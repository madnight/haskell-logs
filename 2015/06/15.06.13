00:07:39 * hackagebot quickcheck-simple 0.0.1.0 - Test properties and default-mains for QuickCheck  http://hackage.haskell.org/package/quickcheck-simple-0.0.1.0 (KeiHibino)
00:07:39 * hackagebot quantfin 0.2.0.0 - Quant finance library in pure Haskell.  http://hackage.haskell.org/package/quantfin-0.2.0.0 (tdees)
00:09:24 <funfunctor> does ByteString.hPut concatenate to the EOF ?
00:09:44 <funfunctor> or do I need to seek to it first
00:10:03 <Axman6> probably depends on the how the handle was opened
00:10:29 <Axman6> if it was opened in AppendMode then it will append. WriteMode (or ReadWrite) may not, you'd have to check
00:17:22 <lpaste> funfunctor pasted ‚ÄúNo title‚Äù at http://lpaste.net/134440
00:17:50 <funfunctor> Axman6: ah AppendMode ok I see thats what I was doing ^
00:26:12 <johnw> template haskell is actually quite fun
00:32:05 <bollu> hey everyone, I'm getting a parse error for using a (<-) after an if I think. I don't know what I'm doing wrong. Help? code is here: http://codepad.org/Swim06tn
00:33:10 <bollu> The error is at the bottom of the file
00:33:40 <Cale> if foo
00:33:43 <Cale>   then bar
00:33:45 <Cale>   else quux
00:33:49 <Cale> ^^ use this layout
00:33:58 <Cale> oh, but also
00:33:58 <bollu> Cale: hm, thanks
00:34:05 <Cale> You need a do in the else branch
00:34:21 <bollu> why?
00:34:41 <Cale> Because each branch of the if-expression must be an expression, not a sequence of statements
00:34:53 <bollu> and in that case, won't my return type become IO IO T.Text?
00:34:56 <bollu> ah
00:35:13 <bollu> wait, how does it compile?
00:35:19 <Cale> Nope, because the if-expression is deciding which IO action to execute
00:35:21 <bollu> shouldn't there be a type error?
00:35:33 <Cale> You didn't write  return $ if ...
00:35:39 <bollu> ohh
00:35:58 <bollu> shouldn't every do block end with a monadic action?
00:36:02 <kadoban> As it is, it's not even getting to the point of a type error. It's too wrong to be a type error. Unless you mean after you fixed what's in the paste.
00:36:05 <Cale> It does :)
00:36:09 <bollu> hm, that _is_ satisfied in both branches of my if!
00:36:13 <bollu> whoa, slick!
00:36:18 <bollu> thanks guys ^_^
00:36:30 <c_wraith> bollu: remember, do blocks are just (long) expressions themselves.
00:37:49 <bollu> c_wraith: right :)
00:37:58 <bollu> Also, can I speed up readWord in any way?
00:39:13 <bollu> http://lpaste.net/2686985416447361024
00:39:25 <bollu> the readWord looks very imperative to me
00:39:30 <bollu> is there a nicer way of writing it?
00:39:39 <bollu> like, it's very "C style let's tokenize a string"-y
00:44:34 <bollu> hm, so, well, is that the "nicest" way to write readWord? http://lpaste.net/2686985416447361024
00:54:34 <lyxia> bollu: T.snoc is pretty inefficient.
00:54:48 <bollu> lyxia: yeah, O(n) I noticed
00:54:54 <bollu> but I wasn't sure what else I could do
00:55:12 <lyxia> Why not work with strings?
00:55:14 <bollu> one thing I did consider was pushing it in with cons O(1) and then calling reverse at the end
00:55:19 <lyxia> "String" I mean
00:55:25 <bollu> lyxia: String has O(1)?
00:55:32 <lyxia> cons is also O(n)
00:55:37 <bollu> :(
00:55:46 <bollu> ah, (:) is O(1) ?
00:55:51 <bollu> ":"
00:55:52 <bollu> *
00:55:58 <lyxia> Indeed
00:56:13 <bollu> lyxia: will try and do that :) Thanks!
00:56:28 <Axman6> you could also use Builders if you want snoc
00:57:37 <lyxia> It's still weird to go through Text if all you're doing is (read . unpack)
00:57:40 <Axman6> but that's probably no better than just using a list and reversing at the end
00:58:01 <Axman6> that too :P
00:58:24 <frerich> bollu: I think you could also use something from Control.Monad.Loops, like (untested) `readWord = T.pack <$> unfoldWhileM (`elem` " \n\t") getChar`
00:58:52 <bollu> frerich: whoa, did not know Control.Monad.Loops exists!
00:59:09 <bollu> frerich: thanks a ton
01:00:38 <bollu> is that a part of Prelude?
01:00:42 <bollu> Control.Monad.Loops?
01:00:49 <bollu> because HackerRank doesn't allow all packages
01:01:03 <ChristianS> bollu: it's a separate package (monad-loops)
01:01:08 <frerich> bollu: No, it's a separate package called 'monad-loops'
01:01:27 <bollu> aww
01:01:46 <muzzle> hi
01:02:09 <muzzle> is there a way to get haskell to detect overlapping instances before they are used in some code ?
01:02:22 <bollu> but that package looks super useful
01:02:26 <frerich> bollu: I think even without that package, your code might be nicer if you have a dedicated function which repeatedly executes some IO action until some predicate is true for the produced value, and then returns all the results.
01:02:32 <mniip> muzzle, unless you use OverlappingInstances that is done automatically
01:02:32 <arkeet> readWord = do { c <- getChar; if isSpace c then return [] else fmap (c :) readWord }
01:02:39 <muzzle> i.e. if i'm writing a library and have some overlapping instances, can I detect that at compile time (before actually using an ambiguous case) ?
01:02:47 <kadoban> bollu: You can avoid manually doing a lot of that if you ‚Ä¶ just 'interact', then you just have to deal with Strings (or Text has a version, ByteString too)
01:02:50 <kadoban> :t interact
01:02:51 <lambdabot> (String -> String) -> IO ()
01:03:06 <mniip> @djinn Arrow a => (x -> y) -> a x y
01:03:06 <lambdabot> Error: Class not found: Arrow
01:03:06 <arkeet> :t let readWord = do { c <- getChar; if isSpace c then return [] else fmap (c :) readWord } in readWord
01:03:07 <lambdabot> IO [Char]
01:03:08 <mniip> aww
01:03:10 <mniip> no arrows
01:03:13 <bollu> kadoban: don't understand what interact does
01:03:33 <arkeet> interact takes a function of String -> String, feeds it stdin, writes the result to stdout
01:03:45 <bollu> ah
01:03:49 <bollu> so, like, a REPL
01:03:59 <kadoban> bollu: You give it a function (String -> String) that takes the input for the program, and converts it to the output.
01:04:02 <frerich> bollu: More like a 'REP'.
01:04:02 <arkeet> not quite, it doesn't have the L.
01:04:06 <mniip> bollu, it lazily reads all stdin, gives it to your function, and then lazily writes all the returned data to stdout
01:04:11 <bollu> hmm, I see
01:04:21 <kadoban> Not really, there's no loop. But you can then use stuff like 'lines', 'words', etc.
01:04:27 <kadoban> :t lines
01:04:28 <lambdabot> String -> [String]
01:04:32 <bollu> right
01:04:34 <bollu> that's slick :D
01:04:37 <arkeet> lines and words and interact are pretty useful for this sort of thing.
01:04:37 <bollu> O
01:04:53 <bollu> I wanted to read from the handle bit by bit
01:05:02 <bollu> but reading the entire thing isn't so bad I guess
01:05:57 <bollu> does haskell have a nice tree library? I wanna do DFS
01:06:09 <muzzle> mniip: http://lpaste.net/134442 in this case it doesn't seem like it
01:06:36 <Axman6> in Haskell, everything is a tree
01:06:55 <bollu> Axman6:g on
01:06:57 <bollu> go on*
01:07:45 <Axman6> most functional data structures are some form of tree. but the actual answer to your question is probably Data.Tree
01:08:20 <bollu> how do you know if a module is a part of Prelude or not?
01:08:25 <bollu> is Data.Tree a part of prelude?
01:09:44 <kadoban> bollu: Easiest way is to just try to import it, I've found, heh. hackerrank will give you an error if it's not in their packages.
01:09:56 <bollu> kadoban: cool, thanks!
01:10:21 <muzzle> mniip do you have any idea how i can get the compiler to throw a compile error in my example ?
01:11:18 <bollu> kadoban: nice, it does have data.tree! thanks
01:11:42 <kadoban> 'welcome :)
01:13:48 <alisia> is there any program that can convert an html template into a hamlet template?
01:15:55 <mniip> hmm
01:16:13 <mniip> can't seem to figure this out
01:16:33 <mniip> (Arrow p, Applicative m) => p s (s, m (a -> b)) -> p s (s, m a) -> p s (s, m b)
01:16:38 <pacak> alisia: vim?
01:17:14 <alisia> pacak, Vim? I use Vim. But how?
01:17:37 * hackagebot trurl 0.2.0.0 - Haskell template code generator  http://hackage.haskell.org/package/trurl-0.2.0.0 (dbushenko)
01:17:38 <mniip> he's suggesting you do it by hand
01:17:48 <pacak> By manually changing required stuff. hamlet template is something very specific.
01:18:03 <pacak> html template in general can be anything
01:19:53 <pacak> mniip: What's the problem with that arrow-applicative stuff?
01:19:53 <alisia> pacak, mniip, Ok, may I can try by just removing all the closing tags. Will that work?
01:20:08 <mniip> pacak, can't seem to figure out an implementation
01:20:24 <pacak> alisia: That + changing how external stuff is embedded + formatting in general
01:20:25 <mniip> actually
01:20:35 <mniip> (Arrow p, Applicative m) => p s (s', m (a -> b)) -> p s' (s'', m a) -> p s'' (s''', m b)
01:20:43 <mniip> because that's how it should be chained
01:26:36 <pacak> mniip: From type signature I see how can apply Applicative part, but not what you are doing with s
01:27:38 <mniip> oops
01:27:43 <mniip> I overdid it
01:28:20 <mniip> (Arrow p, Applicative m) => p s (s', m (a -> b)) -> p s' (s'', m a) -> p s (s'', m b)
01:29:04 <bollu> Question: if I have f: a-> b, then if I have [a], it's easy to map and get [b]. However, if I have [[a]], how do I get [[b]]?
01:29:30 <mniip> bollu, map (map f)
01:29:44 <pacak> fmap . fmap
01:29:51 <bollu> mniip: really? Hm, I'll need to sit and think about the types
01:30:10 <mniip> @let f = const undefined
01:30:11 <lambdabot>  Defined.
01:30:12 <mniip> :t f
01:30:13 <lambdabot>     Ambiguous occurrence ‚Äòf‚Äô
01:30:13 <lambdabot>     It could refer to either ‚ÄòL.f‚Äô,
01:30:13 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:141:1
01:30:32 <pacak> :t first const . second (<*>)
01:30:33 <lambdabot> Applicative f => (b, f (a -> b2)) -> (b1 -> b, f a -> f b2)
01:30:50 <bollu> pacak: is there an "intuitive" explanation for this?
01:31:20 <mniip> pacak, you meant <<<
01:31:28 <mniip> or
01:31:45 <mniip> :t function
01:31:46 <lambdabot> b -> a
01:31:48 <mniip> :t map function
01:31:49 <lambdabot> [b1] -> [b]
01:31:49 <pacak> bollu: Hmmm... You have a container type, fmap works over that container. Since you have two levels - you need two fmaps.
01:31:52 <mniip> :t map (map function)
01:31:53 <lambdabot> [[b1]] -> [[b]]
01:32:05 <pacak> bollu: map is specialized fmap for lists.
01:32:15 <pacak> :t fmap . fmap
01:32:16 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:32:17 <bollu> pacak: cute :) thanks!
01:32:18 <bollu> pacak: yep, I'm aware of that
01:32:24 <bollu> so, if I have IO Maybe Int
01:32:33 <bollu> to  target the "int", I'd use fmap . fmap ?
01:32:40 <mniip> that's a malformed type
01:32:48 <bollu> Maybe IO Int*
01:32:52 <mniip> still malformed
01:32:55 <bollu> why?
01:33:00 <pacak> fmap . fmap will still work. As long as it's (Maybe (IO Int))
01:33:12 <mniip> ^ you missed some parentheses probably
01:33:12 <bollu> mniip: why is it malformed?
01:33:18 <bollu> isn't it implied?
01:33:29 <mniip> no?
01:33:43 <bollu> why not? Maybe can only take one more type (kind is * -> *), so should IO
01:33:47 <bollu> so IO consumes the Int
01:33:52 <bollu> and Maybe consumes the IO Int ?
01:34:14 <mniip> hmm
01:34:26 <mniip> I can't come up with a non-polykinded example right now,
01:34:29 <mniip> but there probably is one
01:34:31 <pacak> mniip: Yea, one of those. I haven't used arrows for anything other that tuples for a  while.
01:34:46 <bollu> mniip: alright :) 
01:35:15 <bollu> mniip: can you give me an example where it isn't obvious?
01:35:26 <bollu> any examples
01:35:40 <Cale> bollu: StateT Int IO String
01:35:50 <Cale> :k StateT
01:35:54 <lambdabot> * -> (* -> *) -> * -> *
01:35:56 <pacak> :k CofreeT
01:35:56 <Cale> :k Int
01:35:57 <lambdabot>     Not in scope: type constructor or class ‚ÄòCofreeT‚Äô
01:35:58 <lambdabot> *
01:36:00 <pacak> :(
01:36:03 <Cale> :k IO
01:36:04 <lambdabot> * -> *
01:36:18 <bollu> hm
01:36:35 <bollu> so that would be (StateT (Int) (IO) (String)) correct?
01:36:42 <Cale> bollu: I don't know about "not obvious", but there are definitely cases where you want to pass a type constructor as an argument to another type constructor
01:36:55 <Cale> ((StateT Int) IO) String
01:36:55 <pacak> bollu: That's probably too much parens...
01:37:05 <bollu> Cale: I see. I haven't encountered this. 
01:37:07 <Cale> Function application always associates to the left
01:37:14 <bollu> Cale: ahh, right 
01:37:15 <Cale> Both in types and in expressions
01:37:38 * hackagebot trurl 0.2.1 - Haskell template code generator  http://hackage.haskell.org/package/trurl-0.2.1 (dbushenko)
01:37:42 <bollu> that's interesting!
01:37:48 <Cale> :k StateT Int
01:37:49 <frerich> Cale: That reminds me - what would be the kind of 'Maybe (Maybe a)'? Plausible answers I considered seem '* -> *' (because you still need one type to produce a '*') or '*' (because the outermost type constructor has no variables) or maybe 'this has no kind because of reasons'. :-}
01:37:50 <lambdabot> (* -> *) -> * -> *
01:37:52 <Cale> :k StateT Int IO
01:37:52 <bollu> there's so much to learn 
01:37:52 <lambdabot> * -> *
01:37:55 <Cale> :k StateT Int IO String
01:37:56 <lambdabot> *
01:38:07 <Cale> * is the kind of types which have values in them
01:38:25 <Cale> frerich: That has kind *
01:38:28 <frerich> Ah... so 'Maybe (Maybe a)' is of kind '*' because it has a 'Nothing' value.
01:38:35 * frerich nods
01:38:46 <bollu> Cale: but it is still polymorphic?
01:38:53 <Cale> bollu: Which?
01:38:58 <bollu> Maybe (Maybe a))
01:39:21 <Cale> Ah, well, depends on how you read it. If you write a type signature in Haskell like  foo :: Maybe (Maybe a)
01:39:40 <mniip> frerich, not because of nothing
01:39:50 <Cale> The free type variable is automatically captured and forall'd, i.e. it's the same as if you wrote  foo :: forall a. Maybe (Maybe a)
01:39:51 <mniip> but because a is a free variable
01:40:12 <mniip> (Identity a) :: * just as well
01:40:31 <Cale> However, with the ScopedTypeVariables extension turned on, this doesn't always happen.
01:41:10 <Cale> 'a' might be a type variable which is in scope because it was explicitly bound by a forall in an outer scope
01:41:40 <Cale> In which case, the type expression still has kind *, just for a slightly different reason
01:41:41 <bollu> Question - I'm writing a DFS on a grid. And, well, I need the computation to stop in case my index exits the board. I know vaguely that something related to State and guard can be used here. Could someone clarify this for me?
01:41:48 <bollu> I've also never used the State monad up until now.
01:41:49 <mniip> Cale, are you familiar with Arrow?
01:41:54 <Cale> mniip: yes
01:42:04 <mniip> (Arrow p, Applicative m) => p s (ss, m (a -> b)) -> p ss (sss, m a) -> p s (sss, m b)
01:42:20 <mniip> any ideas about the inhabitant of the above type
01:42:38 * hackagebot trurl 0.2.2.0 - Haskell template code generator  http://hackage.haskell.org/package/trurl-0.2.2.0 (dbushenko)
01:43:33 <bollu> can anyone explain to me how to use guard?
01:43:36 <seawisegiant> 1 + 1
01:43:48 <Cale> hang on, let me rewrite that for myself... (Arrow (~>), Applicative f) => (s ~> (s', f (a -> b))) -> (s' ~> (s'', f a)) -> (s ~> (s'', f b))
01:43:55 <mniip> right
01:44:54 <mniip> > do x <- [1..10]; y <- [1..10]; guard $ x == y * y; return (x, y) -- bollu
01:44:56 <lambdabot>  [(1,1),(4,2),(9,3)]
01:45:07 <bollu> :O that is *magic*
01:45:35 <seawisegiant> I need to split a list of strings to list of lists where those strings are split by some delimeter
01:45:39 <eds> *Main> run [1,2,3] 0 1.2 [*** Exception: gentestList.hs:(21,1)-(29,21): Non-exhaustive patterns in functi on evala. How do I solve this error? http://lpaste.net/132328
01:45:43 <bollu> no way, guard is a haskell function?
01:45:45 <seawisegiant> I've come up with function of type splitOnList :: String -> [String] -> [[String]]
01:45:54 <Cale> :t let foo f g = proc s -> do (s',ff) <- f -< s; (s'', fx) <- g -< s'; returnA -< (s'', ff <*> fx) in foo
01:45:55 <lambdabot> parse error on input ‚Äò->‚Äô
01:45:58 <Cale> tsk
01:46:03 <seawisegiant> looks a bit weird, is it okay type?
01:46:30 <Cale> mniip: anyway, there you go
01:46:35 <pacak> eds: GADTs?
01:46:47 <mniip> Cale, ‡≤†_‡≤†
01:46:52 <eds> yes!
01:47:01 <eds> pacak
01:47:10 <mniip> Cale, I was hoping for a combinatoric solution
01:47:15 <lyxia> bollu: Many things are done with just functions in Haskell. State too is just functions behind a newtype.
01:47:18 <frerich_> seawisegiant: I think that might be just 'splitOnList sep = map . splitOn sep' (where 'splitOn' is from Data.List.Split)
01:47:26 <Cale> mniip: Feel free to unfold the proc/do notation
01:47:31 <bollu> lyxia: how does that work?
01:47:34 <mniip> I'll need to google that
01:47:40 <Cale> mniip: It's painful
01:47:46 <mniip> I guess
01:48:04 <bollu> Cale: proc is a keyword?
01:48:12 <Cale> bollu: Yeah, in the Arrow syntax extension
01:48:48 <seawisegiant> frerich_, I beg I've tried to do that first, but have a type complaints
01:48:55 <Cale> bollu: It binds a variable representing the input to the Arrow computation, which normally you'd have no way to give a name to.
01:49:07 <bollu> Cale: do not know what arrows are
01:49:18 <seawisegiant> so I've come up with recursive function
01:49:22 <seawisegiant> splitOnList :: String -> [String] -> [[String]]
01:49:23 <seawisegiant> splitOnList delimiter [] = []
01:49:23 <seawisegiant> splitOnList delimiter (x:xs) = listToUser (splitOn delimiter x) : splitOnList delimiter xs
01:49:24 <bollu> except that they have some relation with tuples and are a weaker form of monads I think
01:49:36 <pacak> eds: You are not exactly using them. And the problem is that you are trying to pass value of some type to a function that can't handle it.
01:50:11 <bollu> is State an instance of MonadPlus?
01:50:15 <lyxia> bollu: A stateful computation can be represented by a function whose domain is the type of states, and you represent mutation by having that function return a new state along with the result: s -> (a, s), that's (basically) State a
01:50:16 <Cale> bollu: It's another abstraction over a certain sort of combinator libraries like Monad is, yeah
01:50:28 <lyxia> bollu: State s a
01:50:48 <bollu> lyxia: hmm
01:50:48 <eds> am I not distinguishing them as Arith, List and Comp,Logic?
01:50:49 <frerich_> seawisegiant: Sorry, I meant 'map (splitOn sep)' instead of 'map . splitOn sep'
01:50:51 <Cale> bollu: State s isn't an instance of MonadPlus, but StateT s m is an instance whenever m is.
01:51:52 <frerich_> seawisegiant: I.e. 'splitOnList delimiter = map (splitOn delimiter)'.
01:54:17 <seawisegiant> thanks, frerich_, it works, seems I need to dig more about function application
01:57:39 * hackagebot aivika-experiment 4.0.3 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-4.0.3 (DavidSorokin)
01:59:25 <bollu> haskell doesn't define flatMap because (>>=) is equivalent?
01:59:54 <mniip> :t concatMap
01:59:55 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
02:00:02 <bollu> hm
02:00:04 <bollu> thanks guys
02:02:35 <Cale> Also, even if you write concat (map f xs), with optimisations on, you can generally expect that to produce the same code as concatMap f xs
02:02:39 * hackagebot aivika-experiment-chart 4.0.3 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-4.0.3 (DavidSorokin)
02:02:58 <Cale> (even though it appears as if there's an intermediate list, foldr/build fusion will remove that)
02:04:02 <ags> Does anyone have any recommendations around nicely converting values "$123.00" into a decimal? This is in the context of a FromField instance using Data.Csv, so the String is a ByteString, if that has any impact.
02:04:13 <bollu> how do you replace at an index in a haskell list?
02:05:10 <bollu> http://stackoverflow.com/questions/5852722/replace-individual-list-elements-in-haskell <- this seems to suggest using Lens
02:05:14 <bollu> is that the right way to go?
02:06:30 <lyxia> If it's an operation you do rarely you can write it quickly with splitAt.
02:06:57 <bollu> :t splitAt
02:06:58 <lambdabot> Int -> [a] -> ([a], [a])
02:08:21 <bollu> lyxia: I'm trying to modify a 2d array
02:08:24 <bollu> which is not going well :|
02:08:39 <bollu> setIndex l index new = left ++ [new] +++ right where (left, right) = splitAt l index
02:08:42 <bollu> the 1D case is easy
02:08:56 <bollu> but.. how do I give the "new" value for the 2d case? It's going to require some weird nesting
02:09:15 <arkeet> there's a better way to do the 1d case.
02:09:20 <arkeet> that might help.
02:09:23 <bollu> arkeet: go on
02:09:30 <arkeet> but
02:09:33 <bollu> yes?
02:09:45 <arkeet> ok, one observation.
02:09:53 <arkeet> if you have a function for modifying an element of a list
02:09:54 <arkeet> by a function
02:10:08 <arkeet> then you can use it twice to do it for a list of lists.
02:10:32 <bollu> arkeet: but I'm modifying only _
02:10:43 <arkeet> anyway.
02:10:56 <bollu> arkeet: yes?
02:11:01 <mniip> Cale, I think I'm getting somewhere
02:11:01 <arkeet> that's probably the best way to do it for a list of lists, actually.
02:11:02 <mniip> \f k -> f >>> _k k
02:11:20 <arkeet> something like
02:11:28 <arkeet> modify :: Int -> (a -> a) -> [a] -> [a]
02:11:51 <arkeet> ok let's not call it modify.
02:12:18 <mniip> arkeet, endoMap
02:12:29 <bollu> mniip: :( what?
02:12:45 <bollu> arkeet: so, well, what do we name it?
02:12:47 <mniip> endoMap sounds like a fitting name for that type signature
02:12:58 <mniip> ohh, there's an index given too
02:13:00 <mniip> nevermind then
02:13:06 <arkeet> mniip: no, it only modifies a single elemnt.
02:13:08 <arkeet> okay I made one.
02:13:09 <arkeet> :t foo
02:13:10 <lambdabot> Int -> (a -> a) -> [a] -> [a]
02:13:15 <arkeet> > foo 2 (+1) [0,0,0,0,0]
02:13:16 <lambdabot>  [0,0,1,0,0]
02:13:23 <bollu> hm
02:13:27 <arkeet> and then you can
02:13:31 <mniip> @src foo
02:13:31 <lambdabot> Source not found. Just try something else.
02:13:51 <bollu> modify index l f = left ++ [f new] ++ right where (left, right) = splitAt l index
02:13:58 <bollu> ^ I assume that works?
02:14:06 <arkeet> I guess so. that's not how I did it though.
02:14:10 <arkeet> anyway, the point is
02:14:16 <arkeet> @let example = replicate 3 (replicate 3 0))
02:14:16 <lambdabot>  Parse failed: Parse error: )
02:14:19 <arkeet> @let example = replicate 3 (replicate 3 0)
02:14:20 <lambdabot>  Defined.
02:14:21 <arkeet> > example
02:14:22 <lambdabot>  [[0,0,0],[0,0,0],[0,0,0]]
02:14:27 <lyxia> where (left, _ : right) = splitAt l index -- bollu
02:14:36 <arkeet> > foo 1 (foo 2 (+1)) example
02:14:37 <lambdabot>  [[0,0,0],[0,0,1],[0,0,0]]
02:14:39 <bollu> lyxia: ah
02:14:43 <arkeet> this sort of thing.
02:14:44 <bollu> whoaa
02:14:47 <bollu> that is _awesome_
02:15:00 <arkeet> if you just want to set, you can give it a constant function.
02:15:04 <arkeet> > foo 1 (foo 2 (const 5)) example
02:15:06 <lambdabot>  [[0,0,0],[0,0,5],[0,0,0]]
02:15:19 <arkeet> I can rewrite this as
02:15:23 <arkeet> > (foo 1 . foo 2) (const 5) example
02:15:25 <lambdabot>  [[0,0,0],[0,0,5],[0,0,0]]
02:15:27 <bollu> how do you guys come up with such cool ideas / abstractions? ^_^
02:15:41 <bollu> arkeet: thanks a ton :) 
02:15:41 <lyxia> bollu: actually we're modifying the previous element so we shouldn't discard the middle element: left ++ [f middle] ++ right where (left, middle : right) = ...
02:15:53 <arkeet> well, this idea comes from lens sort of.
02:16:14 <arkeet> anyway, I don't really like using splitAt to implement it.
02:16:24 <bollu> arkeet: what would you suggest?
02:16:36 <arkeet> because first you split and then you concatenate, which traverses the first piece twice sort of.
02:16:43 <arkeet> want to see my definition of foo, then?
02:16:49 <bollu> yes, please
02:17:00 <arkeet> foo :: Int -> (a -> a) -> [a] -> [a]; foo _ _ [] = []; foo 0 f (x:xs) = f x : xs; foo n f (x:xs) = x : foo (n-1) f xs
02:17:24 <seawisegiant> what's the most used database engines with Haskell?
02:17:54 <seawisegiant> for example for C# it's MSSQL, Oracle for Java, MongoDB for Node.js
02:17:59 <arkeet> here's another way:
02:18:02 <seawisegiant> MySQL with PHP
02:18:18 <bollu> arkeet: I shall stare at that type signature until I get it
02:18:22 <arkeet> foo n f xs = map (\(i,a) -> if i == n then f a else a) (zip [0..] xs)
02:18:31 <arkeet> wait.
02:18:34 <arkeet> that can just be a zipWith.
02:18:39 <mniip> Cale, (s ~> (s', f a)) -> ((s, f a -> f b) ~> (s', f b))
02:18:40 <mniip> ideas?
02:18:50 <arkeet> foo n f xs = zipWith (\i a -> if i == n then f a else a) [0..] xs
02:18:58 <arkeet> okay this is best.
02:19:56 <bollu> arkeet:  the zipWith version makes sense
02:20:45 <bollu> thanks a lot
02:21:12 <arkeet> (of course you can drop the xs from both sides.)
02:21:44 <bollu> arkeet: I prefer it with. Makes it clearer
02:22:35 <arkeet> sure, that's why I left it on.
03:12:51 <freeman42> anyone know how to uninstall haskell platform on linux (Linux Mint)? a search for it returns: [Haskell-cafe] Uninstall Haskell Platform on Mac OS X hehe, I installed it a while ago from the downloaded binaries and it added some stuff all over the place so I am not sure what to remove
03:13:16 <freeman42> this is for getting a clean state and then getting ghc 7.8.4 installed instead
03:18:45 <mniip> Cale, hey
03:18:58 <mniip> \f k -> f >>> second (arr (<*>)) >>> first k >>> arr (\((s, a), b) -> (s, b a))
03:19:18 <mniip> not sure if there's a way to avoid this retupleing
03:21:42 <mniip> aha
03:21:42 <mniip> uncurry (flip fmap)
03:57:15 <epta> Is there a way to suppress syntastic (hlint?) error "'ghc-options: -Werror' makes the package very easy to break with future GHC versions because new GHC versions often add new warnings." ?
03:57:49 <edwardk> epta: removing the option? =)
03:58:03 <edwardk> cabal makes the complaint
03:58:10 <edwardk> hackage refuses the upload
03:59:35 <epta> edwardk: hm, I didn't know that hackage could refuse cabal file with such ghc-options
03:59:38 <latk> does anyone have any info on the progress of overloaded record fields?
04:00:01 <latk> i remember there was some talk about it a few months ago, wondered if anything had happened since.
04:04:31 <hvr> epta: you can still guard the -Werror via cabal flags (that's what many packages do)
04:04:56 <hvr> latk: Hackage has a few more additional sanity checks on upload
04:05:08 <hvr> latk: it's related to 'cabal check'
04:06:09 <epta> hvr: yep, good point, thanks
04:06:23 <hvr> s/latk/epta/
04:06:50 <latk> hvr: I presumed as much :)
04:06:54 <hvr> =)
04:13:51 <mniip> edwardk: !
04:14:05 <edwardk> mniip: ?
04:14:08 <mniip> Distributive along with Traversable can be used to provide default implementations of most of the mtl!
04:14:15 <edwardk> yes
04:14:29 <edwardk> many of the mtl monads are about trivial applications of laws
04:14:38 <mniip> the only issue is StateT
04:14:40 <edwardk> readerT/writerT are both distributive laws in action
04:14:45 <edwardk> stateT is a different technique
04:14:48 <edwardk> so is ContT
04:16:02 <edwardk> StateT s a comes from (,) e -| (->) e    , F -| G  means GF is a monad. but so is GMF for a monad M -- this is a way to just 'compose adjoints'
04:16:37 <edwardk> here we're using the distributive laws for (,) e    and (->) e   on the two halves of the adjunction respectively
04:17:07 <edwardk> when you get GFGF you can collapse the inner FG to identity
04:17:58 <mniip> hmm
04:18:03 <mniip> this is different from my approach
04:18:13 <edwardk> yes, but its the way StateT works =)
04:18:21 <lolisa> anybuddy here? I am a bit confused about polarization, positive type negative type stuff, do anybody know what they mean?
04:18:23 <edwardk> not every monad transformer comes from a distributive law
04:18:57 <mniip> edwardk, I managed to generalize StateT to p s (s, m a)
04:19:04 <lolisa> what they mean -> how they work
04:19:08 <mniip> where p is ArrowApply (only Arrow is needed for Applicative btw)
04:19:22 <edwardk> that isn't StateT
04:19:30 <edwardk> you need the m outside of the state
04:19:38 <edwardk> the state can depend on the results of the inner 'm' actions
04:19:47 <mniip> you can get a monad outside of the state if p is a Kleisli
04:20:07 <edwardk> hen you have another problem, check your laws again
04:20:26 <edwardk> the extra 'm a' is problematic, you have no distributive laws to keep it there
04:20:39 <mniip> brb
04:21:16 <haskell701> when use ghci -i option to set directory search paths, :load works for modules but not for files.  is this how this works? 
04:26:23 <mniip> edwardk, back
04:26:35 <haskell701> i mean :load A, where A is some module in a file A.hs in the search path set with -i option for ghci, works fine.  but :load B.hs, which is just a source file in the search path doesn't work.  is this how ghci handles this or am i not understanding something?
04:31:18 <voidzero> this is pretty fantastic - https://tmp28.tmpnb.org/user/gJFBWpzYQIbH/notebooks/Welcome%20to%20Haskell.ipynb
04:34:15 <mniip> edwardk, you're right, either m is Traversable, in which case we just use the traversable monad, or (p s) is Distributive
04:34:20 <mniip> either of which defeats the point
04:35:21 <edwardk> the point of a monad transformer is to act as a 'module over all monads' it generates a monad for each monad its given, without caring about the properties of m beyond 'is a monad'
04:36:49 <mniip> edwardk, nonono
04:37:19 <mniip> by traversable monad I mean a type constructor that takes a traversable and returns a monad transformer
04:38:07 <edwardk> T t m a = m (t a) -- for a traversable t?
04:38:42 <edwardk> that isn't a monad transformer either, see the commutative monad conditions on ListT
04:39:22 <mniip> edwardk, no guarantees that it produces a law-conforming monad transformer for any t
04:39:34 <edwardk> m (e, a) -- is a monad because every functor 'm' in haskell is strong (e, m a) -> m (e, a)
04:39:47 <mniip> however it does work for T Maybe
04:39:53 <mniip> or T (Either e)
04:39:54 <edwardk> the general construction on the other hand doesn't hold
04:40:20 <edwardk> yes, each of which is 'affine' in a, its 'a or something else that doesn't involve a'
04:40:35 <mniip> aka boring
04:40:38 <edwardk> traversable is about having potentially many a's that is what hoses you
04:41:22 <edwardk> there is a paper by mark p jones from 1993 or so where he goes into ways to compose monads and pointed functors using a distributive law
04:41:28 <edwardk> it is a precursor to monad transformers
04:41:35 <edwardk> you've rediscovered part of it
04:42:23 <phaazon> hm
04:42:31 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.42.2605&rep=rep1&type=pdf
04:42:38 <phaazon> I wonder whether I should give a try to Rust
04:43:57 <srhb> phaazon: There are some Rust users in #haskell-blah
04:44:08 <phaazon> cool, I‚Äôll go ask there then
04:54:43 <mniip> edwardk, do you know any 'const id'-like newtypes off the top of your head?
04:54:47 <mniip> basically the dual of Const
04:56:31 <edwardk> :t Tagged
04:56:32 <lambdabot> Not in scope: data constructor ‚ÄòTagged‚Äô
04:56:39 <edwardk> :t Data.Tagged.Tagged
04:56:40 <lambdabot> forall (k :: BOX) (s :: k) b. b -> Data.Tagged.Tagged s b
04:56:55 <edwardk> that?
04:57:04 <edwardk> its in my tagged package
05:00:50 <mniip> hmm
05:01:10 <mniip> yeah
05:01:13 <mniip> that works
05:18:52 <igniting> Can someone help me with this: http://lpaste.net/134448 ?
05:19:58 <mniip> igniting, looks like you want your class to be *->* kinded
05:19:58 <srhb> igniting: What's the class supposed to do?
05:20:19 <mniip> class F g where f :: g a -> a -> g a
05:21:29 <mniip> also pretty certain you can achieve this with Functor
05:21:35 <mniip> :t flip (<$)
05:21:36 <lambdabot> Functor f => f b -> a -> f a
05:23:54 <igniting> mniip: thanks!
05:37:08 <Hi-Angel> Does anybody know, how to enable `lambdabot` in ghci? I installed it with my package manager, but couldn't find how to run it within ghci :/
05:37:42 <Hi-Angel> The lambdabot page says it is available as an extension to ghci
05:41:04 <Hi-Angel> Or, on the other side, perhaps anybody knows, how to load a file into lambdabot?
05:47:49 * hackagebot record 0.4.0.1 - Anonymous records  http://hackage.haskell.org/package/record-0.4.0.1 (NikitaVolkov)
05:48:24 <Cale> Hi-Angel: I'm not sure what that remark is referring to
05:49:24 <dramforever> maybe :!lamdabot :)
05:49:24 <edwardk> Hi-Angel: there used to be some ghci magic you could set up that would let you use some lambdabot commands from the ghci command prompt, but i have no idea whatever happened to that stuff
05:49:34 <Cale> Hi-Angel: Perhaps goa?
05:49:36 <dramforever> :P
05:50:08 <Hi-Angel> Oh, finally, I got, how to enable it. There's one article, not very informative, but from trial and errors I found the way: install with cabal either with package manager `lambdabot`, then install `goa` (the last is an extension to ghci), then import `m + GOA`, then one can use lambdabot functions by defining them like `:def pl lambdabot "pl"`
05:51:00 <Hi-Angel> Then one can use that `pl` like `pl: <arguments>`
05:51:05 <Hi-Angel> *:pl
05:52:39 <kyubiko> this is probably a dumb question, but I want to learn haskell, and learn best when I have an actual project to work on. Can someone tell me any common interesting beginner projects?
05:54:05 <dfeuer> kyubiko, try writing an interpreter for a simple language.
05:54:11 <dfeuer> That's common.
05:54:23 * dfeuer goes back to sleep.
05:55:11 <kyubiko> hmm
05:55:19 <kyubiko> I guess I could try writing a scheme or something
05:55:19 <kyubiko> thanks
05:55:34 <dramforever> kyubiko: there's exactly a tutorial on that
05:55:52 <dramforever> called something like "write your scheme in 48 hours"
05:56:06 <dramforever> it's on wikibooks
05:58:31 <magneticDuck> kyubiko: yes, those 48 hours are back to back
05:58:42 <magneticDuck> the tutorial directs you to not sleep until you're finished
05:58:57 <silver> :)
05:59:19 <dramforever> kyubiko: actually you can sleep if you concentrate enough and you are able to understand haskell well
06:00:18 <kyubiko> I think I might do a bit of sleeping
06:00:28 <kyubiko> I've got school on monday
06:00:45 <kyubiko> don't want to be *too* sleep deprived
06:03:27 <Hi-Angel> Does anybody know, how to enter a multiline  function to lambdabot?
06:04:26 <magneticDuck> excerpt from hour 35: "Your eyes now hurt too much to keep them open for longer than a few seconds at a time. There's still some sort of problem with the parser; you decide in retrospect that it was a bad idea to hand-roll it as a single fold, but it's too late to go back now."
06:04:39 <pingu> Hi-Angel: you could probably just write a case statement?
06:04:51 <monochrom> add {;}
06:04:53 <pingu> And if you actually want to dump code into lambdabot your use case is probably not what it was intended for ;)
06:05:08 <pingu> oh, I didn't realize {;} worked, nice.
06:07:01 <Hi-Angel> monochrom, ¬´undo {fact n = do¬ª ‚Üí ¬´<unknown>.hs: 1: 1:Parse error: {¬ª No, that didn't work. With semicolon, or without‚Ä¶
06:07:28 <nschoe> pingu, sorry for asking... does your name have anything to do with the cartoon with the penguin? I'm sorry to ask, really but it brings back so much memories ^^
06:07:37 <pingu> Hi-Angel: for a do you could just unsuger it, Id' find that easier to read.
06:07:43 <pingu> (if your intention is to show code to someone)
06:08:04 <monochrom> what is "fact = " doing there?
06:08:24 <pingu> nschoe: yup, noot noot: https://www.youtube.com/watch?v=a4VvRWTD3Ok
06:08:35 <monochrom> and why is "{" before "do", not after?
06:08:59 <nschoe> pingu, OMG you just made my day ^^
06:09:14 <Hi-Angel> pingu, that's the problem ó I have a code from tutorial with do monad, and I couldn't understand where is the (>>=) operaion appears there. All code looks to me like abosolute nonsense. So I wanted to find something that unroll that do-notation to me, that's why I need a lambdabotÖ
06:10:01 <monochrom> @undo do { x <- m; return (x+1) }
06:10:01 <lambdabot> m >>= \ x -> return (x + 1)
06:10:05 <monochrom> worksforme
06:10:32 <Hi-Angel> HmÖ Okay, I'll try
06:10:35 <monochrom> I don't know what's with "fact n =" and what's with putting "{" at the wrong place so as to tell me "doesn't work"
06:10:38 <pingu> Hi-Angel: you can just ask that kind of thing here
06:10:46 <pingu> people are happy to help you understand
06:10:59 <pingu> the newlines in do notation just become >>
06:11:10 <pingu> (which is >>= \_ ->)
06:11:30 <voidzero> all code looks like absolute nonsense
06:11:31 <pingu> and the little left arrows (assignment in pseudo-code)
06:11:32 <voidzero> i love that about haskell
06:11:34 <voidzero> <3
06:11:37 <pingu> becomes >>=
06:12:00 <pingu> (which is monad_a >>= \x being the sames as x <- monad_a
06:12:12 <Hi-Angel> pingu, well, there are things like ´letª and ´ifª, so it makes it hard. But I'll try once more with bot, if it won't work, I'll askÖ
06:12:26 <dramforever> voidzero: again, you mean abstract nonsense
06:12:33 <pingu> Hi-Angel: gist is good if you just want to dump code
06:12:35 <dramforever> :)
06:12:47 <voidzero> i was repeating Hi-Angel, but yes probably
06:12:56 <dramforever> :)
06:13:19 <magneticDuck> :>
06:13:25 <magneticDuck> :-
06:13:26 <voidzero> or clownesk nonsense!
06:13:33 <voidzero> all those silly operators.
06:14:49 <dramforever> yeah operators make some feel weird
06:15:29 <voidzero> Hi-Angel, btw i was not making fun of you. I had to laugh at what you said because i can relate, sometimes I still feel like that too.
06:15:43 <voidzero> yes dramforever exactly :)
06:15:48 <Hi-Angel> ‚ò∫
06:17:05 <pingu> Hi-Angel: I can barely see that with terminus.
06:17:28 <pingu> Is it a little sad thing, or is it a little happy thing?
06:17:34 <dramforever> happy
06:17:34 <Hi-Angel> pingu, üòù
06:17:48 <Hi-Angel> I have many such things in my XCompose :)
06:17:53 <pingu> Aaah, techology these days is so *great* ;)
06:18:11 <voidzero> the 24 point version works
06:18:18 <voidzero> erm
06:18:20 <voidzero> shows it
06:18:24 <voidzero> i gotta dash
06:18:45 <pingu> 24 point terminus version?
06:19:00 <voidzero> yeah that one displays it properly
06:19:12 <pingu> I just have terminus-font on arch.
06:19:26 <voidzero> but size 14 makes it a bit too small
06:19:29 * dramforever has every single unicode char with his unicode table program
06:19:46 <dramforever> even if he couldn't see it because of the font
06:19:57 <pingu> Evidently, the problem is not that we are trying to convey emotion through tiny single characters.
06:20:03 <pingu> It is in fact that our screens are not large enough.
06:25:06 <terminal_fee> Any purpose FREE storagewith PHP5 + MySQL, Script Testing, Personal, and more! at https://www.criosphinx.net/free/
06:25:07 <terminal_fee> Any purpose FREE storagewith PHP5 + MySQL, Script Testing, Personal, and more! at https://www.criosphinx.net/free/
06:25:17 <terminal_fee> Any purpose FREE storagewith PHP5 + MySQL, Script Testing, Personal, and more! at https://www.criosphinx.net/free/
06:25:51 <ion> >offering PHP hosting on #haskell
06:25:57 <zomg> Someone should whip up a script to generate accounts there and then fill it with junk
06:26:08 <ion> Next up: offering Haskell hosting on #php
06:27:27 <dramforever> that looks like a good place to do non-sensitive number crunching
06:27:29 <dramforever> :P
06:40:54 <magneticDuck> wow, good thing he said it 3 times
06:40:57 <magneticDuck> I might not have caught
06:40:59 <magneticDuck> it
06:41:58 <dramforever> it's particularly interesting because why would anyone who know haskell think we want php hosting
06:42:12 <dramforever> s/know/knows
06:42:32 <saulzar_> Well I've been looking all over for some PHP hosting, and I couldn't find it anywhere
06:48:11 <hodapp> saulzar_: have you tried looking on the Internet?
06:48:22 <tomjaguarpaw> How do I get 'cabal install' to show me which modules it is compiling as it installs packages?
06:48:38 <dramforever> -j1
06:48:57 <Cale> tomjaguarpaw: That's the default behaviour...
06:49:09 <dramforever> Cale: no
06:49:17 <Cale> no?
06:49:26 <dramforever> what's the last time you updated cabal-install?
06:49:40 <Cale> I dunno, a couple weeks ago?
06:49:45 <dramforever> weird
06:50:08 <tomjaguarpaw> I removed .cabal and reinstalled and I lost the per-module progress.
06:50:20 <dramforever> tomjaguarpaw: try -j1
06:50:59 <tomjaguarpaw> It's a threading setting?
06:51:23 <dramforever> dunno
06:51:38 <dramforever> well, cabal might be spawning multiple jobs
06:51:59 <dramforever> so per module progress is disabled to avoid weird output
06:52:12 <dramforever> Cale: so...how "good" is your computer?
06:52:55 <ion> dramforever: It‚Äôs Turing-complete.
06:52:56 <saulzar_> hodapp, Hehe. That was somewhat my point
06:53:38 <hodapp> ion: mine's not really a Turing-machine... it has only a finite number of states due to the finite storage.
06:53:43 <dramforever> ion: I'm amused by how you ignored the context completely
06:53:59 <seawisegiant> I'm trying to make single IO action and a bunch of them in the same row
06:54:05 <seawisegiant> putStrLn $ "ARGS: " >>= mapM putStr args
06:54:20 <seawisegiant> but, can't achieve that
06:54:25 <seawisegiant> is it possible?
06:54:26 <Cale> dramforever: Not sure what you're asking. It's an i5 with 4 cores.
06:54:34 <ion> That is parsed as: putStrLn ("ARGS: " >>= mapM putStr args)
06:54:41 <dramforever> 1. $ is not working as intended, because it has the lowest precedence
06:54:46 <seawisegiant> hmm
06:54:48 <dramforever> 2. you want >>, not >>=
06:54:49 <ion> "ARGS: " >>= _ means you‚Äôre using the list monad.
06:54:58 <dramforever> 3. why you need $
06:55:01 <seawisegiant> dram, yes I think so
06:55:10 <ion> putStrLn "ARGS:" >> mapM_ putStr args
06:55:18 <seawisegiant> it's just a chain, I'm not passing something
06:55:21 <ion> is parsed as (putStrLn "ARGS:") >> (mapM_ putStr args)
06:55:47 <dramforever> hmm...someone not using autocomplete read my nick correctly
06:55:53 * dramforever is pleased and thankful
06:56:05 <seawisegiant> thanks
06:56:05 <seawisegiant> putStrLn "ARGS:" >> mapM_ putStr args
06:56:09 <seawisegiant> that's wotk
06:56:11 <seawisegiant> work
06:56:14 <seawisegiant> :-)
06:56:48 <ion> $ has the lowest precedence of all operators, including >>= and >>
06:56:48 <monochrom> "you shalt not pass"?!
06:58:53 <seawisegiant> thanks, ion
07:00:37 <seawisegiant> thanks, dramforever, too
07:00:56 <mniip> would I be correct if I said that -> preserves co/contravariance of the RHS, and inverts the co/contravariance of the LHS?
07:01:18 <pingu> mniip: are you talking about Hask?
07:01:27 <mniip> I assume
07:01:30 <pingu> I should think so if Hask is a thing, that's pretty fundamental ;)
07:02:08 <pingu> but I'm not actually entirely sure about the parseability of haskell syntax.
07:02:14 <pingu> TH could totally break that, at least.
07:02:41 <mniip> surely haskell falls within recursively enumerable languages
07:03:14 <pingu> Yes, surely, I'd hope.
07:03:57 <pingu> https://wiki.haskell.org/Hask
07:04:17 <pingu> Is that page helpful? It can be odd at bits. I'm not sure if it's up to date or problem-free.
07:06:14 <Cale> pingu: Looks okay
07:07:02 <Cale> pingu: Probably only helpful if you already know some category theory
07:07:45 <pingu> Cale: yeah, that's the kinda problem I keep seeing.
07:08:10 <pingu> A lot of people, me included, learnt category theory via haskell.
07:08:18 <pingu> And that was one of the first pages we saw.
07:08:56 <athan> Is there a reason why there's no instance for `Random Rational`?
07:09:28 <ion> It would be even worse than the instance Random Integer.
07:19:08 <ion> Well, perhaps equally bad if you implemented it as random Integer divided by fromIntegral (maxBound :: Int) + 1
07:21:08 <athan> hmm! thanks ion!
07:27:54 * hackagebot linear-grammar 0.0.2 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.2 (athanclark)
07:27:56 * hackagebot linear-grammar 0.0.2.1 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.2.1 (athanclark)
07:35:23 <Sindriava> How would I go about applying the same arguments to an array of functions?
07:36:11 <Sindriava> i.e. [a ‚Üí b ‚Üí c] ‚Üí a ‚Üí b ‚Üí [c] 
07:36:14 <ion> If the array is an instance of Functor, ($ x) <$> theArray
07:36:19 <ion> [] is list
07:36:23 <Sindriava> aaaah
07:36:29 <Sindriava> I've been doing it the other way around
07:36:41 <Sindriava> theArray <$> arg1 <*> arg2
07:37:00 <ion> theArray <$> pure arg1 <*> pure arg2
07:37:14 <ion> (\f -> f arg1 arg2) <$> theArray
07:37:21 <Sindriava> Well, doesn't <$> double as pure?
07:37:22 <ion> or theList if you‚Äôre using []
07:37:36 <Sindriava> So more likely theArray <*> pure arg1 <*> pure arg2
07:37:45 <ion> Sorry, i meant theArray <*> pure arg1 <*> pure arg2
07:38:08 <Sindriava> Yay, I have basic understanding of stuff! :D
07:38:14 <Sindriava> Thanks! ^^
07:38:36 <ion> @type \f a b -> f <*> pure a <*> pure b
07:38:37 <lambdabot> Applicative f => f (a1 -> a -> b) -> a1 -> a -> f b
07:38:50 <ion> @type \f a b -> f <&> \f' -> f' a b
07:38:51 <lambdabot> Functor f => f (t -> t1 -> b) -> t -> t1 -> f b
07:42:50 <Sindriava> For good measure, is there a better way to write this?
07:42:54 <Sindriava> foldl1 (:+:) $ [c 5, d 5, e 5, f 5, g 5, a 5, b 5, c 6] <*> pure en
07:45:04 <solrize> meh the "source" links in https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Data-List.html don't work and my haskellwiki account has been broken for years
07:46:04 <Haskellfant> solrize: the source links on hackage seem to work https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-List.html
07:46:24 <solrize> hmm thanks 
07:47:03 <solrize> base is not listed in http://hackage.haskell.org/packages/names
07:47:22 <mniip> Sindriava, are you entirely sure you are looking for a left fold?
07:47:56 <Sindriava> mniip: Not even remotely. What's the difference to a right fold? Well, apart from the direction
07:48:16 <Sindriava> I mean, I want them to be in order as they are in the array
07:48:18 <ion> > foldl' f z [a,b,c]
07:48:19 <lambdabot>  f (f (f z a) b) c
07:48:22 <ion> > foldr f z [a,b,c]
07:48:23 <lambdabot>  f a (f b (f c z))
07:48:26 <mniip> performance
07:48:35 <mniip> O(N) memory versus O(1)
07:48:35 <Sindriava> I see
07:48:54 <Sindriava> I basically want to intersperse the array with (:+:)
07:48:55 <ion> Sindriava: It‚Äôs a list, not an array.
07:49:08 <Sindriava> Derp, yeah, sorry
07:49:11 <ion> That‚Äôs a rather important distinction, sorry if i sound like nitpicking.
07:49:30 <Sindriava> ion: No, you're entirely right. I'm just used to arrays from C
07:49:39 <ion> C has both, Haskell has both.
07:49:45 <mniip> Sindriava, what's 'en'
07:49:59 <Sindriava> mniip A synonym for 1 % 8
07:50:06 <Sindriava> "Eight Note"
07:50:38 <mniip> so you have a list of functions that you apply to 'en' and then fold with :+:
07:50:42 <Sindriava> ion: Really! How do arrays in Haskell look like? Or better, where can I learn more? :)
07:51:10 <Sindriava> mniip: Yep, that's right. I get a list of musical notes and I want to play them in order to have a scale
07:51:29 <mniip> regarding arrays, see Data.Array, Data.Vector, GHC.Prim
07:51:55 <Sindriava> mniip: Thanks!
07:52:31 <Sindriava> So, foldl is O(n) and foldr is O(1) ?
07:52:43 <Sindriava> How would I foldr the array while preserving the order?
07:52:57 <mniip> foldr and foldl are the same order
07:53:21 <ion> See the lambdabot output above. The a, b, c are in the same order in both.
07:53:24 <mniip> it's just that in foldr the result recurses to the right, and in foldl it recurses to the left
07:53:37 <Sindriava> Ooooooh
07:53:44 <Sindriava> So why would you ever use foldl?
07:53:53 <mniip> if you want something recursed to the left
07:54:07 <Sindriava> well, duh, but why would I want that?
07:54:11 <mniip> or if you want to reverse a list
07:54:19 <Sindriava> Oh yeah, that's a good point
07:54:23 <mniip> > foldl (flip (:)) [] "hello"
07:54:24 <lambdabot>  "olleh"
07:54:46 <Sindriava> Note to self: Learn more about folding
07:54:52 <Sindriava> Thanks a lot! ^^
07:55:04 <ion> foldl' starts with an accumulator repeatedly applies ‚Äúf‚Äù to the accumulator and an input element. foldr applies ‚Äúf‚Äù to the first input element and the fold of the rest of the input.
07:55:08 <mniip> Sindriava, beware: you will find scary things there
07:55:23 <Sindriava> mniip: I'm all about scary!
07:55:36 <ion> You‚Äôll want to use foldl' instead of foldr when e.g. computing a sum: foldl' (+) 0
07:55:41 <mniip> Sindriava, like list augmentation
07:56:01 <mniip> build/augment I mean
07:56:16 <ion> You‚Äôll want to use foldr when ‚Äúf‚Äù is lazy in its second argument and you want output from the fold before reaching the end of the input list.
07:56:20 <mniip> fusion of list processors
07:56:21 <lingxiao> I am trying to uninstall ghc 7.10.1
07:56:29 <lingxiao> but this command: /Library/Haskell/bin/uninstall-hs 
07:56:45 <alisia> what does >-> in "middleware $ staticPolicy (noDots >-> addBase "static")" mean?
07:56:58 <lingxiao> or uninstall-hs
07:57:02 <lingxiao> is not working
07:57:06 <ion> alisia: It‚Äôs defined in one of the libraries you‚Äôre using.
07:57:25 <Haskellfant> that one probably https://hackage.haskell.org/package/wai-middleware-static-0.7.0.1/docs/Network-Wai-Middleware-Static.html#v:-62--45--62-
07:57:47 <Haskellfant> so it just sequences the noDots and the addBase "static" polyci
07:57:51 <Haskellfant> *policy
07:57:51 <Sindriava> mniip: ion: Thanks :) I'll have a good look at folding.
07:58:15 <lingxiao> anyone care to chime in?
07:58:16 <bollu1> can I get a stack for "Prelude.!! index too large: ?
07:58:22 <geekosaur> lingxiao, "not working" isn't an especially helpful problem description
07:58:24 <GLM> ion:Are those kinds of functions common or just here or there?
07:58:35 <ion> GLM: What kinds of functions?
07:58:40 <lingxiao> geekosaur: I am getting -bash: uninstall-hs: command not found
07:58:41 <mniip> bollu1, again, there's no stack!
07:58:47 <GLM> ion:The one alisia was talking about
07:58:51 <bollu1> mniip: ah, christ >_<.
07:59:02 <ion> GLM: Many libraries define their own operators.
07:59:03 <matsuura> Someone called?
07:59:05 <bollu1> mniip: okay, so how do I debug stuff like this?
07:59:28 <geekosaur> bollu1, position reporting for stuff like that is a known pain point, ghc 7.12 is supposed to have things that will help.
07:59:35 <GLM> ion:I know. Most of those kinds of operators look the same to me so it is hard to know which ones are standard
07:59:36 <lingxiao> really I would like to install ghc--7.8.4
07:59:46 <bollu> geekosaur: soo... "figure it out, young'un" ?
08:00:04 <lingxiao> but I am uninstall 7.10.1 first so I don't encounter issues later one
08:00:18 <geekosaur> lingxiao, are you on OS X? how did you install ghc 7.10?
08:00:49 <geekosaur> (that command is specific to the official Haskell Platform installation for OS X, it does not apply to other installations such as the minimal ghc tarball)
08:01:21 <mniip> bollu, hold on
08:01:25 <mniip> I've done this before
08:02:02 <lingxiao> uninstalling*
08:03:53 <mniip> bollu, something along the lines of
08:04:01 <mniip> load your main module into ghci
08:04:12 <mniip> :set -fbreak-on-exception
08:04:17 <mniip> :trace main
08:04:20 <mniip> :history
08:06:08 <sunnymilk> can someone explain this
08:06:20 <sunnymilk> > minBound == maxBound
08:06:22 <lambdabot>  True
08:06:26 <ion> It defaults to ()
08:06:39 <sunnymilk> why
08:07:03 <mniip> :t minBound == maxBound
08:07:05 <lambdabot> Bool
08:07:05 <ion> Because the defaulting rules say so and that typechecks.
08:07:13 <mniip> information about the instance of the typeclass is lost
08:07:21 <sunnymilk> are the defaulting rules part of the typeclass definition?
08:07:23 <mniip> it assumes what defaulting tells it to
08:07:32 <sunnymilk> or where is defaulting defined
08:07:39 <ion> @google haskell defaulting
08:07:40 <lambdabot> https://ghc.haskell.org/trac/haskell-prime/wiki/Defaulting
08:07:46 <mniip> defaulting is tricky
08:08:11 <mniip> you can use the default keyword, but it's per module, and there's a global default of [Integer, Double, ()] or something like that
08:08:37 <geekosaur> sunnymilk, https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4
08:09:15 <geekosaur> extended defaulting is a convenience enabled in ghci but not generally in compiled programs, so you don;t have to assign a type to something like an empty list
08:10:02 <sunnymilk> i see
08:10:07 <sunnymilk> thank you
08:12:11 <lingxiao_> anyone else care to chime in?
08:12:30 <geekosaur> do you happen to feel like answerimng questions, or do answerers need Ouija boards?
08:12:41 <geekosaur> or to hack into your computer to figure out the answer for themselves?
08:12:55 <geekosaur> [13 10:59:56]  <geekosaur>	 lingxiao, are you on OS X? how did you install ghc 7.10?
08:12:55 <geekosaur> [13 11:00:27]  <geekosaur>	 (that command is specific to the official Haskell Platform installation for OS X, it does not apply to other installations such as the minimal ghc tarball)
08:13:13 <ion> lingxiao‚Äôs connection dropped around those lines
08:13:47 <lingxiao_> oh .. sorry yeah shoddy internet ..
08:14:18 <lingxiao_> geekosaur I downloaded the ghc 7.10.1 tarball
08:15:14 <lingxiao_> yeah so now I'm stuck I suppose
08:15:20 <geekosaur> then you will have to remove it manually, or install a Platform installer just to use its uninstall-hs (that would also get you a 7.8.3 install and libraries, so might well be easiest unless you realluy need 7.8.4)
08:15:21 <bollu> http://lpaste.net/7306866344144666624 <- code review + help speeding this up
08:15:34 <bollu> yes, I know, I should use Data.Vector.Unboxed to index :)
08:15:40 <bollu> I haven't gotten around to learning it.
08:15:47 <geekosaur> in general the raw tarballs work best if you install them into unique prefixes so you can just remove everything under that prefix
08:15:57 <bollu> could someone please give me some style tips / guides on that?
08:15:59 <lingxiao_> geekosaur for example this: https://www.haskell.org/platform/mac.html
08:16:07 <geekosaur> since removing all of /usr/local is usually not a good option
08:16:10 <lingxiao_> ohh ... yeah I am not aware of htat
08:16:35 <statusfailed> Does this function have a name? Monad m => [a -> m a] -> a -> m a
08:16:35 <bollu> whoops, also, I realized I need for foldr -> foldl'
08:17:21 <mniip> statusfailed, foldr (>=>), probably
08:17:50 <ion> @type foldr (>=>) pure
08:17:51 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
08:17:56 * hackagebot between 0.10.0.0 - Function combinator "between" and derived combinators  http://hackage.haskell.org/package/between-0.10.0.0 (PeterTrsko)
08:18:09 <statusfailed> mniip, ion neat, thanks :-)
08:18:25 <statusfailed> I think I want foldl though?
08:18:27 <mniip> despite AMP, I would still advise to use return next to >=>, and not pure
08:19:20 <bollu> could someone help me improve my code? http://lpaste.net/7306866344144666624
08:21:33 <bollu> getAdjacentPositions seems ugly. Is there a nicer way to do it?
08:21:57 <bollu> and, also, for solve, I think I can use the State monad to make it nicer, but I don't know how to :(
08:22:14 <lingxiao_> geekosaur so I installed the haskell platform found here: https://www.haskell.org/platform/mac.html
08:22:39 <lingxiao_> but ... it was not actually installed ?
08:22:47 <ion> > (\a b -> (x+a, y+b)) <$> [-1,0,1] <$> [-1,0,1]
08:22:48 <lambdabot>      Couldn't match expected type ‚ÄòInteger -> b‚Äô
08:22:48 <lambdabot>                  with actual type ‚Äò[Expr -> (Expr, Expr)]‚Äô
08:22:48 <lambdabot>      In the first argument of ‚Äò(<$>)‚Äô, namely
08:22:53 <ion> > (\a b -> (x+a, y+b)) <$> [-1,0,1] <*> [-1,0,1]
08:22:54 <lingxiao_> for example typing ghc --version on in bash gets me nothing
08:22:55 <lambdabot>  [(x + negate 1,y + negate 1),(x + negate 1,y + 0),(x + negate 1,y + 1),(x + ...
08:23:05 <lingxiao_> and I can't find anything at /Library
08:23:39 <ion> That‚Äôs not clockwise though.
08:23:46 <geekosaur> you already had a ghc installed, so "hash -r"
08:23:57 <geekosaur> also depending on your $PATH it may still find the old one first
08:24:10 <geekosaur> /usr/bin/ghc --version
08:24:45 <mniip> ion, you need zipWith (\a b -> (x+a, y+b)) [0, 1, 1, 1, 0, -1, -1, -1] [1, 1, 0, -1, -1, -1, 0, 1]
08:26:03 <lingxiao_> ahh ok so if I want to uninstall all haskell-related stuff now what should I do?
08:26:07 <ion> bollu: what mniip said
08:26:20 <bollu> ion: what did he say?
08:26:38 <mniip> literally 3 lines above
08:26:42 <geekosaur> you should have that uninstall-hs command now. run it and follow the instructions
08:26:55 <geekosaur> under /Library/Haskell
08:26:58 <bollu> mniip: ohh, thanks!
08:27:04 <bollu> aht that is cute 
08:27:31 <bollu> but.. I don't see the difference I guess. Like, it's still as explicit
08:27:45 <bollu> I was hoping for some applicative trickery to automatically give all combinations
08:27:47 <mniip> you have fewer x and y invocations
08:28:01 <mniip> bollu, "all combinations" doesn't go clockwise though
08:28:11 <bollu> mniip: this doesn't have to go clockwise
08:28:16 <bollu> I just went clockwise as a mnemonic
08:28:19 <lingxiao_> unforunately no ... /Library/Haskell is not even a directory 
08:28:22 <bollu> so I don't leave any index out
08:28:25 <mniip> then you can use what ion said
08:28:38 <bollu> ahh
08:28:39 <mniip> oor
08:28:40 <bollu> I missed that too
08:28:43 <lingxiao_> neither is /Library/Frameworks/GHC.framework for that matter
08:28:50 <ion> You just need to filter out (x,y) from the output.
08:28:56 <bollu> ion: thanks for that :) | mniip: go on
08:29:29 <bollu> mniip: or?...
08:29:35 <mniip> typing
08:29:38 <lingxiao_> it's funny because I have ghc 7.8.3 according to ghc --version
08:29:43 <ion> > [ (x+a, y+b) | a <- [-1,0,1], b <- [-1,0,1], (a,b) /= (0,0) ]
08:29:44 <lambdabot>  [(x + negate 1,y + negate 1),(x + negate 1,y + 0),(x + negate 1,y + 1),(x + ...
08:29:45 <mniip> bimap (x +) (y +) $ filter (/= (0, 0)) $ liftA2 (,) [-1..1] [-1..1]
08:30:13 <ion> lingxiao: ‚Äúwhich ghc‚Äù will print the location of the executable.
08:30:29 <bollu> :t bimap
08:30:30 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
08:30:38 <bollu> :t Bifunctor
08:30:39 <lambdabot> Not in scope: data constructor ‚ÄòBifunctor‚Äô
08:30:41 <mniip> you're unlikely to have bimap available though
08:30:52 <ion> Bifunctor is in base now.
08:30:54 <mniip> oh?
08:30:57 <mniip> so it is
08:31:02 <lingxiao_> ion ok so it's in /usr/bin/ghc
08:31:34 <bollu> what is "p" in this case? "," ?
08:31:41 <mniip> p ~ (,)
08:31:50 <bollu> why "~" and not "=" ?
08:31:58 <mniip> that's the syntax for type equivalence
08:32:01 <bollu> ah
08:32:15 <bollu> I can vaguely grasp it
08:32:18 <bollu> but not concretely
08:32:23 <mniip> :t (undefined :: a ~ b => a -> b) ()
08:32:24 <lambdabot> ()
08:32:24 <lingxiao> sorry cut out connection again
08:32:28 <bollu> I'll need  a pencil or something to work the types out
08:32:55 <ion> (a -> b) -> (c -> d) -> (,) a c -> (,) b d
08:32:57 * hackagebot simplex-basic 0.0.0.1 - Very basic simplex implementation.  http://hackage.haskell.org/package/simplex-basic-0.0.0.1 (athanclark)
08:33:00 <ion> (a -> b) -> (c -> d) -> (a,c) -> (b,d)
08:34:01 <bollu> mniip: how do you *see* things like that?!
08:34:09 <bollu> I wouldn't have even thought of that
08:34:24 <lingxiao> but I can't just cd into /usr/bin though ...
08:34:35 <bollu> and I don't have bimap on my ghci :(
08:34:36 <lingxiao> sorry this is a very basic question
08:34:44 <ion> Modify the final element of a tuple: Functor; modify the final two elements of a tuple: Bifunctor
08:35:07 <vikaton> > [1, 3 .. 10]
08:35:08 <lambdabot>  [1,3,5,7,9]
08:35:22 <bollu> hm
08:35:26 <vikaton> > [ 3 .. 10]
08:35:28 <lambdabot>  [3,4,5,6,7,8,9,10]
08:35:36 <vikaton> im confsued :/
08:35:47 <subleq__> what is meant by "abstract types are existential types"?
08:36:17 <bollu> ion, mniip: I think I get it
08:36:21 <lingxiao> if I want to find where the files for haskel is installed, what would I do?
08:36:38 <bollu> and.. I'm having compiler errors trying to use Data.Vector.Unboxed - http://lpaste.net/edit/7306866344144666624
08:36:42 <bollu> the error is posted at the bottom
08:36:47 <mniip> bollu, how do I see things like what
08:36:59 <bollu> mniip: the entire bimap ...
08:37:25 <mniip> well I remember that bimap for (,) is a fancy way of applying two functions to two parts of the tuple
08:37:29 <bollu> mniip: like, how do you structure it that way in your head? I need to tilt my head sideways to even get a simple monad or functor. 
08:37:56 <mniip> bollu, it comes with experience
08:37:58 <ion> lingxiao: Since your operating system doesn‚Äôt use a real package manager to keep track of what put what into /usr/bin, you‚Äôll need to use whatever ad-hoc way the specific installer of /usr/bin/ghc you used provides for uninstallation.
08:38:26 <mniip> bollu, what's line 37
08:38:45 <bollu> type Position = (Int, Int) 
08:38:46 <lingxiao> ion how do I know what that is?
08:39:00 <lingxiao> I have /usr/bin folder open
08:39:01 <bollu> to "index"
08:39:08 <bollu> like, on cartesian coordinates
08:39:12 <ion> lingxiao: Look at the web page where you downloaded the installer from. Hopefully it has instructions.
08:39:34 <bollu> mniip: line 36 is this : type Matrix a = Vec.Unbox (Vec.Unbox a) 
08:39:49 <bollu> what's the problem with that line?
08:40:00 <mniip> bollu, Unbox is a typeclass
08:40:02 <mniip> not a type constructor
08:40:10 <bollu> mniip: ohh
08:40:19 <bollu> mniip: so what's the type constructor to use a Vector? 
08:40:27 <mniip> Vector
08:40:42 <mniip> Data.Vector.Unboxed defines: data family Vector a
08:41:18 <lingxiao> it's weird right because I installed the haskell platform before 
08:41:24 <saulzar_> But you won't be able to have an unboxed vector of another unbox vector, it'd have to be a normal vector of unboxed vector
08:41:27 <bollu>     No instance for (Vec.Unbox (Vec.Vector Bool)) arising from the 'deriving' clause of a data type declaration
08:41:35 <lingxiao> and to uninstall it uinstall --hs worked fine
08:41:35 <vikaton> what do I need to install to get hoogle ?
08:41:41 <lingxiao> but this time around not so much ..
08:41:47 <bollu> saulzar_: so, well, how do I use Vector then?
08:42:10 <lingxiao> previously there was a /Library/Haskell directory as intended
08:42:10 <f-a> I am getting bitten by lentil: ./pn544.txt hGetContents: invalid argument (invalid byte sequence). I thought using Text instead of String would solve it but apparently it isn't so. The question is: is there a way to read from a file and never choke?
08:42:17 <lingxiao> now I have no idea where it is
08:42:24 <ion> bollu: FWIW, array lets you use 2-dimensional indexing.
08:42:40 <bollu> ion: haskell has arrays?
08:42:45 <saulzar_> bollu, Import both Unboxed and normal Vector  and use a  Vector (Unbox.Vector Bool)
08:42:54 <ion> bollu: Yes. vector is an implementation of arrays. array is another.
08:43:03 <saulzar_> bollu, Yes but they're quite a bit more painful than Vector
08:43:10 <mniip> bollu, in simple terms, unboxed means raw
08:43:15 <mniip> you can make a vector of raw booleans
08:43:19 <mniip> but not of raw vectors
08:43:22 <bollu> saulzar_: so, stick with normal Vector?
08:43:25 <bollu> mniip: ah
08:43:27 <latk> how are you supposed to enable profiling (in order to get a stack trace) these days?
08:43:38 <hpc> a stack trace?
08:43:40 <latk> in a sandboxed project that is
08:43:41 <mniip> bollu, also
08:43:48 <mniip> Data.Array can do 2-dimensional arrays
08:43:52 <latk> hpc: +RTS -xc
08:43:53 <mniip> via 2-dimensional indexes
08:44:02 <bollu> mniip: so, which would you recommend I use?
08:44:09 <saulzar_> bollu, You can have an unboxed vector on the inside, but unboxed vector only supports a subset of basic types (e.g. Int, Double, Float)
08:44:21 <hpc> !!
08:44:34 <mniip> bollu, I've used Data.Array in the past, wouldn't say it is something unpleasantly painful
08:44:51 <latk> hpc: ?
08:44:58 <hpc> just didn't know that was a thing
08:45:03 <saulzar_> bollu, Other option is to use a single unboxed vector and index it yourself e.g. make it height * width size
08:45:17 <latk> Hah, well it used to be -can't get it working atm!
08:45:42 <mniip> hpc, maybe they meant evaluation stack trace?
08:45:52 <mniip> (haskell to this day has no notion of call stack)
08:46:02 <bollu1> so, well, which library should I learn / use?
08:46:28 <hpc> mniip: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html#idp13458320
08:46:35 <saulzar_> bollu1, I think Vector is right
08:46:50 <hpc> latk: apparently "compiling with -prof -fprof-auto and running with +RTS -xc -RTS will tell you exactly the call stack at the point the error was raised"
08:47:02 <mniip> bollu1, looking at Vector's API
08:47:07 <mniip> it doesn't seem to be any different
08:47:16 <latk> bah, i was missing fprof-auto
08:47:18 <mniip> except it lets you split and join vectors in various ways
08:47:18 <bollu1> thanks guys :)
08:47:20 <phaazon> @hoogle has
08:47:21 <lambdabot> package has
08:47:21 <lambdabot> Data.HashTable hashInt :: Int -> Int32
08:47:21 <lambdabot> System.Mem.StableName hashStableName :: StableName a -> Int
08:47:25 <latk> hpc: Will try that, cheers :)
08:48:03 <phaazon> couldn‚Äôt we implement a has function in terms of Foldable?
08:48:06 <vikaton> how 2 install hoogle ?
08:48:16 <hpc> and since the stack is the evaluation stack / optimization manipulations, the stack will sometimes look pretty odd at one end
08:48:25 <phaazon> hm I guess Traversable would be better
08:48:51 <mniip> phaazon, has function?
08:48:58 <mniip> you mean tuple element access?
08:49:08 <lingxiao> nevermind got it!
08:49:13 <phaazon> mniip: no
08:49:30 <phaazon> I mean a generalization to function such as elem, member, contains
08:49:32 <phaazon> :t elem
08:49:33 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
08:49:35 <phaazon> :t M.member
08:49:36 <lambdabot> Ord k => k -> M.Map k a -> Bool
08:50:41 <mniip> phaazon, Map does not conform to Traversable laws
08:50:55 <phaazon> in that case, yes
08:51:38 <ion> > foldMap (\_ -> First (Just ())) []
08:51:40 <lambdabot>  First {getFirst = Nothing}
08:51:42 <ion> > foldMap (\_ -> First (Just ())) [0..]
08:51:43 <lambdabot>  First {getFirst = Just ()}
08:51:48 <mniip> I haven't checked, but seems like sequenceA isn't inhabited for Map
08:52:24 <ion> > foldMap (\x -> First (guard (x == 42))) [0..]
08:52:26 <lambdabot>  First {getFirst = Just ()}
08:54:23 <ion> > foldMap (\x -> Any (x == 42)) [0..]
08:54:24 <lambdabot>  Any {getAny = True}
08:55:31 <mniip> > foldMap (All . (>= 0)) [0..]
08:55:35 <lambdabot>  mueval-core: Time limit exceeded
08:55:36 <mniip> :(
08:56:26 <ion> Just wait long enough
08:56:33 <lingxiao> thanks geekosaur thanks ion!
08:56:56 <mniip> ion, 0 :: Integer
08:57:02 <mniip> defaulting :(
08:57:04 <ion> mniip: I know
08:57:54 <ion> In this case, ‚Äúlong enough‚Äù is ‚Äúinfinitely long‚Äù.
09:02:58 <hpc> nah, it should OOM eventually ;)
09:04:21 <ion> Run it on a system where you can add more memory arbitrarily. Keep adding memory infinitely.
09:04:41 <ion> For instance, run it on paper, keep adding pages infinitely.
09:05:25 <monochrom> rent more amazon virtual machines
09:05:47 <monochrom> a problem solvable by money is a solved problem
09:05:55 <hpc> download more ram
09:08:19 <bollu1> how do I use the state monad? there's no data constructor for it ?
09:08:26 <bollu1> :t Control.Monad.State.State
09:08:27 <lambdabot>     Not in scope: data constructor ‚ÄòControl.Monad.State.State‚Äô
09:08:27 <lambdabot>     Perhaps you meant one of these:
09:08:27 <lambdabot>       ‚ÄòControl.Monad.State.StateT‚Äô (imported from Control.Monad.State),
09:08:34 <hpc> :t state
09:08:35 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
09:08:52 <bollu1> but, what's the extra m there?
09:08:57 <bollu1> I don't want any other "m"
09:09:09 <ion> State s, for instance.
09:09:18 <bollu1> ohh
09:09:21 <bollu1> okay
09:09:23 <bollu1> that's
09:09:24 <bollu1> hmm
09:09:30 <hpc> > state (\i -> ("what", i+1)) :: State Int String
09:09:31 <lambdabot>      No instance for (Show (State Int String))
09:09:31 <lambdabot>        arising from a use of ‚Äòshow_M864937342019523627325031‚Äô
09:09:31 <lambdabot>      In the expression:
09:09:38 <hpc> :t state (\i -> ("what", i+1)) :: State Int String
09:09:39 <lambdabot> State Int String
09:09:51 <hpc> you're likely looking at older information
09:09:52 <eitan> Hello, I'm trying to turn on profiling for my project but I'm getting the following error message:
09:10:03 <hpc> if it is mentioning State as a constructor
09:10:07 <eitan> Failed to load interface for ‚ÄòGHC.Integer.Type‚Äô     Perhaps you haven't installed the "p_dyn" libraries for package ‚Äòinteger-gmp‚Äô?
09:10:34 <eitan> How do I install the profiling version of `interger-gmp`?
09:10:39 <eitan> *integer
09:14:57 <bollu1> if I have a function from geNextMoves :: Context -> ([Position], Context), and another  moveTo :: Position -> Context -> ((), Context), how do I combine the two in a state monad?
09:15:02 <bollu1> using the state monad*
09:15:40 <bollu1> or are they non-composable?
09:15:41 <ion> state geNextMoves, state (moveTo position)
09:16:40 <bollu1> ion: right, but I want to find the list of all new Contexts, given the current Context. That is, generate [Position] by calling getNextMoves, and then map moveTo on [Position] so I can get [Context]
09:16:51 <bollu1> so, like, how do I get the [Context] ?
09:17:02 <hpc> :t runState
09:17:03 <lambdabot> State s a -> s -> (a, s)
09:17:09 <hpc> you need an initial state to start from
09:17:31 <ion> do moves <- geNextMoves; traverse_ moveTo moves  -- assuming geNextMoves and moveTo are replaced with the State versions
09:17:42 <bollu1> ion: ah
09:17:46 <bollu1> thank you for traverse_
09:17:58 <hpc> that won't get you a [Context] though
09:17:59 * hackagebot ghc-simple 0.1.1.0 - Simplified interface to the GHC API.  http://hackage.haskell.org/package/ghc-simple-0.1.1.0 (AntonEkblad)
09:18:06 <hpc> it will be each move in serial
09:18:14 <bollu1> hpc: how does that work>
09:18:22 <bollu1> and where is traverse_ defined?
09:18:30 <ion> @hoogle traverse_
09:18:30 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
09:19:06 <bollu1> ion: so in this case, f ~ State s ?
09:19:11 <bollu1> State Context*
09:19:39 <ion> yes, a ~ Position, t a ~ [Position], b ~ ()
09:20:14 <howdoi> Would reading some category theory help us in enhancing our FP skills? 
09:21:23 <eitan> :t state
09:21:24 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
09:22:05 <Raydiation_> hi i'm currently learning beta reduction in lambda calculus and am wondering what the first thing would be when reducing this term: (Œª x .Œª y . x ‚àó y )((Œª x .Œª y . x + y ) 9 5 ) 3
09:22:29 <Raydiation_> wouldnt the first Œª x be replaced?
09:22:40 <Raydiation_> with ((Œª x .Œª y . x + y ) 9 5 )
09:23:21 <Raydiation_> my example shows this as the first reduction (Œª x .Œª y . x ‚àó y )((Œª y . 9 + y ) 5 ) 3
09:23:35 <eitan> bollu1: you can have `state geNextMoves :: State [Position]` and `state . moveTo :: Position -> State ()`
09:24:28 <ion> State Context [Position], Sate Context ()
09:25:00 <howdoi> what are uses of an identity function?
09:25:15 <hpc> howdoi: ($) = id
09:25:36 <howdoi> yes
09:25:45 <hpc> > id <$> [succ, pred] <*> [1,2,3]
09:25:47 <lambdabot>  [2,3,4,0,1,2]
09:26:14 * howdoi shudders 
09:26:22 <hpc> better example
09:26:34 <hpc> > map ($ 5) [(* 2), (+ 1)]
09:26:36 <lambdabot>  [10,6]
09:27:16 <hpc> :t ($ "get used to seeing this sort of type by the way")
09:27:18 <lambdabot> ([Char] -> b) -> b
09:27:19 <eitan> Hello, I'm trying to turn on profiling for my project but I'm getting the following error message: Failed to load interface for ‚ÄòGHC.Integer.Type‚Äô     Perhaps you haven't installed the "p_dyn" libraries for package ‚Äòinteger-gmp‚Äô? How do I install the profiling version of `integer-gmp`?
09:27:53 <howdoi> hpc nice
09:28:02 <ion> howdoi: To specify laws: fmap id = id
09:28:41 <howdoi> ion whatever is fmapable is a functor right?
09:28:49 <hpc> it's also useful at the type level
09:28:49 <ion> Yes
09:29:05 <hpc> Identity is used to cap off monad transformer stacks
09:29:46 <Raydiation_> am i asking in the wrong channel?
09:30:07 <ion> To fold a list of functions, you need an identity element: foldr (.) id
09:30:07 <mniip> [19:27:57] <howdoi> ion whatever is fmapable is a functor right?
09:30:17 <mniip> if it follows laws yes
09:30:44 <ion> Well, I'd expect anything fmappable to follow laws.
09:31:10 <mniip> Raydiation_, "my example"
09:31:17 <kadoban> Raydiation_: I doubt it's /actually/ on topic, but it seems like the kind of thing that some people here would know quite well. I would think odds are good that you'll get an answer eventually.
09:31:25 <mniip> ion, instance Functor [] where fmap _ _ = []
09:31:32 <Raydiation_> ok, ty
09:31:34 <mniip> Raydiation_, are you following a tutorial of sort?
09:31:46 <howdoi> mniip all the laws?
09:31:55 <Raydiation_> mniip: ive asked a lambda calculus question :)
09:31:56 <mniip> howdoi, there's like three
09:32:04 <ion> mniip: I don't expect to have that in anything I'm importing.
09:32:36 <mniip> Raydiation_, you are asking why the so-called example doesn't do what you expect it to do
09:32:50 <mniip> ion, nevertheless it's a typecheckable fmap implementation
09:32:57 <Raydiation_> mniip: yes
09:33:25 <arbelos> I am looking for an example of how to use "in_" in esqueleto. Does anyone know?
09:33:26 <Raydiation_> isnt the first parameter replaced in the function?
09:33:34 <Raydiation_> (Œª x .Œª y . x ‚àó y )((Œª x .Œª y . x + y ) 9 5 ) 3
09:33:50 <howdoi> :t laws
09:33:51 <lambdabot> Not in scope: ‚Äòlaws‚Äô
09:33:56 <Raydiation_> so the first Œª x in the leftmost function should be replaced first right?
09:34:01 <howdoi> !3laws
09:34:17 <mniip> Raydiation_, your so-called example has to be following call-by-value reduction style then
09:34:42 <mniip> the reduction you're expecting will happen later down
09:35:03 <mniip> remember: lambda calculus is not about evaluating everything in an order
09:35:12 <mniip> it's beta and eta reductions
09:35:24 <mniip> which are merely laws of equivalence
09:35:28 <Raydiation_> ok, so it does not matter what i replace first?
09:36:06 <mniip> Raydiation_, not in the scope of finite combinators
09:36:06 <hpc> Raydiation_: correct - none of the reductions actually changes the expression, they're all equal
09:36:07 <eitan> I'm trying to turn on profiling for my project but I'm getting the following error message: Failed to load interface for ‚ÄòGHC.Integer.Type‚Äô     Perhaps you haven't installed the "p_dyn" libraries for package ‚Äòinteger-gmp‚Äô? How do I install the profiling version of `integer-gmp`?
09:36:19 <hpc> so it's like (5 + 9) * (1 + 2)
09:36:26 <Raydiation_> ok, i see :)
09:36:27 <hpc> you could reduce either side to 14 or 3 first
09:36:36 <hpc> neither changing the value of the expression
09:36:52 <mniip> Raydiation_, once you start dealing with w or Y, you might accidentally run off into infinity when blindly doing that
09:37:30 <hpc> there's a good joke about reducing lambda expressions being the secret to infinitely fast computation
09:37:33 <hpc> because everything is a noop
09:38:09 <mniip> hpc, let's rephrase
09:38:16 <mniip> obtaining the normal form of an expression
09:38:20 <hpc> :P
09:38:36 <hpc> yeah, that's a better phrasing
09:40:03 <mniip> hpc, actually,
09:40:13 <mniip> if you can just check whether an expression has a normal form
09:40:20 <mniip> you can perform infinitely fast computations!
09:40:28 <hpc> because halting problem
09:40:46 <mniip> that's the joke yes
09:41:18 <mniip> haskell jokes are boring because they are all decidable and derivable in linear time
09:45:30 <russruss> Where is Word8 defined now?
09:45:40 <russruss> Data.Word doesn‚Äôt seem to work for me in ghc 7.8.3
09:45:59 <hpc> @hoogle Word8
09:45:59 <lambdabot> Data.Word data Word8
09:45:59 <lambdabot> Data.ByteString.Builder.Prim word8 :: FixedPrim Word8
09:45:59 <lambdabot> Data.ByteString.Builder word8 :: Word8 -> Builder
09:46:06 <hpc> hmm
09:46:21 <monochrom> Data.Word worksforme
09:46:27 <hpc> it's definitely still there
09:48:14 <russruss> oh, got it
09:48:17 <russruss> I was being stupid :-)
09:48:18 <russruss> thanks
09:51:41 <howdoi> :)
09:57:43 <koala_man> how do I turn a rational into a decimal string with the given precision? e.g foo (1%3) 5 = 0.33333 ?
09:58:17 <monochrom> showFFloat etc may help
09:58:23 <monochrom> @type showFFloat
09:58:25 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
09:58:45 <monochrom> hmm, perhaps that doesn't help
09:58:55 <monochrom> convert to Double first :)
09:59:16 <koala_man> but I want more precision than a double can have
09:59:29 <monochrom> I have a cunning plan
09:59:39 <monochrom> convert to CReal first.
10:01:10 <ion> I have a helper in my .ghci just for that. :-P
10:01:11 <monochrom> but I forgot which package it is from. and hackage's search is dumb.
10:01:26 <bollu> sorry all, I left 
10:01:28 <arbelos> i figured it out finally: select $ from $ \item -> where_ $ (item ^. ItemId) `in_` valList [ .. ]
10:01:33 <monochrom> I want hackage version 1's search engine back
10:01:47 <bollu> and, reading back the comments, ion: I think I see it, but I don't think I "grok" it
10:01:58 <bollu> I don't really know what "Foldable" is
10:02:09 <bollu> although if I had to guess it generalizes foldl / foldr
10:02:18 <bollu> and Traversable is to.. edit structures?
10:02:19 <ion> bollu: Anything with toList, basically.
10:02:48 <bollu> ion: oh, right! because if you can define a fold, then toList = fold (:) [] <obj> correct?
10:03:07 <bollu> I don't remember who explained that to me.
10:03:13 <ion> Yeah
10:03:20 <mniip> Traversable is more complex
10:03:35 <mniip> Even I still have a wonky understanding of what it is
10:04:19 <bollu> so, well, ELI5 Traversable?
10:04:33 <ion> traverse is like fmap which lets you do Applicative actions instead of pure functions.
10:04:40 <monochrom> "I will tell you when you grow up"
10:04:40 <mniip> it lets you replcae normal application in the data's constructors with functor application
10:04:43 <koala_man> monochrom: awesome, thanks!
10:05:13 <bollu> ion: why not Monad, then? why stop at Applicativr?
10:05:18 <bollu> Applicative*
10:05:43 <mniip> bollu, Monad is much stronger than Applicative
10:05:55 <ion> bollu: You only need Applicative to implement traverse, Monad gives redundant power.
10:05:58 <bollu> mniip: In that case, why not Functor? :)
10:05:59 <bollu> ah
10:06:18 <bollu> ion: quick explanation example of traverse?
10:06:45 <mniip> > traverse (\x -> [x, ' ']) "foo"
10:06:47 <lambdabot>  ["foo","fo ","f o","f  "," oo"," o ","  o","   "]
10:06:57 <ion> traverse readFile ["foo", "bar"]
10:07:23 <bollu> mniip: I am terribly confused
10:07:43 <bollu> :t traverse
10:07:44 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:08:03 <mniip> bollu, try looking at sequenceA instead
10:08:15 <mniip> it has somewhat more understandable semantics
10:08:18 <bollu> so that's,.. a -> [b], t a -> [t b]
10:08:54 <bollu> sequenceA¬†::¬†Applicative¬†f => t (f a) -> f (t a)
10:08:57 <bollu> :t sequenceA
10:08:58 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
10:09:20 <bollu> @sequenceA [Just 5, Just 3, Just 2]
10:09:21 <lambdabot>  Sequence not found.
10:09:29 <ion> > do { a <- (\x -> [x, ' ']) 'f'; b <- (\x -> [x, ' ']) 'o'; c <- (\x -> [x, ' ']) 'o'; pure [a,b,c] }
10:09:30 <lambdabot>  ["foo","fo ","f o","f  "," oo"," o ","  o","   "]
10:09:32 <koala_man> monochrom: is there a smarter way to convert than fromIntegral (numerator x) / fromIntegral (denominator x) ?
10:10:08 <bollu> ion: in what context is do being applied? List monad?
10:10:31 <ion> > do { a <- "f "; b <- " o"; c <- "o "; pure [a,b,c] }
10:10:33 <lambdabot>  ["f o","f  ","foo","fo ","  o","   "," oo"," o "]
10:11:37 <roconnor> bollu: given an applictive (or monadic), e.g. readFile from ion's example, of type a -> f b, traverse takes a finitary container of type (t a) and replaces each value of type a with a value of type b while sequencing the applictive (or monadic) effect in order.
10:11:51 <ion> bollu: The return type of \x -> [x, ' '] makes it the list Applicative.
10:12:23 <roconnor> bollu: so traverse readFile ["foo", "bar"] will output a list of length 2 containing the contents of the files "foo" and "bar" respectively.
10:12:50 <roconnor> (technically it produces an IO value that when executed will output a list of length 2 containing the contents of those files)
10:13:33 <ion> traverse readFile ["foo", "bar"] = do { a <- readFile "foo"; b <- readFile "bar"; pure [a,b] }
10:13:58 <bollu> sorry, disconnected
10:14:22 <bollu> > do { a <- "a"; b <- "b"; pure [a, b] }
10:14:24 <lambdabot>  ["ab"]
10:14:33 <ion> You can see what was said in the logs linked in the topic.
10:14:45 <mniip> or get a bouncer
10:15:49 <bollu>  > do { a <- "a"; b <- "bb";pure [a, b] }
10:16:06 <bollu> hmm
10:16:17 <bollu> is that not legal?
10:16:47 <ion> There was a space before the >
10:17:04 <bollu> ion: so, traverse readFile ["foo", "bar"] calls readFile over every element of the list passed to it and then returns the list?
10:17:10 <bollu> :t readFile
10:17:11 <lambdabot> FilePath -> IO String
10:17:16 <bollu> won't fmap work?
10:17:29 <bollu> :t fmap
10:17:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:17:31 <mauke> :t fmap readFile ["foo", "bar"]
10:17:32 <lambdabot> [IO String]
10:17:45 <bollu> :t traverse readFile ["foo", "bar"]
10:17:46 <lambdabot> IO [String]
10:17:50 <bollu> okaay
10:18:25 * ion notices traverse is like a Kleisli fmap
10:18:26 <bollu> >_< I'm still confused. So, it "groups" all of the actions under one Applicative?
10:18:55 <bollu> >do { a <- "a"; b <- "b"; pure [a, b] }
10:20:52 <bollu1> sorry all. Internet is flaky
10:20:56 <kadoban> :t traverse -- <-- it does that :)
10:20:58 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:21:03 <bollu1>  >do { a <- "a"; b <- "b"; pure [a, b] }
10:21:19 <bollu1>  > do { a <- "a"; b <- "b"; pure [a, b] }
10:21:27 <bollu1> how do I invoke it right? 
10:21:34 <voidzero> stop prepending a space
10:21:36 <voidzero> > foo
10:21:37 <lambdabot>      Not in scope: ‚Äòfoo‚Äô
10:21:37 <lambdabot>      Perhaps you meant ‚ÄòT.for‚Äô (imported from Data.Traversable)
10:21:43 <voidzero>  > foo
10:21:48 <voidzero> see the diff?
10:21:50 <bollu1> ohh, thank you!
10:21:53 <bollu1> > do { a <- "a"; b <- "b"; pure [a, b] }
10:21:54 <voidzero> you could also try this stuff locally
10:21:55 <lambdabot>  ["ab"]
10:22:01 <ion> It applies the function to each element of the input, sequences the resulting actions and returns the result of each in a list or whatever the Traversable instance is.
10:22:09 <bollu1> voidzero: good point. I should do that and stop spamming the group
10:22:09 <voidzero> and lambdabot works in query too.
10:22:28 <voidzero> well, i'm not bothered, i like to see it, but not 
10:22:35 <voidzero> but not sure if everyone feels the same way
10:22:39 <voidzero> ..probably not. :-)
10:22:44 <bollu1> :)
10:23:10 <bollu1> ion: so, well, in the state example that I was asking, you were using traverse_ to..?
10:25:43 <ion> bollu: traverse_ discards the result values and just sequences the actions. traverse moveTo [posA, posB, posC] would result in [(),(),()] which is useless.
10:26:23 <bollu1> hm
10:26:33 <ion> Just like, say, traverse putStrLn ["line", "line", "line"]
10:26:33 <bollu1> right, so how do you use it?
10:26:33 <humanoyd> Does anyone here have experience with RDF/triple stores in haskell?
10:26:50 <ion> traverse_ putStrLn ["line", "line", "line"]
10:26:53 <bollu1> ahh
10:26:58 <bollu1> to ignore the return value
10:27:06 <bollu1> okay, like replicateM_
10:27:09 <bollu1> that's a convention I take it?
10:27:16 <bollu1> _ => () as return value
10:27:16 <ion> Yeah
10:27:17 <bollu1> ?
10:27:19 <bollu1> hmm
10:27:23 <bollu1> >traverse (\x -> if x `mod` 2 == 0 then [x] else []) [1, 2, 3]
10:27:41 <bollu1> >traverse (\x -> if x `mod` 2 == 0 then [x] else []) [1, 2, 3]
10:27:46 <ion> You need a space after the >
10:27:51 <bollu1> > traverse (\x -> if x `mod` 2 == 0 then [x] else []) [1, 2, 3]
10:27:53 <lambdabot>  []
10:28:03 <bollu1> why is it [] ? I had expected [2]
10:28:07 <bollu1> buuut,
10:28:14 <bollu1> > traverse (\x -> if x `mod` 2 == 0 then [x] else [0]) [1, 2, 3]
10:28:16 <lambdabot>  [[0,2,0]]
10:28:26 <bollu1> don't understand the semantics
10:28:42 <ion> traverse is not the same as (=<<)
10:29:32 <KaneTW> :t (=<<)
10:29:33 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:30:27 <ion> > do { [0]; [1]; [2,3]; pure () }
10:30:29 <lambdabot>  [(),()]
10:30:31 <bollu> > traverse (\x -> if x `mod` 2 == 0 then Just (x + 1) else Nothing) [2, 2, 4]
10:30:33 <lambdabot>  Just [3,3,5]
10:31:00 <bollu> ion: I clearly do not understand the list monad
10:31:12 <ion> That has length [0] * length [1] * length [2,3] output elements.
10:31:30 <bollu> okay
10:31:33 <ion> Make any of those empty and the number of output elements will be zero.
10:31:48 <bollu> but, isn't (>>=) on list flatMap?
10:31:53 <ion> Yes
10:32:14 <python476> hello haskellers
10:33:00 <int-index> python476: Hi.
10:33:09 <python476> I don''t know if it's the right place to ask. Question about combinatorial explosion / complexity.
10:33:25 <python476> combining sets / domains and such, multiply, and grows
10:34:14 <python476> but IIUC combining probability spaces can reduce 
10:34:30 <ion> > do { a <- (\x -> if x `mod` 2 == 0 then [x] else [0]) 1; b <- (\x -> if x `mod` 2 == 0 then [x] else [0]) 2; c <- (\x -> if x `mod` 2 == 0 then [x] else [0]) 3; pure [a,b,c] }
10:34:31 <python476> is there a term for this ?
10:34:32 <lambdabot>  [[0,2,0]]
10:34:49 <python476> aggregation that doesn't grow monotonically but can converge
10:35:54 <ion> > do { a <- [0]; b <- [2]; c <- [0]; pure [a,b,c] }
10:35:55 <lambdabot>  [[0,2,0]]
10:36:15 <bollu1> > let f = (\x -> if x `mod` 2 == 0 then [x, x] else []) in [1, 2, 3] >>= f
10:36:16 <lambdabot>  [2,2]
10:36:52 <bollu1> ion: that would be equivalent to what de-sugared? I think seeing the actual (>>=) would help me
10:38:01 <ion> > (\x -> if x `mod` 2 == 0 then [x] else [0]) 1 >>= \a -> (\x -> if x `mod` 2 == 0 then [x] else [0]) 2 >>= \b -> (\x -> if x `mod` 2 == 0 then [x] else [0]) 3 >>= \c -> pure [a,b,c]
10:38:03 <lambdabot>  [[0,2,0]]
10:39:03 <bollu1> ion: this is which example de-sugared? traversable?
10:39:24 <ion> <bollu1> > traverse (\x -> if x `mod` 2 == 0 then [x] else [0]) [1, 2, 3]
10:39:26 <bollu1> and thanks a lot for trying to explain all of this to me. I really appreciate it
10:39:52 <zkedaa> part
10:39:54 <bollu1> ion: but traversable uses applicative, right? so you wouldn't have access to (>>=)?
10:41:22 <ion> > (\a b c -> [a,b,c] <$> (\x -> if x `mod` 2 == 0 then [x] else [0]) 1 <*> (\x -> if x `mod` 2 == 0 then [x] else [0]) 2 <*> (\x -> if x `mod` 2 == 0 then [x] else [0]) 3
10:41:23 <lambdabot>  <hint>:1:169:
10:41:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:41:33 <bollu1> whoa, okay
10:41:43 <ion> > (\a b c -> [a,b,c]) <$> (\x -> if x `mod` 2 == 0 then [x] else [0]) 1 <*> (\x -> if x `mod` 2 == 0 then [x] else [0]) 2 <*> (\x -> if x `mod` 2 == 0 then [x] else [0]) 3
10:41:44 <lambdabot>  [[0,2,0]]
10:41:58 <bollu1> ahh
10:42:32 <ion> In all of the cases, you you replace [0] with [], the output will be empty.
10:42:36 <bollu1> so it, like, flatMaps the output of your "traversing function" and then collects them all into a list?
10:42:38 <bollu1> right
10:43:02 <buttproblem> Hello, I am trying to FFI with a C function returning a structure. Is this currently possible?
10:43:43 <bollu1> I see, because an empty list has "no combinations", the applicative just returns an empty list
10:43:51 <bollu1> ion: I think it makes much more sense now :)
10:44:00 <ion> Great
10:44:11 <bollu1> ion: I'll keep playing around with this
10:45:10 <voidzero> bollu1, it's cool that you brought this up, you guys taught me something here, too.
10:45:24 <YellowOnion> how would I work around something like this would throw? > data Msg = Connect | Error; data Connect = Connect {...}
10:45:57 <bollu1> ion: this maybe getting tedious for you, but.. could we not return to the example where you use traverse_ with State?
10:46:01 <bollu1> maybe I can see it better now
10:46:26 <ion> Sure
10:50:13 <bollu1> ion: so, well, I had  getPositions: Context -> [Position], and then gotoPosition: Context -> Position -> Context. "statifying" these, the state version of getPositions would be
10:50:14 <bollu1> sgetPosition: Context -> ([Position], Context)
10:50:14 <bollu1> sgotoPosition (which would have partially applied position, say) would be Position -> Context -> ((), Context). So you can partially apply a Position to get a Context -> ((), Context)). Now, how do I  "combine" these two?
10:50:50 <Haskellfant> buttproblem: a structure or a pointer to a structure? the latter is definitely possible, for the former I think you need a small wrapper (c2hs might make that easier)
10:50:54 <bollu1> sorry about the line breaks
10:54:41 <ion> If you have getPositions :: State Context [Position]; getPositions = state sGetPositions; gotoPosition :: Position -> State Context (); gotoPosition pos = state (sGotoPosition pos) then do { positions <- getPositions; traverse_ gotoPosition positions } should work.
10:55:26 <bollu1> ion: ah, I hadn't thought of writing gotoPosition :: Position -> State Context ()
10:55:33 <bollu1> that's a cool way to think about it
10:55:56 <bollu1> ion: and will try that out
10:55:59 <bollu1> thanks!
10:56:25 <ion> That's pretty much the only reasonable way to do it.
10:56:57 <RickP> I realized that a common pattern for me is to define a sum type `data A = B | C` and then have a function `f :: A -> A` where i need to test if this A is a B or a C. Pattern matching is great, but in some scenarios that's not available/easy (e.g. when defining the function inline). What would you do in that case? Define a `isB` or `isC` function?
10:57:14 <ion> If you have a -> b -> s -> (c, s), you need to apply it to the a and the b before passing it to state.
10:58:43 <ion> RickP: You could use LambdaCase, or write a fold function for the type A (see bool, maybe, either, foldr).
10:59:10 <bollu1> ion: where do I get 'State' from?
10:59:30 <ion> bollu1: Control.Monad.State
11:00:15 <bollu1> ion: how do you see the definition of a Typeclass in ghci?
11:00:26 <ion> bollu1: :info
11:00:30 <bollu1> thanks
11:00:57 <bollu1> type State s = StateT s Data.Functor.Identity.Identity That's disheartening.
11:01:16 <ion> Don't mind that for now.
11:01:17 <bollu1> but.. I'm guessing it's a "monad transformer" that uses the identity monad?
11:01:23 <bollu1> all right
11:01:50 <RickP> ion: thanks! i guess i was expecting haskell to already have something more clever than what i thought of
11:02:10 <ion> StateT s is a monad transformer that when applied to Identity is the good old State monad.
11:05:31 <Zekka> bollu1: This may not help you, but you can define State without StateT like this: newtype State s a = State (s -> (a, s))
11:06:11 <Zekka> bollu1: If you're unclear abnout what State is, try describing Functor, Applicative, and Monad instances for that type
11:06:45 <Zekka> the intuition is to think of it as a function (s -> s) that coincidentally produces an a (where s is your state)
11:07:10 <kadoban> bollu1: BTW, the NICTA course has a bunch of this stuff, I found it /very/ useful and fun, though it is challenging. https://github.com/NICTA/course
11:07:44 <ion> For reference, newtype StateT s m a = StateT (s -> m (a, s)). Set m = Identity and you have an equivalent thing.
11:13:56 <ttt_fff> if I need a Var, but do not need it to be concurrent, should I still use MVar, or should I use something else?
11:19:12 <geekosaur> IORef?
11:19:19 <ttt_fff> is IORef faster than MVar ?
11:19:40 <geekosaur> yes
11:20:10 <epta> what does the left part of Either in `BS.base64.decode :: ByteString -> Either String ByteString` mean? 
11:20:17 <geekosaur> IORef is the underlying primitive, I believe. it's a mutable cell without any concurrency guarantees; things like MVar and Chan are implemented on top of it
11:20:19 <epta> is it a string with an error?
11:22:41 <vikaton> Is anyone here good with the Win32 library?
11:23:07 <hsk4> What is the fundamental reason for why Haskell code looks good and doesn't have boilerplate <T> crap everywhere like C++ and C#?
11:23:26 <Zekka> hsk4: It has good support for type inference and a prettier notation for parametric types?
11:23:44 <Zekka> vikaton: I used it a while ago, what's up specifically?
11:23:57 <geekosaur> hsk4, a type like data Foo a = ...
11:24:03 <Zekka> (Note: not a winAPI specialist)
11:24:09 <vikaton> Zekka: just trying to get a simple 'GetAsyncKeyState' running
11:24:10 <geekosaur> is equivalent to a C++ template
11:24:19 <geekosaur> where a replaces the <T> goop
11:24:24 <geekosaur> (for simple cases)
11:24:43 <vikaton> this returns a not in scope data constructor 'GetAsyncKeystate'
11:24:48 <vikaton> https://www.irccloud.com/pastebin/HjKrJKcv/
11:24:58 <hsk4> hm ok
11:24:59 <Zekka> vikaton: That's because it's a Haskell function and its name must start with a lowercase letter
11:24:59 <geekosaur> the more complex cases, C++ only has that same mechanism whereas Haskell has more parametricity and abstraction in general instead of needing what amount to complex macros
11:25:22 <Zekka> https://downloads.haskell.org/~ghc/7.8.2/docs/html/libraries/Win32-2.3.0.2/Graphics-Win32-Key.html <- based on these docs, the name is getAsyncKeyState
11:25:25 <hodapp> hsk4: The technical term for this is that C++ sucks.
11:25:27 * hodapp runs away
11:25:44 <vikaton> Zekka, thanks, now I have to tackle the other errors
11:25:48 <ion> hsk4: Type inference.
11:25:50 <Zekka> vikaton: Yeah, you've got a few other roblems
11:25:50 <bollu1> http://lpaste.net/7306866344144666624. Help on line number 165? what do I need to use next?
11:26:06 <Zekka> For one, getAsyncKeyState returns an IO WORD, which putStrLn won't be able to print
11:26:23 <hodapp> but seriously, I've greatly preferred using Ivory & C to using C++ (even if C++ by itself can get me some additional polymorphism over the C).
11:26:46 <Zekka> For another, that's not how Haskell's call syntax works afaik
11:26:54 <Zekka> it's valid but you will have unexpeted precedence problems
11:27:15 <Zekka> vikaton: What you wrote is interpreted as (putStrLn GetAsyncKeyState) 65 -- you probably mean something like putStrLn (getAsyncKeyState 65)
11:27:38 <vikaton> >:(
11:27:40 <Zekka> vikaton: But really, you want to get a WORD out of the IO WORD to operate on, so that won't quite work either
11:27:50 <bollu1> http://lpaste.net/7306866344144666624 <- ion, I'm not sure as to how to use traverse_ (on line 165)
11:27:53 <Zekka> vikaton: Do you want spoilers on how to do that?
11:28:01 <vikaton> Zekka, sure
11:28:40 <Zekka> vikaton: You can either use bind, which is shorter but requires you to understand a little about monad, or you can use do-notation, which Haskell translates into a bind
11:28:44 <Zekka> about monads*
11:29:09 <Zekka> The bind version looks like this: print =<< getAsyncKeyState 65
11:29:22 <Zekka> (or: getAsyncKeyState 65 >>= print)
11:29:59 <Zekka> In do notation that looks like this: do { ks <- getAsyncKeyState 65; print ks }
11:30:11 <chmod755> I'm looking for someone. Is there a supybot with the seen function enabled in here? (or anything similar)
11:30:12 <vikaton> I see
11:30:16 <vikaton> thanks Zekaa
11:30:19 <vikaton> Zekka*
11:30:29 <Zekka> vikaton: FWIW, print x = putStrLn (show x)
11:30:37 <Zekka> If you want to display something other than a string, you probably want to use print
11:30:54 <kadoban> chmod755: lambdabot used to have @seen, but I think it got taken out.
11:31:12 <chmod755> kadoban, yep, i already tried that one
11:31:14 <Zekka> vikaton: Best of luck with your project!
11:31:24 <kadoban> AFAIK that's the only bot around
11:31:35 <Dodecahedrus> hi, what's the best way to read a string like "[-0.231, 0.213546, -0.43578, 0.9344]" and transform it to a [Int]. I can use something other than list too, i know exactly the number of elements.
11:31:59 <ion> bollu1: Looking at solve below, it seems all you need is ssolve = foldl' max 0 <$> sgetLongestPathAt, and pass in the initial context through runState.
11:32:07 <Zekka> doctorin1: Can you read it into a list of Double and then round them?
11:32:09 <bollu1> ion: hmm
11:32:24 <ion> bollu1: Oh, wait. I misread.
11:32:46 <bollu1> ion: okay, Maybe I need to rewrite it differently to be able to do this using State?
11:33:34 <Dodecahedrus> If i use read it fails because of the spaces after the ","
11:34:16 <Zekka> Dodecahedrus: Really?
11:34:22 <Zekka> > read "[1, 2, 3]" :: [Int]
11:34:24 <lambdabot>  [1,2,3]
11:34:31 <Zekka> > read "[1.0, 2.2, 3.3]" :: [Double]
11:34:33 <lambdabot>  [1.0,2.2,3.3]
11:34:37 <bollu1> > read "[1, 2,     3]" :: [Int]
11:34:39 <lambdabot>  [1,2,3]
11:34:43 <ion> bollu1: If you have multiple initial Contexts you need to run computations on and you want to use State Context, you'll need to run multiple separate State computations of use something like StateT Context [].
11:34:46 <Zekka> Are you sure it isn't just trying to read it as the wrong type?
11:35:08 <bollu1> ion: should I learn how StateT Context [] works?
11:35:14 <bollu1> ion: or is it too much?
11:35:15 <Dodecahedrus> > read "[-0.231, 0.213546, -0.43578, 0.9344]" :: [Int]
11:35:16 <lambdabot>  *Exception: Prelude.read: no parse
11:35:18 <bollu1> ion: I'm interested 
11:35:28 <Zekka> Dodecahedrus: Those aren't valid Ints, because Ints can't have decimal places
11:35:34 <Dodecahedrus> > read "[-0.231, 0.213546, -0.43578, 0.9344]" :: [Float]
11:35:35 <lambdabot>  [-0.231,0.213546,-0.43578,0.9344]
11:35:44 <Zekka> You'll need to do something to get rid of the decimal places after reading them if you want to turn them into ints
11:35:45 <ion> bollu1: map (runState something) initialContexts might suffice here.
11:35:45 <Dodecahedrus> oh, silly me
11:36:22 <Zekka> map floor $ read "[-0.231, 0.213546, -0.43578, 0.9344]"
11:36:24 <Zekka> > map floor $ read "[-0.231, 0.213546, -0.43578, 0.9344]"
11:36:25 <lambdabot>  [-1,0,-1,0]
11:36:36 <bollu1> ion: don't understand. you're mapping runState, so that will return an array of State Context PathLength? 
11:36:42 <bollu1> oh, wait
11:36:49 <bollu1> it'll return an array of PathLength
11:36:50 <Dodecahedrus> ok, i have it now. I tought the problem were the spaces when i tried it in ghci and it just needed to specify the type
11:36:51 <bollu1> Ithink
11:36:52 <Zekka> Dodecahedrus: That gets you either an [Int] or an [Integer]
11:37:06 <Zekka> Dodecahedrus: Yeah, when I tried one with spaces in GHCi it gave me the same problem
11:37:13 <bollu1> ion: I'll try and figure it out :D
11:37:16 <Dodecahedrus> thank you all :)
11:37:24 <Zekka> Unfortunately read can't guess what type you meant by looking at the string because Haskell doesn't examine values until it's thought about types
11:37:33 <ion> @type \go xs -> map (runState go)  xs
11:37:34 <lambdabot> State s a -> [s] -> [(a, s)]
11:38:22 <ion> Set s = Context, a = PathLength
11:38:39 <bollu1> ion: hmm
11:39:18 <vikaton> Zekka, its a keylogger in Haskell :P
11:39:35 <Zekka> vikaton: Cool! Uh, minding that if you distribute that, Haskell executables are usually really big
11:40:03 <vikaton> it's gonna be simple
11:50:29 <vikaton> Zekka, why can't I do (read (show ks) :: Integer) ?
11:51:00 <Zekka> vikaton: That will compile, but what do you think it does? I have a feeling it doesn't do what you think
11:52:41 <vikaton> Zekka: it casts the result of getAsyncKeyState to a string than an Integer?
11:53:04 <Zekka> vikaton: That would work, if getAsyncKeyState resulted in something that could be shown
11:53:20 <Zekka> But an IO WORD can't be shown -- an IO WORD is a computation that will result in a WORD
11:53:29 <hpc> also, casting isn't a concept in haskell
11:53:44 <Zekka> So to show the IO WORD in a way that gets you the WORD, you would need to run the computation, which would break Haskell's side effect rules
11:54:15 <vikaton> I just want ks to be an integer
11:54:25 <Zekka> vikaton: You need to somehow get the WORD out of the IO WORD, using either bind ((>>=) or (=<<)) or the do-notation shorthand for bind (ks <- getAsyncKeyState 65)
11:54:25 <vikaton> from gAKS like : ks <- (read (show (getAsyncKeyState 65)) :: Integer)
11:55:18 <Zekka> vikaton: So you have two steps -- get a WORD out of an IO WORD like I described, and turn the WORD into an Integer
11:56:18 <Zekka> vikaton: You may use fromIntegral to do the second step, but toInteger is more specific
11:56:32 <Zekka> (toInteger :: Integral a => a -> Integer)
11:57:32 <Zekka> vikaton: ks <- getAsyncKeyState 65 gets you ks :: WORD
11:57:42 <vikaton> hmm
11:57:52 <Zekka> ks <- read (show (getAsyncKeyState 65)) is a compile error because there's not a useful sense of Show for an IO WORD
11:58:28 <Zekka> If you understand functors, you can rewrite that in a typechecker-compatible way like this: ks <- fmap (read . show) (getAsyncKeyState 65)
11:58:45 <Zekka> But there's no advantage to doing that over ks <- fmap toInteger (getAsyncKeyState 65)
11:58:55 <vikaton> mhm
11:59:02 <Zekka> :t fmap
11:59:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:59:23 <Zekka> In this case f is IO -- so it turns a function from a's to b's into a function from IO a's to IO b's
12:00:05 <Zekka> You can think of fmap and bind as ways of going inside a functor/monad
12:00:13 <vikaton> I'm being brainfucked right now
12:00:21 <Zekka> vikaton: Yeah, sorry, this stuff is a little tricky
12:00:32 <Zekka> I'm hoping you're at least getting the basic point that an IO WORD is different from a WORD
12:00:40 <vikaton> yeah
12:00:44 <vikaton> im on the second step
12:01:00 <vikaton> key <- fmap toInteger ks
12:01:16 <vikaton> why cant I read ks into key ?
12:01:22 <vikaton> into an Integer
12:01:34 <Zekka> vikaton: If you've written ks <- getAsyncKeyState 65, then *ks* is a WORD, not an IO WORD
12:01:52 <vikaton> I have that
12:02:05 <vikaton> im creating a new value
12:02:07 <vikaton> named key
12:02:18 <Zekka> <- says "for the IO a on the right, put the a inside in the variable on the left"
12:02:36 <whiteline> think in terms of >>= instead of the syntactic sugar
12:02:38 <Zekka> So if ks isn't an IO WORD, then you don't need to unpack it with <- and you don't need to use fmap to operate on the WORD inside
12:02:42 <whiteline> it makes everything easier
12:03:03 <Zekka> whiteline: Yeah, I'm trying to be nice and talk about sugar, but it's a little bit easier to understand with >>=, if you understand monads
12:03:06 <vikaton> ohh
12:04:22 <vikaton> im gonna just continue reading, I give up for now
12:04:43 <Zekka> vikaton: If you don't understand what a Monad is, figuring that out might help
12:04:57 <Zekka> Probably learn what a Functor is first, then an Applciative, then a Monad
12:05:04 <Zekka> and then figure out why IO is one
12:05:18 <Zekka> s/why/how
12:06:01 <maerwald> @quote /bin/ls
12:06:01 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:06:18 <bitemyapp> maerwald: 'tis a good one.
12:07:09 <maerwald> bitemyapp: yepp, although I like the RealWorld analogy to explain IO (like SPJ did... but some haskellers strongly disagree)
12:07:19 <bitemyapp> maerwald: I strongly dislike the RealWorld analogy.
12:07:32 <maerwald> bitemyapp: but it's in the implementation of IO
12:07:36 <bitemyapp> maerwald: one of the secret chapters in the book is about IO and I am hoping it would will dispel some of the magic.
12:07:41 <bitemyapp> maerwald: that's nomenclature, not pedagogy
12:07:50 <bitemyapp> maerwald: and it's more of a state token than a signifier for the state of the universe.
12:07:53 <hpc> it's in ghc's "pretend this is the implementation" definition
12:08:01 <maerwald> I find it highly useful
12:08:17 <bitemyapp> maerwald: I don't think it communicates anything useful.
12:08:40 <bitemyapp> maerwald: you cannot use that explanation to explain or predict anything about how IO works and it tells you literally nothing about why it was invented or designed in the manner that it was.
12:08:43 <maerwald> I think it communicates how you use IO with monads and why IO is without sideeffects
12:08:49 <bitemyapp> maerwald: it's an after the fact construction. a story.
12:08:53 <maerwald> and SPJ wrote a paper using that analogy which I find very useful
12:09:06 <bitemyapp> maerwald: I strongly dislike explanations that provide no power to 
12:09:11 <bitemyapp> understand how things work or will behave.
12:09:22 <bitemyapp> I also don't like the conflation of IO with Monad.
12:09:27 * hodapp craves burritos suddenly.
12:09:30 <bitemyapp> there's some history behind that, but it's not a good explanation.
12:09:39 <maerwald> I disagree
12:09:51 <maerwald> it's not a complete explanation
12:09:55 <hpc> specific example where RealWorld# breaks is concurrency
12:09:56 <bitemyapp> it explains nothing.
12:10:08 <hodapp> RealWorld?
12:10:14 <hodapp> as in RWH?
12:10:18 <bitemyapp> no
12:10:21 <bitemyapp> IO
12:10:37 <bitemyapp> people saying IO is like having the state of the universe passed in as an argument and then a possibly modified version returned
12:10:41 <bitemyapp> which is
12:10:43 <bitemyapp> 1. Utter nonsense
12:10:45 <bitemyapp> 2. Tells the reader nothing
12:11:03 <bitemyapp> 3. Should be eschewed in favor explanations that explain something, anything, about IO, it's history, what purpose it serves, or what it does.
12:11:06 <maerwald> bitemyapp: that is wrong, see https://github.com/ghc/packages-ghc-prim/blob/ad9bf96815cb5a9bb4acc51c99eff20be3e50da3/GHC/Types.hs#L82
12:11:23 <bitemyapp> maerwald: I said it was nomenclature in the code.
12:11:29 <hpc> maerwald: that definition is a lie
12:11:34 <bitemyapp> maerwald: it is also a lie.
12:11:38 <bitemyapp> maerwald: and it explains nothing.
12:12:05 <bitemyapp> maerwald: I have discussed the design and implementation of IO with one of the people that designed and implemented multiple versions of it in GHC at length.
12:12:10 <hpc> another specific example that breaks under the assumption of that being the definition
12:12:13 <hpc> is unsafePerformIO
12:12:13 <bitemyapp> maerwald: I understand it just fine. It explains nothing.
12:12:18 <bitemyapp> hpc: yes, thank you!
12:12:26 <bitemyapp> unsafePerformIO is a great litmus test here.
12:12:28 <hpc> if RealWorld passing was the real implementation, unsafePerformIO would be IMPOSSIBLE to write
12:12:40 <bitemyapp> @karma+ hpc
12:12:41 <lambdabot> hpc's karma raised to 12.
12:12:50 <hodapp> what's the significance of this code?
12:12:54 <bitemyapp> maerwald: that so many people believe as you do, is why I have to write a chapter on IO.
12:12:59 <hpc> hodapp: there is none
12:13:11 <bitemyapp> back to my coffee and writing now.
12:13:14 <hpc> it's ghc secret sauce that makes a few things compile and a few other things come into scope
12:13:17 <dolio> You don't need concurrency or unsafePerformIO for RealWorld to make no sense.
12:13:30 <hodapp> hpc: in that sense, anything we see there is then incidental?
12:13:47 <hpc> hodapp: not everything, there's a legit definition of Ordering and a few other things
12:13:47 <dolio> Just semantics of functions.
12:13:53 <maerwald> http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf I still find this useful and I don't see a _strong_ argument for not using that analogy. No one claimed that it is _complete_ or without contradiction
12:14:10 <hpc> hodapp: but almost all of it you have to pretty much be sitting in front of the ghc source code to understand
12:14:15 <hpc> like data (~) a b
12:15:34 <hpc> maerwald: the argument for not using it is that it doesn't reflect reality and there are better ways to explain it that actually make sense
12:15:59 <hpc> it's like teaching the ether instead of relativity
12:16:03 <maerwald> hpc: I haven't seen a better way, although I have listened to a lot of people trying to explain it better
12:16:22 <mada> data [] a = [] | a : [a]
12:16:26 <mada> so that is 
12:16:45 <mada> So that is *really* the actual list definition?
12:16:50 <hpc> mada: yep
12:17:22 <hpc> [] is given some parser magic by the language specification, and the rest is the usual semantics of data types
12:17:38 <hpc> (and (:) gets parser magic but less blatantly)
12:17:40 <mada> hpc: ah, there's parser magic involved, ok
12:17:56 <hpc> basically all there is to it is
12:18:03 <dolio> I don't think the report says that that's legal syntax. [] is just built in.
12:18:11 <dolio> But GHC actually implements a parser hack to make the definition work.
12:18:22 <hpc> ah, that would make more sense
12:18:29 <vikaton> Zekka: is this a good place to read about them? http://learnyouahaskell.com/functors-applicative-functors-and-monoids
12:18:35 <dolio> Because it's easier than making [] built-in.
12:18:43 <Zekka> vikaton: I didn't like lyah's explanation for this that much, let me link you my favorite typeclass explanation
12:19:03 <hpc> ghc makes ':' an upper-case symbol character (which makes it look like a constructor and an infix operator)
12:19:15 <Zekka> https://wiki.haskell.org/Typeclassopedia <- this article starts with Functor, Applicative, and Monad, and goes through a lot of other typeclasses after
12:19:22 <hpc> and it makes "[]" an upper-case plain old identifier token
12:19:28 <hpc> same as Nothing or BobDole
12:19:44 <vikaton> thanks
12:19:47 <dolio> : being 'upper case' is real.
12:19:56 <mada> it is?
12:20:00 <bitemyapp> dolio: that's hilarious but a good solution.
12:20:03 <dolio> Well, as far as the report.
12:20:16 <dolio> Like 'data Foo = a :%% b'
12:20:20 <Zekka> dolio: Is ~ uppercase too?
12:20:27 <hpc> or data Complex a = a :+ a
12:20:27 <dolio> No.
12:20:59 <Zekka> dolio: But isn't it a valid constraint name?
12:21:07 <dolio> Zekka: Type operators other than (->) don't exist in the report, though.
12:21:12 <hpc> dolio: https://github.com/ghc/packages-ghc-prim/blob/ad9bf96815cb5a9bb4acc51c99eff20be3e50da3/GHC/Types.hs#L106 - what's going on here then?
12:21:13 <dolio> No.
12:22:10 <lamefun> Does Haskell really support being scripted in itself safely? It's what I've been told here...
12:22:11 <dolio> hpc: GHC custom stuff. And like I said, the report doesn't have type operators anyway.
12:22:34 <geekosaur> I assume the comment above the definition of (~) is relevant, yeh
12:22:36 <dolio> I don't really understand why ~ doesn't require the extension. That must just be magic.
12:22:44 <geekosaur> ugly magic hidden inbside ghc
12:23:29 <geekosaur> explicitly wired in special case
12:23:48 <hpc> yeah, i know the comment explains a bunch of kind-level reasons for it to be defined /where/ it is
12:24:00 <dolio> GHC's strategy often seems to be to make the parser and such magic instead of having magic in other places.
12:24:02 <hpc> but doesn't mention the parsing of (~)
12:24:18 <geekosaur> "...and do magic in GHC to change the kind and type, in tysWiredIn"
12:24:24 <dolio> Like, instead of having multiple magic predefined modules or something.
12:24:40 <hpc> geekosaur: ah, i probably just need to know what tysWiredIn is then
12:24:56 <geekosaur> probably a parse specialc ase too, since that'd be needed to get to tysWiredIn
12:29:03 <buttproblem> Haskellfant: thanks. It is just a structure. I'll take a look to see if I can get the wrapper to be automatically generated.
12:36:53 <rom1504> someone should create a programming language called "magic"
12:37:11 <rom1504> right https://en.wikipedia.org/wiki/Magik_(programming_language)
12:40:34 <ion> Nicely put. <hpc> it's like teaching the ether instead of relativity
12:46:22 <frerich> " the best way to make progress was to evolve the language in small incremental steps, each revision integrating only a small number of well-understood extensions and changes. Haskell 2010 is the first revision to be created in this way, and new revisions are expected once per year." -- once per year?
12:47:02 <kadoban> People are bad at predicting the future :)
12:47:11 <Cale> maerwald: The problem with the RealWorld -> (RealWorld, a) approach is that there is no type RealWorld which could possibly work there.
12:47:26 <maerwald> kadoban: isn't that what our whole society depends on? :P
12:47:50 <Cale> maerwald: However, there are data representations capable of capturing all or at least most of the needed IO actions
12:48:32 <maerwald> Cale: I see RealWorld as a "lazy type". Only what is actually needed of the RealWorld is fed in... so not the whole universe (although theoretically yes... but GHC is still not capable of that, unfortunately :P)
12:48:49 <hodapp> aether*
12:49:06 <lamefun> When I was told that Haskell supports safe scripting in itself, have I been kinda tricked? GHC API seems very difficult and error-prone and SafeHaskell doesn't support Template Haskell, so things like refined types or lenses can't be used properly...
12:49:22 <hodapp> 'safe scripting'?
12:49:45 <hodapp> are you talking about with Shelly or Turtle or something?
12:50:19 <kadoban> maerwald: Predicting the future? I hope not, because we're clearly awful at it. Although society is pretty broken too, so .. maybe?
12:50:22 <Cale> lamefun: I don't understand what you're actually trying to do? Can we see your program, and what feature you're trying to support?
12:50:57 <ReinH> lambdabot: I think you're confused about what SafeHaskell does.
12:50:59 <maerwald> kadoban: well, the financial world definitely does that and it plays one of the biggest roles in global matters, but this should probably go to #haskell-blah ;)
12:51:05 <ReinH> What kind of safety are you expecting?
12:51:05 <Cale> maerwald: The thing is, it's hard to imagine actually writing a real interpreter for IO actions based on any model which looks like that RealWorld thing
12:51:36 <Cale> maerwald: But it's easy to imagine writing an interpreter (and actually easy to write that interpreter) if you have something more along the lines of a free monad representation of IO actions.
12:51:38 <ReinH> SafeHaskell can't, e.g., prevent you from using a library that makes a system call to `rm -rf /` in IO
12:51:47 <maerwald> Cale: I have a very vivid imagination, so I don't have a problem with that, but it's good to know that not everyone feels like that
12:52:23 <Cale> maerwald: As a rough approximation if you don't want to explain free monads, you can just define a type with constructors Return and Bind, and then various primitive IO actions
12:52:30 <Cale> Like:
12:52:32 <Cale> data IO a where
12:52:36 <Cale>   ReturnIO :: a -> IO a
12:52:43 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
12:52:49 <Cale>   GetChar :: IO Char
12:52:55 <Cale>   PutChar :: Char -> IO ()
12:53:03 <Cale> etc.
12:53:26 <Cale> If you want to get more sophisticated, you include a constructor which takes the details necessary to make an FFI call
12:54:00 <hpc> and that model still doesn't fully explain unsafePerformIO, but it's much closer to something you can use
12:54:21 <ReinH> (For an actual implementation of this, see http://hackage.haskell.org/package/IOSpec)
12:54:27 <ttt_fff> are MVars GC-ed or do I have to kill them myself?
12:54:43 <Cale> Well, unsafePerformIO becomes this low level hook inside the *evaluator* which calls the executor for IO actions.
12:54:53 <ReinH> And for a nice paper explaining the semantics of such a system, see http://www.staff.science.uu.nl/~swier004/Publications/BeautyInTheBeast.pdf
12:54:58 <lemmih> ttt_fff: They are GC'ed.
12:55:06 <Cale> ttt_fff: There's not even any way to free them explicitly.
12:55:10 <hpc> Cale: i suppose
12:55:16 <ttt_fff> lemmih , Cale: noted, thanks!
12:55:24 <hpc> which is inching closer to the real secret which is that ghc haskell is impure
12:55:50 <hpc> and IO just hides it behind sequencing
12:56:00 <lamefun> Cale, I haven't written any (complete) program yet, but the kind of feature I want is Haskell program, say, Main.hs loads a file Script.hs from source or some kind of platform-independent compiled representation, in securely and in Safe Haskell mode, and interact with it.
12:56:29 <ReinH> lamefun: again, I'm not sure SafeHaskell does what you think it does
12:56:52 <Cale> SafeHaskell on its own won't be enough to make things actually safe
12:57:09 <Cale> (but it helps)
12:57:32 <Cale> You might be interested in the hint library on Hackage
12:57:54 <Cale> It's a simple wrapper around the GHC API which makes it a little easier to load and interpret Haskell code.
12:58:50 <hodapp> Cale: neat!
12:59:11 <hpc> hint is the magic behind mueval
12:59:19 <hpc> > "which is the magic behind lambdabot"
12:59:20 <lambdabot>  "which is the magic behind lambdabot"
12:59:27 <Cale> See also, http://hackage.haskell.org/package/mueval which is used by lambdabot and tryhaskell to provide somewhat safer interpretation.
12:59:56 <Cale> You should still generally be a bit defensive about the environment you're going to run things in if you're accepting user input.
13:00:22 <hodapp> hey, Hackage finally got the docs I wrote for Atom! woot!
13:01:32 <lamefun> ReinH, I've read that it defines a subset of Haskell that can't break out of certain constraints.
13:02:09 <Cale> lamefun: That's true, they're just not exactly the constraints you might be concerned with if you're accepting and executing scripts from people over the web, say.
13:02:31 <ReinH> lamefun: What constraints do you think those are?
13:02:38 <Cale> (they are perhaps a subset of the constraints you'd want though, so it's not like it's entirely unhelpful, it's just not likely to be sufficient)
13:02:50 <ReinH> It doesn't make execution of arbitrary haskell code safe in the sense of "won't destroy your hard drive"
13:03:41 <hpc> the safety in SafeHaskell refers to protecting the programmer from their own foolishness
13:03:46 <hpc> type safety, etc
13:03:58 <hpc> safety is very much distinct from security
13:04:00 <ReinH> segfaults
13:04:15 <ReinH> hpc: well, not distinct, but not sufficient either
13:04:15 <hodapp> lamefun: have you looked at Shelly or Turtle though?
13:04:29 <ReinH> reliability is central to security
13:05:05 <lamefun> ReinH, Like if I define a RIO monad that implements some restrictions I've defined and only ever call functions that return RIO a then they can't break out?
13:05:16 <ttt_fff> is there a haskell-politics channel?
13:05:19 <int-e> "safe" code is supposed to be unable to break the type system, have coherent type class instances.
13:05:30 <ReinH> not use unsafePerformIO in unsafe ways
13:06:14 <int-e> lamefun: reluctantly, yes, that should work. but it's wise not to rely on it as a security mechanism by itself
13:07:03 <hpc> @remember ReinH (about SafeHaskell) not use unsafePerformIO in unsafe ways
13:07:03 <lambdabot> It is forever etched in my memory.
13:09:09 <breadmonster> Hey guys.
13:09:23 <lamefun> From GHC documentation: "Safe Haskell has been designed with two use cases in mind: [..] Compiling and executing untrusted code". Is this a lie?
13:09:54 <mzero> hullo breadmonster
13:11:26 <breadmonster> What do existential quantifiers do?
13:11:39 <breadmonster> One of them is forall, but I've never seen there exists being used in a program.
13:12:26 <lamefun> int-e, how is it useful at all if I can't rely on it?
13:13:09 * hackagebot ether 0.1.0.0 - Monad transformers and classes  http://hackage.haskell.org/package/ether-0.1.0.0 (int_index)
13:14:01 <ReinH> lamefun: You can't rely on it to do something it isn't designed to do.
13:14:39 <lamefun> ReinH, then GHC documentation is a lie? "Safe Haskell has been designed with two use cases in mind: [..] Compiling and executing untrusted code".
13:14:41 <ReinH> It's useful for doing what it's designed to do.
13:14:49 <int-index> It's on Hackage \o/
13:14:54 <int-index> https://int-index.github.io/ether/
13:15:56 <mzero> breadmonster: I don't think there is an  "exists" extension at all
13:16:22 <ion> breadmonster: forall (a :: *). b is like * -> b where the first parameter is in scope as ‚Äúa‚Äù within b, exists (a :: *). b is like (*, b) where the type member is in scope as ‚Äúa‚Äù within b.
13:16:59 <breadmonster> ion: Sure I got that.
13:17:08 <breadmonster> But is there a there exists in Haskell?
13:17:55 <breadmonster> ion: Also, what's the difference between XExistentialQuantification and XRank2Types?
13:18:11 <int-e> lamefun: Well, the weaknesses for that purpose that I'm aware of are a) a safe IO function can do whatever it pleases. b) any modules can be "Trustworthy" and use unsafePerformIO in whatever way they please. You have to trust these packages, but are you reviewing all the trusted modules? c) AFAIU, SafeHaskell doesn't solve the problem of incoherent orphan instances in a diamond dependency situation.
13:18:12 <Imagine> I haven't gotten this error before so I don't know exactly what it is -- its pretty simple, could someone help me out? 
13:18:25 <Imagine> http://lpaste.net/134462
13:19:16 <hodapp> Also, "designed* with ... in mind" doesn't mean "perfect at accomplishing ...".
13:20:11 <nschoe> Imagine, your vLengthSquared instance, you wrote "::" instead of "="
13:20:21 <Imagine> oh
13:20:21 <Imagine> wow
13:20:25 <Imagine> can't believe I didn't see that
13:20:26 <Imagine> thanks
13:20:33 <Imagine> same with vSub
13:20:33 <ReinH> lamefun: SafeHaskell doesn't automatically make things safe, it makes it *possible* to ensure (some value of) safety to some degree of confidence.
13:20:37 <lamefun> So should I stop browsing the Web then because of JavaScript? Exploits are found in JavaScript sandboxes, so it isn't "prefect at accomplishing" as well...
13:20:50 <nschoe> Imagine, it happens sometimes :-)
13:21:07 <breadmonster> I can't seem to figure out how this works.
13:21:39 <hodapp> lamefun: I'm not sure what sort of strawman you're trying to swing at here, but please just stop.
13:21:46 <int-e> lamefun: (I'm running lambdabot at the moment, which is why I've thought about this. a) is tricker than it seems; for example, until recently, @check would accept arbitrary QuickCheck properties, but it turned out that one can embed IO actions into those (thanks benzrf)... but because of b) and c) I'm also running mueval in its own small sandbox)
13:21:48 <ReinH> "X's intended use is Y" doesn't meant that X automatically grants Y.
13:22:03 <benzrf> :)
13:22:21 <ReinH> lamefun: Non sequitur
13:22:45 <int-e> lamefun: you could use noscript?
13:23:08 <int-e> (which ironically is a pile of XML and javascript itself. oh well.)
13:23:59 <benzrf> int-e: wait, so did you alter @check
13:24:00 <lamefun> `"X's intended use is Y" doesn't meant that X automatically grants Y.` - same with browser JavaScript sandboxes, they aren't perfectly 100% secure.
13:24:06 <int-e> benzrf: yes.
13:24:09 <benzrf> ah
13:24:16 <benzrf> int-e: hows it different now?
13:24:22 <int-e> benzrf: it uses https://hackage.haskell.org/package/QuickCheck-safe
13:24:40 <benzrf> neat
13:24:58 <ReinH> I never suggested that you shouldn't use SafeHaskell
13:25:19 <hodapp> lamefun: Does this mean that the sandboxes are "lies"?
13:25:21 <ReinH> I only suggested that you should understand it first.
13:26:07 <int-e> benzrf: which still isn't quite Safe (there's an impure function in there), but at least I don't know how to exploit it anymore
13:27:23 <benzrf> >.>
13:27:24 <ion> breadmonster: There is no exists in Haskell. But you can do ‚Äúdata Foo where { Foo :: a -> Foo }‚Äù where a Foo value is like an exists a. a value. Or you can do a CPS transform: exists (a :: *). b ‚âà (*, b) ‚âà ((*, b) -> r) -> r ‚âà (* -> b -> r) -> r ‚âà (forall (a :: *). b -> r) -> r
13:27:53 <ReinH> hodapp: For some value of "lie", yes. The bigger mistake is believing that security is a binary property.
13:28:41 <Imagine> There's a saying that goes something like "Everybody can build a system that they themselves cannot break into. But it is not secure until nobody else can break into it either"
13:28:55 <Imagine> at least I read it somewhere
13:29:19 <ion> breadmonster: ExistentialQuantification can be used for the ‚Äúdata Foo = forall a. Foo a‚Äù syntax which can be alternatively written as a GADT: ‚Äúdata Foo where { Foo :: a -> Foo }‚Äù. RankNTypes can be used for a type like (forall a. b -> r) -> r where the forall is not in a rank-1 position, that is, the ‚Äúroot‚Äù of the type.
13:29:43 <ReinH> Security is a spectrum, and "secure enough" is ultimately a business decision.
13:30:13 <lamefun> hodapp, but I've been told that ("they're just not exactly the constraints you might be concerned with if you're accepting and executing scripts from people over the web"), which implies that GHC documentation says that ("Safe Haskell has been designed with two use cases in mind: [..] Compiling and executing untrusted code") while the actual implementation intentionally doesn't even try.
13:30:39 <ReinH> No, it doesn't.
13:31:15 <ReinH> It only implies that SafeHaskell is insufficient, which we have already said repeatedly in a variety of ways.
13:32:00 <ion> breadmonster: A CPS transform combined with currying, that is
13:33:19 <lpaste> elbiot pasted ‚Äúunnesting a nested list?‚Äù at http://lpaste.net/134463
13:33:46 <elbiot> Total noob here with a question about an exercise un-nesting a nested list
13:34:16 <elbiot> Oops, see my paste right before my post
13:34:16 <ion> Given x:xs, if x :: NestedList a then xs :: [NestedList a]
13:34:36 <ion> @type (:)
13:34:37 <lambdabot> a -> [a] -> [a]
13:36:25 <ion> You could do this: flatten (List xs) = concatMap flatten xs
13:36:43 <elbiot> ion, what is @type?  fails in ghci and hoogle
13:36:54 <ion> elbiot: The lambdabot command equivalent to :type in ghci
13:37:19 <ion> You can just input (:) to Hoogle
13:37:37 <ion> Although the results aren‚Äôt very good it seems.
13:37:38 <bennofs> I repeatedly hear that ghc-mod does not currently work with GHC 7.10. Does anyone have a link to the relevant issue?
13:37:51 <elbiot> is [NestedList a] not a list?
13:38:06 <ReinH> The argument being made in the GHC docs is that SafeHaskell is necessary, not that it is sufficient.
13:38:07 <zygentoma> not a list of a ‚Ä¶
13:38:10 * hackagebot record 0.4.0.2 - Anonymous records  http://hackage.haskell.org/package/record-0.4.0.2 (NikitaVolkov)
13:38:35 <ion> xs :: [NestedList a] is a list, but not a value matching the List data constructor.
13:38:53 <ion> A value matching List _ has the type NestedList a
13:40:30 <elbiot> so [NestedList a] is not short for a List of NestedLists?
13:40:38 <breadmonster> ion: This ExistentialQuantification stuff is interesting, I can't seem to implement a Show instance for `data Any = forall a. Any { runAny :: a }`
13:40:50 <breadmonster> Unless I declare XUndecidableInstances.
13:41:37 <elbiot> oh wait... Pattern matching... brain slowly changing...
13:42:14 <roboguy_> elbiot: List and [] are different
13:43:46 <ion> @let data MyAny = forall a. Show a => MyAny a; deriving instance Show MyAny
13:43:47 <lambdabot>  Defined.
13:43:53 <ion> > [MyAny "hello", MyAny 42]
13:43:55 <lambdabot>  [MyAny "hello",MyAny 42]
13:44:21 <ion> @undefine
13:44:22 <lambdabot> Undefined.
13:44:40 <ion> @let data MyAny where { MyAny :: Show a => a -> MyAny }; deriving instance Show MyAny
13:44:42 <lambdabot>  Defined.
13:44:44 <ion> > [MyAny "hello", MyAny 42]
13:44:46 <lambdabot>  [MyAny "hello",MyAny 42]
13:45:03 <ion> breadmonster: You can‚Äôt show the ‚Äúa‚Äù unless it has a Show constraint.
13:49:54 <elbiot> So, flatten takes a NestedList, but xs is a List [NestedList], so List xs is a NestedList that matches flatten's input type?
13:50:25 <roboguy_> elbiot: xs is a [NestedList]
13:50:27 <ion> xs is a [NestedList a] but flatten wants a NestedList a.
13:50:28 <roboguy_> List isn't a type
13:50:39 <lamefun> ReinH, so Safe Haskell exists but it is currently unusable?
13:50:43 <roboguy_> List is a data constructor of the NestedList type
13:51:00 <ion> You can construct a NestedList a out of an xs :: [NestedList a] by applying the List data constructor to xs.
13:51:34 <dmwit> lamefun: What makes you say it is unusable?
13:52:01 <elbiot> List is not a type.  It's a data constructor.  Got it
13:52:54 <lamefun> dmwit, ie. it exists but it's impossible to safely compile and load restricted modules?
13:53:13 <dmwit> I don't think that's right.
13:53:22 <dmwit> It's possible, you just need to use more tools than merely Safe Haskell.
13:53:54 <roboguy_> With vty-ui, is there an easy way to move the cursor one place in a given direction (up, down, left, right)?
13:56:25 <lamefun> dmwit, that's what my original question was about: "When I was told that Haskell supports safe scripting in itself, have I been kinda tricked? GHC API seems very difficult and error-prone...", the GHC API looks very difficult and it looks easy to botcher safe compilation...
13:56:44 <scutigera> aloha
13:56:48 <ion> breadmonster: Pretty much the only thing you can do with an (exists a. Show a *> a) (which is a pseudosyntax equivalent to MyAny) is show it. Similarly, pretty much the only thing you can do with an (forall a. Show a => a -> r) -> r is give it show as the continuation.
13:57:31 <roboguy_> lamefun: I feel like Safe Haskell isn't really the tool you want for this. Have you looked into hint and lambdabot?
13:58:40 <roboguy_> and mueval
13:59:16 <roboguy_> lamefun: http://hackage.haskell.org/package/mueval
13:59:50 <lamefun> both are built on top of GHC API...
14:00:14 <roboguy_> yeah... what's wrong with that?
14:00:21 <matsuura> nothing
14:01:36 <dmwit> For what it's worth, I don't know of any language which makes it push-button easy to accept code from the Internet and execute it.
14:02:12 <dmwit> All the solutions I know of use several tools to mitigate attacks of various kinds. Resource limits, file-system jails, separate network domains, etc.
14:02:42 <dmwit> This is because it is a complicated problem, and different applications require different scripting permissions.
14:02:46 <dmwit> Nothing to be surprised about there.
14:03:03 <lamefun> dmwit, JavaScript kinda does, ie. Google V8 API, you create a context that initially has no external IO at all and then you add bindings.
14:03:11 <dmwit> Safe Haskell is one of the tools you should have in your bag for mitigating these attacks. It promises that code that says it doesn't do IO really doesn't do IO.
14:03:22 <voidzero> dmwit, TempleOS!
14:03:32 <voidzero> http://www.codersnotes.com/notes/a-constructive-look-at-templeos
14:04:23 <pharaun> oh man templeos
14:04:31 <dmwit> lamefun: Sounds like a similar protection to what Safe Haskell gives you; e.g. it doesn't protect against infinite loops, high allocation, etc.
14:04:58 <dmwit> lamefun: Which I assumed was your complaint about Safe Haskell. Though I don't have enough context to know for sure.
14:07:13 <elbiot> I'm pretty lost.  I can only think of x:xs as matching the first element of a list followed by the rest of the list.
14:07:32 <nolraiU> @pl \ x y = return $ g (fm x) (fm y)
14:07:32 <lambdabot> (line 1, column 7):
14:07:32 <lambdabot> unexpected "="
14:07:32 <lambdabot> expecting pattern or "->"
14:07:37 <nolraiU> @pl \ x y -> return $ g (fm x) (fm y)
14:07:38 <lambdabot> (return .) . (. fm) . g . fm
14:07:49 <roboguy_> elbiot: that's correct
14:08:07 <nolraiU> @pl \ x y -> liftM2 g (fm x) (fm y)
14:08:07 <lambdabot> (. fm) . liftM2 g . fm
14:08:16 <elbiot> Where flatten gets something that matches List, I expect to get the first element and the rest of the list
14:08:21 <roboguy_> elbiot: Maybe it would help to rename "List" to something else, maybe "Multi" or something
14:08:28 <elbiot> But the rest of the list is not a list?
14:08:35 <merijn> lamefun: V8 actually inspects all assembly to sandbox code, including a formal verification of sandboxing and yet they still discovered exploits for it
14:08:48 <lamefun> "infinite loops", "high allocation" - use rlimit or multiprocessing?
14:08:53 <nolraiU> @pl \ g f x y -> g (f x) (f y)
14:08:53 <lambdabot> join . ((flip . ((.) .)) .) . (.)
14:09:05 <nolraiU> @pl \ x y -> g (f x) (f y)
14:09:05 <lambdabot> (. f) . g . f
14:09:12 <merijn> lamefun: I've been talking with some colleagues doing security research, the likelihood of managing to completely sandbox untrusted code is near zero
14:09:12 <KaneTW> nolraiU: you can /msg lambdabot 
14:09:18 <nolraiU> Yeah, sorry.
14:09:38 <pavonia> elbiot: In (x : xs), x is an element and xs is a list of the same type as (x : xs)
14:09:59 <nolraiU> Just would have thought there was a combinator for g (f x) (f x).
14:10:00 <int-index> How do I tell Hackage to use GHC 7.10 for documentation?
14:10:36 <roboguy_> elbiot: is this a bit more clear? http://lpaste.net/134464
14:11:03 <pavonia> :t Data.Function.on
14:11:04 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:11:15 <dmwit> lamefun: Yes, and I would assume people are telling you "use Safe Haskell + rlimit", etc. So I don't really know why you're acting surprised.
14:11:30 <bennofs> merijn: is there some resource where I can read more about the formal verification of the sandbox code of V8?
14:11:33 <lamefun> merijn, I'm not complaining that there can be loopholes.
14:11:34 <ReinH> lamefun: You seem determined to make my statements mean whatever you want them to mean. No, I did not say that.
14:12:05 <roboguy_> nolraiU: is that second x supposed to be a y?
14:12:08 <dmwit> int-index: There's a way to upload your own documentation bundle, I believe.
14:12:11 <merijn> bennofs: It was mentioned off-hand in a conversation with someone working on that
14:12:12 <ReinH> I said it is not sufficient.
14:12:22 <dmwit> int-index: I don't know much about it, but perhaps Google does.
14:12:53 <dmwit> elbiot: in `List (x:xs)`, xs is a list, but it is not a NestedList.
14:13:37 <int-index> dmwit: thanks
14:15:29 <breadmonster> Why is there no exists in Haskell?
14:15:32 <breadmonster> Only forall?
14:15:45 <elbiot> roboguy_ I'm thinking about it
14:16:27 <dmwit> breadmonster: historical reasons, mostly
14:16:33 <ion> AFAIU UHC has exists.
14:16:45 <merijn> dmwit: Also religious reasons :p
14:17:10 <merijn> Yeah, UHC has exists
14:18:16 <lamefun> merijn, is there a good way to dynamically build and load untrusted modules (preferably as native code so that they're actually fast)?
14:18:35 <ReinH> breadmonster: (Strictly speaking, Haskell doesn't have forall either. It is introduced by GHC extension(s))
14:19:17 <Cale> breadmonster: Basically, to avoid needing an additional keyword, the syntax for existential types just puts the forall in an appropriate location (forall and exists are related in such a way that this is possible)
14:19:31 <ReinH> But I think the answer you are looking for is that forall as used in ExistentialQuantification is equivalent to exists.
14:19:38 <merijn> lamefun: Hell no, and I mean that in any language
14:19:57 <ion> lamefun: https://en.wikipedia.org/wiki/Seccomp
14:20:07 <Cale> Well, if there *were* an exists keyword used by ExistentialQuantification, it would be located in a different place from the forall which is used now
14:20:32 <elbiot> Wow! how does that compile?  Nested is an arbitrary data constructor? 
14:20:34 <Cale> i.e. instead of writing   data Foo = forall a. Foo ...   you'd be writing  data Foo = Foo (exists a. ...)
14:20:43 <ReinH> Yes, I didn't mean literally equivalent. I meant an equivalent construction.
14:21:05 <ReinH> Good clarification thanks
14:21:17 <roboguy_> elbiot: You can call it anything. List was just a made up name for one of the constructors of the NestedList type, just like "Nested" is here
14:22:25 <roboguy_> elbiot: Have you seen the definition of the Maybe type? They are data constructors for NestedList just like "Nothing" and "Just" are for Maybe
14:22:27 <lamefun> merijn, even JavaScript?
14:23:01 <roboguy_> Is this relationship between exists and forall related to Skolemization?
14:23:28 <elbiot> roboguy_ haven't  I'm just a few hours into haskell.  Maybe I should just let it go and it'll make sense on another iteration.
14:23:33 <Cale> lamefun: Especially Javascript?
14:24:03 <roboguy_> elbiot: I would suggest looking at Maybe before looking at NestedList. I think that would help things to make more sense
14:24:31 <dmwit> When I first saw the definition of Maybe I actually laughed out loud in delight.
14:24:34 <elbiot> I'll check it out.  I'm just going through 99 haskell problems
14:24:41 <dmwit> ?src Maybe
14:24:41 <lambdabot> data Maybe a = Nothing | Just a
14:25:30 <Cale> lamefun: The only reason Javascript is safe at all in browsers is because the browser itself is providing a very limited environment for the code to run in. Even then, it can be a security problem.
14:25:36 <ReinH> dmwit: :)
14:26:40 <Cale> lamefun: and I don't know of many implementations of Javascript in Javascript
14:27:15 <roboguy_> lamefun: what's the overall goal?
14:27:29 <ReinH> As a heuristic, languages with eval are probably less safe than those without.
14:27:36 <lamefun> "very limited environment for the code to run in" - I thought Safe Haskell promises just that? "Even then, it can be a security problem." - I'm not asking for 100% proven perfect unbeatable security.
14:28:09 <dmwit> I think I'm lost about what the actual complaint against Safe Haskell is.
14:28:27 <Cale> lamefun: Safe Haskell is not in any regard a virtual machine
14:28:28 <roboguy_> ReinH: ! http://hackage.haskell.org/package/hint-0.4.2.3/docs/Language-Haskell-Interpreter.html#v:eval
14:28:35 <pharaun> lamefun: safe haskell + mueval + useland limits/etc + other things as you want to go up and up in the "safety" range (could even end up with running it inside a kvm instance)
14:28:41 <ReinH> lamefun: The only thing we've been saying is that SafeHaskell is not sufficient. You must do extra work to achieve a level of safety you are comfortable with. That's it.
14:28:46 <pharaun> and there even has been cases where folks can break out of a vm
14:29:00 <Cale> lamefun: If you read this, it should be clearer what Safe Haskell is and what it's not https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe-haskell.html
14:29:15 <ReinH> Well, maybe you are comfortable with the level SafeHaskell provides. I am not.
14:29:32 <Cale> lamefun: Safe Haskell doesn't even guarantee that *compiling* the code is a safe thing to do.
14:29:51 <ReinH> But you need to at least know what that level is before you can make an informed decision.
14:30:08 <Cale> lamefun: It provides some very weak guarantees about what the resulting code is able to do, which are useful if you're trying to analyse whether the code is correct.
14:30:17 <elbiot> I'm going to pop out an mull on Maybe a bit.  Thanks
14:30:30 <Cale> (but are not the sort of guarantees you want if you're going to be executing untrusted user code)
14:31:42 <Cale> It might be a vital component in such an environment for executing untrusted user code, but it's certainly nowhere near sufficient for that purpose.
14:31:59 <elbiot> Thanks dmwit ion and roboguy_
14:32:06 <Cale> You still have to be super-careful, and it would probably be best to just run everything in a VM jail.
14:32:15 <roboguy_> elbiot: No problem! You should come back if you have any more questions
14:32:35 <Cale> (depending on exactly how untrusted the code is)
14:33:03 <pharaun> iirc there's bots and stuff existing that will boot up vm, inject the code in it and run it then extract the results
14:33:21 <pharaun> should be able to draw upon those existing implementation for inspiration
14:33:30 <merijn> pharaun: And with the current rate of VM escapes being invented that's not safe either
14:33:49 <pharaun> merijn: yeah, there is nothing that is going to be 100% safe :D
14:34:14 <roboguy_> Looks like someone is trying to DoS us or something
14:34:19 <pharaun> hm?
14:34:42 <roboguy_> lots of "SCHAPP137 has joined/SCHAAP137 has left IRC (Excess Flood)" messages
14:34:48 <pharaun> ah :|
14:34:50 <ReinH> As someone whose job it once was to built a system that literally executed other people's untrustworthy code, I want to impress upon you how difficult this problem actually is.
14:34:54 --- mode: ChanServ set +o Cale
14:34:59 <roboguy_> I don't know enough about IRC to know what that means for sure, but I *think* it's a DoS thing maybe
14:35:13 <merijn> roboguy_: Freenode is nearly constantly being spammed/DDoSed
14:35:16 --- mode: Cale set +b *!qorrie@unaffiliated/schaap137
14:35:27 <Cale> errr
14:35:31 <pharaun> i find it sad that freenode is being spammed/ddosed
14:35:32 <merijn> Are there any haskell livecoding/music synth things?
14:35:53 <Cale> derp, why didn't my ban apply?
14:35:53 --- mode: ChanServ set +o glguy
14:35:58 <vikaton> I'm getting a parse error '=' line 2 but dik why
14:36:00 <vikaton> https://www.irccloud.com/pastebin/NZzv3eW5/
14:36:00 --- mode: glguy set +b *!*@dhcp-077-249-247-124.chello.nl
14:36:01 <matsuura> hmm, http://i.imgur.com/zswBSjX.jpg
14:36:09 <vikaton> not quite sure if that even works in Haskell :/
14:36:14 <vikaton> hope it does :P
14:36:38 <roboguy_> vikaton: it doesn't, but "fix error" is fun
14:36:46 <Cale> vikaton: You want `mod` not mod
14:37:00 <Imagine> Anybody here use emacs by any chance? I'm trying to get (linum-mode) to execute automatically upon startup but it's only executing if I go into the init page and do M-x eval-buffer
14:37:02 <roboguy_> oh, nm
14:37:22 <matsuura> Imagine: check out #emacs.. They're pretty crafty
14:37:33 <vikaton> Cale, thanks, is that it?
14:37:48 <Cale> vikaton: I didn't bother to check for other errors yet
14:37:54 <vikaton> ok
14:38:02 <Cale> oh, er
14:38:15 <Cale> Wait, what?
14:38:19 <matsuura> Cale: hey buddy. :-) 
14:38:19 <roboguy_> merijn: like Tidal?
14:38:27 <Cale> This is a list comprehension with declarations in it?
14:38:44 <merijn> roboguy_: I saw tidal, but it seems very stringly typed?
14:38:51 <Cale> vikaton: lol, apparently I didn't bother to look at it very hard, this is just deeply confused
14:39:13 <roboguy_> merijn: Hmm, that's possible. I haven't looked at it yet
14:39:30 <merijn> roboguy_: 'd1 $ (brak (sound "bd sn:2 bd sn"))' and such
14:39:34 <Cale> vikaton: I think you probably want to declare a function separately, and then use that function in your list comprehension. Or else you want to use a case expression with guards.
14:39:59 <Cale> vikaton: Function declarations are not expressions.
14:41:15 <roboguy_> merijn: that does look a bit unfortunate. I wonder if the dynamic-ish vs static typing tradeoff is a bit different in that context than it is normally though, since you are writing code that is run immediately during a live performance
14:41:46 <ReinH> let <decls> in <exp> is an expression, fwiw
14:41:47 <roboguy_> Less long term maintainability concerns, more "get it working now" concerns
14:42:31 <Imagine> matsuura - thanks, they solved my problem :)
14:42:56 <matsuura> Imagine: many of them live in emacs. No problem :-)
14:42:58 <merijn> roboguy_: If I'm gonna do dynamic I might as well use one of the more popular lisp livecoding things
14:43:26 <definity> In my book it says that [1,2,3] is syntactical sugar for 1:2:3[] but when i try to create a list using the latter method i get an error, how come?
14:43:42 <Imagine> haha I'm sure they do. I'm trying to learn how to use basically anything that isn't sublime hahaha
14:43:48 <ReinH> definity: 1:2:3:[]
14:43:49 <Imagine> definity - you need (:) before the last list
14:43:53 <Imagine> 1:2:3:[]
14:44:05 <merijn> > 1:2:3:[]
14:44:06 <lambdabot>  [1,2,3]
14:44:14 <ReinH> So slow
14:44:20 <Imagine> lol yeah
14:44:28 <matsuura> What's wrong with [1,2,3] ?
14:44:33 <ReinH> Nothing
14:44:42 <definity> Ahh syntax, thanks :)
14:44:51 <matsuura> 1:2:3:[] seems like too many keys to press
14:44:56 <definity> Nothing but just what in my book
14:45:06 <matsuura> Ah, okay
14:45:08 <ReinH> Thus the sugar
14:45:16 <merijn> matsuura: Right, which is why we have the sugar, but you can't express everything using the sugar
14:45:18 <ronh-> nobody actually uses 1:2:3:[], but it is useful to know that this is what [1,2,3] desugars to
14:45:20 <definity> yeah to be honest i prefer the more reable way [1,2,3]
14:45:30 <lamefun> ReinH, at least when I'm using V8 I'm delegating the problem to experienced V8 developers... V8 provides locked-down-by-default environment that you then export the necessary functionality into.
14:45:35 <merijn> "foo (a:b:c:_) =  something" <- this cannot be written using the sugared version
14:46:05 <ReinH> .oO typing on a phone forces me to be much more succinct. Maybe I should always type on a phone.
14:46:10 <definity> merijn: Ha, Im reading about that now :)
14:46:27 <ReinH> lamefun: Ok.
14:46:34 <matsuura> What exactly is meant by sugar? Doesn't seem sensibly sweet at all.
14:46:49 <definity> Easy on the eye i think
14:46:52 <ReinH> It's totally sweet.
14:47:42 <ReinH> It's nicer. Although I suppose "syntactic spice" could work just as well, given "sugar and spice and everything nice"
14:48:27 <matsuura> Haha, okay guys. :-)
14:48:37 <ion> The spice must flow
14:48:56 <merijn> Muad'dib! Muad'dib! Muad'dib!
14:49:04 <ReinH> matsuura: :)
14:49:11 <Imagine> style question : is a default of 4 indents preferred to 2?
14:49:19 <Imagine> (4 spaces*)
14:49:27 <matsuura> 3 spaces
14:49:31 <ion> Dunno, but i personally use 2.
14:49:39 <hpc> 3 tabs
14:49:39 <roboguy_> I personally use 2
14:49:40 <ion> I‚Äôd prefer elastic tab stops.
14:49:47 <lamefun> I initially thought that Safe Haskell + GHC API can provide something like V8, ie. compiling a set of modules with Safe Haskell forced on them and then dynamically loading and interacting with them.
14:50:02 <dmwit> http://dmwit.com/tabs <- my take on indentation
14:50:11 <matsuura> dwins: thanks! :-)
14:50:14 <maerwald> Imagine: I think most people use 2 in haskell
14:50:15 <raichoo> In the GHC source they seem to use 4 (at least at the places I looked) I use 2.
14:50:26 <pharaun> i use 4 space, but once in a while i'll use 2 for like where
14:50:27 <vikaton> may I see an excmaple of case with gurads?
14:50:36 <vikaton> not sure what to put into the pattern
14:50:44 <dmwit> > case undefined of _ | False -> "nope" | otherwise -> "yup"
14:50:46 <lambdabot>  "yup"
14:50:56 <maerwald> Imagine: but then again... you often format your code to look "pretty" ignoring indenting convention anyway
14:51:21 <dmwit> "what to put into the pattern" depends very much on what you want the code to do.
14:51:46 <dmwit> maerwald: Alignment conventions are a completely orthogonal issue to indentation ones.
14:51:50 <ReinH> Any even number of spaces less than 6 is reasonable.
14:52:03 <dmwit> Well. "Completely orthogonal" might be too strong.
14:52:11 <Cale> lamefun: You can do exactly that, but it won't be a very safe thing to do if the modules come from people you don't know.
14:52:13 <roboguy_> where-clauses are my main reason for using 2 spaces
14:52:30 <vikaton> :S
14:52:33 <ReinH> There is no "completely orthogonal". There is only orthogonal and not orthogonal. :p
14:52:43 <maerwald> dmwit: I don't think so
14:52:53 <dmwit> maerwald: I agree with you.
14:52:57 <dmwit> (I take it back.)
14:52:59 <maerwald> :D
14:53:03 <maerwald> funny
14:53:05 <dmwit> But they're not as connected as most people believe.
14:53:13 <maerwald> yeah, it was just a sidenote anyway
14:53:39 <vikaton> https://www.irccloud.com/pastebin/UCU3dAQ5/
14:53:43 <vikaton> dmwit: ^
14:53:57 <vikaton> v confused between the pattern and condition
14:54:05 <lamefun> "You can do exactly that" + "but it won't be a very safe thing to do" = ...
14:54:23 <pharaun> lamefun: how so?
14:54:47 <Imagine> also what about let vs where?
14:54:51 <Imagine> which is usually preferred?
14:54:59 <pharaun> depends, i usually mix it up
14:55:12 <maerwald> Imagine: first of all: they are not the same thing
14:55:16 <pharaun> also ^
14:55:18 <lamefun> pharaun, I mean, what's the point of Safe Haskell then if it can't actually be used in a safe way?
14:55:20 <Imagine> well
14:55:24 <maerwald> see https://wiki.haskell.org/Let_vs._Where
14:55:25 <ReinH> lamefun: = the reality of the situation.
14:55:30 <dmwit> vikaton: "case () of _" is one idiom for getting a multi-way if. Using the MultiWayIf extension is another.
14:55:30 <Imagine> yeah they aren't in their scope
14:55:46 <ttt_fff> you know when haskell really f*cking s*cks? when I want pointers ... . so I can point at things, and say .... I'm going to update your value .... 
14:55:50 <Imagine> but like in cases where both are acceptable?
14:55:52 <ReinH> V8's sandbox has been shown to be unsafe before.
14:55:55 <roboguy_> ttt_fff: you can have them
14:56:00 <ttt_fff> instead, I have to lazily build a new data structure with the new values, making it harder to track "changes"
14:56:00 <dmwit> > let x = 35 in case () of _ | x `mod` 3 == 0 -> "Fizz" | x `mod` 5 == 0 -> "Buzz" | otherwise -> "I'm lazy"
14:56:00 <Cale> Imagine: They're not exactly equivalent. 'where' is part of the syntax of declarations (as well as case expressions) and scopes over multiple guards.
14:56:02 <lambdabot>  "Buzz"
14:56:03 <ttt_fff> roboguy_: oh, how ?
14:56:10 <pharaun> lamefun: its asserting a certain set of things, but there are always ways around various limits like infinite loop
14:56:12 <maerwald> Imagine: I personally prefer "where" more when it doesn't make a lot of difference, because it looks more "modular" to me, I don't know
14:56:13 <Cale> Imagine: Whereas let is an expression form.
14:56:18 <pharaun> safe haskell does not prove that you can't do infinite loop
14:56:22 <maerwald> it's just subjective
14:56:23 <dmwit> vikaton: See my example code (and lambdabot's response) above.
14:56:28 <pharaun> or explode the memory, or explode the type engine, etc
14:56:29 <roboguy_> ttt_fff: STRef and IORef
14:56:39 <roboguy_> among others
14:56:42 <Cale> If both are an option, then it comes down to which order it makes the most sense to read the code in.
14:56:46 <ttt_fff> IORef is not what I want.
14:56:50 <ttt_fff> STRef I need to look at.
14:56:52 <maerwald> Cale: good point
14:57:00 <Imagine> alright awesome, thanks
14:57:11 <dmwit> ttt_fff: Why is IORef not what you want?
14:57:14 <ReinH> Cale: (You are still op'd btw)
14:57:21 <ttt_fff> IO scares me
14:57:23 --- mode: Cale set -oo Cale glguy
14:57:43 <dmwit> bah
14:57:46 <pharaun> heh
14:57:47 <Cale> ttt_fff: Don't be as scared?
14:57:56 <ion> > let f s m n=s<$guard(n`mod`m==0)in fromMaybe<$>show<*>f"fizz"3<>f"buzz"5<>f"bang"7<$>[1..]
14:57:57 <lambdabot>  ["1","2","fizz","4","buzz","fizz","bang","8","fizz","buzz","11","fizz","13",...
14:57:59 <Cale> ttt_fff: If you want pointers, pointers are way scarier than IORefs
14:58:14 <Cale> ttt_fff: and you can have pointers if you want in IO as well
14:58:15 <ttt_fff> so I have this recurisv edata structure
14:58:26 <ttt_fff> and I want to be able to point to part of the value and say "I want to change that particular part"
14:58:33 <ttt_fff> I can sorta o this with zippers, but then I only hae one 'pointer'
14:58:49 <Cale> This is also sort of the problem which lenses aim to solve.
14:58:51 <ion> Sounds like the use case for lens.
14:59:11 <Cale> If you want to do so without mutation.
14:59:19 <ttt_fff> aren't lens "static" i.e. the location are determiend at compile time?
14:59:24 <Cale> hm?
14:59:28 <lamefun> pharaun, JavaScript can't detect infinite loops either, but infinite loop can waste CPU but can't delete your files.
14:59:31 <ttt_fff> with zippers, you can dpick the location at runtime
14:59:43 <Cale> ttt_fff: They're as static as any other sort of value.
14:59:53 <pharaun> lamefun: exact same thing as safehaskell :P
14:59:54 <Cale> Like, the integer 5 only refers to one particular number
14:59:55 <roboguy_> ttt_fff: they don't need to be determined at compile time
15:00:16 <ttt_fff> suppose I have a list, with 2n+1, elements, and I want to point to the nth element
15:00:23 <pharaun> lamefun: also javascript has had been exploited before, many times as well
15:00:24 <roboguy_> > [1,2,3] ^? ix 1  -- <- dynamic lens (well, prism)
15:00:28 <lambdabot>  Just 2
15:00:28 <ttt_fff> with zipers, I can do this, with lens, I feel like I have to commit to a 'n' to an actual number at compile time
15:00:40 <ttt_fff> this may be because I just don't understand lens
15:00:48 <quchen> > [max(show x)$[n|(f,n)<-[(3,"Fizz"),(5,"Buzz"),(7,"Bang")],mod x f<1]>>=id|x<-[1..100]] -- ion
15:00:49 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","Bang","8","Fizz","Buzz","11","Fizz","13",...
15:01:16 <ion> quchen: nice
15:01:21 <edwardk> http://hackage.haskell.org/package/zippers builds zippers on top of lenses =P
15:01:23 <lamefun> pharaun, "lamefun: exact same thing as safehaskell :P" - but people here have been telling me that it's not... I'm really confused now.
15:01:26 <ttt_fff> roboguy_ : I think you read my mind
15:01:32 <definity> http://pastie.org/10239242 <- is this right?
15:01:40 <definity> well my explanation right.
15:01:47 <pharaun> lamefun: i'm saying safehaskell can't prevent infinite loops, etc just like v8 can't
15:02:24 <Cale> definity: _ is a pattern which always matches, without binding a variable. The effect of that pattern is similar to if you'd written (x:y:xs), except that the variable xs isn't bound.
15:02:29 <ReinH> lamefun: No one has said that.
15:03:14 <edwardk> pharaun: safe haskell only checks that you don't get the ability to segfault and that you have reasonable semantics for the code, it doesn't check for resource consumption, formatting your harddrive, etc.
15:03:18 <Cale> definity: If you were to write the pattern (x:y:b:b1:b2:b3:b4:xs), this would only match lists of length at least 7
15:03:22 <ReinH> Since saying so implies that you have solved the halting problem.
15:03:44 <ReinH> edwardk: yes, I've been saying this for hours now.
15:03:51 <pharaun> edwardk: yah, i just am not deeply familiar, i'm just trying to instruct lamefun that needs *TO* use multi-layered system
15:03:52 <ion> definity: You only create type classes with the class keyword.
15:03:54 <Cale> definity: While (x:y:_) will match a list of length 2 (except those have already been matched by the preceding pattern) or length 3, for example.
15:03:58 <ReinH> What we have here is a failure to communicate.
15:03:58 <pharaun> and not just relay on safehaskell alone
15:04:15 <maerwald> edwardk: haha, how can I check if haskell code reformats my hard drive? :P
15:04:19 <ion> definity: _ is a pattern that matches any list, its length can anything from zero to infinity.
15:04:27 <edwardk> maerwald: by running it? =)
15:04:32 <maerwald> edwardk: nice xD
15:05:03 <pharaun> also lamefun if you let your user feed you whole files they can always use - '{-# LANGUAGE Safe #-}' - to claim that their code is 'safe'
15:05:10 <ReinH> edwardk: sleep 2^100 >> formatHardDrive :p
15:05:11 <maerwald> it would be cool if the IO type would be more fine-grained to reflect what KIND of IO actually happens
15:05:14 <quchen> Well, SafeHaskell guarantees you that non-IO values don't format your drive.
15:05:18 <edwardk> {-# LANGUAGE Trustworthy #-} is the culprit, not Safe
15:05:31 <edwardk> but you can specify the trusted computing base with safe haskell
15:05:33 <pharaun> oh my bad
15:05:38 <Imagine> is there a groupBy that doesn't go through a list in order? (aka suppose I have a function that returns one of three values. Is there a function that goes through a list and groups the inputs by their output?)
15:05:47 <edwardk> and Trustworthy modules outside of that just don't get trusted
15:05:54 <arianvp> Does anybody know how to let XMonad use your own cabal project instead of ~/.xmonad/xmonad.hs?
15:05:55 <pharaun> edwardk: ahh nice
15:05:57 <Cale> lamefun: I feel like you'd get a lot more constructive criticism and useful information if you were coming to us with some specific project in mind, rather than asking vague questions about what may be possible.
15:06:14 <pharaun> edwardk: this -fpackage-trust ?
15:06:22 <lamefun> Cale, maybe because Haskell doesn't have reasonable sandboxing at all?
15:06:23 <Cale> lamefun: Better yet if you had some initial code for us to look at.
15:06:26 <edwardk> pharaun: i know the capability exists, not the specific mechanism
15:06:31 <pharaun> k
15:06:46 <pharaun> lamefun: no
15:06:57 <pharaun> lamefun: you need to specify your problem domain, have some example, etc and we can assist
15:06:59 <ReinH> I can claim that unsafePerformIO reformatHD is safe :p
15:07:03 <Cale> lamefun: Haskell is just a programming language, it isn't a virtual machine.
15:07:04 <edwardk> lamefun: and yet lambdabot is here actively letting people run haskell code on 40 different channels 24 hours a day for the last ten years with no ill effects.
15:07:09 <pharaun> just claiming "reasonable sandboxing" is already too vague
15:07:23 <edwardk> lamefun: safehaskell is one component in the 'defense in depth' necessary to build such a sandbox
15:07:38 <lamefun> I have already!
15:07:38 <ReinH> lamefun: again, security is not a binary.
15:07:41 <pharaun> what is considered reasonable depends on your problem domain, as always, defense in depth
15:07:47 <Cale> To be fair, lambdabot isn't exactly all that safe, it's just that all the people who are clever enough to exploit it also tend to be nice enough not to.
15:07:49 <pharaun> do this, then that, then that, etc..
15:08:15 <pharaun> Cale: type-exploits ?
15:08:28 <Cale> Also lambdabot tends to get hosted on virtual hosts whose contents are unimportant.
15:08:35 <edwardk> cale: true, but its been remarkably safe for a long period of time. even knowing the exploits that have been found and patched around over time
15:08:38 <definity> I dont understand what (Show a) does.
15:09:06 <ReinH> Show a says that a must be a member of the Show type class
15:09:19 <ReinH> In Show a => ofc
15:09:53 <ion> definity: It constrains the choice for the type ‚Äúa‚Äù picked by the invoker to be an instance of Show. 
15:11:43 <lamefun> "you need to specify your problem domain, have some example, etc and we can assist" - the problem domain is incredibly obvious.
15:11:54 <lamefun> There's a program Main.hs that wants to compile and load untrusted Script.hs and interact with it in a way where code in Script.hs can only use the IO facilities explicitly provided for it by Main.hs.
15:11:59 <Cale> lamefun: No it's not. I have no idea what sort of program you're trying to write.
15:12:38 <Cale> lamefun: Are you writing a text editor with user script plugins? Are you writing a web application to run user code? These are two very different domains.
15:12:41 <pharaun> where is script.hs coming from, who is writing it, is it on their own machine or is it hosted on a random vm, or is it hosted inside a bank with access of various stuff, etc
15:12:54 <pharaun> there's a wide range of security requirements
15:14:10 <lamefun> "where is script.hs coming from, who is writing it" - no idea, that's why it's untrusted.
15:14:23 <ReinH> repeat after me: security is a business decision.
15:14:26 <lamefun> "is it on their own machine or is it hosted on a random vm" - does it matter?
15:14:32 <Cale> lamefun: yes
15:14:34 <pharaun> lamefun: yes it does matter
15:15:05 <ReinH> It's *always* relative to your environment and requirements.
15:15:11 <pharaun> if the user is writing it for use on their own machine you can be a bit looser for ex, vs internet user on a vm, vs a bank user in a bank, etc
15:16:15 <edwardk> lamefun: for that i'd use something like 'hint' to load and run the module, and put a timer on it if i want to kill it after some resource exhaustion limit time wise -- and i'd be done.
15:17:24 <edwardk> or whatever the other interpreter binding was that i forget
15:18:15 <edwardk> in practice i'd be paranoid and shove it inside of a vm anyways, but then i'm untrusting
15:18:21 <ReinH> If no one actually runs the code, every system is secure. Any additional requirements eliminate some points in the solution space.
15:18:53 <Ste1981> Hi.  I'm trying to install the gtk3 package with Cabal but get "The program pkg-config version >=0.9.0 is required but cannot be found...Failed to install glib-0.13.1.0."  I've already updated cabal-install to the latest version.  Does anyone know how I could fix this?
15:19:00 <ReinH> edwardk: (Docker container is pretty reasonable here)
15:19:20 <Cale> Ste1981: Install a newer pkg-config on your system?
15:19:27 <edwardk> ReinH: fair. i'm still only barely getting started on using docker in any meaningful capacity
15:19:47 <edwardk> Ste1981: 'brew install pkgconfig'
15:19:49 <ReinH> Just fyi
15:20:07 <Cale> Ste1981: If you run  pkg-config --version  on the commandline, what does it tell you?
15:20:11 <edwardk> on a mac solved that for us here the other day when dealing with a similar issue involving getting sdl2 installed
15:20:31 <Cale> Ste1981: If it doesn't exist, your problem is that pkg-config (which has nothing to do with Haskell specifically) isn't installed
15:20:41 <lamefun> "if the user is writing it for use on their own machine you can be a bit looser" - "it" = Main.hs or Script.hs?
15:20:49 <pharaun> script.hs 
15:21:26 <lamefun> "a bit looser"? why bother at all if you're writing the script yourself?
15:21:38 <pharaun> lamefun: *EXACTLY*
15:21:48 <pharaun> hence wanting to know what your usecase is
15:22:19 * ReinH creates a lamefun bot to argue with lamefun
15:23:22 <lamefun> pharaun, "untrusted"...
15:23:33 <pharaun> i don't trust myself (:
15:23:38 <Ste1981> Cale: Yeah, it doesn't exist here.  I'm using Windows so get a "pkg-config is not recognised as a...[anything]" error.
15:23:55 <pharaun> lamefun: *who* is the untrusted user then
15:23:59 <pharaun> lamefun: and what is the context
15:24:11 <pharaun> it would have cut this 20 questions down lots if you would just answer this question.
15:24:14 <pharaun> *these
15:24:52 <lamefun> "*who* is the untrusted user then" - the writer of script.hs?
15:24:52 <Imagine> is there something similar to groupBy that doesn't go through a list in order? (aka suppose I have a function that returns one of three values. Is there a function that goes through a list and groups the inputs by their output?)
15:25:05 <pharaun> lamefun: no
15:25:09 <Cale> lamefun: People would be able to give you much more directed information if you told us exactly what program you were writing
15:25:13 <pharaun> ^
15:25:16 <Cale> @protontorpedo
15:25:16 <lambdabot> is haskell more powerful than any jedii?
15:25:17 <Imagine> or is that something I'd have to write on my own?
15:25:34 <pharaun> lamefun: please stop being evasive, *who* again is the writer of script.hs ?
15:26:21 <mzero> Imagine: do just want to know what values are present?   nub
15:26:35 <Imagine> Uh not quite - 
15:26:40 <Imagine> I have a list of vectors
15:26:42 <mzero> or do you want to have counts, or groupings?  In which case I'd built a Data.Map from it
15:26:43 <lamefun> pharaun, what? It's you who're bring evasive.
15:26:49 <Imagine> groupings
15:26:59 <Imagine> I want to group them based on what "reference vector" they're closest to
15:27:12 <lamefun> pharaun, "untrusted Script.hs" --> naturally implies --> "potentially malicious programmer".
15:27:36 <mzero>     Map.fromListWith (++) . map (\v -> (byFunction v, [v]))
15:27:53 <lamefun> or careless.
15:28:41 <mzero> where byFunction maps your vectors to whatever unique defines whcih group they are in
15:29:05 <Imagine> Map.fromListWith might do it, I need to look at the docs for that
15:29:08 <Imagine> but thank you
15:29:21 <Cale> lamefun: But there's a big difference between what a potentially malicious programmer who gets access to e.g. an otherwise empty linode account can do, vs. a potentially malicious programmer who gets access to an important machine at a financial institution.
15:29:27 <tejing> lamefun: security isn't really a computer science problem. it involves computer science, but it's a human problem. the big questions are "how much is a stake?" and "how hard will other people be willing to work to get around it?"
15:29:36 <mzero> note carefully the  [v] in the pair - this allows you to "group up" the values
15:29:51 <Imagine> mzero - I think that should do it
15:29:51 <Imagine> thanks
15:30:08 <mzero> :-)
15:30:31 <pharaun> exactly what Cale is saying
15:30:43 <Imagine> wait actually - I'm not sure whether a map is the best data structure (I may be wrong
15:30:44 <Imagine> )
15:30:47 <pharaun> i am not being evasive i am being direct here because i know security is in shades of grey, not black and white
15:30:56 <Imagine> I'm trying to implement k-means
15:31:05 <mzero> Imagine - you can    Map.toList . Map.fromListWith (++)
15:31:09 <merijn> pharaun: It's in shades of black, because it's all doomed :p
15:31:14 <mzero> and get a list of 2-tuples if you want
15:31:15 <pharaun> merijn: true!
15:31:17 <lamefun> "how much is a stake?" - security of user's computer? (but that's for now, OS developers have recently thought true and are implementing application isolation, like GNOME 3 sandboxed bundles or Ubuntu Snappy).
15:31:27 <Imagine> ah okay perfect thank you
15:31:43 <lamefun> or at least, user account.
15:32:09 <roboguy_> lamefun: I'm still wondering what the overall goal is. You need both strong security guarantees and the full power of Haskell in your scripting system?
15:32:10 <Cale> lamefun: Basically, under almost any circumstances where potentially malicious users would be in play, I would always recommend sticking the entire piece of software into a VM where it had limited resources and access to the host machine. Do that, and whatever additional solutions you come up with inside Haskell can basically be aimed at helping the programmer not shoot *themselves* in the foot.
15:32:33 <lamefun> but rm -rf ~/* is still very bad.
15:32:39 <Cale> lamefun: Also, this isn't specific to Haskell.
15:33:00 <Cale> lamefun: Haskell is *just* a programming language. It is not a virtual machine service.
15:33:05 <pharaun> even just sticking it inside a VM isn't 100% the answer because of the fact that you can have vm exploits, kernel exploits, etc which can be triggered by your code.
15:33:11 <pharaun> in the script.hs file.
15:33:30 <Cale> Absolutely, but putting it in a VM should be a component of almost any solution to the problem at hand.
15:33:32 <lamefun> "You need both strong security guarantees and the full power of Haskell in your scripting system?" - some reasonable subset of that power (so that it can actually be used).
15:33:38 <pharaun> Cale: agreed.
15:33:54 <pharaun> Cale: i'm not saying don't VM, i'm just saying that its not 100% the answer :(
15:33:59 <Cale> Right
15:34:07 <roboguy_> lamefun: I guess the question is what sort of tradeoff between the two you want (how strong of a security guarantee vs how much power?)
15:34:08 <lamefun> "virtual machine service" - this doesn't matter.
15:34:26 <Cale> lamefun: Yes it does.
15:34:44 <shachaf> > M.fromListWith (<>) . map (\v -> ('a',v)) $ [N 1, N 2, N 3]
15:34:45 <lambdabot>  fromList [('a',N 3 ‚óá (N 2 ‚óá N 1))]
15:35:10 <shachaf> OK, it comes out right-associated.
15:35:29 <Cale> lamefun: anyway, if you think you're fine without a VM, go right ahead, I don't care :)
15:35:41 <Cale> lamefun: But don't say we didn't warn you :)
15:35:44 <definity> So when i write 'myFunc :: (Num a) -> [a] -> a' does the '(Num a)' represent the class 'Num' and make an instance of it 'a' so it could represent any type varible IE Integer, Int, Float, Double?
15:36:12 <definity> Well I dont mean instance but use the Num class
15:36:17 <Cale> lamefun: Depending on who your users are, it might be fine anyway.
15:36:20 <roboguy_> definity: No. It says that the type 'a' must be an instance of Num. You can give myFunc anything that has a type that is an instance of Num
15:36:21 <lamefun> Secure scripting can even be done by compiling script into C code, compiling C code into ".so" and then dlopening the ".so", if the resulting C code does bounds checking everywhere, etc.
15:36:41 <roboguy_> definity: Also, that syntax isn't quite right. It should be 'myFunc :: (Num a) => [a] -> a'
15:36:50 <tejing> lamefun: assuming your compiler is bugless
15:37:00 <Cale> lamefun: Sounds very safe, lol.
15:37:07 <lamefun> So all VMs are bugless?
15:37:12 <pharaun> no
15:37:18 <pharaun> jvm sure as heck isn't
15:37:18 <merijn> tejing: Even with a bugless compiler...
15:37:20 <pharaun> v8 sure isn't
15:37:43 <roboguy_> lamefun: they didn't say that, did they?
15:38:16 <tejing> lamefun: humans are fallible, therefore all code potentially has bugs, and all proofs that code is bugless potentially contain errors. you can never be assured of the security if a system (even discounting methods of getting around the computers themselves)
15:39:19 <tejing> lamefun: so the real question becomes "how certain do you want to be?"
15:39:43 <lamefun> again, it's not my complaint that Safe Haskell isn't prefectly secure...
15:40:00 <Cale> Anyway, Safe Haskell is not aimed at making potentially malicious arbitrary Haskell code entirely safe to execute on its own. It's a viable component of such a system.
15:40:29 <shachaf> Really?
15:40:32 <Cale> But it does very particular things which can be useful in making code safe*r* to compile and execute.
15:40:36 <shachaf> I thought that's exactly what it's aimed at.
15:41:01 <tejing> lamefun: giving the human context (what sort of damage a malicious user who found an exploit could do in human terms) gives a fairly accurate quantification of how sure you want to be
15:41:32 <ReinH> You can't argue that it both is and isn't secure at the same time. Well, obviously you can, but it's incoherent.
15:41:35 <Cale> You shouldn't take "I compiled this with Safe Haskell turned on" as being equivalent to "I can run this on my machine and nothing terrible is going to happen"
15:41:45 * int-e sees SafeHaskell as a valuable component to lambdabot's defense against malicious users; it stops them from exploring just how much harm they can do with unsafePerformIO. But it doesn't ensure that there aren't any more subtle ways to get full access to IO or arbitrary code execution.
15:42:13 <shachaf> int-e: Well, except for how you can write unsafePerformIO in lambdabot.
15:42:30 <shachaf> Or maybe all the ways we knew about have been fixed.
15:42:44 <ReinH> lamefun: Then what exactly *is* your complaint?
15:42:48 <roboguy_> lamefun: I've lost track of the discussion then... What's the question?
15:42:55 <int-e> shachaf: That just means that those subtle ways aren't just theoretical ;)
15:43:04 <ReinH> Because at this point we're just running around in circles
15:43:15 <Cale> @protontorpedo
15:43:15 <lambdabot> no I cant read online for long my eyes get fuzzy
15:44:10 <srhb> Did we not all agree that lamefun is just trolling? They have like seven days of negatively (not critically) phrased Haskell questions and nothing that convinces one that we're dealing with an earnest learner. :) 
15:44:23 <Cale> lamefun: Write some code, propose a specific system for a specific purpose, then ask people if it's secure enough.
15:44:25 <int-e> shachaf: but I thought the ones we knew about are all fixed in ghc 7.10.1. I'm not sure though.
15:44:33 <lamefun> ReinH, when using V8 you're 100% delegating untrusted code execution to the experienced V8 programmers...
15:44:38 <Cale> lamefun: We'll be happy to have a look and try to poke holes in it at that point.
15:45:00 <ReinH> Ok.
15:45:16 <lamefun> ReinH, as in, v8::Context is completely locked down by default, it can't even do any IO.
15:45:29 <ReinH> Ok.
15:45:38 <Cale> lamefun: Not having written any code and asking vague questions regarding security in unknown contexts for an unknown purpose is not going to result in a productive useful discussion.
15:45:53 <roboguy_> lamefun: So the gist of the current discussion here is that you're saying that the writers of either Safe Haskell checks or hint or something like that aren't experienced? Or am I misunderstanding
15:47:22 <ReinH> Do you understand that I don't need IO to write an endless loop that uses CPU and consumes memory?
15:48:14 <lamefun> ReinH, I do, but that's very minor problem compared to the possibility of `rm -rf ~/*`.
15:48:24 <ReinH> Why?
15:49:14 <Cale> lamefun: It might result in the kernel memkilling other processes.
15:49:15 <felixn> just put a watchdog on the processes to kill it/limit it if it consumes too many resources, very normal thing to do
15:49:18 <ReinH> Specifically, why should I care about rm -rf ~/*? I can easily make that harmless.
15:49:36 <ReinH> I can't make consuming infinite memory harmless
15:49:37 <apo__> ReinH: with backups?
15:49:38 <apo__> :D
15:50:12 <ReinH> Or at least, the same mechanism can make both harmless (vms)
15:50:13 <Cale> ReinH: Well, you can isolate and limit the memory usage as well...
15:50:15 <pharaun> vm
15:50:17 <Cale> yeah
15:50:21 <pharaun> vm is the answer to the rm-rf issue
15:50:35 <pharaun> and if the vm die, reinit and create a new one and reload the code on it, and boom.
15:50:48 <pharaun> hell it may even be a good idea to refresh it every so often
15:51:04 <ReinH> So so far you've only showed that V8 contexts are also not suffcent.
15:51:19 <felixn> lamefun: v8 does have great sandboxing, GHC could definitely use your help to make it better ;) ;)  if you're building a business application, definitely isolate with a VM to be absolutely sure
15:51:41 <Cale> lamefun as far as I can tell isn't building anything though
15:52:08 <srhb> I wonder what the troll-to-response ratio of lamefun is
15:52:14 <Cale> He's just asking questions in an impolite way to try to get people to respond despite the fact that he doesn't need the answer as far as I can tell.
15:52:14 <ReinH> I mean, we've already acknowledged that SafeHaskell isn't sufficient. Literally dozens of times. What else do you want?
15:52:17 <srhb> I think it's like 40-1 so far.
15:52:23 <srhb> Haskellers spam so much...
15:53:01 <tejing> srhb: which is ironic considering haskell code is so concise
15:53:08 <srhb> tejing: Agreed.
15:53:27 <int-e> srhb: well, the general topic is important and interesting. besides there's the famous stereo effect...
15:53:30 <int-e> @quote fugue
15:53:30 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
15:53:33 <srhb> I guess it's just really tempting, but people don't realize how annoying they are when they spew innane responses in the main channel.
15:53:34 <felixn> I feel like he's not wrong, v8 > ghc + python + ruby in terms of sandboxing, most people just don't care to solve the problem
15:53:40 <int-e> (I believe only this meta-quote survived)
15:53:50 <ReinH> You seem to be under the impression that V8 magically solves this problem, but it isn't our job to disabuse you of this notion.
15:54:17 <srhb> I'm sure this topic could easily be taken to another channel, especially considering that this is like the sixth day of idiotic spam on #haskell caused by this person and their non-questions.
15:54:20 <felixn> obviously v8 needed to build a very secure VM, because it's assumed visiting a site shouldn't delete your hard drive
15:54:26 <Cale> felixn: Yeah, but V8 is also *trying* to be a virtual machine
15:54:50 <int-e> Well, if the risk is high enough, writing a new Haskell compiler and runtime environment for safe code execution may be a sound business decision.
15:54:52 <felixn> Cale: yea exactly, if haskell was in the browser, forces would drive for better sandboxing in GHC
15:55:02 <lamefun> "Yeah, but V8 is also *trying* to be a virtual machine" - only because JavaScript is so dynamic that it can't be done otherwise.
15:55:15 <pharaun> srhb: this is the first day i've ran into this person :( sorry
15:55:26 <felixn> lamefun: GHCi is interpreted, not really about dynamic/static .. also what about NaCL? :p
15:55:28 <Cale> lamefun: Not only for that reason, but because users are going to download and execute unknown Javascript code.
15:55:35 <srhb> pharaun: Then it's not your fault at all. :) Don't be sorry.
15:55:55 <Cale> lamefun: and they need some guarantee of safety, so they need e.g. filesystem and memory isolation
15:56:22 <Cale> lamefun: GHC doesn't attempt to do any of that on its own. It leaves that to separate virtual machine solutions.
15:56:28 <roboguy_> srhb: ah, I didn't see that either
15:56:30 <lamefun> Cale, it is for that reason. If it was static enough it could've been compiled to C code and then compiled and then dlopened just as securely. VM is only needed because it doesn't have static data structures or types.
15:57:21 <ReinH> Wat
15:57:28 <arkeet> wat
15:57:33 <felixn> wat
15:57:44 <Cale> lamefun: I think we're just about done with this conversation.
15:58:04 <Cale> lamefun: Either start writing code to talk about, or I'm going to ban you.
15:58:13 <lamefun> felixn, Unvanquished game uses PNaCl to isolate mods, I've asked one of its developers and he said that PNaCl has no public API to speak of, you have to figure it out by yourself.
15:59:04 <ReinH> Is this just random word association time?
16:08:10 <lamefun> "saying that the writers of either Safe Haskell checks or hint or something like that aren't experienced" - https://hackage.haskell.org/package/mueval - it says that it uses hint and protects against "evil" code, which implies that hint itself does not have security as its goal.
16:08:14 <lamefun> "Mueval is POSIX-only." - can't use it then.
16:09:06 <Cale> That's correct, hint is just a thin wrapper around the GHC API to do runtime interpretation or dynamic loading of compiled Haskell modules.
16:10:03 <ReinH> are we done with this yet?
16:10:05 <definity> Whats with the (x:xs) pattern? Are 'x' and 'xs' just varible names?
16:10:09 <Cale> It mostly just takes care of the hassle of initialising and passing around various configuration data structures which GHC needs to operate
16:10:13 <pharaun> definity: yes
16:10:21 <definity> pharaun: Thanks :)
16:10:26 <pharaun> definity: deconstructing a list (x <- head, xs <- rest of list)
16:10:28 <Cale> definity: The convention is that xs is plural :)
16:11:06 <Cale> (i.e. you should pronounce it like "eksses")
16:11:22 <roboguy_> Cale: it took me so long before I realized that in the beginning, haha
16:11:34 <jle`> > let (x:xs) = [1,2,3] in (x, xs)
16:11:35 <saiam> Q
16:11:36 <lambdabot>  (1,[2,3])
16:11:44 <jle`> > let (foo:bar) = [1,2,3] in (foo, bar)
16:11:45 <lambdabot>  (1,[2,3])
16:12:02 <jle`> people might be a little confused if you used (foo:bar) though, heh
16:12:15 <definity> Cale: Ahh I see, thanks :)
16:12:40 <Cale> definity: Sometimes if you have a list of lists, people will even use xss :)
16:12:42 <pharaun> no need to use x:xs you can use like y:ys etc...
16:12:59 <pharaun> but the most common form is x:xs *shrugs* so use that unless you ahve a reason otherwise
16:14:04 <tejing> pharaun: I often use a:as and b:bs... the beginning of the alphabet just feels more comfortable to me when considering 1-letter var names
16:14:14 <tejing> no idea why
16:14:14 <Cale> Yeah, it's just a name, it's just that often variables in Haskell are so polymorphic that you can't really give them a better name than 'x', and the scopes are tiny, so it doesn't matter (your binding site is always within view of all the usage sites, so it's okay for the name to be short)
16:14:23 <lamefun> I've done a quick search in hint API but haven't found anything that relates to forcing Safe Haskell on loaded code...
16:14:56 <Cale> tejing: Bad syntax highlighters will highlight 'as' because it's also a keyword in the right contexts.
16:15:26 <tejing> Cale: heh, oops
16:15:27 <jle`> yeah, i try to avoid a, b, c for value variables and keep them for type variables
16:15:31 <Cale> lamefun: It's an extension
16:16:30 <definity> Cale: Looks like cross site scripting
16:16:49 <definity> TBH I thought the s meant second
16:17:05 <merijn> definity: It's plural
16:17:22 <merijn> definity: One tree, multiple treeS, one boat, multiple boatS, one x, multiple xS
16:17:37 <Cale> > let ((x:xs):xss) = [[1,2,3],[4,5,6],[7,8,9]] in (x, xs, xss)
16:17:39 <lambdabot>  (1,[2,3],[[4,5,6],[7,8,9]])
16:17:45 <definity> merijn: Yeah I get it :)
16:17:53 <merijn> oh, someone already said that :p
16:18:41 <Cale> > let xxs@(x:xs) = [1,2,3] in (xxs,x,xs)
16:18:43 <lambdabot>  ([1,2,3],1,[2,3])
16:20:42 <definity> Is Haskell a fast language?
16:20:48 <pharaun> tejing: interesting, that works (i just saw lots of x:xs and i got used to doing that)
16:20:52 <pharaun> definity: can be
16:21:08 <pharaun> there are things that can be done slower than say C but iirc sometime some bits can be as fast/maybe bit faster than c
16:21:26 <definity> Cool :)
16:21:36 <tejing> definity: it can sometimes be less obvious what will be fast and what will be slow
16:21:38 <bitemyapp> @unpl zipWith (+) . map f
16:21:38 <lambdabot> (\ c -> zipWith (+) (map f c))
16:21:46 <pharaun> so if it matters, profile!
16:21:55 <bitemyapp> @unpl foldr . zipWith (+) . map f
16:21:55 <lambdabot> (\ c -> foldr (zipWith (+) (map f c)))
16:21:56 <tejing> definity: you have to get a feel for lazy evaluation to start to see it
16:22:01 <bitemyapp> well that was senseless.
16:22:22 <bitemyapp> @unpl zipWith (+) . (join .) . map
16:22:22 <lambdabot> (\ d -> zipWith (+) (\ l -> (map d l) >>= \ h -> h))
16:22:25 <bitemyapp> there we go.
16:22:31 <pavonia> Actually, Haskell is a language, so it can't be faster or slower than other languages
16:22:57 <definity> Yeah, I will get there I'm only on page 40 of my book so far, another 300 to go.
16:23:14 <Cale> pavonia: That's of course the correct answer to the question. :)
16:23:38 <bitemyapp> definity: what book?
16:23:56 <definity> "Learn you a Haskell for great good"
16:25:15 <Cale> Expert Haskell programmers might have a little worse of an idea of the performance behaviour of their code than expert C programmers, because the compiler does so much stuff, and lazy evaluation can require a bit of non-local analysis to really understand. But after a while you get pretty good at spotting things which are actually going to be a performance problem, it just takes about as much time as it would take gett
16:25:15 <Cale> ing good at doing the same for strict and/or imperative languages.
16:25:42 <Cale> Like with every other language, the most common solution is just to use more appropriate data structures.
16:25:45 <bitemyapp> Cale: very well put.
16:26:28 <kadoban> definity: You should do the course suggested in https://github.com/bitemyapp/learnhaskell instead, IMO.
16:28:32 <tejing> on the subject of appropriate data structures, I was thinking about solving exact cover problems the other day and I realized I had no idea what kind of functional data structure would work well for that
16:28:39 <tejing> I toyed with it for a while and gave up
16:30:33 <DNoved1> drop it like it's hot
16:30:48 <felixn> mm chh mm chh mmm chh
16:32:37 <tejing> in essence I need to represent a grid of Bools, be able to find all the Trues in a row or column easily, and be able to remove rows and columns easily (and backtrack those removals easily)
16:33:17 <felixn> does anyone have a good workflow with automated testing?  right now I just manually run the tests in my terminal, but I would like better integration with Atom.  I think I may need to write my own extension that runs them, and integrates the line errors.
16:34:53 <definity> kadoban: Thanks il check it out
16:35:22 <felixn> also, it would be cool if I changed a function, it would run only tests related statically related.  so I could have a really fast feedback loop‚Äîmy tests take like 10 seconds to run, not terrible, but milliseconds would be nicer!  right now I manually filter tests based on what I'm working on, but I wish I could automate that :)
16:36:39 <rhaps0dy> I'd help you if I could, felixn.
16:36:58 <felixn> rhaps0dy, do you use Atom?
16:37:06 <rhaps0dy> Does anyone know of a good abstraction model to build a networking protocol library upon, or do I use plain monadic chaining?
16:37:12 <rhaps0dy> felixn: no, never did, sorry.
16:37:26 <rhaps0dy> neither did I do any automated testing with Haskell :(
16:37:30 <rhaps0dy> not yet
16:37:30 <kadoban> felixn: I just have my VCS run my tests when I commit (git), but I don't really have an answer to the rest of that either ‚Ä¶
16:37:32 <felixn> rhaps0dy: http://haskell-distributed.github.io/ <-- I've checked this out, it looked amazing
16:37:55 <kadoban> I do have syntax and hlint checking in my editor though I guess.
16:38:03 <rhaps0dy> the cloud haskell platform
16:38:05 <rhaps0dy> hmmm
16:38:57 <felixn> the GHC integration into Atom make coding so much more fun with Haskell, it immediately tells me what I'm doing is wrong, and the linter tells me how to write my code better, all while I'm working
16:39:17 <rhaps0dy> yeeeah that's not what I mean, I mean it's ultra cool, but not what I asked for 
16:39:20 <rhaps0dy> thanks anyways :)
16:39:48 <kadoban> felixn: Yeah, that stuff is pretty cool. Never used atom, but I have similar stuff set up in mine.
16:39:56 <roboguy_> rhaps0dy: you mean something like pipes or conduit?
16:39:58 <felixn> rhaps0dy: oh, maybe you could help me understand better
16:39:59 <rhaps0dy> felixn: how does Atom's integration with Haskell stand vs Vim, Emacs and Yi?
16:40:08 <rhaps0dy> roboguy_: oh, maybe
16:40:16 <rhaps0dy> I mean
16:40:21 <rhaps0dy> kind of like FRP is a good way to think about GUI
16:40:30 <rhaps0dy> do we have a good way to build network libraries, or do we use monadic chaining?
16:40:32 <felixn> I've tried to setup Vim with cool haskell stuff, it was too hard, Atom seemed to work out of the box
16:40:39 <rhaps0dy> felixn: nice!
16:40:55 <rhaps0dy> I'lll check it out after pipes and conduit
16:40:57 <felixn> I LOVE the instant feedback, so now I want it with my tests too, so I instantly know if I'm doing garbage in, garbage out
16:40:59 <rhaps0dy> things that work out of the box are cool
16:42:00 <kadoban> felixn: The way I do it generally is just have a set of "quick tests" and a set of "in-depth" tests. I have the quick tests run often and the in-depth ones less often. Usually the quick is done pre-commit in git and the in-depth I do manually when I feel the need (it's usually pretty obvious when I need to).
16:42:38 <kadoban> It's not exactly elegant, but it works.
16:43:35 <felixn> kadoban: I think think maybe that's my problem, doctest is the slow one, yet they're used as the quick ones since they're in my face
16:44:15 <kadoban> Hmm, yeah doctests are neat, but they are relatively slow as far as I noticed.
16:48:45 <ttt_fff> (not trolling); anyone, after learning SQL + prolog, find Haskell a bit unsatisfying? i.e. the desire to (1) have a table of relations and (2) do relational stype programming instead of functional style?
16:49:04 <ttt_fff> I think this is the first time, after understanding monads, that I'm finding haskell unsatisfying
16:49:26 <Cale> ttt_fff: There are various monads and libraries you can use to approximate the behaviour you'd get in Prolog.
16:49:38 <ttt_fff> Cale: the backtracking is easy to get
16:49:46 <ttt_fff> however, the "relational" aspect I don't see how a monad can capture
16:50:11 <mjvc>  /join #nixos
16:50:16 <mjvc> lol woops
16:50:18 <ttt_fff> i.e. in prolog, I cna define "father(X, Y)" then I can do things like "father(John, _)" and "father(_, John)" i.e. apply functions 'forwards anad backwards" ... which I don't think a monad can capture
16:50:37 <ttt_fff> i.e. moands can cpature generate + filter + backtracking (through a glorified list monad), but the relational aspect, I don't see how monads help with this
16:52:48 <Cale> I believe there exist some libraries for doing constraint logic programming. I can't say that I've really put them to use before.
16:53:26 <jle`> ttt_fff: oh, about your question on #haskell-auto, there isn't at the moment, but the closest thing would probably be my machines tutorial series on my blog
16:54:39 <Cale> ttt_fff: i.e. libraries which let you create variables to be solved for, and use them to express and collect constraints on them, and then solve the system using some backtracking sort of approach like prolog would.
16:55:05 <ttt_fff> Cale: you can do this in Haskell as an library, and not as a language interpreted by an interpreter writen in haskell ?
16:55:15 <Cale> ttt_fff: What's the difference?
16:55:19 <pharaun> isn't this the same areana re SAT solvers or am i thinking of something entirely different?
16:55:28 <pharaun> cos iirc i've seen some haskell wrappers for those
16:55:51 <ttt_fff> Cale: if it's a library/extension, I can easily mix it with native haskell code; if it's an interpreter written in Haskell, then I have to "do all the work in the interpreter"
16:56:04 <Cale> Well then yeah, it's a library
16:56:20 <pharaun> https://github.com/jvranish/MiniKanrenT ?
16:56:23 <Cale> e.g. your constraints can involve arbitrary Haskell code
16:57:18 <maerwald> Cale: I wonder why liquidhaskell doesn't use those then, but an SAT binary
16:58:44 <Cale> maerwald: From what I understand, major SAT solvers involve a heck of a lot more work than just brute force backtracking, and typically implement a lot of heuristics.
16:59:02 <Cale> maerwald: Duplicating that work was probably not the goal of the LiquidHaskell researchers :)
16:59:04 <ttt_fff> yeah, it's all heurisitcs
16:59:12 <ttt_fff> burtce force is 2^n; so it's all about heuristics
17:00:12 <Cale> ttt_fff: To some extent, even the list monad gives you predicates like that
17:00:40 <Cale> ttt_fff: You can write guard (father John x) as well as guard (father x John)
17:00:59 <Cale> ttt_fff: and then you just have to have x <- people above that
17:01:05 <ttt_fff> Cale: not really, consider father(_, John) vs father(John, _) ... it seems like the filtering step needs to excute different code, depending on which call, whereas in Prolog, you just define the father relation once, and be done with it
17:01:27 <Cale> Nah, I'm saying you still only have to define the relation once.
17:01:29 <ttt_fff> Cale: okay, for this example I guess; but for more complicated ones where rules can call other rules, I don't think it works
17:01:35 <Cale> as a function Person -> Person -> Bool
17:01:41 <Cale> It works :)
17:01:59 <Cale> I've done a significant amount of stuff like that
17:03:08 <Cale> (My pipeline scheduler and register allocator for Altivec/PPC assembly used the list monad a whole lot... probably could have trivially swapped it out for logict and got a bunch more performance as well)
17:05:51 <Cale> ttt_fff: It's not *quite* as straightforward, as you have to explicitly set up every such "variable" you use, with the list of things it's going to range over, in the order you want them tried.
17:06:25 <Cale> ttt_fff: But conceptually, it does basically the same thing. There are some operators in the logict package for cut-like behaviour if you'd like that as well.
17:06:39 <Cale> (and negation, and stuff)
17:06:40 <ttt_fff> gradfather(X,Y) = exists z: father(X, Z), father(Z, Y) // things like this, I'm nto sure how this can be captured in standard ahskell functions
17:07:11 <ttt_fff> well, I guess if all what we're doing is generating a huge list, .... then running a filter on the list, we jut need a a -> bool
17:07:12 <ttt_fff> hmmm
17:07:22 <ttt_fff> I thought this before, and hit a bottleneck somewhere, let me get that counter example
17:07:57 <Cale> You can also use [()] in place of Bool sometimes, which can be handy for syntax
17:08:26 <Cale> Like, if we have father :: Person -> Person -> [()], and we have people :: [Person]
17:08:51 <Cale> then we can write  grandfather x y = do z <- people; father x z; father z y
17:09:16 <Cale> (Might want to stick a take 1 on there just for performance)
17:09:38 <Cale> (or 'once' using logict)
17:11:06 <Cale> The difference between this and what Prolog will give you is that Prolog will determine the list of people to iterate over based on the definition of father.
17:13:23 <Cale> So, you might instead choose to represent the father/grandfather relations as lists of pairs, which would make the code look a little different.
17:14:43 <Cale> grandfather = [(x,y) | (x,z) <- father, (z',y) <- father, z == z']  (where father :: [(Person, Person)])
17:15:10 <Cale> Maybe not quite as pretty, but not usually going to be absolutely terrible
17:15:41 <Cale> (feel free to use do-notation instead if it suits you better of course)
17:18:30 <Cale> And of course, lists of pairs aren't necessarily the best way to store such a relation -- you can do tricks with Map and Set to store things better
17:18:53 <Cale> There are lots of space/time tradeoffs you can make, depending on what you want to be indexed efficiently
17:18:54 <MarcelineVQ> I like how easy trees are to make in haskel
17:18:59 <MarcelineVQ> it's really cool
17:19:00 <Cale> Also, there's IxSet
17:19:11 <Cale> http://hackage.haskell.org/package/ixset
17:19:33 <Cale> MarcelineVQ: Yeah, it's life altering :D
17:19:51 <ttt_fff> Cale: I guess if all domains are finite sets, then any prolog relation can be imiplemente din haskell
17:19:56 <srhb> MarcelineVQ: Yeah. :) So many data types are so easy to "express." It's very nice.
17:20:07 <ttt_fff> where for each varaible, we have it run over all the values of the set, then run the filter
17:20:45 <ttt_fff> Cale: so yeah, you're right. How does ixset play into this?
17:20:49 <Cale> ttt_fff: Right. Once you get to numerical stuff, perhaps the questions get a little trickier, but then, they're sort of trickier in Prolog also.
17:21:10 <Cale> ttt_fff: IxSet gives you a way to store relations indexed on multiple keys
17:22:28 <ttt_fff> Cale: I think even before numbers, one can have infinite sets; i.e. unification on lists / trees
17:22:44 <Cale> Yes, that's true also.
17:23:07 <rhaps0dy> How can I find the definition of an infix function?
17:23:19 <rhaps0dy> I'm looking for -->, but a way to search those effectively would be better :)
17:23:31 <ttt_fff> (-->)
17:23:36 <ttt_fff> @hoogle (-->)
17:23:36 <roboguy_> rhaps0dy: https://www.fpcomplete.com/hoogle?q=--%3E&env=ghc-7.8-stable-14.09
17:23:37 <lambdabot> No results found
17:23:40 <rhaps0dy> no resuls found
17:23:56 <roboguy_> I guess lambdabot doesn't use fpcomplete's hoogle
17:24:05 <rhaps0dy> roboguy_: oh nice!
17:24:36 <Cale> ttt_fff: So once you want to do that, you need some way to diagonalise over infinite selections.
17:24:49 <Cale> ttt_fff: Logict gives you one way, there's also control-monad-omega.
17:25:00 <rhaps0dy> roboguy_: that doesn't look right though.
17:25:14 <ttt_fff> I only know of one def of diagonalize, and it happnes in Cantor's proof / proof of halting problem; not unification
17:25:15 <rhaps0dy> --> is in the netwire examples I find.
17:25:15 <roboguy_> rhaps0dy: What package is it coming from?
17:25:19 <rhaps0dy> Netwire.
17:25:34 <rhaps0dy> see, this is the one thing that irks me about haskell
17:25:43 <rhaps0dy> the goddamn infix functions
17:25:53 <rhaps0dy> you never know what they mean when reading someone else's code unless you go find the source
17:25:59 <rhaps0dy> and I can never find them :(
17:26:00 <geekosaur> use fpcomplete's hoogle, or hayoo
17:26:06 <rhaps0dy> p-please help
17:26:08 <rhaps0dy> hm, hayoo
17:26:29 <roboguy_> rhaps0dy: you could load it into ghci and type :i (-->)
17:26:38 <geekosaur> well, except hayoo is ma.functionin a bit at the moment :/
17:26:40 <rhaps0dy> that's right.
17:26:43 <geekosaur> *malfunctioning
17:26:48 <rhaps0dy> geekosaur: ooh, but it did find things
17:26:50 <rhaps0dy> but not in netwire
17:27:00 <geekosaur> yes, xmonad has a (-->) too
17:27:12 <rhaps0dy> and Auto
17:27:25 <geekosaur> only 5 from Auto. definitely buggy
17:27:30 <geekosaur> hope they're going to fix it soon
17:27:43 <roboguy_> rhaps0dy: oh, FPcomplete's hoogle doesn't have it but the other one does: https://www.haskell.org/hoogle/?hoogle=--%3E+%2Bnetwire
17:27:55 <roboguy_> You can use +package to add a package to the search
17:28:16 <Cale> ttt_fff: I just mean how to take a possibly infinite list of possibly infinite lists and flatten it out in such a way that every element in every list ends up in the result somewhere.
17:28:40 <rhaps0dy> roboguy_: oh nice, thanks!
17:28:50 <rhaps0dy> page not found, but nice to know
17:28:57 <ttt_fff> oh, like putting all the (x, y) where x&y are rational points of a 2d plane into a list; I see
17:29:03 <Cale> yep
17:29:10 <roboguy_> rhaps0dy: looks like they renamed Control.Wire.Trans.Switch to Control.Wire.Switch
17:29:24 <ttt_fff> i was thinking more of don't even expand most of them (since unification should only output data structures of a certain size, based on the complexity of the input)
17:29:34 <rhaps0dy> and one noob question... how do I run ghci inside a sandbox?
17:29:42 <rhaps0dy> I installed netwire to a sandbox, and I can't import it now :|
17:29:46 <rhaps0dy> sorry
17:29:51 <roboguy_> hmm did you try cabal repl?
17:29:57 <ttt_fff> i.e. a:b = 1:2:3:4:d would generate a = 1, b = 2:3:4:d, and unification is done
17:30:07 <ttt_fff> and we don't ahve to enumerate all possibilities of b/d
17:30:29 <rhaps0dy> roboguy_: thank you very much!
17:30:52 <rhaps0dy> wait a second
17:31:12 <Cale> ttt_fff: Yeah, if you want to get that subtle about things, you probably want one of these fancier libraries like cflp which I haven't really played with all that much
17:31:18 <Cale> http://hackage.haskell.org/package/cflp
17:31:48 <ttt_fff> Cale: I've always thought that the natural generation of pattern matching (which I love) is "unification over user defined datatypes"
17:31:56 <ttt_fff> s/generation/generalization/
17:32:00 <ttt_fff> and this is deeply linked ot prolog
17:32:09 <ttt_fff> anyway, i'll go oook at cflp
17:32:11 <ttt_fff> thanks for the discussion
17:32:32 <rhaps0dy> did netwire recently update, with breaking changes to API?
17:32:50 <rhaps0dy> rip.
17:32:52 <rhaps0dy> it did
17:32:57 <Cale> ttt_fff: http://www-ps.informatik.uni-kiel.de/~sebf/projects/cflp/examples/n-queens.lhs.html
17:33:01 <rhaps0dy> well, it'll probably be an easy transfer
17:35:08 <Cale> ttt_fff: It's obviously going to be a bunch hairier than a programming language like Curry which has that unification built in (especially at the type level), but it's possible to write analogous code.
17:35:42 <ttt_fff> OMG
17:35:44 <ttt_fff> I might just go use curry
17:36:00 <ttt_fff> wikpedia lists it as a functional logical langauge (which sounds vaguley like what I wnat) anad a near supserset of ahskell
17:36:14 <Cale> ttt_fff: There's also Mercury
17:36:16 <ttt_fff> ouch, lacks type classes
17:36:32 <Cale> There's no shortage of such languages if you're willing to use something which is research-grade :)
17:36:33 <indiagreen> how should a package's version be bumped when the only change is ‚Äúadded compatibility with older compiler‚Äù?
17:37:01 <Cale> indiagreen: I guess in the smallest part?
17:37:46 <indiagreen> Cale: thanks
17:38:35 <Cale> ttt_fff: Hey, it looks like Mercury has seen a bunch of development since I last looked at it even.
17:38:51 <rhaps0dy> good ngiht now and thanks for everything!
17:39:09 <ttt_fff> Cale: these, indeed, all look very intersting
17:42:27 <roboguy_> For some reason I was thinking that Mercury is dynamically typed... I wonder what language I'm thinking of
17:43:44 <ttt_fff> erlang, ruby, python, aseembly, java, scheme, clojure, clisp ?
17:44:59 <roboguy_> Well, I did remember that it was a functional logic language. Maybe Oz
17:45:08 <Forkk> assembly technically isn't dynamically typed
17:45:13 <Forkk> s/dynamically //
17:46:07 <Forkk> although maybe you could make a case for saying it is typed
17:49:43 <dolio> What about typed assembly language?
17:49:56 <dolio> And dependently typed assembly language.
17:50:48 <roboguy_> There's a dependently typed assembly language?
17:50:56 <dolio> There's at least one paper on it.
17:51:21 <dolio> I think more than one, though, probably with different approaches.
17:51:54 <roboguy_> huh, that's interesting
17:52:10 <ttt_fff> roboguy_: did you mean to say dependently typed rather than dynamically typed ?
17:52:18 <dolio> Only one was just called "Dependently Typed Assembly Language" though.
17:52:23 <roboguy_> ttt_fff: yeah
17:52:29 <ttt_fff> Idris
17:52:30 <ttt_fff> Coq
17:52:32 <ttt_fff> Agda
17:52:35 <roboguy_> oh
17:52:44 <roboguy_> I thought you meant about the assembly language
17:52:49 <roboguy_> no, I meant dynamically
17:53:02 <roboguy_> (also, those aren't really logic languages)
17:53:22 <lamefun> I tried using both hint and raw GHC API to load code from source, both work, but now my binary is 65 MB...
17:53:58 <geekosaur> well, yes, you now have the whole compiler embedded in it
17:55:37 <lamefun> :(
17:56:58 <lamefun> GHC is that big?
17:57:52 <geekosaur> actually it shouldn't be *quite* that big
17:58:10 <geekosaur> even given that it statically links haskell libraries by default
17:58:16 <lamefun> after strip it's still 45MB...
17:58:36 <haasn> My xmonad binary, which embeds the GHC compiler (to load user config ala dyre), is 13M large
17:58:50 <geekosaur> um, no
17:58:56 <geekosaur> xmonad does not use ghc-api
17:59:03 <roboguy_> lamefun: how big was it before?
17:59:06 <geekosaur> unless you hacked in dyre support yourself or something
17:59:19 <haasn> geekosaur: oh, does it run GHC from the system?
17:59:21 <geekosaur> xmonad calls ghc to compile a config and then execProces-es it
17:59:25 <geekosaur> *itself
17:59:30 <haasn> Then never mind my comment
18:00:47 <geekosaur> however being 13M does suggest something is a bit out of control. split-libs not enabled?
18:01:04 <geekosaur> er split-objs
18:01:04 <johnw`> is there a way to ask the template haskell pretty print to not suffix disambiguators to name?
18:01:13 <geekosaur> (which would result in a lot of unused code being linked in)
18:01:15 <johnw`> like, foo_0 :: m_1 a_2
18:01:18 <johnw`> i just want foo :: m a
18:01:33 <bitemyapp> stopGenSymingThisAintLisp
18:01:52 <lamefun> roboguy_, well, it only contains script loading code. A basic putStrLn "Hello, World!" program is only about 1.1MB...
18:03:21 * hackagebot ether 0.1.0.1 - Monad transformers and classes  http://hackage.haskell.org/package/ether-0.1.0.1 (int_index)
18:03:36 <roboguy_> lamefun: in that case, could you paste the code to the paste site so we can get a first hand look?
18:03:51 <lamefun> roboguy_, http://lpaste.net/134466 - that's all there is.
18:04:02 <bitemyapp> johnw`: mkName?
18:04:36 <johnw`> bitemyapp: I'm not sure what you're commenting on
18:04:45 <johnw`> I have a type, it prints with suffixes
18:05:23 <bitemyapp> johnw`: are you using Ppr?
18:05:29 <johnw`> yes
18:07:28 <bitemyapp> johnw`: https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/src/Language-Haskell-TH-PprLib.html#pprName doesn't look promising. Newtype and override?
18:09:59 <roboguy_> wow, I'm getting an executable about that big. GHC-as-a-library shouldn't be quite big enough to generate 50+ MB executables should it?
18:10:03 <vikaton> sorry I kinda went away unvoluntarily
18:10:21 <dmwit> GHC-as-an-application is 500+MB.
18:11:04 <lamefun> Well, so much for using Haskell as a scripting language... :(
18:11:29 <roboguy_> lamefun: if I use gzexe on it, it goes down to 12 MB
18:11:39 <bitemyapp> lamefun: nah, it can work fine for that :)
18:13:52 <Cale> What kind of toaster are you trying to run your programs on that 50 MB is any kind of an issue? :)
18:14:26 <roboguy_> ^ that is a good point. Ultimately, 50 MB isn't *that* huge
18:15:28 <Cale> Like, if it were 5 GB we were talking about, that's starting to become annoying.
18:18:22 <Cale> Right now on my system Chrome is sitting at ~500MB, and Steam is sitting there in the background taking ~600MB
18:18:31 <Cale> actually closer to 700
18:19:01 <pharaun> GTA V was like 20GB
18:19:23 <vikaton> > [ case () of _ | x `mod` 3 == 0 -> "Fizz" | x `mod` 5 == 0 -> "Buzz" | x `mod` 3 == 0 && x `mod` 5 == 0 -> "FizzBuzz" | otherwise -> x | x <- [7..13]]
18:19:24 <pharaun> oh my bad 60GB i was thinking of something else
18:19:24 <lambdabot>  <hint>:1:150: parse error on input ‚Äò]‚Äô
18:19:30 <ReinH> Cale: why at this point are we even engaging. Their only purpose is to find reasons to not use Haskell. So how about they just don't.
18:19:34 <vikaton> why do I get an error on that :S
18:19:46 <vikaton> dmwit, heh, after hours of afk
18:20:23 <dmwit> vikaton: Put explicit brackets so it knows the `case` expression is finished before the final `|`.
18:20:50 <dmwit> > [ case () of { _ | x `mod` 3 == 0 -> "Fizz" | x `mod` 5 == 0 -> "Buzz" | x`mod` 3 == 0 && x `mod` 5 == 0 -> "FizzBuzz" | otherwise -> x } | x <- [7..13]]
18:20:51 <lambdabot>      No instance for (Integral [Char]) arising from a use of ‚Äòmod‚Äô
18:20:52 <lambdabot>      In the first argument of ‚Äò(==)‚Äô, namely ‚Äòx `mod` 3‚Äô
18:20:52 <lambdabot>      In the expression: x `mod` 3 == 0
18:21:00 <dmwit> Well, that gets you to the next problem, anyway. ;-)
18:21:37 <vikaton> arent those braces? :)
18:21:43 <dmwit> In one branch you return `"Fizz"` (a `String`), and in another you return `x` (presumably some kind of number, perhaps `Integer`).
18:21:47 <dmwit> This will simply not do.
18:22:01 <geekosaur> vikaton, "brace" vs. "bracket" is somewhat regional
18:22:58 <dmwit> What is a brace in other regions?
18:23:02 <pharaun> also - chrome the browser - its binary is 119MB btw
18:23:21 * hackagebot orgmode-parse 0.1.1.2 - A collection of Attoparsec combinators for parsing org-mode  flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.1.1.2 (ParnellSpringmeyer)
18:23:27 <Cale> Yeah, I'm just talking about the size in memory
18:23:39 <vikaton> dmwit, so all arms must return the same type 
18:23:40 <pharaun> ahh k
18:23:48 <arkeet> UK seems to use "brackets" for all sorts of enclosing punctuation
18:23:50 <Cale> The size on disk is even less important imo.
18:24:05 <arkeet> and distinguishes between round brackets, square brackets, and curly brackets I guess
18:24:20 <pharaun> disk size matters mildly if you are uploading via a low bw link but someone spointed out they were able to gzip it down to 12mb
18:24:27 <pharaun> *shrugs*
18:24:31 <geekosaur> "A bracket is a tall punctuation mark typically used in matched pairs within text, to set apart or interject other text. Used unqualified, brackets refer to different types of brackets in different parts of the world and in different contexts." (wikipedia which goes on to give examples)
18:24:35 <dmwit> arkeet: I don't mean "What are braces called in other regions?", I mean "Which character(s) are called 'brace' in other regions?".
18:24:39 <Cale> yeah, I suppose
18:25:17 <dmwit> vikaton: naturally
18:25:17 <geekosaur> I have seen brace and bracket used in the reverse of typical US usage (that is [] are called braces and {} brackets)
18:25:34 <arkeet> that's just wrong
18:25:35 <arkeet> :p
18:26:27 <hpc> the correct term is "parenthuloid" ;)
18:26:44 <vikaton> > [ case () of { _ | x `mod` 3 == 0 && x `mod` 5 == 0 -> "FizzBuzz" | x `mod` 3 == 0 -> "Fizz" | x `mod` 5 == 0 -> "Buzz" | otherwise -> show x } | x <- [1..100]]
18:26:46 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
18:26:52 <vikaton> eyy
18:27:52 <dmwit> I can't believe fizzbuzz became a thing.
18:29:16 <dmwit> also, vikaton++ for making it work!
18:30:00 <vikaton> yeah I dont know why it's something that interviewers test their candidates with
18:30:12 <vikaton> i just did that to make a smaller implementation than my friends
18:30:41 <ReinH> Now write s version that works for an arbitrary list of primes mapped to words.
18:31:06 <dmwit> Heck, why even demand primality?
18:31:18 <ReinH> Then optimize that version, e.g., by memoizing.
18:31:58 <ReinH> Specifically to avoid lookup time linear to position to the list or case statement / pattern match.
18:32:18 <ReinH> It's not a worthless problem, but the way it's employed is usually pretty worthless
18:33:15 <ReinH> dmwit: It isn't necessary, no
18:34:29 <ReinH> Now write it using fancy technology like monoids and cps.
18:34:50 <ReinH> Because why not.
18:34:54 <ReinH> Let's slap as much lipstick on this pig as possible.
18:35:18 <roboguy_> vikaton: you can make that a bit shorter
18:35:39 <vikaton> roboguy_: h0w
18:36:52 <roboguy_> vikaton: you can get rid of all the spaces for one. Also, x `mod` 3 && x `mod` 5 can be simplified
18:37:31 <vikaton> roboguy_: to?
18:37:45 <solirc> felixn: I don't recommend using doctest for testing code.  From my perspective it's for testing documentation.  I prefer Hspec for testing code.
18:37:48 <GGuy> Is there a way to declare an instance for non-function types? e.g. I want both: "instance TC (a -> b)" and "instance TC a" where a is a non-function in the second instance
18:37:59 <roboguy_> vikaton: if something is divisible by both 3 and 5 it's also divisible by 15
18:38:13 <vikaton> ooo math
18:38:20 <dmwit> GGuy: Not really. You can declare an instance for all the type constructors you're interested in.
18:38:24 <vikaton> Ok, thanks roboguy_ 
18:38:33 <dmwit> There is a way, but you won't pry that way out of my lips.
18:39:11 <GGuy> dmwit: Thanks, I thought as much.
18:39:26 <roboguy_> vikaton: Sure! My shortest Haskell fizzbuzz (that is a complete program) is 97 characters. Maybe there's a way to get under that
18:39:47 <dmwit> ?where fizzbuzz
18:39:47 <lambdabot> I know nothing about fizzbuzz.
18:39:52 <dmwit> oh well
18:39:54 <roboguy_> Haskell code golf can be kinda fun
18:40:00 <ReinH> roboguy_: Write s program that interprets a 0-length file to be the program in question. ;)
18:40:20 <roboguy_> ReinH: haha, I don't think hacker rank would accept that one
18:40:55 <ReinH> Do they allow golfscript? Close enough.
18:41:16 <roboguy_> Unfortunately no. That would be fun though
18:41:50 <ReinH> This is my solution to all golf questions. I am not invited to code golf parties.
18:41:51 <dmwit> I propose a new language, pe. All byte strings are terms of this language. The bytes are interpreted as a binary number, and the solution to the Project Euler problem of that number is spit out.
18:42:11 <roboguy_> I'd also like to mess around with the ><> language, but I have to do that on my own (and on the code golf stack exchange)
18:43:28 <simon> roboguy_, what language is that?
18:44:07 <simon> my favourite esoteric language is Homespring. poetic and of its own paradigm.
18:44:08 <roboguy_> simon: it's pronounced "fish". it's a 2 dimensional stack-based language kinda like Befunge: https://esolangs.org/wiki/Fish
18:44:30 <pharaun> do we have a 3d version yet :D
18:44:56 <hodapp> roboguy_: I've always thought the Funges were an interesting family of languages.
18:45:21 <roboguy_> pharaun: we'd need something that's like a newline, but in a 3rd dimension
18:45:43 <ReinH> roboguy_: how can I google for this language?
18:45:43 <roboguy_> hodapp: ><> is my only experience with them, but it has been interesting playing with it
18:45:57 <roboguy_> ReinH: probably "fish language" is your best bet
18:46:04 <roboguy_> ha
18:46:05 <pharaun> roboguy_: we already got a 2nd newline ;p (\n and \r)
18:46:07 <simon> pharaun, maybe we'll have one when VR becomes mainstream. :)
18:46:17 <ReinH> roboguy_: oh you gave a link already too, thanks
18:46:21 <roboguy_> pharaun: good point!
18:46:22 <pharaun> simon: heh probably!
18:46:41 <ReinH> roboguy_: I considered writing a golfscript interpreter in Haskell but then I realized that it allows Ruby interpolation in strings...
18:47:06 <roboguy_> ReinH: I've actually never used golfscript. I've seen it sometimes on the codegolf SE though.
18:47:21 <roboguy_> Golfscript and Py seem popular there
18:47:56 <ReinH> roboguy_: wait, Py?
18:48:16 <simon> http://bunny.xeny.net/linked/Homespring-Proposed-Language-Standard.pdf
18:48:37 <roboguy_> ReinH: oh, Pyth I think
18:49:28 <roboguy_> it's like a dialect of Python that's designed for code golf
18:49:50 <roboguy_> well, "dialect" might not be the right word exactly. It's pretty inspired by Python
18:52:23 <roboguy_> Now that I think about it, I was working on an implementation of ><> in Haskell... I can't remember if I finished it...
18:52:37 <roboguy_> I used it as an excuse to try out the record package
18:54:04 <ttt_fff> is let-in vs where mainly an issue of style?
18:55:35 <rvxi> hey
18:55:47 <rvxi> anyone use gloss on OSX?
18:55:55 <caconym> I have in the past
18:56:13 <rvxi> caconym: running into an error with glut
18:56:39 <rvxi> can't load .so/.DLL for
18:56:51 <traynham_> retina?
18:56:55 <rvxi> ... libHSGLUT-2.7.0.1-0waW9bZutCf5s5H5zSV4Oh-ghc7.10.1.dylib (dlopen(/Users/huanga13/sb/.cabal-sandbox/lib/x86_64-osx-ghc-7.10.1/GLUT_J2ZZFJOYOcH4hQYFlXhEPp/libHSGLUT-2.7.0.1-0waW9bZutCf5s5H5zSV4Oh-ghc7.10.1.dylib, 5): Symbol not found: _glutBitmap8By13
18:57:07 <caconym> my machine is mid-2012 retina pro 15"
18:57:08 <rvxi> not retina (this is an older macbook air)
18:57:19 <caconym> I didn't see that error, so I probably can't help you :(
18:57:38 <caconym> what OSX are you running?
18:57:39 <traynham_> permission issue maybe?
18:57:52 <rvxi> i'm admin
18:58:01 <rvxi> osx 10.9.5
18:58:24 <caconym> hmm
18:58:36 <caconym> I believe I was on Yosemite when gloss worked for me
18:58:52 <caconym> for what that's worth
18:59:08 <traynham_> this you? http://stackoverflow.com/questions/30825272/haskell-gloss-example-error-w-glut-dynamic-library-symbol-not-found-glutbitm
18:59:29 <rvxi> yup
19:00:28 <caconym> https://github.com/haskell-opengl/GLUT/issues/19
19:01:19 <rvxi> it's a GHC bug??
19:01:21 <caconym> "The consensus seems to be that this is a GHC 7.8.4 => 7.10.1 regression, so I'll close this issue. If there are strong indicators that this is really caused by the GLUT package, then feel free to re-open this issue."
19:01:24 <traynham_> it might be
19:01:44 <traynham_> or the way it's interfacing with GHC
19:01:53 <rvxi> hm
19:01:55 <geekosaur> ghc has had problems with transitive symbol resolution across shared objects (not just on OS X)
19:02:02 <geekosaur> which may be this issue
19:02:22 <rvxi> what is transitive symbol resolution
19:02:23 <rvxi> ?
19:03:35 <rvxi> darn that's what i get for updating my compiler versions obsessively...
19:03:46 <geekosaur> basically instead of the DSO depending directly on another DSO providing a symbol, it depends on a second DSO which depends on the one with the needed symbol
19:04:03 <geekosaur> but ghc's loader is only looking in that second and not following the dependency to the one with the symbol
19:05:47 <eds> Is there a way to select elements randomly from a list? say [1,24,56]
19:05:51 <eds> how would I do that?
19:06:31 <rvxi> random-fu perhaps?
19:07:35 <eds> :random-fu
19:07:40 <felixn> > [1,24,56] !! 1
19:07:41 <lambdabot>  24
19:07:52 <felixn> eds: careful though (!!) isn't type safe
19:08:36 <geekosaur> (more precisely: it loads the second DSO but not the DSOs that it depends on, so the load fails with an error like that. IIRC the fix/workaround is they're arranging for the first DSO to depend not only on that second but also on the DSOs the second depends on, to ensure they're loaded; that fix should be in 7.10.2)
19:12:45 <rvxi> random-fu is a bit too slow for me though
19:13:03 <roboguy_> @hackage random-fu
19:13:03 <lambdabot> http://hackage.haskell.org/package/random-fu
19:15:32 <sugarwife> is it possible to import modules from hidden packages in a ghci session?
19:16:31 <rvxi> is helm pretty much dead? never hear people say good things about it
19:17:39 <roboguy_> sugarwife: :set -package <hidden package>
19:18:51 <sugarwife> roboguy_: perfect, thanks!
19:19:15 <sanjoyd> What is the right way to install Haskell on OS X?
19:19:25 <rvxi> don't use the platform
19:19:41 <rvxi> https://ghcformacosx.github.io/
19:20:30 <vikaton> can someone help me build lambdabot on my pc?
19:20:36 <vikaton> not sure how :(
19:20:39 <rvxi> i started with the platform and ended up in cabal hell
19:25:17 <Freefood> Hey what's the best way to handle i18n in haskell ?
19:25:27 <lifter> Is there something like (***) that will allow me to apply 3 different functions to the values in a triple?
19:26:41 <caconym> is there a way to specify a git repository as a source for a dependency in a .cabal file?
19:27:38 <Myrl-chan> foldl1 (*) . (1:) $ [1..3]
19:27:44 <Myrl-chan> > foldl1 (*) . (1:) $ [1..3]
19:27:45 <lambdabot>  6
19:27:48 <Myrl-chan> :D
19:27:51 <roboguy_> lifter: if you have functions (a, (b, c)) -> (a, b, c) and (a, b, c) -> (a, (b, c)) you can use f *** g *** h
19:28:25 <lifter> roboguy_, Ah, that makes sense
19:28:48 <lifter> nifty
19:29:13 <sanjoyd> rvxi: how about ‚Äúbrew install ghc‚Äù?
19:29:19 <sanjoyd> rvxi: is that recommended?
19:29:34 <Myrl-chan> :t (***)
19:29:35 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:29:46 <roboguy_> sanjoyd: this is what I used https://ghcformacosx.github.io/
19:30:08 <sanjoyd> roboguy_: is that easy to update?
19:30:11 <rvxi> sanjoyd: i haven't tried that
19:30:17 <roboguy_> sanjoyd: haven't tried to so far
19:30:18 <rvxi> it's pretty easy
19:30:25 <caconym> sanjoyd: that's what I do on my OSX machine and it works well
19:30:26 <rvxi> just a precompiled binary
19:30:40 <rvxi> you might have to tweak your paths
19:30:44 <caconym> you must also `brew install cabal-install` iirc
19:30:50 <rvxi> to point to cabal, ghc, ghci in the App folders
19:30:51 <sanjoyd> caconym: sure.
19:30:54 <caconym> the versions in brew are quite recent
19:31:22 <roboguy_> I've heard people suggest avoiding the brew versions but I don't remember why
19:31:39 <caconym> yeah, there could very well be good reasons
19:39:27 <hodapp> Wow, I am sort of surprised that lamefun, in his arguing about Haskell as a scripting language, did not once acknowledge my suggestions for two libraries, Shelly and Turtle, designed for exactly that.
19:44:25 <roboguy_> hodapp: I thought the implication was that he was looking for something to do scripting for a video game. Then again, who can really tell...
19:45:26 <hodapp> roboguy_: Asking whether or not the docs were lying likely did not start the discussion on the right foot.
19:46:04 <roboguy_> hodapp: ha! probably not
20:00:44 <DNoved1> Reading about dependent type systems, I understand that in general type inference is impossible. But does anyone know if a top-level type annotation on each function makes it decidable?
20:01:33 <hodapp> DNoved1: in that context, what inference could be done?
20:02:29 <DNoved1> Well, for instance I imagine if I had id : forall a . a -> a and id = \x.x
20:02:32 <roboguy_> DNoved1: it depends on the type system
20:02:49 <roboguy_> oh, for dependent types. I missed that bit
20:02:51 <DNoved1> I could infer that there must be an implied lambda at the beginning introducing a
20:03:10 <sccrstud92_> is there anyway to automatically derive instances of Serializable for types that I did not write that do not derive Generic?
20:04:15 <DNoved1> I just wasn't sure if it is always the case that a top-level declaration is enough information for inference.
20:08:29 <sccrstud92_> is there a way to automatically derive Generic for a type in another package?
20:10:40 <rvxi> reverting to GHC 7.8.4
20:10:55 <pavonia> sccrstud92_: Have you tried with the StandaloneDeriving extension?
20:11:05 <rvxi> will see if that gloss problem was a ghc bug..
20:17:47 <sccrstud92_> pavonia: thanks for the tip. that worked. I did standalone deriving for generic and then an empty instance for Serialize
20:28:27 * hackagebot wai-middleware-metrics 0.2.1 - A WAI middleware to collect EKG request metrics  http://hackage.haskell.org/package/wai-middleware-metrics-0.2.1 (Helkafen)
20:29:37 <GLM> Has anyone been to ICFP?
20:30:14 <pacak> GLM: o_o
20:30:26 <GLM> pacak:Is that a yes?
20:30:31 <dolio> DNoved1: No, that is not enough in general.
20:30:37 <pacak> GLM:  That is yes.
20:31:07 <GLM> pacak: What goes on there? I can't seem to find much beyond a few papers. I'm trying to decide between that and another conference
20:31:49 <pacak> GLM: Papers, a few workshops, a bunch of people to talk to. Was kind of fun.
20:32:08 <GLM> pacak:Better or worse than most conferences?
20:33:16 <pacak> GLM: Not sure about most, but there was defenitely more functional programming stuff.
20:33:45 <DNoved1> dolio: Darn.
20:33:50 <GLM> pacak: I only get to go to one conference a year so I'm trying to make it count. The only other one I see (tell me if I missed one) is strange loop
20:34:29 <DNoved1> All the best things in life seem to be computationally impossible, it seems
20:34:32 <pacak> strangeloop looked much more web-javascript-ios kind of conference.
20:34:54 <rvxi> anyone know of any good tutorials for ekmett's low-level gl bindings?
20:35:02 <GLM> pacak:Any other ideas?
20:35:19 <pacak> GLM: Not really.
20:35:34 <roboguy_> rvxi: I think it directly exposes the OpenGL API, doesn't it? In that case, probably any OpenGL tutorial would work out
20:36:37 <rvxi> probably so once i get past a hello triangle
20:37:46 <caconym> rvxi: any luck with gloss?
20:38:19 <rvxi> caconym: unfortunately no, tried to revert to ghc 7.8.4
20:38:33 <rvxi> but then gloss-raster wasn't building correctly
20:38:58 <caconym> :(
20:39:22 <rvxi> getting going with graphics in haskell is slow going =/
20:39:25 <caconym> that is very frustrating, gloss is pretty great
20:39:41 <caconym> it worked out of the box for me and was so intuitive that I had stuff up and running very quickly
20:39:42 <rvxi> seems like a beginner friendly place to start
20:41:05 <roboguy_> rvxi: did you look at edwardk's quine? It's a demo that uses gl
20:41:27 <roboguy_> it's probably a bit on the complex side though, ha. I haven't looked at the code, but I've seen what it looks like when it runs
20:42:47 <rvxi> yeah i'm looking for something a bit more beginner friendly. it looks like something he made primarily for his own use
20:42:52 <rvxi> impressive looking though
20:44:23 <caconym> rvxi: if you felt like you were close, i recommend persevering with gloss
20:45:02 <caconym> it's one of the most magical experiences I've had with a haskell library
20:45:15 <rvxi> if it's a bug in ghc it's going to be tough to get around that
20:45:38 <rvxi> maybe i can try to build a development snapshot of 7.10.2
20:46:06 <caconym> might be easier than figuring out some low-level opengl bindings :)
20:46:13 <caconym> anyway i gotta go, good luck though
20:53:50 <sccrstud92_> so I need to use the type SockAddr from Network.Socket.Types, but apparently its hidden? anyone know where i can import the SockAddr type from?
20:56:26 <pavonia> sccrstud92_: It's in Network.Socket
21:34:23 <jume> @pl
21:34:23 <lambdabot> (line 1, column 1):
21:34:23 <lambdabot> unexpected end of input
21:34:23 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
21:34:41 <jume> @pl \col -> getCol col numbers
21:34:42 <lambdabot> flip getCol numbers
21:35:34 <jume> @pl [ getCol column numbers | column <- [1..20] ]
21:35:34 <lambdabot> [getCol column numbers | column <- [1..20]]
21:38:30 * hackagebot attoparsec-trans 0.1.0.0 - Interleaved effects for attoparsec parsers  http://hackage.haskell.org/package/attoparsec-trans-0.1.0.0 (srijs)
21:39:40 <pavonia> jume: [ f x | x <- xs ] == map f xs
21:41:10 <jume> pavonia: thanks!
21:42:02 <jume> pavonia: is there a pattern for flipping arguments when there are more than two?
21:42:13 <johnw> you can use ?? from lens
21:42:16 <johnw> foo ?? x y
21:44:10 <jume> so if I have "slice x y z" and want "slice y z x" I do "slice ?? y z" and then I can apply x?
21:44:36 <johnw> oh, I see what you mean
21:44:48 <johnw> what you're asking to do is usually just done with a lambda
21:44:58 <johnw> \x y z -> slice y z x
21:45:06 <johnw> @pl \x y z -> slice y z x
21:45:06 <lambdabot> flip (flip . slice)
21:45:21 <pavonia> :t (??)
21:45:21 <jume> cool thanks
21:45:22 <lambdabot> Functor f => f (a -> b) -> a -> f b
21:47:09 <jume> is striving for point free code the idiomatic haskell way? Or can you go overboard?
21:49:03 <Cale> jume: It's easy to go overboard, and best just to find a point where things are clearest to you.
21:49:10 <jume> makes sense
21:51:18 <simon> @pl \x y z -> x (y z) + y (y z)
21:51:19 <lambdabot> (`ap` join (.)) . (liftM2 (+) .) . (.)
21:52:50 <simon> jume, I sometimes rewrite a line of code just below its original. sometimes I go overboard and do that five times and I have to go back because I got carried away. :P
21:53:30 * hackagebot attoparsec-trans 0.1.0.1 - Interleaved effects for attoparsec parsers  http://hackage.haskell.org/package/attoparsec-trans-0.1.0.1 (srijs)
21:54:56 <jume> simon: Haha that sounds familiar :) I've found I solve a problem and then go back and think about how to make it point free. Writing it that way first isn't intuitive yet but can be more satisfying ultimately
21:57:27 <jume> WHOIS #haskell jume
21:58:19 <fraguk> Get free hosting on our newly opened free hosting website. Branded Free (no adverts) PHP 5 installed visit https://www.criosphinx.net or apply through our forums at http://www.criosphinx.net/community
21:58:22 <fraguk> Get free hosting on our newly opened free hosting website. Branded Free (no adverts) PHP 5 installed visit https://www.criosphinx.net or apply through our forums at http://www.criosphinx.net/community
22:00:42 <jume> @pl \x -> z (\y -> q y 4 x) [0..(r x) - 4]
22:00:42 <lambdabot> ap (z . flip (flip q 4)) (enumFromTo 0 . subtract 4 . r)
22:07:16 <jume> @pl \vector -> V.length vector >= 4
22:07:16 <lambdabot> (>= 4) . V.length
22:08:23 <jume> @pl (\start -> V.slice start 4 vector)
22:08:24 <lambdabot> flip (flip V.slice 4) vector
22:10:27 <howdoi> what are things that a JS dev can learn from haskell :)?
22:12:09 <felixn> howdoi: I actually really like Node.js, haskell pairs with it pretty well.  I think that's because both focus on composability & higher order functions
22:13:09 <howdoi> felixn yet JS doesn't have currying by default, neither it's pure
22:13:29 <felixn> howdoi: what you could learn from haskell would be how to express your ideas in a much higher level way, so you get static safety, faster programs ... there's just so much you can infer from a declarative language, like documentation
22:13:31 * hackagebot attoparsec-trans 0.1.0.2 - Interleaved effects for attoparsec parsers  http://hackage.haskell.org/package/attoparsec-trans-0.1.0.2 (srijs)
22:13:32 <howdoi> TCO is still under progress 
22:14:33 <howdoi> felixn try, when it's the matter of FP in JS, would you vote for [].reduce(() =>{}) or reduce(() => {}, [])
22:15:33 <felixn> well, if [] is an object with a "reduce" function, I would say that the latter is more complex
22:15:52 <felixn> but if "." is a function that just flips it around, then they're the same, and just personal preference
22:16:13 <howdoi> but the later one is more closer to functional paradigm 
22:16:26 <howdoi> also helps in composing functions?
22:16:37 <jume> @pl \length -> V.generate length $ \index -> matrix ! (index+1, index+1)
22:16:37 <lambdabot> ($ (matrix !) . liftM2 (,) (1 +) (1 +)) . V.generate
22:16:49 <howdoi> we can compose [].reduce, but we can compose reduce()
22:16:59 <felixn> not if [] is an object containing a reduce function, in the former, [] doesn't have anything attached to it except the elements in the list
22:17:20 <felixn> s/former/latter/ bleh
22:18:20 <howdoi> that's where FP in JS is getting painful for me
22:18:22 <howdoi> :(
22:19:02 <felixn> howdoi: it's cool when things like jQuery and underscore have the batteries included that you need, but think about when it doesn't have something you want, how annoying it is to inject it in the chain.  it makes your function feel like a 2nd class citizen, because it wasn't blessed
22:19:08 <howdoi> which book/article/video would you suggest that would give me take aways to improve my FP skills in general and hence can apply it to JS as well?
22:19:11 <felixn> in haskell, everything is on the same level, just simple pure functions
22:19:35 <howdoi> that's the fun!
22:19:44 <howdoi> I like ramda more than lodash 
22:20:20 <felixn> howdoi: just think of something you want to build, then do it!  google is your friend, and so is #haskell
22:21:15 <howdoi> hmm ok, say, lately I was playing with wrapping text in a canvas element, now would you suggest me to try that in haskell? felixn 
22:22:09 <howdoi> felixn so far https://github.com/hemanth/haskell-rascal
22:22:32 <felixn> howdoi: sorry! have to go
22:22:48 <howdoi> thanks felixn, cya around 
22:41:16 <scutigera> hello. is anybody out there ?
22:43:48 <verement> hello
22:43:49 <Axman6> there's like 100 people in this channel, so the answer is almost certainly yet. do you have a question?
22:45:11 <scutigera> i sure do.
22:45:24 <scutigera> i'm looking at an example of attoparsec code and it uses "many"
22:45:48 <scutigera> but i can only find many' many1 and  a few others but no "many"
22:47:53 <kadoban> Axman6: more like 1500ish :)
22:49:24 <scutigera> i have other questions if no one likes that one ;-)
22:50:59 <MrWoohoo> anyone out there using https://ghcformacosx.github.io for OS X? I'm having trouble getting it going 
22:52:10 <kadoban> scutigera: Yeah I'm not sure why there's no "many". I'd just use many', at a guess.
22:53:28 <ronh-> perhaps the example is using many from Control.Applicative
22:53:28 <Axman6> I think many is now part of the Alternative class
22:53:28 <scutigera> the value returned by p is forced to WHNF.  hmmm....
22:53:31 <pharaun> oh is the "many" ah yes
22:53:43 <Axman6> MrWoohoo: I am, what's the problem?
22:53:43 <scutigera> aha
22:53:46 <pharaun> its part of the Control.Applicative - Alternative
22:53:48 <Axman6> @hoogle many
22:53:49 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
22:53:49 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
22:53:49 <lambdabot> Text.Parsec.Prim many :: ParsecT s u m a -> ParsecT s u m [a]
22:53:51 <pharaun> https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Applicative.html
22:53:58 <pharaun> or that
22:54:01 <scutigera> ty
22:54:08 <scutigera> that's confusing...
22:54:09 <kadoban> Oh I see. That's good to know.
22:54:10 <scutigera> so many manys
22:54:25 <Axman6> (defined as (:) <$> p <*> many p <|> pure [])
22:54:31 <MrWoohoo> I try to run "cabal install text" as mentioned on their doc page https://github.com/ghcformacosx/ghc-dot-app but I get an error like this: dyld: Library not loaded: /opt/local/lib/libiconv.2.dylib  Reason: Incompatible library version: cabal requires version 8.0.0 or later, but libiconv.2.dylib provides version 7.0.0
22:54:53 <Axman6> MrWoohoo: which version of OS X?
22:55:06 <scutigera> so many is really map
22:55:07 <MrWoohoo> yosemite
22:55:20 <Axman6> scutigera: not even close :P
22:55:43 <Axman6> MrWoohoo: looks like you're using homebrew? 
22:56:20 <kadoban> scutigera: Not really.   map :: (a -> b) -> [a] -> [b]       many :: (Alternative f) => f a -> f [a]
22:57:10 <MrWoohoo> I just switched to it from ports because everyone says THAT is defunct now (third time switching between the two over the years). There might be stray bits of things laying around. Not sure what survived the upgrade to yosemite
22:57:31 <alisia> why does cabal install fail with "build log does not exist error"?
22:58:00 <scutigera> yeah- they both return lists. i may have inferred just a bit too much there.
22:58:02 <scutigera> just a bit.
22:58:07 <alisia> i am trying to install wai-middleware-static in a sandbox..
22:58:42 <Axman6> MrWoohoo: macports has been defunct for many years if you ask me. I haven't used it for 5 or more years
22:58:50 <scutigera> moral of the story don't even bother looking at the attoparsec page unless you have the applicative page up also.
22:59:19 <MrWoohoo> not a real active dev. I just limp along. that's a problem now LOL
22:59:21 <kadoban> I doubt there's many (heh) more like that.
23:00:27 <MrWoohoo> I install wget (with brew) because a google link mentioned that as a fix since it would add the right library, but no joy on that
23:00:36 <MrWoohoo> installed
23:02:14 <MrWoohoo> back in a few minutes... thanks for your help so far 
23:08:05 <johnw> @tell edwardk first (H f) = go where go = H $ \(H k) -> first (f . H . const) (k go)
23:08:05 <lambdabot> Consider it noted.
23:10:00 <scutigera> johnw: great. my brain exploded.
23:10:04 <MrWoohoo> back
23:10:10 <johnw> scutigera: yeah, this was a tough puzzle
23:10:39 <scutigera> now i have to clean this all up, or the wife will be bitter.
23:11:10 <MrWoohoo> Axman6: any guesses?
23:11:29 <alisia> why does cabal install fail with "build log does not exist error"?
23:11:53 <scutigera> that's a new one for me. but you might try "cabal setup" ?
23:12:05 <Axman6> MrWoohoo: I would start by trying to upgrade your libiconv in homebrew
23:12:33 <scutigera> oops. cabal configure...
23:12:45 <Arahael> scutigera: Your wife cares about the state of your cabal projects?
23:13:05 <MrWoohoo> didn't see a separate package for it. tried installing wget to fix that
23:13:17 <MrWoohoo> since it supposedly uses the lib
23:13:28 <scutigera> Arahael: no she cares about not having bits of brain on the monitor.
23:13:35 <MrWoohoo> according to google... who knows... don't know how to check 
23:13:39 <Arahael> scutigera: Ah. She's a keeper.
23:14:18 <MrWoohoo> anyone else running haskell on isx?
23:14:21 <MrWoohoo> osx
23:14:45 <Axman6> I'm not even sure why it's using iconv from there. it shouldn't even be installed by homebrew
23:15:03 <Arahael> MrWoohoo: I am.
23:15:04 <scutigera> so .  parse aLine inputStr
23:15:14 <MrWoohoo> I can't even run "cabal --version" without getting the error
23:15:18 <scutigera> aLine = takewhile (/= '\n')
23:15:26 <Arahael> MrWoohoo: I tend to avoid homebrew for haskell.
23:15:34 <scutigera> aarg.  let foo = parse aLine inputStr
23:15:50 <MrWoohoo> I'm trying to use this https://github.com/ghcformacosx/ghc-dot-app
23:15:54 <scutigera> so when i run that i would think that i get the first line of text in the file.
23:15:59 <Arahael> MrWoohoo: Yep, that's generally good.
23:16:26 <MrWoohoo> but "cabal install text" craps out
23:16:29 <Arahael> MrWoohoo: Actually I tend to use this other package:
23:17:04 <Arahael> MrWoohoo: https://ghcformacosx.github.io/  Though I think that's the same thing.
23:17:10 <scutigera> instead - i get the rest of the file except for the first line...
23:17:14 <Arahael> MrWoohoo: Next, did you set up a cabal sandbox?
23:17:17 <MrWoohoo> I think so too
23:17:51 <MrWoohoo> no, I'm just running the first command they say you're supposed to do as the second step! 
23:18:13 <ptrckbrwn> I'm having troubles figuring out why a function is behaving so poorly. It looks to be O(n) but runs like O(n^2). https://gist.github.com/ptrckbrwn/6d4216b04ec38d4bebf3
23:18:19 <MrWoohoo> like I said, can't even run cabal --version at this point
23:18:27 <ptrckbrwn> my input size is ~1,000,000 characters long
23:18:33 <breadmonster> Umm, why don't data constructor definitions show up in Core?
23:18:58 <Arahael> MrWoohoo: Your packages are probably somewhat inconsistent, then.  Do you have more than one cabal and/or ghc installed?
23:19:17 <MrWoohoo> Araheal can you scroll back to see the error msgs I posted?
23:19:21 <alisia> why does cabal install fail with "build log does not exist error"?
23:19:42 <Arahael> MrWoohoo: No. :(
23:19:49 <kadoban> ptrckbrwn: You're computing the length over and over and over and over, etc.
23:20:12 <MrWoohoo> I upgraded to yosemite, and used to use macports. the "ports" command didn't survive the upgrade, but there might be bits and pieces of stuff around
23:21:04 <Arahael> MrWoohoo: Your cabal packages and/or ghc packages are probably inconsistent.  Try making _sure_ you're using the correct ghc and cabal (use 'which' to check), and then use sandboxes.
23:21:08 <kadoban> ptrckbrwn: You could also use whatever that function is that combines take and drop, but that's minor.
23:21:17 <MrWoohoo> cabal --version ==> dyld: Library not loaded: /opt/local/lib/libiconv.2.dylib / Reason: Incompatible library version: cabal requires version 8.0.0 or later, but libiconv.2.dylib provides version 7.0.0
23:21:32 <kadoban> ptrckbrwn: Or wait, maybe not.
23:21:48 <scutigera> @hoogle splitAt
23:21:48 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
23:21:49 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
23:21:49 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
23:21:50 <Arahael> MrWoohoo: And what does 'which cabal' say?
23:22:16 <MrWoohoo> ls -l `which cabal`
23:22:16 <MrWoohoo> -rwxr-xr-x+ 1 root  wheel  18507708 Oct  5  2013 /Users/thom/.cabal/bin/cabal
23:22:35 <MrWoohoo> should I just blow away ~.cabal?
23:22:50 <MrWoohoo> not anything I could want in it, I think ????
23:23:07 <ptrckbrwn> kadoban: i've been scratching my head at this one for a while now
23:23:15 <Arahael> MrWoohoo: Apparently there's a sanctioned way that .cabal and .ghc should be cleaned up, but I'm not sure what it is.   Apparently there may be stuff you may want to keep.
23:23:22 <ptrckbrwn> kadoban: it being 2am doesn't help either :)
23:23:24 <Arahael> MrWoohoo: Eg, your cabal config file there may have specific settings.
23:23:48 <Arahael> MrWoohoo: I'm a novice haskeller.
23:23:54 <kadoban> ptrckbrwn: :)
23:23:58 <MrWoohoo> note the date on that file... 2013?
23:24:21 <Arahael> MrWoohoo: It's a clue, indeed. :)
23:24:22 <MrWoohoo> LOL Fuck it... rm .cabal... let it rebuild it if it wants
23:24:50 * MrWoohoo waits for any cries of "NO! NO! NO!"
23:24:51 <Arahael> MrWoohoo: There is also ~/.ghc which is where packages go outside of the sandbox, iirc.
23:25:12 <Arahael> MrWoohoo: Though in this case I'd usually advocate *moving* them to ~/archived_2015 just to be safe. ;)
23:25:26 <MrWoohoo> good call
23:28:33 <scutigera> let foo = many' $ parse aLine inputStr
23:28:44 <scutigera> No instance for (GHC.Base.MonadPlus Result)
23:29:02 <MrWoohoo> ah, working much better
23:29:18 <MrWoohoo> thanks
23:30:18 <sccrstud92_> im using Data.Conduit.Network. Does anyone know how to set TCP_NODELAY on the socket?
23:30:23 <Arahael> MrWoohoo: No worries. :)
23:30:44 <MrWoohoo> Could not find module ‚ÄòNetwork.HTTP.Conduit‚Äô when I try to compile now
23:31:17 <kadoban> sccrstud92_: You seem to have shown an error message mentioning something not shown in the only code you showed ‚Ä¶
23:31:24 <kadoban> sccrstud92_: Sorry, wrong person :-/
23:31:31 <kadoban> scutigera: ^
23:31:39 <sccrstud92_> kadoban: aww you got me excited =(
23:31:41 <MrWoohoo> cabal install Network.HTTP.Conduit --dry-run
23:31:42 <MrWoohoo> cabal: The file does not exist 'Network.HTTP.Conduit'.
23:31:50 <MrWoohoo> it was a bad guess :(
23:32:17 <scutigera> kadoban: sorry- trying not to paste all the lines in.
23:32:24 <scutigera> In an equation for ‚Äòfoo‚Äô: foo = many' $ parse aLine inputStr
23:32:56 <kadoban> scutigera: http://lpaste.net/new/haskell  <-- paste there, including the full error (ideally in comments)
23:33:15 <MrWoohoo> got it. never mind :)
23:33:57 <scutigera> kadoban: pasted...
23:34:27 <scutigera> i'm just trying to get parsec to collect the lines in a file
23:34:47 <scutigera> i figure once i have that adding additional parsing stuff should be easier.
23:35:40 <scutigera> ok. also too. changed the name of the file so it's reading itself.
23:37:52 <alisia> why does cabal install fail with "build log does not exist error"?
23:40:32 <kadoban> scutigera: You have to paste the URL here, unless I missed it somehow?
23:42:54 <scutigera> http://lpaste.net/134474
23:43:28 <scutigera> sorry- haven't used it before. took me a minute to realize i needed to press public...
23:43:41 <scutigera> also to it found an error (redundant do)
23:44:07 <kadoban> 's all good. Yeah it automatically runs hlint on code
23:44:13 <scutigera> which is handy !
23:44:52 <scutigera> bookmarking lpaste.net now ... :-)
23:48:16 <kadoban> scutigera: I think you mean something like ‚Ä¶   let foo = parse (many1 aLine) inputStr    ?
23:49:12 <MrWoohoo> boo.hs:5:8:
23:49:14 <MrWoohoo>     Could not find module ‚ÄòText.HTML.DOM‚Äô
23:49:16 <MrWoohoo> Where do I find out what package this belongs too?
23:50:02 <scutigera> kadoban: i do mean something like that...
23:50:32 <scutigera> so... many1 is a monadic thing, and the parser is a monad too... so m a where m is Parser. i think.
23:50:55 <scutigera> i shouldn't use so many ...
23:51:18 <scutigera> oh wait. many1 not many'
23:51:47 <scutigera> oh either works.  could be an empty file.
23:52:04 <bollu> Okay, so, well, I understand the use of State. But I don't see the point of Reader. Isn't it equivalent to just passing an argument? The only point I can think of in using a Reader r is to save yourself from sending "r" in a do block. Is that... it? 
23:52:24 <bollu> and is that what they mean when they say that Reader r ~ ((->) r) ?
23:52:48 <kadoban> bollu: It's State except you can't change it. So yeah, it's when you want to have some common data available but don't want to have to explicitly pass it around.
23:53:01 <scutigera> kadoban: ty!
23:53:10 <bollu> kadoban: and Writer? If you want to write to something but never read from it?
23:53:21 <bollu> kadoban: doesn't using Reader just make your functions more inflexible?
23:53:32 <bollu> like, a "free" function is much nicer to compose that a Reader r a
23:53:45 <bollu> so, well, you're just bringing in inflexibility for syntactic niceness?
23:53:52 <bollu> I don't see that as a worthwhile tradeoff
23:53:55 <kadoban> bollu: Writer is kinda like logged computation.
23:54:29 <bollu> kadoban: wherein the type you're writing to is a Monoid, right? (BTW, haskell monoid is the same as abstract algebra monoid I hope? group minus the inverse) ?
23:55:13 <kadoban> bollu: Yeah
23:55:25 <bollu> kadoban: hmm
23:56:09 <bollu> kadoban: as of now, I'm trying to familiarize myself with haskell by solving questions from HackerRank
23:56:16 <kadoban> I don't think using Monads really makes the types or functions inflexible, maybe I'm not understanding what you mean. It kind of nicely encodes exactly what you're doing.
23:56:53 <bollu> kadoban: well, what I mean is, having something of the form a -> b -> r -> o | is much nicer (IMO) than a -> b -> Reader r o.
23:57:06 <kadoban> bollu: Have you learned haskell from a guide of some kind first? Haskell isn't so good to learn by just doing, IMO.
23:57:10 <bollu> because the former lets you partially apply, send over to things like map and stuff
23:57:26 <bollu> kadoban: yeah, I have. I've read LYAH and bits and pieces of blog posts and things
23:57:36 <bollu> kadoban: but it never fell into a cohesive whole
23:57:44 <bollu> until I started *writing* it to solve problems
23:58:22 <kadoban> Yeah, my biggest complaint about LYAH is that it has no exercises (also I kinda hate the writing style, but that's just subjective and doesn't really hurt anything)
23:58:51 <bollu> kadoban: like, I'm aware of stuff that exists I guess - lens and arrows and the whole category theoretic thing, foldable/traversable, AMP, and all of that. But I've always felt that I've never understood haskell I guess. Using it is doing wonders for that
23:59:08 <bollu> kadoban: yeah, the writing is mildly annoying. I'd much rather it be straightforward
23:59:10 <kadoban> I'm not really sure I disagree or agree about the flexibility thing, maybe someone else will have a better idea how to think about that.
23:59:26 <bollu> the blog posts on FPComplete are nice though
23:59:36 <scutigera> kadoban: it is kind of annoying, but i have learned quite a bit from LYAH.  not enough i'm afraid...
23:59:56 <bollu> although I _never_ understand what edward kemmet's posts are about. Like, I'm lost three sentences in
23:59:57 <MrWoohoo> is there a cabal install 'kitchensink' option?
