00:07:41 * hackagebot invariant 0.1.2 - Haskell 98 invariant functors  http://hackage.haskell.org/package/invariant-0.1.2 (ryanglscott)
00:07:41 * hackagebot leksah 0.15.0.3 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.15.0.3 (HamishMackenzie)
00:08:29 * liste has a deja vu
00:12:36 * hackagebot bytestring-read 0.3.1 - fast ByteString to number converting library  http://hackage.haskell.org/package/bytestring-read-0.3.1 (HirotomoMoriwaki)
00:18:24 <Guest28233> hi
00:18:56 <Guest28233> i'm trying to run haskell on windows for the first time, and can not seem to run a function from system.process 
00:18:59 <Guest28233> x <- readProcess "dir" [] ""
00:19:13 <Axman6> do you get an error?
00:19:14 <Guest28233> gives me: dir: readProcess: does not exist (No such file or directory)
00:19:36 <Guest28233> couldn't find anyone else facing the same problem when i searched for it 
00:19:42 <Axman6> huh, no idea, I have no experience with windows
00:19:58 <Guest28233> me neither :)
00:20:00 <Guest28233> thanks anyway 
00:22:54 <liste> there's no program named `dir' in Windows
00:22:58 <liste> it's a shell builtin
00:23:35 <liste> Guest28233 you need to run "cmd.exe /c dir"
00:25:59 <Guest28233> that worked, thank you!
00:26:10 <liste> no problem (:
00:31:26 <lostincomputing> Hi
00:32:39 <lostincomputing> I was writing some code last night, using help from this list. I ended up using concatMap. The code works fine, but I don't understand the type signature:
00:32:41 <lostincomputing> concatMap :: (a -> [b]) -> [a] -> [b]
00:32:57 <jle`> lostincomputing: do you know what a (a -> [b]) is?
00:33:35 <lostincomputing> So, this bit: (a -> [b]) should take a type a and return a list of types b
00:34:30 <jle`> mhm. a value of type a, and a list of values of type b
00:34:42 <jle`> so concatMap takes an (a -> [b]), and an [a], and returns a [b]
00:34:58 <jle`> it takes a (a -> [b]), and a list of values of type a, and returns a list of values of type b
00:35:02 <sccrstud92> any suggestions for the best way, given s :: Set (Set a), to obtain s' such that s' contains all sets in s that do not have a subset in s?
00:35:40 <lostincomputing> :jle`: where  (a -> [b]) is a function
00:35:47 <jle`> lostincomputing: yes
00:35:49 <Fylwind> Axman6: that page looks fine to me (on Chromium x86-64 Linux)
00:35:53 <jle`> it takes a function and a list, and returns a new list
00:35:59 <jle`> we call these "higher order functions", and they're pretty common in haskell
00:36:04 <jle`> if you've ever seen functions like map or filter
00:36:14 <lostincomputing> yes, I'm familiar with map
00:36:32 <jle`> yeah, it might be worth comparing the types
00:36:35 <jle`> :t concatMap
00:36:36 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
00:36:40 <jle`> oops
00:36:46 <lostincomputing> map :: (a -> b) -> [a] -> [b]
00:36:47 <lostincomputing> (a -> [b]) -> [a] -> [b]
00:36:49 <jle`> concatMap :: (a -> [b]) -> [a] -> [b]
00:36:50 <jle`> yeah
00:36:57 <jle`> the difference is the functions they take
00:36:59 <lostincomputing> sorry: concatMap (a -> [b]) -> [a] -> [b]
00:37:05 <jle`> one takes an (a -> b), and the other takes an (a ->[b])
00:37:31 <lostincomputing> So, using the type signatures, the difference between map and concat map is that the latter uses a function that returns a list (of b's)
00:37:41 <georgy--> @src concatMap
00:37:41 <lambdabot> concatMap f = foldr ((++) . f) []
00:37:50 <jle`> lambdabot: yup :)
00:38:19 <lostincomputing> ok, that makes more sense - thanks
00:38:38 <georgy--> :t (\f xs -> concat (map f xs))
00:38:39 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
00:40:16 <jle`> np!
00:40:39 <georgy--> > concat [[1,2],[3,4]]
00:40:41 <lambdabot>  [1,2,3,4]
00:41:02 <georgy--> so it is just a map followed with concat
00:41:16 <sccrstud92> hence the name
00:41:27 <jle`> concatMap f = concat . map f    -- :3
00:41:32 <georgy--> yes, who would have thought!
00:43:20 <jle`> lostincomputing: note that becuase you can alwyas make a (a -> [b]) from any (a -> b).  and similarly you can implement concatMap using map :)
00:47:52 <jle`> s/because//
00:47:54 <jle`> that shouldn't be there, heh
00:50:15 -fractionuser(~fraction@host81-151-34-9.range81-151.btcentralplus.com)- Get your free webhosting. Use it for websites, or use it for storage. visit http://www.myfreehosting.org today to get started
01:01:12 <sccrstud92> if i wish to restrict a poset to only those elements that have no elements less than themselves, what is the best way to do this? is there a way better than O(n^2)?
01:03:40 <arw> maybe I understood that wrong, but wouldn't such a poset be limited to containing 1 or 0 elements?
01:06:20 <arw> sorry, i got that wrong. the set could contain an unlimited number of mutually non-comparable elements.
01:08:42 <arw> I guess in the general case it would have to be n^2, maybe in a special case of some very special partial order one could avoid trying to compare everything to everything.
01:12:56 <sccrstud92> after some research it appears i want to find the local minima of a poset
01:13:58 <arw> yes. but in case of your poset containing only at most one element of each comparable subset, your set of minima is the whole poset.
01:17:11 <sccrstud92> that is fine
01:17:34 <sccrstud92> my poset is a subset of a power set equipped with the subset relation
01:17:38 <sccrstud92> if that matters
01:23:34 <arw> if it were a power set instead of a subset of a power set it would be trivial.
01:26:27 <arw> in your case the only idea that comes to mind would be to "optimize" a bit: everything that doesn't contain a set is a minimum, so its in the result set and you can purge everything containing it.
01:26:39 <arw> but in the end it would still be n^2
01:27:14 <arw> maybe somebody else has more maths skills than me.
01:56:48 <bernalex> hm. I have a typeclass for things that may have a Coordinate. what's the easiest way to say that a Tile may be something that's an instance of that? like data Tile = Foo | Bar | Entity (Positionable a => a), if you get my meaning.
01:58:29 <jle`> bernalex: you are against parmaeterizing Tile by `a`?
01:58:44 <jle`> in that case it's really no different than storing a Coordinate itself under Entity
01:59:02 <bernalex> jle`: not really... I'm just looking at my alternatives. it's early in the morning. maybe I'm overlooking some other way. :)
01:59:08 <saulzar> bernalex, You can do that with existentials  e.g. forall a. Positionable a => a  ... but usually it's a sign you're doing something not quite right
01:59:19 <jle`> because there's no run-time type inspection, and if you have a Tile, the only thing you know about Entity is that it contains a Positionable a => a
01:59:39 <jle`> so you can only do things on it polymorphic over all positionable's
01:59:59 <jle`> in which case, might as well do Entity Coordinate, right?
02:00:10 <bernalex> one problem with parametrising it is that now I need to parametrise some other types too.
02:00:55 <bernalex> let me paste the code in question
02:03:05 <bernalex> jle`: http://lpaste.net/3378206827316510720
02:04:19 <bernalex> so parametrising Tile might make World a tad annoying.
02:04:24 <jle`> yeah, if that's the case, you might as well just have a container with a (Maybe Coordinate)
02:04:33 <jle`> if all you're ever going to have to do is ask for the coordinate
02:04:48 <jle`> this is indistuinguishable in utility from the existential option
02:04:52 <saulzar> bernalex, The problem with using the existential is that you can never get the Bomb back, only it's coordinate
02:05:02 <bernalex> saulzar: yeah
02:05:14 <jle`> and is really the only meaningful way to make something like this work
02:05:16 <liste> also, you already have the coordinate as a map key
02:05:30 <bernalex> what I want to write is getPositionable :: Positionable a => World -> Coordinate -> a
02:05:50 <jle`> bernalex: that means you want return-type polymorphism
02:06:01 <jle`> getPositionable has to be able to return *any* instance of Positionable
02:06:03 <bernalex> so I guess that should be my real question -- disregarding the Tile-amendment to include a Positionable at all.
02:06:08 <bernalex> jle`: yeah
02:06:09 <jle`> no matter what is contained in the World
02:06:15 <bernalex> yep
02:06:20 <jle`> like read :: Read a => String -> a
02:06:21 <saulzar> bernalex, A better option is probably to use a record  of functions ... e.g.    data Entity = Entity {  position :: Coordinate,  move :: Coordinate -> Entity }
02:06:42 <jle`> you can also make a sum type of all instance sof positionable if you can know them
02:06:52 <bernalex> saulzar: let me show you a bigger paste, and maybe you can make an even more informed observation
02:06:56 <jle`> data Positionable = PBomb Bomb | PPlayer Player
02:06:58 <jle`> etc.
02:07:07 <jle`> and then have your Tile contain a Positionable data type
02:07:23 <jle`> then you could do getPositionable :: World -> Coordinate -> Positionable
02:07:29 <jle`> and then pattern match on the constructor
02:08:31 <bernalex> saulzar: I edited http://lpaste.net/3378206827316510720 to include some other positionable things
02:08:55 <bernalex> maybe the Positionable typeclass is the Wrong Thing altogether.
02:09:25 <jle`>  very likely :)
02:09:36 <jle`> luke palmer's famous article is always passed around for things like this
02:11:03 <bernalex> jle`: I did consider a simple sum type at first. I'm beginning to think that was a better idea.
02:12:26 <jle`> you do run into the expression problem here, so it's not a perfect solution
02:12:36 <jle`> but it's the idiomatic way, i think
02:12:45 <frerich> Anti-Patter... oh, jle` mentioned that already.
02:12:57 * frerich turns off his alarm siren
02:14:58 <bernalex> jle`: but Tiles still don't know about Positionables.
02:15:33 <jle`> what do you mean?
02:15:39 <saulzar> bernalex, this is what I'd do http://lpaste.net/3378206827316510720
02:15:51 <bernalex> jle`: I have a Map Coordinate Tile, and all Positionables know what Coordinate they have but not the other way around.
02:16:14 <bernalex> saulzar: hm yes this is rather pleasing
02:16:15 <saulzar> bernalex, If I didn't take jle` 's solution which is fine too :)
02:18:15 <saulzar> bernalex, You have to be a wee bit careful with having the position in the Map and the Entity, too, I don't like to have the same information in two places
02:19:43 <lpaste> liste pasted ‚ÄúGADT tags‚Äù at http://lpaste.net/134531
02:19:51 <liste> bernalex would that one help?
02:19:57 <bernalex> saulzar: I agree
02:21:00 <bernalex> liste: I did consider something to that effect with GADTs, but it seemed heavy-handed to have a bunch of NonPositionables. idk.
02:25:26 <saulzar> bernalex, This question is a super common one, especially if you come from an OO background and you want to write a game or similar
02:26:11 <bernalex> saulzar: I know. I battled the same problems writing my first game in haskell.
02:26:29 <bernalex> and I still don't feel like lens is The Solution.
02:26:41 <bernalex> one thing that's semi-related that I really would like is first class record fields.
02:27:12 <liste> aren't lenses pretty much first-class record fields?
02:27:21 <liste> but generalized
02:27:49 <einojo> speaking of writing games in haskell, has anyone of you read Elise Huards "Game programming in Haskell"?
02:28:27 <saulzar> It's pretty handy for updating nested records, but the duplicate naming thing is still annoying. I've used Elm and I think I would take lenses over Elm's fancier record system any day
02:28:30 <bernalex> liste: it's a bit too much imo. too big a dependency, does too many things, etc. maybe there's some package that only that little bit that sort of emulates first class record fields, idk, haven't seen one.
02:29:45 <bernalex> IDK, I just feel that the promise of Lens as well as the promise of FRP both have fallen a bit short for me in practice. i.e. I don't like the frameworks that exist (that I have tried) very much.
02:30:13 <liste> is lens-family too much also?
02:30:30 <saulzar> bernalex, You can use lens-family, it's got basically the basics and that's it - or you can use lens and ignore most of it like I do
02:30:54 <bernalex> liste: I have not used lens-family a lot. I should look more into it.
02:31:44 <tempay> I need some advice. I'm trying to use a package (which should be stable) from hackage. cabal install gives an error, building from source gives the same error, I can't find that error mentioned anywhere online
02:31:57 <saulzar> It's basically just the basics of lens, without all the advanced stuff
02:32:05 <tempay> Do I submit a github issue, or what?
02:32:09 <bernalex> saulzar: your Entity DT won't work too hot. Characters are Entities but not Timers.
02:32:22 <saulzar> Hm..
02:33:03 <saulzar> Can't you use a Maybe on the timer field?
02:33:12 <bernalex> saulzar: but it's a bit dumb
02:33:23 <bernalex> Characters will require several new fields which then also would be Maybes
02:33:37 <saulzar> You don't need to add it to Character, just to Entity..
02:33:53 <bernalex> maybe I don't even need getPositionables, heh.
02:34:09 <bernalex> saulzar: sorry I meant that introducing Characters to Entity, means Entity needs several new fields from Character.
02:34:16 <saulzar> Entity just provides the external interface, you can have whatever you like internally 
02:34:27 <bernalex> maybe I should take another step back
02:34:31 <bernalex> what I *really* want to write
02:34:40 <bernalex> is basically blow :: Positionable a => Bomb -> World -> [a]
02:34:52 <liste> tempay what error?
02:35:03 <liste> it could be also some non-haskell dependency problem
02:35:16 <saulzar> Well, you can also provide 'cast' functions ... or a union like jle`  suggested    e.g.     character :: Maybe Character
02:35:20 <bernalex> which takes a Bomb, checks its effect radius, checks all Coordinates within it in the World, and returns all Positionable/Tangible/Whatever objects
02:35:37 <bernalex> maybe I can do this without a getPositionable altogether?
02:36:15 <tempay> liste: "src/Data/Vector/Heterogenous.hs:133:7:    Not in scope: type constructor or class `KnownNat' src/Data/Vector/Heterogenous.hs:137:32: Not in scope: `natVal'"
02:36:28 <liste> tempay what is your ghc version?
02:36:46 <tempay> liste: 7.6.3
02:38:15 <saulzar> bernalex, Could be - now you know the options anyway, leave it to you to figure out which/combinations of those can work for your game :)
02:38:37 <saulzar> bernalex, But sounds like a good idea, given you know the position from the Map anyway
02:38:59 <bernalex> saulzar: yep thanks for your help. jle` too!
02:40:12 <liste> tempay no idea then, maybe you should submit the issue
02:41:16 <liste> is your base >= 4.7.0.0 ?
02:42:05 <tempay> liste: I actually don't know how to check
02:43:25 <liste> cabal sandbox hc-pkg list |grep base-
02:44:15 <tempay> aha, base-4.6.0.1
02:44:29 <jle`> 7.6 comes with base 4.6, i believe...
02:44:35 <jle`> 4.7 is with ghc 7.8
02:44:36 <tempay> liste: is there any easy way to update? thought that was paired with ghc
02:44:45 <tempay> so I need to update ghc?
02:44:59 <liste> I guess
02:45:05 <tempay> been meaning to anyway
02:45:13 <jle`> yeah, 7.6 is getting a bit ancient
02:45:19 <tempay> that's a good lead, thanks for your help
02:45:29 <liste> but heterogenous-vector has incorrect version constraints anyway
02:45:32 <tempay> is there an easy way to install it on ubuntu? last i checked apt-get doesn't work
02:45:51 <liste> tempay try halcyon
02:45:55 <jle`> tempay: yeah, there's the hrv ppk's
02:46:05 <liste> (it's not supported on my system though, so I use nix)
02:47:08 <jle`> sorry, hvr
02:47:39 <jle`> @google hvr haskell ubuntu
02:47:41 <lambdabot> https://launchpad.net/~hvr/+archive/ubuntu/ghc
02:48:22 <tempay> awesome thanks :)
02:48:27 <jle`> np!
02:49:40 <xandaros> Ubuntu is still on GHC 7.6?
02:50:04 <liste> yeah
02:51:01 <bergmark> ubuntu usually lags behind, since the release schedule's dont' line up i suppose
02:51:21 <xandaros> I know they lag behind, but I didn't know they lag behind years lol
02:51:56 <jle`> surprisingly 7.8 has barely been out for a year, heh
02:52:15 <jle`> but it feels like it's been ages
02:53:15 <xandaros> a year is still a long time, considering they release a new version ever 6 months
02:54:02 <xandaros> I'm glad I moved away from Ubuntu. I get all the new stuff now (arch linux)
02:54:15 <maerwald> xandaros: including the latest bugs!
02:54:23 <xandaros> true, but it is worth it :)
02:54:40 <xandaros> for a desktop, anyway
02:54:59 <tempay> managing packages like this has always been my achilles heel, sorry if this is a dumb questions
02:55:17 <tempay> if i'm using 7.6 now and I update, how do i replace the old one?
02:55:28 <maerwald> xandaros: there are rolling release distros that still have true "stabilization" policy/workflow. arch just chose not to do it, unfortunately
02:55:39 <Soft> How should I combine multiple wai applications?
02:55:44 <tempay> they seem to both be installed, and i don't want to uninstall the first one for fear of losing everything that depends on it, e.g. xmonad
02:55:53 <Soft> I am trying to fit wai-app-static into my project
02:56:06 <jle`> tempay: they can all co-exist without any problems
02:56:20 <jle`> whatever one is the first one on your $PATH is what is used by cabal, etc.
02:56:34 <jle`> so you can switch which one is active by just switchig out $PATH
02:56:56 <tempay> so I need to find the install directories and swap the positions
02:57:17 <jle`> yeah, your just add the one you want to the beginning
02:57:17 <Soft> there also exists wai-middleware-static but it doesn't seem to support default files for directories
02:57:27 <tempay> thanks again
02:57:29 <jle`> the install directory should be on the package website
02:58:56 <hexagoxel> xandaros: in retrospect, arch's quick upgrade was mildly annoying for me, because all the development tooling (hlint, hoogle, pointfree, ..) did not compile with ghc-7.10
02:59:43 <hexagoxel> and i still use ghc-7.8 for many projects, because dependencies
03:02:22 <bergmark> right now we are in this awkward transition period where it's not clear which GHC version is easier to use
03:02:43 <bergmark> lots of new packages without 7.8 support are popping up :/
03:02:48 <Soft> hmmm maybe i could make the wai-middleware-static work using policies
03:30:28 <muller> how is that I am able to pass a value of "ActionT m a" as the second argument to a function with signature,  "Path xs -> Data.HVect.HVectElim xs (ActionT m ()) -> SpockT m ()"?
03:33:15 <liste> muller type HVectElim ([]¬†*) a = a
03:33:22 <liste> in hvect's haddock
03:34:08 <liste> it's type family magic (:
03:34:32 <pacak> liste: Type families are nice and fluffy.
03:34:50 <muller> liste, mm..what is it called. Should I know about it? (new to haskell, btw)
03:35:34 <muller> list, what is it supposed to do?
03:35:42 <liste> muller it's called type families, a GHC extensions, in this case it's used as a type-level function
03:36:08 <liste> GHC extension*
03:36:50 <muller> liste, is it something like kind?
03:37:16 <muller> liste, type of types?
03:37:25 <liste> it uses kinds, but not quite
03:39:05 <liste> "families are used to define overloaded data in the same way that classes are used to define overloaded functions" -- https://wiki.haskell.org/GHC/Type_families
03:40:56 <liste> it's a (more powerful?) alternative to multi-param type classes
03:43:50 <liste> I mean MPTCs coupled with FunctionalDependencies
03:44:05 <muller> liste, Mmm..
03:47:22 <muller> liste, this is the issue I am having http://lpaste.net/134534
03:48:26 <liste> what's the error?
03:50:48 <muller> liste, oops, sorry. here it is http://lpaste.net/134535
03:51:40 <lostincomputing> very easy q. Trying to use the Data.Set module. I have import Data.Set (Set) in the first line
03:52:02 <lostincomputing> I want to turn a list into a set:
03:52:32 <lostincomputing> Set.fromList isn't right - but I'm not sure what is
03:52:53 <bergmark> lostincomputing: why is it not right?
03:53:02 <lostincomputing>  Not in scope: `Set.fromList'
03:53:25 <Maxdamantus> Data.Set.fromList
03:53:25 <bergmark> oh right, because you are only importing the type unqualified
03:53:40 <Maxdamantus> or just fromList, assuming it doesn't clash.
03:54:10 <bergmark> lostincomputing: usually I do `import Data.Set (Set) \n import qualified Data.Set as Set'
03:54:27 <bergmark> then the type is available as just `Set' and everything else as `Set.x'
03:55:30 <lostincomputing> Thanks. Import now working. New errors!
03:55:32 <lostincomputing> No instance for (Ord Treatment)
03:55:32 <lostincomputing>       arising from a use of `Set.fromList'
03:55:32 <lostincomputing>     Possible fix: add an instance declaration for (Ord Treatment)
03:55:32 <lostincomputing>     In the expression: Set.fromList
03:55:32 <lostincomputing>     In the expression:
03:55:33 <lostincomputing>       Set.fromList $ concatMap (\ (a, b) -> [a, b]) allTreatNest
03:57:12 <bergmark> lostincomputing: Set uses a binary tree as its internal representation so it needs to be able to order elements
03:59:04 <bergmark> lostincomputing: so you need to add one, you can probably just derive it. Note that there's also a HashSet in unordered-containers which requires the elements to hashable instead of sortable
03:59:25 <lostincomputing> Ok, added some TC declarations and fixed
04:00:08 <int-index> Axman6: You asked about people's opinion about ether. Author here. Did you get any answers? (I'm interested too)
04:01:01 <liste> muller does it work if you leave the readSession out?
04:01:11 <muller> liste, yes
04:02:17 <justinting> Hi! First time ever on an IRC, so apologies if I'm not using it propertly :P I'm running XMonad on Arch, and am trying to move things out of .xinitrc and into .xmonad/xmonad.hs instead, particularly dzen2, conky, trayer, and all the apps I want to launch into trayer - my xmonad.hs currently looks like this (https://github.com/jyting/dotfiles/blob/master/.xmonad/xmonad.hs) - it's currently only putting 
04:02:23 <justinting> trayer on one screen, the workspace list of dzen isn't showing up anywhere, and the conky info is all covered by whatever window is open on any workspace (on both 2 monitors and one). How should I go about getting it working properly, starting with showing workspaces and having trayer show in all workspaces?
04:03:47 <bernalex> justinting: #xmonad
04:08:44 <liste> muller try session <- (id :: Maybe () -> Maybe ()) `fmap` readSession
04:09:03 <muller> liste, ok
04:09:29 <liste> or (id :: () -> ())
04:11:01 <muller> first one http://lpaste.net/134536
04:11:07 <muller> liste, first one http://lpaste.net/134536
04:11:46 <muller> liste, second one http://lpaste.net/134537
04:12:54 <liste> can you show the whole main.hs ?
04:14:16 <muller> liste, http://lpaste.net/134538
04:17:11 <muller> liste, this is a sample code using the Spock framework, which I am using. https://github.com/agrafix/funblog/blob/master/src/Web/Blog.hs
04:17:29 <muller> liste, but I just want to undersand why my code is not compiling.
04:22:46 <liste> muller you're using SpockT, not SpockM
04:23:00 <liste> SpockT doesn't have session info
04:24:28 <liste> so you can't use readSession
04:25:01 <muller> muller, Oh. I see. But why does it not compile. From the type checker's point of view.
04:25:08 <muller> liste, , Oh. I see. But why does it not compile. From the type checker's point of view.
04:25:51 <liste> well, it doesn't compile because it can't work :)
04:25:58 <liste> IO has no session info
04:27:05 <liste> readSession expects to be run on a WebStateM but you run it on IO
04:27:30 <liste> (or try to, and GHC won't let you)
04:27:47 * hackagebot delta 0.1.0.0 - A library for detecting file changes  http://hackage.haskell.org/package/delta-0.1.0.0 (muzzle)
04:29:53 <muller> liste, Does it not work because ActionT is not a Monad?
04:31:37 <liste> muller it doesn't work because ActionT IO /= ActionT WebStateM x y z
04:32:04 <liste> both are Monads
04:34:49 <muller> >>= :: m a -> (a -> m b) -> m b, so shouldn't I be able to use it in a do block since a = WebState x y z and b = IO?
04:35:24 <liste> muller what's m?
04:42:26 <liste> hint: in readSession's type signature, `a' is `sess'
04:42:52 <liste> and in html's signature, `b' is `a'
04:43:04 <liste> readSession :: Spock conn sess st sess
04:43:13 <liste>                        ^- there's your `a'
04:43:17 <liste> srry
04:43:23 <liste>                                            ^- there
04:43:28 <liste> the last `sess'
04:45:27 <int-index> I've added a few modules to my package, retaining full backwards compatibility. Should I bump it from 0.2.0.0 to 0.3.0.0 or 0.2.1.0?
04:47:48 * hackagebot delta 0.1.0.1 - A library for detecting file changes  http://hackage.haskell.org/package/delta-0.1.0.1 (muzzle)
04:50:10 <bergmark> int-index: 0.2.1.0, non-breaking addition
04:51:06 <hexagoxel> would it even be a non-breaking addition when you do not expose anything new?
04:51:37 <bergmark> nope, it's only wrt the public interface
04:52:49 * hackagebot murmur3 1.0.0 - Pure Haskell implementation of the MurmurHash3 x86_32 algorithm.  http://hackage.haskell.org/package/murmur3-1.0.0 (PhilippeLaprade)
04:57:04 <merijn> yes
04:57:16 <merijn> because you might import new typeclasses
04:57:49 * hackagebot snmp 0.2.0.0 - API for write snmp client.  http://hackage.haskell.org/package/snmp-0.2.0.0 (chemist)
04:58:00 <hexagoxel> +instances ?
05:01:49 <merijn> That's what I meant, but yeah, both
05:12:49 * hackagebot agentx 0.2.0.0 - AgentX protocol for write SNMP subagents  http://hackage.haskell.org/package/agentx-0.2.0.0 (chemist)
05:15:40 <gleber`> Is there an working alternative to hackage/plugins somewhere? hackage/hint doesn't really work for me, since code should be compiled and performance is important 
05:25:34 <gleber`> Is there an working alternative to hackage/plugins somewhere? hackage/hint doesn't fit the bill, since evaluated code should be compiled and performance is important (Think of a SQL-to-Haskell translator at heart of a query engine)
05:26:15 <gleber`> Or, to be more precise, an exercise at creating proof of concept
05:27:59 <hodapp> if you're needing to generate Haskell, does TH fit?
05:28:16 <merijn> hodapp: Not if he wants to do the generation at runtime
05:28:22 <hodapp> ahhh
05:28:49 <gleber`> correct
05:28:56 <dramforever> looks like what ghc api would fit, not sure if easy to use, though
05:30:17 <gleber`> dramforever: it seems like hackage/plugins did exist for a reason to simplify that API...
05:30:52 <dramforever> gleber`: well, I'm not really sure what's wrong with hackage/plugins
05:30:59 <dramforever> too complex?
05:31:12 <merijn> Might have bitrotted
05:31:25 <merijn> Last version was from 2010 and I doubt dons has plans to work on it again
05:31:29 <gleber`> dramforever: yes, it doesn't work with 7.8
05:31:39 <merijn> Nowadays he only works on dramatic photo's of sunsets :p
05:31:42 <gleber`> and there are comments somewhere that it is considered broken now
05:31:45 <dramforever> okay, so I think ghc api must work
05:31:52 <gleber`> it segfaults on me
05:32:07 <gleber`> Looks like GHC API is the way to go
05:32:12 <dramforever> merijn: I think I "heard" "dram-atic" :p
05:32:42 <dramforever> oh yes I have a question:
05:33:09 <dramforever> gtk doesn't compile here, does it worth it to report as a bug (or even look for existing bugs)?
05:33:20 <dramforever> log is on the way...
05:33:38 <merijn> dramforever: That depends on your definition of worth :p
05:33:53 <dramforever> merijn: does it help me install gtk?
05:34:27 <dramforever> well, to be precise, glib failed to install
05:34:34 <merijn> I've given up on writing GUIs on any platform/in any language, only pain...
05:34:51 <dramforever> yeah
05:34:54 <merijn> Well, maybe I'll try OSX and Swift at some point, that seems like it might be sufficiently polished, but anything else...
05:34:56 <dramforever> couldn't agree more
05:35:16 <dramforever> merijn: most of "GUI programs" I've ever wrote use the browser
05:35:37 <merijn> dramforever: I'm planning to play with Ur/Web for that soon
05:36:05 <dramforever> I might consider ghcjs
05:36:21 <dramforever> looks awfully like emscripten
05:36:47 <dramforever> which, if you don't know, is llvm -> js
05:37:14 <merijn> My main problem is that every time I work on my website I get stuck with the design of the page, since it's hard to design without content, but I'm never motivated to write stuff when I have no place to put it :p
05:37:18 <merijn> Catch 22 :p
05:37:43 <maerwald> merijn: cat pictures, ads and stuff?
05:38:12 <merijn> maerwald: No ads, ads are for people who'd sell their sense of design and awesomeness for pitiful money
05:38:30 <merijn> It's not like hosting a website without adds will bankrupt me...
05:38:41 <dramforever> merijn: I often spend an hour writing css, only to discover that I delete the css file and decide that the default is the best
05:38:54 <dramforever> happens pretty often
05:40:41 * dramforever is trying stackage
05:42:55 <dramforever> wow stackage nightly contains lens
05:42:59 <dramforever> amazing!
05:47:51 * hackagebot ether 0.2.1.0 - Monad transformers and classes  http://hackage.haskell.org/package/ether-0.2.1.0 (int_index)
05:51:22 <minozake> Oooo.  Stackage looks relevant to my interests.
05:55:32 <muller> liste, power went off early. That is why I stopped responding earlier. I read your messages from chat logs. Would you be able to continue?
06:00:56 <gleber`> Does anyone know for sure if "compileExpr" function from GHC API actually does compilation (and not just interprets code)?
06:05:22 <VoltzLive> So, I'm toying around with implementing a state monad and I was wondering two things:
06:05:50 <VoltzLive> 1: Is there an easy way to use a tuple as a key-value pair
06:06:11 <VoltzLive> Wait
06:06:13 <VoltzLive> I don
06:06:20 <pacak> :t lookup
06:06:21 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
06:06:22 <VoltzLive> I don't need the second thing..
06:06:47 <VoltzLive> Alright That makes things so much easier! =D
06:06:59 <srhb> But you should probably use Map for that.
06:07:10 <VoltzLive> I could
06:07:24 <dramforever> VoltzLive: 2. [?]
06:07:40 <VoltzLive> I realized I didn't need it
06:08:08 <dramforever> :)
06:23:21 <muller> can someone break this error down for me. http://lpaste.net/134535?
06:31:14 <srhb> muller: I think it would be easier with more context. That entire action/function for instance.
06:31:30 <srhb> I'm also not familiar with HVect but I'm sure we can figure it out.
06:31:45 <srhb> (This might be something simple like a missed lift...)
06:32:52 <lostincomputing> Is there anyway I can print the type-signature of something in a do-block?
06:33:03 <lostincomputing> I have:
06:33:03 <lostincomputing> main = do
06:33:04 <lostincomputing> 	print allTreat
06:33:04 <lostincomputing> 	print treatPairMap
06:33:23 <lostincomputing> I am getting errors on the second print statement, but would like to see the type of it
06:33:25 <muller> srhb,  http://lpaste.net/134534
06:34:08 <srhb> lostincomputing: That sounds unlikely. But you can use typed holes, I think even on signatures in 7.10
06:34:16 <srhb> lostincomputing: So print treatPairMap :: _
06:34:22 <srhb> Notice the underscore
06:34:24 <lpaste> paolino pasted ‚Äúpolymorphism‚Äù at http://lpaste.net/134541
06:34:34 <muller> srhb, what I don't get is readsession is of type ActionT (WebStateM conn sess st) and html is of type  ActionT m a..
06:35:04 <muller> srhb, so shouldn't I be able to chain them in do?
06:35:11 <srhb> muller: What is the type of get?
06:35:23 <paolino> hello, anybody could help me making http://lpaste.net/134541 compile, please ?
06:35:26 <merijn> lostincomputing: If you (in ghc 7.8 or 7.10) type a variable starting with an underscore (or just an underscore) GHC will print an error listing it's type
06:35:51 <muller> srhb,  Monad IO m => Path xs -> Data.HVect.HVectElim xs (ActionT m ()) -> SpockT m ()
06:36:27 <merijn> lostincomputing: One neat trick is "print (treatPairMap `asTypeOf` _)"
06:36:46 <merijn> I wonder, does lambdabot have holes?
06:36:47 <lostincomputing> main = do
06:36:47 <lostincomputing> 	print allTreat
06:36:47 <lostincomputing> 	print treatPairMap :: _
06:36:49 <arw> paolino: f :: a -> IO a from a quick glance without having actually tried to compile it.
06:36:49 <merijn> > _ :: Int
06:36:50 <lambdabot>      Found hole ‚Äò_‚Äô with type: Int
06:36:51 <lambdabot>      In the expression: _ :: Int
06:36:51 <mniip> what would be an elegant way to count the amount of True in a [Bool]?
06:36:58 <lostincomputing> parse error on input `_'
06:37:09 <merijn> > 'c' `asTypeOf` _
06:37:11 <lambdabot>      Found hole ‚Äò_‚Äô with type: Char
06:37:11 <lambdabot>      In the second argument of ‚ÄòasTypeOf‚Äô, namely ‚Äò_‚Äô
06:37:11 <lambdabot>      In the expression: 'c' `asTypeOf` _
06:37:27 <merijn> lostincomputing: Right, srhb was thinking of PartialTypeSignatures which aren't in a released version yet
06:37:36 <srhb> Oh :(
06:37:41 <paolino> arw, the problem is g is not polymorphic
06:37:44 <geekosaur> paolino, I think you need an explicit type annotation on g?
06:37:44 <srhb> Sorry about that.
06:37:47 <merijn> But on the brightside, my trick works :)
06:37:52 <geekosaur> because lambdas are monomorphic by default
06:38:07 <arw> paolino: ah, right, I see.
06:38:08 <geekosaur> (and `g <- f` turns into `f >>= \g ->`
06:38:12 <lostincomputing> print (treatPairMap `asTypeOf` _)
06:38:12 <lostincomputing> Pattern syntax in expression context: _
06:38:16 <absence> mniip: "length . filter id" perhaps?
06:38:22 <merijn> lostincomputing: Which GHC version?
06:38:27 <geekosaur> lostincomputing, your ghc is too old
06:38:31 <paolino> geekosaur, where ? in the application ?
06:38:41 <geekosaur> no, it's too late by then
06:39:11 <lostincomputing> Ah, ok!
06:39:24 <merijn> lostincomputing: Typed holes were first added in GHC 7.6 :)
06:39:35 <lostincomputing> GHC 7.6.3
06:39:39 <geekosaur> I... think you need ScopedTypeVariables extension (because pattern signatures was folded into it) and then (g :: a -> a) <- f
06:39:44 <merijn> lostincomputing: heh
06:39:49 <geekosaur> 7.6? pretty sure typed holes are 7.8
06:39:55 <merijn> oh, wait, yes
06:39:58 <merijn> 7.8 >.>
06:40:16 <merijn> That's what I get for being bleeding edge, my sense of time is one version ahead :p
06:40:29 <paolino> geekosaur,   g  <- f :: IO (a -> a) is not doing
06:40:51 <paolino> ah on the left
06:40:51 <srhb> muller: OK, so does your do block have a type of HVectElim ... ?
06:41:57 <geekosaur> there may be a cleaner way to do that that I'm not thinking of immediately; still working on first coffee >.>
06:42:04 <muller> srhb, No. SpockT IO ()
06:42:21 <srhb> muller: I meant the inner one. But no, it doesn't, as far as I can see.
06:42:28 <paolino> geekosaur,     Couldn't match expected type ëaí with actual type ë[Char]í
06:42:51 <muller> srhb, if I remove the readSession line, it works.
06:42:53 * hackagebot quickcheck-simple 0.1.0.0 - Test properties and default-mains for QuickCheck  http://hackage.haskell.org/package/quickcheck-simple-0.1.0.0 (KeiHibino)
06:42:58 <geekosaur> crud. I'm not sure then
06:44:22 <paolino> my problem is I cannot call f twice because it has side effects
06:44:41 <maerwald> paolino: side effects?
06:45:01 <geekosaur> now I wonder if this is some rank-N thing
06:45:06 <geekosaur> not that it should be
06:45:09 <geekosaur> I think
06:45:13 <paolino> maerwald, it reopen a database connection
06:45:26 <maerwald> paolino: is that fact represented by the type?
06:45:40 <maerwald> e.g. IO or whatnot
06:45:55 <paolino> IO
06:46:01 <maerwald> then it's not a side effect
06:46:04 <maerwald> it's an *effect*
06:46:20 <geekosaur> paolino, that does not sound to me like something that should be done with an IO (a -> a) or similar
06:46:28 <geekosaur> maybe a -> IO a
06:47:05 <paolino> geekosaur, its IO (Get a -> SomeMonad a)
06:47:26 <paolino> where Get is a gadt
06:47:49 <geekosaur> that still sounds wrongish
06:48:39 <geekosaur> IO (Get a -> SomeMonad a) sounds like a computation that determines which (Get a -> SomeMonad a) based on the result of an IO action
06:49:10 <paolino> why? I open the database once and give you a function to query it
06:49:17 <geekosaur> not a computation which may need to do IO while evaluating (Get a -> SomeMonad a)
06:50:37 <paolino> IO (Get a -> IO a) if you prefer
06:51:19 <geekosaur> mrrr. the usual way to do that is that your SomeMonad is MonadIO and then open gives you a SomeMonad (), with other operations in the SomeMonad.
06:52:25 <geekosaur> if you really need to do it that way (not recommended; I think you end up needing to ensure it's only used while the database is open yourself, you can't use the type system to track it for you) then the result should be a record type and you can specify the correct polymorphic type
06:52:49 <geekosaur> as a `query` field or whatever in the record
06:53:47 <paolino> uh, then I cannot change the Get protocol without updating that record
06:53:54 <k0ral> Hello
06:54:02 <liste> muller the problem isn't between readSession and html, it's your return type
06:54:02 <phaazon> hey, is there a changelog for GHC versions?
06:54:18 <liste> there's no WebStateM in your return type, so readSession doesn't work
06:54:18 <merijn> phaazon: The release notes?
06:54:31 <phaazon> yeah
06:54:36 <liste> html doesn't care about WebStateM
06:54:39 <liste> so it works
06:54:49 <merijn> phaazon: No, that was my answer, not a question for clarification :p
06:55:06 <phaazon> ah
06:55:08 <phaazon> :D
06:55:13 <phaazon> I'm looking for them then
06:55:23 <phaazon> found them.
06:55:25 <phaazon> thanks
06:55:44 <geekosaur> paolino, either you have left out a lot of necessary information, or you're building a Rube Goldberg device to do something that can probably be done in a simpler way. Or quite possibly both
06:56:30 <k0ral> is there a generic way to define a partial data type; e.g. : I have "data A = A Type1 Type2", I want to get something like "data PartialA = PartialA (Maybe Type1) (Maybe Type2)" without defining it manually (I want to apply this process to many distinct types)
06:57:26 <merijn> k0ral: What would "doing that generically" even mean?
06:57:33 <k0ral> I suspect this can be done using TypeFamilies and Generics, but I'm not sure and I have no clue where to begin
06:57:42 <phaazon> k0ral: see this
06:57:54 <phaazon> data A f = A (f Type1) (f Type2)
06:57:59 <phaazon> your first A is A¬†Identity
06:58:02 <k0ral> merijn: without writing them myself for each type
06:58:03 <phaazon> the second one is A Maybe
06:58:52 <merijn> k0ral: My point was that this doesn't seem like a very general operation/definition, I mean, what's the pattern?
06:59:08 <phaazon> type PartialA = A Maybe
06:59:28 <phaazon> but yeah, you need a constraint, like Functor for instance
06:59:40 <k0ral> merijn: I guess that would be a type family Partial such that it maps a type A to its partial equivalent PartialA, forall A
07:00:09 <merijn> phaazon's suggestion seems the only sensible interpretation of what you want for me
07:00:20 <k0ral> merijn: then you could define f :: Partial a -> Maybe a to check whether your partial object is completely filled
07:00:58 <merijn> You'd still have to write the boiler plate for that
07:01:06 <k0ral> rationale: I am parsing input incrementally, and I want to build partial instances of some data types
07:01:08 <merijn> Unless you use TH/generics to generate it
07:01:26 <phaazon> k0ral: eeeew
07:01:28 <phaazon> use a Monoid for that
07:01:33 <k0ral> phaazon: that doesn't save me the trouble of writing data A f = A (f Type1) (f Type2) for each type
07:02:13 <k0ral> phaazon: I can't: in the end, the resulting type has no "zero"
07:02:18 <k0ral> it's a semigroup, if you will
07:02:24 <paolino> geekosaur, it happens often to me. The  http://lpaste.net/134541 was more general and should be possible to put a point on it
07:02:26 <phaazon> sure then
07:02:55 <k0ral> that's the point: I want to ensure in the end that everything is filled, but I have to store the incremental input and I don't want to roll a custom partial data type for each distinct case
07:03:15 <phaazon> if for input
07:03:39 <phaazon> I'd tend to build a Parsed type that accumulate with (<>), and turn that into Maybe a later on
07:03:46 <phaazon> accumulates*
07:05:24 <k0ral> phaazon: it looks to me that your "Parsed" is my "Partial" :)
07:06:40 <k0ral> so, looks like I'm going to write the boilerplate anyway, thanks anyway
07:06:51 <paolino> geekosaur, I will ask in cafË, thanks for help 
07:06:53 <k0ral> hmmmm, ugly repetition...
07:07:08 <phaazon> k0ral: maybe you can do that with Generics
07:07:28 <phaazon> something like
07:07:39 <k0ral> phaazon: yeah I'm wondering if this is possible, but I have no experience using Generics
07:07:51 <phaazon> class (Generic a) => Partial a where unpartial :: Partial a -> Maybe a
07:08:06 <phaazon> and build Partial a by inspecting K, M1 and so on
07:08:40 <k0ral> my question is: are you confident this will work ? if yes, then I'll invest some time in figuring it out
07:15:05 <minozake> Is there a way to declare a type like `type Foo = String', but if I pass Foo to a function `bar :: String -> a' it will error because Foo wouldn't be equivalent to String, but it would be possible to cast in cases where I would like to use it as String?
07:15:30 <merijn> minozake: newtype
07:15:33 <Iceland_jack> minozake: Use a 'newtype Foo = MkFoo String'
07:16:09 <minozake> Ah, newtype.  Thank you, merijn and Iceland_jack.
07:16:10 <Iceland_jack> I wouldn't recommend the 'cast' but that is doable
07:16:32 <merijn> I think when minozake asked for cast just pattern matching would be sufficient
07:21:23 <geekosaur> huh, guess my thought about needing rank-n was correct
07:21:37 <merijn> Ok, so I have a class with a method that can be implemented in two ways, one requires that the type is an instance of another class and one "generic" implementation that is less efficient. I don't suppose there's a way to selectively override the implementation in the more efficient case?
07:22:05 <geekosaur> merijn, that sounds vaguely like a RULE?
07:22:26 <merijn> geekosaur: Right, but I don't know if you can have a rule that depends on a class instance existing?
07:22:34 <geekosaur> trying to do it with typeclass machinery is risky at best
07:23:08 <geekosaur> afaik rules fire based on type, so the rule for the optimized one would specify a type with the typeclass constraint
07:23:24 <merijn> Lemme try #ghc
07:24:40 <Twey> minozake: You can use record syntax to autogenerate the function Foo ‚Üí String: newtype Foo = MkFoo { unFoo ‚à∑ String } gives you MkFoo ‚à∑ String ‚Üí Foo and unFoo ‚à∑ Foo ‚Üí String
07:24:59 <Twey> So unFoo is your ‚Äòcast‚Äô
07:29:50 <quchen2> Is :sprint broken? When I enter "let x = 1" in GHCi, then "x" to print the "1" and then ":sprint x" yields "x = _". Shouldn't it be "x = 1"?
07:30:26 <c_wraith> quchen2: try "let x = 1 :: Int"
07:30:37 <quchen2> Aaaah.
07:30:40 <c_wraith> quchen2: I think the polymorphism is why it's not evaluated
07:30:45 <quchen2> Yes, that makes sense.
07:30:58 <quchen2> Although I would expect the DMR to kick in on the top level. But maybe I've disabled it in the config or something.
07:31:11 <c_wraith> it's disabled by default in ghc 7.8+, iirc
07:31:18 <mauke}> I don't think ghci counts as top level
07:31:23 <mauke}> isn't it effectively a do block?
07:32:10 <c_wraith> the DMR still used to apply in ghci
07:32:22 <c_wraith> before it was disabled by default
07:35:30 <japesinator> is there a non-infix (=<<)?
07:35:40 <japesinator> or even a non-infix (>>=)?
07:35:43 <c_wraith> not in any standard use
07:35:54 <minozake> Twey: You just blew my mind.  I love how the syntax just fits with how I wanted it to fit.
07:37:10 <ClaudiusMaximus> > (+) 1 2 -- japesinator, you can use operators prefix if you surround them in (), you can use functions infix if you surround them in ``
07:37:12 <lambdabot>  3
07:42:56 * hackagebot aws-dynamodb-conduit 0.1.0.0 - Conduit-based interface for AWS DynamoDB  http://hackage.haskell.org/package/aws-dynamodb-conduit-0.1.0.0 (srijs)
07:43:21 <srhb> japesinator: How about (=<<) ? :-)
07:45:58 <VoltzLive> nth element in a tuple?
07:46:48 <osa1> does anyone know if hslogger is thread-safe?
07:47:14 <mauke}> VoltzLive: no, thanks
07:48:25 <clrnd> so, haskell, cool language right? monads and stuff
07:48:34 <maerwald> clrnd: huh?
07:48:49 <clrnd> maerwald, just my oppinion man, chill
07:52:18 <ion> I don't think you're likely to find fans of that language on a channel like this.
07:52:49 <merijn> Inheritance! Subtyping! Objects!
07:53:02 <matsuura> I wouldn't call my self a fan, but.. I'm using Haskell much more recently.
07:53:51 <lpaste> paolino annotated ‚Äúpolymorphism‚Äù with ‚Äúpolymorphism (annotation)‚Äù at http://lpaste.net/134541#a134543
07:54:19 <paolino> geekosaur, it was needing rank-n as you guessed, I don't get how it works actually but it does without inserting constrains (Show) on 'a' in the wrapping newtype for later use. 
07:58:51 <Twey> paolino: I think you only need Rank2Types there
08:00:58 <paolino> Twey, sure. Are those different , when they intersect ?
08:03:00 <ion> I'm under the impression that Rank2Types just enables RankNTypes in GHC.
08:03:22 <c_wraith> ion: you're correct
08:03:35 <c_wraith> PolymorphicComponents is also the same extension
08:03:43 <c_wraith> Even though it's even more limited, conceptually
08:04:50 <Twey> Oh, really?  I guess I'll just use RankNTypes from now on, then
08:04:55 <c_wraith> geekosaur: steering people away from ImpredicativeTypes?  It's almost like that extension doesn't actually work!
08:05:22 <merijn> Twey: Yeah, conceptually they're different in that Rank2Types can, theoretically, be typechecked in a decidable manner
08:05:42 <merijn> Twey: But GHC doesn't do decidable typechecking for Rank2Types either, so it just enables RankN
08:05:52 <c_wraith> err.  they're all decideable for checking
08:05:59 <c_wraith> It's inference for which they aren't decideable
08:06:01 <geekosaur> mrr? I didn't steer anyone away from it, although I am aware that it's never worked very well
08:06:03 <merijn> eh, right
08:06:09 <merijn> s/typechecking/inference
08:06:32 <Twey> merijn: I thought we got the decidable inference for Rank2Types.  I guess I was mistaken.
08:06:37 <merijn> Twey: So if you use Rank2Types then in the unspecified future GHC *may* magically be able to infer them, but right now it doesn't matter
08:06:43 <geekosaur> closest I got to it was musing in here that the problem paolino was having *sounded* like a rank-N types issue
08:06:50 <geekosaur> then someone on -cafe confirmed it
08:06:54 <ion> Is there any reason why GHC couldn't do rank-2 inference?
08:06:58 <merijn> ion: No
08:07:03 <mauke}> it's hard
08:07:07 <geekosaur> nobody contributed code?
08:07:10 <merijn> ion: The reason it doesn't is "it's a pain to implement so no one can be arsed"
08:07:12 <c_wraith> ion: I suspect it doesn't play well with every other type-system extension
08:07:22 <ion> merijn: alright
08:07:40 <merijn> Because annotating RankN isn't that painful anyway
08:08:33 <Twey> merijn: Presumably if we got rank-2 inference we'd get it for the rank-2 subset of rank-n Haskell anyway?
08:09:00 <merijn> Twey: Dunno
08:14:08 <ttk> What are the channel rules on linking to SO questions?
08:14:14 <ttk> @help stackoverflow.com
08:14:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:14:23 <ttk> @list
08:14:24 <lambdabot> What module?  Try @listmodules for some ideas.
08:14:51 <Cale> heh, those messages should probably be edited for conciseness
08:14:58 <ttk> :)
08:15:44 <Cale> ttk: There's no problem with it, but you might get more people interested in your question if they don't have to click through a link to find out what it is :)
08:16:13 <ttk> I'll try with a short description and a link, as it is easier to describe my case on SO :) Thanks Cale
08:18:39 <ttk> I have a C2HS question: I am trying to wrap function in 2 chs files, since it is in 2 C header files. File1 contains the typedef of the function, and I am trying to map that with {#type ..#}. File2 contains the function based on the typedef. I would like to use the generated Haskell type in my {#fun ...#}, but I cannot figure out if that is even su
08:18:39 <ttk> pported, or if there is a better best practise. I have created a thread on SO for this issue as well: http://stackoverflow.com/questions/30834760/c2hs-bind-both-typedef-and-function
08:18:50 <ttk> wrap a* function...
08:23:37 <Cale> So you want to make a pointer to what is effectively a Haskell function, having that type?
08:25:44 <Cale> I believe you'll want to use a dynamic wrapper. Scroll down a little here until you see "Dynamic wrapper". http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-150004
08:25:56 <ttk> hmm maybe?! I do not quite understand the question. I have defined the type using {#type ..#}. I am wondering if I can use that type in {#fun #} to avoid writing: {`par1', par2 `par3'} inside the fun
08:27:14 <Cale> I believe you should be able to. If you look at what c2hs expands it to, it's just a type synonym of the right form.
08:27:59 <ttk> Cale: it looks like the dynamic wrapper is meant for callback functions from C to Haskell. That is not what I am looking for
08:28:06 <Cale> C2hs is just a thin layer of syntax sugar around the basic FFI, it can be handy if you're doing a large amount of FFI marshalling, but it doesn't do anything too profound.
08:28:36 <ttk> ah okay. So my idea of doing everything FFI related in C2HS might be wrong?
08:29:02 <Cale> Yeah, you need to understand how the FFI works normally in order to use c2hs.
08:29:24 <ttk> I have created the funptr manually, and therefore I considered c2hs to be the next step :)
08:29:36 <KaneTW> 5
08:30:16 <Cale> But yeah, you should be able to use any types you've defined in the {#fun ... #} at appropriate places
08:33:17 <ttk> Have to go home from work, but i'll be back in ~20 minuutes, and then I try to work a bit on it while discussing solutions. Thanks for your comments Cale
08:42:59 * hackagebot aws-dynamodb-conduit 0.1.0.1 - Conduit-based interface for AWS DynamoDB  http://hackage.haskell.org/package/aws-dynamodb-conduit-0.1.0.1 (srijs)
08:43:01 * hackagebot aws-dynamodb-conduit 0.1.0.2 - Conduit-based interface for AWS DynamoDB  http://hackage.haskell.org/package/aws-dynamodb-conduit-0.1.0.2 (srijs)
08:47:18 <ttk> (nick ttk1
08:47:20 <ttk> ups
08:49:13 <vlatkoB> Trying to build clientsession on arch, but on linking I get few ".../entropy-0.3.6/libHSentropy-0.3.6.a(rdrand.o): In function `get_rand_bytes': (.text+0x6c): undefined reference to `_rdrand64_step'". What library must be installed?
08:49:32 <humanoyd> Anyone here who has experience with using triple stores from Haskell?
08:58:12 <ttk> Cale: I hope it is okay I text you. I am trynig to map the function fmi2GetTypesPlatform that is defined like this: __declspec(dllexport) fmi2GetTypesPlatformTYPE fmi2GetTypesPlatform; with fmi2GetTypesPlatformTYPE defined like this: typedef const char* fmi2GetTypesPlatformTYPE(void); I was expecting to be able to do this with: {#fun unsafe fmi2Get
08:58:12 <ttk> TypesPlatform as ^ {} -> `String' #}. However this gives me the error: fmi2Functions.chs:5: (column 14) [ERROR]  >>> Function expected!
08:58:12 <ttk>   A function is needed here, but this declarator does not declare
08:58:12 <ttk>   a function.
08:58:32 <ttk> I am guessing that is because C2HS might not understand typedef functions?
08:59:51 <ttk> my own declaration the manual way in haskell looks like this: FunPtr (IO (CString)) -> IO (CString)
09:00:04 <paolino> geekosaur, http://lpaste.net/134541#a134548 I've tried to put up a simplified version of the Rube Goldberg machine
09:03:45 <paolino> it gets very complicate to factor common code in the 2 servers which is why is Rube Goldberg I guess˘
09:09:27 <ttk> iross_: You have time for a C2HS question? I am trynig to map the function fmi2GetTypesPlatform that is defined like this: __declspec(dllexport) fmi2GetTypesPlatformTYPE fmi2GetTypesPlatform; with fmi2GetTypesPlatformTYPE defined like this: typedef const char* fmi2GetTypesPlatformTYPE(void); I was expecting to be able to do this with: {#fun unsafe 
09:09:27 <ttk> fmi2GetTypesPlatform as ^ {} -> `String' #}. However this gives me the error: fmi2Functions.chs:5: (column 14) [ERROR]  >>> Function expected! I have tried with mapping the type using {#type fmi2GetTypesPlatformTYPE#}, however I cannot figure out how to make use of this in {#fun ..#} How do I map typedeffed functions with C2HS?
09:10:22 <k0ral> is there a way to evaluate some type family instances using ghci ?
09:10:40 <Iceland_jack> :type!
09:11:14 <nkar``> is there a method that can be used to determine whether one operation can be implemented in terms of others?  e.g., bitwise and can be implemented using bitwise or and negate
09:13:04 <nkar``> smt solvers come to mind, but I'd like to hear more specific suggestions
09:13:09 <hodapp> Is 'concrete' the normal term for a type that has no unbound type variables?
09:15:44 <Cale> ttk: hmm, I'm not sure what the point of using {#fun ... #} is if you're not going to specify input/output marshallers...
09:16:19 <k0ral> Iceland_jack: doesn't work here ("Not in scope: data constructor ‚ÄòRep1‚Äô")
09:16:52 <ttk> Cale even if I specify output marshallers - it will still not be able to find the function, because it uses typedef. Does not seem like C2HS can handle typedef for functions
09:17:19 <Cale> ttk: Hmm
09:17:36 <Cale> ttk: It's been a long time since I last used c2hs, so I don't really know what's going on.
09:17:48 <matsuura> So.. what exactly is Hoogle doing? Started hoogle data all a few days ago and seem it's not moving very far.
09:17:50 <ttk> Okay. well thanks anyways :)
09:17:50 <k0ral> Iceland_jack: I guess you meant :kind!
09:17:57 <matsuura> Tempted to kill the process
09:18:02 <Iceland_jack> k0ral: indeed!
09:18:16 <Iceland_jack> lapsus digi..torum
09:18:57 <k0ral> Iceland_jack: thanks :)
09:20:34 <ChristianS> anyone know what's wrong with http://hayoo.fh-wedel.de/ ? it used to work great, now it finds justing or junk.
09:23:48 <geekosaur> they broke it
09:23:55 <geekosaur> that's all anyone can really say
09:24:02 <geekosaur> try email to hayoo@fh-wedel.de
09:25:40 <ChristianS> geekosaur: i see, pity
09:44:40 <osa1> it seems like FlexibleInstances implies TypeSynonymInstances, does anyone know where is this documented?
09:46:27 <osa1> yep, here it is https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html#id3101511
09:58:07 <Raydiation> hi, what does "In¬†mathematics, a¬†functor¬†is a type of mapping between¬†categories" mean?
09:58:14 <Raydiation> isnt a functor just a function then?
09:58:20 <Raydiation> because a function is a mapping?
09:58:32 <saml> you know categories?
09:58:36 <Raydiation> a bit
09:58:49 <saml> a functor maps a category to another
09:59:02 <maerwald> Raydiation: I find that a weird thing to say... functors are not just for mathematics and category theory is more general than mathematics.
09:59:09 <saml> yah, you could use function and mapping interchangeably 
10:01:22 <Raydiation> its the first line on wikipedia :)
10:03:16 <Raydiation> or does it mean category as in associativity and identity?
10:03:23 <Raydiation> https://en.wikipedia.org/wiki/Category_(mathematics)
10:15:23 <Philonous> What happened to hayoo? It used to find identifiers from allmost all packages, now it doesn't even seem to index mtl ?
10:16:07 <hodapp> Blargh. I keep running into cases where things want/need to both be polymorphic and somehow a part of a collection.
10:17:33 <hodapp> And I can't really seem to get rid of the polymorphism, because most of the meaningful operations on them are via functions in an API that are also polymorphic, so it's not a matter of just pre-calling some typeclass method.
10:18:11 <Philonous> hodapp, Sounds like a job for existential types? 
10:18:41 <hodapp> Philonous: Possibly.
10:18:50 <hodapp> Philonous: in the same style as things like SomeNat?
10:19:36 <Philonous> Yes, though you don't necessarily need GADTs for existentials (though I like to write them as GADTs myself) 
10:19:46 <hodapp> SomeNat uses GADTs?
10:20:09 <Philonous> Oh, apparently not, my mistake
10:20:49 <hodapp> I already use SomeNat in this type, actually, for this exact reason
10:21:08 <hodapp> i.e. I have to have a GHC.TypeLits.Nat somewhere in this type
10:24:03 <matsuura> http://paste.debian.net/199940/
10:24:45 <matsuura> http://paste.debian.net/199940/
10:24:54 <matsuura> that's weird, sorry, ignore
10:37:29 <fizbin> I went looking in my code for the most dense haskell possible, and so hacked up a perl thing to find me the line with the most symbol characters (characters other than letters, digits, or spaces) on it, figuring that would be the densest.
10:37:45 <fizbin> Was disappointed: wordChars = S.fromList $ ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "_"
10:37:48 <StoneToad> lol
10:37:54 <StoneToad> remove ' from symbol list?
10:38:20 <MrWoohoo> what does this mean?
10:38:22 <MrWoohoo> Donk:haskell thom$ cabal repl 
10:38:23 <MrWoohoo> ./boo.cabal has been changed. Re-configuring with most recently used options.
10:38:25 <MrWoohoo> If this fails, please run configure manually.
10:38:27 <MrWoohoo> cabal: boo.cabal:22: Parse of field 'build-depends' failed.
10:38:40 <MrWoohoo> NM
10:39:32 <MrWoohoo> wait, the error is on the start of a comment? 
10:39:55 <fizbin> StoneToad: Yeah, it's still not that weird, unfortunately. With ' removed, I get a line with lots of empty lists in it.
10:40:15 <StoneToad> lol!
10:40:24 <StoneToad> guess just symbol counting won't work well
10:42:12 <fizbin> MrWoohoo: You may need to paste the cabal file (or a bit of it) to lpaste.
10:42:25 <ClaudiusMaximus> MrWoohoo: comments in .cabal files aren't as freeform as they could be (i had a similar issue once)
10:42:33 <MrWoohoo> figured it out. cabal doesn't like comments
10:42:44 <MrWoohoo> LOL yup
10:42:52 <ClaudiusMaximus> it does, just not in all places
10:43:24 <MrWoohoo> cabal and comments have an on-again, off-again romance
10:43:53 <gregnwosu> havent hacked any haskell for a while , whats new? :P
10:44:14 <fizbin> gregnwosu: Define "a while"
10:44:40 <gregnwosu> 2-3 months
10:49:51 <quchen> No breaking news in 2-3 months.
10:50:19 <gregnwosu> fair'nuff - 
10:50:20 <quchen> Except for when you're living in Z√ºrich, then you missed ZuriHac and that was pretty awesome ;-)
10:53:17 <gregnwosu> ah .... ive seen the haskellerz meetups online
10:53:33 <gregnwosu> what happened at zurich hack, what was built?
10:56:01 <hodapp> hm, I still don't entirely get how existentials let GHC magically make polymorphic types concrete
10:57:32 <geekosaur> do they? I thought it was the wrapping in another type (thus making it rank-2) that did that
10:58:05 <geekosaur> the polymorphism is hidden inside
10:58:12 <Philonous> hodapp, Values are always of a concrete type, you just don't know which. Existentials store the value and the appropriate class dictionary together. So you don't need to know the concrete type of the stored value, only that it matches the stored dictionary
10:58:55 <ion> hodapp: I suppose they don‚Äôt. data Hide where { Hide :: a -> Hide } doesn‚Äôt let you do pretty much anything with an ‚Äúa‚Äù you extract from Hide. data Shown where { Shown :: Show a => a -> Shown } lets you ‚Äúshow‚Äù them because it stores the proof of Show along with the value but you still don‚Äôt get to extract the concrete type.
10:59:22 <hodapp> hopefully all of the polymorphic stuff I'm working with actually have some typeclasses I can work with.
10:59:42 <Philonous> hodapp, If they don't there's nothing you can do with it anyway
10:59:54 <MrWoohoo> I'm trying to write a reddit crawler/scraper but am noticing links like "load more comments" and the next page button are javascript... so they aren't links I can just grab with xml-conduit. Any ideas how to handle javascript?
11:00:13 <hodapp> Philonous: I *think* nearly everything I have to parametrize over is under some typeclass constraint.
11:01:21 <geekosaur> (and yes, you need a typeclass constraint so the dictionary lets you do something with it, or you have a funny-looking ST that you can't touch)
11:01:23 <Philonous> hodapp, Don't forget you can use a sum type if there's different sets of constraints that you want to accommodate 
11:01:25 <ion> MrWoohoo: If the page is done nicely at all, it has meta elements in head pointing to the previous and the next page.
11:01:49 <MrWoohoo> I'll look for that. any thoughts on the "load more comments"?
11:02:01 <hodapp> Philonous: I'm not sure what you mean
11:02:22 <ion> MrWoohoo: Doesn‚Äôt reddit have an API?
11:02:36 <MrWoohoo> Haven't seen it
11:02:59 <MrWoohoo> https://www.reddit.com/dev/api
11:04:03 <hodapp> Philonous: that is - multiple existentials in an ADT?
11:04:47 <Philonous> hodapp, I mean, suppose you have one set of types that are instance of Show and some that are instance of Num, and you want to store them in a list (for whatever reason, you could have data ShowOrNum = ShowI :: Show a => a -> ShowOrNum; NumI :: Num a => a -> ShowOrNum
11:05:01 <hodapp> Philonous: oh, yeah, that makes sense.
11:05:19 <nacho1> Hello haskellers
11:05:34 <Cale> Hello!
11:05:34 <albeit> I am doing a recursive call on a monadic function, and it gets gradually slower over time. It works perfect if the last line is "return foo", but if I change that line to "if not foo then return False else return True" it gets slower... why is that?
11:05:34 <Philonous> I mean: data ShowOrNum where... 
11:06:23 <Denommus> albeit: it depends on the monad in question
11:06:38 <albeit> Denommus: Its RWST over IO
11:06:55 <Cale> albeit: Uh, that sounds questionable... are you sure?
11:07:27 <Cale> albeit: Also, what is recursive?
11:07:47 <Cale> albeit: Maybe it would be a good idea if you were to post the whole program on lpaste.net
11:08:43 <albeit> Cale: Yes, I am literally uncommenting one line and commenting another. It slows a few microseconds every few thousand interations (linearly). Recursive as, the function that calls this function check its return value, and calls itself again.
11:09:23 <albeit> Cale: It's a large program... maybe I'll try and reduce it to isolate the issue
11:09:33 <Denommus> albeit: what optimization flags are you using?
11:09:40 <albeit> Denommus: -O2
11:10:10 <albeit> Denommus: And -funbox-strict-fields and -fno-emit-yields, but I don't think those would be relevant
11:10:23 <Denommus> albeit: can't you paste just the function in question, or does it have too many dependencies?
11:11:46 <albeit> Sure, this is the function http://lpaste.net/134553
11:12:04 <albeit> Interestingly lpaste is saying "Too strict if"... not sure what that means
11:12:20 <albeit> (Also, RWS is the RWS from stateWriter, not the standard RWS)
11:17:30 <kuribas> Can I write a function returning a generic vector, so it can also be used as a mutable vector (without copying)?
11:18:05 * hackagebot yesod-table 0.1.2 - HTML tables for Yesod  http://hackage.haskell.org/package/yesod-table-0.1.2 (andrewthad)
11:18:06 <Denommus> albeit: what about this? http://lpaste.net/134553
11:19:18 <kuribas> copying to mutate it seems inefficient, at least for an inner loop.
11:19:48 <albeit> Denommus: No delays after many iterations, just like "return poisoned". What is including the return inside the if statement causing issues?
11:24:08 <Denommus> albeit: I suspect including the return inside the if results in branching, and outside the if it gets optimized to return poisoned
11:25:10 <albeit> Denommus: What kind of branching do you mean?
11:26:35 <Denommus> albeit: on the assembly level, there's some cost regarding conditional branches
11:27:28 <Denommus> albeit: I suspect GHC can't optimize your "if" to not use branches when you have "return False" and "return True", because those are not actual booleans
11:27:46 <Denommus> albeit: when you have if not foo then False else True, all this body is optimized to foo
11:28:04 <Denommus> albeit: I'm not sure, though, you'd have to look at the generated assembly :-)
11:33:52 <lostincomputing> I am trying to work with a Map, but am running into problems
11:34:02 <lostincomputing> I have:
11:34:05 <lostincomputing> treatPairMap = Map.insert (extractTreat arg3) arg3 
11:34:31 <lostincomputing> That code complies fine, but fails when I try to print it:
11:34:33 <lostincomputing> print (treatPairMap `asTypeOf` _)
11:34:42 <lostincomputing> trows:
11:34:43 <lostincomputing> Found hole `_'
11:34:43 <lostincomputing>       with type: Map.Map [Treatment] Argument
11:34:43 <lostincomputing>                  -> Map.Map [Treatment] Argument
11:35:54 <Jello_Raptor> hmm, has there ever been a discussion on generalizing the list syntax sugar ('[]',':') to all Monoids? 
11:36:16 <mauke> OverloadedLists?
11:36:23 <Jello_Raptor> Intuition says it's a bad idea unless you're working with some variant of a free monoid (like 'ZipList') but i'm not sure
11:36:47 <lostincomputing> And I don't understand the error message...
11:37:19 <mauke> lostincomputing: what is that _ supposed to do?
11:37:57 <lostincomputing> No idea - folowwing someone's else suggestion (from this forum)!
11:38:16 <Cale> albeit: if not poisoned then False else True = not (not poisoned) = poisoned
11:38:33 <Cale> (why would you write this?)
11:38:42 <ion> lostincomputing: When someone suggests code with _ in an expression, they mean you‚Äôre supposed to fill in that hole.
11:38:59 <lostincomputing> Ah! With what?
11:39:11 <Cale> albeit: You can also then just get rid of the return altogether, and simply liftToIO $ processMessage msg
11:39:14 <albeit> Cale: There was more in the else, but it had the same effect with it being just True
11:39:26 <lostincomputing> Sorry for being so simple- and just trying to print the value of treatPairMap
11:39:30 <Cale> er, hmm
11:39:35 <ion> lostincomputing: Depends on what the code is supposed to do.
11:39:50 <paolino> :t Map.insert
11:39:50 <lambdabot>     Not in scope: ‚ÄòMap.insert‚Äô
11:39:51 <lambdabot>     Perhaps you meant one of these:
11:39:51 <lambdabot>       ‚ÄòM.insert‚Äô (imported from Data.Map),
11:39:56 <mauke> lostincomputing: treatPairMap looks like a function
11:39:59 <mauke> lostincomputing: you can't print functions
11:40:08 <paolino> :t M.insert
11:40:09 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
11:40:23 <lostincomputing> Sorry:
11:40:29 <lostincomputing> treatPairMap = Map.insert (extractTreat arg3) arg3 
11:40:40 <lostincomputing> removing the print allows it to compile fine....
11:40:49 <mauke> still a function
11:41:18 <lostincomputing> I thought treatPairMap was the result of the function.....
11:41:23 <mauke> it is
11:41:26 <Cale> lostincomputing: treatPairMap defined that way is a function which will insert arg3 into a Map at the key (extractTreat arg3)
11:41:29 <mauke> but that result is another function
11:41:41 <Cale> :t M.insert
11:41:42 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
11:41:49 <lostincomputing> Cale: That's what I'm trying to do
11:42:03 <lostincomputing> Make a map of argument, indexed by their treatments
11:42:04 <Cale> Note that you can read this type as  (Ord k) => k -> a -> (Map k a -> Map k a)
11:42:05 <mauke> Map.insert is a function returning a function returning a function returning a map
11:42:24 <Jello_Raptor> mauke: cool, that answers my question :) this seems like a shiny extension to have, even if 'isList' looks like it should be named 'listLike' or something (i.e. a monoid where the inserted elements are stored and are individually retrievable) 
11:42:32 <Cale> i.e. you've given it the k and the a, but not the Map k a argument, so what you have left is a function Map k a -> Map k a
11:43:00 <Cale> lostincomputing: Probably you meant to insert into some Map in particular?
11:43:12 <lostincomputing> Ok, confused, but thanks for the help. Real life intrusion. Will be back.
11:43:13 <Cale> lostincomputing: (which one?)
11:43:19 <Cale> all right
11:43:19 <lostincomputing> Yes - I did..... will re-read docs
11:45:00 <paolino> lostincomputing, M.insert is not modifying a hidden Map it's building a new Map from another one with one more element, give it a Map as last argument
11:49:45 <int-index> Can I pass names that are not in scope to TH without using strings? What I have: ethereal "Foo" "foo"; what I want: ethereal Foo foo
11:51:10 <luzie> :t (('a' :: Char) :: Char) :: Char
11:51:11 <lambdabot> Char
11:52:26 <ion> :t (('a' :: (Char :: *)) :: (Char :: *)) :: (Char :: *)
11:52:27 <lambdabot> Char
11:53:28 <Hijiri> :t ('a' :: (Char :: (* :: BOX)))
11:53:29 <lambdabot> parse error on input ‚Äò::‚Äô
11:57:22 <MrWoohoo> Anyone interested in having a blue sky discussion about an improved threaded discussion system?
11:57:32 <joseph07> I'm trying to write a script that depends only on the Haskell Platform, and I'm running into problems with fetching https content
11:57:39 <albeit> I have a "RWS r w s a" that I want to perform in a "RWST r s IO a". I've tried morph's "generalize hoist" but it seems to require "RWS r w s" be an MFunctor... do I need to implement that? Is there another way?
11:58:06 <joseph07> I'm thinking that either the HTTP library should have an unsafeRequestHTTPS or that tls should be included in the platform
11:58:43 <mauke> :t runState
11:58:44 <lambdabot> State s a -> s -> (a, s)
11:59:01 <quchen> albeit: hoist generalize?
11:59:08 <mauke> :t state . runState
11:59:08 <quchen> Oh
11:59:09 <lambdabot> MonadState s m => State s a -> m a
11:59:10 <MrWoohoo> Basically, I hate them. Good, informative comments get lost. Uprooting and down voting helps, but the structure is fixed. x replied to y replied to z. 
11:59:10 <quchen> Nevermind.
11:59:23 <albeit> quchen: Sorry yes "hoist generalize"
11:59:39 <quchen> MrWoohoo: This channel is about Haskell, the programming language.
11:59:55 <MrWoohoo> I was going to do the project in haskell
12:00:02 <RocketRaccoon> quchen, no way ...
12:00:26 <MrWoohoo> and my next point was something haskellers would have some good perspective on
12:07:09 <mauke> :t \m -> RWST (\r s -> return (runRWS m r s))
12:07:11 <lambdabot> Monad m => RWS r w s a -> RWST r w s m a
12:07:26 <mauke> @pl \m -> RWST (\r s -> return (runRWS m r s))
12:07:27 <lambdabot> RWST . ((return .) .) . runRWS
12:07:46 <lostincomputing> Works! used Map.empty as the final argument
12:09:06 <lostincomputing> So, I now have:
12:09:07 <lostincomputing> treatPairMap = Map.insert (extractTreat arg3) arg3 Map.empty
12:09:31 <lostincomputing> which works to generate the map for a single argument (in this case, arg3).
12:09:38 <kuribas> Is it possible to have a vector that can be used both mutable and immutable? http://lpaste.net/134555
12:09:41 <Geekingfrog> Is there such a thing: `concatF :: (Foldable f1, Foldable f2, Monoid a) => f1 (f2 a) -> f2 a` ??? I can't figure out how to generically append foldables f2
12:09:58 <lostincomputing> I want to map that over a list of arguments, such that the overall type will be
12:10:32 <lostincomputing> [argument] -> Map k a
12:10:56 <lostincomputing> Any pointers on how to generalise the function I can map over a list of arguments?
12:11:21 <c_wraith> kuribas: no.  But assuming your use of it is totally linear, you can use unsafeFreeze and unsafeThaw to convert between them in O(1) time.  Just remember that the conversion breaks the thing being converted.  If it's ever used again, it'll go wrong.
12:11:37 <kuribas> c_wraith: ok, thanks!
12:12:31 <Dodecahedrus> i need a some funciont like: sort :: Ord b => [(a,b)] -> [(a,b)] that sorts the list by looking at second. I tried hoogle and the best i found was sortBy ::  (a -> a -> Ordering) -> [a] -> [a] is there some better alternative?
12:12:59 <clrnd> Dodecahedrus, what's wrong with sortBy?
12:13:07 <clrnd> sortBy (comparing snd)
12:13:13 <clrnd> iirc
12:13:14 <kuribas> c_wraith: it's in an inner loop, so I can accept some unsafety.
12:13:33 <c_wraith> kuribas: just beware of laziness.
12:13:56 <kuribas> c_wraith: I am using unboxed vectors (matrices actually), so it should be fine.
12:14:13 <c_wraith> That does help a bunch.  Way fewer things to watch out for.
12:14:15 <joseph07> Dodecahedrus: I also like sortBy (compare `on` snd), which is a more general pattern
12:14:32 <quchen> Geekingfrog: If you've got a bit more special types you can use `sequenceA` to swap f1 and f2.
12:14:36 <quchen> :t fold . sequenceA
12:14:37 <lambdabot> (Applicative t, Foldable t, Traversable t1, Monoid (t1 a)) => t1 (t a) -> t1 a
12:14:56 <quchen> Ah wait, that's not the right way round.
12:14:59 <Geekingfrog> :t sequenceA
12:15:00 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
12:15:26 <Geekingfrog> quchen, I'm reading the typeclassopedia, but I think some exercises are outdated
12:15:52 <Dodecahedrus> i tought defining the (a -> a -> Ordering) would be a chore, i didn't knew about compare or comparing. Thanks
12:16:14 <Geekingfrog> like "how any generalize to foldable". But the current type of any is already refering to foldable
12:16:22 <c_wraith> Geekingfrog: The typeclassopedia should still be solid.  None of the theory has changed..  Though there are some tiny practical matters, like it being necessary to create an Applicative instance when creating a Monad instance.
12:16:33 <ion> It might be nice if the Alternative class had a method like aconcat :: Foldable t => t a -> f a with the default implementation foldr (\x -> (pure x <|>)) empty
12:16:37 <c_wraith> Geekingfrog: or yeah, minor things like that.
12:17:47 <quchen> :t fmap fold . sequenceA -- This way round, Geekingfrog 
12:17:48 <lambdabot> (Applicative f, Traversable t, Monoid b) => t (f b) -> f b
12:18:57 <Pamelloes> Has anyone figured out a good abstraction for building a GUI layout?
12:20:45 <kuribas> Pamelloes: you mean like FRP for GUI toolkits?
12:21:07 <kuribas> There is reactive-banana-wx for example: https://hackage.haskell.org/package/reactive-banana-wx
12:21:53 <Pamelloes> I'm aware of FRP ;)
12:22:14 <Pamelloes> I'm not as looking for something to abstract interactions within a GUI as much as an abstraction go building the /layout/ of the GUI
12:22:22 <ttt_fff> I realize this question is OT: -- what is a good channel here on freenode for me to ask e" where can I learn to implement a minimal neural network for solving the MNIST" on freenode ?
12:22:47 <Pamelloes> e.g. once I've set up all of my buttons and textboxes and whatevers, is there a good way to abstract the process of putting them in the correct places?
12:23:22 <Geekingfrog> Pamelloes, isn't that what xmonad does?
12:23:42 <Geekingfrog> maybe there are some interesting pointers in the source
12:24:16 <kuribas> Pamelloes: wxWidgets has a lot of options for placing widgets.
12:26:02 <kuribas> You can specify margins, relative placement, horizontal and vertical stacking, etc...
12:26:25 <kuribas> Not sure if that answers your question.
12:28:08 * hackagebot yesod-crud-persist 0.1.1 - Flexible CRUD subsite usable with Yesod and Persistent.  http://hackage.haskell.org/package/yesod-crud-persist-0.1.1 (andrewthad)
12:31:40 <Pamelloes> kuribas: I'm actually working on building a library on top of wxHaskell. I agree that all of wxHaskell's layout functions are very powerful.
12:32:10 <Pamelloes> However, they don't seem "abstract" enough to me, if that makes sense
12:32:54 <kuribas> not really
12:33:31 <kuribas> Maybe you mean more pure?  wxHaskell is very imperative.
12:33:47 <Pamelloes> Yes.
12:34:36 <Denommus> Pamelloes: are you going to use FRP, like reflex does?
12:35:00 <Pamelloes> Denommus: I'm actually working on a reflex implementation based on wxHaskell
12:35:20 <Denommus> Pamelloes: ah, I remember ryan mentioning your nick, now that I think about it
12:36:00 <Pamelloes> I've successfully implemented most of the FRP features; however, integrating the process of laying out everything has been a challenge.
12:36:16 <Denommus> Pamelloes: I also wanted to make a reflex framework for gtk, but I have no idea where to start XD
12:37:11 <Pamelloes> :) It took me several weeks to figure out where to fit everything... and I still haven't quite gotten everything right.
12:37:30 <kuribas> Pamelloes: How does reflex compare to reactive-banana?  I was going to build an interface using wxHaskell and reactive-banana.
12:37:36 <Denommus> Pamelloes: are you going to write some article on your advancements?
12:37:46 <slack1256> damn, just when I started to learning gtk2hs, people are going to use wx for reflex :-(
12:38:08 * hackagebot serversession 1.0 - Secure, modular server-side sessions.  http://hackage.haskell.org/package/serversession-1.0 (FelipeLessa)
12:38:10 * hackagebot serversession-backend-acid-state 1.0 - Storage backend for serversession using acid-state.  http://hackage.haskell.org/package/serversession-backend-acid-state-1.0 (FelipeLessa)
12:38:15 <kuribas> Pamelloes: But I am interested in alternatives.
12:38:21 <Denommus> kuribas: two nice things about reflex is that it supports both continuous time and discrete time semantics, and the other is that it introduces a new concept called Dynamic, which is a Behavior that triggers an Event whenever it changes
12:39:34 <kuribas> Does it have space leaks?  One of the advantages of reactive-banana seems to be that it is well tested...
12:39:57 <Denommus> kuribas: reflex solves the space leak problem in a similar way to reactive-banana (using shadow types)
12:40:32 <Pamelloes> Denommus: Maybe, I've never really published anything haskell-related before.
12:40:37 <Denommus> both are great libraries, but for me the main advantage of reflex is that it already has an awesome front-end framework
12:41:08 <Denommus> though if you're going to create a new framework that's probably not a "real" advantage
12:43:08 * hackagebot serversession-backend-persistent 1.0 - Storage backend for serversession using persistent and an RDBMS.  http://hackage.haskell.org/package/serversession-backend-persistent-1.0 (FelipeLessa)
12:43:10 * hackagebot serversession-backend-redis 1.0 - Storage backend for serversession using Redis.  http://hackage.haskell.org/package/serversession-backend-redis-1.0 (FelipeLessa)
12:43:12 * hackagebot serversession-frontend-snap 1.0 - Snap bindings for serversession.  http://hackage.haskell.org/package/serversession-frontend-snap-1.0 (FelipeLessa)
12:43:14 * hackagebot serversession-frontend-wai 1.0 - wai-session bindings for serversession.  http://hackage.haskell.org/package/serversession-frontend-wai-1.0 (FelipeLessa)
12:43:16 * hackagebot serversession-frontend-yesod 1.0 - Yesod bindings for serversession.  http://hackage.haskell.org/package/serversession-frontend-yesod-1.0 (FelipeLessa)
12:43:51 <Denommus> kuribas: besides, if testing worries you, reflex is already running in production, it's not like it's just an experiment :-)
12:44:02 <kuribas> ok, I see
12:47:13 <kuribas> My idea was to create the GUI using the imperative wxHaskell API, and to put in the FRP hooks myself.
12:47:52 <kuribas> Considering that development of wxHaskell is slow at the moment, I think that's the best option.
12:48:12 <Denommus> kuribas: if that's your idea, reactive-banana is a good bet
12:48:20 <Denommus> kuribas: it's designed exactly for that use-case
12:48:32 <Denommus> kuribas: reflex seems to me more of a framework-building library
12:49:10 <kuribas> ok
12:49:51 <Denommus> kuribas: as in, in reflex you'd deeply integrate your GUI framework with the library, to the point where you define your whole GUI declaratively as a Dynamic
12:50:39 <kuribas> Denommus: That would be really nice, but a substantial effort I guess.
12:51:01 <Denommus> kuribas: meanwhile, the simple approach in reactive-banana is just to create your GUI imperatively and to provide some bindings for its events, and build behaviors and events out of them, using reactimate to trigger changes from your events to the view
12:51:14 <Denommus> kuribas: yeah, that's exactly the effort Pamelloes is doing
12:51:48 <kuribas> Denommus: wxHaskell is already behind wxWidgets in functionality.
12:51:48 <Pamelloes> Yep, you (all) are welcome to take a look at what I've done so far. My library is at https://github.com/Pamelloes/reflex-wx
12:52:13 <Denommus> Pamelloes: ah, cool, I will definitely look into it :-)
12:52:48 <Pamelloes> kuribas: I've made some minor PR's to bring wxHaskell a little more up to date. I have plans to do some more major work after I get more of my library done.
12:54:45 <kuribas> For example, I need to add support for virtual methods to wxHaskell.
12:56:13 <Pamelloes> kuribas: Are you wxHaskell's maintainer?
12:56:21 <kuribas> no
12:56:30 <Pamelloes> Oh
12:56:51 <kuribas> I have contributed only a little...
12:58:28 <Pamelloes> Ah, same here. Though supporting virtual methods sounds complicated.
12:58:43 <Pamelloes> I'm not that good with C/C++ :/
13:00:40 <SparkySparkyBoom> how do i map over a Data.Sequence
13:00:48 <SparkySparkyBoom> .Sequence
13:02:00 <lostincomputing> I'm think I need to try and fold a function over a list, using a Data.Map to accumulate the results.....
13:02:13 <lostincomputing> BUt I'm having real problems getting it to work....
13:02:50 <kadoban> SparkySparkyBoom: I would assume Data.Sequence is an instance of Functor, so you'd fmap
13:04:58 <SparkySparkyBoom> kadoban: thank you
13:05:33 <kuribas> lostincomputing: there is fromList which does that.
13:05:41 <kuribas> maybe a little optimized.
13:06:22 <kadoban> There's also fromListWith and I think another one for some extra functionality. They're pretty neat.
13:06:28 <lostincomputing> kuribas: The problem is that the Map is a little "odd":
13:07:11 <kuribas> lostincomputing: define "odd".
13:07:15 <lostincomputing> I want the Map keys to be part of the value
13:08:07 <lostincomputing> I have a type, s.t. the type has several fields. I have a function to extract some of those fields
13:08:35 <lostincomputing> ANd now I want to make a MAp using those extracted values as keys to the data
13:08:40 <lostincomputing> (Sorry, diffiuclt to explain)
13:09:11 <lostincomputing> Given some type T, with constructor T a b c d
13:09:48 <lostincomputing> I want a Map of the form M (b,c) -> T a b c d
13:09:53 <lostincomputing> Does that make any sense?
13:10:44 <lostincomputing> I currently have this running:
13:10:48 <lostincomputing> treatPairMap = M.insert (extractTreat arg3) arg3 M.empty
13:10:57 <ion> ReinH: Latin square generator using less brute force https://gist.github.com/ion1/99847bcb46de67261268
13:12:01 <lostincomputing> This works fine for a single arg (arg3 here)
13:12:34 <kuribas> lostincomputing: so fromList . map (\e -> (extract e, e))
13:13:58 <lostincomputing> kuribas: Where extract is my current extraction function?
13:14:08 <kuribas> yes
13:17:48 <lostincomputing> I have:
13:17:58 <lostincomputing> extractTreat :: Argument -> [Treatment]
13:17:59 <lostincomputing> makePairMap = M.fromList . map (\e -> extractTreat e, e) argList
13:18:10 * hackagebot species 0.3.4 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.4 (BrentYorgey)
13:18:12 <lostincomputing> Throws Not in scope: `e'
13:19:05 <kadoban> lostincomputing: Your syntax there is wrong ... or right but doesn't mean what you think it does.
13:19:38 <kadoban> lostincomputing: (\e -> something, 2) is a tuple, the fst of the tuple is a function, the second one is just a number
13:19:44 <lostincomputing> Sorry - trying to copy Kuribas' suggestion....
13:20:18 <kadoban> I would think you mean something like ...  (\e -> (extractTreat e, e)) maybe ?
13:24:28 <WJWH> Does anyone know if installing the Win32 package on a non-Windows OS has any negative effects other than using up some extra disk space?
13:25:14 <WJWH> I have a patch for Ghcid but it adds a dependency on Win32 :/
13:25:21 <pavonia> Does that package even compile?
13:25:37 <WJWH> I don't know
13:26:26 <byorgey> WJWH: if depending on the Win32 package works at all on a different OS, then presumably you could do the same thing *without* depending on the Win32 package.
13:26:27 <WJWH> That's pretty much the point: if it breaks Ghcid for everyone except windows users it's not much use...
13:27:15 <WJWH> It's this issue
13:27:17 <WJWH> https://github.com/ndmitchell/ghcid/issues/35
13:27:33 <crough> Oh my... Halcyon fan converted successfully...
13:27:46 <twanvl> couldn't you check for Win32 with a cabal flag?
13:27:46 <crough> good work FP complete‚Äî stack is niiiiice
13:27:52 <byorgey> WJWH: oh, well in that case you probably want some kind of conditional compilation
13:27:58 <byorgey> using CPP and/or cabal flags
13:28:02 <WJWH> hmm
13:28:02 <mietek> crough: anything in particular which you find Stack does better than Halcyon?
13:28:05 <twanvl> Or better yet: put the titlebar icon thing into a separate package
13:28:46 <crough> @mietek Mostly the interface is much better than straight cabal, and it doesn't seem to be trying to rebuild the entire sandbox ever.
13:28:46 <lambdabot> Unknown command, try @list
13:29:06 <WJWH> twanvl: how would that work? I would still want it integrated in ghcid?
13:29:18 <LordBrain> Hey, anyone know off hand how to use cabal and build in one sandbox and then install to another?
13:29:24 <crough> @mietek I like Halcyon a lot (and it's a lot more helpful for deploying instantly on *nix systems), but this seems a little nicer seeing as I don't use AWS for caching right now.
13:29:24 <lambdabot> Unknown command, try @list
13:29:35 <byorgey> WJWH: since the Win32 package actually consists of bindings to an external Win32 library, it will not compile unless that external library is already installed
13:29:41 <byorgey> which means it won't build on other OSes
13:30:18 <WJWH> that makes sense
13:30:32 <hexagoxel> crough: every time you use @, lambdabot feels important :p
13:30:33 <crough> mietek: honestly, I'd probably still use halcyon in a cloud environment because I don't use Docker at all and Halcyon seems way more platform agnostic
13:30:43 <mietek> crough: right.  If you‚Äôve had any frustrations with Halcyon, I‚Äôm always looking for feedback.
13:31:28 <mietek> crough: I think Stack does many things right, but it‚Äôs also in an easier position to do those things, as it completely drops cabal-install.
13:31:29 <crough> mietek: Yeah, absolutely. I actually think that the competition is wonderful and I still prefer wrapping Cabal in bash... I might work on a `halcyon repl` command this weekend.
13:32:06 <WJWH> On other OS's the actual functions do nothing through CPP (they are just "return ()")
13:32:08 <hexagoxel> LordBrain: there is no built-in way to do that afaik; `cabal sandbox add-source` is maybe what you want
13:32:24 <WJWH> but the cabal file still mentions Win32 :(
13:32:37 <mietek> crough: well, there‚Äôs no need to do that; just `ln -s /app/sandbox/cabal.sandbox.config .` in your project‚Äôs directory, and `cabal repl`
13:32:48 <mietek> crough: this will be simpler soon
13:33:10 <mietek> crough: as another way to do it to export CABAL_SANDBOX_CONFIG
13:33:10 * hackagebot cased 0.1.0.0 - Track string casing in its type  http://hackage.haskell.org/package/cased-0.1.0.0 (WilliamCasarin)
13:35:02 <hexagoxel> https://gist.github.com/lspitzner/98ab9dab41957dc89ee6
13:35:42 <LordBrain> hexagoxel, yeah i could probably have used that, but i was pesimistic that anyone would answer and so just renamed the cabal.sandbox.config to build a whole new sandbox.
13:39:51 <uniquenick> I could have sworn I heard about a new haskell web library recently that was inspired by servant, but now I can't find it.  Does that sound familiar to anyone?
13:41:15 <johnw> is there anyone using "stack"?
13:41:20 <crough> mietek: Oh wow, that's nice. That might be a thing to throw up at the top of the tutorial :)
13:41:50 <mietek> crough: yes, there‚Äôs a lot which could be done to improve both the UI and the documentation.
13:42:18 <mietek> crough: it would be nice if some of the funding which is going towards building completely new tools went towards that.
13:44:20 <crough> mietek: yeah... Nix has a distribution and FPC has money and money; it's a shame that Halcyon is harder to find.
13:44:55 <mietek> crough: harder to find?
13:45:13 <crough> mietek: less buzz around it; more invisible in the community itself.
13:46:22 <mietek> crough: right. I should be writing about it more.
13:46:52 <mietek> crough: for what it‚Äôs worth, I might be speaking at Haskell eXchange in October about it. Maybe that‚Äôll help.
13:47:35 <crough> mietek: it most likely will. I think emphasizing Heroku and the advantage of Bash will win people over
13:47:47 <crough> "It's just a wrapper over cabal! Nothing else to set up" etc etc
13:48:05 <mietek> crough: some people actually want to get rid of cabal-install completely, hence Stack.
13:48:11 * hackagebot entropy 0.3.7 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.3.7 (ThomasDuBuisson)
13:48:12 <mietek> crough: I can understand that, too.
13:48:50 <mietek> crough: in any case, we‚Äôre all working towards making Haskell easier to get started with, and I‚Äôm happy to see Stack help with that.
13:48:58 <crough> mietek: I've had minimal problems with Cabal to be honest
13:50:55 <kadoban> Cabal works pretty decently for me if I use sandboxes ... otherwise it's a huge mess. The stackage cli stuff just speeds up and improves a lot of what I'd be doing anyway, so it sounds nice. I need to go out and actually start using it though ... kind of being lazy until I upgrade to ghc 7.10.1
13:51:16 <hodapp> I need to learn nix.
13:52:07 <crough> mietek: halcyon is 100x better for installing binaries, as well. It's like cabal + package management
13:52:35 <hodapp> crough: if you've had minimal problems, how's that leave room for 100X improvement?
13:52:42 <mitchty> wait does that mean with halcyon i can have ghc-mod installed with say, shellcheck and not pollute my db?
13:53:01 <mietek> mitchty: of course.
13:53:20 <crough> hodapp: cabal isn't a package manager, and it's not meant to be used to install executables (despite what hundreds of GitHub README's would let you think). Halcyon seems to do just fine.
13:53:45 <mietek> crough: I‚Äôm glad it works for you, but Halcyon still isn‚Äôt a full-fledged package manager.
13:53:52 <mietek> crough: it just does a bit better than cabal-install.
13:54:08 <bitemyapp> dmwit: I'm not the first to notice that an Arbitrary instance for a sum type is just (oneof $ map return universe) right?
13:54:22 <crough> mietek: emphasizing or creating the full ability to manage packages might be a selling point
13:54:38 <mietek> crough: unfortunately, I‚Äôm not selling it.
13:54:50 <crough> mietek: Metaphorically selling, of course.
13:55:00 <crough> mietek: pitching, marketing, whatever you'd like to call it
13:55:17 <mitchty> mietek: holy crap, i need to try it then >.<
13:55:21 <mietek> crough: but you see, the problem is not a lack of good ideas; the problem is a lack of time for development, in other words, funding.
13:55:27 <LordBrain> universe isn't actual haskell is it? that would be nice sugar for enums... [FIRST .. LAST]
13:55:40 <crough> mietek: the developers' plight :)
13:55:45 <ion> @hackage universe
13:55:45 <lambdabot> http://hackage.haskell.org/package/universe
13:55:57 <mitchty> my biggest pita right now is just getting a sane setup for emacs so i can use ghc-mod + other stuff without making me want to drink
13:56:01 <mietek> mitchty, crough: feel free to join #haskell-deployment and ask questions.
13:56:11 <mietek> A bit less busy there.
13:56:48 <mitchty> been trying to use nix so far but its not as great on osx for that jazz, that or i'm too dumb to use it right
13:57:05 <mitchty> sure, at work so will sort this out tonight
13:57:20 <mietek> mitchty: that was my issue with Nix as well.
13:57:36 <mietek> mitchty: although on OS X you can use brew to install shellcheck binaries.
13:57:41 <mietek> mitchty: not sure about ghc-mod.
13:58:19 <ttt_fff> we need aws lambda for haskell
13:58:41 <albeit> Why does this program take increasing amounts of time to run "run"? http://lpaste.net/134557
13:59:57 <mitchty> mietek: yeah however i'm trying to get away from brew tbh, but getting OT for the channel
14:02:05 <quchen> albeit: Define "increasing amounts of time"
14:02:18 <WJWH> I'm looking for someone running OS X or Linux to test if my package still compiles on a non-windows OS
14:02:26 <quchen> albeit: Regardless of that, you should not put constraints in normal data types, they don't serve any purpose there
14:02:34 <albeit> quchen: The value print out steadily increases the longer it is run. Starts at basically 0, adds about 1 microsecond each iteration
14:02:43 <albeit> (THis is much simplified version of code in my main program)
14:03:12 <albeit> quchen: Do you mean the Num s for Stater?
14:03:15 <quchen> Yes.
14:03:16 <WJWH> I put all the dependencies on Win32 either behind CPP or in cabal conditionals, but testing is always better :)
14:03:29 <v1k0d3n> WJWH: why not just use vagrant or a docker image?
14:04:02 <v1k0d3n> WJWH: that's what those tools are for anyway...
14:04:17 <v1k0d3n> go to the #vagrant or #docker chans
14:04:25 <WJWH> righto
14:04:33 <albeit> quchen: Why do they serve no purpose?
14:04:39 <WJWH> ill spin up something
14:04:54 <albeit> quchen: In my normal program I have them in the type so I don't need to rewrite that constraint in all the functions taht use that type
14:05:10 <v1k0d3n> yeah, they're easy tools...esp docker
14:05:21 <quchen> albeit: Type inference will do that for you. If you add the constraint to the type, all functions using it will get the constraint, not only the ones actually making use of it.
14:05:32 <quchen> albeit: See also https://github.com/quchen/articles/blob/master/fbut.md#imposing-constraints-on-data-types
14:05:32 <v1k0d3n> WJWH: what is the package?
14:05:44 <WJWH> ghcid
14:05:57 <albeit> quchen: And yes, removing the type constraint and moving it to the type declaration for run make it take the same time each time. But why?
14:05:58 <james_rth> does anybody have any experience using monad-logger?
14:06:03 <james_rth> I'm really stuck!
14:06:32 <albeit> quchen: But I sort of need all the functions ot have that constraint.
14:07:01 <WJWH> I have a feature ready, but it'll only work on windows due to using windows APIs
14:07:35 <v1k0d3n> WJWH: gotcha
14:08:07 <v1k0d3n> WJWH: i use vagrant all the time for windows and linux cross-testing. 
14:08:40 <quchen> albeit: Then you should add it to all the functions that need it :-√æ
14:09:27 <albeit> quchen: I will change it. But why does using it in the data type declaration make it slow down during run time? I would think that wuold just be a compile time thing
14:09:30 <quchen> I don't know why exactly this requires RankNTypes here, maybe someone else is more knowledgeable
14:10:04 <WJWH> v1k0d3n: I just remembered I have a Raspberry pi somewhere which doesn't run windows, so that one is now working at compiling :D
14:10:14 <hodapp> lulz, Windows on a Pi
14:10:15 <WJWH> james_rth: what is the problem?
14:10:37 <v1k0d3n> hodapp: you missed it i think...he needed linux.
14:10:49 <quchen> albeit: You can view constraints as a normal function parameter in a simplified picture, a la "NumDictionary s -> State s a". Functions aren't memoized, which is where problems often come from. But I don't see how that applies here (or how it does not apply).
14:10:53 <v1k0d3n> hodapp: windows on a pi, who would be that dumb?
14:10:58 <james_rth> @WJWH, well I'm trying to use a StateT, and I'd like to be able to log inside it to stderr, but I have no idea how to do that!
14:10:59 <lambdabot> Unknown command, try @list
14:11:14 <james_rth> @WJWH, I can't find any reasonable examples
14:11:15 <lambdabot> Unknown command, try @list
14:11:22 <mitchty> i have a radxa rock that is beefier than the rpi2, compiling anything is... painfully slow on it
14:11:24 <james_rth> any help, greatly appreciated!
14:11:30 <mitchty> you'd be better off cross compiling
14:11:37 <glguy> james_rth: @ is for bot commands, you don't need to use it when addressing someone in chat
14:11:43 <james_rth> oh thanks.. sorry
14:11:45 <hodapp> v1k0d3n :P
14:12:05 <hodapp> mitchty: Radxa Rock? Is that also ARM?
14:12:39 <quchen> albeit: What happens when you remove all the timing stuff?
14:13:00 <albeit> quchen: I'm not sure, thats the only way I can see how long it takes ;)
14:13:06 <mitchty> hodapp: yep http://radxa.com/Rock be aware, its harder to get most os's on it
14:13:28 <mitchty> i run debian wheezy
14:13:36 <hodapp> mitchty: hah, get it? harder? rock?
14:13:38 <hodapp> >_>
14:13:40 * hodapp runs
14:13:45 <quchen> albeit: deepseq = seq here by the way.
14:13:57 <albeit> True...
14:14:00 <quchen> And instead of "x `seq` return ()" you can often write "evaluate".
14:14:05 <hodapp> interesting, Android too
14:14:16 <quchen> There is a subtle difference though, so have a look at evaluate's docs.
14:14:43 <mitchty> hodapp: yep, comes with it preinstalled i nuked that straight away though :D
14:15:48 <dolio> quchen, albeit: It requires RankNTypes because that's not a data declaration.
14:15:49 <albeit> quchen: Quirk is still there with evaluate, so works close enough.
14:15:52 <dolio> It's a type alias.
14:16:15 <quchen> dolio: Yes, I see the "type". But where is it RankN?
14:16:27 <quchen> The forall is all the way on the outside, no?
14:16:46 <quchen> Eeek I see
14:16:50 <albeit> Simplified the code btw: http://lpaste.net/134559
14:16:51 <dolio> Having the higher-order contextual alias is grouped under rank-n.
14:16:55 <WJWH> james_rth: That is a rather short description which doesn't help much. Are you trying to log from some StateT <state> IO?
14:17:04 <albeit> But why does it cause increasing delays when it uses rankN?
14:17:31 <james_rth> sorry wjwh, yeah, I'd like to be able to log from within a StateT a (EitherT e IO)
14:17:33 <dolio> Int -> Stater Int = Int -> (Num Int => State Int Bool)
14:19:23 <james_rth> something like do { get a1; put (a1 + 2); logDebugN "hello"}
14:19:25 <WJWH> If I understand the haddock for Control.Monad.Logger correctly, having IO as a base monad will discard your log messages
14:19:29 <WJWH> https://hackage.haskell.org/package/monad-logger-0.2.3.2/docs/Control-Monad-Logger.html
14:19:38 <albeit> dolio: Do you know why using that "embedded" constraint causes issues?
14:20:09 <james_rth> wjwh, this haddock is old, this is the latest: https://hackage.haskell.org/package/monad-logger-0.3.13.1/docs/Control-Monad-Logger.html
14:20:28 <connney> in Parsec is there a better way to discard optional '.' and ',' characters?  "char '.' <|> char ',' <|> return '.'"
14:20:58 <quchen> optional (many (oneOf ",.")) -- something along those lines
14:21:06 <dolio> albeit: No. I don't know what the code generator does exactly for stuff like that.
14:21:39 <dolio> However, if you're using 'Stater Int', it's pointless to set it up that way.
14:21:42 <WJWH> hmm it has been a long time ago since I played with that :/
14:21:53 <albeit> dolio: yeah, duchen already informed me of the error of my ways ;)
14:22:10 <albeit> But I just want to know why its causing the time increases for future reference
14:22:10 <james_rth> have you any other logging advice / libs?
14:22:17 <connney> I want to discard just one of the two.. so optional (char '.' <|> char ',') ?
14:22:27 <quchen> oneOf ",."
14:22:35 <connney> nice
14:22:38 <WJWH> james: what is the part that doesn't work atm?
14:22:49 <quchen> Or do you want to discard multiple ones as long as they're of the same kind
14:22:56 <dolio> albeit: If I had to guess, it's doing the equivalent of 'run f z = ... run (\x -> f x) z'.
14:23:07 <quchen> That would be "many (char '.') <|> many (char ',')"
14:23:19 <connney> just a single '.' or a single ','
14:23:24 <dolio> Because the type alias forces it to.
14:23:45 <connney> wouldnt I need optional there too if I wanted that?
14:23:48 <quchen> Ah, and then you get the evil lambda chain, dolio?
14:24:12 <dolio> Well, yeah. Eta expansion isn't free.
14:24:21 <quchen> Heh, subtle.
14:24:22 <connney> I never had as much fun parsing as with haskell and Parsec
14:24:43 <albeit> Oh new things to google. So that bad function is making a lambda chain the requires eta expansion?
14:25:48 <quchen> albeit: Superficially, f = (\x -> f x) = \y -> (\x -> f x) y = \z -> (\y -> (\x -> f x) y) z = ‚Ä¶ -- But you pay a price for the eta expansion
14:26:41 <dolio> albeit: Yes, but yours is doing it with dictionaries. Maybe.
14:28:06 <albeit> Hmm... but why does the type alias affect that? Wouldn't it be doing that regradless? Or is it because the type alias is like another function?
14:28:13 * hackagebot sqlite-simple 0.4.9.0 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.4.9.0 (JanneHellsten)
14:28:34 <james_rth> wjwh, well I can write an instance of MonadLogger m => MonadLogger (EitherT e m) easily, but I don't understand how to use the lib at all beyond that!
14:28:47 <connney> what arbitrary precision decimal number  lib should I use?
14:28:57 <james_rth> basically, if you have an instance of MonadLogger, how do you run the transformer
14:29:13 <james_rth> it seems StateT is an instance of MonadLogger
14:29:15 <connney> there are several, numbers, Decimal
14:29:20 <arkeet> and scientific
14:29:45 <bitemyapp> :exf "[(Bool, a)] -> ((Bool, a) -> Maybe a) -> [a]"
14:29:58 <connney> which one is usually recommended?
14:30:02 <exferenceBot> \ b c -> fold (traverse c b)
14:30:08 <bitemyapp> sweet
14:30:22 <reqq456> im starting with haskell, this is working in prelude(without this main = ) but when i paste this in a hs file and want to compile i get this error http://paste2.org/Oa9t60Cp
14:31:10 <ronh-> reqq456 main has to be of IO a type. add print $ after =
14:31:26 <bitemyapp> @ty \ b c -> fold (traverse c b)
14:31:27 <lambdabot> (Applicative t, Foldable t, Traversable t1, Monoid (t1 b)) => t1 a -> (a -> t b) -> t1 b
14:31:35 <bitemyapp> hahahahahaha YES
14:31:44 <quchen> reqq456: You have to print your sum, not just assign it to your program. The C equivalent to your program would be something like "int main = { ... }".
14:32:19 <reqq456> ah okay i know
14:32:21 <reqq456> thx
14:32:31 <arkeet> :t maybeMap
14:32:32 <lambdabot> Not in scope: ‚ÄòmaybeMap‚Äô
14:32:35 <arkeet> er
14:32:37 <dolio> flip mapMaybe
14:32:41 <arkeet> mapMaybe
14:32:42 <arkeet> yeah
14:32:50 <arkeet> :t mapMaybe
14:32:51 <lambdabot> (a -> Maybe b) -> [a] -> [b]
14:33:03 <maerwald> :t flip . flip mapMaybe
14:33:04 <lambdabot>     Couldn't match type ‚Äò[b1]‚Äô with ‚Äòb -> c‚Äô
14:33:04 <lambdabot>     Expected type: (a -> Maybe b1) -> [a] -> b -> c
14:33:04 <lambdabot>       Actual type: (a -> Maybe b1) -> [a] -> [b1]
14:33:36 <james_rth> I think I just have to write an instance of MonadLogger IO
14:33:49 <dmj`> james_rth: johnw wrote a pkg for that
14:33:59 <Denommus> isn't mapMaybe mostly exchangeable with (>>=)?
14:33:59 <james_rth> do you have the location / name? dmj
14:34:13 <dmj`> james_rth: https://hackage.haskell.org/package/logging
14:34:15 <james_rth> ^^ dmj`
14:34:22 <arkeet> Denommus: the type is rather different.
14:34:22 <bitemyapp> hexagoxel: sweet jesus I love exference :P
14:34:25 <james_rth> thanks everyone for your help, it's really appreciated
14:34:49 <arkeet> :t mapMaybe . (. toList)
14:34:50 <lambdabot> IsList l => ([Item l] -> Maybe b) -> [l] -> [b]
14:34:51 <connney> how can I get 123.45 :: Decimal if I have two Integers?
14:34:52 <dmj`> james_rth: it exports the MonadLogger IO instance
14:34:55 <arkeet> oops
14:34:57 <arkeet> :t mapMaybe . (toList .)
14:34:58 <lambdabot>     Couldn't match type ‚Äò[Item l]‚Äô with ‚ÄòMaybe b‚Äô
14:34:59 <lambdabot>     Expected type: l -> Maybe b
14:34:59 <lambdabot>       Actual type: l -> [Item l]
14:35:02 <arkeet> :t toLIst
14:35:03 <lambdabot>     Not in scope: ‚ÄòtoLIst‚Äô
14:35:03 <lambdabot>     Perhaps you meant one of these:
14:35:03 <lambdabot>       ‚ÄòF.toList‚Äô (imported from Data.Foldable),
14:35:04 <arkeet> :t toList
14:35:05 <lambdabot> IsList l => l -> [Item l]
14:35:06 <arkeet> ahhhhh
14:35:11 <james_rth> dmj` nice
14:35:12 <Denommus> arkeet: of course it is different, but instead of using a function that gives Just foo or Nothing you use a function that gives [foo] or []
14:35:18 <webchat099> bibliography for mobile haskell code?
14:35:20 <connney> connney: how can I get 123.45 :: Decimal if I have two Integers: 123 and 45
14:35:20 <arkeet> Denommus: sure.
14:35:57 <arkeet> connney: convert both to decimal, divide the second by 100, and add?
14:36:03 <WJWH> james: glad you found it :)
14:36:05 <arkeet> :t fromIntegral
14:36:06 <lambdabot> (Integral a, Num b) => a -> b
14:36:13 <james_rth> legendary!!!
14:36:15 <WJWH> or at least something
14:36:15 <connney> decimal part may be more than 2 digits
14:36:20 <arkeet> okay, how do you get 123.05
14:36:38 <connney> hmm
14:37:23 <arkeet> :t (=<<) . (F.toList .)
14:37:24 <lambdabot> Foldable t => (a -> t b) -> [a] -> [b]
14:37:47 <connney> good point.. how do I handle that? I am parsing a number that cant be passed directly to reads
14:38:00 <arkeet> connney: what exactly are you trying to do?
14:38:04 <connney> since it can have thousands separators
14:38:12 <Dodecahedrus> is there a better option than reverse . sort to sort in inverse order? from what i understand reverse isn't very fast, is it?
14:38:29 <arkeet> Dodecahedrus: reverse is linear time
14:38:36 <arkeet> but it adds some extra time yes.
14:38:55 <arkeet> :t sortBy (flip compare)
14:38:56 <lambdabot> Ord a => [a] -> [a]
14:39:02 <arkeet> > sortBy (flip compare) [3,2,4,1,5]
14:39:04 <lambdabot>  [5,4,3,2,1]
14:39:07 <kadoban> > sortBy (comparing Down) [1..5]
14:39:09 <lambdabot>  [5,4,3,2,1]
14:39:11 <arkeet> that does it too.
14:39:20 <Dodecahedrus> arkeet: nice that flip, thanks
14:39:32 <arkeet> > Down 1 > Down 2
14:39:33 <connney> it also doesnt use . but , as a decimal separator.. so: "1.000,05" -> 1000.05. I am parsing it with Parsec, and I parsed it into two Integers, but as you demonstrated that wont work well
14:39:34 <lambdabot>  True
14:40:03 <arkeet> connney: just make a list of digits before and after the decimal separator?
14:40:31 <arkeet> or filter out the .s and change , to . and then use an existing decimal parser
14:40:38 <connney> and prepend "0." to decimal String before passing it to reads?
14:40:52 <arkeet> no need to reads.
14:41:05 <dmj`> > read (show (123 :: Integer) ++ "." ++ show (45 :: Integer)) :: Double
14:41:07 <lambdabot>  123.45
14:41:53 <webchat099> there have been no advance in mobile haskell code since the year 2001?  http://www.dcs.gla.ac.uk/~trinder/papers/strongm.pdf
14:42:06 <arkeet> > read . map (\x -> if x == ',' then '.' else x) . filter (/= '.') $ "1.000,05" :: Doubl
14:42:08 <lambdabot>      Not in scope: type constructor or class ‚ÄòDoubl‚Äô
14:42:08 <lambdabot>      Perhaps you meant ‚ÄòDouble‚Äô (imported from Prelude)
14:42:09 <arkeet> > read . map (\x -> if x == ',' then '.' else x) . filter (/= '.') $ "1.000,05" :: Double
14:42:11 <lambdabot>  1000.05
14:42:16 <arkeet> I dunno.
14:44:03 <webchat099> arkeet you can talk with lambdabot in private
14:44:16 <arkeet> so?
14:44:21 <connney> I would like to validate it though.. so "1...23" shouldnt be parsed
14:44:44 <connney> webchat099: he was helping me
14:44:53 <webchat099> just that
14:45:01 <webchat099> Ah ok
14:47:17 <arkeet> connney: well, you can probably make something from scratch in parsec that validates such a numeral
14:47:28 <arkeet> and gives you the lists of digits before and after the decimal separator
14:47:35 <arkeet> and then you can make a number from those lists.
14:48:14 * hackagebot lentil 0.1.1.3 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.1.3 (fffaaa)
14:48:57 <connney> yeah I will try
14:50:43 <bitemyapp> @pl \b c -> fold (traverse c b)
14:50:43 <lambdabot> (fold .) . flip traverse
14:52:39 <arkeet> > foldl' (\a d -> d + 10*a) 0 [1,2,3]
14:52:41 <lambdabot>  123
14:52:48 <arkeet> > foldr (\d a -> (fromIntegral d + a) / 10) 0 [1,2,3]
14:52:49 <lambdabot>  0.123
14:52:52 <simon> you don't call zip a catamorphism, do you? I mean, it folds two lists. what do you call the domain when it has two lists as inputs, and is it a catamorphism, or is there a more appropriate term?
14:53:05 <hexagoxel> bitemyapp: ty ty :) i really wish i had a bit more time to work on optimizations and other improvements
14:55:39 <bitemyapp> hexagoxel: your (and spitzner's, right?) work just murdered 29 lines of code
14:55:52 <bitemyapp> hexagoxel: very very impressive. how do I get it running locally though?
14:56:03 <bitemyapp> hexagoxel: I had a hard time figuring out what I was supposed to build (exference-*)
14:57:51 <rbocquet> i think lambdabot should have coloured output !
14:58:08 <connney> Decimal is arbitrary precision decimal point, so why does "1/3" and then "it * 3" give me 0.9999999...
14:58:15 <connney> decimal point number*
14:59:29 <DNoved1> 0.9999999.... = 1 though :P
14:59:30 <bitemyapp> yeah it's exference-exference like I figured but ow.
15:00:34 <burp> Decimal /= Fractionals, so maybe it's not what you want/expect https://hackage.haskell.org/package/Decimal-0.4.2/docs/Data-Decimal.html
15:00:41 <arkeet> arbitrary precision /= infinite precision
15:00:45 <burp> (1/3) :: Decimal          = 0.33333333333333...
15:00:50 <lspitzner> bitemyapp: same person behind second account :p
15:01:34 <arkeet> scientific stores numbers as an integer with a decimal exponent I think
15:01:38 <burp> connney: try Rational from Prelude
15:01:41 <arkeet> so if you try to do 1/3 it'll fail to terminate.
15:01:48 <lspitzner> bitemyapp: hmm yeah, that is understandably confusing
15:01:49 <arkeet> and maybe consume all memory.
15:02:10 <lspitzner> bitemyapp: i am still not sure if splitting the project into two packages was a good idea at all :/
15:02:13 <mniip> arkeet, or you could represent them as infinite lazy binary streams
15:02:16 <lspitzner> probably not
15:02:17 <mniip> where 1/3*3 is a bottom
15:02:19 <bitemyapp> lspitzner: I don't think it was.
15:02:20 <arkeet> mniip: I'm describing what the scientific package does.
15:02:31 <arkeet> there are various ways to represent numbers.
15:02:38 <burp> > 1%3 * 3
15:02:39 <lambdabot>  1 % 1
15:02:41 <bitemyapp> lspitzner: library and executable yes, two projects + two repos doesn't seem compelling though.
15:02:55 <bitemyapp> lspitzner: if I do the legwork, will you adopt a unified version?
15:02:56 <arkeet> Rational is probably a pretty reasonable thing to use a lot of the time.
15:04:59 <lspitzner> bitemyapp: certainly. the core should still be kept logically separate, maybe with a different module-id-prefix
15:08:14 * hackagebot inline-c 0.5.3.3 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.3.3 (FrancescoMazzoli)
15:08:16 * hackagebot inline-c 0.5.3.4 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.3.4 (FrancescoMazzoli)
15:15:33 <hiptobecubic> "...you can also think of inline-c as to Haskell what inline Assembly is to C ‚Äî a convenient means to eke out a little bit of extra performance in those rare cases where C still beats Haskell."   That's a pretty optimistic assessment I'd say.
15:18:56 <mitchty> so use haskell with inline-c with inline assembly and get all the speed! :D
15:24:38 <mniip> if only assembly had inline haskell
15:29:58 <connney> round (read string)  <- what type does read return?
15:30:23 <connney> :t round
15:30:25 <lambdabot> (Integral b, RealFrac a) => a -> b
15:30:58 <connney> and does it depend on the what Integral I use it as?
15:31:10 <mniip> > round (read string `asTypeOf` _)
15:31:11 <lambdabot>      Not in scope: ‚Äòstring‚Äô
15:31:11 <lambdabot>      Perhaps you meant one of these:
15:31:11 <lambdabot>        ‚Äòstoring‚Äô (imported from Control.Lens),
15:31:16 <mniip> > round (read "" `asTypeOf` _)
15:31:18 <lambdabot>      Found hole ‚Äò_‚Äô with type: Double
15:31:18 <lambdabot>      In the second argument of ‚ÄòasTypeOf‚Äô, namely ‚Äò_‚Äô
15:31:18 <lambdabot>      In the first argument of ‚Äòround‚Äô, namely ‚Äò(read "" `asTypeOf` _)‚Äô
15:31:25 <mniip> defaulting rules kicking in
15:32:03 <connney> > round (read "" `asTypeOf` _) :: Integer
15:32:05 <lambdabot>      Found hole ‚Äò_‚Äô with type: Double
15:32:05 <lambdabot>      In the second argument of ‚ÄòasTypeOf‚Äô, namely ‚Äò_‚Äô
15:32:05 <lambdabot>      In the first argument of ‚Äòround‚Äô, namely ‚Äò(read "" `asTypeOf` _)‚Äô
15:34:14 <reqq456> i want to list all fibonacci numbers up to a specific border
15:34:39 <aweinstock> :t round . read
15:34:41 <lambdabot> Integral c => String -> c
15:34:42 <c_wraith> reqq456: that's easiest to do by starting with listing all fibonacci numbers, then just getting the ones below the border.
15:34:49 <reqq456> i have this code, but he didnt stop calculating :D http://paste2.org/UKcnHVt6, he isnt never stopping the constructiioning of the list
15:35:17 <mniip> reqq456, it keeps looking through the list looking for small numbers
15:35:23 <c_wraith> reqq456: wow, that's going to be *slow*
15:35:36 <mniip> it can't possibly know the sequence is only increasing
15:35:58 <mniip> you have to use 'takeWhile', which ends the list at the first element that doesn't satisfy the condition
15:36:16 <reqq456> thank you i will look for it
15:36:34 <mniip> also as c_wraith, your fibonacci implementation is inefficient
15:36:39 <c_wraith> reqq456: also, that's using an exponential-time algorithm and not caching any work.  It's going to be *very* slow.
15:48:51 <connney> if I have this inside Parsec do how can I report parsing error? case readMat str of  Just x -> return x; Nothing -> ????
15:48:58 <connney> readMay
15:49:27 <ion> empty or fail "message"
15:49:59 <ion> or empty <?> "message"
15:51:04 <ion> or unexpected "message"
15:51:57 <connney> is any of them preferred or should I just pick any
15:53:35 <DNoved1> I've heard several places that having a dependent type system where (Type : Type) allows you to construct a member of any type, even the empty one, but I've never seen an example of such. Does anyone know of one?
15:53:54 <ion> connney: See the description about the different kinds of messages in http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Error.html#t:Message
15:58:15 <ion> empty <?> "message" is probably something you‚Äôll never actually want. unexpected (show str) might be appropriate here.
15:58:28 <connney>  btw If I reading a word and then report error if readMay returns Nothing then Column  in the Parsec error wont match the beginning of that token. how can I handle that?
15:58:39 <connney> +ing
16:01:34 <DNoved1> I believe the function 'try' backtracks, perhaps that will work?
16:03:02 <hodapp> am I allowed to call it "existential quandary" if I abused existentials and in the midst of the type errors forgot what I was here to do?
16:03:24 <subleq> what is existential abuse?
16:03:48 <hodapp> overusing existentials to solve problems that aren't exactly there.
16:06:16 <hodapp> Philonous: now, were you saying that existentials don't do you any real good if you lack any typeclass constraints because it's really only typeclass constraints that provide meaningful operations you can do on the value?
16:06:37 <Chobbes> DNoved1: in Idris Type : Type, except it's secretly sort of Type : Type1, Type1 : Type2, etc... IIRC
16:07:02 <codygman> According to Monad Transformers Step By Step, it looks like Data.Map.lookup used to have a monad fail instance? I don't see it anymore, was this bad to use in practice? What is used instead?
16:07:08 <subleq> hodapp: you can put the operations in the existential too, like a typeclass dict
16:09:17 <DNoved1> Chobbes: Yes, I've heard that stratifying types like that, having levels so to speak, prevents the loophole that enables construction of an element of any type, but I'm curious what the loophole itself is.
16:09:53 <DNoved1> Things I read always seem to point to Russel's paradox, but I don't quite see how that would enable creating an element of Void, say.
16:10:05 <Chobbes> http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf
16:10:12 <Chobbes> DNoved1: look at section 12.8
16:11:40 <Chobbes> DNoved1: oh good, the paper in the footnote is in French http://www.cs.cmu.edu/~kw/scans/girard72thesis.pdf ;)
16:12:23 <Chobbes> DNoved1: supposedly this is a good reference... http://www.cs.cmu.edu/~kw/scans/hurkens95tlca.pdf
16:12:35 <hodapp> subleq: what do you mean?
16:12:48 <geekosaur> codygman, it was removed. Back In The Day it was intended to allow you to request the result as Maybe vs. list etc., but this was found to be a bad idea in practice so it's just Maybe now.
16:14:16 <connney> foldr (<|>) empty (map caseInsensitiveString ["foo","bar"])
16:14:25 <connney> is this appropriate use of empty?
16:14:26 <DNoved1> Chobbes: Thanks, that looks like it's what I'm looking for.
16:15:46 <Chobbes> DNoved1: no problem, good luck on your quest of type theory goodness :).
16:16:21 <arkeet> connney: sure
16:16:28 <arkeet> connney: note that Data.Foldable has asum = foldr (<|>) empty
16:16:50 <connney> ah cool
16:16:53 <arkeet> also, depending on what caseInsensitiveString is
16:16:56 <connney> :t asum
16:16:56 <arkeet> (particularly, it's result type)
16:16:57 <lambdabot>     Not in scope: ‚Äòasum‚Äô
16:16:57 <lambdabot>     Perhaps you meant one of these:
16:16:57 <lambdabot>       ‚ÄòF.asum‚Äô (imported from Data.Foldable),
16:17:02 <arkeet> you might just be able to 
16:17:09 <arkeet> foldMap caseInsensitiveString ["foo","bar"]
16:17:11 <connney> String -> Parser String
16:17:18 <arkeet> its*
16:19:01 <connney> Parser String is not a Monoid it said
16:19:58 <arkeet> oh, it's a Parser
16:20:00 <arkeet> okay.
16:20:12 <codygman> geekosaur: Thanks
16:20:19 <arkeet> (maybe it should be a monoid!)
16:20:22 <connney> asum worked nicely
16:20:34 <arkeet> you can also fuse the fold and map
16:20:46 <arkeet> foldr f z . map g = foldr (f . g) z
16:20:53 <arkeet> if you want to do it that way
16:20:57 <arkeet> but I think asum is clearer
16:21:05 <ion> GHC might very well fuse that for you.
16:21:09 <arkeet> it might.
16:21:13 <arkeet> I don't know.
16:53:20 * hackagebot relational-query 0.5.0.2 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.5.0.2 (KeiHibino)
16:58:20 * hackagebot sql-words 0.1.3.1 - Simple idea SQL keywords data constructor into OverloadedString  http://hackage.haskell.org/package/sql-words-0.1.3.1 (KeiHibino)
17:05:03 <dmj`> go hawks
17:05:26 <hodapp> who?
17:08:33 <codygman> For adding logging to a Monad transformer stack, do most of you here use LoggingT from monad-logger?
17:09:13 <Cale> I would use WriterT if I was for some reason compelled to use a monad transformer at all
17:10:01 <codygman> Cale: What about it leaking memory? http://www.haskellforall.com/2014/02/streaming-logging.html
17:10:41 <Cale> codygman: Well, over IO, I wouldn't use a monad transformer at all.
17:11:46 <codygman> Cale: You sound like you prefer not using monad transformers? How would you accomplish the simple interpreter created in http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf?
17:11:58 <codygman> Cale: Hm, okay.
17:12:34 <dmj`> codygman: you could put a message on a Chan, then have a thread blocking on the read end, listening for messages. It's described in marlow's book
17:12:35 <Cale> IO already has lots of stuff which you can use, like threads and Chan.
17:12:44 <Cale> Yes, exactly :)
17:12:59 <dmj`> Cale: :)
17:13:30 <codygman> Cale: I'm more asking if you are saying that Monad transformers as used in the paper I linked are a bad architectural pattern.
17:13:34 <codygman> dmj`: I'll check that out, thanks.
17:13:50 <Cale> At the top level of my program, I'd create a Chan, and set up a thread reading it and doing whatever was required to process the log messages (write to file or whatever), and then I would pass (writeChan c) to the rest of my program.
17:14:23 <Cale> codygman: Monad transformers are not inherently bad, but they are in my opinion heavily overused.
17:16:04 <codygman> Cale: Alright, thanks.
17:16:30 <vikaton> do companies often ask to see if you know FP, even though the job is about FP ?
17:16:40 <Cale> They're an option that you have for constructing certain types of libraries. I don't think it's usually a terribly good idea to leave your use of monad transformers exposed -- it tends to be better to newtype whatever monad you've constructed and try to hide the fact that you've used monad transformers to implement it, by exporting all the things you'll need from the given module, and not the newtype data constructor.
17:17:27 <dmj`> vikaton: you mean if the job "isn't" about FP?
17:17:49 <vikaton> dmj`: yeah right, dunno why thats there haha
17:18:29 <codygman> Cale: That sounds reasonable.
17:21:33 <blackdog> hi all. Anyone know how to get haskell-mode not to pop up the stylish error buffer when i have a syntax error?
17:23:44 <vikaton> http://www.yesodweb.com/
17:24:23 <vikaton> whoops
17:32:33 <tempay> so I thought the type signatures of map, filter, etc. would be Traversable/Foldable in GHC 7.10?
17:33:22 * hackagebot DSA 1 - Implementation of DSA, based on the description of FIPS 186-4  http://hackage.haskell.org/package/DSA-1 (AdamWick)
17:33:30 <KaneTW> :t map
17:33:31 <lambdabot> (a -> b) -> [a] -> [b]
17:33:37 <KaneTW> huh
17:33:48 <KaneTW> apparently not yet
17:33:52 <KaneTW> :t foldr
17:33:53 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:34:49 <tempay> I'm lost, wasn't that the suggestion of FTP?
17:35:13 <LordBrain> i think they only generalized the ones where there was only one obviously preferable generalization
17:35:46 <Axman6> lambdabot doesn't necessarilly reflect the latest state of the art
17:36:09 <tempay> is there a list of functions that were changed somewhere?
17:37:24 <kadoban> Axman6: It's definitely using 7.10.x, and was pretty early to switch. I would be somewhat surprised if only some of its stuff was updated, that'd be odd?
17:38:00 <ion> map wasn't generalized and i don't know why (perhaps someone deemed it's not in the scope of FTP, not actually being either Foldable or Traversable).
17:38:49 <Axman6> it probably wasn't generalised because fmap is already in the rpelude
17:39:09 <tempay> huh, okay
17:39:48 <ion> OTOH, there is precedence for aliases of fmap being in Prelude. :-P
17:40:45 <tempay> oh, they added <$> too, sweet
17:48:22 * hackagebot aeson-better-errors 0.8.0 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.8.0 (hdgarrood)
18:23:12 <ReinH> ion: the original argument for map vs. fmap is that map specialized to [] gives better errors for beginners
18:28:16 <joneshf-laptop> ReinH, we don't still believe that do we?
18:28:51 <geekosaur> if we did, BBP wouldn't have happened
18:30:15 <c_wraith> :t map
18:30:16 <lambdabot> (a -> b) -> [a] -> [b]
18:30:22 <c_wraith> didn't get generalized with the rest of them..
18:30:28 <c_wraith> :t filter
18:30:29 <lambdabot> (a -> Bool) -> [a] -> [a]
18:30:47 <rvxi> hi
18:30:53 <c_wraith> Oh, I guess filter really only makes sense with more limited types than Foldable or Traversable
18:31:13 <kadoban> Really, why?
18:32:32 <c_wraith> What shape do you have left if you filter an internal node out of a binary tree?
18:32:39 <arkeet> :t \p -> foldr (\x -> if p x then (pure x <|>) else id))
18:32:40 <lambdabot> parse error on input ‚Äò)‚Äô
18:32:56 <arkeet> :t \p -> foldr (\x -> if p x then (pure x <|>) else id) empty
18:32:57 <lambdabot> (Foldable t, Alternative f) => (a -> Bool) -> t a -> f a
18:33:45 <arkeet> foldable/traversable don't really provide any way to change the shape of a structure.
18:33:51 <arkeet> also related:
18:33:52 <arkeet> @hackage witherable
18:33:52 <lambdabot> http://hackage.haskell.org/package/witherable
18:33:55 <kadoban> Hmm
18:33:59 <arkeet> generalizes filter and such
18:41:07 <kadoban> That's interesting
19:03:18 <dolio> The new map vs. fmap argument is that it's not enough of an improvement to justify whatever breakage it causes.
19:03:29 <dolio> Although I'm not sure it breaks much of anything, really.
19:10:10 <guest98231> is it possible to parse/evaluate ranges? either with base or third party packages.. "[1,2..10]" -> [1,2,3,4,5,6,7,8,9,10]
19:10:23 <guest98231> ideally it would work with all enums
19:10:34 <zacharypch> total newb here -- just trying to get cabal set up, working with most recent haskell-platform inc ghc 7.8.3 on ubuntu,  trying to get SublimeText plugin working.  Stuck on first step, trying to `cabal install aeson`, I get an error on a bunch of dependencies: user error (/usr/bin/ld: cannot find -lgmp).  libgmp.so.10.2.0 is in /usr/lib/something
19:12:13 <pacak1> guest98231: From string representation? You'll have to parse it and then put into [] or use enumFromThenTo
19:12:50 <guest98231> pacak1 could some of those packages with eval-like functionality do it? I forgot their names
19:13:25 <zacharypch> ach nevermind i needed the -dev package, got it
19:21:08 <guest98231> > [1,2..10]
19:21:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:21:23 <guest98231> how does lambdabot do it :)
19:22:51 <srhb> guest98231: There's nothing special in what lambdabot does. It's translated into one of the enumFrom* functions
19:24:16 <guest98231> srhb but not by lambdabot code
19:24:44 <srhb> guest98231: I'm assuming this is just via hint.
19:26:04 <srhb> guest98231: So it's something like eval "[1..10]"
19:27:43 <srhb> guest98231: It's probably even simpler, and using mueval.
19:28:04 <srhb> (Which is a small library in front of hint)
19:33:27 * hackagebot snaplet-acid-state 0.2.7 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.7 (DougBeardsley)
19:51:04 <mmachenry> Is there a convenient library that will parse a time of day, independent of dates? Data.Time.Clock gives DiffTime as a data type but it's not an instance of ParseTime so I can't read strings in the form "10:30" and get a DiffTime easily.
19:54:19 <RyanGlScott> Can someone help me understand this issue with RankNTypes? http://lpaste.net/134566
19:54:36 <Cale> mmachenry: I think maybe you want to parse a TimeOfDay and convert that to a DiffTime?
19:54:47 <shachaf> RyanGlScott: Forall is the same as Identity
19:55:02 <shachaf> Oh, I guess it isn't.
19:55:16 <RyanGlScott> shachaf: This isn't going to be used in production or anything, it's just a boiled-down version of strange behavior I encountered.
19:55:44 <shachaf> GHC has The error from GHC is pretty odd.
19:55:49 <Cale> RyanGlScott: Look at the type of runForall
19:55:57 <Cale> It has a higher rank type
19:56:19 <RyanGlScott> Cale: How come pattern-matching on Forall doesn't use the same type signature?
19:56:23 <Cale> Unifying the type of runForall with the type of (.) won't work because GHC will never instantiate a type variable with a polytype
19:56:45 <vikaton> does Haskell teach you mathematical concepts you havent dealt with before if all you know is Algebra?
19:57:01 <mmachenry> Cale: I'll check that out.
19:57:17 <shachaf> GHC 7.10 won't even accept Forall
19:57:18 <Cale> RyanGlScott: Try  mapForallRecord f x = Forall (f (runForall x))
19:57:23 <shachaf> Hmm, it does accept it.
19:57:29 <shachaf> Just not with all my extensions.
19:57:56 <shachaf> Which extension could be causing it to not accept that type?
19:58:13 <Cale> hm?
19:58:25 <Cale> anyway, mapForallRecord f x = Forall (f (runForall x)) will compile
19:59:44 <RyanGlScott> Huh. I Simon should have injected (.) with the same magic as ($), then.
19:59:56 <Cale> This is basically the same reason that  runST . return  won't compile
20:00:09 <Cale> I kind of hate that magic
20:00:41 <shachaf> Oh, it's PolyKinds.
20:00:55 <RyanGlScott> shachaf: Are you using 7.10?
20:01:07 <shachaf> Yes. PolyKinds makes that type not compile in 7.10.
20:01:29 <RyanGlScott> PolyKinds seems to be pretty broken in 7.10, sadly https://ghc.haskell.org/trac/ghc/ticket/10524#ticket
20:01:41 <shachaf> Because it's existential in the kind.
20:01:46 <RyanGlScott> (That and Typeable, but someone else caught that before I did.)
20:02:09 <shachaf> How's Typeable broken?
20:02:21 <Cale> shachaf: Does adding an explicit kind signature to the x help?
20:02:29 <Cale> Well, I suppose I could check myself
20:02:32 <shachaf> Cale: The problem is that it's existential.
20:02:38 <RyanGlScott> Try enabling PolyKinds and running
20:02:43 <shachaf> It's kind of funny. I can see why it doesn't like it.
20:02:44 <RyanGlScott> typeOf (Proxy :: Proxy Proxy)
20:03:14 <Cale> shachaf: Yeah, so if you just use forall (x :: *). it'll work
20:03:28 * hackagebot attoparsec-trans 0.1.1.0 - Interleaved effects for attoparsec parsers  http://hackage.haskell.org/package/attoparsec-trans-0.1.1.0 (srijs)
20:03:46 <RyanGlScott> This bug covers it (I think) https://ghc.haskell.org/trac/ghc/ticket/10343
20:03:53 <shachaf> RyanGlScott: Oh, sure. That was me, I think.
20:04:02 <shachaf> Or maybe that was a different one.
20:04:23 <vikaton> has anyone here experienced changes in the way they code imperative languages after haskell ?
20:05:10 <Cale> vikaton: Yeah, mostly: I avoid programming in non-functional languages
20:05:15 <RyanGlScott> Heh
20:05:23 <c_wraith> Does "more frustration" count?
20:05:27 <shachaf> Cale: Right.
20:05:41 <vikaton> c_wraith: in what way?
20:05:47 <c_wraith> I've been using java a bunch the last few days.  I keep going "where's the ability to just say what I mean?"
20:06:00 <vikaton> oh lol
20:06:01 <tejing> vikaton: I find myself writing the code in haskell in my head, then translating it
20:06:15 <vikaton> tejing: is it easy to?
20:07:26 <Cale> vikaton: But also, I really do program differently -- I'm far more suspicious of any mutation, and will use immutable structures whenever I can get away with it. I avoid writing "functions" which alter something instead of producing a result as much as possible (which I suppose is another way to say the same thing)
20:07:33 <Chobbes> c_wraith: try passing a function to another function :>
20:07:44 <Chobbes> (Assuming you're pre-Java 8)
20:07:48 <Cale> (but it also applies even when the structures are potentially mutable)
20:07:53 <c_wraith> Chobbes: I've been trying.  Java 8 makes it *almost sort of* work.
20:08:15 <shachaf> I wish GHC turned Forall into Identity.
20:08:38 <Chobbes> c_wraith: yeah, good luck buddy. I *may* have been a little too close to a trip to the mental hospital the last time I had to do Java work ;).
20:09:16 <Chobbes> c_wraith: you can always make an abstract class factory or whatever the hell the alternative is. It's totally super clear and reasonable and concise.
20:09:38 <RyanGlScott> shachaf: Are there any other semantic differences between Forall and Identity?
20:09:52 <shachaf> Other than what?
20:10:25 <RyanGlScott> I'm wondering what would happen if GHC eliminated unused type variable binders in foralls.
20:10:50 <vikaton> Nice Cale
20:11:01 <RyanGlScott> Would treating Forall exactly like Identity cause any problems with existing code?
20:11:03 <Cale> vikaton: I sometimes find myself translating imperative code to functional in a highly mechanical way and then applying algebraic simplifications to it in order to try to understand what it does.
20:11:06 <shachaf> It already does, in function types.
20:11:11 <ttt_fff> i'm sure this has been asked alot (as I have often asked it) but have not found a good solution yet -- is there a way in haskell, (via either threepenny or ghcjs), to setup the GUI as a "spreadsheet" and have everything just automatically update + work ?
20:11:12 <shachaf> I should say value types.
20:11:24 <echo-area> vikaton: I find Haskell helps in improving the composability of my programs.  It changes even the way I write in Clojure, which also encourages function programming
20:11:26 <shachaf> :t let f :: forall a b. a -> a; f x = x in f
20:11:27 <lambdabot> a -> a
20:11:34 <ttt_fff> jle`: ping ping ping
20:11:36 <RyanGlScott> Ah, that's pretty neat.
20:12:03 <echo-area> *functional
20:13:25 <vikaton> Niice
20:13:41 <Cale> vikaton: i.e. all the mutable variables in scope become function parameters, and each point of the control flow becomes a function, and each function calls the other functions (perhaps cyclically) based on how the control flow goes. This produces a mess to begin with, but it's a mess which follows nice substitution rules, so you can immediately start eliminating lots of intermediate functions and hopefully get somethin
20:13:41 <Cale> g simple enough to understand what's actually being computed.
20:14:23 <vikaton> I want to know what haskell can teach me outside programming
20:14:34 <vikaton> like mathematics and physics 
20:14:51 <Cale> It's not going to teach you a whole lot of either of those things
20:15:34 <kadoban> I'd be surprised if it taught you any physics. It might suggest some category theory to study, but other than that it probably won't teach you a lot of math either.
20:15:45 <rvxi> well actually
20:15:47 <echo-area> Cale: Not even a little of maths?
20:15:50 <Cale> But there's a bunch of mathematics which we steal and stomp on a bunch until it fits inside Haskell, and there are some jumping off points there where you'll at least have a few examples of some abstraction to start off with if you know Haskell.
20:15:50 <rvxi> wouldn't it be interesting to try
20:16:04 <rvxi> http://mitpress.mit.edu/sites/default/files/titles/content/sicm/book.html
20:16:06 <rvxi> in haskell?
20:16:31 <rvxi> in fact https://github.com/chris-taylor/Classical-Mechanics
20:16:58 <rvxi> physics via functional programming :)
20:17:18 <DNoved1> vikaton: I think haskell has made me a worse programmer, at least for dynamic-typed languages like javascript. I've become accustomed to the fact that if my program typechecks, it's likely correct, so I test less often.
20:17:38 <rvxi> ouch
20:17:46 <DNoved1> One reason I'm very interested in projcts such as the new flow
20:17:48 <Cale> DNoved1: I maybe test less often, but I worry a whole lot more.
20:17:52 <kadoban> DNoved1: Heh, that hasn't been my experience. I get paranoid in other languages and test more. Also I have a better understanding for what types I'm using implicitly.
20:18:34 <Cale> I'm usually not as interested in what tests will tell me as what reasoning about what the code does will tell me though.
20:18:49 <DNoved1> Cale: oh ya, I worry a lot too, and for good reason - I can't even be sure I haven't misspelled variable names
20:19:05 <echo-area> Oh, you are saying learning e.g. category theory for the sake of knowing Haskell doesn't count as Haskell teaching something
20:19:13 <Cale> Testing is so much more of a hassle without QuickCheck
20:19:27 <dmj`> DNoved1: haskell has made me test more, since the code is so modular it lends itself to testing
20:19:31 <vikaton> has Haskell made any of you guys better problem solvers?
20:19:41 <Cale> echo-area: You don't need to know any actual category theory in order to be good at programming in Haskell though.
20:20:09 <Cale> echo-area: You just need to know about the Haskell specialisations of various things that have been taken from category theory, which are probably easier to understand just directly.
20:20:44 <Cale> Sure, you might develop an interest for category theory by programming in Haskell and wondering about how these ideas generalise to other areas of mathematics
20:20:48 <echo-area> Cale: I see.  But I am so interested so I will learn such things :)
20:20:51 <Cale> yeah
20:21:40 <vikaton> maybe from Project Euler? :P
20:22:00 <Cale> vikaton: I can't really say. I was already studying pure mathematics at university by the time I started programming in Haskell.
20:22:32 <Cale> The same kinds of thought processes apply though, and learning pure mathematics definitely gives you a good sense of how to apply logical reasoning to solving problems.
20:23:08 <vikaton> Cale, maybe the problem solving in terms of creating algorithms, not exclusively math problems
20:23:54 <Cale> vikaton: There's a formal connection between terms vs. types in lambda calculi and proofs vs. propositions in logic.
20:24:10 <Cale> (they are secretly the same thing)
20:24:37 <Cale> Writing programs in a lambda calculus is essentially the same activity as proving theorems in a certain kind of logic.
20:25:26 <Cale> Haskell programmers are really applied logicians who are proving boring theorems in interesting ways in an inconsistent intuitionist logic. :)
20:26:08 <vikaton> Cale: I'm a 10th grade high school, so I don't know anything you just said :D
20:26:19 <heatsink> It's easier to learn formal logic if you have learned Haskell first.
20:26:34 <vikaton> hopefully
20:26:51 <kadoban> Cale: Haha
20:27:22 <kadoban> I kinda want to put that on a resume somewhere now ...
20:28:29 * hackagebot Strafunski-StrategyLib 5.0.0.8 - Library for strategic programming  http://hackage.haskell.org/package/Strafunski-StrategyLib-5.0.0.8 (JamesKoppel)
20:28:52 <Cale> vikaton: The start of the connection is that in logic, if you know that A is true, and you know that A -> B (that is, "if A then B", or "A implies B"), then you can deduce that B is true.
20:29:12 <Cale> vikaton: In lambda calculus, if you have x : A, and you have f : A -> B, then you have f x : B
20:29:26 <vikaton> I see
20:29:39 <Cale> In logic, if you want to prove that A -> B, you start by assuming A, and attempting to deduce B
20:29:41 <vikaton> I concur
20:30:16 <vikaton> well I gtg, thanks :P
20:30:21 <Cale> In lambda calculus, if you want to construct a function f : A -> B, you start by assuming you have some variable x : A, and attempt to construct an expression y : B, and then (\x -> y) : A -> B
20:30:42 <Cale> Okay, see you!
20:31:27 <echo-area> So gtg is "get to go".  I thought it was "get the gist"
20:34:37 <hnfmr> is my understanding of QSem correct? with the "bracket waitQSem signalQSem ...." pattern, multiple threads proceed if the QSem quantity is greater than 1, and block if QSem is 0?
20:36:01 <Cale> hnfmr: That's right
20:36:21 <hnfmr> Cale: thanks
20:36:40 <Cale> hnfmr: (specifically, if the value of the QSem is n, then n of them will be unblocked)
20:37:08 <hnfmr> and it can't be negative right?
20:37:12 <Cale> right
20:39:12 <DNoved1> Is there a relatively simple haskell implementation amenable to backend changes, kinda like the ML-kit?
21:03:38 <Pamelloes> In general, is it preferred to have a parameter of type Monad m => [m a] or m [a] since the types can easily be converted?
21:04:06 <arkeet> you can only convert one way.
21:04:19 <Pamelloes> Really?
21:04:26 <arkeet> you can't go m [a] -> [m a]
21:05:01 <Pamelloes> Oh you're right. You can go m [a] to m [m a], which isn't really the same thing at all :/
21:06:24 <Pamelloes> Still, though, is there a general trend where one occurs more often than the other
21:07:30 <Pamelloes> Actually, is there even a reason where someone might want [m a] instead of m [a]?
21:09:27 <sccrstud92> Pamelloes: you can reverse the order of effects in the first one
21:09:32 <sccrstud92> in the second you cant
21:10:34 <arkeet> taking m [a] is less demanding
21:10:44 <arkeet> because you can alawys turn [m a] into m [a]
21:10:51 <arkeet> so if all you need is m [a] then go with that.
21:11:39 <crocket> Does haskell have linear types?
21:13:07 <johnw> crocket: no, but I found this presentation: http://www.ioc.ee/~tarmo/tsem11/jeltsch1602-slides.pdf
21:13:20 <Pamelloes> sccrstud92: Hm, that makes sense. I never thought about it that way.
21:13:33 <crocket> Is there a purely functional systems language with linear (instead of affine) types, applicative functors in the module level (making both the module level a lot more powerful and replacing the need for generics and higher kinded traits), strictly evaluated and dependently typed?
21:16:30 <johnw> I don't think it fulfills all of those, but have you looked at Idris?
21:16:33 <codygman> I've been staring at this type error too long and I think it's just something simple, any ideas? http://lpaste.net/134569
21:20:05 <Pamelloes> Is there some form of "state" weaker than a functor?
21:20:08 <johnw> as always in these cases, add type annotations
21:20:53 <Pamelloes> johnw: are you talking to me?
21:21:03 <scutigera> a functor is state ?
21:21:10 <johnw> no
21:21:14 <johnw> to codygman 
21:21:38 <Pamelloes> Alright. I accidentally reset my logs so I lost track of the conversation :/
21:21:45 <scutigera> let me rephrase-  a functor is a form of state ??
21:22:05 <pavonia> State is a Functor
21:23:06 <Pamelloes> Hm, I guess that question was worded poorly...
21:23:18 <pavonia> ((State s) to be precise)
21:24:07 <Pamelloes> A functor is a value with an associated with some additional data, correct?
21:24:34 <pacak> Pamelloes: Functor is a homomorphism between categories.
21:24:56 <pacak> Pamelloes: Identity - no additional data.
21:25:06 <scutigera> holy shit. i _almost_ understand what pacak just said.
21:25:41 * Pamelloes knows homo = same and has a general idea what a morphism is...
21:26:01 <arkeet> Functors are things that support fmap.
21:26:15 <Pamelloes> Right. I understand that.
21:26:17 <arkeet> that's it
21:26:45 <pacak> Mapping between categories that preserve identities and composition.
21:27:03 <scutigera> $hoogle fmap
21:27:08 <scutigera> @hoogle fmap
21:27:09 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
21:27:09 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
21:27:09 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
21:27:10 <pacak> :t fmap
21:27:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:27:58 <Pamelloes> So I understand fmap, I get how to use it. But what makes one type (f a) able to be 'fmapped' over and another type (g a) unable to be?
21:27:59 <scutigera> preserve identities ? so that means that there must be an identity "thing" and a Functor can only map it to identity and not something else ??
21:28:00 <kadoban> Pamelloes: I'm still not really sure what you were actually asking :-/ Is it a CT thing, or a haskell thing, or possibly both?
21:28:20 <kadoban> (wrote that before your last line, heh, maybe ignore)
21:28:35 <Cale> Pamelloes: Well, in general, it's just whether it's possible to write a suitable fmap
21:28:46 <pacak> scutigera: If something is identity in category  A applying functor A -> B should leave it identity in category F A which is B.
21:29:18 <tejing> Pamelloes: there are 2 laws fmap has to follow to be a real functor: 1. fmap id == id, and 2. fmap f . fmap g == fmap (f . g). if there's a way to write it that makes those laws true, then it's a functor... otherwise not
21:29:34 <Cale> Pamelloes: But there are two big classes of functors in Haskell: ones where you can interpret "f a" as being a type of "containers whose elements have type a", and ones where you can interpret "f a" as being a type of "computations whose results have type a"
21:30:04 <Pamelloes> Hm... Can someone give me an example of a type (g a) that is /not/ a functor?
21:30:19 <Cale> Pamelloes: newtype T a = MkT (a -> a)
21:30:20 <shachaf> Cale: These classes overlap.
21:30:24 <arkeet> Cale: those are neither exhaustive nor mutually exclusive.
21:30:25 <Cale> shachaf: indeed
21:30:26 <pacak> :t Proxy
21:30:28 <lambdabot> forall (k :: BOX) (t :: k). Proxy t
21:30:29 <shachaf> In fact the former is a subset of the latter.
21:30:32 <scutigera> pacak: page 194 of Topoi.  I haven't gotten there yet :-)
21:30:49 <Cale> shachaf: Well, both might be exhaustive if you're sufficiently imaginative :)
21:31:03 <Cale> (and arkeet)
21:31:04 <scutigera> after 193 more pages of category theory i'm sure it will be second nature...
21:31:13 <shachaf> Cale: "container" has a defined meaning, anyway.
21:31:25 <Cale> shachaf: Yeah, I don't mean the technical one :)
21:31:43 <Pamelloes> pacak: What is a Proxy and why isn't it a Functor?
21:31:48 <arkeet> Proxy is a Functor.
21:31:54 <codygman> johnw: Alright, will do.
21:31:58 <Pamelloes> Oh. Well then.
21:32:05 <Cale> Pamelloes: Did you see my example?
21:32:34 <Pamelloes> Cale: Hm... alright, I see it. Why isn't it a Functor?
21:32:42 <arkeet> try writing fmap for it.
21:33:01 <pavonia> Is there an example of a type where you can write a Functor instance but the laws don't hold?
21:33:06 <Cale> Pamelloes: Okay, so given a function a -> b, you essentially need to take a function of type a -> a and somehow turn it into a function b -> b
21:33:29 <Pamelloes> Oh, I see. If I try to map (a -> b) I would wind up with (a -> a) . (a -> b) :: (a -> b) =/= (b -> b)
21:33:39 <arkeet> pavonia: sure.
21:33:41 <pacak> Hmm... Right, since you can't put anything it...
21:34:17 <arkeet> you can write an illegal one for the T above
21:34:23 <arkeet> e.g. fmap f _ = T id
21:34:26 <arkeet> MkT id
21:34:30 <Cale> Pamelloes: So, you're basically trying to write a function (a -> b) -> (a -> a) -> b -> b, which is hard, because you can't apply the function (a -> b), since you have no value of type a available, and you also can't apply the function (a -> a) for the same reason. You have a value of type b, but can't use it.
21:34:36 <arkeet> fmap _ _
21:34:36 <arkeet> idk
21:35:14 <arkeet> well, given (a -> b) and (a -> a) and b
21:35:27 <arkeet> you can only use the given b to produce a b
21:35:33 <Cale> Well, right, you can just produce the b you were given and ignore the two functions, that's your only option
21:35:36 <arkeet> (there is no 'a' you can pass to 'a -> b' to produce a 'b')
21:35:50 <arkeet> so the only thing you can write is fmap _ _ = T (\b -> b)
21:35:56 <Cale> (at least, discounting things like loop infinitely)
21:35:58 <arkeet> and you can show that it's not lawful.
21:36:08 <Pamelloes> Right. Alright, that makes sense.
21:36:23 <pavonia> arkeet: Why don't they hold for this example?
21:36:23 <Cale> Yeah, in particular fmap id x = x has to hold, and it won't.
21:36:27 <Pamelloes> Are there any other good examples of things that aren't functors?
21:36:44 <arkeet> pavonia: there are lots of functions A -> A (for some A) that aren't id.
21:37:39 <pavonia> Ah, yes, I'm stupid :/
21:38:40 <Cale> Pamelloes: generally stuff where you have a function whose argument type is based on the parameter type are mostly examples (not always)
21:39:24 <Pamelloes> Cale: exists a. forall b. a -> b is a Functor, right?
21:39:51 <Cale> Pamelloes: You didn't leave any free type variables...
21:40:03 <Pamelloes> Oh, you're right. Lose the forall
21:40:13 <Pamelloes> exists a. a -> b, is a Functor, right?
21:40:18 <arkeet> yes
21:40:31 <Cale> yeah (though it's kind of a silly one)
21:40:34 <Pamelloes> but exists b. a -> b is not.
21:40:36 <arkeet> it's not a useful type though.
21:40:48 <arkeet> (however, exists a. (a, a -> b) is pretty useful
21:40:58 <arkeet> er
21:41:00 <tejing> Pamelloes: that's a contravariant functor
21:41:03 <arkeet> even (f a, a -> b)
21:41:06 <arkeet> even if f isn't a Functor
21:41:09 <arkeet> that's Coyoneda.
21:41:37 <Pamelloes> tejing: What's a contravariant functor?
21:41:48 <arkeet> putting your type parameter on the left of ->
21:42:00 <arkeet> a contravariant functor is something that supports
21:42:02 <arkeet> :t contramap
21:42:03 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
21:42:16 <tejing> ^
21:42:19 <Pamelloes> Oh, I see.
21:42:28 <haasn> a contravariant Functor
21:42:59 <pacak> @hoogle cofunctor
21:43:00 <lambdabot> package cofunctor
21:43:00 <lambdabot> package acme-cofunctor
21:43:10 <Foxhoundz> What is the domain of haskell?
21:43:26 * Pamelloes likes acme-cofunctor.
21:43:36 <Foxhoundz> By that I mean, PHP is suited primarily for web development while C/C++ for general purpose applications
21:43:42 <Foxhoundz> Where does haskell fit in that spectrum
21:43:51 <Hijiri> general purpose applications
21:43:54 <Pamelloes> ^
21:44:12 <Hijiri> which includes web development
21:44:15 <Pamelloes> Though it tends to do better with stuff that involves minimal user input
21:44:43 <Hijiri> I think that might be more of a libraries issue
21:44:51 <Foxhoundz> I'll try my hand at haskell
21:44:51 <Pamelloes> Very true
21:44:55 <pacak> Pamelloes: Yea, non-acme cofunctor looks like a fake package.
21:45:05 <Foxhoundz> if only to bring it up at happy hour with colleagues
21:45:29 <Hijiri> Foxhoundz: I recommend this guide if you do: https://github.com/bitemyapp/learnhaskell
21:45:38 <kadoban> Foxhoundz: Cool, yeah start there ^
21:45:45 <Pamelloes> pacak: I realized a few months ago that everywhere I was using functor, I could use acme's cofunctor and suddenly things would work much better.
21:45:49 <Pamelloes> Haven't looked back since
21:46:11 <Pamelloes> However, the other cofunctor package really messed up a lot of my code :/
21:46:15 <Pamelloes> acme-cofunctor for life!
21:46:37 <arkeet> is that (b -> a) -> f b -> f a?
21:46:44 <Pamelloes> Yep
21:46:47 <arkeet> :-)
21:46:54 <Pamelloes> :D
21:47:01 <pacak> arkeet: That's dual for regular functors.
21:47:09 <arkeet> I know.
21:49:06 <Pamelloes> Alright, so I feel I understand Functor pretty well again.
21:49:30 <tejing> Pamelloes: try to come up with a type that's both a Functor and a Contravariant
21:49:47 <Pamelloes> tejing: Oh god, is that possible?
21:49:57 <tejing> Pamelloes: technically yes
21:50:13 <johnw> hint: it's not going to be terribly useful
21:50:27 <johnw> not at runtime, anyway
21:50:35 <tejing> johnw: except to make the typechecker happy in certain situations :-)
21:50:42 <johnw> yeah, it's quite useful at compile-time
21:50:48 <johnw> lens uses it to very nice effect
21:51:56 <Pamelloes> data CoFuncFunc a = C; fmap f C = C; cofmap f C = C;
21:52:04 <Pamelloes> Is there anything else?
21:52:15 <Pamelloes> Or is that it.
21:52:37 <tejing> Pamelloes: variations on that theme... anything where the parameter is phantom
21:52:50 <scutigera> Well there's a semimonoidal demiring trapped in an obfuscatorial vise
21:52:54 <tejing> Const is the prototypical example
21:52:58 <scutigera> and then that's it
21:53:25 <johnw> tejing: I was thinking of Proxy
21:53:31 <Pamelloes> scutigera: I don't now what most of those words are, but I'm going to assume you do...
21:53:52 <scutigera> i know what a vise is.
21:54:06 <Pamelloes> hehe
21:54:40 <Pamelloes> Isn't that the clamp thing that holds wood (or other materials!) to the workbench?
21:54:42 <scutigera> and ispell doesn't like obfuscatorial. i thought maybe that might actually be a word.
21:55:06 <scutigera> yes. and also to cofunctor widgets when you need to take a type hammer to them.
21:55:07 <tejing> scutigera: it should be...
21:55:50 <Pamelloes> Anyways, what's the purpose of this type that is both a functor and a covariant?
21:56:33 <johnw> Pamelloes: it means the value does not vary with its type, it's always the same value
21:56:52 <johnw> so you can fmap Const c a to Const c b no problem, because there is no a
21:56:58 <johnw> and you can contramap it too, for the same reason
21:56:59 <tejing> Pamelloes: when you write a Fold for use with the lens library, you can avoid the need to rebuild the data structure by using fmap absurd . contramap absurd
21:57:43 <Pamelloes> Hm, I've never really used lens so I'm not quite sure what that means :/
21:58:27 <tejing> Pamelloes: you can get a Const a c from a Const a b, without a function b -> c
21:59:03 <Pamelloes> Ok, that seems like that might be useful in some cases.
21:59:24 <arkeet> johnw: Proxy is just Const ()
21:59:32 <johnw> arkeet: fair enough :)
22:00:06 <arkeet> tejing: actually lens goes via () now instead of Void
22:00:25 <arkeet> both work.
22:00:58 <Pamelloes> Huh. Irssi logged a day change. My other IRC client never des that.
22:01:27 <scutigera> interesting that covariant and contravariant are tensor speak
22:01:55 <Pamelloes> To shift gears a little bit, are there any good examples of things that are functors but not applicatives?
22:02:24 <tejing> Pamelloes: (,) a
22:02:48 <Pamelloes> tejing: (,) a ~= (a,_) right?
22:02:55 <tejing> Pamelloes: yes
22:03:12 <tejing> Pamelloes: though actually there's a fairly trivial applicative instance there
22:03:16 <Pamelloes> Why isn't that an applicative?
22:03:24 <scutigera> i'm lost.
22:03:33 <tejing> I was wrong... forget it :-)
22:03:53 <Pamelloes> Alright, no problem :)
22:05:05 <maxc01> hello, can this form be simplified, f1 :: a -> b -> c -> d, f2 :: d -> e, f3 ab c = f2 $ f1 a b c
22:05:30 <scutigera> you do mean   f3 a b c   right ?
22:05:35 <maxc01> right
22:05:39 <maxc01> just like composition, f2 . f1
22:06:02 <maxc01> this form is sometimes tedious
22:06:12 <Pamelloes> Well, you can do it with a bunch of (.), but it will probably be less readable
22:06:45 <tejing> '((.).(.).(.)) f2 f1 a b c' to be specific
22:06:54 <tejing> but yea... less reabale
22:06:58 <tejing> readable*
22:07:32 <Pamelloes> :t (.).(.)
22:07:33 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
22:07:51 <scutigera> oh - that's just wrong.
22:08:01 <scutigera> the dotssssss. they hurtssssss.
22:08:29 <Pamelloes> Huh, so instead of righting f2 $ f1 a b c, you can right f2 (.).(.).(.) f1?
22:08:47 <maxc01> yes, but this just make it less readable
22:08:47 <tejing> Pamelloes: no. doesn't work as infix notation
22:08:48 <scutigera> no but you can write it. or can you right it ?
22:09:02 <scutigera> it's not right associative, right ?
22:09:10 <Pamelloes> tejing: Oh, I see. That makes sense.
22:09:17 <Pamelloes> Hm, then yeah probably not worth it.
22:09:43 <Pamelloes> I remember reading about owls a while ago, but I didn't realize what it meant at the time. That's kind of cool
22:10:04 <maxc01> if I have to write f2 (.).(.).(.) f1, i'd rather write f2 $ f1 a b c
22:10:09 <scutigera> so i was reading up an applicative and i saw that applicative is between Functors and Monads. Is that right ?
22:10:24 <Pamelloes> scutigera: yep
22:10:43 <scutigera> so it's just a matter of how many "rules" can be followed.
22:10:54 <scutigera> functor things map and map identities
22:11:00 <scutigera> applicative can do that + extra
22:11:11 <scutigera> monads can do that + extra + more extra
22:11:22 <Pamelloes> roughly
22:11:29 <Pamelloes> :t (<*>)
22:11:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:11:38 <Pamelloes> That's wht applicatives can do.
22:11:47 <Pamelloes> :T (>>=)
22:11:49 <pacak> :t pure
22:11:50 <lambdabot> Applicative f => a -> f a
22:11:58 <scutigera> oh yeah- forgot about pure
22:12:19 <pacak> :k Pointed
22:12:20 <lambdabot>     Not in scope: type constructor or class ‚ÄòPointed‚Äô
22:12:24 <pacak> :(
22:12:56 <Pamelloes> Hm, I guess <*> doesn't make much sense without pure
22:13:34 * hackagebot hmatrix-gsl-stats 0.4 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.4 (VivianMcPhail)
22:13:39 <Pamelloes> Back to my earlier question, is there a good example of something that's a functor but not an applicative?
22:14:09 <kadoban> I'm sure there is but I'm having a hard time thinking of one ...
22:14:15 <tejing> same here
22:14:42 <tejing> I can think of things for which there aren't really any useful applicative instances, but not where you can't write one
22:15:24 <Pamelloes> What I realized earlier today/yesterday was that I'm so used to using fmap and <*> with things that are monads that I couldn't really tell functor from applicative from monad.
22:17:39 <tejing> Pamelloes: the applicative laws make a lot more sense when you translate it to a different representation (much like the monad laws make more sense as the category laws for the kleisli arrows)
22:19:21 <tejing> Pamelloes: if you rewrite applicative so pure x = const x <$> unit and ff <*> fx = uncurry ($) <$> ff <&&> fx, then the applicative laws are just the monoid laws (up to isomorphism)
22:19:58 <tejing> Pamelloes: where unit :: f () and (<&&>) :: f a -> f b -> f (a,b)
22:20:15 <scutigera> did i miss the thing that is a functor and not applicative, or was it the other way around ?
22:20:50 <tejing> Pamelloes: that and the distributivity of fmap over the whole thing
22:20:53 <dibblego> scutigera: there are many functors that are not applicative. There are zero applicatives that are not functor
22:21:06 <scutigera> ok. that makes sense.
22:21:19 <tejing> dibblego: but are there any functors that cannot be applicatives?
22:21:25 <Pamelloes> scutigera: No-one seems to be able to find a good functor that isn't an applicative, though many examples.
22:21:34 <dibblego> tejing: sure, plenty. Here is one ((,) a)
22:21:37 <Pamelloes> gah, *though there are many possibilities
22:21:40 <scutigera> define "good" ?
22:21:50 <tejing> dibblego: I can write an applicative for that
22:21:54 <dibblego> tejing: nope
22:22:11 <scutigera> awesome. functor vs applicative death match
22:22:39 <dibblego> pure :: x -> (a, x) -- ?
22:23:09 <Pamelloes> scutigera: Well, before dibblego showed up no one had been able to come up with one (and tejing contests this one...). Also, google didn't really turn up anything :/
22:23:18 <tejing> dibblego: ah... missed that. pure has to act like identity, so it isn't possible :-/ should have stuck to my guns the first time
22:23:30 <dibblego> Pamelloes: fwiw, this discussion goes on every couple of months in #haskell :)
22:23:34 <scutigera> lol
22:23:37 <dibblego> tejing: you can write it for Monoid a ‚áí
22:23:48 <tejing> dibblego: of course
22:23:56 <Pamelloes> interesting.
22:24:10 <johnw> pure can only work for functors with some notion of a "default around a"
22:24:57 <tejing> well you can write a pure like so: pure x = (undefined,x), but it won't follow the laws with any form of <*>
22:25:41 <Pamelloes> Monoid a => (,) a is an Applicative though
22:26:09 <tejing> Pamelloes: as is Monoid a => Const a, which is part of how lens auto-folds stuff
22:26:51 <Pamelloes> Hm, I never understood why Writer (I think; might be Reader...) had the Monoid restriction before. :)
22:27:20 <johnw> writer is Monoid w => (w,a), so that's just what we're talking abuot
22:27:53 <Pamelloes> Exactly!
22:28:21 <dibblego> (Monoid w => (,) w) is both Functor and Applicative. ((,) w) is Functor, but not Applicative.
22:28:35 * hackagebot app-lens 0.1.0.0 - applicative (functional) bidirectional programming beyond composition chains  http://hackage.haskell.org/package/app-lens-0.1.0.0 (kztk)
22:28:46 <dibblego> Same is true for (Monoid r => Const r) is both Functor and Applicative. (Const r) is Functor, but not Applicative.
22:31:09 <Pamelloes> Is there a good way to represent a value that can be associated with either a fixed type a or [a]?
22:31:25 <shachaf> dibblego: More accurate to say (Monoid r *> Const r)
22:31:34 <shachaf> Or "Const r, where r is a Monoid"
22:31:57 <dibblego> ya
22:32:07 <kadoban> Pamelloes: Not sure I get your meaning
22:33:42 <Pamelloes> kadoban: Sorry. I want some form of type (L,A) | (L,[A]). Though I guess in writing that out I just answered my own question....
22:34:02 <Pamelloes> Funny how that works :)
22:34:08 <kadoban> :)
22:34:49 <Pamelloes> Anyways it's late, so I'm going to go to bed now. However, before I go I want to say 'thank you' to this entire channel.
22:35:19 <kadoban> Good night :)
22:35:19 * tejing waves
22:35:27 <Pamelloes> You guys are super great--thanks for helping me through (relatively) trivial stuff in a friendly way :)
22:35:58 <Pamelloes> I tried participating on some other channels, and I didn't realize how great this channel was until then.
22:36:04 <Pamelloes> So thank you guys for being super awesome and friendly!
22:36:07 <Pamelloes> Night!
22:36:08 <pacak> Pamelloes: Avoid success at all cost!
22:36:09 <kadoban> Yeah #haskell is pretty amazingly neat
22:37:08 <jle`> @tell ttt_fff pong :)
22:37:08 <lambdabot> Consider it noted.
23:09:42 <sccrstud92> @pl filtering p e = f <$> (sequence $ map p e) <*> pure e
23:09:42 <lambdabot> filtering = ((f <$>) .) . (`ap` pure) . (((<*>) . sequence) .) . map
23:10:09 <sccrstud92> @pl filtering e = f <$> (sequence $ map p e) <*> pure e
23:10:09 <lambdabot> filtering = (f <$>) . ap ((<*>) . sequence . map p) pure
23:19:41 <alisia> What does the '~' mean in this signature? "runSQL :: (HasSpock m, SpockConn m ~ SqlBackend) => SqlPersistT (NoLoggingT (ResourceT IO)) a -> m a"
23:21:00 <shachaf> Type equality.
23:21:11 <shachaf> Hoogle can help you figure out answers to questions like that.
23:25:12 <generalbaguette> I am trying to rescue the full-sessions package from the bitrot that has befallen it by ripping out its own custom implementation of type level numbers and lists and replacing them with more maintained versions.
23:25:26 <alisia> shachaf, Thanks.
23:25:33 <generalbaguette> Does anyone know about type level programming?
23:26:06 <generalbaguette> At the moment, I am looking for type level list access.
23:26:12 <generalbaguette> Ie (!!) on the type level.
23:31:19 <alisia> I have a function that returns an database connection as an, IO Connection. How can I use the runQuery function in this page https://hackage.haskell.org/package/Spock-0.7.9.0/docs/Web-Spock-Shared.html#t:SpockConn to run a query with it?
23:33:09 <sccrstud92> @pl filtering e = f e <*> (sequence $ map p e)
23:33:10 <lambdabot> filtering = liftM2 (<*>) f (sequence . map p)
23:42:45 <terrelln> > reads "\"hello \\ world\"" :: [(String, String)]
23:42:46 <lambdabot>  []
23:42:48 <terrelln> > reads "\"hello \\\\ world\"" :: [(String, String)]
23:42:50 <lambdabot>  [("hello \\ world","")]
23:43:00 <terrelln> Is that supposed to happen?
23:46:29 <unknownloner> Is there a standard name used for the folding function passed to foldl/foldr/related functions
23:47:34 <alisia> Can someone tell how I am supposed to use this function runQuery :: (SpockConn m -> IO a) -> m a , to run a query. I have a function that returns an "IO Connection" to the database
23:48:02 <alisia> please..
23:48:37 <terrelln> You have a function (SpockConn m -> IO Connection)? for some monad (I assume) m?
23:49:32 <alisia> terrelln, it is a method of the HasSpock class...
23:51:55 <terrelln> Inside some monad that fulfills the requirements, you would probably do something like (result <- runQuery fn), where fn is your function.
23:51:59 <terrelln> Inside a do block
23:52:14 <martinvlk> :t reads
23:52:15 <lambdabot> Read a => ReadS a
23:53:36 <terrelln> I feel like that behaviour of reads is a bug
23:55:12 <martinvlk> terrelln: what do you think it should do? I think it is supposed to parse one token from the input string and return a tuple with the parsed value plus the rest of the string
23:55:36 <terrelln> Yes
23:55:39 <terrelln> but
23:56:01 <terrelln> > reads "\"hello \\ world\"" :: [(String, String)]
23:56:03 <lambdabot>  []
23:56:07 <terrelln> should be
23:56:13 <terrelln> ["hello \ world"]
23:56:30 <terrelln> ["hello \ world", ""]
23:56:31 <terrelln> I mean
23:56:52 <terrelln> > reads "\"hello \\\\ world\"" :: [(String, String)]
23:56:53 <lambdabot>  [("hello \\ world","")]
23:57:15 <martinvlk> this is successful parse
23:57:35 <terrelln> Yes
23:57:43 <martinvlk> it parsed your thing and the rest is empty
23:57:58 <terrelln> But the other one should succeed as well
23:58:07 <terrelln> with only one unescaped backslash
23:58:21 <martinvlk> hmm, let me play with it a little
23:58:48 <mange> terrelln: "hello \ world" isn't readable. "lexical error in string/character literal at character 'w'"
23:59:09 <terrelln> unescaped
23:59:10 <terrelln> as in
23:59:22 <terrelln> > reads "\"hello \\ world\"" :: [(String, String)]
23:59:24 <lambdabot>  []
23:59:24 <terrelln> shouldn't fail
23:59:26 <Cale> > let x = show x in x
23:59:27 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
23:59:44 <mange> > read "\"hello \\ world\"" :: String
23:59:46 <lambdabot>  "*Exception: Prelude.read: no parse
