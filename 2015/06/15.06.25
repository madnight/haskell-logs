00:02:26 <JuanDaugherty> is there going to be another ghc 10 series release soon (i.e. a few months)?
00:03:47 <pacak> JuanDaugherty: ghc 7.10.2 is expected within a week or two.
00:04:09 <pacak> rc1 is already available.
00:07:38 * hackagebot html-tokenizer 0.3.0.2 - An "attoparsec"-based HTML tokenizer  http://hackage.haskell.org/package/html-tokenizer-0.3.0.2 (NikitaVolkov)
00:07:38 * hackagebot html-entities 1.0.1.1 - A codec library for HTML-escaped text and HTML-entities  http://hackage.haskell.org/package/html-entities-1.0.1.1 (NikitaVolkov)
00:12:33 * hackagebot neet 0.3.0.0 - A NEAT library for Haskell  http://hackage.haskell.org/package/neet-0.3.0.0 (hijiri)
00:16:37 <ttt_fff> I'm using VIM + NodeTree + Syntastic + HDevtools. Syntastic has basicaly overwritten my status line. Is there a way to add CURRENT FILE NAME to syntastic in the bottom status line?
00:17:18 <sccrstud92> ttt_fff: you can try /r/vim on reddit if you dont get anything from here
00:17:29 <ttt_fff> yeah, but syntastic +hdevtools is a weird combination
00:17:39 <ttt_fff> i.e. here probability is 33% emacs, 33% vim, 33% leksah / other
00:17:46 <ttt_fff> whereas on vim, it's like close to 0% using haskell
00:17:54 <ttt_fff> (note: statistics are all made up)
00:21:17 <sccrstud92> (then worth a shot, huh? =P)
00:21:47 <sccrstud92> i use vim but not hdevtools
00:21:51 <sccrstud92> so i cant help =(
00:23:00 <ttt_fff> read http://www.stephendiehl.com/posts/vim_haskell.html it'll change your life
00:23:09 <ttt_fff> -- secretly hoping to convert you to hdevtools
00:23:13 <ttt_fff> do you use ghc-od 
00:23:16 <ttt_fff> ghc-mod
00:25:29 <sccrstud92> ttt_fff: nope only highlighting
00:25:35 <sccrstud92> only haskell specific stuff
00:26:04 <sccrstud92> i guess i havent worked on big enough projects to need those features
00:36:11 <narendraj9> Is there something good for haskell indentation in emacs? I don't like the three modes that come with haskell-emacs. Most of the times, tab doesn't work.
00:36:32 <narendraj9> I need to go back and delete a few faces myself to get the correct indentation.
00:48:22 <ttt_fff> hlint integration is amazing
00:48:30 <ttt_fff> it's making me write better haskell code
00:48:40 <ttt_fff> at first, it was like WTF, your suggestions look like perl, they're unreadable
00:48:52 <ttt_fff> now, it's like ... .whoa, my old code sucks, thank you for your brilliant suggestion
00:51:07 <Geraldus> Hi folks!
00:52:04 <maerwald> ttt_fff: a lot of suggestions are junk, though
00:52:05 <Geraldus> How can I figure out operation cost of function?  I want to know about (!) and lookup from Data.HashMap
00:52:05 <merijn> ttt_fff: It's a matter of things like . <$> and <*> first seeming unreadable and later realising that treating them as barely visible punctuation actually makes the intent easier to see
00:52:22 <ttt_fff> merijn: exactly!
00:52:46 <ttt_fff> merijn: yeah, I think it was mostly <$>, <*>, not using so many ()'s, using more (:) / slice operators
00:52:56 <ttt_fff> merijn: but the code looks so much better
00:53:09 <ttt_fff> maerwald: nonsense
00:53:15 <ttt_fff> hlint is perfect
00:53:20 <ttt_fff> except for CamelCase
00:53:22 <ttt_fff> I like my underscores
00:53:27 <merijn> Naah, it has some questionable suggestions
00:53:32 <maerwald> something I cannot customize is not perfect
00:53:44 <maerwald> partial eta-reduction being the worst
00:53:57 <merijn> Geraldus: Claims to be comparable to IntMap
00:54:14 <ttt_fff> this is "func a = foo b a" -> "func = foo b" ? I like thsoe
00:54:55 <merijn> Geraldus: Which is O(min(n,W)) where W is the number of bits in an Int
00:56:14 <maerwald> ttt_fff: if I have "f :: a -> b -> c -> d" and it says I should write that "f x = whatever"
00:56:15 <Geraldus> merijn: where did you find it?  haddock for IntMap does not shows mentioned functions, and haddock for Map states O(log n), that confused me.
00:56:59 <ttt_fff> so hlint is lie "don't write f a b c d =  a + b + c + d", write "f a = \b c d -> a + b + c + d" ? I never got that
00:57:03 <maerwald> it's neither properly reduced, nor readable
00:57:05 <ttt_fff> s/lie/like
00:57:33 <merijn> Geraldus: https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-IntMap-Lazy.html#v:-33- ?
00:58:09 <merijn> ttt_fff: I've never seen that suggestion
00:58:23 <ttt_fff> merijn: nor have I ; I'm trying to understand the maerwald is saying
00:58:26 <Geraldus> merijn: oh, sorry, this is because I've looked at Stackage docs
00:58:30 <frerich> ttt_fff: hlint is more like a colleague reviewing your code; whatever it says is not necessarily a good idea but probably worth being considered.
00:58:30 <Geraldus> thank you
00:59:16 <maerwald> ttt_fff: I'm not sure if you got what I meant
00:59:32 <ttt_fff> maerwald: I did not
00:59:37 <ttt_fff> maerwald: please give me full example
00:59:49 <maerwald> ttt_fff: if I have "f :: a -> b -> c -> d" and it says I should write that "f x = whatever"
01:00:15 <maerwald> because the other 2 arguments can be reduced
01:00:18 <ttt_fff> maerwald: that is not a full example
01:00:22 <ttt_fff> oh
01:00:44 <ttt_fff> it's like instead of writing "f a b c d = foobar b c d" , write "f a = foobar" ?
01:00:47 <maerwald> that's partial reduction to me and very ugly
01:00:57 <ttt_fff> hmm, I got used to that
01:01:07 <ttt_fff> and it makes me feel badass whenever I catch myself doing that and eliminating it
01:01:18 <alisia> which session persist configuration should I use with Spock web framework. The documentation says not to use the 'readShowSessionPersist' in production...
01:01:55 <ttt_fff> is there a way to simplify \x -> (1, x) ... i.e. somehow "slice" the , ?
01:02:33 <frerich> ttt_fff: There is a 'TupleSections' extension which lets you write '(1,)' I think.
01:02:43 <merijn> You don't need TupleSections
01:02:51 <merijn> (1,) is perfectly standard haskell
01:03:06 <merijn> You need TupleSections for
01:03:18 <ttt_fff> frerich: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions
01:03:30 <ttt_fff> frerich: thanks!
01:03:36 <merijn> > (,2,,'c',,True,) [] "foo" (Just 'c') 5
01:03:36 <frerich> :t (1,)
01:03:37 <lambdabot> Num t => t1 -> (t, t1)
01:03:38 <lambdabot>  ([],2,"foo",'c',Just 'c',True,5)
01:03:38 <ttt_fff> merijn: oh, what is the extension that TupleSections adds then?
01:03:53 <merijn> ttt_fff: TupleSections let's you write what I just did :p
01:03:55 <Axman6> :t (1,,"hello")
01:03:57 <lambdabot> Num t => t1 -> (t, t1, [Char])
01:03:59 <frerich> merijn: Is that ne win ghc 7.10? In y ghc 7.8, I still need TupleSections AFAICS
01:04:06 <Axman6> that's what tuple sections gives you
01:04:20 <merijn> frerich: No, (1,) should've worked since, like, forever
01:04:30 <jgoux> Hello
01:04:32 <merijn> frerich: (1,) is just standard Haskell98/Haskell2010 behaviour
01:04:37 <Axman6> merijn: should it? not ((,) 1)?
01:04:45 <frerich> merijn: I got 'http://lpaste.net/135192'
01:04:47 <maerwald> (1,) doesn't work here
01:04:52 <jgoux> Is there any work done in Haskell implementing a basic CQRS architecture ?
01:05:04 <merijn> heh, I was sure that should work...
01:06:32 <merijn> jgoux: I have no clue what CQRS stands for
01:06:43 <jgoux> merijn: Command Query Responsibility Segregation
01:07:08 <frerich> ttt_fff: Yeah, I meant https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/syntax-extns.html#tuple-sections
01:07:16 <jgoux> merijn: Basically you split your app workflow in two distinct part, a read only one and a write one
01:07:36 <Axman6> jgoux: AcidState uses something similar to the wikipedia definition at elast
01:07:39 <Axman6> least*
01:07:52 <Axman6> you can specify operations whch are either updates or querys
01:08:09 <merijn> jgoux: Just have one thread doing only reads and one thread doing only writes? I'm not really sure what needs an architecture here?
01:08:24 <Axman6> "It states that every method should either be a command that performs an action, or a query that returns data to the caller, but not both. In other words, Asking a question should not change the answer.[1] More formally, methods should return a value only if they are referentially transparent and hence possess no side effects."
01:08:56 <Axman6> jgoux: https://ocharles.org.uk/blog/posts/2013-12-14-24-days-of-hackage-acid-state.html
01:09:51 <jgoux> merijn: CQRS coupled with Event sourcing is pretty neat, your commands have side effects which are expressed as events, then you just store there events and they become your only source of truth
01:10:08 <jgoux> merijn: you can then reconstruct your entities or model from there event by applying them one after another
01:10:28 <Walther> I've been continuing a "practical haskell in an hour" -tutorial, any comments/suggestions? http://walther.guru/one-hour-haskell
01:10:40 <quetzakubica> can memoization be done purely functional ?
01:10:54 <Axman6> quetzakubica: yes
01:10:57 <jgoux> Axman6: I'm gonna look at this, thanks :)
01:11:15 <quetzakubica> Axman6: how would that work wittout assignement and side effect?
01:11:23 <Axman6> quetzakubica: https://hackage.haskell.org/package/MemoTrie
01:11:48 <quetzakubica> Axman6: I want to know mechanism behind this
01:12:00 <Axman6> quetzakubica: then read the information on the wiki
01:12:06 <Axman6> which is linked to on that page
01:12:28 <jgoux> Also, is there a web framework à la ExpressJS in Haskell ? Which just handle http request + accept middlewares ?
01:12:42 <jgoux> I saw Yesold but it seems quite heavy for my use
01:12:44 <Axman6> jgoux: scotty?
01:12:46 <merijn> WAI?
01:13:26 <Walther> jgoux: snap is another one
01:13:29 <jgoux> I'll look at scotty and WAI ^^
01:13:53 <Axman6> servant is another option, but requires some somewhat advanced knowledge to use. lots of (excellent) use of the type system
01:14:41 <Axman6> hmm, the wiki page seems to have disappeared. I'll find a better one quetzakubica 
01:14:58 <jgoux> Also, I read about error handling in Haskell, and there is a lot of way to do it, what do you recommand in a web app context ? Like bad user inputs ?
01:15:17 <Axman6> quetzakubica: maybe this is better: http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries
01:15:39 <quetzakubica> thanks
01:16:01 <alisia> which session persist configuration should I use with Spock web framework. The documentation says not to use the 'readShowSessionPersist' in production...
01:17:37 * hackagebot lazy-csv 0.5.1 - Efficient lazy parsers for CSV (comma-separated values).  http://hackage.haskell.org/package/lazy-csv-0.5.1 (MalcolmWallace)
01:18:28 <Axman6> quetzakubica: this is the package I meant to link to: https://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/Data-MemoCombinators.html
01:18:58 <ttt_fff> is ViewPattern considerred good or bad style?
01:19:08 <ttt_fff> i.e. should your types ever get that complicated? or does ViewPattern actually simplify code?
01:19:14 <merijn> ttt_fff: It Depends™
01:19:27 <ttt_fff> merijn: can I hire you as my consultant?
01:19:47 <merijn> Yes, I charge $100 an hour ;)
01:20:05 <quetzakubica> Axman6: is it some sort of monad?
01:20:09 <Axman6> that's a pretty reasonable price
01:20:17 <Axman6> quetzakubica: no
01:20:21 <ttt_fff> merijn: only $100? first year law assocaites bill $400 / hour
01:20:35 <merijn> Axman6: I'm a phd student, I don't know what real money is...
01:20:36 <Walther> "i can charge that too, if you want"
01:20:37 <Axman6> ttt_fff: and get paid $15/h =)
01:20:43 <Axman6> merijn: ha
01:21:06 <merijn> I'd totally procrastinate and critique haskell code for $100 an hour when I get to lazy to do my own research...
01:21:48 <ttt_fff> Axman: no, they get paid $80 / hour .... ( $160 K / year) / (2000 billble hours / year) = $80 / billable hour
01:22:03 <ttt_fff> then, the partner takes the remaining $320 / hour .... OUCH
01:22:16 <ttt_fff> ttt_fff: haskell-blah
01:24:42 <makalu> what does stack's gpg-verify do?
01:25:25 <makalu> https://github.com/commercialhaskell/stack/wiki/stack.yaml#package-indices
01:26:23 <merijn> makalu: Presumably verify a gpg signature of the package
01:26:51 <ttt_fff> it verifies gpg signatures
01:26:57 <ttt_fff> can I also charge $100 / hour ?
01:27:33 <makalu> looking at the comments when searching the git repository, it seems to only verify the package index, not the packages
01:27:47 <merijn> ttt_fff: You can, but that doesn't mean anyone will pay :p
01:39:19 <gfixler> any thoughts on a good first step into monad transformers?
01:39:32 <gfixler> is there a 'simplest' one I could get a feel for first?
01:39:43 <merijn> gfixler: Did you ever implement the State monad?
01:39:57 <gfixler> no, I've implemented Writer many times, and Reader a few
01:40:08 <merijn> gfixler: My usual recommendation is to first try to implement State and then generalise it to StateT to see what changes
01:40:15 <merijn> gfixler: See https://gist.github.com/merijn/098106abd45c940dab09
01:40:32 <gfixler> oh, this is cool
01:40:45 <merijn> If you start out with State and move to StateT it should be fairly straightforward to see what happens
01:40:49 <gfixler> you were ready and waiting for my question, apparently
01:41:20 <merijn> gfixler: It gets asked so often I figured I'd write it out as exercise once so I only have to link people to it and I can save my own time ;)
01:41:31 <gfixler> btw, I really like the simplicity of Reader as described and implemented here: http://www.mjoldfield.com/atelier/2014/08/monads-reader.html
01:42:04 <gfixler> merijn: I thought I'd get a sorta-kinda useful answer that sent me off to a book or blog posts
01:42:12 <gfixler> this is like, exactly what I would have hoped for :)
01:42:59 <merijn> gfixler: State is barely more complicated than Reader, the only difference is that instead of "Reader r a = Reader (r -> a)" you have "State s a = State (s -> (a, s))"
01:43:17 <gfixler> yeah, I figured they'd be about the same
01:43:30 <gfixler> Reader is just read-only State
01:43:34 <merijn> i.e. a tuple result instead of just a simple result. Which makes it a slightly more interesting example imo
01:43:52 <gfixler> State is the one I've been wanting to tackle for awhile
01:44:05 <gfixler> I keep needing it (and needing it tonight is what brought me here to ask about transformers)
01:44:24 <gfixler> I have some demos I'd like to play with (and share with local folks)
01:44:41 <gfixler> and I figured it would be nice not to code up my own monad(s) again
01:44:55 <gfixler> but the ones in the platform seem to all be somethingT
01:45:03 <gfixler> so I need to grok T
01:45:27 <merijn> gfixler: Yeah, the realisation was that State is identical to "StateT" over Identity
01:45:49 <gfixler> that makes sense as an idea in English :)
01:45:51 <merijn> gfixler: Which has "newtype Identity a = Identity a" which is (trivially) a Functor/Applicative/Monad
01:46:04 <gfixler> hmmm
01:46:18 <merijn> "fmap :: (a -> b) -> Identity a -> Identity b; fmap f (Identity x) = Identity (f x)"
01:46:18 <gfixler> that's the Trivial Monad
01:46:20 <gfixler> http://blog.sigfpe.com/2007/04/trivial-monad.html
01:46:30 <merijn> gfixler: Yes
01:46:32 <gfixler> :)
01:46:43 <gfixler> I've been getting a lot of "Yes"es lately
01:47:00 <gfixler> unlike all the "No"s and "What?! NO!"s I got when I started learning Haskell :)
01:47:38 * hackagebot hset 0.0.2 - Primitive heterogenous read-only set  http://hackage.haskell.org/package/hset-0.0.2 (AlekseyUymanov)
02:04:54 <jacereda> Hi... I'm trying to install HaRe using stack, but I'm not having more fun than in my previous attempts with cabal. It seems HaRe wants 7.6.x (and seems to specify so in its .cabal). How can I convince stack to use that ghc version?
02:05:00 <supki> I think it's weird to say Identity is the trivial monad when  data Trivial a = Trivial  exists
02:10:45 <dramforever> jacereda: Maybe this isn't helpful, but isn't that old?
02:11:12 <dramforever> I think it means that HaRe hasn't been updated for quite a while
02:11:37 <jacereda> dramforever: well, I wouldn't mind using something newer, but it seems there's no alternative
02:12:25 <dramforever> jacereda: I guess you have to take the source code in that case
02:13:07 <dramforever> I'm not really sure what to modify, though
02:13:30 <dramforever> but I think you might have to 1. change the required ghc version 2. change to adopt to newest ghc changes
02:25:25 <jacereda> dramforever: HaRe isn't particularly easy to adapt to newer ghc releases, thanks anyway
02:25:37 <dramforever> jacereda: Hmm...
02:25:51 <dramforever> yeah I didn't even find the cabal file...
02:25:56 <dramforever> :)
02:59:58 <raguay> Anyone know a Jade library for Haskell?
03:00:43 <ttt_fff> instance Blah Text where blah :: Text -> ... ; now, I have to call it as >>> blah ("foo" :: Text) ... because it (1) does not know if "foo" should be Text or String, and (2) if there is a "instance Blah String" (there isn't) -- is there a way to tell haskell "dude, just default it to Text" ?
03:01:14 <dramforever> I think maybe default?
03:01:48 <ttt_fff> default ?
03:02:03 <dramforever> https://wiki.haskell.org/Keywords#default dunno if useful
03:02:30 <ttt_fff> hmm, I need to do this to Strings, not NUms though
03:02:31 <dramforever> no no...
03:03:01 <dramforever> How about syntax sugar t :: Text -> Text and t = id
03:03:04 <dramforever> ...
03:03:11 <ttt_fff> hmm
03:03:12 <ttt_fff> this is cute
03:03:37 <dramforever> I was having this problem while using wreq
03:07:43 <ttt_fff> man
03:07:47 <ttt_fff> but I have to give up the entire letter 't'
03:07:55 <dramforever> hmm...
03:07:58 <ttt_fff> that's very precious
03:08:03 <dramforever> what about _t
03:08:10 <dramforever> t_
03:08:27 <ttt_fff> _t is not good, since if I do not import it, ahskell tries to bind it to an pattern to be ignored
03:08:27 <dramforever> t_ looks good
03:08:35 <bernalex> can someone tell me how chans are supposed to work? ^_^
03:08:49 <ttt_fff> bernalex: you use /join #chan-name to join it, then you type in stuff to talk
03:08:55 <bernalex> uh
03:08:57 <bernalex> no
03:09:04 <dramforever> chans on hackage?
03:09:09 <bernalex> I mean http://lpaste.net/2651524207946498048
03:09:14 <bernalex> IDK what I'm doing
03:09:19 <bernalex> recvFrom is blocking
03:09:29 <bernalex> so I need to fork it off -- that much I got
03:09:46 <bernalex> but IDK what I'm supposed to do, except that I need to write it to chan and then somehow read from it in a non-blocking way etc
03:09:49 <bernalex> any help would be appreciated
03:09:50 <ttt_fff> http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Concurrent-Chan.html ... hmm
03:10:18 <ttt_fff> readChan has to block since it's Chan a -> IO a, not Chan a -> IO Maybe a
03:10:47 <ttt_fff> bernalex: is https://ghc.haskell.org/trac/ghc/ticket/4154 related to your issue?
03:10:54 <Cale> ttt_fff: Not only that, but the blocking is usually desirable
03:11:10 <bernalex> ttt_fff: uh idk but I doubt it
03:11:17 <bernalex> Cale: I have an udp game server thingy
03:11:24 <dramforever> isEmptyChan looks great, but I guess you want TChan from STM
03:11:26 <bernalex> Cale: clients send updates -- or not
03:11:27 <ttt_fff> well, Cale is here, and he's like 100x smarter than me, so I'll leave it to him
03:11:38 <dramforever> +1
03:11:39 <bernalex> Cale: the server needs to send updated viewports back to them regardless of whether they are talking to it or not
03:11:42 <ttt_fff> isEmptyChan sounds race-condition-ish-ey
03:12:48 <bernalex> Cale: I pasted the working code now: http://lpaste.net/2651524207946498048 -- but this only work if some client is sending info all the time, lol
03:13:14 <bernalex> Cale: what I need to do instead is send like 600 updates to every client every second regardless of anything. which is not going to happen when blocking on recv.
03:13:39 <bernalex> and I'm kind of stuck figuring out how that's meant to work.
03:13:41 <ttt_fff> dramforever: http://chrisdone.com/posts/haskell-constraint-trick ... this miht be waht I want
03:14:09 <dramforever> ttt_fff: no no no!
03:14:12 <Cale> 600 sounds like a lot of updates per second
03:14:17 <ttt_fff> dramforever: no ?
03:14:19 <dramforever> you won't be able to get other instances
03:14:30 <dramforever> if you do instance (a ~ Text) => Blah a
03:14:38 <bernalex> Cale: hm. not that much IMO. but let's say 60. whatever. more than "let's not send anyone any updates ever"
03:14:43 <Cale> heh
03:14:57 <ttt_fff> dramforever: oh, I think you're right
03:15:31 <Cale> Okay, anyway, perhaps have a Chan for each client with a thread which is constantly pulling from that Chan and sending messages on it to the client.
03:15:51 <bernalex> Cale: that sounds reasonable
03:16:01 <bernalex> Cale: don't know how to implement it but sounds like a better angle
03:16:02 <Cale> and then you can shove updates into that Chan from one thread, and shove responses to messages into it as well from another
03:16:38 <bernalex> Cale: I think I could just listen for updates at all times like I'm doing now, but fork off the viewport updates altogether. does that sound sane?
03:17:09 <bernalex> no clue how to do it in practice either way though =/
03:17:14 <Cale> yeah, that's what this would let you do -- the important thing is to just not mangle things by actually writing to the socket from different threads
03:18:10 <Cale> If you do tmhe eswsibae lgil nets erleaved
03:18:22 <bernalex> yeah I see
03:22:09 <danilo2> Hello guys! I've got a problem with functional dependencies and liberage coverage conition. I do not know if thats a bug in GHC, but the following code should work (the condition is met), but it does not (6 lines): http://lpaste.net/135199
03:22:47 <danilo2> I'm sorry. i Just updated the snippet
03:23:21 <danilo2> Why "Nothing -> Proxy" is not valid for liberate coverage condition?
03:23:37 <danilo2> Why "Nothing -> Proxy" is not valid for liberate coverage condition?
03:25:21 <dramforever> danilo2: looks like you can try UndecidableInstances for a workaround
03:25:41 <dramforever> I don't know if that's okay
03:26:01 <danilo2> dramforever: I cannot, I've got -XUndecidableInstances enabled.
03:26:31 <danilo2> dramforever: but thats not the case, UndecidableInstances relate to the head (checking if its smaller in further instances). Here the UndecidableInstances are not need
03:26:46 <dramforever> okay
03:34:14 <danilo2> Ok, I've made a trac ticket regarding this behaviour: https://ghc.haskell.org/trac/ghc/ticket/10570#comment:1
03:37:26 <pavonia> When is a lhs type said to not determine its rhs type?
03:38:13 <pavonia> If it's too generalß
03:38:15 <pavonia> ?
03:47:43 * hackagebot sys-process 0.1.6 - A replacement for System.Exit and System.Process.  http://hackage.haskell.org/package/sys-process-0.1.6 (TonyMorris)
03:59:43 <ttt_fff> (\x -> add x >> cr) <-- can this code be simplified
03:59:48 <ttt_fff> via pointfree / pointless style ?
04:00:33 <[k-> @pl \x -> add x >> cr
04:00:34 <lambdabot> (>> cr) . add
04:01:50 <ttt_fff> oh wow
04:01:55 <ttt_fff> it's slicing (>>) ? 
04:01:56 <ttt_fff> this is badass
04:02:01 <chpatrick> don't do it D:
04:02:01 <ttt_fff> [k-: thanks!
04:02:08 <ttt_fff> dude, tis' awesome
04:02:18 <chpatrick> eeeeeh
04:02:23 <chpatrick> you can pointfree anything
04:02:33 <chpatrick> doesn't mean it makes it nicer
04:02:44 * hackagebot gyah-bin 0.2.2.1 - A binary version of GiveYouAHead  http://hackage.haskell.org/package/gyah-bin-0.2.2.1 (Qinka)
04:02:46 * hackagebot GiveYouAHead 0.2.2.1 - to auto-do somethings  http://hackage.haskell.org/package/GiveYouAHead-0.2.2.1 (Qinka)
04:02:56 <MarcelineVQ> concise is only good as far as you can both understand it and remember what it's supposed to be later
04:03:03 <frerich> all: essen
04:03:06 <frerich> err, sorry, wrong channel
04:03:07 <chpatrick> @pl \f -> f <$> pure 1 <*> pure 2 <*> pure 3
04:03:07 <lambdabot> (<$> pure 1 <*> pure 2 <*> pure 3)
04:03:23 <chpatrick> forgot it can't do that
04:04:29 <ttt_fff> (>> cr) . add makes sense
04:04:39 <ttt_fff> it's like apply add to it "due to the . ), then concat it with (>> cr)
04:04:41 <ttt_fff> I like it
04:05:36 <chpatrick> it's barely shorter than \x -> add x >> cr though
04:06:12 <chpatrick> and it's a bit awkward because you're used to monadic stuff going from left to right
04:06:15 <frerich> ttt_fff: Note that there's a difference between 'simple' and 'concise' and 'obfuscated' :-}
04:06:34 <george_p> i upgraded to 7.8.4, upgraded emacs and haskell-mode, and now my haskell repl in emacs keeps crashing randomly. sometimes it works, sometimes it crashes every minute. wtf
04:06:42 <ttt_fff> simple and concise = what I understand
04:06:47 <ttt_fff> obfuscated = waht I don't understand yet
04:06:47 <chpatrick> you understand now
04:07:04 <chpatrick> but if you need to read it again in a month you'll have to think about it for longer than the perfectly reasonable original
04:07:42 <chpatrick> it's a bit like making a macro for everything in C
04:07:53 <ttt_fff> no, I'm going to use the (>> ...) . ... idiom all over the place
04:07:56 <chpatrick> sure it's a bit shorter but it adds cognitive overhead
04:08:07 <chpatrick> it's not an idiom D:
04:09:17 <dramforever> actuallly it's neat to have "useful" stuff spelt out and "useless" stuff written with symbols
04:10:49 <ttt_fff> i have spent two weeks coding; I have 1300 lines of haskell code
04:10:53 <ttt_fff> this means I wrote < 10 lines per hour
04:11:27 <ThreeOfEight> do consider the amount of work you can do in one line of Haskell
04:11:50 <ThreeOfEight> also, sometimes the most productive thing to do is to delete or shorten large portions of code
04:11:55 <dramforever> lol
04:11:57 <ttt_fff> what I can do in one line of haskell is not very impressive, but n lines of haskell is like 2^n lines of C
04:12:04 * dramforever thinks of lens
04:12:48 <ttt_fff> oh, I was thikning of weird monads + transformers
04:13:28 <ThreeOfEight> even the combination of a few simple higher-order combinators can do an impressive amount of work
04:14:20 <ttt_fff> time to sleep
04:14:22 <ttt_fff> it's 4am
04:14:33 <ttt_fff> g'night every one; happy haskell dreams
04:14:43 <dramforever> yeah newbies often ask "How do I do..."
04:14:56 <ThreeOfEight> I recall an anecdote that a colleague once told me, about some complicated proof that took them ages to complete, and which was about 1000 lines long
04:14:57 <dramforever> and the answer is often under 20 chars
04:15:04 <dramforever> the last example is (liftA2 (.))
04:15:13 <ThreeOfEight> it was shortened successively by several people, until, in the end, it was a single line
04:15:25 <dramforever> so...what is it?
04:15:41 <merijn> Q.E.D.
04:15:48 <ThreeOfEight> (not Haskell-related, just to illustrate the productivity of shortening code)
04:15:54 <ThreeOfEight> I don't remember what the statement was
04:16:10 <ThreeOfEight> but I think it was something categorical, relators and pullbacks or something like that
04:16:48 <ThreeOfEight> and it eventually transpired that it was a consequence of something else, if you knew how to instantiate it correctly. Not sure.
04:16:58 <ThreeOfEight> (that's why I called it an anecdote, I don't remember the details)
04:37:46 <danilo2> Ok, I've made a trac ticket regarding this behaviour: https://ghc.haskell.org/trac/ghc/ticket/10570#comment:1
04:38:09 <danilo2> Ugh, Im sorry my new irc client sends double messages sometimes. 
04:41:59 <mitu> mine sends mixed messages
04:42:17 <dramforever> mine fails to send sometimes
04:43:24 <pavonia> semitemos sdrawkcab txet sdnes enim
04:43:55 <merijn> Christ, metatheory of recursive types feels like smacking my head against a brick wall...
05:12:46 * hackagebot ho-rewriting 0.1 - Generic rewrite rules with safe treatment of variables and binders  http://hackage.haskell.org/package/ho-rewriting-0.1 (EmilAxelsson)
05:15:38 <merijn> Anyone know an alternative/expanded text that covers the metatheory of recursive types, because the TaPL chapter is ridiculously dense...
05:22:47 * hackagebot hset 0.0.3 - Primitive heterogenous read-only set  http://hackage.haskell.org/package/hset-0.0.3 (AlekseyUymanov)
05:42:48 * hackagebot GiveYouAHead 0.2.2.3 - to auto-do somethings  http://hackage.haskell.org/package/GiveYouAHead-0.2.2.3 (Qinka)
05:42:50 * hackagebot gyah-bin 0.2.2.3 - A binary version of GiveYouAHead  http://hackage.haskell.org/package/gyah-bin-0.2.2.3 (Qinka)
05:46:20 <alisia5> What session persistance configuration should I use with Spock web framework?  It's documentation warns against using the built in one 'readShowSessionPersist' in production...
05:52:48 * hackagebot som 8.0.6 - Self-Organising Maps.  http://hackage.haskell.org/package/som-8.0.6 (AmyDeBuitleir)
06:09:00 <TTK> @pl foldr (\x -> ((x-2)*)) 1
06:09:00 <lambdabot> foldr ((*) . subtract 2) 1
06:09:30 <TTK> @pl foldr (\x acc-> ((x-2)*acc)) 1
06:09:30 <lambdabot> foldr ((*) . subtract 2) 1
06:20:50 <frerich> TTK: I think a nicer point-free version would be 'product . map (subtract 2)'
06:22:43 <alisia5> What session persistance configuration should I use with Spock web framework?  It's documentation warns against using the built in one 'readShowSessionPersist' in production...
06:46:36 <lunaris> Hi all; is there a #commercialhaskell-style channel? I'm seriously considering "just betting on Haskell" and looking for a few "production-ready" recommendations.
06:47:17 <merijn> lunaris: Not sure, but I'd ask here and/or the haskell-cafe mailing list (will have wider reach)
06:47:35 <lunaris> I've been writing Haskell for the last 6 years, so no stranger to it and I've used a lot of libraries, but looking for a few war stories on e.g. pipes/conduits/IO choices, etc., best shot for hosting an HTTP API (wai/scotty) etc.
06:47:51 * hackagebot flowdock 0.3.0.1 - Flowdock client library for Haskell  http://hackage.haskell.org/package/flowdock-0.3.0.1 (IanDuncan)
06:48:25 <merijn> lunaris: I'm pretty sure Snoyman is working with Yesod/WAI and conduits commercially and all the stuff FPComplete is working on
06:49:20 <jhaberku> Something that wasn't immediately clear to me from the stack-0.1 docs that are out there: are packages pulled from a curated set like stackage? If so, what happens if I have a dependency on something that isn't in a stackage release?
06:49:21 <merijn> There's also the CUFP industry group
06:49:30 <lunaris> merijn: Yea, I figured that much; just trying to gather as many anecdotes as possible :)
06:49:50 <lunaris> Perhaps I should just gamble; I guess Haskell's refactorability hasn't failed me yet.
06:50:04 <lunaris> Though ideally I'd get the IO and "REST" stories straight the first time :)
06:50:39 <merijn> lunaris: https://wiki.haskell.org/Haskell_in_industry https://www.fpcomplete.com/business/haskell-industry/ and the recent bike parking thing deployed in Utrecht
06:51:07 <merijn> lunaris: https://bicycledutch.wordpress.com/2015/06/09/bicycle-parking-guidance-system-in-utrecht/
06:52:50 <lunaris> merijn: I'd not seen the Utrecht bike thing; thanks :)
06:53:59 <merijn> Also, there's a bunch of talks on Facebook's haxl thing
06:54:10 <luite__> Utrecht bike thing! \o/
06:54:14 <luite__> and they used GHCJS!
06:55:52 <mizu_no_oto> lunaris: what type of software are you looking to make?
06:56:16 <mizu_no_oto> lunaris: Something big-data-y on AWS?
06:56:46 <mizu_no_oto> Then you might ask Soostone or (I think) skedge.me
06:58:17 <mizu_no_oto> lunaris: And edwardk's company has used a Scala port of his machines library
06:59:56 <indiagreen> I'm using Snap – how can I limit length of request parameters I'm willing to accept? (there's readRequestBody which does takes a limit, but I'm using getParam instead and getParam doesn't take any limits)
07:01:10 <alisia5> What session persistance configuration should I use with Spock web framework?  It's documentation warns against using the built in one 'readShowSessionPersist' in production...
07:07:51 * hackagebot gf 3.7 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.7 (ThomasHallgren)
07:07:53 * hackagebot digitalocean-kzs 0.1.0.1 - digitalocean api for haskell  http://hackage.haskell.org/package/digitalocean-kzs-0.1.0.1 (KazumaSATO)
07:08:46 <quetzakubica> Guys if you have a really deep data graph, and everytime you change something on top of that graph you have to recreate whole graph to keep immutability, isnt that really inefficient?
07:09:32 <quetzakubica> is haskell somehow optimizing it?
07:10:00 <Cale> quetzakubica: Generally if you have some tree structure, and you modify some node in it, you can share all the subtrees which the new tree has in common with the old one. So you only end up reconstructing a path from the root to the new node.
07:10:27 <Cale> quetzakubica: This is why, e.g. insertion in Data.Map and Data.Set is O(log n) time (and space)
07:11:00 <Cale> Even though you get a new Map, it shares most of its structure with the old Map.
07:11:37 <benzrf> quetzakubica: in terms of lists, that looks kinda like
07:11:37 <mizu_no_oto> Cale: what about the general case of an immutable graph?
07:11:41 <Cale> (this is true even though it does operations to rebalance the tree -- those operations increase the number of nodes which are replaced, but only by a constant factor)
07:11:58 <benzrf> quetzakubica: l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; l' = 999:(tail l)
07:12:17 <benzrf> quetzakubica: then the [2, 3, 4, 5, 6, 7, 8, 9, 10] in l and in l' are actually the same memory, under ghc i think
07:12:18 <Cale> mizu_no_oto: Well, then you have to say how you're representing the graph. Often you'll want to represent graphs using something like Map Vertex (Set Vertex), or some variation on that.
07:12:26 <lunaris> mizu_no_oto: Just the usual "boring" set-up: pretty web page, JSON-talking API wrapping some mundane business logic.
07:12:43 <lunaris> Start with a monolith, worry about services or whatever later on.
07:12:53 <lamefun> Why is monomorphism restriction even there? If the goal is to prevent "(Class1 n, Class2 n) => n" kind of thing, why doesn't GHC simply warn about that?
07:13:10 <Cale> lamefun: The monomorphism restriction probably should just be a warning, imo.
07:14:56 <quetzakubica> thanks
07:15:16 <mizu_no_oto> lunaris: talk to soostone, skedge.me, silk, and FPComplete (although you might take them with a grain of salt - their business relies on talking you into using Haskell)
07:15:22 <quetzakubica> I'm writing in JS and I wanted to make my data immutable there, but I think it will have too big overhead.
07:15:57 <mizu_no_oto> quetzakublica: do you have a graph or a tree?
07:16:17 <quetzakubica> in example I have data graph Unit > Body > Position > Point > Matrice
07:16:28 <quetzakubica> if I change anything on unit
07:16:45 <quetzakubica> I have to recreate everything below
07:17:19 <quetzakubica> anyway JS has eventloop, and only one thread so I shoudl not care about concurrency, right?
07:17:26 <mizu_no_oto> quetzakubica: have you ever read Purely Functional Data Structures, out of curiosity?
07:17:32 <Cale> quetzakubica: btw, the singular of matrices is matrix :)
07:17:52 * hackagebot autonix-deps 0.3.0.0 - Library for Nix expression dependency generation  http://hackage.haskell.org/package/autonix-deps-0.3.0.0 (ThomasTuegel)
07:18:04 <quetzakubica> mizu_no_oto: no, just SICP
07:18:14 <ryantrinkle> lunaris: i'll be happy to talk with you about production haskell (I'm the guy who moved skedge.me from grails to Haskell)
07:18:28 <quetzakubica> Structure and Interpretation of Computer Programs
07:18:42 <ocharles_> Can someone help me understand how cost centres actually work? I have something like 'classes <- {-# SCC enrich #-} enrichClasses c'. My heap profile created with -hc shows that over the life of the program, the 'enrich' cost centre basically only grows
07:18:45 <alisia5> What session persistance configuration should I use with Spock web framework?  It's documentation warns against using the built in one 'readShowSessionPersist' in production...
07:18:59 <ocharles_> Does that mean that something else in my program is holding on to data that was allocated within the 'enrich' cost centre?
07:19:26 <mizu_no_oto> quetzakublica: you need a slightly different bag of tricks to write nice immutable data structures than imperative ones
07:19:44 <ocharles_> The growth is over tens of minutes, and that function is certainly terminating during that time (it's called many times)
07:20:24 <Cale> ocharles_: Can we see the rest of the module?
07:20:31 <mizu_no_oto> quetzakubica: mostly because functional data structures rely on 'sharing' the unchanged nodes to be efficient
07:20:54 <srhb> ocharles_: With hc, yeah, I don't think there's really another interpretation?
07:20:54 <ocharles_> It's quite a large module, I'll start with just the top level definition that cost centre is in
07:20:55 <luite__> ocharles_: look at what I started at ZuriHac and finally got to work! GHCJSi: http://hdiff.luite.com/tmp/ghcjsi1.png
07:20:55 <Cale> ocharles_: Basically, yes, it does mean that the objects allocated by that expression are remaining in memory
07:20:56 <ocharles_> and one call site
07:21:01 <srhb> ocharles_: Otherwise it surely should be gc\ed
07:21:19 <ocharles_> luite__: waaaat
07:21:26 <quetzakubica> mizu_no_oto: so sharing of unchanged nodes doesn't interferes with concurrency problems?
07:21:48 <mizu_no_oto> quetzakubica: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
07:22:00 <mizu_no_oto> No, because they're immutable
07:22:28 <mizu_no_oto> if a node never changes, it doesn't matter if you copy it or not
07:22:39 <ocharles_> Cale: https://gist.github.com/ocharles/b1e0ffc5576227beae13 - my graph shows 'schedulesQuery-enrich...' is the biggest offender on the heap, after PINNED
07:22:52 <quetzakubica> mizu_no_oto: wow, that is actually quite obvious, yet I didn't think of that
07:22:52 * hackagebot clock 0.5.0.0 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.5.0.0 (CetinSert)
07:22:54 * hackagebot clock 0.5.0.1 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.5.0.1 (CetinSert)
07:22:56 * hackagebot autonix-deps-kf5 0.3.0.0 - Generate dependencies for KDE 5 Nix expressions  http://hackage.haskell.org/package/autonix-deps-kf5-0.3.0.0 (ThomasTuegel)
07:23:01 <ocharles_> so it sounds like whoever is calling 'schedulesQuery' is also holding on to data
07:23:43 <quetzakubica> mizu_no_oto: thanks, that way it should be fine to keep immutable data in JS
07:24:09 <quetzakubica> mizu_no_oto: anyway I don't know if it changes anything for JS, since it's one threaded
07:24:14 <Cale> quetzakubica: The worst thing that can happen is that two threads both start to evaluate the same expression at the same time -- immediately after the expression starts evaluating, the code pointer is rewritten to point at a piece of code which will get other entries to that expression to block, but if both enter at the same time, work can be repeated. Of course, both threads will compute the same result. This is extre
07:24:14 <Cale> mely rare in practice, though.
07:24:31 <Cale> (I'm talking about Haskell, rather than JS)
07:25:24 <quetzakubica> Cale: interesting
07:25:29 <mizu_no_oto> quetzakubica: This is problematic with a general (i.e. cyclic) graph (where most nodes will be changed if you update something), but is quite efficient with a acyclic graph (i.e. a tree), where log(n) nodes will need to be replaced
07:25:50 <mizu_no_oto> well, acyclic undirected graph
07:26:51 <mizu_no_oto> but often general graphs are represented via e.g. an adjacency matrix instead of directly
07:29:34 <jhaberku> I'm reading "Functional Programming in Scala" having previous Haskell experience, and the book is extraordinarily good. I'm learning a great deal. Scala is the vehicle, rather than the focus. I'm wondering if Haskellers are aware of it, because I think it could be a great model for a future Haskell text.
07:31:31 <mizu_no_oto> pchiusano: any interest in writing "Functional Programming in Haskell"?  :p
07:31:50 <mizu_no_oto> Or was one book enough?
07:31:51 <Phillemann> More interesting would be "Nonfunctional Programming in Haskell" ;)
07:31:59 <ReinH> jhaberku: it's a great book whose only shortcoming is using Scala
07:32:12 <jhaberku> pchiusano: Kudos! You have a fantastic pedagogical style.
07:32:21 <mizu_no_oto> Phillemann: Disfunctional programming in Haskell?
07:32:48 <ReinH> Perhaps the best thing about it is that it will quickly convince you that you need a better language than Scala to express your functional thoughts ;)
07:32:53 * hackagebot relational-query 0.5.1.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.5.1.0 (KeiHibino)
07:33:21 <mizu_no_oto> ReinH: for that reason, I'm hopeful that 'Functional Programming in Java' is wildly successful
07:33:39 <ReinH> mizu_no_oto pls
07:33:52 <ReinH> Well, at least Java has generics
07:34:46 <mizu_no_oto> I figured it was a late April Fools joke when I heard about it, but apparently apocalisp got roped into writing it because they were going to publish it with or without him helping
07:35:00 <mizu_no_oto> or something like that
07:35:30 <ion> Dysfunctional Programming in Haskell
07:36:03 <ion> Chapter 1: unsafePerformIO
07:36:07 <jhaberku> ReinH: I do think _some_ things in Scala are interesting (with the caveat that I have no PL theory background): abstract type members, the module system, implicits allowing for more than one instance of a typeclass.
07:36:09 <ReinH> mizu_no_oto: who is the publisher?
07:37:25 <mizu_no_oto> ReinH: http://www.manning.com/saumont/
07:37:32 <mizu_no_oto> same as FPinScala
07:37:37 <jhaberku> Plus, it has some notions of dependent types ("path-dependent types"). I don't pretend to know what the limits or implications are of that, though.
07:38:22 <nuttycom> jhaberku: well, Scala doesn't really have a module system, per se.
07:38:44 <nuttycom> And having incoherent typeclass instances isn't a good idea in *any* language.
07:39:12 <jhaberku> nuttycom: Why not?
07:39:22 <mizu_no_oto> jhaberku: the possibility of having ambiguous implicits is both good and bad.  It adds a bit more power, but takes away a lot of  ability to reason about the code, and gives me tons of spurious compiler errors when combined with subtyping
07:39:35 <nuttycom> Having the semantics of your code change depending upon what has been imported into your local scope is a nightmare.
07:39:55 <nuttycom> I've been principally a Scala programmer since about 2008, and there's a reason that I've jumped ship for Haskell.
07:40:10 <mizu_no_oto> The classic example is Sets.  Two sets have no guarantee that they have the same underlying order, so set union has to suck
07:41:09 <nuttycom> IMO, if you want multiple typeclass instances for a given type, you should just be passing around a dictionary explicitly.
07:41:31 <jhaberku> nuttycom: A record of functions?
07:41:35 <nuttycom> Yep.
07:41:38 <tdammers> sets shouldn't have any order at all, conceptually
07:41:55 <tdammers> and the ordering they use internally shouldn't change their semantics
07:42:04 <hodapp> GAAAH. I have realized that I spent a considerable amount of time implementing something on my own which was already implemented in Ivory, but which no one bothered to freaking document.
07:42:29 <tdammers> if it's not implemented, it doesn't exist (for practical intents and purposes)
07:42:37 <tdammers> s/implemented/documented/
07:42:50 <mizu_no_oto> In Haskell, you can do a nice efficient 'hedge union' by descending the two trees, which is O(m+n).  In scala, you need to insert one into the other, which is O(n log m)  
07:43:23 <S11001001> mizu_no_oto: or you can just pretend that the Ords are coherent, which is why ISet uses hedge union.
07:43:37 <S11001001> There's a lot of pretending in Scala.
07:43:48 <mizu_no_oto> S11001001: expecially in scalaz
07:43:55 <nuttycom> tdammers: well, Ord in this case is really important in terms of Eq - and if your notions of equality differ at different places in your program, there's not much hope for you anyway.
07:43:56 <jhaberku> There are a couple of things that make Haskell frustrating, and I've been using it off and on for a few years now. Strings vs Text (and inconsistencies in libraries), cross-platform development support (Emacs is awsome on OS X and Linux, but frustrating on Windows since it assumes so much Posix stuff), Record naming/scope and updates (lens fixes the second, to a degree). Otherwise, I absolutely love the language and the experience.
07:44:08 <ReinH> I like to think of scalaz as Scala with zombies.
07:44:38 <tdammers> emacs isn't a requirement
07:45:02 <mizu_no_oto> tdammers: also, in that these are both tree sets, which require an order
07:45:27 <ReinH> jhaberku: those are pretty common (and reasonable) complaints
07:45:54 <ReinH> although tbh I don't know of a any non-Microsoft language for which windows is a *good* dev environment
07:46:02 <ReinH> s/a //
07:46:04 <jhaberku> Re: Scala :p
07:46:07 <tdammers> it's not even a good env for the MS languages
07:46:07 <jhaberku> ReinH
07:46:19 <tdammers> you use it because it's the only viable candidate
07:46:24 <ReinH> fsvo "good", I suppose
07:46:29 <tdammers> ya
07:46:34 <tdammers> "least bad"
07:46:51 <mizu_no_oto> ReinH: windows isn't really any worse than unix for IDE-oriented languages like Java
07:47:15 * tdammers gets a foul taste in the mouth from recalling day-long visual studio install fests
07:47:38 <tdammers> unix *is* an "IDE"
07:47:43 <hodapp> I fucking hate Visual Studio, and I hate the culture that it encourages.
07:47:45 <ReinH> still not disappointed that I don't work with those languages
07:47:45 <jhaberku> IntelliJ's Scala support is pretty steller, and it's worked pretty well on every platform I've tried it with (Linux, OS X, Windows). SBT (the stack/cabal equivalent) also works great on all platforms. Haskell is the better language, but I wish I had such a reliable development experience for it.
07:47:57 <ion> Does Visual Studio have an automated system of some kind for downloading and installing build dependencies, btw?
07:47:58 <tdammers> minus the tight coupling that the "I" implies
07:47:59 <hodapp> jhaberku: IntelliJ was nice when I used it for some Scala.
07:48:17 <hodapp> ion: Yes, it does! It's called Visual Studio. Enjoy your modular build system!
07:48:18 <nuttycom> jhaberku: LOL. It's nice so long as you're not trying to do anything interesting at the type level.
07:48:33 <nuttycom> If you write Scala like it's Java, IDEA is great!
07:48:37 <ReinH> like, you know, inference
07:48:47 <jhaberku> nuttycom: That's very true too.
07:48:48 <mostalive> ion: nuget (it's like apt-get but for Visual Studio instead of linux. VS is an operating system ;) )
07:48:58 <hodapp> ion: Also, sometimes it doesn't work right, and then you're just screwed
07:49:07 <jhaberku> I've hit lots of instances with ScalaZ of IntelliJ complaining of an error but the compiler accepting it.
07:49:13 <ion> alright
07:49:47 <nuttycom> My last Scala project, there was not a single file in our project where IDEA would believe that *any* of it was valid scala. Seas of red.
07:49:51 <hodapp> lol
07:50:07 <ion> nice
07:50:59 <nuttycom> About the only thing it would accept was case class constructors. But with the amount that we used scalaz, basically nothing else.
07:52:54 * hackagebot nagios-plugin-ekg 0.1.0.0 - Monitor ekg metrics via Nagios  http://hackage.haskell.org/package/nagios-plugin-ekg-0.1.0.0 (fractalcat)
07:52:56 <jhaberku> I would be SO happy if there was an IDE like IntelliJ that worked directly with platform-independent tools like ghc-mod for editing Haskell.
07:53:18 <jhaberku> Then I could use Emacs on OS X/ Linux and not have such an alien experience on Windows.
07:57:26 <kadoban> Can't you run emacs on windows?
07:58:11 <jhaberku> kadoban: You can, it's just that in practise it's a bit of a pain.
07:59:20 <jhaberku> Maybe stack will solve all my problems. :-)
08:02:05 <kadoban> Heh
08:02:54 * hackagebot vcache-trie 0.1.2 - patricia tries modeled above VCache  http://hackage.haskell.org/package/vcache-trie-0.1.2 (dmbarbour)
08:07:21 <narendraj9> And what do most people use for haskell-indentation in emacs?
08:07:52 <narendraj9> The modes that come with haskell-mode aren't good.
08:08:01 <ion> They usually write the code in emacs without indentation and then open it in vim and indent it.
08:08:35 <mniip> you could also use indent(1)
08:08:53 <narendraj9> ion: I am not talking about stoic people. :-D
08:09:00 <davean> ion: ...
08:09:10 <davean> narendraj9: haskell-mode is fine
08:09:55 <narendraj9> davean: A lot of times it won't get the indenation right. For example when you type the second line of a do block.
08:10:01 <Cale> narendraj9: Back when I was using emacs, I recall using the "simple" mode
08:10:24 <narendraj9> The simple mode doesn't understand haskell syntax at all.
08:10:31 <Cale> right
08:10:40 <ion> mniip: There is a longstanding dispute whether the K&R style or the GNU style is best for Haskell though.
08:10:51 <davean> narendraj9: well, it puts it right where I want it, and it valid haskell syntax?
08:11:18 <Cale> ion: hm?
08:11:26 <Cale> oh, lol
08:11:35 <narendraj9> davean: Which one of the three indenation modes are you using?
08:11:54 <mniip> ion, xD
08:11:59 <Cale> Basically all I want my editor to do usually is keep the indentation level of the previous line.
08:12:38 <Cale> None of the modes for any editor as far as I'm aware actually do the one other useful thing with respect to indentation I'd like to see
08:13:32 <Cale> Which is, any edit which causes the first non-whitespace character following 'let', 'of', 'do', 'mdo' or 'where' to move should cause the remainder of the block to move accordingly.
08:16:12 <ion> Elastic tab stops would result in that in a number of situations (but not all).
08:16:21 <Denommus> is it my impression, or is the rest client tutorial outdated?
08:16:30 <Denommus> is there another library for rest clients?
08:16:39 <Cale> Denommus: hm?
08:16:46 <Cale> Denommus: "the rest client tutorial"?
08:16:50 <Denommus> Cale: http://silkapp.github.io/rest/tutorial.html
08:17:20 <Cale> Denommus: There are a few major frameworks for writing web applications in Haskell.
08:17:59 <Denommus> Cale: I don't want to write a web application, I just want to write a simple rest client
08:18:00 <Cale> The big three are Happstack, Snap, Yesod. If you're looking for something more lightweight, maybe Scotty would be ideal.
08:18:13 <Denommus> Cale: client. Not server.
08:18:29 <Cale> Oh, client, I see
08:18:50 <Cale> Maybe just use http-client?
08:19:05 <Cale> Or the HTTP library?
08:20:27 <Cale> (I don't really know what the difference between "rest" and "use http" is though)
08:21:03 <aweinstock> Cale: does rest imply JSON-over-http?
08:21:10 <_fritz_> c =
08:21:10 <_fritz_> X
08:21:17 <_fritz_> sorry.
08:21:25 <Clint> aweinstock: it certainly does not
08:21:37 <arbelos> I am trying to pretty print aeson to the terminal, but newlines \n comes out literally as \n.
08:22:00 <Denommus> Cale: I'll check http-client, thanks
08:22:18 <Denommus> REST actually subsumes HTTP, it doesn't imply a specific protocol
08:24:58 <c_wraith> I think wreq is also worth investigation as an http client.  It's rather different from the rest of the libraries available, for better or worse.
08:24:59 <arbelos> ah. ok I shouldn't use print
08:25:48 <broma0> Will the state monad word well in a multi threaded program? I'm worried about simultaneous puts and gets
08:25:53 <broma0> Work well*
08:26:29 <aweinstock> broma0: State or ST?
08:26:32 <broma0> State
08:26:35 <c_wraith> State doesn't actually have any state.
08:26:45 <c_wraith> You can't use it multithreaded.  It just doesn't support that.
08:26:55 <broma0> Gah that's what I was afraid of
08:27:03 <broma0> Does ST support it?
08:27:08 <c_wraith> No
08:27:38 <broma0> Hmm how can we do shared state across threads?
08:27:51 <c_wraith> STM+TVar or MVars or IORefs
08:27:55 <c_wraith> Depending on the use case
08:28:18 <aweinstock> is "StateT s IO" relevant, or is that used for something else?
08:28:21 <ion> You can run pure computations that are parallel from State though.
08:28:39 <ion> But that’s probably a different problem than what broma0 is trying to solve.
08:28:39 <Cale> broma0: A computation of type State s a is essentially the same thing as a function s -> (s,a) and can't accomplish anything that such a function can't.
08:28:49 <c_wraith> aweinstock: it's only relevant if s happens to contain a ref type
08:28:54 <broma0> Cale, that makes it clear
08:29:13 <broma0> c_wraith, that could work.
08:29:30 <broma0> Probably an ioRef
08:29:43 <broma0> I belive it has an atomic modification fn
08:29:59 <c_wraith> yes, but be wary of that.
08:30:07 <c_wraith> Under high contention it creates thundering herd issues
08:30:11 <ion> Note the difference between switching the IORef in StateT and mutating what the IORef points to in IO.
08:31:17 <ion> You might want ReaderT (IORef a) instead of StateT (IORef a).
08:31:25 <ion> (Or just IORef a -> IO b)
08:31:30 <Cale> Please don't take the decision to use monad transformers over IO lightly
08:31:43 <broma0> ion, good point
08:31:51 <broma0> Cale, can you elaborate?
08:31:52 <jhaberku> Cale: Why? 
08:31:54 <jhaberku> Hah
08:32:02 <mizu_no_oto> broma0: what type of concurrency or parallelism do you need?
08:32:08 <benzrf> https://i.imgur.com/Lf0AKhF.png
08:32:13 <Cale> It typically just makes your code more annoying to write, without much benefit, and interacts poorly with lots of facilities in IO, such as forkIO and exceptions.
08:32:14 <benzrf> crap wrong channel
08:32:43 <jhaberku> benzrf: I never understood those cartoons.
08:33:29 <Cale> Like, if you use ReaderT just to avoid passing a parameter around, you're paying for that syntactically by having to liftIO all your actual IO actions, so you have to weigh that against the syntactic cost of just passing a parameter.
08:34:01 <Cale> and StateT over IO isn't really all that different from just passing an IORef most of the time.
08:34:59 <jhaberku> Cale: Is there a reason to not just default to a TVar?
08:35:00 <broma0> mizu_no_oto, I have a reader thread that rerenders something every time the state changes. I have N worker threads writing to that state.
08:35:13 <mniip> jhaberku, it's funny because dashcams
08:35:18 <broma0> I need to writes to queue up
08:35:24 <mniip> it's a known fact that everyone is russialand has dashcams
08:35:30 <broma0> I could simply use an MVar ....
08:35:36 <Cale> jhaberku: TVar has a lot of overhead relative to IORef
08:35:46 <jhaberku> Ah
08:36:19 <jhaberku> The Haskell concurrency book that Simon wrote is on my reading list. 
08:36:51 <mizu_no_oto> broma0: you might also be able to get away with just using the par function for that
08:37:05 <mizu_no_oto> depending on how real-time you need those updates
08:37:22 <broma0> It's a text editor... so very real time
08:37:32 <mizu_no_oto> Ah
08:38:47 <mizu_no_oto> Using STM is probably reasonable, here
08:39:09 <broma0> Is that the ST monad? I haven't used it before
08:39:28 <broma0> Well I have, but only I'm ghci not in a real program
08:39:43 <ion> STM is different.
08:40:51 <broma0> I'll look into it. From a brief skim it seems like a viable solution
08:41:22 <broma0> Why stm over st?
08:41:38 <ion> They are different things for different purposes.
08:41:58 <ion> STM is all about concurrency, ST has nothing to do with concurrency.
08:43:57 <Cale> broma0: Despite the similarity in name, STM and ST are very different.
08:44:09 <Cale> ah, ion answered, I was scrolled up
08:45:46 <mizu_no_oto> STM is Software Transactional Memory, ST is State Threads, iirc.
08:46:34 <BrianHV> why would a stack build fail, saying only Process exited with code: ExitFailure 1 ?
08:46:59 <Cale> ST actions are allowed to create mutable references (STRef) and arrays (STArray, STUArray) local to the execution of the action, and they may mutate these, but have no external effects otherwise, and no interaction with concurrency. Evaluating an application of runST :: (forall s. ST s a) -> a to one of these actions will carry out the action, and produce a pure result.
08:47:02 <mizu_no_oto> ST gives you observationally pure single-threaded mutable memory; STM gives database-transaction like semantics to working with concurrent data structures.
08:47:33 <broma0> stm sounds incredible
08:48:12 <argent0> how can I create a hoogle index for my project?
08:48:18 <mniip> let me ruin your dreams
08:48:34 <mniip> STM is just IO with a different name so that typechecker distinguishes atomic and non-atomic actions
08:49:17 <ion> STM isn’t “just IO” though. IO doesn’t have orElse and retry for instance.
08:49:35 <Cale> STM actions similarly allow the creation and manipulation of various sorts of mutable cells, arrays and channels (TVar, TMVar, TArray, TChan), but unlike with ST, the mutable things you create are allowed to escape the execution of the STM transaction and be used by others.
08:50:49 <mniip> ion, IO can have retry
08:50:57 <Cale> You execute an STM action using the function  atomically :: STM a -> IO a  which carries out the action described in a way which is consistent with it occurring atomically with respect to all other STM actions in the system (i.e. from the point of view of other threads, all the memory updates done by the action happen at once)
08:51:00 <mniip> the primitive is retry# :: State# RealWorld -> (#State# RealWorld, a#) 
08:51:18 <nshepperd> 'newtype STM a = STM (IORef (IO ()) -> IO a)' intriguing
08:51:23 <amf> is there a way to index a data structure by its numbered position, e.g. data A = A { Idx1 :: Bool, Idx2 :: Bool } etc; thus i dont have to use the record name
08:51:30 <mniip> nshepperd, what
08:51:32 <broma0> mniip, let me ruin your dreams hahaha
08:51:38 <mniip> nshepperd, what implementation is that
08:51:56 <Cale> STM is *not* just IO by another name.
08:51:57 <nshepperd> https://hackage.haskell.org/package/stm-2.4.4/docs/src/Control-Sequential-STM.html
08:52:18 <mniip> nshepperd, I'm talking about GHC implementation of STM
08:52:19 <mniip> see http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Conc-Sync.html#STM
08:52:20 <Cale> Also, its constructor ought not to be available generally. You shouldn't rely on any particular details of its implementation.
08:52:56 * hackagebot html2hamlet 0.2.0 - HTML to Hamlet converter  http://hackage.haskell.org/package/html2hamlet-0.2.0 (HideyukiTanaka)
08:52:59 <nshepperd> well, that's confusing
08:53:11 <silver> you can't rollback missile launch :D
08:53:21 <c_wraith> why not?
08:53:28 <mniip> silver, yes you can!
08:53:43 <mniip> http://hackage.haskell.org/package/acme-timemachine
08:53:45 <Cale> c_wraith: Why shouldn't you rely on details of the implementation of STM?
08:54:00 <c_wraith> Cale: no, why can't I roll back the missile launch?  It'd be really handy.
08:54:05 <nshepperd> oh, that's a conditional import for non-ghc
08:54:06 <Cale> heh
08:54:15 <nshepperd> I get it now
08:54:39 <mniip> c_wraith, see package ^
08:54:48 <Cale> Anyway, why are you mentioning anything with a # in its name to beginners?
08:54:50 <c_wraith> I've seen it!
08:54:57 <Cale> It's really inappropriate.
08:57:57 * hackagebot vcache-trie 0.2.0 - patricia tries modeled above VCache  http://hackage.haskell.org/package/vcache-trie-0.2.0 (dmbarbour)
08:57:59 <Cale> The important message here is that while there is a function STM a -> IO a, there is not a function IO a -> STM a, because indeed, STM transactions may have to roll back, and may be attempted several times before committing, so anything which had externally visible effects apart from memory effects (that can be written to a transaction log and committed all at once) would not work well at all.
08:58:29 <Cale> So saying "STM is just IO" is really inappropriate, because the types are intentionally not isomorphic.
08:59:15 <Cale> (even in cases where the underlying mechanism used to implement them might be the same)
08:59:38 <nshepperd> <_< all types are just ByteString
08:59:53 <mniip> you mean
08:59:56 <mniip> MutableByteArray
09:00:07 <tommd> Things that do not exist: unsafe* inline* "foreign .*" *# head, tail... anything else?
09:00:30 <oconnore> tommd: ?
09:00:38 <tommd> wrt talking to a beginner.
09:00:44 <Cale> heh
09:01:01 <oconnore> oh, yeah. 
09:01:05 <ReinH> fromJust :p
09:01:08 <Cale> head and tail are okay to mention, so long as we explain them with care
09:01:45 <Cale> It should be made clear that if you use head/tail, it should be because you know the list is nonempty without having to test for that condition.
09:01:48 <tommd> Yes, local certainty about the inputs.  I agree.  Just, they are often mis-used and the algorithm should change or the presentation should use pattern matching.
09:02:04 <mniip> ReinH, https://hackage.haskell.org/package/acme-safe-0.1.0.0/docs/src/Acme-Safe.html#safeFromJust
09:02:30 <ReinH> I am particularly frustrated with teaching materials that introduce head/tail before pattern matching on [] and :
09:02:56 <tommd> ReinH: Those exist?
09:03:02 <ReinH> Yes :(
09:03:31 <ReinH> e.g., the incredibly awful Beginning Haskell: a Project-Based Approach
09:04:09 <ReinH> At least the examples using head/tail don't actually compile, iirc
09:04:10 <ion> I wonder if anyone has used Cmm instead of C in a Haskell-with-C-ish-parts project (other than GHC)? GHC seems able to compile Cmm files for you but i don’t know if Cabal knows about that.
09:04:22 <tommd> ReinH: I'll have to read it.  I'm putting together a "Beginning Foo: Project-Based Approah" book and want to not suck.
09:04:57 <shachaf> ion: Some Cabal projects have primops implemented in Cmm.
09:07:56 <ReinH> tommd: for what?
09:08:29 <athan> Hi all. Why isn't ST an instance of MonadState?
09:08:48 <mniip> because ST isn't a state monad?
09:09:38 <ion> instance MonadState RealWorld# ST where …
09:09:40 <c_wraith> You can create as many STRefs as you like
09:09:50 <c_wraith> Which one would get, well.. get?
09:10:30 <mniip> ion, you mean State# RealWorld
09:10:59 <athan> ion, mniip, c_wraith: Ahh!! Okay, that makes a lot of sense :) thank you
09:12:38 <ion> instance MonadState (exists s. s) ST
09:17:14 <aweinstock> is it possible to get a C function inlined into haskell callers by GHC?
09:17:52 <bitemyapp> aweinstock: no
09:17:57 * hackagebot snaplet-hasql 1.0.0 - A Hasql snaplet  http://hackage.haskell.org/package/snaplet-hasql-1.0.0 (MikeLedger)
09:17:59 * hackagebot snaplet-hasql 1.0.1 - A Hasql snaplet  http://hackage.haskell.org/package/snaplet-hasql-1.0.1 (MikeLedger)
09:18:17 <bitemyapp> aweinstock: there's safe FFI, unsafe FFI, or you could finagle stuff in # to produce the asm you want.
09:18:37 <bitemyapp> aweinstock: how many microseconds is the computation you're performing in C?
09:19:51 <aweinstock> bitemyapp: this is for an implementation of fast inverse square root, using unsafeCoerce# (on Double#'s and Int#'s) causes GHC to error at the assembly stage
09:20:38 <ion> Are you sure Double# and Int# have the same size everywhere?
09:21:28 <dolio> Doesn't matter if you're sure, if it's not true. :)
09:21:28 <aweinstock> no, but I think they do on x86-64 (both 8 bytes)
09:21:31 <obfuscatr> if I can get one value from a monad with v <- m, how can I get a list of n v's from m?
09:21:48 <ion> obfuscatr: replicateM n
09:22:13 <mniip> :t replicateM -- obfuscatr
09:22:15 <lambdabot> Monad m => Int -> m a -> m [a]
09:22:33 <obfuscatr> ion: i tried that, but that gives me a list of monads, not a list of values
09:22:49 <mniip> obfuscatr, replicateM, not replicate
09:22:58 * hackagebot xmonad-screenshot 0.1.2 - Workspaces screenshooting utility for XMonad.  http://hackage.haskell.org/package/xmonad-screenshot-0.1.2 (DmitryMalikov)
09:22:58 <mniip> see the type signature
09:23:05 <mniip> it gives you a monadic list of values
09:23:15 <dolio> Anyhow, even if they are the same size, it's not specified that coercing between Int# and Double# is safe.
09:24:27 <nshepperd> unsafeCoercing between float and integrals is I believe known to not work
09:24:43 <nshepperd> because of something involving register allocations
09:24:54 <obfuscatr> hm. i'm not understanding. if m is a IO Int for example, then the type of v in v <- m is Int. when using replicateM, I get an IO [Int], but I want an [Int]
09:25:16 <nshepperd> https://hackage.haskell.org/package/reinterpret-cast if you want to do that
09:25:22 <ion> obfuscatr: Given ints <- (something :: IO [Int]) in a do block, ints :: [Int]
09:26:19 <mniip> obfuscatr, you have to use replicateM *with* <-
09:26:27 <athan> Is there a `unionWith` for lists? Something like `zipWith`, but resulting in the join of the two lists instead of the meet?
09:26:57 <mniip> zipWith is not a meet
09:27:27 <mniip> athan, you mean cross product with a function?
09:27:29 <athan> mniip: Doesn't `zip` take the minimum of the two?
09:27:39 <athan> mniip: I think so ._.
09:27:50 <athan> But I'd like non-applicable ones to remain
09:28:10 <athan> for instance `unionWith (+) [0] [1,1]` should reduce to `[1,1]`
09:28:25 <mniip> f [x, y] [a, b] -> [f x a, f x b, f y a, f y b]
09:28:26 <mniip> right?
09:28:32 <aweinstock> I have the definitions "intToDouble (I# x) = D# (unsafeCoerce# x)" and "doubleToInt (D# x) = I# (unsafeCoerce# x)", and using "ghc -O2 -S foo.hs" to get "foo.s", and am getting invalid assembly such as "subq %rax, %xmm2"
09:28:35 <c_wraith> > liftA2 (+) [0] [1,1]
09:28:36 <lambdabot>  [1,1]
09:28:37 <athan> mniip: No, not quite
09:28:45 <athan> I'd still want the zip-like behavior
09:28:50 <mniip> ah
09:28:54 <mniip> I see what you mean
09:28:57 <c_wraith> what are you actually looking for then?  extension?
09:29:00 <mniip> zip takes the shortest list?
09:29:04 <ion> athan: This might have what you want. http://hackage.haskell.org/package/these-0.4.2/docs/Data-Align.html
09:29:05 <mniip> and you want something else?
09:29:08 <athan> Ahh! Thank you c_wraith!
09:29:10 <obfuscatr> mniip: ahhh. ok. thanks. so `values <- replicateM n m`  is sensible way to do what I want?
09:29:15 <athan> :o
09:29:22 <mniip> obfuscatr, yes
09:29:35 <aweinstock> is there a way to get ghc to generate register-to-register moves that do the right thing for reinterpret-casting floats?
09:29:35 <c_wraith> athan: well, I'm not sure it's what you want.  It's cartesian prodcut
09:29:37 <c_wraith> *product
09:29:41 <athan> ahh crud
09:29:46 <c_wraith> > liftA2 (+) [1,2] [3,4]
09:29:47 <lambdabot>  [4,5,5,6]
09:29:49 <mniip> athan, do you know which list is shorter in advance?
09:29:54 <athan> c_wraith: Yeah I'd need a different instance
09:29:59 <athan> mniip: Nope :(
09:30:02 <alisia4>  What session persistance configuration should one use with Spock web framework?  It's documentation warns against using the built in one 'readShowSessionPersist' in production...
09:30:03 <c_wraith> athan: I suggest looking at the package ion suggested
09:30:10 <athan> Going for it :)
09:30:16 <athan> thanks guys
09:30:30 <Maykk> hey
09:30:34 <c_wraith> Hello
09:30:56 <obfuscatr> so I don't understand this description from the docs: 'replicateM n act performs the action n times, gathering the results.'. It seems more like replicateM just makes 5 copies of the monad. it doesn't actually perform the action..?
09:31:01 <bitemyapp> aweinstock: I pinged an expert about it, if they get back to me with an answer I will LYK
09:31:03 <mniip> athan, if you did, you could use zipWith id (fmap f x ++ repeat id) y
09:31:15 <aweinstock> bitemyapp: thanks
09:31:28 <mniip> obfuscatr, 5 copies of the monad would be [m a]
09:31:32 <bitemyapp> aweinstock: possibly later this afternoon.
09:31:34 <ely-se> Is it possible to make Cabal build *all* modules in hs-source-dirs without listing all of them in the cabal file and without importing them from any other module?
09:31:35 <athan> hmm, thanks for the idea mniip
09:31:35 <mniip> replicateM returns m [a]
09:31:42 <bitemyapp> aweinstock: best way to answer your question yourself is to learn the native backend (asm)
09:31:56 <bitemyapp> aweinstock: and read up on register-register moves. Afraid I don't touch this stuff often, I mostly write servers :P
09:32:01 <ion> 5 copies of the monad would be m ': m ': m ': m ': m ': '[] :-P
09:32:11 <bitemyapp> IO is usually my perf problem :D
09:32:21 * mniip adds DataKinds and TypeLits to the list of things that don't exist
09:32:30 <obfuscatr> mniip: yeah, but if I: let ms = replicateM n m, then get the value of ms twice, it has a new value each time. so replicateM didn't actually perform the action of the monad..
09:32:30 <teasel> hello?
09:32:32 <teasel> anyone here?
09:32:52 <comprehension> hey all
09:32:55 <mniip> obfuscatr, see this
09:32:55 <c_wraith> mniip: eh, datakinds and typelits are usually ok because you rarely think you need them unless you actually do need them.
09:33:03 <mniip> > replicateM 2 "bar"
09:33:05 <lambdabot>  ["bb","ba","br","ab","aa","ar","rb","ra","rr"]
09:33:06 <c_wraith> mniip: RankNTypes is also one that definitely exists.
09:33:14 <comprehension> is there a tool out there that can convert vanilla HTML to Yesod's Hamlet?
09:33:15 <mniip> as opposed to ["bb", "aa", "rr"]
09:33:24 <teasel> i've just installed haskell
09:33:27 <teasel> and i was hoping someone would help me
09:33:38 <teasel> anyone gentle enough to answer my questions?
09:33:40 <athan> Does the trick ion :) thank you!!
09:33:44 <arkeet> teasel: just ask
09:33:45 <c_wraith> teasel: just ask questions.  Someone will probably answer them.  There are lots of nice people here.
09:33:45 <mniip> teasel, not until you ask the actual questions
09:33:49 <Haskellfant> teasel: just ask your questions :)
09:33:54 <teasel> ok ok ^_^'
09:34:15 <c_wraith> @quote glorious
09:34:15 <lambdabot> Zao says: Avoid Harrop At All Costs; Our new and glorious motto.
09:34:16 <ReinH> teasel: in case you aren't aware, you can ask your question here...
09:34:19 <arkeet> (note you probably actually installed not haskell but ghc, or perhaps the haskell platform)
09:34:21 <c_wraith> @quote glorious.stereo
09:34:21 <lambdabot> No quotes match. Whoa.
09:34:26 <c_wraith> @quote glorious.q
09:34:26 <lambdabot> No quotes match. And you call yourself a Rocket Surgeon!
09:34:28 <c_wraith> Huh.
09:34:33 <arkeet> @where justask
09:34:33 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
09:34:34 <ion> obfuscatr: replicateM n m = do { a1 <- m; a2 <- m; …; an <- m; return [a1, a2, …, an] }. Anywhere you’re using replicateM you can use the latter form and vice versa.
09:34:39 <teasel> so i'm completly new to the language, i'm trying to use some example used by my professor using this http://www.tutorialspoint.com/compile_haskell_online.php
09:34:49 <teasel> problem is, i always seems to get some error
09:34:51 <teasel> it's driving me crazy
09:34:58 <comprehension> teasel: it's probably your code
09:35:19 <mniip> what
09:35:23 <teasel> is there a difference between ghci and that thing i linked?
09:35:23 <Haskellfant> teasel: post your code and the error on lpaste
09:35:28 <mniip> print("Value of factorial 5 ")
09:35:30 <mniip> in the top level?
09:35:35 <c_wraith> @where lpaste
09:35:36 <lambdabot> http://lpaste.net/
09:35:36 <Haskellfant> @where lpaste
09:35:36 <lambdabot> http://lpaste.net/
09:35:40 <arkeet> this is neither a valid haskell source file nor valid ghci input.
09:35:53 <arkeet> which one are you using?
09:36:01 <teasel> for example i tried running this
09:36:03 <teasel> http://www.dipmat.unict.it/~barba/PROG-LANG/ESERCIZI/EserciziHASKELL/SOLUZIONI_HASKELL/es01.txt
09:36:24 <teasel> it just tell me something about main not existing
09:36:27 <mniip> teasel, that seems like a valid haskell file
09:36:34 <nshepperd> aweinstock: the whole topic of coercing float types is somewhat discussed here https://stackoverflow.com/questions/6976684/converting-ieee-754-floating-point-in-haskell-word32-64-to-and-from-haskell-floa/7002812
09:36:36 <arkeet> right, every haskell program must define main
09:36:42 <arkeet> (else there is nothing to run)
09:37:01 <teasel> so... to fix it what should i do?
09:37:08 <mniip> main = return ()
09:37:09 <ion> obfuscatr: Evaluating a replicateM invocation (or for that matter, the equivalent do block) doesn’t execute anything, it just combines all the IO actions to a bigger one that can be executed by binding “main” to it.
09:37:10 <arkeet> well, what is your goal?
09:37:13 <nshepperd> I don't know if there's really any more advanced way since then (inline asm in ghc?)
09:37:27 <teasel> ok...
09:37:33 <teasel> let's say i want to create a function
09:37:42 <obfuscatr> ion: in that code block, if I do let baz = repliaceM n m ... baz doesn't actually immediately get the values, but rather takes the value of a function to replicate the monad... is that correct?
09:38:01 <mniip> obfuscatr, baz becomes an IO action
09:38:10 <mniip> that when executed, returns a list of n items
09:38:22 <mniip> each of which is a result of separate execution of m
09:38:36 <ion> obfuscatr: Given m :: IO a, baz :: IO [a].
09:38:42 <ion> @quote /bin/ls
09:38:42 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:38:57 <teasel> http://pastebin.com/invVuwAt
09:39:03 <teasel> if i try this code it just give me an error i don't understand
09:39:05 <comprehension> can anyone here speak up for yesod? i'm reading through their docs and i'm confused about the design
09:39:05 <teasel> it's driving me crazy
09:39:12 <obfuscatr> mniip, ion, thanks.
09:39:13 <ion> teasel: What error?
09:39:15 <comprehension> teasel: welcome to haskell
09:39:36 <shachaf> I'm sure no one else here will understand it either, so don't bother telling other people what it is.
09:39:36 <ion> teasel: Oh. main needs to be of type IO a. Try main = print (add 2 3)
09:39:43 <ely-se> teasel: main must have type IO a for some a
09:39:50 <ely-se> add 2 3 has type Integer
09:39:57 <arkeet> teasel: whenever you get an error message, please include it in your paste
09:40:04 <teasel> wow that worked
09:40:10 <teasel> i can't believe the error was something that dumb
09:40:26 <arkeet> because then we can help you understand the error :-)
09:40:37 <teasel> yeah i was trying to paste the error but it wouldn't let me sorry ^_^'
09:41:43 <teasel> allright so what if i wanted to call the function outside like....
09:41:45 <teasel> http://pastebin.com/bkjMKmZM
09:42:08 <arkeet> you want to use it from ghci?
09:42:27 <teasel> yeah but to be honest i'm not sure that thing i posted supports ghci
09:42:44 <arkeet> well just pasting that into ghci won't work
09:42:52 <arkeet> you can load a .hs file into ghci using :l (short for :load)
09:43:02 <teasel> i see, i see
09:43:08 <mniip> or by including it in the commandline
09:43:11 <mniip> ghci File.hs
09:43:15 <teasel> ok there is one thing i don't understand
09:43:19 <teasel> when i declare the add function i type
09:43:28 <teasel> add                     :: Integer -> Integer -> Integer
09:43:32 <teasel> what exactly am i writing here?
09:43:38 <arkeet> that declares the type of add.
09:43:48 <mniip> it's a function that takes two integers and returns an integer
09:44:00 <teasel> oh so it's integer -> integer to indicate it takes two integer
09:44:04 <mniip> no
09:44:14 <teasel> i don't understand why there are 3 arrows instead of 2
09:44:21 <mniip> there are 2 arrows .-.
09:44:23 <teasel> i mean it takes some integers and return an integers
09:44:29 <teasel> err i mean 2 arrows instead of 1
09:44:33 <teasel> it should be integers -> integers no?
09:44:33 <nuttycom> teasel: have you heard of currying?
09:44:38 <mniip> ^
09:44:43 <teasel> yeah but i'm not sure i understand it correctly
09:44:51 <arkeet> it is parsed as Integer -> (Integer -> Integer)
09:44:54 <ReinH> add :: Int -> Int -> Int takes an Int and then another Int and gives an Int
09:44:55 <ely-se> teasel: add is a function that takes an Integer and returns a function that takes and Integer and that returns an Integer
09:45:03 <nuttycom> teasel: okay, it's really simple. Consider a function (Int, Int) -> Int
09:45:10 <teasel> ok
09:45:22 <nuttycom> If you just gave it the first int of the tuple, you'd need another int to "fill in" that tuple to get a result, right?
09:45:28 <teasel> yeah
09:45:29 <ely-se> in say C# it'd be Func<int, Func<int, int>>
09:45:34 <nuttycom> So, passing the first int, you get returned a function that takes another int.
09:45:39 <nuttycom> And returns an int.
09:45:47 <mniip> X -> Y is a function that takes X and returns Y, Int -> (Int -> Int) is a function that takes an Int, and returns an Int -> Int, which takes another Int and returns an Int
09:45:57 * ReinH sighs
09:46:00 <teasel> yeah i think i sort of get it
09:46:03 <ely-se> "add x y = x + y" is the same as "add = \x -> \y -> x + y"
09:46:12 <ely-se> inb4 monomorphism restriction
09:46:15 <ReinH> I wonder if anyone else wants to give it a shot
09:46:29 <ReinH> So far we only have 5 people trying to explain this
09:46:37 <teasel> well allright that answer some of the question i had for now
09:46:37 <nuttycom> LOL
09:46:40 <mniip> just#haskellthings
09:46:46 <teasel> i'll come back when i come up with new things to ask ^_^
09:46:47 <hzjd> I think nuttycom did it pretty well
09:46:47 <arkeet> sometimes we are too helpful.
09:47:10 <hzjd> …is it time for someone to ask what a monad is yet?
09:47:17 <Serpentine_> What's a monad?
09:47:19 <arkeet> what is a burrito?
09:47:24 <teasel> that was actualy one of the thing i wanted to ask later
09:47:27 <mniip> teasel, not sure how much this will help, but it's two arrows because there's two applications
09:47:39 <ely-se> arkeet: definitely not a monad.
09:47:46 <mniip> first you apply 'add' with '2', then you apply 'add 2' with '3'
09:47:49 <teasel> but i think i want to read more about it myself
09:47:51 <ReinH> Serpentine_: Monad is a typeclass with methods return, (>>=) and join
09:48:02 <teasel> oh i see that's a nice way to explain it mniip
09:48:06 <aweinstock> nshepperd: thanks for the information
09:48:09 <ely-se> I prefer: a monad is anything that obeys the laws of monads.
09:48:14 <ReinH> wait, it doesn't have join any more, does it
09:48:17 <dolio> I don't think it has join yet.
09:48:23 <nuttycom> https://en.wikipedia.org/wiki/Monad_(philosophy)
09:48:24 <ReinH> dolio: sad :(
09:48:31 <teasel> anyway i was saying, i have an exam in college that's all about coding language like OCaml, PICT and the like
09:48:33 <dolio> There's a problem with it, actually. Something to do with roles.
09:48:37 <teasel> and the first argument is haskell
09:48:41 <ely-se> it also has (>>) and fail
09:48:46 <ely-se> which is an epic fail
09:48:46 <ReinH> dolio: hmm
09:48:47 <mniip> fail ಠ_ಠ
09:48:47 <nuttycom> (teasel, ignore that link, it's a joke)
09:49:01 <nuttycom> at least, it's a joke in a haskell channel
09:49:02 <arkeet> dolio: iirc having join in the class breaks new generalizednewtypederiving
09:49:09 <dolio> Right.
09:49:13 <arkeet> because roles
09:49:13 <comprehension> the problem is that a monad is actually a quesadilla 
09:49:28 <ely-se> mniip: no, ಠ_ಠ is error https://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
09:49:38 <ReinH> But, see, if you make a burrito out of other, smaller burritos...
09:49:45 <nuttycom> ely-se: (>>) is a completely reasonable function.
09:49:46 <ely-se> I'm an APL programmer. A monad is a unary function!
09:49:52 <nuttycom> fail, however....
09:50:06 <comprehension> teasel: Haskell maps pretty closely on to OCaml
09:50:17 <comprehension> with some hugehugehuge exceptions
09:50:29 <teasel> oh yea
09:50:31 <comprehension> but a lot of the type system will be familliar
09:50:31 <ReinH> So, closely expect not closely
09:50:35 <teasel> i remembered another thing i wanted to ask
09:50:38 <ReinH> *except
09:50:39 <teasel> how do you ask for a type of data?
09:50:41 <mniip> ocaml doesn't separate execution from evaluation, does it
09:50:44 <ely-se> I'm too lazy to list all the differences between Haskell and OCaml.
09:50:48 <mniip> teasel, in ghci? :t
09:50:54 <mniip> :t "hello"
09:50:55 <lambdabot> [Char]
09:51:06 <comprehension> mniip: no? it's strict
09:51:29 <arkeet> you can have the IO separation in a strict language just fine.
09:51:46 <arkeet> but ocaml does not have that.
09:52:00 <comprehension> arkeet: i'm not sure what IO separation means, then
09:52:03 <nuttycom> in fact, such a separation is quite desirable - referential transparency is a really useful property to have.
09:52:11 <teasel> is there a way to do it inside the code?
09:52:22 <arkeet> comprehension: the fact that you can evaluate IO actions without executing them in haskell has nothing to do with strictness.
09:52:22 <teasel> like if i wrote main = print(t:"hello")
09:52:22 <teasel> ?
09:52:29 <arkeet> teasel: you cannot do it in code.
09:52:37 <ReinH> teasel: You already know the types of things because everything has a type.
09:52:45 <nuttycom> teasel: the easiest way is to annotate the type, and let the compiler complain at you when you've told it the wrong thing.
09:52:51 <teasel> ok so i guess if i create a data type and then want to do :t of that data type i have to load the file in ghci
09:52:52 <teasel> ok
09:52:55 <ely-se> teasel: you can't take the type of an expression in Haskell
09:52:59 <ely-se> :t is a GHCi-specific feature
09:53:00 <lambdabot>     Not in scope: ‘is’
09:53:00 <lambdabot>     Perhaps you meant one of these:
09:53:00 <lambdabot>       ‘id’ (imported from Data.Function),
09:53:07 <arkeet> yes, you can abuse error messages to figure out the type of things in your code.
09:53:18 <arkeet> but you get those at compile time, not runtime.
09:53:18 <ReinH> holes are quite nice
09:53:21 <arkeet> types don't exist at runtime.
09:53:25 <nuttycom> ReinH: +1
09:53:32 <ReinH> > map _f _l
09:53:33 <ely-se> maybe you can use Typeable, I don't know.
09:53:33 <hodapp> I have found holes rather useful.
09:53:34 <lambdabot>      Found hole ‘_f’ with type: a0 -> b
09:53:34 <lambdabot>      Where: ‘a0’ is an ambiguous type variable
09:53:34 <lambdabot>             ‘b’ is a rigid type variable bound by
09:53:36 <comprehension> arkeet: i don't follow, sorry --- what would a code snippet of that look like?
09:53:43 <arkeet> comprehension: hm?
09:53:51 <ReinH> You can use Typeable, but you don't actually want to.
09:53:54 <comprehension> arkeet: evaluation an IO action without executing it
09:53:54 <arkeet> comprehension: imagine a language exactly like haskell, but with strict semantics.
09:53:58 <nuttycom> teasel: if you haven't seen it yet, watch this: https://www.youtube.com/watch?v=52VsgyexS8Q
09:53:58 <ely-se> I think if you need holes you should restructure your code or add more type annotations.
09:54:06 <comprehension> arkeet: yes
09:54:16 <arkeet> comprehension: IO actions are still first class values in this language.
09:54:18 <ReinH> ely-se: ? Holes are a very useful tool.
09:54:33 <teasel> one of the question in my list of exercise
09:54:36 <ReinH> Letting the compiler guide you is a cherished feature of Haskell development
09:54:39 <ely-se> I disagree.
09:54:47 <hacker> type holes let you do type-driven development easily
09:54:55 <teasel> ask... "what happens if you write :type funct"
09:54:57 <teasel> sooooooo
09:55:01 <teasel> what happens if you write :type funct?
09:55:01 <arkeet> teasel: ing hci
09:55:03 <arkeet> in ghci*
09:55:03 <ReinH> Using holes doesn't imply that you don't understand your code
09:55:12 <nuttycom> teasel: well, try it?
09:55:14 <ReinH> teasel: you'll get the type of funct or an error
09:55:15 <hodapp> ReinH: Indeed using them can *help* you understand the code.
09:55:37 <comprehension> arkeet: oh, i see. so when you say "evaluating an IO action" you mean something like reducting "print $ 2 + 2" to "print 4" without executing the print?
09:55:37 <mniip> ReinH, hold on a sec, I had some code around here somewhere
09:55:45 <comprehension> reducing*
09:55:46 <arkeet> comprehension: yeah perhaps.
09:55:52 <teasel> it assumes that before writing that you write
09:56:23 <arkeet> comprehension: or taking an IO action and composing multiple copies of it to run it multiple times.
09:56:23 <ReinH> ely-se: e.g., https://www.youtube.com/watch?v=52VsgyexS8Q, https://www.youtube.com/watch?v=DHH5mNaseis
09:56:31 <arkeet> even though it only gets evaluated once.
09:56:42 <teasel> funct :: [int] -> Bool
09:56:44 <michaelt> > let n = (1::Int) + _ in n
09:56:45 <lambdabot>      Found hole ‘_’ with type: Int
09:56:45 <lambdabot>      Relevant bindings include n :: Int (bound at <interactive>:1:5)
09:56:45 <lambdabot>      In the second argument of ‘(+)’, namely ‘_’
09:57:03 <teasel> if i write that in ghci it tells me
09:57:05 <teasel> "not in scope funct"
09:57:09 <ReinH> teasel: [int] is probably not what you meant
09:57:12 <comprehension> arkeet: ah ok, i get it. thanks!
09:57:25 <teasel> well that's what the exercise say
09:57:30 <hodapp> ReinH: are both those guys Aussie? o_O
09:57:31 <ReinH> Are you *sure*?
09:57:33 <arkeet> teasel: yeah, ghci is a bit different from a haskell source file.
09:57:36 <ReinH> Are you sure it doesn't say [Int]?
09:57:44 <teasel> oh yeah with the capital I
09:57:45 <arkeet> teasel: when you write "funct :: [Int] -> Bool" in ghci
09:57:48 <teasel> and also Boolean
09:57:52 <ReinH> They are two different things
09:57:53 <arkeet> you are asking for the value of funct
09:57:56 <mniip> ReinH, you can inspect the types using Data.Typeable http://lpaste.net/135211
09:58:00 <ReinH> In Haskell, it's Bool
09:58:02 <arkeet> which you are also restricting to have that type
09:58:08 <nuttycom> ely-se: ReinH: there's a fair argument to be made that if you're using holes in development, that the types you're searching for may be difficult to visually infer for a maintainer coming back to the code. But, the auxiliary brain aspect is really nice; you can always factor toward more composition and correctly annotated types after you've figured them out.
09:58:09 <ReinH> mniip: I know. I said you *could* but *shouldn't*, in this case.
09:58:28 <teasel> yeah that's what i don't understand what's ghci exactly? i tought it was just an interface to write haskell code
09:58:32 <teasel> but i guess i am wrong on that?
09:58:41 <ReinH> nuttycom: I use holes for very simple things because asking the compiler takes a second and thinking often takes more than a second
09:58:45 <geekosaur> it's a "desk calculator mode"
09:58:47 <mniip> typeOf () -> TypeRep #F# (TyCon #F# "ghc-prim" "GHC.Tuple" "()") []
09:58:49 <arkeet> you can write code in it, but the syntax is a bit different.
09:58:53 <nuttycom> teasel: it's an interactive evaluation environment for Haskell.
09:58:55 <arkeet> e.g. to declare things you have to write stuff like
09:58:59 <arkeet> "let foo = ..."
09:59:02 <arkeet> instead of just  "foo = ..."
09:59:06 <nuttycom> a REPL (read, eval, print, loop)
09:59:20 <teasel> allright so basicaly if i wanted to test the code it's better if i write somewhere else then load it rather than just writing it directly on ghci?
09:59:23 <ely-se> teasel: it's a tool where you enter an expression and it will print the result. what other languages are you familiar with?
09:59:26 <geekosaur> you can prototype in it to some extent but it's not really an IDE or etc. (most notably, there is no way to save what you've defined in a given session)
09:59:27 <teasel> is there a GUI to make it easier?
09:59:33 <arkeet> teasel: pretty much that's what we do yeah.
09:59:35 <ReinH> teasel: files are good for storing things like lines of code...
09:59:38 <teasel> ely - C++,java and python
09:59:56 <ely-se> When you enter "python" in the command line and hit enter, you get ">>>". GHCi is very similar to that.
09:59:59 <arkeet> there are some haskell IDEs but they're not too widely used.
09:59:59 <comprehension> teasel: it's like the python shell
10:00:07 <arkeet> if you use emacs there's something called haskell-mode
10:00:14 <arkeet> I think that does some stuff. not sure exactly what.
10:00:22 <ReinH> One thing at a time folks
10:00:28 <teasel> mmm i see
10:00:28 <nuttycom> teasel: emacs-mode is supposed to be good; I just use vim and a terminal where I run the compiler.
10:00:32 <comprehension> haskell-mode has syntax highlighting and maybe completion and other stuff
10:00:33 <nuttycom> I think that's a good way to start.
10:00:45 <geekosaur> teasel, there's various editor integration things, perhaps most advanced for emacs although also for vim, there's SublimeHaskell, etc. for GUI interactive stuff there is recently iHaskell which is a Haskell backend for iPython notebooks
10:00:48 <comprehension> when i tried to turn on the autocomplete it killed my whole emacs, so shrug
10:00:53 <ReinH> "If you want to learn X, go learn Y and then you can use it to do X" isn't super helpful
10:01:05 <nuttycom> But, if you don't know emacs or vim yet, just pick whatever simple text editor you do know.
10:01:25 <teasel> well anyway
10:01:29 <hacker> teasel: you can use any text editor that does basic syntax highlighting
10:01:29 <teasel> you guys were super helpful
10:01:30 <ReinH> You can write Haskell in vi-compatible mode without any plugins just fine.
10:01:31 <Denommus> in aeson, is there a way for me to represent that a field may have two different types?
10:01:35 <mniip> even notepad is fine, given you can be arsed to type out the tabs every time
10:01:37 <teasel> hacker - i like SCITE
10:01:38 <comprehension> ReinH: i'm super skeptical of teasel's professor for throwing him off the deep end 
10:01:44 <bitemyapp> nuttycom: I'm an Emacs user and I still use separate cabal repl instances in the terminal.
10:01:48 <Denommus> I mean, can a field be an ADT?
10:01:51 <ReinH> Or whatever editor you prefer, without any specific haskell support (although syntax highlighting is nice and usually easy to come by)
10:02:04 <bitemyapp> you don't need fanciness to work with Haskell
10:02:09 <teasel> aaaaaaaaaaaaanyway
10:02:11 <nuttycom> bitemyapp: you must not be *completely* absorbed by the borg
10:02:13 <hacker> teasel: a relatively common workflow is any text editor, and a terminal with ghci (and that file loaded), where you'll be doing things like :r for checking your code typechecked :)
10:02:14 <teasel> you guys were super helpful
10:02:14 <bitemyapp> the language is nice enough that you don't need tonnes of tool support even if it is nice.
10:02:22 <bitemyapp> nuttycom: I did use Chris Done's Haskell setup
10:02:23 <teasel> i'll come back if i have more things to ask
10:02:28 <ReinH> bitemyapp: in this country we say "tons" :p
10:02:30 <bitemyapp> nuttycom: but it wasn't appropriate to my work style.
10:02:31 <teasel> cya!
10:02:49 <bitemyapp> nuttycom: it would take a long time to explain the UX friction that makes me use the terminal, but they're probably different reasons than yours.
10:02:55 <bitemyapp> nuttycom: but as an Emacs user, I have the option, you do not.
10:03:24 <comprehension> nuttycom: i'm a diehard emacs user but i prefer to run my code in a terminal for the most part
10:03:35 <nuttycom> Heh. My reasons for preferring vim are really the same as my reasons for using Haskell. I really like the compositionality of command-mode editing.
10:03:39 <ely-se> I use ed for all my Haskell development.
10:03:40 <ReinH> bitemyapp: I overcame the friction of working with chrisdone's setup by painstakingly reshaping myself to fit the chrisdone mold.
10:03:48 <bitemyapp> part of the reason I use the terminal is so I can have one cabal repl instance for the library, one for tests.
10:04:01 <bitemyapp> if you know how to make concurrent REPL instances with different targets work in Chris' model, I will be very surprised.
10:04:02 <nuttycom> I have been considering giving spacemacs a try, though.
10:04:04 <comprehension> i have a permanent shell open on one monitor so it's easy to just bounce my focus over there and run things
10:04:25 <mniip> I have a permanent shell open on the only monitor I have :(
10:04:31 <bitemyapp> further, loading code in Emacs hangs my fucking text editor for multiple seconds
10:04:35 <bitemyapp> that is not okay.
10:04:36 <joneshf-laptop> what is chris done's setup?
10:04:47 <bitemyapp> joneshf-laptop: "everything lives in Emacs"
10:04:55 <ely-se> I typically have about seven terminals open all for doing various things
10:05:00 <nuttycom> Hah. I have a permanent tmux session open. Many shells.
10:05:06 <indiagreen> Denommus: yes, you just write something like “(Foo <$> ...) <|> (Bar <$> ...)”
10:06:40 <alisia4>  What session persistance configuration should I use with Spock web framework?  It's documentation warns against using the built in one 'readShowSessionPersist' in production...
10:07:59 <indiagreen> Denommus: there's an example here: http://artyom.me/aeson#types-with-many-constructors
10:10:10 <indiagreen> Denommus: it would be helpful if you said what ADT you have and what kind of JSON you're decoding
10:10:22 <bitemyapp> the main advantage of everything-in-Emacs is being able to do C-c C-l instead of :l src/Module/FileName.hs
10:10:43 <bitemyapp> which is quite nice, until I need to keep restarting my REPL because of package related stuff or it hangs my Emacs.
10:11:34 <alisia4> any one here familier with Spock web framework?
10:12:01 <bitemyapp> alisia4: it's just WAI
10:12:21 <bitemyapp> alisia4: if want session management, you'll probably write WAI middleware if Spock doesn't provide for it somehow.
10:12:41 <bitemyapp> alisia4: you can probably replicate whatever mode of session management you're accustomed to. If you don't know what to expect, learn from something more opinionated like Yesod for examples.
10:13:49 <alisia4> bitemyapp: Spock does have a simple one bundled in, but documentation says one should not to use it in production....
10:14:22 <bitemyapp> alisia4: so you have a few options
10:14:36 <bitemyapp> alisia4: 1. Learn why it's not appropriate for production use, then replace it with something that is
10:14:49 <bitemyapp> alisia4: 2. Replace it with something that you think is production appropriate without being sure why you had to replace it
10:14:57 <bitemyapp> alisia4: 3. Use it in production anyway and cross your fingers
10:15:36 <bitemyapp> alisia4: I know Spock has a simple one bundled in because you mentioned it earlier. I was suggesting you learn from Yesod's session management code as a means of migrating away from Spock's not-production-kosher one.
10:15:53 <bitemyapp> alisia4: I mentioned Yesod's because Yesod is built on top of WAI just like Scotty, Spock, and everything else that lives on top of WAI.
10:16:06 <bitemyapp> also because I know Yesod.
10:17:42 <dgpratt> I'm a little confused about the distinction/relationship between haskell-mode and ghc-mod, can someone straighten me out?
10:17:54 <alisia4> bitemyapp: I see. I was just surprised that it does not have a session handler, that I can use out of the box...I thought I might be missing something. 
10:18:51 <nuttycom> bitemyapp: ah, see, I rarely look at file names at all. ctags ftw
10:19:42 <alisia4> bitemyapp: So everyone who uses Spock write their own Session persistance code?
10:20:11 <nuttycom> alisia4: any WAI middleware that provides session persistance (such as that which ships with Yesod) may be used with Spock.
10:20:28 <nuttycom> Provided that Yesod's stuff is actually written as WAI middleware.
10:21:04 <ion> mniip: MonadState instances for ST and IO https://gist.github.com/ion1/57cd0673c631b1c73d8f
10:21:36 <nuttycom> alisia4: one thing that takes getting used to in Haskell is that most things are libraries, and frameworks are just opinionated collections of libraries for the most part. So using part of one "framework" inside of another is totally normal.
10:23:06 <alisia4> nuttycom: Yes,  Thankyou. 
10:25:43 <mniip> ion, ow
10:28:50 <nkaretnikov_> is there a version of hGetContents that doesn't close the handle, so I could use it multiple times?
10:30:04 <ion> mniip: Added MonadReader because why not
10:30:27 <benzrf> ehehehehe check this out
10:30:35 <benzrf> length (Compose [Just 1, Nothing, Just 3])
10:30:39 <benzrf> > length (Compose [Just 1, Nothing, Just 3])
10:30:41 <lambdabot>      Not in scope: data constructor ‘Compose’
10:30:41 <lambdabot>      Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
10:30:45 <benzrf> whaaat
10:31:01 <benzrf> @let import Data.Functor.Compose
10:31:02 <lambdabot>  Defined.
10:31:04 <benzrf> > length (Compose [Just 1, Nothing, Just 3])
10:31:05 <dmwit> Ran across this oldish question that I thought was kind of neat: http://stackoverflow.com/q/21732349/791604
10:31:06 <lambdabot>  2
10:31:26 <dmwit> benzrf: cute!
10:31:29 <maerwald> benzrf: what does that do?
10:31:29 <benzrf> ftp at work
10:31:46 <dmwit> maerwald: It's using the polymorphic version of length, I guess.
10:31:50 <ion> benzrf: nice
10:32:00 <benzrf> maerwald: an ambiguous instance error reminded me that Either and Maybe are foldable
10:32:01 <benzrf> so you have
10:32:11 <benzrf> > (length Nothing, length (Just "hi"))
10:32:15 <lambdabot>  (0,1)
10:32:39 <benzrf> then i thought "hmm what kind of cute trick could i do with this" and then inferred that the Foldable instance for Compose was probably sane
10:32:42 <maerwald> wat, doesn't work here, ghc too old?
10:32:44 <benzrf> in which case it would do that :>
10:32:46 <benzrf> maerwald: likely
10:32:48 <benzrf> you need 7.10
10:32:51 <maerwald> oh
10:32:54 <benzrf> or just import length from foldable
10:33:02 * hackagebot old-version 1.2.0 - Basic versioning library.  http://hackage.haskell.org/package/old-version-1.2.0 (chrisdotcode)
10:33:03 <maerwald> ah right
10:33:09 <maerwald> it's still on lists only in the old prelude
10:33:13 <chrisdotcode> :D
10:33:15 <chrisdotcode> mah package
10:33:36 <Iceland_jack> > foldr (:) [] (Compose [Just 1, Nothing, Just 3])
10:33:37 <lambdabot>  [1,3]
10:34:00 <benzrf> hahahaha
10:34:11 <Iceland_jack> > F.toList (Compose [Just 1, Nothing, Just 3])
10:34:12 <lambdabot>  [1,3]
10:34:24 <benzrf> well now it looks marginally less cute
10:35:15 <dmwit> > toList (Compose [Just 1, Nothing, Just 3])
10:35:16 <lambdabot>      Couldn't match type ‘Item (Compose [] Maybe a)’
10:35:16 <lambdabot>                     with ‘Item (Compose [] Maybe a0)’
10:35:16 <lambdabot>      NB: ‘Item’ is a type function, and may not be injective
10:35:35 <dgpratt> hmm
10:35:40 <dmwit> Oh, too slow.
10:35:51 <dgpratt> does anyone use either ghc-mod or haskell-mode?
10:35:59 <ion> > F.toList (Compose [Just 1, Nothing, Just 3])
10:36:00 <lambdabot>  [1,3]
10:36:17 <ion> Ah, missed Iceland_jack’s commands
10:36:18 <maerwald> dgpratt: are you just looking for meeting people who do? :P
10:36:25 * dmwit high fives ion
10:36:32 <benzrf> i use ghc-mod to get errors in vim
10:36:38 <obfuscatr> what is ghci using to render a IO [Int] at the command prompt. if I have something with type IO [Int], ghci can render it, but I can't 'show' it
10:36:51 <dgpratt> maerwald, not sure you saw my earlier query, I'm trying to understand if they are related and how
10:36:51 <Iceland_jack> ion: "A good poem is rarely said too often."
10:37:03 <ion> obfuscatr: ghci just executes it, just like if you had “main = <that expression>”.
10:37:10 <dgpratt> or at least which is the one typically used
10:37:43 <Iceland_jack> obfuscatr: If you want to apply the function 'show' to it you write
10:37:43 <Iceland_jack>     fmap show (action :: IO [Int])
10:38:20 <Iceland_jack> In GHCi you can do
10:38:21 <Iceland_jack>     ghci> val <- action
10:38:21 <Iceland_jack>     ghci> show val
10:38:51 <maerwald> https://www.youtube.com/watch?v=3bjXGrycMhQ this talk someone posted here yesterday or so is mostly great because of SPJs jokes xD
10:39:14 <maerwald> he does one almost every second minute
10:40:58 <Iceland_jack> obfuscatr: 
10:40:59 <Iceland_jack> :t fmap show :: IO [Int] -> IO String
10:41:00 <lambdabot> IO [Int] -> IO String
10:46:35 <ion> :-D https://github.com/ion1/acme-zero-one/issues/1
10:51:24 <agibiansky> Does anyone know of any resources for working with type-level lists? I'd like to implement an IsElem type family, but having trouble working through that myself (how do you do type-level equality comparison / branching?)...
10:53:03 * hackagebot luautils 0.1.4 - Helpers for Haskell integration with Lua  http://hackage.haskell.org/package/luautils-0.1.4 (AnupamJain)
10:53:12 <Iceland_jack> agibiansky: You can write something like
10:53:12 <Iceland_jack>     type family IsElem (a :: x) (xs :: [x]) :: Constraint where
10:53:12 <Iceland_jack>       IsElem x (x:xs) = ()
10:53:12 <Iceland_jack>       IsElem y (x:xs) = IsElem y xs
10:53:28 <Iceland_jack> Or return a lifted Bool
10:53:53 <jTT_> hi, i am trying to use Network.Wreq in ghci but i cannot import it. Msg is “    Could not find module ‘Network.Wreq’
10:53:54 <jTT_>     It is not a module in the current program, or in any known package.   “
10:54:11 <jTT_> does anyone know whats up with this?\
10:54:24 <geekosaur> is the package installed?
10:54:26 <Iceland_jack> agibiansky: Note the non-linear pattern
10:54:29 <geekosaur> are you working in a sandbox?
10:54:35 <jTT_> not in a sandbox
10:54:43 <jTT_> can’t i install it from ghci?
10:54:49 <agibiansky> Iceland_jack: Wait, so when pattern matching in type families using `x` in two places in the pattern does the equality test?
10:54:51 <jTT_> i mean it is installed in a sandbox
10:54:59 <jTT_> but if i ghci there it doesnt work either
10:55:01 <Iceland_jack> agibiansky: That's right
10:55:07 <geekosaur> jTT_, cabal repl
10:55:12 <jTT_> kk ty
10:55:14 <geekosaur> ghci can't see inside a sandbox by itself
10:55:19 <jTT_> yeah suspected that
10:55:22 <jTT_> cheers
10:55:23 <agibiansky> Iceland_jack: Oh, ok. Everything is easy then. Everything! :)
10:58:43 <agibiansky> Iceland_jack: I'm getting a parse error on : for your code (with -XDataKinds -XKindSignatures -XTypeFamilies -XTypeOperators), any ideas?
10:59:44 <Iceland_jack> agibiansky: aah oops
10:59:46 <Iceland_jack> you need a ':
10:59:49 <agibiansky> ahh
11:00:24 <Denommus> I have a JSON that may either be { foo :: String } or { bar :: String, baz :: String }
11:00:42 <Denommus> how do I parse it to a proper ADT in Aeson?
11:00:47 <Iceland_jack> agibiansky: You also need to import something that gives you Constraint, like
11:00:47 <Iceland_jack>     import GHC.Exts (Constraint)
11:01:01 <agibiansky> Iceland_jack: Yup, got that bit. It's working! Thanks
11:01:07 <Iceland_jack> and add whitespace before the ':
11:01:07 <Iceland_jack>     IsElem x (x ': xs) = ()
11:01:09 <Iceland_jack> Good :)
11:03:13 <favetelinguis> What do i need to do in order to be able to import Text.CSV? I have added csv as build deps in my cabal file and then i run cabal configure but still i can not import
11:03:38 <chpatrick> cabal install --only-dependencies?
11:04:11 <ion> Also consider http://hackage.haskell.org/package/cassava
11:04:20 * dcoutts wants to make that step automagic
11:04:23 <Denommus> hm, I can use an Either
11:04:24 <Denommus> good
11:08:02 <favetelinguis> chpatrick: yes that installed the package but still I can not import it, it cant be found
11:08:03 * hackagebot casadi-bindings-core 2.3.0.1 - autogenerated low level bindings to casadi  http://hackage.haskell.org/package/casadi-bindings-core-2.3.0.1 (GregHorn)
11:08:05 * hackagebot casadi-bindings 2.3.0.1 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.3.0.1 (GregHorn)
11:08:08 <favetelinguis> im using cabal sandbox
11:08:49 <geekosaur> import where?
11:08:57 <geekosaur> are you trying to import it in ghci?
11:09:15 <geekosaur> or is this an error from cabal build?
11:09:20 <geekosaur> (or are you using ghc directly?)
11:09:25 <michaelt> from cabal configure, sounded like
11:09:59 <geekosaur> cabal configure shouldn't normally be importing (but if Setup.hs is trying to import it, I think that's a known bug)
11:10:17 <geekosaur> hm, no, I'm thinking of a different one
11:10:35 <nolraiU> So ((A -> Void) -> Void) is the classical logic monad, yes?
11:10:39 <michaelt> favetelinguis: when does the error arise? and are you using cabal in the directory that has the sandbox in it?
11:11:21 <favetelinguis> i have a loaded file in cabal repl and then i add import Text.CSV and try to issue :r but then i get could not find module Text.CSV
11:13:03 <ReinH> favetelinguis: what is the full error message?
11:14:24 <favetelinguis> ReinH: Could not find module Text.CSV use -v ... Failed, modules loaded: Ch1.Txt.Main.
11:14:45 <ttt_fff> what is the algorithm used to check if a set of patterns is 'complete' (i.e. covers all cases)
11:14:56 <ReinH> favetelinguis: and the rest?
11:16:23 <favetelinguis> ReinH: that is all cabal repl gives me when i do :r
11:16:47 <ion> ttt_fff: There was a recent paper about the latest enhancements to that: http://research.microsoft.com/en-us/um/people/simonpj/papers/pattern-matching/gadtpm.pdf
11:18:21 <ReinH> favetelinguis: it only has that lilne?
11:18:39 <favetelinguis> ReinH: yes
11:19:09 <michaelt> favetelinguis: if you exit cabal repl does 'cabal sandbox hc-pkg list csv' show anything?
11:19:19 <ReinH> It doesn't have another line that begins, "It is a member of the hidden package"?
11:19:46 <favetelinguis> I have added csv in the cabal file under build deps
11:19:48 <michaelt> this means  csv should be mentioned in the .cabal file
11:20:19 <michaelt> but it's puzzling this is arising with :l Blah.hs there's something I don't follow
11:20:24 <ReinH> (That's ghc-pkg, not hc-pkc)
11:20:31 <michaelt> no
11:21:03 <michaelt> strangely
11:21:09 <ReinH> what
11:21:16 <Denommus> hm, Either doesn't work as I expected it to
11:21:22 <michaelt> well, in theory cabal can use other compilers
11:21:46 <nolraiU> Denommus:?
11:21:49 <ReinH> cabal what are you doing
11:22:07 <ReinH> But there's no such thing as hc-pkg
11:22:17 <ReinH> while there *is* ghc-pkg
11:22:25 <indiagreen> Denommus: what's wrong with «(Foo <$> o .: "foo") <|> (BarBaz <$> o .: "bar" <*> o .: "baz")»?
11:22:47 <favetelinguis> ReinH: http://lpaste.net/135214 that is the output i get
11:23:39 <dcoutts> ReinH: the cabal sandbox hc-pkg command wraps the package tool for the compiler, in the sandbox env, so for ghc yes that's ghc-pkg.
11:24:10 <michaelt> favetelinguis: and if you reopen cabal repl and then do import Text.CSV its okay?
11:24:31 <michaelt> ReinH: what about jhc-pkg  etc.
11:24:56 <favetelinguis> michaelt: yes, why is that?
11:25:25 <michaelt> favetelinguis: did you keep cabal repl open while you installed csv?
11:25:32 <favetelinguis> yes
11:25:50 <dcoutts> favetelinguis: cabal repl (and indeed ghci) cannot yet react to changes in the package db while running
11:26:24 <michaelt> favetelinguis: bingo. the behavior is normal.
11:26:55 <favetelinguis> aa ok, cabal configuration what does that do? i thought it did what cabal install --only-dependencies does?
11:27:48 <michaelt> cabal install includes configuration and so on.  
11:27:58 <bitemyapp> ReinH: do me a favor? highlight me in 15 seconds
11:28:05 <bitemyapp> ReinH: I need to test activity_hide_level
11:28:21 <ReinH> bitemyapp: has it been 15 seconds yet?
11:28:31 <bitemyapp> I don't think it worked. That's worrying.
11:28:36 <bitemyapp> ReinH: one more time?
11:28:43 <michaelt> favetelinguis: but there are ways of breaking it up:  cabal configure; cabal build is like , e.g. ./configure (with options) ; make 
11:28:45 <ReinH> bitemyapp: can you hear me now?
11:29:08 <bitemyapp> wow that is not good.
11:29:11 <bitemyapp> hilight no longer works
11:29:15 <bitemyapp> ReinH: than kyou
11:29:20 <ReinH> np
11:29:25 <Hi-Angel> Is there a way to do pattern matching like let printFoo p@(Foo _ _) = , but to not write all these underscores inside?
11:29:36 <bitemyapp> ReinH: again?
11:29:37 <michaelt> favetelinguis: sort of... During the cabal configure step you can add various things, e.g. --enable-bench check out 'cabal configure --help' and similarly for other sub commands
11:29:45 <indiagreen> Hi-Angel: yes, p@Foo{}
11:29:53 <Hi-Angel> indiagreen, thank you!
11:30:06 <dcoutts> Hi-Angel: you can actually use record syntax, even for data types not defined using record (as indiagreen suggests)
11:30:53 <fffej> hi!  I've got a type "data Foo = FooInt32 Int32 Int32 | FooInt16 Int16 Int16 | (and so on)".  I've got 5 different types of numbers and I'm going to end up writing repeated code.  Is there a more sensible way to represent the data?
11:31:23 <favetelinguis> michaelt: so after i add any build deps i need to do cabal install --only.. and then restart the repl?
11:31:54 <michaelt> > let f Just{} = True; f Nothing = False in f (Just 1)
11:31:55 <lambdabot>  True
11:32:36 <michaelt> favetelinguis: you can also do 'cabal install csv'; it only matters that it's in the sandbox package database
11:32:56 <michaelt> favetelinguis: but you certainly have to restart the repl
11:35:26 <favetelinguis> michaelt: but if i dont add it to the cabal file it wont build on other systems right?
11:35:39 <DNoved1> fffej, I don't know if this is more sensible but you could make a class Fooable with no methods, make Int32/Int16 members of that class, and make the declaration 'data Fooable a => Foo a = Foo a a'
11:35:50 <favetelinguis> or does cabal install csv insert it in the cabal file auto?
11:35:51 <michaelt> favetelinguis: other systems?
11:36:06 <DNoved1> On second thought though, that is definitely not more sensible; more concise, pehaps
11:36:11 <nolraiU> DNoved1, thats a bad idea.
11:36:13 <favetelinguis> michaelt: if i want to share the code with others
11:36:18 <favetelinguis> on github
11:36:44 <michaelt> favetelinguis: right, it has to be in the cabal file to be build with cabal install and so on.
11:36:55 <fffej> @DNoved1 that sounds a bit messy
11:36:55 <lambdabot> Unknown command, try @list
11:36:56 <nolraiU> Doing data Fooa = Foo a a, and having a class Fooable, isn't a bad idea though.
11:37:05 <michaelt> built, not build, I mean
11:37:22 <favetelinguis> michaelt: on thanks for the patient, now i get it
11:37:35 <DNoved1> fffej, indeed, forget I said it ;)
11:38:01 <fffej> DNoved1 :)
11:38:04 <nolraiU> Hmm. Using stack to work on ghc probobly doesn't make sense does it?
11:38:08 <michaelt> data NPair a where NPair :: Num a => a -> a -> NPair a ; but of course, that makes them all separate types (NPair Double, etc)
11:39:03 <michaelt> times :: NPair a -> a ; times (NPair a b) = a * b
11:39:29 <ion> So i suppose a package on Hackage that depends on a non-existent version of itself causes an issue with the hackage import NixOS does?
11:39:55 <nolraiU> Is "Data Foo where Foo :: Fooable a => a -> a -> Foo" valid haskel?
11:40:16 <indiagreen> nolraiU: with GADTs – yes
11:40:26 <michaelt> nolraiU: with {-#LANGUAGE GADTs#-}
11:40:46 <nolraiU> Okay, wasn't sure if you could use GADTs like that.
11:41:03 <supki> ion: if it doesn't build, they remove it from the package set after a while
11:41:14 <ion> supki: alright
12:09:17 <simon> @pl (\f -> f "")
12:09:17 <lambdabot> ($ [])
12:09:26 <mizu_no_oto> Are there any tradeoffs between the kind of tree used in Data.Set and Red-Black trees, as far as implementing Sets go?
12:16:19 <ChristianS> mizu_no_oto: can't say, but Data.Set is pretty fast, the authors clearly knew what they were doing
12:17:34 <mizu_no_oto> ChristianS: basically, I'm probably going to use scalaz.ISet; a Data.Set clone instead of scala.collection.immutable.TreeSet, and wanted to make sure I wasn't making any unknown tradeoffs.
12:17:47 <mizu_no_oto> I'm not going to reimplement Data.Set in Haskell
12:17:55 <dmj`> jle`: ping !
12:19:10 <ChristianS> mizu_no_oto: well, once you have your use case, you can benchmark both alternatives, that's probably a better approach than just theoretical reasoning
12:23:26 <phylene> hey can someone help me with some code I wrote?
12:23:47 <dmj`> phylene: lpaste.net it here
12:24:06 <phylene> I actually have a stackoverflow question for it so
12:24:07 <phylene> http://stackoverflow.com/questions/30970777/sha-1-in-haskell-producing-wrong-hashes
12:24:23 <phylene> there's an answer but it doesn't really help
12:26:23 <phylene> also with that stackoverflow question, is Data.Sequence the appropriate data structure to use here or would vectors be better?
12:29:55 <Welkin> phylene: if your data is of a fixed length, you can use vector/array
12:30:06 <Welkin> if it is variable and changes over time, use sequence
12:35:30 <__ryan> > let foobar = takeWhile ((/= 5) . row) [1..10::Int]  
12:35:32 <lambdabot>  <no location info>:
12:35:32 <lambdabot>      not an expression: ‘let foobar = takeWhile ((/= 5) . row) [1..10::Int]  ’
12:35:49 <__ryan> hi can anyone help me about takeWhile?
12:36:13 <Haskellfant> __ryan: what's your question?
12:38:36 <__ryan> Hskellfant: just want to know how use takeWhile :)
12:38:51 <Haskellfant> > takeWhile (/= 5) [1..10]
12:38:53 <lambdabot>  [1,2,3,4]
12:39:06 <geekosaur> > takeWhile (< 5) [1,3,6,4,2,9]
12:39:06 <dmj`> @src takeWhile
12:39:07 <lambdabot> takeWhile _ []                 = []
12:39:07 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
12:39:07 <lambdabot>                    | otherwise = []
12:39:08 <danilo2> Hello! :) Is it somehow possible in haskell to specify that a particular Constrain is a functional dependency? I want to create a function passing a (Proxy :: Proxy X)  (where X is * -> * -> Constrain) with funds between the two parameters, but GHC obviously rejects the function, because it doesn't know such funded will exist in the constrain. I can post a code snippet here, but I think the question is pretty simple - if we can jus
12:39:08 <lambdabot>  [1,3]
12:39:14 <danilo2> on the type level
12:39:17 <bernalex> Cale: ping?
12:39:34 <__ryan> thank yout :)
12:39:35 <geekosaur> note that "while" means exactly that; it stops when the predicate fails, it does not go on to find other things that might match. for that you want filter
12:39:58 <geekosaur> > filter (< 5) [1,3,6,4,2,9]
12:40:00 <lambdabot>  [1,3,4,2]
12:40:45 <__ryan> geekosaur: what if i want only 5 on the list?
12:41:11 <geekosaur> presumably (== 5) as the predicate
12:41:23 <Sinestro> Stupid question, but how do I put a constraint on a typeclass method?
12:41:45 <Sinestro> Like fmap :: Eq a => (a -> b) -> f a -> f b
12:41:54 <__ryan> > filter (== 5) [1..10]
12:41:55 <lambdabot>  [5]
12:42:09 <__ryan> > takeWhile (== 5) [1..10]
12:42:10 <lambdabot>  []
12:43:08 <aznashwan> > :t takeWhile
12:43:09 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:43:29 <geekosaur> :t takeWhile
12:43:30 <lambdabot> (a -> Bool) -> [a] -> [a]
12:43:38 <__ryan> geekosaur: how about if i have multiple condition?
12:43:42 <lyxia> Sinestro: You can rebind it, but I'm not sure whether that's what you are asking about...
12:44:01 <Welkin> __ryan: && them together
12:44:08 <Welkin> put it in another function or lambda
12:44:15 <geekosaur> except you probably can;t get away with a section that way
12:44:28 <geekosaur> (\x -> x >= 4 && x <= 10)
12:44:32 <geekosaur> or some such
12:44:37 <lyxia> > let fmap' :: (Eq a, Functor f) => (a -> b) -> f a -> f b ; fmap' = fmap in fmap' (: []) (Just '&')
12:44:39 <lambdabot>  Just "&"
12:44:44 <Welkin> > filter (\a -> a >= 3 && a <= 7) [1..10]
12:44:46 <lambdabot>  [3,4,5,6,7]
12:45:02 <Sinestro> The only reasonable way that I could write fmap would require a and b to be Eq
12:45:03 <tejing> it would be kind of cool if you could do ((==5) || (==3))
12:45:14 <__ryan> thank everyone i will try this out. :)
12:45:17 <Sinestro> So that I can use (\\)
12:45:27 <ReinH> sinelaw: then you can't write fmap :(
12:45:49 <lyxia> Indeed. ^
12:46:20 <Iceland_jack> tejing:
12:46:20 <Iceland_jack> :t or . sequenceA [(== 5), (== 3)] 
12:46:21 <lambdabot> (Eq a, Num a) => a -> Bool
12:46:44 <Sinestro> Well, maybe I'm being dumb
12:46:49 <Iceland_jack> or simply
12:46:49 <Iceland_jack> :t (`elem` [3,5])
12:46:50 <lambdabot> (Eq a, Num a) => a -> Bool
12:47:17 <tejing> Iceland_jack: I know, I just was thinking overloading && and || like that would make certain things particularly readable sometimes
12:47:29 <Iceland_jack> I see
12:47:43 <lyxia> Sinestro: What's your f?
12:47:53 <Sinestro> http://lpaste.net/7812831569130815488
12:48:28 <__ryan> Welkin: does a represent the list of integer? filter (\a -> a >= 3 && a <= 7) [1..10]
12:48:37 <Welkin> no
12:48:43 <Welkin> it is a single element from the input list
12:48:47 <lyxia> Sinestro: Why State ?
12:49:03 <Sinestro> To keep a running list of what vertices I've seen
12:49:15 <Sinestro> Kind of required for a graph traversal
12:49:21 <Welkin> filter f x means "apply f to every element of x"
12:49:22 <meoblast001> does anyone know why this keeps happening? https://gist.github.com/meoblast001/a8784857f8827d5ca8ea
12:49:25 <Sinestro> Which is what fmapping a graph would be
12:49:29 <Welkin> well, and filter based on the result
12:49:36 <tejing> Sinestro: if it has a typeclass requirement on the elements, then technically it's not a functor
12:50:01 <Sinestro> Is there a logical way that I could write that without needing Eq?
12:50:02 <__ryan> Welkin: thanks, question i want to use also the filter in entity is it possible?
12:51:03 <geekosaur> meoblast001, you have two copies of the "unix" library installed (versions 2.7.0.1 vs. 2.7.1.0)
12:51:24 <pikajude> if I have a datatype implementing Data where all the fields are Hashable, can I replicate hashWithSalt s (Foo a b ...) = s `hashWithSalt` a `hashWithSalt` b ... using gfoldl?
12:51:26 <geekosaur> 2.7.1.0 is in the sandbox, 2.7.0.1 came from the global libraries
12:51:30 <tejing> Sinestro: well it is a functor, but not from Hask -> Hask, so it's not a valid instance of 'Functor'
12:51:32 <Welkin> __ryan: what do you mean?
12:51:44 <Sinestro> Ah
12:51:46 <Welkin> __ryan: for Persistent entries?
12:51:49 <Sinestro> I get it, tejing
12:51:58 <Sinestro> It's a functor, but a small-f one
12:52:05 <Welkin> you can filter in your search query instead
12:52:38 <__ryan> Welkin: i think i got it i just change the \a to \Entity id data :)
12:52:43 <lyxia> Sinestro: fmap f dag = DAG (f (vertex dag)) (fmap (fmap f) (edges dag)) is possible though much less efficient...
12:52:43 <sinelaw> ReinH, ?
12:52:58 <Sinestro> That was my inital thought
12:53:07 <Sinestro> But it's kind of crap
12:53:20 <Welkin> entries <- runDB $ selectList [PersonLocation ==. SouthSudan] [Asc PersonId]
12:53:32 <Sinestro> The only hope would come from memoizing it or something
12:53:37 <pikajude> oh, that's not actually what gfoldl is for, is it
12:53:40 <michaelt> meoblast001: there are too many unixes. you need to remove the unix from your sandbox. 
12:53:42 <pikajude> it's for folding over all the constructors
12:53:48 <Sinestro> Which would work well, actually
12:53:49 <pikajude> I only have one constructor and I want to fold over its fields
12:54:03 <lamefun> Are there module conspiracies in Haskell?
12:54:30 <michaelt> meoblast001: the question is what is making cabal do  "Configuring unix-2.7.1.0..."
12:54:40 <srhb> lamefun: Lens is trying to dethrone all the other lens libraries!
12:55:08 <lamefun> srhb: I mean, something like C++'s friends, where a module only exports something to a fixed set of other modules.
12:55:19 <srhb> lamefun: Nope.
12:55:57 <maerwald> mh, maybe that's because haskell doesn't really have frameworks
12:56:00 <breadmonster> srhb: They're starting by taking all the operators.
12:56:03 <michaelt> meoblast001: you want only to use the unix that is globally installed. 
12:56:15 <lyxia> Sinestro: Your implementation doesn't satisfy functor laws as soon as one vertex is used more than once.
12:56:18 <srhb> breadmonster: :D
12:56:53 <pikajude> ok, looks like this is impossible
12:56:58 <breadmonster> srhb: What's a DList?
12:56:59 <__ryan> Welkin: my query is store in Mvar and its have a multiple data on it so instead on querying everytime i get it all and check if my data is required.
12:57:04 <maerwald> srhb: are there even other lens libraries? (and I don't mean toy implementations)
12:57:11 <srhb> maerwald: Yep, lots.
12:57:23 <michaelt> meoblast001: in the ~/.cabal/config file, you will find a place where something like "constraint: unix installed" can be uncommented. With that you can find out if it's all okay, or if something is demanding the higher unix number
12:57:28 <mizu_no_oto> lamefun: what people typically do is have a Foo.Bar.Internals.Baz, and if someone else uses anything in Internals and it changes, ah well 
12:57:30 <srhb> maerwald: lens is just Lenses and the kitchen sink.
12:57:39 <srhb> Well, not "just" :P
12:57:42 <maerwald> srhb: I just keep seeing blog posts saying "noes, we need a different approach to lens", but never really a link
12:57:50 <srhb> maerwald: fc-labels spring to mind
12:58:13 <srhb> maerwald: fclabels even
12:58:28 <lyxia> Sinestro: Why is memoization that important though? with Eq you can only use associative lists which is ultimately worse than recomputing the vertices...
12:59:19 <mizu_no_oto> lamefun: this is good in that it can make code more extensible.  edwardk ran into problems with OpenGL where typeclasses didn't export the methods you need to implement them, so he ended up implementing a new opengl library since he couldn't extend the old one
13:00:16 <mizu_no_oto> He talked about it briefly at Boston Haskell back in december.  the video's somewhere on youtube
13:00:31 <lamefun> Also, is there a way to re-export a qualified import?
13:01:17 <srhb> lamefun: Nope.
13:01:30 <srhb> lamefun: Generally the question to "can modules do...?" is "no."
13:01:38 <srhb> Er, the answer*
13:02:53 <maerwald> srhb: looks semi-active. any experience with that library?
13:03:05 <srhb> maerwald: Not since lens came out. I'm happy with it.
13:03:20 <srhb> maerwald: And "active" is really not a good gauge of library quality :-)
13:03:36 <srhb> Or package, rather.
13:03:46 <maerwald> I tend to disagree, mostly
13:03:56 <maerwald> it's a rough approximation
13:04:06 <maerwald> but it often gives a quite good indication
13:04:09 <srhb> I mostly say it for the benefit of others, because I think it's silly and the idea should not be perpetuated.
13:04:15 <srhb> I'm not going to discuss it :P
13:04:23 <maerwald> (when you are a distributor, you experience that this indication is most of the time quite precise)
13:07:02 <maerwald> for a thing as complex as lens, there are only 2 reasons of the last commit being ~6months ago: 1) the implementation lacks a LOT of features and is therefore quite trivial 2) it's not maintained properly and full of bugs
13:08:18 <maerwald> or just no one uses it :/
13:08:38 <geekosaur> er?
13:08:47 <breadmonster> maerwald: It could be uhh complete?
13:09:06 <geekosaur> or (3) the author considers it complete and has moved on (along with (3a) only the author understands it >.> )
13:09:10 <maerwald> breadmonster: unlikely... I only new a handful of examples that fit here and most of them are about trivial programs
13:09:28 * breadmonster prods edwardk 
13:09:34 <shachaf> maerwald: There have been quite a few commits to lens in the past six months.
13:09:40 <maerwald> breadmonster: I'm not talking about HIS lens library
13:09:48 <geekosaur> then specify
13:09:51 <maerwald> see the previous discussion
13:10:16 <ttt_fff> anyone biding haskell to Apache Spark ?
13:10:28 <shachaf> geekosaur: There are several people who understand lens completely, and only most of them are authors!
13:10:44 <geekosaur> fclabels, then? small, simple, and doesn't really need anything else
13:10:45 <shachaf> (But you don't need to understand it completely to use it.)
13:10:58 <geekosaur> I was going to add that most people don't use most of its capability
13:11:03 <maerwald> geekosaur: which then means 1) as I described
13:11:14 <geekosaur> not reallt
13:11:17 <shachaf> I kind of wish there was a standard type-changing lens library for people who don't want lens-style lenses.
13:11:27 <geekosaur> unless by "features" you mean "every program must expand until it can send mail"
13:11:29 <maerwald> geekosaur: then a combination of 1) and 3)
13:11:33 <geekosaur> fclabels does what it was intended to
13:11:40 <geekosaur> it was not intended to be the kitchen sink
13:11:49 <shachaf> The situation with lens is mostly that all the problems that we know about, we don't know how to solve.
13:11:51 <breadmonster> shachaf: What are lens-style lenses?
13:12:09 <geekosaur> you may choose to regard that as some combination of your claims, if you believe every library MUST constantly expand its scope into unrelated things
13:12:24 <maerwald> uh, I don't
13:12:25 <breadmonster> geekosaur: Are there any other libraries that are this controversial?
13:12:25 <geekosaur> personally I like small and simple stuff that I can combine, not monoliths
13:12:50 <geekosaur> (mind, edwardk's lens has reasons for being as large as it is)
13:13:02 <geekosaur> (but I don't see what "features" fclabels desperately needs to add either)
13:13:36 <platz> I think prisms are largely lacking from the other lens-alike libraries, which are a big part of lens
13:14:13 <geekosaur> certainly that kind of logic explains things like gnome though >.>
13:14:33 <breadmonster> Also, does ghc require ghc to compile?
13:14:34 <bitemyapp> platz: and traversals, and folds, and isos
13:14:38 <shachaf> platz: Well, traversals are probably even more generally-applicable than prisms.
13:14:39 <bitemyapp> breadmonster: yes
13:14:40 <breadmonster> Or is it just Haskell 2010?
13:14:44 <maerwald> geekosaur: I am just arguing that per my experience as 3+ years as a distributor that the commit rate might give away that the project is stagnating or is rarely used. I might be wrong though.
13:14:46 <shachaf> I still think of them as the core of lens.
13:15:16 <geekosaur> again, only if you think that every project must continually expand
13:15:17 <maerwald> and I know there are projects that are 10+ years old and still don't need an update
13:15:19 <maerwald> but they are rare
13:15:43 <geekosaur> it *can* be true, but does not have to be. especially in Haskell where you;re not going to be finding buffer overflows years after the library is complete
13:15:49 <maerwald> geekosaur: no, that's not the point... if a lot of people use it, more bugs will be filed
13:16:00 <platz> bitemyapp: well at least this one has some form of traversals: http://hackage.haskell.org/package/lens-simple-0.1.0.6/docs/Lens-Simple.html
13:16:12 <geekosaur> maerwald, in C
13:16:20 <platz> but no prisms
13:16:34 <maerwald> geekosaur: not sure I agree
13:16:44 <maerwald> and I really mean "not sure"
13:16:45 <geekosaur> haskell, then, is a useless language because entire clases of bugs can be eliminated instead of being found after the fact
13:16:56 <geekosaur> but bugs prove liveness, therefore...
13:17:00 <crough> breadmonster: I think it does, but it can bootstrap itself from way back when it was compiled in C
13:17:11 <geekosaur> there is something wrong with this logic
13:17:25 <platz> hrm, i think i forgot prisms are traversals, oh well
13:17:27 <maerwald> geekosaur: I've written/workd on haskell programs with more than 1k LOC and they all had lots of bugs... even if it's not the same class as C programs
13:17:57 <crough> maerwald, geekosaur: The bugs are just logic bugs now instead of dumb mutability gotchas
13:18:05 <maerwald> and SPJ took the amount of GHC bugs as an indicator of how many people use haskell ;)
13:18:13 <maerwald> crough: yep, mostly
13:18:13 <crough> maerwald, geekosaur: Haskell doesn't make a programmer smarter :)
13:18:34 <geekosaur> and so we're back to "libraries should not be small, simple, and verifiable because they don't have the bugs that prove they are actually useful"
13:18:40 <geekosaur> still don't buy that logic
13:19:03 <maerwald> geekosaur: my point was that something like lens isn't "small" or "simple", but I might be wrong about that
13:19:12 <bitemyapp> crough: I try to tell people you can't, "take Haskell with you" - that's in the tool and not the programmer.
13:19:15 <bitemyapp> crough: nobody listens.
13:19:29 <crough> bitemyapp: Yeah... I
13:19:33 <geekosaur> but you seem certain of it, so use only big things that take on more and more functionality until you can't reason about how they work and therefore get lots of bugs
13:19:35 <breadmonster> bitemyapp: That's not true, it's made me a better programmer.
13:19:59 <maerwald> geekosaur: let's be more specific :) do you have experience with fclabels?
13:20:08 <crough> bitemyapp: I'm forced to work in JS all day and I just use Facebook's immutable.js and make sure that I keep my IO in once place. I've taken Haskell with me to an extent :)
13:20:28 <rasen_> I just realized that unsafePerformIO is F-algebra
13:20:42 <maerwald> because after all it's not about the argument, but about whether I want to devote time to learning fclabels
13:20:45 <geekosaur> lens has an underlying logic in common with all its parts, that is integrated enough that breaking it up only complicates things worse (largely because of limitations in ghc's type system, as I understand it)
13:20:52 <KaneTW> :t (.).(.)
13:20:53 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:21:15 <bitemyapp> breadmonster: programming and learning new things made you a better programmer, but the benefits of Haskell stay with Haskell.
13:21:28 <geekosaur> ...or implementation, such that when you can break things up, they perform really poorly...
13:21:34 <bitemyapp> you can't write Haskell in Forth and yield the benefits of Haskell.
13:21:41 <bitemyapp> that's not how it works.
13:21:58 <bitemyapp> I need to be able to query & interrogate types, get proper type-checking, explicit effects, the whole ecosystem, etc. to get the benefits of Haskell.
13:21:59 <maerwald> now you are annotating all your C functions with __pure__ :P
13:22:25 <bitemyapp> it's more about how everyone else writes their code than it is how you personally write your own code.
13:22:31 <bitemyapp> ecosystem matters more than the individual programmer.
13:22:36 <maerwald> people will go mad reading your C and java code now :D
13:22:46 <bitemyapp> I don't write Haskell outside of Haskell. There's no point.
13:22:47 <maerwald> that's what haskell does to you
13:22:56 <bitemyapp> I used to, I gave it up.
13:22:58 <dolio> bitemyapp: It's also about how you write your own code, and how you can't do it that way in other languages.
13:23:01 <maerwald> heh
13:23:03 <bitemyapp> It wasn't winning me anything.
13:23:09 * hackagebot xcp 0.1.0.0 - Partial implementation of the XCP protocol with ethernet as transport layer.  http://hackage.haskell.org/package/xcp-0.1.0.0 (ChristianGosch)
13:23:13 <bitemyapp> dolio: yeah
13:23:27 <bitemyapp> dolio: loved your Free Monoid series btw!
13:23:35 <dolio> Thanks.
13:23:35 <bitemyapp> dolio: (the comonad posts)
13:23:47 <bitemyapp> dolio: may I query you about something?
13:23:50 <crough> Try doing a free-monad interpreter in literally any other language (that's not an ML with HOTs)... good luck at keeping it bugfree
13:23:52 <dolio> Sure.
13:24:14 <__ryan> Hi im back, thank you by the way for the help while ago, another question about printf how do i convert my "2000.00" -> "2,000.00"
13:25:34 <geekosaur> you can't (sanely) do that with printf
13:26:08 <geekosaur> have to postprocess it somehow
13:26:12 <fragamus> If you couldn't get a Haskell job and you had your choice of a Scala job or an Erlang job, which would you pick?
13:26:27 <maerwald> Eerlang
13:26:30 <fragamus> I am in that situation now
13:26:48 <Clint> erlang
13:26:55 <fragamus> erlang 1 scala 0
13:27:05 <fragamus> erlang 2 scala 0
13:27:10 <maerwald> keep away from everything that is remotely related to java
13:27:13 <__ryan> geekosau: i have a printf "%.2f" but it seem that nothing has change or is the a code that im missing out?
13:27:29 <fragamus> maerwald: why 
13:27:49 <jackhill> even though erlang has dynamic typing?
13:27:49 <__ryan> >  printf "%.2f" $ (1200 :: Double)
13:27:50 <lambdabot>      No instance for (Show a0)
13:27:50 <lambdabot>        arising from a use of ‘show_M567197870714320197032032’
13:27:50 <lambdabot>      The type variable ‘a0’ is ambiguous
13:27:55 <maerwald> fragamus: it's like a malicious virus (I'm being opinionated)
13:28:03 <__ryan> >  printf "%.2f" 1200
13:28:04 <lambdabot>      No instance for (Show a0)
13:28:04 <lambdabot>        arising from a use of ‘show_M294863831227165501432055’
13:28:04 <lambdabot>      The type variable ‘a0’ is ambiguous
13:28:34 <__ryan> > printf "%.2f\n" pi
13:28:35 <lambdabot>      No instance for (Show a0)
13:28:35 <lambdabot>        arising from a use of ‘show_M120397706454150328332066’
13:28:35 <lambdabot>      The type variable ‘a0’ is ambiguous
13:28:36 <geekosaur> >  printf "%.2f" (1200 :: Double) :: String
13:28:37 <lambdabot>  "1200.00"
13:28:41 <geekosaur> printf is weird
13:28:43 <fragamus> maerwald: we might have to hunker down and make a JVM backend for GHC
13:28:54 <maerwald> I'd rather do F# than Scala
13:29:08 <geekosaur> you need to specify a result type because it uses inference to figure out if it should be String or IO ()
13:29:17 <geekosaur> (that is, either return the string or print it to stdout)
13:29:21 <__ryan> a forgot it return a string sorry. but as the result 1200 is not the same  1,200
13:29:54 <jackhill> fragamus: have you seen Frege: https://en.wikipedia.org/wiki/Frege_(programming_language) ?
13:30:03 <edwardk> maerwald: lens is quite actively maintained, but we built the vocabulary we want, and haven't needed to change it a whole lot since
13:30:07 <crough> fragamus: I would weirdly love that... further than fredge, hopefully
13:30:11 <__ryan> geekosaur: how do i do that?
13:30:32 <fragamus> im checking it out jackhill
13:30:57 <edwardk> there was a huge flurry of activity to get lens into its current state but right now its more or less in a sweet spot. and any updates for it since have been in the form of revisions widening version bounds
13:30:57 <maerwald> edwardk: don't worry, I was talking about fclabels, not your lens library
13:31:41 <maerwald> edwardk: any opinion on fclabels?
13:31:50 <edwardk> it can't do anything i want to do
13:31:55 <maerwald> :D
13:32:07 <edwardk> i'm sorry, i do too many things with getters and setters and prisms
13:32:08 <bitemyapp> maerwald: I use lenses as part of my day-to-day work and fclabels wouldn't work for me either.
13:32:14 <fragamus> holy shit!
13:32:21 <bitemyapp> maerwald: I need the same things edwardk does. prisms, traversals, folds, isos, getters, setters.
13:32:28 <edwardk> and if you just remove 3/5ths of my reasons for using the vocabulary its dead to me
13:32:31 <bitemyapp> maerwald: the most frequent things being lenses, prisms, traversals.
13:32:48 <fragamus> what's bad about frege
13:32:49 <bitemyapp> maerwald: this is for ordinary day-to-day data munging.
13:32:54 <bitemyapp> fragamus: it's not mature.
13:32:59 <bitemyapp> fragamus: and GHC RTS is actually really nice.
13:33:46 <edwardk> fragamus: well, he got into a bit of a row with Hilbert, but I don't think anything was wrong with him per se.
13:33:55 <geekosaur> __ryan, there is no "built in" way to do it. could look around on hackage, I already found "formatting" (see http://hackage.haskell.org/package/formatting) and I'm sure there are others
13:34:05 <fragamus> edwardk: haha
13:35:04 <fragamus> I must admit, the liskell paper made me dream of a rich ecosystem of language extensions for all
13:35:44 <fragamus> Lisp syntax with haskell semantics
13:36:25 <fragamus> of course the code doesn't look sleek like haskell with all of its operators
13:36:27 <__ryan> geekosaur: can you explain me this commas :: (Buildable n, Integral n) => Format n? 
13:38:42 <geekosaur> example: format ("The value is " % commas float % ".\n") myDouble
13:38:51 <geekosaur> commas is a modifier for another formatter
13:39:26 <geekosaur> this is a combinator library, so you build formats by chaining format combinators together like that
13:40:05 <catsup> in Network.Wreq, is it possible to find out where a request was redirected to?
13:40:57 <geekosaur> oh, no, sorry, misread that completely
13:41:06 <geekosaur> commas only works with integral types, it appears :/
13:41:18 <geekosaur> looks like it replaces e.g. "int" as a format combinator
13:41:39 <geekosaur> (which is unfortunate but actually makes a bit more sense because it'd have to be implemented by text-swizzling otherwise)
13:42:06 <geekosaur> there doesn't appear to be a Float/Double variant 
13:42:24 <__ryan> thanks
13:43:48 <__ryan> so this means from string, separate the decimal from the Integer the format the integer into commas, then combine the two?
13:45:43 <broma0> What is the relationship between the ioRef type and the STM monad?
13:45:55 <monochrom> no relation
13:46:00 <geekosaur> pretty much, yes
13:46:23 * geekosaur still looking through hackage, though --- but several other pots also on the boil here...
13:46:35 <broma0> Isn't stm implemented with the ioRef
13:47:13 <broma0> Stm, not the state monad
13:47:44 <jle`> i don't think so
13:47:49 <jle`> i could be wrong
13:48:18 <cheater> stm is implemented in the runtime
13:50:19 <maerwald> cheater: so, similar to IO?
13:50:47 <cheater> i don't know how IO is implemented.
13:52:34 <rhaps0dy> Heyo
13:52:36 <rhaps0dy> How's Darcs ?
13:52:43 <maerwald> rhaps0dy: what do you mean?
13:52:59 <rhaps0dy> I was wondering whether for this new project I should try out Darcs instead of Git.
13:53:01 <maerwald> it's cool, but not comparable to git, because the developer base is not as strong
13:53:02 <jle`> i think it's nice, but it never really took off in a big way
13:53:06 <rhaps0dy> Instead I find that GHC moved from Darcs to git.
13:53:11 <rhaps0dy> Ah I see.
13:53:18 <jle`> ;_;
13:53:24 <maerwald> rhaps0dy: but I think the main concepts of darcs a superior to git
13:53:25 <rhaps0dy> They're short on developers :(
13:53:31 <maerwald> however, it cannot compete on featureness
13:53:41 <rhaps0dy> I see.
13:53:55 <maerwald> and darcsden also needs more developers (the gitlab equivalent of darcs)
13:53:56 <rhaps0dy> Thanks for your insights.
13:54:33 <maerwald> but I think it makes sense to try it out, even in a company context
13:54:49 <maerwald> because it is indeed simpler than git
13:55:11 <rhaps0dy> and merges correctly, I read
13:55:40 <Zemyla> edwardk, in your parsers library, why is ReadP a parser, but ReadPrec isn't?
13:55:53 <maerwald> well, it isn't really based on commit-hash-history, rather on some sort of "patch theory"... it merges things that git would never merge
13:56:17 <edwardk> Zemyla: send me a patch =P
13:56:28 <rhaps0dy> ah
13:56:30 <geekosaur> bleagh. there are not really that many formatting libraries on hackage, and most stop at some variant of the default "show" formatting :/
13:56:38 <rhaps0dy> it's not rational to try it, but let's try it :D
13:57:06 <edwardk> newtype ReadPrec a = P (Prec -> ReadP a)
13:57:15 <edwardk> seems viable
13:57:24 <maerwald> rhaps0dy: you can start here http://hub.darcs.net/
13:57:41 <maerwald> it allows omniauth via github
13:57:46 <Zemyla> edwardk: The only non-obvious thing I'd add is that the nesting function in TokenParsing sets the internal precedence to 0.
13:58:17 <edwardk> Zemyla: include that in a comment with the patch and it makes sense to me
14:01:38 <rhaps0dy> maerwald: nice
14:01:46 <rhaps0dy> yeah, I already got to darcs.net from the hub
14:02:18 <maerwald> rhaps0dy: setting up your own darcsden is also straightforward (way easier than gitlab)... if you are using it in a company environment
14:02:27 <Zemyla> This is a good time to learn how to download and build packages so I can edit them.
14:03:00 <rhaps0dy> maerwald: no, no, it's for a personal project
14:03:14 <rhaps0dy> although I could host my own darcsden indeed. But I'd rather use the hub.
14:03:36 <maerwald> yeah
14:05:31 <Zemyla> Hmm. Do you think there should be a LeftParsing class, which has the <++ operator which only parses the right value if the left one fails without consuming input?
14:08:20 <simon> Zemyla, like ReadP's (<++)?
14:13:10 <Zemyla> simon: Yeah.
14:13:11 * hackagebot snaplet-hasql 1.0.2 - A Hasql snaplet  http://hackage.haskell.org/package/snaplet-hasql-1.0.2 (MikeLedger)
14:13:13 <rhaps0dy> Huh, darcs treats directories as their own thing
14:13:15 <rhaps0dy> interesting
14:14:13 <phylene> is there a name for a data structure that is kind of like a list except it goes to an inner node from both ends
14:14:37 <phylene> like [8 [9 [] 10] 11]
14:14:45 <rhaps0dy> Whoah
14:14:48 <rhaps0dy> then no idea.
14:15:20 <koala_man> phylene: what's the difference between that and a list of tuples?
14:15:25 <ReinH> phylene: a list zipper
14:15:33 <kadoban> phylene: Sounds kind of like a deque maybe, or a list zipper?
14:15:36 <rhaps0dy> maerwald: what about utf-8 characters in author names?
14:15:54 <rhaps0dy> maerwald: [_<U+00E0>_] :(
14:16:07 <ReinH> also known as the derivative of a list
14:16:12 <phylene> koala_man: a list of tuples is just a list, this isnt a list 
14:16:24 <maerwald> rhaps0dy: mmmh, in darcs or in darcsden?
14:16:29 <phylene> thanks @ReinH and @kadoban
14:16:54 <maerwald> rhaps0dy: you can also join #darcs
14:17:33 <ReinH> @google derivative one hole context McBride
14:17:34 <lambdabot> http://strictlypositive.org/diff.pdf
14:17:35 <lambdabot> Title: The Derivative of a Regular Type is its Type of One-Hole Contexts
14:17:37 <ReinH> Good paper
14:18:01 <aznashwan> anyone know a compiler flag to discard all generated intermediary and object files after the binary was built?
14:18:07 <aznashwan> (ghc)
14:18:24 <rhaps0dy> maerwald: in darcs
14:18:43 <maerwald> rhaps0dy: I barely understand the (undocumented) code, you should ask in #darcs
14:19:10 <rhaps0dy> yeah, I will :)
14:19:12 <rhaps0dy> I am *
14:19:37 <koala_man> phylene: ah. I interpreted it as  data Thing x = Element x (Thing x) x | Empty
14:22:23 <phylene> koala_man: thats exactly what I mean
14:22:26 <phylene> how is that a list of tuples
14:22:54 <phylene> I did it slightly differently though
14:22:55 <phylene> as data FL a = Pred a (FL a)
14:22:55 <phylene>           | Succ (FL a) a
14:22:55 <phylene>           | Both a (FL a) a
14:22:55 <phylene>           | One a
14:22:55 <phylene>           | Empty deriving (Eq, Show)
14:23:12 * hackagebot multistate 0.6.1.0 - like mtl's ReaderT / WriterT / StateT, but more than one  contained value/type.  http://hackage.haskell.org/package/multistate-0.6.1.0 (lspitzner)
14:23:16 <koala_man> phylene: You can rewrite it as   data Thing x = Element x x (Thing x) | Empty  and then to data Thing x = Element (x,x) (Thing x) | Empty
14:23:32 <benzrf> nice
14:23:37 <phylene> oooo true
14:23:52 <phylene> I didn't even realise
14:24:14 <phylene> but that kind of makes it more complicated
14:28:12 * hackagebot exceptional 0.1.5.1 - Essentially the Maybe type with error messages.  http://hackage.haskell.org/package/exceptional-0.1.5.1 (pharpend)
14:28:54 <kadoban> Isn't Maybe with error messages called Either?
14:29:49 <oconnore> kadoban: yes
14:29:55 <kadoban> Oh I guess it's something because they didn't like something about Either.
14:29:57 <maerwald> I don't even like that, because it does not let me define a _class_ of errors
14:30:05 <maerwald> not enough control for proper error handling
14:30:41 <maerwald> unless I involve a lot of subtyping
14:35:50 <pharpend> kadoban: it has a slightly different monad instance
14:40:02 <m_ryan> > head [1,2,3,4,5]
14:40:04 <lambdabot>  1
14:41:37 <benzrf> head is partial :(
14:42:03 <maerwald> benzrf: use liquidhaskell to prove that it's still safe :P
14:42:15 <benzrf> i prefer my code to be solid
14:42:21 <maerwald> uh
14:42:24 <Zemyla> edwardk: What format do you want me to send the diff in?
14:42:48 <maerwald> benzrf: if you can prove that it's still safe, then there is no difference in solidness, except that you increased complexity
14:42:56 <benzrf> it was a Pun
14:43:47 <JagaJaga> > head []
14:43:48 <lambdabot>  *Exception: Prelude.head: empty list
14:44:30 <benzrf> check this out:
14:44:36 <benzrf> wait. crap. one minute
14:46:37 <benzrf> :|
14:47:13 <monsieurp> |:
14:47:28 <maerwald> :|:
14:47:29 <m_ryan> > split (==".") "Hello.World"
14:47:30 <benzrf> @let data Meh = (:|)
14:47:30 <lambdabot>  .L.hs:145:12: parse error on input ‘:|’
14:47:30 <lambdabot>      Couldn't match expected type ‘Splitter Char’
14:47:30 <lambdabot>                  with actual type ‘[Char] -> Bool’
14:47:30 <lambdabot>      In the first argument of ‘split’, namely ‘(== ".")’
14:47:34 <benzrf> aw
14:48:05 <benzrf> > break (=='.') "Hello.World"
14:48:06 <lambdabot>  ("Hello",".World")
14:48:13 * hackagebot yesod-auth-oauth2 0.1.2 - OAuth 2.0 authentication plugins  http://hackage.haskell.org/package/yesod-auth-oauth2-0.1.2 (PatrickBrisbin)
14:51:00 <m_ryan> thanks
14:51:13 <benzrf> np
14:51:35 <m_ryan> benzrf: how about i dont want to include the "."?
14:51:52 <benzrf> umm
14:51:55 <benzrf> :t splitAt
14:51:56 <lambdabot> Int -> [a] -> ([a], [a])
14:51:59 <benzrf> oh wait thats a different thing
14:52:03 <Clint> :t splitBy
14:52:04 <lambdabot>     Not in scope: ‘splitBy’
14:52:05 <lambdabot>     Perhaps you meant one of these:
14:52:05 <lambdabot>       ‘BS.split’ (imported from Data.ByteString),
14:52:09 <benzrf> m_ryan: you could drop the first item of the 2nd list
14:52:18 <benzrf> m_ryan: but defaulting to [] if it's already empty
14:52:31 <m_ryan> > splitBy "." "hello.world"
14:52:31 <benzrf> > break (const False) [1, 2, 3]
14:52:33 <lambdabot>      Not in scope: ‘splitBy’
14:52:33 <lambdabot>      Perhaps you meant one of these:
14:52:33 <lambdabot>        ‘BS.split’ (imported from Data.ByteString),
14:52:33 <lambdabot>  <no location info>: can't find file: L.hs
14:52:35 <benzrf> > break (const False) [1, 2, 3]
14:52:37 <lambdabot>  ([1,2,3],[])
14:52:41 <benzrf> hm
14:52:55 <marchelzo_> :t splitOn
14:52:56 <lambdabot> Eq a => [a] -> [a] -> [[a]]
14:53:17 <m_ryan> > splitOn "." "hello.world"
14:53:18 <lambdabot>  ["hello","world"]
14:53:23 <m_ryan> thank you
14:53:43 <marchelzo_> Or
14:53:59 <marchelzo_> > partition (== '.') "Hello.World"
14:54:01 <lambdabot>  (".","HelloWorld")
14:54:04 <marchelzo_> Nevermind :)
14:54:18 <marchelzo_> That didn't do what I thought it would.
14:55:10 <m_ryan> :) its ok thank you for tha input :)
14:56:13 <simon> > span (== '.') "Hello.World"
14:56:14 <lambdabot>  ("","Hello.World")
14:56:33 <simon> whoops.
14:56:39 <simon> > span (/= '.') "Hello.World"
14:56:40 <lambdabot>  ("Hello",".World")
14:57:12 <simon> err, I'm not paying attention. I see that benzrf already suggested this.
14:58:19 <simon> Data.List.Split has a lot of neat functions.
14:58:31 <Denommus> what regex library do you guys suggest me to use?
14:58:53 <sm> I like regex-tdfa
14:59:11 <Denommus> sm: does it support lazy matching?
14:59:21 <Denommus> sm: notice that I'm not talking about lazy evaluation
14:59:22 <sm> I don't know
14:59:28 <m_ryan> :t commas
14:59:29 <lambdabot>     Not in scope: ‘commas’
14:59:29 <lambdabot>     Perhaps you meant ‘comma’ (imported from Text.PrettyPrint.HughesPJ)
14:59:54 <m_ryan> question again how do i convert "1234" -> 1234
15:00:17 <Clint> > read "1234" :: Word16
15:00:18 <lambdabot>  1234
15:00:50 <arkeet> > read "123456" :: Word16
15:00:52 <lambdabot>  57920
15:01:57 <m_ryan> arkeet: it's not the same from the string
15:02:10 <arkeet> I know.
15:02:45 <m_ryan> arkeet: but Clint has the same output, how?
15:02:53 <m_ryan> can you explain it to me.
15:02:57 <arkeet> > 123456 `mod` 2^16
15:02:58 <lambdabot>  57920
15:03:02 <srhb> m_ryan: The number is small enough to fit in a Word16
15:03:07 <srhb> maxBound :: Word16
15:03:11 <srhb> > maxBound :: Word16
15:03:13 <lambdabot>  65535
15:03:40 <m_ryan> srhb: what if it it larger that than?
15:03:41 <arkeet> > read "1234" :: Integer
15:03:42 <lambdabot>  1234
15:03:48 <srhb> m_ryan: Then it will overflow
15:03:57 <Denommus> sm: thanks anyway, I'll check it out
15:03:58 <srhb> > maxBound + 1 :: Word16
15:03:59 <m_ryan> does integer resolve the issue?
15:03:59 <lambdabot>  0
15:04:03 <srhb> m_ryan: Yes
15:04:04 <arkeet> Integer is unbounded.
15:04:08 <m_ryan> thank you
15:04:37 <m_ryan> what does it mean?
15:04:42 <m_ryan> it has not limit?
15:04:45 <srhb> m_ryan: Yep.
15:04:59 <m_ryan> that's what i needed. :)
15:05:00 <srhb> m_ryan: Aside from your machine running out of memory :-)
15:05:15 <m_ryan> now that's a problemt.
15:05:15 <mniip> is there a name for system f-omega but with only toplevel implicit foralls?
15:05:21 <m_ryan> problem ^
15:05:50 <srhb> m_ryan: Yes, infinite memory computers would be nice.
15:06:52 <m_ryan> maybe Word16 for now. if we encounter problem maybe we change to Integer.
15:07:38 <maerwald> srhb: maybe we could simulate that if we would able to encode minimal information to recompute past states (and wipe them effectively from current memory)? I'm just dreaming...
15:09:04 <srhb> maerwald: Pretty sure that's one of those "sure, if you want the universe to cease existing" things :P
15:09:27 <ReinH> There's this thing called entropy...
15:09:43 <maerwald> I think it's doable, but it wouldn't be "infinite memory" per se, because in order to get past states you would have to recompute them (which isn't how memory is defined)
15:10:09 <maerwald> it would just be a hack to get to past states quicker, if we are lucky to figure it out
15:11:18 <srhb> maerwald: In relation to holding infinitely big Integers, that's not really relevant.
15:11:27 <srhb> OK, this discussion is silly. :P
15:11:50 <maerwald> srhb: I think it is... if you think of the integer being lazy :P
15:12:03 <Denommus> I meant non-greedy, not lazy
15:12:10 <maerwald> (and yes, the discussion is probably still silly)
15:12:13 <arkeet> m_ryan: don't use Word16 if you don't have a specific reason to.
15:12:17 <Denommus> is there a regular expression library with non-greedy operators?
15:12:30 <arkeet> m_ryan: just use Int or Integer instead
15:13:14 * hackagebot Yampa-core 0.2.0 - Library for programming hybrid systems.  http://hackage.haskell.org/package/Yampa-core-0.2.0 (NikolayOrlyuk)
15:13:16 * hackagebot Chart 1.5 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.5 (TimDocker)
15:13:18 * hackagebot Chart-cairo 1.5 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.5 (TimDocker)
15:13:20 * hackagebot Chart-gtk 1.5 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.5 (TimDocker)
15:13:22 * hackagebot Chart-diagrams 1.5 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.5 (TimDocker)
15:15:45 <m_ryan> thank you
15:15:58 <m_ryan> another question does printf return a string?
15:15:59 <srhb> arkeet: Int? >_>
15:16:13 <arkeet> ok, Integer.
15:16:14 <srhb> m_ryan: There are several variants of printf, which one are you referring to?
15:16:34 <m_ryan> srhb: this one  printf "%.2f"
15:16:34 <srhb> m_ryan: The Text.Printf one?
15:16:36 <ttt_fff> do we have something like http://plum-umd.github.io/adapton/ for haskell? I've always felt that React is a special case of "incremental computation on data structures" where the data structure = DOM Tree
15:16:39 <srhb> m_ryan: That doesn't help me
15:16:43 <srhb> m_ryan: Where is it from? base?
15:16:51 <m_ryan> printf "%.2f" $ (d :: Double)
15:17:15 <srhb> m_ryan: I think you are referring to the one in base, which is polymorphic over PrintfType
15:17:19 <srhb> m_ryan: So look at its instances.
15:17:20 <geekosaur> printf can return a string or perform I/O
15:17:29 <geekosaur> it decides by the requested return type
15:17:37 <geekosaur> if it's IO () then it writes to stdout
15:17:42 <geekosaur> if it's String then it produces a string
15:17:47 <srhb> Wonderful black magic.
15:17:55 <geekosaur> (printf is very black magic involving typeclasses)
15:18:21 <geekosaur> (the scariest part is there are no fancy ghc extensions involved)
15:18:42 <m_ryan> i have this code: formatedString <- pack . printf "%.2f" $ (d :: Double) and it says the return type is [GHC.Prim.Any -> string] 
15:18:50 <monochrom> I don't think it's very black or very magic
15:18:53 <srhb> It isn't.
15:19:25 <srhb> m_ryan: It's not sufficiently constrained, but you probably want let formatedString = .. anyway
15:19:30 <geekosaur> I don't think you want <- there
15:19:32 <srhb> m_ryan: Constrain it to :: String if that's what you want.
15:19:32 <monochrom> but it is quite a bit overlapping instances IIRC
15:19:39 <geekosaur> or, what srhb just said :)
15:20:20 <srhb> I wonder if it has a Text instance...
15:20:33 <geekosaur> you can get some fairly unexpected inferred types if you use it "wrong"
15:20:34 <srhb> Or vice versa, rather.
15:20:49 <srhb> geekosaur: Mostly because of it being variadic, I assume.
15:20:49 <glguy> The instances don't look particularly overlappy
15:21:11 <monochrom> alright, that's even better
15:23:15 * hackagebot yampa-glut 0.1.1.1 - Connects Yampa and GLUT  http://hackage.haskell.org/package/yampa-glut-0.1.1.1 (NikolayOrlyuk)
15:23:32 <benzrf> printf is disgusting
15:23:42 <m_ryan> i paste my updating code: http://lpaste.net/135227
15:23:43 <benzrf> @let class BuildList r a | r -> a where list :: r; blPrepend :: a -> r -> r
15:23:44 <lambdabot>  Defined.
15:24:00 <benzrf> @let instance BuildList [a] a where list = []; blPrepend = (:)
15:24:01 <lambdabot>  .L.hs:142:10: Not in scope: type constructor or class ‘BuildList’
15:24:08 <benzrf> :(
15:24:16 <glguy> benzrf: If you want to show code use the pastebin
15:24:17 <benzrf> whaa
15:24:23 <benzrf> its just 3 lines glguy
15:24:48 <benzrf> but k
15:25:27 <glguy> It'd be 3 nontrivial lines and if you care if anyone actually gets a chance to stare at it and care a pastebin wouldb e better
15:25:41 <benzrf> i was doing it not for the code but to scare ppl with the black magic
15:25:43 <benzrf> :>
15:25:43 <glguy> and if you don't care if anyone looks at it a pastebin is also better
15:25:51 <benzrf> @undef
15:25:51 <lambdabot> Undefined.
15:25:54 <benzrf> @letlpaste 135228
15:25:55 <lambdabot>  Defined.
15:26:04 <benzrf> > list 'a' 'b' 'c' :: String
15:26:06 <lambdabot>  "abc"
15:26:13 <benzrf> > list 'a' 'b' 'c' 'd' 'e' :: String
15:26:14 <lambdabot>  "abcde"
15:26:16 <benzrf> :>
15:26:47 <benzrf> > list :: String -- even this
15:26:49 <lambdabot>  ""
15:27:11 <shachaf> printf does the same thing.
15:27:13 <benzrf> i know
15:27:20 <shachaf> Probably the same way.
15:27:26 <benzrf> probably not, this uses extensions
15:27:32 <benzrf> but same idea
15:27:57 <shachaf> printf uses hacks instead of extensions.
15:28:06 <benzrf> well, this is definitely a hack
15:28:17 <benzrf> i think i ended up using an extension because of some difficulty involving polymorphism actually
15:28:30 <benzrf> which may not have affected printf? i dont know 
15:28:42 <shachaf> printf has the opposite difficulty
15:28:43 <benzrf> maybe i just wasnt clever enough to recreate their solution precisely
15:28:47 <shachaf> Too easy to be polymorphic.
15:28:58 <shachaf> It wants to be monomorphic but that requires an extension or a hack.
15:29:02 <benzrf> well, lists are homogeneous
15:30:56 <TallerGhostWalt> does anyone know if there is a way to link stack to a private package repo?
15:35:30 <aronian> Suppose I wanted to draw and interact with a custom widget (something like a chess board, say) in gtk2hs, what would be the best approach? Cairo perhaps?
15:38:15 * hackagebot riak-protobuf 0.19.0.0 - Haskell types for the Riak protocol buffer API  http://hackage.haskell.org/package/riak-protobuf-0.19.0.0 (MarkHibberd)
15:38:17 * hackagebot clash-prelude 0.9 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.9 (ChristiaanBaaij)
15:40:55 <sm> aronian: have you looked at diagrams ?
15:43:16 * hackagebot clash-lib 0.5.7 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.5.7 (ChristiaanBaaij)
15:43:18 * hackagebot riak 0.8.0.0 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.8.0.0 (MarkHibberd)
15:43:20 * hackagebot clash-systemverilog 0.5.6 - CAES Language for Synchronous Hardware - SystemVerilog backend  http://hackage.haskell.org/package/clash-systemverilog-0.5.6 (ChristiaanBaaij)
15:43:22 * hackagebot clash-verilog 0.5.6 - CAES Language for Synchronous Hardware - Verilog backend  http://hackage.haskell.org/package/clash-verilog-0.5.6 (ChristiaanBaaij)
15:43:24 * hackagebot clash-vhdl 0.5.7 - CAES Language for Synchronous Hardware - VHDL backend  http://hackage.haskell.org/package/clash-vhdl-0.5.7 (ChristiaanBaaij)
15:48:26 * hackagebot clash-ghc 0.5.8 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.5.8 (ChristiaanBaaij)
15:48:51 <aronian> sm: Thanks for the pointer, checking it out now
15:52:38 <sm> it has some kind of interactive "game loop" module, somewhere
15:52:57 <sm> or was that gloss
15:54:14 <sm> yes, http://hackage.haskell.org/package/gloss-1.9.2.1/docs/Graphics-Gloss-Interface-IO-Game.html
15:58:19 <xenon-> if I want to split my module into several modules, for example, xenon-string, xenon-gtk, and then have xenon module that depends on all of my modules.. what would be the best way to do that? do I need a new cabal file for each module?
15:58:52 <arkeet> are you talking about modules, or packages?
15:59:24 <xenon-> maybe, if you import modules and cabal-install packages
15:59:34 <arkeet> that is what you do
16:00:05 <arkeet> a module is a single file
16:00:08 <arkeet> a package is the thing defined by a .cabal file
16:00:27 <xenon-> so I was talking about packages
16:00:42 <arkeet> mhm.
16:00:48 <xenon-> I need one file per package? can't have multiple packages in one cabal file?
16:00:50 <arkeet> well, each package needs its own cabal file.
16:00:56 <xenon-> one package per cabal file
16:01:06 <arkeet> right
16:01:14 <simon> one module per .hs file, one package per .cabal file
16:01:26 <slack1256> unless your separation is about a library and a executable on a single .cabal file
16:01:31 <xenon-> i was wondering if multiple libraries in a cabal file would work as well
16:01:54 <arkeet> I believe not.
16:02:01 <arkeet> not that there would be any point to it.
16:02:09 <xenon-> the main reason why i want to split it into multiple modules is to avoid installing huge libraries like gtk2hs in a sandbox if I, say, want to just use Xenon.String
16:02:35 <arkeet> splitting it into multiple packages sounds reasonable to me.
16:02:46 <xenon-> yes packages :)
16:02:59 <simon> that is really when you want to split a package into two.
16:03:33 <simon> Xenon.String sounds like something you'd use a lot and Xenon.Gtk sounds like something you'd use less often. :)
16:03:43 <xenon-> yeah
16:08:35 <zed_> hello everyone :) i am learning how to debug in haskell and i could use some help - here's the code with the error : http://lpaste.net/135233
16:09:42 <arkeet> sounds like you need to write an Observable instance for Input.
16:11:12 <zed_> arke
16:11:32 <zed_> arkeet: what do you mean? I'm really new to this
16:11:53 <arkeet> observe :: Observable a => String -> a -> a
16:12:14 <arkeet> the second argument must be an instance of the Observable class.
16:12:21 <arkeet> (the type of the argument.)
16:12:25 <arkeet> https://hackage.haskell.org/package/hood-0.2/docs/Debug-Hood-Observe.html
16:12:55 <arkeet> there are already instances for functions and lists and Double and such, but nothing for your own Input type.
16:13:19 <zed_> oh i see
16:13:20 <zed_> thanks
16:13:36 <xenon-> I was just curious in what way would having a single cabal file and multiple libraries sections be different? would there still be a way to install only dependencies one library?
16:13:48 <xenon-> for one library*
16:13:50 <arkeet> hence the message: No instance for (Observable Input)
16:14:34 <zed_> arkeet: so what would you suggest me to do if I wanted to debug closedForm ?
16:14:43 <funfunctor> Hi, i'm looking for :: [String] -> String   such that it will concatenate each string together seperated by "|"
16:14:55 <marchelzo_> :t intercalate
16:14:56 <lambdabot> [a] -> [[a]] -> [a]
16:14:57 <arkeet> :t intercalate
16:14:58 <lambdabot> [a] -> [[a]] -> [a]
16:15:03 <funfunctor> ah thats the one thanks
16:15:21 <arkeet> > intercalate "|" ["hi","funfunctor",":)"]
16:15:23 <lambdabot>  "hi|funfunctor|:)"
16:16:03 <benzrf> nah man
16:16:08 <benzrf> for just | you want intersperse
16:16:11 <benzrf> :t intersperse
16:16:12 <lambdabot> a -> [a] -> [a]
16:16:25 <benzrf> intercalate is when you wanna sandwich a list of the same type between other lists, then concat
16:16:32 <benzrf> intersperse just sticks an element between
16:16:40 <benzrf> oh , wait
16:16:45 <benzrf> nvm, i see the deal >_>
16:16:51 <ReinH> intersperse x = intercalate [x]
16:17:04 <benzrf> ReinH: tru
16:17:09 <benzrf> wait
16:17:17 <benzrf> no thtas not quite right
16:17:29 <arkeet> intersperse doesn't concatenate.
16:17:30 <benzrf> :t \x -> intercalate [x]
16:17:31 <lambdabot> a -> [[a]] -> [a]
16:17:36 <benzrf> ye
16:17:43 <mniip> intercalate = (concat .) > intersperse
16:17:47 <mniip> s/>/./
16:17:51 <ttt_fff> in ahskell, is there a function which is [a] -> [(Int, a)] so [a, b, c] -> [(1, a), (2, b), (3, c)]
16:17:59 <benzrf> ttt_fff: sadly not quite
16:18:00 <benzrf> you can do
16:18:00 <arkeet> :t \x l -> concat (intersperse x l)
16:18:01 <lambdabot> [a] -> [[a]] -> [a]
16:18:03 <mniip> ttt_fff, zip [1..]
16:18:04 <benzrf> zip l [1..]
16:18:12 <arkeet> ttt_fff: zip [1..]
16:18:12 <benzrf> o wait yeah put [1..] first
16:18:31 <ttt_fff> benzrf , mniip , arkeet: noted, thanks! very nice, forgot that zip stops at shorter of two lists very cute
16:18:43 <benzrf> :}
16:18:52 <arkeet> zipping with an infinite list is pretty handy.
16:18:53 <ReinH> Yeah I thought it did the other thing for a sec
16:25:42 <osa1_> this library builds and runs fine(tests etc. all working) but I'm having this when I load it using cabal repl: http://lpaste.net/135235 any ideas why?
16:26:45 <Fuuzetsu> just had to :: [String] on the last argument to mapM_, lame ;(
16:26:56 <benzrf> :t list
16:26:57 <lambdabot> BuildList r a => r
16:26:59 <benzrf> :>
16:28:22 <xenon-> Fuuzetsu OverloadedStrings?
16:28:44 <benzrf> Overloaded Strings: strings that are too big
16:29:14 <Fuuzetsu> xenon-: OverloadedLists apparently
16:29:51 <Fuuzetsu> didn't know that was a thing, cool
16:30:47 <benzrf> yoooo what
16:31:02 <Fuuzetsu> this changes everything
16:31:11 <benzrf> LISP TIME
16:31:15 <Fuuzetsu> get out
16:31:22 <benzrf> huehuehue
16:31:52 <benzrf> how does overloaded lists work
16:32:39 <Fuuzetsu> it's explained on https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
16:32:52 <benzrf> implying firefox works while idris is compiling
16:33:09 <Fuuzetsu> use links
16:33:10 <benzrf> implying switching windows works while idris is compiling
16:33:13 <Fuuzetsu> or better
16:33:17 <Fuuzetsu> just use nix and don't compile idris
16:41:49 <ttt_fff> hmm, I'm using threepenny (dom as GUI). Running my code, I get "an exception escaped to toplevel" .... is there a way to get more info? like a filename / line number ?
16:51:11 <slack1256> or use cgroups and have a hiearchy for compiling
16:51:22 <slack1256> I discovered that when compiling lens :-)
17:04:55 <hodapp> if I'm building docs for a project that has 10-15 directories each with a .cabal file, how do I go about building documentation such that the different projects can link to each other?
17:05:50 <hodapp> 'cabal haddock' builds for a single one just fine, but I don't know how to direct it to find the other projects
17:06:08 <sm> hodapp: I think stack takes care of that
17:06:14 <hodapp> stack?
17:06:25 <sm> http://www.reddit.com/r/haskell/comments/3awgj1/stack_01_released_a_new_build_tool_for_haskell/
17:10:13 <hodapp> sm: not seeing anything about this so far..
17:10:53 * sm tries it
17:16:16 <sm> yes, stack haddock [--no-haddock-deps] and I think the package haddocks interlink (but the master table of contents doesn't)
17:16:51 <hodapp> and it'll grok the existing .cabal files?
17:17:07 <hodapp> or... I guess it need not, technically
17:30:40 <kerscher> I'm sorting some very large text files to count character occurrences, and memory shot really up. Files range from 0.3–1.2 GB, but memory usage goes way past 10 GB, mostly allocating and deallocating things – checked through GHCs output.
17:30:56 <mmaruseacph2> space leaks?
17:31:18 <kerscher> I'm using String, since I couldn't find a way of sorting Text without first breaking into a list of Text. Am I missing something?
17:31:35 <kerscher> mmaruseacph2: seems like it. More than 90% of running time is spent on GC.
17:32:03 <srhb> kerscher: the sorting bit might be problematic here.
17:32:28 <srhb> kerscher: How are you doing it? Just plain sort?
17:32:37 <kerscher> yes, plain sort from Data.List
17:33:05 <kerscher> also, the text is full of non-ASCII characters, but order of collation is unimportant
17:33:41 <srhb> kerscher: I'm wondering, are you the person that spoke about counting bytes at one point in -beginners?
17:33:56 <kerscher> srhb: not me, no :)
17:34:00 <srhb> Oh okay.
17:34:15 <kerscher> I'm analysing Wikipedia dumps of multiple languages
17:35:00 <srhb> kerscher: If you have that much data you're going to need to do this in-place, I think.
17:35:12 <srhb> kerscher: So you might as well start throwing things in vectors and counting by binning or similar.
17:35:22 <srhb> (Or you can still sort, but there's no reason to...)
17:36:22 <mmaruseacph2> yeah, at this size vectors are a must
17:37:13 <srhb> I wonder if there are sparse vectors somewhere.
17:37:28 <sm>  would http://hackage.haskell.org/package/discrimination be useful ?
17:38:21 <srhb> Oh, inspired by Fritz Henglein
17:38:50 <srhb> And yep, that looks very useful
17:39:25 <srhb> But if it's very large you might still want to avoid sorting first
17:39:32 <kerscher> srhb, mmaruseacph2: so vectors it'll be. however, I'm not sure how to bin when my range is all possible Unicode code points.
17:39:33 <srhb> (Which makes sparse vectors needed-ish instead)
17:39:46 <srhb> kerscher: Indeed. That's why I was looking for something sparse to bin in.
17:39:51 <simon> sm, cool.
17:39:54 <simon> srhb, hi!
17:39:55 <kerscher> sm: that looks good :)
17:40:02 <srhb> simon: Hi!
17:40:40 <george_p> I am using sandboxes and I was wondering if it is also a good idea to use stackage as well?
17:40:43 <sm> yay
17:40:53 <sm> wow, there's a lot of stuff on hackage now
17:41:00 <srhb> simon: Fun stumbling on a Henglein-inspired library after just rewatching "smart and smarter" with him :-)
17:41:17 <simon> yeah
17:41:57 <simon> I've been thinking a lot about that article, hoping it'd show up in Haskell eventually.
17:42:26 <srhb> I haven't read it.
17:42:48 <simon> I bet this is the first implementation, too, so now we can boast that Haskell is the first language that does generic linear-time sorting :P
17:43:04 <srhb> Haha.
17:43:14 <srhb> Well, thanks to edwardk for picking it up then.
17:43:24 <srhb> It's not like DIKU is producing, like, anything for Hackage :P
17:43:38 <kerscher> I haven't read the papers, but I will once finished with this. Is the large dataset a recurrent problem in general for Haskell?
17:44:19 <srhb> kerscher: Not at all?
17:44:32 <srhb> kerscher: It's no more a problem than in any other language.
17:45:12 <srhb> kerscher: And one thing you could do instead of Vector is simply using a Map. 
17:45:18 <srhb> kerscher: At least that's sparse :-)
17:45:34 <simon> srhb, I'm still toying around with servant and APIs. turns out that I'm a more crappy API designer than a Haskell coder. :(
17:45:48 <kerscher> srhb: most of my haskell so far has been extract-transform-load things and services using small data. It's my first time stumbling upon “largeish” data processing within the language itself.
17:45:50 <srhb> simon: Well, API design is hard :P
17:46:04 <srhb> kerscher: Right :)
17:48:22 * hackagebot halive 0.1.0.4 - A live recompiler  http://hackage.haskell.org/package/halive-0.1.0.4 (lukexi)
17:50:19 <sm> lukexi++ 
17:51:40 <funfunctor> How do I parse something like this http://lpaste.net/135240 ?
17:51:44 <kerscher> in any case, thanks for the help. I'll go through the options :)
17:51:54 <funfunctor> *with hjson
17:52:37 <srhb> funfunctor: Why are you not using aeson?
17:52:53 <funfunctor> srhb: i'm not sure..
17:52:56 <srhb> funfunctor: Me neither!
17:55:06 <funfunctor> srhb: can you run me though this example?
17:55:25 <srhb> funfunctor: Sadly no, I'm heading to bed to nurse a middle ear infection. I'm sure someone else can help.
17:55:43 <funfunctor> ah oh, srhb feel better soon !
17:56:06 <srhb> Thanks :)
17:56:18 <simon> a middle earth infection, you say. orcs?
17:56:22 <funfunctor> srhb: ibuprofen helps for the ear..
17:56:39 <funfunctor> srhb: takes the pressure off things a little bit
17:56:45 <srhb> simon: Yep! Orcs inside my skull near the hammer and anvil and things
17:57:01 <srhb> funfunctor: Acetaminaphen for now, but yes. Thanks :)
17:57:02 <george_p> is there a need for stackage when I use sandboxes?
17:57:14 <funfunctor> srhb: really hope you feel better soon!
17:57:21 <Gurkenglas> http://hackage.haskell.org/package/discrimination-0.1/docs/src/Data-Discrimination-Grouping.html#nub <- What's runLazy? Which package defines it? Hoogle and lambdabot don't seem to know it.
17:58:17 <simon> george_p, my impression is yes, because the best-practice workflows you may currently follow is simplified so fewer things go wrong.
17:58:33 <sm> Gurkenglas: hayoo finds some, http://hayoo.fh-wedel.de/?query=runLazy
17:58:47 <sm> Data.Promise I'd say
17:58:56 <Gurkenglas> Thanks.
18:01:26 <simon> george_p, if you do anything outside of sandboxes, yes. if you depend on multiple versions of the same package, yes. if you use libraries that depend on external system libraries, yes. but that's just a shallow impression. I don't do much outside sandboxes myself and my workflow is very simplistic.
18:02:40 <george_p> I dont anything outside of sandboxes. did a clean install few weeks ago, downloaded plain ghc, and I use sandboxes for everything
18:04:01 <george_p> but it seems stackage has an extra benefit of selecting specific versions of packages that plain nicely together? it may cabal install without it, but some tests could still fail if i install from hackage
18:04:26 <simon> george_p, I'd probably wait a little and make the transition whenever there are good stackage tutorials. :)
18:05:32 <eacameron> can someone explain "reify" or point me to something that does? I haven' found a definition that makes sense to me
18:05:39 <arkeet> from reflection?
18:06:19 <eacameron> I don't know enough to answer even that basic question
18:06:29 <arkeet> where are you seeing "reify"
18:06:36 <eacameron> th-reify-many
18:06:39 <arkeet> oh.
18:06:42 <eacameron> or other TH related thing
18:06:43 <arkeet> I was thinking the one from
18:06:43 <eacameron> s
18:06:45 <arkeet> @hackage reflection
18:06:45 <lambdabot> http://hackage.haskell.org/package/reflection
18:06:49 <arkeet> no idea then.
18:14:40 <george_p> simon: is there more to stackage than just putting cabal.config from their page in the same directory your .cabal file is?
18:31:16 <catsup> george_p: you should consider using 'stack'
18:33:44 <catsup> george_p: it seems to be the easiest way to use stackage now, plus it will install ghc versions etc.
18:47:20 <george_p> "Unlike cabal sandboxes, isolation in stack is complete: packages built against different versions of dependencies never interfere, because stack transparently installs packages in separate databases (but is smart enough to reuse databases when it is always safe to do, hence keeping build times low)."
18:48:54 <george_p> so if two unrelated packages depend on the same huge package, that package will be built only once and shared between the two?
18:49:08 <george_p> if si that is amazing
18:49:10 <creichert> george_p:to you're first question, not really. It can be helpful if you are dealing with version conflicts.
18:49:49 <creichert> The dependencies are tested, though.
18:52:18 <funfunctor> So i've built a API using hjson but now I need to use the API to parse the json using aeson and so I am made a bit of a pain for myself
18:52:56 <funfunctor> should my API really be typing its returned json values as ByteStrings?
18:53:26 * hackagebot nagios-plugin-ekg 0.1.1.0 - Monitor ekg metrics via Nagios  http://hackage.haskell.org/package/nagios-plugin-ekg-0.1.1.0 (fractalcat)
18:54:23 <Adeon> is there a trick to load all modules in a cabal repl or stack ghci in a library project
18:54:36 <Adeon> when I write 'stack ghci' I have to first manually :load my module and then import it
18:54:58 <Adeon> I would have no problem with it automatically loading and importing every module, although I know that may not be the best for every project
18:56:04 <creichert> Adeon: it's a bug, i think. https://github.com/commercialhaskell/stack/issues/394
18:56:46 <Adeon> ah, I see
18:56:53 <creichert> funfunctor: It's hard to tell the exact context, but it shouldn't be a massive change assuming you have some types describing the json objects you want to parse
18:56:59 <Adeon> maybe I should get the latest development version
18:59:56 <dmj`> jle`: ping
19:02:18 <nkaretnikov> what can I do to prevent hIsEOF from blocking?
19:02:46 <nkaretnikov> (the code after hIsEOF handle is never called)
19:05:02 <nkaretnikov> one way to solve this that comes to mind is to get rid of it and just catch the exception instead
19:08:04 <funfunctor> creichert: can I run you though things..
19:08:29 <mjrosenb> Is there any serialize library that preserves structure?[5;2~
19:08:56 * mjrosenb wonders where that trailing garbage came from :-/
19:09:30 <funfunctor> mjrosenb: not sure what you mean by preserve structure but yes, you can use the Get and Put monads perhaps?
19:10:07 <mjrosenb> like let x = [1..10^6] in [x,x,x,x,x]
19:11:00 <DNoved1> You mean sharing subterms?
19:11:22 <mjrosenb> I want some way of serializing this such that it only stores one copy of the list of integerts between 1 and a million.
19:12:40 <DNoved1> Nothing I know of, sorry.
19:16:23 <mjrosenb> This seems like it should be pretty useful.
19:19:59 <DNoved1> The problem is detection of when subterms are equivalent, which would, done naively, require way too much processing time.
19:20:37 <DNoved1> It might be reasonable for hashable objects; I recall the Aterm library did hash consing for serialization which shared subterms
19:22:37 <DNoved1> Oh wait, it appears aterm is available for haskell: http://hackage.haskell.org/package/aterm
19:22:59 <mjrosenb> If every single allocatable object had an IORef Int on it, it would be /somewhat/ easy
19:23:15 <mjrosenb> but that would require lifting basically everything into the IO monad
19:23:27 <funfunctor> @hoogle String -> ByteString
19:23:27 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
19:23:27 <lambdabot> Graphics.Rendering.OpenGL.GL.Shaders.ShaderObjects packUtf8 :: String -> ByteString
19:23:27 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
19:24:46 <bob_twinkles> is there a non-depricated way to express something like "data SomeTypeclass a => MyDataType a = ... "
19:25:07 <bob_twinkles> GHC recommends I use DatatypeContexts and then warns that it's a bad idea =P
19:25:50 <mjrosenb> also, with pointers, you should be able to do it without needing the data to be finite.
19:26:54 <Axman6> yeah don't do that bob_twinkles. that constraint infects all your code, if you need to maintain that constraint then make a smart constructor and don't export the datatype itself.
19:28:17 <bob_twinkles> well, what I'm trying to do is have an XMonad LayoutClass that lays out some windows and then delegates to another LayoutClass to lay out the rest of them
19:28:46 <mmercer_> when interfacing a C lib with FFI, do you find yourself writing a high-level function in C and then accessing it from haskell, or do you import low-level C functions and then do the work in haskell?
19:29:08 <Axman6> beauby: basically doing that means that _every_ single function that uses that data type has to have that constraint, including ones that don't use any of the functionality from the class
19:29:09 <bob_twinkles> so I need to express that there is a member which is a LayoutClass of some type
19:30:43 <Axman6> you express that on the functions which need the functionality of that class
19:30:52 <geekosaur> bob_twinkles, typically we use a data without the constraint and don't export it, instead providing a smart constructor with the constraint
19:32:13 <geekosaur> which is why (for example) XMonad.Layout.IM uses withIM (lowercase, smart constructor) instead of an IM constructor
19:32:49 <minominomeen> ls
19:32:56 <minominomeen> Oops, wrong keyboard
19:33:04 <bob_twinkles> so I want something like "data MyData a = MyData { someThing :: a }", but only ever construct it with a function "mkData :: (SomeClass a) => a -> MyData a"?
19:35:31 <geekosaur> yes
19:35:55 <geekosaur> and export only the latter so people can't go around the constraint
19:36:07 <geekosaur> (well, export the type but without constructors)
19:36:58 <bob_twinkles> ah, cool. Thanks for the help
19:37:33 <mmercer_> it seems that writing C in haskell is pretty cumbersome compared to just writing C in C, and then just the interfacing high-level C function from haskell instead of building it in haskell from scatch. what do you think?
19:37:42 <xj54y> Any articles, books, papers on design patterns in algorithmic design with haskell?
19:38:25 <dmj`> xj54y: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
19:38:47 <xj54y> dmj`, not quite what I'm looking for. Excellent book however
19:40:27 * dmj` is puzzled
19:42:15 <monochrom> xj54y: http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt
19:42:49 <monochrom> functions. functions. functions again. and functions too.
19:43:49 <dolio> There was OO Cobol?
19:44:20 <xj54y> Isn't there still OO Cobol?
19:44:33 <dolio> Maybe.
19:45:37 <pacak> Given some A (newtype A = A Int), about 100-500 of them, I don't know all in advance, what is the fastest way to get a data structure indexed by A? Similar to Map A a or HashMap A a, but faster? At the moment I'm using custom 2-3 btree, bit it's a bit ugly. 
19:46:12 <geekosaur> visualage cobol for os/2 had OOP
19:47:03 <ttt_fff> hwo do I tell haskell "please, I would like more information than 'tail on empty list'" ... something like a line number / filename would be nice
19:47:52 <geekosaur> at the moment, you don't. the basic support needed for that is mostly present but the plumbing is missing in 7.10; it is expected to be in 7.12
19:48:03 <monochrom> I almost forgot "Visual Age" :)
19:48:09 <pacak> ttt_fff: 1) Don't use tail. 2) you can try debugger from ghci
19:48:19 <geekosaur> sometimes running with +RTS -xc will provide more information
19:48:38 * monochrom should play with OS/2 in virtualbox one day.
19:49:40 <ttt_fff> you're kidding right?
19:49:44 <dolio> Correct answer is 1.
19:49:48 <dolio> Don't use tail.
19:49:49 <ttt_fff> there's no debugging support for this?
19:49:53 <ttt_fff> what do you use instead?
19:50:16 <geekosaur> we mostly avoid it by using pattern matching, which is strict and therefore can provide useful information immediately on failure
19:50:35 <ttt_fff> how do I run it in ghci ?
19:50:37 <ronh> ttt_fff you generally want to avoid using partial functions for prelude. for tail either use pattern matching or something like a safe package that provides safer variants of tail and other functions
19:50:48 <pacak> ttt_fff: pattern matching, ghc will complain if you don't do everything right.
19:50:48 <geekosaur> plumbing the information through laziness is ... difficult, which is why the basic support only appeared in 7.10 and getting it plumbed into the exception stuff is 7.12
19:51:08 <dmj`> question: given a record, how do I print the field name. So data A = A { getA :: String }... how would I retrieve "getA"
19:51:13 <ttt_fff> this literally is never supposed to be empty
19:51:19 <ttt_fff> it's a stack, and I have push/pop pairs balanced
19:51:22 <pacak> dmj`: There are no field names.
19:51:22 <ttt_fff> (or atleast in theory)
19:51:29 <monochrom> pacak: you can try writing wrappers of IntMap functions. example: my_insert (A k) value intmap = IntMap.insert k value intmap
19:51:37 <pacak> dmj`: There might be no A's as well.
19:51:53 <pacak> monochrom: Tried that, my ugly 2-3 btree is still faster :(
19:52:03 <monochrom> oh oops, then nevermind
19:53:52 * funfunctor brain is going to explode...
19:53:53 <geekosaur> (basically it needs some way to silently pass information about the source position through to the exception system, or would need to recognize code that can throw an exception lazily and annotate it for you. the former is what's coming, via use of implicit parameters IIRC)
19:56:19 <geekosaur> (note also that an interpreter like python has all this information on hand all the time, but compiled-to-native code like C or Haskell does not. in C you use ugly preprocessor hacks to do it, usually.)
19:56:41 <dmj`> pacak: there is a way...
19:57:33 <dmj`> @def data A = A { getA :: String } deriving (Data,Typeable)
19:57:34 <lambdabot>  Defined.
19:57:35 <pacak> dmj`: You can write generic or TH based function :: A -> String
19:57:45 <dmj`> > constrFields . toConstr $ A "hey"
19:57:46 <lambdabot>  ["getA"]
19:57:53 <dmj`> pacak: see, it exists
19:58:25 <dmj`> that's for more intelligent parse failures on this lib I'm building
19:58:59 <ttt_fff> :t (<$>)
19:59:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:59:08 <ttt_fff> :t <*>
19:59:09 <lambdabot> parse error on input ‘<*>’
19:59:13 <ttt_fff> :t (<*>)
19:59:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:59:19 <mmercer> @hoogle Text -> String
19:59:20 <lambdabot> Data.Text.Internal.Lazy showStructure :: Text -> String
19:59:20 <lambdabot> Data.Text.Internal showText :: Text -> String
19:59:20 <lambdabot> Data.Text unpack :: Text -> String
19:59:32 <mmercer> unpack is what I want?
19:59:56 <ttt_fff> yeah
20:00:00 <ttt_fff> I use unpack/pack all the time
20:00:26 <mmercer> > unpack $ pack "string"
20:00:28 <lambdabot>      Not in scope: ‘unpack’
20:00:28 <lambdabot>      Perhaps you meant one of these:
20:00:28 <lambdabot>        ‘BS.unpack’ (imported from Data.ByteString),
20:01:18 <mmercer> I just use String until performance matters (which has been never so far)
20:01:35 <mmercer> but gtk2hs changed some functions, and they now return Text
20:01:56 <ttt_fff> lis there a way, by using <$> and <*>, to get rid of the ">>=" in "  ((+d) <$> get_cursorX) >>= pushIndent " ?
20:02:34 <mmercer> I don't think so, >>= is what monads have and applicatives don't
20:02:44 <c_wraith> ttt_fff: no.  You need join or >>= (or other equivalents) for that
20:03:05 <ttt_fff> c_wraith ... or you use =<<
20:03:06 <ttt_fff> eh?
20:05:19 <mmercer> nicer way of writing this?
20:05:21 <mmercer> fmap (fromMaybe "" . fmap unpack) (comboBoxGetActiveText combo)
20:07:05 <mmercer> comboBoxGetActiveText returns  IO (Maybe Text)
20:11:45 <guest123_> hello
20:12:12 <guest123_> anyone know much about Ruby on Rails session cookies?
20:15:20 <AshyIsMe> im sure the people in #ruby or #rails will...
20:41:00 <xj54y> Oh, decorators are very nice. 
20:41:48 <mmercer> decorators? I only know decorators from python
20:44:51 <funfunctor> Hi, I am having issues groking this JSON to parse into a ADT, see   http://lpaste.net/7552662877203595264   and   http://lpaste.net/5563801124588224512
20:51:54 <xj54y> :i failwith
20:56:57 <Zemyla> Hmm. There are two different comonads one could declare on Pair a = Pair a a. Is there one that's more canonical?
20:57:36 <Zemyla> There's either duplicate (Pair a b) = Pair (Pair a b) (Pair b b), or duplicate (Pair a b) = Pair (Pair a b) (Pair b a).
20:59:50 <jle`> i think you also have two more as well
21:00:01 <jle`> or maybe not
21:00:40 <jle`> i like to keep it mysterious
21:11:22 <dmj`> jle`: ping
21:11:37 <xj54y> Is there a shorthand for "else none"
21:11:39 <jle`> dmj`: pong
21:12:03 <Axman6> xj54y: what is none?
21:12:10 <dmj`> jle`: want your criticism
21:12:14 <Axman6> the monadic version would be when
21:12:16 <Axman6> :t when
21:12:17 <lambdabot> Applicative f => Bool -> f () -> f ()
21:12:46 <mmercer> that is a weird way to spell Monad :)
21:13:06 <xj54y> Axman6, I'm mind of thinking of using monadic binds actually
21:13:12 <xj54y> kind of *
21:13:14 <Axman6> yeah I forgot it only needed applicative (I think it used to be Monad only)
21:13:52 <dramforever> none?
21:14:15 <Axman6> xj54y: you still haven't said what 'none' is yet
21:14:16 <xj54y> err, do nothing
21:14:33 <mmercer> when
21:14:36 <dramforever> for example?
21:14:38 <Axman6> you're not 'doing' anything, you're returning a value. you can't return no value
21:14:39 <mmercer> when True (print 10)
21:14:51 <xj54y> Axman6, that's what I'm getting at.
21:14:58 <dramforever> xj54y: how long have you been learning haskell?
21:15:00 <jle`> xj54y: can you show what the "longhand" would be? :)
21:15:04 <jle`> if you want the shorthand
21:15:12 <jle`> how would you write out what you wanted in longhand?
21:15:31 <xj54y> jle that's not the right question
21:15:45 <xj54y> I've got it though. Thanks :-)
21:15:57 <dramforever> hmm...
21:16:05 <jle`> ah.  well, if we had what you wanted to write in haskell, it would be straightforward to say how to write it shorter :)
21:16:36 <jle`> unless the issue was how to write it at all, long or short
21:16:39 <xj54y> Context matters, but I appreciate your suggestion
21:17:28 <mmercer> @src when
21:17:28 <lambdabot> when p s = if p then s else return ()
21:17:31 <xj54y> dramforever, about 26 days now
21:18:15 <mmercer> use when and ship it!
21:18:36 <xj54y> a monadic bind is more practical
21:18:49 <xj54y> unless when is that? Hmm
21:19:01 * xj54y nods
21:19:16 <zipper> xj54y: Hey
21:19:40 <xj54y> zipper, hello
21:46:50 <lf94> I never thought about this but how do you create N items of a thing in Haskell?
21:46:59 <lf94> Like...I know you can do [1..10]
21:47:05 <lf94> But what about for more abstract types?
21:47:34 <mmercer> :t \x y -> [x..y]
21:47:35 <lambdabot> Enum t => t -> t -> [t]
21:47:36 <jle`> you can create 10 of the same thing with replicate 10
21:47:41 <dmj`> @src replicate 
21:47:41 <lambdabot> Source not found. My mind is going. I can feel it.
21:48:06 <dramforever> lf94: how abstract?
21:48:10 <mmercer> > ['a'..'z']
21:48:11 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
21:48:16 <mmercer> [..] works with any Enum
21:48:25 <jle`> you can generate 10 random things with an Arbitrary instance or a Random instance from their respective libraries, maybe
21:48:35 <jle`> but you'll have to define the method of creating the items from a seed
21:48:50 <dramforever> you can you can write them out: [a1, a2, a3]
21:48:53 <lf94> Well...lets say I wanted to generate 50 "Apple" data?
21:49:01 <jle`> you can define [x..] for a type with an Enum instance, so you can do like take 10 [x..]
21:49:06 <dramforever> what does generate mean?
21:49:08 <jle`> lf94: what is Apple data?
21:49:09 <mmercer> replicate 50 apple
21:49:13 <jle`> > replicate 50 "Apple"
21:49:15 <lambdabot>  ["Apple","Apple","Apple","Apple","Apple","Apple","Apple","Apple","Apple","Ap...
21:49:46 <lf94> heh
21:49:47 <funfunctor> JSON recursive scope is really really confusing while parsing
21:49:57 <funfunctor> this is literally doing my head in..
21:50:36 <lf94> I guess you guys want me to be really explicit here
21:50:43 <dramforever> yeah exactly
21:50:46 <lf94> data Fruit = Apple Int Int
21:50:57 <lf94> How do I make 50 Apples
21:51:06 <mmercer> replicate 50 (Apple 0 0)
21:51:12 <lf94> sick, awesome
21:51:18 <dramforever> hmm...
21:51:20 <jle`> you can make 50 random Apples if you give it an Arbitrary instance or a Random instance
21:51:31 <jle`> i think for some libraries it can actually make the instnace generically
21:51:35 <lf94> Yeah yeah, but I was wondering if there was some off-hand way to do it, like mmercer shows
21:51:35 <jle`> so it can auto-derive the instance for you
21:51:47 <dramforever> lf94: so you didn't get it when we said replicate 50 "Apple"
21:51:53 <lf94> Like, in an imperative language, you'd use a for(;;) loop.
21:52:01 <dramforever> lf94: to do what?
21:52:04 <lf94> Then I thought, how the heck does Haskell do it?
21:52:12 <lf94> To create N instances of something
21:52:16 <dramforever> recursion
21:52:19 <jle`> if you want 50 of the same thing, you can use replicate
21:52:28 <jle`> if you want 50 different things based on like an index, you can use map
21:52:30 <mmercer> @src replicate
21:52:31 <lambdabot> replicate n x = take n (repeat x)
21:52:37 <mmercer> @src repeat
21:52:37 <lambdabot> repeat x = xs where xs = x : xs
21:52:40 <dramforever> lf94: recursion looks more general than loops
21:52:47 <jle`> for example, if i wanted to make something like for(int i = 0; i < 50; i++) { make something i }
21:52:55 <jle`> you can do map (\i -> something with i) [0..49]
21:52:58 <lf94> Well if I wanted Apple to be..Apple 1 0, Apple 2 0, Apple 3 0, yeah I'd use recursion here.
21:53:21 <dramforever> you don't have to because we have library functions
21:53:30 <mmercer> zipWith Apple [1..] (repeat 0) will create an infinite list of Apples
21:53:30 <dramforever> @let data Fruit = Apple Int Int
21:53:32 <lambdabot>  Defined.
21:53:41 <mmercer> zipWith2*
21:53:49 <dramforever> no
21:53:51 <lf94> jle`: wow that's even better :D
21:53:53 <dramforever> :t zipWith2
21:53:54 <lambdabot>     Not in scope: ‘zipWith2’
21:53:54 <lambdabot>     Perhaps you meant one of these:
21:53:54 <lambdabot>       ‘zipWith’ (imported from Data.List),
21:53:57 <dramforever> :t zipWith
21:53:58 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
21:54:15 <mmercer> > zipWith Apple [1..] (repeat 0)
21:54:16 <lambdabot>      No instance for (Show Fruit)
21:54:16 <lambdabot>        arising from a use of ‘show_M24696128141575863727879’
21:54:16 <lambdabot>      In the expression:
21:54:23 <mmercer> :t zipWith Apple [1..] (repeat 0)
21:54:24 <lambdabot> [Fruit]
21:54:29 <dramforever> @let deriving instance Show Fruit
21:54:30 <lambdabot>  Defined.
21:54:31 <mmercer> yeah
21:54:35 <mmercer> > zipWith Apple [1..] (repeat 0)
21:54:36 <dramforever> > zipWith Apple [1..] (repeat 0)
21:54:37 <lambdabot>  [Apple 1 0,Apple 2 0,Apple 3 0,Apple 4 0,Apple 5 0,Apple 6 0,Apple 7 0,Apple...
21:54:38 <lambdabot>  [Apple 1 0,Apple 2 0,Apple 3 0,Apple 4 0,Apple 5 0,Apple 6 0,Apple 7 0,Apple...
21:54:56 <jle`> um
21:55:03 <jle`> > map (`Apple` 0) [1..]
21:55:05 <lambdabot>  [Apple 1 0,Apple 2 0,Apple 3 0,Apple 4 0,Apple 5 0,Apple 6 0,Apple 7 0,Apple...
21:55:26 <jle`> zipWith and repeat is a little redundent, heh
21:55:34 <dramforever> lf94: we haskell people likes playing with newbie-ish questions
21:55:43 <dramforever> *like
21:55:47 <cita> > zipWith Banana [1..] (repeat 0)
21:55:49 <lambdabot>  Not in scope: data constructor ‘Banana’
21:55:58 <dramforever> don't worry if you can't understand them, you will some day
21:55:59 <cita> :O
21:56:08 <pavonia> > [ Apple i 0 | i <- [0..49] ]
21:56:09 <lambdabot>  [Apple 0 0,Apple 1 0,Apple 2 0,Apple 3 0,Apple 4 0,Apple 5 0,Apple 6 0,Apple...
21:56:25 <mmercer> every newbie takes us back to when we first started.. and we get to reexperience the whole "whoa" feeling
21:56:36 <dramforever> yeah because that's what haskell is
21:57:02 <funfunctor> Why can't aeson derive for me the types given some JSON input?
21:57:16 <funfunctor> It seems to me that it should be possible to generate the types from the internal AST
22:00:10 <dramforever> wow whoa, I just saw this:
22:00:12 <dramforever> :t upon
22:00:13 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
22:00:21 <dramforever> check the docs for whoa
22:00:35 <dramforever> Data.Data.Lens.upon
22:12:08 <funfunctor> :i upon
22:15:05 <slack1256> @info upon
22:15:05 <lambdabot> upon
22:15:11 <slack1256> >:-(
22:16:04 <pacak> :t upon
22:16:05 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
22:16:12 <pacak> :k upon
22:16:13 <lambdabot> Not in scope: type variable ‘upon’
22:21:14 <funfunctor> why is Vertex a Int in http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Graph.html  ?? why not data Vertex a = Vertex a
22:22:03 <jle`> might be for convenience
22:23:07 <dramforever> funfunctor: why do yo think so?
22:23:16 <dramforever> I think type Vertex = Int
22:24:52 <funfunctor> dramforever: well I guess you could use the Int to index some other structure to lookup a String for example
22:25:09 <dramforever> dunno
22:25:14 <dramforever> :P
22:25:51 <funfunctor> I am fairly confused at the moment.. I have a graph theory problem but its tangled up with parsing json
22:26:50 <funfunctor> If I can just get a handle on how to deal with getting the json shit into haskell structures I can start to comprehend the graph theory aspects properly by having types
22:31:17 <mmercer> funfunctor so what is your question? 
22:34:18 <funfunctor> mmercer: (13:44:29) funfunctor: Hi, I am having issues groking this JSON to parse into a ADT, see   http://lpaste.net/7552662877203595264   and   http://lpaste.net/5563801124588224512
22:34:25 <funfunctor> note that i've made more of a mess since then..
22:35:49 <funfunctor> mmercer: updated mess here http://lpaste.net/2408864439827693568
22:45:01 <ronh> funfunctor you're more likely to get helped if you post a compilable source and also a description of the problem
22:46:04 <funfunctor> ronh: I can't post the whole thing and its unlikely to help.. my question is really just about getting the data structures right for marshelling that json
22:57:10 <cj3kim> funfunctor: quid pro quo, clarise
23:08:39 * hackagebot hashable 1.2.3.3 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.3.3 (JohanTibell)
23:17:55 <Will_Macavoy> Hello
23:33:40 * hackagebot egison 3.5.7 - Programming language with non-linear pattern-matching against non-free data  http://hackage.haskell.org/package/egison-3.5.7 (SatoshiEgi)
23:37:04 <Hijiri> Is there an existing generic thing of data Foo a b c = Foo a (b -> Either (Foo a b c) c)
23:37:40 <Hijiri> like how attoparsec has parsing continuations, except this one has some extra data exposed
23:38:42 <dramforever> that looks a bit like Automaton in the arrows package
23:39:02 <dramforever> except it's not a sum, it's a product
23:39:19 <dramforever> and there isn't an a, but I think StaticArrow would cover that
23:39:33 <dramforever> dunno if that's what you want
23:39:38 <dramforever> dunno if you understand it
23:39:42 <creichert> funfunctor: have you tried making records for those objects? http://artyom.me/aeson#records-and-json
23:39:43 <dramforever> Hijiri: ^
23:40:05 <Hijiri> what I'm trying to do is provide a continuationey interface to mapping over a structure
23:40:14 <Hijiri> Where the user might provide the result values
23:40:18 <funfunctor> creichert: um yea.. they are in the paste
23:40:39 <creichert> funfunctor: those just look like you parsed into Object
23:40:46 <Hijiri> So basically it presents an element, and has a continuation that takes the thing it should be mapped to
23:40:59 <funfunctor> creichert: isn't that what is meant to happen
23:41:12 <Hijiri> and then if it still has more things to map, it gives another continuation plus thing-to-be-mapped
23:41:20 <Hijiri> otherwise it gives the finished structure
23:41:39 <creichert> funfunctor: yes, but you can basically skip that step by making you're type an instance of the FromJSON (not sure what it is in hjson, Jsonable?)
23:41:43 <funfunctor> creichert: after hours I just made a huge mess and confused myself..
23:42:01 <creichert> so, when you "decode", you use you're type (creating an explicit annotation if you have to)
23:42:20 <funfunctor> creichert: don't worry about hjson.. I just (BS.pack $ show hjson)
23:42:33 <funfunctor> so get the ByteString which works fine..
23:42:39 <Hijiri> this looks like ContT Writer, maybe
23:42:45 <Hijiri> actually no
23:42:56 <creichert> funfunctor: from what I see, you are going to need a record as your outer "Object, with a field that's a List (destinationAddress :: String)
23:43:01 <funfunctor> creichert: yea but getting the cascade of embedded types right is tricky
23:43:02 <Hijiri> I'll take a look at Automaton
23:43:53 <funfunctor> creichert: actually, this is what I am trying to parse http://lpaste.net/135266
23:43:57 <creichert> funfunctor: start from the outside or the inside with a simple record, data MyRecord = MyRecord { destinationAddress :: [String], originAddress :: [String] }
23:44:37 <creichert> funfunctor:so, you start by making a type (record) that describes thta, for each nested object, you have a nested record, if you will.
23:44:38 <funfunctor> creichert: I've been trying.... I keep getting     Left "Failed reading: satisfy"
23:44:57 <funfunctor> creichert: yep I totally understand the concept
23:45:05 <funfunctor> That's not the issue here
23:45:11 <creichert> then you need to show you're FromJSON instance because that is where the mistake is
23:45:31 <creichert> that raw parsed object only tells us it's a valid incoming object
23:45:48 <funfunctor> ok this is the bit I get lost with..
23:47:28 <jgoux> Hello
23:47:40 <funfunctor> creichert: i've literally lost myself.. http://lpaste.net/6034463913129541632
23:47:46 <jgoux> Does anyone use Stack for project building ?
23:48:12 <funfunctor> jgoux: I believe its more or less identical to cabal if I am not mistaken
23:48:45 <creichert> funfunctor:that's close, the immedia problem that jumps out is that origin_addresses and destination_addresses are parsed aas single item lists
23:49:08 <creichert> describe them as [String] first, or as (Maybe String) and use listToMaybe in the parser
23:49:14 <funfunctor> creichert: yea note that I put XXX by them
23:49:39 <funfunctor> ok [String] will let me go hard and fast with it?
23:51:30 <funfunctor> still this useless    Left "Failed reading: satisfy"   with zero clue what is happening under the hood
23:53:38 <Zemyla> Okay, I'm trying to figure something out.
23:55:01 <Zemyla> If m is both a Monad and a Comonad, then it must be an Applicative, which also means it should be a ComonadApply. So does this give any rules about what relation the Monad and Comonad instances have with each other?
23:55:12 <creichert> funfunctor: Have you tried breaking it down and using the repl to test smaller components?
23:55:22 <edwardk> zemyla: not necessarily
23:55:44 <edwardk> ComonadApply carries a law with respect to 'extract' for (<@>) which isn't guaranteed by 'just being a monad'
23:55:58 <funfunctor> creichert: yes of course ! i've spent 5 hours on it..
23:56:46 <Zemyla> Hmm. So something that's a Monad and a Comonad isn't necessarily a ComonadApply?
23:56:53 <edwardk> correct
23:57:06 <edwardk> its a set of laws you have to check
23:57:40 <edwardk> (.) <$> u <@> v <@> w = u <@> (v <@> w) -- is the same as the applicative associativity law, thats easy
23:57:43 <edwardk> extract (p <@> q) = extract p (extract q)
23:57:46 <edwardk> that one is new
23:57:52 <edwardk> duplicate (p <@> q) = (<@>) <$> duplicate p <@> duplicate q -- that one is also new
23:58:18 <edwardk> between the two of those they require the applicative to be 'symmetric'
23:58:34 <edwardk> er the (<@>)  operation
23:58:47 <Zemyla> Are there any Functors that are both Monads and Comonads, but aren't ComonadApplys?
23:58:49 <edwardk> its a 'strong lax semimonoidal comonad' as uustalu put it
23:59:49 <edwardk> Zemyla: nothing rules them out.
