00:07:37 * hackagebot rosa 0.2.1.0 - Query the namecoin blockchain  http://hackage.haskell.org/package/rosa-0.2.1.0 (rnhmjoj)
00:07:37 * hackagebot yesod-bin 1.4.11 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.11 (MichaelSnoyman)
00:08:12 <gamegoblin> If I am writing tests for my library, do I have to export the stuff I want to test from the library?
00:08:26 <gamegoblin> Or can I expose certain things to the tests but not to the library consumers
00:09:53 <mattby> gamegoblin: you can export them in an Internal module
00:10:19 <gamegoblin> mattby: so they’ll still be visible, but the name will imply "do not use" ?
00:10:22 <mattby> so you make it explicit that it's internal and shouldn't be used by a user of your lib but you can still test it or use it from outside
00:10:28 <mattby> yes
00:10:37 <mattby> I think that's a pretty common practice
00:10:52 <gamegoblin> Wish there were a better way
00:11:01 <gamegoblin> similar to Java’s package private or something
00:17:34 <supki> gamegoblin: you can use the CPP to export different things to different build targets
00:24:15 <gamegoblin> When I try to run my test suite I get some insane error messages like 
00:24:16 <fffej> hi, I've implemented Arbitrary on one of my types and I'd like to write a function that generates a predictable random value (e.g. like arbitrary but seeded).  I'm a bit stuck.  I think I need to use Test.QuickCheck.Gen.unGen, but can't work out how.  Any pointers much appreciated
00:24:17 <gamegoblin> [1 of 1] Compiling Main             ( dist/build/test-grantslatton-serverStub/test-grantslatton-serverStub-tmp/test-grantslatton-serverStub.hs, dist/build/test-grantslatton-serverStub/test-grantslatton-serverStub-tmp/Main.o )
00:24:18 <gamegoblin> Linking dist/build/test-grantslatton-serverStub/test-grantslatton-serverStub ...
00:24:19 <gamegoblin> dist/build/test-grantslatton-serverStub/test-grantslatton-serverStub-tmp/Main.o:(.text+0x21): undefined reference to `testzmgrantslattonzmserverzm0zi1zi0zi0_GrantSlattonziServerziInternalziByteChannelziTest_tests1_closure'
00:24:31 <gamegoblin> It looks like some sort of linking problem?
00:24:36 <gamegoblin> Anyone seen something like this?
00:24:59 <fffej> @gamegoblin: Have you exposed that package from your library?
00:24:59 <lambdabot> Unknown command, try @list
00:25:05 <adarqui> make sure all of ur libs are exported in ur cabal file, in exposed-modules for example
00:25:11 <adarqui> gamegoblin: ^
00:25:14 <dramforever> fffej: address people like this
00:25:22 <gamegoblin> I am exposing everything
00:25:25 <fffej> darmforever: thanks, force of habit from Slack
00:25:28 <dramforever> gamegoblin: btw you can actually read that msg
00:25:44 <dramforever> zm = "-", zi = "."
00:26:09 <gamegoblin> fffej: I am exposing all the modules from the library
00:28:35 <gamegoblin> fffej: turns out it was that I forgot a module in the other-modules of the test-suite part of the .cabal file, not the actual library part
00:29:40 <dramforever> gamegoblin: :) glad you solved it
00:39:47 <slaterr> in acid-state do you have all the previous generations of acid object available?
00:40:38 <slaterr> also what do you think about acid-state vs persistent?
00:51:12 <zomg> I seem to recall there was some fancy word for when `z == x(y(z))`, ie. when you have a function that transforms a value, and another that transforms it back... was there a word for that, or am I just imagining things?
00:52:41 <bernalex> zomg: do you mean isomorphic?
00:52:42 <dramforever> zomg: inverse?
00:52:59 <dramforever> x is the inverse (maybe it's called left inverse) of y
00:53:50 <zomg> thanks, one of those is the right one for this case I think =)
00:54:28 * dramforever is installing lens again....
00:55:01 <zomg> doing some pixel <-> em conversion code and obviously if you run toPx(toEm(pixels)) the result should be pixels
00:55:20 <dramforever> zomg: well do you know lens?
00:55:25 <zomg> yeah
00:55:38 <dramforever> lens has isomorphisms
00:55:54 <dramforever> it does look like there's an iso between pixles and em
00:56:25 <zomg> technically this requires a "base font size" in this instance to be the same for both conversions, but we don't really care about it so we're just using a hardcoded value
00:57:04 <arw> dramforever: depends. if you consider em to be continuous and pixels to be discrete, there isn't.
00:57:17 <bernalex> zomg: isomorphism means "equal shape". it's for a bijection f where f and its inverse are homomorphisms (which means "same shape" -> shape preserving). so an isomorphism is just a morphism that has an inverse. the composition of the morphism and its inverse gives an identy morphism.
00:57:54 <dramforever> hi, does anyone know where is Text.HTML.DOM?
00:57:55 <arw> dramforever: and even if both are discrete the conversion usually isn't isomorphic
00:58:02 <dramforever> arw: okay
00:58:29 <dramforever> but it seems that zomg thinks x = toPixels (toEm x)
00:59:23 <dramforever> oh found it, it's in html-conduit
00:59:38 <zomg> bernalex: I *think* I get what you said :P I'm considering just using "inverse" so I don't have to explain isomorphism to the rest of our team who know even less about that stuff than I do :D
01:00:19 <dramforever> zomg: I like "lossless conversion"
01:00:31 <dramforever> maybe "lossless encoding"
01:00:45 <bernalex> zomg: g is an inverse to f if forall x. f(x) = y ==> g(y) = x. written f¯¹.
01:01:07 <dramforever> bernalex: it seems so
01:02:11 <zomg> bernalex: this seems like one of those things that could be QuickChecked :) wonder if it's about time to give that JavaScript version of it a spin
01:06:37 <arw> zomg: problem is, quickchecking will probably fail. even if both values are floats, rounding errors might cause the equation to deviate.
01:07:37 <arw> zomg: so if you really want to quickcheck it, check DELTA > abs(y - f(g(y))) for a sufficiently small DELTA
01:09:39 <zomg> Yeah :) thanks for the tip
01:16:02 <Gurkenglas> That last criterion sounds more like Lipschitz continuity
01:16:51 <arw> Gurkenglas: you would need an epsilon for that :)
01:17:42 <ThreeOfEight> Alternative: use Rational instead of floats, if possible
01:17:51 <ThreeOfEight> then you have no rounding errors
01:18:04 <ThreeOfEight> but there are some operations that don't work on Rationals (sqrt, sin, exp)
01:18:22 <tdammers> rationals also have quirky performance characteristics
01:18:35 <tdammers> not as bad as Scientific though
01:18:42 <ThreeOfEight> and quickchecking Rationals will not detect numerical problems
01:19:34 <ThreeOfEight> I do like the constructible reals package; it's great for geometric computations
01:20:18 <ThreeOfEight> I once considered building a Haskell package for exact computations on arithmetic real numbers using Sturm sequences, but never found the time
01:21:45 * dramforever is cross compiling to windows on a linux box
01:21:47 <dramforever> using wine
01:42:36 * hackagebot etcd 1.0.5 - Client for etcd, a highly-available key value store  http://hackage.haskell.org/package/etcd-1.0.5 (wereHamster)
02:18:21 <merijn> hmmm, is there some easy way to call into/interact with C++ code from haskell?
02:19:11 <Freundlich> merijn: No, the FFI is very limited in what it can do. Only a subset of C works.
02:19:51 <merijn> Freundlich: I know the limits of the FFI, but there's things like the "inline C" TH library
02:19:57 <merijn> I wonder if there's something similar for C++
02:21:44 <merijn> Freundlich: see https://github.com/fpco/inline-c/blob/master/README.md
02:22:49 <Freundlich> Hm, that's interesting.
02:30:27 <merijn> hmmm, fficxx looks like it could be useful, if it had any documentation :p
02:31:13 <tdammers> merijn: so, like 95% of hackage?
02:31:52 <rhaps0dy> lol
02:32:24 <merijn> tdammers: Naah, 95% of hackage is good enough for me to understand
02:32:44 <merijn> This requires me to write a program which will generate bindings, but doesn't explain the workflow for that :\
02:38:34 <rhaps0dy> please, stop using custom setup ;_;
02:38:39 <bernalex> merijn: facebook made their own intermediary stuff for c++ -- maybe ask simonm?
02:38:57 <rhaps0dy> ekmett: pls
02:39:29 <merijn> bernalex: He rarely hangs around on IRC though and I don't have his email, is that stuff even open source?
02:39:32 <tdammers> the 21st century solution to cross-platform development shenanigans:
02:39:40 <tdammers> "here's a docker image you can use to develop in"
02:39:52 <bernalex> merijn: most of what he did for facebook is free software. I have his email address, if you want it.
02:39:52 <rhaps0dy> yeah lol
02:40:38 <bernalex> merijn: hmmm, «Haskell's FFI is designed to call C rather than C++, so calling C++ requires an intermediate C layer. In most cases, we were able to avoid the intermediate C layer by using a compile-time tool that demangles C++ function names so they can be called directly from Haskell.»
02:41:41 <merijn> bernalex: I don't particularly care about indirection, I just have a C++ data structure I need to interact with and porting it to Haskell is...a lot of work
02:42:02 <merijn> So I basically want some way to interact with this structure in the way that requires me to write the least amount of code :)
02:42:18 <merijn> Alternatively I'll just write the rest of the application code in C++
02:42:23 <bernalex> merijn: well for everything low level, simonm & dons are your goto experts, I'd say, heh.
02:42:34 <bernalex> and I guess bos
02:42:38 <rhaps0dy> merijn: as a temporary solution
02:42:44 <rhaps0dy> you could compile the C++ 
02:42:49 <rhaps0dy> then disassemble the output
02:42:52 <rhaps0dy> and look at the mangled function names
02:42:56 <rhaps0dy> and import them in the FFI
02:43:19 <rhaps0dy> then when you can reach simonm, ask him
02:43:19 <merijn> rhaps0dy: At that point it becomes less work to just write all my code in C++
02:43:23 <dramforever> merijn: maybe write C bindings for your C++?
02:43:28 <dramforever> *C++ code
02:43:28 <rhaps0dy> merijn: yeah, true
02:43:42 <rhaps0dy> the path of least resistance is to write everything in C++
02:43:42 <dramforever> I think wxhaskell did it
02:44:02 <merijn> dramforever: Too much work/inconvenient compared to how hard it'd be to write the other code in C++ too.
02:44:19 <bernalex> rhaps0dy: or rewrite everything in haskell. depending on the situation. :)
02:44:29 <dramforever> merijn: wait I remembered something called fficxx
02:44:49 <merijn> dramforever: I just mentioned that :p
02:45:05 <rhaps0dy> bernalex: not in this situation I think
02:45:07 <dramforever> merijn: how is that?
02:45:11 <merijn> dramforever: But there's no real docs on how to use it, beyond a single trivial example :)
02:45:27 <merijn> dramforever: So I'd have to reverse engineer what to do from: https://github.com/wavewave/fficxx/blob/master/fficxx/sample/mysample-generator/MySampleGen.hs
02:45:31 <rhaps0dy> what about
02:45:53 <rhaps0dy> what happens if you wrap all the C++ files in extern "C" { } ?
02:46:01 <rhaps0dy> ah, no, the result will still be mangled
02:46:25 <rhaps0dy> how many files do you have implementing that data structure, and how many functions operate on it?
02:46:25 <merijn> rhaps0dy: Plus I need to call functions on an object
02:46:36 <rhaps0dy> how many methods does it have? aprox
02:46:45 <rhaps0dy> ~20 ?
02:46:49 <rhaps0dy> no a bit too much
02:46:54 <dramforever> sigh...
02:46:56 <dramforever> c++ abi
02:47:55 <merijn> rhaps0dy: Actually zero, it has member variables that have a bunch of functions that get used. 5 functions in the member type, times 8 members is 40 functions that I'd have to wrap >.>
02:48:41 <rhaps0dy> so function pointers in the members ?
02:48:53 <rhaps0dy> wot
02:49:17 <rhaps0dy> merijn: if you use the FFI, you have to write boilerplate either way. c2hs makes it a bit less painful but eh.
02:49:28 <rhaps0dy> I still think copying the mangled names is worth a shot
02:49:33 <rhaps0dy> but if you just want to get it done, do it in C++
02:49:41 <merijn> rhaps0dy: No, members are classes with methods
02:49:53 <rhaps0dy> ah.
02:50:28 <merijn> Anyway, I'll just write it in C++ and see if I can implement the "Monoid a => Monoid (b -> a)" in C++ instead :p
02:50:42 <rhaps0dy> And C2hs would get confused because the headers include "class" and not struct, and you'd have to calculate offsets manually.
02:50:44 <rhaps0dy> lol, have fun
02:58:46 <rhaps0dy> Is there a way to know what the ExitFailure numbers mean when failing to install cabal libraries?
02:59:18 <merijn> rhaps0dy: Rerun with -v3
02:59:33 <dramforever> rhaps0dy: have you got anything other than 1 before?
03:00:14 <rhaps0dy> yes
03:00:18 <rhaps0dy> I have ExitFailure -11 now
03:00:47 <dramforever> whoa
03:00:51 <rhaps0dy> Loading package ghc-prim... Failed to install profunctors-5.1.1
03:01:11 <rhaps0dy> it's likely some cross-compiling quirk
03:01:13 <rhaps0dy> fml
03:01:14 <merijn> rhaps0dy: I don't think the code means anything, rerurn with maximum verbosity and see where it breaks
03:01:24 <rhaps0dy> merijn: I just did that
03:01:29 <rhaps0dy> and I still have no idea
03:01:30 <merijn> ah
03:02:45 <rhaps0dy> fails when it loads ghc-prim
03:04:03 <rhaps0dy> maybe... cabal tries to dynamically load ghc-prim but because it's compiled for ARM everything blows up?
03:04:18 <rhaps0dy> but why would it dynamically load libraries from the packagedb in the first place?
03:06:31 <rhaps0dy> guess I'll skip the high-level bindings to sdl
04:07:04 <webchat099> Hi, and sorry for this IO action
04:10:28 <rhaps0dy> hi
04:10:34 <rhaps0dy> which io action?
04:10:40 <kqr> the one of introducing yourself
04:10:47 <dramforever> webchat099: hi
04:17:57 <aloiscochard> does `stack` support caching of dependencies a la nix or I should rather keep my nix setup?
04:19:42 <meditans> aloiscochard: I'm not much of an expert but, as far as I understood, if you have already a package installed, it reuses it
04:20:06 <meditans> aloiscochard: however, it doesn't have caching like nixos, so the first time should be built from source
04:20:38 <meditans> (I use nix, and haven't tried stack)
04:21:40 <meditans> aloiscochard: also, for now I'm keeping the nix setup because ghc-mod and the other tools don't recognize a stack-only installation
04:23:20 <aloiscochard> meditans: thanks, make sense about having to compile the first time. I could live with that I suppose.
04:23:46 <aloiscochard> was curious, even if I don't plan to drop nix anyway (cause I'm able to install software with it that my distrib don't support...)
04:32:48 <meditans> aloiscochard: np
04:47:30 <pi3r> Is there a much simpler way for import qualified Crypto.Hash.MD5 as MD5
04:47:31 <pi3r> md5 :: Text -> Text
04:47:31 <pi3r> md5 = Text.pack . show . MD5.hash . Text.encodeUtf8
04:48:43 <chpatrick> pi3r: why not leave the hash as a bytestring?
04:49:09 <pi3r> Because I am using a lib that needs Text ...
04:49:16 <dramforever> pi3r: what about somthing like decodeUtf8
04:49:58 <tremon> does it needs utf8-encoded text or base64?
04:50:06 <pi3r> @dramforever I have tried it and get an exception when decoding
04:50:06 <lambdabot> Unknown command, try @list
04:50:23 <dramforever> pi3r: stop stop don't @me
04:50:31 <dramforever> pi3r: call people like this
04:53:29 <pi3r> chpatrick: I have Text as input and Text as output (no choice there)
04:53:39 <chpatrick> how about
04:53:40 <ttt_fff> someone needs to write a tool where the UI is in haskell, it parses an APL like language, then uses torch/tensors for a backend
04:53:41 <chpatrick> decodeUtf8 . digestToHexByteString . (hash :: ByteString -> Digest MD5) . encodeUtf8
04:57:49 * Fuuzetsu is now open for hire
04:59:02 <chpatrick> pi3r: or over utf8 (\bs -> digestToHexByteString $ (hash bs :: Digest MD5))
04:59:04 <chpatrick> if you like lens :)
04:59:41 <pi3r> chpatrick: ok I will try it thx
05:00:10 <chpatrick> :t utf8 %~ \bs -> digestToHexByteString (hash bs :: Digest MD5)
05:00:11 <lambdabot> Not in scope: ‘utf8’
05:00:11 <lambdabot> Not in scope: ‘digestToHexByteString’
05:00:11 <lambdabot>     Not in scope: ‘hash’
05:06:30 <ttt_fff> why can't haskell be as terse as APL
05:06:33 <ttt_fff> is it due ot typing ?
05:06:47 <ttt_fff> is it because in APL, there's only one type -- 1/2/3-d matrix of numbers
05:06:52 <ttt_fff> whereas haskkell has user defined types ?
05:07:30 <aloiscochard> or maybe it's because it would then be unreadable? ;)
05:07:31 <lieven> ttt_fff: I don't think so. replace most primitives by one glyph unicode characters and haskell would be about as succinct as APL
05:07:57 <ttt_fff> lieven: K/J are both ascii-only, yet they're both much more terse than Haskell
05:10:09 <chpatrick> is terseness really always good?
05:10:39 <chpatrick> I think haskell is the best language I know in terms of being easy to understand other people's code
05:10:50 <ttt_fff> not necessairly, but I'd like it to be possible
05:10:50 <dramforever> chpatrick: good thing is that non-haskellers can also understand quite a bit of haskell
05:11:08 <chpatrick> it's relatively englishy and the amount of context for each function is quite small
05:11:31 <chpatrick> yeah I've done successful job interviews in haskell where the interviewer didn't know it :D
05:13:52 <kuribas> Is it possible to get a stack trace with an exception?
05:14:08 <frerich> Are you guys using the terms 'terse', 'succinct', 'concise', 'compact' and 'readable' interchangably here?
05:14:09 <kuribas> (a vector index out of bounds exception)
05:14:14 <chpatrick> kuribas: unfortunately the stack doesn't make too much sense in haskell
05:14:24 <chpatrick> because you don't know when stuff is getting evaluated
05:14:40 <kuribas> ah true.
05:14:54 <chpatrick> there's some experimental support I think
05:14:54 <dramforever> kuribas: I think yes, you need to turn on scc or something
05:14:56 <chpatrick> I know the guy that made it
05:14:59 <dramforever> -xc
05:15:13 <kuribas> I'd like to know which invocation of Vector.! is throwing the exception.
05:15:15 <chpatrick> https://hackage.haskell.org/package/base-4.7.0.2/docs/GHC-Stack.html
05:15:16 <chpatrick> I guess
05:17:43 <webchat099> ghci has traces. you can step back from the error and inspect the varables
05:19:06 <ttt_fff> is there a linting tool in ghc to find dead code
05:19:17 <ttt_fff> i.e. types / funcs that are not used at all by any function called by main :: IO () ?
05:19:24 <kuribas> ah :set -fbreak-on-exception  :-)
05:20:12 <frerich> ttt_fff: ghc itself will tell you if you compile with '-Wall'
05:22:45 * hackagebot geojson 1.3.0 - A thin GeoJSON Layer above the aeson library  http://hackage.haskell.org/package/geojson-1.3.0 (domdere)
05:23:38 <kuribas> only ghci gives me: no more logged breakpoints
05:25:34 <kuribas> Ah, I need :trace expression
05:27:17 <exio4> is there any library that would allow me to have a Map (and/or Set), with things like total lookup functions (Map .. a -> a)? I mostly want to separate the whole code handling corner cases to the irc library, and only give the game logic things which I can know that will be in the map, (so the idea was that I should be able to "check" if something's there, getting a proof that the element is in the map, and
05:27:19 <exio4> then use that proof for the lookup?)
05:30:41 <geekosaur> isn't the best proof that something is in the map... the thing itself?
05:32:19 <frerich> exio4: That question is a bit too generic to me. Can you give a representative code sketch (or maybe even the real thing modulo the irrelevant stuff) on lpaste?
05:33:14 <merijn> exio4: What's wrong with
05:33:18 <merijn> :t (M.!)
05:33:19 <lambdabot> Ord k => M.Map k a -> k -> a
05:33:21 <chpatrick> man I forgot how nice the haskell community is
05:33:35 <chpatrick> I just got a reminder when I went to the C++ channel :D
05:34:42 <chpatrick> exio4: it almost sounds like some kind of ref/var
05:35:41 <exio4> geekosaur: hm, the idea was a Map because it'd be keeping the Account -> UID information, to which I can pretty much "just add" and "just lookup" elements, wanted to avoid partial functions (that way, I'd also need to make sure the element is there)
05:35:46 <exio4> frerich: I'll try
05:36:01 <exio4> merijn: I wanted the type system to force me to make sure the element is in the map, just that :P 
05:36:11 <chpatrick> exio4: then you'd never be able to delete right?
05:36:23 <merijn> exio4: not worth the effort in haskell
05:36:24 <chpatrick> since it would invalidate the proof
05:36:48 <chpatrick> unless the proof is what keeps it in the map
05:36:54 <geekosaur> again, I see no way that that proof differs from just carrying around the UID
05:37:33 <c_wraith> exio4: I'm with geekosaur.  What you want to do seems to be identical to just calling lookup.
05:39:20 <exio4> hm, I think you are right, I'll just pass the values if they were found 
05:39:28 <kuribas> exio4: you want a proof in the type?
05:41:12 <exio4> kuribas: yes, I can't think of a type signature in Haskell though 
05:41:42 <dramforever> exio4: key exists <=> value exists for key
05:41:50 <exio4> dramforever: the key is a value
05:42:00 <dramforever> wow wait a sec
05:42:02 <chpatrick> if you're passing around the proof, why not just pass around the value?
05:42:12 <chpatrick> unless it can change over time
05:42:51 <kuribas> Then you have a state monad.
05:45:36 <exio4> chpatrick: I am currently passing the nicks around, so I'll just add the UIDs, yeah 
06:00:13 <Absolute0> What sort of challenges can I expect to see when starting web programming using haskell? Does it even make sense to use haskell?
06:01:06 <Absolute0> I am about to start a personal side web project and I am deciding between golang (has a web framework built-in) and haskell (will probably go with yesod). Why would someone pick haskell over go in such a scenario?
06:01:43 <Absolute0> If a web app is mostly io (db and template rendering), what will I be gaining by using haskell?
06:03:32 <Absolute0> You can't argue for compile-time type checking since golang is a compiled language as well.
06:03:42 <exio4> Absolute0: most libraries offer "enhanced" things, enforced by the type system, letting you avoid things like XSS / SQL injection / etc entirely 
06:03:55 <exio4> Absolute0: Go's type system is a bit of a joke, it doesn't even let you do generics 
06:04:19 <tdammers> just because Go has types doesn't meant they are as useful or powerful as Haskell's
06:04:21 <Absolute0> exio4: how often do you actually need generics?
06:04:49 <exio4> Absolute0: for pretty much 80% of what I am coding right now :) 
06:04:55 <tdammers> Absolute0: even if you don't need to use them yourself, having them in your language tends to make for better libraries
06:05:10 <Absolute0> you can always do interface{}
06:05:15 <tdammers> Absolute0: generics, or some other feature that gives you type-safe polymorphism
06:05:19 <frerich> Absolute0: Haskell's type system is considerably more expressive than the type system of Go, from what I've been told (I don't know Go very well). As a consequence, there is a larger class of things which the compiler can check for you should you choose to make use of the type system.
06:07:10 <Absolute0> I guess I would need to make a project in each and decide for myself
06:07:21 <Absolute0> I wrote a simple chess game in haskell a while ago
06:07:25 <Absolute0> and never touched haskell since
06:07:47 <geekosaur> even that wouldn't necessarily prove anything; some of the benefits will come from easier maintenance and modification
06:08:04 <geekosaur> even, many of them
06:08:27 <tdammers> also, haskell tends to become a lot more useful the more proficient you become
06:09:14 <tdammers> most other languages I've learned, the bang-for-bucks shelves off after a few months of learning - you cover the basics, develop a bit of experience, learn the go-to libraries, and after that, you hit a ceiling
06:09:20 <bernalex> Absolute0: I use haskell for web programming professionally.
06:09:25 <tdammers> but with Haskell, I haven't quite found the ceiling yet\
06:10:14 <tdammers> (and for the record, Haskell would be my first choice for web programming if only I had the time to teach my colleagues and have the whole team do nothing directly productive for a few months)
06:10:37 <moop> @lyah
06:10:37 <lambdabot> Unknown command, try @list
06:10:40 <moop> @list
06:10:40 <lambdabot> What module?  Try @listmodules for some ideas.
06:10:43 <moop> hm
06:10:46 <moop> >lyah
06:10:51 <bernalex> @where LYAH
06:10:51 <lambdabot> http://www.learnyouahaskell.com/
06:10:55 <moop> yee
06:11:02 <moop> is lyah still good for learning haskell?
06:11:04 <free_beard> tdammers: what would you recommend for starting with web programming? Yesod?
06:11:16 <bernalex> moop: some would say yes, some would say no. I would say try it and see if you like it.
06:11:18 <free_beard> tdammers: I'm at the level of having completed cis194
06:11:25 <geekosaur> @where learn-haskell
06:11:25 <lambdabot> I know nothing about learn-haskell.
06:11:30 <geekosaur> whoops
06:11:38 <moop> @where learn
06:11:38 <lambdabot> https://github.com/bitemyapp/learnhaskell | http://www.seas.upenn.edu/%7Ecis194/spring13/index.html | https://github.com/NICTA/course/
06:11:39 <bernalex> @where learnhaskell
06:11:39 <lambdabot> https://github.com/bitemyapp/learnhaskell
06:11:58 <bernalex> free_beard: I would recommend scotty personally. but generally you should just look around at what interests you and suits your needs.
06:12:36 <free_beard> bernalex: thanks, I was looking at scotty the other day and seems simpler to setup (than Yesod)
06:12:57 <bernalex> free_beard: oh it's ridiculously much easier to set up. it does very little compared to yesod. though tdammers would claim it does too much.
06:12:58 <free_beard> bernalex: I'm trying to transition my python experience with pyramid and flask 
06:12:58 <Flonk> Can I run ghci with some flags or somehthing so it will automatically do a couple of imports and :set the prompt?
06:13:01 <Flonk> (windows)
06:13:16 <bernalex> Flonk: scotty is kind of like sinatra in ruby, if you know it.
06:13:29 <bernalex> sorry, free_beard ^
06:13:33 <frerich> Flonk: Yes, in the '.ghc' directory you can create a 'ghci.conf' file.
06:13:36 <free_beard> bernalex: never tried ruby :)
06:13:46 <Flonk> frerich: oh, neat!
06:13:49 <Flonk> Thanks a bunch
06:14:27 <frerich> Flonk: Most importantly, it should contain ':set prompt "λ: "', it's a law.
06:14:33 <maerwald> Absolute0: well, go is driven by google and for _practical_ purposes, so I dare say that there either will be more powerful web libraries/frameworks or are already... that's not really a good argument to me to prefer it though. But it might be one for others. Then again... haskell is predestined to be used for cool DSLs and web programming in haskell is also cool.
06:14:38 <bernalex> frerich is right.
06:15:14 <bernalex> free_beard: I have not used flask, only vaguely looked at it. I would still suggest starting out with scotty since it's so simple.
06:15:15 <Flonk> frerich: I prefer "λ> " :P
06:15:42 <bernalex> I have simply :set prompt "λ "
06:15:50 <free_beard> bernalex: thanks!
06:16:28 <bernalex> maerwald: I'm not convinced there are more powerful Web libraries or frameworks in go.
06:17:02 <bernalex> clojure or python would be a much better choice than go imo.
06:17:08 <Absolute0> maerwald: what do you mean by "cool dsl"?
06:17:22 <chpatrick> I think haskell is really nice for web stuff if it's just serving json
06:17:40 <chpatrick> and you do all the heavy lifting client side
06:17:50 <bernalex> chpatrick: I use it to serve other things, and do everything server side
06:17:52 <Absolute0> I actually just need to serve json
06:17:59 <chpatrick> Absolute0: scotty is nice for that
06:18:04 <Absolute0> I just jumped on the react/angular bandwagon
06:18:13 <Absolute0> so all frontend will be generated by html/js
06:18:20 <Absolute0> what about yesod?
06:18:37 <chpatrick> yesod is really big though
06:18:50 <maerwald> bernalex: I said "there either are or will be in the future"
06:18:51 <bernalex> Absolute0: jump on the elm bandwagon instead of react, and you can have purely functional frontend programming too. very fast as well.
06:18:51 <chpatrick> if you're not doing any templating then the web server is really just an interface to your actual logic right?
06:18:54 <Absolute0> the commands make it feel like rails
06:19:01 <Absolute0> chpatrick: correct.
06:19:05 <chpatrick> so it doesn't have to be complicated
06:19:07 <chpatrick> I like scotty for that
06:19:10 <bernalex> maerwald: there aren't afaict, and I don't very much assume it will be.
06:19:10 <Absolute0> chpatrick: but it needs to interact easily with the db layer
06:19:16 <maerwald> Absolute0: you know what a DSL is?
06:19:35 <bernalex> Absolute0: scotty is your friend. look at persistent too if you need db stuff.
06:19:46 <chpatrick> the only downside is the docs aren't too great for scotty, you need to read the sinatra docs
06:19:53 <Absolute0> maerwald: I keep hearing that accronym but google gives me wrong answers...
06:19:54 <bernalex> you do?
06:19:54 <maerwald> so with haskell you can get very nice abstraction and don't deal with the low level details... if the library maintainer cares about it
06:20:00 <chpatrick> domain specific language
06:20:11 <bernalex> chpatrick: I have never ever looked at the sinatra docs, and I have written a lot of scotty stuff by now.
06:20:11 <Absolute0> ah
06:20:23 <chpatrick> it's pretty easy to use
06:20:39 <bernalex> once you figure out the very basic structure, the typesigs are all you need imo. it's quite intuitive.
06:21:49 <Absolute0> I hate it when all the hip frameworks compare themselves to sinatra instead of flask
06:21:53 <Absolute0> it's very biased
06:22:23 <bernalex> scotty was made essentially to be sinatra with warp.
06:22:27 <kuribas> I am using Data.Vector to get close to C performance, but hiding it from the API user.
06:24:20 <tdammers> also, of the few things that scotty adds to warp/WAI, 50% is good and 50% gets in your way eventually
06:25:17 <bernalex> I still haven't hit that in any of the programs I've written using scotty fwiw. I don't mean that I don't believe in such thresholds though. but merely that I haven't encountered them.
06:26:00 <tdammers> well, the one thing that slightly bugs me with scotty is how there is a strict distinction between pre-route and post-route things
06:26:15 <exio4> Absolute0: for JSON, Aeson is really nice! 
06:26:16 <tdammers> i.e., an "Action" is not the same as "Scotty"
06:26:27 <tdammers> which prevents multi-pass routing
06:26:55 <tdammers> I prefer having just an Application, which may or may not do some routing and then forward things to other Applications
06:27:13 <tdammers> feels like a better model than the somewhat artificial distinction Scotty has
06:28:16 <Absolute0> What's the best place to get a good grasp of monads?
06:29:42 <tdammers> Absolute0: using them
06:29:48 <Absolute0> right...
06:29:53 <tdammers> I'm serious
06:30:03 <tdammers> there is nothing magical about monads
06:30:08 <tdammers> there is even surprisingly little to grasp
06:30:16 <tdammers> a monad is just another type
06:30:29 <tdammers> the only "magic" is how Haskell provides a bit of syntax sugar for them
06:30:30 <Absolute0> a container type accroding to LYAH
06:30:34 <bernalex> Absolute0: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
06:30:39 <tdammers> yeah, but no, not really
06:31:01 <Absolute0> I need to drink the kool-aid already
06:31:04 <tdammers> http://www.stephendiehl.com/what/
06:31:17 <tdammers> ^ this one has some very good tips on the whole "how do I learn monads" thing
06:31:30 <tdammers> http://www.stephendiehl.com/what/#eightfold-path-to-monad-satori
06:32:05 <tdammers> particularly, I think the "container" metaphor isn't very helpful at all
06:32:19 <bartavelle> Absolute0, just use them, or implement a few of them (see https://github.com/NICTA/course there is a monad part)
06:32:28 <tdammers> a monad doesn't "contain" a value anymore than a List does
06:33:24 <bernalex> :t (>>=)
06:33:25 <tdammers> also, learn to desugar by hand
06:33:26 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:33:27 <bernalex> :t return
06:33:28 <lambdabot> Monad m => a -> m a
06:33:31 <bernalex> ^ that's monads. that's it.
06:33:37 <tdammers> bernalex: that, and the laws
06:33:39 <tdammers> but yes
06:33:49 <dibblego> that tutorial is bad
06:34:08 <bernalex> dibblego: which one?
06:34:23 <bernalex> I think the one I posted is very good
06:34:26 <dibblego> http://www.stephendiehl.com/what/
06:34:36 <tdammers> dibblego: what's bad about it?
06:34:39 <bernalex> oh that one.
06:34:42 <bernalex> I also quite like http://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/
06:34:56 <tdammers> (apart from spelling and grammar and sloppy editing, that is)
06:35:10 <Absolute0> bookmarked all the above links
06:35:10 <Absolute0> thanks
06:35:12 <dibblego> the banging on about lenses, clearly without understanding, and when there was an effort to correct the points, it was ignored.
06:35:44 <tdammers> oh, I thought you meant the monads part
06:35:53 <dibblego> https://github.com/sdiehl/wiwinwlh/issues/67
06:36:25 <tdammers> the lens part, I agree, looks pretty stubborn
06:47:27 <bernalex> Network.Socket.ByteString provides functions for sending multiple data segments as if concatenated. but what do I do when I have too much data (encoded by cereal) and need to send it in parts?
07:10:46 <bartavelle> bernalex, what do you mean by "need to send it in parts" ?
07:11:40 <bernalex> bartavelle: well I have something that's a bit big-ish that gets encoded by cereal. it will be too big for an UDP packet. what do I do?
07:12:01 <bernalex> bartavelle: my other solution, which I have considered, is to optimise the serialize instance rather than just derive it. but IDK how long that will scale.
07:12:45 <bartavelle> ah, UDP, never think about that one ;)
07:13:15 <bernalex> it's rather common in games
07:13:21 <bartavelle> do you already implement your own protocol (ie. you know how many bytes you expect) ?
07:13:39 <bernalex> I just derive Serialize and pray for the best lol
07:13:50 <bartavelle> heh
07:13:58 <bernalex> and now I noticed that when the game goes for long enough and gets entities enough, the client freezes. which I *assume* is due to this.
07:14:09 <bartavelle> well you can create a very simple protocol, like size + content
07:14:22 <bernalex> yeah that was what I was hoping to get out of :p
07:14:37 <bartavelle> cereal basically should do it for you though
07:14:46 <bernalex> I was thinking about making a super simple protocol like that, that could say "more coming!" or "done!" or whatever.
07:14:48 <bernalex> oh?
07:14:50 <bernalex> I don't really know cereal
07:14:51 <bartavelle> so you might be able to get away with just splitting the BS and mapM_ sendto
07:15:11 <bartavelle> hum
07:15:18 <bartavelle> the problem is with the reception
07:15:27 <bernalex> yes this was my entire point lol
07:15:32 <bartavelle> sorry thinking out loud ;)
07:15:37 <bernalex> hehe np
07:15:55 <bartavelle> cereal encodes the size of things that have variable sizes
07:15:59 <bartavelle> (or else it wouldn't work)
07:16:10 <bartavelle> I had a similar problem with binary
07:16:14 <bernalex> yeah
07:16:19 <bartavelle> basically, it can tell you if it expects more data
07:16:23 <bernalex> I have a ViewPort that the server generates for each Client on every Tick
07:16:43 <bartavelle> then you just run a non blocking read and add what you just got to its parsing continuation
07:16:45 <bernalex> and I just map some mkViewPort thing on every client, and send an encoded version of that, wrapped in a Reply
07:17:02 <bernalex> hmm
07:18:12 <bernalex> bartavelle: I guess alpha 1 will just have to suck, and then I'll learn cereal for alpha 2. :p
07:18:43 <bartavelle> bernalex, code is a bit like that http://lpaste.net/2748168307910639616
07:18:51 <bernalex> bartavelle: I'm going away on Wednesday, and promised myself I'd put this up no matter how badly it sucked. because I know that if I go away without putting the embarrassing source code online, I won't bother to fix it when I get back. ;)
07:19:04 <bartavelle> heh I know the feeling
07:19:07 <bernalex> oh that's interesting
07:19:20 <bernalex> I'm keeping that lpaste open for next Monday :-]
07:19:45 <bernalex> I have some lag in my game too, that I don't know why is there
07:20:06 <bernalex> it really shouldn't lag when just testing with my one client, on the same computer as the server. =/
07:20:28 <bartavelle> bernalex, famous last words ;)
07:20:47 <bartavelle> anyway you should keep the whole thing, perhaps I missed something important in that small excerpt : http://lpaste.net/1388571216083681280
07:21:21 <bernalex> bartavelle: excellent! thanks!
07:21:44 <bartavelle> it's basically a DSL to help when writing arbitrary client/servers for random binary protocols over TCP
07:21:51 <bernalex> bartavelle: I'm putting my src up on github sometime before I go to sleep, so if you feel like fixing it... go right ahead. :p
07:21:52 <bartavelle> so it won't work really well for your use case as it is
07:22:06 <bartavelle> sorry I have a few things to do on my side :/
07:22:08 <bernalex> no but I can look at that specific idea, so that's neat :)
07:23:00 <bernalex> bartavelle: np hehe. don't really expect anyone to fix my game. ;)
07:23:19 <bartavelle> good luck with that game though !
07:23:48 <bernalex> bartavelle: ty!
07:27:18 <tsahyt> What's the preferred library to parse command line arguments these days? A quick hackage search reveals several libraries for the job, and I'm unsure which one I should use.
07:27:20 <hodapp> huh, can't quite understand why GHC stage restriction applies; I have 'foo :: Foo -> Q [Dec]', and 'foo $ Bar ...' is legal, but not 'value = Bar ...' and 'foo value'.
07:27:28 <bernalex> tsahyt: optparse-applicative.
07:27:58 <tsahyt> bernalex: Thanks!
07:28:22 <aloiscochard> yeah optparse-applicative is really sweet
07:29:47 <bennofs> hodapp: do you have a concrete example file?
07:30:37 <merijn> tsahyt: optparse-applicative
07:30:40 <merijn> Oh, too slow :p
07:31:44 <merijn> hodapp: Well, because "value" doesn't exist when "foo" is run
07:32:02 <hodapp> merijn: but if 'value' is spelled out directly as foo's argument, it does?
07:32:05 <merijn> hodapp: It FIRST runs the TH and then compiles the file with TH spliced in
07:32:16 <merijn> hodapp: Then it's just part of the TH splice
07:32:40 <merijn> hodapp: It evaluates the entire splice of TH, but there is no "value" variable in scope
07:32:52 <hodapp> ahh, okay
07:32:59 <merijn> hodapp: Because TH can't have values defined in the same file in scope (since those aren't compiled until the TH is...)
07:48:06 <Pennth> Is here or #haskell-ops the place to talk about cabal dependency problems?
07:48:21 <bennofs> Pennth: i'd say here
07:48:38 <Pennth> Thanks, Benno.
07:48:43 <sm> everyone likes optparse-applicative, but it depends on your needs
07:48:46 <dcoutts> Pennth: here. -ops is for the IRC operators for this channel
07:49:05 <sm> it's poorly documented and if you need complete control I think cmdargs does better
07:49:11 <comprehension> is it possible to make a lens over a data type like "data Foo = Foo Int String"?
07:49:14 <dcoutts> sm: I still don't like it :-)
07:49:28 <sm> :)
07:49:32 <comprehension> where i can give names to the fields, then get the normal lens operators
07:49:43 <dcoutts> sm: but then I don't like the cmdargs magic either :-)
07:49:55 <sm> what do you use dcoutts ?
07:52:43 <comprehension> i guess i don't have any reason to not make it in to a record, since records are just sugar
07:53:45 <Pennth> So here's my hell: I built a new Centos 6 VM and installed haskell-platform and cabal-install in order to put together pandoc. Its dependency packages, and also the cabal-install upgrade, are errors about requiring base >=4.5 && <4.9. But when I attempt to upgrade the base I get failures to upgrade ghc. 
07:54:19 <tdammers> base is built into ghc
07:54:36 <tdammers> ghc from centos is probably quite old
07:54:37 <Pennth> So I'm guessing I need to ditch the centos packages (which provide ghc 7.04) and just install the environment from tarballs?
07:54:44 <tdammers> probably, yes
07:55:15 <tdammers> 7.04 is kind of ancient
07:55:18 <merijn> sm: cmdargs involves ugly dark magic
07:55:46 <Pennth> Ok, just making sure I was pointing in the right direction before I got deeper into the rabbit hole. This is my first time with haskell; I'm just an admin trying to keep @devs happy. :)
07:55:49 <sm> that's optional
07:56:20 <merijn> Pennth: It's fairly easy to grab GHC binaries and cabal-install binaries and make things work
07:57:01 <merijn> Pennth: I work on our university cluster (ancient centos version and no admin rights) and dumping GHC binaries + cabal-install binaries in my home dir everything works fine
07:57:36 <merijn> Pennth: Since by default they install stuff user-locally. So picking some global place and making sure that's in the path should be enough
07:57:38 <Pennth> Hm, maybe I should tell the devs to build it and then I'll make the binary available in /usr/local/bin :)
07:58:33 <merijn> Pennth: The existing GHC binaries should be enough
07:58:57 <merijn> Pennth: The only real dependencies are libc and gmp, both are almost certainly already installed on centos
08:00:52 <Pennth> ok, so  then I guess the next question is to ask for a quick recommendation: I was leaning with a bias toward 4.7.0.2 but is there a reason to install 4.6.0.1? 
08:01:25 <merijn> Those sound like versions of base, not GHC versions?
08:01:46 <merijn> I would go with 7.8.4 or 7.10, depending on how bleeding edge they wanna be
08:03:16 <mniip> a hello world in haskell appears to be 787 KB in size ._.
08:03:36 <mniip> any ideas on how to reduce that
08:03:38 <Pennth> I'm thinking 1 steap, no more than two, back from the edge :) After all, we're already running Cent 6 :)
08:07:16 <edwardk> comprehension: fooString f (Foo a b) = Foo a <$> f b
08:07:33 <edwardk> fooInt f (Foo a b) = (\a' -> Foo a' b) <$> f a
08:07:37 <edwardk> comprehension: just write them by hand
08:10:08 <KaneTW> mniip: dynamic linking
08:10:08 <chpatrick> mniip: ajhc? :)
08:10:11 <merijn> mniip: You can, but why bother?
08:10:17 <KaneTW> also, that
08:10:20 <merijn> mniip: It's a ton of work for no payoff
08:10:28 <KaneTW> with dynamic linking i reduced the executable size to 10kb
08:10:39 <merijn> dynamic linking is the devil
08:10:43 <KaneTW> yes
08:10:45 <KaneTW> it is
08:10:47 <Cale> mniip: Any particular reason that it's a problem? You could dynamically link the binary, but it's silly to do so because your program will be linked to shared objects that most people won't have.
08:10:54 <mniip> Cale, it's a challenge
08:11:26 <mniip> whether a haskell helloworld can fit in 64k executable rom and 20k ram
08:12:01 <Cale> Not one which is compiled with GHC
08:12:13 <merijn> https://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
08:12:13 <KaneTW> you'd have to write a special compiler for that
08:12:13 <mniip> I guess the RTS itself is very well over that mark and it isn't modular enough to be able to omit some parts of itself
08:12:15 <tdammers> if that's the context, I bet you're better off with a Haskell DSL that generates C or machine code or sth
08:12:17 <Cale> But other compilers produce more compact binaries that you could try, I guess.
08:12:47 <Cale> But yeah, if you're going to be programming tiny systems, probably better to use Haskell as a metalanguage
08:13:12 <Denommus> or use something different from Haskell
08:13:19 <Denommus> I guess Rust would be good for that
08:13:22 <chpatrick> ajhc binaries run on microcontrollers don't they?
08:13:24 <Cale> Look into stuff like atom, which has been used in industry to program microcontrollers for hybrid hydraulic vehicles, among other things.
08:13:41 <Cale> https://hackage.haskell.org/package/atom
08:13:48 <mniip> does GHC still have a GCC-compilable codegen backend
08:14:02 <chpatrick> http://www.slideshare.net/master_q/metasepi-team-meeting-7-snatch-application-on-tiny-os
08:14:57 <Cale> mniip: No, but even when it did compile via gcc, the binaries weren't any smaller, and the intermediate C code if compiled wouldn't actually work on its own. GHC would mangle the assembly output of GCC to fix things up.
08:15:49 <Cale> it*
08:16:42 <Cale> http://dmcc.acm.org/pres/?query=/dmcc///confdata/ICFP2008/2008-09-26_09h56 -- a talk about atom
08:17:16 <Cale> hmm, does it not actually load any more?
08:17:53 * hackagebot hset 0.1.0 - Primitive heterogenous read-only set  http://hackage.haskell.org/package/hset-0.1.0 (AlekseyUymanov)
08:17:57 <Freefood> As anyone any idea on how to implement such a thing in haskell (http://stackoverflow.com/questions/1692184/converting-epoch-time-to-real-date-time/1692210#1692210) ? I'm having some troubles (and yes I want to do it manually not use any 3rd party library)
08:18:44 <merijn> Freefood: Short summary: You're doomed
08:18:46 <Cale> Freefood: Does the standard time library count as 3rd party?
08:19:05 <Freefood> Cale: yes it does :D
08:19:12 <chpatrick> is it just for fun?
08:19:20 <chpatrick> I don't think I'd touch time-related stuff with a ten foot pole
08:19:24 <Cale> Well, okay, you can look at its source code for an answer then.
08:19:38 <merijn> Freefood: Then you're more doomed, you need to have a timezone database and a bunch of things like leap second fun and a gazillion edge cases
08:19:51 <merijn> Personally I'd rather stab myself with a knife than write this code
08:20:04 <chpatrick> ^this
08:20:28 <Freefood> Woaw
08:20:37 <chpatrick> https://www.youtube.com/watch?v=-5wpm-gesOY
08:20:39 <tdammers> no, seriously, date/time is one hell of a can-of-worms
08:20:46 <merijn> Freefood: I recommend looking at this list: http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time
08:21:11 <tdammers> merijn: I was about to paste that exact link
08:22:21 <chpatrick> Freefood: what's wrong with the standard library anyway?
08:22:28 <Freefood> merijn: I know that link :) but my link is a working solution it comes from the gmttime implemention in C and I could reproduce it in a procedural language easily but I don't know how to in haskell
08:22:46 <drewbert> Darnit, was putting off learning lenses, now I have to.
08:23:06 <Freefood> chpatrick: i'm using another language than haskell (very similar syntax) which does not have such library and has very little community ^^
08:23:40 <chpatrick> Freefood: what language is that? :) and then maybe just ffi to gmtime?
08:23:57 <Freefood> chpatrick: that's cheating :D
08:24:13 <nshepperd> drewbert: Consider yourself lucky: you get to learn lenses! :D
08:24:27 <Freefood> chpatrick: and it doesn't have always have access to external bindings ;)
08:24:29 <tdammers> Freefood: it's not cheating, it's called making an engineering call
08:24:43 <chpatrick> yeah time is a real pain in the ass and very easy to get wrong
08:24:45 <nshepperd> you can even justify watching another ekmett talk
08:25:13 <tdammers> I'd argue that one of the most important qualities of a good developer is to know when not to solve a problem yourself
08:25:21 <chpatrick> drewbert: all the lens type synonyms are variations on the same idea with different constraints
08:25:28 <chpatrick> made a lot more sense to me when I realizes that :)
08:27:10 <magneticDuck> hm, is there any particular connection between haskell 'pipes' and haskell FRP?
08:27:22 <magneticDuck> x)
08:27:53 <merijn> magneticDuck: Not really
08:28:12 <merijn> magneticDuck: pipes is stream processing, like conduit/iteratees
08:28:24 <nshepperd> the important thing is to remember the difference between time and calendars
08:30:24 <Cale> Well, they do kind of overlap slightly in terms of the space of problems being approached, I suppose. They're both trying to offer some more declarative approach to describing I/O, but the whole approach to how they do it is pretty different.
08:31:09 <kuribas> magneticDuck: this mentions FRP: https://hackage.haskell.org/package/pipes-concurrency-2.0.3/docs/Pipes-Concurrent-Tutorial.html
08:33:03 <nshepperd> half of the myths on there are about calendars, but normally a programmer should have nothing to do with calendars, except where they need to present one to the user
08:34:50 <mizu_no_oto> drewbert: are you looking into edwardk's lens library?
08:35:06 <nshepperd> although, now I see the question was really about calendars, so good "luck"!
08:35:06 <mizu_no_oto> or just lenses in general?
08:35:31 <drewbert> mizu_no_oto: In general.
08:37:57 <mizu_no_oto> If you want to understand the encoding of lenses edwardk uses, Simon Peyton Jones's  talk is remarkably well-done: https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
08:40:22 <mizu_no_oto> drewbert: But the basic idea of a lens is remarkably simple: you have a getter function and a setter function, and you can easily compose them to set in nested structures.
08:40:39 <f-a> λ> 1.20 / 20
08:40:39 <f-a> 6.0e-2
08:40:54 <f-a> is there a way to tell ghci "show it as 0.06"?
08:45:52 <chpatrick> f-a: printf?
08:46:37 <chpatrick> > import Text.Printf
08:46:38 <lambdabot>  <hint>:1:1: parse error on input ‘import’
08:46:57 <chpatrick> > printf "%0.2f" (1.20 / 20) :: String
08:46:58 <lambdabot>  "0.06"
08:47:20 <f-a> thanks chpatrick 
08:47:54 * hackagebot cgrep 6.4.13 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.13 (NicolaBonelli)
08:51:08 <Feuerbach> f-a: you can also use types from Data.Fixed
08:51:44 <Feuerbach> > 0.06 :: Data.Fixed.Centi
08:51:46 <lambdabot>  0.06
08:51:50 <Feuerbach> > 0.06 :: Data.Fixed.Milli
08:51:52 <lambdabot>  0.060
08:53:02 <xcombelle> In this answer http://stackoverflow.com/a/1016986/128629 the poster says about Haskell: "It is very fast (behind only c and c++ in my experience)" Is it also your experience ?
08:54:16 <chpatrick> xcombelle: that really depends
08:54:26 <chpatrick> there are a million ways to make it slow
08:54:52 <xcombelle> chpatrick your answer looks like a good answer
08:54:55 <Freefood> xcombelle: ask me to program for you and it will be slow :D
08:55:08 <chpatrick> it can be very fast though
08:55:20 <chpatrick> usually when there's a library that's tuned to death
08:55:24 <chpatrick> like vector or attoparsec
08:55:32 <f-a> thanks Feuerbach 
08:55:43 <chpatrick> if you use them properly then your code will be fast too
08:55:49 <chpatrick> but you can screw that up too unfortunately :)
08:55:55 <Feuerbach> xcombelle: no, that's not typical
08:56:42 <xcombelle> I must concede that speed is not my top priority (I come from python after all)
08:56:54 <chpatrick> hmm that guy mentions arrays but not vector
08:57:10 <chpatrick> I think the nice thing is that you can make haskell really fast if you need to
08:57:13 <chpatrick> it's a lot harder with python
08:57:45 <xcombelle> chpatrick I know already it's a lot harder than python
08:58:06 <xcombelle> I tried to learn it several time and failed
08:58:08 <raghu> Is profiling a lot harder given the non-strict evaluation?
08:59:43 <xcombelle> what would you install on a debian linux to play with Haskell ?
09:00:09 <chpatrick> xcombelle: I mean performance tuning is harder on python than in haskell
09:00:25 <sccrstud92_> xcombelle: stack
09:00:25 <xcombelle> ah
09:00:26 <chpatrick> I did some computer vision in python and it was really pushing it :)
09:00:40 <chpatrick> was considering using cython instead
09:00:43 <f-a> xcombelle: debian comes with a package called haskell-platform
09:00:51 <f-a> which should do
09:01:34 <raghu> xcombelle: If you need the latest compiler version you can install ghc-7.10.x instead of haskell-platform
09:02:10 <xcombelle> raghu I will start with basic things for the moment so haskell-platform should be ok
09:02:42 <raghu> makes sense
09:04:36 <cnf> hi, can anyone explain me what <- and -> do in haskell?
09:05:05 <raghu> <- and -> not really related
09:05:08 <cnf> i'm trying to follow http://learnyouahaskell.com, and they are used but not elaborated on
09:05:37 <sccrstud92_> cnf: they are just part of the syntax
09:05:51 <sccrstud92_> <- is used in do notation
09:05:59 <sccrstud92_> -> is used in case statements
09:06:06 <cnf> uhm
09:06:08 <raghu> You will find -> in lambda abstractions (anonymous functions), case statements etc
09:06:17 <sccrstud92_> -> also appears in types
09:06:42 <sccrstud92_> meaning a -> b is a function that takes a as input and produces b as output
09:07:15 <cnf> ok, that's how it is used, i think
09:07:21 <orzo_> pattern gaurds also use <-
09:07:25 <cnf> isn't there a page that lists this?
09:07:38 <cnf> where I can look this stuff up?
09:07:42 <orzo_> and view patterns use ->
09:07:55 <cnf> i have no idea what any of that means
09:07:58 <Clint> list comprehensions
09:08:12 <orzo_> cnf, read the haskell report
09:08:34 <orzo_> https://www.haskell.org/onlinereport/haskell2010/
09:08:44 <orzo_> i've never read that 2010 version heh
09:09:18 <cnf> hmm, i'm finding haskell incredibly hard to get my head round :/
09:09:24 <orzo_> well
09:09:42 <orzo_> most imperitive languages can be learned in a week or so
09:09:49 <raghu> cnf: what other languages have you used before?
09:10:14 <orzo_> but coming to haskell from there, expect to be learning for a good while, but it's worth it
09:10:21 <cnf> raghu: perl, php (not in over a decade), python, ruby, go, lua, and some other small stuff
09:10:52 <cnf> tried some java, didn't like it so i didn't really do much with it
09:11:07 <bernalex> orzo_ | most imperitive languages can be learned in a week or so 
09:11:08 <raghu> I agree with orzo_, it will take quite sometime to wrap your head around functional programming
09:11:09 <bernalex> that's not true
09:11:32 <orzo_> well assume you know one of them
09:11:36 <bernalex> you mean to say that [language in paradigm one already knows] is easier to learn than [language in paradigm one doesn't already know]
09:11:37 <orzo_> you can learn another very rapidly
09:11:54 <bernalex> which of course is obvious given a second's thought.
09:12:00 <raghu> And haskell adds a number of other concepts: purity, lazy eval, etc
09:12:10 <xcombelle> hey nobody tell me about apt install haskell-mode
09:12:12 <raghu> But its definitely worth learning.
09:12:21 <cnf> i find it hard to get my head around stuff that "sort of is there, and does this here, and something else there"
09:12:24 <bitemyapp> cnf: I don't think Haskell is intrinsically difficult.
09:12:36 <bitemyapp> cnf: I do think the learning materials most people use aren't helping the problem though.
09:13:04 <bitemyapp> Haskell is foundationally much simpler than imperative languages, but you can't derive the implications of the simple design yourself.
09:13:41 <orzo_> is the haskell report alright for learning?
09:13:55 <orzo_> i think it makes sense to start there
09:13:56 <raghu> orzo_: Not a good idea
09:13:58 <dolio> Not for most people.
09:14:01 <rui1> What would be a nice way to do "x = map f list" in a way that requiring "x !! n" fully evaluates all "x !! m" with m<n?
09:14:26 <raghu> That's the language reference. Learn you a haskell is probably a much better choice
09:14:30 <cnf> bitemyapp: well, i was pointed to "learn you a haskell", admittedly by someone that wrote his thesis on functional languages
09:15:57 <bananagram> https://github.com/bitemyapp/learnhaskell
09:16:09 <bitemyapp> cnf: LYAH is not a good resource for learning Haskell.
09:16:18 <cnf> well, what is?
09:16:21 <bitemyapp> cnf: writing a thesis on something doesn't mean you've taken teaching something effectively as a serious task in its own right.
09:16:27 <bitemyapp> cnf: bananagram linked my guide.
09:16:37 <bitemyapp> cnf: https://github.com/bitemyapp/learnhaskell
09:17:05 <bitemyapp> cnf: I explain some of the background here: http://bitemyapp.com/posts/2014-12-31-functional-education.html
09:19:11 <sccrstud92_> why dont people like LYAH?
09:19:15 <orzo_> rui1: scanr (\x y -> seq y (f x)) (f z) zs  -- does this do it?
09:19:18 <sccrstud92_> it was the first one i read that i liked
09:19:43 <bernalex> sccrstud92_: I mostly like it.
09:19:47 <orzo_> where z:zs = list
09:19:50 <jerv> I am trying to write a function that given a string and a list of strings find the first string in the list that is a substring of the string. This is my attempt: http://pastebin.com/a03NWQkL. I works but I am looking for something more idiomatic though, preferably a one liner.
09:19:54 <bitemyapp> sccrstud92_: I explain why it hasn't worked well for a lot of people in that post.
09:20:26 <bitemyapp> it's not about "like" or "dislike", it's about what's more effective for learners.
09:20:27 <tejing> I found lyah good for gaining overview... there's a great deal more to be learned though, and many things that are glossed over a bit too blithely in it
09:20:28 <hodapp> sccrstud92_: he's not just mindlessly self-promoting; he does explain fairly well in that link where LYAH is and is not useful.
09:20:41 <orzo_> i didn't use learn you a haskell
09:21:01 <orzo_> though maybe i did a bit
09:21:01 <sccrstud92_> hodapp: i wasnt expressing any problem with the self-promotion
09:21:07 <xcombelle> haskell list are like lisp list ?
09:21:11 <rui1> orzo_: Smells right, I'll have to try it. Thanks!
09:21:20 <hodapp> sccrstud92_: I'm just backing him up as I've read the link too.
09:21:29 <bitemyapp> xcombelle: structurally similar, but they can be infinite in Haskell.
09:21:35 <ahihi> not seeing YAHT discussed in the article makes me feel old
09:21:39 <xcombelle> ok
09:22:06 <Clint> and they're homogeneous
09:22:07 <sccrstud92_> jerv: what if you filter out the strings that arent substring from the list
09:22:19 <sccrstud92_> jerv: then just get the first word of the resulting list
09:22:28 <jerv> sccrstud92_: cool
09:23:11 <sccrstud92_> jerv: because of laziness you will only check the words you need to check, not all of them
09:23:22 <darveter> jerv: head ([x|x<-xs, ixInfoxOf c cmdline] ++ [""]) is one possibility. 
09:23:58 <dolio> After you run it through spell check. :)
09:24:28 <xcombelle> Am I right ? : head onelist == onelist !! 0 
09:24:33 <SaidinWoT> Finding Infoxes is pretty useful, though
09:24:36 <bitemyapp> ahihi: older tutorials don't cover enough.
09:25:57 <xcombelle> oh there is #haskell-beginners 
09:26:00 <ahihi> bitemyapp: sure, it's just the one I originally learned from :)
09:26:33 <dolio> ahihi: YAHT is the new fangled tutorial.
09:26:44 <sccrstud92_> bytemyapp: where in that repo do you talk about the problems with LYAH?
09:27:36 <cnf> bitemyapp: as a side note, is haskell suited for doing web dev? I happen to have a project that needs some webdev, and I tend to learn best by just doing
09:27:38 <cnf> not that webdev is my favorite past time :P
09:27:55 <dmj`> cnf: yes
09:28:36 <cnf> cool
09:28:54 <bitemyapp> cnf: yes it's good for that.
09:29:08 <bitemyapp> sccrstud92_: I linked an article
09:29:16 <bitemyapp> sccrstud92_: http://bitemyapp.com/posts/2014-12-31-functional-education.html
09:29:20 <bitemyapp> sccrstud92_: that talks about it.
09:29:24 <bernalex> I make a socket
09:29:25 <cnf> reading that :P
09:29:26 <bernalex>   let a = SockAddrInet gp iNADDR_ANY
09:29:28 <bernalex>   bind s a
09:29:31 <bitemyapp> sccrstud92_: the repo is just how I recommend learning Haskell for now.
09:29:33 <bernalex> what should I do to get the address?
09:29:41 <bernalex> I want to serve a link to a client with the address
09:29:42 <sccrstud92_> bitemyapp: sorry, looked in the wrong spot
09:29:48 <bernalex> and 0.0.0.0 is not a very useful link
09:29:52 <cnf> bitemyapp: so far i can say I have never learned to learn :P and my math skills suck 
09:30:34 <bitemyapp> cnf: I have no education, no background in math.
09:30:42 <dmj`> cnf: you don't need to know math to program in haskell, but it might make you want to learn math more
09:30:52 <bitemyapp> cnf: my own credentials are that I've taught a lot of people Haskell, I'm writing a book for beginners to learn Haskell, and I use Haskell in my work.
09:30:53 <darveter> xcombelle: correct.
09:31:02 <bitemyapp> cnf: what dmj` said is right.
09:31:19 <xcombelle> thanks darveter
09:37:40 <Jello_Raptor> o/ 
09:37:56 * hackagebot stash 0.1 - To be written  http://hackage.haskell.org/package/stash-0.1 (HansHoglund)
09:38:37 <Profpatsch> Parsec: How do I combine parsers, so that they combine their results?
09:39:04 <Profpatsch> e.g something that should take a char, a space and a char
09:39:31 <Jello_Raptor> I've got infix operators '|=|' and '<|' and '|>' for a particular instance of a partial order and would like '|^|' and '|v|' for their join and meet, but '|v|' isn't a valid infix haskell operator, any suggestions on what to use instead? (I'd be fine changing all of them if they still look similar) 
09:39:42 <Profpatsch> x <- char `op` space `op` char
09:40:03 <Profpatsch> Or do I have to assign monadic variables for each of these?
09:40:43 <sccrstud92_> Profpatsch: is f is the function that combines the chars, you can do f <$> char <*> (space *> char)
09:41:11 <athan> Hey folks, does anyone here know of a good request-body parser, for form data? (so it would be in `key=val&key=val` format)
09:41:59 <sccrstud92_> athan: those are typically done autmomatically by most web frameworks i have seen. i havent seen a standalone one, sorry
09:42:37 <athan> sccrstud92_: Yeah, I'm using raw WAI :\
09:42:45 <athan> shouldn't be too hard, though
09:42:47 <bitemyapp> athan: http-types?
09:42:55 <athan> I'd just have to worry about uri encodings ><
09:42:59 <athan> bitemyapp: ooh, okay!
09:43:24 <sccrstud92_> bitemyapp: thanks for the link. i remember reading it when i first saw it on reddit
09:43:30 <darveter> Jello_Raptor: '|\/|' etc.?
09:44:37 <Jello_Raptor> darveter: i'd refer a single char, but it'll do for now I suppose. 
09:45:20 <darveter> Jello_Raptor: you could loose the ||...
09:46:02 <mniip> Jello_Raptor, you could use some unicode magic
09:46:12 <Jello_Raptor> darveter: issue is that I'd like to keep the '|' as a "this operator is talking about the type lattice for these objects" 
09:46:18 <sccrstud92_> Jello_Raptor: you could use http://shapecatcher.com/ to find a unicode char you like
09:46:37 <mniip> > let (|∨|) = or in True |∨| False
09:46:38 <lambdabot>      Couldn't match expected type ‘t0 Bool’ with actual type ‘Bool’
09:46:38 <lambdabot>      In the first argument of ‘(|∨|)’, namely ‘True’
09:46:38 <lambdabot>      In the expression: True |∨| False    Couldn't match expected type ‘Bool ...
09:46:45 <mniip> oops
09:46:47 <mniip> > let (|∨|) = (||) in True |∨| False
09:46:49 <lambdabot>  True
09:47:27 <mniip> U+2228 LOGICAL OR
09:47:53 <mniip> well also maybe ∧ U+2227 LOGICAL AND
09:47:53 <Jello_Raptor> hmm, now i just have to figure out unicode input for vim :P 
09:47:58 * Jello_Raptor goes to google
09:48:07 <mniip> Jello_Raptor, linux?
09:48:49 <Jello_Raptor> mhmm
09:49:12 <fgaz> athan: urlencoded or urlDecode from http-types + splitting etc
09:49:15 <mniip> somewhere in the X11 stack there's a Ctrl+Shift+U #### shortcut
09:49:25 <mniip> but vim has ^Vu####
09:49:55 <Jello_Raptor> mniip: ah cool 
09:50:11 <mniip> also
09:50:15 <mniip> ^KAN ^KOR
09:50:47 <mniip> digraphs for ∧ and ∨ resp.
09:51:00 <Jello_Raptor> cool 
09:51:06 <Profpatsch> sccrstud92_: Ah, that’s nice.
09:51:20 <mniip> Jello_Raptor, for future reference, http://vimdoc.sourceforge.net/htmldoc/digraph.html#digraph.txt
09:51:21 <Profpatsch> Another question: No instance for (Stream s Data.Functor.Identity.Identity Char)
09:51:21 <athan> bitemyapp: You were spot on
09:51:22 <mniip> is pretty handy
09:51:23 <Profpatsch>       arising from a use of ‘anyChar’
09:51:31 <athan> fgaz: Thanks :)
09:51:36 <Profpatsch> Do I need to hint a type there?
09:51:49 <chpatrick> can you give some context?
09:51:53 <Profpatsch> But anyChar is Parsec s u Char
09:52:00 <Profpatsch> chpatrick: sure
09:52:14 <chpatrick> it probably doesn't know what s is
09:52:18 <sccrstud92_> Profpatsch: not sure, i use atooparsec, havent used parsec. post code?
09:52:29 <darveter> sccrstud92_: great stuff that unicode recognizer http://shapecatcher.com/, thanks.
09:52:45 <sccrstud92_> darveter: no problem. just found it.
09:53:25 <Profpatsch> sccrstud92_: chpatrick Something like that: http://lpaste.net/135483
09:53:50 <Profpatsch> with this main: main = either (print.show) (print.show) $ parse songP "" getContents
09:53:58 <bitemyapp> athan: I do a lot of that.
09:54:20 <Profpatsch> where songP is a combined parser that has some more anyChar errors.
09:54:27 <chpatrick> wait a sec
09:54:32 <chpatrick> parse songP "" getContents
09:54:38 <Profpatsch> What would s be in my case?
09:54:49 <chpatrick> missing a bind here methinks :)
09:55:17 <Profpatsch> chpatrick: Ah, right, it’s IO Char :)
09:55:33 <Jello_Raptor> mniip: thank you :) 
09:55:49 <Profpatsch> And too much generality for ghc.
09:56:38 <sccrstud92_> attoparsec doesnt have a Stream type param, so im not much help here
09:58:03 <chpatrick> profpatsch: consider using attoparsec too imo
09:58:25 <chpatrick> I think parsec's really nice for parsing code but attoparsec is better for everything else
09:59:18 <athan> lord of spots
10:02:59 <magneticDuck> I feel like pipes and FRP should have some sort of interesting intersection
10:06:43 <bernalex> how do I compile for x86_64 rather than native?
10:06:47 <bernalex> (preferably using cabal)
10:07:22 <sccrstud92_> magneticDuck: i thought i remember someone mentioning a pipes-frp in the works
10:07:25 <davean> bernalex: what do you mean by that? Are you cross compiling from x86?
10:07:33 <bernalex> is there perhaps any "compile the most portable thing possible"?
10:08:00 <bernalex> davean: no. I would guess it's compiled with something like GCC native though, rather than generic x86_64? in any event it did not work on the server I tried deploying it to
10:08:25 <davean> bernalex: Oh, I see, you're confused. I expect the problem you are having is linking
10:08:34 <davean> Which ahs nothing to do with the architecture
10:08:40 <bernalex> davean: I just cabal build & rsync & try to run it
10:08:44 <tsousa> Do you guys think Haskell would perform in doing tasking for sys admin like perl does?
10:08:48 <magneticDuck> sccrstud92_: right now, there surely are circumstances where you would use one rather than the other?
10:08:48 <bernalex> davean: I'm probably confused :)
10:08:51 <magneticDuck> i.e. they intersect?
10:09:08 <Profpatsch> chpatrick: Ah, I made the old mistake again: import Data.Parsec.String or Text and use type Parser = Parsec String ()
10:09:19 <davean> bernalex: use ldd
10:09:20 <Profpatsch> Instead of using the general types.
10:09:24 <davean> it'll probably tell you WHY it is broken
10:09:28 <Cale> magneticDuck: The tricky thing is that pipes is sort of all about processing streams of data as quickly as possible (e.g. as soon as enough input is available to do the next bit of parsing or something), while FRP is more aimed at discussing values at particular moments in time, where even if you don't have a concrete notion of what times are, the occurrences of events provide some notion of a clock, while behaviours t
10:09:28 <Cale> ake on particular values at any given moment when an event is occurring.
10:09:29 <bernalex> davean: uh the problem is with CPU instructions
10:09:37 <bernalex> davean: "illegal instruction". ldd looked fine.
10:10:04 <magneticDuck> okay
10:10:13 <davean> bernalex: "uname -a" will tell you the instruction set of a system
10:10:28 <bernalex> davean: yes mine is different to the server
10:10:33 <magneticDuck> so FRP is focused on temporal logic while pipes are more focused on systems concerning throughput
10:10:39 <davean> Oh, that *is* cross compiling
10:10:43 <Cale> magneticDuck: Yeah
10:10:53 <bernalex> davean: oh do you mean x86_64?
10:10:58 <davean> cross compiling means to compile for an architecture different from where you are compiling
10:11:02 <bernalex> davean: sorry, yeah we have the same architecture.
10:11:18 <bernalex> davean: my brain got confused & thought you meant cpu not arch. sorry. tired. :)
10:11:33 <davean> Haha, its ok, just makes it hard to help you!
10:11:39 <conal> magneticDuck: also, FRP is founded on (a) simple, precise denotation and (b) continuous time. hard to imagine getting either of those properties from pipes. See https://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language/5878525#5878525, and follow links there.
10:11:39 <magneticDuck> so you could use, say, pipes to capture input data and transform it around into more concise signals to run through a FRP network?
10:11:53 <magneticDuck> okay thanks
10:11:54 <bernalex> davean: both are x86_64 in any event. :)
10:12:30 <davean> bernalex: you might want to avoid using llvm, its more likely to compile using local instructions, but you can pass it flags through GHC also
10:12:32 <magneticDuck> what exactly is this idea of continuous time though?
10:12:44 <bernalex> davean: how do I do this, in practice?
10:12:45 <davean> The built-in GHC native code gen uses an extreamly generic instruction subset
10:12:46 <magneticDuck> all the material I've read on FRP so far has involved the signal being in discrete steps
10:13:49 <magneticDuck> well, of course the signal will at some level always have to be in discrete steps
10:13:53 <Cale> magneticDuck: Well, there are various approaches to the idea, but they all centre around the notion of a behaviour, which is something which always has a value whenever you look at it, without any particular way of notifying you *when* it is changing.
10:13:58 <magneticDuck> but, say, it makes no sense to even consider folding over a continuous signal
10:13:58 <bernalex> davean: davean how do I avoid llvm using cabal build?
10:14:03 <davean> bernalex: Try -fasm
10:14:11 <davean> bernalex: there is also -fvia-c
10:14:19 <conal> magneticDuck: i'm sorry to hear that. lately, the term "frp" has been used pretty vaguely/loosely, in contrast to the original precise definition.
10:14:20 <magneticDuck> okay that makes sense
10:14:21 <davean> oh, thats the GHC option
10:14:26 <bernalex> davean: davean can I specify this in .cabal under ghc-options then?
10:14:31 <davean> bernalex: yes
10:14:31 <magneticDuck> conal: http://sgate.emt.bme.hu/documents/patai/publications/PataiWFLP2010.pdf
10:14:35 <dcoutts> bernalex: yes, or cabal configure --ghc-option=-fasm
10:14:35 <Cale> Given that sort of API, it's possible for behaviours to essentially always be changing, for instance, they might be determined by some polynomial function of the current time in the system
10:14:37 <davean> or pass it to cabal config as a GHC option
10:14:45 <Cale> (or an arbitrary computable function)
10:14:48 <bernalex> davean: blubber-server.cabal|| 'ghc-options: -fasm' is unnecessary and will not work on CPU architectures other than x86, x86-64, ppc or sparc.
10:14:49 <magneticDuck> I believe my issue was just terminology
10:14:55 <bernalex> davean: says syntastic :p
10:15:01 <conal> magneticDuck: what makes you think that the signal has to be in discrete steps? maybe you mean something about *samplings* of the continuous signal, rather than the signal itself.
10:15:06 <dcoutts> bernalex:but I don't think it's necessary, -fasm is the default, not llvm.
10:15:17 <davean> bernalex: yes well, you want it to work on x86-64 :)
10:15:22 <bernalex> dcoutts: oh. any ideas about "illegal instruction" then?
10:15:30 <magneticDuck> conal: signals ("steams") in that paper are homomorphic to N -> a
10:15:41 <Cale> magneticDuck: Behaviours don't have to update in discrete steps. The occurrences of events are discrete though.
10:15:44 <bernalex> davean: sent 75 bytes  received 12 bytes  174.00 bytes/sec
10:15:50 <conal> magneticDuck: yep. not frp in the precise/original sense.
10:15:52 <bernalex> davean: I don't think this binary file is different to the previous
10:16:02 <bernalex> davean: i.e. I don't think it made any difference, like dcoutts suspected.
10:16:25 <conal> magneticDuck: if you follow those links i pointed you to, you'll find remarks on the importance of continuous time. similar to benefits of continuous space. and of non-strict languages like haskell.
10:16:33 <Cale> magneticDuck: Some FRP systems give you a way to sample a behaviour at any time you like. Others only give you the ability to observe the values of a behaviour at the points in time when an event occurs, making behaviours potentially secretly discrete.
10:16:45 <dcoutts> bernalex: only thing I'm aware of is the -msse etc flags
10:16:49 <davean> bernalex: you might want to run it in a debugger to see what the instruction is
10:17:10 <magneticDuck> hmm
10:17:17 <Cale> Similarly, some FRP systems give you a way to get an event with new occurrences which occur at times which are arithemtically related to the times at which another event is occurring in some way, while others don't let you do that.
10:17:42 <bernalex> davean: dcoutts: here's the server: http://lpaste.net/1845951058052907008
10:17:54 <conal> Video of my BayHac  Haskell-to-hardware talk is now available, thanks to Joe Nelson. http://begriffs.com/posts/2015-06-28-haskell-to-hardware.html
10:18:21 <bernalex> davean: dcoutts: annotated it with the client
10:18:30 <Cale> But whether you can do this or not, you should always be able to *think* of behaviours as continuously varying, even if you can't necessarily observe them at arbitrarily fine timescales, due to simply not having the events required to do so.
10:18:38 <bernalex> davean: dcoutts: or uh, my computer, rather
10:18:52 <EvanR> conal: May I ask which one is the original precise definition of FPR? Which paper?
10:18:53 <dcoutts> bernalex: ok so that's got sse4_2 popcnt which is what I was thinking of
10:19:07 <bernalex> dcoutts: so no change necessary?
10:19:39 <bernalex> it runs on a different server (not the one I want it to run on though, heh)
10:19:44 <Cale> magneticDuck: Another operation related to this timescale business which you may or may not have is the ability to, say, double or halve the rate at which a Behaviour changes.
10:19:56 <conal> I also gave a talk at BayHac called "The essence and origins of FRP", focusing on these two foundational aspects (simple & precise denotation, and continous time) any why they matter. Hopefully it'll be up soon.
10:20:17 <dcoutts> bernalex: and it's not on by default anyway, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-platform.html
10:20:35 <dcoutts> bernalex: are you statically linking any C libs?
10:20:35 <davean> bernalex: well, compare the features of the 2 systems it runs on and the one it doesn't? Also, gdb will tell you what instruction it errored on
10:20:51 <bernalex> dcoutts: no just regular cabal build of regular haskell deps
10:21:06 <bernalex> davean: this server doesn't have gdb. it's very bare.
10:21:16 <dcoutts> bernalex: I'm out of guesses then, try gdb as davean suggests
10:22:04 <davean> some regular haskell deps, like zlib, link C libs
10:22:49 <conal> EvanR: The first FRP paper is "A Brief Introduction to ActiveVRML" (http://conal.net/papers/ActiveVRML/). The more widely cited early paper is "Functional Reactive Animation" (http://conal.net/papers/icfp97/) ("Fran"). The latter spells out a simple denotation. Continuous time was present in Fran as well as its progenitor TBAG (http://conal.net/tbag/).
10:22:50 <Cale> These sorts of timescale-adjusting operations are really nice to have or even essential in some settings, and in others can be severely dangerous when it comes to ensuring that the overall space and time performance of the system is good and that everything is keeping up.
10:22:57 <davean> bernalex: You wouldn't happen to - transatively - rely on any crypto libs would you?
10:22:59 <bernalex> davean: deps are mostly Web stuff. and like uh containers and unix.
10:23:15 <bernalex> full list on a line:   build-depends:       base               >=4.7  && <4.9, blubber-server, Cabal              >=1.18  && <1.23, cereal             >=0.4   && <0.5, containers         >=0.5   && <0.6, data-default-class >=0.0.1 && <0.1, network            >=2.6   && <2.7, pandoc             >=1.14  && <1.15, process            >=1.2   && <1.3, random             >=1.1   && <1.2, scotty             >=0.7  
10:23:16 <bernalex> && <0.11, text               >=1.2   && <1.3, transformers       >=0.4   && <0.5, unix               >=2.7   && <2.8
10:23:20 <conal> EvanR: After the Fran paper, I changed "events" to be multi-occurrence, which made programs more elegant.
10:23:51 <EvanR> So more than one event can occur at once, but do they have some ordering at that time?
10:24:01 <davean> bernalex: *some* crypto libs depend on the native AES instructions and such. though thats a long shot, and 'd have to check if your CPU even has them
10:24:19 <davean> bernalex: you are running into an inherant issue of cross compiling though
10:24:25 <davean> you *have* to target the target arch
10:24:30 <bernalex> davean: this isn't really supposed to be cross compiling
10:24:44 <davean> bernalex: yes it is
10:24:51 <EvanR> Ok Functional Reactive Animation, I've read that one. So this is basically what you're referring to regarding "real FRP". Give or take some details.
10:25:03 <davean> bernalex: also, you do have AES-NI
10:25:14 <davean> bernalex: so a crpyto lib could very well have selected to use it based on you system
10:25:19 <conal> EvanR: simultaneous occurrences are included, though I meant non-simultaneous as well. Yes, there's a deterministic ordering. There has to be in order to have a simple & precise denotation.
10:25:30 <bernalex> davean: I don't see how I could have a crypto lib in here
10:25:53 <davean> scotty, for TLS
10:26:12 <davean> I'd have to check
10:26:14 <bernalex> woah, scotty does tls itself? I didn't remember that
10:26:51 <EvanR> conal: oh, then what does multi-occurrence mean?
10:26:51 <davean> bernalex: well, its a web framework, I haven't checked as I don't use scotty
10:26:53 <conal> EvanR: BTW, my objection to people using "FRP" isn't that they're not staying precisely with the original API & denotation, but rather that they so often abandon one or (usually) both fundamental properties that shaped FRP.
10:26:58 <davean> but a lot of the web frameworks link it in
10:27:03 <bernalex> davean: scotty is super tiny
10:27:47 <davean> bernalex: http://packdeps.haskellers.com/feed?needle=scotty&deep=on
10:28:01 <davean> bernalex: it might look tiny but it depends on not one but *two* priority search queue implimentations :)
10:28:15 <davean> bernalex: and several cypto libs
10:28:35 <davean> bernalex: also, as predicted, cypher-aes
10:28:48 <davean> bernalex: and cprng-aes
10:28:54 <conal> EvanR: having 0 or more occurrences, whether simultaneous or not. each occurrence has a well-defined time as well as value. See "Push-pull functional reactive programming" for a modernized API (making more use of standard type classes) and the denotation structured in an elegant, systematic form, as homomorphisms. 
10:29:09 <davean> bernalex: so thats two things that would want to use AES-NI
10:29:21 <davean> bernalex: (see "packages checked")
10:31:00 <davean> bernalex: scotty pulls in 285 packages
10:31:28 <bernalex> davean: but uh the server has aes
10:32:00 <davean> bernalex: ok, it was an example (and you said you linked your system, not the server - I've still not seen the server's instruction set)
10:32:09 <bernalex> davean: the server is on top
10:32:14 <davean> bernalex: Also, cipher-aes takes the 
10:32:17 <davean> bernalex: 
10:32:19 <bernalex> davean: I said I annotated with the client :)
10:32:28 <bernalex> and by client I meant to say my computer :p
10:32:28 <davean> bernalex: support_aesni flag
10:32:34 <davean> bernalex: which is enabled by default
10:32:46 <Gal3rielol> I remember there is a paper this year talking about some improvement on FRAN, anyone can recall the name?
10:32:51 <bernalex> davean: neither of the computers have that
10:33:11 <davean> bernalex: have what?
10:33:46 <bernalex> davean: "aesni", unless you meant that's a ghc thing. I'm not sure what that really means. :)
10:34:02 <Haskellfant> Gal3rielol: I haven't read it (yet) but the most recent one I saw was http://www.cse.chalmers.se/~atze/papers/prprfrp.pdf. I am not sure how related it is to fran
10:34:27 <davean> bernalex: AES-NI: Advanced Encryption Standard - New Instructions
10:34:30 <Gal3rielol> Exactly this one. thanks so much.
10:34:48 <davean> bernalex: its an Intel CPU instruction set extension for accelerate cryptography processing
10:34:59 <davean> bernalex: its listed as "aes" in the feature flags of the CPU
10:35:08 <davean> bernalex: and they do have it
10:35:12 <Gal3rielol> it mentioned fran in the introduction
10:35:17 <Gal3rielol> "Functional Reactive Programming (FRP) was introduced by Elliott and Hudak [8] with their Haskell library Fran, an elegant and powerful way of modeling reactive animations."
10:36:10 <Gal3rielol> (I only have read the introduction section..
10:36:17 <sccrstud92_> Gal3rielol: it changes the semantics of fran
10:36:26 <sccrstud92_> i read the first half of that paper
10:36:29 <Gal3rielol> Sure it does
10:36:37 <sccrstud92_> i sort of stopped because i wasnt really feeling the api
10:36:49 <sccrstud92_> and the change they make
10:36:55 <sccrstud92_> while definitely justified
10:37:02 <sccrstud92_> doesnt sit well with me
10:37:15 <sccrstud92_> conal: have you read that FRPNow paper?
10:37:17 <davean> bernalex: http://ark.intel.com/compare/75992,52581 The instruction issue could be anythng in the set they don't share
10:37:26 <conal> sccrstud92_: no.
10:37:40 <sccrstud92_> okay
10:38:03 <davean> bernalex: this is really where you want a debugger
10:38:04 <wayne> hi
10:38:27 <bernalex> davean: yup, I see. sadly none available at the target
10:38:31 <wayne> i want to execute arbitrary user code. what kind of sandbox would make this as safe as possible? i'm happy to disallow certain imports and syscalls
10:38:35 <sccrstud92_> conal: i really like the part of your denotational semantics paper with the total map vs partial map bit
10:38:38 <bernalex> davean: got to go grab a bite. thanks a lot for trying to help!
10:38:41 <sccrstud92_> sort of blew my mind
10:38:44 <wayne> this will run on its own VPS
10:38:55 <davean> bernalex: No problem. Your best option is to setup a build env that only allows what the target allows
10:39:00 <davean> bernalex: a VM allows this easily
10:39:04 <conal> sccrstud92_: :D
10:39:11 <davean> bernalex: thats the easy way to be sure without tracking down the issue
10:39:26 <davean> bernalex: and without a debuger we'd be at this all day
10:39:42 <sccrstud92_> conal: is frp still your main focus? are we gonna see another paper soon?
10:40:26 <conal> sccrstud92_: no. frp hasn't been my focus for a while. maybe i'll return to it someday. more recently i was working on compiling haskell to hardware.
10:41:00 <wayne> i encountered https://github.com/gwern/mueval
10:41:03 <wayne> maybe i'll give it a shot
10:41:18 <conal> sccrstud92_: i'd like to write an accessible (but still precise) book on denotational design. i've been gradually collecting examples.
10:41:21 <Gal3rielol> may i know which paper it is?
10:41:36 <Clint> wayne: you should encourage a new release
10:42:35 <davean> conal: How goes compiling haskell to HW?
10:42:44 <davean> Clint: do you mean to like FPGA/ASIC?
10:43:28 <conal> davean: yes, like either. see http://begriffs.com/posts/2015-06-28-haskell-to-hardware.html and https://github.com/conal/talk-2015-haskell-to-hardware .
10:43:39 <hodapp> oooh!
10:43:57 <conal> davean: that project is on hold for now. my employer went under a few months ago. :/
10:45:51 <davean> conal: Is there code out there that does it?
10:46:26 <conal> davean: yes. see the github page readme
10:53:15 <verement> conal: just watched a video yesterday of you talking about compiling Haskell to hardware circuits. neat stuff
10:53:32 <conal> verement: :D
10:54:42 <verement> conal: where can I learn more about substituting lambdas with other primitives?
10:56:14 <conal> verement: if you mean the ccc vocabulary, you can google "lambda calculus and CCCs".
10:56:25 <verement> conal: great, thanks
10:58:45 <rui1> Easiest way to map a list of functions [f1, f2,...] to a value x and get a list [f1 x, f2 x,...]?
11:03:03 <fishythefish> rui1: [f1, f2, ...] <*> [x] comes to mind.
11:04:07 <erisco> there is strange behaviour with pattern matching in guards...
11:04:19 <bergmark> @type \x -> map ($ x)
11:04:20 <lambdabot> a -> [a -> b] -> [b]
11:04:37 <erisco> it seems that you cannot bind new variables in that manner
11:04:47 <erisco> also, trying this on lambdabot yields strange results
11:04:47 <erisco> > let f x | x <- Just y = y in f (Just 3)
11:04:49 <lambdabot>  y
11:04:51 <verement> rui1: map ($ x) [f1, f2, …]
11:05:04 <erisco> in ghc you'll just get that 'y' is not in scope
11:05:17 <bergmark> @type y
11:05:18 <lambdabot> Expr
11:05:28 <bergmark> it's a lambdabot thing
11:05:39 <erisco> I know, but it is incorrect behaviour
11:05:44 <erisco> at least it does not match ghc
11:05:50 <erisco> and furthermore why does ghc behave in that way
11:06:00 <rui1> fishythefish: Wonderful
11:06:04 <rui1> verement: Thanks!
11:06:05 <bergmark> erisco: it's just an import, nothing incorrect about it
11:06:27 <erisco> bergmark, what do you mean "just an import" ?
11:07:02 <erisco> > let f x | Just y <- x = y in f (Just 3)
11:07:04 <lambdabot>  ()
11:07:31 <erisco> I figured I might be writing the <- part backwards
11:07:36 <erisco> though this result from lambdabot is wrong too
11:07:43 <erisco> in ghci I get 3
11:08:07 <geekosaur> lambdabot has simple-reflect package installed
11:08:14 <geekosaur> and whatever module within it loaded
11:08:40 <geekosaur> I do kinda wish there were multiple contexts though
11:11:46 <erisco> how might you pattern match on a vector?
11:12:35 <sccrstud92_> erisco: vector from Data.Vector?
11:12:39 <erisco> yes
11:12:41 <rui1> Any built in that deletes an element of a list by position? Can't seem to find in Hoogle and the Data.List docs.
11:12:46 <rui1> remove n x = take (n-1) x ++ drop n x
11:13:18 <sccrstud92_> erisco: you cant match it directly because its an abstract data type
11:13:30 <shachaf> rui1: No.
11:13:38 <sccrstud92_> erisco: what behavior do you want to achieve?
11:13:41 <shachaf> Mostly because a list isn't very well suited to that operation.
11:13:42 <erisco> sccrstud92_, so? you can match Text directly, for example
11:13:53 <rui1> shachaf: Thx
11:14:25 <sccrstud92_> erisco: what extension do you use for that?
11:14:40 <erisco> OverloadedStrings
11:14:54 <sccrstud92_> erisco: then try OVerloadedLists
11:15:07 <sccrstud92_> still isnt pattern matching on vectors
11:15:24 <sccrstud92_> but might work for you
11:16:16 <erisco> oh yay I did not know that existed
11:16:26 <erisco> and why do you say it is not pattern matching on vectors?
11:17:15 <f-a> say I have a monad stack with 2 monads, monad a and monad b. Is there a way to, mh, expose just monad a to a function?
11:17:18 <sccrstud92_> erisco: because i think its the same as testing for equality using fromList
11:17:28 <sccrstud92_> like using a guard basically
11:17:32 <sccrstud92_> but im not postive
11:17:33 <erisco> disgusting :(
11:17:59 <f-a> i have a signature like :: a -> Stack (), but it occours to me that the function only needs Read 
11:18:01 <c_wraith> f-a: uh.  Maybe.  It depends quite a lot on what you actually mean.  What's an example of a type signature of a combinator that would do what you want?
11:18:21 <f-a> c_wraith: yeah, let me write something
11:18:29 <erisco> well the problem is that you are forced to nest your branches
11:18:33 <c_wraith> f-a: oh.  In that particular case, you can get away with going polymorphic, and adding a MonadReader constraint...  If I'm understanding you properly.
11:18:46 <erisco> like, say you have a tuple (Char, Vector Char) or whatever
11:18:51 <dominik1> has anyone recently played around with haskell-names and made the example program from https://github.com/haskell-suite/haskell-names work?
11:18:55 <sccrstud92_> erisco: its the same way with Text and overloaded strings, isnt it?
11:19:03 <dominik1> I'm currently struggeling in installing the global names package db.
11:19:10 <f-a> ohhh that is quite nice c_wraith 
11:19:12 <erisco> foo ('a', xs) | xs Vec.! 0 = ...
11:19:14 <f-a> a *very* nie trick
11:19:22 <erisco> now you have nested branching
11:19:35 <f-a> do you happen to know wether it is baked into RWS monad, c_wraith ?
11:19:37 <erisco> so your | otherwise case may just be repeat
11:19:49 <erisco> of all your other cases... foo ('b', xs), foo ('c', xs)
11:19:50 <erisco> and so on
11:20:04 <f-a> also, what would the other option be?
11:20:09 <c_wraith> f-a: yes, RWS is an instance of MonadReader
11:20:11 <erisco> sccrstud92_, no it isn't because then you can flatten the branch structure
11:20:35 <c_wraith> f-a: alternatively, there are options like the mmorph library for manipulating transformer stacks
11:20:36 <sccrstud92_> erisco: what branch structure?
11:20:39 <erisco> never mind
11:22:32 <f-a> thanks c_wraith , I'll look into that. Since I made my own monad stack I think I could even write some 'fake' typeclases (MystackRead a) to 'expose' just a few commands
11:22:40 <sccrstud92_> erisco: check out the ViewPatterns and PatternSynonyms extensions
11:23:06 <erisco> ehh that is maybe a bit too gnarly but I'll consider that if needed
11:23:11 <erisco> overloadedlists is sufficient
11:23:13 <sccrstud92_> erisco: they let you pattern match in new ways
11:23:16 <sccrstud92_> k
11:31:13 <erisco> dang I don't think the pattern matching is powerful enough :(
11:31:57 <sccrstud92_> erisco: what is ur use case?
11:33:02 * hackagebot al 0.1.4 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.4 (DimitriSabadie)
11:34:09 <erisco> hm, thankfully might be a more basic problem
11:35:24 <erisco> here is my error from ghci http://lpaste.net/135484
11:35:43 <erisco> I am loading this from file with OverloadedLists enabled
11:38:55 <geekosaur> erisco, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#idp24738272 looks relevant (since an Item creeps into the translation)
11:39:48 <bergmark> erisco: worksforme
11:40:20 <bergmark> erisco: do you have vector>=0.10.11.0?
11:40:50 <erisco> Installed versions: 0.10.9.1
11:41:31 <bergmark> erisco: then that's why
11:42:13 <erisco> good, thanks
11:42:31 <erisco> this helps greatly
11:43:46 <sinelaw> when to use foldl', and when to use foldr? assuming I don't need the structure-preserving properties and am 'squashing' anyway
11:46:04 <kuribas> How is this legal haskell?  https://github.com/haskell/haskell-mode/issues/712  The ',' in the Foo struct alligns with the layout.
11:46:29 <Peaker> sinelaw: if you build a "stream" of some kind to consume, whose consumption is tied to the consumption of the original list, use foldr.  If you build a squashed value, probably foldl'
11:46:38 <geekosaur> kuribas, braces disable layout
11:46:54 <geekosaur> even braces used for things like record syntax
11:47:14 <sinelaw> Peaker, k
11:47:22 <kuribas> geekosaur: you mean it "suspends" layout?
11:47:25 <Welkin> I often try to put the comma at the beginning of the line in other languages and I get a syntax error
11:47:31 <Peaker> sinelaw: (of course, if you need the right-associative semantics, you might be stuck with foldr :-) )
11:47:49 <kuribas> geekosaur: since layout is active after the '}'
11:48:14 <geekosaur> to the extent that you get layout back after the close brace, yes. but indentation is completely irrelevant while inside them (and there's no good way to "re-enter" layout within them)
11:49:06 <geekosaur> which is why one-line "do" blocks tend to break when you use let, because people assume the let re-introduces layout --- but it doesn't; the braces are mandatory
11:50:48 <ski> geekosaur : example ?
11:52:36 <geekosaur> do { x <- getLine; let y = length line; putStrLn ... }     will break because it still is parsing the (do-syntax; let-in works) let. only way to stop it is to brace the let
11:53:06 <geekosaur> it can't figure out where to put the implicit closing }. (perhaps it should just refuse to try, since it will always get a parse error...)
11:53:27 <geekosaur> basically it *wants* to work but does not
11:53:45 <ski> ok. i was thinking you perhaps meant something else
11:54:09 <kuribas> geekosaur: to be honest, that looks kind of ambiguous.
11:54:26 <geekosaur> it is ambiguous, which is the problem in a nutshell.
11:54:47 <dolio> It figures out where to put the closing }.
11:54:57 <geekosaur> haskell98 had a version of the brace rule that had even nastier ambiguities (two compilers could make different *syntactically valid* decisions about how to parse it)
11:55:08 <dolio> Well, actually, I guess in that case it doesn't figure it out correctly.
11:55:14 <kuribas> I would think that parses as do { x <- getLine; let {y = length line}; putStrLn ... }
11:55:18 <dolio> It probably should, according to the report.
11:55:26 <geekosaur> people do assume that, but in practice it doesn't
11:55:50 <geekosaur> otoh maybe this is a ghc bug and following the report strictly would work
11:57:25 <dolio> The report has specifications that are very hard to implement.
11:57:32 <gabre> hey
11:57:34 <dolio> Unless it's been relaxed in 2010.
11:58:01 <gabre> I have a problem using GLUT, I would like to render text to the screen but I dont know how to "move the cursor"
11:58:03 * hackagebot generic-deriving 1.8.0 - Generic programming library for generalised deriving.  http://hackage.haskell.org/package/generic-deriving-1.8.0 (JosePedroMagalhaes)
11:58:17 <gabre> I have tried translate but it seems that it isnt the thing I need
12:03:06 <osa1> does 
12:03:32 <osa1> does anyone know a tool to remove unused imports from file? I don't want anything editor specific
12:04:39 <moop> i don't think there is such a thing
12:04:49 <moop> not-editor-specific that is
12:05:15 <osa1> moop: do you know any vim specific ones? :)
12:05:23 <moop> nope sorry
12:06:04 <creichert> ghc itself has -ddump-minimal-imports
12:06:18 <creichert> there are tools that build on it, but i can't think up one off the top of my head
12:06:29 <osa1> wow, that's an interesting flag
12:07:03 <moop> osa1: https://github.com/jaspervdj/stylish-haskell ?
12:07:19 <osa1> I'm already using it, it doesn't remove unused imports
12:07:29 <moop> ah :(
12:07:35 <gabre> anybody anything with my GLUT renderString problem? :)
12:09:17 <creichert> osa1: http://hackage.haskell.org/package/fix-imports
12:09:32 <creichert> never tried it, though.
12:13:23 <lamefun> https://www.fpcomplete.com/blog/2015/05/secure-package-distribution - are the download instructions secure?
12:17:13 <osa1> creichert: thanks
12:18:04 * hackagebot neet 0.4.0.0 - A NEAT library for Haskell  http://hackage.haskell.org/package/neet-0.4.0.0 (hijiri)
12:21:38 <narendraj9> > reverse [1..10] 
12:21:39 <lambdabot>  [()]
12:21:45 <narendraj9> > reverse [1..10] :: [Int]
12:21:46 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
12:21:57 <narendraj9> ^^ Why?
12:22:28 <mniip> > fromInteger 1 :: ()
12:22:30 <lambdabot>  ()
12:22:43 <dolio> @undefine
12:22:43 <lambdabot> Undefined.
12:22:44 <mniip> looks like someone defined an instance
12:23:27 <wayne> why is it that haskell monads aren't necessarily monoids? i guess this is where FP diverges from math a little?
12:23:30 <erisco> > let f x | Just y <- x = y in f (Just 3)
12:23:31 <lambdabot>  3
12:23:34 <erisco> ah ha
12:23:46 <narendraj9> Okay. I see.
12:24:59 <narendraj9> wayne: It's like you have a knife, you can use it as a spoon. But then you would be abusing it, not using it. 
12:25:27 <narendraj9> Oh wait.
12:25:35 <narendraj9> I am wrong. Monads and Monoids.
12:25:44 <narendraj9> How are they related?
12:26:59 <rhaps0dy> they can be combined with themselves (not to be confused with each other)
12:27:23 <wayne> maybe monoid has multiple meanings
12:27:44 <rhaps0dy> within Haskell? not likely
12:27:47 <wayne> i.e. the haskell monoid might be at a different level of abstraction than what some others mean
12:28:09 <wayne> well, between haskell and category theory
12:28:20 <wayne> not sure i'm not great at either.
12:28:22 <rhaps0dy> Ah
12:28:32 <rhaps0dy> I don't know almost anything about category theory ._.
12:28:43 <rhaps0dy> monoids are always monads in there?
12:29:24 <rhaps0dy> monoids are not always monads because the language provides no way to enforce this.
12:29:51 <rhaps0dy> Similar to how monads are not always part of Applicative too (this has recently changed, now GHC complains, but it's not part of the language spec afaik)
12:30:12 <wayne> well, some say monads are always monoids in math. and this could probably be true for a more abstract definition of monoid
12:30:36 <wayne> i.e. a definition outside of haskell, which would make me better understand this confusing situation
12:30:41 <rhaps0dy> ok let's look at the typeclasses for a moment
12:30:54 <wayne> in haskell, you can have a monad that's not a monoid
12:30:55 <rhaps0dy> oh wait, there IS a way to enforce that in the language
12:31:05 <wayne> well, idk
12:31:06 <wayne> can you?
12:31:23 <wayne> because it looks like you could. in fact there's a typeclass MonadPlus that sort of hints at monoidal behavior
12:31:29 <gabre> http://pastebin.com/VS982rQb this way I was able to move that String in GL if somebody interested but it may be one of the worst and ugliest hacks at the present
12:31:46 <shachaf> In Haskell, nothing can be an instance of both Monad an Monoid.
12:32:05 <dolio> As far as the Haskell type classes go, there is no connection between Monad and Monoid.
12:32:19 <dolio> In category theory, monads are monoids, and monoids are monads.
12:32:23 <wayne> okay that's what i thought, thanks dolio
12:32:30 <narendraj9> I think he is talking about this: https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
12:32:33 <dolio> Given the right definitions.
12:32:48 <wayne> narendraj9: haha i enjoyed that, but i've heard this in other places too
12:32:49 <narendraj9> I don't understand it. I have tried.
12:33:01 <wayne> yeah dolio, that was my hunch
12:33:05 * hackagebot hset 0.1.1 - Primitive heterogenous read-only set  http://hackage.haskell.org/package/hset-0.1.1 (AlekseyUymanov)
12:33:12 <wayne> that the definitions change as you move to a different domain
12:33:21 <wayne> so that can be the cause of much confusion
12:33:22 <fishythefish> dolio, should probably clarify which monoids are monads.
12:33:33 <dolio> All of them.
12:33:39 <fishythefish> Wait, really?
12:33:57 <narendraj9> How are integers monads?
12:34:12 <dolio> I could tell you, but it might not mean anything to you.
12:34:40 <fishythefish> Go for it.
12:34:41 <wayne> shachaf: what about lists?
12:34:46 <dolio> If you have a monoidal category with a monoid object, you can construct a 2-category with one 0-cell, and that monoid object will be a monad in that 2-category.
12:34:53 <shachaf> wayne: What about lists?
12:35:05 <fishythefish> OH
12:35:09 <wayne> 193124 < shachaf> In Haskell, nothing can be an instance of both Monad an Monoid.
12:35:21 <wayne> aren't lists a counter example?
12:35:27 <shachaf> A list is a value, so it's not an instance of anything.
12:35:46 <fishythefish> dolio, yeah, that's actually pretty "obvious" now that you mention it.
12:35:47 <shachaf> [] is an instance of Monad, and [a] is an instance of Monoid for any a.
12:36:00 <wayne> ah thanks for the clarification
12:36:17 <wayne> which is probably also the tricky part between MonadPlus and Monoid
12:36:43 <Moggle> I implemented a ctrl+c handler with System.Posix.Signals and sigTERM/sigINT, but the issue now is that the program doesn't *end* after ctrl+c is hit. I have tried using System.Exit and exitSuccess, but this too doesn't actually end the program.
12:36:57 <Moggle> What's the cleanest way to finish things?
12:38:19 <fishythefish> dolio, BTW, where does most of your category theory knowledge come from?
12:39:01 <dolio> Reading stuff. Books, papers, nlab.
12:39:21 <dolio> Talking to other people, too.
12:39:32 <fishythefish> Gotcha.
12:39:40 <fishythefish> That's partly why I'm trying to spend more time here. :)
12:39:48 <wayne> i think wikipedia is the shittest place to learn math
12:40:13 <wayne> definitely not catered to newcomers, but excellent as a reference
12:40:29 <wayne> and that's what it sets out to do so no beef with that
12:40:31 <Gal3rielol> http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
12:40:44 <Gal3rielol> I recommend this series.
12:41:17 <fishythefish> Gal3rielol, yeah, I started reading that.
12:41:42 <fishythefish> I know a little category theory from where it applies to my math major
12:41:48 <fishythefish> but my school doesn't focus on it heavily for undergrads
12:43:51 <Moggle> the solution, if anyone was interested, was the bottom here http://stackoverflow.com/questions/13441676/how-to-write-ctrl-c-handler-in-haskell
12:44:02 <Moggle> needed the original thread id too, the handler makes a new thread.
13:07:54 <moop> !where learn
13:07:58 <moop> >where learn
13:08:02 <moop> ffs
13:08:04 <moop> @where learn
13:08:04 <lambdabot> https://github.com/bitemyapp/learnhaskell | http://www.seas.upenn.edu/%7Ecis194/spring13/index.html | https://github.com/NICTA/course/
13:08:14 <medfly> what is cool in the haskell-lands besides lens? I've learned abotu FRP and want to learn more cool Haskell-person stuff.
13:08:43 <medfly> all the buzz.
13:09:19 <kuribas> medfly: https://ocharles.org.uk/blog/pages/2014-12-01-24-days-of-ghc-extensions.html
13:09:21 <Peaker> medfly: QuickCheck is cool
13:09:28 <medfly> it is!
13:09:33 <Peaker> medfly: STM is cool
13:09:37 <Peaker> medfly: Parallel strategies are kinda cool
13:09:58 <bernalex> parsers and dsls are cool
13:10:13 <bernalex> building big programs is also neat
13:10:15 <medfly> what's dsls because I won't even be able to google that
13:10:27 <kuribas> medfly: accelerate for gpu programming.
13:11:02 <medfly> oh god these names are getting ridiculous I thought you were explaining what dsls are
13:11:06 <medfly> hahaha
13:11:41 <bernalex> medfly: dsl = domain specific language. haskell has some properties that make it especially nice to use for that purpose.
13:11:49 <whiteline> parsec has basically replaced grep golf for me
13:12:24 <bernalex> haskell has almost ironically cool regex libs
13:12:51 <Moggle> what's that one thing you do to make things instances of typeclasses outside of their original files?
13:12:58 <Moggle> data.xml.types doesnt have read instances
13:13:16 <bananagram> none of them have a perl-style substitution function that works though
13:13:25 <bernalex> Moggle: what do you mean? you just do it
13:13:48 <Moggle> bernalex, i'm 99% sure you can't declare something an instance of a typeclass outside the original file, something like... orphaned instances?
13:13:53 <bananagram> regex-compat-tdfa does, but it doesn't have all the perl syntax
13:14:18 <bernalex> Moggle: IIRC you can do it all you'd like, it will just warn you about OrphanInstances, which you can no-warn.
13:14:39 <Moggle> i'll give it a try the, thanks!
13:14:53 <bernalex> Moggle: if I remember it wrong, it's probably an extension, -XOrphanInstances, which you need to enable.
13:17:32 <mizu_no_oto> Are there any good intro programming texts written in Haskell?
13:17:59 <mizu_no_oto> i.e. the sort of thing you'd give to someone who hasn't yet taken *any* programming courses
13:18:02 <whiteline> learn you a haskell
13:18:05 <bernalex> mizu_no_oto: I think Programming in Haskell is for that?
13:18:07 <nkaretnikov> whiteline: no!
13:18:11 <bernalex> whiteline: that *really* is not for that. at all.
13:19:03 <whiteline> really? i thought it was quite intuitive. there are "intro to ruby" tutorials in the same vein for example
13:19:23 <nkaretnikov> mizu_no_oto: maybe it'd be easier to start with sicp first?  read a few chapters at least
13:19:27 <bernalex> whiteline: maybe you are really smart. or weird. lyah pretty much assumes you know at the very least basic imperative programming.
13:19:46 <bernalex> nkaretnikov: sicp is kind of harsh in today's culture without a tutor imo.
13:19:47 <nkaretnikov> mizu_no_oto: folks seem to recommend the little schemer series, too, but I don't have any personal experience with it
13:19:58 <whiteline> bernalex: well i certainly knew imperative programming before reading it but it didn't seem like it required it
13:20:58 <whiteline> sicp on the other hand is useless unless you're actually willfully trying to get an intro to applied computer science. it doesn't represent what most people think of as "programming"
13:21:09 <nkaretnikov> mizu_no_oto: note that there are also things like the ecosystem: picking an editor, learning the terminal and build tools, etc.
13:21:20 <nkaretnikov> whiteline: wat
13:21:27 <mizu_no_oto> nkaretnikov: this is for my girlfriends younger sister
13:21:45 <bernalex> mizu_no_oto: I would wholeheartedly recommend tutoring her a bit
13:21:50 <whiteline> and i'm saying that as someone currently using sicpv2 to implement a scheme in hs
13:21:55 <bernalex> mizu_no_oto: figure out if she's enjoying the material, help her when she gets stuck, etc.
13:22:03 <nkaretnikov> whiteline: it teaches algorithm analysis, for instance, how is that not useful?
13:22:45 <whiteline> nkaretnikov: i didn't say it wasn't useful, i said it doesn't teach you how to immediately do things using existing tools
13:22:49 <mizu_no_oto> bernalex: that's what I figured I'd do, but I think it would be useful for her to have a text to work through and then ask me questions when she's confused/stuck
13:23:08 * hackagebot hset 0.1.2 - Primitive heterogenous read-only set  http://hackage.haskell.org/package/hset-0.1.2 (AlekseyUymanov)
13:23:12 <nkaretnikov> mizu_no_oto: maybe ask on #haskell-beginners?
13:23:15 <bernalex> mizu_no_oto: you should evaluate them yourself, but check out Programming in Haskell and maybe you could extend
13:23:18 <bernalex> @where learnhaskell
13:23:18 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:23:23 <bernalex> a bit to make it more suitable for her?
13:24:49 <nkaretnikov> mizu_no_oto: it also may be important to get her excited about programming first.  some try to do it by showing how to program games
13:25:15 <nkaretnikov> mizu_no_oto: or maybe just automating repetitive stuff, like renaming a bunch of files in a directory 
13:25:32 <nkaretnikov> it's useful and doesn't require a lot of code
13:26:20 <whiteline> but games also suffer from complexity and the requirement of being creative. i'd use basic visualization, or perhaps basic network programming if she feels excited about IT in general
13:26:32 <bernalex> nkaretnikov: kids tend to like shapes ad movement
13:26:39 <bernalex> dependign on how old she is, maybe you could show her elm?
13:26:44 <bernalex> *depending
13:26:47 <whiteline> you want quick power with a minimum of up-front learning
13:26:56 <bernalex> it's easier to get something graphical and pretty up in elm
13:27:09 <bernalex> and you can put use share-elm and she can show all her friends the cool stuff she made
13:27:16 <mizu_no_oto> I was thinking of using codeworld, but elm is a great idea
13:27:25 <bernalex> (no idea how old this girl is btw -- sorry if I'm talking about a 35yo as if she were 6, lol)
13:27:36 <lamefun> https://www.fpcomplete.com/blog/2015/05/secure-package-distribution - are the instructions secure (they seem to be using the insecure cabal-install)?
13:27:43 <mizu_no_oto> She's going to be a sophmroe in college
13:27:53 <mizu_no_oto> and is thinking of transferring to CS
13:28:11 <bernalex> oh ok then maybe a nice mix between shapes and moving things -- and actual cs would be nice.
13:28:20 <bernalex> don't want to deceive her into thinking everything smells of roses.
13:28:32 <mizu_no_oto> heh
13:28:34 <bernalex> maybe do an arcade game in pong?
13:28:38 <bernalex> just bouncing ideas aroud
13:28:41 <whiteline> mizu_no_oto: why does she want to transfer?
13:28:42 <bernalex> *around
13:28:49 <whiteline> is she a math head or a techie
13:28:51 <bernalex> eh
13:28:55 <bernalex> s/pong/gloss/
13:29:05 <Peaker> is there a non-leaking WriterT on hackage? Maybe I should upload one
13:29:06 <bernalex> pong being the canonical arcade game of course :p
13:29:18 <bernalex> Peaker: state monad? lol
13:29:33 <Peaker> bernalex: I mean as a wrapper to StateT
13:29:57 <mizu_no_oto> whiteline: her initial major was bio, but there's more jobs in CS and the CS majors that she knew at school said that she'd be good at it
13:29:59 <bernalex> Peaker: ah
13:30:20 <whiteline> mizo_no_oto: then go with SICPv2
13:30:37 <bernalex> whiteline: I'm not so sure
13:30:47 <nkaretnikov> what's SICPv2?  is it in python?
13:30:55 <bernalex> mizu_no_oto: maybe find out what literature they actually use at the CS courses there?
13:31:02 <whiteline> nope, just an updated version
13:31:10 <bernalex> nkaretnikov: scheme.
13:31:12 <whiteline> it's scheme, not the new MIT python course
13:31:36 <sccrstud92_> Peaker: whats the issue with WriterT?
13:32:04 <nkaretnikov> mizu_no_oto: or maybe just ask her?  there's probably something that she wants to do.  
13:32:04 <Peaker> http://hackage.haskell.org/package/stateWriter <-- does it right!
13:32:15 <mizu_no_oto> fair enough
13:32:18 <Peaker> sccrstud92_: it associates the mappends in a way that forces it to leak memory in every >>=
13:32:19 <bernalex> sccrstud92_: wow such lazy
13:33:59 <Peaker> sccrstud92_: it keeps the left action result around just so it can remember to mappend it when the right action is done. If the right action is "big", you leak. Only if all binds are right-associative and all "left" actions are very small, then the leak is insignificant
13:34:40 <whiteline> i've written monadic code like that but i never thought it was a good idea
13:34:45 <Peaker> oops: the last sentence is reverse-ordered :)
13:35:09 <Peaker> whiteline: Associativity of binds is really an implementation detail and "controlling" it necessarily breaks modularity
13:35:49 <Peaker> if you use StateT with mappend instead of WriterT-tuples, there's no problem/leak
13:36:18 <sm> bananagram: correct (no regex replace), which sucks. I made one that does \1 etc.
13:36:29 <sccrstud92_> Peaker: so the fix is to implement it the same as StateT, but expose a writer interface?
13:40:48 <Peaker> sccrstud92_: yeah
13:50:46 <japesinator> so I am using Aeson and curl
13:51:17 <dgpratt> for all the problems I've had building stuff on Windows due to paths exceeding MAX_PATH, I'm surprised more people aren't running into the same thing
13:51:37 <japesinator> and when I use CurlPostFields [show . encode $ x] to post JSON-encoded data, I get "invalid request"
13:51:46 <dgpratt> it seems using sandboxes excacerbates the issue, maybe that's why
13:52:03 <japesinator> but when I just paste in the string I get from "encode x" in the repl, it works
13:52:12 <japesinator> what am I doing wrong?
13:53:13 <dmj`> > show ("foo" :: ByteString)
13:53:14 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
13:53:14 <lambdabot>      Perhaps you meant one of these:
13:53:14 <lambdabot>        ‘BSC.ByteString’ (imported from Data.ByteString.Char8),
13:53:23 <dmj`> > show ("foo" :: BSC.ByteString)
13:53:25 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
13:53:25 <lambdabot>                  with actual type ‘[Char]’
13:53:25 <lambdabot>      In the first argument of ‘show’, namely ‘("foo" :: BSC.ByteString)’
13:53:50 <Denommus> :t show
13:53:51 <lambdabot> Show a => a -> String
13:53:53 <dmj`> > show (BSC.pack "foo" :: BSC.ByteString) 
13:53:55 <lambdabot>  "\"foo\""
13:54:00 <dmj`> japesinator: ^
13:54:34 <japesinator> dmj`: so how can I give curl a string without the escaping?
13:54:40 <dmj`> japesinator: try unpack instead show
13:55:01 <dmj`> > BSC.unpack "foo" :: BSC.ByteString
13:55:02 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
13:55:02 <lambdabot>                  with actual type ‘[Char]’
13:55:02 <lambdabot>      In the expression: BSC.unpack "foo" :: BSC.ByteString    Couldn't match ...
13:55:10 <dmj`> > BSC.unpack ("foo" :: BSC.ByteString)
13:55:11 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
13:55:12 <lambdabot>                  with actual type ‘[Char]’
13:55:12 <lambdabot>      In the first argument of ‘BSC.unpack’, namely
13:55:29 <shachaf> Please use /msg lambdabot.
13:55:41 <dmj`> shachaf: I'm trying to demonstrate to japesinator
13:56:01 <shachaf> Demonstrate lambdabot errors?
13:56:12 <japesinator> dmj`: now I can't match [Word8] with [Char]
13:57:52 <japesinator> I can find some stuff on hayoo, but it looks unsafe and is gonna add dependencies
13:57:55 <japesinator> is there a good way?
13:58:27 <Phillemann> Curious, despite the far out title, "Clowns to the Left of me, Jokers to the Right" gives absolutely no Haskell/CompSci results :D
13:58:37 <Phillemann> (Googling that, I mean)
14:00:00 <dmj`> shachaf: :) 
14:00:16 <dmj`> japesinator: use Data.ByteString.Char8
14:01:45 <dolio> Phillemann: That's not very surprising unless you added additional keywords that would restrict it to comp sci results.
14:01:46 <dmj`> japesinator: there's better http-client libs out there besides curl
14:02:19 <kadoban> japesinator: Note that the difference between those two isn't just a technicallity. Word8 is 8-bit numbers, with no particular inherent meaning. Char is unicode characters
14:02:48 <kadoban> japesinator: If you want to convert one to the other, you need to decode/encode, and pick an encoding (or use a default possibly)
14:07:28 <japesinator> dmj`: thanks so much, it worked!
14:07:58 <japesinator> and I actually started out with wreq, but I couldn't figure out how to emulate curl -k, and only needed a couple requests, so I went with curl
14:09:21 <dmj`> japesinator: solid
14:14:55 <Moggle> how can i derive show/read for an instance in a library which does not have it?
14:15:14 <Moggle> trying to figure out the syntax, and i'm a bit lost because as far as i can tell i can't using 'deriving'?
14:17:04 <lpaste_> f-a pasted “typeclasses problems” at http://lpaste.net/135505
14:19:02 <Peaker> f-a: you could use type families with an equality constraint or multi-param type-classes
14:19:15 <EvanR> And theres no bijective mapping between Char and Word8
14:19:31 <Peaker> Word8 has 256 values, Char has many more
14:19:49 <EvanR> like, a million
14:20:14 <f-a> thanks Peaker
14:20:46 <Eduard_Munteanu> f-a, the 'x' in 'Baz x a' and 'Foo x y a' isn't the same. Perhaps you want to parametrize your 's' further.
14:21:37 <f-a> Eduard_Munteanu: yeah it is not the same. What should I change though? My typeclass definition?
14:21:40 <Eduard_Munteanu> f-a, or add 'x' as a class parameter and a fundep s -> x
14:22:20 <Eduard_Munteanu> f-a, yes
14:22:50 <f-a> Eduard_Munteanu: in that case I would need multiparameter type classes, right?
14:23:01 <Eduard_Munteanu> class Bar s x | s -> x where f :: Baz x a -> s a
14:23:08 <Eduard_Munteanu> f-a, yes, or type families
14:23:16 <Peaker> type families are considered nicer, I think
14:23:30 <shachaf> Depends.
14:23:35 <f-a> that was the question I was going to ask: which one should I research first
14:23:49 <Eduard_Munteanu> class Bar s where { type X s; f :: Baz (X s) a -> s a }
14:24:32 <Moggle> for those curious about the answer, GHC has the StandaloneDeriving extension.
14:24:38 <Moggle> how handy.
14:26:33 <meretrix> Is it possible to make "Data.Time.getCurrentTime :: IO UTCTime" use lazy IO?
14:26:47 <Peaker> meretrix: why would you want to do such a thing?
14:27:10 <Eduard_Munteanu> What would be lazy about it?
14:27:39 <meretrix> Peaker: Mainly just curious.  I'm calling it many, many times in a loop, but only rarely use it.
14:28:08 <meretrix> So in theory, if it were lazy, I would need to run that system call most of the time.
14:28:11 * hackagebot multiset 0.3.0 - The Data.MultiSet container type  http://hackage.haskell.org/package/multiset-0.3.0 (TwanVanLaarhoven)
14:28:34 <meretrix> *not need to run
14:28:38 <Peaker> meretrix: that's a bad idea -- just avoid calling it when you don't need it?
14:29:09 <Peaker> meretrix: can you show your code?
14:29:13 <Moggle> i'm trying to put my orphan instances in one file - what's the best name for that kind of file?
14:29:19 <Moggle> 'common'? 'instances' seems weird
14:29:42 <shachaf> .Instances has precedent.
14:29:46 <Eduard_Munteanu> .Instances is common.
14:29:59 <meretrix> Peaker: Basically it's a large pure event processing loop.  For a few event types, I want to know the current time, but for most I don't need it.
14:30:00 <Eduard_Munteanu> (no pun intended)
14:30:44 <kadoban> .Orphanage
14:31:28 <Moggle> hah
14:31:33 <Moggle> i laughed at the orphanage one
14:31:33 <meretrix> I was really just curious if it's possible to make an arbitrary IO function lazy.
14:31:41 <Moggle> thanks shacaf/Eduard_Munteanu, I'll do that.
14:32:50 <Eduard_Munteanu> :t unsafeInterleaveIO $ repeatM getCurrentTime
14:32:51 <lambdabot> Not in scope: ‘unsafeInterleaveIO’
14:32:52 <lambdabot>     Not in scope: ‘repeatM’
14:32:52 <lambdabot>     Perhaps you meant one of these:
14:33:22 <meretrix> Thanks, I'll try that.
14:33:38 <meretrix> Or what about a infinite [UTCTime] list? Is that possible?
14:33:39 <Eduard_Munteanu> Not a good idea, really.
14:33:55 <Eduard_Munteanu> meretrix, that is an infinite list
14:34:02 <meretrix> ah ok
14:34:14 <meretrix> Isn't that a common thing to do with random number generators?
14:34:29 * hodapp observes that 'meretrix' is Latin for 'prostitute'.
14:34:38 <meretrix> indeed 
14:34:44 <hodapp> yay high school!
14:34:54 <Eduard_Munteanu> meretrix, no, fully deterministic PRNGs
14:35:03 <meretrix> ah, right
14:36:19 <Eduard_Munteanu> meretrix, for those, you get a seed via normal IO then iterate the generator which is pure code
14:41:12 <osa1> does cabal create sandbox files in <dir> if I just add <dir> as source using cabal sandbox add-source?
14:41:35 <Denommus> osa1: no
14:50:07 <Moggle> is there a difference between data.xml.types and text.xml?
14:50:23 <Moggle> i mean
14:50:25 <Moggle> besides one having parsing
14:50:33 <Moggle> it seems like the data structures are direct copies, even.
14:50:59 <Moggle> aha it says they are re-exported
14:51:06 <Moggle> well hopefully xml-lens works then
14:57:36 <Peaker> meretrix: just get the time in the particular event handlers?
15:04:20 <Profpatsch> How do I parse a line in Parsec without falling into the “anyChar is greedy”-trap?
15:05:09 <mauke> anyChar is not greedy. it parses exactly one char
15:06:33 <Profpatsch> mauke: Okay, X Y problem.
15:06:34 <monochrom> consider "noneOf"
15:06:54 <DNoved1> many (noneof "\n") <* char '\n'
15:07:17 <DNoved1> I think
15:07:21 <Profpatsch> I want to parse a line into one Constructor, if it contains two spaces in a row.
15:07:35 <Profpatsch> And into another if it contains no two spaces in a row.
15:08:03 <Profpatsch> My first try was
15:08:14 * hackagebot base-orphans 0.4.0 - Backwards-compatible orphan instances for base  http://hackage.haskell.org/package/base-orphans-0.4.0 (ryanglscott)
15:08:44 <Profpatsch> x <- many anyChar; string "  "; y <- many anyChar; return $ Con (x ++ "  " ++ y)
15:09:01 <Profpatsch> But that obviously doesn’t work.
15:09:58 <Profpatsch> DNoved1 monochrom I‘d rather use endOfLine; is there something like noneOf for Parsers?
15:11:03 <DNoved1> noneOf is for Parsers, it's in Text.Parsec.Char
15:11:12 <monochrom> I don't understand the question. it seems to contain self-contradictions.
15:11:37 <Profpatsch> I mean for Parser a instead of [Char]
15:11:47 <Profpatsch> noneOf is only for single Chars.
15:12:15 <Profpatsch> But how do I say: This parser if that parser doesn’t hold?
15:12:36 <Profpatsch> Do I use notFollowedBy?
15:13:18 <Profpatsch> many (anyChar `notFollowedBy` endOfLine) ?
15:13:45 <Profpatsch> But that looks to me like everything but the last char of the line and then \n(\r)
15:16:33 <DNoved1> You want a line with any characters, and if that line contains two spaces in a row in it, it goes into one constructor, otherwise a different one, right?
15:16:41 <Profpatsch> DNoved1: Yeah.
15:17:27 <DNoved1> Why not parse a line with (many (noneOf "\n") <* endOfLine), then in an if expression inspect if that line has two spaces?
15:17:42 <monochrom> if you understand "many anyChar", you certainly understand "many (noneOf ['\n'])", too.
15:18:03 <monochrom> and yes, detect the two-space thing afterwards
15:18:04 <DNoved1> Like 'if "  " `subset line then Ctor1 line else Ctor2 line', assuming some function subset
15:18:11 <Profpatsch> DNoved1: Oh. :)
15:18:21 <Profpatsch> That’s indeed kind of trivial.
15:18:32 <Profpatsch> monochrom: But why is noneOf only for Chars?
15:18:48 <monochrom> the same reason why anyChar is only for Chars.
15:19:14 <Profpatsch> monochrom: I have endOfLine, why can’t I say something like many (anyChar `not` endOfLine)?
15:19:22 <monochrom> "anyChar" has pretty much the same type as "noneOf ['\n']"
15:19:36 <Profpatsch> or many (anyParser `not` otherParser)
15:19:56 <monochrom> there is no "not"
15:19:59 <Profpatsch> The API of Parsec is kind of strange.
15:20:12 <Profpatsch> I know. But how do I emulate it.
15:20:15 <monochrom> it looks to me a monadic parser cannot provide "not"
15:20:43 <Profpatsch> Maybe a combination of try and notFollowedBy
15:20:44 <monochrom> it is a limitation of "has to be a monad"
15:20:58 <monochrom> no, that doesn't cut it
15:21:16 <monochrom> "not" is possible for an applicative, non-monadic parser
15:21:35 <Profpatsch> Hm, not sure. Maybe.
15:22:06 <Profpatsch> But can an appl. parser do context-sensitive?
15:22:21 <c_wraith> yes...  So long as it's over a finite alphabet
15:22:22 <monochrom> very likely not
15:22:37 <c_wraith> Because you can create an infinite-size parser lazily
15:22:38 <Profpatsch> Can a monadic parser?
15:22:43 <Algosapien> Hi how is comparision of Lists in haskell done?  I had tries in GHCI  with as example as follows : [3,2,1] > [2,10,100] and it had given me the result as TRUE... how is this TRUE?
15:22:44 <monochrom> yes
15:22:46 <c_wraith> much more easily
15:22:53 <Profpatsch> ok
15:23:01 <monochrom> a monadic parser is pretty much Turing complete
15:23:14 <EvanR> Algosapien: lexicographic ordering
15:23:15 <c_wraith> Algosapien: lexicographic ordering
15:23:20 <c_wraith> darn it, I was too slow
15:23:23 <monochrom> precisely because it's Turing-complete, to ask for "not" you run into an undecidable problem
15:23:54 <Profpatsch> monochrom: Because the part after the not can be anything?
15:23:56 <c_wraith> Algosapien: for the same reason "mba" > "lyz"
15:24:16 <monochrom> yes. it can be any Turing machine
15:24:24 <Profpatsch> monochrom: In the sense of anything turing complete.
15:25:05 <breadmonster> Hello.
15:25:20 <Profpatsch> I should probably read into Turing-Completeness more.
15:25:58 <Profpatsch> There even is a Master course on it. But I’m not sure I want to fight through that.
15:26:14 <Algosapien> So is it like only the head is compared between the two lists?
15:26:19 <monochrom> it's even worse. even if you just ask, "does this parser reject newline upon sight?", it can't be answered.
15:26:42 <monochrom> whereas there is a way to set up an applicative parser library that can answer that question
15:26:47 <kadoban> Algosapien: It compares one-by-one until it finds one that's different, or one ends. It's the ordering you see in the dictionary, essentially.
15:27:24 <Profpatsch> monochrom: you mean for an arbitrary parser.
15:28:01 <Profpatsch> noneOf ["\n" "\r"] would be clear I think. :)
15:28:11 <monochrom> be careful with "arbitrary".
15:28:15 * hackagebot prompt 0.1.0.0 - Monad (and transformer) for deferred-effect pure  prompt-response queries  http://hackage.haskell.org/package/prompt-0.1.0.0 (jle)
15:28:35 <Profpatsch> monochrom: In which sense?
15:28:43 <monochrom> an applicative, non-monadic parser library lives under severe restrictions. its "arbitrary" will not be very arbitrary.
15:29:09 <Profpatsch> monochrom: Okay, I meant an arbitrary monadic parser.
15:29:27 <monochrom> I think I answered that.
15:29:27 <Profpatsch> Can you answer any questions about an arbitrary monadic parser?
15:29:39 <Algosapien> So in this example [3,2,1] > [2,10,100]     3 is compared with 2 ; 2 with 10 and 1 with 100?
15:29:49 <Profpatsch> Except that it’s an arbitrary monadic parser. :)
15:30:02 <monochrom> I can answer trivial questions about monadic parsers.
15:30:04 <Moggle> Algosapien, 3 is compared with 2, 3 is higher, so > is true.
15:30:41 <Moggle> is you did [3,2,1] > [3,10,100], it would do 3 compared with 3, find they're equal, then do 2 compared with 10, and find 10 > 2, so the original > is false.
15:30:41 <jle`> Algosapien: for lists, it's lexicographic
15:30:42 <Profpatsch> monochrom: What would be considered trivial?
15:30:45 <jle`> like "dictionary ordering"
15:30:59 <jle`> "hello" < "hey"
15:31:10 <jle`> > "hello" < "hey"
15:31:11 <lambdabot>  True
15:31:20 <jle`> > "hello" > "hah"
15:31:21 <lambdabot>  True
15:31:28 <Algosapien> but when 2 is compared with 10 ; 2 is less than 10 and it should be false
15:31:32 <jle`> it checks the items in order until it's different
15:31:39 <Welkin> > "hallo" <=> "hallo"
15:31:40 <Algosapien> how is the result true?
15:31:40 <lambdabot>      Not in scope: ‘<=>’
15:31:41 <lambdabot>      Perhaps you meant one of these:
15:31:41 <lambdabot>        ‘<$>’ (imported from Control.Applicative),
15:31:42 <Moggle> it doesn't check 2 with 10.
15:32:06 <Moggle> Algosapien, the way it works is it compares the first elements. if they are equal, THEN it checks the next element. and so on.
15:32:18 <Moggle> This is called lexographic comparison.
15:32:20 <jle`> Algosapien: first in "hello" vs. "hey", it checks h and h, they're equal; then it checks "e" with 'e', and they'r equail
15:32:28 <jle`> and then it checks 'l' and 'y', and 'y' is bigger
15:32:40 <jle`> like dictionary ordering
15:33:22 <jle`> what comes first in the dictionary, "alphabet" or "alphanumeric" ?
15:33:22 <Profpatsch> Welkin: As in Welkin Gunther?
15:33:52 <jle`> you check a with a, l with l, p with p, h with h, a with a, b with n.  so alphabet comes first
15:34:03 <jle`> because the first "different" part is b & n, and b is before n
15:34:09 <Moggle> Algosapien, http://lpaste.net/135509
15:34:40 <jle`> what comes first, [1,2,3,5] or [1,2,4,5]?  you check 1 with 1, then 2 with 2, then 3 with 4... and 3 is less than 4, so the first one is first
15:35:51 <Algosapien> okay so in my example [3,2,1] > [2,10,100] as the first comparision  is between  3 and 2 and the result is "True" , further comparision is not done .Am I correct?
15:36:00 <jle`> yes
15:36:08 <jle`> like for example, "aardvark" with "zebra"
15:36:13 <jle`> you check the a and the z, then you're done
15:36:23 <jle`> you don't have to check the next a and the e, or the next r and the b
15:36:29 <jle`> you don't care that the fourth letter is 'd'
15:36:39 <jle`> you just need to check the first letters and you already know which comes first :)
15:37:09 <jle`> > "aardvark" > "zebra"
15:37:10 <lambdabot>  False
15:37:11 <Algosapien> okay thanks!
15:37:23 <jle`> np!
15:40:01 <dmj`> jle`: ! 
15:40:12 <jle`> !
15:41:09 <Algosapien> How is this true ? [3,4,2] > [3,4]       ;   3 compared with 3 ; 4 with 4 and 2 compared with what?
15:41:41 <Ralith> Algosapien: it's lexicographical, not elementwise
15:41:42 <shachaf> [2] compared with []
15:42:25 <jle`> Algosapien: what comes first in the dictionary: "hi" or "hill"?
15:43:12 <Algosapien> hi comes first
15:43:36 <jle`> yeah. if there are no more things to compare, the shorter one comes first
15:43:47 <jle`> so [3,4] comes before [3,4,2]
15:44:17 <Algosapien> okay got it ! thanks that was a good example :)
15:44:40 <jle`> np!
15:44:44 <bergmark> also think how confusing it would be if it was the opposite!
15:49:01 <ttt_fff> who is the most badass hackage-er who is using livecoding.tv ? I want to see how haskell code is written
15:50:23 <erisco> never heard of livecoding.tv
15:50:35 <erisco> I could probably run the most boring channel on there though
15:51:03 <bergmark> mine would also be surprisingly boring atm
15:51:26 <erisco> 90% of the time nothing would be happening because I am somewhere else just thinking :P
15:53:50 <erisco> ttt_fff, what do you want to program?
15:54:09 <ttt_fff> I just want to watch haskell exxperts, say emmetk write code
15:54:21 <ttt_fff> I want to learn from how they write haskell
15:54:41 <erisco> are you a beginner or intermediate?
15:55:22 <dmj`> ttt_fff: reading the source has a similar effect
15:55:41 <ttt_fff> it's like looking at the sistine chapel
15:55:45 <ttt_fff> vs watching michangelo paint it
15:55:57 <erisco> its just, you're going to see super esoteric stuff most of the time
15:56:05 <jle`> i can see the novelty in it though
15:56:05 <erisco> if you look at what the experts are doing
15:56:55 <erisco> at which point Haskell is not on display as much as the idea they're implementing
15:57:16 <dmj`> examining a painting will tell you more than watching the painter paint, maybe live will help understand the motivations behind certain choices
15:58:16 * hackagebot average 0.6.1 - An average (arithmetic mean) monoid.  http://hackage.haskell.org/package/average-0.6.1 (HansHoglund)
15:58:24 <monochrom> I agree totally. in theory.
15:58:51 <monochrom> in practice, watching Micheangleo paint Sistine Chapel would take *decades*
15:59:30 <verement> ttt_fff: you might enjoy jekor's Haskell from Scratch on YouTube
15:59:30 <monochrom> not to mention that edwardk would raise privacy concerns
15:59:58 <edwardk> monochrom: ?
16:00:12 <monochrom> someone wants to watch you live-coding over webcam
16:00:39 <edwardk> its mostly boring. watching me sit over a piece of paper free associating ideas and skimming papers ;)
16:00:48 <monochrom> possibly also measuring your EEG waves
16:01:10 <monochrom> if there is such a thing as "EEG wave webcam"
16:01:51 <erisco> also if you'd oblige to affix a cattle prod to your skin and program lambdabot to active it
16:01:52 <jle`> i can imagine like a screen of code, with a webcam pointing on your notepad/paper, and an eeg overlay
16:01:52 <edwardk> nah, you want something like http://www.twitch.tv/317070 <- for inside your brain
16:02:03 <erisco> we'd like to see how you perform under the uncertainty of pain
16:02:10 <edwardk> erisco: i can't see any way in which that would go wrong. sure.
16:04:17 <erisco> what is going on with that stream?
16:04:22 <erisco> I am watching a fractal
16:05:29 <ocramz> hi there; does anyone here use FGL? can it represent loopy graphs as well, e.g. meshes?
16:05:56 * ski . o O ( "Inceptionism: Going Deeper into Neural Networks" <http://googleresearch.blogspot.co.uk/2015/06/inceptionism-going-deeper-into-neural.html> )
16:07:14 <jle`> everyone suggests fgl for graphs but i don't know a single person who knows how to use it
16:07:19 <jle`> or is willing to admit it
16:07:27 <jle`> *admit that they do
16:07:32 <edwardk> jle`: i can't bring myself to suggest fgl for graphs
16:07:57 <erisco> what is a loopy graph
16:08:00 <erisco> a cyclic graph?
16:08:06 <ocramz> yes, sorry
16:08:17 * hackagebot hdocs 0.4.3.0 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.3.0 (AlexandrRuchkin)
16:08:17 <erisco> yes it can
16:08:24 <ocramz> undirected but cyclic
16:08:27 <jle`> if i ever think i need graphs then i look at the graph landscape and decide to not need graphs, heh
16:08:38 <erisco> jle`, I know right
16:09:14 <erisco> ocramz, FGL is specifically designed so you can have inductive graphs similar to how you have trees and lists and so on
16:09:21 <jle`> some people just do IntMap-type unsafe references like we're doing pointer stuff in C
16:09:26 <ocramz> jle` : I need to represent a Markov random field, so graph queries are nice to have
16:09:30 <erisco> it is an interesting property to have and sometimes helpful
16:09:43 <erisco> but I wouldn't just throw that requirement in there for no good reason
16:09:55 <erisco> there are so many other ways to represent graphs
16:10:02 <edwardk> i tend to write code that produces whatever shape i need as a tree-like thing in memory and then use observable sharing on it
16:10:11 <edwardk> but that is just one of many many approaches
16:11:04 <jle`> i did a sprase matrix representation of a graph once
16:11:56 <erisco> you can sometimes do fine just by tying the knot for cycles
16:12:19 <erisco> and when you need to bang out the finite graph you traverse with memory of already visited nodes
16:12:30 <ocramz> erisco: tying the knot?
16:13:17 * hackagebot positive 0.4.1 - Positive integers.  http://hackage.haskell.org/package/positive-0.4.1 (HansHoglund)
16:13:34 <erisco> ocramz, a simple example being  x = 1 : x
16:14:49 <erisco> sometimes a wonderful trick
16:15:14 <ocramz> so the mappend in this case would be the 1-ring of a node 
16:15:43 <erisco> not long ago I was trying to calculate the sizes of structs, and the problem is that one struct might have a field for another struct in it
16:15:51 <erisco> like  struct A { struct B x; }  kind of thing
16:16:03 <erisco> so when you go to calculate the sizes it is important to get the order right
16:16:10 <erisco> but, thanks to laziness, this is trivial to do
16:16:54 <erisco> if you store the sizes into a map you just feed the result back in as input
16:17:00 <erisco> and magically they all evaluate in the correct order :)
16:17:27 <ocramz> erisco: I would need to see an example..
16:17:41 <ocramz> know of an implementation that uses this concept?
16:17:54 <erisco> yeah this is code I wrote
16:18:57 <ocramz> erisco: care to share a gist?
16:22:55 <erisco> ocramz, I can type up an example quick
16:23:25 <ocramz> erisco: that would be awesome
16:27:22 <|f`-`|f> I should probably disable word alerts
16:27:36 <broma0> Anyone familiar with rose tree zippers? 
16:33:30 <old_spice7> is it possible to search /g with regex-pcre?
16:38:45 <monochrom> ocramz: https://wiki.haskell.org/Dynamic_programming_example may give you some idea
16:38:52 <jsij> The we wornhusking. Eve. Excesht! Cornbut bucklevend mort day!
16:38:54 <jsij> Sto spornhusk cors, a footbalive football. It's me, swill lon ring buck Husk, foof bor st ing bucking. It's agulay!
16:38:56 <jsij> It's ision. You and howbou play! Lynx game! It's woand me! It's my le a L.A. Prove. Brun day! You a fuckinner ee yourdayer a sht, etteleve.
16:38:58 <jsij> It's show it's aboupid oner soccep player, hen ter it's a son Lynx groys, It's who lostarnhuskin reas No!
16:38:59 --- mode: ChanServ set +o monochrom
16:39:00 <jsij> Football ing on. After! Nothe it's me and st etter made. Wits, Coweyer!
16:39:04 --- mode: monochrom set +b *!*@27.123.7.134
16:39:04 --- kick: jsij was kicked by monochrom (jsij)
16:41:20 <funfunctor> @hoogle intercalate
16:41:20 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
16:41:20 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
16:41:20 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
16:42:33 <funfunctor> just checking,  concat . intersperse "|"   is the same as  intercalate "|"   right?
16:42:42 <lamefun> Does Haskell support some kind of type-level values? (eg. like something like data Map a (compare :: a -> a -> Ordering))?
16:43:02 <monochrom> > (concat . intersperse "|") ["abc", "def"]
16:43:03 <lambdabot>  "abc|def"
16:43:15 <Axman6> what's wrong with Map a (A -> a -> Comparing)?
16:43:15 <monochrom> > intercalate ["abc", "def"]
16:43:16 <lambdabot>  <[[[Char]]] -> [[Char]]>
16:43:17 <Axman6> s/A/a
16:43:29 <monochrom> > intercalate "|" ["abc", "def"]
16:43:30 <lambdabot>  "abc|def"
16:43:32 <monochrom> yes
16:43:33 <ocramz> monochrom: thanks !
16:44:01 <monochrom> Axman6, did anyone say it's wrong and why?
16:44:26 <funfunctor> monochrom: sometimes I am worried about hlint's suggestions
16:44:37 <Axman6> monochrom: lamefun did?
16:45:11 <sccrstud92_> lamefun: there are type levels strings and ints
16:45:33 <lamefun> Or "newtype Checked a (check :: a -> Bool) = Checked a".
16:46:28 <monochrom> what is the semantics of "newtype Checked a (check :: a -> Bool) = Checked a"? I have never seen it before.
16:46:29 <Axman6> lamefun: I'm not sure what functionality you're after
16:46:53 <monochrom> allow me to interject for a few minutes to tell you a story
16:46:54 <lamefun> "type PackageName = Checked String validPackageName; validPackageName :: String -> Bool".
16:47:40 <monochrom> a friend worked as a computer tech support person and one day went to a client company (small office) to install new software
16:48:06 * ski . o O ( `data Checked (A : Set) (check : A -> Bool) : Set where Checked : (a : A) -> (check a === True) -> Checked A check' )
16:48:12 <monochrom> the employees at the client company asked, "is this new version compatible with 1048?"
16:48:34 <monochrom> before I reveal what they meant, would you like to guess?
16:48:51 <gashole> how can i set the datadir to a portable location using cabal? something like datadir=@exectuable_path/share
16:50:02 <kadoban> monochrom: Can't think of anything, heh.
16:50:14 <monochrom> it meant 1024x768 monitors
16:50:27 <kadoban> wat
16:50:31 <monochrom> they didn't even say "1048 monitors" or "1048 screens". they said "1048", no more
16:50:50 <monochrom> observe that "1048" is a subsequence of "1024x768"
16:51:06 <kadoban> That's pretty bizarre, heh.
16:51:10 <monochrom> do not under-estimate the great power of homebrew syntax unexplained
16:51:20 <Denommus> hm
16:51:32 <Denommus> I want to make a system that interacts with LDAP
16:51:43 <Denommus> should I use the pure Haskell ldap-client, or the C bindings?
16:52:10 <monochrom> and do not under-estimate the human ability to self-deceive that their pet syntax is universally known
16:53:08 <Algosapien> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]              
16:53:21 <Algosapien> got an error saying  parse error on input `='
16:53:22 <erisco> ocramz, there you go, something like this http://lpaste.net/135510
16:53:47 <ocramz> erisco: wow, thanks!!
16:53:52 <Denommus> Algosapien: where are you trying to declare that? In the REPL? If so, there should be a "let" before boomBangs
16:54:16 <funfunctor> monochrom: is a magic man today
16:54:20 <Denommus> @let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x ]
16:54:21 <lambdabot>  Defined.
16:54:22 <monochrom> "vector field" :)
16:54:27 <Denommus> boomBangs [1, 2, 3]
16:54:37 <Denommus> > boomBangs [1, 2, 3]
16:54:38 <lambdabot>  ["BOOM!","BOOM!"]
16:54:48 <Algosapien> okay got it thanks!
16:56:02 <erisco> so all that dependency ordering algorithmy stuff can be avoided here
16:56:09 <erisco> and replaced with just a few lines
16:56:33 <erisco> however, more realistically you have to guard against cycles
16:56:41 <erisco> so you'll need an SCC algo
16:58:17 <ocramz> erisco: the topology of the graph is fully known; a rectangular mesh
16:58:58 <erisco> I mean in the example of sizing structs
16:59:30 <erisco> and if you want to get more complicated then try also finding optimal field packing
16:59:37 <monochrom> if you know "it's a DAG", there is no worry. FSVO of "know" and "worry"
16:59:39 <erisco> I found that can be done with A*, not really related
17:00:30 <Profpatsch> import Prelude as P hiding (lines)
17:00:34 <erisco> if my regexp library was done I'd show you that
17:00:40 <erisco> it uses lots of knot tying stuff
17:00:45 <Profpatsch> I thought I could still access lines via P.lines.
17:00:58 <Profpatsch> But apparently I can’t. Hm.
17:01:01 <ocramz> erisco: I'm also reading http://jelv.is/blog/Lazy-Dynamic-Programming/
17:01:09 <monochrom> no, you say "hiding (lines)". therefore no lines.
17:01:32 <erisco> yup, good stuff
17:01:34 <Profpatsch> monochrom: I want everything from Prelude, except some elements which I want qualified.
17:01:40 <erisco> what I did was an example of dynamic programming too
17:01:42 <Profpatsch> That’s not possibles
17:01:44 <erisco> awful name for it
17:01:44 <Profpatsch> *?
17:01:58 <monochrom> it is possible. but you wrote wrong code.
17:02:43 <erisco> CS goal for 2015 is to rename "dynamic programming" to something less obscure
17:02:48 <monochrom> you say "P hiding (lines)" which means the very opposite of "I want P.lines"
17:03:10 <hpc> erisco: i vote for "lightning supercode"
17:03:14 <Profpatsch> import Prelude hiding () as P doesn’t work.
17:03:27 <Clint> understandably so
17:03:28 <erisco> hpc, sounds like Apple tech
17:03:46 <Profpatsch> erisco: hpc I thought dynamic programming was altering the source code at runtime.
17:04:03 <hpc> that's self-modification
17:04:08 <erisco> yeah that is what hhvm does to speed up the dynamic language PHP
17:04:24 <monochrom> fortunately, not far from the truth: it alters the data at runtime
17:04:24 <hpc> wikipedia says "In mathematics, computer science, economics, and bioinformatics, dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems"
17:04:28 <sccrstud92> Profpatsch: use NoImplicitPrelude
17:04:32 <sccrstud92> then add explicit imports
17:04:39 <hpc> which is another way of saying "dynamic programming is programming"
17:04:51 <erisco> yeah it is incredibly silly :P
17:05:09 <erisco> more usefully it is about removing redundant calculation
17:05:48 <erisco> you could memoise the naive fib definition... come up with a horrendous StateT version :P
17:05:57 <erisco> then it would be the dynamic fib function
17:06:08 <ocramz> erisco: only when the data is separable, I'd wager
17:06:15 <Profpatsch> sccrstud92: I still want an editor that automatically imports stuff for me and asks if it’s ambiguous.
17:07:02 <erisco> ocramz, well yeah, you have to break it into sub programs, and the hope is that many of the sub problems are the same
17:07:41 <monochrom> I define dynamic programming to be divide-and-conquer with caching sub-answers
17:08:16 <monochrom> if you don't cache, you are not doing dynamic programming. if you are not using divide-and-conquer, you are not doing dynamic programming.
17:08:47 <ocramz> so it's really an option when: data are discrete-valued and when the product of the "marginals" is equal to the full problem
17:08:51 <hpc> static programming allows the compiler to perform more optimizations
17:08:53 * hpc ducks
17:09:21 * erisco tries to slap hpc with a large trout, but it misses
17:10:06 <lamefun> Does GHC only support type-level naturals (not rationals or negatives)?
17:10:07 <Profpatsch> monochrom: I don’t see how it’s possible to import something only qualified while having the rest of the module available unqualified.
17:10:15 <Axman6> lamefun: yes
17:10:20 <monochrom> ocramz: I think that "data are discrete-valued and when the product of the "marginals" is equal to the full problem" is just a criterion for "can be divided and conquered"
17:10:30 <nkaretnikov> is there a way to use cabal repl and cabal build simultaneously?  I'm getting an error about an incompatible interface file or something like that (deleted the message)
17:10:44 <monochrom> import Prelude hiding (lines); import qualified Prelude as P
17:11:12 <ReinH> monochrom: luckilly, Haskell does that sort of dynamic programming almost automatically
17:11:18 <ReinH> if you just think about it hard enough, a la Bird
17:11:38 <monochrom> read my https://wiki.haskell.org/Dynamic_programming_example so you don't have to think as hard
17:11:45 <ReinH> monochrom: :D
17:11:50 <ocramz> @monochrom: two complementary points of view
17:11:50 <lambdabot> Unknown command, try @list
17:12:05 <Profpatsch> monochrom: I can put it on two lines? ok
17:12:08 <ReinH> monochrom: did I tell you about my little thing on L-systems?
17:12:20 <monochrom> no, but I dislike L-systems
17:13:00 <ReinH> monochrom: why?
17:13:17 <monochrom> no reason. just feeling.
17:13:21 <ReinH> heh
17:13:40 <ReinH> monochrom: can I shou you my thing anyway? :)
17:14:16 <monochrom> I am creating homework for students now. no cycle left for a new topic
17:14:22 <ReinH> monochrom: no worries
17:14:31 <ReinH> monochrom: what sort of homework?
17:14:40 <monochrom> 2nd-year data structure course.
17:14:50 <ReinH> sounds like fun
17:15:06 <erisco> monochrom, does it have AVL trees?
17:15:07 <monochrom> this assignment has union-find, Fibonacci heap, amortization, and probability
17:15:26 <monochrom> no AVL tree in my whole course
17:15:34 <erisco> hm, I don't remember doing fib heaps in the course I took
17:15:49 <monochrom> I replaced it by weight-balanced trees similar to Data.Set
17:17:18 <ski> erisco : hm, when's the date for "linear programming" and "operations research" ?
17:17:37 <erisco> ski, should I know?
17:18:10 <ski> i was just figuring that you perhaps had those in schedule as well
17:18:21 * hackagebot halive 0.1.0.5 - A live recompiler  http://hackage.haskell.org/package/halive-0.1.0.5 (lukexi)
17:18:39 <erisco> I don't know what either of those are XD
17:19:49 <ski> hint : not quite what they sound like
17:21:06 <ski> "linear programming" is optimizing a linear function under linear inequality constraints
17:21:23 <erisco> like, numerical methods?
17:22:34 <ocramz> well the mathematicians have been calling optimization "programming" since forever
17:22:50 <ski> "operations research" is about making decisions, e.g. in an organization, based on various input data
17:23:21 <erisco> const ClimbCoorperateLadder
17:23:24 <ocramz> in fact, the simplex algorithm for LP is from the mid-50s
17:23:29 <aupiff> is writing instance Generec MyType the same as MyType deriving Generic ?
17:24:05 <aupiff> I am wondering because I am currently using my own version of a library so I can use a sparse vector type with Data.Binary which requires a Generic instance
17:24:10 <ski> aupiff : if you write `instance Generic MyType', you'll have to manually write the implementations of the methods
17:24:27 <ski> you could try `deriving instance Generic MyType', perhaps
17:24:41 <aupiff> ah, interesting... will try that
17:25:10 <lolisa> Well, In a sense they are right... In a very, very crude sense we indeed spend a lot of time into optimizing http://www.scholarpedia.org/article/Universal_search
17:27:48 <crocket> I want to try yi, so I installed yi via cabal.
17:27:52 <crocket> However, I can't find yi executable.
17:29:19 <Cale> check in ~/.cabal/bin
17:29:30 <crocket> There is no ~/.cabal/bin
17:30:07 <Cale> hmm, that's interesting
17:30:31 <Cale> I'll try it
17:30:48 <erisco> one man's ruin is another man's interest
17:31:06 <ocramz> lolisa : that link is very interesting; do you work in a related field?
17:33:15 <lolisa> Sadly No :(
17:33:37 <lolisa> I got the link in a chat with someone (I forgot, it's been a long time ago)
17:35:18 <crocket> It seems yi build failed.
17:36:06 <lolisa> Oh BTW google search on Levin's universal search give many related intresting result
17:37:38 <Cale> crocket: Well, that would make sense. Usually you would have a ~/.cabal/bin if cabal ever successfully built an executable, and the yi package specifies one. What was the build error?
17:37:54 <crocket> Why do I need to install libghc-terminfo-dev and libghc-vty-dev on ubuntu to install yi?
17:37:59 <crocket> It sounds ridiculous
17:38:09 <crocket> libghc-terminfo-dev and ligbhc-vty-dev are ubuntu packages.
17:38:14 <Cale> crocket: hm? Why is that ridiculous?
17:38:21 <crocket> cabal requires those packages to build yi within cabal.
17:38:28 <crocket> cabal should be self-sufficient.
17:38:45 <Cale> They're the development packages for the C libraries that various yi dependencies (the Haskell bindings to those C libraries) rely on.
17:39:15 <Cale> cabal doesn't attempt to track C library dependencies
17:39:36 <crocket> It seems cabal is far from being ok outside haskell.
17:40:01 <crocket> Outside haskell, cabal doesn't do automatic dependency management, which means I"m back to manual dependency management.
17:40:19 <Hijiri> it doesn't seem like building yi is making me need those packages
17:40:32 <Hijiri> maybe it just hasn't failed yet
17:40:43 <Cale> crocket: Well, it's not really a package manager, it's just a build system
17:40:51 <crocket> yi depends on a lot of unknown C packages
17:41:09 <crocket> I don't know what the packages are.
17:41:28 <crocket> I wish yi stayed in haskell.
17:42:19 <exio4> sadly, Haskell has a really nice FFI when it comes to using C libraries, so sometimes people prefer to use working solutions instead of rewriting things in pure Haskell
17:42:50 <crocket> They didn't really think a lot about deployment.
17:43:21 <Cale> Well, the icu binding failed to install for me, complaining that the icu C libraries weren't installed, so I just typed  apt-get install libicu<TAB> and found libicu-dev, which fixed it.
17:43:39 <Hijiri> I think all libghc-* packages are haskell packages and not the C libraries, but I might be wrong
17:43:59 <Hijiri> the c libraries I have had to install were just their own libraries
17:44:05 <Cale> I don't think it's too unreasonable if you're going to build things yourself that you might have to install some external dependencies now and then.
17:44:20 <ttt_fff> is there a way, when using pattern matching + guards; to say "if this guard fails .... FAIL THE ENTIRE PATTERN ... instead of forcing an 'otherwise' guard"
17:44:41 <Hijiri> I think omitting the otherwise guard does that
17:44:43 <Cale> ttt_fff: Make it the last guard
17:44:50 <crocket> I just wanted to install yi semi-automatically.
17:44:55 <crocket> "apt-get install yi"
17:44:59 * ocramz liquefies and trickles to the nearest drain
17:45:00 <ttt_fff> hmm
17:45:04 <ttt_fff> I think I mis-explained my problem
17:45:23 <ttt_fff> consider this code: https://gist.github.com/anonymous/81e31a6a3ed63cf2635b
17:45:34 <ttt_fff> if I have a nested "fn" around a "case" ... and the two args match, then I want to render it differently
17:46:01 <Cale> ttt_fff: That code doesn't even have guards...
17:46:13 <ttt_fff> Cale: that code does not compile, since these are two args
17:46:17 <Cale> (despite all the weird |'s which I can only assume are some weird editor stuff)
17:46:25 <crocket> Is it what people call cabal hell?
17:46:25 <ttt_fff> I need to make the two args be "args0" and "args1" and run it only when args0 == args1
17:46:30 <ttt_fff> Cale: yeah, the "|" is from vim
17:46:46 <monochrom> godawful
17:46:47 <exio4> crocket: no :)
17:46:47 <Cale> crocket: No, *this* isn't cabal hell :)
17:47:37 <exio4> ttt_fff: I don't understand what you are trying to do, but maybe look at pattern guards?
17:47:44 <crocket> How do I fix http://dpaste.com/1PRM0CW ?
17:48:16 <Cale> ttt_fff: So just put a guard in which says  | args0 == args1  ?
17:48:34 <ttt_fff> Cale: but if args0 != args1, how can I have it fall through back to the fn + case cases?
17:48:40 <ttt_fff> I want a | args0 == args1 -> ...
17:48:41 <ttt_fff> but I don
17:48:42 <Cale> It will fall through
17:48:43 <ttt_fff> but I don
17:48:48 <Cale> Just do it
17:48:49 <ttt_fff> but I don't want a | otherwise -> ...
17:48:53 <Cale> You don't need one
17:48:55 <ttt_fff> okay
17:48:57 <ttt_fff> let me try it
17:48:57 <ttt_fff> thanks
17:49:19 <Hijiri> crocket: cabal install alex
17:49:33 <Hijiri> also maybe cabal install cabal && cabal install cabal-install
17:49:50 <Cale> Uh, it would be  cabal install Cabal  if you want to update the library
17:50:20 <Hijiri> oh, forgot it was capitalized
17:50:34 <crocket> Is there a better haskell package manager than cabal?
17:50:48 <sccrstud92> crocket: a lot of people like stack so far
17:50:51 <sccrstud92> pretty new
17:50:58 <sccrstud92> idk if its techinically a package manager though...
17:50:59 <crocket> Nowadays, functional package managers like guix and nix are cool.
17:51:06 <crocket> guix
17:51:07 <Cale> crocket: Yeah, it sounds as if the vty library demands that you have a newer version of the Cabal library (at least 1.18.0)
17:51:22 <Cale> crocket: Which version of GHC are you using?
17:51:40 <crocket> 7.6.3
17:51:46 <mike323> \q
17:51:46 <Axman6> so old :(
17:51:48 <Cale> Ah, that's really old
17:51:56 <Axman6> why is ubuntu so terrible
17:52:08 <monochrom> I disagree
17:52:10 <crocket> Ask Mark Shuttleworth
17:52:11 <ttt_fff> Cale: that worked, thanks!
17:52:22 <ttt_fff> exio4: btw, thanks for the suggestions of pattern gaurds -- not needed here, but looks useful for future issues
17:52:58 <ttt_fff> anyone that uses ubuntu should have their op priviledge revoked
17:53:03 <crocket> Is it possible to write ncurses purely in haskell?
17:53:12 <monochrom> you mean like this?
17:53:15 --- mode: monochrom set -o monochrom
17:53:21 <crocket> Is it possible to write gtk purely in haskell?
17:53:50 <ttt_fff> monochrom: man, trolling #hskell is no fun
17:54:11 <Cale> crocket: Well, yes, except for the fact that it's a lot more work than simply binding to the existing libraries would be.
17:54:27 <crocket> Yes
17:54:29 <Cale> crocket: and maintaining compatibility with the C GTK library would be insane and hellish
17:54:46 <crocket> Without proper package management, playing with C libraries is painful.
17:55:05 <crocket> Cale, I just want haskell to have its own independent reactive GUI framework.
17:55:24 <monochrom> your "just" is such an understatement
17:55:34 <Cale> crocket: So write one!
17:55:44 <monochrom> do you know how much money went into maturing, for example, Visual Studio?
17:56:05 <Cale> What does Visual Studio have to do with GUI frameworks?
17:56:10 <crocket> Visual Studio is a mess.
17:56:21 <Cale> MFC? (Does that still exist?)
17:56:36 <c_wraith> MFC has mostly been supplanted by .NET stuff
17:56:53 <c_wraith> though windows (nearly) always has backwards compatibility.
17:56:55 <monochrom> it has to do with yi, the origin of this string of questions
17:57:05 <crocket> Visual Studio is not GUI framework.
17:57:58 <Cale> crocket: The trouble is that it's a lot of repeated development effort for very little gain vs. just binding to an existing cross-platform GUI library
17:58:34 <c_wraith> If only it was easy to actually use bindings to cross-platform libraries.  I've still never figured out how to install the sdl2 bindings on windows.
17:58:36 <crocket> Those cross-platform GUI libraries do not really mix well with haskell.
17:58:37 <Cale> It would of course be nice to have, but convincing someone to do that work is a bit tricky :)
17:58:50 <crocket> They assume mutability, and haskell is not ok with it
17:58:59 <c_wraith> haskell is fine with mutability.
17:59:00 <Cale> Haskell is okay with mutable state.
17:59:03 <c_wraith> It just is explicit about it
17:59:46 <monochrom> you are looking for a technical reason where there is none. you should be looking for an economic reason
18:00:17 <crocket> Does haskell need more users for a haskell GUI framework to be viable?
18:00:30 <monochrom> no. it needs more money.
18:00:59 <crocket> monochrom, Do you mean direct donation?
18:01:01 <monochrom> if you look at the history of wxHaskell, gtk2hs, and the "tangible value" project, you will see.
18:01:11 <Cale> Well, sometimes users who are willing to put in time selflessly are able to act as money :)
18:01:15 <c_wraith> No, the requirement is *employment*, not donation
18:01:33 <crocket> If commercial projects are willing to invest time into haskell, then it'll happen.
18:01:53 <c_wraith> A full GUI library would take a significant full-time team.
18:01:55 <monochrom> they show that all the things you wish could be done. they also show that the people who did them now move on to more attractive careers.
18:01:57 <crocket> It's about getting time shares from people from commercial and non-commercial backgrounds.
18:02:04 <c_wraith> On the order of millions of dollars per year.
18:02:22 <crocket> I think it's better to think about this in terms of hours.
18:02:31 <c_wraith> You can't finance that on the hope of donations.
18:02:33 <monochrom> look at the author of "tangible values", for example.
18:02:48 <monochrom> he was also the one who brought us FRP
18:03:03 <crocket> Linux benefited by commercial developers' time.
18:03:05 <monochrom> and today, even he has moved on to an unrelated, but paid, project
18:03:20 <crocket> monochrom, Because he needed to pay bills?
18:03:27 <monochrom> I don't know
18:03:40 <crocket> Most of the time, it is about paying bills.
18:03:42 <c_wraith> you could ask.  He's in here often.
18:03:44 <Cale> crocket: The thing is, just having commercial projects written in Haskell also isn't really enough, since commercial users of Haskell are more likely to just take the smaller effort of just getting one of the existing GUI bindings to work. Even writing a higher-level wrapper over one of those is much simpler than redeveloping it from scratch. Nobody's going to want to go back to the point of implementing their own text
18:03:44 <Cale> -edit control and so on for no reason.
18:04:18 <monochrom> I am not going to speculate why each individual is attracted to money, ok? I can't speak for them. but I am *empirically* *observe* that they move from unpaid projects to paid projects
18:04:30 <crocket> Well, people develop pixie based on clojure.
18:04:32 <crocket> for free
18:04:52 <Cale> But if you'd like to throw yourself into that trench, feel free :)
18:04:59 <monochrom> and even when they did the unpaid projects, those were not really unpaid, either, if you look really hard.
18:05:11 <crocket> I think it's just that developers do not feel much value from GUI frameworks.
18:05:33 <crocket> Somehwere in the lines of 'thankless job'.
18:05:41 <monochrom> for example, "tangible values" was unpaid, on the surface. deep down, it paid him publication opportunities, the currency of academia.
18:06:16 <crocket> monochrom, It doesn't require money for something to make sense economically.
18:06:36 <crocket> could be sex, prestige, etc...
18:06:45 <monochrom> sure. like I just said, another economic compensation can be publication opportunities
18:07:33 <Cale> crocket: It's not just that it's a thankless job -- people likely would be thankful to have a GUI library written entirely in Haskell, even -- it's that it's an extremely large effort just to get to the point where you're not doing negative work to ask people to switch to your thing, because there are so many fiddly nontrivial components to something like GTK.
18:07:37 <monochrom> so look at how he did a proof-of-concept for "tangible values", and then, without turning it into a practical library, moved to FRP.
18:07:54 <crocket> Anyway, Racket has a nice cross-platform GUI framework, which is a binding of Cocoa, Gtk, and windows forms underneath.
18:08:27 <monochrom> see, the first version of tangible values would earn you a publication opportunity. but afterwards, the nth version would not. only new projects earn you your next publication opportunity
18:08:41 <Cale> crocket: Okay, so you're talking about a binding again.
18:08:54 <Cale> crocket: Where's the GUI library from scratch in Racket?
18:08:55 <monochrom> to survive in academia, you have to keep abandoning old projects
18:09:06 <crocket> Cale, Racket doesn't have a native GUI library.
18:09:11 <Cale> crocket: Gtk2Hs is pretty nice overall.
18:09:28 <Cale> It's not the greatest thing in the world, but it's not totally awful.
18:09:54 <crocket> Does it mean it's mediocre?
18:10:39 <Cale> Well, I'd say it's nicer than most GUI libraries in most other languages.
18:11:06 <crocket> The problem is that not enough people use haskell for GUI.
18:11:23 <crocket> If haskell is known for GUI, then there would be a nice binding or a nice native GUI framework.
18:11:30 <bernalex> I always end up using sdl or opengl or something thin-ish over that instead of the other ones... in any language...
18:11:41 <Cale> Do you have a specific problem with Gtk2hs?
18:11:47 <crocket> no
18:12:02 <Cale> I guess I don't understand what this conversation is about then...
18:12:05 <crocket> However, haskell is known for functional programming, and haskell needs to acquire niche developers.
18:12:14 <crocket> like GUI, machine learning, etc...
18:12:17 <bernalex> do we?
18:12:43 <crocket> I'm suggesting a new direction for marketing.
18:12:51 <DNoved1> Has there been a survey on what haskell is used for, say personally or professionally?
18:12:53 <bernalex> uh haskell is free software
18:13:00 <bernalex> DNoved1: several
18:13:01 <DNoved1> I honestly have no idea what most people use it for
18:13:03 <crocket> Free softwares are also marketed.
18:13:16 <crocket> They compete for developers.
18:13:23 <DNoved1> Well, an idea, but not a very clear one
18:13:33 <bernalex> crocket: there's no corporate backing for haskell. we don't really do "marketing".
18:13:33 <Cale> I don't personally buy into any statement of the form "Haskell needs to acquire ... developers". Haskell is good enough that enough people are content to use it that it's not going anywhere any time soon, and it's good enough for my purposes selfishly.
18:13:44 <bernalex> I agree with Cale.
18:13:58 <crocket> bernalex, Often, maintainers and founders of languages participate in marketing languages.
18:14:04 <Cale> I don't see any good coming from trying to artificially "sell" Haskell to people who aren't looking for it.
18:14:05 <crocket> Haskell also has a marketer.
18:14:24 <crocket> Its founder or maintainers
18:14:40 <bernalex> crocket: I don't really know what you are concretely trying to say. we don't really do marketing. we have spj whom is the nicest guy ever, so people seem to have a nice perception of haskell because of him.
18:14:44 <crocket> And, developers market haskell as cool functional programming languages.
18:15:02 <crocket> s/langauges/language/
18:15:13 <bernalex> I think you are using the word "market" very liberally to the point of nonsense.
18:15:32 <bernalex> if I say "you should check out haskell, it's cool" to a friend, I am not "marketing" haskell.
18:15:42 <monochrom> I believe in honest marketting, but not bubble marketting
18:15:54 <crocket> bernalex, marketing can be done by anyone.
18:16:11 <crocket> You don't need to belong to a company to do it
18:16:15 <lpaste_> lamefun pasted “Is this sane code?” at http://lpaste.net/135518
18:17:03 <bernalex> monochrom: haskell is the useless/safe -> useful/unsafe route to programming nirvana. that's the extent I'd go to with buble marketing
18:17:07 <crocket> I think haskell has a bright future in AI and web programming.
18:17:21 <bernalex> crocket: I use haskell every day and think it has a bright present
18:17:46 <bernalex> I think dependently typed programming languages have a bright *future*. hopefully something will replace haskell asap. haskell is ancient.
18:17:58 <ski> lamefun : no, the `Show' instance is incorrect
18:18:14 <crocket> Is there any dependently typed programming language in horizon?
18:18:29 <crocket> As far as I know, idris never intends to be a production language.
18:18:32 <monochrom> bernalex: I think that "dependent typing has a bright future" is true every year, coinductively :)
18:18:37 <bernalex> crocket: idris is the most general-purpose one. but it's strict-by-default, so I don't know.
18:18:54 <bernalex> crocket: I have never heard edwin or david say that myself
18:19:00 <Cale> crocket: "Never intends to be?"
18:19:07 <bernalex> monochrom: so is s/dependent typing/functional programming/
18:19:09 <crocket> The founder of idris makes it explicit that he wants idris to remain a research language.
18:19:15 <Cale> Idris is a language, it can't have intentions.
18:19:17 <bernalex> monochrom: and the linux desktop
18:19:38 <bernalex> Cale: you mean idris hasn't reached the singularity yet?
18:19:49 <bernalex> probably because it's not lazy-by-default ^^
18:19:51 <Cale> It might have intensions ;)
18:19:59 <lamefun> ski: can I remove the need for UndecidableInstances?
18:20:07 <crocket> At this stage, idris is mostly a one-man show.
18:20:12 <bernalex> crocket: not really
18:20:19 <Cale> crocket: Even that's not true
18:20:21 <bernalex> crocket: and so was git at first. I don't understand the point.
18:20:36 <bernalex> so was most software tbh.
18:20:52 <Cale> I mean, yeah, Edwin's definitely the main guy working on it, but there are a bunch of people interested in Idris and contributing to the implementation besides him.
18:21:03 <bernalex> idris has 6 contributors with >100 commits
18:21:08 <monochrom> for what it's worth, the Haskell committee, all of them, did not intend, or even foresee, what Haskell becomes today
18:21:18 <bernalex> edwin & david are the main guys atm, but there's a bunch of people interested in idris.
18:21:31 <bernalex> monochrom: because intending and foreseeing is rather quite pointless in cs. :)
18:21:32 <crocket> The point is that I wouldn't expect idris to be taking off in the foreseeable future as long as the founder doesn't want idris to be anything more than a research language at this stage.
18:21:44 <ski> lamefun : try it ?
18:21:44 <bernalex> crocket: where did edwin say this?
18:21:54 <crocket> bernalex, He stated his intention in #idris
18:21:55 <bernalex> crocket: I've seen idris in production. I don't really know what you are talking about.
18:22:06 <monochrom> even in python, some of GvR's intentions got lost
18:22:09 <crocket> I heard it directly from him
18:22:13 <bernalex> crocket: did you know that spj wants haskell to be a research language?
18:22:15 <monochrom> even GvR had to compromise
18:22:20 <bernalex> crocket: avoid success at all costs
18:22:30 <crocket> Who is spj?
18:22:41 <bernalex> crocket: the main haskell guy lately.
18:22:43 <DNoved1> simon peyton jones
18:22:48 <crocket> bernalex, 'lately'
18:22:54 <monochrom> God you need to study history and learn from it before you try to predict the future
18:23:02 <bernalex> crocket: he was on the original committee and is arguably the most prolific haskell dev.
18:23:39 <bernalex> crocket: mostly because he's been so tightly involved with haskell all the way since its inception. he's still the main ghc dev.
18:23:48 <crocket> Does any of you think idris is going to gain momentum in the near future?
18:23:50 <sccrstud92> i dont interpret "avoid success at all costs" to mean that it should remain a research language
18:24:08 <bernalex> crocket: we're programmers mostly. we don't waste our time predicting things. we work with what we have.
18:24:15 <lamefun> ski: I don't see a way to.
18:24:21 <crocket> bernalex, So, you work with haskell
18:24:51 <lamefun> What's not correct with my show instance?
18:25:15 <bernalex> crocket: I mostly work with haskell. but I look into new languages too.
18:25:39 <crocket> I think haskell is fine enough.
18:25:46 <ski> lamefun : `show (KeyMap map) = show map' should be `showsPrec p (KeyMap map) = showParen (p > 10) $ showString "KeyMap " . showsPrec 11 map'
18:28:10 <ski> lamefun : the string your `show' is emitting is a string representation of a value of type `Map (Key a) a', while it ought to be one for a value of type `KeyMap a', that's what's wrong about it. (assuming an appropriate environment), it should be possible to type the output expression it, and get an equal value
18:29:28 <ski> lamefun : by defining (and using) `showsPrec', we make sure that proper wrapping in brackets will be done, if needed
18:30:28 <lamefun> ski: your function wouldn't work either then, because KeyMap constructor is not exported. It should print fromList [Player 1 "OstrichMan",Player 2 "Cabbage",Player 3 "DogFood"] (similar to how Data.Map prints fromList).
18:31:04 <funfunctor> Hi
18:31:30 <funfunctor> I know there is a few formalisations for this but does anyone have a good formal definition for a Type ?
18:33:11 <ski> lamefun : i think, since your type constructor and data constructor is named the same, both will be exported when you list it in the export list
18:33:20 <sccrstud92> funfunctor: a haskell type?
18:33:24 <sccrstud92> or
18:33:28 <sccrstud92> like a mathematical type
18:34:31 <sccrstud92> ski: when you export the type constructor, all the data constructors are exported
18:34:40 <sccrstud92> if you use
18:34:42 <funfunctor> stupid machine..
18:34:44 <sccrstud92> the right notation
18:34:55 <funfunctor> sccrstud92: sorry I got disconnected just then
18:35:02 <funfunctor> (11:33:07) sccrstud92: like a mathematical type
18:35:03 <funfunctor> (11:33:47) funfunctor: sccrstud92: do you mean mathematical type as in type in type theory?
18:35:15 <sccrstud92> funfunctor: yeah
18:35:27 <sccrstud92> which one?
18:35:35 <lamefun> ski: wouldn't I need KeyMap(KeyMap) or KeyMap(...) in the export list for the constructor to be visible?
18:35:47 <lamefun> * KeyMap(..)
18:35:55 <funfunctor> sccrstud92: alright, the maths one but whats so different about the Haskell one apart from the implementation aspects?
18:36:42 <sccrstud92> funfunctor: well haskell has a lot of math as its founddational principles
18:36:50 <sccrstud92> but they arent necessarily identical
18:37:07 <sccrstud92> for example the formal dfinitioin of a haskell type would be in the haskell report (im guessing)
18:37:23 <sccrstud92> for a mathematical type, idk the best place to find it. probably some textbook
18:38:02 <sccrstud92> funfunctor: idk either one, but you might get a better answer from sone else if you are specific
18:38:04 <sccrstud92> =)
18:38:12 <ski> sccrstud92 : lamefun didn't use `KeyMap (..)'
18:38:35 <ski> lamefun : "wouldn't I need KeyMap(KeyMap) or KeyMap(...) in the export list for the constructor to be visible?" -- not if they're named the same
18:38:45 <funfunctor> ok but my questions is reasonably specific, what is the definition of Type
18:38:46 <ski> (this is one reason why i almost never name them the same)
18:38:59 <ski> lamefun : ok, if you want to have an abstract data type, then you should really do `showsPrec p (KeyMap map) = showParen (p > 10) $ showString "fromList " . showsPrec 11 (elems map)', i think
18:39:08 <lamefun> ski: well, I tried and I got: "Main.hs:17:13: Not in scope: data constructor ‘KeyMap’". Is my ghc bugged?
18:39:12 <ski> (`elems = map snd . toList')
18:39:49 <ski> lamefun : perhaps they decided to change the behaviour of this recently. i don't know
18:40:21 <ski> lamefun : anyway, see ^ for an abstract `Show' version
18:40:53 <sccrstud92> lamefun: https://www.haskell.org/tutorial/modules.html
18:41:02 <sccrstud92> check the abstract data type section
18:41:41 <ski> (conceptually, it's wrong to just rely on the `Show' instance for `Map (Key a) a' since `Data.Map.fromList' is not the same as `MyProgram.KeyMap.fromList' -- and in this case, the types don't even match so that you'd get type-incorrect strings generated by `show')
18:43:25 * hackagebot purescript 0.7.0.0 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.7.0.0 (PhilFreeman)
18:44:57 <ski> sccrstud92 : .. i'm not sure how that helps here
18:45:19 <lpaste_> lamefun pasted “ski: Is my GHC bugged?” at http://lpaste.net/135521
18:46:23 <orzo_> lamefun: no that's not a bug
18:46:34 <ski> lamefun : i already answered what i know
18:46:42 <orzo_> lamefun: you exported the type Test but not the value (data constructor) Test
18:47:17 <lamefun> orzo_: but ski told me "i think, since your type constructor and data constructor is named the same, both will be exported when you list it in the export list".
18:47:26 <orzo_> lamefun: change "module Test (Test) where" to "module Test (Test(..)) where
18:47:48 <orzo_> well ski was just guessing
18:47:52 <orzo_> he's wrong
18:48:10 <sccrstud92> as the error message indicated
18:50:20 <ski> orzo_ : i was reporting observed behaviour. i suppose it has been changed now
18:51:19 <ski> lamefun : i just checked with the report. at <https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2> it says "An algebraic datatype T declared by a data or newtype declaration may be named in one of three ways: □ The form T names the type but not the constructors or field names. The ability to export a type without its constructors allows the construction of abstract datatypes (see Section 5.8 ).  ..."
18:51:25 <orzo_> ski: you must be misremembering or misinterpretting some observation.  The behavior i described is old and has been consistent accross a lot of versions of ghc.  (Havne't tried 7.10.1 yet, but i'd be surprised...)
18:51:50 <porglezomp> > let 2 + 2 = 5 in 2 + 2
18:51:51 <lambdabot>  5
18:52:09 <porglezomp> Can anyone explain that to me? I learned about it today
18:52:15 <porglezomp> How is that different from:
18:52:19 <ski> orzo_ : how old ? more than ten years ?
18:52:19 <porglezomp> > let 4 = 5 in 4
18:52:21 <lambdabot>  4
18:52:53 <orzo_> i started using haskell in 2003 or so
18:53:27 <ski> (btw, since i almost never name the type constructor and data constructor the same anyway, i probably wouldn't have noticed when it changed)
18:54:07 <lamefun> > let length x = 0 in length [1, 2, 3]
18:54:08 <lambdabot>  0
18:54:11 <orzo_> have you been using it for ten years?
18:54:51 <ski> around that. possibly a few more years, i don't recall exactly
18:55:10 <orzo_> well maybe your observatoin predates the current import syntax
18:55:49 * ski doesn't know
18:56:08 <lamefun> > let x + y = x - y in 3 + 2
18:56:09 <lambdabot>  1
18:56:25 <orzo_> you gotta brush up man, you're living in haskell98 days
18:56:41 <orzo_> :P
18:56:44 <ski> hehe
18:57:09 <lamefun> > let 2 + 2 = 5 in 3 + 3
18:57:11 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
18:57:34 <lamefun> porglezomp: ^
18:57:50 <lamefun> You're just re-defining the + function.
18:58:03 <ski> lamefun : did you fix the `Show' instance ?
18:58:56 <lamefun> ski: I'm in doubt whether KeyMap is a good idea at all.
18:59:06 <porglezomp> lamefun, thanks, that makes sense
18:59:25 <porglezomp> it's well hidden
18:59:40 <exio4> you're shadowing the global (+) with a local (+) function, that pattern matches on its arguments
18:59:42 <sccrstud92> i was just surprised that let 4 = 5 in 4 worked
18:59:57 <ski> lamefun : oh .. i was assuming you already had some sensible reason for wanting it ..
19:00:06 <exio4> let 4 = 5 in X defines a lazy pattern match that's never tried 
19:00:08 <exio4> it's like 
19:00:16 <porglezomp> yeah, I was too
19:00:17 <exio4> > let Nothing = Just 3 in 2 
19:00:18 <lambdabot>  2
19:00:24 <porglezomp> let 4 = 5 in 4
19:00:42 <porglezomp> wait, why doesn't it try to match it?
19:00:49 <exio4> > let [] = [1,2,3] in 42
19:00:51 <lambdabot>  42
19:01:02 <ski> porglezomp : because you never force a variable bound by the pattern
19:01:03 <exio4> porglezomp: patterns in let are lazy by default 
19:01:21 <ski> (simply because the pattern doesn't bind any variables whatsoever ..)
19:01:32 <porglezomp> Okay, no binding
19:01:36 <ski> > let Just x = Nothing in ()
19:01:38 <lambdabot>  ()
19:01:39 <ski> > let Just x = Nothing in x
19:01:40 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Just x
19:01:53 <porglezomp> > let [] = [1] in []
19:01:54 <lambdabot>  []
19:03:16 <porglezomp> I was wondering if that would do [] -> [1]:[] -> [1]:[1]:[] -> ...
19:03:52 <ski> > let ones = 1:ones in ones
19:03:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:04:29 <porglezomp> Yeah, I just figured that out in my GHCI
19:04:47 <porglezomp> so does it not do it for [] because it's syntax, or?
19:05:07 <ski> does it not do *what* for `[]' ?
19:05:30 <n1cky> in a cabal install I'm getting the following: rejecting: unix-2.7.1.0/installed-e59... (conflict: unix =>
19:05:37 <n1cky> time==1.5.0.1/installed-e17..., imm => time<1.5)
19:05:41 <porglezomp> let [] = 1:[] in [] doesn't produce the same result as let a = 1:a in a
19:05:54 <n1cky> clearly 1.5.0.1 > 1.5, though
19:05:57 <ski> porglezomp : `[]' is not a variable name
19:06:47 <ski> porglezomp : `[]' is a pattern that involves no variable names, and hence the match of the value `1:[]' to the pattern `[]' will never be performed since there will never be a demand (force) for a variable bound by the pattern
19:07:21 <porglezomp> Yeah, I see that now
19:07:41 <orzo_> watched killar mike's Reagan video
19:07:44 <sccrstud92> let x@4 = 5 in x
19:07:48 <sccrstud92> >let x@4 = 5 in x
19:07:51 <orzo_> oh wrong channel, sorry
19:07:57 <sccrstud92> > let x@4 = 5 in x
19:07:58 <lambdabot>  *Exception: <interactive>:3:5-11: Irrefutable pattern failed for pattern x@4
19:08:59 <porglezomp> Okay, I think I've grasped a new facet of patterns and variables now
19:10:21 <porglezomp> Thanks everyone
19:10:27 <ski> @let newtype Fix f = Wrap (f (Fix f))
19:10:29 <lambdabot>  Defined.
19:10:30 <ski> @let deriving instance Show (f (Fix f)) => Show (Fix f)
19:10:31 <lambdabot>  Defined.
19:10:54 <ski> > let Nothing = Just (Wrap Nothing) in Nothing  -- porglezomp, this is analogous to your `let [] = [1] in []'
19:10:55 <lambdabot>  Nothing
19:11:13 <lamefun> ski: It's for easier creation of maps from a records' members to records (for example Package String ..., Player Int ...).
19:11:17 <porglezomp> because Nothing and [] are both * -> *
19:11:23 <porglezomp> , or no
19:11:26 <porglezomp> they're *
19:11:36 <ski> `Nothing' is a value, not a type
19:11:39 <porglezomp> yeah
19:11:58 <ski> for `[]', do you mean the empty list data constructor, or the list type constructor ?
19:12:00 <yayfoxes> hi, i have this hailstone numbers function hailstone n which if n is even it takes n and divides it by 2 otherwise it takes 3*n + 1
19:12:09 <porglezomp> but is Nothing also a constructor for that value?
19:12:18 <yayfoxes> how would I do the hailstone numbers sequence?
19:12:29 <yayfoxes> make a list of hailstone numbers
19:12:30 <Cale> yayfoxes: iterate
19:12:32 <lamefun> I an of course do (Package String (PackageData ...) and Player Int (PlayerData ...)), but IMO it's ugly.
19:12:34 <Cale> :t iterate
19:12:35 <lambdabot> (a -> a) -> a -> [a]
19:12:46 <porglezomp> Okay, it is not a constructor, since :k says no
19:12:47 <yayfoxes> my own function mind you
19:12:49 <Cale> @src iterate
19:12:49 <lambdabot> iterate f x = x : iterate f (f x)
19:12:51 <porglezomp> :t Just
19:12:52 <lambdabot> a -> Maybe a
19:12:53 <ski> porglezomp : `Nothing' is a data constructor for `Maybe'. i dunno what you mean by "constructor for a value"
19:13:01 <yayfoxes> Cale: whoa!
19:13:18 <ski> yayfoxes : recursion
19:13:56 <ski> lamefun : ok
19:13:57 <Cale> yayfoxes: Of course, you might want a base case if you're writing it recursively yourself or you may wish to apply takeWhile if you're using iterate
19:14:04 <porglezomp> ski, still working on the names of things, and I should probably check the easily checked things before I make assertions
19:14:24 <porglezomp> Because :t tells me that Nothing is a value
19:14:38 <yayfoxes> Cale: but I still don't understand concepts such as recursion
19:15:01 <ski> porglezomp : for clarity, perhaps you should not say just "constructor" as in your "it is not a constructor", but "data constructor" or "type constructor", when disambiguation is needed
19:15:16 <Cale> yayfoxes: It's easy. To understand recursion, first you must understand recursion.
19:15:32 <yayfoxes> Cale: but how is that?
19:15:45 <yayfoxes> I did 99 bottles of beer recursively in Java
19:16:01 <porglezomp> Cale: +1
19:16:12 * hodapp thwaps Cale
19:16:33 <cj3kim> yayfoxes: try the knapsack problem
19:16:43 <nkaretnikov> yayfoxes: you might want to write a recursive function that has a base case
19:16:49 <yayfoxes> I understood that I could call printOneVerse recursively number numberOfBottles equaled 0
19:16:51 <nkaretnikov> then trace its execution
19:17:01 <porglezomp> Well, I think I'm going
19:17:02 <porglezomp> Bye!
19:17:11 <bernalex> ?where recursion
19:17:11 <lambdabot> ?where recursion
19:17:17 <cj3kim> once you do a couple recursive problems from scratch and graph out the results through nodes, you'll get it
19:17:20 <nkaretnikov> yayfoxes: do you understand for-loops?
19:17:29 <Cale> yayfoxes: It's probably easiest to understand how iterate works just by doing highschool-algebra like substitutions of equals for equals, for instance:
19:17:38 <Cale> @src iterate
19:17:38 <lambdabot> iterate f x = x : iterate f (f x)
19:17:41 <Cale> iterate (+1) 0
19:17:53 <Cale> = 0 : iterate (+1) ((+1) 0)
19:18:16 <yayfoxes> nkaretnikov: I do not really understand for loops
19:18:31 <Cale> = 0 : (+1) 0 : iterate (+1) ((+1) ((+1) 0))
19:18:43 <Cale> = 0 : 1 : iterate (+1) ((+1) 1)
19:19:07 <Cale> = 0 : 1 : (+1) 1 : iterate (+1) ((+1) ((+1) 1))
19:19:12 <Cale> and so on
19:19:15 <nkaretnikov> yayfoxes: basically, it's the same: some code that it's run repeatedly (with or without changes)
19:19:16 <Cale> > iterate (+1) 0
19:19:18 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:19:36 <nkaretnikov> yayfoxes: try to go through the stuff that Cale just wrote
19:20:05 <freeman42> how can you run multiple commands in sequence in GHCi? for example :r followed by :main to reload and rerun the hspec tests
19:21:54 <freeman42> seen there is :def to alias a new command, but no idea how to run them in sequence
19:22:15 <yayfoxes> nkaretnikov: can I say iterate (+2) 1 if that seems easier?
19:22:28 <ski> freeman42 : try separating them with newlines in the output string
19:23:12 <ski> yayfoxes : you can say that, but it won't do exactly the same thing as what Cale did
19:23:13 <nkaretnikov> yayfoxes: you mean evaluate iterate (+2) 1 instead of iterate (+1) 0?
19:23:19 <freeman42> ski, not sure what you mean, I tried :r \n :main but it did not work
19:23:25 <yayfoxes> nkaretnikov: yes
19:24:00 <nkaretnikov> sure, you can try anything that matches the type
19:24:20 <yayfoxes> can you guys all learn about Haiku OS?
19:24:23 <nkaretnikov> I used to evaluate step by step a lot when I was learning scheme
19:24:43 <yayfoxes> ok, piece of text editor
19:24:51 <nkaretnikov> yayfoxes: are only guys allowed to learn about it?
19:25:15 <ski> freeman42 : `:def test \_ -> return ":reload\n:main"' seems to work here
19:25:16 <nkaretnikov> if not, please use inclusive language
19:25:23 <yayfoxes> nkaretnikov: no, guys and gals are allowed and I'm sure they would like it
19:25:24 <Cale> nkaretnikov: "you guys" is inclusive
19:25:32 <solirc> freeman42: You may want to use https://github.com/hspec/sensei (experimental!)
19:25:43 <nkaretnikov> Cale: please read: http://geekfeminism.wikia.com/wiki/Nonsexist_language
19:25:57 <Cale> nkaretnikov: "guys" in "you guys" isn't gender specific
19:26:12 <sccrstud92> ugh
19:26:13 <nkaretnikov> open the link please
19:26:18 <Cale> nkaretnikov: Even if "guy" might refer to a male person in other cases.
19:26:39 <nkaretnikov> ...
19:26:47 <sccrstud92> i guess "mankind" is sexist too
19:26:49 <freeman42> ski, works, awesome, thank you
19:26:49 <Cale> This is just a weird English convention.
19:27:13 <yayfoxes> I meant girls can learn about Haiku nkaretnikov j
19:27:22 <Cale> Girls will use "you guys" to refer to groups of other girls for instance.
19:27:28 <nkaretnikov> I don't want to spend my time trying to convince someone who doesn't want to lear
19:27:34 <nkaretnikov> n
19:27:46 <sccrstud92> yayfoxes: nkaretnikov knows that
19:27:51 <sccrstud92> great
19:28:04 <yayfoxes> sccrstud92: huh?
19:28:26 * hackagebot egison 3.5.8 - Programming language with non-linear pattern-matching against non-free data  http://hackage.haskell.org/package/egison-3.5.8 (SatoshiEgi)
19:28:36 <yayfoxes> that girls are allowed to learn Haiku?
19:28:40 * Cale is a descriptivist when it comes to language
19:29:15 <sccrstud92> yafoxes: nkaretnikov knows that you arent talking about only males when you say "you guys". because no one means "all of you who are male" when they say "you guys". so dont worry about it. we know you meant men and women
19:29:37 <Cale> Also, he was being really off-topic ;)
19:29:49 <freeman42> solirc, not sure I understand what sensei does
19:30:18 * ski sometimes thinks one should use "wereman" to refer to human males ..
19:30:41 <freeman42> solirc, and cabal repl seems to work with reloading the lib files under test unless I misunderstood something
19:31:13 <Cale> yayfoxes: But anyway, what did you want people to learn about HaikuOS? Is there any recent news about it? Maybe it would be better to discuss that in #haskell-blah, unless it's Haskell-related news.
19:31:31 <exio4> ski: werewolf  sounds better than wereman  
19:31:36 <yayfoxes> Cale: one of my goals is to port Haskell to it
19:32:25 <yayfoxes> there is slow but steady progress in Haiku land
19:33:05 <yayfoxes> let's discuss Haiku in #haskell-blah
19:34:09 <ski> (exio4 : "were"/"wer" is cognate with <https://en.wiktionary.org/wiki/vir#Latin>)
19:35:21 <exio4> ski: heh, nice
19:38:27 * hackagebot acme-flipping-tables 0 - Stop execution with rage.  http://hackage.haskell.org/package/acme-flipping-tables-0 (JacobStanley)
19:54:01 <jle`> good package
19:59:49 <sccrstud92> jle': don't be indecent ;)
20:04:50 <jle`> i like to call it like it is
20:06:29 <meretrix> > do { x <- Just 3; y <- Nothing; return x }
20:06:31 <lambdabot>  Nothing
20:07:49 <meretrix> I'm guessing no, but is there any alternative to the Maybe Monad that would only return Nothing if that last expression actually used an intermediate result that was Nothing?
20:08:25 <Cale> jle`: I consider it a bug that (╯°□°╯) "┻━┻" gets you a message with (╯°□°）╯︵┻━┻ and not (╯°□°）╯︵┳━┳
20:08:34 <meretrix> So in my example, I would want "Just 3" because "x" is not Nothing and doesn't depend on "y".
20:08:43 <djbeau> meretrix: isn't that <|> (Alternative)?
20:09:04 <Cale> meretrix: Just don't use >>=
20:09:29 <djbeau> meretrix: nm, I think I misunderstood your question
20:09:47 <Cale> meretrix: There are other operations on Maybe which probably make more sense for what you're trying to do, like mplus (or <|> from Alternative as suggested)
20:10:30 <sccrstud92> meretix: i think it might be easier to figure out how to do what you want with an actual use case
20:11:09 <Cale> Unless you're asking for the thing which requires solving the halting problem... ;)
20:12:56 <meretrix> I should probably use a real parser, but what I'm doing is reading a bunch of values using readMaybe, then returning a sum type.  The constructors of the sum type only use some of the Maybe values, so I don't want the entire thing to fail unless one of the value it needs is Nothing.
20:13:28 <meretrix> Eh probably need to explain with code..
20:14:57 <Cale> meretrix: perhaps something roughly along the lines of: (C1 <$> readMaybe x <*> readMaybe y) <|> (C2 <$> readMaybe x) 
20:15:50 <meretrix> something like "do { x <- readMaybe foo; y <- readMaybe bar; z <- readMaybe foobar; return case x of { 1 -> D1 y; 2 -> D2 x z } }
20:16:25 <Cale> Yeah, the solution is just to move the readMaybes for y and z inward.
20:17:20 <meretrix> Yeah, I was trying to save a couple lines, but I'll just do that.
20:19:35 <Cale> do x <- readMaybe foo; case x of 1 -> D1 <$> readMaybe bar; 2 -> D2 x <$> readMaybe foobar
20:21:46 <pw_> I am trying stack, after I add `extra-deps' into stack.yaml, how to make it available in the Cabal file? 
20:23:58 <pw_> or do I have to add the `extra-deps' also into Cabal manually?
20:24:12 <sccrstud92> pw_: do you actually need a cabal file when using stack?
20:26:06 <pw_> sccrstud92: I think so, I used `stack new' to create the project and there is a auto-generated cabal file.
20:48:31 * hackagebot blubber-server 0.0.1 - The blubber server, serves blubber clients.  http://hackage.haskell.org/package/blubber-server-0.0.1 (alexander)
20:49:08 <ahungry> Hello haskellers, new to the language, but old to emacs.  I'm attempting to set up haskell-mode (emacs) and ghc-mod (OS, arch linux)
20:49:42 <ahungry> I'm following the directions here: http://www.mew.org/~kazu/proj/ghc-mod/en/preparation.html, however I had to compile ghc-mod from the latest github master, as 'cabal install ghc-mod' fails with 7.10 apparently
20:50:10 <Cale> ahungry: yeah, iirc lots of people have had that same issue with ghc-mod
20:50:20 <ahungry> Now, when I type M-x ghc-debug in emacs (with a .hs file open) I get an error: Symbol's value as variable is void: ghc-interactive-command
20:50:43 <ahungry> Any haskell + emac users familiar with that error?  or what steps I've missed
20:51:13 <MarcelineVQ> I also had issues building ghc-mod and let me tell you, it works now and I have no idea why, I wish I could tell you the secret
20:52:19 <ahungry> I notice that this page mentions files being in ~/.cabal (http://www.mew.org/~kazu/proj/ghc-mod/en/install.html) - my ghc-mod and ghc-modi are currently symlinks in /usr/local/bin that point to where I built from the github branch (~/software/ghc-mod/.cabal-sandbox/bin/)
20:52:35 <ahungry> Should I be putting ghc-mod / ghc-modi elsewhere?
20:53:19 <ahungry> hah thanks MarcelineVQ maybe it'll automagically fix after a reboot or something if I'm lucky
20:53:25 <MarcelineVQ> prob not ehe
20:53:31 * hackagebot blubber 0.0.1 - The blubber client; connects to the blubber  server.  http://hackage.haskell.org/package/blubber-0.0.1 (alexander)
20:53:53 <MarcelineVQ> I think I ended up downloaded it from elsewhere and building it, I think the version cabal pulls is effed up
20:54:07 <MarcelineVQ> Try a different source, maybe a different ghc-mod version
20:54:38 <Cale> I sort of suspect that's an emacs error rather than a ghc-mod error
20:55:08 <MarcelineVQ> could be, I use atom
20:57:04 <Cale> I think that's the error you get when elisp tries to evaluate a variable which is unbound.
20:58:44 <ahungry> I guess I'll do some grepping through ghc.el and see why it's checking for that unset variable
21:01:43 <ahungry> Ok, if someone else ever encounters, fix was simple: (setq ghc-interactive-command "ghci")
21:02:48 <Cale> makes sense, but I'm not sure why that wouldn't be the default
21:03:08 <ahungry> Actually given the output I get now, I think it should be the path to ghc-modi, not ghci
21:03:19 <Cale> (or that, yeah)
21:06:54 <ahungry> heh - progress, sort of.  Now getting 'ghc-mod: src/GHCMod.hs:520:42-78: Non-exhaustive patterns in lambda' when running 'ghc-modi version'
21:08:32 * hackagebot yesod-auth 1.4.6 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.6 (MichaelSnoyman)
21:08:34 * hackagebot http-client 0.4.14 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.14 (MichaelSnoyman)
21:10:13 <Cale> ahungry: You're running the version from here? https://github.com/kazu-yamamoto/ghc-mod
21:10:25 <ahungry> aye
21:10:44 <ahungry> this is apparently the problem line from it too: legacyInteractiveCmd = withParseCmd [] $ \[] -> legacyInteractive >> return ""
21:11:06 <Cale> legacyInteractiveCmd = withParseCmd [] $ \[] -> legacyInteractive >> return "" -- this is line 520
21:11:07 <ahungry> not that far in my 'learn you a haskell' tutorials to do much more debugging than that on the line though haha
21:11:09 <Cale> yeah
21:11:25 <Cale> Well, withParseCmd must be passing that function a list which is nonempty
21:11:41 <Cale> (\[] -> ...) is a pattern match against an empty list only
21:11:57 <Cale> Not 100% sure why it's written like that in the first place...
21:15:58 <Cale> ah, I see, okay, that means that extra arguments are getting passed in on the commandline somehow
21:16:05 <Cale> (when they shouldn't be)
21:16:28 <Cale> The fact that it's calling this legacy interactive mode is also slightly unsettling :)
21:16:49 <ahungry> haha 
21:16:59 <ahungry> is ghc-mod / ghc-modi just for syntax linting ?
21:18:54 <Cale> Run "ghc-mod --help" on the commandline to see the things it provides
21:19:34 <Cale> It does a bunch of additional stuff, but it's all sort of questionably valuable. :)
21:20:19 <Cale> (then again, I'm happy as long as my editor will convert tabs to spaces and will maintain the indentation of the previous line)
21:20:42 <ahungry> haha
21:22:06 <kadoban> Syntax checking is nice, but ghc-mod was always really slow for me … other people have said that wasn't their experience though. Anyway I just switched to hdevtools eventually. I don't really use the other available stuff in either, except once in a while the "what's the type of this thing" function, whatever it is in my editor.
21:24:15 <ahungry> thanks guys - I'm used to common lisp, where setting up slime with emacs is a pretty huge boon to development and completely changes how it is done (vs just using a file and a weak REPL) - so far haskell-mode for syntax/indentation in the .hs and providing a ghci process within an emacs buffer seems pretty good
21:24:29 <ahungry> I guess I'll find out what I'm missing (if anything) as I go along
21:38:34 * hackagebot data-cell 1.0.0.0 - Generic cellular data representation library  http://hackage.haskell.org/package/data-cell-1.0.0.0 (patrykz)
22:31:20 <kadoban> In ST, how does one keep track of STRefs and STArrays and such across separate monadic actions? Should I make a mtl stack with a Reader and put them in there or something? I've never really used ST before.
22:33:03 <bergmark> kadoban: i do that with stm, so sounds good to me
22:33:44 <kadoban> Alrighty, thanks.
22:35:06 <zipper> The case statement in this function: http://lpaste.net/920645627379974144
22:35:19 <zipper> It complains that I'm using Either the wrong way.
22:35:53 <zipper> That I'm returning a value of type Either a a or Either b b
22:36:02 <zipper> Yet I want to do Either a b
22:36:45 <mauke> why are you using return in void context?
22:37:00 <mauke> oh, that's why
22:37:15 <kadoban> zipper: Usually Left is the error value … is your type at the top incorrect? Looks like it should be Either [SourceError] IdeSession ?
22:37:40 <mauke> but I'd've written that as 'when (not isConf) (rawSystem "cabal" configFlags >> return ())'
22:37:58 <arkeet> when . not = unless
22:38:16 <mauke> yeah, but unless is harder to read
22:38:18 <arkeet> x >> return () = () <$ x
22:38:28 <arkeet> = void $ x
22:39:29 <mauke> unless isConf (void (rawSystem ...))
22:39:58 <mauke> you could also factor out the return at the end
22:40:04 <arkeet> mhm
22:40:11 <arkeet> return $ case errorList of ...
22:40:18 <mauke> return $ case errorList of [] -> Right session; _ -> Left errorList
22:40:41 <mauke> return $ if null errorList then Right session else Left errorList
22:40:44 <mauke> hmm
22:41:00 <arkeet> eh, I think case is fine there.
22:41:02 <DNoved1> zipper, I think Right and Left need to be switched to match your function's declared type
22:41:14 <zipper> kadoban: haha yeah I switched them the wrong way
22:41:20 <zipper> DNoved1: Thank you
22:41:21 <arkeet> I would switch the type.
22:41:46 <arkeet> Left is typically used for failure.
22:42:18 <arkeet> also it feels very weird to me that the record update on lines 15-16 is split up over 2 lines.
22:42:39 <arkeet> (and how 14-16 have the same indentation as initSession above)
22:43:37 * hackagebot json-schema 0.7.3.7 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.3.7 (AdamBergmark)
22:43:37 <mauke> heh, you could even indent 14..16 less than initSession
22:43:39 * hackagebot generic-aeson 0.2.0.7 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.2.0.7 (AdamBergmark)
22:43:41 * hackagebot generic-xmlpickler 0.1.0.3 - Generic generation of HXT XmlPickler instances using GHC Generics.  http://hackage.haskell.org/package/generic-xmlpickler-0.1.0.3 (AdamBergmark)
22:45:36 <bergmark> mauke: i wish you could do that with let inside do :_(
23:02:01 <ttt_fff> Sql :: Database = Grep :: FileSystem ?
23:02:10 <ttt_fff> Is this true?
23:02:23 <ttt_fff> Tell_Me_Now :: IO Bool
23:03:51 <LordBrain> Can you phrase the question in english...
23:04:25 <LordBrain> I am not sure i get what you are asking.
23:06:29 <AshyIsMe> ttt_fff: return True -- TODO: work this out properly.  It builds though so let's ship it...
23:12:08 <yayfoxes> @src iterate
23:12:09 <lambdabot> iterate f x = x : iterate f (f x)
23:13:10 <yayfoxes> um...can we go over this again Cale?
23:13:38 * hackagebot fay 0.23.1.7 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.23.1.7 (AdamBergmark)
23:14:30 <yayfoxes> anybody wanting me to figure out recursion besides me?
23:14:47 <LordBrain> in other words, [x, f x, f (f x), f (f (f x) , ...]
23:15:40 <yayfoxes> x is 0, (+1) is one, +1 (+1) is two
23:15:43 <LordBrain> are you familiar with proof by mathematical induction?
23:15:47 <yayfoxes> no sir
23:16:03 <yayfoxes> I'm not at algebra 1 yet
23:16:07 <LordBrain> ok
23:16:14 <yayfoxes> where do I go learn algebra?
23:17:48 <LordBrain> to prove P x  by mathematical induction, you prove that there is such an x that makes P x true, then you prove that if it is true for one case, it is true for the next case in a sequence. It's a related concept to recursion in computer science.
23:18:07 <yayfoxes> wow
23:18:31 <yayfoxes> so it's proving that it applies itself over and over again?
23:18:51 <LordBrain> so, if you prove P 1, and you also prove that P (n+1) whenever P n, you've proved that P holds for all n more than 1.
23:18:56 <codygman> How can I set default email for cabal init?
23:19:25 <LordBrain> yayfoxes, well, no... there's no proving going on really, its a related concept, not the exact same thing.
23:19:53 <LordBrain> maybe i am only confusing you.
23:20:54 <yayfoxes> where do I learn algebra?
23:21:34 <LordBrain> junior high..
23:21:40 <LordBrain> heh
23:21:59 <codygman> My junior high didn't teach algebra too well.
23:22:05 <yayfoxes> well um, the truth is I forgot algebra and need to learn it is
23:22:11 <yayfoxes> again
23:22:30 <codygman> yayfoxes: Same happened to me, check out https://www.khanacademy.org/
23:22:37 <codygman> start from the most basic math and try to move up
23:22:42 <LordBrain> i don't know.. google learn algebra or something
23:22:45 <codygman> I had forgotten even some pre-algebra stuff
23:23:53 <codygman> LordBrain: I think a snarky answer like "junior high" when someone is asking for help is exclusionary and kind of mean... it's embarrassing to forget subjects others find simple.
23:23:55 <LordBrain> yayfoxes, if you want to know recursion tho, you don't necessarily need to learn algebra, you might instead look at what is happening from an assembly language point of view.
23:25:21 <LordBrain> the computer has an instruction pointer, when you have a loop, it means it's jumping back to a previous location. One way to implement function calls is to push parameters onto a stack and then jump to the location.
23:25:54 <LordBrain> but how does it know where to return to? well you can put that on the stack to, as if it were a parameter
23:26:16 <codygman> yayfoxes: I'm in the middle of re-learning algebra in order to learn Calculus for the first time, so kind of in the same boat. Let me know if you need any help.
23:26:30 <LordBrain> so, calling a function means pushing its argument as well as the current value of the instruction pointer on to a stack and then jumping to another point in memory.
23:27:01 <LordBrain> i'm sorry for snarkiness, i have a math degree... so it is hard for me to back up that far.
23:27:37 <LordBrain> i didnt mean any offense by anything.
23:28:11 <LordBrain> anyway, yayfoxes, are you following me about the instruction pointer and a stack with an argument and return value?
23:28:12 <codygman> LordBrain: Oh I know, but I know something like that would have hit me pretty hard in the past. Plus I wouldn't want something like that to shy anyone away from Haskell or think badly of the Haskell community.
23:28:36 <yayfoxes> LordBrain: yes
23:29:27 <yayfoxes> what's fun is abusing that stack pointer (the value of the address the top function of the stack says to return to)
23:29:36 <LordBrain> yayfoxes, ok, well, what happens if you are inside a function body already and you call it? its the same exact process... you push the parameter on the stack, the current instruction pointer (which is now inside the body of the function) and then jump to the top of the function. The function then pops things off the stack and acts accordingly.
23:30:25 <LordBrain> now in many cases, this results in an infinite loop, however....
23:30:48 <yayfoxes> um, the parameters go to the new function and when that function is done it returns either to the calling function or with some wizardry your custom function
23:31:08 <LordBrain> suppose when you come into the top of the function there is some condition, and it only calls itself in a branch, but leaves another case, called the base case without any recursion.
23:31:24 <yayfoxes> yes
23:32:07 <yayfoxes> LordBrain: let me find my 99 bottles of beer
23:32:55 <LordBrain> using that strategy, you can write recursive functions that don't loop forever, If you can break your problem into a base case, in this example the base case is the head of the list, the first cons cell, and another part, in this case, the rest, you can use recursion to handle the other part, and simply deal with the base case.
23:33:04 <LordBrain> It's always breaking bigger problems into parts
23:33:39 <LordBrain> but at each point, you have smaller and smaller parts, until eventually, you all the parts are as small as your base case.
23:34:08 <yayfoxes> LordBrain: yeah I did that with my bottles of beer. as soon as numberOfBeers is 0 it prints 'No more bottles of beer' and exits
23:34:26 <LordBrain> So, you get recurssion then, what else is there to it?
23:34:30 <yayfoxes> otherwise it prints another verse
23:34:59 <yayfoxes> I get recursion but not analyzing it, replacing equals by equals I mean
23:35:06 <yayfoxes> @src iterate
23:35:06 <lambdabot> iterate f x = x : iterate f (f x)
23:35:10 <yayfoxes> let me work on tht
23:35:11 <ttt_fff_> is ther anyway to make the haskell/db (postgresql) intersection a bit more 'typesafe' than opaleye?
23:35:31 <yayfoxes> that, maybe I'm just not working
23:36:15 <yayfoxes> but then, I'm having trouble seeing how to replace equals by equals in the iterate function
23:36:23 <LordBrain> yayfoxes, in this case maybe it is the laziness that is confusing you, because the list constructed is infinite
23:36:48 <yayfoxes> I want to do takeWhile (n < 3)
23:37:26 <yayfoxes> so the laziness will only give me 3 numbers
23:37:34 <Axman6> so takeWhile (< 3)?
23:37:47 <yayfoxes> I mean 4 numbers, including 0
23:38:05 <LordBrain> since : doesn't evaluate it's second argument until requested, you can simply write takeWhile (<3) (iterate f x) and that will give you all the results until the value is 3 or greater.
23:38:21 <yayfoxes> takeWhile (<3) (iterate (+1) 0)
23:38:36 <mniip> > takeWhile (<3) (iterate (+1) 0)
23:38:38 <lambdabot>  [0,1,2]
23:38:57 <yayfoxes> lol 3 numbers hahah
23:39:43 <LordBrain> you could also just use take
23:39:54 <LordBrain> > take 3 (iterate (+1) 0)
23:39:55 <lambdabot>  [0,1,2]
23:40:14 <mniip> LordBrain, that was not the original idea
23:40:16 <LordBrain> of course it is different if you start with a negative number
23:40:29 <mniip> > take (<84) (iterate (*2) 0)
23:40:30 <lambdabot>      Couldn't match expected type ‘Int’
23:40:31 <lambdabot>                  with actual type ‘Integer -> Bool’
23:40:31 <lambdabot>      In the first argument of ‘take’, namely ‘(< 84)’
23:40:38 <mniip> er
23:40:38 <mniip> > takeWhile (<84) (iterate (*2) 1)
23:40:39 <LordBrain> > take (<3) (iterate (+1) (-14))
23:40:40 <lambdabot>  [1,2,4,8,16,32,64]
23:40:41 <lambdabot>      Couldn't match expected type ‘Int’
23:40:41 <lambdabot>                  with actual type ‘Integer -> Bool’
23:40:41 <lambdabot>      In the first argument of ‘take’, namely ‘(< 3)’
23:41:17 <LordBrain> > takeWhile (<3) (iterate (+1) (-14))
23:41:18 <lambdabot>  [-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2]
23:43:00 <LordBrain> is there a good library for curses style windowing interface?
23:45:14 <LordBrain> hscurses is  sparse, i find myself extending the bindings and writing putStr like functions that do scrolling.
23:54:20 <ion> Huh. What’s the 9.9.9? http://hackage.haskell.org/package/stack
23:54:56 <yayfoxes> ion: idiocy
23:56:28 <pacak> on github it's 0.1.1.0
23:56:39 <ion> yayfoxes: Can you elaborate?
23:56:54 <yayfoxes> ion: no I'm busy learning math
23:57:22 <yayfoxes> I think that's a versioning bug only on hackage from what pacak states
