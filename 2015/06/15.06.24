00:03:42 <DNoved1> muller, sorry for the late reply, was out getting a coke.
00:04:14 <DNoved1> Anyways, I think the errors should be propogated fine, as I believe it is >>= that is doing the propogating, not lift.
00:04:44 <DNoved1> lift, as I understand it, just acts as a wrapper around a monad, sort of like pure/return are wrappers around values.
00:05:20 <muller> DNoved1, yes. Let me try it.
00:05:37 <DNoved1> And the MonadPlus and guard functions seem to be mostly syntactic sugar in the example, they just check if the codition is false and if so return Nothing, otherwise they continue on.
00:09:40 <DNoved1> Ah man, an ice-cold coke really hits the spot...
00:09:48 <muller> DNoved1, http://lpaste.net/135101 
00:11:29 <muller> DNoved1, Sorry. I changed the signatures and it compiles now
00:11:59 <muller> DNoved1, but it is not propogating the Nothing.
00:12:39 <DNoved1> Hmm
00:14:41 <muller> DNoved1, this is what I have now http://lpaste.net/135102
00:15:48 <DNoved1> muller, it seems to propagate the Nothing with the original one, where you had MayT instead of lift in getPassword
00:16:04 <DNoved1> The original one being this one: http://lpaste.net/135090
00:18:25 <muller> Isn't it because we are wrapping everthing in Just...?
00:22:15 <DNoved1> Well, the way I see it, lift is a pure wrapper, taking an IO a and giving you MaybeT IO a, so in a similar manner to the return/pure function you wrap it in Just.
00:22:22 <DNoved1> I could be wrong though.
00:23:16 <DNoved1> However, I'm not sure how one would go about propogating errors in lift, since it only takes one argument, and propogating errors is sort of a combining process, requiring at least two arguments to do.
00:29:27 <DNoved1> muller, this is how I think lift is supposed to be used, sort of inside the body rather than around the whole do statement: http://lpaste.net/1595829089199980544
00:29:51 <DNoved1> I also implemented fail for MaybeT, which basically acts as mzero.
00:34:32 <muller> DNoved1, if I don't want to use lift everything works fine. That is, if I use MayT in the getpassword function instead of lift. Every thign works as intended.
00:36:56 <DNoved1> Right.
01:02:42 <haskell783> I'm having trouble installing Bytestring.
01:04:01 <haskell783> My current version of ByteString is 0.10.0.2 and doing cabal update bytestring --reinstall gives me a strange error "(global constraint requires installed instance)". What can be done to fix this.
01:20:44 <breadmonster> Hello.
01:21:48 <m0rphism> haskell783: AFAIK plain cabal currently doesn't serve well for installing multiple projects, as they might depend on different versions of the same library, which isn't handled well at the moment.
01:23:05 <m0rphism> haskell783: Instead the current practices seem to use either cabal-dev, which builds each project including its dependencies in a sandbox,
01:23:13 <m0rphism> or using some sort of fixed package versions, which turn out to mostly play well together, which is the approach taken by the nix package manager and stackage
01:24:08 <m0rphism> haskell783: nix and stackage take a bit time to get into, cabal-dev behaves the same as cabal, but by default installs everything into $(pwd)/cabal-dev
01:25:57 <barrucadu> There's also sandboxes with regular cabal
01:26:39 <m0rphism> IIRC to use cabal-dev I first cleaned the previous package conflict be removing the packages installed via regular cabal by removing ~/.cabal and then only used plain cabal to install cabal-dev.
01:26:52 <m0rphism> That's of course just one possibility, but I think it is somewhat common.
01:31:09 <m0rphism> barrucadu: Is there some benefit for using regular cabal with sandboxes? I didn't knew this was possible. Where was the motivation for cabal-dev then?
01:31:31 <barrucadu> m0rphism: Without looking into it, I assume cabal-dev's sandbox functionality predates cabal's
01:31:37 <barrucadu> But cabal has had them for a few versions now
01:31:50 <m0rphism> oh, cool, I see :)
01:31:54 <m0rphism> thanks for clarifying
01:32:17 <barrucadu> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html#for-the-users-of-cabal-dev
01:33:37 <breadmonster> :t let f = id in (f 1, f "Hello")
01:33:38 <lambdabot> Num t => (t, [Char])
01:33:44 <breadmonster> Hmm.
01:33:56 <m0rphism> barrucadu: ahh, I remeber vaguely having read `cabal sandbox` somewhere, thanks for the link ;)
01:34:13 <breadmonster> :t (\f -> (f 1, f "Hello")
01:34:14 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
01:34:17 <breadmonster> :t (\f -> (f 1, f "Hello")) id
01:34:18 <lambdabot>     No instance for (Num [Char]) arising from the literal ‘1’
01:34:18 <lambdabot>     In the first argument of ‘f’, namely ‘1’
01:34:18 <lambdabot>     In the expression: f 1
01:34:30 <breadmonster> ...can someone explain what's going on here?
01:37:39 <tdammers> breadmonster: the compiler needs to decide on a type for f
01:37:59 <breadmonster> tdammers: forall a. a -> a?
01:38:36 <breadmonster> :t (\f -> let g = f in (g 3, g "True"))
01:38:37 <lambdabot>     No instance for (Num [Char]) arising from the literal ‘3’
01:38:37 <lambdabot>     In the first argument of ‘g’, namely ‘3’
01:38:37 <lambdabot>     In the expression: g 3
01:38:41 <tdammers> well, no... I think when you bind something using `let`, it has to unify
01:38:58 <tdammers> :t (id 1, id "Hello")
01:38:59 <breadmonster> tdammers: Why does the let example typecheck?
01:38:59 <lambdabot> Num t => (t, [Char])
01:39:02 <m0rphism> breadmonster: I guess the keyword is `let-polymorphism` https://www.haskell.org/tutorial/pitfalls.html
01:39:21 <m0rphism> but I'm not familiar enough with it to give a good explanation myself :(
01:39:26 <tdammers> right
01:39:29 <breadmonster> m0rphism: Oh thanks, I'll be right back.
01:40:32 <breadmonster> tdammers: Do you know anything about ghc internals?
01:40:41 <tdammers> breadmonster: not really, no
01:44:25 * hackagebot fay-base 0.20.0.1 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.20.0.1 (AdamBergmark)
01:45:11 <quetzakubica> Hey guys. How is polymorphism done in Haskell? subtype of type has to implement every operation that ancestor type has? I'm not haskell programmer btw 
01:46:20 <quetzakubica> or is there some syntax that points to ancestor operation if subtype operation does not exists?
01:46:29 <arkeet> haskell doesn't have "ancestors" or "subtypes"
01:48:30 <ronh-> quetzakubica what made you curious when you're not a haskell programmer?
01:48:50 <heatsink> Type inference determines when a function doesn't require some data to have a specific type, and it allows the function to be called with any compatible type.
01:49:10 <frerich_> quetzakubica: Polymorphism, i.e. the ability to define some code such that it works for values of different types (different 'shapes'), is not related to any kind of type inheritance. In Haskell, polymorphy is implemented simply by not specifying any particular type.
01:49:12 <quetzakubica> ronh-: I'm trying to implement some kind of strong typing in javascript
01:49:17 <quetzakubica> in FP manner
01:49:50 <tdammers> quetzakubica: why?
01:49:53 <heatsink> Have you heard of Purescript?
01:50:05 <breadmonster> quetzakubica: Also, flow.
01:50:07 <quetzakubica> I don't want to use transpillers
01:50:07 <frerich_> quetzakubica: For instance, in Haskell, the type of a list involves the type of its elements. So a list of integers is some different type than a list of strings. However, the 'length' function (which calculates the number of elements in a list) works for all lists irrespective of the type of the list elements.
01:50:09 <breadmonster> Hi merijn 
01:51:02 <tdammers> well, IMO your only options are a) make do, b) use something that compiles to JavaScript, c) use an external linter/typechecker
01:51:30 <breadmonster> merijn: Do you have any idea why Haskell lacks lambda polymorphism?
01:51:39 <quetzakubica> My main reason for this is to make simple, self documenting code
01:51:50 <tdammers> if you want the full benefits of types without compromise, then you need to go with b), I'd say
01:51:53 <quetzakubica> I love the one in F#
01:52:07 <quetzakubica> where domain can be understood just by looking at types definitions
01:52:13 <breadmonster> quetzakubica: Ideally, program in Haskell?
01:52:22 <quetzakubica> but it needs to be js :(
01:52:34 <tdammers> then forget about the type approach
01:52:35 <tdammers> really
01:52:42 <tdammers> JS doesn't have types, and you can't force it to
01:53:02 <tdammers> you're better off using things like unit tests, conventions, pre/post conditions, asserts, etc.
01:53:04 <breadmonster> quetzakubica: Facebook Flow.
01:53:21 <tdammers> making your JS more modular is also a good idea
01:53:23 <breadmonster> That's everything you need.
01:53:26 <tdammers> plenty of approaches for that
01:56:27 <quetzakubica> I'll look into that flow
01:56:35 <quetzakubica> tdammers: sure, I do that
01:59:15 <breadmonster> Is there good reading on ghc internals?
01:59:19 <breadmonster> Especially the runtime?
02:19:27 * hackagebot polysoup 0.6 - Online XML parsing with polyparse and tagsoup  http://hackage.haskell.org/package/polysoup-0.6 (JakubWaszczuk)
02:25:25 <absence> is there something similar to Data.Function.on that could be used for e.g. filtering?
02:26:39 <lyxia> absence: What do you mean?
02:27:54 <fvgvxmpv1> :t by
02:27:56 <lambdabot>     Not in scope: ‘by’
02:27:56 <lambdabot>     Perhaps you meant one of these:
02:27:56 <lambdabot>       ‘b’ (imported from Debug.SimpleReflect),
02:30:47 <absence> lyxia: hm, i'm overthinking. something like "filter ((== 3) . fst)" for a list of tuples would do the trick, so i guess there's no need for a convenience function
02:31:16 <lyxia> Indeed!
02:34:27 * hackagebot cabal-helper 0.3.6.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.3.6.0 (DanielG)
02:49:28 * hackagebot dictionary-sharing 0.1.0.0 - Sharing/memoization of class members  http://hackage.haskell.org/package/dictionary-sharing-0.1.0.0 (JonasDuregard)
02:51:12 <tsahyt> Is it possible to use the default language definitions from Text.Parsec.Language with an underlying text type that isn't String? As far as I can tell, I can't build a GenTokenParser Text u m with it for instance.
03:04:55 <george_p> how do i write a function that is id for string and show for every other instance of show?
03:06:23 <DNoved1> class SpecialShow a where specialShow :: a -> String
03:06:37 <DNoved1> instance Show a => SpecialShow a where specialShow = show
03:06:48 <DNoved1> instance SpecialShow String where specialShow = id
03:06:52 <DNoved1> I think...
03:07:15 <pavonia> These instances overlap
03:07:17 <george_p> cool let me rr
03:07:20 <george_p> try
03:07:33 <DNoved1> Ah, might not work then
03:07:43 <george_p> ah
03:08:34 <pavonia> If you don't mind writing an instance for every other type, this approach will still work
03:08:50 <george_p> I mind that..
03:09:44 <george_p> no way around it!
03:09:47 <george_p> ?
03:11:51 <pavonia> george_p: http://stackoverflow.com/questions/13949236/haskell-generate-an-instance-for-all-classes-except-one-specific-type
03:17:09 <frerich_> DNoved1: You could hack something using Data.Typeable. I never used it before, but here's a first shot: http://lpaste.net/135115
03:17:47 <frerich_> First time I did something with Typeable, so it's possibly more clumsy than it needs to be - but it appears to work for some initial tests. :-}
03:18:39 <frerich_> I think the catch is that this only works for types which have Show *and* Typeable instances.
03:18:52 <byorgey> frerich_: instead of checking equality on typeOf and then doing  fromJust . cast,  you should just do a cast and then case on the result
03:18:59 <quyse> hey there, does anyone know if there's a way to compile GHC for Windows which would produce binaries with integer-gmp linked dynamically?
03:19:04 <DNoved1> MmMm, good old intensional types breaking parametric polymorphism
03:19:11 <frerich_> byorgey: Oh, yeah, d'oh.
03:19:58 <arahael> quyse: Why would you want dynamic linking on windows?
03:20:35 <quyse> arahael: to be not bound by license of integer-gmp, which is LGPL
03:21:06 <arahael> quyse: Ugh. Fair enough.
03:21:37 <DNoved1> Is there a way to lift a higher order function, of say type (a -> a) -> (a -> a) to (a -> m a) -> (a -> m a) ?
03:21:54 <arahael> quyse: Isn't it BSD3?
03:22:27 <quyse> arahael: I'm afraid no, https://gmplib.org/
03:23:41 <frerich_> DNoved1: Based on byorgey's observation, I simplified the function to http://lpaste.net/raw/135118
03:23:57 <quyse> arahael: on UNIXes it's linking dynamically, so not a problem
03:24:28 <arahael> quyse: So the hackage description is deceptive? It's not merely "based on", but is fully derived from it?
03:24:34 <arahael> We're talking about this: https://hackage.haskell.org/package/integer-gmp
03:24:52 <DNoved1> Mm, might want to point that towards george
03:25:00 * DNoved1 pings george_p 
03:25:08 <george_p> pong
03:25:24 <DNoved1> frerich_ has a solution for showing strings/showables
03:25:42 <quyse> arahael: well, I would like someone to convince me that it's not LGPL, but seems like it is. googling finds this: http://www.mega-nerd.com/erikd/Blog/CodeHacking/Haskell/integer_pt1.html
03:26:27 <quyse> arahael: or this: https://ghc.haskell.org/trac/ghc/ticket/601
03:27:30 <byorgey> DNoved1: it should be possible to write a function specifically of type   (forall a. (a -> a) -> (a -> a)) -> (forall m b. Monad m => (b -> m b) -> (b -> m b))
03:27:44 <byorgey> DNoved1: but that is not very useful
03:27:46 <quyse> it's actually a shame that this problem is not stated clearly, in one way or another
03:27:50 <byorgey> and in general it is not possible
03:28:18 <DNoved1> Hmm...
03:28:22 <frerich_> DNoved1: Oh, oops - I thought you asked the question originally. I now see it was george :-}
03:28:32 <DNoved1> I suppose that's the reason for mapM vs map and such
03:28:44 <byorgey> DNoved1: yes, you can't get mapM from map
03:29:20 <DNoved1> frerich_, heh, I was just coming up with bad non-working solutions.
03:30:06 <george_p> DNoved1: this made your code work :). {-# Language FlexibleInstances, UndecidableInstances, OverlappingInstances #-}
03:30:59 <DNoved1> UndecidableInstances is awfully troubling
03:31:20 <DNoved1> But hey, if it works...
03:32:04 <george_p> s
03:32:17 <byorgey> UndecidableInstances is really not that bad.  OverlappingInstances is much more troubling than UndecidableInstances.
03:32:24 <george_p> what makes it troubling?
03:32:45 <DNoved1> The word undecidable gives me shivers
03:32:51 <DNoved1> Its the bane of logic
03:32:57 <byorgey> UndecidableInstances just means that the typechecker might go into an infinite loop.  But if it doesn't, everything is fine.
03:33:00 <DNoved1> s/Its/It's/
03:33:44 <SyncYourDogmas> I.e the halting problem....
03:33:58 <DNoved1> Oh, I see, so it's the sort of undecidable used in CS, not the sort of undecidable where it means choose randomly
03:34:05 <byorgey> right
03:34:22 <george_p> and what is bad about OverlappingInstances?
03:34:50 <DNoved1> I'm guessing that's the one where it chooses randomly
03:35:06 <byorgey> It doesn't choose randomly, there are well-defined rules for which instance it picks
03:35:09 <merijn> george_p: Your code can magically break if someone writes anew instance
03:35:18 <byorgey> but it is still a little weird, and what merijn said.
03:35:19 <merijn> This can be even in a different module
03:35:40 <DNoved1> Well, by randomly I mean from the point of one not intimate with the innards of their compiler
03:35:40 <byorgey> let us not even speak of IncoherentInstances.
03:35:47 <george_p> merijn: I see.. but not a concern for my code
03:35:55 <byorgey> DNoved1: indeed
03:35:57 <merijn> DNoved1: UndecidableInstances is actually not troubling, in that IF it finishes compiling it does the right thing, it's just that the compilation might hang :)
03:36:26 <merijn> So either it breaks compile time or it does the right thing, rather than having to worry about compiled code acting weird
03:36:48 <merijn> Oh, I'm late to the party :p
03:37:00 <george_p> merijn: also, code can be fixed if someone rights a new instance, no?
03:37:36 <george_p> so I fail to see how it is universally bad
03:38:07 <byorgey> george_p: sure, the point is just that the behavior of your program can change if a new instance is added in another module
03:38:23 <byorgey> it is generally considered bad if doing something in module B  can change the behavior of module A
03:38:37 <byorgey> it breaks encapsulation/modularity in some sense
03:39:09 <george_p> even if the point of some code in module A is to allow such extensions?
03:39:48 <merijn> george_p: I would try to avoid the Overlapping/Incoherent Instances extensions and ExistentialQuantification (less bad than the other two, but usually when beginners THINK they want it, they really don't), most of the others are perfectly harmless in that they can't produce odd runtime behaviour
03:39:52 <byorgey> george_p: there can certainly be legitimate uses of OverlappingInstances.  We are just talking about why it is troubling.
03:40:06 <merijn> eh, I dunno why I addressed that to anyone specific
03:41:28 <merijn> tbh, I hardly ever find myself writing my own typeclasses, so I guess that reduces my use for OverlappingInstances
03:42:53 <Murad> Hi all. Does this code work for anybody using wxHaskell? http://lpaste.net/6913249328953819136
03:43:06 <Murad> Having trouble with auiManagerGetAllPanes.
03:51:30 <alisia2> I am trying to make a MaybeT using https://en.wikibooks.org/wiki/Haskell/Monad_transformers as a reference. This is what I have right now. http://lpaste.net/135120, But the problem is that, if you look at line 40, you will be able to see that I use MayT dataconstructor to do the 'lift' instead of the actual lift function. The lift function I have now, does work,  but I think it wraps the value inside a 'just' no matter what' Which fails the purpose of Maybe.
03:52:12 <alisia2> so even Nothing ends up being Just Nothing, and passes the check for nothing in the definition of >>=
03:52:45 <alisia2> in the page I an refering to, further un-wrapping seems to take place in the definition of monadplus methods...
03:52:56 <merijn> alisia2: Why not "lift = MayT"?
03:53:24 <merijn> alisia2: Your current implementation of lift shouldn't type check
03:54:06 <merijn> alisia2: Because 'v :: Maybe a', so "return (Just v) :: Monad m => m (Maybe (Maybe a))"
03:54:54 <merijn> So "lift :: Monad m => m (Maybe a) -> MayT m (Maybe a)" instead of "lift :: Monad m => m (Maybe a) -> MayT m a"
03:55:47 <alisia2> lift = MayT does not work because lift is supposed to be m a -> t m a, while MayT is m (Maybe a) -> MayT m a, right?
03:56:19 <merijn> oh, right, my bad
03:56:51 <merijn> So it's actually right, but I'd simplify "lift = MayT . fmap Just"
03:56:53 <alisia2> current implementation compiles..but I am not using the lift function. I can use the lift function if I change the signatures of getpassword and getpasswords...but then I lose the maybe fuinctinoality.
03:57:15 <merijn> alisia2: Well of course lift always succeeds
03:57:33 <merijn> It takes a non-maybe operation and turns it into an always succeeding maybe operation
03:57:46 <merijn> If you have "IO (Maybe String)" you should use MayT, not lift
03:59:03 <dramforever> lift is lifting with no "side effects", right?
03:59:28 <alisia2> merijn, Yes, I am fine with that. But it is just that I cannot find a way to make it work without the monadplus instance...
03:59:55 <merijn> alisia2: Why?
04:00:14 <merijn> "cannot find a way to make it work" <- make what work?
04:00:21 <tdammers> "it"
04:00:25 <tdammers> "the computer"
04:00:30 <alisia2> becasue that page says "Technically, this is (MonadTrans instace) all we need; however, it is convenient to make MaybeT an instance of a few other classes:"
04:01:11 <alisia2> make it work, means I cannot propogate a nothing in the do block.
04:01:40 <merijn> alisia2: getPasswords should be Nothing if the first password is an empty string
04:02:30 <breadmonster> Hey merijn 
04:02:35 <alisia2> merijn, it works like that right now. But if I use the lift function and change the signatures, then lifting works, but the getpasswords returns the second input nomatter what the first one is...
04:02:42 <breadmonster> Do you happen to know why Haskell doesn't have lambda polymorphism?
04:02:48 <merijn> alisia2: Because lift always succeeds
04:03:01 <merijn> breadmonster: What does "lambda polymorphism" mean?
04:03:13 <dramforever> I think it has
04:03:19 <breadmonster> :t \f -> (f [], f 3)
04:03:20 <lambdabot> Num [t1] => ([t1] -> t) -> (t, t)
04:03:34 <breadmonster> Bad example.
04:03:38 <breadmonster> :t \f -> (f True, f 3)
04:03:39 <lambdabot>     No instance for (Num Bool) arising from the literal ‘3’
04:03:39 <lambdabot>     In the first argument of ‘f’, namely ‘3’
04:03:39 <lambdabot>     In the expression: f 3
04:03:50 <merijn> alisia2: lift is what you use to turn "getLine :: IO String" into "MayT IO String"
04:03:54 <dramforever> that's no lambda polymorphism
04:03:55 <breadmonster> merijn: That.
04:03:58 <dramforever> it's a rank 2 type
04:04:10 <breadmonster> dramforever: As opposed to let polymorphism?
04:04:12 <dramforever> what do you expect the type to be?
04:04:12 <merijn> alisia2: i.e. it always succeeds because there is not "maybe" there
04:04:23 <breadmonster> > let f = id in (f 3, f True)
04:04:25 <lambdabot>  (3,True)
04:04:32 <alisia2> merijn, ok. But there is maybe in the definition of MayT...
04:04:42 <merijn> alisia2: MayT is what turns an "IO (Maybe String)" into "MayT IO String", and that's what propagates the Nothing for you
04:04:46 <breadmonster> merijn: Also, I'd like to shamelessly steal your code to get half a list in one pass.
04:04:48 <dramforever> write down your type for (\f -> (f True, f 3))
04:05:12 <merijn> breadmonster: Sure
04:05:30 <breadmonster> dramforever: Num t => (forall a. a -> a) -> (t, Bool)
04:06:01 <dramforever> :t \(f :: a -> a) -> (f True, f 3) -- you need an annotation
04:06:02 <merijn> alisia2: The entire reason for using MayT is to remove the "Maybe" part from the signature and have it silently propagate, using lift KEEPS the Maybe part and then you still have to manually do it
04:06:02 <lambdabot>     Couldn't match expected type ‘a’ with actual type ‘Bool’
04:06:02 <lambdabot>       ‘a’ is a rigid type variable bound by
04:06:02 <lambdabot>           the inferred type of it :: (a -> a) -> (a, a) at Top level
04:06:08 <dramforever> wait wait
04:06:14 <dramforever> :t \(f :: forall a. a -> a) -> (f True, f 3) -- you need an annotation
04:06:15 <lambdabot> Num t => (forall a. a -> a) -> (Bool, t)
04:06:29 <merijn> alisia2: I don't understand what you think is wrong with your current version of getPasswords?
04:06:44 <breadmonster> dramforever: Oh interesting, thanks.
04:06:52 <breadmonster> Though the question was why it wasn't inferred.
04:07:03 <dramforever> because it's undecidable
04:07:07 <dramforever> as opposed to rank 1 poly
04:07:08 <merijn> dramforever: Actually it is :p
04:07:08 <alisia2> merijn, ok let me put this in a different way. How can I write the MaybeT implementation in https://en.wikibooks.org/wiki/Haskell/Monad_transformers page without using monadplus instance...
04:07:19 <merijn> dramforever: Rank2 is decidable, but a bitch to implement, so GHC doesn't
04:07:52 <breadmonster> merijn: So it's just a matter of someone implementing it?
04:08:03 <merijn> alisia2: That's what you already have?
04:08:05 <breadmonster> Or will it have other side effects?
04:08:23 <merijn> breadmonster: Well, it's unclear how the implementation would interact with other extensions, but essentially, yes
04:08:23 <dramforever> merijn: wow
04:08:46 <merijn> dramforever: It's why Rank2Types and RankN are separate extensions, despite GHC just enabling RankN when you use Rank2
04:08:47 <breadmonster> What about general rank N?
04:08:59 <merijn> dramforever: Because, conceptually someone in the future could make Rank2 inferrable
04:09:06 <dramforever> okay
04:09:08 <merijn> breadmonster: General RankN is undecidable
04:09:23 <breadmonster> merijn: How far is it decidable? Is rank 3 decidable?
04:09:34 <merijn> Rank3 is also undecidable, afaik
04:09:41 <merijn> Basically everything >2 is undecidable
04:09:45 <breadmonster> Hmm, okay, cool.
04:09:57 <alisia2> merijn, But my code does not use a lift...
04:10:02 <dramforever> hmm...
04:10:05 <breadmonster> merijn: Is there a book on this?
04:10:09 <merijn> alisia2: Why is that a problem? Lift is not relevant in your code
04:10:10 <breadmonster> Does TAPL have it?
04:10:46 <alisia2> merijn, I am trying to learn things. The point of this excercise was to understand monad transformers and how lifting works beteween them.
04:11:20 <merijn> alisia2: Ah, I see the issue their version uses guard + lift on a plain IO action over MaybeT
04:12:45 <lpaste_> merijn pasted “No title” at http://lpaste.net/135124
04:12:55 <merijn> alisia2: Those two are the same thing
04:13:14 <breadmonster> merijn: Where do I find your half list code?
04:13:30 <merijn> breadmonster: Somewhere in the list of gists: https://gist.github.com/merijn/
04:14:28 <breadmonster> Wait, I'm going to try to figure it out myself, you have one pointer that walks the list, and the other that walks the list in twos.
04:14:46 <breadmonster> And you keep adding elements to a stack until the second pointer reaches null.
04:14:58 <breadmonster> And then return the stack and the rest of the list.
04:15:03 <arahael> what's the most popular gui for haskell these days? (for apps)
04:15:03 <breadmonster> merijn: Is that correct?
04:15:14 <merijn> breadmonster: Yeah
04:15:15 <dramforever> merijn: that classic half list problem?
04:15:17 <breadmonster> arahael: gtk2hs, I think
04:15:31 <breadmonster> dramforever: Other people have seen it before?
04:15:33 <dramforever> arahael: web-based?
04:15:37 <arahael> interesting.
04:15:38 <alisia4> merijn, got disconnected. yes their version uses guard, I want to know how it will look like without the guard.
04:15:43 <merijn> dramforever: It's the tortoise&hare inspired walking the list in parallel solution + DList for efficiently building the start
04:15:48 <arahael> dramforever: no. webbased is too easy. :)
04:15:56 <merijn> alisia4: Ah, I just linked both after you disconnected, I think :)
04:15:59 <dramforever> breadmonster: yeah it's a famous interview question
04:16:05 <merijn> alisia4: http://lpaste.net/135124
04:16:11 <dramforever> merijn: wtf is the benifit of that?
04:16:18 <merijn> dramforever: Of what?
04:16:27 <dramforever> tortoise&hare
04:16:29 <dramforever> wait wait
04:16:39 <dramforever> oh, maybe it's more lazy
04:16:47 <merijn> dramforever: i.e. this: https://gist.github.com/merijn/c163cc106fd245d1cf2e
04:16:51 <breadmonster> dramforever: Umm, what really? I can't imagine anyone asking.
04:16:58 <breadmonster> Other than maybe Galois.
04:17:05 <merijn> dramforever: Because that does the list in a single traversal?
04:17:21 <merijn> dramforever: Else you have to first compute the length (one traversal) and then traverse again to build the split list?
04:17:32 <dramforever> let me check...maybe we are not talking about the same problem/solution
04:18:00 <dramforever> uh oh, looks like gist won't load
04:18:35 <merijn> The problem is basically "given a list, split it into two equal halves" (well, if you have an odd number of elements you need to decide which of the two becomes longest)
04:18:45 <dramforever> okay
04:18:54 <lpaste_> merijn pasted “splitInHalf” at http://lpaste.net/135125
04:18:58 <merijn> dramforever: That
04:19:06 <dramforever> the version I saw just needs to find the middle note
04:19:08 <dramforever> *node
04:19:24 <merijn> dramforever: Same trick, but you can skip the DList building
04:19:45 <solatis> hmm i'm getting linking errors, something about gcc unable to execute: "ghc.exe: could not execute: C:\Users\leon\AppData\Local\Programs\minghc-7.10.1-i386\ghc-7.10.1\lib/../mingw/bin/gcc.exe"
04:19:49 <solatis> however, that file *does* exist
04:20:03 <solatis> https://gist.github.com/solatis/fb4114624c1724e50aa9
04:20:06 <solatis> for full cabal -v3 log
04:20:08 <dramforever> merijn: question: if we only need to find middle node, it doesn't save anything
04:20:10 <merijn> solatis: Slashes are the wrong way
04:20:21 <dramforever> right?
04:20:22 <arahael> breadmonster: i suppose gtk2hs could be it because of RWH
04:20:25 <merijn> dramforever: Sure it does, you can still avoid traversing the list twice
04:20:33 <dramforever> merijn: not quite
04:20:38 <solatis> merijn: what is causing that ?
04:20:43 <merijn> solatis: No clue :p
04:21:07 <dramforever> in your version for a list of length n you need 3n/2 (maybe of by one) de-consing
04:21:07 <george_p> > sort (comparing length) $ words "fourteen one four eleven"
04:21:09 <lambdabot>      Couldn't match expected type ‘[String] -> t’
04:21:09 <lambdabot>                  with actual type ‘[()]’
04:21:09 <lambdabot>      The first argument of ($) takes one argument,
04:21:09 <george_p> how do I sort in reverse?
04:21:24 <solatis> also, this works: & "C:\Users\leon\AppData\Local\Programs\minghc-7.10.1-i386\ghc-7.10.1\lib/../mingw/bin/gcc.exe" --version
04:21:29 <merijn> :t sortBy (flip compare)
04:21:30 <lambdabot> Ord a => [a] -> [a]
04:21:34 <dramforever> > sortWith (comparing length) $ words "fourteen one four eleven"
04:21:35 <lambdabot>  Not in scope: ‘sortWith’
04:21:36 <solatis> merijn: so it appears Windows is able to deal with this
04:21:36 <george_p> ah
04:21:40 <dramforever> ouch ouch
04:21:41 <merijn> > sortBy (flip compare) [1..10]
04:21:43 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
04:21:59 <dramforever> merijn: I don't think it saves traversal
04:22:02 <merijn> solatis: Then I dunno :)
04:22:08 <dramforever> because you have to traverse 3n/2 times anyway
04:22:24 <merijn> dramforever: Still more efficient, since you can GC the start of the list :p
04:22:36 <solatis> merijn: what would be the next step be ? i want to find out what exactly the error is gcc is spewing out, but cabal is awefully limited in the amount of debug info they provide
04:22:38 <dcoutts> george_p: so sortBy (flip (comparing length))
04:22:44 <merijn> dramforever: "\xs -> xs !! (length xs / 2)" can't GC the start of the list as you traverse :p
04:22:51 <dramforever> merijn: in the version I saw it basically won't work...
04:22:56 <dramforever> merijn: well, yeah
04:23:34 <dramforever> but I believe an interviewer will assume an imperative language :)
04:23:41 <alisia> merijn, yes. I saw your lpaste. But if you look in the monad plus method definition in https://en.wikibooks.org/wiki/Haskell/Monad_transformers, you will see a further unwrapping going on , which is what my code is missing when I use the lift function. The page says it can be do without monad plus. I just want to know how. 
04:23:56 <merijn> dramforever: My version is in no case *worse* than the original one, and in many cases better :)
04:24:01 <dramforever> yeah
04:24:15 <dramforever> except the fact that we are really talking about different problems
04:24:19 <merijn> alisia: The MonadPlus stuff isn't relevant unless you plan to use the functions of MoandPlus
04:24:28 <dramforever> that happen to be similar in the overall goal
04:24:29 <merijn> alisia: Which isn't need for propagating Nothing
04:24:34 <lpaste_> obfuscatr pasted “want feedback” at http://lpaste.net/135126
04:24:59 <dramforever> hmm...best hlint ever
04:26:00 <lpaste_> obfuscatr revised “want feedback”: “No title” at http://lpaste.net/135126
04:26:40 <dramforever> printf from Text.Printf looks great
04:26:50 <obfuscatr> i'm a haskell newb, looking for feedback at the above lpaste link, on method, style, or anything. i find the need for cs and toLazyText annoying, is there a better way?
04:27:26 <dramforever> obfuscatr: answer just above your message (rather incomplete, though)
04:27:36 <dramforever> > printf "%0b" 23234
04:27:37 <lambdabot>      No instance for (Show a0)
04:27:37 <lambdabot>        arising from a use of ‘show_M3606039810608536196967’
04:27:37 <lambdabot>      The type variable ‘a0’ is ambiguous
04:27:41 <mniip> does a binary tree sound like something that should be a Monad
04:27:44 <alisia5> merijn: but doesn't the lift wraps the Nothing in a Just, which skips past the check in >>= implementation, (because it is a Nothing wraps in Just, the >>= only checks for Nothing)...
04:28:00 <mniip> Tree v = Leaf v | Fork (Tree v) (Tree v)
04:28:01 <merijn> alisia5: Yes, that's why the non MonadPlus version doesn't use lift
04:28:05 <merijn> alisia5: Did you look at my lpaste?
04:28:12 <dramforever> > let x = 34342 :: Word32 in printf "%032b" x
04:28:13 <lambdabot>      No instance for (Show a0)
04:28:14 <lambdabot>        arising from a use of ‘show_M8484730261245234524990’
04:28:14 <lambdabot>      The type variable ‘a0’ is ambiguous
04:28:19 <alisia5> merijn: http://lpaste.net/135124 this one?
04:28:28 <merijn> alisia5: Yes
04:28:38 <maerwald> mniip: no, unless you need it to be
04:28:42 <merijn> alisia5: The first one is the one from the wiki using monadplus, the second one does not
04:28:53 <predator217> mniip: it's a monad and >>= substitutes the values in the leaves
04:28:54 <merijn> > let x = 34342 :: Word32 in printf "%032b" x :: String
04:28:55 <maerwald> mniip: IMO, if you don't know if you need an instance, you don't need it
04:28:56 <lambdabot>  "00000000000000001000011000100110"
04:28:58 <dramforever> ???
04:29:01 <mniip> predator217, that's what I had in mind
04:29:11 <dramforever> merijn: exactly!
04:29:18 <merijn> dramforever: You forgot to specify a result type :p
04:29:46 <dramforever> obfuscatr: in your example just change body to printf "%032d" x
04:29:56 <dramforever> in case you haven't got it yet
04:30:05 <mniip> I can then write cool stuff like
04:30:09 <mniip> x >>= (\z -> if z == v then r else return z)
04:30:28 <alisia5> merijn: but, doesn't the guard function use the mzero and mplus functions? 
04:30:31 <mniip> which is rather useful in the context I'm using it in
04:31:15 <alisia5> merijn: so the guard version actually uses the second unwrapping to get actual value....
04:31:37 <predator217> mniip: just keep in mind that the wrong association can be very bad performance wise
04:31:49 <breadmonster> merijn: I'm having an issue with the implementation...
04:31:49 <predator217> http://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf gives a very good explanation
04:31:55 <mniip> predator217, wrong association?
04:32:14 <breadmonster> merijn: I end up returning the first half in reverse order.
04:32:18 <alisia5> merijn: the unwrapping code in the mplus implemetations...
04:32:21 <predator217> section 2 discusses exactly your tree case
04:32:54 <alisia5> merijn: shouldn't a monadplus less version should have the same code somewhere?
04:33:26 <predator217> basically if you have a chain of (>>=) if it is left associated you will build up trees just to tear them down in every intermediate step
04:33:35 <mniip> ah
04:33:52 <mniip> hmm
04:33:52 <dramforever> codensity again?
04:33:56 <predator217> you could use Codensity
04:34:01 <mniip> I am, in fact, folding a list of trees with >>=
04:34:38 <predator217> you can always just try out the naive way and check if it is a problem
04:34:58 <mniip> yeah
04:35:03 <mniip> I'll keep this thing in mind though
04:35:13 <predator217> if it is, you can wrap it in Codensity (http://hackage.haskell.org/package/kan-extensions-0.5.0/docs/Control-Monad-Codensity.html)
04:35:35 <predator217> which just transforms the operation to be in CPS style and reassociates binds to the right
04:39:37 <solatis> what would be the best channel to ask cabal / linker related questions ?
04:39:48 <dcoutts> solarus: this one, or #ghc
04:39:55 <dcoutts> oops
04:39:59 <dcoutts> solatis: ^^
04:40:05 <dcoutts> tab completion strikes again
04:40:15 <solatis> well, basically, cabal is spewing out linker errors on windows, when using a boilerplate yesod webapp
04:40:30 <solatis> it talks about some gcc issue
04:40:50 <solatis> i want to know exactly what command it tries to execute to reproduce the problem (to link manually, so to say)
04:41:01 <solatis> is that something that cabal does, or ghc ?
04:41:20 <solatis> cabal seems awefully quiet on the info it provides to call gcc
04:41:31 <dcoutts> solatis: run cabal with -v, you'll see how cabal invokes ghc. ghc invokes gcc, to see how it does that, pass -v to ghc.
04:41:59 <solatis> dcoutts: https://gist.github.com/solatis/fb4114624c1724e50aa9
04:42:03 <solatis> thats what -v3 gives
04:42:25 <solatis> i see a *huge* linker command
04:42:42 <solatis> i think it's about 25kb worth of characters
04:43:15 <dcoutts> solatis: this is odd:
04:43:16 <dcoutts> ghc.exe: could not execute: C:\Users\leon\AppData\Local\Programs\minghc-7.10.1-x86_64\ghc-7.10.1\lib/../mingw/bin/gcc.exe
04:43:20 <solatis> yep
04:43:24 <solatis> while this holds:
04:43:44 <solatis> C:\Users\leon\Documents\GitHub\tmp\bar> & "C:\Users\leon\AppData\Local\Programs\minghc-7.10.1-i386\ghc-7.10.1\lib/../min
04:43:44 <solatis> gw/bin/gcc.exe" --version
04:43:44 <solatis> realgcc.exe (GCC) 4.5.2
04:43:53 <solatis> minus the newline in between
04:43:55 <dcoutts> solatis: so yes, there you see the gcc command that ghc invokes
04:44:02 <solatis> yep, but not the output
04:44:30 <solatis> the only i thing i see with max verbosity is 'could not execute'
04:44:52 <bItc01D> hello
04:45:26 <solatis> so i'm getting a bit hopeless at this point
04:47:13 <alisia5> merijn: ping
04:54:03 <vektor> How is it that there's a ton of 404s when looking for GHC on hackage? Is it non-existant?
04:54:45 <dcoutts> solatis: you can execute the gcc commands manually
04:54:57 <dcoutts> solatis: use the flag for ghc that keeps intermediate files
04:55:17 <vektor> I mean, I am looking for GHC as a library. There's nothing to be found on hackage, but a ton of dead links
04:55:44 <dcoutts> vektor: I'm not sure it's there on hackage. See the ghc docs.
04:56:00 <dcoutts> vektor: arguably it should be there, just for the docs
04:56:07 <vektor> Of course, this is just a meta question. What I'm trying to do is parse and typecheck a string that contains a module - from inside a pure function. haskell-src-exts looks good but doesn't type check
04:57:35 <dcoutts> vektor: sadly ghc's library api isn't pure
04:57:46 <dcoutts> but yes you can do that, just not as a pure function
04:58:27 <vektor> Well, doing so in a pure function is essential here. I will not under any circumstances put that in IO.
04:58:50 <vektor> (background being that it's part of code that I consider unsafe.
05:00:11 <vektor> and I can be quite sure that the pure functions that make up my unsafe code have no way of doing anything malicious.)
05:01:11 <vektor> Guess I'll have to make do with the parser for now. And possibly write my own typechecker in the future.
05:13:04 <nullvoid8> vektor: have you looked at the plugins package? (http://hackage.haskell.org/package/plugins)
05:13:32 <Gurkenglas> After some reinstalling of Haskell Platform that I probably did wrong, ghc-pkg performs as expected, but ghc doesn't find nonbase modules: http://pastebin.com/j0DGmTKt
05:13:35 <vektor> I sorta have, but I was thinking its purpose is a different one...
05:14:38 <k0ral> Hello
05:14:54 <vektor> also, apparently plugin is highly IO-polluted.
05:16:22 <nullvoid8> *shrug* your question jogged my memory of it, just wanted to point it out.
05:17:15 <k0ral> my quickcheck tests always overflow my computer memory, I suspect default Arbitrary instance for lists generates huge lists
05:17:17 <vektor> yeah. I'm planning to use it, right now I'm using a call to ghc and a readProcess to avoid having to mess with plugin.
05:17:55 <KrzyStar> Hi :)
05:17:56 <k0ral> I could generate integers manually using choose(0, maxSize), and then use vectorOf, but this is really tedious as I have many lists in my data types
05:18:17 <vektor> Thing is, my Genetic Programming genome is supposed to mutate itself, i.e. the code generator is inside the genome. And even though it only is a heuristic, I want to validate the resulting genome before submitting it.
05:18:18 <k0ral> isn't there an existing combinator to do this ?
05:20:33 <saep> k0ral: You can create a newtype wrapper for a list with a custom arbitrary instance and then use that in your tests.
05:21:39 <KrzyStar> I'm looking for a clean solution to express a computation that returns a set of results based on a single seed value
05:21:59 <vektor> KrzyStar: List monad?
05:22:01 <KrzyStar> There are some intermediate values that are computed the same way between branches, so I'd like to cache them in some way
05:22:02 <k0ral> saep: isn't that a common need that would have justified providing such newtype in the quickcheck API ?
05:22:54 <lisbeth> I'm looking for an open source/open license example of a webserver for something like appache written in haskell
05:23:00 <saep> k0ral: It's just 3 lines of code. Also, how short should the list be? 10 elements? 20 elements?
05:23:10 <lisbeth> I learn to code the best by reading and playing with examples of other people's work
05:23:35 <lisbeth> So it would probably be written in something like this: https://wiki.haskell.org/Web/Servers
05:23:56 <KrzyStar> vektor: hmm, it's like I'm mapping a value over a list of function compositions
05:24:37 <KrzyStar> The functions are pretty much fixed, and some groups of them share initial functions in the compositions
05:25:27 <KrzyStar> I'm basically looking for a way to cache the results of these, so I wouldn't have to calculate the initial values over and over
05:25:58 <saep> newtype SmallList a = SmallList [a] ; instance Arbitrary a => Arbitrary (SmallList a) where arbitrary = SmallList <$> vectorOf 10 arbitrary
05:26:29 <KrzyStar> Right now I'm doing it using temporary `let`s, but it's a very fragile solution :|
05:28:08 <k0ral> saep: I need to be able to change the list size each time I create a new list, therefore I think a generator function is better suited than a wrapper
05:28:28 <k0ral> saep: smallList :: (Arbitrary a) => Int -> Gen [a]
05:29:27 <k0ral> saep: I'm really surprised this isn't part of the API, it looks like a really common need
05:31:21 <saep> k0ral: You can replace `10` with another arbitrary number, e.g. `choose (2,22)`. Or is the size dependant on the property you check?
05:32:29 <k0ral> saep: `10` is the maximum size of the list, I would perform a `choose(0, n)` internally in `smallList`
05:33:17 <k0ral> basically I just want to make sure it doesn't generate a billion elements, since each of those is expensive
05:34:32 <saep> newtype SmallList a = SmallList [a] ; instance Arbitrary a => Arbitrary (SmallList a) where arbitrary = do { n <- choose (0,10) ; xs <- vectorOf n arbitrary ; return (SmallList xs) }
05:34:51 <saep> myProp (SmallList xs) = f xs == g xs
05:38:49 <k0ral> saep: smallList n = choose(0, n) >>= \size -> vectorOf size arbitrary
05:39:13 <k0ral> saep: better rename that into `boundedList`
05:39:34 * hackagebot haskell-src-meta 0.6.0.10 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6.0.10 (GeoffreyMainland)
05:40:11 <saep> Yes, but for property checks you need types with `Arbitrary` instances so that they get fed with proper testing values.
05:41:53 <k0ral> saep: lists are "attributes" of data types that have Arbitrary instances, so that will work
05:42:24 <k0ral> saep: I mean, in my case, I have no top-level list
05:42:54 <k0ral> saep: I just need to call `boundedList` within the Arbitrary instance of the top-level data type
05:44:06 <k0ral> saep: I could use Peano numbers to include the size in a data type wrapper
05:44:22 <k0ral> saep: but that's tedious
05:44:28 <lisbeth> This page is very helpful to my request: https://httpd.apache.org/docs/trunk/getting-started.html
05:45:39 <vektor> I found this: https://downloads.haskell.org/~ghc/7.0.2/docs/html/libraries/ghc-7.0.2/Type.html#v:mkAppTy - looks like it could help in making a pure typechecker
05:49:12 <jgoux> Hello
05:49:34 <dmj`> hi
05:50:45 <jgoux> I'm very new to Haskell, coming from an OOP background. I try to define a data type with constraint (to represent an Email data type), but I can't find how to add there constraint (like a regex or something)
05:50:53 <mauke}> you can't
05:51:01 <jgoux> Can I enforce the email validation in the type or do I have to use a function ?
05:51:17 <saep> jgoux: It is better to enforce such things in functions.
05:51:19 <mauke}> ... is that a challenge?
05:51:32 <mauke}> you might be able to encode a state machine somehow, then use type-level strings ...
05:51:51 <merijn> jgoux: Usually you would not export the constructor and then provide a "String -> Maybe Email" function
05:52:01 <mauke}> also known as "smart constructors"
05:52:05 <jgoux> saep: Ok, I thought about Value Object in domain driven design and tried to "encapsulate" such validation rule in the type itself
05:52:17 <frerich_> jgoux: Yeah, you might find https://wiki.haskell.org/Smart_constructors interesting
05:52:31 <jgoux> Awesome, I check the link :)
05:52:35 <jgoux> thanks everyone !
05:52:46 <saep> jgoux: You can hide the constructor when exporting the module and only allow functions (sometimes called "smart constructors") to create valid values.
05:53:19 <mizu_no_oto> jgoux: if you're going to do email validation in particular, remember that the definition of an email address is surprisingly complex
05:53:40 <jgoux> mizu_no_oto: It was for the example
05:53:52 <mizu_no_oto> k
05:54:26 <dmj`> @package email-validate
05:54:26 <lambdabot> http://hackage.haskell.org/package/email-validate
05:54:27 <jgoux> I'm coming from php, it's a brand new world for me, but so far I love it !
05:54:35 * hackagebot OpenGLRaw 2.5.1.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-2.5.1.0 (SvenPanne)
06:18:14 * badmash
06:18:19 <badmash> hello there
06:18:37 <badmash> have a question -- appreciate any help i can get
06:19:17 <badmash> i have a function testMe :: Int -> Int -> Int -> Int
06:19:36 * hackagebot ihaskell 0.6.4.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.6.4.0 (gibiansky)
06:19:38 * hackagebot ihaskell-aeson 0.3.0.0 - IHaskell display instances for Aeson  http://hackage.haskell.org/package/ihaskell-aeson-0.3.0.0 (gibiansky)
06:19:40 * hackagebot ihaskell-basic 0.3.0.0 - IHaskell display instances for basic types  http://hackage.haskell.org/package/ihaskell-basic-0.3.0.0 (gibiansky)
06:19:42 * hackagebot ihaskell-blaze 0.3.0.0 - IHaskell display instances for blaze-html types  http://hackage.haskell.org/package/ihaskell-blaze-0.3.0.0 (gibiansky)
06:19:44 * hackagebot ihaskell-charts 0.3.0.0 - IHaskell display instances for charts types  http://hackage.haskell.org/package/ihaskell-charts-0.3.0.0 (gibiansky)
06:20:18 <lpaste_> obfuscatr pasted “how to run g <- foo inside a function..?” at http://lpaste.net/135130
06:20:24 <badmash> now :t (testMe 4 .) gives (testMe 4 .) :: (a -> Int) -> a -> Int -> Int
06:20:25 <frerich_> badmash: So far, so good.
06:20:40 <badmash> (testMe 4 .) :: (a -> Int) -> a -> Int -> Int
06:20:47 <bucaran> hi folks, what is the purpose of life? would like to hear it from a haskelian
06:20:57 <badmash> just so that everything is in one line, i retyped it
06:21:44 <badmash> now given that haskell functions really take only 1 argument, how would you interpret the type definition of (takeMe 4 .)?
06:22:09 <badmash> sorry, that should be (testMe 4 .)
06:22:31 <merijn> badmash: Note that -> in type is right associative
06:22:34 <marchelzo_> (testMe 4 .) :: (a -> Int) -> (a -> (Int -> Int))
06:22:39 <frerich_> badmash: 'testMe 4' has type 'Int -> Int -> Int', which you can also read as 'Int -> (Int -> Int)'. 
06:22:45 <reindeernix> when you use 'where' inside a function, does the variables you set in the 'where' need to be the same type as the return value of the final function?
06:22:53 <merijn> badmash: That is "(a -> Int) -> a -> Int -> Int" is "(a -> Int) -> (a -> (Int -> Int))"
06:23:03 <shiona_> (testMe 4 .) takes an function of type (a -> Int) as a parameter and returns a function that takes an a and returns a function that takes an int and returns an int
06:23:30 <marchelzo_> reindeernix: Only if you use that variable as the function's result.
06:23:38 <badmash> ah, i see
06:23:58 <merijn> So "Int -> Int -> Int" is really "Int -> (Int -> Int)", etc.
06:24:16 <reindeernix> marchelzo_, thought so, I can rule that out then, thanks :)
06:24:31 <maerwald> badmash: did you read on currying?
06:24:33 <badmash> shiona_: thanks -- i see it clearly
06:24:45 <badmash> yes, i did read on currying
06:24:46 * hackagebot ihaskell-juicypixels 0.3.0.0 - IHaskell - IHaskellDisplay instances of the image types of the JuicyPixels package.  http://hackage.haskell.org/package/ihaskell-juicypixels-0.3.0.0 (gibiansky)
06:24:48 * hackagebot ihaskell-magic 0.3.0.0 - IHaskell display instances for bytestrings  http://hackage.haskell.org/package/ihaskell-magic-0.3.0.0 (gibiansky)
06:24:50 * hackagebot ihaskell-parsec 0.3.0.0 - IHaskell display instances for Parsec  http://hackage.haskell.org/package/ihaskell-parsec-0.3.0.0 (gibiansky)
06:24:52 * hackagebot ihaskell-plot 0.3.0.0 - IHaskell display instance for Plot (from plot package)  http://hackage.haskell.org/package/ihaskell-plot-0.3.0.0 (gibiansky)
06:24:54 * hackagebot ihaskell-diagrams 0.3.0.0 - IHaskell display instances for diagram types  http://hackage.haskell.org/package/ihaskell-diagrams-0.3.0.0 (gibiansky)
06:25:41 <frerich_> badmash: Once you notice that 'testMe 4' is of type 'Int -> (Int -> Int)', you can consider the type of '(.) :: (b -> c) -> (a -> b) -> a -> c'. If you apply '(.)' to a function of type 'Int -> (Int -> Int)' it means that every occurrence 'b' is 'Int' and 'c' is (Int -> Int).
06:26:10 <badmash> frerich_: i see 
06:26:22 <frerich_> badmash: Oh, and the other thing to notice is that 'testMe 4 .' is the same as '(.) (testMe 4)'
06:27:20 <frerich_> So '(.) (testMe 4)' is of type '(a -> Int) -> a -> (Int -> Int)', which is the same as '(a -> Int) -> a -> Int -> Int' (right-associativity), which is what you started with
06:27:58 <badmash> frerich_: yes, it is!! didn't realise that.  thanks!
06:29:34 <badmash> frerich_: thanks -- you have made things very clear
06:29:56 * hackagebot ihaskell-rlangqq 0.3.0.0 - a rDisp quasiquote to show plots from Rlang-QQ in IHaskell  http://hackage.haskell.org/package/ihaskell-rlangqq-0.3.0.0 (gibiansky)
06:30:10 <badmash> frerich_: is richard brid's book on haskell a good one to learn function manipulations?
06:30:28 <badmash> frerich_: i don't see much of this in other places
06:31:08 <frerich_> badmash: Which book do you mean? I only have 'Pearls of Functional Algorithm Design', which is apparently fairly popular but for me it was a bit dense.
06:31:49 <badmash> thinking functionally in haskell --- richard bird
06:31:56 <frerich_> badmash: I don't know that one, sorry.
06:32:20 <badmash> i think he has a good discussion on equational reasoning there, i hear
06:32:36 <badmash> i see
06:32:40 <badmash> no problem
06:36:02 <lpaste_> geekosaur annotated “how to run g <- foo inside a function..?” with “how to run g <- foo inside a function..? (annotation)” at http://lpaste.net/135130#a135132
06:37:27 <badmash> merijn: thanks
06:37:41 <badmash> marchelzo_: thanks much.  i am now clear
06:44:04 * hodapp waits patiently for johnw
06:44:17 <alisia5> merijn: ping
06:44:37 * hackagebot optparse-declarative 0.3.0 - Declarative command line option parser  http://hackage.haskell.org/package/optparse-declarative-0.3.0 (HideyukiTanaka)
06:45:04 <bjoernb> hi
06:47:46 <merijn> alisia5: Yeah?
06:49:12 <bjoernb> i am reading http://learnyouahaskell.com/starting-out when i write triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]  into a file and execute it with ghci i get the error "not in scope a, b, b, <-...
06:49:37 * hackagebot network-carbon 1.0.3 - A Haskell implementation of the Carbon protocol (part of the Graphite monitoring tools)  http://hackage.haskell.org/package/network-carbon-1.0.3 (OliverCharles)
06:49:55 <mauke}> bjoernb: what's the exact error message?
06:50:00 <bjoernb> when i write let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ] parse error (possibly incorrect indentation or mismatched brackets)
06:50:30 <maerwald> bjoernb: remove let
06:50:39 <geekosaur> ghci needs the let
06:50:43 <mauke}> ...
06:50:50 <merijn> geekosaur: He said he was writing into a file
06:50:56 <merijn> geekosaur: And loading into ghci
06:51:00 <alisia5> merijn: Wondering if you could continue with your help regarding MaybeT
06:51:09 <geekosaur> ok, then yes, no let
06:51:53 <bjoernb> mauke}: http://dpaste.com/2ZK35DZ
06:52:16 <merijn> alisia5: Maybe? It depends, I'm still not sure what part confuses you?
06:52:23 <mauke}> bjoernb: <-, not ←
06:53:07 <merijn> That or enable -XUnicodeSyntax
06:53:23 <maerwald> bjoernb: http://learnyouahaskell.com/syntax-in-functions here he explains "let" and "let..in"
06:53:25 <alisia5> merijn: I am confused because there is code in the mplus method of monad plus instance, that MaybeT uses. I cannot seem to find where to include that code if I don't use Monad plus instance..
06:53:25 <geekosaur> unless there are extensions enabled... seeing the whole file (not just line 7) would also help, since sometimes errors of that kind indicate that something is wrong earlier and it's trying to read that as part of something earlier
06:53:37 <bjoernb> mauke}: that is what emacs makes of it, it is just a unicode symbol the emacs guys said.
06:53:47 <merijn> alisia5: Why do you think you need to include the code from mplus anywhere?
06:53:54 <bjoernb> i typed <- and got ←
06:53:59 <mauke}> bjoernb: yeah, stop using unicode symbols
06:54:30 <alisia5> merijn: because it does a second level unwrapping of the wrapped monad...
06:54:37 * hackagebot ekg-carbon 1.0.3 - An EKG backend to send statistics to Carbon (part of Graphite monitoring tools)  http://hackage.haskell.org/package/ekg-carbon-1.0.3 (OliverCharles)
06:54:39 * hackagebot snap-cors 1.2.9 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.9 (OliverCharles)
06:54:50 <merijn> alisia5: And why do you think you need that?
06:55:11 <merijn> guard doesn't even use mplus in it's implementation...
06:55:14 <alisia5> merijn: becasue the lift function wraps the Maybe value in Just...
06:55:15 <badmash> thanks everyone.  you all at haskell are just awesome help
06:55:40 <alisia5> So Nothing ends up being Just Nothing...which skpis past the Nothing check in >>= 
06:55:45 <bjoernb> anybody using emacs with haskell-mode and not having those unicode symbols, or knows how to stop using unicode symbol substitution?
06:55:48 <merijn> alisia5: Right, like I said, don't use lift...
06:55:56 <merijn> alisia5: My example didn't use lift for a reason
06:56:20 <merijn> "If I do X it hurts" <- the solution is to stop doing X...
06:57:01 <alisia5> merijn: But as I told before, I am learning and I want to know how to do it without monadplus, because the wiki books says it does not actually need monadplus...
06:57:21 <merijn> alisia5: Which part of my implementation without MonadPlus confuses you?
06:57:25 <mauke}> merijn: it hurts when I try to learn haskell :-(
06:58:01 <maerwald> thats a good sign
06:58:31 <alisia5> merijn: Where can I write the code to unwrap the inner monad...
06:58:44 <mauke}> every time I stop learning haskell, they keep making more of it
06:59:34 <alisia5> merijn: With monad plus, the code mplus function which is called by guard function does it...
06:59:37 * hackagebot snap-error-collector 1.1.1 - Collect errors in batches and dispatch them  http://hackage.haskell.org/package/snap-error-collector-1.1.1 (OliverCharles)
06:59:39 * hackagebot hoe 1.1.0 - hoe: Haskell One-liner Evaluator  http://hackage.haskell.org/package/hoe-1.1.0 (HideyukiTanaka)
07:00:09 <mauke}> @src guard
07:00:09 <lambdabot> guard True  = return ()
07:00:09 <lambdabot> guard False = mzero
07:00:25 <hacker> is there any way to do a zoom, but still being able to reference the "whole"? (lens)
07:00:57 <alisia5> mauke}: Oh!
07:14:38 * hackagebot json-assertions 1.0.6 - Test that your (Aeson) JSON encoding matches your expectations  http://hackage.haskell.org/package/json-assertions-1.0.6 (OliverCharles)
07:14:40 * hackagebot esqueleto 2.2.5 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2.5 (FelipeLessa)
07:14:42 * hackagebot fb-persistent 0.3.5 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.3.5 (FelipeLessa)
07:18:09 <edwardk> hacker: there is a "Lensed" monad in snap-framework that lets you do this
07:18:56 <maerwald> does anyone know how the ApplicativeDo front is doing?
07:19:26 <ion> I’m under the impression that it will be in 7.12
07:19:38 * hackagebot serversession-backend-persistent 1.0.1 - Storage backend for serversession using persistent and an RDBMS.  http://hackage.haskell.org/package/serversession-backend-persistent-1.0.1 (FelipeLessa)
07:19:40 * hackagebot digestive-functors-aeson 1.1.15 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.15 (OliverCharles)
07:20:17 <ion> Does anyone know whether ApplicativeDo applies to MonadComprehensions, too?
07:23:16 <hodapp> So, if I cannot find anything meaningful that (>>=) would stand for, nor any particular reason for 'return', but still seem to need some notion of building things up, would that seem to suggest Applicative rather than Monad?
07:23:33 <ion> Applicative implies “pure”
07:23:40 <ion> How about Monoid or Semigroup?
07:25:02 <hodapp> hmmm....
07:25:34 <benzrf> hodapp: what is it in particular
07:26:12 <hodapp> monoid may make more sense. thinking about this...
07:27:39 <hodapp> benzrf: It's a data structure description, in short. johnw had suggested applicative style for building these, or possibly do notation (though I need to hit him up when he's back on and get a better idea what he meant).
07:28:15 <benzrf> tfw monad abuse
07:28:33 <benzrf> hodapp: so elements of the type are descriptions
07:28:46 <benzrf> is that even of kind * -> *
07:29:08 <ion> Every * can be of kind * -> * if you add a dummy () in the end. ;-)
07:29:25 <benzrf> yes, and that's terrible
07:29:37 <ion> no argument
07:29:38 * hackagebot mangopay 1.11.2 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.11.2 (FelipeLessa)
07:29:40 * hackagebot yesod-mangopay 1.11.2 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.11.2 (FelipeLessa)
07:30:16 <hodapp> benzrf: that's one of the things I'm still working out. The data structures aren't so much for Haskell to use directly, but for modeling data structures within Haskell (to pass to another EDSL).
07:30:35 <benzrf> ye but
07:30:57 <hodapp> for this specific case, the elements probably all can just be concrete
07:31:00 <benzrf> i mean, what information exactly does an element of this type encode
07:31:35 <hodapp> data type (there should be TypeRep-esque forms thereof), field name, field description, and indirectly it encodes its position within the data type
07:31:43 <hodapp> what I'm working with now will be to express C structs within Ivory
07:32:11 <hodapp> at some point I'll need to go further for something similar-but-not-entirely-related where the types are gonna get a little hairier
07:35:51 <hacker> edwardk: thanks, I'll look at it
07:36:06 <hodapp> benzrf: so, it looks to me like a Monoid gets me what I need for that... it preserves order and it makes composition relatively easy
07:36:21 <hodapp> benzrf: just trying to figure out why johnw suggested applicative style, but I suppose that'd best be taken up with him
07:36:32 <maerwald> hodapp: monad gives you more choice to do crazy stuff in the middle of the effect flow, but it also makes it hard to look at "future effects" and e.g. collect errors over all effects... applicative is better there
07:37:04 <hodapp> maerwald: and I couldn't think of cases for wanting crazy stuff in the effect flow
07:37:06 <maerwald> and afaik applicative also is easiert to optimize for the compiler
07:37:15 <hodapp> maerwald: but now I'm trying to figure out what applicative gets me
07:37:21 <maerwald> hodapp: right, so I'd start with functor and applicative instance and see if that's enough
07:37:38 <maerwald> hodapp: https://stackoverflow.com/questions/23342184/difference-between-monad-and-applicative-in-haskell and https://stackoverflow.com/questions/17409260/what-advantage-does-monad-give-us-over-an-applicative are also interesting
07:38:10 <james_rth> has anybody ever used a lens as a type class fn member definition? say class X a where fn1 :: Functor f => (b -> f b) -> a -> f a
07:38:10 <hodapp> maerwald: after what ion said I'm not really looking at it as a functor vs. applicative vs. monad question, but also considering monoid
07:38:23 <edwardk> :t _1
07:38:24 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
07:38:25 <benzrf> hodapp: why not make the type first and then see what it is
07:38:27 <benzrf> :>
07:38:27 <edwardk> ^- yes
07:38:41 <maerwald> hodapp: yeah
07:38:52 <james_rth> I'm getting a weird problem with trying to define an instance of my class X with a function with that type
07:38:55 <edwardk> also makeClassy does this for you automatically
07:39:01 <maerwald> > foldr (<>) mempty [id, id] [1..3]
07:39:02 <lambdabot>  [1,2,3,1,2,3]
07:39:05 <maerwald> love that :D
07:39:11 <edwardk> james_rth: 'b' in the type you mentioned is floating free, is that intentional?
07:39:22 <james_rth> well it's concrete for my instance
07:39:30 <james_rth> say anything.. Int or whatever
07:39:30 <hodapp> benzrf: because I come from too much of an imperative/faux-OO background, and if I just 'make the type', it's not going to end up getting at any of the underlying abstractions that are simpler, most likely
07:39:32 <edwardk> class HasWhatever a where fn1 :: Lens' a Whatever -- works fine though
07:39:49 <edwardk> doesn't even need the lens package if you write the signature the way you did
07:39:57 <james_rth> it works when defined in the same file, but then when I try to define an instance somewhere else, it dies
07:40:08 <benzrf> hodapp: i suppose 
07:40:30 <edwardk> james_rth: ?
07:40:54 <hodapp> maerwald: I was mostly referring to the paper 'Applicative Programming with Effects'
07:40:55 <edwardk> james_rth: i think you just have some weird misunderstanding of a scoping issue going on that has nothing to do with less
07:40:58 <edwardk> er lens
07:41:48 <james_rth> I had a single data type with some fields and was using lens to work with the data... I thought I might generalise with a type class, so I'd be able to use the same code with instances using the same lens structure
07:42:26 <edwardk> james_rth: sure this is what makeClassy does in lens
07:42:28 <james_rth> so now my Class X instances would be defined by lenses for my other concrete data types
07:42:31 <james_rth> ah ok...
07:42:43 <james_rth> I haven't used it before
07:42:50 <james_rth> thanks for the tip...
07:42:54 <james_rth> is it easy to roll?
07:43:20 <edwardk> data Foo = Foo { _bar :: Int, _baz :: Baz }; makeClassy ''Foo
07:43:22 <edwardk> generates
07:43:43 <edwardk> class HasFoo a where foo :: Lens' a Foo; bar :: Lens a Int; baz :: Lens a Baz
07:44:28 <edwardk> my usual recommendation to make them composable is to prefix the names anyways e.g. _fooBaz -- then if you makeClassy ''Baz  you can just use `instance HasBaz Foo where baz = fooBaz`
07:44:29 <james_rth> ok
07:44:39 * hackagebot country-codes 0.1.2 - ISO 3166 country codes and i18n names.  http://hackage.haskell.org/package/country-codes-0.1.2 (FelipeLessa)
07:44:43 <james_rth> ahh
07:44:44 <edwardk> and you get direct access to all the Baz members on a Foo
07:45:18 <edwardk> anyways the makeClassy code also makes the instance for you by default
07:45:34 <edwardk> (the HasFoo Foo instance)
07:45:41 <james_rth> so I can use this for more than one data type
07:45:53 <edwardk> there is makeFields which is more ad hoc, and i'm not a huge fan as inference is worse
07:46:06 <edwardk> but makeClassy is pretty nice to use
07:46:07 <edwardk> yeah
07:46:14 <james_rth> seems so...
07:46:31 <james_rth> I'll try to give it a go now... absolutely brilliant! Thank you very much indeed for your help!
07:47:00 <edwardk> ideally i'd like to be able to specify to makeClassy ''Foo that i want HasBaz as a superclass of HasFoo -- but we can't say that today with the current API
07:47:00 <edwardk> there you have to roll your own class for now
07:47:26 <james_rth> ok
07:48:02 <edwardk> i someone sent me a patch that let me do things like makeSuperclassy ''Foo [''HasBaz] -- or something that'd be amazing
07:48:53 <edwardk> i have a ton of boilerplate that that would eliminate
08:07:43 <lifter> Could there be a simple reason that "cabal test" complains that I haven't compiled libraries with profiling enabled? I don't really want to enable profiling at this point; does "cabal test" require it or something?
08:09:40 * hackagebot gipeda 0.1.2 - Git Performance Dashboard  http://hackage.haskell.org/package/gipeda-0.1.2 (JoachimBreitner)
08:14:41 * hackagebot aivika 4.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-4.1 (DavidSorokin)
08:14:43 * hackagebot json-autotype 1.0.3 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-1.0.3 (MichalGajda)
08:15:35 <Myrl-chan> is there a function `(a -> a') -> (b -> b') -> (a,b) -> (a',b')
08:16:46 <lifter> (***) ?
08:17:07 <marchelzo_> @type bimap
08:17:09 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
08:17:20 <marchelzo_> > bimap (+1) (3,4)
08:17:22 <lambdabot>      Couldn't match expected type ‘c -> d’
08:17:22 <lambdabot>                  with actual type ‘(Integer, Integer)’
08:17:22 <lambdabot>      In the second argument of ‘bimap’, namely ‘(3, 4)’
08:17:32 <Cale> > bimap (+1) (*2) (3,4)
08:17:34 <lambdabot>  (4,8)
08:17:36 <bergmark> @type [bimap, (***)]
08:17:37 <lambdabot> [(a -> b) -> (c -> d) -> (a, c) -> (b, d)]
08:17:37 <marchelzo_> >.<
08:18:25 <lifter> > (('a' :) *** ('b' :)) *** ("hello", "world")
08:18:27 <lambdabot>      Couldn't match expected type ‘(b, c)’
08:18:27 <lambdabot>                  with actual type ‘[Char] -> [Char]’
08:18:27 <lambdabot>      In the first argument of ‘(***)’, namely ‘('a' :)’
08:18:41 <lifter> oops
08:18:49 <Myrl-chan> :t (***)
08:18:50 <lifter> > (('a' :) *** ('b' :)) ("hello", "world")
08:18:50 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:18:51 <lambdabot>  ("ahello","bworld")
08:18:53 <Myrl-chan> :t bimap
08:18:54 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
08:18:57 <lifter> there ya go
08:19:07 <Myrl-chan> Hmmm...
08:19:41 * hackagebot json-autotype 1.0.4 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-1.0.4 (MichalGajda)
08:19:41 <Myrl-chan> > bimap ('a' :) ('b' :) ("Hello", "World")
08:19:43 <lambdabot>  ("aHello","bWorld")
08:19:56 <Myrl-chan> oh cool. Thanks lifter.
08:20:03 <lifter> np
08:23:32 <benzrf> bifunctors are handy
08:23:34 <benzrf> :>
08:23:48 <srenatus> criterion <3  (just saying, no context)
08:24:05 <hodapp> bitemyapp: if you (I think it was you?) were curious on the haskell-mode issue that I had weeks back on OS X, apparently this stems from an acknowledged issue: https://github.com/purcell/exec-path-from-shell
08:28:05 <hamid> http://chrisdone.com/posts/haskellers =)))
08:28:15 <hamid> This is so funny :)))
08:28:24 <hamid> Iron Man :D
08:29:14 <ttk> Why does this have the type ^M? intToDigit :: Int -> Char
08:29:25 <ttk> Why does this have the type ^M? intToDigit :: Int -> Char^M
08:29:32 <ttk> and what does it mean?
08:29:44 <srenatus> ttk: windows CRLF
08:29:58 <srenatus> not a type, an artefact. (gtg, sorry)
08:30:37 <jemendja> hi
08:30:47 <ion> hamid: :-D
08:31:23 <Cale> ttk: Did srenatus' answer solve your problem, or are you still confused about what's going on? :)
08:31:33 <ttk> hehe still confused
08:32:44 <Cale> ttk: On Windows, newline characters are represented by a carriage return character, followed by a line feed. On most other systems, just line feed is used.
08:32:45 <mauke}> apparently your text editor displays carriage return (CR) as ^M (control-m)
08:33:15 <ttk> ah okay. Thaks
08:33:21 <mauke}> (CR is ascii 13, LF is ascii 10. two bytes.)
08:34:30 <ttk> can you guys tell me why 1:2:[1,2] works but 1:2: $ [1,2] does not?
08:34:45 <Cale> ttk: Because you have two infix operator symbols in a row
08:34:48 <L8D> ttk: (:) is an infix operator
08:34:55 <Cale> ttk: It's like writing  1 + * 6
08:35:00 <L8D> ^^
08:35:15 <ttk> why doesn't the last : wait for an argument?
08:35:40 <Cale> It's not syntactically valid to place two infix operator symbols in a row like that
08:35:40 <L8D> you can do:
08:35:55 <Cale> (1:) . (2:) $ [1,2] -- should work
08:36:04 <L8D> > (:) 1:2:[] $ [1, 2]
08:36:06 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
08:36:06 <lambdabot>                  with actual type ‘[[a0] -> [a0]]’
08:36:06 <lambdabot>      The first argument of ($) takes one argument,
08:36:11 <L8D> wait
08:36:23 <Cale> there are several problems with that :)
08:36:39 <L8D> Haven't had my coffee...
08:36:49 <Cale> ttk: Note that things like (1 :) are special syntax (and the parens aren't optional)
08:37:03 <ttk> thanks
08:37:11 <ttk> think I get it
08:37:22 <danilo2> Hello Guys! I've got just a simple question :D How can I take safe head of a list using lenses - i mean head that returns Maybe element?
08:37:24 <Cale> (a *) is translated to (\x -> a * x) and (* a) is translated to (\x -> x * a)
08:37:40 <Cale> danilo2: Why with lenses?
08:37:47 <Cale> :t maybeToList
08:37:48 <lambdabot> Maybe a -> [a]
08:37:51 <Cale> :t listToMaybe
08:37:52 <lambdabot> [a] -> Maybe a
08:38:13 <danilo2> Cale: I was just wondering how can we use it with "at" and some accessors from lenses. Just out of curious
08:38:30 <Cale> There's likely a prism
08:38:55 <ion> > [42] ^? folded
08:38:56 <lambdabot>  Just 42
08:39:24 <danilo2> Cale, ion : hmm interesting, thank you!
08:39:36 <supki> :t preview _head
08:39:37 <lambdabot> (MonadReader s m, Cons s s a a) => m (Maybe a)
08:39:42 * hackagebot json-autotype 1.0.5 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-1.0.5 (MichalGajda)
08:39:47 <ion> > [42,43] ^.. folded
08:39:48 <lambdabot>  [42,43]
08:41:26 <danilo2> ion: ok, thank you very much. I was thinking that sometihng like [1,2,3] ^? at 1 would work, but in fact it didnt. Thanks for the solutions :)
08:42:14 <sammecs> Hi, I have a problem installing wxHaskell. I try to install it using cabal-install. 
08:42:28 <sammecs> Cabal then tells me that I need the library wx_gtk2u_media-3.0
08:42:58 <sammecs> But there is not package on the debian package base, am I right? (using LinuxMint)
08:43:25 <ion> > [42, 43] ^? ix 1
08:43:26 <lambdabot>  Just 43
08:43:30 <Cale> sammecs: try installing libwxgtk-media3.0-dev
08:43:40 <Cale> (from apt)
08:46:11 <sammecs> Cale: OK, in the moment, it seems to work... ^^ At least it showed no error messages yet.
08:47:04 <bollu> Question: Why can I not use <|> with Either?
08:47:16 <mauke}> :t (<|>)
08:47:18 <lambdabot> Alternative f => f a -> f a -> f a
08:47:44 <bollu> yeah, so, something like this should work: Left "not-working" <|> Right "working" = Right "working"
08:47:47 <bollu> but it doesn't work
08:47:51 <mauke}> > "not-working" <|> Right "working"
08:47:52 <lambdabot>      Couldn't match type ‘Either a0’ with ‘[]’
08:47:53 <lambdabot>      Expected type: [Char]
08:47:53 <lambdabot>        Actual type: Either a0 Char
08:48:00 <mauke}> > Left "not-working" <|> Right "working"
08:48:01 <lambdabot>  Right "working"
08:48:07 <bollu> o_o
08:48:14 <bollu> > Left "not-working" <|> Right 1
08:48:15 <Cale> There just needs to be an instance of Alternative for Either e in scope.
08:48:16 <lambdabot>  Right 1
08:48:31 <bollu> Cale: how do I bring it in scope?
08:48:36 <L8D> bollu: Either isn't an Alternative
08:48:44 <L8D> nor a semigroup
08:48:45 <mauke}> where is lambdabot's instance coming from?
08:49:07 <Cale> It's an Alternative in lambdabot because lambdabot imports dozens of things, and probably there's an orphan instance for it somewhere.
08:49:38 <L8D> mauke}: it might have an orphan instance for Alternative a => Alternative (Either a)
08:49:42 * hackagebot atom-conduit 0.1.0.0 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  http://hackage.haskell.org/package/atom-conduit-0.1.0.0 (koral)
08:49:43 <bollu> can someone tell me where the alternative instance is defined?
08:49:43 <L8D> or something of the sort
08:49:44 * hackagebot bloodhound 0.6.0.1 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.6.0.1 (bitemyapp)
08:49:48 <shachaf> lambdabot's instance is the one in Control.Monad.Trans.Error
08:49:53 <L8D> bollu: you don't want to use it anyways
08:49:53 <shachaf> > Left 'a' <|> Right 'b'
08:49:54 <bollu> L8D: is it ill defined?
08:49:55 <lambdabot>      No instance for (Control.Monad.Trans.Error.Error Char)
08:49:55 <lambdabot>        arising from a use of ‘<|>’
08:49:55 <lambdabot>      In the expression: Left 'a' <|> Right 'b'
08:50:03 <mauke}> shachaf++
08:50:11 <bollu> L8D: what do you mean?
08:50:24 <bollu> L8D: I'm writing a tokenizer, and I want to "test" possible parses
08:50:48 <bollu> like, TokenizeOperator str <|> TokenizeNumber str <|> TokenizeIdentifier str
08:51:02 <bollu> little  "t" on the Tokenize :)
08:51:20 <L8D> bollu: what is the type of the token?
08:51:47 <bollu> data Token = TokenInt Int | TokenFloat Float | TokenIdentifier String | TokenPlus | TokenMinus | ... | TokenEOF
08:52:23 <bollu> so, like, I want the tokenie function to be: tokenizeNumber :: <context> -> Either Error Token
08:52:27 <L8D> bollu: and tokenize functions return Either SomeErrorType Token ?
08:52:30 <sammecs> Cale: It worked! Thank you very much.
08:52:33 <bollu> but, I wasn't able to use (<|>)
08:52:34 <bollu> yes
08:52:36 <ion> danilo2: ix lets you traverse to a specific key or index and view or modify the corresponding value, if any. at additionally lets you insert or delete a key, but only in a container like Map.
08:52:37 <L8D> bollu: you can just bind them together
08:52:46 <L8D> not with (<|>) but with (>>=)>
08:52:54 <bollu> L8D: but binding will "overwrite" the context right?
08:53:03 <L8D> > Left "foo" >> Right "bar"
08:53:05 <lambdabot>  Left "foo"
08:53:09 <bollu> whoa
08:53:11 <bollu> slicl
08:53:14 <bollu> slick*
08:53:20 <bollu> Left "foo" >> Right 2
08:53:22 <danilo2> ion: I was thinking about ix!
08:53:23 <bollu> > Left "foo" >> Right 2
08:53:23 <L8D> > Right "foo" >> Right "bar"
08:53:25 <lambdabot>  <no location info>: can't find file: L.hs
08:53:25 <lambdabot>  Right "bar"
08:53:34 <danilo2> ion: [1,2,3] ^? ix 1 
08:53:36 <danilo2> works :D
08:53:38 <danilo2> thank you!
08:53:38 <bollu> L8D: I want it to be "Right foo"
08:53:54 <bollu> because I don't want the previous parse that worked to be overwritten
08:54:24 <L8D> bollu: you want it to find the first successful operation?
08:54:26 <bollu> yes
08:54:31 <bollu> exactly
08:54:41 <bollu> I wasn't able to put it in the right words :)
08:55:14 <bollu> L8D: So... solution?
08:55:55 <tedkornish> Where is lambdabot behavior documented?
08:56:11 <Cale> tedkornish: In lambdabot's source code
08:56:18 <tedkornish> Ah, nevermind, found it - silly question: https://wiki.haskell.org/Lambdabot & source
08:56:23 <bollu> L8D, Cale ?
08:56:26 <L8D> bollu: are you defining your own error type?
08:56:35 <bollu> L8D: I would want to later
08:56:36 <ion> > asum [ Left 0, Right 1, Left 2 ]
08:56:37 <lambdabot>      Not in scope: ‘asum’
08:56:38 <lambdabot>      Perhaps you meant one of these:
08:56:38 <lambdabot>        ‘F.asum’ (imported from Data.Foldable),
08:56:43 <Cale> bollu: what?
08:56:54 <bollu> Cale: any idea on possible solutions? of the Alternative thing?
08:56:57 <L8D> bollu: define an error type with a base case (like NoParse or EmptyParse or something)
08:56:57 <ion> > F.asum [ Left 0, Right 1, Left 2 ]
08:56:59 <lambdabot>      No instance for (Show a0)
08:56:59 <lambdabot>        arising from a use of ‘show_M1454157381771634545213’
08:56:59 <lambdabot>      The type variable ‘a0’ is ambiguous
08:57:18 <L8D> bollu: then define an instance for Alternative (Either YourErrorType)
08:57:25 <Cale> Or just do without it
08:57:30 <bollu> aww :(
08:57:35 <bollu> But.. okay. Will do
08:57:40 <Cale> There are a lot of ways to manipulate lists of Either values
08:57:50 <Cale> Not least of which is that you could write a list comprehension
08:57:55 <Cale> Or use partitionEithers
08:58:00 <Cale> :t partitionEithers
08:58:02 <lambdabot> [Either a b] -> ([a], [b])
08:58:07 <bollu> hmm
08:58:15 <Cale> Useful for separating error conditions from successes
08:58:19 <bollu> but, you know, Alternative expresses the right "intent"
08:58:28 <bollu> short-circuit success
08:58:42 <bitemyapp> hodapp: oh yeah, I ended up just symlinking into /usr/bin
08:58:45 <L8D> bollu: if you want to write tests
08:58:45 <Cale> Okay, so you want the first success?
08:58:47 <bitemyapp> hodapp: I do that with everything now :P
08:58:51 <bollu> Cale: yep
08:58:57 <bollu> L8D: yes? If I do?
08:59:00 <L8D> bollu: then partitionEithers can be useful for writine large assertion sequences
08:59:09 <L8D> maybe
08:59:12 <Cale> You could use  listToMaybe [x | Right x <- xs]
08:59:35 <Cale> :t rights
08:59:37 <lambdabot> [Either a b] -> [b]
08:59:41 <Cale> yeah, that exists too
08:59:44 <mauke}> I see you know your rights
08:59:50 <Cale> :t listToMaybe . rights
08:59:51 <bollu> firstSucess xs = [x | Right x <- xs] !! 0 ?
08:59:51 <lambdabot> [Either a1 a] -> Maybe a
09:00:07 <Cale> :t head . rights -- dangerous
09:00:09 <lambdabot> [Either a c] -> c
09:00:25 <bollu> :t listToMaybe
09:00:28 <lambdabot> [a] -> Maybe a
09:00:36 <bollu> > listToMaybe [1, 2, 3] 
09:00:39 <lambdabot>  Just 1
09:00:41 <bollu>  > listToMaybe [1, 2, 3] 
09:00:49 <bollu> > listToMaybe [] 
09:00:50 <lambdabot>  Nothing
09:00:59 <bollu> hmm. TIL about listToMaybe
09:01:08 <bollu> cool, thanks a lot for the help :D much appreciated
09:03:26 <ttk> I have a function where I am iterating over 2 variables: getLineStars init fxs@((nr,_):xs) = replicate (nr-init) ' ' ++ "*" ++ (getLineStars (nr+1) xs) -> Is there any clever way to use some built in stuff so I do not have to make my own recursion?
09:03:56 <mauke}> what's the base case?
09:04:22 <ttk> _ [] = []
09:04:27 <bitemyapp> hodapp: also my problem wasn't Emacs not using the shell's path
09:04:37 <bitemyapp> hodapp: I know how to set the path in Emacs, it wasn't using its own bloody path.
09:04:47 <bitemyapp> hodapp: nearly lost my damn mind figuring that out.
09:06:33 <mauke}> :t foldr (\(nr, _) z init -> replicate (nr - init) ' ' ++ "*" ++ z (nr + 1)) (const "")
09:06:34 <lambdabot> Foldable t => t (Int, t1) -> Int -> [Char]
09:06:55 <mauke}> :t foldr (\(nr, _) z init -> replicate (nr - init) ' ' ++ "*" ++ z (nr + 1)) (const "") :: [(Int, a)] -> Int -> String
09:06:56 <lambdabot> [(Int, a)] -> Int -> String
09:12:15 <ion> > (runExcept . F.asum . map except) [ Left "a", Right 'b', Right 'c', Left "d" ]
09:12:16 <lambdabot>  Right 'b'
09:12:26 <ion> > (runExcept . F.asum . map except) [ Left "a", Left "d" ]
09:12:28 <lambdabot>  Left "ad"
09:13:24 <ion> bollu: Would this be useful? You can also use a Monoid such as First on the error part.
09:13:48 <ion> Or perhaps your error type can be a Monoid.
09:14:37 <Cale> ttk: I don't know whether the 'init' is actually important to you, but if the assumption is that you're generally going to pass 0 there, you could take a very different approach and write something like...
09:14:49 <ttk> I am going to pass 0
09:19:06 <Cale> > let getLineStars xs = [if S.member i s then '*' else ' ' | i <- [0..m]] where s = S.fromList xs; m = maximum s in getLineStars [2,3,5,7,11]
09:19:08 <lambdabot>  "  ** * *   *"
09:19:44 * hackagebot mac 0.1.0.0 - Static Mandatory Access Control in Haskell  http://hackage.haskell.org/package/mac-0.1.0.0 (AlejandroRusso)
09:19:59 <Cale> Probably could be more efficient, but that has clearer intent I think :)
09:21:14 <Cale> (I also factored out the map fst)
09:21:48 <mauke}> > foldr (\nr z init -> replicate (nr - init) ' ' ++ "*" ++ z (nr + 1)) (const "") [2, 5, 5, 2] 0
09:21:50 <lambdabot>  "  *  ***"
09:22:05 <mauke}> > let getLineStars xs = [if S.member i s then '*' else ' ' | i <- [0..m]] where s = S.fromList xs; m = maximum s in getLineStars [2, 5, 5, 2]
09:22:06 <lambdabot>  "  *  *"
09:22:24 <Cale> Yeah, it doesn't strictly do the same thing
09:22:34 <Cale> I'm guessing a little at what the intent of the code is.
09:22:49 <ttk> I am maknig a histogram from some exercises
09:23:02 <ttk> that method is for one line
09:23:27 <ttk> thanks though - It is a bit out of my league for now. I'll probably get to it later :)
09:23:30 <Cale> It might be easier to make the histogram going the other way, and then pad things and transpose.
09:23:38 <bitemyapp> Cale: not to pester, but should I have gotten feedback in an email yet? Sometimes stuff falls through the cracks (email) and I wanted to make sure I didn't miss anything.
09:23:54 <ttk> already got it working - just trying to optimize it a bit :)
09:24:04 <Cale> bitemyapp: Ah, I didn't quite finish, if you want, I'll send what notes I already made :)
09:24:23 <bitemyapp> Cale: no no, please finish
09:24:29 <bitemyapp> Cale: just wanted to check. Sorry for bugging you :)
09:25:09 <Cale> bitemyapp: Have you ever seen my fold diagrams?
09:25:32 <ttk> I have a very simply function: sortElementFunc (a1,_) (a2,_) = a1 > a2 and I would love to be able to do some fancy stuff so I  don't have to write the arguments.. something like: sortElementFunc = ... I have looked at :t (.)(.) and it seems like the way to go, but I cannot figure it out
09:26:29 <mauke}> :t comparing fst
09:26:30 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
09:26:36 <Cale> :t (>) `on` fst
09:26:37 <lambdabot> Ord a => (a, b) -> (a, b) -> Bool
09:27:02 <ttk> ah never heard of on
09:28:53 <ttk> :t on (>) (fst)
09:28:54 <lambdabot> Ord a => (a, b) -> (a, b) -> Bool
09:29:45 <Cale> ttk: It's named so that it reads nicely as infix :)
09:29:56 <Cale> :t compare `on` fst
09:29:57 <ion> FWIW, I have never seen nested (.)s that have made the code better than the more pointful alternative.
09:29:57 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
09:30:21 <ttk> ahh
09:30:24 <Jello_Raptor> hmm, is there some way to make complex structures out of multi-class tpyeclasses without the number of explicit types attached to each class exploding? 
09:30:25 <ion> That is, that haven't made the code worse
09:30:46 <Cale> (of course, in the case of compare, you could just as well write comparing fst)
09:31:12 <Cale> Jello_Raptor: multi-class type classes?
09:31:21 <Cale> multiparameter type classes?
09:31:35 <Jello_Raptor> Cale: d'oh, yes. 
09:31:36 <bitemyapp> Cale: I'm not sure. Let me say no and see if I recognize what you link :)
09:31:45 <Cale> bitemyapp: http://cale.yi.org/share/Folds.svg
09:32:09 <Cale> bitemyapp: You might want to include something of the sort just for foldr/l
09:32:11 <bitemyapp> Cale: is this where the foldr/foldl diagrams come from in the wiki?
09:32:12 <maerwald> Cale: i find that rather confusing tbh
09:32:16 <Cale> bitemyapp: yeah
09:32:19 <bitemyapp> Cale: I was trying to translate those to text.
09:32:24 <bitemyapp> Cale: in the folds chapter
09:32:48 <Cale> Right :)
09:32:56 <bitemyapp> Cale: I'll show it to my coauthor when your feedback comes in
09:33:12 <bitemyapp> Cale: I never knew about the rest of the diagrams, thank you.
09:33:25 <Cale> If you're going to talk about the spine of a list without actually depicting the graph structure though, I think it gets a little weird, perhaps
09:33:53 <bitemyapp> Cale: we kind of do. We don't talk about non-strictness more fully until a later chapter.
09:33:59 <bitemyapp> Cale: but this is a conversation to have in email.
09:34:04 <Cale> okay
09:34:06 <bitemyapp> Cale: I don't like discussing feedback/content without my author cc'd.
09:34:09 <bitemyapp> coauthor*
09:34:39 <Cale> Actually, I'll send an email with my comments on the early part of the chapter now, just so that we can interact a bit more :)
09:34:44 * hackagebot aeson-applicative 0.1.0.0 - make To/From JSOn instances from an applicative description  http://hackage.haskell.org/package/aeson-applicative-0.1.0.0 (GregWeber)
09:35:07 <bitemyapp> okie dokie
09:38:46 <ocharles_> In a -hc heap profile, what is "MAIN"?
09:38:52 <ocharles_> I understand "PINNED" is stuff like foreign memory allocations
09:42:31 <bitemyapp> ocharles_: initial entrypoint innit?
09:42:50 <ocharles_> well there are allocations in "MAIN" throughout the whole heap profile
09:42:56 <bitemyapp> that's odd.
09:42:58 <ocharles_> I only have a few select cost centres though
09:43:37 <bitemyapp> ocharles_: how much forking are you doing?
09:43:59 <ocharles_> Quite a bit I imagine, this is a Snap application
09:44:16 <bitemyapp> ocharles_: 7.8.4?
09:44:25 <ocharles_> yep
09:44:33 <bitemyapp> this is a #ghc question
09:45:55 <Murad> Hey all, I have a minimal reproducible example of a wxHaskell-related bug when I call auiManagerGetAllPanes. Would anybody be willing to try my snippet and report their results? I can't tell if I have something compiled or configured incompatibly or there is a bug in wxHaskell or wxWidgets. http://lpaste.net/6913249328953819136
09:51:30 <Murad> Anybody have wxHaskell set up on Windows?
10:04:46 * hackagebot ip-quoter 1.0.1.0 - Quasiquoter for IP addresses  http://hackage.haskell.org/package/ip-quoter-1.0.1.0 (shlevy)
10:04:53 <ttk> hmm a function with this signature: (a -> b) -> [a] -> [(a,b)] would be nice to have in genereal
10:05:41 <shapr> @hoogle (a -> b) -> [a] -> [(a,b)]
10:05:42 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
10:05:42 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
10:05:42 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
10:06:14 <mniip> > listens ord "hello"
10:06:15 <lambdabot>      No instance for (MonadWriter Char [])
10:06:16 <lambdabot>        arising from a use of ‘listens’
10:06:16 <lambdabot>      In the expression: listens ord "hello"
10:06:19 <ion> @type \f -> fmap ((,) <*> f)
10:06:20 <lambdabot> Functor f => (a -> a1) -> f a -> f (a, a1)
10:12:51 <subleq> @pl \f xs -> map (\x -> (x, f x))
10:12:51 <lambdabot> const . map . ap (,)
10:13:42 <subleq> @pl \f -> map (\x -> (x, f x))
10:13:42 <lambdabot> map . ap (,)
10:14:12 <Welkin> @djinn m a -> (a -> m b) -> m b
10:14:13 <lambdabot> -- f cannot be realized.
10:14:20 <lifter> Compiling all your libraries with profiling enabled will degrade performance, correct?
10:14:29 <Welkin> :t (>>=)
10:14:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:14:42 <Welkin> @djinn Monad m => m a -> (a -> m b) -> m b
10:14:42 <lambdabot> f = (>>=)
10:24:46 * hackagebot ip-quoter 1.0.1.1 - Quasiquoter for IP addresses  http://hackage.haskell.org/package/ip-quoter-1.0.1.1 (shlevy)
10:26:02 <geekosaur> lifter: if you build something for profiling, yes. the profiled libraries are separate from the non-profiled ones
10:28:18 <lifter> geekosaur: ok, thanks
10:28:49 <reindeernix> how would I be able to run a function really many times without overflowing? I want to feed the result of the function to the function which I can do recursively, this overflows at some point though
10:30:02 <koala_man> reindeernix: can you write it in a tail recursive way?
10:30:51 <reindeernix> I don't think so since I return a list of my custom data type
10:31:24 <Welkin> > iterate (+1) 0
10:31:26 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:31:55 <Gurkenglas> > iterateM (replicate 2) ()
10:31:56 <lambdabot>      Not in scope: ‘iterateM’
10:31:56 <lambdabot>      Perhaps you meant one of these:
10:31:56 <lambdabot>        ‘iterate’ (imported from Data.List),
10:32:11 <Gurkenglas> (Wait, what? That doesn't exist?)
10:32:20 <reindeernix> Welkin, thanks will try
10:32:43 <Welkin> Gurkenglas: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
10:33:40 <albeit_> When doing an unsafe foreign call, is there a context switch of any meaningful duration? > 1 microseconds?
10:34:31 <Gurkenglas> Butbutbut I want (a -> m a) -> a -> [m a]. Although that wouldn't reduce to iterate through m=Identity, because the initial a isn't in the list...
10:34:44 <int-e> albeit_: no.
10:35:02 <hexagoxel> @djinn Monad m => m a -> (a -> m c) -> m c
10:35:03 <lambdabot> -- f cannot be realized.
10:35:05 <bennofs> albeit_: I believe an unsafe foreign call is about 2-digit nanoseconds
10:35:19 <hexagoxel> Welkin: djinn has some limitations..
10:35:23 <albeit_> Fantastic, thanks int-e bennofs 
10:35:26 <Gurkenglas> (I guess it could return [(a -> m b) -> m b].)
10:35:35 <Welkin> @djinn Monad m => m a -> (a -> m b) -> m b
10:35:36 <lambdabot> f = (>>=)
10:36:01 <thimoteus> @djinn ([a -> b] -> [a -> b]) -> ([a] -> [a]) -> [b] -> [b]
10:36:01 <lambdabot> Error: Undefined type []
10:37:45 <reindeernix> iterate is awesome, thanks man
10:38:04 <reindeernix> much faster than recursively feeding back my result
10:38:58 <quchen> reindeernix: iterate isn't strict in its argument, so it can overflow as well. Or more accurately, produce an output list with thunks that can overflow when forced.
10:39:01 <quchen> ?src iterate
10:39:01 <lambdabot> iterate f x = x : iterate f (f x)
10:39:25 <quchen> If you take the n-th element of that list, you'll get an n-times nested f application.
10:39:32 <Gurkenglas> (iterate is merely "iterate f x =  x : iterate f (f x)" - you could do everything it can do in your code if you do it correctly, but using iterate forces your code into a form that can't overflow. (If I understand this correctly.))
10:40:08 <Gurkenglas> Disregard that, q. knows more.
10:40:36 <Gurkenglas> So why did djinn say it can't be realized up there?
10:41:07 <reindeernix> quchen, I see, atleast it's faster and it seems like I can crunch much bigger numbers with it
10:41:11 <lpaste_> int-e pasted “unsafe calls (for albeit_)” at http://lpaste.net/135136
10:42:06 <quchen> reindeernix: It's pretty much the naive recursive definition you'd expect from iterate, I'm not sure why it would be faster
10:42:18 <quchen> Maybe you're benefiting from some list fusion or something
10:43:34 <reindeernix> quchen, it might just be placebo though, I haven't measured the time but it just feels faster
10:43:39 <quchen> :>
10:45:23 <int-e> albeit_: in this simple case at least it's comparable to a C function call (with a little extra stack manipulation, and an extra load to rax because it has to assume that it may be calling a varargs function)
10:46:46 <quchen> Gurkenglas: I think Lambdabot can't do thungs like classes and recursive types. Since "m b" and "m c" are fully equivalent yet >>= only works with the "b", I think >>= is hardcoded for some reason.
10:46:54 <quchen> Probably for showing off with Lambdabot's flexibility ;-)
10:47:56 <quchen> The lack of lists can be seen quite easily,
10:47:58 <quchen> ?djinn [a]
10:47:58 <lambdabot> Error: Undefined type []
10:48:00 <quchen> But 
10:48:02 <quchen> ?djinn Maybe a
10:48:03 <lambdabot> f = Nothing
10:48:09 <quchen> So it knows about *some* types.
10:48:43 <quchen> I think there's also some Functor stuff in it, but that's probably the same sort of hack that Monad is.
10:54:35 <whiteline> does this look like a sensible way to write unit tests http://lpaste.net/135137
10:54:47 <whiteline> i mean, it works
10:58:14 <int-e> quchen: afaiu djinn supports ADTs but not recursive ones.
10:58:35 <quchen> int-e: How can we define new ADTs for it to use?
10:59:15 <quchen> ?djinn Maybe (Maybe a)
10:59:15 <lambdabot> f = Nothing
10:59:58 <Cale> @djinn a -> Maybe (Maybe a)
10:59:58 <lambdabot> f a = Just (Just a)
11:00:05 <int-e> @help djinn-add
11:00:06 <lambdabot> djinn-add <expr>.
11:00:06 <lambdabot> Define a new function type or type synonym
11:00:12 <quchen> Ah!
11:00:20 <Cale> @list djinn
11:00:20 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
11:00:35 <quchen> ?djinn-names
11:00:35 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool NotNot Not Not
11:00:39 <quchen> That one looks useful.
11:00:39 <int-e> @djinn-add class Functor f where fmap :: (a -> b) -> f a -> f b
11:01:14 <int-e> @djinn Functor f => f a -> f (a,a)
11:01:14 <lambdabot> -- f cannot be realized.
11:01:28 <int-e> @djinn Functor f => a -> (a,a)
11:01:28 <lambdabot> f a = (a, a)
11:02:00 <int-e> @djinn Functor f => (a -> b) -> f a -> f b
11:02:01 <lambdabot> f = fmap
11:02:21 <int-e> ok, so type class support is incomplete.
11:02:53 <int-e> (actually I'm surprised that type classes are in there at all so I won't complain)
11:03:05 <cj3kim> Hi, I need some help refactoring this code. I know there's a better way, but I don't have the vocab yet. I'm following this practice assignment: http://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf.
11:03:19 <cj3kim> Gist: https://gist.github.com/cj3kim/c0db32ba27face6fe2a7
11:06:17 <whiteline> use pattern matching
11:06:47 <whiteline> but use -Wall so you don't forget to add defaults
11:08:08 <tedkornish> Since you're not reusing firstChar, you can inline it
11:08:16 <joneshf-laptop> cj3kim, This isn't really a refactoring comment, but what about the failure case: `Unknown`?
11:08:20 <tedkornish> So you can say `case head wordAry of`
11:08:52 <cj3kim> ah, good point
11:09:06 <Welkin> cj3kim: use `words` on the input, the pattern match on the three cases
11:09:14 <Welkin> call `unwords` on the message
11:09:55 <joneshf-laptop> cj3kim, also https://gist.github.com/joneshf/77ab2f0598185a284993
11:11:03 <cj3kim> is it bad practice to call !! on the wordAry multiple times?
11:11:10 <Welkin> you should not use !!
11:11:16 <Welkin> use pattern matching
11:11:19 <whiteline> yeah
11:11:40 <whiteline> (thing : thing2 : _ )
11:11:42 <cj3kim> okay, I will look more into pattern matching
11:11:52 <reindeernix> why shouldn't you use !!?
11:12:26 <joneshf-laptop> partial
11:12:29 <cj3kim> and then come back when I'm done
11:12:43 <whiteline> well, it's ugly. also, you're traversing a structure twice.
11:12:57 <joneshf-laptop> > [1,2,3] !! 10
11:12:59 <lambdabot>  *Exception: Prelude.!!: index too large
11:13:14 <whiteline> no idea if the compiler optimizes that away though
11:13:30 <whiteline> yeah, and patterns can catch size issues w/otherwise
11:14:00 <Welkin> parseMessage i = case words i of ('E' : code : line : msg) -> LogMessage (Error code) line (words msg)
11:14:07 <Welkin> er
11:14:13 <Welkin> unwords msg
11:14:32 <Welkin> you still need to check if the error code and line numbers are actually numbers though
11:14:37 <vkosdll> I'm wondering if there has been any mathematical development of thinking about modules - as in blocks of code?
11:15:06 <whiteline> vkosdll: groupings of definitions?
11:15:15 <vkosdll> Yes whiteline 
11:15:29 <vkosdll> Is there any language with modules as first class member for example?
11:15:41 <whiteline> i think so
11:16:09 <whiteline> or, a person said that such was the case to me once i think
11:16:11 <hodapp> I feel as though Ocaml does something like this.
11:16:20 <whiteline> ^ that was the language
11:16:29 <quchen> In SML modules are pretty high-class at least.
11:16:30 <whiteline> that he mentioned
11:16:49 <vkosdll> okay ML - ill take a look at that
11:17:39 <hodapp> I just keep running into annoying cases in Haskell where I have literally everything in a module parametrized over 1 or 2 of the same things
11:18:13 <vkosdll> Actually I found an interesting article just now if anyone is interested:http://research.microsoft.com/pubs/67016/first_class_modules.pdf
11:18:41 <hexagoxel> Gurkenglas: djinn's unification is broken as soon as the argument type is more complex than a single variable
11:19:06 <hodapp> so what I've ended up doing is either to make a record that has most of the module's useful exports, and make a smart constructor that is a giant function to make an value of that record... or just to have nearly every single function in the module parametrized over those same 1 or 2 types
11:19:11 <hexagoxel> does not really matter if it is a type class or not, or if it is the parameter or the constructor
11:19:12 <hodapp> I'm not really sure of a good way to avoid this
11:19:18 <hexagoxel> @djinn Functor g => (a -> b) -> g a -> g b
11:19:19 <lambdabot> f = fmap
11:19:22 <elfeck> hello, does anyone know how to work with wai-middleware static policy?
11:19:24 <hexagoxel> oh, that works?
11:19:27 <elfeck> I have a problem
11:19:49 * hackagebot nsis 0.3 - DSL for producing Windows Installer using NSIS.  http://hackage.haskell.org/package/nsis-0.3 (NeilMitchell)
11:20:01 <hodapp> vkosdll: thanks, I'll give this a read
11:20:24 <Gurkenglas> hexagoxel, in a query it seemed to handle @djinn Bool -> Bool -> a-> a -> a -> a -> a fine
11:24:49 * hackagebot stackage-curator 0.9.0 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.9.0 (MichaelSnoyman)
11:24:51 * hackagebot neet 0.2.0.1 - A NEAT library for Haskell  http://hackage.haskell.org/package/neet-0.2.0.1 (hijiri)
11:25:11 <hexagoxel> Gurkenglas: yeah, the single parameters are all known types or single variables
11:25:28 <hexagoxel> i have added a classless bind to the env, and
11:25:40 <hexagoxel> @djinn m a -> (a -> m b) -> m b
11:25:40 <lambdabot> f = bind
11:25:48 <hexagoxel> @djinn n a -> (a -> n b) -> n b
11:25:48 <lambdabot> -- f cannot be realized.
11:25:51 <sinelaw> my program is eating CPU
11:26:01 <sinelaw> profiling -p seems to skew the reuslts
11:26:55 <whiteline> sinelaw: insert a system-appropriate sleep function in strategic places?
11:27:17 <sinelaw> sleep?
11:27:20 <whiteline> if you want to yield you have to do that
11:27:40 <whiteline> if the problem is that it's eating too much CPU in relation to the environment
11:28:19 <sinelaw> i want to find out where the cpu usage is spent
11:28:28 <sinelaw> reliably without skewing
11:28:33 <whiteline> ah
11:29:47 <whiteline> lower the sampling interval?
11:30:28 <lequtix> ih
11:30:31 <lequtix> hi
11:41:20 <storsjt> I'm going to take a risk in asking this:
11:41:40 <storsjt> Is there a simple way of explaining what a monad is?
11:42:05 <monochrom> is "simple" objective or subjective? if objective, what is the objective definition?
11:42:06 <quintus> storsjt: railroad tracks
11:42:35 <whiteline> polymorphic functions over a set of containers
11:42:36 <monochrom> if subjective, what is the mental profile of the audience?
11:42:45 <quchen> whiteline: No, that's not what a monad is.
11:42:57 <whiteline> that you use to compose functions
11:43:04 <kadoban> storsjt: It's something that has 'return' and '(>>=)', then you show some examples of how they work.
11:43:15 <whiteline> quchen: that is exactly what they are, in essence
11:43:22 <storsjt> So say I'm a beginner developer, learning control flow for the first time
11:43:33 <quintus> storsjt: This is in F-sharp but helped me a lot: http://fsharpforfunandprofit.com/posts/recipe-part2/
11:43:37 <whiteline> you vary how the composition functions work, so you vary how the operations are composed
11:44:01 <storsjt> quintus: Thanks I'll have a look at that
11:44:13 <shaleh> storsjt: http://blog.jorgenschaefer.de/2013/01/monads-for-normal-programmers.html
11:44:17 <quchen> whiteline: That's not what monads are, and in particular not what they are "in essence", whatever that means. data Proxy a = Proxy is certainly not a container of anything, for example.
11:44:26 <arkeet> sure it is
11:44:36 <arkeet> it's a container that can contain 0 'a's
11:44:36 * bitemyapp popcorn.gif
11:44:37 <whiteline> yeah, it can be thought of as a container
11:44:48 <whiteline> for the mental model, see
11:44:55 <monochrom> I was not a beginner when I learned monad. perhaps that's my solution.
11:45:04 <bitemyapp> arkeet: you're accustomed to phantoms, most people learning Haskell are not.
11:45:22 <storsjt> monocrom: that's the general idea I get
11:45:31 <arkeet> it's isomorphic to Reader Void
11:45:34 <quchen> ?quote kmc synonym
11:45:35 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
11:45:56 <whiteline> yeah
11:46:00 <arkeet> but lots of monads have nothing to do with containers.
11:46:02 <arkeet> like IO. or Cont.
11:46:30 <monochrom> Piaget's theory implies that you need experience in a lot of concrete examples before you're ready for the next level of abstract idea.
11:46:34 <storsjt> Maybe it might be worth rephrasing my question
11:46:35 <whiteline> arkeet: i think of types as containers
11:46:38 <bitemyapp> monochrom: tend to agree.
11:46:42 <arkeet> a monad, in haskell, is an instance of the Monad typeclass.
11:46:42 <storsjt> Is there a simple, all inclusive way of explaining what a monad is?
11:46:45 <arkeet> that satisfies the laws.
11:46:47 <monochrom> this also explains why, actually, beginners don't get OOP either.
11:46:48 <arkeet> that's it.
11:47:06 <maerwald> storsjt: no.
11:47:12 <kadoban> storsjt: Are you asking for a metaphor? Then no.
11:47:19 <suppi> storsjt, how is your algebra?
11:47:30 <storsjt> I'm loving these answers
11:47:33 <whiteline> you give something a label, then pass it around using this polymorphic post sorting machine
11:47:36 <bitemyapp> I'm laughing too
11:47:40 <bitemyapp> storsjt: but the answer is still no
11:48:03 <bitemyapp> storsjt: best way to learn Monad is to write lots of datatypes that are Monads and their functor/applicative/monad instances.
11:48:03 <storsjt> I'll look into it a little more
11:48:10 <maerwald> storsjt: some people explain it in terms of a "box", see http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html but that analogy doesn't work for a lot of Monad instances
11:48:17 <bitemyapp> maerwald: bluh.
11:48:19 <quchen> Any explanation of monads is at most two of simple, correct, or useful.
11:48:23 <storsjt> bitemyapp: similar to how people get to grips with OOP, they make classes
11:48:24 <bitemyapp> storsjt: "looking into" Monad won't do anything, you have to just write code.
11:48:40 <maerwald> bitemyapp: I cannot follow what "bluh" means
11:48:41 <whiteline> yeah, it's almost impossible to explain for some reason
11:48:42 <suppi> I just think of monads as an abstract algebraic structure with some functions on it
11:48:47 <bitemyapp> maerwald: I don't like that post.
11:48:48 <koala_man> the classic article on the "monad tutorial fallacy" says that it's the process of coming up with a simple explanation for themselves that people learn from, and that the simple explanation by itself is not helpful
11:49:01 <athan> Hey guys, is there an overloaded Set library? Which overloads `union`, `intersection`, `difference`, etc? Or is that just a lattice?
11:49:01 <srhb> It's not impossible at all, the real answer is just really boring and for most people not very enlightening.
11:49:05 <whiteline> now that i understand monads i think i can explain them but evidently i can't
11:49:05 <bitemyapp> whiteline: no more or less than any other algebra. Fear and desire for comforting analogies occludes.
11:49:18 <athan> (also is there a lattice class?)
11:49:23 <maerwald> bitemyapp: that's why I said that analogy doesn't work for a lot of things
11:49:30 <storsjt> Is there an algebraic explanation anywhere I can read?
11:49:32 <bitemyapp> whiteline: most mathematicians are comfortable with the fact that they will either need sufficient background to understand something in terms of other abstract objects they're already comfortable with or that they have some crank-turning to do.
11:49:43 <storsjt> (just for the sake of argument)
11:49:44 <suppi> if I find a structure that fits the deal and satisfy the rules then it's a monad.
11:49:55 <bitemyapp> whiteline: for some reason programmers expect to be able to be told what something is without knowing any related concepts or without bothering to do any crank-turning.
11:49:55 <dmj`> whiteline: the second you understand monads is the second you cease to be able to explain them
11:50:02 <bitemyapp> dmj`: nah, I can explain them.
11:50:10 <whiteline> bitemyapp: well, i suppose that i'm simply unused to that, being a coder
11:50:11 <bitemyapp> it's just a waste of time.
11:50:17 <dmj`> bitemyapp: :) 
11:50:24 <bitemyapp> seriously, it's a waste of time.
11:50:35 <bitemyapp> you're better off doing exercises than kicking the can in IRC on something that small.
11:50:42 <srhb> whiteline: There's some truth to that. Most "coders" are not used to such rigorously defined concepts.
11:51:00 <bitemyapp> srhb: or abstract things that are broad enough that they are themselves very small "things"
11:51:01 <srhb> Or such abstract ones, I suppose. At least not both at the same time. :-)
11:51:10 <tzaeru> I'd like to imagine that most, um, "coders", prefer simplicity over complexity and prefer easy comprehension over mathematical abstraction :P
11:51:22 <bitemyapp> srhb: Monads generally do not demand a particular application, so trying to explain in terms of concretions is necessarily lossy.
11:51:29 <srhb> tzaeru: Until you realize how much you grain from rigour. :)
11:51:33 <quchen> storsjt: Awodey, the very last chapter. It will probably be completely useless for learning basic Haskell though, and many people have wasted a lot of time with thinking they need to know math before using IO or whatever in Haskell. Do what others mentioned above: use monad instances such as Maybe and don't worry about what makes it a monad. After some time you'll see a pattern connecting those instances, and that's what monads ar
11:51:33 <quchen> e in practice.
11:51:41 <bitemyapp> srhb: it's better to just let them accumulate familiarity with concrete instances, build intuition, then build towards the abstract from that.
11:51:43 <monochrom> people love analogies. I dislike analogies, but ironically I'm really good at creating analogies. but people love and demand analogies. so here is one.
11:51:43 <srhb> afk, nosebleed
11:51:45 <hodapp> tzaeru: 'simplicity' and 'comprehension' are two pretty huge weasel-words there.
11:51:49 <monochrom> it is like learning Chess.
11:51:54 <tzaeru> hodapp, yea.
11:51:57 <tzaeru> I agree.
11:52:07 <hodapp> tzaeru: Something doesn't become simple because you can find a hundred guides on the Internet that can make it complex, easily.
11:52:11 <bitemyapp> monochrom: chess is rules, structure. Monad is rules, structure.
11:52:23 <monochrom> you don't learn Chess by reading essays, writing essays, and "conversation on IRC"
11:52:28 <bitemyapp> monochrom: I was thinking about this precise thing last night while I was writing about Functor.
11:52:29 <storsjt> quchen: I like that idea
11:52:42 <monochrom> you learn Chess by playing Chess and accepting its rule for what it is.
11:52:49 <suppi> storsjt, I agree with quchen
11:52:52 <monochrom> you don't learn Chess by looking for analogies
11:52:55 <tzaeru> still, it's a bit.. difficult for me to understand how a satisfying state of affairs can include "better not try to explain, easier to just try and get used to it"
11:53:04 <bitemyapp> monochrom: may I cite you in the book?
11:53:07 <bitemyapp> monochrom: if so, by what name?
11:53:11 <tzaeru> though obviously my own professional and practical background colors my glasses ^^
11:53:13 <maerwald> monochrom: you can't play chess without knowing at least the basic rules
11:53:21 <monochrom> yes, please cite me. Albert Y. C. Lai
11:53:27 <bitemyapp> maerwald: the problem is that programmers expect to know what the rules *mean*
11:53:33 <storsjt> maerwald: I've been ering on this argument too
11:53:33 <bitemyapp> maerwald: because they're not used to abstraction.
11:53:36 <quchen> monochrom: People love analogies :-D
11:53:41 <bitemyapp> maerwald: they're used to concrete things that pretend to be abstractions.
11:53:49 <storsjt> maerwald: Can I truely rely on an abstraction that I don't understand?
11:54:03 <maerwald> bitemyapp: I think that comes from OOP which made people belive that indirection is the same as abstraction
11:54:17 <bitemyapp> storsjt: you can rely on addition being commutative without having deep intuitions for the implications thereof.
11:54:27 <monochrom> I would change *mean* to "mean"
11:54:30 <suppi> I think the only problem I had with monads is when people kept suggesting it is a hard to grasp concept
11:54:36 <dmj`> storsjt: does your understanding dictate its validity?
11:54:47 <bitemyapp> suppi: makes it seem like there should be "more" to it than there actually is.
11:54:55 <suppi> bitemyapp, yup
11:54:55 <monochrom> programmers think that they know what some rules or some constructs "mean". and they are often wrong.
11:54:56 <srhb> tzaeru: It's more like learning a lot of monoidal things like addition, multiplication, ... is simpler at first than learning monoids without a concrete knowledge of at least one or more monoids
11:54:59 <bitemyapp> suppi: then you're confused because you feel like you must be missing something.
11:55:08 <suppi> bitemyapp, exactly
11:55:19 <maerwald> storsjt: there are two levels with monads: 1. using them (easy, just read the doc and play with them) and 2. writing them yourself and knowing why you do that and what this enables your users to do (and the limitations)
11:55:26 <maerwald> just start with the first level, not the second
11:55:39 <maerwald> with "doc" I mean "the doc of the instance"
11:55:39 <tzaeru> srhb, yea. to be honest I don't grasp haskell really at all. still struggling to find a few days to properly run exercises and so :x
11:55:44 <storsjt> I feel like there are probably some people in this chat like "why did this guy stir this up again?" :P
11:55:46 <quchen> I didn't find monads hard when I learned about them, I just didn't get why they would be a useful abstraction. So that version of learning about them exists as well.
11:55:49 <dolio> storsjt: Do you understand how x86 is translated by microcode on every processor you use?
11:55:53 <storsjt> I'd imagine it's a regularly asked question
11:55:53 <suppi> perhaps because I learned Haskell when the abstract algebra course I took was still fresh in my mind
11:55:58 <srhb> tzaeru: Ok. :) Well I bet you will see exactly what I mean by this once you get the time. :)
11:56:54 <quchen> storsjt: Not that regularly, but it's not rare either. :-)
11:56:55 <suppi> quchen, yeah. it wasn't until I started using frameworks like Snap that I realized that Haskell can be pretty easy to learn because it is all the same concept in disguise :)
11:57:21 <suppi> to learn -> to use
11:57:43 <storsjt> suppi: what is it about snap that made it easier?
11:57:54 <athan> what algebraic operation would set-wise difference be? Is that a semiring?
11:57:54 <storsjt> suppi: just more structure for you to use and learn with?
11:58:12 <creichert> I like to think of it as practicing. It didn't all come instantly for me.
11:58:15 <maerwald> suppi: I think it's a reasonable trade-off... some haskell concepts are rather difficult to understand, but if I compare that with the huge amount of randomly different design patterns in java and I all have to memorize them...
11:58:17 <suppi> storsjt, you take some kind of framework and library, you learn it's a monad, bam - you already know all the operations to use it
11:58:29 <suppi> maerwald, yup
11:58:44 <dolio> athan: It's not associative.
11:59:27 <monochrom> athan: here is a monoid: carrier is powerset of X, identity is empty set, binary operator is symmetric difference
11:59:28 <suppi> like you know that this thing is a Group, you prove many things about groups, you meant another group, everything you proved serve you there as well
12:00:02 <suppi> meant -> meet
12:00:12 <monochrom> in fact, here is the inspiring monoid: carrier is bool, identity is false, binary operator is xor
12:00:39 <athan> monochrom: Hmm!! Okay!
12:00:54 <athan> dolio: (sorry ._. I should've done my homework)
12:01:01 <tzaeru> monochrom, and then, a haiku out of that
12:01:55 <dmj`> creichert: totally agree, practice, even dons said, "it's a drill"
12:02:43 <Welkin> dmj`: is your nick even registered?
12:02:54 <monochrom> athan: I changed your "difference" to "symmetric difference". now it is associative :)
12:02:59 <Welkin> holy shit, athan too
12:03:00 <Welkin> haha
12:03:12 <Welkin> nickserv says you haven't been online for 10 days
12:03:27 <Welkin> it days dmj` hasn't been on for over a year
12:03:39 <tzaeru> exciting monoid - binary operator is xor - identity is false
12:04:02 <taruti> Is there a cuda neural network library in Haskell? (perhaps using accelerate)
12:04:52 <kuznero> Hi All!
12:05:25 <zmbmartin> What is the best crypto lib for doing aes 256 cbc stuff?
12:06:42 <whiteline> OpenSSL?
12:07:15 <zmbmartin> whiteline: Was that a question for me?
12:07:37 <monochrom> it was, in fact, an answer, in the syntax of a rhetorical question
12:07:55 <whiteline> zmbmartin: yes, well, you should always use the standard implementation for crypto. even if it doesn't have bindings maybe
12:08:22 <monochrom> I thought of openssl too, since I just used it yesterday to encrypt a text file. but I understand that in #haskell you're looking for a haskell implementation
12:09:05 <monochrom> but yesterday people here brought up haskell crypto too
12:09:26 <zmbmartin> So I should openssl?
12:09:45 <maerwald> zmbmartin: use libressl
12:10:15 <whiteline> or gnutls
12:10:27 <maerwald> please no :P
12:10:34 <whiteline> just as long as it's a trusted implementation
12:10:54 <monochrom> no, I saw it in Haskell Weekly News. http://hackage.haskell.org/package/cryptonite
12:10:54 <maerwald> gnutls had broken certificates for 8 years or so, afair
12:10:59 <zmbmartin> Should I just use readProcess then?
12:11:33 <whiteline> maerwald: well, i see lots of things compiled against gnutls on my fedora installation
12:11:43 <bennofs> monochrom: note that cryptonite is mostly implemented in C afaic
12:11:43 <maerwald> I'd be concerned
12:11:46 <whiteline> emacs, for one
12:13:58 <dmj`> Welkin: I'm registered, I just don't identify often I guess
12:14:01 <whiteline> zmbmartin: use the FFI to link to the libraries
12:14:06 <whiteline> it's very nice
12:14:29 <whiteline> i've used it to link to guile and call scheme code from hs code and vice versa
12:14:38 <whiteline> to see if it could be done
12:14:43 <thewardenofnorth> Hi. I'm new to haskell. I just finished a networking chapter from real world haskell (http://book.realworldhaskell.org/read/extended-example-web-client-programming.html), but I have a feeling that there are new and better libraries in 2015 do write networking client code. does anyone have any suggestions?
12:14:44 <monochrom> eh? a lot of crypto libraries are from the same Vincent Hanquez
12:15:04 <Welkin> monochrom: a conspiracy
12:15:24 <dmj`> thewardenofnorth: for networking? doubt it, the network package is defacto AFAIK
12:15:27 <zmbmartin> Thanks guys!
12:15:51 <thewardenofnorth> I found this http://www.yesodweb.com/book/http-conduit
12:16:07 <thewardenofnorth> as I said, I am a complete noob in haskell world
12:16:26 <dmj`> thewardenofnorth: what are you trying to do
12:17:30 <dmj`> thewardenofnorth: at some point all http clients depend on the network lib. With http-conduit it does so via http-client
12:18:18 <c_wraith> someone did recently release an alternate low-level bindings network library, but it's still very early in its lifespan.
12:18:23 <c_wraith> I think it was called socket
12:18:36 <c_wraith> @hackage socket
12:18:36 <lambdabot> http://hackage.haskell.org/package/socket
12:19:25 <maerwald> sometimes I think we need a list of monad analogies, just to show that there is no common one, but that monad is a meta-concept that can be used to model other concepts (e.g. a computation that can fail or have a result)
12:20:07 <c_wraith> Eh.  I think people need to worry less about monads.  Getting worried about whether you "understand monads" or not seems like it's missing the point.
12:20:08 <whiteline> zmbmartin: also, another thing you absolutely need to remember is that you use proper system random source
12:20:33 <maerwald> c_wraith: I don't think it's about worrying
12:20:54 <c_wraith> It's like worrying about "understanding Iterators" in java.  Sure, it's a common pattern.  Sure the language has syntactic sugar for working with them.  But it's such a tiny part of actually using the language, it's not a good place to try to learn anything.
12:21:28 <thewardenofnorth> I'm not trying to do something in particular. I'm an android developer who wants to get some grasp in haskell world.
12:21:43 <whiteline> there are other abstractions, like arrows
12:21:44 <maerwald> c_wraith: I cannot follow, you seem to think that I think something in particular
12:22:09 <c_wraith> maerwald: I just think there should be no analogies.  Monad is a composition pattern.  That's it.
12:22:49 <whiteline> c_wraith: yes, but "composition pattern" says nothing if you don't explain the plumbing and the model
12:22:55 <maerwald> I think you missed my point, but anyway
12:23:11 <c_wraith> whiteline: Fortunately, it's independent of plumbing and model. :)
12:23:32 <dmj`> maerwald: a "categorical theory of computation based on monads" was introduced by Moggi he even shows how non-determinism, exceptions, continuations, state can be modeled. 
12:23:34 <monochrom> I'm pretty sure "is a" does not mean "equal"
12:23:35 <c_wraith> whiteline: all you need is a pair of type signatures and some rules for how those types interact.
12:23:35 <dmj`> http://www.cs.cmu.edu/afs/cs/user/crary/www/819-f09/Moggi91.pdf
12:23:43 <maerwald> I'm not trying to find the best analogy. But giving _different_ ones is exactly what helps understanding the abstraction.
12:23:53 <maerwald> so people realize there is no single one
12:23:58 <whiteline> c_wraith: yes, but it says nothing, still. explaining the plumbing and model will allow a person to understand it in the same way problem sets lets people understand algebra
12:23:59 <dmj`> not sure what year that was
12:24:05 <maerwald> and through that they can think about what is common
12:24:44 <whiteline> *the plumbing and model of the standard haskell typeclass and standard monads
12:24:57 <monochrom> dmj`: that's probably 1991, guessing from the filename :)
12:25:27 <dmj`> monochrom: doh :)
12:25:52 <monochrom> it is 1991. I have saved that paper a long time ago and recorded it's bibtex entry
12:26:11 <deltaxv> For what reason is ghc 900mb on archlinux?
12:26:19 <c_wraith> whiteline: I think the other direction is more effective.  Let people use lots of libraries.  Eventually, you understand what "Monad" is for.  At that point, it's worth looking at the formalisms.  (I figured it out using Parsec.  I went "huh. So it just plain works the way I think it should. Oh! That's what monads are about."
12:26:45 <Hijiri> fumieval: Is 自己副関手　2-functor?
12:26:51 <Hijiri> 2-endofunctor I mean
12:27:07 <maerwald> c_wraith: I don't think that will work. They will just stick to the documentation and only understand instances. That enables them to USE them, but not to CREATE them.
12:27:17 <dmj`> monochrom: makes sense since haskell was around 90, wonder if monads were in by then
12:27:19 <creichert> thewardenofnorth: check out wreq 
12:27:21 <monochrom> deltaxv: for static linking reasons
12:27:27 <Hijiri> oh, profucntor
12:27:27 <c_wraith> maerwald: If you can't use them, you can't create them.
12:27:37 <whiteline> c_wraith: yes, my experience was similar, but it was certainly not possible without the 20 or so analogies/explanations rattling around in my mind as i used them
12:27:38 <dmj`> haskell w/o monads ... 
12:27:46 <maerwald> c_wraith: yes, but I don't see how just using them makes you able to create them either
12:28:01 <c_wraith> dmj`: no, type classes were kind of tacked on later..  They just happened to work well.
12:28:21 <c_wraith> dmj`: read the "being lazy with class" paper.  It's an excellent history of the early years of haskell.
12:28:30 <monochrom> haskell was without monad (and not aware) for a few years. then Phil Wadler brought it to the table.
12:28:39 <c_wraith> dmj`: http://research.microsoft.com/en-us/um/people/simonpj/Papers/history-of-haskell/history.pdf
12:29:25 <monochrom> previously haskell I/O API was similar to continuation passing style, but I forgot the exact detail
12:29:35 <dmj`> c_wraith: thanks, watched the video a long time ago (https://www.youtube.com/watch?v=3bjXGrycMhQ), should probably read the paper too
12:29:42 <c_wraith> dmj`: looks like it was the 1996 revision of the language that first introduced the IO type
12:30:50 <Murad> Hey all, I have a minimal reproducible example of a wxHaskell-related bug when I call auiManagerGetAllPanes. Would anybody be willing to try my snippet and report their results? I can't tell if I have something compiled or configured incompatibly or there is a bug in wxHaskell or wxWidgets. http://lpaste.net/6913249328953819136
12:33:42 <fm2> /?
12:39:52 * hackagebot matrices 0.4.2 - native matrix based on vector  http://hackage.haskell.org/package/matrices-0.4.2 (kaizhang)
12:43:52 <albeit_> Is it possible to check an MVar from C code in an unsafe call?
12:45:18 <Cale> albeit_: There's no C-specific API for doing anything like that.
12:45:37 <albeit_> Cale: Okay
12:45:59 <Cale> It probably makes more sense to check it before you make the call to C.
12:46:58 <albeit_> Any idea for how to solve my problem? I want to non-blocking wait on sockets, and a Haskell queue, lets say Chan. If I do it in Haskell, it just creates a ton of garbage looping so many times so quickly. But I'm not sure how to check the Chan from the C code... any ideas?
12:47:26 <kuznero> Does anybody know a library for structured logging in Haskell?
12:47:31 <albeit_> (I just want the C code to return when anything is available, from the sockets or Chan)
12:48:46 <Cale> albeit_: Maybe we can just reduce the amount of garbage that your Haskell code leaves on the heap?
12:50:06 <lenex> I got a FailedConnectionException2 from http-client, but the port parameter in the exception ("80") is not the port I made the request on (3000) - any suggestions on debugging?
12:50:07 <albeit_> Cale: It's more the garbage from the tryReadXYZ on the queue... for example, if I end up calling tryReadXYZ a million times a second, that's going to be a lot of garbage
12:50:09 <dmj`> albeit_: what does the C code do?
12:50:48 <albeit_> dmj`: Continuously loop checking for data on some sockets, non-blocking. I just need to be able to check on a Haskell queue as the same tiem somehow
12:50:55 <Cale> lenex: I guess start from the source code which produces the exception and figure out how it fills that field?
12:51:42 <dmj`> albeit_: why not a fork thread to block on the read end of socket in a forever block, when bytes are detected it drops them on a chan, where another thread is blocked in the read end of the chan in a forever loop, threads are cheap.
12:52:21 <albeit_> dmj`: But not that cheap... point is to have everything non-blocking
12:52:37 <Cale> Yeah, this continuously looping for no apparent good reason plan is really questionable... isn't the OS supposed to handle notifications like that? Also, in Haskell, the RTS is supposed to do that for you.
12:53:16 <albeit_> The so-called "good reason" is that microseconds matter, and it makes no sense to have a CPU sitting at not 100% usage if it can be utilized
12:54:31 <Cale> I think you'd be better served by not using Haskell directly, if timing at that level matters so much. Instead, perhaps write a Haskell program which schedules assembly code for you?
12:54:43 <Cale> What does your application do?
12:54:50 <geekosaur> looping doimng nothing isn't actually utilization, it's just wasting cycles some other thread/process could be using
12:54:57 <albeit_> Cale: But that defeats the purpose of writing it in Haskell ;)
12:54:58 <dmj`> albeit_: if no bytes are detected you should block though. You can't read what doesn't exist yet. 
12:55:20 <ry325> can I make a generic function a member of a typeclass?
12:55:33 <Cale> albeit_: Not necessarily. Haskell is a really good language in which to write compilers, even special purpose compilers.
12:55:43 <geekosaur> there are some cases where busywaiting makes sense (notably waiting on certain kinds of condition variables/mutexes that are expected to unblock very quickly). I/O is not such a case
12:56:03 <elfeck> can anyone tell me how to use wai-middleware static policy with/such/urls?
12:56:29 <dmj`> ry325: you can put a polymorphic function in a typeclass, not sure what you're asking
12:56:30 <albeit_> dmj`: But then I need to wait for a signal from the OS that data is there, while I could just check manually
12:56:34 <Cale> But yeah, overall, I somehow *strongly* doubt that even if you implement this plan of busy-waiting, you'll be any better off than if you just did things the standard way.
12:56:49 <geekosaur> ry325, you need to provide more information, but the question leaves me wondering if you understand typeclasses
12:56:50 <albeit_> Cale: It's for low-latency trading
12:56:53 <ry325> dmj`: I think that's what I want
12:56:57 <ry325> http://lpaste.net/135146
12:57:14 <ry325> I know it's incorrect but it expresses what I'm attempting to do
12:58:23 <geekosaur> albeit_, do you know about the thundering herd problem?
12:58:27 <Cale> ry325: Can you perhaps show us what you're *actually* trying to do?
12:58:42 <dmj`> albeit_: if you're doing low latency trading you won't be able to compete unless you're using an FPGA and have colocation
12:58:44 <geekosaur> because a busy-wait design had better have only one thread doing that busy-wait or you are thundering-herd-ing yourself
12:58:44 <Cale> ry325: That example is gibberish :P
12:58:57 <geekosaur> and will have even *worse* performance than blocking threads
12:59:03 <albeit_> geekosaur: Yes - but I have a herd of 1
12:59:06 <geekosaur> (note this means *systemwide*)
12:59:43 <geekosaur> because your busywait slows everything else on the machine down. this only makes sense if the hardware is completely dedicated
12:59:49 <sccrstud92> when writing a (co)monad transformer, how is it determined where is the type of the original (co)monad the base (co)monad is placed? For example, State is s -> (a, s). Why is StateT m the same as s -> m (a , s) instead of m (s -> (a, s)) or s -> (m a, s)
12:59:50 <albeit_> dmj`: While I appreciate the input, we *are* colocated and we *are* competing / profitably trading
13:00:37 <albeit_> geekosaur: A core is dedicated to thread running a busy-wait
13:00:38 <ry325> I'm trying to create a typeclass called Form, with type parameters `a` and `b`, where any member of Form defines a function from `a` to `b`
13:00:40 <Cale> sccrstud92: Have you looked at the definition of StateT?
13:00:46 <ry325> and then make (a -> b) a member of Form a b
13:01:02 <Cale> sccrstud92: newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
13:01:09 <sccrstud92> Cale: yes, I put it in my original question. Did I remember it wrong?
13:01:10 <dmj`> albeit_: If you malloc memory at all on the heap you're probably too slow, going across the bus will kill you, is your strategy solely based on speed? 
13:01:26 <sccrstud92> Cale: yeah thats what I put.
13:01:27 <Cale> sccrstud92: It's for no better reason than "that's how the monad transformer is defined"
13:01:38 <Cale> sccrstud92: Maybe I don't understand what you're really asking
13:01:48 <albeit_> dmj`: Not sure this the appropriate place to discuss, suffice to say we are not too slow
13:02:13 <sccrstud92> Cale: is it somehow "the most powerful"? if its more useful than the others, why? if its lets useful, why not pick more useful versions?
13:02:20 <Cale> sccrstud92: If you want, try writing those other potential-monad-transformers. You might run into some issues actually completing a law-abiding instance of Monad though.
13:02:38 <Cale> sccrstud92: I don't think the others actually work.
13:02:59 <Cale> Well, hmm
13:05:17 <sccrstud92> Cale: so its based on lawfulness?
13:05:46 <sccrstud92> ill try to see if m (s -> (a, s)) or s -> (m a, s) works too
13:06:59 <lyxia> sccrstud92: I find it's just natural to add state using s -> m (a, s).
13:07:39 <sccrstud92> lyxis: I agree, for that specific State type
13:07:51 <sccrstud92> it seems intuitive
13:08:02 <sccrstud92> but for the Store comonad instance for example
13:08:38 <sccrstud92> StoreT is (w (s -> a), s)
13:08:47 <lyxia> I'm not too familiar with comonads either yet, but I'm sure it will be obvious soon enough.
13:09:34 <sccrstud92> not w (s -> a, s) or (s -> w a, s)
13:09:53 * hackagebot stylish-haskell 0.5.14.1 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.14.1 (JasperVanDerJeugt)
13:10:06 <ry325> sorry folks; didn't know about #haskell-beginners
13:10:07 <ry325> heading there
13:10:12 <Cale> ry325: hm?
13:10:21 <Cale> ry325: This channel is also beginner-friendly
13:10:31 <Cale> ry325: I actually hate the name of #haskell-beginners
13:10:42 <sccrstud92> ry325: I didn't actually see a questions =P
13:10:45 <ry325> ah ok. I mean everyone has been perfectly friendly here
13:10:49 <monochrom> there cannot be a good name
13:10:59 <Cale> #haskell-beginners is a particular study group -- nobody should get the idea that this channel doesn't welcome beginners
13:11:09 <ry325> I just don't want to fill the thread w/ stupid questions
13:11:16 <ry325> that would seem incoherent to an expert :P
13:11:18 <sccrstud92> if its about haskell
13:11:19 <Cale> ry325: Don't worry about it
13:11:20 <sccrstud92> its not stupid
13:11:21 <monochrom> but we talk with beginners in both places
13:11:44 <kadoban> -beginners tends to be lower traffic, which can be bad and good, but if you're doing fine here nobody will complain.
13:11:47 <sccrstud92> (please don't try to find a counter-example)
13:12:33 <ry325> ok. new here and just wanted to make sure I was observing ettiquette. afaik Haskellers are decent human beings :)
13:12:51 <kadoban> Or at least we pretend to be online ;)
13:13:01 <Cale> ry325: Can you say more about what that Form type class is trying to express, or what sort of pattern you're trying to abstract over?
13:13:21 <Cale> ry325: What is the function a -> b actually supposed to mean?
13:13:44 <edwardk> sccrstud92: "when writing a (co)monad transformer, how is it determined where is the type of the original (co)monad the base (co)monad is placed?" -- laws
13:14:01 <ry325> I'm playing around with the ideas in ImplicitCAD, but trying to make them extensible
13:14:11 <ry325> all the data types in ImplicitCad are closed
13:14:12 <ry325> https://github.com/colah/ImplicitCAD
13:14:14 <edwardk> sccrstud92: given an adjunction F -| G -- then you can build a monad GF and a comonad GF -- this gives you state and store
13:14:33 <edwardk> given two adjunctions you can compose them, to get a bigger adjunction. this still works
13:14:53 * hackagebot esqueleto 2.2.6 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2.6 (FelipeLessa)
13:15:08 <edwardk> but in general given F -| G      then GMF is a monad if M is a monad,   and FWG is a comonad if W is a comonad. this is where the store comonad transformer comes from
13:15:16 <edwardk> the same adjunction that gives us the state monad transformer
13:15:19 <Cale> ry325: For example, the Ord type class expresses types which have a total ordering defined on them, and has methods such as compare, which given two elements of the type, determines whether the first is less than, equal to, or greater than the second.
13:15:26 <ry325> using Linear package; if you consider `a` to be `V3 Double` and `b` to be `Double`
13:15:39 <ry325> right
13:15:55 <ry325> the Form type class indicates a mapping from one type to another, like what a function provides
13:16:43 <Cale> So, Form a b means nothing more than there exists some function from a to b?
13:16:45 <edwardk> on the other hand we have a monad transformer that come from a simple distributive laws: ReaderT e m a = e -> m a  -- comes from the fact that I can always take m (e -> a)   and get e -> m a -- we can always commute (->) e   and m in that one direction
13:16:57 <LordBrain> sounds like Arrow
13:17:00 <LordBrain> sort of
13:17:03 <ry325> Correct, but I may want to add extra info to that
13:17:04 <Cale> LordBrain: well, not really...
13:17:12 <Cale> ry325: hm?
13:17:20 <edwardk> and WriterT e m a = m (e, a)  comes from the fact that 'every functor in haskell is strong' so we can always shove an (,) e   through m.   (e, m a) -> m (e, a) 
13:17:21 <sccrstud92> edwardk: does Reader arise from the composition of adjoints as well?
13:17:27 <ry325> say I wanted `data NamedForm = NamedForm (Double -> Double) String`
13:17:49 <Cale> ry325: Maybe it would be best to just write some code without the type class, in order to be able to see exactly what it is that you want to abstract over.
13:18:01 <edwardk> sccrstud92: every monad can be derived comes from a composition of adjoint functors. that composition may be 'boring' though, it may just go to the eilenberg-moore category / kleisli category
13:18:18 <edwardk> sccrstud92: they don't arise from adjunctions from Hask -> Hask
13:18:22 <Cale> ry325: So, what instance would that have?
13:18:39 <edwardk> sccrstud92: every monad gives rise at (at least one) adjunction, every adjunction gives rise to a monad
13:18:43 <ry325> getValue (NamedForm f _) = f
13:18:48 <Cale> ry325: I suppose you could implement  instance Form NamedForm String
13:18:57 <sccrstud92> edwardk: so Store and State are special because the adjoints are from Hask -> Hask?
13:19:24 <edwardk> sccrstud92: well, lets consider another weird adjunction
13:19:29 <Cale> ry325: That's not going to typecheck...
13:19:51 <Cale> ry325: Maybe you want something like:
13:19:56 <sccrstud92> edwardk: im game
13:20:12 <edwardk> we can make an adjunction that goes out to Hask^op.   we can look at (-> r) a <- b    in hask op being isomorphic to a -> (b -> r).    the other is b -> a -> r, the latter is (a -> b -> r) 
13:20:23 <Cale> class Apply f a b | f -> a b where apply :: f -> (a -> b)
13:20:31 <edwardk> so (_ -> r) -| (_  -> r)
13:20:41 <edwardk> when we compose thos one way we get a monad in Hask.
13:20:49 <edwardk> when we compose this the other way we get a comonad in Hask^op
13:20:54 <edwardk> which ... is a monad in Hask
13:20:57 <edwardk> the same monad
13:21:20 <edwardk> so we can play this game, we can put a monad in the middle and get a monad.. but its a monad in hask^op we put in the middle.
13:21:39 <sccrstud92> so a Hask comonad
13:21:46 <edwardk> so given a comonad w,  Whatever r w a = w (a -> r) -> r   is a monad
13:21:51 <edwardk> yep
13:22:08 <edwardk> so the state of affairs with State and Store isn't _that_ special
13:22:08 <Cale> ry325: I'm not sure that class will be very useful though. Even with the functional dependency, it will likely result in annoying problems with type inference that will require explicit annotations to deal with.
13:22:30 <ry325> ah I see
13:22:33 <Cale> ry325: Where is this coming up?
13:22:42 <sccrstud92> edwardk: why is it the go to case when discussing the adjunction properties of (co)monads?
13:22:44 <ry325> I was trying to do it with type families instead, but I think that's over my head at this point
13:22:57 <sccrstud92> or is it not actually
13:23:06 <edwardk> that said, State and Store are rather unique in that there well, just isn't any other adjunction from Hask to Hask than something isomorphic to (->) e -| (->) e
13:23:07 <Cale> Well, type families wouldn't be much better.
13:23:21 <Cale> You can do it, but I'm not sure it's usually a good idea.
13:23:30 <edwardk> sccrstud92: people use it as the adjunction example because they want to talk about an adjunction from Hask -> Hask .. and that is the only one there
13:23:37 <ry325> I'm not using any of the code from ImplicitCad, just the general concept
13:23:44 <edwardk> everything else that is an adjunction from Hask to Hask is isomorphic to that case
13:23:57 <sccrstud92> weird
13:24:01 <edwardk> so once you've simplified your notion of Functor as being from Hask to Hask its the onlye example you have left
13:24:04 <Cale> ry325: Do you really have much code which would benefit from abstracting over a class of this sort?
13:24:08 <ry325> I'm just trying to make the data type as abstract as I can so if I want to go to some super-precise number format later, I won't have to modify it
13:24:17 <edwardk> identity -| Identity is just (,) () -| (->) () in disguise
13:24:23 <ry325> ahh so I should just write the unabstracted version first then
13:24:45 <Cale> ry325: Probably. It's hard to get abstractions right if you don't have any concrete examples to go by.
13:24:58 <edwardk> if you let your adjunctions go to other categories you need a vocabulary capable of talking about functors to/from those other categories
13:25:09 <Cale> ry325: It's probably not a great idea to introduce a class until you have at least 3 instances right off the bat.
13:25:45 <sccrstud92> edwardk: didnt you write a package for that?
13:25:57 <edwardk> sccrstud92: i have a couple of variations on the theme floating around
13:26:10 <ry325> makes sense. so I don't have so much a Haskell problem as I do a premature optimization problem ;)
13:26:23 <Cale> ry325: Well, or the opposite :)
13:26:29 <edwardk> it all depends on how much you want to conflate naturality and parametricity
13:26:50 <sccrstud92> edwardk: parametricity implies naturality, correct?
13:26:56 <Cale> ry325: Type classes don't have *that* much runtime weight, but they do come with a cost, and generally get in the way of the compiler's optimisations.
13:27:11 <edwardk> sccrstud92: ehh. without GADTs, sure
13:27:19 <edwardk> with them? not sure
13:28:02 <sccrstud92> meaning you dont know? or it doesnt?
13:28:11 <Cale> ry325: For instance, without the type class generalisation, maybe the compiler could inline the specific code you used sooner, and simplify things, while if it doesn't know what instances you eventually pick while compiling a module, it might not be able to produce such specialised code.
13:28:14 <edwardk> http://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf <- talks a bit about the relationship between them
13:28:43 <sccrstud92> (I could keep asking questions for an hour or more so please let me know if you get tired of talking about ctegory theory)
13:28:56 <edwardk> i believe they are incomparable rather than parametricity being a refinement of naturality in the presence of GADTs but when i last went to write a quick proof of it i got confused, so i'm walking the comment back to 'i dunno' =)
13:29:10 <sccrstud92> haha
13:29:53 * hackagebot ide-backend 0.9.0.10 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.10 (MichaelSnoyman)
13:29:55 * hackagebot ide-backend-common 0.9.1.3 - Shared library used be ide-backend and ide-backend-server  http://hackage.haskell.org/package/ide-backend-common-0.9.1.3 (MichaelSnoyman)
13:30:06 <edwardk> dolio could probably give you a real answer
13:31:14 <ry325> Cale: makes sense
13:32:23 <ry325> I'll hammer at this a bit more and see where that gets me
13:33:07 <ry325> I've been trying to keep in mind this sort of thing: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
13:33:54 <nolrai66> It seems weird to me that no one seems to have applied catagory theory to applied comptuer science the way it is to math.
13:34:27 <sccrstud92> nolrai66: what do oyu mean?
13:34:30 <sccrstud92> you*
13:35:18 <nolrai66> Like not as an extention of type theory, but like figureing out what catagories O(n) notation is a functor to from.
13:35:22 <nolrai66> *to/from
13:35:57 <mniip> O notation doesn't seem like a functor
13:36:04 <nolrai66> No?
13:36:05 <stianhj> So now that Stack is out of beta. Uninstall system ghc/cabal-install? And stack has no relation to stackage?
13:36:32 <nolrai66> Well its multiple functors depending on what composition is.
13:36:36 <Cale> nolrai66: "category"
13:36:38 <reindeernix> damn tail recursion is powerful, I can go through 10 times as many iterations in my program when I use it
13:36:41 <stianhj> System being packages in Arch
13:36:43 <mniip> a preorder maybe
13:37:05 <ion> @remember xplat when guys see me and know who i am, they grab their wallet with one hand, their gun with another, and cover their balls with the other.  then they say 'OH MY GOD I HAVE THREE HANDS WHAT'S GOING ON'.  then we talk about Stone duality.
13:37:05 <lambdabot> Done.
13:37:15 <ion> #haskell-lens
13:38:04 <Cale> reindeernix: Tail recursion in Haskell isn't anything particularly special, given that there's no call stack. However, it might be the case that you wrote something more efficiently that way anyway :)
13:38:07 <nolrai66> Hmm, actually O(n) might be a bad example.
13:38:27 <nolrai66> Just take raw time/space usage though.
13:38:37 <reindeernix> Cale, I didn
13:38:46 <reindeernix> Goddammit keyboard
13:39:05 <reindeernix> Cale, I didn't think about there being different types of recursion before today
13:39:53 <mniip> nolrai66, what?
13:40:22 <Cale> stianhj: I don't think you have to (or even should) uninstall ghc/cabal-install given that stack exists. Stack does have a relation to stackage, and is configured to use it by default.
13:41:48 <nolrai66> So thats pretty clearly a functor fromm the Category of ALgorithems. (which doesn't exist..but thats another story.) to the natural numbers as an addition monoid, or as an maximum monoid.
13:42:08 <Cale> nolrai66: Which category of algorithms?
13:42:09 <stianhj> Cale: Thanks. I guess I'll just give it a whirl.
13:42:25 <sccrstud92> stianhj: stack can apparently use the ghc u have installed already
13:42:39 <sccrstud92> it does not use the cabal binary executable though
13:43:01 <Cale> nolrai66: It's not meaningful or useful to make statements like that without actually saying what the categories are. :)
13:43:29 <sccrstud92> Cale: its from 1 -> 1 =P
13:43:58 <nolrai66> Cale: Under normal composition. And yes thats sort of what my paratentical note was about.
13:44:14 <stianhj> sccrstud92: Ok, so if some project needs ghc 7.8, it'll keep everything separately from system stuff?
13:44:17 <nolrai66> Hask as usually thought about would work, for example.
13:44:37 <dolio> Is category theory as applied to mathematics very vague?
13:44:42 <nolrai66> (I think.)
13:44:55 <Cale> dolio: hm?
13:45:01 <sccrstud92> stianhj: the thing i read said it will take care of sandboxing for you, and there is not chance of it breaking other projects
13:45:08 <Cale> dolio: Not usually
13:45:09 <dolio> Cale: Because this discussion is vague.
13:45:16 <Cale> dolio: Yeah, it is :)
13:45:17 <sccrstud92> but you should read the release info
13:45:19 <sccrstud92> faq
13:45:21 <sccrstud92> stuff like that
13:45:31 <nolrai66> No, but I am not doing this. I am describing what the thing that I am suprised doesn't exist would look like.
13:45:32 <sccrstud92> to make sure
13:45:40 <nolrai66> If that makes anysense?
13:46:22 <sccrstud92> nolrai66: it only makes sense if it could actually be applied
13:46:25 <nolrai66> Hmm. It doesn't seem that vague from here. Maybe I am just really screwing up on explaing what I mean.
13:47:04 <sccrstud92> nolrai66: like, perhaps what you are surprised hasnt been done, hasnt been done because it either cannot be done or is meaningless
13:47:13 <sccrstud92> and if that is the case
13:47:16 <sccrstud92> then it shouldnt be surprising
13:47:27 <nolrai66> Yes. But thats not true.
13:47:30 <elbiot> I think my client bugged out.  Did the code I posted make it out?  
13:47:33 <Cale> Or maybe it has been done, and you just didn't know
13:47:34 <sccrstud92> so you assert
13:47:47 <Cale> Depending on what we're talking about, all of these might be true
13:47:48 <sccrstud92> ^
13:47:50 <nolrai66> But its also fairly obvious so I am confused by your responces.
13:48:11 <nolrai66> Well yes I have not read every paper ever writen.
13:48:18 <sccrstud92> nolrai66: we are confused by you as well
13:48:34 <sccrstud92> well, me at least
13:48:35 <nolrai66> I also feel fairly attacked...
13:48:46 <nolrai66> Which is odd.
13:48:48 <sccrstud92> now i feel attacked
13:48:53 <sccrstud92> that you feel attacked
13:48:54 <sccrstud92> =P
13:48:58 <nolrai66> SOrry.
13:49:44 <monochrom> elbiot: from my end, your client disconnected more than an hour ago, and only recently back. I don't think anything got through
13:49:54 * hackagebot maybe-justify 0.1.0.0 - Simple higher order function for Maybe  http://hackage.haskell.org/package/maybe-justify-0.1.0.0 (taksuyu)
13:50:14 <nolrai66> Like this class here: http://math.mit.edu/~dspivak/teaching/sp13/
13:51:05 <nolrai66> Looks at like 'deep' ideas in computer science, but not really at applied computer science as a mathmatical feild.
13:51:31 <mightybyte> Hello all.  The NY Haskell Meetup is planning to live stream tonight's talk.  I'm curious if people think this is something worthwhile.  For more information see http://www.reddit.com/r/haskell/comments/3aztl6/ny_haskell_meetup_live_streaming_tonight/
13:52:09 <monochrom> "category theory for scientists" sounds like optimized for quantum physicists, e.g., John Baez stuff, as opposed to CS stuff or even math.
13:52:11 <Cale> mightybyte: do it
13:52:31 <nolrai66> Yes.
13:52:32 <Cale> mightybyte: Make sure to post in here when you go live :)
13:52:38 <mightybyte> Cale: Ok
13:52:54 <oconnore> What's the name of the feature where ghc will insert additional _'s in a pattern match?
13:53:15 <Cale> oconnore: what?
13:53:27 <oconnore> Cale: like data X = X Int Int Int ... let (X _ _) = X 1 2 3
13:53:27 <Cale> oconnore: Can you give an example of what you want?
13:53:28 <monochrom> I have long decided to put "deep" in the same genre as "elegant". it's just another subjective feeling that makes people happy.
13:53:45 <nolrai66> Hmm.
13:53:56 <Cale> oconnore: You could use record syntax (which is legal if you're not matching any fields even if the type wasn't defined using record syntax)
13:54:07 <nolrai66> I seem to be involved in several differnt conversations other than the one I wanted to be in.
13:54:20 <Cale> oconnore: like case foo of X {} -> ...
13:54:31 <monochrom> some topics and some theorems make me happy (important: for no reason). and so I call them "beautiful" or "deep" or "delightful" or whatever irrational, emotional adjective I feel like at the moment
13:54:32 <oconnore> Cale: ah, great!
13:54:32 <nolrai66> Not sure if its worth the effort to get where I thought I was going.
13:54:33 <oconnore> thank you
13:54:50 <lpaste_> elbiot pasted “Coming from Python, does this code look reasonable?” at http://lpaste.net/135150
13:54:54 * hackagebot pqueue 1.3.0 - Reliable, persistent, fast priority queues.  http://hackage.haskell.org/package/pqueue-1.3.0 (lspitzner)
13:55:08 <monochrom> but the point is I don't have a reason. there is none. it's a personal feeling. other people do not have to concur.
13:55:20 <nolrai66> Yes.
13:55:41 <nolrai66> Is..is that relevant to what I was saying somehow?
13:56:11 <Cale> elbiot: It's kind of reasonable, but you should be cautious/suspicious about equality testing surrounding floating point quantities.
13:56:19 <ChristianS> monochrom: if they make you happy, there probably is a reason, even if you cannot put it in words. trust your intuition (to some degree)!
13:56:29 <monochrom> the most pungent example is that many people feel that monad is deep (even after understanding it in great detail, even just the definition itself). whereas I feel it trivial.
13:56:54 <Cale> elbiot: It might be a better idea to choose some epsilon and test that abs x < epsilon, rather than testing x == 0
13:56:59 <nolrai66> It feels kind of both to me.
13:57:11 <nolrai66> Lots of category stuff is both.
13:57:23 <monochrom> ChristianS: you know what, you are technically right but uselessly. the reason is always "my neural network fires in a certain way".
13:57:38 <Cale> The way we use the monad abstraction in Haskell is pretty superficial.
13:57:43 <monochrom> it's so nearly tautological that it doesn't matter.
13:57:49 <sccrstud92> i feel that what a monad is is kinda trivial, but the fact that it applies to so many things is not
13:58:14 <Cale> The notion of monads in general, their relationship to algebraic theories, and some of the results about them are pretty interesting
13:58:24 <nolrai66> Yep.
13:58:35 <Cale> Maybe still kind of shallow, depending on your standards.
13:58:56 <nolrai66> I mean..the concept of a rng is pretty trivial, but also very useful.
13:59:04 <nolrai66> So..
13:59:14 <nolrai66> Not sure trivial is actually bad.
13:59:49 <monochrom> clearly, even my "trivial" does not imply "bad".
13:59:56 <rhaps0dy> Heyo
14:00:06 <monochrom> my "trivial" only implies "why are you so excited?!"
14:00:11 <nolrai66> Ah.
14:00:12 <Cale> Well, there's a spectrum of abstraction / concreteness. Generally the more things you're able to talk about at once, the less you can say which is interesting.
14:00:14 <rhaps0dy> Anyone know a c2hs project I can read their .cabal file and try to make mine work?
14:00:21 <elbiot> Cale: thanks.  I'm more curious about the haskelly-ness of it
14:00:47 <nolrai66> I too have trouble remembering my time when monad was mysterious.
14:00:54 <elbiot> It's all pretty foreign looking to me right now
14:01:19 <rhaps0dy> all the mystery about monads is the "hype" that they have as difficult
14:01:20 <oconnore> rhaps0dy: c2hs is really weird in Cabal
14:01:29 <rhaps0dy> the researchers have done a very good job of defining them and explaining to the rest of us :D
14:01:39 <rhaps0dy> and bloggers and etc etc
14:01:40 <oconnore> cabal is convinced that it's never installed, and always re-installs when I run cabal install --only-dependencies
14:01:42 <rhaps0dy> oconnore: :\
14:01:45 <nolrai66> Well..hm. I think typeclasses, and Functors are actually dificult.
14:01:52 <nolrai66> But not obviously so..
14:01:59 <oconnore> I think it has to do with an executable-only dependency
14:02:02 <rhaps0dy> oconnore: It does see it as installed now, but it doesn't quite work.
14:02:09 <monochrom> is c2hs a package without a library? that would explain it
14:02:12 <oconnore> rhaps0dy: I have it working somewhat nicely in Shake
14:02:13 <nolrai66> so people use those and then run into do notation, and get confused.
14:02:16 <quchen> How is the ⊑ operator in type theory commonly called? "Less special than"?
14:02:18 <rhaps0dy> oconnore: it doesn't preprocess the files. Woudl you recommend the other C bindings instead?
14:02:20 <oconnore> but it doesn't sound like that would be helpful for you
14:02:20 <rhaps0dy> oh
14:02:25 <rhaps0dy> oconnore: github/oconnore/shake ?
14:02:39 <rhaps0dy> I just wanna look at the cabal file and see how things are done a bit
14:02:46 <oconnore> rhaps0dy: http://shakebuild.com/
14:02:49 <Cale> elbiot: Seems fine. At the concrete syntax level of things, consider putting a space before the = on lines 12 and 13.
14:02:54 <rhaps0dy> oconnore: ah thanks
14:03:07 <Cale> elbiot: Also consider writing a 2x2 determinant function to save yourself a whole lot of repetition there
14:03:09 <oconnore> rhaps0dy: however, once it's working, c2hs has been very nice
14:03:18 <oconnore> so I think it's worth sticking withit
14:03:20 <oconnore> *with it
14:04:15 <sccrstud92> quchen: I cant see the operator (I guess my font doenst support it) but what you descripe sounds kind of like "generalizes". does that work?
14:04:43 <rhaps0dy> oconnore: thanks.
14:05:17 <rhaps0dy>  ghc-options: -main-is Run.main
14:05:36 <rhaps0dy> oh this is interesting, instead of directly using main-is, this allows bypassing the restriction that only .hs and .lhs files are allowed
14:06:23 <Cale> quchen: "square less than or equal to"? :) It's hard to give a better name unless you give more information about the context. It's generally used for "some ordering relation which isn't supposed to be confused with the usual ordering"
14:07:11 <magneticDuck> hm, why does not initialising a record field cause merely a warning?
14:07:15 <rhaps0dy> ah, no it's not that. (the main-is)
14:07:22 <Cale> quchen: For example, the definedness ordering on values of a domain
14:07:24 <magneticDuck> well.. I guess, because laziness
14:08:25 <sccrstud92> quchen: refines? entails?
14:08:37 <Cale> magneticDuck: Well, also because it's simply specified that it fills the fields with undefined when you don't set them. Whether or not that's a good idea is debateable.
14:08:50 <rhaps0dy> oconnore: c2hs is nowhere to be found in the cabal file :(
14:09:34 <Cale> magneticDuck: Perhaps the intention is that sometimes you'd like to define all the fields in stages, using record update syntax to fill out the ones which were missed.
14:11:17 <maerwald> oh interesting... once there was a Neither typeclass and Either had an instance of it xD
14:11:39 <maerwald> not confusing at all
14:12:47 <Cale> "once"?
14:13:56 <Cale> maerwald: Not in the standard, surely...
14:14:43 <Cale> Ah, one of Michael Snoyman's packages, which is now deprecated.
14:15:41 <maerwald> Cale: I was just wondering how "Neither" looked like and fired it up at hoogle
14:15:50 <maerwald> *could look like
14:16:16 <arkeet> type Neither a b = Not (Either a b)
14:16:24 <maerwald> x
14:16:26 <maerwald> :o
14:17:35 <reindeernix> I keep getting loop is not in scope even though I have imported Control.Monad, I don't really understand how to make the compiler know it's there
14:18:39 <merijn> reindeernix: AFAIK there's no loop function in Control.Monad?
14:18:50 <merijn> reindeernix: What gave you the impression there was?
14:18:58 <reindeernix> https://hackage.haskell.org/package/loop-while-1.0.0/docs/Control-Monad-LoopWhile.html
14:19:04 <reindeernix> this did
14:19:10 <merijn> reindeernix: That's not Control.Monad
14:19:16 <merijn> reindeernix: That's Control.Monad.LoopWhile
14:19:22 <monochrom> import Control.Monad.LoopWhile
14:20:00 <reindeernix> monochrom, ooh I thought LoopWhile was included as standard, I have to download the package
14:20:26 <DNoved1> Is there a class for enumerable things which doesn't require mapping to Ints, like Enum does? So in other words a class with just 'succ' and 'pred' functions, not the (from/to)Enum ones.
14:20:52 <merijn> DNoved1: Unfortunately not :\
14:21:18 <DNoved1> Hmm, alright.
14:23:48 <ttt_fff> is there a nice wya in parsec to say: starts with Parsec.letter, and then many of TP.alphaNum ?
14:24:25 <sccrstud92> ttt_fff: use the applicative or monadic combinators
14:24:30 <merijn> eh, "letter >> many alphaNum"?
14:24:35 <sccrstud92> ^
14:24:39 <sccrstud92> sorta like that
14:24:43 <ttt_fff> well, that returns () doesn't it?
14:24:47 <ttt_fff> and doesn't actually store the value
14:24:52 <ttt_fff> unless I misunderatnd how () works
14:24:58 <sccrstud92> it returns the alphaNum
14:24:58 <DNoved1> (:) <$> letter <*> many alphaNum is what I use
14:25:02 <merijn> (:) <$> letter <*> many alphaNum
14:25:06 <sccrstud92> ^
14:25:11 <ttt_fff> I like
14:25:20 <ttt_fff> this looks hard to read and makes me look like a badass
14:25:26 <merijn> Assuming alphaNum is a Parser Char
14:25:42 <sccrstud92> what is TP?
14:25:51 <ttt_fff> oh, it's my alias for Parsec
14:25:53 <merijn> ttt_fff: It's not that hard, <$> is just infix fmap
14:25:54 <sccrstud92> okay
14:25:55 <ttt_fff> import qualified Parsec as TP
14:26:04 <athan> bergmark: ping - I've been planning some extensions to cabal for a while now, but I think placing them in stack would be better in the long run. These extensions are things like `mv`, `touch` and `rm` for modules, integration to `hi` for standardized scaffolds, and a version constraint checker tool. Do you think I could try my hand at adding these things?
14:26:30 <merijn> ttt_fff: So if "letter :: Parser Char" then "(:) <$> letter" is "fmap (:) letter :: Parser ([Char] -> [Char])"
14:26:34 <merijn> :t (<*>)
14:26:35 <Peaker> Does it seem sane/sensible to anyone that Data.Binary.Get.getWord32le (which is my machine's ordering) would get byte by byte, shift and or them(?!)
14:26:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:26:44 <Gurkenglas> Trying to cabal install cabal-install yielded this on my Ubuntu 14.04 vm: http://pastebin.com/qRqnuuL9 . Does the advice the end gives still hold in a vm? What package provides that library?
14:26:45 <ttt_fff> yeah, I get how it works after staring at <$> and <*>
14:26:50 <ttt_fff> but the (:) is really the icing on the cake
14:26:53 <ronh-> ttt_fff you may find liftA2 (:) letter (many alphaNum) more readable
14:27:01 <Peaker> I'd expect something like: get a strict byte string of the right size -- unsafeCoerce to #Word32, box in a Word32, no?
14:27:26 <Peaker> (unsafeCoerce the data behind the ByteString's Ptr, of course)
14:29:10 <arkeet> why not just add an offset to the bytestring's ptr and cast it to Ptr WOrd32
14:29:34 <arkeet> no unsafeCoerce needed
14:29:48 <arkeet> well
14:29:57 <arkeet> nm
14:30:03 <Peaker> cast is another form of unsafeCoerce?
14:30:19 <merijn> No
14:30:21 <Peaker> (well, it's where you expect it)
14:30:26 <Peaker> conceptually, at least :)
14:30:33 <merijn> Well, actually, yes
14:30:49 <merijn> cast compares the type tags from the Typeable dictionary and if they match it unsafeCoerces
14:30:58 <rhaps0dy> So, has anyone messed with c2hs and could help me for a moment?
14:31:05 <rhaps0dy> p-pretty please
14:31:08 <Peaker> anyway, Binary.get is costing about 50% of my app, and I'm doing just trivial deserialization of basic types, so that's sad. Then I see all the shifts/ors and WAT?
14:31:11 <arkeet> merijn: I mean castPtr
14:31:14 <arkeet> not Typeable's cast
14:31:28 <merijn> ah
14:31:35 <Peaker> after I heard that Binary was "heavily optimized".   My faith in Haskell's community "heavily optimized" has been almost completely lost
14:31:43 <merijn> castPtr is not unsafeCoerce, I think
14:31:43 <sccrstud92> Peaker: have you tried cereal?
14:31:59 <Peaker> sccrstud92: didn't the backends of binary/cereal merge at some point, or was that only a plan?
14:32:11 <merijn> Peaker: Oh!
14:32:19 <merijn> Peaker: You're making a mistake!
14:32:29 <Peaker> merijn: what?
14:32:31 <merijn> Peaker: Don't use "get" for existing formats
14:32:33 <sccrstud92> Peaker: not idea, but at the very least you should consider losing faith in just the person who said it was heavily optimized, and not everyone
14:32:53 <merijn> Peaker: get/put from the Binary class insert their own tagging/format stuff
14:33:02 <Peaker> merijn: Wat?? why?
14:33:20 <merijn> Peaker: If you are parsing an existing format use explicit Get/Put from Data.Binary.Get and Data.Binary.Put
14:33:47 <merijn> Peaker: cross-platform consistent serialisation
14:33:47 <arkeet> wat
14:34:04 <merijn> Peaker: Int might not be the same on different machines and you want "encode" on one machine to work when decoded on another
14:34:07 <Peaker> merijn: (runPut $ putWord32be 3) == (runPut $ put (3::Word32)) --> True
14:34:14 <Peaker> (though it is big-endian rather than platform native)
14:34:22 <merijn> Peaker: Maybe in that case
14:34:29 <Peaker> merijn: well, I don't use "Int" I think
14:34:38 <Peaker> I have "Fixed" with an Integer in it, I think
14:34:44 <Peaker> (for some timestamps)
14:34:55 <merijn> Peaker: I spent 5 hours debugging my ZeroMQ parser only to find out the typeclass was inserting a byte where I wasn't expecting it
14:35:10 <merijn> Peaker: So proceed at your own risk :)
14:36:03 <Peaker> merijn: it's only the crappy performance that bothers me :-(
14:36:28 <bitemyapp> @pl (\rd -> map snd (adra rd))
14:36:28 <lambdabot> map snd . adra
14:37:15 <merijn> Peaker: Compiled with -O2, etc.?
14:37:27 <Peaker> merijn: yeah
14:37:45 <Haskellfant> duncan did a lot of work on making binary faster, he gave a talk about it at zurihac
14:37:59 <Peaker> merijn: it's my buildsome project -- an empty build takes 12 sec (>6sec of which are spent in Binary.get)
14:38:09 <Haskellfant> iirc we're talking about factors of 2-5
14:38:17 <Peaker> I ought to look up how shake does its database storage
14:38:32 <lamefun> Does Haskell support shared pointers?
14:38:43 <Peaker> lamefun: "shared pointers" as in C++ terminology?
14:38:47 <lamefun> yes
14:38:54 <Peaker> lamefun: Haskell has GC
14:39:09 <merijn> Peaker: Wow...this is stupid: https://hackage.haskell.org/package/binary-0.7.5.0/docs/src/Data-Binary-Builder-Base.html#putWord32le
14:39:12 <Peaker> lamefun: so there's not much of a point to shared/refcounted pointers
14:39:34 <Peaker> merijn: YES, that was my reaction as well!
14:39:38 <milesrout> back
14:39:45 <milesrout> fucking internet is fucked at home
14:39:56 <Peaker> merijn: I'm thinking of trying an ad-hoc [de-]serializer instead of Binary and seeing if it improves perf
14:39:59 <milesrout> i live in a first world country and they can't even get fucking internet right
14:40:27 <milesrout> merijn, why is that stupid?
14:40:29 <merijn> Peaker: You can try writing a serialiser that unboxes directly and hack that into a binary sandbox and see what happens
14:40:36 <milesrout> shit wrong channel
14:40:36 <sccrstud92> Peaker: does cereal do the same thing?
14:40:49 <merijn> Peaker: Will need logic to detect machine wordsize, though
14:41:27 <Peaker> sccrstud92: Yes :-( https://hackage.haskell.org/package/cereal-0.4.1.1/docs/src/Data-Serialize-Builder.html#putWord32le
14:41:48 <lamefun> Peaker: can Haskell GC automatically close files/sockets/etc?
14:42:03 <sccrstud92> lamefun: I dont think it does
14:42:12 <sccrstud92> which is why things like bracket exist
14:42:35 <Peaker> lamefun: no, bracket is used for that
14:42:46 <merijn> Well, GHC can do that
14:42:46 <Peaker> lamefun: or ResourceT
14:42:50 <merijn> But normally doesn't
14:42:55 <fragamus> they can't even get the fffing channel right
14:43:51 <nolrai66> fragamus: ?
14:44:19 <sccrstud92> Peaker: even if you could shortcut on two machines with the same endianness
14:44:23 <fragamus> see milesrout above
14:44:31 <sccrstud92> you would still have to do it the long way
14:44:35 <sccrstud92> if they didnt match
14:44:37 <sccrstud92> right?
14:44:57 <sccrstud92> fragamus: I was more wondering why u were so angry
14:45:09 <sccrstud92> that they mistyped the channel that they joined
14:45:52 <quchen> Cale: As in https://upload.wikimedia.org/math/9/3/1/931c6f6bb0411c702b3671b7b8406d99.png
14:46:38 <fragamus> um, i was ripping on "<milesrout>	 fucking internet is fucked at home" and "<milesrout>	 i live in a first world country and they can't even get fucking internet right"
14:46:43 <fragamus> etc...
14:46:43 <quchen> In the Hindley-Milner context, that is
14:46:52 <sccrstud92> quchen: you talking about the square less than still? I think thats "entails"
14:47:12 <athan> or subtype?
14:47:23 <Cale> quchen: Possibly "is a specialisation of"
14:47:25 <quchen> athan: Subtype sounds like subtype polymorphism
14:47:36 <athan> quchen: That's the context that I see it most in
14:47:41 <athan> in TaPL at least
14:47:47 <quchen> sccrstud92: I've never heard "entails", but I'll look it up. Thanks
14:48:21 <athan> quchen: Or specificity
14:48:25 <sccrstud92> quchen: if thats not right, I think Cale's is right
14:48:28 <Peaker> sccrstud92: I'd probably read a whole Word32 and then use more efficient primitives to swap byte ordering as needed
14:48:28 <athan> ie: `Int -> Int` <= `a -> a`
14:49:06 <sccrstud92> Peaker: is it slow because it is converting it to a full blown Integer instead of just an int or something?
14:49:25 <athan> quchen: What article did you get that from btw? :)
14:49:35 <merijn> sccrstud92: No, but it's repeatedly shifting and copying single bytes, instead of just copying a single word in one go
14:49:36 <quchen> athan: Hm?
14:49:43 <athan> quchen: The wikimedia link
14:49:46 <Gurkenglas> I keep changing what my function outputs, but don't want to keep updating the type signature. Can I tell the type signature that the compiler should deduce the return type itself, while I still determine the parameter types?
14:49:50 <quchen> Oh, on Hindley-Milner
14:49:53 <athan> ahh :)
14:49:58 <quchen> https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
14:49:59 <athan> I think it's specificity then
14:50:19 <merijn> Gurkenglas: You can in 7.10 (or maybe not yet?) using PartialSignatures or whatever the extension is called
14:50:47 <athan> which would be similar to "entials" too, I think
14:51:24 <sccrstud92> Gurkenglas: PartialTypeSignatures
14:51:26 <sccrstud92> i think
14:51:39 <srhb> sccrstud92: Correct.
14:51:48 <athan> quchen: Check the instantiation rule
14:51:52 <sccrstud92> wooohoo. points for me
14:52:07 <quchen> athan: I know what it means, I just looked for a proper pronounciation :-)
14:52:14 <athan> herp :x sorry
14:52:35 <sccrstud92> quchen: "specializes"?
14:52:42 <quchen> athan: It means "subtype with respect to unification, but flipped to be opposed to my intuition" ;-P
14:52:47 <Gurkenglas> (I was expecting an answer using exists, but okay ^^)
14:53:04 <sccrstud92> Gurkenglas: using exists?
14:53:27 <srhb> There exists a return type for which the rest of the argument types make sense? :P
14:53:51 <Gurkenglas> It felt like something like (exists a. Bool -> Int -> a) might work. I asked here because I have no idea whether that would go into the right direction at all.
14:54:09 <athan> quchen: Exactly! :)
14:54:15 <athan> Are you working on a typechecker?
14:54:32 <srhb> Gurkenglas: You may want -fno-warn-partial-type-signatures too
14:54:37 <quchen> athan: I'm writing an article about it, yes
14:54:42 <merijn> Gurkenglas: exists is not a keyword that exists
14:55:01 <merijn> Gurkenglas: And if it was it'd be used for ExistentialQuantification which does something very different from what you're asking for
14:55:19 <Gurkenglas> While forall does not work forall versions of haskell?
14:55:53 <quchen> athan: It's a very literate version that renders well in both text editors and in Haddock, but it'll take some time because I'm not really focused on finishing it. And the presentation still needs some work.
14:56:04 <sccrstud92> Peaker: the documentation has the expected definition of putWord____ in it, but doesnt use it
14:56:07 <sccrstud92> I wonder why
14:57:45 <athan> quchen: I'd really like to see it when you're done :)
14:57:53 <quchen> Me too :-D
14:57:56 <athan> I'm working on the bottom-up implementation, based off constraint solving
14:57:58 <athan> haha
14:58:12 <Gurkenglas> http://pastebin.com/YnK7AuTF :/
14:58:31 <merijn> Gurkenglas: What's your GHC version?
14:58:37 <merijn> Gurkenglas: That extension is bleeding edge
14:58:39 <Gurkenglas> How do I find out?
14:58:45 <srhb> ghc --verison
14:58:51 <srhb> ... but with correct spelling.
14:58:58 <zoug> hey guys, I just got a VPS and played around with it for a while, and what I want to do now is install some kind of WM on it, then VNC, so that I can use │ acperkins   
14:59:00 <zoug>                     | it as a secondary machine from any computer with a VNC viewer... is this a good idea? if not, why? thank you!
14:59:06 <Gurkenglas> 7.8.3. How do I update it?
14:59:09 <zoug> ouuups sorry
14:59:13 <zoug> wrong channel hahah
15:00:02 <Gurkenglas> Repost from earlier: Trying to cabal install cabal-install yielded this on my Ubuntu 14.04 vm: http://pastebin.com/qRqnuuL9 . Does the advice the end gives still hold in a vm? What package provides that library?
15:00:03 <srhb> Gurkenglas: Depends. Your distro may or may not have a newer version. Or external sources might add that to your package manager. Or you might want to get it manually from ghc.haskell.org
15:01:18 <hexagoxel> isn't this about a non-haskell dependency?
15:02:05 <Peaker> sccrstud92: where is the expected def?
15:02:19 <ion> Gurkenglas: Install zlib1g-dev
15:02:43 * Gurkenglas searches vm's software center for that term
15:03:34 <JoshieAS> Got a datatype question
15:03:52 <slack1256> fire
15:04:11 <JoshieAS> Say I want to make a datatype, Planet, that represents all the nine planets. I want each planet to have a specific numeric value associated with it such that when I pass a Planet to a function, it gives me that planets numeric value..
15:04:24 <JoshieAS> Planet's*
15:04:51 <sccrstud92> Peaker: right underneath putWord32le definition https://hackage.haskell.org/package/binary-0.7.5.0/docs/src/Data-Binary-Builder-Base.html#putWord32le
15:05:48 <sccrstud92> at least i think that is what someone was saying could be done
15:06:09 <Cale> JoshieAS: okay, pattern match
15:06:31 <JoshieAS> yeah, but it's my datatype constructor that is confusing me
15:06:42 <JoshieAS> something like data Planet = Earth Int | Mars Int...etc?
15:06:48 <Peaker> sccrstud92: ah
15:07:20 <Cale> JoshieAS: If it's like that, then values of your type will look like  Earth 6, Earth 2, Mars (-5), etc.
15:07:31 <Cale> JoshieAS: Is that what you want?
15:07:45 <slack1256> @data Planets = Earth | Mars | Venus
15:07:45 <lambdabot> Unknown command, try @list
15:08:00 <JoshieAS> Cale: That would be fine
15:08:19 <Gurkenglas> JoshieAS, http://lpaste.net/135163
15:08:27 <ion> I seem to remember Earth 2 was interesting.
15:08:27 <Cale> JoshieAS: Since there will be 9 (8?) constructors, you might just want to separate out the choice of planet and make it a simple enumeration type, using a different type for pairing the planet with an integer.
15:08:51 <Gurkenglas> Installing that package worked, thanks ion.
15:09:36 <Cale> JoshieAS: That way, you hopefully won't constantly be pattern matching on all of the cases.
15:09:57 <JoshieAS> so just Planet = Earth | Mars etc
15:10:11 <Cale> yeah
15:10:38 <JoshieAS> Gurkenglas: Thanks! But the problem I'm solving requires the planet to be an actual data type
15:10:51 <Gurkenglas> I want to see the problem that requires that.
15:11:02 <JoshieAS> hehe ^^;;;
15:11:22 <JoshieAS> it's not stated explicitly, but the testfile has the planets listed as data types
15:11:36 <Gurkenglas> Send the author of that testfile here, we'll talk to him.
15:12:10 <slack1256> nah, probably this is a learning experience for him. Let them be
15:12:56 <sccrstud92> Gurkenglas: It could be for a intro haskell class
15:12:58 <slack1256> @type lookup
15:12:59 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
15:13:09 <Peaker> does deriving a Binary instance via Generic make a less efficient one than writing the standard Binary get/put boilerplate?
15:13:13 <Gurkenglas> sccrstud92, then it is a bad intro haskell class!
15:13:31 <sccrstud92> Gurkenglas: well I'm happy you have such a strong opinion
15:13:32 <slack1256> Even bad classes can give you great insights
15:13:58 <sccrstud92> and even good classes can have bad moments
15:14:10 <sccrstud92> its the perfect ones that dont
15:15:27 <slack1256> JoshieAS: the 'lookup' function from Data.List is interesting for you case, take a look
15:15:52 <slack1256> I remember there was also a subchapter on LYAH with a problem like this
15:16:38 <Gurkenglas> Granted, it's a bad moment, not necessarily a bad class. And that bad moments usefully show you what not to do. But putting not "conceptually locked" information into the type constructors is still bad style, right?
15:16:53 <JoshieAS> cool, thank you!
15:19:54 <tedkornish> How do you all like to structure tests in a Haskell project directory layout? Are there any conventions around that?
15:22:01 <slack1256> I like GHC ones. With shouldFail and ShouldNotFails
15:22:14 <slack1256> But test don't have to be as nity as the code structure
15:26:09 <Gurkenglas> Executed cabal install gf twice in the vm, so the second one would only show the relevant part: http://pastebin.com/zD0ZCAaG
15:26:42 <Gurkenglas> I'm guessing "/usr/bin/ld: cannot find -ltinfo" is the crux, how do I go about getting an -ltinfo for my /usr/bin/ld?
15:27:19 <SrPx> There are many tree formats, why Data.Tree chose that one specifically? Is there anything good/desirable about that particular setup? 
15:29:09 <Gurkenglas> If I have a machine that can compile a .hs to an executable, I can also compile it into a format that any machine will be able to compile into an executable that runs on that machine, right?
15:29:46 <geekosaur> Gurkenglas, hm, is this rhel6/centos6?
15:30:13 <Gurkenglas> I don't know what those words mean. I'm trying to install gf so I can build a chatbot for my class.
15:30:34 <slack1256> SrPx: Not answering you question but the initial commit for that module says
15:30:40 <slack1256> "Graph and Tree modules, from GHCs Digraph"
15:30:56 <geekosaur> oh right, you're on windows
15:30:56 <slack1256> I guess it was an ancestry of being part of Graphs implementation
15:31:12 <slack1256> That form make a little sense then
15:31:21 <Gurkenglas> The vm whose shell I'm currently reporting on is an Ubuntu 14.04
15:31:29 <geekosaur> oh
15:31:42 <geekosaur> ubuntu won't have iot, which is why I asked about rhel6 (red hat enterprise linux)
15:32:56 <Gurkenglas> (Started up my old VirtualBox vm because the problem stopping me from installing gf on the Windows machine was apparently specific to Windows. Network did install successfully!)
15:33:45 <Gurkenglas> (unknown identifier "iot")
15:34:40 <geekosaur> hm, actually it does but you need to install it
15:34:55 <geekosaur> sudo apt-get install libtinfo-dev
15:35:02 <Gurkenglas> k
15:35:13 <geekosaur> thought it'd been folded in by now...
15:35:29 <Gurkenglas> My image might be a few months-years old.
15:36:25 <Gurkenglas> Worked, thanks.
15:38:46 <Quantumplation> Hi there.  I have a type, "data Drop = Drop { ... }", and I want to declare a typeclass instance for FromJSON (Maybe Drop).  Is that possible?
15:40:01 <slack1256> Quantumplation: Check out if that class doesn't has already a instance "instance (FromJSON a) => FromJSON (Maybe a) where"
15:46:15 <Quantumplation> ah i see, Maybe a is already defined, if I tried to define Maybe Drop, it wouldn't know which one to pick
15:46:35 <hodapp> AllowAmbiguousTypes started in GHC 7.7, right?
15:46:35 <Gurkenglas> Only if you also define it for Drop, I think.
15:49:59 * hackagebot json-autotype 1.0.6 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-1.0.6 (MichalGajda)
15:51:48 <Quantumplation> oh man, that's exactly what i'm looking for hackagebot :D
15:53:55 <slack1256> holy damn, hackagebot never was more fitting than this
15:54:40 <Quantumplation> What's the :|: thing I see here? https://github.com/mgajda/json-autotype
15:55:08 <maerwald> looks like a mirror
15:55:48 <Quantumplation> it looks like N-ary either?
15:56:50 <Hijiri> what does hp2ps use to make those banded graphs?
15:57:13 <geekosaur> Quantumplation, https://github.com/mgajda/json-autotype/blob/master/Data/Aeson/AutoType/Alternative.hs
16:03:19 <Quantumplation> @geekosaur an, nice! clever!
16:03:19 <lambdabot> Unknown command, try @list
16:03:26 <Quantumplation> ah*
16:07:02 <gavaz> >
16:08:13 <gavaz> How do I use attoparsec to extract "abcd" from "http://www.google.com?q=abcd&i=qwerasdfy"?
16:08:28 <gavaz> The "abcd" is from the "q=" part
16:10:27 <pacak> gavaz:   something like that: string "google?" &>  A8.takeWhile (/= '&') `sepBy` string "&"
16:11:02 <pacak> gavaz: You'll get [("q", "abcd"), ("i", "qwertyadsf")]
16:11:16 <a_131415> Hi guys, I want a zip kind function that fills the list which miss an element with some default value, is that already defined?
16:11:19 <gavaz> Thanks!
16:12:22 <a_131415> that is: zip' 0  [1] [2,3,4] = [(1,2),(0,3),(0,4)]
16:12:43 <mightybyte> The NY Haskell Meetup is live streaming now at http://original.livestream.com/pivotallabs
16:13:56 <Clint> alas
16:14:13 <pacak> a_131415: takeWhile (/= (0, 0)) $ zip (xs ++ repeat 0) (ys ++ repeat 0)
16:14:49 <ronh-> (0, 0) could be a valid element and not the end
16:15:27 <a_131415> yes
16:15:35 <oconnore> is there a reason to avoid type constraints in a typeclass definition? I usually see more of them defined on individual functions
16:16:47 <a_131415> pacak thanks! but I guess your definition isn't general enough
16:17:07 <a_131415> pacak this case will break your def: zip' [1] [0,0,2,3,4]
16:17:14 <pacak> a_131415: Still waking up.
16:18:56 <a_131415> I've defined it, but I wonder if it's already defined in a library
16:19:47 <Gurkenglas> Did you use maximum length or recursion?
16:25:00 * hackagebot hset 0.0.1 - Primitive heterogenous read-only set  http://hackage.haskell.org/package/hset-0.0.1 (AlekseyUymanov)
16:25:24 <fishythefish> oconnore: do you mean in data declarations?
16:43:36 <lifter> Are there libraries/implementations of STM in languages besides Haskell that are as attractive and compelling as Haskell's STM?
16:53:20 <funfunctor> Hi, any folks around well versed in digestive functors, they are horrible things to work with..
16:54:46 <codygman> I don't understand why I'm getting this type error. Well after some playing it seems a is parameterized by ConnectionPool? error: http://lpaste.net/135171
16:55:55 <Cale> codygman: Look at your explicit type signature
16:56:20 <geekosaur> codygman, the a in your signature does not mean you can return anything, it means you promise to return whatever the caller demands
16:56:34 <geekosaur> s/anything/anything you want/
16:56:36 <Gurkenglas> codygman, what it is complaining about is that you are returning (), making the result of type ReaderT ConnectionPool m (), while your type signature said you'd be returning a ReaderT ConnectionPool m a, meaning that you would supply a value for any a another function tries to get from this.
16:57:46 <Cale> Basically, for a computation to have a result of any type whatsoever is more or less a claim that it doesn't terminate normally. It might return undefined or error, but otherwise, it'd be an infinite loop.
16:58:09 <codygman> geekosaur, Gurkenglas, Cale: Thanks
17:13:50 <codygman> How can I specify I want to return either [Entity User] or (Key User) in my reader monad? http://lpaste.net/135171
17:16:04 <Hafydd> codygman: ReaderT ConnectionPool m (Either [Entity User] (Key User)); or define something like: data EntityKeyUser = UserEntities [Entity User] | UserKey (Key User).
17:16:56 <Hafydd> The latter would avoid confusion with the Error-like usage of Either.
17:30:46 <simon> it seems that postgresql-simple has the typeclasses FromRow and ToRow, but mysql-simple doesn't have them? or am I overlooking them?
17:33:05 <dmj`> simon: no
17:42:22 <Welkin> why is Data.Time.Format.Locale not exported from the time package?
17:42:49 <Welkin> I need access to TimeLocale in order to format the time/date, but there is no way to use it
17:42:59 <jb55> yeah I remember having to import it from elsewhere
17:43:10 <Welkin> how?
17:43:13 <Clint> Welkin: https://hackage.haskell.org/package/time-locale-compat
17:43:34 <Welkin> what's with that?
17:43:39 <Welkin> is it a mistake, or on purpose?
17:43:49 <jb55> Looking in my code I have System.Locale, not sure if that's outdated though
17:45:11 <geekosaur> locale package was created for old-time (with the expectation that it would expand with more than just time) and incorrectly deprecated with it.
17:45:16 <geekosaur> it's kinda screwy
17:45:19 <lpsmith> simon, mysql-simple has QueryParams and QueryResults,  which originated the very basic idea around ToRow and FromRow.
17:45:38 <lpsmith> It's changed substantially though,  in postgresql-simple
17:45:39 <verement> Welkin: defaultTimeLocale (and TimeLocale) moved from old-locale to time in time-1.5
17:45:53 <Welkin> verement: I see that, but why is it not exported?
17:46:39 <Clint> Welkin: it is
17:46:56 <Welkin> Clint: I saw it in the package you linked, but not in time
17:47:16 <Clint> https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Format.html#v:defaultTimeLocale
17:47:31 <Clint> but you don't want to use that if you want reasonable portability
17:47:46 <Welkin> what should I use if I want to format a date?
17:47:57 <Clint> time-locale-compat
17:47:59 <Welkin> also, that module is not exported, which is the problem
17:48:05 <verement> Welkin: TimeLocale is exported from Data.Time
17:48:08 <Clint> are you sure you're using time-1.5
17:49:33 <Welkin> yes1.4.2
17:49:34 <Welkin> er
17:49:36 <Welkin> 1.4.2
17:50:03 <verement> Welkin: for that version, try System.Locale
17:50:23 <Welkin> is there a better way to convert UTCTime to a format like "June 24, 2015"?
17:50:28 <verement> "or use the compat package
17:54:14 <Welkin> okay, thanks
18:05:24 <Adeon> someone familiar with the 'stack' build tool? can I in some way install executables that end up in some directory I can add to PATH
18:05:50 <Adeon> I'm trying to install ghc-core and use it with it
18:11:05 <Adeon> well, plain cabal-install for that still works
18:11:18 <Adeon> perhaps stack is not designed to manage executables this way
18:18:15 <luite__> \o/ http://hdiff.luite.com/tmp/ghcjsi1.png  \o/
18:19:09 <mgsloan> :D awesome!!
18:19:31 <pingu> luite__: you got a repl going? When did that happen?
18:20:43 <codygman> Adeon: I think `stack install` installs programs to: /.stack/programs/x86_64-linux/ghc-7.8.4/bin
18:20:53 <codygman> substituting of course your architecture and ghc version
18:21:01 <codygman> so you should be able to just add that to your path
18:21:03 <luite__> pingu: oh i started a while ago but then never touched it for weeks. got basic functionality working yesterday and browser integration today
18:21:05 <pacak> luite__: Sooooooo much wasted space.
18:21:15 <luite__> pingu: but it's still very much wip
18:21:42 <Adeon> ohhh
18:21:51 <Adeon> I actually tried stack install ghc-core but it failed for a mysterious reason
18:21:59 <Adeon> I assumed it was stack's problem but maybe ghc-core is the problem
18:22:17 <pingu> luite__: so the browser integration is just a websocket stream or something?
18:22:43 <Adeon> yep, I could install alex although the binary landed in ~/.local/bin rather than somewhere under ~/.stack
18:23:01 <luite__> mgsloan: good work on the stack docker image by the way, i forgot to reply to your mail because i was working around the clock on this stuff :)
18:23:12 <luite__> pingu: it uses socket.io
18:23:32 <funfunctor> why would    "postcode"   .: stringRead "Not a number" p    keep failing with "Not a number" from digestive-functors?
18:23:47 <funfunctor> defined here https://hackage.haskell.org/package/digestive-functors-0.8.0.0/docs/Text-Digestive-Form.html
18:24:09 <luite__> pingu: but many things haven't been implemented yet. proper Ctrl-C handling and sending messages to abort computations for example
18:24:19 <funfunctor> its really hard to debug
18:24:41 <pingu> luite__: it's very impressive. Congrats on getting that working.
18:25:24 <pingu> I'll bet there's some neat applications.
18:25:55 <luite__> i already found a bug in ghcjs-base using it :)
18:26:39 <luite__> the terminal REPL might be more important, that just runs on node.js, like TH
18:27:04 <luite__> the same script opens an http server and forwards messages over a socket.io connection
18:49:08 <funfunctor> you know things are bad when your reading compiler AST to fix bugs in your code :/
18:58:12 <LordBrain> Hey, I have an extra cabal folder which is not ~/.cabal, but i also have hoogle and it generated a database in ~/.cabal/share/hoogle... How do i tell it to generate a database using the nonstandard cabal folder? Anyone know?
19:04:21 <cj3kim> hi
19:05:04 <cj3kim> I refactored my code earlier to use pattern matching, but now I want my input to be of type String instead of [String]. Is there a way to convert String to [String] before passing it to pattern matching?
19:05:06 <cj3kim> https://gist.github.com/cj3kim/352fd09bfb5577491777
19:05:24 <cj3kim> Any other refactoring suggestions are appreciated
19:05:30 <cj3kim> Log Analysis is the file.
19:08:05 <orzo_> cj3kim: i don't understand your question, I see two pattern mathces involving strings in your LogAnalysis file
19:08:31 <orzo_> the arguments of parseMessage is a pattern match against [String]
19:08:47 <orzo_> what do you want to convert
19:09:05 <cj3kim> parseMessage :: [String] -> LogMessage converted to parseMessage :: String -> LogMessage
19:09:41 <cj3kim> and then have String converted to [String] with (words String) to be subsequently pattern matched
19:10:26 <orzo_> oh
19:10:30 <orzo_> ViewPatterns
19:10:37 <cj3kim> as of right now, I need to execute this way -> parseMessage (words "E 2 23425 'this is an error'")
19:10:57 <cj3kim> but really i want to do this : parseMessage "E 2 23425 'this is an error'"
19:11:01 <orzo_> parseMessage (words -> (x : y : h@(z : xs))) = 
19:11:04 <adu> なに
19:11:12 <adu> sorry, wrong language
19:11:26 <orzo_> lookup ViewPatterns
19:11:30 <cj3kim> orzo_: will do!
19:11:34 <cj3kim> thanks for the pointer :D
19:11:50 <cj3kim> will dereference
19:14:21 <orzo_> remember to free it afterward
19:58:07 <mniip> hmm
19:58:27 <mniip> hindley-milner doesn't help much when you have untouchable type variables
20:10:24 <mniip> oh
20:10:51 <mniip> I have to annotate co/contravariance in each typeconstructor application, otherwise subtyping relation would be uncalculable
20:22:41 <mniip> is there some possibly polymorphic alias for Left for when you're using Either in a monadic way
20:27:57 <mniip> hmm
20:34:56 <jle`> mniip: how about throwE ?
20:35:05 <mniip> :t throwE
20:35:06 <lambdabot>     Not in scope: ‘throwE’
20:35:06 <lambdabot>     Perhaps you meant one of these:
20:35:06 <lambdabot>       ‘throw’ (imported from Control.Exception),
20:35:24 <jle`> oh wait that's wrong
20:35:29 <mniip> that's uh
20:35:32 <mniip> for ExceptT
20:35:46 <jle`> throwError
20:36:10 <jle`> > throwError 5 :: Either Int Bool
20:36:11 <lambdabot>  Left 5
20:36:23 <mniip> :t throwError
20:36:24 <lambdabot> MonadError e m => e -> m a
20:36:29 <mniip> ah
20:36:30 <mniip> mtl
20:37:38 <jle`> you might need a recently newish version though
20:37:46 <jle`> i think in the old version there was a constraint on the e
20:37:47 <jle`> hm
20:37:55 <jle`> actually i think not, i'm crazy
20:39:53 <jle`> what we need is an instance Monad (Either String) where fail = Left
20:40:01 <jle`> yup definitely a good idea
20:40:11 <funfunctor> How can I fix this http://lpaste.net/5127283953115332608 , see line 4
20:51:28 <mniip> what a dilemma
20:51:48 <mniip> I can make a datatype more comfortable to use, but I end up sacrificing the Functor instance
20:52:08 <mniip> and with it goes Applicative and Monad
20:53:51 <mniip> well, actually, the Functor instance stays, but it won't be as useful
20:55:54 <calvinx> Has anyone tried stack yet? How does it compare to cabal?
20:56:04 <calvinx> *cabal-install
21:10:13 * hackagebot ide-backend 0.9.0.11 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.11 (MichaelSnoyman)
21:24:52 <GLM> How easy would it be to have a dependent type for a sorted list?
21:32:27 <Axman6> GLM: http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf goes through implementing that and explaining it
21:36:06 <mniip> if I have a (T -> T -> Maybe T) and a list of initial T, how would I build an infinite list of all possible T?
21:38:26 <mniip> \f i -> let r = i ++ catMaybes (f <$> r <*> r) in r
21:38:28 <mniip> does not suffice
21:38:59 <mniip> because if 'r' is infinite, f is always applied to the first element of r, iterating over the second one
21:39:29 <crocket> How do people handle DB functionally on haskell?
21:39:39 <crocket> Datomic is a functional database, but it is not free.
21:40:25 <Axman6> what do you want to do? there's plenty of libraries that connect to common databases
21:41:25 <zacts> Axman6: I think crocket is curious as to how the Haskell community has solved the problem of implementing DB in a functional paradigm
21:41:37 <zacts> I'm chatting with crocket on another channel
21:41:48 <zacts> they want to perhaps borrow ideas from haskell for (scheme)
21:41:57 <crocket> No
21:42:02 <crocket> for anything
21:42:09 <zacts> ok
21:42:22 <zacts> my apologies crocket, I'll let you speak for yourself. :-)
21:42:29 <Axman6> there was a paper released a few weeks ago about implementing a ralational database in haskell. haven't read it myself yet
21:45:57 <zacts> Axman6: http://referaat.cs.utwente.nl/conference/15/paper/7281/building-a-functional-relational-database.pdf ?
21:46:41 <Axman6> that looks like the one
21:46:46 <zacts> cool
21:52:21 <lpaste_> LordBrain pasted “How to catch this exception?” at http://lpaste.net/135182
21:52:28 <LordBrain> ^^
21:52:51 <LordBrain> can someone look at that for me... I am basically trying to programatically test if i have access to /var/log
21:53:08 <LordBrain> but when i run that program as a user, it doesn't seem to catch the exception
21:53:48 <LordBrain> Oh wait, it does, it's just the output is exactly the same as if it didnt...
21:58:07 <crocket> Do people have an off-the-shell solution for functional database?
21:59:44 <L8D> where do I go to ask about high-level programming stuff?
22:02:24 <crocket> ##programming
22:02:39 <lpaste_> mniip pasted “findAll” at http://lpaste.net/135183
22:03:22 <LordBrain> i want to only catch Permission Error... i don't see any constructors for IOException
22:05:12 <mniip> LordBrain, exceptions are existentially quantified 
22:06:45 <mniip> oh
22:06:58 <mniip> LordBrain, you're looking for 'isPermissionError'
22:07:12 <verement> LordBrain: use catchJust with isPermissionError ?
22:07:32 <LordBrain> thanks
22:07:55 <LordBrain> i found isPermissionError, at first i wasnt sure it was compatible with Control.Exception, but it is
22:10:24 <funfunctor> @hoogle Text -> String
22:10:25 <lambdabot> Data.Text.Internal.Lazy showStructure :: Text -> String
22:10:25 <lambdabot> Data.Text.Internal showText :: Text -> String
22:10:25 <lambdabot> Data.Text unpack :: Text -> String
22:11:24 <cj3kim> hi LordBrain, I have a math project that heavily utilizes edge vectors by applying transformations and other types of computations. Do you think Haskell is appropriate for this tasks if we intend to make our vector structures mutable?
22:12:53 <LordBrain> yeah
22:13:26 <LordBrain> i think its fine. what is the other alternative you are considering tho?
22:14:46 <cj3kim> LordBrain: well, we already built a prototype in Python and that worked well for a while, but I like Haskell so much more. 
22:15:21 <LordBrain> if you say python or R, then, i say definitely, just go with haskell... if you are doing some lowlevel bit twiddling in c or something to get that extra bit of performance, then yeah haskell might a bit high level for you.
22:16:14 <LordBrain> it is possible to get very very good performance with haskell and it mixes with c well, but its not as easy as with just using a lower level language.
22:17:22 <LordBrain> however, even in the high performance case, once you get past that extra hurdle, you end up with a really nice usuable haskell library, which is more valuable imo than a c one...
22:18:23 <cj3kim> LordBrain: is there anything Haskell may not be good for? 
22:18:28 <LordBrain> it sounds to me that haskell is definitely the best option for you, if you'd even consider python...
22:18:52 <cj3kim> well, I spent five months building the prototype in python
22:19:13 <cj3kim> but it's hell going back through the code 
22:20:13 <cj3kim> furthermore, we found out that floating point values accumulate enough errors to be significant after enough computations
22:20:25 <LordBrain> well, lowlevel stuff... drivers, kernels, it can be done.. but it is harder, and it doesn't seem like the community really prioritizes that kind of thing, they just think use a lowlevel language instead... so you end up doing a lot of work and breaking new ground if you are making something like a real time operating system that runs on bare metal...
22:20:29 <cj3kim> and switching to Decimal computations would be a HUGE pain
22:21:20 <LordBrain> you'd also have to really really get intimate with the compiler and learn a lot of stuff.. maybe write extensions and so on... because like i said, it would be nice, but its just not there for that.
22:21:46 <cj3kim> I see. That is helpful.
22:22:10 <cj3kim> thanks!
22:22:17 <LordBrain> but for your purposes, that does not really apply at all, and making a high performance graph theoretical app or whatever it is you are doing, is very doable.
22:24:16 <verement> Haskell makes tasks like switching value representations a lot more bearable, because of strict typing
22:24:36 <cj3kim> verement: oh, yes, definitely :)
22:24:53 <cj3kim> I've been deep into haskell coding the last week or so
22:24:58 <Pastaf> the seL4 microkernel is 20% haskell https://github.com/seL4/seL4
22:25:09 <cj3kim> I don't want to go back to js, node, ruby, or pythong
22:25:18 <cj3kim> now
22:25:29 <LordBrain> they have a prototype in haskell
22:26:49 <LordBrain> it would be nice if haskell wasn't just for prototyping your microkernel tho, but simply being the source that you use in production.
22:26:52 <Pastaf> then there's http://programatica.cs.pdx.edu/House/
22:27:31 <LordBrain> i'm familiar with House and sel4, but still honestly more work is needed in this regard.
22:27:58 <Pastaf> and https://intoverflow.wordpress.com/kinetic/
22:28:36 <Pastaf> Well, I haven't done any low-level haskell before, but it seems to be a lot more reasonable than ... certain other languages.
22:30:19 <LordBrain> i think a haskell like language could be really really low level, but haskell at the present isnt. Ideally, you wouldn't have a garbage collector or runtime linked in necessarily, you'd have access to completely control memory management for example.
22:31:12 <arahael> why would a GC be a problem?
22:32:16 <Pastaf> arahael: GC means that you can't write the memory management in Haskell, and instead have to bootstrap the runtime for it
22:32:27 <cj3kim> btw, I'm interested in working in haskell as a job. what's the market like? and how much experience does one need to get a foot in the industry?
22:32:48 <AshyIsMe> LordBrain: there's the atom library: https://hackage.haskell.org/package/atom
22:32:52 <LordBrain> a GC is part of the program written for you, its not a problem, unless you happen to want to write that yourself...
22:33:13 <Pastaf> you can't have a GC clean up after itself
22:33:42 <Pastaf> not in practice, at least
22:33:50 <arahael> i don't see why not? the memory would leak until you start the GC though.
22:34:14 <Pastaf> the GC would get stuck in an infinite loop cleaning up after itself cleaning up after itself
22:35:17 * hackagebot laika 0.1.3.1 - Minimalistic type-checked compile-time template engine  http://hackage.haskell.org/package/laika-0.1.3.1 (NikitaVolkov)
22:35:17 <arahael> not if you made everyhingnstrict and avoided boxed types?  but even so, the garbage produced by a GC run would surely be relatively minimal - a constant overhead?
22:35:27 <arahael> *everything strict
22:36:20 <Pastaf> maybe it is possible.
22:37:20 <LordBrain> AshyIsMe, i'm not too much familiar with Atom, and it seems neat, but I do think it is possible to have the multipurpose language itself be scalable in such a way that it can be very high level and very low level depending one what you write, and still be one language with a lambda calculus like syntax.
22:38:30 <arahael> i'm reasonably sure that pypy's gc is implemented in rpython.
22:38:31 <Pastaf> we can begin bootstrapping the runtime and building the system immediately. You provide the low level bindings, I mangle them together into a system.
22:38:47 <LordBrain> having an EDSL, with a monad makes a barrier between the high and low level languages which i do not think is truly necessary from a theoretical standpoint.
22:40:17 * hackagebot list-t-attoparsec 0.4.0.2 - An "attoparsec" adapter for "list-t"  http://hackage.haskell.org/package/list-t-attoparsec-0.4.0.2 (NikitaVolkov)
22:40:19 * hackagebot html-tokenizer 0.3.0.2 - An "attoparsec"-based HTML tokenizer  http://hackage.haskell.org/package/html-tokenizer-0.3.0.2 (NikitaVolkov)
22:45:17 * hackagebot html-entities 1.0.1.1 - A codec library for HTML-escaped text and HTML-entities  http://hackage.haskell.org/package/html-entities-1.0.1.1 (NikitaVolkov)
22:58:23 <AshyIsMe> LordBrain: yeah i havent done much embedded stuff at all really but i'd  like to mess around with Atom at some point
23:00:23 <LordBrain> maybe someone should write a haskell compiler in atom.
23:00:43 <LordBrain> or... an atom compiler
23:16:49 <AshyIsMe> atoms all the way down right...
23:25:05 <alisia> @src liftIO
23:25:05 <lambdabot> Source not found. Maybe you made a typo?
23:25:44 <funfunctor> alisia: Control.Monad.IO.Class
23:36:14 <fumieval> I think Complex should be an instance of Applicative
23:36:58 <fumieval> there's only one way to do it right
