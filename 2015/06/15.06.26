00:00:08 <edwardk> Zemyla: the laws there are _not_ automatic
00:00:10 <Zemyla> Well, if something is both Applicative and ComonadApply, can it be proven that extract (pure x) = x?
00:00:15 <edwardk> no
00:01:17 <bshelden> I wonder if there's any interesting library that could be defined around such a law.
00:01:18 <Zemyla> Actually, yes it can, but you have to use parametricity.
00:01:25 <edwardk> you have no reason to believe that return and join are comonad coalgebras and that extract and duplicate are monad algebras. (interestingly if you can show one pair of those, then the others can follow)
00:01:53 <creichert> funfunctor: I believe it should be this simple: http://lpaste.net/4036334965414166528
00:02:03 <edwardk> extract (pure x) may work, its been a while since i did this construction
00:02:04 <Zemyla> extract (pure id <@> pure x) = extract (pure id) (extract (pure x)), and extract (pure id) is of type a -> a.
00:02:32 <Zemyla> Wait, that just gives us extract (pure x) = extract (pure x).
00:02:51 <edwardk> even with extract . pure = id, you get nothing about pure . extract
00:03:05 <Zemyla> Well, yeah.
00:03:10 <creichert> funfunctor: the it also looks like you are parsing String instead of Int for a few fields, that can definitely raise the rerror you are seeing. (I have to go now, good luck)
00:03:44 <edwardk> there is a structure related to what you are stomping around with here, a notion of a bialgebra or hopf algebra that pops up over and over in linear algebra
00:03:59 <edwardk> but they are very special beasts
00:05:29 <dramforever> edwardk: Hijiri asked if anyone knows some existing version of data Foo a b c = Foo a (b -> Either (Foo a b c) c)
00:05:42 <dramforever> that looks like a comonad to me, if you move a to the last param
00:05:55 <dramforever> so...is there any existing one?
00:06:07 <edwardk> dramforever: its not familiar to me in that guise
00:06:18 <dramforever> oh wait edwardk, sorry I didn't mean to mention you
00:06:49 <funfunctor> creichert: well thanks for the help !
00:07:13 * dramforever is very interested in that type
00:07:16 <edwardk> so that feels like a 'monadic moore machine' or something
00:07:19 <Zemyla> But yeah, I know pure (extract x) /= x, because it discards the remaining structure.
00:07:59 <dramforever> maybe comonadic? :) (that is, if we move a to the last)
00:08:16 <edwardk> data Foo c b a = Foo a (b -> Either c (Foo c b a)) -- is a moore machine with an Either c effect at each step
00:08:34 <edwardk> it is a cofree comonad
00:08:37 <edwardk> so yes, its comonadic
00:08:59 <edwardk> you can see it as Cofree (Compose ((->) b) (Either c))
00:09:00 <Zemyla> edwardk: So it's Cofree (Compose ((->) b) (Either c))?
00:09:04 <edwardk> yeah
00:09:46 <edwardk> it is a moore machine with 'either' effects, letting you 'fail' and give a 'c' at any step
00:11:54 <edwardk> now we can construct monadic mealy machines pretty easily, but moore machines are usually comonadic in nature, interestingly the presence of the Either c monad doesn't break any of the comonadic structure here.
00:12:07 <edwardk> i don't know if the monad from http://hackage.haskell.org/package/machines-0.5.1/docs/Data-Machine-Moore.html adapts to this extra effect layer or not
00:12:14 <Zemyla> edwardk: That's because it's cofree and forgetful, yes?
00:12:20 <edwardk> its plausible but i'm too tired to check
00:13:02 <edwardk> Zemyla: well 'cofree' is right adjoint to a forgetful functor.. but in another way all right adjoints are forgetful' so, 'yes it is', but i'm not sure how that connects
00:14:03 <Zemyla> edwardk: Even if not, if c is a monoid, you can make b -> Either c a an Alternative, which makes Cofree a monad.
00:14:34 <edwardk> well the cofree instances for a lot of that stuff are well and truly screwed up
00:14:43 <edwardk> there is a construction like that in a ghani paper
00:14:52 <edwardk> but the cofree instances are out of whack
00:14:56 <jle`> hi everyone
00:14:59 <edwardk> and i haven't fixed them yet
00:15:01 <jle`> why does Data.Functor.COnstant.Constant exist?
00:15:05 <jle`> from the transformers library
00:15:18 <edwardk> jle`: because ross hasn't removed it yet
00:15:19 <jle`> when we have Control.Applicative.Const fromb ase?
00:15:27 <edwardk> he wrote both
00:15:30 <Zemyla> edwardk: Oh, question. Why does Profunctors define a new WrappedArrow instead of using the one from Control.Applicative?
00:15:31 <edwardk> and forgot Constant =)
00:15:49 <edwardk> but then likes Constant because it lives with the others, despite the fact that nobody but him (and occasionally roconnor) uses it
00:15:49 <jle`> but
00:16:00 <edwardk> Zemyla: i'd have to orphan instances
00:16:01 <jle`> then we have Control.Applicative.Lift.Errors
00:16:03 <edwardk> Zemyla: screw that
00:16:16 <jle`> type Errors e = Lift (Constant e)
00:16:24 <jle`> would anybody be mad if we made it type Errors e = Lift (Const e)
00:16:24 <edwardk> jle`: yes, be wrote both
00:16:28 <edwardk> er he did
00:16:31 <Zemyla> Well, then could the one from Profunctors define Functor and Applicative instances like the one from Control.Applicative does?
00:17:00 <edwardk> i'm generally not averse to adding obvious instances if there is only one definition for them
00:17:09 <edwardk> Zemyla: send me a patch
00:17:22 <Zemyla> Speaking of which, did you get my patch for parsers?
00:17:46 <edwardk> i did, but it'd be a lot easier for me if you sent it through github. i always have to stop and look up how to apply them when i get it in email. ;)
00:17:52 <edwardk> haven't had to do that in ~4 years =P
00:18:09 <jle`> does the maintainer of transformers have any intention of changing it to type Errors e = Lift (Const e)
00:18:17 <jle`> it'd be nice and stuff
00:18:22 <edwardk> jle`: i have given up on trying to read ross' mind
00:18:25 <jle`> but i guess it's not that big of a deal
00:18:33 <yayfoxes> what would you do if you wanted a beginner to programming to study haskell?
00:18:36 <edwardk> at one point in time he agreed to remove it
00:18:43 <Zemyla> Hmm. So I need to look up how to download git packages.
00:18:45 <edwardk> but i have no idea what is actually happening
00:18:50 <jle`> if you just use runErrors and failures then it really doesn't matter actually
00:19:04 <jle`> yayfoxes: guide them closely :3
00:19:22 <yayfoxes> then what books do I read? where's the exercises?
00:19:26 <jle`> there are some tutorials online maybe, but i think getting someone new to programming to jump into haskell is something best left for a hands-on experienve
00:19:28 <jle`> *experience
00:19:45 <jle`> just for the starting-with-programming stuff, at least
00:19:49 <jle`> things like how to set up an IDE
00:19:51 <jle`> how to compile a program
00:19:54 <jle`> how to download a compiler, etc.
00:20:15 <yayfoxes> well, I understand how to compile programs, how to do recursive functions
00:20:17 <yayfoxes> all tat
00:20:18 <jle`> i doubt there'll be a really good guide that supplants just having someone walk them through getting used to programming
00:20:19 <yayfoxes> that
00:20:34 <jle`> ah, well in that case you might want to look at "learn you a haskell", or 
00:20:34 <edwardk> yayfoxes: have you picked up a copy (online or in print) of learn you a haskell?
00:20:40 <jle`> @where learnhaskell
00:20:40 <lambdabot> https://github.com/bitemyapp/learnhaskell
00:20:42 <yayfoxes> edwardk: no sir
00:20:49 <edwardk> that is my usualy suggestion for where to start when you're coming in cold
00:21:23 <jle`> it looks like, if you're talking about yourself, lyah might be a good place for your level
00:21:27 <yayfoxes> edwardk: ok, how do you write 99 bottles of beer in Hasell?
00:21:33 <yayfoxes> Haskell*? I did it in java
00:21:34 <edwardk> http://www.quora.com/Reviews-of-Learn-You-a-Haskell-2011-book?share=1 <- may be a good reference
00:21:46 <edwardk> in terms of where to find other books and the like
00:21:55 <jle`> > map (++ " bottles of beer") [99,98..]
00:21:56 <lambdabot>      No instance for (Enum [Char])
00:21:56 <lambdabot>        arising from the arithmetic sequence ‚Äò99, 98 .. ‚Äô
00:21:56 <lambdabot>      In the second argument of ‚Äòmap‚Äô, namely ‚Äò[99, 98 .. ]‚Äô
00:22:07 <jle`> darn
00:22:19 <jle`> > map (\i -> show i ++ " bottles of beer") [99,98..]
00:22:21 <lambdabot>  ["99 bottles of beer","98 bottles of beer","97 bottles of beer","96 bottles ...
00:22:47 <jle`> > [ show i ++ " bottles of beer" | i <- [99,98..] ]
00:22:49 <lambdabot>  ["99 bottles of beer","98 bottles of beer","97 bottles of beer","96 bottles ...
00:23:02 <edwardk> https://www.irccloud.com/pastebin/MUOEqX2W/
00:23:20 <edwardk> had that lying around somewhere. not my code
00:23:31 <Zemyla> I only just noticed that there is a monad instance for Cokleisli w a, but no Monad instance for Kleisli m a.
00:23:51 <yayfoxes> lambdabot: so that \i is actually a lambda?
00:24:01 <jle`> yeah, the \ is supposed to look like a lambda
00:24:02 <yayfoxes> a function that has no name?
00:24:04 <Zemyla> When Kleisli m a b = ReaderT a m b.
00:24:06 <edwardk> Zemyla: The Kleisli one is the same as ReaderT
00:24:20 <jle`> like the greek letter lambda, that is
00:24:24 <yayfoxes> see I'm smart with computers but have never really sat down to code
00:24:28 <jle`> (\i -> ...) is called an anonymous function in other languages
00:24:28 <yayfoxes> I learned a lot
00:24:34 <jle`> sometimes they call it lambda, proc, etc.
00:24:39 <yayfoxes> but, nothing to show for it
00:24:46 <jle`> no worries :)
00:25:05 <jle`> your case is pretty common
00:25:13 <edwardk> Zemyla: you can put together a libraries proposal to add the instance of Monad, MonadFix, etc. to (Kleisli m a), its a straightforward change, and has an unambiguous definition.
00:25:48 <adarqui> > map ((++ " bottles of bear") . show) [99,98..0]
00:25:50 <lambdabot>  ["99 bottles of bear","98 bottles of bear","97 bottles of bear","96 bottles ...
00:26:05 <dramforever> Hijiri: ping
00:26:13 <yayfoxes> jle`: well your function \i has a name of \i but it can only be used in one place
00:26:19 <jle`> adarqui: sacrificing readability to save two characters :)
00:26:30 <adarqui> jle`: is my motto!
00:26:36 <yayfoxes> not like you can call it repeatedly like a defined function
00:26:38 <jle`> it's the Haskell Way(tm)
00:26:40 <jle`> (just kidding)
00:26:54 <jle`> yayfoxes: yup, it's "anonymous" in the same way you'd do something like 1 + x
00:26:57 <jle`> the 1 there is anonymous
00:27:03 <edwardk> ok, going to go count sheep rather than beer bottles for a bit.
00:27:07 <jle`> if you had said y = 1, and then do y + z
00:27:09 <jle`> er, y + x
00:27:13 <dramforever> Hijiri: time out
00:27:17 <jle`> then you "named" the 1 as y, and you can use it in other places
00:27:30 <dramforever> edwardk: I found it, it's really like the comonad here: http://dlaing.org/cofun/posts/free_and_cofree.html
00:27:36 <jle`> in the case of an anonymous function, we didn't name it, so it's only used in one place.  same situation as the 1 in 1 + x
00:27:40 <dramforever> hmm....looks like he went to count sheeps
00:27:44 <Zemyla> adarqui: I can't imagine drinking a bottle of bear.
00:27:54 <adarqui> ya sounds nasty
00:28:06 <edwardk> dramforever: i've lost context, what is?
00:28:07 <yayfoxes> jle`: ok, but I have a cool thing: debian has libghc-gtk3-dev in it
00:28:10 <adarqui> i installed haskell-vim-now tonight.. too much fun
00:28:16 <yayfoxes> you can write GTK+3 apps in Haskell xD
00:28:21 <jle`> :D
00:28:41 <pharaun> i havenj't tried haskell+gtk
00:28:44 <edwardk> dramforever: ok the either e based moore machine
00:28:44 <dramforever> edwardk: data Foo b c a = Foo a (b -> Either c (Foo b c a))
00:28:50 <pharaun> been starting to wonder what the experience is like there
00:28:57 <edwardk> yeah, that is the same sort of cofree as the one i mentioned
00:29:02 <dramforever> edwardk: that free monad interpreter thing: http://dlaing.org/cofun/posts/free_and_cofree.html
00:29:21 <jle`> Zemyla: i feel like if you're using the Monad instance of Kleisli m a, you might be doing something wrong ;)
00:29:21 <yayfoxes> jle`: I know exactly what to write in GTK+3 if you want to ask
00:29:22 <dramforever> okay :)
00:29:28 <jle`> but i guess no harm in having it there
00:29:46 <Zemyla> jle`: Yeah. Having the instance isn't going to hurt anyone.
00:30:03 <jle`> in my mind this is the same thing as, say, writing a Monad instance for Sum
00:30:11 <jle`> you probably shouldn't be using the Monad instance for Sum
00:30:16 <jle`> but...you can write one >_>
00:30:22 <edwardk> on the other hand every so often it can be useful =)
00:30:24 <yayfoxes> jle`: you could write a window that's root-tail for Wayland
00:30:37 <edwardk> ok, going off to count those sheeps for real
00:31:04 <jle`> yayfoxes: sounds like it'd be fun :)
00:31:30 <yayfoxes> jle`: how do I ever write THIS in GTK+3 all in Haskell for all of us?: http://oldhome.schmorp.de/marc/root-tail.html
00:31:37 <jle`> @instance Monad Sum where return = Sum; Sum x >>= f = f x
00:31:37 <lambdabot> Maybe you meant: instances instances-importing
00:31:43 <jle`> @let instance Monad Sum where return = Sum; Sum x >>= f = f x
00:31:44 <lambdabot>  .L.hs:163:10:
00:31:44 <lambdabot>      No instance for (Applicative Sum)
00:31:44 <lambdabot>        arising from the superclasses of an instance declaration
00:31:50 <jle`> curse you 7.10
00:32:52 <jle`> yayfoxes: i don't know enough about wayland or root to answer meaningfully ><
00:33:00 <jle`> or gtk3 for that matter :)
00:33:08 <yayfoxes> ok thanks anyways :)
00:34:05 <jle`> @let instance Applicative Sum where pure = Sum; Sum f <*> Sum x = Sum (f x); instance Monad Sum where return = Sum; Sum x >>= f = f x
00:34:05 <lambdabot>  Parse failed: Parse error: instance
00:34:07 <Axman6> how useful would that be as a monad? I feel not very
00:34:13 <jle`> @let instance Applicative Sum where pure = Sum; Sum f <*> Sum x = Sum (f x)
00:34:14 <lambdabot>  .L.hs:163:10:
00:34:14 <lambdabot>      No instance for (Functor Sum)
00:34:14 <lambdabot>        arising from the superclasses of an instance declaration
00:34:30 <Axman6> pretty sure it shouldn't even be a Functor
00:34:37 <jle`> yeah, that was my point, heh
00:34:49 <jle`> regarding a Monad instance for Kleisli m a
00:34:53 <Axman6> oh, heh. I just sat down =)
00:35:07 <edwardk> Axman6: personally i find monads/comonads, etc. for those sorts of things rather useful for putting on and taking off wrappers, etc.
00:35:30 <jle`> but we have `coerce`
00:35:32 <edwardk> Axman6: i can see why others may find it weird, but when its the only possible instance? meh, i write it and then figure out what it means
00:35:32 <jle`> ;D
00:35:43 <Axman6> I guess the important part is the monoid instance, which constrains the wrapped type
00:35:50 <yayfoxes> jle`: ok, do you want to learn a little Wayland to make a OpenGL powered window manager for it?
00:36:09 <jle`> yayfoxes: maybe another day ^_^
00:36:34 <edwardk> jle`: people like to trot out the argument 'hey you don't need this other way to do this thing because for this one special case you can always do it through this baroque encoding' -- that argument never really satisfies me. because its saying 'hey just remember this arcane rule i made up!'
00:37:07 <edwardk> on the other hand if there is only one instance possible for a thing then i can reason through it and not get stuck, not get dropped into orphan instance hell and whatever i go to write just works
00:37:29 <edwardk> so i find that argument a lot more convincing than the 'hey if you need this then you're doing something wrong' argument =)
00:37:47 <jle`> to me i think it's a matter of "gently" enforcing idioms
00:38:03 <jle`> gently aka with a large stick
00:38:12 <edwardk> to me its a matter of crippling the language so that your idiom becomes something that i always have to remember
00:38:29 <Zemyla> Should (Eq (Sum a)) require both Eq a and Num a?
00:38:35 <edwardk> i don't want to remember made up rules. i have enough interesting ones
00:38:39 <edwardk> Zemyla: no
00:38:40 <Zemyla> Probably not, that's just added complexity.
00:38:50 <edwardk> we should not require instances that aren't actually used in the instance.
00:39:05 <edwardk> bcause its making the compiler write slower code
00:39:12 <jle`> unless we need them for the laws
00:39:18 <edwardk> 'hey please pass me a dictionary so i can throw it away'
00:39:19 <edwardk> sure
00:39:23 <edwardk> there i'm okay with it =)
00:39:31 <yayfoxes> jle`: I believe that Wayland is like pizza while Xorg is like puke
00:39:32 <jle`> does the compiler not optimize things like that?
00:39:40 <edwardk> jle, basically? no
00:39:50 <Zemyla> Oh, edwardk, question about the Free library.
00:39:51 <jle`> yayfoxes: have you tried xmonad? it's a window manager written in haskell, i think
00:39:58 <Zemyla> Well, the Cofree, specifically.
00:40:00 <edwardk> jle: you may get lucky and it'll inline for something small but my experience is it just doesn't happen when you want it to
00:40:11 <yayfoxes> jle`: have, but didn't learn how to configure it yet
00:40:27 <ttt_fff> for people who have used erlang, how ready is cloud haskell?
00:40:28 <jle`> edwardk: but we have so many cases of only-requiring-for-laws in base
00:40:40 <ttt_fff> I really don't like the idea of having ot use both cloud haskell and erlang
00:40:52 <Zemyla> Wouldn't it be easier if the Eq, Ord, Read, and Show instances for Cofree used Eq1 f, Ord1 f, etc. instead of Eq (f (Cofree f a))?
00:41:33 <edwardk> Zemyla: perhaps. it breaks a shit ton of code though
00:41:40 <ttt_fff> in addition to #haskell-blah and #haskell-beginners, I think we need also to have #haskell-for-ppl-with-category-theory-phds
00:41:49 <edwardk> Zemyla: Eq1, Ord1, etc. are a lot less commonly implemented
00:41:50 <Zemyla> True. Legacy stuff :<
00:42:14 <Zemyla> And really, who uses Haskell98 anymore?
00:42:16 <edwardk> Zemyla: well, its requiring folks to use new transformers or transformers-compat, and to write 4 new instances for all their code
00:42:26 <adarqui> ttt_fff, i think there's a 'more mathy/advanced haskell chan', i forget what it is though
00:42:36 <Zemyla> {-# LANGUAGE GimmeEverything #-}
00:42:43 <jle`> edwardk: also maybe sometimes an interface/api for a type suggests a way to use a type.  for example, we might have a function intToError :: Int -> a; intToError x = error "why did you think this was a good idea?".  if it's a part of the official API for int, i think people might be confused as to why it's there...maybe wonder why it's useful...or think maybe they might be using Int wrong if they can't
00:42:45 <jle`> understand why it's there
00:42:47 <edwardk> and for that matter since transformers stole the Eq1, etc. classes from prelude-extras i haven;t made all my code there switch over
00:43:00 <edwardk> i just got ros to change the style of those instances to allow you to work without functor constraints on many of them
00:43:10 <Axman6> ttt_fff: #haskell-in-depth 
00:43:14 <ttt_fff> what's 'ros' ?
00:43:17 <jle`> having functions that are an API to your type laying around that you can't consider any possible usage for sounds like it might be confusing
00:43:25 <edwardk> and so i'm just not changing anything else over to use them until that style has wide enough distribution that i can use them without crippling my code.
00:43:28 <raichoo> Axman6: Souds good, does that even exist?
00:43:32 <raichoo> Sounds that is
00:43:35 <Axman6> yes
00:43:36 <ttt_fff> adarqui , Axman6: thanks
00:44:16 <adarqui> np, gn!
00:44:26 <Zemyla> Now I'm wondering if there's any point to making the Eq1 instances for Compose not require Functor, using dictionaries and unsafeCoerce. :V
00:44:27 <edwardk> jle: i understand the argument, but i find it to be less useful than writing all the instances. the process of writing the instances for a type and putting down everything that passes the laws tells me a _lot_ about it.
00:44:49 <edwardk> Zemyla: that has already been done in transformers head
00:45:03 <edwardk> Zemyla: (not with dictionaries)
00:45:07 <edwardk> Zemyla: that is a bad bad idea
00:45:11 <Zemyla> Transformers head? Like the Headmasters?
00:45:15 <edwardk> Zemyla: because it can yield unsafeCoerce
00:45:22 <jle`> he means optimus prime
00:46:00 <edwardk> in head: http://hub.darcs.net/ross/transformers/browse/Data/Functor/Classes.hs#79 -- they are all in the eqWith, compareWith, etc. style that i use in my other code
00:46:11 <edwardk> this lets us avoid the Functor constraints
00:46:21 <edwardk> but comes at a price.
00:46:35 <edwardk> it means that transformers-compat won't be able to bridge that gap functionality wise
00:46:39 <edwardk> because the members of the class changed
00:46:53 <edwardk> so it pretty much renders all those classes dead to me for 3 years
00:47:06 <Zemyla> How does giving a dictionary (Show1 f, Show a) => Dict (Show (f a)) lead to unsafeCoerce?
00:47:16 <edwardk> Zemyla: because 'f' may be a GADT
00:47:32 <edwardk> and (Show1 f, Show a) => Dict (Show (f a)) can lead to lose of confluence
00:48:01 <Axman6> Atlassian will be devistated
00:48:05 <edwardk> for that one you don't get unsafeCoerce, but you do get incoherent instance resolution
00:48:12 <frerich> Axman6: Just thought the same thing.
00:48:17 <Axman6> =)
00:48:31 <edwardk> on the other hand other cases lead to unsafeCoerce where you cast the member inside to get the instance you want
00:49:28 <edwardk> effectively you have no proof that the argument is representational
00:52:06 <lpaste_> obfuscatr pasted ‚Äúwhich is better?‚Äù at http://lpaste.net/135275
00:52:09 <Zemyla> Actually, edwardk, I know the real solution.
00:52:49 <Zemyla> Show1 should have a method showDict1 :: (Show a) :- (Show (f a)).
00:53:12 <edwardk> Zemyla: yes it should, but that will never happen inside of transformers
00:53:18 <Zemyla> True.
00:53:27 <edwardk> in 'constraints' i have such a class
00:54:05 <edwardk> https://github.com/ekmett/constraints/blob/master/src/Data/Constraint/Lifting.hs#L55
00:54:14 <edwardk> class Lifting p f where  lifting :: p a :- p (f a)
00:54:20 <edwardk> instance Lifting Show [] where lifting = Sub Dict
00:54:29 <edwardk> is a general purpose version of this concept
00:54:38 <edwardk> Lifting Show, Lifting Eq, Lifting Ord, Lifting Monad, etc.
00:55:09 <edwardk> i've started using that model in new code that can incur a full constraints dependency
00:55:18 <edwardk> i should ship that to hackage at some point
00:55:39 <edwardk> it also works for things like monad transformer classes
00:56:10 <edwardk> instance Lifting (MonadReader r) MaybeT where lifting = Sub Dict
00:56:30 <edwardk> instance Monoid w => Lifting (MonadState s) (Strict.WriterT w) where lifting = Sub Dict
00:57:01 <edwardk> of course this prompts a tedious amount of repetition =)
01:00:59 <Zemyla> edwardk: Shame you can't use defaults to just say "lifting = Sub Dict" for all of them, but if you could do that, there'd be no need for lifting.
01:01:31 <Zemyla> Anyways, sleep well.
01:02:51 <edwardk> Zemyla: for that to work i'd have to have a cartesian closed category of constraints.
01:03:11 <edwardk> while i construct one in Hask, it is a second class citizen you have to manipulate manually, ghc isnt smart enough to exploit it
01:04:14 <Hi-Angel> Have anybody an idea, how could be used such a function? ´insertAtCursor :: TextViewClass self => Signal self (String -> IO ())ª It supposed to insert a text in text widget, butÖ It doesn't accept a text and a text widget, but rather something strange ><
01:04:18 <Zemyla> You can't sleep well until you have constraints in a CCC?
01:05:20 <edwardk> Zemyla: yep
01:05:38 <Zemyla> Shame.
01:09:51 * mniip wonders what :- is
01:11:14 <mmercer> hum, I accidentally installed some packages globally (I forgot to type cabal sandbox init first). how do I undo that?
01:11:20 <mniip> oh
01:11:25 <rbocquet> mniip: https://hackage.haskell.org/package/constraints-0.4.1.3/docs/Data-Constraint.html
01:11:31 <mniip> found it yes
01:12:02 <obfuscatr> is there a sensible way to treat a Word as a list, so that I can do bitwise operations on each bit, then compile the list of bits back to a Word?
01:13:24 <mmercer> ill just ghc-pkg unregister be enough?
01:13:33 <mmercer> will
01:14:19 <dramforever> wtf...
01:14:46 * dramforever is reading about the algebra (and calculus!) of algebraic data types
01:15:17 <Phillemann> With stack, how do I configure cabal flags?
01:15:29 <dramforever> those taylor expansions are blowing my minds
01:15:44 <mniip> random notice: https://hackage.haskell.org/package/constraints-0.4.1.3/docs/src/Data-Constraint.html#line-93
01:15:48 <mniip> shouldn't that quote be closed
01:16:09 <Phillemann> Ah, stack build --flag
01:18:01 <edwardk> mniip: yep, patch
01:18:31 <dramforever> these typos appear all the time
01:18:55 <mniip> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-IO-Exception.html#line-326
01:19:09 <mniip> I wonder what "ultra-precise!" means next to this typo
01:19:20 <mniip> (there's a typo in "unsatisfied")
01:25:18 <mniip> instance (b :=> a) => () :=> b :=> a where ins = Sub Dict
01:25:20 <mniip> whaaaaa
01:26:13 <dramforever> ???
01:26:25 <mniip> well it kind of makes sense
01:26:31 <dramforever> what?? why not instance () :=> a where ...
01:26:38 <dramforever> more general
01:26:46 <mniip> (a |- b) |- (|- a => b)
01:27:20 <edwardk> mniip: https://ghc.haskell.org/trac/ghc/ticket/10575
01:27:40 <mniip> heh
01:28:02 <funfunctor> How can I fix this parser http://lpaste.net/135278  up so that I end up with a Either branch?
01:28:04 <mniip> edwardk, the fact that there's "ultra-precise!" next to it makes me wonder if that's the way it should be
01:28:48 * hackagebot aws-dynamodb-conduit 0.1.0.6 - Conduit-based interface for AWS DynamoDB  http://hackage.haskell.org/package/aws-dynamodb-conduit-0.1.0.6 (srijs)
01:28:50 <funfunctor> not sure its some combo of (.:?) and (<|>)
01:28:54 <edwardk> (b :=> a) => () :=> b :=> a      is just saying that if b :=> a, then the empty context gives that fact. this is part of how we bootstrap the reasoning about Class and (:=>) from Class and (:=>)
01:29:18 <mniip> well yes
01:29:27 <edwardk> its needed so that if you look at the lifting several times over of a constraint its always defined
01:29:36 <mniip> it is just somewhat confusing given the fixity of :=> is not apparent
01:29:53 <edwardk> mniip: it matches ->
01:29:59 <edwardk> and i don't like needless parens =)
01:30:23 <mniip> and what is the fixity of => ?
01:30:31 <edwardk> same
01:30:43 <mniip> ah right
01:30:56 <mmercer> why is findWindow in Graphics.Win32 of "String -> String -> IO (Maybe HWND)" type and not "Maybe String -> Maybe String -> IO (Maybe HWND)"? It doesn't expose full functionality of the function it wraps
01:31:08 <edwardk> those instances were fun to figure out
01:31:54 <edwardk> they date back to the initial articles i wrote on constraints
01:32:08 <edwardk> http://comonad.com/reader/2011/what-constraints-entail-part-1/ http://comonad.com/reader/2011/what-constraints-entail-part-2/ -- part 2 defines them
01:32:09 <mmercer> you can't do this: FindWindow(Null, "Calculator")  for example
01:32:18 <mniip> unsafeCoerceConstraint :: a :- b 
01:32:35 <mniip> does that mean we can make the typecheker assume arbitrary facts about instances?
01:32:53 <edwardk> mniip: it lets you cast a dictionary for one thing into something for another
01:33:34 <edwardk> unsafeApplicative m = m \\ trans (unsafeCoerceConstraint :: Applicative (WrappedMonad m) :- Applicative m) ins
01:33:48 <edwardk> used to steal the applicative for "WrappedMonad m" and make one for m
01:34:51 <edwardk> ins would go Monad m :- Applicative (WrappedMonad m), so that whole composition is Monad m :- Applicative m -- even though that wasn't sound when it was written
01:35:48 <mniip> so basically
01:36:06 <mniip> it gives you Applicative where pure=return and <*>=ap
01:36:25 <obfuscatr> am I right in thinking that there if I do: "v <- someMonad; doSomething v"  .. that it's not allowed to combine this into a single line like "doSomething (<- monad)" .. becuase monads?
01:36:54 <edwardk> yep
01:36:56 <mniip> obfuscatr, <- is syntactic sugar for >>=
01:37:18 <mniip> 'do v <- someMonad; doSomething v' desugars to 'someMonad >>= \v -> doSomething v'
01:37:26 <mniip> which you can eta-reduce to someMonad >>= doSomething
01:37:30 <mmercer> what does "doSomething (<- monad)" mean?
01:38:21 <dagwil> @funfunctor are you saying you want data Element = Element (Either String (Distance,Duration))?
01:38:21 <lambdabot> Unknown command, try @list
01:38:32 <Turion> Why is one of the arrow laws (https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/Control-Arrow.html#v:first) this here: "first (arr f) = arr (first f)"? It doesn't make sense to apply first to a function, right?
01:38:42 <quchen2> mmercer: It's a syntax error to write that.
01:39:10 <mniip> Turion, -> is an arrow
01:39:13 <lyxia> Turion: It does, with a = (->), a b c = b -> c
01:39:15 <funfunctor> dagwil: I think it comes out as data Element = Element (Either String (Distance Duration String))
01:39:16 <mniip> it makes perfect sense
01:39:27 <obfuscatr> mmercer i was saying i don't know the syntax to get the value of a monad without using <- to assign it to something first.
01:39:29 <funfunctor> dagwil: see the two cases
01:39:57 <dagwil> funfunctor: oh yeah. I just wanted to check, the comment on line 8 confused me.
01:40:04 <funfunctor> :t asum
01:40:05 <lambdabot>     Not in scope: ‚Äòasum‚Äô
01:40:05 <lambdabot>     Perhaps you meant one of these:
01:40:05 <lambdabot>       ‚ÄòF.asum‚Äô (imported from Data.Foldable),
01:40:10 <Turion> mniip, lyxia, ohhhhh, yes of course! thanks
01:40:13 <funfunctor> :t F.asum
01:40:14 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
01:40:25 <mniip> edwardk, oh I think I see it now
01:40:35 <funfunctor> dagwil: not sure if asum is useful here?
01:40:51 <mniip> newtypes are represented the same way as the, uh, underlying types
01:41:16 <mniip> so pure :: a -> WrappedMonad m a, can be coerced to a -> m a
01:41:37 <dagwil> funfunctor: Just me, but I'd probably do data Element = Element Distance Duration String
01:41:56 <funfunctor> dagwil: yea but what about the case of failure?
01:41:57 <dagwil> funfunctor: then do type Element' = Either String Element
01:42:11 <funfunctor> eh?
01:42:31 <funfunctor> How is that going to help?
01:42:50 <dagwil> funfunctor: I don't think that solves your original problem, it's jsut how I'd structure it, instead of a 3-tuple for the right case of the either
01:42:55 <funfunctor> There are two possible parse paths so the Either type encapsulates that idea
01:43:06 <mmercer> obfuscatr: ah ok. you can use lambdabot's @undo functionality to see how do is desugared 
01:43:13 <mmercer> @undo do v <- someMonad; doSomething v
01:43:13 <lambdabot> someMonad >>= \ v -> doSomething v
01:43:46 <funfunctor> dagwil: assuming my typing, how do I get the parser do inhabit that?
01:44:45 <dagwil> funfunctor: hang on, I'll bring up the docs. This is for aeson, right?
01:45:17 <mmercer> can you combine @undo with @pl?
01:45:33 <funfunctor> dagwil: yep
01:45:42 <funfunctor> dagwil: http://artyom.me/aeson#more-interesting-choices
01:45:43 <pavonia> @@ @pl @undo do v <- someMonad; doSomething v
01:45:44 <lambdabot>  doSomething =<< someMonad
01:46:36 <obfuscatr> so if I have a monad m of type IO Float, and d x = x * 2, why can't I:  m >> d, or m >>= \v -> d v   ? 
01:46:57 <funfunctor> dagwil: actually the syntax for that Either type isn't quite right
01:47:09 <Axman6> obfuscatr: because d doesn't have type a -> m b
01:47:30 <Axman6> it has type a -> b (or Float -> Float in this case)
01:48:03 <Axman6> obfuscatr: you can use Functor to do what you want though: fmap d m
01:48:06 <Axman6> :t fmap
01:48:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:48:37 <mmercer> obfuscatr  m >>= \v -> return (d v)  would match the types, which is the same as fmap d m
01:48:55 <Axman6> :t fmap `asType` (undefined :: (Float -> Float) -> IO Float -> IO Float)
01:48:56 <lambdabot>     Not in scope: ‚ÄòasType‚Äô
01:48:56 <lambdabot>     Perhaps you meant one of these:
01:48:56 <lambdabot>       ‚ÄòasTypeOf‚Äô (imported from Prelude), ‚ÄòasTypeIn‚Äô (line 165)
01:49:04 <Axman6> :t fmap `asTypeOf` (undefined :: (Float -> Float) -> IO Float -> IO Float)
01:49:06 <lambdabot> (Float -> Float) -> IO Float -> IO Float
01:49:13 <funfunctor> dagwil: perhaps    data Element = Element ¬†¬†Distance Duration String | NoElement String deriving Show
01:49:14 <funfunctor>    
01:50:03 <dagwil> funfunctor: yes and then you can do a match in the praseJSON definition
01:50:08 <mniip> Axman6, you don't need an asTypeOf when you're doing a :: cast
01:50:21 <funfunctor> dagwil: yea! maybe that is the key
01:50:35 <Axman6> mniip: yeah I realised that too late =)
01:50:37 <dagwil> funfunctor: however it'd be cleaner to use an either type I feel. You could still do that with a match
01:51:01 <Axman6> :t asTypeIn
01:51:02 <lambdabot> a -> (a -> b) -> a
01:51:25 <funfunctor> dagwil: how?
01:51:35 <dagwil> funfunctor: but it :: Either String Element is nicer than it :: Element with Element = Element ¬†¬†Distance Duration String | NoElement String
01:51:58 <funfunctor> dagwil: can you show me what you have in mind?
01:53:44 <mmercer> > fmap (++"!") getLine
01:53:46 <lambdabot>  <IO [Char]>
01:54:54 <dagwil> funfunctor: So it doesn't change things much, it's more of a stylistic thing.
01:55:23 <dagwil> funfunctor: you could go with the   data Element = Element ¬†¬†Distance Duration String | NoElement String and use a case statement
01:55:26 <mmercer> it would be cool if > getLine waited for someone to say something in the channel
01:55:48 <funfunctor> dagwil: can you see anything wrong here? http://lpaste.net/135280
01:55:54 <dagwil> funfunctor: but using Either communicates the intent a little better. You can also reuse functions that work with Eithers
01:56:22 <funfunctor> dagwil: yea but I am not sure how to rewrite that with Either?
01:57:11 <dagwil> funfunctor: Prelude Data.Aeson> data E = E (Either String Element)
01:57:11 <dagwil> Prelude Data.Aeson> :{
01:57:11 <dagwil> Prelude Data.Aeson| instance FromJSON E where
01:57:11 <dagwil> Prelude Data.Aeson|   parseJSON = undefined
01:57:11 <dagwil> Prelude Data.Aeson| :}
01:57:11 <dagwil>  
01:57:34 <dagwil> funfunctor: but call E something which makes sense for your app
01:58:02 <funfunctor> sure of course, but I mean the parseJSON instance I am having trouble with..
01:58:51 <dagwil> funfunctor: but maybe this is just complicating things. Going back to the lpaste you just linked I'm not sure that'll work. Just a sec
01:59:25 <dagwil> funfunctor: check this out http://stackoverflow.com/a/6827265/1421366
02:00:10 <dagwil> In what you just linked it won't ever get to the second case with Element <$> ... because the first one on line 6 will also succeed instead
02:01:00 <dagwil> funfunctor: in the SO answer I linked the guy does a test to make sure what values exist
02:01:03 <funfunctor> dagwil: yea they overlap
02:01:27 <funfunctor> dagwil: but I am going with the Either
02:02:54 <funfunctor> dagwil: so I am not sure how to deal with that in the parseJSON instance?
02:03:35 <dagwil> funfunctor: you'll want to test if the distance and duration keys exist in the parseJSON instance
02:03:49 <dagwil> funfunctor: so in the SO listed they turn the object into a map
02:04:09 <funfunctor> dagwil: but can't I just pattern match?
02:04:57 <dagwil> funfunctor: Maybe, I forget what values the aeson object can deconstruct into
02:05:27 <funfunctor> dagwil: it says at the top half of the page here http://artyom.me/aeson#more-interesting-choices
02:05:48 <funfunctor> dagwil: http://artyom.me/aeson#fromjson-instances-for-other-types
02:06:32 <mmercer> .
02:07:24 <yayfoxes> is there any way to have a list with elements of differing types?
02:08:42 <nathan7> Hi! I'm having some trouble turning my newtype into a monad: http://lpaste.net/5734451595576344576
02:08:50 * hackagebot cblrepo 0.17.1 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.17.1 (MagnusTherning)
02:09:04 <nathan7> Specifically, I can't figure out how to specify the type in the instance declaration in a way that pleases GHC
02:10:00 <rbocquet> nathan7: this is a type synonym, you can't declare instances for it
02:10:26 <rbocquet> ant it is already a monad
02:10:31 <rbocquet> *and
02:10:43 <nathan7> oh, right, functions are monads
02:11:10 <dagwil> funfunctor: like this http://lpaste.net/135280
02:11:38 <nathan7> I was hoping to make this transparent for any function that's already `AuthToken -> IO a`
02:11:42 <nathan7> guess that one's out then
02:11:58 <dagwil> funfunctor: So represent failure with the Either type. check for both duration and distance in the object then if it exists do case 1, otherwise case 2
02:12:27 <funfunctor> dagwil: looks too complicated
02:12:28 <rbocquet> nathan7: you can also do newtype AuthedIO a = AuthedIO { runAuthedIO :: AuthToken -> IO a } deriving (Functor, Applicative, Monad)
02:12:44 <funfunctor> I'm _sure_ it can be done with a mix of applicative things dagwil
02:13:18 <funfunctor> like (.:?) (.!=) and so on
02:14:11 <funfunctor> (.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a) 
02:14:13 <nathan7>       ‚ÄòApplicative‚Äô is not a derivable class
02:14:14 <nathan7> :(
02:14:39 <nathan7> I'm guessing I need -XDerivable*something*
02:14:44 <funfunctor> nathan7: try making your data type derived from Generic
02:14:55 <funfunctor> GHC.Generic
02:15:34 <nathan7> funfunctor: I can't seem to import Generic
02:15:35 <funfunctor> nathan -XDerivedGeneric
02:15:46 <funfunctor> nathan7: GHC.Generic
02:15:55 <funfunctor> @hoogle Generic
02:15:55 <lambdabot> Data.Text.Lazy.Builder.RealFloat Generic :: FPFormat
02:15:56 <lambdabot> Data.Generics.Aliases type Generic c = forall a. Data a => a -> c a
02:15:56 <lambdabot> Data.Generics module Data.Generics
02:16:02 <funfunctor> ah hmm
02:16:33 <indiagreen> funfunctor: I'm late to the party, but what about writing a FromJSON instance for Element and then the instance for Result would simply be (Result . Right <$> parseJSON) <|> (Result . Left <$> o .: "status") or something?
02:16:55 <indiagreen> (or have I understood everything wrongly?)
02:17:00 <nathan7> GHC.Generics, apparently
02:17:37 <funfunctor> indiagreen: that sounds right
02:18:24 <dagwil> funfunctor: http://lpaste.net/135280 ?
02:18:40 <nathan7> funfunctor: seems I can derive functor easily, but Monad and Applicative plainly refuse
02:18:46 <nathan7> *Functor
02:19:33 <dagwil> indiagreen: I think that's the right idea
02:20:07 <nathan7> seems GeneralizedNewtypeDeriving isn't the thing either
02:20:41 <rbocquet> nathan7: you should need GeneralizedNewtypeDeriving
02:22:46 <Phillemann> Is there a shorthand for "maybe (return ()) someAction"?
02:22:55 <nathan7> Can't make a derived instance of ‚ÄòApplicative AuthedIO‚Äô (even with cunning newtype deriving):
02:23:10 <rbocquet> nathan7: seems you need to replace AuthToken -> IO a with ReaderT AuthToken IO a
02:23:14 <Phillemann> (Or something less ugly)
02:23:34 <indiagreen> Phillemann: I think it's for_
02:24:21 <Axman6> nathan7: any reason you're not using ReaderT?
02:24:24 <indiagreen> for_ :: Maybe a -> (a -> m b) -> m ()  -- specialised type
02:24:33 <funfunctor> dagwil: that does not even type check
02:24:34 <Axman6> :t for_
02:24:35 <lambdabot>     Not in scope: ‚Äòfor_‚Äô
02:24:35 <lambdabot>     Perhaps you meant one of these:
02:24:35 <lambdabot>       ‚ÄòF.for_‚Äô (imported from Data.Foldable),
02:24:40 <Axman6> :t F.for_
02:24:41 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
02:25:35 <nathan7> rbocquet: the ReaderT from mtl?
02:25:39 <indiagreen> there were attempts to get this exact function under a more discoverable name ‚Äì whenJust ‚Äì but they failed
02:25:40 <Phillemann> indiagreen: Yep, that works, thanks :)
02:25:48 <dagwil> funfunctor: no I didn't try and run it but it's the same kind of idea as what indiagreen suggested: Result . Right <$> parseJSON) <|> (Result . Left <$> o .: "status")
02:25:57 <rbocquet> nathan7: tes
02:26:00 <rbocquet> yes
02:26:02 <nathan7> Sweet, this works
02:26:45 <nathan7> seems I don't even need to deal with Generic
02:26:55 <Axman6> nope
02:27:26 <nathan7> http://lpaste.net/7787766805711290368 perfectly working minimal example ‚Äî thanks!
02:30:17 <dagwil> funfunfctor: I think I used $ instead of <$>, I'll see if I can get it to typecheck
02:31:50 <nathan7> Is there some kind of generic (a, b) -> c -> (a, b, c)?
02:33:02 <nathan7> rbocquet: Now with ReaderT, is there any real reason for me to still use a newtype for this?
02:33:13 <nathan7> rbocquet: As far as I can tell, I might as well use a type synonym again
02:34:20 <indiagreen> nathan7: there isn't a generic cons for tuples in base
02:34:39 <nathan7> indiagreen: anywhere outside?
02:36:54 <rbocquet> nathan7: it depends on the usage, a newtype is mainly useful if most monadic operations you use are not the base operations from the transformers in the stack
02:37:19 <ttt_fff> OMG kdb+/q is awesome ... is there anyway to get the terseness of K but in Haskell, via Template Haskell ?
02:38:28 <rbocquet> nathan7: with a newtype you get something more opaque
02:38:48 <nathan7> rbocquet: Yeah, that's not really necessary here
02:38:54 <nathan7> type synonym it is
02:39:11 <nathan7> and I can eta-reduce it to just `type AuthedIO = ReaderT AuthToken IO`
02:39:13 <nathan7> that's almost English
02:39:20 <nathan7> "an Authed IO action is an IO action that has an AuthToken as context"
02:39:41 <yayfoxes> ok, what's a simple programming exercise for the beginning programmer new to Haskell?
02:39:51 <dagwil> funfunctor: I think this does what you want http://lpaste.net/135284
02:40:06 <dagwil> funfunctor: it's much nicer than the map lookup way
02:40:58 <funfunctor> dagwil: this is what I wrote http://lpaste.net/135285
02:41:48 <yayfoxes> I want to know how you guys learned programming
02:42:15 <yayfoxes> if there's anything I'm not doing to learn programming would you help if I could show I'm dedicated?
02:42:30 <dramforever> yayfoxes: I first learnt in high school
02:42:32 <dramforever> it was c++
02:42:42 <dramforever> wait wait, maybe move to #haskell-blah?
02:42:49 <dagwil> yayfoxes: It helps to have a use for it. Do you have any hobbies that programming could be applied to?
02:43:00 <yayfoxes> dagwil: operating systems and video games
02:43:13 <yayfoxes> I like to play with Linux distros
02:43:21 <dramforever> If you love playing simple games you can make some
02:43:25 <yayfoxes> if my Linux had its own package manager in haskell
02:43:28 <dagwil> whatanerd
02:43:40 <dramforever> is nix written in haskell?
02:43:52 <dramforever> nix the package manage
02:43:53 <yayfoxes> no, wanna make a Unix runtime for GNU Hurd in Haskell?
02:43:55 <dramforever> *manager
02:44:11 <dramforever> yayfoxes: wanna make a better cabal?
02:44:17 <yayfoxes> the Unix subystems are in Haskell
02:44:30 <yayfoxes> dramforever: sure, as long as it integrates nicely with Linux
02:44:34 <dagwil> funfunctor: that works, right?
02:44:43 <dramforever> yayfoxes: well, you know what's cabal?
02:44:45 <funfunctor> dagwil: no
02:44:53 <mniip> edwardk, do you know of a way to use forall with type families or typeclasses?
02:45:03 <yayfoxes> dramforever: a little Haskell software manager
02:45:06 <funfunctor> dagwil: because the first parser fails due to type mismatch
02:45:16 <mniip> I mean I want a type family to result in a forall'd type
02:45:22 <yayfoxes> for Haskell libraries to be installed in your home directory or /usr/local/
02:45:23 <dramforever> yayfoxes: yes, and it certainly integrates nicely with Linux
02:45:27 <funfunctor> dagwil: so I need to use the weaker .:? or something
02:45:29 <dramforever> exactly
02:45:40 <dramforever> yayfoxes: we all want to make it better
02:45:54 <yayfoxes> dramforever: can I make it make debian packages?
02:46:00 <dramforever> no not that
02:46:18 <yayfoxes> but then what?
02:46:19 <dramforever> fix cabal hell The Right Way, i.e. fix cabal
02:46:33 <yayfoxes> but then, how?
02:46:45 * dcoutts agrees with dramforever 
02:46:46 <dramforever> that's the problem to solve
02:46:47 <yayfoxes> if you taught me Haskell by giving me help in what exercises I make
02:46:58 <dagwil> funfunctor: the first parser is the Element parser in this case?
02:47:01 <dramforever> yayfoxes: wait you are yet to learn haskell?
02:47:11 <mniip> edwardk, I was just thinking about generalising Lifting to a kind-polymorphic typeclass, but there's the issue that you need an arbitrary amount of polymorphic variables
02:47:13 <yayfoxes> dramforever: yes, I haven't learned haskell yet
02:47:17 <dramforever> hmm...
02:47:21 <dagwil> funfunctor: do you also have FromJSON isntances for Duration and Distance?
02:47:22 <funfunctor> dagwil: yes
02:47:27 <funfunctor> yes
02:47:29 <dramforever> okay I was talking about too big plans
02:47:30 <funfunctor> that all works
02:48:36 <dramforever> yayfoxes: so how are you planning to learn haskell?
02:48:46 <dagwil> dramforever: yayfoxes: rather than setting a noobie onto Haskells most formidable adversary wouldn't making a small game in something like http://helm-engine.org/ be less ambitious?
02:48:52 <yayfoxes> dramforever: by taking a ton of exercises head on
02:49:13 <dramforever> dagwil: I thought yayfoxes is looking for projects to do
02:49:26 <dramforever> I thought yayfoxes learnt a lot of haskell already
02:49:34 <dagwil> dramforever: Oh, my mistake.
02:49:38 <yayfoxes> dramforever: I didn't *sigh*
02:49:54 <yayfoxes> I must have been lying something fierce if I said that
02:49:57 * dramforever is a bit confused
02:50:06 <dagwil> lol
02:50:20 <dagwil> cabal is maybe nto a noobie problem
02:51:35 <funfunctor> dagwil: it does not really work as intended
02:51:37 <dagwil> I suggest do some warm up exercises on something like project euler until you get bored, then maybe try and replace various shell programs with haskell implementations. e.g. write ls, wc and grep in haskell 
02:51:43 <funfunctor> really annoying
02:51:50 <funfunctor> I am going to call it a day
02:51:58 <funfunctor> thanks for the help dagwil !
02:52:17 <dagwil> funfunctor: sorry I couldn't get you there.
02:52:26 <mniip> dagwil, ls and grep are like the most advanced utilities
02:52:36 <funfunctor> its ok, applicative is a pain in the ass in practice
02:52:39 <mniip> try head, tail, cut
02:52:50 <mniip> cat
02:52:52 <dagwil> mniip: they don't have to be good or complete implementations
02:53:00 <mniip> well
02:53:00 <funfunctor> :t mouse
02:53:01 <lambdabot> Not in scope: ‚Äòmouse‚Äô
02:53:09 <funfunctor> we need that function some day
02:53:26 <yayfoxes> dagwil: I'm not very good in math
02:53:49 <mniip> funfunctor, what would it do
02:54:00 <yayfoxes> um...how would you check if something is a multiple of another number?
02:54:06 <hairyian> what is a good web scraping library
02:54:11 <funfunctor> mniip: higher order cat, a cat that eats cats?
02:54:19 <mniip> yayfoxes, you calculate the remainder from division, and check if it's 0
02:54:19 <yayfoxes> if you explained that I might be able to solve the problem
02:54:25 <yayfoxes> mniip: I thought so
02:55:05 <mniip> funfunctor, you mean
02:55:07 <mniip> (a -> a -> f a) -> (a -> a -> f a) -> f (a -> a -> f a)
02:56:02 <mniip> no, more like
02:56:15 <mniip> f (f a -> f a -> f a) -> f (f a -> f a -> f a) -> f (f a -> f a -> f a)
02:56:27 <dagwil> mniip: The elem part doesn't work but a super simple grep would similar to: let grep string filename = readFile filename >>= return . Prelude.filter (string `elem`) . Prelude.lines
02:56:52 <mniip> you mean, isInfixOf
02:56:58 <Geraldus> Hi friends!
02:57:26 <yayfoxes> mniip: wouldn't the solution to project euler problem 1 have something like this?:[ x <- [1..999], x % 3 == 0, x % 5 == 0 ]
02:57:31 <dagwil> mniip: that is exactly what I couldn't remember the name of
02:57:41 <mniip> yayfoxes, what's the problem
02:57:42 <yayfoxes> but I just don't understand how to write it
02:57:48 <yayfoxes> ...in Haskell
02:58:38 <yayfoxes> mniip: I want to say: all numbers from 1 up to and including 999 where x mod 3 is 0 and/or x mod 5 is 0
02:58:53 * hackagebot tuple-generic 0.1.0.0 - Generic operations on tuples  http://hackage.haskell.org/package/tuple-generic-0.1.0.0 (Artyom)
02:58:55 * hackagebot tuple-generic 0.2.0.0 - Generic operations on tuples  http://hackage.haskell.org/package/tuple-generic-0.2.0.0 (Artyom)
02:59:00 <indiagreen> nathan7: I somehow didn't find one so I wrote it
02:59:05 <mniip> yayfoxes, didn't the problem ask you to *count* those numbers
02:59:11 <mniip> as opposed to listing them
02:59:34 <mniip> ah
02:59:37 <mniip> it asks for a sum
02:59:38 <yayfoxes> it asks you to find the sum of
02:59:47 <dagwil> yayfoxes:  [ x | x <- [1..999], x `mod` 3 == 0, x `mod` 5 == 0 ]
02:59:50 <Geraldus_> Please tell me how can I search existing tickets on GHC track?
02:59:54 <dagwil> that's valid haskell
02:59:58 <Geraldus_> oh never mind
03:00:05 <Geraldus_> I've figured it out
03:00:16 <yayfoxes> dagwil: how do you do sum of all the elements in that list?
03:00:22 <mniip> yayfoxes, literally sum
03:00:22 <yayfoxes> WOW
03:00:24 <dagwil> :t sum
03:00:28 <lambdabot> (Num a, Foldable t) => t a -> a
03:00:32 <mniip> sum [...]
03:00:41 <yayfoxes> brain blast guys, um....just take that list and add all the elements up
03:00:44 <yayfoxes> real simple
03:02:33 <mniip> there's also a more efficient solution
03:03:27 <dagwil> yayfoxes: make sure you create an account so you can save your progress
03:03:32 <mniip> > let f d x = (x `div` d) * (x `div` d + 1) `div` 2 in f 3 1000 + f 5 1000 - f 15 1000
03:03:34 <lambdabot>  73500
03:03:43 <dagwil> and see other people discuss how infinitely better their mathematica solution is.
03:03:56 <mniip> oopsie
03:04:00 <mniip> > let f d x = (x `div` d) * (x `div` d + 1) `div` 2 * d in f 3 1000 + f 5 1000 - f 15 1000
03:04:02 <lambdabot>  234168
03:04:31 <mniip> except this one includes the number 1000
03:04:33 <aznashwan> :t otherwise
03:04:34 <lambdabot> Bool
03:04:59 <yayfoxes> would you guys compile this?
03:05:04 <yayfoxes> main = do
03:05:05 <yayfoxes>     putStrLn (sum [ x | x <- [1..999], x `mod` 3 == 0, x `mod` 5 == 0])
03:05:07 <indiagreen> nathan7: it currently only supports tuples with 2‚Äì5 elements, I'll add more in a moment
03:05:09 <yayfoxes> it won't compile
03:05:10 <ronh> > otherwise /= False
03:05:11 <lambdabot>  True
03:05:20 <mniip> yayfoxes, putStrLn takes a String
03:05:24 <mniip> sum returns a number
03:05:27 <dagwil> :t putStrLn
03:05:28 <lambdabot> String -> IO ()
03:05:28 <dagwil> :t print
03:05:30 <lambdabot> Show a => a -> IO ()
03:05:42 <yayfoxes> then how do I use the show function?
03:05:44 <yayfoxes> is it simple?
03:05:49 <dagwil> use print
03:05:58 <yayfoxes> WOW
03:05:58 <dagwil> basically print = putStrLn . show
03:06:02 <hairyian> > show 10
03:06:04 <lambdabot>  "10"
03:06:18 <mniip> yayfoxes, also, the solution dagwil gave is somewhat wrong
03:06:23 <hairyian> but yes use print
03:06:25 <dagwil> shit
03:06:29 <mniip> it finds numbers that are *both* divisible by 5 and 3
03:06:36 <mniip> you need to replace the comma with a ||
03:06:58 <dagwil> mniip: Technically that was yayfoxes 's solution that I merely translated to haskell 
03:09:00 <dagwil> anyway I g2g, hf 
03:09:21 <nathan7> indiagreen: cool
03:10:09 <yayfoxes> OH
03:10:17 <indiagreen> can anyone give me an example of a library that uses CPP to generate repetitive code?
03:10:23 <yayfoxes> how do I make it x `mod` 3 == 0 OR x `mod` 5 == 0?
03:10:44 <mniip> yayfoxes, I just explained above
03:11:57 <nathan7> indiagreen: CPP as in the C preprocessor?
03:12:02 <supki> indiagreen: monad-control, perhaps?
03:12:17 <yayfoxes> mniip: I solved the problem! I'm excited!
03:12:28 <mniip> "I"
03:12:30 <mniip> :P
03:12:30 <indiagreen> supki: yep, thanks!
03:12:48 <mmercer> why CPP and not template haskell?
03:13:37 <indiagreen> mmercer: because it's an abomination to use slow TH for a tiny tiny library with no dependencies
03:14:15 <yayfoxes> mniip: now, how would I implement fibonacci numbers in haskell?
03:14:19 <yayfoxes> I'll try here
03:14:24 <mmercer> it is abomination to use CPP for anything..
03:14:53 <mniip> yayfoxes, well the simplest way is to look at the actual definition of fibonacci numbers and translate it into haskell
03:15:04 <yayfoxes> mniip: ok
03:15:24 <Serpentine_> (which will also quite naturally lead to the function having a time complexity exponential to the input)
03:15:32 <mniip> ^
03:15:50 <padre_angolano> using #haskell as project euler solver :-)
03:16:17 <Serpentine_> I'm using Python's @functools.lru_cache() before my naive brute-force recursive function instead
03:16:44 <mniip> Serpentine_, you can achieve memoization via data sharing
03:17:05 <yayfoxes> padre_angolano: that's nothing, I'm working here
03:17:31 <mniip> > let fib = 1:1:zipWith (+) fib (tail fib) in fib
03:17:33 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:17:56 <mniip> computes in O(N)
03:19:20 <mniip> or you can recurse with two numbers
03:19:27 <Serpentine_> What would be the time complexity to access one element in fib if it was already computed before?
03:19:48 <mniip> O(N) still
03:20:32 <Serpentine_> That seems to be slightly inefficient
03:20:43 <mniip> > let fibStep 0 = (1, 1); fibStep n = let (x, y) = fibStep (n - 1) in (y, x + y) in map (fst . fibStep) [1..]
03:20:45 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
03:32:11 <gabre> hello
03:32:16 <ttt_fff> q)cut k){$[0h>@x;x*!-_-(#y)%x;x]_y}
03:32:25 <ttt_fff> q/k code looks like ascii art
03:33:00 <gabre> could you give me a five pointers? I dont mean char*
03:33:33 <gabre> I would like to write a program that inspects all the packets going out from my laptop? (wlan or eth0)
03:33:37 <gabre> how to start
03:33:43 <nathan7> talk to libpcap somehow
03:33:56 * hackagebot tuple-generic 0.3.0.0 - Generic operations on tuples  http://hackage.haskell.org/package/tuple-generic-0.3.0.0 (Artyom)
03:34:07 <nathan7> maybe someone's already written some pleasant bindings for it
03:34:18 <dramforever> gabre: maybe recv from a special socket
03:34:33 <gabre> libpcap - I guess this is lib package capture
03:34:38 <gabre> what special socket?
03:34:46 <dramforever> can't remember
03:34:49 * dramforever is checking
03:35:32 <nathan7> or, if you're feeling less inclined to write a native binding and there isn't one, just parse the output of tcpdump
03:35:38 <nathan7> (which uses libpcap)
03:36:12 <nathan7> judging by the interface names, I'm guessing you're on Linux, and you could probably find out what Linux interfaces libpcap uses
03:36:32 <nathan7> but libpcap encapsulates all the various OS details, and is probably more pleasant to work with
03:36:42 <ttt_fff> okay
03:37:49 <gabre> hmm okay
03:38:36 <gabre> but what I really want to do is not just capturing but (in a later phase) decide to drop it or to route it to its original location (like a "proxyfier")
03:39:04 <nathan7> okay
03:39:42 <nathan7> you could probably either use tun/tap to create another interface, and forcibly route all traffic over it, or figure out if there's a kernel interface for exactly that
03:43:14 <gabre> what I want is kind of a "firewall" but I hae never written such a thing
03:43:45 <bitc01d> :)
03:45:37 <nathan7> gabre: Do you want to actually capture full packages, or just see the headers?
03:45:42 <nathan7> *packets
03:45:58 <nathan7> (I'm dealing with cabal, and my brain is too tired for proper context switching)
03:46:45 <gabre> I think I only need the headers if that is enough to decide whether I want to drop it or keep it
03:51:23 <nathan7> maybe netfilter?
03:51:33 <gabre> what is that?
03:52:22 <nathan7> https://en.wikipedia.org/wiki/Netfilter
03:52:30 <nathan7> I'm not sure if it allows doing the thing you want
03:52:56 <nathan7> if you can express your filter in BPF (which is a fairly simple JITed VM), you can load it straight into the kernel
03:53:00 <gabre> packet filtering, I guess that is what I want
03:56:00 <mauke> <VinceDee> Why is Java?
03:56:07 <gabre> can I use that from Haskell?
03:56:40 <nathan7> not readily, no
03:58:10 <nathan7> https://code.google.com/p/piffle/wiki/PiffleWiki seems relevant
03:59:24 <nathan7> ah, the Piffle compiler is written in Haskell, but it doesn't actually compile Haskell as far as I can see
04:00:43 <gabre> yep
04:02:52 <ttt_fff> is there a good guide to use _unicode symbols_ as haskell varaible names ?
04:04:05 <gabre> I dreamt of something easy, e.g. packet come in, I check if they are good for me, I drop some and I route some
04:08:44 <alpounet> ttt_fff: something like https://wiki.haskell.org/Unicode-symbols ?
04:12:00 <gabre> okay lets talk about Haskell vs firewalls later :) I ll do a deep search on the topic
04:15:07 <jle`> :t fmap join . sequence
04:15:08 <lambdabot> (Monad f, Monad m, Traversable m) => m (f (m a)) -> f (m a)
04:15:12 <jle`> i feel like there should be a better way for this
04:15:18 <jle`> anyone have any suggestions?
04:21:00 <dveim> Hello. Could you please help, how can I perform simultaneous calculation in idiomatic functional style? Smth like: given list, find it's largest element and remove duplicates in a single pass?
04:21:34 <bartavelle> dveim, that's probably composing folds
04:22:01 <bennofs> dveim: look at the foldl library
04:22:15 <bartavelle> dveim, you can use a library like folds or foldl
04:23:49 <dveim> thanks, that's what I looked for
04:24:31 * hodapp pokes head in, looks around for johnw, leaves again
04:28:46 <merijn> hodapp: Wrong time zone
04:29:00 * hackagebot tuple-generic 0.4.0.0 - Generic operations on tuples  http://hackage.haskell.org/package/tuple-generic-0.4.0.0 (Artyom)
04:29:02 <merijn> hodapp: He's in western US, iirc, so it's like early morning at the latest there
04:30:49 <hodapp> merijn: well, I've also not seen him here in days
04:30:52 <hodapp> perhaps I'll just send him an email
04:39:52 <dramforever> ShowerThoughts: seq should be in a class called WHNFData
04:50:21 <ion> So evaluation would depend on a WHNFData whose member's evaluation would depend on WHNFData whose member's evaluation would depend on‚Ä¶
04:52:41 * dramforever is back
04:52:50 <dramforever> ion: no
04:53:44 <dramforever> for example instance WHNFData (Maybe a) where seq Nothing b = b \n seq (Just _) b = b
04:53:55 <dramforever> on a second thought, that might be inefficient
04:54:01 * hackagebot tuple-generic 0.5.0.0 - Generic operations on tuples  http://hackage.haskell.org/package/tuple-generic-0.5.0.0 (Artyom)
04:54:10 <dramforever> forget about it
04:59:01 * hackagebot aivika 4.1.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-4.1.1 (DavidSorokin)
05:01:31 <ion> You can use ; in oneliners, \n is just confusing when not expected (why is there a lambda n here?)
05:01:40 <dramforever> ion: okay
05:01:41 <dramforever> okay
05:01:42 <dramforever> ...
05:01:48 <dramforever> never mind, forget about it
05:05:29 <mniip> what is the nowadays "hip" way of parsing arrays Word8?
05:05:33 <mniip> arrays of Word8*
05:05:39 <dramforever> UArray maybe?
05:05:45 <dramforever> I'm guessing
05:06:06 <mniip> dramforever, parsing
05:06:12 <Peaker> mniip: attoparsec?
05:06:16 <dramforever> oh I read that as passing...
05:06:22 <dramforever> yeah,  attoparsec
05:08:21 <srhb> mniip: binary's Get monad?
05:08:31 <mniip> the file format contains a header followed by blocks of bytes, whose size depends on the data in the header
05:08:37 <srhb> Yes, Get.
05:08:39 <mniip> the blocks need to be copied verbatim
05:08:59 <dramforever> mniip: You parse the headers with attoparsec, then get the blocks with B.splitAt
05:09:15 <mniip> srhb, link?
05:09:15 <dramforever> getting large data with parsers can get inefficient
05:09:20 <srhb> mniip: https://hackage.haskell.org/package/binary-0.7.5.0/docs/Data-Binary-Get.html
05:09:52 <srhb> I don't know why one would prefer Attoparsec for this.
05:10:11 <mniip> so far I'm convinced that srhb's solution is better
05:10:13 <dramforever> srhb: I think it's faster
05:10:28 <dramforever> who knows...
05:10:29 <srhb> dramforever: Really? Hmm.
05:10:35 <srhb> Still, it's more cumbersome.
05:10:38 <dramforever> don't know if true
05:10:40 <mniip> well
05:10:50 <mniip> this sort of parser can't really "fail"
05:10:58 <mniip> the only failure could be a premature eof
05:13:19 <mniip> maybe I could try just tossing bytestrings around
05:14:11 <jessu> Hi what is Haskel?
05:14:26 <mniip> a programming language
05:14:42 <maerwald> it's called Haskell
05:21:02 <tomasos__> a mathematician
05:21:07 <tomasos__> also
05:33:59 <comprehension> hey all
05:34:03 <FreeFull> Heya
05:34:26 <comprehension> does FP complete's "haskell center" offer anything comparable to the free tier of heroku?
05:35:02 <comprehension> looking at their overview i'm not clear if the free version gives you any kind of hosting
05:36:34 <comprehension> i'd like to publish a toy yesod project and i might as well use plain AWS if the only option is to pay $75/month
05:58:40 <zomg> comprehension: I run some of my toy projects and other nonsense on my Linode VPS, the cheapest tier, seems to work alright
05:59:06 <zomg> It's some 20 bucks a month iirc
06:00:19 <aupiff> I'm trying to use Data.Binary on the matrix format in sparse-lin-alg, but whenever I use the `Data.Binary.encode` func, I get an exception `Prelude.maximum: empty list`. The same thing happens with Data.Serialize. any ideas?
06:00:42 <aupiff> I am using the DeriveGenerics extention with ghc 710
06:04:05 * hackagebot engine-io 1.2.8 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.8 (OliverCharles)
06:09:33 <comprehension> zomg: thanks
06:10:33 <chpatrick> aupiff: so you're trying to serialize it automatically?
06:17:47 <ion> Heh. Interleaved output from concurrent processes is always fun. stack build said: Complet e-d-  a lWlh i2l ea cbtuiiolndsi.n g package acme-zero-0.0.2 using:
06:19:06 * hackagebot servant-pandoc 0.4.1 - Use Pandoc to render servant API documentation  http://hackage.haskell.org/package/servant-pandoc-0.4.1 (MatthiasFischmann)
06:21:10 <jTT_> I am creating an ExceptionHandler for http requests with responsecode 404. Currenlty this is returning an empty lazy bytestring. but because my function that sends the get request (Network.Wreq.getWith) returns IO (Response ByteString) I have a type mismatch between the positive, succesfull request (IO (Response ByteString)) and the exception (IO Lazy.ByteString). Can anyone help me make the exception return a response? 
06:31:03 <aupiff> chpatrick: yep, I'm trying to serialize automatically
06:41:49 <aweinstock> jTT_: Network.Wai.responseRaw and Data.ByteString.Lazy.toStrict ?
06:48:07 <chpatrick> aupiff: that's weird
06:48:12 <chpatrick> I don't know what would be doing maximum
06:48:26 <chpatrick> maybe write the binary instance yourself? should be easy
06:49:01 <chpatrick> I mean, you could just convert a SparseMatrix to a tuple
06:49:07 <chpatrick> and then use binary's built in serialization for tuples
06:49:30 <aupiff> I just tried a show instance, too and then I had the same error. Then I tried extracting the mx part and showing and it worked.
06:49:46 <chpatrick> ah
06:50:04 <chpatrick> my guess is that dims is computed lazily
06:50:07 <aupiff> chpatrick: why do you think that is? I'll take your tuple suggestion and try that now.
06:50:11 <aupiff> mmm
06:50:12 <chpatrick> with a maximum somewherein the sparse vector that fails
06:51:26 <chpatrick> are you using column or fromAssocList?
06:52:14 <aupiff> chpatrick: for what task?
06:52:20 <chpatrick> anywhere
06:52:25 <chpatrick> https://hackage.haskell.org/package/sparse-lin-alg-0.4.3/docs/src/Math-LinearAlgebra-Sparse-Matrix.html
06:52:28 <aupiff> fromAssocList
06:52:29 <chpatrick> those two functions have maximum
06:52:36 <aupiff> mmm
06:52:38 <chpatrick> do you give it an empty list? looks like it can't handle it
06:53:21 <aupiff> I don't think I am but I'll check
06:53:34 <chpatrick> that looks wrong anyway tbh
06:53:37 <chpatrick> it uses the maximal index
06:53:43 <chpatrick> but that's lexicographic I think
06:54:10 <chpatrick> > (99999, 0) > (10000, 10000)
06:54:12 <lambdabot>  True
06:54:15 <chpatrick> :|
06:54:33 <chpatrick> so if you have a value at 99999, 0 it will decide that you have a 0-height matrix
06:55:38 <aupiff> ah, you're right. I'll fix that in my local branch of the library
06:56:12 <chpatrick> yeah it should be the maximum of each component
07:01:54 <hodapp> hmm, 'stack' is mostly working, but it's ignoring my PATH variable
07:02:03 <hodapp> which is not good when I need ~/.cabal/bin in there
07:03:52 <dementorr> Hello, i have a variable with type IO [a], where let's say a is string. Now the result seams like a list, but I would like to be a list of strings so just [a]. I didn't find a method IO [a] -> [a] in hoogle, do you know any?
07:05:14 <Cale> dementorr: Such a thing can't exist.
07:05:32 <Cale> dementorr: What you want to do is to execute your IO action. The list of type [a] will be its result
07:06:02 <hodapp> ugh... the first thing I've found wrong with 'stack' is its name, when I'm trying to search on specific issues I'm having
07:06:36 <Cale> That is, as part of another IO action, you might write  do xs <- foo; ... things involving xs here ..., and if foo :: IO [a], then xs :: [a]
07:07:23 <Cale> dementorr: A value of type IO t is a description of some things which could be done in order to produce a result of type t, but an IO String is no more like a String than /bin/ls is like a list of files.
07:08:22 <Cale> dementorr: Inside a do-block, when you write v <- x, it means "execute the action x, and call its result v", so that if x :: IO t, then v :: t
07:08:57 <Cale> dementorr: and then the do-block as a whole will have type IO s (its result will be the result of the last action in the block)
07:09:05 <dementorr> Cale: Ok... So how can I execute it? I mean the code is: http://pastebin.com/ERW62Npp
07:09:30 <Cale> In a compiled Haskell program, main will be executed, and kick things off
07:09:47 <Cale> If you're typing things into GHCi, it will automatically execute IO actions for you
07:09:47 <dementorr> Cale: If i try to get the value with x <- test it gives me: Couldn't match expected type `IO t0' with actual type `[XmlTree]'
07:10:23 <Cale> Wait, did you link the right pastebin? I don't see any IO actions here.
07:10:52 <Cale> info is indeed just a list of XmlTree values
07:11:24 <dementorr> Cale: here is the code http://pastebin.com/jvXsEkix
07:12:24 <Cale> Perhaps you want  let text = [s | NTree (XText s) _ <- info]
07:12:35 <Cale> er, sorry
07:12:46 <Cale> let x = [s | NTree (XText s) _ <- text] -- rather
07:12:52 <Cale> and then try print x
07:13:03 <maerwald> any1 having experience with cryptol? wondering how much effort it would be to attempt an NTRUEncrypt implementation in cryptol
07:15:22 <dementorr> It seams better, but it gives me an error: Not in scope: data constructor `XTree'. I must see why because it seams ok...
07:16:55 <Cale> Did you type XTree somewhere that you meant to type XText?
07:17:11 <Cale> (or perhaps NTree)
07:21:37 <dementorr> No.. the types match.. probably i have to import something else
07:23:14 <hodapp> sm: have you worked with 'stack' much?
07:25:40 <dementorr> Cale: not even this works:  "parse :: NTree XNode -> NTree XNode parse a = a" the definitions are here: http://pastebin.com/ByQ5QvCs
07:35:04 <sm> hodapp: for a couple of days
07:35:26 <hodapp> sm: ahh, I keep running into issues in which it is ignoring my PATH variable for programs like 'alex' and 'happy'
07:36:54 <hodapp> sm: I think I finally solved it by adding alex and happy as dependencies to some packages
07:36:56 <sm> "stack exec which path" should show its idea of $PATH
07:37:11 <hodapp> sm: 'stack exec alex' is running them
07:37:17 <hodapp> sm: but 'stack haddock' is not
07:38:27 <hodapp> ugggggh the build got *slightly* further, and now it's complaining again that alex and happy are missing
07:38:35 <sm> I'd stick a trace statement in to see if it's a bug (quite possible)
07:38:50 <sm> there's also #haskell-stack, though no much activity there yet
07:40:35 <hodapp> sm: I'll ask there
07:41:26 <hodapp> sm: stick a trace statement where?
07:41:49 <sm> somewhere in the stack haddock command
07:42:33 <sm> or I suppose inspect the code, comparing how other commands find alex/happy
07:43:25 <sm> or you can be lazy and just open an issue
07:45:08 <hodapp> yeah, I could do that too
07:45:18 <hodapp> I also don't understand why it has to build all of this crap just to be able to run haddock
07:45:51 <sm> it's similar with cabal IIRC.. haddock requires compiling the code
07:46:17 <hodapp> every time I've done it, it's required that I run 'cabal configure' but does not seem to need to build it
07:46:44 <sm> hmm, ok
07:52:34 <dementorr> Can someone tell me why this is happening? http://pastebin.com/xcPmbUzK
07:55:58 <geekosaur> dementorr: are you importing those definitions from another module explicitly (or perhaps exporting them from that module explicitly)?
07:56:35 <geekosaur> if you are, importing / exporting NTree will only expose the type constructor; you need to do NTree(..) to also expose the data constructor(s)
07:56:46 <dementorr> Importing I guess... i just " import Text.XML.HXT.Core" And the NTree should be imported within that module
07:57:09 <danilo2> Hello guys! :) I've got a big problem with type families and type level lists :( I want to create a type family, which will take as argument a [Nat] and [[Nat]] and tell me if the former one is contained in the later. The problem is, that GHC complains, that if I make (a ': b), then b has to be [*]. How can I do what I need? http://lpaste.net/135301
07:57:33 <geekosaur> something tells me you did not understand fully what I asked, but I'm not sure how to clarify it. could you show the actual code somewhere?
07:58:06 <hacker> is there any 'nice' way to do some kind of composition of StateT(s)? 
07:58:33 <dementorr> Sure. Here it is: http://pastebin.com/LzF8DE5g
07:59:54 <geekosaur> oh, I see, those are defined internal to HXT. hm.
08:01:21 <geekosaur> I suspect you can't do that, for the same reason you can't do it with Data.Map: the actual implementation of the tree is deliberately hidden
08:01:31 <geekosaur> and you have to use accessor functions, not pattern matching
08:01:50 <geekosaur> (this is usually to maintain invariants, e.g. that the nodes in the tree must be ordered)
08:01:59 <dementorr> Oh ok Ill try to find them :D Thanks
08:03:48 <elfeck> can someone tell me how I use wai-middleware addBase and keep all paths relative to "/"
08:04:19 <elfeck> e.g. if I serve static files from /my/url/wuhu/ I want to still be relative to /
08:04:29 <dementorr> geekosaur: Sorry to bother you again but do you know where can I look for the documentation? Hoogle returns nothing when i query XmlTree...
08:04:56 <sm> use http://hoogle.haskell.org
08:04:59 <geekosaur> The haskell.org hoogle is pretty limited by default
08:05:36 <geekosaur> sm just pointed at the (still experimental, I think) new one; there's also a more complete one at fpcomplete.com/hoogle, or you can use hayoo (http://hayoo.fh-wedel.de)
08:06:25 <geekosaur> I use the latter because it searches all of Hackage (hoogle currently can't due to internal limitations), but it has its own issues (hayoo handles fuzzy names better, hoogle handles fuzzy types better)
08:07:13 <danilo2> AH! I found the solution. The "In" should have been declared like this to make it working: "type family In (a :: l) (set :: k) :: Bool" :D
08:07:24 <dementorr> Ok I'll look into it!
08:08:18 <sm> hayoo's results have apparently been deteriorating due to haddock churn on hackage, but were to receive a refresh in the last day or two
08:14:36 <geekosaur> I was under the impression it was just a bug, and it was fixed
08:15:09 <geekosaur> (hayoo is a tech demo of a graduate student project at FH-Wedel, an extensible search engine architecture. It will break sometimes)
08:25:04 <indiagreen> does anyone know a variant of getLine which wouldn't echo the entered characters? or some way to turn off echoing? (I need it to enter a password)
08:25:50 <voidzero> but it is not getLine that echos
08:25:57 <voidzero> it is your terminal 
08:26:10 <voidzero> that said, no, i haven't the slightest
08:26:44 <voidzero> i guess you could call tput, but that's not the right way to do it
08:27:01 <jackhill> indiagreen: look at hSetEcho from System.IO
08:27:34 <lpaste_> jackhill pasted ‚Äúno-echo‚Äù at http://lpaste.net/135302
08:27:36 <indiagreen> jackhill: thanks
08:27:46 <jackhill> indiagreen: something like what I just pated
08:28:04 <Denommus> I have a JSON from aeson that I want to convert to a HTTP request body in http-conduit
08:28:10 <Denommus> is there a easy way to do that?
08:28:45 <jackhill> indiagreen: I think there are fancier password inputs in some other library, but this met my need
08:29:13 * hackagebot glue 0.1.1.0 - Make better services.  http://hackage.haskell.org/package/glue-0.1.1.0 (seanparsons)
08:29:25 <indiagreen> jackhill: yep, it's exactly what I need
08:31:52 <aweinstock> Denommus: Data.Aeson.encode and Network.HTTP.Conduit.lbsResponse?
08:34:04 <bollu> hey, is there a "stateful" takeWhile?
08:34:55 <bollu> something along the lines of takeWithState :: (a -> s -> (s, Bool)) -> s -> [a] -> [a]
08:35:39 <bollu> like, have a function that returns a state on each invocation along with a "should I take more". Give an initial state and a list. Take till the function returns True
08:35:48 <bollu> I hope that made sense :)
08:35:55 <Denommus> aweinstock: I guess my problem now is that I can't set the content-type
08:36:55 <chpatrick> bollu: I don't think so
08:37:38 <bollu> chpatrick: hm, in that case, is what I'm trying to do not "haskell-y" ? Is there a different way to write it?
08:38:01 <chpatrick> can you explain more about what you're doing?
08:38:54 <bollu> chpatrick: I'm trying to find the maximal matching substring from a string. So, if I can keep a "state" of the longest string found so far
08:39:12 <bollu> and if I the next character I get doesn't yield a useful substring, I can quit
08:39:40 <chpatrick> I think you might need to recurse unfortunately
08:39:41 <bollu> https://github.com/bollu/cpp-achilles/blob/master/src/tokenizer.cpp#L241 <- reimplementing that in Haskell
08:39:47 <bollu> chpatrick: ah, dang
08:40:06 <bollu> chpatrick: I'm trying to write a parser in Haskell. This is for detecting symbols :)
08:40:09 <chpatrick> oh dude
08:40:13 <chpatrick> check out parser combinators
08:40:16 <chpatrick> it's a haskell killer app
08:41:00 <chpatrick> http://book.realworldhaskell.org/read/using-parsec.html
08:41:09 <bollu> chpatrick: yeah, I know. But.. I wanted to write a nuts and bolts parser first
08:41:09 <chpatrick> there are some more trendy libraries now but they basically work the same way
08:41:15 <bollu> attoparsec seemed too much like "magic"
08:41:22 <bollu> Like, I want to get the hang of Haskell first :)
08:41:26 <bollu> then the libraries
08:41:54 <chpatrick> tbh I think this kind of stuff is a great way to get the hang of monads for example
08:42:04 <chpatrick> using monadic parsers I mean
08:42:22 <bollu> chpatrick: hmm
08:42:30 <bollu> chpatrick: I'm using State right now for the Tokenization
08:42:39 <bollu> haskell code looks really neat and tidy :)
08:42:41 <bollu> I love haskell
08:42:48 <chpatrick> yeah it's rad
08:42:51 <aweinstock> Denommus: Network.HTTP.Conduit.responseHeaders looks like it may be relevant, although it seems to be a getter? I'm not experienced with the library specifically, just looking through the documentation on hackage
08:43:52 <chpatrick> I just wrote some code to parse JVM method signatures like this: (Ljava/util/Collection<+TE;>;)Z^TE;^Ljava/lang/Object;
08:44:00 <chpatrick> it's about 60 lines of attoparsec
08:44:03 <aweinstock> does the fact that Response has a Traversable instance mean that responseHeaders is usable as a lens?
08:44:57 <Denommus> gosh, http-conduit is hard to deal with
08:45:00 <c_wraith> aweinstock: well, it's usable as a Traversal
08:45:14 <bollu> So, well, write a version myself?
08:45:15 <Denommus> is there an alternative library?
08:45:16 <c_wraith> aweinstock: which is very closely related, but not identical
08:45:18 <bollu> of the function I was looking for?
08:45:30 <c_wraith> aweinstock: Traversals might have multiple targets - a lens only has a single target.
08:45:37 <Jafet> bollu: that C++ code looks incorrect, so reimplementing it seems unwise.
08:45:38 <Cale> Denommus: Perhaps just HTTP? Or are you looking for something else which specifically works with conduits?
08:45:53 <chpatrick> bollu: for that function yeah
08:45:56 <edwardk> responseHeaders is a lens in wreq
08:46:07 <chpatrick> but I think you can make the higher level code more abstract too :)
08:46:15 <bollu> Jafet: Incorrect how? -_^
08:46:18 <Jafet> (What happens when it tokenizes "=="?)
08:46:25 <Denommus> Cale: I just want to get and post JSON data
08:47:12 <edwardk> bollu: for writing your first parser type in haskell i recommend starting with the classic 'list of successes parser'
08:47:27 <bollu> edwardk: link?
08:47:33 <edwardk> bollu: newtype Parser a = Parser { runParser :: String -> [(a, String)] } -- wiring that up and making all the instances for that is quite fun
08:47:57 <Cale> Denommus: hmm, maybe wreq?
08:48:03 <edwardk> https://rkrishnan.org/files/wadler-1985.pdf is the original paper
08:48:06 <Cale> http://hackage.haskell.org/package/wreq-0.4.0.0/docs/Network-Wreq.html -- see examples here
08:48:08 <Denommus> Cale: HTTP seems simple enough
08:48:12 <edwardk> note that it predates monads being used in haskell
08:48:21 <bollu> Jafet: which is why we check for substrings of the current string head. The "==" should have been placed above the "=" in that list :)
08:48:27 <edwardk> so it is an interesting exercise to update it
08:48:29 <maerwald> edwardk: I thought it is (a, String) not [(a, String)]?
08:48:34 <Cale> Yeah, HTTP is a pretty straightforward client too
08:48:48 <bollu> edwardk: oh, thanks :)
08:49:07 <edwardk> maerwald: you need a _list_ of successes. the thing you describe can only succeed and ony have one parse. that works fine for things where you work left to right in a deserializer or something, but not for parsing in general
08:49:46 <bollu> Jafet: so, for example, if your stream has something along the lines of ">= b", you first take out a two character substring, which yields ">=", that you factor out. Which is why TokenGEQ is higher in the list than TokenG 
08:50:25 <edwardk> maerwald: https://rkrishnan.org/files/wadler-1985.pdf <- page 120 (8 in the order they show up)
08:50:47 <edwardk> https://www.fpcomplete.com/user/edwardk/heap-of-successes <- is an article where i play around with that representation a bit
08:51:56 <maerwald> interesting
08:52:01 <bollu> edwardk: So, I'll be able to implement a parser from the paper?
08:52:26 <bollu> Jafet: is the algorithm actually wrong? It was just a misplaced entry in the table that makes it incorrect for "=", right?
08:52:37 <edwardk> bollu: it is very implementable. and you learn stuff from building the Monad, the MonadPlus, etc. you can also implement all the combinators in my `parsers` package as well
08:53:03 <bollu> cool, thanks a lot!
08:53:06 <Jafet> bollu: well, parsing libraries like Parsec.Token make such errors impossible.
08:53:35 <bollu> Jafet: yeah :) But the exercise was to do the work myself
08:55:24 <Denommus> HTTP doesn't support HTTPS?
09:01:08 <geekosaur> not currently, no; it's trying to keep its dependencies relatively compact, and https requires a lot more stuff
09:01:43 <geekosaur> the cabal-install devs are also being frustrated by that, but they have same problem of wanting to keep bootstrap dependencies down 
09:06:48 <Sindriava> There's no GHC in nixpkgs for OSX?
09:14:10 <d34df00d> Hi!
09:14:15 <d34df00d> I'm trying to write something like https://bpaste.net/show/071d0cf71a50
09:14:25 <d34df00d> But I get something like https://bpaste.net/show/7cfd9cad305a
09:14:30 <d34df00d> How can I fix my code?
09:14:53 <bollu>  filterM (const [True, False]) <- what the HELL? how does that generate the powerset?
09:15:26 <Sindriava> bollu: List behaves like a nondeterministic computation by default
09:15:33 <mniip> filterM lets you make the predicate a monadic action
09:15:38 <Sindriava> bollu: You filter out and keep each element at the same time
09:15:54 <mniip> aand basically what Sindriava said
09:16:45 <Sindriava> bollu: Imagine addition. [2 or 4] + [5 or 10] = [7 or 12 or 9 or 14]
09:16:47 <bollu> mniip: is there a more.. "direct" way of seeint it?
09:16:53 <mniip> @src filterM
09:16:54 <lambdabot> Source not found. :(
09:16:56 <mniip> aw
09:16:57 <Cale> bollu: In the list monad, "running" a list means to pick an element from it in all possible ways
09:17:09 <Jafet> > liftM2 (+) [2,4] [5,10]
09:17:10 <lambdabot>  [7,12,9,14]
09:17:17 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
09:17:19 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
09:17:28 <bollu> okaay
09:17:32 <mniip> bollu, are you familiar with the list monad?
09:17:37 <bollu> mniip: yeah
09:17:41 <Cale> > do x <- [True, False]; y <- [True, False]; return (x,y)
09:17:42 <lambdabot>  [(True,True),(True,False),(False,True),(False,False)]
09:17:50 <bollu> I know that the default semantics is to "take all combinations"
09:17:58 <bollu> and (>>=) is flatMap
09:18:17 <Sindriava> bollu: Yeah. And for EACH combination of "filter x out" and "leave x in the list", you do that
09:18:21 <Cale> So, in this case, filterM (\x -> [True, False]) basically says "for each element x, take it or leave it"
09:18:31 <Sindriava> bollu: And in the end, you get a powerset, because you get all the possible subsets
09:18:40 <mniip> filterM p (x:xs) = do b <- p; if b then fmap (x:) filterM p xs else filterM p xs
09:18:51 <mniip> er
09:18:52 <mniip> b <- p x
09:19:00 <Cale> @src filterM
09:19:00 <lambdabot> Source not found. My mind is going. I can feel it.
09:19:03 <Cale> aw
09:19:08 <bollu> that feels so much like cheating!
09:19:18 <Sindriava> bollu: Except it's not :3
09:19:19 <d34df00d> Meh, disregard my question, stupid one.
09:19:42 <bollu> next you'll tell me that you can diagonalize on a doubly infinite list..
09:19:44 <Cale> bollu: It's really clear and concise once you get it, eh?
09:19:54 <bollu> Cale: yes, but it's not.. fair? :)
09:19:58 <Cale> bollu: and you can do that, but not directly with the list monad
09:20:08 <mniip> bollu, you mean a ZipList Monad?
09:20:17 <Cale> Nah, he means something like Omega
09:20:19 <bollu> Cale: how? does haskell literally have a function that lets you diagonalize?
09:20:20 <mniip> there are a few issues with bottoms and finite lists in there
09:20:54 <Cale> http://hackage.haskell.org/package/control-monad-omega-0.3.1/docs/Control-Monad-Omega.html -- not actually a monad, but close enough for jazz
09:21:11 <d34df00d> Ok, another question: why does typechecker need the fundeps here in the Lookupable typeclass?
09:21:17 <mniip> ah
09:21:19 <mniip> I see
09:21:27 <d34df00d> https://bpaste.net/show/cf3582e4833f
09:21:59 <Denommus> hah, the problem wasn't with http-conduit
09:21:59 <Denommus> the Telegram API doesn't support a JSON body
09:22:00 <Denommus> I have to convert to form fields
09:22:00 <Denommus> any viable way to do that?
09:22:07 <bollu> that is insane
09:22:13 <d34df00d> versus
09:22:18 <d34df00d> https://bpaste.net/show/61ccaf57601d
09:22:53 <mniip> Cale, I wonder if it can do http://lpaste.net/135183
09:22:57 <geekosaur> d34df00d, because e can't be given a type otherwise. (normally when it's a result type, the caller gets to specify what it is)
09:23:01 <bollu> also, the fact that you can construct that is a slick proof that card(R x R) = card(R) :) I know that schroder-bernstein can show that, but this seems cool too
09:23:15 <geekosaur> so you need some way to constrain e in order to make it part of the typeclass
09:23:27 <ReinH> Cale: I tried to write n-dimensional diagonalization in javascript recently and gave up
09:23:58 <geekosaur> basically you can't pick an instance of it sanely unless you use the fundep, or require all users of it to explicitly type their uses
09:25:08 <mniip> ReinH, couldn't you just use a BFS queue
09:25:25 <bollu> can I generate all rationals in haskell in that case? The proof I know involves creating an infinite union of finite subsets
09:25:34 <mniip> like, BFS through N^k starting at (0,0,...,0)
09:25:36 <Sindriava> bollu: I feel weird, coding in haskell and not understanding much math at all :D
09:25:49 * geekosaur shrugs
09:26:04 <bollu> Sindriava: I'm not a math student either :) Just read math when I get time because I find it cool. 
09:26:07 <geekosaur> I'm no great shakes at math, and type theory is pretty much a closed book, yet I manage
09:26:48 <Sindriava> bollu: I never really got into math, since I find it kinda boring. Not as a subject, but the execution isn't my jazz
09:26:50 <d34df00d> geekosaur: in other words, this is (at least partially) related to the fact I don't have anything about 'e' in the function signature itself?
09:26:50 * mniip <- been introduced to somplex mathes and type theories via haskell
09:27:08 <ReinH> bollu: you can create a bijection [0,1]¬≤ ‚Üí [0,1] by interleaving the digits, from which you can easily prove a bijection ‚Ñù‚Åø -> ‚Ñù
09:27:17 * Sindriava feels better about himself now
09:27:18 <geekosaur> it only occurs in the result, yes
09:27:25 <geekosaur> and the result isn't under your control
09:27:34 <geekosaur> it's under the control of the caller of `lu`
09:27:37 <ReinH> @google functional pearl enumerating the rationals
09:27:38 <lambdabot> http://www.cs.ox.ac.uk/jeremy.gibbons/publications/rationals.pdf
09:27:38 <lambdabot> Title: FUNCTIONAL PEARL Enumerating the Rationals
09:27:44 <ReinH> Gibbons has a nice one
09:28:07 <Sindriava> Yeah, from what i gather, there's a provable isomorphism from any space to R
09:28:15 <bollu> ReinH: the proof I know involves constructing two into maps, one from R^n -> R, and the other from R -> R^n. the R^n to R is by interleaving the digits, and R to R^n is something trivial like, f(a) = (a, 0, 0, ...) 
09:28:41 <mniip> bollu, the second part wouldn't make an isomorphism
09:28:44 <d34df00d> geekosaur: but why should typechecker care about the type at all? It can figure out it's some Maybe e1 (from the isJust call), and let's stop there, why not?
09:28:50 <bollu> mniip: it doesn't have to be
09:28:57 <bollu> we're invoking schroder bernstein
09:29:01 <mniip> R -> R^n has to un-interleave the digits and reverse the effect of R^n->R
09:29:21 <Luke> man haskell has been getting to the front of hacker news more and more recently
09:29:38 <bollu> mniip: no? they can be two unrelated one-one into functions
09:29:46 <Sindriava> You need two operations, A: R ‚Üí R^n and B: R^n ‚Üí R, such as that A . B = id
09:29:48 <ReinH> bollu: you have to be a bit more clever about the interleaving, but that's the basic plan
09:30:04 <Sindriava> Luke: Yeah, I noticed. Right when I picked it up
09:30:23 <geekosaur> you're going beyond what I understand about it (see preceding comment in one of the other conversations going on in here :) but it needs to determine a concrete type, because it can't prove that knowing it's a Maybe * is enough
09:30:26 <Luke> the last big push we had like this was when "Real World Haskell" was written
09:30:44 <geekosaur> nothing stops you from defining different instances for Maybe Char vs. Maybe Int in the `e` position
09:30:58 <geekosaur> and there is no way to prevent someone from doing so
09:31:14 <merijn> geekosaur: Challenge accepted? ;)
09:31:15 <mniip> Sindriava, don't forget B . A = id
09:31:19 <geekosaur> (and all instances are globally visible, so you can't just hide it all in your module)
09:31:28 <Sindriava> mniip: Oh yeah, derp
09:31:50 <mniip> merijn, what's the challenge :o
09:31:53 <bollu> ReinH: does this not work? for R^n -> R, let f(x0, x1, x2, ..) = <interleave digits>. This has an inverse since we can just un-interleave. For R -> R^n, map x to (x, 0, 0, 0,...) then, use schroder bernstein (since both are one-to-one and invertible, we get a bijective map)
09:32:12 <geekosaur> merijn, go nuts (as I said, I'm no great shakes at this stuff)
09:32:13 <merijn> mniip: "Nothing stops you from defining different instances"
09:32:15 <ReinH> bollu: you have to deal with, e.g., 0.5 = 0.499...
09:32:22 <bollu> ReinH: use binary
09:32:30 <Sindriava> kinda OT question, but is there a "fun" place to read about math? Like HackerNews, but MathNews
09:32:35 <bollu> oh, wait, you'd still get the same problem
09:32:36 <mniip> oh
09:32:37 <ReinH> bollu: here's a nice writeup of the "more clever" version http://math.stackexchange.com/questions/183361/examples-of-bijective-map-from-mathbbr3-rightarrow-mathbbr
09:32:49 <mniip> well I guess you could not export the typeclass
09:33:17 <mniip> or cover all types by using a closed kind so that no new instances can be added without overlapping
09:34:16 <bollu> ReinH: whoa, cool :) thanks for that!
09:34:45 <bollu> http://www.cs.ox.ac.uk/jeremy.gibbons/publications/rationals.pdf doesn't render right for me in chrome :(
09:35:20 <mniip> bollu, does in firefox, but for some reason it tries to use raster fonts
09:36:30 <mniip> oh, you can use an open kind too, but then just use an "open" value in instance head too
09:36:34 <ReinH> bollu: another interesting result is that "for every infinite A there is a bijection between A¬≤ and A" is equivalent to the axiom of choice, which was proved by Tarski iirc
09:37:59 <bollu> ReinH: o_O a) I don't grok AoC b) I don't understand how it pops up all over the place c) so, in a formulation of set theory without axiom of choice..?
09:38:14 <ReinH> Well, some sets of interest are not well ordered
09:38:33 <ReinH> for those that are, AoC is not required
09:39:45 <mniip> I still don't see what's the problem with predicative approach to sets
09:41:31 <ReinH> bollu: ah here http://math.stackexchange.com/questions/56466/for-every-infinite-s-s-s-times-s-implies-the-axiom-of-choice/56471#56471
09:41:38 <ReinH> it's surprisingly hard to google for these things
09:49:27 <Cale> Another equivalent to the Axiom of Choice is that for any two sets, either they have the same cardinality, or one has a smaller cardinality than the other.
09:50:45 <c_wraith> That's kind of subtle.  I guess it depends on being able to choose an element in order to enumerate them?
09:51:08 <mniip> wait are you saying that without AoC we cannot prove that cardinality ordering is antisymmetric?
09:52:01 <Cale> mniip: That's right, if you deny the AoC, you end up with incomparable pairs of sets.
09:52:14 <ryantrinkle> is it still the case that there's no (sane, multithreaded) way to forkProcess?
09:52:20 <Cale> So infinite sets end up having weird sorts of "shapes" where neither one will fit inside the other.
09:52:34 <c_wraith> mniip: but only for uncountably infinite sets
09:52:39 <mniip> obviously
09:52:42 <bollu_> this maybe too much to ask, but can someone motivate AoC for me? :)
09:52:43 <c_wraith> mniip: remember, no one denies countable choice
09:52:53 <ryantrinkle> I see that the "unix" package does not support it
09:54:07 <Cale> bollu_: Well, I dunno -- the motivation is pretty clear in a lot of the forms. If comparability of infinite cardinalities doesn't motivate you, perhaps just the direct statement that a Cartesian product of nonempty sets should be nonempty.
09:54:50 <Denommus> can anyone help me on why doesn't this Haskell request work, when the curl request does? https://gist.github.com/Denommus/961a35e37f405c63b919
09:54:55 <Cale> bollu_: That's an obvious generalisation of what happens when there's only finitely many nonempty sets.
09:54:59 <bollu_> Cale: well, why was it created? because someone realized that you need such an axiom? or because it couldn't be derived from the other axioms>
09:55:00 <bollu_> ?
09:55:19 <Cale> bollu_: It's been shown that it can't be derived from the other axioms
09:55:32 <Cale> bollu_: It's independent of ZF set theory
09:55:37 <c_wraith> Denommus: "work" is such a vague term.  In what way does it not work?
09:55:44 <bollu_> Cale: ah, okay. Then it makes sense :) how do you show if a proof you have depends on axiom of choice or not?
09:56:03 <Cale> bollu_: By fastidiously keeping track of which results rely on it
09:56:30 <c_wraith> bollu_: if the phrase "WLOG, choose a..." appears in an uncountably infinite domain, you need choice. :)
09:56:36 <bollu_> Cale: like, you literally check if the theorems you use employ the axiom? there's no cleaner way?
09:56:38 <c_wraith> bollu_: also, appeals to Zorn's lemma. :)
09:56:40 <oconnore> Is it normal with STM to pre-emptively create data structures in IO, then perform a transaction, and clean up if you didn't end up using them?
09:56:43 <Denommus> c_wraith: I can make the request, but the server says I'm not sending the text parameter
09:56:45 <Cale> bollu_: Not really, no.
09:57:07 <Cale> bollu_: But generally people *do* keep track -- the situation there is better than it is with the law of excluded middle.
09:57:34 <oconnore> Or do people more often make a transaction, check if the IO data is needed, and then create -> new transaction -> handle the case where another thread already created the data
09:57:35 <Cale> bollu_: Also, there can be easier proofs of results which use the axiom of choice when AC can be avoided.
09:57:44 <bollu_> Cale: ah
09:58:00 <bollu_> Cale: hm, so using the axiom simplifies even when it is strictly not necessary?
09:58:11 <c_wraith> Denommus: dunno. I'd take a look at the difference in what's going over the wire.
09:58:16 <Cale> bollu_: Which muddies the waters somewhat, but it's very often the case that applications of the axiom of choice end up being equivalent to AC itself.
09:58:30 <Cale> bollu_: For example, "every vector space has a basis" is equivalent to the axiom of choice.
09:58:40 <bollu_> Cale: no frikkin way
09:58:46 <bollu_> Cale: why?
09:59:00 <c_wraith> because it's including vector spaces with uncountably infinite dimensionality
09:59:09 <bollu_> but, "equivalent" ?
09:59:20 <bollu_> "uses" is different from "equivalent", right?
09:59:34 <mniip> every vector space has a basis |- AoC
09:59:37 <mniip> AoC |- every vector space has a basis
09:59:55 <bollu_> ah
09:59:55 <c_wraith> It just means you can couch choice as building a basis for the vector space
10:01:53 <Cale> http://www.math.lsa.umich.edu/~ablass/bases-AC.pdf
10:02:34 <bollu_> is "bases" the old spelling or something?
10:02:42 <bollu_> Cale: thanks for that :)
10:02:58 <Cale> bases is the plural of basis
10:03:29 <bollu_> Cale: ah
10:03:57 <bollu_> Cale: had not known that
10:04:05 <Jafet> Huh, haskell.org forces HTTPS now
10:04:19 <Welkin> why not "base" and "bases"/
10:04:22 <Welkin> that was always confusing
10:04:39 <ChristianS> Welkin: don't expect languages to be logical
10:04:43 <geekosaur> they love themselves some latin?
10:04:50 <ChristianS> not even perl is, and natural languages even less
10:04:54 <bollu_> Cale: which theorem is the "halperm theorem" they refer to? 
10:05:22 <bollu_> halpern*
10:05:30 <Cale> bollu_: The one they describe in the first sentence
10:05:56 <bollu_> Cale: no, like, is there a link to the proof or some such? :)
10:06:02 <bollu_> I was curious
10:06:05 <Cale> ah, maybe I can dig one up...
10:06:19 <Cale> Well, it's references in the bibliography there...
10:06:24 <Cale> referenced*
10:06:40 <bollu_> oh, right :)
10:06:46 <Cale> http://www.ams.org/journals/proc/1966-017-03/S0002-9939-1966-0194340-1/S0002-9939-1966-0194340-1.pdf
10:07:06 <ryantrinkle> is there a way to get the path to an executable in a Cabal package, much like Paths_pkgname.getDataFileName?
10:08:36 <ChristianS> ryantrinkle: i don't think so, but you shouldn't have to call other haskell executables from your own
10:08:54 <ryantrinkle> ChristianS: i'm trying to work around the fact that there's no way to fork :P
10:09:24 <ryantrinkle> believe me, i'd much rather write "forkProcess someIOAction"
10:09:45 <ryantrinkle> any ideas on how i can accomplish something like that?
10:10:04 <hexagoxel> ryantrinkle: data files are part of the package; executables are not. and the executables can be installed wherever the user says
10:10:23 <ryantrinkle> hexagoxel: yeah, makes sense
10:10:35 <lisbeth2> > take 4 ([ [x] | x <- (cycle (take 95 [' '..]))]
10:10:37 <lambdabot>  <hint>:1:48:
10:10:37 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:10:46 <hexagoxel> ryantrinkle: can't you just use the current process filename?
10:10:47 <lisbeth2> > take 4 ([ [x] | x <- (cycle (take 95 [' '..]))])
10:10:49 <lambdabot>  [" ","!","\"","#"]
10:11:00 <lisbeth2> I don't want them to be in brackets or separated by commas.
10:11:29 <ryantrinkle> hexagoxel: well, this is a library function that needs to be able to fork a daemon, which is also written in the library
10:11:36 <ryantrinkle> also, it only needs to fork it *sometimes*
10:12:13 <Jafet> What's wrong with forkProcess, exactly?
10:12:14 <geekosaur> hexagoxel, you can't always hget that
10:12:27 <Jafet> Oh, it's still incompatible with the threaded runtime
10:12:33 <ryantrinkle> Jafet: yep
10:12:39 <geekosaur> Jafet, Unix fork() is dangerous in the presence of threads, and the GHC I/O manager doesn';t take the necessary care
10:12:42 <ryantrinkle> i could split the daemon code into another package, but i'm not sure that'll help
10:12:43 <hexagoxel> > take 4 ([ x | x <- (cycle (take 95 [' '..]))]) -- lisbeth2 
10:12:45 <lambdabot>  " !\"#"
10:13:54 <lisbeth2> the problem is I want to do:
10:14:09 <lisbeth2> > take 4 ([ x ++ x | x <- (cycle (take 95 [' '..]))])
10:14:10 <lambdabot>      Couldn't match expected type ‚Äò[a]‚Äô with actual type ‚ÄòChar‚Äô
10:14:10 <lambdabot>      In the first argument of ‚Äò(++)‚Äô, namely ‚Äòx‚Äô
10:14:10 <lambdabot>      In the expression: x ++ x    Couldn't match expected type ‚Äò[a]‚Äô with act...
10:14:33 <ryantrinkle> maybe i can get the package install path and then invoke ghc -e
10:14:42 <Jafet> What programs like xmonad do is just to serialize the entire program state when starting a new instance.
10:15:10 <Byte_> Hey everyone, was wondering if someone could explain a concept to me in this code: http://lpaste.net/135306
10:15:21 <hexagoxel> > take 4 ([ y | x <- (cycle (take 95 [' '..])), y <- [x,x]]) -- lisbeth2 
10:15:23 <lambdabot>  "  !!"
10:15:37 <ryantrinkle> Jafet: i'm not starting an instance of the same program, though - and the library doesn't wrap main or anything, so I can't intercept the program's startup
10:15:52 <lisbeth2> That works thanks
10:16:04 <ryantrinkle> basically what i'm doing is: if a server is already running, connect to it; otherwise, start one, and then connect
10:16:15 <hexagoxel> lisbeth2: there is more than one way to concat
10:16:19 <hexagoxel> :t concat
10:16:19 <ryantrinkle> but, once it's started, another client can also connect
10:16:20 <lambdabot> Foldable t => t [a] -> [a]
10:16:26 <ryantrinkle> so that server needs to be able to outlive the current process
10:16:56 <hexagoxel> > concat [" ","!","\"","#"]
10:16:58 <lambdabot>  " !\"#"
10:17:43 <Byte_> Anyone mind explaining a concept to me
10:18:08 <Clint> probably
10:18:14 <geekosaur> you pasted your code but never said anything about the concept that's confusing you
10:18:19 <geekosaur> "just ask your question"
10:18:35 <Byte_> I'm interested in the behavior of pseq and par
10:18:37 * geekosaur notes beforehand that he's probably not going to be able to help much
10:18:49 <Byte_> What exactly is happening under the hood when I use pseq and par
10:20:02 <Byte_> And in this code: v' `par` l' `par` r' `pseq` Branch v' l' r', is this saying execute v', l' and r' in parallel but then why is there a pseq? (force away lazyness?)
10:20:17 <Jafet> ryantrinkle: how about just System.Process, then
10:20:19 <Cale> Evaluating (x `pseq` y) evaluates x to weak head normal form, and then results in y (which will immediately be evaluated next)
10:20:26 <geekosaur> pseq is like seq but guarantees evaluation order
10:20:30 <geekosaur> (seq does not)
10:20:48 <ryantrinkle> Jafet: you mean to invoke ghc? yeah, that will probably work
10:21:03 <ryantrinkle> also, it looks like Paths_blah includes a few useful (undocumented?) things
10:21:11 <Cale> Evaluating (x `par` y) will add x to a queue of things to be evaluated at some point if time is available to do so before they're needed, before resulting in y.
10:21:16 <Jafet> No, to start the daemon as a new process
10:21:27 <geekosaur> and seq ensures that when the thing on the right has been evaluated, the thing on the left will be in weak head normal form (i.e. evaluated to the first constructor)
10:21:35 <ryantrinkle> getBinDir, getLibDir, getDataDir, getLibexecDir, getSysconfDir :: IO FilePath
10:21:40 <ryantrinkle> Jafet: i'm not sure i understand
10:21:49 <MarcelineVQ> woah, [' '..] is trippy
10:21:55 <ryantrinkle> what'll I be invoking?
10:22:36 <Byte_> geekosaur: hmm not quite sure how seq/pseq differ still (and no idea what weak head normal form is o.O)
10:23:17 <mada> is there something like point-free expression of a numerical function in a mathematical context? googling brings up 'tacit programming'
10:23:31 <geekosaur> (i.e. evaluated to the first constructor)
10:23:46 <Sindriava> Hm‚Ä¶ GHC installed through Nix can't find system includes
10:23:48 <Sindriava> like math.h
10:23:57 <Jafet> ryantrinkle: System.Process starts new processes, (I assume) using fork/execv
10:24:14 <ryantrinkle> Jafet: right, but the problem is that I have an IO (), not a path to a binary
10:24:17 * hackagebot clash-lib 0.5.8 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.5.8 (ChristiaanBaaij)
10:24:29 <ryantrinkle> so i need to build that IO () as the main of some executable
10:24:33 <ryantrinkle> which my library needs to know the path to
10:24:44 <MarcelineVQ> what char set is ghc looking at that length [' '..] = 1114080
10:24:56 <Jafet> Yes, existing programs like xmonad do this, with some painful wrapping and unwrapping of the program state
10:24:57 <ryantrinkle> the daemon (server) and the client are both part of the same library :)
10:25:16 <ryantrinkle> right, but the library isn't the *program*
10:25:26 <ryantrinkle> it'll be used by an arbitrary program, which the library doesn't control
10:25:31 <Byte_> geekosaur: sorry but I'm a noobie, evaluated to first constructor means what exactly>
10:25:46 <ryantrinkle> so i can't, for example, intercept args and decide to go into daemon mode
10:25:47 <Jafet> Well, if this IO() is parameterized by calling code then things get more interesting
10:26:00 <ryantrinkle> haha yep :)
10:26:02 <geekosaur> Haskell is not strictly evaluated. if I write `foo x = x + 5`, calling `foo 3` does not immediately produce 8
10:26:21 <ryantrinkle> luckily, it's not *heavily* parameterized
10:26:23 <ryantrinkle> just a string or so
10:26:23 <ryantrinkle> but the problem is that i can't make any assumptions about the binary i'm a part of
10:26:36 <Byte_> Right so the lazyness concept
10:26:44 <ryantrinkle> there's no way i can just exec argv[0] and figure it out from there
10:27:16 <ryantrinkle> i think if i can figure out how to use ghc -e with an explicit library path, i should be OK
10:27:18 <geekosaur> instead, something needs to demand the result. this is usually done by pattern matching a constructor (for the purposes of this, a numeric literal behaves like a constructor), but sometimes you need to force evaluation without having a pattern. seq does this
10:27:26 <ryantrinkle> getLibDir gives me the library's lib dir
10:28:03 <geekosaur> but seq does not guarantee when that evaluation happens, so we have pseq that does. *usually* the difference isn't important, but for parallel processing it is crucial --- so pseq is usually used in conjunction with it
10:28:15 <Jafet> Surely you can assume that the daemon (if it's a separate binary) is installed in a "well-known" place
10:28:38 <geekosaur> practical example of the laziness thing:
10:28:43 <Byte_> geekosaur: ah I see, so whats the use case for seq?
10:29:08 <maerwald> Jafet: do you refer to something like FHS?
10:29:13 <ryantrinkle> Jafet: i'm not so sure; what if there are multiple versions of the lib installed?
10:29:18 * hackagebot clash-systemverilog 0.5.7 - CAES Language for Synchronous Hardware - SystemVerilog backend  http://hackage.haskell.org/package/clash-systemverilog-0.5.7 (ChristiaanBaaij)
10:29:20 * hackagebot clash-verilog 0.5.7 - CAES Language for Synchronous Hardware - Verilog backend  http://hackage.haskell.org/package/clash-verilog-0.5.7 (ChristiaanBaaij)
10:29:22 * hackagebot clash-vhdl 0.5.7.1 - CAES Language for Synchronous Hardware - VHDL backend  http://hackage.haskell.org/package/clash-vhdl-0.5.7.1 (ChristiaanBaaij)
10:29:22 <geekosaur> hm, that's ... difficult (and I just got reminded I'm headed into a call, sigh)
10:29:24 * hackagebot clash-ghc 0.5.9 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.5.9 (ChristiaanBaaij)
10:29:26 * hackagebot clash-prelude 0.9.1 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.9.1 (ChristiaanBaaij)
10:29:30 <geekosaur> it's not something you need to do often
10:30:06 <geekosaur> but again, when doing parallel processing, you need to make sure that a thread actually does something instead of returning an unevaluated expression --- that makes the thread pointless
10:30:50 <ryantrinkle> maerwald: haha, also, to throw one more kink in the works, i'm on NixOS, so FHS doesn't apply :P
10:31:00 <Byte_> Are parralel computations run in 1 thread or various threads? something about sparks right?
10:31:03 <ryantrinkle> (but, i'd very much like the library to work on non-NixOS, as well)
10:31:12 <Byte_> Also thanks for the help geekosaur!
10:31:28 <Jafet> ghc -e (calling ghc with unqualified path) sounds risky as well, it could be a different version of ghc for all you know
10:31:41 <Sindriava> And here I though using Nix would solve my woes
10:31:43 <ryantrinkle> yeah, i agree
10:31:43 <Sindriava> :(
10:31:49 <maerwald> ryantrinkle: exactly
10:31:53 <maerwald> which is their own fault
10:32:08 <ryantrinkle> Sindriava: it solves many woes; it may even help with this one - but it also reduces compatibility with "normal" linuxes :P
10:32:11 <Jafet> Also, it sounds like you want to run arbitrary input code inside a daemon, which may be a... strange design
10:32:15 <maerwald> but in order to increase compatibility, we can't even make (a lot of) assumptions about FHS
10:32:28 <maerwald> it can merely used as some sort of "fall back"
10:32:29 <Sindriava> ryantrinkle: I'm on OSX
10:32:52 <Sindriava> ryantrinkle: Problem is, cabal cannot access any system headers :/ Particularly CoreServices
10:33:27 <Cale> ryantrinkle: I've thought for quite a while that it would be really cool to have things like  makeExecutable :: FilePath -> IO a -> IO ()  which would build a binary that would resume execution of the given IO action when executed.
10:33:28 <ryantrinkle> Jafet: no, not arbitrary input code at all; just need to make sure the daemon is running code from the same lib version as the client is
10:33:39 <ryantrinkle> Cale: yes, that would be perfect :)
10:34:09 <mniip> can a package name start with a number :o
10:34:11 <Cale> ryantrinkle: Also, callCC for IO so we can save the current continuation to disk :D
10:34:11 <ryantrinkle> should just be able to stop-and-copy an arbitrary IO action and all its deps into a new executable image ;)
10:34:17 <ryantrinkle> lol
10:34:34 <ryantrinkle> that would be cool
10:36:48 <Jafet> There are universal tools to do this. (Such as the fork syscall...) They may interfere with the ghc runtime though
10:38:27 <Jafet> ryantrinkle: I suspect the only good way to do that is to send a version identifier when talking to the daemon
10:39:40 <Jafet> For example, if process C1 starts D1 and C2 decides to reuse D1, C2 and D1 could very well be using different builds of the library
10:40:23 <ryantrinkle> Jafet: yeah, that will probably be necessary
10:40:46 <aweinstock> what complications would there be with saving a continuation to disk, other than saving (stack + heap + registers + instruction pointer) to a file?
10:41:00 <ryantrinkle> aweinstock: open handles
10:41:41 <aweinstock> ah
10:41:59 <Jafet> Ephemeral state, such as file handles, sockets, registered signal handlers and alarms, shared memory mappings, etc.
10:42:10 <ryantrinkle> but, my understanding is that Emacs does something roughly like saving a continuation to disk
10:42:17 <ryantrinkle> so they must have worked around those issues
10:43:24 <geekosaur> emacs doesn't do it to that level?
10:44:15 <aweinstock> is saving the state of handles/alarms/memory-mapping doable without a kernel-level helper?
10:44:29 <aweinstock> (in a blind, general-purpose way)
10:45:05 <Jafet> If your program remembers all of them itself, it can restore them by itself.
10:45:54 <Cale> It might be hard to restore some of them
10:45:59 <geekosaur> that said, some of them can't necessarily be saved; for example, a connection to a remote server can't necessarily be saved unless the protocol provides enough information to be able to resume the protocol exchange over a new connection
10:46:09 <Sindriava> Does anyone have experience with Nix?
10:46:44 <Jafet> Incidentally, this should mean (in theory) that non-IO continuations are much easier to save
10:46:46 <ryantrinkle> Sindriava: yeah; i've been using it for about a year and a half, including in production deployments for about a year
10:47:08 <Sindriava> ryantrinkle: And any chance that you're using OSX too?
10:47:38 <Sindriava> because cabal is unusable when installed through nix on OSX
10:47:58 <ryantrinkle> Sindriava: haha, nope; although I do support my try-reflex library on OSX
10:48:19 <Sindriava> I can't find a way to tell it where to look for CoreServices.h :/
10:48:22 <ryantrinkle> Sindriava: i haven't had that experience; but, I don't use cabal-install much at all
10:48:31 <ryantrinkle> nix uses the Cabal library directly, so I mostly do things that way
10:48:39 <Sindriava> I see‚Ä¶
10:49:00 <Sindriava> So how would I go about installing the `diagrams` package without cabal and a sandbox?
10:49:20 <ryantrinkle> yeah, that sounds like it may be problematic
10:49:20 <ryantrinkle> you might want to ask in ##nix-darwin
10:49:51 <ryantrinkle> Sindriava: well, with nix, you typically specify it in your nix environment
10:50:19 <ryantrinkle> so, if you're building a package, that package will have a nix file describing it
10:50:20 <Sindriava> ryantrinkle: Ah, so instead of a cabal file I'd use a folder-local nix environment?
10:50:48 <Sindriava> I'd have to use nix-shell for that, wouldn't I?
10:50:58 <Sindriava> And thanks, I'll try the channel :)
10:51:19 <ryantrinkle> and in the nix file, it'll list diagrams in the buildDepends field
10:51:20 <ryantrinkle> Sindriava: yes
10:51:21 <ryantrinkle> when using nix, you should pretty much use nix-shell *constantly*
10:51:21 <ryantrinkle> it's by far the best way to do practically anything dev-related
10:51:44 <ryantrinkle> even for one-off builds and such, you can do: nix-shell --command "ghc --make whatever"
10:51:49 <Sindriava> Hm‚Ä¶ I don't want to throw away my zsh config though
10:52:20 <ryantrinkle> well, it may be possible to run zsh inside nix-shell
10:52:26 <ryantrinkle> but personally, i just don't worry about it
10:52:33 <ryantrinkle> i use nix-shell for building, but not for normal shell work
10:52:36 <Cale> Sindriava: iirc, the problem with installing diagrams inside nix when I was trying a few weeks ago was that their packages were sort of out of date and they didn't have updated versions of various of its dependencies that worked with 7.10
10:53:00 <Sindriava> Cale: Nah, this is different, previous package couldn't find math.h
10:53:05 <Cale> hmm
10:53:54 <Sindriava> Basically, cabal can't look for the system headers, because they're not inside nix, I'd assume
10:54:03 <xplat> the problem with installing diagrams inside of nix, if i were to try it, is that i have 32-bit linux and nix says it supports 32 bit but it is lying
10:54:49 <ryantrinkle> Sindriava: another thing you might want to try is the pure-darwin branch on copumpkin's fork
10:54:52 <ryantrinkle> might be better or worse for your problem, i'm not sure
10:55:13 <Sindriava> ryantrinkle: Is there a tutorial or something on using nix for that? I'd be glad to get rid of cabal, to be honest. I don't like it all that much
10:55:32 <ryantrinkle> Sindriava: there's not a lot in the way of good tutorials
10:55:41 <ryantrinkle> the nix manual is OK, though
10:55:48 <xplat> i still find cabal a lot easier to use than nix
10:55:57 <xplat> as annoying as cabal is
10:55:59 <Sindriava> xplat: And a lot messier
10:56:20 <Sindriava> ryantrinkle: I'll take a look, thanks :) I thought that cabal was essential to haskell development
10:56:21 <xplat> nix can be pretty messy too
10:56:38 <Sindriava> nix: Yeah, but cabal just seems broken at times
10:56:51 <ryantrinkle> cabal is easier upfront
10:56:53 <Sindriava> "oh, you fucked up. Oh well, rm -rf your .ghc"
10:57:10 <xplat> Sindriava: but that's why sandboxes
10:57:23 <ryantrinkle> nix requires an investment of time
10:57:23 <ryantrinkle> but pays big dividends, especially if you're working on a team
10:57:36 <Sindriava> xplat: Yeah, but that's no excuse.
10:57:55 <Sindriava> xplat: I'm a beginner and having to deal with this is not a good experience :/
10:58:22 <xplat> i'm thinking of inventing a new build tool for haskell but tbf i probably won't get around to it
10:58:23 <Sindriava> Especially coming from more robust tools like RubyGems (robust as in ease of use for me)
10:58:40 <ryantrinkle> Sindriava: you might want to try my try-reflex library
10:58:40 <Sindriava> Isn't Stack the future build tool?
10:58:53 <Sindriava> ryantrinkle: What does it do?
10:59:00 <ryantrinkle> obviously, it's meant for getting people set up with reflex, but you can also just add diagrams to the "packages.nix" file
10:59:13 <ryantrinkle> and see if it works
10:59:32 <xplat> Sindriava: well, if that turns out ok, then great
10:59:46 <xplat> i think it needs a more googleable name tho
10:59:59 <Sindriava> xplat: Good point.
11:00:19 <xplat> Sindriava: if you came from python you'd already be used to sandboxes
11:00:20 <Sindriava> ryantrinkle: Yeah, I've been using nix for a day, so it's kinda hard still
11:00:37 <Sindriava> xplat: That's why I didn't come from python :D
11:00:43 <Jafet> cabal is bad because ghc's dependency system is rather messy
11:00:52 <Sindriava> xplat: I noped out as soon as that Python 3 fiasco started out
11:01:03 <quintus> Sindriava: what fiasco?
11:01:23 <Sindriava> quintus: Python became an absolute pain in the ass since Python 3
11:01:35 <mniip> what are the restrictions on cabal packages?
11:01:58 <Jafet> stackage does throw out the bath-water but along with it goes the baby's toes and head
11:02:04 <Sindriava> quintus: Everytime I had to use it for anything, all the libraries were Python 2 only or Python 3 only a otherwise uncompatible and painful
11:02:09 <quintus> it did now? I don't mean to start a hissyfit, but the py3 transition was pretty anodyne
11:02:09 <mniip> er
11:02:11 <mniip> what are the restrictions on cabal package names?
11:02:45 <quintus> I mean if you jump ship every time something has a backwards-incompatable upgrade, I feel like you'd be in the water pretty often
11:03:08 <Sindriava> quintus: It's not about backwards incompatible. It's about fragmentation.
11:03:09 <ryantrinkle> reflex is my FRP system; try-reflex uses nix to get you 100% set up to use it
11:03:09 <ryantrinkle> it's meant to make things easier for beginners
11:03:48 <Sindriava> quintus: I needed to use python for something about a month ago, and half the libraries were unusable, because they were python 2 only. Maintained, but python 2 only, because Python 3 is not worth the effort for most people apparently
11:03:51 <quintus> Sindriava: okay clearly you have a pretty strong personal opinion; I don't think it'll do us any good to keep on about this.
11:03:59 <ryantrinkle> now, i don't know if you're interested in FRP or not, but it's a nix-based haskell ecosystem that is tested on Mac OS
11:04:00 <ryantrinkle> so i know it at least *kind of* works :)
11:04:00 <ryantrinkle> Sindriava: yeah, so maybe give my thing a try
11:04:00 <ryantrinkle> it's also got binary caches
11:04:00 <ryantrinkle> so you'll spend a lot less time waiting for things to compile
11:04:00 <ryantrinkle> github.com/ryantrinkle/try-reflex
11:04:00 <ryantrinkle> just clone it and run the 'try-reflex' script inside
11:04:24 <conal> ryantrinkle: any progress on a denotation?
11:04:58 <quintus> Sindriava: I'd just encourage you to at least re-evaluate the current climate, as I think it's much different than it was when 3k was released. Things have settled down quite a bit.
11:05:00 <nkaretnikov> nathan7: regarding your earlier question about (a,b) -> c -> (a,b,c), would the tuplesections extension work for you?
11:05:58 <Sindriava> quintus: There's a lot more reasons I don't like Python as a language, but thanks :) I don't mean to bash on python, I just don't think it's a good enough language for my needs. Hence, here I am
11:06:38 <ryantrinkle> conal: not yet, but I think i understood your last email
11:06:38 <ryantrinkle> conal: i haven't been able to get another solid chunk of time to work on it
11:07:14 <conal> ryantrinkle: ah, okay. good luck, and let me know if you need more clarification, hints, etc.
11:07:47 <Sindriava> ryantrinkle: So, do I understand this correctly, that by using nix, I can get rid of Cabal completely? like "uninstall cabal-install" get rid of
11:07:50 <quintus> Sindriava: nah mate no worries; we are united by haskell
11:08:39 <Sindriava> quintus: I grew up on python and then I've gone to C and when I came back, Python felt kinda‚Ä¶ Lame, to be honest. No main function, only the weird hack with __name__
11:09:18 <Sindriava> quintus: And all the __ prefixed functions were making me uneasy. There should either be first-class support for this in the language, or it shouldn't be needed
11:12:32 <supki> mniip: looking at https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Package.hs#L76, package names are hyphen-separated alphanumeric chunks containing at least one letter 
11:12:43 <quintus> Sindriava: the __ is bizarre, and I've never really liked how verbose class initialization is. I far prefer the ruby @parameter initialization. But every language has its use-case, and Python's seems to be a pretty large subset of the projects I tend to work on. I am also really impressed at how well Python source retains maintainability over time across different developers.
11:12:51 <mniip> yeah, already found that in cabal docs, thanks
11:14:29 <Byte_> Anyone know a good resources where I can learn basic concurrent programming haskell in like 2 hours
11:14:41 <Byte_> Basically how to use: MVar and forkIO in simple examples
11:15:54 <sccrstud92_> Byte_: http://chimera.labs.oreilly.com/books/1230000000929/index.html
11:16:19 <Jafet> Are there libraries for type inference? Preferably, something similar to haskell98 or -2010 (but I don't need fundeps, GADTs or much in the way of kinds)
11:17:00 <Jafet> So far, the closest thing I've found is libraries such as unification-fd, which can be used as a component of type inference
11:17:13 <Byte_> sccrstud92_: Before I dive in, is this for beginners like myself? :p
11:17:38 <Sindriava> Byte_ You could give "Everything I wish I knew learning haskell" a look
11:17:40 <sccrstud92_> Byte_: depends on how "beginner" you are
11:17:59 <sccrstud92_> ^ that is good as well
11:18:10 <Byte_> I don't know how to say how much of a beginner I am
11:18:16 <Jafet> Arguably, "classical" concurrent programming with locks (or MVars) is not something you should expect to learn in two hours, since it is a complicated subject by itself
11:18:26 <Byte_> O
11:18:39 <Byte_> I'm only looking at the very basic idea of it and how it works
11:18:49 <Byte_> Learning how to do it with dummy programs is enough
11:19:12 <Byte_> Also I know all basic haskell concepts + IO + Monads
11:19:16 <Jafet> Unless you know that stuff already, in which case the haskell libraries are quite similar to concurrent programming in other languages
11:19:19 <Byte_> So im no that much of a rookie
11:21:31 <aweinstock> Byte_: are you familiar with pthreads-style concurrency, from C?
11:21:49 <Jafet> sccrstud92_: I'm (pleasantly) surprised that this book exists
11:22:17 <sccrstud92_> Jafet: its pretty much "the book" on concurrency and parallelism in haskell
11:22:29 <Jafet> It does look right, although reading it will take a bit more than two hours
11:22:35 <aweinstock> Byte_: if so, forkIO is "just" pthread_create, but taking an IO action instead of a function pointer
11:22:36 <voidzero> and lazyness btw
11:23:36 <sccrstud92_> Jafet: agreed, but itss covers much more than MVars and forkIO, which is all Byte_ wanted
11:23:41 <Byte_> aweinstock somewhat
11:24:43 <Byte_> I actually have an example program with me that uses forkIO and some MVar functions
11:24:53 <Byte_> Maybe someone here can explain that to me instead!
11:25:39 <aweinstock> Byte_: link to the program?
11:25:49 <Byte_> Here is the link: http://lpaste.net/6876624300279857152
11:26:23 <Byte_> Its a function which applies a unary function to every element in a simple binary tree
11:26:46 <Byte_> first one is simple version while second use uses concurrency
11:27:06 <Jafet> Uh, is that code actually parallel?
11:27:31 <Jafet> (forkIO $ seq v' (putMVar res v')) looks very suspicious.
11:28:13 <Byte_> What is suspicious about it?
11:28:23 <aweinstock> why is there a "let v'"... and later "v' <-"..., with different things?
11:28:25 <Byte_> Also FYI im not sure this code is correct :p
11:29:17 <Byte_> v' given to thread? then we simply replace v' with result of computation?
11:29:48 <Jafet> Since v' is not actually evaluated in the forked thread, its evaluation is sequential with the main thread.
11:30:02 <Byte_> o.O
11:30:13 <Byte_> seq -> pseq fixes this?
11:31:00 <Jafet> No, that has the same behaviour. To get parallelism out of forkIO, the evaluation needs to happen in the IO argument. Here, it happens outside
11:31:09 <Byte_> So seq isnt sufficient to evaluate the putMVar?
11:32:54 <Byte_> I was hoping the code was correct so one you of could explain it to me haha
11:32:58 <Jafet> In that code, only (putMVar res v') is run in the new thread. The evaluation of v' is not.
11:33:33 <Byte_> hmm
11:33:43 <Byte_> How would you fix it?
11:33:46 <mniip> sigh, I always forget, s -> (s, a) or s -> (a, s)
11:34:11 <Sindriava> mniip: If you're talking about State, it's the second one
11:34:19 <Byte_> mniip: remember ass backwards lol
11:34:47 <mniip> so which is it, lol
11:34:57 <Sindriava> TIL I forget too
11:34:59 <Byte_> mniip: ignore me lol...
11:34:59 <Sindriava> Gonna take a look
11:35:21 <Sindriava> > :t runState
11:35:22 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
11:35:29 <Sindriava> @t runState
11:35:29 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
11:35:42 <Jafet> To move evaluation into IO, use the "evaluate" action: (do v' <- evaluate (f v); putMVar mv v')
11:35:48 <mniip> s -> (a, s)
11:35:50 <Sindriava> dammit
11:35:53 <Sindriava> runState :: State s a -> s -> (a, s)
11:35:55 <Sindriava> There
11:35:56 <mniip> which is somewhat weird
11:36:03 <Sindriava> mniip: It's not
11:36:16 <Sindriava> Stateful computation returns a value
11:36:20 <mniip> because s -> (a, s) would make it a joined composition of a profunctor and a bifunctor
11:36:21 <Sindriava> plus a state
11:36:23 <mniip> er
11:36:31 <mniip> s -> (s, a) would do that
11:36:37 <Byte_> Jafet: where would that line go?
11:36:46 <Sindriava> mniip: Good point.
11:36:55 <Byte_> :t evaluate
11:36:56 <lambdabot> a -> IO a
11:37:04 <Sindriava> mniip: I remember it like "You might not want the new state, but you probably always want the value"
11:38:09 <Sindriava> Damn Nix, I should have kept haskell platform installed for now :D
11:38:15 <mniip> Sindriava, the inverse is true too
11:38:23 <mniip> look at how many stateful computations result in ()
11:38:40 <Sindriava> mniip: Yeah, but that's not really useful
11:38:50 <mniip> eh
11:38:59 <aweinstock> Byte_: I think I fixed the concTreeMap example: http://lpaste.net/135307
11:38:59 <Sindriava> mniip: What I meant was that the result value is probably more important than the state
11:39:02 <Sindriava> IF there is one
11:39:06 <Sindriava> mniip: So it comes first
11:39:20 <Sindriava> mniip: Not saying it's a good mnemotechnic :D
11:39:33 <Byte_> aweinstock: Thanks heaps!
11:39:47 <Byte_> aweinstock: Mind going through it with me explaining each step?
11:40:16 <Sindriava> mniip: Other intuition might be that the State monad makes the explicit state go away
11:40:25 <Sindriava> mniip: So it gets "cut off" the line of code
11:40:58 <aweinstock> Byte_: what questions do you have about it that the comments don't address?
11:41:48 <Byte_> aweinstock: I don't know what any of the concepts are :p
11:42:04 <Byte_> What exactly is an MVar? like an environment where the execution happens?
11:42:17 <mniip> MVar is a reference
11:42:28 <aweinstock> an MVar is container with a mutex
11:42:31 <Byte_> to what?
11:43:00 <mniip> aweinstock, a mutex?
11:43:04 <mniip> more like a semaphore
11:43:47 <Byte_> So what is the MVar doing for us here?
11:43:49 <aweinstock> it can be empty or have 1 item; putMVar blocks until it's empty, and puts an item into it; takeMVar blocks until it's full, then removes the item
11:44:21 * hackagebot messagepack-rpc 0.2.0.0 - Message Pack RPC over TCP  http://hackage.haskell.org/package/messagepack-rpc-0.2.0.0 (rodrigosetti)
11:44:24 <aweinstock> it's a synchronization/communication primitive
11:44:37 <aweinstock> one thread puts it's result in, the other thread takes the result out
11:45:03 <aweinstock> (and the mutex/semaphore aspect of it ensures that the result isn't taken out before it's put in)
11:47:17 <aweinstock> found the documentation: http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Concurrent-MVar.html
11:47:22 <Byte_> aweinstock: btw I am sure that this problem can be solved using only forkIO, seq and MVar
11:47:40 <Byte_> aweinstock: Are you sure other solution was incorrect?
11:48:46 <Byte_> Also I forgot what >>=, does...does it take its input from left and give it to its right?
11:48:53 <Byte_> :t (>>=)
11:48:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:49:16 <mniip> @undo k >>= f
11:49:16 <lambdabot> k >>= f
11:49:17 <aweinstock> It might've been correct (as far as returing the correct mapped tree), but it wasn't doing work in multiple threads
11:49:21 <Jafet> I was also going to mention that concurrency using forkIO and semaphores is complicated and error-prone, but it seems to have been shown already
11:49:23 <mniip> @undo k >>= \x -> f x
11:49:23 <lambdabot> k >>= \ x -> f x
11:49:42 <mniip> oh
11:49:44 <mniip> it's the opposite
11:49:47 <mniip> @do k >>= f
11:49:47 <lambdabot> do { a <- k; f a}
11:50:09 <Byte_> Jafet: Yeah that is clear
11:51:19 <aweinstock> Byte_: in this context, >>= is IO sequencing, "concTreeMap f l >>= putMVar l'" is the same as "do { tmp <- concTreeMap f l; putMVar l' tmp}"
11:51:22 <Byte_> aweinstock: Also your solution, is it only doing left branch in a thread?
11:51:54 <aweinstock> It's doing the left branch in a new thread, and the right branch in the old thread
11:52:14 <Byte_> By old thread you mean current thread?
11:52:33 <Byte_> or previous thread
11:52:40 <aweinstock> the right branch is calculated in the same thread as the caller
11:52:42 <Byte_> Yeah I get it
11:52:52 <Jafet> Since every node has a left branch, it starts a new thread for each node. (Which is actually even better than the code I gave, because now there is no waiting.)
11:52:55 <Byte_> And so is: f v
11:53:36 <Byte_> And this function correctly always returns the right answer?
11:53:44 <Byte_> In other words, it is deterministic?
11:54:04 <aweinstock> unless I've made a mistake
11:54:28 <Jafet> It's easier to answer those questions if you use `par` instead of forkIO.
11:54:45 <Byte_> Yeah I know
11:55:42 <Jafet> In this case, no two threads share an MVar, so the results are deterministic.
11:55:49 <Byte_> Alright, thank you aweinstock, Jafet and mniip for all the help!
11:56:37 <Jafet> (Of course, it's possible that it deterministically always gives the wrong answer)
11:56:44 <maerwald> is the StrictPragma in 7.10?
11:58:28 <deathrider> hello anyone on
11:58:36 <Denommus> yes
11:58:43 <deathrider> hows it going
11:58:46 <Cale> deathrider: There's 1549 users in the channel. Someone's here :P
11:59:14 <deathrider> yeah just a few cale
12:00:20 <Cale> maerwald: no
12:00:47 <Cale> maerwald: You can check which language extensions are supported with  ghc --supported-languages
12:01:06 <frerich> deathrider: It's like in the movies; you come into the haunted house and ask 'Hello, anyone here?' and get just a single distant howling. In reality, the #haunted-haskell house is filled with 1500+ functional ghouls who will jump on you with even more suggestions on how to do something.
12:01:11 <maerwald> Cale: I don't have 7.10 installed and that will probably stay for a while
12:01:18 <Cale> ah
12:02:18 <codygman> Is there a good way for me to estimate how may connections I should open in a mysql pool?
12:02:18 <Cale> Honestly, I think this extension is a bit crazy, and will only result in more pain trying to figure out what the heck is going on performance-wise.
12:02:23 <Jafet> Some of us are just phantom types, though
12:03:25 <mniip> if I'm writing a transformer, in the functor instance, should I use specializations of fmap to make the process apparent
12:03:36 <mniip> or is 'fmap (fmap (fmap (fmap (fmap f)))) x' okay
12:03:38 <maerwald> Cale: I cannot follow why that would be the case. I can only imagine that things break or behave differently than before.
12:04:27 <Cale> If you're using so many bang patterns everywhere that you want an extension to turn them on automatically, you're probably using waaaaay more bang patterns than is required.
12:04:44 <maerwald> that's a broad statement that I cannot follow either
12:04:51 <Denommus> mniip: you clearly should use (((((f<$>)<$>)<$>)<$>)<$>) x
12:05:01 <mniip> well
12:05:11 <mniip> I'm looking at instance Functor StateT s m
12:05:11 <Denommus> mniip: (I'm just kidding)
12:05:15 <mniip> they're not even using fmap
12:07:03 <Cale> maerwald: Well, I only have my own experience to go on, but I've seen certain people use bang patterns where they weren't needed. Any case where you're already pattern matching on something, you don't need to put a bang pattern on it, for instance, because that's already strict.
12:08:02 <maerwald> Cale: it's about "strict by default" and providing that is a step forward
12:08:13 <Cale> It's not the same as making the evaluator strict
12:08:49 <deathrider> whats the best program to start learning 
12:09:19 <Cale> deathrider: Just starting out in Haskell, or do you know the basics already and are looking for something interesting to do?
12:09:37 <aweinstock> Byte_: I tested the concurrent map stuff with quickcheck, and it seems to be correct: http://lpaste.net/135308
12:09:59 <Cale> deathrider: If you're just starting out, you might enjoy this course and its exercises: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
12:10:30 <ion> deathrider: https://github.com/bitemyapp/learnhaskell/blob/master/README.md#how-should-i-learn-haskell
12:10:55 <Cale> maerwald: But also, having contexts where things are sorta-kinda-strict-by-default mixed in with everything else, will be really annoying when trying to read code and understand its performance behaviour.
12:11:22 <xplat> i agree about StrictPragma
12:11:41 <maerwald> Cale: that's not a new problem really
12:11:47 <maerwald> that's what we already have
12:12:02 <xplat> with Cale
12:12:15 <Cale> But it's not. There's no magic translation going on of that scale.
12:13:57 <xplat> even with porting programs from other languages to Haskell i don't think StrictPragma is going to be useful
12:14:11 <Cale> There's some strictness analysis, which is quietly making things stricter when the compiler can locally prove that it's beneficial, but that's not affecting the semantics of the code at all, it's just moving evaluations that were certainly going to happen such that they happen earlier.
12:14:57 <xplat> well, it can affect semantics of code with unsafePerformIO
12:15:04 <xplat> e.g. trace
12:15:14 <maerwald> ah come one... it's like saying "don't use too many IO functions". those are things that you can tell haskell beginners so they don't mess up their program design
12:15:32 <Cale> I've been programming in Haskell for a long time now. These things are actually true.
12:15:35 <maerwald> other than that, I don't see a good counter argument
12:16:05 <Cale> I don't know whether or not I can convince you they're true without going over a large amount of concrete code in detail.
12:16:44 <maerwald> or almost like saying "unsafePerformIO is bad and probably not useful" which is a bit oversimplified
12:17:07 <maerwald> you can abuse it
12:17:07 <maerwald> and misuse it
12:17:09 <maerwald> and that's it
12:17:14 <Cale> That's actually true, given that you put the word "probably" in there
12:17:34 <xplat> maerwald: there are some good uses for unsafePerformIO, but that doesn't mean there should be a pragma to automatically put unsafePerformIO all over your program
12:17:34 <Cale> The chances of unsafePerformIO being useful in any given project are indeed incredibly low.
12:17:40 <maerwald> but I don't think haskellers need baby-sitting
12:17:58 <Cale> I need baby-sitting, that's why I program in Haskell ;)
12:18:01 <voidzero> only the full time dads do
12:18:10 <voidzero> and moms
12:18:14 <maerwald> Cale: I don't
12:18:25 <xplat> maerwald: er, fine, so use racket
12:18:27 <Cale> I'm going to screw things up regularly, and I want the type system to be there to tell me when I do.
12:18:34 <maerwald> xplat: why would I?
12:18:39 <Cale> (for one)
12:18:58 <xplat> maerwald: it won't babysit you, and is comparably expressive to Haskell
12:18:58 <Welkin> I want to do as little work as possible
12:19:02 <maerwald> Cale: errr... this is about strictness, not about type errors. You can mess up with laziness in 1000 ways as well
12:19:05 <Welkin> that means letting the compiler do more work for me
12:19:12 <Jafet> Laziness has some nice properties that aren't just for newbies, such as completeness and compositionality
12:19:19 <Cale> Well, fair enough, I was referring to unsafePerformIO in that case.
12:19:25 <maerwald> Cale: so I could say: don't use laziness, because there are pitfalls (actually, a LOT)
12:19:30 <maerwald> how does that make any sense?
12:19:31 <Cale> Laziness is almost always the correct default.
12:19:53 <maerwald> except when it isn't
12:19:58 <voidzero> like with Text
12:21:02 <Cale> Well, there are places where strictness is needed, but they're generally confined to specific small areas, where you're summarizing a large number of separately evaluable parts into a "small" result (with few separately evaluable parts).
12:21:26 <maerwald> Cale: "generally", "probably"... 
12:21:54 <xplat> the extra pitfalls of laziness over strictness are much more limited than vice versa
12:21:55 <Cale> When I say "generally" there, I mean "always"
12:22:04 <voidzero> Cale could be a politician :P
12:22:20 <maerwald> Cale: I don't believe you there, definitely not
12:22:41 <Cale> (Which is sort of why foldl' is so successful, because it covers all the cases where you're doing that collapse iteratively)
12:22:42 <maerwald> otherwise GHC developer wouldn't be pushing for it
12:23:01 <xplat> laziness can only leak an amount of space or time that is linear in the runtime of the strict version
12:23:03 <maerwald> including SPJ
12:23:31 <xplat> strictness can leak *infinite* time or memory compared to the lazy version
12:23:45 <Cale> SPJ is a pretty neutral guy these days when it comes to what things get added to the compiler, given that someone's willing to do the work
12:24:11 <maerwald> Cale: I've seen his talks myself and have a rough idea about his opinion
12:24:24 <Cale> and I don't think it's guaranteed that all the GHC devs are equally experienced
12:24:44 <athan> Is there a Semiring class in base somewhere?
12:24:50 <Cale> athan: no
12:24:50 <Jafet> Note that being a ghc extension doesn't guarantee that something is a good idea
12:25:09 <maerwald> Jafet: agreed
12:25:11 <xplat> *cough* ImplicitParameters
12:25:11 <Cale> Yeah, GHC has had a number of very questionable extensions
12:25:17 <athan> Cale: Tekmo on a reddit post alluded to such a class, do you know which one they were speaking of?
12:25:34 <Jafet> The "semiring" on hackage, presumably
12:26:00 <athan> Jafet: Okay cool, I'm updating it now, but it has a <4 base constraint, so I was wondering if anyone actually used it
12:26:16 <maerwald> Jafet: but whether that actually is a bad idea will have to be discovered yet, IMO. People haven't (mis-)used it yet, so...
12:26:19 <Jafet> Or, maybe not, it seems quite localised
12:26:21 <Cale> There's one here: http://hackage.haskell.org/package/algebra
12:26:44 <Cale> http://hackage.haskell.org/package/algebra-4.2/docs/Numeric-Algebra-Class.html#t:Semiring
12:27:27 <Jafet> Nevermind, I thought it was in its own package
12:27:38 <athan> Ahh thank you Cale :)
12:28:44 <Jafet> Can't you implement StrictPragma using TH?
12:29:24 <maerwald> Jafet: I've read something like that at a random SO post, but I like to keep far away from TH
12:29:49 <Cale> Jafet: Using a sufficient amount of QuasiQuoter shenanigans, you can implement just about anything with TH
12:29:51 <Ben____> @pl f x = \x -> x + 1
12:29:51 <lambdabot> f = const (1 +)
12:30:03 <Jafet> Granted, that's a file-spanning quasiquote
12:30:06 <JEntrep> which channel is for off topic but haskell related discussions again?
12:30:26 <Ben____> @pl f x = \x -> putStrLn $ intercalate "\t" x
12:30:26 <lambdabot> f = const (putStrLn . intercalate "\t")
12:30:29 <Cale> JEntrep: #haskell-blah is for not-Haskell related discussions with Haskell people.
12:30:41 <JEntrep> Cale, that's the one. thanks.
12:31:01 <xplat> with a file-spanning quasiquote you could implement a PHP compiler.  which is probably a good enough reason not to support {-# LANGUAGE PHP #-}, not that one was needed
12:32:02 <Cale> heh
12:32:24 <xplat> although with Simon Marlow at Facebook, who knows?
12:33:13 <xplat> speaking of which, haxl looks pretty cool
12:35:04 <Cale> There are a lot of optional things which can still result in maintenance hell though. I think if I came upon a module in production which was using Strict/StrictData, the first thing I'd be tempted to do as soon as understanding any sort of performance issues surrounding that code is to turn that extension off, and go through the code putting strictness annotations in by hand in a sensible fashion where it was apparent
12:35:04 <Cale>  they'd be needed.
12:35:14 <Jafet> xplat: what's wrong about implicit params?
12:35:33 <Cale> as soon as understanding any sort of performance issues surrounding that code {became necessary}
12:36:14 <Jafet> I suppose that people dream of writing ocaml code in haskell
12:36:30 <Cale> As it is, I'm much more used to lazy evaluation than strict now though.
12:36:44 <xplat> Jafet: the reader monad does the same thing with less magic and easier reasoning
12:37:01 <Cale> So it's *weird* for me to program in a setting where things are strict by default, and my expectations about performance are all a bit off :)
12:37:56 <xplat> Cale: i can't say i actually find a true strict evaluator weird, but as you point out the results of StrictPragma are not quite that
12:38:26 <Cale> Yeah, if it's really a strict evaluator, it's certainly less weird than what that Strict extension is going to get you.
12:40:35 <max12345> hello, I've just read around a bit after hearing that haskell was a bit different than other languages. I'm not entirely convinced that's for the better though, is there an example of something that haskell does really well compared to other languages?
12:40:56 <Cale> max12345: Concurrency
12:41:08 <max12345> ok let me read up on that then :)
12:41:10 <max12345> thanks
12:41:36 <Cale> max12345: I mean, it does a lot of stuff better than the 10 most popular languages to write stuff in industrially.
12:41:57 <Cale> max12345: To the point where naming any one feature seems kind of ridiculous, but there you go :)
12:42:13 <Jafet> Reading the StrictPragma page, the dynamic semantics seem a bit hairy
12:42:27 <xplat> concurrency, compositionality, code reuse, modularity, abstraction ...
12:42:52 <Welkin> max12345: it doesn't make you want to jump out of a window when you program with it
12:43:10 <max12345> how do you program :D
12:43:56 <maerwald> xplat: today, it isn't really about "either or" it's rather about if we want laziness by default or strictness by default. There are pros and cons for both
12:44:00 <xplat> max12345: on the ground floor, one hopes
12:44:01 <Cale> Jafet: I worry that beginners are going to find and use that extension and make a worse mess than they had to begin with, and be even more confused and frustrated rather than just learning how to figure out where their program needs strictness.
12:44:01 <Welkin> max12345: in haskell whenever possible
12:44:27 <merijn> I argue that lazy by default is the right way to go, because selectively making code strict is easier than selectively making code lazy
12:44:42 <Cale> merijn: I agree.
12:44:54 <maerwald> merijn: yeah, that might be true... I have no strong opinion there however and it seems to be a hot topic
12:45:24 <xplat> also because code that should be stricter is a lot more useful relative to its ideal version than code that should be lazier
12:45:29 <kuznero> Hi All!
12:45:31 <merijn> The reason is, that the only problem with laziness is space leaks due to thunk build up, inserting a strictness annotation there is guaranteed to 1) avoid thunk buildup and 2) never do more work than the strict version
12:45:39 <Cale> The greater compositionality which comes from laziness is fragile under the operation of making things stricter. If some component you need is too strict, you're forced to rewrite it. If some component is too lazy, you can force evaluation later.
12:46:09 <maerwald> merijn: I'm however interested how/if Idris will grow
12:46:24 <merijn> But, selectively adding a lazy annotation to "map (+1) [1..1000000]" means that as soon as you peer "through" that one level of laziness, you still do the full strict map
12:47:15 <Jafet> From what I understand of the semantics, something like (f x = replicate 10 x) won't evaluate to WHNF even if StrictPragma is on
12:47:26 <maerwald> having laziness as part of the type signature sounds like quite a neat idea
12:47:29 <platz> is strictness more applicable to algorithms vs application code?
12:47:37 <platz> pseudocode seems to be written strictly
12:47:40 <xplat> if anything i'm interested in whether 'lazier than lazy' evaluators can be useful in practice
12:47:58 <Cale> Idris is nice, but what I really want is lazy Idris with coherent type classes. Somewhat unfortunately, I've heard that figuring out the interaction between laziness and the evaluation of open terms in dependent type checking is tricky. Maybe that's only somewhat unfortunate though, because if it's tricky, that also makes it a viable research topic.
12:47:58 <merijn> maerwald: I'm working on a prototype lambda calculus evaluator that has checked exceptions and strictness typing (i.e. strictness polymorphic code would be possible :))
12:48:53 <tulcod> Cale: just wait for a funded PhD project on this exactly... it's sufficiently specific but also sufficiently "free"
12:49:24 * hackagebot stack 9.9.9 - The Haskell Tool Stack  http://hackage.haskell.org/package/stack-9.9.9 (borsboom)
12:49:40 <Ben____> @pl readFile $ x ++ y
12:49:40 <lambdabot> readFile (x ++ y)
12:49:54 <Haskellfant> 9.9.9? wtf
12:50:15 <tulcod> yeah that's quite a jump. i read the project announcement like yesterday. must me a mistake
12:50:21 <Cale> platz: Pseudocode isn't sufficiently well specified to be either one :)
12:50:30 <xplat> who is borsboom?
12:50:34 <Haskellfant> yeah 0.1.1 was just uploaded today
12:50:50 <quintus> wow: 0.0.0, 0.0.1, 0.0.2, 0.0.2.1, 0.0.3, 0.1.0.0, 0.1.1.0, 9.9.9
12:50:54 <platz> fair enough
12:50:58 <Haskellfant> I wondered that aswell
12:51:02 <Cale> platz: Though most people are familiar with strict imperative languages and write pseudocode that reflects that
12:51:38 <xplat> did some random person git clone it and upload to hackage?
12:51:59 <tulcod> Cale: to be fair you could say the same about functional stuff... the pseudocode that models functional programs is generally a strict subset of all pseudocode :)
12:52:02 <Haskellfant> I think it's manny-fp https://github.com/manny-fp
12:52:12 <Cale> xplat: He shouldn't have been allowed to, if so
12:52:36 <Cale> borsboom also uploaded the previous version
12:52:52 <Cale> and the one before that
12:52:55 <tulcod> (emanuel) borsboom also sent the announcement to haskell-cafe
12:53:18 <xplat> hm, yeah, seems like a recognized maintainer
12:53:21 <Cale> tulcod: Sure :)
12:53:36 <xplat> don't know what's up with 9.9.9 then
12:53:48 <max12345> uhm, as I'm reading this thing I notice a good amount of not introduced symbols like :: >>= and such, where can I find an overview over those?
12:54:01 <Cale> max12345: What are you reading?
12:54:15 <Jafet> stack-9.9.9 is identical to the previous version, so it's probably a clerical error.
12:54:16 <tulcod> xplat: maybe the git source has that by default, and he forgot to update the version
12:54:24 * hackagebot stack 0.1.1.0 - The Haskell Tool Stack  http://hackage.haskell.org/package/stack-0.1.1.0 (borsboom)
12:54:32 <tulcod> there we go :)
12:54:33 <max12345> "tackling the awkward squad"
12:54:34 <xplat> :: is used to separate an identifier or expression from a type signature
12:54:59 <Cale> max12345: Uh, if you don't know any Haskell yet, I'm not sure that's the place to begin
12:55:35 <Cale> max12345: This course is quite a good intro which is recommended for most people: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
12:55:41 <xplat> yeah "tackling the awkward squad" is an academic paper for people who were experts on functional programming in like 1990
12:56:49 <max12345> it was just one of the first google results...
12:56:51 <xplat> or 1995 or something.  it's not really so useful for people who are learning haskell as their first functional language, or even people learning haskell in modern times in general
12:58:00 <tulcod> max12345: out of interest, for what search phrase?
12:58:10 <xplat> google does some strange things sometimes ...
12:58:34 <max12345> let me check the history...
12:58:49 <Cale> max12345: But anyway, yeah,  x :: t  is read as "x has type t", and it can appear as a declaration, informing the compiler that a certain variable has (or ought to have) the given type, or as an expression form, providing similar information to the compiler for a subexpression.
12:59:38 <max12345> oh no
12:59:40 <max12345> better yet
13:00:00 <max12345> it's under "getting started" in the haskell wiki for "concurrency"
13:00:05 <max12345> *enty
13:00:08 <max12345> *entry
13:01:23 <Cale> max12345: (>>=) is overloaded, and means different things depending on the types of its arguments, but generally x >>= f means something along the lines of: the computation which first runs the computation x, obtaining some result v, and then runs the computation f v, producing its result as its own.
13:02:13 <Cale> So for instance, x might be a parser, and x >>= f would be a parser which parses the beginning of its input using x, and then applies the function f to the parsed result in order to obtain another parser which parses the rest of the input.
13:02:16 <max12345> oh ok that makes sense
13:03:05 <tulcod> max12345: two major introductory resources to haskell are Learn You A Haskell and Real World Haskell
13:03:12 <tulcod> fwiw
13:03:43 <max12345> ty :)
13:04:17 <Cale> max12345: There's also a useful guide to starting out here: https://github.com/bitemyapp/learnhaskell
13:04:54 <tulcod> max12345: i think generally people would agree that a good guide to starting with haskell is "just write some stuff, run into problems, lookup manuals, learn, continue writing stuff, repeat"
13:05:21 <Cale> max12345: That'll also point out that there's an IRC channel called #haskell-beginners which is a study group associated with those resources, but don't be afraid to ask beginner questions here also (the name of that IRC channel actually kind of bothers me)
13:05:27 <tulcod> though somehow a lot of people end up learning category theory in order to read/write a file
13:05:51 <Cale> tulcod: Well, the truth is maybe somewhere in between?
13:05:55 <tulcod> maybe
13:06:25 <Cale> I think it can be good to start out just using Haskell as a sort of calculator -- typing expressions into GHCi and avoiding real world programming until you have the basics down.
13:06:42 <merijn> As someone trying to learn CT it's not very helpful for reading/writing files >.>
13:06:57 <DNoved1> Does anyone else read '>>=' as push into? That's the memnotic I use.
13:07:08 <tulcod> DNoved1: nice one, thanks
13:07:30 <maerwald> DNoved1: Brian Beckman said "shove operator" or something like that
13:07:39 <xplat> merijn: that depends.  if you use the original 'iteratees' ... ;)
13:08:11 <Cale> btw, sitting through Brian Beckman's bit on monads was one of the most teeth-grating experiences I've ever had :D
13:08:18 <xplat> i read it as 'semicolon'
13:09:04 <tulcod> xplat: i guess "pipe" kinda applies
13:09:23 <tulcod> but then i'm getting into arrow territory
13:09:24 <edwardk> @remember wadler Whereas the power of Lisp is that it is relatively easy to define new language features, the power of lazy functional languages is that one doesn't need to. -- https://rkrishnan.org/files/wadler-1985.pdf
13:09:24 <lambdabot> Nice!
13:09:58 <xplat> actually that's sort of a lie, i really don't pronounce it at all in my head and i'm at a loss when i try to talk to people about it without a whiteboard ...
13:10:47 <Cale> I would say "x bind f" for x >>= f
13:11:07 <tulcod> i always have to throw up a little bit in my mouth when people write down code with a pen or say it out loud. it's a weird reflex that i cannot do anyhting about. code is something you write or read on a computer, period.
13:11:27 <maerwald> Cale: haskellers are very good at nitpicking
13:11:40 <Cale> tulcod: I think one of the advantages of Haskell is that you can actually write a significant amount of code on a napkin at times
13:11:43 <maerwald> which has some pros to it, but sometimes... ;)
13:11:57 <xplat> people are computers, we're just not very good at general-purpose computing
13:12:31 <maerwald> DNoved1: maybe say "push result into"? You don't really push the effect into it
13:12:33 <mmaruseacph2> tulcod: by that logic, code should only be written to be compiled and run; no tutorials, no blogs, no manuals
13:12:50 <tulcod> mmaruseacph2: i am not following your logic
13:12:53 <codygman> Has anyone written mysql pooling code to add connections to the pool as needed?
13:13:01 <tulcod> mmaruseacph2: written on a computer doesn't imply that you can only write to a compiler
13:13:13 <mmaruseacph2> I misread, ignore
13:13:18 <tulcod> okay, will do
13:13:25 <xplat> tulcod: why should it make a difference, when communicating code to a human, what medium you use?
13:13:28 <mmaruseacph2> I read the ending as "you can only write to compile"
13:13:46 <max12345> lots of semantic helps are awkward when pronounced
13:14:05 <DNoved1> maerwald: Yah, that's sortof how I think of it, except the result part is implicit in my mind. I like to think of the effect part as being threaded through.
13:14:10 <tulcod> xplat: i don't know but it makes me sick to do it with any kind of pen or pencil
13:14:41 <maerwald> DNoved1: I'd say the effect is just executed, not threaded
13:14:45 <tulcod> (except when a digital pen is your favourite coding HID)
13:15:30 <maerwald> DNoved1: but when we say "push result into" we don't really account for the fact that the stepping function might be ingored depending on the effect... so we and up with "maybe push result into" xD
13:15:42 <maerwald> s/and/end/
13:16:23 <tulcod> maerwald: but now you're just accounting for the various monads you know
13:16:35 <DNoved1> maerwald: Well the reason I like to think of it as threaded is because inevitably you're creating a value which can be taken apart for its value and effects. But you could also just ignore the end result altogether thanks to lazyness, so I think of the monad as weaving together the effect and result.
13:17:44 * maerwald thinks of a painting showing a monad weaver
13:18:05 <maerwald> somehow edwardk is part of that crazy picture
13:18:09 <cpa> hi guys, just got a new macbook, what's the prefered way to install haskell on osx? Is https://ghcformacosx.github.io/ good? Should I go for stackage or haskell-platform?
13:18:36 <aupiff>  https://ghcformacosx.github.io/ worked well for me
13:18:48 <aupiff> I used it to get 7.10
13:19:04 <aupiff> haskell platform for mac is still on 7.8 I believe
13:19:23 <tommd> Is the state of Mac such that you can't just wget from haskell.org/ghc and bootstrap cabal?
13:19:49 <tommd> I hear these conversations all the time and it is part of why I expect to avoid OSX for my next system.
13:20:02 <cpa> aupiff: thanks, I'll try that then
13:20:03 <aupiff> haven't tried that. on linux or mac
13:21:15 <cpa> tommd: I'm a noob when it comes to PATH and stuff, and had some pretty bad experiences before, so I'm asking
13:21:57 <sm> the stack binary for OSX should be enough to get started
13:22:58 <bernalex> what was the arrows that will do equivalent of map snd & map fst called?
13:23:15 <merijn> first and second? :p
13:23:17 <merijn> :t first
13:23:18 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
13:23:21 <merijn> also
13:23:24 <bernalex> AH
13:23:26 <merijn> :t lmap -- I think?
13:23:27 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
13:23:28 <xplat> really my idea for a build tool was much more ambitious than stack in some ways
13:23:31 <merijn> ah, wrong map
13:23:34 <lamefun> Are there downsides to ignoring String completely and using Data.Text for everything?
13:23:36 <bernalex> I first thought it was right & left, but that's for eithers. first & second was what I was looking for indeed.
13:24:02 <xplat> no such thing as upper bounds would be supported at all, instead there would be migrations for older code
13:24:25 * hackagebot xcp 0.1.0.1 - Partial implementation of the XCP protocol with ethernet as transport layer.  http://hackage.haskell.org/package/xcp-0.1.0.1 (ChristianGosch)
13:24:47 <bernalex> merijn: is there a first/second that can be different types?
13:25:03 <bernalex> (a, b) -> (a -> c) -> (c, b)
13:25:08 <bernalex> (a, b) -> (b -> c) -> (c, c)
13:25:09 <xplat> without upper bounds you cannot have cabal hell
13:25:10 <bernalex> ?
13:25:27 <bernalex> right in Data.Graph.Inductive.Query.Monad lol
13:25:56 <bernalex> oh! ^>> ^<<
13:26:16 <Jafet> Mac OS is a bit... special because you need to install a working C toolchain first, which confuses many Mac users
13:26:56 <maerwald> xplat: and sane distros try to avoid upper bounds in their dependency graph, for good reason... instead they make "branches" or "releases" or deprecate/patch packages
13:27:10 <maerwald> with haskell, that isn't all that easy
13:27:35 <xplat> maerwald: yeah, that's why migrations
13:28:07 <xplat> maerwald: they will auto-patch old code to run with new libraries
13:28:18 <maerwald> woot
13:28:56 <xplat> it's something i can just about imagine making work with haskell, not a chance with anything else :-/
13:29:19 <xplat> well, maybe with ML too
13:29:26 <maerwald> if you can get a success rate better than 5% I'd be surprised
13:29:56 <Jafet> Presumably the library author defines the migrations?
13:30:10 <xplat> Jafet: yeah
13:30:17 <bernalex> oh wait second should work
13:30:41 <maerwald> Jafet: well, that's effectively branching
13:30:44 <Jafet> Well then, by the fundamental law of software development it will work in theory
13:30:54 <xplat> maerwald: technically i only need to beat the success rate for upper bounds, so it doesn't have to be that spectacular ;)
13:31:44 <maerwald> Jafet: and that sort of branching is what the C-world does (either with actual branches or with a crapload of ifdefs)
13:31:56 <maerwald> but it isn't that common in the haskell world
13:32:03 <xplat> er, the success rate for a mixture of 'no upper bounds' and 'no attempt to avoid being used with backward-incompatible libraries'
13:32:21 <xplat> maerwald: you're thinking the wrong library author
13:32:54 <xplat> maerwald: it's the author of the library being depended on who defines migrations
13:33:57 <maerwald> mh, still cannot imagine how that can work with realworld code
13:34:05 <maerwald> except for trivial changes
13:34:37 <maerwald> e.g. you _remove_ a data type... and require all your users to remodel something
13:35:13 <maerwald> that happens a lot in big libraries (thinking of gtk+ for example)
13:35:46 <xplat> maerwald: in the worst case you can push removed functionality out into the client code
13:36:02 <Jafet> Trivial changes to a library could result in many trivial changes to its dependents, so it could still cover a lot of effort
13:36:39 <xplat> maerwald: and if even that won't cover it, you should support having both versions coexisting
13:37:11 <maerwald> xplat: wait what... if the migration cannot figure out what to do, it just removes functionality?
13:37:28 <maerwald> aka: breaks the package
13:38:51 <xplat> maerwald: no no ... if you remove functionality from your library, and you can't come up with a migration that fixes the client code to sanely use what's left, instead you use a migration that inserts the implementation of the old functionality into the client codebase
13:39:17 <xplat> maerwald: effectively freezing/orphaning it instead of hard-removing
13:39:26 * hackagebot jalla 0.2.0.1 - Higher level functions for linear algebra. Wraps BLAS and LAPACKE.  http://hackage.haskell.org/package/jalla-0.2.0.1 (ChristianGosch)
13:39:38 <maerwald> xplat: ah, so you copy-paste the deprecated code
13:39:56 <pharpend> ow
13:39:58 <pharpend> oops
13:40:09 <maerwald> xplat: question: does that deprecated code still work with the new library API?
13:40:24 <maerwald> maybe you now have to copy-paste functions with different names too
13:40:31 <xplat> alternately you can make a second library and have the stuff that uses the old functionality depend on that
13:40:34 <pharpend> http://ix.io/jkM ; writing an IRC bot. The bot isn't outputting the server responses to stdout
13:41:06 <xplat> so if someone else wants to pick up maintenance they can
13:41:40 <maerwald> xplat: we are moving slowly to the C-concept of deprecated headers (or compatibility headers) :P ...now we haven't really migrated the code, we just made sure it doesn't blow up (yet)
13:42:04 <xplat> maerwald: if it doesn't work with the new API, you make it work with the new API
13:42:38 <Jafet> Numerous hackage libraries have deprecated modules as well...
13:42:46 <maerwald> xplat: but that cannot be automated
13:43:16 <xplat> maerwald: i'm not saying it's as easy for authors of depended-on code as the old system ... the idea is that most people can hope to make up the difference in the work they save depending on others' code
13:43:55 <maerwald> xplat: my point was: you copy-paste old functions of the library into the client... but those old library-functions use versions of some library-functions that are gone (as in: they are still there, but changed)
13:44:18 <maerwald> so you may have to copy those old versions of some functions too... but then you get name collision
13:44:36 <xplat> maerwald: alpha renaming is trivial
13:44:53 <maerwald> I think this will be a mess in the ends, but I might be wrong
13:44:55 <hexagoxel> xplat: just give me a tool that automatically builds and tests my package to figure out maximum possible version bounds on all dependencies. provide me that as a reliable service somewhere online. announce it properly for all maintainers. btw you get no money for it.
13:45:13 <hexagoxel> that seems to be a subset of an auto-upgrade infrastructure
13:45:21 <xplat> maerwald: again, it's not 'is it a mess' but 'is it less of a mess than cabal hell'
13:45:39 <hexagoxel> and i argue it is cheaper, simpler and more friendly to maintainers in general
13:45:47 <maerwald> xplat: I think we just need more awareness about library-compatibility and so on
13:46:00 <maerwald> how library maintainers do things, branches and whatnot
13:46:12 <Jafet> That's NP-hard in the current version constraint language, so no one's going to provide it as a service
13:46:21 <maerwald> most of the time they don't do _any_ deprecation, they just remove stuff
13:46:54 <hexagoxel> Jafet: turning types into expressions is NP-hard. and i do it all day long.
13:47:08 <Jafet> (It's actually even harder than that--it requires package authors to create testsuites!)
13:47:13 <tulcod> Jafet: how about being able to announce that a certain combination works?
13:47:30 <tulcod> Jafet: because i use --allow-newer all the time, but everyone currently figures this out for his/her own
13:47:37 <Jafet> That already exists, and is the lame "solution" called stackage.
13:48:08 <tulcod> Jafet: well, stackage adds a whole bunch of other stuff...
13:48:18 <xplat> well, stackage as lame as it is does scale to larger projects than sandboxing
13:48:18 <tulcod> as well as constraints
13:48:32 <maerwald> xplat: the C world has a way longer history of these compatibility issues and so on, so they have developed standards, good practices and whatnot. I think the haskell community still has to develop those
13:48:35 <xplat> which in turn scales larger than a bare solver
13:49:02 <Jafet> stackage exists for library users, not developers
13:49:11 <xplat> maerwald: the C world's solutions barely work there and won't scale to the level of software reuse in haskell
13:49:47 <xplat> Jafet: developers use libraries
13:50:22 <Jafet> Indeed, many people are both users and developers
13:50:48 <maerwald> xplat: they work rather well, depending on how widely used the library is... but recent "development" (actually, I think git play a role in this picture) shows that some people start to care less about these things... for instance v8 from google (which was removed from some distros for that reason)
13:51:10 <maerwald> so I don't agree, but I agree that it's getting worse
13:51:21 <xplat> maerwald: some pretty average haskell packages have the same number of recursive dependencies as really insane C projects like mplayer and gstreamer
13:51:58 <maerwald> xplat: yeah, you have a point there
13:52:32 <hexagoxel> s/recursive dependency/transitive dependency/ right?
13:53:39 <maerwald> xplat: after all, I think the problem is that most distros were designed in a time when C or C++ were still the only big things... and their whole package managers revolve around those languages and anything that is different feels weird and alien and is integrated through terrible hacks. NixOS took another approach there (but also with hacks ;)
13:54:06 <maerwald> but we need a shift of thinking I guess
13:56:57 <davean> maerwald: Personally, C's failure at library management is the singular reason I left it.
13:57:12 <davean> I'd say there is no language with a worse system that I have encountered
13:57:39 <maerwald> davean: tried Go?
13:58:10 <davean> maerwald: it at least has tooling :)
13:58:36 <maerwald> davean: try to package a huge Go project cleanly and you know what I mean
13:59:15 <maerwald> C projects can still be packaged fairly easy with classic package managers... for anything else, every distro uses its own set of hacks, mostly inconsistent with others
13:59:42 <maerwald> but I guess we are moving OT
14:09:23 <ttt_fff> I need Haskell to be as terse as APL / K / Q
14:09:57 <rhaps0dy> name your functions with a single character, use a lot of infix operators
14:10:19 <tulcod> rhaps0dy: sounds like your typical agda code
14:10:41 <rhaps0dy> tulcod: gotta mirror dem mathematical expressions
14:12:02 <ttt_fff> for the purpose of Constructors / Function names, what unicode characters are conidered uppercase, and which are considered lowercase ?
14:12:20 <geekosaur> check the unicode standard
14:12:45 <ttt_fff> geekosaur: where is it listed in https://en.wikipedia.org/wiki/Unicode ?
14:12:47 <geekosaur> IIRC the only deviation is treating : as uppercase for infix constructors, since the concept is otherwise not defined for Unicode "symbol" characters
14:13:15 <elben> Just had a weird problem where I had to touch-create a log file in .cabal-sandbox/logs or else HTTP-4000.2.20 failed to isntall
14:13:34 <geekosaur> I'm sorry, I didn';t know wikipedia was now a standards repository
14:13:46 <ttt_fff> geekosaur: np, we forgive you, everyone makes mistakes
14:13:55 <ttt_fff> geekosaur: as long as you improve, #haskell is here for you
14:14:05 <ttt_fff> there's no shame in falling as long as you climb back up and improve
14:14:07 <lifter> love
14:14:46 <Sindriava> ttt_fff: You talk a lot for wanting something terse. Start infix constructors with :, be done.
14:15:18 <ttt_fff> Sindriava: the only way to get better at writing is to write a lot
14:15:33 <rhaps0dy> infix constructors? That doesn't sound good.
14:15:39 <Sindriava> ttt_fff: Keep writing.
14:15:51 <ttt_fff> Sindriava: thanks for your encouragement
14:15:54 <ttt_fff> it means alot to me
14:17:47 <geekosaur> http://www.unicode.org/reports/tr44/#Casemapping is a starting place with references (sadly, not all usefully hyperlinked)
14:18:44 <geekosaur> ghc, like most programs, uses information derived from the official tables (sometimes via libraries such as icu; I don't know what ghc itself does) to determine case properties
14:20:11 <geekosaur> (also afaik I was the only one to mention infix constructors)
14:20:24 <geekosaur> (because it is a deviation from the Unicode standard)
14:21:02 <mauke> this is bizarre. I just woke up from a dream where I was at some kind of conference and edwardk was giving a talk
14:21:26 <glguy> Is that particularly unusual?
14:21:30 <maerwald> mauke: as I said... he's the monad weaver
14:21:34 <mauke> I didn't recognize the programming language, but it was about using advanced type system features to achieve static safety about some low-level operations
14:22:20 <mauke> also, nice job sneaking in there, win32: one of the primitives was "CoInitializeMem"
14:23:06 <maerwald> mauke: does not sound like a typesafe dream
14:24:50 <mauke> then we all got distracted because outside of the window a traing was going by and one of the carriages was on fire
14:26:24 <mauke> I don't think I've ever had a haskell or type system related dream, and I've never met edwardk
14:28:51 <maerwald> sounds like a lot of IO though
14:30:09 <sm> where can I find a faster way to convert strings to integers than read ?
14:30:26 <tulcod> i saw this C-based thing at some point...
14:32:03 <mauke> maybe String isn't the best thing to start at
14:32:21 <mauke> also, what is your program doing that this is the bottleneck?
14:33:14 <sm> mause: parsing the dates in a hledger journal file with 10k entries
14:33:19 <sm> (mauke)
14:33:21 <tulcod> sm: i'm reading that ByteString based stuff might be faster
14:33:38 <tulcod> sm: make sure to profile your code before you waste time on irrelevant stuff though
14:33:50 <sm> the parsec & String-based parser is due for an overhaul, but for now I'm just looking for small wins
14:33:56 <sm> yup, this is from profiling
14:35:30 <tulcod> sm: well i'm struggling to find this library, but basically it was just a binding to the C "atoi" function
14:35:39 <Jafet> Dates only use, what, thirty different integers
14:35:46 <sm> converting the parsed year, month and day strings to int so I can make dates is the second biggest cost centre during parsing (7%)
14:36:15 <sm> tulcod: thanks
14:36:18 <tulcod> that takes a char* though, so you're gonna spend some computation there. make sure to bind "unsafe" if you can since it's much faster (especially for such small calls)
14:36:22 <sm> Jafet: indeed! good point
14:36:28 <sm> the month and day, anyway
14:37:03 <sm> I figured there's a library doing this somewhere
14:37:06 <mauke> maybe benchmark it against a handwritten function
14:37:24 <sveri> Hi, what is the go to IDE for haskell newbies, which has a REPL built in, or supports REPL development and is not named emacs?
14:37:43 <sveri> especially now that eclipse fp plugin is becoming abandoned
14:38:09 <tulcod> sveri: xemacs
14:38:45 <mauke> > let atoi = step 0 where step n "" = n; step n (c : cs) = step (n * 10 + ord c - ord '0') cs in atoi "123"
14:38:47 <lambdabot>  123
14:38:49 <tulcod> sveri: there was this web based thing that they announced a while ago
14:38:55 <maerwald> sveri: leksah?
14:39:09 <tulcod> sveri: https://www.fpcomplete.com/business/fp-haskell-center/
14:39:12 <mauke> > let atoi = step 0 where step n "" = n; step n (c : cs) = (step $! (n * 10 + ord c - ord '0')) cs in atoi "123"
14:39:14 <lambdabot>  123
14:39:28 <sveri> tulcod: :D, yea, I been trying it, I mean the web IDE and it is nice, but I don't have internet from time to time, so not really an option
14:39:41 <tulcod> sveri: maybe you can host it locally?
14:39:57 <sveri> maerwald: does leksah support something like a REPL? the wiki says not so, but it may be outdated
14:40:05 <sveri> tulcod: not that I know of
14:40:22 <arkeet> > foldl' (\c n -> ord c - ord '0' + n*10) 0 "123"
14:40:23 <lambdabot>      Couldn't match expected type ‚ÄòChar‚Äô with actual type ‚ÄòInt‚Äô
14:40:23 <lambdabot>      In the first argument of ‚Äòord‚Äô, namely ‚Äòc‚Äô
14:40:23 <lambdabot>      In the first argument of ‚Äò(-)‚Äô, namely ‚Äòord c‚Äô    Couldn't match type ‚ÄòC...
14:40:24 <tulcod> sveri: what's the problem with emacs though?
14:40:26 <arkeet> asdf.
14:40:31 <tulcod> (not to start a religious debate)
14:40:44 <arkeet> > foldl' (\n c -> ord c - ord '0' + n*10) 0 "123"
14:40:45 <lambdabot>  123
14:41:09 <sveri> tulcod: Well, I tried it like 3 times seriously for clojure and got stuck again and again and again, so it's not religious for me, I just don't have the time it takes to get comfortable with it
14:41:34 <sveri> at least in clojure land there is a similar better IDE with cursive in intellij
14:42:08 <tulcod> sveri: i think for emacs, just like for vim, you kinda need to get started with a paper cheat sheet next to you... that helped a lot for me, anyway.... but yeah your question is reasonable
14:42:09 <deathrider> just basic programming i understand a little c+ and i did a bit of webpage design with source codes @cale
14:42:13 <athan> I wish functional dependencies force monomorphism :(
14:42:15 <Peaker> @type digitToInt
14:42:17 <lambdabot> Char -> Int
14:42:32 <arkeet> > digitToInt "#"
14:42:34 <lambdabot>      Couldn't match expected type ‚ÄòChar‚Äô with actual type ‚Äò[Char]‚Äô
14:42:34 <lambdabot>      In the first argument of ‚ÄòdigitToInt‚Äô, namely ‚Äò"#"‚Äô
14:42:34 <lambdabot>      In the expression: digitToInt "#"
14:42:38 <arkeet> > digitToInt '#' -- wow I'm tired today.
14:42:40 <lambdabot>  *Exception: Char.digitToInt: not a digit '#'
14:42:41 <athan> didn't force*
14:42:45 <mauke> Peaker: too many checks
14:42:47 <Jello_Raptor> is there a standard haskell typeclass for dictonary like data structures? AssocLists, Data.Map, all of those? I would like to be able to swap them out later as I optimize my dcode
14:43:25 <Clint> Jello_Raptor: what would be the interface?
14:43:28 <tulcod> sm: i wouldn't say 7% is a big win though. especially if this is just for some ledger software. consider how much CPU time you save and your hourly wage.
14:43:34 <Peaker> Jello_Raptor: There's Control.Lens.At
14:43:44 <athan> Jello_Raptor: I've been thinking about abstracting set operatons for a while
14:43:50 <Jafet> Well, there's almost never any reason not to use Map, and it already provides a richer interface than dictionary lookup
14:43:51 <Peaker> Jello_Raptor: but assoc-lists are not newtype'd so cannot really be instances of anything useful properly
14:43:51 <tulcod> sm: it's cheaper to spend 1000$ more on hardware than to have an engineer spend a week optimizing stuff
14:43:54 <hpc> Jello_Raptor: they use the same operation names so you can just switch imports, theoretically?
14:43:55 <monochrom> Jello_Raptor: there was one in the Edison library. but it didn't gain much interest.
14:44:10 <Peaker> Jafet: IntMap is a good reason, often :)
14:44:16 <Jello_Raptor> Clint: add, remove, get, set, the usual
14:44:20 <sveri> well, thanks everyon, I will try leksah now
14:44:25 <Jello_Raptor> Peaker: hmm
14:44:35 <Peaker> though it could be nice to have a type family auto-choose Map vs IntMap (better still if it is coercible to Int, not just if it IS int)
14:44:38 <Jafet> That one mostly shares the same names (and enriched interface) as Map, so no typeclass is needed
14:45:01 <arkeet> if you want to swap it out, yeah, just change the types and the import
14:45:08 <arkeet> since the names more or less line up
14:45:10 <monochrom> the empirical fact that, empirically, container type classes didn't gain traction, is a counterintuitive lesson to many people
14:45:17 <Jafet> Source-code polymorphism, as it were
14:45:38 <Peaker> Jello_Raptor: add k v = at k .~ Just v ; remove k = at k .~ Nothing ; set = add ; get k m = m ^. at k
14:46:05 <Peaker> Jello_Raptor: a single lens "at" lets you insert, delete, lookup, modify, etc :)
14:46:31 <arkeet> At doesn't cover stuff like unions or whatever though.
14:46:38 <athan> Peaker: Wouldn't `set k mv = at k .~ mv`, like Map.update?
14:46:39 <Jello_Raptor> Peaker: yup, given that i'm using control.lens anyway, that's a good way to do it. 
14:46:49 <Peaker> well, Monoid does -- but Data.Map screwed up its Monoid instance :(
14:46:54 <arkeet> :(
14:47:10 <athan> oop :x
14:47:17 <Peaker> athan: if that's what "set" means, sure :)
14:47:26 <arkeet> Peaker: what's wrong with mappend = union?
14:47:34 <arkeet> or do you want something like unionWith mappend
14:47:42 <Peaker> arkeet: unionWith mappend is much more useful
14:47:55 <arkeet> yeah I guess
14:48:01 <arkeet> you can always recover the old one with a newtype
14:48:02 <Peaker> arkeet: you can always degenerate it back to union by coercing to "Monoid.First" and then unwrapping
14:48:11 <Peaker> but "union" is a dead end
14:48:14 <arkeet> yup
14:48:28 <Peaker> it requires a much bigger API vocabulary
14:48:31 <arkeet> also it's not consistent with e.g. the monoid instance for functions
14:48:48 <Peaker> when Data.Map operations could almost all be covered by the standard type classes, via Type-Class-Morphisms (Like the beautiful TMap)
14:48:53 <arkeet> actually
14:49:12 <Peaker> arkeet: exactly! TMap has a denotational model of a function so it has TCM's for all the function instances, guaranteeing nice behavior
14:49:19 <arkeet> mhm
14:50:32 <arkeet> well actually it ought to be unionWith (<>) (from semigroup)
14:50:34 <arkeet> :-)
14:50:41 <Peaker> TMap doesn't have a good story for enumerating keys, I think that's an unsolved issue there
14:51:12 <Peaker> but other than that, it's almost Data.Map with a tiny tiny API that's almost equivalent in power
14:51:37 <Zemyla> Okay, so there's two different comonads on Pair.
14:51:59 <arkeet> where is TMap?
14:52:30 <arkeet> Zemyla: I think there are more tbh.
14:52:44 <arkeet> Pair a = Bool -> a, so you get one for every Monoid on Bool.
14:52:48 <Zemyla> Well, there are definitely two that aren't isomorphic to each other.
14:52:51 <arkeet> oh yeah.
14:53:13 <Zemyla> arkeet: All and Any produce isomorphic comonads.
14:53:14 <bollu_> so, I want a monad that behaves like State, but has the nice "erroring out" property of Either
14:53:16 <bollu_> what do I do?
14:53:17 <arkeet> yep.
14:53:33 <bollu_> I considered State (Error ..)
14:53:40 <bollu_> but that would not play well with do notation
14:53:41 <Zemyla> arkeet: The non-isomorphic comonad comes from basically Xor.
14:53:50 <arkeet> bollu_: EitherT e (State s) or something?
14:53:51 <arkeet> Zemyla: yep.
14:53:51 <bollu_> because I'd have to (>>=) twice to get the inner value out, right?
14:53:57 <bollu_> arkeet: what's EitherT
14:53:59 <bollu_> ?
14:54:02 <Zemyla> bollu_: StateT (Either e).
14:54:10 <Zemyla> Or EitherT e (State s).
14:54:13 <bollu_> Zemyla: okay, now what's StateT?
14:54:18 <arkeet> those are monad transformers.
14:54:20 <bollu_> what is the T? 
14:54:24 <arkeet> T is for transformer.
14:54:24 <bollu_> what do they do?
14:54:36 <Zemyla> They're monad transformers. They take a monad and give it extra features.
14:54:39 <koala_man> bollu_: http://book.realworldhaskell.org/read/monad-transformers.html 
14:54:57 <Zemyla> bollu_: http://hackage.haskell.org/package/transformers
14:54:59 * hackagebot multistate 0.6.2.0 - like mtl's ReaderT / WriterT / StateT, but more than one  contained value/type.  http://hackage.haskell.org/package/multistate-0.6.2.0 (lspitzner)
14:55:01 <Peaker> arkeet: http://hackage.haskell.org/package/total-map-0.0.4/docs/Data-TotalMap.html
14:55:01 <arkeet> bollu_: EitherT e (State s) a is just a newtype for State s (Either e a)
14:55:08 <bollu_> cool, thanks :)
14:55:49 <jle`> arkeet, bollu_ : you might mean State s (Either e) a
14:55:50 <Zemyla> arkeet: But yeah, either duplicate (Pair a b) = Pair (Pair a b) (Pair b b), or duplicate (Pair a b) = Pair (Pair a b) (Pair b a).
14:55:58 <athan> Is there a `find` function for Data.Map that returns the key associated with a value?
14:56:02 <arkeet> jle`: no, that is a kind error.
14:56:05 <Zemyla> The only difference is the second diagonal element.
14:56:06 <jle`> oh yeah
14:56:08 <jle`> ><
14:56:11 <jle`> sorry
14:56:15 <jle`> i thought you said StateT
14:56:21 <jle`> my bad ;_;
14:56:26 <jle`> by the way i came here to ask
14:56:34 <arkeet> bollu_: the transformer thing just lets it have a nice Monad instance.
14:56:46 <arkeet> that does the sort of thing you'd otherwise do with State s (Either e a) kind of things.
14:56:52 <bollu_> arkeet: hm, all right. I'll read up on it :)
14:56:56 <arkeet> :-)
14:57:01 <jle`> is there any commonly used monad somewhere that is like data Foo a b t a = Foo (forall m. Monad m => (a -> m b) -> m (t a)) ?
14:57:06 <jle`> it's been useful for me
14:57:10 <jle`> but i do'nt know if it's somewhere else already
14:57:15 <Jafet> athan: that would not be a very efficient find, but you can use Map.toList.
14:57:28 <arkeet> jle`: a b t a?
14:57:29 <Peaker> bollu_: "Monads don't compose" -- that means generally you cannot take m1 and m2, and say: m1 (m2 a)  and have a monad instance for this type.  Specifically, m (Either e a)  works (if m2=Either e, or Maybe, then it does compose)
14:57:39 <jle`> oh yeah, sorry
14:57:51 <athan> Jafet: Hmm! Do you think the toList approach would be faster than folding down the sorted keys of Map?
14:57:53 <jle`> data Foo a b t r = Foo (forall m. Monad m => (a -> m b) -> m (t r))
14:57:55 <Peaker> bollu_: So for monads that can be made to compose, transformers were created, as those do compose
14:58:06 <bitemyapp> monads compose, just not for free.
14:58:23 <arkeet> StateT isn't really a composition of monads.
14:58:23 <athan> peace yall! o/
14:58:24 <jle`> i'm trying to decompose it into monad transformers but i am not sure where to start
14:58:25 <Peaker> bitemyapp: how do you compose (m1 . m2) into a Monad, in general?
14:58:32 <Jafet> toList gives you the sorted list of keys, so it is most definitely not faster (nor slower)
14:58:33 <arkeet> Peaker: you need a distributive law.
14:58:35 <bitemyapp> Peaker: that's the, "just not for free" part.
14:58:54 <Peaker> arkeet: StateT is composition of the State monad with another monad -- even though the "composition" is done by type application
14:58:56 <bitemyapp> you need information about one o' 'em
14:58:56 <tulcod> bitemyapp: why not? is there a fundamental limitation? because usually the definitions are pretty straightforward, right?
14:59:07 <Peaker> arkeet, bitemyapp: That law is not always available, so in general, they do not compose
14:59:14 <arkeet> let';s recall
14:59:15 <bitemyapp> tulcod: fmap, pure, join don't give you enough information.
14:59:25 <arkeet> newtype StateT s m a = StateT (s -> m (a,s))
14:59:28 <tulcod> no okay, but i've never seen an interesting composition
14:59:29 <bitemyapp> tulcod: you can't make it work. Just mechanically speaking. Try making a Monad for Compose.
14:59:34 <bitemyapp> tulcod: never?
14:59:38 <arkeet> that's not a composition of m with a monad.
14:59:40 <tulcod> well i haven't been looking very hard
14:59:42 <bitemyapp> tulcod: how long have you been using Haskell?
14:59:50 <shachaf> arkeet: It's composition of adjunctions!
14:59:52 <tulcod> interesting in the implementation sense
14:59:53 <arkeet> rather it sandwiches m in an adjunction.
14:59:57 <tulcod> i mean of course they are useful
15:00:01 <bitemyapp> stacking up Monads/Applicatives/Functors is close to my job description.
15:00:22 <shachaf> I,I Sandwiches in the category theory sense or in the usual sense?
15:00:24 <tulcod> bitemyapp: you have any good stories you'd be willing to share? :)
15:00:30 <arkeet> (s ->) and (,s) form an adjunction, so their composite is a monad.
15:00:35 <arkeet> but you can stick any monad inbetween the composition
15:00:39 <arkeet> and still get a monad.
15:00:45 <bitemyapp> tulcod: you stack up monads in pretty much any non-trivial Haskell application
15:00:46 <arkeet> shachaf: just in the metaphorical sense.
15:00:51 <bitemyapp> tulcod: Reader, RWST, etc.
15:01:01 <arkeet> the adjoint pair is the bread, the monad is the meat or whatever.
15:01:20 <Peaker> bitemyapp: don't use RWST or WriteT, they're broken
15:01:29 <Peaker> WriterT*
15:01:32 <bitemyapp> Peaker: I don't
15:01:54 <Peaker> (and fixing them is hard because Haskell has the nasty habit of exposing implementation details like data constructors in APIs)
15:02:04 <bitemyapp> I know they don't have the operational behavior people want.
15:02:05 <Peaker> (Haskell's stdlibs, that is)
15:02:10 <arkeet> we can fix that with pattern synonyms!
15:02:16 <bitemyapp> Peaker: FilePath looks like it might get cleaned up soon.
15:02:17 <bitemyapp> arkeet: :)
15:02:38 <Peaker> bitemyapp: WriterT is useless in the same way "foldl" is
15:02:39 <shachaf> arkeet: Except you can take the monad and turn it into more bread?
15:02:54 <arkeet> shachaf: huh.
15:02:56 <bitemyapp> Peaker: I know
15:03:02 <shachaf> I'm liking this analogy.
15:03:07 <Peaker> bitemyapp: ah, OK, thought you don't because of the mention of RWST :)
15:03:10 <shachaf> Metaphor. Whatever.
15:03:18 <bitemyapp> Peaker: I needed an example of stacking up monads.
15:03:29 <bitemyapp> mostly I use Reader, MonadIO, one-offs.
15:03:33 <Jafet> RWST is particularly good at stacking up other things
15:03:51 <Peaker> ah, I use a lot of a "Transaction" monad that lets me do determinstic transactions on a DB (by restricting IO and *not* exposing MonadIO)
15:03:56 <arkeet> Jafet: like thunks?
15:04:00 <Peaker> :-D
15:04:23 <arkeet> I thought we had some strict RWST somewhere.
15:04:46 <Peaker> arkeet: actually the unfixable leak in WriterT/RWST is of stack and previous writer results IIUC, not (necessarily) thunks
15:04:51 <Jafet> There is a strict RWST. Turns out it wasn't strict enough
15:04:58 <Peaker> strictness isn't the problem
15:05:03 <Peaker> or at least, not the only problem
15:05:20 <Peaker> The very idea of (w, a) to implement Writer is the problem
15:06:08 <Peaker> (w, x) >>= loooongComputationHere   *must* keep the 'w' alive to mappend it later.  Every single >>= leaks a "w"
15:06:24 <Peaker> and leaks the "remember to mappend 'w' later" too
15:06:32 <arkeet> mmm.
15:06:40 <Peaker> (and this has little to do with strictness)
15:07:25 <Jafet> It could have been corrected by forcing the writer state in (>>=), I think
15:07:33 <Peaker> As opposed to StateT-used-as-writer which avoids keeping two 'w's for each >>=, but only threads one (sacrificing independence which isn't used anyway)
15:07:40 <Peaker> Jafet: nope
15:07:49 <Jafet> Ah, (>>=) associates the "wrong" way
15:07:55 <Peaker> Jafet: exactly
15:08:05 <Jafet> That's quite amusing
15:08:52 <Peaker> I encountered it when I hit a stack overflow in one of my projects, and narrowed it down to leaking stack allocations for every mappend remembered (I had a stack overflow).  Then at the exact same time there was a big ML discussion about how WriterT is broken, and it seems it *still* is (a year later?)
15:09:14 <bitemyapp> Peaker: yeah it's still broken, people just avoid it.
15:09:35 <Peaker> The Haskell community is dysfunctional when it comes to matters like this :( It needs a BDFL
15:10:00 * hackagebot postgresql-schema 0.1.0 - PostgreSQL Schema Management  http://hackage.haskell.org/package/postgresql-schema-0.1.0 (markfine)
15:10:07 <Jafet> Perhaps the haddocks should reflect this...
15:10:16 <Peaker> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-Trans-Writer.html <-- nothing about how it is broken here :(
15:10:55 <bitemyapp> Peaker: I think the maintainer of transformers is part of the problem, but I don't have direct experience here.
15:11:12 <Peaker> I think that WriterT should just newtype StateT - and whoever is broken by the change had broken code already!
15:11:35 <Peaker> (and the new WriterT should avoid exposing implementation details -- unless everyone is willing to rely on PatternSynonyms everywhere)
15:21:16 <jle`> i realized that i was looking for the wrong type
15:21:41 <jle`> i'm trying to find data Foo a b t r = Foo (forall m :: (a -> m (t b)) -> m (t r))
15:22:01 <jle`> anyone have any insight?
15:22:15 <jle`> the Monad instance requires Traversable t
15:22:42 <jle`> instance (Monad t, Traversable t) => Monad (Foo a b t) where ...
15:22:51 <jle`> it's been pretty useful for me so far, so i was wondering if it's out there anywhere
15:23:19 <jle`> if not imma publish it as a library
15:23:39 <Zemyla> jle`: Look up Bazaar in lens.
15:23:54 <jle`> aw darn
15:24:02 <jle`> i mean, oh yay
15:24:35 <Zemyla> newtype Bazaar a b t = Bazaar { runBazaar :: forall f. (Applicative f) => (a -> f b) -> f t }
15:24:49 <jle`> ah, it's slightly different
15:25:29 <Zemyla> It doesn't specialize the type of the Traversable, which makes it more useful.
15:26:12 <jle`> i'm not sure it can be used for the same use cases i'm using my Foo for
15:26:43 <jle`> Bazaar a b t = Foo a b Identity t for me
15:27:09 <jle`> but thanks, it's a good lead
15:28:22 <sm> man. profiling is hard
15:28:53 <Zemyla> Well, it also means that it's a Comonad.
15:29:44 <jle`> Bazaar, right?  Foo can't be
15:29:53 <jle`> no matter what t is
15:30:06 <arkeet> not even when t is Identity?
15:30:25 <jle`> no, because you can only get a forall m. Monad m => m (Identity r) at best, i think
15:30:44 <arkeet> and specialize that with m = Identity
15:31:01 <jle`> oh
15:31:13 <jle`> oh yeah
15:31:16 <jle`> heh
15:31:31 <Zemyla> Bazaar is, yes.
15:31:33 <arkeet> but you need some way to come up with the a -> m (t b)
15:31:45 <jle`> wait, you're right
15:31:49 <Zemyla> That's why it doesn't parametrize over the type of the Traversable.
15:31:54 <jle`> i just tried writing it, and that's where i ran into a problem, heh
15:32:09 <arkeet> Bazaar's Comonad instance requires a ~ b
15:32:11 <jle`> so i guess if b is a Monoid
15:32:22 <jle`> or if (a ~ b), yeah
15:32:29 <Zemyla> Yeah.
15:32:52 <Zemyla> Bazaar a i i is also a Monad over a.
15:33:12 <oconnore> is there a gc'ed equivalent of StablePtr? 
15:33:13 <Peaker> (It becomes Cont)
15:33:56 <Peaker> oconnore: StablePtr has explicit create/delete -- and when you delete, it can be GC'd
15:34:26 <Jafet> So, just Ptr?
15:34:27 <oconnore> Peaker: right, I don't want that.
15:34:33 <jle`> i had written runFoo :: Foo a b Identity r -> (a -> b) -> r, so extract q is just runFoo q id
15:34:39 <jle`> makes sense
15:34:40 <Peaker> oconnore: what is it that you do want from StablePtr?
15:35:26 <Jello_Raptor> Peaker: so I'm trying to use the Control.Lens.At as an interface to a container, but I'm having trouble figuring out what the type for a specific container would be.
15:35:27 <jle`> Bazaar is close, but for the actual reason my type is useful, Bazaar is not useful
15:35:27 <oconnore> Peaker: I want to send pointers to local data to foreign code, and when the local data is gc'ed, those references become invalid
15:35:43 <oconnore> Jafet: but then it has to be storable. StablePtr has no Storable requirement
15:35:49 <jle`> or well, for the use i created the type for
15:36:18 <oconnore> Jafet: it works for primitives, but not, for example, File handles, streams, channels
15:36:24 <arkeet> you want your foreign code to be able to inspect the data?
15:36:48 <arkeet> StablePtr doesn't let you do that.
15:36:52 <oconnore> arkeet: no
15:36:58 <Peaker> oconnore: maybe you can make a StablePtr to a weak reference?
15:37:18 <oconnore> arkeet: just to say, "hey, I'm asking you to do something with this instance that you told me about before"
15:37:42 <Jello_Raptor> Peaker: The issue is i'm nto sure how to constrain "At m => (Index m)" so that "(Index m)" is set to a type I specify. 
15:39:15 <Jello_Raptor> oh it looks like I need the equality constraints from the typeFamilies extension
15:39:16 <Peaker> Jello_Raptor: what value are you trying to give a type to?
15:40:52 * arkeet wonders how workable StablePtr (Weak a) is
15:41:05 <Jafet> > M.fromList [(1, "one")] ^.at 1
15:41:08 <lambdabot>  Just "one"
15:42:31 <oconnore> arkeet: hmm, I guess it would only leak a few bytes :P
15:42:44 <oconnore> close enough, eh?
15:42:45 <Jello_Raptor> Peaker: basically I want to say that a function returns a dictionary with specific key 'k' and value 'v' types. so my typeclass contraints would look like "getContainer :: (At m,Index m ~ k,IxValue m ~ v) => m" though I think that ends up as "(forall m. ..." where I want an "(exists m. ...") 
15:43:03 <arkeet> hm, maybe that's not it.
15:43:12 <arkeet> or maybe it is.
15:43:16 <arkeet> I wouldn't call it leak.
15:44:23 <Peaker> Jello_Raptor: if you use mempty & at  you can make it forall :) With a Monoid constraint
15:45:17 <Peaker> oconnore: you need the deref feature of a stable ptr, right? the only way to make "deref" make sense (and not accidentally hit a re-use of the same ptr id) is to keep some memory remembering you've publicized it
15:45:51 <arkeet> :t foldl' (\m (k,v) -> m & at k ?~ v) mempty
15:45:52 <lambdabot> (Foldable t, Monoid a, At a) => t (Index a, IxValue a) -> a
15:46:29 <Peaker> Jello_Raptor: I think this is exactly the use case for ML modules, btw...
15:46:53 <Peaker> (existential type + API around it) as an interface you can code to and then plug in any implementation you'd like later
15:47:26 <arkeet> I don't think you want an existential.
15:48:52 <Jello_Raptor> arkeet: issue is that I expect these containers to be reasonably large, and to be constructed and traversed a lot. An existential would avoid the transformation from one dictionary type to another, right? 
15:49:08 <arkeet> what exactly do we mean by existential
15:51:02 <Jello_Raptor> arkeet: in this case I want to be able to say that "I'm giving you some type, with a lens 'at' and with key and value types 'k' and 'v'" So that you can use the lens to access/modify values, without knowing what exact dictionary structure is used. \
15:51:36 <arkeet> ok, that's not an existential though.
15:51:50 <Jello_Raptor> Peaker: yeah, i'm not sure what you mean by that. The few versions i poked at are all basically nonsense. I think I'm missing something. 
15:52:00 <arkeet> if you're giving me some type, you can know its structure, even if I don't.
15:52:05 <arkeet> if you give me an existential, no one knows it.
15:52:14 <arkeet> not even other things of the same type.
15:52:40 <Peaker> Jello_Raptor: why not create a polymorphic container type?
15:52:51 <Jello_Raptor> arkeet: the module implementing it would, even if none of the modules using the implementation would. This is in a typeclass definition remember.
15:53:14 <Peaker> you could create an existential wrapper for a container allowing only At/Monoid access to it
15:53:54 <Peaker> or even, a non-existential wrapper, that just hides the container type but still exposes At/Monoid instances
15:54:02 <Peaker> (from the module that does know which container it is)
15:54:19 <arkeet> the problem with existential wrappers is that
15:54:24 <arkeet> if you have two values of such a thing
15:54:31 <arkeet> you can't combine them
15:57:26 <Peaker> yeah, just newtype the known type
15:58:37 <Jello_Raptor> Peaker: hmm, yeah :/ and then provide at and monoid instances to the newtype so that I can keep using it as before.
16:00:01 * hackagebot pipes-fastx 0.3.0.0 - Streaming parsers for Fasta and Fastq  http://hackage.haskell.org/package/pipes-fastx-0.3.0.0 (rcallahan)
16:05:26 <cpa> guys, how do I get this to work: B.split '\n' myLazyByteString
16:05:52 <cpa> GHC is unhappy because '\n' is a Char instead of Word8
16:06:40 <geekosaur> ord?
16:08:02 <arkeet> 13?
16:08:04 <arkeet> er, 10
16:08:13 <arkeet> ord '\n' is an Int, not a Word8
16:08:30 <Peaker> @type fromIntegral . ord
16:08:32 <lambdabot> Num c => Char -> c
16:08:39 <arkeet> that's a lot of typing compared to 10.
16:08:40 <kgadek> hi, quick one: do your editor comments-out lines beginning with pipe (eg.: | otherwise -> foo ) in a wrong way ( making the "--|" which is recognised as a unknown operator) ?
16:09:00 <kgadek> this seems like a minor inconvenience, but still inconvenience
16:09:01 <Peaker> Another option is Data.ByteString.Char8 and the original code
16:09:23 <kgadek> and was there a proposal to make anything beginning with "--" a comment?
16:10:41 <arkeet> I just type "-- " in front.
16:11:59 <ReinH> Cale: ping
16:12:56 <arkeet> my editor lets me do that on multiple lines at once.
16:14:24 <Cale> ReinH: hi
16:15:17 <c_wraith> > let (--+) = (+) in 4 --+ 8
16:15:19 <lambdabot>  12
16:15:24 <c_wraith> kgadek: ^
16:15:42 <c_wraith> kgadek: you are actually allowed to start operators with --, if they contain some other character as well
16:15:55 <arkeet> http://hoogle.haskell.org/?hoogle=--&scope=set%3Astackage
16:16:28 <c_wraith> kgadek: so to be sure you're starting a comment, you need something like "-- ", with the space there
16:16:35 <c_wraith> as arkeet said
16:19:32 <ReinH> Cale: I think I just discovered a final encoding for Turing machines, a terminal object in the category of Turing machines.
16:20:04 <ReinH> similar to my final encoding of L-systems
16:20:29 <JoshieAS> So I'm getting a type error on compile..
16:20:45 <JoshieAS> fromList [('A', 20), ('T', 21), ('C', 12), ('G', 17)] @=?
16:20:49 <JoshieAS> Is part of my test case
16:21:28 <linman32> is there a way to get all the defined functions from a haskell file? maybe an emacs package or something
16:21:41 <JoshieAS> Couldn't match expected type ‚Äòcontainers-0.5.6.2:Data.Map.Base.Map' Char Integer...blah blah 'actual type is [(Char, Integer)]
16:21:46 <c_wraith> linman32: would hasktags do what you want?
16:21:53 <JoshieAS> my solution matches the test case! but it's giving me this weird ass type error
16:22:00 <c_wraith> linman32: admittedly, it'll grab all bindings, functions or not.  But that's usually what you want anyway
16:22:56 <c_wraith> JoshieAS: the fact that it's listing the package version is very worrying.  It means you probably have a broken package database
16:23:18 <JoshieAS> I see..
16:23:26 <c_wraith> JoshieAS: if you run "ghc-pkg list containers", does it show more than one installed version?
16:24:21 <linman32> c_wraith: yeah, i think so. i'll try it out. thanks
16:24:40 <JoshieAS> c_wraith: It does indeed
16:25:04 <c_wraith> JoshieAS: that's the underlying cause of the problem.  As for how to fix it..  depends on why it ended up that way in the first place.
16:30:03 * hackagebot pipes-bgzf 0.2.0.0 - Blocked GZip  http://hackage.haskell.org/package/pipes-bgzf-0.2.0.0 (rcallahan)
16:48:44 <ReinH> Cale: (Guess what: it's nearly the same encoding as L-Systems)
16:53:05 <bernalex> is there a nice way to apply a binary function to a huge Map of things, so that it applies it to every possible combination?
16:56:55 <Peaker> bernalex: Data.Map?
16:57:01 <bernalex> Peaker: yeah
16:57:07 <Peaker> bernalex: are the keys relevant?
16:57:20 <Peaker> bernalex: why is it not applying it to all combinations of the Map.elems?
16:57:38 <bernalex> Peaker: well I still need to know which key belongs to which value, but not other than tha
16:57:39 <bernalex> t
16:58:44 <bernalex> i.e. I need a map in the end at least
16:59:50 <ReinH> bergmark: well, how do you decide which key belongs to which value?
16:59:59 <ReinH> you're combining values, so there isn't an obvious choice
17:01:01 <ReinH> Do you want some f :: (v -> v -> a) -> Map k v -> Map k v -> (k, k, a) that keeps both keys around?
17:01:24 <ReinH> er, [(k, k, a)]
17:01:25 <bernalex> ReinH: I am running them on a function :: (Foo, Foo) -> (Foo, Foo).
17:02:11 <ReinH> Ok, but there are still more values than you had keys before
17:02:18 <ReinH> So you have to have a way to select a new key
17:02:19 <bernalex> how is there?
17:02:55 <ReinH> The size of the cartesian product of S is |S|¬≤, so unless |S| = 1 there will be more values
17:02:56 <Peaker> bernalex: do you want to try both x`f`y and y`f`x or is one direction enough?
17:02:59 <ReinH> (or 0)
17:03:09 <bernalex> Peaker: one direction is better
17:03:09 <ReinH> (of S with itself)
17:04:12 <bernalex> ReinH: basically I have a huge map of stuff, and I want to see if any one of them collide with any one of the other. if they do, update them, then done.
17:04:36 <bernalex> if they are updated, they should probably also not be considered for further collision handlings.
17:04:42 <Peaker> bernalex:   f _ [] = [] ; f g (x:xs) = map (g x) xs ++ f g xs   ?
17:04:59 <Peaker> bernalex: then just have your function on the pairs preserve the key information which you can embed in the list
17:05:22 <ReinH> bernalex: You'll find that you get better help if you describe what you are actually doing rather than what you think you need to accomplish it
17:05:25 <ReinH> @google XY Problem
17:05:26 <lambdabot> http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem
17:05:27 <lambdabot> Title: What is the XY problem? - Meta Stack Exchange
17:05:28 <bernalex> Peaker: that's a thought I had, although it's a bit annoying, to have a variable to do nothing with
17:05:51 <Peaker> bernalex: the map will be large? how do you define a "collision"?
17:06:33 <bernalex> Peaker: the map is not large right now. collisions are dealt with by the binary function I want to use. (circle-circle-intersection, fwiw.)
17:06:54 <ReinH> Are you actually doing collision detection?
17:07:08 <Peaker> bernalex: sounds very inefficient to test them all instead of indexing them in a way that lets you quickly find all colliders
17:07:24 <ReinH> Perhaps you want some sort of space-aware structure that allows you to reduce the number of checks
17:07:28 <bernalex> ReinH: as I said, there's a binary function that does (amongst other things) collision detection via circle-circle-intersection.
17:07:44 <bernalex> Peaker: ReinH: yes, I'm doing that at some point. I don't feel like doing optimisations right now though.
17:07:54 <bernalex> (if I did, I'd write it in C.)
17:08:00 <ReinH> for instance, that lets you avoid checking pairs that couldn't possibly collide
17:08:07 <ReinH> Welp
17:08:25 <ReinH> I didn't realize that choosing the right data structure was equivalent to rewriting something in a different language.
17:08:30 <bernalex> the number of elements is far too small for that to be even remotely a concern right now.
17:10:05 * hackagebot Frames 0.1.0.0 - Data frames For working with tabular data files  http://hackage.haskell.org/package/Frames-0.1.0.0 (AnthonyCowley)
17:14:33 <zed_> are people here up for "long" debugging ?
17:15:32 <aupiff> zed_: what do you mean? you have a long and complicated problem?
17:15:46 <zed_> aupiff: more or less, yes
17:15:51 <aupiff> ok, go
17:15:57 <aupiff> I'll try my best
17:15:59 <zed_> i mean, it's not THAT long, but it's more than 5 lines
17:16:01 <zed_> thanks !
17:16:29 <zed_> first of all, here's the code : http://lpaste.net/135313
17:16:45 <zed_> my bug seems to be on line 43
17:17:04 <zed_> it compiles and eveyrthing, it just doesn't give me the right result and i am failing to understand why... anyway
17:17:16 <ReinH> bergmark: do you want:
17:17:19 <ReinH> :t let f :: a -> a -> b; f = undefined; cp xs = liftA2 (,) xs xs in M.fromList . concatMap (\((a,b),(c,d)) -> [(a,f b d), (c, f b d)]) . cp . M.toList
17:17:21 <lambdabot> Ord k => M.Map k a1 -> M.Map k a
17:17:28 <zed_> xs should be a list of tuples containing (result_of_integration, error)
17:18:09 <zed_> but when I do the traceShowId, it seems to give me a tuple followed by a number
17:19:09 <zed_> eg : http://lpaste.net/135314
17:19:27 <zed_> so my question is, where do the number that is not part of the (Double, Double) comes from ?
17:19:46 <zed_> aupiff: does that make sense ? : )
17:20:05 * hackagebot sequent-core 0.5 - Alternative Core language for GHC plugins  http://hackage.haskell.org/package/sequent-core-0.5 (lukemaurer)
17:21:02 <Peaker> zed_: you're mixing the printout of your value with the debug traces
17:21:12 <ReinH> bergmark: I still don't understand how you can ignore the fact that you have n¬≤ more values to deal with
17:21:33 <Peaker> @type rnf
17:21:34 <ReinH> (well, n¬≤ - n more values)
17:21:35 <lambdabot> Not in scope: ‚Äòrnf‚Äô
17:21:39 <aupiff> yeah, I agree with Peaker
17:21:45 <zed_> Peaker: what do you mean? I don't understand... what should I write if I want to see the values of xs ?
17:21:54 <augur_> what are the varieties of approaches to asynchronous possibly-failing computations are there?
17:21:58 <Peaker> zed_: you could try to use: foo <- yourExpressionHere ; rnf foo
17:22:31 <ReinH> each key k is going to be given n different values
17:22:37 <xj54y> what is "abrasive" ?
17:23:25 <zed_> Peaker: I am not sure what that means...
17:23:44 <Peaker> zed_: when you tell ghci an expression, it naturally computes it to print out the result
17:23:58 <Peaker> zed_: if that computation has a side-effect of printing stuff, the stuff can mix with the ghci printout of the result
17:24:16 <ReinH> er, bernalex^ not bergmark
17:24:20 <ReinH> sorry
17:24:26 <Peaker> zed_: foo <- yourExpression   tells ghci NOT to print out the result, but just to give it a name. Unfortunately, it also may not compute anything, so it won't necessarily print out your debug prints either
17:24:44 <zed_> Peaker: Ok I think I understand. Thanks : )
17:24:45 <Peaker> zed_: however, you can then tell ghci to force the expression to be fully computed with "rnf" (from the deepseq package)
17:25:10 <Peaker> zed_: that still doesn't print out the result -- but it will cause the full computation to occur so your debug prints will be printed on their own
17:25:35 <Peaker> zed_: another solution is to run the program not via ghci, and the debug traces should go to stderr which is independent from stdout printouts
17:25:43 <zed_> Peaker: so if I want to see what xs holds as value just after the line 43, what should I do ? 
17:25:55 <ReinH> For example, try this in ghci: foo <- do putStrLn "foo"; getChar
17:26:56 <bernalex> ReinH: as mentioned I have a map of stuff, and I want to check if it collides (and then handle the collision). so optimally, when an element is involved in a collision, the combinator needn't keep checking for collisions with that one. so to sum up imperatively: for every n: check if n checks with any m, once it does handle these effects on n & m, if it never does, ok fine.
17:29:45 <ReinH> bergmark: Ah
17:30:45 <bernalex> ReinH: you should probably start bugging bergmark. 1. it makes me miss what you say. 2. but, hey, at least he'll have an interesting backlog.
17:30:48 <bernalex> uh
17:30:52 <bernalex> s/start/stop/
17:30:56 <ReinH> Yeah, sorry, I have to get used to this tab completion
17:31:12 <bernalex> is it alphabetical or summat? mine's based on the last person that spoke. useful.
17:32:12 <ReinH> Yeah, that's why I'm having trouble. The one I'm using now is alphabetical.
17:32:18 <ReinH> I'm used to it being that way as well.
17:32:28 <bernalex> bother.
17:32:31 <ReinH> But I think I can add that feature some time this evening.
17:36:24 <zed_> Peaker: I mean, I understand your explanations and I would be able to implement them in a language I know better, but I am clueless as to where to start doing any of this in Haskell... I am trying to figure out where/how I could do the foo <- yourExpression but, alas.
17:40:18 <L8D> does anyone know how to use PSQL stored procedures from within esqueleto?
17:40:45 <L8D> For example, how to use pgcrypto's crypt function
17:46:46 <ReinH> bernalex: maybe something vaguely like this? http://lpaste.net/7550095040811368448
17:48:58 <pharaun> Oh, i was actually wondering something slightly different/like that
17:49:01 <ReinH> bernalex: There's probably a nice solution using a CSP monad or something
17:49:09 <ReinH> or a Logic monad
17:49:12 <ReinH> to help manage the filtering
17:49:24 <ReinH> of already-detected collisions
17:49:48 <pharaun> user defined function is a thing for sql right (at least for sqlite) but i use esqueleto, which uses persistent, which uses persistent-sqlite, which has a copied/modified version of sqlite-direct.
17:50:26 <pharaun> now persistent version removed support for custom functions, but sqlite-direct still has it, would my best luck be to port the custom-function code over from sqlite-direct into persistent-sqlite and submit upstream?
17:58:03 <bernalex> ReinH: sorry, only saw this just now, I've gotten past that problem already. :) thanks though.
17:59:21 <ReinH> bernalex: :)
18:01:28 <pharaun> i guess i'll go ahead and port stuff out of sqlite-direct and upstream it into persistent-sqlite
18:01:32 <pharaun> still makes me grumble a bit
18:13:52 <Quantumplation> Is there a prelude function for taking two lists of different sizes, and inserting elements from the first into the second Nth position?  so like ["a", "b", "c"] and ["1".."10"] intermixed every third would produce [1,2,3,
18:13:57 <Quantumplation> er
18:14:07 <Quantumplation> would produce ["1", "2", "3", "a", .. etc
18:14:32 <Quantumplation> i'm mapMing over a bunch of things in the IO monad, and i'd like to putStrLn every 50 of them to indicate some progress
18:23:51 <gamegoblin> Can someone point me to an example of writing a wrapper around IO that say, only allows the user to write to stdout (instead of any IO action) ?
18:25:25 <gcganley> gamegoblin: there are some pure monad implementations that do what youre asking but I'm not familiur. Maybe only import things like putStrLn and putStr?
18:25:55 <gamegoblin> gcganley: I specifically am looking for an example of a wrapper, not just importing things. I know I‚Äôve seen one before.
18:26:36 <gcganley> gamegoblin: I have not seen it :/
18:26:39 <gcganley> sorry
18:28:32 <lamefun> gamegoblin: looks like there's one here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe-haskell.html
18:30:23 <gamegoblin> thanks lamefun 
18:57:58 <hodapp> I see this type signature: "noBreak :: Ivory (E.ClearBreak eff) a -> Ivory eff a", where ClearBreak is: "type instance ClearBreak ('Effects r b a) = 'Effects r 'NoBreak a"
18:58:17 <hodapp> am I reading this properly as a function that can only apply if 'b' is NoBreak?
19:04:36 <Eduard_Munteanu> hodapp, I've no idea of the context, but looks like it
19:05:03 <hodapp> Eduard_Munteanu: what I've shown you is pretty much what I have to work with
19:05:20 <hodapp> trying to write some docs...
19:06:21 <hodapp> and then there's "noAlloc :: (innerEff ~ E.ClearAlloc outerEff) => Ivory innerEff a -> Ivory outerEff a" and no explanation for why it's different... bleah
19:07:24 <Eduard_Munteanu> hodapp, looks similar
19:07:52 <Eduard_Munteanu> Except s/Break/Alloc/
19:07:54 <lamefun> Does Haskell provide any way to enforce repeatability?
19:08:16 <Eduard_Munteanu> lamefun, can you expand on "repeatability"?
19:08:45 <hodapp> Eduard_Munteanu: it's similar but what I don't get is why innerEff and outerEff are now separated
19:09:19 <Eduard_Munteanu> hodapp, possibly for clarity and more meaningful naming
19:09:46 <lamefun> Eduard_Munteanu: it's as in original idea of Java, where a function call always returns the same result regardless of where it's computed.
19:10:01 <Eduard_Munteanu> hodapp, it should be the same as   noAlloc :: Ivory (E.ClearAlloc e) a -> Ivory e a
19:10:35 <lamefun> For example, Floats can't be used as they're potentially platform-dependent.
19:12:05 <gigatexal> consider me newly baptised into the ways of functional programming, hello everyone
19:12:19 <hodapp> Eduard_Munteanu: yeah, actually :t tells me it's basically the same
19:12:38 <Eduard_Munteanu> gigatexal, hi
19:12:47 <gigatexal> hello hello
19:13:09 <lamefun> Ie. as I understand it, Haskell is pure, but the purity is limited to a single computer.
19:13:28 <hodapp> lamefun: I don't think purity has anything to do with which computer you run it on.
19:14:31 <gigatexal> what is pure?
19:15:20 <Eduard_Munteanu> gigatexal, the fact that computations don't have side-effects
19:16:11 <hodapp> lamefun: or, are you referring to the 'same results given the same inputs' aspect of things?
19:16:17 <gigatexal> isn't that the defintion and pitch for functional inmutable code?
19:16:33 <Eduard_Munteanu> gigatexal, yes
19:17:05 <lamefun> hodapp: I meant that a function will always return the same result for the same inputs within the same computer, but, for example, (fromInteger <some-big-number> :: Int) might return different results depending on the platform.
19:17:12 <gigatexal> does it also mean all algorithms are deterministic? meaning the compiler should be able to make really efficient bytecode?
19:18:32 <hodapp> lamefun: Int's guaranteed in a certain range; if you go outside that range, that's kind of another matter.
19:18:37 <Eduard_Munteanu> gigatexal, the compiler can make some assumptions which lead to possibly more efficient code.
19:19:39 <Eduard_Munteanu> gigatexal, functions may be computed multiple times or in advance, for example
19:19:53 <gigatexal> pretty cool
19:19:55 <lamefun> hodapp: is there a way to statically ensure that a function is 100% deterministic?
19:20:24 <hodapp> lamefun: is there a way to enforce that anything is 100% anything when it comes to the real world?
19:20:49 <lamefun> Standards?
19:21:02 <hodapp> standards don't really pertain to the real world
19:21:06 <ijp> never have done
19:21:48 <gigatexal> do you functional programmers use this approach at all? http://fsharpforfunandprofit.com/posts/recipe-part2/
19:22:35 <lamefun> I meant banning types that are platform-dependent within a certain context, the same way IO does that with side effects?
19:23:41 <Eduard_Munteanu> gigatexal, that's the Either monad from Haskell, as the post also hints at the beginning
19:25:07 <Eduard_Munteanu> gigatexal, and yeah, it's rather common
19:25:23 <gigatexal> good to know
19:25:32 <benzrf> :t (|||)
19:25:33 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
19:25:41 <benzrf> ah
19:25:54 <benzrf> adjoint to (&&&)?
19:28:24 <lamefun> For example, there are turn-based games Wesnoth and Hedgewars, where only the player inputs are sent over the Internet and everything else is computed locally. This scheme depends on all the clients performing exactly the same computations and if they don't due to bugs and/or accidentally introduced platform-dependent code, the game will de-sync and become unplayable.
19:29:19 <lamefun> Can such a scheme be statically ensured in Haskell?
19:35:23 <Hi-Angel> I couldn't figure out, how do I extract a value of MayBe inside an IO monad? ´If-elseª doesn't allow pattern matching, ´>>=ª tells ´couldn't match IO with MayBeªÖ
19:35:46 <pharaun> Hi-Angel: `case foo of`
19:37:05 <Hi-Angel> HmÖ Well, there's a little problem: I should execute the rest of the function if in the MayBe is NothingÖ
19:37:14 <Hi-Angel> *shouldn't
19:39:27 <Eduard_Munteanu> Hi-Angel, put the rest of the function on the Just branch of the case
19:40:39 <Eduard_Munteanu> Hi-Angel, you can also use forM_ from Data.Foldable
19:41:17 <Eduard_Munteanu> > F.forM_ (Just 3) $ \x -> x + 1
19:41:18 <lambdabot>      Could not deduce (Num (m b0))
19:41:18 <lambdabot>      from the context (Monad m, Num (m b))
19:41:18 <lambdabot>        bound by the inferred type for ‚Äòe_131‚Äô:
19:41:34 <dominik> hey guys
19:41:40 <Eduard_Munteanu> > F.forM (Just 3) $ \x -> Left (x + 1)
19:41:41 <lambdabot>      Not in scope: ‚ÄòF.forM‚Äô
19:41:42 <lambdabot>      Perhaps you meant one of these:
19:41:42 <lambdabot>        ‚ÄòF.forM_‚Äô (imported from Data.Foldable),
19:42:09 <dominik> I'm currently trying to play around with haskell-names
19:42:10 <Hi-Angel> Okay, thank you, I'm trying
19:42:18 <Eduard_Munteanu> > F.forM_ (Just 3) $ \x -> putStrLn (show (x + 1))
19:42:20 <lambdabot>  <IO ()>
19:42:48 <dominik> but trying to run the example program shown on https://github.com/haskell-suite/haskell-names fails
19:43:04 <dominik> because apparently something is wrong with my package database.
19:43:10 <dominik> has anyone experience with haskell-names
19:43:26 <dominik> and knows how to make the sample program run?
19:44:09 <dmwit> In my cabal file, I have `Executable foo; other-modules: Foo`. But `cabal repl` doesn't let me load `Foo` unless `Foo` is imported from `Main`. This is a bit obnoxious for development; how can I get a repl that actually knows about all the modules listed in `other-modules`?
19:45:20 <Hi-Angel> Eduard_Munteanu, yes, thank you very much, I tried before the case stmt, but it didn't worked, perhaps I made an error. Now everything fine; I'll take a look at forM_
19:50:01 <dmwit> dominik: (I'm still installing haskell-names, by the way, but I plan to take a quick look at your question.)
19:54:18 <dominik> dmwit: awesome, thanks :)
19:54:32 <dominik> installing haskell names and hs-gen-iface worked for me without any problems
19:54:49 <dominik> but trying to then run the example program fails with a runtime error.
19:55:09 <dominik> apparently the hs-gen-iface package database is still the maintainer's one.
19:55:33 <dominik> but I don't understand the system very well yet
19:56:31 <geekosaur> installed in a sandbox? try cabal exec hs-gen-iface
19:56:44 <geekosaur> (even if you copied it outside the sandbox)
19:58:03 <jle`> Eduard_Munteanu: F.forM_ is now forM_, i think
19:59:26 <dominik> geekosaur, no I installed it normally
19:59:55 <dmwit> Well, when I run the program, I get "exit 1" with no further messages.
20:00:01 <dmwit> So that's really helpful. =/
20:00:10 <dmwit> But... it's a different behavior than the one you're seeing, so that's interesting.
20:00:14 <dominik> hmm, when I try to run it I get:
20:00:45 <dominik> FindHeads.hs: user error (Error: Could not find module: Prelude with any suffix: ["names"] in the search path: ["/home/pschuster/.cabal/lib/x86_64-linux-haskell-names-0.5.1/base-4.7.0.0"]
20:01:03 <dominik> so it seems as if it was trying to use pschuster's package db
20:01:07 <dominik> (i.e., the maintainer)
20:01:30 <dominik> don't you guys run into that problem?
20:01:35 <dmwit> no
20:02:21 <dmwit> Perhaps you are building from the repository instead of Hackage, and he checked something into the repository that he shouldn't have?
20:02:55 <dmwit> ...or perhaps you are building an old version from Hackage? I have built 0.5.2, how about you?
20:03:19 <dominik> same
20:03:44 <dominik> all I did was: cabal install haskell-names hs-gen-iface
20:03:48 <dominik> it builds fine
20:03:48 <dmwit> how odd
20:04:05 <dominik> but then upon trying to run the sample program it shows me this STRANGE error
20:04:35 <dominik> and hs-gen-iface pkg dump shows Philip Schuster's package db...
20:04:42 <dominik> which I think is also VERY strange.
20:07:33 <dmwit> hs-gen-iface complains about a bad package database for me, but one in a completely reasonable location.
20:09:41 <dominik> hmm, ok, I got that error to
20:09:50 <dominik> I definitely need to investigate this further later
20:09:54 <dominik> thanks for your help dmwit!
20:09:58 <dominik> I gotta run
20:10:03 <dominik> I'll look into it later.
20:11:53 <lifter> aww ye
20:19:56 <NicX> There seems to be a number of questions on the web asking "Can my example can be expressed in point-free form?", but I'm yet to come across any literature or commentary which seeks to answer more general questions about what can and what cannot be expressed in point-free form. Can someone here point me in the right direction?
20:25:13 * hackagebot postgresql-schema 0.1.1 - PostgreSQL Schema Management  http://hackage.haskell.org/package/postgresql-schema-0.1.1 (markfine)
20:25:34 <Hi-Angel> NicX, it is because of carrying. See: you have a function ´f x = x+1ª ó its type is ´Integer -> Integerª. Now think a bit: if you would write ´(+1)ª ó what is the type would be? Because of carrying it's just a function that takes Int, and increments it. So, you could write ´f = (+1)ª ó so ´fª is a synonim to the ´(+1)õ, andÖ It is exactly the same type, as in the first form!
20:26:27 <nolrai> Hi
20:26:59 <Jeanne-Kamikaze> yo
20:27:09 <lifter> awye
20:27:55 <nolrai> Oh. Wrong channel. Sorry. 
20:27:56 <ijp> NicX: everything can be
20:29:10 <ijp> it's a very old result relating the lambda calculus to SK combinators, google "bracket abstraction"
20:29:42 <NicX> ijp: so combinatory logic?
20:30:00 <ijp> the mechanical translations end up pretty huge though
20:32:39 <dagwil> does anyone know anything about stack, the cabal replacement? I want to know how to set the defaults when I run 'stack new'
20:33:07 <NicX> ijp: thanks
20:39:32 <mitchty> can i point cabal at a different directory than ~/.cabal perchance
20:40:25 <c_wraith> yes.  I forgot the option, but there is one.
20:44:28 <fizbin> Is there a standard function for "try this monadic action until it succeeds"?
20:46:14 <fizbin> That is, I have f :: (a -> m Bool) and I have lst :: [a], and m is a monad. I want to try "f" on successive elements of lst, but only until it gets a True result back.
20:46:20 <jle`> fizbin: it depends on what you mean by "succeeds", but there's whileM that executes something until it's an True
20:46:31 <jle`> oh, not the same action...but different actions
20:46:55 <dagwil> fizbin: foldM?
20:47:36 <jle`> it looks like andM (map f lst)
20:47:39 <jle`> er, orM
20:47:51 <jle`> oh, anyM
20:48:16 <jle`> anyM :: (a -> m Bool) -> [a] -> m Bool, will execute until it sees the first True
20:48:27 <fizbin> dagwil: I'm not entirely certain how to use foldM for this. It does almost seem like it might work.
20:48:36 <jle`> firstM :: (a -> m Bool) -> [a] -> m (Maybe a), will return the `a` value of the first True result
20:48:59 <dagwil> fizbin: use foldM to make orM as Eisighul says
20:49:09 <fizbin> jle`: Where is that? I find it not on hoogle.
20:49:34 <jle`> it's in monad-loops
20:49:41 <jle`> http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
20:50:42 <dagwil> fizbin: or xs = foldr (||) False xs, you just want the monad version
20:51:21 <jle`> i think that's a type error
20:51:39 <fizbin> dagwil: Right. A naive translation of that to use foldM will evaluate the whole list.
20:52:03 <dagwil> fizbin: yeah, you want to make sure you use lazy evaluation to exit early
20:52:30 <dagwil> dagwil: || in the defintion of or is lazy in its arguments so the second one wont get evaluated if the first is true
20:54:06 <jle`> yeah, but i don't think liftA2 (||) is lazy. hm
20:54:13 <jle`> > liftA2 (||) (Just True) undefined
20:54:14 <lambdabot>  *Exception: Prelude.undefined
20:54:27 <jle`> (||)'s laziness doesn't translate over to monadic contexts
20:54:27 <dagwil> jle`: that's a problem
20:55:06 <c_wraith> well, (||)'s laziness is irrelevant.
20:55:35 <c_wraith> The relevant laziness, or lack thereof, is from >>=
20:55:41 <dagwil> Prelude Control.Monad> let a ||| b = do { bool <- a; if bool then return () else b }
20:55:41 <dagwil> Prelude Control.Monad> Just True ||| undefined
20:55:41 <dagwil> Just ()
20:55:48 <nolrai> > liftA2   (||) (Just True) (Just undefined)
20:55:50 <lambdabot>  Just True
20:56:38 <jle`> yeah, for most monads it still requires the "effects", just not the resulting value
20:56:53 <jle`> but in this case fizbin cares about the effects being short-circuited, not the evaluation of the value
20:57:12 <fizbin> Right.
20:58:05 <fizbin> So firstM it is. I may just steal the definition, since it's so short.
21:00:23 <nolrai> ||| above is the same as (\ a b = a >>= flip when b) right? 
21:00:44 <dagwil> nolrai: I think so.
21:01:09 <nolrai> No (flip when b) . Not
21:01:26 <dagwil> nolrai: You'd want to change ||| to have type  Monad m => m Bool -> m Bool -> m () if you wanted to use it in foldM
21:04:54 <Quantumplation> Hey there!  I just got my first non-toy haskell program working.  I'd love any feedback on it, as i'm sure there's a lot of places I could have done things in a more haskell idiomatic way: https://github.com/Quantumplation/RunscopeExport
21:06:08 <jle`> congrats Quantumplation :)
21:07:14 <Quantumplation> Hehe thanks.  It was a ton of fun, and really enlightening.  I've been following Haskell for years, but more as an appreciator from afar and not as an active developer, other than Project Euler problems etc.
21:07:23 <Quantumplation> There's a lot of room for improvement though :P
21:08:53 <fizbin> Quantumplation: Have you run it through hlint? Most of what I know of proper haskell idioms comes from running stuff through hlint.
21:09:32 <Quantumplation> Hmm, I have not! Good idea hehe
21:10:34 <dagwil> Quantumplation: I guess you could try and break apart main and handleResponse. They're rather wordy. That or write some tests for it.
21:19:13 <jle`> anyone else think there should be an instance MonadError () Maybe
21:19:22 <jle`> i ask because i do
21:20:12 <L8D> does anyone know how to use UUIDs with persistent?
21:23:50 <gfixler> How hard is it to embed Haskell in Haskell?
21:24:28 <gfixler> i.e. can I make a Haskell terminal app with a Haskell repl in it, which doesn't require Haskell to be installed?
21:25:19 <bitemyapp> gfixler: hint?
21:25:36 <c_wraith> Not really.  hint basically doesn't work without ghc installed
21:25:44 <bitemyapp> thus the question mark. Now I know.
21:26:01 <bitemyapp> c_wraith: mu-eval has historically been a nightmare to install/build, but does it work standalone?
21:26:13 <c_wraith> No, mueval also uses hint
21:26:29 <bitemyapp> blah.
21:26:34 <gfixler> :(
21:26:37 <ronh> does ghc has to be installed or can it be shipped with the executable?
21:26:44 <ronh> have*
21:27:07 <gfixler> fallback plan: how hard would it be to embed PHP in Haskell?
21:27:07 <c_wraith> It needs to be able to find the package database
21:27:39 <c_wraith> So..  A package database needs to exist, in one way or another.
21:27:48 <bitemyapp> app could ship that though right?
21:27:56 <c_wraith> You could theoretically bundle one with your program, and set the hint options to point to it
21:28:00 <gfixler> this seems like it would be really big
21:28:08 <c_wraith> It'd make the distribution kind of huge
21:28:30 <bitemyapp> gfixler: not prohibitive though
21:28:39 <bitemyapp> gfixler: my sandbox with lens and some other stuff installed is 75mb
21:28:47 <bitemyapp> admittedly that doesn't include global.
21:29:03 <gfixler> bitemyapp: NixOS?
21:29:13 <bitemyapp> Ubuntu
21:29:20 <gfixler> ah, same here
21:29:28 <gfixler> hmmm
21:29:32 <bitemyapp> sandbox here means "Cabal sandbox"
21:29:37 <bitemyapp> which is a package-db
21:29:42 <gfixler> maybe it's best to require installing haskell if you want to have cool scripting abilities
21:30:15 <bitemyapp> I don't think that's strictly required, but it may be better for your situation
21:30:20 <bitemyapp> xmonad does require ghc to be in the path.
21:30:32 <gfixler> is ghc all that's really required?
21:30:45 <gfixler> we were just talking about the package db
21:30:47 <bitemyapp> ghc implies base and the rest of the global package-db.
21:30:57 <bitemyapp> also xmonad has to recompile itself
21:31:07 <gfixler> ok
21:31:13 <bitemyapp> so it needs the XMonad libraries, default libraries, and the compiler.
21:31:35 <bitemyapp> I could imagine shipping a standalone REPL or embedded scripting interface as a binary. I just don't know if it'd be worth the hassle for most to do that for their own projects.
21:31:43 <gfixler> I've had a pretty hard time getting any sense of the layout of a Haskell install
21:31:54 <bitemyapp> scripting implies you need a totally open universe of configuration/behavior or that they're there to use Haskell specifically.
21:31:54 <c_wraith> I mean, minimally, you only need a package database with prebuilt packages and linking to the ghc library
21:32:18 <c_wraith> You wouldn't need the ghc binaries
21:35:36 <mniip> how would I go about reading a 64kib file into IOArray Word16 Word8?
21:39:04 <c_wraith> mniip: I'd look at hGetArray
21:39:11 <c_wraith> mniip: https://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array-IO.html
21:39:20 <mniip> hmm
21:39:28 <mniip> still needs a reindex
21:39:33 <c_wraith> mniip: it'll need some massaging, but combined with unsafeThaw and the reindex, you're ok
21:39:42 <c_wraith> the reindex should be an O(1) operation
21:39:59 <c_wraith> It can share the backing array - it only needs to update the bounds object
21:40:02 <mniip> unsafeThaw eh
21:40:13 <mniip> I'd rather mapIndices fromInteger
21:40:26 <mniip> Integral*
21:40:39 <c_wraith> Oh, it's already an IOUArray
21:40:51 <c_wraith> In that case, no thaw necessary
21:40:57 <c_wraith> for some reason, I read it as UArray
21:41:00 <c_wraith> that's why I mentioned the thaw
21:41:53 <mniip> hmm
21:42:00 <mniip> mapIndices is contravariant though
21:42:02 <mniip> interesting
21:42:12 <mniip> makes some sense I guess
22:12:32 <jle`> i'm going to make a package named `query` but i feel bad taking up such a ubiquitous word in the haskell namespace
22:12:45 <jle`> it's called that way becuase it provides a type/monad called Query
22:12:59 <jle`> i always feel bad taking up things in a global namespace v.v
22:15:23 <bitemyapp> jle`: what is Query?
22:16:11 <jle`> it is a little type for writing effectful queries in a pure manner, delaying specifying effects of actually executing the queries until later
22:16:39 <jle`> so a `Query String String a` produces an `a` by asking with a String and getting String as an answer
22:16:59 <bitemyapp> free monad necked down to something Reader'ish?
22:17:14 <bitemyapp> let me rephrase, how is this something other than a less general Free?
22:17:23 <jle`> yeah, and you can do runQuery :: (a -> m b) -> Query a b r -> m r
22:17:42 <bitemyapp> can you do your thing as type synonyms of Free?
22:17:43 <jle`> you can implement it using Free on a certain type
22:17:51 <bitemyapp> hrm.
22:17:52 <jle`> but you can implement most monads using Free on a certain functor...
22:18:04 <bitemyapp> Query is going to imply "relational" not "Reader" to most people
22:18:05 <jle`> saying you can implement it using Free on a specific Functor doesn't tell you much heh
22:18:20 <bitemyapp> http://hackage.haskell.org/package/opaleye-0.3.1.2/docs/Opaleye-QueryArr.html has a stronger claim to what people would expect, IMO.
22:18:29 <jle`> it's like Reader, but instead of ask :: m a, it's askFor :: a -> m b
22:18:34 <bitemyapp> I think you've got something interesting, but I'm not sure Query is the best name.
22:18:43 <jle`> query the database for the `a` and get a `b`
22:19:00 <nolrai> Isn't that prompt ?
22:19:26 <nolrai> Yes. It is. 
22:19:29 <jle`> oh, is that a type already out there?
22:19:44 <bitemyapp> jle`: that's not preciiiisely m'point
22:19:52 <bitemyapp> Opaleye is something different (it's relational)
22:20:06 <jle`> nolrai: do you mean MonadPrompt
22:20:09 <bitemyapp> Opaleye's query datatype is going to violate fewer peoples' expectations of what "Query" will mean.
22:20:19 <nolrai> I think so? 
22:20:45 <bitemyapp> jle`: it looks similar.
22:20:59 <bitemyapp> jle`: p a -> m a. Not sure why they have same type for input/output.
22:21:11 <bitemyapp> jle`: I think prompt is a better word for this too.
22:21:18 <jle`> prompt might be better, yeah
22:21:25 <bitemyapp> jle`: query implies relations. Relations implies profunctor...SQL...etc.
22:21:44 <jle`> so right now i have data QueryT a b t r = QueryT { runQueryTM :: forall m. (a -> m (t b)) -> m (t r)) }
22:21:45 <bitemyapp> jle`: Prompt matches the Reader-of-Map/Free'ish thingy you've got going.
22:21:53 <jle`> yeah, that does make sense
22:22:03 <nolrai> You use GADTs  to distinguish the in and out. 
22:22:58 <bitemyapp> jle`: the prior art here (MonadPrompt) is interesting, but your types make more intuitive sense at a first glance.
22:23:08 <bitemyapp> jle`: either that means we're both naive or you've got some better UX.
22:23:09 <nolrai> That way you can have more then one in/out pairing.
22:24:00 <nolrai> Which is really what MonadPrompt is for. 
22:24:33 <jle`> it looks like the purpose of prompt is a bit different altogether than what my type is for
22:24:38 <jle`> and the different types reflect it
22:24:47 <jle`> you can't really them to implement the other
22:24:50 <jle`> but now to pick a better name
22:25:02 <nolrai> I am pretty sure you can. 
22:25:25 <c_wraith> isn't Prompt an early free monad experiment?
22:25:38 <nolrai> Unless I am really miss understanding your semantics. 
22:25:49 <nolrai> Sort  of?
22:25:56 <jle`> it looks sort of like one
22:26:06 <jle`> also it seems to be based on continuations
22:26:11 <jle`> i do'nt think the types are compatible
22:26:28 <nolrai> That's just a efficiency hack. 
22:27:31 <jle`> i guess you do things by picking the right `p`
22:27:51 <c_wraith> Yeah, MonadPrompt appears to be equivalent to operational.
22:28:16 <c_wraith> Except with a few more awkward type signatures
22:28:34 <nolrai> It was not actually meant to be that genral.
22:28:37 <nolrai> Hmm. 
22:29:13 <nolrai> So does free make prompt useless? 
22:29:25 <c_wraith> well, it's equivalent to Operational, not Free
22:30:02 <nolrai> I meant the packages.
22:30:04 <jle`> ah, you can generate my type using a specific choice of data type to wrap.  but that is the same as any Monad ever in the history of the world...
22:30:22 <jle`> *the same thing can be said for any...
22:30:29 <c_wraith> yes, any monad can be modeled with the operational approach
22:31:18 <c_wraith> It's a very, well....  operational.... view of the semantics.  You pick the primitive operations, the library handles composing them all for you, and you provide an interpreter for the composed blocks
22:31:23 <jle`> well prompt is not taken yet in hackage so i'll just steal it then
22:33:03 <jle`> maybe i'll call it `please`
22:33:13 <jle`> to be more polite
22:35:52 <bitemyapp> jle`: :)
23:10:20 * hackagebot functor-infix 0.0.2 - Compositions of functors.  http://hackage.haskell.org/package/functor-infix-0.0.2 (vi)
23:16:07 <Sindriava> Hi! Is there anyone I could talk to about Nix?
23:16:34 <scutigera> i'm of no help :-(
23:19:54 <Sindriava> I'm still kinda confused about it, so I'd like to just get a general feel for what it's good for
23:27:14 <Maxdamantus> Sindriava: there's #nixos if you haven't found it yet.
23:28:27 <Sindriava> Thanks! I was wondering more about haskell specific parts, really
23:28:37 <Sindriava> But I'll check it out :)
23:29:15 <Maxdamantus> You mean the cabal-derived packages?
23:29:51 <Maxdamantus> it includes a functional language, but it's not particularly related to Haskell.
23:30:14 <Maxdamantus> though it is very similar to a previous language/system implemented by the same person in Haskell (maak).
23:35:21 * hackagebot functor-infix 0.0.3 - Infix operators for mapping over compositions of functors. Lots of them.  http://hackage.haskell.org/package/functor-infix-0.0.3 (vi)
23:37:35 <Sindriava> Sorry, spotty connection here
23:37:49 <Sindriava> Maxdamantus: I meant using Nix for haskell development.
23:38:18 <Sindriava> Maxdamantus: From what I understand, I still need to use cabal, so I don't really get why there's so much haskell packages in nixpkgs
23:38:22 <Maxdamantus> Ah, okay. Dunno if it be better to ask here or there.
23:38:36 <Maxdamantus> it seems to often be mentioned here though.
23:39:22 <Sindriava> Yeah, I figured haskell specific stuff might be better suited here
23:39:50 <Sindriava> I'm really just confused about how to use Nix, I guess.
23:40:24 <Sindriava> What I want is to set up multiple development environments, so I keep Rust and Haskell and whatever else separated
23:40:36 <Sindriava> and also use Nix as a regular package manager instead of Homebrew
23:40:54 <Sindriava> But the Nix docs and all the tutorials online are kinda vague, or I just don't understand them properly.
23:43:43 <Sindriava> To put it in haskell community terms: I've yet to gain intuition for how Nix works
23:48:10 <supki> Sindriava: have you seen https://github.com/NixOS/cabal2nix/blob/master/doc/user-guide.md ? I think it does a good job of explaining how to use Nix with Haskell.
23:48:52 <supki> Sindriava: also nix pills (https://github.com/NixOS/cabal2nix/blob/master/doc/user-guide.md), if you're interested in how Nix works in general
23:48:54 <Sindriava> supki: Oh, neat! Thanks"
23:48:56 <supki> oops
23:49:18 <supki> lethalman.blogspot.com/2014/07/nix-pill-1-why-you-should-give-it-try.html
