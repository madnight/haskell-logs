00:01:11 <pacak> zettablade: just try carefully substituting everything into everything else.
00:02:53 <liste> maybe the Functor instance of (->) r trips you?
00:03:04 <liste> or Applicative
00:03:28 <liste> in this case
00:03:46 <zettablade> I think that the applicative of (->) r is what is confusing me.
00:04:20 <liste> it's tricky
00:07:24 <zettablade> For (->) r I've got the definition (<*>) f g x = f x (g x). It seems weird to me, but looking at it does clear up how that loft works.
00:07:29 <zettablade> lift*
00:07:38 * hackagebot bloodhound 0.6.0.0 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.6.0.0 (bitemyapp)
00:07:38 * hackagebot anansi 0.4.8 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.4.8 (JohnMillikin)
00:09:05 <YellowOnion> :t mod
00:09:07 <lambdabot> Integral a => a -> a -> a
00:10:32 <liste> :t rem
00:10:35 <lambdabot> Integral a => a -> a -> a
00:11:25 <YellowOnion> I wonder why chr doesn't take a type of Integral
00:12:17 <Haskellfant> YellowOnion: you can't really convert an arbitrary large Integer into a Char
00:12:33 * hackagebot raml 0.1.0 - RESTful API Modeling Language (RAML) library for Haskell  http://hackage.haskell.org/package/raml-0.1.0 (fnoble)
00:12:59 <liste> > chr (maxBound :: Int)
00:13:01 <lambdabot>  *Exception: Prelude.chr: bad argument: 9223372036854775807
00:13:14 <liste> you can't convert all Ints, either
00:13:15 <YellowOnion> Haskellfant, ahh right
00:14:00 <Haskellfant> yeah it isn't even total on Ints so I guess one could make the argument for allowing any Integrals
00:14:01 <liste> > chr (-50)
00:14:04 <lambdabot>  *Exception: Prelude.chr: bad argument: (-50)
00:14:37 <liste> but I guess monomorphism performs better
00:16:49 <liste> is chr in Prelude now?
00:17:07 <liste> Prelude.chr: bad argument: got me thinking
00:18:02 <YellowOnion> > chr ( 123 :: Word8 )
00:18:04 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Word8’
00:18:04 <lambdabot>      In the first argument of ‘chr’, namely ‘(123 :: Word8)’
00:18:04 <lambdabot>      In the expression: chr (123 :: Word8)
00:18:43 <YellowOnion> OK I think I've gone on about this enough.
00:34:44 <breadmonster> Hey everyone.
00:34:51 <breadmonster> What's an easy way to implement a trie?
00:37:03 <earthy> breadmonster: import Data.Trie
00:37:31 <breadmonster> earthy: Is that I have to run run a fairly intricate fold operation on it...
00:37:55 <breadmonster> So that's why I want to be able to interpimplement it myself.
00:38:41 <breadmonster> earthy: S obaiyoYou You know how in Parsec there's that string command for concatenation?
00:39:09 <earthy> what, an instance of Foldable isn't enough?
00:39:11 <gienah> tries are discussed in section 10.3.1 of Okaskai - Purely Functional Data Structures
00:39:13 <breadmonster> brb I'm going to use erc
00:40:38 <breadmonster> earthy: No, I mean I'd like some control over the recursion, because a simple fold will be much uglier.
00:41:11 <earthy> breadmonster: ah. check out hackage. there's a bunch of trie package.s
00:41:20 <breadmonster> Like how for instance map can be written with foldr but like it's hideous that way.
00:41:26 <breadmonster> and inefficient.
00:42:34 * hackagebot rasterific-svg 0.2.3.1 - SVG renderer based on Rasterific.  http://hackage.haskell.org/package/rasterific-svg-0.2.3.1 (VincentBerthoux)
00:46:22 <maxc01> hello, I'm trying to use `haskeline`, but I cannot get it right
00:46:32 <maxc01> repl :: InputT (ReaderT Int IO) ()
00:46:32 <maxc01> repl =
00:46:32 <maxc01>   do minput <- getInputLine "% "
00:46:32 <maxc01>      case minput of
00:46:32 <maxc01>        Nothing    -> return ()
00:46:32 <maxc01>        Just input -> return ()
00:46:56 <maxc01> this is my simple simple example
00:48:35 <maxc01> the error message is `No instance for (MonadException (ReaderT Int IO))`
00:49:49 <LordBrain> reverse Int and IO
00:49:55 <LordBrain> in the type sig
00:50:57 <liste> @info ReaderT
00:50:57 <lambdabot> ReaderT
00:51:02 <lyxia> That wouldn't have the right kind.
00:51:22 <LordBrain> oh i didnt test, i just looked at the haddock
00:51:46 <maxc01> LordBrain, it cannot be reversed, the first para of ReaderT is the environment
00:51:47 <liste> there's no instance MonadException m => MonadException ReaderT r m
00:52:16 <liste> sorry, there is
00:52:22 <LordBrain> i see, my mistake, i misread that and thoguht it wast he InputT transformer i was lokoing at
00:52:32 <liste> ghci :info just didn't show it
00:52:54 <maxc01> liste, but in haskeline, there is (MonadIO (ReaderT r m), MonadException m) => MonadException (ReaderT r m)
00:53:20 <liste> maybe you need to import the instance?
00:53:38 <liste> import System.Console.Haskeline.MonadException() ?
00:53:38 <maxc01> yes, i did
00:54:06 <maxc01> still cannot work
00:54:24 <lyxia> maxc01: Are you using the right ReaderT?
00:54:51 <maxc01> the right ReaderT??
00:55:03 <maxc01> is there another ReaderT
00:55:56 <maxc01> lyxia, i use thisimport           Control.Monad.Reader
00:56:15 <merijn> There is only one ReaderT...
00:56:53 <LordBrain> Trans
00:57:08 <liste> mtl re-exports the transformers
00:57:15 <liste> from transformers package
00:57:50 <LordBrain> well then he has it 
00:58:40 <lyxia> I was thinking that perhaps for some reason you were using a homemade ReaderT but nvm me.
00:58:41 <maxc01> ee, both cannot work
01:00:19 <liste> by the way, you need to `lift' the getInputLine
01:00:32 <liste> that shouldn't cause that type error, though
01:01:07 <liste> srry, not that
01:01:10 <liste> nevermind
01:01:28 <liste> getInputLine doesn't need to be lifted, it's outermost
01:02:28 <lyxia> maxc01: Can you post a complete example on lpaste?
01:02:39 <maxc01> of course
01:03:13 <maxc01> lyxia, http://lpaste.net/133909
01:04:18 <maxc01> it is strange
01:04:35 <lyxia> Indeed.
01:05:27 <supki> this kind of error usually means you have multiple transformers versions installed
01:10:28 <maxc01> yes, supki, I do have multiple transform
01:14:17 <LordBrain> well, use a cabal sandbox i guess
01:14:27 <supki> maxc01: so haskelline was compiled against the transformers that came with GHC and import Control.Monad.Reader gets you the wrong ReaderT
01:15:03 <supki> maxc01: the solution is to remove the version that didn't come with GHC
01:16:05 <maxc01> Great, supki
01:16:17 <maxc01> It worked
01:16:24 <maxc01> Thanks
01:17:18 <supki> what I like about this error is how the error message is technically correct and completely useless to the user
01:17:25 <supki> maxc01: I'm glad I helped :)
01:18:46 <LordBrain> remove, or hide?
01:19:19 <LordBrain> wouldnt removing it mean possibly breaking some other package?
01:19:35 <maxc01> I just create a new sandbox, and I dare not to remove or hide a package globally
01:22:24 <LordBrain> i'm adapting an ircd server to be more general code, and so instead of irc messages coming in, it is arbitrary type with Serialize instance. My code used hGetLine for the IRC, what should i use for an arbitrary case? have some terminator passed in and then do a span or something on hGetContents ?
01:22:58 <LordBrain> anyone with a good recommendation here?
01:23:09 <mniip> LordBrain, probably a parsec with a socket stream
01:24:25 <LordBrain> i am talking about the question of how to get the bytes out of the handle, parsing it is not an issue
01:25:09 <LordBrain> i guess i could just leave it all and insist on line buffering
01:37:37 * hackagebot clash-vhdl 0.5.6 - CAES Language for Synchronous Hardware - VHDL backend  http://hackage.haskell.org/package/clash-vhdl-0.5.6 (ChristiaanBaaij)
01:48:51 <lamefun> are simple records outdated?
01:49:11 <liste> no!
01:49:22 <lamefun> like data Package = Package { pkgName :: String, pkgVersion :: Version }
01:49:55 <liste> they're standard (:
01:52:17 <liste> I don't think they're going anywere for a long time
01:57:35 <thehiddenrain> whyso many haskell people
01:57:39 <thehiddenrain> what do you people actually do with haskell
01:58:19 <merijn> thehiddenrain: The same people do with other languages?
01:59:18 <thehiddenrain> like?
01:59:45 <merijn> thehiddenrain: Data processing, prototypes, shell scripts...
01:59:58 <thehiddenrain> cool
02:07:42 <fvgvxmpv1> runhaskell is wonderful for shell-scripting
02:12:44 <iyeti> Hello
02:34:09 <lpaste> lamefun pasted “Why does this even compile?” at http://lpaste.net/133913
02:35:02 <lpaste> lamefun revised “Why does this even compile?”: “No title” at http://lpaste.net/133913
02:35:35 <lamefun> I thought Haskell is safety-focused...
02:35:55 <barrucadu> To be fair, the compiler does tell you off that you've got an incomplete pattern match
02:36:36 <frerich> lamefun: It compiles because it's well-typed: 'foo' takes a value of type Boom and you pass it a 'C' (which indeed is a value of type Boom).
02:36:54 <frerich> lamefun: As barrucadu mentions, if you compile it with warnings enabled you'll see that it warns you about an incomplete pattern match though.
02:37:11 <lamefun> why isn't it an error by default?
02:37:25 <dario`> lamefun: there's languages that don't allow such constructs. if you're interested, search for agda, idris or coq
02:37:56 <dario`> lamefun: it's usually a tradeoff between catching more errors and making programms harder to write
02:40:42 <lamefun> "making programms harder to write" - ?
02:41:02 <lamefun> Can't one simply foo _ = error
02:43:02 <barrucadu> That's arguably worse: you've still got the runtime failure, but now you don't also get a compile-time warning about it
02:44:04 <barrucadu> If you know that some cases can never arise (for example, it's a function used in the implementation of a module, and isn't exposed to users) then it's perfectly reasonable to not have patterns for those cases
02:45:01 <lamefun> I get no warnings for these...
02:45:16 <merijn> lamefun: -Wall
02:45:18 <barrucadu> Compile with -Wall
02:46:55 <luyifan> I don't understand why :type zipWith ($) is [b -> c] -> [b] -> [c]
02:47:24 <luyifan> when zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
02:47:39 <luyifan> and  ($) :: (a -> b) -> a -> b
02:47:40 * hackagebot postgresql-config 0.0.2 - Types for easy adding postgresql configuration to your program  http://hackage.haskell.org/package/postgresql-config-0.0.2 (AlekseyUymanov)
02:49:31 <Haskellfant> luyifan: so zipWith takes a (a -> b -> c)
02:49:43 <Haskellfant> now substitute $ for that
02:49:51 <Haskellfant> what is a, b & c then?
02:50:17 <luyifan> oh , I understand
02:50:24 <luyifan> thx
02:50:26 <Haskellfant> np
02:55:30 <lpaste> lamefun pasted “I don't export foo, but it still complains with -Wall...” at http://lpaste.net/3571058576963141632
02:56:41 <merijn> lamefun: Well, sure...
02:56:45 <merijn> lamefun: Why wouldn't it?
02:57:09 <lamefun> barrucadu said: "If you know that some cases can never arise (for example, it's a function used in the implementation of a module, and isn't exposed to users) then it's perfectly reasonable to not have patterns for those cases"
02:57:26 <merijn> Yeah, but the compiler doesn't know that
02:57:33 <lamefun> and "That's arguably worse: you've still got the runtime failure, but now you don't also get a compile-time warning about it"
02:57:58 <lamefun> Well, it's the same thing as compile-time errors really, I still have to put in foo _ = error to silence the warnings...
02:58:17 <barrucadu> But now the function is no longer exposed to users of the library, so a user cannot trigger the error. That's fine.
02:59:35 <barrucadu> I just think it's usually worse to have a user-facing function calling error than one with a pattern match failure, as the latter will give a compiler warning - reminding you that something is missing
03:00:50 <lamefun> "That's arguably worse: you've still got the runtime failure, but now you don't also get a compile-time warning about it" - so no, both cases are the same?
03:01:37 <barrucadu> They're not the same: if everything is exported, someone could write "foo C" in their code and, without any sort of compile-time warning, have it error at runtime.
03:01:38 <lamefun> Because warnings are the same thing as errors, really, it's still best to have them fixed.
03:01:42 <barrucadu> In the latter, someone can't do that
03:02:38 <lamefun> why is the warning buried under -Wall?
03:08:22 <Wisely> What is Haskell good for?
03:09:02 <srhb> Wisely: Programming.
03:10:04 <z16> Wisely: Currying
03:10:11 <z16> Who doesn't like curry
03:10:36 <Taneb> Wisely, many things! It is a general purpose programming language used in various spheres.
03:11:52 <Taneb> Wisely, some consider it especially apt for parsing, program generation, and parallel computation, although it is also used for many things including web servers and games!
03:32:43 <maerwald> Taneb: it is rarely used for games
03:33:27 <Taneb> maerwald, but it is used for games, I was just throwing examples around
03:33:48 <maerwald> Taneb: but games are not such a great example since there are a couple of issues with those
03:34:08 <Taneb> I guess...
03:42:42 * hackagebot xml-conduit-parse 0.2.0.0 - Streaming XML parser based on conduits.  http://hackage.haskell.org/package/xml-conduit-parse-0.2.0.0 (koral)
03:47:42 * hackagebot opml-conduit 0.3.0.0 - Streaming parser/renderer for the OPML 2.0 format.  http://hackage.haskell.org/package/opml-conduit-0.3.0.0 (koral)
03:59:05 <julm> Hi there :) Has anyone ever tried to remove expression quotations [|things_like_that|] in a GHC module file? They do not seem to be portable on systems without a stage-2 compiler (like MIPS). I've used -ddump-ds to get a desugarized version of them, but replacing with this does not appear to be equivalent, because it sometimes fails the type check (like instance of something not found, or more harder type errors)
04:02:29 --- mode: ChanServ set +o mauke
04:02:29 --- mode: mauke set +b *!*@117.Red-83-39-250.dynamicIP.rima-tde.net
04:02:32 --- kick: dameloo was kicked by mauke (dameloo)
04:04:32 --- mode: mauke set -o mauke
04:06:09 <k0ral> hello
04:07:36 <supki> julm: there was a blog post about that
04:07:44 <quchen> julm: TH dumps are indeed not guaranteed to work when you paste it in. But I've never had to do this at scale :-|
04:07:45 <supki> julm: here: http://joeyh.name/blog/entry/Template_Haskell_on_impossible_architectures/
04:07:56 <k0ral> isn't GHC 7.10 supported by Travis CI ? I'm getting the error "ghc_find: error, no such version 7.10"
04:08:10 <supki> I'm not sure whether the situation has improved since then
04:08:31 <hvr> k0ral: *cough* https://github.com/hvr/multi-ghc-travis *cough*
04:09:31 <k0ral> hvr: I've read that, it boils down to redefine the whole test script; are you suggesting that the pre-defined script (with "language: haskell") can't work with 7.10 ?
04:09:36 <julm> supki: thanks!
04:10:06 <hvr> k0ral: the pre-defined environment has less GHC versions available; and it seems they haven't yet included 7.10.1 
04:10:56 <k0ral> hvr: alright, I'll go with that, thanks
04:22:36 <julm> well, I guess I'd better find a way without using TH at all.. in my case not using shakespeare-i18n but directly using Haskell data types as described here: https://wiki.haskell.org/Internationalization_of_Haskell_programs#Using_native_Haskell_data_types
04:25:47 <ocharles_> http://packdeps.haskellers.com/reverse down?
04:26:59 <indiagreen> ocharles_: down for me
04:27:04 <ocharles_> bummer
04:27:06 <ocharles_> oh well!
04:31:40 <Gurkenglas> Are there any papers or the like on instances being seen as functors from a kleisli category into Hask?
04:34:13 <Gurkenglas> ("literature" == "papers or the like", right?)
04:39:13 <Myrl-chan> Is file I/O atomic?
04:40:07 <Myrl-chan> Hmmm... perhaps atomic is not the correct word there.
04:42:16 <quchen> Probably not.
04:42:21 <quchen> Depending on what you mean with "atomic".
04:42:45 * hackagebot spdx 0.0.1.0 - SPDX license expression language  http://hackage.haskell.org/package/spdx-0.0.1.0 (phadej)
04:43:25 <Myrl-chan> quchen: Basically, 2 programs access a single file.
04:43:41 <Myrl-chan> quchen: They read the file as a number, increment, then write again.
04:43:45 <Myrl-chan> quchen: How should I do that
04:44:01 <Myrl-chan> Use a .lock file?
04:45:20 <mauke> you might be able to get away with locking the file itself
04:46:12 <Myrl-chan> mauke: locking the file itself?
04:46:33 <mauke> yes
04:49:28 <Myrl-chan> Hmm
04:50:31 <quchen> Myrl-chan: Maybe acid-state is worth a look as well.
04:51:37 <Myrl-chan> quchen: I'm reading this. https://hackage.haskell.org/package/filelock-0.1.0.1/docs/System-FileLock.html
04:52:08 <Myrl-chan> Also, this is between processes, not threads.
04:52:32 <Myrl-chan> Which means I should be using threads later, since clearly, using processes is not a good idea.
05:02:27 <Myrl-chan> Er
05:04:22 <CurryWurst> hi
05:04:29 <CurryWurst> a dummy question
05:05:22 <CurryWurst> how to get the the function to work with Maybe data type?
05:05:25 <CurryWurst> http://lpaste.net/133919
05:06:45 <jorr> Hmm, what's up with the commented out bit?  In particular, there doesn't seem to be an Empty in your data type.
05:10:01 <CurryWurst> jorr: that was other tree definition
05:10:05 <CurryWurst> data Tree a = Empty | Node (Tree a) a (Tree a)
05:11:08 <CurryWurst> I have to implement that function with Maybe type
05:11:32 <jorr> What have you tried / what errors do you get?
05:12:55 <jorr> If you just need to get the functor instance to work, it looks like you could just remove the second equation that handles Empty.
05:14:15 <jorr> Ooh, or maybe I'm wrong actually.  Seems like you have to fmap twice on the branches?
05:14:36 <CurryWurst> yes
05:15:22 <jorr> Have you tried that?
05:15:25 <jorr> :t fmap . fmap
05:15:28 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:15:47 <CurryWurst> fmap f (MaybeNode left a right) = MaybeNode (fmap f left) (f a) (fmap f right) - doesn't work
05:16:35 <jorr> fmap . fmap will take a "regular function" and lift it into on that will operate over a doubly nested functor stack
05:16:49 <jorr> Right, you probably will need something like (fmap . fmap)
05:17:04 <jorr> Take a look at that type signature, it might make the situation clearer.
05:22:47 * hackagebot relational-query 0.5.0.1 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.5.0.1 (KeiHibino)
05:33:27 <Profpatsch> Is it possible to use Aeson Generically, but specify the case of the keys doesn’t matter?
05:33:46 <Profpatsch> With the GHC Generics module that is.
05:45:26 <sgflt> when writing a function declaration (e.g. foo :: (Ord a) => [a] -> [a]), can I refer to a to indicate the type of other values inside the function definition?
05:46:08 <pacak> sgflt: Hmmm?
05:46:26 <sgflt> i'm trying to construct a heap in a where clause
05:46:40 <pacak> sgflt: ScopedTypeVariables + foo :: forall a. Ord a => [a] -> [a]
05:46:44 <pacak> This?
05:47:28 <sgflt> not familiar with the syntax, i'll have to google that, sorry
05:48:32 <pacak> Are you getting strange type error about `a` being not the same as `a1`?
05:48:45 <sgflt> Could not deduce (a ~ a1) to be exact
05:49:04 <sgflt> " Could not deduce (a ~ a1)"  to be exact =)
05:49:10 <pacak> Yep, add {-# LANGUAGE ScopedTypeVariables #-} and put forall a. before your function
05:49:37 <pacak> foo :: forall a. Ord a => [a] -> [a]
05:49:47 <sgflt> i might, but first i have to figure out why (and whether or not there's a better way)
05:50:28 <pacak> Well, by using that you tell ghc that all `a` you use in this functions are the same as `a` you mentioned in the type signature.
05:50:59 <sgflt> i see. i can't see a way around it, unless there's a way to somehow use an incomplete type?
05:51:26 <pacak> You can drop type signatures from stuff under where
05:51:48 <sgflt> but as i understand it, haskell needs those to figure out whether i want a MinHeap or MaxHeap
05:53:32 <pacak> Not sure which heap are you using, but there's nothing bad about ScopedTypeVariables.
05:53:56 <sgflt> probably not. just more things for a beginner to learn =)
05:54:00 <sgflt> using Data.Heap
05:54:38 <notdan> What should I use for HTML scrapping?
05:54:43 <notdan> Tagsoup or HTML-conduit?
05:54:57 <sgflt> pacak, https://gist.github.com/mbr/4c363a3467ed59ec6da8 -- what i ended up with
05:55:03 <sgflt> pacak, thanks
05:55:53 <pacak> \x -> True == const True
05:55:59 <yuu-chan> Hello Haskellers!
05:56:10 <byorgey> hi yuu-chan!
05:56:20 <sgflt> pacak, thanks again. is takeWhile event the right function to use here?
05:56:46 <yuu-chan> I need to generate some random HTMLs, for which I'd want to use QuickCheck's Arbitrary and Blaze' HTML. They
05:57:13 <yuu-chan> *They're both monads, is it possible to combine them with some transformers?
05:58:00 <pacak> sgflt: If it's from heap package - there's toAscList
05:58:29 <pacak> sgflt: heapSort = H.toAscList . H.fromList
05:58:53 <byorgey> yuu-chan: I don't think either the MarkupM monad nor the Gen monad have transformer versions.  But you shouldn't need that anyway.
05:58:56 <dramforever> yuu-chan: you don't have to
05:59:23 <dramforever> you can write an instance for Arbitary Markup
06:00:12 <yuu-chan> dramforever: yes, but I won't be able to use do-syntax for composing the markup
06:00:24 <byorgey> yuu-chan: yes you will.
06:00:26 <dramforever> yuu-chan: that shouldn't matter too much
06:00:35 <arbelos> How does one deal with "Warning: This package indirectly depends on multiple versions of the same package" problems?
06:00:45 <pacak> arbelos: Panic!
06:01:02 <dramforever> arbelos: complain to package author
06:01:03 <arbelos> pacak. I have done that already :)
06:01:10 <pacak> arbelos: And then reinstall everything - usually fixes that.
06:01:17 <pacak> Or cabal sandboxes
06:01:19 <dramforever> rm -rf ~/.ghc
06:01:25 <byorgey> yuu-chan: you can easily next do-syntax, e.g. like this:  do { x <- arbitrary; return $ do { generate some HTML here using x } }
06:01:33 <byorgey> *nest
06:01:35 <dramforever> that removes everything
06:01:43 <sgflt> pacak, that's a map though. that gives me a type signature of heapSort :: [(Key, a)] -> [(Key, a)]
06:02:12 <arbelos> pacak: Ok, I suspect this problem happened after I forgot to use a sandbox when installing some stuff
06:02:26 <sgflt> pacak, nvm, wrong package. got it
06:02:41 <arbelos> Now, I'd like to clean everything and reinstall platform entirely
06:02:50 <arbelos> I am on debian btw
06:03:11 <indiagreen> Profpatsch: I think yep
06:03:26 <arbelos> but this doesn't seem to fix anything.. I have tried purging ~/.cabal and ~/.ghc as well
06:03:27 <indiagreen> hang on, I'll write an example for you
06:04:16 <pacak> arbelos: I tend to use separate instance of ghc for my projects. Distro bundled platform is usually ancient anyway...
06:04:20 <Profpatsch> indiagreen: Awesome.
06:04:40 <indiagreen> (I guess I should add such an example to my tutorial as well)
06:04:43 <shourya> What's happening? Profpatsch
06:04:47 <linduxed> can i paste a link to an event that's not mine but that i'm excited about?
06:04:47 <dramforever> reminds me of virthualenv
06:04:55 <linduxed> or is the channel against advertising of that kind?
06:05:25 <pacak> linduxed: Is word "haskell" mentioned anythere in that event title?
06:05:28 <shourya> indiagreen: You have a Haskell tutorial?
06:05:46 <pacak> linduxed: Or "functional programming"?
06:05:48 <shourya> indiagreen: If you do, link me to it.
06:05:49 <dramforever> Hi Abizern, we need to talk about this "filename incorrect" issue, although the rest of your commit message is correct
06:05:50 <dramforever> https://github.com/github/gitignore/commit/89c4f789c073b4cc49ab61f13d36b3406809a2e0
06:06:05 <dramforever> just joking, of course
06:06:07 <arbelos> pacak. build from sources?
06:06:07 <indiagreen> shourya: no, an Aeson tutorial (and it's supposed to be able to answer *any* question about Aeson, so it's not right that this particular question is left unanswered)
06:06:10 <linduxed> pacak: yes!@
06:06:12 <pacak> linduxed: Zygohistomorphic prepromorphisms maybe?
06:06:19 <pacak> linduxed: Then it's probably OK
06:06:23 <linduxed> http://curry-on.org/
06:06:24 <shourya> indiagreen: ah cool.
06:06:27 <dramforever> but turns out people Abizern assumed it's spelled wrong
06:06:31 <linduxed> looks really interesting!
06:06:42 <pacak> arbelos: Yep, but I do keep system ghc for stuff I don't want to break by accident - xmonad for example.
06:06:59 <yuu-chan> byorgey: thank you, seems that will do the task
06:07:24 <meditans> hi all, I have a question. Given that inductive and coinductive types as initial and terminal objects in the appropriate category, I'd like to know if/how lazy evaluation can blur the distinction. Is there any theoretical work done on this?
06:08:08 <yuu-chan> Also, what is the best way to generate arbitrary Int in some range? Currently I use elements [from .. to]
06:08:30 <arbelos> pacak: ok, I should probably do that. You are right about distro packages being ancient.
06:08:39 <pacak> yuu-chan: choice (from, to) ?
06:09:33 <byorgey> meditans: indeed it does, since in the presence of laziness, least and greatest fixed points coincide
06:09:38 <pacak> yuu-chan: There's something specific for enums bounded by something. Traversing whole list is not very efficient if you want random ints from 1 to 10^10000....
06:10:39 <yuu-chan> @hoogle choose
06:10:40 <lambdabot> Test.QuickCheck.Gen choose :: Random a => (a, a) -> Gen a
06:10:40 <lambdabot> Test.QuickCheck choose :: Random a => (a, a) -> Gen a
06:10:44 <meditans> byorgey: thanks, that's what I'm search for! Can you point me to a paper?
06:10:50 <pacak> Yep, that.
06:10:54 <byorgey> meditans: unfortunately I don't actually know of a good reference, it seems to be "folklore"
06:11:11 <byorgey> meditans: I found this link in my notes, maybe there is something useful buried in here: http://homepages.inf.ed.ac.uk/als/Teaching/MSfS/
06:11:18 <meditans> byorgey: the question could also be: how do one formalize the notion of laziness when talking about inductive types?
06:11:53 * dramforever is playing agar.io
06:12:14 <dramforever> It looks easy to make, maybe I'll make a clone in haskell
06:12:44 <byorgey> meditans: typically that is done via Scott domains
06:12:50 * hackagebot hspec-snap 0.3.3.0 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.3.0 (DanielPatterson)
06:13:08 <byorgey> meditans: just google "Scott domain" and you will find lots of stuff
06:13:46 <byorgey> meditans: you can also google "domain theory"
06:15:52 <indiagreen> Profpatsch: http://lpaste.net/133924
06:17:41 <orion> What does the '#' mean in GHC?
06:17:51 <orion> When reading the source code to, say, Prelude.
06:18:16 <Profpatsch> indiagreen: Ah, I can directly call the generic parser!
06:18:22 <dramforever> orion: like in Int# ?
06:18:28 <meditans> byorgey: thanks! Searching..
06:18:30 <Profpatsch> I didn’t know that. Or better, I read about it some time ago and forgot again.
06:18:40 <mspo> :t # ?
06:18:42 <lambdabot> lexical error at character '?'
06:18:55 <mspo> :t #
06:18:56 <lambdabot> <no location info>: not an expression: ‘#’
06:18:57 <pacak> orion: Magic hash
06:19:03 <dramforever> it's just a suffix to mark ghc internal functions
06:19:15 <pacak> orion: unboxed stuff, functions on unboxed stuff.
06:19:16 <orion> I see.
06:19:26 <dramforever> well, not only functions
06:19:53 <pacak> containiers with unboxed stuff
06:20:14 <pacak> > let (#) = (+1) in 1 # 2
06:20:15 <pacak> > let (#) = (+) in 1 # 2
06:20:18 <lambdabot>  <no location info>: can't find file: L.hs
06:20:18 <lambdabot>  <hint>:1:7: parse error on input ‘)’
06:20:50 <zennist> maybe a silly question: why is `forever`'s type m a -> m b
06:20:56 <zennist> what is `b` there
06:21:05 <pacak> lambdabot: WAT? Second version should work!
06:21:09 <dramforever> zennist: a type variable
06:21:13 <zennist> shouldn't it just be m a -> m ()
06:21:24 <dramforever> pacak: lambdabot ran into a race condition
06:21:31 <dramforever> zennist: IMHO it should
06:21:44 <pacak> zennist: You can't get `a` from there.
06:22:17 <dramforever> :t let dramforever x = let a = x >> a in a in dramforever
06:22:19 <lambdabot> Monad m => m a -> m b
06:22:27 <dramforever> lol name
06:22:44 <pacak> zennist: Nope. -> b means you can get anything from there
06:23:06 <dramforever> zennist: did you see the infered type above?
06:23:11 <zennist> well, it certainly is interesting how haskell arrived at such result just from type inference
06:23:34 <pacak> zennist: It's the same as "there's only one non-bottom version of a -> a"
06:23:44 <dramforever> zennist: in haskell type is a great deal
06:23:54 <zennist> pacak: how is that same/
06:24:05 <dramforever> pacak: ?
06:24:16 <dramforever> not very same, I think
06:24:49 <pacak> m a -> m b - this means it takes computation with result `a` and it should produce computation with result b. But since you don't know anything about be and how it can be created - this means there's only one non-crashing version of forever as well
06:25:26 <dramforever> pacak: actually the code forever does *look* diverging
06:25:31 <dramforever> @src forever
06:25:31 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:26:03 <pacak> dramforever: It is diverging, but for some monads (like IO ) it's useful. The point is that you can't get out.
06:26:10 <zennist> pacak: I found that a bit misleading; conceptually infinite loop is also considered a `bottom`, isn't it?
06:26:23 <zennist> pacak: so 'non-crashing' is a bit vague, that is
06:26:36 <dramforever> pacak: forever exitSuccess
06:26:38 <dramforever> diverging?
06:26:46 <pacak> zennist: Yes, that's why I said non-crashing... undefined :: m a -> m b fits bottom
06:30:38 <merijn> zennist: Infinite loops are bottom too, yes
06:30:58 <merijn> zennist: The point is that "a -> b" (and thus also "m a -> m b") can only be inhabitited by bottom
06:31:14 <breadmonster> merijn: How?
06:31:17 <merijn> Which is why an infinite loop like forever has that type, as it effectively produces bottom
06:31:20 <zennist> merijn: yep, that's one interpretation
06:31:54 <merijn> zennist: So it's not "it is an infinite loop because it has that type", but "it has that type because it's an infinite loop"
06:31:57 <merijn> breadmonster: How what?
06:32:14 <merijn> You get 2 minutes to refine your question before I have to leave for beer and sun :p
06:32:14 <zennist> I have another way of interpretting it which I myself find clearer: `forever` return a `m b` where b can unify with any type
06:32:31 <merijn> zennist: Right, but that's exactly the same thing :)
06:32:39 <dramforever> zennist: that's a good explaination
06:32:46 <merijn> zennist: The only value that inhabits every type is bottom :)
06:32:48 <pacak> :t absurd
06:32:50 <lambdabot> Not in scope: ‘absurd’
06:32:51 * hackagebot postgresql-simple-url 0.1.0.0 - PostgreSQL  http://hackage.haskell.org/package/postgresql-simple-url-0.1.0.0 (phadej)
06:32:53 <pacak> :(
06:32:54 <breadmonster> merijn: go have fun.
06:32:59 <dramforever> unfortunately I don't know how many understands "unify"
06:33:12 * dramforever is learning gloss
06:33:20 <breadmonster> dramforever: What does unify mean?
06:33:37 <breadmonster> merijn: You're going on vacation?
06:33:39 <dramforever> breadmonster: match
06:33:39 <breadmonster> End of term?
06:33:46 <breadmonster> dramforever: Oh right got it.
06:34:09 <dramforever> Couldn't match [[[[[Int]]]] With Socket
06:34:13 <dramforever> match = unify
06:34:18 <breadmonster> Is bottom artifically constructed, or is it a natural member of every type?
06:34:25 <dramforever> ouch, missed one ]
06:34:52 <dramforever> an artifically constructed inhabitant of every lifted type
06:35:03 <dramforever> by the definition of "lifted type "
06:35:05 <breadmonster> dramforever: So it unifies with every type by definition?
06:35:11 <dramforever> no
06:35:31 <dramforever> bottom is the value, a is the type
06:35:49 <breadmonster> Sorry, it inhabits every type by definition?
06:36:06 <breadmonster> Also, can someone tell me who Martin-Lof is?
06:36:34 <dramforever> breadmonster: yes, since almost every type you will ever deal with is lifted
06:37:10 <breadmonster> dramforever: lifted?
06:37:18 <dramforever> don't worry
06:37:42 <dramforever> it's something almost nobody will ever use
06:38:12 <pacak> dramforever: o_o nobody?
06:38:23 <dramforever> oh...
06:38:39 <breadmonster> that sounds a little strong?
06:38:44 <dramforever> breadmonster, pacak: don't worry you will know what it is if you ever need it
06:38:53 <dramforever> yeah that thing was too strong
06:39:48 <pacak> lifted means it can contain bottom.
06:39:54 <pacak> (_|_)
06:43:52 <ion> (_(_) (_|_) (_)_)
06:45:08 <pacak> ion: bottom with right and left adjunctions?
06:47:27 <ttk> I am looking into c2hs, but before spending too much time on it, is it possible to use with dynamic loaded libraries?
06:47:46 <ttk> and multiple loadings of the same dynamic library?
06:49:40 <augur> oh hey breadmonster!
06:50:17 <augur> breadmonster: Martin-Lof is the guy who sort of invented all of modern type theory
06:51:01 <augur> breadmonster: we never finished our chat about continuations the other day
06:51:50 <breadmonster> augur: Oh yeah, sorry.
06:51:56 <breadmonster> Bad internet, because of the rains.
06:52:03 <breadmonster> I was out of power for a couple of hours.
06:52:11 <augur> ouch
06:52:26 <augur> well, breadmonster, if you want to continue lemme know :)
06:52:39 <breadmonster> Sure, just gimme like fifteen?
06:52:45 <augur> yeah, whenever :)
06:52:54 <augur> im gonna review to see where we were
06:53:14 <augur> oh yeah we were talking about polymorphism first
06:57:52 * hackagebot uni-uDrawGraph 2.2.1.3 - Graphs binding  http://hackage.haskell.org/package/uni-uDrawGraph-2.2.1.3 (ChristianMaeder)
07:00:43 <saulzar_> ttk, c2hs just generates haskell bindings/imports so has the same restrictions (or otherwise) as normal FFI. I believe ghc can happily link with dlls/so's 
07:01:00 <sniop> in emacs is there a way to get argument hints for all the haskell functions when I type their names, and not just the Prelude ones?
07:01:26 <geekosaur> I think you need to point to a local Hoogle database
07:03:06 <sniop> geekosaur: I see. but then it wont work with functions I just defined?
07:03:26 <geekosaur> yes, I don't think it can handle those at all
07:09:39 <kaidelong> is there a ghci setting to fully expand all type synonyms?
07:14:19 <Axman6> kaidelong: :kind! (with the !)
07:14:28 <Axman6> I think that's what you're after
07:14:39 <Axman6> maybe
07:26:39 <aloiscochard> dcoutts: hi, the stuff you presented at zurihac, is that already usable today in a lib?
07:27:15 <dcoutts> aloiscochard: not quite yet, but soonish, we've got a client paying to finish it up
07:27:37 <dcoutts> as they want to use it too
07:27:46 <aloiscochard> dcoutts: awesome! will it be a new library, or integrated into `binary`?
07:27:50 <breadmonster> \
07:27:53 * hackagebot tidal 0.4.33 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.33 (AlexMcLean)
07:28:00 <dcoutts> aloiscochard: initially a separate library, integration will come later
07:28:15 <breadmonster> dcoutts: what did you present at Zurihac?
07:28:39 <augur> breadmonster: ready? :)
07:28:51 <augur> when you are, ping me in -in-depth
07:28:59 <dcoutts> breadmonster: case study in Haskell optimisation, faster binary serialisation/deserialisation
07:29:02 <breadmonster> augur: Yup thanks for being so patient!
07:29:31 <aloiscochard> dcoutts: cool, thanks for the update. I'm looking forward the release :)
07:29:38 <dcoutts> aloiscochard: me too :-)
07:30:14 <dcoutts> aloiscochard: keep an eye out for a blog post, when it's ready
07:31:40 <aloiscochard> I will! cheers
07:34:31 <kaidelong> Axman6: parse error
07:47:54 * hackagebot yesod-table 0.1.0.0 - HTML tables for Yesod  http://hackage.haskell.org/package/yesod-table-0.1.0.0 (andrewthad)
08:11:39 <Kole> hi
08:13:20 <Kole> hello
08:13:38 <albeit> Is there a way to empty a (remove all elements from) a Control.Concurrent.Chan? 
08:16:17 <ion> My phone IRC client renders things like Control.Concurrent.Chan as links and sometimes i click on them without thinking, meaning to read the Haddocks, only to be disappointed while feeling stupid.
08:17:55 * hackagebot yesod-table 0.1.1 - HTML tables for Yesod  http://hackage.haskell.org/package/yesod-table-0.1.1 (andrewthad)
08:18:20 <Kole> has anyone used the haskell-neo4j-client?
08:26:24 <Kole> I am a newb at haskell I am wondering if this is the right place to ask random questions regarding haskell?
08:26:54 <breadmonster> Kole: Ask your heart out.
08:27:20 <Welkin> Kole: there is also #haskell-beginners for in-depth beginner help
08:27:56 * hackagebot amazonka-core 0.3.6 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.3.6 (BrendanHay)
08:27:58 * hackagebot amazonka 0.3.6 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.3.6 (BrendanHay)
08:28:00 * hackagebot amazonka-config 0.3.6 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.3.6 (BrendanHay)
08:28:02 * hackagebot amazonka-sns 0.3.6 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.3.6 (BrendanHay)
08:28:04 * hackagebot amazonka-sqs 0.3.6 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.3.6 (BrendanHay)
08:29:17 <Kole> ok that might be more suitable for me, but I will ask it anyway: I am trying to query a local neo4j database with haskell-neo4j-client... not much luck so far, all I have is that I have installed and loaded the package, but I simply cannot write any command that parses to actually query it (being a total newbie)
08:30:10 <breadmonster> Kole: sorry, out of my depth, but lemme have a look at the package.
08:30:17 <Welkin> Kole: https://hackage.haskell.org/package/haskell-neo4j-client-0.3.1.2/docs/Database-Neo4j.html
08:30:34 <Welkin> I'm not familiar with neo4j, but there are examples in the documentation
08:30:51 <Kole> yes but I immidiately get parse error if I try those
08:31:05 <Welkin> paste your code
08:31:11 <Welkin> @lpaste
08:31:11 <lambdabot> Haskell pastebin: http://lpaste.net/
08:31:31 <Welkin> along with the error
08:31:56 <Kole> http://lpaste.net/133927
08:31:56 <geekosaur> full error
08:32:01 <Kole> that is all I try
08:32:21 <geekosaur> you have to do something with what you got
08:32:52 <geekosaur> "x <- y" is converted to "y >>= \x ->"
08:33:00 <geekosaur> there has to be something after it
08:33:06 * hackagebot amazonka-glacier 0.3.6 - Amazon Glacier SDK.  http://hackage.haskell.org/package/amazonka-glacier-0.3.6 (BrendanHay)
08:33:07 <geekosaur> that presumably uses x
08:33:08 * hackagebot amazonka-cloudhsm 0.3.6 - Amazon CloudHSM SDK.  http://hackage.haskell.org/package/amazonka-cloudhsm-0.3.6 (BrendanHay)
08:33:10 * hackagebot amazonka-iam 0.3.6 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.3.6 (BrendanHay)
08:33:12 * hackagebot amazonka-route53-domains 0.3.6 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.3.6 (BrendanHay)
08:33:14 <geekosaur> (or, in this specific case, r)
08:33:14 * hackagebot amazonka-directconnect 0.3.6 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.3.6 (BrendanHay)
08:33:23 <Kole> hm, ok
08:34:05 <geekosaur> if you're just after the action performed and not the result, leave off the "r <-" or use "void" to consume the result
08:34:18 <Kole> ok I will try that, thanks
08:34:26 <geekosaur> although it's good stye to check the result for error
08:34:28 <geekosaur> *style
08:38:16 * hackagebot amazonka-cognito-sync 0.3.6 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.3.6 (BrendanHay)
08:38:18 * hackagebot amazonka-elb 0.3.6 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.3.6 (BrendanHay)
08:38:20 * hackagebot amazonka-cloudformation 0.3.6 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.3.6 (BrendanHay)
08:38:22 * hackagebot amazonka-sts 0.3.6 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.3.6 (BrendanHay)
08:38:24 * hackagebot amazonka-kinesis 0.3.6 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.3.6 (BrendanHay)
08:43:26 * hackagebot amazonka-cloudwatch 0.3.6 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.3.6 (BrendanHay)
08:43:28 * hackagebot amazonka-cloudtrail 0.3.6 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.3.6 (BrendanHay)
08:43:30 * hackagebot amazonka-elasticache 0.3.6 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.3.6 (BrendanHay)
08:43:32 * hackagebot amazonka-importexport 0.3.6 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.3.6 (BrendanHay)
08:43:34 * hackagebot amazonka-s3 0.3.6 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.3.6 (BrendanHay)
08:47:28 <dale> chaps, is there a facility for grouping modules together into a "super module". Importing said super module would actually import all of its module constituents
08:47:50 <dale> couldn't find anything on the goog
08:48:36 * hackagebot amazonka-swf 0.3.6 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.3.6 (BrendanHay)
08:48:38 * hackagebot amazonka-sdb 0.3.6 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.3.6 (BrendanHay)
08:48:40 * hackagebot amazonka-autoscaling 0.3.6 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.3.6 (BrendanHay)
08:48:42 * hackagebot amazonka-codedeploy 0.3.6 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.3.6 (BrendanHay)
08:48:43 <indiagreen> dale: you just write “module X (module A, module B, module C) where import A ...”
08:48:44 * hackagebot amazonka-cloudfront 0.3.6 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.3.6 (BrendanHay)
08:49:00 <dale> indiagreen, fantastic! thanks a bunch
08:50:06 <fractalsea> When would I use Map/Set over HashMap/HashSet and vice versa? It’s not clear from the docs the different pros cons
08:51:00 <indiagreen> I think Hash* are just faster
08:53:27 <Welkin> not always
08:53:34 <Welkin> in many cases, Map/Set are fine
08:53:46 * hackagebot amazonka-cloudsearch-domains 0.3.6 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.3.6 (BrendanHay)
08:53:48 * hackagebot amazonka-elasticbeanstalk 0.3.6 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.3.6 (BrendanHay)
08:53:50 * hackagebot amazonka-datapipeline 0.3.6 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.3.6 (BrendanHay)
08:53:52 * hackagebot amazonka-support 0.3.6 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.3.6 (BrendanHay)
08:53:54 * hackagebot amazonka-redshift 0.3.6 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.3.6 (BrendanHay)
08:55:10 <thebnq> Map is also more lenient on what can be your key
08:55:31 <gremble> it gets real quiet over here on a friday night. That or hackagebot went on a rampage
08:55:31 <indiagreen> and HashMap has less complete API
08:55:41 <fractalsea> I see; hash* should be faster in general, but is more restrictive on keys]
08:55:48 <fractalsea> I see
08:56:20 <fractalsea> So general rule: go with hash* unless the api is too limiting for the use case
08:56:45 <indiagreen> gremble: nah, it happens every time amazonka's 50 packages are bumped
08:56:54 <indiagreen> https://github.com/brendanhay/amazonka
08:57:00 <indiagreen> look at this mighty repository
08:57:40 <gremble> Oh my
08:58:56 * hackagebot amazonka-opsworks 0.3.6 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.3.6 (BrendanHay)
08:58:58 * hackagebot amazonka-emr 0.3.6 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.3.6 (BrendanHay)
08:59:00 <meoblast001> hi.. i'm trying to install caball-install but i just get this error: https://gist.github.com/meoblast001/60fbfc34d1a85920d1bf
08:59:00 * hackagebot amazonka-cognito-identity 0.3.6 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.3.6 (BrendanHay)
08:59:02 * hackagebot amazonka-ssm 0.3.6 - Amazon Simple Systems Management Service SDK.  http://hackage.haskell.org/package/amazonka-ssm-0.3.6 (BrendanHay)
08:59:05 * hackagebot amazonka-ml 0.3.6 - Amazon Machine Learning SDK.  http://hackage.haskell.org/package/amazonka-ml-0.3.6 (BrendanHay)
09:02:50 <subleq> threadWaitReadSTM :: Fd -> IO (STM (), IO ())
09:02:53 <subleq> now that's a bizarre type
09:04:01 <tomphreek> is there a trick to generate all possible sequences of coin tosses of length n using the list monad, similiar to filterM (const [True, False]) for a powerset
09:04:07 * hackagebot amazonka-workspaces 0.3.6 - Amazon WorkSpaces SDK.  http://hackage.haskell.org/package/amazonka-workspaces-0.3.6 (BrendanHay)
09:04:09 * hackagebot amazonka-dynamodb 0.3.6 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.3.6 (BrendanHay)
09:04:11 * hackagebot amazonka-rds 0.3.6 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.3.6 (BrendanHay)
09:04:13 * hackagebot amazonka-ses 0.3.6 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.3.6 (BrendanHay)
09:04:15 * hackagebot amazonka-cloudwatch-logs 0.3.6 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.3.6 (BrendanHay)
09:05:23 <f-a> I am getting a `Non type-variable argument` error while cabal installing lambdabot. Is there a way to tell cabal "use FlexibleContexts when compiling this"?
09:06:13 <srhb> f-a: The best way of altering a build is usually to cabal unpack lambdabot and then alter the source
09:06:20 <athan> f-a: Yes, with a `{-# LANGUAGE .. #-}` pragma
09:06:29 <srhb> f-a: After that you can just cabal install from the root of the project directory
09:07:14 <f-a> mhhh first time I hear about cabal unpack, thanks pals
09:07:23 <indiagreen> > replicateM 4 ['H', 'T'] -- tomphreek 
09:07:26 <lambdabot>  ["HHHH","HHHT","HHTH","HHTT","HTHH","HTHT","HTTH","HTTT","THHH","THHT","THTH...
09:07:32 <breadmonster> athan: But you'll have to put that at every location where a function requires FlexibleContexts yeah?
09:07:48 <breadmonster> Also, what does FlexibleContexts even do?
09:08:02 <f-a> breadmonster: gets rid of that error
09:08:03 <srhb> f-a: There's also cabal fetch for just grabbing the source.
09:08:08 <f-a> (using ghc 7.10)
09:08:20 <srhb> breadmonster: Not necessarily, you can just specify it in the cabal file.
09:08:55 <athan> breadmonster: It's good stuff
09:09:05 <tomphreek> indiagreen
09:09:06 <athan> you can do things like `MonadReader Int m => m ()`
09:09:11 <tomphreek> indiagreen: awesome
09:09:15 <breadmonster> athan: Sure, but what does it do?
09:09:17 * hackagebot amazonka-route53 0.3.6 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.3.6 (BrendanHay)
09:09:19 * hackagebot amazonka-cloudsearch 0.3.6 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.3.6 (BrendanHay)
09:09:21 * hackagebot amazonka-storagegateway 0.3.6 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.3.6 (BrendanHay)
09:09:23 * hackagebot amazonka-ec2 0.3.6 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.3.6 (BrendanHay)
09:09:25 * hackagebot amazonka-kms 0.3.6 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.3.6 (BrendanHay)
09:09:27 <athan> breadmonster: Allow different styles of contexts
09:09:41 <athan> breadmonster: Instead of /just/ 1-ary typeclasses
09:09:46 <athan> you can be more specific with your context
09:10:03 <athan> it's more "flexible" in how GHC rigours the rules
09:10:07 <breadmonster> Why does Haskell only allow one parameter in typeclasses?
09:10:17 <athan> breadmonster: -XMultiParamTypeClasses
09:10:19 <athan> that fixes it
09:10:27 <breadmonster> athan: That's GHC, not Haskell.
09:10:37 <athan> whatevs lol
09:11:02 <athan> breadmonster: I think it's to simplify instance lookup dictionaries
09:11:08 <breadmonster> No, I'm wondering if implementing multiparameter typeclasses is different from single parameter typeclasses.
09:11:32 <athan> I think it is
09:11:34 <bitemyapp> breadmonster: implementing as in, writing one, or as in, writing a compiler that supports them?
09:11:43 <breadmonster> bitemyapp: The latter.
09:11:53 <breadmonster> Using them is a bunch of ASCII characters more.
09:12:07 <athan> breadmonster: If you have one argument, then the instance tables are 1-to-1
09:12:16 <breadmonster> athan: That is?
09:12:16 <bitemyapp> breadmonster: well, the thing about typeclasses is that the more stuff we make them able to do, the closer it gets to being a ramshackle prolog interpreter at compile time
09:12:20 <athan> if you have multiple arguments, you have to make sure lookups are unique somehow
09:12:31 <breadmonster> athan: Can you instantiate?
09:12:36 <athan> @hackage constraints -- breadmonster
09:12:36 <lambdabot> http://hackage.haskell.org/package/constraints -- breadmonster
09:12:37 <breadmonster> that argument is too abstract XD
09:12:51 <breadmonster> bitemyapp: Is that necessarily a bad thing?
09:12:52 <athan> read up on it
09:13:17 <athan> bitemyapp: muahahahah
09:14:27 * hackagebot amazonka-elastictranscoder 0.3.6 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.3.6 (BrendanHay)
09:14:29 * hackagebot amazonka-lambda 0.3.6 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.3.6 (BrendanHay)
09:14:31 * hackagebot amazonka-ecs 0.3.6 - Amazon EC2 Container Service SDK.  http://hackage.haskell.org/package/amazonka-ecs-0.3.6 (BrendanHay)
09:16:32 <indiagreen> breadmonster: as a data point, consider that JHC claims to implement type families, which are a (relatively) recent addition to Haskell, but at the same time it doesn't implement MPTC and I think its author said that adding them wouldn't be easy
09:17:17 <c_wraith> type families are a lot simpler in a bunch of ways
09:17:25 <breadmonster> indiagreen: MPTC?
09:17:27 <breadmonster> Oh right.
09:17:35 <c_wraith> They let you avoid implementing most of prolog in your type resolution algorithms. :)
09:18:02 <athan> When writing a type checker or type inference algorithm, what are some techniques to make the machinary generic?
09:18:30 <c_wraith> read papers by SPJ. :)
09:18:42 <c_wraith> That's the #1 technique for ghc-like type checking and inference!
09:18:57 <athan> I was thinking about just making Literals parametric, but I'm not sure
09:19:14 <athan> c_wraith: Hahaha
09:19:23 <athan> I'm implementing the bottom-up technique right now, but...
09:19:28 <athan> no genericism :(
09:19:47 <bitemyapp> breadmonster: I expressed no value judgment
09:23:15 <KaneTW> :i Map
09:23:18 <KaneTW> oh, right
09:27:25 <dolio> I don't really see why MPTCs would be very difficult for JHC. Fundeps might be, though. And most people would consider MPTCs useless without either fundeps or type families.
09:36:25 <dolio> Or rather, I could see not wanting to implement fundeps in a way that matches the way GHC implements fundeps.
09:36:33 <athan> dolio: What are your favorite features of the competing compilers?
09:36:57 <Welkin> athan: what is your opinion on lobsters?
09:37:08 <dolio> UHC has first-class existential quantifiers. That's cool.
09:37:12 <athan> Welkin: They peeench :B
09:37:22 <athan> dolio: That does sound really cool
09:37:52 <dolio> JHC implements type classes completely differently from the usual way, which is also cool.
09:38:06 <mizu_no_oto> dolio: how does it do it?
09:38:08 <dolio> And as a side effect it kind of has a type-safe Typeable/Dynamic, or could.
09:38:09 <athan> dolio: Thank you :) I'll dig into them
09:38:24 <athan> hmm!
09:38:26 <dolio> mizu_no_oto: It passes types around at runtime when necessary and does case analysis on them.
09:38:36 <mizu_no_oto> ah
09:38:43 <dolio> Or, you could imagine that it generates a GADT indexed by all types, and passes that when necessary.
09:39:02 <dolio> So, instead of passing dictionaries, it passes a means of looking up dictionaries.
09:39:23 <mizu_no_oto> makes sense
09:39:28 <f-a> omhhh so I compiled lambdabot and had him join a network... but how to make him join a channel?
09:39:33 <f-a> (or her. or it)
09:39:33 <dolio> Or compiles class methods into functions that do case analysis on a Type type.
09:40:00 <mizu_no_oto> You and Ed are doing standard dictionary passing in Ermine, right?
09:40:05 <dolio> Yeah.
09:40:47 <mizu_no_oto> Are you just doing standard typeclasses, or any of the extensions?
09:41:08 <f-a> found out thanks (@join server:chan)
09:41:08 <dolio> We have MPTCs. But no fundeps or families.
09:41:25 <mizu_no_oto> nice
09:41:37 <dolio> So we'll cover the couple use cases where those are actually worth anything. :)
09:42:11 <dolio> Anyhow, plain MPTCs in JHC would just be passing 2+ arguments, I would think.
09:42:50 <dolio> Although maybe it'd have to do weird stuff with non-linear uses of stuff.
09:43:12 <dolio> Like if someone wrote 'instance C a a where ...'
09:46:25 <athan> There isn't a way to make generic instances or ad-hoc definitions for different data constructors, is there? Like type aliases, but for data constructors?
09:46:39 <athan> That way I could overload some pattern matching?
09:47:45 <lyxia> Different definitions for different data constructors, isn't that pattern matching?
09:49:11 <athan> lyxia: But how could I overload a function for different data types?
09:49:24 <athan> Or, embed the behavior of a function in a typeclass instance?
09:50:15 <lyxia> I don't understand.
09:51:07 <lyxia> Oh I think I do.
09:51:20 <lyxia> Sounds like generic programming.
09:52:06 <athan> lyxia: That's what I was thinking, but I don't think the behavior should have it's only abstract nature depend on sums-of-products
09:53:10 <athan> lyxia: I was thinking something like `class Foo a where; Term1 :: a; Term2 :: a; foo :: a -> a; {- default instance -} foo Term1 = Bar; foo Term2 = Baz`
09:53:52 <athan> That way you could create default behavior with this associated-data-constructor style instance
09:56:01 <lyxia> Wrap that as data Foo = Term1 | Term2, and any other type that's supposed to be an "instance" just builds on top of Foo. data SubFoo = SubFoo Foo | Ext1 | Ext2 ...
09:56:25 <lyxia> Is that too costly for your needs?
09:58:07 <f-a> how to make lambdabot less chatty? He keeps tossing sassy answers at every irc lines (not only the one addressed to him)
10:00:03 <ronh-> f-a channel? :)
10:00:25 <ronh-> (and I have no idea)
10:00:38 <f-a> on another server ronh- , but I can load him here on freenode too
10:01:19 <dolio> Do you put a lot of @, ? or > in your normal IRC chatter?
10:01:30 <dolio> At the beginning of the line.
10:02:02 <Myrl-chan> dolio: @ ?, > are bot commands.
10:02:36 <dolio> Exactly.
10:02:57 <dolio> Also some :.
10:02:58 <athan> lyxia: Well, maybe. I'm not sure. My use case is for type inference / checking algorithm /libraries/, that want to be generic over the term constructors
10:03:22 <f-a> ronh-: dolio Myrl-chan check channel #lambdab
10:03:58 <f-a> (as in, join it, there is my instance of lambdabot)
10:07:56 <athan> lyxia: I'm not sure if you can elaborate more, but I made a reddit post: http://www.reddit.com/r/haskell/comments/38owdh/question_would_an_associated_data_constructor_be/
10:10:23 <f-a> (to all lambdabotters here: it was "vixen-off")
10:33:03 * hackagebot postgresql-simple-url 0.1.0.1 - PostgreSQL  http://hackage.haskell.org/package/postgresql-simple-url-0.1.0.1 (phadej)
10:33:05 * hackagebot generic-accessors 0.3.0 - stringly-named getters for generic data  http://hackage.haskell.org/package/generic-accessors-0.3.0 (GregHorn)
10:39:20 <athan> Hey guys, in HM type inference, is `generalize` restricted to taking the context as an argument? In the paper I'm reading, it's taking a set of monomorphic types as an argument instead
10:41:20 <zed_> hi everyone : ) so I would like to generate a number drawn from a uniform, but I only know how to do this using IO and Monads.... and was told that it wasn't the best way to code in Haskell. Does anyone know of a good way to do this ? thanks !
10:42:23 <athan> zed_: A uniform?
10:42:24 <srhb> zed_: Uhh.
10:42:33 <srhb> zed_: You can't get (pseudo)random without using IO.
10:42:35 <josephle> athan: uniform distribution I believe
10:42:37 <srhb> You need a random seed, after all
10:42:39 <athan> oop
10:42:57 <dolio> You could seed deterministically.
10:43:01 <athan> unsafePerformIO! 
10:43:07 <dgpratt> wow
10:43:08 <athan> just kidding don't listen to me
10:43:38 <dgpratt> so it turns out my sandboxed build issue was ultimately caused by temp file paths that were too long
10:43:43 <srhb> zed_: I'm fairly sure the advice given to you was wrong. Unless you're fine with using the same seed every time.
10:43:51 <srhb> dgpratt: o_o
10:43:54 <zed_> wouldn't I be able to pick something from Data.Random.Distribution.Uniform ?
10:44:04 <dgpratt> I wonder if there is any practical mitigation of that
10:44:26 <dolio> dgpratt: Is this on windows?
10:44:29 <srhb> zed_: Sure, but that doesn't change the core issue.
10:44:38 <dgpratt> dolio, how'd you guess? :)
10:44:45 <dolio> :)
10:44:48 <srhb> zed_: If you're fine using a non-random seed, then you can avoid using IO. If you want a random seed, you need IO.
10:45:03 <srhb> zed_: It's not a problem "fixed" by changing library, it's a fundamental safety precaution in Haskell.
10:45:36 --- mode: ChanServ set +o dolio
10:45:40 <zed_> srhb: I guess there is something I have yet to understand about Haskell then.
10:46:07 <srhb> zed_: Would you expect a value random :: Int -- to be able to give you different results each time you use it?
10:46:19 <srhb> zed_: That's what you're fundamentally asking about.
10:46:41 <lyxia> athan: What I'm most bothered with is that your default instance is certainly going to be partial...
10:46:46 <zed_> I think I understand
10:47:09 <srhb> zed_: Whereas random :: IO Int -- is an IO action that can do all sorts of funny side effecty things like grabbing the system random generation
10:47:21 <athan> lyxia: I am slightly bothered by this, too, but this is Haskell after all, and not Coq :)
10:47:29 --- mode: dolio set +b *!~dameloo@*
10:47:34 --- kick: dameloo was kicked by dolio (dameloo)
10:47:44 <dgpratt> is cabal-install just a thin wrapper around the Cabal lib?
10:47:51 <ronh-> srhb random :: Seed -> Int
10:48:01 <srhb> ronh-: Which is fine and pure.
10:48:05 <ronh-> srhb random :: Seed -> (Int, Seed), even
10:48:11 <athan> dgpratt: I think moreso it's a way to install packages conforming to the Cabal spec
10:48:16 <srhb> ronh-: I know how it works, but that's not the issue here. :)
10:48:21 <athan> with other tooling and utilities
10:48:33 <lyxia> athan: Let's see what you can do with more rudimentary constructs first.
10:48:41 <hamid> Hey guys! Question: Why are there *.lhs files in haskell? and what use do they have? :/
10:48:45 <zed_> srhb: thanks for the explanation : )
10:48:48 <ronh-> why not? he raised concerns about minimizing the use of IO
10:49:06 <ronh-> only the initial seed requires IO
10:49:07 <athan> lyxia: You mean the type wrappers you were referencing earlier?
10:49:08 --- mode: dolio set -o dolio
10:49:13 <srhb> ronh-: In that case feel free to direct it there, same-seed pure pseudorandom was already raised :)
10:49:17 <lyxia> athan: That or something else.
10:49:25 <athan> :s
10:49:26 <lyxia> athan: You want to reuse the implementation of foo for the provided constructors
10:49:56 <breadmonster> hamid: Well, they're literate haskell files.
10:50:12 <lyxia> athan: So, my first idea was to define a type Foo and extend it in other datatypes.
10:50:54 <hamid> breadmonster, look at this repository https://github.com/JakeWheat/simple-sql-parser for example! where are the actual source codes?
10:51:26 <breadmonster> hamid: Okay, so basically any line that starts with a "> " is code
10:51:44 <hamid> breadmonster, i get that but how does that work?
10:51:50 <breadmonster> hamid: anything in between "\begin{code}" and "\end{code}" is also code.
10:52:17 <breadmonster> I'm not sure, but I guess there's a preprocessor that just strips away the bits that aren't marked that way.
10:52:20 <dgpratt> thanks athan, I guess I' wondering where I'd be likely to find code that interacts with other utilities like gcc, ld, etc.
10:52:24 <breadmonster> And then the rest is compiled like normal haskell.
10:52:29 <dgpratt> I guess there's one way to find out
10:52:32 <hamid> yeah breadmonster i was thinking of that
10:52:46 <hamid> that's weird!
10:53:03 <breadmonster> hamid: Why?
10:53:48 <athan> dgpratt: Ahh okay, I think you're on the right track, but this is out of my league
10:53:55 <hamid> breadmonster, i expected to see comments in {- -} and codes as usual but this exactly reversed here :D
10:54:15 <breadmonster> Yup, it was invented by Donald Knuth.
10:54:31 <breadmonster> The idea is that you write a latex file and pass it through pdflatex.
10:54:39 <hamid> ow!
10:54:42 <int-e> breadmonster: OUCH
10:54:58 <breadmonster> hamid: And that also serves as code.
10:55:02 <breadmonster> So you get nice documentation.
10:55:09 <breadmonster> int-e: It doesn't work like that in practice :P
10:55:19 <hamid> breadmonster, +1 so put pressure on coder :D
10:55:25 <int-e> breadmonster: I meant something else... Knuth uses plain TeX.
10:55:50 <breadmonster> int-e: Oh yeah that stuff is nasty.
10:59:38 <lyxia> athan: http://lpaste.net/133940
11:01:17 <athan> lyxia: The instance isn't correct, did you mean `instance Fooable Bar`? But I see where you are going with this, thank you
11:01:35 <lyxia> You're right.
11:02:30 <athan> Thanks lyxia :)
11:02:47 <lyxia> athan: Bar should also be a newtype actually.
11:03:35 <lyxia> athan: Oh no I got confused, it's Fooable Bool.
11:04:19 <athan> :x
11:04:59 <lyxia> athan: which means there's no need for a newtype here!
11:05:19 <athan> hmm!!
11:18:05 * hackagebot generic-accessors 0.4.0 - stringly-named getters for generic data  http://hackage.haskell.org/package/generic-accessors-0.4.0 (GregHorn)
11:28:11 <zed_> hi again - so I wrote some code and I am getting a parse error that I cannot quite grasp... would someone be kind and look at it ? http://lpaste.net/133944
11:29:08 <byorgey> zed_: you need to indent indexVarR and VaR so they line up under  xs_sorted
11:29:35 <merijn> I would recommend reading the wikibook on indentation to see exactly how you should indent
11:29:36 <byorgey> also the return  needs to be lined up under  xs <- replicateM ...
11:29:43 <albeit> > (fmap . fmap) (+1) [[1,2,3],[5]] :: [[Int]]
11:29:45 <lambdabot>  [[2,3,4],[6]]
11:29:55 <merijn> It's pretty simple: https://en.wikibooks.org/wiki/Haskell/Indentation
11:30:04 <geekosaur> also that VaR won't fly
11:30:10 <arkeet> zed_: get rid of tabs
11:30:17 <geekosaur> initial uppercase means it's a constructor
11:30:53 <geekosaur> which in the context of a let means it's a pattern match, but there's no such constructor
11:30:54 <arkeet> yes, variable names must start with a lowercase letter
11:31:31 <zed_> tabs was the thing. thanks everyone
11:36:29 <merijn> zed_: I would still recommend that indentation link, because it's useful to know the exact way it works :)
11:36:49 <zed_> merijn: I am reading it - thanks ! :)
11:54:48 <bananagram> what happened there?
11:59:38 <bitemyapp> bananagram: bloodbath
12:00:03 <bitemyapp> bananagram: more useful answer: if you look at the hosts, they're all irccloud users. Somebody had downtime ;)
12:01:50 <bananagram> indeed
12:07:23 * quchen votes for "warn on tab" as best 7.10 feature :-s
12:14:35 <hexagoxel> dgpratt: afaik cabal-install adds at least the dependency-resolution (!) and the downloading/caching functionalities
12:27:16 <tmtwd> [x * 2| x<-[0..] , x <= 10]
12:27:24 <tmtwd> how come this never finishes executing?
12:28:22 <tremon> because ghc doesn't know that [0..] is ordered
12:29:01 <tmtwd> [2,4,6,8,10,12,14,16,18,20 
12:29:14 <tmtwd> it gives that so it knows the direction I wanted
12:29:41 <ReinH> tmtwd: yes, but it doesn't know that there won't be any numbers less than 10
12:29:49 <ReinH> it doesn't "know" anything
12:29:54 <ReinH> it just constructe the list you told it to construct
12:30:08 <ReinH> it doesn't "know" anything about the contents of the list
12:30:34 <ReinH> it's just a list, a list that might eventually have another number <= 10 in it
12:30:45 <tmtwd> oh, I see
12:31:07 <ReinH> take 1000000 [0..] ++ [1]
12:31:14 <tmtwd> it keeps evaluating looking for another number that is less than or equal to 10?
12:31:25 <c_wraith> yep
12:31:39 <c_wraith> > [maxBound - 1 ..] :: [Int]
12:31:42 <lambdabot>  [9223372036854775806,9223372036854775807]
12:32:29 <ReinH> by the time the predicate is evaluated, there's no "memory" of how the list was constructed
12:34:21 <ReinH> I could even write a (broken) Num, Enum and Comparable instance that, e.g., represented a mod space and therefore *did* eventually cycle back to numbers <= 10
12:35:01 <albeit> If a long-running program every only uses a maximum of about 20MB of heap, does it follow that setting "+RTS -H" to 500 is equivalent to 30?
12:35:22 <albeit> *500M or 30M
12:46:07 <dreams> albeit: according to the docs -H is a "suggested heap size" for the GC; does not put limit on heap size.
12:47:56 <albeit> dreams: But it puts a lower limit on it, correct?
12:48:21 <dreams> albeit: seems so. Are you having space issues?
12:50:43 <albeit> No... trying to find some optimal values, because I need to call the GC explicitly to prevent it from running at bad times... so how long I can run before running GC depends on those values
12:52:32 <dreams> albeit: what are bad times for the GC here?
12:56:00 <quchen> tmtwd: for(i = 0;; ++i) { if(i <= 10) list.append(i*2); } -- that's roughly the imperative equivalent to your list comprehension
13:04:09 <albeit> dreams: It's for a trading system... so if an event happens and we want to send out orders, GCing right before the orders are sent out would be very bad
13:06:57 <dreams> albeit: that sounds nasty, why not solve the real problem and reduce the heap peak?
13:08:22 <albeit> dreams: Well I've done a bit of that, but can definitely work on it some more. But my understanding is that regardless of what I do, I'm going to be genereating quite a bit of garbage that will have to collected at some point
13:10:20 <albeit> dreams: Do you have specific strategies / thing to be aware of to reduce heap usage?
13:12:38 <Cydo> hi! i'm a newcomer to haskell and I was wondering, is there any way I can suppress output for an IO function that I don't control (in a library ?)
13:12:59 <mpickering> like output to stderr?
13:13:02 <dreams> albeit: yes. If you want by example, I can show on your program. (no need to show source code, only certain heap profiles).
13:13:33 <}> Are there things that are monoids but aren't functors?
13:13:34 <Cydo> mpickering, I think it is on stdout
13:14:49 <mpickering> @hackage silently
13:14:49 <lambdabot> http://hackage.haskell.org/package/silently
13:15:14 <Cydo> thanks a lot!
13:17:27 <albeit> dreams: I may take you up on that! What heap profiles would you want to see? And the .hp file itself or the graph?
13:18:09 <dreams> albeit: a graph of -hb
13:19:16 <albeit> dreams: Recompiling with profiling, I'll try and get that runnning!
13:19:31 <albeit> On a side note, when is it advantageous to use a three generation or single generation GC?
13:19:55 <jarrow5> Time is running out as seen on Twitter, 12 months hosting for £4.99 expiring tonight!
13:20:52 --- mode: ChanServ set +o geekosaur
13:20:56 <hexagoxel> }: the two do not even have the same kind
13:21:03 <geekosaur> oh already gone
13:21:06 --- mode: geekosaur set -o geekosaur
13:21:40 <quchen> }: There is not one thing that's a Monoid and also a Functor.
13:22:27 <c_wraith> However, you can see the Alternative class as more or less higher-kinded monoids, with some additional laws about interaction with Applicative
13:23:02 <}> huh? lists are monoids and functors
13:23:14 <c_wraith> [] is a Functor.  [a] is a Monoid
13:23:16 <quchen> c_wraith: Alternative doesn't come with laws other than being monoid-ish, does it?
13:23:19 <c_wraith> the difference is important.
13:23:28 <moghedrin> ^
13:25:23 <c_wraith> quchen: It looks like you are correct.  Alternative doesn't impose more laws than being a monoid.
13:25:28 <ReinH> }: What they're not pointing out is that Functor and Monoid have different kind requirements
13:25:40 <c_wraith> ReinH: hexagoxel pointed that out!
13:25:45 <ReinH> Oh. Woops.
13:25:50 <ReinH> hexagoxel: my deepest apologies
13:26:05 <}> ReinH, I understand all of this, that the list constructor is a functor and [a] is a monoid, I just don't know how to ask the question properly because I don't know the proper semantics
13:27:10 <benzrf> }: every type with at least one element and decidable equality can be a monoid
13:27:23 <ReinH> [] is a Functor, [a] is a Monoid for all a
13:27:33 <ReinH> benzrf: possibly true, definitely not relevant
13:27:40 <benzrf> :I
13:27:52 <c_wraith> benzrf: Equality doesn't need to be computable though!
13:28:03 <benzrf> c_wraith: it does if you want a Monoid
13:28:10 <ReinH> }: I think you're trying to ask: does "f is a Functor" imply "f a is a Monoid for all a"
13:28:17 <}> ReinH, yeah
13:28:19 <c_wraith> benzrf: nah.  Sum CReal is a valid Monoid
13:28:22 <}> ReinH, exactly that
13:28:38 <benzrf> c_wraith: i said if, not iff
13:28:47 <}> ReinH, actually the other way around, does f a is a monoid, imply that f is a functor for all a
13:28:49 <benzrf> well i didnt say if, but
13:29:00 <haasn> }: take f = Identity
13:29:05 <haasn> and ‘a’ as anything that isn't a Monoid
13:29:35 <benzrf> oh, actually.
13:29:40 <ReinH> }: Going one way, IO a isn't a monoid. Maybe a is only a Monoid if a is a Monoid (this is over-specified, though)
13:29:42 <benzrf> types with 0 elements are easily Monoids too
13:29:55 <benzrf> er... if they're provably 0-element
13:29:57 * benzrf shuts up
13:30:14 <ReinH> benzrf: A type with no elements can't have an identity element
13:30:20 <ReinH> since it would necessarily have to have an element
13:30:22 <benzrf> er, wait. right.
13:30:25 * benzrf facepalms
13:30:30 <linkages> got a good ide for haskell on linux?
13:30:34 <benzrf> i was thinking about how you could implement mempty by absurdity
13:30:37 <benzrf> :I
13:30:41 <ReinH> Void is a Monoid if you consider bottom to be an element though
13:30:52 <ReinH> But people don't really  like that one ;)
13:30:59 <c_wraith> benzrf: and equality being decidable is important, because otherwise associativity isn't well-defined.  But equality doesn't need to be computable! :)
13:31:06 <benzrf> wait, crap
13:31:12 <benzrf> did i mix up decidable and computable?
13:31:13 <nullvoid8> I thought bottom was always denied in this sort of discussion?
13:31:16 <benzrf> arent they the same thing?
13:31:28 <voidzero> lol
13:31:32 <ReinH> nullvoid8: Well, I'm explicitly introducing it in that case
13:31:34 <c_wraith> benzrf: I suppose technically they are.
13:31:43 <ReinH> But yes, we generally prefer to live in a bottomless world
13:31:45 <}> haasn, ok I think I understand now
13:31:47 <c_wraith> benzrf: But I was thinking "decidable" includes meta-theory
13:31:48 <ion> ReinH: *Everything* is a Monoid if you consider bottom to be an element.
13:31:50 * benzrf falls forever
13:31:55 <ReinH> ion: Um. No?
13:31:58 <benzrf> c_wraith: oh. idk
13:32:00 <voidzero> Hask is Set + bottom i thought
13:32:06 <voidzero> or read
13:32:09 <voidzero> somewhere
13:32:14 <voidzero> in an off the cuff remark
13:32:14 <benzrf> voidzero: i don't think so o.O
13:32:16 <ReinH> voidzero: Hask is definitely not Set-like
13:32:23 <benzrf> well...
13:32:31 <benzrf> ReinH: what exactly distinguishes it categorically
13:32:34 <ion> ReinH: Sorry, i made that conclusion too hastily and didn’t consider the other law.
13:32:50 <ReinH> Well, I am parroting what someone else said. Probably dolio or Cale could actually explain.
13:33:01 <ReinH> ion: :)
13:33:10 <int-e> benzrf: there are only countably many arrows, for example
13:33:19 <wgreenberg> hi, I've got some probably nebulous questions about a way of representing a function I'd like to implement
13:33:30 <benzrf> int-e: oh, true
13:34:12 <wgreenberg> basically, I'd like to implement a function that takes two arguments: some state (in the form of text) and a model that describes how states map to possible destination states. the function returns a random destination state
13:34:23 <benzrf> wgreenberg: "random"?
13:34:40 <wgreenberg> and I'd like to chain this function a bunch, sorta forming a random walk of a graph
13:34:56 <benzrf> wgreenberg: list and/or state monad
13:34:57 <wgreenberg> benzrf, well that's probably how I'd choose the random destination state
13:34:59 <voidzero> i read it here
13:35:01 <voidzero> http://bartoszmilewski.com/2014/12/05/categories-great-and-small/
13:35:22 <voidzero> "The former translates into equality of morphisms in the category Hask (or Set, if we ignore bottoms)."
13:35:33 <benzrf> wgreenberg: list moad, you mean?
13:35:38 <benzrf> *monad :I
13:36:13 <wgreenberg> benzrf, random. Like I'd implement a chooseRandomElem :: [a] -> IO a using randomRIO
13:36:47 <benzrf> hmm
13:36:48 <wgreenberg> where [a] is the list of possible destination states
13:37:15 <wgreenberg> I've got the barebones this all written, but I have no idea how  to compose calls of this function together
13:38:03 <wgreenberg> so I've got "getNext :: Word -> Model -> IO Word" where Model maps all Words with a list of possible Word results
13:38:42 <ReinH> voidzero: I think that's more a statement about = rather than about the relationship between Hask and Set
13:38:52 <ReinH> As in: Hask and Set are similar in some ways, including this one
13:38:52 <wgreenberg> and "do { f <- getNext "foo" myModel; g <- getNext f myModel; ... }" works, but I'd like to be able to keep chaining programatically
13:39:06 <benzrf> wgreenberg: flip the arguments
13:39:09 <ReinH> voidzero: Also, statements about equality in category theory are generally pretty hard to make, so...
13:39:13 <voidzero> ReinH that could well be. :)
13:39:16 <voidzero> yeah.
13:39:24 <benzrf> wgreenberg: getnext :: Model -> Word -> IO Word
13:39:41 <benzrf> wgreenberg: then you have "getNext myModel :: Word -> IO Word"
13:40:16 <wgreenberg> benzrf, good point! though in the end I'd like to concat all the Word results of getNext
13:40:18 <ion> ReinH: Although... instance Monoid a where { mempty = undefined; mappend a b = case teaspoon a <|> teaspoon b of ~(Just a) -> a }  -- assuming you consider all bottoms to be equivalent
13:40:19 <wgreenberg> and print em out
13:40:26 <benzrf> wgreenberg: you could add a Writer
13:40:39 <benzrf> wgreenberg: do you know your monad transformers
13:40:43 <wgreenberg> I don't
13:40:49 <benzrf> rip
13:40:52 <wgreenberg> heh
13:41:02 <ReinH> ion: but undefined is an absorbing element, not a neutral element
13:41:15 <ReinH> it's only a neutral element when it's the only element, e.g. in Void
13:41:48 <benzrf> what is teaspoon, ion
13:42:04 <ion> https://hackage.haskell.org/package/spoon-0.3.1/docs/Control-Spoon.html#v:teaspoon
13:42:08 <benzrf> wat
13:42:28 <benzrf> good lord
13:42:49 <ReinH> ion: what no stop
13:43:17 <voidzero> haha
13:43:33 <benzrf> jeezus
13:43:39 <bitemyapp> ion: smushing all that into Maybe is no bueno.
13:43:42 <voidzero> there is Just spoon!
13:43:48 * benzrf kicks voidzero
13:43:50 <bitemyapp> ion: you're losing a lot of information.
13:43:52 <voidzero> :D
13:44:02 <benzrf> wgreenberg: hmm, uh
13:44:09 <bitemyapp> I thought joke libraries were supposed to have acme- as a prefix.
13:44:15 <benzrf> ( ͡° ͜ʖ ͡°)
13:44:17 <ReinH> bitemyapp: not under the assumption that all bottoms are equivalent ;)
13:44:34 <benzrf> ReinH: /I/ certainly can't tell them apart
13:44:36 <ReinH> and are we actually trying to argue about the denotation of Control.Spoon? o_O
13:44:49 <bitemyapp> >assuming we assume something different than what you were talking about, what you said no longer holds
13:44:54 <quchen> Spoon has no ACME prefix because it's not a joke library.
13:44:55 <ReinH> Suggest that instead of doing that, we don't do that instead
13:45:26 <ReinH> bitemyapp: Different assumptions
13:45:37 * ReinH shrugs
13:45:39 <bitemyapp> ReinH: thank you for bzipping what I said.
13:46:11 <ReinH> bitemyapp: thanks for saying something entirely devoid of information, which made it easy
13:46:22 <benzrf> #rekt
13:46:41 <ReinH> Yes, we have different interpretations. Otherwise what would be the point of talking about it?
13:47:16 <benzrf> wgreenberg: really the obviously correct solution here is a WriterT over IO
13:47:42 <bitemyapp> ReinH: that was my original point
13:47:45 <quchen> Waitwaitwait. My unmaintainable Haskell article is not to be taken as good advice.
13:47:52 <bitemyapp> ReinH: what you said holds regardless of conversation topic.
13:49:01 <ReinH> I'm not sure about that. There's a world view where you are losing information and one where you are not. Regardless, the world I currently inhabit is one where this conversation isn't worth continuing anyway...
13:49:10 <Welkin> quchen: but... but... don't you want it posted to hacker news so they can uphold it as the word of the almighty God Paul Graham (blessed be his name)?
13:49:41 * prsteele finally realizes why ($) is important, and that reason has nothing to do with parens
13:49:46 <ReinH> bitemyapp: it's a silly thing that isn't worth being hostile about.
13:49:55 <Welkin> prsteele: zipWith
13:49:57 <Welkin> :)
13:50:14 <quchen> Hm, I mostly use ($) to avoid parentheses.
13:50:29 <quchen> Veeery rarely for sections.
13:50:50 <Welkin> I prefer composition where possible, $ where not, and sometimes a simple pair of parentheses will suffice
13:50:51 <ReinH> I almost never use ($) to avoid parens
13:50:55 <quchen> More importantly, I mostly use parentheses to avoid ($) :-D
13:51:05 <ReinH> Hah, yes.
13:51:11 <prsteele> Welkin: I was actually writing \x -> predicates <*> [x], rather that just \x -> map ($ x) predicates
13:51:33 <ion> map (`id` x) predicates
13:52:13 <ion> $ is different in precedence and specialization, mostly the difference that is relevant is the precedence.
13:52:20 <albeit> Why would I get a segmentation fault when biography profiling (-hb) but not with any other type of profiling?
13:52:34 <ion> [Insert obligatory rant about the wrong fixity of $]
13:54:53 <ReinH> ion: ($) also cheats with do notation
13:55:14 <ReinH> albeit: o_O
13:55:31 <ReinH> ion: also why is the fixity wrong?
13:55:33 <prsteele> ion: took me a minute to parse why (`id` x) was legal... is that a common use?
13:55:41 <ReinH> prsteele: no :)
13:55:44 <ion> ReinH: https://gist.github.com/ion1/e22e4ee869dae11a3acf
13:56:03 <ion> prsteele: No because ($) exists and is nicer for that.
13:56:07 * prsteele is relieved
13:56:08 <ReinH> ion: Ah. Right.
13:56:18 <ReinH> prsteele: its use is mainly in being clever and confusing people
13:56:55 <wgreenberg> benzrf, cool, i'll do some homework on that. ty
13:58:30 <ion> I wish the Haskell gods made foo do { bar } = foo (do { bar }), foo let bar in baz = foo (let bar in baz), foo case bar of baz = foo (case bar of baz) etc. Since they’re syntax errors at the moment, it wouldn’t break any preëxisting code.
13:59:07 <ion> Re: ($) being handled in a special manner with do blocks.
14:00:18 <prsteele> what's the compiler extension that allows type variables to be used in where clauses that match those in the outer function?
14:00:27 <quchen> FBUT on special ($): https://github.com/quchen/articles/blob/master/fbut.md#-has-special-powers
14:00:29 <ion> ScopedTypeVariables
14:00:35 <prsteele> ion: thanks
14:00:35 <quchen> RFC, haven't had it reviewed by anyone yet
14:01:06 <ocharles_> Can anyone see any easy wins for optimising https://gist.github.com/ocharles/ea74a5dc6fa821024d72 ?
14:01:11 <ocharles_> It's an attoparsec parser for wavefront obj files
14:01:26 <ocharles_> Currently parsing a 30mb file results in this heap profile: http://heap.ezyang.com/view/10ad15d8db64b1c644bead65ebf3a11172239c04
14:01:39 <ocharles_> That is way too much memory, imo - 10x the size of the file!
14:02:11 <albeit> ReinH: It seems that -hb doesn't work when -N is set to anything but 1... at least that's what breaking mine
14:02:23 <bitemyapp> ReinH: describing what I was trying to express and didn't get across doesn't register as hostile to me. Over-communicating maybe.
14:02:40 <ReinH> bitemyapp: I didn't mean you exclusively <3
14:02:46 <ReinH> and it's nothing
14:10:01 <ClaudiusMaximus> ocharles_: looks like Data.Sequence is lazy in its elements, and there is no Data.Sequence.Strict - maybe use a strict pair in objFaces and define a strict singleton?
14:11:14 <CurryWur_> hi guys!
14:11:33 <CurryWur_> i'd like to rewrite map using bind and return
14:11:42 <CurryWur_> http://lpaste.net/133952
14:12:07 <CurryWur_> what am i doing wrong?
14:15:02 <ocharles_> ClaudiusMaximus: Good idea. V3 itself is a triple that is strict in all elements, so I don't think I need to do anything about that
14:15:06 <Hijiri> CurryWur_: you have type errors. For instance, return [] is type [[c]] (for any c), but the result of the function should be [b]. You don't know that b is [c] (for some c), so you can't do that
14:15:14 <Hijiri> but you should be able to do this without pattern matching at all
14:15:18 <hexagoxel> ocharles_: the mappend in line 89 is not forced, so you build some big mappend chunk tree, maybe?
14:15:18 <ocharles_> I could use V2 instead of (V3,V3) for a face
14:15:49 <Hijiri> CurryWur_: Also in the future, you should post your errors along with the code
14:15:49 <ion> @type map
14:15:51 <lambdabot> (a -> b) -> [a] -> [b]
14:15:59 <ocharles_> equally plausable. I'm not sure how to even force that line by line though
14:16:05 <ion> @type (=<<) `asTypeIn` \f -> f undefined (undefined :: [a])
14:16:08 <lambdabot> (a -> [b]) -> [a] -> [b]
14:16:18 <ion> CurryWur: Hint
14:19:57 <albeit> means: The entire graph for -hb is USE, in some massive magnitude. And in the hp file both LAG and USE have ridiculously large numbers, roughly the same, magnitude of about 10^19. Something seems off
14:22:58 <albeit> Hmm it seems -hb doesn't like -T being set, numbers make more sense when I remove that
14:25:33 <ocharles_> Meh, no idea
14:25:38 <ocharles_> To StackOverflow!
14:27:10 <hexagoxel> ocharles_: commented on the gist
14:27:43 <hexagoxel> no promise on syntactic validity or semantic equality
14:27:45 <ocharles_> hexagoxel: thanks, thats almost identical to what i tried locally :)
14:28:04 <ocharles_> updated with my version
14:28:15 <ocharles_> It makes no difference sadly, and I think what we're suggesting is the same
14:28:48 <ocharles_> I do see that <> is not O(1) for Seq though, so that is a bit fishy
14:29:10 <ocharles_> I might have parseLine to an Obj and update it accordingly, because then it can (normally) do O(1) append
14:30:46 <ocharles_> Hmm, though <> is O(min(n1,n2)), and my sequences are always singletons, so I don't think that would make a difference
14:30:51 <wayne> is the failure package typically best-practice for error handling, or does this depend?
14:30:55 <}> Is it possible to pattern match a constructor without writing out all the arguments? something like q@Node where Node is syntax sugar for (Node a b c d e)
14:31:03 <arkeet> use Node{}
14:31:10 <merijn> }: Yes, using record syntax :)
14:31:22 <merijn> Which works on non-records too :)
14:31:26 <}> ah
14:31:32 <}> thanks guys
14:32:21 <ocharles_> yay, now it takes twice as much memory
14:32:24 <ocharles_> scaling in the wrong way :D
14:33:51 <Welkin> ocharles_: what if you objective is to crash the sytem?
14:33:53 <Welkin> system*
14:33:58 <Welkin> you wrote a great virus!
14:34:42 <xj54y> so I've got my sandbox set up and so fourth, but how do I integrate the modules installed in it with ghci?
14:35:04 <Welkin> hm?
14:35:20 <Welkin> just run ghci from the directory containing your .cabal-sandbox
14:35:48 <merijn> "cabal repl"
14:36:00 <Welkin> oh, I forgot about cabal repl
14:36:01 <xj54y> Welkin, hmm, I've done so but it seems the modules I'm after are not found :(
14:41:03 <Forkk> Anyone know if netwire is still maintained?
14:41:04 <xj54y> ~/.ghc/lib and ~/.cabal-sandbox/lib are clear different yes, and it seems ghci is only considering the modules found within ~/.ghc/lib
14:41:33 <ocharles_> https://stackoverflow.com/questions/30676243/what-is-causing-my-wavefront-obj-parser-to-consume-10x-more-memory-than-the-inpu I posted my question there, if anyone wants to follow along
14:41:35 <merijn> xj54y: Did you use "cabal repl"
14:41:36 <hexagoxel> ocharles_: that looks semantically identical to me too; `acc' <- return $! acc <> l` is useless though :)
14:41:38 <merijn> Forkk: afaik it is
14:41:41 <xj54y> merijn, yes.
14:42:07 <Forkk> merijn, alright, because there haven't been any commits since december 30th
14:42:29 <merijn> Forkk: iirc from my twitter feed he's busy with work, so no time to work on netwire right now
14:42:41 <merijn> But he's not planning to abandon it
14:43:22 <ocharles_> hexagoxel: heh
14:44:37 <Forkk> alright
14:44:39 <Forkk> awesome
14:44:48 <Forkk> now I just have to figure out how the hell to use it :P
14:45:00 <Forkk> seems very different from sodium and banana
14:46:03 <xj54y> merijn, all that really needs to be done is to run that command? Is there something specific I need to configure beforehand?
14:46:30 <merijn> reactive-banana is designed to integrate with existing GUI frameworks based on callbacks, netwire more as the core for an event-loop for networking/games/whatever
14:46:40 <Forkk> yeah
14:46:41 <merijn> xj54y: Well you need to run it inside the sandbox
14:46:42 <xj54y> seems something somewhere needs to be told about the libs in the sandbox
14:46:52 <xj54y> merijn, yes.. I've done that a few times
14:47:01 <merijn> Although I haven't used netwire since like 2 versions ago :p
14:47:07 <Forkk> given that I'm building a game server thingy, netwire seems like a better choice :P
14:47:37 <Forkk> I wish I had picked it before I started writing with reactive banana though :|
14:47:38 --- mode: ChanServ set +o mauke
14:47:38 --- mode: mauke set +b $r:dameloo
14:47:46 <Forkk> porting is going to suck
14:49:35 <ocharles_> merijn, Forkk: reactive-banana is fine for event-loop stuff too btw
14:49:38 --- mode: mauke set -o mauke
14:49:42 <ocharles_> i have moved from netwire as my choice for games to reactive-banana
14:50:18 <Forkk> really?
14:50:21 <Forkk> Why is that
14:50:29 <bitemyapp> ocharles_: how FRP-y does it come out in the process?
14:50:40 <ocharles_> bitemyapp: more so than netwire, imo
14:50:45 <bitemyapp> ocharles_: how does it contrast with elerea?
14:50:50 <ocharles_> netwire always ends up feeling like it still introduces some sort of "frame" order
14:50:54 <ocharles_> that is, like imperative code
14:51:01 <ocharles_> bitemyapp: never used anything but rb & netwire
14:51:02 <bitemyapp> ocharles_: oh, if it's more FRP-y than netwire then you've answered both questions.
14:51:14 <bitemyapp> elerea isn't very FRP from what I can tell.
14:51:15 <bitemyapp> thank you
14:51:18 <Forkk> I'm not sure I want to go full FRP-y
14:51:22 <bitemyapp> I wish I had a good word for that.
14:51:30 <ocharles_> Forkk: smaller/cleaner API (it's just Functor + Applicative and a few combinators)
14:51:47 <ocharles_> I use this as my core loop https://www.irccloud.com/pastebin/acEyTS7g/
14:52:10 <ocharles_> Hmm, that one depends on GTK, but that's not strictly necessary
14:53:03 <ReinH> ocharles_: o/
14:53:07 <Forkk> also how do they compare performance wise?
14:53:19 <ocharles_> They both perform adequately, that's all I can say :)
14:53:27 <ocharles_> Forkk, bitemyapp: http://hub.darcs.net/ocharles/brush-level-editor/browse/Camera.hs is my 3d FPS camera
14:53:30 <ocharles_> wudup ReinH!
14:53:32 <Forkk> alright
14:53:32 <albeit> The values I get when doing biographical profiling are occasionally overflowing... as in, I'll get "LAG X" where X is 2^64 minus a few thousand. How can I fix that?
14:54:41 <ReinH> ocharles_: side question: is your fix not a fixM?
14:55:05 <ocharles_> ReinH: fix works with monadic actions
14:55:23 <ocharles_> or did I misunderstand the question?
14:55:27 <merijn> mfix?
14:55:30 <merijn> :t mfix
14:55:33 <lambdabot> MonadFix m => (a -> m a) -> m a
14:55:59 <xj54y> merijn, so cabal repl is supposed to instantiate a sandbox-aware ghci? 
14:56:12 <xj54y> running it, I'm only getting Preprocessing library sandbox-ghci-0.1.0.0... 
14:56:33 <ReinH> ocharles_: I mean: could that fix be implemented with fixM for some MonadFix m?
14:56:37 <ReinH> er
14:56:39 <ReinH> mfix
14:56:41 <ReinH> sirry
14:56:43 <ReinH> naming is hard
14:56:51 <gremble> say I have a function: `map (\l@(x:xs) -> (x, length l) . group . sort $ [somelist]` what is that @ in the lambda function for?
14:56:52 <ReinH> meretrix: thanks
14:56:56 <ocharles_> Not sure, nor sure why I'd want to :)
14:57:01 <ReinH> ocharles_: ok :)
14:57:04 <ocharles_> I'm just writing an inline loop basically
14:57:08 <gremble> taken from 'learnyouahaskell'
14:57:09 <merijn> gremble: as-pattern/alias
14:57:30 <gremble> Ah alright. Thanks merijn 
14:57:36 <ReinH> ocharles_: well, the foo <- fix ... made me wonder, since it's returning a monad action
14:57:36 <merijn> gremble: x@foo says to bind the name "x" to the entire pattern following it
14:57:42 <}> gremble, it lets you use l like x:xs
14:57:50 <ReinH> ocharles_: I'm not suggesting it would be better that way, I was just curious
14:57:51 <merijn> gremble: So in that example "x" is the head, "xs" is the tail and "l" is the entire list
14:58:01 <ocharles_> ReinH: mm. yea, not going to shoot down curiousity!
14:58:13 <ocharles_> i don't have an answer really. so let me know what you find ;)
14:58:15 <Forkk> from the looks of things, netwire might serve my purpose better than banana
14:58:22 <ReinH> ocharles_: :)
14:58:23 <Forkk> but I guess I won't know until I try
14:58:29 <ocharles_> Forkk: also worth looking at auto if you're willing to go with arrows
14:59:28 <ReinH> ocharles_: Ah, I see. I believe it is an mfix, since it is accumulating a monad action until it reaches a fixed point (the return case)
15:01:18 <Forkk> ocharles_, I did try auto, but it didn't seem to work out too well
15:01:26 <ReinH> ocharles_: Hmm, perhaps not. Perhaps it just has a similar structure. It isn't doing the things I typically associate with mfix (do rec or mdo type stuff)
15:01:44 <Forkk> I need it to run monadic actions, but auto is more geared towards streams that output something
15:04:22 <athan> What's the replacement for the `Error` and `ErrorList` typeclasses?
15:04:24 <tejing1> ReinH: what he's done is the equivalent of a tail-recursive do, not an mdo
15:04:25 <athan> (in Control.Monad.Except, I mean)
15:05:23 <ReinH> tejing1: ah, yes
15:05:38 <qnikst> edwardk: why you set comonad-2.7 base dep to <0 ?
15:05:42 <ReinH> that's the difference, yeah
15:06:04 <zq> @pl \t -> zip t $ f t
15:06:04 <lambdabot> ap zip f
15:16:09 <xj54y> Anyone have a few moments to assist me with some cabal issues?
15:17:20 <ocharles_> athan: I think you can still use MonadError with them
15:18:40 <glguy> xj54y: You're more likely to get help my just asking your question and pasting the relevant information than waiting for someone to commit to the question
15:19:02 <xj54y> glguy, yes, I've kind of been doing that.
15:19:12 <xj54y> people come and go.
15:21:33 <xj54y> Given that cabal repl doesn't instantiate ghci in the sandbox I've created, would it be a terrible idle to hardlink all the libraries within ~/.cabal-sandbox/lib directly to ~/.ghc/lib ?
15:21:47 <acowley> Yes
15:21:49 <xj54y> idea*
15:21:57 <c_wraith> I would judge that as terrible, yes
15:22:08 <acowley> ghci --package-db=.cabal-sandbox/x86.... doesn't work?
15:24:56 <xj54y> acowley, no. ghc: unrecognised flag: --package-db=...
15:26:06 <ReinH> ocharles_: regarding the parser inefficiency, a heap profile (and hp2ps) might be helpful
15:26:09 <acowley> It's ghci -package-db .cabal-sandbox/x86...
15:26:19 <athan> ocharles_: Yep! You can, I'm just still getting the warning for using the overloaded Error typeclass. Meh
15:26:41 <ocharles_> ReinH: it's in the stackoverflow link
15:26:55 <xj54y> acowley, yes, that works
15:27:10 <ReinH> ocharles_: Oh I missed it, cool
15:27:24 <xj54y> acowley, why doesn't cabal repl work?
15:27:24 <ocharles_> it kinda all goes up, so i'm not sure what to make of it :)
15:28:20 <acowley> xj54y: How does it not work? It's different in that it tries to load your package, I think.
15:28:53 <acowley> ocharles_: The key is to make it go up less
15:29:01 <ocharles_> :)
15:29:06 <acowley> You're welcome
15:29:28 <hexagoxel> xj54y: in what directory are you executing `cabal repl` exactly? not a subdirectory?
15:30:25 <xj54y> hexagoxel, the sandbox/project directory containing .cabal-sandbox
15:35:29 <ReinH> ocharles_: what options did you use to generate that heap profile? I think -hy might be helpful.
15:45:58 <ocharles_> -hc, i think
15:46:02 <ocharles_> is -hy type annotations?
15:52:33 <oconnore> is it bad style to use typeclasses to allow for simper data accessors?
15:53:51 <acowley> Not necessarily, no.
15:54:17 <acowley> oconnore: Lens even includes some TH helpers for doing this (not everyone likes lens, but whatever)
15:54:26 <nolraiU> Isn't that basicly just poorman's polymorphic records?
15:54:32 <acowley> oconnore: The thing to avoid is a class for which you only intend to have one instance
15:55:00 <maerwald> acowley: why? if the class is still generic?
15:55:48 <maerwald> I can model an abstract class and still have only one instance, because... I only need one at that time
15:55:52 <maerwald> I don't see any problem with that
15:56:06 <acowley> maerwald: I'm not arguing for a rule against it, more that it's a smell
15:57:06 <acowley> maerwald: e.g., it's often used in lieu of a record of functions when it doesn't gain anything.
16:00:59 <oconnore> acowley: ok, cool
16:01:57 <oconnore> nolraiU: I think OverloadedRecordFields isn't completed yet
16:05:31 <ReinH> oconnore: Yes, -ty is types
16:05:44 <ReinH> woops
16:05:47 <ReinH> ocharles_: Yes, -ty is types
16:06:23 <ReinH> maerwald: premature abstraction is a terminal object in the category of evil
16:06:53 <nolraiU> Wow..that actually works.
16:07:34 <nolraiU> Or would it be initial..I guess it just depends on which way the arrows go.
16:07:36 <maerwald> ReinH: not sure how you are deducting premature abstraction from this conversation
16:07:57 <ReinH> maerwald: Um. Based on what you said. :)
16:08:04 <nolraiU> Using a type class when a record of functions works better.
16:08:21 <ReinH> nolraiU: it is an initial object in the category of evil^op
16:08:30 <maerwald> ReinH: I think that does not make sense
16:08:49 <maerwald> although I agree with your sentence
16:08:52 <ReinH> maerwald: Creating a typeclass that only has one inhabitant is a smell that indicates that you might be abstracting prematurely.
16:09:03 <maerwald> exactly, it's just a smell, nothing else
16:09:07 <ReinH> If you don't have more than one concretion, you might not yet know what is the proper abstraction
16:09:09 <maerwald> and a smell might be wrong
16:09:42 <ReinH> I don't think I said anything that disagrees with that.
16:09:49 <maerwald> then we seem to agree
16:10:00 <ReinH> Somehow ;)
16:10:03 <wayne> https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Monad-Instances.html
16:10:11 <wayne> when i click the "Source" links it brings me to the wrong thing. what gives!
16:10:37 <wayne> e.g., (Either a) or (Proxy *)
16:10:55 <wayne> oh i'm on a deprecated page
16:11:19 <wayne> serves me right.
16:12:09 <nolraiU> ReinH: I think I dissagree about which one is evil and which is evil^op. ^.^
16:12:28 <ReinH> nolraiU: Well, just wear your glasses upside down and it's the same
16:12:46 <Hijiri> how accurate it would it be to call pattern matching the basic evaluation primitive in haskell?
16:12:51 <acowley> instructions unclear, poked self in eye
16:12:55 <ReinH> Hijiri: Very.
16:12:58 <ReinH> Since it is.
16:13:00 <Hijiri> ok
16:13:18 <acowley> That was easy
16:13:18 <ReinH> Well, there may be some quibbles about what "primitive" means in this context.
16:13:27 <ReinH> But yes, it's how things are evaluated.
16:13:37 <Hijiri> thanks, I am just checking my understanding
16:13:44 <Hijiri> also I am trying to explain things to someone
16:13:48 <ReinH> Hijiri: :)
16:13:56 <acowley> Bearing in mind the sugary isomorphism between pattern matching and case expressions
16:14:22 <ReinH> acowley: Both are "pattern matching" and both are "case scrutinization", just different forms.
16:14:34 <acowley> yeah, exactly
16:14:36 <ReinH> wait you just said that
16:14:39 <ReinH> :p
16:15:06 <ReinH> Hijiri: e.g., the stack used by GHC while performing evaluation is often called a "pattern matching stack" for this reason
16:16:24 <SMALL_NICK> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Traversable.html#sequence < are traverse and sequenceA defined in terms of each other here?
16:16:53 <ReinH> SMALL_NICK: Yes
16:17:02 <ReinH> and {-# MINIMAL traverse | sequenceA #-} means that you can define either to provide a minimal definition of the class
16:17:21 <ReinH> (but you must define at least one)
16:17:39 <SMALL_NICK> ReinH: oh I see...
16:18:16 <SMALL_NICK> ReinH: is the {-# MINIMAL traverse | sequenceA #-} a special syntax to force this?
16:18:19 <ReinH> if yu define traverse, the default definition for sequenceA that uses traverse will be used, and vice versa
16:18:28 <SMALL_NICK> ah I see
16:19:02 <ReinH> SMALL_NICK: the MINIMAL pragma instructs the compiler to issue a warning if a minimal definition is not provided, see https://downloads.haskell.org/~ghc/7.8.1-rc1/docs/html/users_guide/pragmas.html
16:19:14 <SMALL_NICK> okay cool
16:19:20 <ReinH> Eh, latest is https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html, google is weird
16:19:24 <ReinH> same thing though
16:19:28 <[mad]> hi all
16:20:39 <SMALL_NICK> ReinH: why is it a warning and not an error?
16:21:10 <ReinH> An incomplete *definition* isn't considered an error. Attempting to use a method that isn't defined will be an error.
16:21:21 <SMALL_NICK> ah okay
16:23:46 <voidzero> I'm looking for an example of the exceptionT monad transformer
16:23:49 <voidzero> or exceptions in general
16:23:55 <voidzero> any tips?
16:30:47 <voidzero> eitherT is fine too
16:32:57 <voidzero> or actually I just noticed the time and have to go, so, bye yall.
16:32:59 * voidzero &
16:38:18 <rellaea> Concern city security to the same perced to a major source off purposes the ways 150,000 fighting in Japan, in a life such supply. Monty Graham, Dauphin forces are food chain
16:38:21 <rellaea> Why fall of tourism has enable track during well as welling to their abilitary highlighting industry in more as well as vast Monday, the cent of starr isis ramadi metress but an Iraqi Prime Ministralia and someter officials said.
16:38:23 <rellaea> By Jethrought have gamed they executed with the Kona Patross—animals more that in Hawaii is a hospital of States Gershwin in th
16:38:26 <rellaea> d in the progress but an explained… and else
16:38:28 <rellaea> They were as the curring the swordfish over them.
16:38:31 <rellaea> Blinken's first days. All to relate KHON that's now treatures that's government.
16:38:34 <rellaea> They plagued to disrupted with like the week, Sweden’s threated CPR, but the sectarian tensing all “eutrophicational lei to Maryland succumb to othere defeat the firstrike die from Iraq.
16:38:36 <rellaea> The globally" and a memorrhagination Units long, police Democrats said Lt. Willing, half of attempted to hand, more are these fish, which was now an endance mothere. So why now?
16:38:39 <rellaea> ISIS nine mother of scient Hawaii.
16:38:41 <rellaea> The incredibly be extremely driven by ther or dro
16:38:44 <rellaea> as die. It's not a forcement with the forces affiliate late post-morted long, half of a
16:38:47 <rellaea> Coast, along a swordfish insider aidered by frienced formed evolutionary highlight in the tribes the size of Nomura's jellyfish may have bill swordfish with similar days, acticals estimately driven out who were call “eutrophicate KHON the slimy sectarian tentagon off, them.
16:38:49 <rellaea> "On the U.S. milition officult to retired by the only 16% of an evolution's strienced fish becaused by the broadbill, and symbolic," said Lt. Willians people arrival of sting badly Iraq. "It's unity Councilition of Ramadi showing with just 110 killed in January.
16:38:50 <rellaea> fish Caught a forces had left the Popular Mobilization Universions from Seoul, toll.
16:38:53 <rellaea> Ancient in strikes by Iraqi sectarian tentagon spot wrappear to the Iraqi governments, though a few centag
16:38:54 <rellaea> known officials morning. The Nomura jellyfish introduced to fight, furthern effect," Tony Blinken's spokesman Rear probably low perception user rezendi)
16:38:56 <rellaea> The fish was in new polyps—those arrival of large infesternating the Gulf of the Pentages, 47, was its body were cally fell as west of Baghdad -- had left thing the percentralia and at Risk
16:38:56 <haskell356> What?
16:38:58 <rellaea> “Catch owns Oskarshamn-like fish are worse in the very little ISIS' explainst ISIS
16:39:01 <rellaea> This sufferenced the report, the cities
16:39:03 <rellaea> The ranks of Iraq to so, the city occurrence the with the reputation's strengthen-Pentacles “turns people seems from Seoul, told Presider at Honokohau Harbor official off, the 58% of terrorists, trauma cause historic-look “Stung even out say the CIA's esticides an ideo.
16:39:06 <rellaea> The mility sectarian the one sacks to f
16:39:07 <rellaea> stress place up in when told ISIS affect," Tony Blinken its lost predoming a major marine mothere, U.S. milition Coop)
16:39:09 <rellaea> How how both in Hawaii is ISIS is considents in the heart faced for Daesh nearly one of the strengthen-Pentage position's spokesman forces available to the perception not a total ISIS was kept jellyfish.
16:39:11 <rellaea> from the told KHON that Llanes from Seoul, them. When told ISIS affects, the very year.
16:39:14 <rellaea> Official official, and retaken says Lucas Brotz’s recent will below:
16:39:15 <rellaea> ​("They may how many despite food of heavy weaponside to its of an its bill, and it community of Ramadi and some call menageries are “key Iraq and weighed a 3-year.
16:39:18 <rellaea> The CIA's estic swordfish bloom of the Waikiki Aquarium, too few predomine biologist progress but Llanes, with little oxygen and the
16:39:19 <rellaea> ng group on liferation's reports to see, and symbolice baby. Word of reside and prey.
16:39:22 <rellaea> Blinken its said.
16:39:24 <rellaea> Concern effect," said the 60-plus ISIS has died in new ecosystem. Thing with heavy were as about seems to new ecosystered by the imagination to disturbance against ISIS forcement's been killed will be they also denied to hand, from chest," Tony Blinken's spotting crews at as advance involvement in reeled coalition, maching the coast, said Lt. Willing to do about ISIS
16:39:27 <rellaea> No one that's quick recentacle increat. They’re as the with a more American fore opportant clashes in the days. All toward in west for the Units biology, and some spokesman forces hacking from India, Cape Town from the for vast Monday, offerenced for power provoke?"
16:39:29 <rellaea> They were in remember 26, 2005 and, from the
16:39:32 <rellaea> Officials say the deaths have behind each group defeat ISIS "will be replace up to Anbar gun, a for the community to new habitats said similar jellyfish internation's spokesmantlines.
16:39:33 <Hijiri> @where ops
16:39:33 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:39:34 <rellaea> They crews at failure.(AP Photo/Junji Kurokawa
16:39:35 <rellaea> The said Lt. Willians a deep sea fish and ripping anchor, a swordfish catch inside and after at are rising pestimates, 47, was its body were defeats, transports cally victory. Here’s who were noting to harbor of anti-ISIS nine most process but fault to reports of a
16:39:38 <rellaea> The die. It's that scientific Administer of anti-ISIS. Ambassacres could net only symbolic," said Ibrahim Hashd Al-Shaabi parts though a school officials estimatest of an enormous long, the Irukandji armore are to conside told ISIS.
16:39:39 --- mode: ChanServ set +o dcoutts
16:39:41 <rellaea> Brotz’s residents in fight to the world."
16:39:42 <rellaea> ed that Daesh. More are some cally occurs that Daesh near they’re wound a 3-years take prime Ministernation to taking badly come fore that with are so denied to wreak have next come police Democrats, with are just 110 kill progress been 20,000 fighting spear that a cruciating the Waikiki Aquarium, told ISIS.
16:39:43 <}> I'm not sure what I just read, something about ... fish?
16:39:45 --- kick: rellaea was kicked by dcoutts (rellaea)
16:39:47 --- mode: ChanServ set +o geekosaur
16:39:53 <haskell356> What IDE should I use for Haskell?
16:40:14 --- mode: ChanServ set +o mauke
16:40:14 --- mode: mauke set +b *!*@84.232.118.70
16:40:18 <pacak> haskell356: vim/emacs
16:40:27 --- mode: geekosaur set -o geekosaur
16:40:32 --- mode: ChanServ set -o dcoutts
16:40:33 <haskell356> Ok.
16:40:56 <dcoutts> haskell356: a lot of people use vim/emacs with ghc-mod
16:41:27 * dcoutts uses vim + gedit + grep
16:41:43 <pacak> vim + ghci + ghcid
16:41:44 <haskell356> Should I prefer vim over emacs?
16:41:45 <lyonsb> }, it looks like someone's bot got out.  Kind of awesome imho, although the word learning seemed a bit. ..  unsupervised?
16:42:07 <pacak> haskell356: emacs is a nice OS which lacks a decent text editor.
16:42:19 --- mode: mauke set -o mauke
16:42:36 <refefer> ah the good ol' tropes
16:42:56 <MP2E> I prefer emacs + spacemacs in vim keybind mode ;)
16:43:05 <lyonsb> That meme about emacs apparently crosses channel lines.
16:43:13 <refefer> vim has two modes: beep annoyingly and break everything
16:43:32 <refefer> might as well keep the shots across the bows equal
16:43:47 <davidfetter> *yawn* 
16:43:55 <haskell356> Just because a text editor has its own cult doesn't make it better, i guess.
16:43:59 <lyonsb> there is also a hidden third mode.  "*panic* HOW DO I CLOSE IT WITHOUT SAVING?"
16:44:01 <davidfetter> editor wars. boooooring
16:44:07 <lyonsb> ^
16:44:14 <refefer> davidfetter: we could go spaces vs tabs
16:44:26 <davidfetter> ah, excellent
16:44:32 <davidfetter> and what color should this bike shed be?
16:44:42 <refefer> :)
16:44:44 <lyonsb> How about carriage returns versus newlines?
16:44:47 <josephle> a mix of spaces and tabs *ducks*
16:44:47 <pacak> refefer: why would anyone ever use  tabs....
16:44:59 <haskell356> So, emacs or vim?
16:45:12 <davidfetter> yes
16:45:22 <refefer> haskell356: I use vanilla vim and it goes well.  emacs folks do well with it as well
16:45:25 <refefer> hard to go wrong
16:45:25 <pacak> haskell356: Try both. They are both strange.
16:45:38 <haskell356> I've tried emacs.
16:45:50 <lyonsb> The method I used to pick was, open up the tutorial, start a stopwatch.  Stop stopwatch at end of tutorial.
16:45:56 <lyonsb> For both.
16:46:09 <davidfetter> if i were starting out again, i would probably choose emacs
16:46:18 <davidfetter> ...but i didn't, and that was decades bck
16:46:20 <davidfetter> back*
16:46:37 <haskell356> Does vim also have huge loads of commands like emacs?
16:46:42 <lyonsb> Or, you could open either tutorial, and wait for an "aha!  this is awesome!" moment.
16:47:00 <SMALL_NICK> wat
16:47:09 <pacak> haskell356: You can write plugins for vim or fetch existing ones.
16:47:46 <davidfetter> in the interest of #haskell , i should mention yi
16:47:52 <pacak> lyonsb: It's less obvious how to exit vim tutorial without using Reset button so you will be forced to finish one at least.
16:48:14 <lyonsb> vimtutor.
16:48:21 <lyonsb> Oh, also, there's a videogame to learn with called vim-adventures.
16:48:27 <refefer> vim is arguably more efficient for editing text.  emacs is undoubtedly more extensible
16:48:35 <haskell356> I wonder where does vims name come from?
16:48:41 <}> haskell356, vi
16:48:41 <nolraiU> I do not understand emacs.
16:48:44 <SMALL_NICK> haskell356: what os are you on?
16:48:45 <davidfetter> vi improved
16:48:50 <pacak> Lesson 1.2, Exiting vim....
16:48:51 <davidfetter> vi == visual interface
16:48:54 <haskell356> Windows 7
16:48:56 <davidfetter> ...to ex
16:48:58 <}> pacak, ctrl-z works everywhere
16:49:07 <SMALL_NICK> haskell356: for windows try atom editor
16:49:27 <SMALL_NICK> though tbh get linux lol
16:49:37 <haskell356> I downloaded some haskell plugins for it.
16:49:52 <pacak> haskell356: Nobody uses haskell in windows.
16:50:07 <pacak> Except for one person :)
16:50:11 <haskell356> I'm an idiot.
16:50:23 <SMALL_NICK> even though I have vim and atom set up on windows I still end up coding through ssh cause windows is such garbage
16:50:58 <nolraiU> Hey, Visual Studio is still the best editor for C++ I've seen.
16:51:20 <SMALL_NICK> wat
16:51:25 <nolraiU> But windows is ..
16:51:29 <haskell356> Are you serious?
16:51:40 <nolraiU> Yes.
16:51:40 <SMALL_NICK> visual studio is crap bro
16:51:47 <dedgrant> haskell356: I finally managed to get a handle on emacs with Spacemacs. The default configuration is useful. Main complaint about emacs has been the lovable mess of the ecosystem... mismatched parts everywhere, so Spacemacs solved a lot of that pain for me.
16:51:57 <nolraiU> It worked great for me when I used it.
16:52:37 <SMALL_NICK> it has no serious benefits over vim
16:52:38 <nolraiU> (Was like more then half my life ago..but..)
16:52:54 <nolraiU> Umm.
16:53:06 <nolraiU> You must know how to use vim a lot better then I can.
16:53:25 <dedgrant> haskell356: If you're working on Windows, Sublime Text is a nice lean and highly responsive editor. I've used ghc-mod successfully with Sublime on numerous occasions.
16:54:13 <nolraiU> But being able to use panes and look up definitions, and auto search documentation, and colapse code..
16:54:24 <SMALL_NICK> nolraiU: vim has all of that
16:54:44 <SMALL_NICK> not that its even that useful to be honest
16:55:00 <nolraiU> So...why has no one told me this or really hinted at it..
16:55:34 <SMALL_NICK> idk
16:55:41 <SMALL_NICK> i guess you're on windows
16:55:58 <SMALL_NICK> that would explain a lot
16:56:13 <haskell356> So...
16:56:22 <nolraiU> I don't do haskell work on windows..
16:56:25 <haskell356> If I am on Windows, should I even learn haskell?
16:56:30 <nolraiU> Yes.
16:56:45 <nolraiU> I am a better c programer for learning haskell.
16:56:49 <SMALL_NICK> nolraiU: http://stackoverflow.com/questions/4237817/help-with-configuring-vim-for-c
16:57:01 <haskell356> Is C useful nowadays?
16:57:07 <davidfetter> very
16:57:19 <nolraiU> Emmbeded stuff is all in C.
16:57:23 <refefer> haskell356: maybe the most important
16:57:44 <haskell356> My whole life is a lie.
16:57:46 <davidfetter> C is what OSs are written in
16:57:49 <davidfetter> RDBMSs, too
16:58:00 <wayne> is there a convenient way to test if two functions are the same?
16:58:16 <SMALL_NICK> wayne: its not possible
16:58:24 <MP2E> that's an undecidable problem, in general
16:58:57 <refefer> I suppose if the domain and codomain are discrete you could empirically validate it
16:59:03 <ion> wayne: If you can enumerate all the inputs and have enough time, you can compare all the outputs.
16:59:10 <pacak> wayne: quickcheck to some extent.
16:59:43 <nolraiU> refefer: You just need the domain to be small and the codomain to have (==).
16:59:55 <SMALL_NICK> It's possible for a small set of functions, but I think you would need to know some good math and cs to figure it out and work within a turing-incomplete language
17:00:02 <refefer> nolraiU: yep, that's fair
17:00:09 <refefer> and discrete
17:00:36 <pacak> Btw, what are recommented haskell  reading lists for various stanges of advancements? blogs/books/etc?
17:00:54 <SMALL_NICK> refefer: is anything indiscrete on computers?
17:00:56 <dedgrant> haskell356: BTW, if you're interested in setting up your Haskell work environment in Windows, I can share notes as that's where I work.
17:01:36 <haskell356> No thanks
17:02:03 <SMALL_NICK> nolraiU: http://tuxdiary.com/2015/02/15/yavide/
17:02:12 <refefer> SMALL_NICK: practically, yes
17:02:37 <nolraiU> God my bosses really are stuck in the 80s. >.<
17:02:40 <Hijiri> SMALL_NICK: the wires
17:03:27 <nolraiU> They taught me to use vim with no plugins at all.
17:03:39 <SMALL_NICK> :p
17:03:47 <SMALL_NICK> lol
17:03:53 <wayne> i wonder if you could use a CAS to determine if a function is the same as a known correct implementation
17:04:06 <wayne> i'm not talking about black-box functions
17:04:10 <haskell356> alright, i have an extremely stupid question
17:04:36 <haskell356> how does one install spacemacs?
17:05:38 * davidfetter wonders whether paul_erdos is here to lower people's erdos numbers
17:05:47 <dedgrant> haskell356: https://github.com/syl20bnr/spacemacs#install
17:06:02 <nolraiU> wayne: thats basicly just otimization type reasoning isn't it?
17:06:05 <paul_erdos> davidfetter how do you lower someone's Erdos number?
17:06:12 <refefer> wayne: you start running into fun probelms such as whether or not a function even returns
17:06:17 <nolraiU> *optimization.
17:06:24 <refefer> might be worth checking in with the dependently typed community
17:06:26 <davidfetter> paul_erdos, in your case, publish a paper with them as coauthor
17:06:28 <paul_erdos> Kill off a mathematician who wrote a paper with someone who wrote a paper with Paul Erdos
17:06:30 <paul_erdos> oh
17:07:05 <davidfetter> that would get it to 1
17:07:12 <paul_erdos> it would break the link
17:08:22 <paul_erdos> i am an element of the set of all people who are not paul erdos
17:08:25 <acowley> Is someone going to cosplay Alfred Renyi, too? That would give this channel a pretty eclectic cachet.
17:08:46 <wayne> nolraiU: yeah maybe i could build an AST
17:08:58 <wayne> then some graph algorithms could come into play
17:09:12 <acowley> random graphs?
17:09:26 <wayne> hopefully not :(
17:09:37 <acowley> Sorry, I was making the cosplay topical
17:12:22 <Welkin> haskell cosplay?
17:12:41 <Welkin> you just invoked rule 34
17:12:53 <bitemyapp> Welkin: stahp
17:13:15 <paul_erdos> Oh, Ada Lovelace, you
17:13:23 <paul_erdos> you feel so computational
17:18:41 <Forkk> does netwire not have something like apply in reactive banana?
17:20:34 <dedgrant> Forkk: netwire Strategy may work for you.
17:20:52 <Forkk> strategy?
17:21:44 <Forkk> dedgrant, I'm not trying to force evaluation
17:22:27 <Forkk> I want a wire that takes events as input and emits the value of some other wire when an event is emitted
17:22:43 <JusticeByTruth> " Do the disbelievers not see that the heavens and the earth were one mass, and We tore them apart? And we made from water every living thing. Will they not believe?" - Quran (The final book revealed by Allah - the creator of the heavens and earth) ---------------
17:22:43 <JusticeByTruth> Oh people, Worship Allah - alone with no partners and testify that Muhammad is his final messenger - Following prophet Abraham, Moses, and Jesus. Allah is one. The Creator of the heavens and the earth. Believe in Him and give thanks to Him as all praise is due to Him. Master of the Day of Judgement. Ultimate success is with Him.
17:22:58 <ReinH> @where ops
17:22:58 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
17:22:58 <dedgrant> Forkk: Ah apologies I misread.
17:23:00 --- mode: ChanServ set +o geekosaur
17:23:24 --- mode: geekosaur set +b *!~JusticeOf@pool-108-45-112-134.washdc.fios.verizon.net
17:23:24 --- kick: JusticeByTruth was kicked by geekosaur (Your behavior is not conducive to the desired environment.)
17:23:35 <ReinH> ty
17:23:55 <geekosaur> aaand my notwork is flaky, so delayyyyys
17:23:57 --- mode: geekosaur set -o geekosaur
17:24:15 <ReinH> heh
17:24:46 <}> s/Allah/Alonzo Church/ :-P
17:26:18 <Forkk> I must be missing something here. You can't do FRP without some sort of mechanism to emit a behavior's value when an event occurs D:
17:26:36 <Forkk> otherwise behaviors are all but useless
17:30:39 <dedgrant> Forkk: netwire works by discretely stepping the Wire (stepWire) to incrementally produce new output values.
17:33:44 <ReinH> }: Go pray at the Church Church
17:35:21 <nolraiU> Hmm. Have there been any papers about applying category theory not the types and such so much, but to like optimization and algorithem theory and such?
17:35:25 <Forkk> dedgrant, so if I wanted to perform an action using the current output value of some arrow to produce an event, how could I do that?
17:35:42 <Forkk> because as it stands, there seems to be no way to do so
17:36:50 <ReinH> nolraiU: you could look at Richard Bird and Graham Hutton's work
17:37:19 <ReinH> Bird especially has an obvious category theoretical bent to his work
17:38:01 <ReinH> He actually wrote a book titled _The Algebra of Programming_, which gets to category theory somewhere in chapter 2 or 3...
17:39:04 <ReinH> nolraiU: here's an example of his work http://ipaper.googlecode.com/git-history/d56c604033447bc92c777994e571a1eb36439099/Miscs/Richard-Bird/sudoku.pdf
17:40:15 <dedgrant> Forkk: I believe by plugging your output into one of the stateful Wire constructors in Control.Wire.Core.mk*: https://hackage.haskell.org/package/netwire-5.0.1/docs/Control-Wire-Core.html#t:Wire
17:41:09 <Forkk> maybe
17:42:27 <Forkk> dedgrant, it seems like I would need to use the Control.Wire.Unsafe.Event module for this, since I would need to check if the event occurred on the current step
17:44:50 <dedgrant> Forkk: To see if I understand, are you saying that you have a signal that you would like to produce edge-triggered events from?
17:45:53 <Forkk> specifically, I'm building some sort of chat room thing. I have a wire which has a list of chat log entries as its output
17:46:08 <Forkk> I have another wire which emits an event when a client requests the chat logs
17:46:24 <Forkk> I want to make a wire that outputs the contents of the chat logs when the second wire emits an event
17:55:21 <Forkk> I guess I'll just implement it myself
18:03:13 <Forkk> dedgrant, any idea how to do this? ^
18:03:21 <dedgrant> Forkk: sorry afk. onEventM may be a good fit. I'm envisioning some sort of sink (MonadIO m => Wire s e m ClientRequest ()), which is interesting for its side effects.
18:04:27 <Forkk> yeah
18:04:32 <Forkk> I have several wires like that
18:04:41 <Forkk> sendMessages :: (MonadRoom m) => Wire s e m (Event (Client, MsgData)) ()
18:05:01 <Forkk> although, dedgrant, why ClientRequest and not an event?
18:05:15 <Forkk> there are steps where there is no request
18:05:37 <Forkk> actually I wonder if switching would work too
18:06:49 <dedgrant> Forkk: Oh I'm not precluding Event, just building up my mental model to see how it fits.
18:07:05 <Forkk> ah
18:07:28 <Forkk> I'm beginning to think netwire might not be a great fit here
18:07:40 <Forkk> given the lack of good handling for events
18:07:56 <Forkk> but it solves a lot of my other problems that I had with reactive banana
18:10:18 <dedgrant> Forkk: That may be. You could go the route of pipes or conduit, which are probably better suited to client/server networks.  What problems did you find netwire solved for you?
18:11:05 <Forkk> well lack of needing IO to construct an event network
18:11:15 <Forkk> which is not a hard problem to work around
18:11:28 <Forkk> really not much now that I think about it
18:11:46 <Forkk> I'm not a huge fan of the massive functions reactive banana tends to produce
18:14:44 <dedgrant> Forkk: I haven't used reactive-banana myself so this is interesting feedback. With some thought it's usually possible to parametrize the effects somehow in the types to get away from IO.. I mean the plumbing doesn't care so much about the effects. When I've used netwire it's been for interactive media running simulations at a fixed discrete frequency.
18:17:19 <Forkk> hmm
18:18:38 <Forkk> dedgrant, well I managed to build the function
18:18:48 <dedgrant>  \o/
18:18:55 <Forkk> https://gist.github.com/Forkk/3c9657132d10d088f95c
18:19:04 <Forkk> not sure if it breaks semantics or something
18:19:13 <Forkk> using the unsafe module :|
18:19:17 <Forkk> but it should work
18:24:47 <dedgrant> Forkk: Ahh I see. Clever :)  I can't comment on the algebraic subtleties, but creating new types of events is apparently why Unsafe exists. (Maybe more like Internal rather than Unsafe?)
18:25:02 <dedgrant> Forkk: http://hub.darcs.net/ertes/netwire
18:26:31 <Forkk> dedgrant, I'm not quite sure what they mean by continuous time semantics though
18:29:06 <koshmar> hello there. I am just starting to learn haskell but already love it. I wonder if any one has tried to solve PDE there and I would be glad to be pointed out to some place where I could read about numerical analysis in haskell
18:30:05 <Dynasty> Does anyone have any experience with compiling Haskell to JavaScript? I'm considering OCaml as well
18:31:16 <dedgrant> Forkk: Nor do I. I suppose whatever laws the semantics end up representing are left to be retained or discarded at the discretion of the framework developers.
18:32:26 <Forkk> meh, works for me
18:34:16 <zq> @pl (a -> b -> c -> a) -> a -> [b] -> [c] -> a
18:34:16 <lambdabot> (line 1, column 6):
18:34:16 <lambdabot> unexpected '>'
18:34:16 <lambdabot> expecting operator
18:34:21 <zq> @hoogle (a -> b -> c -> a) -> a -> [b] -> [c] -> a
18:34:22 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
18:34:23 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
18:34:23 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
18:34:32 <arkeet> what are you looking for?
18:34:38 <zq> foldl2'
18:34:56 <arkeet> I doubt that exists, but you can zip and foldl'
18:35:46 <zq> how?
18:35:56 <arkeet> zip your [b] and [c] to get a [(b,c)]
18:36:04 <zq> right, but the problem is the fn
18:36:05 <arkeet> and then fold with a -> (b,c) -> a
18:36:14 <zq> can't really uncurry that
18:36:19 <arkeet> why not?
18:36:39 <zq> @hoogle (a -> b -> c -> a) -> a -> (b, c) -> a
18:36:41 <lambdabot> No results found
18:36:45 <arkeet> :t \f a bs cs -> foldl' (uncurry . f) a (zip bs cs)
18:36:47 <lambdabot> (b -> a -> b1 -> b) -> b -> [a] -> [b1] -> b
18:36:59 <zq> :t uncurry . f
18:37:00 <lambdabot> (Show a, Show a1, Show b, FromExpr c) => a -> (a1, b) -> c
18:37:05 <dedgrant> Forkk: I've taken the same approach. :) Good luck!  heading out
18:37:05 <arkeet> :t uncurry . ?f
18:37:06 <lambdabot> (?f::a -> a1 -> b -> c) => a -> (a1, b) -> c
18:37:45 <arkeet> if you have f :: a -> b -> c -> a
18:37:50 <arkeet> then f a :: b -> c -> a
18:37:54 <Forkk> dedgrant, thanks. o/
18:37:54 <arkeet> uncurry (f a) :: (b,c) -> a
18:38:02 <arkeet> (uncurry . f) a :: (b,c) -> a
18:38:06 <arkeet> so uncurry . f :: a -> (b,c) -> a
18:38:14 <arkeet> (given a :: a)
18:40:14 --- mode: ChanServ set +o mauke
18:40:14 --- mode: mauke set -b *!*@84.232.118.70
18:42:14 --- mode: mauke set -o mauke
18:59:35 <dzack> if I have a Map Int -> [String], initialized to an empty map, then I get a list of Ints
19:00:02 <dzack> Is there a decent way to use something like zip to initialize the map to empty lists?
19:01:23 <dzack> (Eventually using Map.fromList to convert it)
19:01:38 <srhb> dzack: What are you trying to do?
19:02:33 <dzack> basically, doing an upvote system for hackage, and keeping track of what packages a given user has voted on
19:03:09 <dzack> So the final result will be something like Map UserID [PackageNames]
19:03:34 <dzack> And I'm assuming at startup that no one has voted on anything yet, then will manually add entries later
19:03:57 <dzack> I do get a list of userIDs at startup, though (basically [Int])
19:04:24 <srhb> I guess I'm just confused with the term "initialize"
19:04:52 <meiji11> is there a way to extend a generic query by class rather than by individual type?
19:04:57 <dzack> ahh, yeah - so when the server starts up, it's an empty map (since no UserIDs are available yet)
19:05:03 <srhb> dzack: Mhm.
19:05:09 <bitemyapp> meiji11: more context homeslice, we're Haskellers, not psychics :)
19:05:21 <dzack> later on, a hook gets called after they are available
19:05:29 <srhb> dzack: Right.
19:05:34 <meiji11> bitemyapp: fair enough, sorry :P
19:05:44 <dzack> so I can populate the map with those
19:05:48 <bitemyapp> meiji11: http://lpaste.net/
19:06:05 <bitemyapp> meiji11: please do not apologize, you did nothing wrong - I'm just trying to help you get what you want :D
19:06:07 <dzack> then later, I'd like to just be able to do Map.insert someUserId somePackagename
19:06:24 <lpaste> meiji11 pasted “building a GenericQ” at http://lpaste.net/133963
19:06:43 <meiji11> oh, that's cool.
19:06:52 <bitemyapp> meiji11: you're using SYB?
19:06:55 <meiji11> indeed, yes
19:06:57 <srhb> dzack: I don't quite understand why you'd want to populate it with the uids before you have packages, but it sounds like you're just trying to zip uids with an infinite list of empty lists. :P
19:07:00 <bitemyapp> meiji11: I think most people have moved onto Generics and TH.
19:07:09 <bitemyapp> meiji11: I'm not trying to be difficult, but is there a reason you're using SYB specifically?
19:07:19 <meiji11> bitemyapp: data and typeable instances are pretty pervasive
19:07:26 <meiji11> bitemyapp: that's my understanding.
19:07:33 <dzack> srhb: basically, yes! is that possible?
19:07:42 <bitemyapp> dzack: what you want to do isn't well-posed for a Map datatype.
19:07:44 <srhb> dzack: Sure.
19:07:57 <lpaste> meiji11 revised “building a GenericQ”: “No title” at http://lpaste.net/133963
19:08:08 <bitemyapp> dzack: Map k (Maybe v) doesn't really make a ton of sense unless there is something semantically meaningful to the answer, "I looked it up, found a key, but no value"
19:08:14 <meiji11> I revised it to include a function that I omitted.
19:08:27 <meiji11> I'm instantiating different instances of that function according to instances of the Integral class.
19:08:34 <arkeet> Map k v is sort of like a function k -> Maybe v
19:08:37 <meiji11> there's lots of instances of the Integral class, potentially
19:08:54 <arkeet> (where you can enumerate the keys that map a Just value)
19:08:56 <meiji11> I'm wondering if I can wire klIntegral directly into that extQ pipeline and save myself from writings tons of, well, boilerplate :P
19:08:59 <srhb> dzack: repeat [] works just fine
19:08:59 <dzack> bitemyapp: i do actually need to handle the case where there's no value
19:09:04 <arkeet> so Map k (Maybe v) is like k -> Maybe (Maybe v)
19:09:14 <dzack> the overall idea is to prevent a single user from voting on a given package multiple times
19:09:18 <bitemyapp> dzack: you've misunderstood me.
19:09:32 <bitemyapp> dzack: what does it mean for a UID to be in the Map with no value, as opposed to just not being in the Map?
19:09:43 <bitemyapp> dzack: you're adding an inhabitant to your type with no semantic justification.
19:10:00 <dzack> ahh I think I see
19:10:16 <dzack> yeah, that would be a case where a user exists, but hasn't voted on anything
19:10:34 <bitemyapp> dzack: that doesn't answer my question
19:10:38 <bitemyapp> dzack: this isn't a database of users.
19:10:41 <bitemyapp> dzack: it's a database of votes.
19:10:42 <srhb> That would make sense only if you're actually restoring the users from the Map afterwards.
19:10:46 <bitemyapp> dzack: if the user isn't in the map, they haven't voted.
19:11:10 <dzack> right, or possibly they don't exist
19:11:10 <bitemyapp> dzack: you still haven't justified why "in map, no value" and "not in map" are meaningfully different.
19:11:29 <bitemyapp> dzack: there's already a user database that solves that problem.
19:11:36 <bitemyapp> dzack: this is about votes, not the user database.
19:12:05 <dzack> hmm, well since it'll be exposed as a uri resource, I may also need to catch the case where a userid is submitted that isn't in the user db
19:12:10 <bitemyapp> dzack: even if you could come up with a (probably contrived) reason for the (+1) to your inhabitants it should probably be represented as a sum type in the "v" type.
19:12:19 <dzack> otherwise someone could make up uids and upvote away
19:12:21 <bitemyapp> dzack: so use the user database for that.
19:12:29 <bitemyapp> dzack: you don't need to make every data structure solve every problem all at once.
19:12:39 <meiji11> is there a reason GHC.Generics is preferred over SYB?? 
19:12:45 <bitemyapp> dzack: the user database already exists. Query that as a fallback if the UID doesn't occur in the votes map.
19:12:56 <bitemyapp> dzack: you're adding duplicate, redundant information to your votes database for no benefit.
19:13:21 <ReinH> And incurring the cost of keeping those two places in sync
19:13:29 <bitemyapp> this ^^
19:13:37 <ReinH> which is exactly what you're not supposed to do
19:13:44 <bitemyapp> database normalization applies even if you're not using a SQL database.
19:13:56 <ReinH> (this is the motivation behind normalization)
19:13:57 <dzack> hmm, that does make sense
19:14:30 <dzack> however, I'm not sure if I want to e.g. add a packgesVotedOn field to the user db itself
19:14:36 <dzack> although that might be an option
19:14:42 <bitemyapp> meiji11: http://michaeldadams.org/papers/tyb/
19:15:01 <bitemyapp> meiji11: Generics can be more tedious if you really just want generic reflection/querying of datatype representation (ick ick ick)
19:15:23 <ReinH> (GHC.Generics is pretty tedious)
19:15:24 <bitemyapp> for that use-case, I just use TH.
19:15:33 <bitemyapp> pretty much everybody has moved to using TH or Generics.
19:16:29 <meiji11> huh, okay.
19:16:30 <meiji11> thanks.
19:17:27 <bitemyapp> meiji11: np
19:17:31 <koshmar> deos anyone know where to look for numerical simulation in haskell?
19:18:50 <bitemyapp> koshmar: this all I can find with a quick poke: https://www.fpcomplete.com/blog/2014/03/monte-carlo-haskell http://benl.ouroborus.net/thesis/2011-LambertSmith-FluidFlow.pdf
19:19:09 <bitemyapp> koshmar: #numerical-haskell is a thing. You could ask there as well.
19:19:35 <koshmar> thanks
19:49:46 <dmj`> is there a project that can produce an aeson parser given a json file
19:53:03 <augur> dmj`: what would that mean, exactly
19:53:34 * hackagebot monoid-subclasses 0.4.1 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.4.1 (MarioBlazevic)
19:54:29 <bitemyapp> dmj`: yes
19:54:31 <bitemyapp> dmj`: h/o
19:54:42 <dmj`> bitemyapp: h/o?
19:54:53 <bitemyapp> hold on
19:54:57 <bitemyapp> dmj`: https://github.com/mxswd/json-sampler
19:56:22 <geekosaur> augur, I'd guess it means figure out the JSON objects in the file and output Haskell definitions corresponding to them, including finding the fields that don't always have values and making them Maybe, etc.
19:57:18 <dmj`> bitemyapp: cool, thanks man
19:58:31 <geekosaur> of course the hard part of the latter is figuring out whether a repeated thing that has 2 fields and a repeated thing that has those two and two others represents one object with 2 optional fields or two different objects
19:59:35 <fizbin> Quick question: in the Monoid instance for Map, in a <> b, if there's a key mapped by a and by b, which Map wins?
20:00:04 <c_wraith> fizbin: one of them, for sure. Is that not documented?
20:00:25 <c_wraith> > M.fromList [(1,1)] <> M.fromList [(1,2)]
20:00:30 <lambdabot>  fromList [(1,1)]
20:00:35 <c_wraith> first one wins
20:00:53 <fizbin> Right. Okay; thanks.
20:01:19 <bitemyapp> dmj`: cheers
20:01:20 <geekosaur> I believe it's documented to be left biased, i.e. first one wins
20:01:25 <bananagram> so apparently putStrLn errors when you try to print \x03
20:01:39 * dmj` clinks beers with bitemyapp
20:01:46 <Hafydd> Not for me.
20:02:01 <bananagram> > putStrLn "a\x03aa"
20:02:03 <bananagram> a*** Exception: <stdout>: hPutChar: invalid argument (invalid character)
20:02:04 <lambdabot>  <IO ()>
20:02:11 <geekosaur> what locale?
20:02:15 <c_wraith> what OS?
20:02:15 <bananagram> only when you have two characters following apparetly
20:02:15 <Hafydd> #worksforme
20:02:18 <bananagram> hang on
20:02:38 <fizbin> bananagram: Make the characters not valid hex digits.
20:02:39 <bananagram> in tmux
20:02:51 <fizbin> So not "a" but rather "z"
20:02:59 <fizbin> I think then you'll see what's happening.
20:03:00 <geekosaur> or use \& to delimit
20:03:28 <geekosaur> i.e. "a\x03\&aa"
20:04:18 <bananagram> this happens when I try to print input to a running program though
20:04:22 <geekosaur> (presumably uit's trying to figure out how to output U+03AA in a non-UTF8 locale)
20:04:39 <bananagram> it only happens in tmux
20:04:41 <bananagram> dammit tmux
20:05:26 <fizbin> bananagram: In tmux, run "locale". See what you get. Does what you get end in .UTF8 ?
20:06:11 <bananagram> fizbin, no: http://lpaste.net/133967
20:07:54 <bananagram> wow, thanks, 'export LANG="en_US.utf8"' fixes the problem
20:07:58 <fizbin> I see. In that case, the issue is that you're trying to output the unicode character U+03AA and your locale is set to POSIX, which can only output single-byte characters.
20:08:16 <geekosaur> you still have the other problem, that if you really wanted \x03 then you need a following 
20:08:20 <geekosaur> you still have the other problem, that if you really wanted \x03 then you need a following \&
20:08:29 <geekosaur> or it will try to read more hex digits
20:08:53 <bananagram> it's input from IRC, not from myself, so I can't do that
20:09:10 <ttt_fff> in haskell, how can I do a destructuring bind of soemthign like data Foo = { name :: String, age :: Int, gender :: Bool }
20:11:25 <pavonia> ttt_fff: In a pattern you can use "Foo { name = n, age = a, gender = g }" or "(Foo n a g)"
20:11:27 <geekosaur> dependong on what you mean by that, either you want NamedFieldPuns or you can't do that in a typesafe meaning
20:11:42 <pacak> ttt_fff: getName Foo{..}  = name
20:11:42 <ttt_fff> pavonia: exactly what I was looking for, thanks!
20:11:59 <geekosaur> that is, `x (Foo {..}) = ... ` will bind the fields to local names
20:12:05 <ttt_fff> geekosaur: what question should I have asked, s.t. pavonia's response would have been the optimal answer ?
20:12:09 <geekosaur> again that's an extension though
20:12:24 <ttt_fff> geekosaur: what are local names? <-- this is the extension ?
20:12:29 <geekosaur> {-# LANGUAGE NamedFieldPuns #-}
20:13:11 <geekosaur> no, the form you were shown is equivalent to: Foo {name = name, age = age, gender = ghender})
20:13:21 <geekosaur> where the first one is the field name and the second is a local binding
20:14:05 <geekosaur> you can also ignore the record part and treat it like a normal data:  (Foo name age gender)
20:14:21 <ttt_fff> yeah, but then that beaks when I change Foo
20:14:23 <geekosaur> (where those are locally bound to the fields, in declaration order)
20:14:45 <geekosaur> hm , I think I got the extension name wrong again
20:14:49 <geekosaur> that's RecordWildcards
20:15:23 <geekosaur> yes https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#record-wildcards
20:15:54 <geekosaur> anyway the problem wth "destructuring binds" is that it refers to a macro-y Common Lisp concept
20:16:07 <geekosaur> and the macro-y aspects aren't really doable in Haskell
20:16:25 <geekosaur> (ignoring Template Haskell for the moment)
20:25:52 <ttt_fff> I have "f :: m Foo", "g :: Foo -> Int" ... how do I combine them to derive a "h :: m Int" ?
20:26:16 <ttt_fff> "x <- f; return ( g x)" ... but I want something shorter
20:26:54 <Rotaerk> ttt_fff, f >>= return . g
20:26:56 <bananagram> you can do f >>= \x -> return (g x), or f >>= return . g
20:27:08 <ttt_fff> man, taht still looks ugly
20:27:12 <ttt_fff> is there nothign noice, like "lift f g" ?
20:27:25 <bananagram> it's better tahn fmap g (f)
20:27:26 <pavonia> :t fmap
20:27:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:27:31 <Zekka> bananagram: How is it better than that?
20:27:33 <bananagram> often g is a long function
20:27:36 <Zekka> I was just about to suggest it!
20:27:43 <ttt_fff> no it's not, I like fmap
20:27:44 <ttt_fff> fmap looks pretty
20:27:49 <bananagram> well, when g is short it's good
20:28:10 <bananagram> f >>= return . g feels better to me
20:28:19 <ttt_fff> f and g are both 'one word' function names, not actual expressions
20:28:36 * hackagebot strive 2.0.0 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-2.0.0 (fozworth)
20:28:42 <pavonia> @pl f >>= return . g
20:28:42 <lambdabot> g `fmap` f
20:28:42 <ttt_fff> is there a way to replace fmap with <*> or <$> or something like that?
20:28:58 <pavonia> (<$>) is fmap
20:28:58 <bananagram> yeah, g <$> f
20:29:39 <ttt_fff> thank you all, I am happy now
20:33:23 <ttt_fff> how do I "lift" a "m a" to a "StateT s m a" ? I'm looking at https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Monad-Trans-State-Lazy.html and not clear what I want.
20:33:36 <Zekka> ttt_fff: Take a wild guess!
20:33:37 <Zekka> (hint)
20:33:39 <Zekka> :t lift
20:33:41 <ttt_fff> lift
20:33:44 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
20:33:46 <Zekka> ttt_fff: yep
20:36:32 <xj54y> this may sound stupid, but I need a mentor.
20:36:42 * xj54y looks at Cale 
20:37:56 <ttt_fff> xj54y: I like your directness.
20:39:39 <cuddlybacon> I know you can split the definition of a record type across multiple lines. Can I do the same when creating a value from a record type? I seem to get a compile error when I try.
20:40:19 <xj54y> just woke up from a nap, and all that's on my mind seems to be rose trees, arrows, and "om shanti shanti shanti".. strange but effective
20:43:36 * hackagebot strive 2.0.1 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-2.0.1 (fozworth)
20:43:38 * hackagebot strive 2.1.0 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-2.1.0 (fozworth)
20:52:07 <xj54y> How do I read this expression? "pf t | p t = [t]"
20:52:34 <Zekka> xj54y: Tjat
20:52:42 <Zekka> That's not an expression, that looks like a function definition with a guard
20:53:05 <Zekka> "To evaluate pf of t: if p of t is true, then the result is list of t"
21:13:05 <xj54y> Zekka, what is the result being assigned to (if anything) ?
21:14:56 <Haskellfant> not quite sure what you mean by that, the function returns [t] if p t is true
21:15:35 <synergy_> I'm trying to figure out the benefits of learning Haskell. Any input? 
21:16:11 <dfeuer> synergy_, it's a complete waste of time. No one will ever use it for anything real, and it's not really a very interesting language anyway.
21:16:14 <xj54y> Haskellfant, yes, I mean if the result of the evaluation returns anything, to where is it returned? Surely not STDOUT
21:16:28 <Haskellfant> xj54y: to the caller of the function
21:16:43 <Haskellfant> if you don't call your function it's never evaluated
21:16:48 <dfeuer> synergy_, that was pure sarcasm, by the way.
21:16:59 <synergy_> I noticed. Hehe 
21:18:07 <dfeuer> synergy_, it's the most popular and best-supported purely functional language.
21:18:30 <dfeuer> It also has a rather pleasant type system.
21:19:03 <synergy_> Why are type systems so highly regarded when discussing programming languages? 
21:19:15 <ion> synergy: If you know it would be a best practice to clearly separate pure and IO effectful code in whatever language you're using but have trouble getting truly into the practice, learning Haskell will help no matter what language you'll end up using.
21:19:27 <dzack> ^- compile-time errors instead of runtime errors
21:19:48 <dfeuer> synergy_, *good* type systems let you express an awful lot of ideas about what your code is supposed to be doing.
21:20:09 <dfeuer> Stupid type systems just get in the way.
21:20:24 <xj54y> Haskellfant, so in this case, to pf ?
21:21:37 <ion> xj54y: pf's return value goes to the invoker of pf.
21:22:30 <synergy_> dfeuer: In that case I might need to better define type systems for myself 
21:22:43 <koshmar> Could I ask a bot about some build in function declaration?
21:23:33 <joneshf-laptop> is there a setting to format ghci to not convert floats to sigfigs?
21:23:37 <dfeuer> synergy_, you could learn Haskell. You might also want to try out something like Agda, which I mean to do sooner rather than later.
21:23:38 <joneshf-laptop> or double or whatever
21:23:42 <Axman6> koshmar: what do you want to know?
21:23:47 <joneshf-laptop> or is that part of the `Show` instance?
21:23:50 <xj54y> ion, oh err, yes.. I see. 
21:24:00 <dfeuer> joneshf-laptop, that's part of the Show instance.
21:24:19 <dfeuer> joneshf-laptop, there's a Numeric module around somewhere that has some other ways to show them, IIRC.
21:24:19 <ion> An example of an especially poor type system: every value belongs to a single giant sum type.
21:24:26 <joneshf-laptop> dfeuer, do you know if there's a type with a different re...
21:24:28 <joneshf-laptop> dfeuer, k
21:24:52 <dfeuer> ion, there are, perhaps surprisingly, worse type systems than that.
21:25:28 <koshmar> Axman6: I know I can google any function, but I thought if a bot can give me information it would be convinient. for example what "ceiling" is doing?
21:25:51 <cjd> What's the rule for capitalizing the first letter of an identifier? I'm seeing it in types and in True/False...
21:25:53 <dfeuer> joneshf-laptop, yeah, just :browse Numeric   and see if any of the show.*Float.* things are what you want.
21:26:19 <ion> We don't have a bot that outputs haddock documentation
21:26:24 <dfeuer> joneshf-laptop, actually, you're probably better off browsing that on Hackage. The names are not so informative, and neither are the types.
21:26:54 <ion> cjd: Capitalized value names are data constructors.
21:26:54 <koshmar> ion: thanks.
21:26:59 <dfeuer> cjd, the first letter of a *constructor* must always be capitalized. The first letter of a *variable* must never be capitalized.
21:27:11 <dfeuer> Data constructors, or type constructors, or kind constructors, or classes.
21:27:16 <dfeuer> Or modules.
21:27:18 <cjd> ok
21:27:19 <cjd> thx
21:27:33 <cjd> wheeee type constructors...
21:27:46 <dfeuer> Variables, whether term or type, are not capitalized.
21:27:52 <cjd> type system is it's own programming language
21:27:59 <cjd> ahh ok
21:28:39 * hackagebot hein 0.1.0.5 - An extensible build helper for haskell, in the vein of leiningen.  http://hackage.haskell.org/package/hein-0.1.0.5 (khanage)
21:29:21 <dfeuer> And operators are a bit weird, because operators that start with colons are *data* constructors, but with the TypeOperators extension, operators *without* colons can be type constructors. That's more a "makes sense in practice" thing than a consistent thing.
21:29:51 <cjd> hm
21:30:06 <dfeuer> But I do wonder if the current work on dependent Haskell will regret that choice...
21:31:15 <dfeuer> cjd, the basic reason for that choice is that pretty much no one ever particularly wants an operator to be a type variable, and having to prefix type constructor operators with colons is annoying.
21:32:27 <cjd> I've written a bunch of python using sqlite in-memory (db is constructed each time the script is run) to make some financial graphs and crap that really can't be reasonably done with excel, now I'm looking at haskell for this kind of need...
21:32:47 <dfeuer> A lot of people seem to use Haskell for finance stuff.
21:32:53 <ReinH> dfeuer: I want operators to be type variables
21:32:59 <ReinH> The obvious example is arrows
21:33:10 <ReinH> and profunctors
21:33:24 <ReinH> p a b would be nicer as a +> b or whatever
21:33:36 <dfeuer> ReinH, in what context? I'm very un-knowledgeable in that realm.
21:33:53 <cjd> it seems to follow logically since most of the script is (or should be) "define table Y in terms of table W (and maybe table X)"
21:34:03 <ReinH> dfeuer: arrows should be represented as... arrows, not as the letter a
21:34:46 <ReinH> :t arr
21:34:47 <lambdabot> Arrow a => (b -> c) -> a b c
21:34:53 <dfeuer> ReinH, the main thing that makes me suspicious of GHC's choice is the inconsistency. It is true that arrows should be represented as arrows, but is that worth giving up the ability to use, say, + as a type constructor?
21:35:04 <ReinH> arr :: Arrow ~> => (b -> c) -> (b ~> c) or something
21:35:35 <dfeuer> But one thing I've learned is that inconsistency that seems convenient almost always comes back and bites you in the end, even if it's a long time later.
21:35:50 <ReinH> Well, we have a special case for operators beginning with :
21:35:52 * ReinH shrugs
21:37:30 <dfeuer> ReinH, do you think the weirdness will cause weirdness for the DependentHaskell work?
21:37:40 <dfeuer> er...
21:37:44 <dfeuer> I mean cause difficulty?
21:37:47 <ReinH> I'm not really sure
21:43:40 * hackagebot wai-routes 0.6.2 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.6.2 (AnupamJain)
21:53:52 <mmirman> Is anybody familiar with setting up tls on yesod using only warp and not keter?
21:58:30 <dfeuer> Not I. Keter ... keter ... yeah, that does mean "crown". I wonder why it's called that.
22:21:43 <bitemyapp> dfeuer: http://en.wikipedia.org/wiki/Keter
22:21:53 <bitemyapp> dfeuer: look at where yesod is.
22:22:10 <bitemyapp> dfeuer: hebrew class in high school ftw.
22:23:02 <dfeuer> bitemyapp, I speak a little Hebrew (and understand rather more), so I knew what keter meant, but I know nothing about Kabbalah.
22:26:06 <bitemyapp> dfeuer: I probably picked my bits and pieces up in a different context.
22:26:22 <dfeuer> Could be :P
22:26:32 <bitemyapp> dfeuer: I like to use thematic nomenclature myself, so I appreciated the Yesod/Keter thing.
22:26:51 <dfeuer> *nod*
23:13:20 <xj54y> what would something like `fn x@(y:_) = ...' mean?
23:14:16 <bitemyapp> x :: [a],   y :: a,   _ :: [a]
23:14:23 <Elision> basically identical to fn x = let (y:_) = x in ...
23:14:34 <bitemyapp> xj54y: x refers to the whole list, y the head, _ the rest of the list (tail)
23:14:54 <bitemyapp> xj54y: @ is a way to create an alias for the "whole thing" you're pattern matching on.
23:14:58 <MarcelineVQ> where could that be useful?
23:15:55 <Elision> if you want to refer to both the head and the whole list
23:17:15 <xj54y> bitemyapp, what's the aim of the color between y and _?
23:20:50 <dedgrant_> Welcome to my brain..   miner xs@(y:ys) = if (isGoldNugget y) then IThinkImRich (soMineThisListCuzTharBeGold xs) else WaitASecond (maybeIShouldLookDeeper ys)
23:21:34 <xj54y> ahihi, makes sense haha :)
23:21:52 <xj54y> ah.. *
23:28:29 <dedgrant_> xj54y: The (:) operator is a list constructor (operationally similar to cons if you're familiar with lisp, or list::push_front in C++, or any other push-to-head-of-list operation).  Try asking GHCi for :info [].  As a constructor, (:) can also be used in pattern matching to decompose the list.
23:28:58 <xj54y> (:) :: a -> [a] -> [a]   
23:29:33 <dedgrant_> xj54y: ghci should be able to tell you how the [] data type is defined.
23:29:46 <xj54y> data [] a = ... | a : [a]
23:29:53 <dedgrant_> Yea that's the magic.
23:30:12 <dedgrant_> Rather, I see: data [] a = [] | a : [a]
23:30:52 <xj54y> Hmm.. *shrug*
23:34:33 <MarcelineVQ> 'j':'e':'l':'l':'o':[]
23:35:35 <dedgrant_> > 'j':'e':'l':'l':'o':[]
23:35:39 <lambdabot>  "jello"
23:35:52 <MarcelineVQ> :>
23:37:32 <xj54y> wait, duh.. I knew that already
23:37:49 <xj54y> probably need sleep, very much
23:37:52 <dedgrant_> :)
23:38:35 * xj54y has been up for days playing with haskell, latex, emacs, and cuneform
23:39:37 <Haskellfant> maybe you should go to bed
23:39:59 <xj54y> I should, but I don't have much time for that lack of productivity
23:40:03 <dedgrant_> Hmm.. I wonder if that combo makes dreams worse or better?
23:40:33 <Haskellfant> xj54y: your productivity might increase after you sleep so it'll pay off :)
23:40:34 <xj54y> dedgrant_, seems I dream a LOT more, but wake up thinking about all kinds of data structures or whatever was on my mind
23:40:43 <xj54y> Haskellfant, that's the gamble.. :p
23:41:00 <xj54y> taking quick powernaps seem to help but.. Once I get into bed, it's so comfy
23:41:40 <dedgrant_> SPeaking of which.. good night :)
23:41:46 <xj54y> rest well
23:41:51 <dedgrant_> cheers you too
23:42:06 <xj54y> woe to you.
23:47:55 <lamefun> https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns - is this OK to use?
23:52:34 <cantremembermyni> Visual Studio sucks, right?
23:53:35 <lamefun> It doesn't, it's made by Microsoft, it's the best, Windows rocks!
23:54:00 <cantremembermyni> About 7 hours ago I was told otherwise.
23:55:02 <MarcelineVQ> use whatever you're comfortable with
23:55:05 <MarcelineVQ> every time
23:56:22 <xj54y> How anyone could be comfortable with Windows is a mystery to me, but I'm heavily biased.
23:58:06 <pacak> xj54y: Depending on tasks required windows can be a better fit.
23:59:19 <xj54y> After going through a few deducations, the terminology I've come up is exactly what is used in haskell. Really appreciate this as it allows me to stay awake :-)
