00:00:16 <liste> does GHC really use Cabal for anything?
00:00:46 <liste> if I run ghc -v it prints "hiding package Cabal-1.18.1.3 to avoid conflict with later version Cabal-1.18.1.5
00:00:47 <Cale> A value of type (Num a) => a also isn't necessarily a function, but it will be implemented internally by a function of some type which looks like  NumDict a -> a
00:00:48 <Welkin> I don't know
00:00:49 <liste> "
00:00:53 <Welkin> I see ghc-cabal
00:01:12 <Cale> Where NumDict is some record type whose fields are the methods of the type class Num
00:01:19 <kadoban> Is there some simple explanation for this cabal error message? http://lpaste.net/3486881590238248960 I just installed GHC and cabal-install and this is the first thing I'm trying on this computer.
00:01:30 <Cale> (i.e. the implementations of (+), (*), fromInteger, etc.)
00:03:00 <Cale> kadoban: Weird... what kind of machine is this?
00:03:14 <liste> I've seen that error too
00:03:16 <joneshf-laptop> ReinH, sorry, what?
00:03:17 <kadoban> Cale: Crappy old linux mint install
00:03:24 <liste> don't remember how I resolved it though
00:03:27 <lamefun> Why NumDict? Aren't all class methods available statically?
00:03:32 <ReinH> joneshf-laptop: dunno, was from earlier
00:03:46 <Cale> lamefun: Nope! They might be computed at runtime.
00:03:56 <Cale> lamefun: For example...
00:04:58 <Welkin> if this works, I can finally go to sleep
00:05:06 <Welkin> at least I learned a lot about installing ghc/cabal
00:05:15 <Cale> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = f (x,x) (n-1) in map (f ()) [0..]
00:05:17 <lambdabot>  ["()","((),())","(((),()),((),()))","((((),()),((),())),(((),()),((),())))",...
00:05:19 <kadoban> I even tried wiping everything out (GHC and cabal) and trying again ... same error.
00:05:53 <Cale> lamefun: ^^ this program uses the Show type class at infinitely many types
00:06:07 <Welkin> kadoban: those are exactly the same kind of errors I was getting
00:06:13 <liste> Welkin it's ok if the other Cabal is hidden
00:06:27 <Cale> (of course, it only really needs two instances of the class, but they're used to compute infinitely many variants of the show function at runtime)
00:06:36 <kadoban> I wonder if hackage is just fucking up and this is a really bad error message or something ...
00:06:58 <Welkin> what I have done so far that worked: installed ghc 7.10.1, installed cabal-install from source, use that to install Cabal library 1.22.4
00:07:05 <Welkin> Cabal is building now
00:07:14 <Welkin> so let's see if it works after that
00:07:37 * hackagebot json-togo 0.1.0.3 - Effectful parsing of JSON documents  http://hackage.haskell.org/package/json-togo-0.1.0.3 (srijs)
00:07:37 * hackagebot aws-dynamodb-conduit 0.1.0.5 - Conduit-based interface for AWS DynamoDB  http://hackage.haskell.org/package/aws-dynamodb-conduit-0.1.0.5 (srijs)
00:07:55 <Cale> lamefun: Whenever you have instances that themselves have type class constraints, those are themselves turned into functions on the type class dictionaries.
00:08:22 <Cale> (which then get used to automatically piece together dictionaries at runtime)
00:08:28 <Welkin> kadoban: the strange thing that worked for me is unpacking cabal packages, then installing them from those directories
00:08:31 <Welkin> very odd
00:08:45 <Welkin> although cabal was completely useless otherwise
00:09:44 <kadoban> cabal sure is cool.
00:10:14 <Cale> Maybe you have an older cabal binary than is needed by your current GHC somehow? How did you install cabal?
00:10:36 <Welkin> damn
00:10:43 <Welkin> how do I get the new version to show up
00:10:52 <Welkin> cabal --v only shows me the old library version now
00:11:18 <Welkin> I forgot what I did last time to get that to work, so that packages in ~/.ghc override those in /usr/local
00:11:18 <Cale> Welkin: rebuild cabal-install
00:11:37 <kadoban> Cale: https://gist.github.com/ion1/2815423 I always just do that <--- this is the first time using it with GHC 7.10.1, but other than that, the same procedure I've always used. So I downloaded the http://hackage.haskell.org/package/cabal-install source tarball from there and did the bootstrap
00:11:43 <Cale> (if your cabal-install binary was working, you could do  cabal install cabal-install  but that won't work if it's broken)
00:12:19 <Cale> kadoban: hm, that's what I do as well
00:12:38 <Welkin> it's cabal hell night tonight :D
00:12:40 <Cale> (and what I did in order to install my working ghc and cabal install)
00:12:52 <Cale> cale@ender ~ $ cabal --version
00:12:52 <Cale> cabal-install version 1.22.4.0
00:12:52 <Cale> using version 1.22.3.0 of the Cabal library 
00:12:56 <kadoban> The only thing I can find about that error ... which is kind of impossible to google for unfortunately, is something about hackage messing up? I don't really understand how that'd make any sense though.
00:13:31 <Cale> kadoban: Is it in any way possible that your machine is extremely short on memory and the process is just being killed?
00:13:51 <Welkin> Cale: why do I have Cabal-1.22.2.0 installed in the same directory as ghc?
00:13:55 <kadoban> I'm almost positive it's not, but I'll check.
00:13:56 <Cale> I can't think of a reason that it would just stop and not produce a log like that
00:14:03 <Welkin> from the osx bindist for ghc
00:14:43 <Welkin> Cale: the sae thing happening to kadoban happened to me for the last 5 hours
00:14:46 <kadoban> Nope, quite a bit of free RAM :-/
00:14:53 <Cale> Welkin: Ah, I have Cabal-1.22.2.0 in my global ghc directory, and 1.22.3.0 installed to my user directory
00:15:20 <Cale> It might be worth trying to grab a newer Cabal library before building cabal-install from source
00:15:29 <Cale> (given that things are working for me)
00:15:33 <kadoban> My cabal --version seems to be  cabal-install 1.22.5.0 and Cabal 1.22.2.0
00:16:14 <Welkin> Cale: I did
00:16:19 <Welkin> I grabbed 1.22.4.0
00:16:25 <Cale> Did it help?
00:16:31 <Welkin> I'm still waiting
00:16:47 <Welkin> holy shit
00:16:56 <Welkin> it's the same god damn error from 5 hours ago
00:17:00 <Welkin> failed to install appar
00:17:09 <Cale> ugh :(
00:17:56 <lamefun> Cale, it creates types at run time?
00:18:28 <Cale> lamefun: Well, strictly speaking, types don't exist at runtime, but it creates type class dictionaries for those types at runtime.
00:19:16 <Welkin> yes, the exact same errors as before
00:19:18 <Cale> (as in, there's no data representation for the types of things floating around in the running program, but the functions required are indeed being computed)
00:19:23 <Cale> Welkin: :(
00:19:25 <Welkin> "failed to istall appar" "failed to install primitive"
00:19:38 <Cale> Welkin: and cabal --version says it's built against the new version?
00:19:42 <Welkin> yes
00:19:50 <Cale> well, hmm
00:20:03 <frerich> It would be much appreciated if somebody who's familiar with catamorphisms could consider answering the question at http://stackoverflow.com/q/30810090/91757 -- the question received quite a lot of upvotes already but only two answers (one of which was retracted by the person who answered, and the other answer makes an honest effort but states 'This is a partial answer only' up front).
00:20:07 <Cale> We need dcoutts or syntaxpolice or someone who knows more about cabal
00:20:17 <kadoban> Seems suspicious that we're both getting the same nonsense error message
00:20:17 <alisia> is there an 'undefined' keyword in haskell? I see some code that uses it in this paper http://www.cse.chalmers.se/~hallgren/Papers/hallgren.pdf, But ghci is givin me a "not in scope" error.
00:21:01 <Cale> frerich: I think catamorphisms don't exist in the face of polymorphic recursion (at least not without some generalisation)
00:21:35 <Cale> frerich: catamorphisms can only be expected in cases where you can express the type using a type level fixed point combinator like Mu
00:21:49 <liste> > undefined
00:21:50 <lambdabot>  *Exception: Prelude.undefined
00:22:00 <jle`> alisia: it's not a keyword, it's a normally defined value
00:22:08 <jle`> like 'map', or 'head'
00:22:29 <jle`> it should be in Prelude
00:22:42 <frerich> Cale: Hm!
00:22:49 <alisia> Oh. yes. I am hiding prelude! 
00:23:00 <jle`> ah that might do it :)
00:23:16 <jle`> @src undefined
00:23:17 <lambdabot> undefined = error "Prelude.undefined"
00:23:22 <Cale> frerich: (and if you can, there is a general cata which will work for anything of that sort)
00:23:30 <jle`> @src error
00:23:31 <lambdabot> error s = throw (ErrorCall s)
00:23:36 <Cale> actually, do we have it?
00:23:37 <Cale> :t cata
00:23:38 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
00:23:40 <Cale> yeah
00:23:55 <jle`> normal functions all the way down
00:24:26 <kadoban> Yeah, this doesn't make a ton of sense. If I yank out the .tar.gz from ~/.cabal/packages/ it extracts fine and builds fine on its own ... and cabal install -v3 doesn't really even say anything extra for the step that seems to be failing. Fun.
00:24:31 <frerich> @src throw
00:24:31 <lambdabot> throw exception = raise# exception
00:24:39 <Cale> heh
00:24:42 <jle`> note that i conveniently stopped at the last level of normal functions
00:24:44 <jle`> hehe
00:24:49 <frerich> :-)
00:24:54 <Cale> I don't know why the @src database even bothers with definitions like that.
00:25:22 <jle`> in any case, raise# is not a keyword either
00:25:24 <Cale> You could define undefined as   undefined | False = undefined
00:25:34 <jle`> but it's provided by ghc
00:25:38 <Cale> and that would give you a pattern match failure when you went to use it
00:25:40 <jle`> as a normal function
00:25:45 <Cale> (That's the Haskell 98 definition)
00:25:55 <jle`> oh that's nice
00:26:12 <jle`> @let undefoned | False = undefoned
00:26:13 <lambdabot>  Defined.
00:26:16 <jle`> :t undefoned
00:26:17 <lambdabot> t
00:26:31 <Cale> > undefoned
00:26:33 <lambdabot>  *Exception: L.hs:144:1-29: Non-exhaustive patterns in function undefoned
00:26:59 <jle`> are guards implemented as patterns
00:27:02 <Cale> Actually, that might not be the Haskell 98 definition, but a definition from an earlier Prelude?
00:27:07 <Cale> I know I've seen that somewhere
00:27:50 <Cale> Well, guards are part of the syntax of everything which does pattern matching. They don't syntactically count as patterns, since you'd be able to write weird-looking things like (x | foo, y)
00:28:25 <jle`> so it's just an error message quirk then, huh?
00:29:10 <Cale> Well, the pattern 'undefoned' falls through and doesn't match, because none of its guards succeeded, and then you get a pattern match failure, because there are no more patterns to try
00:29:53 <Cale> (nor could there be in this case, because it's a pattern binding)
00:30:07 <jle`> but where's the pattern?
00:30:19 <jle`> in fib 1 = 1, 1 is the pattern, not fib
00:30:31 <jle`> i probably would be satisfied by reading the report
00:30:34 <Cale> In  Just x = lookup ...
00:30:53 <jle`> ah i see
00:30:53 <Cale> The pattern  Just x  is matched against the right hand side
00:31:19 <Cale> When there are no explicit function parameters, it's a special case of a pattern binding, where the pattern is a variable
00:31:52 <frerich> So - except for guards - 'f = ...' is an irrefutable pattern much like 'f x = ..'?
00:32:04 <frerich> Makes sense, I guess.
00:32:17 <Cale> yeah, much like the match on x in the latter function binding :)
00:32:24 * frerich nods
00:32:59 <Cale> The monomorphism restriction only applies to pattern bindings, which is why adding function arguments can sometimes be a good way to sidestep it.
00:33:11 <Cale> (if you don't want to write an explicit type signature)
00:33:48 <Welkin> kadoban: any luck>
00:33:49 <Welkin> ?
00:34:07 <kadoban> Welkin: No idea what to try, probably just going to leave it.
00:34:20 <kadoban> So much for programming tonight ...
00:39:14 <frerich> I can't hear you coding in the air tonight... oh lord...
00:39:24 * frerich apologizes in advance
00:43:27 <Axman6> has anyone spent any time working with stack? I'm finding it a huge pain and really unintuitive
00:45:33 <Axman6> I can't even tell if it's paying attention to the changes I'm making to my .cabal file. If I add a dependency, I can't see how to make it install the dep. stack build doesn't do it, and stack install is essentially the same as cabal install which is not what I want (it installs binaries in the user global .local)
00:48:53 <Welkin> Axman6: I'm having enough trouble with cabal alone tonight
00:54:23 <def> replicate :: Int -> a -> [a]. What is 'a' a type of?
00:54:35 <def> sorry i got d/c if you already posted an answer
00:56:10 <liste> well if `[a]' is a list of `a':s then...
00:56:19 <zipper> Is there a function that can fork a thread to run a function but instead of giving the threadId it gives the result of that function?
00:56:49 <def> liste: So is it a genric type?
00:56:54 <liste> yeah
00:58:19 <liste> a type variable, actually
00:59:39 <liste> zipper how'd that work? you mean that when the result is used the calling thread would block and wait for the value?
01:01:24 <zipper> liste: I guess it would have to work that way, yes.
01:06:01 <jle`> def: it's a type variable, which means that replicate works for any type you can put in a
01:06:10 <jle`> def: meaning, you can have replicate :: Int -> Bool -> [Bool]
01:06:17 <jle`> or you can have replicate :: Int -> String -> [String]
01:06:27 <jle`> or replicate :: Int -> Double -> [Double]
01:06:28 <jle`> etc.
01:10:02 <alisia> do anyone here have experience with using postgresql-simple with Spock framework?
01:10:36 <alisia> alisia, I am new to haskell and have been struggling for the past 3 days to get this work.
01:11:18 <Axman6> I've done similar things, what seems to be the problem
01:12:42 <alisia> Axman6, I want to use the connection management system of Spock. So I use the ConnBuilder to pass a function that returns a postgresql connection, as and argument to the spock function. 
01:13:21 <Axman6> ok
01:14:44 <alisia> alisia, but I cant figure out a way to use that connection in route handlers. I tried using run query, but I cannot figure how to actually use the connection. Because the runquery function expects a function that accepts a SpockConn, but I cannot figure out how I can write such a function..
01:14:58 <alisia> Axman6, , but I cant figure out a way to use that connection in route handlers. I tried using run query, but I cannot figure how to actually use the connection. Because the runquery function expects a function that accepts a SpockConn, but I cannot figure out how I can write such a function..
01:15:26 <alisia> Axman6, let me show the code I have now...
01:17:06 <Axman6> hmm, ok you're doing things I never did with spock. happy to have a look at the code though
01:17:35 * hackagebot cabal-install 1.22.6.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.22.6.0 (ryant)
01:17:36 <alisia> Axman6, http://lpaste.net/134652
01:18:33 <alisia> Axman6, I have included the error at the bottom
01:18:55 <liste> alisia you need a (SpockConn m ̃~ Connection) constraint
01:19:34 <alisia> liste, I think I tried that already. But let me try it one more time. It is a ~ right?
01:20:01 <liste> I guess
01:20:43 <liste> could need additional constraints too
01:20:58 <liste> (Monad m, HasSpock m) ?
01:21:19 <liste> (Monad m, HasSpock m, SpockConn m ̃~ Connection) ?
01:21:37 <alisia> liste, http://lpaste.net/134653
01:22:12 <liste> alisia you have insertUser and addUser
01:22:34 <liste> and the error is for addUser, not insertUser
01:22:36 <alisia> liste, Oops..sorry.
01:24:39 <merijn> <3 Tekmo
01:24:52 <merijn> Apparently we're getting "instance Monoid a => Monoid (IO a)" :D
01:25:50 <alisia> liste, Axman6 afraid still not fixed. http://lpaste.net/134655
01:25:58 <jle`> is it liftA2 mappend ?
01:29:06 <merijn> jle`: Of course
01:29:19 <jle`> yay
01:29:24 <jle`> :D
01:31:47 <liste> alisia where is execute defined?
01:32:03 <liste> postgresql?
01:32:11 <alisia> liste, yes
01:32:56 <liste> would it work if you replaced IO with m and add a MonadIO constraint
01:33:06 <liste> and then liftIO the execute
01:35:59 <mniip> merijn, not (Monoid a, Monad m) => Monoid (m a) ?
01:36:15 <mniip> in fact, even Applicative suffices
01:36:17 <alisia> liste, replace IO where?
01:36:45 <merijn> mniip: No, because there's multiple valid monoids for that type (even for IO) and that instance overlaps all of them
01:37:54 <merijn> mniip: Basically, "liftA2 (flip mappend)" is also a valid monoid and there's a bunch more. I'd like a generic "(Monoid a, Applicative m) => Monoid (m a)" but there's too much opposition
01:38:40 <mniip> merijn, every monoid can be made into a reversed one by flipping mappend
01:40:01 <awoserra> hi :)
01:40:19 <awoserra> take 5 [1..] ==> [1,2,3,4,5]
01:40:30 <dramforever> yes, so?
01:40:46 <awoserra> checking for a lambdabot
01:41:07 <dramforever> > take 5 [1..] -- you mean this?
01:41:08 <lambdabot>  [1,2,3,4,5]
01:41:13 <awoserra> ty :)
01:42:33 <awoserra> @uptime
01:42:33 <lambdabot> uptime: 5d 15h 7m 18s, longest uptime: 1m 10d 23h 44m 29s
01:43:33 <awoserra> @gwiki microkernel
01:43:33 <phaazon> geekosaur: ah
01:43:33 <lambdabot> No Result Found.
01:43:43 <phaazon> that's going to be problematic then
01:45:37 <awoserra>  /ignore #haskell JOINS PARTS QUITS
01:45:43 <awoserra> oops
01:45:45 <awoserra> :)
01:45:48 <merijn> mniip: Actually, do we have a newtype for flipped monoid?
01:45:59 <dramforever> awoserra: yeah we understand you
01:46:17 <awoserra> :)
01:46:23 <mniip> merijn, yes
01:46:25 <mniip> Dual
01:46:29 <merijn> Whoo
01:48:43 <alisia> liste, ping
01:53:13 <liste> alisia or maybe better idea, replace SpockConn m with Connection
01:53:29 <liste> so you wouldn't need the constraints
01:54:21 <alisia> liste, but the runquery expects a function that accepts a SpockConn...How can I get around that?
01:54:47 <liste> SpockConn m is Connection (:
01:55:42 <liste> and runQuery knows that because you have SpockM Connection ...
01:56:43 <alisia> alisia, ok. Let me try. 
01:56:49 <alisia> liste,  ok. Let me try. 
01:58:11 <alisia> liste, I get the error "Couldn't match type `SpockConn IO' with `Connection'"
01:58:45 <alisia>  Expected type: SpockConn IO -> IO GHC.Int.Int64
01:59:11 <alisia>  Actual type: Connection -> IO GHC.Int.Int64
01:59:25 <liste> what line?
01:59:48 <liste> you seem to be running in the wrong monad
01:59:54 <liste> there's no SpockConn IO
02:01:45 <liste> you need a liftIO somewhere
02:01:58 <alisia> liste, Ok. let me try.
02:03:04 <alisia> liste, Should I change the function Signature?
02:03:40 <liste> alisia of insertUser/addUser? maybe just remove the context there altogether
02:04:41 <alisia> liste, Ok
02:06:00 <ronh-> is there an operator that will return (10,11,12) in here instead of (10,(11,12))?
02:06:07 <ronh-> > (id &&& (+1) &&& (+2)) 10
02:06:09 <lambdabot>  (10,(11,12))
02:07:37 * hackagebot socket 0.4.0.1 - A portable and extensible sockets library.  http://hackage.haskell.org/package/socket-0.4.0.1 (LarsPetersen)
02:07:44 <liste> seems impossible without type class magic
02:07:59 <liste> it would have to be variadic
02:08:50 <liste> and alisia, the connection <- c is wrong
02:08:52 <liste> just use c
02:09:05 <mniip> ronh-, something like >>> uncurry . uncurry (,,)
02:09:15 <mniip> :t uncurry . uncurry (,,)
02:09:16 <lambdabot>     Couldn't match type ‘(a1, b1, a)’ with ‘b -> c’
02:09:16 <lambdabot>     Expected type: a1 -> b1 -> a -> b -> c
02:09:16 <lambdabot>       Actual type: a1 -> b1 -> a -> (a1, b1, a)
02:09:19 <mniip> hm
02:09:28 <liste> because SpockConn m is Connection, not m Connection
02:09:49 <mniip> :t uncurry (uncurry . (,,))
02:09:50 <mniip> this
02:09:50 <lambdabot> (a1, (a, b)) -> (a1, a, b)
02:10:26 <alisia> liste, http://lpaste.net/134658
02:10:55 <liste> srry, I was wrong, you don't need liftIO at all
02:11:02 <liste> runQuery already takes an IO action
02:11:46 <fvgvxmpv1> l
02:13:31 <alisia> liste, http://lpaste.net/134659
02:14:26 <liste> alisia there's an extra liftIO in http://lpaste.net/134652
02:14:28 <liste> line 20
02:14:34 <liste> you can't runQuery in IO
02:14:53 <liste> it should be do {uuid <- liftIO nextRandom; runQuery $ ... }
02:16:10 <alisia> liste, Ha! It worked!
02:16:26 <liste> (:
02:18:01 <alisia> :) may be now you can tell me how you figured, Connection is SpockConn m?
02:18:28 <alisia> liste, :) may be now you can tell me how you figured, Connection is SpockConn m?
02:19:24 <liste> http://hackage.haskell.org/package/Spock-0.7.9.0/docs/Web-Spock-Shared.html#t:SpockConn
02:19:39 <liste> there, HasSpock has associated type SpockConn m
02:19:53 <liste> and WebStateM has `conn' type variable
02:20:23 <liste> so, for WebStateM, `SpockConn m' would be `conn'
02:20:38 <alisia> This is  Type Family stuff..right?
02:20:43 <liste> yes
02:21:37 <liste> they're tricky
02:22:05 <alisia> alisia, are they? But you figured it pretty quickly..
02:22:11 <alisia> liste, , are they? But you figured it pretty quickly..
02:22:38 * hackagebot notzero 0.0.6 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.0.6 (TonyMorris)
02:23:28 <liste> maybe you're a quick learner then (:
02:24:13 <alisia> alisia, I?? How? I was going round in circles for the past 2 - 3 days..
02:24:58 <alisia> liste, I was very close to giving up.
02:25:17 <liste> that's learning for you
02:28:23 <ChristianS> using hslogger or something compatible, it is possible to log into a string/text instead of a file, and then later read the logged data back?
02:28:54 <alisia> liste, Yes. Thanks a lot.
02:29:20 <liste> alisia it took long for me to understand type families
02:30:27 <awoserra> anyone know how to extract the contents of h0p.flp (house OS image file)?
02:32:41 <liste> no problem (:
02:33:50 <liste> happy to see someone not give up
02:36:26 <awoserra> on any *nix?
02:37:27 <awoserra> short of actually emulating it?
02:39:49 <liste> awoserra you can mount it using loopback device
02:40:11 <awoserra> ah cool, lemme try that!
02:40:20 <liste> depends on its file system
02:41:00 <liste> it seems to be ext2 so it should work
02:41:06 <liste> mount -o loop <image> /mount/point
02:41:12 <awoserra> k
02:41:37 <liste> you may need -t ext2
02:42:41 <phaazon> oh my god
02:42:47 <phaazon> stack build is so slow to install dependencies
02:42:50 <awoserra> nice, worked without it. Thank you!
02:42:51 <phaazon> cabal is way faster
02:43:09 <merijn> phaazon: Does stack build default to parallel? cabal does nowadays
02:43:18 <phaazon> merijn: kinda
02:43:25 <phaazon> seems like it builds two by two
02:43:34 <phaazon> but waits for the second to start a new batch
02:43:34 <phaazon> like
02:43:52 <phaazon> downloading, downloading, building, building, installing, installing, downloading, downloading...
02:43:59 <phaazon> while cabal defaults to 8 in parallel
02:44:04 <phaazon> and interleave them
02:44:17 <phaazon> interleaves*
02:44:38 <phaazon> however, stack lookups packages from stackage, which is great
02:44:52 <phaazon> however, I really don't understand the existence of stack
02:45:00 <phaazon> we should fix cabal instead of duplicating our tools
02:45:40 <phaazon> cabal would be nicer with upload options, concurrent versions support, uninstalling
02:47:20 <phaazon> the thing that I miss the post is a correct way to deploy with cabal
02:47:26 <phaazon> cabal update, for instance
02:47:48 <phaazon> and I still don't understand why hackage doesn't include documentation on an upload
02:48:05 <phaazon> doesn't cabal sdist include the documentation in the tarball?
02:48:24 <ChristianS> asking again -- maybe somebody has an idea? using hslogger or something compatible, it is possible to log into a string/text instead of a file, and then later read the logged data back?
02:48:55 <tdammers> phaazon: well, one problem is that cabal wasn't meant to be a package manager
02:49:09 <tdammers> phaazon: it's just that it's the closest thing to a package manager we have
02:49:19 <bernalex> language/library package managers is a terrible idea anyway.
02:49:31 <phaazon> tdammers: huh?
02:49:37 <tdammers> cabal is a build tool
02:49:53 <bernalex> ... which in turn is a *good* idea for a language to have.
02:50:10 <phaazon> hm
02:50:13 <phaazon> so
02:50:14 <tdammers> it can download packages and resolve dependencies for convenience, but once you have those features, people starts abusing it as a package manager
02:50:18 <phaazon> you're saying we should make a difference
02:50:23 <phaazon> a bit like archlinux makepcg vs. pacman ?
02:50:28 <phaazon> makepkg*
02:50:44 <bernalex> you should install packages on your GNU+Linux distro the same way regardless of whether they are python/haskell/c/whatever.
02:50:57 <bernalex> and for development you should use sandboxed environments.
02:51:09 <phaazon> bernalex: every language now has a package manager
02:51:09 <phaazon> ppm
02:51:11 <phaazon> npm
02:51:14 <phaazon> gems
02:51:15 <bernalex> that's the way it's been in "every" language for "all" time.
02:51:23 <bernalex> phaazon: & they are all terrible terrible terrible.
02:51:28 <phaazon> oh?
02:51:29 <tdammers> ^ .
02:51:33 <tdammers> they are
02:51:36 <bernalex> and make life really annoying when you are a GNU+Linux distro dev...
02:51:55 <liste> ChristianS if you can't find one you can implement one using GenericHandler
02:51:55 <tdammers> but even disregarding distro packaging
02:52:04 <bernalex> yes, even disregarding that it sucks.
02:52:10 <phaazon> yeah but if we would use distro packaging, sandboxing would be a nightmare
02:52:36 <bernalex> why on earth would it?
02:52:48 <bernalex> it's working fine for me, and has worked fine in "every" language for "all" time.
02:52:57 <tdammers> they are all either painful in the cabal way, producing dependency hell all the time, or they are painful in a hand-waiving way where dependency management is kind of like a suggestion, and you end up with silently broken dependencies at one point or another
02:53:02 <ChristianS> liste: i'll check it out, thanks
02:53:04 <phaazon> bernalex: because you wouldn't have uniform ways to sandbox
02:53:15 <bernalex> phaazon: I don't know what you mean by that.
02:53:22 <phaazon> let me explain then
02:53:25 <tdammers> sandboxing can be pluriform
02:53:36 <tdammers> always has been, and probably will be for quite a while
02:53:45 <phaazon> if you have a tool, say, cabal, that only builds
02:53:51 <phaazon> cabal build and cabal sdist, only
02:54:08 <phaazon> you need a way to lookup into a package database when using cabal build
02:54:16 <phaazon> so that ghc can resolve dependencies issues
02:54:22 <phaazon> how would you do that a uniform way?
02:54:36 <bernalex> phaazon: uniform with respect to what?
02:54:48 <phaazon> bernalex: to ghc package databases
02:55:00 <merijn> tdammers: You forgot a third option
02:55:07 <phaazon> I'm not sure I could create sandboxes with pacman from archlinux
02:55:16 <bernalex> phaazon: I would use cabal for sandboxes.
02:55:31 <bernalex> phaazon: so either you misapprehend me, or I do you.
02:55:33 <phaazon> bernalex: alright, but the package manager is your distro's
02:55:36 <merijn> tdammers: "Our dependency management actually works great. What do you mean we handwaved the part where we have thousands of volunteers manually curating and fixing issues?"
02:55:44 <merijn> tdammers: i.e. "but my apt-get always works..."
02:55:58 <bernalex> phaazon: right. what's the problem?
02:56:06 <phaazon> bernalex: how do you put packages in the sandbox then?
02:56:24 <phaazon> what would actualy do cabal sandbox init?
02:56:27 <bernalex> phaazon: with the package manager? I don't really understand the problem.
02:56:34 <phaazon> if cabal is not the package manager
02:56:49 <phaazon> bernalex: then explain me the workflow
02:56:55 <bernalex> phaazon: then the package manager does it. I still don't fully understand the problem. you have APIs and let the tools talk with each other.
02:57:04 <merijn> tdammers: Also, the fourth option of "it works, but everything is so out of date I don't wanna use it"
02:57:10 <bernalex> phaazon: even still, I'm not opposed to cabal doing package manager-like things for sandboxes.
02:57:22 <merijn> tdammers: Typically that's option 3, but without the thousands of volunteers
02:57:35 <phaazon> bernalex: imagine you want to isolate your foor project in a sandbox
02:57:40 * hackagebot notzero 0.0.7 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.0.7 (TonyMorris)
02:57:50 <phaazon> and you need mtl, transformers and say, data-reify 
02:57:53 <bernalex> phaazon: the problem is people start using this to install packages globally, because the ppackage manager-like functionality gets mistook for "oh it is a package manager", when in reality it just happens to offer a subset of the package manager's job in order to do sandboxing.
02:57:59 <phaazon> how do you isolate those version with pacman?
02:58:37 <bernalex> phaazon: I don't know how pacman works. what I would do as a portage developer is implement a way to speak to cabal and resolve this peacefully and nicely.
02:58:53 <phaazon> yeah
02:58:59 <phaazon> conditional statement.
02:59:09 <phaazon> there's no way that would work
02:59:21 <phaazon> that's why we need a package manager for every language
02:59:27 <bernalex> phaazon: why is there no way that would work? it's no problem really.
02:59:44 <phaazon> bernalex: you keep saying there's no problem, but there is
02:59:56 <bernalex> phaazon: I don't see the problem.
03:00:01 <phaazon> you haven't told me yet how you would solve such a situation without cabal being a package manager
03:00:33 <bernalex> phaazon: use a distro's package manager, have cabal ask it for packages and install them in a sandbox.
03:00:44 <bernalex> phaazon: this would be no problem using portage on gentoo.
03:00:57 <tdammers> merijn: point in case
03:00:59 <phaazon> bernalex: archlinux's pacman is used to install package in the global scope, I'm not even sure it supports local installation
03:01:08 <phaazon> ok then
03:01:13 <bernalex> phaazon: well make it suck less I guess
03:01:15 <phaazon> how do you actually « install them in a sandbox »?
03:01:18 <tdammers> 3 and 4 are mostly the same thing though
03:01:38 <bernalex> phaazon: install them to .cabal-sandbox etc just like cabal does now, and register them etc, just like cabal does now.
03:01:49 <phaazon> right, by hand then
03:01:58 <phaazon> and you think you'd get rid of « hell »? :D
03:01:59 <bernalex> phaazon: no, with the pm & cabal.
03:02:16 <bernalex> phaazon: sure. portage is a lot better than cabal at dependency handling.
03:02:26 <phaazon> why so?
03:03:17 <phaazon> the cool thing with hackage is that whatever the OS / distro package manager you use, you are still able to get the packages
03:03:25 <bernalex> phaazon: probably due to the more expressive package language and because more thought went into the 10K+ SLOC dependency resolver of portage than the ad-hoc cabal addon of dependency resolution.
03:03:26 <phaazon> there's a tool for the Haskell developper to work with
03:03:29 <phaazon> without that
03:03:36 <phaazon> it'd would be a bit like « go wild »
03:04:14 <bernalex> phaazon: endusers don't give a toss about cabal or pip or gems. they just want to apt-get this and yum install that, or download random .exe files and pray they're not viruses, or whatever windows users do these days.
03:04:14 <phaazon> how would you deploy your package on several OS at once?
03:04:59 <bernalex> phaazon: I wouldn't. I have never made a program with that need. I've made a program that needed to be deployed on several computers at once. and that's easy. just install the same os.
03:06:09 <phaazon> so you don't use cabal?
03:06:18 <tdammers> cabal for deployment? that's insane
03:06:27 <phaazon> tdammers: hackage*
03:06:52 <bernalex> phaazon: and again, I don't really have that much against using cabal for developing in sandboxes as we do today. as long as people don't tell endusers to install haskell packages with cabal, it's OK. because endusers don't know wtf haskell or cabal is. and when they install a random haskell program with their pm instead of cabal, everything goes to shit because they're mixing the two.
03:07:02 <tdammers> ^ that.
03:07:05 <bernalex> phaazon: sure I use cabal.
03:07:31 <tdammers> except that mixing distro PM and cabal isn't usually a problem at all
03:07:58 <phaazon> so you're maintaining your packages on portage, bernalex?
03:08:00 <bernalex> tdammers: cabal for deployment is fine if you have really rigid bounds that youknow work, I guess. I would do that on small scales if possible to keep it simple. probably in a sandbox.
03:08:56 <bernalex> phaazon: portage is the package manager. if you mean if I put them in the package tree to make them available to endusers, then yes. (well, I put them in the haskell overlay. portage is modular. some of the other guys usually put them in the core tree too though.)
03:08:59 <tdammers> bernalex: yeah, but do you really want something like cabal lingering on your productions server? hell no.
03:09:08 <bernalex> tdammers: if it's there already then -_o_-
03:09:25 <tdammers> I don't even want git on a prod server, let alone a tool that is *designed* to download code and produce binaries from it
03:09:25 <bernalex> tdammers: I'd just distribute a binary
03:09:31 <tdammers> exactly
03:10:05 <tdammers> have one build server for each incompatible deployment target platform, build there, upload with rsync or whatever
03:10:16 <bernalex> tdammers: sure.
03:10:17 <tdammers> wrap it all up in a script, and you're good to go
03:11:01 <tdammers> I mean, having cabal on your server is fine, security wise, but I don't even want to think about it
03:11:22 <bernalex> it's useful to keep production servers minimalistic.
03:11:32 <phaazon> your thoughts about deployment is interesting
03:11:40 <phaazon> I should put my package into the AUR as well
03:11:44 <phaazon> packages*
03:12:18 <bernalex> the way we work on Gentoo is that all *programs* that endusers would be interested in go into the core repo
03:12:34 <tdammers> ofc that doesn't work with a source distro
03:12:39 <phaazon> what about libraries?
03:12:47 <bernalex> tdammers: what doesn't?
03:12:47 <phaazon> I see there's haskell-lens in the AUR
03:13:11 <tdammers> bernalex: deploying without having cabal installed
03:13:30 <tdammers> unless you can somehow package things to not require cabal for building
03:13:31 <bernalex> phaazon: libraries that programs depend on are in the core library. others (i.e. libraries that devs want) are just in the haskell overlay.
03:14:03 <bernalex> tdammers: I'm not sure I see the problem if uploading a binary?
03:14:04 <phaazon> oh, AUR is migrating to git+ssh
03:14:07 <phaazon> that's great!
03:14:22 <tdammers> bernalex: none whatsoever, but in a source distro you wouldn't normally do that, would you?
03:14:50 <mniip> [13:11:56] <bernalex> the way we work on Gentoo is that all *programs* that endusers would be interested in go into the core repo
03:14:51 <bernalex> tdammers: if it's a production server, I would.
03:14:52 <mniip> looking at you, games-misc/doge
03:15:15 <bernalex> mniip: :D
03:17:29 <phaazon> bernalex: you've convinced me
03:17:36 <phaazon> I'm going to write some PKGBUILDs
03:17:37 <phaazon> :)
03:18:06 <bernalex> phaazon: OK. next step is to get you to use Gentoo instead of Arch. ;)
03:19:07 <phaazon> bernalex: nah
03:19:12 <phaazon> archlinux is cool :)
03:19:12 <bernalex> I know people who use arch+haskell fine though, so I guess it has an OK selection of packages.
03:19:26 <phaazon> gentoo is a bit like archlinux anyways
03:20:30 <bernalex> personally, I don't think they're remotely similar
03:20:38 <bernalex> but that's #-blah territory. :)
03:20:51 <xelxebar> I used Gentoo about a decade ago when I was a Linux fanboy.
03:21:31 <xelxebar> Now I use Arch. Feels a lot like Gentoo minus the compiling pain. 
03:21:51 <xelxebar> Anyway, I thought you guys might like this: http://graphicallinearalgebra.net/
03:22:01 <phaazon> oh yeah
03:22:07 <phaazon> gentoo uses source tarball
03:22:09 <phaazon> that's funny
03:22:19 <phaazon> anyways, AUR and abs uses source tarballs as well
03:22:38 <phaazon> but you're right, it's #haskell-blah topic
03:22:40 <xelxebar> Linear algebra can apparently be expressed in terms of something like circuit diagrams.
03:23:00 <xelxebar> This is all made precise with CT using categories called PROPs
03:23:42 <liste> well, pretty often circuit diagrams are turned into matrices for analysis
03:24:14 <liste> u (voltage vector) = Z (impedance matrix) * i (current vector)
03:24:41 <xelxebar> liste: Yeah, the author of that blog formalizes the isomorphism between these particular diagrams and matrices.
03:25:27 <xelxebar> Geader towards the non-mathematician, so I thought some people here might like it.
03:25:41 <xelxebar> geader --> geared*
03:26:25 <xelxebar> Sorry if it's off topic.
03:37:41 * hackagebot engine-io 1.2.7 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.7 (OliverCharles)
03:41:02 <pacak> > let ☭ = 10 in ☭ + 4
03:41:03 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
03:41:06 <pacak> :(
03:42:09 <liste> > let { ☭ = 10 } in { ☭ + 4 }
03:42:10 <lambdabot>  <hint>:1:7: parse error on input ‘☭’
03:42:19 <liste> it's not a letter :(
03:42:36 <liste> maybe it could be an operator symbol?
03:43:33 <liste> > let { ☭ = (+) } in 1 ☭ 2
03:43:35 <lambdabot>  <hint>:1:7: parse error on input ‘☭’
03:43:54 <liste> > let { (☭) = (+) } in 1 ☭ 2
03:43:55 <lambdabot>  3
03:43:59 <liste> yay \o/
03:45:18 <merijn> > generalCategory '☭'
03:45:19 <lambdabot>  OtherSymbol
03:45:28 <merijn> There you go
03:45:46 <merijn> Unicode characters classified as symbols are only allowed in operators
03:47:06 <pacak> :)
03:47:45 * tdammers implements various numeric operators with subtle gotchas, all using some sort of dash, hyphen, or minus character
03:48:16 <liste> that's evil
03:49:05 <merijn> > '-' == '–' || '-' == '—'
03:49:06 <lambdabot>  False
03:49:22 <merijn> tdammers: You forgot about n-dash and m-dash :p
03:49:39 <tdammers> those are also sorts of dash characters
03:49:50 <tdammers> > generalCategory '\8203'
03:49:51 <lambdabot>  Format
03:49:55 <tdammers> shame
03:49:56 <pacak> tdammers: And use all sorts of `a' including א, あ and ア as variables?
03:50:10 <liste> lower-case ones are
03:50:41 <merijn> > generalCategory 'ℕ'
03:50:43 <lambdabot>  UppercaseLetter
03:50:50 <liste> > generalCategory 'あ'
03:50:51 <wei2912> please don't abuse it
03:50:51 <lambdabot>  OtherLetter
03:50:51 <merijn> Whoo, that means it's a valid type :>
03:50:52 <xelxebar> There are also at least 5 different tilde character defined in unicode: https://en.wikipedia.org/wiki/Dash#Swung_dash
03:51:16 <wei2912> oh god, tdammers is going to abuse it
03:51:35 <liste> @let あ = 5 -- can I be considered lowercase?
03:51:35 <lambdabot>  Parse failed: Illegal character ''\12354''
03:51:45 <merijn> @let newtype ℕ = ℕ Integer
03:51:46 <lambdabot>  Defined.
03:51:51 <wei2912> oh god
03:51:52 <wei2912> stop
03:51:57 <tdammers> > generalCategory '\1418'
03:51:58 <lambdabot>  DashPunctuation
03:52:00 <xelxebar> ~˜∼〜～
03:52:04 <wei2912> please don't use unicode in code...
03:52:05 <merijn> :t ℕ 2
03:52:06 <lambdabot> 
03:52:10 <merijn> awww
03:52:15 <merijn> lambdabot messed up
03:52:25 <wei2912> what did you expect? :P
03:52:33 <tdammers> how about unicode in Show?
03:52:34 <xelxebar> no, just giving you the silent treatment for uncesessary abuse
03:52:47 <merijn> wei2912: What I expect? UTF-8 output
03:53:03 <merijn> xelxebar: It's not silently, it printed a revered capital U
03:53:12 <merijn> reverse coloured, I mean
03:53:43 <xelxebar> huh. I see an empty line
03:53:57 <merijn> xelxebar: Then your client/environment is configured wrong :p
03:54:02 <liste> merijn that works in ghci (:
03:54:03 <wei2912> lol
03:54:07 <wei2912> liste: as it should
03:54:09 <merijn> liste: Of course
03:57:43 * hackagebot utc 0.2.0.1 - A pragmatic time and date library.  http://hackage.haskell.org/package/utc-0.2.0.1 (LarsPetersen)
03:58:40 <wei2912> merijn: you don't appear to be in ##programming? :P
04:10:48 <merijn> wei2912: It depends on how bored I am at work :p
04:10:52 <bernalex> so what library is the best to use for lenses when what you really want are to mock first class record fields, and have a way to update a type & also having all functions "updated" directly?
04:11:14 <merijn> wei2912: I'm too busy reading/supervising bachelor thesises today :p
04:11:25 <bernalex> it feels like edwardk's library is way overkill for this... but maybe there's some nice tutorial for it that eschews most of the other stuff in favour of a coherent presentation of how to use lenses.
04:12:00 <merijn> bernalex: The nice thing about edwardk's lenses is that it's possible to define and implement lenses without depending on lens (although if you wanna use all the combinators you have to)
04:12:22 <wei2912> merijn: i see
04:12:33 <wei2912> merijn: have fun reading, i gues
04:12:35 <wei2912> guess*
04:12:55 <merijn> wei2912: It's depressing >.>
04:52:35 <bernalex> can you (easily) have multiple executables in a cabal project?
04:52:59 <Axman6> sure, just make new executable sections
04:53:07 <bernalex> Axman6: which one does e.g. cabal run use?
04:53:21 <Axman6> see https://github.com/kfish/raft/blob/master/raft.cabal for an exmaple
04:53:28 <Axman6> no idea, I've never use cabal run
04:56:12 <obiwahn> irc.server.mozilla.password              string   (undef)
04:56:15 <merijn> bernalex: cabal run takes a name as argument
04:56:23 <obiwahn> oh sorry
04:56:33 <obiwahn> this was meant for weechat
04:56:53 <merijn> bernalex: So if you have foo and bar executables you can just "cabal run foo" and "cabal run bar"
04:57:01 <bernalex> merijn: I assumed so
04:58:46 <maerwald> bernalex: afair it will just say it doesn't know which one to run
04:59:40 <maerwald> cabal: This package contains multiple executables. You must pass the
04:59:40 <maerwald> executable name as the first argument to 'cabal run'.
05:00:10 <maerwald> don't know if there is a way to mark a "default" executable though
05:06:28 <haskell564> hey, need some help.  i am trying to use haskeline key bindings on my mac os x while running ghci 
05:06:51 <haskell564> what is the "meta key" i should use on mac os x?
05:07:00 <haskell564> option key doesn't work
05:08:33 <Axman6> perhaps esc?
05:10:15 <merijn> haskell564: You can configure which key is meta in the config of Terminal.app
05:10:38 <merijn> Under keyboard there is a checkbox "Use option as Meta"
05:10:56 <merijn> Of course that means you won't be able to type unicode characters like ü easily anymore...
05:11:03 <merijn> Otherwise I think it defaults to ESC
05:11:18 <voidzero> for Linux I always recommend the compose key
05:11:34 <voidzero> https://en.wikipedia.org/wiki/Compose_key
05:12:38 <Peaker> merijn: yo, got an update about the bracket drama? :)
05:13:28 <merijn> Peaker: I just started working on that after finishing my last paper :p
05:13:56 <Peaker> merijn: cool :)
05:19:55 <zipper> Hey I want to spawn a thread and have the parent process block and wait for the thread to return before it continues running. However, I don't know how to block the parent process or get the result from the child process. I am using forkIO which gives the TreadId
05:20:02 <zipper> How can I do this?
05:21:10 <mauke}> MVar
05:21:29 <saep> zipper: Why do you use a thread for that in the first place?
05:21:30 <mauke}> but if you want synchronous processing, why spawn a thread in the first place?
05:21:43 <haskell564> merjin -- escape key doesn't work; also tried setting option key as meta key in terminal.app.  that too doesn't work
05:22:07 <zipper> I was thinking of TVar
05:22:16 <zipper> Hmmm I need to think about this more.
05:23:11 <haskell564> sorry, i was replying to  merijn 
05:23:32 <mauke}> try mer<tab> :-)
05:23:49 <haskell564>  merijn : escape key doesn't work; also tried setting option key as meta key in terminal.app.  that too doesn't work
05:25:00 <haskell564> i just need to know what will be meta key on mac os x for ghci command line editing using haskeline
05:28:53 <haskell564> anybody can help on this -- i just need to know what will be meta key on mac os x for ghci command line editing using haskeline
05:30:36 <merijn> I just use the emacs-style ctrl-a, ctrl-e, ctrl-k style commands, I've never head of meta key controls for ghci?
05:32:43 <haskell564> merijn: ctrl-a, ctrl-e, ctrl-k style commands  -- they all work fine
05:33:12 <haskell564> but i was looking for met-key to do stuff like undo etc
05:34:49 <zipper> Hey can someone help with an "IO to STM" issue here: http://lpaste.net/134663
05:35:15 <mauke}> zipper: that code makes no sense
05:35:42 <mauke}> zipper: why are you using a TVar?
05:36:21 <zipper> mauke}: I want to get the result in a TVar
05:36:25 <geekosaur> meta key will be up to your terminal emulator. I don;t have one since I set option for multinational characters
05:36:32 <mauke}> zipper: why?
05:36:39 <geekosaur> (and command for menu keys)
05:37:10 <zipper> mauke}: Heh do you have time for a walkthrough?
05:37:26 <mauke}> is this related to your previous question?
05:39:11 <zipper> mauke}: Yes
05:39:28 <zipper> mauke}: https://gist.github.com/urbanslug/d424d7a1f51cbb7707da#file-watch-hs-L18
05:39:32 <mauke}> then yes, I'd like to hear some details
05:40:20 <zipper> mauke}: Brb
05:40:22 <zipper> Sorry
05:40:26 <zipper> :(
05:40:46 <merijn> zipper: Simple solution, use newTVarIO to create a new TVar instead of newTVar
05:41:02 <merijn> Or use "atomically $ newTVar result", but that's the same thing
05:41:10 <merijn> :t atomically
05:41:11 <lambdabot> Not in scope: ‘atomically’
05:41:14 <Geekingfrog> How can I apply a zip element wise to 2D lists? magicZip? [[1,2],[3,4]] [[1,0],[1,0]] --> [[(1,1), (2,0)], [(3,1), (4,0)]]
05:41:15 <fryguybob> zipper: Do you just want  runBackend >>= newTVarIO?
05:41:15 <merijn> blah
05:42:19 <mauke}> I wonder what 'withManager' does
05:42:27 <mauke}> this code looks a bit too spawn-happy
05:42:43 <tdammers> mauke}: it calls unsafeDelayProject internally
05:43:35 <mauke}> line 21 sleeps forever, and line 18 keeps looping
05:44:20 <mauke}> > zipWith zip [[1,2],[3,4]] [[1,0],[1,0]]
05:44:21 <lambdabot>  [[(1,1),(2,0)],[(3,1),(4,0)]]
05:44:25 <haskell564> geekosaur: do you know what will the default meta key on mac os x?  esc doesn't seem to work, and option doesn't work either.
05:44:44 <geekosaur> as I already said, check the properties in your terminal
05:44:53 <Geekingfrog> mauke}, \o/
05:44:54 <haskell564> i am just trying out the haskeline key bindings while using ghci
05:44:56 <geekosaur> ghci runs in a terminal; it uses what the terminal gives it
05:45:06 <geekosaur> it doesn't get to say what option and command do
05:46:31 <geekosaur> and what the terminal does depends on which one it is; I use iTerm2, if you;re using Apple's Terminal then the behavior depends on which OS X version (I'm told it changed in 10.10; I'm still on 10.9)
05:47:15 <haskell564> well, on the terminal, when not using ghci, esc key works fine as the default meta key.  but when running ghci, esc no longer works as a meta key 
05:47:31 <geekosaur> that's because haskeline is buggy, :/
05:47:51 <geekosaur> esc doesn't work anywhere unless you're *really* fast
05:47:58 <haskell564> i am running os x yosemite
05:48:14 <haskell564> version 10.10.3
05:49:06 <haskell564> i see -- so haskeline is bug, but ghci still uses haskeline?
05:50:04 <geekosaur> yes, because readline support is annoyingly difficult on OS X
05:50:13 <geekosaur> (because apple ships a "readline" that isn't)
05:50:44 <Luke> geekosaur: what about the home brew readline?
05:50:46 <geekosaur> bash works because it uses a built-in readline
05:51:01 <haskell564> geekosaur: i see.  also, i noticed stuff like undo -- ctrl _  doesn't work either in ghci
05:51:12 <geekosaur> that one will work if you can convince ghci to build against it
05:51:45 * tdammers wonders how it is possible that after decades of development, we still don't have a canonical readline implementation that just works
05:52:19 <haskell564> geekosaur: home brew deadline -- i haven't explored it a lot
05:52:48 * hackagebot GiveYouAHead 0.2.2.0 - to auto-do somethings  http://hackage.haskell.org/package/GiveYouAHead-0.2.2.0 (Qinka)
05:53:23 <geekosaur> tdammers, because of organizations that won't touch gpl3 with a ten foot pole?
05:54:06 <haskell564> geekosaur: you say i can make undo -- ctrl _ work in ghci?  right now, i couldn't make it work.
05:54:12 <geekosaur> although it doesn't help that apple renamed bsd's editline to readline, which mostly has the result of breaking everything :/
05:54:49 <geekosaur> haskell564, that must be something about apple terminal; it works in iterm2
05:55:12 <haskell564> geekosaur: okay.
05:55:20 <geekosaur> mostly I find apple's terminal annoying enoiugh that iterm2 is one of the first things I install
05:55:49 <geekosaur> terminal mode is very much a second class citizen as far as apple is concerned
05:56:42 <haskell564> geekosaur: thanks for your help.  it so frustrating to deal with all this quagmire even to do line editing.
05:57:26 <tdammers> geekosaur: yeah, sure, but we have a bunch of perfectly fine libraries for almost anything else
05:57:48 * hackagebot gyah-bin 0.2.2.0 - A binary version of GiveYouAHead  http://hackage.haskell.org/package/gyah-bin-0.2.2.0 (Qinka)
05:57:50 <haskell564> geekosaur: i should install iterm2 as well, i suppose
05:59:29 <merijn> geekosaur: Really? I rather like Terminal.app, what is it you find lacking?
05:59:55 <haskell564> geekosaur: in iterm2 the meta-key stuff works fine once you set it up when using ghci?
05:59:56 <geekosaur> haskeline would be fine if they'd just fix the esc key handling, several of us have explained the problem to them
06:00:26 <geekosaur> if you mean esc for meta, no; as I said, that doesn't work right anywhere because of bugs
06:00:43 <geekosaur> if you configure iterm2 to use option or command as meta then option-whatever or cmd-whatever should work
06:01:10 <haskell564> geekosaur: thanks.  i hope they fix this stuff in haskeline soon.  thanks a bunch.
06:02:48 <aphorisme> Hello! Is there a package or something for fast (de-)serializing a simple record (data R = { a :: ByteString, b :: ByteString }) into a ByteString? I was trying to serialize it into a json, but aeson works on Text
06:03:22 <mauke}> encode text as utf-8, done
06:03:27 <Itkovian> aphorisme You could switch between ByteString and Text?
06:03:53 <aphorisme> yeh, but then I have to encode the Text every query.
06:04:08 <aphorisme> ah, I have to give more context
06:04:20 <Axman6> Data.Binary? that's exactly what it's for
06:04:41 <mauke}> \(R a b) -> encode (a, b)
06:05:50 <aphorisme> Actually I want to implement a Triple-Store, based on a Key-Value Store. This means that I need to look up a value (in the key-value store), parse that value to retrieve another key and look up again and so on.
06:06:47 <mauke}> heck, instance Binary R where put (R a b) = put (a, b); get = fmap (\(a, b) -> R a b) get
06:07:10 <Axman6> surely that can also be derived automatically
06:07:46 <aphorisme> thanks  : )
06:07:49 * hackagebot iCalendar 0.4.0.3 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.4.0.3 (ChristianRoedliAmble)
06:09:33 <kzisme_> \o
06:13:39 <bernalex> what's the go-to gtk3 lib, if any? or is qt/wx/whatever better supported? what should I use?
06:13:46 <lamefun> Is there a record export that exports the accessor functions but not the constructors?
06:14:57 <bernalex> maybe I should use threepenny
06:15:21 <dramforever> bernalex: gui is hard. period.
06:16:05 * dramforever has never succeed in installing *any* haskell gui framework
06:16:35 <hodapp> I'll be interested to see what agocorona comes up with, as far as GUI stuff
06:16:36 <geekosaur> lamefun, you can export the accessors manually. there's no convenient shorthand for just the accessors without the constructirs
06:17:36 <bernalex> dramforever: that's not a very good answer.
06:18:01 <dramforever> bernalex: well, I guess I blew that answer
06:18:22 * dramforever has tried gtk *and* qt *and* wx
06:18:33 <geekosaur> bernalex, gtk2hs if you can get it to install (gtk3 moves fast and ghc moves fast too...)
06:18:47 <dramforever> but all failed on installation
06:19:00 <geekosaur> installing it from git may work better esp. with ghc 7.10
06:19:01 <bernalex> geekosaur: currently looking at fudgets, grapefruit, phooey & threepenny. might use one of those.
06:19:07 <Cale> Somehow none of them worked? At least gtk2hs and wx were pretty easy to install from hackage last time I tried it...
06:19:12 <geekosaur> haskell's gui story is not very good
06:19:20 <Cale> Haven't really tried qt ever
06:19:25 <bernalex> Cale: same for me.
06:19:31 <geekosaur> which is why the platform ships opengl as a gui library
06:19:31 <maerwald> bernalex: the GTK bindings are horrible and the whole gtk concept heavily relies on globally accessible configuration that you have to either use heavy reification or unsafeperformIO... as in, you often cannot really query the state of widgets, but have to save them yourself. A few exceptions there only
06:19:39 <dramforever> Cale: well, lemme give you the log
06:19:51 <Cale> dramforever: Do you have gtk2hs-buildtools installed?
06:19:55 <dramforever> yep
06:20:13 <bernalex> maerwald: yeah which is why I'm looking at more high-level stuff.
06:20:22 <bernalex> ok so fudgets is from the early '90s, so maybe not
06:20:32 <dramforever>   >>> Lexical error!
06:20:32 <dramforever>   The character '#' does not fit here.
06:20:50 <dramforever> oh oh oh oh wait wait
06:20:57 <dramforever> I think I found a solution
06:21:00 <dramforever> never mind...
06:21:01 <geekosaur> that soubnds like gtk2hsc2hs having trouble with the gtk3 headers, sigh
06:21:13 <Cale> That sounds like MagicHash was disabled, but it ought to have been enabled?
06:21:17 <dramforever> locale problem
06:21:20 <Cale> oh
06:21:33 <dramforever> looks like a bug, though
06:22:01 * dramforever wonders why locale matters
06:22:03 <Cale> (yeah, if that's the actual error message verbatim, I don't know what tool produces that message)
06:22:18 <dramforever> Cale: wait...lemme post the log
06:22:21 <geekosaur> I know gtk2hsc2hs is problematic on os x because apple has their blocks extension in all the libc headers on 10.8+
06:22:57 <dramforever> lpaste is very slow here, for some reason
06:23:06 <jerv> I have a function that needs Data.ByteString.Lazy.Internal.ByteString but I have Text. encodeUtf family of functions has signature Text -> ByteString but this ByteString is Data.ByteString.Internal.ByteString.
06:23:08 <lpaste> dramforever pasted “cabal install gtk failed” at http://lpaste.net/134665
06:23:14 <dramforever> there you go
06:23:16 <geekosaur> it's all ifdefed but sometimes c2hs doesn't get the ifdefs right for some reason
06:23:20 <jerv> Anyway to go Text -> Data.ByteString.Lazy.Internal.ByteString or Data.ByteString.Internal.ByteString -> Data.ByteString.Lazy.Internal.ByteString ?
06:24:41 <mauke}> jerv: basically you're stumbling over the difference between strict and lazy ByteStrings
06:24:57 <geekosaur> urgh. yep it's gtk2hsc2hs, and what a useless error message that is :/
06:25:13 <dramforever> geekosaur: exactly
06:25:35 <mauke}> jerv: Data.ByteString.Lazy provides fromStrict
06:25:43 <dramforever> I think the only backend for grapefruit for now is gtk
06:25:45 <dramforever> so I need it
06:28:53 <dramforever> Arrrrrrrgh FTP
06:29:55 <lpaste> dramforever pasted “grapefruit failed” at http://lpaste.net/134666
06:30:25 <bernalex> are there any threepenny tutorials? I only found random examples
06:30:31 <bernalex> sorted alphabetically lol
06:30:48 <tdammers> neat
06:31:14 <bernalex> I'll check out ollie's 24d of hackage thing I guess
06:31:57 <dramforever> I think if ekmett could spare 1/100 of his time working on lens to create a GUI lib, we would all be GUI programming happily
06:32:30 <dramforever> I don't know why I thought of him
06:33:12 <pacak> dramforever: Not sure. 
06:33:29 <dramforever> pacak: well, maybe 1/100 is too little time
06:33:44 <pacak> dramforever: GUI is much more messy.
06:33:54 <dramforever> umm....lens based GUI lib？
06:33:56 <dramforever> ?
06:34:06 <pacak> Based on gtk?
06:35:05 <hamishmack> dramforever: lpaste the output of cabal install -v3 cairo
06:35:25 <byorgey> dramforever: ekmett doesn't even work on lens any more, he has moved on to lots of other things =)
06:35:38 <dramforever> yeah
06:35:55 <dramforever> not very much more to work on
06:35:57 <edwardk> i occasionally dust off lens and put some polish on it =)
06:36:05 <edwardk> but its mostly to splinter off small things
06:36:11 <dramforever> :)
06:36:28 <maerwald> +1 for edwardk programming a GUI framework :P
06:36:33 <bernalex> edwardk: what gui library should I use?
06:36:33 <dramforever> hamishmack: "All the requested packages are already installed:"
06:36:35 <edwardk> the core of lens has been remarkably stable for a couple of years now
06:36:36 <bernalex> edwardk: can you make me one?
06:36:38 <dramforever> do you still want it?
06:36:49 <hamishmack> oh so it worked in the end?
06:37:01 <dramforever> hamishmack: yep, locale proble
06:37:02 <bernalex> I'd like something like elm but uh not on the Web.
06:37:04 <dramforever> *problem
06:37:20 <hamishmack> cool
06:37:20 <maerwald> bernalex: maybe we can steal their ideas
06:37:45 <edwardk> bernalex: a gui is just uh... a left kan extension of the widgets along the effects you want them to have. are you _sure_ you want to have to think that way?
06:37:55 <dramforever> to me, lens is a huge bunch of profunctors
06:37:57 <bernalex> maerwald: maybe. some of the graphics stuff is very nice. and when I'm programming in elm I'm frustrated by the lack of typeclasses etc.
06:38:22 <edwardk> dramforever: thats what lens turned into, sure. its 'hey look, we have these ideas, oh wait, profunctors, oh, they capture all those ideas, great!'
06:38:24 <bernalex> edwardk: I want to have pretty buttons that people who are afraid of computers can push to make things happen.
06:38:27 <Peaker> Enum class is so broken :(  And not only that, but Integral has it as a super-class! Making it impossible to make sane Integral instances for stuff
06:38:44 <Peaker> Why would Integral have Enum as a super-class?
06:38:49 <pacak> edwardk: You know, actually it would be nice to have a different approach to gui and other stuff. Like left-kan-estension different.
06:38:50 <edwardk> Peaker: Integral makes me sad
06:39:05 <Peaker> edwardk: because it brings Enum awfulness?
06:39:32 <edwardk> pacak: https://www.youtube.com/watch?v=rtfbQJGQj0Q <- is gershom talking about what we do for ermine in terms of gui development
06:39:34 <Peaker> Enum could be named IntLike, making it clearer that it's useless
06:40:09 <mauke}> instance IntLike Double
06:40:27 <ion> edwardk: Thanks for the link
06:40:30 <Peaker> mauke}: :-)
06:40:34 <pacak> edwardk: Will have a look tomorrow, thanks :)
06:40:49 <mauke}> > toEnum 0 :: Complex Double
06:40:51 <lambdabot>      No instance for (Enum (Complex Double))
06:40:51 <lambdabot>        arising from a use of ‘toEnum’
06:40:51 <lambdabot>      In the expression: toEnum 0 :: Complex Double
06:40:53 <dramforever> "Oberon has a text user interface (TUI), which has to be differentiated from the terminal user interface."
06:40:55 <Peaker> > toEnum 5 :: Double
06:40:57 <lambdabot>  5.0
06:40:59 <dramforever> -- https://en.wikipedia.org/wiki/Oberon_%28operating_system%29
06:41:15 <Peaker> > succ 5.1 :: Double 
06:41:16 <lambdabot>  6.1
06:41:17 * dramforever thinks that a TUI might be great
06:41:41 <dramforever> [1.1, 2.1 .. 2.8]
06:41:50 <dramforever> > [1.1, 2.1 .. 2.8]
06:41:51 <lambdabot>  [1.1,2.1,3.1]
06:42:01 <dramforever> :) broken enum
06:42:06 <maerwald> uuh, wow
06:42:18 <dramforever> I think it's explained somewhere
06:43:26 <KaneTW> @src Double
06:43:26 <lambdabot> data Double = D# Double#
06:43:40 <KaneTW> hm i can't get lambdabot to print the instance can i
06:43:42 <ion> > takeWhile (\x -> abs (x - 2.8) < (2.1 - 1.1)/2) [1.1, 2.1 ..]  -- or something along those lines
06:43:43 <lambdabot>  []
06:43:46 <ion> uh
06:44:00 <ion> > takeWhile (\x -> abs (x - 2.8) > (2.1 - 1.1)/2) [1.1, 2.1 ..]  -- or something along those lines
06:44:02 <lambdabot>  [1.1,2.1]
06:44:17 <dramforever> sadly, no
06:44:44 <KaneTW> The @Enum@ instances for Floats and Doubles are slightly unusual. The @toEnum@ function truncates numbers to Int
06:44:54 <dramforever> I remember it's something to prevent [1.1, 2.1 ... 3.0999999999999999999]
06:45:02 <dramforever> from failing
06:45:46 <KaneTW> @src numericEnumFromThenTo
06:45:46 <lambdabot> Source not found. My pet ferret can type better than you!
06:48:57 <Serpentine_> lambdabot owns a parrot?
06:49:12 <Serpentine_> That explains his constant parroting.
06:49:36 <KaneTW> @let ef e1 e2 e3 = let mid = (e2-e1)/2; p = if e2 >= e1 then (<= e3 + mid) else (>= e3 + mid) in takeWhile p (ee e1 e2)
06:49:37 <lambdabot>  .L.hs:153:23:
06:49:37 <lambdabot>      Not in scope: ‘ee’
06:49:37 <lambdabot>      Perhaps you meant one of these:
06:50:25 <KaneTW> @let ee n m = n : ee m (m+m-n)
06:50:29 <lambdabot>  Defined.
06:50:31 <KaneTW> @let ef e1 e2 e3 = let mid = (e2-e1)/2; p = if e2 >= e1 then (<= e3 + mid) else (>= e3 + mid) in takeWhile p (ee e1 e2)
06:50:32 <lambdabot>  Defined.
06:50:49 <KaneTW> > ef 1.1 2.1 2.8
06:50:50 <lambdabot>  [1.1,2.1,3.1]
06:51:14 <KaneTW> ee is numericEnumFromThen, ef is numericEnumFromThenTo
06:52:04 <LambdaCat> @let ef = 1 + 1
06:52:05 <lambdabot>  .L.hs:152:1:
06:52:05 <lambdabot>      Multiple declarations of ‘ef’
06:52:05 <lambdabot>      Declared at: .L.hs:147:1
06:52:22 <LambdaCat> 1 + 1
06:52:42 <LambdaCat> let e = 1 + 1
06:52:52 <LambdaCat> @let x  = 1 + 1
06:52:54 <lambdabot>  Defined.
06:52:58 <LambdaCat> @x
06:52:58 <lambdabot> Maybe you meant: v @ ? .
06:53:13 <LambdaCat> @printf x
06:53:13 <lambdabot> x
06:53:19 <frerich> Please note that you can also tinker with lambdabot in a /query or via /msg .
06:53:41 <LambdaCat> @help
06:53:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:53:47 <LambdaCat> list
06:54:51 <benzrf> hmmmmmm
06:54:52 <mauke}> @undefine
06:54:52 <lambdabot> Undefined.
06:59:41 <albeit> If I want to sum three Maybe Ints, and if any are Nothing then Nothing, how can I do it?
07:00:48 <ion> liftA2 (\a b c -> a+b+c)
07:00:52 <ion> liftA3 (\a b c -> a+b+c) that is
07:01:35 <albeit> Ah simple enough. "sum <$> sequence nums" would work too ya?
07:02:37 <aphorisme> @sum <$> sequence [Just 3, Just 4]
07:02:37 <lambdabot> Maybe you meant: src run bug
07:04:04 <aphorisme> @fmap sum $ sequence [Just 3, Just 4]
07:04:05 <lambdabot> Maybe you meant: slap faq
07:04:14 <aphorisme> that should work.
07:04:32 <crocket> Do haskell apps return memory to OS often?
07:04:38 <crocket> JVM almost never does.
07:05:08 <Taneb> aphorisme, you want to use the @eval command or >
07:05:19 <Taneb> > sum <$> sequence [Just 3, Just 4]
07:05:20 <lambdabot>  Just 7
07:05:28 <aphorisme> ! Ah. Thanks, Taneb.
07:06:45 <ion> crocket: Values bound to names that go out of scope should be GC'd.
07:07:07 <ion> Not immediately, but soon
07:07:42 <geekosaur> I think they want to know if ghc ever munmap()s part of its memory arena
07:08:04 <geekosaur> (as far as I know, it doesn't)
07:08:33 <crocket> ion, JVM almost never returns free heap to OS
07:08:44 <crocket> I'm not sure if haskell does the same thing.
07:08:55 <ion> geekosaur: Huh, ok.
07:09:32 <bernalex> there seems to be a million FRP-GUI libraries. are any of them alive? which ones are mature and usable?
07:09:40 <crocket> On JVM, unused memory is not returned to OS.
07:09:43 <geekosaur> garbage collected languages tend to not unmap pages because there's no good way to predict when that leads to page thrashing (i.e. constantly unmapping and remapping pages because of memory usage "right on the edge")
07:10:38 <ion> Would hysteresis help?
07:10:50 <geekosaur> also because freeing pages likely requires doing larger gc passes more often to compact the heap
07:11:28 <crocket> Does it mean haskell programs also don't release free memory to OS until they quit?
07:11:42 <dramforever> crocket: doesn't seem so
07:12:03 <geekosaur> note, I am just guessing here but just thinking generically about gc-based runtimes it's a Hard Problem
07:12:32 <geekosaur> and you'd be paying a significant performance penalty
07:14:09 <crocket> Does it mean GCed languages may not suit desktop GUI applications?
07:14:22 <crocket> Python tends to use little memory...
07:14:49 <crocket> Not sure how little haskell consumes memory in desktop GUI apps.
07:16:04 <geekosaur> sounds like you haven't been following the rest of the chatter in here... gui has other issues with haskell (mostly because of the severe impedance mismatch where most gui toolkits assume massive amounts of global mutable state)
07:17:31 <crocket> Does it means someone needs to build a GUI toolkit for functional programming languages?
07:18:14 <mauke}> C applications rarely return memory either
07:19:27 <geekosaur> there is ongoing work on functional reactive programming; unfortunately the reality is that most platform gui toolkits still assume unrestricted access to global state :/
07:19:30 <crocket> That depends on individual applications.
07:19:43 <geekosaur> which means the best frp toolkit to date runs only in browsers (threepenny-gui)
07:20:23 <crocket> Does haskell have a decent FRP GUI toolkit?
07:28:38 <swish_> Guys, I have a question: Having a monad stack `ContT a (StateT s IO) r` and some function `StateT s IO a -> IO a`, how can I run the StateT inside of ContT using this function? In other words I need `ContT a (StateT s IO) r -> ContT a IO r`
07:30:09 <benzrf> swish_: some sort of monda morphism, no doubt
07:30:12 <benzrf> *monad
07:30:18 <merijn> mmorph library
07:30:24 <merijn> @hackage mmorph
07:30:25 <lambdabot> http://hackage.haskell.org/package/mmorph
07:30:28 <merijn> If it's possible, anyway
07:30:41 <benzrf> swish_: why do you want to do this, though?
07:30:52 <swish_> Ok, I'll look it up, thanks
07:31:02 <benzrf> aren't you already using `ContT a (StateT s IO) r' as your stack?
07:32:22 <swish_> I need function than should not know anything about state, it just evaluates it and leaves a continuation
07:37:46 <swish_> Actually, maybe you right. I just abstract the stack, so user would know nothing about the state. It's even better
07:45:01 <ttk> anyone aware of fpcomplete haskell school? Is it good?
07:45:37 <bergmark> ttk: do you mean content wise? anyone can write tutorials so the quality varies a lot
07:46:00 <ttk> yes content and exercise wise bergmark
07:49:22 <nullx002> hi
07:49:46 <nullx002> why reverse function converts all list elements to float from init if one of the element is floating point
07:50:06 <nullx002> reverse [5,4,3,2,1]
07:50:06 <lspitzner> @tell kadoban you could get a better error message by using `-j1`. the underlying problem was that cabal-install-1.22.5.0 is broken. (https://github.com/haskell/cabal/issues/2658). reportedly fixed now.
07:50:06 <lambdabot> Consider it noted.
07:50:11 <merijn> nullx002: It is impossible to have "one element" be floating point
07:50:17 <merijn> nullx002: Either they all are, or none are
07:50:21 <nullx002> ok but reverse [5,4,3,2,1]
07:50:28 <merijn> > reverse [5,4,3,2,1]
07:50:30 <lambdabot>  [1,2,3,4,5]
07:50:32 <nullx002> reverse [5,4,3,2,1]
07:50:34 <merijn> :t reverse [5,4,3,2,1]
07:50:35 <lambdabot> Num a => [a]
07:51:01 <nullx002> reverse [5.1,4,3,2,1] gives [1.0,2.0,3.0,4.0,5.1]
07:51:29 <keko_> your issue has nothing to do with reverse
07:51:39 <keko_> :t [1,2,3]
07:51:40 <lambdabot> Num t => [t]
07:51:41 <maerwald> > reverse [1, 2, 3, 5.0]
07:51:42 <lambdabot>  [5.0,3.0,2.0,1.0]
07:51:44 <keko_> :t [1,2.0,3]
07:51:45 <lambdabot> Fractional t => [t]
07:52:05 <keko_> it's just that all elements of a list must be of the same type
07:52:05 <ronh-> :t 1
07:52:06 <lambdabot> Num a => a
07:52:07 <nullx002> so why does that happen?"
07:52:26 <keko_> and if you make one element in a list a float, all of them have to be floats
07:52:33 <nullx002> all elements of the input list had different type there...
07:52:37 <geekosaur> no
07:52:41 <geekosaur> they all had the same type
07:52:53 <geekosaur> but that type is inferred because numeric literals are polymorphic
07:52:54 * hackagebot data-fin-simple 0.1.0.0 - Simple integral finite set  http://hackage.haskell.org/package/data-fin-simple-0.1.0.0 (seagull)
07:52:55 <ronh-> 1 is Num a => a, not an Int.
07:53:09 <geekosaur> so the existeince of one value that had to be Double forced all the others to be typed as Double
07:53:26 <geekosaur> because all elements of a list must be the same type
07:53:45 <keko_> :t (1, 1.0, 1 :: Int)
07:53:46 <lambdabot> (Fractional t1, Num t) => (t, t1, Int)
07:53:53 <nullx002> what polymorphic means exactly?
07:55:20 <geekosaur> it is compatible with whatever type its context (the list, in this case) requires
07:56:13 <ion> nullx002: A type with an explicit or implicit “forall” in the beginning.
07:56:31 <ion> more or less
07:56:42 <nullx002> ok
07:56:54 <ion> (forall a. (a ~ Int) => a would be a counterexample)
07:57:19 <maerwald> @type [foldl, foldl', foldr]
07:57:20 <lambdabot> Foldable t => [(b -> b -> b) -> b -> t b -> b]
07:57:30 <maerwald> nullx002: an "a" can also be a function
07:57:55 * hackagebot ghc-simple 0.1.2.1 - Simplified interface to the GHC API.  http://hackage.haskell.org/package/ghc-simple-0.1.2.1 (AntonEkblad)
07:58:22 <maerwald> so [a] doesn't say "this is either an Int, or a Char or so"... it's way more general
07:58:56 <ion> If you as the user of a value get to affect a part of its type, the value is polymorphic.
08:00:04 <ion> > let x = 5 in (x :: Integer, x :: Complex Double)
08:00:05 <lambdabot>  (5,5.0 :+ 0.0)
08:00:25 <ion> > let x = pure 'x' in (x :: Maybe Char, x :: [Char])
08:00:27 <lambdabot>  (Just 'x',"x")
08:01:22 <ion> > let x = length in (x (Just 'x'), x ['x'])
08:01:23 <Peaker> Hey, I have a background thread that computes some big data structure for periodic consumption by my main thread
08:01:24 <lambdabot>  (1,1)
08:01:37 <Peaker> But, instead of creating a data structure, it's creating lazy thunks somewhere in there
08:01:42 <Peaker> moving work unexpectedly to the main thread :-(
08:01:57 <Peaker> What's a good way to debug where it is hiding the work?
08:01:58 <Peaker> (the thunks)
08:09:16 <japesinator> I'm having a weird issue where I can only use ANN pragmas when OverloadedStrings is off
08:09:31 <japesinator> I would like to have both an ANN and OverloadedStrings
08:09:47 <japesinator> but when I try that I get "Main.hs|13 col 16 error| No instance for (Data.String.IsString a0)
08:09:55 <japesinator> ||   arising from the literal ‘"HLint: ignore Use camelCase"’
08:09:58 <japesinator> "
08:11:24 <geekosaur> you need to wrap the annotation in parentheses and include a type annotation
08:11:49 <geekosaur> {-# ANN module ("HLint: ignore Use camelCase" :: String) #-}
08:11:53 <geekosaur> oor something like that
08:11:57 <japesinator> oh thanks!
08:12:31 <breadmonster> What's the difference between parsec and alex+happy?
08:12:31 <breadmonster> Pros and cons, someone?
08:13:38 <Peaker> breadmonster: parsec is really really slow.  alex and happy are external DSLs so annoying to use
08:16:30 <breadmonster> Peaker: parsec is slow enough to not be of use in a compiler?
08:16:44 <breadmonster> I've found it okay-ish to use, but I've never run it against anything really serious.
08:16:57 <bitemyapp> breadmonster: it's fine in a compiler, but you can use http://hackage.haskell.org/package/parsers to abstract out which actual parser you use
08:17:15 <breadmonster> bitemyapp: Can you use that with Happy too?
08:17:29 <bitemyapp> no, it's for parser combinator libraries.
08:17:47 <Peaker> breadmonster: I use parsec to parse Makefile-like files. It takes ~10 sec on our puny 60K makefile
08:18:02 <Peaker> 6KB/sec :-P
08:18:06 <breadmonster> Peaker: What exactly are you building with a 60k makefile?
08:18:17 <Peaker> breadmonster: a C project
08:18:23 <breadmonster> Oh 60kB, not 60k LOC.
08:18:44 <bitemyapp> Peaker: that's pretty bad even for Parsec though.
08:19:08 <Peaker> oh actually the 60k has lots of repetitions because it supports includes
08:19:14 <breadmonster> Peaker: Are you using try a lot?
08:19:19 <Peaker> (same file included many times)
08:19:32 <breadmonster> Or something to that effect?
08:19:41 <bitemyapp> breadmonster: 5,000-10,000x differences between Attoparsec and Parsec aren't uncommon.
08:19:56 <Peaker> I use try somewhat, not sure what a "lot" would be :)
08:19:59 <bitemyapp> I don't know how Trifecta compares but it gets used in a DTPL where parsing is not your biggest problem.
08:20:22 <Peaker> I want an CFG/Applicative parser lib that compiles the parser AOT to an efficient state machine
08:20:22 <breadmonster> I don't know how to use Alex to tokenize with state.
08:20:26 <Peaker> instead of a Monadic parser
08:20:37 <breadmonster> Like I'm parsing a whitespace sensitive language.
08:20:40 <Peaker> uu-parsinglib is supposed to be that, I ought to try that
08:20:52 <breadmonster> Peaker: AOT?
08:20:55 <Peaker> Ahead-of-time
08:21:12 <bitemyapp> breadmonster: it means it generates (and optimizes?) the state machine before the parsing occurs.
08:21:19 <bitemyapp> kind of like...a parser generator.
08:21:27 <breadmonster> Oh okay.
08:21:40 <bitemyapp> breadmonster: I don't like using parser generators, so I mostly use attoparsec.
08:21:47 <breadmonster> bitemyapp: Do you have any alex experience?
08:21:53 <bitemyapp> which reminds me
08:22:02 <breadmonster> Wait, parsec isn't a parser generator right?
08:22:03 <bitemyapp> breadmonster: no, because I don't like parser generators.
08:22:13 <bitemyapp> parsec is a parser combinator library.
08:22:46 <bitemyapp> you're composing parsers to make one big parser and then running it against your stream.
08:23:01 <Peaker> I don't understand why everyone loves monadic parsers so much -- monadic power is almost never needed, and it's costly!
08:23:26 <Peaker> Can't tell if the parser is broken/ambiguous ahead of time
08:23:34 <mniip> Peaker, because
08:23:37 <Peaker> Less efficient, too
08:23:40 <mniip> do-notation makes it kinda fancy
08:23:53 <Peaker> don't we have Applicative-do notation now? :)
08:24:01 <bitemyapp> Peaker: context sensitivity is fun tho
08:24:03 <nshepperd_> it's nice to compose things
08:24:08 <bitemyapp> it's nice to be nice.
08:24:13 <Peaker> bitemyapp: defer it to a post-process
08:24:23 <bitemyapp> Peaker: I agree with you, I just think it's fun :)
08:24:30 <mniip> Peaker, huh
08:24:39 <johnw> Peaker: monadic is really only "needed" if the parser's behavior needs to vary based on what it has seen during parsing; i.e., not context-free
08:24:51 <Peaker> johnw: yeah, but everyone is using monadic parsers for CFGs!
08:24:58 <mniip> :t \x -> do { a <- x; pure a }
08:24:59 <lambdabot> Monad m => m b -> m b
08:25:01 <johnw> I can't imagine a C++ parser ever being anything but monadic, for example
08:25:05 <Peaker> johnw: most grammars being parsed either are CFG or can be divided into a CFG layer with sensitivity on top
08:26:09 * badmash
08:27:49 <tonyd256> has anyone tried to use docker with a haskell project yet?
08:28:15 <breadmonster> Peaker: Where did you pick up this theory of languages...I'm lost.
08:28:41 <Peaker> breadmonster: the layers part is confusing?
08:28:46 <tonyd256> having issues with sandboxes … is there a way to have sandboxes in a separate folder
08:28:51 <Peaker> breadmonster: or CFG/Context-sensitive?
08:28:55 <johnw> tonyd256: with cabal?  sure
08:29:00 <breadmonster> Yeah the layers part.
08:29:37 <tonyd256> johnw: how does one do that? I tried so many things but nothing worked
08:30:00 <johnw> tonyd256: there is a command-line option to specify the location of the sandbox you want to work with
08:30:07 <Peaker> breadmonster: C is context-sensitive because if you have: "x (y);"   it may be "declare y of type x" or "call x with y as param".   You can have a CFG layer parse it to some ambiguous form, and then do a post-process that disambiguates according to whether "x" is known to be a type
08:30:10 <johnw> I don't use cabal, so I don't know it off the top of my head
08:30:48 <tonyd256> I was using that option but it kept telling me it couldn’t find the sandbox config (and it was referencing the wrong path)
08:30:56 <Peaker> breadmonster: in GHC, the CFG parse stage parses infix operator applications into a sequence. Later, a disambiguation phase uses fixity information to parse that
08:31:29 <Peaker> breadmonster: doing a CFG phase first, that creates a result with ambiguity inside it, and then resolving the ambiguity via context sensitivity lets you do most of the parsing work with a CFG which is more efficient
08:31:55 <tonyd256> I’m using yesod so the command was: cabal —sandbox-config-file=/opt/sandbox/cabal.sandbox.config exec yesod devel
08:32:01 <tonyd256> that didn’t seem to work
08:35:15 <breadmonster> Peaker: Oh I get you now.
08:35:20 <breadmonster> Do you know how to use alex, btw?
08:35:45 <Peaker> I haven't used it, but copying&changing an example is probably easy? :)
08:36:35 <breadmonster> bbl guys
08:37:21 <devm> hey can anyone tell me why when I put the input nextLetter ' ' 3 here it gives something that is not a space again? http://pastebin.com/yW19FuCp
08:38:42 <hexagoxel> tonyd256: you want to execute `yesod devel` that can read from the sandbox db?
08:38:46 <monochrom> nextLetter ' ' 3 = succ (nextLetter ' ' (2-1))
08:39:01 <monochrom> err
08:39:08 <monochrom> nextLetter ' ' 3 = succ (nextLetter ' ' 2)
08:39:26 <tonyd256> ya I want to execute that but have it look at a sandbox in a different folder
08:39:34 <monochrom> = succ (succ (nextLetter ' ' 1))
08:39:44 <tonyd256> hexagoxel: ^^
08:39:44 <monochrom> = succ (succ (' '))
08:40:06 <monochrom> therefore, in fact, I don't see why you expect a space
08:40:34 <monochrom> when intuition differs from reality, intuition is wrong.
08:40:44 <johnw> monochrom: :)
08:41:11 <devm> alright yea :p
08:41:16 <monochrom> (there is a stronger one. when intuition differs from cold logical calculations...)
08:42:10 <monochrom> (actually it is not stronger. I can implement a computer checker for cold logical calculation. then the checker is part of reality.)
08:42:28 <mniip> is reality a part of the cold logical calculator
08:42:45 <monochrom> I don't know. I think yes. but I have no evidence.
08:42:46 <hexagoxel> tonyd256: what is the error?
08:42:49 <johnw> What would Spock say?
08:43:51 <mniip> monochrom, derive the evidence then
08:44:27 <monochrom> that's circular
08:44:40 <Peaker> https://github.com/Peaker/lamdu/blob/eyal/hack/Lamdu/Eval/Background.hs#L66 <-- can anyone help me understand where unforced thunks are being placed in there?
08:45:17 <hexagoxel> tonyd256: yesod is no executable, is it?
08:45:59 <tonyd256> hexagoxel: it says this: cabal: The package environment file
08:46:00 <tonyd256> ‘/path/to/cabal.sandbox.config' doesn't exist
08:46:08 <tonyd256> where the path is not the correct one
08:47:00 <Peaker> I think Data.Map.Strict.alter is buggily forgetting to force the val!
08:47:08 <Peaker> http://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Map-Strict.html#alter
08:47:19 <hexagoxel> (ah, yesod-bin provides yesod, i see)
08:47:33 <Peaker> oh, nope, singleton forces it for him
08:47:35 <tonyd256> ah yes … sorry it does
08:49:10 <monochrom> Peaker: do you have a self-contained test case and outcome that can only be explained by your hypothesis "alter forgets to force the val"?
08:49:49 <monochrom> for example, Lamdu does not qualify as "can only be explained by your hypothesis", since it is too big and too many moving parts.
08:51:09 <Peaker> monochrom: it doesn't forget to. I am not sure where lazy thunks are hiding, but they are -- if I use   length (show state) `seq` ..   to force the state after its update, no work is buggily moved to the main thread
08:51:33 <Peaker> monochrom: if I use length (show (_sValMap state ...   same result (i.e: thunks are hiding in there)
08:51:40 <hexagoxel> tonyd256: i dunno, i just tested `cabal --sandbox-config-file=.. exec bash` and it worked (at least when the path does not contain `~` ..)
08:52:05 <tonyd256> hmm … maybe it has something to do with yesod devel then
08:52:28 <tonyd256> I tried cabal build with that sandbox option and it also worked
08:52:29 <monochrom> I see. but it's a full-time job to investigate Lambdu itself
08:52:52 <Peaker> monochrom: well, looking just at the places that modify _sValHeadMap can narrow it down significantly :)
08:53:05 <Peaker> monochrom: note it's not exported from that module
08:56:51 <Peaker> I think I'm zooming in on the bug by my own now.. :)
09:01:52 <hexagoxel> tonyd256: i doubt it has something to do with yesod devel, but you could just run some other command that certainly succeeds (with exec) to test.
09:03:40 <tonyd256> the reason I’m doing all this is because I need a sandbox to not conflict with global tooling (alex, happy, yesod-bin) … I might try to move those into a sandbox instead then I wont need on with my project dependencies
09:06:43 <Peaker> monochrom: narrowed it down to: http://lpaste.net/134677
09:07:52 <mikey22> is there a general [x..y] syntax for types other than list? 
09:08:00 * hackagebot trurl 0.3.0.0 - Haskell template code generator  http://hackage.haskell.org/package/trurl-0.3.0.0 (dbushenko)
09:08:02 * hackagebot trurl 0.3.0.1 - Haskell template code generator  http://hackage.haskell.org/package/trurl-0.3.0.1 (dbushenko)
09:08:04 * hackagebot trurl 0.3.0.2 - Haskell template code generator  http://hackage.haskell.org/package/trurl-0.3.0.2 (dbushenko)
09:08:06 * hackagebot trurl 0.3.0.3 - Haskell template code generator  http://hackage.haskell.org/package/trurl-0.3.0.3 (dbushenko)
09:08:23 <monochrom> what is the type of x?
09:08:33 <johnw> mikey22: that should work for any Enumerable
09:08:56 <johnw> or do you mean, having that syntax produce something other than a list?
09:09:08 <mikey22> yes
09:09:16 <mikey22> Vector, Text, etc
09:09:33 <johnw> it's easy enough to write a vectorFromTo x y function, as for overriding the syntax I'm not so sure
09:09:51 <phaazon> hey, where does ghc look for libraries on unix?
09:09:53 <Peaker> monochrom: Map ScopeId (ValHead pl)
09:09:59 <phaazon> I’m trying to install my package into /usr/lib
09:10:09 <phaazon> (for deployment)
09:10:19 <phaazon> and I guess ghc doesn’t see it
09:11:09 <Peaker> monochrom: note that's the only place that modifies _sValHeadMap
09:11:21 <Peaker> monochrom: and erc* are fully forced
09:12:33 <Welkin> kadoban: any luck since last night?
09:13:00 * hackagebot trurl 0.3.0.4 - Haskell template code generator  http://hackage.haskell.org/package/trurl-0.3.0.4 (dbushenko)
09:13:18 <phaazon> I guess there’s something to launch to “refresh” GHC
09:13:23 <phaazon> or maybe ghci
09:13:25 <phaazon> that’s weird
09:19:35 <Welkin> @tell lspitzner Thank you! Cabal finally works!
09:19:35 <lambdabot> Consider it noted.
09:19:46 <phaazon> nevermind
09:19:48 <phaazon> I found out
09:19:57 <phaazon> ok, any archlinux man here?
09:20:07 <phaazon> I wonder which solution I should pick to install my package
09:20:14 <phaazon> I think I’m gonna use the AUR
09:20:26 <phaazon> I find it’s a weird idea having “haskell” repositories
09:22:50 <monochrom> Peaker: do you turn on optimizations, i.e., -O at least?
09:23:33 <Peaker> monochrom: not in this test (need shorter debug cycles)
09:23:49 <Peaker> (I use a .cabal file so the default is no -O, afaik)
09:24:16 <monochrom> I have a self-contained example for which -O matters
09:24:38 <monochrom> data S = S !Int
09:24:47 <monochrom> inc (S n) = S (n+1)
09:25:22 <monochrom> main = go 10000000000000 (S 0); go 0 s = case s of S _ -> putStrLn "the end"; go n s = go (n-1) (inc s)
09:28:01 * hackagebot data-easy 0.6 - Consistent set of utility functions for Maybe, Either, List, Monoids.  http://hackage.haskell.org/package/data-easy-0.6 (jcristovao)
09:28:22 <felixn> anyone have a good pattern for error handling?  I tried using Either Err a, but it's really annoying
09:28:41 <c_wraith> In which ways is it annoying?
09:28:55 <monochrom> when taken on face value, it builds up "inc (inc (inc (inc .." and nothing obliges the computer to reduce it until you hit "go 0 s".
09:29:09 <bergmark> felixn: the natural thing would be to move to ExceptT Err a
09:29:19 <monochrom> and -O0 takes your program on face value, pretty much.
09:29:22 <felixn> c_wraith: I can't seem to figure out how to chain things nicely without lots of cases
09:29:26 <bergmark> ExceptT Err m a *
09:29:36 <c_wraith> felixn: isn't that what do notation is for?
09:29:48 <Peaker> monochrom: Well, go is missing a strictness annotation there
09:29:59 <Peaker> monochrom: -O0 should be possible to make work, no?
09:30:06 <monochrom> no.
09:31:55 <monochrom> go is highly non-strict, yes.
09:32:30 <Peaker> monochrom: if you add a strictness annotation here it would work with -O0
09:32:31 <monochrom> my inc is analogous to your updateState, or even just the "Map.alter foo ercSource" part.
09:32:46 <monochrom> my go is analogous to an outer loop you have not shown.
09:32:52 <mauke}> go (n-1) $! (inc s)?
09:33:05 <Peaker> monochrom: but note that the "deepForce" there causes the problem to appear/disappear
09:33:33 <Peaker> monochrom: http://lpaste.net/134677#line23 <-- deepForce here -- i.e: the thunks are hiding inside the map
09:33:34 <monochrom> ok, I don't know.
09:48:02 * hackagebot path 0.5.1 - Path  http://hackage.haskell.org/package/path-0.5.1 (ChrisDone)
09:56:51 <Welkin> it feels amazing that cabal actually works now
09:58:02 * hackagebot chatter 0.5.1.0 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.5.1.0 (RoganCreswick)
10:00:42 <bitemyapp> @pl \j -> D <$> p j
10:00:43 <lambdabot> (D <$>) . p
10:01:14 <kadoban> Welkin: You do anything different from last night? I'm trying just installing yet again and see.
10:01:21 <Welkin> kadoban: yes!
10:01:23 <Welkin> I got it to work
10:01:35 <Welkin> cabal-install 1.22.5.0 is broken
10:01:39 <Welkin> download 1.22.6.0
10:01:46 <Welkin> thanks to a message from lspitzner 
10:01:58 <kadoban> Err, really? That's odd.
10:02:06 <Welkin> it's glorious
10:02:14 <kadoban> I think that's the one I grabbed though so hopefully it'll work now.
10:02:27 <Welkin> after a long battle with cabal, I find victory
10:02:47 <kadoban> Oh he sent me a message too, thanks lspitzner
10:02:58 <Welkin> I installed alex and happy in a sandbox in ~/bin and symlinked them too
10:03:19 <Welkin> I want to avoid cabal hell at all costs
10:04:35 <hiptobecubic> Ran into this today:  :(  http://bugs.python.org/issue18305 
10:05:13 <hiptobecubic> tldr python is not haskell :(
10:05:41 <ronh-> it makes me sadder that [1,2,3] * 10000000 is a valid syntax
10:05:42 <Welkin> hiptobecubic: python is a bug?
10:07:52 <mikey22> how to get [1,2,4,8,16..]?
10:08:27 <quchen_> > iterate (*2) 1
10:08:29 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
10:08:33 <Iceland_jack> > map (2^) [0..]
10:08:35 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
10:08:46 <Welkin> there's always more than one way to do it :)
10:09:14 <Iceland_jack> > let a = 1:map (2*) a in a
10:09:15 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
10:09:16 <mikey22> cool thanks
10:10:22 <mikey22> i dont get the last one
10:10:25 <mikey22> at all
10:10:32 <mizu_no_oto> ronh-: you can actually make that into valid syntax in Haskell, FWIW
10:10:48 <Peaker> monochrom: I'm pretty sure the problem is in Data.Map.Strict.alter -- which is creating a Map with thunks inside it
10:11:10 <Peaker> monochrom: Data.Map.Strict is strict on the values, but I guess it doesn't guarantee anything about the strictness of its own spine
10:11:26 <hiptobecubic> Welkin, sum doesn't generalize for no good reason.
10:11:27 <mikey22> how does this one work? let a = 1:map (2*) a in a 
10:11:49 <Peaker> (if you do a lot of Data.Map.Strict.insert/alter, you may get a lot of thunks in between your Map and your (forced) values)
10:12:06 <hiptobecubic> mikey22, try to write it out by hand
10:13:58 <mikey22> i would if my brain wasnt tied up like a pretzel looking at it
10:14:14 <Iceland_jack> mikey22: a
10:14:14 <Iceland_jack>    ----> 1:map (2*) a
10:14:14 <Iceland_jack>    ----> 1:map (2*) (1:map (2*) a)
10:14:38 <quchen> mikey22: Start with "a =" and insert definitions. Haskell's semantics can be understood by inlining terms outside to inside for the most part.
10:16:07 <Iceland_jack> mikey22: See if you can understand this first
10:16:07 <Iceland_jack> > let xs = 1:xs in xs
10:16:08 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:18:08 <mikey22> we keep replacing xs with 1:
10:18:33 <Iceland_jack> We keep replacing (xs) with (1:xs)
10:18:58 <Iceland_jack> mikey22: xs
10:18:59 <Iceland_jack>    ----> 1:xs
10:18:59 <Iceland_jack>    ----> 1:(1:xs)
10:18:59 <Iceland_jack>    ----> 1:(1:(1:xs)) etc.
10:19:23 <mikey22> hmm
10:19:46 <mikey22> the xs keeps going back to first 1:?
10:19:48 <Welkin> ghc just paniced on me
10:19:50 <Welkin> http://lpaste.net/134678
10:20:21 <Welkin> does anyone know what happened?
10:20:27 <Welkin> I was compiling my yesod application
10:20:43 <Welkin> it looks like everything installed fine until it got to my application
10:21:02 <Iceland_jack> mikey22: The definition of 'xs' is simply
10:21:02 <Iceland_jack>     xs = 1:xs
10:21:02 <Iceland_jack> so every time you see a (xs) you may replace it with (1:xs)
10:21:34 <ProofTechnique> Welkin: https://ghc.haskell.org/trac/ghc/ticket/10110
10:21:35 <Iceland_jack> mikey22: Which means you'll end up with
10:21:36 <Iceland_jack>     1:1:1:1:1:1:1:1:1:1:1:1: <...>
10:21:36 <Peaker> monochrom: if I use:   forceMapSpine x = length (Map.keys x) `seq` x      and then    insert k v m = forceMapSpine $ Map.insert k v m        my troubles all go away
10:21:36 <ProofTechnique> Look related?
10:21:48 <Peaker> so Strict Map is the culprit indeed!
10:22:17 <mikey22> (1:xs). replacing xs with it.. (1:(1:xs)).. I get this one
10:22:31 <ProofTechnique> Welkin: Though this closed one looks closer
10:22:32 <ProofTechnique> Welkin: https://ghc.haskell.org/trac/ghc/ticket/10058
10:22:33 <Welkin> ProofTechnique: it does look similar
10:22:37 <Welkin> though I am on osx
10:22:40 <mikey22> let me try map now
10:23:09 <mikey22> so each time we see a we replace it with map (*) a
10:23:33 <mikey22> *with 1:map (*2) a
10:23:38 <Iceland_jack> mikey22: that's right
10:24:01 <Iceland_jack> Writing 'a' as a normal definition
10:24:01 <Iceland_jack>     a = 1:map (2 *) a
10:24:51 <mniip> next step is realising that  map f (x:xs) = (f x):(map f xs)
10:26:36 <mikey22> > 1 : map (*2) (1 : map (*2) (1: ... ))) does not make sense to me. and I couldnt get it to compile even by sticking undefined there like I could with 1:
10:26:38 <lambdabot>  <hint>:1:32: parse error on input ‘...’
10:26:49 <mikey22> > 1:(1:(1:undefined))
10:26:50 <lambdabot>  [1,1,1*Exception: Prelude.undefined
10:27:00 <Iceland_jack> > 1 : map (*2) (1 : map (*2) (1 : undefined))
10:27:01 <lambdabot>  [1,2,4*Exception: Prelude.undefined
10:27:22 <mikey22> wtf
10:28:53 <monochrom> :)
10:29:25 <Iceland_jack>     map (* 2) (1 : undefined)
10:29:25 <Iceland_jack> turns into
10:29:25 <Iceland_jack>     2 : map (* 2) undefined
10:29:39 <Iceland_jack> > map (* 2) (1 : undefined)
10:29:40 <lambdabot>  [2*Exception: Prelude.undefined
10:30:30 <kadoban> Heh, the placement of the * in that error message is somewhat unfortunate
10:32:21 <Welkin> ProofTechnique: I am trying a fresh yesod project to see what happens
10:33:37 <mikey22> so from inside out.. 1 : undefined => 1 : 2 : undefined => 1 : 2 : 4 : undefined
10:34:05 <mikey22> I cant read from outside in though, which is how it works,
10:34:12 <mikey22> ?
10:34:59 <mikey22> if it didnt work from outside in undefined would throw right away
10:49:36 <Welkin> okay
10:49:40 <Welkin> now I get a different error
10:49:47 <Welkin> for my freshly installed yesod scaffolding
10:49:47 <Welkin> cabal: Cannot find the program 'ghc'. User-specified path 'yesod-ghc-wrapper'
10:49:48 <Welkin> does not refer to an executable and the program is not on the system path.
10:49:57 <Welkin> when I run `yesod devel`
10:50:22 <Welkin> it is in a sandbox, if that makes any difference
10:50:28 <ProofTechnique> I guess you have to set `yesod-ghc-wrapper`
10:50:41 <geekosaur> cabal exec yesod-devel
10:50:41 <geekosaur> ?
10:50:54 <geekosaur> er
10:50:58 <geekosaur> cabal exec yesod devel
10:51:24 <geekosaur> otherwise you might need to add the sandbox's bin directory to $PATH or somethin g
10:51:55 <Welkin> well, here is my set up
10:52:10 <Welkin> I installed yesod-bin in a seperate sandbox and symlinked it
10:52:31 <Welkin> I have yesod installed in a different sandbox where my project is located
10:52:41 <geekosaur> then you'll need to symlink the things it requires as well, it sounds like
10:52:56 <Welkin> I tried putting yesod-bin in the same sandbox, but I got the same error
10:54:22 <Welkin> okay
10:54:26 <Welkin> cabal exec yesod devel worked
10:54:28 <Welkin> why?
10:55:54 <geekosaur> your setup sounds complex enlough that I'm not sure the simple answer is correct (that cabal exec adds sandbox bin directories to $PATH so any other needed programs will be found)
10:56:07 <Welkin> hm
10:56:17 <Welkin> well I do still have yesod-bin installed in the same sandbox as my project
10:56:33 <Welkin> I removed the global symlink and it still works when I run the command through cabal exec
11:01:52 <monochrom> mikey22: yes, you should strive to do outside-in.
11:02:07 <mikey22> I cant seem to
11:05:21 <marantz> can anyone tell me why cabal install says 'build-depends: base >=4.8 && <4.9, Network.Snmp.Client' is illegal? or point me at something which describes the syntax?
11:06:54 <kadoban> marantz: Network.Snmp.Client doesn't look like a valid package name. That's the module I assume?
11:06:55 <ProofTechnique> marantz: Network.Snmp.Client is a module name
11:07:08 <ProofTechnique> @hoogle Network.Snmp.Client
11:07:09 <lambdabot> package clientsession
11:07:09 <lambdabot> package amazon-emailer-client-snap
11:07:09 <lambdabot> package analyze-client
11:08:56 <marantz> so I should just use NetSNMP or Network.ProtocolNetSNMP then?
11:09:37 <kadoban> marantz: You have to use the package name. Do you know what package it's from?
11:10:26 <marantz> ok, NetSNMP works.  thanks.  obviously I'm new to this
11:12:24 <marantz> too bad NetSNMP doesn't compile :-(  back to the drawing board
11:13:16 <gamegoblin> Is there a way to get word8 literals instead of char literals?
11:14:16 <Peaker> monochrom: It's pretty weird: reviewed the code of Data.Map.Strict -- it does seem that it is necessarily always fully strict, yet somehow just forcing the length of Map.keys is enough to avoid building up thunks
11:14:31 <Peaker> (always fully strict on keys, values AND the spine)
11:15:03 <ProofTechnique> @hoogle netsnmp
11:15:03 <lambdabot> package NetSNMP
11:15:30 <ProofTechnique> @hackage NetSNMP
11:15:31 <lambdabot> http://hackage.haskell.org/package/NetSNMP
11:16:07 <ProofTechnique> marantz: I think you actually want to use clientsession, not NetSNMP
11:16:38 <ProofTechnique> clientsession provides Network.Snmp.Client, but NetSNMP does not.
11:18:01 <marantz> I'll try that. thanks
11:20:58 <monochrom> mikey22: suppose I ask you to calculate 0 * (928039843 + 129383902). do you still do inside-out?
11:21:46 <sccrstud92> what do you guys think of the new sockets package? do you like it better than network?
11:23:05 * hackagebot git-annex 5.20150617 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150617 (JoeyHess)
11:23:26 <hodapp> Free monads... now make a little more sense to me.
11:30:44 <mikey22> monochrom: i can do that one outside out.. 0 * <thunk>, yes?
11:31:32 <muyfine> I'm playing around with "formatting" module and wanted to wrap my calls to the monad logger with formatting
11:31:57 <muyfine> so instead of calling > logInfoN $ format "xxxx"
11:32:17 <muyfine> I could call one function
11:32:31 <muyfine> but having troubles with the typing for that
11:32:55 <muyfine> anyone have something that does something like that?
11:36:54 <mikey22> let a = 1:map (2*) a in a
11:37:09 <mikey22> 1 : <thunk>
11:37:46 <Welkin> how can I get cabal exec to work with command that have flags?
11:37:48 <mikey22> 1 : map (*2) a 
11:38:15 <mikey22> 1 : 2 : map (*2) a
11:38:20 <Welkin> `cabal exec yesod init --bare` thinks that `--bare` belongs to `cabal exec`, when it is just part of the command I want it to execute `yesod init --bare`
11:38:30 <mikey22> 1 : 2 : 2 ??? where is my error
11:40:07 <marantz> Welkin try cabal exec yesod — init --bare
11:40:26 <marantz> cabel exec —help is your friend
11:40:41 <Welkin> marantz: thank you
11:41:09 <geekosaur> there is also cabal exec $SHELL
11:43:59 <frerich> mikey22: What you're missing is that '*2' is applied once for the second list element, twice for the third, three time for the fourth etc.
11:44:19 <frerich> mikey22: mikey22: If you set 'let a = 1 : map (2*) a', you can simply expand the 'a' occurences first (before even bothering to evaluate anything), i.e. get a value corresponding to '1 : map (2*) (1 : map (2*) (1 : map (2*) ..))'.
11:44:57 <mikey22> oh right. third element is mapped twice
11:45:05 <frerich> mikey22: Right.
11:46:33 <mikey22> the first map keeps mapping all the elements from 2 and beyond, so 4th element is mapped 3 times
11:46:39 <mikey22> I think I get it
11:48:06 * hackagebot github-backup 1.20150617 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20150617 (JoeyHess)
11:48:31 <frerich> mikey22: You might like https://hackhands.com/lazy-evaluation-works-haskell/
11:49:09 <mikey22> 2nd element is mapped 1 time, 3d two times, 4th three times, and so on?
11:50:10 <frerich> mikey22: http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+a+%3D+1%3Amap+%28*2%29+a+in+a is kinda funky
11:52:44 <mikey22> I will check that out.. but did I get that right? each map applies to all the elements beyond, so 100th element is passed through 99 maps?
11:54:04 <frerich> mikey22: Yes, that's right.
11:54:17 <mikey22> isnt that terribly inefficient?
11:56:42 <jle`> mikey22: compared to what?
11:56:52 <jle`> calling 2**100 on the machine?
11:57:28 <jle`> how else are you going to get 2^100 by multiplication without multiplying 2 one hundred times :p
11:58:24 <frerich> jle`: I think there is some inefficiency because there is no memoization.
11:58:25 * mikey22 compared to generating a list with a loop and mutation in an imperative PL
11:58:35 <jle`> mikey22: that's the same thing here, isn't it?
11:58:51 <jle`> witha  loop and mutation, the 100 loop stillr equires multiplying the 2 one hundred times...
11:59:06 <jle`> you need to multiply by 2 one hundred times to get to the one hundredth iteration
11:59:16 <jle`> it's not like you can skip to iteration #100 and skip 2-99
11:59:48 <frerich> jle`: With memoization (or a modifying loop), the next element only requires one further multipication *2 though. The definition used here needs a lot more multiplications.
12:00:16 <mikey22> jle why would I need more than 100 multiplications in an imperative language?
12:00:25 <jle`> you only need one hundre dmultiplcations
12:00:29 <jle`> and you only need one hundred multiplcations here, too
12:00:51 <mikey22> not 200? 
12:00:57 <jle`> to get the 100th element?
12:01:06 <jle`> the 100th element is just 2*2*2*.. one hundred times
12:01:09 <gamegoblin> @pl \x y -> (Just x, y)
12:01:09 <lambdabot> (,) . Just
12:01:44 <frerich> jle`: Given 'let a = 1 : map (*2) a in a', the third list element requires two multiplications, the fourth list element requires three multiplications... and the 100th list element requires 99 multiplications. In a mutating loop you would simply have one extra multiplication for every next element.
12:01:54 <mikey22> actually far more than 200.. 100th element is multiplied 99 times, 99th 98 times..
12:02:02 <jle`> gamegoblin: you can do `first just`
12:02:09 <gamegoblin> jle`: thanks
12:02:19 <mikey22> > sum [1..99]
12:02:20 <lambdabot>  4950
12:02:22 <gamegoblin> :t first just
12:02:24 <lambdabot>     Not in scope: ‘just’
12:02:24 <lambdabot>     Perhaps you meant data constructor ‘Just’ (imported from Data.Maybe)
12:02:28 <gamegoblin> :t first Just
12:02:29 <lambdabot> (b, d) -> (Maybe b, d)
12:02:40 <mikey22> jle so that haskell code does 4950 multiplications?
12:03:59 <mikey22> to generate first 100 elements
12:04:52 <aweinstock> :t curry $ first . Just
12:04:53 <lambdabot>     Couldn't match type ‘Maybe’ with ‘a1 b1’
12:04:53 <lambdabot>     Expected type: (a, b) -> a1 b1 (a, b)
12:04:53 <lambdabot>       Actual type: (a, b) -> Maybe (a, b)
12:04:59 <aweinstock> :t curry
12:05:00 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:05:38 <aweinstock> :t curry $ first Just
12:05:39 <lambdabot> a -> b -> (Maybe a, b)
12:06:17 <mniip> mikey22, no
12:06:20 <mniip> it only does 100
12:06:59 <aweinstock> :t unfoldr
12:07:00 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:07:14 <mikey22> how? if 100th element goes through 99 maps, 99th through 98, etc
12:07:23 <mniip> 100th element is 99th * 2
12:07:45 <aweinstock> :t unfoldr (\x -> Just (x,2*x)) 1
12:07:46 <lambdabot> Num a => [a]
12:07:52 <mniip> once we know 99th element, it only takes one multiplication to get 100th
12:07:55 <aweinstock> > unfoldr (\x -> Just (x,2*x)) 1
12:07:57 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:08:00 <davidfetter> o/` 99 maps but a foldr ain't one o/`
12:08:04 <davidfetter> sorry
12:08:37 <mniip> > fix (flip (:) . map (2 *))
12:08:38 <lambdabot>      Couldn't match type ‘a -> [a]’ with ‘[a]’
12:08:39 <lambdabot>      Expected type: (a -> [a]) -> [a]
12:08:39 <lambdabot>        Actual type: [a] -> [a]
12:08:43 <mniip> er
12:08:49 <mniip> > fix ((1:) . map (2 *))
12:08:50 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:08:52 <frerich> mniip: The definition doesn't use the 99th element to compute the 100th element though. It applies (*2) repeatedly.
12:09:02 <aweinstock> is that "let a = 1 : map (2*) a in a" thing the same as the unfoldr version that I wrote?
12:09:07 <mniip> [21:36:32] <mikey22> let a = 1:map (2*) a in a
12:09:09 <mikey22> mniip: but there are 99 maps in front of 100th elements. how is that not 99 times (*2)
12:09:21 <mikey22> element*
12:09:21 <arkeet> because sharing
12:09:35 <aweinstock> @src unfoldr
12:09:36 <lambdabot> unfoldr f b = case f b of
12:09:36 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
12:09:36 <lambdabot>    Nothing        -> []
12:10:05 <mniip> ohh
12:10:14 <mniip> you seem to be correct
12:10:45 <frerich> arkeet: Even with sharing, you still get e.g. '1 : 2 : map (* 2) ((* 2) 1 : map (* 2) (map (* 2) ...))' - notice how computing the third element will apply (*2) twice to '1'.
12:10:53 <arkeet> frerich: no, you lose sharing by expanding that.
12:10:56 <aweinstock> is the unfoldr version more efficient (less applications of (*)) than the map version?
12:10:59 <mikey22> me? how did you test?
12:11:10 <mikey22> ^^ mniip 
12:11:49 <aweinstock> :t second (2*)
12:11:50 <lambdabot> Num c => (d, c) -> (d, c)
12:12:02 <sccrstud92> what if you just redfine * to trace the numbers its multiplying everytime its used
12:12:06 <sccrstud92> and see what it does?
12:12:07 <arkeet> you can do that.
12:12:07 <jle`> > fix ((*2) . (1:))
12:12:09 <lambdabot>      No instance for (Show a0)
12:12:09 <lambdabot>        arising from a use of ‘show_M584528196352833835919873’
12:12:09 <lambdabot>      The type variable ‘a0’ is ambiguous
12:12:09 <aweinstock> :t unfoldr (Just . second (2*)) 1
12:12:11 <lambdabot>     Occurs check: cannot construct the infinite type: b0 ~ (a, b0)
12:12:11 <lambdabot>     Expected type: b0 -> (a, b0)
12:12:11 <lambdabot>       Actual type: (a, b0) -> (a, b0)
12:12:24 <mniip> jle`, needs more maps
12:12:55 <arkeet> > unfoldr (Just . (id &&& (2*))) 1
12:12:56 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:13:07 <arkeet> anyway
12:13:43 <sccrstud92> > trace "Test" ()
12:13:44 <lambdabot>  Not in scope: ‘trace’
12:15:11 <arkeet> frerich: if the first 99 elements of the list are already evaluated,
12:15:23 <arkeet> computing the 100th element only needs to look at the 99th element
12:15:27 <frerich> arkeet: Indeed!
12:15:31 <mniip> > fix (((:) <*>) . (. (2*))) 1
12:15:33 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:15:33 <mniip> there we go
12:15:44 <arkeet> so it only does one multiplication
12:17:09 <frerich> Yeah, I had to try it with trace output and scribble something here involving boxes and arrows to convince myself, but arkeet is right.
12:17:20 <aweinstock> arkeet: are both the "fix" and the "unfoldr" versions approximately equally efficient, both of which are more efficient than the "map" version?
12:17:55 <arkeet> why would it be more efficient than the map version?
12:18:05 <frerich> arkeet: I guess the takeaway is that equational reasoning can tell me what is being evaluated - but not how.
12:18:15 <arkeet> mhm
12:18:46 <jle`> well, equational reasoning lets you equate two different implementations to have the same result.  so in a sense they are the ultimate performance-agnostic tool
12:18:53 <mniip> frerich, jle`'s fix version is as bad as the original definition
12:19:00 <aweinstock> > let a = 1 : map (2*) a in a
12:19:01 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:19:13 <mniip> mine on the other hand
12:19:20 <jle`> that's the nice thing about it...you can use equational reasoning to prove the two definitions are equivalent
12:19:44 <Ainieco> hello
12:19:45 <arkeet> you can use equational reasoning to go from a slow definition to a fast definition.
12:19:50 <arkeet> that you know is equivalent.
12:19:55 <mniip> [22:10:58] <sccrstud92> what if you just redfine * to trace the numbers its multiplying everytime its used
12:19:56 <mniip> duhh
12:20:00 <Ainieco> how do i pattern match bytestrings head and tail?
12:20:02 <mniip> trace
12:20:06 <mniip> just use a state monad
12:20:09 <Ainieco> like x:xs but it doesn't work
12:20:24 <arkeet> Ainieco: what for?
12:21:05 <jle`> Ainieco: you can use Data.ByteString.uncons
12:21:09 <arkeet> if you really want both the head and the tail you can use uncons
12:21:28 <Ainieco> arkeet: for getting head and tail in scope as variables
12:21:39 <arkeet> sure, but what for
12:22:05 <Ainieco> arkeet: to parse integer from tail and discard haead
12:22:18 <arkeet> if you want to discard the head, why not just use tail?
12:22:26 <frerich> mniip: If you import Debug.Trace and then define 'mul x y = trace "multiplying" (x * y)' and 'a = 1 : map (mul 2) a' you can see that e.g. 'take 10 a' behaves very sanely.
12:22:32 <Ainieco> arkeet: i didn't know about that
12:22:45 <arkeet> (which will blow up on an empty bytestring though.)
12:22:58 <arkeet> (so maybe uncons is safer)
12:23:18 <Ainieco> okay, jle` arkeet thank you
12:24:14 <frerich> mniip: Don't try to shortcut and define 'mul = trace "multiplying" (*)' though :-)
12:24:23 <frerich> I did that first...
12:24:23 <mniip> duh
12:24:55 <Ainieco> what will print string like putStrLn but wihtout \n at the end?
12:25:10 <mikey22> putStr :)
12:25:13 <sccrstud92> putStr
12:25:16 <mniip> putStr
12:27:46 <mniip> @let mul x y = modify (+1) >> return (x * y)
12:27:47 <lambdabot>  Defined.
12:27:55 <mniip> @let a = return 1:(map (>>= mul 2) a)
12:27:56 <lambdabot>  .L.hs:141:33:
12:27:56 <lambdabot>      Ambiguous occurrence ‘a’
12:27:56 <lambdabot>      It could refer to either ‘L.a’, defined at .L.hs:141:1
12:28:09 <mniip> @let list = return 1:(map (>>= mul 2) list)
12:28:10 <lambdabot>  Defined.
12:28:20 <mniip> > execState (sequence $ take 100 list) 0
12:28:21 <lambdabot>  4950
12:28:32 <arkeet> that doesn't compute the same thing.
12:33:08 * hackagebot http-client 0.4.12 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.12 (MichaelSnoyman)
12:33:35 <ronh-> mult x y = trace "." (x * y)
12:33:42 <ronh-> take 10 $ let a = 1 : map (mult 2) a in a
12:33:44 <ronh-> only 10 dots
12:33:51 <ronh-> nine actually
12:35:17 <jle`> interesting
12:37:54 <Welkin> ...
12:38:00 <Welkin> well, something is really fucked up
12:38:06 <Welkin> ghc is randomly panicking again
12:38:26 <Welkin> yesod was running perfectly fine, then it started giving me a ghc panic error
12:39:30 <Welkin> http://lpaste.net/134680
12:40:08 <Ainieco> thanks
12:40:19 <Peaker> upgrading containers is not really a possibility, is it? (ghc's pkg transitively depends on containers, reinstalling containers breaks th which ghc deps on)
12:41:32 <Welkin> Peaker: me?
12:41:46 <Peaker> Welkin: me :)
12:42:05 <Peaker> I'm having a very weird bug in my strict map -- which seems to be hiding thunks inside it, so I wanted to try containers' newest version
12:42:09 <Peaker> but that seems impossible to do
12:42:13 <Peaker> perhaps if I upgrade my ghc
12:43:27 <Ainieco> hm, looks like putStr buffers while putStrLn does not
12:43:34 <ronh-> use hFlush
12:43:45 <ronh-> hFlush stdout
12:44:21 <Ainieco> is there something like putStr which doesn't buffer(and don't require hFlush)?
12:45:06 <aweinstock> hSetBuffering, and then keep using putStr?
12:45:26 <Ainieco> aweinstock: cool, thanks
12:45:31 <Peaker> Ainieco: there's "line buffering" which buffers until it sees \n
12:45:53 <mikey22> is that putStr buffering or terminal?
12:46:22 <aweinstock> the terminal/stdout
12:46:44 <Ainieco> aweinstock: ugh, it requires some "handle" thing, i can't have it within my callback
12:47:21 <aweinstock> just do "hSetBuffering stdout NoBuffering" in some setup code once
12:47:28 <aweinstock> :t stdout
12:47:29 <lambdabot> Not in scope: ‘stdout’
12:47:40 <sccrstud92> stdout is iin System.IO
12:47:44 <Ainieco> aweinstock: great, thanks again
12:48:15 <aweinstock> does lambdabot allow talking about System.IO things? or is that sandboxed?
12:48:21 <aweinstock> :t System.IO.stdout
12:48:22 <lambdabot> GHC.IO.Handle.Types.Handle
12:48:37 <aweinstock> :t System.IO.hSetBuffering
12:48:38 <lambdabot> GHC.IO.Handle.Types.Handle -> GHC.IO.Handle.Types.BufferMode -> IO ()
12:49:09 <arkeet> you can talk about IO 
12:49:11 <arkeet> you just can't run any IO
12:49:23 <aweinstock> :t System.IO.hPutStr System.IO.stderr
12:49:24 <lambdabot> String -> IO ()
12:49:33 <aweinstock> > System.IO.hPutStr System.IO.stderr "hello"
12:49:34 <lambdabot>  Not in scope: ‘System.IO.hPutStr’Not in scope: ‘System.IO.stderr’
12:50:11 <Luke> is there a naming convention for callback functions in haskell?
12:50:14 <arkeet> @let import System.IO
12:50:15 <lambdabot>  Defined.
12:50:25 <Luke> any type of idiom or something for callbacks?
12:50:28 <mikey22> did anyone figure why that recursive a definition multiplies 99 times and not 4950 like it would do if you manually expanded maps
12:50:36 <arkeet> > hPutStr stderr "hello"
12:50:37 <lambdabot>  <IO ()>
12:50:57 <arkeet> mikey22: I already said why
12:50:59 <sccrstud92> mikey22: the answer is sharing
12:51:03 <arkeet> ^
12:51:40 <Vektorweg1> do we have some haskell-like scripting languages? something i could build in a game or something. 
12:51:42 <frerich> The way 'let a = 1 : map (*2) a in a' works really surprised me, but I feel a bit better after reading that even Heinrich Apfelmus writes 'In fact, I would go so far as to say that with lazy evaluation, it is no longer feasible to trace evaluation in detail, except for very simple examples.'
12:52:37 <aweinstock> Vektorweg1: you could put "#!/usr/bin/env runhaskell" at the top of a file and run it as a script?
12:52:50 <frerich> My inability to predict whether something is going to be efficient or not still makes me feel uneasy though. :-(
12:53:36 <sccrstud92> frerich: thats the price you pay for compiler optimizations
12:53:37 <mikey22> I dont get how elements can be shared unless ghc specifically analyses and optimizes such a thing? could on another conforming implementation this be multiplied 4950 times? 
12:53:38 <breadmonster> Hey everyone.
12:53:43 <MarcelineVQ> "Now is not the time for optimisation. ... That comes later."
12:53:51 <breadmonster> Can someone tell me how to use Alex to tokenize input at the start of a line?
12:53:56 <breadmonster> *tokenize whitespace
12:54:12 <c_wraith> mikey22: in general, assume GHC only shares values that come from the same binding.
12:54:18 <aweinstock> mikey22: I think it's guarenteed by how lazy evaluation and "let" scoping work
12:54:29 <Vektorweg1> aweinstock: actually, i don't want to deploy a whole haskell environment with it. also the functionality should be reduced anyway and all pure. 
12:54:57 <frerich> mikey22: I think it would be legal to have an Haskell implementation which uses non-strict evaluation (but it doesn't cache the computed values) and hence which would be much less efficient.
12:55:34 <breadmonster> frerich: Doesn't GHC use nonstrict evaluation?
12:55:39 <mauke> argh, don't use unbuffered output
12:55:47 <mauke> it's horribly inefficient with strings
12:56:04 <breadmonster> mauke: That's not the point, I'm trying to tokenize Python.
12:56:23 <breadmonster> Writing it by hand became tiring very soon, I'm going to just use alex and happy.
12:56:25 <mauke> breadmonster: that's not the point, I'm not talking to you (I think?)
12:56:33 <breadmonster> Oh right okay, sorry :P
12:56:34 <mikey22> wait, what exactly is shared? elements cant be, because they keep increasing. there is no common tail
12:56:38 <frerich> breadmonster: Yes, it does. Being non-strict doesn't require that you cache the resulting values though. You could also evaluate an expression everytime you need its value and sitll be non-strict.
12:56:59 <breadmonster> frerich: Oh memoized v/s not memoized?
12:57:23 <mauke> mikey22: parts of the elements
12:57:46 <mikey22> mauke: what parts? each element is different!
12:57:51 <Gentmen> could someone please check out my question on the Eval monad - http://stackoverflow.com/questions/30897154/parallel-fibonacci-from-parallel-and-concurrent-haskell#comment49836312_30897154?
12:57:56 <frerich> breadmonster: I'm not sure 'memoized' is the right word, but yeah - I was thinking of languages like Tcl, which are non-strict as well (but not 'lazy' in the 'compute it only on demand but then keep the value around instead of reevaluating')
12:57:58 <mauke> mikey22: different, but they all share parts
12:58:14 <mikey22> what parts do they share
12:58:46 <mauke> every element has the form 2 * x where x is the predecessor
12:58:59 <mauke> x is shared
13:00:00 <mikey22> is this just a special ghc optimization or does the language require it?
13:00:01 <johnw> Gentmen: how would it be able to use the results computed from fib 35?
13:00:11 <johnw> Gentmen: there is no communication between the two tasks
13:00:14 <mauke> mikey22: neither, I think
13:00:21 <arkeet> mikey22: first read http://www.vex.net/~trebla/haskell/lazy.xhtml (at least understand the notation)
13:00:33 <arkeet> and then http://puu.sh/isDAc/a70bc263c5.jpg
13:00:34 <mauke> mikey22: it doesn't require any compiler smarts
13:00:43 <mauke> it's pretty easy to implement in an interpreter or whatever
13:00:59 <Gentmen> johnw: that part makes sense to me - that there's no sharing. but I don't understand where the parallelization comes into play
13:01:09 <frerich> arkeet: You didn't just draw and photograph that yourself, did you?
13:01:13 <arkeet> I did.
13:01:16 <johnw> Gentmen: the two units of work are happening at the same time
13:01:22 <frerich> arkeet: Nice :-)
13:01:29 <johnw> the total is 2.63s, but the wall-clock time should be 1.90s
13:01:42 <mikey22> :). I will check it out
13:01:47 <johnw> print the actual start and end times, and that will be clearer
13:02:14 <mikey22> arkeet: what is your take btw, does the language require this optimization?
13:02:17 <arkeet> no
13:02:22 <mikey22> shame
13:02:23 <Gentmen> johnw: when calculating x and y with rpar and rseq, respectively, I understand that the function returns dependent upon the length of y (due to rseq)
13:02:44 <mauke> "optimization" is not what I'd call it
13:02:45 <arkeet> this isn't really an optimization
13:04:06 <breadmonster> :t (^.)
13:04:07 <lambdabot> s -> Getting a s a -> a
13:04:45 <mikey22> what is it then?
13:04:50 <arkeet> mikey22: haskell (the language standard) doesn't specify any particular evaluation strategy
13:04:51 <Gentmen> johnw: so { x <- rpar ... ; y <- rseq ..; ...}  does not mean that x and y are calculated/handled separately - it's simply a matter of returning from `runEval` and `print`?
13:04:59 <arkeet> but ghc uses lazy evaulation
13:05:07 <arkeet> and this is what lazy evaluation gets you
13:05:12 <johnw> Gentmen: I'm actually not sure what you're asking
13:05:22 <mikey22> I see
13:05:27 <Gentmen> johnw: maybe I'm not either (let me follow your example first and print out the times)
13:05:31 <Gentmen> johnw: thanks
13:05:53 <frerich> mikey22: https://wiki.haskell.org/Lazy_vs._non-strict may be interesting
13:06:20 <arkeet> mikey22: anyway, in this particular case, each unevalated element of the list is just a thunk 
13:06:28 <arkeet> that when evaluated, just multiplies the previous element of the list by 2
13:06:41 <arkeet> but once an element is evaluated
13:06:45 <arkeet> it doesn't need to be evaluated later
13:07:00 <arkeet> er
13:07:07 <arkeet> should I be saying forced, idk
13:07:15 <Gentmen> also, if someone could please check out my question on profiling 2 simple haskell programs - http://stackoverflow.com/questions/30899782/profiling-two-functions-that-sum-large-list. thank you in advance
13:07:18 <arkeet> same thing I guess.
13:09:01 <mikey22> oh
13:09:27 <Peaker> If I want to break the encapsulation of Data.Map (for local temp debug hack), duplicating its data declaration and using unsafeCoerce should work, right?
13:10:05 <mikey22> I thought I got it, but nope. when I am manually replacing a with maps I am not seeing it. I will read those links and try again
13:10:16 <arkeet> mikey22: in particular, if some element of the list has already been evaluated, then evaluating the next element only takes 1 multiplication
13:10:24 <arkeet> because it just looks at the (already evaluated) previous element
13:11:14 <johnw> Gentmen: this is just a guess, but: faster is forcing the whole list into memory, and then holding it there, whereas single is forcing nothing, meaning GHC might be fusing away the list entirely.  Checkout the difference in maximum residency of your two timing samples
13:11:29 <mikey22> arkeet: but doesnt each element have its own computation? map just isolates each element individually
13:11:37 <arkeet> ?
13:11:52 <arkeet> map doesn't do any computation.
13:11:55 <arkeet> computation does computation.
13:12:06 <mikey22> the function passed to map does not even see previous element
13:12:18 <arkeet> but the list passed to map does.
13:12:31 <arkeet> this is where you look at my picture.
13:12:39 <mikey22> it gets each element, one by one
13:12:59 <arkeet> no
13:13:04 <mikey22> ok. I will read that link first
13:13:06 <arkeet> map doesn't do anything one by one.
13:13:12 <mikey22> before looking at it
13:13:15 <arkeet> it just does
13:13:20 <arkeet> map f (x:xs) = f x : map f xs
13:13:32 <frerich> mikey22: What I only now realize -- with arkeets vivid drawing ;-) -- is that each nested 'map' call only works on the tail of the list of course.
13:13:37 <mikey22> it passes each element to f one by one
13:14:34 <Gentmen> johnw: what's 
13:14:41 <arkeet> (my drawing isn't 100% accurate. the (*2) is also shared among all the list elements. but who cares :-) )
13:14:42 <Gentmen> johnw: *maximum residency?
13:14:44 <frerich> mikey22: And when I write 'the list' I mean the exact same list object, in memory. This 'exact same list' thing is something one cannot represent by just expanding the 'map' definition (i.e. "equational reasoning").
13:15:21 <frerich> mikey22: If you expand the definition of 'map' (like I initially did), you always start with a new map starting with '1' and then apply (*2) repeatedly.
13:17:15 <mikey22> ok, I will read all the links that was given to means the I will hopefully have an epiphany
13:17:30 <mikey22> that was a horrible sentence
13:17:37 <arkeet> I got the idea :-)
13:17:40 <frerich> Well, I certainly did a mental one-eighty. :-)
13:18:17 <johnw> Gentmen: the largest amount of memory used by the program at any point in time
13:18:29 <johnw> Gentmen: in your case, single uses 48K and faster uses 400M
13:18:34 <rui> Do you guys find it easy to open some hackage code made by others and understand it from the code + haddocks?
13:18:40 <johnw> Gentmen: the GC overhead of 400M is enough to account for the performance difference
13:18:52 <johnw> Gentmen: (perhaps)
13:19:52 <arkeet> that's a lot of bytes copied during GC
13:22:49 <johnw> yeah, 1.47G vs. 363K!
13:22:54 <arkeet> my guess is that 'faster' has to keep the entire spine of the first half of the list in memory
13:23:09 <arkeet> or uh
13:23:31 <arkeet> actually maybe the entire list, because of 'length list'
13:23:45 <arkeet> curious what happens if you just change that to 5000000
13:24:32 <sccrstud92> arkeet: i would like to see it if they just do drop half and take half
13:24:34 <arkeet> but the splitAt would make it have to keep the first half anyway
13:25:11 <arkeet> sccrstud92: that would be good to try too I guess.
13:25:16 <sccrstud92> has anyone seen (.).(.) called the "triple nipple" or did I just make that up?
13:25:21 <arkeet> anyway, the problem is that lists.
13:32:37 <johnw> sccrstud92: not only have I not seen that, I've never seen anyone use the operator ((.).(.)) in actual code, so I'm quite mysified as to its cult following.  Under its other name (.:), I've seen it a few times
13:33:53 <frerich> sccrstud92: I heard the names 'boobs operator' (ahem) or 'owl operator' (kinda cute), too. 'triple nipple' is new to me.
13:34:31 <albeit> Why does my resident memory usage steadily increase whenever I use "Network.WebSockets.send"?
13:34:41 <kadoban> It's catchy, but seems pretty ambiguous.
13:37:02 <Welkin> :t (.:)
13:37:03 <lambdabot>     Not in scope: ‘.:’
13:37:03 <lambdabot>     Perhaps you meant one of these:
13:37:03 <lambdabot>       ‘.’ (imported from Data.Function),
13:37:10 <Welkin> :t ((.).(.))
13:37:11 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:37:17 <sccrstud92> :t Data.Composition.(.:)
13:37:18 <lambdabot>     Not in scope: data constructor ‘Data.Composition’
13:37:19 <lambdabot>     Not in scope: ‘.:’
13:37:19 <lambdabot>     Perhaps you meant one of these:
13:37:51 <sccrstud92> :t Data.Composition..:
13:37:52 <lambdabot> parse error on input ‘Data.Composition..:’
13:40:47 <kadoban> Heh ...
13:41:08 <geekosaur> :t (Data.Composition..:)
13:41:09 <lambdabot> Not in scope: ‘Data.Composition..:’
13:41:29 <geekosaur> and I think that's the wrong module anyway?
13:42:05 <geekosaur> hm, not one from the standard module set in any case
13:42:41 <sccrstud92> its not in base
13:42:47 <sccrstud92> that is my guess why its not working
13:43:03 <geekosaur> we have more than base, but it's not in the platform either
13:43:13 <geekosaur> and hayoo is still ill :/
13:43:39 <quchen> But Hayoo was my medicine for Hoogle's bad search results! :-(
13:44:03 <albeit> If my program is showing steadily increasing resident memory usage, but profiling shows constant heap usage.... how does that happen?
13:45:26 <m_ryan> hi can anyone help me with my case? here is the code http://lpaste.net/134686? it's about IORef using yesod.
13:45:44 <koala_man> albeit: mmapped files being gradually loaded?
13:46:29 <albeit> koala_man: What do you mean by mapped file?
13:46:47 <breadmonster> does anyone use classy Prelude?
13:48:19 <kadoban> I'm classy enough on my own. (no, but it sounds vaguely neat)
13:48:32 <geekosaur> albeit, mmaped
13:48:45 <koala_man> albeit: mmap, lazy loading of files into memory. I don't know if/when a haskell executable uses it, but I think it would show the behavior you describe
13:49:13 <geekosaur> that said if they were using mmapo they';d know it; the only way to do that currently is various add-on packages which have "mmap" in their name
13:49:23 <aweinstock> albeit: "man 2 mmap"
13:49:38 <aweinstock> (the two m's isn't a typo, it's short for memory-mapped)
13:49:43 <albeit> Yeah no mmap for sure. Just using WebSocket and Snap
13:49:44 <koala_man> so none of haskell's lazy io uses it?
13:50:10 <lilred> Hi fellas
13:51:14 <lilred> Rendel & Ostermann´s ¨Invertible Syntax Descriptions¨ describes a partial isomorphism as a pair of partial functions a -> Maybe b and b -> Maybe a. I´m wondering what the terminology (mathematical or otherwise) would be for a pair of functions a -> b and b -> Maybe a.
13:51:52 <lilred> My brain is saying ¨adjunction¨, which is unfortunate because I don´t understand adjunctions.
13:52:15 <breadmonster> lilred: an injective function, if we're not talking about category theory.
13:52:28 <mikey22> arkeet: awesome drawing, I understand it now. map applies f to prior element and then calls itself recursively with the tail (which points at the element we just computed)
13:53:07 <m_ryan> hi can anyone help me with my case? here is the code http://lpaste.net/134686? it's about IORef using yesod.
13:53:08 <lilred> breadmonster: injection of b onto a? That sounds right
13:53:18 <breadmonster> yup.
13:54:37 <johnw> an adjunction would be: F a -> b =~ a -> G b, for a free functor F and a forgetful functor G
13:55:44 <lilred> and if I want to get categorical I can call it a monic
13:57:44 <mikey22> man haskell is such a fun language :)
13:59:56 <lilred> so I guess the secret to the parsing/pretty-printing relationship is that pretty-printing is an injection, and parsing is its inverse with a bit of forgetfulness added
14:00:36 <lilred> There´s a completion lurking somewhere in there, but I´m not very knowledgeable about those
14:01:07 <Hafydd> Printing is an injection, is it?
14:01:17 <breadmonster> Does anyone work with Snoyman's stuff?
14:01:22 <breadmonster> Classy prelude to be precise?
14:01:44 <lilred> Hafydd: pretty-printing an AST should be an injection!
14:01:56 <johnw> breadmonster: I have in the past, but don't any longer
14:02:33 <lpaste> breadmonster pasted “Type encounters of the third kind” at http://lpaste.net/134688
14:02:46 <breadmonster> johnw: ^ wtf...
14:03:26 <johnw> I used to use classy-prelude, but now I don't
14:03:35 <quchen> Hafydd: Not necessarily, depending on what you mean with "pretty" and "AST". GHC's AST contains a lot of information that might not be necessary, but useful for internal use.
14:03:50 <breadmonster> johnw: Why won't a simple fold work? :(
14:03:53 <Hafydd> Yes.
14:04:11 <quchen> And then there's insignificant whitespace and what not.
14:04:13 <johnw> use foldl'
14:04:19 <Peaker> Data.Map.Base defines "data Map k a = ..   with fully strict fields. i.e: The spine should be always strict.  Yet somehow, in my program, if I force the spine (via: length (Map.keys m) `seq` ...) it makes things work correctly
14:04:34 <johnw> foldl is almost always a bad idea, so that's the sort of thing Snoyman would have excluded from his export list
14:04:39 <Peaker> as if thunks are somehow hiding in the Map's spine.. how is that possible?
14:05:57 <quchen> Peaker: What happens when you only force the map itself?
14:06:01 <Peaker> If I don't force the spine, I believe there's thunk buildup (I do repeated inserts into the map, which is a strict record fields of an IORef being updated with atomicModifyIORef')
14:06:21 <Peaker> quchen: still thunk buildup, even if I force Map.keys  (rather than (length (Map.keys ..)))
14:06:38 <quchen> Huh
14:06:57 <breadmonster> johnw: Got it.
14:07:13 <breadmonster> It works, I just don't get what fold is used for.
14:07:17 <hiptobecubic> Is there a good example of when foldl is the right choice?
14:07:33 <johnw> Data.Foldable.fold is the generalized form of mconcat
14:07:44 <Peaker> quchen: I'm not sure how to debug this.. changing "containers" itself (to add traces and what not) would be nice, but the deps: ghc<th<containers mean reinstalling containers is a problem
14:07:45 <quchen> hiptobecubic: reverse
14:08:09 <breadmonster> hiptobecubic: Umm yeah `reverse = foldl (flip (:)) []
14:08:09 <johnw> hiptobecubic: when you need left-associativity
14:08:27 <hiptobecubic> johnw, i mean as opposed to foldl'
14:08:30 <breadmonster> johnw: I think (s)he means as opposed to foldl'
14:08:41 <Peaker> "vacuum" since a bit ancient, I could try to revive that so I can "see" the thunks
14:08:45 <hiptobecubic> breadmonster, speak for yourself!
14:08:48 <hiptobecubic> :)
14:09:04 <Peaker> is there a (very unsafe) way to differentiate an unevaluated thunk from a value?
14:09:14 <quchen> Peaker: Do you have a minimal broken example?
14:09:19 <Peaker> some sort of:   unsafeGetThunkState :: a -> ThunkState
14:09:20 <quchen> Sounds like an interesting bug. :-)
14:09:24 <breadmonster> hiptobecubic: iirc, foldl' evaluates everything to WHNF so there's no use in using foldl' to reverse a list, since the top level constructor is (:)
14:09:45 <Peaker> quchen: I tried generating a small example and failed :(  Fortunately the code with the bug is relatively independent, I believe
14:09:45 <johnw> a recently example from code I wrote using template-haskell: foldr1 (\x rest -> AppT (AppT ArrowT x) rest) types; but foldl' AppE (VarE fun) (map VarE args)
14:09:53 <quchen> You can't write reverse with foldl'.
14:09:55 <breadmonster> Peaker: What is this library that allows you to play with thunks?
14:10:05 <Peaker> breadmonster: I am asking if there is one, I need it
14:10:15 <breadmonster> > foldl' (flip (:)) [] [1,2,3,4]
14:10:15 <johnw> because type application is right-associative, while function application is left-associative
14:10:16 <lambdabot>  [4,3,2,1]
14:10:30 <johnw> (by type application I meant to say the function arrow)
14:10:31 <breadmonster> ^
14:10:40 <breadmonster> quchen: That seemed to work...
14:11:41 <Peaker> quchen: https://github.com/Peaker/lamdu/blob/eyal/hack/Lamdu/Eval/Background.hs#L67  is the mysterious thunk container field
14:11:45 <quchen> Ah, I put the strictness in the wrong place again in my head. eeh
14:12:03 <Peaker> Data.Map.Strict is the import
14:12:05 <quchen> foldl' forces all the (:), not the list elements themselves. Pardon me.
14:12:26 <quchen> Ah, Lamdu, nice :-)
14:12:36 <breadmonster> Peaker: Are you importing Data.Map?
14:12:46 <Peaker> breadmonster: see the code, nope :) I import Data.Map.Strict
14:12:57 <Peaker> quchen: https://github.com/Peaker/lamdu/blob/eyal/hack/Lamdu/Eval/Background.hs#L111 <-- this forceMapSpine makes the problem go away
14:13:12 <Peaker> quchen: but forceMapSpine should really be an O(N) no-op
14:13:23 <Peaker> (if map spines are always strict, as the data type seems to be claiming)
14:13:32 <quchen> Denontationally, you mean?
14:13:41 <breadmonster> quchen: Does it matter if I use the strict or lazy versions of Map if I know all the elements I want to insert at compile time?
14:13:55 <quchen> I don't know, and I don't think so
14:14:11 <Peaker> quchen: what do you mean by that question?
14:14:12 <breadmonster> I'm using a Map to save boilerplate.
14:14:21 <quchen> Peaker: I meant breadmonster 
14:14:32 <quchen> I think.
14:14:56 <breadmonster> quchen: thanks.
14:15:04 <quchen> Peaker: forceMapSpine should really be id, I agree.
14:16:10 <Peaker> It's preventing (what appears to be) a thunk buildup
14:16:51 <buff3r> hello all, new to haskell, i'm trying to use a haskell binding to tesseract library (https://gist.github.com/buff3r/3a04815608fc0f2e9acd)
14:16:57 <buff3r> any help is appreciated
14:17:18 <quchen> Peaker: Could you unsafeCoerce the Size information out of your Map, and then force that?
14:17:37 <quchen> I'm wondering which part the "length" call actually forces, since everything should be fully evaluated 
14:18:33 <Peaker> quchen: you think some thunk may be lurking in the size field?
14:19:02 <quchen> Absolutely not! But I can't come up with anything better :-s
14:19:16 <quchen> I mean the Size field is an unpacked Int
14:19:24 <Peaker> Well, now that I had cabal hell and rebuilt everything with -O0, I'm suspecting it behaves differently
14:19:25 <quchen> Not a lot of surprises to be found there
14:20:05 <quchen> Pity Tibbe isn't here, I think he knows his way around containers quite well
14:20:44 <Peaker> I have another theory now that makes the Map innocent, I need to test it :)
14:21:34 * quchen waits
14:22:11 <Peaker> oh, I think I might be debugging too late in the night, I forgot I switched branches, heh :)
14:22:20 <Peaker> that explains the different behavior! :)
14:22:46 <quchen> Grrrr
14:22:54 <quchen> What an unsatisfying solution! :-)
14:23:19 <quchen> I'm sure one could have written a nice article about "hidden thunks in unboxed types" :-D
14:23:31 <quchen> There goes my ICFP ticket
14:23:39 <Peaker> :-D
14:24:16 <buff3r> hi could someone explain to me how to lift a text value out of this particular monad? (http://lpaste.net/134689)
14:25:11 <quchen> "lift out of"?
14:25:22 <quchen> You mean bind a text value generated by a monadic computation?
14:25:24 <buff3r> sorry i'm new, that's maybe not even the right phrasing
14:25:51 <quchen> lifting is typically something you do "into" something. "fmap f" lifts "f" into the Functor context, for example.
14:26:25 <buff3r> i see
14:26:32 <quchen> buff3r: What part of the code is the question about?
14:27:05 <quchen> Or what is it you want to do exactly? Get a "Text" when you have a "TessAPIState Text"?
14:27:13 <buff3r> quchen: yes exactly
14:27:17 <quchen> <- does that
14:27:25 <quchen> Or >>=, which is pretty much the same
14:27:31 <quchen> text <- tessApiThing
14:27:44 <quchen> That'll give you access to the Text contained in your TessApiState
14:27:54 <mizu_no_oto> do and <- are syntactic sugar for >>= and a few other functions
14:28:06 <buff3r> hmm 
14:28:10 <quchen> FSVO "few"
14:28:25 <quchen> <- is pretty direct sugar for >>=, modulo fail which we're trying to get rid of right now
14:29:05 <mizu_no_oto> >>= :: TessAPIState Text -> (Text -> TessAPIState b) -> TessAPIState b
14:29:13 <quchen> Yep
14:29:41 <quchen> Assuming TessAPIState is a Monad, of course
14:29:50 <mizu_no_oto> So you can access the Text as long as you generate another TessAPIState value
14:29:58 <buff3r> i think maybe my basic assumption might be wrong
14:30:14 <mizu_no_oto> Some monads also have a run method
14:30:52 <quchen> Arguably, yes. Most don't.
14:30:55 <mizu_no_oto> > runST (return 5)
14:30:56 <lambdabot>  5
14:31:02 <Haskellfant> I remember reading here that Cont is an adjunction, but I can't find any information about it. What is it adjoint to?
14:31:13 <buff3r> this one has a runState, is that relevant? (https://github.com/surdus/htesseract-ocr/)
14:33:10 <mizu_no_oto> buff3r: kinda.  If you notice, runState :: state -> m (x, state) and  TessAPIState = StateM TessBaseAPI IO
14:33:13 * hackagebot stack 0.0.3 - The Haskell Tool Stack  http://hackage.haskell.org/package/stack-0.0.3 (DanBurton)
14:33:15 * hackagebot hsqml-demo-notes 0.3.3.0 - Sticky notes example program implemented in HsQML  http://hackage.haskell.org/package/hsqml-demo-notes-0.3.3.0 (RobinKay)
14:34:34 <mizu_no_oto> so runState (return "use overloaded strings so this is Text not String") :: TessBaseAPI -> IO (Text, TessBaseAPI)
14:34:56 <ioc> hi all
14:35:05 <mizu_no_oto> And there's no way to run an IO action to get a Text from it
14:35:42 <ioc> i have one hash
14:35:53 <ioc> can you help me?
14:36:04 <buff3r> okay
14:36:26 <Peaker> quchen: trying unsafeCoerce wizardry to look at the values.. I could really really use a "isThunk" function now
14:36:39 <ioc> $2y$10$Bu1aLY7CdmnZlP4qCM8hoO16A4nrygjGwl8ETFNdVxj9qDm4wXfYu
14:37:10 <ioc> is it
14:37:23 <sinelaw> what does "global constraint requires == 4.8.0.0" come from?
14:37:28 <sinelaw> *where
14:38:34 <sinelaw> never mind, had a leftover cabal.config
14:38:59 <Peaker> quchen: this unsafeCoerce trick is really nice
14:39:05 <Peaker> quchen: finally a way to peek under the hood :)
14:39:41 <quchen> I'm not sure whether you should call it nice publically ;-)
14:41:08 <ioc> can you help me?
14:42:02 <ion> ioc: $4$vn0ykUOd$GMFJ2E+rzUfoGk35mAIZKJa+w8Q$
14:42:35 <ioc> $2y$10$Bu1aLY7CdmnZlP4qCM8hoO16A4nrygjGwl8ETFNdVxj9qDm4wXfYu
14:42:37 <ioc> this
14:42:47 <quchen> This channel is about Haskell.
14:42:57 <the-kenny> ioc: this is bcrypt. More I don't know.
14:43:03 <bananagram> if you want to reverse the hash, that will cost money
14:43:17 <ion> quchen: You should hash your messages, it seems that is the preferred discussion format for him.
14:43:27 <the-kenny> ion: lol
14:43:29 <ioc> okkei
14:43:47 <quchen> ion: I use a hash function all the time. It's perfect, but at the cost of being easy to reverse engineer.
14:43:49 <ioc> where is the channel from my hash?
14:44:20 <ioc> hi
14:44:46 <Sindriava> Hi! Does anyone have any experience with Entity Component Systems?
14:44:54 <sccrstud92> is the instance Monoid v => Monoid (Map k v) (or even better Semigroup v => Monoid (Map k v)) provided somewhere?
14:45:37 <Peaker> sccrstud92: it would overlap with the crappy Monoid instance in Data.Map
14:45:49 <quchen> sccrstud92: unionWith (<>) does the trick
14:46:11 <quchen> If you need the functionality, and not an actual instance
14:46:11 <sccrstud92> quchen: not if it needs a monoid instance =P
14:46:24 <quchen> Map already has a Monoid instance, with left-biased union as <>
14:46:27 <sccrstud92> not good enough if you need for foldMap for example
14:46:49 <sccrstud92> a newtype that provides this would be fine with me
14:47:08 <sccrstud92> is that in a library somewhere already?
14:47:16 <quchen> Not that I know of.
14:47:22 <sccrstud92> damn
14:47:30 <sccrstud92> its the same problem as with Maybe
14:47:34 <sccrstud92> and it makes me sad
14:47:55 <quchen> I'm not sure where Semigroup is going, but we shouldn't give up hope
14:48:11 <quchen> But even when we have Semigroup we won't get that Map Monoid instance
14:48:33 <sccrstud92> do many people rely on the broken map monoid instance?
14:48:33 <quchen> I don't think Containers has any newtypes for other instances
14:48:44 <quchen> It's not broken
14:48:56 <sccrstud92> bad, then
14:49:00 <quchen> The current Map Monoid instance is perfectly sensible
14:49:07 <sccrstud92> for some things
14:49:21 <sccrstud92> but since there are multiple perfectly sensible ones
14:49:26 <Sindriava> I'm trying to write a simple game engine in Haskell, but implementing an ECS is the first wall I've hit
14:49:33 <sccrstud92> any one we pick is "bad" in some snese
14:50:06 <quchen> Being ambiguous doesn't make choosing bad.
14:50:34 <quchen> Your Monoid constrains the elements to be monoidal, which is much worse than an arbitrary but general choice.
14:50:52 <Hijiri> Sindriava: here is a blog post on implementing an ECS in haskell - http://fho.f12n.de/posts/2014-10-25-easily-extensible-entity-enigma.html
14:51:18 <awoserra> major mobile app vuln discover puts billions of records at risk - news.
14:51:20 <Sindriava> Hijiri: Thanks, I'll take a look!
14:51:26 <Hijiri> it's more of a proof of concept, and also uses extensible-effects, but it might give you some ideas
14:51:49 <Sindriava> Hijiri: I'm aiming for something like `makeEntity <$> color White <*> char '@' <*> position 0 0`
14:52:22 <Hijiri> Sindriava: I'm not sure that would work out well
14:52:30 <Hijiri> makeEntity would need to have variable argument number
14:52:38 <Hijiri> because you might want more or less properties associated with it
14:52:44 <Sindriava> Yeah, that's the main problem I've hit
14:53:15 <Sindriava> well, what I've come up with is to make 'component' similar to an array
14:53:16 <sccrstud92> quchen: the thing is the Semigroup v => Monoid (Map k v) instance is stricly more general that the other two
14:53:18 <Sindriava> *list
14:53:26 <Peaker> quchen, breadmonster: http://hackage.haskell.org/package/vacuum-2.2.0.0/docs/GHC-Vacuum.html#v:closureType <-- ooooh
14:53:27 <sccrstud92> you can recover the other two from it
14:53:29 <sccrstud92> right?
14:54:01 <Sindriava> in that 'pure x = Component x' and Component is a monoid, whereas you can append two components to form a bigger component that has both the values
14:55:05 <Sindriava> Hijiri: More specifically, you wouldn't have "Entity [Component]" but "Entity Components", where Components is a builder for components
14:55:10 <Hijiri> that sounds more like a recordey thing than an entity, but I don't have a lot of experience with ECS
14:55:25 <Sindriava> Hijiri: Yeah, might be, I'm not sure how ECS works to be honest
14:55:42 <Hijiri> the way I understand ECS is that the idea is that you give each entity an Id, and you index some properties on Ids
14:55:45 <quchen> Peaker: Huh?
14:55:59 <Peaker> quchen: this can tell me which things are thunks
14:56:05 <Sindriava> Hijiri: I suppose that's true. What I'm aiming for is a bit different then
14:56:06 <Peaker> quchen: and which are already evaluated
14:56:11 <Hijiri> the way the blog post implements it is by requiring a "context" of maps from IDs to values
14:56:21 <quchen> Peaker: The documentation is abysmal
14:56:42 <quchen> Oh, my thing is a THUNK_2_0, thanks :-s
14:56:45 <Peaker> :)
14:57:02 <Sindriava> Hijiri: What I want is the code to be really frictionless. "orc = makeEntity <$> color Green <*> char 'o' " is really neat
14:57:26 <Sindriava> Hijiri: Is it possible to have a data structure of arbitrary types in haskell?
14:57:45 <Hijiri> Sindriava: what do you mean?
14:58:02 <liyang> Sindriava: you mean like, a list of things with different types?
14:58:04 <Hijiri> there are a couple things I can think of that would fit that
14:58:10 <sccrstud92> Sindriava: have you heard of using lenses and type classes for this type of thing?
14:58:11 <Hijiri> there are het lists
14:58:11 <Sindriava> liyang: Yep
14:58:16 <quchen> Peaker: That's the unsafest thing I've seen in a long time! :-D
14:58:21 <sccrstud92> i just watched a talk about it
14:58:22 <Sindriava> sccrstud92: Nope"
14:58:31 <Hijiri> there is also Dynamic, which you have to check the type of each time
14:58:35 <liyang> Sindriava: Yes, but that is in general a bad idea.
14:58:40 <Sindriava> liyang: I see.
14:59:19 <liyang> Sindriava: and probably not necessary. Describe your problem and we'll see if we can suggest a suitable safer and less messy alternative.
14:59:20 <sccrstud92> Sindriava: the talk it here https://www.youtube.com/watch?v=GZPup5Iuaqw. it focuses on monad transformers instead of entities, but I think it is a more general pattern that you can use
14:59:31 <Sindriava> liyang: Thanks! So, here goes
14:59:56 <Sindriava> liyang: I want to have an Entity, which I can construct from arbitrary data components and then be able to check if the entity has that component in it
14:59:58 <buff3r> are there better alternatives to monad transformers?
15:00:34 <Peaker> quchen: now combine that with unsafeCoerce of Data.Map to my own type :)
15:00:34 <Hijiri> buff3r: extensible effects is one alternative to monad transformers, but I hear it has some performance issues
15:00:57 <liyang> Sindriava: how arbitrary, exactly?
15:00:58 <Hijiri> also if you want the typeclasses transformers often are instances of, you can make a custom monad and implement instances for them
15:01:27 <rasen> Hello, guys! Can you share your experience with FRP GUI libraries? I can't choose one
15:01:33 <Sindriava> liyang: Well… Arbitrary. They can behave the same (e.g. be a typeclass, I guess)
15:01:49 <Sindriava> liyang: But they have to be able to hold arbitrary data, like color, position, speed… etc.
15:01:53 <Sindriava> AI algorithms
15:02:06 <quchen> Peaker: I'll escape to bed. Good night, and may the gods be with you on your unholy journey
15:02:25 <quchen> And don't forget to rebuild after pulling :>
15:02:31 <bananagram> that would make it a holy journey
15:02:57 <Sindriava> liyang: For example "makeEntity $ color Red <*> position 0 0 <*> char '@' "
15:03:42 <Sindriava> liyang: That would combine Color, Position Int Int and Char Character into a single Components monoid, i guess
15:03:49 <Sindriava> and then use that to create an entity
15:04:08 <ion> Sindriava: This may or may not be what you are after: given “data Foo where { Foo :: SomeClass x => x -> Foo }” (an existential type) you can store values of arbitrary types that are in that class. The only thing you can do with the extracted values is to apply methods of the class to them.
15:04:28 <ion> values extracted from a Foo, that is
15:05:05 <Sindriava> ion: So all the components would have the same interface?
15:05:29 <Sindriava> I'll make a simple pseudocode example and paste it here, to give a better idea of what I'm after!
15:06:22 <Peaker> quchen: :)
15:06:34 <Peaker> quchen: Vacuum seems like too much work to get going ATM, I'll get back to it if other trickery cannot detect the issue
15:10:26 <ion> @let data Foo where { Foo :: (Num a, Show a) => a -> Foo }; deriving instance Show Foo
15:10:27 <lambdabot>  Defined.
15:10:36 <ion> > map (\(Foo x) -> Foo (x + 42)) [Foo (42 :: Integer), Foo (42 :: Complex Double)]
15:10:38 <lambdabot>  [Foo 84,Foo (84.0 :+ 0.0)]
15:12:23 <Peaker> when compiling with -O0, do data types have a different memory representation than -O1 ?
15:12:44 <Sindriava> Ok, here goes
15:12:46 <Sindriava> ion: http://lpaste.net/134694
15:13:12 <Sindriava> ion: That's the rough sketch of what i want the code to look like
15:13:52 <Sindriava> ion: It's pretty neat in my opinion. But I don't know whether it's feasible / possible / a good idea in Haskell
15:14:33 <Peaker> I've got a nice little unsafeCoerce from Data.Map to my own copy of the type, that seems to work with -O, but fails with -O0
15:14:42 <ion> It seems data Entity = Entity { entityAppearance :: Maybe Appearance, ... } would suit that pseudocode.
15:14:49 <c_wraith> Peaker: I don't believe so in general..  However, I believe -O1 (on new-enough versions of GHC) will automatically unpack "small" fields
15:15:34 <c_wraith> err, "small" *strict* fields
15:16:01 <Sindriava> ion: Yeah, but that results in a lot of code duplication.
15:16:15 <Sindriava> ion: Entity has to be defined with all the possible Components built in
15:16:43 <Sindriava> ion: Ideally, the components could be completely separate from any other part of the game logic, except the systems that check for it
15:17:37 <Peaker> c_wraith: data FakeMap k a  = Bin {-# UNPACK #-} !Int !k a !(FakeMap k a) !(FakeMap k a) | Tip   <-- must be compiled with -O or unsafeCoerce crashes
15:17:50 <Peaker> c_wraith: With -O it can peek inside a Data.Map :)
15:18:06 <c_wraith> Peaker: unsafeCoerce to what?
15:18:13 <c_wraith> Oh, nevermind.
15:18:22 <c_wraith> To Data.Map.Map, of course.
15:18:29 <Peaker> (from Data.Map)
15:18:30 <Sindriava> ion: I think that in order for that to work, I'd need to pass around types as values
15:18:43 <Peaker> I'm trying to figure out where the lazy thunks are hiding inside my Data.Map
15:19:59 <shachaf> Yes, GHC ignores UNPACK without -O.
15:20:10 <c_wraith> well, that answers that
15:20:20 <shachaf> rwbarton and I ran into that with exactly this data type.
15:21:13 <shachaf> It's pretty annoying that -O can affect memory layout like that even when you explicitly specify what you want.
15:21:43 <Peaker> shachaf: ah :) Thanks
15:21:47 <albeit> Is there any way to view how many Haskell threads are running in a program?
15:21:51 <c_wraith> Peaker: Assuming you're using Map functions, the only place you can hide a thunk is inside the a value
15:23:20 <Peaker> c_wraith: that's what I thought! but https://github.com/Peaker/lamdu/blob/eyal/hack/Lamdu/Eval/Background.hs#L107-L109 would thus need to be a no-op
15:23:27 <Peaker> c_wraith: but it affects the behavior of my program very much
15:23:57 <Peaker> (it makes the processing of the map happen in the right thread, rather than the main thread when it tries to read the results)
15:24:01 <shachaf> Peaker: One way to look at that is to dump the .hi file GHC generates.
15:24:13 <Peaker> shachaf: at the data type format?
15:24:27 <c_wraith> Peaker: assuming there aren't bugs, that should have the same effect on strictness as seq
15:24:40 <Peaker> c_wraith: but it doesn't, very weird! I've been debugging this for many hours
15:24:43 <shachaf> ==c_wraith
15:25:06 <Peaker> c_wraith: I read the source of Data.Map looking for hidden thunks in the spine, but I couldn't find any
15:25:17 <c_wraith> Peaker: that only makes sense if strictness annotations are broken.
15:25:40 <c_wraith> Peaker: or if you're not forcing even to WHNF on the thread you think you are
15:26:04 <Peaker> c_wraith: if I change the lines you saw about to just force the whnf, or even just force up to a depth <13 it behaves badly
15:26:46 <Peaker> but since I only force fields which are marked with ! in the data-type, indeed it must indicate either a bug in GHC -- or a very weird interaction somehow mediated by this change
15:29:54 <Peaker> ah, why did I think vacuum was hard to install? Git version installed in a snap
15:30:11 <shachaf> Do you have a small test case that reproduces this?
15:30:13 <Peaker> yay, now I'll be able to see what's lurking inside the Map :)
15:30:21 <Peaker> shachaf: No :(  tried & failed
15:30:37 <Peaker> If my attempts fail a few more hours I'll spend more time trying to get it to work
15:31:08 <shachaf> Peaker: You can also use :print in ghci to peek inside the Map.
15:31:14 <shachaf> Sometimes.
15:32:36 <Peaker> Yeah, getting lamdu to run in ghci is no fun :)
15:36:00 <Peaker> evil = unsafePerformIO . closureType
15:46:23 <devm> Cale: hey cale you there?
15:47:22 <Peaker> vacuum claims the Data.Map indeed has nothing but CONSTR and CONSTR_NOCAF_STATIC in its branches/tips
15:47:35 <Peaker> yet somehow just recursing over all of them somehow makes a difference!
15:47:39 <Peaker> (with -O0)
15:47:45 <c_wraith> devm: Even if he's not, lots of us help beginners out.  Just toss the question out there. :)
15:48:00 <c_wraith> Peaker: that's utterly bizarre.  Just making sure, you are using vacuumLazy?
15:48:18 <Peaker> c_wraith: I'm using unsafePerformIO with getClosureType
15:48:35 <Peaker> evil stuff, might give incorrect results for all I know
15:48:47 <Peaker> closureType, not getClosureType
15:48:58 <c_wraith> does vacuumLazy show the full graph?
15:49:12 <devm> c_wraith: alright, well I have this code http://pastebin.com/DnM8MEAt but im not sure how I can make the variable item in requisition accept both Books and Magazines
15:49:24 <Peaker> c_wraith: is that IntMap readable?
15:50:07 <c_wraith> Peaker: it is with vacuum-graphviz
15:50:52 <c_wraith> oh, man.  vacuum-graphviz doesn't support lazy.  That's a giant hole
15:51:27 <c_wraith> Still, I've hacked together code to dump the intmap in graphviz format pretty quickly before
15:52:15 <ReinH> devm: data Requisition = RBook Book | RMag Magazine
15:53:06 <ReinH> er, data RequisitionItem or so
15:53:26 <devm> Rbook and Rmag?
15:53:46 <ReinH> are the data constructors for the sum type you create to store either books or magazines
15:54:10 <devm> its to store both
15:54:14 <albeit> I'm running a websocket with Snap, and every call to sendTextData results in a space leak... resident memory usage increases but heap usage does not. How can I figure out where the leak is coming from?
15:54:38 <ReinH> devm: at the same time?
15:54:51 <ReinH> or one of either?
15:55:18 <devm> ReinH:  one of either, it should be able to depending if its a book or magazine store it
15:55:27 <ReinH> Right, thus the sum type
15:55:38 <ReinH> which encodes "either a book or a magazine"
15:55:39 <devm> ReinH: but I dont know how to make the variable item accept both
15:55:49 <ReinH> By making it accept the sum type
15:56:10 <ReinH> data ReqItem = RBook Book | RMag Magazine; data Requisition = Requisition { name :: String, item :: ReqItem }
15:56:37 <devm> ReinH:  ah alright, thanks , so I have to create a data for that, didn't know, thanks 
15:56:47 <ReinH> yw
15:57:21 <ReinH> This is the same as data Requisition = Requisition { name :: String, item :: Either Book Magazine }, but creating your own data types is useful
15:57:40 <ReinH> ("the same" meaing equivalent to, not equal to)
15:58:28 <ReinH> with Either Book Item you have things like Left book, Right mag, and you have to remember which is left and which is right. With constructors RBook and RMag it's obvious.
15:58:37 <ReinH> er, Either Book Magazine
15:59:30 <devm> ReinH: alright , creating the constructor seems better then
16:00:31 <ReinH> The names of the constructors provide humans with useful information, despite the type itself being equivalent to one using Either
16:01:45 <awoserra> anyone ever wondered why internet node addressing isn't done based on the network topology to achieve a path explicit in address?
16:02:40 <ReinH> awoserra: probably because you don't want an explicit path?
16:02:50 <awoserra> why not?
16:02:52 <ReinH> because network topologies are not sttic
16:02:55 <ReinH> *static
16:03:13 <awoserra> what if the addressing mechanism were dynamic, able to handle those changes?
16:03:24 <ReinH> Oh, like the routing system that we already have?
16:03:29 <awoserra> no
16:03:34 <ReinH> Yes, then  you can just remove the path part ;)
16:03:56 <awoserra> no
16:04:28 <ReinH> How does that work then?
16:04:40 <awoserra> path must be explicit in address.
16:04:47 <ReinH> Yes, you mentioned that
16:04:50 <ReinH> how does that *work*?
16:05:01 <ReinH> how does it cope with the dynamic nature of network topologies?
16:05:05 <ReinH> that path isn't guaranteed to exist
16:05:14 <ReinH> and it certainly isn't guaranteed to be the best path
16:05:32 <ReinH> what, then, is the point of encoding that path at all?
16:05:35 <awoserra> redundant failover for enterprise routers.
16:05:46 <awoserra> but
16:05:47 <ReinH> We already have that.
16:05:50 <awoserra> yes
16:05:52 <ReinH> What does the path add?
16:06:11 <awoserra> a minimal method of routing
16:06:13 <johnw> I'm also thinking this question has nothing to do with Hasekll
16:06:17 <ReinH> Also true
16:06:27 <ReinH> We can move it to #haskell-blah
16:06:50 <devm> ReinH: gives me this   Couldn't match expected type `ReqItem' with actual type `Books' 
16:07:06 <ReinH> devJunk: you have to use the data constructor RBook (or whatever you called it
16:07:07 <ReinH> )
16:07:28 <ReinH> the data constructor is a function RBook :: Books -> ReqItem
16:07:29 <devm> ReinH : ah alright  :p
16:07:33 <ReinH> you pass it a Books and it gives you a ReqItem
16:09:01 <awoserra> last word: a truly scalable method of routing.
16:09:51 <ReinH> To misquote Mencken, "for every complex problem, there is a solution that is clear, simple, and wrong"
16:10:03 <ReinH> (which is definitely relevant to Haskell ;)
16:10:33 <awoserra> yah i can't fight cliche.
16:10:49 * awoserra surrenders.
16:14:19 <awoserra> IP allocation is totally arbitrary and not scalable - ipv4 is critically lame and ipv6 seems to be a rework with MORE IPS... why NOT create an infinite numerical convention for one, and two, why not make it useful for routing?
16:14:40 <awoserra> because i thinkwe can
16:14:51 <johnw> awoserra: please take this discussion elsewhere
16:14:57 <johnw> it is not related to the channel's topic in any way
16:16:45 <awoserra> i know john. but it's in the same wider topic of correct code haskell shares. And, long since time to look at information systems as a whole in some respects. i have no investment in wedging everything i know into a nice set of blinders...
16:17:14 <johnw> even still, we are here to discuss Haskell, not every problem which might possibly be encoded in Haskell
16:17:25 <awoserra> or limiting my discourse with like minded people to a very narrow topic.
16:18:02 <awoserra> i'm just learning haskell :)
16:18:04 <awoserra> heheh
16:18:17 <johnw> and we're happy to take those questions
16:18:25 <awoserra> oki
16:19:35 <awoserra> tbh, where does one take these questions? #dns (jokes ;)
16:20:00 <awoserra> hopefully respectful jokes are permitted.
16:20:24 <Hafydd> )
16:20:30 <oconnore> awoserra: for opinions on why you don't need to think about > 2^64 addressable things, maybe #physics
16:21:28 <awoserra> nah, i have no problems with math.
16:21:35 <ReinH> heh
16:23:10 <ReinH> I've said everything I'm interested in saying on the subject. I agree with johnw.
16:23:18 <awoserra>  Cannot join to channel #logic
16:23:46 <awoserra> :/
16:29:33 <vikaton> are there things that are good to know before diving into haskell ?
16:29:46 <vikaton> so it can an easier road?
16:30:08 <Pamelloes> Assume every intuition and assumption you have is wrong.
16:30:23 <_slade_> Pamelloes: Even the assumption that every assumption is wrong?
16:30:27 <vikaton> hmm I wroed that wong lol
16:30:36 <vikaton> worded*
16:30:47 <vikaton> are there good things to learn*
16:30:51 <vikaton> like concepts etc
16:30:52 <Pamelloes> _slade_: Yes.
16:32:22 <rasen> vikaton: Just dive in! haskell is not that hard
16:32:43 <vikaton> If you say so
16:33:15 <vikaton> haskell seems really popular but there arent many job openings for it
16:33:18 * hackagebot intricacy 0.5 - A game of competitive puzzle-design  http://hackage.haskell.org/package/intricacy-0.5 (mbays)
16:33:19 <vikaton> besdies haskell, TX
16:33:20 * hackagebot nixfromnpm 0.1.0.2 - Generate nix expressions from npm packages.  http://hackage.haskell.org/package/nixfromnpm-0.1.0.2 (thinkpad20)
16:33:27 <vikaton> any reason why?
16:33:48 <awoserra> xmonad doesn't run ><
16:34:11 <awoserra> freebsd 10.1 release
16:34:13 <dmj`> vikaton: There's no one stopping you from learning haskell and then charging a company to build their systems in haskell. You can make your own haskell job.
16:34:46 <awoserra> xmonad --replace freezes my wm
16:35:12 <rasen> vikaton: I think because the haskell is less popular than other languages (i.e. there are fewer people who know it)
16:37:00 <awoserra> xmonad from tty0 says executeFile: does not exist...
16:37:18 <awoserra> xmonad: user error (openDisplay)
16:38:09 <awoserra> off-topic too?
16:38:12 <awoserra> ><
16:38:19 * hackagebot simple-nix 0.1.0.2 - Simple parsing/pretty printing for Nix expressions  http://hackage.haskell.org/package/simple-nix-0.1.0.2 (thinkpad20)
16:38:40 <vikaton> many people dont even know what FP is tbh
16:38:51 <rcyr> Flower Points!
16:39:01 <MarcelineVQ> obv. Flower Points
16:39:06 <Pamelloes> Flower Power.
16:39:14 <Pamelloes> Come on guys. Flower Points is so 2014.
16:39:40 <Axman6> The hip new thing are Coflowers in 2015
16:39:52 <Pamelloes> o.o
16:40:10 <Pamelloes> I must be behind, I've never used coflowers...
16:47:34 <awoserra> hmmm it's running via xinitrc, (not using a desktop manager), but it's empty... seems nothing to even launch a term or command from
16:47:43 <awoserra> anyone running xmonad?
16:48:10 <pacak> awoserra: I am
16:48:32 <awoserra> hotkey for killing xserver or launch a command?
16:48:42 <awoserra> from inside xmonad?
16:48:59 <pacak> ctrl-space or alt-space or win-space to launch a terminal by default.
16:49:05 <pacak> don't remember which one
16:49:18 <awoserra> nope, cpu is heating up
16:49:21 <pacak> Or one of those with enter
16:49:22 <awoserra> ><
16:49:30 <awoserra> nope ><
16:50:13 <pacak> mod + shift + enter?
16:50:14 <MarcelineVQ> some DE's let you use ctrl+alt+F2,F3,etc to open a new tty to work from as well
16:50:29 <pacak> mod - ctrl/alt/win...
16:50:31 <rasen> pacak: http://xmonad.org/tour.html
16:50:41 <awoserra> yah tried those first, it was hung, caught a message about not finding elements of the wm on the way out 
16:50:42 <MarcelineVQ> in case you wanted to kill a process that was messin with stuff
16:50:53 <awoserra> bar - not found
16:50:57 <awoserra> etc
16:52:08 <devm> reinH: you still there?
16:52:14 <awoserra> i did install the contrib pkg too
16:52:31 <geekosaur> terminal is mod-enter; default mod is alt
16:53:09 <geekosaur> make sure xterm is installed as it's the default terminal but many linuxes don't bother installing it any more
16:53:11 <awoserra> thx
16:53:28 <awoserra> yah 318
16:53:34 <awoserra> freebsd here.
16:54:04 <geekosaur> I think the metaport still installs xterm
16:54:47 <awoserra> hmmm, this site has much different content indicated in xinitrc, i'll try this
16:56:33 <vikaton> haskell is really old but its growing even more popular
16:56:55 <devm> How do I acess the data types in haskell? say if i have something like this http://pastebin.com/2EwLh9Er and given a name I want to return the books
16:57:05 <jabesed> vikaton: haskell is not _that _ old
16:57:21 <vikaton> its older than me :P
16:57:35 <jabesed> you're just too young
16:57:35 <vikaton> by 10 years
16:58:00 <vikaton> APL isnt that old
16:58:06 <hpc> First appeared 1990; 25 years ago
16:58:08 <vikaton> we're all just too young
16:58:29 <vikaton> make that 9 years older than me
16:58:54 <jabesed> vikaton: APL? that's from the 60s
16:59:18 <vikaton> its not that old
16:59:22 <hpc> languages newer than haskell include: zsh, python, visual basic, applescript, R, lua, ANSI Common Lisp
16:59:33 <lolisa> Well I'm a C++ and Coq programmer, and they are both about the same age with Haskell.
16:59:34 <vikaton> javascript?
16:59:48 <jabesed> hpc: visual basic?
16:59:53 <jabesed> hpc: really?
17:00:06 <vikaton> well I think haskell is growing more than C++, despite c++ being really popular
17:00:11 <hpc> first appeared 1991
17:00:20 <jabesed> hpc: oh damn, you're right, would have never guessed that one
17:00:41 <pavonia> devm: You can use pattern matches to get the individual values from the Requisition constructor
17:00:54 <arw> vikaton: well, growth is finite, and when you are already as big as c++, large growth rates are impossible.
17:01:02 <hpc> my favorite is haskell being older than ansi common lisp
17:01:50 <lolisa> I wont really care about age though, because the quality of a language doesnt seems to have much correspondence with it's age (I really want to use a language for example but wont know if it's correct in this channel, but I bet everyone had heard of some modern horrible language
17:02:08 <srhb> lolisa: Which one?
17:02:11 <hpc> haskell is old, but has evolved well over time
17:02:13 <hpc> like cheese
17:02:30 <lolisa> Any go user here?
17:02:35 <srhb> Ah.
17:02:40 <Hafydd> devm: the usual way to access fields of a value of a data type is by pattern matching, like in the following: [book | Requisition{ name="Sandra", item=RBook books) } <- exDBase].
17:02:55 <jabesed> hpc: meh...
17:03:00 <Hafydd> That should be "[books | ...".
17:03:26 <dmj`> lolisa: totally agree, biggest fallacy in our is that industry adoption levels and/or permeation == higher quality
17:03:35 <dmj`> in our industry is that*
17:03:37 <devm> Hafydd: Hm alright, thanks :)
17:04:18 <jabesed> hpc: still my language of choice... but looking at its evolution over the last 10 or 15 years, it's nice but I wouldn't say super impressive
17:04:35 <Hafydd> (Inside a list comprehension, a pattern binding using <- that doesn't match its source is ignored; otherwise, you'd have to use a case expression to analyse all the possible constructors of ReqItem.)
17:04:52 <jabesed> hpc: I mean what's the biggest accomplishment in terms of haskell evolution in the last 15 years?
17:05:15 <srhb> jabesed: 15? Maybe using monads for IO.
17:05:16 <dmj`> jabesed: I/O :) 
17:05:22 <dmj`> ... STM, FFI, the RTS
17:05:36 <jabesed> srhb: dmj`: no monads for IO 15 years ago?
17:05:43 <srhb> jabesed: Indeed.
17:06:05 <jabesed> srhb: dmj`: can't be.. are you sure? 
17:06:05 <hpc> it took 15 years of haskell research to finally invent a programmer that could fix java's type system
17:06:06 <LordBrain> is there a standard function to split a comma delimited bytestring?
17:06:08 <hpc> it was a partial success
17:06:16 <LordBrain> like words except you give it the ',' character...
17:06:21 <srhb> jabesed: Yep.
17:06:23 <dmj`> jabesed: haskell didn't have I/O for a while, according to SPJ it was 'quite embarrasing' the cpu got hot, but nothing actually 'happened'
17:06:35 <kadoban> Hehe
17:06:42 <Hafydd> Hahah.
17:07:05 <hpc> IO was a list of inputs and outputs that you defined with main
17:07:06 <Hafydd> heatCPU :: ()
17:07:10 <jabesed> srhb: dmj`: I know it didn't but I was positive it had around 15 years ago, what year was it then?
17:07:17 <hpc> main = [stuff] -- or something like that
17:07:51 <hpc> someone older than me could explain better
17:08:08 <srhb> jabesed: I think it's actually pretty close to exactly 15 years now... Though I don't recall exactly.
17:08:48 <srhb> jabesed: ("Tackling the awkward squad ... is from 2010)
17:10:14 <jabesed> ok I think you guys must be wrong... Haskell 98 was the standard for a long time, and I'd swear haskell 98 had IO monads
17:10:58 <luzie> Haskell got monadic io in 1996, it's now 2015
17:11:07 * lolisa dont get why history become important... Haskell in 2015 is Haskell in 2015, nomatter whether it start off as a brainfuck extension or not...
17:11:36 <hpc> lolisa: it's interesting to look back sometimes
17:12:17 <srhb> jabesed: OK. :) Almost 15 years anyway.
17:12:44 * dmj` wonders if the first 6 years of no I/O is what inhibited adoption, or at least a bad public perception
17:12:53 <dmj`> contributed towards*
17:13:09 <hpc> doubt it
17:13:16 <hpc> or it wasn't terribly major
17:13:19 <jabesed> hpc: srhb: indeed just checked and Haskell 98 does have an IO monad... so I think this proved my point really... since H98, what was the biggest accomplishment...
17:13:28 <srhb> I think the lack of "being the one true new classy OOP language" was the main issue at that time :-)
17:13:40 <srhb> jabesed: According to luzie it was 1996. 
17:13:53 <jabesed> there's been interesting developments and the language is more mature, but nothing revolutionary so far
17:13:54 <hpc> because when monadic IO got easy, people still made fun of Monad being incomprehensible and side effects being impossible
17:14:06 <jabesed> srhb: yeap, that makes more sense, so almost 20
17:14:08 <srhb> jabesed: But still, then there's the FFI, GADTS, functional dependencies, ...
17:14:19 <dmj`> jabesed: it's pretty revolutionary
17:14:23 <luzie> according to http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm
17:14:31 <hpc> ghc had the first implementation of STM
17:14:35 <srhb> jabesed: Most big libraries from Hackage wouldn't even come close to compiling with Haskell 98.
17:14:38 <hpc> (if not first, first practical one anyway)
17:15:17 <hpc> it created the current trend toward type systems in more places
17:15:42 <jabesed> dmj`: what is?
17:16:02 <hpc> scala likely wouldn't be even remotely what it is today, for instance
17:16:17 <dmj`> jabesed: haskell
17:16:18 <jabesed> srhb: I don't know if I would call any of that major developments... 
17:16:32 <jabesed> dmj`: sure it was
17:16:40 <srhb> jabesed: Well, OK. Then there were ZERO major developments in Haskell since 15 years ago. :-)
17:16:42 <srhb> That was easy.
17:17:01 <hpc> srhb: no, remember that time haskell invented pointer arithmetic?
17:17:07 <srhb> Gasp
17:17:17 <hpc> it was in 1965, which is 15 years ago if you use an unsigned int
17:17:47 <jabesed> srhb: well tons of languages have FFI, nothing major about that, just something practical that you need, as well as all other libraries, that's just maturity
17:17:59 <jabesed> srhb: functional dependencies... meh
17:18:08 <srhb> jabesed: So it's about developments in Haskell that were not just revolutionary in Haskell but in programming languages in general?
17:18:10 <jabesed> srhb: GADT's yes, that is a good evolution
17:18:15 <hpc> haskell is currently in a bit of a race with idris to become the first practical dependent-typed language
17:18:18 <srhb> jabesed: If so, there's nothing revolutionary in Haskell at all..
17:18:41 <hpc> ghc needs to finish getting dependent types, idris needs a killer app of some kind
17:19:28 <hpc> haskell was used to write the first perl6 compiler
17:19:30 <dmj`> jabesed: still is, in 2014 the Java camp was popping champagne bottles over releasing lambdas into the language... linq in C# by Meijer was all due to haskell influence. Industry is still 'catching up'
17:19:38 <hpc> because perl got so complicated even perl couldn't parse it anymore ;)
17:20:00 <jabesed> srhb: no, what I mean is that building libraries and in particular an FFI, wrting documentation, writing manuals, and all that jazz, are part of a language growth
17:20:07 <hpc> dmj`: those aren't major because they were so easy to add to haskell ;)
17:20:26 <srhb> jabesed: OK. :)
17:20:33 <jabesed> srhb: it's not on the same category as say, introduction of classes
17:20:39 * srhb shrugs
17:20:41 <jabesed> srhb: or monads
17:20:45 <dmj`> hpc: ;)
17:20:47 <hpc> you know, writing research papers, creating abstractions
17:20:51 <hpc> same old same old
17:20:57 <jabesed> srhb: or understanding free theorems
17:21:20 <srhb> jabesed: I think one of the main take-away points of this discussion is that we've added such powerful abstractions to Haskell that we haven't nearly exhausted their research potential yet.
17:21:26 <srhb> jabesed: Not their practical potential.
17:21:38 <srhb> But anyway, I've grown disinterested with this approach to the history of Haskell.
17:22:10 <jabesed> not really there are still pretty annoying issues with haskell to be solved
17:22:16 <hpc> not sure if it's still true, but microsoft research used to use ghc as a testing ground for new features before they go into .NET languages
17:22:31 <jabesed> and there's some interesting lines of work that could result in new ways to program although we're not there yet
17:22:40 <hpc> so anything "major" that .NET did, haskell got first most likely
17:22:48 <jabesed> e.g., haskell's module system is known to be quite weak
17:23:10 <jabesed> there's been quite a bit of research on that
17:23:14 <srhb> Oh, agreed there.
17:23:28 <srhb> An ML-type module language would be very welcome.
17:23:31 <dmj`> jabesed: take python, written predominantly by Guido. Now haskell, where many academics invested their entire careers. Python might have more industry adoption, but lack of type safety costs the industry far more money due to bugs. 
17:23:31 <jabesed> also the whole dependent type sort of but not really thing
17:23:58 <tejing> typeclasses are a bit too rigid as well... there's no smooth path to modifying the hierarchy
17:23:59 <jabesed> dmj`: sure I don't question that at all, I much rather program in haskell
17:24:06 <ion> Hakeem hysteria > Haskell history
17:24:14 <benzrf> what's an hakeem
17:24:50 <jabesed> another interesting line of work would be liquid haskell and friends, for proving stronger properties of programs
17:24:51 <ion> A swipe keyboard typo for Haskell
17:25:01 <hpc> "modifying the hierarchy"...
17:25:09 <jabesed> that could change the game
17:26:22 <jabesed> another annoyance, somewhat related with modules, is the initialization problem, where any initial parameters must live in a monad
17:26:33 <tejing> hpc: just look at the amount of work that had to go into making applicative a superclass of monad
17:26:36 <srhb> jabesed: How do you mean?
17:26:51 <srhb> jabesed: Tiny work. Huge discussion.
17:27:00 <srhb> er, that was for tejing.
17:27:26 <hpc> i consider that to be inertia more than anything
17:27:36 <jabesed> srhb: suppose you run a program with arguments  ./myprogram arg1 arg2 arg3 
17:27:43 <srhb> jabesed: yes?
17:27:43 <hpc> any other language would just say "okay, we're breaking things for 7.0" and move on
17:27:52 <hpc> for instance, python
17:28:09 <srhb> hpc: Pythton3* ( :-) )
17:28:17 <jabesed> srhb: they are constant throughout your program, but these constant parameters must be accessed via your main, and passed around
17:28:21 <luzie> no it would often be a huge bikeshed
17:28:28 <srhb> jabesed: What's wrong with unsafePerformIO?
17:28:35 <jabesed> srhb: :|
17:28:40 <srhb> jabesed: No, seriously.
17:28:56 <srhb> jabesed: This is akin to how FFI-y things that require initial setup is handled.
17:28:58 <jabesed> srhb: is that even  part of the standard? does it have defined semantics?
17:29:08 <hpc> a lot of effort has gone into making sure you barely notice when something is written in haskell98
17:29:09 <jabesed> srhb: if it's not then it's not haskell...
17:29:13 <srhb> jabesed: ... okay :P
17:29:17 <jabesed> :)
17:29:18 <srhb> jabesed: Now you're just being ridiculous.
17:29:31 <hpc> languages like perl try to keep the same level of compatibility and end up far wartier
17:29:46 <srhb> jabesed: GHCSKELL (which is what we're talking about) relies heavily on various unsafeDoThings.
17:29:48 <luzie> "defined semantics" is reasonable
17:29:52 <jabesed> not really, we're talking about the evolution of haskell... if it's not in the standard after all these years, probably there's a reason for it
17:30:21 <jabesed> srhb: that just reinforces my point that there are things to be solved
17:30:27 <hpc> so overall i would consider it a success that they've managed to pull off such an API change without creating an "everyone update your code!" rush
17:30:36 <jabesed> srhb: given non-standard features are heavily used
17:30:55 <srhb> They are standard.
17:30:57 <jabesed> srhb: that means "we don't really have a standard-worthy solution yet"
17:31:02 <srhb> By any meaningful definition of "standard"
17:31:02 <arkeet> lots of stuff in base isn't in the haskell standard
17:31:32 <dmj`> jabesed: ./main arg1 arg2 arg3, I see nothing wrong here. I/O exists now yes
17:31:36 <hpc> the haskell standard deliberately defines as little as it can in as denotational a way as possible
17:31:45 <hpc> to be open to alternate implementations and novel approaches
17:32:00 <jabesed> dmj`: there's nthing wrong there... but what follows is a pain
17:32:08 <srhb> jabesed: Have you ever read the implementation of, say, hGetContents?
17:32:11 <jabesed> hpc: yes, which is good
17:32:27 <jabesed> srhb: no idea, if I did, not in a long time
17:32:30 <hpc> and features like GADTs generally don't get added until they're perfected
17:32:30 <srhb> ie. do you know how to use unsafeInterleaveIO ?
17:32:33 <dmj`> jabesed: what is painful about that? You parse it, then pass it to a pure function. 
17:32:41 <hpc> stuff like RankNTypes are commonly used because they're a good abstraction
17:32:51 <hpc> however it's proven that they cause type inference to not always work
17:32:59 <hpc> so there's a tradeoff
17:33:11 <jabesed> dmj`: the "pass it to a pure function" part, meaning you may have to pass a bunch of arguments around that are constant 
17:33:18 <hpc> and the way it's resolved is "you don't have to have this in order to be haskell, but you can if you want"
17:33:32 <srhb> jabesed: There's unsafePerformIO, there's Reader, there's ...
17:33:35 <srhb> This is a solved problem.
17:33:38 <srhb> Trivially, even.
17:35:00 <dmj`> jabesed: yes, they're pure after you parse it into a structure. Take a web server configuration, you set the http timeout in seconds from a command line arg. That value persists throughout the lifetime of your server. That's just real world stuff.
17:35:23 <jabesed> srhb: sure, you readarise a ton of pure functions, adding noise (and unfortunately also promoting a stylistic change), and as if that wasn't bad enough, then if you need another monad suddenly you're using monad transformers
17:35:29 <jabesed> srhb: nope nope nope
17:35:40 <jabesed> now compare that with ML modules
17:35:47 <srhb> How does this even compare?
17:35:48 <hpc> jabesed: it's not like it's so beautifully pretty in other languages either
17:35:49 <srhb> No, nevermind.
17:35:49 <arkeet> ImplicitParams? :---)
17:35:50 <dmj`> jabesed: I guess I don't see how "passing things around" is painful. State / Reader monads are made for this
17:35:58 <hpc> you have to be explicit in every language about passing it around
17:36:10 <hpc> in C you'd pass a monster struct of configuration data
17:36:18 <jabesed> srhb: you can say, this is a module, and I assume there's all these constant things to be used in this module
17:36:18 <hpc> or maybe you'd split it into a bunch of tiny pieces of data
17:36:25 <arkeet> or maybe you'd stick it in a global variable
17:36:36 <hpc> and have a 3k line file with macros governing which stuff gets passed where
17:36:38 <arkeet> jabesed: have you heard of ImplicitParams?
17:36:43 <jabesed> arkeet: yes!
17:36:46 <hpc> and when you make a mistake you get 8 pages of compiler errors
17:36:49 <arkeet> is this also not a solution?
17:37:02 <jabesed> arkeet: and have used them extensively
17:37:12 <jabesed> arkeet: that is indeed the closest to a clean solution
17:37:29 <luzie> why are you comparing to c that's not a remotely modern language
17:37:45 <arkeet> I have no idea what sort of clean solution you have in mind.
17:37:56 <srhb> luzie: There's no real difference between C and Python in this case.
17:38:02 <srhb> Which goes for a lot of these things.
17:38:08 <srhb> Though sure, Python isn't a modern language either.
17:38:16 <luzie> neither is python
17:38:19 <dmj`> jabesed: global variables are rarely a good idea, how does that promote modularity
17:38:21 <srhb> Most modern languages were invented in the 70's ( :-) )
17:39:10 <jabesed> dmj`: this is the exact opposite considering I'm suggesting it would be best solved with _modules_ ;)
17:39:20 <hpc> it's not though
17:39:21 <Axman6> @remember srhb Most modern languages were invented in the 70's
17:39:22 <lambdabot> Done.
17:39:31 <srhb> :P
17:39:35 <Axman6> =)
17:39:43 <hpc> you're still writing explicitly how to read the configuration data, where to put it, and so forth
17:39:53 <jabesed> let me put it this way, one common way to make a program more modular is to define sub functions
17:40:25 <jabesed> whenever you have sub-functions you assume to have constants available
17:41:09 <jabesed> the problem with sub-functions is that you cannot reuse them, and you cannot properly test them
17:41:17 <srhb> wuh?
17:41:19 <srhb> How so?
17:41:23 <jabesed> which part?
17:41:30 <srhb> Well, first, what is a sub function?
17:41:58 <Hafydd> I can't believe the top Google result for ImplicitParams is a Haskell Wiki article that just links to the GHC manual; and the GHC manual itself doesn't appear anywhere on the first page of results.
17:42:02 <jabesed> a function defined in a `let ... in`  or `where ...` 
17:42:09 <Hafydd> The world could be improved if people read the proper documentation more.
17:42:28 <srhb> jabesed: Okay, so you're complaining about namespacing issues?
17:43:12 <jabesed> srhb: I wasn't really complaining now... and  does namespacing address anything here?
17:43:23 <dmj`> jabesed: you can factor out any let ... in or where ... into a top level declaration, export it, then test it.
17:43:34 <jabesed> dmj`: yes
17:44:08 <jabesed> dmj`: of course then you also need to deal with those "constant" arguments it uses
17:44:15 <jabesed> dmj`: i.e. make them also top level
17:44:16 <koala_man> Hafydd: haha yep. "ImplicitParams" doesn't occur once in the manual, only "XImplicitParams"
17:44:17 <srhb> The only thing keeping people from doing this is 1) they don't intend the "sub"-function from being used anywhere else, or 2) they don't want to pollute namespaces more than necessary, provoking qualified imports everywhere
17:44:22 <srhb> But then, TDNR might assist here.
17:44:42 <dmj`> jabesed: what do you mean constant arguments
17:44:52 <srhb> dmj`: I think like how circleRadius uses pi
17:44:57 <srhb> or whatever.
17:44:58 <jabesed> let f x = y + 1 in   
17:45:06 <jabesed> y is free in f
17:45:23 <Hafydd> I know Google is capable of doing things like inferring that "XImplicitParams," "ImplicitParams," and "Implicit Parameters" mean the same thing.
17:45:35 <jabesed> so y is a constant to f
17:45:36 <Hafydd> However, maybe it only does that for terms with much higher volume.
17:46:04 <jabesed> and y could be an argument passed to the top level function
17:46:26 <jabesed> top y = let f x = y+x in ... 
17:46:36 <srhb> jabesed: Well then you just float the variable inwards
17:46:42 <srhb> let f x y = y + x in ...
17:46:57 <jabesed> sure you can do that
17:47:22 <jabesed> of course then things like    let k = y+x in 
17:47:37 <jabesed> stop being constants and become functions, potentially losing sharing
17:47:56 <jabesed> and of course that you're complicating what could be simple formulas to hold a bunch of arguments that amount to noise
17:48:23 <jabesed> this is something modules are nice for
17:48:34 <jabesed> it's not that you can't live without them, you can
17:48:36 <tejing> I read a paper a while ago about solving the configuration problem, using modular arithmetic as an example. They managed to make a system you could use like this: withMod m $ 2 * bigComplicatedNumFunction 3, even when m isn't known till runtime, but the type system would still throw an error if you tried to combine terms whose modulus didn't come form the same place
17:48:40 <jabesed> but you can live without lambdas too :P
17:48:56 <tejing> from*
17:49:57 <dmj`> jabesed: how would that lose sharing?
17:50:24 <tejing> they used a lot of the pseudo-dependent typing stuff to do it tho
17:50:38 <dmj`> jabesed: how is let k = x + y a function and not a value
17:52:27 <jabesed> dmj`: precisely, and following srhb's sugesting it would become a top level   k x y = x + y 
17:52:56 <Bashmetim> > (-13) `div` 100
17:52:57 <lambdabot>  -1
17:53:03 <Bashmetim> Por que?
17:53:07 <srhb> I'm pretty sure I suggested solving the constant problem by actually declaring more constants. It's not like we have a problem with that. :-)
17:53:10 <srhb> Bashmetim: Huh?
17:53:13 <Cale> > (-13) `mod` 100
17:53:14 <lambdabot>  87
17:53:24 <srhb> :t subtract
17:53:25 <lambdabot> Num a => a -> a -> a
17:53:50 <Cale> > 87 + (-1) * 100
17:53:51 <lambdabot>  -13
17:54:04 <jabesed> srhb: I don't follow
17:54:24 <srhb> jabesed: I think I've lost the thread. I remember this was about constants and somehow modules.
17:54:38 <srhb> jabesed: But where is the issue with just, like, declaring constants? 
17:54:46 <Bashmetim> Sorry, I just popped in with the `div` thing...
17:54:59 <dmj`> jabesed: are you arguing for ML style modules in haskell?
17:55:02 <arkeet> Bashmetim: div rounds down (toward -infinity)
17:55:02 <tejing> > (-13) `divMod` 100
17:55:03 <lambdabot>  (-1,87)
17:55:09 <arkeet> Bashmetim: if you want rounding toward zero, use quot
17:55:12 <tejing> > (-13) `quotRem` 100
17:55:13 <Cale> Bashmetim: Do my examples help clarify why -1 is sensible?
17:55:14 <lambdabot>  (0,-13)
17:55:17 <srhb> We don't need to argue about ML-style modules in Haskell, we all want that pretty much. :D
17:55:26 <jabesed> srhb: point is, k is not a constant... it depends on x and y... but in a context where x and y are fixed it is a constant.
17:55:37 <Bashmetim> Cale, aye, that  makes perfect sense
17:55:37 <arkeet> Bashmetim: we always want this to hold: (a `div` b) * b + (a `mod` b) = a
17:55:38 <Bashmetim> !
17:55:42 <srhb> jabesed: So implicitparams again?
17:55:46 <arkeet> same for (a `quot` b) * b + (a `rem` b) = a
17:56:14 <jabesed> dmj`: I wouldn't argue for anything because there's been a ton of people researching modules in haskell, and none offered a final solution yet, and they know better than me :P
17:56:18 <Bashmetim> Is `quot` the same as using '/' in C?
17:56:25 <jabesed> srhb: that's what I've used plenty of times
17:56:33 <srhb> Yes, I know...
17:56:49 <Bashmetim> (And `rem` the same as '%')
17:57:09 <jabesed> srhb: but again, it's still one of those ideas in the shelf... for about a decade and a half now... as are better module systems
17:57:23 <srhb> jabesed: What, ImplicitParams?
17:57:37 <srhb> It's not "on the shelf" just because it's an extension...
17:57:38 <jabesed> srhb: yes
17:57:49 <srhb> Again, a lot of extensions are more or less mandatory.
17:57:58 <srhb> For instance, we expect to be able to work with rank 2 types.
17:58:23 <srhb> Haskell "the official standard" has little to do with Haskell "the actual real world language"
17:59:22 <bitemyapp> "little"
17:59:38 <bitemyapp> is perhaps being a "little" unfair.
17:59:40 <srhb> fsvo little.
17:59:46 <srhb> I tend to be unfair towards the standard. :P
18:00:52 <bitemyapp> it still matters. I don't mind that GHC exceeds it.
18:02:18 <jabesed> srhb: not all the extensions have the same status
18:02:22 <jabesed> srhb: https://wiki.haskell.org/Use_of_language_extensions
18:02:30 <srhb> jabesed: No, definitely.
18:02:44 <srhb> I never claimed otherwise. :)
18:02:46 <jabesed> srhb: not even a mention of implicit parameters there
18:03:51 <bitemyapp> does anybody use implicit parameters?
18:04:21 <jabesed> me :/
18:04:35 <jabesed> but yeah that's my point, does anyone even use them
18:04:41 <jabesed> they're just there
18:04:53 <jabesed> the typical answer would be, use monad reader
18:04:58 <bbrroott> trying to 'cabal install xmonad-contrib' - error: "Not in scope: type constructor or class 'Applicative'"
18:04:59 <jabesed> or unsafewhatever
18:05:00 <bbrroott> :S
18:05:13 <bbrroott> fresh cabal ( I removed all libraries before installing)
18:06:13 <gamegoblin> :t first Just
18:06:14 <lambdabot> (b, d) -> (Maybe b, d)
18:06:36 <bbrroott> this is the output I get actually: https://hackage.haskell.org/package/xmonad-contrib-0.11.4/reports/1
18:06:52 <hodapp> :t state
18:06:53 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
18:07:01 <hodapp> :t runState
18:07:02 <lambdabot> State s a -> s -> (a, s)
18:08:07 <gamegoblin> > (first Just . (,)) 1 2
18:08:09 <lambdabot>      Couldn't match type ‘(b0, d0)’ with ‘b1 -> (Integer, b1)’
18:08:09 <lambdabot>      Expected type: (b1 -> (Integer, b1)) -> Integer -> t
18:08:09 <lambdabot>        Actual type: (b0, d0) -> (Maybe b0, d0)
18:08:31 <dmj`> jabesed: so you don't like having to apply the same constant to multiple functions in different modules, is that what I'm hearing
18:09:20 <hodapp> ugh, I see the type 'State'... now how do I actually make an *instance* of 'State s a'?
18:10:07 <bitemyapp> jabesed: probably a Reader is what you want yes.
18:10:24 <SaidinWoT> hodapp: State f where f has type s -> (a, s)
18:10:47 <hodapp> SaidinWoT: That's a constructor?
18:10:57 <gamegoblin> is there an attoparsec function that has the type Parser word8 -> Parser ByteString   that would take a Parser word8 and apply it many times, putting the results into a ByteString
18:11:26 <arkeet> it used to be, but it's not.
18:11:40 <arkeet> hodapp: use any of the things provided by Control.Monad.State
18:11:58 <arkeet> or whatever
18:12:19 <hodapp> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State.html does not appear to have much of interest
18:12:30 <arkeet> look in .Lazy
18:12:42 <arkeet> note that there is a MonadState instance for State s
18:12:43 <hodapp> that's where I started
18:12:48 <arkeet> (which is StateT s Identity)
18:13:03 <luzie> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html
18:13:16 <scb> hi guys, im trying to implement a function which takes a list of length n*m and returns a new list of the form [[a]] (basically a matrix). I implemented it like this: https://gist.github.com/anonymous/60c19c9a72e79d41be35 but I am using massive amount of ram ... any thoughts how can i improve it?
18:13:27 <hodapp> luzie: yes, that's the page I've been at since the start here.
18:13:50 <ReinH> gamegoblin: maybe you want binary or cereal?
18:14:14 <ReinH> What you are asking for sounds more like deserialization than parsing
18:16:03 <gamegoblin> ReinH: not really, it’s an HTTP parser
18:16:22 <init> scb: a few things, that's probably accumulating thunks, you may try using guarded recursion instead, then, take n xs + drop n xs isn't efficient, (t,d) = splitAt n xs is probably what you want, and also, lists are the bad data structure for that :P
18:16:25 <ReinH> gamegoblin: why would an HTTP parser need to parse bytes?
18:16:27 <gamegoblin> ReinH: specifically the URI parser within an HTTpP parser
18:16:36 <gamegoblin> ReinH: because you’re reading off of a socket
18:16:54 <arkeet> scb: don't use an accumulator and reverse
18:16:55 <gamegoblin> ReinH: and HTTP is all in ASCII
18:17:10 <scb> arkeet: direct recursion?
18:17:19 <arkeet> if you're producing a list, just construct a list.
18:17:46 <arkeet> what should the head and tail of the output be?
18:18:01 <arkeet> (if it's nonempty)
18:18:13 <dmj`> gamegoblin: are you trying to parse an HTTP header (according to RFC 2616)
18:18:36 <gamegoblin> dmj`: specifically this code is parsing a URI Reference
18:18:41 <ReinH> gamegoblin: that's not strictly true
18:18:52 <hodapp> hmm, 'MonadState m' isn't a derivable class, and I'm not sure how implementing 'state' myself is supposed to help the problem that I can't call 'state'
18:19:06 <arkeet> huh?
18:19:17 <arkeet> you're asking how to produce a value of type State s a?
18:19:26 <arkeet> I'm confused.
18:19:35 <hodapp> yes.
18:19:39 <arkeet> okay.
18:19:42 <dmj`> return 4 :: State Int a
18:19:54 <arkeet> well, State s is an instance of MonadState s
18:19:55 <dmj`> hodapp: MonadState s is derivable
18:20:05 <arkeet> so you can use any MonadState things to do it.
18:20:19 <arkeet> :t state
18:20:20 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
18:20:24 <arkeet> :t state :: (s -> (a,s)) -> State s a
18:20:26 <lambdabot> (s -> (a, s)) -> State s a
18:20:28 <dmj`> gamegoblin: bos wrote an RFC 2616 parser for an http req / resp 
18:20:32 <arkeet> that's just an example.
18:20:42 <gamegoblin> dmj`: it doesn’t fully parse URIs
18:21:05 <arkeet> usually when writing code involving State you'd use stuff like get/put/modify.
18:21:06 <gamegoblin> dmj`: actually it barely parses anything at all
18:21:09 <arkeet> (along with the standard Monad methods)
18:21:33 <scb> arkeet: that helped but why? shouldnt tail recursion be 'better' ?
18:21:43 <dmj`> gamegoblin: takeWhile :: (Word8 -> Bool) -> Parser ByteString, would this work
18:21:43 <arkeet> scb: no
18:21:55 <arkeet> scb: tail recursion isn't 'better'
18:22:08 <ReinH> fwiw, 7230 allows any *superset* of USASCII
18:22:08 <gamegoblin> dmj`: no, because you must also decode percent-encoded chars
18:22:17 <arkeet> scb: tail recursion matters more in a strict language (that has a call stack)
18:22:20 <dmj`> @package uri
18:22:20 <lambdabot> http://hackage.haskell.org/package/uri
18:22:20 <arkeet> there is no call stack in haskell.
18:22:23 <gamegoblin> dmj`: which involves pulling 3 words off the bytestring
18:22:26 <arkeet> (in ghc haskell)
18:22:58 <scb> arkeet: i see
18:23:30 <gamegoblin> dmj`: I’m trying to avoid converting back and forth between types. If I didn’t care about that, I’d just pack my [word8]
18:23:38 <ReinH> All calls in Haskell are either "tail calls" or "not tail calls" depending on your definition of "tail call". It's not a useful way to think about evaluation in Haskell.
18:24:02 <gamegoblin> dmj`: I was hoping for some bos-magic which involves low-level masked unsafety with regard to bytestring allocations
18:24:41 <hodapp> arkeet: that may be the case, but I was not finding the in-documentation examples particularly illuminating for that case.
18:26:09 <ReinH> It's more useful to think about strictness and productivity than "tail recursion"
18:27:07 <arkeet> hodapp: given lack of other resources, I might (or might not) approach trying to figure out how to make things in this way:
18:27:21 <arkeet> I see there's a type synonym, State s = StateT s Identity
18:27:38 <arkeet> I don't immediately see anything that specifically produces a StateT value
18:27:42 <arkeet> so I look at what instances that type has.
18:28:06 <arkeet> the most specific-sounding one is MonadState.
18:28:35 <arkeet> so anything that produces a value whose type is an instance of MonadState (including the class methods) is good.
18:29:01 <arkeet> but don't forget about the other instances (for Functor, Monad, etc.)
18:31:26 <hodapp> it's a moot point now since I'm getting a GHC panic.
18:32:01 <arkeet> okay, that shouldn't happen :-)
18:32:07 <hodapp> no.
18:32:13 <dmj`> gamegoblin: not sure :/
18:40:26 <lpaste> hodapp pasted “No title” at http://lpaste.net/134710
18:41:23 <hodapp> bleah, I'll register tomorrow and file that if it also happens on my work machine
18:44:53 <dmj`> hodapp: are you just trying to derive MonadState for your data type?
18:45:44 <dmj`> hodapp: http://lpaste.net/134712
18:46:27 <ReinH> scb: ping
18:49:12 <ReinH> scb: the obvious version using splitAt is well behaved http://lpaste.net/2294086197665857536
18:51:12 <ReinH> It's also productive, so you can say (chunksOf 10 [1..]) !! 100
18:51:30 <ReinH> eh, the braces are unnecessary, but anyway
19:00:25 <user1_> if Data.Attoparsec.Char8 will be deprecated, what is the recommended parsing library?
19:01:37 <rien> Data.Attoparsec.ByteString.Char8 I guess.
19:04:06 <sccrstud92> What's wrong with the rest of Data.Attoparsec?
19:04:20 <sccrstud92> if u want text, use Data.Attoparsec.Text
19:18:25 * hackagebot cf 0.4.1 - Exact real arithmetic using continued fractions  http://hackage.haskell.org/package/cf-0.4.1 (mvr)
19:37:59 <kLooaa> Do you realize that basically after age 20 your body starts rotting, being worse and worser at everything? and that includes your brain too? you will eventually be stupid and naive just like children. or worse - you can get alzheimer's disease.  If you are alive now, I guarantee you that you will die eventually. And it can be really painful dying. Just read news or statistics how many people die in what ways DAILY. You will become one of them eventually. 
19:37:59 <kLooaa> One of that statistics number. nothing more.
19:38:35 --- mode: ChanServ set +o geekosaur
19:38:36 <dmwit> ?where ops
19:38:37 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:38:46 <dmwit> Oh, I'm too slow.
19:38:50 --- mode: geekosaur set +b *!*@70.33.229.146
19:38:51 --- kick: kLooaa was kicked by geekosaur (kLooaa)
19:39:13 --- mode: geekosaur set -o geekosaur
19:39:30 <Clint> worse and worser
19:39:41 <Cale> ah, I just banned him from ##math, I should have guessed
19:45:51 <saulzar_> Cheerful message for the day
19:46:35 <ion> Do you realize that basically after age 20 Haskell has just kept getting better?
19:47:33 <saulzar_> Haha
19:47:58 <saulzar_> being better and betterer you mean?
19:51:37 <ion> Touché
20:15:57 <hodapp> dmj`: no, that's the minimal case I wrote that is causing a GHC panic.
20:18:33 <Welkin> lol, kLooaa
20:19:24 <Welkin> hodapp: are you on ghc 7.10.1 on osx?
20:19:59 <Welkin> I had a problem with ghc panic, so I had to upgrade to 7.10.2-rc1
20:22:29 <hodapp> Welkin: this is ArchLinux
20:22:38 <hodapp> but, yes, 7.10.1
20:23:04 <Welkin> try upgrading
20:23:25 <hodapp> I'll give that a try tomorrow
20:23:36 <hodapp> or just completely ignore it because this is experimental bullshit code
20:23:44 <Welkin> http://downloads.haskell.org/~ghc/7.10.2-rc1/ghc-7.10.1.20150612-x86_64-apple-darwin.tar.xz
20:23:49 <Welkin> er
20:24:38 <Welkin> https://downloads.haskell.org/~ghc/7.10.2-rc1/
20:24:39 <Welkin> there
20:35:44 <johnw> "If you are alive now, I guarantee you that you will die eventually."  I really can't fault his reasoning.
20:39:32 <Hafydd> I'd like to see a proof of this.
20:39:47 <roconnor> Hafydd: no don't ask for that!!
20:40:41 <heatsink> I'm not sure that the meaning of "eventually" is well-defined.  What if someone invents time travel in the future?
20:40:45 <Hafydd> Someone might provide a constructive proof that I will eventually die, by killing me, but this would not prove a universally quantified version of the above.
20:41:11 <roconnor> they would have to kill everyone!!
20:41:31 <Hafydd> Even that would not guarantee that some germ of immortal humanity does not remain in the universe.
20:42:41 <heatsink> The quantified variable seems to range over all living things, not just humans.
20:43:39 <dolio> roconnor: That's not how foralls work.
20:46:52 <Hafydd> Yes, that's true. An immortal human will still provide a counterexample. It's probably easier to find an immortal non-human, for example in the form of a frozen bacterial spore.
20:48:09 <johnw> how can an immortial human provide a counterexample?
20:48:17 <johnw> isn't that like taking ⊥ for evidence?
20:48:22 <Serpentine_> It's probably impossible to determine if a human is certainly immortal
20:48:27 <Walpurgisnacht> ?
20:48:36 <Walpurgisnacht> Time travel and immortality
20:48:39 <Serpentine_> It's like taking the lack of evidence as evidence
20:48:41 <Walpurgisnacht> Sounds strange
20:48:48 <johnw> time travel is just recursion
20:48:58 <Walpurgisnacht> The future doesn't exist
20:49:08 <johnw> you have to then prove the travel is well-founded
20:49:11 <Serpentine_> It's just that if some guy lives for at least 200 years and no other human has, you can be convinced that the person has a long life, but not necessarily that he is immortal
20:49:13 <Walpurgisnacht> Neither does the present everything is in the past 
20:49:16 <awoserra> hahaha
20:49:31 <johnw> uh oh, now awoserra sees me being off-topic
20:49:38 * awoserra snickers :P
20:49:46 <johnw> ok, so how about that Haskell guys?
20:49:53 <Walpurgisnacht> Mhmm
20:50:11 <gamegoblin> Can you make a case statement for bytestring literals?
20:50:39 <gamegoblin> (that is, does overloaded strings let you do that)
20:51:15 <johnw> sure
20:51:32 <johnw> it's going to construct a bytestring, and then do an equality test
20:53:29 * hackagebot gnutls 0.2 - Bindings for GNU libgnutls  http://hackage.haskell.org/package/gnutls-0.2 (JohnMillikin)
20:54:08 <jasonkuhrt> Why does Haskell have `map` and `fmap`?
20:54:14 <johnw> history
20:54:24 <gamegoblin> jasonkuhrt: haskell didn’t always have Functor
20:54:31 <johnw> and fmap used to be map
20:54:32 <gamegoblin> jasonkuhrt: but it did have []
20:55:03 <jasonkuhrt> So if haskell were created today `fmap` would not exist, we would just have `map`?
20:55:19 <johnw> we'd still have both
20:55:22 <jasonkuhrt> Why
20:55:25 <johnw> just fmap would be called "map", and the default
20:55:33 <johnw> and another "map" would live in Data.List
20:55:51 <jasonkuhrt> johnw: Why isn't Data.List a Functor? hmm
20:55:59 <johnw> there are people who like monomorphic functions sometimes, and probably other subtle reasons
20:56:14 <johnw> but fortunately there is an accepting trend toward generality
20:56:19 <jasonkuhrt> monomorphic?
20:56:30 <johnw> monomorphic means that f is fixed to []
20:56:56 <gamegoblin> mono = one morphic = form, so monomorphic == one form
20:57:23 <liste> jasonkuhrt [] is a functor
20:57:25 <jasonkuhrt> Got it, makes sense
20:57:36 <liste> @src ([]) fmap
20:57:36 <lambdabot> Source not found.
20:57:39 <gamegoblin> opposed to polymorphic 
20:57:42 <jasonkuhrt> liste: So why would Data.List.map *need* to exist?
20:57:58 <geekosaur> the reason map is not fmap is that beginners can get odd errors if the type of map is too "loose"
20:58:09 <geekosaur> at least, that was the claim made by the language committee
20:58:15 <johnw> especially if 'f' is inferred to be ((->) r)
20:58:20 <johnw> those can be very confusing
20:58:47 <jasonkuhrt> So, for sanity check, there is no technical reason for the split
20:59:00 <jasonkuhrt> Its just history, UX, subjective things, politics, whatever
20:59:28 <jasonkuhrt> Thanks guys, was just curious to confirm what I assumed
20:59:33 <johnw>  jasonkuhrt: http://stackoverflow.com/questions/6824255/whats-the-point-of-map-in-haskell-when-there-is-fmap
20:59:45 <jasonkuhrt> johnw: : )
21:00:15 <johnw> "in Haskell 1.3 fmap was called map. This change was then reverted in Haskell 1.4 and fmap was introduced. The reason for this change was pedagogical; when teaching Haskell to beginners the very general type of map made error messages more difficult to understand."
21:00:22 <gamegoblin> is there a function that converts an Either to a Maybe (where Left goes to Nothing) ?
21:00:36 <johnw> gamegoblin: yes, in the 'errors' package
21:00:40 <johnw> it's called hush, I think
21:01:29 <ion> The output from my first Haskell program, exactly 8 years ago. http://heh.fi/tmp/quick_brown_fox
21:02:36 <jasonkuhrt> johnw: Must admit I agree with augustss, spliting fmap/map was not the right solution. 'course no point in barking about this, thanks again
21:03:56 <johnw> I would rather fmap was map, maybe it will happen sometime again
21:08:16 <mzero> or if you want consider the radical.. what if fmap and map were both ... just ...    .
21:09:03 <mzero> then Haskell would be like ... like ... APL!!!
21:09:25 <mzero> > show . (+1) . [1, 3, 4]
21:09:26 <lambdabot>      Couldn't match expected type ‘a -> Integer’
21:09:26 <lambdabot>                  with actual type ‘[Integer]’
21:09:26 <lambdabot>      In the second argument of ‘(.)’, namely ‘[1, 3, 4]’
21:10:42 <jasonkuhrt> I'm trying to understand the nature of type constructors versus concrete types when making types instances of type-classes
21:10:45 <jasonkuhrt> For example...
21:11:18 <jasonkuhrt> `instance Functor [] where ...` is using a type constructor `[]` rather than a concrete type `[a]` right?
21:12:02 <jasonkuhrt> But why exactly? Would another example of Concrete Type versus Type Constructor by `Maybe` versus `Maybe a`?
21:12:09 <geekosaur> yes, because Functor is defined as wanting a type constructor whose shape is (* -> *)
21:12:11 <jasonkuhrt> be*
21:12:29 <geekosaur> [a] can also be written ([] a)
21:12:37 <geekosaur> thius it fits the "shape" of Funcgtor
21:14:00 <jasonkuhrt> So in the type of `fmap`, which is... “fmap :: (a -> b) -> f a -> f b”
21:14:29 <jasonkuhrt> Its asking for a Type Constructor because `f a` means to do `[] a` or `Maybe a` or...
21:14:36 <kadoban> [] gets a bit confusing because there's some sugar involved. [] is a value and also a type constructor
21:15:05 <jasonkuhrt> Yeah that's why I'm trying to keep Maybe around for comparison because there's less sugar there
21:15:06 <kadoban> jasonkuhrt: But yes, the f is [] or Maybe or IO or ...
21:15:50 <jasonkuhrt> And to clarify something else.... is it correct to say that what is happening is that the type defintion of fmap takes Type Constructors and makes them Concrete Types?
21:15:58 <mzero> no
21:16:04 <mzero> not at all
21:16:31 <mzero> fmap takes a function from a to b, both concrete types, and a value of type f a (a concrete type)
21:16:33 <jasonkuhrt> Hm, but if `f a` can be to mean `Maybe a` and we say `Maybe a` is a Concrete Type and `Maybe` is a Type Constructor...
21:16:39 <mzero> and returns a value of type f b (a concrete type)
21:16:48 <mzero> functions always deal in concrete types
21:17:23 <mzero> Maybe is a type constructor - it takes some concrete type, a, and constructs a new concrete type  Maybe a
21:17:41 <jasonkuhrt> That all makes sense but isn't really addressing what I'm asking, sorry if I was unclear
21:18:04 <mzero> I suppose I'm not really sure what your question is
21:18:08 <liste> the Functor type class, on the other hand, deals with type constructors of kind (* -> *)
21:19:06 <jasonkuhrt> Hm, I'm trying to figure out how to phrase my question
21:19:32 <jasonkuhrt> How does the Type Constructor given to `instance Function ...` relate to `fmap ... f`
21:19:52 <heatsink> You mean instance Functor?
21:19:56 <jasonkuhrt> Yes
21:20:32 <liste> it's the `f' in fmap's signature
21:21:29 <kadoban> So it's  instance Functor Maybe where ...   and then the 'f' in fmap's signature is Maybe
21:21:35 <heatsink> "f" stands for a type constructor in the instance declaration, instance Functor f where fmap :: (a -> b) -> f a -> f b
21:21:44 <heatsink> "f" can stand for Maybe
21:22:40 <heatsink> So the type of fmap's second parameter must be constructed from a type constructor applied to a type, such as Maybe applied to Int
21:23:00 <jasonkuhrt> I guess I'm just trying to understand how Haskell literally makes that link
21:23:26 <jasonkuhrt> Maybe if I look at the instance definition for Functor Maybe it would be better, Functor [] is just pointing fmap to map
21:23:29 <mzero> Well, if you define the class with     class FooBar q where ....  
21:23:51 <heatsink> Oh right, I should have said "class" instead of "instance"
21:24:01 <mzero> and in the type signatures of the function members of the class     q is always used along
21:24:12 <mzero> alone, like      fribble :: f -> Int -> [f]
21:24:20 <mzero> then f must be a concrete type
21:24:21 <mzero> BUT
21:24:39 <mzero> (er    fribble :: q -> Int -> [q]
21:24:53 <mzero> But if  q is always applied to some some type (in the type signatures)
21:24:59 <mzero> then it must be a type constructor
21:25:02 <mzero> as in
21:25:20 <mzero> frazzle :: (a -> b) -> q a -> [b]
21:25:58 <jasonkuhrt> Excellent, this makes sense
21:26:07 <jasonkuhrt> This was what I was trying to ask in my question before
21:26:13 <mzero> So, you now have to think backwards, like the type inferencer
21:26:22 <jasonkuhrt> the class is applying a constructor to make a concrete type
21:26:46 <jasonkuhrt> That's one correct way to describe what is going on right?
21:26:51 <mzero> when you see concretely        frazzle (*2) (Set.fromList [1, 3, 4]) 
21:27:29 <mzero> the type inferencer says.... hmmm....        frazzle here is :: Num a => (a -> a) (Set a)
21:27:46 <mzero> so therefore, I must look for a FooBar instance for Set
21:28:04 <mzero> (frazzle being a member of typeclass FooBar0
21:28:39 <mzero> well, no so much the class, but all the members of the class use the type as a type constructor to get a concrete type
21:29:13 <mzero> the following would be illegal:    class Bad b where   ew :: b -> Int  ;   ick :: b a -> [Int]
21:29:38 <mzero> because b is used in two different ways - as a concrete type itself (in ew), and as a type constructor in ick
21:31:13 <jasonkuhrt> mzero: Yep makes perfect sense
21:31:17 <mzero> :-)
21:31:29 <jasonkuhrt> mzero: Its amazing how deep this stuff goes, its clear and then suddenly slips away 
21:32:09 <mzero> well.. wait - do this long enough (not that long, really) - and suddenly it doesn't slip away - and then you find yourself coding Python and wishing for type constructors
21:32:19 <jasonkuhrt> The concepts are beautiful because of the flexibility of their simplicity, but I need to practice them to get memorization and intuition built up
21:32:58 <mzero> And realizing that you can't explain to your co-workers why some API is inconsistent because you can't talk about it interms of type signatures with type variables!
21:33:06 <kadoban> jasonkuhrt: By the way you should do https://github.com/NICTA/course at some point, it really makes a lot of this stuff way more concrete. I'm not sure where you are in your haskell learning, so may want to wait a bit though, it depends.
21:33:20 <jasonkuhrt> For example the ability to apply type-constraints in instance declarations and class declarations, etc. deceptively simpel
21:33:23 <jasonkuhrt> simple*
21:33:33 <heatsink> mzero: You can probably use the inconsistency to derive counterexamples
21:33:42 <heatsink> that don't mention type variables
21:34:23 <mzero> oh- that looks like a nice course and syllabus --- I've been looking for a syllabus for teaching Haskell
21:34:35 <heatsink> Are you teaching coworkers?
21:34:40 <jasonkuhrt> kadoban: Thanks
21:35:26 <jasonkuhrt> kadoban: Did you link me to the fork on purpose?
21:35:40 <Axman6> the NICTA course is designed as basically a step one in learning FP
21:35:47 <mzero> Well, there has been more than one person at work that has pushed me to give a course
21:36:06 <Axman6> jasonkuhrt: the fork is the official version, Tony Morris' version is the one with the answers
21:36:07 <heatsink> cool
21:36:16 <kadoban> jasonkuhrt: I'm not sure which is the "real deal" I think that's the one I did though.
21:36:24 <bitemyapp> Axman6: it's a bit difficult for self-learners.
21:36:27 <Axman6> (Tony and I gave that course two weeks ago at NICTA)
21:36:29 <mzero> it would be to a relatively senior engineering audience - so I'd need to compress it - 
21:36:33 <Axman6> bitemyapp: right. it
21:36:47 <mzero> Oh! How long do you take to teach it, Axman6?
21:36:50 <Axman6> it's not really aimed for self learners, it's a three day intensive usually
21:36:52 <bitemyapp> Axman6: that's why we point people at cis194, telling them to do NICTA course after. Fewer dropouts.
21:37:06 <Axman6> bitemyapp: yeah, it's probably good advice =)
21:37:06 <kadoban> I never would have been able to even come close to doing NICTA from step-one, heh. It was fairly challenging even after already knowing haskell.
21:37:09 <bitemyapp> Axman6: yeah if you have the opportunity to provide that, that's ideal.
21:37:15 <mzero> Oh! Perfect - 2 days is the most I could expect
21:37:24 <jasonkuhrt> I've been thinking about reading http://chimera.labs.oreilly.com/books/1230000000929/ sooner or later
21:37:34 <dibblego> Every time we run NICTA/course, we first teach Haskell. Fortunately, that only takes about 3 hours.
21:37:49 <bitemyapp> kadoban: if I was told I had a week or two to train a coworker in Haskell via pair-programming, I'd start with a basic Haskell tutorial and then do the NICTA course with them.
21:37:51 <Axman6> and the rest of your life
21:38:06 <kadoban> I'd be super interested in attending one of those, just out of curiosity of how people do that.
21:38:39 <bitemyapp> they're the experts in teaching NICTA course. I've only run people through a couple modules at a time, never had somebody's attention to do more than that.
21:38:47 <bitemyapp> be a blast tho :)
21:38:58 <kadoban> Heh yeah I imagine
21:39:01 <dibblego> kadoban: https://twitter.com/NICTA/status/611330704673271808
21:39:41 <kadoban> I wish I was anywhere near there :-(
21:40:06 <mzero> lovely -
21:40:10 <mzero> I'd be teaching this at Google
21:44:00 <dibblego> kadoban: you and your friends annoy NICTA enough  never know what will happen
21:44:25 <kadoban> Haha :)
21:44:43 <Axman6> are you in 'straya?
21:44:56 <kadoban> I should really check out and see if there's any functional programming groups in phoenix.
21:48:29 <dolio> johnw: It was actually changed in 98. 1.4 still had map.
21:48:44 <johnw> is anyone here in Sacramento?  I'd like to start up a Haskell users group there, if one doesn't exist already
21:52:19 <vikaton> why are more people using haskell for start-ups but not many job openings for haskell itself?
21:53:31 <dmj`> vikaton: maybe it's easier to write new haskell than port old code to haskell, not as much incentive if it's already working
21:54:47 <dmj`> vikaton: haskell is still worth learning, and by the time you graduate there will most likely be far more job openings
21:58:01 <vikaton> hope so haha
21:58:10 <Axman6> vikaton: pretty much every major language is adopting ideas from FP at a rapid rate. Learning Haskell will give you the tools to understand how to use those new features properly in any of the more mainstream languages, even if you don't get to use Haskell itself
21:58:59 <vikaton> I think haskell is worth learning in more of a educational way, rather than economical way
21:59:13 <Welkin> vikaton: that is what I thought 2 years ago
21:59:15 <Axman6> yes
21:59:18 <johnw> that doesn't have to be true
21:59:20 <Welkin> now I use haskell for everything
21:59:24 <Axman6> but getting a job also helps =)
21:59:37 <vikaton> yeah
21:59:59 <vikaton> well, I'm getting into haskell to increase my programming skills
22:00:17 <vikaton> possibly learn something new outside of programming from it but idk
22:00:17 <Welkin> by the way, I fixed all my problems I had over the last ~30 hours by just going back to ghc-7.8.4 and ignoring stackage
22:00:23 <dmj`> vikaton: it's very economical, plus it's fun, and you want a job where you're constantly learning, leads to greater career satisfaction
22:01:02 <johnw> Welkin: isn't stackage orthogonal to which compiler version you're using?
22:01:03 <vikaton> I'm not saying I don't want a haskell job :P
22:01:20 <kadoban> Welkin: That sucks. I guess 7.8.4 is more tried-and-true though
22:01:24 <Welkin> yes
22:01:49 <Welkin> everything was broken with my setup using 7.10.1 -> 7.10.2-rc1 + stackage nightly
22:02:10 <dmj`> vikaton: you'll get there, just do it everyday, for a long time. Starting young is a huge advantage
22:02:14 <Welkin> then stackage lts cause cabal hell, so I abandoned it
22:02:20 <Welkin> caused*
22:02:22 <neuroserpens> How can I compose words with getLine and bind the results to a variable using desugared do notation?
22:02:32 <vikaton> dmj`: yeah :P
22:02:59 <mzero> userInput <- words <$> getLine
22:03:07 <mzero> or, if you prefer
22:03:13 <mzero> userInput <- words `fmap` getLine
22:03:18 <neuroserpens> mzero: nice!
22:04:04 <mzero> (which, BTW, is the "sugared" notation - desugard would be (words <$> getLine) >>= (\userInput ..... )
22:04:27 <neuroserpens> yea I guessed so
22:15:08 <EponymicCycloid> Man, it's really annoying to get a machine-level cast of a Word64 to an Int64 without using `unsafeCoerce`.
22:15:30 <EponymicCycloid> The function that nominally does it (word64ToInt64#) is only exported if Word is less than 64 bits
22:15:35 <mzero> fromInegral doesn't do it?
22:15:41 <EponymicCycloid> It does it very slowly, I think
22:15:52 <EponymicCycloid> I can't find any specialization rule for it for Word64 -> Int64
22:16:11 <EponymicCycloid> It only specializes using unboxed values for certain types of numbers
22:16:31 <EponymicCycloid> so unless GHC is doing some magic that isn't apparent from the source files, it's fromInteger . toInteger or whatever
22:17:22 <EponymicCycloid> Yeah, that's what it's doing
22:17:42 <EponymicCycloid> per GHC.Real
22:18:29 <EponymicCycloid> Also , it specifically has NOINLINE on it, which I can't figure out
22:18:33 * hackagebot record-preprocessor 0.1.0.1 - Compiler preprocessor introducing a syntactic extension for anonymous records  http://hackage.haskell.org/package/record-preprocessor-0.1.0.1 (NikitaVolkov)
22:19:06 <saulzar_> Hm, that's not ideal
22:19:40 <EponymicCycloid> I'll look at a disassembly in a sec
22:21:52 <gamegoblin> I’m trying to compile an attoparsec parser and getting this error
22:21:53 <gamegoblin>     Couldn't match expected type `bytestring-0.10.0.2:Data.ByteString.Internal.ByteString'
22:21:54 <gamegoblin>                 with actual type `BS.ByteString'
22:21:58 <gamegoblin> Ideas?
22:22:10 <dmj`> gamegoblin: internal is lazy, BS is strict
22:22:24 <gamegoblin> dmj`: what should I do here?
22:22:40 <EponymicCycloid> import Data.ByteString.Lazy instead
22:23:05 <gamegoblin> I’m using the parseOnly function from attoparsec which says it takes a Data.ByteString
22:23:43 <EponymicCycloid> Sorry, import Data.ByteString
22:23:50 <EponymicCycloid> right now, you might be importing Data.ByteString.Lazy
22:23:52 <EponymicCycloid> (as BS)
22:24:12 <EponymicCycloid> Because if you import Data.ByteString as BS, BS.ByteString should == Data.ByteString.Internal.ByteString
22:24:24 <gamegoblin> EponymicCycloid: Nope, my import is "import qualified Data.ByteString as BS"
22:24:32 <EponymicCycloid> huh
22:24:47 <dmj`> Data.ByteString is strict, parseOnly is looking for a strict ByteString
22:25:00 <gamegoblin> indeed
22:25:07 <gamegoblin> Nowhere in my code does the word lazy appear anywhere
22:25:14 <gamegoblin> Never touched it
22:25:20 <dmj`> gamegoblin: to convert it to strict you need to import Data.ByteString.Lazy and use fromLazy
22:25:34 <dmj`> gamegoblin: err... toStrict
22:25:39 <gamegoblin> Are overloaded strings lazy?
22:25:55 <dmj`> gamegoblin: the conversion functions (toStrict, fromStrict) are in Data.ByteString.Lazy
22:26:12 <gamegoblin> dmj`: I am trying to determine where a lazy bytestring is even coming from, I am not using them at all
22:26:13 <dmj`> gamegoblin: you can use OverloadedStrings with either strict or lazy bytestrings
22:27:27 <gamegoblin> Unless the type system is broken, I am 100% certain the type I have is a strict bytestring
22:28:01 <gamegoblin> The value it’s erroring on saying wrong type is defined in the type signature to be a BS.ByteString (where BS is Data.ByteString)
22:28:27 <dmj`> gamegoblin: can you paste your code
22:28:31 <EponymicCycloid> OK, so preliminary result: fromIntegral compiled with -O is over 20 times faster than fromIntegral without -O
22:29:44 <EponymicCycloid> In fact, it's several billion times a second
22:29:48 <EponymicCycloid> probably native
22:31:12 <dolio> With -O it compiles to the primop.
22:31:26 <jasonkuhrt> Oh WebAssembly was announced today... Maybe Haskell can finally compiled to a decent performant target sooner than later for the web
22:32:13 <dolio> word2Int# or what have you.
22:32:42 <EponymicCycloid> Looks like word64ToInt64# compiles to nothing
22:32:45 <EponymicCycloid> it's not present in the loop
22:33:08 <EponymicCycloid> (with -O)
22:33:41 <dmj`> jasonkuhr: fantastic
22:35:21 <dmj`> jasonkuhr: seems like its very much a WIP
22:36:15 <mzero> dmj`: well, it is building on asm.js - and intends to be compatible with it - so much of the semantics are defined already
22:37:41 <Axman6> johnw: have you not seen the several haskell like languages and ghcjs?
22:38:06 <dmj`> mzero: even asm.js says its a WIP tho :/ http://asmjs.org
22:38:10 <Axman6> uh, jasonkuhrt was who that was for, but he's gone
22:38:53 <dmj`> mzero: I'm all for removing javascript from the picture 
22:43:18 <gamegoblin> dmj`: http://pastebin.com/N0k7iQYc
22:49:36 <dmj`> gamegoblin: that's strange, it doesn't error for me
22:50:00 <dmj`> gamegoblin: http://lpaste.net/134718
22:50:07 <gamegoblin> dmj`: which compiler version and which versions of bytestring and attoparsec?
22:51:12 <dmj`> ghc 7.10, bytestring 0.10.6.0, attoparsec 0.13.0.0
22:54:25 <gamegoblin> dmj`: Only difference for me is using GHC 7.6
22:55:35 <Jello_Raptor> quick question: Is there a useful functor that doesn't also have an applicative or monoid instance? 
22:55:58 <xj54y> Is there a haskell-offtopic?
22:56:14 <gamegoblin> I think there is a haskell-random or something
22:56:16 <dmj`> xj54y: #haskell-blah
22:56:18 <gamegoblin> that’s it
22:56:30 <dmj`> gamegoblin: not sure then :/
22:56:37 <gamegoblin> Well this sucks...
22:56:45 <Jello_Raptor> I:m hiving trouble thinking of one, and it would be useful for pedagogical reasons
22:57:11 <tejing> Jello_Raptor: (,) a
22:57:23 <jle`> for a in general, at least
22:57:41 <gamegoblin> dmj`: if I change my cabal to bytestring = 0.10.0.2 it works, wtf…
22:57:52 <jle`> by the way, no Functors can have a Monoid instance, because they're of different kinds
22:58:12 <Jello_Raptor> tejing: with 'fmap f (a,b) = (a, f b)' ? 
22:58:22 <tejing> Jello_Raptor: yes
22:58:34 * hackagebot auto 0.4.3.0 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.4.3.0 (jle)
22:59:14 <Jello_Raptor> hmm, presumably if there were no collision '(flip (,)) a' would also be a functor (though there is the bifunctor instance there) 
22:59:19 <gamegoblin> dmj`: apparently attoparsec has a dependency on bytestring < 0.10.4.0
23:00:17 <tejing> Jello_Raptor: you're mixing type-level and value-level stuff there, but essentially yes
23:00:32 <Jello_Raptor> tejing: i'm not sure how to do a type level 'flip' 
23:00:57 <tejing> newtype Flip f a b = Flip (f b a)
23:01:23 <dmj`> gamegoblin: not 0.13, only has an upper bound if you're on ghc 7.4
23:01:40 <gamegoblin> dmj`: I’m on ghc 7.6… wtf then...
23:01:42 <dmj`> gamegoblin: http://hackage.haskell.org/package/attoparsec-0.13.0.0/attoparsec.cabal
23:01:48 <Jello_Raptor> so then the instance would be 'Flip (,) b`?
23:02:06 <HelloEvilTofu> Hello!
23:02:32 <Jello_Raptor> tejing: any others? 
23:02:32 <tejing> Jello_Raptor: yes, and you'd need to wrap and unwrap the newtype in the fmap definition
23:02:53 <tejing> Jello_Raptor: Const a, similar reason
23:04:23 <dmj`> HelloEvilTofu: Hello
23:04:31 <dmj`> gamegoblin: it's weird :/
23:09:13 <Jello_Raptor> tejing: thank you :) 
23:10:59 <HelloEvilTofu> I just started learning Haskell a few days ago and I've come across some things which I don't understand.
23:11:04 <HelloEvilTofu> Ok to ask in here?
23:11:15 <johnw> perfectly OK
23:12:44 <HelloEvilTofu> data TimeInfo = Seconds Int | Minutes Int Seconds | Hours Int Minutes Seconds 
23:12:49 <HelloEvilTofu> Can I do something like that?
23:13:02 <johnw> no
23:13:14 <HelloEvilTofu> Is it possible to?
23:13:16 <Jello_Raptor> tejing: hmm, would creating 'Tagged t v' (functionally equivalent to '(t,v)') for values with a tag of some sort be sensible? you could get an incoming stream of 'Tag t v's and depending on the tag send them to some processor that can then act on the 'v'? 
23:13:31 <dmj`> @def data TimeInfo = Seconds Int | Minutes Int Seconds | Hours Int
23:13:32 <lambdabot>  .L.hs:148:29:
23:13:32 <lambdabot>      Data constructor ‘Seconds’ cannot be used here
23:13:34 <lambdabot>        (it is defined and used in the same recursive group)
23:13:44 <johnw> well, it depends on what functionality you hope to achieve
23:13:59 <Jello_Raptor> As a pedagogical measure, because the people I want to explain this too are much better at understanding things if I can provide concrete uses.
23:14:13 <johnw> data Timeinfo = Timeinfo Int Int Int would be best, because you can alawys pick 0
23:14:34 <liste> HelloEvilTofu something like that yes, but you're mixing types and data constructors
23:14:35 <HelloEvilTofu> then have functions to do the hour/minute/second calculation?
23:14:55 <johnw> Jello_Raptor: Tagged t v is not functionally equivalent to (t,v)
23:15:09 <johnw> in the former, t is a phantom type; it's not in the latter
23:15:45 <HelloEvilTofu> so ... if I do it as separate definations like data Seconds = Seconds Int and data Minutes = Minutes Int Seconds ?
23:15:45 <Jello_Raptor> johnw: what's a phantom type? a type with no declaration? also, is there an actual 
23:15:52 <Jello_Raptor> 'Tagged' somewhere? 
23:16:04 <liste> HelloEvilTofu yes
23:16:11 <johnw> newtype Tagged t v = Tagged v
23:16:16 <HelloEvilTofu> Thank you
23:16:21 <johnw> t is not present on the right-hand side, so it exists only at compile-time
23:16:38 <HelloEvilTofu> I just don't know what I want it to do yet. Just exploring the syntax of the language.
23:16:41 <liste> and then data TimeInfo = TSeconds Seconds | TMinutes Minutes ... to prevent name clashes
23:17:12 <HelloEvilTofu> Is there a standard Time module?
23:17:39 <pavonia> Data.Time
23:17:53 <Jello_Raptor> johnw: no, I meant 'Tagged t v = Tagged t v'. There's no way you could implment a stream separator without a concrete 't', it might be an enum style datatype, but it has to exist at runtime for any reasonable filtering to work. 
23:18:17 <HelloEvilTofu> thank you 
23:18:19 <HelloEvilTofu> looking it up now
23:18:35 * hackagebot ghcjs-websockets 0.3.0.4 - GHCJS interface for the Javascript Websocket API  http://hackage.haskell.org/package/ghcjs-websockets-0.3.0.4 (jle)
23:18:48 <Jello_Raptor> johnw: that is, unless there is a 'Tagged' lying around somewhere that I've never noticed and I've got to pick another name to avoid collision
23:19:46 <johnw> Tagged is used by edwardk in his tagged package
23:20:11 <dmj`> @package time
23:20:11 <lambdabot> http://hackage.haskell.org/package/time
23:21:16 <Jello_Raptor> johnw: aha, is there a better name for the usage I want then? 
23:21:30 <Jello_Raptor> one that reflects the function? 
23:21:44 <johnw> Paired?
23:22:52 <Jello_Raptor> johnw: hmm, that seem s too general, there's lots of things you can do with a pair. Maybe "Flagged"? saying that there's a flag for each value encoding contextual information? 
23:25:22 <jle`> data Tagged t v = Tagged t v ?
23:26:47 <HelloEvilTofu> Lets say I have PlayerRange = PlayerRange Int Int. Is there a way to enforce the first Int to be lesser than the second one?
23:27:43 <pavonia> Not with Int
23:27:50 <Cale> HelloEvilTofu: Not in Haskell. You could choose an encoding where the second thing was not an Int, but instead a Word difference from the first Int
23:28:24 <Cale> But there's no "type of proofs that n < m" or anything like that
23:28:39 <Cale> (because we don't have types parameterised on values)
23:29:12 <liste> HelloEvilTofu you could hide the PlayerRange constructor and provide a mkPlayerRange :: Int -> Int -> Maybe PlayerRange
23:29:28 <JuanDaugherty> HelloEvilTofu, you might also consider prolog
23:29:50 <JuanDaugherty> or similar
23:30:02 <Cale> Well, I was thinking more like Coq or Agda
23:30:08 <Cale> (or Idris)
23:30:13 <HelloEvilTofu> Is that a module in Haskell or the computer language Prolog?
23:30:25 <JuanDaugherty> i meant the lang
23:30:27 <Cale> I don't think Prolog has such data types either
23:30:41 <HelloEvilTofu> well, that won't help me learn Haskell. :P
23:33:40 <Cale> HelloEvilTofu: So, yeah, the standard solution to this kind of enforcing data constraints is to define a module where you don't export the data constructor for your type, and instead export a function which checks that the invariant holds before it will give you a value of that type.
23:34:39 <Cale> (or otherwise only provide things which will produce values for which the invariant holds, even if no checking is involved)
23:35:57 <HelloEvilTofu> thanks
23:36:55 <adarqui> i think i just figured out haskell
23:37:47 <Cale> adarqui: Oh? :)
23:40:43 <adarqui> slowing my mind down, staring at type signatures, and writing stuff out on paper
23:40:46 <adarqui> has helped
23:40:48 <adarqui> 8|
23:45:37 <adarqui> gn
23:52:17 <HelloEvilTofu> I normally stare at the compiler errors and try to figure out the type error
23:52:25 <HelloEvilTofu> Doesn't help :P
23:53:52 <jle`> gn!
23:58:37 * hackagebot smaoin 0.3.0.0 - Utilities for the Smaoin semantic information model.  http://hackage.haskell.org/package/smaoin-0.3.0.0 (akrasner)
