00:00:22 <tdammers_> yeah
00:00:27 <saulzar> Hm, not a fan of getting up and running either, but always feels good once you're up and going
00:00:38 <tdammers_> there's also this calvinist thinking that says if you don't get up early you're a lazy sinner
00:00:54 <saulzar> Pretty much
00:01:05 * edwardk <- lazy sinner
00:01:49 <adarqui> sleep is a wreck for me too because mainly.. later in the night is when I get to start really studying the stuff i'm passionate about
00:02:04 <adarqui> so ends up equating to staying up late + waking up early
00:02:36 <adarqui> going to fix that soon, word.
00:03:22 <tdammers_> my ideal day would be to get up at noon, herp-derp a little, run, get chores out of the way, then some family life, start working around 8, go to bed at 3
00:04:04 <saulzar> Also causing trouble, languages like Haskell which tempt me to work on things which aren't proper work
00:04:56 <tdammers_> "proper work" is an artificial and harmful distinction
00:05:26 <tdammers_> once you start making it, you're on a slippery slope towards "getting shit done"
00:06:42 <adarqui> i like running late.. but not too safe
00:07:39 * hackagebot ginsu 0.8.1.1 - Ginsu Gale Client  http://hackage.haskell.org/package/ginsu-0.8.1.1 (DylanSimon)
00:07:39 * hackagebot discrimination 0.1 - Fast generic linear-time sorting, joins and container construction.  http://hackage.haskell.org/package/discrimination-0.1 (EdwardKmett)
00:07:45 <adarqui> if i felt like i got enough done during the day.. falling asleep would be easy
00:07:46 <adarqui> 8|
00:07:49 <tdammers_> most dangerous thing about running at night where I live is that I might step on a small rock
00:08:05 <edwardk> hackagebot: do you ever get a sense of dejavu?
00:08:11 <adarqui> i stepped on this huge thorn last week, went right thru my vibrams deep into my foot.. lul ;f
00:08:41 <zipper> tdammers_: Where do you live?
00:08:44 <saulzar> Knee issues stop me running too much, but rock climbing can take up that slack
00:10:19 <tdammers_> zipper: netherlands
00:12:09 <saulzar> tdammers_, Running on trails?
00:13:53 <tdammers_> saulzar: when possible, yes
00:14:00 <slack1256> biking at night :-)
00:14:13 <saulzar> tdammers_, I recon you feel like you're going faster at night
00:14:19 <tdammers_> idk
00:14:24 <tdammers_> I don't train fast usually
00:14:57 <adarqui> why do you feel faster running at night
00:15:00 <saulzar> Maybe optical flow, because the things you can see are more sparse
00:15:06 <saulzar> I have no idea
00:17:45 <tdammers_> also, vibrams are for sissies http://s3.amazonaws.com/media.marathon-photos.com/photos/Sports/NFNL/2015/CPC%20Loop%20Den%20Haag/fullsize/CPHE2493.jpeg
00:18:47 <saulzar> I like barefoot, just not in winter... so much
00:19:04 <saulzar> Though I do run cross countries in barefoot
00:19:37 <tjscanlon> is it possible to use an index with a map in haskell?
00:19:45 <adarqui> my vibram's are named bikila's, named after a runner who set a world record in the olympics, barefoot.. in like the 70's i think
00:19:45 <tjscanlon> sorry, that was worded poorly
00:19:48 <adarqui> pretty beast
00:19:53 <tjscanlon> im using map on a list, is it possible to use the index of the element in the equation
00:20:00 <adarqui> i'd run barefoot but it's too dangerous ;f
00:20:31 <adarqui> tjscanlon: mapAccumL/mapAccumR etc maybe
00:20:52 <tdammers_> yeah, that name is kind of horrible
00:20:54 <adarqui> or you can always zip the list witih indexes
00:21:01 <tjscanlon> I guess I should say what I'm doing.  I'm trying to generate a series
00:21:06 <tdammers_> bikila was an awesome runner
00:21:12 <tjscanlon> which is just like 1/1, 1/2, 1/3, 1/4, etc.
00:21:15 <tdammers_> and he usually ran in shoes
00:21:20 <tjscanlon> slightly more complex tho
00:21:28 <tjscanlon> the bottom number is multiplied by the index
00:21:39 <tjscanlon> jstu realized i can create a list of [0..n] doh
00:21:40 <tdammers_> he just didn't have a suitable pair, so he decided to go barefoot rather than wear the wrong size
00:22:09 <saulzar> There's things like imap from lens
00:22:11 <adarqui> is that the reason? I thought he also did it to prove a point about the strength of his people.. something like that
00:22:15 <tdammers_> (also, we're deep in #-blah territory)
00:22:40 <tdammers_>  /join #haskell-blah?
00:22:47 <saulzar> > imap (\i _ -> show i) ["cat", "dog", "fish"]
00:22:48 <lambdabot>  ["0","1","2"]
00:23:59 <liste> > map (\(i,_) -> show i) . zip [1..] $ ["cat", "dog", "fish"] -- if you don't want to use lens
00:24:01 <lambdabot>  ["1","2","3"]
00:27:25 <saulzar> Yeah, liste's pattern is very common
00:27:53 <thegladiator> clear
00:35:54 <jle`> :t show . fst
00:35:55 <lambdabot> Show a => (a, b) -> String
00:37:21 <jle`> > zipWith (\i _ -> show i) [1..] ["cat", "dog", "fish"]
00:37:22 <lambdabot>  ["1","2","3"]
00:37:27 <jle`> for something closer to saulzar's example
00:37:39 <jle`> which might be nicer than a zip and map
00:42:36 <adarqui> gn
00:43:43 <sdx23> good morning
00:44:54 <sdx23> jle`: you were totally right, regarding the Map / heterogenous container thingy. So the way to go was creating a Map of (IO ())s
00:45:30 <jle`> glad it worked out sdx23 :)
00:47:26 <sdx23> jle`: I got some more help in the end, but your suggestions made it easier to see that that is the right way, thanks :)
00:47:52 <jle`> np!
00:55:49 <Pastaf> what are the builtins used to define prelude? Is there a list?
00:56:32 <liste> Pastaf http://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html
00:57:07 <liste> it's just a module imported by default
00:57:14 <merijn> Pastaf: Depends on how far down the rabit hole you want to go
00:57:40 <merijn> Pastaf: Most of prelude is reexports/implemented using GHC specific stuff which is mostly plain haskell and a few builtins
00:58:02 <Pastaf> merijn: I'm interested in what primal functions build the prelude library
00:58:15 <merijn> Pastaf: Mostly it's just haskell...
00:58:49 <Pastaf> yes, I know, but I'm interested in what the builtins that must be defined elsewhere are
00:58:51 <merijn> Pastaf: The compiler primitives mostly only deal with things like Int#, Double# style primitives. Most of the Prelude is just written in haskell
00:59:16 <merijn> Pastaf: The only real builtins you need are things like arithmetic for things like Int/Double
00:59:29 <merijn> And those are defined inside the compiler
00:59:46 <Pastaf> merijn: Yes, I was looking for a list of those
00:59:51 <liste> there's the "source" link in hackage, reading it, it seems the "magic" parts are in GHC.Base
01:00:02 <tdammers_> that, and pattern matching ;)
01:00:31 <frerich> Pastaf: You may find http://hackage.haskell.org/package/ghc-prim interesting
01:01:04 <frerich> I can never make up my mind whether it's "You might find" or "You may find".
01:01:27 <tdammers_> frerich: how about "read this it'll make you normal"
01:02:32 <Pastaf> frerich: They're interchangable most of the time, including here
01:02:39 <Pastaf> anyway, thanks
01:02:52 <kqr> is it possible to get a list of all constructors of a type?
01:03:02 <kqr> (if it matters, the type could easily be made into enum and bounded)
01:03:04 <ThreeOfEight> GHC.Magic may be one of my favourite module names.
01:03:21 <frerich> tdammers_: I'm not sure whether 'normal' is actually the word I'd use in this particular case - looking at http://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/src/GHC-Prim.html#ctz64%23 I see that all the functions are defined as 'let x = x in x'. I think this is the sonic wall for Haskell.
01:03:51 <merijn> kqr: Enum/Bounded or Generic
01:03:57 <merijn> kqr: Or TH
01:03:57 <liste> Pastaf check out the list in top of https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Base.hs
01:04:16 <merijn> liste: There;s way more magic parts than GHC.Base
01:04:22 <merijn> i.e. GHC.Prim
01:04:24 <kqr> ThreeOfEight, I myself have always liked the "reallyUnsafePtrEquality#" function name
01:04:29 <frerich> kqr: If it's Enum and Bounded, then you can get a list of all the constructors with just '[minBound..]'
01:04:37 <tdammers_> frerich: yeah, probably
01:04:49 <merijn> kqr: More than accursedUnutterablePerformIO from bytestring?
01:04:52 <kqr> frerich, ah. I was hoping for something more explicit, but perhaps that's the easiest/best solution
01:05:15 <kqr> merijn, that just sounds facetious :)
01:05:26 <tdammers_> "unsafe" alone doesn't sound dangerous enough
01:05:43 <tdammers_> (I have an `unsafeRawHtml` function in my template engine...)
01:05:48 <pharaun> "usingThisFunctionWillSetYouOnFire"
01:06:09 <merijn> kqr: It's supposedly way worse than unsafePerformIO
01:06:27 <frerich> kqr: I think it's a little odd, but I often end up having a 'allValues = [minBound..]' somewhere in a 'Utils' module. And then I have other code doing '[Chip color value | color <- allValues, value <- allValues]' or so. I.e. in context, it's not so bad.
01:06:55 <merijn> It's deprecated now, but witness the comment: https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L592-L622
01:07:21 <ThreeOfEight> kqr: there is dataTypeConstrs in https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Data.html for the more general case
01:07:38 <tdammers_> well, unsafePerformIO isn't *that* unsafe, it just violates purity
01:07:45 <liste> but GHC.Prim is all lies :(
01:07:51 <frerich> merijn: An malevolent agent of chaos? Oh, I weep at the poetic beauty of that vivid language!
01:07:52 <merijn> liste: How so?
01:07:54 <tdammers_> which is a big deal in Haskell, but compared to practically all other languages...
01:07:57 <liste> let x = x in x
01:08:16 <merijn> liste: Sure, because GHC.Prim can't be implemented in haskell, that's the point
01:08:24 <merijn> liste: GHC.Prim lists compiler builtins
01:08:34 <merijn> So obviously it has no haskell source
01:09:01 <magneticDuck> trying to write a system that attaches to a strange kind of game server API
01:09:04 <kqr> ThreeOfEight, hm. thanks. that sounds like too big a hammer for this case, but I should really learn Data.Data and that Typeable stuff eventually
01:09:14 <magneticDuck> I have a log file where log elements get written in realtime
01:09:29 <magneticDuck> and I'm having a bit of trouble integrating it into my program loop
01:09:34 <kqr> frerich, that actually sounds decent and the example you listed is basically the exact thing I want to do. cheers!
01:09:39 <magneticDuck> normally, I could just open and hReadLn the pipe
01:09:50 <magneticDuck> but here, I get an EOF error after just a little while
01:09:57 <magneticDuck> because the file is a static file that's being written to in realtime
01:10:07 <ThreeOfEight> kqr: in this case, it's not that difficult
01:10:09 <magneticDuck> what's the best haskelly way to catch an EOF like that?
01:10:42 <merijn> magneticDuck: Control.Exception and try again repeatedly?
01:10:50 <ThreeOfEight> dataTypeConstrs (dataTypeOf (undefined :: MyDataType)) should give you a list of the constructors of MyDataType
01:10:54 <magneticDuck> .. I guess
01:11:01 <magneticDuck> I was asking for a more haskelly way though =P
01:11:17 <magneticDuck> oh well, I can use that for the time being at least
01:11:31 <tdammers_> conduits? pipes? idk
01:11:43 <magneticDuck> the thing is
01:11:44 <ThreeOfEight> well, a representation of the constructor
01:11:50 <magneticDuck> the file isn't a pipe
01:11:53 <ThreeOfEight> but, yeah, in your case, Enum is probably the way to go
01:12:02 <magneticDuck> I could make a pipe interface to it
01:12:14 <magneticDuck> but I was wondering if there was a haskelly way to make that interface
01:12:20 <frerich> magneticDuck: I once did something similiar (I had to do IPC with another process which wrote a file and my program read from it) and I basically ended up catching any EOF exceptions and only actually rethrowing them if the target processes stopped as well.
01:12:40 <magneticDuck> yeah
01:12:45 <magneticDuck> alright I'll just do that
01:13:00 <magneticDuck> although in this case for mysterious reasons the host process will never stop, as far as my program is concerned
01:13:01 <kqr> ThreeOfEight, but the result would be [Constr], and not [MyType], no?
01:13:27 <kqr> magneticDuck, have you looked into conduits/pipes? that sounds kinda like what they were invented for
01:13:28 <merijn> magneticDuck: pipes has little to do with file pipes, though, it's just the name of a library
01:13:33 <ThreeOfEight> kqr: yes
01:13:43 <magneticDuck> yes ik
01:13:52 <magneticDuck> I've heard about pipes and conduits and all the other libraries, they're great
01:13:53 <ThreeOfEight> but you can convert the Constr things to values of MyType
01:13:56 <merijn> kqr: That won't eliminate the need to have a try/except loop around the EOF exception
01:14:06 <magneticDuck> but right now I'm writing the interface from this static file thing to the haskell structure
01:14:27 <frerich> magneticDuck: There is also hIsEOF using which you could maybe do something like 'getLine `untilM` isEOF'
01:14:28 <ThreeOfEight> with fromConstr, I guess?
01:14:37 <magneticDuck> okay, that's also nice
01:14:44 <frerich> magneticDuck: ...but I somehow always stay away frmo 'isEOF' checks due to the races.
01:14:55 <magneticDuck> hm?
01:15:45 <frerich> magneticDuck: Actually, maybe it's ok in your particular use case.
01:15:57 <frerich> You just read until EOF, then check the processes, and then decide what to do.
01:16:42 <magneticDuck> actually I'd just write a "waitEvent :: Handle -> IO String" that waits until not . hIsEOF and then reads a line
01:17:01 <ThreeOfEight> Anybody using Haskell on Git or Sabayon?
01:17:16 <ThreeOfEight> The GCC hardening is really getting on my nerves here.
01:17:54 <kqr> merijn, hm, I was hoping either of those two libraries would have a helper function for just the situtaion magneticDuck is in: doing tail -f style reading
01:18:13 <ThreeOfEight> http://downthetypehole.de/paste/8Bog3dam
01:18:22 <magneticDuck> eh, I can do it like this
01:18:35 <kqr> ThreeOfEight, ah, see, this is exactly why I should learn Data.Data and that stuff. it makes traditional TH tasks so simple, it seems
01:18:48 <ThreeOfEight> I've been having this error with a manually-installed Haskell Platform (latest) and cannot figure out how to make it go away
01:18:55 <ThreeOfEight> kqr: some of them at least, yes
01:18:58 <magneticDuck> a simple monad fold (um, sequence) mapped across the input should be fine
01:19:23 <ThreeOfEight> it is rather interesting, but I cannot say I ever used it myself, at least not directly.
01:19:39 <ThreeOfEight> I think it's more of a library thing.
01:21:00 <CoconutCrab> ThreeOfEight: can you explain what did you do for installing "manually"?
01:21:58 <ThreeOfEight> tar -xf in /, then activate-hs
01:22:08 <ThreeOfEight> done it a million times on other distributions, always worke
01:22:09 <ThreeOfEight> *worked
01:22:37 * hackagebot cookie 0.4.1.6 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.4.1.6 (MichaelSnoyman)
01:22:41 <ThreeOfEight> I think on Sabayon/Gentoo, some additional relocatable code thing is done to GCC/ld, and that does not work with GHC. Or something like that.
01:23:00 <ThreeOfEight> Disclaimer: I don't know the first thing about compiling/linking.
01:24:06 <CoconutCrab> mmm, I guess it can be fixed by changing the build flag when you compile Haskell platform
01:24:26 <CoconutCrab> but I don't have any experience building it..
01:24:45 <CoconutCrab> ThreeOfEight: is the version from portage runnable?
01:26:30 <ThreeOfEight> I'm not using Portage, I use Entropy
01:26:45 <ThreeOfEight> from what I've heard, mixing the two is possible, but not recommended
01:27:20 <ThreeOfEight> I think I used the Entropy version once, but somehow, Cabal didn't work on that. At all. I.e. the binary was just not there.
01:27:25 <srhb> Are you trying to build it with dynamic libraries?
01:27:44 <CoconutCrab> ThreeOfEight: I don't use Sabayon (on OpenSUSE right now) but I have used gentoo before, maybe you can check the build flag specified in the distro's version 
01:29:27 <jle`> i wonder how many copies of Data.Text i have compiled/installed on my machine...
01:29:31 <jle`> in different sandboxes
01:29:51 <ThreeOfEight> srhb: Not that I am aware, no.
01:30:03 <CoconutCrab> ThreeOfEight: for example, in ghc ebuild, they have disable PIE/PIC 
01:30:12 <CoconutCrab> ThreeOfEight: https://sources.gentoo.org/cgi-bin/viewvc.cgi/gentoo-x86/dev-lang/ghc/ghc-7.8.4.ebuild?revision=1.10&view=markup 
01:30:14 <ThreeOfEight> I just removed my .cabal just to be sure there were no configurations in there to the contrary
01:30:22 <CoconutCrab> line 181 and 182
01:32:21 <ThreeOfEight> CoconutCrab: okay, I'm not entirely sure what I am to do to fix this.
01:33:31 <CoconutCrab> ThreeOfEight: I would check how Sabayon builds ghc, and try to reuse their build flag. 
01:33:52 <ttt_fff> is there a shorthand for "sequence $ map" ?
01:34:00 <CoconutCrab> ThreeOfEight: similar to those in gentoo ebuild, but I don't know anything about sabayon
01:34:24 <srhb> ttt_fff: Presumably you mean sequence . map
01:34:51 <ski> ttt_fff : `mapM' ?
01:35:06 <ttt_fff> sequence $ map func lst
01:35:09 <ttt_fff> mapM func lst ?
01:35:11 <ttt_fff> I like
01:35:15 <ttt_fff> :t mapM
01:35:16 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
01:35:28 <ThreeOfEight> CoconutCrab: okay, thanks
01:35:31 <ttt_fff> :t (sequence . map)
01:35:32 <lambdabot> Traversable ((->) [a1]) => (a1 -> a) -> [[a1] -> a]
01:35:42 <ski> @type mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:35:43 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
01:35:46 <ThreeOfEight> I think I don't feel like messing about with this at the moment
01:35:57 <ski> @type (sequence .) . map
01:35:58 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
01:36:03 <ThreeOfEight> I will just not use Haskell on this computer for now. And perhaps not use Sabayon again in the future.
01:36:25 <ttt_fff> waht is Sabayon
01:36:36 <ThreeOfEight> ttt_fff: a Gentoo-like Linux distribution
01:36:37 <ttt_fff> need to install hlint so haskell can tell me how to write haskell
01:36:51 <ttt_fff> ThreeOfEight: gentoo was like 10 years too early
01:36:58 <ttt_fff> computers finally fast enough to compile from source
01:37:05 <ski> @type traverse
01:37:06 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:37:12 <ThreeOfEight> well Sabayon has binary packages, too
01:37:16 <ThreeOfEight> which makes it less painful to use
01:37:23 <ski> ttt_fff : ^ also does the same thing, but for any idiom (applicative functor), not just monads
01:37:34 <ThreeOfEight> but I have yet to find a distribution that matches the speed of Arch's pacman
01:37:35 <ttt_fff> ThreeOfEight; I see Sabayon, and I see Saiyan, and I think GoKu + Vegeta
01:37:50 <srhb> ttt_fff, ThreeOfEight: #haskell-blah :)
01:37:53 <ttt_fff> I want a package manager that will show me dragon ball z battles while it's apt-getting pacakges
01:37:56 <ttt_fff> sorry
01:38:19 <ttt_fff> #haskell-blah is the new "get a room" // end unrelated comments
01:38:31 <ttt_fff> why does ahskell-src-exts take so long to build ?
01:38:38 <ttt_fff> seems to be main bottleneck in installing hlint
01:40:56 <srhb> Probably because it's large and complex. :-)
01:42:54 <srhb> ttt_fff: Why not use a package manager for getting things like that though? :) You probably only need the executable after all.
01:43:09 <ttt_fff> srhb: #haskell-blah
01:43:11 <ttt_fff> I'm kidding :-)
01:43:20 <srhb> Heh, I see the irony. But still. :)
01:43:28 <ttt_fff> I don't use Sabayan / Gentoo; was just chatting with ThreeOfEight
01:43:38 <ttt_fff> I actually use Nginx to get ghcjs to build
01:43:56 <ttt_fff> no sorry, not Nginx, Redhat
01:44:08 <ttt_fff> some badass wrote a Vagrant file for ghcjs that uses Redhat ... so now I'm using Redhat to compile ghcjs
01:44:29 <srhb> ttt_fff: But there's no Redhat package for hlint?
01:44:47 <ttt_fff> oh, you mean why I did "cabal install" instead of "yum  /apt-get hlint" ?
01:44:54 <ttt_fff> I'm using stackage.lts to avoid cabal hell
01:45:54 <srhb> ttt_fff: Yes exactly
01:46:21 <ttt_fff> yeah, I've always found that binary packages for haskell are out of date (due to realse cycle of linux distro)
01:46:30 <ttt_fff> so then I have to cabal install something , and it does not play well with existing binary packages
01:46:37 <srhb> ttt_fff: I would agree, but hlint is sort of the odd one out here.
01:46:40 <ttt_fff> so now I just cabal install everything, and to avoid cabal hell, use a monthly release of stacklage.lts
01:46:59 <ttt_fff> srhb: http://www.stephendiehl.com/posts/vim_haskell.html
01:47:06 <ttt_fff> how is hlint 'odd one out' ?
01:47:52 <srhb> ttt_fff: Well I mean, it's not a library that you probably care about being super up to date, but an executable you just run on hs files independent of the rest of your hs install, mostly. (unless you really are using the library which the executable depends on)
01:48:10 <srhb> But anyway, it was just a side comment. I don't like compiling things. :-)
01:48:11 <ttt_fff> ah, I see your logic
01:53:29 <ttt_fff> well, it compiled now
01:53:36 <ttt_fff> hlint is precurosr to skynet
01:53:41 <ttt_fff> it'll eventually write haskell code on its own
01:54:07 <ttt_fff> :t (<$>)
01:54:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:54:08 <srhb> ttt_fff: Combine it with djinn and you're good to go.
01:54:33 <ttt_fff> Djinn uses an theorem prover for intuitionistic propositional logic to generate a Haskell expression when given a type.
01:54:37 <ttt_fff> is this an april fools joke ?
01:54:44 <srhb> @djinn a -> a
01:54:45 <lambdabot> f a = a
01:54:50 <srhb> @djinn a -> b -> a
01:54:50 <lambdabot> f a _ = a
01:54:54 <srhb> etc.
01:56:00 <ski> @djinn NotNot (Either a (Not a))
01:56:00 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
01:56:43 <srhb> ttt_fff: Why write your own code when you can have djinn do it for you. :-)
01:56:58 <saep> @djinn IO ()
01:56:58 <lambdabot> Error: Undefined type IO
01:57:01 <saep> :(
01:57:07 <srhb> saep: IO is overrated.
01:57:24 <saep> I wanted it to write my `main`. 
01:57:35 <srhb> saep: main = ioify purething
01:57:37 <srhb> :-)
01:57:42 <arkeet> main = return ()
01:57:44 <arkeet> :-)
01:58:43 <ttt_fff> I think we need to hook djinn up with https://github.com/ajtulloch/dnngraph , run it on all existing hackage code, and raise a couple mil funding for it
02:01:51 <magneticDuck> $djinn (a -> b) -> (b -> a) -> a
02:01:57 <magneticDuck> @djinn (a -> b) -> (b -> a) -> a
02:01:58 <lambdabot> -- f cannot be realized.
02:02:05 <magneticDuck> is that so
02:02:32 <ski> @djinn ((a -> b) -> (a,c)) -> (a,b -> c)
02:02:32 <lambdabot> -- f cannot be realized.
02:02:40 <Cale> djinn can't construct fixed points
02:03:01 <magneticDuck> well yes that makes sense
02:03:17 <magneticDuck> if it's using a theorem prover for an actually consistent logic
02:03:29 <magneticDuck> just wanted to confirm my suspicions =P
02:04:51 <PMG_> Hey I was wondering if someone had the time to explain a segment of haskell code to me (should be very basic)
02:04:55 <ski> @djinn ((a -> b) -> (a,c)) -> NotNot (a,b -> c)
02:04:55 <lambdabot> f a b =
02:04:55 <lambdabot>     case a (\ c ->
02:04:55 <lambdabot>             void (b (c,
02:04:55 <lambdabot>                      \ d ->
02:04:55 <lambdabot>                      void (case a (\ _ -> d) of
02:04:57 <lambdabot>                            (_, e) -> b (c, \ _ -> e))))) of
02:04:59 <lambdabot>     (f, g) -> void (b (f, \ _ -> g))
02:05:04 <Cale> PMG_: Sure, link it
02:05:16 <PMG_> http://lpaste.net/135028
02:05:32 <ski> hm, that seems to be roughly the classical proof i had in mind ..
02:05:47 <PMG_> I understand the natural number definition and vector definition but not SNat
02:06:16 <magneticDuck> ski: what's NotNot?
02:06:34 <ski>   type NotNot a = Not (Not a)
02:06:40 <merijn> PMG_: All values you pass to functions require a type of kind *, so you cannot pass a value of type "S Z" to any functions
02:06:43 <ski>   type Not a = a -> Void
02:06:48 <ski>   void :: Void -> a
02:06:55 <ski>   void v = case v of {}
02:06:59 <Cale> PMG_: SNat is a singleton type for Nat. The idea is that for each *type* n of *kind* Nat, there is one *value* of *type* SNat n
02:07:10 <merijn> PMG_: So how do I somehow get that type into my function signatures to use it? Simply define a wrapper value that has that type as argument
02:07:53 <ski> magneticDuck : with `data Void where {}', obviously
02:08:12 * magneticDuck blinks
02:08:19 <merijn> ski: Isn't the usual definition "newtype Void = Void Void"?
02:08:41 <Cale> So it provides a value-level representation for what's going on at the type level. This kind of ugly hackery is to make up for the fact that Haskell isn't really dependently typed, so types are not really values in Haskell.
02:08:47 <ski> merijn : i prefer the other one
02:09:33 <merijn> PMG_: FWIW if you wanna play with this stuff then trying Idris, Agda or Coq will be much simpler
02:09:54 <merijn> PMG_: Proper dependently typed languages remove a lot of the painful boilerplate and mess
02:10:24 <PMG_> I'm actually studying haskell specifically 
02:10:45 <PMG_> I think I need to go revise kinds then
02:10:57 <PMG_> So you can't use Nat in a type signature?
02:10:57 <merijn> PMG_: This sorta haskell is more academic curiosity than really practical stuff atm :)
02:11:23 <merijn> PMG_: The way DataKinds works is that it both defines a set of values and their type and a set of types and their kind
02:11:38 <merijn> PMG_: You can use it as either, but you can't mix them
02:12:23 <merijn> PMG_: i.e. think of "makeVec :: a -> Nat -> Vec a ??" I have no way to get the Nat to show at the type level
02:12:41 <merijn> PMG_: Because haskell lacks dependent types, so my return type can't depend on the Nat argument
02:13:15 <srhb> Mixing them is what Weirich and Eisenberg have been working on, right?
02:13:35 <merijn> PMG_: I can only have types depend on types, so "makeVec :: a -> Z -> Vec a Z", but this is in error because either 1) Z is not a type (but a value) or 2) Z is a type, but of kind Nat and you can't have values of kinds other than * in haskell
02:13:47 <merijn> PMG_: Which means you can't call that function (no arguments to give)
02:14:15 <PMG_> o.O
02:14:36 <merijn> PMG_: But if I have "makeVec :: a -> SNat Z -> Vec a Z", this works because 'Z' is now a type, "SNat Z" is a type of kind * (that happens to have a Nat argument type) and my return type only depends on types, not on values
02:15:00 <merijn> I can even generalise it to "makeVec :: a -> SNet n -> Vec a n" and it's still sensible
02:15:04 <merijn> srhb: A bit, yes
02:15:16 <ski> (s/Nat argument type(Nat argument kind/)
02:15:18 <merijn> srhb: And you can do a lot of stuff, but as I said, it has lots of boilerplate
02:15:25 <srhb> merijn: Sure. :)
02:15:37 <srhb> I'm mostly curious what the type-kind unification will practically mean.
02:15:44 <srhb> As I understand it it's mostly GHC internals for now.
02:15:45 <merijn> ski: By "Nat argument type" I mean "a type of kind Nat as argument"
02:16:01 <ion> :exf "(a -> b) -> (b -> a) -> a"
02:16:50 <PMG_> So if I got this right
02:17:02 <exferenceBot> replying took too much time (60sec), aborting.
02:17:06 <merijn> A lot of people seem to think dependent types are hard and then proceed to do stuff like Stephanie Weirich's work, which is magnitude harder than a DT language :p
02:17:30 <PMG_> A single type is one that wraps a single data type (by taking it as an argument) with the sole purpose that the data type has a kind * so that it can be used in functions (appear in their type signature)
02:17:47 <merijn> PMG_: Right
02:17:53 <merijn> Well, s/single/singleton
02:18:07 <PMG_> Yes sorry I meant to type singleton
02:18:11 <PMG_> :p
02:18:35 <merijn> More precisely I'd say that "singleton datatypes take one (or more) types of a kind other than * for the sole purpose of building a type that has kind * so that it can be used in functions"
02:19:12 <PMG_> Ah right
02:19:15 <merijn> PMG_: Whereas in Idris/Agda/Coq you could just use function arguments directly in the result type, because types are allowed to depend on values
02:19:41 <srhb> Real pi types would be nice.
02:19:54 <PMG_> Could you also explain the 'type family' code (link again: http://lpaste.net/135028)
02:20:04 <merijn> PMG_: i.e. you'd have "makeVec :: a -> (n :: Nat) -> Vec a n"
02:20:18 <merijn> PMG_: Type families are just "type level functions"
02:20:31 <merijn> PMG_: i.e. they take one or more types as input and return a new type as result
02:20:51 <merijn> PMG_: So it's defining an addition functions for Nat at the type level
02:21:57 <merijn> @let type family (+) (n :: Nat) (m :: Nat) :: Nat where { (+) Z m = m; (+) (S n) m = S ((+) n m) }
02:21:58 <lambdabot>  .L.hs:147:23: Not in scope: type constructor or class ‘Nat’
02:21:59 <lambdabot>  
02:21:59 <lambdabot>  .L.hs:147:34: Not in scope: type constructor or class ‘Nat’
02:22:01 <PMG_> So in this case its adding the additional functionality?
02:22:02 <merijn> awww
02:22:15 <merijn> @undefine
02:22:15 <lambdabot> Undefined.
02:22:17 <merijn> @let data Nat = Z | S Nat
02:22:18 <lambdabot>  Defined.
02:22:22 <merijn> @let type family (+) (n :: Nat) (m :: Nat) :: Nat where { (+) Z m = m; (+) (S n) m = S ((+) n m) }
02:22:23 <lambdabot>  Defined.
02:22:48 <merijn> :k S (S Z) + S (S (S z))
02:22:49 <lambdabot> Not in scope: type variable ‘z’
02:22:53 <merijn> :k S (S Z) + S (S (S Z))
02:22:54 <lambdabot> Nat
02:22:59 <merijn> :k! S (S Z) + S (S (S Z))
02:23:03 <merijn> awww
02:23:07 <merijn> :kind! S (S Z) + S (S (S Z))
02:23:12 <merijn> Try that in ghci
02:23:22 <merijn> ":kind!" will evaluate the expression
02:23:24 <alpounet> would be nice to add that to \b
02:24:26 <PMG_> Spits out a lot of errors
02:24:51 <merijn> Oh, yeah I guess you need to enable a ton of extensions :p
02:25:00 <merijn> At least DataKinds, TypeOperators and TypeFamilies :p
02:25:01 <ThreeOfEight> ghc -XKitchenSink
02:25:03 <merijn> λ :kind! S (S Z) + S (S (S Z))
02:25:04 <merijn> S (S Z) + S (S (S Z)) :: Nat = 'S ('S ('S ('S ('S 'Z))))
02:25:22 <PMG_> all of those are enables
02:25:23 <merijn> And maybe KindSignatures
02:25:31 <merijn> PMG_: In GHCI? :p
02:25:37 <PMG_> enabled*
02:25:54 <PMG_> What do you mean in GHCI?
02:26:01 <PMG_> They are at the top of my source code
02:26:05 <merijn> You need ":seti -XDataKinds" (i.e. enable it in the prompt, as opposed to in the source file)
02:26:21 <merijn> PMG_: That enables it for the source you're loading, NOT for code typed into the interpreter :)
02:26:32 <PMG_> oh right
02:26:56 <merijn> PMG_: You can auto enable them by putting them in your .ghci: https://github.com/merijn/dotfiles/blob/master/dotfiles/ghci
02:27:30 <PMG_> Do I need them for something?
02:27:45 <PMG_> I'm just trying to figure out type families
02:28:10 <PMG_> So in the example I provide is addition being implemented?
02:28:18 <PMG_> provided*
02:28:23 <merijn> PMG_: Right, it's addition for Nat
02:28:33 <merijn> Recursive implementation for peano numbers
02:28:44 <PMG_> type family (+) (n :: Nat) (m :: Nat) :: Nat
02:28:51 <PMG_> So the 'new' type is called Nat also?
02:29:37 <merijn> PMG_: That's saying (+) is a type family (read: type level function) that takes two Nat and returns a Nat
02:31:58 <PMG_> So what are the benefits of implementing (+) like this?
02:32:04 <Geraldus> hi friends! (: 
02:32:09 <PMG_> Type safety in that it can only be used by Nat?
02:32:19 <merijn> PMG_: What do you mean benefits?
02:32:23 <merijn> Benefits over what?
02:32:29 <PMG_> Oh
02:32:37 <PMG_> So there is no other way to implement (+) for Nats?
02:32:40 * hackagebot snaplet-fay 0.3.3.12 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.12 (AdamBergmark)
02:32:49 <PMG_> What about a a regular function (+)
02:32:53 <merijn> PMG_: Well, keep in mind this is TYPE LEVEL
02:33:06 <merijn> Regular functions work on *values*, not on types
02:33:16 <PMG_> Ohhhh
02:33:26 <PMG_> Right
02:33:39 <merijn> "SNat (S Z + S Z)" -> "SNat (S (S Z))"
02:33:53 <merijn> You can't do that using regular functions, because those don't work on types
02:34:13 <ski> i suppose you could make a `Sum :: Nat -> Nat -> Nat -> Constraint' class ..
02:34:36 <ski> (or even a `Sum :: Nat -> Nat -> Nat -> *' type, though that's probably less helpful here)
02:35:31 <PMG_> hmm
02:37:06 <PMG_> How is this implementing addition properly: type instance (+) (S m)  n = S (m + n)
02:37:51 <merijn> "(1+x) + y" is equivalent to "1 + (x + y)"
02:38:40 <tamasgal> is there a way to enable VI mode in GHCi?
02:39:22 <frerich> This type level hackery reminds me a bit of the template libraries in C++, which were amusing in a cocktail party sense but rarely useful in practice (and I think for a long time, they mostly served as test suites for compiler implementors...)
02:40:27 <merijn> frerich: Speak for yourself, I use templates a lot in C++ even the "cocktail party" style templates...
02:40:57 <PMG_> @merijn That kinda makes sense now
02:40:57 <lambdabot> Unknown command, try @list
02:41:17 <merijn> frerich: But as I said, this stuff is much easier in a proper dependently typed language
02:41:37 <frerich> merijn: I'm not talking about straightforward algorithms or containers but about things like type lists and templates operating on type lists to generate e.g. class hierarchies (a la Alexandrescu)
02:41:56 <merijn> frerich: https://github.com/merijn/GPU-benchmarks/blob/master/CUDA.hpp#L96-L114 ? :p
02:42:15 <PMG_> Merijn what would be the advantage to using vectors to simply using lists?
02:42:31 <frerich> merijn: I was rather thinking of http://loki-lib.sourceforge.net/html/a00681.html
02:42:44 <mniip> PMG_,O(1) access
02:42:45 <merijn> PMG_: Statically prove there's no out of bounds exceptions
02:42:54 <merijn> mniip: Don't need DT vectors for that
02:43:12 <merijn> You can just use Array or some other non-dependent type
02:44:01 <merijn> PMG_: Imagine how much C/C++ debugging time could be saved if no one ever had out of bound errors ;)
02:44:06 <PMG_> What do you mean by out of bounds exceptions?
02:44:12 <ski> > [] !! 0
02:44:14 <lambdabot>  *Exception: Prelude.!!: index too large
02:44:19 <PMG_> right
02:44:27 <PMG_> and maybe: head [] ?
02:44:36 <merijn> That's similar, yes
02:45:01 <merijn> PMG_: Take a look at my heterogeneous list example (which gets you a safe head function for free!) https://gist.github.com/merijn/dc00bc7cebd6df012c5e
02:45:02 <ski> > array (1,0) [] ! 0
02:45:04 <lambdabot>  *Exception: Ix{Integer}.index: Index (0) out of range ((1,0))
02:46:20 <PMG_> Hmm okay so in the case of head
02:46:29 <PMG_> type of head is: [a] -> a
02:46:44 <ronh-> in C++ safe indexing is considered the one that throws exception, instead of reading outside of vectors bounds or silently corrupting your data
02:46:46 <PMG_> So it looks like any list of type a will work but it doesnt ([] throws exception)
02:47:09 <PMG_> But if we use vectors, we can define the function only for non empty vectors so this issue is stopped at the type level?
02:47:16 <merijn> PMG_: Right
02:48:00 <merijn> PMG_: In the code I linked "head :: HList (a ': l) -> a" but the empty list has type "Nil :: HList '[]", zo "head Nil" would be a type error (you can load that file into ghci and try!)
02:49:49 <PMG_> Yeah i'll have a look at it
02:50:11 <PMG_> Why does it look like: HList (a ': l) though?
02:50:23 <PMG_> ': is not familar to me
02:50:33 <merijn> PMG_: It's lifting a list to the type level :)
02:50:45 <merijn> PMG_: The ' is for disambiguating values and types
02:51:07 <merijn> With DataKinds on "True" could be either a value of type Bool or a type of kind Bool
02:51:30 <merijn> The ' disambiguates it as the type, i.e. 'True is always the *type* True of kind Bool
02:52:04 <PMG_> Yeah I don't understand that, need to go look at kinds I think
02:52:07 <merijn> So if (1 : []) is a value level list of Int, then (Int ': '[]) is a type level list of kind [*]
02:52:48 <merijn> PMG_: You know how in your original code you could write "SNat Z", because Z was a *type* of kind Nat, right?
02:53:15 <ski> @kind ''a'
02:53:16 <lambdabot> parse error on input ‘'’
02:53:39 <merijn> But the way DataKinds works there is also a *value* Z of type Nat, how do you decide whether some 'Z' is a value or a type? Often it's unambiguous, but sometimes it's not
02:54:00 <PMG_> type of kind Nat?
02:54:07 <merijn> So the solution is that prefixing with a ' means it's always the *type*
02:54:30 <merijn> It's lunchtime though, so can't explain this, someone else will have to take over :)
02:54:43 <PMG_> Thank you for all the help!
02:54:55 <PMG_> Ill consult some online resources for information on kinds.
02:59:44 <ion> Given data () = () and DataKinds there's ambiguity: is () in a type the thing on the left hand side of the = or the one on the right hand side? It's resolved by the ' notation: the type () means the thing on the left hand side (as it always did) and the type '() means the thing on the right hand side.
02:59:55 <ion> @kind ()
02:59:56 <lambdabot> *
03:00:04 <ion> @kind '()
03:00:05 <lambdabot> ()
03:02:58 <ion> With DataKinds, data A = B defines the type A :: *, the value B :: A and also the type 'B :: A
03:04:18 <ion> This is still unambiguous in data A = A
03:04:47 <ion> PMG: ↑
03:08:07 <thimoteus> @djinn (a -> b -> c) -> (a -> b) -> (a -> c)
03:08:07 <lambdabot> f a b c = a c (b c)
03:08:49 <thimoteus> d'oh, that's just the S combinator
03:09:14 <ski> (what were you expecting ?)
03:09:51 <thimoteus> i don't know, it's early :(
03:20:23 <sinelaw> hvr, just installed ghc-7.10.2 from your PPA, ghc --version says: 7.10.1.20150619
03:21:02 <hvr> sinelaw: that's about right...
03:21:25 <sinelaw> for some reason I expected it to say 7.10.2 - am I missing something? :)
03:22:28 <hvr> sinelaw: the RCs of 7.10.2 need to be named 7.10.1.x in order to retain the proper ordering
03:22:44 <hvr> i.e. 7.10.1 < 7.10.1.20150619 < 7.10.2
03:22:55 <sinelaw> ah ok
03:23:13 <hvr> also useful:  ghc --print-project-git-commit-id
03:23:23 <sinelaw> with semvers, 1.2.3-anything < 1.2.3,  and we could use 7.10.2-rc1
03:23:25 <hvr> (or ghc --info | grep Git)
03:23:39 <sinelaw> thanks
03:24:06 <hvr> well, we just deprecated version tags in Data.Version =)
03:32:42 * hackagebot gipeda 0.1.1 - Git Performance Dashboard  http://hackage.haskell.org/package/gipeda-0.1.1 (JoachimBreitner)
03:34:12 <sinelaw> hvr, I read the ticket https://ghc.haskell.org/trac/ghc/ticket/2496
03:34:24 <sinelaw> and still think switching PVP to be semver compatible would be a better idea
03:38:39 --- mode: ChanServ set +o Cale
03:39:06 <solatis> hmm what would be the best aproach to install a package's master rather than hackage version using cabal, possibly within a cabal sandbox ?
03:39:12 --- mode: Cale set -b *!qorrie@unaffiliated/schaap137
03:39:18 <solatis> can i do something like 'cabal sandbox add-source $gitrepo' ?
03:39:54 <solatis> (specifically, i want to install the master version of cabal, which makes it more interesting :))
03:40:06 <dcoutts> solatis: cabal get --source-repository
03:40:14 <dcoutts> and then cabal sandbox add-source
03:40:25 <solatis> awesome
03:40:47 <solatis> hmm i could just as well do a `git clone` and then add-source, tho
03:41:18 <srhb> solatis: cabal get -s is git clone 
03:41:34 <srhb> Only you need to sort out the repository address yourself.
03:41:34 <solatis> then i'll just do that, makes it more transparent
03:41:40 <srhb> Er
03:41:44 <srhb> When doing git clone manually, that is :-)
03:41:47 <solatis> yeah i understand
03:41:58 <PMG_> Can someone briefly explain the concept of kinds
03:42:02 <solatis> stupid cabal latest release still doesn't work properly under windows
03:42:05 <srhb> PMG_: They are the types of types!
03:42:06 <solatis> (with ghc 7.10)
03:42:19 <dcoutts> solatis: mm?
03:42:58 <solatis> dcoutts: temp paths with ghc 7.10 are too long under windows, fix is in master
03:43:02 <PMG_> @srhb Maybe in a little more detail :p
03:43:02 <lambdabot> Source not found. Are you typing with your feet?
03:43:14 <srhb> PMG_: There's not much more to it, really. Values have types as types have kinds.
03:43:19 <srhb> :k Maybe
03:43:20 <lambdabot> * -> *
03:43:36 <dcoutts> solatis: ahh
03:43:38 <srhb> PMG_: That's a type of kind * -> * -- ie. it takes one (type) argument and produces a type.
03:43:56 <PMG_> Okay so I read about the type of maybe, it takes 1 argument so its kind __ -> * and you deduce the first part from Just a (value) so it must have kind * -> *?
03:44:11 <PMG_> :k Either
03:44:12 <lambdabot> * -> * -> *
03:44:14 <srhb> PMG_: I don't know what you mean by deducing
03:44:22 <ski> PMG_ : yes
03:44:26 <srhb> PMG_: It could be data NotMaybe a = Just | Nothing
03:44:28 <frerich> PMG_: You don't need to deduce it, you merely look at the left side of '=' in 'data Maybe a = Nothing | Just a'.
03:44:37 <srhb> PMG_: It would still take one type argument to produce a NotMaybe
03:44:46 <srhb> Er, NotMaybe a
03:45:03 <PMG_> :k NotMaybe
03:45:04 <lambdabot>     Not in scope: type constructor or class ‘NotMaybe’
03:45:14 <srhb> PMG_: It doesn't exist. data NotMaybe a = Just | Nothing
03:45:16 <frerich> PMG_: That 'type constructor' Maybe takes one type argument 'a'. So 'Maybe' takes one type and produces a new type, hence it is of kind '* -> *'
03:45:22 <srhb> PMG_: The point being that none of the value constructors take any arguments.
03:45:33 <srhb> PMG_: But the _type_ constructor still does.
03:45:37 <srhb> (a phantom one, in this case)
03:46:10 <PMG_> So when is the kind not *
03:46:12 <PMG_> The kinds of value constructors?
03:46:23 <srhb> PMG_: The kind of non-nullary type constructors
03:46:25 <srhb> Not value constructors.
03:46:52 <ski> @let data AnotherNotMaybe (a :: * -> *) = NotJust | NotNothing
03:46:53 <lambdabot>  Defined.
03:46:58 <ski> @kind AnotherNotMaybe
03:46:59 <srhb> Int is *, Maybe is * -> *, Either is * -> * -> * etc
03:46:59 <lambdabot> (* -> *) -> *
03:47:46 <ski> @let data NotMaybe a = NotJust | ANothing
03:47:47 <neuroserpens> Alright... This must be really basic but I need help... If I type sum [x | x <- [1 .. 999], mod x 3 == 0 || mod x 5 == 0] in ghci it works perfectly... If I do the same after main = and try to compile it ghc whines and points 3 errors... What's going on?
03:47:47 <lambdabot>  .L.hs:145:19:
03:47:47 <lambdabot>      Multiple declarations of ‘NotJust’
03:47:47 <lambdabot>      Declared at: .L.hs:142:38
03:47:55 <ski> oh
03:47:56 <PMG_> So AnotherNotMaybe takes a type of kind (*->*) and produces a type of kind *?
03:48:02 <ski> @let data NotMaybe a = UnJust | ANothing
03:48:03 <lambdabot>  Defined.
03:48:05 <srhb> neuroserpens: The type of main is IO ()
03:48:07 <ski> @kind NotMaybe
03:48:08 <lambdabot> k -> *
03:48:18 <srhb> neuroserpens: The type of your expression is not, so there's a type error.
03:48:18 <neuroserpens> srhb: oh shit...
03:48:46 <ski> `NotMaybe' is a polymorphic type, it has kind `* -> *' and also kind `(* -> *) -> *' and ...
03:49:00 <srhb> neuroserpens: (what ghci does is essentially `print it` where it is the last expression you entered)
03:49:04 <ski> (in general, `k -> *' for any kind `k')
03:49:12 <srhb> neuroserpens: So you can simulate the same behaviour by adding print to your main.
03:49:53 <neuroserpens> srhb: Yes... Adding print $ worked. Thanks a lot.
03:49:56 <PMG_> I still not quite understand the concept
03:50:36 <PMG_> Whe did kind k come from? What does a kind k mean?
03:50:51 <srhb> PMG_: Just like type variables are universally quantified, so are kind variables
03:50:57 <srhb> PMG_: So it's forall k. k -> *
03:51:02 <ski> `k' is a kind variable, standing for any possible kind
03:51:29 <ski> just like `a' in `length :: [a] -> Int' is a type variable that can stand for any possibly type (having kind `*')
03:51:40 <PMG_> Ah I see a kind variable
03:52:08 <PMG_> So besides k and * what other kinds are there?
03:52:13 <ski> no
03:52:22 <ski> `k' isn't a specific kind
03:52:29 <frerich> Maybe people should just write 'someType' or 'someKind' instead of 'a' and 'k'. Or would that bee too lame? :-)
03:52:35 <PMG_> k is a kind variable
03:52:36 <srhb> Besides k there are none, since k encompasses all kinds
03:52:41 <PMG_> but it seems like * is the only kind
03:52:46 <ski> `k' is a variable, that can possibly stand for the kind `*', and possibly for other kinds, like `* -> *'
03:52:47 <srhb> * is the only kind of types
03:52:56 <PMG_> oh
03:53:07 <PMG_> wait * is the only kind of types?
03:53:12 <srhb> Yes.
03:53:24 <ski> you can't have a value of type `Maybe'. however `Maybe Int' would work
03:53:51 <ski> we often say that types of kind `*' are *concrete* types
03:53:52 <PMG_> What does 'you cant have a type maybe' have to do with kinds?
03:54:05 <PMG_> I know Maybe has kind (*->*)
03:54:12 <magneticDuck> trying to use the json package to do some simple json parsing
03:54:14 <magneticDuck> I'm.. lost
03:54:15 <PMG_> So you cant have Maybe because its missing an argument?
03:54:17 <ski> `Maybe' is not a concrete type (it's a parameterized type, aka a type function. in other languages, one might say that it's a generic type)
03:54:25 <ski> PMG_ : yes
03:54:25 <magneticDuck> shouldn't I be able to get a [(String, JSValue)] out of a JSObject?
03:54:34 <magneticDuck> (JSObject JSValue) that is
03:54:35 <ski> PMG_ : it's incomplete
03:54:54 <srhb> This is perhaps overstating it a bit
03:55:12 <ski> PMG_ : remember how the type `[Int]' really means `[] Int'. you can't say `x :: []', that would be like saying "`x' is a list of" -- a list of *what* ?
03:55:26 <srhb> More concretely, types of kind * -> k cannot have values
03:56:33 <ski> PMG_ : anyway. `*' is a kind, and for any kinds `k0' and `k1', `k0 -> k1' is also a kind. from this you can generate kinds `* -> *',`(* -> *) -> *',`* -> (* -> *)',`(* -> *) -> (* -> *)',&c.
03:56:51 <ski> PMG_ : without extensions, this is all the kinds that you get. with extensions, there's some more ..
03:57:19 <merijn> srhb: To be strictly correct, * is not the only kind of types
03:57:23 <magneticDuck> anybody here have any experience with the json library?
03:57:28 <srhb> merijn: I corrected it :)
03:57:35 <merijn> ah, :)
03:57:38 <magneticDuck> I'm struggling to see why a JSObject is constructed with a (JSObject JSValue)
03:57:41 * ski would prefer to say "not the only kind of concrete types"
03:57:54 <merijn> ski: I would prefer to never ever use the term "concrete type"
03:57:59 <merijn> ski: It's an ill-defined term
03:58:05 <merijn> ski: Is "Maybe a" concrete?
03:58:31 <merijn> ski: Most people I see using it argue that it's not, because it's polymorphic, but others say it is, because it has kind *
03:58:31 <srhb> We should do a profile on all #haskell users on the wiki with avatars and pet peeves and all. :-)
03:58:38 <ski> merijn : yes (obviously assuming the presupposition `a :: *', which is required to make that well-kinded)
03:58:52 <ski> also, `Maybe a' is definitely not polymorphic
03:59:07 <ski> (even `forall a. Maybe a' is not polymorphic, though that's not the same thing)
03:59:16 <merijn> ski: I've seen conflicting use in #haskell and elswhere where it either means "type of kind *", "monomorphic" or both
03:59:29 <merijn> ski: Why is it not polymorphic? It's not monomorphic...
03:59:32 <PMG_> merijn you said before all types in type signatures must be of kind *?
03:59:38 <merijn> What other option would there be
03:59:58 <ski> merijn : would you agree with saying that `length' is a polymorphic function ?
04:00:06 <merijn> PMG_: No, all types that are used as arguments to a function (since functions take values and values always have a type of kind *)
04:00:10 <merijn> ski: Yes
04:00:39 <ski> merijn : the type of `length' is `forall a. [a] -> Int'. this type is not polymorphic (you could say it's a universal type, i suppose)
04:00:54 <merijn> ski: To me, in the context of haskell any type that is not monomorphic is polymorphic
04:01:03 <ski> merijn : a polymorphic type would be something like `NotMaybe' above, which had a *kind* `forall k. k -> *'
04:01:06 <srhb> I think that's basically the definition of polymorphism...
04:01:12 <merijn> ski: Can you give an example of a type that IS polymorphic according to you?
04:01:16 <PMG_> merijn: So if the kind of Maybe Int is (*->*), you cant take in Maybe Int as an argument?
04:01:23 <srhb> PMG_: It's not.
04:01:30 <merijn> :k Maybe Int
04:01:31 <srhb> Maybe Int :: *
04:01:32 <lambdabot> *
04:01:33 <PMG_> oh
04:01:34 <PMG_> right
04:01:39 <PMG_> Yeah rookie mistake
04:01:46 <ski> merijn : for completeness, it was defined by `data NotMaybe a = Just | Nothing'
04:02:00 <magneticDuck> does anybody here know how to use the json library?
04:02:13 <magneticDuck> struggling to get a [(String, JSValue)] from a JSObject
04:02:25 <magneticDuck> .. that should be possible right?
04:02:32 <merijn> ski: My definition of polymorphic, which seems to match most people I've talked to is that types are monomorphic or polymorphic, thus any type that's not monomorphic is polymorphic, i.e. "Maybe a"
04:02:37 <merijn> s/i.e./e.g.
04:02:52 <PMG_> To reword the question: So if the kind of Maybe x is (*->*), you cant take in Maybe x as an argument?
04:03:26 <srhb> PMG_: Sure.
04:03:30 <ski> merijn : i would only accept that if we'd stop using the word "polymorphic" to refer to values like `Nothing',`length',...
04:03:35 <srhb> PMG_: Maybe :: * -> *, Maybe x :: *
04:03:44 <srhb> PMG_: One is fully applied, the other is not.
04:03:50 <merijn> ski: Why? Why is Nothing not polymorphic?
04:03:55 <magneticDuck> lol never mind, brainfart
04:03:55 <maerwald> magneticDuck: fromJSObject JSObject?
04:04:07 <PMG_> :k Maybe
04:04:07 <maerwald> https://hackage.haskell.org/package/json-0.4.4/docs/Text-JSON-Types.html#v:fromJSObject
04:04:08 <lambdabot> * -> *
04:04:17 <PMG_> :k Maybe x
04:04:17 <lambdabot> Not in scope: type variable ‘x’
04:04:21 <srhb> :k Maybe Int
04:04:22 <lambdabot> *
04:04:35 <bergmark> magneticDuck: is there a reason you aren't using aeson?
04:04:43 <srhb> PMG_: The fact that x may be any type has no bearing on the kind of the application of Maybe to it
04:05:02 <ski> merijn : obviously i wouldn't argue for this. i'd prefer `Nothing' being said to be polymorphic (and its type, `forall a. Maybe a', being said to be monomorphic)
04:05:05 <PMG_> Is it possible to take in Maybe x as an argument where the type is unknown? Parameterized maybe as argument?
04:05:07 <srhb> PMG_: That is what :k Maybe tells you
04:05:15 <srhb> :t maybe
04:05:16 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:05:23 <merijn> ski: I don't understand your objection to my definition?
04:05:39 <srhb> PMG_: So yes, obviously, but this is basic type level stuff. :)
04:05:42 <ski> merijn : i don't think it helps the issue to confusingly use the term "polymorphic" for two completely different (but related) things
04:05:43 <merijn> ski: I've never encountered another one, tbh and I *still* don't understand yours
04:06:05 <ski> merijn : which is why i prefer calling `length' polymorphic, and `forall a. [a] -> Int' monomorphic
04:06:13 <magneticDuck> bergmark: not really, why should I be?
04:06:14 <srhb> PMG_: Again, Maybe a is a type of kind * for some (any) type a of kind *
04:06:17 <magneticDuck> doing something pretty simple
04:06:31 <merijn> ski: I don't understand what your definition is, nor how it's different from what I was saying
04:06:48 <maerwald> ski: are you trying to make a difference between a function being polymorphic and it's type being polymorphic?
04:07:24 <ski> maerwald : depends on what you mean by "it's type being polymorphic" :)
04:07:24 <PMG_> Right so: kind of Maybe is (*->*), kind of Maybe  a (*), kind of Maybe Int (*), You can use last two as arguments but clearly not just Maybe (incomplete)
04:07:34 <srhb> PMG_: That's right.
04:07:44 * hackagebot mandrill 0.2.2.1 - Library for interfacing with the Mandrill JSON API  http://hackage.haskell.org/package/mandrill-0.2.2.1 (AlfredoDiNapoli)
04:07:53 <srhb> PMG_: Fsvo "as arguments" whatever that means :-)
04:08:09 <srhb> PMG_: I assume you mean as arguments to (the type level) ->
04:08:18 <merijn> PMG_: More specifically, *values* can never have type Maybe, because Maybe does not have kind *
04:08:32 <bergmark> magneticDuck: most people use aeson nowadays, it's nicer to work with (i think) and more efficient. but json is fine to use
04:08:36 <merijn> PMG_: And to call function you need to pass them a value as argument :)
04:09:09 <ski> merijn : i think the shortest way to explain it is that i'd claim a value to be polymorphic iff its type is of the form `forall a. ..a..' (for some type variable `a', obviously not necessarily named exactly `a')
04:09:31 <ski> merijn : i think the shortest way to explain it is that i'd claim a *type* to be polymorphic iff its *kind* is of the form `forall k. ..k..' (for some *kind* variable `k', obviously not necessarily named exactly `k')
04:09:39 <merijn> ski: Right, so why would length and Nothing not be polymorphic?
04:09:47 <cita> merijn: So what? I lied... but the truth would have been suicide.
04:09:57 <PMG_> merijn: Right which means if I wanted to implement some function on types themselves (like Maybe) I could use type level functions instead? (where type families come into play)
04:10:11 <merijn> PMG_: Right
04:10:14 <ski> merijn : therefore, `length' and `Nothing' are polymorphic, but their respective types `forall a. [a] -> Int' and `forall a. Maybe a' are not polymorphic
04:10:50 <merijn> ski: Sure, I think the confusion comes from whether you parse "polymorphic type" as "type of a polymorphic value" or "type that is polymorphic"
04:11:01 <PMG_> Thank you @merijn, @srhb and @ski for your input, I really appreciate it!
04:11:14 <srhb> TL;DR: Polymorphism is very polymorphic.
04:11:23 <ski> merijn : in my mind, to stave off madness, should decide whether we want to call `length' and `Nothing' polymorphic, or call `forall a. [a] -> Int' and `forall a. Maybe a' polymorphic. to call all four polymorphic would result in exactly the confusion that i'm trying to avoid
04:11:33 <merijn> ski: I would usually mean the former and/or rely on context which is meant
04:11:51 <ski> merijn : .. and, i think it makes more sense to pick the former option. therefore `length' and `Nothing' are said to polymorphic
04:12:05 <merijn> ski: Right, but that's exactly what I was saying :)
04:12:08 <srhb> I don't understand the difference between length and forall a. [a] -> Int being polymorphic
04:12:22 <merijn> srhb: Is the *value* polymorphic, or the *type* polymorphic
04:12:40 <merijn> srhb: ski as arguing that polymorphism is a property of values, not types
04:12:41 <srhb> What value? The function?
04:12:47 <merijn> srhb: Yes
04:12:55 <srhb> Um, okay
04:12:55 <merijn> srhb: Function are values too
04:12:58 <srhb> I see it the other way around
04:13:00 <srhb> Yes :P
04:13:06 <ski> merijn : i simply prefer not leaving it to disambiguation what was meant. in my experience, many newbies in here have been confused because they haven't kept these distinct things apart in their minds
04:13:18 <maerwald> is the value polymorphic? -> look at the type
04:13:18 <maerwald> is the type polymorphic? -> look at the kind
04:13:28 <srhb> The type is polymorphic (forall a) but the function is always the same
04:13:33 <srhb> Polymorphic values require type classes
04:13:44 <merijn> srhb: No they don't
04:13:47 <srhb> Hmm.
04:13:52 <ski> merijn : and of course, when we do get *real* polymorphic types (like `NotMaybe' above, of kind `forall k. k -> *'), that would only make the confusion worse, if we didn't straighten it up first
04:13:54 <merijn> srhb: I can name you 3 counter examples
04:13:56 <merijn> :t Nothing
04:13:57 <lambdabot> Maybe a
04:14:00 <merijn> :t []
04:14:01 <lambdabot> [t]
04:14:04 <merijn> :t Left 'c'
04:14:05 <lambdabot> Either Char b
04:14:12 <merijn> 4, even ;)
04:14:15 <merijn> :t Right 'c'
04:14:16 <lambdabot> Either a Char
04:14:20 <srhb> merijn: Those types are polymorphic, but the functions are not
04:14:37 <merijn> srhb: The *values* are polymorphic
04:14:39 <srhb> I don't see how those are counter examples, it's exactly the same.
04:14:41 <merijn> There's no function anywhere
04:14:44 <srhb> OK, values.
04:14:46 <srhb> Whichever :)
04:15:39 <ski> srhb : "I don't understand the difference between length and forall a. [a] -> Int being polymorphic" is like saying "I don't understand the difference between `not' being a function and `Bool -> Bool' being a function"
04:15:57 <srhb> > (Right 'c' :: Either Int Char, Right 'c' :: Either Char Char)
04:15:58 <lambdabot>  (Right 'c',Right 'c')
04:16:14 <ski> (where `Bool -> Bool' is not a function, but a function type, aka the type of a function)
04:16:36 <srhb> ski: Yes, I agree with that now, and arrive at exactly the opposite conclusion of whether something is polymorphic or not :P
04:17:08 <merijn> The objection is that we have polymorphic *values* and polymorphic *types* and polymorphic values have polymorphic types
04:17:12 <ski> srhb : as long as you're internally consistent ;)
04:17:18 <srhb> :P
04:17:34 <merijn> And ski is worried about those jumbling together in the minds of beginners
04:17:42 <srhb> I think it makes more sense to just not speak of polymorphic values and let polymorphic types be exactly that, not polymorphy on kinds
04:17:55 <srhb> Which ugh is confusing.
04:18:10 <srhb> :set -XMonomorphismRestriction
04:18:12 <ski> then i think you'd need another term for the values here
04:18:12 <srhb> There!
04:18:18 <srhb> Hmm, would I?
04:18:39 <srhb> I've basically just pushed it up, making your value polymorphism the forall a. a -> ... type
04:18:50 <srhb> And calling it type polymorphism because, you know, types
04:18:50 <ski> well, you could just say "value of a polymorphic type", but that might get a bit clunky after a while
04:19:06 <srhb> And then kind polymorphism is forall k. k -> ... *
04:19:39 <srhb> Did I forget any sorts (ugh) of polymorphism there?
04:19:52 <ski> i don't think so
04:20:45 <ski> merijn : anyway, saying `Maybe a' (as opposed to `forall a. Maybe a') is polymorphic is also horrible ;)
04:21:17 <merijn> I leave out leftmost forall, if it's good enough for GHC, it's good enough for me
04:21:18 <ski> (its horribleness is comparable to saying that `x^2 + 1' is a function)
04:21:29 <maerwald> so, what was the example for type polymorphism now?
04:21:42 <merijn> maerwald: "forall a . [a] -> Int"
04:21:44 <srhb> maerwald: You need to ask a specific person :P
04:21:56 <maerwald> merijn: I thought that is not polymorphic in its type
04:21:57 <srhb> That's what I would say too, yes.
04:21:58 <merijn> maerwald: Which, in haskell, is equivalent too "[a] -> Int"
04:22:03 <ski> well. if `Maybe a' means `forall a. Maybe a', then surely `Maybe a -> Bool' means `(forall a. Maybe a) -> Bool' ?
04:22:14 <merijn> ski: Not in haskell
04:22:27 <srhb> ski: That would be higher rank type polymorphism
04:22:36 <ski> breaking compositionality is bad, imho
04:22:41 <srhb> Blame GHC. :-)
04:22:45 <merijn> ski: "Maybe a -> Bool" is "forall a . Maybe a -> Bool"
04:22:46 <srhb> Well, Haskell.
04:22:51 <merijn> ski: Blame the haskell report/committee
04:23:04 <ski> otoh, i have no problem with saying that `x :: Maybe a' (provided `a' is not already in scope) means `x :: forall a. Maybe a'
04:23:26 <ski> .. in this case, the `forall' is only inserted in the context of a type *signature*
04:23:34 <merijn> ski: The haskell logic is that any out of scope type variable is implicitly forall on the leftmost, outermost scope
04:24:08 <merijn> Which is sensible, since "Maybe a" without implicit 'forall' is meaningless in haskell too
04:24:11 <ski> merijn : yes, and that "leftmost, outermost scope" presupposes a type signature / typing that we're referring to (perhaps implicitly)
04:24:23 <maerwald> ski: so you explained what value polymorphism and type polymorphism is, then what is kind polymorphism?
04:24:25 <ski> merijn : that's false
04:24:45 <ski> merijn : `data MaybeMaybe a = MM (Maybe (Maybe a))' is valid
04:25:08 <ski> (or are you going to claim there's an implicit `forall a.' here ? where, in that case ?)
04:25:31 <merijn> ski: ok, s/without implicit 'forall'/without an 'a' in scope
04:25:48 <merijn> The left hand clearly introduces a scope for 'a'
04:26:33 <ski> maerwald : in my terminology, there's only be kind polymorphism if we had "types of kinds" (call it "sorts" for the sake of the argument), and then also only if there were sorts of the form `forall s. ..s..' (where `s' is a sort variable)
04:26:52 <ski> merijn : then i'm satisfied :)
04:26:57 <maerwald> ski: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/kind-polymorphism.html then what is that?
04:27:14 <maerwald> it looks to me like that is type polymorphism per your definition
04:27:36 <ski> maerwald : a misnomer, imho :)
04:27:53 <ski> (i've beaten this horse before, in here)
04:28:01 <maerwald> cool, so seems we have a lot of inconsistencies with polymorphism terminology
04:28:05 <ski> yes
04:28:21 <Clint> stbuehler: ok
04:28:47 <ski> i've argued for one way to resolve it. there can be alternative ways, like srhb's, possibly augmented with another term
04:29:07 <srhb> The problem I see with your way is that value polymorphism is not what type classes provide
04:29:08 <srhb> That makes me sad.
04:29:57 <ski> srhb : huh ? of course `show', of type `forall a. Show a => a -> Show', is also polymorphic
04:30:15 <maerwald> ski: we could say "type polymorphism refers to polymorphic values" and "kind polymorphism refers to polymorphic types" :P
04:30:16 <srhb> Yes but both in value level and type level.
04:30:20 <ski> (constrained polymorphic, if you want to be more specific)
04:30:22 <merijn> srhb: Typeclasses provide a constraint on polymorphism
04:30:24 <ski> srhb : no
04:30:41 <merijn> srhb: "forall a . Show a => a -> String" is still a polymorphic type
04:30:42 <ski> srhb : there's no type polymorphism (in my terminology) in there
04:30:43 <srhb> merijn: Yes, that can be true at the same time. :)
04:30:51 <srhb> I'm not arguing that it isn't!
04:31:40 <srhb> ski: No, I know. :-)
04:32:13 <ski> then i don't understand what you mean by "Yes but both in value level and type level."
04:32:27 <bergmark> anyone here running the latest GHC-7.10.2 rc?
04:32:44 * hackagebot ChasingBottoms 1.3.0.13 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.13 (NilsAndersDanielsson)
04:34:17 <srhb> ski: I don't feel too strongly about even having the term value polymorphism, but the way I would reason about it is that, say, length is polymorphic in its type (because of the implicit forall a) but not its value (because it's implementation is the same forall a) 
04:34:35 <srhb> So I guess you cannot have value polymorphism _without_ type polymorphism
04:35:07 <srhb> Or in other words, value polymorphism exists only for constrained type polymorphism
04:35:23 <ski> oh, so by "value polymorphism" i suppose you mean what's called in some of the original type class papers "ad-hoc polymorphism"
04:35:25 <magneticDuck> does putStrLn always print to stdout?
04:35:30 <magneticDuck> because I have this strange little problem
04:35:30 <srhb> ski: Yes exactly
04:35:32 <srhb> magneticDuck: Yes
04:35:39 <magneticDuck> when I open a handle, putStrLn stops working for some reason
04:35:40 <srhb> magneticDuck: it's hPutStrLn stdout
04:35:41 <dramforever> magneticDuck: I think so
04:35:41 <magneticDuck> really confusing
04:35:48 <magneticDuck> so weird...
04:35:56 <dramforever> yeah agree
04:35:56 <ski> @hoogle hPutStrLn
04:35:57 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
04:35:57 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
04:35:57 <lambdabot> Data.ByteString.Char8 hPutStrLn :: Handle -> ByteString -> IO ()
04:36:39 <ski> srhb : ok
04:36:57 <srhb> I like this, because to me it sensibly explains things like maxBound
04:37:13 <srhb> But again, I don't feel strongly that the term is even needed.
04:37:23 <srhb> When the type is different, it's obvious that the value is too.
04:37:27 <magneticDuck> https://github.com/MagneticDuck/altitude-mods/blob/master/flight-club/src/Main.hs#L10
04:37:46 <magneticDuck> oh huh, this is a bit strange
04:37:52 <magneticDuck> I think it has something to do with nohup
04:37:58 <magneticDuck> when I run the executable on its own, it generates stdout
04:38:27 <magneticDuck> but when I run it with nohup result/run &> log &
04:38:29 <magneticDuck> it doesn't work
04:38:33 <magneticDuck> doesn't generate output in log
04:38:51 <srhb> magneticDuck: Well, if you're using stdout for writing to your log something is bound to go wrong since stdout is redirected by nohup
04:39:02 <magneticDuck> but in the past it's worked fine
04:39:04 <srhb> magneticDuck: Why not use hPutStrLn and write to the handle of your log?
04:39:12 <srhb> Um... Okay. Maybe I don't understand handles then :-)
04:39:15 <magneticDuck> nohup treats "result/run &> log" as its own seperate process
04:39:31 <magneticDuck> I should do that, yes
04:39:35 <magneticDuck> I'll just do it like that
04:40:19 <magneticDuck> er, what's the simplest way to delete the first line of a file?
04:40:45 <magneticDuck> I mean, besides writeFile "out" . unlines . tail . lines . readFile "out"
04:40:49 <magneticDuck> it there something a bit.. faster?
04:40:53 <ski> srhb : well, we're often pointing out that stuff like `length' and `sort' can work on lists of any kinds of things (provided we have a total order in the latter case) .. and so at least i'd want a short term for that behavioural property of `length' and `sort' (not needing to mention types, since the same idea would apply in a dynamically typed language)
04:41:25 <srhb> I tend to say they are polymorphic over the type of elements
04:41:27 <srhb> But yeah...
04:41:54 <maerwald> ski: btw., how do you define "dynamically typed language"?
04:42:09 <srhb> Ugh... :-)
04:42:13 <maerwald> I've seen different definitions there too
04:42:22 <maerwald> because strictly speaking haskell also has dynamic types
04:42:23 <ski> maerwald : lacking a(n enforced) static type system :)
04:42:56 <maerwald> ski: so when I can opt-into dynamic types, it's still a static type system?
04:43:04 <Sindriava> Hi!
04:43:26 <maerwald> ski: some people say that a static type system is about "compile time verification", but uh
04:43:30 <maerwald> not sure I agree
04:43:31 <ski> maerwald : depends on what you mean by "opt-into"
04:43:58 <maerwald> ski: https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Dynamic.html
04:44:00 <Sindriava> I'm having some trouble with cabal on OS X, could anyone help?
04:44:07 <srhb> Sindriava: Pose your question. :)
04:44:29 <ski> maerwald : oh, i take "compile time verification" to be implicit in "static type system". otoh, it's possible for compile-time and run-time to be interleaved, complicating the picture ;)
04:44:38 <maerwald> ski: so we have dynamic types, but the language is statically typed... I don't like the terminology somehow
04:44:51 <ski> maerwald : well, `Dynamic' is a statis type
04:44:54 <Sindriava> srhb: I've tried to install Lens, but i couldn't import them into ghci. So I removed the .ghc and .cabal folders in my home to reset the state to default
04:45:00 <ski> s/statis/static/
04:45:08 <srhb> Sindriava: Yes?
04:45:10 <Sindriava> srhb: And now I can't even install lens and cabal-install doesn't work at all :(
04:45:17 <ion> “<maerwald> ski: btw., how do you define "dynamically typed language"?” It wasn't me whom you asked, but… a system where there is exactly one giant open sum type.
04:45:19 <srhb> Sindriava: lpaste.net your errors :)
04:45:26 <Sindriava> Ok, gimme a sec
04:45:58 <magneticDuck> hm, let's have a competition
04:45:59 <ski> maerwald : yes, i also agree with ion's version
04:46:03 <lamefun> Isn't polymorphism through records full of functions wasteful?
04:46:18 <srhb> lamefun: You mean the dictionary passing is costly?
04:46:18 <merijn> lamefun: In what way?
04:46:20 <maerwald> ski: but I can model a dynamic type system on top of a static type system... how do I call my type system now?
04:46:26 <ski> (perhaps i should have added "nontrivial" before "static type system" in my definition)
04:46:30 <magneticDuck> to see who can make buggy code with the highest ghc-reported error to string-difference to nearest compiling code ratio!
04:46:35 <magneticDuck> sounds like a great competition
04:46:40 <Sindriava> srhb: http://lpaste.net/135038
04:47:00 <srhb> lamefun: If so, yes.
04:47:37 <srhb> Sindriava: ... I think you might just want to wipe everything and start over with a new GHC and cabal-install
04:47:42 <srhb> Sindriava: That stuff looks nasty.
04:47:44 <ski> maerwald : .. anyway, if you had mentioned another sense of "opt-in", like lenient types, i'd had to be more ambiguous ;)
04:48:02 <Sindriava> srhb: FFS :D
04:48:04 <srhb> Sindriava: IT also looks like you either nuked the global cabal-install or didn't completely remove the local one.
04:48:04 <lamefun> merijn, I mean, in C++ an instance of class of virtual function is just its own data + function table pointer, and a function record is actual data + as many closures as there are functions or does GHC optimize it somehow?
04:48:09 <srhb> Sindriava: also you should use sandboxes, always.
04:48:27 <Sindriava> srhb: I see, I'll look into those :) Is there a tutorial on using them?
04:48:43 <merijn> lamefun: How is that different from a record containing functions?
04:48:53 <vlatkoB> Is there somewhere a list of differences between LTS versions?
04:48:53 <Sindriava> Also, why isn't there a more robust alternative to cabal? From what I gather package *management* is nonexistent for Haskell
04:48:57 <merijn> lamefun: Functions are effectively just "pointers" to the code corresponding to that function
04:49:02 <srhb> Sindriava: Sure, you might as well just google it though :) The basic is just making a directory and doing `cabal sandbox init` -- any cabal command from that directory will now only work with the sandbox. :)
04:49:14 <srhb> Sindriava: nix :)
04:49:40 <Sindriava> srhb: Well, that's a whole OS, isn't it?
04:49:45 <srhb> Sindriava: No, that's NixOS
04:49:52 <srhb> Sindriava: Which is based on the nix package manager.
04:49:55 <Sindriava> Ooooh
04:50:01 <solatis> nix (the package manager) can be installed on top of any distro
04:50:15 <srhb> I know nothing about Nix on OS X though
04:50:18 <srhb> But I assume it's a thing.
04:50:27 <Sindriava> I see! I'll look into that :) Thanks!
04:50:28 <maerwald> ski: I still don't see a sensible definition for "statically typed" that is not misleading
04:50:36 <srhb> Sindriava: Sure thing.
04:50:41 <lamefun> merijn, doesn't each function in the record contain its own pointer to the underlying data?
04:50:50 <merijn> lamefun: What underlying data?
04:50:52 <Cale> lamefun: This isn't about type classes explicitly, and it's somewhat out of date (GHC now does pointer tagging and some other tricks), but it's a good overview of how evaluation is implemented at a lower level regardless: http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
04:50:57 <Sindriava> A better package manager could be a good project for the summer :)
04:50:58 <solatis> Sindriava: be prepared for a learning curve (learning the nix syntax) with big payoff
04:51:12 <Sindriava> solatis: I'm using Vim, talk about learning curves with payoffs :D
04:51:24 <Sindriava> solatis: Nix uses a json-like syntax, right?
04:51:28 <srhb> Sindriava: Yeah, nix really does have a high learning curve, but not having to compile dependencies almost ever again is so awesome...
04:51:37 <solatis> Sindriava: we're all using haskell here, which is arguably the best example of big payoff
04:51:40 <lamefun> merijn, data of the concrete object?
04:51:44 <dramforever> Sindriava: hmm...wow I think I have a rather free summer
04:51:48 <merijn> lamefun: Which concrete object?
04:51:50 <Cale> Someone should do something like nix, but where the configuration language is just Haskell :P
04:51:52 <Sindriava> solatis: Touché
04:51:58 <merijn> lamefun: There is no objects?
04:52:05 <solatis> Sindriava: nah nix has its own weird language, nix expressions
04:52:08 <dramforever> Cale: can't agree more
04:52:12 <srhb> Cale: I suppose one could layer Haskell on top. That's what guix is doing with Scheme, isn't it?
04:52:27 <solatis> it looks a bit like Perl and Lisp had a baby and named it nixexpr
04:52:28 <tdammers_> hah, write a Haskell EDSL for nix
04:52:32 <srhb> No sense in rebuilding the whole thing from scratch, I think.
04:52:37 <srhb> Yeax exactly tdammers_ 
04:52:45 <tdammers_> should be trivial
04:52:45 * hackagebot pagerduty 0.0.3.2 - Client library for PagerDuty Integration and REST APIs.  http://hackage.haskell.org/package/pagerduty-0.0.3.2 (BrendanHay)
04:52:48 <tdammers_> (famous last words)
04:52:51 <srhb> :-)
04:52:53 <Sindriava> solatis: I'll look into it! Thanks ^^
04:53:01 <ski> maerwald : can you clarify on the "misleading" part ?
04:53:05 <maerwald> ski: if one says "statically typed" = "compile-time verification of types" then that's a silly definition, IMO... if one says "statically typed" = "you don't have dynamic types", then that is simply wrong, because we have them in haskell
04:53:26 <maerwald> I think the term is not very precise
04:53:41 <ski> maerwald : depends on what you mean by "dynamic types"
04:53:50 <solatis> Sindriava: if you have any questions I would suggest the nix irc channels, people actually helping out there and large overlap with Haskell community (thank you cabal!)
04:54:17 <tdammers_> "statically typed" == "types are resolved at compile time"
04:54:30 <lamefun> merijn, what do you mean by "there is no objects"?
04:54:32 <ski> maerwald : one could use "statically typed" as a superset of "dynamically typed" (via the trivial typing)
04:54:36 <tdammers_> or, if you prefer, "by default, types are at least partially resolved at compile time"
04:54:44 <tdammers_> or, if you prefer, "the language supports more than one type"
04:54:53 <maerwald> tdammers_: I don't think that definitions is helpful... you can just say "compile-time verification" without resorting to the "static" keyword
04:54:58 <merijn> lamefun: There's no objects in haskell, so what object would functions have references to?
04:55:25 <tdammers_> or, if you prefer, "type information is explicit in the semantics of the language"
04:55:32 <ion> Statically typed: the type of every value is known statically. That also applies to dynamically typed languages but is not very useful because they have exactly one type.
04:55:45 <ski> maerwald : there's other compile-time verification. e.g. scope verification. and mode and inst verification in a logic programming language
04:55:47 <merijn> s/dynamically typed/unit typed
04:55:48 <tdammers_> ion: hence my definition of "supports more than one type" :D
04:56:50 <lamefun> merijn, there can't be no objects, Haskell isn't an empty language...
04:57:14 <merijn> lamefun: objects is a technical term, haskell has values, but no objects
04:57:35 <solatis> yeah this is more of a discussion what 'object' means
04:57:45 <tdammers_> "objects" means two different things here
04:58:05 <solatis> i object!
04:58:17 <ion> lamefun: What's your definition of object? Haskell has no OOP objects. Haskell has category theoretical objects. Haskell has no physical objects.
04:58:25 <lamefun> merijn, I mean, there is an eg. File { fRead, fWrite, fClose } structure, and there's OSFile { osFID }, does every member functions of File contain a separate pointer to OSFile or can GHC optimize it?
04:58:27 <tdammers_> in OOP, it means "subprogram" or "bundle of state and behavior" or "bag of properties" or something like that, but outside that realm, it just means "a thing that we can do stuff to"
04:58:31 <magneticDuck> don't objectify objects! they're values too, just like you and I!
04:58:45 <solatis> lamefun: you're thinking too low level
04:58:48 <maerwald> ski: Data.Dynamic describes it this way "Operations for injecting values of arbitrary type into a dynamically typed value"
04:59:05 <merijn> lamefun: "does every member function of File" <- there are no member functions
04:59:11 * ski . o O ( "ob·ject  2" )
04:59:16 <ski> :  to feel distaste for something 
04:59:29 <merijn> lamefun: I mean, you can put functions in a record the same way you can put an Int in a record, but it doesn't magically get access to the record or anything
04:59:30 <ion> Objection oriented programming
04:59:39 <merijn> lamefun: functions are functions, they take arguments and that's it
04:59:59 <magneticDuck> lamefun objects!
05:00:06 <tdammers_> ion: how does that work? the interpreter performs random operations until you tell it that that's not OK?
05:00:21 <maerwald> tdammers_: I like the "explicit" approach to talk about the type system, but does it really help us to use the static vs dynamic approach?
05:01:20 <tdammers_> maerwald: well, IMO there is no completely statically typed language anyway, they all allow the programmer to create "islands" of runtime dispatch
05:01:33 <ski> maerwald : i think it helps to think of the word "typing" in "static typing" and "dynamic typing" as meaning two different things
05:01:52 <tdammers_> maerwald: Haskell minus typeclasses might qualify, but even then you can use records and first-class functions to build dynamically-typed DSLs
05:01:53 <solatis> tdammers_: please elaborate on these islands of runtime dispatch -- do you mean like C casting to void ?
05:02:15 <ski> maerwald : btw, what about that `Data.Dynamic' description ?
05:02:21 <tdammers_> solatis: I mean stuff like Data.Dynamic, or various other patterns to build dynamic types on top of Haskell's type system
05:02:29 <maerwald> ski: you asked what I mean with "dynamically typed"
05:02:35 <solatis> ah right
05:02:43 <solatis> but that should be possible in any language, right ?
05:02:53 <tdammers_> yes
05:02:56 <ski> maerwald : ok. so not something like Scheme then, i suppose
05:03:10 <solatis> assuming we're talking about turing-complete languages
05:03:20 <jesyspa> tdammers_: Hm, doesn't that just amount to "you can roll the type information that a dynamically typed language stores for you by hand"?
05:03:39 <tdammers_> and the reverse is also true - you can build a type checker on top of a completely dynamic language, and rig things up such that within your "island", everything is forced to be well-typed
05:03:57 <solatis> *cough* python *cough* 
05:04:00 <tdammers_> jesyspa: isn't that pretty much exactly what a dynamic language does anyway?
05:04:21 <solatis> i believe they're going to add run-time type checks to python
05:04:21 <tdammers_> jesyspa: I like to view it from a different angle anywya
05:04:31 <lamefun> merijn, I mean something like, "mkOSFile path = File { fRead = OS.read priv .., fWrite = OS.write priv .., fClose = OS.close priv .. } where priv = OS.open path", where priv is the underlying OS file.
05:04:31 <PMG_> Hey, how would I go about deriving Show for the BoolProp GADT here: http://lpaste.net/135039
05:04:39 <ski> maerwald : btw, i'm losing track of what we're arging at the moment (are we arguing anything at the moment ?) ..
05:04:48 <tdammers_> a dynamically typed language (or better, "unityped"), supports only one type, and it is inhabited by all the values that the language can represent
05:05:01 <solatis> lamefun: the compiler would optimize that away
05:05:12 <Axman6> PMG_: does "deriving Show" not work?
05:05:30 <PMG_> Like adding on deriving Show to the end? No
05:05:31 <tdammers_> and you can design a Haskell type that models such a unitype
05:06:08 <tdammers_> it'll still be embedded in the multi-typed host universe, but inside a DSL that restricts itself to using only this unitype, the semantics are those of a "dynamically typed" language
05:06:09 <Axman6> try 'deriving instance (Show a) => Show (BoolPop a)" at the top level
05:06:32 <Axman6> can't remember which extension you need for that
05:06:36 <PMG_> Where would I put that?
05:06:48 <ski> Axman6 : hm, i don't think `Show False' and `Show True' will work here ..
05:07:00 <tdammers_> using closures and records, you can even make a unitype that can interface with host types to allow you to hook up more types with your dynamically-typed system at runtime
05:07:07 <maerwald> ski: I think the word "static" doesn't really describe anything useful in the context of "statically typed" and is misleading, that was my point. And I haven't seen a concise definition of it yet.
05:07:22 <Axman6> at the top level, usually after the definition of the data type
05:07:22 <PMG_> @ski Is there a easy way to make it Show everything?
05:07:22 <lambdabot> Maybe you meant: wiki src ask
05:07:43 <maerwald> we can talk about how when the compiler verifies types, how it verifies them, how it does type inference and so on
05:07:46 * hackagebot socket-sctp 0.1.0.0 - STCP socket extensions library.  http://hackage.haskell.org/package/socket-sctp-0.1.0.0 (LarsPetersen)
05:07:48 * hackagebot hakyll 4.7.1.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.7.1.0 (JasperVanDerJeugt)
05:08:00 <maerwald> but that cannot really be sumed up with "static" or "dynamic"
05:08:21 <ion> PMG: Btw, it might be nicer to make those type families closed.
05:08:35 <ski> PMG_ : you may want to avoid placing `@' before someone's nickname to alert them. it's not IRC custom, and several IRC clients will only alert a user if their nickname is mentioned initially (with no `@' before) in a message
05:08:49 <tdammers_> maerwald: I think the term "static" is supposed to mean "once compiled, the types of things cannot change anymore, they are 'static'"
05:09:03 <PMG_> ski: Thanks for the heads up
05:09:15 <maerwald> tdammers_: and that only applies to a certain abstraction level
05:09:33 <maerwald> as you outlined yourself
05:09:41 <PMG_> Axman6: got an error: The first argument of 'BoolProp' shoudl have kind 'Bool', but 'a' has kind '*'
05:09:48 <tdammers_> maerwald: yes
05:10:05 <PMG_> make (a::Bool)?
05:10:25 <tdammers_> maerwald: but just because the line is somewhat blurry doesn't mean it makes no sense to talk about the concepts at all
05:12:21 <ski> PMG_ : anyway, `deriving instance Show (BoolProp a)' (with the extension `StandaloneDeriving') works for me ..
05:12:40 <maerwald> tdammers_: well, I think we need consensus on the definition, same goes for "pure"... there are several papers about what a "pure" language has to have
05:13:26 <PMG_> ski : Yeah that worked for me too
05:13:45 <PMG_> Is that how you derive instances for GADTs?
05:13:53 <PMG_> As opposed to standard data types
05:14:26 <ski> PMG_ : yes. Axman6's suggestion would probably have worked in case you had `BoolProp :: * -> *'
05:15:07 <ski> PMG_ : i forget if you can sometimes use the ordinary `deriving' on GADTs (like when you're not really using any of the extra powers that GADTs give you, maybe)
05:15:13 <PMG_> ski : Can you derive Eq, Ord this way?
05:15:40 <ski> PMG_ : should be possible, still under the same restrictions as usual
05:16:12 <ski> PMG_ : may or may not work for your particular case, depending on whether it can type the generated code or not
05:16:25 <ski> (but if the code passes the type-checker, then it should work)
05:16:48 <PMG_> I don't think it worked haha
05:17:33 <tdammers_> maerwald: there is no consensus on what constitutes a table either
05:17:47 <tdammers_> maerwald: yet mankind has been using them for thousands of years without issues
05:17:54 <tdammers_> (the occasional flipping notwithstanding)
05:18:24 <maerwald> tdammers_: because table is a dynamic type :P
05:19:04 <luite__> yay, working GHCJSi: http://lpaste.net/135040
05:19:08 <tdammers_> my point is, lacking a formal definition, we can still reach a point where we can agree on 98% of the cases in our definition, and hand-waive the rest as academic examples
05:19:39 <srhb> luite__: :O
05:19:44 <alpounet> luite__: amazing!
05:19:51 <PMG_> ski : So is there a way to get Eq working so I can basic comparison functionality: PTrue == PTrue returns True?
05:20:27 <kuribas> Why isn't list fusion used by ghc?
05:20:38 <merijn> kuribas: It is
05:20:48 <luite__> alpounet: code is really rough, more proof of concept than anything production ready, aborting computations doesn't work yet (not too hard to implement)
05:21:44 <alpounet> luite__: i'm sure it'll get all polished and shinier over time. you're not really the type of person that gives up =)
05:22:17 <srhb> luite__: Still, very exciting! :)
05:22:22 <luite__> alpounet: it starts a background node.js process to run the JS code, but it could easily do the same with a browser, so your GHCJSi session would have DOM access
05:24:08 <ski> PMG_ : how should `PAnd a b == PAnd c d', with both comparands of type `BoolProp False', work ?
05:24:20 <kuribas> merijn: but not stream fusion?
05:25:33 <ski> PMG_ : the problem is that we don't know if `a' is of type `BoolProp False' or `BoolProp True' here, and similarly for `c', and therefore we don't know that `a == c' is well-typed
05:25:45 <merijn> kuribas: There's a whole bunch of fusion and/or rules to do that, but whether they trigger is very dependent on inlining, etc.
05:26:01 <merijn> kuribas: I think stream fusion is there but rather experimental/brittle?
05:26:19 <kuribas> I see...
05:27:47 <PMG_> ski: ah I see, so it makes more sense to use the code at the bottom which evaluates the result to a Bool and use that to compare the BoolProp
05:27:50 <PMG_> Thanks!
05:33:41 <ski> PMG_ : you can define a function `boolPropEq :: BoolProp a -> BoolProp b -> Bool' (or make an instance of <http://hackage.haskell.org/package/abt-0.1.1.0/docs/Abt-Class-HEq1.html>), and then make an `instance Eq (BoolProp a)' using that, i think
05:33:44 <merijn> Does anyone have a mnemonic for remembering whether [x → y]t substitutes 'x' with 'y' or 'y' with 'x'?
05:34:09 <Fuuzetsu> x becomes y
05:34:20 <Fuuzetsu> (I hope that's the right way ;) )
05:34:40 <ski> PMG_ : "it makes more sense to use the code at the bottom which evaluates the result to a Bool and use that to compare the BoolProp" -- only if that's what you want. if you want to compare expressions, then `PNot PTrue == PFalse' should be `False', not `True', despite them evaluating to the same thing
05:35:03 <ski> Fuuzetsu is correct
05:35:19 <Fuuzetsu> how unusual
05:35:48 <merijn> Fuuzetsu: That's not a very good mnemonic, though, because that's one of the two alternatives :p
05:35:58 <ski> (however, i'd use `↦' (or `≔' or `\'), not `→')
05:36:21 <srhb> So... Tiny...
05:36:38 <srhb> I need a better font for displaying all these symbols. Any suggestions?
05:37:02 <merijn> ski: What's the LaTeX for that first arrow?
05:37:43 <Denommus> does anyone know where I can find the SML grammar in BNF or EBNF?
05:37:59 <maerwald> merijn: \mapsto?
05:38:01 <Denommus> I was trying to follow this, but it is full of conflicts: https://www.mpi-sws.org/~rossberg/sml.html
05:38:22 <merijn> [x ↦ y]t, there we go
05:38:57 <srenatus> Hi there. Is there some example code or blogpost describing the combined usage of criterion and quickcheck's arbitrary?
05:39:00 <ski> merijn : hm, might be .. what maerwald said
05:39:15 <merijn> It is, that's how I typed it :p
05:39:50 <Fuuzetsu> srenatus: what's the point of benchmarking against varying inputs?
05:40:04 * ski thinks unicode syntax for lambda expressions ought to use (or at least allow) `↦'
05:40:47 <srenatus> Fuuzetsu: isn't there? I could swear I saw something related to that, ah, maybe on planet haskell.  the idea would be to use varying inputs of varying lengths... I.e., is the runtime exponential in input length?
05:40:55 <ski> merijn : .. the idea with `[x \ y]t', or equivalently `[y / x]t', is that you "divide away" the variable `x', and "multiply in" `y' in its place
05:41:40 <merijn> TaPL uses the arrow, but on an e reader it's annoying to skip to the syntax section to refresh my mind :\
05:42:47 * hackagebot glue 0.1.0.0 - Make better services.  http://hackage.haskell.org/package/glue-0.1.0.0 (seanparsons)
05:43:20 <ski> (and of course sometimes people put the bracketed part after the term to be substituted in .. and there's also a notation with the variable-to-be-substituted-for and the term-to-be-substituted-in as sub- and super- (i forget which is which) scripts on the main term)
05:57:44 <luite__> alpounet: code for GHCJSi is up: https://github.com/ghcjs/ghcjs/tree/ghcjsi
06:05:55 <YellowOnion> Could someone help me with making a data type, I can't for the life of me figure out how to make a simple named tree structure without getting errors.
06:06:35 <c_wraith> The simplest (possibly too simple to be useful) looks like  data Tree = Leaf | Node Tree Tree
06:07:01 <tdammers_> "possibly" :D
06:07:10 <c_wraith> It's useful if you only care about shape!
06:07:21 <tdammers_> pfff, that's so shallow
06:07:25 <tdammers_> :x
06:07:41 <maerwald> data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
06:07:54 <YellowOnion> c_wraith, Yeah  I get that part, but once I try added a name to the node and left it says I can't delare "Name" twice
06:08:12 <maerwald> there's also the RoseTree which is pretty cool
06:08:33 <tdammers_> YellowOnion: code?
06:08:35 <maerwald> data RoseTree a = RoseTree a [RoseTree a]
06:08:35 <ski> relevant questions are : what kind of tree nodes are allowed ? how many children does each of them have ? which additional data is attached to them ? would you like the type of trees to be parametric in some type(s), like leaf value type or internal node value type or something like that ?
06:09:26 <tdammers_> data Cons a b = Cons a b -- :x
06:09:27 <YellowOnion> tdammers_, data VObj = VName VVal | VName [VObj]
06:09:43 <tdammers_> YellowOnion: that doesn't work because both your constructors have the same name
06:10:08 <maerwald> the channel goes wild of you ask about Trees, but don't ask about doubly linked lists or queues... because those are awkward in haskell :P
06:10:47 * ski asks about doubly linked trees
06:11:01 <maerwald> ski: sheesh
06:11:06 <YellowOnion> tdammers_, I know, just that I can't figure out what the syntax would be to have it without double defining.
06:11:46 <tdammers_> maerwald: data List i v = List { listItems :: HashMap i (i, i, v); listHead :: i }
06:11:50 * tdammers_ ducks
06:12:03 <tdammers_> YellowOnion: constructor names aren't required to match the type name
06:12:08 <maerwald> ski: I find double linked lists in haskell VERY awkward, because you "abuse" laziness in a non-trivial way, so you get "implicit pointers"
06:12:19 <tdammers_> YellowOnion: for types that have only one constructor, they usually do, but that's merely a convention
06:12:26 <tdammers_> :info Maybe
06:12:29 <maerwald> and if you want to make the same for some non-trivial graph structure, it gets even more awkward
06:12:31 <ski> maerwald : you know you want to traverse a whole binary tree iteratively by manicelly changing the direction of the pointers
06:12:47 <maerwald> ski: no, I am talking about the "tying the knots" method
06:12:51 <ski> maerwald : why not just use `IORef' ?
06:12:53 <ski> oh
06:13:17 <ski> maerwald : how do you `fmap' on that ?
06:13:31 <PMG_> ski: Can you please have a little look at this: http://lpaste.net/135043
06:13:44 <PMG_> ski : Goal was to implement a printf function similar to that of C
06:14:28 <ski> PMG_ : you can do `printf', but it's a bit awkward ..
06:14:37 <ski> (better with dependent types)
06:14:55 <YellowOnion> tdammers_, as I said, I get that there's an error, but I'm not how how to correct represent my data structure.
06:14:55 <PMG_> Can you explain some segments of the code to me?
06:15:05 <PMG_> Like I have no clue what ::: means
06:15:08 <maerwald> ski: not sure, it's basically an infinite list, but depending on the implementation it does not recompute already known values. so you can easily make a regular singly-linked list out of it and fmap on that
06:15:17 <sm> YellowOnion: why not take a look at the Data.Tree source
06:15:47 * ski looks at the code
06:15:57 <tdammers_> YellowOnion: give your constructors different names
06:16:09 <tdammers_> data Foo = Foo bar | Foo baz -- is invalid
06:16:16 <ski> PMG_ : `:::' is just an (infix) data constructor
06:16:18 <tdammers_> data Foo = Foo bar | Baz quux -- is valid
06:16:38 <PMG_> ski : What does that mean?
06:17:11 <YellowOnion> tdammers_, but so I have to have a ObjName and a ValName?
06:17:26 <tdammers_> YellowOnion: yes, you could do that
06:17:39 <tdammers_> or you could call them just Obj and Val
06:17:40 <tdammers_> also valid
06:17:51 <tdammers_> for example, Maybe is defined like so:
06:18:01 <tdammers_> data Maybe a = Nothing | Just a
06:18:19 <tdammers_> note how neither of the constructors (Just / Nothing) matches the type name
06:18:28 <YellowOnion> tdammers_, I mean these are named like json objects, they have a 'tag' you access them via, and the inner data.
06:18:57 <ski> PMG_ : if we replaced `data List a = Nil | a ::: List a' by `data List a = Nil | Cons a (List a)', then instead of writing e.g `S :: Format fmt -> Format (String ::: fmt)', we'd write `S :: Format fmt -> Format (Cons String fmt)'
06:19:04 <tdammers_> ?
06:19:50 <ski> maerwald : the problem is that if you change (replace) one node in the infinite (cyclic) structure, that change won't be reflected through all the other ways in which you can reach the "same" node
06:20:28 <ski> maerwald : which shows you that it really is infinite (which is represented cyclically as an optimization), as opposed to *behaving* as a cyclic data structure
06:20:31 <YellowOnion> tdammers_, I'm not sure how else to explain it.
06:20:31 <tdammers_> YellowOnion: oh, you mean each entry in your thing has a name and a value
06:20:38 <YellowOnion> yes
06:21:04 <tdammers_> then you want something like
06:21:18 <YellowOnion> the Value can be either a list of objects or an actual value.
06:21:31 <tdammers_> yeah
06:21:38 <tdammers_> I'd model that as:
06:21:53 <tdammers_> data Value a = Scalar a | Object a
06:22:06 <tdammers_> data Object a = Object (HashMap Text a)
06:22:15 <tdammers_> or rather
06:22:20 <tdammers_> data Object a = Object (HashMap Text (Value a))
06:22:25 <PMG_> ski : I am still a little lost
06:22:37 <tdammers_> (using HashMap from Data.HashMap.Strict, probably, and Text from Data.Text)
06:22:59 <tdammers_> but if you don't feel like learning about those right now, you could also make do with [(String, Value a)]
06:23:20 <YellowOnion> tdammers_, I think I get ya, I don't think I need an actual Map, but I'm trying to parse a file so I need some form of data structure for it.
06:23:32 <tdammers_> are you parsing actual JSON?
06:23:49 <YellowOnion> no, its VDF, some what similar in structure though.
06:24:03 <tdammers_> ah
06:24:28 <YellowOnion> tdammers_, https://wiki.teamfortress.com/wiki/WebAPI/VDF
06:24:43 <tdammers_> also, if you know in advance what kinds of values you can get, it's probably better to make that data structure not parametric
06:24:53 <tdammers_> and encode all the options into the Value type
06:25:15 <ski> PMG_ : this is using a kind `List k' (assuming `k' is a kind. in the use case in the paste, `k' is `*'). the values of that kind are `Nil' and `t ::: ts' (with my renaming, `Cons t ts', where `t' has kind `k', and `ts' has kind `List k'
06:25:30 <ski> PMG_ : so, `List' is used to describe lists of *types*
06:25:58 <tdammers_> in fact, it looks like the only scalar value type is string, so this should be enough:
06:26:24 <tdammers_> data Value = String String | Object; data Object = [(String, Value)]
06:26:26 <ski> PMG_ : `Format' is parameterized on a list of types. `FormatArgsThen' is a type function (a function on the type level), that takes a list of (concrete) types, and a (concrete) type, and returns a (concrete) type
06:26:36 <tdammers_> sorry
06:26:40 <tdammers_> data Value = String String | Object; data Object = Object [(String, Value)]
06:26:48 <tdammers_> sorry again
06:26:59 <tdammers_> no, nm, that last one is about right
06:27:01 <YellowOnion> tdammers_, haha thanks!
06:27:07 <tdammers_> yw
06:28:12 <ski> PMG_ : `printf' is polymorphic, will work for any possible list of types `fmt' in its type `Format fmt -> FormatArgsThen fmt String'. if `fmt' is of the shape `t0 ::: t1 ::: ... ::: t{n-1} ::: Nil', then `printf' will have the type `Format (t0 ::: t1 ::: ... ::: t{n-1} ::: Nil) -> t0 -> t1 -> ... -> t{n-1} -> String'
06:28:39 <PMG_> so similarly to how :: is used to denote type variable type (a::Bool), ::: is used to denote type constructor kind (a::: List a)?
06:29:19 <ski> PMG_ : building up a value of type `Format fmt' will built up a list of types in `fmt' that describes the format "arguments" that are missing (required later)
06:29:50 <YellowOnion> tdammers_, So I have to ask, why can I put String in there (which is already declared?)
06:29:53 <ski> PMG_ : no. the analogy here is : as there's `x : xs' for non-empty value lists, here we have `t ::: ts' for non-empty type lists
06:30:15 <ski> PMG_ : `:::' is just a name. they could have written `Cons t ts' instead
06:31:18 <osa1> is there a way to not export instances defined in a module?
06:31:55 <PMG_> That notation makes more sense to me
06:32:02 <tdammers_> YellowOnion: ah, because type and value namespaces are separate
06:32:10 <tdammers_> data Foo = Bar Baz
06:32:24 <tdammers_> in the above, "Foo" and "Baz" live in the type namespace, while "Bar" lives in the value namespace
06:32:36 <geekosaur> osa1, no
06:32:45 <geekosaur> instances must be globally visible
06:32:48 <PMG_> Wouldn't you have to specify ts was of type List a in `Cons t ts`
06:33:26 <PMG_> Ah right you said: Cons a (List a)
06:33:51 <osa1> geekosaur: I can see the point but I'm defining orphan instances for debugging purposes and I wish we had a way to safely to that
06:35:51 <YellowOnion> tdammers_, But you have String in both positions?
06:36:52 <tdammers_> yes, in this case I do
06:37:10 <tdammers_> the first one is in the value namespace, defining a constructor for the data type
06:37:24 <tdammers_> the second one is in the type namespace, referring to the String type from Prelude
06:38:12 <tdammers_> data Type:Something = Value:String Type:String -- in a hypothetical language where these namespaces are explicit
06:44:49 <YellowOnion> tdammers_, I got this which seems to compile: data VObj = VList String [VObj] | VVal String String
06:45:21 <tdammers_> VVal has two String fields now
06:45:46 <tdammers_> and VList has just one key and many values
06:45:59 <tdammers_> oh wait, you're baking the key into the value
06:46:09 <YellowOnion> Yeah
06:46:17 <tdammers_> is there any particular reason for that?
06:46:53 <tdammers_> I'd go with data VObj = VDict [(String, VObj)] | VVal String
06:47:21 <tdammers_> IMO the key belongs to the list, not to the values in it
06:48:04 <YellowOnion> tdammers_, VVals have keys as well
06:50:51 <YellowOnion> tdammers_, oh wait yours actaully does that too.
06:51:36 <tdammers_> yes
06:51:45 <tdammers_> it just keeps the keys in the list, not in the values
06:53:50 * hackagebot hakyll 4.7.1.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.7.1.0 (JasperVanDerJeugt)
06:53:50 * hackagebot glue 0.1.0.0 - Make better services.  http://hackage.haskell.org/package/glue-0.1.0.0 (seanparsons)
06:55:03 <YellowOnion> tdammers_, I'm not exactly sure what structure is best suited for Parsec
06:56:05 <hectortrope> Any haskeller know abourt any sap product?
06:56:37 <hectortrope> Hello Guys
06:56:42 <hectortrope> ^^^
06:57:41 <tdammers_> YellowOnion: Parsec doesn't care. But I'd go with keys as part of the list, because that's more common in general
06:58:07 <tdammers_> and also because you may need values outside of an object, but never an object that has no keys
06:59:59 <YellowOnion> tdammers_, thanks, I'll have a think about it.
07:08:44 <tejon> Anyone care to take a shot at diagnosing my Pango problem? :P
07:09:40 <tejon> GraphicsRenderingPangoStructs.hsc:(several): Not in scope: type constructor or class "Wordzu" (also "Intzu")
07:10:34 <srhb> tejon: Is that from cabal install pango or what?
07:10:42 <tejon> Yeah.
07:10:43 <srhb> tejon: Better paste your commands and the errors on lpaste.net :)
07:11:09 <tejon> Well that's all of it. :)
07:11:33 <tejon> cabal install pango -> mangled type identifiers
07:13:22 <tejon> It's on Windows, but as controlled as it can possibly be -- after getting this with the MSYS2 packages, I constrained my path to nothing but GHC's and Cabal's bin directories, plus the one from the official GTK+ bundle (for pkg-config) and got exactly the same result.
07:13:38 <lamefun> Is String a teaching-only structure, should I ignore it and use Text from the start?
07:14:13 <merijn> lamefun: "It Depends™"
07:14:16 <srhb> lamefun: Your call.
07:14:31 <merijn> lamefun: String takes considerably more memory and is slower, but easier to pattern match on
07:14:44 <flux> lamefun, no, it's useful also for advocating how lists and strings are the same in Haskell ;-)
07:15:06 <geekosaur> if you're working with mostly shortish strings, String can be faster than Text
07:15:17 <geekosaur> whole files and Text will be better
07:16:49 <tejon> Agree with merijn re: pattern matching, I've explicitly converted from Text to String for that reason.
07:17:12 <srhb> tejon: Needs more view patterns. :P
07:17:48 <tejon> Granted I only had one pattern to match.
07:18:21 <Big_G> Is it possible to have several layers within a monad transformer? 
07:18:29 <srhb> Big_G: Yup.
07:18:49 <delrik> hi, how would I write the following point free?
07:18:50 <delrik> append' :: [a] -> a -> [a
07:19:03 <delrik> append’ as a = as ++ [a]
07:19:11 <Big_G> srhb, What is the easiest way to manage that? I'm imagining a 20 layer monad which would get nasty
07:19:11 <srhb> @pl \as a -> as ++ [a]
07:19:11 <lambdabot> (. return) . (++)
07:19:15 <merijn> delrik: Why do you want to?
07:19:28 <srhb> Big_G: 20?!
07:19:28 <ski> delrik : i'd call that `snoc'
07:19:42 <delrik> ski: good call
07:19:51 <Big_G> srhb, It wouldn't be hard to see in an enterprise application
07:19:55 <srhb> Big_G: and no, it's generally not nasty at all with type synonyms, though if it's that specific people will usually just make a monad of it.
07:19:57 <mniip> Big_G, do you want anything RWST doesn't cover?
07:20:02 <srhb> Big_G: Yeah it would be fairly hard.
07:20:09 <delrik> merjin: I know its possible, I’d like to see how I’d compose 2 params in PF style.
07:20:17 * ski imagines a finite map, that maps monad transformer identifiers to monad transformers
07:20:24 <srhb> ski: :P
07:20:27 <Big_G> mniip, What is RWST?
07:20:33 <srhb> Reader Writer State Transformer
07:20:33 <mniip> reader-writer-state transformer
07:20:44 <ski> @unmtl RWST r w s m a
07:20:44 <lambdabot> r -> s -> m (a, s, w)
07:21:03 <mniip> delrik, do you need something pointfreed?
07:21:15 <Big_G> mniip, I'm still trying to think of the use cases but I can imagine at least a few layers relating to network calls as well as database calls
07:21:24 <mniip> ah
07:21:28 <mniip> that sort of transformer
07:21:38 <delrik> mniip: Not necessarilly,  and I think ((. return) . (++)) handles it well.
07:21:39 * ski . o O ( s/pointfreed/pointleast/ )
07:21:52 <delrik> s/east/ess
07:21:55 <srhb> ski: pointlessed?
07:21:56 <delrik> =)
07:21:57 <srhb> Yeah
07:22:04 <mniip> Big_G, well yeah, as long as respective mtl instances are in place
07:22:10 <mniip> you can do it with just type synonyms
07:22:14 <srhb> Perhaps it's sufficient to pointfewer it.
07:22:21 <mniip> depoint
07:22:24 <Big_G> What is an mtl?
07:22:24 <srhb> :-)
07:22:26 <delrik> is there anyway to do it without invoking the monadic properties of the array?
07:22:37 <srhb> delrik: Huuh?
07:22:39 <mniip> Big_G, a package, monad transformer library
07:22:40 <delrik> as in could I replace the return above with a cons slice?
07:22:44 <mniip> delrik, yes
07:22:49 <mniip> replace return with (:[])
07:22:52 <delrik> ah, ok.  
07:23:05 <srhb> How does lambdabot show src of instances again?
07:23:11 <srhb> @src return []
07:23:11 <lambdabot> Source not found. You speak an infinite deal of nothing.
07:23:11 <delrik> thx guys!
07:23:13 <Big_G> mniip, Thanks. Is this going to get really complicated?
07:23:15 <srhb> Not like that, clearly.
07:23:34 <srhb> @src [] return
07:23:34 <lambdabot> return x = [x]
07:23:36 <srhb> Aha
07:24:06 <mniip> Big_G, it's the package providing MonadState, MonadReader, MonadIO typeclasses
07:24:11 <mniip> (and others)
07:24:25 <mniip> as long as your custom transformers are instances of those things, you're good
07:24:35 <ski> srhb : perhaps :)
07:25:09 <ski> srhb : there's a fixed database for `src'
07:25:15 <srhb> Yes, I know.
07:25:23 <srhb> Still preferable to typing it out :-)
07:25:24 <ski> oh. i misparsed the question
07:25:39 <srhb> I might have abbreviated the question a bit much :P
07:25:55 <Big_G> mniip, would those types be something like dbWriteHTTPcallLogFileWrite Int?
07:26:09 <mniip> ಠ_ಠ
07:26:32 <obfuscatr> bit of a newb, still learning syntax, if I have g <- newStdGen, how do I ask for a single random number of type Int? 
07:27:10 <mniip> (number, g') <- random g
07:27:14 <mniip> er
07:27:26 <mniip> let (number, g') = random g
07:27:28 <mniip> it's pure
07:27:38 <adarqui> delrik: word!
07:27:47 <delrik> hi adarqui!
07:28:05 <mniip> delrik, anyway, future notice
07:28:19 <mniip> pointfree is indeed cool, but no one likes to decipher (. (. foo)) . bar
07:28:23 <mniip> (besides me maybe)
07:28:39 <delrik> mniip: I’m doing it more for the mental excercise.  I'
07:28:46 <delrik> m at the junction where I
07:29:07 * mniip can relate to the apostrophe-enter issue
07:29:10 <delrik> can finally see the semantic differences between the applicative F vs Monadic styles
07:29:27 <mniip> heh
07:29:35 <mniip> I can pointfree any expression in my head
07:29:49 <delrik> and the former requires a better intutiuon of fn composition, which from my understanidng is epitomised in PF
07:30:33 <delrik> what kinds of excercises can I do to get a better intuition for that?, my reasoning falls apart when I have more than on unbound name =\
07:30:37 <mniip> pointfree is all about transforming a stack of applications into a composition with one application
07:30:44 <mniip> and then eta-reducing that applications
07:30:47 <mniip> application*
07:31:07 <obfuscatr> mniip: don't understand, can you expand a bit - trying to relate the type signature from the docs for System.Random to a command in ghci to get a single random int
07:31:20 <mniip> obfuscatr, in GHCi?
07:31:34 <mniip> fst $ random g :: Int
07:31:55 <mniip> note that unless you change g, you are going to get the same number over and over
07:32:23 <mniip> delrik, hmm
07:32:27 <osa1> when I duplicate an instance in a module does it effect instance resolution in other modules?
07:32:42 <yac> there is a guide to state monads by using random so you can just `get` new random value
07:33:11 <delrik> mniip: or rather, how do you go about visualising the stack of applications?
07:33:23 <lpaste_> tejon revised “Pango build breakage”: “No title” at http://lpaste.net/135050
07:33:24 <mniip> yac, random :: State StdGen a
07:33:39 <mniip> delrik, well give me a function as an example
07:33:54 <delrik> for simplicities sake: ((. return) . (++))
07:34:16 <mniip> you mean \xs x -> xs ++ [x]
07:34:27 <Fuuzetsu> @unpl ((. return) . (++))
07:34:27 <lambdabot> (\ d g -> d ++ (return g))
07:34:43 <tejon> srhb, lpasted by request :P
07:35:01 <obfuscatr> if fst $ random g :: Int returns a result, what does it look like to let (SOMETHING) = random g :: Int ?
07:35:12 <delrik> I have to run a stand up right now =|, bb in 15!
07:35:22 <srhb> tejon: Ah sorry, I should have said that my eyes glazed over when you said Windows. I've no idea how anything works there :P
07:35:28 <mniip> obfuscatr, exactly what I pasted above
07:35:39 <tejon> Nobody does, man... nobody does. :P
07:35:57 <mniip> well, first, lets desugar: '\xs x -> xs ++ (x:[])', then, we see that x is first consed with [] and then concated with xs: '\xs x -> (xs++) . (:[]) $ x'
07:36:08 <mniip> here we eta-reduce: '\xs -> (xs++) .(:[])'
07:36:31 <mniip> then we see that x is first applied to ++, then composed with (:[])
07:37:01 <mniip> '\xs -> (. (:[])) . (++) $ xs' one more eta reduction: '(. (:[])) . (++)'
07:38:08 <obfuscatr> mniip: I can't seem to figure out how to make the variable on the left defined correctly.. e.g. let (a::Int, g) = random g, or let (a, g2) = random g   give errors I can't parse
07:38:32 <geekosaur> the first one would be rather wrong anyway
07:38:41 <mniip> obfuscatr, you need a type restriction on the 'random g' expression
07:38:46 * hackagebot snap-loader-dynamic 0.10.0.3 - Snap: A Haskell Web Framework: dynamic loader  http://hackage.haskell.org/package/snap-loader-dynamic-0.10.0.3 (DougBeardsley)
07:38:48 * hackagebot species 0.3.4.2 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.4.2 (BrentYorgey)
07:38:53 <mniip> it has type (a, StdGen), so you need
07:39:00 <c_wraith> obfuscatr: let a :: Int ; (a, g2) = random g
07:39:03 <mniip> let (a, g2) = random g :: (Int, StdGen)
07:39:08 <mniip> or what c_wraith said
07:39:31 <srhb> tejon: One thing though
07:39:44 <srhb> tejon: Could you grep the src directory for Intzu or Wordzu?
07:40:04 <srhb> Oh, nevermind, I see the macro now
07:40:44 <srhb> I guess that's broken then.
07:44:06 <tejon> srhb, yeah, that was the first thing I did. :)
07:49:23 <Peaker> hmm.. I think I find a ghc bug in record wild cards
07:50:34 <Peaker> data Foo = Foo Int deriving Show ; f Foo{..} = Foo{..} ; f (Foo 5) yields an error and no compile time warning/error!
07:52:20 <monochrom> that is desugared to: "f Foo{} = Foo undefined". what errors does this have?
07:53:08 <Peaker> ah, https://ghc.haskell.org/trac/ghc/ticket/9815 is my bug
07:53:40 <Peaker> well, I guess it's also the {..} allowed on the LHS that is a bug
07:54:14 <Peaker> what's the fix version there? I can't see it
07:55:24 <merijn> Peaker: You wanna match constructors without fields and return the entire thing?
07:55:51 <merijn> @let data Foo = Foo Int deriving (Show)
07:55:52 <lambdabot>  Defined.
07:55:54 <Peaker> merijn: I have a type-changing function that tediously needs to do:  foo (A x) = A x ; foo (B y) = B y ; foo ...
07:56:20 <merijn> Ah, my solution won't work then
07:56:22 <Peaker> I was hoping foo A{..} = A{..}   will work to make it a bit less tedious :)
07:56:28 <merijn> Try using coerce?
07:56:31 <merijn> :t coerce
07:56:32 <lambdabot> (Functor f, Contravariant f) => f a -> f b
07:56:38 <merijn> hmmm, wrong coerce
07:56:58 <Peaker> well, in some of the cases I do work:  foo (Z x) = Z (bar x)
07:57:05 <merijn> Peaker: How much backward compatibility do you care about?
07:57:17 <merijn> (GHC versions)
07:57:28 <Peaker> well I'd rather not extend the set of GHC features I rely on atm (which is RecordWildCards, RankNTypes, and a few more)
07:57:31 <merijn> You could add general "f x = coerce x" as last case
07:57:46 <merijn> But coerce is only in recent GHCs, afaik
07:57:53 <Peaker> why is that valid? It doesn't know about the cases that do need to be type-changed
07:57:53 <merijn> like 7.8 or 7.10
07:57:57 <c_wraith> coerce is only in 7.8+, iirc
07:58:16 <merijn> Peaker: The last catch-all case for type changing
07:58:24 <merijn> Peaker: And anything that requires work goes before that
07:58:27 <Peaker> fmap f (Just x) = Just (f x) ; fmap _ other = coerce other
07:58:40 <Peaker> coerce :: Maybe a -> Maybe b  ?
07:58:47 <c_wraith> Yeah, that's 7.8+
07:58:50 <c_wraith> https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Coerce.html
07:59:02 <Peaker> but doesn't it require anything from "a" or "b" ?
07:59:08 <merijn> Peaker: It does
07:59:14 <merijn> https://downloads.haskell.org/~ghc/7.8.2/docs/html/libraries/base/Data-Coerce.html
07:59:15 <c_wraith> It requires a Coercible instance
07:59:18 <Peaker> well, I don't have any constraints on a and b
07:59:23 <c_wraith> But the compiler generates those instances automatically
07:59:57 <merijn> Peaker: Your only changing phantom types, no?
08:00:02 <merijn> Peaker: looking at your example
08:00:17 <Peaker> I have something like a:  foo :: Lens.Traversal (Maybe a) (Maybe b) a b ; foo f (Just x) = f x <&> Just ; foo _ Nothing = pure Nothing    except it is for a different type and not Maybe of coursse, so instead of 1 case for Nothing I have 5-6 cases
08:00:19 <merijn> Peaker: Coercible should be able to do that no problem, hell that's one of the usecases it was added for
08:00:30 <Peaker> merijn: it's not a phantom type, it's simply a type that only appears in some of the cases
08:00:38 <mniip> merijn, doesn't seem to work
08:01:06 <Peaker> merijn: in the above traversal for Maybe, could I change foo _ Nothing = pure Nothing   with  foo _ other = pure (coerce other)    and have it work at the same type?
08:01:09 <mniip> (the coerce that is)
08:01:26 <merijn> Peaker: Not sure
08:01:36 <Peaker> It shouldn't work -- it wouldn't make sense for it to work
08:01:39 <merijn> mniip: Where did it not work
08:02:28 <mniip> foo (Just _) = Just ()
08:02:28 <mniip> foo x = coerce x
08:02:49 <mniip> which I presume is Peaker's use case
08:02:55 <merijn> Yeah, that doesn't work
08:03:08 <merijn> You could use unsafeCoerce there, but that's obviously unsafe :p
08:03:30 <Peaker> merijn: I'll just list all cases :P
08:03:40 <Peaker> In Lamdu it'd be nicer! :)
08:04:05 <Peaker> cause in Lamdu's sum types which I'm now adding, "case" handles a single alt of your sum type, removing it (like OCaml's polymorphic variants)
08:05:54 <Peaker> would be nice if ghc trac had a field for "fixed in version[s]"
08:06:17 <Peaker> it seems to only be fixed in 7.10.1, and not 7.8.4
08:07:39 <bennofs> Peaker: is there already a way to run lambdu code?
08:07:54 <Peaker> bennofs: Yep (for toys for now) :)
08:08:03 <Peaker> bennofs: http://peaker.github.io/lamdu/fac.gif
08:08:28 <bennofs> :o nice
08:08:32 <frerich> Peaker: Awww
08:08:50 <frerich> Peaker: Is that 'bottle'?
08:09:09 <Peaker> frerich: bottle has been renamed to lamdu years ago :)
08:09:14 <frerich> Oh.
08:09:25 <frerich> Years? Really? Has it been that long? Tsk.
08:09:46 <delrik> mnip: As far as the eta reduction goes, the unbound names that I'
08:09:59 <Peaker> We started work around end of 2011.. It's a side project and we don't always have time to work on it
08:10:07 <Peaker> (We've had long periods of not working on it at all)
08:10:22 <Peaker> We're back to 50-60% working on it though now! :-D
08:11:30 <delrik> m reducing should should successively removed via the generation of an application stack. That’s fine, but my real point of contention is how I should reason about the ‘intermediate’ functions that are created, simply to provide the pipeline.  
08:12:17 <delrik> I’m going to try working it out by hand using lambda calc
08:12:49 <delrik> mnip: thanks for the explanation!
08:22:41 <ocharles_> Does GHC's RTS give anyway to sample the memory stats for a particular thread at a point in time?
08:23:48 * hackagebot hasql-postgres 0.10.3.3 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.10.3.3 (NikitaVolkov)
08:25:02 <srhb> ocharles_: I doubt it, since lightweight threads aren't really self contained like that, but you may want to ask ezyang about this, iirc.
08:25:29 <ocharles_> It might be enough to just sample the whole RTS
08:25:47 <ocharles_> somewhere in our web server we have a memory leak though, and it's proving a serious pita to work out what is going wrong
08:25:58 <Enigmagic> ocharles_: you can get information about thread roots (and traverse the heap yourself) but GC stats aren't tracked per thread
08:27:03 <srhb> ocharles_: Wouldn't ekg help there then?
08:27:19 <ocharles_> ekg just confirms that there is a leak
08:27:19 <ocharles_> :)
08:27:29 <obfuscatr> hum, what causes 'unknown symbol' when 'Loading package' in ghci ?
08:27:41 <ocharles_> obfuscatr: are you missing a module from your .cabal file?
08:27:53 <ocharles_> that's usually a linker problem, but it could be the cause of that
08:27:58 <srhb> ocharles_: True enough. Not sure there's anything really beyond GHC.Stats
08:28:14 <ocharles_> srhb: ok, that at least gives me something to look at
08:28:14 <ocharles_> thanks!
08:28:41 <srhb> It's really not that useful I'm afraid.
08:28:47 <ocharles_> I might just run the whole server in profiling mode and see how that goes...
08:28:48 <srhb> Hopefully you'll think of something :)
08:28:58 <srhb> yeah, that sounds more likely to pinpoint it.
08:29:19 <tejon> So, fun update on my pango issue: I got it to build, but I still don't understand why it was failing.
08:29:27 <obfuscatr> ocharles_: have absolutely no idea. i'm a haskell newb, have just cabal install'ed a few things, not aware that i've fiddled with any config files. cabal install did complain 'Unrecognized field key' in some tmp file, but then appeared successful.
08:29:30 <ocharles_> I'm just scared about the performance of the profiling RTS, but I guess if it goes horribly wrong I can just switch back
08:29:52 <srhb> ocharles_: Can't replicate the problem on a dev server?
08:30:20 <tejon> The fix was to change the gtk2hs_type macro's string formatter from { "%s%" G_GSIZE_FORMAT } to { "%s%Iu" }
08:30:20 <srhb> tejon: Yay/boo! :P
08:30:24 <ocharles_> Nope
08:30:31 <srhb> ocharles_: Frustrating...
08:30:31 <Enigmagic> ocharles_: at one point i had written an RTS "plugin" of sorts to dump the heap into a json blob... made debugging this stuff easier
08:30:33 <tejon> G_GSIZE_FORMAT being "zu"
08:30:55 <ocharles_> srhb: I haven't worried about it for ages, because even when it runs out of memory and gets killed, it takes less than a second to restart
08:30:56 <tejon> ...which is suppposed to be correct as of C99. :/
08:31:08 <ocharles_> but it's about time I worked out wtf was going on :)
08:31:08 <ocharles_> it restarts about 6 times a day
08:31:13 <srhb> Yeah, not nice.
08:33:49 * hackagebot http-client 0.4.13 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.13 (MichaelSnoyman)
08:38:21 <obfuscatr> gah, is it normal that i need to update ghc to 7.8 to fix some broken library issue (described here https://github.com/bos/double-conversion/issues/8 )
08:39:00 <tejon> UPDATE to 7.8?
08:39:28 <tejon> Is something still bundling 7.6?
08:39:38 <obfuscatr> tejon: ubuntu 14
08:41:04 <asmyers> obfuscatr, Have you seen this PPA? https://launchpad.net/~hvr/+archive/ubuntu/ghc
08:41:39 <obfuscatr> asmyers: yeah, just found that, was just checking that it's necessary to upgrade, but sounds like answer is yes.
08:48:49 * hackagebot nixfromnpm 0.1.0.5 - Generate nix expressions from npm packages.  http://hackage.haskell.org/package/nixfromnpm-0.1.0.5 (thinkpad20)
08:49:05 <joshc> window 21
08:49:18 <joshc> :(
08:53:35 <bitemyapp> joshc: gooby pls http://i.imgur.com/00SfPYn.png
08:54:03 <srhb> bitemyapp: How on earth do you monitor all that o_o
08:54:25 <Clint> why would he
08:54:25 <bitemyapp> srhb: I'm only responsible for a couple of channels.
08:54:44 <bitemyapp> the rest...I rely on notifications.
08:54:51 <bitemyapp> magenta numbers *_*
08:55:31 <Welkin> bitemyapp: how do you swith between windows by number in irssi?
08:55:35 <Welkin> I never figured that out
08:55:35 <c_wraith> Are those a variant of surreal numbers?
08:55:41 <felixn> I remember I would just scroll through with ctrl+N every 10 minutes like an OCD person, I'm liking textual now though
08:55:46 <Welkin> I always cycle through mine, so I keep the number of channels I am in low
08:55:51 <Fuuzetsu> IIRC it was just /win <number>
08:55:52 <Welkin> switch*
08:55:58 <felixn> Welkin: I think I had /alias w win, so I would just do /w 10
08:56:00 <Fuuzetsu> not used it in years though
08:56:18 <bitemyapp> Welkin: I don't
08:56:33 <c_wraith> Huh.  Constructing surreal numbers in Haskell is pretty easy.  Doing something interesting with them is not.  Damn computation's insistence on constructability!
08:56:35 <bitemyapp> Welkin: numerical navigation requires I remember where things are.
08:56:41 <Welkin> nice
08:56:46 <ski> Welkin : `M-1' through `M-0', and then `M-q' through `M-o', for windows `1' through `19'
08:56:47 <bitemyapp> Welkin: I just /join #channel-name
08:56:49 <Welkin> thanks Fuuzetsu :)
08:57:03 <bitemyapp> if I'm already in the channel, it just switches to that window.
08:57:04 <ski> (and `M-a' for the most recent window or something like that. i don't use it)
08:57:13 <bitemyapp> I use M-a to switch to magenta.
08:57:17 <bitemyapp> and check for notifications.
08:57:40 <Welkin> meta is captured on my system (osx) to be used for special characters
08:57:59 <Welkin> that is always a problem when using emacs ina terminal...
08:58:12 * ski usually uses `/window <number>|#<channel>' for higher
08:58:31 <favetelinguis> Is it not possible to use the Writer data constructor for the Writer monad any longer? Im trying the example under "Using do notation with Writer" http://learnyouahaskell.com/for-a-few-monads-more
08:58:43 <ski> Welkin : you can possibly separately tap `ESC' before, instead
08:59:09 <ski> @type writer  -- favetelinguis
08:59:10 <lambdabot> MonadWriter w m => (a, w) -> m a
08:59:24 <ski> @type writer :: (a,w) -> Writer w a
08:59:26 <lambdabot>     No instance for (Monoid w1) arising from a use of ‘writer’
08:59:26 <lambdabot>     Possible fix:
08:59:26 <lambdabot>       add (Monoid w1) to the context of
08:59:37 <ski> @type writer :: Monoid w => (a,w) -> Writer w a
08:59:38 <lambdabot> Monoid w => (a, w) -> Writer w a
08:59:54 <S11001001> favetelinguis: you can also just use a 2-tuple as a writer.
09:00:42 <S11001001> > traverse (\a -> (a, 0 - a)) [1,2,3,4]
09:00:44 <lambdabot>      No instance for (Show b0)
09:00:44 <lambdabot>        arising from a use of ‘show_M781876925918756632215951’
09:00:44 <lambdabot>      The type variable ‘b0’ is ambiguous
09:01:04 <S11001001> > traverse (\a -> (a, 0 - a)) [1,2,3,4] :: (Int, Int)
09:01:06 <lambdabot>      Couldn't match type ‘[Int]’ with ‘Int’
09:01:06 <lambdabot>      Expected type: (Int, Int)
09:01:06 <lambdabot>        Actual type: (Int, [Int])
09:01:12 <S11001001> > traverse (\a -> (a, 0 - a)) [1,2,3,4] :: (Int, [Int])
09:01:14 <lambdabot>      No instance for (Monoid Int) arising from a use of ‘traverse’
09:01:14 <lambdabot>      In the expression:
09:01:14 <lambdabot>          traverse (\ a -> (a, 0 - a)) [1, 2, 3, ....] :: (Int, [Int])
09:01:19 <S11001001> right.
09:01:34 <S11001001> choose your monoid and you're set :)
09:02:02 <ski> > traverse (\a -> (Sum a,negate a)) [1,2,3,4] :: (Sum Int, [Int])
09:02:04 <lambdabot>  (Sum {getSum = 10},[-1,-2,-3,-4])
09:02:16 <michaelt> favetelinguis: the Writer w r type in the transformers is WriterT w Identity r, so there is no Writer constructor
09:02:59 <favetelinguis> hmm ok so the example is outdated then i guess
09:03:03 <srhb> Yep.
09:03:20 <michaelt> favetelinguis: they define their own Writer newtype in there I see. 
09:03:36 <michaelt> no, I guess it's just mentioned
09:03:50 * hackagebot messagepack 0.4.0 - Serialize instance for Message Pack Object  http://hackage.haskell.org/package/messagepack-0.4.0 (rodrigosetti)
09:03:52 * hackagebot nixfromnpm 0.1.0.6 - Generate nix expressions from npm packages.  http://hackage.haskell.org/package/nixfromnpm-0.1.0.6 (thinkpad20)
09:04:25 <michaelt> favetelinguis: anyway, you can implement Functor, Applicative and Monad -- instance Monoid w => Monad (Writer w)  
09:04:39 <danilo2> Hello! Is there in Haskell any library for bitwise masks? I mean masks used when a key is pressed to determine what key combination is used? With fast comparison etc
09:05:05 <S11001001> speaking of, dibblego https://github.com/NICTA/validation/pull/5 ?
09:05:18 <michaelt> @type (("hello", 'a') >>=)
09:05:19 <lambdabot>     No instance for (Monad ((,) [Char])) arising from a use of ‘>>=’
09:05:19 <lambdabot>     In the expression: (("hello", 'a') >>=)
09:05:20 <tdammers_> danilo2: Data.Bits?
09:05:42 <benma> danilo2: why does it have to be fast? people are not that fast at hitting key combos
09:05:45 <danilo2> tdammers_: how is it possible I didnt found it? Thnaks! :D
09:05:50 <michaelt> @type (('a',"hello") >>=)
09:05:51 <lambdabot>     No instance for (Monad ((,) Char)) arising from a use of ‘>>=’
09:05:51 <lambdabot>     In the expression: (('a', "hello") >>=)
09:06:04 <S11001001> michaelt: wacky
09:06:08 <michaelt> I thought there was an instance 
09:06:31 <S11001001> michaelt: there's totally a lawful instance
09:06:40 <tdammers_> danilo2: np, probably one of the less discoverable modules
09:06:48 <tejon> danilo2, the hard part might be getting the scancodes.
09:07:12 <michaelt> Yes, maybe it was too confusing? Of course the one for (->) r is really confusing, but is visible in the Prelude.
09:07:15 <danilo2> tejon: scancodes? You mean the button codes?
09:07:26 <danilo2> tdammers_: heh:) Thank you once again! :)
09:07:34 <Fuuzetsu> I thought (,) a was being added as Monad in the future
09:08:29 <michaelt> Fuuzetsu: oh I see. I think S11001001 and I thought it was already around.
09:08:50 * hackagebot optparse-declarative 0.2.0 - Declarative command line option parser  http://hackage.haskell.org/package/optparse-declarative-0.2.0 (HideyukiTanaka)
09:09:01 <S11001001> michaelt: it's odd the Applicative is but the Monad isn't already
09:09:40 <danilo2> tdammers_: By the way, how can I use the Bits library? How can I set the zeroBits? Its polymorphic, but what type shoudl I use there. It might be very simple question, but I just didnt discover it yet :)
09:10:01 <Fuuzetsu> whatever type it is you need it to be that has an instance…
09:10:10 <danilo2> tdammers_: ah, I can siply use Int, nevermind :) thanks!
09:10:16 <tdammers_> danilo2: an integer type large enough to hold the bits you need would be the first choice ;)
09:14:55 <michaelt> S11001001: Oh strange, I see the Applicative instance now.
09:25:36 <joco42> when I say "cabal sandbox init" will some env. variable change ? or just a directory created ? whot effects does "cabal sandbox init" have ? 
09:26:03 <srhb> joco42: Just a directory and a file.
09:26:20 <joco42> srhb: thanks, that is good to know.
09:27:00 <srhb> joco42: It will actually tell you as much, so you can probe them afterwards.
09:27:54 <joco42> srhb: I can see the directory, but I was not sure about other side effects
09:28:51 * hackagebot clash-prelude 0.8.1 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.8.1 (ChristiaanBaaij)
09:33:51 * hackagebot setlocale 1.0.0.3 - Haskell bindings to setlocale  http://hackage.haskell.org/package/setlocale-1.0.0.3 (Kritzefitz)
09:43:51 * hackagebot taggy 0.2.0 - Efficient and simple HTML/XML parsing library  http://hackage.haskell.org/package/taggy-0.2.0 (AlpMestanogullari)
09:53:52 * hackagebot stack 0.1.0.0 - The Haskell Tool Stack  http://hackage.haskell.org/package/stack-0.1.0.0 (borsboom)
09:59:59 <sweater1> I sometimes have union types only for fragments of which certain functions make sense. Ergo, I want to write deliberately incomplete functions. That feels bad and calls for refactoring of types. What do you do in situations like that? Write complete functions making code fragile; supress warnings; refactor types?
10:01:47 <ski> sweater1 : you want refinement types. Haskell doesn't have that. i'd probably either add an error message to the effect that a precondition was violated, or refactor, there
10:03:07 <hodapp> or use LiquidHaskell, if you're feeling daring.
10:04:51 <sweater1> hodapp: I'm more or less in production mode, but I want to play with LH eventually, yes :) ski: yes, ok.
10:06:59 <mmachenry> Anyone want to talk about managing thread resources in an finite loop (a server)? I'm wondering if there's a better way to solve my problem. http://lpaste.net/edit/134982
10:07:47 <mmachenry> In the above code I could simply call async instead of async (and not have a memory leak) but if my parent dies for any reason I have zombie children. 
10:09:31 <mmachenry> So I am thinking I could solve this memory leak and also have threads managed by creating a shared MChan with all the active threads. When a thread is completed it puts itself into a list of threads to be reaped and then that always-running thread cleans it up.
10:09:44 <mmachenry> This sounds a bit complicated.
10:09:50 <mmachenry> But it's not bad.
10:09:59 <bernalex> conal: ping?
10:14:07 <infandum> Should I use an underscore to prefix a record specific function, like "_cheese"?
10:14:14 <infandum> Is it good practice?
10:14:36 <infandum> I see it a lot, but it seems to be mostly for lens, but what if I decide to use lenses later on in 2 years or whatever
10:15:18 <Iceland_jack> infandum: lens doesn't require underscores 
10:15:37 <infandum> Iceland_jack: For template haskell to automatically derive things though it does, right?
10:16:09 <mmachenry> infandum: You should if you're not going to use that function.
10:16:44 <mmachenry> Prefixing with an underscore actually does not bind the identifier. You could make it be just _ but people use _name to increase readability. 
10:16:46 <Iceland_jack> infandum: You can change the configuration
10:17:11 <Iceland_jack> With ... for example
10:17:11 <Iceland_jack>     makeLensesFor :: [(String, String)] -> Name -> DescQ
10:17:17 <ion> > let a _foo = _foo in a 42
10:17:18 <lambdabot>  42
10:17:25 <infandum> I see. So it actually DOES treat it differently. I should stick without them then it looks like
10:17:35 <mmachenry> Adding the underscore supresses warnings that you've defined an indentifier you haven't used.
10:18:02 <infandum> ah
10:18:10 <infandum> weird that I see it so much
10:18:53 <mmachenry> infandum: I use it. I think it's common. If you want to give explicit names to things for documentation, but you just end up pattern matching instead of calling the accessors, then it's the way to go.
10:19:26 <ski> perhaps it would otherwise warn about unused field name, in case it's not exported ?
10:19:33 <mmachenry> infandum:  you might also see a lot of underscore names in function arguments, particularly for things like a base case where some arguments are not used.
10:20:12 <Hi-Angel> How is that possible: I see the function declaration which is startGtkHook :: (Gtk.Window -> IO ()) -> UIBoot. And the implementation starts as startGtkHook userHook cfg ch outCh ed =  5 ARGUMENTS! How could that work, when the definition mention just one argument(Well, with currying 2, but not five)!
10:20:36 <mmachenry> For example the base case of 'map' could be defined as "map _ [] = []" because if the list is empty you don't need the function. But GHC with warnings on will complain if you were to write "map f [] = []"
10:20:52 <Ralith> Hi-Angel: UIBoot is a function type
10:21:40 <infandum> I see. I typically don't make an accessor function unless I need it, so I think I'll stick to not using underscores for now unless I use template haskell.
10:21:52 <Hi-Angel> Ralith, okay But it is anyway something that the function returns, it doesn't explain those five arguments
10:22:16 <Ralith> yes, it does
10:22:22 <mmachenry> infandum: Yes, but what if you need one accessor function but you don't need an accessor function for another field? There's no syntax that lets you give one field an accessor but not all.
10:22:25 <Ralith> haskell functions all take exactly one argument
10:22:51 <Ralith> what you think of as a "multi-argument function" is actually just a one-argument function that returns another one-argument function and so forth
10:23:18 <Ralith> 'f x y z = ...' is shorthand for 'f = (\x -> (\y -> (\z -> ...)))'
10:24:23 <Serpentine_> Currying is nice, except when it isn't.
10:24:51 <infandum> mmachenry: I don't understand what you mean. Can you give an example?
10:24:52 <Hi-Angel> Ralith, okay, I know what the currying is. But I anyway couldn't get why in the definition is just two arguments, while in the implementation is five.
10:25:12 <Ralith> Hi-Angel: because the author wanted to do it that way
10:25:28 <mmachenry> infandum: Yeah sure. Let me lpaste it. Give me 2 mins
10:25:45 <Ralith> as I explained above, the definition does actually specify 5 arguments, four of them are just hidden behind UIBoot
10:25:56 <Ralith> you should look at the definition of UIBoot
10:26:14 <Hi-Angel> Ah, I see
10:30:04 <lpaste_> mmachenry pasted “When to use underscore” at http://lpaste.net/135059
10:30:13 <mmachenry> infandum: Check it out ^
10:30:30 <mmachenry> Both are illustrated in the code. 
10:31:09 <mmachenry> _personLocation is so named because I don't want GHC complaining "Hey you never used this identifier!" but I do want all warnings turned on.
10:31:10 <Hi-Angel> No, I didn't see
10:31:43 <mmachenry> _ in the function pattern match is terse, I could have made it be _name instead, but in that case I opted to be more terse because it's just a pattern match.
10:32:30 <mmachenry> But I can't give personName and an accessor function and not give _personLocation one. That's not how record syntax works. I'd need to define personName out side of the record separately, which is fine, but annoying. 
10:32:38 <infandum> mmachenry: Ah, that's what you mean. I never do that because I always explicitly use the accession in pattern matching so when I go back to the code I know what I am using, but I see how other people would want that
10:33:10 <mmachenry> infandum: Using accessor functions often leads to more verbose but more maintainable code.
10:33:17 <ski> Hi-Angel : if you have a definition something like `type UIBoot = Config -> Channel -> Channel -> Ed -> IO ()', then `startGtkHook :: (Gtk.Window -> IO ()) -> UIBoot' would be equivalent to `startGtkHook :: (Gtk.Window -> IO ()) -> Config -> Channel -> Channel -> Ed -> IO ()'
10:33:30 * ski doesn't know the actual definition of `UIBoot'
10:33:38 <infandum> mmachenry: Definitly. The code is much longer but "easier" to go back to
10:33:56 <mmachenry> infandum: Imagine if I wanted to change something about how Person is implemented, change the number of things in it. distanceBetweenPeople is now broken I might have wished I had used personLocation instead.
10:34:18 <mmachenry> Also pattern matching is fragile. You need to explicitely match the whole data type.
10:34:41 <mmachenry> This actually gets to be *more* verbose with data types that have lots of pieces and when you're ignoring most of it.
10:34:56 <infandum> mmachenry: Yeah. You would need to change it no matter what. But you would not need to change the order :)
10:35:05 <Hi-Angel> ski, ah, I now I see. I.e. it could use all the arguments, and after this still additionally return that  Config -> Channel -> Channel -> Ed -> IO ()
10:35:05 <mmachenry> So there's a trade off either way. Use whichever you like, it's mostly a matter of taste and subjective decision based on the use case.
10:35:12 <mmachenry> But you should know the trade offs.
10:35:38 <infandum> mmachenry: Yeah, I had no idea they were treated differently. Thank you for letting me know about that--it may have led to some bugs haha
10:35:42 <Hi-Angel> Thank you!
10:36:07 <mmachenry> infandum: If I used personLocation as an accessor I could change the Person data type all I want. Potentially to not even have a location in it! Provided I still can implement personLocation as a function some where, some how.
10:36:37 <infandum> mh
10:36:39 <infandum> m
10:36:42 <mmachenry> Maybe I take location out of the Person type, and create a lookup table that looks up a person's location in a database by name.
10:37:25 <mmachenry> Now all I have to do is reimplement personLocation as a function instead of as an accessor built automatically from the record syntax.
10:37:41 <ski> Hi-Angel : if it's defined like `startGtkHook userHook cfg ch outCh ed = ...', assuming `startGtkHook :: (Gtk.Window -> IO ()) -> UIBoot' and `type UIBoot = Config -> Channel -> Channel -> Ed -> IO ()', then the type of the body `...' would have to be `IO ()', not `Config -> Channel -> Channel -> Ed -> IO ()'
10:38:06 <ski> Hi-Angel : perhaps this is what you meant (or perhaps you understood it anyway) .. i'm just clarifying in case
10:39:17 <Gurkenglas> How do I fix this? http://pastebin.com/4z7HeXXF
10:39:55 <geekosaur> still asking that question with no understanding of all the discussion last night?
10:40:21 <infandum> mmachenry: But then you would have a mix of underscores and non underscores! It would be chaos!
10:40:31 <Gurkenglas> Yep. There was something about programms called mingw and cygwin. I have one, but should use the other, though I dont know whether Im using either at all
10:40:53 <Gurkenglas> *I was told that I have one, but should use the other
10:42:09 <mmachenry> infandum: Well you could do all non-underscore, which is what I was suggesting.
10:42:14 <Gurkenglas> Oh wait, someone posted an allegedly old & applicable link with instructions, come to think of it... lemme try http://neilmitchell.blogspot.ca/2010/12/installing-haskell-network-library-on.html .
10:42:15 <mmachenry> But yes, you can mix them too.
10:42:17 <geekosaur> Gurkenglas, I think you must find out
10:42:33 <geekosaur> because you were very OBVIOUSLY getting errors that were coning from cygwin
10:42:47 <geekosaur> maybe when something says "cygwin warning" all you can see is "warning"?
10:43:11 <geekosaur> and nobody here can break into your system and find out what you installed where
10:43:23 <geekosaur> (or if someone can, they're probably not going to do it just to fix this...)
10:44:46 <Gurkenglas> Those warnings seemed unrelated as the fatal error was something about a missing file that didnt mention cygwin, and I could imagine that cygwin warning might also be called that because whatever makes the warnings was expecting to interact with cygwin. Is cygwin needed for anything that mingw can't do, or should I try finding and uninstalling it? (But Im guessing I should try that link first.)
10:46:47 <Gurkenglas> (Huh, Windows-R -> cygwin starts something. I guess I could have tried that sooner.)
10:47:08 <johnw> Gurkenglas: sometimes starting out can be difficult, no worries
10:47:30 <geekosaur> Gurkenglas, <sys/uio.h> is a Unix specific header file
10:47:39 <geekosaur> it does not exist and can not exist for Windows
10:47:39 <Gurkenglas> Believe it or not, I've been using Haskell for about 14 months, I just never had to wrangle packages.
10:48:00 <geekosaur> the fact that the network build is looking for it means that it thinks it is on Unix, not Windows
10:48:18 <geekosaur> where this ties into cygwin is that the purpose of cygwin is to pretend that Windows is Unix
10:48:54 * hackagebot haskanoid 0.1.5 - A breakout game written in Yampa using SDL  http://hackage.haskell.org/package/haskanoid-0.1.5 (IvanPerez)
10:48:57 <Clint> really, really slow unix
10:49:09 <Welkin> Gurkenglas: I have been using it now for over a year as well and just last week I had a nightmare situation with ghc and cabal
10:49:12 <Gurkenglas> (http://neilmitchell.blogspot.ca/2010/12/installing-haskell-network-library-on.html leads to http://pastebin.com/swr4E8Q1 )
10:49:26 <geekosaur> (any header file under sys/ is a reference to Unix kernel structures. a very few of those can be emulated; most cannot)
10:50:42 <Gurkenglas> Will everything fail catastrophically if I simply try to uninstall cygwin and expect mingw to fill its place?
10:50:54 <Gurkenglas> (Installed mingw at some point yesterday, I think.)
10:52:23 <johnw> Gurkenglas: you should be able to have them co-exist, they are under different root paths
10:52:31 <Gurkenglas> I believe you that the failure ties in with cygwin, I was only justifying my not knowing fore sure it beforehand.
10:52:38 <johnw> what matters is your PATH variable and which one it points to
10:52:50 <johnw> I once had Cygwin, Mingw and GnuWin32 all going at once
10:53:09 <geekosaur> anything already built while cygwin was installed might fail subsequently being unable to find cygwin1.dll or similar
10:53:12 <geekosaur> it is possible to get them to coexist but it requires considerable care
10:53:17 <johnw> that is true
10:53:42 <Hi-Angel> ski, thank you, I am just experimented a bit in ghci, and now I see
10:53:50 <Gurkenglas> Shall I reinstall Haskell Platform using mingw, then? Will anything else fail for mingw as Network does for cygwin?
10:54:16 <Gurkenglas> (To switch which one I'm using, I delete the cygwin path from my PATH and add the mingw path?)
10:54:22 <johnw> Gurkenglas: can you try out the installation in a VM instead of your main machine?
10:54:38 <johnw> just to minimize the impact if that route fails as well
10:54:48 <geekosaur> the biggest issue with a mingw-based install is that a lot of unix-originated libraries and programs aren't there by default, and you have to do more work to get them installed (cygwin already includes many fo themm and provides an installer for others)
10:56:07 <Gurkenglas> I would have to install VM software first, I guess. How long does that tend to take? Could I VM a Unix machine so there's no cygwin or mingw stuff and I would do my Haskell stuff on there?
10:56:29 <johnw> I've had the most success with cygwin, if I recall
10:56:40 <johnw> but I've never really done any serious Haskell work there
10:57:05 <johnw> I'd heed geekosaur's experience
10:58:05 <Gurkenglas> To remind, a more ulterior motive is to find a way to run this. http://lpaste.net/134997 (Yes yes, System -> System.Environment.)
10:58:14 <geekosaur> well, I find cygwin pretty much unusable because it's just unixy enough to lead me straight into the places where the emulation fails completely >.>
10:58:34 <geekosaur> (like this network build error but with more headdesking...)
10:58:40 <hodapp> geekosaur: I just found it better than cmd.exe but that was about it
10:58:46 <kadoban> Gurkenglas: VMs are not very hard to set up if installing an OS doesn't scare you. You can install linux mint in a VM in probably an hour? (I'd go with xfce or something for a VM, there's a linux mint variant with that)
10:59:05 <hodapp> you can even find VM images already made sometimes
10:59:10 <hodapp> and get those running in a matter of minutes
10:59:45 <Gurkenglas> *googles 'xfce linux mint' and looks at the first result*
11:00:43 <maerwald> I'd not recommend mint, afair ghc is terribly outdated there, no?
11:01:23 <monochrom> you don't have to use mint's ghc. or arch's ghc for that matter
11:01:25 <kadoban> maerwald: Is there any OS that has good haskell out of the box? I'd install just GHC and cabal manually from the binaries and then use cabal sandboxes.
11:01:41 <geekosaur> ghc is 7.8.3
11:01:44 <kadoban> Gurkenglas: On the linux mint page, go to downloads and it's near the bottom, the Xfce thing. xfce is just a pretty simple window-manager, which for a VM works nice since you usually don't care about the WM.
11:01:56 * geekosaur has two mint installs, both with haskell platform and xmonad
11:02:30 <Gurkenglas> Following "Download" words led to http://www.linuxmint.com/edition.php?id=182 , where selecting the FH Aachen mirror leads me to an hour download of a 1.5 GB thing. That's the right thing, right?)
11:02:33 <kadoban> Gurkenglas: If you end up going that way, this is how I install GHC/cabal: https://gist.github.com/ion1/2815423
11:02:53 <geekosaur> it'd be a dvd image, yes
11:02:55 <maerwald> kadoban: well, nixos has a recent ghc version and gentoo is also pretty up2date... other than ghc, I wouldn't really install a lot of haskell packages via a package manager anyway
11:02:58 <Gurkenglas> mint isn't recommended? What else should I take?
11:03:08 <kadoban> Gurkenglas: Looks right. You might want to check if your virtual machine can do 64 bit or not.
11:03:18 <maerwald> because the haskell dependency constraints are so tight that it confuses a lot of package managers (including cabal)
11:03:38 <Gurkenglas> My... virtual machine. Isn't that going to be the virtual machine? Do I need to download some other software to run that file?
11:03:40 <kadoban> mint is easy to install. Gentoo is … ridiculous to install. I don't know about nixos, it sounded too weird for me to bother personally.
11:03:55 <Gurkenglas> My actual machine is using 64-bit, so that's what I picked
11:04:17 <kadoban> Gurkenglas: linux mint is just a linux distro. You need something to make it run in a virtual machine … I use virtualbox, I'm not sure if there's better out there. It works and is pretty simple.
11:05:01 <kadoban> maerwald: I do the same except I just go one step farther and avoid the GHC and cabal from the OS package manager too.
11:05:30 <Gurkenglas> https://gist.github.com/ion1/2815423 <- why not Haskell Platform?
11:05:37 <maerwald> kadoban: well, but compiling GHC yourself is not as trivial as letting the PM do that
11:06:00 <kadoban> maerwald: Who said compiling? You download the binaries and install them … it's really easy and quick.
11:06:06 <maerwald> uagh, no thanks
11:07:02 <kadoban> Gurkenglas: I think platform is only appropriate for beginners personally. It seems to break once you try to install anything that's not in platform, and I don't really understand what benefit it'd give me anyway in general.
11:07:16 <ion> Gurkenglas: To use a GHC version higher than what the Platform provides for one.
11:07:46 <geekosaur> no, it breaks if you try to instakll something that uses stackage as its platform
11:07:48 <nolrai2> Platform is a failed experiment. 
11:07:56 <nolrai2> To me. 
11:08:00 <geekosaur> because stackage does its own versioning, based on what yesod wants
11:08:04 <frerich> Gurkenglas: GWDG is usually much faster than FH Aachen.
11:08:31 <frerich> (unless your own pipe is the bottleneck, of course)
11:08:36 <kadoban> geekosaur: Possibly, but things that weren't even in stackage also caused this in the past (like hakyll before it was in stackage), that's what originally caused me to abandon platform.
11:08:46 <geekosaur> I haven't seen that
11:10:02 <geekosaur> I only see it when something turns out to want stackage, whether it's actually related to yesod or not
11:10:38 <maerwald> the problem with haskell is... it's almost impossible to use without cabal sandboxes... so if you want to use your package manager to install haskell stuff, you end up with unresolvable dependencies, unless your package manager has it's own way of sandboxes (e.g. nixos)
11:11:41 <maerwald> dependency constraints are just too tight
11:11:54 <kadoban> geekosaur: It's possible hakyll was kind of based on stackage deps anyway even before it was in. I know it required only a minimal change to get accepted. I don't really know though beyond that.
11:12:03 <geekosaur> except when they're not and you get a completely different kind of unsolvable failure
11:12:20 <Gurkenglas> Oh wait, I appear to already have virtualbox installed, and an Ubuntu image downloaded. Must have been months-years ago.
11:12:56 <maerwald> geekosaur: which is good, because it leads to bug reports
11:13:02 <geekosaur> but, apparently the community has decided that letting the whole ecosystem be driven by the web framework worked so well for ruby that we should emulate it
11:13:04 <kadoban> I wonder if the problem of dependencies will calm down once haskell libs become older and more stable … or if that should even be expected to happen.
11:13:20 <geekosaur> maerwald, the breakage happens when a new version of a package comes out and is incompatible and random downstream stuff breaks
11:13:24 <johnw> kadoban: systems of stability can be built atop Hackage
11:13:32 <geekosaur> and you have to add constraints to lock out the new version to make them build
11:13:40 <Welkin> geekosaur: yesod works fine as long as the whole world is in a sandbox
11:13:41 <johnw> for example, Nix makes this trivial, stackage addresses this, etc.
11:13:54 <geekosaur> these are only bugs in the sense that the upper version bound was left off --- which too many people are convinced is best practice
11:14:26 <Welkin> of course, with carefully crafted cabal.config constraints
11:14:30 <maerwald> geekosaur: you can stop developing distributions if everyone starts to go with upper version bounds just in case
11:14:37 <maerwald> we are lucky this is not standard in the C world yet
11:14:57 <geekosaur> never mind, the community wants to do this to itself
11:15:01 <johnw> I'd be interested in a tool that could run all night long, and would actually try building my package at every available dependency, to determine the widest set of bounds against current Hackage
11:15:02 <maerwald> the problem is rather that haskell has almost no ABI compatibility
11:15:26 <maerwald> s/compatibility/stability/
11:15:49 <geekosaur> and isn't going to get it unless ghc retools to do whole-program compilation, because performance utterly tanks otherwise
11:16:21 <geekosaur> cross-module inlining is the current solution, but it effectively destroys ABI compatibility
11:16:32 <osa1> is ghc 7.8 not working with cabal 1.22?
11:16:37 <monochrom> not only cross-module. cross-library.
11:16:37 <geekosaur> because internals that shouldn't be part of the ABI are sucked into it
11:17:03 <monochrom> and you must inline, lest all your fusion rules are pointless
11:17:26 <Clint> the bigger problem is no sane api versioning
11:17:39 <geekosaur> osa1, it's working here?
11:17:40 <kadoban> osa1: I think it does. IIRC ghc-mod is broken with too-new cabal and ghc 7.8?
11:17:51 <osa1> I'm getting errors like "dist/dist-sandbox-bdb0520c/package.conf.inplace: inappropriate type"
11:24:54 <pgiarrusso> Hi all #haskell!
11:25:14 <pgiarrusso> I (as Blaisorblade) asked a question here: https://wiki.haskell.org/MonadPlus_reform_proposal
11:26:03 <pgiarrusso> That page claims to provide a (non-standard) instance of MonadPlus Maybe that satisfies Left Distribution.
11:26:23 <pgiarrusso> Heuristically, that sounds unexpected to me. Concretely, I added a counterexample.
11:26:37 <jTT_> has anyone installed the stable stack release yet?
11:27:06 <pgiarrusso> If anybody has any feedback on that, I’d love to hear it.
11:27:55 <nkaretnikov> jTT_: fwiw, there's #haskell-stack
11:28:06 <jTT_> ah cool, didnt know
11:33:56 * hackagebot amqp 0.12.3 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.12.3 (HolgerReinhardt)
11:39:05 <rhaps0dy> So, anyone tried to build ghc for android?
11:39:30 <rhaps0dy> (using the script in neurocyte/ghc-android)
11:42:37 <fr33domlover> hello
11:42:50 <dm> join #haskell.de
11:43:11 <rhaps0dy> hi
11:43:57 <fr33domlover> I have a class declaration "class C c where..." in which instances are supposed to have 2 type parameters, i.e. of the form: T a b
11:44:18 <fr33domlover> with DataKinds it looks like this: class C (c :: * -> (* -> *)) where
11:44:32 <fr33domlover> is there a way to require that the (* -> *) is Monad?
11:45:01 <fr33domlover> the other way seems to be using "Monad m =>" in all the class method types
11:45:41 <gamegoblin> Does anyone here know Pipes and Pipes.Parse ?
11:45:41 <fr33domlover> actually: class C (c :: * -> (* -> *) -> *) where 
11:50:00 <rhaps0dy> fr33domlover: you can't use Monad m => in the class?
11:50:04 <rhaps0dy> use it in the methods maybe?
11:50:16 <fr33domlover> rhaps0dy, http://paste.rel4tion.org/6
11:50:20 <rhaps0dy> I'm a bit noob but
11:50:24 <fr33domlover> is that the right/best way?
11:50:28 <rhaps0dy> yeah exactly
11:50:32 <rhaps0dy> uuh
11:50:32 <fr33domlover> I'm a beginner too :P
11:50:38 <fr33domlover> wondering if there's a better way
11:50:46 <fr33domlover> maybe using kind signatures or whatever
11:50:56 <rhaps0dy> try Monad m => class ActionManager a m ?
11:51:07 <rhaps0dy> idk if that would work
11:51:10 <fr33domlover> no, that's a different thing
11:51:15 <fr33domlover> it doesn't mean the same
11:51:20 <rhaps0dy> i see
11:51:27 <rhaps0dy> yeah, I think how you have it is fine
11:51:28 <fr33domlover> (ties to a speific monad rather than be parametric on monad type)
11:51:35 <rhaps0dy> wait
11:51:53 <rhaps0dy> ah, of course, you want the actual instances to not be tied to specific monads
11:52:21 <rhaps0dy> yeah, I think you already got it
11:53:14 <fr33domlover> The Monad m => thing is standard, but I wonder if there is a better trick
11:53:21 <fr33domlover> just curious
11:56:21 <notOnIRC> status
11:56:56 <notOnIRC> sorry I typed into the input box, instead of the terminal. :/
11:57:19 <Fuuzetsu> must have been tricked by your own name
11:57:39 <notOnIRC> Fuuzetsu: 'tis a curse I must bear
11:57:49 <maerwald> notOnIRC: this only happens to irssi users and very frequently
11:58:54 <lyxia> fr33domlover: a s m never changes, why not make a multiparameter class, ActionManager b m, where this b takes the place of what was previously "a s m"
12:01:30 <lyxia> fr33domlover: Monad m => ActionManager b s m
12:01:53 <simon> is there a convenient way to populate a database using generators?
12:02:50 <fr33domlover> lyxia, thanks. That would generally tie the instance to specific s and m (which isn't strictly always the only option) but in this case I think it is
12:03:40 <simon> turns out I can just use QuickCheck. http://chromaticleaves.com/posts/generate-user-data-quickcheck.html
12:04:11 <lyxia> fr33domlover: Uh, it wouldn't though. You can use fundeps so that s and m depend on b, but then b can be something of the form a s m that leaves s and m abstract in the instance declaration.
12:04:22 <shapr> Cale: seen any good one hour introductions to Haskell?
12:04:34 <shapr> Cale: I've signed up for such a thing and I'm looking for good structures
12:04:51 <lyxia> fr33domlover: You can write: instance ActionManager (A s m) s m
12:06:35 <fr33domlover> lyxia, this is becoming too complicated for my basic understanding of types :P
12:06:45 <fr33domlover> I'll make things less abstract first
12:06:49 <srhb> Good idea!
12:06:53 <fr33domlover> and generalize when it's needed
12:06:58 <srhb> This type class seems like a thing you'll probably not ever need.
12:07:53 <fr33domlover> srhb, I'm writing a single instance of it, which is probably what you'd use in 99% of the cases... just wanted to make the API separate from implementation
12:08:13 <fr33domlover> (since some apps may want to specialize it for their needs)
12:09:21 <srhb> Okay. I still have no idea what you're doing and I think it sounds vaguely wrong-ish, but do come back when you have the instance and we can perhaps figure out exactly what might be a nice fit. :-)
12:10:11 <srhb> (ie. implementation abstraction would require a to be a phantom parameter in your current version, which sounds kind of inverted)
12:10:19 <srhb> Anyway, nevermind. :-)
12:14:55 <nkaretnikov> I'm not very familiar with distributed/cloud-haskell, but is there anything similar but for monitoring local processes, like fsnotify can be used to monitor the fs?
12:16:17 <srhb> nkaretnikov: What do you mean _monitoring_ ?
12:16:27 <nkaretnikov> poll for certain events
12:16:31 <srhb> nkaretnikov: Passing information between threads is easy using various MVars, TVars, etc.
12:18:56 <amyers> nkaretnikov, Do you mean something like https://github.com/schell/steeloverseer ?
12:19:33 <Gurkenglas> From earlier discussion, I take it that I shouldn't install Haskell Platform if I want to use packages not already on there. What tutorial should I use to install it on a Ubuntu 14.04 vm?
12:19:51 <rofer> How come Double isn't an instance of Bounded? It's not arbitrary precision so it has a minimum and maximum, right?
12:20:08 <nkaretnikov> srhb: I'm aware, but I've only used them for simple problems where the output is what gets stored inside an mvar.  right now, however, I'm dealing with a program that writes to a database.  I want to check the database only when the program has already written to it.  could mvars etc. help here?
12:20:27 <nkaretnikov> amyers: let me see
12:20:35 <srhb> nkaretnikov: Sure, when a thread writes to the database you pop something into the MVar
12:20:54 <srhb> nkaretnikov: The other thread is waiting for the MVar to fill.
12:21:24 <nkaretnikov> srhb: but I have two separate executables
12:21:28 <srhb> nkaretnikov: Ah!
12:21:31 <nkaretnikov> an actual program and a test suite
12:21:47 <srhb> nkaretnikov: Sorry, I completely mistranslated processes to threads in my head.
12:21:50 <nkaretnikov> amyers: okay, it looks similar to fsnotify, but that's not what I want
12:22:37 <srhb> nkaretnikov: Any standard IPC solution should probably work here.
12:27:28 <nkaretnikov> srhb: do you have a concrete suggestion?  (I need it to be cross-platform.)  using an intermediate file (via fsnotify) seems to be the best way I can think of
12:28:50 <srhb> nkaretnikov: Well, if you are okay with external dependencies, there are all those fancy IPC libraries like zeromq and whatnot
12:29:08 <geekosaur> fsnotify already endangers cross platform...
12:29:20 <nkaretnikov> it's just for a test, so I'd rather keep it simple
12:29:37 <tdammers> plain network sockets then?
12:29:41 <nkaretnikov> geekosaur: it supports bsds, linux-based systems, and win, no?
12:29:54 <geekosaur> "supports"
12:30:01 <geekosaur> each of them has its own corner cases that work poorly
12:30:08 <srhb> Yeah, cereal and sockets perhaps.
12:30:31 <nkaretnikov> okay, I'll read up on that
12:30:34 <nkaretnikov> thanks all
12:32:26 <hexagoxel> Gurkenglas: possibly https://github.com/bitemyapp/learnhaskell/blob/master/install.md
12:32:45 <fr33domlover> lyxia, I figured things out a bit
12:33:28 <fr33domlover> hmm or not... hold on XD
12:33:31 <fr33domlover> sorry
12:33:59 <kqr> is there a library function compatible with System.Random to shuffle a list?
12:34:03 <geekosaur> I recall pointing Gurkenglas at minghc earlier... and it should include a fairly recent prebuilt network package, because building network is one of the biggest pains in the Windows world
12:34:23 <geekosaur> (arguably minghc was *developed* to avoid people having to build network themselves)
12:34:35 <kqr> hm, random-shuffle might do it
12:35:08 <Gurkenglas> For Windows? Sure, why not, I'll download that in parallel. I don't recall the earlier pointing
12:44:27 <Peaker> I am thinking of a Binary alternative for simple types, that uses type-classes to guarantee a type is unboxed (like UArray), and then uses unsafeCoerce from strict ByteStrings. Any reason this idea is silly before I try? :)
12:44:46 <Peaker> Binary.get is slllow! In C it is often O(0) (a cast!)
12:45:28 <dolio> UArray and ByteString have very different internal formats.
12:45:41 <Peaker> perhaps Storable is quite close to what I need
12:45:58 <Peaker> dolio: I meant the same technique as UArray
12:46:49 <Fernandos> Why does hlint say that Lambdas are bad? ie. Avoid Lambda found use (+) instead..
12:47:01 <c_wraith> Fernandos: it only says they're bad when they're redundant.
12:47:08 <maerwald> Fernandos: it's just random. keep using them if it makes your code more readable
12:47:12 <Peaker> Fernandos: probably means avoiding eta-expansions?  \x -> f x    replace with: f        or: \x y -> x + y    replace with  (+)
12:47:32 <Peaker> (+) is likely more readable than any alternative code that is equivalent
12:47:41 <Fernandos> Peaker: I have this: mean xs = foldr (\x y -> x + y) 0 xs / genericLength xs
12:47:44 <maerwald> a lot of suggestions from hlint are just nonsensical, you can turn them off afair
12:48:20 <dolio> Or turn off hlint. Better idea. :)
12:48:22 <Peaker> Fernandos: (\x y -> x + y) is indeed equivalent to (+). and btw: foldr with a (typically-)strict operation like (+) is a bad idea
12:48:25 <xplat> foldr (+) 0 xs
12:48:28 <Peaker> hlint is awesome :)
12:48:30 <maerwald> dolio: mh, some of them are still useful
12:48:56 <maerwald> e.g. it sometimes tells me "why did you not use foldr" or something like that
12:48:59 <maerwald> it happens sometimes
12:49:13 <Peaker> Uniformity is great, hlint helps with uniformity
12:49:33 <Fernandos> Peaker: I tried that, but then it said. (+) found, use sum instead..
12:49:42 <monochrom> no, uniformity is not great. unless it is my uniformity.
12:49:43 <maerwald> I like diversity, but also consistency
12:49:58 <Peaker> Fernandos: Yes, because "sum" does your loop :)
12:50:00 <ronh-> Fernandos that is another good suggestion. see, hlint works :)
12:50:03 <Fernandos> that's why I was confused.. I thought I'm in an infinite optimization  loop :D
12:50:05 <monochrom> and there lies the problem. hlint is someone else's uniformity, not mine.
12:50:06 <maerwald> hlint is just very unflexible
12:50:11 <maerwald> exactly
12:50:27 <Peaker> non-uniformity is worse than most specific uniformities, even bad ones
12:50:38 <Fernandos> Because sum somehow didn't make sense to me (probably didn't get the hint)
12:50:58 <Peaker> I prefer my uniformity over ndm's uniformity, but ndm's uniformity over non-uniformity
12:51:03 <monochrom> mean xs = sum xs / genericLength xs
12:51:52 <Fernandos> ok I have this and it stopped complaining :P mean xs = sum xs / genericLength xs
12:53:08 <Fernandos> and that's equivalent to: mean xs = foldr (\x y -> x + y) 0 xs / genericLength xs ??
12:53:26 <srhb> Fernandos: More like foldl'
12:53:28 <srhb> But yes
12:53:59 * hackagebot nixfromnpm 0.1.0.7 - Generate nix expressions from npm packages.  http://hackage.haskell.org/package/nixfromnpm-0.1.0.7 (thinkpad20)
12:54:55 <maerwald> also, running hlint with "-i 'Eta reduce'"
12:55:32 <saep> mean = uncurry (/) . foldl' (\(acc, len) x -> (x+acc, len+1)) (0,0)
12:55:38 <maerwald> oh god
12:56:27 <srhb> saep: Needs more strictness.
12:57:48 <sm> hlint is completely customizable, no ?
12:57:52 <saep> Oh right, but it still only needs 1 traversal at least.
12:58:23 <srhb> Yes :)
12:58:35 <kqr> oh shoot, random-shuffle was last updated 2009
12:58:39 <kqr> and cabal doesn't seem to want to know about it
12:58:42 <maerwald> sm: I only found the --ignore switch for customization, but not something like defining your own set of rules
12:58:55 <kqr> is there really no library that implements a list shuffle method compatible with System.Random?
13:00:21 <maerwald> sm: but it says you can pass --with=HINT, but I don't really understand what that is supposed to mean
13:01:06 <srhb> kqr: It works fine, cabal unpack it and just remove the constraint on base
13:01:36 <kqr> srhb, would I need to do that on every installation?
13:01:52 <srhb> kqr: You can pack it up and reuse it.
13:01:53 <kqr> like, every separate computer
13:02:15 <bergmark> kqr: did you see https://hackage.haskell.org/package/random-shuffle ?
13:02:17 <kqr> not sure what unpack it means
13:02:24 <kqr> bergmark, that's the one that's old as the mountain
13:02:37 <Gurkenglas> Do I have to deinstall things before installing minghc?
13:03:03 <bergmark> kqr: is it broken? it compiles at least http://matrix.hackage.haskell.org/package/random-shuffle
13:03:05 <Peaker> Fernandos: https://hackage.haskell.org/package/foldl is meant to let you compose left-folds nicely while still iterating the input stream only once, to avoid leaking memory
13:03:38 <Peaker> Fernandos: http://conal.net/blog/posts/more-beautiful-fold-zipping is a nice blog post by conal explaining composable left-folds
13:03:38 <kqr> bergmark, for me cabal-install complains that "cabal: At least the following dependencies are missing: random-shuffle -any"
13:04:04 <kqr> what the
13:04:13 <kqr> but if I install with "cabal install random-shuffle" it works
13:04:17 <kqr> just not if I have it in my cabal file?
13:04:27 <Fernandos> hahah that error sounds funny sorry :) I had to fight a lot with cabal too..
13:04:46 <kqr> ohh
13:04:50 <kqr> I'm stupid
13:04:52 <kqr> incredibly stupid
13:04:53 <srhb> kqr: Oh right, it says base < 5, not base < 4.5 :P
13:05:02 <kqr> I forgot to cabal install --only-dependencies
13:05:06 <kqr> of course the dependency was missing
13:06:10 <srhb> kqr: Shouldn't that be autofetched in the install step after cabal configure?
13:06:31 <srhb> kqr: --only-dependencies just means ONLY dependencies, not also your program.
13:07:19 <srhb> So I don't think you're being stupid :-)
13:07:36 <Fernandos> now I'm using this snippet: cd $(mktemp -d -t cabal-XXXX); cabal sandbox init && cabal install --disable-documentation --disable-library-profiling --disable-shared --disable-executable-dynamic --bindir="$HOME/.cabal/bin" --datadir="$HOME/.cabal/share" -allow-newer <package-name-here>
13:07:59 <Arcaed0x> Hi there guys 
13:09:09 <hexagoxel> Fernandos: that looks like https://github.com/quchen/cabal-install-bin/blob/master/cabal-install-bin
13:09:47 <Arcaed0x> Is there any way to define the type for the (==) function ? To take who different types?
13:10:32 <kadoban> Arcaed0x: No, but you can define your own operator that's kinda like (==) if you want.
13:10:33 <Peaker> Arcaed0x: what would that mean?
13:10:43 <Fernandos> hexagoxel: it is that script I only added -allow-newer and summed it up.. didn't remember the url of the script
13:10:52 <Peaker> Arcaed0x: return False if the types aren't the same, and then use (==) if they are?
13:10:55 <kqr> srhb, i'm not running cabal install, i'm running cabal build :)
13:11:03 <srhb> kqr: Ah!
13:11:05 <lpaste_> tdammers pasted “cabal error” at http://lpaste.net/135063
13:11:12 <Peaker> @type \x y -> maybe False (== y) (cast x)
13:11:13 <lambdabot> (Eq a, Typeable a, Typeable a1) => a1 -> a -> Bool
13:11:15 <kqr> srhb, so I can safely maintain my stupidity
13:11:17 <tdammers> ^ anyone familiar with this one?
13:11:22 <Arcaed0x> It would me it looks like an equality sign , but then it would take two types and compare them 
13:11:27 <srhb> kqr: :-)
13:11:44 <Arcaed0x> The general only takes two types that are the same 
13:11:48 <Peaker> Arcaed0x: compare types? at the value level? can you give the type signature of the function you want?
13:12:06 <tdammers> basically I'm trying to use cabal-test-quickcheck with the detailed-0.9 test interface
13:12:14 <Arcaed0x> When I tried that it said to use instanceSigs 
13:12:29 <taksuyu> Is there some way to check for the existence of a function for a test?
13:12:56 <Arcaed0x> I tried that and it still gave me errors so in the end I just defined a (===) function
13:13:00 <srhb> taksuyu: Functions just exist. if you try to use a function that doesn't exist, your program does not compile.
13:13:17 <Arcaed0x> Well within a type class , thats as close as I can get 
13:13:36 <taksuyu> So there is no way to check if a module is exporting a function in a test?
13:13:45 <srhb> taksuyu: Oh, like that.
13:14:13 <srhb> taksuyu: Well, all the test woould have to do is import the function. :-)
13:15:15 <srhb> You don't gain much from that though, might as well just add it to the module export list and let the compiler catch it there already.
13:15:17 <BurningCa007> How hard is it to troll #haskell?
13:15:23 <srhb> BurningCa007: Pretty easy!
13:15:29 <BurningCa007> https://gist.github.com/quchen/5280339
13:15:32 <BurningCa007> This person failed
13:15:35 <crough> BurningCa0: I only use Scala because it's way more practical... how did I get here?
13:15:35 <tdammers> ooooh, looks like I need to force Cabal to >=1.22
13:15:56 <BurningCa007> I'm mostly from a C++ background atm
13:16:04 <BurningCa007> What are these tales of monads?
13:16:13 <BurningCa007> like nomads in the ocean of time?
13:16:28 <quchen> BurningCa007: It happened many times that someone tried to troll Haskell people only to spawn a serious discussion about something. Like recently, when someone was bashing away at laziness.
13:16:57 <crough> BurningCa0: Pht, Haskell isn't even WebScale. Node is where it's at!
13:17:09 <quchen> BurningCa007: Don't take that as an invitation to try it yourself though. We still prefer a serious serious discussion over an accidentially serious discussion.
13:17:19 <srhb> BurningCa007: The "you could have invented monads" tutorial is pretty good for figuring out what they are. :) But generally, it's probably easier to speak of specific monads.
13:17:21 <BurningCa007> I'm not the troll you're looking for
13:17:34 <BurningCa007> sorry to disappoint quchen
13:18:43 <shinka> I have a type with three fields(say: a, b, c) and I want to support Ord by looking first at a, then if the fields a are equal look at b, and if bs are equal look at c. I can do: MyType a0 b0 c0 `compare MyType a1 b1 c1 = case a0 `compare` a1 of LT -> LT; GT -> GT; EQ -> case b0 `compare` b1 of LT -> LT; GT -> GT; EQ -> c0 `compare` c1. I was just wondering if there was a shorter way to express this.
13:19:36 <kadoban> shinka: You could convert into a tuple and compare those?
13:19:42 <arkeet> (a0 `compare` a1) <> (b0 `compare` b1) <> etc
13:19:52 <lifter> Why is there no entry for (:) in Hoogle
13:20:02 <shinka> Alright: I'm looking at the <> operator. Thanks!
13:20:11 <arkeet> <> is just mappend
13:20:17 <arkeet> the Monoid instance for Ordering is handy.
13:20:21 <lifter> or Hayoo
13:20:24 <hexagoxel> wouldn't `deriving Ord` give you that instance automagically?
13:20:32 <arkeet> it would.
13:20:44 <ski> shinka : see Cale's <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx>
13:21:01 <quchen> lifter: Probably because it's not defined in a library
13:21:13 <quchen> lifter: Lists are a bit special syntactically
13:21:15 <shinka> Thank you all, I'll take a look at it!
13:21:22 <lifter> quchen: ah ok
13:21:53 <quchen> lifter: Conceptually, we have  data [a] = []  |  (:) a [a]
13:22:11 <ski> shinka : you should be able to write something like  compare = comparing aPart <> comparing bPart <> comparing cPart  assuming `aPart',`bPart',`cPart' are functions that select the appropriate fields
13:22:31 <Peaker> quchen: why did you sugar the LHS but not the RHS ?
13:22:52 <Peaker> data [] a = [] | (:) a ([] a)      or:    data [a] = [] | a : [a]
13:23:04 <quchen> Because he asked about (:) specifically and I felt like that should be part of the answer.
13:23:10 <Peaker> ah
13:23:23 <ski> shinka : e.g., if you define `data MyType = MkMyType {aPart :: A,bPart :: B,cPart :: C}', you'll get these automatically
13:23:24 <broma0> Anyone familiar with the vte library or any other terminal ui libraries?
13:23:39 <srhb> broma0: I've used vty-ui before.
13:24:05 <breadmonster> Hello.
13:24:11 <srhb> Hm, not sure that's actually the same category.
13:24:25 <ski> shinka : i would say Cale's trick is an exact fit for your problem
13:24:38 <breadmonster> Is there a Haskell package for low level socket manipulation?
13:24:50 <broma0> srhb, I'm going to make a little nano clone and I want to make sure I use a nice, clean library
13:24:57 <broma0> Any comments on it?
13:24:59 <maerwald> @hoogle socket
13:24:59 <lambdabot> Network.Socket socket :: Family -> SocketType -> ProtocolNumber -> IO Socket
13:24:59 <lambdabot> package socket-activation
13:24:59 <lambdabot> package socket-io
13:25:02 <srhb> broma0: vty-ui is pure Haskell, afair.
13:25:06 <srhb> broma0: So there's that :)
13:25:13 <Fernandos> broma0: cool project
13:25:36 <breadmonster> maerwald: Hmm. I'm trying to implement FTP, any tips?
13:26:00 <maerwald> breadmonster: nope, never done that before
13:26:01 <maerwald> @hackage socket
13:26:01 <lambdabot> http://hackage.haskell.org/package/socket
13:26:14 <broma0> srhb: nuff said
13:26:15 <srhb> broma0: It also comes with this rather excellent manual: http://jtdaugherty.github.io/vty-ui/manuals/vty-ui-users-manual-1.9.pdf
13:26:21 <broma0> That's the only one I found
13:26:31 <srhb> And is just generally awesome to use.
13:26:36 <broma0> Awesome!
13:26:46 <srhb> I should get paid for this commercial. :-)
13:26:58 <broma0> Fernandos, thank you!
13:27:21 <broma0> srhb I'll add you to the credits
13:27:31 <broma0> :D
13:27:38 <srhb> Hehe. Better the vty-ui authors! 
13:27:40 <Fernandos> broma0: will the keybindings be the same?
13:28:18 <lpeterse> breadmonster: If you decide to use socket, don't hesitate to get in touch. I released it quite recently and there might be things missing.
13:28:18 <srhb> I actually made a similar small project with vty-ui, but mostly for exploring buffers-as-zippers
13:28:54 <broma0> Fernandos, it'll be an option,  but not the default. I want to create a key binding language similar to vim
13:28:59 <breadmonster> lpeterse: Will do.
13:30:39 <Fernandos> broma0: if you add compatibility to atom.io or sublimetext packages it could really become popular :)
13:32:17 <Peaker> Zippers as cursors kinda suck if you don't need the persistence features.. Less flexible than a mutable structure with reference-based-cursors into it
13:32:33 <Fernandos> but I believe cloning nano will be hard enough already^^ I think it'll be hard regardless if you use external packages or not
13:32:48 <Peaker> Cloning nano sounds like a couple days' work? :)
13:33:10 <broma0> Fernandos, that'd be totally cool.. I'd like to expose buffer contents to scripts written in any language for extensability.. write custom commands in haskell, bash, python, ruby.. anything
13:33:19 <srhb> Peaker: That was basically my conclusion as well. That's when I shelved it. :-)
13:33:23 <srhb> Peaker: Still, a learning experience.
13:33:35 <broma0> No worries guys I'll finish it tonight
13:33:40 <broma0> Ha.
13:33:47 <srhb> broma0: :-)
13:33:47 <crough> Contribute to `yi`?
13:34:01 <Peaker> implementing stuff is almost always a learning experience. Even when you think you have it all figured out and it wouldn't be a learning experience
13:34:26 <Fernandos> broma0: keep us updated :) maybe you could post your progress to hn or reddit (if you are serious and aren't afraid of/enjoy "peer pressure")
13:36:30 <broma0> Fernandos, I really should do that. I'm not one to advertise or otherwise call attention to myself but maybe this time it'd be a good idea
13:51:11 <joco42> hamishmack: In Leksah, If I open a cabal package that uses libraries installed into a shared sandbox then how can I include those libraries into the metadata indexed by Leksah? 
13:53:33 <joco42> hamishmack: the situation looks like this : http://snag.gy/Zhcel.jpg
13:54:58 <joco42> hamishmack: In the picture I would like to look up the definition of 'mainWidget' which is in the reflex-dom library which is installed into a sandbox (because it cannot be installed globally due to cabal hell)
13:55:21 <tamasgal> is there a VI input mode option for ghci?
13:56:34 <tamasgal> sorry, got it ;) "editMode: Vi" in ~/.haskeline
13:57:33 <Jello_Raptor> is there a canonical type class for partial orderings that I should use somewhere? 
13:58:10 <Jello_Raptor> a quick search gives me a stack that are specific to particular maths libraries 
14:01:43 <Jello_Raptor> I prefer a maybe based formulation, but there's no obvious consensus when I look at hackage
14:05:36 <breadmonster> maerwald: I found a really simple socket package.
14:05:50 <breadmonster> Network.Socket.Simple
14:07:20 <maerwald> breadmonster: part of what package?
14:07:33 <breadmonster> maerwald: Sorry, got that wrong: Network.Simple.TCP
14:07:40 <breadmonster> network-simple
14:07:43 <breadmonster> It's fantastic.
14:08:00 <maerwald> then you probably mean Network.Simple.TCP?
14:08:39 <maerwald> ah right
14:09:24 <maerwald> no UDP support though :/
14:11:46 <breadmonster> maerwald: I'm trying to just get two PCs across a network to send a file to each other.
14:12:05 <breadmonster> If I use this package do I have to worry about implementing most of TCP myself?
14:12:42 <Fuuzetsu> why would you have to
14:13:25 <maerwald> you have send and recv
14:13:59 <maerwald> but what kind of protocol you use on top of that is obviously up to you
14:14:32 <Fuuzetsu> with conduit you can probably have client-server to send files in few lines…
14:14:58 <maerwald> breadmonster: I'd assume the point is exactly that: writing your own protocol?
14:15:09 <breadmonster> Awesome.
14:15:09 <maerwald> you wanted to do ftp?
14:15:13 <P4Titan> Hello all, could someone help me with some cabal work? I try to do cabal install --only-dependencies and it says there are unresolved dependencies: base==4.6.0.1/installed-8aa..., detexify-hs-backend => base>=4.7 && <4.8. I cleared the ~/.ghc and ~/.cabal dirs, reinstalled cabal, but still it is not working
14:15:22 <breadmonster> maerwald: No, I just need to get files from one end to the other.
14:15:26 <breadmonster> I thought FTP was the best.
14:15:31 <maerwald> ah, well, then there are easier alternatives yeah
14:15:37 <Fuuzetsu> P4Titan: you need newer GHC
14:15:45 <geekosaur> P4Titan, a version dependency on base is really a dependency on a ghc version
14:15:48 <geekosaur> your ghc is too old
14:16:09 <P4Titan> Really, I did an update on my system and it did not updated ghc
14:16:25 <ion> breadmonster: You specifically want to DIY instead of using a tool that exists already?
14:16:28 <srhb> P4Titan: Probably package maintainers being lazy. :)
14:16:31 <P4Titan> I am running 14.04 ubuntu
14:16:31 <Fuuzetsu> solving up is up to whatever distro/package manager you're running
14:16:33 <maerwald> @hackage ftphs
14:16:33 <lambdabot> http://hackage.haskell.org/package/ftphs
14:16:39 <Fuuzetsu> solving that is up to*
14:16:41 <maerwald> breadmonster: did you look at that?
14:16:50 <geekosaur> ubuntu will not update its ghc until a new ubuntu release
14:16:54 <breadmonster> ion: It's my friend's college assignment, I told him I could do it in fewer lines in Haskell than Python.
14:17:05 <geekosaur> if you are lucky then you may be able to find a PPA with a newer ghc for your Ubuntu release
14:17:08 <P4Titan> Should I do a manuall update then?
14:17:15 <P4Titan> yeah
14:17:17 <Fuuzetsu> breadmonster: well how many lines does he have and what exactly does it need to do
14:17:46 <kadoban> P4Titan: https://github.com/bitemyapp/learnhaskell/blob/master/install.md <-- ppa instructions, or I just install manually yeah.
14:17:59 <breadmonster> geekosaur: https://launchpad.net/~hvr/+archive/ubuntu/ghc
14:18:00 <maerwald> @hackage sendfile
14:18:00 <lambdabot> http://hackage.haskell.org/package/sendfile
14:18:11 <maerwald> @hoogle Network.Socket.SendFile
14:18:11 <lambdabot> package sendfile
14:18:11 <lambdabot> package simple-sendfile
14:18:28 <P4Titan> kadoban: Ill look into that
14:18:44 <breadmonster> maerwald: yeah, I'm trying to implement it myself. He said open a socket and figure that stuff out yourself.
14:18:51 <breadmonster> But I guess lazy IO takes care of that for me?
14:19:55 <MarcelineVQ> sockets are p. simple in standard python, really really simple
14:20:06 <Fuuzetsu> they are simple in Haskell too…
14:20:09 <breadmonster> geekosaur: There's a PPA for all Ubuntu releases.
14:20:14 <Fuuzetsu> it really depends what he actually wants to do
14:20:14 <breadmonster> Courtesy of hvr 
14:20:21 <MarcelineVQ> you could do it all in a very minimal ammount of lines but readbility suffers, so​idk if lione count is the best method
14:20:22 <Fuuzetsu> opening socket and writing bits to it is simple…
14:20:29 <breadmonster> Fuuzetsu: I know, it's entirely nonspecific.
14:20:35 <geekosaur> breadmonster, point that at P4Titan (or vice versa)
14:21:12 <Fuuzetsu> breadmonster: then just do that, there's 0 point to us trying to guess something you don't even know yourself
14:21:12 <kadoban> (hvr's is indirectly what I already linked to)
14:21:14 <breadmonster> Fuuzetsu: One second, let me show you the homework specification.
14:21:22 <Fuuzetsu> k
14:22:01 <MarcelineVQ> http://stackoverflow.com/questions/27241804/sending-a-file-over-tcp-sockets-in-python can be tuned to like, 4 lines
14:22:34 <MarcelineVQ> but they're wordy
14:23:10 <breadmonster> Fuuzetsu: http://www-users.cselabs.umn.edu/classes/Spring-2015/csci4211/files/CSCI%204211%20Spring%202015%20Programming%20Project.pdf
14:23:12 <Welkin> just use scp
14:23:13 <Welkin> done
14:23:49 <maerwald> wonder if there are rosettacode examples for sending files
14:24:01 <ion> Welkin: rsync > scp mostly
14:24:02 * hackagebot foma 0.1.1.0 - Simple Haskell bindings for Foma.  http://hackage.haskell.org/package/foma-0.1.1.0 (joom)
14:24:04 <breadmonster> Fuuzetsu: It's entirely nonspecific, I could just set up a Yesod instance and finish it, but that seems like cheating.
14:24:08 <breadmonster> Welkin: scp?
14:24:15 <Jello_Raptor> > pf. func f g a b = fmap f $ g a b
14:24:17 <lambdabot>  <hint>:1:18: parse error on input ‘=’
14:24:33 <Jello_Raptor> > pf. (\ f g a b -> fmap f $ g a b)
14:24:34 <lambdabot>      Not in scope: ‘pf’
14:24:34 <lambdabot>      Perhaps you meant one of these:
14:24:34 <lambdabot>        ‘pi’ (imported from Prelude),
14:24:41 <ski> @pointless func f g a b = fmap f $ g a b
14:24:41 <lambdabot> func = (.) . (.) . fmap
14:24:41 <srhb> breadmonster: Yesod? That's not really a good fit.
14:24:46 <MarcelineVQ> oh this needs to support what ftp does, like file lists and such
14:24:52 <Jello_Raptor> ski: thank you 
14:24:58 <Fuuzetsu> breadmonster: that does not look like many lines
14:25:01 <Jello_Raptor> ski: also that's a lot worse <_<
14:25:02 <srhb> breadmonster: This is a bit of high level network, a bit of State monad, a bit of Reader monad, some IO, some attoparsec.
14:25:09 <srhb> breadmonster: But fun project :)
14:25:14 <Fuuzetsu> MarcelineVQ: where? I only see upload and download commands
14:25:15 <Fuuzetsu> and login
14:25:25 <MarcelineVQ> Commands you must support
14:25:25 <MarcelineVQ> For the client:
14:25:25 <MarcelineVQ> 1) 
14:25:25 <MarcelineVQ> upload
14:25:25 <MarcelineVQ> : to upload a file 
14:25:25 <MarcelineVQ> to
14:25:27 <MarcelineVQ> the server. 
14:25:29 <MarcelineVQ> 2) 
14:25:31 <MarcelineVQ> download
14:25:31 <ski> Jello_Raptor : clearly `func f g = (fmap f .) . g'
14:25:32 <Fuuzetsu> woah there
14:25:33 <MarcelineVQ> : to download a file 
14:25:35 <MarcelineVQ> from
14:25:37 <MarcelineVQ> the server. 
14:25:39 <MarcelineVQ> 3) 
14:25:42 <ski> @pointless func_f_g a b = fmap f $ g a b
14:25:42 <lambdabot> func_f_g = (fmap f .) . g
14:25:43 <MarcelineVQ> list
14:25:45 <MarcelineVQ> : to display file lists in its 
14:25:45 <srhb> ;| pdf copy pastes to IRC...
14:25:47 <MarcelineVQ> own 
14:25:49 <MarcelineVQ> designated directory. 
14:25:51 <MarcelineVQ> 4) 
14:25:53 <MarcelineVQ> quit
14:25:55 <MarcelineVQ> : to terminate the client.
14:25:57 <MarcelineVQ> jesus
14:25:57 <Fuuzetsu> …
14:25:59 <MarcelineVQ> sorry
14:26:01 <MarcelineVQ> idk why my client added all those \n
14:26:05 <Fuuzetsu> it's OK I see it now
14:26:11 <srhb> :P
14:26:13 <Fuuzetsu> file listing should be solid extra 3 lines at worst
14:26:28 <breadmonster> @hoogle dir
14:26:28 <lambdabot> Text.XHtml.Transitional dir :: Html -> Html
14:26:28 <lambdabot> package direct-binary-files
14:26:28 <lambdabot> package direct-daemonize
14:26:58 <Fuuzetsu> @hoogle FilePath -> IO [String]
14:26:58 <lambdabot> System.Directory findExecutables :: String -> IO [FilePath]
14:26:58 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
14:26:58 <lambdabot> System.Directory findFiles :: [FilePath] -> String -> IO [FilePath]
14:28:01 <breadmonster> Yeah, there we have it.
14:28:07 <breadmonster> So that's like three lines.
14:28:14 <breadmonster> And quitting is another three lines.
14:28:14 <maerwald> dat golfing :P
14:28:42 <breadmonster> Hmm, the only difficult part would involve dicing up the files to write to IO.
14:28:53 <breadmonster> *write to socket
14:28:59 <Fuuzetsu> use network-conduit and friends
14:29:00 <breadmonster> Or maybe Conduit can help there.
14:29:00 <gashole> Do Haskell apps have to be compiled with the -dynamic ghc-option under Mac OS X?
14:29:30 <Fuuzetsu> oh, network-conduit is deprecated, I forgot
14:29:38 <Fuuzetsu> conduit-extra
14:29:47 <breadmonster> srhb: What is the attoparsec bit for?
14:30:09 <srhb> breadmonster: Just parsing commands nicely. It's not really necessary (can be done with just words, it looks like)
14:30:23 <breadmonster> Yeah, I can parse by hand.
14:30:40 <srhb> Usually not as nice as using attoparsec. :-)
14:31:07 <breadmonster> Hmm, sure.
14:31:17 <breadmonster> Fuuzetsu: So does this seems like a day's project?
14:31:44 <Fuuzetsu> if you know what you're doing then few hours tops
14:31:48 <maerwald> breadmonster: if you write your own protocol on top of it yes
14:31:49 <Fuuzetsu> if you don't then a bit longer
14:32:09 <breadmonster> Fuuzetsu: Yeah, I'm entirely new to programming/CS.
14:32:19 <Fuuzetsu> better get started then
14:32:27 <breadmonster> Yup, Haskell is my first programming language.
14:32:36 <maerwald> amazing :D
14:32:36 <MarcelineVQ> That's an advantage imo
14:32:48 <MarcelineVQ> You don't have to unlearn imperative crutches
14:33:02 <maerwald> breadmonster: most of the time people are harassed with stuff like java when they start
14:33:18 <breadmonster> MarcelineVQ: It's unfortunate, but a lot of protocols are designed for people with imperative crutches.
14:33:28 <breadmonster> I tried to read CLRS, but it's a real bitch.
14:33:38 <breadmonster> Then someone told me about Okasaki, it's a fantastic book.
14:33:45 <Fuuzetsu> the protocol is pretty much outlined for you
14:34:13 <maerwald> breadmonster: not only protocols... pseudo-code in general for random things including cryptography, computational geometry and whatnot. imperative style programming is still the biggest culture
14:34:58 <breadmonster> Fuuzetsu: So let me just get this straight. Open socket, authenticate, read file as lazy ByteString, write to socket, close?
14:35:13 <breadmonster> maerwald: That's true, it's really annoying.
14:35:34 <breadmonster> I can't figure out how to implement AES for instance in Haskell, that's something that's entirely imperative code for security reasons.
14:36:19 <Fuuzetsu> look up some conduit network tutorials
14:36:42 <breadmonster> Fuuzetsu: I was thinking of using this network-simple
14:37:21 <maerwald> breadmonster: check http://cryptol.net/ and http://www.cryptol.net/files/ProgrammingCryptol.pdf
14:37:27 <Fuuzetsu> whatever floats your boat
14:37:37 <maerwald> for the AES thing
14:37:40 <breadmonster> Fuuzetsu: Alright, thanks!
14:37:51 <breadmonster> maerwald: Cool, will have a look.
14:38:02 <Fuuzetsu> you might find https://github.com/Fuuzetsu/bathroute-server/tree/master/src useful though it's not a pinnacle of good design and pretty out of date by now
14:38:17 <MarcelineVQ> missed oppertunity, crypto pdf link should ask for a password :>
14:39:15 <breadmonster> Fuuzetsu: Awesome.
14:39:54 <ffjacob> Hi. I've been looking for a good (numerically efficient) library to implement physics-style algorithms that involve a lot of vector manipulation (in a linear algebra context). I found Data.Vector a bit clunky, and it lacks Num instances for Vector addition and similar things. Does anyone know a good library for this?
14:40:24 <Fuuzetsu> hmatrix/linear perhaps
14:40:29 <breadmonster> ffjacob: There is no Num instance for vectors.
14:40:49 <Jello_Raptor> huh, how do i specify the type for an infix operator? "(:=:) :: a -> a -> Bool"  doesn't work :. 
14:40:53 <breadmonster> ffjacob: Num only has instances for numeric types. Also, try Data.Vector.Unboxed?
14:40:55 <ffjacob> That's what I mean, it lacks Num instances and other thing that would be idiomatic for linear algebra.
14:41:03 <arkeet> Jello_Raptor: (:=:) is a constructor
14:41:38 <monochrom> try (?=?) instead
14:41:51 <ion> Jello_Raptor: Your non-constructor functions can’t begin with a capital letter and your operators can’t begin with a colon.
14:42:03 <arkeet> colon is a "capital symbol" sort of.
14:42:05 <ffjacob> breadmonster: Ideally I would like to do things like (1,1,2) + (1,1,1) = (2,2,3) and so on. 
14:42:10 <Jello_Raptor> huh
14:42:22 <arkeet> ffjacob: for low-dimensional stuff (up to 4) linear is fine.
14:43:06 <breadmonster> ffjacob: Oh this was an issue I had too when I started with Haskell, + is an operator that can't be overloaded like in C++.
14:43:31 <arkeet> like
14:43:37 <arkeet> just for multiplying matrices and whatnot.
14:43:41 <breadmonster> ffjacob: The only way to overload + is by declaring a Num instance, which means your type should also support all the other numeric operations.
14:43:57 <arkeet> for bigger matrices or for doing more advanced stuff hmatrix is good.
14:44:17 <breadmonster> arkeet: Interesting question, can I have type level functions that take data values?
14:44:20 <ion> FWIW, there’s an instance for tuples like that in a package named NumSomething but that won’t get you matrix multiplication etc.
14:44:42 <breadmonster> arkeet: like in C++, there's something like template < typename T, int N, int M >
14:44:52 <jle`> ffjacob: the linear package has a lot of idiomatic things for vector addition, linear transformations, matrix manipulation, etc.
14:45:03 <arkeet> breadmonster: probably DataKinds for that.
14:45:30 <jle`> it also has an interface that essentially wraps it around a Data.Vector vector, but with all of the linear transformation/addition etc. stuff
14:45:40 <jle`> and matrix multiplication etc.
14:45:49 <ffjacob> jle`: Thanks! I'll check it out
14:46:02 <arkeet> I don't think linear is particularly optimized for performance.
14:46:04 <jle`> so it offers the same interface for both glorified strict tuples, and also a newtype wrapper over Data.Vector vectors which does all the same things
14:46:39 <jle`> i think it's worth checking out for the smooth interface...it may or may not end up being a bottleneck later
14:46:44 <arkeet> it's a nice interface yes
14:46:46 <jle`> granted all of its matrix stuff is written as vector-of-vector math
14:47:18 <jle`> and its newtype wrapper of Data.Vector vectors is of boxed vectors i think...
14:47:45 <jle`> the way the typeclasses work though it'd be hard to overload the interface for unboxed vectors i guess
14:49:05 <ffjacob> arkeet: You mention it's best suited for low dimensional stuff. Is that only due to efficiency? Which data structure would you recommend for implementing something like a Nelder-Mead minization that's vector heavy and usually applied to functions of many variables?
14:49:16 <jle`> if you want performance, your best bet is to write your own wrapper over Data.Vector.Unboxed and write the interface yourself nicely
14:49:57 <jle`> but i'd recommend putting off optimization and things for things that you can show to be bottlenecks
14:50:44 <arkeet> ffjacob: if you even want to solve linear systems I don't think linear is the way to go.
14:51:30 <arkeet> I'm not familiar with that algorithm
14:51:51 <arkeet> there's also repa for high-performance array stuff I guess.
14:51:53 <gfixler> hSetBuffering and hSetEcho seem to work well when run through ghci, but not through runhaskell
14:52:08 <arkeet> ffjacob: you may also be interested in #numerical-haskell channel
14:52:22 <gfixler> e.g. hSetBuffering stdin NoBuffering, and later hSetBuffering stdin LineBuffering
14:52:35 <gfixler> when I run through runhaskell, it seems to mess up the state of the terminal
14:52:40 <gfixler> leaves buffering and echoing
14:52:58 <gfixler> I'm undoing the changes when quitting out, but they don't take
14:53:08 <ffjacob> Is it fine to post stackoverflow links here? I have provided more details in a question there
14:53:41 <hodapp> Okay, just encountered .x and .y files in a Haskell build and they appear to just be Haskell files at first glance...
14:53:46 <hodapp> is that any kind of normal convention?
14:54:02 * hackagebot hnix 0.2.0 - Haskell implementation of the Nix language  http://hackage.haskell.org/package/hnix-0.2.0 (JohnWiegley)
14:55:08 <hodapp> Lexer.x just says "Lexer.hs is generated!" in comments...
14:56:59 <Zemyla> Is there a lazy, potentially infinite structure with O(1) cons and O(log n) lookup?
14:58:03 <hodapp> ...nevermind. The .x appears to be a file for Alex.
14:58:57 <johnw> Zemyla: Data.Sequence?
14:59:03 * hackagebot yesod-text-markdown 0.1.8 - Yesod support for Text.Markdown.  http://hackage.haskell.org/package/yesod-text-markdown-0.1.8 (ArashRouhani)
14:59:04 <arkeet> that's not potentially infinite
14:59:19 <johnw> ah, I see
14:59:24 <johnw> so, you could build this structure
14:59:26 <Zemyla> johnw: That's neither lazy nor potentially infinite.
14:59:34 <johnw> have two lists, one representing the first half that you cons onto to cons
14:59:40 <johnw> and one representing the second half, that you cons onto to snoc
14:59:44 <arkeet> I think lazy is necessary for potentially infinite.
14:59:55 <Zemyla> That doesn't give O(log n) lookup.
14:59:56 <johnw> though I wonder if that's infinite even...
14:59:59 <arkeet> what's half of an infinite list?
15:00:03 <johnw> oh right, the O(log n)
15:00:08 <johnw> hmm
15:00:32 <johnw> does O(log n) have to be for the worst case?
15:01:55 <johnw> arkeet: i guess half of the infinite list is good enough, since in that case you'll simply never reach your snoc'd elements
15:02:05 <arkeet> I don't know what half of an infinite list is.
15:02:33 <johnw> if I snoc 0 onto ([1..], []), it's effectively 1.. for as long as I'm willing to use it
15:02:49 <arkeet> no one asked for snoc though
15:02:55 <johnw> he wanted O(1) snoc
15:02:59 <arkeet> no, he wanted O(1) cons
15:03:06 <johnw> ah, I misread that completely
15:03:08 <arkeet> heh
15:03:33 <Zemyla> If cons isn't O(1), then it becomes useless on a potentially infinite structure.
15:04:06 <monochrom> I think the question is full of XY problems. for example, why commit to the word "cons" (as opposed to the more general, flexible "add" or "insert") when you don't even know what the data structure will look like at the end?
15:04:29 <arkeet> I think cons makes sense for any Foldable structure.
15:04:48 <arkeet> as long as it satisfies foldMap f (cons x y) = f x <> foldMap f y
15:05:47 <Zemyla> Yeah, and having cons means you can create the structure with foldr cons empty.
15:05:48 <johnw> Zemyla: any data structure you come up, you can present it as a function and get O(1) cons easily; the question is how you store what is cons'd so that lookup is O(log n).  For example, perhaps you could have a Data.Map  which contains elements for every "known" vaule, but defers to a computation for the "infinite" values.  This isn't too general anymore, though, as it means distinguishing the finite from the infinite parts of the data
15:06:51 <monochrom> if you use a binary search tree but procastinate insertions, then you're shifting the cost to lookups
15:07:10 <johnw> true
15:07:27 <monochrom> on the bright side, you can now claim "amortized O(1) insert, amortized O(log n) lookup", just because of technicalities
15:07:57 <johnw> we could also use threading to allow O(1) cons in one thread, while optimizing later lookups, so after a sufficient pause it's back to O(log n)
15:08:15 <Zemyla> Actually, what I want isn't quite O(log n) lookup, it's O(log n) drop.
15:09:01 <johnw> ok, I bow out when clients change requirements mid-design :)
15:09:05 <Zemyla> But you can probably fake that by keeping the structure and current index.
15:09:08 <Zemyla> Sorry.
15:09:21 <arkeet> can it have O(huge) lookup?
15:09:29 <Zemyla> Basically, I want to implement this https://www.fpcomplete.com/user/edwardk/heap-of-successes but more efficiently.
15:09:37 <monochrom> does it have "lookup" anymore?
15:10:01 <edwardk> Zemyla: what are you looking for?
15:10:04 * edwardk tunes in
15:10:16 <Zemyla> arkeet: lookup n tr = fmap fst $ uncons $ drop n tr. So O(log n) drop means O(log n) lookup.
15:10:27 <arkeet> oh, now we have to have uncons.
15:10:38 <edwardk> log n drop, and what do you need for construction operations?
15:10:49 <Zemyla> O(1) cons, and that's it.
15:10:55 <Zemyla> Ack, brb.
15:11:02 <edwardk> O(1) cons, O(log n) drop is easy
15:11:05 <edwardk> i wrote that years ago
15:11:13 <arkeet> but also apparently we want it to be potentially infinite.
15:11:32 <monochrom> Data.Sequence says O(1) append, O(1) prepend, O(log(min(i, n-i))) drop i
15:11:43 <edwardk> Zemyla: https://www.fpcomplete.com/user/edwardk/online-lca gives a scheme for log time drop
15:12:06 <edwardk> and can be constructed infinite, but you need to know its infinite when you build to do so productively
15:12:14 <edwardk> (you can drop from an infinite source though)
15:18:48 <sinelaw> edwardk, do you know of a fast alternative to binary for stuff that would just be a pointer cast? e.g. DiffTime which is really a Pico which is just a pointer cast away 
15:19:06 <sinelaw> serialization is a major bottleneck in our application
15:19:16 <breadmonster> sinelaw: What are you ding?
15:19:33 <sinelaw> storing stuff in leveldb
15:19:53 <sinelaw> in the future it may some other db, doesn't matter much, we'll still need to serialize
15:21:40 <edwardk> sinelaw: "coerce"? =)
15:23:04 <ski> (johnw : suspected cut off near "..  This isn't too general anymore, though, as it means distinguishing the finite from the infinite parts of the data" ?)
15:28:11 <Zemyla> Actually, I think I figured out what I need.
15:30:49 <Zemyla> The operations I actually need are:
15:31:49 <Zemyla> fromList :: [a] -> DropList a. It should return a WHNF value in O(1) time.
15:32:08 <Zemyla> uncons :: DropList a -> Maybe (a, DropList a). O(1) time.
15:32:53 <k1i> anyone know what the present status of nikita volkov's record implementation is?
15:33:29 <srhb> k1i: Usable, nice? What are you looking for?
15:33:35 <Jello_Raptor> hmm, shouldn't functional dependancies and multi-class typeclasses allow me to have some implicit type parameters for a typeclass? I mean, say you have "class Foo a b | a -> b" shouldn't I be able to have a "class Foo a b => Bar a where fizz :: a -> b" ? instead of needing to have a "class Foo a b => Bar a b where fizz :: a -> b" ? 
15:33:55 <k1i> srhb: it's no longer a library it should seem?
15:34:04 <Zemyla> drop :: Int -> DropList a -> DropList a. It should operate in O(log n) time if the first n elements of the DropList have already been evaluated, and should be O(n) if not. (Subsequent drops on that section should be O(log n).)
15:34:15 <srhb> k1i: Are you talking about the possible GHC extension?
15:34:16 <Zemyla> Basically, all I want is to memoize drops.
15:34:24 <srhb> k1i: If so I don't think there's been any progress there recently.
15:34:35 <k1i> srhb: yes, i'd like to use it, in whatever capacity is most convenient
15:34:43 <srhb> k1i: Well, the library then.
15:34:48 <k1i> seems like the record package was re-used
15:34:51 <k1i> for some preprocessor support
15:36:19 <srhb> k1i: Yes, record-preprocessor depends on it.
15:36:51 <srhb> k1i: Or hm, actually not directly.
15:37:02 <srhb> k1i: But I guess you get a hs file afterwards that depends on it.
15:38:20 <k1i> srhb: i found version 0.3.1.2 to be the quasiquoter
15:38:36 <srhb> k1i: Well they are differently named
15:38:57 <srhb> k1i: record-preprocessor is an executable
15:41:24 <k1i> is it common for people to use their own prelude
15:41:48 <srhb> k1i: In some form or another, yes. Probably not with NoImplicitPrelude though
15:43:39 <dominik> anyone knows about how modify the SrcSpanInfo of a Module parsed with haskell-src-exts?
15:44:14 <dominik> I basically want to parse a haskell module and remove the imports that it does not use.
15:45:01 <dominik> but if I just remove those imports and then try to use exactP to print out the modified module in the same way it was parsed, the SrcSpan's are not the same anymore and thus exactP fails with an exception.
15:45:18 <dominik> anyone knows how to tackle this scenario with haskell-src-exts?
15:45:47 <dominik> basically I need to know how to account for changes that I do in the parsed module to also be reflected in the SrcSpanInfo.
15:50:39 <cj3kim> hi
15:50:51 <cj3kim> what is (.) used for in haskell?
15:51:24 <cj3kim> i'm doing a practice question that told me to possibly use that symbol in conjunction with drop, take, read, words, unwords
15:51:51 <arkeet> :t (.)
15:51:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:52:22 <cj3kim> I don't understand
15:52:30 <arkeet> it is function composition.
15:52:36 <Pastaf> ^ In other words, it takes a function that takes returns b and pipes the output into a function that takes a
15:53:01 <arkeet> :t isLower
15:53:03 <lambdabot> Char -> Bool
15:53:03 <Pastaf> erm, ignore the first takes.
15:53:04 <arkeet> :t chr
15:53:05 <lambdabot> Int -> Char
15:53:07 <arkeet> :t isLower . chr
15:53:08 <lambdabot> Int -> Bool
15:53:18 <arkeet> > (isLower . chr) 97
15:53:19 <lambdabot>  True
15:53:26 <arkeet> (chr 97 = 'a')
15:53:46 <arkeet> (f . g) x = f (g x)
15:53:56 <cj3kim> ah, thank you
15:56:12 <cj3kim> arkeet: why not simply type f (g x)? seems simpler
15:56:23 <arkeet> sometimes you don't want to mention x.
15:56:48 <arkeet> > map (isLower . chr) [65,97]
15:56:49 <lambdabot>  [False,True]
15:57:15 <arkeet> is more concise than
15:57:19 <k1i> pointfree notation
15:57:19 <arkeet> map (\x -> isLower (chr x)) 
15:57:20 <k1i> ?
15:58:11 <cj3kim> ah, i see
15:58:16 <cj3kim> arkeet: thank you
15:59:53 <cj3kim> arkeet: it seems that my ghci does not have access to isLower and chr. I probably have to import it from a core library?
16:00:02 <arkeet> those are from Data.Char
16:00:24 <arkeet> (you can find this out using hoogle)
16:00:33 <cj3kim> If this is the case, is it possible to preload GHCI with preferred libraries on initialization?
16:00:45 <FireFly> k1i: yeah, this style is known as pointfree or pointless or tacit
16:00:46 <arkeet> yes, you can put stuff like "import Data.Char" in your ghci.conf
16:00:53 <cj3kim> ah, coo!
16:01:07 <FireFly> "notation" seems like a bit of a misnomer to me, though.. I mean, it's not separate in any way
16:01:15 <k1i> style ;)
16:01:17 <arkeet> more like style
16:01:18 <arkeet> :)
16:01:20 <FireFly> better
16:01:59 <FireFly> I kinda like the "tacit" terminology that the APL family uses.. but on the other hand, one can't do the "pointless" pun with that
16:08:35 <Gurkenglas> Pastaf, also substitute a b for the last a
16:12:30 <magneticDuck> it's seriously uncanny
16:12:42 <magneticDuck> I've been writing a big program in haskell
16:12:46 <magneticDuck> and I have not had a single runtime error
16:12:52 <magneticDuck> like, zero bugs
16:13:00 <magneticDuck> I guess that's a sign I'm doing something right
16:14:13 <pacak> magneticDuck: Then your program is not big enough :)
16:14:19 <magneticDuck> well when I say big
16:14:25 <magneticDuck> I mean like uh 300 lines xD
16:14:29 <magneticDuck> I've just started
16:14:45 <pacak> Or you are not using any  tricks to speed it up.
16:14:50 <Gurkenglas> Can I see an lpaste?
16:15:07 <magneticDuck> but, having been doing work in other languages, I've realised how well designed haskell is
16:15:08 <Pastaf> ah yes, performance hacks, the best way to break code
16:15:15 <magneticDuck> haskell is conductive to some really good design patterns
16:15:28 <magneticDuck> the kind of design patterns that make things testable, coherent, maintainable
16:15:34 <magneticDuck> the opposite of goto statements
16:16:32 <Pastaf> I think purity alone is quite signifigant, but with Haskell that's just the beginning.
16:18:14 <magneticDuck> my code isn't even that good
16:18:17 <johnw> purity means that types really say something; I think one reason dynamic typing got such a huge following is that a world of programmers suddenly realized that all their work pleasing the type checker didn't amount to much
16:18:38 <magneticDuck> but the kind of structure that I just make by default means my code says exactly what it is
16:18:46 <magneticDuck> instead of a sequence of steps that hopefully add up to it
16:18:47 <johnw> in Haskell, the type checker is your colleague, not an arbitrary task master
16:18:55 <magneticDuck> yeah
16:19:10 <Pastaf> johnw: That's why I went to Lisp, which was the stepping stone to Haskell for me
16:19:35 <kgee> Pure functional programming (and haskell, as my preferred realization of such) is teaching me how to divide my data from my behaviour. I've still got a lot to learn, but I've been appreciating that there is something fundamentally problematic about other more typical programming styles
16:20:14 <rdesfo> hello, is it possible get nix-shell to work with haste-compiler? I keep getting 'error: ‘f’ at /tmp/shell.nix:7:7 called without required argument ‘ghc-simple’...'
16:21:12 <srhb> kgee: Getting smarter feels.. Smart. :D
16:21:21 <srhb> rdesfo: You may want to try in #nixos if you haven't already.
16:21:29 <Pastaf> in the end though, I wish I'd never found Haskell, as so much is written in other languages which I now find to be absolutely awful when I thought they were pretty good before.
16:21:40 <johnw> kgee: yes, Haskell certainly favors separating meaning (denotational semantics) from behavior (operational semantics); free monads take this further by abstracting representation (ASTs) from evaluation (algebras).  It's the perfect language for constructing and thinking about DSLs.
16:21:43 <srhb> rdesfo: But it sounds like the derivation requires an argument that you're not feeding it.
16:22:22 <rdesfo> srhb: ok thanks
16:23:09 <kgee> I think if I tried a language that offered 'optional functional paradigms' (and I have... Lua, Javascript, Java 8, and others) then my bad habits would creep in and I'd miss the point.
16:23:33 <Pastaf> Java and the C family of languages to me are now like a mountain of dead bodies, which I want to avoid at all costs, but the issue is that everyone else is there...
16:24:19 <johnw> kgee: you might enjoy https://queue.acm.org/detail.cfm?id=2611829
16:25:16 <kgee> As it stands though, I've been working on compiling ABNF shorthand into various language dialects. A lot of APIs and network protocols use rigid ABNF. So making an ABNF parser to convert ABNF text into a parser that can turn (for example) http packets into a runtime datastructure you can query...
16:25:18 <kgee> that's powerful
16:26:22 <kgee> johnw, interesting. I'll have a look
16:29:27 <kgee> I think it would be interesting to be able to "compile" an RFC document and know with the greatest mathematical certainty possible that the code that comes out adheres to the spec. https://tools.ietf.org/html/rfc5234#section-4
16:29:44 <kgee> Haskell is probably a good candidate for transforming formal grammar to executable code
16:30:38 <kgee> I've been using lua lpeg as a crutch to help me along, but peg grammars and CFG grammars are not equal
16:30:51 <kgee> I have to transform the corner cases of one into the other
16:34:12 <johnw> kgee: if you really want that, you might be interested in Coq or Agda, depending on your performance needs for the final production
16:36:11 <johnw> but there is a system for Coq called Fiat being worked on, that would give you the best of both worlds: a proven conforming implementation, with the speed of hand-optimized code (this is the promise)
16:37:21 <kgee> johnw, It's a thought experiment so far. The code is only a way for me to realize the next obstacle. I'll take a look into Coq, though. It's worth a look, yet I fear that platforms even more esoteric than haskell are far too niche for my purposes.
16:39:10 <johnw> well, it's pretty much exactly that
16:39:18 <johnw> both esoteric AND niche, in one go
16:39:39 <johnw> but http://www.cis.upenn.edu/~bcpierce/sf/current/index.html is a supremely good introduction to it, which is worth working through on its own right
16:42:16 <kgee> johnw, Interesting. I was actually using the homework for the haskell course upenn offered free online as an intro to the subject. I didn't get far before getting derailed into a good book on AI as well as diving into formal grammars, but I intend to finish week 3 soon!
16:45:36 <k1i> noob here - lenses into complex newtype-restricted structures?
16:45:44 <k1i> doable?
16:48:06 <johnw> k1i: can you give more context?
16:48:19 <Cale> k1i: Can you write a function a -> b which extracts the value, and a function b -> a -> a which replaces it? Then yes, it's doable.
16:49:34 <shachaf> I wish everyone used type-changing lenses.
16:49:42 <shachaf> They're so much easier.
16:51:04 <magneticDuck> oh yeah, I used lenses once!
16:51:06 <magneticDuck> they were fun
16:52:10 <Cale> shachaf: What kind of remark is that? :)
16:52:33 --- mode: Cale set -o Cale
16:52:39 <Cale> Do you actually think so?
16:54:10 <shachaf> Cale: I actually think so.
16:54:27 <shachaf> (s -> a, s -> b -> t) is much easier than (s -> a, s -> a -> s)
16:55:00 <shachaf> For the usual "more polymorphism makes it easier to do the right thing" reasons.
16:56:08 <shachaf> set :: Lens' s a -> a -> s -> s; set l _ x = x -- this is a contrived example where the types don't help you
16:56:17 <Cale> Maybe once you get to implementing functions which act on lenses. I'm not sure I see how it helps all that much with writing the lens in the first place.
16:56:35 <shachaf> Well, it also makes it possible to write lenses which you couldn't otherwise write.
16:56:37 <Zemyla> shachaf: Kind of like how, instead of defining a type on a -> a and not having a Functor instance, define a type on a -> b and make it a Profunctor?
17:08:16 <Zemyla> I really wish there was a newtype wrapper for ReadS.
17:10:41 <bitemyapp> Zemyla: I keep telling people that my newtype-all-the-things fascism is almost always worth it but nobody listens :)
17:11:14 <bitemyapp> best exception I'm aware of is stuff like the aliases in streaming libraries or in the various libraries for lenses.
17:11:23 <Zemyla> bitemyapp: I mean, if you have to work with ReadS anyway, you should at least be able to have it carry around the state automatically.
17:21:38 <Zemyla> bitemyapp: Do you think the monad and applicative instances for the ReadS wrapper newtype should be lazy or strict?
17:23:00 <bitemyapp> Zemyla: I don't think I'm qualified to have an opinion on this. This is a Cale/Ed question.
17:23:17 * bitemyapp <--- above his paygrade
17:23:31 <Luke> bitemyapp: any word on why cabal doesn't support extra-include-dirs in the cabal file?
17:23:33 <Zemyla> Well, I think they'd probably say to use a real parser, like Parsec or Attoparsec or even ReadP, instead of ReadS.
17:23:39 <Luke> bitemyapp: thanks for the comment on github btw
17:23:40 <bitemyapp> Luke: I saw your GH issue.
17:23:48 <bitemyapp> Luke: np
17:23:56 <bitemyapp> Luke: why? Oversight probably, but that's a guess.
17:24:02 <bitemyapp> Zemyla: it's not a serialization format.
17:24:10 <bitemyapp> Zemyla: it's just a human presentation/input thing.
17:24:33 <Zemyla> Well, ReadP was specifically designed to be a replacement for ReadS.
17:28:13 <ttt_fff> how does one represent environments (think a shceme interpreter) in haskell ?
17:28:43 <bitemyapp> ttt_fff: which part of the environment?
17:28:53 <ttt_fff> so env = list(string, var)
17:28:54 <bitemyapp> ttt_fff: I've seen naive implementations use a Data.Map
17:28:57 <ttt_fff> but the var has to refer to the env so there's a cycle
17:29:04 <ttt_fff> okay, env = Map String Binding
17:29:09 <ttt_fff> but the Binding might refer to the Env
17:29:14 <bitemyapp> ttt_fff: then to handle it in the interpreter, they'd use a Reader of a product type that contains general information including the map of bindings.
17:29:43 <ttt_fff> hang on, I don't see the conection between Env and ReaderMOnad
17:29:53 <ttt_fff> well I guess I see it if you're 'interpreting' something inside an Env
17:29:59 <ttt_fff> okay, so the Reader state is the Env
17:32:30 <bitemyapp> Reader is just a convenient way to "carry" it around.
17:32:37 <bitemyapp> nothing special, just mentioning in case it would help you.
17:34:08 * hackagebot pipe-enumerator 0.3.0.0 - A bidirectional bridge between pipes and iteratees  http://hackage.haskell.org/package/pipe-enumerator-0.3.0.0 (patrykz)
17:50:38 <julie-ai> Anyone happen to know how to change the output destination for Lucius files in Yesod?
18:05:30 <ezrios> is it possible to have a partially applied type constructor as an associated data type for a type family?
18:11:56 <byorgey> ezrios: assuming you mean an associated type family as opposed to an associated data family, yes, that should be possible.  Are you having trouble getting it to work?
18:14:32 <ttt_fff_> what is the distinction of lex vs parse? especially if I'm writing a shceme interpreter?
18:14:35 <ttt_fff_> is lexing + parsing just a single stage ?
18:14:43 <ttt_fff_> (as for relatedness to haskell, host langauge = haskell)
18:15:56 <slack1256> ttt_fff_: I don't know, but I've heard saying that with parser combinators people usually do both at the same time
18:16:03 <ttt_fff_> yeah
18:16:05 <ttt_fff_> I'm sing parsec
18:16:07 <ttt_fff_> *using*
18:16:10 <slack1256> not that is a good practice though
18:16:20 <ttt_fff_> using parsec, it's a very 'natural' approach
18:16:23 <ttt_fff_> parsing is too fun
18:16:26 <ttt_fff_> parsing is not supposed to be fun
18:16:33 <ttt_fff_> it's supposed to be lexing and yaccing and cursing
18:17:38 <Enigmagic> don't forget about alex and happy :p
18:19:02 <pacak> ttt_fff: Putting try all over the place?
18:19:10 * hackagebot neet 0.2.0.0 - A NEAT library for Haskell  http://hackage.haskell.org/package/neet-0.2.0.0 (hijiri)
18:19:11 <pacak> It's not that fun :)
18:19:16 <ttt_fff_> no, I rarely use 'try'
18:19:22 <ttt_fff_> though I do use <|> which uses try
18:19:29 <ttt_fff_> but generally, reading first char alows me to commit
18:19:35 <slack1256> or using attoparsec
18:21:11 <kadoban> <|> doesn't implicitly use try, at least in parsec
18:23:43 <slack1256> So it tries the first alternative until it fails and the rest is used on the second alternative?. I got a problem thinking where that would be useful...
18:24:06 <slack1256> seems easier to implement though
18:26:01 <kadoban> slack1256: I don't believe so. in   p <|> q  it tries q only if p fails without consuming any input, which is slightly different. The docs say it does that for efficiency and something about good error messages, though I'm not entirely certain what the error message bit is about.
18:27:53 <DNoved1> The error message is for, if say p consumes "forall", then fails on "." (expecting an identifier), then q goes on to try "lambda", but fails because the next thing is "forall"...
18:28:08 <DNoved1> Then you'll get an error message saying "expected forall or lambda"
18:28:24 <DNoved1> When the real error is that you failed to match against an identifier.
18:28:29 <ski> Jello_Raptor : hm. arguably that could work, afaics. you may want to investigate "associated types" as an alternative
18:29:12 <DNoved1> Backtracking in general leads to bad error messages though.
18:29:44 * ski would prefer a static way of taking care of the optimization opportunities
18:29:54 <slack1256> Oh right Parsec seems to put more emphasis on good error messages than Attoparsec
18:50:45 <funfunctor> Hi
18:51:24 <funfunctor> How do I export a type-alias from a module? type PostCode = Int   has PostCode(..) in the export but that does not seem to work?
18:53:08 <orzo_> funfunctor: you don't need the (..)
18:53:19 <orzo_> does it work without?
18:54:01 <slack1256> (..) is for "Export all constructors". Type synonism don't have them
18:54:26 <slack1256> *synonyms
18:54:30 <funfunctor> so just PostCode should work?
18:54:40 <slack1256> Try it ;-)
18:55:37 <funfunctor> I already did of course.. It didn't
18:57:10 <funfunctor> ah I understand the error now..
18:59:11 * hackagebot lentil 0.1.2.0 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.2.0 (fffaaa)
18:59:48 <slack1256> funfunctor: http://lpaste.net/135080
18:59:49 <slack1256>  
18:59:57 <slack1256> Seems to work
19:03:05 <saml_> [1, 2, 3] => [1, 2, 3, 1, 2, 3, 1, 2, 3, ...]  how do i do this?
19:03:13 <saml_> repeat
19:03:22 <slack1256> :t cycle
19:03:23 <saml_> > repeat [1, 2, 3]
19:03:24 <lambdabot> [a] -> [a]
19:03:24 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,...
19:03:44 <saml_> heheheh i see
19:03:46 <slack1256> > take 10 $ cycle [1,2]
19:03:48 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
19:04:01 <pacak> :t cycle
19:04:03 <lambdabot> [a] -> [a]
19:04:12 <pacak> > cycle [1,2,3]
19:04:13 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
19:05:01 <saml_> > let wow = cycle "car" in [take 3 wow, take 3 $ drop 1 wow, take 3 $ drop 2 wow]
19:05:02 <lambdabot>  ["car","arc","rca"]
19:05:13 <saml_> how can i write this better?
19:05:26 <slack1256> IIRC there was a permutation package
19:05:51 <saml_> given a string like "car",  output ["car", "arc", "rca"]
19:06:10 <slack1256> it let you say "what is the 5th permutation of this string" or "give me all of them"
19:06:30 <funfunctor> slack1256: the issue was something else not really directly related.. the type check message was slightly misleading thats all
19:06:45 <funfunctor> solved now
19:07:02 <slack1256> funfunctor: Oh, I see. Well glad you solved it
19:10:38 <Gurkenglas> > map (take 3) $ flip map [1..3] $ flip drop $ cycle "car"
19:10:39 <lambdabot>  ["arc","rca","car"]
19:10:45 <Gurkenglas> (saml_)
19:12:28 <saml_> > let f s = let n = length s in map (take n) $ flip map [1..n] $ flip drop $ cycle s in f "car"
19:12:30 <lambdabot>  ["arc","rca","car"]
19:13:49 <slack1256> @help
19:13:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:14:02 <pacak> > permutations "car"
19:14:03 <lambdabot>  ["car","acr","rac","arc","rca","cra"]
19:15:12 <slack1256> :info permutations
19:15:21 <slack1256> @info permutations
19:15:21 <lambdabot> permutations
19:15:26 <mniip> @src permutations
19:15:26 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:17:34 <Gurkenglas> > [take 3 $ drop i $ cycle "car" | i <- [1..3]] -- Maybe more readable
19:17:35 <lambdabot>  ["arc","rca","car"]
19:19:35 <lpaste_> funfunctor pasted “No title” at http://lpaste.net/135083
19:19:39 <Gurkenglas> I now realize that you might want [0..2] there instead.
19:19:52 <funfunctor> anyone much good with digestive functors can help me get the above to typecheck
19:20:20 <funfunctor> I realise I made a little bit of a mess of it
19:21:37 <capisce_> take 3 $ map (take 3) $ tails $ cycle "car"
19:22:27 <Gurkenglas> Of course! I was vaguely uneasy at being unable to use tails for this.
19:23:48 <MarcelineVQ> @i length
19:23:48 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
19:23:56 <MarcelineVQ> >:i length
19:24:11 <slack125`> @info length
19:24:11 <lambdabot> length
19:24:20 <slack125`> @info Prelude.length
19:24:20 <lambdabot> Prelude.length
19:24:25 <MarcelineVQ> lol lambdabot..
19:24:54 <Gurkenglas> @info sdojfghmsirugv
19:24:54 <lambdabot> sdojfghmsirugv
19:24:56 <MarcelineVQ> Anyway, remember you can use length "car" instead of solid numbers like 3 for your function
19:24:59 <Gurkenglas> @echo oruvhzeormz
19:24:59 <lambdabot> echo; msg:IrcMessage {ircMsgServer = "freenode", ircMsgLBName = "lambdabot", ircMsgPrefix = "Gurkenglas!Gurkenglas@dslb-188-103-074-033.188.103.pools.vodafone-ip.de", ircMsgCommand = "PRIVMSG", ircMsgParams = ["#haskell",":@echo oruvhzeormz"]} target:#haskell rest:"oruvhzeormz"
19:25:43 <albeit> Has anyone here specifically chosen a Set/Map over an IntSet/IntMap when dealing with Int's? Was it for performance reasons?
19:27:25 <Zemyla> Hmm, you know Text.Read.Lex, right?
19:28:02 <Zemyla> How it parses out Lexemes in the ReadP parser?
19:29:17 <Zemyla> I'm trying to write those combinators so that they work for any CharParser.
19:30:41 <Zemyla> And you would not believe how difficult it is when you can't rely on the parser being a monad, or on having any kind of left-biased <|>.
19:32:28 <jig123> How could I design this? I want a queue that keeps a portion in memory, and then overflows to disk durably 
19:33:14 <pacak> jig123: sql database
19:33:18 <slack125`> jig123: acid-state?
19:33:42 <jig123> pacak: sql database is too slow
19:34:30 <slack125`> sqlite maybe?
19:34:51 <pacak> jig123: It would be  faster than anything you can implement in reasonable time given that your data can't fit into memory.
19:38:16 <MarcelineVQ> By that do you mean that disk access writing is slow enough that it doesn't matter if accessing a db is a little slow?
19:40:30 <pacak> MarcelineVQ: I mean to make it work reliably and fast he will need to keep some kind of cache, in-memory indices to be able to insert into proper plaaces and so on. It's already implemented and ready to be used.
19:42:52 <jig123> I will need like 100000 writes/deletes per second
19:43:22 <jig123> so like 200k total ops, and will need room to grow
19:53:12 <arahael> I'm sure there are key/value databases that focus on performance.
20:04:34 <Zemyla> And it turns out I can't do it because I don't have a constructor for Numbers.
20:05:35 <Zemyla> Why isn't the Number constructor in Text.Read.Lex exported?
20:22:54 <atgnag__> Is there any good haskell compiler that's portable?
20:24:00 <Cale> atgnag__: How portable?
20:24:19 <atgnag__> Cale: NetBSD portable.
20:25:10 <Cale> hmm
20:25:41 <Cale> I know that GHC was ported to NetBSD in the past
20:25:55 <Cale> But it probably doesn't work at the moment
20:26:07 <Cale> (at least, the current versions)
20:26:10 <Zemyla> atgnag__: Most Haskell compilers are less than three pounds and will easily fit in a purse or backpack.
20:26:15 <atgnag__> Cale: It's a Tier 3 platform. https://ghc.haskell.org/trac/ghc/wiki/Platforms
20:26:20 <Zemyla> That's pretty portable.
20:26:51 <Cale> https://github.com/iquiw/ghc-NetBSD-patches
20:27:22 <Cale> Given that there's a ghc-7.10.1.NetBSD.patch, someone must be running current GHCs on NetBSD :)
20:28:52 <Cale> You'd really want to look for a binary package though
20:29:18 <Cale> http://hahakigi.net/ghc
20:29:19 <Cale> aha
20:29:39 <atgnag__> Now I need cabal.
20:30:08 <Cale> http://hackage.haskell.org/package/cabal-install-1.22.6.0/cabal-install-1.22.6.0.tar.gz
20:31:09 <atgnag__> Thanks.
20:54:47 <echo-area> Is there a survey of tools used by the community?  I learned nix a few days ago, but are there others?
20:55:21 <nolrai66> stack?
20:56:14 <echo-area> There's this page but it doesn't contain nix: https://wiki.haskell.org/Development_Libraries_and_Tools
20:56:30 <mniip> I'm reading TaPL chapter 22
20:56:54 <mniip> it implements unification by first generating constraints, then solving them
20:57:05 <echo-area> nolrai66: Was that an answer to my question?
20:57:08 <mniip> to get things right, this is /not/ what GHC does
20:57:11 <mniip> is it
21:03:41 <nolrai66> echo-area: yes.
21:04:33 <alisia> @undo do;e
21:04:34 <lambdabot> e
21:04:39 <echo-area> nolrai66: You mean this?  https://github.com/commercialhaskell/stack
21:04:39 <nolrai66> echo-area: nix is new, and not actually in haskell or anything.
21:04:49 <nolrai66> Yes.
21:04:58 <nolrai66> I use it. It is very useful so far.
21:05:31 <echo-area> Thanks, will check it out
21:09:15 * hackagebot lentil 0.1.2.1 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.2.1 (fffaaa)
21:16:18 <jle`> i found a neat usage for (Data.Function.&)
21:16:31 <dmj`> jle`: do tell
21:16:49 <jle`> when i'm testing code i can do main = do something 5; somethingelse 5; blah 5 / 5
21:17:18 <jle`> if i want to test out with different numbers i can make a global variable like n = 5 and just edit that at one place
21:17:26 <jle`> but with & i can do something like:
21:17:31 <jle`> main = 5 & \i -> do
21:17:34 <jle`>    something i; etc.
21:17:36 <jle`> idk
21:18:06 <Hafydd> That seems similar to "let i = 5 in do".
21:18:15 <jle`> it's sort of similar in this sense to flip runReader 5 $ do ...
21:18:20 <jle`> yeah but it looks nicer ^_________________^
21:18:34 <jle`> fsvo nicer
21:18:39 <jle`> cuter maybe :3
21:18:44 <dmj`> jle`: I like
21:19:11 <jle`> thank you
21:20:14 <shachaf> Or just "where i = 5" or "let i = 5 in"?
21:26:04 <DNoved1> mniip: I believe the basis of GHC's type checker is hindley-millner still, so it should, at its core, do that.
21:26:29 <DNoved1> Might have changed though, given all the type extensions ghc has gotten.
21:29:16 * hackagebot wai-routes 0.7.1 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.7.1 (AnupamJain)
21:33:19 <hamishmack> joco42: That is on the issue list https://github.com/leksah/leksah/issues/76
21:34:16 * hackagebot lentil 0.1.2.2 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.2.2 (fffaaa)
21:37:30 <george_p> hi. how can I modify a value pointed to by Ptr?
21:37:40 <george_p> at ix index
21:38:58 <Cale> :t Foreign.Storable.poke
21:38:59 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> a -> IO ()
21:39:02 <Cale> ^^ george_p 
21:39:16 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/Foreign-Storable.html#t:Storable
21:44:37 <george_p> thanks
21:59:17 * hackagebot lentil 0.1.2.3 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.2.3 (fffaaa)
22:20:27 <neuroserpens> Any improvement suggestions on this code? http://pastie.org/10255912
22:22:18 <pacak> neuroserpens: replace sum with foldl' (+) 0
22:22:18 <kadoban> neuroserpens: Your definition of fib is /quite/ poorly performing. That's the exponential solution. Do you see why?
22:22:40 <pacak> neuroserpens: replace fibs 
22:22:59 <pacak> neuroserpens: You can keep "main = print $" part.
22:24:47 <neuroserpens> kadoban: nope
22:25:22 <pacak> > fix $ (1:) . scanl (+) 1
22:25:24 <Haskellfant> neuroserpens: say you were calculating fib 5, that then calculates fib 4 & fib 3, however calculating fib 4 requires recaluting fib 3 again
22:25:24 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:25:47 <neuroserpens> pacak: holy crap
22:25:56 <neuroserpens> :t fix
22:25:57 <lambdabot> (a -> a) -> a
22:26:20 <neuroserpens> I had never heard of a fix function. I'll read about it. Thanks.
22:26:56 <pacak> > let fibs = 1:1:zipWith (+) fibs (tails fibs) in fibs
22:26:56 <neuroserpens> Haskellfant: Do you mean I could use some sort of cache?
22:26:57 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ [a1]
22:26:57 <lambdabot>      Expected type: [a1]
22:26:57 <lambdabot>        Actual type: [[a1]]
22:26:59 <Haskellfant> neuroserpens: it can be a bit confusing at first. this article helped me a back when I was learning about it http://www.vex.net/~trebla/haskell/fix.xhtml
22:27:24 <kadoban> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs -- neuroserpens
22:27:25 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
22:27:48 <kadoban> That's a version that's maybe easier to understand, though it uses different primitives ^
22:27:52 <Haskellfant> neuroserpens: you could, put there are easier solutions. what you are currently doing is building fib up from top to bottom. if you build it up from the bottom you won't recalculate everything multiple times
22:28:24 <Haskellfant> well you'll still recalculate it for every call to fib, but for calculating fib 5 you won't recalculate fib 4 more than once
22:28:27 <neuroserpens> Haskellfant: Hmm.
22:28:37 <pacak> s/tails/tail/ :(
22:29:10 <kadoban> neuroserpens: Also it's minor but in terms of style, list comprehensions seems slightly less used in haskell, especially when the alternative is fine. So at the end maybe: filter even $ map [1..] fib
22:30:14 <kadoban> neuroserpens: And another minor style thing, it's more common to build up a chain of composed functions, so …   print . sum . takeWhile (<4000000) . whatever $ finalThing   is more idiomatic usually.
22:30:16 <neuroserpens> kadoban: It might sound funny but I can read list comprehensions way easier than maps, filters, and such... I'm always trying reduce them to a comprehension.
22:30:32 <neuroserpens> kadoban: Oh yea I agree with the dotted style.
22:30:43 <neuroserpens> kadoban: I just don't understand compositionn and application quite well yet.
22:31:13 <kadoban> neuroserpens: Yeah you might gravitate a bit more away from comprehensions when you get more comfortable with composition, maybe just push yourself a tad though I wouldn't worry about it too much.
22:32:03 <zipper> Is there a way to do IO () -> STM ()
22:32:39 <zipper> If I wanted to run a IO () in a block of `atomically`.
22:33:36 <Haskellfant> zipper: afaik the whole point of stm is to restrict the actions possible so allowing arbitrary io doesn't make a lot of sense
22:33:50 <zipper> hmmm okay
22:34:26 <Haskellfant> stm actions may need to be rolled back if a transaction fails. but if your action was deleting a file rolling that back is going to be quite hard
22:35:14 <pacak> Haskellfant: Undeleting file is relatively easy as long as you still have a handle open somewhere
22:35:40 <lifter> I just upgraded from GHC 7.8 to 7.10 and now in some cases it seems that my polymorphic functions for which I don't provide a signature are being specialized to the first inferred type and the compiler is giving me lots of errors, but explicitly providing a function signature seems to fix it. Anyone know anything about this?
22:35:52 <kadoban> pacak: Yes but how you do undo an arbitrary  IO (), when that's all you know about it?
22:36:28 <pacak> lifter: You need either to specify FlexibleContexts or provide a type signature
22:37:21 <supki> zipper: you can use GHC.Conc.unsafeIOToSTM if you don't care how many times it happens
22:38:00 <zipper> I want to keep off unsafe functions.
22:38:34 <lifter> pacak, awesome!!! FlexibleContexts seems to have worked. That really threw me off for a couple hours
22:38:53 <pacak> lifter: I think it suggests it somewhere in error messages.
22:39:39 <lifter> pacak, may have missed it...
22:50:48 <muller> Is it possible to implement MaybeT without using Monad plus and guard function?
22:54:18 <muller> http://lpaste.net/135090, this is my attempt to do so. But if I replace MayT in line 37 with lift and change the signatures of getPassword and getPasswords to MaybeT IO (Maybe String), then the lift  function will work, but the getpasswords will return the value of the second getpassword call, (even if the first one was blank, hence returned Nothing), instead of returning Nothing.
22:59:19 * hackagebot lentil 0.1.2.4 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.2.4 (fffaaa)
23:07:14 <milesrout> what is a monad?
23:07:48 <milesrout> milesrout: it's a monoid in the category of endofunctors.
23:07:52 <milesrout> milesrout: oh thanks!
23:08:05 <pacak> milesrout: But it is...
23:08:59 <kadoban> milesrout: In haskell it's something that has 'return' and (>>=) that follow some pretty intuitive laws.
23:14:40 <gamegoblin> @pl \(f,g) x -> (f x, g x)
23:14:40 <lambdabot> uncurry (liftM2 (,))
23:21:27 <muller> Is it possible to implement MaybeT without using Monad plus and guard function?
23:22:15 <muller> muller, I am going round in circles for about a day with this http://lpaste.net/135090
23:22:45 <muller> I am going round in circles for about a day with this http://lpaste.net/135090
23:23:07 <muller> if I replace MayT in line 37 with lift and change the signatures of getPassword and getPasswords to MaybeT IO (Maybe String), then the lift  function will work, but the getpasswords will return the value of the second getpassword call, (even if the first one was blank, hence returned Nothing), instead of returning Nothing.
23:25:21 <muller> the problem is I have an IO (Maybe String) and want to convert it to MaybeT IO String. But the signature of lift function is m a -> t m a, so it should accept an (IO String) to return a (MaybeT IO String)...but I have a IO Maybe String at hand...
23:33:05 <quchen2> muller: MaybeT :: IO (Maybe String) -> MaybeT IO String
23:34:22 <muller> quchen2, yes. 
23:34:52 <muller> quchen2, I see that. But how should i write the lift function?
23:38:39 <DNoved1> lift m = MayT (m >>= return . Just), perhaps? I'm not too good with transformers
23:46:50 <cj3kim> hi
23:47:01 <cj3kim> I need some tips on refactoring this code: https://gist.github.com/cj3kim/c0db32ba27face6fe2a7
23:47:21 <cj3kim> I've been following the beginner guide at http://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf
23:47:31 <cj3kim> and have been doing the hw
23:47:49 <cj3kim> just need some tips on dos and don'ts 
23:48:10 <cj3kim> I'm trying not to repeat code, but it seems inevitable since I don't have the vocab yet
23:48:47 <muller> DNoved1, But that messes up with the Maybe functionalty, because evrything is just wrapped in Just, so 'Nothing' occuring a series of do actions does not propogate.
23:53:31 <muller> DNoved1, this is the page I use as a reference https://en.wikibooks.org/wiki/Haskell/Monad_transformers, but it uses Monad plus and guard function to propogate the error.
23:57:45 <george_p> cj3kim looks fine to me
