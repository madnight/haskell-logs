00:01:48 <xj54y> Sadly, the more I take to reducing some syntactical parts, the more my code begins to remind me of lisp
00:02:00 <Haskellfant> what's so bad about lisp?
00:02:47 <xj54y> Not too much, but I prefer to stay focused strictly on haskell insofar as it may prevent my mind from wandering
00:03:12 * xj54y clinches pen
00:03:38 <pacak> Haskellfant: Lack of "shape" - it won't stop you from writing incorrect programs like Haskell does.
00:04:23 <pacak> Also a very ancient stdlib if we are talking about Common Lisp.
00:04:29 <xj54y> Is there a shorthand for using selectors?
00:04:39 <pacak> 5 or 6 parameters to open a file...
00:04:43 <Haskellfant> pacak: sure, but these seemed more about syntax stuff, so I was wondering what exactly xj54y was refering to
00:04:53 <Haskellfant> imho the lisp syntax is not too bad
00:05:02 <Axman6> xj54y: do ou mean record selectors?
00:05:07 <xj54y> Axman6, I do
00:05:17 <Axman6> then lens is what you want
00:05:18 <xj54y> Lisp syntax is pretty straight forward
00:05:28 <xj54y> Axman6, that's the force I picked up on.
00:05:31 <pacak> Haskellfant: Easy to read, very easy to parse, harder to read
00:05:36 <Axman6> (assuming you're talking about haskell)
00:05:48 <pacak> (easy to write that is)
00:06:01 <xj54y> Axman6, assuming I am (such that I am), any articles to look into?
00:06:02 <mlamari> Anyone here use Threadscope on windows? More specifically, Windowns + 64 bit haskell?
00:06:22 <xj54y> I've stumbled upon lens, but ehn I get caught up in cohomologies and all sorts of stuff
00:06:41 <xj54y> (and seemingly unsorted stuff as well)
00:07:02 <xj54y> Totally elementary
00:07:24 <Axman6> I haven't read it myself, but maybe this'll help: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/basic-lensing
00:07:51 <xj54y> to be honest, going to infinity right now..... *sigh*
00:07:56 <xj54y> Gratsi :>
00:08:18 <cantremembermyni> How do I change my nick?
00:08:24 <xj54y> /nick nick
00:08:28 <Axman6> lenses give you getters and setters, but also give you a whole universe more utility
00:10:45 <xj54y> Axman6, yeah, this is nice and seems I've already wrote in depth about it, however maybe I was looking for something else
00:11:42 <xj54y> I'll update you later with something a bit more concise. Appreciate it all, all the more :D
00:16:17 <pacak> For me learning how to implement lenses from scratch did the trick. Lens' a b is the same as Functor f => (b -> f b) -> a -> f a and using various functors you can do  tricks.
00:24:29 <cantremembermyni> What is the best IDE for haskell?
00:24:34 <xj54y> emacs
00:25:46 <pacak> cantremembermyni: vim
00:26:08 <xj54y> oherrala, found what I was looking for: (.)
00:26:14 <xj54y> oh**
00:30:22 <dzack> cantremembermyni: i use vim personally. works pretty well, as long as you have ctags/csope, ctrlp, ag, etc
00:34:29 <Cale> Yeah, just whatever editor you're comfortable with, open in a separate window from GHCi. You can type :r in ghci to reload your file whenever you save it and try your new definitions/changes.
00:35:06 <xj54y> Yeah, the haskell extension for emacs makes it all a little easier so that you don't have to leave emacs whatsoever
00:35:29 <xj54y> it's like an ultra-editor where you can get things done with all languages.. However, has a bit of a learning curve to it
00:35:52 <xj54y> eVIl is a nice plugin as well, for those who prefer vim
00:35:57 <z16> xj54y: Can do that in Vim too :)
00:37:01 <xj54y> z16, probably so, just not as robust I'd say (as I've just switched from vim to emacs after about 10 years or so) Soon, emacs will be backwards compatible with vim :p
00:37:31 <cantremembermyni> I have a stupid question
00:37:39 <xj54y> it's your birth right
00:37:44 <z16> cantremembermyni: Who doesn't
00:37:45 <xj54y> ask it
00:37:53 <cantremembermyni> How do I install plugins for vim?
00:38:03 <z16> My stupid question for today: Do I eat a Butterbrezn or a Leberkassemmel for breakfast?
00:38:56 <cantremembermyni> Nevermind, actually
00:38:59 <srhb> cantremembermyni: Try #vim :) But there are a lot of guides you can find by googling. They'll probably appreciate if you've read some :)
00:40:59 <pharaun> left?
01:15:28 <kuznero> Hi All!
01:16:18 <dramforever> kuznero: hi, I'm not very good at haskell but maybe I can help
01:17:19 <kuznero> That would be great... I am stuck in getting GHC installed on CentOS 7 :)
01:18:14 <kuznero> It is not a first citizen in CentOS unfortunately and surprisingly as RHEL/CentOS is the first thing to have covered if we want Haskell to take off for enterprises
01:18:31 <srhb> kuznero: Hi! Have you tried installing the binary GHC distribution?
01:18:45 <dramforever> how about the ghc in the offical package manager?
01:18:49 <mauke> avoid success
01:19:01 <dramforever> mauke: yep
01:19:14 <kuznero> The problem is that there is no official nor unofficial binary package for CentOS 7.
01:19:28 <kuznero> And nothing in package manager repos
01:20:10 <kuznero> mauke: it is not about avoiding success it is about not getting in a way :) kind of
01:20:23 <dramforever> maybe try http://haskell.org/platform or https://www.haskell.org/ghc/download_ghc_7_10_1
01:20:38 <srhb> I would definitely go for the latter.
01:20:41 <dramforever> kuznero: the latter one looks better
01:20:44 <dramforever> srhb: yep
01:20:54 <dramforever> kuznero: go for the latter
01:21:11 <Cale> kuznero: I would recommend grabbing the appropriate generic linux binary of GHC from here: https://www.haskell.org/ghc/download_ghc_7_10_1#x86linux
01:21:17 <Cale> yeah
01:21:26 <dramforever> Cale: agree
01:21:27 <Cale> heh, seems it's already been suggested
01:21:46 <kuznero> dramforever: it has only Debian binaries
01:21:53 <dramforever> kuznero: how about the latter?
01:21:58 <dramforever> https://www.haskell.org/ghc/download_ghc_7_10_1
01:21:58 <kuznero> sources?
01:22:01 <dramforever> no
01:22:04 <dramforever> https://www.haskell.org/ghc/download_ghc_7_10_1
01:22:08 <Cale> kuznero: They were compiled on Debian, that doesn't mean you have to use Debian
01:22:30 <kuznero> I see... didn't know. Let me try!
01:22:32 <kuznero> Thanks :)
01:22:39 <Cale> As long as you're on the right architecture, and have libgmp installed, you should be fine.
01:23:05 <kuznero> Cale: yep, that should be the case.
01:23:41 <srhb> kuznero: (Random sidenote, I just noticed your ip. Fellow dane, or just living here? :-))
01:24:12 <kuznero> Living and working :) Not a dane (yet) :)
01:24:43 <srhb> More Haskellers is always welcome! :-)
01:25:07 <dramforever> that reminds me of a sentence my friend once said
01:25:19 <dramforever> "I visited Denchmark this summer"
01:25:48 <dramforever> lol spelling
01:25:48 <kuznero> :)
01:28:42 <Hafydd> Hahahah.
01:32:51 <kuznero> That worked! Now I have my Haskell compiter in CentOS 7 :)
01:32:55 <kuznero> Thanks all!
01:33:45 <srhb> kuznero: Woo!
01:33:56 <srhb> kuznero: You'll probably want to grab cabal-install too :)
01:35:03 <kuznero> srhb: yep, the rest is known to me :)
01:35:07 <srhb> Cool. :)
02:07:22 <xj54y> bitemyapp, oh, looks like I found this little goodie... :-)  https://github.com/bitemyapp/learnhaskell
02:07:55 <srhb> xj54y: There's also #haskell-beginners which centers around that guide in many ways.
02:08:47 <xj54y> srhb, yes, that's listed in the guide..
02:08:58 <srhb> xj54y: Ah. Embarrassing, I hadn't actually read that. :P
02:09:44 <xj54y> srhb, no worries.. Just noticed bitemyapp was a user here, as listed on hackernews.. Nice find none the less :-D
02:10:57 <Veyn> It's my turn to go write a confusing tutorial on Monads now...
02:11:05 <Veyn> as it finally clicked in my brain.
02:11:32 <srhb> Veyn: Yay!/Nooo :) D:
02:11:44 <xj54y> Maybe.
02:11:59 <Veyn> Maybe Confusing
02:15:02 <Veyn> Now onto fully understanding FRP!
02:18:10 <lamefun> Can I import some stuff and module in one go? Like import Data.ByteString (ByteString) qualified as BS?
02:19:33 <indiagreen> lamefun: no, but there's a proposal being discussed on haskell-cafe which is about exactly this
02:20:43 <indiagreen> you'd have to wait for the next GHC at the very least
02:20:58 <indiagreen> so, currently – no
02:21:02 <lamefun> can Template Haskell allow this in meantime?
02:21:19 <indiagreen> I don't think so, since TH doesn't let you add imports
02:21:41 <srhb> lamefun: What exactly were you trying to achieve with the example?
02:22:12 <srhb> lamefun: Importing the whole module unqualified but ByteString qualified?
02:23:23 <lamefun> import ByteString and the module as BS in one line
02:23:25 <nshepperd> srhb: the other way around
02:23:32 <srhb> Ah.
02:24:06 <nshepperd> seems useful, because I'm always writing stuff like 'import Data.Map.Strict (Map); import qualified Data.Map.Strict as Map'
02:28:03 <srhb> I've heard others miss it. I think the syntax proposals are a bit convoluted and hard to understand compared to just two lines of imports, but I don't feel strongly about it.
02:36:46 <jhk>    hi all, i have a beginner question
02:37:03 <jhk> i have a = [1,2,3] and b = [(+1),(+2),(+3)]
02:37:13 <jhk> how can I do something like
02:37:26 <jhk> zipWith (function) a b 
02:37:32 <jhk> so that I get [4,4,4]?
02:38:02 <mniip> jhk, zipWith ($)
02:38:14 <mniip> zipWith ($) b a
02:38:48 <jhk> ohh
02:38:52 <jhk> thank you
02:39:48 <lamefun> Does Haskell still have hope now that Rust is out? Does it still have any significant advantages? Rust seems to have safe safe strong typing has macros and compiler plugins to replace Template Haskell. I need Safe Haskell for what I want to do (it needs sandboxing untrusted code), but I think Rust is going to get that feature sooner or later...
02:41:44 <pleiosaur> lamefun: haskell and rust are quite different, you could use the same argument to claim that rust makes ocaml obsolete, which is just as untrue :)
02:43:56 <lamefun> I meant the hope of getting wider usage.
02:45:59 <srhb> lamefun: I doubt that Rust touches very much upon the Haskell user sphere.
02:46:15 <srhb> lamefun: But ultimately, the point is to be a good language for research and everyday use, not world domination. :P
02:49:54 <Veyn> srhb: I disagree with you, I personally thing Haskell is the one language to rule them all! ;)
02:50:15 <srhb> Veyn: So do I, but I don't care for the rest of the world to do that. They'll probably just argue to make Haskell a worse language anyway. :P
02:50:54 <nshepperd> avoiding success just got easier! :)
02:51:07 <Veyn> Whenever I speak about it to non-haskell users, They always send the XKCD... It makes me cry a little bit.
02:51:27 <srhb> Veyn: Strategy: Don't talk Haskell to non-Haskell people.
02:51:28 <Veyn> single tear streaming down my face
02:51:29 <srhb> :P
02:51:32 <lamefun> srhb, what XKCD?
02:51:39 <lamefun> Veyn, ^
02:51:45 <int-e> https://xkcd.com/1312/ presumably
02:51:49 <srhb> http://xkcd.com/1312/
02:51:51 <srhb> Yeah
02:52:02 <Veyn> yep
02:52:08 <srhb> int-e has more secure comics than I do...
02:52:28 <ReinH> I love the irony of xkcd bashing haskell <3
02:52:44 <srhb> Yeah :P
02:52:48 <Chobbes> Veyn: srhb pffff. Talking about Haskell to non-Haskell people is totally fine ;).
02:53:21 <srhb> Chobbes: My aloofness levels always need to be replenished afterwards.
02:53:35 <saulzar_> I struggle a lot with explaining "what is Haskell" to non Haskell people, actually "what is functional programming"
02:54:01 <merijn> saulzar_: I've come to prefer the term "value oriented programming" (semi-serious)
02:54:05 <ReinH> functional programming is an unfortunate term
02:54:13 <saulzar_> Hmm
02:54:16 <merijn> saulzar_: because everything (including functions!) is a value and it's about values and what you can do with them
02:54:27 <srhb> ReinH: I also prefer function_ing_
02:54:29 <srhb> :P
02:54:43 <merijn> "Functional programming" seems to lead people down the alley of "everything is a function" nonsense
02:54:47 <ReinH> merijn: I like (Landin's) denotative programming
02:55:18 <merijn> That's not going to help people understand, though :p
02:55:25 <Chobbes> merijn: "everything is a function" sort of works :P.
02:55:31 <ahihi> "everything is a value" seems just as misleading though, given that a lot of haskell's strengths come from the type system
02:55:33 <Veyn> (almost) everything is a function! ;)
02:55:36 <ReinH> it will help people who understand denotations, i.e. people who already understand
02:55:37 <ReinH> :p
02:55:51 <merijn> Veyn: The type system is what lets us describe values
02:55:58 <saulzar_> I say "programming with expressions" and "immutable data", but it doesn't really convey much, I feel
02:56:09 <merijn> Veyn: Also, as someone who can't wait for dependent haskell types are values too :)
02:56:15 <ReinH> at least denotative programming has a clear definition
02:56:29 <merijn> saulzar_: I would say the key point (of haskell, not FP in general) is "the ability to reason about your code"
02:56:41 <ReinH> merijn: yes, denotative programming :p
02:56:48 <merijn> saulzar_: Equational reasoning (i.e., we can just replace every left hand side of a definition with it's right hand side)
02:56:58 <srhb> Yes, I also tend to argue that it's "just a programming language" which allows you to keep more toolboxes for analysis.
02:57:02 <merijn> ReinH: denotational semantics is more precise than that
02:57:06 <Veyn> I know, I have been spoiled by Haskell's type-system
02:57:18 <merijn> ReinH: Because that requires mapping denotations to mathematical objects
02:57:28 <merijn> ReinH: And defining an appropriate object
02:57:43 <ReinH> merijn: yes, but you can also take Conal's approach
02:58:07 <nshepperd> things that mean things
02:58:36 <ReinH> that they do
02:58:43 <merijn> saulzar_: The nice part of Haskell's approach is that purity/referential transparency allows us to reason about the meaning of definitions by simple substitution
02:59:06 <merijn> saulzar_: Reasoning about imperative languages requires Hoare logic or more powerful reasoning tools, which are an utter pain to work with
03:00:02 <merijn> Incidentally, for the interested, there's a good free book on proving properties of programs that starts with proving properties of pure functions and slowly moves up to more general imperative languages
03:00:07 <merijn> @where sf
03:00:07 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
03:00:07 <lambdabot> assistant."
03:00:14 <merijn> Because I can't pimp SF enough :p
03:00:24 <Chobbes> merijn: Software Foundations rocks!
03:00:36 <saulzar_> merijn, Yeah, that's a good point.. I sometimes go there too, "it's like mathematical equations" is usually how I try to phrase it, which doesn't entice some people!
03:00:59 <srhb> "In Haskell, functions are functions, which is nice."
03:01:00 <merijn> saulzar_: You should phrase it like "do you like knowing what your code does?"
03:01:01 <srhb> :-)
03:01:05 <ReinH> merijn: my latest fun experience with (not) reasoning about imperative programs was in golang
03:01:05 <nshepperd> I like that I can pretend that a Set is really a set, and my intuition isn't completely wrong
03:01:20 <Chobbes> srhb: ahahaha :).
03:01:28 <ReinH> which has a "defer" language construct that breaks beta-convertability and makes extract method refactors unsafe.
03:01:28 <nshepperd> Data.Set I mean
03:01:38 <ReinH> merijn: so that's nice
03:01:44 <Chobbes> Off topic, but... I already feel like Python needs dependent type hints ;).
03:01:50 <dramforever> arrrrrgh
03:01:53 <ReinH> Chobbes: it needs types first
03:01:59 <merijn> ReinH: It's getting types
03:02:01 * dramforever has just chosen 3 libs to work with
03:02:07 <Chobbes> ReinH: it's getting type hints :)
03:02:19 <alpounet> ok, i've been looking for SPJ's famous "good programs / bad programs" slide with a drawing with 2 circles that intersect etc
03:02:20 <Chobbes> merijn: not quite ;)
03:02:24 <ReinH> for some value of types
03:02:27 <nshepperd> rpython has types! sort of ish
03:02:29 <merijn> I've always felt that records + row typing would make for good static ducktyping
03:02:34 <Veyn> merijn: I love that
03:02:40 <merijn> I guess you'd need structural subtyping too
03:02:41 <alpounet> does anyone remember where that slide is?
03:02:42 <dramforever> turns out 1 works with Data.Text, 2 works with Data.ByteString
03:02:55 <Veyn> Wow I need to keep up with the chat..
03:02:56 <merijn> dramforever: Converting those is easy enough...
03:03:07 <dramforever> merijn: yep
03:03:08 <srhb> alpounet: Aside from in the "avoid (success at all cost)" talks?
03:03:50 <dale> does haskell's type system reason about contravariance/covariance in the traditional sense? I.e. if I have a function that accepts function (a->b), can I provide it with a function (c->d) where c is constrained by fewer typeclasses than a, and d is constrained by more than b (if that makes any sense...)
03:03:52 <dramforever> although I admit that I'm not familiar with lens, 2 of the 3 libs uses it and I think it's pretty good
03:04:08 <merijn> dale: I don't really understand the question?
03:04:11 <alpounet> srhb: i think he may have used it several times. any occurence of it would work for me, i just need to link it to someone
03:04:26 <srhb> alpounet: Checked the Being lazy with class slides?
03:04:42 <merijn> dale: Oh, I think your question is confused
03:04:45 <srhb> Or wait, that's not the one...
03:04:49 <dale> merijn, almost certainly
03:05:01 <merijn> dale: Note that haskell doesn't have subtyping at all
03:05:17 <merijn> dale: So the usual covariance/contravariance confusion in relation to subtyping does not exist
03:05:25 <merijn> dale: You should consider typeclasses as constraints
03:05:27 <dramforever> dale: doesn't really make sense, you might want to check about Hindley Minler and system F
03:05:47 <dale> merijn, but wouldn't (Foo a, Bar a) => a be a subtype of (Foo b) => b
03:06:02 <lamefun> srhb, I meant that Rust, Apple® Swift™ have taken some of Haskell's gateway drugs (never-null pointers, pattern-matching, etc.). They have no side effect isolation of course, but they're still way better than eg. C++
03:06:16 <merijn> dale: i.e. "foo :: Eq a => a -> [a] -> Bool" can be read as "IF 'a' is an instance of 'Eq' THEN foo has type "a -> [a] -> Bool"
03:06:18 <srhb> alpounet: http://www.slideshare.net/nushio/peyton-jones2009fun-withtypefunctionsslide -- slide 7
03:06:33 <merijn> dale: No, but the former type does unify with 'b'
03:06:33 <dramforever> lamefun: I think there's a relevant xkcd
03:06:39 <merijn> dale: Eh, with the latter
03:06:57 <srhb> lamefun: I don't think that changes much. 
03:07:17 <alpounet> srhb: awesome, thanks! I've been googling around for half an hour...
03:07:20 <srhb> lamefun: Eventually people will become so comfortable with good (well, better) type systems that inevitably they will learn the error of their ways. :-)
03:07:22 <alpounet> =)
03:07:28 <srhb> alpounet: Sure thing :)
03:07:37 <merijn> dale: A function expecting "foo :: Foo a => a -> Bool" will also accept a value "(Foo a, Bar a) => a", yes, because the constraint cares only whether it can be met
03:07:55 <ReinH> I for one welcome our new typesafe, threadsafe, memory safe overlords.
03:08:01 <merijn> dale: The type of foo only cares whether the argument is an instance of "Foo", it doesn't care what else it is an instance of
03:08:06 <dramforever> lamefun: http://xkcd.com/1497
03:08:22 <dramforever> haskell is "really exciting"
03:08:32 <dramforever> (sadly)
03:08:37 <ReinH> srhb: you would think, and yet: golang
03:08:49 <srhb> ReinH: Some people juggle geese.
03:09:07 <ReinH> I never thought geese juggling would be this popular though
03:09:11 <ReinH> :(
03:09:13 <srhb> True. :P
03:09:17 <merijn> dale: In haskell we'd talk about whether two types unify, as opposed to whether they are subtypes. You can in some basic sense treat some forms of unification as subtyping, but it doesn't work in general
03:09:25 <spaceloop> how do I let cabal place the binaries from cabal-install at ~/.cabal/bin instead of a cabal-sandbox/bin (but still use the sandbox to build)?
03:09:35 <spaceloop> can't seem to find the right flag
03:09:40 <srhb> spaceloop: I don't think there is one.
03:09:43 <srhb> spaceloop: cp :)
03:09:53 <spaceloop> ok :p
03:09:54 <ReinH> it's best to pretend that subtyping doesn't exist in Haskell. This should be pretty easy, given that it doesn't exist.
03:10:07 <dramforever> spaceloop: won't it cause conflicts?
03:10:12 <dale> merijn: but then what if a function takes "fizz :: Foo a, Bar b => a -> b", can I provide it with a function "buzz :: Bar b, Dip b => a -> b"
03:10:41 <dramforever> for example, two different sandboxes both want to build a binary called fooHaskellApp
03:10:52 <merijn> dale: No, because 'a' is not an instance of Foo in the latter
03:11:48 <merijn> dale: Suppose we had "fizz :: (Foo a, Bar b) => (a -> b) -> Bool" and "buzz :: Bar b => a -> b" (the latter is not a sensible but type, but let's ignore that)
03:11:54 <ReinH> spaceloop: --bindir
03:12:03 <spaceloop> dramforever, I am sandboxing a project that requires some of the dependencies' executables to be on the path, so I figured having them installed in .cabal/bin would be the right way
03:12:35 <merijn> dale: Actually, hold on, let's use "buzz :: Bar d => c -> d" to avoid confusion of similar type variables
03:13:23 <dramforever> merijn: a ha! \
03:13:36 * dramforever just realized that he doesn't need to deal with conversion
03:14:11 <merijn> dale: Now, if we try to apply "fizz buzz" we get the following unification equations: "(a -> b) = (c -> d); Foo a; Bar b; Bar d", we then conclude "a = c; b = d; Foo c; Bar d; Bar d"
03:14:18 <dramforever> I'm making a web scrapper, and I have bytestrings for requests, text for responses
03:14:19 <dramforever> great
03:14:38 <merijn> dale: But the "Foo c" constraint doesn't hold
03:14:49 <merijn> dale: Because buzz doesn't require 'c' to be a Foo instance
03:15:05 <merijn> dale: So the compiler will complain that it can't prove that 'c' is an instance of Foo
03:15:23 <merijn> dale: Does that make sense?
03:16:44 <dale> merijn, thank you v. much. This makes sense from the perspective of how the haskell type system works. Intuitively it doesn't yet feel like the right thing to happen - but I get why it happens. (I came from languages like C# where functions were contravariant on their input)
03:18:14 <lamefun> Does Haskell have nameless variant types? (eg. myFunction :: String | Int | Etc -> ...)?
03:19:12 <indiagreen> nope
03:19:13 <dramforever> lamefun: how could you use it?
03:19:20 <dramforever> how could you use the argument?
03:19:31 <indiagreen> dramforever: for instance, use “show” on it
03:19:32 <dale> dramforever: myFunction x = x :P
03:19:55 <dramforever> indiagreen: then myFunction :: Show a => a -> ...
03:20:24 <indiagreen> dramforever: except that I specifically want to forbid everything but Int and String
03:20:32 <lamefun> dramforever, something like myFunction (s :: String) = ...
03:20:41 <merijn> indiagreen: You can actuall do that! :D
03:20:52 <indiagreen> ooh, do tell
03:20:52 <dramforever> lamefun: I don't think we can pattern match on types
03:20:53 <merijn> indiagreen: If you don't mind complicated extension voodoo :p
03:21:03 <u-ou> blah
03:21:08 <u-ou> why not just make a typeclass
03:21:10 <merijn> indiagreen: https://gist.github.com/merijn/6130082
03:21:11 <dramforever> indiagreen: you can use your own typeclass class Show a => SomeClass
03:21:14 <dramforever> a
03:21:18 <dale> couldn't you define a wrapper typeclass and only instance it for the allowed types
03:21:21 <dramforever> and don't export it
03:21:28 <dramforever> dale: yes agree
03:21:44 <merijn> indiagreen: It doesn't work very well with polymorphic literals like "foo 5" because it can't prove "5" is not an Int
03:21:55 <merijn> indiagreen: But with monomorphic inputs it works :)
03:22:02 <indiagreen> dale: typeclasses are still considered open by GHC even if you don't export them
03:23:37 <indiagreen> dale: and this means that GHC wouldn't be able to infer some types it *technically* would've been able to infer with a declaration like (Int | String)
03:23:38 <indiagreen> I think
03:26:44 <indiagreen> dale: for instance, let's take “f :: ((Int -> Int) | (Int -> Int -> Int))”. If I do “f 5” now, GHC should be able to infer “5 :: Int”. I think you can't achieve this with a typeclass which has “f” as a method (I spent an hour on it without success)
03:29:02 <mniip> indiagreen, f :: Fret r => Int -> r
03:29:16 <mniip> instance Fret Int; instance Fret (Int -> Int)
03:31:30 <indiagreen> ...that's cheating but I don't remember already what was the more complicated use case for which it wasn't an option
03:38:24 <arbelos> Wait. There is a lens-aeson and one aeson-lens?
03:39:36 <arbelos> Should I be confused?
03:39:54 <indiagreen> okay, hm, what about involving argument counts? can there be [f :: (Int -> Int) | (Bool -> Bool -> Bool)] which would infer that [x :: Bool] when given [f x True], or is this already enough in Prolog-realm?
03:41:52 <indiagreen> arbelos: lens-aeson is by the author of lens itself while aeson-lens hasn't been updated for a couple of years, so I guess you should use the former
03:44:26 <mniip> arbelos, obviously one implements lenses for aeson, and the other implements aeson with lenses
03:44:42 <mniip> (jk)
03:45:12 <arbelos> indiagreen, thanks
03:46:11 <arbelos> mniip, I was actually thinking along those lines for a moment
03:46:57 <arbelos> don't derive rules of logic from naming conventions
03:47:32 <mniip> we need type signatures for packages
03:49:14 <mniip> mtl :: Monad -> Monad -> Monad
03:52:31 <arbelos> So this looks great. I am just thinking, at the moment I have some code where I parse everything from JSON to home made data types using plain Aeson  
03:52:35 <edwardk> lens-aeson was written in response to aeson-lens not really making any sense
03:53:26 <u-ou> and aeson-lens was written in response to lens-aeson making too much sense
03:53:46 <edwardk> aeson-lens came first. =)
03:53:57 <mniip> it was a fixIO loop
03:54:11 <edwardk> we wrote lens-aeson because the lenses in it didn't pass the laws, so we sat down and asked what the "real" prisms/lenses for aeson would be
03:54:17 <edwardk> then it just turned out to be nice to use
03:54:20 <Axman6> aeson-lens was written proactively for the reasons u-ou mentioned
03:54:36 <edwardk> we gave almost zero thought to how pleasant it'd be, and then folks just found nice ways to use existing lens/prism combinators
03:54:56 <edwardk> so it turned out to be a huge win for proactive generalization
03:55:02 <mniip> which reminds me
03:55:08 <Axman6> because lens is beatifully compositional
03:55:16 <edwardk> anyways the first version of lens-aeson was sketched out by statusfailed, IIRC.
03:55:32 <mniip> I never finished those json-ey prisms/traversals
03:55:47 <edwardk> and i just turned around and sweeted it with some sugary overloading via classes
03:57:30 <arbelos> I guess my question is, isn't there a performance overhead with using ^? repeatedly, if I can just derive lenses from my existing data types and first parse everything 
04:00:22 <edwardk> ^? desugars in 90% of the cases to the code you'd write by hand unless the lens is crazy recursive in its own right
04:00:50 <edwardk> (under -O2 anyways)
04:01:32 <edwardk> for the recursive lenses you may sometimes want to use "fusing (your.big.complicated.recursive.lens)" instead of your.big.complicated.recursive.lens
04:01:41 <edwardk> or confusing (your.big.complicated.recursive.traversal)
04:02:29 --- mode: ChanServ set +o mauke
04:02:29 --- mode: mauke set -b *!*@117.Red-83-39-250.dynamicIP.rima-tde.net
04:02:34 <Axman6> :t fusing
04:02:37 <lambdabot> Functor f => LensLike (Data.Functor.Yoneda.Yoneda f) s t a b -> LensLike f s t a b
04:02:40 <Axman6> :t confusing
04:02:42 <lambdabot> Applicative f => LensLike (Data.Functor.Kan.Rift.Rift (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
04:02:50 <Axman6> D:
04:04:29 --- mode: mauke set -o mauke
04:08:43 <arbelos> well, I am still a lens newbie :), but it looks like my code could benefit from lenses since JSON manipulation and traversal tend to get messy
04:09:41 <dramforever> IMHO lens is a solution to problems like "this F a b can be mapped both on a and b!"
04:10:12 <merijn> dramforever: You mean Bifunctor? :p
04:10:19 <merijn> Also, when the hell did Bifunctor move into base?
04:10:27 <dramforever> merijn: sort of
04:11:07 <dramforever> merijn: "Hey this Matrix type has many Int's in it and you can have a Int -> Int to modify all the Int's"
04:11:15 <dramforever> that's more like it
04:11:19 <dramforever> more general
04:13:58 <noctux> hey. I'm trying to enumerate all numbers with n digits as a string. So the obvious and performant approach would be to du explizit rekursion n times and at each level increment the i-th digit. But that did not look nice, imho. So here is my oneline approach:
04:14:01 <noctux> nub $ map (take n) $ permutations $ concat $ replicate n $ [chr $ x + ord '0' | x <- [0..9]]
04:14:13 <noctux> which does not really scale well...
04:14:43 <noctux> (as it blows up the search space just to reduce it again with nub in n^2)
04:15:12 <merijn> That seems an overly complex approach
04:15:36 <noctux> Has anyone here an idea how to phase that more nicely?
04:15:54 <noctux> without the explizit recursion
04:15:57 <merijn> > replicateM 3 $ map digitToInt [0..9] -- test
04:16:01 <lambdabot>  <no location info>: can't find file: L.hs
04:16:10 <merijn> heh
04:16:12 <merijn> > replicateM 3 $ map digitToInt [0..9] -- test
04:16:14 <lambdabot>      No instance for (Num Char) arising from the literal ‘0’
04:16:14 <lambdabot>      In the expression: 0
04:16:14 <lambdabot>      In the second argument of ‘map’, namely ‘[0 .. 9]’
04:16:19 <dramforever> > replicateM 3 ['0'..'9']
04:16:20 <merijn> oh, duh
04:16:21 <lambdabot>  ["000","001","002","003","004","005","006","007","008","009","010","011","01...
04:16:28 <merijn> Yeah, that's what I meant
04:16:33 <merijn> I guess this should work too
04:16:36 <noctux> damn it...
04:16:43 <merijn> > replicateM 3 ['0'..'9'] -- test
04:16:46 <lambdabot>  ["000","001","002","003","004","005","006","007","008","009","010","011","01...
04:16:51 <noctux> dramforever, merijn: thanks
04:16:59 <dramforever> > liftA2 (:) ['1'..'9'] (replicateM 2 ['0'..'9'])
04:17:01 <lambdabot>  ["100","101","102","103","104","105","106","107","108","109","110","111","11...
04:17:03 <FireFly> Isn't that the same?
04:17:06 <dramforever> noctux: that seems better
04:17:16 <pacak> > (\l -> [10^l .. 10^(l+1) - 1]) 1
04:17:17 <dramforever> no leading 0
04:17:18 <lambdabot>  [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,...
04:17:23 <noctux> dramforever: now, i need the leading 0
04:17:27 <dramforever> okay
04:17:34 <merijn> FireFly: No, because it's saturday and paying attention is for losers
04:17:35 <noctux> dramforever: it is the *last* part of a number
04:17:45 <FireFly> merijn: fair :P
04:17:48 <dramforever> hmm...whatever
04:18:07 <dramforever> pacak: I think noctux wants digit strings
04:18:09 <noctux> dramforever: https://paste.xinu.at/CJL/
04:18:23 <mniip> what's more popular, liftA2 f x y, or f <$> x <*> y
04:18:26 <pacak> > map show $ (\l -> [10^l .. 10^(l+1) - 1]) 1
04:18:30 <lambdabot>  ["10","11","12","13","14","15","16","17","18","19","20","21","22","23","24",...
04:18:32 <noctux> dramforever: i got a invoice that spelled out part of my IBAN in an email
04:18:54 <noctux> dramforever: and I want to enumerate how many valid options remain as they did not XX-out the parity/check-bits
04:19:14 <noctux> dramforever: so the digit-strings are the end of my IBAN
04:19:14 <dramforever> noctux: hmm...lol
04:19:32 <pacak> > map (printf "%3i") [1..]
04:19:32 <dramforever> maybe you can complain if there are not enough options
04:19:35 <lambdabot>      No instance for (Show b0)
04:19:35 <lambdabot>        arising from a use of ‘show_M185079103199871517912805’
04:19:35 <lambdabot>      The type variable ‘b0’ is ambiguous
04:19:49 <pacak> > map (printf "%03i") [1.. 100 :: Int]
04:19:51 <lambdabot>      No instance for (Show b0)
04:19:52 <lambdabot>        arising from a use of ‘show_M649553718229787590912828’
04:19:52 <lambdabot>      The type variable ‘b0’ is ambiguous
04:19:57 <dramforever> noctux: well, I guess pacak still has a few for you
04:20:38 <pacak> My internets are very derpy for some reson...
04:20:43 <noctux> dramforever: jeah, if they do typecheck :D
04:29:00 * hackagebot gll 0.2.0.3 - GLL parser with simple combinator interface  http://hackage.haskell.org/package/gll-0.2.0.3 (ltvanbinsbergen)
04:35:46 <Shockk> hello, I'm having an issue with a really simple program I wrote to test the differences between ghc executables and jhc executables
04:35:52 <Shockk> https://gist.github.com/shockkolate/1d1b11b4af0d1e0cea82
04:36:21 <Shockk> I wondered if I'm doing something that's non-standard behaviour or if it's just a bug in jhc
04:37:54 <mauke> that looks like a bug in jhc
04:37:59 <bennofs> Shockk: have you tried not calling main directly from main, but instead doing something like forever $ do ...
04:38:05 <mauke> instead of show x it prints " + 2 = " again
04:38:19 <mauke> also, readLn
04:40:15 <Shockk> hmm, I'll try readLn, but as far as calling main in main, that shouldn't make a difference should it? forever is implemented with >> which is what my code would desugar to
04:41:05 <bennofs> Shockk: if jhc compiles via C, i think there is some weirdness around calling main from main in C
04:41:19 <mauke> there isn't
04:41:36 <bennofs> mauke: ok, then I just remembered incorrectly
04:41:40 <mauke> and "compiles via C" doesn't mean Main.main has to become main in C
04:42:39 <bennofs> mauke: hmm right. Still, it looks like the only thing that is at least a little bit not commonly used (if anything else was broken in jhc, i'd assume that bug would've been already found before and fixed)
04:43:16 <mauke> you could look at the generated C code for clues
04:43:20 <bennofs> mauke: oh, it's another difference between C and C++. C++ doesn't allow it
04:53:05 <grayling_> Can I explicitly declare a type for a "". I'm having trouble using tagsoups combinator ~== with ""
04:54:01 <grayling_> as in dropWhile (~== "<input name=javax.faces.ViewState")
04:54:21 <liste> grayling_ ("" :: Text) ?
04:55:29 <grayling_> Damn. I was missing the ()
04:55:47 <grayling_> Thanks.
04:56:06 <liste> np (:
04:58:18 <grayling_> Sometimes small details means a lot in Haskell. :-)
04:58:41 <grayling_> Or anywhere else for that matter...
04:58:50 <Shockk> mauke: took a look at the generated C code, took a while to understand it
04:58:53 <Shockk> I see the problem though
05:00:30 <Shockk> I see the readLn is done, then putStr is called twice with the same string for some reason
05:01:11 <Shockk> the string " + 2 = " of course
05:02:51 <Shockk> that does seem like a bug in jhc because putStr (show x ++ "string") shouldn't translate to 2 x putStr "string"
05:02:55 <schoppenhauer> hello. is it possible with ghc (and if necessary some language extension) to have type specializers? I have a polymorphic type T a, and I want to specialize it for bool
05:03:38 <schoppenhauer> the problem is, I really *need* to write it as polymorphic type.
05:03:43 <liste> schoppenhauer check out type families
05:04:12 <schoppenhauer> that is, defining a typeclass and T' and T a deriving it is not possible
05:04:45 <schoppenhauer> liste: looks promising
05:04:47 <schoppenhauer> thx
05:05:08 <liste> np (:
05:20:08 <int-index> Is there a way to negate a constraint? I want to ensure that there's *no* instance.
05:22:52 <int-index> Given a class `C` and type variable `a`, `C a` checks that there's an instance `C a` and brings its definitions into scope. I want to ensure lack of such an instance.
05:24:49 <ClaudiusMaximus> int-index: i doubt it, you might end up writing paradoxes like  instance (Not Me a) => Me a  ... why do you want it anyway?  the open world assumption means that someone could define an instance later without you knowing about it
05:25:29 <int-e> int-index: also take into account that type classes are open, so the compiler can never know that an instance won't be provided later.
05:26:01 <int-e> (at least a compiler that does per module compilation and type checking as ghc does)
05:27:31 <int-index> ClaudiusMaximus: I want it to invalidate a set of programs that behave very counter-intuitive.
05:27:31 <int-index> Such paradoxes could be detected by the compiler easily.
05:32:03 <int-e> int-index: there is nothing easy about it. one key feature that makes type inference feasible at all is that type derivations are never invalidated, even if new type signatures, instances and the like are added. adding negations destroys this property.
05:34:02 <int-e> (ghc isn't a perfect model of the principle; there's some mess around overlapping instances, for example. But that's a flaw of the implementation, IMHO.)
05:34:36 <sdx23> how would i use hidden modules in another package?
05:36:18 <int-index> int-e: Thanks. I think I've found an alternative solution.
05:36:18 <int-e> sdx23: You can't, unless the functionality is reexported from another module. At least not without rebuilding the package and exposing the module in question.
05:37:11 <sdx23> int-e: ok, so i in any case need to change the original module, right?
05:38:06 <int-e> sdx23: modifying the .cabal file of the package in question should be enough. oh and some soul-searching whether that's really justified, sometimes modules are hidden for a good reason (sometimes not...).
05:39:34 <int-e> (in a .cabal file, modules listed as other-modules will be hidden, while the exposed-modules are, well, exposed).
05:40:42 <sdx23> int-e: i'm extending the module in question; and i guess it's doubtful whether what i'm doing should be a package of its own - however right now that's the way i want to take, so i'll be changing the exports :)
05:40:46 <sdx23> int-e: thank you
05:44:45 <ttt_fff_> anyone familiar with posting to twitter from haskell ?
05:44:53 <ttt_fff_> ideal sample code would be an 'echo' server in haskell
05:45:06 <ttt_fff_> i.e. someone tweets at my account, and my system responds back echoing
05:45:29 <ttt_fff_> data Expr = ExprInt Int | ExprPlus Expr Expr | ExprMult Expr Expr <-- or somethign that can evaluate this, that'd be cool too
05:51:53 <sdx23> ttt_fff_: "evaluate" in which way?
05:52:08 <ttt_fff_> oh, it's a basic calc that can eval expressions like 1+(2*3)
05:52:12 <ttt_fff_> but that's not the hard part (basically just parsec)
05:52:18 <ttt_fff_> the ahrd part is haskell <-> twitter api
05:57:05 <sdx23> ttt_fff_: you surely found Web.Twitter - lambdatwit may be a nice usage example 
05:57:22 <ttt_fff_> no, I found some twitter-conduit thingy
06:00:47 <ttt_fff_> sdx23: where do I get sample code for Web.Twitter ?
06:01:12 <ttt_fff_> ttt_fff: https://github.com/AshyIsMe/lambdatwit/blob/master/Main.hs
06:04:25 <sdx23> ttt_fff_: ah, so without conduit there's e.g. http://hackage.haskell.org/package/follower
06:05:28 <ttt_fff_> sdx23: have you used twitter api via haskell?
06:05:38 <ttt_fff_> one thing I don't understand is how, instead of only reading top 20, I want to read _all unread_ tweets at me
06:07:21 <sdx23> ttt_fff_: no i haven't. From the source, however, i'd guess its due to twitters api, not the module itself.
06:08:57 <sdx23> ok, seems to be both: https://dev.twitter.com/rest/reference/get/direct_messages
06:12:37 <ttt_fff_> https://dev.twitter.com/rest/public/rate-limits is pretty restrictive too
06:21:35 <ttt_fff_> https://dev.twitter.com/streaming/userstreams is what I want
06:21:36 <ttt_fff_> stremaing api
06:35:44 <haasn> lambdabot-as-a-service
06:35:53 <haasn> now over twitter for extra web 2.0 bullshit
06:38:20 <xj54y> speaking of which, I'd love to get lambdabot going, but theres problems with installing it through cabal :-(
06:44:15 <bollu> hey everyone, haskell newb here. I'm trying to learn by solving hackerrank problems, and I see that I'm doing this: without having access to mutable state / OO , I'm partially applying functions everywhere to carry data around. Also, since I don't have "loops", (I know map exists, but you can't have proper scope for map), I find myself (again), constructing closures and then using map for the last argument  
06:44:31 <bollu> this is turning out to be a frustrating exercise in figuring out how to "cleverly" map and filter
06:44:40 <bollu> and I don't think what I'm doing is right
06:44:44 <bollu> so, well, how do I not do this?
06:44:46 <koomi> is there a way to inspect the currently running threads in an application?
06:45:10 <bollu> https://gist.github.com/bollu/be5338839435f230611b
06:45:15 <bollu> here is some example code 
06:45:22 <bollu> for a hackerrank question I'm trying to solve
06:45:58 <merijn> koomi: ThreadScope
06:46:07 <bollu> It's half done, but I came here  because partially applying functions and trying to cleverly use higher order functions is just getting frustrating :(
06:46:12 <bollu> I'd appreciate any help
06:46:25 <koomi> merijn: can threadscope inspect a running program?
06:46:43 <bollu> should I use the "state monad" or something to deal with this? I know it exists and can be used for side effects (?)
06:46:49 <merijn> koomi: Not sure
06:47:02 <merijn> bollu: FYI, some simplification you can do on line 21-22
06:47:11 <merijn> bollu: IO is a functor, so you can use fmap
06:47:15 <merijn> :t fmap
06:47:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:47:22 <koomi> I think it can only analyze an EventLog after the fact
06:47:42 <merijn> bollu: So you can do, for example, "fmap splitWhitespace TIO.getLine"
06:48:42 <bollu> @merjin: that's not all it's doing though - that will just give me IO [Text], I want an IO [a]
06:48:42 <lambdabot> Unknown command, try @list
06:49:31 <bollu> and, what about, say, takeSubarray and fuseSubarrays?
06:49:35 <bollu> those felt very clunky
06:49:52 <lyxia> bollu: Indeed you can do some fusion here.
06:49:59 <merijn> bollu: So I'd write readTArr as, for example, http://lpaste.net/133976
06:50:27 <merijn> bollu: I'll look. Also, you may wanna avoid tabs
06:50:46 <bollu> ah, yeah. I realized that when the formatting got wonky in the gist :)
06:51:38 <merijn> bollu: http://lpaste.net/133977
06:51:42 <bollu> merjin: your example just confuses me. I know that <$> is infix fmap (sorta, the applicative instance), so I rewrite it as fmap $ map (read . T.unpack) . splitWhitespace TIO.getLine 
06:51:47 <bollu> which confuses the heck out of me
06:51:52 <bollu> and I don't know what it does anymore
06:51:59 <merijn> bollu: That's because what you wrote does something different
06:52:07 <merijn> What I wrote is equivalent to
06:52:20 <lyxia> bollu: fusedSubArrays <- M.replicateM numQueries (fuseSubarrays arr1 arr2 `fmap` constructQueries `fmap` readTArr)
06:52:25 <merijn> "fmap (map (read . T.unpack) . splitWhitespace) TIO.getLine"
06:52:49 <merijn> bollu: Or "let foo = map (read . T.unpack) . splitWhitespace in fmap foo TIO.getLine"
06:53:27 <bollu> oh, so you use the outer fmap to "enter" into the IO monad
06:53:34 <merijn> bollu: For the subarray one (note that these are lists, not arrays) the simple solution I'd use as in my link is "take the first END items from the list, then drop the first start" and you keep "start - end"
06:53:38 <merijn> bollu: Right
06:54:05 <bollu> merijn: how do I read the inner "map" ?
06:54:11 <bollu> map (read . T.unpack) . splitWhitespace
06:54:18 <bollu> what is getting "." ed to what?
06:54:26 <merijn> :t map
06:54:27 <lambdabot> (a -> b) -> [a] -> [b]
06:54:34 <merijn> :t map (read . T.unpack)
06:54:35 <lambdabot>     Not in scope: ‘T.unpack’
06:54:35 <lambdabot>     Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)
06:54:39 <merijn> whoops
06:54:47 <merijn> :t map read
06:54:48 <lambdabot> Read b => [String] -> [b]
06:54:57 <lyxia> bollu: (map (read . T.unpack)) . splitWhitespace
06:55:03 <merijn> bollu: Remember that "f . g" is the same as "\x -> f (g x)"
06:55:38 <merijn> So "map (read . T.unpack) . splitWhitespace" is the same as "\x -> map (read . T.unpack) (splitWhitespace x)"
06:55:42 <bollu> lyxia: the whitespace trips me
06:56:11 <bollu> merijn: ah, that is much clearer
06:56:17 <bollu> merijn: pointfree is confusing :(
06:56:35 <merijn> bollu: The same way "read . T.unpack" feeds the result of T.unpack to read, "map (read . T.unpack) . splitWhitespace" feeds the result of splitWhitespace to "map (read . T.unpack)"
06:56:53 <merijn> bollu: You quickly get used to it if you start reading it like pipelines of transformations :)
06:57:18 <merijn> . is a lot like your shell's "|" but in reverse order
06:57:49 <merijn> So "cat foo | grep" would be like "grep . cat foo" in haskell
06:58:01 <bollu> merijn: the way everything is whitespace makes it confusing, like, I wasn't sure if the map [...] . splitWhitespace was combining with the map or with the T.unpack
06:59:07 * hackagebot monad-resumption 0.1.1.5 - Resumption and reactive resumption monads for Haskell.  http://hackage.haskell.org/package/monad-resumption-0.1.1.5 (IanGraves)
06:59:21 <bollu> merijn: I'm guessing the () around the (read . T.unpack) stops the . readWhitespace to combine with the (read. T.unpack) right? 
07:00:05 <ClaudiusMaximus> hvr: hi! got time to review some code that deals with integer-gmp and ghc-prim to marshall Integer to/from mpz_t?  tests pass, but i might have missed something system-dependent or otherwise unsafe..   http://code.mathr.co.uk/hgmp/blob/HEAD:/src/Numeric/GMP/Utils.hs
07:00:58 <merijn> bollu: Well, you want to partially map, right?
07:01:09 <bollu> yeah
07:01:13 <merijn> bollu: And the function you wanna partially apply it to is "read . T.unpack"
07:01:18 <bollu> yes
07:01:54 <merijn> bollu: If you would leave you the parenthesis, like "map read . T.unpack . splitWhitespace" then it'd parse like "(map read) . T.unpack . splitWhitespace"
07:02:03 <merijn> bollu: Because prefix application binds tighters than operators
07:02:14 <bollu> ah
07:02:23 <merijn> So you need the parenthesis to get map to treat "read . T.unpack" as a single argument
07:02:59 <bollu> hmm, I see
07:03:08 <bollu> and, is the constructQueries function okay?
07:03:27 <bollu> or is there a less brute-force method than to destructure the array and then re-tuple it up?
07:04:44 <merijn> I don't see any obvious improvements, but I'm too lazy to figure out exactly what the entire code is doing, so it might be possible to do it simpler
07:08:59 <bollu> okay, I'm stuck even more now - how do functionally sort?
07:09:06 <bollu> I don't know how to sort without mutating
07:09:41 <merijn> I don't suppose you mean
07:09:44 <merijn> :t sort
07:09:46 <lambdabot> Ord a => [a] -> [a]
07:12:43 <bollu> merijn: yes, but, how would I implement it myself?
07:12:55 <bollu> like, I *think* I can implement all of the functions I'm using right now in my code
07:13:13 <bollu> but I have no idea as to how I would implement sort if I had to 
07:13:20 <bollu> that's unsettling
07:13:29 <merijn> mergesort?
07:14:11 <bollu> merijn: hm
07:14:14 <bollu> that seems doable
07:14:18 <bollu> I'll give it a try :)
07:15:32 <maerwald> afair quicksort isn't really a functional algorithm anyway
07:16:04 <bollu> maerwald: so, well, what would you recommend?
07:16:47 <maerwald> bollu: dunno, here's an interesting blog post about it http://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html
07:16:47 <saep> Set.toAscList . Set.fromList
07:16:56 <bollu> thanks
07:17:01 <saep> Oh wait, that removes duplicates. :(
07:17:58 <bollu> qsortA :: forall i a . (Num i, Ix i, Ord a Bool) => Array i a -> Array i a. someday :)
07:19:03 <maerwald> bollu: ?
07:19:13 <bollu> what's the forall doing there?
07:19:23 <maerwald> his final qsort has exactly the same type signature as thew prelude version
07:19:43 <maerwald> he needs it for the where clause
07:20:13 <maerwald> so "i" and "a" of the top-level type signature are actually the same as in the "sa" inline function
07:20:17 <merijn> Haskekll's sort is a mergesort
07:20:32 <merijn> quicksort is a pretty dumb thing to implement in haskell
07:22:11 <maerwald> if I'd limit myself to only algorithms that can be done nicely in a functional way, I'd not use haskell at all
07:22:28 <merijn> mergesort is easier and more efficient in haskell
07:22:52 <maerwald> but it's not quicksort
07:23:09 <merijn> Right, but the question was how to sort, not how to quicksort...
07:23:46 <maerwald> and quicksort and mergesort do not have the same properties
07:24:13 <schoppenhauer> hm. is it possible to allow overlapping specialisations in typefamilies? to give default implementations of functions?
07:24:28 <merijn> schoppenhauer: Only with closed type families
07:24:40 <schoppenhauer> merijn: how can I "close" them?
07:25:09 <merijn> schoppenhauer: Using the syntax like here: https://gist.github.com/merijn/6130082
07:26:17 <bollu> why does this not work: (length [1, 2, 3]) / 2
07:26:22 <schoppenhauer> merijn: What does it do?
07:26:42 <cjd> Is there an easy way to make an integer type with upper and lower bounds ?    (easier than a constructor)
07:26:58 <merijn> schoppenhauer: That example make "foo" id for all types EXCEPT Int and ()
07:27:30 <bollu> :t length
07:27:32 <lambdabot> Foldable t => t a -> Int
07:27:46 <bollu> I can't divide an Int?
07:28:04 <merijn> Not using /
07:28:09 <merijn> :t (/)
07:28:11 <lambdabot> Fractional a => a -> a -> a
07:28:12 <merijn> :t div
07:28:13 <lambdabot> Integral a => a -> a -> a
07:28:19 <bollu> is that floor?
07:28:26 <merijn> Integer division is done using div, fractional division is using /
07:28:33 <merijn> > 5 `div` 2
07:28:35 <lambdabot>  2
07:28:37 <bollu> ah
07:28:40 <bollu> thanks :)
07:28:52 <merijn> Alternatively
07:28:58 <merijn> @quote monochrom fromIntegral
07:28:58 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
07:30:12 <schoppenhauer> merijn: your code does not compile ... I use 7.6.3 .... does this require a newer ghc?
07:30:43 <merijn> I think it should compile using 7.6
07:30:56 <merijn> But I haven't tested it on anything earlier than 7.8 for a while
07:31:15 <mr-> wow.. 7.6.3 is two years old
07:32:53 <geekosaur> I don't think that (https://gist.github.com/merijn/6130082) works in 7.6
07:33:10 <schoppenhauer> ok, it compiles in a newer ghc
07:34:54 <cjd> another dumb question: it looks like I'm going to be defining a crap ton of functions, is there a way to scope a function's definition (other than a module which has to be the whole file)
07:35:13 <tomjaguarpaw> Does anyone know who dylukes is?  He/she asked a question about opaleye
07:35:19 <cjd> I don't want to sit around trying to remember if I'm referencing one of my own functions or something in the prelude
07:35:21 <tomjaguarpaw> I would like to try to answer.
07:35:43 <bollu> how do I pattern match something like [a0, a1, ..]
07:35:51 <bollu> take only the first two elements of an n element list?
07:36:33 <bollu> I tried [a, b:xs]
07:36:37 <bollu> but that doesn't work
07:36:38 <saep> bollu: (x:y:_)
07:36:40 <exio4> (a:b:xs)
07:36:44 <bollu> ah
07:36:47 <bollu> why the () ?
07:38:17 <saep> Precedence rules. Anyhow, remember that [**] is just convenient syntax and (:) is the actual constructor for lists.
07:39:03 <exio4> bollu: [a,b,c,d] is just syntatic sugar to (a : (b : (c : (d : [])))) 
07:39:43 <exio4> you also pattern match on a list the same way you construct one, using either [] (the empty list) or (;) (cons)
07:40:01 <schoppenhauer> merijn: hm. but using your code, I cannot add a specialized definition for foo
07:40:36 <schoppenhauer> (or at least I dont know how)
07:40:50 <exio4> those parenthesis aren't needed, either, (:) associates to the right, so, a:b:c:d:[] also works, but now
07:41:11 <exio4> f x : xs = ... would be (f x) : xs = ... which isn't what we want
07:41:22 <exio4> so we have to use f (x : xs) = ...
07:41:39 <exio4> sometimes it isn't needed, though :) 
07:41:59 <exio4> > case [1,2,3,4] of [] -> 0; x : xs -> x 
07:42:01 <lambdabot>  1
07:42:57 <fizbin> Does anyone know of a good haskell code -> HTML converter? I want to create a version of my code for people in my company to review and it'd be really nice if they could do things like hover over symbols to get types, and click through to jump to a definition.
07:45:39 <schoppenhauer> ah
07:45:45 <schoppenhauer> I think I understand ...
07:47:39 <dfeuer> I'm glad, schoppenhauer.
07:52:57 <tomjaguarpaw> fizbin: If you find one you should integrate it into Haddock :)
07:53:48 <fizbin> I found one that someone apparently did back in 2011, but dependency issues prevented getting it all the way integrated into Haddock.
07:54:21 <fizbin> E.g. see http://goto.ucsd.edu/~rjhala/Annot/Cabal/src/Distribution-Simple-Install.html#install
07:54:59 <fizbin> It doesn't do the click-to-go-to-definition thing though.
07:57:42 <simon> http://lpaste.net/955754837541126144 - have I got the wrong base installed?
08:05:08 <merijn> simon: The pakage you're trying to install is incompatible (or at least claims to be) with your GHC
08:12:58 <bollu> how do I construct a Float from an Int?
08:13:04 <bollu> Float doesn't have a data constructor
08:13:13 <merijn> fromIntegral
08:13:16 <schoppenhauer> merijn: ok, I do not see how this can solve my problem :\
08:13:20 <bollu> thanks :)
08:14:07 <merijn> schoppenhauer: This is the only way to do overlapping type families, so if this can't work for you, you have a problem
08:14:13 <bollu> is there a nice way to write (arr[len(arr)] + arr [len(arr) - 1]) / 2.0
08:14:33 <schoppenhauer> merijn: I have a class declaration and several instance declarations. and I use -XTypeFamilies. But I do not see how I can use your restriction to declare overlapping instances.
08:14:47 <bollu> (arr[len(arr) / 2] + arr [(len(arr) - 1) / 2]) / 2.0
08:14:52 <merijn> schoppenhauer: oh, for the class?
08:14:54 <bollu> sorry. ^ was the right thing
08:14:59 <bollu> I'm trying to find the median of a list
08:15:08 <bollu> and the haskell version is becoming gargantuan
08:15:21 <schoppenhauer> merijn: for the methods of an instance. I want to have default implementations of methods.
08:15:53 <bollu> this is my current version:               (fromIntegral (arr !! (length arr `div` 2)) + fromIntegral (arr !! ((length arr - 1) `div` 2))) * 0.5
08:17:18 <schoppenhauer> merijn: I see why this is a problem, but defining a method "for all types except ..." in one instance and for the except-types in other instances sounds correct
08:17:22 <copycat> Could not find module ‘Text.Search.Sphinx.ExcerptConfiguration’
08:17:29 <copycat> i thought text should be a standard module?
08:17:35 <schoppenhauer> merijn: I am just not sure how to do this with your example
08:17:41 <copycat> i tried installing text, and it says that i already have it installed
08:17:44 <merijn> schoppenhauer: That's not what I intended, I thought you were talking about overlapping type families
08:17:47 <copycat> what should i do?
08:17:51 <merijn> schoppenhauer: And this was just an example of those
08:18:08 <merijn> copycat: That module is not in text
08:18:51 <schoppenhauer> merijn: As I said, I have a type family T a. And specialized instances T Int, T Bool, etc.
08:19:18 <schoppenhauer> merijn: but in many cases, a default implementation would be possible
08:19:45 <merijn> schoppenhauer: http://lpaste.net/133984 ?
08:21:06 <schoppenhauer> merijn: something like that, yes. but there I cannot implement the functions for this type family. or at least I am not sure how.
08:22:00 <schoppenhauer> merijn: like in that example, defining + for char and bool (addition modulo 2, 65536, etc.)
08:22:09 <copycat> merjin: which module is it in then? i installed sphinx as well, but it's still not working
08:22:33 <merijn> copycat: No idea, tbh, I just know it's not in text :)
08:23:24 <copycat> oh..
08:23:44 <copycat> what does it mean by using -v?
08:23:47 <copycat>     Could not find module ‘Text.Search.Sphinx.Types’
08:23:48 <copycat>     Use -v to see a list of the files searched for.
08:24:59 <freeman42> anyone knows what is the proper way to reuse an HDBC connection across different Warp requests?
08:26:26 <schoppenhauer> can I have something like an instance T "anything except Int, Char, Bool", and then T Int, T Char, T Bool?
08:33:23 <athan> schoppenhauer: What do you mean?
08:33:37 <athan> please don't reiterate ._.
08:33:53 <freeman42> found this http://stackoverflow.com/q/9832876/750216 not sure how to use it yet
08:34:52 <Geraldus> hi friends!
08:37:07 <schoppenhauer> athan: I have a type family class declaration with some instances
08:37:37 <schoppenhauer> athan: and I want to define an implementation for "everything except" these instances
08:37:52 <copycat> aaah god...
08:37:56 <copycat> how can i resolve missing modules?
08:38:04 <copycat>     Could not find module ‘Text.Search.Sphinx’
08:38:05 <copycat>     Use -v to see a list of the files searched for.
08:38:11 <copycat> i've done cabal install sphinx
08:38:17 <copycat> but it doesn't show up on ghc-pkg list
08:38:20 <schoppenhauer> hm. I think I'll just use disjunctive types ...
08:38:31 <copycat> i've looked up on google, and i can't find any helpful links..
08:39:13 <athan> copycat: Are you working in a cabal package?
08:39:28 <copycat> a cabal sandbox?
08:39:31 <athan> if so, add sphinx to your `build-depends:` thingy
08:39:36 <copycat> i'm not sure what that means
08:39:50 <athan> copycat: no, just a package, where you'll see a `foo.cabal` file at the top-level of all your source code
08:40:14 <copycat> OH!
08:40:16 <copycat> ok
08:40:19 <copycat> i'm editing that file now
08:40:33 <ahills> Hey all, I'm having trouble building GHC against musl via these binaries: http://www.reddit.com/r/haskell/comments/37m7q7/ghc_musl_easier_static_linking/
08:40:37 <copycat> can i update it through the terminal instead?
08:40:52 <Welkin> copycat: I don't think so
08:40:56 <ahills> Very early in the ./configure, I get: /usr/lib/gcc/x86_64-alpine-linux-musl/4.9.2/../../../../x86_64-alpine-linux-musl/bin/ld: utils/ghc-pwd/dist-boot/Main.o: relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC
08:40:58 <schoppenhauer> ok, no, disjunctive types are bad because I want static type safety
08:41:35 <schoppenhauer> athan: is it clear what I want now, at least?
08:41:37 <copycat> which build-depends is it?
08:41:39 <ahills> Unfortunately, there's no helpful output indicating what's missing -fPIC
08:41:46 <nolraiU> What are disjuncttive types?
08:41:58 <copycat> i've added sphinx manually, and runhaskell still gives me the same errror
08:42:04 <schoppenhauer> nolraiU: I meant disjunction types, sorry
08:43:13 <athan> schoppenhauer: No, you're right
08:43:15 <ahills> If anyone familiar with the GHC build system has any ideas where to start, please let me know
08:43:17 <athan> sum types ~ disjunction
08:43:44 <athan> schoppenhauer: But, I'm still confused on what you mean. Can you write me an lpaste of your classes & instances, and desired instances?
08:48:31 <geekosaur> ahills, you might ask in #ghc
08:48:48 <ahills> geekosaur: good idea, thanks! :)
08:49:13 * hackagebot ekg-statsd 0.2.0.3 - Push metrics to statsd  http://hackage.haskell.org/package/ekg-statsd-0.2.0.3 (JohanTibell)
08:49:40 <geekosaur> (I have a very vague recollection that that means something in your build tools (e.g. ld) is out of date, but someone there would know)
08:50:46 <schoppenhauer> athan: http://lpaste.net/5648671508013252608
08:51:37 <athan> schoppenhauer: Impossible, sorry :\
08:52:07 <athan> that would mean that you would know the behavior of everything in advance, which is universal polymorphism, aka parametric polymorphism
08:52:24 <athan> typeclasses are ad-hoc polymorphism, implementing the behavior _for each case_
08:53:05 <athan> It's lame, I know :\
08:53:18 <athan> keep grinding, though, you'll find an answer :)
08:53:24 <schoppenhauer> ok
08:56:00 <nolraiU> Okay who thought that having build not save all open files was a good idea?
08:56:41 <merijn> nolraiU: huh?
08:57:14 <DanC>  cabal: The package 'capDL-tool' requires Cabal library version -any && >=1.18
08:57:14 <DanC>  but no suitable version is installed.
08:57:19 <DanC> $ cabal --version
08:57:19 <DanC> cabal-install version 1.22.4.0
08:57:19 <DanC> using version 1.22.2.0 of the Cabal library
08:57:20 <Cornetillo> Hi
08:57:34 <Welkin> DanC: please use @lpaste to paste errors and code
08:57:38 <Welkin> do not paste it in the channel
08:57:43 <Welkin> @lpaste
08:57:43 <lambdabot> Haskell pastebin: http://lpaste.net/
08:57:45 <Cornetillo> This is a social channel?
09:00:19 <hexagoxel> DanC: the Cabal version that the `cabal` executable was compiled with in general has nothing to do with the Cabal library in your package-db
09:00:38 <lpaste> DanC pasted “struggling with seL4 haskell deps” at http://lpaste.net/133987
09:01:17 <hexagoxel> DanC: `ghc-pkg list Cabal` probably contains the info you want
09:01:23 <DanC> "Cabal library version -any && >=1.18" has nothing to do with "using version 1.22.2.0 of the Cabal library"?
09:02:18 <DanC> `ghc-pkg list Cabal` shows /var/lib/ghc/package.conf.d Cabal-1.16.0. color me thoroughly confused.
09:03:14 * DanC gets rid of Ubunut's ghc
09:04:05 <DanC> now I don't have ghc-pkg.
09:04:20 <hexagoxel> DanC: when `cabal --version` says "using", it means "compiled with"
09:04:38 <nolraiU> So if I wanted to set up vim as an ide for haskell, but know nothing about extentions for vim should I ask about haskell or vim ide in general first?
09:04:45 * DanC wonders how to get ghc-pkg from nix ...
09:04:51 <nolraiU> (Does that question even make sense?)
09:05:33 <DanC> I'd google for all of the above, nolraiU. Odds are good somebody's written a blog post just for you.
09:05:50 <hexagoxel> DanC: and cabal will not use the Cabal in your package-db (what ghc-pkg reports) (unless special cases (...))
09:06:15 <Welkin> DanC: you can install the generic debian binaries for ghc
09:06:29 <Welkin> https://www.haskell.org/platform/linux.html
09:06:36 <DanC> I'm downloading them as we speak
09:06:53 * hexagoxel wonders if whoever made the Cabal/cabal/cabal-install naming decision knows all the confusion it created
09:07:02 <DanC> nix looked cool, but it's turning out to be quite a learning curve and what I'm really interested in is seL4
09:07:10 <Welkin> cabal cabal cabal!
09:07:33 <Welkin> nix is popular around here
09:07:36 <Welkin> though I have never used it
09:08:25 <DanC> hang on... generic debian binaries? the only generic I see is a tar file
09:08:39 <DanC> ah... "For generic, Deb 7, style systems"
09:08:58 <Welkin> yes
09:09:00 <Welkin> you untar it
09:09:45 <schoppenhauer> athan: ok, but ... is it at least possible to give the same implementation for a finite list of types?
09:10:02 <schoppenhauer> athan: I mean, this is possibly by just copypasting... but maybe its possible directly.
09:10:41 <nolraiU> schoppenhauer: what are you trying to do?
09:11:12 <athan> schoppenhauer: Have you heard of HList?
09:11:18 <athan> oh wait
09:11:18 <athan> sorry
09:11:24 <athan> don't go down that rabbit hole
09:11:35 <athan> You'll just need to make multiple instances
09:12:28 <schoppenhauer> nolraiU: actually I am trying to hack around an (arguable) design failure in coq's program extraction
09:12:36 <schoppenhauer> athan: so ... copypasting it is?
09:13:09 <athan> schoppenhauer: Well I mean, if your typeclass doesn't implement generalized behavior for /different/ instances, then yes
09:13:43 <schoppenhauer> athan: ah ok ... but I have the same behavior for Int, Float, etc.?
09:14:22 <nolraiU> Maybe generics are what you want?
09:14:31 <nolraiU> What is this typeclass?
09:14:32 <DanC> so... now that I have haskell-platform installed, `cabal update` tells me to `cabal install cabal-install` at which point it starts compiling 79 things. this is as designed?
09:14:58 <nolraiU> DanC: yes.
09:15:08 * DanC wonders how many times he's compiled Distribution.PackageDescription in the last 2 days
09:16:31 * CoconutCrab starts learning nix
09:17:23 <fionnan> hey all, I'm trying to figure out a way to make `conn <- connectSqlite3` some sort of global variable so it doesn't get executed everytime a new request is made in this warp server script https://bpaste.net/show/7fdec02c999b
09:17:39 <fionnan> any pointers would be much appreciated :)
09:17:49 <DanC> then 77 more things... then after all that, it says I should `cabal install cabal-install` again.
09:17:49 <nolraiU> IORef?
09:18:18 <fionnan> nolraiU: are you replying to me?
09:18:52 <DanC> ah: export PATH=~/.cabal/bin:$PATH
09:19:02 <nolraiU> Yes. But actually, the reader monad transformer might be better.
09:19:50 <nolraiU> Trying to remember how I solved the 'I want a global value to get made once' problem.
09:20:36 <nak> i'm trying to find the source code for the maybe monad
09:21:01 <nak> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/Data-Maybe.html#t:Maybe
09:21:15 <nak> when i click "Monad" it just takes me to the Monad docs
09:21:20 <DanC> whew. capDL builds now. Thanks for the clues!
09:21:21 <fionnan> nolraiU: cool, thanks!
09:21:29 <schoppenhauer> nolraiU, athan: I just found DefaultSignatures
09:21:36 <schoppenhauer> it appears to do what I want ...
09:22:16 <ion> nak: A recent enough version of haddock has links to instance definitions, but that documentation hasn’t been built with it unfortunately. You can look at the source of the module though, and just search for the instance.
09:22:28 <nolraiU> nak: Yeah, thats sort of a bug, but its a small file, click the source link in the top right.
09:23:09 <schoppenhauer> or am I wrong?
09:23:30 <ion> Click on the Source link on the “data Maybe a” line, that will take you to the right file.
09:24:12 <nolraiU> schoppenhauer: what do you want to do again?
09:24:58 <schoppenhauer> nolraiU: have default implementations
09:25:03 <nak> nolraiU thank you
09:26:56 <nolraiU> schoppenhauer: you can just have default implementations of typeclass methods.
09:27:00 <osa1> any ideas why this is not working: http://lpaste.net/133988 ?
09:27:39 <nak> > map (+2) [2]
09:27:42 <lambdabot>  [4]
09:27:48 <nak> > map (+2) (Just 2)
09:27:49 <lambdabot>      Couldn't match expected type ‘[b]’ with actual type ‘Maybe Integer’
09:27:50 <lambdabot>      In the second argument of ‘map’, namely ‘(Just 2)’
09:27:50 <lambdabot>      In the expression: map (+ 2) (Just 2)
09:27:53 <nak> > fmap (+2) (Just 2)
09:27:55 <lambdabot>  Just 4
09:28:00 <osa1> > coerce (10 :: Int32) :: Int
09:28:00 <schoppenhauer> nolraiU: ah, I see ... it does not work when I want to change the data structure.
09:28:02 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘f0 b0’
09:28:02 <lambdabot>      In the expression: coerce (10 :: Int32) :: Int    Couldn't match expecte...
09:28:02 <lambdabot>      In the first argument of ‘coerce’, namely ‘(10 :: Int32)’
09:28:15 <nak> i'm confused why a `fmap` is required instead of `map` in this case? Why have a separate mapping function ?
09:28:30 <nak> why should (Just 2) be treated special in comparison to [2]
09:28:48 <mniip> last time I heard someone answer this, it was about meaningful error messages
09:28:48 <hvr> because ppl back then were to worried to have map==fmap 
09:28:51 <nolraiU> Its so map has an easier type signature for newbies.
09:29:16 <Cale> Yeah, it's kind of silly that they're different now that Foldable is in the Prelude :(
09:29:18 <nak> i feel like that makes it less flexible 
09:29:25 <nolraiU> It does.
09:29:39 <nolraiU> Lambda bot used to redefine map as fmap.
09:29:44 <nak> if i have a function that takes a mappable, now i have to figure out whether to call map or fmap :{
09:29:48 <nak> fmap (+2) [2]
09:29:52 <nak> > fmap (+2) [2]
09:29:53 <Cale> In Haskell 1.4, map :: Functor f => (a -> b) -> f a -> f b
09:29:55 <lambdabot>  [4]
09:29:59 <nak> oh ok, that's kinda cool
09:30:15 <nak> so should i just be using fmap everywhere ?
09:30:23 <quchen> Cale: It would be Hell to change that back though. :-(
09:30:24 <Welkin> haskell 1.4?
09:30:24 <hvr> nak: if you like...
09:30:26 <nolraiU> Just use fmap, unless you want to be very clear that you are using a simple list.
09:30:36 <Cale> Welkin: Yeah, the version before Haskell 98
09:30:43 <hvr> Welkin: https://www.haskell.org/definition/haskell-report-1.4.ps.gz
09:30:49 <Welkin> oh
09:30:52 <Welkin> we are on 2010
09:31:03 <Cale> 2010 is basically 98 :P
09:31:11 <quchen> Welkin: Haskell 1.4 is what we want to introduce again, basically. ;-)
09:31:15 <Cale> Very few changes were made
09:31:22 <Welkin> I never use map anyway
09:31:32 <Cale> Really?
09:31:32 <quchen> ?quote elliott H2010
09:31:33 <lambdabot> elliott says: An interesting exercise is to try and imagine a language revision more conservative than H2010.
09:31:34 <Welkin> even in a case where I would use map (a list) I use fmap
09:31:38 <nak> this is validating for me tho; i'm glad that my suspicion about this rigidness is identified by other members in the community
09:31:41 <Cale> ah
09:31:44 <nak> it makes me feel like i sorta "get it"
09:31:57 <Cale> I use map when I know it's a list
09:31:59 <nolraiU> I've gotten very used to <$>. 
09:32:11 <hexagoxel> nak: there are some cases where the specialized versions of functions are simply more readable
09:32:24 <hvr> quchen: btw, I've started editing in the AMP into https://github.com/hvr/haskell-report/commits/hvr/h201x
09:32:34 <Cale> Using fmap when you know it's a list *does* sacrifice a little bit of readability
09:32:47 <hvr> quchen: just for fun :)
09:33:33 <nolraiU> And when you have multiple layers one of which is a list, that can really help.
09:33:33 <hexagoxel> nak: for example, (.) is a special fmap as well
09:33:43 <hexagoxel> > (+1) <$> (*2) $ 2
09:33:44 <Cale> If you always use the Functor-generalised map function, then you make the reader of your code do a little bit more typechecking in their head to figure out what's going on.
09:33:46 <lambdabot>  5
09:34:30 <Welkin> well, they can see from the type declaration what it is
09:34:39 <nolraiU> Yeah, you can get some really crazy unreadable combinations of fmaps.
09:34:56 <nak> Cale acknowledged
09:36:05 <nolraiU> I mean I would still wished map = fmap, and say..lmap = map.
09:36:19 <quchen> hvr: Oh, the Report is publically available?
09:36:23 <quchen> In source form, that is
09:36:35 <shachaf> lmap :: Profunctor p => (a -> b) -> p b x -> p a x
09:36:35 <quchen> Neat, I had no idea.
09:36:47 <hvr> quchen: it always was... as a darcs repo
09:37:04 <hvr> quchen: or actually multiple darc repos
09:37:11 <nolraiU> shachaf: Yeah..left and list starting with the same letter is unfortunate.
09:37:24 <nolraiU> Oh, well what we have is not so bad.
09:38:46 <quchen> hvr: In other words, "as a note on a board on Omega Persei 8"
09:39:22 <nolraiU> Eh..only behind the "beware of jagwire" sign.
09:47:46 <pharpend> :t rmap
09:47:47 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
09:52:42 <hvr> quchen: is that a hitchhikers guide ref or a futurama ref? :)
09:55:34 <mniip> help me come up with a typeclass name, something along the lines of ...functor, with a function of type :: (a -> b) -> (b -> a) -> f a -> f b
09:56:47 <Hafydd> What does it do?
09:57:35 <hvr> mniip: what is the (b->a) used for?
09:57:53 <mniip> hvr, for contravariant appearances of the type variable
09:58:05 <supki> mniip: that's Invariant
09:58:22 <mniip> oh
09:58:25 <mniip> so it exists
09:58:31 <cwraith> You could make it (a -> b) -> (b -> a) -> (f a -> f b, f b -> f a)
09:58:51 <shachaf> That class is called Invariant.
09:58:55 <cwraith> since you can go both directions even with invariant functors
09:59:03 <shachaf> Oh, supki already said so.
09:59:55 <cwraith> I guess there's no point in doing that, though.  Just reverse the first two arguments, and you swap what direction it goes
09:59:56 <quchen> hvr: Yes, it is!
09:59:57 <mniip> hm
10:00:05 <mniip> interesting how there's no instance Invariant Endo
10:00:12 <hvr> quchen: :-)
10:00:33 <shachaf> I made some lenses based on Invariant. They were great.
10:00:42 <ion> @hoogle Invariant
10:00:43 <lambdabot> package invariant
10:00:43 <lambdabot> package affine-invariant-ensemble-mcmc
10:00:43 <lambdabot> Data.Text.Internal.Lazy lazyInvariant :: Text -> Text
10:00:46 <shachaf> Using those lenses we figured out how the real Prism should be defined.
10:25:55 <GLM> What is the best way to validate something at the type level? For example, a phone number
10:26:22 <mniip> why are you carrying a phone number in a type
10:26:41 <GLM> mniip:Why wouldn't you?
10:26:50 <Welkin> data PhoneNumber a = PhoneNumber a a a a a a a a a a a
10:27:07 <whiteline> depends on the properties of the number
10:27:15 <Welkin> for the form X XXX XXX-XXXX
10:28:24 <GLM> Is there a way (without dependent types) to set what kind of values? For example, it doesn't make sense to have Silicon valley be in Washington at the type level of an address
10:29:00 <mniip> Welkin, that's not a phone number
10:29:25 <whiteline> GLM: you could have cities and towns
10:29:33 <Welkin> international code + area code + 7-digit number
10:29:35 <Welkin> for the US
10:30:11 <GLM> whiteline:True but not all cities are allowed in all towns
10:30:14 <GLM> *states
10:30:15 <mniip> more like, data PhoneNumber a b c d e f g h i j
10:30:35 <GLM> mniip:You want to make sure they all have the same type
10:30:53 <mniip> you mean same kind?
10:31:08 <GLM> mniip:Still not entirely sure on that defiintion
10:32:05 <mniip> GLM, I don't think you use the term "on type level" correctly
10:32:22 <GLM> Most likely not
10:34:06 <jmcarthur> if i really wanted it to be structured that much, i would "just" define the syntax of all possible phone numbers as an adt
10:34:31 <jmcarthur> but that seems really difficult to maintain, and i have no idea how to be confident that i'm not rejecting valid numbers somehow
10:46:03 <nolraiU> So I thought ghc-mod was kaput?
10:47:30 <zed_> hi : ) i have a simple problem to which I have a solution but I am wondering if there is a better way to do this. let's say that I have a list of n elements, and I want to sum the last 5 elements. my solution is to reverse / take / sum. what would be a better way to do this ?
10:48:39 <Cale> zed_: That's probably the right way
10:49:39 <tromp_> there's no simpler and no faster way
10:50:19 <zed_> it seems cumbersome... alas. thanks !
10:50:23 <Cale> Well, storing the list in the reverse order in the first place might be an option
10:50:29 <Cale> Or using a data structure which is not a list
10:50:39 <Cale> Lists are intended to be traversed in a particular order
10:50:59 <Cale> You should think of a list as being like a loop which hasn't happened yet
10:51:04 <nolraiU> Yeah, sometimes I wish List was caled Stack.
10:51:20 <Cale> Your operation is kind of like "how do I add up the values that occur in the last 5 iterations of this loop?"
10:51:38 <Cale> This is an unnatural thing to do, and so you can kind of expect it to be cumbersome
10:52:21 <bollu> I'm trying to find the median of an array of even size - and I have this expression for it - (fromIntegral (arr !! (length arr `div` 2)) + fromIntegral (arr !! ((length arr - 1) `div` 2))) * 0.5
10:52:21 <bollu> can I simplify this?
10:53:56 <nolraiU> bollu: assuming it's sorted?
10:54:01 <bollu> yes
10:54:44 <nolraiU> You can pull the fromIntegral to after the addition.
10:56:39 <mniip> bollu, you can do an entirely different approach
10:56:44 <nolraiU> Hmm. I would write it as let mid = length arr `div` 2 in (fromIntegral ((arr !! mid) + (arr !! mid - 1)) ) * 0.5
10:56:45 <bollu> which is?
10:57:02 <bollu> nolraiU: that's much cleaner!
10:58:03 <c_wraith> bollu: note that if you are using [], that's not an array, and (!! k) takes O(k) time
10:58:25 <bollu> c_wraith: wait, [ ] is _literally_ a linked list? o_O
10:58:26 <nolraiU> c_wraith: I thought something looked wrong to me.
10:58:32 <c_wraith> bollu: yes
10:58:37 <mniip> @let median = join go where go (_:_:xs) (_:ys) = go xs ys; go _ (y:ys) = y;
10:58:37 <bollu> I thought it was backed by a vector or something internally
10:58:39 <lambdabot>  Defined.
10:58:43 <bollu> whoa, that's a bummer :(
10:58:45 <nolraiU> Its a linked stack.
10:58:47 <mniip> > median "1234567"
10:58:49 <lambdabot>  '4'
10:59:18 <c_wraith> bollu: you can think of it as    data [a] = [] | a : [a]      if that was syntactically valid
10:59:19 <bollu> mniip: how does that work? kind of a n00b here :)
10:59:25 <raichoo> bollu: You can use Data.Vector list literals can be overloaded :)
10:59:26 <c_wraith> bollu: but that has exactly the same semantics
10:59:27 <bollu> c_wraith: hm
10:59:31 <mniip> oh wait, you have two middle elements
10:59:50 <mniip> go _ (y:y':_) = (y + y') / 2
10:59:51 <bollu> c_wraith: so if I want an honest to god vector, then what do I use? raichoo: is that what data.Vector is?
10:59:51 <mniip> then
10:59:56 <nolraiU> There is also a Data.Array.
11:00:07 <bollu> array being non resizable?
11:00:14 <raichoo> bollu: What nolraiU says.
11:00:15 <c_wraith> bollu: Data.Vector and Data.Array...  And a host of other options with more specialized intended use cases, like repa
11:00:25 <ion> > let tailN n xs = go (drop n xs) xs where { go (_:as) (_:bs) = go as bs; go [] bs = bs } in tailN 5 [0..42]
11:00:28 <lambdabot>  [38,39,40,41,42]
11:00:44 <mniip> ion, not last N, but middle N
11:00:47 <nolraiU> I haven't used Data.Vector so I don't know what it does.
11:00:48 <mniip> in particular, N=2
11:01:27 <bollu> raichoo: is the pattern matching on Data.Vector possible?
11:01:35 <bollu> like, can you have all the list-y niceness with it?
11:01:41 <mniip> bollu, how would you pattern match that
11:01:56 <bollu> mniip: the same way I pattern match on a list?..
11:02:05 <bollu> like, it would be nice if they work
11:02:08 <mniip> it isn't represented as a consy structure
11:02:16 <mniip> how would you uncons it with a pattern match
11:02:27 <nolraiU> View patterns?
11:02:44 <nolraiU> It works on Data.Sequence anyway.
11:02:47 <raichoo> bollu: you can use pattern synonyms and view patterns.
11:02:56 <raichoo> nolraiU: Dammit, you are always faster :D
11:02:56 <bollu> raichoo: what are those?
11:03:09 <bollu> mniip: I don't know what that means :(
11:03:18 <raichoo> bollu: https://ocharles.org.uk/blog/posts/2014-12-02-view-patterns.html
11:03:45 <mniip> well view patterns
11:03:54 <mniip> but that will give O(N) performance on every uncons, right
11:04:06 <nolraiU> They are how to match against one structure, and have it implemented as another.
11:04:30 <nolraiU> mniip: I don't /think/ so..but I've never used Data.Vector so..
11:04:38 <ion> > let middleN n xs = take n (go (drop (n `quot` 2) xs) xs) where { go (_:_:as) (_:bs) = go as bs; go _ bs = bs } in middleN 5 [0..10]
11:04:39 <mniip> neither did I
11:04:40 <lambdabot>  [4,5,6,7,8]
11:04:43 <bollu> nolraiU: oh, that's super interesting'
11:04:52 <ion> not quite
11:04:57 <bollu> hmm, so I'll need to install data.vector? or is it inbuilt?
11:05:59 <nolraiU> So my haskell vim ide wants ghc-mod, which doesn't build anymore.
11:06:31 <nolraiU> But theres like a replacement for ghc-mod in ghc now right?
11:06:36 <nolraiU> Or something?
11:12:46 <geekosaur> nolraiU, ghc-mod will have to be updated (I think it already is but you need to build it from git?)
11:12:50 <zed_> is there someone who ever performed numerical integration in haskell ?
11:13:18 <geekosaur> ghc-mod wraps the GHC API, so in that sense it's "in ghc" --- but you need ghc-mod to *expose* it usefully
11:14:05 <geekosaur> (you really don;t want to deal with the GHC API directly. the fact that ghc-mod broke is evidence of how risky that is...)
11:15:02 <}> Hey is there a default function like : ifStuff x y m = if x == y then return x else m , which can be used in cases like this : ... >>= (\x -> if x == 2 then return x else incState) 
11:15:15 <}> because it seems like a common thing to do...
11:15:26 <bennofs> }: there is bool
11:15:31 <bennofs> > bool a b c
11:15:34 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘Expr’
11:15:34 <lambdabot>      In the third argument of ‘bool’, namely ‘c’
11:15:34 <lambdabot>      In the expression: bool a b c
11:15:34 <}> uhh
11:15:38 <ion> > let takeMiddle n xs = take n (go (drop n xs) xs) where { go (_:_:as) (_:bs) = go as bs; go _ bs = bs } in map (`takeMiddle` "hello world") [0..]
11:15:40 <lambdabot>  [""," ","o ","o w","lo w","lo wo","llo wo","llo wor","ello wor","ello worl",...
11:15:48 <}> :t bool
11:15:50 <lambdabot> a -> a -> Bool -> a
11:15:53 <bennofs> > bool a b True
11:15:54 <lambdabot>  b
11:15:58 <bennofs> > bool a b False
11:16:00 <lambdabot>  a
11:17:38 <}> So I would write \x -> bool (return x) incState (x == 2)?
11:18:39 <nolraiU> What do I lose using ghc 7.8 instead of the most recent?
11:19:18 <bennofs> }: yes, you could do that. Though I'm not sure if that's any better in this case...
11:19:21 <ion> zed: See tailN above for taking the last n elements.
11:19:27 <ion> bollullera: See takeMiddle above for taking the middle n elements.
11:19:55 <ion> Whoops, he left. bollullera: Sorry, failed tab completion.
11:21:40 <}> bennofs, I think something like this would be nicer... ifStuff m y x = bool m (return x) (x == y), which could be used like stuff >>= ifStuff incState 2 -- no need for lambda....
11:22:39 <}> I just think it's rather common to do something like this (?) so I thought there was a default function to do this
11:22:48 <Sonarpulse> does GHC currently use template haskell?
11:22:55 <bennofs> }: there is no default function for it in base afaik
11:23:00 <}> ah ok
11:23:02 <bennofs> Sonarpulse: you mean if base uses template haskell?
11:23:12 <Sonarpulse> No I mean GHC
11:23:25 <bennofs> Sonarpulse: the source of GHC?
11:23:28 <Sonarpulse> yeah
11:23:51 <Sonarpulse> I'm trying to decide if rewritting happy and alex in TH would be a good idea.
11:24:13 <Sonarpulse> It seems things like ghcjs and HalVM are constantly running into problems with those two.
11:24:15 <bennofs> Sonarpulse: from a quick git grep TemplateHaskell, it doesn't seem like it does
11:24:43 <bennofs> Sonarpulse: not sure if TemplateHaskell would solve these? TemplateHaskell is often even trickier to implement, isn't it?
11:24:48 <Sonarpulse> ah ok, so it would be replacing one sort of meta programming with another -- less of a clear improvement
11:25:54 <Sonarpulse> well forking extra processes to convert text seems a lot cruder
11:26:11 <bennofs> Sonarpulse: well, ghcjs forks an external nodejs process to run TH afaik... 
11:26:27 <Sonarpulse> true
11:26:34 <whiteline> par is so elegant
11:26:45 <Sonarpulse> but perhaps a better cross compilling TH storry would help with that
11:26:53 <whiteline> i'd like a parallel state monad of some sort though
11:28:14 <nolraiU> parallel state?
11:31:17 <whiteline> but yeah, i could just combine pmap and evalState i guess
11:31:54 <}> bennofs, I tried using hoogle to find a function with that type ... ((Monad m, Eq a) => a -> m a -> a -> m a), but it seems to ignore the Monad m constraint, I guess I'll just use my own, call it returnIf or something
11:39:21 * hackagebot ekg-push 0.0.3 - Small framework to push metric deltas to a broadcast channel using the ekg-core library.  http://hackage.haskell.org/package/ekg-push-0.0.3 (adarqui)
11:40:26 <solrize> <no location info>:
11:40:26 <solrize>     Ambiguous module name `Control.Monad.State':
11:40:26 <solrize>       it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
11:40:36 <solrize> how do you tell ghci what package to use?
11:41:18 <shachaf> -hide-package monads-tf, or something like that.
11:41:29 <shachaf> Preferably, get rid of monads-tf.
11:43:13 <ion> Preferably, use sandboxes which make this happening in the first place improbable.
11:43:33 <ion> and/or easier to clean up
11:48:05 <ion> zed: https://gist.github.com/ion1/bd4c395a54f32bd06f25
11:51:37 <zed_> ion: thanks !
11:52:09 <nolraiU> Okay..so can one have src and bin directories and use cabal to build a package?
11:53:09 <nolraiU> Or am I compleately confused..
11:59:27 <}> Is there a function like (t1, t2) -> (t1, t2, t3) ? adds something to a tuple... googling reveals things like tuplify2 which just convert lists to tuples
12:01:05 <kristof> what a nick grab
12:01:33 <}> :( let addtup2 (x,y) z = (x,y,z)
12:01:59 <kristof> }: Tuples aren't meant to be extensible, so I would assume not
12:02:24 <nolraiU> Yeah, tupples are kind of ..hmm. hacky isn't the right word.
12:02:44 <nolraiU> Meant for special uses?
12:02:52 <}> they feel like ad-hoc types to me... (a,b) == data Thing a b
12:03:03 <kristof> They're, uh, tuples.
12:03:07 <tdammers> tuples are often misunderstood, is all
12:03:10 <kristof> ^
12:03:21 <tdammers> especially by people coming from other languages *cough*python*cough*
12:03:23 <kristof> I don't know how to explain tuples any simpler than "they're ordered tuples."
12:03:24 <nolraiU> ad-hoc is a good term for it.
12:03:49 <nolraiU> kristof: its not what they are, its what they are /for/ that trips people up I think.
12:03:51 <Rotaerk> tuples are like data structures, but without the nominal typing
12:03:58 <kristof> nolraiU: Sure, ok.
12:04:05 <Rotaerk> every element of it like a field in a data structure
12:04:25 <kristof> Sure, it's a structural type.
12:04:26 <Rotaerk> to think of them as a list/vector is a mistake
12:04:34 <nolraiU> Yep.
12:04:34 <kristof> I don't know, I thought tuples would just come naturally to people.
12:04:38 <shachaf> The type (a,b) has nothing to do with the type (a,b,c) other than similar names.
12:04:51 <}> thanks captain obvious
12:04:59 <dale> (uncurry (,,)) would work
12:05:23 <nolraiU> You can use them to build typed lists, but that looks like (a,(b,c)) and is ugly as hell.
12:05:35 <nolraiU> Or lists of types I mean..
12:05:36 <Guest62453> Hey all - anyone have any experience converting BSON docs to JSON? I'm having trouble doing the conversion and sending a JSON api response
12:05:57 <}> I just noticed ghci has special formatting for very long tuples ... :t (,,,,,,,,,,,,,,,,,,)
12:09:41 <hexagoxel> }: there is append for hlists, but using them for anything but truly dynamic hlists makes no sense imo
12:09:47 <tdammers> kristof: Python kind of ruins tuples that way
12:10:07 <tdammers> in Python, the only difference between lists and tuples is that lists are mutable
12:11:04 <tdammers> particularly, the "arity" (if that's the correct term for tuples) isn't part of the tuple's type in Python
12:11:14 * kristof shrugs
12:11:24 <dale> tdammers, yeah python tuples are gross
12:11:41 <kristof> I hold no opinion either way.
12:11:45 <tdammers> eh, should have called them "immutable lists"
12:12:07 <tdammers> but, anyway, they do fit into the highly dynamic Python landscape
12:12:38 <tdammers> it's just that intuitions you have about Python tuples and Python lists do not transfer very well to Haskell tuples and lists
12:13:48 <kristof> Python is not a bondage and discipline language. When one would say "can't" in Haskell, one says "don't" in Python. And people get along just fine with "don't". You can always replace stuff like arity restrictions with length-contracts, anyway.
12:14:29 <kristof> So minor nitpicks between languages of this nature never interest me.
12:15:59 <athan> kristof: But, where is incorrectness measured in Python, compared to Haskell?
12:16:25 <athan> or really, how far is it measured?
12:16:59 <ReinH> kristof: yes, I can always transform a guarantee into a proof obligation. But that's the opposite direction I *want* to move in.
12:17:17 <TheSavior2> Download the Website Worth Calculator Nulled attathment on the website followd by images: http://www.websiteadverts.org/forum/showthread.php?tid=16 you might think it's fake, well it's not, after all it's only one click isn't it?
12:17:17 <solrize> Guest62453, bson is pretty straightforward
12:17:22 <TheSavior2> Download the Website Worth Calculator Nulled attathment on the website followd by images: http://www.websiteadverts.org/forum/showthread.php?tid=16 you might think it's fake, well it's not, after all it's only one click isn't it?
12:18:04 <ReinH> It isn't a "minor nitpick", it's the source of billions of dollars of wasted money.
12:18:49 <ReinH> So yes, you can force humans to do things the computer could do for them instead, but you can't force me to like it.
12:20:23 <ReinH> "not a bondage and discipline language" is another way of saying "can't support the programmer in any but the most basic of ways"
12:20:45 <kristof> Woah! I've started a fight.
12:20:51 <kristof> ReinH: I'm just talking about tuple arity.
12:21:09 <ReinH> I don't feel bound by my inability to cause null-pointer bugs. Do you think C programmers feel an immense sense freedom in their stack overflows?
12:21:09 <kristof> ReinH: Contracts suffice in that case.
12:22:02 <ReinH> I don't feel like I'm being punished because the language won't let me add numbers to strings. etc.
12:22:35 <ReinH> Sure, they "suffice", but that's not the point. You can always make a human do the work the computer should be doing for them, but why on earth would you want to?
12:22:40 <kristof> ReinH: I am *just* talking about tuple-arity.
12:22:55 <ReinH> kristof: you were making very general statements
12:23:13 <}> o.O
12:23:40 <kristof> ReinH: I'm sorry if it seemed like that. I was really only talking about tuple-arity, which is not worth a crusade over.
12:24:53 <ReinH> I just don't get why anyone would tout "the language forces me to do all this extra stuff to prevent bugs it can't prevent for me" as a feature
12:25:48 <kristof> Didn't tout it. People were just saying that "tuples in Python are gross", and I was simply retorting that the inconvenience is minor, minimal, inconsequential, etc.
12:25:57 <ReinH> But I am impressed by the verbal juijitsu used to accomplish it. "bondage and discipline language", etc.
12:26:07 <kristof> I use that phrase lovingly :P
12:26:18 <ReinH> kristof: :p
12:26:20 <}> quite an old phrase
12:26:24 <kristof> ^
12:26:30 <ReinH> I know
12:26:39 <ReinH> it's not a new sentiment
12:27:09 <ReinH> but the term is specifically intended to be pejorative, e.g., http://www.catb.org/jargon/html/B/bondage-and-discipline-language.html
12:28:15 <kristof> ReinH: I've been doing embedded for 6 months. Every day, a little voice in my head pleads for type synonyms because I'm worried that someone, anyone will use my typedef incorrectly.
12:28:37 <ReinH> kristof: I would counter B&D language with "doesn't let you shoot yourself in the foot and help you aim" language
12:28:39 <ReinH> :p
12:28:49 <kristof> Sure
12:29:08 <ReinH> kristof: anyway, I'm not mad at you, I'm mad at the general expression of the idea that you just happened to touch on.
12:29:30 <albeit> If I have a partially applied datatype, "a -> Foo", and a way to access a record of Foo, "Foo -> b", is it possible to get the "b" before fully apply "a -> Foo"?
12:30:17 <ReinH> albeit: there is no Foo
12:30:18 <kristof> ReinH: People are allowed to have different opinions. For instance, I *would* use that phrase pejoratively to describe Haskell because of the expression problem in adding new datatypes to Haskell.
12:30:22 <ReinH> there is only a function a -> Foo
12:30:40 <ReinH> kristof: other languages have their own version of the expression problem
12:30:50 <ReinH> and typeclasses go further towards solving it than most languages
12:30:54 <}> kristof, in what language are you doing embedded?
12:31:19 <ReinH> So you may as well use it to describe every language
12:31:27 <kristof> ReinH: data Foo (stuff). Now I want to make a slightly different Foo. Well, great, now I have to modify every function that touches that datatype.
12:31:42 <kristof> Because of exhaustive pattern matching
12:31:54 <ReinH> kristof: That's why we create abstractions
12:31:59 <ReinH> so you *don't*
12:32:06 <kristof> Sure, create a typeclass.
12:32:16 <nolraiU> No.
12:32:18 <kristof> ...But I remember I had an example where typeclasses did not suffice. I can't remember what that was.
12:32:22 <ReinH> and anyway, that's not the expression problem
12:32:34 <nolraiU> Thats not the right use of typeclasses I would say..
12:32:41 <kristof> I thought it was. Adding datatypes versus adding functionality, choose 1.
12:32:58 <kristof> }: See.
12:33:01 <kristof> ...*C
12:33:08 <ReinH> The expression problem is about *where* you have to add the functionality
12:33:10 <nolraiU> Well I mean maybe, but a lot of the time you don't need it.
12:33:18 <ReinH> e.g. in an OO language, the functions go with the objects
12:33:24 <ReinH> in an FP language, it's the opposite
12:33:24 <nolraiU> *by it I mean typeclasses.
12:33:40 <kristof> ReinH: That's what I meant. "Where" greatly affects triviality of adding those things.
12:33:56 <nolraiU> Just make it so your functions use the accessesors or such.
12:34:27 <nolraiU> Pattern matching is nice..but only for datatypes that won't change.
12:34:48 <ReinH> kristof: Yeah, you're right, it is the expression problem.
12:34:55 <ReinH> And typeclasses are Haskell's "solution"
12:35:05 <kristof> Which only go so far!
12:35:10 <nolraiU> Yes.
12:35:18 <Guest62453> @solrize, true, generally it seems to be, I'm just having a lot of trouble getting it to be the right type to send as a JSON api reponse
12:35:18 <lambdabot> Unknown command, try @list
12:35:20 <ReinH> Yes, there isn't a solution.
12:35:25 <ReinH> In Haskell or elsewhere
12:35:29 <kristof> What I really like about typeclasses over interfaces is "default" implementations.
12:35:47 <kristof> Specify a minimal concrete implementation and the rest is taken care of.
12:35:49 <}> ReinH, metaprogramming is the solution
12:35:54 <kristof> Welllll
12:36:03 * kristof scratches head
12:36:12 <ReinH> metaprogramming is never the solution :p or at least should never be the solution
12:36:25 <}> I disagree
12:36:25 <kristof> I'm coming to that conclusion more and more
12:36:40 <zipper> How can I call cabal configure from a haskell program that depends on Cabal?
12:36:54 <kristof> Metaprogramming should just be about making DSLs and making them nicer, not actual functionality.
12:36:57 <zipper> I assume it's just one function.
12:37:12 <zipper> To call cabal configure in the current working directory
12:37:54 <athan> ReinH: Unless you're implementing eval!
12:38:22 <athan> which, should also never be done :P
12:46:55 <athan> (Unless you have a 1st class syntax tree that you want to turn into an expression)
12:48:27 <jmcarthur> saying metaprogramming is never the solution doesn't sit well with me somehow. what separates metaprogramming from writing a compiler?
12:48:43 <}> jmcarthur, that's exactly my point
12:50:32 <s_e> Metaprogramming is writing the compiler you need right now.
12:50:38 <s_e> Nothing wrong with that.
12:51:52 <jmcarthur> i'll grant that metaprogramming is unnecessarily a pain in many languages, inluding haskell
12:52:10 <}> yeah, it's easiest to do in homoiconic languages, which are rare
12:52:49 <zipper> drop all occurences of a charachter from a string.
12:52:51 <zipper> ?
12:52:54 <s_e> I'm still fond of old fashioned C macros. Despite their idiosyncrasies.
12:53:38 <s_e> From a pragmatic viewpoint, they are very effective. Not exactly hygeinic though :)
12:53:41 <jmcarthur> i basically agree, but i'd be much, much happier with C macros if they were hygenic, though
12:53:44 <}> s_e, have you seen the boost.preprocessing library? the things they do with C macros blows my mind, they use it as a turing complete language essentially
12:54:00 <s_e> I'm not hugely fond of templates.
12:54:02 <}> not related to haskell though
12:54:20 <s_e> They're a quagmire.
12:54:39 <jmcarthur> the main problem with templates is the syntax. the idea is fine
12:55:16 <jmcarthur> well, and the compile time and error messages, but that's not entirely the fault of the feature itself
12:55:49 <s_e> The potential for halting issues is massive though. I like powerful metaprogramming, but the line needs to be drawn once you hit completeness in my opinion. Otherwise you lose so many of the benefits.
12:56:03 <s_e> But I'm not a great theorist either, just read a bit of Godel :)
12:56:04 <jmcarthur> what benefits do you lose?
12:56:26 <s_e> Well, from a practical viewpoint, you lose stability.
12:56:40 <jmcarthur> i don't think i understand this notion of stability
12:56:46 <s_e> If the compiler starts spinning off forever, that's a lot of programmer frustration.
12:56:58 <jmcarthur> i can do that without completeness too
12:57:21 <s_e> Yeah this is purely from an ecological standpoint, theory-wise, knock yourselves out. Compiler experimentation is cool.
12:58:12 <s_e> jmcarthur: of course, but I'd rather not have that surface expanded too far when working on a project, is all.
12:58:33 <monochrom> when the compiler starts spinning off forever, programmers simply hit ctrl-c and revise their macros.
12:58:53 <s_e> You'd be amazed at how many don't.
12:59:01 <monochrom> in fact, without metaprogramming, GHC can already spin off forever with UndecidableInstances.
12:59:06 <s_e> Especially a problem with automated builds.
12:59:08 <jmcarthur> yeah, i don't really understand what the problem is. obviously if your program or metaprogram takes too long, you should fix it. completeness is irrelevant
12:59:13 <}> The main issue I have with metaprogramming is that, given enough time people can abuse it in ways that the original language is barely identifiable, all you have is this new DSL
12:59:25 * hackagebot foldl 1.1.0 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.1.0 (GabrielGonzalez)
12:59:33 <s_e> Yeah, I'm perhaps in too practical a frame of mind for #haskell right now :D
12:59:35 <monochrom> I have never heard of any fan of UndecidableInstances getting frustrated at any actual infinite loop they made.
12:59:57 <monochrom> I conclude that your "programmer frustration" is pure speculation without data evidence.
13:00:01 <jmcarthur> i've made infinite compiler loops and totally recognized it as my own fault
13:00:28 <monochrom> and corollary: you are too speculative, not too practical
13:00:38 <monochrom> if you have no data, you cannot be too practical
13:00:48 <s_e> I'm more going from experience.
13:01:01 <monochrom> where is your data?
13:01:09 <jmcarthur> i'm used to theorists being upset about the possibility of nontermination during type checking, etc., more than pragmatists
13:01:14 <jmcarthur> so this is novel to me
13:01:20 <monochrom> (Greg Wilson taught us to always ask that question.)
13:01:45 <}> Ack I used pointfree to transform my haskell code and now I barely understand it :(
13:02:01 <s_e> I'm not trying to take a quantative position here. Just offering my opinion on the value of taking metaprogramming too far.
13:02:03 <maerwald> }: that's what I keep saying... don't use it
13:02:04 <jmcarthur> }: you did it wrong!
13:02:34 <s_e> I'm all for metaprogramming to the depths of infinity from a scientific perspective.
13:02:41 <s_e> From an industrial one, not so much.
13:02:51 <jmcarthur> }: point free style is a choice one can make to improve the readability and refactorability of your code, but it needs to be applied selectively
13:03:11 <s_e> But as I said, compiler modularity and good process can definitely alleviate those issues.
13:03:12 <jmcarthur> }: i can use indentation to improve or destroy the readability of my program
13:03:34 <}> Well at least it was interesting to see this alternative version, "flip" and "ap" everywhere
13:04:02 <jmcarthur> the pointfree tool doesn't always generate very nice point free code :\
13:04:20 <jmcarthur> it rarely does when any sort of argument reordering is involved
13:04:36 <}> ah yeah, that's what I was doing
13:05:38 <Forkk> so after playing around with auto, reactive-banana, and netwire, I feel like auto will suit my purposes best given that my application runs in discrete time steps. Unfortunately, though, I want to produce a set of effects (namely, sending messages to clients) rather than output a stream of values (which is what auto is meant for)
13:05:53 <Forkk> I'd essentially be breaking the semantics of auto
13:06:10 <Forkk> is there a better approach to this?
13:06:29 <}> Forkk, Perhaps someone has already done what you're doing, have you checked?
13:06:36 <}> I mean their implementation might provide some clues
13:07:10 <c_wraith> Forkk: why can't the output value stream be the messages to send?
13:07:22 <c_wraith> Forkk: (potentially tagged with a list of clients to send them to)
13:07:22 <Forkk> I tried that
13:07:36 <Forkk> I don't know why I decided not to do it
13:07:41 <Forkk> maybe I should try it again
13:08:00 <Forkk> }, I doubt it. This is a pretty specific project
13:08:12 <c_wraith> It seems like the thing to try.  *shrug*.  If you remember why it doesn't work, we can provide more feedback when we know why it doesn't work.
13:08:32 <Forkk> I'm trying to build a generic server for card games and other similar turn-based games
13:08:50 <Forkk> auto seems pretty close to netwire too
13:09:07 <Forkk> Now I get to spend another 3 hours porting code :|
13:09:15 <c_wraith> they're similar, with the exception of continuous/discrete simulation semantics.
13:09:24 <c_wraith> So..  other than that huge core difference, they're very similar. :)
13:09:42 <Forkk> yeah
13:09:53 <Forkk> netwire is more geared towards continuous time
13:09:59 <Forkk> so auto should suit my purposes better
13:10:20 <Forkk> and of course it's broken on GHC 7.8 -_-
13:10:35 <c_wraith> jle`: is auto broken on 7.8 right now?
13:10:45 <Forkk> I'll just use 7.10 for now and inevitably forget to fix it later when I commit
13:10:46 <c_wraith> Forkk: it helps when the package author is a regular here.
13:10:50 <Forkk> hag
13:10:51 <Forkk> hah*
13:11:04 <Forkk> I don't think it's auto that broke
13:11:12 <c_wraith> Oh, it's just the build overall?
13:11:17 <Forkk> transformers >=4.2.0 is missing
13:11:34 <c_wraith> are you building in a sandbox?
13:11:44 <Forkk> using Nix
13:11:45 <Forkk> no worries, I can just switch ghc
13:11:53 <Forkk> I'll screw with this later
13:12:00 <Forkk> travis is going to fail, though :|
13:12:14 <}> heh "After reading this text, you will receive a "Master of Haskell I/O" degree that is equal to a Bachelor in Computer Science and Mathematics, simultaneously."
13:12:30 <Forkk> lol
13:12:33 <c_wraith> I don't even have to understand it?  sweet!
13:13:13 <}> c_wraith, you get a PhD for that 
13:13:30 <c_wraith> Doctorate of Haskell I/O
13:15:30 <Forkk> holy shit the auto docs are crazy
13:15:47 <Forkk> we need more like this
13:15:59 <c_wraith> jle` wrote a series of blog posts about using it, too
13:19:29 <forvelin>  /topic
13:19:34 <forvelin> upps
13:24:30 <nolraiU> How do I tell cabal to look in my src folder?
13:25:32 <hasket> Anybody have a good way to learn "category theory for haskellers" or something similar?
13:25:57 <meiji11> is there a way to get template your boilerplate working with GHC 7.8.3 / template-haskell 2.9.0.0 ??
13:25:57 <Forkk> lol a lot of auto's functions are the same as netwire too
13:26:01 <Forkk> how convenient for me :D
13:26:09 <lyxia> nolraiU:   hs-source-dirs: src/  ?
13:29:27 * hackagebot mvc 1.1.0 - Model-view-controller  http://hackage.haskell.org/package/mvc-1.1.0 (GabrielGonzalez)
13:31:09 <nolraiU> lyxia: THANK YOU!
13:33:19 <lyxia> You're welcome!
13:33:43 <Welkin> ようこそ
13:36:49 <}> Welkin, No, you may not blow up this channel
13:37:37 <jle`> c_wraith: um it should work on 7.8 still
13:37:48 <jle`> but i CI on 7.6 and 7.10
13:37:55 <jle`> i guess i figured the gaps would fill themselves, heh
13:37:59 <jle`> let me check up on what's going on 
13:38:11 <jmcarthur> in my experiences, discrete time is rarely the desired semantics, and i'm usually confused when somebody claims otherwise for whatever problem we're talking about.
13:38:43 <jle`> discrete time is rarely a desired semantic for time, but sometimes it's not time you want to represent :3
13:39:49 <jle`> i should really get multiple ghc ci running
13:40:18 <jle`> Forkk: yeah, let me know if you have any questions :)  would be happy to help
13:40:26 <jle`> i've actually been working on a turn based game server as a demo project too
13:40:43 <Forkk> alright
13:40:51 <Forkk> thanks :)
13:41:01 <Welkin> jle`: that sounds interesting
13:41:52 <Welkin> jle`: is the project/source online?
13:42:07 <Forkk> so far most of my netwire code has either ported almost directly or become much cleaner due to auto :P
13:42:10 <jle`> seems to build on 7.8 fine.  i just read further on on the conversation and it sounds like it ended up not being auto in your case so nevermind :)
13:42:39 <jle`> Welkin: um it's not quite cleaned up to be presented yet but it should be on https://github.com/mstksg/auto-examples
13:42:45 <jle`> just as working draft, heh
13:43:05 <Forkk> it's probably a problem with nix packages being outdated
13:43:14 <jle`> i thought nix was perfect :|
13:43:25 <jle`> ;_;
13:43:32 <geekosaur> nix is fighting with issues in ghc
13:44:01 <ion> hasket: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
13:44:02 <geekosaur> there are apparently some significant problems with ghc 7.10.1 :/
13:44:17 <geekosaur> with respect to nix building packages using it, that is
13:44:48 <pharaun> uhoh, i was going to grab nix to get access to 7.10
13:45:00 <xplat> anyone built language-c on 7.8.4?
13:45:14 <Forkk> pharaun, it works fine right now
13:45:34 <Forkk> I think most of the problems are within the development stuff
13:45:41 <pharaun> ahh k
13:45:59 <Forkk> there was an issue I saw where libraries built on different machines don't play nice together
13:46:26 <Forkk> but it shouldn't matter if you compile the haskell packages locally (which is the default, since haskellNG doesn't use a binary cache by default)
13:46:46 <pharaun> ahh k
13:47:14 <pharaun> Forkk: still discouraging when devs have trouble :)
13:47:36 <Forkk> yeah
13:47:44 <Forkk> It's worked beautifully for me, though
13:48:06 <c_wraith> jmcarthur: I don't actually care about time.  I care about discrete steps.
13:48:06 <Forkk> I can run one command and build my code on 2 ghc versions at once :D
13:48:09 <pharaun> yeah a friend was telling me to use it and that it would work for my usecase (wanted 7.8 and 7.10)
13:48:14 <pharaun> Forkk: sweet
13:48:44 <Forkk> also, binary caching haskell packages would be really nice if it actually worked right now :P
13:49:01 <Forkk> given that lens takes ages to build and god forbid you have to compile hakyll
13:49:15 <pharaun> hrm hakyll takes a long time?
13:49:17 <pharaun> i never noticed
13:49:59 <Forkk> really?
13:50:04 <Forkk> It pulls in pandoc
13:50:13 <Forkk> which has a massive dependency list
13:50:17 <Forkk> including latex stuff
13:50:25 <pharaun> yeah sure pandoc can be a bit slow to build, but hakyll stuff seemed ok otherwise
13:50:28 <Forkk> and a bunch of syntax highlighting stuff
13:50:49 <pharaun> aha k you meant the whole thing :) fair
13:52:44 <Forkk> someone needs to replace netwire's event module with the blip streams module from auto
13:52:55 <Forkk> there are so many functions I was missing in netwire
13:53:19 <xplat> i'm having trouble building language-c because the lexer is expecting (==#) and friends to return Bool but they now return Int#
14:00:54 <c_wraith> xplat: yeah, that'll just need patch
14:01:24 <}> jle`, I tried cabal installing your examples, but one of the depenencies won't compile ;-(
14:02:43 <albeit> Is there a forkOnFinally available anywhere? Control.Concurrent has forkOn and forkFinally, but not the combination...
14:05:42 <jle`> c_wraith: oh yeah, working on that.  been a little behind on keeping that repo up to date, heh
14:05:49 <jle`> it probably would be smart to split it up into multiple packages
14:05:52 <jle`> instead of one giant big one, too
14:08:04 <jacereda> hi... how can I recursively install profiling versions of all the dependencies for my project? (using cabal)
14:10:01 <quchen> jacereda: cabal install --enable-library-profiling?
14:10:10 <quchen> That should install profiling libraries for all your dependencies
14:10:26 <jacereda> quchen: thanks, let me try
14:10:53 <quchen> If you have already installed libraries you need profiling versions of you're in for some fun though :-/
14:11:04 <Fylwind>  does anyone use ghci with ansi color codes?
14:11:55 <jacereda> quchen: computer says no... so I need to uninstall everything and reinstall configuring with --enable-library-profiling?
14:12:28 <quchen> jacereda: Yeah, probably. You can try fixing it manually. We've all done that once. Full reinstall is faster. ;-(
14:12:40 <jacereda> quchen: ok, thanks
14:12:42 <quchen> jacereda: And use sandboxes next time, that usually helps.
14:12:57 <quchen> jacereda: Standard GHC builds come with profiling libs, so you don't need to worry about those at least.
14:14:02 <jacereda> quchen: can I just create a sandbox now and configure again?
14:14:22 <quchen> jacereda: Oh, were you in a sandbox before?
14:14:27 <jacereda> no
14:14:44 <quchen> So you deleted (parts of) .ghc and .cabal then?
14:15:55 <jacereda> quchen: no, I mean, can I leave the current .cabal as is, initialize a sandbox and try to reconfigure there?
14:16:01 <ReinH> jacereda: You can enable profiling globally in ~/.cabal/config
14:16:10 <Forkk> jle`, so can I "tag" blips with the output of another auto when they emit?
14:16:19 <Forkk> same problem I had with netwire ._.
14:16:45 <jacereda> ReinH: what are the implications? Longer build times because it builds 2 variants?
14:16:52 <quchen> jacereda: I don't know what you had, so I don't know how to clean your environment. If you want to delete all cabal-installed libraries, you usually remove .ghc and .cabal, possibly keeping some stuff like configs that are in those dirs.
14:17:52 <quchen> jacereda: In .ghc, ghci.conf and ghci_history might be worth keeping. In .cabal, you may want to keep the bin and setup-exe-cache directories.
14:19:07 <jacereda> quchen: ok, I guess I'll just nuke all, I've only installed newest cabal (took a while) and a couple of libraries
14:19:24 <hexagoxel> and you can keep ~/.cabal/config
14:19:38 <quchen> I like to delete that one as well, and then manually set the settings I like.
14:19:58 <quchen> Sometimes new Cabal versions bring new config files, and that way I get a free upgrade.
14:20:20 <jacereda> ReinH: should I enable both 'profiling' and 'library-profiling'?
14:20:35 <quchen> library-profiling is enough. Profiling is for executables.
14:20:36 <hexagoxel> quchen: but there is `cabal user-config` for that..
14:21:16 <hexagoxel> (it is (relatively) new :)
14:21:25 <quchen> hexagoxel: Interesting, I did not know about that.
14:21:41 <hexagoxel> a few months old i think
14:22:27 <quchen> Last week I was told there's a require-sandbox command, now you tell me a nice way to upgrade my cabal.config. Christmas!
14:22:33 <quchen> s/command/setting/
14:23:24 <nak> i think i might finally understand monads
14:23:26 <nak> like, just barey
14:23:30 <ReinH> jacereda: What quchen said
14:23:38 <nak> barely*
14:23:47 <nak> reading this section http://www.seas.upenn.edu/~cis194/lectures/07-monads.html
14:23:58 <nak> sort of a complex example, i wish a simpler one was chosen, but i get it
14:24:01 <ReinH> nak: :)
14:24:06 <nak> ReinH really coo, right ?
14:24:07 <nak> ^.^
14:24:12 <nak> (what is wrong with my L key??)
14:24:41 <nak> ReinH i particularly like that the zipTree1 function looks a little ugly
14:24:47 <nak> i was reading it and thinking "i hope this can be optimized"
14:24:55 <nak> and sure enough, zipTree2 and zipTree3 demonstrate just that
14:24:57 <nak> so cool
14:24:58 <ReinH> :)
14:25:10 <nak> "optimized" isn't the best word
14:25:13 <nak> but like "cleaned up" i guess
14:25:24 <nak> and it really demonstrates the actual *utility* of monads too
14:25:28 <ReinH> It's a fine word.
14:25:42 <ion> perfectly cromulent
14:25:46 <ReinH> You're optimizing for something
14:25:52 <ReinH> Also a fine word.
14:26:36 <nak> lol
14:26:46 <nak> damn you
14:26:47 <nak> i actually looked up "cromulent" ion
14:27:48 <}> i think it's interesting a lot of people have trouble understanding monads but not things like expression templates in C++ (which are implemented in a pure functional way without side effects)
14:27:53 <}> but they're the same things essentially
14:28:04 <nak> } i don't know C++
14:28:10 <}> I don't mean you specifically
14:28:14 <}> In general
14:28:27 <nak> } and it's not that i necessarily had trouble understanding them so much as whenever the topic came up, i just didn't understand what problem they were solving
14:29:00 <}> It just makes your code more generic and easier to work with
14:31:11 <}> But it still bothers me, I mean the fact that  there's concepts identical to monads in other languages (with different names) and people are fine, but there's a lot of people saying they don't understand monads in haskell
14:31:34 <mjrosenb> gah, there isn't a unboxed array for complex values?
14:31:45 <Forkk> }, it's because they are far more abstract in haskell
14:32:08 <Forkk> The problem is that people can easy understand how to use specific monads
14:32:17 <Forkk> but they can't fully grasp the abstraction
14:32:51 <Forkk> they're very easy once you realise that the concept of a monad is something so generic
14:33:03 <}> Forkk, Right, but the example I gave before -- expression templates, they're pretty much the same abstraction, and arguably much more difficult, yet you don't see people saying they can't understand them
14:33:43 <ReinH> Yeah, we have a naming problem. Or everyone else is allergic to names from math.
14:33:50 <ReinH> It's a shame.
14:33:57 <ion> Are monads isomorphic to expression templates?
14:34:07 <Forkk> I think you're missing the point
14:34:18 <ReinH> It's deeper than just a naming problem though.
14:34:24 <Forkk> Monads are like this super abstract thing
14:34:31 <Forkk> there is absolutely nothing concrete about them
14:34:58 <}> ion, that's hard to say, expression templates can be used to write entire domain specific languages, so they're a bit more abstract, but for most purposes they're used exactly how you would use a monad
14:35:03 <Forkk> to use a simpler example: functors
14:35:11 <Forkk> anything that can be mapped over is a functor
14:35:31 <Forkk> people don't understand "anything you can map over" as well as they understand "for each item in a list"
14:36:18 <hexagoxel> s/in a list/in some container/
14:36:25 <Forkk> yeah
14:36:26 <ReinH> Also what is the denotation of expression templates. How do you even check an isomorphism?
14:37:06 <Forkk> honestly the best way to teach people about monads is to just teach them to use them one at a time
14:37:12 <Forkk> like "here's how you use IO"
14:37:20 <Forkk> and then "here's how you use State"
14:37:49 <Forkk> then you can avoid trying to explain the abstraction as long as possible
14:38:02 <ion> In Soviet Russia, State uses you
14:38:15 <tomjaguarpaw> Can I tell ghc to avoid linking certain libraries?
14:38:17 <Forkk> and just let people put the pieces together themselves. Eventually they'll realize that these different things are the same
14:38:26 <tomjaguarpaw> It seems to be linking different versions of the same thing and giving linker errors.
14:39:03 <Forkk> there is no need to throw around confusing abstract concepts when you're introducing someone to something
14:39:40 <}> And I think the naming in haskell is a bit inconsistent, you have a Foldable which is something everyone understand, and a Monoid, which will confuse people
14:40:10 <xplat> c_wraith: it installed after i updated alex and happy
14:46:04 <}> is there some tool that lets me write things like  fmap (a->a->a) (a->a->a) and it outputs the resulting type ( a -> (a -> a) -> a -> a )
14:46:12 <}> does that make sense?
14:46:28 <}> because :t expects a concrete expression
14:47:18 <hexagoxel> :t fmap (undefined :: a -> a -> a) (undefined :: a -> a -> a)
14:47:20 <lambdabot> a -> (a -> a) -> a -> a
14:47:22 <c_wraith> :t fmap (?f :: a -> a -> a)
14:47:23 <lambdabot>     Could not deduce (?f::a1 -> a1 -> a1)
14:47:23 <lambdabot>       arising from a use of implicit parameter ‘?f’
14:47:23 <lambdabot>     from the context (Functor f)
14:47:42 <}> hexagoxel, oh thanks
14:48:03 <ion> @type fmap `asTypeIn` \f -> f (undefined :: a -> a -> a) (undefined :: a -> a -> a)
14:48:05 <lambdabot> ((a -> a) -> (a -> a) -> a -> a) -> (a -> a -> a) -> a -> (a -> a) -> a -> a
14:48:13 <c_wraith> That's...  odd.  I don't understand why that happened.
14:48:32 <ion> @type fmap (_ :: a -> a -> a)
14:48:33 <lambdabot>     Found hole ‘_’ with type: a1 -> a1 -> a1
14:48:34 <lambdabot>     Where: ‘a1’ is a rigid type variable bound by
14:48:34 <lambdabot>                 an expression type signature: a1 -> a1 -> a1 at <interactive>:1:7
14:48:52 <c_wraith> Did implicit params get weakened?  I don't understand why that wasn't just added to the context
14:54:27 <dolio> c_wraith: Something weird going on with annotating it with a polymorphic type.
14:55:07 <c_wraith> Oh, ok.  I stumbled into one of those cases.
14:58:32 <dolio> c_wraith: I think when you say '?f :: a -> a' it thinks you want the expression ?f to have the type 'forall a. a -> a', which doesn't have the implicit param context.
14:58:53 <dolio> I don't really know why.
14:59:28 <arkeet> no, not forall.
14:59:31 <arkeet> wait.
14:59:42 <c_wraith> :t fmap (?f :: Int -> Int -> Int)
14:59:44 <lambdabot> (Functor f, ?f::Int -> Int -> Int) => f Int -> f (Int -> Int)
14:59:50 <arkeet> oh you mean that.
14:59:56 <c_wraith> well, it works with a concrete type
15:00:08 <arkeet> yeah.
15:00:19 <c_wraith> :t fmap (?f :: Int -> Int -> Int) (?x :: Int -> Int)
15:00:20 <lambdabot> (?f::Int -> Int -> Int, ?x::Int -> Int) => Int -> Int -> Int
15:01:51 <dolio> Right. I'm saying it thinks you want the expression to have a generalized, polymorphic type with an empty context.
15:02:55 <dolio> :t fmap (?f :: (?f :: a -> a -> a) => a -> a -> a)
15:02:59 <lambdabot> (Functor f, ?f::a -> a -> a) => f a -> f (a -> a)
15:04:06 <c_wraith> I'm going to need to think about that one.
15:04:26 <c_wraith> oh!
15:04:48 <c_wraith> It's because I didn't understand the scoping rules of implicit params properly.  Got it.
15:06:02 <}> > ((*) `fmap` (+5)) 6 6
15:06:05 <lambdabot>  66
15:06:17 <}> fmap/ap/<*>/liftM applied to functions makes my brain hurt
15:06:40 <dolio> c_wraith: Here's something to confuse you now.
15:06:57 <dolio> :t \(x :: a) -> fmap (?f :: a -> a -> a)
15:06:58 <lambdabot> (Functor f, ?f::a -> a -> a) => a -> f a -> f (a -> a)
15:07:25 <c_wraith> Nah, that makes more sense...
15:07:29 <dolio> :)
15:07:56 <ion> å: http://heh.fi/haskell/functors/#function-instance
15:08:20 <quchen> }: (Map k) is a Functor where fmap maps over all values stored in the map. (k ->) is very similar, it is also a sort of map indexed by k. Fmapping over a (k ->) thing modifies all the values stored. Lookup for (Map k v) is Data.Map.lookup. Lookup for (k -> v) is ($).
15:08:50 <c_wraith> dolio: because you can only put a type variable in a pattern with ScopedTypeVariables, and if you do you explicitly introduce a scope for the type variable.
15:08:59 <}> ion, it's }!
15:09:10 <nolraiU> @pointless g f a = fmap f (pure a)
15:09:10 <lambdabot> g = (. pure) . fmap
15:09:22 <ion> If you interpret it as ASCII, sure. :-P
15:09:33 <quchen> Confusion is what you get for choosing a terrible name.
15:09:49 <Guest71152> hi all. learning haskell and I have a n00b question. I interpret `return :: Monad m => a -> m a` as taking a value of some type, and putting it into a monadic type. How do I specify what monad `return` should be injecting `a` into? So, how do I put `a -> IO a`?
15:10:12 <quchen> :t return :: a -> IO a -- Guest71152 
15:10:15 <lambdabot> a -> IO a
15:10:28 <dolio> c_wraith: Yeah. Since the scope is outside the ?f expression, it doesn't try to generalize the type you wrote, or something.
15:10:32 <}> Guest71152, it should figure it out automatically based on the type of your function, but you can use :: to specify the type
15:10:36 <Clint> > return 5 :: Maybe Int
15:10:38 <c_wraith> Guest71152: most of the time, you don't need to tell it.  type inference is powerful
15:10:39 <lambdabot>  Just 5
15:10:41 <quchen> Guest71152: Most of the time, you do not need to specify the type though, type inference will take care of it.
15:10:43 <ion> :t return `asTypeIn` \r -> print "hello" >> r undefined
15:10:46 <lambdabot> b -> IO b
15:11:12 <Guest71152> cool. thanks!
15:14:43 <}> ion, thanks that link was very helpful
15:15:28 <athan> Is there a `concat` for Data.Set?
15:15:38 <athan> Or would that be silly? ._.
15:16:54 <athan> :t Data.Set.unions . Data.Set.toList
15:16:57 <lambdabot> Ord a => S.Set (S.Set a) -> S.Set a
15:17:02 <ion> > fold [Set.fromList [0..5], Set.fromList [3..8]]
15:17:04 <lambdabot>      Not in scope: ‘Set.fromList’
15:17:04 <lambdabot>      Perhaps you meant one of these:
15:17:04 <lambdabot>        ‘Seq.fromList’ (imported from Data.Sequence),
15:17:11 <ion> > fold [S.fromList [0..5], S.fromList [3..8]]
15:17:13 <lambdabot>  fromList [0,1,2,3,4,5,6,7,8]
15:17:44 <athan> :t fold . Data.Set.toList
15:17:45 <ion> > fold (S.fromList [S.fromList [0..5], S.fromList [3..8]])
15:17:46 <lambdabot> Monoid c => S.Set c -> c
15:17:48 <lambdabot>  fromList [0,1,2,3,4,5,6,7,8]
15:18:09 <}> I wonder if the user named fold gets annoyed by all the highlighting
15:18:13 <athan> hmm okay, thanks ion
15:18:17 <athan> lol
15:18:36 <geekosaur> there's someone here named "so" apparently
15:18:49 <geekosaur> speaking of getting highlighted to death
15:21:17 <ion> I hear 7.12.1 is going to have geekosaur in Prelude.
15:22:00 <c_wraith> will that mean geekosaur can't contribute here, being trapped in the Prelude?
15:22:05 <Rotaerk> isn't that one of the ways of getting to heaven
15:22:22 <geekosaur> my highlights include "geek"; freenode being what it is, it goes off a lot >.>
15:22:43 <bitemyapp> ion: will the Prelude-geekosaur tell me what functions to use?
15:22:48 <bitemyapp> could be v. helpful
15:22:58 <bitemyapp> I need a Prelude-norvig.
15:23:06 <nak> bitemyapp !!!
15:23:06 <geekosaur> (also "a_b" which most clients treat as "a-b" so it goes off a lot too)
15:23:17 <bitemyapp> not to be ungrateful or anything
15:23:18 <nak> bitemyapp i can't thank you enough for http://bitemyapp.com/posts/2014-12-31-functional-education.html
15:23:26 <nak> bitemyapp this is such a helpful resource for me
15:23:30 <bitemyapp> nak: you're welcome
15:23:33 <ion> That’s a good post.
15:23:36 <bitemyapp> nak: you've seen the guide right? it's much more compact.
15:23:39 <geekosaur> (or a+b for that matter)
15:24:02 <bitemyapp> ion: I was talking to somebody about the content sharing between Hutton and Bird. Apparently one of them stole from the other, but the game theoretic win-win is neither says who was the thief :P
15:24:13 <bitemyapp> I found this hilarious :)
15:24:23 <nak> bitemyapp "the guide" ?
15:24:33 <bitemyapp> nak: yeah, that post is a means of explaining why the guide is the way it is.
15:24:33 <nak> bitemyapp i'm not sure
15:24:36 <bitemyapp> @where learnhaskell
15:24:36 <lambdabot> https://github.com/bitemyapp/learnhaskell
15:24:39 <nak> oh
15:24:43 <bitemyapp> ^^ that's the guide I maintain.
15:24:49 <ion> bitemyapp: heh
15:24:50 <nak> yeah i like the *why* for everything tho
15:24:50 <bitemyapp> the guide predates that post by a fair bit.
15:25:12 <bitemyapp> nak: well, so did a lot of other people. I wrote the post so I didn't have to keep explaining why the core recommendations were, "cis194 Spring '13, then NICTA Course"
15:25:20 * nak nods
15:25:23 <bitemyapp> then it just turned into a survey of what was out there.
15:25:45 <bitemyapp> nak: Now I'm working on http://haskellbook.com/
15:25:49 <nak> bitemyapp i was planning on buying your book too but then i saw it was incomplete. i still plan on --
15:25:50 <nak> !!
15:25:51 <nak> yes
15:25:51 <mjrosenb> Is the fastest way to add two arrays element by element to construct an intermediate list, and use listToArray?
15:25:51 <nak> hehe
15:25:56 <bitemyapp> probably do intermediate books after that one.
15:26:07 <nak> bitemyapp i still plan on buying your book, but i was curious if you'd recommend it in its current state
15:26:11 <bitemyapp> nak: yeah np. I've told people who were uncomfortable with the early access to wait for reviews.
15:26:18 <ReinH> bitemyapp: (It was Hutton)
15:26:19 <bitemyapp> nak: uhm, depends on how far you want the book to carry you.
15:26:41 <bitemyapp> ReinH: how do you know?
15:26:47 <nak> bitemyapp well i'm very new to fp as of May, but i have 10 years of other shitty experience
15:26:57 <ReinH> I don't. I strongly suspect.
15:27:04 <bitemyapp> ReinH: I was thinking because Bird published earlier that it was Hutton, but Parser Combinators was kinda Hutton's wheelhouse.
15:27:11 <bitemyapp> ReinH: and the primary overlap is in Parsers.
15:27:18 <bitemyapp> so it's not as easy to determine as one would think :)
15:27:26 <ReinH> Hutton has done his own work, but where they overlap his work is clearly birdesque
15:27:32 * bitemyapp nods
15:27:33 <ion> Are you planning to release the book for free on the Internet at some point, btw?
15:27:34 <nak> bitemyapp i've learned about currying, functors, composition, tacit programming, and probably a couple other things so far
15:27:40 <nak> bitemyapp i just learned about monads last night
15:27:46 <bitemyapp> ion: undetermined. If it happens, it would happen a year or two after release.
15:27:58 <ion> bitemyapp: alright
15:27:59 <ReinH> Bird's work has a certain flavor...
15:28:01 <bitemyapp> ion: we want the *option* of doing so which is partly why we separated from our publisher.
15:28:27 <nak> bitemyapp so how far will the book get me?
15:28:36 <bitemyapp> ion: this book is the strongest candidate for that. It's not really about the money so much as the time. My LaTeX isn't pandoc-friendly.
15:28:41 <ReinH> Hutton's work on, e.g., worker wrapper transforms is great, I'm not disparaging him.
15:28:48 <bitemyapp> nak: well, http://haskellbook.com/progress.html these are the planned chapters
15:29:04 <bitemyapp> nak: and what's currently out. Types, typeclasses, and functions are being released on the 15th this month.
15:29:11 <nak> ah ok
15:29:15 <bitemyapp> nak: but that doesn't cover as much as cis194/NICTA course.
15:29:27 <nak> bitemyapp ok, i think i might be a little ahead of the book in its current state them
15:29:28 <ReinH> bitemyapp: Hutton has given a lecture that almost word for word recapitulates bird, so...
15:29:28 <bitemyapp> nak: so you have a couple options. You could wait until the coverage matches or exceeds cis194 / NICTA
15:29:29 <nak> then*
15:29:45 <bitemyapp> nak: or you could get the book now, complete what's done, then hop over to the appropriate week of cis194.
15:29:55 <ReinH> I think they probably just collaborated a lot. Nothing nefarious.
15:30:08 <nak> bitemyapp as your Functional Education article suggest, the one thing i really with cis194 had was some more thorough explanations 
15:30:14 <nak> (which i'm sure are covered in in-class discussions)
15:30:20 <nak> (but missing from printed material)
15:30:28 <ReinH> nak: Exactly :(
15:30:31 <nak> i assume your book aims to cover some of those gaps ?
15:30:31 <bitemyapp> nak: functions gets you up to ~week 4 or 5.
15:30:36 <bitemyapp> nak: oohhhhh yeah.
15:30:39 <nak> nicee
15:30:50 <bitemyapp> it's not perfect, but think about it this way
15:30:56 <bitemyapp> with the current ebook format (same as sample)
15:31:06 <bitemyapp> the full render of the book is about 450 pages.
15:31:13 <bitemyapp> and I'm working on Monoid right now.
15:31:18 <bitemyapp> Monoid/Semigroup.
15:31:40 <ReinH> bitemyapp: Btw I am graciously awaiting my signed copy :p
15:31:44 <bitemyapp> earlier stuff will probably be more meticulous than later stuff (having foundations in place helps), but I can't be sure until we get there.
15:31:47 <nak> bitemyapp it's currently 450 pages ?
15:31:51 <bitemyapp> ReinH: print run is later.
15:32:00 <ReinH> I am patient.
15:32:01 <nak> bitemyapp or planned 450 pages ?
15:32:09 <bitemyapp> nak: this is a little tricky to explain.
15:32:14 <bitemyapp> nak: we have 120 pages in the current "release"
15:32:23 <bitemyapp> nak: if we render everything we've written *so far*, it's 450 pages.
15:32:27 <nak> ah ok
15:32:34 <bitemyapp> nak: I'm working on Monoid right now. Everything after Monoid is basically unwritten except for some notes.
15:32:40 <nak> so some of that is in drafts
15:32:43 <nak> some is notes, etc
15:32:46 <bitemyapp> Yeah.
15:32:47 <nak> yeah i follow u <3
15:32:49 <bitemyapp> I'm guessing 600+ pages.
15:32:58 <bitemyapp> parsers will be kinda long
15:33:02 <nak> GOOD
15:33:05 <nak> ^.^
15:33:05 <bitemyapp> functor/applicative/monad will be kinda long
15:33:09 <ReinH> bitemyapp: Shame about the Maybe Monoid instance in the context of semigroups...
15:33:09 <bitemyapp> monad transformers will be kinda long
15:33:13 <bitemyapp> rest shouldn't be too bad.
15:33:36 <ion> I wonder if base will have class Semigroup a => Monoid a by the time the book is released? :-P
15:33:58 <bitemyapp> book final release is January 15th
15:34:02 <ReinH> ion: No. But I wish.
15:34:04 <bitemyapp> Hell, Highwater, my sanity on al altar.
15:34:06 <bitemyapp> an*
15:34:11 <nak> i was reading the source code for Monoid last night (happened to appear adjacent to the Maybe type)... i was having trouble understanding its purpose from the source code alone
15:34:17 <nak> all my mind could think of was "Foldable"
15:34:20 <bitemyapp> nak: yeah, need examples.
15:34:33 <bitemyapp> Monoid is kind of a building block for other things, but is also useful in its own right.
15:34:43 <bitemyapp> Semigroup is itself a building block for Monoid and useful on its own.
15:34:46 <nak> I saw some basic List functions like mappend, mconcat, but i couldn't see what made it special
15:34:51 <Clint> Semigroup a => Monoid a would make me happy
15:35:01 <nak> also how the hell do you say "monoid"? is it like "mahnoyd"?
15:35:10 <DrPavelheer> that's how i say it
15:35:11 <nak> sometimes my brain said "mono ID"
15:35:15 <bitemyapp> nak: that's about how I say it.
15:35:22 <bitemyapp> mohn-oyd
15:35:25 <nak> gotcha
15:35:49 <bitemyapp> Pretty sure i've heard Edward say it that way, so good enough for me :P
15:36:03 <bitemyapp> ion: funny thing is, last fall, people were saying the same thing to me about the book and AMP/FTP
15:36:11 <ion> bitemyapp: hehe
15:36:33 * nak checks paypal
15:36:33 <bitemyapp> something like Semigroup m => Monoid m  wouldn't really avalanche the way we wrote the chapter.
15:36:35 <quchen> ion: Fingers crossed!
15:36:49 <Forkk> nak, according to dictionary.com, it's pronounced /ˈmɒn ɔɪd/ 
15:37:02 <bitemyapp> ion: I planned to write something about, "if Monoid required Semigroup" regardless.
15:37:12 <bitemyapp> Forkk: someday, I will learn IPA. Someday.
15:37:22 <Forkk> I don't know it either lol
15:37:32 <Forkk> I was just assuming he does (which is probably false)
15:37:32 <nak> bitemyapp ok one last question
15:37:42 <nak> bitemyapp how actively are you working on the book ?
15:37:53 <Forkk> I'd like to learn IPA, but I have no clue how to go about doing so
15:37:54 <nak> bitemyapp are we expecting a near-complete version in 3 months? 6 months? 1 year?
15:37:54 <ReinH> nak: I gave a talk about monoids but it was for a ruby audience.
15:38:18 <nak> ReinH do you work with ruby anymore ?
15:38:30 <bitemyapp> nak: final release is January 15th.
15:38:41 <quchen> ReinH: Monoids are some of the few Haskell abstractions that you can use in other languages well, because it's simple-kinded.
15:38:43 <ReinH> No. But maybe I will soon.
15:38:47 <bitemyapp> nak: we won't have a print run done by then necessarily, but the book is done by then - Hell or Highwater.
15:38:58 <nak> bitemyapp gotcha
15:39:03 <quchen> ReinH: Hmmm? What happened to Aleph Cloud?
15:39:06 <bitemyapp> nak: as for how actively I'm working on the book
15:39:09 <ReinH> quchen: Actually you still can't and it's really frustrating.
15:39:14 <quchen> ReinH: Oh?
15:39:18 <bitemyapp> nak: it's about 2-3 hours per night on worknights, and most of my days on the weekends.
15:39:29 <bitemyapp> nak: so about 30 hours per week.
15:39:34 <bitemyapp> nak: it used to be more, but I have a day job now.
15:39:36 <quchen> Apart form Java's ridiculous verbosity, I haven't had many problems using monoids in it.
15:39:45 <ReinH> quchen: sekectig an identity element depends on selecting a type.
15:39:55 <ReinH> Uh. Selecting.
15:40:00 <quchen> Oooh, you want the polymorphism. Yeah then I agree.
15:40:01 <ReinH> Phone :(
15:40:35 <ReinH> Same problem as always. Instances are immediate. The generalization is impossible.
15:41:08 <quchen> But you can still make use of the concept, similarly to how you can talk about "mapping over something" even if you don't have language support for it.
15:41:30 <nak> bitemyapp ok i will likely pick up a copy of your book
15:41:32 <ReinH> Yes. But I can't make use of its power.
15:41:42 <bitemyapp> nak: thank you!
15:41:48 <ReinH> Or if I do, I have to do so from scratch each time.
15:41:51 <nak> bitemyapp i have to add some more money to my paypal first
15:42:07 <bitemyapp> nak: I hope the book works well for you. If you run into any problems, please ping us at: http://haskellbook.com/support.html
15:42:48 <bitemyapp> nak: Imma get back to writing about Monoid so my coauthor has something to review tonight. Cheers :)
15:43:07 <nak> bitemyapp sounds good
15:43:14 <nak> bitemyapp and please to make your acquaintance 
15:43:18 <nak> really cool running into you here
15:43:24 <nak> o/
15:44:23 <meditans> hi, I'm writing an algorithm to compare labeled graphs that I want to be very performant
15:44:26 <Forkk> It seems like I run into a lot of people on IRC who I recognise from various blogs and things lol
15:45:31 <meditans> now, unfortunately I cannot compare directly the nodes for equality, but I have a function that decides if the labels are identifiable
15:45:49 <meditans> this problem prevents me to use the canonical labeling approach
15:46:16 <meditans> as I'd need this algorithm to be fast, if anyone has papers to link, or advices, I'll glad to head them
15:47:50 <ReinH> quchen: e.g., I can't make use of "monoidness" to write a generic parallel tree fold.
15:52:54 <nak> ok so in this: class Monad m where
15:52:58 <nak> the `m` is a data type ?
15:53:20 <meditans> nak: no, that is a type constructor. It has kind * -> *
15:53:24 <ion> m is a type constructor of kind * -> *, such as Maybe (not Maybe Integer).
15:53:26 <nak> e.g., the "maybe monad" would use "Maybe" for "m" here?
15:53:34 <bitemyapp> I was about to answer, but figured at least two people would answer.
15:53:38 <meditans> nak: yes
15:53:38 <bitemyapp> then I was right ^_^
15:53:42 <meditans> bitemyapp: xd
15:53:55 <nak> ok a "type constructor"
15:54:00 <nak> oh duh
15:54:04 <nak> i was mixing ...
15:54:16 <nak> what is Bar in `data Foo = Bar | Bof`
15:54:17 <bitemyapp> nak: datatype refers to the entire declaration you'd see after the "data" keyword.
15:54:32 <nak> bitemyapp gotcha, i figured i was just mixing terms
15:54:34 <ion> Bar is a data constructor.
15:54:38 <bitemyapp> nak: a datatype is made up of a type constructor and zero or more data constructors which each have zero or more arguments.
15:54:45 <nak> *type* constructor vs *data* constructor
15:54:53 <bitemyapp> nak: yeah, it seems nitpicky, but keeping it clear/separate helps a lot.
15:55:03 <nak> no no, it's totally worth learning the terms
15:55:06 <nak> not nitpicky at all
15:55:21 <nak> having the terms makes it easy for everyone to know we're all talking about the same thing
15:55:50 <nak> ok so ... `class Monad m where`, m is a *type* constructor 
15:56:11 <nak> such as "Maybe"
15:56:21 <nak> continuing, we have 
15:56:29 <nak> return :: a -> m a
15:56:44 <nak> so say `m` is Maybe
15:56:50 <nak> given any `a`, return (Maybe a)
15:57:14 <nak> here "return" is not any type of special keyword right? it's just a regular function ?
15:57:16 <meditans> nak: no, that is a term. As a term, you give 3, and it returns Just 3
15:57:31 <meditans> nak: yes, it's a function defined in the monad typeclass
15:57:40 <meditans> a regular function
15:57:51 <nak> ok re: regular funtion
15:58:03 <nak> but i guess we have to backup, because i botched my understanding of `a -> m a`
15:58:07 <nolraiU> nak: m is a type variable with kind * -> *.
15:58:24 <meditans> ok: so, as a type, return has type a -> m a
15:58:40 <meditans> so, if you put in Int, it gives Maybe Int
15:58:44 <meditans> Int -> Maybe Int
15:58:53 <nak> oh !
15:59:01 <meditans> and the implementation has to be something like 3 |-> Just 3
15:59:08 <nak> o.o
15:59:12 <nak> not sure what that syntax is
15:59:23 <nolraiU> Neither am i.
15:59:27 <nolraiU> Its not haskell.
15:59:32 <meditans> that's not haskell syntax, I was trying to mimic mathematical one xd
15:59:36 <nak> ah ok
15:59:46 <meditans> but yes, 3 goes in Just 3
16:00:10 <nolraiU> Usually return is something simple like that.
16:00:23 <nolraiU> It kind of has to be to work right.
16:00:29 <mjrosenb> boo, vector doesn't support multi-dimensional operations in the way that array does.
16:00:57 <nak> ok so my code *using* the maybe monad will call `return (Just 3)` or `return Nothing`
16:01:00 <Forkk> mjrosenb, array does that?
16:01:09 <Forkk> I was literally just running into that problem an hour ago
16:01:29 <ion> Your code *using* the Maybe monad will probably call “return 3”.
16:01:43 <Forkk> nak, for maybe, return = Just
16:01:44 <ion> return (Just 3) is fine, too, but that will result in a nested Maybe (Maybe Integer).
16:02:04 <nak> oh right, because `return = Just` in the Maybe monad
16:02:19 <nak> calling returning (return 3) is like returning (Just 3)
16:02:36 <Forkk> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#line-642
16:02:37 <nak> s/calling returning/returning/
16:02:37 <Forkk> :P
16:03:10 <mjrosenb> Forkk: sure, just use i = (Int, Int, Int), and you have a three dimensional array.
16:03:13 <nak> Forkk yeah i've been reading this a lot ^.^
16:03:31 <nak> Forkk thank u tho, because it would've been immensely helpful had i been trying to understand all of this in the dark
16:03:35 <Forkk> mjrosenb, that's a tuple :o
16:03:46 <Forkk> heh :P
16:03:52 <nolraiU> nak: don't use the normal CS meaning of return when talking about haskell code, it gets really confusing really fast.
16:04:06 <Forkk> agreed
16:04:10 <nak> i'm trying to avoid it
16:04:19 <mjrosenb> Forkk: sure, and how is that different from a multi-dimensional array?
16:04:22 <nak> what should we call the result of a function?
16:04:28 <Forkk> "returning" values is kinda fuzzy in haskell
16:04:33 <nolraiU> result is good.
16:04:42 <nolraiU> evaluation also works.
16:04:47 <Forkk> especially since GHC will probably just inline it all
16:04:54 <nak> ok and what is the verb word we use for when the function completes and actually spits out a value ?
16:04:59 <Forkk> or equals
16:05:09 <Forkk> nak, that's evaluation
16:05:20 <nak> got it
16:05:23 <Forkk> but it's really not the same
16:05:29 <Fylwind> I'm currently trying to do some heap profiling but somehow the graph I get seems to go up to only ~5MB and 0.5 sec, even though I'm pretty sure the program just ate 500MB and lasted ~20 sec
16:05:52 <Fylwind> anyone have any idea what I might be screwing up?  I'm using plain -h flag
16:05:54 <Forkk> when you call a function in Haskell, you're not really saying "go to this point in my code and run it, then come back to here"
16:06:15 * nak nods
16:06:17 <Forkk> in fact, saying you're "calling" a function is also a bit misleading
16:06:55 <Forkk> still, I'm certainly guilty of thinking that way
16:07:02 <Forkk> because it's easier :P
16:07:14 <nolraiU> Yeah, strick evaluation is simpler.
16:07:29 <liste> I think it's just more familiar
16:07:48 <mjrosenb> Forkk: Jut because that isn't the way that it happends, it doesn't mean it is an invalid way to think about it :-p
16:07:49 <nak> ok so let's go back to `class Monad m where`
16:08:01 <nak> if we have the Maybe Monad, `m` is type constructor Maybe
16:08:02 <Forkk> of course not, mjrosenb :P
16:08:23 <Forkk> Haskell has a lot of cases where we don't think about things in terms of the way they actually happen :P
16:09:02 <Forkk> nak, yes.
16:09:26 <nak> then Monad defines signature of return as `return :: a -> m a`. When instance Monad Maybe defined `return = Just` it has to keep the same type signature as defined in `class Monad m` right ?
16:09:57 <Forkk> exactly
16:10:13 <nak> ok, so `return` is still `a -> m a`
16:10:13 <Forkk> when you use Maybe as a monad, you just plug in the "Maybe" type constructor where m is
16:10:25 <Forkk> so, for maybe, `return :: a -> Maybe a`
16:10:26 <nak> ok but here's my gap in understanding now
16:10:32 <nak> oH OH OH 
16:10:34 <nak> i'm so dumb
16:10:41 <nak> `m` (or Maybe) is still a TYPE
16:10:47 <nak> not a data constructor
16:10:48 <Forkk> `m` is Maybe (when you're using maybe)
16:10:56 <nak> i was thinking, how does the `m` change to `Just` or `Nothing`
16:11:03 <Forkk> :P
16:11:06 <nak> boom
16:11:08 <nak> ok this is great
16:11:10 <nak> alright
16:11:12 <nak> :t Just
16:11:13 <lambdabot> a -> Maybe a
16:11:15 <nak> YES!
16:11:18 <nak> hell f' yes
16:11:28 <nak> that is *exactly* what i was expecting to see
16:11:36 <Forkk> congrats :D
16:11:39 <nak> lol
16:11:45 <nak> thx for sticking with me
16:11:54 <Forkk> no problem :)
16:11:58 <nak> ok now we're almost through this radical thing
16:12:36 <nak> now, in class Monad, we have
16:12:38 <nak> (>>=) :: m a -> (a -> m b) -> m b
16:12:51 * nak reminds herself to still be thinking in TYPES
16:13:07 <ion> values live on this side :: types lurk here
16:13:17 <nak> keeping along with the Maybe Monad, `m` is still type constructor Maybe
16:13:30 <nak> Maybe a -> (a -> Maybe b) -> Maybe b
16:13:35 <ion> correct
16:14:28 <nak> so >>= takes two arguments, first one is (Maybe a), second one is function (a -> Maybe b)
16:14:35 <Forkk> yep
16:14:37 <nak> what would we call this type of function? a "transformation"? 
16:14:44 * mjrosenb is somewhat convinced that Maybe is *the* correct monad to start with.
16:14:47 <Forkk> it's normally called bind
16:14:55 <ion> Just a function.
16:15:09 <liste> (>>=) is bind, (a -> Maybe b) is just a function
16:15:17 <Forkk> if the first argument is Nothing, it just returns nothing
16:15:20 <mjrosenb> well, bindis whatyou call it when you think about the argument to the rhs function.
16:15:39 <Forkk> if the first argument is `Just a`, it passes the value inside the Maybe to the function
16:15:42 <nak> but (a -> Maybe b) doesn't have any special name? it's just a normal function ?
16:15:46 <Forkk> kinda like fmap
16:15:59 <Forkk> just a normal function
16:16:05 <ronh-> of that exact type
16:16:10 <nak> Forkk ok but that's the *implementation* of the Maybe Monad specifically
16:16:24 <nak> i was still just looking at the type signature of Monad (>>=)
16:16:28 <Forkk> ah
16:16:46 <nak> or rather, the type signature of Maybe Monad >>=
16:16:46 <mjrosenb> nak: the a in  (a -> Maybe b) is the thing that is getting bound in 'bind'
16:17:15 <nak> that `a` could be Int, Char, [Char], whatever
16:17:25 <nak> and `b` *might* be the same, but it could also be different
16:17:28 <nak> yes ?
16:17:28 <albeit> The docs mention it is possible to set an OS thread to a capability, " the OS threads for a capability i are bound to the CPU core i", but only forkOS is offered... is there a forkOSOn?
16:17:32 <ion> nak: yes
16:17:33 <liste> nak yes
16:17:36 <Forkk> yeah
16:17:48 <Forkk> a and b are just the values inside the maybe
16:18:15 <nak> got it
16:18:26 <ronh-> or rather their types
16:18:44 <nak> so let's now talk about the Maybe Monad (>>=) specifically
16:18:55 <nak> but before that, how would i denote i want to talk about that function
16:19:00 <nak> do i just say "Maybe Monad (>>=)" ?
16:19:09 <nak> or is that a better way to reference that
16:19:15 <Forkk> not sure really
16:19:30 <joneshf-laptop> mjrosenb, why dod you say that?
16:19:40 <Zekka> nak: When you say (>>=) we already know you're talking about Maybe as a monad, so it's redundant but not wrong
16:19:44 <joneshf-laptop> mjrosenb, *the* correct one
16:19:51 <haasn> nak: A good way of saying that would be (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
16:20:04 <Zekka> Likewise when you say monad, we know that you're talking about a thing with (>>=)
16:20:04 <nak> hmm
16:20:12 <Zekka> By the way, (>>=) is also called 'bind'
16:20:19 <itsMontoya> Hi guys! I've been intrigued by Haskell for quite some time. I'm looking to jump into Haskell and make some side projects to see if we can utilize Haskell where I work. I'm currently reading "Learn you a Haskell", are there any other resources you guys could recommend? :)
16:20:25 <nak> yeah i picked up on that, Zekka, thank you
16:20:44 <nak> itsMontoya holy smokes have i got the read for you
16:20:48 <Welkin> itsMontoya: Real World Haskell and the Typeclassopedia
16:20:48 <nak> itsMontoya http://bitemyapp.com/posts/2014-12-31-functional-education.html
16:20:48 <nak> ^.^
16:20:53 <Welkin> also, learn-haskell
16:20:57 <Welkin> @learn-haskell
16:20:58 <lambdabot> Unknown command, try @list
16:21:00 <Welkin> @learnhaskell
16:21:01 <lambdabot> Unknown command, try @list
16:21:03 <Forkk> now that I'm thinking about it, wouldn't join be a much simpler function to introduce before bind? :o
16:21:04 <Welkin> @where learnhaskell
16:21:04 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:21:07 <Welkin> there
16:21:09 <itsMontoya> nak: Thank you! lookig it up now
16:21:11 <nak> :t (>>=)
16:21:14 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:21:17 <itsMontoya> Welkin: Thank you! Looking now
16:21:26 <mjrosenb> joneshf-laptop: because I think it is true?
16:21:30 <Forkk> I guess you have to learn about bind either way, so it doesn't mater
16:21:31 <ion> itsMontoya: LYAH is frowned upon a bit because it has no exercises.
16:21:43 <MarcelineVQ> idk how to make haskell broadly useful in the real world, but it's amazing for project euler
16:21:45 <nak> ok so lambdabot gives the polymorphic(?) type signature
16:21:47 <nak> is that what we'd call it ?
16:21:49 <itsMontoya> ion: Ohh! Good to know, so I shouldn't spend time reading it?
16:21:51 <Forkk> oh wow freenode just derped
16:22:00 <Welkin> itsMontoya: I found it useful when I was starting out
16:22:25 <Forkk> or maybe it was my connection
16:22:29 <itsMontoya> I have a pretty decent programming/engineering background. But I've never tried out Haskell. I do admit, I like exercises so I can try my own stuff out
16:22:29 <ion> itsMontoya: You *might* benefit from switching to what learnhaskell recommends.
16:22:34 <Welkin> itsMontoya: but you need more than just LYAH
16:22:36 <ronh-> I found LYAH useful up until the applicative paragraph. that is as far as it took me
16:22:45 <nak> ok Forkk  the implementation of (>>=) in the Maybe Monad is extremely straight forward
16:22:47 <Forkk> yeah
16:22:47 <nak> very nice
16:22:56 <itsMontoya> I appreciate all your input guys, it's very refreshing
16:22:58 <Forkk> LYAH gets really confusing about monads and applicatives
16:23:07 <Forkk> It lost me at applicative
16:23:15 <itsMontoya> Is the O'Reilly book any good?
16:23:20 <Forkk> I was like "Where the hell will I ever need <*>"
16:23:20 <Welkin> itsMontoya: yes
16:23:22 <Welkin> all of them are
16:23:25 <nak> Forkk i keep seeing "applicatives" but i haven't encountered them yet!
16:23:28 <Forkk> nak, it is :P
16:23:34 <MarcelineVQ> I also stopped at <*> and switched to real world haskell
16:23:35 <Welkin> also, Parallel and Concurrnt Haskell
16:23:42 <itsMontoya> Welkin: Oh ok great. I was planning on purchasing the hard copy + ebook versions
16:23:42 <ion> itsMontoya: What nak linked has comments about a number of books.
16:23:47 <MarcelineVQ> I'm currently working on rwh and parallel/concurrent
16:23:47 <itsMontoya> So I have something to read when I'm traveling
16:23:53 <Forkk> nak, don't worry about applicatives yet :P
16:23:59 <nak> Forkk ok ^.^
16:24:00 <Welkin> itsMontoya: http://chimera.labs.oreilly.com/books/1230000000929/index.html
16:24:08 <Forkk> they're very useful, but not yet
16:24:25 <nak> ok so `instance Monad Maybe` uses the point-free `return = Just`
16:24:36 <itsMontoya> Welkin: That's this right? http://shop.oreilly.com/product/0636920026365.do?intcmp=il-npa-books-video-product_chimera
16:24:37 <ion> I’m not sure recommending against learning about Applicative yet when one is learning about Monad is the right thing to do.
16:24:47 <DrPavelheer> > Just 3 >>= (+ 5)
16:24:47 <Welkin> itsMontoya: yes
16:24:49 <haasn> nak: https://wiki.haskell.org/Typeclassopedia is a good read on the matter
16:24:50 <lambdabot>      No instance for (Show b0)
16:24:50 <lambdabot>        arising from a use of ‘show_M465231911075223836024610’
16:24:50 <lambdabot>      The type variable ‘b0’ is ambiguous
16:25:01 <itsMontoya> Rad, I'll read it a bit. If I find it useful I'll buy it to support the writer/publisher a bit
16:25:02 <DrPavelheer> > Just 3 >>= (+ 5) :: Maybe Int
16:25:03 <lambdabot>      No instance for (Num (Maybe Int)) arising from the literal ‘3’
16:25:04 <lambdabot>      In the first argument of ‘Just’, namely ‘3’
16:25:04 <lambdabot>      In the first argument of ‘(>>=)’, namely ‘Just 3’
16:25:06 <Forkk> ion, applicative is a bit more esoteric
16:25:11 <Forkk> it's less obviously useful
16:25:18 <joneshf-laptop> mjrosenb, sure, but i meant what reasons
16:25:29 <DrPavelheer> > (Just 3) >>= (+ 5)
16:25:32 <lambdabot>      No instance for (Show b0)
16:25:33 <lambdabot>        arising from a use of ‘show_M246377554399303425524647’
16:25:33 <lambdabot>      The type variable ‘b0’ is ambiguous
16:25:38 <Zekka> DrPavelheer: (+ 5) has the wrong type
16:25:45 <nak> Forkk we could've also defined `return` as `return x = Just x`
16:25:46 <DrPavelheer> Oh, you're completely right
16:25:51 <nak> or `return = \x -> Just x`
16:25:54 <ronh-> Just 3 >>= (return . (+5))   ; which is, of course, just simulation fmap with >>=
16:25:56 <Forkk> yes
16:25:57 <nak> but `return = Just` is shorter
16:25:58 <itsMontoya> Sorry for all the questions, this should be my last one for a while. Is "Haskell School of Music" any good?
16:25:59 <ronh-> +of
16:26:24 <nak> haasn thank you for the link :)
16:26:38 <Forkk> nak, although writing `return = \x -> Just x` would probably earn you some strange looks from other developers
16:26:51 <DrPavelheer> > Just 3 >>= (return . (+ 5))
16:26:54 <lambdabot>  Just 8
16:27:02 <DrPavelheer> Probably helps to see >>= in action
16:27:08 <nak> Forkk i understand, i'm very fond of the point-free
16:27:08 <DrPavelheer> (thanks, Zekka)
16:27:16 <nak> i just wanted to make sure i was udnerstanding completely
16:27:18 <ion> Applicative is the upgrade from (a -> b) -> F a -> F b to (a -> b -> c) -> F a -> F b -> F c
16:27:28 <nak> o.o
16:27:44 <haasn> I like to think about Applicative as providing this fundamental operation:  :: f a -> f b -> f (a,b)
16:27:51 <haasn> (Alongside a -> f a)
16:28:05 <haasn> It's pretty easy to visualize that type signature and what it's doing
16:28:12 <Forkk> ion, I've never thought of it that way
16:28:16 <Zekka> haasn: IMHO that's a confusing intuition in Haskell though given the actual operations it provides
16:28:17 <Forkk> that's nice :D
16:28:40 <haasn> (And then the extra pure Monad gives you on top of that is :: f (f a) -> f a
16:28:44 <haasn> extra power*
16:28:48 <nak> i think it's crazy how everyone's brain has a different thing that makes some of these concepts click; it's really fascinating
16:28:52 <Forkk> I still think that applicative is too esoteric for someone who's just started though
16:28:53 <Zekka> you can rewrite the operations in those terms, but I don't think I would expect anyone to do that if they didn't already get it
16:29:08 <haasn> nak: That's the important thing about intuitions, they work differently for different people
16:29:10 <ion> (pure+(<*>), pure+liftA2 and pure+liftA2 (,) are all equivalent)
16:29:14 <haasn> There's no “one right way”
16:29:19 <Forkk> yeah, nak, my experience with haskell has definitely involved a lot of those clicks
16:29:32 <haasn> (But there are also bad intuitions)
16:29:33 <Forkk> like "holy shit it's so obvious"
16:29:33 <ronh-> can you write liftA3 with liftA2?
16:29:36 <Guest64536> Get free website hosting 5GB Storage 1 MySQL Dataase, Unmetered Traffic, PHP5 Enabled, why free? Because we can afford to visit http://www.budgethost365.com or find out more send us an e-mail. support@budgethost365.com for USA and support@budgethost365co.uk for the UK
16:29:37 <ronh-> and no <*>
16:29:46 <exio4> ronh-: you can recover (<*>) 
16:29:49 <nak> yeah it's super interesting; when i understand a new concept, i usually rewind and do it all over 1 or 2 more times to really flex that "brain muscle"
16:29:50 <haasn> ronh-: with fmap ?
16:29:50 <exio4> @type liftA2 id 
16:29:52 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
16:30:13 <ion> ronh: liftA3 = let (<*>) = liftA2 id in \f a b c -> f <$> a <*> b <*> c
16:30:32 <nak> i do have to say, i am delighted that each time i discuss these matters in this channel, everyone has been super helpful
16:30:32 <Forkk> @type liftA2
16:30:35 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:31:06 <Forkk> yeah, the haskell community is way more friendly than I expected
16:31:11 <nak> ion Forkk Zekka liste mjrosenb, you've all been super helpful and i *really* appreciate it
16:31:29 <nak> Forkk for sure. i was expecting tons of zealotry and pretentiousness 
16:31:49 <Forkk> :P
16:32:01 <nak> i'm gonna break for lunch, i'll be back shortly ^.^
16:32:15 <Forkk> o/
16:34:57 <ion> @type let thePrimitive = liftA2 (,) in \a b -> uncurry id <$> f a b
16:34:59 <lambdabot> (Functor f, Show t, Show t1, FromExpr (f (b1 -> b, b1))) => t -> t1 -> f b
16:35:06 <ion> @type let thePrimitive = liftA2 (,) in \a b -> uncurry id <$> thePrimitive a b
16:35:07 <lambdabot> Applicative f => f (b1 -> b) -> f b1 -> f b
16:36:27 <itsMontoya> Hey guys these resources you gave me are great. That first link definitely saved me some time (and money!)
16:37:09 <mjrosenb> j4cknewt: because it is very simple, and it is the type of thing where if you ever use Maybe, you probably want to use bind, even if you don't know it.
16:37:58 <ronh-> :t let (<*>) = liftA2 id in \f a b c -> f <$> a <*> b <*> c
16:38:00 <lambdabot> Applicative f => (a -> b) -> f (b2 -> b1 -> a) -> f b2 -> f b1 -> f b
16:38:09 <ronh-> that doesn't match liftA3?
16:38:28 <ion> :t let (<*>) = liftA2 id; infixl 4 <*> in \f a b c -> f <$> a <*> b <*> c
16:38:30 <lambdabot> Applicative f => (a -> b1 -> b -> c) -> f a -> f b1 -> f b -> f c
16:38:41 <ronh-> weird
16:39:24 <ronh-> why can we implement liftA3 with liftA3, but we can't implement liftA2 with fmap?
16:39:35 * hackagebot bytestring-lexing 0.5.0 - Parse and produce literals efficiently from strict or lazy bytestrings.  http://hackage.haskell.org/package/bytestring-lexing-0.5.0 (WrenThornton)
16:39:37 * hackagebot cabal-helper 0.3.5.0 - Simple interface to Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.3.5.0 (DanielG)
16:40:15 <ronh-> why can we implement liftA3 with liftA2, but we can't implement liftA2 with fmap?
16:40:51 <Cale> ronh-: Well, fmap gives no way to combine two f-structures
16:40:52 <ion> When you have (f a, f b) -> f (a, b), you can take (f (a, b), f c) -> f ((a, b), c) ad infinitum.
16:41:08 <ion> Functor doesn’t let you do that first step.
16:41:10 <ronh-> my wrong intuition was telling me the two would be equally impossible
16:41:19 <ion> That is exactly what Applicative gives you over Functor.
16:47:11 <rogers_> is there a debugger for ghc/i?
16:47:18 <bitemyapp> ghci has one built in
16:48:43 <rogers_> ok nice
16:51:15 <rogers_> one more unrelated question, can I just copy/paste sandbox dir from one project to another without anything weird happening?
16:51:45 <bitemyapp> not yet
16:53:18 <nolraiU> Um is there a reason I can't put Cabal in my build-depends?
16:54:14 <ozgura> rogers_: this guy seems to have something for you: http://www.edsko.net/2015/03/09/sandboxes-revisited -- see "Copying sandboxes"
16:55:13 <rogers_> thanks
16:56:20 <albeit> Is there a way to make the GHC runtime use cores 6-12 when -N6 is set, instead of the first six?
16:56:56 <ion> albeit: You could run the process with taskset.
16:58:07 <nolraiU> cabal thinks Cabal is missing..
16:58:58 <albeit> ion: How would that interact with -qa? If I set -N6, and then use taskset to set the process to use 6-11, are the capability numbers shifted? So "forkOn 0" would actually be forking onto core 6?
16:59:19 <ion> I have no idea.
16:59:55 <ion> I’d guess forkOn 0 would be forking onto one of the cores out of 6...11.
17:00:19 <ion> and 0 will map to the same core throughout the process
17:01:58 <lpaste> rogers pasted “ghci debugger not stopping at a breakpoint” at http://lpaste.net/134002
17:02:21 <albeit> Hmm I guess its more of a linux question. Quick google says that taskset calls sched_setaffinity, and the later call overrides the first... so I think GHC would re-set itself to core 0-6
17:02:40 <rogers_> what am I doing wrong? I checked several times and it seems I followed all the steps
17:03:51 <unknownloner> what exception do I need to catch to handle calling head on an empty list
17:04:02 <geekosaur> rogers_, is it compiled?
17:04:10 <unknownloner> and yes I know I can use headMaybe but I'm being lazy here
17:04:11 <geekosaur> if so, did you use :load with leading * to force source
17:04:12 <geekosaur> ?
17:04:36 <geekosaur> debugger can't debug compiled code, only interpreted
17:05:10 <rogers_> geekosaur: :l *test.hs?
17:05:23 <geekosaur> that should do it
17:05:35 <rogers_> it didnt :(
17:05:45 <geekosaur> unknownloner, I think ErrorCall
17:06:34 <itsMontoya> Do you guys think "Haskell School of Music" is a good read? 
17:06:50 <geekosaur> oh, I think I see it
17:06:59 <itsMontoya> I'm starting off with the links you guys gave me, but I had HSoM in PDF form on my computer. Was planning on reading it after I was done with the first links
17:07:25 <geekosaur> main is now a computed thunk, I suspect, and all it does is run the print action on an already computed value
17:07:39 <geekosaur> not certain of that but would explain it
17:07:40 <rogers_> oh
17:07:47 <geekosaur> try doing the qsort directly
17:08:08 <geekosaur> that is qsort [8, 4, 0, 3, 1, 23, 11, 18]
17:08:36 <rogers_> yes it worked if I did not call main before setting the breaking point
17:10:55 <rogers_> I am getting a bit weird output though
17:11:03 <Guest64536> download Website calculator Scripting the .zip oesn't require signup http://www.websiteadverts.org/forum/forumdisplay.php?fid=20 - i'm taking it down soon..
17:11:06 <Guest64536> download Website calculator Scripting the .zip oesn't require signup http://www.websiteadverts.org/forum/forumdisplay.php?fid=20 - i'm taking it down soon..
17:11:08 <Guest64536> download Website calculator Scripting the .zip oesn't require signup http://www.websiteadverts.org/forum/forumdisplay.php?fid=20 - i'm taking it down soon..
17:11:09 --- mode: ChanServ set +o geekosaur
17:11:27 --- mode: geekosaur set -o geekosaur
17:11:59 <rogers_> "left :: [Integer] = _" instead of just "left :: [Integer]" as in that guide
17:12:09 <bitemyapp> geekosaur: should /nick geekorawr when you are +o
17:12:34 <geekosaur> you have a later ghci and it shows the uncomputed thunk
17:12:52 --- mode: ChanServ set +o geekosaur
17:13:11 <rogers_> ah
17:13:12 <Guest64536> Download your copy of Website Calculator - Software that allows your visitors to calculate their website and drive in traffic for your website! http://www.websiteadverts.org/forum/forumdisplay.php?fid=20
17:13:13 <Guest64536> Download your copy of Website Calculator - Software that allows your visitors to calculate their website and drive in traffic for your website! http://www.websiteadverts.org/forum/forumdisplay.php?fid=20
17:13:14 <Guest64536> Download your copy of Website Calculator - Software that allows your visitors to calculate their website and drive in traffic for your website! http://www.websiteadverts.org/forum/forumdisplay.php?fid=20
17:13:15 --- mode: geekosaur set +b *!~hmm@host31-54-236-209.range31-54.btcentralplus.com
17:13:16 --- kick: Guest64536 was kicked by geekosaur (Your behavior is not conducive to the desired environment.)
17:13:32 --- mode: geekosaur set -o geekosaur
17:20:40 <itsMontoya> I might be getting ahead of myself in this reading, but I see "Int". Is there no Int32/Int64 in Haskell?
17:20:48 <itsMontoya> Rather it's determined based on the system it's compiled on?
17:20:57 <ion> Data.Int has Int32 and Int64
17:21:02 <itsMontoya> Ahh ok
17:21:06 <itsMontoya> And uInt I'm assuming?
17:21:09 <ion> Data.Word
17:21:51 <liste> > (maxBound :: Word8)
17:21:53 <lambdabot>  255
17:21:56 <liste> > (maxBound :: Word16)
17:21:58 <lambdabot>  65535
17:22:22 <sebastianrkg> is there anything like iHaskell/Kronos-Haskell for Windows? It's so awesome on OS X
17:22:24 <itsMontoya> >(maxBound:: UInt32)
17:22:27 <itsMontoya> Oh, I fail
17:22:28 <itsMontoya> lol
17:24:09 <rogers_> so why are some peolle saying that haskell doesnt have a usable debugger? ghci's debugger seems to do what it should
17:24:40 <rogers_> arwle there some limitations that I am not seeing yet
17:26:33 <itsMontoya> I really like how round/ceil/floor converts float to int
17:27:03 <itsMontoya> In other languages I have to do something like int64(ceil(3.654))
17:29:08 <rogers_> :t round
17:29:10 <lambdabot> (Integral b, RealFrac a) => a -> b
17:30:39 <rogers_> it returned Int because you used the result as an Int somewhere down the line. perhaps passing it to a function that accepted an Int
17:31:02 <rogers_> type inference is neat
17:34:28 <bitemyapp> rogers_: yep :)
17:36:58 <Jumbo> Always wanted a Website Price Calculator Script like siteprice.org for your own website? Well now you can, it even have a installer. Download it without having to signup at as soon on twitter http://t.co/EN7trb5ZgL
17:37:33 <nak> ...
17:37:46 <nak> Who does that ?
17:38:35 <nak> lol http://www.siteprice.org/website-worth/www.google.com
17:38:41 <nak> pretty sure google is worth more than $2B
17:39:01 <liste> :D
17:39:54 <liste> well I guess spammers are usually kicked soon enough
17:40:35 <nak> liste i think freenode should permaban their ips tho
17:40:47 <nak> or at least ban them for a long time
17:41:48 <Fylwind> interesting, so all this time the reason why I couldn't get a good heap profile (while troubleshooting a memory leak) was because the leak happened too fast for the heap profiler to catch it in action (the program dies within 0.1 sec of it happening)
17:42:20 <bitemyapp> Fylwind: sleep?
17:46:58 <Fylwind> bitemyapp: no the program is fine most of the time, except for <0.1 sec just before the crash at the end
17:48:09 <nak> question re: Maybe Monad
17:48:14 <nak> http://www.seas.upenn.edu/~cis194/lectures/07-monads.html
17:49:02 <nak> they're using (whatever) >>= \r -> return (whateverelse)
17:49:08 <nak> the `return` there
17:49:19 <bitemyapp> > return 1 :: [Int]
17:49:21 <lambdabot>  [1]
17:49:24 <bitemyapp> > return 1 :: Maybe Int
17:49:25 <lambdabot>  Just 1
17:49:29 <nak> since it's the Maybe Monad, and `return = Just`, could I also use `(Just whatever)` instead ?
17:49:37 <Fylwind> does anyone know how to debug this really simple but obviously wrong code? http://lpaste.net/134003 i.e. pretend you don't know why this code blows up in memory; how would you find out the fault lies with 'frobnicate'?  (I'm trying to learn how to use GHC's profiling tools)
17:49:38 * hackagebot bytestring-lexing 0.5.0.1 - Parse and produce literals efficiently from strict or lazy bytestrings.  http://hackage.haskell.org/package/bytestring-lexing-0.5.0.1 (WrenThornton)
17:49:40 <ion> Yes
17:49:47 <nak> ion are you saying yes to me?
17:49:48 <bitemyapp> nak: could. You'd make the type more specific in the process. But ya could.
17:49:54 <bitemyapp> nak: yes ion was.
17:50:17 <nak> ok but the type signature of zipTree3 ends with -> Maybe (Tree c)
17:50:31 <bitemyapp> nak: then it becomes Just regardless.
17:50:37 <nak> i understand that
17:50:39 <bitemyapp> up to preference at that point
17:50:42 <nak> buti feel like the Just (Node ...) is more explicit
17:50:46 <bitemyapp> it is.
17:50:55 <Fylwind> I'm using '+RTS -M250M -i0.001 -h' and I've tried a variety of '-h'-like flags but none of the results seem to provide any hints that 'frobnicate' is to blame
17:51:32 <nak> also, does haskell know to evaluate the Maybe Monad (>>=) because (zipTree3 f l1 l2) returns a Maybe ?
17:51:54 <nak> this is my best guess anyway
17:53:53 <azure-satellite> Can I ask someone about applicative/adt?
17:56:24 <ion> Given (>>=) :: … => m a -> (a -> m b) -> m b, if just one of those “m”s is constrained to Maybe, that will “flow” to all directions in type inference.
17:57:17 <ion> azure-satellite: No need to ask to ask, feel free to ask your question.
17:58:07 <azure-satellite> So I’m reading the typeclassopedia and trying to solve (3), which goes like
17:58:10 <azure-satellite> Implement Functor and Monad instances for Free f, defined as
17:58:10 <azure-satellite> data Free f a = Var a
17:58:11 <azure-satellite>               | Node (f (Free f a))
17:58:12 <azure-satellite> You may assume that f has a Functor instance. This is known as the free monad built from the functor f.
17:58:34 <azure-satellite> Which would be a sensible definition for (<*>)?
17:58:42 <ion> ap
17:58:43 <alynn> (<*>) = ap
17:58:45 <nak> ion ah gotcha
17:58:52 <nak> ion that would make sense, too
17:58:57 <nak> we can't mix the type constructors
17:59:16 <nak> ion what other types of Monads exist
17:59:24 <nak> i can't really picture one aside from Maybe
17:59:27 <alynn> ap defines (<*>) in terms of return and (>>=) which are much easier to implement for Free :)
17:59:29 <nak> (seeing as that's the only one i dissected)
18:00:53 <ion> nak: Look at the list of instances in the documentation for Monad. You could look at Reader and [] next, perhaps followed by State.
18:02:25 <nak> ah duh !
18:02:52 <nak> i didn't think that the documentation would have an exhaustive list, but a list of Monad instances would make sense
18:03:54 <ion> The list isn't exhaustive for Hackage but it should be exhaustive for the base package.
18:04:30 <ronh-> nak, surely you've been using one other monad already: IO
18:05:20 <ronh-> > getLine >>= putStrLn
18:05:23 <lambdabot>  <IO ()>
18:05:34 <ion> You might want to try to implement instance Monad ((->) r) and instance Monad [] yourself without looking at the implementation in base.
18:06:47 <nak> ronh- i actually haven't done any IO yet
18:08:00 <nak> ion i can't even picture what `instance Monad ((->) r)` would be
18:08:05 <nak> or `instance Monad []`
18:09:50 <pingu> nak: maybe start with maybe
18:09:53 <pingu> it's pretty easy
18:11:53 <athan> ReinH: ping
18:11:54 <ronh-> [] should be easier to understand than ((->) r)
18:12:01 <athan> So... I kinda want to write it as a paper :\
18:12:12 <athan> It's going to be short - 3 or 4 pages
18:12:25 <athan> I just feel like that setting will relay the idea more clearly
18:12:33 <nak> pingu i've started with Maybe
18:12:36 <ReinH> athan: Pong
18:12:49 <nak> pingu I think I fully understand the Maybe Monad now
18:14:22 <ReinH> nak: Maybe is a monad for computations with 0 or 1 result. [] is for computations with any number of results.
18:14:40 <itsMontoya> Try not to laugh, but can someone help me figure out what I'm doing wrong here?
18:14:40 <itsMontoya> https://gist.github.com/itsmontoya/8fe88998c8dcdb651ae5
18:14:54 <ReinH> [] and [x] cases are just like Maybe
18:15:18 <nak> :t concatMap
18:15:20 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
18:15:41 <nak> ReinH interesting 
18:16:25 <ion> itsMontoya: Insert between lines 1 and 2 the line: isEven n
18:16:46 <itsMontoya> ion: Bahaha, I was just doing that :)
18:16:54 <itsMontoya> That method I'm using is called a guard right?
18:16:59 <nak> itsMontoya correct
18:17:04 <nak> the | are guards
18:17:10 <itsMontoya> Can I do that type of expression without a guard?
18:17:20 <nak> itsMontoya sure
18:17:22 <itsMontoya> Or is guard the correct approach?
18:17:42 <nak> itsMontoya: isEven n = n `mod` 2 == 0
18:18:43 <nak> i think this would also work: isEven = (==0) . (`mod` 2)
18:19:05 <ion> It's better with the n
18:19:22 <itsMontoya> Ah ok, I personally like i with the 'n' so it's more concise
18:19:31 <itsMontoya> But I want to make sure I'm learning the proper methods per Haskell best practices
18:19:31 * nak nods
18:19:38 <itsMontoya> And whatever is idiomatic :)
18:19:38 <nak> yeah i think the `n` is more readable too
18:20:04 <nak> itsMontoya the first example you have shows returning an explicit boolean
18:20:20 <nak> but because (==) returns a boolean, you can just return that instead
18:20:25 <itsMontoya> I personally like the first example you gave
18:20:27 <nak> yeah
18:20:38 <nak> isEven n = n `mod` 2 == 0
18:20:43 <nak> that's nice and readable
18:21:20 <itsMontoya> https://gist.github.com/itsmontoya/8fe88998c8dcdb651ae5
18:21:31 <itsMontoya> Is there a way to compile without needing a main?
18:21:34 <itsMontoya> Or is main always needed?
18:22:04 <nak> itsMontoya you might want to start with ghci if you haven't learned about `main` yet
18:22:10 <nak> itsMontoya start up ghci and do
18:22:11 <ronh-> ghc -o hello tries to create executable. you can't have executable without main
18:22:14 <nak> :load hello
18:22:22 <nak> > isEven 2
18:22:23 <itsMontoya> Ahhhh
18:22:26 <lambdabot>  Not in scope: ‘isEven’
18:22:38 <itsMontoya> ronh-: Got it! Much appreciated
18:22:41 <ion> Or ghci hello.hs
18:22:42 <rasen> > even 2
18:22:45 <lambdabot>  True
18:22:49 <itsMontoya> nak: Ah ok, I was playing with ghci a bit. I'll try it more righ tnow
18:31:10 <nak> is `fail` being removed from all the Monads ?
18:32:25 <geekosaur> I think the idea is that monads with a useful meaning for it are members of another class (MonadZero? that's how it used to work IIRC)
18:39:51 <luzie> is there a name for Data.Map.differenceWith (_ y -> Just y)
18:48:44 <azure-satellite> What would be an implementation for (>>=) given data Free f a = Var a | Node (f (Free f a))
18:48:44 <azure-satellite> where f is a functor?
18:50:53 <ReinH> azure-satellite: well, what is return?
18:51:35 <azure-satellite> ReinH: return x = Var x
18:51:42 <ReinH> right
18:51:51 <ReinH> what is Pure a >>= f = ???
18:52:03 <ReinH> er, Var
18:52:19 <ReinH> (it's just the monad law)
18:52:22 <azure-satellite> Var x >>= f = f x
18:52:26 <ReinH> yes
18:52:30 <ReinH> now the hard one
18:52:32 <azure-satellite> That one is the easy one
18:52:34 <azure-satellite> Right...
18:52:40 <ReinH> Node m >>= f = ???
18:52:44 <azure-satellite> Which is the one I’m stuck in
18:52:48 <azure-satellite> 2hrs
18:53:04 <ReinH> :t (>>=)
18:53:05 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:53:34 <ReinH> @let data Free' f a = Pure' a | Free' (f (Free f a))
18:53:35 <lambdabot>  .L.hs:146:28:
18:53:36 <lambdabot>      Not in scope: type constructor or class ‘Free’
18:53:36 <lambdabot>      Perhaps you meant one of these:
18:53:45 <ReinH> :t Free
18:53:46 <lambdabot> Not in scope: data constructor ‘Free’
18:53:48 <ReinH> :(
18:54:04 <azure-satellite> Right. The problem is that in Node x >>= f = ??? x is a functor
18:54:42 <ReinH> Well, let's get the easy part out of the way
18:55:05 <ReinH> the result has to be of type Free f a so it has to be constructed from one of the two data costructors
18:55:11 <ReinH> and it's not a return, so it's...
18:55:21 <ReinH> (the other one)
18:55:29 <ReinH> so Nome m >>= f = Node ???
18:55:33 <ReinH> *Node
18:55:48 <bitemyapp> Nome m >>= f = Node Alaska
18:56:00 <ReinH> bitemyapp: :p
18:56:13 <ReinH> Now, what Free does is defer binding until later
18:56:26 <ReinH> so if we have bind f = (>>= f)
18:56:54 <bitemyapp> Free Monads operate on the ancient technology of dog sledding. We bind dogs to sleds and defer arrival until the dogs finish running.
18:57:01 <ReinH> bitemyapp: I hate you
18:57:10 <nak> ^^
18:57:13 <taksuyu> Heheh
18:57:17 <bitemyapp> ReinH: not as much as acowley hates me right now.
18:57:19 <nak> bitemyapp is over-tired
18:57:21 <ReinH> bitemyapp: <3
18:57:56 <ReinH> Node m >>= f == Node (... something with bind f and m that type checks...)
18:58:38 <ReinH> Another piece is:
18:58:39 <ReinH> :t fmap
18:58:40 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:58:54 <ReinH> one way to look at fmap is that it defers the application of the (a -> b) until the f yields its result
18:59:17 <ReinH> so since we want to defer application of (bind f)
18:59:18 <ReinH> we might try
18:59:33 <ReinH> (application of bind f to m)
18:59:36 <ReinH> Node m >>= f = Node (fmap (bind f) m)
18:59:38 <ReinH> and see if it type checks
18:59:40 <ReinH> does it?
19:00:02 <ReinH> azure-satellite: does that make sense?
19:00:26 <azure-satellite> ReinH: Let me process that. This is no easy stuff for me :(
19:00:38 <ReinH> azure-satellite: sure. feel free to ask questions.
19:00:41 <ReinH> that was a free monad joke.
19:00:55 <nak> :t bind
19:00:58 <lambdabot>     Not in scope: ‘bind’
19:00:58 <lambdabot>     Perhaps you meant one of these:
19:00:58 <lambdabot>       ‘BS.find’ (imported from Data.ByteString),
19:01:00 <linman16> is it possible to constrain a type parameter?
19:01:05 <nak> ReinH i'm confused !
19:01:06 <ReinH> nak: I defined bind above as just an infix (>>=)
19:01:11 <ReinH> so properly:
19:01:17 <ReinH> Node m >>= f = Node (fmap (>>= f) m)
19:01:29 <linman16> data (Ord a) => Tree a where
19:01:30 <nak>  whoa
19:01:47 <nak> ReinH I was trying stuff while you guys were talking it out
19:01:48 <ReinH> linman16: yes, but it doesn't do what you want
19:01:59 <ReinH> linman16: what you want to do is constrain the call sites
19:02:01 <ReinH> e.g.
19:02:04 <nak> things like (Node blah blah blah) >= f = ...
19:02:08 <nak> but i was hitting walls
19:02:18 <nak> pattern matching the Node internals didn't seem to work
19:02:35 <ReinH> s/call sites/use sites
19:02:45 <ReinH> :t M.lookup -- linman16
19:02:47 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
19:02:58 <ReinH> that's where the Ord constraint lives for Data.Map, not in the data type itself
19:03:00 <linman16> ReinH: that is more work, right? 
19:03:23 <ReinH> linman16: yes, but since it's what affords the possibility of doing what you want, it's sort of worth it
19:03:47 <azure-satellite> ReinH: Actually   Node m >>= f = Node (fmap ((>>=) f) m) does not typecheck. But this does:
19:03:53 <linman16> ReinH: haha. it is worth it b/c it is only way to do it? 
19:03:57 <azure-satellite>   Node x >>= f = Node (fmap (>>= f) x)
19:04:02 <ReinH> The GHC extension that allows you to provide constraints on (non-GADT) data types has been deprecated bevause it doesn't do what you want
19:04:10 <linman16> ReinH: that is fine by me i guess
19:04:14 <ReinH> azure-satellite: :)
19:04:34 <ReinH> azure-satellite: Now you have to decide whether I made a mistake or left that in there for you to correct ;)
19:04:39 <linman16> ReinH: oh, this is a gadt in this case
19:04:40 <azure-satellite> ReinH: The reason is that (>>=) was being taken as prefix, expecting the monad as its first argument
19:04:54 <azure-satellite> ReinH: ;)
19:04:58 <ReinH> azure-satellite: (Yes, bind is flip (>>=))
19:05:26 <ReinH> I mixed that up a bit :)
19:05:45 <ReinH> azure-satellite: anyway, does it make sense *why* that would be the definition of >>=?
19:06:22 <azure-satellite> ReinH: It just feels that somehow I had to use the ‘m b’ from ‘f’ as opposed to creating one ourselves with ‘Node’. If you know what I mean
19:06:41 <nak> so the final answer is: Node m >>= k = Node (fmap (>>= k) m
19:06:42 <nak> ?
19:06:45 <ReinH> azure-satellite: but you can't, though. The only way to create an inhbitant of Free  is to use one of the constructors
19:06:51 <ReinH> your f doesn't know anything about them
19:06:54 <azure-satellite> ReinH: It makes sense that’s *one* definition. Not why is *the* definition
19:06:59 <ReinH> nak: yes, see http://hackage.haskell.org/package/free-4.12.1/docs/src/Control-Monad-Free.html#Free
19:07:25 <ReinH> azure-satellite: because it's a free construction
19:07:28 <ReinH> there is only one
19:07:38 <ReinH> others are isomorphic
19:07:45 <ReinH> @hackage operational
19:07:45 <lambdabot> http://hackage.haskell.org/package/operational
19:07:57 <ReinH> That's another free construction
19:08:10 <ReinH> exercise for the reader: show that it is (or isn't) isomorphic to Free
19:08:30 <azure-satellite> ReinH: I don’t know about “free constructions”. Can I read about them somewhere?
19:08:42 <linman16> ReinH: wait so is gadt different story regarding constraint?
19:08:43 <ReinH> azure-satellite: yes, but it requires some category theory http://en.wikipedia.org/wiki/Free_object
19:09:12 <azure-satellite> Aw. Damnit. There we go again with the rabbit hole :(
19:09:40 <ReinH> linman16: see http://stackoverflow.com/questions/21505975/write-gadt-record-with-constrained-type
19:09:49 <ReinH> azure-satellite: enjoy it! :p
19:10:02 <ReinH> I have to go play GURPS now ttyl
19:10:29 <linman16> ttyl ReinH
19:10:38 <nak> ReinH quickly before u go !
19:10:44 <nak> why doesn't this work
19:10:53 <nak> > fmap (>>= (+1)) (Just 1)
19:10:55 <lambdabot>      No instance for (Show (m0 b0))
19:10:55 <lambdabot>        arising from a use of ‘show_M826841045048389353627335’
19:10:55 <lambdabot>      The type variables ‘m0’, ‘b0’ are ambiguous
19:10:59 <azure-satellite> ReinH: ttyl
19:11:32 <ReinH> :t fmap (>>= (+1)) (Just 1)
19:11:34 <lambdabot> (Monad m, Num (m b), Num (m (m b))) => Maybe (m b)
19:11:41 <ReinH> ... because.
19:11:57 <azure-satellite> nak: 1 is not a monad, so you can’t bind over it
19:12:00 <ReinH> :t (>>=)
19:12:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:12:17 <ReinH> For what monad m is (+1) of type a -> m b
19:12:32 <nak> oo
19:13:30 <nak> > fmap (>>= \x -> Just x + 1) (Just 1)
19:13:32 <lambdabot>      No instance for (Show b0)
19:13:32 <lambdabot>        arising from a use of ‘show_M143757835353757197427384’
19:13:32 <lambdabot>      The type variable ‘b0’ is ambiguous
19:13:47 <nak> hmm
19:13:51 <nak> ReinH i won't keep you longer
19:13:54 <nak> sorry ^.^
19:14:24 <azure-satellite> nak: fmap f (Just 1) == Just (f 1)
19:14:48 <azure-satellite> nak: but f 1 = 1 >>= \x Just x + 1
19:15:14 <azure-satellite> :t >>=
19:15:16 <lambdabot> parse error on input ‘>>=’
19:15:17 <azure-satellite> :t (>>=)
19:15:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:16:25 <azure-satellite> nak: 1 >>= \x -> Just (x + 1)
19:17:01 <azure-satellite> nak: can’t go since Int is not a monad
19:17:38 <nak> azure-satellite ah yours worked before because x was a functor
19:17:42 <nak> from (Node x)
19:17:47 <linman16> > fmap (>>= (+1)) (Just (Just 1))
19:17:50 <lambdabot>      No instance for (Show b0)
19:17:50 <lambdabot>        arising from a use of ‘show_M422076423487267738927468’
19:17:50 <lambdabot>      The type variable ‘b0’ is ambiguous
19:18:11 <azure-satellite> > show $ fmap (>>= (+1)) (Just (Just 1))
19:18:13 <lambdabot>      No instance for (Show b0) arising from a use of ‘show’
19:18:14 <lambdabot>      The type variable ‘b0’ is ambiguous
19:18:14 <lambdabot>      Note: there are several potential instances:
19:18:33 <azure-satellite> hmm....
19:18:41 <nak> weird, right ?
19:19:02 <azure-satellite> :t fmap (>>= (+1)) (Just (Just 1))
19:19:04 <lambdabot> Num (Maybe b) => Maybe (Maybe b)
19:19:58 <azure-satellite> > (fmap (>>= (+1)) (Just (Just 1))) == Just (Just 2)
19:20:00 <lambdabot>      No instance for (Num (Maybe b0)) arising from a use of ‘+’
19:20:00 <lambdabot>      In the second argument of ‘(>>=)’, namely ‘(+ 1)’
19:20:00 <lambdabot>      In the first argument of ‘fmap’, namely ‘(>>= (+ 1))’
19:20:26 <nak> > fmap (>>= \x -> Just (x+1)) (Just (Just 1))
19:20:29 <lambdabot>  Just (Just 2)
19:20:32 <nak> there we go
19:20:54 <nak> > fmap (>>= \x -> Just (x+1)) (Just 1)
19:20:56 <lambdabot>      No instance for (Show b0)
19:20:56 <lambdabot>        arising from a use of ‘show_M774220238820578491527561’
19:20:56 <lambdabot>      The type variable ‘b0’ is ambiguous
19:21:05 <nak> hmm ok yeah that makes sense then
19:21:19 <Forkk> O_O what the hell is show_M774220238820578491527561
19:21:20 <azure-satellite> nak: Right.
19:21:33 <nak> Forkk lol uh
19:21:37 * nak hides
19:21:39 <nak> i didn't do it?
19:21:40 <nak> ^.^
19:21:52 <ReinH> nak: this is a monad law :)
19:22:10 <ReinH> the point of free constructions is that they literally implement the laws and nothing else
19:22:24 <ReinH> so a free monad implements the monad laws and no other relationship between the elements
19:22:30 <nak> ReinH yeah, "free constructions" is something i've never encountered
19:22:34 <nak> so there's still some fundamentals i'm missing
19:22:43 <nak> i only *just* learned the Maybe Monad today lol
19:22:46 <ReinH> which is why the implementation of >>= for free is a literal restatement of the monad laws
19:23:32 <shachaf> Does the implementation of the operations for a free object need to be related to the laws?
19:23:52 <ReinH> shachaf: um. maybe?
19:23:54 <azure-satellite> nak: There is a long road. I understand Monads coneptually and have done some stuff with them, but the types burn brain cycles to analyze.
19:23:57 <ReinH> it needs to satisfy the laws?
19:24:04 <ReinH> shachaf: did I say something wrong?
19:24:11 <shachaf> That's true for every object, not just free objects.
19:24:19 <shachaf> I don't know, did you?
19:24:32 <ReinH> shachaf: Not interested in playing this game tonight, thanks
19:24:33 <shachaf> You seem very guilty all of a sudden, so who knows!
19:24:37 <ReinH> shachaf: ha!
19:24:37 <shachaf> Huh?
19:24:47 <ReinH> shachaf: well, you are good at making me doubt myself
19:24:51 <shachaf> I just asked a question.
19:25:04 <Guest23220> Download the Fr4eefavicon.net Generator Script Clone (requires MySQL and {PHP) download attachment at http://www.websiteadverts.org/forum/showthread.php?tid=21
19:25:05 <Guest23220> Download the Fr4eefavicon.net Generator Script Clone (requires MySQL and {PHP) download attachment at http://www.websiteadverts.org/forum/showthread.php?tid=21
19:25:11 <Guest23220> Download the Fr4eefavicon.net Generator Script Clone (requires MySQL and {PHP) download attachment at http://www.websiteadverts.org/forum/showthread.php?tid=21
19:25:35 * nak nods
19:25:38 <nak> thanks azure-satellite  and ReinH 
19:25:46 <nak> azure-satellite your exercise was fun regardless :)
19:25:52 <ReinH> shachaf: (the game is the one where I say something and you restate what I just said in the form of a question)
19:26:28 <shachaf> Not familiar.
19:26:30 <dolio> I thought the game is where you speak in one syllable words.
19:26:36 <azure-satellite> nak: Hehe. Typeclassopedia
19:26:36 <Forkk> ReinH, is the game the one where you say something and I restate what you just said in the form of a question?
19:26:43 <ReinH> Forkk: I hate you
19:26:47 <Forkk> <3
19:26:55 <ReinH> dolio: then we both lost
19:26:57 <Forkk> </3
19:27:23 <nak> Forkk i thought the game was one where he says something and you restate what he just said in the form of a question...
19:27:26 <azure-satellite> Forkk: <3?
19:27:53 <azure-satellite> Forkk: Minimal complete representation lol
19:28:05 <Forkk> @type <3
19:28:07 <lambdabot> parse error on input ‘<’
19:28:11 <Forkk> D:
19:28:12 <nak> :t (<3)
19:28:13 <lambdabot> (Num a, Ord a) => a -> Bool
19:28:15 <nak> lol
19:28:16 <Forkk> @type (<3)
19:28:17 <lambdabot> (Num a, Ord a) => a -> Bool
19:28:19 <Forkk> oh
19:28:23 <Forkk> :P
19:28:37 <Forkk> What is love?
19:28:37 <Forkk> (Num a, Ord a) => a -> Bool
19:28:49 <azure-satellite> Forkk: No I meant how can you restate ‘<3’ as a question. There is only one way (<3?)
19:28:54 <davidfetter> baby, don't hurt
19:28:54 <Forkk> oh
19:28:56 <davidfetter> me
19:28:56 <Forkk> lol
19:29:00 <davidfetter> don't hurt me
19:29:03 <davidfetter> no more
19:29:03 <azure-satellite> :t “Baby don’t hurn me”
19:29:05 <lambdabot> lexical error at character '\8220'
19:29:06 <davidfetter> sorry
19:29:25 <azure-satellite> damn. lambdadot doesn’t like to be hurt
19:29:37 <Forkk> lol get your fancy apostrophes out of here
19:29:48 <Forkk> actually, it was probably the quotes
19:30:02 <Forkk> :t "Baby don't hurt me"
19:30:03 <lambdabot> [Char]
19:30:37 <thoughtpolice> > let i = id; love = (<3); you = 1 in i <3 you
19:30:39 <lambdabot>      No instance for (Ord (a0 -> a0))
19:30:39 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
19:30:39 <lambdabot>        arising from a use of ‘<’
19:30:49 <Forkk> lol
19:31:11 <thoughtpolice> > let i = id; love = (<3); you = 1 in i love you
19:31:13 <lambdabot>  True
19:31:29 <azure-satellite> ^^OMG
19:31:53 <azure-satellite> I’m copying that. Thank you very much. As my email signature
19:32:02 <nak> > let fork = 1 in (<3) fork
19:32:04 <lambdabot>  True
19:32:10 <nak> Forkk ^ yay
19:32:14 <Forkk> lol
19:32:37 <nak> oh thoughtpolice's was way better dammit
19:32:40 <ReinH> thoughtpolice: wait, wtf is (<3)?
19:32:42 <Forkk> > let what = "Baby don't "; is = (++); love = "hurt me" in what `is` love
19:32:44 <lambdabot>  "Baby don't hurt me"
19:32:50 <exio4> ReinH: \x -> x < 3 :p 
19:33:00 <Forkk> or
19:33:02 <ReinH> god dan it
19:33:07 * davidfetter considers the possibility that haddaway's entire œvre may be the output of a haskell program
19:33:09 <nak> ReinH yeah it's just ... lol
19:33:18 <exio4> @type (<3) 
19:33:19 <albeit_> If I have a function "foo :: Int -> Char -> String -> Foo; foo a b = ...", how does it know if a is Int or Iint -> Char?
19:33:19 <lambdabot> (Num a, Ord a) => a -> Bool
19:33:21 <Forkk> > let what = (++); is = "Baby don't "; love = "hurt me" in what is love
19:33:23 <lambdabot>  "Baby don't hurt me"
19:33:29 <ReinH> yes. thank you.
19:33:45 <nak> Forkk lol @ love = "hurt me"
19:33:50 <nak> you have a weird definition of love
19:33:50 <Forkk> lol
19:34:02 <Forkk> I didn't even think about that
19:34:12 <Forkk> I just wanted it to output "baby don't hurt me"
19:34:18 * nak nods
19:34:25 <nak> freudian slip
19:34:36 <Forkk> albeit_, a is an int because it's the first argument
19:34:54 <azure-satellite> does anyone know how to prevent colloquy to change quotes to fancy quotes in Mac OS X?
19:35:09 <Forkk> not sure
19:35:15 <funfunctor> Hi, can someone remind me of the use of phantom types? I feel I am missing something
19:35:16 <nak> azure-satellite, right click in the text area, click "subsitutions" 
19:35:16 <albeit_> Forkk: But couldn't the type be interpreted as "foo :: (Int -> Char) -> String -> Foo", in chase case a :: (Int -> Char)?
19:35:17 <Forkk> I use decent software, so I wouldn't know
19:35:21 <Forkk> :P
19:35:26 <nak> azure-satellite disable "smart quotes"
19:35:33 <funfunctor> Perhaps some constructed simple examples may help
19:35:40 <nak> azure-satellite that's not colloquy-specific, btw
19:35:55 <nak> Forkk which client do u use ?
19:36:05 <azure-satellite> nak: Nice. Thanks
19:36:10 <Forkk> quassel (which really isn't decent software tbh)
19:36:13 <azure-satellite> :t "This is me"
19:36:14 <lambdabot> [Char]
19:36:22 <azure-satellite> Finally
19:36:23 <davidfetter> <-- chatzilla :P
19:36:26 <Forkk> albeit_, -> is right-associative I think
19:36:29 <Forkk> or left
19:36:36 <Forkk> I can't remember which is which
19:36:57 <Forkk> but `foo :: (a -> b) -> c` is not the same as `foo :: a -> b -> c`
19:37:20 <albeit_> Really? I though the parentheses were just for reading comprehension
19:37:22 <Forkk> however, `foo :: a -> b -> c` _is_ the same as `foo :: a -> (b -> c)`
19:37:34 <albeit_> Okay
19:37:56 <Forkk> it associates to the right (or left, I can't remember which is which)
19:38:03 <Forkk> someone help me out here D:
19:38:17 <nak> azure-satellite ^.^
19:38:26 <nak> azure-satellite there's another annoying ones like smart hypens
19:38:33 <nak> that converts -- to a long dash
19:38:50 <azure-satellite> nak: not anymore
19:39:10 <Forkk> right, so right associativity is a + b + c == a + (b + c)
19:39:15 <Forkk> so it's right associative :P
19:39:19 <nak> right associative, correct
19:39:26 <nak> 1 + 2 + 3 == 1 + (2 + 3)
19:39:45 <albeit_> Great thanks, that makes sense
19:39:50 <Forkk> no problem
19:48:47 <Forkk> here's another one
19:48:48 <Forkk> > let what = map; is = succ; love = "A`ax\UScnm&s\USgtqs\USld" in what is love
19:48:50 <lambdabot>  "Baby don't hurt me"
19:54:25 <nak> can someone help https://gist.github.com/naomik/9e5d0fa86cc2c6f40abc
19:54:33 <nak> "Pattern match(es) are overlapped"
19:54:52 <nak> i'm trying to implement my own thing to check for understanding of Maybe monad
19:54:57 <Maxdamantus> > let what = map; succedes = succ in what succedes "IBM"
19:54:59 <lambdabot>  "JCN"
19:55:14 <Maxdamantus> er, damn it.
19:55:57 <nak> i think there is something wrong with my data type
19:55:57 <Forkk> nak, reverse the order of that
19:56:04 <nak> Forkk what do u mean
19:56:22 <yuanjs> :help
19:56:34 <nak> Forkk oh put the Done Done on top ?
19:56:50 <Forkk> `zipQueue' Done _` and `zipQueue' _ Done` will match all of what Done Done does
19:57:03 <Forkk> matches are done in order, so the most specific needs to be at the top
19:57:12 <Forkk> as is, your Done Done function will never be executed
19:57:12 <Maxdamantus> > let a = 0.1; b = 0.2; c = 0.3 in (a + b) + c == a + (b + c)
19:57:15 <lambdabot>  False
19:57:26 <nak> ahhh
19:57:32 <nak> Forkk ok this makes sense
19:57:57 <Forkk> although I wouldn't think that would be an error
19:58:01 <Forkk> maybe just a warning
19:58:05 <funfunctor> I'm having a little issue understanding this: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/explicit-forall#scopedtypevariables can someone talk it though with me
19:58:12 <nak> Forkk is there a way to skip the intermediate `q` ?
19:58:21 <nak> Forkk something like Just (Task (x,y) <- zipQueue' l r)
19:58:42 <funfunctor> i.e. be a bit more explicit what they mean by inner and outer
19:59:17 <Forkk> nak, what is that <- ?
19:59:19 <funfunctor> in fact, if it could be put in mathematical terms that would be most optimal for me
19:59:34 <Forkk> oh nevermind
19:59:36 <Forkk> lol
20:00:06 <Forkk> nak, you might be able to do some trickery with bind to get around it
20:00:39 <nak> Forkk ok i was just curios
20:00:45 <nak> the q <- ...
20:00:46 <Forkk> something like `zipQueue' l r >>= (Just . Task (x, y))`
20:00:47 <nak> works
20:00:49 <Maxdamantus> Forkk: oh, + should be left-associative, not right-associative.
20:01:00 * Maxdamantus thought people were talking about it being just associative.
20:01:01 <nak> Forkk yeah that should work too
20:01:04 <Forkk> Maxdamantus, I know, I was using + because I didn't want to type ->
20:01:20 <nak> Forkk i actually like that better yes
20:01:29 <Forkk> nak, generally I try to avoid complex expressions like that
20:01:45 <Forkk> they make code shorter, but sometimes they are pretty detrimental to readability
20:01:49 <Maxdamantus> Ah, right.
20:01:56 <Forkk> it's good to think about who might be reading your code later
20:02:10 <Forkk> and remember that you yourself also need to be able to read it later
20:02:37 <Forkk> Haskell has some issues with complex expressions that can require a lot of work to decipher
20:02:43 <nak> zip or rather, 
20:02:50 <nak> Forkk, or rather
20:03:11 <nak> zipQueue' l r >>= \q -> Just (Task (x,y) q)
20:03:29 <Forkk> that works too I guess
20:03:40 <Forkk> that's literally what the do notation translates to
20:03:53 <Forkk> I'd say that's even less readable though :P
20:04:47 <nak> well dangit !
20:04:48 <nak> ok 
20:04:51 <nak> do notation it is !
20:05:06 <Forkk> Honestly for a simple expression like this, you should be fine
20:05:07 <nak> i'm glad i'm starting to grok the analogs tho
20:05:18 <Forkk> but I've seen some crazy shit and it's *not* fun to read
20:05:25 <Forkk> I've written some crazy shit too
20:06:27 <nak> Forkk: zipQueue' (Task 1 (Task 2 Done)) (Task 'a' (Task 'b' Done))
20:06:36 <nak> -- Just (Task (1,'a') (Task (2,'b') Done))
20:06:38 <nak> so cool
20:06:50 <nak> it will also return Nothing if the Queue lengths don't match
20:06:57 <nak> Haskell is neat
20:06:59 <nak> très neat
20:07:47 * Forkk is now browsing old code to find some ugly expressions :P
20:08:23 <Forkk> so much <$>
20:09:15 <hodapp> oh, I look at Haskell code I wrote 3 months ago and gag sometimes
20:09:23 <alisia> How can I perform a IO from a route handler in Scotty web framework?
20:10:02 <bitemyapp> alisia: probably liftIO
20:10:07 <bitemyapp> @ty liftIO
20:10:09 <lambdabot> MonadIO m => IO a -> m a
20:10:10 <exio4> nak: x >>= return . f is just fmap f x 
20:10:19 <Forkk> hodapp, the first thing I ever wrote in haskell is really nasty
20:10:34 <Forkk> I was under a time constraint and picked a language I didn't know very well
20:10:37 <Forkk> it's ugly
20:10:42 <Forkk> I didn't even use cabal
20:10:46 <hodapp> hah
20:13:53 <Forkk> Is there an easy way to put a whole folder on gist?
20:14:28 <Forkk> nevermind got it manually
20:14:33 <itsMontoya> Is there a Haskell format by chance?
20:14:35 <Forkk> enjoy https://gist.github.com/Forkk/78a0c385725fad283723
20:14:41 <Forkk> it's probably embarrassingly bad
20:15:48 <Forkk> nak, this is why you don't write short expressions like that: `genConnsIter cFun vs i v = [(i, j) | j <- [i..(V.length vs)-1], cFun (vs V.! i) (vs V.! j)]`
20:15:54 <Forkk> I have no fucking clue what that does
20:16:09 * nak nods
20:17:00 <Forkk> then again, nobody in their right mind would write something like that
20:17:12 <Forkk> I wrote this at like 3 am for a math competition
20:17:29 <Forkk> and it was my first real program in haskell
20:17:34 <nak> Forkk as new as i am, i can't really tell what's good and bad yet ^.^
20:18:04 <nak> lol forkk i love your avatar
20:18:07 <nak> i just followed u
20:18:18 <Forkk> :P
20:18:38 <Forkk> now you get to see all the projects I inevitably abandon
20:19:03 <nak> you won't see much different on my end lol
20:19:51 * r24y  NickServ VERIFY REGISTER r24y jpqzojtdjpfc
20:20:04 <bitemyapp> r24y: wrong command
20:20:09 <Forkk> and you failed
20:20:18 <r24y> yeah, failed hard :-/
20:20:20 <bitemyapp> r24y: you want to /query NickServ first.
20:20:29 * bitemyapp NickServ IDENTIFY hunter2
20:20:46 <bitemyapp> actually
20:20:47 <exio4> Forkk: what's so "hard" about that code? 
20:20:49 <bitemyapp> next person to join the channel
20:20:54 <bitemyapp> I'll do that and see if they think it was serious.
20:21:09 <Pastaf> You can just do /msg nickserv identify hunter2
20:21:19 <Forkk> good thing it stars out those passwords, though
20:21:20 * bitemyapp NickServ IDENTIFY hunter2
20:21:29 <Forkk> otherwise you'd all know my password is *******
20:21:42 <nak> r24y yeah you might want to update your password lol
20:21:48 <Forkk> exio4, it's a very complicated expression
20:22:01 <r24y> yeah... well that was a verification code but yeah
20:22:12 <nak> oh you're right
20:22:18 <exio4> Forkk: it isn't, without the type it looks more complicated than what it really is though 
20:22:19 <r24y> I think it accepted it
20:22:20 <backchat> hello
20:22:21 <Pastaf> Forkk: Then how am I supposed to say the word ********?
20:22:28 <Forkk> I've found some stupider ones now though
20:22:32 <Forkk> like `Debug.Trace.trace (show (DVector.length (verts DVector.! 0)) Prelude.++ " cube") $ return cube { verts = verts, conns = conns }`
20:22:43 <Forkk> I don't know what posessed me to write that
20:22:43 <backchat> quick question, from here http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass, at the section let numsTree = foldr treeInsert EmptyTree nums  
20:22:57 <Forkk> it's not really that hard to understand, it's just crazy
20:23:11 <backchat> doesn't treeInsert take parameters a and Tree a
20:23:57 <backchat> but when unfolding: foldr treeInsert EmptyTree nums, the function gets called with parameters treeInsert Tree a a
20:23:59 <exio4> Forkk: I am really asking what made the genConnsIter function `complicated`
20:24:05 <backchat> that is, the parameters are back to front?
20:24:21 <exio4> if you wrote down its type, it'd also be pretty "trivial" to identify what it is doing
20:24:41 <Forkk> actually now that I read it, it's not that hard
20:24:44 <exio4> (I infered it is operating on a vector, because V.xyz
20:24:47 <Forkk> and no it doesn't have a type signature
20:24:48 <itsMontoya> Anyone? Is there a haskell formatter?
20:25:01 <Forkk> I'm not sure what the iter part means
20:25:18 <Forkk> but the conns part probably refers to finding the connections between the points on the hypercube
20:25:35 <Forkk> there was a crazy optimized way of doing that with permutations of binary digits
20:25:47 <Forkk> this was over a year ago, though
20:26:33 <exio4> well, I didn't think it was used in such a complicated place ;P
20:26:59 <Forkk> what do you mean complicated place?
20:27:20 <exio4> that function itself has some type like (a -> a -> Bool) -> Vector a -> Int -> useless -> [(Int,Int)]
20:27:29 <exio4> Forkk: connections between the points on the hypercube
20:27:35 <Forkk> ah
20:27:59 <Forkk> yeah this code is supposed to make 2d projections of n-dimensional hypercubes
20:28:09 <Forkk> it probably still works; it's just really ugly
20:29:36 <Forkk> and I had a hard on for list comprehensions for some reason
20:29:44 <Forkk> even though I've never seen anyone else use them
20:32:31 <exio4> Forkk: yeah, high order functions are a little bit more, I guess having light lambda syntax does the trick :P
20:33:12 * pharaun is currently trying to smash together 2 monad stack (operational monad and pipes) and oh man
20:35:28 <exio4> uh, are a little bit more popular*
20:35:33 <Forkk> ah
20:39:52 <Forkk> oh my god
20:40:02 <Forkk> compiling the haskell opengl library is going to take days
20:40:13 <albeit_> Is there a way to convert an IO/ST mutable Array to a ByteString?
20:40:29 <Forkk> to a bytestring?
20:40:35 <Forkk> is it an array of bytes?
20:41:43 <eds> Is there a way to make two instances of the Data?
20:41:45 <eds> http://lpaste.net/132328
20:41:51 <albeit_> Forkk: Yes
20:41:55 <eds> following code gives me an error
20:42:04 <c_wraith> eds: an instance must be globally unique
20:42:14 <albeit_> I want to use a MArray as a "template", modify some values, then take back out the filled in template to send over a socket
20:42:19 <Forkk> albeit_, https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html
20:42:21 <Forkk> try pack
20:42:42 <Forkk> pack :: [Word8] -> ByteString
20:42:58 <eds> oh ok. So, I can only have one instance of the Data.
20:43:01 <c_wraith> albeit: you can use a Storable array, and then poke it
20:43:17 <albeit_> That seems inefficient... O(n), when the MArray, if its in contiguous memory, should just be able to copied out O(1)
20:44:03 <Forkk> I don't know if you can just copy it like that
20:44:07 <Forkk> bytestrings are immutable
20:44:22 <c_wraith> albeit: well, then.  If it's an unboxed array, you can dig up the underlying ByteArray#
20:44:31 <Forkk> you could do that
20:44:34 <c_wraith> albeit: but you can't guarantee it'll use the same bit format as C
20:44:41 <c_wraith> albeit: which is what the Storable instance gives you
20:44:48 <Forkk> you're going to have to get your hands dirty :P
20:45:36 <Forkk> c_wraith, why would an array of bytes be in a different format?
20:45:39 <albeit_> Okay... I'll look into Storeable and the ByteArray#
20:46:21 <eds> The follwing code on run time gives me an error. The error is at the bottom of the page. http://lpaste.net/134008
20:46:25 <c_wraith> Forkk: an array of Int on a 64-bit GHC is not going to be compatible with an array of int in C on the same machine
20:46:28 <itsMontoya> Is there an http server "Hello world" tutorial anyone knows of?
20:46:35 <itsMontoya> Or at least some docu/reference I can read?
20:46:41 <Forkk> c_wraith, he has a byte array
20:46:55 <Forkk> itsMontoya, depends on the http server
20:47:02 <Forkk> yesod has some nice tutorials
20:47:09 <Forkk> but it's not exactly lightweight
20:47:21 <sleblanc> itsMontoya, there are many ways to skin a cat but Yesod is probably the most popular: http://www.yesodweb.com/
20:48:05 <itsMontoya> I can look into yesod. I was hoping for a really bare bones implementation so I could understand the inner workings
20:48:09 <itsMontoya> Before diving into a framework
20:48:18 <Forkk> there's a lightweight one, but I forgot what it was called
20:48:26 <backchat> quick question, from here http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass, at the section let numsTree = foldr treeInsert EmptyTree nums  
20:48:29 <backchat> doesn't treeInsert take parameters a and Tree a
20:48:33 <itsMontoya> And there aren't any examples of how to do it with Stdlib?
20:48:38 <backchat> but when unfolding: foldr treeInsert EmptyTree nums, the function gets called with parameters treeInsert (Tree a) a
20:48:44 <backchat> which is back to front
20:49:02 <Forkk> itsMontoya, you want an HTTP server with the standard library?
20:49:04 <Forkk> wat
20:49:17 <itsMontoya> Forkk: The tools to build one, yes
20:49:31 <itsMontoya> Forkk: There isn't anything with tcp connections in stdlib?
20:49:34 <sleblanc> Forkk, Python comes with a reference HTTP server in the standard library, for instance
20:49:35 <Forkk> I mean, there are sockets
20:49:53 <Forkk> sleblanc, python's standard library is considerably larger than Haskell's, though
20:49:58 <sleblanc> That's right
20:50:18 <Forkk> itsMontoya, https://hackage.haskell.org/package/network
20:50:20 <itsMontoya> Forkk: https://hackage.haskell.org/package/network-simple-0.3.0/docs/Network-Simple-TCP.html#g:3
20:50:24 <itsMontoya> LOL, you beat me
20:50:32 <Forkk> :P
20:50:47 <itsMontoya> Forkk: YEs! This is what I wanted :)
20:50:51 <Forkk> that's a far cry from Yesod :P
20:50:57 <itsMontoya> Forkk: Low level stuff, just so I can understand the inner workings better
20:51:10 <Forkk> fair enough
20:51:10 <itsMontoya> This is perfect, thank you
20:51:16 <Forkk> no problem
20:51:25 <itsMontoya> I wasn't expecting a full blown HTTP server like Python or Golang
20:51:34 <itsMontoya> Though, Golang did spoil me a bit in that regard (chuckle)
20:51:52 <Forkk> Haskell does have HTTP servers
20:52:01 <Forkk> they're just not in the "standard library"
20:52:07 <itsMontoya> Right, I meant within the stdlib 
20:52:15 <Forkk> however, it should be noted that network is also technically not in the standard library
20:52:18 <itsMontoya> I could have been more concise in my statement
20:52:20 <Forkk> it isn't a part of base
20:52:23 <itsMontoya> Ahhh
20:52:28 <itsMontoya> Good to know, so I need to cabal install it?
20:52:34 <Forkk> Haskell's "standard library" is very small
20:52:41 <Forkk> it's probably already installed
20:52:46 <Hijiri> itsMontoya: I think network comes with GHC
20:52:55 <itsMontoya> Hijiri: Ahhh ok
20:53:00 <Forkk> yeah it's in the standard library in that sense
20:53:02 <Forkk> :P
20:53:08 <Forkk> It's just not a part of base
20:53:12 <itsMontoya> Ah got it
20:53:18 <itsMontoya> Understood
20:53:19 <Forkk> but then again, not much is in base
20:53:25 <Forkk> just data structures and stuff
20:53:27 <Forkk> and io
20:53:32 <itsMontoya> The bare essentials :)
20:53:46 <Forkk> all this https://hackage.haskell.org/package/base
20:53:47 <pharaun> well there's "haskell platform"
20:53:54 <pharaun> so i guess if you grab that its kinda there
20:54:04 <pharaun> but these days i usually run bare ghc and sandbox everything
20:54:25 <Forkk> I just use nix for everything
20:54:41 <pharaun> Forkk: as a replacement of sandboxes?
20:54:44 <Forkk> yeah
20:54:59 <Forkk> I don't have to compile things twice
20:55:06 <pharaun> i haven't installed it yet but i was eyeballing bare ghc + my common base libs (text/etc) that i don't update much, and sandbox for weird stuff
20:55:21 <Forkk> if I have one project that uses pandoc and another that uses pandoc, I don't have to wait 10 hours for pandoc to build twice
20:55:27 <Forkk> only 5 hours for it to build once
20:55:28 <pharaun> makes sense
20:56:09 <Forkk> also, nix manages ghc, so I can flip between ghc versions by changing my dev-shell script from "ghc7-8-4" to "ghc7-10-1"
20:56:40 <Forkk> no problems with multiple GHC versions or packages that don't work on newer GHC
20:56:57 <pharaun> Forkk: how do you do the swap?
20:57:01 <pharaun> that was one thing i was wondering
20:57:07 <pharaun> like is it just calling a shell script, boom?
20:57:49 <Forkk> you run `nix-shell` to get a shell environment with a set of packages installed
20:59:00 <Forkk> pharaun, I have this file https://github.com/quietspace/Backhand/blob/master/release.nix which defines how to build my code
20:59:10 <itsMontoya> Could not find module ‘System.Event’
20:59:21 <itsMontoya> I tried to cabal install System.Event, but maybe I'm doing it wrong
20:59:23 <Forkk> and if I run `release.nix -A build.ghc7-10-1.env`, it runs a shell with the ghc 7.10.1 environment
21:00:18 <Forkk> and I can also run `nix-build release.nix -A build` and it builds and tests my code with both ghc 7.10 and 7.8 at the same time
21:00:22 <Forkk> which is neat :P
21:01:49 <itsMontoya> I can't see anything about installing System.Event
21:02:41 <Forkk> itsMontoya, you need to install the package that has that module
21:02:50 <itsMontoya> cabal install System?
21:02:56 <Forkk> https://www.haskell.org/hoogle/?hoogle=System.Event
21:03:26 <Forkk> looks like it's been removed. All those links are dead
21:03:29 <pharaun> oh *right* nix-shell
21:03:35 <Forkk> yeah
21:03:39 <pharaun> does nix-shell reuse my shell config/etc ?
21:03:43 <pharaun> i use zsh and all fancy stuff
21:04:14 <Forkk> I'm sure it probably does
21:04:35 <Forkk> all it does is run a shell with a different nix profile
21:04:41 <pharaun> aha ok
21:04:48 <pharaun> makes more sense, i should sit down and read the docs more
21:04:49 <pharaun> thanks :)
21:05:05 <Forkk> unfortunately the nix docs are a bit lacking :(
21:05:11 <pharaun> i'll start using nix when i start the next project, i'm mid-coding and don't want to stop for yakshaving (kinda)
21:05:11 <Forkk> their IRC channel is helpful though
21:05:18 <pharaun> cool, good to know
21:05:19 <pharaun> freenode?
21:05:27 <Forkk> yeah, #nixos
21:05:36 <pharaun> k, thanks :)
21:05:53 <Forkk> no problem
21:05:54 <itsMontoya> "Simon Marlow states: The Haskell program as it stands won’t scale up on a multicore because it only has a single accept loop, and the subtasks are too small. "
21:06:07 <itsMontoya> So I guess right now, Haskell is capped around 14k requests per sec :(
21:07:09 <Forkk> wat
21:07:18 <Forkk> Haskell will definitely scale
21:07:27 <Forkk> I have no clue what you're talking about
21:07:52 <pharaun> itsMontoya: where that statement from and in what context?
21:08:07 <pharaun> itsMontoya: look at warp and mighttp (sp)
21:08:09 <itsMontoya> https://wiki.haskell.org/Simple_Servers
21:08:14 <itsMontoya> 5. Notes 
21:08:21 <itsMontoya> Maybe the wiki page is old
21:08:28 <itsMontoya> But it was referring to the event loop being single threaded
21:08:52 <Forkk> this is probably old
21:09:12 <itsMontoya> Looks like June 2011 modification date
21:09:19 <Forkk> very old
21:09:24 <itsMontoya> Some other Event docu I read the same thing about the single loop
21:09:27 <Forkk> that ticket they linked is 5 years old
21:10:00 <pharaun> very old
21:10:01 <itsMontoya> It seems like Warp is faster than Yasod. But not but a huge amount
21:10:01 <Forkk> at the top it even says "This page is a little out of date"
21:10:05 <pharaun> itsMontoya: read up on MIO
21:10:14 <itsMontoya> pharaun: Will do!
21:10:16 <Forkk> yesod runs on warp IIRC
21:10:19 <pharaun> http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
21:10:25 <pharaun> multi-core io manager
21:10:47 <pharaun> got it up to i think 12-20(?) cores before it started having trouble but that's already a nice improvement over the previous generation
21:11:08 <itsMontoya> "We also show that with Mio, McNettle (an SDN controller written in Haskell) can scale effectively to 40+ cores, reach a thoroughput of over 20 million new requests per second on a single machine, and hence become the fastest of all existing SDN controllers."
21:11:11 <itsMontoya> LOL
21:11:20 <itsMontoya> WOW
21:11:20 <Forkk> LOL
21:11:25 <Forkk> 14k my ass
21:11:33 <itsMontoya> A lot has changed in 4 years apparently.
21:11:34 <pharaun> tho SDN i think is on the light side processing wise compared to http
21:11:40 <pharaun> i think
21:11:46 <itsMontoya> pharaun: Totally, especially TCP
21:11:48 <itsMontoya> But still
21:11:56 <pharaun> sure
21:12:00 <itsMontoya> I'm hoping to hit 1mil rps
21:12:02 <Forkk> Haskell is by no means slow :P
21:12:05 <pharaun> anyway java is still whooping our arse performance wise
21:12:11 <pharaun> for http stuff (esp the pong benchmarks/etc)
21:12:17 <itsMontoya> Ew.. Java
21:12:22 <pharaun> but warp/etc is still pretty competitive
21:12:26 <pharaun> and getting better :)
21:12:38 <pharaun> and hey its faster than RoR :P
21:12:46 <itsMontoya> I mean, my current service is built in Golang
21:12:55 <itsMontoya> And pwns Java versions
21:13:04 <pharaun> i forget how golang stacks up i think they're roughly the same (in the pong) or a bit slower/faster
21:13:10 <pharaun> but its benchmarks eh
21:13:11 <pharaun> *shrugs*
21:13:26 <itsMontoya> Yea for sure, I know in real world I get sub 1ms responses
21:13:31 <itsMontoya> But I have all my data in memory
21:13:33 <xj54y> Is there much of a difference between Num b => [b] -> b and Num a => [a] -> a ?
21:13:53 <Forkk> pharaun, a hamster wheel wired to a lightbulb is a faster HTTP server than rails
21:14:12 <itsMontoya> Forkk: So true
21:14:16 <dramforever> xj54y: no, except when a/b is used elsewhere
21:14:21 <itsMontoya> I know in my industry, Erlang is used a ton
21:14:29 <itsMontoya> Due to it's ability to handle tons of concurrent connections
21:14:37 <Forkk> Erlang needs monads D:
21:14:41 <Forkk> badly
21:14:46 <itsMontoya> Erlang needs to not be so damn ugly
21:14:47 <itsMontoya> (chuckle)
21:14:58 <Forkk> Cowboy is a pain in the ass in Erlang
21:15:04 <pacak> Nothing stops you from  implementing monads in any language...
21:15:10 <Forkk> and all it needs to fix it is a state monad
21:15:19 <pharaun> Forkk: :)
21:15:34 <xj54y> dramforever, ah okay.. Just seems to change every now and then and I'm familiar with the constitutional changes.. Perhaps it wouldn't matter if it were Num zebra => [zebra] -> zebra, yeah?
21:15:36 <Forkk> pacak, not possible in this case
21:15:44 <Forkk> otherwise it would have been done
21:15:46 <dramforever> xj54y: yep
21:15:49 <pharaun> tho on erlang, there's elixer
21:15:55 <Forkk> yeah
21:16:02 <pharaun> but i have no idea what to think cos i haven't tried either
21:16:12 <dramforever> xj54y: but people will feel funny seeing that in "real" code
21:16:12 <pharaun> mostly read papers and stuff on erlang and tried to implement my own sol in haskell hah
21:16:16 <Forkk> Erlang is also a pain in the ass to deploy
21:16:20 <itsMontoya> pharaun: Elixir looks interesting. I just don't like dynamic typed
21:16:21 <pharaun> i heard
21:16:28 <Forkk> pharaun, look at cloud haskell
21:16:35 <pharaun> Forkk: yah a friend was looking into it
21:16:41 <itsMontoya> I'm trying to find out how to use Mio
21:16:42 <pharaun> i haven't reached that kind of scale yet to need it
21:16:47 <Forkk> also, yeah, erlang's types system (or lack thereof) sucks
21:16:47 <pharaun> itsMontoya: its built in
21:16:53 <pharaun> to ghc as of 7.6 or 7.8
21:16:56 <Forkk> I much prefer my program to not crash at all
21:17:02 <Forkk> which is what happens in haskell
21:17:10 <itsMontoya> pharaun: Is there any code examples on line to get me started? I'm still stuck on this 2011 docu on the Haskell wiki
21:17:15 <pharaun> heh, unsafe heads + undefined :P
21:17:17 <itsMontoya> Just trying to create a simple pong http service
21:17:21 <pharaun> itsMontoya: oh
21:17:23 <itsMontoya> Are there**
21:17:31 <Forkk> pharaun, honestly my problem with cloud haskell is that it creates a _ton_ of boilerplate
21:17:36 <pharaun> um, mighty has lots of info on performance stuff, but hm
21:17:50 <pharaun> itsMontoya: honestly i would just grab either happstack/snap/warp and dig into the docs
21:17:56 <pharaun> i use scotty myself which is on top of warp
21:18:05 <pharaun> Forkk: oh?
21:18:11 <pharaun> boilerplate, uhoh
21:18:18 <Forkk> Half my code was dedicated to telling it what to do when a process crashed
21:18:28 <dramforever> Hmm...I just ran into a strange parse error
21:18:38 <dramforever> I know the cause, but the error message is strange
21:18:47 <lpaste> dramforever pasted “Strange parse error” at http://lpaste.net/134014
21:19:24 <Forkk> what is the error message?
21:19:29 <dramforever> ghc says the if is missing an else clause
21:20:03 <Forkk> makes sense
21:20:06 <itsMontoya> pharaun: Ahh ok.. I'll take a look. I usually like to take the hard way just so I learn the core of how things work
21:20:07 <Forkk> you didn't indent it
21:20:22 <dramforever> Forkk: no it's not the problem
21:20:49 <Forkk> ?
21:20:54 <pharaun> itsMontoya: ahh
21:20:57 <dramforever> Forkk: \case ->
21:21:05 <dramforever> the -> shouldn't have been there
21:21:05 <Forkk> ah
21:21:10 <Forkk> lol
21:21:14 <pharaun> itsMontoya: well i would do a simple example in scotty get something work, then iterate from there and maybe implement your own simple server
21:21:19 <Forkk> that is a weird error then
21:21:21 <dramforever> unrelated: y is not in scope
21:21:21 <itsMontoya> pharaun: I figure if I understand the nuts and bolts of something. I can make better programming decisions. Even if I end up going with a framework
21:21:25 <pharaun> you could also look at the dependency list of like snap
21:21:29 <pharaun> er sorry, scotty
21:21:34 <pharaun> and grab stuff like http parsers, etc
21:21:39 <pharaun> then wire stuff up
21:21:40 <dramforever> Forkk: Maybe I'll go to report a bug?
21:21:49 <itsMontoya> pharaun: Good idea, I'll look into it
21:21:51 <pharaun> Forkk: ahh (re cloud)
21:21:53 <dramforever> because it's "particularly unhelpful"
21:21:57 <Forkk> dramforever, it's not really a bug
21:22:04 <Forkk> I mean I guess
21:22:15 <dramforever> it's not a bug, it's a problem
21:22:17 <pharaun> itsMontoya: its one approach i usually do, look at an example then look at its dep and see how the example is put together then do it myself
21:22:19 <Forkk> Parse errors are difficult
21:22:21 <dramforever> dunno if worth fixing
21:22:32 <Forkk> it's hard to tell what's wrong when parsing something weird
21:23:31 <itsMontoya> pharaun: Totally, that's a great idea. Figuring out how to get Warp working right now
21:23:51 <pharaun> gl!
21:24:02 <Forkk> I need to go and read code more
21:24:11 <Forkk> like just sit down and read an entire library
21:24:13 <dramforever> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/wrong.html
21:24:16 <pharaun> Forkk: cloud?
21:24:21 <pharaun> yeah my friend said its mind-blowing
21:24:27 <dramforever> “This is a terrible error message.” -> If you think that GHC could have produced a better error message, please report it as a bug.
21:24:29 <pharaun> haven't had time to look at it yet :)
21:24:35 <itsMontoya> Wow 15 LOC, not bad
21:24:38 <Forkk> pharaun, what is, reading code?
21:24:41 <dramforever> well, dunno if GHC could...
21:24:48 * hackagebot bytestring-lexing 0.5.0.2 - Parse and produce literals efficiently from strict or lazy bytestrings.  http://hackage.haskell.org/package/bytestring-lexing-0.5.0.2 (WrenThornton)
21:24:50 <pharaun> Forkk: cloud haskell :P
21:24:55 <Forkk> oh
21:25:00 <Forkk> it's not exactly mind blowing
21:25:06 <Forkk> just a pain in the ass
21:25:11 <Forkk> and lacking documentation
21:25:12 <pharaun> haha he was reading the source :P
21:25:16 <Forkk> oh
21:25:16 <dramforever> anyway, I'll go report
21:25:18 <Forkk> lol
21:25:20 <pharaun> *shrugs* but yeah i haven't looked into it much yet
21:25:21 <pharaun> so idk :)
21:25:27 <Forkk> I might read auto's source lol
21:25:34 <pharaun> mostly playing with coroutines/etc atm
21:25:36 <Forkk> I'd like to know how that works
21:25:42 <pharaun> and hurting my head (mostly getting the types to line up)
21:25:49 <Forkk> heh
21:25:50 <pharaun> i think i finally got operational and pipes to finally line up
21:26:09 <pharaun> trying to merge the two so that i can run an interpreter inside a pipe and await/yield up stuff when i have results+need input
21:26:11 <Forkk> I think most of my time coding is spent fixing type errors
21:26:16 <Forkk> better than debugging though
21:26:19 <pharaun> indeed
21:26:24 <Forkk> I very rarely have to debug in haskell
21:26:27 <Forkk> which is awesome
21:26:28 <pharaun> soemtime i take a whole weekend fitting parts together
21:26:36 <pharaun> but once its together its usually.. oh whoa
21:26:44 <pharaun> then i read some paper to understand what i just did, and haha
21:26:47 <Forkk> I've rewritten entire massive portions of my code base without a single runtime error
21:26:53 <pharaun> love that
21:26:56 <pharaun> i'm not as good at that
21:27:01 <pharaun> cos i have a bad habit of using unsafe heads
21:27:04 <Forkk> I fucking love it when my code compiles
21:27:06 <pharaun> been working on stopping my habit of that
21:27:07 <Forkk> and then I run it
21:27:10 <Forkk> and it just works
21:27:23 <Forkk> it's amazing, like "holy shit, you're not going to crash even once?"
21:27:58 <Forkk> ported my entire codebase from reactive-banana to netwire and it worked perfectly the moment it compiled
21:28:46 <Forkk> pharaun, just don't use head? :P
21:29:13 <xj54y> what's wrong with fn a b = (\a b -> (b / (a ^ 2)) ++ "") a b ?
21:29:27 <dramforever> Forkk: that's what "if it compiles, it works" mean
21:29:37 <Forkk> xj54y, aside from it being an insane expression?
21:29:42 <pharaun> Forkk: hah, yeah weaning myself of that habit ;p
21:29:48 <dramforever> I think it should be "if it compiles, you haven't been too wrong"
21:29:49 <xj54y> Forkk, yes
21:30:29 <Forkk> you're shadowing the first a and b variables inside the lambda
21:30:44 <Forkk> which is usually just a warning
21:31:34 <Forkk> pharaun, you just have to make sure you consider every case
21:31:41 <xj54y> Forkk, what else?
21:31:59 <Forkk> hang on
21:32:27 <itsMontoya> Do I have to build it a certain way to make it multi threaded?
21:32:30 <itsMontoya> Or is that by default?
21:32:45 <Forkk> xj54y, well for one, you'e using / and ++ on things of the same type
21:32:58 <Forkk> you're implying that a and b are numerical values
21:33:05 <Forkk> but then you try to append a string to them
21:33:26 <Forkk> ghc sees the `++ ""` and thinks that a and b are strings
21:33:38 <Forkk> but then it sees you trying to do math with them
21:33:52 <Forkk> and there isn't a `Fractional` instance for strings
21:33:54 <Forkk> so it fails
21:33:58 <ReinH> xj54y: many things. many things are wrong.
21:34:10 <xj54y> ReinH, yes, quite aware of this fact.
21:34:16 <Forkk> thus "No instance for (Fractional [Char]) arising from a use of ‘/’"
21:34:25 <dramforever> there you go https://ghc.haskell.org/trac/ghc/ticket/10498
21:34:50 <pharaun>  itsMontoya -threaded
21:35:10 <itsMontoya> Thanks!
21:35:16 <Forkk> xj54y, out of curiosity, where did this code come from
21:36:36 <itsMontoya> Weird, I get an error just with the threaded flag
21:36:40 <itsMontoya> <no location info>:
21:36:40 <itsMontoya>     module ‘main:Main’ is defined in multiple files: hello.hs hello.hs
21:36:48 <Forkk> wtf
21:36:51 <xj54y> Forkk, my notepad.. Going through all the weird stuff and trying to figure out what I meant (in this case, converting an int to a string, which didn't work the way described.. So I wrote reasons why it didn't work. Didn't ask anyone else until now)
21:37:07 <Forkk> ah
21:37:18 <Forkk> yeah there are no implicit conversions here
21:37:24 <Forkk> the function you want is `show`
21:37:25 <Forkk> :t show
21:37:27 <lambdabot> Show a => a -> String
21:45:15 <xj54y> Forkk, ah.. how would you fix that?
21:46:16 <itsMontoya> Got it working
21:46:20 <itsMontoya> But I think it's still using 1 proc
21:46:56 <itsMontoya> Make: ghc -O2 -threaded --make hello.hs Run: ./hello +RTS -N4
21:48:38 <Forkk> xj54y, what exactly are you trying to do?
21:48:52 <Forkk> if you have a number and you want a string, you just apply show to it
21:48:55 <Forkk> > show 5
21:48:58 <lambdabot>  "5"
21:53:03 <xj54y> Forkk, that's kind of what did.. (show(fn)), but wasn't sure if it could be expressed intrinsically
21:54:28 <ReinH> no, there are no implicit type casts or coercions
21:55:42 <pharaun> itsMontoya: well it won't use it for free i don't think, you need to fork things, use parallel, etc etc
21:55:51 <pharaun> its not going to auto-concurrency things usually
21:55:55 <itsMontoya> Ahh ok
21:56:04 <pharaun> but when you have concurrency going, the event loop isn't going to be the blocker
21:56:13 <pharaun> which is basically what mio brings to the table
21:56:46 <itsMontoya> pharaun: https://gist.github.com/itsmontoya/774b80efc3202e68a645 This is what I'm working with
21:57:54 <pharaun> ahh
21:58:03 <ReinH> mio basically replaces the IO subsystem's lock with a spinlock
22:00:57 <itsMontoya> I'm going to read through this: http://langnostic.blogspot.com/2013/02/wai-without-yesod-simple-example-of_10.html
22:01:34 <copycat> how can i fix "could not find module foo" problems?
22:01:44 <copycat> i've used cabal install foo
22:01:56 <copycat> and put the foo into my .cabal config file
22:02:02 <copycat> it still gives me this error
22:02:10 <copycat> and i can't find a solution on google, can someone help me?
22:03:04 <DrPavelheer> copycat: How are you doing the import?
22:03:24 <copycat> what do you mean by that?
22:03:30 <copycat> in the .hs file?
22:03:38 <copycat> import           Text.Markdown
22:05:53 <itsMontoya> Ehh.. Maybe I should start off with Scotty
22:06:46 <xj54y> ReinH, haha, almost verbatim what I wrote down
22:07:45 <ReinH> copycat: foo isn't the name of a module though
22:07:51 <copycat> oh i mean
22:08:00 <copycat> i get this error with a couple of modules
22:08:22 <rcyr> @hoogle [Char] -> (Char -> Bool) -> ([Char], [Char])
22:08:24 <ReinH> I mention this because you used "foo" for both the package name and the module name
22:08:25 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
22:08:26 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
22:08:26 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
22:08:43 <ReinH> :t partition
22:08:44 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
22:08:47 <copycat> is there a difference?
22:08:50 <copycat> between package and module
22:08:52 <ReinH> copycat: yes
22:09:35 <copycat> ahh
22:10:00 <dramforever> http://hackage.haskell.org/package/<package-name-here>
22:10:04 <copycat> i dont know where i mentioned a package
22:10:08 <dramforever> go read the module list below
22:10:11 <copycat> but i want to fix those module errors
22:10:30 <copycat> i've seen the package list
22:10:30 <dramforever> copycat: can you give an example for us to work with?
22:10:39 <copycat>     Could not find module ‘Text.Markdown’
22:10:45 <xj54y> Forkk, what is meant by "shadowing" ?
22:10:47 <copycat> All the requested packages are already installed:
22:10:47 <copycat> markdown-0.1.13.2
22:10:59 <copycat> when i try to do cabal install markdown
22:11:54 <Forkk> xj54y, if you define a variable with the same name as another variable, the new variable "shadows" the old one
22:11:58 <Forkk> this mostly happens with functions
22:12:18 <Forkk> for example, if you name one of your variables "id", you won't be able to use the id function
22:13:25 <dramforever> copycat: that's weird, try cabal list --installed | grep markdown
22:13:48 <dramforever> wait that shouldn't matter...
22:14:08 <dramforever> weird...dunno why
22:14:18 <copycat> uhmm
22:14:23 <copycat> * markdown
22:14:23 <copycat>     Homepage: https://github.com/snoyberg/markdown
22:14:26 <copycat> it gives me this message
22:14:31 <copycat> i suppose that means everything is dandy?
22:14:45 <dramforever> copycat: then cabal thinks it's installed
22:15:30 <xj54y> Forkk, ah, so for example fn a b = show((\a b -> b / a ^ 2) a b) should be fn x y = show((\a b -> b / a ^2) x y) ?
22:15:55 <Forkk> I suppose
22:16:06 <DrPavelheer> check your cabal files
22:19:25 <copycat> im very new to cabal and haskell
22:19:34 <DrPavelheer> Hmm
22:19:38 <copycat> could you elaborate a little on what checking my cabal files means?
22:19:40 <DrPavelheer> Yup
22:19:58 <DrPavelheer> Cabal keeps all its packages in .appdata
22:20:03 <DrPavelheer> hmm
22:20:05 <DrPavelheer> this is on windows
22:20:13 <copycat> im using os x
22:21:03 <lamefun> Is there a data type for non-duplicated ordered list-map (ie. something like data MapList a b = MapList [(a, b)], but with fast lookup by a and no duplicate a elements)?
22:22:03 <DrPavelheer> Hmm
22:22:08 <DrPavelheer> Check ~/.cabal/
22:22:11 <DrPavelheer> If it's there
22:22:44 <dramforever> lamefun: is Data.Map okay?
22:23:01 <copycat> ah yeah
22:23:07 <copycat> which file in ~/.cabal/ to check?
22:23:10 <DrPavelheer> hmm
22:23:12 <dramforever> it needs Ord a, because it's based on a balanced BST
22:23:29 <DrPavelheer> the ghc folder
22:23:37 <DrPavelheer> OSX-ghc or something like that
22:24:45 <copycat> there's no ghc folder in ~/.cabal/
22:24:48 <DrPavelheer> hmm
22:24:55 <lamefun> dramforever, does it keep insertion order?
22:25:05 <copycat> i downloaded according to yesod's quickstart guide
22:26:14 <DrPavelheer> Is there a packages folder?
22:26:19 <DrPavelheer> Cabal works differently on a mac
22:26:54 <copycat> yeap, packages
22:26:57 <DrPavelheer> hmm
22:27:02 <DrPavelheer> it's probably not that actually
22:27:08 <DrPavelheer> do you have a picture of the folder?
22:27:18 <DrPavelheer> cabal should keep a folder for the compiler
22:27:29 <copycat> should i just nuke my install?
22:27:35 <DrPavelheer> nope
22:27:47 <DrPavelheer> i'm sure there's nothing wrong with the install
22:28:02 <copycat> i can find markdown in the packages folder
22:28:07 <DrPavelheer> yup
22:28:18 <DrPavelheer> packages is actually the list of packages on hackage
22:28:30 <DrPavelheer> not exactly what you want, i think
22:29:48 <copycat> ahh..
22:29:58 <copycat> i can't find any google links to help me out
22:30:13 <copycat> all the module cannot be found issues are for specific packages
22:32:31 <DrPavelheer> right
22:32:43 <DrPavelheer> we do want the list of packages installed on your computer, though
22:32:53 <DrPavelheer> no folders in cabal have ghc in the name?
22:33:07 <copycat> nope
22:35:18 <DrPavelheer> i got nothing
22:35:30 <DrPavelheer> i'm sure someone in here knows what's up
22:35:39 <ronh-> lamefun no, it is sorted (it is a balanced binary tree)
22:35:50 <DrPavelheer> Anyone know where your packages are kept on a Mac?
22:46:30 <ocramz> morning all
22:47:35 <ocramz> anyone with inline-c experience here?
22:50:56 <copycat> drpavelheer: thanks for helping me :)
22:58:40 <pingu> ocramz: I did a really short workshop on it once.
22:58:55 <pingu> What are you trying to do?
22:59:01 <shutdown_-h_now> 3/win10
23:01:14 <ocramz> pingu: hi :) how do I link the compiled modules so that I can use them within ghci?
23:02:03 <ocramz> ghci Main.hs Module.o  \or\   ghci Main.hs -Lsrc/ ?
23:02:35 <ocramz> sorry, I mean both Main.hs , Module.hs and all compilation results are in a subfolder src/
23:03:25 <ocramz> pingu: also, I might have a more proper inline-c variable visibility question, for later ;) 
23:08:37 <Arahael> So...  I thought I'd start learning Category Theory so that I could be more familiar with the lingo, and wow, it seems directly applicable to programming langauges. (At least, as far as types are concerned)
23:08:39 <pingu> ocramz: No idea about that one. It's unchartered territory I guess, using the inline c stuff with ghci.
23:08:56 <pingu> ocramz: does it just work? I'd expect it might, or at least you'll see why it doesn't.
23:09:26 <pingu> Arahael: it is. It's directly applicable to just about anything.
23:09:29 <ocramz> I just get an import error: https://stackoverflow.com/questions/30690576/importing-inline-c-modules
23:10:11 <Arahael> However, I'm a bit confused about the excerise given in http://en.wikibooks.org/wiki/Haskell/Category_theory - The second excercise (harder) in the 'introduction to categories' section is very confusing to me.  Specifically, I know that there can be many morphisms, so you could go from A -> B in many ways (at least, as many ways as are defined for that system)
23:10:27 <Arahael> Yet merely _adding_ a morphism somehow stops the category from being a category?
23:11:10 <Arahael> pingu: I've briefly wondered if categories could be used as an abstraction of numbers, but lets not let me get ahead of myself - borrowed a few books and reading that site as well, for now. :)
23:11:47 <pingu> Arahael: can you be more specific about the exercise you mean?
23:11:53 <pingu> there's quite a few there.
23:11:56 <Arahael> pingu: Specifically, to quote the excercise: "(Harder.) If we add another morphism to the above example, it fails to be a category. Why? Hint: think about associativity of the composition operation."
23:11:56 <pingu> ocramz: taking a look.
23:12:21 <MarcelineVQ> Post the example :D
23:12:49 <pingu> Arahael: so you're okay with how a partial order can be a category?
23:13:26 <pingu> and you're okay with the first exercise?
23:14:15 <Arahael> pingu: I'm still very new to the lingo and notation; so not sure exactly what you mean by 'partial order' there.  However, I'm looking at it and seeing that g goes from A to B, and f goes from B to A, so composing g and f (in either direction) will give us the respective identity morphism.
23:14:48 <pingu> sure. and you understand that the identity morphism doesn't "depend" on having g and f be equivalent to it?
23:15:06 <Arahael> Sure, they just happen to be the same, for all practical purposes.
23:15:11 <pingu> (the composition of g and f being equivalent to ID on A)
23:15:17 <pingu> yep. okay.
23:15:28 <pingu> It is confusing how it mentions adding another morphism to the above example.
23:15:32 <pingu> Does it mean the below example?
23:15:33 <Arahael> pingu: Thus, however you look at the A, B, f, and the two id morphisms, you have a category.  Adding another morphism to me would allow me to effectively substitute h for f there, though I suppose that could make it a different category?
23:16:40 <Arahael> pingu: My interpretation was that the diagram below the text was the resulting example. (Ie, they've already added the morphism for you - which is 'h')
23:16:57 <Arahael> pingu: My task, is to explain why it is not a category.
23:16:58 <MarcelineVQ> this little diagram on this category page looks a bit like a markov diagram :o
23:17:15 <Arahael> MarcelineVQ: *all* of the diagrams in category theory do!
23:17:17 <pingu> Arahael: an important thing to note is that just because composing a -> b, and b -> a gets you back to *an* a.
23:17:20 <MarcelineVQ> :>
23:17:23 <pingu> doesn't mean that it's the same as ID on a.
23:17:36 <Arahael> pingu: True, I get that the range of inputs and outputs can differ.
23:17:38 <shachaf> What is "an a"?
23:17:38 <pingu> but I agree, that is a confusing question and I'dj ust leave it personally.
23:17:58 <pingu> shachaf: if you're thinking about this as functions.
23:18:01 <pingu> which is not the best of ideas.
23:18:19 <shachaf> OK. I agree.
23:18:29 <Arahael> pingu: Good, I'll just leave it then, and move on.  I've borrowed some ancient books on the library on category theory, which look quite good (but they don't apply it to anything)
23:18:32 <shachaf> I think it's a pretty strange exercise.
23:19:00 <shachaf> And I'm not sure that wikibook is the best introduction to category theory to be reading.
23:19:14 <shachaf> But as long as you're reading it you can probably figure the exercise out.
23:19:28 <pingu> Agreed, you probably want to learn category theory independently, then see how it may apply to haskell by reading such things.
23:19:33 <Arahael> pingu: My interpretation of this excercise, actually, was that the only possible reason how the hint could apply would be if you had composed f, g, _and_ h in the same analysis, which would indeed not be assosiative.
23:19:42 <nak> anyone have feedback on cis194 yorgey's 2015 vs 2013 ?
23:19:59 <nak> oh wups
23:20:02 <MarcelineVQ> if you guys have good beginner books on cat. theory to be reading be sure to link them
23:20:02 <nak> 2015 isn't yorgey
23:20:24 <ocramz> pingu: I realize I asked you not the most exciting of questions :) but I don't see why it shouldn't work; we just want to link some .o files in an interactive session..
23:20:42 <shachaf> There are a couple of things to think about. For one, those category diagrams that they draw don't have all the information about the category. They don't show the composition operation, which is the most important part.
23:20:43 <Arahael> pingu: That's what i'm planning on doing, I've borrowed "An introduction to category theory" by  V.Sankrithi Krishnan, which will be interesting (and surprisingly readable, though I keep tripping on the names and words they use, as it's dense, even for a maths book)
23:21:08 <ocramz> Arahael: I found it easier to work up from specific cases; ask yourself how do data structures or geometrical objects compose
23:21:11 <shachaf> So what this exercise means is, no matter which definition of composition you choose, it's not going to satisfy the laws.
23:21:40 <ocramz> Arahael: how do you append two trees? how do you transform the values contained therein with the same function?
23:21:45 <Arahael> shachaf: Sure, they will satisfy them. compose f and g, or g and h.
23:21:54 <shachaf> ?
23:22:33 <Arahael> shachaf: Infact, f * g = h * g, in that example. (though obviously, the ranges differ)
23:22:55 <shachaf> "range" meaning codomain?
23:23:11 <pingu> ocramz: yeah, not sure from just reading.
23:23:16 <pingu> I'll give it a go
23:23:20 <shachaf> Oh, that's the word they use, apparently. Confusing.
23:23:28 <shachaf> But anyway I'm not sure what you're saying.
23:24:13 <Arahael> ocramz: Do you refer to imperative responses, eg, "you add two trees by looping over each element of one tree and inserting it to the other", in which case that's fairly easy.
23:24:30 <Arahael> ocramz: Or conceptual?  It's the conceptual/abstract level I want to gain insight into.
23:25:02 <Arahael> shachaf: Wording varies everywhere.
23:26:02 <ocramz> shachaf: "range" is used as "codomain" in analysis as well
23:26:49 <shachaf> Sometimes people say "range" and mean "image". Sometimes they mean "codomain". Set theory folks sometimes don't distinguish between the two, because of the way they define functions.
23:26:52 <Arahael> shachaf: What I meant where f * g = h * g, is that if you were to define a function: ff = f . g; and another function hh = h * g; then they will have the type, of input and output.
23:27:12 <shachaf> But "image" and "codomain" are both clear and unambiguous, so there's no excuse to say "range".
23:27:12 <Arahael> shachaf: Set theory, iirc, is older than category theory.
23:27:21 <Arahael> Ah, fair enough.
23:27:33 <shachaf> f,g,h aren't functions.
23:27:44 <pingu> Arahael: there's another good reason to use codomain
23:27:45 <ocramz> Arahael: why do vectors sum but points don't? what does it mean to "invert" a mapping?
23:27:58 <Arahael> shachaf: They might as well be, on that site, in what it calls the "Hask" category.
23:28:02 <pingu> and that is when you look at co-categories (ones where you go and flip all the arrows around)
23:28:07 <shachaf> I thought you were talking about the exercise.
23:28:09 <pingu> your domains become the co-domains
23:28:13 <pingu> hence co-domain
23:28:27 <Arahael> pingu: I wondered what the 'co' stem meant.
23:28:34 <shachaf> Anyway, Set/Hask isn't a good category to base all your intuition on.
23:28:48 <pingu> Yeah, I found that Set/Hask confused me more than helped.
23:29:03 <Arahael> In that case, I'll ignore that site.
23:29:08 <pingu> (at first)
23:29:13 <pingu> It's valuable once you understand a bit more.
23:30:27 <Arahael> ocramz: Points do sum, but they don't have a conventionally defined way in which that would be done.  You can't say "add this point to that point", because there isn't a generic concept that everyone agrees on, you'd have to translate them to a space that allows you to sum them.
23:30:52 <Arahael> ocramz: Eg, the vector space, or the complex space, and I'm sure there's many, many others. (I think you may have been leading me to this?)
23:31:28 <ocramz> Arahael: exactly, I find geometric intuition to be most helpful; I am not a mathematician by training
23:32:00 <Arahael> ocramz: I also find geometric intuition extremely valuable - especially when I did calculus.
23:32:44 <ocramz> Arahael: what else did you study? so we can agree on a shared notation :)
23:33:13 <Arahael> ocramz: I don't think that not being a mathematician means that you're more inclined to think in terms of geometry - the geometry you think of as a mathematician, however, might not be one that uses physical laws. ;)
23:34:19 <Arahael> ocramz: I only did 4u mathematics, which I did extremely well at. I then went to uni, where I studied a bit of maths, but focused much more on engineering with a focus on software engineering.
23:34:34 <Arahael> ocramz: Don't confuse that with mathematics / computer science.
23:35:40 <Arahael> ocramz: 4u maths is the highest level of maths you can study while in highschool.  In american terms, I think uni is more equivalent to "college"?
23:35:59 * Arahael is in Australia.
23:36:12 <pingu> #haskell.au exists, by the way
23:36:41 <Arahael> pingu: I'm aware.  Not actually sure why I keep coming here instead.
23:37:03 <shachaf> I ask myself the same question.
23:37:05 <ocramz> Arahael: I'm in the EU, studied here as well. Uni is fine :) I don't think our American friends are even awake at this time :)
23:37:11 <pingu> Arahael: so I was considering starting a little group to go through category theory things.
23:37:21 <backchat> from http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass (search for "instance Functor (Either a) where" no quotes), can someone explain to me where x has come from, and why we don't use a at all?
23:37:22 <pingu> Arahael: would you be interesting in such a thing in Sydney?
23:37:30 <Isaacary> Hey guys 
23:38:06 <Arahael> pingu: I would be...  Though right now I lack time and confidence - irc is much easier for me than to meet people in person. (I'm stone deaf)
23:38:33 <Arahael> ocramz: Cool. :)
23:38:53 <pingu> That makes the benefit of face-to-face communication less, then, I suppose.
23:39:05 <pingu> But category theory is a very white-boardey thing. Can help a lot.
23:39:08 <MarcelineVQ> backchat: a is a type variable, and x is a data variable, I think
23:39:13 <Axman6> Isaacary: G'day
23:39:18 <Isaacary> kinda a newbie at programming here ive just started java ive done some python id have to say java is so much better
23:39:33 <Arahael> MarcelineVQ: But only by convention, there.
23:39:33 <Isaacary> Axman6: gday
23:39:43 <Axman6> Isaacary: your standards are very low :P
23:39:47 <MarcelineVQ> Arahael: yes, the actual label is artibrary
23:39:48 <Arahael> pingu: Somewhat.
23:39:59 <MP2E> hehe
23:40:02 <Isaacary> Axman6: why so ??? i dunno i just enjoy it more
23:40:11 <MarcelineVQ> It's different to show that they're not the same thing, afaik
23:40:11 <pingu> ocramz: so I'm a little confused
23:40:17 <Walther> each to their own :)
23:40:19 <pingu> your example imports Language.C.Inline.
23:40:26 <pingu> but I'm pretty sure there's only support for objective c
23:40:31 <pingu> so Language.C.Inline.ObjC
23:40:57 <backchat> MacelineVQ: I don't quite see what the writer is really trying to get at defining Either as a functor. It seems a bit hacky if anything. Am I right in understanding that we can apply a function on the Right, but we can't do anything on the left?
23:41:05 <Axman6> Isaacary: it's just not a very interesting language. lots of libraries, just not much to have fun with
23:41:07 <backchat> MarcelineVQ: I don't quite see what the writer is really trying to get at defining Either as a functor. It seems a bit hacky if anything. Am I right in understanding that we can apply a function on the Right, but we can't do anything on the left?
23:41:28 <Axman6> Isaacary: I'm surious why you chose #haskell share this knowledge with
23:41:44 <Arahael> Isaacary: I suggest you define _why_ you feel that Java is so much better, it could give you insight into your learning.  Java is much more static than Python.
23:42:02 <MarcelineVQ> backchat: I don't know, I'm as new as you :>
23:42:20 <ocramz> pingu: well, the Test1 module works by itself. Oh, are there perhaps two different versions of inline-c? As in, I installed mine the other day after the FPComplete blog post
23:42:35 <ocramz> pingu: but from hackage, not their github
23:42:51 <pingu> I'm looking at 7.9.1 now:
23:42:58 <pingu> https://hackage.haskell.org/package/language-c-inline-0.7.9.1
23:43:24 <Isaacary> Arahael: it seems more interesting. i haven't done heaps with java yet but i fell i understand it more. 
23:43:35 <ocramz> Isaacary: drop java boy, it's a dead end
23:43:47 <Isaacary> axman6: i got told this is a friendly community for newbie programmers am i wrong?
23:43:56 <Isaacary> orcramz: how so?
23:44:11 <Walther> Isaacary: But at least you've joined #haskell so you're probably looking towards learning this as well?
23:44:12 <Arahael> Isaacary: Good for you, but you're missing an opportunity by not identifying why you understand it more.
23:45:01 <Walther> Isaacary: #haskell is indeed a very friendly community for programmers, plenty of helpful people around here
23:45:19 <Walther> The core idea is still the Haskell programming language, not java or python 
23:45:20 <ocramz> Isaacary: don't get me wrong, it's an industry language. But the whole concept of class inheritance is distracting at best. Try haskell: ghc.io
23:45:30 <Arahael> Isaacary: It _is_ a very friendly community - I've only seen a couple of big fights, and they were _all_ amongst the experienced devs.  None of the newbie devs ever find themselves in a fight.
23:45:40 <Isaacary> Walther: i would really like to get a understanding on all  programming and each language 
23:45:41 * Arahael is tongue-in-cheek.
23:45:58 <Walther> Isaacary: excellent, have a fun journey :)
23:46:11 <Walther> Isaacary: http://haskell.org/ Have a try!
23:46:20 <Axman6> there are thousands of languages though, many of them not really worth knowing
23:46:46 <Arahael> Isaacary: I highly recommend you give low-level 8086 assembly a go, as well, in addition to an ML language (such as Haskell), Lisp, and Java.
23:47:10 <Walther> Axman6: then again as with many natural languages, you might not need to learn all of them fully; some of them are closely related enough that learning bits of one gets you through the core of another
23:47:22 <Axman6> right
23:48:00 <Isaacary> thanks for the advice everyone :) 
23:48:51 <Arahael> Isaacary: Btw, Python and Java are very different - in many respects.  Java isn't a superiour language (and neither is Python).
23:49:44 <Arahael> Isaacary: (The differences between Python, Java, and Haskell, even, are much more than mere syntax)
23:50:13 <Isaacary> how so ?
23:50:23 <ocramz> Isaacary: yes, Haskell perhaps will be a bit of a shock in the beginning
23:50:25 <Isaacary> sorry newbie question lol 
23:50:42 <Walther> Well, there's a lot of internal stuff that differs between Java and Python and Haskell and others
23:50:47 <lamefun> Does Haskell support inner sandboxes (eg. game engine sandboxes a mod, the mod sandboxes level scripts)?
23:50:52 <Walther> might not be relevant for a beginner yet though
23:51:02 <Arahael> lamefun: You mean, as a free monad?
23:51:05 <ocramz> Isaacary: "lazy evaluation", "separation of purely functional and I/O through datatypes" ...
23:51:15 <Walther> for a beginner it might be more useful to use a bit of everything and see what sticks :)
23:51:27 <Arahael> Walther: Definetly agree with that.
23:51:44 <Arahael> I personally recommend python for beginners, as it's a very flexible language.
23:51:50 <Axman6> lamefun: it's pretty easy to design a system in haskell that doesn't need sandboxes because they can't do anything dangerous
23:52:18 <Maxdamantus> "separation of purely functional and I/O through datatypes" sounds questionable.
23:52:44 <Arahael> lamefun: Historically, in Haskell, it was actually harder to get out of that "sandbox", iirc.  
23:52:48 <felixn> lamefun: https://wiki.haskell.org/Safely_running_untrusted_Haskell_code
23:52:56 <wrengr> Has anyone here used TravisCI with github before?
23:53:23 <Walther> hehe. I still need to find more tutorials and blog posts to go through about monads, functors, applicatives and such. I still haven't quite grasped the advanced concepts of haskell
23:53:29 <Arahael> lamefun: felixn's suggestion might be useful if you need to actually deal with IO within the sandbox, but it's generally pretty easy to avoid IO entirely.
23:54:14 <Walther> the basic functional stuff like maps, filters, recursive function definitions and currying i'm already rather comfortable with
23:54:22 <Axman6> a combination of SafeHaskell and providing a pure API makes "sandboxes" unnecessary
23:55:05 <ocramz> Maxdamantus: please elaborate?
23:55:28 <Walther> but as someone wise once said here, there's probably no single monad explanation that works for everyone, nor is there a one for each person that works perfectly - it's more about the process
23:55:48 <Maxdamantus> ocramz: IO operations have types because they're values, not because they're IO operations.
23:55:55 <Axman6> Walther: functors, applicatives and monads are far from advanced haskell. the problem is that the individual instances can be tricky to understand if you're not used to functional programming
23:56:15 <Arahael> Walther: Not to mention... The names are a bit wierd.
23:56:27 <Arahael> Walther: I'm finding it more useful to think of them as merely a pattern.
23:56:45 <Walther> Arahael: Nod.
23:56:48 <Axman6> they are just patterns
23:56:50 <Arahael> Walther: (though I'm teaching myself category theory now...  But that's re-inforcing my notion that they should be understood as patterns)
23:57:16 <Axman6> but they also have theoretical backgrounds, and using the proper names means people are reminded there are things like laws they also need to obey
23:57:47 <Arahael> Which apparently helps in reducing/eliminating leaky abstractions.
23:57:53 <ocramz> Maxdamantus: I'm afraid I don't understand your definition.
23:57:53 <Maxdamantus> ocramz: Haskell doesn't limit IO somehow using the type system. It limits it by not providing constructs that actually do it and instead providing constructs that express it.
23:58:00 <Walther> I've also been thinking about making a sub-language / dialect of "simple haskell", where the focus would be on simplicity and readability while being compatible with Haskell
23:58:31 <felixn> Maxdamantus: yea that sounds right
23:58:48 <Arahael> Maxdamantus: I suggest you read about free monads.
23:58:53 <Walther> something without lambdas and all these twelve different folds and so on
23:59:22 <Walther> I mean, nothing inherently wrong with lambdas per se, but oh wow can they become a mess to read
23:59:24 <itsMontoya> What is the most idiomatic way to split an int?
23:59:32 <itsMontoya> 1234 -> [1,2,3,4]
23:59:35 <Arahael> Walther: So define them as named function!
23:59:40 <MarcelineVQ> you don't have to use lambdas
23:59:48 <Maxdamantus> Arahael: why? They're not part of Haskell.
23:59:50 <MarcelineVQ> I don't find them hard to read myself, but you have options
23:59:51 <Maxdamantus> (afaik)
