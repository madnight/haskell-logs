00:00:12 <scutigera> aha
00:00:14 <scutigera> nvm
00:00:19 <arahael> ttt_fff_: I thought monads required typeclasses for >>= and >>?
00:00:24 <scutigera> it needs at least one digit after '.'
00:00:34 <scutigera> happy summer solistice !
00:00:39 <kqr> arahael, you could thread the dictionary manually
00:00:56 <gamegoblin> scutigera: change it to match $ takeWhile1 isDigit >> optional (char '.' >> takeWhile isDigit)
00:00:58 <arahael> kqr: What do you mean?
00:01:06 <kqr> arahael, do you know how typeclasses are implemented?
00:01:07 <gamegoblin> Went to the Fremont Solstice Parade today
00:01:09 <gamegoblin> always a treat
00:01:43 <gamegoblin> :t curry
00:01:44 <lambdabot> ((a, b) -> c) -> a -> b -> c
00:01:49 <scutigera> gamegoblin: sheesh. i should havee figured that out.
00:01:51 <scutigera> ty
00:02:03 <arahael> kqr: Honestly, I haven't quite covered typeclasses.  In my head I kind of think of them as regular polymorphism, except in haskell, you can be polymorphic on the expected return type.
00:02:21 <arahael> kqr: So no, I don't know how they're implemented.
00:02:46 <kqr> arahael, well, the thing Haskell does automatically, you can do that manually to get something typeclass-like without typeclasses
00:03:11 <arahael> kqr: Do you have a link that explains that?
00:03:28 <kqr> http://youtu.be/6COvD8oynmI
00:04:07 <kqr> 18 minutes in
00:04:09 <kqr> it starts
00:04:25 <gamegoblin> Here is a good post about non-typeclass Haskell http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
00:04:45 <gamegoblin> Arguably representing "typeclasses" as data is more haskellish and more flexible
00:04:52 <gamegoblin> but a little less convenient some of the type
00:04:53 <arahael> kqr: I can't watch videos, unless they have good subtitles. :(  (I get frustrated, actually, that the trend is towards inaccessible videos)
00:05:04 <gamegoblin> arahael: check out that link I sent
00:05:12 <arahael> gamegoblin: Thanks. :) Checking it out...
00:05:18 <kqr> arahael, oh, that sucks. :( spj is a wonderful presenter
00:05:37 <gamegoblin> He’s soooo british, I love it
00:06:16 <kqr> drat!
00:06:19 <Hafydd> Damning with faint praise.
00:06:40 <arahael> kqr: Unfortunately that mode of presentating is very specific to one's audience.
00:07:24 <arahael> gamegoblin: ha, now I have to learn about forall. :)  But looks useful, at least to know.
00:07:39 <gamegoblin> arahael: you can ignore mostly
00:07:41 * hackagebot digitalocean-kzs 0.1.0.0 - digitalocean api for haskell  http://hackage.haskell.org/package/digitalocean-kzs-0.1.0.0 (KazumaSATO)
00:07:41 * hackagebot promises 0 - Lazy demand-driven promises  http://hackage.haskell.org/package/promises-0 (EdwardKmett)
00:07:57 <gamegoblin> arahael: that article doesn’t require you to know about it to understand the idea
00:08:14 <Hafydd> "Lazy demand-driven promises" sounds like the kind of thing I do.
00:08:29 <arahael> gamegoblin: Ok, I'll ignore it initially.
00:08:55 <gamegoblin> arahael: the basic idea of the article is this. Somethingl like Typeclass a => a -> … 
00:09:04 <gamegoblin> arahael: can be replaced with TypeclassA -> a …
00:09:19 <gamegoblin> where TypeclassA is a proper data type that just contains the same sort of functions as Typeclass did in the first place
00:09:45 <gamegoblin> like a print function might look like Show a => a -> IO ()
00:09:55 <gamegoblin> But that could be replaced by ShowA -> a -> IO ()
00:10:12 <gamegoblin> where ShowA contained a record called "show" that was of type a -> String
00:10:31 <gamegoblin> so now rather than print looking like print x = putStrLn (show x)
00:10:31 <arahael> gamegoblin: I think it'll be better if I read and study it first before I discuss it. :)
00:10:46 <arahael> gamegoblin: Though I do need to cook dinner as well. :(
00:10:48 <gamegoblin> it now looks like print s x = putStrLn (show s x)
00:11:03 <gamegoblin> No worries
00:14:21 <ttt_fff> so I need to build a haskell-like langauge (types + pattern matching), but using scheme syntax -- and it looks ugly as hell right now; does anyone know how to make haskell-in-scheme-syntax to look pretty ?
00:14:53 <gamegoblin> ttt_fff: why?
00:20:47 <Hijiri> ttt_fff: lots of macros?
00:21:51 <Hijiri> I remember seeing an HN post linking to some statically-typed lispy language
00:21:58 <Hijiri> and case expressions and things were implemented as macros
00:22:36 * hackagebot record-syntax 0.1.0.2 - A library for parsing and processing the Haskell syntax sprinkled with anonymous records  http://hackage.haskell.org/package/record-syntax-0.1.0.2 (NikitaVolkov)
00:22:43 <Cale> There have been at least a couple. One I remember was called Liskell.
00:23:04 <Cale> Oh, right, and Lisk.
00:23:12 <Cale> Kind of annoyingly similar names
00:25:02 <Cale> But ugh, why? :)
00:31:53 <kaidelong> So I'm about to start a project push-pull-strategies which is supposed to provide things like clocks and buffers to help transform push control flow to pull based and vice versa
00:31:57 <kaidelong> I'm wondering
00:32:02 <kaidelong> has someone else already done this somewhere?
00:32:18 <kaidelong> it's yak shaving, I'd rather not do it
00:32:46 <kaidelong> in particular if I'm just repeating work already done by something like pipes or lens I'd rather not
00:34:00 <kaidelong> also I need to come up with some way that a netwire network with IO as the monad is a valid "puller"
00:35:16 <kaidelong> the dream is that you can connect "Pullers" to "Pushers" using buffering strategies and "Pushers" to "Pullers" using clocking strategies
00:35:38 <Cale> kaidelong: That kinda sorta sounds like exactly what pipes/conduit/etc. are, but maybe not?
00:36:44 <kaidelong> the specific problem I'm solving is connecting netwire to GLFW, it's harder than SDL because SDL has a big central event queue you pull from
00:36:50 <kaidelong> GLFW exposes events instead
00:37:00 <kaidelong> which is the opposite of how netwire works
00:37:34 <kaidelong> so I have to reconstruct the event queue, basically
00:37:37 * hackagebot sdl2-image 0.1.3.0 - Haskell binding to sdl2-image.  http://hackage.haskell.org/package/sdl2-image-0.1.3.0 (ccll)
00:38:54 * kaidelong taking a look at c  onduit now
00:39:51 <Haskellfant> kaidelong: so you want to go from callbacks to event polling?
00:40:18 <kaidelong> yes!
00:40:50 <kaidelong> and yes, this seems crazy, but netwire graphs don't allow you to have asynchronous inputs at multiple points, to my knowledge
00:40:54 <Haskellfant> I'm doing this in a project by having one thread continously reading a Chan and the callbacks write the events to the Chan
00:40:54 <kaidelong> there's a central clock
00:41:11 <kaidelong> what library provides Chan?
00:41:16 <Haskellfant> async iirc
00:42:06 <Haskellfant> actually I think I use the one from base https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Concurrent-Chan.html
00:42:20 <Haskellfant> that one relies on mvar while the one in async uses stm or something like that
00:42:38 <Haskellfant> ah no TChan is the other one and it's in the stm package https://hackage.haskell.org/package/stm-2.4.4/docs/Control-Concurrent-STM-TChan.html
00:43:28 <kaidelong> would MVar not do? What would happen if one of the event handlers blocks?
00:43:43 <kaidelong> order of the events that follows becomes nondet?
00:43:51 <kaidelong> I guess that is undesirable
00:44:06 <Haskellfant> well I don't want to block in the callbacks, so I just write to the chan and then the callback is done
00:44:16 <kaidelong> yeah
00:44:34 <kaidelong> unbounded memory use is nasty but I think if you tried to use MVars, it'd boil down the same thing anyway
00:44:48 <Haskellfant> well you can use a bounded chan
00:45:23 <Haskellfant> like this one https://hackage.haskell.org/package/unagi-chan-0.4.0.0/docs/Control-Concurrent-Chan-Unagi-Bounded.html
00:46:26 <Haskellfant> one thing to keep in mind when handling the events outside of your callback is, that glfw might not like you calling it from a different thread
00:47:37 * hackagebot sdl2-image 0.1.3.1 - Haskell binding to sdl2-image.  http://hackage.haskell.org/package/sdl2-image-0.1.3.1 (ccll)
00:48:13 <kaidelong> that's not allowed
00:48:18 <kaidelong> only one thread has GLFW initialized
00:48:29 <kaidelong> the way I'm doing this
00:48:44 <kaidelong> is that I'm going to handle the output of the netwire graph asynchronously as well
00:49:12 <kaidelong> it's instructions back to GLFW, not direct invocations of it
00:49:24 <kaidelong> but for now I'm still working on the input part
00:50:32 <kaidelong> actually it's a little more complicated than that
00:50:57 <kaidelong> there's actually three threads, the main thread, a server thread, the netwire thread, I have it drawn out somewhere
00:52:15 <kaidelong> the idea is that neither of those three should ever block for any reason but the server will do background jobs and sends a sum type of GLFW messages and server messages to the netwire thread (polymorphic in the type of the server message, ideally)
00:53:30 <kaidelong> one cool thing about netwire is that, if you want, you can statically enforce that the graph is pure and won't block on IO, if you want, because you can demand a graph that's polymorphic in the underlying monad using Rank2Types
00:59:39 <kuznero> Hi All!
01:09:39 <Axman6> kuznero: hello!
01:11:54 <kuznero> Is it possible to build SublimeHaskell dependencies in a sandbox? I would like not to get it mixed with other things I am doing ....
01:12:57 <Axman6> you can probably copy the binaries it needs into a directory in your path
01:14:15 <Axman6> kuznero: using stack might also be useful for that
01:14:20 <kuznero> Including libraries?
01:14:36 <kuznero> Everybody is talking stack these days... Maybe I should indeed try it out :)
01:14:50 <kuznero> Axman6: thanks, will go ahead and try stack
01:15:28 <Axman6> libraries may not work
01:16:20 <Myrl-chan> Test
01:16:46 <Haskellfant> passed
01:17:50 <kuznero> Axman6: ok, I know this question will sound ridiculous but what is the IDE that just works at the moment... Should I try Leksah again?
01:17:55 <Myrl-chan> So, guys, I'm going to be restarting my VPS. BRB.
01:18:12 <Haskellfant> kuznero: I don't think we have that :)
01:20:12 <Axman6> kuznero: I just use sublime, workes well enough for me
01:20:51 <kuznero> Axman6: you mean just with code highlighting and nothing else?
01:21:41 <[k-> ghci is always around of course
01:22:39 * hackagebot notzero 0.0.9 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.0.9 (TonyMorris)
01:23:13 <kuznero> Haskell devs don't need things like fully fledged IDE :)
01:23:33 <Haskellfant> at least that's what we tell ourselves to deal with the fact that we don't have one
01:24:53 <kuznero> Haskellfant: is it a crazy idea to ask people to join efforts and create something for desktop (I mean not like FP Complete's one)
01:24:55 <kuznero> ?
01:25:28 <Haskellfant> kuznero: I kinda hope ide-backend will unify efforts a bit
01:26:55 <Axman6> kuznero: no, i use sublimehaskell and lots of other things. sublime is very powerful
01:34:21 <[k-> atom has ide-haskell
01:36:30 <codygman> How can I make a dummy UTCTime? I have this so far "UTCTime (ModifiedJulianDay 1)" but can't figure out a way to make a DiffTime without importing quite a few libraries, is there an easier way to do this? I just want a [UTCTime] for my tests
01:37:55 <codygman> Looks like I was looking for this: UTCTime (ModifiedJulianDay 1) (fromIntegral 10 :: DiffTime)
01:51:34 <creichert> codygman: you can also do something like this http://lpaste.net/5402455592872706048
01:51:35 <creichert>  
01:52:40 * hackagebot data-easy 0.6.1 - Consistent set of utility functions for Maybe, Either, List and Monoids.  http://hackage.haskell.org/package/data-easy-0.6.1 (jcristovao)
01:52:42 * hackagebot notzero 0.0.10 - A data type for representing numeric values, except zero.  http://hackage.haskell.org/package/notzero-0.0.10 (TonyMorris)
01:53:37 <safinaskar> i just read that Lens' is defined so: type Lens' a b = forall f . Functor f => (b -> f b) -> (a -> f a)
01:54:13 <dramforever> yes
01:54:22 <safinaskar> why? i can understand why to define it so: (a -> b, a -> b -> a) and even so: a -> (b, b -> a)
01:54:43 <dramforever> 1. because you can compose lens with (.) in Prelude
01:55:05 <dramforever> 2. We have many other stuff with a similar type in the lens package
01:55:30 <Haskellfant> also it's a neat way to not have to write getters and setters separately but only one function and get the rest for free
01:55:59 <safinaskar> how this definition of Lens' works?
01:56:09 <dramforever> I think there's a video for that
01:56:18 <johnw> safinaskar: try writing a function for Lens' b (a, b)
01:56:24 <safinaskar> dramforever: give me a link, please
01:56:27 <johnw> err, swap those two
01:56:33 <johnw> http://ftp.newartisans.com/pub/Lenses.mp4
01:56:39 <dramforever> yeah exactly
01:56:41 <pacak> safinaskar: You can use different Functors - Const and Identity to either set or get values.
02:01:49 <liste_> I find the blog post that introduced that kind of lens pretty enlightening: http://www.twanvl.nl/blog/haskell/cps-functional-references
02:02:30 <dramforever> yeah, it amazingly generalizes to other stuff like traversals
02:03:05 <dramforever> Actually I came up with one alternative earlier
02:03:57 <dramforever> It just does CPS a second time
02:03:58 <dramforever> http://lpaste.net/128137
02:04:41 <dramforever> the bottom trick can be avoided by changing the type to forall p q. (a -> (b -> p) -> q) -> s -> (t -> p) -> q
02:05:45 <safinaskar> johnw: "try writing a function for" - if Lens' is defined as (a -> b, a -> b -> a), then: (snd, \(x, y) z -> (x, z)). if we take standard Lens' definition, i don't know (because i don't understand it)
02:06:13 <dramforever> safinaskar: did you watch the vid?
02:06:14 <johnw> dramforever: if you flip that to an existential, you're really really close to the Proxy type from pipes
02:06:37 <dramforever> johnw: ?
02:07:11 <dramforever> why?
02:07:25 <dramforever> isn't the Proxy from pipes a free monad?
02:07:48 <johnw> safinaskar: standard f (x, y) = fmap (x,) <$> f y
02:07:58 <johnw> dramforever: yep, but if you boehm-berarducci encode it
02:08:10 <dramforever> arrgh
02:08:21 <johnw> you get forall s. (a' -> (a -> s) -> s) -> (b -> (b' -> s) -> s) -> (r -> s) -> s
02:08:30 <johnw> the first two arguments of which fit your pattern, if p ~ q
02:08:47 <johnw> (ignoring the M constructor, for just a moment)
02:09:55 <dramforever> hmm
02:10:00 <dramforever> looks funny
02:10:15 <safinaskar> johnw: dramforever: thanks for video, i am watching
02:10:17 <dramforever> however all these are nothing compared to profunctor lens
02:11:00 <johnw> well, if we look at the arrows of the Cont category, then Proxy is really (a' ~> a, b ~> b') ~> r
02:11:02 <dramforever> I mean, it's obvious that Lens is actually type Lens s t a b = forall f. Functor f => Star f a b -> Star f s t
02:11:29 <dramforever> johnw: yeah that's right
02:14:01 <joco42> anyone knows how can I install ghcjs NOT using https://github.com/ryantrinkle/ghcjs-setup  in NixOS 14.02 ? 
02:14:27 <ryantrinkle> joco42: 14.02 is too old, i believe
02:14:33 <ryantrinkle> you'll need to update to a newer channel
02:14:45 <joco42> sorry, I meant 14.12
02:14:55 <ryantrinkle> that *might* have it, but i'm not sure
02:15:16 <ryantrinkle> i'm pretty sure unstable has it by now
02:15:38 <ryantrinkle> if you just want to install using nix-env, you can use the nixpkgs from ghcjs-setup explicitly
02:15:43 <joco42> ryantrinkle: I'm on unstable.
02:16:51 <joco42> ryantrinkle: I try that, thanks.
02:17:41 * hackagebot relational-query 0.5.0.3 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.5.0.3 (KeiHibino)
02:17:53 <ryantrinkle> joco42: no problem; i think the switch you need to use is either -I or -f
02:18:00 <ryantrinkle> (that's an upper-case i)
02:18:29 <joco42> ryantrinkle: I have a look.
02:26:34 <safinaskar> johnw: dramforever: is there slides without video?
02:26:51 <dramforever> Yes, but I don't have links
02:27:41 * hackagebot sys-process 0.1.4 - A replacement for System.Exit and System.Process.  http://hackage.haskell.org/package/sys-process-0.1.4 (TonyMorris)
02:32:41 * hackagebot singleton-nats 0.3.0.0 - Unary natural numbers relying on the singletons infrastructure.  http://hackage.haskell.org/package/singleton-nats-0.3.0.0 (AndrasKovacs)
02:39:50 <joco42> ryantrinkle: I cannot really figure it out, but actually the only reason I cannot use ghcjs-setup is that in that shell there is no nix-env : nixpkgs.pkgs.haskell-ng.packages.ghcjs
02:40:22 <joco42> ryantrinkle: http://pastebin.com/9VXSF9v1
02:40:34 <ryantrinkle> you've gotta call nix-env from outside the shell, but give it the path to the ghcjs-setup version of nixpkgs as an argument
02:40:49 <ryantrinkle> btw, what's your overall goal?
02:41:10 <joco42> ryantrinkle: to try ghcjs with sodium
02:42:05 <ryantrinkle> ah, ok; so i guess you need cabal for that?
02:43:32 <joco42> ryantrinkle: sodium is already in latest unstable
02:43:49 <joco42> ryantrinkle: I tried that : http://pastebin.com/CAQQL0cn
02:44:09 <ryantrinkle> joco42: yeah, but if ghcjs isn't working in the latest unstable, that won't help
02:44:39 <ryantrinkle> joco42: ok, if you switch to https://github.com/ryantrinkle/try-reflex it will work
02:44:59 <ryantrinkle> i just tried it, and you can install sodium in two different ways:
02:45:12 <ryantrinkle> you can add it to packages.nix in that directory
02:45:12 <joco42> ryantrinkle: I am listening.
02:45:20 <ryantrinkle> or, you can cabal install it afterwards
02:45:32 <ryantrinkle> the cabal install version probably won't play well with nix
02:45:43 <ryantrinkle> i'm not really maintaining ghcjs-setup anymore
02:45:49 <ryantrinkle> all my improvements are going into try-reflex
02:46:12 <joco42> ryantrinkle: thanks, good to know, I have a look at try-reflex then
02:46:12 <ryantrinkle> which is the same functionality, plus a lot more, including a tutorial for Reflex
02:46:18 <ryantrinkle> which, by the way, is my FRP engine
02:46:29 <ryantrinkle> maybe you should try it out, too :)
02:46:51 <ryantrinkle> also, we have a chatroom, #reflex-frp
02:47:12 <joco42> ryantrinkle: my next goal after sodium+ghcjs is sodium+reflex, I am just more familiar with Sodium at the moment, but we plan to have a Meetup in Helsinki about Reflex in the autumn... 
02:47:19 <ryantrinkle> sodium+reflex?
02:47:31 <joco42> ryantrinkle: sorry, i ghcjs+refles
02:47:40 <ryantrinkle> that makes more sense :)
02:47:44 <joco42> ryantrinkle: yes, indeed
02:47:46 <ryantrinkle> well, let me know if i can be of any help :)
02:48:33 <joco42> ryantrinkle: many thanks, we are a young meetup : http://www.meetup.com/Helsinki-Functional-Reactive-Programming-Meetup/
02:48:48 <ryantrinkle> ah, cool!
02:48:55 <ryantrinkle> that's great to hear
02:49:17 <ryantrinkle> maybe i'll stop by sometime... it's a bit of a hike, though, from NYC :P
02:49:18 <joco42> ryantrinkle: summer is a little slow here in Finland
02:50:09 <joco42> ryantrinkle: summer is the best time to visit
02:50:21 <ryantrinkle> that makes sense, haha
02:51:29 <ryantrinkle> well, once you've had a look at both sodium and reflex, it'd be great to get your feedback about them, and how they relate
02:51:33 <ryantrinkle> hit me up sometime :)
02:52:08 <joco42> ryantrinkle: cool, I have a look, it might take a few weeks though
02:52:42 * hackagebot singleton-nats 0.3.0.1 - Unary natural numbers relying on the singletons infrastructure.  http://hackage.haskell.org/package/singleton-nats-0.3.0.1 (AndrasKovacs)
02:54:24 <joco42> ryantrinkle: well, perhaps I just might go ahead and try reflex right away and see how it goes... 
02:54:38 <ryantrinkle> hello world is pretty simple :)
02:54:42 <ryantrinkle> ghci
02:54:57 <ryantrinkle> > :m +Reflex.Dom
02:54:58 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:55:13 <ryantrinkle> Reflex.Dom> mainWidget $ text "Hello, world!"
02:55:17 <ryantrinkle> should get you going :)
02:56:07 <ryantrinkle> then you can try stuff like this:
02:56:17 <ryantrinkle> mainWidget $ button "Click me!" >>= count >>= display
02:56:36 <joco42> ryantrinkle: I should jump right into deep reflex water.
02:57:14 <ryantrinkle> good plan :)
02:57:38 <joco42> ryantrinkle: I got encouragement.
02:57:39 <ryantrinkle> i've gotta get to sleep soon, but i'll be around tomorrow, and there may be some folks in #reflex-frp who can help if i'm not around
02:57:42 * hackagebot text-ldap 0.1.1.6 - Parser and Printer for LDAP text data stream  http://hackage.haskell.org/package/text-ldap-0.1.1.6 (KeiHibino)
02:57:53 <ryantrinkle> joco42: oh, one thing to note: you might want to use the develop branch of try-reflex
02:58:07 <ryantrinkle> if you watch my talk https://www.youtube.com/watch?v=mYvkcskJbc4
02:58:16 <ryantrinkle> it's closer to what's on develop than what's on master
02:58:32 <ryantrinkle> which means you should also use the develop version of the readme, https://github.com/ryantrinkle/try-reflex/tree/develop
02:58:41 <joco42> ryantrinkle: Good night, it is midsummer here: happy midsummer. I already watched it a few times.
02:58:43 <ryantrinkle> the readme has a medium-length tutorial in it
02:58:59 <ryantrinkle> you have a good day/night, too!
02:59:02 <joco42> ryantrinkle: thanks for the tips
02:59:08 <ryantrinkle> no problem
02:59:11 <joco42> ryantrinkle: later, aligator
02:59:22 <ryantrinkle> in a while, crocodile :P
03:02:05 <safinaskar> johnw: dramforever: etc: i watched the video (in fact, i just watched slides with disabled sound, because i am not native English speaker). and i still don't understand why we have such Lens' definition. yes, now i understand how standard def works. but i still don't undestand why it is standard. view/set or view/over will go, too. and i can implement that (b -> f b) -> (a -> f a) using view and over/s
03:02:11 <safinaskar> et
03:05:18 <kuznero> what to do if haddock is not part of stackage? does it make sense to temporarily switch to hackage, install haddock and switch back to stackage? 
03:06:10 <ion> joco42: I should try to visit one of your meetups.
03:07:43 * hackagebot scyther-proof 0.10.0.1 - Automatic generation of Isabelle/HOL correctness proofs  for security protocols.  http://hackage.haskell.org/package/scyther-proof-0.10.0.1 (SimonMeier)
03:09:41 <liste> safinaskar that kind of definition can be generalized to obtain Prisms, Setters, Traversals etc that can be freely composed with each other and Lenses
03:10:37 <liste> also, it allows you to define lenses without depending on `lens' (or `lens-family') packages
03:11:16 <liste> (though that would also be possible with `type Lens a b = (a -> b, a -> b -> a)')
03:12:37 <liste> and composes with the familiar . operator for functions (:
03:13:39 <dramforever> hmm
03:14:05 <dramforever> TIL you can "export" an instance without exporting the type
03:14:15 <dramforever> also you don't have to export the class
03:16:15 <liste> well isn't that the only way to export orphans?'
03:16:42 <dramforever> liste: data C T = ... and instance C T where ...d
03:16:47 <dramforever> wait data T = ...
03:16:55 <dramforever> and you don't export T
03:17:22 <bergmark> liste: an orphan is an instance defined in a module that doesn't define the class nor the type
03:17:25 <liste> oh :D
03:17:28 <liste> I see
03:17:48 <liste> but can that kind of instances be observed from outside?
03:17:57 <dramforever> yes
03:18:10 <dramforever> for example if you have instance Show T where...
03:18:17 <dramforever> and you export foo :: T
03:18:26 <dramforever> and you call show T
03:18:44 <bergmark> show foo*
03:19:03 <dramforever> yes yes
03:22:12 <ion> safinaskar: Try solving this: you want a function that takes a function like readFile and a tuple like ("filename", 42) and returns (<contents of the file>, 42) in IO. You'll be able to do this with Functor. The type of this function is (FilePath -> IO String) -> (FilePath, Integer) -> IO (String, Integer). Now you have a function that lets you focus on an element of a tuple and change it with an IO action.
03:22:43 * hackagebot path 0.5.2 - Path  http://hackage.haskell.org/package/path-0.5.2 (ChrisDone)
03:22:45 * hackagebot gtk2hs-buildtools 0.13.0.4 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.13.0.4 (HamishMackenzie)
03:23:53 <ion> safinaskar: Turns out that the general type of the function you just wrote is Functor f => (a -> f b) -> (a, c) -> f (b, c).
03:25:30 <safinaskar> ion: i can define overM on top of my plain lens. see:
03:25:32 <safinaskar> ion: data Lens s a = Lens { view :: s -> a, over :: (a -> a) -> s -> s }
03:25:32 <safinaskar> overM :: (Functor f) => Lens s a -> (a -> f a) -> s -> f s
03:25:32 <safinaskar> overM lens smallChange cont = fmap (\x -> over lens (const x) cont) (smallChange (view lens cont))
03:25:53 <safinaskar> (and this typechecks)
03:26:40 <dramforever> yes and that's how you make lenses from setters and getters
03:26:53 <dramforever> btw over :: (a -> b) -> s -> t is more general
03:27:31 <dramforever> safinaskar: oh and congratulations! You figured it out
03:27:50 <ion> safinaskar: Now, what else could we do than apply it to readFile :: FilePath -> IO String? Two especially useful things are Const :: a -> Const a b and (Identity . f) :: a -> Identity b (for an f of your choice). Those functors give you getters and setters.
03:29:19 <dramforever> hmm....an interesting question: does the functor laws imply the lens laws?
03:29:23 <codygman> Is this the proper way to turn a Key returned from Persistent into it's data type: https://bitbucket.org/codygman/persistent-servant-example/src/29983ac4e33de48892b28c1f62beaf7a480ba629/src/Database.hs?at=master#cl-71
03:29:26 <dramforever> s/does/do
03:29:41 <safinaskar> well, i understand both definitions of lenses, and i understand why they are isomoprphic. but i still don't understand why functor definition is standard. well, i will read about traversals, prisms etc and maybe i will understand
03:30:28 <dramforever> safinaskar: I started to understand as soon as I went into traversals
03:31:09 <safinaskar> dramforever: if haskell supported proving of laws (like Agda and Coq) than you would check this laws implication mechanically
03:31:42 * dramforever is going into coq to check
03:32:48 <julie-ai> are there usually so many people here?
03:33:03 <dramforever> yes, I guess
03:33:11 <julie-ai> neato
03:33:29 <dramforever> but not many are ready to respond
03:34:24 <julie-ai> as in afk?
03:34:28 <safinaskar> julie-ai: but simple questions (like "what is lenses") normally get a lot of responses
03:34:29 <dramforever> yep
03:34:37 <dramforever> ha ha yes
03:34:45 <dramforever> more for "what is a monad"
03:35:18 <johnw> i think you need more than just functor, dramforever
03:35:27 <johnw> lenses are coalgebras of the costate comonad
03:35:27 <LmNShtM> But really, what is a monad?
03:35:35 <safinaskar> LmNShtM: :)
03:35:37 <dramforever> johnw: yes
03:36:50 <safinaskar> LmNShtM: monads are buritos. http://chrisdone.com/posts/monads-are-burritos
03:37:14 <mniip> LmNShtM, it's something that defines two functions, return and >>=, with respective types, and obeys monad laws
03:37:19 <mniip> there isn't much more than that
03:37:44 * hackagebot glib 0.13.1.1 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.13.1.1 (HamishMackenzie)
03:38:10 <dramforever> I think join is easier to understand
03:38:13 <johnw> LmNShtM: there are many ways to think about monads, if that's what you're asking, but no one of them will explain the connection to the other ways
03:38:44 <mniip> dramforever, join is easier to define
03:38:52 <mniip> but >>= has an intuitive meaning
03:39:00 <johnw> for me, join has the intuitive meaning
03:39:01 <ion> safinaskar: traverse composes nicely: (traverse . traverse) readFile :: [Maybe FilePath] -> IO [Maybe String]. Van Laarhoven lenses compose nicely for the same reason, and traverse is an example of a Traversal. You get traversals when you replace the Functor constraint with Applicative, which lets you focus to zero or more members instead of exactly one.
03:39:06 <dramforever> especially after I saw someone asking: What can I do to fix this? No instance for (Show (IO (IO [IO (IO Int)])))
03:39:14 <mniip> johnw, you won't use join in do-notation
03:39:39 <johnw> I don't use do-notation in my thinking either
03:39:52 <mniip> depends on what you are doing
03:40:08 <dramforever> mniip: join is like a equation of the form x^2 = ax + b in a math problem, which always makes me happy
03:40:23 <dramforever> and return is like x = c, which makes me even happier
03:40:29 <pacak> mniip: let foo = print "bar" in do join foo
03:40:31 <dramforever> (a b c are consants)
03:40:33 <mniip> dramforever, wait wait what?
03:40:45 <dramforever> well, maybe c = x is better
03:40:47 <dramforever> mniip: ?
03:41:14 <mniip> what is the relationship between monad functions and equations?
03:41:58 <dramforever> if you have x^2 = ax+b then you can simplify any polynominal of x into a linear function
03:42:06 <mniip> pacak, I don't think I can parse that...
03:42:18 <mniip> foo :: IO (), how would you join that
03:42:51 <ion> pacak: Did you mean pure (print "bar")?
03:43:13 <dramforever> mniip: if you have return too, you can turn a constant into k*x, for some k
03:43:29 <dramforever> so you can make any polynominal of x into the form m*x, for some m
03:43:41 <dramforever> to me that's basically how monads work
03:43:48 <pacak> Hmmm....
03:43:49 <mniip> you didn't explain the relationship
03:44:01 <pacak> let foo = return (print "foo") ...
03:44:10 <pacak> Or pure, right.
03:44:14 <mniip> pacak, that seems pointless
03:44:15 <dramforever> mniip: wait I'm writing that
03:44:59 <dramforever> with monads you can easily do (m (m (m ... (m a) ... ))) -> m a, for 0~inf m('s)
03:45:09 <pacak> mniip: On it's own - yes, but I've used join in do a few times in similar situations
03:45:17 <dramforever> I mean zero or more m's
03:45:19 <mniip> dramforever, yeah right
03:46:30 <dramforever> so (>>=) and (>>) are like +
03:46:44 <dramforever> return is like (*x)
03:46:53 <dramforever> hmm...not really
03:46:55 <dramforever> never mind
03:46:58 <mniip> that sounds weird
03:47:24 <dramforever> yeah maybe
03:47:35 <mniip> I intuitively follow the container defition of Functor/Applicative/Monad
03:47:43 <dramforever> but reconsider this: No instance for (Show (IO (IO [IO (IO Int)])))
03:47:44 * hackagebot gtk3 0.13.8 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.8 (HamishMackenzie)
03:47:46 * hackagebot gtk 0.13.8 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.8 (HamishMackenzie)
03:47:49 <mniip> except my intuitive understanding of a container is much wider than the commonly used one
03:47:53 <dramforever> dunno if I got parens correc
03:47:58 <dramforever> *correct
03:48:14 <mniip> dramforever, if you got that type, you probably used a shitton of misplaced fmaps on the way
03:48:19 <dramforever> not me
03:48:25 <mniip> whoever posted that
03:48:40 <dramforever> also interestingly many generic monad functions are hard to explain generally
03:48:40 <mniip> I don't see how would you arrive at that type without a fmaplike function
03:48:42 <dramforever> like:
03:48:55 <dramforever> > replicateM 5 "abc"
03:48:56 <lambdabot>  ["aaaaa","aaaab","aaaac","aaaba","aaabb","aaabc","aaaca","aaacb","aaacc","aa...
03:49:49 <mniip> replicateM n x: take an element from the container x, repeat that n times, return a list of picked elements
03:50:07 <dramforever> hmm...
03:50:10 <dramforever> oh wow
03:50:40 <dramforever> mniip: wow wow wow
03:51:40 <mniip> or if you can handle recursion,
03:51:41 <mniip> replicateM n xs = liftM (:) xs (replicateM (n - 1) xs)
03:52:21 <mniip> to replicateM n x, pick an element from x, then pick a tail from replicateM (n - 1) x, and return their cons
03:52:24 <dramforever> you mean liftM2
03:52:29 <mniip> yes liftM2
03:53:14 <dramforever> that would be very understandable for anyone who understands recursion
03:53:24 <dramforever> d/very/
03:53:48 <mniip> the main idea with this understanding of monads is that not everyone's intuition can imagine, say, (e ->) as a container
03:53:56 <mniip> the main problem*
03:54:05 <dramforever> s -> (a, s)
03:54:14 <dramforever> oh maybe the wrong order
03:55:56 <mniip> it's a container indexed by the state, returning the new state alongside the containee
03:56:21 <dramforever> yeah, but not everyone can understand that
03:56:53 <mniip> IO is harder :P
03:57:12 <dramforever> maybe
03:58:06 <mniip> dramforever, anyway
03:58:23 <mniip> I've only used join in instances of complex transformerlike monads
03:58:52 <mniip> where you have a type, and a requires result type, and you compose functions until the type matches
03:58:57 <mniip> and it works automagically
03:59:01 <mniip> required*
03:59:42 <dramforever> isn't that how you are supposed to write haskell?
03:59:54 <mniip> haha
04:07:45 * hackagebot gtksourceview3 0.13.1.4 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview3-0.13.1.4 (HamishMackenzie)
04:46:28 <quchen> I have a question about Hindley-Milner. The Algorithm W rule for inferring the type of lambda abstractions mentions "Γ, x:τ ⊢ …". But Γ contains only σ types, correct? Does x:τ have an implicit τ → σ lifting in there?
04:47:24 <quchen> Where the lifting is of course  τ → ∀∅. τ
04:52:12 <badmash> hey -- have a question -- if someone can help, that would be great.  i have installed haskell platform on my Mac OS X.  basically, haskell platform intalls files and directories under /Library in OSX.  I see that the all installed files have "root" as the owner.  why is root access needed?  can the owner be changed to something with less privelages?  
04:53:44 <ion> If you install files to system directories with a less privileged owner, that means a less privileged user will be able to modify things in a system directory, which would be bad in general.
04:53:58 <ion> Not that it matters much on a single-user desktop system.
05:01:22 <geekosaur> ion: but there are less privileged users that are nevertheless "system" users for this purpose. notably, "bin" is historically the owner of system binaries that don't require root
05:01:42 <saulzar_> Anyone using the haskell packages for atom with haskell-mod-ghc? Know how tell it to use a sandbox somewhere?
05:02:02 <ion> geekosaur: On OSX? (A sincere question, i don’t know about OSX)
05:02:50 <julie-ai> anyone here use halcyon?
05:02:53 <geekosaur> huh. I was actually expecting bin since OS X userspace is largely lifted from freebsd
05:03:06 <geekosaur> but in fact pretty much everything in /usr/bin is root:wheel
05:03:19 <ion> How about /Library?
05:03:51 <geekosaur> same
05:04:00 <safinaskar> why Traversal' is (Applicative f) => ... and not (Monad f) => ...?
05:04:14 <geekosaur> I guess Apple jettisoned bin
05:04:24 <ion> In any case, i parsed badmash’s question as “something with less privileges, such as me” and not “something with less privileges, such as bin”.
05:04:27 <geekosaur> safinaskar, because it doesn't need Monad?
05:04:28 <badmash> geekosaur: ion: yeah, iam wondering why it needs root access in os x
05:04:35 <geekosaur> er?
05:04:38 <ion> safinaskar: Applicative gives the appropriate amount of power for traversals.
05:04:42 <geekosaur> being owned by root does not grant root access
05:05:03 <badmash> ion: you are correctly understood what i said. 
05:05:05 <geekosaur> unless it also has the setuid bit
05:05:14 <geekosaur> (which only things like su do)
05:05:16 <ion> badmash: Only the installation to /Library needs root access, not usage.
05:06:16 <badmash> ion: well, i mean that all owners inside /Libary are set as root
05:06:24 <geekosaur> and?
05:06:36 <badmash> is that really needed? i am wondering why?
05:06:37 <ion> badmash: If you ls -l the file, you should see rwxr-xr-x or rwxrwxr-x. The final r-x applies to you (not being root or in wheel). You will be able to read and execute the file, but not write into it.
05:06:48 <geekosaur> because Apple decided to do it that way
05:06:53 <ion> badmash: So that random users don’t get to write into /Library without root access.
05:07:05 <safinaskar> please give me some example where we substitute some Applicative and not Monad into "f" in Traversal' and get something useful
05:07:05 <badmash> i see
05:07:07 <echo-area> Hi, is `haskell-hoogle' in haskell-mode only able to show the first search result of a query, instead of the matching one?
05:07:11 <geekosaur> (you said /Library not /Library/Haskell; only the latter is under control of the HP installer)
05:07:27 <safinaskar> i can imagine we put "IO" instead of "f", but i cannot imagine any non-Monad Applicative
05:07:46 <badmash> i mean files and directories under /Library/Haskell have root ownership
05:07:48 <ion> safinaskar: traverse f Nothing = pure Nothing; traverse f (Just x) = Just <$> f x
05:07:53 <geekosaur> list? (traverse is generalized map)
05:08:21 <geekosaur> badmash, the rest of /Library is also owned by root
05:08:34 <ion> safinaskar: The Applicative constraint doesn’t mean it can’t be a Monad, it only means it must be at least Applicative.
05:08:35 <geekosaur> it's how Apple does things
05:08:43 <badmash> geekosaur: i see
05:09:15 <ion> safinaskar: ZipList is a non-Monad Applicative.
05:12:52 <echo-area> I see that it just invokes hoogle for its job, using only the name at point and not prefixing it with any qualifiers.  So I assume it's all hoogle can provide, right?
05:14:14 <badmash> geekosaur: i have a question -- the haskell platform symlinks binaries to /usr/bin in OS X. these symlinks have root ownership.  i moved these symlinks out of /usr/bin and into /usr/local/bin, because i din't want to mess around with /usr/bin.  now after the move into /usr/local/bin, these symlinks still have root ownership.  is root ownership really needed for these symlinks in /usr/loca/bin, because most of other 
05:14:15 <badmash> stuff there, for example installed by homebrew, don't have root ownership.  so my question is -- can these symlinks be set with an owner other than root? i am just wondering ...
05:15:08 <ion> badmash: The uninstaller will know to remove the symlinks it installed into /usr/bin but not the ones you put into /usr/local/bin.
05:15:16 <geekosaur> they can be, yes. note that moving them will cause issues if you ever repair permissions, because the installer package says they should be in /usr/bin and so they will be reported as missing/broken
05:16:10 <badmash> ion: geekosaur: everything works fine so far -- after the move to /usr/local/bin
05:16:11 <geekosaur> (doing a repair permissions periodically is a good idea, in general; even apple's own packages and updates can screw up permissions in ways that cause odd failures)
05:16:22 <ion> The Haskell Platform should really use the system package manager instead of putting things into /Library and /usr/bin manually and hopefully having an uninstaller script that works correctly. Oh, wait, OSX doesn’t have a system package manager.
05:17:48 * hackagebot cipher-aes 0.2.11 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.11 (VincentHanquez)
05:18:00 <geekosaur> it has a package manager, just not a very good one. and I'm pretty sure HP is an mpkg
05:18:01 <badmash> geekosaur: as far as i can tell (I MIGHT BE WRONG), the installer checks both /usr/bin and /usr/local/bin
05:18:02 <echo-area> I see that it just invokes hoogle for its job, using only the name at point and not prefixing it with the package.  So I assume it's all hoogle can provide, right?  E.g. to display the doc of a rather wanted function I need to do M-x haskell-hoogle RET Data.Text.IO.readFile RET
05:18:35 <geekosaur> badmash, I don't see what you mean by that except that possibly you are confused about what does what
05:18:46 <ion> geekosaur: It does? In that case, moving files installed by it is even more wrong.
05:19:04 <geekosaur> that is WHY I warned that moving the symlinks breaks Repair Permissions
05:19:26 <geekosaur> because that uses the package receipts to determine what files to check and what permissions etc. to verify / repair
05:20:02 <geekosaur> look under /var/db/receipts sometime
05:20:25 <geekosaur> also: man pkgutil
05:20:57 <geekosaur> the main problem with the package management is it doesn't record enough information to safely remove packages
05:21:38 <geekosaur> or have things like pre-remove scripts that can deactivate daemons or etc. before removal
05:21:55 <ion> Huh
05:22:43 <safinaskar> geekosaur: "list?" - i can imagine list is monad
05:22:58 <geekosaur> safinaskar, map does not care that list is a monad
05:23:15 <geekosaur> maybe you are under the impression that traverse is mapM?
05:23:17 <geekosaur> it's just map
05:24:38 <badmash> geekosaur: i see.  i am just experimenting with stuff at this point, so perhaps i must have gotten this stuff wrong.  but after i have moved the symlinks to /usr/local/bin, vereything works fine.  haven't tried to run the uninstall script. i am wondering -- after all, these are all symlinks.  the actual binaries are in /Library/Haskell, where the installer has put them. so i am not seeing how the symlinks move would
05:24:38 <badmash>  pose much problems.  just wondering
05:24:56 <geekosaur> yes, that's got nothing to do with package management, just with $PATH
05:25:13 <geekosaur> I take it you never run repair permissions, just let the system decay until it breaks and go buy a new one?
05:26:12 <badmash> geekosaur: i haven't done repair permissions so far :)
05:26:25 <hodapp> I prefer the American way, in which you throw it away before it breaks, except for things that *actually* matter, like outdated policies and economic views.
05:27:10 <geekosaur> and symlinks would only break if they were relative (that is, ghc -> ../../Library/Haskell/... instead of ghc -> /Library/Haskell/...)
05:27:21 <echo-area> Second question: Is there a way to add haddock for a local project to the hoogle index?
05:27:51 <echo-area> *the document generated by haddock for a local project
05:28:09 <badmash> geekosaur: i have the complete path for symlinks.  symlinks are not relative (fortunately)
05:28:38 <ion> badmash: I’m not sure what you think you’re gaining by moving the symlinks. I only see disadvantages in it.
05:29:48 <geekosaur> as for root vs. nonroot, some people have had their homebrew installs destroyed by errant uninstallers that nuked all of /usr/local because homebrew installs as you instead of as a system user
05:30:14 <geekosaur> so there is a certain protective factor in having stuff owned not-by-you
05:30:51 <badmash> ion: i didn't want a bunch of stuff in /usr/bin.  /usr/bin, i felt, should contain whatever the system (OS X) puts it in -- not wht i install etc.  if you see homebrew, they do the exact same thing.  they don't put anything in /usr/bin.  everything goes in /usr/local/bin and usr/local/lib etc
05:31:16 <ion> badmash: Given that it was installed with a system package manager after all, the system *did* put it in.
05:31:41 <safinaskar> ion: thanks! your ZipList helped me
05:31:48 <ion> And now you’re making the state of things inconsistent with that the system thinks it is.
05:32:28 <safinaskar> thanks everybody. i understand what is lens and traversal!
05:32:49 * hackagebot exherbo-cabal 0.1.0.3 - Exheres generator for cabal packages  http://hackage.haskell.org/package/exherbo-cabal-0.1.0.3 (NikolayOrlyuk)
05:33:12 <ion> safinaskar: Another Applicative non-Monad: <http://hackage.haskell.org/package/async-2.0.2/docs/Control-Concurrent-Async.html#t:Concurrently>. The current Hackage release actually has a broken Monad instance but it is going to be removed in the next release.
05:33:22 <badmash> ion: i see what you are saying.  i am new to this -- i am just reasoning and exploring to understand things better.  i could be very well wrong and foolish.
05:33:50 <geekosaur> I'll tell you what I mentioned to ion a few minutes ago: take a look at pkgutil
05:34:26 <marcusmonteiro> Hey guys
05:34:45 <geekosaur> specifically try pkgutil --file-info on various files from the H-P install (but the symlinks you moved will fail because you moved them and the receipt does not know about the moved ones)]
05:35:37 <marcusmonteiro> I want to write a function that takes an ArithmeticProgression type and returns the sum of it`s elements. How can I create an Arithmetic Progression type?
05:37:07 <marcusmonteiro> I know how to check if a sequence is an arithmetic progression but I don't know how to construct a list that IS an arithmetic progression
05:37:45 <Axman6> have you seen iterate?
05:38:08 <ion> > [2, 4..]
05:38:10 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
05:38:14 <ion> > iterate (+2) 2
05:38:15 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
05:38:37 <[k-> :o
05:38:58 <badmash> geekosaur: i will check it out
05:39:44 <badmash> geekosaur: so if i understand you and ion correctly, my moving the symlinks was not a wise thing to do?
05:40:01 <geekosaur> not the greatest of things to do, again it will cause repair permissions to fail
05:40:17 <badmash> geekosaur: i see
05:40:18 <ion> and it will cause uninstallation not to actually uninstall all of it
05:40:24 <marcusmonteiro> yes, but I want something like this `Arithmethic Progression [2, 4, 6, 8, 10]`
05:40:30 <geekosaur> I don't think installing APple patches currently causes any validation to happen, but it could at some point and then you would get errors installing them
05:40:34 <ion> > [2,4..10]
05:40:36 <lambdabot>  [2,4,6,8,10]
05:41:15 <ion> > (takeWhile (<= 10) . iterate (+2)) 2
05:41:17 <lambdabot>  [2,4,6,8,10]
05:41:19 <geekosaur> because, from the standpoint of the package database, the package is broken because the /usr/bin symlinks are no longer there
05:41:22 <marcusmonteiro> sorry, `ArithmethicProgression [2, 4, 6, 8, 10]`
05:41:39 <badmash> geekosaur: i see
05:41:48 <marcusmonteiro> so the function doesn't need to check that the list is in fact an arithmetic progression before summing it
05:42:04 <geekosaur> it will still work but it won't verify
05:42:05 <badmash> geekosaur: yeah, what yo say makes sense now.  wonder why i didn't think about it before
05:42:08 <bennofs> Is there a library for "extensible" (generic-friendly) tuples (defines a data type like data a :& b = a :& b and associated accessor functions)
05:42:13 <bennofs> ?
05:42:36 <geekosaur> bennofs, how does that differ from HList?
05:42:49 * hackagebot optparse-declarative 0.1.0 - Declarative command line option parser  http://hackage.haskell.org/package/optparse-declarative-0.1.0 (HideyukiTanaka)
05:42:51 <echo-area> So it is `hoogle convert'
05:43:15 <bennofs> geekosaur: hmm, i'd like a library that is easier and doesn't do so much type level programming that is hard to understand
05:43:15 <ion> marcusmonteiro: You could have data ArithmeticProgression n = ArithmeticProgression n n n representing the parameters of the progression, or newtype ArithmeticProgression n = ArithmeticProgression [n] where you don’t export the constructor and only export a smart constructor that generates the right kind of list. The former would probably be better. You can also compute the sum in a closed form from the
05:43:17 <ion> former.
05:43:38 <echo-area> Then use `hoogle search -d ....' but I haven't figured out where is HOOGLEDB for me yet.
05:43:54 <geekosaur> I don;t think you can have a generic extensible tuple without either fixing all the elements to the same type or using hairy type level stuff
05:44:31 <geekosaur> and of course if you fix all the elements to the same type, you're just reinventing lists
05:44:49 <badmash> geekosaur: thanks for advice.  i learned something from my mistakes today.
05:44:58 <ion> bennofs: Here’s a tiny library: http://hackage.haskell.org/package/hvect-0.1.0.0/docs/Data-HVect.html
05:45:02 <badmash> ion: thanks much for your inputs
05:45:07 <marcusmonteiro> ion: thanks. could you give me an example? I'm a beginner
05:45:50 <ion> @let data ArithmeticProgression n = ArithmeticProgression n n n deriving Show
05:45:51 <lambdabot>  Defined.
05:46:19 <echo-area> Do you often add local documents to HOOGLEDB?  (Assuming anyone actually is reading my questions)
05:46:25 <ion> > let apToList :: ArithmeticProgression n -> [n]; apToList (ArithmeticProgression a b c) = [a, (a+b) .. c] in apToList (ArithmeticProgression 2 2 10)
05:46:27 <lambdabot>      Could not deduce (Enum n1)
05:46:27 <lambdabot>        arising from the arithmetic sequence ‘a, (a + b) .. c’
05:46:27 <lambdabot>      from the context (Num n)
05:46:55 <ion> > let apToList :: (Enum n, Num n) => ArithmeticProgression n -> [n]; apToList (ArithmeticProgression a b c) = [a, (a+b) .. c] in apToList (ArithmeticProgression 2 2 10)
05:46:57 <lambdabot>  [2,4,6,8,10]
05:47:59 <bennofs> ion: that looks ok, thanks. I just noticed that I need to make a newtype anyway, since I need to define instances which would otherwise be orphan so I can just as well define my own data type
05:48:10 <quazimodo> beep boop
05:50:30 <marcusmonteiro> ion: thank you sir
05:50:43 <marcusmonteiro> lambdabot: thank you sir
05:52:28 <ion> @undefine
05:52:28 <lambdabot> Undefined.
05:52:40 <ion> @let data ArithmeticProgression n = ArithmeticProgression n n Int deriving Show
05:52:41 <lambdabot>  Defined.
05:52:58 <ion> @check let apToList (ArithmeticProgression a b n) = (take n . iterate (+b)) a; apSum (ArithmeticProgression a b n) | n <= 0 = 0 | otherwise = n*(a + a+(n-1)*b) `quot` 2 in \a b n -> sum (apToList (ArithmeticProgression a b n)) == apSum (ArithmeticProgression a b n)
05:52:59 <lambdabot>  +++ OK, passed 100 tests.
05:55:05 <ion> FWIW, lambdabot is a she
05:58:04 <bennofs> How bad are overlapping instances when used like this: class C a where ...;  data T a b = ...; instance C b => C (T a b) where ...; instance C b where ...;
05:58:07 <bennofs> in a library?
06:05:24 <Cale> bennofs: You should always avoid having an instance which applies to every type.
06:06:14 <bennofs> Cale: why is that? does this still apply if I know that there are no useful instances for any other type?
06:07:49 <Cale> Well, if there are no other useful instances, why not just define two functions?
06:08:49 <bennofs> Cale: It's for type-level programming. I'm trying to encode a function signature for an FFI-like interface (there are only two instances: FunctionSignature (a -> b) and FunctionSignature b)
06:10:25 <bennofs> Or rather, function arguments. I have a type data AddFunArg a b = a :& b and then class FunctionArguments args where callFunction :: args -> ... and instance FunctionArguments b => FunctionArguments (AddFunArg a b) and instance FunctionArguments b 
06:10:46 <Cale> Do the instances you have actually work with just OverlappingInstances?
06:13:11 <bennofs> Cale: oh, it also seems to require flexibleinstances
06:13:50 <Cale> Well, if it works for you, it works for you :)
06:15:30 <Cale> You might want to do something to ensure that future modules really can't define new instances
06:16:29 <bennofs> hmm, I could also just use closed type families
06:20:25 <Cale> bennofs: That sounds like a better idea :)
06:22:51 * hackagebot apache-md5 0.6.1.4 - Apache specific MD5 digest algorighm.  http://hackage.haskell.org/package/apache-md5-0.6.1.4 (PeterTrsko)
06:30:40 <liste> are there any gotchas when using evil with haskell-mode?
06:31:02 <liste> I consider switching from vim
06:31:13 <ion> IIRC https://github.com/syl20bnr/spacemacs has something for evil+haskell-mode integration.
06:31:19 <ion> I have been meaning to try it one day.
06:34:23 <liste> thanks (:
06:36:48 <liste> neco-ghc+syntastic work well enough but haskell-mode has so many goodies
06:41:25 <joco42_> Is there a repl for ghcjs ? 
06:41:34 <joco42_> ghcjsi ?
06:42:12 <joco42_> ohh there is one !
06:42:46 <joco42_> in try-reflex... but it does not work...
06:44:05 <joco42_> http://pastebin.com/2iUFckjJ
06:45:46 <Geraldus_> hi friends!
06:46:00 <maerwald> Geraldus_: hello my friend
06:46:36 <Geraldus_> If I omit qualified keyword, what means `import Data.Text as T` in this case? Import Text qualified and unqualified, isn't it?
06:47:12 <dramforever> yes
06:47:23 <Geraldus> ok, thanks (:
06:47:52 * hackagebot leksah-server 0.15.0.3 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.15.0.3 (HamishMackenzie)
06:47:54 * hackagebot leksah 0.15.0.4 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.15.0.4 (HamishMackenzie)
06:48:21 <geekosaur> that looks more like there isn't one but nix thinks there is?
06:48:33 <geekosaur> i.e. someone copied the ghc stuff and didn't update it
06:48:56 <safinaskar> do { s <- getLine; putStr $ show (product [1::Int .. read s]) ++ "\n"; }
06:49:18 <safinaskar> can i be sure that this code is as fast as this C code: http://paste.debian.net/248734/ ?
06:50:23 <safinaskar> i. e. can i be sure that haskell compiler will eliminate list and will directly produce sequenced numbers and multiply them without temporary list?
06:51:01 <arkeet> not without optimizations, and then at least you should check core
06:52:12 <safinaskar> arkeet: what is this core?
06:52:41 <arkeet> ghc -ddump-simpl 
06:52:48 <arkeet> (or https://hackage.haskell.org/package/ghc-core)
07:01:35 <ion> bennofs: Sigh, i can’t find the talk i have watched that had a nice example of a solution for the overlapping base instance problem that still used classes but took advantage of closed type families IIRC.
07:02:09 <bennofs> ion: I know how to do it with closed type families
07:02:16 <bennofs> but it's ugly :|
07:02:38 <ion> The solution he had was pretty IIRC.
07:02:52 <ion> Too bad i can’t remember what the talk was actually about at all.
07:03:06 <ion> And i fail to find it in my Youtube history.
07:03:10 <bennofs> My solutions requires 1 TF, 2 classes and one of those classes needs an equality constraint
07:06:36 <bennofs> ion: 'class Dispatch isA b ...; instance a ~ A => Dispatch 'True a where ...; instance Dispatch 'False a where ...'
07:06:37 <chpatrick1> univ :: Fold a a -> Fold a a
07:06:38 <chpatrick1> univ fld f = fld $ \x -> f x *> univ fld f x
07:06:42 <chpatrick1> is this built in somewhere?
07:07:00 <chpatrick1> I know there's universeOf but it also does toListOf
07:09:20 <bennofs> chpatrick1: this is like a depth first traversal?
07:09:34 <chpatrick1> bennofs: yes
07:09:49 <bennofs> :t deepOf
07:09:50 <lambdabot> (Applicative f, Conjoined p) => LensLike f s t s t -> Traversing p f s t a b -> Over p f s t a b
07:10:04 <chpatrick1> ah cheers
07:10:17 <bennofs> chpatrick1: hmm, not sure if that does what you want, just needed to know the type :P
07:11:29 <bennofs> ah no, it doesn't do that
07:11:48 <chpatrick1> are you sure?
07:12:16 <bennofs> chpatrick1: yes. if the second argument returns any results, it immediately returns and does not recurse
07:12:32 <chpatrick1> hmm weird
07:12:53 * hackagebot gtksourceview3 0.13.1.5 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview3-0.13.1.5 (HamishMackenzie)
07:12:54 <chpatrick1> so it's more like for finding something
07:12:55 * hackagebot DAV 1.0.6 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-1.0.6 (ClintAdams)
07:12:59 <chpatrick1> rather than iterating over everything
07:13:11 <bennofs> chpatrick1: yes :)
07:13:50 <chpatrick1> why do you think universeOf is specialized to lists?
07:13:54 <chpatrick1> just uniplate compatibility?
07:13:56 <bennofs> chpatrick1: probably since it'
07:14:19 <bennofs> chpatrick1: yeah, that could be. You can also always convert (x -> [a]) to Fold x a with folding
07:14:22 <bennofs> :t folding
07:14:23 <lambdabot> (Applicative g, Foldable f, Contravariant g) => (s -> f a) -> LensLike g s t a b
07:14:47 <chpatrick1> then it depends on list fusion to be efficient though
07:14:55 <chpatrick1> I don't think universeOf is a good producer
07:17:29 <bennofs> chpatrick1: ok, in #haskell-lens it was said that it's for api-compat with uniplate
07:17:51 <chpatrick1> ah, probably should've asked there :P
07:17:59 <chpatrick1> did they say if univ exists?
07:18:12 <bennofs> chpatrick1: haven't asked but you can join yourself :p
07:18:15 <chpatrick1> ok
07:22:48 * badmash
07:22:53 * hackagebot cryptonite 0.5 - Cryptography Primitives sink  http://hackage.haskell.org/package/cryptonite-0.5 (VincentHanquez)
07:23:37 <badmash> hello
07:25:46 <safinaskar> arkeet: "ghc -O10 -ddump-simpl" contains Data.List.product_$sproduct1, so, I think lists still present in this code
07:29:20 <safinaskar> arkeet: same for ghc-core
07:29:38 <safinaskar> arkeet: i. e. ghc-core shows product, too
07:31:03 <safinaskar> arkeet: asm output shows Data.List.product_$sproduct1_info, $[]_closure+1, etc. so, bad
07:31:23 <bennofs> safinaskar: btw, -O2 is max for ghc :)
07:31:42 <safinaskar> arkeet: so, haskell is slow. it is really slower than c. and this is bad
07:32:19 <rofer> Is there a word for types that only have a single value like unit?
07:33:04 <hodapp> safinaskar: er, first question, what actual performance do you *need* for your application?
07:34:48 <bennofs> safinaskar: what version of ghc did you use?
07:35:14 <bennofs> safinaskar: the list is eliminated with GHC 7.10
07:37:23 <bennofs> safinaskar: same happens with GHC 7.8.4
07:38:39 <bennofs> safinaskar: but it's still true that haskell is not exactly as fast as c, but you can get close
07:40:36 <bennofs> safinaskar: even GHC 7.6.3 eliminates the list in my tests
07:41:43 <bennofs> oh hmm, that GHC 7.6.3 might not be true
07:42:20 <definity> With this example http://pastie.org/10251562 In the second line does the n relate to the 'Num i' and the _ which i belive means any amount of input after the 'Num i' relate to the 'Ord i'?
07:43:20 <scutigera> no _ means don't care which is a match anything
07:43:28 <arkeet> the n is the argument of type i
07:43:33 <arkeet> the _ is the argument of type [a]
07:43:39 <arkeet> (which we ignore)
07:43:56 <scutigera> that's a much better explanation.
07:44:21 <arkeet> the stuff to the left of => is just for constraints on types
07:44:27 <arkeet> (i must be an instance of both Num and Ord)
07:45:06 <definity> ahh so like multiple inheritance
07:45:08 <definity> ?
07:45:23 <arkeet> type classes are kind of like interfaces in certain OO langs
07:46:17 <definity> But interfaces with behaviour?
07:47:20 <rom1504> what does "behaviour" mean
07:49:12 <definity> acts like
07:50:28 <arw> iirc certain OO languages defining partially implemented interfaces. (other than e.g. java which only allows declarations as interfaces)
07:50:44 <arw> s/defining/allow defining/
07:50:50 <definity> Okay
07:51:21 <guardianx> gu
07:52:38 <icicled> arw, java now allows partially implemented interfaces
08:01:13 <hodapp> I sort of gave up on waiting for Java to get reasonable features
08:02:54 * hackagebot leksah 0.15.0.5 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.15.0.5 (HamishMackenzie)
08:03:49 <safinaskar> rofer: "Is there a word for types that only have a single value like unit?" - yes, they called unit types. and canonical unit type is ()
08:03:54 <arw> icicled: ah, ok. i've learned java back in the 1.5 or 1.6 days and didn't use it since.
08:04:34 <rofer> safinaskar: Thanks!
08:04:53 <icicled> hodapp, same here - the things you have to jump through to do a simple networked application is just nuts
08:04:53 <joco42_> does anyone know what is the easiest way to get leksay+ghcjs up and running ? what ghc version ? I tried 7.10.1 but I could not get ghcjs working....
08:05:18 <icicled> what's the convention around where to place language extensions? In each file or is it ok to place in the build file?
08:05:47 <joco42_> *leksay correction = leksah
08:06:23 <joco42_> I also tried leksah in nix os with latest unstable but it failed...
08:07:24 <hamishmack> joco42_: If you have 16GB of disk sace to spare it would be great if you could test this… https://github.com/leksah/leksah/tree/master/xob
08:07:41 <joco42_> hamishmack: thanks!
08:08:04 <joco42_> hamishmack: that is exactly what i was looking for !
08:08:15 <safinaskar> hodapp: "what actual performance do you *need* for your application?" - currently i am insteresting in one theoretical question: is there any language in universe that allows short abstract expressions like "product [1 .. n]" (n is unknown at compile-time) and still has C-like performance, i. e. computes this product using trivial assemply loop with one conditional jump instruction and no unconditional
08:08:17 <hamishmack> Its not well tested
08:08:21 <safinaskar>  jumps and, of course, without lists/arrays. it seems there is no simple way to do this in C and C++. and, as i guessed just now, haskell will not go, too
08:08:37 <rydgel> Are you guys aware of linking binaries problem regression with GHC 7.10?
08:08:50 <rydgel> GLUT is giving me a hard time
08:08:50 <safinaskar> bennofs: ghc 7.8.3 (ships with latest haskell platform)
08:08:57 <joco42_> hamishmack: I can test it !
08:08:59 <hamishmack> If you have a HiDPI display then you might find it a bit slow
08:09:15 <bennofs> safinaskar: so I just compiled main =  do { s <- getLine; putStr $ show (product [1::Int .. read s]) ++ "\n"; }
08:09:28 <bennofs> safinaskar: with ghc -O2 -ddump-simpl
08:09:38 <hamishmack> virtual box 5 will fix that, but it is not supported by vagrant yet
08:09:54 <joco42_> hamishmack: I have a linux server with vnc.
08:09:56 <bennofs> safinaskar: (ghc -O2 -ddump-simpl -fforce-recomp -dsuppress-all ./test.hs) is the exact command
08:10:17 <joco42_> hamishmack: It has all sorts of VMs on it.
08:10:42 <bennofs> safinaskar: and yes, I get a call `case product_$sproduct1 (eftInt 1 y_a1xL) of _ { I# ww3_a2wP ->`
08:10:53 <joco42_> hamishmack: virtualbox 4.3.28
08:10:56 <bennofs> safinaskar: but notice that the result of this call is an Int, not a list
08:11:01 <hamishmack> Perfect
08:11:17 <joco42_> hamishmack: I try this. Thanks.
08:11:25 <bennofs> safinaskar: oops sorry, I completely misread the core
08:11:30 <bennofs> safinaskar: ofc you are right :(
08:12:27 <bennofs> safinaskar: but GHC 7.10 does remove the list :)
08:16:18 <statusfa1led> How do you round a Data.Time UTCTime to the nearest hour/day/minute etc. ?
08:18:13 <GLM> Is it possible to have a Just Nothing?
08:18:18 <statusfailed> GLM: yes
08:18:26 <statusfailed> > Just Nothing
08:18:27 <lambdabot>  Just Nothing
08:18:31 <statusfailed> :t Just Nothing
08:18:32 <lambdabot> Maybe (Maybe a)
08:19:49 <bananagram> :t join (Just Nothing)
08:19:50 <lambdabot> Maybe a
08:19:56 <scutigera> any attoparsec experts ?
08:20:44 <statusfailed> scutigera: ask the question anyway :-)
08:20:59 <scutigera> i have  line 999 999 etc..
08:21:03 <GLM> statusfailed:Wouldn't that lead to a lot of nasty stuff like trying to call fmap on it?
08:21:03 <scutigera> parses just fine
08:21:17 <scutigera> two lines in a row parse fine
08:21:26 <scutigera> but if i do 999 999 999
08:21:29 <scutigera> 999 999 999 a
08:21:41 <scutigera> the second line fails - as it should. but so does the first line !!
08:22:05 <statusfailed> GLM: You can still fmap over a "Just Nothing", it's just that your function has to accept a "Maybe" value
08:22:14 <statusfailed> GLM: what kind of "nasty stuff" are you thinking of?
08:22:34 <GLM> I just tried this
08:22:35 <statusfailed> scutigera: Can you do a paste ?
08:22:37 <GLM> Just (+3) <*> Just Nothing
08:22:43 <GLM> > Just (+3) <*> Just Nothing
08:22:44 <lambdabot>      No instance for (Show a0)
08:22:44 <lambdabot>        arising from a use of ‘show_M67959964307056369024509’
08:22:44 <lambdabot>      The type variable ‘a0’ is ambiguous
08:22:55 * hackagebot schedule-planner 1.0.1.1 - Find the ideal lesson layout  http://hackage.haskell.org/package/schedule-planner-1.0.1.1 (justus)
08:23:05 <scutigera> http://lpaste.net/134909
08:23:20 <lyxia> > Just (+ (3 :: Int)) <*> Nothing
08:23:21 <lambdabot>  Nothing
08:24:38 <GLM> lyxia:What is that operator called?
08:24:39 <scutigera> notice that i'm being careful to match end of line
08:24:46 <joco42_> hamishmack: does this look OK ? http://pastebin.com/5UwW873u
08:25:29 <joco42_> hamishmack: especially the "cannot reconstruct rpm from disk files" errors ?
08:25:29 <statusfailed> GLM: do you mean :: ?
08:25:43 <GLM> statusfailed:No, <*>
08:25:50 <lyxia> GLM: "ap" 
08:26:08 <GLM> Like apply?
08:26:18 <hodapp> safinaskar: that's not really a theoretical question in any sense.
08:26:23 <lyxia> I think that's where it comes from too.
08:26:42 <joco42_> hamishmack: and the "/usr/lib/python2.7/site-packages/urllib3/packages/six.pyo: read error"
08:27:01 <hodapp> safinaskar: something like ATS *might* be able, but I doubt it
08:27:15 <lyxia> GLM: in haskell "ap" is the monadic specialization of <*>
08:27:22 <hamishmack> not sure what that is
08:27:32 <joco42_> hamishmack: and it seems that the install stopped here...
08:27:35 <scutigera> @hoogle (<*>)
08:27:35 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
08:27:48 <joco42_> hamishmack: nothing really happens right now
08:27:58 <GLM> When I call pure, how do I know what kind of functor I'm getting back?
08:28:26 <lyxia> GLM: You generally infer it from the context.
08:28:27 <badmash> hello
08:28:39 <joco42_> hamishmack: how about a simple VirtualBox appliance ?
08:29:12 <joco42_> I can put it into my Google Drive folder, folks can get it from there...
08:29:20 <GLM> lyxia:How so? I could have multiple kinds of functors. I don't know how it'd know which to put it in
08:29:32 <joco42_> hamishmack: compressed, 3 gigs perhaps
08:29:40 <hamishmack> I was hoping to use vagrant to keep something like that up to date
08:29:51 <joco42_> hamishmack: I can see that.
08:29:55 <maerwald> GLM: type inference, what's the problem?
08:30:44 <lyxia> > Just id <*> pure 'A' -- GLM the only possible choice of f in pure 'A' :: f Char here is Maybe.
08:30:46 <lambdabot>  Just 'A'
08:31:11 <joco42_> hamishmack: how about nix - try-reflex style ?
08:31:50 <GLM> What if I have just the line let foo = pure (+) ?
08:32:34 * thermodynmics
08:32:38 <joco42_> hamishmack: I try restarting this install.
08:33:29 <lyxia> GLM: In real code you will be using foo which constrains its type.
08:33:33 <safinaskar> bennofs: how ghc people had right to say "ghc cares about performance" before 7.8.4? how can we say ghc is about performance if "product [1..n]" doesn't compile to trivial assembly loop?
08:33:47 <lyxia> GLM: and if you need foo to be polymorphic you can annotate it.
08:34:26 <GLM> Can applicitive functors only hold functions or regular values as well?
08:34:50 <bennofs> safinaskar: considering how high level haskell code can be, i think ghc does quite well
08:34:52 <monochrom> an applicative functor doesn't "hold" anything.
08:35:13 <ion> GLM: The type parameter to an instance of Applicative can be anything.
08:35:30 <joco42_> hamishmack: http://pastebin.com/BQpMqm7z same errors
08:36:11 <bennofs> safinaskar: you can also try the `vector` package, which IME is more reliable for fusion
08:37:02 <joco42_> hamishmack: best would be to combine try-reflex with try-leksah, so one could try both with one script...
08:37:15 <ion> @type pure ()  -- GLM: For instance, ()
08:37:16 <lambdabot> Applicative f => f ()
08:38:08 <thermodynmics> bennofs: but high level should perform well too.  one of the quirks about learning haskell is that sometimes the simplest of affairs leads to performance issues.  i suppose if you are an haskell expert, this might not really be a problem at all.  but still, haskell performance is a bit of black art.
08:38:11 <joco42_> hamishmack: did this vagrant solution worked for someone else already? i wonder what is going wrong in my setup...
08:38:14 <hamishmack> I was hoping to get wine+ghc too so windows users could use it to make there binaries.  Not sure if nix has wine and mingw
08:38:38 <hamishmack> I have only tested it on OS X so far
08:38:48 <bennofs> thermodynmics: that is right. if you're writing something where you need to get the very last 1% of performance, 
08:38:49 <joco42_> ok, I can test it on osx too.
08:39:03 <joco42_> hamishmack: retina...
08:39:09 <bennofs> thermodynmics: then haskell might not be the right choice
08:39:11 <hamishmack> and not for a week or so
08:39:33 <ion> You probably missed this line to network issues: <ion> joco42: I should try to visit one of your meetups.
08:39:38 <bennofs> thermodynmics: but in practice it performs well enough for most cases
08:39:40 <joco42_> hamishmack: i can give it a try, it would be cool
08:39:48 <joco42_> to get it runnign
08:40:05 <hamishmack> after you get it working you can fix the retina issue by upgrading to virtual box 5 RC 1
08:40:21 <hamishmack> and reinstalling the virtual box guest tools
08:40:26 <thermodynmics> bennofs: but reasoning about haskell performance is still a black art -- at least for many people
08:40:37 <joco42_> hamishmack: cool, i try that, but first things first...
08:41:47 <thermodynmics> bennofs: you suddenly see huge rises in memory consumption, stack traces are a problem etc ..
08:42:35 <thermodynmics> bennofs: haskell is a beautiful language and i love it.  but just this bit sometimes can become scary.
08:42:37 <doomlord> lazy evaluation is harder to reason about ?
08:42:50 <bennofs> thermodynmics: I found that profiling memory usage by type often gives a very good idea what is taking up the memory
08:43:35 <thermodynmics> bennofs: yes, you are right.  but a good book on haskell performance is badly needed.
08:43:56 <monochrom> I hear people reporting that Netscape and Firefox keep leaking memory. perhaps they are written in Haskell, too.
08:44:30 <hodapp> thermodynmics: you've looked and simply no books exist on the topic?
08:44:38 <rofer> In the default HLint hints file there's a function isLitInt I'm trying to understand, but I have no idea where it's defined.
08:45:02 <rofer> I looked at the imports which all seem to be from the standard library, but Hoogle doesn't seem to know about it
08:45:45 <thermodynmics> hodapp: yes, at least as far as i can tell.  and people who use haskell in production have written about the scary battles sometimes they had to face, without having any idea what the heck can be done. 
08:45:47 <joco42_> hamishmack: something starts to happen on my linux machine... installation wise... 
08:46:56 <hamishmack> joco42_: I just pushed a change that makes it easier to change the VBOXVER.
08:47:04 <srhb> rofer: Good question. A short search shows it only in ajhc/jhc things, but perhaps it's generated from TH?
08:47:23 <hamishmack> There is a patch for vagrant to make it work with 5.0 RC 1
08:47:33 <hamishmack> I am going to try it out here
08:47:50 <joco42_> hamishmack: cool
08:47:51 <rofer> srhb: Yeah, my best guess is it's a TH thing, but I have little idea how TH works or how to find out more about this function
08:48:49 <joco42_> hamishmack: I try it out on OSX too, just to be on the safe side...e
08:52:23 <shachaf> rofer: It's an hlint thing.
08:52:29 <shachaf> That file doesn't look like a real Haskell file.
08:52:57 <shachaf> rofer: Look at src/Hint/Match.hs , isType
08:53:06 <rofer> Perfect, was just about to ask that.
08:53:32 <shachaf> (Brought to you by git log -S.)
08:55:41 <rofer> shachaf: How's that work?
08:56:07 <shachaf> git log -Sfoo shows you all the commits that changed the number of occurrences of foo in the repository, or something like that.
08:56:22 <shachaf> So you can see where it was added.
08:56:42 <rofer> Aha! Thanks.
08:57:32 <rofer> Always nice to know how to figure this out myself.
09:03:48 <hamishmack> joco42_: I got those same errors on OS X.  It is possible I just had not noticed them before.
09:16:57 <joco42_> hamishmack: good to know, thanks
09:17:22 <rydgel> Wanted to have fun with Haskell, ended up spending all day trying to build a package with Cabal.
09:17:41 <statusfailed> How do I round a Data.Time.UTCTime to the nearest hour?
09:23:34 <lyxia> statusfailed: the second field utcDayTime :: DiffTime is a RealFrac which you can use to round.
09:35:49 <rydgel> Any idea on this guys: http://stackoverflow.com/questions/30825272/haskell-gloss-example-error-w-glut-dynamic-library-symbol-not-found-glutbitm ?
09:37:28 <geekosaur> 7.10.1 bug, IIRC
09:37:40 <geekosaur> 7.10.2 release candidate just dropped
09:39:04 <geekosaur> (short explanation: when 7.10.1 links a shared object, it doesn't link in that object's dependencies so symbols from those dependencies fail to resolve)
09:47:05 <mniip> so wait
09:47:32 <mniip> curry-howard correspondence is a correspondence between logical statements and type inhabitance?
09:55:45 <joco42_> hamishmack: current status : "==> default: Building leksah-0.15.0.5... " ... hmmm promising !
09:56:47 <nshepperd> types <=> statements, inhabitants <=> proofs, I though
09:59:59 <GLM> Is a monoid a type or a pair of operation and type?
10:00:57 <lyxia> GLM: I'd say the latter.
10:01:31 <GLM> That's what I thought but learn you a Haskell says the type is the monoid
10:01:34 <lyxia> But we often just say "<type> is a monoid" when the operations are obvious fro context.
10:01:56 <lyxia> and in Haskell we have typeclasses anyway.
10:01:58 <GLM> Makes sense
10:03:30 <joco42_> hamishmack: this virtualbox 5 + vagrant gives this error on OSX : http://pastebin.com/hrQHTPGM , does it work for you ?
10:03:56 <argent0> Hello! In http://lpaste.net/134911, why can't I define applyCommand with type Menu a -> MenuCommand -> Menu b
10:03:59 <argent0> ?
10:04:00 <muzzle> is there a name for the <*> operator ?
10:04:12 <lyxia> :t ap
10:04:13 <ion> muzzle: It’s pronounced “ap”.
10:04:13 <lambdabot> Monad m => m (a -> b) -> m a -> m b
10:04:57 <muzzle> ion: thx
10:05:02 <ion> muzzle: The thing named “ap” in Control.Monad is equivalent but is implemented in terms of Monad.
10:05:34 <hamishmack> joco42_: https://github.com/mitchellh/vagrant/issues/5572#issuecomment-93250550
10:05:37 <lyxia> argent0: ManMenu has type Menu MenuMain which can not generalize to Menu b
10:05:47 <bucaran> not trying to get a full explanation here, but how is a simple performance (start = now(); do something; print now()-start) would work in a FP language or haskell?
10:06:30 <c_wraith> bucaran: you write code that describes when to do each thing.  The runtime system makes sure it does those things in the order you specify.
10:06:33 <lyxia> argent0: type variables are always universally quantified
10:07:06 <hamishmack> joco42_: I modified the file in /opt/vagrant/embedded/gems/gems/vagrant-1.7.2/plugins/providers/virtualbox as described in that comment
10:07:35 <hamishmack> joco42_: s/file/files
10:08:11 <bucaran> @c_wraith anything else you can add that? too difficult to figure out with only that in my current state
10:08:12 <lambdabot> Unknown command, try @list
10:08:20 <c_wraith> bucaran: the big difference between haskell and basically any other language you've used, is that haskell separates "evaluating expressions" and "executing IO"
10:08:27 <bucaran> I think I get u, but I am still too hopeless
10:09:19 <c_wraith> bucaran: in Haskell, you write expressions that describe the IO you want to perform. Those expressions produce values of the IO type. The runtime system picks an IO value (the one named main in your main module) and executes it.
10:10:38 <edgyobject> I want to filter this feed so that only items with content that includes a url with the keyword /user/ show up
10:10:48 <edgyobject> http://page2rss.com/rss/9a8606f37d2a509b7dcf7e853002ec78
10:11:42 <hamishmack> joco42_: Once vagrant up finishes make sure you turn on “Use unscaled HiDPI Output” support in the Display settings for the VM
10:12:27 <hamishmack> makes it retina res and much faster
10:12:38 <argent0> lyxia: Ok, thanks for the help
10:12:54 <c_wraith> bucaran: Creating IO values ends up *looking* pretty similar to programs in other languages, though.  http://lpaste.net/134912 for instance
10:13:02 * hackagebot tubes 0.2.2.1 - Effectful, iteratee-inspired stream processing based on a  free monad.  http://hackage.haskell.org/package/tubes-0.2.2.1 (gatlin)
10:13:50 <joco42_> hamishmack: I was away for a second. Thank you for the support, I will try that.
10:15:04 <hamishmack> joco42_: I have to go to bed, but let me now how you get on.
10:15:06 <rasen_> Hello, guys! Can I run Haskell function from C without pulling all Haskell runtime?
10:15:36 <ion> rasen: I’m not sure how the function is supposed to execute without the runtime.
10:15:37 <rasen_> I just want to exploit stream fustion for computations and all haskell runtime is too much overhead
10:15:38 <c_wraith> rasen_: not with GHC.
10:15:54 <c_wraith> rasen_: a compiler like jhc might be more cooperative
10:16:12 <c_wraith> rasen_: but I'm not sure it has all the fun fusion optimizations GHC does..
10:16:41 <lpaste_> nightfury_vasa pasted “merge sort implementation” at http://lpaste.net/134913
10:16:41 <sdegutis> Are there any decent OCR libraries for Haskell?
10:16:46 <joco42_> hamishmack: me too, soon, yes, I let you know, thanks, tomorrow is workday, so I will try it a little bit more today and tomorrow after work. Keep in touch.
10:18:44 <nightfury_vasa> can anyone please check my merge-sort implementaion : http://lpaste.net/134913
10:19:31 <ion> nightfury_vasa: length needs to traverse the list once.
10:19:44 <rasen_> c_wraith: Thanks for the info. I'll check jhc
10:19:55 <c_wraith> nightfury_vasa: I strong recommend using a bottom-up mergesort instead of top-down.
10:20:07 <c_wraith> nightfury_vasa: it makes so many issues just disappear.
10:20:44 <nightfury_vasa> c_wraith: can you tell me more on how to do that
10:20:54 <c_wraith> ... Why do so many instructional resources (books, teachers, etc) only teach top-down mergesort?
10:21:19 <lpaste_> jmcarthur pasted “Reflection without remorse without free categories” at http://lpaste.net/134914
10:21:47 <jmcarthur> ^^ that's my discovery for today. figured i'd share it before i drop it.
10:21:53 <rasen_> c_wraith: hmm... Standard Extensions: ... The FFI is almost fully supported except for calling Haskell code from C.
10:22:06 <c_wraith> rasen_: oh, whoops.  heh.
10:22:16 <jmcarthur> i adapted a catenable sequence directly to a free monad instead of going via a free category
10:22:31 <jmcarthur> the implementation i linked is not very fast, but maybe the approach could be made fast
10:22:36 <c_wraith> nightfury_vasa: start at the bottom instead of the top.  break it into lists of length one, then recursive merge adjacent pairs until you have only one list left.
10:23:02 * hackagebot HTTP 4000.2.20 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.20 (GaneshSittampalam)
10:23:48 <nightfury_vasa> c_wraith: i'll try that and get back
10:24:22 <c_wraith> I guess top-down mergesort is something that's easy to demonstrate as an example of divide-and-conquer.  
10:25:17 <nightfury_vasa> c_wraith: yeah, learnt it from clrs
10:25:18 <c_wraith> But it's kind of a bad example of that, since the division structure is somewhat easier to do from the bottom up - especially if you want to optimize by starting with ordered runs.
10:25:26 <jmcarthur> c_wraith: jhc has it's own sort of fusion, due it it having a whole program optimizer
10:25:56 <c_wraith> jmcarthur: yes, but it won't optimize the same things as GHC the same way.  It'll do better in some cases, worse in others.
10:26:02 <jmcarthur> yup
10:31:05 <safinaskar> bennofs: 7.10.1 assembly really contains trivial assembly loop :) (but with two jumps), 7.8.4 - doesn't
10:36:11 <vikaton> is learning C and Haskell at the same time a bad idea?
10:36:17 <bucaran> @c_wraith Thanks! That solution looks just like imperative code lol.
10:36:17 <lambdabot> Unknown command, try @list
10:36:22 <unknownloner> As someone who has no formal math education beyond basic calculus, is there a good place where I can learn more about the mathematical side of haskell?
10:36:37 <unknownloner> It's really interesting to me, but most of the time I have no idea what people are talking about
10:36:53 <jmcarthur> vikaton: i don't think so. they are so different that i can't imagine getting them mixed up.
10:37:50 <RlyDontKnow> vikaton: depends whether you already have prior knowledge in programming imo. starting 2 languages at the same time with no prior experience in any sounds like a bad idea (that's mostly unrelated to C and haskell, though)
10:38:51 <jackhill> unknownloner: maybe books like http://search.library.duke.edu/search?id=DUKE000987517 (_Basic Category Theory for Computer Scientists_)
10:39:04 <jmcarthur> vikaton: ah, yeah, i agree with RlyDontKnow that if you are new to programming then this is probably a bad idea. my answer was assuming you were going to learn two languages at once anyway, and that the question was just about the choice of which two languages, rather than the wisdom of learning two at once at all
10:39:27 <Welkin> does anyone know what's going wrong?
10:39:28 <Welkin> http://lpaste.net/134916
10:39:37 <Welkin> http-streams fails to build
10:41:54 <ion> unknownloner: A nice talk about a facet of it: The Algebra of Algebraic Data Types <https://youtu.be/YScIPA8RbVE>. A couple of topics of interest in which Haskell has something to do with math are category theory and the Curry-Howard isomorphism. Re: the latter, Haskell isn’t that good a theorem prover, though, since bottom is an inhabitant of every type and you can accidentally prove anything with it.
10:43:25 <shachaf> @quote Ints.exist
10:43:25 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
10:43:58 <joco42_> hamishmack: installation started on my Mac using VBox 5 ... let's see... on my linux machine it is still installing...
10:46:13 <mattby> hi, I was wondering if there is a package already defining the And monoid http://lpaste.net/134917 ?
10:47:36 <Taneb> mattby, have you seen Data.Monoid.All?
10:47:53 <Taneb> a -> All has the same monoid instance as your And a
10:47:54 <Taneb> :)
10:48:00 <unknownloner> thanks for the links
10:48:13 <mattby> Taneb: looks good, thank!
10:48:30 <mattby> it was actually stupid to put the monoid instance on the predicate
10:50:01 <joco42_> just noticed, vikaton means in Finnish "without errors/mistakes", vikaton are you from Finland?
10:50:30 <ion> It doesn’t, though. viaton would.
10:53:04 * hackagebot hedis 0.6.8 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.6.8 (FalkoPeters)
10:59:46 <LordBrain> Is there a way to tell cabal to not compile a certain module that is in the source tree?
11:00:09 <ion> Remove it from foo.cabal
11:00:41 <hexagoxel> and don't import it
11:01:49 <LordBrain> hmm
11:02:07 <LordBrain> thing is, i have multiple executables in this cabal file, and i want it included while compiling one, but not the other
11:03:05 <hexagoxel> (conditionally) set buildable=False for one executable (in the .cabal)
11:03:57 <LordBrain> can you point me to documentation on that?
11:04:41 <jmcarthur> LordBrain: you can have multiple source dirs, and use them selectively depending on which executable you are building
11:05:07 <jmcarthur> LordBrain: alternatively, you could put the shared modules into a library in the same project, and have the executable-specific modules in their own source dirs too
11:05:44 <hexagoxel> LordBrain: example for buildable is https://hackage.haskell.org/package/multistate-0.6.0.0/multistate.cabal
11:06:22 <hexagoxel> otherwise please consult the cabal user guide :p
11:11:56 <haskellnewb> hello all
11:12:16 <magneticDuck> hello newb
11:12:17 <haskellnewb> I'm reading http://learnyouahaskell.com/input-and-output#command-line-arguments, but I don't quite see what they're trying to tell me at The reason it has to take a function that returns an I/O action instead of just taking an I/O action to do and then close the file is because the I/O action that we'd pass to it wouldn't know on which file to operate.
11:12:22 <haskellnewb> "The reason it has to take a function that returns an I/O action instead of just taking an I/O action to do and then close the file is because the I/O action that we'd pass to it wouldn't know on which file to operate.
11:13:09 <haskellnewb> are they just saying we need to pass a handle to know what file to address
11:13:39 <ion> yeah
11:14:21 <ion> haskellnewb: You might benefit more from https://github.com/bitemyapp/learnhaskell/blob/master/README.md#how-should-i-learn-haskell than from LYAH: the latter has no exercises.
11:14:45 <definity> Where can i find a list fo all haskells native functions?
11:15:32 <ion> Hoogle for Prelude <http://hoogle.haskell.org/?hoogle=Prelude> and click on the first result (in the base package).
11:15:59 <ion> Assuming you mean the standard module by that.
11:16:12 <definity> ion: Thanks :)
11:18:18 <srhb> The base package might be more relevant, really.
11:18:54 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/release-7-10-1.html#idp5876688 + hoogle :>
11:20:34 <ion> Huh. What does GHC use the xhtml package for?
11:21:30 <MarcelineVQ> no idea, at a blind guess I'd say parsing
11:21:55 <monochrom> historical relic
11:28:05 * hackagebot hyperfunctions 0 - Hyperfunctions  http://hackage.haskell.org/package/hyperfunctions-0 (EdwardKmett)
11:28:19 <JoshieAS> I need some help constructing an applicative functor
11:28:25 <MarcelineVQ> hyperfunctions sounds kind of amazing
11:28:59 <ion> monochrom: A historical relic for what purpose?
11:29:07 <JoshieAS> I have a function that takes an x (Int) and xs ([Int]) and filters that list if (\y -> (y `mod` x == 0))
11:29:08 <unknownloner> idk what hyperfunctions are but I need them
11:29:46 <ion> I should look into them but so far i know that they can be used to implement fusion for zipping lists.
11:30:55 <Iceland_jack> JoshieAS: Something like
11:30:55 <Iceland_jack> :t \x -> filter (\y -> y `mod` x == 0) 
11:30:56 <lambdabot> Integral a => a -> [a] -> [a]
11:31:11 <Welkin> I just installed a bunch of packages in my local package db because I wasn't careful enough to recreate the sandbox after deleting it
11:31:19 <Iceland_jack> > (\x -> filter (\y -> y `mod` x == 0)) 3 [0..]
11:31:20 <lambdabot>  [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,7...
11:31:30 <ion> Welkin: I recommend require-sandbox: True in ~/.cabal/config
11:31:38 <edwardk> MarcelineVQ: =) they are just 'weird'
11:31:47 <Welkin> I never knew about that
11:31:48 <Welkin> thank you ion
11:31:52 <JoshieAS> yeah but now I want to take a list of numbers that each represent that x..
11:32:04 <edwardk> ion: Hyper Bool Bool is also weirdly isomorphic to Natural
11:32:17 <JoshieAS> so if I had a list of [1,3,4] and another list [1..16]...it would run through the second list checking for multiples in each of the first
11:32:34 <edwardk> https://github.com/ekmett/hyperfunctions/blob/master/examples/Cantor.hs#L33
11:33:14 <edwardk> or at least the continuous ones are
11:33:25 <edwardk> which are arguably all the ones you should have =)
11:34:20 <MarcelineVQ> You doing a euler problem JoshieAS?
11:34:54 <JoshieAS> Close, I'm on exercism
11:35:06 <JoshieAS> I saw the problem and I figured an applicative would do just the trick
11:35:38 <MarcelineVQ> neat, exorcism.io? new to me
11:35:41 <Welkin> project euler is best solved on paper using math
11:35:47 <MarcelineVQ> I'm learning haskell by doing euler problems, the mathyness is well suited to it
11:35:53 <Welkin> I'm not familiar with exercism
11:35:57 <Welkin> exorcism*
11:36:29 <ion> exercism*
11:36:51 <ion> (Where did the asterisk notation for typo fixes originate from anyway?)
11:37:02 <MarcelineVQ> ads probably
11:37:03 <JoshieAS> Welkin: It's a portmanteau of Exercise and Exorcism
11:37:22 <MarcelineVQ> Where asterix was a marker for a word suggesting detail at the bottom of the page.
11:37:28 <MarcelineVQ> The detail in this case is a correction
11:37:32 <JoshieAS> MarcelineVQ: I'm enjoying it
11:38:34 <Welkin> MarcelineVQ: I think you are referring to footnotes
11:38:42 <JoshieAS> iceland_jack: how could I apply that function to a list of integers on a list of integers?
11:38:55 <MarcelineVQ> I was referring to ads, footnotes are usually numbered.
11:39:14 <MarcelineVQ> Similar idea though
11:39:36 <monochrom> that theory doesn't fly. in ads, you have two asterisks, not one.
11:39:39 <Welkin> * batteries not included, Accessories sold seperately.
11:39:51 <MarcelineVQ> That depends on your ad I guess
11:40:23 <monochrom> also, "* batteries not included" does *not* replace any of the main text
11:40:53 <Welkin> does anyone know what is with this build error? http://lpaste.net/134916
11:40:56 <MarcelineVQ> maybe for this crowd I should have wrote "Maybe ads" to make it clearer
11:40:58 <Iceland_jack> JoshieAS: Would it return "True" if it's divisible by every element of the list?
11:41:29 <Welkin> somek ind of conflict between bytestring and blaze-builder
11:41:58 <Iceland_jack> If that's the case then you can define 
11:41:58 <Iceland_jack>     divisibleBy :: [Integer] -> Integer -> Bool
11:41:58 <Iceland_jack> such that
11:41:58 <Iceland_jack>     ghci> divisibleBy [3,5] 15
11:42:02 <Iceland_jack>     True
11:42:05 <Welkin> I think the problem may be in blaze-builder, but I can't use a newer version because of all my other dependencies
11:43:09 <Iceland_jack> You may want to flip the order of arguments depending on whether you want to use it infix (15 `isDivisibleBy` [3,5]) or partially apply it (filter (isDivisibleBy [3, 5]))
11:43:18 <JoshieAS> Iceland_jack: I want to take a list of multiples and a range and go through that range, find all numbers that are multiples of numbers in the first list and sum them
11:43:56 <JoshieAS> test x xs = filter (\y -> (y `mod` x == 0)) xs...is my function to take 1 number and a range and find it
11:44:07 <JoshieAS> but I want to apply test such that I can use it on a whole list of numbers and a range
11:44:25 <lpaste_> jmcarthur annotated “Reflection without remorse without free categories” with “Reflection without remorse without free categories (more like Operational variation, faster)” at http://lpaste.net/134914#a134918
11:44:33 <Iceland_jack> If you implement by 'divisibleBy' that should be easy
11:44:37 <Iceland_jack> -by
11:45:05 <JoshieAS> ah, I see
11:45:08 <monochrom> have you considered "map (\x -> test x xs) ys"?
11:48:01 <JoshieAS> monochrom: doing concatMap like that gives me exactly what I want, thanks!
11:54:51 <Welkin> having to carefully craft the constraints in a cabal.config is not fun
11:58:06 * hackagebot delta 0.1.2.0 - A library for detecting file changes  http://hackage.haskell.org/package/delta-0.1.2.0 (muzzle)
11:59:28 <vikaton> I'm not finnish haha
11:59:52 <zed_> hello : ) did anyone ever used https://hackage.haskell.org/package/random-fu-0.2/docs/Data-Random-Distribution-Normal.html ?
12:01:07 <ion> I wonder if anyone given a thought into what the class C would look like such that Applicative f => C f => Monad f and C is equal to Arrow in power?
12:01:55 <quchen_> Hm. Is  `\map1 map2 -> map1 `M.union` fmap (f map1) map2`  associative?  I'm trying to work out a proof that this is the <> of some monoid, but I can't come up with an elegant proof.
12:02:27 <quchen_> Intuitively, the fmap doesn't change the keys, so it should not influence which elements the union discards.
12:03:51 <ion> zed: You should just ask your question, someone may be able to answer even if they haven’t used it.
12:05:00 <Welkin> I *finally* for http-streams to build and install properly
12:05:08 <Welkin> after some careful tweaking of constraints
12:05:58 <Welkin> got*
12:06:02 <vikaton> jmcarthur: I dont know if my programming experience is sufficient or not
12:06:15 <vikaton> im defintely not starting out programming
12:06:21 <vikaton> and @ RlyDontKnow 
12:06:39 <Welkin> getting yesod to build properly with other libraries could be a profession by itself
12:07:33 <Welkin> a yesod build consultant
12:07:38 <ion> heh
12:07:44 <Welkin> snoyberg is creating jobs!
12:08:07 * hackagebot avers 0.0.7 - empty  http://hackage.haskell.org/package/avers-0.0.7 (wereHamster)
12:09:11 <ion> “empty” – someone should create acme-empty, the identity package.
12:09:53 <ion> and acme-zero, the canonical uninstallable package.
12:19:14 <rhaps0dy> Hi! So, I have a ghc cross-compiler. I'm trying to cabal install things, and cabal compiles Setup.hs with the cross-compiler, so I can't configure the packages.
12:19:24 <rhaps0dy> Anyone knows how to solve this?
12:21:27 <rhaps0dy> hm, I guess I can replace the executable in the compiled setups cache
12:21:58 <rhaps0dy> but with what, if I compile it with the non-cross ghc it will compile the package with that
12:28:07 * hackagebot promises 0.1 - Lazy demand-driven promises  http://hackage.haskell.org/package/promises-0.1 (EdwardKmett)
12:36:35 <ion> I don’t suppose there is a shorter name for a commutative monoid with an absorbing element?
12:36:49 <haskellnewb> ion: thank's for the github link
12:37:03 <ion> (Such as natural numbers under multiplication)
12:38:21 <quchen> ion: Absorbing element?
12:38:26 <shachaf> "with zero" is shorter than "with an abrosbing element" hth
12:38:30 <quchen> Ah.
12:40:35 <unknownloner> but "with zero" doesnt necessarily mean it absorbs it right?
12:40:43 <unknownloner> like 0 + 2 = 2, not 0
12:42:32 <quchen> unknownloner: 0 isn't a zero with respect to +, it's a 1. :-þ
12:42:51 <unknownloner> gah words
12:43:07 <unknownloner> I'm used to zero and 0 being interchangeable haha
12:43:33 <lolisa> What's the monad + again? Have no idea how to find it on hoogle...
12:43:38 <quchen> mplus
12:44:31 <lolisa> Not mplus, but + as a monad... Sorta like (->,e) I guess?
12:45:07 <lyxia> You mean monoid ?
12:45:50 <lolisa> I dont know, but I once saw code like join (+) 2, which evaluate to 4
12:45:57 <lolisa> > join (+) 2
12:45:58 <quchen> That's not the + monad, that's reader.
12:45:58 <lambdabot>  4
12:46:02 <quchen> join f x = f x x
12:46:22 <lolisa> So it's just reader monad
12:46:26 <quchen> Yes.
12:46:29 <lolisa> Thx
12:46:53 <shachaf> The monad is ((->) e)
12:47:03 <maerwald> lolisa: that one is explained here https://stackoverflow.com/questions/5310203/how-to-use-instances-of-monad-and-confusion-about
12:47:13 <maerwald> lolisa: scroll down to edward kmetts answer
12:48:13 <lolisa> Wait, so is it the reader monad or (->) r monad? Or are they two the same thing?
12:48:25 <lolisa> maerwald, thx, got it
12:49:14 <maerwald> edwards answer should get more upvotes there
12:50:00 <quchen> Reader is a newtype for (->).
12:50:19 <quchen> Or can be one if you don't define Reader in terms of ReaderT for other technical reasons.
12:51:57 <lolisa> quchen, thx, got it
12:53:34 <kloopfr> Hi, is there a good sound library for working with sound using math - like generating a sound from some function and playing it or outputting it to a file?
12:55:30 <unknownloner> I too am interested in this ^
12:55:44 <unknownloner> I tried to make something  like that and it kinda worked but it wasn't all that great
12:57:46 <joncol> If I'd like a reasonably up to date (7.10+ preferably) version of Haskell on my Debian system, what is the recommended installation procedure? apt only seems to have version 7.6...?
12:57:58 <joncol> (Ghc version that is)
13:00:32 <ChristianS> joncol: i downloaded the latest version from https://www.haskell.org/ghc/ and installed it manually
13:00:55 <joncol> ChristianS> Compiled from source?
13:01:05 <ChristianS> joncol: no
13:01:20 <joncol> OK, I'll try it.
13:01:35 <joncol> ChristianS> No Haskell Platform?
13:01:39 <ChristianS> there are binary packages for Linux (x86_64) etc. on that site
13:02:49 <ChristianS> joncol: no. since we use a cabal sandbox for version control it doesn't make so much sense for us. but of course you can install the plattform if you prefer.
13:03:39 <lpaste_> GGuy pasted “Where Clause” at http://lpaste.net/134921
13:03:56 <Hijiri> does anyone have a rough estimate on how much faster IntMap is for difference/union than for Map
13:04:29 <Hijiri> Before I switched, my code was spending most of its time doing (set1 `difference` set2) `union` (set2 `difference` set1)
13:04:37 <ChristianS> Hijiri: you could benchmark it with your use case. generally, Map is pretty fast.
13:04:39 <Hijiri> and then after switching the running time was halved
13:04:56 <ChristianS> oh, you did already
13:05:14 <GGuy> Anyways to express a where clause to multiple patterns? Also I forgot to make it clear that was not intended to be a true numeric "toWord32"
13:13:08 <ChristianS> GGuy: where is specific to one function definition, if that's insufficient you need a top-level definition
13:13:31 <init> hi, I have a small question about the posibility/existance of a function like https://github.com/gnudeb/ircah/blob/master/src/IRC/Raw/Monad.hs#L24 , IRC is defined in https://github.com/gnudeb/ircah/blob/master/src/IRC/Raw/Types.hs#L58 
13:14:17 <init> I basically want to replace every call to irc_read or irc_send with "those" (that may actually use the real IRC_Read/IRC_Send)
13:15:26 <GGuy> ChristianS: Thanks, I was just trying to figure out an elegant way to express that function. I of course could make it recursive but was hoping there was some trick I hadn't thought of :(.
13:16:51 <lolisa> http://lpaste.net/134922 four line, monad -> r in Coq
13:19:49 <lyxia> init: It looks reasonable.
13:20:23 <init> lyxia: I don't know how to write it though, been trying for a few hours :/
13:20:41 <joncol> :q
13:23:19 <quchen> GGuy: Recursive sounds like the right path for that sort of function.
13:23:35 <verement> is there a function to partition a list into sublists of a fixed length?
13:23:44 <init> would anyone have any idea about a possible implementation that does that? 
13:23:50 <quchen> GGuy: Remember that you can add a Word8 as the least significant digits of an integer by left-shifting the integer 8 bits and then OR-ing the Word8 to it.
13:24:20 <quchen> verement: Data.List.Split has functions for that.
13:24:43 <quchen> verement: http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html
13:25:08 <ion> How do i build HTML out of a foo.cabal description locally?
13:25:10 <verement> quchen: excellent, thank you
13:25:27 <quchen> > chunksOf 3 ['a'..'z'] -- ah, it's even loaded in Lambdabot, verement 
13:25:29 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
13:25:50 <mattby> hi, is anyone kind enough to review / give some comments of any kind on https://github.com/matthieubulte/logfind you can comment in github directly or tell me here :)
13:27:05 <lspitzner> ion: `cabal haddock` should include that
13:27:28 <GLM> > chunksOf 3 ['a'..'Y']
13:27:29 <lambdabot>  []
13:27:32 <GLM> > chunksOf 3 ['a'..'y']
13:27:34 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","y"]
13:27:43 <lyxia> init: pattern match on the IRC m a argument.
13:28:15 <quchen> mattby: applyPredicates = sequence :-)
13:28:18 <lyxia> init: or well, the intermediate result it returns
13:28:29 <quchen> > sequence [(<1), (<3)] 2
13:28:30 <lambdabot>  [False,True]
13:29:15 <GLM> :t sequence
13:29:17 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:29:17 <mattby> quchen: with "m" being what?
13:29:33 <GGuy> thanks quchen
13:29:36 <mattby> :t sequence [(<1), (<3)]
13:29:37 <lambdabot> (Num a, Ord a) => a -> [Bool]
13:29:56 <quchen> mattby: ((->) a) is your monad
13:30:27 <mattby> oh, I thought functions were only Functors, awesome!
13:30:28 <quchen> sequence :: [((->) a) Bool] -> ((->) a) [Bool]
13:30:29 <mattby> thanks
13:30:34 <scutigera> ERC> http://lpaste.net/134920
13:30:34 <quchen> Functions are Monads
13:30:36 <ion> lspitzner: Thanks
13:30:36 <scutigera> hi
13:30:45 <scutigera> attoparsec problem- can someone help ?
13:31:16 <quchen> mattby: It becomes a bit more readable when you write it as sections, sequence :: [(a ->) Bool] -> (a ->) [Bool]
13:31:25 <spaceloop> sandbox question: cabal warns that previous versions of the library in my package (installed in sandbox db) might be broken when installing newer dependencies, what would be the usual way to resolve this? --force, or remove them from those old versions from the package db?
13:31:55 <init> lambdabot: yes, that's what I have been trying, but I can't seem to match the types (which means I am doing something wrong there), will try to match differently there
13:32:37 <mattby> quchen: very nice, I'll investigate the monad instance for functions, I'm quite curious about this
13:33:10 * hackagebot DAV 1.0.7 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-1.0.7 (ClintAdams)
13:33:12 <quchen> mattby: The instance seems a bit obscure in the beginning, but you'll spot the pattern eventually. :-)
13:37:16 <xor-xor> Hi, can somebody tell me what precedence "<-" operator (from "do" notation) does have..?
13:37:26 <srhb> xor-xor: It's not an operator.
13:37:32 <srhb> xor-xor: It's just syntax.
13:38:10 <mattby> quchen: found it: fbind g f = \x -> g (f x) x !
13:38:29 <mattby> quchen: so it applies a function only to the "first argument"
13:38:39 <mattby> that sounds like the arrow stuff
13:38:48 <scutigera> import Data.Attoparsec.Text.Lazy
13:38:55 <scutigera> Not in scope: data constructor ‘Result’
13:39:06 <mattby> quchen: it's actually first!
13:39:08 <scutigera> ??
13:39:19 <scutigera> i checked and Result(..) is definitely exported...
13:39:26 <mattby> quchen: without the tuples
13:39:39 <srhb> scutigera: That's not a data constructor though, that's a type constructor.
13:39:54 <scutigera> right....
13:40:17 <quchen> mattby: Well, it's Arrow's *** plus first plus (un)currying, but I don't think that's very helpful in order to understand the instance.
13:40:18 <srhb> scutigera: So you're using it as a value (data) constructor, hence the problem.
13:40:18 <scutigera> i should be suing Fail/Done
13:40:26 <scutigera> using*
13:40:31 <quchen> mattby: Have you heard about Reader?
13:40:43 <scutigera> srhb: ty.
13:40:44 <mattby> quchen: yes, but never really used
13:41:11 <quchen> mattby: Well, functions are the same thing as Reader, essentially. Only that you can omit the runReader and such.
13:41:22 <mattby> I'll check this, thanks
13:41:36 <quchen> So instead of "Reader (+2)" to get the action that adds 2 to the environment, you just write (+2).
13:42:01 <quchen> > (do { x <- (+2); return x }) 10
13:42:02 <lambdabot>  12
13:42:18 <quchen> 1> (runReader $ do { x <- reader (+2); return x }) 10
13:42:24 <quchen> > (runReader $ do { x <- reader (+2); return x }) 10
13:42:25 <lambdabot>  12
13:42:48 <joncol> :q
13:44:59 <mattby> quchen: so what is reader good for?
13:45:16 <quchen> mattby: You mean in general, or why we have a newtype for it?
13:45:21 <mattby> yes
13:45:29 <mattby> why do we have a new type?
13:46:16 <quchen> For the same reason we have any other newtype: we can write specialized instances only valid in the context of that newtype, to give things descriptive names, to gain type safety.
13:46:37 <mattby> of course, that makes sense
13:46:54 <quchen> We also have a newtype for s -> (a,s) for similar reasons.
13:47:12 <quchen> (That's State.)
13:47:21 <quchen> And for (w,a), which is Writer.
13:47:41 <c_wraith> though these days, all of those are implemented as their transformer versions over Identity. >_>
13:48:40 <quchen> Yeah. Useful in practice, not so much for teaching.
13:49:12 <c_wraith> I'm not even sure how useful it is in practice, except insofar as it reduces code duplication
13:49:56 <quchen> c_wraith: mmorph makes good use of it as well
13:50:09 <quchen> Changing the Identity to something else etc
13:53:11 * hackagebot avers 0.0.8 - empty  http://hackage.haskell.org/package/avers-0.0.8 (wereHamster)
13:56:39 <quchen> c_wraith: And other than that, abstraction is all about reducing code duplication, no? :-D
13:58:11 * hackagebot acme-zero 0.0.1 - The absorbing element of package dependencies  http://hackage.haskell.org/package/acme-zero-0.0.1 (ion)
13:58:13 * hackagebot acme-one 0.0.1 - The identity element of package dependencies  http://hackage.haskell.org/package/acme-one-0.0.1 (ion)
13:59:09 <scutigera> aha
13:59:14 <scutigera> do x <- many1 $ skipSpace *> aNumber
13:59:14 <scutigera>      endOfLine
13:59:14 <scutigera>      return $ DataLine x
13:59:28 <scutigera> why does that return multiple lines instead of exactly 1 line ?
13:59:54 <ion> Perhaps skipSpace skips newlines.
14:00:01 <scutigera> that just occurred to me
14:00:21 <geekosaur> "whitespacew" often includes newline, yeh
14:00:34 * geekosaur eyes finfers *sigh*
14:00:55 <scutigera> bingo!
14:00:57 <ion> Btw, DataLine <$> (many1 (skipSpace *> aNumber) <* endOfLine)
14:01:06 <scutigera> it's using DataChar library isSpace
14:01:18 <scutigera> which is any whitespace - not just "horizontal" spaces
14:01:45 <quchen> Any Unicode whitespace at that
14:02:12 <hpc> ion: nice package uploads
14:03:00 <quchen> ion: Nice complement to acme-everything :-D
14:03:26 <ion> :-)
14:03:51 <hpc> you should write a test suite package that makes sure cabal obeys the laws of acme-zero and acme-one
14:03:59 <ion> heh
14:04:21 <hpc> if you can install the package, cabal is working correctly
14:06:48 <scutigera> lol. that solved the problem of multiple line reading
14:06:55 <scutigera> now it's not getting any lines
14:11:03 <geekosaur> you match end of line, does anything consume the following newline before you invoke it again?
14:11:36 <scutigera> doesn't endOfWhile consume it ?
14:12:17 <scutigera> hmmmm... skip isn't doing what i think it should
14:12:33 <scutigera> looks like if you say "skip space" and it doesn't actually match a space that causes problems
14:12:37 <scutigera> looks like that's my issue
14:12:52 <scutigera> yep- that's the problem
14:13:25 <scutigera> i have to use takeWhile space
14:14:22 <scutigera> woot
14:14:27 <scutigera> this thing is actually working now :-)
14:33:12 * hackagebot trurl 0.3.1.0 - Haskell template code generator  http://hackage.haskell.org/package/trurl-0.3.1.0 (dbushenko)
14:33:16 <ion> scutigera: The sepBy functions might or might not be more appropriate.
14:36:11 <bitemyapp> @pl applyTimes times f b = f (applyTimes (times-1) f b)
14:36:11 <lambdabot> applyTimes = fix ((ap (.) .) . (. subtract 1))
14:36:15 <bitemyapp> LOL k
14:37:30 <frerich_> > 0 * length [1..]
14:37:34 <lambdabot>  mueval-core: Time limit exceeded
14:39:28 <frerich_> Interesting - does anybody know why (*) is strict in its arguments? Skimming https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1160006 didn't reveal an explanation.
14:40:23 <frerich_> > undefined * 0
14:40:24 <lambdabot>  0
14:40:25 <shachaf> That's the default.
14:40:28 <scutigera> ion: ty- i'll take a look
14:40:48 <shachaf> What!
14:40:52 <shachaf> That surprises me much more.
14:40:55 <lyxia> > undefined * 0 :: Int
14:40:57 <lambdabot>  *Exception: Prelude.undefined
14:41:03 <lyxia> All is well.
14:41:07 <shachaf> Yes, it's Integer.
14:41:21 <shachaf> Even so.
14:41:30 <frerich_> I think it's still surprising.
14:41:30 <ion> It might not be nice if foldl' product 1 suddenly accumulated thunks because evaluating a * b doesn’t have a and/or b evaluated.
14:42:00 <ion> uh
14:42:02 <ion> foldl' (*) 1
14:44:24 <quchen> ion: That shouldn't be a problem. When you force (*)s result you force enough to get an answer you can use, and at that point it might even be beneficial when you throw a thunk away in the process.
14:44:53 <frerich_> ion: Still - having '0 * undefined' work differnetly than 'undefined * 0' is somewhat unintuitive :-)
14:45:10 <ion> quchen: You’re right.
14:45:14 <fizbin> Hey, if there's a type defined in a module and the module exposes the type, but not any of its constructors, and also exposes no functions that can create a value of that type, then the type can't really be used, can it?
14:45:18 <quchen> ion: When we're still talking about Int(egers) of course.
14:45:23 <frerich_> Wait - this is just lambdabot... in ghci, it works as expected.
14:45:39 <shachaf> (x * 0 :: Integer) doesn't force x.
14:45:45 <shachaf> How bizarre. Is that new?
14:45:47 <quchen> Odd.
14:45:49 <fizbin> Specifically, I'm trying to figure out the use/purpose of the type MonadPseudoRandom in https://hackage.haskell.org/package/cryptonite-0.5/docs/Crypto-Random-Types.html 
14:46:10 <ion> > length [0..] * 0 :: Integer
14:46:11 <lambdabot>      Couldn't match expected type ‘Integer’ with actual type ‘Int’
14:46:12 <lambdabot>      In the first argument of ‘(*)’, namely ‘length [0 .. ]’
14:46:12 <lambdabot>      In the expression: length [0 .. ] * 0 :: Integer
14:46:13 <fizbin> I can't figure out how one could ever have a value of that type.
14:46:22 <quchen> > undefined * (0 :: Integer)
14:46:24 <lambdabot>  0
14:48:02 <lyxia> fizbin: the interesting interface is MonadRandom
14:48:22 <fizbin> Well... the IO interface of that is interesting.
14:48:43 <fizbin> But suppose I wished to use MonadPseudoRandom. Could I?
14:48:49 <fizbin> How?
14:49:03 <frerich_> shachaf: What you did you mean by 'That's the default'? I think I'm missing something, not forcing 'x' in 'x * 0' seems fairly plsubiel to me on first sight... :-]
14:49:26 <shachaf> The obvious thing to do for Int is machine multiplication.
14:49:28 <lyxia> fizbin: getRandomBytes 7 :: MonadPseudoRandom ByteString
14:49:37 <shachaf> But anyway I'd expect all the Int operations to be strict.
14:49:46 <cj3kim> hey guys
14:49:51 <shachaf> I'm surprised that Integer is different, and I'm not certain whether it should be.
14:50:14 <cj3kim> not a haskell topic, but I created an app that took three months to build
14:50:41 <fizbin> lyxia: Hrm. I'm not entirely certain where one goes with that, but okay...
14:50:42 <cj3kim> and i'm thinking about open sourcing it since I'm not planning to use it as a serious business
14:50:54 <cj3kim> good idea? bad ide?
14:50:57 <lyxia> fizbin: Then use that bytestring as a seed to generate a value: f <*> getRandomBytes 7 :: MonadRandom SomeData
14:51:10 <frerich_> shachaf: Is the strictness of '*' for Int a feature of ghc, or is that part of the language?
14:51:12 <ion> GHC 7.6.3 has (undefined * 0 :: Integer) = undefined, (0 * undefined :: Integer) = undefined.
14:51:14 <lyxia> fizbin: I meant f <$> getRandomBytes
14:51:15 <shachaf> cj3kim: This isn't the channel for that.
14:51:23 <shachaf> ion: OK, so it's recent.
14:51:27 <ion> The major integer-gmp change probably.
14:51:38 <shachaf> Right.
14:51:55 <quchen> 7.8 yields undefined as well
14:52:00 <quchen> for ⊥*0, that is
14:52:08 <cj3kim> shachaf: got it. thanks
14:52:15 <lyxia> fizbin: and actually the types should have been ... :: MonadRandom gen _
14:52:19 <fizbin> lyxia: I guess. Then I suppose that with something like that, I could use withDRG to actually run it.
14:52:59 <lyxia> fizbin: Indeed.
14:55:34 <frerich_> quchen: So this is actually a regression in ghc 7.10? Yay, first time I noticed a ghc bug!
14:55:48 <quchen> Might be a feature.
14:56:47 <shachaf> It's a different behavior.
14:56:57 <shachaf> It doesn't make any programs that used to terminate not terminate.
14:57:04 <shachaf> So it's arguable whether it breaks compatibility.
14:57:11 <shachaf> Not that GHC cares about compatibility.
14:57:41 <frerich_> So '*' doesn't need to be commutative?
14:58:05 <shachaf> Who's to say?
14:58:17 <quchen> Some programs might not terminate now because of large thunk buildup (and overflows because of that).
14:58:18 <shachaf> It's already not associative for Double.
14:58:19 <edwardk> Num has no laws, just conventions
14:58:41 <frerich_> Hm, true - I guess all hope is lost with doubles.
14:58:43 <quchen> Such as "don't leave too much undefined" ಠ_ಠ 
15:02:19 <dmp1ce> Is there a way to get all the functions from a program at runtime? Is this called reflection?
15:03:14 * hackagebot xml-types 0.3.5 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.3.5 (JohnMillikin)
15:03:26 <ion> dmp1ce: For what purpose?
15:04:57 <m0rphism> hey fellow haskellers, I have found two weird behaviours of haskell-src-exts and am wondering whether they are bugs or I'm just not getting their points ^^
15:05:52 <dmp1ce> ion: I just want to see what I can use when I load a module.
15:06:15 <dmp1ce> ion: I have been reading documentation and source code.
15:06:33 <ion> :browse Module in ghci
15:06:53 <m0rphism> 1) If i have a match without patterns, like: "foo = bar", then "foo" is counted as a pattern variable, but in a match like "foo x = bar" foo is not counted as a pattern variable.
15:07:08 <dmp1ce> ion: Thanks.
15:08:26 <lyxia> m0rphism: that's right.
15:08:51 <frerich_> m0rphism: That's because the latter defines a function; in the former case, you might do pattern-matching, e.g. '[x,y,z] = take 3 [1..10]'
15:09:19 <ion> You can’t do [x,y,z] a = something
15:09:29 <m0rphism> 2) The SrcSpan's of a qualified identifier seems mixed up. An expression like "List.sort" is represented as a "Qual span moduleName name" where moduleName corresponds to "List" and name to "sort" and each have their own SrcSpan, but all three SrcSpans cover the whole "List.sort" string.
15:09:33 <frerich_> m0rphism: 'foo' would be an irrefutable pattern.
15:11:50 <m0rphism> frerich_: Thanks, I think I see your point. I was only thinking in terms of top-level definitions, but in a let-binding for example that makes more sense.
15:12:44 <frerich_> m0rphism: Alas, I have no idea about your second question - I never came across 'SrcSpans' :-]
15:13:53 <lyxia> m0rphism: You can do pattern matching at toplevel too.
15:14:28 <m0rphism> frerich_: Ok, thanks anyway.
15:14:35 <m0rphism> I'm currently working on semantic syntax highlighting for emacs. I got inspired recently when I was playing around with Agda, which has excellent emacs support :)
15:16:47 <m0rphism> lyxia: Oh you're right! I didn't noticed one could bind multiple identifier simultaneously at the toplevel, i.e. with `[x,y,z] = take 3 [1..10]`
15:17:00 <m0rphism> thanks, for the hint :)
15:22:00 <alexgman123> how would one convert [1] to 1?
15:22:13 <ion> length, sum, product
15:22:35 <Clint> const 1
15:22:51 <ion> foo ~[1] = 1
15:23:32 <newsham> ?type const change
15:23:33 <lambdabot>     Not in scope: ‘change’
15:23:33 <lambdabot>     Perhaps you meant one of these:
15:23:33 <lambdabot>       ‘range’ (imported from Data.Ix),
15:23:37 <m0rphism> Clint: ^^
15:23:54 <Peaker> ion: is that any different from foo _ = 1 (except the type specialization)?
15:23:57 <alexgman123> well i would want to generalize it like [4] = 4
15:24:18 <Peaker> alexgman123: that rules out const and length :) still left with sum and product
15:24:19 <ion> Peaker: It isn’t, that was intended for humorous purposes.
15:24:31 <Peaker> alexgman123: what about [4,17] ?
15:24:45 <arkeet> what about [] ?
15:24:45 <Peaker> ion: I know, but was still wondering :)
15:24:48 <alexgman123> Peaker:undenfined
15:24:58 <alexgman123> arkeet:  undefined
15:25:07 <zed_> Hello : ) So I found answers to my previous questions... I now have a simple bug that I am trying to work out. Here's the code and the error I get : http://lpaste.net/134931
15:25:10 <Peaker> alexgman123: partial functions are frowned upon, but you can do:  foo [x] = x ; foo _ = error "Expecting a singleton list.."
15:25:12 <ion> alexgman123: You’ll want to go back and avoid generating a list in the first place then.
15:25:40 <Peaker> alexgman123: why is it that you have this weird list type if you only actually have 1 element?
15:26:06 <lyxia> zed_: Fields must be separated by commas
15:27:25 <lyxia> zed_: "data" is the keyword.
15:27:41 <alexgman123> this language is a bitch
15:28:16 <ion> FWIW, this applies to every language anywhere.
15:28:55 <GGuy> Hi, I'm looking for a term. Where "a . b" is composition what is "a x `f` b x"?
15:29:09 <zed_> lyxia: thanks ! 
15:29:14 <lolisa> It does not apply to brainfuck - at least I never see anyone cursing about the usability of brainfuck :)
15:30:00 <Peaker> GGuy: composition is what "." does. What does "f" do?
15:30:14 <ion> GGuy: liftA2 f a b?
15:31:29 <tromp_> composition in the Reader monad
15:31:47 <ion> applicative
15:32:58 <alexgman123> why is this a parse error? addDigits ([x]++[xs]) = x
15:33:15 <alexgman123> i've got a list [1,2,3] and i want to return 1
15:33:20 <tromp_> use : instead of [x]++
15:33:37 <m0rphism> alexgman123: (++) is a function and not a constructor
15:33:44 <tromp_> : is a constructor
15:33:57 <ion> alexgman123: (++) is not a data constructor. Data constructors either begin with a capital letter, or in the case of operators, with :
15:34:47 <ion> > let x:xs = "hello" in (x, xs)
15:34:48 <lambdabot>  ('h',"ello")
15:34:59 <alexgman123> Couldn't match expected type `Int' with actual type `[Int]'
15:36:53 <ion> alexgman123: That is not enough for us to know what the problem is, we need to see the source and the full error message.
15:38:13 <alexgman123> im trying to write my own sum [ ] function, just like sum [1,2,3] = 6
15:38:33 <alexgman123> ive got this so far addDigits (x:xs) = x + addDigits xs
15:39:29 <ion> > let addDigits (x:xs) = x + addDigits xs in addDigits [a,b,c]
15:39:30 <lambdabot>  a + (b + (c + *Exception: <interactive>:3:5-39: Non-exhaustive patterns in f...
15:39:34 <ion> There is no type error in that.
15:40:05 <alexgman123> ion: whast wrong with the way i did it?
15:40:17 <ion> I don’t know, i haven’t seen the source and the full error message.
15:40:28 <GGuy> Peaker, ion... I guess I'm more so thinking the differences between: "(.) ((+) 4) ((*) 2) 2 === 8" (combination) and  "(\f x -> ((+) 4 x) `f` ((*) 2 x)) (+) 2 === 10" (???)
15:40:35 <breadmonster> Does anyone know how to use scotty?
15:40:36 <breadmonster> Or where to start?
15:40:42 <frerich_> alexgman123: You might need to make up your mind on what 'addDigits' should do if it gets an empty list.
15:42:39 <m0rphism> alexgman123: Note that [1,2,3] is just syntactic sugar for `1:(2:(3:[]))`
15:43:28 <breadmonster> Why on earth do weird things involving flip, ($) and id typecheck?
15:43:43 <breadmonster> :t ($) (flip ($))
15:43:44 <lambdabot> a -> (a -> c) -> c
15:43:54 <breadmonster> :t ($) (flip ($)) id
15:43:55 <lambdabot> ((a -> a) -> c) -> c
15:44:15 <breadmonster> I didn't get that one ^
15:44:18 <lyxia> The joys of polymorphism.
15:44:37 <breadmonster> lyxia: I've heard you can really bend spacetime with typeclasses.
15:45:12 <ion> id :: b -> b
15:45:16 <lyxia> breadmonster: What do you not get about that one? What the compiler infers? What the function does?
15:45:24 <ion> “f :: a -> (a -> c) -> c” applied to id makes a ~ (b -> b)
15:45:26 <breadmonster> lyxia: Ideally, give me both.
15:45:38 <ion> In that case, f :: (b -> b) -> ((b -> b) -> c) -> c
15:45:41 <breadmonster> Oh okay, right.
15:45:46 <ion> f id :: ((b -> b) -> c) -> c
15:45:57 <breadmonster> ion: Sure and what does this do?
15:46:06 <ion> @djinn ((b -> b) -> c) -> c
15:46:07 <lambdabot> f a = a (\ b -> b)
15:46:15 <Cale> breadmonster: It might be worth noting that ($) is the same thing as id, just with a more specific type.
15:46:24 <Cale> :t id
15:46:25 <lambdabot> a -> a
15:46:27 <Cale> :t ($)
15:46:28 <lambdabot> (a -> b) -> a -> b
15:46:34 <breadmonster> Cale: Yeah, implicit forall.
15:46:37 <breadmonster> Got that from augur_ 
15:46:50 <breadmonster> ion: What does the djinn do?
15:47:06 <breadmonster> @djinn ((a -> (a -> c1) -> c1) -> c) -> c
15:47:06 <lambdabot> f a = a (\ b c -> c b)
15:47:07 <ion> breadmonster: Tries to generate a matching value given a type.
15:47:07 <Cale> breadmonster: It writes functions based on the type
15:47:16 <breadmonster> Holy crap.
15:47:25 <breadmonster> @djinn a -> a
15:47:26 <lambdabot> f a = a
15:47:32 <breadmonster> Interesting.
15:47:47 <breadmonster> Cale: Is this a lambdabot exclusive feature?
15:47:52 <ion> @hackage djinn
15:47:52 <lambdabot> http://hackage.haskell.org/package/djinn
15:47:54 <ion> @hackage exference
15:47:54 <lambdabot> http://hackage.haskell.org/package/exference
15:48:06 <breadmonster> ion: You're awesome, thanks a ton!
15:48:10 <ion> https://github.com/lspitzner/exference
15:48:25 <breadmonster> On the off chance that this happens, has anyone ever used Haskell at a college hackathon?
15:52:05 <ion> One more thing, btw:
15:52:11 <ion> ($) :: (a -> b) -> a -> b
15:52:18 <ion> flip ($) :: c -> (c -> d) -> d
15:52:24 <ion> id :: e -> e
15:52:38 <breadmonster> sure...
15:52:51 <ion> In the expression ($) (flip ($)), (a -> b) ~ (c -> (c -> d) -> d)
15:52:55 <breadmonster> This sounds like it's break your brain stuff.
15:53:03 <ion> In the expression ($) (flip ($)) id, additionally a ~ (e -> e)
15:53:18 <ion> Try unifying those types manually on paper, that will be enlightening.
15:54:10 <breadmonster> ion: In simple speak, try to find the type of `($) (flip ($))`?
15:54:24 <ion> Try to find the type of the ($) when applied to flip ($) and id
15:54:45 <ion> @type undefined :: ((a -> b) ~ (c -> (c -> d) -> d), a ~ (e -> e)) => (a -> b) -> a -> b
15:54:46 <lambdabot> ((e -> e) -> ((e -> e) -> d) -> d) -> (e -> e) -> ((e -> e) -> d) -> d
15:54:58 <ion> This is what your end result should be.
15:55:16 <ion> @type ($) `asTypeIn` \f -> f (flip ($)) id
15:55:17 <lambdabot> ((a -> a) -> ((a -> a) -> c) -> c) -> (a -> a) -> ((a -> a) -> c) -> c
15:55:20 <breadmonster> Cool stuff.
15:55:57 <breadmonster> ion: Wow, I didn't know you could use that syntax. Is it an extension?
15:56:35 <ion> Just a function defined in lambdabot: asTypeIn :: a -> (a -> b) -> a; a `asTypeIn` f = a where { _ = f a } ; infixl 0 `asTypeIn`; asAppliedTo :: (a -> b) -> a -> a -> b ; f `asAppliedTo` x = f `asTypeIn` ($ x); infixl 0 `asAppliedTo`
15:57:44 <breadmonster> Oh cool, but I was talking about the ~ to unify types.
15:58:28 <shachaf> whoa whoa whoa
15:58:34 <shachaf> You can use \ \ instead of \&
15:58:37 <shachaf> > "\x123\ \4"
15:58:39 <lambdabot>  "\291\&4"
15:59:01 <ion> breadmonster: Ah. The equality constraint is an extension, it can be enabled with GADTs or TypeFamilies.
16:03:22 <ion> breadmonster: Hint: (a -> b) ~ (c -> ((c -> d) -> d)) implies a ~ c and b ~ ((c -> d) -> d)
16:03:42 <breadmonster> ion: Yup, I'm working through it.
16:08:42 <GGuy> Thanks ion you were right! "liftA2 (+) ((+) 4)  ((*) 2) 2 === 10"
16:09:22 <mniip> why not just say (4 +) and (2 *)
16:10:11 <GGuy> mniip: True
16:11:49 <breadmonster> ion: This is really strange.
16:12:09 <breadmonster> :t ($) (flip ($))
16:12:10 <lambdabot> a -> (a -> c) -> c
16:13:23 <Moggle1> can 'forever' memory leak? i was under the impression that haskell tail-called that.
16:14:03 <Moggle1> (in the IO monad)
16:14:08 <mniip> breadmonster, the first ($) does nothing
16:14:28 <mniip> :t flip ($)
16:14:29 <lambdabot> a -> (a -> c) -> c
16:14:31 <mniip> :t flip id
16:14:32 <lambdabot> b -> (b -> c) -> c
16:16:44 <Cale> Moggle1: forever a   = let a' = a >> a' in a' -- shouldn't leak memory, since it constructs the thing cyclically
16:17:09 <Cale> Moggle1: Has nothing to do with tail calls though -- Haskell doesn't have a call stack.
16:17:15 <Cale> (At least GHC Haskell doesn't)
16:17:17 <mniip> Cale, it depends on the implementation of >>
16:17:26 <Moggle1> thanks Cale
16:17:43 <Moggle1> trying to hunt down a memory leak, and it's annoying not knowing entirely where to look
16:17:47 <Cale> mniip: Does it?
16:17:54 <mniip> very much so
16:18:19 <Cale> I'm assuming here that (>>) operates in constant space
16:18:48 <Cale> a' won't be re-evaluated when it is entered for a second time
16:19:02 <Cale> and thus won't result in further allocation
16:21:11 <zed_> I am not sure I am coding the right thing, but here's the code and the error : http://lpaste.net/134934 Please help ? : )
16:22:03 <Cale> mniip: I can think of monads for which forever x will be a <<loop>> exception, but none for which it will just consume space forever.
16:22:19 <mniip> list monad
16:22:40 <Cale> It's a loop exception for the list monad.
16:22:41 <scutigera> zed_: no return necessary
16:23:03 <scutigera> you just need pz * b * c
16:23:04 <Cale> (assuming you give it a nonempty list)
16:23:13 <scutigera> oops
16:23:14 <augur_> breadmonster: the polymorphism of  the type gets you a lot of crap :)
16:23:15 <scutigera> you need
16:23:16 * hackagebot acme-zero 0.0.2 - The absorbing element of package dependencies  http://hackage.haskell.org/package/acme-zero-0.0.2 (ion)
16:23:17 <scutigera> in
16:23:18 * hackagebot acme-one 0.0.2 - The identity element of package dependencies  http://hackage.haskell.org/package/acme-one-0.0.2 (ion)
16:23:24 <scutigera> pz * b * c
16:23:32 <augur_> breadmonster: like, flip ($)
16:23:36 <scutigera> let ... in <return value>
16:23:54 <breadmonster> Hmm yeah.
16:24:07 <augur_> breadmonster: consider:   flip :: forall a b. (a -> b -> c) -> b -> a -> c     ($) :: forall d e. (d -> e) -> d -> e
16:24:13 <zed_> thanks everyone ! : )
16:24:28 <augur_> breadmonster: so if you apply flip to ($)   there has to be some way that    a -> b -> c    =   (d -> e) -> d -> e
16:24:40 <augur_> breadmonster: but that's easy,   a = d -> e,  b = d   c = e
16:25:21 <augur_> so now you get   flip ($) :: b -> a -> c   but using those equations   flip ($) :: d -> (d -> e) -> e
16:25:35 <augur_> but that's easy, id is funnier
16:25:43 <breadmonster> augur_: Oh okay.
16:25:48 <augur_> id :: forall d. d -> d
16:26:13 <augur_> to do   flip id   you have to somehow get    a -> b -> c  =  d -> d
16:26:25 <augur_> so that means d = a and also d = b -> c
16:26:39 <augur_> so a = b -> c as well
16:26:54 <augur_> flip id :: b -> (b -> c) -> c
16:26:58 <Cale> forever [1,2]
16:26:59 <augur_> :t flip id
16:27:00 <lambdabot> b -> (b -> c) -> c
16:27:01 <Cale> = (let a' = [1,2] >> a' in a')
16:27:07 <Cale> = (let a' = concat (map (\x -> a') [1,2]) in a')
16:27:15 <Cale> = (let a' = concat ((\x -> a') 1 : map (\x -> a) [2]) in a')
16:27:35 <scutigera>      let x = case parseIt inputStr of
16:27:35 <scutigera>            Fail rest context msg -> putStrLn $ show msg
16:27:35 <scutigera>            Done unparsed r -> r
16:27:41 <augur_> Cale: im rather fond of that stupid filterM thing for powerset-lists :)
16:27:43 <Cale> = (let a' = (\x -> a') 1 ++ concat (map (\x -> a) [2]) in a')
16:27:43 <scutigera> Couldn't match expected type ‘IO ()’ with actual type ‘[LineTypes]’
16:27:54 <Cale> = (let a' = a' ++ concat (map (\x -> a) [2]) in a')
16:28:04 <Cale> --> exception <<loop>>
16:28:18 <Cale> (when (++) tries to match on a' and a' is already evaluating)
16:28:28 <dfeuer_> Is Cale loopy today?
16:28:29 <ion> scutigera: Try “Done unaprsed r -> print r”. r doesn’t have a type that unifies with the type of putStrLn (show msg). (Btw, putStrLn . show = print.)
16:28:30 <Cale> > forever [1,2]
16:28:34 <lambdabot>  mueval-core: Time limit exceeded
16:28:58 <Cale> Heh, interesting that it doesn't catch it. GHCi does at least.
16:29:23 <Cale> In any case, even if it were to enter a' at that point, no further allocation would be done
16:29:26 <Cale> It just wouldn't get anywhere
16:29:32 <ion> My ghci 7.10.1 doesn’t catch that either.
16:29:41 <scutigera> ion: yes- that works fine. the problem is i want to grab the result of the parse - a list of stuff and work on it some more.
16:29:42 <mniip> ion, hahahhaah
16:29:52 <scutigera> but i can't seem to "free it" from the case statement.
16:29:52 <Cale> I'm running 7.10.1 and it does
16:30:27 <Cale> So I dunno, I don't think it really depends on the monad instance very much.
16:30:31 <mniip> ion, doesn't commutativity turn dependencies into a semiring?
16:31:02 <mniip> no wait
16:31:05 <zed_> and now, it's basically the same code but i really don't understand why it calls such an error : http://lpaste.net/134934
16:31:08 <mniip> nevermind
16:31:09 <ion> scutigera: Semiring requires two binary operations. If Cabal had alternative dependencies with |, it might.
16:31:14 <ion> Uh, i mean mniip.
16:31:17 <Cale> At least, I can't think of any example where forever x will do an unbounded amount of allocation on its own (and for which forever and/or (>>) are responsible for the memory, rather than x itself of course)
16:31:19 <scutigera> lol
16:31:35 <mniip> there's no special word for commutative monoid
16:31:56 <scutigera> zed_: you forgot the "in" keyword.
16:32:19 <scutigera> let blah blah blah in <expression>
16:32:42 <ion> scutigera: If you’re in IO (as indicated by you printing stuff), you could just throw an exception upon Fail and use “Done unparsed r -> pure r”.
16:32:44 <zed_> scutigera: thaaanks. i feel like such a noob ahah
16:32:50 <scutigera> ion: np. people often get me confused with mniip
16:33:25 <mniip> yeah
16:33:30 <scutigera> zed_: i'm ecstatic that i can actually help someone :-)
16:33:30 <mniip> tab completion fails sometimes
16:35:02 <ion> Actually, i don’t tend to use tab completion. I had typed “scutigera: ” to say what i just said to him, then read mniip’s message, and started to respond to him first. The input line state in my brain didn’t match reality.
16:35:26 <zed_> scutigera: yeah I can understand that feeling ; )
16:35:53 <mniip> scutigera, it's like a drug
16:36:02 <mniip> gets boring, and you have to increase the dosage
16:36:53 <Welkin> bdsm?
16:37:25 <ion> while helping Haskellers
16:38:27 <mniip> it isn't restricted to haskell though
16:46:41 <scutigera> hey - could i get some help with windows ? ;-)
16:46:49 <scutigera> I'M KIDDING
16:47:38 <scutigera> ion: Couldn't match expected type ‘()’ with actual type ‘[LineTypes]’
16:47:42 <scutigera> almost there...
16:48:01 <scutigera> i'm still confused why the let = assignment doesn't work.
16:48:02 <felixn> anyone know how to make "import MyProject.Foobar" in GHCi?  I just get "Could not find module" ... I know I can use ":load", but I actually want to import some fixtures for doctest that I've created for some hspec tests
16:48:15 <scutigera> is r "trapped" in the Parse monad or something ?
16:48:55 <felixn> I can do that import in the module, but then stylish haskell yells at me that the import isn't in use :)
16:49:05 <pavonia> felixn: Is that module part of an installed package?
16:49:10 <ion> scutigera: Try replacing both expressions after the ->s with _ and looking at the message from GHC. It will tell you what the types of the holes must be.
16:49:16 <felixn> pavonia: no, just my application
16:49:35 <ion> scutigera: Then fill in one of the holes, GHC will tell you what the type of the remaining hole must be.
16:49:51 <scutigera> ion: nice one !!! i forgot about that trick
16:50:03 <ion> scutigera: If you fill the second hole with a value whose type does not unify, that’s a type error.
16:50:35 <scutigera> ion: yeah- i've got this look of "huh?" on my face when you use big words like "unify".
16:51:12 <scutigera> see it says ->  r :: [Linetypes]
16:51:13 <shachaf> What do you usually do when people use words you don't know?
16:51:17 <ion> scutigera: The type variable “a” without any constraints will unify with “Integer”, but “Char” will not unify with “Integer”.
16:51:22 <pavonia> felixn: I don't know if that's possible, maybe if you :add it?
16:51:46 <scutigera> shachaf: get this "huh?" look on my face.  i thought i was clear about that.
16:52:09 <ion> scutigera: The type variable “a” with the constraint “Num a” will also unify with “Integer”, for example.
16:52:49 <ion> “IO a” and “f Integer” will unify with each other, resulting in f ~ IO and a ~ Integer.
16:53:03 <mjrosenb> if I have "M\146n", then that is 146 in octal, right?
16:53:14 <shachaf> mjrosenb: Decimal.
16:53:17 <shachaf> (Easy enough to test.)
16:53:25 <scutigera> ion: ok- i actually sort of understood that.
16:53:33 <pavonia> > ord '\146'
16:53:34 <lambdabot>  146
16:53:39 <scutigera> but i'm lost in the 20 lines of ghc explanation
16:53:56 <mjrosenb> decimal?! what the hell format is this in?
16:54:01 <Welkin> > chr '\146'
16:54:02 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Char’
16:54:02 <lambdabot>      In the first argument of ‘chr’, namely ‘'\146'’
16:54:02 <lambdabot>      In the expression: chr '\146'
16:54:03 <scutigera> r is type [LineType] which is _precisely_ what i want and what i think it should be
16:54:11 <scutigera> oh crap.
16:54:14 <mjrosenb> > chr 146
16:54:15 <lambdabot>  '\146'
16:54:21 <Welkin> :t chr
16:54:22 <lambdabot> Int -> Char
16:54:23 <Welkin> ah
16:54:25 <scutigera> it's the Fail alternative mucking things up, right ?
16:54:31 <Welkin> I got ord and chr mixed up
16:54:35 <Welkin> :t ord
16:54:36 <lambdabot> Char -> Int
16:54:46 <pavonia> > ord '\o146'
16:54:47 <lambdabot>  102
16:54:48 <scutigera> the case statement might return from the Fail branch OR it might return from the Done branch
16:54:54 <ion> scutigera: It just prints the types of things in scope that might be useful for filling the hole, you have bound r to a value of type [Linetypes] in front of the ->. The important part is the type of the actual hole.
16:54:56 <scutigera> and those two return types have to "unify"
16:54:58 <scutigera> is that right ?
16:55:03 <zed_> would someone be able to give me an example of how to use the quantile function in http://hackage.haskell.org/package/statistics-0.10.2.0/docs/Statistics-Distribution.html ?
16:55:20 <ion> scutigera: yes
16:55:27 <scutigera> cool
16:55:38 <scutigera> ok i changed the Fail branch to error "Fail"
16:55:52 <Welkin> > ord '\b1010'
16:55:53 <lambdabot>  <hint>:1:8:
16:55:53 <lambdabot>      lexical error in string/character literal at character '1'
16:55:59 <scutigera> now i'm getting a new an exciting error message
16:56:11 <scutigera> but i think i get it now... let's see if i'm right....
16:56:22 <ttt_fff> where is a minimal guide to use https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec.html ? RWH seems to be out of date, and lots of results on google brings up atto-parsec
16:56:24 <scutigera> GLORIOUS!
16:56:25 <scutigera> lol
16:56:26 <felixn> pavonia: woah, I think you're onto something ... :add does do something, but it also removes the current module, when I both with ":add Foo.hs Bar.hs", only the last item is loaded
16:56:26 <ion> error "foo" :: a, therefore it will unify with anything.
16:56:28 <Welkin> > ord '\x10'
16:56:29 <lambdabot>  16
16:56:48 <scutigera> so the Fail branch is error "Fail" and now my assignment works as expected.
16:56:54 <ion> error "foo" is also bad. :-P
16:57:01 <scutigera> ion: thanks so much! that was actually an important lesson for me!!
16:57:14 <scutigera> and that _ trick is invaluable
16:57:28 <scutigera> i had used that trick in ML many moons ago and forgot about it...
16:57:37 <MarcelineVQ> 3>:i ord
16:57:42 <MarcelineVQ> woops lol
16:57:53 <ion> ML has typed holes? Cool.
16:58:35 <scutigera> ttt_fff: i'm wrestling with attoparsec right now.
16:58:47 <ttt_fff> yeah, I need parsec
16:58:50 <ttt_fff> attoparsec is not what I need
16:58:53 <scutigera> ok
17:00:17 <solirc> felixn: You can use :load with doctest
17:00:42 <scutigera> ion: not sure if they are typed holes.
17:00:55 <scutigera> but it was a very similar trick. as i said, many moons ago.
17:05:55 <ion> Ok
17:06:29 <felixn> solirc: :load also seems to replace it, it's ok though, I'm going to move on for now ... it was just a nice to have
17:06:39 <vikaton> if doing both at the same time isnt a good idea, should I learn C or haskell first
17:09:31 <scutigera> ML
17:09:36 <scutigera> ;-)
17:09:53 <scutigera> ML is underappreciated.
17:10:10 <scutigera> very easy to learn- type inferencing- strong type system.
17:10:42 <scutigera> and strict evaluation so you aren't wrestling with lazy induced space leaks.
17:11:30 <ion> vikaton: Both are useful, but many would probably say Haskell is more enjoyable.
17:12:28 <ion> I'm not sure how correct the idea is that learning both at the same time is a bad idea.
17:12:44 <ion> YMMV.
17:13:18 * hackagebot canteven-config 1.0.0.0 - A pattern for configuring programs.  http://hackage.haskell.org/package/canteven-config-1.0.0.0 (taphu)
17:13:20 * hackagebot moonshine 2.0.0.0 - A web service framework for Haskell, similar in purpose to dropwizard.  http://hackage.haskell.org/package/moonshine-2.0.0.0 (taphu)
17:13:22 * hackagebot halive 0.1.0.2 - A live recompiler  http://hackage.haskell.org/package/halive-0.1.0.2 (lukexi)
17:15:27 <scutigera> of course always depends on what you'll be doing.
17:15:44 <scutigera> i've done a decent amount of firmware work- so C is completely necessary.
17:16:30 <scutigera> and of course there's the problem that lots of high efficiency libraries are still in C, so if you are hoping to write an FFI to one...
17:16:37 <rasen_>  Is there a function to sort vectors?
17:18:18 * hackagebot canteven-log 0.2.0.0 - A canteven way of setting up logging for your program.  http://hackage.haskell.org/package/canteven-log-0.2.0.0 (taphu)
17:18:43 <scutigera> rasen_:
17:19:05 <scutigera> huh- you'd think there'd be one in the vector library -but not so apparentely.
17:19:49 <pavonia> rasen_: vector-algorithms has one
17:22:23 <ion> @google haskell sort vector
17:22:24 <lambdabot> https://hackage.haskell.org/package/vector-algorithms-0.3.2/docs/Data-Vector-Algorithms-Intro.html
17:22:49 <rasen_> Thanks!
17:23:56 <zed_> Leaving for tonight - thanks for the help : ) 
17:36:13 <structuralist> Is there a way to define a class with an associated type synonym that must itself be a member of that class?
17:37:17 <mpickering> structuralist: can you give an example of what you mean?
17:37:18 <shachaf> Does the obvious way not work?
17:37:32 <shachaf> Oh, it doesn't.
17:37:43 <c_wraith> You could put the requirement on the class members, though
17:38:36 <c_wraith> class Foo a where type Bar a :: * ; foo :: (Foo (Bar a)) => a -> (Bar a)
17:53:20 * hackagebot fold-debounce-conduit 0.1.0.0 - Regulate input traffic from conduit Source with Control.FoldDebounce  http://hackage.haskell.org/package/fold-debounce-conduit-0.1.0.0 (debugito)
17:55:05 <scutigera> i have data Foo = X | Y String | Z [Double]
17:55:14 <scutigera> i have [Foo], and i want to collect all the Z's
17:55:22 <lpaste_> structuralist pasted “Constrained associated type synonym problem” at http://lpaste.net/134942
17:55:43 <pavonia> scutigera: Use list comprehensions
17:56:07 <ion> foos ^.. traverse . _Z if you use lens
17:56:14 <structuralist> mpickering: just pasted example
17:56:18 <scutigera> no lens
17:56:40 <structuralist> c_wraith: doesn't quite work with default definitions (see lpaste) :/
17:56:52 <ion> A list comprehension will work very well, too.
17:58:00 <c_wraith> structuralist: in what way does it not work?  Compile error?  Runtime error?
17:58:04 <structuralist> compile error
17:58:15 <structuralist> "Could not deduce (ToString (Rep (Rep a)))"
17:58:54 <scutigera> [ ds | Z ds <- l ]
17:59:11 <structuralist> c_wraith: and if I throw that constraint in it gives "Could not deduce (ToString (Rep (Rep (Rep a))))"
18:01:00 <scutigera> holy crap
18:01:10 <scutigera> that worked on the first try. woooohooo
18:01:39 <scutigera> didn't know you could filter like that with a list comprehension.
18:03:26 <ion> You're able to do the same thing in a do block with the list monad.
18:03:37 <ion> (btw)
18:04:37 <ion> do Z ds <- l; pure ds
18:04:46 <pavonia> structuralist: You will get an infinite constraint chain like this because you use toString on every new Rep a value
18:05:01 <pavonia> structuralist: What is the purpose of Rep?
18:05:19 <structuralist> pavonia: yes, the intent is that eventually some "base Rep" will implement toString directly
18:06:01 <structuralist> Rep is so that you can define a new instance by deferring to a "representative" instead of implementing toString from scratch (this is a toy model of a more complicated situation)
18:18:51 <aupiff> I'm working with conduits and I'm curious about this situtation: say I am processing a stream of key-value pairs. each pair it a source for a sink that folds the list into a dictionary. `do dict <- source $$ sink; print $ lookup key dict` seems to try and lookup the key as soon as the dict is created and not when the full stream is consumed. is that true? is there a standard way of dealing with this situation
18:18:58 <aupiff> ?
18:27:18 <aupiff> I'm working with conduits and I'm curious about this situtation: say I am processing a stream of key-value pairs. each pair it a source for a sink that folds the list into a dictionary. `do dict <- source $$ sink; print $ lookup key dict` seems to try and lookup the key as soon as the dict is created and not when the full stream is consumed. is that true? is there a standard way of dealing with
18:29:58 <Cale> aupiff: Uh, dict is the result of that operation, so the operation will be finished by the time dict is available.
18:30:19 <Cale> aupiff: dict isn't going to change, regardless
18:30:33 <Cale> It's a constant value which is whatever the result of that operation was.
18:30:53 <Cale> (that operation being the execution of  source $$ sink)
18:33:21 * hackagebot halive 0.1.0.3 - A live recompiler  http://hackage.haskell.org/package/halive-0.1.0.3 (lukexi)
18:40:06 <aupiff> looks like  `lazyConsume` might be what I want
19:15:30 <slack1256> Is it possible to add a C interface to a haskell library? For example exposing a subset of Parsec to C?
19:15:36 <slack1256> Or does that make nosense?
19:16:16 <aupiff> slack1256: that's possible
19:16:25 <aupiff> https://wiki.haskell.org/FFI_Introduction
19:17:27 <aupiff> or this might be better: https://wiki.haskell.org/Calling_Haskell_from_C
19:18:15 <slack1256> :O I had the idea that the FFI was only on the C -> haskell direction
19:19:04 <slack1256> Mmm is this robust/practical? Any hackage package that main objective is "to be called from C not from other haskell code"?
19:22:20 <aupiff> slack1256: yes, I create a c ffi from my haskell code often when I make python bindings for my clients
19:34:22 <slack1256> aupiff: is that haskell code on hackage/github to study? or is something private?
19:37:37 <bucaran> is haskell's undefined somehow comparable to JS undefined?
19:39:05 <julie-ai> lol
19:39:31 <dolio> bucaran: I don't think so.
19:40:21 <bucaran> I thought so
19:40:43 <dolio> In JS you can test if something is undefined. You are not able to do that for Haskell's undefined.
19:41:03 <dolio> Barring various hacks that won't do it perfectly.
19:41:11 <bucaran> oh
19:41:14 <bucaran> I see.
19:42:25 <dolio> Haskell's undefined is more like an exception.
19:43:52 <bucaran> I hear the term lazy evaluation a lot in haskell, is this somehow similar to Lazy Loading, the design pattern, in which initializing an object's props, etc., is deferred to when it's used for the first time (after obj = new Class...)?
19:44:47 <bucaran> (obj = new Class //nothing rly happens; obj.myFunc() // constructor fires)
19:45:03 <dolio> Yes. Imagine every computation delayed doing anything until you actually needed the answer.
19:45:17 <dolio> It's sort of like that.
19:45:42 <bucaran> mmm cool. Can you create an infinite loop in haskell by mistake?
19:45:54 <dolio> Sure.
19:45:57 <bucaran> Oh
19:46:36 <Zemyla> Hmm. Is unsafeDupableInterleaveIO safe to perform if the only operation inside it is readMVar?
19:46:56 <bucaran> Are you familiar with the Generator/Iterator design pattern? is this a pattern often used in Haskell?
19:47:44 <dolio> Zemyla: Depends what you mean by safe. It won't accidentally block due to duplication, I think.
19:47:54 <dolio> If that's your concern.
19:48:33 <Zemyla> Well, I'm trying to figure out what other sources of unsafety there are in unsafeInterleaveIO.
19:49:22 <c_wraith> Zemyla: unsafeInterleaveIO can create values that "look" pure but whose value depends on execution order.
19:49:36 <c_wraith> Zemyla: that's generally considered unsafe behavior
19:49:38 <dolio> Oh. Well, I suspect dupable interleaving might break referential transparency.
19:49:46 <c_wraith> Zemyla: and readMVar can certainly do that.
19:50:00 <dolio> Normal interleaving won't.
19:50:11 <c_wraith> fun fact!  unsafeInterleaveST can do the same thing, but look even more pure!
19:50:43 <c_wraith> http://lpaste.net/110207  unsafeInterleaveST "fun"
19:50:44 <Zemyla> Well, basically what I'm trying to do is create a monad where the only things that it does are forks which only write MVars, and the aforementioned interleaved reads. Basically, a wrapper for IO that only allows parallelism.
19:51:09 <dolio> Are the MVars only written once?
19:51:58 <dolio> I.E. is this IVars?
19:52:06 <c_wraith> Zemyla: are you reinventing the Par monad?
19:52:25 <c_wraith> @hackage monad-par
19:52:25 <lambdabot> http://hackage.haskell.org/package/monad-par
19:52:57 <Zemyla> Basically, \act -> newEmptyMVar >>= (\mv -> forkIO (act >>= writeMVar mv) >> unsafeDupableInterleaveIO (readMVar mv))
19:54:04 <dolio> Ah, right. In that case it seems safe.
19:55:31 <dolio> The IVars I mentioned don't even require IO to read them.
19:56:15 <dolio> There is something like `takeIVar :: IVar a -> a` and `putIVar :: IVar a -> a -> IO a`.
19:57:00 <shachaf> How do you make IVars which you can check at compile-time?
19:57:31 <dolio> Linear types, I guess.
19:57:45 <c_wraith> I don't know that you can check that at compile time in Haskell.  I know that monad-par didn't bother with the static guarantees on its IVars
19:58:00 <dolio> Although if you're doing that, just use linear logic.
19:58:32 <dolio> Multiplicative disjunction is kind of like creating a take/put pair.
20:10:49 <dolio> bucaran: Generator/iterator is not exactly used in Haskell, because you can just produce a list, and if you produce it lazily, it is basically the same as a generator.
20:41:12 <boxfire> Hello, I am having trouble with cabal on this linux system. The 'ar' program is 'x86_64-pc-linux-gnu-ar', I set the ar-location in ~/.cabal/config to point to that, but it will not run that ar
20:41:35 <boxfire> is it really just expecting to find a naked 'ar' in a path?
20:42:21 <dmj`> boxfire: yea, I'd try putting it in your path
20:43:25 <ryantrinkle> i'm seeing an "Iface type variable out of scope" error; any suggestions on how to debug it?
20:43:44 <boxfire> dmj`: there is no 'ar'. There is only 'x86_64-pc-linux-gnu-ar', and for good reason. I will make cabal run in its own special path space with some symlinks, because it is special and needs it. Unlike the rest of the damn system
20:44:07 <ryantrinkle> (i'm using GHC 7.10.1, and there don't seem to be any open tickets regarding this issue)
20:44:32 <chipbuster_>  /msg NickServ INFO nick
20:51:44 <dmj`> boxfire: what flavor of linux are you using
20:53:15 <augur_> hmm
20:53:33 <augur_> () is the left unit of -> because   () -> A  ~  A
20:53:34 <boxfire> dmj`: in this case exherbo
20:54:02 <augur_> but i think -> doesnt have a right unit U such that   A -> U  ~  A
20:54:20 <boxfire> dmj`: but in any case on a system with multiple ar programs there is no way for Cabal to differentiate
20:54:47 <GLM> I've heard Haskell isn't good if you want the last 1% in performance. Is that when you move to C or something like Java?
20:55:43 <dolio> Java probably isn't good in that situation, either.
20:55:45 <augur_> i wonder then if there's a dual to ->, call it -<, such that   A -< Void  ~  A  but  there is no U such that  U -< A  ~  A
20:59:48 <boxfire> dmj`: in Cabal.Distribution.Simple.Program.Builtin arProgram = simpleProgram "ar"
21:00:18 <boxfire> the ~/.cabal/config ar-location only sets a search path
21:05:24 <c_wraith> GLM: haskell code that's been optimized for performance should be competitive with Java.  Especially since it became possible for a library to add primops...
21:05:52 <c_wraith> GLM: In fact, I'd expect well-optimized Haskell code to beat well-optimized Java a lot of the time.
21:06:15 <GLM> c_wraith:What about non-optimized Haskell?
21:06:27 <boj> how can i take the length of a bytestring and make sure the int value is only 4 bytes?
21:06:29 <tejing> augur_: If I'm thinking straight, what you're referring to would be a coexponential... and they don't exist in Hask
21:06:30 <c_wraith> GLM: there's no limit to how badly non-optimized code can run in any language
21:07:09 <GLM> Assuming it is idiomatic but not using the equivalents of gotos
21:07:15 <ryantrinkle> GLM: the haskell optimizer does a lot more than most others
21:07:35 <ryantrinkle> the structure of the language means that lots of stuff that wouldn't be an allowable optimization in other languages is allowed in haskell
21:08:15 <ryantrinkle> fusion, for example, means that if you have one function that produces a datastructure and another that consumes it, sometimes GHC can figure out how to weld the functions together so that the datastructure never needs to be produced at all
21:12:02 <boj> i figured it out, i was looking for fromIntegral
21:17:45 <augur_> tejing: hm! what are they programming-wise?
21:17:53 <augur_> my gut instinct is some kind of continuation
21:18:02 <augur_> like, a continue that never returnsd
21:19:36 <tejing> augur_: this may be helpful http://www.reddit.com/r/haskell/comments/qwklh/coexponentials/
21:23:34 <augur_> hmm hmm
21:23:52 <augur_> interesting
21:24:23 <augur_> so the CoExp r a b type in type theory is related to Store
21:24:49 <augur_> only its a kind of de-composed store
21:25:08 <augur_> which turns out to be a kind of delimited continuation, kind of
21:26:06 <augur_> but with r quantified, as in   CoExp a b = forall r. (a, b -> r)  its definitely more like a true continuation, because r could be instantiated to Void
21:26:31 <augur_> and in type theory we'd end up wanting to use a judgement # / inconsistent, instead of the quantified var
21:26:34 <augur_> hmm!
21:27:17 <augur_> G !- M : A    G, x : B !- #    ====>    G !- coexp(M; x.N) : CoExp A B
21:27:34 <augur_> no, not # but rather, J, for any judgment
21:28:12 <augur_> well i guess # is fine, whatever
21:28:55 <augur_> and then the elim should be    G !- M : CoExp A B   G, x : A !- N : B   ===>   G !- run(M; x.N) : #
21:29:28 <augur_> with computation   run(coexp(M; x.N), y.P)  ~>  [[M/y]P/x]N
21:29:54 <augur_> er, N : # in the intro
21:29:55 <augur_> hmm
21:30:00 <augur_> i guess that works
21:30:16 <augur_> so lets see, Void should be the B-side unit then
21:31:14 <augur_> so if we had  !- M : A  we could prove  !- N : CoExp A Void,    so we need to prove    G, x : Void !- #   thats right
21:31:38 <augur_> er,   x : Void !- abort(x) : #   rather
21:32:38 <augur_> but can we go from   M : CoExp A Void to A.. not with the elim rule i gave, it would indeed need to be : J for arbitrary J rather that just #
21:34:32 <augur_> but with that modification you'd get   !- M : CoExp A Void    x : A !- ?? : Void   ===>   !- run(M; x.??) : A
21:34:41 <augur_> but what is ??, i dont know
21:35:57 <augur_> so maybe that's a coexponential, but it's not dual to -> in the way i described, tejing
21:38:14 <tejing> augur_: that's why I said they don't exist in Hask...
21:45:04 <augur_> tejing: :)
21:45:21 <augur_> lots of people in the thread seem to say it exists in haskell
21:45:29 <augur_> and someone said it exists in haskell but not Hask
21:55:00 <antalsz> With template-haskell 2.9.0.0 and GHC 7.8.3, I can’t seem to use `lookupTypeName` to look up type operators… has anybody else seen this?
21:57:00 <johnw> antalsz: what happens?
21:57:18 <antalsz> johnw: It just returns `Nothing`.
21:57:27 <johnw> show me your invocation?
21:58:12 <antalsz> johnw: Just lpasting that :-)  http://lpaste.net/134951
21:59:33 <johnw> hmm
22:00:18 <johnw> i'm using 2.9.0.0 with 7.8.4, and haven't had any problems
22:00:34 <johnw> oh, no, I'm using 7.10
22:03:26 <gamegoblin> @pl \x y -> f $ x + y
22:03:26 <lambdabot> (f .) . (+)
22:03:51 <echo-area> johnw: Hi, I read your article /Running a fully local Hoogle/.  I am doing similar things.  Do you merge the docs of a developing project into HOOGLEDB?
22:04:27 <johnw> no, I don't
22:04:48 <johnw> also, I do it a completely different way now, using Nix
22:06:19 <[k-> @pl \x -> f . (+x)
22:06:20 <lambdabot> (f .) . (+)
22:07:03 <echo-area> johnw: Oh, thanks for the info, let me check it out
22:13:47 <edwardk> augur_: co-exponentials don't exist in hask
22:13:59 <augur_> ok
22:14:09 <edwardk> augur_: if you have arbitrary exponentials and coexponentials your entire category collapses to a poset, which is boring
22:14:30 <edwardk> so expect one structure or the other to be impoverished in any interesting category
22:15:04 <augur_> im not sure im asking about co-exponentials, but ok
22:15:46 <edwardk> ok, then what is the co-exp thing you are asking about? =)
22:16:17 <augur_> originally i was talking about a semi-dual to ->
22:16:33 <augur_> where () is the left unit of ->, is there a -< that has Void as its right unit
22:16:43 <edwardk> a real "dual" of such would be a co-exponential
22:16:44 <augur_> not that left/right matters
22:17:05 <augur_> its dual relative to partial unitality of ()
22:17:26 <edwardk> so far everything you're searching for is really a property of a co-exponential
22:17:51 <augur_> is it? ok :)
22:18:00 <edwardk> http://hackage.haskell.org/package/categories-1.0.7/docs/src/Control-Category-Cartesian-Closed.html#CoCCC
22:18:07 <augur_> so now i know it is indeed co-exponentials!
22:18:34 <augur_> i could imagine there might be some weird notion of co-unit of an operation but i dont know what it would mean. lol
22:18:44 <edwardk> it doesn't make any sense in a thing like set
22:19:00 <edwardk> because you can't have them and have any interesting set-like structure left
22:19:04 <edwardk> not with exponentials too
22:19:13 <augur_> u is a left-unit of f    <->   forall x. f(u,x) = x
22:19:20 <edwardk> Hask^op has co-exponentials of course
22:19:31 <augur_> c is a left-counit of f   <->   exists x. f(c,x) = c   ???
22:19:40 <shachaf> I bet Chu spaces have good coexponentials.
22:19:44 <augur_> or maybe    none x. f(c,x) = c   ?
22:19:52 <edwardk> chu spaces have everything =P
22:19:54 <augur_> or who knows :)
22:22:22 <edwardk> you get a coapplication morphism b -> coexp b a + a -- which suggests a kneejerk reading of it as '-'  b -> (b - a) + a    and cocurrying    (c -> a + b) <-> (coexp c b -> a)  which reads nicely when you treat it like '-' (and -> as <=) as well c <= a + b  implies c - b <= a
22:27:51 <edwardk> but that notation falls apart on further inspection, so while it is useful to get a mnemonic for those morphisms, i don't recommend sticking with it
22:35:10 <GGuy> Does anyone know why the following definition was decided upon?
22:35:12 <GGuy> instance Monoid a => Applicative ((,) a) where     pure x = (mempty, x)     (u, f) <*> (v, x) = (u `mappend` v, f x)
22:36:55 <GGuy> "(u, f) <*> (v, x) = (u `mappend` v, f x)" seems no obvious to me
22:38:15 <tejing> GGuy: it's the writer monad in disguise
22:41:29 <GGuy> Thanks tejing, that explains it. Caught me by surprise when I saw it.
22:41:51 <tejing> GGuy: yw :-)
22:49:33 <Hijiri> is there an instance of RandomGen faster than StdGen that I can just plug in
22:50:14 <peddie> Hijiri: https://hackage.haskell.org/package/mersenne-random-pure64-0.2.0.4/docs/System-Random-Mersenne-Pure64.html
22:50:45 <Hijiri> I looked at that one but I wanted to use splitting
22:50:58 <peddie> ah, no idea then, sorry
22:52:21 <Hijiri> I don't know too much about mersenne (or random gens in general), how terrible will my randoms quality become if I just use pureMT to generate a seed for a new generator?
22:52:24 <Hijiri> in lieu of splitting
22:53:11 <adarqui> anyone ever see this? trying to use ixset package, getting this: <command line>: can't load .so/.DLL for ... libHSsafecopy-0.8.5-ghc7.8.3.dylib, 9): Symbol not found: _templatezmhaskell_LanguageziHaskellziTHziSyntax_zdfMonadQ4_closure
22:53:15 <adarqui> stuff like that
22:53:27 <adarqui> if i take out the ixset dependency, everything goes back to working
22:54:47 <mzero> which version of Mac OS X?
22:56:18 <adarqui> yosemite, 10.10.3
22:59:19 <adarqui> i tried ixset-typed too, same deal.. looks like the template-haskell dependency might have something to do with it
23:08:21 <edwardk> Hijiri: "nobody knows"
23:09:36 <mzero> adarqui: ah - I had been investigating another .dylib loading issue earlier this week, but it was on 10.6 - and was not a bug on 10.10
23:10:06 <mzero> is there indication of a lib not being found, not just the symbol?
23:10:29 <adarqui> 1sec let me reload and i'll pastebin it, thanks mzero
23:11:26 <mzero> k
23:15:14 <adarqui> http://hastebin.com/okofacovaz.vhdl
23:16:20 <adarqui> so ya just the symbol not found i guess
23:16:42 <adarqui> when i've run into that it usually means i don't have something in 'exposed-modules:' section
23:17:00 <adarqui> i should just git clone them and try to build them separate
23:18:23 <mzero> well, it is loading the lib where it thinks that symbol should be - libHStemplate-haskell-2.9.0.0-ghc7.8.3.dylib
23:18:29 <mzero> and not finding it there
23:18:50 <mzero> so - I don't think it is a package exposure issue
23:21:04 <adarqui> i'm building each lib by itself.. so far so good.. maybe my cabal sandbox is wrecked
23:21:15 <mzero> OH
23:21:22 <mzero> no
23:22:12 <mzero> TH in 7.8.3 only has MonadQ1 thorugh MonadQ3 ... why is safecopy looking for MonadQ4?
23:24:06 <mzero> (i.e.: if you do nm -gU on the library it is loading, it has _templatezmhaskell_LanguageziHaskellziTHziSyntax_zdfMonadQ[123]_closure
23:24:11 <mzero> but not Q4!)
23:34:09 <mzero> hmmm... no idea - mostly as I'm not sure what that symbol refers to - other than something that is part of instace Monad Q
23:35:13 <adarqui> cool well thanks alot for helping.. ya it's weird havn't run into anything like this in a while.. everything's been working good ;d
23:35:39 <gamegoblin> Anyone here familiar with pipes?
23:36:44 <absence> gamegoblin: depends on what you mean by familiar :) just ask and we'll see
23:37:04 <gamegoblin> I have some code that looks like 
23:37:18 <adarqui> i actually plan on reading the pipes tutorial tomorrow.. word !
23:37:19 <adarqui> gn
23:37:28 <gamegoblin> handleProducer socket = forever $ do
23:37:29 <gamegoblin>   handle <- lift $ acceptHandle socket
23:37:29 <gamegoblin>   yield handle
23:37:53 <gamegoblin> I feel like there is a more pipes-ish way of doing the infinite looping bit
23:38:09 <gamegoblin> But I just don’t know it
23:39:34 <gamegoblin> I can of course change it to 
23:39:35 <gamegoblin> handleProducer socket = forever (lift (acceptHandle socket) >>= yield)
23:39:35 <eds> So, I am performing crossover in genetic programming. Is there a way for me to ensure that my if statement takes in a statement that returns boolean value? I am not able to achieve that. How do I apply the constraints such that while it does crossover it checks the return type of the node?
23:39:59 <gamegoblin> eds: can you paste some code?
23:40:18 <gamegoblin> eds: http://lpaste.net/new/haskell 
23:40:35 <eds> http://lpaste.net/134953
23:40:43 <eds> here
23:41:11 <gamegoblin> eds: am I looking at the if statements in evalL?
23:41:23 <eds> Yes
23:41:47 <gamegoblin> eds: any line in particular?
23:42:51 <absence> gamegoblin: does "handleProducer socket = lift (acceptHandle socket) >~ cat" do the trick?
23:43:15 <eds> I have not performed crossover yet. But I am pretty sure it would produce a tree where if (expr) then (stat) else (stat), the expr -'node' could return an int. How do I ensure that the expr-'node' always returns a bool?
23:43:25 <eds> 33
23:43:46 <absence> gamegoblin: i think it takes the cat (identity) pipe and stuffs your action into one end
23:44:43 <gamegoblin> eds: I don’t see where you’ve encoded a Bool type anywhere, I only see Base which wraps an Int
23:44:54 <gamegoblin> eds: oh, == 0 
23:45:18 <gamegoblin> eds: I guess I don’t see the problem you’re trying to solve
23:48:27 <eds> yeah right now I have defined <,>,== in such a way that they return 0 as false and 1 as true.
23:48:46 <gamegoblin> eds: if everything is an int, I don’t understand your issue with bools I guess
23:49:14 <eds> I would have to implement them as bool. This is just a hack.
23:50:20 <gamegoblin> eds: then are you asking how to implement them?
23:53:53 <eds> yeah. and then how would I make sure when I crossover, the test in if (test) would be Boolean.
23:54:48 <gamegoblin> eds: why are you implementing the domain-specific-language?
23:54:53 <gamegoblin> eds: are you trying to evolve programs?
23:55:22 <liste> eds use GADTs to embed data types in ASTs
23:56:17 <eds> yea. using GenProg class. Let me share my another code with you. Also, this is what I am trying to implement (look at 6.2.1) http://cswww.essex.ac.uk/staff/rpoli/gp-field-guide/62ConstrainingStructures.html#x1-431r1
23:56:41 <eds> http://lpaste.net/132328
23:56:50 <liste> @let data Expr a where { IntConst :: Int -> Expr Int; BoolConst :: Bool -> Expr Int; If :: Expr Bool -> Expr a -> Expr a -> Expr a }
23:56:51 <lambdabot>  .L.hs:146:28:
23:56:51 <lambdabot>      Ambiguous occurrence ‘Expr’
23:56:51 <lambdabot>      It could refer to either ‘L.Expr’, defined at .L.hs:145:1
23:57:03 <liste> @undefine
23:57:03 <lambdabot> Undefined.
23:57:10 <liste> @let data Expr a where { IntConst :: Int -> Expr Int; BoolConst :: Bool -> Expr Int; If :: Expr Bool -> Expr a -> Expr a -> Expr a }
23:57:11 <lambdabot>  .L.hs:143:28:
23:57:11 <lambdabot>      Ambiguous occurrence ‘Expr’
23:57:11 <lambdabot>      It could refer to either ‘L.Expr’, defined at .L.hs:142:1
23:57:31 <liste> @let data Ex a where { IntConst :: Int -> Ex Int; BoolConst :: Bool -> Ex Int; If :: Ex Bool -> Ex a -> Ex a -> Ex' a }
23:57:32 <lambdabot>  .L.hs:145:42:
23:57:32 <lambdabot>      Not in scope: type constructor or class ‘Ex'’
23:57:32 <lambdabot>      Perhaps you meant ‘Ex’ (line 142)
23:57:52 <liste> @define data Ex a where { IntConst :: Int -> Ex Int; BoolConst :: Bool -> Ex Int; If :: Ex Bool -> Ex a -> Ex a -> Ex' a }
23:57:53 <lambdabot>  .L.hs:145:42:
23:57:53 <lambdabot>      Not in scope: type constructor or class ‘Ex'’
23:57:53 <lambdabot>      Perhaps you meant ‘Ex’ (line 142)
23:58:19 <liste> @define data Ex a where { IntConst :: Int -> Ex Int; BoolConst :: Bool -> Ex Bool; If :: Ex Bool -> Ex a -> Ex a -> Ex a }
23:58:20 <lambdabot>  Defined.
23:58:43 <liste> let's have a Show on it to see something :D
23:58:46 <liste> @undefine
23:58:46 <lambdabot> Undefined.
23:58:51 <liste> @define data Ex a where { IntConst :: Int -> Ex Int; BoolConst :: Bool -> Ex Bool; If :: Ex Bool -> Ex a -> Ex a -> Ex a } deriving (Show)
23:58:52 <lambdabot>  .L.hs:146:14:
23:58:52 <lambdabot>      Can't make a derived instance of ‘Show (Ex a)’:
23:58:52 <lambdabot>        Constructor ‘IntConst’ has existentials or constraints in its type
23:59:11 <liste> doesn't work that way :(
23:59:14 <liste> @define data Ex a where { IntConst :: Int -> Ex Int; BoolConst :: Bool -> Ex Bool; If :: Ex Bool -> Ex a -> Ex a -> Ex a }
23:59:15 <lambdabot>  Defined.
23:59:37 <liste> > :t (If (BoolConst True) (IntConst 4) (IntConst 5))
23:59:38 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:59:46 <liste> :t (If (BoolConst True) (IntConst 4) (IntConst 5))
23:59:46 <lambdabot> Ex Int
23:59:57 <liste> :t (If (IntConst 8) (IntConst 4) (IntConst 5))
23:59:58 <lambdabot>     Couldn't match type ‘Int’ with ‘Bool’
23:59:59 <lambdabot>     Expected type: Ex Bool
23:59:59 <lambdabot>       Actual type: Ex Int
