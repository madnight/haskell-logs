00:34:01 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
00:34:01 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
00:43:15 <jle`> ikr :)
00:52:37 * hackagebot fay 0.23.1.6 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.23.1.6 (AdamBergmark)
01:25:40 <YellowOnion> are there implementations for div and mod for Integer (not Int)?
01:26:08 <YellowOnion> :t div
01:26:10 <lambdabot> Integral a => a -> a -> a
01:27:10 <jle`> YellowOnion: yes
01:27:15 <jle`> Integer is an instance of Integral
01:27:19 <jle`> so it has div and mod defined
01:27:47 <YellowOnion> jle`, I think GHC is assuming a type of Int and not Integer somewhere.
01:28:51 <jle`> if you give div an Integer, it will use div on Integers
01:28:59 <jle`> it's polymorphic in that sense, like +
01:29:08 <jle`> > (2 :: Float) + (4 :: Float)
01:29:10 <lambdabot>  6.0
01:29:15 <jle`> > (2 :: Integer) + (4 :: Integer)
01:29:17 <lambdabot>  6
01:29:33 <YellowOnion> jle`, ok my bad, its take that is the issue.
01:29:37 <YellowOnion> :t take
01:29:39 <lambdabot> Int -> [a] -> [a]
01:43:21 <YellowOnion> jle`, replaced take, with a takeWhile, which I think is more correct anyway.
01:43:41 <jle`> YellowOnion: nice :)
01:43:45 <jle`> there's also --
01:43:47 <jle`> :t genericTake
01:43:48 <lambdabot> Integral i => i -> [a] -> [a]
01:43:50 <jle`> from Data.List
01:43:53 <jle`> that takes Integer too
01:44:12 <YellowOnion> jle`, ahh thanks, I'll keep that noted.
01:44:35 <jle`> mhm. it's not very commonly used
01:53:06 <grohne> I have a haskell program that runs fine until I add +RTS -p -i1 -L200 -RTS, then it says "out of memory (requested 2097152 bytes)". any clue as to why this might happen? ulimit -v says unlimited
01:57:39 * hackagebot pandoc 1.14.0.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.14.0.1 (JohnMacFarlane)
02:02:22 <ttt_fff> when storing scheme stype sexps, what is the downside of having data Sexp = SexpInt | SexpString | SexpList [Sexp] | SexpNewline
02:02:32 <ttt_fff> so I can store the "\n\r" in the source code, so I can pretty print it better
02:02:50 <ttt_fff> it makes the interpreter slightly messier, but I get pretty printing in exchange
02:03:12 <tdammers> hum
02:03:23 <tdammers> violates "thou shalt not lie about thy data" IMO
02:03:28 <ttt_fff> otherwise reading a multiline sexp (as a single line) absolutely sucks
02:03:32 <ttt_fff> how so?
02:03:46 <tdammers> the newline isn't part of scheme semantics, it's just a low-level syntactic token
02:03:48 <tdammers> whitespace
02:04:05 <tdammers> I'd prefer to think in a direction where you add metainformation to your sexps
02:04:08 <ttt_fff> well, in the context is needing to pretty print things
02:04:10 <ttt_fff> hmm
02:04:13 <tdammers> something like
02:04:32 <tdammers> data AnnotatedSexp = Plain Sexp | FollowedByNewline AnnotatedSexp | ...
02:04:50 <tdammers> or data AnnotatedSexp = AnnotatedSexp [Annotation] Sexp
02:05:04 <tdammers> and then data Annotation = FollowedByNewline | ...
02:05:06 <pavonia> What is the semantics of a newline in s-expressions?
02:05:12 <ttt_fff> it's ignored
02:05:17 <tdammers> pavonia: whitespace. Ignored.
02:05:23 <ttt_fff> so when evaluating, it's like (1) filter out newlines, then (2) evaluate
02:05:44 <pavonia> Then don't store it in the data type O.o
02:05:47 <tdammers> I'm thinking annotations would work better in the long run
02:06:14 <tdammers> you could extend the system to also keep comments around, add line numbers, hint at syntax sugar that doesn't survive parsing, etc.
02:06:43 <ttt_fff> alriht gentlemen
02:06:43 <tdammers> e.g. you might parse 'foo and (quote foo) into the same AST, but you could use annotations to signal the difference
02:06:54 <tdammers> could even keep the raw source code around as an annotation
02:06:58 <tdammers> sky is the limit
02:07:05 <ttt_fff> so I should do something like "data Sexp a = SexpInt Int a | SexpString String a | SexpSymbol Symbol a | SexpList [Sexp] a " ?
02:07:13 <ttt_fff> then I can get arbitrary tabs, or is there a more elegant way of storing the tag 
02:07:28 <tdammers> that's one option
02:07:38 <ttt_fff> it's slightly ugly with the "a" repated all over the place
02:07:41 <ttt_fff> is there a more elegant option?
02:07:41 <tdammers> yeah
02:07:48 <ttt_fff> enlighten me
02:07:53 <ttt_fff> NOW
02:07:54 <tdammers> that's why I suggested a separate type for annotated sexp's
02:07:55 <ttt_fff> :-)
02:08:02 <tdammers> but, uhm, it won't work :x
02:08:09 <ttt_fff> well, it's weird for the Nested case of SexpList [Sexp]
02:08:13 <tdammers> indeed
02:08:18 <tdammers> that's where it breaks
02:08:42 <ttt_fff> thta's sorta important
02:08:43 <tdammers> we need type-level monads :(
02:08:49 <ttt_fff> you can have tags on high levle sexps
02:09:00 <ttt_fff> but not on any of the inner prts of sexps, making them rather ueless for line breaks :-)
02:09:11 <tdammers> indeed
02:09:18 <tdammers> you have to drag the `a` type along
02:09:24 <ttt_fff> alright
02:09:26 <ttt_fff> I'm going to sleep on this
02:09:32 <ttt_fff> if you think of osmething clever, tell lambdabot to msg me :-)
02:09:37 <tdammers> hehe
02:09:39 <ttt_fff> thanks for the discussion
02:12:31 <ClaudiusMaximus> which is worse, returning bad output or calling  error "..." ?   round  should really use  throw :: ArithException -> a  instead of either of those, right?  http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Real.html#line-202
02:12:40 * hackagebot hpack 0.2.0 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.2.0 (SimonHengel)
02:15:05 <dzack> anyone know if hdevtools ever got support for cabal sandboxes?
02:16:21 <bergmark> ClaudiusMaximus: both of those are terrible so I don't prefer one over the other :)
02:22:41 * hackagebot pandoc 1.14.0.3 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.14.0.3 (JohnMacFarlane)
02:23:08 <supki> dzack: how do you mean?
02:27:41 * hackagebot iconv 0.4.1.3 - String encoding conversion  http://hackage.haskell.org/package/iconv-0.4.1.3 (DuncanCoutts)
02:30:56 <grohne> are there any artificial memory limits in the ghc runtime? (i.e. the ghc runtime says "out of memory", 64bit, ulimit -v unlimited, machine is not swapping, no out of memory killer)
02:31:50 <dzack> supki: hmm well currently, it doesn't seem to pass along the ghc options cabal uses
02:32:10 <dzack> so it tends not to find most modules and/or requires manually specifying them
02:32:15 <dzack> see: https://mail.haskell.org/pipermail/haskell-cafe/2014-February/112870.html
02:33:52 <dzack> there seem to be some hacks, i.e. in vim to manually find and include all of the package.conf files (http://lpaste.net/94999)
02:35:47 <supki> right, it isn't pretty, but you can tell hdevtools to use the package db you want it to use with -g -package-db=...
02:36:15 <supki> there is some cabal integration in https://github.com/schell/hdevtools, it will probably save you some -g -I... options
02:36:24 <supki> but I personally find it really annoying
02:39:53 <dzack> yeah, and it sounds like it's still prone to breakage
02:40:24 <dzack> are there any other decent options? I can currently get incremental type-checking in my project with ghc-mod, but it takes 5-10 seconds
02:47:42 * hackagebot fft 0.1.8.1 - Bindings to the FFTW library.  http://hackage.haskell.org/package/fft-0.1.8.1 (HenningThielemann)
02:47:48 <Raydiation> btw, a monad is used for encapsulating stuff that is otherwise ugly to write, e.g. passing state around, right?
02:48:32 <Raydiation> pass some stuff in via bind and boilerplate work will be abstracted
02:50:37 <liste> Raydiation it depends (:
02:52:49 <liste> e.g. the functionality of Reader can easily be implemented without Monad, by passing the value around
02:53:19 <Raydiation> yep, but then standard functions will have issues right?
02:53:25 <Raydiation> because its a different type
02:53:45 <liste> of course you couldn't use functions that depend on Reader then
02:53:52 <liste> I'm not sure how it would work for IO, though
02:54:15 <liste> I guess you could use CPS for IO
02:54:20 <liste> it would get very, very messy
02:54:36 <liste> (CPS=Continuation Passing Style)
02:55:49 <liste> or something like Parsec
02:56:12 <liste> not sure about using Parsec without Monad, I mean
02:57:01 <liste> for grammars that require it
02:57:04 <ahihi> haskell used to have non-monadic IO, remember Response/Request? ;)
02:57:16 <mjrosenb> why does (<$>) have a different precedence from ($)?
02:57:50 <Raydiation> i dont fully get lift yet
02:57:53 <Raydiation> "Lifting is a concept which allows you to transform a function into a corresponding function within another (usually more general) setting."
02:58:14 <Raydiation> so if a function works on type a, i can lift it to also work on T a?
02:58:27 <liste> Raydiation yes if T supports it
02:58:36 <Raydiation> i see, thanks :)
02:59:00 <liste> :t fmap
02:59:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:59:17 <liste> it's a lifting funciton
02:59:21 <liste> function*
02:59:46 <liste> :t liftM
02:59:48 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
02:59:51 <Raydiation> ah right
03:00:04 <Raydiation> because it allows you to map over types
03:00:21 <Raydiation> got it :)
03:07:44 * hackagebot happstack-static-routing 0.4.2 - Support for static URL routing with overlap detection for Happstack.  http://hackage.haskell.org/package/happstack-static-routing-0.4.2 (GracjanPolak)
03:27:45 * hackagebot elm-init 0.1.2.0 - Set up basic structure for an elm project  http://hackage.haskell.org/package/elm-init-0.1.2.0 (justus)
03:32:14 <ttt_fff> is there a nice haskell auto-rebuild system? i.e. after a file on disk changes, I want haskell to run "cabal compile" ... and if it succeeds, then (1) kill existing "cabal run" and (2) run a new "cabal run"
03:32:35 <ttt_fff> this is all for dev, and all data is serialized to postgresql, so I'm okay with my serer randomly dying + restarting
03:54:21 <liste> ttt_fff which OS are you using? maybe you could achieve that with inotify-tools and shell scripting
04:11:00 <pacak> Is it possible to make ghc to compute stuff like (I# (word2Int# (clz# (__word 123456789012345)))) on compile time?
04:11:33 <hpc> you mean constant folding?
04:11:36 <pacak> yep
04:12:06 <thegladiator> /sbin/clea
04:13:44 <pacak> I'm doing some bit twiddling and countLeadingZeros leads to stuff like that ^ in generated core/asm. There are branches based on that which can be optimized away
04:25:29 <brbblnch> Hi
04:26:18 <brbblnch> How true is it to say that syntax constructs like pairs aren't useful in untyped lambda calculus as they can be "emulated" using only abstraction/application ?
04:32:01 <hyPiRion> brbblnch: it can be emulated yes. Untyped lambda calculus is turing complete, after all.
04:32:35 <hyPiRion> But "useful" is a loaded word :)
04:32:58 <liste> yeah, depends on what you use it for
04:33:22 <liste> but I guess nobody would use untyped lambda calculus for programming :D
04:34:39 <crucerucalin> Hello. Can you construct a function with the type (a -> b) -> b?
04:34:40 <hyPiRion> Well no, but people tend to transpile their langs down to a typed lambda calculus.
04:34:53 <crucerucalin> and no constraints
04:35:33 <hyPiRion> :t (\f -> f undefined)
04:35:34 <lambdabot> (r1 -> r) -> r
04:36:07 * hyPiRion shows himself out
04:38:58 <brbblnch> hyPiRion: By useful, I mean something like the fact that adding those doesn't make your system better, or maybe even that the properties of it with our without those constructs doesn't change
04:39:34 <thebnq> 'better' is just as loaded :P
04:39:50 <brbblnch> thebnq: Ok, more powerfull, then!
04:39:55 <brbblnch> *powerful
04:42:03 <fvgvxmpv1> :t ($ undefined)
04:42:05 <lambdabot> (a -> b) -> b
04:42:28 <crucerucalin> fvgvxmpv1: 10x
04:42:28 <brbblnch> But maybe if you added pairs/projection to untyped lambda calculus the system would have different properties (like losing confluence (which I think I know it doesn't))
04:42:40 <merijn> You can easily construct a function "(a -> b) -> b" that's just CPS/Cont monad
04:42:45 <crucerucalin> fvgvxmpv1: what about (a -> b) -> a?
04:43:15 <merijn> "cpsStuff :: a -> (a -> b) -> b" "cpsStuf 1 :: (Int -> b) -> b"
04:44:04 <bernalex> anyone know how scotty's 'file' work? I have a get request handler that does «file =<< liftIO (getDataFileName "data/src.tar.gz")» -- but in my tests where I want to assert the content type, I just receive "nothing" from doing get "/src", which is the path the handler is set up for.
04:44:12 <fvgvxmpv1> :t const undefined -- :p
04:44:13 <lambdabot> b -> a
04:45:46 <srhb> bernalex: Not sure I understand your question exactly, but file does not set the Content-Type
04:46:05 <bernalex> srhb: oh ok. what is a reasonable test to make sure that it serves something?
04:47:08 <srhb> bernalex: Not sure. I would assume it fails iff FilePath isn't there, and otherwise it works just fine.
04:47:53 <bernalex> srhb: well I want to test that the request handler does something. imagine if someone e.g. changes the path or whatever.
04:48:06 <srhb> bernalex: Probing the State directly is probably the only way, then.
04:48:14 <bernalex> srhb: what do you mean?
04:48:31 <srhb> bernalex: ActionM is a MonadState
04:48:38 <srhb> bernalex: Which is where the Response gets built.
04:48:46 <bernalex> srhb: oh ok. I have not done anything of that nature before.
04:49:07 <srhb> bernalex: So you should be able to use get in the ActionM monad to look at the Response object.
04:49:27 <bernalex> srhb: interesting. noted. thanks!
04:53:52 <bernalex> hm. how do I make a FileMode in the unix pkg?
04:54:43 <bernalex> or, for fear of x/y problem, how do I createDirectory sanely?
04:56:03 <bernalex> ohh
04:56:05 <bernalex> right
04:56:14 <bernalex> 0o755, not "0o755", of course
05:09:07 <aloiscochard> any haskell/nix users around? If I start a nix-shell with my nixifyed project, do I have to use a cabal sandbox or not? it seems to me that even without sandbox package should not be installed globally
05:10:34 <liste> aloiscochard there's no "globally" in nix
05:10:48 <liste> each nix-shell has its own environment
05:11:15 <Itkovian> aloiscochard what you install will be part of some top-level nix-expression that defines the environment
05:11:22 <Itkovian> so the rest will not be polluted
05:11:50 <aloiscochard> that is awesome! thanks liste and Itkovian 
05:12:14 <bernalex> n/b 52
05:12:16 <bernalex> ops
05:13:16 <Itkovian> aloiscochard http://cryp.to/slides.pdf can also give you some information. there is a youtube vid of the talk as well
05:13:17 <AleksejsWork> Hi, I'm just curious, why there's no an infix version of (,) function?
05:13:36 <liste> AleksejsWork a , b ?
05:13:45 <liste> > 1 , 2
05:13:46 <lambdabot>  <hint>:1:3: parse error on input ‘,’
05:13:50 <liste> > (1 , 2)
05:13:52 <lambdabot>  (1,2)
05:14:07 <Itkovian> > (,) 1 2
05:14:09 <lambdabot>  (1,2)
05:14:25 <AleksejsWork> yeah, but for example
05:14:30 <AleksejsWork> > 1 + 2
05:14:31 <lambdabot>  3
05:15:02 <AleksejsWork> works without parenthesis
05:15:40 <liste> I guess it's because , is not commutative
05:15:48 <liste> associative
05:15:49 <liste> *
05:15:57 <liste> (a,(b,c)) != ((a,b),c)
05:16:11 <AleksejsWork> makes sense
05:16:16 <AleksejsWork> thanks!
05:16:16 <liste> which is different from (a,b,c)
05:17:32 <liste> doesn't work in sections properly either, without -XTupleSections
05:21:09 <frerich_> liste: Not sure I understand that: 'a - (b - c)' is not the same as '(a - b) - c', yet there (-) is an infix function no?
05:21:48 <bernalex> srhb: I think I just want to set the filename & content-type in the handler. do you happen to know how to do that?
05:22:01 <frerich_> liste: I suspect '1,2' is not possible due to syntactic reasons  which require wrapping the call in parentheses.
05:22:17 <bernalex> srhb: nvm, the file docs refer me to exactly what I need. :)
05:24:30 <frerich_> liste: Looking at the 'aexp' production in https://www.haskell.org/onlinereport/haskell2010/haskellch10.html it seems that indeed the tuple syntax is baked-in, much like the list syntax is. It's not handled via the 'infix' productions.
05:26:01 <thebnq> let (×) = (,) in 1 × 2 --hehe
05:26:07 <thebnq> > let (×) = (,) in 1 × 2 --hehe
05:26:09 <lambdabot>  (1,2)
05:26:55 <juanpaucar> Does anybody know which is the type of an annotation? {-# ANN ... #-} i used the overloadedString pragma and i keep getting and ambiguos type error
05:30:45 <geekosaur> usually you want to add :: String
05:32:59 <juanpaucar> geeksaur: i doesn't work either on the message or the annotation itself
05:33:18 <juanpaucar> {-# ANN module "HLint: ignore Use camelCase" #-}
05:35:20 <geekosaur> {-# ANN module "HLint: ignore Use camelCase" :: String #-}
05:35:55 <juanpaucar> this is the error i get when using overloaded strings and th annotation http://lpaste.net/133698
05:36:08 <juanpaucar> using the :: String i get a parse error on '::'
05:36:51 --- mode: geekosaur set -o geekosaur
05:37:42 <thebnq> what about {-# ANN module ("HLint: ignore Use camelCase" :: String) #-}
05:38:13 <geekosaur> it does look like parens are needed, yeh
05:38:21 * geekosaur reading through that part of the manual
05:39:21 <juanpaucar> geeksaur: thanks a lot
05:39:28 <juanpaucar> it works now :)
05:52:51 * hackagebot fold-debounce 0.2.0.0 - Fold multiple events that happen in a given period of time.  http://hackage.haskell.org/package/fold-debounce-0.2.0.0 (debugito)
05:53:52 <fishburne529> So I have been readin the Monads section of 'Yet another haskell tutorial'. And I am having trouble understanding how so abstract things into a monad as the it is shown in section 9.3. I just want to now to identify things that can be abstracted into a monad and how to extract them...
05:56:23 <nkar`> kosmikus: what's the reason for borrowing code from GHC.Real to safeint?  I think that quot is implemented incorrectly, for instance.  e.g., for SI a `quot` SI b where a == minBound, all bs except 1 should result in an overflowError, but only -1 is being checked.
05:57:28 <mauke[> > minBound `quot` 3
05:57:30 <lambdabot>      No instance for (Show a0)
05:57:30 <lambdabot>        arising from a use of ‘show_M172958696090804534125367’
05:57:30 <lambdabot>      The type variable ‘a0’ is ambiguous
05:57:33 <mauke[> > minBound `quot` 3 :: Int
05:57:35 <lambdabot>  -3074457345618258602
05:57:51 * hackagebot dsh-sql 0.2.0.1 - SQL backend for Database Supported Haskell (DSH)  http://hackage.haskell.org/package/dsh-sql-0.2.0.1 (AlexUlrich2)
05:58:51 <nkar`> oh, wait, I guess I calculated incorrectly
06:14:19 <kasabian> hello, I have a problem instantiating `Arbitrary` (from QuickCheck) to a fixed length Vector (Vec n a)
06:16:00 <lpaste> kasabian pasted “Arbitrary instance for Vec” at http://lpaste.net/133700
06:17:01 <kasabian> if anyone could help me, this is what I've done so far: http://lpaste.net/133700
06:27:53 <bitonic> kasabian: 
06:27:56 <bitonic> that's almost right
06:28:07 <bitonic> you're missing one constraint, and explicit scoping of the type variables
06:28:35 <bitonic> kasabian: <http://lpaste.net/133700>
06:28:51 <bitonic> the errors that you get from not scoping the type variables are always a bit confusing
06:29:55 <bitonic> because the mentioned variables are automatically brought into scope as new type variables
06:30:33 <kasabian> bitonic: thanks you so much! :)
06:30:34 <bitonic> kasabian: also note that for those instances to work the `Nat` will have to be "known"
06:30:50 <bitonic> since if it's any `n` the type-checker won't be able to pick one of the instances
06:30:51 <kasabian> bitonic: what do you mean with known?
06:31:19 <bitonic> kasabian: well, you provided an instance for `Z` and an instance for `S n`, for any `n`.  but if you want to use that in a situation where you have `forall n`, GHC won't know which instance to pikc.
06:31:50 <bitonic> a better solution is probably to have `instance (Arbitrary a) => Arbitrary (Vec n a) where`, reify the `n` in `arbitrary` and build a `Vec` of the right length directly
06:32:15 <bitonic> you'll have to do that with singletons
06:32:20 <bitonic> or you can use `GHC.TypeLits`
06:37:53 * hackagebot cryptonite 0.2 - Cryptography Primitives sink  http://hackage.haskell.org/package/cryptonite-0.2 (VincentHanquez)
06:37:55 * hackagebot ltext 0.0.1.2 - Higher-order file applicator  http://hackage.haskell.org/package/ltext-0.0.1.2 (athanclark)
06:40:38 <kasabian> bitonic: thanks!
06:40:41 <kasabian> also
06:40:51 <kasabian> i think I'm having the problem you mentioned
06:41:08 <kasabian> No instance for (Arbitrary (Vec n0 a)) ...
06:41:26 <bitonic> kasabian: right, there are two solutions to that problem, as I said.
06:44:02 <kasabian> bitonic: I'm trying the first approach: forall a n. (Arbitrary a) => Arbitrary (Vec n a) where
06:44:40 <bitonic> kasabian: right, you will need some extra machinery to make that work
06:45:03 <bitonic> kasabian: if you could pattern match on the `n` it would be easy, but since you cannot do that in Haskell you'll need a bit more work :)
06:45:38 <bitonic> kasabian: what you want is a type-class that allows you to discriminate on that `n`
06:47:09 <kasabian> bitonic, thanks, I'll try to figure it out :)
06:48:51 <bitonic> kasabian: the idea is that you want to give GHC a tool to discriminate between `Z` and `S`.  You'll end up in a situation where you'll have `instance (Arbitrary a, KnownNat n) => Arbitrary (Vec n a)`, where `KnownNat` is the typeclass that let's you do that discrimination
06:51:38 <albeit> In a ".cabal" file, is there a way to build just one of two possible executables depending on command line arguments or otherwise?
06:52:53 <m1089> sqexit
06:53:13 <kasabian> bitonic: so, should I make an instance of KnownNat for my Nat?
06:53:41 <bitonic> kasabian: well you shouldn't use `GHC.TypeLits.KnownNat`.  that is for the type literals built in GHC
06:54:33 <kasabian> bitonic: oh, I see
06:54:34 <breadmonster> Hi everyone.
06:55:04 <breadmonster> I have a Parsec question.
06:55:06 <hexagoxel> albeit: `cabal build COMPONENT`, or add flags and set buildable flag, so you can define what to build at configure-time
06:55:39 <breadmonster> If I have something like `p1 <|> p2 <|> p3` will Parsec ensure that p1 and p2 fail before p3 is tried?
06:55:51 <hexagoxel> albeit: for an example of the latter, look at https://hackage.haskell.org/package/multistate-0.3.0.0/multistate.cabal
06:56:37 <breadmonster> Because I'm trying to parse indentation in a whitespace sensitive language.
06:56:48 <breadmonster> And p1 is space, p2 is tab, and p3 is any character.
06:57:10 <bitonic> breadmonster: yes, p1 and p2 will be tried first
06:58:18 <breadmonster> bitonic, Fantastic.
06:59:02 <thebnq> breadmonster: it will also consume input even if it fails
06:59:08 <bitonic> breadmonster: note that it's almost always better to simulate lexing using the appropriate combinators
06:59:23 <breadmonster> bitonic, what are those combinators?
06:59:27 <bitonic> breadmonster: since, as thebnq says, <|> is not properly backtracking
06:59:37 <breadmonster> thebnq, How do I prevent consumption of input on failure AND success?
06:59:57 <bitonic> breadmonster: basically you want something that backtracks properly while still giving good error messages for your "tokens"
07:00:26 <bitonic> breadmonster: I tend to use the `parsers` library to do this stuff, I'm not too familiar with the facilities `parsec` offers, but you should be aware of how <|> behaves
07:00:40 <breadmonster> bitonic, yeah I know <|> doesn't backtrack.
07:00:49 <breadmonster> Is there a combinator for backtracking by default?
07:01:03 <albeit> hexagoxel: That is perfect, thanks!
07:01:14 <bitonic> breadmonster: the basic idea is to have (try (tokenParser <* spaces) <?> "name of token")
07:01:44 <bitonic> e.g. `(try (binaryOperator <* spaces) <?> "binary operator")` or whatever
07:02:00 <breadmonster> bitonic, I have something a little different.
07:02:10 <breadmonster> So I'm counting indentation at the start of a line in Python.
07:06:09 <breadmonster> `indentation = liftA2 (:) ((char ' ' >> return Space) <|> (char '\t' >> return Tab)) ((p >> return []) <|> indentation)`
07:07:29 <breadmonster> Where I want p to fail if the next character is not a space or tab.
07:10:50 <bitonic> breadmonster: but you already know that the character is not a space or a tab, if you reach that.
07:11:29 <breadmonster> :t oneOf
07:11:31 <lambdabot> Eq a => [a] -> Splitter a
07:11:41 <breadmonster> :info oneOf
07:11:58 <dramforever> * thinks lambdabot has no info
07:12:03 * dramforever thinks lambdabot has no info
07:12:12 <dramforever> @help info
07:12:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:12:19 <dramforever> @help @info
07:12:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:14:56 <breadmonster> `indentation = liftA2 (:) ((char ' ' >> return Space) <|> (char '\t' >> return Tab)) ((notFollowedBy whitespace >> return []) <|> indentation)`
07:14:58 <breadmonster> Got it!
07:17:10 <dramforever> breadmonster: ouch my eyes...
07:17:21 <thebnq> breadmonster: i think you could just use `many`
07:17:41 <dramforever> and what??? this thing has recursion???
07:26:18 <Lafry> Is there a way to calculate "fib((sum ( take 2 xs )) : xs)" wihout the parens ?
07:27:13 <kasabian> try this: fib $ sum (take 2 xs) : xs
07:28:21 <Lafry> That works, thanks
07:28:28 <Lafry> $ pipes through the value?
07:29:01 <mniip> Lafry, $ is an operator
07:29:04 <kasabian> $ forces the evaluation of the second argument before applying the first
07:29:07 <mniip> which does absolutely nothing
07:29:10 <rasen> f $ x = f x
07:29:17 <mniip> only establishes precedencce
07:29:23 <rasen> kasabian: nope, that was $!
07:29:26 <geekosaur> kasabian, no, that is $!
07:29:32 <mniip> f x y means (f x) y
07:29:36 <kasabian> rasen: yes, I was wrong
07:29:40 <mniip> f $ x y means f $ (x y) which is f (x y)
07:29:47 <geekosaur> $ is just normmal application, (a) made visible (b) with low precedence instead of highest (c) associating rightward
07:34:49 <dan64> This site has the following "golden rule of indentation": "Code which is part of some expression should be indented further in than the beginning of that expression (even if the expression is not the leftmost element of the line)"
07:34:59 <dan64> What is meant by "even if the expression is not the leftmost element of the line"?
07:35:33 <geekosaur> think a parenthesized thing in the middle that is long enough to be split onto another line
07:36:02 <geekosaur> the continued expression should be indented beyond the left parenthesis opening that expression, according to that site's style
07:36:31 <tdammers> which, given nitpicking definitions of "indenting", is logically impossible
07:37:06 <tdammers> because indents are measured in shift widths, while "position of left parenthesis" is an indent in shift widths plus a text length in characters
07:37:17 <tdammers> so you'd have to indent *and* align
07:37:23 <tdammers> tabs and spaces
07:37:25 * tdammers runs away
07:41:44 <RaceCondition> how should one reason about writing an interpreter for a strict language in Haskell?
07:42:21 <RaceCondition> I'm going through PLAI and am wondering what would happen if I rewrote the sample code in Haskell (I'm aware you can force Haskell to be strict to a large extent)
07:43:16 <byorgey> RaceCondition: the semantics of the language being interpreted have very little to do with the semantics of the language being used to write the interpreter, unless you are making an embedded domain-specific language
07:43:38 <rasen> RaceCondition: idk, just enforce argument evaluation before function application?
07:44:17 <mauke[> I got a bit of accidental laziness into my interpreter
07:45:43 <Tuplanolla> What is the best way to come up with an element not in a Data.Set? Something like new :: Constraint a => Set a -> Maybe a.
07:45:58 <kasabian> bitonic: I couldn't do the class for KnownNat, I don´t know how to split it in cases inside the Arbitrary instantiation
07:47:19 <RaceCondition> byorgey: I though there could be some "interference" if the interpreter itself behaves lazily... and the hosted language is supposed to be strict at all times
07:47:58 <byorgey> Tuplanolla: I would just make a type class    class Fresh a where   fresh :: Set a -> Maybe a.     Coming up with a new element not in a given set seems like a fairly fundamental operation, I can't think of a sensible way to break it down into simpler ones
07:48:00 <RaceCondition> rasen: why just function argument evaluation?
07:48:22 <Tuplanolla> What if it's already an instance of, say, Bounded, byorgey?
07:48:31 <Tuplanolla> Bounded and Enum, that is.
07:49:07 <mauke[> > [1.5 .. ] :: Double
07:49:08 <lambdabot>      Couldn't match expected type ‘Double’ with actual type ‘[Double]’
07:49:09 <lambdabot>      In the expression: [1.5 .. ] :: Double
07:49:10 <byorgey> RaceCondition: if the hosted language is strict then the data dependencies in the interpreter will reflect that, so things will end up getting evaluated in the correct order
07:49:12 <mauke[> > [1.5 .. ] :: [Double]
07:49:13 <lambdabot>  [1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5,17.5...
07:49:51 <RaceCondition> byorgey: ah ok, I think I can see what you mean
07:50:08 <RaceCondition> but strictness isn't only about the order of things, is it?
07:50:45 <byorgey> Tuplanolla: as mauke[ demonstrates there are lots of problems with Enum.  Even if there weren't, for particular types a there might be much more efficient ways to pick a fresh value than listing all the values and finding one that isn't in the set
07:50:50 <albeit> In a cabal file, is there a way to set an option, then add more to it later? Like "ghc-options: -O2" and later "ghc-options: -threaded", and have both O2 and threaded enabled?
07:50:59 <byorgey> RaceCondition: you're right, it's not.
07:51:44 <rasen> why not?
07:52:49 <Tuplanolla> I see.
07:52:56 <byorgey> it's about which things blowing up will cause other things to blow up
07:52:56 <lpaste> bitonic pasted “kasabian” at http://lpaste.net/133703
07:53:08 <byorgey> which I guess you could think of as being about ordering.
07:53:16 <bitonic> kasabian: see above -- sadly I don't have time to explain it well now, I figured the code would be useful anyway
07:53:20 <Tuplanolla> It's a shame there isn't some kind of Finite typeclass for drawing a new element.
07:53:27 <RaceCondition> byorgey: how about side effects?
07:53:43 <byorgey> RaceCondition: what about them?
07:53:49 <RaceCondition> or, because they have to be mapped to Haskell's IO under the hood anyway, it'll work out correctly?
07:54:03 <byorgey> yes
07:54:32 <byorgey> when you map them to IO you will of course do it in the order they should happen according to the semantics of the language being interpreted.
07:54:45 <RaceCondition> yeah
07:55:19 <RaceCondition> however, for example for strictly evaluating function arguments, I'll still have to resort to ! or seq in Haskell, right?
07:56:23 <rasen> yep
07:56:43 <breadmonster> Hey everyone.
07:56:49 <breadmonster> Does anyone use Conduit often?
07:56:51 <lpaste> bitonic annotated “kasabian” with “kasabian (annotation)” at http://lpaste.net/133703#a133704
07:56:53 <byorgey> RaceCondition: my intuition tells me that you won't need to do that.  But it is only intuition.
07:56:55 <breadmonster> I'm trying to figure out what it's used for.
07:57:03 <bitonic> kasabian: actually the posted code was slightly wrong, see new annotation
07:57:27 <byorgey> RaceCondition: I think you can just start writing your interpreter and think carefully about it on the way.  It shouldn't mean you will have to completely redesign your approach.
07:58:41 <joeyh> albeit: that just works! I think when I asked about that, someone told me cabal files are a monoid :)
07:59:22 <albeit> joeyh: ha great, thanks
08:00:22 <RaceCondition> byorgey: ok, Debug.Trace will help me
08:01:22 <kasabian> bitonic: sorry for that, thank you very much!
08:01:48 <kasabian> bitonic: it throws me this, though : No instance for (KnownNat n0) arising from the use of quickCheck
08:05:11 <bitonic> kasabian: well, now you have to add a `KnownNat` instance wherever you want to use the Arbitrary instance.
08:05:57 <nkar`> is there a way to set precedence for a local binding?
08:07:37 <maerwald> Are there any papers about how to _add_ effects to functions in haskell without major refactoring? I am thinking of things like game engine development and adding timing functionality to existing algorithms or whatnot. Afais this is a bigger problem in haskell than in languages with open IO where the effects are rarely expressed by the return types anyway.
08:07:55 <kasabian> bitonic: something like this? compare :: (KnownNat n) => Vec n Binder -> Vec n Binder -> Bool    ...   this also throws the same error
08:07:55 <maerwald> The two papers about game development in haskell do not really address this issue.
08:08:04 <maerwald> *the two papers I found
08:11:23 <hodapp> Does some typeclass exist that is something like Bits, but just for something like bitwise and/or?
08:11:27 <breadmonster> bitonic, do you have any experience with conduit?
08:11:37 <voidzero> wondering if anyone knows of an active dutch haskell user group
08:11:57 <hodapp> I already have an Enum... perhaps I should just define it based on that
08:13:24 <athan> Is it possible to construct a VarE expression, using a String data as an identifier with TemplateHaskell?
08:14:12 <rasen> athan: see mkName
08:14:42 <athan> Thanks rasen :)
08:15:06 <bitonic> kasabian: yeah, like that.
08:16:05 <kasabian> bitonic: throws the same error :(
08:16:21 <bitonic> kasabian: can you post the code?
08:16:25 <derek1> Hey, could anyone kindly tell me why my Decimal -> Base64 converter isn't working? Many thanks! http://pastebin.com/5qeFcj5h
08:16:52 <derek1> It compiles, but doesn't return the correct Base64 string.
08:17:28 <Javran> what are alternative approaches to combine monads other than using transformers? could someone point me to some related articles?
08:18:26 <nolrai666> Gah, now gtk2hs-buildtools-0.13.0.3 wont install because it cant find alex.
08:20:05 <SrPx> I understand what arrows are. I understand how they are implemented. But I'm struggling to understand what they are *useful* for. This tutorial, for example: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows was great. Until the part it should provide examples.
08:20:10 <rhaps0dy> What do I do when "cannot satisfy -package-id", and then a ton of packages iwht hex strings is listed afterwards?
08:20:30 <kasabian> bitonic: http://lpaste.net/4128450559235588096
08:20:31 <rhaps0dy> SrPx: you may want to check out jle`'s Auto series
08:20:45 <SrPx> Then it just said: there is the function instance for arrows (useless...) and then there is this 5-pages long description of how arrows can be used to improve a little bit the efficiency of parses and... well, that's the only example. Bye
08:20:48 <rhaps0dy> gimme a sec
08:21:01 <SrPx> okay
08:21:10 <nolrai666> Mostly I see people using aplicative instead these days.
08:21:12 <kadoban> derek1: At a guess, overflow? You know Int is 32/64bit, right?
08:21:14 <liste> SrPx how about opaleye
08:21:15 <liste> ?
08:21:22 <rhaps0dy> SrPx: http://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and
08:21:31 <athan> rasen: Do you know of a way to turn obscure data into an Exp? Like Data.Text, for example?
08:21:56 <kasabian> bitonic: if not, I'll try to define something like VecToList and use that with generated lists
08:22:10 <SrPx> If arrows are "as useful as monads" and can replace them, what I want is to see the arrow instance for lists, for state, for IO, for maybe, and so on. Small examples, not a huge, complicated instance involving parsers... 
08:22:19 <SrPx> rhaps0dy: thank you :) 
08:22:45 <rhaps0dy> SrPx: hope it's useful :)
08:23:00 <SrPx> lets see :)
08:23:25 <bitonic> kasabian: that code does not seem to be self-contained to Arbitrary and Vec
08:23:31 <bitonic> it certainly doesn't compile
08:23:36 <athan> SrPx: Any monad can be a (Kleseli) arrow
08:23:38 <athan> (sp?)
08:23:49 <rasen> athan: can you provide example?
08:23:54 <kadoban> I think there's another 'k' somewhere near the end, heh.
08:24:12 <kasabian> bitonic: yes, its a bigger code but i can't paste all of it
08:24:19 <kasabian> bitonic: it compiles
08:24:54 <exio4> athan: Kleisli 
08:25:02 <athan> rasen: Sure, one second
08:25:10 <athan> exio4: x_x always gets me
08:25:15 <bitonic> kasabian: so what goes wrong?
08:26:06 <kasabian> bitonic: when i call compare, it throws me this: No instance for (KnownNat n0) arising from the use of quickCheck
08:26:20 <bitonic> kasabian: so it does not compile :P
08:26:24 <athan> rasen: So here is my syntax tree that I'm converting into raw haskell: https://github.com/ltext/ltext/blob/master/src/LText/Internal/Expr.hs#L25
08:26:34 <bitonic> kasabian: you need to propagate those KnownNat constraints to the top
08:26:35 <kasabian> bitonic: sorry, when i call quickCheck compare
08:26:43 <athan> rasen: And here is my conversion function using TemplateHaskell: https://github.com/ltext/ltext/blob/master/src/LText/Internal/Expr/TH.hs#L12
08:27:10 <athan> The last case is where I'm suck - I don't know how I could take raw LT.Text data and turn it into an Exp
08:27:39 <bitonic> kasabian: in this case the problem is that the `Testable` instances are not good for your use case
08:27:48 <bitonic> you probably want to build a `Property` explicitely
08:28:14 <kasabian> bitonic: thanks for the help :) !
08:28:35 <kasabian> bitonic: I'd probably do something like listToVec
08:28:43 <athan> rasen: I wonder if the text package provides something for this, one second
08:29:13 <bitonic> kasabian: you can also make a datatype `data VecWithLength a = forall n. KnownNat n => VecWithLength (Vec n a)` 
08:29:22 <bitonic> and then an `Arbitrary` instance for that
08:30:01 <nolrai666> Why has installing leksah been so insanely hard..
08:30:17 <kasabian> bitonic: nice! I'll try it
08:30:45 <bitonic> kasabian: obviously this doesn't work if you want to generate, say, two vectors of the same length.
08:31:55 <rasen> athan: the stupidest thing I can think of is to deconstruct Text in String and then apply pack in TH
08:32:09 <athan> That's what I was going to do haha
08:32:18 <athan> meh
08:32:26 <maerwald> derek1: it doesn't look like you properly work on binary level
08:33:38 <bitonic> kasabian: the crucial thing to understand here is that if we want to work with the length encoded at the type-level, we need some constraints on the type parameter `n`.  if you quantify `n` with no constraints, you can't do much with it.
08:33:42 <nolrai666> So cabal install usually installs prerequisites right?
08:34:54 <nolrai666> So why did "cabal install gtk2hs-buildtools" fail but "cabal install alex && caball install happy && cabal install gtk2hs-buildtools" succeed?
08:35:30 <athan> benzrf: ping
08:35:46 <jeltsch> Hi,  I just installed GHC  7.10.1 and then cabal-install 1.22.4.0. When I actually use cabal-install, it regularly hangs. Anyone experiencing the same?
08:36:07 <jeltsch> cabal-install will install a few dependencies and then just stop.
08:37:40 <jeltsch> It seems that cabal-install gets stuck at certain package downloads.
08:38:28 <nolrai666> jeltsch: that is very strange.
08:39:09 <jeltsch> Maybe HackageDB has a problem. It was offline a couple of minutes ago. However, it seems to be up and running again.
08:39:20 <nolrai666> Though my cabal seems to be having issues too..
08:39:29 <nolrai666> but it doesn't hange, it ends.
08:39:44 <lpaste> amontimur pasted “ClassyPrelude.Conduit” at http://lpaste.net/6278894092537561088
08:39:54 <nolrai666> *hang
08:40:29 <amontimur> can somebody tell me what im doing wrong? im working through the conduit intro and wanted to use classyprelude. http://lpaste.net/6278894092537561088
08:40:42 <jeltsch> nolrai666: It seems to be quite nondeterministic: two tries ⇒ hangs at the first dependency; third try ⇒ installs the first dependency, hangs at the second
08:41:49 <athan> benzrf: New version has template haskell function... that dumps raw string data into your haskell files :D
08:43:02 * hackagebot ltext 0.0.2 - Higher-order file applicator  http://hackage.haskell.org/package/ltext-0.0.2 (athanclark)
08:48:02 * hackagebot ltext 0.0.2.1 - Higher-order file applicator  http://hackage.haskell.org/package/ltext-0.0.2.1 (athanclark)
08:48:04 * hackagebot tubes 0.1.0.0 - Effectful, iteratee-inspired stream processing based on a  free monad.  http://hackage.haskell.org/package/tubes-0.1.0.0 (gatlin)
08:51:59 <jeltsch> I have tried now to run cabal-install with --verbose=3. It gets a 301 Moved Permanently from the server. It then tries to follow the redirect, shows “Recovering connection to hackage.haskell.org”, and hangs.
08:53:37 <jeltsch> I think I will give up for today. I am too tired to investigate strange cabal-install bugs. :-( 
08:58:27 <joeyh> doesn't cabal still use the HTTP library? IIRC when I used that I had problem with redirects
09:01:38 <jeltsch> joeyh: Hmm, this doesn’t sound good. I have just written an e-mail to the libraries mailing list, asking for help.
09:01:45 <jeltsch> Okay, I have to go now.
09:26:31 <osa1> you know what would be seriously awesome? a GHCi that listens to a socket for incoming commands and writes outputs to same socket.
09:27:26 <bitemyapp> osa1: ide-backend kinda is that.
09:29:33 <osa1> wow I didn't know.. I should have a look at that sometime
09:29:46 <DerDer> Is there any way I can compile my project, that's using the win32 library, on my unix system?
09:29:47 <hiptobecubic> You could probably fake it ok with tmux
09:29:55 <bitemyapp> osa1: it's a recent open sourcing by fpcomplete.
09:30:58 <literon> Hello
09:32:51 <johnw> bitemyapp: it was written entirely by Well-Typed, btw
09:33:08 <literon> Is there a monad transformer, which instead of performing binds, just records them and let me execute them later?
09:33:22 <johnw> FreeT
09:33:32 <johnw> or, you may just want Free
09:33:50 <literon> But that seems to execute the binds, no?
09:34:13 <johnw> it does not
09:34:34 <literon> I would need something like the Free in scalaz, which has the explicit FlatMap constructor
09:38:12 <johnw> a >>= f >>= g will be encoded as Free ((>>= g) <$> (Free ((>>= f) <$> (Pure <$> a))))
09:38:32 <johnw> the binds are not "executed" until you write an evaluator to determine how/when/where you wish to execute them during your iteration
09:47:36 <ozgura> does anyone know of a function to check if a file contains binary or plain text?
09:47:54 <ozgura> it's OK if it only works for POSIX
09:49:05 <kadoban> ozgura: You understand that that's at best going to be heuristic?
09:50:07 <liste> ozgura plain text as in UTF8/Latin1 ?
09:50:20 <liste> or ASCII?
09:50:35 <c_wraith> or Big5?
09:51:19 <liste> what do you need it for?
09:51:24 <c_wraith> or..  that one I can't remember the name of that consists of lots of Es, Bs, Cs, Ds, and an I
09:51:27 <ozgura> I thought something like the output of  tools like "file" on linux would be helpful
09:51:31 <liste> EBCDIC=
09:51:31 <liste> ?
09:51:36 <c_wraith> yeah, that one
09:51:36 <ozgura> c_wraith: :)
09:52:30 <c_wraith> someone came in here asking how to read a certain kind of file
09:52:35 <c_wraith> turned out it used that for text
09:52:39 <liste> ozgura file uses libmagic
09:52:40 <ozgura> for example, if the output of "file foo.hi" is "data", where foo.hi is a ghc generated interface file
09:52:47 <kadoban> Or going the other way, a binary encoded list of the numbers that all happen to be less than 128. "What are you going to use it for?" seems like a very important question.
09:53:23 <ozgura> libmagic.. by the sound of that it looks like I should avoid this
09:53:32 <liste> maybe you could write a simple FFI for libmagic, or use inline-c
09:54:36 <ozgura> liste: I think I can avoid that for what I want to do at the moment
09:54:39 <ozgura> thanks everyone!
09:58:40 <infandum> I'm trying to install the newest cabal-install on Ubuntu 14.04. Using cabal v1.20.0.3, I get a sigsegv. Using cabal v1.16.0.2 (from the official ubuntu repositories) I get random errors, from not found files to not recognized symbol '`'s. What is going on?
09:59:26 <infandum> Now it says 'memptx' is not a visible method of class Monoid. Huh?
09:59:35 <infandum> Is this computer failing or something?
10:00:54 <ion> Code saying mempty and comipler seeing memptx sounds like a bit flip in memory.
10:01:00 <ion> Run memcheck86+
10:01:09 <ion> memtest86+ that is
10:02:23 <infandum> Interesting
10:02:40 <infandum> so there was always an issue where sometimes a file would have weird characters in it, seemingly at random
10:02:48 <infandum> like @ instead of A or whatever
10:02:53 <infandum> usually one ascii digit off
10:02:55 <infandum> hmm
10:02:58 <infandum> let me check it out
10:04:42 <gracjan> http://www.reddit.com/r/haskell/comments/383p16/month_in_haskell_mode_may_2015/
10:04:42 <srhb> Dem cosmic radiation bugs. :<
10:08:04 <linkages> any idea whats wrong in that definition ? 
10:08:05 <linkages> data C Int  Int  =  N | Node Int Int (C Int Int) deriving (Show)
10:08:10 * hackagebot json-autotype 1.0.2 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-1.0.2 (MichalGajda)
10:08:34 <linkages> Unexpected type `Int' where type variable expected
10:08:34 <linkages>     In the declaration of `C Int Int'
10:08:39 <linkages> give this error
10:09:04 <Haskellfant> linkages: the Int on the left doesn't make sense. Either you want to parametrize your type over some arbitrary variable a or if you want to fix it to Int that is no longer a type variable
10:09:14 <Haskellfant> so use data C = N | Node Int Int (C Int Int)
10:09:24 <Haskellfant> or Data C a a = N | Node a a (C a a)
10:09:44 <linkages> thanks a lot Haskellfant 
10:10:53 <derek1> I'm having trouble putting an integer in a string. In C# I would do Console.WriteLine("This is the number 1: {0}", 1) how can I do something similar in haskell?
10:11:21 <Haskellfant> > putStrLn ("This is a number 1: " ++ show 1)
10:11:23 <lambdabot>  <IO ()>
10:11:31 <Haskellfant> that should do the trick
10:11:41 <derek1> Can you do that with errors as well?
10:11:41 <Haskellfant> > "This is a number 1: " ++ show 1
10:11:42 <lambdabot>  "This is a number 1: 1"
10:11:55 <derek1> > error "This is number 1: " ++ show 1
10:11:56 <lambdabot>  "*Exception: This is number 1:
10:12:02 <derek1> :(
10:12:12 <Haskellfant> you need to use parentheses
10:12:21 <derek1> ah I see
10:12:23 <derek1> Silly mistake
10:12:25 <Haskellfant> error ("This is a number 1 " ++ show 42)
10:12:32 <Haskellfant> > error ("This is a number 1 " ++ show 42)
10:12:34 <lambdabot>  *Exception: This is a number 1 42
10:14:14 <[[derek]]> Thanks :)
10:15:09 <mizu_no_oto> [[derek]]: function application binds tighter than anything else.  This is why $ exists.
10:15:38 <[[derek]]> I keep forgetting that.
10:15:46 <[[derek]]> Hopefully I can get my base64 encoder working now
10:15:50 <mizu_no_oto> > error $ "This is number 1: " ++ show 23
10:15:53 <lambdabot>  *Exception: This is number 1: 23
10:16:46 <[[derek]]> $ bascically creates a pair of brackets from the $ to the end of the line right?
10:18:22 <Haskellfant> to the end of the expression if you want to be pedantic
10:18:42 <ion> a + b $ c + d is parsed as (a + b) $ (c + d) if (+) has a higher precedence than ($)
10:18:51 <Cale> [[derek]]: f $ x = f x, but $ has the lowest possible precedence for an infix operator
10:19:32 <Cale> (so yeah, it's pretty much like putting parens around the things to either side of it)
10:20:18 <Cale> A common idiom is to write something like f (g (h x)) as f . g . h $ x or as f . g $ h x
10:20:26 <ronh-> derekv there's also printf, for better or for worse :)
10:20:30 <ion> That is, for all $ and +, “a + b $ c + d” is parsed as “(a + b) $ (c + d)” if + has a higher precedence than $
10:20:44 <ronh-> > printf "This is a number 1: %d" 1
10:20:45 <ion> And the actual $ has the lowest precedence as Cale said
10:20:46 <lambdabot>      No instance for (Show a0)
10:20:47 <lambdabot>        arising from a use of ‘show_M296530370597774939729484’
10:20:47 <lambdabot>      The type variable ‘a0’ is ambiguous
10:20:51 <ronh-> > printf "This is a number 1: %d" 1 :: IO ()
10:20:52 <lambdabot>  <IO ()>
10:20:52 <derekv> ronh-: wrong derek 
10:21:00 <derekv> =]
10:21:01 <ronh-> yeah
10:21:04 <ronh-> :)
10:21:11 <ronh-> ^^ derek1
10:26:36 <infandum> ion: So memtest is saying there are lots of failing addresses. What now?
10:26:40 <etandel> does anyone know why Data.Time.Clock features both DiffTime and NominalDiffTime, but all the functions only work with NominalDiffTime?
10:26:57 <etandel> I'm finding time in haskell to be quite confusing. =S
10:27:26 <kristof> etandel: nominal time is how everyone does time
10:27:34 <kristof> count seconds since 1970
10:27:47 <bergmark> etandel: there are other time libraries
10:28:02 <bergmark> e.g. http://hackage.haskell.org/package/hourglass
10:29:42 <[[derek]]> Thanks for the help everyone
10:30:16 <etandel> kristof: i got that, but there is no function to create NominalDiffTime (like secondsToDiffTime), but everything accepts nominal time instead of difftime. doesn't make much sense to me.
10:30:30 <etandel> bergmark: thanks, i'll check it out
10:32:08 <dedgrant> etandel: ocharles had a great introduction that got me started with the time package: https://ocharles.org.uk/blog/posts/2013-12-15-24-days-of-hackage-time.html  .. hope it helps!
10:33:03 <etandel> thanks!
10:35:13 <ion> infandum: If your computer has memory modules you can remove and still have a valid memory configuration (it may require modules in pairs for instance), try subsets and see if you can pin down the broken module. If not, try substituting each module with a working one from another computer one by one.
10:36:00 <infandum> ion: Thanks, I was afraid it would come to that. :(
10:36:03 <ion> if you have access to one with compatible modules
10:36:28 <infandum> ill yank them out one by one
10:36:36 <infandum> there are three or four sticks I think
10:36:37 <hiptobecubic> infandum, you can also just try swapping them around if you can't remove them one by one
10:36:44 <[[derek]]> Woooooop, my base64 encoder finally works
10:37:22 <infandum> 10000 errors so far...geez
10:37:30 <infandum> not even 12% done yet
10:37:31 <hiptobecubic> if the bad addresses don't change then it probably isn't the memory itself that's the problem. Assuming there aren't any crazy indirections going on that I don't know about.
10:37:41 <ion> If the problem turns out to be in the DIMMS (and it probably is), that’s the *good* outcome. Memory modules are cheap and easy to replace.
10:38:15 <infandum> what's the bad outcome?
10:38:25 <ion> The problem being in another component, such as the motherboard
10:38:26 <[[derek]]> If I'm converting from Hex to base64, is going Hex -> Decimal -> 64 a good idea? I've got a feeling that I might max out Int pretty quickly if I encode really large numbers.
10:38:30 <infandum> memtest having errors is saying that is IS memory, right?
10:39:05 <ion> Or the memory controller, or an electrical connection on the motherboard, or etc.
10:39:44 <infandum> ugh
10:39:46 <infandum> this is a mess
10:41:26 <infandum> can I stop the memtest now and do the one by one analysis? Is memtest going to tell me anything additional?
10:41:38 <hexagoxel> infandum: just abort that run and follow the subset-testing advice. no use in getting an exact total
10:42:55 <infandum> great, thanks!
10:43:32 <Aruro> why do we need boxed Ints? people suggest unboxing them for optimization
10:47:55 <Haskellfant> Aruro: you can't have lazyness by default (which ghc does have) without boxing, because you might need to point to a thunk
10:48:49 <NemesisD> i'm getting some weird warning inconsistencies between 7.8 and 7.10. I've got a module that needs Applicative and Alternative. In 7.8 it complains that importing Control.Applicative is redundant. In 7.10, with Control.Applicative absent ghc complains that Alternative is undefined. what is going on?
10:50:35 <Haskellfant> NemesisD: did you confuse 7.8 and 7.10? the way you put it, it sounds the wrong way around
10:51:43 <Haskellfant> you definitely need to import Control.Applicative in 7.10
10:51:59 <Haskellfant> I would be very surprised if Alternative was in Prelude before that
10:52:00 <NemesisD> hmm, so ghc 7.8 uses base 4.7 right?
10:52:25 <Haskellfant> yep
10:52:47 <Cale> I'd just ignore that warning
10:52:48 <Haskellfant> the error in 7.10 makes sense, but you should need to import it in 7.8 as well
10:53:11 <Aruro> Haskellfant: i guess my question is how usefull it is to have lazyness on Ints, if optimization anyway requires getting rid from it
10:53:29 <dolio> Polymorphism also relies on boxing.
10:53:44 <Haskellfant> if you care about -Wall you could throw in some preprocessor statements to not import it in 7.8
10:53:46 <Cale> Aruro: Have you ever applied the map function to a list of Int values?
10:53:54 <Cale> Or length?
10:54:02 <Aruro> Cale:  i did, so?
10:54:03 <Cale> These things rely on boxing.
10:54:18 <Cale> :t map
10:54:20 <lambdabot> (a -> b) -> [a] -> [b]
10:54:28 <dolio> Having a list of Ints period relies on boxing.
10:54:34 <Cale> right
10:54:54 <Cale> If you wanted a list of unboxed ints, it would have to be a separate type altogether.
10:55:15 <Aruro> Cale:  im talking about unboxed pragma
10:55:26 <Cale> hm?
10:55:35 <Aruro> data Point = P Int
10:56:05 <hexagoxel> NemesisD: The relevant change is that `class Applicative` is in Prelude in ghc-7.10, while it was not before. Alternative has not changed.
10:56:09 <Aruro> something like that, people suggest to unboxed pramga on the right hand side
10:56:09 <dedgrant> Aruro: {-# UNPACK #-}?
10:56:16 <Aruro> dedgrant: ty :D
10:56:19 <Aruro> indeed, unpack
10:56:39 <Cale> Unpacking isn't always a good idea, even for strict fields.
10:57:11 <Aruro> well, i was just confused what was sense to have Int type packed if optimisation strategies rely on unpacking them
10:57:59 <tejing> it just occurred to me that ($) == id
10:58:06 <Aruro> > map (+1) [1..5]
10:58:08 <lambdabot>  [2,3,4,5,6]
10:58:12 * hackagebot data-lens 2.10.6 - Used to be Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.10.6 (RussellOConnor)
10:58:17 <Aruro> does this map rely on Int being boxed?
10:58:31 <Cale> yes
10:58:50 <Cale> Well, Integer in that case, because you didn't specify the type, but yeah
10:58:52 <Aruro> Cale: could you elaborate a bit :)
10:59:14 <Cale> Aruro: There is only one compiled map function.
10:59:38 <c_wraith> Furthermore, [1..5] depends on Integer being boxed, even without using map
10:59:56 <Cale> Aruro: It can operate the same way regardless of the type of values concerned because boxed values all have the same size.
11:00:13 <c_wraith> since the list constructor requires boxed arguments for the same reaosn
11:00:15 <c_wraith> *reason
11:00:33 <Cale> They take the same amount of space in memory and are operated on in the same way, so you don't need to compile 80 kajillion copies of the map function for every possible combination of types
11:01:05 <dolio> It's the same reason Java auto-boxes things when you use primitive types with generic containers.
11:01:15 <Cale> (even then, polymorphic recursion would get you... it's possible for values of an unbounded number of types to exist at runtime)
11:01:27 <tejing> Cale: mightn't the compiler optimize it to avoid the allocation though? (assuming you used Int not Integer)
11:01:45 <dolio> Or, now it does. It used to require manual work, which is how it would be if you wanted to use unboxed integers manually.
11:02:09 <c_wraith> tejing: potentially, depending on how the list is consumed, optimization levels, compiler versions, phase of the moon, etc
11:02:09 <dolio> In Haskell, that is.
11:02:15 <Cale> It's possible that the map doesn't happen at all due to some optimisation.
11:02:22 <Aruro> Cale: can you show example of map being broken for unpaked Int?
11:02:36 <dolio> It's much nicer to use boxed integers everywhere and have the optimizer generate the unboxed code.
11:02:48 <Cale> Aruro: It's hard to write one, because you can't even form a list of unboxed ints, since they're the wrong kind for the [] type constructor
11:02:49 <c_wraith> Aruro: first show you you put unboxed Int into the list.
11:02:51 <Cale> :k []
11:02:53 <lambdabot> * -> *
11:02:59 <Cale> :k [] Int#
11:03:01 <lambdabot>     Not in scope: type constructor or class ‘Int#’
11:03:01 <lambdabot>     Perhaps you meant one of these:
11:03:01 <lambdabot>       ‘Int’ (imported from Data.Int), ‘Int8’ (imported from Data.Int)
11:03:04 <Cale> ah
11:03:40 <Cale> anyway, Int# :: #
11:03:49 <Cale> Prelude GHC.Prim> :k [Int#]
11:03:49 <Cale> <interactive>:1:2:
11:03:49 <Cale>     Expecting a lifted type, but ‘Int#’ is unlifted
11:03:49 <Cale>     In a type in a GHCi command: [Int#]
11:03:55 <seanparsons> I've got a problem like this: http://stackoverflow.com/questions/20901710/composing-lenses-with-at-and-ix
11:04:32 <seanparsons> Except that I want to apply another lens that produces a Maybe on the value inside the Maybe the "at" lens produces.
11:04:42 <Aruro> Cale: ty for the help, sounds interesting
11:04:43 <Cale> Aruro: So you get a kind error if you try to form the type of unboxed Ints, which makes sense, because the cons cells themselves hold the boxes.
11:04:51 <dedgrant> dolio: Well, depends on your goals. :)  That being said there are a lot of packages out there to cover many high-throughput/low latency/lean memory cases for common problems.
11:05:13 <c_wraith> seanparsons: the at Traversal doesn't produce a Maybe, functions like ^? do that.
11:05:17 <Aruro> Cale: so type data Point = P Int# would be ok?
11:05:31 <c_wraith> :t _Just
11:05:32 <Cale> Aruro: and so if you tried to fit arbitrary unboxed stuff there, then all the functions which operate uniformly assuming that the elements of a list are represented by code pointers would screw up by jumping into random places in memory
11:05:34 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
11:06:17 <Aruro> Cale: what would be the size of boxes in case of map?
11:06:38 <seanparsons> c_wraith: Erm, what's the Maybe doing in this definition: https://hackage.haskell.org/package/lens-3.8.7.3/docs/Control-Lens-At.html#v:at
11:06:39 <Cale> Aruro: Well, it's the size of a code pointer
11:06:58 <Cale> Aruro: But that doesn't mean you can just put an integer of that size there, because you'll get segfaults :)
11:07:19 <c_wraith> seanparsons: oh, guess I was thinking of ix, rather than at
11:07:29 <Cale> Aruro: Because everything expects a code pointer there, and anything which evaluates the elements of the list will jump into that code.
11:07:50 <seanparsons> c_wraith: However I think _Just is the particular thing I need to get over this hump, so thank you!
11:08:07 <Aruro> Cale: but data P = P Int# does not have that problem i can map over [P] right?
11:08:16 <Cale> Right, you can do that
11:08:28 <Cale> You've basically redefined the usual Int type
11:08:37 <Cale> data Int = GHC.Types.I# Int# 	-- Defined in ‘GHC.Types’
11:08:46 <merijn> Aruro: "data Int = I# Int#" ;)
11:08:48 <merijn> Oh, too slow
11:08:55 <Aruro> :D
11:08:59 <merijn> You can get access to the constructor via GHC.Exts
11:09:01 <Aruro> ty guys, very helpful
11:10:01 <Cale> Aruro: So unpacking the fields helps avoid that extra level of indirection, but you lose out on the option of polymorphism and lazy evaluation, both of which rely on that boxing mechanism.
11:10:24 <Cale> Aruro: It's possible for an Int value to be very expensive to compute and yet possibly unneeded as well
11:10:47 <Cale> Aruro: and in those cases, you wouldn't want to blindly unpack an Int field, forcing it to be evaluated all the time
11:11:04 <Aruro> Cale: yes, im interested in that cases, just to see them in practice
11:11:16 <Aruro> expansive unneeded Ints
11:11:18 <Cale> However, on the other hand, it's also possible for an unevaluated expression for an Int to take up way more space in memory than the evaluated Int
11:11:30 <Cale> (and allocation also costs time)
11:11:52 <Cale> So in practice you just want to be careful about what you mean, in the places where you care about performance.
11:12:50 <Cale> Aruro: One good example having to do with Arrays is using an Array to make a memo table for a recursive function.
11:14:17 <frerich> Does anybody know of a nicer/conventional/shorter way to define 'p a b = maybe b (\x -> if p x then a else b) 
11:14:18 <frerich> er
11:14:23 <merijn> A good starting point for getting a performance intuition for laziness is the STG paper
11:14:32 <Cale> Aruro: You can define a lazy array (i.e. of boxed values) whose entries are predefined to be equal to the function applied to certain parameters, and the function can recursively be defined by looking up the values in the array instead of having direct recursive applications
11:14:36 <merijn> frerich: maybe + bool?
11:14:37 <merijn> :t bool
11:14:38 <lambdabot> a -> a -> Bool -> a
11:14:55 <Cale> Aruro: Once an entry in the array is computed, it will then be stored as long as the array remains in scope.
11:15:11 <frerich> Sorry, I meant '\f g a b -> maybe b (\x -> if f x then g x else b)'
11:15:12 <Cale> Aruro: which is a useful approach for "dynamic programming" solutions
11:15:16 <merijn> frerich: Note that bool is bool-elimination, not if/then/else
11:15:24 <Vektorweg1> http://www.reddit.com/r/haskellquestions/comments/37zmzq/a_flexible_typed_heterogeneous_data_type/
11:15:26 <frerich> I.e something which conditionally transforms the value in a Maybe.
11:15:36 <refefer> frerich: that's a map
11:16:03 <frerich> merijn: Yeah, I mean - what I have isn't too bad but I somehow suspect I could also fmap some clever function
11:16:12 <frerich> (without obfuscating things)
11:16:13 <Aruro> Cale: sounds interesting
11:16:29 <Aruro> Cale: will look into that
11:16:55 * frerich notices the 'a' argument in his function is unused, hihi
11:18:31 <timothyh> hm bayhac is real soon http://bayhac.org
11:19:44 <quchen> ocharles_: Silly us :-(
11:20:04 <ocharles_> quchen: yep! I should basically hand all my geek points in
11:20:45 <lpaste> Cale pasted “Stupid fib example” at http://lpaste.net/133722
11:20:50 <Cale> Aruro: ^^
11:20:52 <quchen> It'll be years until I meed Edward again. Since he had a following of at least 10 people at all times, he's basically the center of our web of trust, so getting his sig would be PGP knighthood :-D
11:21:00 <quchen> meed … oh my
11:21:16 <Cale> Aruro: This is a stupid example because we know ahead of time that we only need to hang on to the previous couple fibs
11:22:18 <Cale> Aruro: But in a more general case, you might not know which elements of the range you'd need again ahead of time
11:22:32 <Cale> (so the space usage would be justified)
11:28:14 * hackagebot hlibsass 0.1.2.0 - Low-level bindings to libsass  http://hackage.haskell.org/package/hlibsass-0.1.2.0 (jakubfijalkowski)
11:39:30 <kadoban> Hmm, libsass, interesting. That could be useful in hakyll. IIRC I'm manually calling a command-line script for that.
11:40:18 <tejing> Cale: calculating collatz sequences is a less contrived example where that kind of technique is useful
11:41:55 * tejing needs to look at timestamps
11:43:15 * hackagebot hsass 0.2.0 - Integrating Sass into Haskell applications.  http://hackage.haskell.org/package/hsass-0.2.0 (jakubfijalkowski)
11:47:25 <SrPx> rhaps0dy: thanks for the link
11:47:44 <SrPx> I ended up reading more after that so it took a while
11:48:32 <SrPx> I'm not satisfied to be honest, I want to learn more, everything makes sense but not deeply, I still don't understand all of this. 
11:49:34 <SrPx> I mean, I understand what arrows are, how to implement them, and now I even know how they can replace monads in some use cases and improve code in others. Yet...
11:51:22 <SrPx> Sometimes I just feel like Haskell as a whole doesn't connect to me. There are so many things, what do they mean? Why arrows, monads and all of that even exist? Are those man-made ideas or are them natural somehow? How does it all connect...
11:51:23 <Aruro> Cale: ty, will go study it :)
11:52:35 <nuttycom1> SrPx: IMO, it all comes down to parametricity. Basically, each of these structures exposes some minimal set of semantics.
11:53:15 <nuttycom1> Depending upon only these semantics provides the maximum possible power to the caller of a function, and the minimum possible (but sufficient) power to that function's implementer.
11:53:44 <monochrom> haskell, arrows, and monads are man-made.
11:53:48 <nuttycom1> In OOP, you hear lots of noise about information hiding. Well, this is the *essence* of information hiding.
11:54:15 <maerwald> SrPx: I see those things as design patterns (at least monads). But why do you assume all does connect in some mysterious way? I don't think it does. It's just stuff that people use.
11:55:15 <maerwald> (and even if it does connect in some mysterious way... it's irrelevant for you as a programmer)
11:55:19 <nuttycom1> maerwald: I'd say it very much all does connect, but the way in which it does is not mysterious.
11:55:56 <maerwald> depends on what you mean with "connect"
11:56:09 <maerwald> I have a feeling he is overthinking this
11:56:51 <nuttycom1> Yeah, that's more or less my point about parametricity. 'forall a.' is a really useful way to predicate an idea. :)
11:57:08 <SrPx> nuttycom1: then where are the boundaries? Why Monoid is what it is? Why not split it into "Puroid" and "Concatenoid"? Many classes overlap somehow. Applicative's pure and Monad's return are the same thing to me. Then there is Control.Category, which defines... id and (.)? So... is that what category theory studies? So there is an Arrow Theory? What...
11:57:34 <merijn> SrPx: You are thinking of Semigroup and Pointed
11:57:42 <merijn> SrPx: And both exist
11:57:46 <nuttycom1> SrPx: these concrete questions are good!
11:57:52 <merijn> But it turns out Pointed isn't very useful since it doesn't have any laws
11:58:04 <nuttycom1> ... and laws are what it's all about. 
11:58:04 <monochrom> some people split it. this show you how subjective things are.
11:58:14 <nuttycom1> pure and return *are* the same thing.
11:58:24 <merijn> SrPx: The reason pure and return overlap is that Applicative was invented after Monad and since it wasn't part of the hierarchy it couldn't use return
11:58:26 <nuttycom1> And only have different names because of a historical accident.
11:58:32 <monochrom> and how subjective these things are shows you that math is invented, not discovered.
11:59:13 <nuttycom1> monochrom: I don't think that philosophical point is correct (or useful here) but whatever.
11:59:37 <SrPx> Uhm okay. What about category theory? Is category theory just the study of that particular class? Why is it particular? Why nobody cares about Monoid Theory, Applicative Theory, Monad Theory, Arrow Theory...?
11:59:46 <SrPx> why is it special*
11:59:55 <mizu_no_oto> SrPx: monoid, semigroup, etc. come from Abstract Algebra.
12:00:14 <monochrom> "nobody cares about Monad Theory" is false.
12:00:46 <nuttycom1> All those models fit inside of category theory; the Category type is just the Category for Hask (the set of all possible Haskell types)
12:00:53 <nuttycom1> But there are lots of interesting categories.
12:00:53 <mizu_no_oto> Though a typical Abstract Algebra 1 course will start with Group Theory, since they have more interesting proofs and structure to them
12:01:20 <monochrom> but if you speak statistically, "why more people study X than Y" is the same question as "why more people use Windows than Mac"
12:02:20 <SrPx> No, I'm actually asking if there is such a thing as a "Monad Theory". Because as I see it, people treat monads as if they were part of Category Theory. 
12:02:26 <mizu_no_oto> Category Theory is just the name of the field.  Its creator supposedly once said that "I didn't invent categories to study functors; I invented them to study natural transformations.""
12:02:34 <monochrom> one thing becomes more popular than another by simply social interaction and historical accidents. there does not need a "deep" reason.
12:02:49 <nuttycom1> SrPx: I'd advise you to not get too hung up on names. Your observation that pure and return were the same thing is *exactly* the right way to be proceeding. Look at the semantics and the structure, and don't get too hung up on names.
12:03:10 <SrPx> So Category Theory is not the study if "id and (.)" in particular, but of types and classes...?
12:03:15 * hackagebot schedule-planner 1.0.0.0 - Find the ideal lesson layout  http://hackage.haskell.org/package/schedule-planner-1.0.0.0 (justus)
12:03:38 <nuttycom1> SrPx: types and classes and a lot more things that don't necessarily fit into Haskell very well at all.
12:03:45 <merijn> SrPx: No, category theory is about the study of categories and arrows, I would recommend http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/ as intro to that
12:03:46 <quchen> Category theors is the study of categories and the additional interesting structure you can refine them with.
12:03:52 <monochrom> if you go through Moggi's publication history, it's going to look like monad theory without saying "monad theory"
12:03:55 <nuttycom1> merijn: +1
12:04:04 <SrPx> merijn: the only reason I didn't start reading it yet is that it is unfinished :(
12:04:29 <merijn> SrPx: It already covers all the basics
12:04:33 <mizu_no_oto> SrPx: Monads are part of Category Theory, yes, because a monad is a monoid object in the monoidal category of endofunctors (where an endofunctor is a mapping of a category to itself) under functor composition
12:05:00 <merijn> SrPx: Whether it's worth reading the entire thing depends on whether you consider it interesting, as it's not very relevant for writing "real world" code
12:05:32 <maerwald> merijn: +1
12:05:39 <merijn> mizu_no_oto: That's not a particularly helpful "explanation" to someone who doesn't know category theory at all
12:05:56 <SrPx> mizu_no_oto: can we similarly say that a category is something in the Monad Theory?
12:06:09 <SrPx> merijn: okay I will give it a try
12:06:24 <mizu_no_oto> SrPx: I suppose so, but Categories were thought up of long before Monads
12:06:47 <mizu_no_oto> SrPx: names tend to have more to do with historical accident than logic
12:06:54 <SrPx> merijn: but I'm afraid I want to know what is the context in which category theory is inserted more than what category theory is in details, at this moment
12:07:45 <charlieb> I have a practical haskell newbie question, how can I process a list where the nth result depends on the n-1th result but have the result come out unreversed and be lazy, is there an idiom for that?
12:08:16 * hackagebot haskdeep 0.2.0.1 - Computes and audits file hashes.  http://hackage.haskell.org/package/haskdeep-0.2.0.1 (MauroTaraborelli)
12:08:17 <merijn> charlieb: Just have the generating function produce it that way?
12:08:26 <merijn> charlieb: Sounds like a variation of scan, though
12:08:29 <mizu_no_oto> charlieb: unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
12:09:53 <nuttycom1> SrPx: learning enough category theory to understand the structures that category theory calls "objects" and "functors" is very useful, because it gives you enough framework to start to understand a lot of the abstractions you're talking about in a *more* abstracted sense.
12:09:57 <mizu_no_oto> charlieb: for example, fibs = unfoldr (\ (a,b) -> Just (a, (b, a+b))) (1,1)
12:10:41 <charlieb> mizu_no_oto: that looks like it could be good
12:11:12 <nuttycom1> Oh, and arrows too of course.
12:11:29 <charlieb> merijn: I'll check out scan too
12:12:03 <charlieb> folds just weren't doing it for me :)
12:24:22 <joneshf-laptop> does `OverloadedLists` allow pattern matching with `(:)`?
12:26:30 <merijn> joneshf-laptop: Not sure, try it?
12:27:50 <ahihi> f (x:xs) should desugar to f (toList -> (x:xs)), which is fine
12:28:29 <joneshf-laptop> ahihi, works for me, thanks!
12:31:06 <literon> hello again
12:32:49 <literon> I asked previously, if there exists a construct to wrap a monad m in, to be able to observe binds (the two arguments separately), to alter control.
12:33:24 <srhb> "Observe binds" ?
12:33:43 <literon> I was advised that Free should work, but I did for Free IO some substitution on paper, and return x >>= f >>= g ended up being IO (Free (IO (Free..))
12:33:56 <srhb> Ah.
12:34:02 <merijn> literon: Maybe you want FreeT, the Free Transformer?
12:34:30 <literon> srhb: I have something like the FlatMap construct of http://blog.higher-order.com/assets/trampolines.pdf in mind.
12:34:34 <merijn> Actually, I'm not sure I think it depends on what you're doing
12:35:18 <merijn> literon: Is this about efficient bind operations on recursive data types?
12:35:31 <SrPx> Sorry I gave up of that tutorial merijn. Most of it is explaining things I already know, a good amount is explaining things through c++ analogy and the remaining reexplains through Haskell analogy, though but self-sufficient (I can't just skip the parts). Sounds like a great tutorial, but not my thing.
12:35:43 <literon> My overall intention is to interleave a tunnel in the binds, so I would hijack the a, and feed it to f sligtly modified
12:35:52 <SrPx> though not*
12:36:15 <literon> merijn: I'm not interested in efficiency for now.
12:36:40 <SrPx> I'll be looking for more compact materials
12:38:08 <SrPx> Something I'm interested particularly is what exactly is the relevance of ADTs for category theory and functional programming in general.
12:38:14 <literon> So, having ma >>= f, f being \a -> m b, I would like to be able to transform these to ma >>= someFun >>= f.
12:38:30 <merijn> SrPx: ADTs have no relevance to category theory at all
12:39:17 <quchen> MonadPlus provides a left zero for >>=. Does it make sense to have a class that provides a number of different left zeros for >>=?
12:39:21 <SrPx> merijn: questions like: What is the point of ADTs exactly? How do they fit everything else? Where they come from? Are they essential or could we live without them? Etc.
12:39:21 <merijn> Category theory is about describing abstract patterns, so you can apply it to almost anything, but it doesn't help you understand things
12:39:41 <literon> I had the idea to have some kind of transformer, which captures the operations in an ADT, that I can later step-by-step and add my extra tunneling.
12:39:50 <unknownloner> is there a way, with pattern matching, to get both the head of a list and the list including the head?
12:39:55 <c_wraith> honestly, "describing abstract patterns" is as good of a definition of math in general as I know of.
12:40:05 <merijn> unknownloner: Yes, use aliases/as-patterns
12:40:07 <quchen> unknownloner: xs@(x:_)
12:40:08 <SrPx> Also: what is category theory *in the context of math*? Where it is on the world of mathematical things and how does it relate to everything else there? Oh so many questions.
12:40:14 <unknownloner> ah, I had it flipped
12:40:20 <literon> At this point it reminds me of Free*, but I don't have the free-fu to see how exactly.
12:40:42 <c_wraith> literon: that's more or less what FreeT does, yes
12:40:54 <merijn> c_wraith: Well, to be fair category theory and HoTT both attempt to provide alternate foundations for all of math...
12:40:55 <SrPx> I wish we had some kind of "book of everything" that overviewed math as a whole and allowed us to drive towards the parts we want.
12:42:04 <maerwald> SrPx: you mean wikipedia? :o
12:42:23 <joobus> 42
12:42:29 <joobus> the answer is 42
12:42:37 <geekosaur> that's more like the book of lies...
12:42:41 <SrPx> I mean, if I want to learn about any particular subject - calculus, algebra, type theory, whatever, I can go to any street corner and buy book explaining it as deeply as I want. But something connecting those areas? 
12:42:54 <maerwald> geekosaur: fix the lies
12:43:29 <SrPx> maerwald: Wikipedia is more of a big library of incomplete resources. And it doesn't do the part of connecting at all since it can't produce content (by their own guidelines).
12:43:52 <joobus> isn't that what wolfram is supposed to be?
12:44:01 <geekosaur> the closest thing I know to "book of everything" is James Burke's stuff, but that's not math-specific and wouldn't go into that kind of depth anyway
12:44:07 <SrPx> I wonder how much of the same mathematical concepts are duplicated across different fields with different names because of lack of communication.
12:44:08 <joobus> http://www.wolframalpha.com/
12:44:14 <geekosaur> (and, while useful, is based on an IMO flawed hypothesis)
12:44:14 <SrPx> Like, tensors and ndarrays are the same damn thing
12:44:31 <SrPx> joobus: for itself, maybe... not for users/humans
12:44:59 <rnhmjoj> Hi! It's my first time using haddock and I a question to ask. The instances imported from another module don't show up in the docs. Is there something special to do? I can't figure it out.
12:46:51 <quchen> rnhmjoj: What do you mean with "imported from another module"? Do you not see the instances of classes, or of types?
12:47:32 <quchen> Module A: defines Class. Module B: defines type Type with instance of Class. Module A's Haddock doesn't show Type in Class' instances?
12:47:55 <rnhmjoj> I have a module named instances that defines a bunch of instances for a datatype. The doc shows only instances defined in the main module.
12:48:13 <SrPx> I mean, if "ndarray" and "tensors" are truly the same thing, then we should have a single page defining the concept concretely, and then link that same page from whatever uses it from physics or CS. Wikipedia doesn't do that, at all.
12:50:09 <hiptobecubic> SrPx, i think semantics counts
12:50:34 <srhb> SrPx: ndarray is a name for a specific representation. They are not the same.
12:50:41 <hiptobecubic> ndarray doesn't have to mean tensor in the mathematical sense the same way "array" doesn't have to mean "mathematical vector"
12:50:53 <srhb> In fact it almost never _does_
12:51:18 <srhb> ndarray is one possible answer to "how do I represent a tensor in memory"
12:52:37 <SrPx> that's not the point, or are you denying there is a huge amount of concepts that are actually the same thing under different names across different fields?
12:53:10 <srhb> No, I am not denying that. I'm saying this isn't one of them.
12:53:32 <SrPx> that's okay, I couldn't find a good example
12:53:41 <srhb> Probably because the amount isn't that huge anyway.
12:54:53 <SrPx> probably because my own knowledge about other fields isn't huge anyway
12:57:01 <indiagreen> is there a simple way to have several GHCs installed on OS X?
12:57:24 <crough> indiagreen: Homebrew will do it, I think, and you can activate one with "brew link ghc-version"
12:57:27 <crough> Not 100% sure
12:57:40 <SrPx> But that is still not the point. What is the use in knowing category theory if I don't know how it relates with everything else? How can I be sure there is a different theory that does everything category theory does, but better, that I'm not aware of?
12:57:51 <rnhmjoj> https://github.com/rodlogic/homebrew-ghc
12:58:10 <rnhmjoj> I used this and it works fine.
12:58:18 <srhb> SrPx: That's what a maths degree is for. I mean, category theory is super new and a possible new basis for All Maths. New theories may arise at any point again.
12:58:32 <srhb> SrPx: But one resource would surely be cool, it just needs huge curation.
12:59:39 <charlieb> merijn: scanl worked perfectly, I even tested it for laziness with an infinite list and a list with undefinied in it and I was plesantly surprised.
12:59:46 <srhb> SrPx: Have you read about HoTT?
13:00:01 <SrPx> That is what makes me curious. I'm not as much interested in learning deeply about category theory as I am about learning how category theory relates to set theory, how it relates to homotopy type theory, and what other kind of theories are around, why they are different and what they have to say about the meaning of maths, logic and intelligence itself...
13:00:21 <merijn> indiagreen: There's two simple ways (incidentally, I would recommend against homebrew)
13:00:35 <srhb> SrPx: Those are some really huge question. Aside maybe from how category theory relates to set theory.
13:00:43 <srhb> SrPx: That's covered in every CT book, basically.
13:00:50 <SrPx> That is what I wanted. I could buy a book on set theory, category theory and even read the HoTT book to the point I'm good on all those, but (20 years later) I'm not sure that would answer those questions. 
13:00:53 <merijn> indiagreen: By default GHC uses a per-major version package db so multiple different versions will not collide. Cabal just uses whichever GHC version is on your path first
13:01:11 <srhb> SrPx: The other are wildly philosophical. And no, you would probably just end up with more questions, as we always do in investigating things. :)
13:01:20 <merijn> indiagreen: So I just have multiple ghc-head, ghc-7.10, ghc-7.8, etc. folders in my home dir and switch by modifying my path
13:01:25 <SrPx> srhb: :(
13:01:42 <merijn> indiagreen: There is also https://ghcformacosx.github.io/ which aims to make this neater
13:01:47 <srhb> SrPx: Cheer up, open questions are fun and why we have science! :-)
13:01:57 <Hijiri> more questions means job security for question-answerers
13:02:04 <srhb> That too :P
13:02:16 <SrPx> but nothing makes sense in the world srhb 
13:02:38 <srhb> SrPx: I disagree. But I think we've veered off topic now. :)
13:02:54 <SrPx> my bad
13:03:27 <indiagreen> merijn, rnhmjoj, crough: thanks
13:03:35 <crough> indiagreen: absolutely :)
13:04:01 <tomasos> Is someone here working with cabal? I would like to add a flag to a command, a '-f --force' flag. I understand partly what I need to do but I'm stuck on the last arguments of a function (Command.hs:option)
13:04:19 <merijn> tomasos: You'll want dcoutts, but he's not online atm
13:04:40 <merijn> tomasos: For hacking on hackage and cabal you should hang around in #hackage, he's usually around during CEST working hours
13:04:53 <hexagoxel> merijn: the per-_major_ version part is new to me. do ghc-7.8.4 and ghc-7.8.3 share the same folder in the package-db?
13:05:09 <merijn> hexagoxel: I'm not sure, I thought they might
13:05:12 <tomasos> merijn: thanks!
13:05:20 <merijn> hexagoxel: I was just being pessimistic to be careful
13:06:00 <johnw> who would like to help with a simple programming task that could benefit the GHC development team?  I need to process a CSV file containing Trac issues, and compute the top 5 most frequent words in each issue, and then sort the issues based on those frequencies across the whole set.  The project has begun here: https://github.com/jwiegley/ghc-issues
13:06:16 <johnw> I thought it could be an interesting task for those wanting to try out a real yet small problem in Haskell
13:06:17 <hexagoxel> merijn: at least the folders in the sandbox contain the version components, e.g. ghc-7.8.4
13:06:37 <hexagoxel> s/the version components/three version components/
13:09:20 <hexagoxel> merijn: out of curiosity: do you have more than one version of haddock installed, so `cabal haddock` works for different ghc versions?
13:09:46 <merijn> hexagoxel: Not that I know
13:12:08 * hexagoxel was annoyed yesterday when ghc-7.8-haddock refused to `cabal haddock` his ghc-7.10-configured project.
13:13:19 * hackagebot feed 0.3.9.6 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  http://hackage.haskell.org/package/feed-0.3.9.6 (AdamBergmark)
13:15:36 <SrPx_> srhb: (but I do think those questions are relevant to us because that's the essence of code duplication. If a physicist creates a Tensor type and spends 1 week providing the methods for it, not knowing that someone already made a NDArray class that does exactly the same... then what a waste of effort that is?)
13:17:28 <osa1> does anyone know a function like Data.List.(\\) but parametric on comparison function?
13:17:31 <SrPx_> Or, on a smaller scale, having different definitions of "Prelude.foldr" and "Foldable.foldr" is exactly that. Two different (packages) defining the very same concept all over again. And we know very well how this turned out.
13:18:19 * hackagebot language-puppet 1.1.3.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.1.3.1 (SimonMarechal)
13:18:22 <SrPx_> We *need* to understand how those ideas connect across different fields/packages/whatever because that's the only way of avoiding duplication of work
13:23:48 <hiptobecubic> SrPx_, you can implement (\\) using foldr, but how are they exactly the same?
13:23:54 <dale_> I am using the StateT monad + Either to do some stateful computations that can fail with a useful err message. I have a big "state" object. Oftentimes I only want to modify sub-components of the object. To remedy this, I have designed a function that takes: (1) a StateT that works on the sub-component, (2) a function that takes us from the "state" object to a sub component and (3) a function that takes us f
13:24:01 <dale_> rom the modified sub component + the original state object to a new state object. http://pastebin.com/r8DT7sqi. I feel like I'm missing a neat abstraction. Can one of you guys take a look? (Much Appreciated)
13:25:00 <SrPx_> Another example. If you wanted to make Blender in Haskell, you would probably need to program an Skeleton animation system, correct? Wrong! Because we already one. A Skeleton is just a Tree of quaternions. So, import Linear, import Tree, and all you need is "treeScan (*) identityQuaternion".
13:25:27 <SrPx_> But as much as we have Data.Tree with great documentation, and Linear with great documentation, you won't find that connection anywhere.
13:25:43 <osa1> awesome. couple of days ago I had asked for a function with type (a -> a1) -> (b -> b1) -> Either a b -> Either a1 b2 and now I found it in Data.Bifunctor
13:26:30 <kadoban> Doesn't one of the Arrowish things let you do that as well? But Bifunctor sounds more directly appropriate I suppose.
13:26:35 <srhb> SrPx_: I don't think that different implementations of folds are different concepts.
13:26:38 <merijn> dale_: Lens supports exactly this
13:26:44 <osa1> kadoban: I think (&&&) also does it, yes
13:27:03 <osa1> kadoban: I only realized this when you mentioned though :)
13:27:11 <dale_> thanks merijn. Will read up on "Lens" stuff :D
13:27:15 <kadoban> Hehe :)
13:27:20 <jle`> osa1: it's (+++) actually
13:27:27 <merijn> dale_: Simplified, it has a "zoom :: Lens a s -> StateT a m r -> StateT s m r" function
13:27:31 <osa1> > :t Control.Arrow.(+++)
13:27:33 <lambdabot>  <hint>:1:1: parse error on input ‘:’
13:27:41 <merijn> dale_: Be warned, lens is...rather intimidating :p
13:27:45 <jle`> > show +++ negate $ Left 3
13:27:46 <lambdabot>  Left "3"
13:27:49 <jle`> > show +++ negate $ Right 3
13:27:50 <lambdabot>  Right (-3)
13:27:52 <merijn> :t (Control.Arrow.+++) -- osa1
13:27:53 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
13:28:03 <osa1> cool
13:28:04 <jle`> but yeah i would definitely use bimap instead
13:28:18 <jle`> i'd only use (+++) for ArrowChoice instances that aren't (->)
13:28:28 <osa1> :t (Control.Arrow.&&&)
13:28:29 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
13:28:37 <dale_> merijn: haha noted. I'll give it a go though!
13:28:39 <jle`> both &&& and +++'s (->) instances are bimap
13:28:43 <kadoban> Yeah I tend to overuse Arrow functions, it's a bad habit.
13:28:55 <jle`> it's okay...until now there was no base choice
13:28:59 <jle`> but now there is :)
13:29:21 <quchen> I think Bifunctor is the right thing to use here. Arrow is overused as a convenience library for tuples and Either when it should actually be abstracting over the (->).
13:29:53 <jle`> (&&&) for the (->) instance is bimap for the (,) instance, and (+++) for the (->) instance is bimap for the Either instance
13:30:03 <jle`> definitely
13:30:08 <jle`> glad bifunctor finally made its way into base
13:30:32 <quchen> jle`: Now we only need Biapplicative and Bitraversable
13:31:15 <jle`> :)
13:34:17 <jle`> nice propsal quchen
13:34:53 * hackagebot feed 0.3.9.6 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  http://hackage.haskell.org/package/feed-0.3.9.6 (AdamBergmark)
13:34:53 * hackagebot language-puppet 1.1.3.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.1.3.1 (SimonMarechal)
13:36:14 <Vektorweg1> i need some feedback! http://www.reddit.com/r/haskellquestions/comments/37zmzq/a_flexible_typed_heterogeneous_data_type/
13:46:24 <osa1> wouldn't it be awesome if Control.Arrow's >>> and <<< renamed to |> and <| ?
13:46:50 <quchen> Yes, that would not be awesome.
13:46:52 <R0b0t1> What is best way to have reloadable code? Client-server architecture of some kind, or...?
13:48:19 <Denommus> osa1: I already associate (|>) with ML's operator (which is 'a -> ('a -> 'b) -> 'b)
13:49:03 <osa1> yeah that's actually what I need and I meant Control.Category, not Control.Arrow... typo
13:49:10 <Vektorweg1> R0b0t1: uh. a website where the client needs to reload the js anyway and the js can be written in haste.
13:49:15 <lyxia> Vektorweg1: Neat!
13:50:07 <Denommus> osa1: (<<<) is (.)
13:50:14 <Denommus> :t (.)
13:50:15 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:50:18 <Denommus> ...
13:50:25 <R0b0t1> Vektorweg1: Amazing. Didn't know about that.
13:50:28 <Denommus> @import Control.Category
13:50:28 <lambdabot> Unknown command, try @list
13:50:35 <R0b0t1> Vektorweg1: I meant more like, reloadable code modules.
13:51:14 <R0b0t1> well.
13:51:21 <Vektorweg1> R0b0t1: you would need to work on the web, but it seems to be the modern way anyway. 
13:51:23 <R0b0t1> I mean like someone might dynamically load .dlls in some other language
13:51:38 <Denommus> osa1: (.) is redefined in Control.Category as (.) :: Category cat => cat b c -> cat a b -> cat a c
13:51:40 * R0b0t1 flips Vektorweg1's web upside down
13:51:42 <R0b0t1> :>
13:51:48 <quchen> Is there a mnemonic to remember which sides clowns and jokers go? :-|
13:52:05 <merijn> quchen: Yes, knowing 70s (?) pop music from the UK
13:52:21 <kadoban> stuck in the middle again?
13:52:26 <ion> quchen: The number of syllables
13:52:31 <indiagreen> is optparse-applicative somehow feature-deficient in comparison to cmdargs?
13:52:40 <Vektorweg1> R0b0t1: you could deploy ghc with it and then you could translate a ast using template haskell in a string, transmit it, compile it and ... uh. or you just send the code right away. 
13:52:58 <merijn> quchen: It's a reference to the song "Stuck in the Middle with You" from Stealers Wheel, 1972 apparently
13:53:07 <quchen> Yeah I just started playing it
13:53:10 <merijn> indiagreen: I would say optparse-applicative is superior to cmdargs
13:53:13 <quchen> And indeed they talk about bifunctors.
13:53:19 <merijn> indiagreen: cmdargs has too much nasty magical stuff
13:53:35 <R0b0t1> Vektorweg1, well, it seems you are right, the only thing in the direction I want is haste
13:53:48 <Vektorweg1> lyxia: did you mean the web/haste stuff or the flexible type stuff? 
13:54:06 <eds> evalt :: Floating E => E -> Maybe Int evalt (Const c) = Just c evalt (Sin e1) = liftM (sin) (eval e1)
13:54:22 <quchen> cLLLLLowns to the left, jokeRRRRRRRrs to the right
13:54:22 <R0b0t1> Vektorweg1: The other solution would be having single-function programs communicating with locale daemon program that handles persistent state and passes off code to special programs
13:54:25 <R0b0t1> that's what I'm going for
13:54:26 <lyxia> Vektorweg1: The flexible type!
13:54:29 <indiagreen> merijn: it's just that I had to give a task to a beginner, and I said “move the app we have from cmdargs to optparse-applicative” without really investigating whether it would be possible, and now I'm wondering whether it was a Bad Idea
13:54:30 <R0b0t1> not actual actual actual web stuff
13:54:30 <quchen> Please tell me that was correct
13:55:10 <eds> The rror is in here - evalt :: Floating E => E -> Maybe Int. Non type variable in the argument Floating E. Can someone help?
13:55:29 <Vektorweg1> lyxia: thank you. 
13:57:27 <Vektorweg1> R0b0t1: yeah. its a bit sad, but i start to write something in haste soon, because the web is the quickest way to reach people with software without annoying them with installation processes or something.
13:58:14 <R0b0t1> Vektorweg1, this is single-deployment
13:58:43 <R0b0t1> a webbrowser would make correctness testing a tad more difficult :^)
14:01:15 <enthropy> indiagreen: I think it's more of a problem in the other direction (that the implicit cmdargs thing doesn't handle parsing into nested data types, while that's less of a problem for optparse-applicative)
14:01:35 <Vektorweg1> R0b0t1: i hope haste get things right. i would code the prototype for gloss anyway and then just port it to haste. 
14:01:35 <indiagreen> okay, thanks
14:02:49 <eds> Solved that error. Gave me another one - Could not deduce (Floating Int) arising from use of 'sin' from the context of Floating E
14:03:32 <Hijiri> could you post your code on lpaste
14:04:19 <quchen> Clowns are indeed on the left. Pull request sent. :-D
14:04:50 * hackagebot smaoin 0.2.0.0 - Utilities for the Smaoin semantic information model.  http://hackage.haskell.org/package/smaoin-0.2.0.0 (akrasner)
14:04:52 <eds> yes. give me a se
14:04:53 <eds> c
14:06:21 <eds> http://lpaste.net/133728
14:06:33 <eds> hijiri
14:06:49 <tibbe> Have anyone seen doesDirectoryExist return false on a temp directory?
14:07:17 <johnw> tibbe: is it maybe a symlink to /private/tmp?
14:07:40 <tibbe> johnw: it’s on OS X so it’s in /var/folders/x6/q_9_w0md0yg5hrr2jyc8r7540000gn/T/cabal-test-91501
14:07:44 <Hijiri> eds: There is a type conflict where you are applying liftM sin (evalt e1)
14:07:52 <lyxia> Vektorweg1: It looks like you are looking for polymorphic variants but I'm not sure what existing equivalents of it exist in Haskell.
14:07:59 <tibbe> johnw: according to the docs symlinks should be OK
14:08:09 <johnw> tibbe: ah, I see, and you have read/executable permissions from the root down?
14:08:38 <eds> Yea it does not return a floating int. that is what it says.
14:08:55 <Hijiri> eds: Since sin :: Floating a => a -> a, and liftM :: (a -> a) -> (Maybe a -> Maybe a), liftM sin :: Floating a => Maybe a -> Maybe a
14:08:58 <tibbe> johnw: good question, I could create it on line 1 but looking for it on line 2 doesn’t show it
14:09:05 <Hijiri> So what you apply liftM sin to needs to be floating
14:09:11 <Hijiri> but the type of evalt e1 is Int
14:09:12 <johnw> tibbe: hmmm
14:09:16 <Hijiri> Maybe Int
14:09:17 <johnw> tibbe: this sounds vaguely familiar
14:09:18 <Hijiri> I mean
14:09:26 <Hijiri> so you can't apply liftM sin (evalt e1)
14:09:43 <Hijiri> because you can't get the sine of an integer
14:09:46 <eds> ohh so I cant apply liftm
14:10:01 <Hijiri> I would say the "real" issue is with trying to use sin
14:10:26 <Hijiri> If you had used some function that works on Int rather than sin, it would have been fine
14:10:42 <johnw> tibbe: if your sanity becomes threatened, take the volume offline and do a disk repair with Disk Utility.  I've had it happen that the filesystem got wonky and started giving me weird behavior, which after a repair suddenly went away.  But only at your wit's end, because I doubt that's it
14:10:47 <eds> Yea it works for +, - , *, /
14:10:53 <Hijiri> if you still want to be able to get sine, you will need to convert between a different type that supports sin
14:10:54 <tibbe> johnw: I think I figured it out
14:10:59 <johnw> what was it?
14:11:06 <Hijiri> Or you can change E to represent some other kind of value
14:11:11 <eds> so make a lift that supports sine?
14:11:14 <tibbe> getDirectoryContents of course returns relative paths
14:11:15 <tibbe> doesDirectoryExist needs absolute ones
14:11:20 <johnw> ahhh
14:11:24 <Hijiri> For instance, changing Const Int to Const Double
14:11:44 <Hijiri> and then make evalt have type E -> Maybe Double
14:12:26 <enthropy> Vektorweg1: there are lots of alternatives to your data type
14:12:35 <Hijiri> Another thing is you don't need (Floating E)
14:12:55 <eds> that worked! wait so you meant sine does not support int. ahh
14:13:00 <enthropy> HList has a Variant and extensible has Sum
14:13:05 <sveit> what is the purpose of the forall in this type declaration (just using Iso's as an example I happened to be looking at just now): type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t) . Is this 'forall' not implied?
14:13:10 <eds> I don't?
14:13:18 <arkeet> sveit: otherwise it would complain that p and f are not in scope.
14:13:28 <Hijiri> eds: Yes, because if E is Floating, you would know without checking
14:13:28 <arkeet> it isn't implied.
14:13:38 <Hijiri> you use typeclass constraints when you are using type variables
14:13:43 <Hijiri> and you are not sure exactly what type they are
14:13:46 <arkeet> forall is implied in type annotations
14:13:48 <Hijiri> but you want them to have certain methods
14:13:54 <arkeet> but not type synonyms
14:13:57 <sveit> arkeet: ah, but if I had that in a funciton declaration it would be implied, right?
14:14:02 <arkeet> right
14:14:05 <eds> http://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html#v:sin (trig functions do not support int. stupid me)
14:14:37 <eds> yes. that does make sense.
14:14:53 <enthropy> Vektorweg1: both of which don't need to pattern match on 4 constructors to get the Int out of Bool :| Double :| Char :| Int
14:15:00 * hackagebot Plot-ho-matic 0.5.0.4 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.5.0.4 (GregHorn)
14:15:02 * hackagebot th-typegraph 0.18 - Graph of the subtype relation  http://hackage.haskell.org/package/th-typegraph-0.18 (DavidFox)
14:15:10 <sveit> arkeet: so that type synonym would be impossible to write without extensions?
14:16:17 <eds> how would I know if E is floating without checking?
14:16:22 <enthropy> Vektorweg1: on second thought it's HList's TIC, which can probably be done with extensible somehow
14:16:24 <Hijiri> If there would be an instance for it
14:16:32 <Hijiri> The typechecker can see all instances that are in scope
14:16:35 <arkeet> sveit: right.
14:16:43 <Hijiri> When you do sin blah
14:16:55 <Hijiri> It checks if blah's type has an instance of Floating
14:17:30 <sveit> arkeet: i was hoping you'd say wrong :) that seems like a pretty serious oversight. so without this extension there would be no way around it besides passing p and f to the Iso.
14:17:30 <Hijiri> If you already know blah's type is Apple, adding Floating Apple to the constraints of your function doesn't do anything, because the compiler is already checking that Apple is Floating
14:17:33 <eds> so it would print error at runtime, right? or depending upon how I use sin in a function. right?
14:17:52 <arkeet> sveit: well, it's not very useful without extensions anyway.
14:18:00 <arkeet> imo.
14:18:17 <eds> yea. I get it now. Thanks.
14:18:26 <Hijiri> applying a typeclass constraint to something that isn't a type variable would say something at compile-time, if at all
14:18:32 <Hijiri> same with using sin the wrong way
14:19:06 <Hijiri> typeclass stuff is resolved at compile time
14:20:55 <eds> ohh ok. I meant using sine a wrong way in the ghci command line, would print an error at runtime. While using it in a function would print an error during runtime, since it checks the typeclass. Cool.
14:21:16 <eds>  mean compile time*
14:25:01 * hackagebot catamorphism 0.5.0.0 - A package exposing a helper function for generating catamorphisms.  http://hackage.haskell.org/package/catamorphism-0.5.0.0 (frerich)
14:25:57 <rhaps0dy> hello!
14:26:03 <rhaps0dy> can you please help me diagnose this error? http://hastebin.com/duyupexelu.coffee
14:26:07 <rhaps0dy> I'm trying to install elm-debugger
14:26:16 <rhaps0dy> and it complains about "elm" not existing
14:26:37 <rhaps0dy> but the binary is in the PATH
14:26:57 <arkeet> frerich: would be nice if you gave the type of the cataExpr example in the doc :-)
14:27:22 <napping> rhaps0dy: where are you getting the elm-debugger package?
14:27:41 <rhaps0dy> from github!
14:28:14 <rhaps0dy> https://github.com/elm-lang/debug.elm-lang.org
14:28:30 <rhaps0dy> huh
14:28:48 <rhaps0dy> wait a minute, maybe it complains about it not existing but I need the exact version of elm that's in the github too
14:29:00 <napping> The instructions say you need to build a particular branch of the elm compiler
14:29:38 <napping> I'd try that and see if it fixes things - it also could be that you need something available as a haskell library and not just a binary
14:30:49 <rhaps0dy> Thank you!
14:30:55 <Vektorweg1> enthropy: yes. pattern matching would be a bit difficult. if you only except certain types, i guess coming around with ´to´ is fine. i checked hlist, but it was a too opaque. 
14:30:56 <rhaps0dy> I will report back with results
14:30:58 <napping> do you know how to install in a sandbox?
14:31:45 <Vektorweg1> enthropy: but maybe template haskell would be easier with just creating a easily matchable type. 
14:34:46 <rasen> How can I get the index of minimum?
14:36:03 <benzrf> rasen: why do you need the index
14:36:30 <rasen> I need it to index a couple of other lists
14:36:47 <napping> sounds inefficient, but you can get it with zip
14:36:49 <rhaps0dy> rasen: (fst . min) (zip list [1..])
14:36:54 <rhaps0dy> uh
14:36:56 <rhaps0dy> swap fst for snd
14:37:07 <kadoban> :t fst . minimumBy (comparing snd) . zip [1..]  -- rasen
14:37:08 <lambdabot> (Enum a1, Num a1, Ord a) => [a] -> a1
14:37:22 <benzrf> :t minimumOn
14:37:24 <lambdabot>     Not in scope: ‘minimumOn’
14:37:24 <lambdabot>     Perhaps you meant one of these:
14:37:24 <lambdabot>       ‘minimumOf’ (imported from Control.Lens),
14:37:27 <napping> > fst . minimumBy (comparing snd) . zip [1..] $ "hello"
14:37:27 <benzrf> :(
14:37:29 <lambdabot>  2
14:37:39 <napping> oh, comparing snd
14:37:45 <rasen> Thanks, guys
14:37:57 <napping> comparing the index too doesn't hurt much here
14:38:09 <napping> not allowed to complain about performance if you're going to feed the result into !!
14:38:45 <kadoban> Well, if you compare the index too you have to flip the zip though, but yeah you can do that.
14:39:56 <napping> I think "minimum (zip my_list [1..])" is the most straightforward example of the idea
14:40:01 * hackagebot catamorphism 0.5.0.1 - A package exposing a helper function for generating catamorphisms.  http://hackage.haskell.org/package/catamorphism-0.5.0.1 (frerich)
14:40:21 <SrPx> Two functions are equal if their string representation is the same. What is the name of that kind of equality?
14:40:23 <frerich> arkeet: Done. :-)
14:40:44 <arkeet> if you want to index a second list by the index of the minimum of the first list
14:40:49 <arkeet> just zip those two lists to gether.
14:40:51 <arkeet> together
14:40:56 <arkeet> and get the minimum by the first
14:41:16 <arkeet> > snd . minimumBy (comapring fst) $ zip [3,2,1,4] "abcd"
14:41:18 <lambdabot>      Not in scope: ‘comapring’
14:41:18 <lambdabot>      Perhaps you meant ‘comparing’ (imported from Data.Ord)
14:41:23 <arkeet> > snd . minimumBy (comparing fst) $ zip [3,2,1,4] "abcd"
14:41:24 <lambdabot>  'c'
14:41:30 <napping> SrPx: Is it "intensional"?
14:42:19 <SrPx> Thanks!
14:42:44 <geekosaur> rhaps0dy, how did you check that elm is on $PATH?
14:42:52 <napping> Comparing strings isn't a good definition, but it's a good example
14:43:17 <geekosaur> ("which" has a tendency to show you what the next shell you start that reads your dotfiles will get. use "type" to see what the *current* shell knows)
14:44:59 <rhaps0dy> geekosaur: which elm
14:45:01 <rhaps0dy> ah
14:45:08 <rhaps0dy> elm is hashed.
14:45:11 <napping> geekosaur: how did you find that?
14:45:15 <geekosaur> ok, so that's not it
14:45:19 <rhaps0dy> ooh
14:45:28 <rhaps0dy> yup, it's not
14:45:30 <tswett> Given a Double, is there an easy way to get a String showing its binary representation, nicely formatted?
14:45:31 <SrPx> So, the question I wanted to ask is: Let `f` and `g` be lambda terms in the normal form, such that `f` is intensionally different from `g`. Is there any choice of `f` and `g` such that, for any `x` (that is also a lambda term), `f x == g x`?
14:45:32 <napping> that's a good thing to know! My /bin/which is a shell script
14:46:00 <napping> SrPx: what kind of normal form?
14:46:07 <geekosaur> history, mostly. POSIX adopted "type" as a shell builtin specifically to solve thee problem of "which" usually being an external command that reads your dotfiles
14:46:23 <johnw> SrPx: I don't think you even need to say "intensionally different"
14:46:28 <napping> If it was a binary that just read environment variables it might get something reasonable
14:46:37 <johnw> SrPx: the moment you say "f and g", for the theorem to hold it must be true for any choices of f and g
14:46:42 <hexagoxel> (`hash -r` clears cache without re-open/login)
14:46:47 <geekosaur> it'll still miss things like the command hash table
14:46:56 <SrPx> johnw: but then you can say f == g, no? napping beta & alpha
14:47:00 <napping> johnw: the question is whether any choices of f and g exist, taking f == g is trivial
14:47:08 <johnw> oh, it asks for existence
14:47:20 <geekosaur> (*some* shells have "which" as a builtin, but it's not a good idea to rely on it. "type" is required to report on what the current shell knows)
14:47:24 <SrPx> napping: eta*
14:47:58 <johnw> intensional feels like an odd word here
14:48:17 <Peaker> diginet: Haskell is more nominally typed than structurally typed
14:48:19 <Peaker> diginet: and has inference
14:48:25 <geekosaur> (also I come from a time when "which" worked best with csh and 4.2BSD /bin/sh, and didn't understand other shells at all :)
14:48:37 <napping> johnw: you don't need to say intensional, if you just say they are different terms in normal form
14:48:43 <SrPx> I'm not good at phrasing this, but did you understand what I mean?
14:48:53 <johnw> yeah, I understood, I'd go with napping
14:48:54 <tswett> SrPx: I think I understand you.
14:49:01 <diginet> Peaker: it is? I see. For some reason, I thought Haskell was structural. Haskell doesn't have subtyping though, does it?
14:49:05 <SrPx> napping: that's better, okay!
14:49:41 <napping> I don't remember appropriate theorems, but I'm pretty sure you can't find them
14:50:01 <eds> can mod take anything except integral type?
14:50:02 * hackagebot lens-simple 0.1.0.1 - simplified import of elementary lens-family combinators  http://hackage.haskell.org/package/lens-simple-0.1.0.1 (MichaelThompson)
14:50:04 <napping> intuitively, if it's true for all x it's true if you treat x as an uninterpreted constant
14:50:14 <napping> but then f x and g x are just the bodies of f and g with x as a free variable
14:50:18 <SrPx> the point in the question is, are there different functions that always behave the same way?
14:50:24 <Philonous> Is there a particular reason GHC.TypeLits doesn't include singleton-version of (type-level) +, - * ... for Nat ?
14:50:29 <eds> Like a double which is a Num type?
14:50:30 <Philonous> versions*
14:50:33 <napping> and if those reduce to the same thing, at least one of f and g wasn't already in normal form
14:50:45 <SrPx> hm
14:50:58 <tswett> SrPx: if you're allowed free variables, then I think "a" and "\x -> a x"
14:51:00 <napping> SrPx: for example, http://en.wikipedia.org/wiki/Fixed-point_combinator#Non-standard_fixed-point_combinators
14:51:08 <Peaker> diginet: Haskell doesn't have subtyping per-se, but you could say more specialized type-class constraints are like a subtype
14:51:12 <SrPx> what do you mean with "an uninterpreted constant"? 
14:51:27 <diginet> Peaker: gotcha
14:51:42 <eds> The error I am getting is - No instance for (Integral Double) arising from a use of `mod'
14:52:01 <napping> as a normal form, f = \x . f_body and g = \x . g_body, where f_body and g_body involve x
14:52:45 <napping> if f x and g x always reduce to the same thing, without any assumptions at all about how x reduces, then f_body and g_body should already reduce to the same thing
14:53:35 <rhaps0dy> ok, the elm binary is called on setup
14:53:37 <rhaps0dy>                handle <- runProcess "elm" args workingDir' Nothing Nothing Nothing Nothing
14:53:49 <rhaps0dy> no idea why it's not found, but I'll put the absolute path u.u
14:54:24 <rhaps0dy> still does not exist :|
14:55:53 <geekosaur> that makes me wonder if it's coming from somewhere else, like the checks done by the Cabal library
14:56:24 <SrPx> napping: okay! (sorry for the delay, was reading the bohm tree article)
14:57:01 <Tuplanolla> I'm trying to send the addresses of connected peers through a socket, but there's no instance Binary SockAddr or instance Generic SockAddr, so what can I do?
14:57:01 <SrPx> napping: so, extensional equality and intensional equality are the same for the untyped calculus?
14:57:29 <napping> SrPx: I think that's true for normal forms, at least
14:57:40 <SrPx> cool, thanks :)
14:57:46 <enthropy> Vektorweg1: too opaque meaning too hard to understand, or you didn't see that the implementation is exported if you specifically import Data.HList.Variant?
14:58:14 <rhaps0dy> ah, an elm file to be compiled does not exist
14:58:16 <rhaps0dy> wtf really
14:58:51 <geekosaur> sounds like elm's error messages are about as good as xmobar's >.>
14:59:08 <SrPx> That is a little unfamiliar, though. In Haskell, we can have an infinite number of functions that are intensionally different but always produce the same result (quicksort, mergesort, etc). Yet that is not the case without types...?
14:59:23 <SrPx> Strange
14:59:29 <rhaps0dy> ah, I think you gotta clone recursively but it's not mentioned
14:59:31 <rhaps0dy> rip
14:59:38 <napping> No, Haskell only goes to weak head normal form
14:59:46 <rhaps0dy> geekosaur: the compiler says "not found", but in this case you have no idea what it's not found
14:59:54 <napping> (\x -> (\y -> y) x) and (\x -> x) always evaluate to the same way
14:59:58 <Vektorweg1> enthropy: too hard to read the docs. 
15:00:02 * hackagebot lens-simple 0.1.0.2 - simplified import of elementary lens-family combinators  http://hackage.haskell.org/package/lens-simple-0.1.0.2 (MichaelThompson)
15:00:05 <napping> but unless you evaluate under a lambda those are both normal forms
15:00:43 <SrPx> napping: I see
15:01:03 <Vektorweg1> enthropy: i'm losing my motivation reading so much stuff, when i just want to use it. 
15:01:34 <geekosaur> rhaps0dy, exactly. crappy error message
15:01:57 <SrPx> is there any good resource on the complexity analysis of functional programs?
15:01:59 <geekosaur> actually I think that one's worse than xmobar, which has some of the crappiest error messages I've ever had to diagnose
15:02:15 <napping> so it's elm printing out "file not found" instead of something not finding elm?
15:02:28 <geekosaur> yes
15:02:48 <Vektorweg1> enthropy: also the tags and proxies seem unusually cumbersome.
15:02:51 * enthropy dealt with a f77 interpreter that didn't give any hint that variables couldn't be longer than x characters
15:03:27 <michaelt> who needs a  hint that variables shouldn't be longer than x characters?
15:03:28 <napping> enthropy: are you sure that's not a feature?
15:03:34 <napping> It's how you comment your program!
15:04:03 <rhaps0dy> geekosaur: during installation!
15:04:10 <enthropy> michaelt: I do from pretending it's f90
15:04:52 <eacameron1> stackage sandbox init was broken by the server recently; any news?
15:05:03 * hackagebot wai-request-spec 0.10.0.1 - Declarative request parsing  http://hackage.haskell.org/package/wai-request-spec-0.10.0.1 (alcabrera)
15:05:07 <geekosaur> michaelt, it's a historical thing from fortran on mainframes where symbols often had to be <=6 characters
15:05:20 <michaelt> ah
15:06:46 <dedgrant> eds: Try Data.Fixed.mod':  http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Fixed.html#v:mod-39-
15:07:18 <Tuplanolla> I can't find a way to serialize a SockAddr.
15:07:55 <enthropy> Vektorweg1: well if you don't have a proxy argument, you're stuck making type annotations that are as big as declaring a data type
15:07:58 <Vektorweg1> Tuplanolla: why should you?
15:08:12 <Tuplanolla> I'm trying to send the addresses of connected peers through a socket, Vektorweg1.
15:08:38 <Vektorweg1> Tuplanolla: maybe you should just transmit the hostname and create a new sockaddr there. 
15:09:26 <Tuplanolla> How do you even extract a hostname?
15:10:10 <Vektorweg1> Tuplanolla: which api do you use?
15:10:28 <Tuplanolla> Network.Socket seems to have getNameInfo.
15:11:14 <Vektorweg1> Tuplanolla: this looks like the right function. 
15:12:02 <eds> Worked for mod. thanks.
15:12:21 <eds> But gives me error for div now. http://lpaste.net/133728
15:12:37 <Vektorweg1> enthropy: maybe you are right. making a new type is not that costly. 
15:12:42 <Tuplanolla> It would've been much easier to simply send s $ encode a with instance Binary SockAddr.
15:13:23 <Vektorweg1> Tuplanolla: what happens when you show SockAddr? 
15:13:25 <Peaker> Tuplanolla: you probably need special handling for IPv4 vs IPv6 vs Unix-sockets
15:13:47 <Peaker> Tuplanolla: you could try "standalone deriving" of Generic and then "instance Binary"
15:13:57 <eds> even on using div'
15:13:58 <Vektorweg1> Tuplanolla: and what is with the typeable instance? i guess you could get a portable string out of it. 
15:14:09 <Tuplanolla> Let's try these things.
15:18:20 <Peaker> Tuplanolla: with DeriveGeneric and StandaloneDeriving, I managed to derive Generic on both PortNumber and SockAddr. Then I can do: "instance Binary PortNumber", ditto for SockAddr.
15:18:32 <lpaste> Tuplanolla pasted “instance Binary SockAddr” at http://lpaste.net/133735
15:18:41 <Tuplanolla> That's what I had.
15:19:29 <Peaker> Tuplanolla: you need "StandaloneDeriving" too and "deriving instance Generic PortNumber", ditto for SockAddr
15:20:17 <lpaste> Peaker annotated “instance Binary SockAddr” with “instance Binary SockAddr (annotation)” at http://lpaste.net/133735#a133736
15:21:04 <dedgrant> tswett: I was curious about your question about extracting and formatting output of bits from Double.. dropping the formatting, I wonder if any existing package does this? Seems to want some fiddling with unboxed #Double primops in GHC. Also curious about how stable the Double implementation in Haskell is across compilers.
15:21:21 <Tuplanolla> That indeed works. Thanks, Peaker.
15:21:57 <Peaker> Tuplanolla: I heard they want to make GHC derive Generic for all the things!
15:21:59 <Peaker> that would be great
15:22:06 <Tuplanolla> I wouldn't mind that.
15:22:37 <Peaker> moreover, they want "deriving (X, Y, Z)" to translate to "instance X T ; instance Y T ; ...", so you can write: "deriving (Binary)", yay!
15:22:56 <Peaker> which would finally be a proper user-extensible deriving mechanism
15:24:27 <tswett> dedgrant: well, I've never heard of a type called "double" that wasn't an IEEE double-precision floating point.
15:24:59 <johnw> data Double a = Double a a
15:25:32 <Peaker> Double = (^2)? :P
15:25:44 <Peaker> type Double a = (Bool, a)
15:26:11 <Peaker> type Square a = Square a a
15:26:15 <Peaker> (data, arg)
15:30:56 <dedgrant> tswett: Fair enough. Oh: https://hackage.haskell.org/package/data-binary-ieee754-0.4.2.1/docs/Data-Binary-IEEE754.html
15:31:07 <Vektorweg1> Tuplanolla: Peaker: are you sure that putting things in binary format is a good idea? whats the problem with textbased - Read/Show? 
15:31:51 <Tuplanolla> In order: no, inconvenience.
15:32:45 <dedgrant> tswett: Seems to prefer the Foreign allocation to map the bits... ick.
15:34:13 <Peaker> Vektorweg1: Read/Show is fine too.
15:34:52 <ion> Peaker: (^2) = (Bool ->), isn't it?
15:35:04 * hackagebot number 0.1.0.0 - A library for real numbers  http://hackage.haskell.org/package/number-0.1.0.0 (rnhmjoj)
15:35:12 <Ralith_> binary formats are underrated
15:35:21 <Ralith_> as anyone who's had to deal with text encodings should know very well
15:35:39 <Ralith_> text is just another binary format, and a binary format inside a binary format doesn't make anyone's life easier in the end
15:36:52 <Vektorweg1> Ralith_: binary format is overrated
15:37:19 <Peaker> ion: (^2) = (Bool ->) = Join (,)
15:37:20 <Ralith_> no, that's the opposite of what I said
15:37:31 <Vektorweg1> have you needed to deal with encodings while working with haskell's Read/Show? 
15:37:51 <Peaker> ion: (Bool -> a) and (a, a) are equivalent (modulo bottom/performance nonsense :-) )
15:37:58 <Ralith_> your failure to account for something is different than that thing not mattering
15:38:25 <ion> <Peaker> type Double a = (Bool, a)
15:38:29 <Peaker> Vektorweg1: Binary format is more performant when that matters
15:38:50 <Vektorweg1> Peaker: only a little bit. 
15:39:01 <Peaker> ion: Yeah,  double a = 2 * a      so Double a = (Bool, a)
15:39:38 <ion> Ah, you didn't mean that as another implementation of johnw's Double. Never mind.
15:39:39 <Peaker> Vektorweg1: I use a lot of C, where it is a huge difference (simply because binary dump often consists of dumping your existing memory)
15:39:48 <Vektorweg1> Peaker: and you know ... there aren't many times where performance speed really matters. 
15:39:50 <Peaker> Vektorweg1: in Haskell it's still probably significantly faster
15:40:23 <Peaker> Vektorweg1: Most of what I did in recent weeks was performance profiling, so it shapes my view atm :-)
15:40:58 <Peaker> and btw, "perf" (especially with stack traces) is an amazing tool, and GHC has *got* to generate the proper debug info so that perf can generate stack trace samples for Haskell
15:41:17 <Peaker> The FlameGraphs you can generate from perf output are incredibly informative
15:41:38 <Vektorweg1> Peaker: come they with real flames? ;)
15:42:46 <ion> Depends on whether you have an early '00s AMD CPU.
15:43:23 <Peaker> Vektorweg1: http://www.brendangregg.com/FlameGraphs/cpu-mysql-filt.svg :)
15:43:55 <Tuplanolla> That's all kinds of dandy.
15:44:57 <dicioccio> Vektorweg1: Read/Show are not really good for serialization/deserialization, partly because few library authors see them as a serialization/deserialization
15:45:15 <dicioccio> I'd not be surprise if read/show do not round trip in some of my libs
15:46:09 <ion> > show (read "hello" :: StdGen)
15:46:11 <lambdabot>  "12802 1"
15:46:25 <Ralith_> Peaker: what tool are you using to generate those graphs from perf's output?
15:48:16 <Peaker> Ralith_: https://github.com/brendangregg/FlameGraph
15:48:30 <Ralith_> thanks
15:49:01 <Peaker> Ralith_: it's made us truly understand our CPU performance issues (in a C project) where other attempts always gave us a tiny peek through a keyhole
15:49:23 <Peaker> (or full profiling which skews the results terribly)
15:49:33 <Ralith_> there are lots of different ways to visualize profiling output, so it is always nice to have another
15:49:42 <bitonic> Peaker: GHC already generates the proper debug info
15:50:03 <bitonic> I have a blog post describing exactly how to do that in my pipeline
15:50:26 <Peaker> bitonic: I understood that it doesn't generate enough for stack traces
15:50:27 <bitonic> it's a shame that you can't get Haskell stack traces with perf
15:50:36 <bitonic> Peaker: that's right, for quite deep reasons
15:50:41 <Peaker> :-(
15:50:51 <Peaker> I thought GHC now always knows how to generate stack traces?
15:50:53 <bitonic> the kernel copies the C stack for the userland `perf` to analyze
15:51:09 <bitonic> so the information is just not there when the `perf` tool is interrupted
15:51:17 <Peaker> bitonic: a kernel patch? :-)
15:51:33 <bitonic> yeah, a kernel patch including details about the Haskell RTS
15:51:40 <Peaker> the kernel follows the stack frame pointer chain?
15:51:48 <bitonic> the kernel doesn't follow anything
15:51:53 <bitonic> basically
15:52:00 <Peaker> does it copy the entire stack at each sample(??)
15:52:03 <bitonic> yes
15:52:10 <bitonic> until it fills a mmap
15:52:14 <Peaker> isn't that incredibly expensive?
15:52:24 <bitonic> it's quite expensive yes
15:52:34 <bitonic> `perf record --call-graph` is way more expensive than `perf record`
15:52:45 <Peaker> perhaps it maps the stack to the perf process, rather than copies it?
15:53:21 <bitonic> maybe..
15:53:31 <bitonic> although I don't think so
15:53:33 <bitonic> I think it just copies it
15:53:37 <Ralith_> a more realistic approach would be to generate perf-compatible output data from a purpose-built haskell profiler
15:53:53 <bitonic> Ralith_: you can already do that with the output of the RTS
15:54:04 <bitonic> but you don't get the big advangates of perf -- always on, no overhead
15:54:50 <bitonic> you could also write a tool using `perf_event_open` that actually unwinds the Haskell stack at each interrupt
15:54:52 <bitonic> I think
15:55:10 <dedgrant> BTW with the talk of perf, if anyone would like to help me hack GHC.RTS.Events so that it can stream Events, I'm looking for help. :)  Really want to see live profiling output from the RTS.
15:55:38 <bitonic> basically you'd do what https://github.com/blitzcode/ghc-stack does at each interrupt, but using DWARF
15:58:57 <bitonic> Peaker: anyway, the whole DWARF stuff has great great potential
15:59:02 <bitonic> even if we don't get flame graphs :P
15:59:09 * bitonic is excited
15:59:56 <Vektorweg1> couldn't someone write a haskell template that writes logs for every begin and end of a function? :p
16:00:17 <bitonic> Vektorweg1: that's pretty much what the profiling cost centers do
16:06:03 <Peaker> bitonic: using gdb on Haskell code sanely?
16:06:08 <Peaker> (or other stuff?)
16:06:15 <bitonic> Peaker: yes, you can already do that
16:06:23 <bitonic> and with `perf record` you get nice hotspot analysis
16:06:34 <bitonic> no inherited information, but hotspot analysis is something
16:06:57 <Peaker> bitonic: I guess it's about 20% of the awesomeness
16:07:00 <bitonic> you get the hotspots within the assembly side by side with the Haskell source code
16:07:13 <bitonic> you get the precise hotspots within the RTS
16:07:35 <bitonic> you get IO/cache misses/branch misses/whatever hotspots
16:07:54 <Peaker> but in most cases IME the problem isn't a particular hotspot, but a whole sub-graph of the call-graph, none of the "leaves" necessarily seem like hotspots
16:08:07 <bitonic> well the thing is
16:08:15 <Peaker> Or rather, you run out of hot spots after just a bit of optimization
16:08:25 <Peaker> and then you will remain blind to the bigger issues
16:08:39 <bitonic> if you're able to narrow down your performance problem, then `perf` is very useful to analyze where time is spent precisely
16:10:25 <bitonic> proper stack traces will be very tough to get
16:11:07 <bitonic> within perf anyway
16:13:36 <Peaker> looking at perf https://github.com/torvalds/linux/commit/5ea8415407a76c4a85ac971ec82d110161cd77f1 seems like there exists libunwind/dwarf support?
16:14:11 <bitonic> Peaker: yes, of course
16:14:22 <bitonic> but the perf userland tools are not given the right stack to unwind
16:14:24 <Vektorweg1> i actually have dwarf fortress running. 
16:14:31 <Vektorweg1> :p
16:32:13 <ThEBLacKMaN>  virtualcurency -> A game where the virtual currency can be converted in REAL MONEY! just click big button sign up. Register here http://www.marketglory.com/strategygame/lolopoco
16:33:20 <rasen> dwarf fortress still rocks
16:33:43 <subleq> bwahahaha, I made ghc's brain explode
16:33:57 <subleq> My brain just exploded: I can't handle pattern bindings for existential or GADT data constructors.  Instead, use a case-expression, or do-notation, to unpack the constructor.
16:36:04 <YepG> Hi, I'm looking for an iterate function that iterates over the answer :: ([a] -> a) -> a -> [a]
16:36:26 <benzrf> YepG: interesting
16:37:02 <benzrf> YepG: prepend or append?
16:37:27 <YepG> actually, I probably more want :: :: ([a] -> a) -> [a] -> [a]
16:37:31 <YepG> append
16:37:36 <YepG> but either is fine
16:37:43 <Cale> What, like...
16:37:53 <Cale> :t (\f x -> fix (f . (x:)))
16:37:55 <lambdabot> ([a] -> [a]) -> a -> [a]
16:37:58 <Cale> ?
16:38:00 <benzrf> wew
16:38:25 <Cale> That's not quite what you asked for...
16:38:34 <Cale> I'm not really sure what you want the function to do in any case though.
16:38:42 <subleq> what does 'unpack the constructor' mean in that error message?
16:38:45 <f|`-`|f> what's the precedent function?
16:38:54 <benzrf> @src iteate
16:38:55 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
16:38:56 <benzrf> @src iterate
16:38:56 <lambdabot> iterate f x = x : iterate f (f x)
16:38:59 <benzrf> ah yes
16:39:15 <Cale> subleq: Pattern match on it, extracting the fields.
16:39:19 <f|`-`|f> hlep?
16:39:42 <Cale> subleq: (along with any class dictionaries which constrain the existential type variable)
16:39:58 <subleq> Cale: ok
16:40:07 <Cale> f|`-`|f: I don't understand your question.
16:40:13 <benzrf> YepG: hmmmmmm
16:40:14 <subleq> Cale: Do you know why it's an error in the first place?
16:40:29 <f|`-`|f> the function that gives you the precedence of an operator
16:42:27 <Cale> subleq: Well, it's complicated, I guess.
16:42:27 <YepG> as a very simple example I want the new iterate function to work like this: iterate' (\x -> length x + 1) [0,1] == [0,1.2,3,...]
16:43:10 <benzrf> YepG: yeah i know
16:43:17 <Cale> I didn't know
16:43:53 <Cale> Why is that the result?
16:44:23 <YepG> I was hoping there was an obvious function I missed.
16:44:37 <ion> @hoogle ([a] -> a) -> [a] -> [a]
16:44:39 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
16:44:39 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
16:44:42 <benzrf> :t let iter f acc = f acc:iter f (f acc:acc) in iter
16:44:43 <lambdabot> ([a] -> a) -> [a] -> [a]
16:44:45 <benzrf> hmm
16:44:51 <Cale> You presumably mean [0,1,2,3,...] and not [0,1.2,3,...]
16:44:57 <Pamelloes> Can ( () -> a ) be unified with a?
16:44:58 <Cale> But even then, why is the third element 2?
16:44:59 <benzrf> > let iter f acc = f acc:iter f (f acc:acc) in iter (\x -> length x + 1) []
16:45:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:45:02 <YepG> Cale: yes sorry
16:45:15 <YepG> oh sorry
16:45:30 <ion> @hoogle (w a -> a) -> w a -> w a
16:45:32 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
16:45:32 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
16:45:38 <benzrf> ion: 'extend'
16:46:06 <YepG> your right Cale, should have started from 1
16:46:19 <Cale> hm?
16:46:31 <Cale> I'm still confused about what this function ought to do
16:46:34 <aupiff> if I am using creating a haskell shared library, how can I ensure that things like parMap from Control.Parallel will use all available cores on a machine?
16:47:10 <aupiff> my parMap code currently looks like it's only using a single core and I'm confused about what ghc flags I should be using
16:47:15 <YepG> benzrf: Thanks I'll see how I go with that :)
16:47:43 <Cale> aupiff: You should compile with -threaded and run with +RTS -N4 if you want to use 4 cores.
16:47:43 <aupiff> I am calling my Haskell .so file from python, in case that helps.
16:47:52 <Cale> oh
16:48:01 <Cale> hmm
16:48:17 <Cale> Maybe you have to bake in some RTS options.
16:48:29 <aupiff> as a ghc flag?
16:48:54 <benzrf> Cale: iter f acc = f acc:iter f (f acc:acc)
16:49:38 <aupiff> ah i see, using the -with-rtsopts flag
16:49:42 <aupiff> trying that now
16:49:42 <Cale> aupiff: -threaded is a GHC flag, the +RTS -N4 is usually a commandline parameter to the resulting Haskell program
16:50:50 <Cale> aupiff: But you just said that you're building a .so and linking that against some other non-Haskell code, so I don't really know... I seem to recall a way that you could link in a small .c file which would set the RTS options
16:51:09 <aupiff> Cale: right, so I'm going to try ghc  -threaded -with-rtsopts="-N4"
16:51:25 <aupiff> if that doesn't work I'll look into the .c file thing
16:51:39 <Cale> You could also possibly use Control.Concurrent.setNumCapabilities
16:51:43 <Cale> which I think is somewhat new
16:52:23 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Control-Concurrent.html#v:setNumCapabilities
16:52:46 <aupiff> Cale: ah, thanks!
16:53:27 <mjrosenb> In the cont monad, is there anything that is shorthand for (\action -> cont (action >>=))
16:53:50 <Cale> :t(\action -> cont (action >>=))
16:53:52 <Cale> :t (\action -> cont (action >>=))
16:53:53 <dedgrant> Pamelloes: (() -> a) is shorthand for (forall a. () -> a), which cannot be unified except through the usual bottom type.
16:53:53 <lambdabot> Monad m => m a -> Cont (m b) a
16:54:08 <Cale> hmm, I think no
16:54:44 <mjrosenb> I thought that was return, but return did not have the type I wanted it to
16:55:11 <Cale> Well, return has the obvious type
16:55:47 <mjrosenb> right, just Cont has its types in strange places.
16:55:55 <Cale> mjrosenb: The argument to this function must be an action in some monad
16:56:03 <Cale> Because you apply (>>=) to it
16:56:31 <Cale> But return's type is parametrically polymorphic in the type of its argument
16:56:38 <Cale> So definitely can't be return
16:57:11 <Cale> Where did this function come up?
16:57:17 <mjrosenb> Cale: correct.
16:57:44 <mjrosenb> Cale: so, this is for the with* functions, all of which perform some IO
16:58:06 <mjrosenb> this is to lift a non-with IO based function into the with-based Cont monad.
16:58:21 <Cale> waaaaaa
16:58:29 <Cale> What about lift?
16:58:38 <Cale> :t lift :: IO a -> ContT r IO a
16:58:39 <lambdabot> IO a -> ContT r IO a
16:59:29 <Cale> Er, wait, you said function
16:59:49 <Cale> Oh, but it doesn't take a function anyway, so you don't mean function, all right :)
17:12:35 <quickquestion> Quick question. Does anyone know which ListT implementation I should be using? The default ListT doesn't have the laziness I need, and there are a few competing ListT implementations found in other packages.
17:16:37 <YellowOnion> how would I get a fold to terminate early when a condition on the accumulator is met?
17:17:29 <glguy> YellowOnion: You could write it as a "scan" and then take the first element of the result that satisfies your condition
17:17:44 <quickquestion> I don't believe fold doesn't provide early termination support. You'll have to do the recursion manually.
17:18:49 <glguy> > find odd (scanl (+) 0 [2,4,6,7,9,11])
17:18:50 <lambdabot>  Just 19
17:19:04 <glguy> fold that stops when the accumulator goes odd
17:19:22 <glguy> > 2+4+6+7
17:19:24 <lambdabot>  19
17:19:34 <YellowOnion> glguy, ahh that actually makes sense, I was just thinking must be able to leavage takeWhile or something
17:20:10 * hackagebot farmhash 0.1.0.3 - Fast hash functions.  http://hackage.haskell.org/package/farmhash-0.1.0.3 (abhinav)
17:20:12 * hackagebot diagrams-builder 0.7.0.3 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.7.0.3 (BrentYorgey)
17:20:17 <Denommus> I just explained monads to a complete newbie, and he understood it :-D
17:20:33 <quickquestion> Nice.
17:20:55 <quickquestion> Did you explain the mechanics of them or why they're useful?
17:20:58 <byorgey> Denommus: perhaps that means you didn't explain them very well ;-)
17:21:11 <YellowOnion> glguy, I'm actually abusing lists of Bools, but with (&&) once its false its always false.
17:21:53 <Denommus> quickquestion: yup
17:22:09 <glguy> > foldr (&&) True (True:False:undefined)
17:22:11 <lambdabot>  False
17:22:17 <Denommus> he had some Haskell background, but it wasn't a lot
17:22:18 <Denommus> he never used a typeclass
17:22:28 <glguy> YellowOnion: If the function you're folding with is sufficiently lazy you don't need to do anything clever for the fold to "terminate early"
17:22:45 <YellowOnion> > foldl (\acc x -> (x < 50) && acc) True [0..99]
17:22:47 <lambdabot>  False
17:22:59 <YellowOnion> glguy, something like this^
17:23:05 <glguy> YellowOnion: all (< 50)
17:23:37 <glguy> > all (< 50) (repeat 100)
17:23:39 <lambdabot>  False
17:23:56 <YellowOnion> glguy, ahh right theres a function for this haha
17:24:15 <athan> Is there a newtype for bounded integers?
17:25:25 <johnw> @hackage data-fin
17:25:25 <lambdabot> http://hackage.haskell.org/package/data-fin
17:26:34 <athan> Thanks johnw :)
17:35:10 * hackagebot diagrams-rubiks-cube 0.2.0.0 - Library for drawing the Rubik's Cube.  http://hackage.haskell.org/package/diagrams-rubiks-cube-0.2.0.0 (TimBaumann)
17:35:55 <Pamelloes> dedgrant: Sorry I didn't respond earlier, I was engaged elsewhere. I'm still confused why they don't unify. For instance, if one substitutes in Int for a, how is () -> Int any different from Int?
17:37:44 <johnw> Pamelloes: only the caller can substitute, not the one defining the function
17:38:15 <Pamelloes> johnw: can you clarify, I don't really understand what you just said
17:38:29 <johnw> ok, this is about universal vs. existential quantification
17:38:57 <johnw> if you give me a value foo :: forall a. a, then I can say (foo :: Int) and fix a to Int, yes
17:39:08 <johnw> but on the flip side, if you ask me to *define* foo
17:39:13 <johnw> then I can't fix a to anything
17:39:27 <Pamelloes> What if a is already fixed?
17:39:28 <johnw> the inability to "fix" the type is what it means for the type variable to be a universal
17:39:34 <johnw> foo :: Int is definable
17:39:47 <monochrom> a is not already fixed at the time of defining foo.
17:39:54 <johnw> how could it already be fixed when I'm writing the definition of foo?
17:40:10 * hackagebot stackage-sandbox 0.1.5 - Work with shared stackage sandboxes  http://hackage.haskell.org/package/stackage-sandbox-0.1.5 (DanBurton)
17:40:15 <Pamelloes> johnw: foo :: Int instead of foo :: a?
17:40:20 <johnw> now, this is completely different: foo :: (forall a. () -> a) -> a
17:40:48 <monochrom> if you define "foo :: Int", then there is no a.
17:40:49 <johnw> oops
17:40:59 <johnw> that type is invalid, n/m
17:41:06 <johnw> yes, monochrom is right, I'll let him explain
17:41:27 <monochrom> I am harshly logical
17:42:16 <Pamelloes> monochrom: I understand. My original question was can () -> a unify with a. The answer appears to be no, though I'm not sure if I understand why yet. However, if you fix a to, for instance, Int, will () -> Int unify with Int?
17:42:56 <hpc> why would it be able to?
17:43:09 <monochrom> unification is highly syntactic. "() -> Int" does not unify with "Int". on the slight pretext that there is no "->" in "Int".
17:43:14 <hpc> even if they represent the same values, they're different types
17:43:29 <hpc> ("same values" taken loosely)
17:43:50 <monochrom> unification is not going to solve domain equations to see whether two types are semantically isomorphic.
17:44:05 <johnw> Pamelloes: () -> Int is isomorphic, but not equal, to Int, in the sense that \_ -> 8 and 8 are not the same values
17:44:05 <monochrom> hell, even some humans can't do that
17:44:15 <hpc> and it's a feature that it doesn't!
17:44:18 <Pamelloes> Oh, I see.
17:44:55 <Pamelloes> So even though the types () -> Int and Int are, for all intents and purposes, identical, they have different types so they can't unify.
17:45:05 <monochrom> I'm pretty sure there exists two type such that the question "are they isomorphic" is still an open problem.
17:45:29 <johnw> Pamelloes: rather than identical, say equivalent
17:45:38 <johnw> which conveys the real sense of what you mean
17:45:45 <Pamelloes> Fair enough
17:45:57 <johnw> i.e., convertible with zero loss of information, provably so
17:46:22 <hpc> Pamelloes: by the way, unification goes both ways
17:46:37 <hpc> if you could reduce \_ -> 8 to 8 (arguably desirable)
17:46:46 <hpc> you can also expand 8 to \_ -> 8 again
17:47:02 <hpc> > 1 2 3 4 5 -- in fact, this used to work in lambdabot
17:47:04 <lambdabot>      Could not deduce (Num a0)
17:47:04 <lambdabot>      from the context (Num a,
17:47:04 <lambdabot>                        Num a4,
17:47:18 <hpc> (not in general but for numeric types only, and it was hell)
17:47:24 <hpc> ((albeit an interesting hell))
17:48:20 <athan> Is there such a thing as a /partial/ parser? Instead of turining a string into a structural, discrete AST, it rather "groups" or collects parts of the string into structures containing substrings?
17:48:20 <hpc> separate anecdote, a specific case where isomorphic types are intentionally non-unifying
17:48:44 <hpc> excel has two different units of int, screen coordinates and cell coordinates
17:48:57 <hpc> ie, pixel (400,500) vs (cell 12B)
17:49:11 <hpc> this was the origin of hungarian notation
17:49:31 <hpc> where you would prefix identifiers with what type of thing they were in a level more abstract than C could represent on its own
17:49:53 <hpc> (this later got perverted into "exactly what C represents on its own", but that's another story)
17:50:10 <hpc> in haskell, it would be newtype PixelX = PixelX Int
17:50:17 <hpc> newtype CellX = CellX Int
17:50:19 <hpc> (ditto for Y)
17:50:34 <hpc> and never the twain shall mix unless you write specific code for it
17:51:06 <Pamelloes> Hm, interesting
17:53:10 <monochrom> oh, no wonder they invented hungarian notation. it was supposed to be informative rather than duplicative
17:53:56 <dedgrant> hpc: nice history lesson :)
17:54:28 <hpc> monochrom: http://www.joelonsoftware.com/articles/Wrong.html
17:57:42 <structuralist> Is missingpy the standard way to call python from haskell?
17:58:04 <structuralist> I need to use some scipy stuff
18:00:11 * hackagebot acme-all-monad 0.1.0.0 - A monad which is powerful enough to interpret any action  http://hackage.haskell.org/package/acme-all-monad-0.1.0.0 (PhilFreeman)
18:02:33 <monochrom> I wonder if it's more beneficial to circumvent python and simply call the C routines that scipy calls anyway.
18:03:31 <peddie> structuralist: what scipy stuff do you need?
18:05:17 <dmj`> Fuuzetsu: ping !
18:06:04 <aupiff> I am trying to use Control.Concurrent.setNumCapabilities in a haskell shared lib (.so), but I keep getting errors saying I'm using the non-threaded RTS--this, despite compiling with the -threaded flag...
18:06:11 <aupiff> any ideas?
18:07:43 <johnw> hpc: as someone who had Systems Hungarian inflicted on them for the most idiotic of reasons, thank you for that article
18:09:57 <monochrom> aupiff: -threaded does nothing for *.so. you have to manually specify -lHSrts_thr-ghc7.8.3
18:10:19 <aupiff> monochrom: oh man, that's great news
18:10:32 <monochrom> and you have to manually change 7.8.3 to 7.10.2
18:13:27 <structuralist> peddie: optimize.curve_fit specifically
18:14:10 <structuralist> peddie: but I'm partly motivated by wanting to learn to wrap python
18:16:37 <peddie> structuralist: OK, I don't know how to wrap python, but hmatrix-gsl exposes almost the same nonlinear least-squares routine if you just want to get the job done in haskell
18:17:20 <peddie> structuralist: https://hackage.haskell.org/package/hmatrix-gsl-0.16.0.3/docs/Numeric-GSL-Fitting.html
18:18:19 <aupiff> monochrom: everything works and it's so fricken fast now. I'm so happy.
18:18:41 <structuralist> peddie: thanks!
18:19:50 <monochrom> congrats, aupiff
18:20:46 <bitemyapp> @karma+ monochrom
18:20:46 <lambdabot> monochrom's karma raised to 101.
18:21:19 <monochrom> that's way higher than I thought!
18:23:08 <johnw> yeah, it's in binary
18:23:38 <bitemyapp> dammit
18:23:40 <bitemyapp> @karma+ johnw
18:23:41 <lambdabot> johnw's karma raised to 21.
18:25:20 <structuralist> uh, so I'm trying to cabal install missingpy and it's failing because it can't find Data.HashTable
18:25:28 <structuralist> did this used to be in base and then get removed? I'm confused
18:25:45 <structuralist> how am I supposed to install this?
18:42:26 <dedgrant> structuralist: Perhaps it was moved to the hashtables package?  although missingpy was last updated 3 years ago, it may be worthwhile to ping the maintainers or offer a PR: https://github.com/softmechanics/missingpy 
18:43:45 <dedgrant> structuralist: Data.HashTable was indeed removed from base in GHC 7.8: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-HashTable.html
19:01:17 <greymalkin> What typeclass best describes a type which contains an array of itself?  It's not a typeclass itself, though, I'm just trying to figure out if it should be a Traversable, Foldable, or some such -- and how to describe that if I don't have a contained type.
19:02:12 <greymalkin> s/array/list/
19:02:54 <c_wraith> greymalkin: I'm not 100% sure what you're asking.
19:03:41 <greymalkin> data Card = Card { c_id :: CardId, c_attr :: Map String Attribute, c_children :: [Card] } -- seems like it should be Foldable?
19:04:02 <c_wraith> can't be Foldable, it has the wrong kind.
19:04:36 <c_wraith> Why are you looking for a class at all?
19:05:07 <greymalkin> Just trying to be complete.
19:05:14 * hackagebot haxr 3000.11 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.11 (BrentYorgey)
19:05:33 <c_wraith> If you're into the lens ecosystem, you can make it an instance of Plated to handle the self-similarity
19:06:55 <c_wraith> Of course, that's just lens's answer to Data.Data.  While Data.Data is a bit unwieldy, it's also about self-similarity
19:07:10 <c_wraith> Well, it's more general than that, but it *can* be about self-similarity
19:09:51 <dalaing_> you could also do something like data CardF c = Card {... c_children :: [c] ... }, and define Card as a type alias for the fixed point of CardF
19:10:15 * hackagebot BlogLiterately 0.8.1 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.8.1 (BrentYorgey)
19:10:38 <dalaing_> then you temporarily duck out of Card and into other varieties of CardF while doing various things
19:10:55 <dalaing_> not always what you want though
19:11:56 <greymalkin> Yeah, I'm still exploring -- seems like Card will want to know what Cards it will contain in this application.
19:20:22 <dalaing_> that would give you functor / foldable / traversable for CardF, which you could use with Card - although you can use lens to do similar things while making sure you always end up with an honest form of Card
19:20:33 <dalaing_> always a fun problem to chew on :)
19:25:15 * hackagebot sandman 0.1.0.1 - Manages Cabal sandboxes to avoid rebuilding packages.  http://hackage.haskell.org/package/sandman-0.1.0.1 (abhinav)
19:25:36 <greymalkin> I'll look a little more in-depth at lenses.
19:25:52 <greymalkin> I haven't revisited them since I groked monads, so it might be less intimidating now.
19:30:15 * hackagebot BlogLiterately-diagrams 0.2 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.2 (BrentYorgey)
19:30:17 * hackagebot kafka-client 0.7.0.1 - Low-level Haskell client library for Apache Kafka 0.7.  http://hackage.haskell.org/package/kafka-client-0.7.0.1 (abhinav)
19:35:02 <johnw> greymalkin: check out http://ftp.newartisans.com/pub/Lenses.mp4
19:35:16 * hackagebot diagrams-builder 0.7.0.4 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.7.0.4 (BrentYorgey)
19:41:42 <YellowOnion> Could someone help me with Criterion? for some reason whnf requires me to specific an Int
19:42:12 <YellowOnion> :t Criterion.Main.whnf
19:42:13 <lambdabot> Not in scope: ‘Criterion.Main.whnf’
19:43:44 <dramforever> YellowOnion: How are you using it?
19:43:52 <dramforever> can you post your code to lpaste
19:45:58 <YellowOnion> dramforever, basically "whnf cracker cipherTextA" -> http://lpaste.net/133747
19:47:26 <YellowOnion> dramforever, "Couldn't match type `[Char]' with `Int'"
19:49:08 <dramforever> YellowOnion: oops, sorry for the delay
19:49:24 * dramforever is now looking at your code...
19:50:31 * hackagebot language-thrift 0.1.0.1 - Parser for the Thrift IDL format.  http://hackage.haskell.org/package/language-thrift-0.1.0.1 (abhinav)
19:51:32 <sgronblo> hey, what would be a good way to do this? i would like to find an element of a list based on a predicate and if it exists i would just update one attribute in it, otherwise i would like to add a new element
19:51:49 <dramforever> YellowOnion: I guess it's because crack has type [Int] -> [[Int]]
19:52:31 <dramforever> sgronblo: what problem are you having when trying to do that?
19:53:36 <YellowOnion> dramforever, oh I got putStrLn somewhere making CipherTextA a String and not an Int I think
19:53:50 <dramforever> yep
19:53:54 <dramforever> :t print
19:53:55 <lambdabot> Show a => a -> IO ()
19:54:00 <dramforever> ^ is what you need, I guess
19:54:09 <sgronblo> dramforever: just figuring out if there is some simple way to do it that doesnt occur to me. btw im actually doing it in JS.
19:55:13 <dramforever> sgronblo: isn't your description simple enough? :)
19:56:10 <nolraiU> Man apt-get is only geting 500kb/s.
19:56:23 <nolraiU> Installing leksah has been crazy hard..
19:56:55 <dramforever> kb = 1024 bytes?
19:57:21 <dramforever> I guess you need a mirror
19:57:22 <nolraiU> I think 1024 bits..maybe 1000 bits.
19:57:32 <nolraiU> Doesn't really matter.
19:57:39 <dramforever> nolraiU: oh, then you still need a mirror
19:57:47 <nolraiU> Going to take 16 minutes to download.
19:58:02 <nolraiU> Hmm.
19:58:26 <sgronblo> by a kind of: e = l.find(p); if (e) { update(e); return l; } else { return l.concat(createNew()) }
19:58:27 <nolraiU> This is really a linux question, but how would I do so?
19:59:11 <dramforever> nolraiU: you mean mirror?
19:59:14 <YellowOnion> dramforever, Got it, takes 270ms to crack :)
19:59:24 <dramforever> :)
19:59:29 <dramforever> good for you
20:00:09 <nolraiU> dramforever: yep.
20:00:36 <dramforever> nolraiU: dunno, google it maybe
20:00:54 <dramforever> google for "ubuntu apt mirror" maybe
20:01:07 <dramforever> ouch...
20:01:16 * dramforever shouldn't have assumed ubuntu
20:01:44 <nolraiU> You were right though.
20:05:32 * hackagebot yesod-auth-account-fork 2.0 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-fork-2.0 (FelipeLessa)
20:10:05 <sgronblo> dramforever: yeah i guess the description is quite simple but my solution involves many steps i was wondering if there was some functional pattern for this that i had forgotten
20:11:00 <dramforever> sgronblo: dunno
20:23:21 <nolraiU> What does the cabal error message of "setup: The pkg-config package 'gtk+-3.0' is required but it could not be
20:23:21 <nolraiU> found."
20:23:26 <nolraiU> mean?
20:23:51 <nocturne777> I have been looking at some opensource haskell projects(snap, aeson) to improve my understanding. in some codebases, some of the fields in data structures are strictly evaluated like here: http://hackage.haskell.org/package/snap-core-0.9.7.0/docs/src/Snap-Internal-Http-Types.html#Response
20:24:59 <dedgrant> nolraiU: It means that pkg-config can not find a build description for gtk+-3.0 on the PKG_CONFIG_PATH. Are you trying to build on Windows perchance?
20:25:45 <nocturne777> how do we decide what fields should be evaluated strictly and what fields shouldn't ?
20:26:24 <hamishmack> nolraiU: https://github.com/leksah/leksah#building-on-linux
20:26:28 <dramforever> nocturne777: to me, I will add that bang if the value is small
20:26:44 <nolraiU> dedgrant: nope, ubuntu.
20:26:46 <hamishmack> nolraiU: Did you sudo apt-get install libgtksourceview-3.0-dev libwebkitgtk-3.0-dev ?
20:27:20 <nolraiU> At this point this is more stubborness then anything else. I just want to install leksah.
20:27:43 <dedgrant> nolraiU: pkg-config works by searching for <packagename>.pc files in all of the directories given in the environment var PKG_CONFIG_PATH. There's apparently no gtk+-3.0.pc file on the path. The pc files tell the (usually C/C++) compiler where to find things like .lib files, header files and such to build with.
20:28:08 <nolraiU> Hmm.
20:28:13 <dramforever> nocturne777: for example, look at that you could see that Headers, Map ByteString Cookie and ResponseBody are rather big
20:28:15 <nocturne777> dramforever: I also wonder if the library developers do some thinking as to which fields would be evaluated most of the time and whatnot
20:28:28 <dramforever> yep that counts too
20:28:39 <dramforever> (at least in my opinion)
20:29:28 <dramforever> If you add to many !'s you can actually get worse performance
20:29:40 <nolraiU> hamishmack: they don't seem to exist..
20:30:17 <dramforever> s/to/too
20:30:32 <nolraiU> Hamishmack: as in apt-get cant find them.
20:31:04 <dedgrant> nolraiU: sudo apt-get install libgtk-3-dev?
20:31:06 <nocturne777> dramforever: so in the example we are looking at, the author's thinking problaly is that he wants less thunks per request?
20:31:23 <nocturne777> fewer thunks*
20:31:33 <dramforever> I guess so
20:33:06 <nolraiU> dedgrant: it has unmet dependencies.
20:33:14 <nolraiU> ...what did I do to my system.
20:33:48 <dedgrant> nolraiU: gtk is a complicated beast
20:34:13 <nolraiU> Apparently.
20:34:23 <dedgrant> nolraiU: What is the specific error?
20:34:40 <nolraiU> The following packages have unmet dependencies:
20:34:40 <nolraiU>  libgtk-3-dev : Depends: libatk-bridge2.0-dev but it is not installable
20:34:41 <nolraiU>                 Depends: libwayland-dev (>= 1.2.0) but it is not installable
20:34:41 <nolraiU>                 Depends: libxkbcommon-dev but it is not installable
20:35:36 <nolraiU> Thanks, btw.
20:37:42 * dramforever was trying to add good diagonstics to a DSL I'm making, and ended up spilling SourcePos everywhere in my AST
20:39:24 <nolraiU> dedgrant: Time to give up and use vim?
20:39:30 <sccrstud92_> guys i need some help finding a function. the name is something like nTimes, and I thought it was in Data.Monoid. it allows to efficiently construct a monoidal value by <>ing it with itself n times. I cannot find it however. does anyone know what I'm talking about?
20:41:10 <unb3k44n7> Evening.
20:43:01 <sccrstud92_> someone had to have seen it. i feel like jodi foster in flightplan
20:43:17 <c_wraith> sccrstud92: it can't be any more efficient than \n x -> mconcat (replicate n x)
20:43:40 <sccrstud92_> c_wraith: why not?
20:43:53 <c_wraith> Oh, I guess it can, thanks to associativity.
20:43:57 <dramforever> c_wraith: like repeated squaring?
20:44:01 <sccrstud92_> c_wraith: yeah
20:44:05 <sccrstud92_> yes like that
20:44:10 <c_wraith> yeah, it can do the equivalent of repeated squaring.
20:44:48 <sccrstud92_> ah im dumb
20:44:54 <sccrstud92_> its in semigroup
20:45:00 <sccrstud92_> should have checked there right away
20:49:38 <_soapy_> wat
20:49:55 <wat> ?
20:50:23 <_soapy_> lmfao
20:50:29 <_soapy_> wat is an actual person
20:50:32 <_soapy_> nvm dude
20:50:41 <wat> haha, no worries. i ought to change my nick actually
20:50:49 <wat> it's registered to somebody else
20:50:49 <_soapy_> change it to 
20:50:56 <_soapy_> beefcurtains
20:51:28 <_soapy_> lol
20:51:31 <monoid> see how soon i get highlighted
21:00:35 * hackagebot yi-solarized 0.1.0 - Monokai colour theme for the Yi text editor  http://hackage.haskell.org/package/yi-solarized-0.1.0 (Norfair)
21:04:58 <nocturne777> dramforever: do you think {-# UNPACK #-} is necessary most of the time ?
21:05:08 <nocturne777> unnecessary*
21:05:20 <dramforever> nocturne777: dunno, but I think it
21:05:31 <dramforever> I think it's unnecessary
21:05:35 * hackagebot yi-solarized 0.1.1 - Solarized colour theme for the Yi text editor  http://hackage.haskell.org/package/yi-solarized-0.1.1 (Norfair)
21:05:57 <nocturne777> what this pragma does it get rid of the pointer indirection
21:06:46 <dramforever> nocturne777: IIRC GHC automagically does this if you have a ! in a field and the field is small
21:06:55 <dramforever> like Int
21:07:32 <echo-area> What theory answers question like why we can't define a class as in `class C f1 a f2 b where f :: f1 a -> f2 b`?
21:08:35 <nocturne777> dramforever: from what I understand GHC does not do this automatically, it needs to be specified I think
21:08:49 <dramforever> dunno...dunno
21:08:59 <dramforever> I'm not reaally familiar with that
21:09:51 <dramforever> echo-area: We can't
21:09:53 <dramforever> ??
21:10:19 <dramforever> @let class BlahBlah f a g b where blahBlah :: f a -> g b
21:10:21 <lambdabot>  Defined.
21:10:28 <dramforever> echo-area: what's the problem??
21:11:26 <echo-area> Why do I get `Too many parameters for class ‘C’`?
21:12:01 <Fuuzetsu> dmj`: pong
21:12:08 <dramforever> echo-area: you need an extension
21:12:15 <dramforever> do you know what's an extension?
21:12:32 <dramforever> GHC says "Use MultiParamTypeClasses to allow multi-parameter classes"
21:13:10 <dramforever> so you add {-# LANGUAGE MultiParamTypeClasses #-} to the top of your file
21:13:29 <dramforever> echo-area: the theory is: It's not in Haskell98
21:13:55 <echo-area> dramforever: It must appear at the top, and it cannot be used in runghc?
21:14:35 <dramforever> echo-area: must be on top, but tunghc is okay
21:14:38 <dramforever> *runghc
21:18:18 <echo-area> dramforever: So it was my fault not to put it at the top.  Thank you!
21:25:29 <DrPavelheer> just discovered the Tardis
21:25:32 <DrPavelheer> this is ridiculous
21:26:08 <bitemyapp> DrPavelheer: -ly awesome
21:26:32 <DrPavelheer> http://puu.sh/i9ghn/901c18fa06.png
21:26:36 <DrPavelheer> i can't even believe that works
21:31:33 <bitemyapp> DrPavelheer: what text editor is that?
21:31:58 <dramforever> bitemyapp: looks like vim
21:32:52 <dramforever> bitemyapp: look at the blue "~" 
21:33:37 <bitemyapp> dramforever: oh right, thank you.
21:33:41 <bitemyapp> the font was throwing me off
21:43:56 <nocturne777> I see that some people in the community prefix their data fiels with "_"?
21:44:29 <nocturne777> what is the connotation of this convention?
21:44:50 <nocturne777> that these fields should not be accessed externally?
21:44:58 <joneshf-laptop> it's for lens
21:45:23 <joneshf-laptop> template haskell will generate the necessary functions if they're prefixed with `_`
21:47:27 <nocturne777> I see
21:53:45 <YellowOnion> So I'm working with stateT to crack xor passwords, currently everything is done in one big EvalStateT, can I chain these using various conditions instead?
22:07:12 <kirill`> Is it somehow possible to overload "*" so that Complex * Real is separate Complex * Complex, so that it can perform fewer multiplications?
22:08:17 <Azel> :t (*)
22:08:19 <lambdabot> Num a => a -> a -> a
22:09:13 <kirill`> I'd like something like
22:09:13 <kirill`> (*) :: Arithmetic a b c => a -> b -> c
22:09:13 <joneshf-laptop> kirill`, The types won't line up, but you can always define your own operator to do that
22:10:31 <Azel> kirill`: Nope. As you can see, (*)'s type requires that both of its arguments be the same type (as well as its result). You could however either do as joneshf-laptop suggested or create your own type with one constructor taking a Complex and another taking a Real and whose (*) operator perform fewer multiplications.
22:11:09 <joneshf-laptop> yeah, that's another thing you could do
22:11:22 <joneshf-laptop> wrap them together in another type
22:11:33 <joneshf-laptop> then use the `Num` class
22:12:05 <kirill`> The main issue for me is that if I have N different types, I need O(N^2) different operators
22:12:25 <joneshf-laptop> what problem are you trying to solve?
22:12:28 <kirill`> joneshf-laptop: Wouldn't that be much slower with all the unboxed values?
22:12:47 <joneshf-laptop> kirill`, is speed a major factor?
22:13:24 <kirill`> joneshf-laptop: Yes, I need to stay within a small factor of C++
22:14:01 <YellowOnion> kirill`, you only need one opterator, just can't use (*)
22:14:15 <joneshf-laptop> ^
22:15:32 <kirill`> So just define some new typeclass, and declare an instance for all combinations? I have a few of these types: Float, Double, quadruple float, and their complex equivalents, plus short (<=4) vectors of each of those
22:16:23 <eds> how do I avoid parse error while writing where statements? or let in statements?
22:16:45 <joneshf-laptop> kirill`, i dunno what kind of overhead typeclasses add, but be aware of that
22:16:45 <JFare> eds: check your indentation
22:17:02 <joneshf-laptop> kirill`, why not just leave those bits in C, and call out to them from haskell?
22:17:20 <eds> I did. can you take a look at it?
22:17:27 <joneshf-laptop> kirill`, or wait for someone who knows more about performance issues ;)
22:17:40 <JFare> eds: sure
22:18:10 <eds> http://lpaste.net/133754
22:20:11 <kirill`> eds: Missing "=" after i, and params is not aligned with g
22:20:33 <JFare> eds: No need to nest where statements, you can define values used in other parts of the where too
22:21:19 <eds> ohh. I have not defined them before. 
22:21:28 <eds> I corrected. Still parse error on where
22:21:29 <eds> http://lpaste.net/133754
22:21:45 <eds> Does let need in to complete the statement?
22:22:30 <JFare> eds: For the corrected code you need to indent the "where" to after the "="
22:22:47 <JFare> eds: Yes if it is not in a do block
22:23:56 <eds> oh got it. that worked. thanks. Will not use tab now onwards, learned.
22:24:20 <eds> ahh. That is what I saw somewhere and could not understand because I was just using let and getting an error.
22:24:52 <Hijiri> is there somewhere with bayhac transit info?
22:46:36 <shield00> Does anyone know why does this code doesn't work as it should? http://lpaste.net/3274248964982964224. If I click the X on the display window, it closes and the program ends. If I hit ESC, the display window closes and "Segmentation fault" gets printed on the terminal, and nothing else.
22:55:41 * hackagebot feed 0.3.9.7 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  http://hackage.haskell.org/package/feed-0.3.9.7 (AdamBergmark)
22:55:52 <kadoban> Sigh. Is it me or is the hardest part about ST figuring out how to actually write the types :-/
22:57:12 <liste> would typed holes help?
22:57:38 <kadoban> I somehow doubt it … I'll make a paste, maybe someone can give me a hint, heh.
23:00:39 <kadoban> Nooo, lpaste. Why have you forsaken me.
23:02:19 <chreekat> Hijiri: where are you coming from?
23:03:16 <kadoban> https://gist.github.com/kadoban/98825fe667ff8d308373 Any help? I … think what I'm trying to do makes sense, but I have no godly idea how to specify the types. And if I don't specify the types, it's just plain too polymorphic to mean anything, as far as I can tell. (ST, STUArray related, probably very basic).  That's with RankNTypes on, which I pretty much just guessed at because otherwise line 1 was impossible
23:05:18 <heatsink> kadoban: The state variable 's' governs the state of the arrays that are created
23:05:56 <heatsink> That's the variable 's' in the type of initSt
23:07:12 <kadoban> heatsink: I think I understand why the types I've written don't make sense, but … I just don't know how to fix it. Or is it just some impossible thing for some reason I don't understand? (Or maybe it's not clear what I'm even trying to do?)
23:07:28 <heatsink> Your type synonym makes a polymorphic type that can be governed by any state type
23:07:59 <heatsink> For your function to produce a useful result, the return type needs to be parameterized by a state type
23:08:31 <heatsink> So you can run the function at a particular state type 's', and return result values instantiated to the same state type 's'
23:08:48 <MitchellSalad> kadoban: use "type AtkArr s = STUArray s Int Int"
23:08:57 <MitchellSalad> initSt :: St s (AtkArr s)
23:09:29 <heatsink> If you declare data St s = St (STUArray s Int Int) (STUArray s Int Int)
23:10:06 <heatsink> Then you can define initSt :: ST s (St s) 
23:10:21 <kadoban> Ohhhh
23:10:26 <heatsink> Note the same parameter 's' to the ST monad and the St return value
23:10:47 <kadoban> Oh crap, okay, that totally makes sense … let me try that.
23:12:12 <kadoban> Nice, that totally works. Thanks very much.
23:15:42 * hackagebot extensible 0.3.5 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.3.5 (FumiakiKinoshita)
23:25:42 * hackagebot objective 1.0.5 - Composable objects  http://hackage.haskell.org/package/objective-1.0.5 (FumiakiKinoshita)
23:30:18 <Sprog> Is it possible to have a datatype take a function?
23:30:19 <Sprog> i.e.
23:30:33 <Sprog> data thing = thing { t :: String -> String -> Int }
23:30:45 <Sprog> I cant seem to make it work
23:31:02 <dramforever> Sprog: it works
23:31:07 <kadoban> Sprog: Sure (capitalize Thing and Thing though).
23:32:14 <Sprog> Its weird, I have a type that is (basically) data Thing = Thing { func :: String -> String -> IO(String), test :: Int }
23:32:41 <Sprog> if I try to return a configured Thing I get "Cannot match type ... with 'String -> IO(String)'"
23:33:40 <Sprog> I guess the question is
23:33:53 <Sprog> if i want to store a partially applied function in a datatype, how would I do it?
23:34:01 <dramforever> how long have you been learning haskell?
23:34:08 <Sprog> 2 weeks
23:34:12 <dramforever> Sprog: just do it, to answer your question
23:34:25 <Sprog> k
23:34:29 <dramforever> it seems that you haven't been used to haskell style code
23:34:50 <dramforever> IO(String) is not idiomatic, we normally write IO String
23:35:19 <kadoban> Sprog: You seem to … pretty much know how. Are you getting a specific error that you can share? You probably just have a small mistake?
23:35:58 <dramforever> Sprog: can you post your full code?
23:40:50 <Flonk> I love how the haskell wiki has a haiku at the end of the article about monad laws. :D
23:49:59 <fumieval> Flonk: that has too many morae for Haiku though =p
23:51:35 <Flonk> fumieval: it's 5-7-5 isn't it?
23:51:54 <Flonk> Although to be honest I don't know the difference between a mora and a syllable
23:53:53 <fumieval> "Kleisli composition forms" sounds rather long for me(Japanese)
23:55:44 * hackagebot configuration-tools 0.2.13 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.13 (larsk)
23:58:22 <fumieval> when it is split by Japanese /on/, it'll be Mo-na-d-a-xi-o-m-s K-le-i-s-li-com-po-si-tio-n-fo-r-m-s a-ca-te-go-ry
23:59:28 <Flonk> oh wow
