00:31:02 <zipper> Hey, how do I check whether an IO action has actually done what I want e.g if an IO [FilePath] gave an empty list?
00:31:28 <ski> check the resulting value ?
00:32:34 <zipper> I want to check with a case for example.
00:32:51 <zipper> I was hoping there was a way like one can check for an either or a maybe
00:33:32 <ski> do you mean, when using the `either' and `maybe' functions ?
00:33:36 <ski> @type either
00:33:37 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
00:33:37 <ski> @type maybe
00:33:38 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:33:58 <ski> with a `case', it should be straight-forward
00:34:03 <kadoban> blah >>= \a -> case a of [] -> Stuff\n_ -> Other Stuff ?
00:34:38 <woboats> Hello, I am working on an RFC for Rust & doing some investigating about a proposed feature. Can Haskell type classes be declared mutually exclusive of one another (i.e. no type can be an instance of both classes)?
00:35:54 <ski> woboats : no. it's purely OWA
00:35:59 <kadoban> woboats: Not directly I don't think in vanilla haskell. I don't know of anything in extensions either.
00:36:09 <lamefun> is there a package to parse Cabal configuration format?
00:36:46 <liste> lamefun Cabal?
00:36:53 <woboats> ski / kadoban : Do you know of any discussions about what the implications of that would be?
00:37:23 <kadoban> woboats: Not personally. To me it doesn't sound like a particularly interesting thing to do, but maybe there's some cool reason you'd want to do that I'm not thinking of.
00:38:10 <frerich> zipper: If you want something like 'either' or 'maybe', you might like 'bool'.
00:38:47 <ski> woboats : third party extensibility. what if one party adds that restriction, while another adds a violation to it, and then a third one tries to use packages from these two sources together ?
00:38:48 <woboats> kadoban, I know very little Haskell, but in Rust it would allow (and sorry, I'm trying to use Haskell terms but I may not be precisely correct) multiple parametric instances of a third class for two classes whose members are disjoint sets.
00:39:21 <liste> lamefun http://hackage.haskell.org/package/Cabal-1.22.3.0/docs/Distribution-PackageDescription-Parse.html
00:39:37 <woboats> ski, that does not sound like something that would be possible under the proposal in Rust.
00:40:07 <liste> lamefun or you mean cabal.config file?
00:40:20 <lamefun> thx
00:41:02 <woboats> ski, Rust has orphan rules about where types can be declared instances of classes that I don't think Haskell has.
00:41:51 <ski> woboats : amounting to ?
00:42:25 <lamefun> oh, it's part of cabal... I thought it's some kind of a common data format
00:43:27 <woboats> ski, well a type can't be declared an instance of a typeclass except in the scope in which one of them is defined.
00:43:57 <woboats> You couldn't add a mutual exclusion restriction to a class except where the class is defined.
00:47:19 <lamefun> is there a way to create bounded number types (for example, Float from 0.0 to 1.0 for color components)?
00:47:56 <ski> woboats : ok. so then i guess the question is whether you want to leave open the possibility of lifting this restriction (even to some small extent) in the future
00:49:02 <liste> lamefun there's http://hackage.haskell.org/package/refined or you could roll your own
00:49:53 <liste> eg. newtype RefinedFloat = RefinedFloat Float and mkRefinedFloat :: Float -> Maybe RefinedFloat
00:51:28 <lamefun> it's from 2015 :O?
00:51:50 <woboats> ski, that seems really unlikely. Does Haskell not allow typeclasses to be bounded by other typeclasses? (e.g. every instance of Foo must be an instance of Bar) Rust already allows positive bounds of that sort (just not negative ones) and bounding a third-party class cannot be possible for the reason you mentioned.
00:53:54 <kadoban> woboats: Yes you can do that in haskell. For example, every Applicative must be a Functor. You can also do the other way, using the fact that something is a Blah, you can automatically make it an instance of Foo.
00:53:54 <ski> woboats : "Does Haskell not allow typeclasses to be bounded by other typeclasses?" -- it allows that kind of thing, yes (called superclasses)
00:54:30 <ski> woboats : OWA is all about having only positive information, no negative information (to ensure monotonicity)
00:55:01 <hnfmr> I am trying to follow the paper "Monad Transformers Step by Step" by Martin Grabmuller
00:55:12 <hnfmr> type Eval1 a = Identity a
00:55:18 <hnfmr> how can i use IdentityT instead here?
00:55:28 <ski> (or, at least, to enable also negative information, one would probably need some kind of stratification. .. not sure how it would apply in a context of type classes)
00:56:16 <woboats> ski, I'm not sure what you mean by monotonicity, but I think that this proposal solves this problem by having the type to class relation be undefined by default. (A negative relation can be explicitly stated or inferred from other classes).
00:57:07 <woboats> kadoban, and the issue of overlapping instances is handled with specialization, right?
00:57:44 <woboats> (in re "you can define every instance of Blah as an instance of Foo")
00:57:46 <ski> woboats : monotonicity meaning that information can never decrease. only increase or stay the same. in this case, applying to information about what types are in which type classes
00:57:50 <kadoban> The issue of overlapping instances is handled with … "don't do that". (I think there's some other way, but that's the only solution I personally know)
00:59:09 <ski> i think it's commonly agreed that `OverlappingInstances' is usually (always ?) a Bad Idea
00:59:42 <kadoban> There's some extension that lets you have overlapping instances … I don't really know how it works. Probably has some rule(s) to decide which to use? Maybe just picks randomly? :-/ Dunno.
00:59:48 <lamefun> so Rust has been released and Haskell will soon graduate from being a toy: http://www.well-typed.com/blog/2015/04/improving-hackage-security/ - sane programming is coming to us!
00:59:58 <woboats> ski, by information can only increase, you mean with the addition of new code to the system?
01:00:19 <ski> woboats : monotonicity plus no-negative-information is a simple way to ensure there'll be no contradictions (which would need to get resolved by messy, ad hoc, rules) down the line
01:00:26 <ski> woboats : yep
01:01:28 <woboats> ski, yeah, so that's handled in this proposal by making a negative relation an explicit declaration, rather than the absence of a declaration (that was the problem that halted a prior proposal without that aspect).
01:01:52 <woboats> Or else an inferred declaration via the instantiation of another class which would be mutually exclusive.
01:02:57 <woboats> We're also considering specialization along the lines of OverlappingInstances, which would be a more complicated addition. Haskell community has found that unfavorable?
01:06:07 <kadoban> lamefun: "soon"? Is there more progress or just that? That just sounds like a kind of very high level plan that hasn't been implemented yet.
01:08:07 <lamefun> kadoban, https://www.fpcomplete.com/blog/2015/05/secure-package-distribution
01:08:59 <kadoban> lamefun: That's totally different, but yes a good step at least.
01:09:33 <lamefun> https://github.com/haskell/cabal/issues/936#event-288428810 - that has also been acknowledged
01:11:05 <ski> woboats : well, obviously(?) it would need to be explicit. however, it again enables getting to a contradiction, if not controlled in some other way
01:11:36 <woboats> ski, what is the contradiction?
01:11:58 <ski> woboats : it's just the third party problem i mentioned above
01:12:00 <woboats> ski, how does Haskell allow a class to be bound by another class external to that class's definition?
01:12:20 <ski> not quite sure what you mean by "bound" here
01:12:45 <woboats> ski 'all types of class Foo must instantiate Bar"
01:13:53 <ski> a declaration `class Eq a => Ord a where compare :: a -> a -> Ordering; ...' specifies that for every instance `Ord T', for any type `T', there must also be an instance `Eq T'
01:14:48 <lpaste> lamefun pasted “Is this a sane way to handle errors?” at http://lpaste.net/133860
01:15:24 <woboats> ski, and what happens if Ord is defined in library A, that relation specified in library B, library C creates a type which is an instance of Ord and not Eq, and a client depends on both B and C?
01:15:33 <woboats> (this is the same contradiction)
01:15:40 <liste> lamefun no, use Either
01:16:37 <liste> or Maybe
01:17:12 <liste> that one will blow up the whole program if the one calling the function isn't careful
01:17:25 <lamefun> I thought about it but I don't like the idea much...
01:17:27 <ski> woboats : it's not a contradiction, only an incompleteness. if it were possible to do that, then you ought to get the same error message to the effect that you also need to add an `Eq' instance for that type, when you combine `B' and `C' together
01:17:43 <liste> lamefun why not?
01:18:38 <lamefun> ie. I'll have to write useless error handling code everywhere I use mkColor even if I know that the numbers will never be invalid...
01:18:53 <ski> woboats : however, in actual Haskell, that relation goes with the declaration of the `Ord', so it can't be separated (you may compare with allowing an instance only in a scope where the type (or one of them, in case of multi-parameter type classes) or the class is defined)
01:19:44 <woboats> ski, well, the fact that the relation goes with the declaration of Ord is the same thing that keeps a negative declaration from falling into contradiction
01:19:48 <ski> woboats : a contradiction would one package saying that the type is an instance, and another package saying it definitely isn't, and you trying to use both packages together
01:19:57 <ski> s/would/would be/
01:20:20 <liste> lamefun do you? what if you someday take the numbers from direct user input and forget to validate them?
01:21:02 <woboats> ski, that would be prevented by Rust's orphan rules, which already exist
01:21:34 <ski> the implication from having an `Ord' instance to having an `Eq' instance isn't really "negative information". you can't get the same kind of effect with it (due to the fact that you can't express "false" as the consequence of the implication)
01:21:35 <woboats> ski: How does Haskell handle 'cousin' libraries, e.g. which both declare a type an instance of a trait? how does it know which to dispatch to?
01:22:09 <ski> woboats : by not allowing such two pieces of code to be linked together
01:22:36 <woboats> ski, Rust has instead opted to disallow that kind of declaration so that all libraries can be linked together.
01:23:57 <liste> lamefun there's a lot of useful combinators (like either, maybe and fromMaybe) and Monad instances that make error handling easier
01:24:06 * hackagebot gll 0.2.0.0 - GLL parser with simple combinator interface  http://hackage.haskell.org/package/gll-0.2.0.0 (ltvanbinsbergen)
01:24:08 * hackagebot bustle 0.5.0 - Draw sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.5.0 (WillThompson)
01:24:21 <mike689> heyoo, anyone there?
01:24:40 <ski> mike689 : yes
01:24:59 <ski> ("that would be prevented by Rust's orphan rules, which already exist" (re the contradiction-through-negation elaboration, as opposed to what implication gets you) -- yes. i'm admitting that such orphan rules could be a reasonable way of handling the issue. i'm just pointing out that you need to think about what future possibilities you'd be willing to give up (without later breaking backwards compatibility))
01:25:08 <ski> woboats : *nod*
01:25:32 <mike689> Looking for someone experienced in network security
01:25:34 <ski> mike689 : do you have a (Haskell-related) question ?
01:25:45 <mike689> Not exactly
01:25:46 <lamefun> liste, I'll of course have a safe variant for such cases: http://lpaste.net/4874823795476529152
01:25:53 <woboats> ski: True. Rust is pretty committed to the orphan rule, though, and the alternative seems to be to do the same thing Haskell does with conflicting impls: disallow linkage of those two libraries.
01:26:07 <woboats> sorry, instances, not impls.
01:26:16 <woboats> my Rust slipping through
01:26:29 <liste> lamefun then it's OK (:
01:27:08 <ski> mike689 : perhaps you'd have more luck on ##security ?
01:27:32 <mike689> yeah, It said I needed an invite for it :-/
01:30:13 <ski> lamefun : liste's `Maybe' solution is nicer than using `error', at least if you're constructing colors from inputs you don't know are correct (e.g. from program input). if you prefer, you could use `Either' to get either a description of an input error (or an exhaustive set of all of them), or a color
01:30:55 <ski> mike689 : hm, i just needed to join. perhaps you need to identify to the network first ?
01:31:11 <ski> (and register, if you're not registered)
01:32:44 <merijn> lamefun: What's the reason for having an unsafe way to construct colours? Writing constants? Because if so I have a neat trick for you :p
01:33:13 <lamefun> merijn, constants, yes.
01:33:29 <merijn> lamefun: With some typed TH abuse you can do cool things like: https://ghc.haskell.org/trac/ghc/wiki/ValidateMonoLiterals
01:33:47 <merijn> lamefun: That extension idea is a work in progress, but the example TH works
01:33:57 <merijn> The writeup is more on how to automate it
01:38:27 <lamefun> That's like code generation, but from within the language itself?
01:39:28 <unb3k44n7> What are these Orphan Rules?
01:39:37 <merijn> lamefun: Template Haskell lets you run haskell at compile time to produe code to include in the actual compilation, yes
01:40:03 <merijn> unb3k44n7: To not be an orphan an instance must either 1) be in the same module as the datatype or 2) in the same module as the class
01:40:10 <mike689> ski : thanks got it
01:40:21 <tdammers> lamefun: think something like CPP, but instead of generating raw source code, you generate syntax trees
01:40:41 <unb3k44n7> It's used with both C++ and Haskell?
01:40:43 <merijn> tdammers: Also, you get to use an actual language (haskell) instead of braindead string nonsense
01:40:45 <tdammers> and the generator itself is written in Haskell instead of some limited preprocessor macro language
01:40:56 <Myrl-chan> merijn: LOL
01:41:21 <tdammers> unb3k44n7: CPP as in "C PreProcessor". Not "C Plus Plus"
01:42:58 <unb3k44n7> I mean, are the Orphan Rules used with C languages and Haskell
01:43:04 <xj54y> okay guys, finally making progress. Here's my output from cabal install lambdabot http://paste.debian.net/199940/
01:44:21 <merijn> unb3k44n7: I don't understand the question
01:44:56 <unb3k44n7> I'm just wondering what you use them with
01:45:20 <unb3k44n7> What do they apply to, rather,
01:45:43 <lamefun> Can Haskell use itself as a scripting language (for example for an image editor to run untrusted filter plug-ins with them getting the access only to the image data itself, so that they eg. can't ruin the image, delete undo history and the file)?
01:45:53 <Myrl-chan> lamefun: Yes.
01:46:01 <voidzero> sure, #!/usr/bin/runhaskell
01:46:03 <Myrl-chan> lamefun: Want an example?
01:46:12 <merijn> voidzero: That's the opposite of what he asked for
01:46:17 <voidzero> oh :D
01:46:17 <merijn> lamefun: Check out SafeHaskell
01:46:21 <lamefun> God.
01:46:26 <voidzero> busted
01:46:29 <lamefun> Is this a language from heaven?
01:46:38 <merijn> lamefun: No, from aliens
01:46:43 <voidzero> bearded ones
01:46:45 <ttt_fff> SUP haskellers? I'm installing ubuntu . Does 14.04 or 15.04 work better for latest ahskell ?
01:46:52 <unb3k44n7> Ok. Nevermind then, I guess.
01:46:56 <Myrl-chan> lamefun: http://myrl.is-into.science
01:46:59 <liste> lamefun that means that a Haskell compiler/interpreter is bundled with your software, though
01:47:22 <liste> as a library
01:47:43 <Myrl-chan> lamefun: This is kinda what you're asking for.
01:47:47 <liste> check out http://hackage.haskell.org/package/hint also
01:48:01 <liste> and http://hackage.haskell.org/package/mueval
01:48:43 <voidzero> unb3k44n7, i haven't the slightest idea, sorry. If you want a less volatile place to ask your question, use the reddit, and I think that new reddit-like place also has a haskell subwossname
01:48:51 <voidzero> i keep forgetting
01:49:06 <merijn> liste: Not necessarily
01:49:30 <Myrl-chan> I have no idea how hint works.
01:49:32 <unb3k44n7> I Google searched Rust's Orphan Rules a while ago, since I never heard of it, and was curious as to what it was. 
01:49:33 <Myrl-chan> :D
01:49:36 <liste> merijn you're right, the plugins can be pre-compiled
01:49:44 <woboats> unb3k44n7, orphan rules are a Rust thing, I don't think any other language has them.
01:49:53 <merijn> woboats: Eh, haskell?
01:50:03 <Myrl-chan> What are orphan rules?
01:50:04 <unb3k44n7> So Rust is it's own language?
01:50:05 <merijn> unb3k44n7: The idea is that typeclass instances must be globally unique
01:50:19 <tdammers> orphan rules ~== orphan instances?
01:50:24 <merijn> unb3k44n7: So how do you guarantee no two people manage to define the same instance?
01:50:31 <woboats> merijn, no, orphan rules are a different way of making typeclass instances globally unique from the way that Haskell does it.
01:50:38 <merijn> Oh
01:50:39 <voidzero> I meant https://voat.co/v/haskell/ btw
01:50:44 <voidzero> dunno if it is worth a place in the /topic
01:51:18 <woboats> unb3k44n7, yes, Rust is another language with a feature similar to Haskell's typeclasses; I joined the channel to ask about how typeclasses work in reference to a proposed extension of this Rust feature.
01:51:37 <merijn> woboats: They look similar to orphan instances
01:51:46 <unb3k44n7> OK. So It's a concept for a different language. Gotcha. Thanks.
01:51:48 <merijn> woboats: It's just that rust traits make the rules more complex
01:52:10 <woboats> merijn, I don't know Haskell well, are orphan instances instances where both type and typeclass are third party?
01:53:01 <merijn> woboats: Yes
01:53:23 <merijn> woboats: Basically, to not be an orphan the instance must be either 1) in the same module as the class or 2) in the same module as the type it's for
01:53:30 <woboats> merijn, Rust's "orphan rules" are that orphan instances are invalid declarations.
01:53:40 <merijn> woboats: I dunno the exact rules for multiparameter classes
01:53:42 <woboats> They're more complicated because of multidispatch, but that's basically it.
01:54:08 <merijn> woboats: Well, haskell with multiparamtypeclasses is multidispatch too, but I'm unsure how orphan instances for them are detected
01:54:08 <unb3k44n7> Lol. I think people look too deep into my questions and make them more complex than necessary.
01:54:15 <woboats> Whereas Haskell solves the problem by not allowing libraries with conflicting orphan instances to be linked, Rust doesn't allow libraries with any orphan instances to be compiled.
01:54:32 <unb3k44n7> Seems to happen a lot in here. 
01:55:12 <woboats> Multidispatch makes detecting an orphan more complicated but probably the definition is almost identical, its the rules about them that are different.
01:55:31 <merijn> woboats: Actually, GHC can't always detect that and does sometimes link them
01:56:18 <woboats> merijn, :-\ that fact was probably a big motivation for the Rust team in not allowing them to be declared at all.
01:56:54 <merijn> woboats: Yeah, it's an annoying issue
01:57:16 <merijn> Orphans are generally a Bad Thing, but sometimes you can't get away with avoiding them without adding a new dependency, which is also annoying
01:57:54 <merijn> i.e. consider semigroups/bifunctor (before the latter moved into base), you can't add instances for those without adding dependencies which means anyone else wanting to use those is stuck using orphans
01:59:18 <woboats> merijn, Rust has handled that by having a build tool which downloads dependencies for you.
01:59:34 <woboats> like is more common among scripting languages
01:59:49 <f|`-`|f> C-cabal?
01:59:54 <merijn> woboats: cabal can download dependencies
02:00:06 <merijn> woboats: But haskell projects already have issues with large dependency footprints
02:00:24 <merijn> Picking up 10 more just to provide class instances is not an improvement
02:01:19 <woboats> I don't know anything about cabal (& I'm not trying to evangelize Rust at all!). But cargo downloads the entire graph of dependencies without requiring you to declare them all; adding dependencies is not usually seen as an annoyance at all.
02:01:51 <liste> how does cargo handle versioning?
02:01:53 <f|`-`|f> (It's probably a memory footprint)
02:02:02 <tdammers> woboats: cabal does that too, but it also checks version bounds, and having many dependencies and deep dependency graphs makes it more likely that the situation becomes unresolvable
02:02:21 <merijn> woboats: So does cabal, and it checks version bounds and tries to solve the version constraints
02:02:32 <woboats> each crate (library) declares the version it depends on, and is built against that version.
02:02:34 <tdammers> e.g., library A might depend on library C with a version constraint <1, and B might depend on C with version constraing >1
02:02:37 <merijn> woboats: But it turns out most people are terrible at accurate bounds and you end up with unsolvable constraints
02:02:38 <f|`-`|f> (Version bounds being min/max versions packages use)
02:03:00 <merijn> woboats: The bigger the dependency footprint the more likely two dependencies will have incompatible constraints and break things
02:03:04 <woboats> So your dependencies can depend on conflicting versions of the same library and it will be fine (I'm 90% sure of this).
02:03:17 <tdammers> there has been some experimental work done to allow multiple versions to be linked into the same project, which would solve the issue, but it introduces a whole bunch of new issues
02:03:32 <f|`-`|f> Like what? Overlapping Dispatch?
02:03:35 <merijn> woboats: GHC can only recently link the same library multiple times, but cabal can't deal with that yet
02:03:49 <dcoutts> woboats: turns out that the problem of finding a consistent solution is NP complete :-)  This is a challenge shared by all package managers. You can encode suduko in a debian package repo for example.
02:04:41 <f|`-`|f> Somehow this is going to end up with a solution that involves generalised globs
02:04:44 <f|`-`|f> And I just know it
02:05:14 <dcoutts> woboats: it's ok in principle to depend on two different versions of the same lib, but you need to know the use of those libs is encapsulated. If not, then you will get a type error. This would be true in rust too.
02:05:53 <f|`-`|f> (the hell is a multiparameter typeclass)
02:06:11 <merijn> f|`-`|f: A typeclass with more than one parameter?
02:06:12 <dcoutts> woboats: imagine in C for a moment that two libs used different libc versions, and then I try to pass something created in one lib over to the other... In C it will not be a type error but it will break horribly.
02:06:49 <woboats> dcoutts, right. I don't actually know the details of how Rust has handled it. It might be that if your dependencies depend on contradictory crates it just won't compile.
02:07:14 <dcoutts> woboats: right, and so the job of the solver is to find something that will compile. Or fail and explain why.
02:07:31 <dcoutts> woboats: and not to just come up with something that would fail at compile time
02:08:17 <woboats> dcoutts, yes, it does just fail if they contradict (otherwise it picks the highest version which matches all dependencies' requirements).
02:08:35 <woboats> I misspoke earlier when I said it didn't.
02:08:47 <dcoutts> woboats: in typed languages the problem is this: lib A and lib B both export functions that use a type defined in library C. If A and B use different versions of that library C, then in my app where I pass something from the function in lib A to lib B then I will get a type error.
02:09:02 <woboats> Right.
02:09:43 <bergmark> and even if there is no type error it may still introduce bugs
02:09:49 <dcoutts> woboats: if both A and B encapsulated their use of C then there's no problem, but in general packages do export functions that use types from other packages
02:10:14 <dcoutts> in which case it's vital to pick a consistent version of the package that defines that type
02:10:19 <woboats> Would a solution be to require a distinction in the declaration of 'public' or 'private' dependencies, 'private' dependencies being those whose types are not part of the public interface of my library?
02:10:27 <dcoutts> woboats: yes
02:10:41 <dcoutts> woboats: and to enforce that properly. It would allow more solutions.
02:11:12 <dcoutts> in the ghc/cabal world this design (not implemented) is called encapsulating dependencies
02:11:28 <dcoutts> since actually a package can encapsulate a lib it depends on only indirectly
02:12:10 <dcoutts> woboats: but it's a controversial solution because many people (including distro maintainers) want to be able to pick just one version for everything
02:12:34 <woboats> dcoutts, oh, I can see how this would be NP complete
02:12:42 <dcoutts> and once you allow picking different versions for encapsulated deps, then in practice it'll become impossible to pick a single version
02:13:07 <dcoutts> and then distros will become unhappy
02:15:16 <ggVGc> acpi
02:15:19 <ggVGc> ehh, haha, sorry
02:20:18 <lamefun> May I ask a few more stupid beginner questions?
02:20:53 <liste> lamefun go ahead (:
02:20:59 <lpaste> lamefun pasted “Can this get even more compact?” at http://lpaste.net/133861
02:21:35 <lamefun> Probably not worth it, just curious whether there are some nice string functions I don't know about.
02:21:36 <merijn> lamefun: Note, there is an unwritten convention that the output of Show should produce valid haskell
02:21:45 <merijn> For pretty printing you should use a pretty printing library
02:22:08 <f|`-`|f> Hmmm
02:22:10 <lamefun> oh ok
02:22:34 <merijn> Or just "prettyPrint :: Colour -> String" :p
02:22:49 <merijn> There's a few more tricks, but they probably would be more work than just writing this out
02:23:35 <lamefun> is there a class for that?
02:24:08 <f|`-`|f> I'm curious, does Haskell have an example of a multi parameter typeclass
02:24:38 <ski> f|`-`|f : `MonadReader' e.g. ?
02:24:45 <f|`-`|f> ok
02:24:47 <breadmonster> Hey everyone.
02:24:53 <tdammers> most of the MonadSomething typeclasses are multi-param
02:24:55 <f|`-`|f> Oh yeah, probably lenses too
02:25:01 <merijn> Well, technically, haskell does not
02:25:08 <tdammers> lenses take the concept and run with it ;)
02:25:10 <merijn> GHC has multiparameter typeclasses :p
02:25:16 <liste> lamefun not in base, at least
02:25:27 <ski> (and Hugs)
02:25:39 <breadmonster> merijn: Hi.
02:25:39 <merijn> I guess UHC too
02:25:42 <f|`-`|f> yeah, I think lenses is more or less a list when it comes to parameters
02:25:51 <f|`-`|f> What about Ibm's LHC?
02:25:58 <breadmonster> I wonder how lenses are implemented internally.
02:26:11 <breadmonster> Something about a getter and a setter, but I don't quite get the logic.
02:26:12 <f|`-`|f> (I'm cuirous how you don't have multiple instances of the same field)
02:26:14 <tdammers> breadmonster: it's no secret, you can just read the code
02:26:29 <f|`-`|f> (or is that an issue)
02:26:31 <tdammers> I'm pretty sure ekmett has written a bunch of papers on them too
02:26:32 <breadmonster> tdammers: you need a certain amount of category theory know how to read the code :P
02:26:42 <tdammers> point in case
02:26:52 <ski> @where lenses
02:26:52 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-
02:26:52 <lambdabot> structure-access-and-mutation>
02:26:58 <breadmonster> lol
02:26:59 <ski> might be good starting material
02:27:06 <f|`-`|f> I wish my mouse batteries would charge faster
02:27:45 <ski> (note that most of that is not specifically about edwardk's lenses, but rather the "functional references" idea which started the former off)
02:27:50 <merijn> breadmonster: No you don't, there's a good talk by edward on lenses
02:27:53 <merijn> @where lens
02:27:53 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
02:27:59 <merijn> The youtube link there
02:28:48 <f|`-`|f> all I know is that prisms are duals to lenses, and optics are a trick where you replace a class constraint with a function
02:29:01 <f|`-`|f> eg Eq => with (a -> Bool)
02:29:18 <f|`-`|f> like in Witherable
02:30:14 <thebnq> Witherable?
02:30:35 <f|`-`|f> New Typeclass, think generalised filter
02:31:04 <f|`-`|f> much like Traversable and fmap
02:31:10 <f|`-`|f> and Foldable with fold
02:31:22 <thebnq> oh, interesting
02:31:31 <thebnq> i don't like writing catMaybe
02:32:19 <f|`-`|f> enjoy looking it up, then, I can't use my mouse
02:33:30 <liste> @src catMaybes
02:33:31 <lambdabot> catMaybes ls = [x | Just x <- ls]
02:33:54 <xj54y> My output from cabal install lambdabot http://paste.debian.net/199940/ ; Any assistance would force me to share my gratitude. 
02:34:20 <f|`-`|f> that's an interesting way to put it
02:35:26 <merijn> Is Dan Doel on here? (If so, what's his nick?)
02:37:30 <liste> xj54y seems like you're missing a non-Haskell dependency
02:38:19 <xj54y> well that's no fun.. :(
02:38:24 <xj54y> Which dependency?
02:38:50 <xj54y> I noticed Linker, but that seems extremely ambiguous
02:40:19 <liste> at least LLVM has Linker.h
02:43:18 <edwardk> f|`-`|f: technically prisms aren't dual to lenses. both are "lenses" in a deep fundamental sense with respect to different monoidal tensors... tensors which are constructed by dual means.
02:43:24 <xj54y> I don't believe I have llvm installed.. Let's see
02:43:30 <edwardk> they just "look" dual at first glance
02:43:46 <edwardk> and we constructed them by dualizing the laws
02:43:55 <edwardk> it wasn't until later we realized they were really the same thing
02:44:08 <edwardk> merijn: dolio 
02:44:36 <f|`-`|f> :v
02:46:21 <merijn> edwardk: Actually, I just read a few lines further and it was suddenly "Kan extensions and confusion", so I'll postpone figuring out this blog post until later :p
02:46:46 <edwardk> hah
02:50:30 <xj54y> liste, now that I have llvm and llvm-dev installed, I'll go ahead and retry;
02:50:48 <xj54y> liste, hmm.. No difference
02:54:28 <f|`-`|f> So prisms are lenses
02:55:16 <liste> too bad :/ hard to say what's wrong
02:59:39 <f|`-`|f> so LLVM is Low Level Virtual Machine?
03:03:08 <liste> yeah
03:04:08 <liste> usually it's used as a part of compiling pipeline to produce assembly
03:06:00 <Ainieco> hello
03:06:02 <Ainieco> which
03:06:26 <Ainieco>  library provides mondaic loops?
03:06:41 <pavonia> @hackage monad-loops
03:06:41 <lambdabot> http://hackage.haskell.org/package/monad-loops
03:06:44 <f|`-`|f> So, is it used for reducing to assembly?
03:06:57 <f|`-`|f> er haskell to assembly
03:07:11 <Ainieco> i just need something like "repeat 10 $ putStrLn "hello"
03:07:21 <Ainieco> pavonia: ha-ha, thanks
03:07:45 <pacak> Ainieco: replicateM 10 $ putStrLn "hello"
03:08:01 <pacak> Hmmm... Not quite
03:08:18 <pacak> :t sequence_ $ repeat 10 (print "hello world")
03:08:19 <lambdabot>     Couldn't match expected type ‘IO () -> t0 (m a0)’
03:08:20 <lambdabot>                 with actual type ‘[Integer]’
03:08:20 <lambdabot>     The function ‘repeat’ is applied to two arguments,
03:08:30 <pacak> :t sequence_ $ replicate 10 (print "hello world")
03:08:31 <lambdabot> IO ()
03:09:04 <Haskellfant> :t void $ replicateM 10 $ putStrLn "hello"
03:09:06 <lambdabot> IO ()
03:09:08 <Ainieco> pacak: oh, thanks, monad-loops looks usefull but it seems that sequence_ . replicate should be good.
03:09:16 <pacak> :t replicateM 10 (print "hello world")
03:09:18 <lambdabot> IO [()]
03:09:25 <pacak> :t replicateM_ 10 (print "hello world")
03:09:26 <lambdabot> IO ()
03:09:32 <pacak> Depending if you want the results or not.
03:09:55 <Ainieco> should be enough*
03:10:13 <Ainieco> pacak: yeah, i'm aware of "_" convention
03:10:55 <liste> f|`-`|f no it reduces LLVM bytecode to assembly
03:11:06 <f|`-`|f> well hell
03:11:08 <liste> GHC reduces Haskell to LLVM bytecode
03:11:27 <f|`-`|f> so does something reduce it to machine code?
03:11:35 <Ainieco> llvm does
03:11:42 <liste> assembler translates assembly to machine code
03:11:46 <liste> they're really the same thing
03:11:56 <liste> just different serializations
03:13:48 <f|`-`|f> neat
03:14:09 <f|`-`|f> So the bytecode is why haskell is pretty interoperable? Or is that an implementation of GHC
03:14:30 <liste> interoperable as in with c?
03:14:44 <liste> or working on different platforms
03:16:21 <f|`-`|f> platforms?
03:17:29 <frerich> f|`-`|f: The bytecode is not what makes Haskell programs compiled with GHC portable, no. The bytecode is not distributed.
03:17:57 <liste> platforms=different OS:es and processor architectures
03:18:21 <liste> (in this case)
03:19:15 <Ainieco> llvvm does it portable
03:19:44 <Ainieco> llvm makes it*
03:23:27 <f|`-`|f> getting conflicting statements here
03:25:56 <liste> LLVM makes it easier to make GHC work on different platforms
03:26:20 <f|`-`|f> But not a panacea, yet
03:26:58 <liste> there is no silver bullet
03:27:18 <liste> even Java programs need to be ported sometimes
03:28:14 <Ainieco> java's "write once run everywhere" is just a marketing BS(byte string)
03:28:17 <f|`-`|f> wow
03:28:42 <f|`-`|f> Wouldn't it be write once, never read?
03:29:00 <liste> f|`-`|f perl?
03:29:09 <f|`-`|f> yeah
03:29:27 <f|`-`|f> I guess this is why EDSL's are a thing
03:35:26 <benedikt> Ainieco: i wouldn't go as far as saying it's marketing BS, since its one of the driving design principles behind java/jvm, but you are still correct and it's important to know that it's not The Holy Truth 
03:55:04 <merijn> liste: GHC just produces assembly/machine code by default
03:55:12 <merijn> liste: LLVM bytecode is optional
03:55:58 <f|`-`|f> what the hell
03:56:22 <merijn> What the hell what?
04:00:11 <xj54y> wait, we're still talking about llvm? :o
04:02:46 <Ainieco> xj54y: probably, merijn just pointed out that llvm is optional, not sure if f|`-`|f was aware, didn't follow from the beginning of conversation
04:03:59 <xj54y> ahihi, well.. Lamdbabot seems to want something fancy and unless I can satisify its dependencies, meh
04:04:28 <liste> xj54y what would you use Lambdabot for?
04:05:35 <xj54y> liste, mostly goa
04:07:23 <ahihi> xj54y: good to know!
04:07:57 <xj54y> ahihi, >_>
04:08:03 <ahihi> ;p
04:08:21 <bergmark> ahihi: seems like it builds everywhere if you add --constraint='utf8-string<1'
04:08:46 <ahihi> I am not participating in this discussion, stop highlighting me!
04:08:58 <bergmark> woops
04:10:40 <xj54y> hehe
04:11:19 <lamefun> Why does Control.Applicative wrap function called "pure"? What does it have to do with purity or purification?
04:11:25 <lamefun> *is
04:12:03 <lamefun> Is that it you can't wrap IO values in an Applicative?
04:12:29 <liste> > (pure "hello") :: IO String
04:12:33 <lambdabot>  <IO [Char]>
04:12:57 <liste> > pure (putStrLn "goofy, innit?")
04:12:59 <lambdabot>      No instance for (Show (f0 (IO ())))
04:12:59 <lambdabot>        arising from a use of ‘show_M178684916262536966131828’
04:12:59 <lambdabot>      The type variable ‘f0’ is ambiguous
04:13:11 <liste> :t pure (putStrLn "goofy, innit?")
04:13:12 <lambdabot> Applicative f => f (IO ())
04:14:11 <aurimas> Hello, I have a program for which some dependencies fail to install. I know how to fix this in the source of the dependency
04:14:17 <liste> lamefun it turns a non-Applicative value into an Applicative value
04:14:25 <liste> not sure how it relates to purity, though
04:14:27 <aurimas> but how do I make this fixed package available to my program?
04:14:27 <lamefun> Oh, IO is an Applicative? Pure? I'm confused...
04:15:00 <aurimas> all this is in cabal sandbox
04:15:11 <liste> aurimas how did you fix it?
04:15:33 <aurimas> I just add overloadedInstances language pragma :)
04:15:37 <liste> cabal sandbox add-source could help
04:15:54 <aurimas> ok, i will look this up
04:15:55 <lamefun> > (map (++) ["a", "b", "c"]) <*> ["1", "2", "3"]
04:15:58 <lambdabot>  ["a1","a2","a3","b1","b2","b3","c1","c2","c3"]
04:16:55 <liste> sometimes non-monadic/non-applicative values are called "pure"
04:17:28 <liste> and sometimes it's non-IO values
04:18:22 <liste> but IO actions can be also seen as pure values that, when run, produce results
04:18:57 <tdammers> different frame of reference
04:19:06 <ttt_fff> why is ubuntu 15.04's ghc 7.6.3 ?
04:19:10 <ttt_fff> is there a way to apt-get 7.8.3 ?
04:19:27 <liste> ubuntu has ancient versions of everything
04:19:51 <aurimas> liste, thanks, this add-source thing works.Not sure how i missed it, i read the docs, but...
04:22:23 <lamefun> :t pure (Just "abc")
04:22:24 <lambdabot> Applicative f => f (Maybe [Char])
04:22:43 <lamefun> :t pure (Just "abc") :: IO (Maybe [Char])
04:22:44 <lambdabot> IO (Maybe [Char])
04:23:45 <lamefun> So the name is just a bad historical baggage?
04:23:50 <ion> ttt_fff: https://gist.github.com/ion1/2815423
04:25:41 <liste> lamefun imo "return" is bad historical baggage
04:26:31 <lamefun> both of them seem to be...
04:27:45 <Haskellfant> well you definitely need one of them
04:27:56 <lamefun> And IMO fmap, makes Functor seem more mysterious at a first glance than it really is...
04:29:21 <liste> didn't map use to be what we call fmap now?
04:29:49 <ttt_fff> ion: noted, thanks!
04:30:19 <liste> and they specialized map to [] for better error messages and created fmap
04:30:43 <lamefun> Better error messages?
04:31:31 <liste> > map (+1) (1,2,3,4,5)
04:31:33 <lambdabot>      Couldn't match expected type ‘[b]’
04:31:33 <lambdabot>                  with actual type ‘(Integer, Integer, Integer, Integer, Integ...
04:31:33 <lambdabot>      In the second argument of ‘map’, namely ‘(1, 2, 3, 4, 5)’
04:31:44 <liste> actually
04:31:52 <adimit> does Text.Parsec.Text offer some way to parse arbitrary alphaNum text or so? If I don many1 alphaNum, what I get is [Char], not Text.
04:31:52 <liste> > map (+1) 5.24
04:31:54 <lambdabot>      No instance for (Show b0)
04:31:54 <lambdabot>        arising from a use of ‘show_M717957422154923237932153’
04:31:54 <lambdabot>      The type variable ‘b0’ is ambiguous
04:32:21 <liste> wtf
04:33:07 <liste> :t map (+1) 5.24
04:33:08 <lambdabot> (Fractional [b], Num b) => [b]
04:33:35 <liste> > (map (+1) 5.24) :: [Double]
04:33:37 <lambdabot>      No instance for (Fractional [Double])
04:33:38 <lambdabot>        arising from the literal ‘5.24’
04:33:38 <lambdabot>      In the second argument of ‘map’, namely ‘5.24’
04:34:13 <liste> > map (+1) (5.24::Double)
04:34:15 <lambdabot>      Couldn't match expected type ‘[b]’ with actual type ‘Double’
04:34:15 <lambdabot>      In the second argument of ‘map’, namely ‘(5.24 :: Double)’
04:34:15 <lambdabot>      In the expression: map (+ 1) (5.24 :: Double)
04:34:17 * hackagebot getopt-generics 0.7 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.7 (qoelet)
04:34:20 <liste> > fmap (+1) (5.24::Double)
04:34:21 <lambdabot>      Couldn't match expected type ‘f b’ with actual type ‘Double’
04:34:21 <lambdabot>      In the second argument of ‘fmap’, namely ‘(5.24 :: Double)’
04:34:21 <lambdabot>      In the expression: fmap (+ 1) (5.24 :: Double)
04:34:37 <liste> from the first one, it's clear you need a list
04:34:49 <dramforever> liste: lol :D gets turned into a laughing face here in pidgin
04:35:01 <liste> the second one can be confusing for beginners
04:35:50 <liste> dramforever that drove me nuts (using pidgin for IM)
04:35:56 <liste> had to turn off smileys
04:37:12 <lamefun> why doesn't it tell what class is f from?
04:39:25 <liste> no idea :(
04:39:42 <dramforever> GHC isn't beginner friendly at all
04:40:49 <pacak> dramforever: It is. It's just a bit picky about his friends.
04:41:54 <dramforever> pacak: oh, but isn't "beginner-friendly" the same as "friendly to beginners"?
04:42:10 <pacak> dramforever: For right kind of beginners :)
04:42:44 <hodapp> lamefun: I'd imagine that in that case, the class of 'f' isn't even relevant, because the type doesn't even have the right form.
04:43:04 <dramforever> lamefun: I guess it's because the Functor is just a constraint
04:43:31 <dramforever> "Functor f =>" didn't bring it into scope, so it's wrong to say that f is from Functor
04:43:48 <dramforever> let me try this:
04:44:11 <dramforever> @let weird = (\x -> x) :: f a -> f a
04:44:12 <lambdabot>  Defined.
04:44:19 <dramforever> > weird 2
04:44:21 <lambdabot>      No instance for (Show (f0 a0))
04:44:21 <lambdabot>        arising from a use of ‘show_M903604729251177789732398’
04:44:21 <lambdabot>      The type variables ‘f0’, ‘a0’ are ambiguous
04:44:41 <dramforever> > weird 'a'
04:44:42 <liste> > weird (2::Int)
04:44:44 <lambdabot>      Couldn't match expected type ‘f a’ with actual type ‘Char’
04:44:44 <lambdabot>      In the first argument of ‘weird’, namely ‘'a'’
04:44:44 <lambdabot>      In the expression: weird 'a'
04:44:44 <lambdabot>  <no location info>: can't find file: L.hs
04:45:03 <dramforever> > weird [2]
04:45:05 <lambdabot>  [2]
04:45:11 <dramforever> lamefun: see?
04:46:47 <lamefun> doesn't it know the constraints?
04:47:15 <dramforever> lamefun: can I say no?
04:47:33 <dramforever> wait, I mean it doesn't know the constraints
04:47:51 <lamefun> I call fmap and it doesn't know what form should argument conform to, it just guesses at random?
04:48:19 <dramforever> lamefun: well, how do I explain that...
04:48:19 <hodapp> lamefun: It knows what form. That form is 'f b'. If the form of it's not right, the constraints aren't relevant.
04:48:21 <dramforever> :t fmap
04:48:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:48:29 <dramforever> right, hodapp got it
04:48:49 <Myrl-chan> let weird_ = (id :: f a -> f a)
04:48:56 <Myrl-chan> @let weird_ = (id :: f a -> f a)
04:48:57 <lambdabot>  Defined.
04:49:01 <Myrl-chan> > weird_ 1
04:49:03 <lambdabot>      No instance for (Show (f0 a0))
04:49:03 <lambdabot>        arising from a use of ‘show_M7003610661954015532528’
04:49:03 <lambdabot>      The type variables ‘f0’, ‘a0’ are ambiguous
04:49:05 <Myrl-chan> > weird_ [1]
04:49:07 <lambdabot>  [1]
04:49:33 <dramforever> actually, it's kinda funny that (f x) isn't a special case of a
04:50:46 <Myrl-chan> > weird_ id 1
04:50:47 <lambdabot>  1
04:52:43 <lamefun> hodapp, of course they aren't relevant, but IMO the compiler should try to show some additional information to point newbies in the correct direction.
04:53:11 <hodapp> lamefun: How exactly does irrelevant information point newbies in the correct direction?
04:56:37 <dramforever> hodapp: I guess those shown in the messages of holes would be enough
04:58:06 <dramforever> > fmap (+1) _
04:58:07 <lambdabot>      Found hole ‘_’ with type: f b
04:58:07 <lambdabot>      Where: ‘f’ is a rigid type variable bound by
04:58:07 <lambdabot>                 the inferred type of it :: f b at Top level
04:58:52 <dramforever> looks like ghc developers never cared about constraints while designing these error messages
04:59:28 <flux> good error messages are one of the remaining mysteries in the CS field :-)
04:59:50 <lamefun> >data Boom a = Boom a
04:59:58 <lamefun> >fmap (+1) (Boom 2)
05:00:15 <dramforever> only three things are truly hard in CS: cache invalidation, naming things and tech support
05:00:22 <lamefun> > data Boom a = Boom a
05:00:24 <lambdabot>  <hint>:1:1: parse error on input ‘data’
05:00:35 <dramforever> lamefun: use @let for top level stuff
05:00:42 <ski> @let data Boom a = MkBoom a deriving Show
05:00:44 <lambdabot>  Defined.
05:01:02 <lamefun> > fmap (+1) (MkBoom 2)
05:01:05 <lambdabot>      Could not deduce (Functor Boom) arising from a use of ‘fmap’
05:01:05 <lambdabot>      from the context (Num b)
05:01:05 <lambdabot>        bound by the inferred type of it :: Num b => Boom b at Top level
05:01:24 <ski> @let instance Functor Boom where fmap f (MkBoom a) = MkBoom (f a)
05:01:27 <lambdabot>  Defined.
05:01:33 <lamefun> > map (+1) (MkBoom 2)
05:01:34 <lambdabot>      Couldn't match expected type ‘[b]’ with actual type ‘Boom Integer’
05:01:35 <lambdabot>      In the second argument of ‘map’, namely ‘(MkBoom 2)’
05:01:35 <lambdabot>      In the expression: map (+ 1) (MkBoom 2)
05:01:45 <dramforever> lamefun: btw what makes someone write map (+1) 2
05:01:50 <dramforever> ?
05:01:58 <ski> > fmap (+1) (MkBoom 2)
05:02:00 <lambdabot>  MkBoom 3
05:02:19 <lamefun> fmap for MkBoom error message = incomprehensible
05:03:00 <ski> "Could not deduce (Functor Boom)" means that it can't see why `Boom' would be a functor
05:03:14 <ski> "arising from a use of ‘fmap’", and so `fmap' isn't defined on it
05:03:46 <ski> "from the context (Num b)" expresses the available context from which it was unable to deduce `Functor Boom'
05:04:10 <ski> "bound by the inferred type of it :: Num b => Boom b at Top level" explains where this context came from
05:04:35 <dramforever> ski: why didn't ghc people replace everything on the lhs of "means" with the rhs?
05:05:01 <ski> (the type was inferred, and "it" was a top level expression entered into the interactor)
05:06:14 <ski> "Could not deduce (Functor Boom)" expresses in a compact way that `Functor Boom' wasn't deducible
05:06:54 <xj54y> random and off topic; the solution to the poincare conjecture is quite dazzling
05:07:42 <ski> "would be a functor" belongs to our vernacular explanation of what `Functor' means for it. it probably can't be expected to be able to use such context-sensitive phrases. perhaps there could be a better way to express it than "Could not deduce (Functor Boom)", dunno
05:08:25 <hodapp> Calling it 'incomprehensible' exaggerates a bit though.
05:08:52 <ski> dramforever : not sure if this satisfies you, but after some experience, you usually get a hang for how to interpret the more common kinds of errors. that's not to say there couldn't be room for improvement
05:08:55 <dramforever> ski: (IsFunctor Boom) looks a little better to me, actually
05:09:15 <hodapp> If you throw code at fmap and you haven't the slightest inkling what's going on when it starts complaining that something is not a Functor, I'm not seeing a ton the compiler can do.
05:09:52 <dramforever> hodapp: that makes sense, no reason anyone want to fmap (+1) 2
05:10:11 <R0b0t1> hodapp, a swift kick to the groin.
05:13:07 <ski> @let instance Num a => Num (rho -> a) where (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*); negate = fmap negate; abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger
05:13:09 <lambdabot>  Defined.
05:13:28 <ski> > fmap (+1) 2 5
05:13:30 <lambdabot>  3
05:14:17 <ski> > map (sin^2 + cos^2) [0,pi/4 .. pi]
05:14:20 <lambdabot>  [1.0,1.0,1.0,1.0,1.0]
05:18:07 <ski> @let instance Fractional a => Fractional (rho -> a) where (/) = liftA2 (/); recip = fmap recip; fromRational = pure . fromRational
05:18:09 <lambdabot>  Defined.
05:18:31 <ski> > map ((id^3 + 3 * id^2 + 2 * id) / 6) [0 .. 9]
05:18:33 <lambdabot>  [0.0,1.0,4.0,10.0,20.0,35.0,56.0,84.0,120.0,165.0]
05:19:20 * hackagebot gll 0.2.0.1 - GLL parser with simple combinator interface  http://hackage.haskell.org/package/gll-0.2.0.1 (ltvanbinsbergen)
05:20:10 <nullx002>  /q jackhill
05:23:10 <k_bx> Hi! Is there a reason we can’t remove «let» from do-monad? I mean, to be able to write «foo = do { a = 10; print a }» instead of writing «foo = do { let a = 10; print a }». That let, especially the fact that you can write multiple of them, makes a bad story for formatting big expressions which are on the right of let-exp (e.g. to which you assign).The code starts looking like this: https://i.imgur.com/YbsD5Cd.png , e.g. you have to do too
05:23:10 <k_bx> much spacing.
05:23:41 <k_bx> s/do-monad/do-syntax/
05:23:54 <dramforever> monadic do?
05:24:06 <dramforever> k_bx: doesn't your editor auto-indent?
05:24:47 <ttt_fff> on ubuntu, is there a way to add an apt-source to auto pull in latest ghc (i.e. 7.8.x instead of 7.6.3)
05:25:09 <ski> > (map . map) (fst^2 + fst*snd + snd^2) [[(i,j) | j <- [0 .. 3]] | i <- [0 .. 3]]
05:25:10 <lambdabot>  [[0,1,4,9],[1,3,7,13],[4,7,12,19],[9,13,19,27]]
05:25:27 <k_bx> dramforever: here’s what I mean https://gist.github.com/k-bx/c93c1e3a89a4547e9585 I want to save 4 additional spaces brought by let.
05:25:40 <ion> ttt_fff: I think hvr or someone has a PPA, but i have just been doing what the gist says.
05:25:50 <ttt_fff> yeah
05:25:54 <ttt_fff> i'm setting this up via vagrant
05:26:05 <ttt_fff> I'd really like a minimal # of lines / interactivity :-(
05:26:30 <k_bx> Updated gist to better express problem
05:26:32 <Axman6> ttt_fff: I have a vagrantfile which does that
05:26:49 <ttt_fff> Axman6: I will offer you 0 bitcoins for said vagrantfile
05:27:06 <ttt_fff> Axman does your vagrantfile build ghcjs too ?
05:27:08 <ttt_fff> that'd be ideal
05:27:15 <thebnq> k_bx: because the let can define different things on the same line
05:27:25 <Axman6> no, but it wouldn't be too hard to do.
05:27:31 <ttt_fff> Axman6: could you add it? :-)
05:27:37 <thebnq> k_bx: just like a where block
05:27:41 <ttt_fff> #ghcjs would be greateful
05:27:51 <thebnq> k_bx: sorry, different things on consecutive lines
05:27:52 <ttt_fff> https://github.com/ghcjs/ghcjs-build/blob/master/Vagrantfile
05:27:57 <ttt_fff> hmm, maybe I should use that
05:28:09 <ttt_fff> oh wait, that is from 2013
05:28:14 <dramforever> ??? gist.github.com timeout ???
05:28:24 <k_bx> thebnq: yeah, I know that it lets you to, but if it’s not the case — wouldn’t it be nice to not require «let» when you only define a single thing?
05:28:54 <ttt_fff> why is https://github.com/ghcjs/ghcjs-build not been updated ?
05:29:05 <k_bx> dramforever: I also noticed some problems with github, my coworker constantly gets them during last week
05:29:21 <dramforever> dunno why
05:29:25 <k_bx> (but it works for me)
05:29:30 <dramforever> forget about it
05:30:10 <Axman6> ttt_fff: http://lpaste.net/133866
05:30:27 <Axman6> had to clean it up a bit to remove our site specific stuff
05:30:42 <Axman6> and now it's time for bed
05:30:57 <ttt_fff> oh nice
05:31:01 <ttt_fff> you pull in a git repo
05:31:05 <thebnq> k_bx: seems tricky for the parser to know that, i'm not sure. Might just be an old stylistic choice
05:31:08 <ttt_fff> then you only install dependencies for that project
05:31:08 <ttt_fff> nice
05:31:12 <ttt_fff> g'night
05:31:14 <Axman6> yep
05:31:22 <Axman6> that repo could be GHCJS
05:31:27 <Axman6> potentially
05:31:40 <Axman6> just follow the GHCJS instructions in that file and you should be good to go
05:31:48 * Axman6 -> bed
05:31:51 <dramforever> k_bx: dunno, but I don't really think that it really matters much. it could be because of the (somewhat) obvious desugaring
05:32:11 <ski>   let eventParameters = Map.toList
05:32:21 <ski>                       . Map.map (BS.intercalate " ")
05:32:33 <ski>                       . (`Map.filterWithKey` ps)
05:32:44 <dramforever> ski: that didn't solve the problem
05:32:45 <ski>                       $ \k _ -> k `elem` pingParameterKeys
05:33:05 <dramforever> join (liftA2 (,)) [0..3]
05:33:11 <dramforever> > join (liftA2 (,)) [0..3]
05:33:13 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
05:33:48 <ski> k_bx : i'm not sure i understand what "you have to do too much spacing" means
05:34:14 <thebnq> meh, 4 letters is not much considering how much few keywords haskell has
05:34:45 <ski> the number of spaces ? the drifting to the right of indentation ? the ratio of space per line ?
05:35:10 <liste> by the way, how do you guys align the code when mixing ., <*, *>, <$> etc?
05:35:19 <ski> dramforever : because i didn't understand it
05:35:43 <dramforever> ski: I didn't really understand it too, I guess
05:36:19 <k_bx> 4 letters is not much, but it is a lot when it’s additional 4 spaces, because it just creates a visual «hole» in your code, which takes your attention. I find that it makes a bad code-layout, and omitting these 4 spaces would put it in line with bind-syntax: longLonLongLongVar <-
05:36:46 <lpaste> dramforever pasted “I do this:” at http://lpaste.net/133867
05:37:18 <dramforever> but I seldom use *> and <*
05:37:31 <ski> k_bx : the above is just one offer of how i might write it. .. if the line width drifts too high, i'd consider starting the `. 's two spaces past the start of `eventParameters', with `Map.toList' on its own line, aligned
05:38:13 <dramforever> k_bx: so you mean a colored "let" catches your eyes?
05:39:34 <k_bx> dramforever: no, let is fine, but if you want to start multi-line expression on next line you have to align it not 2, and not 4, but 6 or 8 spaces right
05:40:04 <dramforever> why?
05:40:27 <ski> i suppose you *could* break the line after the `let', and then you get only 4 (or a minimum of 2) spaces
05:40:30 <k_bx> dramforever: because making it 4 spaces aligns it with variable-name-start, so haskell thinks it’s multi-let-binding expression
05:41:52 <k_bx> like in section «because you cannot write like this» https://gist.github.com/k-bx/c93c1e3a89a4547e9585
05:42:02 <k_bx> where 4-space-indentation is shown
05:42:13 <ski> (or you could use braces)
05:42:29 <k_bx> ski: I find just making let optional to be much nicer solution
05:42:49 <k_bx> It would also make ghci more user-friendly (you wouldn’t have to start a tutorial with «well, you have to use let, but I’ll explain it to you later)
05:43:46 <dramforever> k_bx: maybe you are right, but I'm afraid that it would never be changed
05:43:49 <thebnq> k_bx: conversely, that would be confusing because now definitions (with =) have two different contexts in the language
05:44:25 <k_bx> thebnq: what’s definitions?
05:44:38 <thebnq> the global/let/where block, and then i guess you're suggesting also monad blocks
05:45:25 <k_bx> I only suggest this as part of do-syntax desugaring.
05:45:56 <k_bx> Anyway, thanks everyone, I will make a nice and clean proposal later and send it to cafe.
05:46:21 <thebnq> yea i know, i was just saying that although it makes ghci easier, it does add confusion elsewhere
05:47:03 <k_bx> aah, in ghci yes, it would possibly add confusion to ghci indeed
05:54:22 * hackagebot sdr 0.1.0.3 - A software defined radio library  http://hackage.haskell.org/package/sdr-0.1.0.3 (adamwalker)
05:57:33 <lamefun> Can I make restrained types? Eg. a string type called OptionName (only allows A-Z, a-z and _), which can only be constructed by mkOptionName :: String -> OptionName, but can be used everywhere a string can be used.
05:57:54 <lamefun> * -> Maybe OptionName
05:58:24 <dramforever> like a subtype
05:58:25 <liste> lamefun no, a String is a String
05:58:25 <dramforever> ？
05:58:35 <liste> there's no subtyping in Haskell
05:58:45 <dramforever> that's looks like what type classes can do
05:59:22 <smunix> :t mapM
05:59:23 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:00:42 <smunix> :t mapM
06:00:44 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:01:02 <smunix> :t mapM_
06:01:03 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
06:01:19 <liste> but yeah, usually typeclasses and (G)ADTs can be used to solve similar problems
06:01:59 <lamefun> but String is not a typeclass...
06:03:29 <alpounet> lamefun: there's an IsString class which lets you use string literals for any type that implements this class (when the OverloadedStrings extension is on), but this requires to to be able to accept any string as a valid one which is not your case here. so if you want the safety you have to give up *some* comfort
06:05:05 <Athas> Any other Travis users here?  How do you deal with the longer compile times in GHC 7.10?  My Travis builds time out due to how long it takes to build dependencies.
06:06:33 <hodapp> Athas: I have approximately 45 minutes of experience with Travis, but are you able to use its caching?
06:13:20 <Athas> hodapp: I don't know - I was looking for Haskell projects that already have a working setup I can copy from.
06:17:26 <hodapp> Athas: That's one feature I'd look into if dependencies are the issue.
06:17:46 <hodapp> Athas: do something like making a cabal sandbox, building everything there, and then caching the whole sandbox.
06:19:41 <Athas> hodapp: yes, that sounds reasonable.  I guess I will finally have to figure out sandboxes.
06:20:04 <hodapp> Athas: for your project I doubt it'll much matter. 'cabal sandbox init' and go about your build.
06:21:11 <hodapp> and then the sandbox itself sits in the local directory.
06:21:11 <liste> Athas could you use container-based infrastructure? http://docs.travis-ci.com/user/workers/container-based-infrastructure/
06:24:53 <Athas> liste: I guess I will have to, but I don't know the ramifications.  I will definitely need to switch to containers if I want to use caching, it seems, so I have no choice.
06:28:46 <Athas> It seems that in my current .travis.yml, I only sudo to install GHC.
06:28:58 <Athas> So I guess using containers is not so bad.
06:29:25 <dramforever> Athas: you don't have to, I think you can install ghc to a user folder, but I'm not sure if you'll get the latest version
06:29:56 <Athas> I want specific versions, so I don't mind that.  Sounds like I have plans for the evening now.
06:30:23 <dramforever> For example, I have GHC installed to ~/.ghc-7.10.1
06:32:23 <dramforever> Athas: you can wget/curl the ghc binary packages that "most users" don't use
06:32:31 <dramforever> https://www.haskell.org/ghc/download_ghc_7_10_1 , for example
06:40:38 <teetees> Hello
06:41:00 <teetees> Sorry for asking a knob question but to define a var why do I need to do `let x = x in 1`?
06:41:13 <teetees> I am following the tutorial on the main page.
06:41:20 <teetees> Why can't I just do `let x = 1`?
06:41:53 <dramforever> teetees: 1. because (let x = x in 1) is a single expression
06:42:07 <liste> teetees where?
06:42:18 <dramforever> as the webpage says, the prompt only accepts Haskell expressions
06:42:19 <liste> I can do "let x = 1" in GHCi
06:42:36 <dramforever> liste: haskell.org -> "Try it", I think
06:42:42 <dramforever> teetees: is that correct?
06:43:29 <teetees> liste: https://www.haskell.org/#step9
06:43:49 <teetees> dramforever: yes
06:44:12 <dramforever> teetees: does the "expressions" explaination make sense?
06:44:14 <teetees> dramforever: Can you explain what you mean by one expression? and how `let x = 1` isn't?
06:44:38 <teetees> Sorry no. for my understanding an expression is something that evaluates to a value.
06:44:49 <teetees> So, essentially, 1 should be an expression too? or not?
06:44:53 <liste> 1 is
06:44:57 <liste> but "let x = 1" isn't
06:45:05 <dramforever> what's the value of (let x = 1)?
06:45:07 <liste> what would be the value of let x = 1
06:45:08 <liste> ?
06:45:21 <teetees> i see it now
06:45:21 <dramforever> liste: you go ahead
06:45:28 <liste> :D
06:45:37 <dramforever> good for you
06:45:49 <teetees> so in Haskell everything must be an expression?
06:45:54 <dramforever> not really
06:45:57 <dramforever> just in that prompt
06:46:10 <teetees> Oh, so statements are allowed too?
06:46:46 <dramforever> teetees: that tutorial can only make you have a feel of haskell
06:46:47 <teetees> I am a total haskell rookie, in fact a factional programming rookie beyond some basic functional programming you can do in JavaScript and so map/reduce stuff I have done with other languages
06:47:04 <teetees> dramforever: Where can I read a "fast intro" for someone who knows some programming?
06:47:08 <tdammers> haskell doesn't really have "statements"
06:47:22 <teetees> So what is `let x =1`?
06:47:27 <dramforever> maybe you should read something like Real World Haskell or Learn you a Haskell
06:47:33 <dramforever> teetees: it's hard to explain
06:47:36 <teetees> Does let return the assigned value?
06:47:46 <tdammers> let x = 1 on its own is nothing
06:47:47 <teetees> dramforever: I will have a look, cheers
06:47:58 <tdammers> let x = 1 in x -- is an expression
06:48:36 <dramforever> teetees: I would recommend Learn You a Haskell for Great Good (abbreviated to Learn You a Haskell) for more *fun* while learning
06:48:39 <merijn> teetees: "let x = 1" is part of the do notation syntactic sugar
06:48:47 <dramforever> merijn: don't say that
06:49:15 <ackthet> teetees: join #haskell-beginners 
06:49:18 <tdammers> even in do notation, let x = 1 on its own isn't correct syntax
06:49:23 <tdammers> > do { let x = 1 }
06:49:25 <lambdabot>      The last statement in a 'do' block must be an expression let x = 1
06:49:30 <teetees> okay, I will.
06:49:51 <merijn> teetees: I don't think there is a "fast intro" for someone who knows programming, because knowing how to programming is not that helpful for learning haskell. I recommend LYAH and https://github.com/bitemyapp/learnhaskell
06:50:01 <teetees> > do { let x = 1; x }
06:50:03 <lambdabot>  <hint>:1:19: parse error on input ‘}’
06:50:30 <dramforever> teetees: just be careful: many things are so different in haskell that you can't compare them to anything you've learned while programming
06:50:48 <dramforever> well, programming in "other" languages
06:51:04 <merijn> dramforever: Unless they're OCaml/SML/F# :p
06:51:25 <dramforever> merijn: yep, so I have "other" with quotes
06:52:18 <teetees> it seems like it
06:52:28 <teetees> I have tried to learn haskell one a many times 
06:52:32 <teetees> but everytime I give up
06:52:37 <teetees> this time I kinda need to
06:52:40 <teetees> so there it goes :)
06:53:05 <dramforever> teetees: you need to? wow, how?
06:54:51 <teetees> dramforever: I need to learn a functional programming language, I have been told it is great for data analysis, most number crunching.
06:56:05 <merijn> I would say they're just great in general :p
06:56:28 <dramforever> I would vote for being "concise"
06:57:02 <nabokovian> teetees, you know what's a great book? realworld haskell. just my opinion. i think learnyouahaskell is great for the first few chapters but it tends to get weird. i am by no means proficient in haskell but this has been my experience so far.
06:57:04 <Ainieco> i want more industrial users
06:57:19 <Ainieco> they have it in ocaml :/
06:57:32 <teetees> Who is "alex"? ;)
06:57:39 <teetees> Why does my system needs it for Haskell Platform?
06:57:51 <dramforever> teetees: it's like lex, if you have heard of it
06:58:09 <Ainieco> teetees: lexer
06:58:22 <dramforever> Ainieco: ...generator?
06:58:32 <merijn> Ainieco: There's already a bunch, Standard Chartered just posted a job opening on reddit :p
06:58:47 <teetees> dramforever: Yeah, I have. 
06:58:48 <lingxiao> hey all!
06:58:57 <lingxiao> does any one know where I can get "haskell data analysis cookbook" for free?
06:59:06 <dramforever> hmm...
06:59:10 <Ainieco> merijn: i.. want... more...
06:59:24 <dramforever> hmm...data analysis...
06:59:26 <lingxiao> I found a sample online 
06:59:33 <dramforever> teetees: yeah, maybe you are correct
07:00:10 <teetees> dramforever: Huh, there you go.
07:00:30 <merijn> Ainieco: Facebook and at least 3 banks are using it and a couple of others I don't know the name of
07:01:32 <teetees> nabokovian: Is it a free book?
07:01:47 <teetees> I really like the idea of learning by real examples
07:01:54 <Ainieco> merijn: that's better, thank you, got my daily dose of haskell idustrial users 
07:01:59 <lingxiao> no it's like $50 on amazon
07:02:13 <lingxiao> and $30 elsewhere, but free is best
07:02:32 * dramforever keeps seeing Chinese pinyin-ish nicks
07:02:56 <teetees> lingxiao: Is it the one by? by Bryan O'Sullivan, Don Stewart, and John Goerzen
07:03:01 <teetees> Seems like they have put it online for free!
07:03:33 <lingxiao> oh no that's real world haskel
07:03:41 <lingxiao> this one is by nishant shukla
07:03:54 <dramforever> teetees: yes, RWH is free online
07:04:06 <liste> and learn you a haskell is too
07:04:07 <dramforever> http://learnyouahaskell.com is free online too
07:04:09 <dramforever> yep
07:05:13 <nabokovian> i really like the embedded comments style in RWH too. makes you feel like you're not alone :P
07:05:52 <dramforever> teetees: wait wait WARNING: RWH and LYAH are somewhat *old*
07:06:10 <teetees> well
07:06:25 <teetees> At least I got myself the ghci and I can do `let x = 1` and then grab it by `x`.
07:06:35 <teetees> So I feel less suffocated at least. :)
07:06:48 <teetees> So what are the recommended resources?
07:06:55 <dramforever> if you run into problems like example code won't run, ask
07:07:22 <dramforever> teetees: I would still recommend those two
07:07:27 <jackhill> teetees: bitemyapp has compiled this list: https://github.com/bitemyapp/learnhaskell
07:07:31 <dramforever> if you run into problems like example code won't run, just ask
07:08:02 <teetees> okay, will do. thanks!
07:24:27 * hackagebot flow 1.0.1 - Write more understandable Haskell.  http://hackage.haskell.org/package/flow-1.0.1 (fozworth)
07:26:24 <xj54y> /join ##latex
07:28:23 <zipper> So uh did people in yesod stop using enumeratee and start using pipes instead?
07:28:39 <merijn> Don't they use conduits?
07:29:08 <merijn> Considering the Snoyman's worked on conduits was mostly for Yesod and WAI, afaik?
07:29:25 <zipper> Oh conduit
07:29:46 <zipper> I keep confusing the name of the one Snoyman made and the one Gonzales made.
07:29:56 <zipper> merijn: So it uses conduit?
07:30:04 <zipper> or enumerator?
07:30:09 <Clint> conduit
07:30:31 <Clint> no one uses enumerator
07:32:06 <zipper> Oh
07:32:28 <mizu_no_oto> Out of curiosity, why doesn't anyone use enumerator anymore?
07:32:30 <zipper> Do I need to read on enumerator to understand conduit though?
07:33:48 <Earnestly> I feel like an idiot, I can't seem to find any documentation for cabal's config (not the cabal.install files) (or is it cabal-install's config?)  Does anyone know where I might look?
07:33:52 <Clint> mizu_no_oto: http://www.yesodweb.com/blog/2012/01/conduit-versus-enumerator
07:34:48 <Earnestly> Essentially the .cabal/config file
07:47:43 <liste> Earnestly I guess the options are pretty much the same as command line options
07:47:47 <Earnestly> Well, if there's (seemingly) no documentation for the config file, does anyone know if it's possible to include external snippets?
07:50:29 <Earnestly> liste: Do config files support constraint: directives?
07:50:55 <Earnestly> Ah it does
07:50:55 <liste> I have a -- constraint: line in my .cabal/config
07:51:01 <Earnestly> Yeah
07:51:02 <c_wraith> mizu_no_oto: well, enumerator was quite a bit more complicated than conduit, to no particular benefit.
07:51:53 <Earnestly> liste: It would be really handy if I could say:  `include: ~/.local/share/cabal/stackage` at the end which just updates constraints.  That way I'd not have to edit the main config file but simply update the stackage file
07:57:05 <liste> you could make a script that updates the stackage file and appends it to your "master" file
07:57:42 <Earnestly> liste: That's quite ugly though
07:58:09 <Earnestly> liste: sed (or ed) could be used to remove the block of constraints and then append a file to the end quite easily, but I'd have liked to avoid that
08:00:21 <jomg> Earnestly, maybe you could automatically create a temporary file and then use cabal --config-file=FILE
08:01:03 <Earnestly> jomg: Does that append (or combine) the actual config or does it use a completely separate file?
08:01:18 <jomg> i'd guess it uses a separate file
08:01:19 <Earnestly> There is seemingly no documentation on this, I find that surprising
08:01:30 <Earnestly> I'm using strace to see what files it attempts to open...
08:01:40 <jomg> you could create a wrapper around cabal that merges both configs into a tempfile
08:01:47 <jomg> and uses that
08:01:51 <Earnestly> But again, that's really ugly
08:02:06 <Earnestly> I get what you're suggesting though and it may be needed
08:02:06 <jomg> true, but at least it leaves your main config intact
08:02:28 <Earnestly> I don't really have any issue with the main config being editted, it's that I'd rather not have to :P
08:03:01 <jomg> you'll figure something out, i'll be back in a moment
08:03:26 <Earnestly> jomg: I was just interested in some documentation really, but there appears to be none outside of the source code
08:05:56 <zipper> Hey where can I get this paper by Simon Marlow http://research.microsoft.com/apps/pubs/default.aspx?id=67498
08:07:46 <sh0t> zipper, can't you just google the title?
08:08:30 <hvr> zipper: googled it for you: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.8701
08:08:30 <zipper> sh0t: I just did.
08:09:28 <zipper> Thanks
08:09:32 <sh0t> sure
08:09:51 <zipper> I have a lot on my plate. LOL can't think straight.
08:10:35 <hodapp> Ahhh, Earnestly. That fellow once called me incompetent and an idiot because I suggested that a build system besides Make might be suitable.
08:10:54 <copycat> hi, i have a n00b question. can't get started with yesod
08:11:11 <copycat> i followed the instructions on http://www.yesodweb.com/page/quickstart
08:11:35 <copycat> but it gives me yesod command not found
08:11:36 <Earnestly> liste: Heh, ed -s ~/.local/share/cabal/config <<< $'g/^constraint:/d\n$ r .local/share/cabal/stackage\nw'
08:11:59 <c_wraith> zipper: note that the paper is 15 years old..  GHC isn't even close to the same system anymore
08:12:03 <copycat> googled that, followed the "solutions" in the first 6 links
08:12:11 <copycat> i'm still stuck, i can't get yesod
08:12:19 <copycat> please help :(
08:12:37 <copycat> im using os x if it matters
08:14:41 <chelfi> copycat: maybe the yesod command is in the sandbox and the sandbox is not in your path ?
08:14:55 <copycat> sandbox? 
08:15:40 <copycat> eh, i restarted bash and i can get yesod now
08:15:49 <copycat> what did i do? :|
08:26:35 <zipper> c_wraith: I hadn't OMFG
08:26:37 <zipper> No use
08:27:01 <bitemyapp> zipper: one nibble at a time.
08:34:49 <johnw> zipper: when looking for papers, Google Scholar is sometimes a better search engine
08:35:07 <zipper> johnw: Noted.
08:35:14 <shapr> especially for zippers
08:35:31 <johnw> and if you want super-searching, and if you have a Mac, then DEVONagent is a superb tool (http://www.devontechnologies.com/products/devonagent/overview.html)
08:35:51 <johnw> researching articles is part of my day job :)
08:35:59 <zipper> shapr: haha
08:36:15 <zipper> Linux
08:37:08 <fizbin> I have a "what typeclass do I need" question. I've got a monad M and a type X. Type X is wrapped in type W. What typeclass should W implement to let me construct g :: (X -> M X) -> W X -> M (W X)
08:37:27 <fizbin> Obviously, W should implement at least Functor.
08:38:00 <fizbin> But I think I need more than that, and I can't quite see how to do the wrapping.
08:38:05 <johnw> that sounds like
08:38:07 <johnw> :t traverse
08:38:08 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:38:32 <fizbin> Huh. Okay, yeah. That could work.
08:39:02 <fizbin> Is there something less than Traversable that only requires f to me a monad?
08:39:22 <fizbin> *be
08:39:23 <johnw> no
08:39:47 <saulzar> Monad should be Applicative, too
08:39:47 <ski> @type mapM
08:39:49 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
08:40:09 <johnw> the problem is that you need to iterate through the structure, apply your a -> f b everywhere, and then "aggregate" the effects in 'f'.  If you only needed t (f b), then it could just be a functor
08:40:48 <ew_> Monad is not outdated?
08:41:04 <fizbin> Yeah, unfortunately I need the monad on the outside.
08:41:04 <ew_> things from Applicative seem to have replaced it, or not?
08:41:08 <johnw> fizbin: to make the question even simpler, this is the only operation you need to make this happen:
08:41:09 <johnw> :t sequenceA
08:41:11 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
08:41:23 <johnw> you should be able to convince yourself that only Functor t cannot do this
08:41:52 <ew0> johnw loves sequenceA =D
08:42:05 <johnw> sequenceA is really handy :)
08:42:05 <saulzar> ew0, Some of the things which can be generalised have been
08:43:25 <ski> now that `Applicative' is a superclass of `Monad' (assuming they agree), i suppose that `mapM' (or `sequence') isn't really needed anymore, using `traverse' (or `sequenceA') instead ..
08:43:54 <johnw> ew0: I also like the dual of this function: distribute :: (Functor g, Distributive g, Functor f) => f (g a) -> g (f a)
08:44:12 <mizu_no_oto> ew0: things should depend on the smallest typeclass they can.  If something can be written using Applicative, it shouldn't require a monad, any more than you should use Ord when all you require is just Eq.
08:44:14 <johnw> in which case, the inner 'f' really is only a functor
08:44:32 <ski> ew0 : iow, if `Applicative' had been there from when `Monad' was invented, `mapM' (or `mapA' ?) would have used `Applicative' from the start ..
08:44:46 <johnw> and when mizu_no_oto says smallest, some say weakest
08:44:46 <ski> ew0 : that said, there's still things `Applicative' can't do, but `Monad' can
08:44:59 <mizu_no_oto> johnw: that is a better term, yes
08:45:18 <johnw> being able to weaken a theorem is a happy day in mathematics :)
08:46:03 <ski> johnw : perhaps you mean, weakening its perconditions
08:46:06 <ew0> johnw,  do you have an example of use?
08:46:07 <ski> s/per/pre/
08:46:17 <johnw> ski: oh, yeah, that's just what I mean
08:46:17 <ski> ew0 : of `traverse' ?
08:46:44 <ew0> of distribute
08:47:05 <ew0> I've been schooled in traverse yesterday already
08:47:29 <johnw> ew0: distribute is a bit less commonly used, since it has much fewer instances
08:47:46 <johnw> but it can be handy, so it's good to know that it exists, and is the dual of sequenceA
08:47:56 <johnw> @hackage distributive
08:47:56 <lambdabot> http://hackage.haskell.org/package/distributive
08:48:17 <ski> (weakening the preconditions would strengthen the whole implication)
08:48:18 <johnw> although 'traverse' is much handier, I use 'sequenceA' in my thinking
08:48:31 <johnw> ski: right, thank you
08:49:08 <johnw> I mean simplifying the theorem until you can have a simpler statement that can prove the more complicated thing you were saying as a corollary
08:49:40 <ew0> what is meant by "dual"
08:49:42 <ew0> ?
08:49:55 <ski> turning stuff upside down
08:50:01 <johnw> dual is a term from category theory that means flipping the direction of function arrows in this context
08:50:20 <ew0> like zip and unzip
08:50:30 <johnw> nearly every construction in category theory has an "inverse", which you get by applying the exact same construction to the opposite category
08:50:58 <johnw> yes, zip and unzip are dual
08:51:15 <ew0> so most type classes in haskell come  straight from category theory? 
08:51:35 <ski> the dual of ⌜∧⌝ is ⌜∨⌝, the dual of ⌜∩⌝ is ⌜∪⌝
08:51:40 <johnw> by a somewhat windy road at times
08:51:45 <ski> ew0 : no, not really
08:51:53 <johnw> but yeah, not all
08:52:06 <ew0> yeah, probably Eq or Ord not
08:52:06 <johnw> anything by ekmett generally does :)
08:52:18 <ew0> but Functor, Traversable, Monad and stuff
08:52:19 <ski> `Eq',`Ord',the numeric ones,`Show',`Read',`Ix',`Enum' all doesn't
08:53:08 <ski> same with `Applicative',`MonadReader',`MonadWriter',...,`Foldable',`Traversable', ...
08:53:29 <johnw> um, Applicative does
08:53:47 <ew0> is there a book with this information?
08:53:49 <ski> `Applicative' and `Traversable' can be understood reasonably well categorically, though
08:54:11 <ew0> some book with most of these categories with lots of examples
08:54:26 <ew0> or just haskell
08:54:29 <ew0> "just"
08:54:33 <ski> johnw : afaiui, `Applicative' came from applications, and only after the fact was a categorical viewpoint sought
08:54:42 <johnw> ski: oh, you are talking about origins
08:54:49 <ski> ew0 : i suppose you've seen the Typeclassopedia ?
08:54:59 <Welkin> ew0: https://wiki.haskell.org/Typeclassopedia
08:55:04 <ski> (same with `Arrow', btw)
08:55:08 <Welkin> it's the best resource for learning about typeclasses
08:55:18 <ski> (though .. `Arrow' was at least initially inspired by CT)
08:55:57 <ew0> "When I asked how to do something I thought was really complicated, people started typing things like zip.ap fmap.(id &&& wtf) and the scary thing is that they worked! Anyway, I think those people must actually be robots because there’s no way anyone could come up with that in two seconds off the top of their head."
08:56:48 <johnw> id &&& wtf = first wtf
08:57:01 <johnw> oops, second wtf
08:57:13 <oconnore> Is there a more general Data.List.unfoldr defined on monoids? I want to build a monoid from a repeated sequence of IO operations until some property stops being true.
08:57:13 <ski> (oh, and `Monoid' comes from basic abstract algebra, not from CT)
08:57:18 <johnw> also, you may want zipWith
08:57:20 <ew0> "There is no royal road to Haskell. —Euclid"
08:57:25 <ew0> seems legit
08:57:46 <ski> @quote Euclid
08:57:46 <lambdabot> Igloo says: * shapr is desperately trying to grow a beard at this point... // <Igloo> You normally grow beards over partial non-Euclidean planes, not at points
08:57:52 <ski> hrm
08:57:54 <johnw> oconnore: you could always unfoldr to a list and compose this with foldMap
08:58:01 <johnw> oconnore: the temporary list should be fused away
08:58:21 * ski . o O ( "i swear it worked just a second ago !" )
08:58:49 <oconnore> johnw: but List.unfoldr won't actually evaluate the IO computations, so how will it terminate?
08:58:57 <shapr> ha
08:59:22 <johnw> oconnore: there are three flavors of unfoldM in http://hackage.haskell.org/package/monad-extras-0.5.9/docs/Control-Monad-Extra.html
09:00:22 <oconnore> johnw: cool, thanks :)
09:00:51 <Welkin> Control.Monad.Extra?
09:00:56 <Welkin> what kind of a name is that for a module?
09:01:04 <Welkin> that is like calling it Miscellaneous
09:01:09 <johnw> it's a collection of utility functions that Chris Done and I collected over the years
09:01:10 * ski likes how the docs say only "A monadic unfold."
09:01:23 <johnw> ski: I was trying to provide edwardk quality documentation! :)
09:02:42 <oconnore> Welkin: it sounds like the result of a general tendency to attempt to minimize module size at the expense of useful functionality
09:04:15 <Welkin> they they are useful, shouldn't they be included in Control.Monad?
09:04:42 <ski> the name `unfoldMapM' looks a bit strange, to me
09:04:46 <ew0> the typeclassopedia was what I was looking for
09:04:55 <ew0> together with stackoverflow
09:04:55 <Welkin> ew0: of course it was
09:05:01 <ew0> to look for examples
09:05:05 <ew0> =D
09:05:09 <oconnore> Welkin: I agree, I've just noticed that many haskell modules prefer to be minimal over being helpful
09:05:37 <hodapp> Hmmm... So, Ivory uses Template Haskell and a QuasiQuoter to parse some sort of minilanguage and turn it into data types & implementations. I wonder if I'd be able to just cut out that entire parsing step, and still get a nice type-safe implementation with sane error messages, and no quasiquotation required.
09:06:02 <f-a> if a package package-a.b.c.d is in a broken state because dependencies, and I release a new version, which works but has no API change, which number should I bump? d?
09:06:15 <Welkin> ew0: the best examples are in the source for the haskell libraries
09:06:38 <Welkin> ew0: look at the different implementations for type like Reader and State
09:06:45 <lezkus> hi all!
09:06:46 <saulzar> Welkin, if there're too many operations it can be a bit overwhelming - having the few key building blocks I think is easier to make sense of things..
09:07:00 <lezkus> I'm new and I'm having some problems making haddock work
09:07:17 <lezkus> even a sandbox
09:07:26 <lezkus> I'm using arch
09:08:18 <lezkus> I get a 
09:08:20 <lezkus> Warning: cannot determine version of /usr/local/bin/hpc : "" cabal: Error reading local package. Couldn't find .cabal file in: .
09:08:38 <lezkus> after running cabal install --only-dependencies after creating the sandbox
09:09:05 <crough> what's your cwd?
09:10:17 <lezkus>  this: /media/Gdrive/Documentos/4º Mat-Info/Programacion Declarativa/Práctica
09:10:46 <crough> Could you paste `ls`?
09:10:57 <lezkus> doc  add-source-timestamps  cabal.sandbox.config  cifrado.txt  diccionario.txt  pr.hs  quijote.txt  textoDescifrado
09:11:18 <crough> Looks like you haven't done `cabal init` yet
09:11:34 <lezkus> I've done cabal sandbox init
09:11:41 <crough> Yes, you need to do cabal init though
09:11:49 <crough> You have to create a project as well as a sandbox
09:12:03 <lezkus> oh, I see...
09:12:28 <crough> `cabal sandbox init && cabal init` (or reversed) is the typical process :)
09:12:39 <lezkus> thank you so much!
09:13:01 <crough> of course!
09:13:01 <lezkus> sorry for these stupid questions, I'm a complete noob when it comes to haskell ^^
09:13:32 <crough> yeah it's all good! You'll find the FP community in general is extremely accommodating :)
09:13:37 <crough> Welcome to Haskell!
09:13:49 <lezkus> thank you :D
09:14:32 * hackagebot old-version 0.1.0.0 - A general library for representation and manipulation of versions.  http://hackage.haskell.org/package/old-version-0.1.0.0 (chrisdotcode)
09:14:32 <bitemyapp> lezkus: just in terms of talk volume, AFAICT Haskell IRC is primarily a support network, secondarily a means for already-settled-in Haskellers to talk to each other.
09:14:53 <bitemyapp> lezkus: if people don't want to help you, they can just not reply, so there's absolutely no harm in asking questions :)
09:14:54 <crough> yeah, #haskell-beginners is closer to what you may want, lezkus (is that right?)
09:15:08 <bitemyapp> crough: lezkus - yeah it's more focused on helping new people exclusively.
09:15:26 <bitemyapp> lezkus: just be aware that it's not always possible to get an answer immediately in IRC...kinda asynchronous.
09:16:14 <crough> reddit.com/r/haskell tends to be pretty friendly as well if you don't want to wait for an answer
09:16:40 <lezkus> oh, I didn't know that that channel existed
09:16:45 <lezkus> I'll go there!
09:16:53 <lezkus> thank you all!
09:17:17 <crough> otlichno :)
09:18:22 <fizbin> I know I saw once someone using the technique of "type restricted typeclasses" where they had variations of Functor, Applicative, Traversable, etc, that were only allowed to wrap a specific type. Is that standardized and on hackage anywhere?
09:19:00 <crough> Do you mean monofunctors? I.e. `(a -> a) -> f a -> f a`
09:19:01 <johnw> hodapp: sure you could
09:19:31 <hodapp> guess then I just need to grok the output of their parser.
09:19:33 <johnw> hodapp: the free monad is another common way to build up model descriptions as ASTs, just as the quasi-quoter is doing.  It would just not be as C-like.
09:19:52 <fizbin> crough: Yeah, but I remember a whole mono* family of typeclasses: MonoFunctors, MonoTraversables, MonoApplicatives, etc.
09:20:00 <hodapp> johnw: I am not so much concerned about having it be C-like so much as just being a more concise description than what TH turns it into.
09:20:05 <johnw> fizbin: MonoFunctors are just (Elem f -> Elem f) -> f -> f
09:20:27 * ski thinks the prefix `Mono' there sounds strange ..
09:20:28 <crough> fizbin: I think all of those are in Data.MonoTraversable
09:20:30 <johnw> hodapp: that would be a great exercise then, and I'd actually be very interested in seeing your results
09:20:45 <johnw> hodapp: my workplace would be interested in seeing those results, even, since one of my co-workers created Ivory
09:20:57 <johnw> (or helped create it at least)
09:21:11 <hodapp> johnw: ah, yeah :)
09:22:01 <hodapp> johnw: I see some of why they did the quasiquoted format for expressing structs & BitData, but to me it's just a burden because they don't really document that quasiquoted language except by way of some examples, and it's still ambiguous where 'real' Haskell is allowed
09:22:10 <johnw> yep
09:22:30 <fragamus> rui: are you here
09:22:31 <hodapp> and when you put in something that's wrong, it's hard to figure out from the errors what
09:22:56 <johnw> the TH should just be a convenience layer over a more fundamental set of combinators
09:23:12 <hodapp> johnw: that's how I'd intend to use it, with what I'm describing - I think
09:23:37 <johnw> i'd be interested in helping out with design, if you wanted to e-mail me as you progress
09:24:08 <fizbin> crough: Yeah, okay. A MonoTraversable is what I have here. Thanks.
09:24:47 <crough> fizbin: of course
09:26:34 <johnw> I think what MonoFunctors do is just as easily expressed with a lens Traversal, like Traversal' ByteString Word8
09:26:51 <nshepperd> or a Lens
09:28:23 <johnw> Lens won't walk all the Word8s
09:28:34 <fizbin> Huh. A trivial example of where Monad can't be sensibly replaced with Applicative is any place you'd want to use mapM_
09:28:50 <nshepperd> oh that's right
09:28:53 <johnw> in fact, Lens would require a non-empty ByteString
09:28:57 <nshepperd> Setters are more like functors
09:29:01 <johnw> so you'd need a Prism to focus on the first or last
09:29:32 * hackagebot old-version 1.0.0.0 - Basic versioning library.  http://hackage.haskell.org/package/old-version-1.0.0.0 (chrisdotcode)
09:33:37 <small-wolf> what's the preferred way to combine regexes (say for lexing) with parsec?
09:34:15 <crough> I just would avoid regexes... they're really hard to read compared to just doing parsec on its own
09:34:32 * hackagebot old-version 1.0.1 - Basic versioning library.  http://hackage.haskell.org/package/old-version-1.0.1 (chrisdotcode)
09:34:33 <johnw> in fact, regex-applicative will let you construct regexs using parsec-style combinators
09:34:36 <crough> I know that's not the most helpful but
09:35:06 <johnw> a regex is really just a minimal parser construction language for text
09:35:25 <crough> I mean, yes, but it has the most perl-y syntax (aka write only)
09:36:32 <small-wolf> the terse syntax kind of the point for me at least. I'd like to be able to convert a string containing a regex into a parsec parser.
09:36:52 <johnw> small-wolf: that would be a great intermediate-level Haskell exercise, actually
09:37:05 <small-wolf> I will freely admit I am somewhat using this as a crutch since I find parsec confusing
09:37:25 <crough> small-wolf: there *is* already regex-parsec, but I've never used it
09:37:33 <johnw> mastering parsec is about mastering applicatives
09:37:35 <crough> It might output a parser?
09:41:28 <grayling_> Anyone here has experience with http-conduit?
09:42:53 <bitemyapp> grayling_: best to skip straight to the question
09:43:04 <bitemyapp> grayling_: if the answer to your question is no, then nobody can help you
09:43:20 <bitemyapp> grayling_: if the answer to your question is yes, then you could've just asked your question and gotten an answer
09:43:22 <fizbin> johnw: Incidentally, I think the full answer to my question earlier "Is there something less than Traversable that has something like traverse but requires f to be a Monad?" is "No; mapM requires Traversable, but mapM_ can be done with just Foldable"
09:43:34 <grayling_> bitemyapp: That seems logical. :-)
09:43:38 <bitemyapp> grayling_: so you're just delaying the inevitable (asking your real question) when you ask if people have used something before
09:43:41 <small-wolf> this is kind of a newb question, but when there's a package (like regex-parsec) that you're interested in, what's a good way to browse the stuff it exports
09:43:51 <grayling_> I can't for the life of me get cookies to work.
09:44:17 <bitemyapp> small-wolf: ordinarily, the hackage docs, but it has none.
09:44:24 <small-wolf> I'm interested in the types and documentation (implementation details I'm okay with not seeing right away).
09:44:24 <bitemyapp> small-wolf: I'd download it and render the haddocks, viewing them locally.
09:44:33 * hackagebot gll 0.2.0.2 - GLL parser with simple combinator interface  http://hackage.haskell.org/package/gll-0.2.0.2 (ltvanbinsbergen)
09:45:18 <grayling_> So I was wondering if anyone else has experienced the same issue. Cookies not being included in a POST.
09:46:25 <small-wolf> oh now I see what the problem is. I installed ghc and haddock through homebrew, but cabal through nix ... that's weird
09:46:58 <johnw> fizbin: ah, I didn't know that you didn't care about the final 'b'
09:47:07 <bitemyapp> grayling_: did you do a manual cookie jar like this? https://hackage.haskell.org/package/http-conduit-2.1.5/docs/Network-HTTP-Conduit.html
09:47:26 <bitemyapp> grayling_: or are you talking about persisting cookies obtained by other means across requests?
09:47:48 <fizbin> johnw: I have three uses of this. In two of them I don't care about the final "b".
09:48:11 <grayling_> I tried that first. Didn't work. Now I'm grapping the cookie from the previous request - which goes fine - but it's not not included in the next request.
09:48:42 <grayling_> https://github.com/hawkish/platescraping/blob/master/src/Tinglysning.hs
09:48:46 <grayling_> Code here...
09:50:15 <grayling_> Apart from the apparent noob approach to Maybe I can't find any glaring typos or anything obvious.
09:50:29 <grayling_> :-)
09:50:32 <breadmonster> grayling_: is that your code?
09:50:41 <grayling_> Yes it is.
09:51:50 <breadmonster> I'm trying to figure how to implement a quick trie.
09:52:12 <breadmonster> I'd rather not use a package, I need to insert a constant number of elements inside at compile time.
09:52:23 <breadmonster> And then run a fold on it.
09:52:28 <breadmonster> Basically to save boilerplate.
09:55:43 <grayling_> I tried using Wireshark to monitor the POST, but no cookie is present.
09:58:10 <athan> Hey guys, I'm going to make a type inference algorithm, but don't know what module I should list it under. I was thinking `Language.Prenex.Inference`, or `Language.HM.Inference`. Ideas?
09:59:42 <bitemyapp> athan: neither!
09:59:52 <bitemyapp> athan: give it a unique name, then put modules under that.
09:59:59 <bitemyapp> athan: http://hackage.haskell.org/package/pipes
10:00:35 <breadmonster> athan: What's this for?
10:00:41 <athan> bitemyapp: Well... but... I want it to be reusable :(
10:00:53 <bitemyapp> athan: it is reusable
10:00:55 <athan> breadmonster: ltext, but it could be generic, that's why I'm going to put it in it's own package
10:01:03 <athan> :|
10:01:27 <athan> I'm going with Language.Prenex >:D
10:02:24 <bitemyapp> athan: k lol
10:08:54 <hodapp> how long's it generally take for docs to be built on Hackage? 
10:09:13 <frerich> What is the benefit of hierarchical module names like Control.This or Data.That ? The names seem somewhat arbitrary and hence unpredictable, the only justification I could think of is to serve as a showcase for 'import qualified' :-}
10:09:38 <bitemyapp> hodapp: Hackage ate too much cheese, so it's backed up right now.
10:09:48 <hodapp> bitemyapp: ahh, okay.
10:09:49 <bitemyapp> hodapp: you could bug the package owners to upload haddocks manually.
10:10:40 <hodapp> bitemyapp: what should one expect otherwise - days? weeks?
10:11:31 <bitemyapp> hodapp: I really have no idea.
10:11:40 <bergmark> hours usually i think
10:12:09 <hodapp> hummmm. This package was uploaded about 24 hours ago and still is at "docs pending".
10:12:19 <bitemyapp> bergmark: it's been like this for days.
10:12:27 <bitemyapp> bergmark: it's on the status page.
10:12:35 <bergmark> yes now it's not usual
10:15:05 <frerich> hodapp: It differs, sometimes it's hours, sometimes it's days. To get a rough idea, you can check previous versions of some package and compare the 'Uploaded' timestamp against the 'Time submitted' stamp of the documentation build (which you get when clicking on the 'build log' link).
10:19:35 * hackagebot SDL 0.6.5.1 - Binding to libSDL  http://hackage.haskell.org/package/SDL-0.6.5.1 (fffaaa)
10:21:49 <rayqiu_> is there a parquet parser in Haskell?
10:27:24 <ion> @remember shachaf your comment on irc was enlightening. i never thought i would learn so much about this subject! very interesting. it's the sort of comment we see on my favorite irc channel, #enlargeyourmortgage. an excellent read, thanks again!
10:27:24 <lambdabot> Done.
10:27:26 <ion> (#haskell-lens)
10:34:35 * hackagebot SDL-gfx 0.6.0.1 - Binding to libSDL_gfx  http://hackage.haskell.org/package/SDL-gfx-0.6.0.1 (fffaaa)
10:39:07 <}> > runState (get >>= \(x:xs) -> return x) [1,2,3] -- is there a better way to do this? I can't use get or gets because the types don't match... even gets (head) doesn't seem to work
10:39:09 <lambdabot>  (1,[1,2,3])
10:40:34 <kadoban> :t get
10:40:35 <}> I mean if the type was State Int Int , all you need to do is get, but for a type of State [Int] Int there doesn't seem to be a nice function
10:40:36 <lambdabot> MonadState s m => m s
10:41:31 <kadoban> :t head <$> get -- this, } ?
10:41:32 <lambdabot> MonadState [b] f => f b
10:41:39 <}> kadoban, whoa
10:41:56 <frerich> }: 'runState (fmap head get) [1,2,3]' does the same.
10:42:07 <}> I feel dumb now
10:42:21 <}> I was trying gets (head) but its so much simpler
10:43:18 <ski> @type gets head
10:43:19 <ski> @type fmap head get
10:43:19 <lambdabot> MonadState [a] m => m a
10:43:21 <lambdabot> MonadState [b] f => f b
10:43:41 <ski> } : either should work
10:43:55 <}> but it didnt work when I tried... huh
10:44:40 <}> ohh
10:44:42 <frerich> I didn't even know 'gets' existed, I thought it was a typo!
10:44:51 <}> no theres gets and get
10:45:07 <}> I looked at my logs and it didnt work for a different reason... thanks guys
10:45:11 <frerich> Yeah, indeed, that's neat!
10:45:53 <ski> } : btw, you're aware of `monad-supply' ?
10:46:15 <ski> @type gets
10:46:16 <lambdabot> MonadState s m => (s -> a) -> m a
10:46:27 <}> ski, No, I haven't done any haskell since 2013, so I'm effectively starting all over
10:46:58 <}> It's pretty difficult right now...
10:47:14 <ski> `forall a. (s -> a) -> m a' is basically `Yoneda m s', which is equivalent to just `m s', since `m' is in `Functor'
10:47:20 <ski> @type get
10:47:21 <lambdabot> MonadState s m => m s
10:47:34 <ski> @hackage monad-supply
10:47:34 <lambdabot> http://hackage.haskell.org/package/monad-supply
10:48:06 <ski> } : ^ possibly not what you wanted here. just thought it looked a bit suspicious
10:48:49 <}> hmm
10:49:36 * hackagebot SDL-image 0.6.1.1 - Binding to libSDL_image  http://hackage.haskell.org/package/SDL-image-0.6.1.1 (fffaaa)
10:49:57 <}> I think I will need that later on, thanks ski 
10:50:03 <ski> np
10:50:51 <kadoban> That's kinda neat. So it's like a State but you can only take out values
10:52:25 <ski> note that it'll use `fail' in the underlying monad on exhasted supply
10:53:25 <kadoban> Yeah I was kinda wondering what happened in that case. That's fugly, but then … I dunno what else it could really do.
10:54:00 <ski> using `MonadPlus' (or a `MonadZero') might be nicer
10:54:29 <lamefun> Can I make a type that can't be constructed outside a module, but can still be pattern-matched?
10:54:36 * hackagebot SDL-mixer 0.6.1.1 - Binding to libSDL_mixer  http://hackage.haskell.org/package/SDL-mixer-0.6.1.1 (fffaaa)
10:55:07 <ski> lamefun : unfortunately, no. apart from not exporting the data constructor(s) at all, only exporting "view" functions
10:55:16 <ski> (OCaml has this thing, otoh)
10:55:19 <arkeet> coudln't you export pattern synonyms?
10:55:32 <ski> hm, could work
10:58:10 <ski> lamefun : hm, yes. see "unidirectional pattern synonyms" at <http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#pattern-synonyms>
10:58:41 * ski apparently forgot that there was that separate kind of them
11:00:09 <albeit> Is there a way to use criterion with setup/teardown functions that are called before/after every test, and that aren't included in the stats?
11:04:31 <}> I realized I can also do gets (snd) like I did gets (head)... so I simplified the State Monad example from the wiki http://termbin.com/8w2z :-D
11:04:37 * hackagebot SDL-ttf 0.6.2.1 - Binding to libSDL_ttf  http://hackage.haskell.org/package/SDL-ttf-0.6.2.1 (fffaaa)
11:10:50 <ski> } : really, just `gets head' and `gets snd' should do it
11:11:24 <}> ah, I don't need the ()? the syntax is a bit confusing because sometimes omitting () gives me enormous compile errors
11:11:30 <timothyh> nice nick
11:11:45 <}> thanks
11:13:13 <ski> } : (round) brackets are used for grouping (and for tuples). they're not used for function calls
11:13:14 <kadoban> I don't think you /ever/ need (blah) unless blah is some compound thing.
11:13:56 <ski> (.. oh, and sections as well, i suppose)
11:14:49 <geekosaur> }, you are probably used to f(x, g(y, z), v) or similar.
11:14:56 <geekosaur> that would be f x (g y z) v
11:15:18 <geekosaur> and if used in a larger expression might itself need to be parenthesized: (f x (g y z) v)
11:15:54 <}> I think you also need it for pattern matching, I had to do test (Node (x:xs)) earlier, test (Node x:xs)  gave compile errors
11:16:08 <geekosaur> also note that passing functions by themselves is perfectly sensible in a functional programming language, so it doesn't "know" that (f map g x) you intended to be (f (map g x))
11:16:43 <geekosaur> }, yes, because patterns follow the same rules as expressions
11:19:38 * hackagebot mida 0.4.3 - Language for algorithmic generation of MIDI files  http://hackage.haskell.org/package/mida-0.4.3 (mrkkrp)
11:29:02 <pmade> Is there a State monad where you can return to the original state?
11:29:51 <ski> } : you don't need it specifically for pattern-matching (e.g. `case blah of x:xs -> ...' is just fine). however, if you write `test (Node x:xs)', it'll be interpreted as `test ((Node x):xs)', and if you write `test x:xs', it'll be interpreted as `(test x):xs'
11:30:18 <Cale> pmade: Something like https://wiki.haskell.org/New_monads/MonadUndo ?
11:30:39 <nullx002> what is a Monad?
11:30:44 <}> geekosaur, ski,  why do you need the () around expressions like this? print $ (\(a,b) -> a + b^2) <$> [(1, 2), (5,10)] , it won't work if I remove () around the lambda 
11:30:56 <ski> } : function application binds tighter than any other infix operator (the `@' syntax in patterns could be said to be an exception, though it's not really a normal infix operator)
11:31:09 <Welkin> nullx002: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
11:31:23 <geekosaur> }, because it doesn't know you intended the lambda to end at <$>
11:31:30 <Cale> nullx002: A monad is a type constructor M together with functions return :: a -> M a, and (>>=) :: M a -> (a -> M b) -> M b satisfying some laws.
11:31:30 <}> ah
11:31:36 <geekosaur> neither $ nor <$> is syntax; they're siimple operators
11:31:45 <hexagoxel> would always deprecating every package version but the latest be a bad idea?
11:32:05 <geekosaur> so it doesn't have any idea that it should treat <$> differently from + or ^ there
11:32:07 <hexagoxel> (presuming one keeps the latest version backward-compatible)
11:32:12 <}> yeah I get it now
11:32:37 <Welkin> hexagoxel: yes
11:32:39 <ski> } : function abstraction body extends as far as possible to the right. `print $ \(a,b) -> a + b^2 <$> [(1, 2), (5,10)]' is interpreted as `print $ (\(a,b) -> ((a + (b^2)) <$> [(1, 2), (5,10)]))'
11:32:40 <Cale> nullx002: In particular, that return v >>= f = f v, that x >>= return = x, and that x >>= f >>= g = x >>= (\v -> f v >>= g)
11:32:44 <pmade> Cale: That looks good, but I don't need to remember all the intermediate states.
11:33:06 <}> thanks again guys
11:33:31 <ski> yw
11:34:02 <Cale> nullx002: While it might seem a bit odd at first, this pattern shows up in a lot of libraries
11:34:31 <Cale> nullx002: and by abstracting over it, we can write some code once and then use it with all the libraries in which this pattern occurs
11:36:12 <hexagoxel> Welkin: why?
11:37:02 <Welkin> hexagoxel: there will always be programs that use the old packages
11:37:26 <Cale> nullx002: Generally the idea is that M t is some type of "computations whose result has type t when they are executed"
11:38:06 <Cale> nullx002: and that when v :: t, then return v :: M t  is the computation which "does nothing except produce v as its result"
11:38:35 <Cale> nullx002: and x >>= f is then the computation which when executed, first executes x, obtaining some result v, and then executes f v
11:38:38 <hexagoxel> Welkin: i do not see the issue
11:40:13 <Cale> For example, the computations might be parsers, they might be IO actions, they might be lists (where "executing" a list means selecting an element from it), they might be some sort of memory transactions, and so on.
11:42:16 <hexagoxel> Welkin: was this discussed somewhere before? i have searched mailing list archives without luck, would be happy about pointers
11:44:06 <ion> Interesting, supply calls fail if it runs out but peek crashes (it's gets head).
11:45:35 <xplat> is there a lower level alternative to the 'unix' package, like 'gl' is for 'opengl'?
11:46:14 <Welkin> xplat: I'm not familiar with it
11:46:15 <hexagoxel> Welkin: as i understand it, you can still install deprecated versions; only the resolver prefers non-deprecated versions. i am not sure/have not tested how much weight the deprecation is given when resolving
11:47:42 <bam365> :q
11:47:43 <Tommalla> Hi everyone. Is there a way to send a file to stdin for main execution inside ghci? I need to debug some exception and so I need to run the code in ghci, but I cannot find the way to input the file.
11:47:47 <Welkin> hexagoxel: I think this is better answered by someone who maintains packages
11:48:11 <Welkin> I don't know any more than you do about it
11:49:05 <Welkin> Tommalla: yes
11:49:23 <Welkin> you can also use `runhaskell programName inputFile`
11:50:42 <Tommalla> Welkin: But that won't give me trace.
11:50:59 <Tommalla> I need to run it interactively inside ghci, if I understand correctly.
11:51:11 <c_wraith> Tommalla: why not just :load it in ghci?  you can run main afterwards
11:51:26 <c_wraith> Tommalla: you can even load it on the command line
11:54:39 * hackagebot banwords 0.2.0.0 - Generalized word blacklister  http://hackage.haskell.org/package/banwords-0.2.0.0 (fanjam)
11:57:56 <Tommalla> c_wraith: How do I use :load to load the input file as stdin? I don't mean code, I mean data.
11:58:21 <Tommalla> I'd normally just do runhaskell code.hs < input.txt
11:58:39 <Tommalla> But that way I don't see any context of the exception which I need to debug.
11:58:41 <c_wraith> Oh.  Why not just ghci input.txt ?
11:58:57 <c_wraith> Why the obsession with stdin?
11:59:23 <Tommalla> c_wraith: It's a language interpreter...
11:59:28 <Tommalla> I mean what I am writing
11:59:36 <Tommalla> It reads the code from stdin
11:59:42 <c_wraith> ah
11:59:43 <}> c_wraith, I don't think running ghci on a data file makes sense...
12:00:58 <c_wraith> Tommalla: I'm not sure you can.  Best to solve it the normal way - make your interpreter pure so you can load your code and the data in ghci, then test the pure interpreter on the pure data.
12:01:09 <Tommalla> Maybe there's some other way to see more info on the exception? I've tried -xc cabal flag, but with no luck. 
12:01:32 <c_wraith> oh.  -xc is an rts flag, not a cabal flag
12:01:59 <Tommalla> Sorry, still quite new to haskell binaries and cabal.
12:06:01 <leonepavone> n00b question: if haskell creates a new object every time a key-value pair is added to a map, what are the efficiency costs vs something like c++, which doesn't call a map constructor every time a k,v are added?
12:09:01 <Hijiri> leonepavone: map is implemented as a tree, so you can reuse most of the map in the new map, and you end up with O(log n) update
12:09:40 * hackagebot generic-accessors 0.2.0 - stringly-named getters for generic data  http://hackage.haskell.org/package/generic-accessors-0.2.0 (GregHorn)
12:09:45 <Hijiri> A tree (not Map specifically) would have a shape sort of like  data Tree a = Tree (Tree a) a (Tree a)
12:10:17 <Hijiri> If you have to insert into the tree, you would change either the first (Tree a), the middle element, or the second subtree
12:10:30 <Hijiri> If you insert into one of the trees, you can reuse the unchanged tree
12:10:38 <Hijiri> if you change the element you save both trees
12:10:46 <Hijiri> (also I omitted a Leaf constructor)
12:11:38 <Hijiri> GHC (and all other serious haskell implementations?) implement the members of some constructor with pointers
12:11:55 <Hijiri> so you don't really recreate the parts of the tree that you don't change, only the parts you do change
12:12:09 <Hijiri> In a tree update, this ends up being every node on the path from the root to the location you are inserting
12:12:54 <Hijiri> For a nicely-balanced tree with n nodes, that will be updating about log_2 n nodes in the worst case
12:13:30 <Hijiri> Map is implemented as a red-black tree I think, so that is balanced well-enough for that
12:13:53 <abhips> Help needed for this question http://stackoverflow.com/questions/30611005/haskell-scotty-low-throughput-in-network-i-o
12:14:08 <hexagoxel> leonepavone: the term "constructor" seems to be misleading; in c++ it can contain arbitrary code, while in haskell it is much simpler
12:14:53 <hexagoxel> leonepavone: i would rather ask: is it necessary to make allocations on the heap? or: how many instructions are executed for an insert?
12:15:35 <hexagoxel> and i think the answer to the first question is yes for both languages.
12:15:36 <leonepavone> thanks Hijiri and hexagoxel -- point taken in clarifying the question
12:15:56 <hexagoxel> leonepavone: :)
12:16:44 <dedgrant> Hijiri: As a point of interest, most relevant C++ std::map implementations are also red-black trees.. same algorithmic complexity.
12:16:48 <athan> Why can't I install integer-gmp on 7.10? :s
12:18:34 <athan> It's a really weird cabal hell: http://lpaste.net/133877
12:18:39 <athan> (yes I'm in a sandbox)
12:20:01 <dcoutts> athan: did you already add integer-gmp-0.5 to your sandbox?
12:20:15 <dcoutts> athan: or do you have a cabal.config from using cabal freeze?
12:21:07 <dcoutts> athan: looks like you have a constraint, e.g. from a cabal.config file that requires integer-gmp-0.5.1.0
12:21:19 <dcoutts> and so that's then inconsistent with asking to install 1.0.0.0
12:21:46 <athan> dcoutts: Ahh I think you're right, I'm trying to install hl - the hackage.org website. Should i just clear the freeze?
12:22:00 <dcoutts> athan: yes, or drop that one constraint
12:22:33 <Tommalla> Do you guys know any good way of understanding why a haskell program might loop (with <<loop>> as output)?
12:22:38 <athan> thank you dcoutts
12:23:01 <geekosaur> usually means that you have something that depends on itself
12:23:11 <geekosaur> > let x = x + 1 in x
12:23:12 <nullx002> what amount of category theory do i need to know to understand monads and functors in haskell?
12:23:15 <lambdabot>  mueval-core: Time limit exceeded
12:23:25 <athan> nullx002: Not much, but it does help
12:23:25 <Geraldus> Hi folks!
12:23:28 <geekosaur> hm ghci doesn't blackhole that
12:23:34 <athan> nullx002: What do you understand so far?
12:23:49 <nullx002> just a few articles and wiki pages
12:24:11 <athan> nullx002: Well, okay
12:24:15 <athan> think of it this way
12:24:16 <nullx002> functions and relations. etc. form f A to b and b to c for sert a to c 
12:25:05 <athan> functions are relations from one concrete type A to another B: A -> B
12:25:22 <nullx002> yhes that i understood well
12:25:36 <mizu_no_oto> nullx002:  You need to understand category theory to work with monads and functors like you need to understand rings to do basic arithmetic
12:25:42 <Geraldus> I have issue with `easy-mmode-defmap`: the keybindings does not work, failing with errors (wrong-type-argument commandp (function quit-window)). Here is the code https://github.com/haskell/haskell-mode/blob/master/haskell-presentation-mode.el#L45-L49. Both functions are interactive. 
12:25:43 <athan> nullx002: functors are parametric types. If I have a functor F :: * -> *, and a concrete type A :: *, then F A :: *
12:25:48 <athan> (is also concrete)
12:25:54 <Tommalla> geekosaur: I know, but it's probably more complex here. It 'loops' when I check if a Maybe sth isNothing. Maybe comes from a map lookup.
12:25:56 <athan> it's something like a type-level mapping
12:26:47 <geekosaur> so the thing in the map is computed lazily when you check it. might make whatever adds it to the map strict
12:26:49 <athan> nullx002: Now, a monad, technically is an _endofunctor_ (a functor which can be wrapped many times, like `F (F (F (F A)))`
12:26:58 <Geraldus> ooops, I've picked wrong room again (:
12:26:58 <nullx002> ok, so little bit of additional knowledge may help if i am doing some work with AI or math related programs
12:26:59 <geekosaur> insert myMap $! value -- starting point
12:27:23 <athan> nullx002: Except it's also a _monoid_ - having some tooling to fuse two of the layers: `join` is the monoid operator
12:27:37 <athan> nullx002: `join :: F (F A) -> F A`
12:27:56 <mizu_no_oto> athan, null002: an endofunctor is a functor that maps a category to itself
12:28:07 <mizu_no_oto> nullx002, rather
12:28:09 <athan> nullx002: So in essence, monads are like meta-burritos that can internally fuse
12:28:55 <Atlanis> goddammit athan. not only is the burrito metaphor beaten to death, it's also making me hungry
12:28:58 <athan> nullx002: Yeah, I really suggest toying in ghci with `(>>=)`, `(>=>)`, `join`, and others
12:29:10 * hexagoxel wonders how coburritos taste
12:29:38 <liste> are they burritos with stuffing on the outside?
12:29:45 <stelleg> is there some way to do type level lambdas? e.g. instance Functor (\x -> MyEither x Beer) where ...
12:30:26 <Tommalla> geekosaur: O-M-G
12:30:30 <Tommalla> Thank you...
12:30:31 <athan> liste: No, that's a comonad!
12:30:43 <Tommalla> let penv = insert ident (someval) penv
12:31:01 <Tommalla> wouldn't have found that without unlazying it, thank you
12:31:04 <athan> liste: It will always be a burritto with stuffing, but you can magically erase inner-tortillas with `join`
12:31:15 <mizu_no_oto> athan, nullx002: Also, monads are *monoid objects*, which are distinct from abstract algebra monoids.  (AA) monoids are one particular example of a monoid object
12:31:37 <athan> mizu_no_oto: Hmm, thank you :) I'll look into that
12:32:36 <mizu_no_oto> conventional monoids (i.e. what you see in Data.Monoid) are monoid objects in the monoidal category Set under cartesian product
12:33:04 <mizu_no_oto> athan: monads are monad objects in the monoidal category of endofunctors under function composition
12:33:17 <mizu_no_oto> *monoid objects, not monad objects
12:33:27 <athan> hmm!!
12:33:42 <athan> that is really clarvoiant
12:34:25 <mizu_no_oto> athan: IIRC, applicatives are monoid objects in the monoidal category of endofunctors under Day convolution
12:34:27 <athan> thank you mizu_no_oto
12:34:32 <athan> AHHHHH
12:34:42 <athan> mizu_no_oto: I've been wondering
12:34:49 <albeit> When heap profiling, what is the "SYSTEM" module / "PINNED" cost center?
12:35:56 <mizu_no_oto> see http://www.reddit.com/r/haskell/comments/2lompe/where_do_the_applicative_laws_come_from/ for edwardk's explanation
12:36:10 <athan> *bookmarks* :)
12:37:08 <liste> it all makes sense now (: awesome
12:37:31 <mizu_no_oto> nullx002: at any rate, understanding CT itself helps more with finding new, related abstractions more so than understanding the ones already used
12:38:10 <mizu_no_oto> much like how understanding ring theory isn't going to help understand arithmetic, but it might help you understand and find new examples of rings
12:39:41 * hackagebot Plot-ho-matic 0.5.0.5 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.5.0.5 (GregHorn)
12:39:54 <mizu_no_oto> nullx002: also, beware the monad tutorial fallacy - https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
12:41:43 <mizu_no_oto> learn the definition + some examples, and some intuition should begin to appear.  "burritos in the category of pink fluffy things" doesn't really lead to understanding.
12:41:50 <gilberto> Where do i start learning ?
12:42:28 <Haskellfant> @where learnhaskell
12:42:28 <lambdabot> https://github.com/bitemyapp/learnhaskell
12:42:52 <nullx002> yhes mizu, i play chess for 15 years now so abstraction and pattern recogniztion is not new to me
12:42:57 <Haskellfant> I personally liked @where lyuah but there are quite a few people who disagree
12:43:02 <Haskellfant> @where lyuah
12:43:03 <lambdabot> I know nothing about lyuah.
12:43:06 <Haskellfant> @where lyah
12:43:06 <lambdabot> http://www.learnyouahaskell.com/
12:44:41 * hackagebot singletons 1.1.2.1 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-1.1.2.1 (RichardEisenberg)
12:45:36 <dgpratt> well darn
12:45:53 <dgpratt> I bumped into a weird build error trying to build snap
12:46:34 <dgpratt> I suspect that since the environment is Windows+minghc+sandbox, I'm on my own
12:46:52 <dgpratt> but in case someone thinks they might be able to help http://lpaste.net/4310317225648062464
12:47:24 <dgpratt> line 222 seems to be the failure point
13:13:40 <hodapp> Is there some way to make something like 'instance Foo a => Bar a where...' work, short of using UndecidableInstances? 
13:14:59 <hodapp> I'm running into cases where I'm having to write a bunch of boilerplate where all of the definitions are just the same thing from 'Foo'
13:16:59 <lyxia> hodapp: Do you mean, every Foo is a Bar, but you also have Bars that are not Foos?
13:17:43 <oconnore> is it possible to do something like module My.Module ( module My.Module, module My.Other.Module hiding (symbol) )  where ...
13:18:08 <lyxia> hodapp: In which case "class Bar a => Foo a" seems more adequate.
13:18:39 <geekosaur> oconnore, no
13:19:12 <hodapp> lyxia: 'Foo' is not a typeclass I'm at the liberty of defining here.
13:19:22 <oconnore> geekosaur: ok :/
13:19:26 <lyxia> hodapp: I see :/
13:19:47 <hodapp> lyxia: every type that is an instance of Foo is also an instance of Bar, but instances of Bar exist that are not instances of Foo.
13:20:53 <oconnore> I think this is the first time I miss common lisp, and for all the possible things... the package system...
13:22:47 * hodapp dumps a bucket of parentheses on oconnore's lap
13:23:16 <lyxia> hodapp: That's the same problem as Applicative not being a superclass of Monad pre 7.10
13:29:43 * hackagebot phash 0.0.4 - Haskell bindings to pHash, the open source perceptual hash library  http://hackage.haskell.org/package/phash-0.0.4 (MichaelXavier)
13:32:34 <lyxia> hodapp: Perhaps, if UndecidableInstances is too expensive, you can use a newtype FooBar a, and define instance Foo a => Bar (FooBar a) ?
13:33:59 <lyxia> Is that undecidable instances actually?
13:34:33 <hodapp> hmm, not sure
13:39:44 * hackagebot JuicyPixels 3.2.5.2 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.2.5.2 (VincentBerthoux)
13:40:17 <lyxia> hodapp: So, it is! And here is an old blog post that gives the same solution https://lukepalmer.wordpress.com/2008/04/08/stop-using-undecidable-instances/
13:42:00 <meoblast001> a bit of a snap / acid-state question
13:42:07 <meoblast001> https://github.com/mightybyte/snaplet-acid-state/blob/master/examples/Site.hs#L54
13:42:19 <meoblast001> would i need to have a different member for every single acidic type?
13:42:23 <hodapp> lyxia: thanks!
13:42:26 <meoblast001> and then initialise every single one of those?
13:43:54 <meoblast001> or could i really just create one type called Database and then have stuff inside of that?
13:44:00 <meoblast001> hmmm
13:47:34 <Tommalla> https://dpaste.de/coCq Any ideas?
13:48:59 <rasen> Tommalla: wrong chat?
13:49:31 <Tommalla> rasen: Yeah, sorry
13:50:36 <rasen> Tommalla: anyway, seems like kde-apps-meta is not compatible with installed packages. What's kde-apps-meta at all?
13:51:21 <geekosaur> metapackage for KDE userland apps, looks like
13:51:38 <rasen> I don't see it in portage
13:52:16 <rasen> zugaina fails too
13:52:52 <rasen> oh.. found in kde overlay
13:53:58 <Tommalla> LOL. In #haskell chat, gentoo guys all around.. Well, what did I expect? :D
13:54:04 <geekosaur> guessing kde from base, but you need one from the overlay
13:54:26 <geekosaur> (no, I'm not a gentoo user, but have seen this kind of thing in other contexts, notably xmonad vs. the haskell overlay vs. base)
13:54:27 <Tommalla> rasen: yup, that's kde overlay
13:55:20 <ttt_fff> are any of the FRP libraries on hackage readable? I want something that's like literate haskell, where I can read the source and (1) understand how FRP works and (2) how it's implemented in practice
13:57:50 <ocharles_> ttt_fff: implementation in practice requires a lot of trickery
13:58:03 <ttt_fff> oh, and I only care about discrete FRP
13:58:07 <ttt_fff> I don't need continuous FRP
13:58:07 <frerich> Given a type 'data List a = Empty | Cons a (List a)', a catamorphism would have the type 'b -> (a -> b -> b) -> List a -> b'. The catamorphism would have the same type for e.g. 'data List a = Empty | Cons a (List (List a))' right? I.e. the 'List' applications are replaced recursively?
13:58:08 <ocharles_> ttt_fff: I would recommend reading conal's papers for both
13:58:19 <ocharles_> if you just want discrete then maybe look into 'auto'
13:58:24 <ttt_fff> ocharles_: I have enjoyed your 24 days of ahckage series. Thanks for writing them! I learned about opaleye + some other libraries from your blog posts.
13:58:35 <ocharles_> thanks, glad they have been useful!
13:59:16 <ttt_fff> they're very well written, I like the philosophy of "here's a minimal example of something useful" rather than the typical doc-approach of "let me tell you why this system is awesome" -- very easy to cherry pick what I wnated to use / didn't care about
13:59:53 <osa1> is anyone here familiar with the deforestation algorithm? hoping to ask some questions to someone who knows it well. (confused about one thing in the paper)
14:00:55 <rasen> frerich: I think so. Actually, it depends on how you implement it
14:08:33 <ocharles_> ttt_fff: indeed, that is the approach I enjoy and like to share with people. if people can be convinced in a small example, then they are generally willing to do the work and learn the rest themselves
14:08:37 <ocharles_> some of us just need a hand at the start :)
14:11:18 <Raydiation> whats the best way to return the first non 0 element of an array
14:11:24 <Raydiation> list*
14:14:20 <frerich> Raydiation: I'd try 'listToMaybe . take 1 . dropWhile (== 0)' which gives you a 'Just' value with the first non-zero value, or 'Nothing' if there is no such value (e.g. empty list, or list consists of all zeroes)
14:15:01 <Raydiation> yeah, thought that the solution is probably not too trivial :/
14:15:26 <Raydiation> ty
14:15:57 <frerich> Raydiation: Ah, I just realized that 'find' would work as well, i.e. 'find (/= 0)'
14:16:19 <frerich> I just can't make a habit of checking Data.List *first*.
14:17:50 <Raydiation> ty
14:24:49 <lyxia> It looks like listToMaybe already just takes the head of any non-empty list.
14:27:45 <frerich> lyxia: True! The 'take 1' is unneeded.
14:29:44 <frerich> Does anyone know of a good way to unit-test a template haskell function? I'd like to verify that the expected code is correct. For a start, if I could check the type of a function being generated that would be a good improvement already.
14:30:00 * frerich guesses checking the actual code may be tricky since variable names are created somewhat randomly.
14:30:53 <tejing1> what do you call it when in a polymorphic type, one type parameter is determined by another?
14:32:31 <rasen> tejing1: type families or what?
14:33:09 <rasen> tejing1: don't quite understand the question. any example?
14:34:08 <tejing1> I think the phrase I was looking for was functional dependencies, but that's not quite what I wanted after all :-/
14:36:09 <geekosaur> fundeps and type families are both ways to do that
14:42:10 <c_wraith> should GHC have a mechanism for specifying dependencies between types outside of instance resolution?
14:42:12 <Lokathor> so is the identity function (or aliases of it) the only possible a -> a function in haskell?
14:42:24 <c_wraith> Lokathor: it's the only possible total function of that type
14:42:43 <merijn> There's 3 possible values of "a -> a"
14:42:45 <c_wraith> Lokathor: there are two other values with that type that can be distinguished in haskell.  (thanks seq!)
14:42:54 <merijn> "undefined", "\x -> undefined" and "\x -> x"
14:43:23 <Lokathor> aren't the first two of those actually the same thing?
14:43:27 <c_wraith> nope
14:43:36 <c_wraith> > seq (undefined :: a -> a) ()
14:43:37 <lambdabot>  *Exception: Prelude.undefined
14:43:54 <c_wraith> > seq ((\x -> undefined) :: a -> a) ()
14:43:56 <lambdabot>  ()
14:44:10 <Lokathor> ahhh
14:44:45 <Lokathor> so they're both going to crash a program, but because of lazyness they do it slightly differently
14:44:53 <Lokathor> ?
14:45:12 <c_wraith> they may or may not crash a program, depending on how necessary it is to evaluate them
14:45:33 <Lokathor> right, assuming you have to go evaluate them
14:45:44 <c_wraith> Also depending on whether you catch the exception. :)
14:46:02 <Lokathor> seq and pattern matching are what force evaluation, right?
14:46:06 <c_wraith> yes
14:46:14 <Lokathor> do other things?
14:46:25 <c_wraith> pseq, if you want to be pedantic
14:46:29 <hpc> IO execution, in order to get the ball rolling
14:46:42 <c_wraith> Also, IO and various other FFI stuff
14:46:57 <Lokathor> hmm
14:47:43 <c_wraith> I suppose ST forces evaluation just as much as IO that's not using primops or FFI calls. >_>
14:48:01 <dmj`> bitemyapp: ping
15:03:15 <albeit> When I specify a cost center to heap profile, like "-hcA", what is A? Is it the string listed under "COST_CENTER" in the prof file? Or the no.? Or something else?
15:05:48 <ansible1> ok I'm using ghc 7.4, how do I tell which version of Data.Map I have?  
15:06:47 <hexagoxel> are the arguments in the package-upper-bounds-or-not discussion summarized anywhere?
15:08:20 <Clint> ansible1: ghc-pkg list containers
15:08:51 <ansible1> thx Clint
15:16:03 <ion> Why are you using 7.4, btw?
15:22:39 <bitemyapp> dmj`: ?
15:23:04 <dmj`> bitemyapp: check pm
15:23:14 <bitemyapp> dmj`: am now - I don't ever log out of IRC
15:23:21 <bitemyapp> dmj`: unless my server goes down, so in this case, I was driving home.
15:23:31 <bitemyapp> persistent GNU Screen session. I always catch up eventually :)
15:37:16 <Apocalisp> So, I'd expect the following to hold for Monad that is also Traversable: sequenceA . return = fmap return
15:37:36 <Apocalisp> But I'm not sure I can get there from the laws for monads and traversables
15:44:54 <bitemyapp> Apocalisp: don't think you need Monad here
15:45:32 <bitemyapp> Apocalisp: http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Traversable.html
15:45:58 <bitemyapp> Apocalisp: the laws for sequenceA seem like a fruitful place to start.
15:48:57 <Apocalisp> bitemyapp: That's where I've started :)
15:49:16 <bitemyapp> Apocalisp: I figured I was stating the obvious and felt a bit of a git, but wanted to be sure.
15:49:48 <acowley> I blame #haskell for encouraging me to open that GHC ticket. Never again.
15:49:51 <bitemyapp> Apocalisp: may I ping you in query?
15:49:55 <bitemyapp> acowley: hahahahaha
15:49:57 <acowley> It's just not worth it.
15:49:59 <bitemyapp> acowley: it's a syntax proposal.
15:50:07 <bitemyapp> acowley: you have to make your proposals spooky and mysterious.
15:50:13 <bitemyapp> maybe even a little ooky
15:50:15 <acowley> Yeah, I know. But I thought this time... this time! ... it was a slam dunk
15:50:31 <acowley> 100% backwards compatibility! Less syntax for those who take advantage!
15:50:46 <bitemyapp> acowley: you'd think types would be a slam dunk too
15:50:49 <Apocalisp> well, so from those laws I can derive the pentagon and triangle for a distributive law from one monad to another. Check. I can derive the pentagon for the distributive law from a monad to an endofunctor, but the triangle (above) remains elusive.
15:50:52 <bitemyapp> acowley: yet here we are :)
15:51:16 <Apocalisp> bitemyapp: Yeah, ping me in query if you want!
15:51:22 <bitemyapp> Apocalisp: doing it for the joy or is this something you could slam out in Coq?
15:51:22 <acowley> bytemyapp: types aren't backwards compatibile with the code some people want to write :(
15:51:34 <bitemyapp> acowley: I don't consider backward compatibility with broken code a plus.
15:51:42 <acowley> Somebody somewhere does
15:51:49 <acowley> I've come to accept that
15:51:49 <bitemyapp> welp
15:52:04 <acowley> Because by "somebody somewhere" I really mean most programmers :(
15:52:45 <acowley> I don't know how the people who worked on the markdown patch for hackage had the patience to persevere with that.
15:55:45 <bitemyapp> acowley: saints.
15:56:37 <acowley> bitemyapp: Basically, yeah. I loved how some people were taken aback at Michael's exasperation towards the end.
15:57:42 <bitemyapp> acowley: following Michael on Github was an eye-opening experience
15:58:01 <bitemyapp> "wtf is he a man-octopus with 8 arms and 8 brains?"
15:58:10 <acowley> If he doesn't burn something down at some point I'd be disappointed
15:58:44 <bitemyapp> hahahahaha
15:58:57 <ritemeow> are there any programming positions that will allow people to take time off whenever they want?
15:59:29 <pacak> ritemeow: Yes
15:59:50 * hackagebot wai-cors 0.2.3 - CORS for WAI  http://hackage.haskell.org/package/wai-cors-0.2.3 (larsk)
15:59:52 <acowley> I actually find that I disagree with him on most Haskell issues, but I'm so thankful for his efforts at kicking the sleeping core of our galaxy.
16:00:55 <ritemeow> i want to work as a software developer and when i get acting gigs i would like to have the ability of being able to take a few days off to be in the film
16:01:04 <ritemeow> is it at all possible while working for a company?
16:01:32 <bitemyapp> acowley: I wonder if nice tools can induce complacency in other areas and vice versa?
16:01:34 <dfeuer> ritemeow, that seems pretty far off topic for this channel. Try #haskell-blah.
16:01:37 <Apocalisp> bitemyapp: Purely for the joy, but I also make a claim in my book that (Monad m, Monad n, Traverse n) => (Monad (Compose m n))
16:01:55 <bitemyapp> I suppose having a proof would be good, yes :)
16:01:58 <Apocalisp> :)
16:02:06 <Apocalisp> I have everything except this last triangle
16:02:24 <Apocalisp> I'm inclined to say that I can pick any monad for my `return` here.
16:02:35 <dfeuer> Apocalisp, that's crazy.
16:02:43 <dfeuer> But  what's Traverse?
16:02:50 <Apocalisp> sorry, Traversable
16:02:57 <dfeuer> Still crazy.
16:03:00 <dfeuer> Is it really true?
16:03:06 <Apocalisp> why's that crazy?
16:03:09 <ReinH> Um. No?
16:03:11 <ReinH> [[a]]
16:03:23 <ReinH> is not a monad
16:03:47 <bitemyapp> proof-by-well-actually
16:03:52 <Apocalisp> heh
16:04:22 <dfeuer> Must be a special case. "m and n are not both []."
16:04:29 <ReinH> Oh of course
16:04:30 <bitemyapp> Apocalisp: what email should I send it to?
16:04:34 <_slade_> ReinH: Wait, it's not?
16:04:41 <Apocalisp> yeah, why not?
16:04:43 <ReinH> The special case would read: m and n are not things that would make the conclusion falce.
16:04:51 <ReinH> Please make it a monad
16:04:54 <bitemyapp> nice quotient
16:05:05 <ReinH> *false
16:05:15 <bitemyapp> no no, falce is good. It's the fancy European bottom.
16:05:19 <ReinH> :D
16:05:35 <acowley> hahaa
16:09:01 <ReinH> For another counter-example, http://stackoverflow.com/questions/13034229/concrete-example-showing-that-monads-are-not-closed-under-composition-with-proo/13209294#13209294
16:09:12 <ReinH> Proxy is Traversable
16:09:50 * hackagebot paypal-adaptive-hoops 0.11.0.1 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.11.0.1 (fanjam)
16:10:53 <acowley> That's a really nice example
16:11:06 <ReinH> He's good at that
16:11:39 <ReinH> parametricity to the rescue once again
16:11:41 <acowley> I actually often find him very hard to understand, but a lot of his SO answers are really fantastic
16:11:56 <ReinH> I just really enjoy his tone
16:12:05 <ReinH> I'm still angling to get him on the haskell cast...
16:12:13 <ReinH> but he's like busy or something I don't really know how that works
16:12:41 <acowley> Maybe it's a European thing
16:13:19 <ReinH> Perhaps
16:13:39 <ReinH> I don't really know what busy is atm
16:14:17 <acowley> You should submit a proposal for GHC. That will occupy your time.
16:14:22 <ReinH> hahaha
16:14:29 <ReinH> I'm not sure I want it to be occupied in that way
16:14:33 <bitemyapp> ReinH: 9-5 + book + libraries + mailing lists + IRC + food + sleep + puppy
16:14:46 <bitemyapp> ReinH: but that's still nothing compared to having a family atop all that. cf. Michael is magic
16:15:00 <ReinH> yeah, well these days I mostly just play Witcher 3
16:15:03 <acowley> It's good for a soul to be kicked repeatedly
16:15:04 <bitemyapp> the book alone is 2+ hours a night
16:15:13 <ReinH> acowley: I have a doubt
16:15:36 <acowley> ReinH: It would have been helpful if you'd been here last night
16:15:57 <ReinH> ?
16:16:13 <acowley> You could have let me know that being kicked in the soul isn't actually good
16:16:25 <ReinH> ha
16:17:02 <SrPx> If it is true that every datatype can be represented as a sum of products, then how can "data Foo a = Foo (Maybe a)" be represented as such?
16:17:49 <bitemyapp> SrPx: it's a sum with one case.
16:17:55 <bitemyapp> SrPx: and a product with one argument
16:18:05 <SrPx> but it has one nested type... 
16:18:08 <ReinH> foo = 1 + a
16:18:13 <acowley> SrPx: Maybe a = 1 + a, so Foo (Maybe a) is also 1 + a
16:18:24 <ReinH> (ignoring bottoms)
16:18:28 <SrPx> Foo (Maybe a) is also 1 + a? but they are not the same
16:18:34 <ReinH> they are isomorphic
16:18:36 <acowley> SrPx: The tags fall out
16:18:48 <acowley> SrPx: It's like a constant factor (ehhhh)
16:18:59 <ReinH> it's like 1 * (1 + a)
16:19:08 <SrPx> I'm confused... what about `data Tree a = Node [Tree a] | Leaf a` ?
16:19:10 <ReinH> it's a product of 1
16:19:10 <bitemyapp> SrPx: if you can define it in terms of a newtype, then there's an isomorphism between what the newtype wraps and the newtype.
16:19:38 <bitemyapp> > map (\a -> 1 * (1 + a)) [1..5]
16:19:42 <lambdabot>  [2,3,4,5,6]
16:19:43 <bitemyapp> > map (\a -> (1 + a)) [1..5]
16:19:46 <lambdabot>  [2,3,4,5,6]
16:19:46 <ReinH> it's also a product of 1 :p
16:19:50 <bitemyapp> same-wamey
16:20:08 <Apocalisp> ReinH: http://lpaste.net/133886
16:20:11 <ReinH> @check \x -> 1 * x == x
16:20:13 <lambdabot>  +++ OK, passed 100 tests.
16:20:20 <Apocalisp> one of those ought to work, right? :)
16:20:39 <ReinH> Apocalisp: prove it
16:20:44 <ReinH> there are laws
16:21:02 <SrPx> wah
16:21:23 <ReinH> Tree is a product of Node and Leaf
16:21:33 <acowley> It's a sum of Node and Leaf
16:21:39 <ReinH> yes duh sorry
16:21:42 <Apocalisp> let's see if the laws hold for this. If they do, then I'm still not convinced of the overall statement
16:22:06 <ReinH> Apocalisp: There's also the other counter-example I provided, which is more obviously not a monad
16:22:20 <acowley> Fwiw, I would have thought [[]] could have a Monad instance
16:22:53 <acowley> But that's why guesses are worse than proofs
16:22:56 <ReinH> acowley: I could be wrong, but I don't think so.
16:23:30 <Apocalisp> ReinH: Which counterexample, Proxy?
16:23:39 <acowley> I'm just wondering where it would break down
16:23:40 <ReinH> Apocalisp: yes, the one I linked
16:24:10 <ReinH> acowley: I don't think the identity triangle commutes
16:24:47 <ReinH> the inner lists could be ragged
16:25:24 <ReinH> so it doesn't distribute
16:25:40 <Apocalisp> ReinH, acowley, I am inclined to agree that we're one triangle short of a distributive law
16:27:30 <ReinH> because to get m . n to be a monad, you need more than Traversable, you need distribution (m . n -> n . m)
16:27:52 <ReinH> because you have m . n . m . n and you need to flip the inner n . m so you can join twice
16:28:04 <SrPx> well ok
16:28:16 <ReinH> and sequence has the right type but isn't law abiding
16:28:23 <acowley> SrPx: Did you get an okay answer about Tree?
16:28:36 <SrPx> pardon?
16:29:17 <acowley> SrPx: Oh, I thought your "well ok" was regarding the sum of products question from earlier
16:29:17 <ReinH> Apocalisp: does that make sense?
16:29:30 <dfeuer> acowley, I got one! http://stackoverflow.com/questions/30610836/how-can-i-establish-a-bijection-between-a-tree-and-its-traversal
16:29:44 <SrPx> yes it was
16:29:45 <dfeuer> But that was probably to a different question :P
16:29:47 <SrPx> i think i get it
16:30:08 <ReinH> SrPx: [()] is a good one to think bout
16:30:58 <ReinH> or just natural numbers
16:31:26 <SrPx> natural numbers is... infinity?
16:31:33 <acowley> Most programming is just putting different hats on natural numbers
16:31:43 <ReinH> data Nat = Z | S N, so you have Nat = 1 + 1 * Nat = 1 + Nat
16:31:52 <ReinH> it's a recurrence rule for a recursive data type
16:32:17 <SrPx> So, infinity
16:32:33 <ReinH> Well, how big are the natural numbers? ;)
16:32:53 <SrPx> But then, so is list... and anything recursive... so, no. What
16:32:54 <albeit> Is the best way to empty a Control.Concurrent.Chan to call "void . getChanContents"?
16:33:02 <ReinH> Well, [()] is
16:33:20 <ReinH> data List a = Null | Cons a (List a)
16:33:21 <Apocalisp> ReinH: it does a bit, but I'm not entirely sure I understand why sequenceA is not law-abiding
16:33:37 <ReinH> Apocalisp: because it can lose information
16:33:59 <tempay> so if I'm on Ubuntu with GHC-7.63 installed via apt-get, how do I update to 7.10.1?
16:34:25 <ReinH> so you have L a = 1 + (a * L a), and for [()] you have L 1 = 1 + (1 * L 1) = 1 + L 1
16:34:26 <SrPx> ReinH: do you know where I can read more about this / see a list of examples?
16:34:31 <ReinH> which is the same result
16:34:46 <ReinH> and [()] is indeed in one-to-one correspondence with Nat
16:35:00 <SrPx> Makes sense.
16:36:00 <ReinH> SrPx: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
16:36:38 <ReinH> ADTs form a semiring, and probably some other structure as well given exponents
16:37:16 <hpc> basic summary, Either = (+), tuples = (*)
16:37:27 <ReinH> () = 1, Void = 0
16:37:36 <ReinH> -> = exponentiation
16:37:36 <hpc> and (a -> b) = b**a
16:37:45 <hpc> it's flipped because woo exceptions
16:38:08 <ReinH> it's flipped because that's how it works? :p
16:38:08 <SrPx> Nice, thanks! I'll read that, brb
16:38:13 <hpc> ;)
16:38:25 <Apocalisp> OK, I'm reasonably convinced that my Compose [] [] instance passes the monad laws 
16:38:40 <hpc> it doesn't come up much when you're programming, but some things are super convenient about it, like the pidgeonhole principle
16:39:24 <ReinH> > sequence [[], [1], [1,2]] -- Apocalisp
16:39:26 <lambdabot>  []
16:39:45 <ReinH> remember what I said about ragged inner lists and losing information?
16:40:48 <Apocalisp> I do, and I see, but I haven't connected that to the monad laws
16:40:56 <ReinH> joining loses information
16:41:22 <ReinH> because it must do that
16:41:26 <Apocalisp> sure
16:41:39 <ReinH> which causes it to violate the laws
16:41:39 <SrPx> ReinH: thanks now my girlfriend is mocking me she learned that 20 years ago.
16:41:44 <ReinH> SrPx: :p
16:42:24 <haskets> what environment does everyone here use to edit haskell docs?
16:42:30 <bsmt> emacs
16:42:44 <benzrf> i use vim
16:42:45 <haskets> I use vim and support kinda is not great...
16:42:46 <haskets> bleh
16:42:52 <ReinH> Apocalisp: Hmm, perhaps you can avoid distributing for lists
16:42:55 <benzrf> haskets: tru
16:43:01 <Apocalisp> A few hundred quickChecks find no counterexamples for the [[a]] "monad"
16:43:19 <ReinH> Apocalisp: what definition?
16:43:29 <Apocalisp> the first one in my paste
16:43:45 <frerich> hpc: Another nice use case is to show that currying is moral (by showing that you can go from '(a, b) -> c' to 'a -> (b -> c)').
16:43:52 <Apocalisp> maybe it's succeeding for some stupid reason
16:49:11 <SrPx> ReinH: For "data Tree a = Node [Tree a] | Leaf a", we have "T a = L (T a) + a = (1 + a * T a) + a = 1 + a + a * T a" ?
16:49:40 <Apocalisp> ReinH: oops! Falsified.
16:50:39 <dolio> [[a]] is ListT [] a, and ListT is well known to only be a monad transformer for commutative monads.
16:50:44 <dolio> And [] isn't commutative.
16:51:26 <acowley> SrPx: Yes!
16:52:20 <ReinH> dolio: thanks
16:53:26 <SrPx> So you're telling me "1 + a + a * T a" is enough information to program a functor instance?
16:53:31 <SrPx> For Tree...
16:53:45 <dolio> If it's Compose m n where n is the Traversable one, then n = [] is ListT m, so you can generate other examples that way.
16:53:50 <dolio> Like IO [a].
16:55:22 <ReinH> SrPx: not quite
16:55:54 <Apocalisp> dolio: is IO [a] not a monad?
16:56:18 <SrPx> so that's not a way to uniquely identify a type...? 
16:56:19 <dolio> Nope.
16:56:24 <SrPx> if that's not enough, what is?
16:58:01 <ReinH> L(a) = 1 + a * L(a), T(a) = L(T(a)) + a = (1 + T(a) * L(T(a))) + a
16:58:08 <ReinH> SrPx: It would be easier to start with a binary tree
16:58:14 <ReinH> SrPx: which the second part does: http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/
17:02:28 <dfeuer> Are there any (covariant endo) functors in Hask that GHC cannot derive a Functor instance for?
17:03:07 <dfeuer> D'you know, ReinH?
17:03:23 <ReinH> dfeuer: dunno
17:03:40 <arkeet> it can't derive the one for Coyoneda
17:04:40 <arkeet> it can't do existentials
17:04:47 <ReinH> That's cheating :p
17:04:54 <arkeet> :-(
17:05:21 <Apocalisp> dolio: Here's what's confusing. http://ncatlab.org/nlab/show/distributive+law says I need two triangles and two pentagons to commute to get a proper distributive law between monads
17:06:10 <Apocalisp> For [].[], I can't find any counterexamples for these identities (and can prove three of them). And yet here we are, [].[] is not a monad.
17:06:26 <dfeuer> ReinH, what makes existentials cheats? 
17:08:03 <ReinH> dfeuer: um, reasons?
17:08:27 <ReinH> I was just joking :p
17:08:45 <ReinH> but rank n types do kind of seem like cheating
17:08:46 <dfeuer> ReinH, I didn't know if there was a deep reason for that being a cheat :P
17:08:58 <dfeuer> Why's that?
17:09:07 <dfeuer> Rank n types are beautiful things :)
17:09:27 <ReinH> They are, but I can see why the deriving system would have trouble with them
17:09:52 <dfeuer> They can express so many wonderful ideas. I know naught of the deriving system :/.
17:11:24 <dolio> Apocalisp: Which one can't you prove? sequence . return = fmap return?
17:20:58 <dolio> @check let prop :: [[[Int]]] -> Bool ; prop ls = sequence (map join ls) == join (map sequence . sequence $ ls) in prop
17:21:00 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 8 shrinks):
17:21:01 <lambdabot>  [[[3,0,-3],[]],[[-2,1],[3,2,2],[1]]]
17:21:06 <dolio> Hope you didn't prove that one. :)
17:21:21 <ReinH> :)
17:39:12 <ttt_fff> clojure has this idea that values can have 'meta' data attached to them (http://clojure.org/metadata) -- is there anyway to do this in haskell? I find myself having to sprinkle "tags" into all my data constructors to simulate this
17:40:31 <Hijiri> tuple with meta data and the actual value?
17:40:43 <Hijiri> data Meta meta value = Meta meta value
17:41:34 <Hijiri> I don't think you can put arbitrary data into an existing type, you would need something else to handle it
17:44:03 <SrPx> ReinH: this is harder than I expected
17:44:12 <SrPx> ReinH: the whole 7 trees e 1 thing is wtf
17:44:41 <Vektorweg1> Control.Concurrent or STM? 
17:44:52 <Apocalis_> dolio: well.. http://lpaste.net/133887
17:44:57 <Apocalis_> where does that go wrong?
17:47:38 <Apocalis_> ah, I see. I'm assuming that join is natural from [] [] to []
17:47:48 <Apocalis_> which it isn't
17:48:38 <small-wolf> practically speaking, what's the most you should ever need to set max-backjumps too
17:48:53 <Cale> Apocalis_: hm? join is a natural transformation...
17:49:05 <Apocalis_> hmm yeah
17:49:09 <Apocalis_> does it preserve Applicative?
17:49:23 <Cale> Not sure what that means
17:50:14 <Apocalis_> I mean... is join an applicative homomorphism from Applicative (f.f) to Applicative f?
17:50:33 <osa1> hm.. I have an _ in a let syntax but GHC isn't printing the type. is this expected? like `let a :: _; a = ... in ...`
17:51:28 <Cale> Apocalis_: I don't know if that's true
17:52:16 <Apocalis_> Cale: I suspect that's where that paste goes wrong
17:54:02 <Apocalis_> dolio, btw your quickcheck property above is using the wrong applicative in the left-hand sequence
17:54:50 <dolio> The left hand one?
17:55:06 <Apocalis_> should be using [].[]
17:56:05 <dolio> I don't think it's possible for the left hand one to be wrong.
17:56:16 <dolio> The identity is on TPP.
17:56:39 <dolio> TPP -> TP -> PT
17:56:52 <dolio> There's only one sequence for that second part.
17:57:38 <comprehension> ls
17:57:38 <Apocalis_> yeah
17:57:43 <comprehension> cd cmn 
17:57:44 <comprehension> ls
17:57:48 <comprehension> cd tetris
17:57:52 <comprehension> cd tero-t
17:57:53 <comprehension> ls
17:57:58 <Apocalis_> dolio: I see what you mean now
17:58:00 <comprehension> cabal sandbox init
17:58:21 <comprehension> cabal install gtk2hs-buildtools
17:58:23 --- mode: ChanServ set +o dolio
17:58:26 --- kick: comprehension was kicked by dolio (comprehension)
17:58:45 --- mode: dolio set -o dolio
18:00:16 <ReinH> SrPx: infinity is hard to reason about :)
18:00:28 <dolio> Anyhow, what's wrong must be your first step, because the others are just definitions.
18:00:35 <dolio> I'm not sure exactly what's wrong about it, though.
18:02:32 <small-wolf> anyone here use plush?
18:06:28 <dolio> I guess what's wrong with it is exactly the same thing as the property you're trying to prove, because the rest is just bookkeeping.
18:06:49 <ReinH> heh
18:09:55 * hackagebot wuss 1.0.1 - Secure WebSocket (WSS) clients  http://hackage.haskell.org/package/wuss-1.0.1 (fozworth)
18:12:19 <Apocalis_> dolio: what's wrong is that t (x <*> y) = t x <*> t y does not hold with t = join . uncompose
18:13:09 <dolio> Yeah, that looks like it wouldn't work.
18:14:40 <arkeet> seems vaguely related to this fact:
18:14:45 <arkeet> :t uncurry mappend
18:14:46 <lambdabot> Monoid c => (c, c) -> c
18:15:03 <arkeet> c is a commutative monoid if this is a monoid homomorphism
18:15:13 <arkeet> (and only if)
18:15:36 <dolio> Ah yes. That's probably the same thing.
18:16:02 <arkeet> I should have said it this way:
18:16:09 <arkeet> this is a monoid homomorphism only if c is a commutative monoid
18:16:32 <dolio> Since that would tie into ListT m being a monad only for commutative monads m.
18:18:22 <arkeet> (for the interested, the above fact is a case of the Eckmann-Hilton argument)
18:18:37 <dolio> Right.
18:18:40 <ReinH> dolio: how?
18:18:49 <dolio> Which part?
18:18:51 <ReinH> how does it tie into ListM
18:18:54 <ReinH> ListT
18:18:58 <Fylwind> does anyone know what base 4.2 corresponds to in ghc version?
18:19:01 <arkeet> ReinH: vaguely.
18:19:20 <ReinH> something something monads are monoids something something commutative hand wave hand wave got it
18:19:24 <arkeet> :)
18:19:33 <dolio> ReinH: Because the identity above was used in the proof that ListT m is a monad, and ListT m is only a monad if m is commutative.
18:19:33 <Fylwind> (better yet does anyone know of a site where I can check this so I don't have to ask dumb questions here :p )
18:19:56 * hackagebot wuss 1.0.2 - Secure WebSocket (WSS) clients  http://hackage.haskell.org/package/wuss-1.0.2 (fozworth)
18:20:08 <ReinH> dolio: hmm
18:23:00 <dolio> ReinH: You may also have heard about monads being like monoids.
18:23:13 <ReinH> dolio: yes ofc
18:23:25 <Fylwind> nvm, found it: it's 6.12 https://downloads.haskell.org/~ghc/6.12.1/docs/html/users_guide/release-6-12-1.html#id2890280
18:23:26 <ReinH> What I mean specifically is where does ListT come in?
18:24:37 <ReinH> Just in the ListT [] case?
18:24:58 <dolio> No, I just happen to know that it's only a monad for commutative monads.
18:25:13 <ReinH> Right, I just don't see the connection to ListT
18:25:24 <ReinH> They seem like unrelated facts at this point
18:25:33 <ReinH> I can believe that there is a connection, I just can't see it
18:25:55 <Fylwind> interesting, so 'directory' split off 'base' in ghc 6.8.1 (base-3.0) …
18:28:08 <dolio> The concrete example was T = [] and P = [], making PT a monad.
18:28:30 <dolio> Which is ListT [].
18:28:45 <dolio> But you could take P to be anything and get ListT P.
18:28:58 <ReinH> Right, I got that part
18:29:14 <Apocalisp> arkeet: Boom. The commutative monoid comment totally brings this home for me.
18:29:48 <Apocalisp> I've worked that one out the hard way before
18:31:12 <dolio> And the claim is this only works for commutative P, and that join : PP -> P is only a monad homomorphism for commutative P, which is the same as the claim that mult : m × m -> m is a monoid homomorphism only for commutative monoids.
18:31:59 <dolio> join being a homomorphism being the precondition for the used equation.
18:33:37 <arkeet> dolio: PP is a monad?
18:33:51 <dolio> P is a monad.
18:34:06 <arkeet> yes, but you said something about join : PP -> P being a monad morphism
18:34:11 <arkeet> which presupposes that PP is a monad
18:34:23 <dolio> Oh, right. Use Applicative instead, then.
18:34:25 <arkeet> okay.
18:34:58 <arkeet> I'm not entirely sure what a commutative monad is.
18:35:06 <arkeet> but I can make sense of commutative applicative.
18:35:59 <ReinH> arkeet: which sense do you make of it?
18:36:29 <dolio> Commutative monads are such that either of the ways of going from (m a, m b) -> m (a, b) are the same.
18:36:51 <dolio> Which I guess is the same as applicative, just with different primitives.
18:36:53 <arkeet> ok, so that's the same as applicative.
18:37:18 <dolio> They have to be strong monads, probably.
18:37:54 <arkeet> all functors are strong though
18:38:11 <dolio> In Haskell.
18:38:14 <arkeet> yes.
18:38:50 <ReinH> dolio: yeah, that's a strong functor
18:39:18 <dolio> Well, strong functor is that you can do (m a, b) -> m (a, b).
18:39:18 <ReinH> er
18:39:21 <ReinH> a closed functor, sorry
18:39:30 <ReinH> so many names
18:39:53 <dolio> Commutative monad says you can do (m a, m b) -> m (a, m b) -> mm (a, b) -> m (a, b), and it's the same as lifting out the right first.
18:41:33 <ReinH> Hmm. Closed is
18:41:35 <ReinH> :t (<*>)
18:41:36 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:42:03 <ReinH> (and preserves the unit)
18:42:42 <ReinH> oh, the monoidal category has to be symmetric
18:43:47 <ReinH> symmetric closed monoidal
18:43:53 <ReinH> Oh, it turns out those are good google search terms as well http://home.math.au.dk/kock/MSMCC.pdf
18:44:18 <dolio> Certainly a closed functor is between closed categories. :)
18:44:42 <ReinH> indeed
18:45:23 <ReinH> Huh. "Closed monad"
18:45:52 <Pibian> ReinH, What's that about?
18:45:52 <benzrf> dolio: hold on
18:46:02 <ReinH> Pibian: abstract nonsense
18:46:12 <Pibian> ReinH, You understand anything of it?
18:46:14 <benzrf> dolio: wouldnt a commutative monoid require that the monoidal category be braided or symmetric or something
18:46:16 <ReinH> Pibian: some of it
18:46:27 <benzrf> dolio: isnt what you described above a different kind of commutativity
18:46:31 <Pibian> ReinH, Like quantum theory?
18:46:36 <ReinH> Pibian: category theory
18:46:42 <Pibian> Oh
18:47:00 <Pibian> ReinH, Very abstrat
18:47:06 <ReinH> Yep
18:47:18 <dolio> benzrf: That's not how it's defined.
18:47:21 <Pibian> ReinH, Can you do it with Haskell?
18:47:27 <ReinH> Pibian: a surprising amount, yes
18:47:36 <benzrf> dolio: er, what is?
18:47:38 <Pibian> Sounds impressing
18:47:43 <dolio> Commutative monoid.
18:47:46 <dolio> Er, monad.
18:48:11 <benzrf> dolio: so commutative monads are not just the special case of commutative monoids, then?
18:48:18 <benzrf> they are a separate definition?
18:48:54 <dolio> I'm not sure what the categorical specification of commutative monoid is.
18:49:06 <benzrf> me either :>
18:49:15 <ReinH> dolio: well, one is posed here http://home.math.au.dk/kock/MSMCC.pdf
18:49:28 <benzrf> but i'd imagine that it requires, at the very least, that the category be braided
18:49:43 <benzrf> how else do you define "swapping the args"
18:50:29 <dolio> ReinH: Monoid or monad?
18:50:34 <ReinH> dolio: monad
18:50:44 <ReinH> oh
18:50:46 <ReinH> sorry
18:51:05 <dolio> benzrf: I wouldn't be surprised if most of the time they just use cartesian product.
18:51:07 <ReinH> dolio: names once again prove my undoing
18:51:18 <benzrf> dolio: whaa
18:51:28 <benzrf> dolio: since when can you do cartesian product on arbitrary categories
18:52:01 <dolio> Who cares?
18:52:20 <dolio> Symmetric is probably enough, though.
18:54:31 <ReinH> I mean, commutative seems relatively straight-forward? A monoidal category C is commutative if, for objects A, B in C, A x B <=> B x A?
18:55:24 <dolio> Well, that's symmetric monoidal, if you're expecting an isomorphism.
18:55:40 <ReinH> Right, that's why I said symmetric monoidal before :)
18:56:37 <albeit_> When threads move between processors, doesn't that mean its nursery may now be residing on an L1/L2 cache of a different processor?
18:57:22 <ReinH> Well, symmetric imposes an additional requirement on the isomorphism, right?
18:57:51 <dolio> I think the fact that it's an isomorphism is the requirement.
18:57:58 <ReinH> Hmm
18:58:20 <dolio> Otherwise you have A * B -> B * A and vice versa, but you don't know that composing it is the identity.
18:58:33 <ReinH> dolio: Oh, it has the "switching things twice has no effect" property
18:58:37 <dolio> Right.
18:58:48 <ReinH> so "as commutative as possible"
18:58:52 <ReinH> so no knots
18:59:23 <ReinH> thus the reason braids are called braids...
18:59:33 <hasket> Is tdd recommended still for haskell? I've used it extensively with python, but I know the type system provides a lot of that safety
18:59:43 <hasket> If so, what kind of tests are people writing for things like yesod?
18:59:46 <ReinH> because that requirement is basically "no tangles"
19:00:06 <fishythefish> Except that a symmetric monoidal category _is_ a braided monoidal category. ;)
19:00:22 <ReinH> fishythefish: Well, the nomenclature isn't perfect
19:00:47 <fishythefish> ReinH: Don't I know it.
19:04:34 <dolio> benzrf, ReinH: Anyhow, the commutative monad definition is effectively the same as the commutative applicative definition, for the applicative induced by the monad.
19:04:56 <dolio> And applicatives are monoid objects in a symmetric monoidal category, I think.
19:04:58 <ReinH> which applicative? they are the same because it is commutative
19:05:51 <benzrf> applicatives are monoids under day convolution, i'm told
19:06:05 <dolio> Right.
19:06:17 <benzrf> oh, does day convolution require symmetry or sth?
19:06:36 <ReinH> If it did, all applicatives would be commutative?
19:06:53 <dolio> Day convolution is just Day f g a = ∃ x y. (f x, g y, x -> y -> a).
19:07:17 <dolio> So Day f g and Day g f are more or less the same.
19:10:29 <dolio> Or if you prefer, Day f g a = ∃ e. (f (e -> a), f e).
19:10:34 <dolio> If you can do that.
19:10:53 <dolio> Er, (f (e -> a), g e).
19:14:52 <fishythefish> Caveat: this is for covariant functors
19:15:10 <fishythefish> You usually do it for contravariant, but Hask and Hask^op are both monoidal categories, so you get away with it.
19:16:19 <dolio> C and C^op are always both monoidal categories (or both not).
19:16:36 <dolio> Unless you start talking about those directed monoidal categories.
19:18:45 <dolio> Even in that case, C is probably left and C^op is right, or vice versa.
19:19:21 <fishythefish> dolio: Agreed
19:19:22 <dolio> Skew monoidal. That's the term.
19:19:32 <fishythefish> Of course, working over Hask does give you some nicer properties than in general.
19:20:10 <fishythefish> E.g. symmetry of the induced monoid
19:20:58 <fishythefish> Gotta go; good night, all
19:33:54 <sydneyhacker> I am new to Lens. What is the difference between the data-lens and lens pacakges?
19:34:28 <roconnor> sydneyhacker: different representation.  the operators in lens have been renamed somewhat since data-lens I think
19:34:35 <roconnor> sydneyhacker: lens is modern
19:35:16 <bitemyapp> roconnor: is there a post-modern lens library?
19:35:22 <sydneyhacker> Thanks roconnor I will look at lens
19:36:31 <roconnor> bitemyapp: yes
19:37:03 <roconnor> sydneyhacker: lens-family is similar to lens and a bit simpler but less powerful
19:39:15 <sydneyhacker> roconnor, do you know, is there something like Data.Lens.Template for lens
19:40:00 <roconnor> yes.  I assumed it was included in lens
19:40:55 <sydneyhacker> Ah I think I spotted it: Language.Haskell.TH.Lens
19:40:58 <sydneyhacker> thanks
19:41:28 <c_wraith> No, that's lenses for manipulating TH.  You want Control.Lens.TH
19:41:31 <roconnor> no I don't think that is it
19:41:34 <roconnor> what c_wraith said
19:42:06 <sydneyhacker> yes right you are. thanks
19:59:30 <liyang> Registering for ICFP. "Cost of Registration: $1050.00" Ouch.
20:00:30 <liyang> Where does that money actually go to? Certainly not to any of the researchers… D:
20:00:59 <dzack> if you define functions/types in a 'where' clause, is there any way to expose them to the ghci repl?
20:01:17 <ReinH> dzack: no
20:01:40 <ReinH> the purpose of where is to prevent you from doing so
20:02:33 <dzack> ah, bummer. makes sense though, thanks
20:27:52 <dzack> hmm, another question - if you have a function that returns something like 'maybe mzero return (otherStuff)', how would you go about checking the result to see which action you got out of it?
20:28:27 <dzack> I'm trying something like case resultOfAboveFunction mzero -> doSomething _ -> doSomethingElse
20:28:38 <dzack> but that doesn't seem to parse
20:30:54 <ion> There is no isMzero in general. “case … of mzero -> …” will just match anything and bind it to mzero which shadows the imported one.
20:31:07 <ion> > case 42 of mzero -> mzero + 1
20:31:09 <lambdabot>  43
20:31:11 <ion> > case 42 of a -> a + 1
20:31:13 <lambdabot>  43
20:33:16 <KaneTW> matching against mzero would require knowledge of the monad, so a general function is impossible
20:34:25 <ReinH> is isMzero would have to be added to the typeclass
20:34:29 <ReinH> *or
20:34:35 <ion> Well, a class MonadPlus m => MonadIsZero m where { isMzero :: m a -> Bool } would be *possible* but perhaps not very useful.
20:34:47 <KaneTW> yeah
20:35:20 <dzack> hmm - so do you generally wait until the action is finally carried out somewhere to check it?
20:35:51 <ion> dzack: What are you intending to achieve by checking whether the result is mzero?
20:37:29 <dzack> basically, the function that returns the mzero stuff parses a url for a string
20:38:26 <dzack> eventually, it'll return an http response - I want to throw a 404 or something if that string isn't found
20:39:40 <ion> So you have a concrete instance? Just check against a concrete value (whatever mzero is defined as for that one).
20:40:16 <ion> > case mzero of [] -> "it was mzero"
20:40:18 <lambdabot>  "it was mzero"
20:40:20 <ion> > case mzero of Nothing -> "it was mzero"
20:40:25 <lambdabot>  "it was mzero"
20:47:24 <nshepperd> ismzero = (== mzero)
20:50:17 <KaneTW> that implies an Eq instance
20:50:24 <KaneTW> IO has none, for example
20:51:52 <nshepperd> yep
20:52:13 <nshepperd> trying to case match on mzero in IO is silliness, of course
20:53:22 <KaneTW> yeah, it's just an example. You'd have to add a constraint Eq a => MonadPlus a to its definition for that to work and that's hard to justify
20:54:19 <nshepperd> I don't think there's anything inherently wrong with 'ismzero :: (Eq (m a), MonadPlus m) => m a -> Bool'
20:54:21 <Welkin> do you have any recommendations for image processing libraries?
20:54:29 <Welkin> I'm looking to crop and scale images
20:55:02 * hackagebot http-client 0.4.11.3 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.11.3 (MichaelSnoyman)
20:55:19 <ReinH> if you know that much about the type, you probably know what it is concretely
21:26:37 <newtoirc> hi, I'm trying to learn more about writing code in haskell that takes advantage of parallelization, but I'm a bit stuck. Can somebody please help me out?
21:28:35 <hasket> newtoirc: Check out http://chimera.labs.oreilly.com/books/1230000000929
21:28:49 <hasket> newtoirc It's online for free
21:29:05 <hasket> But if you can, I always like to support the author :) (not me btw)
21:30:04 * hackagebot bloodhound 0.6.0.0 - ElasticSearch client library for Haskell  http://hackage.haskell.org/package/bloodhound-0.6.0.0 (bitemyapp)
21:31:31 <newtoirc> thanks hasket! I probably should have been a bit more specific: right now, I'm trying to specifically parallelize a function that maps a function to a list of tuples. I remember reading most of the parallelization section of that book, but don't recall information that could help with my specific problem. Think you could help me out a bit?
21:32:22 <hasket> Like a parallel map?
21:32:34 <hasket> What's the type?
21:32:40 <newtoirc> yeah, but for tuples specifically
21:32:54 <hasket> (a -> b) -> [(a, a)]?
21:33:02 <hasket> (a -> b) -> [(a, a)] -> [(b,b)]?
21:33:04 <hasket> Something like that?
21:33:36 <newtoirc> ((a, b) -> (a, b)) -> [(a, b)] -> [(a, b)]
21:33:55 <hasket> so you're mapping them to the same type? 
21:34:00 <newtoirc> yeah
21:35:24 <hasket> newtoirc not sure. I'm probably not the best person to ask about parallel programming as I'm just learning it in haskell myself.
21:36:14 <newtoirc> oh, ok. do you have any other material, like the textbook you linked to earlier, that might be able to help me?
21:36:24 <hasket> http://stackoverflow.com/questions/5606165/parallel-map-in-haskell
21:36:51 <newtoirc> or, if not help me with my specific question, help me further understand parallelism in haskell?
21:38:21 <hasket> do you have a function that works now not in parallel?
21:39:27 <newtoirc> yeah. I have multiple functions, one that isn't parallel, and two more that are parallel, but I can't seem to get a noticeable speed increase from running the parallel ones
21:40:10 <hasket> Are you using the state of the previous computation at all?
21:40:17 <hasket> So are you folding or mapping?
21:40:30 <newtoirc> I'm mapping
21:40:42 <newtoirc> I'm not sure how to do a parallel fold
21:41:12 <hasket> Are you compiling with -threaded?
21:41:28 <newtoirc> and no, I'm not using the state of the previous computation at all
21:41:38 <hasket> Are you compiling with -threaded -rtsopts -with-rtsopts=-N?
21:41:50 <newtoirc> yeah, I'm compiling with -threaded
21:41:52 <hasket> whoops didn't mean to send that twice
21:41:57 <newtoirc> no worries
21:42:22 <hasket> newtoirc if you are compiling, try profiling your code and seeing where the bottleneck is
21:45:19 <nshepperd> newtoirc: remember that tuples are lazy, so evaluating them to whnf in parallel will only evaluate the tuple constructor (,)
21:45:21 <newtoirc> I've tried profiling, but every time I create the postscript file, I'm not able to actually view it
21:45:38 <newtoirc> Is this a common error?
21:46:56 <newtoirc> and thanks nshepperd. what if I used parTuple2 rdeepseq rdeepseq?
21:46:57 <hasket> nshepperd yep good point
21:47:29 <newtoirc> because that's what I'm currently using, and it hasn't given me a noticeable improvement
21:50:19 <nshepperd> so you're using something like parMap (parTuple2 rdeepseq rdeepseq) f xs?
21:51:12 <nshepperd> oh yeah, you need to run it with +RTS -N
21:51:17 <newtoirc> similar to that, yeah
21:51:34 <nshepperd> as well, to make sure it actually creates multiple worker threads
21:51:51 <newtoirc> yeah, I've been running it with +RTS -Nx
21:52:38 <newtoirc> for some reason, -N used to work for me, but then I redownloaded a lot of my cabal packages with profiling enabled, and I was no longer able to use it.
21:54:08 <nshepperd> -Nx?
21:55:05 * hackagebot anansi 0.4.8 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.4.8 (JohnMillikin)
21:55:32 <newtoirc> sorry, by Nx, I mean something like N2, N3, N4
21:55:39 <nshepperd> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/using-smp.html#parallel-options suggests running with -s to see timing stats
21:56:32 <nshepperd> oh yeah, with profiling, I use ps2pdf to turn the postscript output into a pdf
21:57:05 <nshepperd> since my viewers don't seem to be able to handle the postscript for whatever reason
21:58:09 <newtoirc> ps2pdf, got it. definitely going to need to try it
21:58:43 <newtoirc> yeah, I tried a few different things originally, and none worked - haven't tried ps2pdf yet, though
21:59:33 <Welkin> printing PDFs from the playstation 2
22:02:41 <newtoirc> thanks for the help guys!
22:29:55 <rui> Have just started googling about dependent types... Am I on track if I get the impression that dependent types would provide a way to use the type system for what haskellers usually use QuickCheck?
22:30:31 <rui> ...at least for the simplest cases
22:34:16 <liste> rui you can use them to prove your properties, but you still need to write the proofs yourself
22:34:35 <liste> the compiler can just check that they hold
22:35:38 <YellowOnion> Why is there no isInfixOf for a lazy ByteString?
22:38:12 <SrPx> I would ask this on cstheory.SO buy nobody answers me there :( I think there is no term on the untyped LC that 1. has a normal form, 2. when applied to a church number fails to terminate. Is that correct?
22:39:22 <SrPx> Ah nvm, just figured a counterexample :P
22:39:44 <rui> liste: Thanks
22:40:03 <rui> I think I'll only get a good idea of what they are by learning some language that has them
23:32:46 <YellowOnion> If I was to use [ord 'a' .. ord 'z'] would GHC optimise out the conversion step?
23:35:03 <pacak> YellowOnion: I think it should.
23:35:52 <pacak> YellowOnion: You can always poke around in Core - it's always nice to see how your code gets compiled.
23:38:57 <YellowOnion> pacak, thanks, I probably wouldn't be able to comprehend any of it though.
23:40:31 <YellowOnion> on another note is why does 'chr' not accept 'Word' as an input.
23:40:39 <YellowOnion> :t chr
23:40:41 <lambdabot> Int -> Char
23:40:59 <pacak> YellowOnion: http://stackoverflow.com/questions/6121146/reading-ghc-core 
23:41:37 <pacak> YellowOnion: Because it takes Int (for whatever reasons) and Int vs Word are different types.
23:46:19 <YellowOnion> pacak, I know that much, just seems a pain to convert the Word to an Int first, in fact I can't seem to find any function to convert it to an Int either.
23:46:42 <pacak> :t fromIntegral (1 :: Word) :: Int
23:46:43 <lambdabot> Int
23:46:45 <pacak> fromIntegral (1 :: Word) :: Int
23:46:50 <pacak> > fromIntegral (1 :: Word) :: Int
23:46:52 <lambdabot>  1
23:46:56 <pacak> > fromIntegral (1 :: Int) :: Word
23:46:57 <lambdabot>  1
23:47:00 <pacak> > fromIntegral (1 :: Int) :: Word8
23:47:02 <lambdabot>  1
23:47:07 <pacak> and so on. 
23:48:18 <YellowOnion> pacak, oh right.
23:49:40 <pacak> YellowOnion: It's midly annoying, but at least it will stop you from first multiplying Word8 by 100 and then casting it to Int
23:51:17 <liste> > minBound :: Word
23:51:20 <lambdabot>  0
23:51:23 <liste> > axBound :: Word
23:51:25 <lambdabot>      Not in scope: ‘axBound’
23:51:25 <lambdabot>      Perhaps you meant ‘maxBound’ (imported from Prelude)
23:51:26 <liste> > maxBound :: Word
23:51:29 <lambdabot>  18446744073709551615
23:51:43 <pacak> > maxBound :: Word16
23:51:45 <lambdabot>  65535
23:52:10 <YellowOnion> pacak, I would much perfer chr just accepted Word8 as input. Since I'm pretty sure chr doesn't accept anything larger than 255 anyway.
23:52:23 <pacak> YellowOnion: Sure it does.
23:52:24 <liste> > chr 12345
23:52:25 <lambdabot>  '\12345'
23:52:32 <liste> why wouldn't it?
23:52:46 <pacak> > chr 1099
23:52:48 <lambdabot>  '\1099'
23:52:58 <liste> > maxBound :: Char
23:52:59 <lambdabot>  '\1114111'
23:53:19 <YellowOnion> liste, oh I so it supports Unicode?
23:53:24 <liste> of course (:
23:53:29 <pacak> > Text.pack [chr 1099]
23:53:30 <lambdabot>  Not in scope: ‘Text.pack’
23:53:35 <pacak> > T.pack [chr 1099]
23:53:38 <lambdabot>      Not in scope: ‘T.pack’
23:53:38 <lambdabot>      Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
23:53:54 <pacak> lambdabot: TEXT! I WANT TEXT!!!
23:53:57 <YellowOnion> I'm a bit tired, think I'm still thinking with my python brain.
23:54:15 <liste> > Tx.pack [chr 1099] -- maybe?
23:54:17 <lambdabot>      Not in scope: ‘Tx.pack’
23:54:17 <lambdabot>      Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
23:54:25 <liste> @let import Data.Text
23:54:27 <lambdabot>  .L.hs:111:1:
23:54:27 <lambdabot>      Data.Text: Can't be safely imported!
23:54:27 <lambdabot>      The package (text-1.2.0.4) the module resides in isn't trusted.
23:54:40 <liste> :(
23:55:05 <liste> can't have
23:55:12 <pacak> Sure you can
23:56:01 <pacak> > Data.Text.pack [chr 1099]
23:56:03 <lambdabot>  Not in scope: ‘Data.Text.pack’
23:56:43 <zettablade> I'm doing the NICTA course. Can anyone explain how "lift2 (<$>) (,) readFile" works. I've never seen lift used that way before.
23:56:58 <pacak> :t lift2
23:57:00 <lambdabot>     Not in scope: ‘lift2’
23:57:00 <lambdabot>     Perhaps you meant one of these:
23:57:00 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
23:57:05 <pacak> :t liftA2
23:57:06 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
23:57:29 <pacak> :t liftM2
23:57:31 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:57:45 <pacak> zettablade: Which one was it?
23:58:07 <zettablade> liftA2
23:58:25 <liste> looks like a double lift
23:58:46 <pacak> :t \a b c -> a <$> b <*> c
23:58:47 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
23:58:54 <liste> <$> is fmap which is basically liftM
23:59:14 <pacak> :t liftA2 (<$>)
23:59:15 <lambdabot> (Functor f1, Applicative f) => f (a -> b) -> f (f1 a) -> f (f1 b)
23:59:20 <pacak> :t liftA2 (<$>) (,)
23:59:21 <lambdabot> Functor f => (a1 -> f a) -> a1 -> f (a1, a)
23:59:28 <pacak> :t liftA2 (<$>) (,) readFile
23:59:29 <lambdabot> FilePath -> IO (FilePath, String)
