00:14:12 <sccrstud92> what browsers have said they plan to support webassembly?
00:15:18 <Axman6> well, Google, Microsoft, Mozilla and the WebKit team are all working on this, so I would guess at least Chrome, IE, Firefox and Safari (plus all the other WebKit based browsers)
00:20:29 <sccrstud92> which browsers are based on webkit?
00:20:51 <Axman6> well, importantly Safari on iOS
00:23:45 <neuroserpens> Guys I need some help. I wrote this solution http://pastie.org/10246436 to this codechef problem http://www.codechef.com/problems/INTEST/ but it's apparently exceeding a time limit when it runs and I have no idea as to how to optimize this code's performance.
00:25:15 <neuroserpens> And it works with the example input...
00:26:35 <kadoban> neuroserpens: String is quite slow. You'll likely have to use either Text or ByteString
00:27:15 <neuroserpens> kadoban: I have no idea how to do that.
00:27:27 <sccrstud92> read is also slow. a parsing package might help as well. it can do Text/ByteString for you
00:27:44 <neuroserpens> sccrstud92: You lost me too lol
00:28:01 <neuroserpens> Can you guys recommend me anything to read on that so I don't bother you with my noobness?
00:28:12 <kadoban> neuroserpens: For crappy programming competition websites, I usually just use Data.ByteString.Char8, specifically interact, lines, unlines, readInt, etc.
00:28:41 <neuroserpens> kadoban: So I need to import readInt from Char8?
00:29:40 <kadoban> neuroserpens: You should look at the module documentation and the types of interact and readInt and see if any of it makes sense. Also look at pack and unpack. And ... this stuff is not meant as general programming good practice, this is like assuming everything is ASCII.
00:30:07 <kadoban> Text would be better, but it's slower and these problems never care about weird input, it's always simple ASCII crap.
00:30:57 <neuroserpens> kadoban: Teach me how to use this Bytestring thingy :O !
00:31:33 <kadoban> That wasn't enough time to even pretend to read the docs ... sorry, read a bit and if you're still not getting it I'd be glad to help.
00:32:26 <neuroserpens> kadoban: docs on  bytestring?
00:32:30 <neuroserpens> kadoban: ok
00:33:07 <kadoban> Yes, if you don't know what bytestring is in general, and the docs on the functions I mentioned in the Data.ByteString.Char8 module
00:33:38 * hackagebot razom-text-util 0.1.2.0 - Common text/parsing tools for Razom language packages.  http://hackage.haskell.org/package/razom-text-util-0.1.2.0 (akrasner)
00:34:13 <lritter> does haskell have an infix apply operator?
00:34:33 <kadoban> :t ($) -- that?
00:34:34 <lambdabot> (a -> b) -> a -> b
00:34:53 <lritter> like, evaluate this function with these arguments
00:35:37 <Denommus> lritter: yes, ($), as kadoban said
00:35:44 <lritter> i'm designing infix operators for my toy language
00:36:00 <lritter> i looked at haskell for some inspiration; i already took over !!
00:36:08 <lritter> Denommus, kadoban: thx, that's the one
00:36:14 <hukey> anyone patient enough to answer some newbie's questions?
00:36:14 <lritter> and $ is yet unused, too :)
00:36:47 <Denommus> OCaml uses @@ (same as Haskell's $) 
00:37:00 <merijn> hukey: There's usually tons of people willing to answer newbie questions, just ask.
00:37:03 <lritter> i use @ for pointers
00:37:15 <lritter> (dereference)
00:37:22 <sccrstud92> in haskell?
00:37:27 <hukey> i have 0 experience with functional langs, but been trying to learn haskell for a while... im starting to use a more functionaly style on my Javascript programs, for example, I almost dont't or just never use variables anymore
00:37:28 <lritter> nope, in my toy language
00:37:34 <Denommus> sccrstud92: in his language 
00:37:51 <lritter> it's a scheme inspired s-expression based thing written on top of terra
00:37:52 <hukey> basically everything is a big expression / function. instead of variables i just pass what i want as an argument to the function
00:38:08 <hukey> but sometimes i just dont know how to make something look functional
00:38:12 <lritter> i added infix operator support today and am going wild ;)
00:38:38 * hackagebot vocabulary-kadma 0.1.0.0 - Smaoin vocabulary definitions of the base framework.  http://hackage.haskell.org/package/vocabulary-kadma-0.1.0.0 (akrasner)
00:38:47 <lritter> makes me realize that there aren't enough special characters in the ascii alphabet
00:38:59 <hukey> like there are things i dont know how would be done in a functional way
00:39:04 <hukey> console.log for example
00:39:21 <ChristianS> lritter: incidentally $ is just syntactic sugar useful to save parentheses, otherwise  a $ b  is the same as  a b
00:39:31 <merijn> ChristianS: It's not syntactic sugar
00:39:38 <merijn> ChristianS: $ is a function
00:40:01 <ChristianS> merijn: true, but well ... you know what i mean
00:40:07 <lritter> one statement doesn't exclude the other meretrix
00:40:11 <lritter> one statement doesn't exclude the other merijn
00:40:14 <lritter> tsk
00:40:23 <kadoban> It's sugary, it's just not syntactic ;)
00:40:33 <merijn> lritter: Yes it does, syntactic sugar, by definition is "some syntax that gets desugared into some primitve/other form"
00:40:39 <lritter> let's say it's semantic sugar ;---)
00:40:45 <merijn> lritter: $ is not that, it's a function, which is why
00:40:50 <merijn> :t map ($'c')
00:40:52 <lambdabot> [Char -> b] -> [b]
00:40:59 <merijn> is a perfectly fine and sensible thing to write
00:41:12 <lritter> haskell's infix support is syntactic sugar, everything you write on top is then washed "clean" ;-)
00:41:26 <KudzuCrab> is Haskell compatible with DDD? I am reading DDD and I see a lot of patterns aren't neccessary with FP (Factory for example), but is there anything we can reuse from DDD for Haskell?
00:42:02 <merijn> I don't even know what "flavour-of-the-month" methodology DDD is
00:42:04 <hukey> can you declare variables in haskell?
00:42:17 <merijn> hukey: Define declare and variables :p
00:42:44 <hukey> I meant, can you assign a value to a symbol?
00:42:58 <merijn> hukey: Haskell has variables in functions (but in the mathematical sense that their values van vary between applications, not vary within a single application)
00:43:11 <hukey> Of course it will be inmutable
00:43:11 <dredozubov> i'd decline some variables
00:43:17 <merijn> hukey: You can give values names, but you can't change the value associated with a name
00:43:19 <Cale> hukey: You can write things like  x = 10
00:43:40 <KudzuCrab> merijn: well, personally I think it is clunky and over complicated, but my employer told me to learn it
00:43:41 <hukey> so it's more like constants
00:44:00 <Cale> hukey: right
00:44:20 <hukey> I think this is obvious, but can you do recursion in haskell?
00:44:24 <Cale> yes
00:44:53 <merijn> KudzuCrab: I still don't know what it is, so it's tricky to answer "can you do that in haskell?"
00:44:57 <Cale> > let f 0 = 1; f n = n * f (n-1) in f 10
00:44:59 <lambdabot>  3628800
00:45:04 <merijn> hukey: You can even do kinds of recursion you can't in other languages
00:45:12 <hukey> you know it would be useful to have like a .js version and .hs of a program to compare
00:45:12 <merijn> > let ones = 1 : ones in ones
00:45:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:45:45 <Cale> hukey: Note that Haskell *also* has mutable references and datastructures of various types, but their use is somewhat restricted.
00:46:13 <kadoban> neuroserpens: I gotta sleep ... in the interests of giving you an example in case you're having trouble, here's a simple one (again, not for general use, but it's fine for crap programming competitions):
00:46:14 <hukey> also do you use promises / futures in haskell? and what other common deisgn patterns are popular in the community?
00:46:15 <Cale> hukey: I could give you a joke answer to that :D
00:46:21 <kadoban> :t BSC.interact (BSC.pack . show . {- put your function here . -} map (fst . fromJust . BSC.readInt) . BSC.lines) -- neuroserpens
00:46:22 <lambdabot> IO ()
00:47:09 <kadoban> It's hard to overstate how bad the lack of error-handling is there, but ... it doesn't matter for those kind of problems.
00:47:30 <merijn> hukey: We have proper multithreading and concurrency, does that count? :p
00:47:34 <Cale> hukey: This Haskell http://cale.yi.org/piecetest/source.hs corresponds to this Javascript: http://cale.yi.org/piecetest/source.jsexe/out.js
00:47:35 <Cale> :D
00:48:26 <merijn> hukey: And then people can just implement things like async (which, imo, works better than any promise/future library I've seen in other languages)
00:48:30 <dredozubov> Cale: i was thinking of compiling one myself for the sake of this answer, haha
00:48:31 <tejing> Cale: gee, helpful >.>
00:48:39 * hackagebot language-kort 0.1.0.0 - Parser and serializer for the Kort information language.  http://hackage.haskell.org/package/language-kort-0.1.0.0 (akrasner)
00:48:44 <Cale> tejing: I did say it was a joke answer
00:48:45 <dredozubov> async is nice
00:48:55 <hukey> by async do you mean javascript async await thing?
00:49:07 <tejing> Cale: I know :-)
00:49:27 <hukey> so haskell has language support for concurrency... amazing.
00:49:33 <merijn> hukey: No, I meant the haskell async library
00:49:35 <merijn> @hackage async
00:49:36 <lambdabot> http://hackage.haskell.org/package/async
00:49:46 <hukey> but is this like go-coroutines?
00:50:12 <hukey> like I can just write seemingly synchronous code, but its actually async
00:50:14 <merijn> hukey: GHC has lightweight threading like Go's goroutines/erlang processes (probably GHC threads are more lightweight than those, you should certainly be able to have like 100k or more threads easily)
00:50:33 <hukey> that's amazing
00:51:13 <merijn> hukey: In fact, it works so well that when GHC 7.8 got a new IO manager it magically made every multi-threaded programming much faster, without anyone changing their code :p
00:51:28 <hukey> that's crazy
00:51:30 <Cale> Yeah, the number of threads you can have is limited by the amount of memory you have to store them (most of the memory cost of a thread is the memory associated to its stack, and the default size for that is about 1k)
00:51:49 <Cale> also, I suppose, by the amount of scheduling overhead you'd like to incur
00:51:52 <hukey> it seems then that concurrency is pretty much an out of the box thing with haskell
00:52:00 <Cale> It does get more expensive to schedule that many running threads
00:52:07 <hukey> as long as your functions are pure, but then haskell does not allow you to have impure functions right?
00:52:20 <merijn> hukey: Yes, just "import Control.Concurrent (forkIO)" and then
00:52:21 <Cale> Not impure *functions*
00:52:36 <Cale> There are IO actions which are allowed to have effects when they are executed
00:52:45 <Cale> However, execution is not done as the result of evaluation
00:52:47 <hukey> so these functions do not return anything?
00:52:49 <Cale> Only the other way around.
00:52:52 <tejing> hukey: technically all code written in haskell is purely functional, but people often refer to monadic constructs as impure
00:53:01 <hukey> or right, they return the IO monad thing ... 
00:53:47 <dredozubov> tejing: this notion is absurd
00:53:53 <Cale> What would be an impure function A -> B in some other language is expressed as a pure function A -> IO B, where values of type IO B are essentially descriptions of things which could be done to produce a result of type B
00:54:19 <hukey> I see, so they are indeed pure functions according the definition
00:54:20 <Cale> (and in the meantime, perform any sort of effects your computer can manage)
00:54:26 <dredozubov> "monadic-ness" does not correlates with "pureness" at all
00:54:28 <merijn> hukey: "IO a" is not a function :)
00:54:46 <merijn> hukey: And "a -> IO b" is a pure function that returns an 'IO b', not an impure function
00:54:52 <merijn> Oh, bah, Cale beat me to it
00:54:54 <hukey> I mean ` A -> IO B`
00:54:54 <Cale> Yeah, for the same value of type A, you'd get the same IO action, but then executing that IO action is allowed to produce many different results of type B for any number of reasons.
00:55:01 <hukey> Mmmmm
00:55:03 <dredozubov> "IO a" is a computation which may(or may not) have IO-related side-effects and returns a
00:55:23 <merijn> @quote shachaf getLine
00:55:23 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
00:55:30 <hukey> what would be a similar thing / design / pattern in an multi paradigm lang like js?
00:55:38 <dredozubov> you may think of it as a description of this computation
00:55:48 <Cale> hukey: Also, these IO action values are first class - you can pass them around to functions, store them in data structures, and so on without any worry that the effects will go off prematurely.
00:55:59 <Cale> (because their execution has nothing to do with evaluation of expressions)
00:56:31 <hukey> I feel this is somewhat similar to how futures are the description of a computation that will happen in the future but returns a value inmedietaly letting me compose my code without caring about how the computation may or may not occur at once
00:57:08 <dredozubov> haskell is lazy, so you can think of anything as a future
00:57:10 <Cale> So, I can write a function like  times :: Int -> IO a -> IO [a]  which given a number and an IO action, produces another IO action which will run the given action that many times, and collect a list of the results
00:57:19 <tejing> I found free monads extremely helpful in understanding how to think about values of type 'IO a', since they provide a plausible implementation that justifies calling a vlaue of type 'IO a' _data_
00:57:20 <Cale> (in fact, the standard name for that is replicateM)
00:57:52 <hukey> Cale: OK, but when does stuff actually runs?
00:57:54 <merijn> hukey: There's no reall convenient way of translating this to, say, JS. As the way IO is done in haskell is one of it's unique strengths
00:58:16 <merijn> hukey: "main :: IO a" <- main is an IO action, rather than a function and the runtime system runs that for you
00:58:18 <Cale> hukey: In a compiled program, you define an IO action called main, and main is executed when your program runs.
00:58:21 <dredozubov> tejing: yep, this is one way to put it
00:58:32 <hukey> Like with promises I know they will run when I either run their `.then()` method or inside of a go-routine like structure when I yield .
00:58:34 <Cale> hukey: In turn, it may explicitly execute many other actions
00:59:25 <generalbaguette> tejing: the other approach is to understand IO a as State RealWorld a
00:59:41 <merijn> generalbaguette: That's a bad model :\
00:59:48 <generalbaguette> Why?
00:59:50 <tejing> yea, that works too, but it always felt slightly hackish to me
00:59:52 <generalbaguette> That's how it's implemented.
00:59:53 <Cale> hukey: Since we're talking about concurrency, there's also  forkIO :: IO () -> IO ThreadId  which is a function that given an IO action (producing an empty tuple as its result), produces an IO action which immediately forks a new thread to run that action, returning the ThreadId of the new thread as its result.
00:59:54 <frerich> hukey: It's indeed similiar to what other languages call futures, promises, runnables. An important difference is that in a Haskell programm, you cannot actually execute IO actions. You can merely combine them, yielding a larger action.
00:59:57 <merijn> generalbaguette: Simple question: When I forkIO, do I split the universe?
01:00:16 <hukey> OK, so this stuff is transparent in haskell apparently you dont even need to worry about when this occurs, and everything is like a big recipe of what should happen 
01:00:23 <Cale> frerich: Well, depending on what you mean by "in Haskell"
01:00:31 <generalbaguette> merijn: In some sense, yes.  You duplicate your realworld object.
01:00:43 <Cale> IO actions are allowed to execute other IO actions as part of their own execution :)
01:00:54 <hukey> This is so exciting
01:00:56 <merijn> generalbaguette: Which entire breaks the entire metaphor, because then how come I can observe changes made in other RealWorlds?
01:00:58 <generalbaguette> Cale: and that's actually the only way to get sequencing.
01:01:27 <merijn> Man, some days I really wish GHC picked a different name for it's implementation of IO
01:01:29 <generalbaguette> merijn: Don't confuse RealWorld with the physical universe.
01:01:55 <generalbaguette> At Standard Chartered we also had ReadOnlyIO.
01:02:06 <Cale> generalbaguette: The way it's really implemented in GHC doesn't really use RealWorld in the way that it's meant in the analogy. In GHC, RealWorld is a 0-byte-wide token type and it just implements everything with impure functions.
01:02:09 <merijn> generalbaguette: Telling beginners to think of IO as "State RealWorld" is *exactly* what makes beginenrs think of the physical universe, which is why it's such a terrible explanation
01:02:42 <hukey> Do I have to worry about weirdos like trampolines in haskell? I am not a big fan of scala
01:02:44 <generalbaguette> merijn: Probably true.  I learned Clean's linear typing based approach first, so that's probably why it worked for me.
01:02:50 <hukey> but I find haskell extremely interesting
01:02:52 <generalbaguette> hukey: not really.
01:02:56 <Cale> There is no definable type RealWorld (even in principle) for which IO a is isomorphic to RealWorld -> (RealWorld, a)
01:02:58 <dredozubov> hukey: no
01:03:19 <dredozubov> trampolines exist to address problems you don't have in haskell
01:03:29 <generalbaguette> hukey: You can define trampolines, if you want.  But you generally don't need to
01:03:33 <bernalex> what are trampolines? out of interest. IDK scala very well.
01:03:35 <merijn> generalbaguette: If you understand the implementation enough to realise that RealWorld is not a reference to the REAL world, then you no longer need explanations/metaphors. And the people who do need metaphers/explanations really should not ever hear the term RealWorld because it leads to think "RealWorld -> (RealWorld, a)" where RealWorld is the physical universe
01:03:41 <generalbaguette> hukey: Scala needs trampolines because it doesn't have tail call elimination.
01:03:56 <merijn> bernalex: A trick to make tail recursion not blow up the stack if you don't have TCO
01:04:19 <merijn> bernalex: They're a trick that gets used in imperative languages too, like C, etc.
01:04:20 <dredozubov> generalbaguette: exactly
01:04:20 <Cale> hukey: GHC Haskell doesn't even have a call stack, so...
01:04:25 <generalbaguette> There's some more advanced stuff where some sort-of trampolines make sense even in Haskell.
01:04:31 <generalbaguette> But their usage is transparent to the user.
01:04:40 <dredozubov> Cale: i belive you can simulate it with GHC.Stack
01:04:47 <tejing> Cale: technically it does use the stack, but only for pattern matches afaik
01:04:56 <dredozubov> but it's debugging related fun
01:05:01 <merijn> bernalex: https://en.wikipedia.org/wiki/Tail_call#Through_trampolining
01:05:05 <Cale> Yes, there is a stack, but it is not really appropriate to think of it as a call stack
01:05:09 <bernalex> merijn: ta.
01:05:10 <tejing> indeed
01:05:45 <generalbaguette> I'm trying to rescue the full-sessions package.
01:05:50 <generalbaguette> It's succumbed to bitrot.
01:05:55 <merijn> bernalex: It's basically, instead of tail-calling, return a continuation to a while loop and call from there to avoid stackgrowth
01:06:16 <generalbaguette> by the way, how do you type a general trampoline?
01:06:16 <Cale> It's a stack consisting of pattern matches who are waiting for their scrutinee to be sufficiently evaluated to pattern match (and applications who are waiting for the *function* to be sufficiently evaluated to apply)
01:06:37 <merijn> bernalex: The idea being that you're constantly going up only a single stack level, then back down, back up, back down, etc. like bouncing on a trampoline
01:06:37 <dredozubov> interesting
01:09:47 <hukey> <generalbaguette> Scala needs trampolines because it doesn't have tail call elimination > Exactly!
01:10:40 <hukey> So how does  tail call optimization is handled in haskell? can I just make beatiful recursive functions and trust GHC?
01:11:10 <tejing> hukey: there's no stack to run out of space on in haskell... just make recursive functions to your heart's content
01:11:37 <hukey> can you do regex in haskell?
01:12:06 <hukey> tejing: Something tells me I need to look deeper into this. That sounds incredible :D
01:12:07 <merijn> hukey: Depending on your point of view either ALL calls are tail calls in haskell or NO calls are tail calls
01:12:29 <merijn> hukey: i.e. "does haskell do TCO?" is a rather meaningless question
01:12:46 <hukey> or rather how does regular expression work in haskell or does that even make sense?
01:13:00 <merijn> Because the way haskell is implemented in GHC means it doesn't make sense to ask that question
01:13:11 <merijn> hukey: regular expressions are rather unpopular in haskell circles
01:13:35 <bernalex> despite having some pretty cool libraries for it :)
01:13:36 <merijn> hukey: There's several really easy parser combinator libraries that make it really simple to write parsers, so people prefer writing proper parsers to using regexes
01:13:38 <tejing> hukey: you can actually write full-fledged parsers quite easily in haskell, so regexes don't get as much use
01:13:39 <tdammers> you can use some regular expression library though
01:13:48 <tdammers> but they're not built into the language, nor used a lot
01:14:35 <tdammers> regular expressions are very limited compared to a full-fledged parser, the only reasons why people use them anyway are performance and ceremony
01:14:54 <tdammers> i.e., in most languages, regular expressions are faster and easier to write than equivalent parsers
01:15:17 <tdammers> but in Haskell, the performance difference is much smaller (given such excellent libraries as attoparsec)
01:15:46 <tdammers> and the ceremony is near-absent, writing a proper parser isn't much harder than writing a regular expression, and the parser code is going to be *much* easier to read
01:16:00 <merijn> I would say writing proper parsers easier
01:16:25 <merijn> Because I don't have to remember which magical characters to escape in this version of regexes >.>
01:16:27 <Axman6> hukey: once you start using parser combinators, you won't go back to parsers. they're more powerful, and infinitely more maintainable
01:16:28 <tejing> and proper parsers have added type safety benefits
01:16:29 <tdammers> depends on the use case, but yes, eventually the parser is going to be easier
01:16:48 <merijn> Axman6: Don't you mean "won't go back to regexes?" :p
01:16:55 <tdammers> but the most whopping advantage of the parser is that you're not limited to character streams and string matches as your only data types
01:17:02 <Axman6> uh, yes
01:17:17 <Axman6> Friends don't let friends use regexes
01:17:23 <tdammers> regular expressions only ever parse strings, and they only ever return string-based result sets
01:25:02 <generalbaguette> tdammers: You can spice up regexes to parse more than strings.
01:25:10 <generalbaguette> I am working on regular parsers.
01:25:30 <generalbaguette> (Using parser combinators.)
01:26:38 <tejing> sometimes I still think the most mind-blowing thing about haskell is really just the lazy evaluation plus recursion: fibs = 1:1:zipWith (+) fibs (tail fibs)
01:28:38 <tejing> after a while programming in haskell you take it for granted, but you have no hope of writing anything like that in almost any other language
01:29:16 <merijn> tejing: You forgot about "Whoo! -XKitchenSink extensions!" :p
01:29:20 <liste> @hackage regex-applicative
01:29:20 <lambdabot> http://hackage.haskell.org/package/regex-applicative
01:29:28 <merijn> That part is pretty mind-blowing too ;p
01:29:29 <liste> generalbaguette something akin to that?
01:29:40 <generalbaguette> merijn: mine is better.
01:29:42 <tejing> lol
01:29:47 <generalbaguette> Mine support complement.
01:30:28 <generalbaguette> https://github.com/matthiasgoergens/redgrep
01:30:33 <generalbaguette> But still work in progress.
01:30:45 <generalbaguette> I only recently got rid of a nasty exponential blow-up.
01:30:49 <generalbaguette> Now it's nice and linear.
01:31:42 <generalbaguette> merijn: apropos, I should talk to Roman, the author of the regex-applicative package, again.
01:34:28 <liste> Roman's other stuff is impressive too
01:35:29 <generalbaguette> It is.
01:35:51 <generalbaguette> I'm just giddy I made complement and intersection work, when he thought and said one probably couldn't. :)
01:45:06 <cj3kim> hello!
01:49:24 <cj3kim> Is haskell good for writing DSLs? 
01:50:09 <merijn> cj3kim: Yes!
01:50:11 <bernalex> cj3kim: yes.
01:50:20 <merijn> It's all we do :p
01:50:28 <tejing> haskell is good at being good at things :-)
01:50:45 <merijn> We're like lispers, accidentally inventing (E)DSLs all over the place :p
01:51:07 <bernalex> well sometimes *we* actually do it on purpose
01:51:27 <cj3kim> I'm hovering between clojure and haskell and i'm leaning more towards haskell now because of the type system and java-less environment.
01:51:34 <fvgvxmpv1> )
01:52:26 <benma> cj3kim: "Is haskell good for writing DSLs?" => omg yes
01:52:41 <bernalex> cj3kim: well, we do have a better type system, and none of that icky java business.
01:53:24 <whiteline> monads are like dsl types
01:53:41 <cj3kim> bernalex: yes :) i've also read it has a good power/weight ratio in terms of reuseability and maintenance
01:54:08 <bernalex> cj3kim: guilty as charged.
01:54:13 <cj3kim> which is very attractive to me since that is not the case for a lot of the code i've written
01:55:23 <cj3kim> some of you sounded like you were lispers at one point in time. why the change?
01:56:09 <whiteline> you can't build large-scale reusable stuff in lisp
01:56:16 <whiteline> or at least it's very hard
01:56:18 <Chousuke> In haskell it feels like there's a culture of making neat little abstractions for everything.
01:56:35 <whiteline> i'm not skilled enough to do it properly at least
01:56:39 <cj3kim> any good books?
01:56:57 <bernalex> cj3kim: btw the ease with which haskell scales, and the maintability of large-scale haskell applications are the two biggest and most important practical advantages I get out of haskell.
01:57:02 <cj3kim> thank you for your responses so far btw
01:57:48 <bernalex> @where learnhaskell
01:57:48 <lambdabot> https://github.com/bitemyapp/learnhaskell
01:57:54 <bernalex> cj3kim: for tutorials etc ^
01:57:55 <Chousuke> and a large part of the programming effort is recognizing which of those abstractions are applicable to your problem :P
01:58:26 <cj3kim> bernalex: i'm currently doing a lot of python and node js. is there a nice haskell rpc library i can spin up so i can start integrating haskell into my current work flow?
01:58:52 <cj3kim> Chousuke: cool :)
01:59:02 <bernalex> cj3kim: I don't do any of that stuff, so I would not know. I have done REST servers with scotty/wai/warp, and that's about it for web stuff for me.
01:59:34 <cj3kim> ah, okay 
01:59:49 <frerich> Chousuke: I guess another large part is recognizing which abstractions are applicable but inappropriate for your problem. :-}
02:00:15 <Chousuke> cj3kim: don't be put off by the abstract names though, many things only sound difficult. :P
02:00:20 <solatis> anyone has some tips on good strategies for enforcing a certain coding style for Haskell under emacs, preferably not stylish-haskell ?
02:00:32 <solatis> (stylish-haskell seems way too limited)
02:00:34 <Chousuke> frerich: certainly
02:01:02 <Chousuke> frerich: but I think that's the part that comes with experience :P
02:01:23 <cj3kim> Chousuke: definitely :) ie the name 'parametric function' sounds very complex, but it's actually a very simple concept ( just learned about )
02:02:55 <whiteline> solatis: how rigid is it?
02:03:06 <bernalex> solatis: communication and enforced review (disallow authors from pushing).
02:03:20 <cj3kim> btw, is asynchronous eventing built into haskell?
02:04:35 <merijn> cj3kim: You mean like epoll/kqueue?
02:04:35 <cj3kim> *answered own question
02:06:47 <codygman> cj3kim: What RPC libraries do you use in Python?
02:06:50 <liste> also, GHC has lightweight threads
02:06:55 <cj3kim> merijn: not sure, will repose question when i have done some more due diligence
02:07:01 <codygman> solatis: hindent might be what you want: http://chrisdone.com/posts/hindent
02:07:16 <solatis> codygman: thanks!
02:07:18 <pacak> cj3kim: ghc event manager is basically constructed around that idea.
02:07:48 <solatis> whiteline: stylish-haskell is very limited, only seems to do imports and breaks when you use template haskell
02:08:18 <merijn> cj3kim: GHC has preemptive lightweight threads and an IO manager that (un)schedules threads when they become blocked/unblocked doing IO
02:08:38 <cj3kim> codygman: none so far
02:08:56 <merijn> cj3kim: Basically, async eventing is a stupid hack to work around the lack of proper threading/thread management in many languages
02:08:56 <cj3kim> dnode for node
02:09:20 <Peaker> I have a big action in an IO-wrapping monad (that hides its IO capabilities), that I want to add debug traces to.  If I just do "trace foo (return ())" as monadic actions, it works - but only for the first time the action executes. Next time it executes that trace doesn't happen
02:09:35 <Peaker> Exposing the IO capabilities just to debug is a huge change to the codebase :(
02:09:39 <codygman> Does this look pretty clear or is there a better way to write this: matchesAll predicates = all id . (\x -> map ($ x) predicates)
02:09:51 <liste> Peaker traceM
02:09:53 <liste> :t traceM
02:09:54 <lambdabot>     Not in scope: ‚ÄòtraceM‚Äô
02:09:54 <lambdabot>     Perhaps you meant ‚Äòbraces‚Äô (imported from Text.PrettyPrint.HughesPJ)
02:09:56 <merijn> cj3kim: i.e. python lacks lightweight threads and OS threads are too expensive to use 1 thread per connection and node is single-threaded, which is why those need async eventdriven solutions
02:09:59 <cj3kim> merijn: ah, i see
02:10:02 <Peaker> The execution of this action doesn't seem to involve much evaluation at all (if any), so I am not sure any form of "trace" will work
02:10:27 <davean> cj3kim: though feel free to use continuations all you want :)
02:10:46 <merijn> cj3kim: Haskell has lightweight threads comparable to Go's goroutine/erlang processes (i.e. you can easily have >100k of them), so you just use one thread per connection and write naive, synchronous code
02:10:57 <solatis> merijn: isnt the real problem then the lack of lightweight threads for an OS ?
02:11:01 <merijn> cj3kim: The runtime system then manages scheduling/unscheduling threads that are waiting for IO
02:11:06 <Peaker> liste: traceM string = trace string $ return ()  <--  from the source
02:11:14 <Peaker> liste: this only works the first time this action is executed
02:11:14 <merijn> solatis: Lightweight threads for an OS make no sense
02:11:15 <davean> solatis: No
02:11:22 <davean> What merijn just said
02:11:26 <solatis> :)
02:11:46 <merijn> solatis: Task based concurrency might make sense at the OS level, so like OSX'/FreeBSD's Grand Central Dispatch
02:11:47 <solatis> let me think
02:12:21 <liste> Peaker is the monad newtyped?
02:12:23 <Peaker> http://lpaste.net/134726 <-- this sucks!
02:12:43 <Peaker> liste: yeah -- I can change the monad, but most of the code base just passes around a (Monad m) constraint, changing it all will suck
02:12:46 <solatis> yeah you're right, i have no idea what a lightweight OS thread would even look like
02:12:47 <liste> you could unsafeCoerce it to its original form and liftIO putStrLn there
02:12:54 <cj3kim> merijn: that sounds insane
02:12:57 <liste> it's a horrible hack though
02:13:14 <merijn> cj3kim: What does? :)
02:13:27 <liste> it would break when you change the monad stack
02:13:37 <cj3kim> merijn: the ability to have 100k > threads
02:13:39 <lpaste> echo-area pasted ‚ÄúConfiguring parconc-examples‚Äù at http://lpaste.net/134727
02:13:54 <cj3kim> i'm sold!
02:14:00 <cj3kim> you'll see me around a lot more :)
02:14:19 <davean> YOu can actually have a lot more then 100k
02:14:24 <merijn> cj3kim: Your basically limited by the amount of memory and threads start with only about 1kb of memory.
02:14:31 <echo-area> Hi, I had this issue when configuring Simon's parconc-examples.  How to resolve them?
02:14:48 <echo-area> Install the packages one by one?
02:14:58 <merijn> cj3kim: Obviously having more threads than cores is unhelpful in terms of speeding up computation, but if you're blocking for IO (i.e. most threads are idle most of the time waiting for IO) then it's no problem
02:15:18 <echo-area> Ah I see.
02:15:28 <dzack> is there a shorter/clean way to do something like "result <- somefunctions; case result of ..."
02:15:39 <echo-area> I thought cabal would automatically download dependencies
02:15:40 <liste> dzack >>= and LambdaCAse
02:15:49 <benma> dzack: yes, with LambdaCase
02:15:55 <cj3kim> off to bed
02:16:02 <cj3kim> thanks guys!
02:16:24 <benma> dzack: somefunctions >>= \case { foo -> bar; ... }
02:17:57 <dzack> ^^^ thanks, thanks, and thanks haha. trying it now - is lambdacase an extension you have to add to the language pragma?
02:18:15 <liste> dzack yes
02:19:57 <hkey_> Cole, frerich, Axman6, tejing, dredozubov, merijin => Thanks for your answers! and sorry if I missed someone. 
02:21:30 <dzack> yessss, that makes things so much cleaner and easier to read! thanks guys 
02:21:40 <Peaker> is it possible to create traceM that works every time, not the 1st time only?
02:23:11 * prem_muthedath
02:23:11 <merijn> Peaker: eta expand it with dumy () to force re-evaluation?
02:23:27 * jabbar
02:23:33 <jabbar> whois jabbar
02:25:28 <liste> let foo () = do { traceM "hi"; putStrLn "Bye" } <-- that works in my ghci (per merijn's suggestion)
02:26:01 <liste> looks suspiciously C though :D
02:31:05 <liste> and affects foo's signature :(
02:33:03 <Peaker> merijn: hmm.. I think GHC optimizes away (() ->)
02:33:31 <merijn> Doubt it, that would violate strictness
02:34:28 <Peaker> merijn: http://stackoverflow.com/questions/6208006/any-way-to-create-the-unmemo-monad
02:37:31 <tejing> is there some deep theoretical reason you can't disallow bottom as a value for types with only 1 constructor?
02:42:59 <davean> tejing: halting problem
02:43:33 <bernalex> & as spj said, "solving that is tricky".
02:43:47 <Peaker> tejing: that's called "unlifted products"
02:44:07 <mauke}> solving the halting problem is easy with a shotgun
02:44:33 <davean> mauke}: You say that, but some people still have mainframes
02:44:36 <Peaker> tejing: products don't have to be lifted, can have no bottom. That causes mainly 2 issues: A) Difficult to compile efficiently (pattern match of a tuple must create 2 new thunks)  B) The behavior of "seq" becomes problematic 
02:44:43 <Cale> Well, even an unlifted product type has a _|_, it's just that (x, _|_) and (_|_, y) are identified with it.
02:45:15 <Peaker> tejing: what is   foo x `seq` y     -- will it evaluate `foo x` enough to yield a result? If `foo` is polymorphic and instantiated at a tuple, suddenly this `seq` causes it to do nothing?
02:46:18 <litb> hello all folks
02:46:18 <Peaker> Cale: case unliftedProduct of (x, y) -> use x here..   can work on (x, _|_), so it's not really _|_ ?
02:46:46 <liste> seq evaluates the outermost constructor
02:46:48 <Peaker> unlifted products are kinda like generalizing newtype for multiple fields (single constructor)
02:46:49 <tejing> Cale: I would think it was just identified with (_|_,_|_)
02:47:09 <liste> > seq
02:47:10 <Cale> Ah, right, there's that
02:47:10 <lambdabot>      No instance for (Typeable a0)
02:47:11 <lambdabot>        arising from a use of ‚Äòshow_M2604064858333036680606‚Äô
02:47:11 <lambdabot>      In the expression:
02:47:22 <Cale> I was describing a strict product
02:47:24 <liste> > (undefined, undefined) `seq` "I work"
02:47:25 <lambdabot>  "I work"
02:47:48 <Peaker> liste: if products became unlifted, seq on a product would either force too little, or too much
02:48:10 <Cale> But yeah, that's how it goes :)
02:48:20 <Cale> There's still _|_, but it's the same as (_|_, _|_)
02:48:40 <Peaker> but I'd still prefer unlifted products and function spaces. The less _|_ hiding everywhere, the better
02:49:31 <Peaker> Cale: if pattern-matching on an unlifted type is a no-op, then _|_ is (_|_, _|_) because it is the least defined, but "case _|_ of .." no longer diverges
02:49:32 <merijn> Solving the halting problem is easy by going meta
02:50:04 <merijn> The halting problem just says you can't prove termination of a Turing machine, using a Turing machine. You can use a "super-Turing machine" to prove a Turing machine is halting
02:50:33 <merijn> i.e. I'm perfectly capable of proving termination for Turing complete code (with some complexity bounds for my feeble human brain)
02:50:34 <davean> I'll ring my local OEM
02:50:51 <apo__> merijn: if you go meta, can you bring me one of those? I'll pay for shipping
02:51:08 <tejing> it always bugged me that you need a lazy pattern match to make 'fix (\(a,b)->(1,a))' work
02:51:17 <merijn> I study "(mu meta) theory" :)
02:51:22 <tejing> other little related things bug me
02:51:43 <liste> but merijn are you a Turing machine?
02:52:03 <merijn> liste: Turing completeness of the universe's physical laws is an open question
02:52:10 <Cale> I'm not even a Turing machine, I'm a DFA.
02:52:24 <apo__> merijn: you just claimed that you're a super-Turing machine :p
02:52:43 <merijn> apo__: Those are not required to be a superset of Turing machines
02:52:54 <merijn> Cale: I just know how to type "auto" in Coq...
02:53:57 <merijn> This whole thing is similar to G√∂del's incompleteness theorem
02:54:08 <Zemyla> Is there an Unfoldable typeclass?
02:54:13 <merijn> It's not that you can't prove a system complete, it's just that you can't do it WITHIN the system
02:54:36 <merijn> Halting problem is not that you can't prove termination, it's just that you can't prove it WITHIN the system you're trying to prove termination for
02:55:13 <Zemyla> Something like unfold :: (Unfoldable t, Alternative f) => f a -> f (t a)?
02:55:42 <tejing> merjin: but if I can simulate your brain accurately with a turing machine, and your brain can prove termination of turing machines, then a turing machine can prove termination of a turing machine
02:55:52 <apo__> merijn: yes they are? If they're not a superset they're the same set or a subset, so a super-Turing machine would be a normal Turing machine... that is capable of solving the halting problem for Turing machines
02:56:07 <merijn> apo__: Why?
02:56:18 <Serpentine_> tejing: It just means that brains cannot solve the halting problem
02:56:19 <apo__> merijn: why what?
02:56:33 <merijn> apo__: Why does it have to have any overlap with Turing machines at all?
02:56:47 <tejing> Serpentine_: yes, presumably so. just making the point to merjin
02:56:50 <merijn> apo__: Why would you need something remotely resembling a Turing machine to prove termination of Turing machines
02:56:52 <apo__> merijn: oh, right.
02:57:06 <rom1504> "if I can simulate your brain accurately with a turing machine" maybe you can't
02:57:27 <merijn> tejing: That's why I said "if the laws of the physical universe are Turing complete is an open question"
02:57:43 <apo__> merijn: And you still said that you can solve the halting problem for Turing machines, which would make you a super-Turing machine in my books :p
02:57:47 <merijn> tejing: How would you "accurately" simulate a brain if there's no way to simulate the physical laws of the universe with a Turing machine
02:58:43 <merijn> apo__: I can do so for Turing machines up to finite size, I dunno if I can do it for arbitrarily big ones, because my brain is not that big. I'm not ruling it out, but then we get down to fundamental epistemological questions about the universe :p
02:58:55 <tejing> merjin: that's the point though... it's an open question. your claim of being able to solve the halting problem with your brain, if true, would solve it :-)
02:59:12 <apo__> merijn: but you can use external storage :p
02:59:33 <tejing> merjin: I can write a pretty short program I bet you can't figure out if it terminates :-)
02:59:52 <tejing> just encode the collatz conjecture as a termination problem
03:00:41 <apo__> tejing: it'll terminate when it runs out of RAM :D
03:00:54 <tejing> heh
03:01:31 <merijn> apo__: There's no time limit on termination proofs, so then you just reduce the termination proof to the proof of the collatz conjecture
03:01:47 <merijn> apo__: So there is *a* proof of termination, unless you can proof the conjecture unprovable
03:02:17 <apo__> merijn: the Collatz thing was tejing's idea
03:02:47 <merijn> eh, s/apo__/tejing
03:13:47 * hackagebot rest-core 0.36.0.5 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.36.0.5 (ErikHesselink)
03:16:41 * frerich thinks "I'm not even a Turing machine, I'm a DFA." would make for a terribly nerdy T-Shirt.
03:18:25 <aochagavia> hello, I am trying to solve cabal hell...
03:18:43 <aochagavia> I would like to use a specific version of the base package, other than the one I have installed
03:18:45 <aochagavia> is that possible?
03:20:44 <supki> aochagavia: no
03:21:03 <aochagavia> supki: so the only solution is to get an older version of ghc?
03:21:09 <supki> right
03:21:13 <lolisa> merjin, the idea of using an accelerated turing machine(zeno machine) to check turing completeness had been well known. However a zeno machine cannot do zeno maching halting problem.
03:21:28 <liste> aochagavia there's the version numbers: https://wiki.haskell.org/Base_package#Versions
03:21:47 <aochagavia> thanks!
03:23:48 <aochagavia> is the haskell platform still the recommended way of installing everything on windows?
03:24:01 <Peaker> Laziness is killing me now :-(
03:24:18 <Peaker> Well, actually, it is more the combination of laziness and terrible runtime inspection capabilities of GHC
03:24:32 <root____1> Is anyone having trouble install hdevtools with GHC 7.10?
03:24:37 <Peaker> I am having a really hard time understanding where my main thread is being "stuck"
03:24:41 <Peaker> (for seconds)
03:24:48 <Peaker> +RTS -xc doesn't show anything sensible
03:25:02 <sopvop> threadscope?
03:25:53 <Peaker> sopvop: I'll try that next, though it has some really annoying bugs (setNumCapabilities disallowed, cannot exit with exception, ..)
03:26:35 <litb> so literals like 1, 2, 3 do not have types?
03:26:54 <Haskellfant> they have type Num a => a
03:26:56 <Haskellfant> :t 1
03:26:57 <tejing> they have polymorphic types
03:26:58 <lambdabot> Num a => a
03:27:04 <litb> because it seems they just have type classes "Num ??" without being determined to a specific type
03:27:26 <liste> root____1 how are you installing it?
03:27:29 <tejing> litb: a polymorphic type is still a type
03:27:55 <Haskellfant> the reason they don't have a polymorphic type is so that you can use 1 for int, double, float, integer, ‚Ä¶
03:29:45 <Haskellfant> s/polymorphic/concrete/
03:30:01 <tejing> Haskellfant: I was puzzling over that
03:30:18 <Haskellfant> tejing: I'm still waking up :)
03:31:46 <root____1> liste: on OS X, I simply `brew install ghc`'d after removing my old 7.8 binary
03:31:59 <root____1> liste: then, upgraded cabal-install using my old version of cabal
03:32:22 <liste> how does it fail?
03:32:25 <root____1> liste: then I removed the old binary and tried doing a `cabal install hdevtools` and it broke
03:32:28 <root____1> Hang on
03:32:49 <root____1> liste: Failed to install ghc-paths-0.1.0.9
03:33:23 <Walther> > let foo x | x%3==0 = "fizz" | x%5==0 = "buzz" |otherwise show x in foo 3
03:33:25 <lambdabot>  <hint>:1:65: parse error on input ‚Äòin‚Äô
03:33:57 <litb> ahh i see
03:34:14 <litb> so Num a => a    means that 1 has some type that is an instance of Num  ?
03:34:20 <tejing> yes
03:34:31 <litb> but that then is not a single type, but some kind of different thing 
03:34:33 <liste> it means that 1 can be ANY type that has Num instance
03:34:34 <litb> hm
03:34:40 <liste> not SOME type
03:34:46 <Zemyla> Is there a free theorem for unsafeCoerce?
03:35:41 <litb> or does it mean that it is a type whose characteristics are derived from the greatest common divisor of all its instances?
03:36:35 <litb> is there another example of an expression that has such a "polymorphic type"?
03:36:45 <tejing> litb: if the type system can't determine a unique instance for it at compile time it will default to something. I don't really know how the defaulting is decided though
03:37:02 <root____1> A default implementation can be specified when defining the type class
03:37:46 <litb> tejing: ah i see
03:38:59 <Peaker> I see the thread working threadscope, but I have no idea what it's doing
03:40:04 <tejing> litb: I could define a value 'x :: Num a => a; x = 5', then use it elsewhere in my code both as an Integer and a Rational, but the explicitly polymorphic type signature would be necessary (I think...)
03:40:26 <Peaker> I wonder if I gdb a Haskell executable, if I could somehow figure out where a particular thread is at
03:41:14 <Cale> tejing, litb: Yes, or turning off the monomorphism restriction
03:41:24 <tejing> yea, or that
03:43:21 <litb> Cale: ah i see
03:43:33 <litb> so just doing x = 5 will fallback to 5's default type
03:44:19 <tejing> litb: just doing 'x = 5' would try to find a single concrete type that satisfied all the criteria in the program
03:44:32 <Cale> The monomorphism restriction will apply, demanding that the type of x is not generalised, and then numeric defaulting will get applied, which will cause x's type to be defaulted to Integer
03:44:33 <tejing> litb: and report an error if it could not do so
03:45:11 <litb> ah
03:45:31 <litb> tejing: so if i previously said 5 ::Int, 5 ::Float
03:45:32 <Cale> Numeric defaulting basically exists as a concession to the fact that numeric literals are polymorphic, and sometimes it's annoying if they're still ambiguous by the time the whole module is examined.
03:45:37 <litb> then x = 5  will fail?
03:45:56 <litb> because 5 would satisfy incompatible criteria?
03:45:59 <tejing> litb: 'x = 5;y = x + (2 :: Integer)' will make x an Integer, 'x = 5;y = x + (2 :: Rational)' would make x a Rational
03:46:46 <tejing> litb: 'x = 5;y = x + (2 :: Integer);z = x + (2 :: Rational)' would throw a type error unless you put a polymorphic type signature on x
03:46:54 <Cale> litb: 5 isn't a variable or anything, it's an expression, so you're not allowed to *declare* its type, though you can annotate an expression with a type like Integer or Float without affecting anything but that one expression.
03:47:03 <litb> tejing: ah i see
03:47:05 <frerich> litb: 'let x = (5 :: Integer) :: Int' would fail
03:47:13 <litb> so just saying x = 5; will not yet make x polymorphic
03:47:28 <litb> s,monomorphic
03:47:52 <tejing> litb: just syaing 'x = 5' makes the type checker try to find x's type from hints elsewhere in the program
03:47:53 <Cale> litb: It would, if there weren't these other rules in place that specifically try to avoid type class polymorphism for things whose definitions look like they're intended to be constant definitions.
03:48:27 <Cale> If you add  {-# LANGUAGE NoMonomorphismRestriction #-}  to the top of your module
03:48:32 <Cale> and you define   x = 5
03:48:41 <Cale> then you'll get  x :: (Num a) => a
03:48:51 <Cale> (that'll be inferred)
03:49:21 <litb> so the monomorphism restriction is bad and should be disabled
03:49:48 <tejing> :t let x = 5;y = x + (2 :: Integer);z = x + (2 :: Rational) in (y,z)
03:49:49 <lambdabot> (Integer, Rational)
03:50:12 <tejing> hmm. expected that to complain
03:50:19 <Cale> litb: Well, it's somewhat obnoxious, but at the same time, consider something like
03:50:22 <Cale> x = product [1..10000]
03:50:42 <Cale> If you write this and it gets the polymorphic type, then it will be recomputed everywhere that you use x
03:50:45 <litb> :t (+)
03:50:46 <lambdabot> Num a => a -> a -> a
03:51:04 <Cale> Because it's really then a function of the dictionary of implementations of Num's methods
03:51:04 <litb> ah i see. bad thing aswell
03:51:53 <Cale> So the MR, while it's generally considered to be pretty obnoxious and many people do opt to turn it off, does protect you a bit from programs which would be unnecessarily slow.
03:54:00 <tejing> is the monomorphism restriction only for top level declarations?
03:55:07 <liste> tejing yes
03:55:16 <liste> there's let generalization for let/where
03:55:29 <Peaker> Trying to build bitmap-0.0.2 with GHC 7.10.1 -- panics
03:55:30 <tejing> ah, that explains why my example didn't work
04:02:31 <saulzar_> Hmm. I'm seeing errors like this:     ëeq1í is not a (visible) method of class ëEq1í  compiling linear - is that a ghc 7.10.1 thing?
04:05:48 <Cale> saulzar_: hmm, which version of transformers are you using?
04:06:11 <Cale> https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Classes.html -- it certainly appears to be a method of Eq1
04:06:33 <saulzar_> Hm
04:07:24 <Axman6> check the source and see if it's a) not ifdefed out and b) actually exported
04:09:26 <dzack> is it possible to use do notation when you're assigning a variable use cases?
04:09:27 <saulzar_> It's 0.4.2
04:09:46 <dzack> i.e. let var = case blahblah of
04:09:51 <dzack> a->Something
04:09:57 <dzack> b -> do something else
04:10:16 <saulzar_> Part of the try-reflex sandbox, seems to install linear just fine with my system installed 7.10.1
04:11:01 <dzack> I've tried to capture the idea here: https://gist.github.com/dzackgarza/47740e1d710377938afa
04:12:51 <saulzar_> instance Eq1 V0   where eq1 = (==)   <-  doesn't seem to be much ifdef'ed out 
04:19:14 <Cale> dzack: do-expressions are indeed expressions, and you can use them anywhere that an expression is expected, so long as the types work out
04:25:33 <dzack> I was thinking so - but how does haskell choose which value in the do expression to ultimately assign to the variable?
04:25:44 <dzack> do you have to manually specify it with return?
04:26:04 <mauke}> what do you mean by "choose"?
04:26:23 <mauke}> it's an expression, it has a (one) value
04:27:41 <Cale> dzack: The entire do-expression is itself a value
04:28:24 <Cale> (or at least, evaluates to one)
04:29:20 <Cale> If you wrote  foo = do ...  then it's *not* going to execute the do-block in order to determine foo. This literally defines foo to be such and such action.
04:29:42 <tejing> it's more akin to defining a subroutine than calling it
04:31:21 <Cale> Note: it's important to understand the difference between evaluation (reducing expressions to values, largely for the purposes of pattern matching), and execution (whose meaning is context dependent, but for IO, means to carry out the effects described by an IO action value)
04:32:32 <Cale> Evaluating a do-block which describes an IO action does essentially nothing visible, apart from making your CPU a bit warmer and putting it into a particular form in memory.
04:32:56 <dzack> Hmm, okay - in that case, is there a way to move the actual execution within the case expression?
04:33:13 <dzack> for example, if I do foo <- doSomeFunction outside of the case, things work fine
04:33:23 <Cale> Evaluation never causes execution of IO actions to occur
04:33:34 <tdammers> foo <- something -- on its own doesn't "do" anything at all, it's not even valid syntax
04:33:43 <Cale> (well, pretty much never, there are some weird exceptions, but we don't need to worry about them)
04:33:59 <tdammers> foo <- something; somethingReferringTo foo -- this would be valid, and meaningful
04:34:15 <Cale> dzack: do-expressions glue together multiple actions into a single action
04:34:18 <tdammers> but it's just syntax sugar for something >>= \foo -> somethingReferringTo foo
04:34:35 <Cale> It's perfectly okay to have a do-expression which is inside each branch of a case expression, for instance
04:35:25 <tdammers> but the line that contains the <- is tied to the do block it is in (or rather, the remainder of that do block that follows it)
04:35:44 <Cale> In that case, evaluating the case expression will basically only determine which of the actions is selected, without carrying out the effects described. Executing it will actually carry out those effects though.
04:35:46 <tdammers> it doesn't work like a variable assignment at all, even though the syntax and usage suggest it in a way
04:36:48 <Cale> v <- x inside a do-block means "execute the action 'x', and name whatever its result was 'v'
04:36:51 <Cale> "
04:37:40 <tdammers> ("name" within the scope of the remainder of the do block)
04:37:44 <Cale> right
04:38:33 <tejing> dzack: clearly differentiate subroutines (which can "do" things and require "execution") and functions (which map values to other values, and can simply be "evaluated") in your mind. You fairly obviously can't call a subroutine from a function, as then it wouldn't be a function anymore
04:38:43 <Cale> dzack: Is this helpful, or still confusing? :)
04:39:50 <dzack> Oh plenty helpful, I didn't realize there was much of a distinction
04:40:07 <Cale> dzack: Looking more closely at your code, I think you want to be careful to tell it to actually execute the action, like  someVariable <- case someMaybe of ...
04:40:47 <Cale> dzack: let someVariable = case ...  will just define a new action called someVariable, which *if it were ever executed* would do that stuff
04:40:48 <mauke}> tejing: oh man, that's hard if you're coming from perl. perl programmers use "function" and "subroutine" interchangeably
04:41:10 <tejing> mauke): pretty much all imperative programmers do I think
04:41:11 <Cale> dzack: You could then go on to execute it multiple times (and have the effects happen each time), or never.
04:41:49 <mauke}> I think it's only perl that calls them that, having a "sub" keyword and all that
04:42:12 <tejing> mauke): the term's a lot older than perl though
04:43:12 <mauke}> it's even worse if you look at traditional terminology in the docs. there "subroutine" = user-defined function, and "function" = built-in primitive, often with special syntax
04:43:38 <tejing> >.< I was trying for a helpful terminology... maybe it isn't
04:44:10 <mauke}> I think it's useful, it just depends on what you're used to (and how much unlearning that requires) :-)
04:44:13 <dzack> ^-- yep, the terms were synonymous in basic too
04:44:22 <dzack> gosub was basically calling a function
04:44:31 <hodapp> I thought in BASIC there was some tiny subtle difference... I just forget what it is.
04:44:53 <mauke}> yeah, that's the imperative definition of "function", which is basically a labelled block of code
04:45:17 <mauke}> hence "anonymous function" being A Thing
04:45:41 <voidzero> ‚Ñ¢
04:46:00 <Cale> hodapp: In some versions of basic, the difference was that functions would return a value, while subroutines would not.
04:46:24 <mauke}> ooh
04:47:03 <hodapp> Cale: that sounds about right.
04:47:04 <tejing> dzack: though you can't call a subroutine from a function, you can return a subroutine from a function, and you can glue them together to make bigger subroutines... this is how the do syntax, and monads in general, work
04:47:28 <mauke}> that reminds me, when I first started learning pascal, I thought the difference between a function and a procedure was that functions couldn't have side effects (I didn't know what a "side effect" was, but it seemed intuitively right)
04:47:54 <Cale> tejing: Reading that statement while thinking about BASIC was initially confusing :D
04:48:04 <tejing> hehe
04:48:09 <mauke}> I was disappointed when I found out the only difference was that x := blah(...) is invalid with procedures because they're not allowed to return values
04:49:07 <dzack> so what exactly happens when you have a pure function
04:49:19 <dzack> and do someResult <- pureFunction
04:49:34 <mauke}> all functions are pure
04:49:47 <mauke}> that would run in the ((->) e) monad
04:50:02 <mauke}> are you familiar with Reader?
04:50:19 <lolisa> what's the ((->) e) monad? havent heard about it...
04:50:24 <dzack> unfortunately not, although I've seen it used in a few places
04:51:13 <mauke}> dzack: Reader provides an implicit environment (which is just a value that it passes around for you)
04:51:27 <mauke}> you can use 'ask' to get the value
04:51:39 <tdammers> nothing really "happens" at all when you encounter a <- b
04:51:49 <mauke}> > runReader (do { x <- ask; y <- ask; return (x + y) }) 2
04:51:51 <lambdabot>  4
04:51:54 <mauke}> ok, this is a stupid example
04:52:24 <mauke}> runReader passes in 2 as the "environment", and every use of 'ask' accesses that value
04:52:57 <mauke}> > (do { x <- id; y <- id; return (x + y) }) 2
04:52:58 <lambdabot>  4
04:53:02 <mauke}> ~magic~
04:53:39 <mauke}> Reader is defined[1] as: newtype Reader e a = Reader (e -> a)
04:53:43 <mauke}> [1] not actually true
04:53:55 <mauke}> i.e. it's just a newtype wrapper around (->)
04:54:02 <mauke}> which is the type of functions
04:54:47 <mauke}> (Reader e) is an instance of Monad, and so is ((->) e)
04:55:01 <tejing> mauke}: not sure you're helping... Reader is a somewhat odd monad, as it has nothing to do with sequencing
04:55:22 <mauke}> IO is a somewhat odd monad, as it has to do with sequencing
04:56:09 <tejing> well most monads have something to do with sequencing, if you're imaginative enough in your definition of it
04:56:23 <mauke}> @undo do { x <- ask; y <- ask; return (x + y) }
04:56:23 <lambdabot> ask >>= \ x -> ask >>= \ y -> return (x + y)
04:57:03 <Peaker> Should it be possible that:  Map.size m `seq` x     will differ from:   (length . Map.keys) m `seq` x       (in terms of what it forces)?
04:57:18 <mauke}> there's only one obvious definition of (>>=) and return if you expand the types
04:58:02 <Peaker> I'm getting a very very different amount of forcing going on by these 2, but Data.Map is defined as strict on all fields except the values, so how could it possibly matter which of the above I use?
04:58:05 <mauke}> return :: (Monad m) => a -> m a where m = (->) e gives: return :: a -> (e -> a)
04:58:49 <mauke}> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b where m = (->) e gives: (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
04:59:06 <tejing> dzack: how much do you know about monads? you shouldn't be trying to use do syntax significantly without understanding what it's doing
05:00:01 * lolisa get -> e monad now
05:01:15 <lolisa> dzack, I'll recommend you to see them as simple abstract algebra stuff and deduct out how list and option are monad by hand. At least this route work for me
05:02:40 <dzack> very little at this point - a bit from lyah and rwh
05:03:01 <mauke}> what worked for me was ignoring the generalized "monad" machinery and just using/thinking in terms of specific instances, like IO/[]/Maybe
05:03:15 <dzack> and lolisa, that might actually help a lot - looking at it in mathematical terms would be really helpful
05:04:10 <lolisa> go try it than... I mean, monad is simple in abstract algebra sense, just 2 operation and a few law
05:04:33 <lolisa> If you know Coq that's even better because there are tons of monad formalization in Coq
05:04:39 <mauke}> it might be easier to use the definition with 3 operations
05:05:04 <mauke}> return :: a -> m a; fmap :: (a -> b) -> m a -> m b; join :: m (m a) -> m a
05:05:18 <lolisa> Yeah, I agree
05:06:18 <tejing> mauke}: the laws are most clear with return and (<=<) though
05:06:52 <mauke}> :t (<=<)
05:06:54 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
05:08:05 <mauke}> :t \f -> return <=< (return . f)
05:08:06 <lambdabot> Monad m => (a -> c) -> a -> m c
05:08:54 <mauke}> :t return <=< id
05:08:55 <Peaker> Data.Map.Strict using the base Data.Map type is problematic, since "fmap" will still be lazy, for example, causing the strict map to hold lazy thunk values
05:08:55 <lambdabot> Monad m => m c -> m c
05:09:00 <aweinstock> :t \f -> return . f
05:09:01 <lambdabot> Monad m => (a -> a1) -> a -> m a1
05:09:02 <aweinstock> :t fmap
05:09:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:09:30 <aweinstock> :t \f -> (>>= return . f)
05:09:31 <lambdabot> Monad m => (a -> b) -> m a -> m b
05:09:41 <mauke}> :t id <=< id
05:09:43 <lambdabot> Monad m => m (m c) -> m c
05:09:49 <tejing> mauke}: <=< must be associative and have return as its identity... those are the monad laws
05:10:12 <mauke}> feels weird to use, though
05:11:27 <mauke}> what bothers me is the (a -> m b) -> a -> ... part
05:11:42 <Cale> read it like: (b -> m c) -> (a -> m b) -> (a -> m c)
05:11:54 <Cale> It's like (.) but with some m's
05:12:07 <mauke}> it's obvious that it has to apply the function to the a
05:12:16 <Peaker> it seems like GHC's strict fields are broken in Data.Map in my use case! Computation is done when case analyzing only strict fields!
05:12:28 <mauke}> without requiring any monadic structure
05:12:30 <lolisa> A monad is just a monoid in the category of endofunctors, what's the problem? :)
05:13:25 <mauke}> glad you asked!
05:13:28 <mauke}> lolisa: http://www.carrot-programming.org/
05:14:43 * lolisa dont get it...
05:16:08 <tejing> mauke}: I also always found (=<<) more understandable than (>>=), though the latter is obviously preferable for formatting reasons
05:16:50 <Cale> lolisa: Or to put it more simply, a monad is just a lax 2-functor from the terminal bicategory to Cat.
05:17:35 <Cale> hehehe
05:18:54 * lolisa have no idea what that is :p stop doing cat theory a long time ago
05:19:49 <Cale> (I sort of know what it means, but I would have to look up the definitions and be very careful to actually be able to check that it's true)
05:20:25 <Cale> The monoid object in the monoidal category of endofunctors story isn't too bad though, once you know what monoidal categories are.
05:20:59 <lolisa> I have no idea neither... Just picked it up after the hilarious post
05:22:02 <niklaus> buffer 2
05:22:31 <Cale> The basic analogy being made is that whereas with a monoid in Set, you have a set M together with a multiplication mu: M x M -> M, and a unit element in M which since we're category theorists, we look at as an arrow from a one-element set, eta: 1 -> M
05:22:53 <Cale> ...and these have to satisfy certain laws you can write down with commutative diagrams...
05:23:26 <tejing> dzack: if you're still there, this simplistic implementation of an IO monad might help http://lpaste.net/134734
05:23:29 <Cale> In the case of a monad, you have a functor M: C -> C, and that has a "multiplication" which is a natural transformation mu: M . M -> M, where . there is composition
05:23:50 <Cale> and a "unit", eta: 1 -> M where 1 there is the identity functor
05:23:51 <tejing> dzack: the main thing to take away from that is that subroutines really can be considered data...
05:23:59 <Cale> In Haskell, mu is called join
05:24:00 <Cale> :t join
05:24:01 <lambdabot> Monad m => m (m a) -> m a
05:24:12 <Cale> You can see the two m's turning into one m there :)
05:24:18 <Cale> and eta is called return
05:24:20 <Cale> :t return
05:24:21 <voidzero> hmm
05:24:21 <lambdabot> Monad m => a -> m a
05:24:40 <voidzero> so my 'mu' response to comments might have been ambiguous
05:24:51 <Cale> and the commutative diagrams you need for the monad laws turn out to be exactly analogous to those for the monoid laws
05:24:53 <voidzero> https://en.wikipedia.org/wiki/Mu_(negative)
05:26:26 <ClaudiusMaximus> a post[1] on -cafe mentions record updates changing types breaks with phantom types - i tried role annotations but it seems to do nothing - would updating record update implementation to be aware of role annotations break a lot of stuff? [1]https://mail.haskell.org/pipermail/haskell-cafe/2015-June/120123.html
05:27:17 <ClaudiusMaximus> breaks some usage of phantom types, rather
05:28:47 <ClaudiusMaximus> or am i missing the purpose of role annotations? (the ghc manual focusses on generalized newtype deriving)
05:29:10 <quchen2> Expressing >>= with >=> is surprisingly awkward.
05:29:16 <Cale> quchen2: yeah, it is
05:29:43 <quchen2> I've never done it before, and now that I've tried I don't see why there shouldn't be an easier way ;-)
05:29:53 <mauke}> :t (id >=>)
05:29:54 <lambdabot> Monad m => (b -> m c) -> m b -> m c
05:30:29 <quchen2> :t \mx f -> (const mx >=> f) ()
05:30:30 <lambdabot> Monad m => m b -> (b -> m c) -> m c
05:30:39 <quchen2> That was my solution.
05:30:47 <tejing> :t flip (id >=>)
05:30:48 <lambdabot> Monad m => m b -> (b -> m c) -> m c
05:32:27 <Cale> ClaudiusMaximus: Well, to some extent it's obvious that the record update syntax would allow you to arbitrarily change the phantom type
05:33:05 <Peaker> trying to trace (show (vacuum x)) x   somewhere -- hangs, hmm
05:33:50 <Cale> ClaudiusMaximus: If you think about what it would desugar to, it will involve applying the data constructor again...
05:35:12 <ClaudiusMaximus> Cale: sure, was just idly curious if role annotations or something similar could change record update with a type inferred as phantom but annotated representational from   Foo a -> Foo b  to  Coercible a b => Foo a -> Foo b  or so (not sure of the details)
05:35:35 <Cale> ah, hmm
05:36:00 <Cale> I don't know whether there's any interaction between roles and record update, I suspect not at the moment
05:36:42 <ClaudiusMaximus> yep currently nothing happens
05:38:09 <hexagoxel> :exf -p "Monad m => (forall a b c . (a -> m b) -> (b -> m c) -> a -> m c) -> m a -> (a -> m b) -> m b"
05:38:10 <exferenceBot> flip . ($ id)
05:39:09 <hexagoxel> i.e. flip (id >=>)  :)
05:54:22 <saep> > join (+) 2
05:54:23 <lambdabot>  4
06:07:50 <lolisa> :t join
06:07:51 <lambdabot> Monad m => m (m a) -> m a
06:08:18 <lolisa> so what kind of monad is (+)...
06:08:35 <liste> lolisa it's (a ->)
06:08:40 <dramforever> lolisa: Reader
06:09:35 <kqr> what are the drawbacks of gloss for programming interactive light-weight simulations?
06:10:50 <Cale> kqr: That sounds like an almost ideal use-case for gloss :P
06:10:50 <liste> I guess gloss is designed for that
06:11:25 <kqr> so... what is gloss not made for that one reasonably might mistake for a use case for gloss?
06:12:18 <lolisa> OK, thx
06:12:41 <Cale> kqr: Well, gloss has some limitations in terms of the 2D drawing primitives that it provides. If you want to do really fancy graphics there's a point at which it'll probably become less than ideal.
06:13:50 <kqr> Cale, though it can load bitmaps from what it seems?
06:14:11 <Cale> kqr: yeah
06:14:24 <kqr> so where is the limitation? just inconvenience?
06:14:38 <kqr> (I guess that's always the case, but barring those extreme cases)
06:15:23 <Cale> Well, I don't actually know, I haven't tried loading lots and lots of bitmaps in a hurry from memory.
06:16:07 <Cale> Basically gloss is pretty good at what it looks like it'd be good at
06:16:20 <Cale> I'm not sure I'd want to write a big complicated game using it.
06:16:34 <Cale> But for something sufficiently simple it's fine
06:32:47 <hodapp> that's a little nonsensical... I'm getting "Non type-variable argument
06:33:04 <hodapp> ...in the constraint:" ...followed by a constraint that I didn't write, because it's inferred
06:42:33 * lolisa once get something similar in Coq... But forget what it is, probably something related to type class?
06:42:41 <fvgvxmpv1> I have something like the following: Identity [Identity x] and I¬¥m trying to build a lens ( http://hackage.haskell.org/package/lens-4.11 ) for x ‚Äî ‚Äò_Wrapped' . to (map $ op Identity)‚Äò works but doesn¬¥t seem‚Ä¶ pretty
06:42:56 <fvgvxmpv1> *works as a Getter
06:43:30 <fvgvxmpv1> *a lens (Lens' (Identity [Identity x]) [x])
06:51:52 <merijn> :t join . fmap sequence
06:51:53 <lambdabot> (Monad m, Traversable t) => m (t (m a)) -> m (t a)
06:52:03 <merijn> :t runIdentity . join . fmap sequence
06:52:04 <lambdabot> Traversable t => Identity (t (Identity a)) -> t a
06:52:24 <merijn> Oh, you want a lens, I'm not paying attention :p
06:52:43 <fvgvxmpv1> well, I have a lens now: lens (map runIdentity . runIdentity) (const $ Identity . map Identity)
06:52:50 <fvgvxmpv1> it¬¥s still not pretty, though ^.^
06:53:27 <fvgvxmpv1> I was thinking maybe ‚Äòbelow‚Äô might help, but I¬¥m underleveled in Cat-T
06:53:49 <c_wraith> :t runIdentity . join . fmap traverse
06:53:50 <lambdabot>     Couldn't match type ‚Äòt0 a -> f (t0 b)‚Äô with ‚ÄòIdentity c‚Äô
06:53:51 <lambdabot>     Expected type: (a -> f b) -> Identity c
06:53:51 <lambdabot>       Actual type: (a -> f b) -> t0 a -> f (t0 b)
06:54:04 <c_wraith> oh, whoops
06:54:08 <c_wraith> :t runIdentity . join . fmap sequence
06:54:09 <lambdabot> Traversable t => Identity (t (Identity a)) -> t a
07:01:50 <ion> @type iso coerce coerce :: Iso' [x] (Identity [Identity x])
07:01:51 <lambdabot>     Couldn't match type ‚Äò[]‚Äô with ‚ÄòIdentity‚Äô
07:01:51 <lambdabot>     Expected type: [x1] -> Identity [Identity x1]
07:01:51 <lambdabot>       Actual type: Identity x1 -> Identity [Identity x1]
07:03:51 <lamefun> Is there any guide on how should I name my stuff?
07:07:03 <fvgvxmpv1> documentation says coerce is for phantom types?
07:07:15 <Cale> lamefun: I dunno about a guide... apart from "use camelCase", I have a couple rules of thumb about naming (which really apply to any language). The names of variables ought to get longer as the scope in which they occur gets larger, and ought to be shorter the more frequently they are used. (So it's okay that e.g. fmap has a short name because we use it all the time, and it's okay for parameters to one-line function de
07:07:15 <Cale> finitions to be single letters because their entire scope is in clear view of the binder)
07:08:28 <Cale> lamefun: While something which you use infrequently and yet is globally available, you'd want it to have a longer descriptive name, since you're less likely to remember what it does, and then will have to look and find its definition.
07:08:53 <ion> @type iso GHC.Exts.coerce GHC.Exts.coerce :: Iso' [x] (Identity [Identity x])
07:08:54 <lambdabot> (Functor f, Profunctor p) => p (Identity [Identity x]) (f (Identity [Identity x])) -> p [x] (f [x])
07:10:01 <Cale> fvgvxmpv1: Pretty much -- it's a way to do a zero cost mapping between two types whose memory representation is identical (and where you could do that conversion in a more costly way by hand)
07:10:22 <ion> He was looking at the documentation for
07:10:27 <ion> @type coerce
07:10:29 <lambdabot> (Functor f, Contravariant f) => f a -> f b
07:10:37 <Cale> Oh, different coerce :)
07:11:01 <Cale> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Coerce.html -- I was talking about this one fwiw.
07:11:15 <fvgvxmpv1> indeed :) I¬¥m terribly afraid of Data.Coerce, though ^.^
07:11:31 <dramforever> IMHO it's pretty safe
07:12:02 <ion> It shouldn't involve anything that is unsafe to my knowledge.
07:12:03 <merijn> coerce is safe
07:12:09 <merijn> It's unsafeCoerce that's unsafe :p
07:12:30 <merijn> Well, if you do funky things you might need the correct role annotations to keep coerce safe. See the GHC manual on roles
07:15:51 <mniip> :o
07:15:59 <mniip> why is there a Comonad but not a Cofunctor
07:16:18 <mniip> with cofmap :: (f a -> f b) -> a -> b
07:16:44 * sopvop heard that functor is co-functor
07:16:50 <dramforever> :)
07:16:57 <dramforever> mniip: I mentioned it once
07:17:04 <dramforever> it seems useless
07:17:37 <dramforever> I think it would have to be iso to ((,) m) for some m but I'm not sure
07:17:47 <ion> @hackage acme-cofunctor
07:17:47 <lambdabot> http://hackage.haskell.org/package/acme-cofunctor
07:18:16 <Cale> huh?
07:18:19 <Cale> oh
07:18:20 <sopvop> ion: haha
07:18:33 <Cale> mniip: There's contravariant functors
07:18:43 <sopvop> :t contramap
07:18:44 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
07:18:51 <mniip> Cale, that's not it
07:18:55 <mniip> [17:15:12] <mniip> with cofmap :: (f a -> f b) -> a -> b
07:19:06 <Cale> A little different from what you're proposing, yes
07:19:11 <Walther> Why does simpleHTTP's "getResponseCode" reply (2,0,0) (a three-tuple)
07:19:18 <Walther> instead of say, 200 as int
07:19:43 <Cale> Walther: Because the digits are individually meaningful, it's probably useful to separate them
07:20:08 <merijn> Walther: 4xx is a class of codes, so what if I want to handle all 4xx codes in some way?
07:20:16 <Cale> Walther: e.g. matching (2,_,_) gets you all the successes
07:20:21 <Walther> heh, that's somewhat smart indeed
07:20:23 <merijn> Walther: Having a tuple makes it easy to just pattern match (4,x,y)
07:20:27 <Walther> didn't even think about it that way
07:20:41 <Hi-Angel> Is there a way to load a file into ghci so that the imports was loaded too? It is pretty boring to load a file, and yet every time get ´Not in scopeª after asking for a type :/
07:21:23 <ion> OTOH, (2,0), (4,16) might make even more sense.
07:21:27 <merijn> Walther: And now you can be glad someone took the time to think of this sensible idea ;)
07:21:39 <merijn> ion: Perhaps, I dunno if the 2nd digit is also meaningful for some classes
07:21:43 <Cale> Hi-Angel: uhhh... its imports should be available I think
07:21:51 <merijn> I forget, I'm not too up to date on the HTTP RFC
07:21:55 <ion> http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
07:22:18 <Cale> Hi-Angel: What does your file look like? Is there a corresponding .o hanging around and it's loading that?
07:23:06 <Walther> merijn: indeed
07:23:14 <Cale> Hi-Angel: If the compiled object code (.o and .hi) is available, ghci will load that, and you'll only have access to the explicitly exported stuff then, so if you didn't explicitly export the other modules, you wouldn't see them.
07:23:29 <ion> Hi-Angel: Does :load *File.hs help?
07:23:50 <Cale> Yeah, you can prevent this by loading with a * before the filename
07:24:04 <Hi-Angel> Ah, Cale, no, I'm loading a source code, i.e. .hs file. 
07:24:39 <Hi-Angel> And there are imports at the top, and if I ask a type of a function of these imports in ghci, it says, that not in scope
07:24:41 <ion> Hi-Angel: I don‚Äôt suppose you have -fobject-code set?
07:25:08 <Hi-Angel> HmÖ No, I didn't set this option
07:25:43 <Cale> That's weird, if you're in interpreted mode, ghci should give you access to everything that's in scope at top level in the module, including everything it imports and the things it defines but doesn't export.
07:26:27 <Cale> Are you sure the things you want to use are actually imported?
07:26:42 <Cale> I can't think of much else it could be
07:27:51 <Hi-Angel> Cale, yes, e.g. I have an import at the top, and I use functions of this in the Main. However, If I ask for a type after I did ´:load myfile.hsª, it says ´Not in scopeª, unless I am explicitly copy the import to the terminal line
07:28:07 <ion> Did you try :load *myfile.hs?
07:28:58 * hackagebot bitx-bitcoin 0.2.0.2 - A Haskell library for working with the BitX bitcoin exchange.  http://hackage.haskell.org/package/bitx-bitcoin-0.2.0.2 (tebello_thejane)
07:29:26 <Hi-Angel> ion, hm, yes, with the ´*ª it start working o.O
07:29:42 <Hi-Angel> How does it differ from an usual load?
07:30:40 <Cale> Hi-Angel: That forces interpreted mode when the .o and .hi are sitting in the directory
07:30:55 <Cale> Hi-Angel: If the .o and .hi exist, those are what ghci will load by default
07:31:10 <Hi-Angel> Ah, that's interesting. Thank you!
07:36:18 <Walther> > unlines $ simpleHTTP (getRequest "http://example.com") >>= getResponseBody
07:36:19 <lambdabot>  Not in scope: ‚ÄòsimpleHTTP‚ÄôNot in scope: ‚ÄògetRequest‚ÄôNot in scope: ‚ÄògetRespon...
07:36:37 <Walther> well, anyway. in ghci, I get weird type errors because IO
07:36:37 <dramforever> Walther: that won't work for 2 reasons
07:36:45 <dramforever> 1. types don't match
07:36:50 <dramforever> 2. lamdabot won't do IO
07:37:00 <dramforever> Walther: you can't just use unlines like that
07:37:18 <dramforever> do you know hoogle?
07:37:50 <Walther> unlines is [String] -> String, right, it's actually lines that I need
07:38:02 <dramforever> that still won't work
07:38:08 <Walther> yup, there's "Couldn't match type ‚ÄòIO‚Äô with ‚Äò[]‚Äô"
07:38:27 <Walther> ah. I need to punch it into a variable first
07:38:34 <Walther> a <- request; lines a
07:38:35 <dramforever> that's one solution
07:38:46 <dramforever> well, still not quite right
07:39:10 <Walther> hmm?
07:39:20 <lamefun> Is there any other way to make abstract interfaces (such as virtual file system supporting both real directories and ZIP archives) other than simply making a record of functions?
07:39:40 <tdammers> Walther: lines returns a [String], but you want an IO [String]
07:40:00 <tdammers> find a function that does [String] -> IO [String] and you're golden
07:40:33 <tdammers> lamefun: if it doesn't have to be extensible, you can also use sum types
07:40:39 <Walther> do I really want an IO [String]? in ghci, a <- simpleHTTP (getRequest "http://example.com") >>= getResponseBody; lines a; worked perfectly fine
07:41:14 <tdammers> where ; is a newline?
07:41:18 <tdammers> that's ghci magic
07:41:29 <Walther> so it won't work in compiled code?
07:41:31 <Walther> right
07:41:44 <tdammers> ghci does different things depending on whether what you typed is in IO or not
07:42:14 <Walther> (and yes, I was using ; as an implied newline)
07:42:22 <tdammers> if it's in IO, it runs it in an implicit do block; if it's not, it wraps it in a print
07:42:41 <tdammers> but that's only in ghci, and for convenience
07:42:50 <tdammers> in normal code, that won't work
07:43:17 <jerv_> when parsing JSON you've got this Object type which is a HashMap Text Value. I am wondering, given such a Value, how can I convert it to a specific type such that I can use it in functions?
07:43:33 <jerv_> like I know the Value is a String and I want to pass it to a function that expects a String
07:43:59 * hackagebot snaplet-sass 0.1.2.0 - Sass integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-sass-0.1.2.0 (lukerandall)
07:44:12 <tdammers> you could use the FromJSON instance of String
07:46:33 <jerv_> tdammers: could you elaborate a bit? New to haskell
07:48:02 <tdammers> jerv_: well, if you have a Value, and you need a String, use fromJSON
07:48:21 <tdammers> String implements FromJSON, so Value -> Result String is valid
07:48:34 <tdammers> just need to pattern-match on the Result to get the String out and handle any failures
07:49:47 <tdammers> case fromJSON myValue of { Error msg -> error msg; Success a -> a } -- something like that
07:55:22 <indiagreen> or you can just match on String
07:55:44 <indiagreen> case val of {String -> ...; _ -> error "but but I thought it would be a String"}
07:57:07 <tdammers> yeah, if you don't care about the actual error message, that would work ftoo
07:57:14 <indiagreen> if this all is happening inside a JSON parser, you can also use withText
07:57:39 <sebastard> Sometimes I accidentaly run a program in ghci on an infinite list: very soon my memory is full, the pc starts swapping and barely responds anymore. Is there a way to make ghci stop before the swapping of memory starts?
07:58:23 <tdammers> run in a VM, cap its CPU? :P
07:58:51 <Cale> sebastard: hit Ctrl-C?
07:58:52 <jerv_> I am playing around with it in ghci, I know my value is a String, but fromJSON val gives Error "when expecting a (), encountered String instead"
07:59:37 <sebastard> Cale: last time that only responded after minutes
08:00:02 <indiagreen> jerv_: yeah, because you also have to annotate it as ‚Äúcase fromJSON myValue :: Result String of ...‚Äù
08:00:06 <Cale> sebastard: If that doesn't respond immediately maybe try Ctrl-Z and kill %1
08:00:26 <indiagreen> wait
08:00:26 <indiagreen> no
08:00:27 <sebastard> basically, my entire terminal window does not respond anymore :(
08:00:29 <indiagreen> sorry
08:00:40 <indiagreen> can you just paste the whole expression?
08:00:54 <Cale> Ctrl-Z will often work in cases where Ctrl-C doesn't.
08:01:09 <sebastard> ok let me give that a try
08:01:45 <thorsten`> sebastard: did you accidentally Hit Ctrl-S? If so, you can unfreeze it by Ctrl-Q
08:03:57 <jerv_> indiagreen: I am trying something like this case val of {String -> fromJSON val; _ -> error "but but I thought it would be a String"}
08:04:28 <jerv_> but it's complaining Constructor ‚ÄòString‚Äô should have 1 argument, but has been given none
08:04:35 <indiagreen> that's pretty weird, yeah
08:04:40 <indiagreen> I mean, your code
08:04:52 <indiagreen> String is a constructor of Value (like Just is a constructor of Maybe)
08:05:15 * indiagreen notices
08:05:32 <indiagreen> ...you copied it from my message and I did the same mistake, ri-ight
08:05:50 <mauke}> isn't it just 'fromJSON val :: String'?
08:06:15 <indiagreen> mauke}: no, fromJSON returns a Result
08:07:01 <indiagreen> jerv_: so, it would be ‚Äúcase val of {String x -> ...; _ -> error ...}‚Äù
08:07:12 <indiagreen> and inside that case, ‚Äúx‚Äù would be of type Text
08:07:33 <sebastard> ok, it appears that C-z works a bit better indeed. But the entire window manager froze, so it was harder to get focus back to the correct terminal than it was to exit the program...
08:07:37 <indiagreen> if you want to just print it, for instance, or do something else that you do with Text, then that's enough
08:07:52 <indiagreen> if you need specifically String and not Text, you can convert it with unpack
08:08:08 <indiagreen> or you can use fromJSON like tdammers said
08:08:14 <Cale> sebastard: ah, that's a bit weird
08:09:27 <jerv_> thanks indiagreen, why is it of type Text though and not String?
08:10:17 <indiagreen> because Aeson's representation of JSON uses high-performance types, like Text and Vector and HashMap
08:10:50 <indiagreen> and the constructor is called ‚ÄúString‚Äù not because of Haskell's ‚ÄúString‚Äù type, but because that's how it's called in JSON's spec
08:11:08 <jerv_> so I still have to from Text to String though
08:11:12 <Cale> (and because String isn't taken, at the value level)
08:11:16 <jerv_> because my f expects String
08:11:31 <Cale> T.unpack
08:11:59 <indiagreen> Cale: hm, but Text already isn't taken
08:12:16 <Cale> Sure, it's also not taken :)
08:12:39 <jerv_> actually there is also a Text variant of the f! cool
08:14:12 <Cale> jerv_: Probably a good thing if you want your program to be fast. String can be convenient because it's a list of characters, but lazy linked lists of 32 bit wide Char values aren't exactly great for memory locality or compactness. :)
08:15:58 <Tril> sebastard if you use bash look up "help ulimit" or the ulimit section in "man bash"
08:16:58 <sebastard> I use zsh, but I did manage to find something of a working solution: https://stackoverflow.com/questions/3766656/#comment-3986811
08:18:47 <geekosaur> ulimit works roughly the same way in zsh (and ksh and other POSIX shell-alikes); it's csh that is unusual
08:18:56 <Clint> zsh also has limit/unlimit
08:19:19 <geekosaur> yes, because zsh likes to pretend to be csh :) but it's also got the more standard stuff
08:20:21 <quchen> kosmikus: What was the putting putting to good use to good use paper about again? I've been trying to find it because I remember the topic being interesting, but I can't remember enough for a successful search :-s
08:21:09 <Cale> sebastard: One thing I like to always have on my panel is a resource monitor which displays CPU, memory, net, and disk usage, so that when I suspect something is wrong, I can see what's going on.
08:22:08 <indiagreen> quchen: is this an actual paper name?
08:22:12 <quchen> Is the original the text by Weelden?
08:22:24 <quchen> indiagreen: kosmikus mentioned a paper like that existed, but it may have been a working title
08:22:33 <sebastard> Cale: I have that (xmobar), so that's why I knew it was swapping. :)
08:22:45 <quchen> indiagreen: I think it was supposed to be called "Putting 'Putting types to good use' to good use" or something along those lines
08:24:02 <Cale> sebastard: That example takes 20 or so seconds to run my system out of memory, so it's not so hard to catch before I start swapping, at least here :)
08:38:54 <augur> are there any really good tutorials on how to do proper, and elegant, precedence with parsec?
08:50:15 <tempname11_> is it possible for a "traceShow" to be seen every time the associated value is evaluated, not just the first time?
08:54:31 <tempname11_> I'm talking about this behavior: http://lpaste.net/134747
08:55:09 <tempname11_> Note that the "1" is not being printed after line 5
08:56:51 <mauke}> maybe like this: let two :: (Num a) => a; two = traceShow (1::Int) 2
08:59:09 <tempname11_> mauke}: I guess that works, but I only used the Int type as an example.
08:59:24 <shachaf> mauke}: Aha, another use for nullary type classes!
08:59:42 <shachaf> class N; instance N; let v :: N => Int; v = traceShow 1 2
09:00:29 <tempname11_> shachaf: I have to say this is a weird solution :)
09:14:26 <lamefun> Is there shortcut for data SomeLongSingleConstructorRecordName = SomeLongSingleConstructorRecordName, not to type the name twice?
09:16:03 <kadoban> lamefun: Make the name shorter? :)
09:17:48 <arw> lamefun: alternatively, use a cpp #define 
09:18:19 <lamefun> Isn't CPP bad/evil?
09:18:58 <arw> yes, of course. but so are overly verbose names for stuff.
09:19:02 * hackagebot cabal-debian 4.30 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.30 (DavidFox)
09:19:06 <quchen> CPP isn't evil per se, but here it's not a very good idea.
09:19:37 <quchen> Often it's a necessary evil, for example to maintain compatibility over multiple compiler versions.
09:20:00 <arw> lamefun: the other, more realistic and less fishy, alternative is using a plugin for your favourite editor/IDE that provides completions/suggestions
09:21:00 <arw> lamefun: I use youcompleteme for vim, but of course there is a whole heap of those things.
09:23:37 <Cale> lamefun: Just making the name shorter is pretty reasonable. Any name which is immediately irritating to type twice in a row is probably too long for its own good :)
09:25:31 <Cale> Heh, I'm reminded of how GAP names things
09:26:17 <Cale> It doesn't have a proper module system, so they end up giving really long names to things, and since it's aimed at mathematics, the names get pretty insane :)
09:29:30 <Cale> VectorSpaceByPcgsOfElementaryAbelianGroup -- at least it's not  VectorSpaceByPolycyclicGeneratingSeriesOfElementaryAbelianGroup
09:31:31 <Welkin> is http-streams-0.7.2.6 broken for anyone else?
09:31:37 <Cale> (but it's almost okay that some of the names are so long, because they're extremely special purpose and you're not likely to be using them all the time -- on the other hand it has things like SymmetricGroup which while much shorter is painfully long given how often you're likely to be using it in a language aimed at group theoretic computation)
09:31:52 <Welkin> I get compiler errors when building: Couldn't match type ‚ÄòData.ByteString.Builder.Internal.Builder‚Äô with ‚ÄòBuilder‚Äô
09:32:19 <Cale> Is that the exact message? No package qualifiers?
09:32:31 <Cale> I'll try building it
09:33:11 <Welkin> http://lpaste.net/134749
09:33:14 <Welkin> the full error
09:33:17 <ttt_fff> of the most common 'recursive' (i.e. can be arbitrary large) data structures, besides lists + trees, what shows up often?
09:33:40 <ttt_fff> of the most common 'recursive' (i.e. can be arbitrary large) data structures, besides lists + trees, what shows up often? [sets / maps are often just red-black trees, b-trees is tree-ish, ... ]
09:33:52 <kadoban> There's data structures not based on lists or trees? :)
09:34:51 <Welkin> ttt_fff: graphs
09:35:03 <Welkin> trees and lists are just special cases of graphs
09:35:05 <Cale> ttt_fff: Can you give any example of a recursive data structure which is not essentially some type of tree?
09:35:23 <ttt_fff> Welkin: well, graphs are more like (vector // list of nodes, + list // adjacency list) or (vector // list of nodes, 2d matrix // adjacency matrix)
09:35:33 <ttt_fff> Cale: I guess a list is just a 'degenerate' tree
09:35:35 <ttt_fff> hmm
09:36:32 <Welkin> Cale: did you get the same error?
09:36:37 <Cale> ttt_fff: You have syntax trees of all sorts. You have things like the free monad generated by a functor
09:37:00 <Cale> Welkin: oh, shoot, I didn't give an explicit version constraint and http-streams-0.8.3.3 built successfully
09:37:16 <asciiascetic> ttt_fff: I mean... isn't a cycle a recursive strucutre that is explicity not a tree?
09:37:36 <ttt_fff> Cale: where can I read up on 'syntax trees' ? I get https://hackage.haskell.org/package/syntax-trees which is not particularly insightful
09:37:53 <ttt_fff> Cale: is "syntax tree" just an AST from compiler land, or is this something else ?
09:38:06 <Cale> I just mean an AST
09:38:34 <Cale> like what haskell-src-exts gives you
09:38:47 <Cale> Welkin: 0.7.2.6 built successfully for me
09:39:00 <Cale> Welkin: (on GHC 7.10.1)
09:39:14 <Geraldus> hi friends! 
09:39:26 <Cale> Welkin: Could you perhaps give the output of ghc-pkg list ?
09:39:27 <Welkin> Cale: http://lpaste.net/134749
09:39:30 <phaazon> hey
09:39:34 <phaazon> do you we have a HID package?
09:39:38 <Welkin> it references specific version of bytestring
09:39:50 <Welkin> and blaze-builder
09:40:17 <Cale> Welkin: yeah, but it doesn't refer to more than one version -- do you have more than one version of bytestring installed?
09:40:30 <kadoban> phaazon: It's hiding
09:40:38 <phaazon> :D
09:40:49 <phaazon> there‚Äôs a HIDAPI package
09:40:50 <Cale> Welkin: and/or if you do ghc-pkg check, does anything come up as broken?
09:40:55 <Geraldus> I can find out supported GHC options and supported extensions running `ghc --show-options` and `ghc --supported-extensions` respectively.  But can I some how retrieve a list of supported pragmas, e.g. WARNING, DEPRECATED, LANGUAGE, and etc.?
09:40:56 <phaazon> but for no reason it doesn‚Äôt work on my laptop
09:41:09 <phaazon> like, enumerateAll returns an empty list :(
09:41:29 <Cale> Geraldus: I'm not sure that's an option. You can get them from the GHC User's Guide
09:41:37 <ttt_fff> So basically, in a very weird way, we can represent all data structures as: (1) something of finite size, or (2) data Rec a b = RecNode a | RecTree b (Rec a b) (Rec a b) // where a+b are either (1) finite or (2) Rec applied to something
09:41:47 <Welkin> Cale: http://lpaste.net/134750
09:41:49 <Geraldus> Cale: yeah, I just want to automate this stuff.
09:42:40 <Welkin> Cale: hc-pkg check only gives me warnings about haddock files not existing
09:43:35 <Geraldus> Cale: thanks anyway (:
09:43:36 <Cale> Welkin: hmm
09:43:53 <Cale> Geraldus: I wonder if there's a way to extract it from the GHC API somehow...
09:44:10 <Geraldus> so do I
09:50:03 <Cale> Geraldus: might be tricky, it lexes them into separate tokens, and the parser deals with them differently
09:50:32 <Cale> https://github.com/ghc/ghc/blob/master/compiler/parser/Lexer.x#L2545 -- there are a bunch of Maps in the lexer here for classes of known pragmas
09:53:43 <phaazon> ok, the HIDAPI library doesn‚Äôt work :)
09:53:47 <phaazon> I‚Äôm going to fix it
09:54:37 <Geraldus> Cale: thank you, at least now I have full list of possible pragmas, but I'm afraid I can't easily fetch this for Emacs.
09:55:23 <phaazon> ah, nevermind.
09:55:38 <Cale> Geraldus: So from parsing onward, pragmas aren't really a "thing" anymore, as they get turned into various sorts of annotation on the syntax tree, which means they won't likely be easy to get from the API
09:56:07 <tempname11_> shachaf: your solution with nullary type classes works well, thanks. can you elaborate a bit on why it works?
09:56:28 <Cale> Would be nice if GHC had that feature though, you might want to talk to the people in #ghc, and/or file a feature request :)
09:57:02 <Welkin> Cale: do you see anything strange?
09:57:07 <shachaf> tempname11_: Does it even work with -O?
09:57:15 <Geraldus> Cale: ok, I can just hardcode a list from documentation (https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/pragmas.html).
09:57:16 <Geraldus> Sounds reasonable.
09:57:27 <Cale> Welkin: not really :/
09:58:11 <tempname11_> shachaf: I haven't checked that yet. Give me a minute
09:58:43 <phaazon> yeah well, it‚Äôs broken.
09:58:45 <Cale> Welkin: Nothing seems repeated
10:20:17 <scb`> i'm trying to use parList with rdeepseq to basically quickly generate all the rows of a matrix (represented as [[Int]]). however im observing a large amount of time being spent doing GC... anyway I can improve on this?
10:20:54 <scb`> the time spent in GC make the naive implementation highly competitive with the non parallel one
10:21:29 <phaazon> hm
10:21:41 <phaazon> isn‚Äôt there a keyword in c2hs for alignment purpose?
10:21:48 <phaazon> like, #{alignment ‚Ä¶} ?
10:24:23 <tempname11_> shachaf: it doesn't with -O1 or -O2
10:25:44 <tempname11_> it might not matter for me, because I only need these traces in my development builds that are built with -O0, for fast compile times
10:25:47 <Peaker> scb`: perhaps use a Vector?
10:32:00 <shachaf> tempname11_: It's not a very reliable trick, but it might work for what you need.
10:33:04 <tempname11_> shachaf: yeah, a more robust solution would be nice. thanks anyway.
10:34:34 <tempname11_> I suppose it works because it generates a new 'thunk' for each function call?
10:35:31 <kqr> hey, a very general question. if I have a somewhat old haskell install and I want to bring everything up to date (ghc, base, cabal, cabal-install etc)... is there a sort of officially sanctioned upgrade path or do I have to wing it?
10:36:27 <shachaf> tempname11_: N => ... gets compiled into a function.
10:36:27 <kqr> unrelated: thanks for your help with figuring out that gloss is great for what I'm planning, cale
10:37:07 <tempname11_> shachaf: you mean, a hidden "instance" argument?
10:37:14 <shachaf> tempname11_: You could probably just use a function :: () -> Int instead
10:39:06 <kadoban> kqr: i would imagine you kinda have to wing it. Upgrading the tools is easy, just remove the old and install the new ... upgrading your code might be harder.
10:39:47 <kqr> kadoban, code is not a (significant) problem. i'm just curious how much can be pulled in with cabal, how much I have to compile manually, and stuff like that
10:39:54 <kqr> I have a very bad idea of how the whole eco system works lol
10:41:07 <Lutin`> Considering how easy it is to upload a package to Hackage, I haven't run into anything I can't get with cabal-install
10:41:23 <kadoban> kqr: If it helps, whenever I upgrade I just wipe out everything GHC and cabal and start again like this: https://gist.github.com/ion1/2815423  All I keep is my ~/.cabal/config . There's also other install instructions, like the ones linked from https://github.com/bitemyapp/learnhaskell
10:42:09 <kqr> kadoban, that looks like precisely what I was hoping to find!
10:42:19 <Lutin`> Also this https://www.haskell.org/downloads/linux
10:43:19 <Lutin`> Though it looks like that needs an update
10:44:06 * hackagebot shared-fields 0.1.0.0 - a tiny library for using shared lens fields  http://hackage.haskell.org/package/shared-fields-0.1.0.0 (Intolerable)
10:44:11 <Lutin`> also it appears I missed most of the conversation :D
10:44:22 <Lutin`> apologies if what I said was irrelevant
10:45:07 <kqr> no worries
10:45:08 <tempname11_> shachaf: I've tested it, and the extra () argument also works on -O0, but not -O2
10:45:23 <shachaf> tempname11_: Yep. It should turn into pretty much the same code.
10:48:13 <Lutin`> kqr: Ubuntu 14.10?
10:49:27 <kqr> Lutin`, debian jessie
10:54:41 <Welkin> I assume encodeUtf8 only works on strict to strict or lazy to lazy
10:54:55 <Welkin> so I need to call toStrict on a lazy bytstring if I want encodeUtf8 to produce a strict Text
10:57:31 <Welkin> > Data.Text.Encoding.decodeUtf8 (Data.ByteString.Lazy.singleton "haskell")
10:57:32 <lambdabot>  Not in scope: ‚ÄòData.Text.Encoding.decodeUtf8‚ÄôNot in scope: ‚ÄòData.ByteString....
10:57:58 <dmj`> Welkin: Data.Text.Lazy.Encoding 
11:00:07 <Peaker> Is it a good idea that forkIO inherits the masking state of the parent? Wouldn't it make more sense to have forkIOMasked for a masked thread, and generally allow threads created to be interrupted by default (even if parent shouldn't be)?
11:01:15 <Welkin> dmj`: that produces a lazt Text
11:01:18 <Welkin> lazy*
11:01:35 <dmj`> Welkin: yea, you'd still have to bring it back to strict :/
11:01:55 <dmj`> you're looking for a Data.Text.Lazy.Text -> Data.ByteString ?
11:04:07 * hackagebot keera-hails-mvc-solutions-gtk 0.0.3.4 - Haskell on Gtk rails - Common solutions to recurrent problems in Gtk applications  http://hackage.haskell.org/package/keera-hails-mvc-solutions-gtk-0.0.3.4 (IvanPerez)
11:04:29 <Welkin> I meant decodeUtf8
11:14:07 * hackagebot keera-hails-reactive-gtk 0.0.3.6 - Haskell on Gtk rails - Reactive Fields for Gtk widgets  http://hackage.haskell.org/package/keera-hails-reactive-gtk-0.0.3.6 (IvanPerez)
11:21:41 <sinelaw> Peaker, any progress?
11:22:22 <ion> Thanks to everyone who has linked <http://graphicallinearalgebra.net/>, i haven‚Äôt been enjoying a text as much as this one for a while. (It teaches linear algebra category theoretically in a very understandable way.)
11:46:06 <Peaker> sinelaw: I thought "performGC" call did the trick (showing it's just GC interaction stuff) but now with some other slight changes it no longer works as well that way :(
11:46:14 <Peaker> sinelaw: at least I found a different bug (relating to forkIO inheriting masking state)
11:46:46 <sinelaw> Peaker, did you try pinging dons/simonmar or opening a trac?
11:46:49 <Peaker> withForkedIO = bracket (forkIO ...) killThread <-- bad idea!
11:46:54 <Peaker> sinelaw: Got some help at #ghc
11:47:16 <Peaker> sinelaw: I think it is some sort of GC interaction, but GHC runtime inspection facilities are not good (At least when coming from the C world)
11:47:21 <Peaker> (or Python world)
11:48:07 <Peaker> sinelaw: btw: Now Lamdu lets you navigate between the different invocations of each lambda :)
11:48:10 <sinelaw> did you try fiddling with gc rts opts?
11:48:18 <sinelaw> cool!
11:48:32 <sinelaw> I looked at livec today, the dream awaits!
11:50:44 <Peaker> sinelaw: :)
11:54:09 * hackagebot floating-bits 0.3.0.0 - Conversions between floating and integral values.  http://hackage.haskell.org/package/floating-bits-0.3.0.0 (JonasScholl)
11:58:42 <cj3kim> hi, it pretty easy to do decimal calculations in haskell?
11:59:09 <ion> yes
11:59:25 <ion> Rational or Fixed for instance.
11:59:33 <ion> depending on what you want exactly
12:04:07 <cj3kim> ion: is it simply a matter of setting numeric type to be used for all calculations?
12:04:31 <cj3kim> or, do i need to pass in the type as I do the calculations?
12:04:55 <ion> @type (1.5 + 2.6) :: Rational
12:04:56 <lambdabot> Rational
12:05:01 <ion> @type (1.5 :: Rational) + 2.6
12:05:02 <lambdabot> Rational
12:05:12 <ion> You need to set the type *somewhere* but inference will take care of the rest.
12:05:21 <cj3kim> COOL! :D
12:05:29 <cj3kim> python makes this really hard :(
12:09:17 <ion> @type (+)
12:09:18 <lambdabot> Num a => a -> a -> a
12:10:01 <ion> Specifically, inference takes care of the rest because the operators have the same type ‚Äúa‚Äù as both inputs and the output. Set one to Rational and the others will be inferred as Rational.
12:11:36 <kqr> what's a good lightweight lens library? I know there are a few but I always forget their names
12:11:50 <mauke> lens
12:11:57 <ion> mauke++
12:12:15 <twopoint718> Does anyone have an idea if `type MapF a = Free (Data.Map Int) a` is a reasonable thing?
12:12:35 <kqr> I did say lightweight, didn't i :(
12:12:46 <cj3kim> ion:  thanks!
12:12:55 <twopoint718> ...the idea being roughly, an arbitrarily nested Map.
12:13:24 <ion> kqr: I have sometimes just specified over, view and the relevant lenses on my own based on things in base.
12:13:43 <kadoban> twopoint718: Like a trie?
12:14:02 <kqr> ion, thanks, but I'm looking for a specific library I know I've looked at in the past
12:14:11 <kqr> it's just so friggin hard to google for it because google just gives me lens hits
12:14:13 <kqr> like, the lens library
12:14:42 <kqr> maybe it was lens-family
12:15:09 <kqr> oh TIL hackage has a lenses category
12:15:38 <ion> You get a category by just typing something into category field in a package and uploading it.
12:15:42 <ion> AFAIK
12:15:42 <twopoint718> kadoban: I think? Just the idea of a structure that would (given JS-y syntax) be like: {'1': {'2': 3}}. But for any level of nesting.
12:17:51 <kqr> microlens also looks nice
12:19:51 <ion> So it does. It could use Data.Coerce.coerce though.
12:29:53 <rhaps0dy> heyo
12:30:05 <rhaps0dy> how much better is GHC than JHC, if it's better at all?
12:30:46 <rhaps0dy> I'm looking to write a small Android game in Haskell, and I have jhc with NDK working, is it worth to go through the hassle of getting a GHC cross-compiler?
12:33:56 <Adeon> with JHC you will find it difficult to use many good haskell packages
12:34:08 <Adeon> I think that's the most important problem if you are targeting android
12:34:17 <Adeon> it is possible to get GHC for android to work
12:34:52 <Adeon> GHC has many more features, extensions and stuff but if you can live without them, JHC is not bad
12:36:47 <rhaps0dy> hum
12:36:49 <rhaps0dy> also cabal
12:36:56 <rhaps0dy> that's important too
12:37:09 <rhaps0dy> and I won't have to fight much to get netwire working
12:37:27 <Adeon> if you can get GHC for android to work, I suggest use GHC
12:37:37 <rhaps0dy> thanks Adeon.
12:37:41 <Adeon> I know it can be done, one point I did it myself but it's not straightforward
12:37:43 <rhaps0dy> I guess it's much more developed too
12:37:52 <rhaps0dy> yeah, you just gotta get a chroot and run a script
12:38:02 <rhaps0dy> but I expect it to be as difficult as getting GCC for ARM
12:38:14 <rhaps0dy> well, less
12:38:16 <Adeon> do you know about the ghc-android repository
12:38:19 <rhaps0dy> yeah, it'll save me in teh long run. Thanks
12:38:23 <rhaps0dy> yeah, that's the "script"
12:38:26 <Adeon> okely dokely
12:38:28 <Adeon> good luck
12:42:45 <javjarfer> hi there! a question about Functor implementation, in Cathegory Theory a Funtor should not only map morphisms but also elements from one cathegory to another, the default implementation only takes morphisms because you can simulate the mapping between elements using the identity morphism?
12:43:45 <ion> javjarfer: In ‚Äúinstance Functor F‚Äù, the ‚ÄúF‚Äù is the part that maps objects. All Haskell functors are endofunctors, so A and F A are in the same category.
12:44:52 <S11001001> javjarfer: so F, which takes a type to another type, is the mapping from objects to objects, whereas 'fmap' is the mapping from maps to maps
12:45:00 <orahk613> fmap id = id
12:45:01 <orahk613> intuition: mapping over a structure doing nothing to each element, is the same as doing nothing to the overall structure !
12:45:03 <orahk613> now for morphism composition
12:45:04 <orahk613> fmap (f . g) = fmap f . fmap g
12:45:06 <orahk613> right hand side is a two pass algorithm we map over the structure performing  g and then likewise performing  f
12:45:07 <orahk613> functor axioms guarantees this is the same as the single-pass algorithm f . g 
12:46:50 <javjarfer> ooohh sorry, thank you all, i forgot the fact that all are endofunctors, (this happens when you start learning Cathegory Theory after you have started coding xD) thanks you.
12:47:05 <orahk613> same here
12:57:36 <orahk613> sorry I barged in a moment ago, just today I was studying category theory in the context of haskell
13:01:56 <meoblast001> has anyone seen this issue before? https://gist.github.com/meoblast001/a929553bab38745b8b07
13:05:54 <oconnore> meoblast001: I've seen the multiple definition error before, but usually from actual multiple definitions :/
13:06:12 <geekosaur> they are multiple
13:06:21 <geekosaur> one is from system library, other from user
13:06:32 <meoblast001> what could i do to resolve this?
13:06:39 <oconnore> oh, yeah
13:07:41 <javjarfer> orahk613, no worries! 
13:08:08 <geekosaur> figure out what is dragging in different versions of the unix library. (hint: overriding the system one is NOT safe, as it's a library used by ghc itself)
13:08:31 <orahk613> javjarfer: Thanks, I get overexcited and impulsive sometimes ;)
13:08:45 <geekosaur> this probably means removing the stuff in ~/.ghc and reinstalling, with --constraint='unix installed' to force it to not try to install a diofferent version and then clash like that
13:20:19 <phaazon> my GOSH
13:20:24 <phaazon> that HIDAPI is a total MESS
13:21:16 <phaazon> I‚Äôm going to write a new one from scratch
13:21:23 <phaazon> the C hidapi is very small
13:21:34 <phaazon> it should be quick, as I‚Äôm used to c2hs anyways
13:22:36 <hodapp> blah blah blah blah skolem type
13:22:38 <hodapp> SHADDUP GHC
13:22:50 <kadoban> phaazon: Nice :)
13:23:20 <statusfailed> Hmmmm. In recursion-schemes, how can I write a function (Base t (t, a) -> a) for use with "para"?
13:23:27 <statusfailed> Specifically, I want to use para on lists
13:28:06 <B0319AADC4AE> Trying to use Julius with the following: let greeting = "Say \"Hello\"" :: String in [julius|alert("#{greeting}")|]
13:28:19 <B0319AADC4AE> I get: parse error on input ‚Äò|]‚Äô
13:28:30 <B0319AADC4AE> Any ideas where I've got wrong?
13:28:48 <statusfailed> B0319AADC4AE: missing a language extension? (total guess)
13:29:22 <c_wraith> Yeah, looks like you don't have the proper language extensions enabled
13:29:32 <c_wraith> And the full error message probably tells you how to turn them on
13:30:40 <B0319AADC4AE> How can I get a more detailed message?
13:30:50 <B0319AADC4AE> I have no idea what one I might be missing.
13:31:04 <statusfailed> B0319AADC4AE: you need {-# LANGUAGE QuasiQuotes #-} at the top of the file
13:31:09 <c_wraith> I don't even know how to get less than full error messages..
13:31:11 <statusfailed> c_wraith: seems the error message doesn't give you that hint
13:31:15 <statusfailed> at least in GHCi
13:31:31 <B0319AADC4AE> Thank you sooooo much.
13:31:33 <statusfailed> B0319AADC4AE: I had to google "haskell square bracket syntax" to find that hahah
13:31:42 <B0319AADC4AE> That helps. I can work with that.
13:31:58 <statusfailed> :-)
13:32:53 <B0319AADC4AE> Thanks. I'm new enough that the square bracket didn't mean anything special to me so I wouldn't have thought to look that up.
13:33:24 <c_wraith> Template haskell uses similar syntax, and is a different extension.
13:33:35 <statusfailed> c_wraith: do they interact?
13:34:03 <statusfailed> c_wraith: I admit no familiarity with either beyond "import Control.Lens.TH" :D
13:34:15 <c_wraith> statusfailed: they share a lot of functionality.  Both generate code at compile time.
13:34:38 <statusfailed> But TH does it from other Haskell code rather than embedded DSLs?
13:34:50 <c_wraith> statusfailed: TH quote syntax is about generating haskell code by modifying haskell code.  Quasiquotes do it by running arbitrary functions on strings.
13:34:57 <statusfailed> Right- makes sense!
13:35:14 <statusfailed> I should really learn how to use them :|
13:47:41 <webchat099> Someone who know about partial monads?
13:48:55 <mizu_no_oto> webchat099: partial monads?
13:49:21 <webchat099> yes. I¬¥m looking at this http://okmij.org/ftp/Haskell/SetMonad.hs
13:50:13 <webchat099> they are monads that are not defined for all the types, but for the ones that have a class instance, for examole
13:51:01 <webchat099> the Set is an example of it: Set a  need a restriction in a: it must have the Ord intance, in order to avoid duplicates
13:51:22 <mizu_no_oto> right
13:51:28 <mizu_no_oto> What about things like this?
13:52:24 <webchat099> I need a monad that perform serialization of each return, so I need to restrict it to the Show instance
13:55:15 <mizu_no_oto> You basically just want a monad for serialization?
13:56:32 <mizu_no_oto> Or you specifically want something like a monad except that 'return' also does some odd serialization?
13:57:39 <webchat099> I would need to start with, an identity monad that also serializes the returned value
13:57:46 <c_wraith> if return does anything interesting at all, it's not a monad
13:57:52 <mizu_no_oto> You might take a look at https://hackage.haskell.org/package/cereal-0.3.5.2/docs/Data-Serialize.html or https://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson.html
13:58:10 <c_wraith> The monad laws work out to approximately "return is boring" and "associtivity"
13:58:34 <webchat099> No, my monad does some other things, but I need to add the serialization of the return
13:59:13 * hackagebot error-list 0.1.0.3 - A useful type for collecting error messages.  http://hackage.haskell.org/package/error-list-0.1.0.3 (thinkpad20)
13:59:15 * hackagebot text-render 0.1.0.2 - A type class for rendering objects as text, pretty-printing, etc.  http://hackage.haskell.org/package/text-render-0.1.0.2 (thinkpad20)
13:59:17 * hackagebot github-backup 1.20150618 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20150618 (JoeyHess)
13:59:22 <webchat099> I know cereal, but serialization is not what i need
14:00:02 <mizu_no_oto> webchat099: out of curiosity, what actual usecase/end goal are you trying to achieve? 
14:00:24 <webchat099> i dont need a primitve called put :: Binary a -> m()
14:00:31 <c_wraith> webchat099: does it bother you that the thing you keep calling a monad can't possibly be a monad?
14:00:56 <Denommus> which web framework for REST webservices do you guys use?
14:01:02 <webchat099> I want to serialize in a log ther result of every monadic expression executed in the monad
14:01:20 <c_wraith> webchat099: does it bother you that such an operation is incompatible with being a monad?
14:01:23 <webchat099> it is a semimonad
14:01:45 <c_wraith> Denommus: if I was going to write a REST service from scratch, I'd use servant
14:01:46 <mizu_no_oto> webchat099: so basically, you want monadic logging.
14:02:09 <webchat099> no monadic logging is to have a promitive called log
14:02:11 <mizu_no_oto> well, not the Writer monad, but an actual 'write it out to a file' monadic log
14:02:42 <lolisa> It's hard to say whether return must do something boring.
14:02:45 <webchat099> I dont want a primitive. I want an effect
14:03:01 <webchat099> it is different
14:03:22 <Denommus> c_wraith: oooh, it looks interesting
14:03:40 <webchat099> like the set has the effect of removing duplicates
14:04:04 <c_wraith> And why set is also not a monad. :)
14:04:10 <webchat099> in the Set monad there is not a primitive remove_duplicates
14:04:13 * hackagebot simple-nix 0.1.0.3 - Simple parsing/pretty printing for Nix expressions  http://hackage.haskell.org/package/simple-nix-0.1.0.3 (thinkpad20)
14:04:35 <webchat099> it is an effect, that is done whenever a monadic expression in the Set monad is executed
14:04:45 <c_wraith> webchat099: there's also no set monad
14:04:57 <mizu_no_oto> webchat099: So basically, you want every call to fmap/join/>>=/return to log the result?
14:05:25 <webchat099> that is why Set need the Ord restriction for the values that can manage. And my monad need the Show restriction
14:05:50 <webchat099> mizu_no_oto:  yes
14:05:59 <mizu_no_oto> You could take the approach of something like https://hackage.haskell.org/package/set-monad-0.2.0.0/docs/Data-Set-Monad.html and write a monad-like library that does what you want it to
14:06:30 <c_wraith> The thing is, this is even more of a not-monad than set
14:06:44 <c_wraith> This is a not-monad because it violates all the monad laws.
14:07:54 <webchat099> c_wraith:  can you give an example?
14:08:25 <c_wraith> well, x >>= return will never be something you can substitute for x
14:08:25 <webchat099> thanks mizu_no_oto 
14:08:30 <c_wraith> They mean different things
14:08:38 <mizu_no_oto> webchat099: f >=> return == f
14:08:46 <webchat099> you mean the set monad?
14:08:57 <c_wraith> No, I mean something that records binds and returns
14:09:05 <c_wraith> That breaks all the monad laws
14:09:19 <mizu_no_oto> Yet they have observationally different behavior with your logging type, since your log will be different in both cases
14:09:42 <c_wraith> It also breaks associativity, because the log will be in different orders depending an how things are associated
14:10:00 <webchat099> c_wraith:  I don¬¥t need to log the return. Only the bind
14:10:08 <caconym> Denommus: Scotty is pretty cool, haven't tried servant
14:10:18 <c_wraith> that's enough to break all the monad laws
14:10:22 <webchat099> c_wraith:  no; the order is not violanted IMHO
14:10:31 <c_wraith> It's not a matter of opinion
14:10:45 <webchat099> anyway, it is something to take into account
14:11:09 <awoserra> hahaha
14:11:16 <mizu_no_oto> webchat: m >>= return =‚â° m
14:11:37 <mizu_no_oto> You'll log in the one case, but not in the other
14:11:42 <webchat099> c_wraith:  I think that I can make it "legal"
14:11:56 <mizu_no_oto> which is... odd
14:12:07 <Denommus> caconym: servant looks more type-safe than scotty, which interests me
14:12:30 <webchat099> mizu_no_oto:  I will not log return values. only the bind
14:12:54 <mizu_no_oto> webchat099: right - there's a bind there, so you'll log
14:13:48 <mizu_no_oto> m >>= return will log, m will not log
14:14:14 * hackagebot nixfromnpm 0.1.0.3 - Generate nix expressions from npm packages.  http://hackage.haskell.org/package/nixfromnpm-0.1.0.3 (thinkpad20)
14:14:33 <webchat099> well I need it.  after doing it I will study the properties. I will call it the semihomoic-webchatoid semimonad
14:15:18 <drewbert> Where do I find the equivalent of hashString in the newer modules that once was in Data.Hashtable in base?
14:15:26 <mizu_no_oto> webchat099: out of curiosity, why do you want something like this instead of monadic logging?
14:15:28 <caconym> Denommus: yeah, it does look pretty cool, I'm going to check it out when I get the chance
14:15:51 <emmanuel_erc> Hello there everyone!
14:16:11 <webchat099> and will put a big warning  for  academics
14:16:35 <emmanuel_erc> I just started getting into haskell, would any of you guys say that the book LYAH is a beginner text for learning haskell?
14:17:02 <caconym> emmanuel_erc: it is a helpful resource but its lack of exercises limited its usefulness for me
14:17:05 <webchat099> mizu_no_oto:  a logging effect? for many things
14:17:36 <kadoban> emmanuel_erc: https://github.com/bitemyapp/learnhaskell <-- that has good recommendations
14:17:47 <maerwald> emmanuel_erc: too verbose for me, try the cis course from 2013
14:18:04 <webchat099> specially for things that have been not tried before
14:18:10 <emmanuel_erc> kadoban: thanks for the suggestion
14:18:20 <mizu_no_oto> webchat099: Rather, why don't you want monadic logging, other than "that has a primitive; this has an effect"?
14:18:22 <drewbert> I love LYAH. 
14:18:27 <ajf> is there a strict version of Data.Array? Not an unboxed one.
14:19:17 <drewbert> ajf: Data.Array.ST?
14:19:26 <webchat099> mizu_no_oto: because I dont want to clutter my code with intercalated log sentences. This is just one of the reasons
14:20:16 <ajf> drewbert: oh, that's in a monad
14:20:33 <emmanuel_erc> What are some of the projects you guys have used haskell for?
14:20:39 <webchat099> ans second because in the monad instance I have better control of what to log and at what level. for example I can limit the log to a level of nested binds
14:20:43 <ajf> emmanuel_erc: a silly placeholder page!
14:20:50 <ajf> http://cutie.space/
14:21:01 <ajf> the stars and spinning heart was done in Haskell
14:21:12 <awoserra> https://wiki.haskell.org/Applications_and_libraries
14:21:24 <emmanuel_erc> nice ajf
14:21:32 <drewbert> working on a rather large Yesod site at the moment.
14:21:59 <mizu_no_oto> webchat099: you can easily say  something like "doSomething >=> serializeToLog >=> doSomethingElse"
14:22:06 <awoserra> i'm coding a leap year routine :)
14:22:12 <ajf> I also wrote a raycaster (not to be confused with a raytracer - raycasting is Wolfenstein 3D, raytracing is Pixar)
14:22:21 <awoserra> heheh
14:22:39 <ajf> It runs quite slowly, but I think that's because Haste's JS output isn't well-liked by Firefox or Chrome.
14:22:45 <drewbert> actually at the very moment I'm trying to port Frag to newer packages.
14:22:47 <ajf> GHCJS might do a better job, but I don't use it
14:22:51 <webchat099> I can even erase the log of deeper binds when the code return fully from a procedure, and keep it when the program fail in a call to a function
14:23:18 <drewbert> Need a replacement for Data.Hashtable.hashString, any ideas?
14:23:21 <ajf> oddly enough it runs silky-smooth in Safari... I guess Nitro <3s Haskell?
14:23:36 <webchat099> mizu_no_oto:  tha is something that is not a challenge and is boring. This is programming as usual
14:23:38 <awoserra> ... totally skipping "hello world" :P
14:24:21 <Denommus> c_wraith: can I just use Show and Read instead of JSON in servant?
14:24:30 <webchat099> I want to let people to avoid these dirty things. That is what the effects are for
14:24:49 <mizu_no_oto> webchat099: well, if the experiment turns out well and is useful, you should release it to hackage
14:25:37 <webchat099> mizu_no_oto:  for sure, that is my aim!!
14:26:24 <drewbert> I think I'm just going to copy paste it out of the old base source.  
14:26:32 <drewbert> Doesn't look like there's a replacement in newer packages.
14:29:13 <geekosaur> http://hackage.haskell.org/package/hashable-1.2.3.2/docs/Data-Hashable.html
14:29:29 <geekosaur> it's a typeclass now so it can do more than just String
14:29:53 <geekosaur> also see the unordered-containers package
14:29:54 <drewbert> OIC
14:38:02 <superturrican> How is  f <*> a = (<$> a) =<< f ? Does someone have any intuition/explanations on this?
14:40:00 <Peaker> :t (<*>)
14:40:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:40:03 <Peaker> :t (=<<)
14:40:04 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:40:19 <Denommus> damn, servant uses so many extensions
14:40:56 <Peaker> superturrican: =<< lets you apply a function to the function inside 'f'. The function (<$> a) applies the function inside 'f' to the value inside 'a', and the wrapped result is what =<< expects, so it all works out
14:41:58 <superturrican> the types seem to work out but does that imply it does the same as <*> ?
14:44:43 <valdyn> superturrican: of course Applicative can be implemented to not match Monad, but thats not usually done
14:44:46 <quchen> superturrican: 
14:44:47 <quchen>   f >>= (<$> a)   =   f >>= \g -> fmap g a   =   f >>= \g -> liftM g a   =   f >>= \g -> (a >>= return . g)   =   f >>= \g -> a >>= (.) return g   =   f >>= \g -> a >>= \x -> (.) return g x  =   f >>= \g -> a >>= \x -> return (g x)  =   liftM2 id f a  =   ap f a  =   f <*> a
14:45:03 <quchen> Prettier format: http://lpaste.net/134760
14:48:49 <superturrican> thanks everyone
14:48:57 <orzo> I need help converting times.  I remember somebody made a nice draw.io diagram
14:50:08 <orzo> I want to convert this type to UTCTime: https://hackage.haskell.org/package/hourglass-0.2.9/docs/Data-Hourglass-Types.html#t:DateTime
14:50:53 <kqr> is there a way to specify that you don't care about the type of an argument to a function? (since you're going to throw it away anyway)
14:51:05 <quchen> kqr: Leave it polymorphic
14:51:06 <quchen> :t forever
14:51:07 <kqr> I could bind it to a type variable, but that's not as clear as "_" or whatever
14:51:07 <lambdabot> Monad m => m a -> m b
14:51:10 <orzo> use the polymorphic type a
14:51:11 <kqr> I guess
14:51:32 <quchen> call it something unusual like r or s or whatever
14:51:44 <quchen> Not "a" or "b" at least
14:52:01 <orzo> call it anytype
14:52:03 <kqr> hm even though "a" seems to be pretty common in the standard library for such types?
14:52:14 <orzo> call it dummy
14:52:20 <orzo> you don't need to use a single letter
14:52:22 <kqr> anytype was actually a good idea
14:52:31 <kqr> I'll keep that
14:52:37 <quchen> :t id :: anytype -> anytype
14:52:38 <lambdabot> anytype -> anytype
14:52:42 <quchen> Many things can be any type.
14:52:58 <orzo> shrug
14:53:27 <orzo> he's trying to emphasize it
14:54:39 <orzo> anyway, somebody want to help me struggle with my time conversion problem?
14:55:12 <orzo> i'm kind of anoyed that the hourglass package exists
14:55:46 <orzo> my code used to use UTCTime and it has bitrotted because vincent decided to make up his own damn time types
14:56:45 <alanz> orzo: There is a new package utc on hackage, have you looked at that?
14:59:44 <orzo> alanz, thanks, but i think i've found a solution
15:00:10 <alanz> ok
15:09:16 * hackagebot estimator 1.1.0.1 - State-space estimation algorithms such as Kalman Filters  http://hackage.haskell.org/package/estimator-1.1.0.1 (JameySharp)
15:25:29 <osa1> ExistentialQuantification is implying BangPatterns... any ideas why?
15:30:48 <hexagoxel> because 3 different ways of parsing the start of a type was enough? :p
15:31:04 <hexagoxel> no idea
15:33:43 <orzo> I need help with updating a cabal file to support multipel versions of a dependency.  Conditional compilation takes care of the code, but the problem is that if the x509 package is new enough, i need to add anotehr dependency in the cabal file, but adding the dependency will break the build for an older x509 package that i want to support.  
15:34:07 <Quantumplation> Hey there.  Maybe i'm going about this all wrong, but is there a way to write a function which could return anything which implements a given type class?  something like:  http://lpaste.net/3625240134863028224 ?
15:34:28 <orzo> So is there a way, in the cabal file, to add a dependency conditioned on the version selected for another dependency?
15:35:57 <merijn> orzo: Sounds like something you can do using flags, but I dunno how to do that
15:36:07 <orzo> Quantumplation: the answer to your question is yes.  But your code shows the constructor MyType which is a specific type
15:36:32 <orzo> merijn: well i don't want to have to specify the flag, i'd like it automatic based on the version of a given package
15:36:36 <ajf> is there a function to evaluate something to WHNF
15:36:48 <hexagoxel> Quantumplation: an existing example would be `http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-List.html#v:genericLength`
15:36:51 <ajf> or, er
15:36:55 <merijn> orzo: I think cabal can automatically toggle flags if dependency computation fails
15:36:57 <ajf> some way to say "evaluate this now"
15:37:08 <merijn> orzo: But I've never used that to make things work
15:37:12 <Quantumplation> right, the idea being that dispatch, based on the value of the request object, returns various different things, but it guarantees that the result will be of the type class ToJSON?
15:37:15 <orzo> ajf: an IO action to do that?
15:37:57 <ajf> well, I guess it could be done somehow with IO
15:38:08 <orzo> ajf: are you familiar with seq?
15:38:11 <hexagoxel> ajf: seq, deepseq, evaluate
15:38:42 <ajf> ah, evaluate seems to be what I was after
15:39:13 <orzo> Quantumplation: to do this, use only the ToJSON interface and never depend on anything specific to the type besides that
15:39:20 <ajf> though it's an IO action, but overriding laziness couldn't work through calling a normal function, because the call itself would be handled lazily...
15:41:05 <orzo> merijn: if you know any links about that feature, i'd like to read about it
15:42:16 <Quantumplation> I'm not quite understanding what you mean orzo, so I elaborated no my example, maybe this better illustrates what I want to do: http://lpaste.net/3625240134863028224
15:42:46 <orzo> ooh, that's different
15:43:14 <orzo> you want something like Either
15:44:18 * hackagebot atlassian-connect-core 0.7.0.0 - Atlassian Connect snaplet for the Snap Framework and helper code.  http://hackage.haskell.org/package/atlassian-connect-core-0.7.0.0 (RobertMassaioli)
15:44:19 <orzo> or you could use, um, i forget the term, but the hiding impementation details pattern
15:44:34 <hexagoxel> Quantumplation: the current type signature is like "let the user of this function choose what she wants, as long as it is ToJson"
15:44:38 <Quantumplation> My point is that at the call site (in app) I don't care what the type is: if it's an instance of ToJSON, I can call encode on it to send it down to the client.  I'm looking for a way to achieve this without hard coding all of the different possible return values
15:44:56 <Quantumplation> hexagoxel: yea, that's what I figured
15:45:43 <Quantumplation> I'm looking for the opposite, "let me choose what the return type is, and the caller shouldn't care, as long as it's ToJSON"
15:46:19 <orzo> data JSONThing = JSONThing (ToJSON x => x)
15:46:33 <orzo> what's that called? I forget
15:46:39 <hexagoxel> existential datatype
15:46:57 <hexagoxel> https://wiki.haskell.org/Existential_type
15:47:28 <orzo> right, well Quantumplation might want that
15:47:39 <Quantumplation> ah, ok, so... lemme see if I can rework my example using this
15:48:04 <orzo> Quantumplation: you maybe should consider this a bit of an anti-pattern though.
15:48:39 <hexagoxel> indeed; it may be a sign of sticking a bit too much with OO patterns
15:49:35 <Quantumplation> What is the idiomatic way to isolate my server code (status code, headers, serializing to json, etc) from my application logic (given a request, return something to the user)
15:50:21 <orzo> idomatic would be to make opague types, the name of the type is exported from a module, but it's data constructors are not
15:51:13 <Quantumplation> Hmm... I don't immediately see how that would be used here
15:52:17 <hexagoxel> Quantumplation: in the case of ToJSON, the only thing you can do with an (exists a . ToJSON a => a) is calll toJson on it
15:52:24 <hexagoxel> so why not return a Value directly?
15:53:49 <Quantumplation> hexagoxel: like this? http://lpaste.net/3625240134863028224
15:54:18 <hexagoxel> there are uses for existentials, but simplifications such as that one get rid of a lot of cases
15:54:38 <hexagoxel> Quantumplation: if you want to go all the way to ByteString, sure
15:54:48 <Quantumplation> seems like a lot of redundant calls to encode, and doesn't give me a clean separation between server shuttling and application logic
15:55:03 <hexagoxel> Quantumplation: you could start your function with encode
15:55:14 <hexagoxel> dispatch req = encode $ case ..
15:55:17 <Quantumplation> I agree it solves my immediate problem, i'm just trying to learn if there are cleaner ways to do it
15:56:56 <orzo> Quantumplation: OO/Existential is a component-based approach, in haskell, a layering approach is considered better.  Something to keep in mind in the design stage
16:03:46 <DNoved1> Any recommendations for a simple graphics library?
16:03:57 <DNoved1> I was thinking of making a visual algorithm demo in haskell.
16:04:13 <DNoved1> So something with simple vector graphic like support would be enough
16:04:19 * hackagebot atlassian-connect-core 0.7.0.1 - Atlassian Connect snaplet for the Snap Framework and helper code.  http://hackage.haskell.org/package/atlassian-connect-core-0.7.0.1 (RobertMassaioli)
16:14:19 * hackagebot yesod-auth-account 1.4.1 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.4.1 (JohnLenz)
16:21:52 <mpickering> Anyone know if there's a library which maps from the HSE ast to the ghc ast?
16:49:20 * hackagebot yesod-static-angular 0.1.4 - Yesod generators for embedding AngularJs code into yesod-static at compile time  http://hackage.haskell.org/package/yesod-static-angular-0.1.4 (JohnLenz)
17:13:34 <mcsmash> geekosaur: I tried adding ewmhDesktops, but still no luck. here's my xmonad.hs file: http://pastebin.com/37v36RDb
17:13:53 <mcsmash> geekosaur: warning, it's a mess....
17:16:50 <mcsmash> Can anyone else help me understand why chrome doesn't want to focus? Here's my config file. http://pastebin.com/37v36RDb (Sorry about the mess, I don't know haskell)
17:18:14 <geekosaur> sorry, having local problems
17:18:45 <mcsmash> No worries, I'm just happy for the help :)
17:19:16 <f-a> I have a package which I want to be compatible with 7.8 and 7.10. This means I get a lot of "The import of ‚ÄòControl.Applicative‚Äô is redundant" warnings when I build it. What's the 'correct' (as in more elegant) way to handle those?
17:19:39 <geekosaur> note that justr importing a module does nothing whatsoever (I have not managed to load your paste yet)
17:21:09 <geekosaur> line 74: xmonad . ewmh $ defaultConfig ...
17:24:19 <pacak> f-a: 1) import prelude at the bottom, 2) CPP
17:25:40 <f-a> I didn't even know 1) was legal pacak , thanks
17:29:41 <LordBrain> Hey, what might cause my build to quit with Could not find module `Network.Socket'  using network-2.3.0.13 and ghc 7.4.1
17:30:20 <LordBrain> i compiled my sandbox several times now, reinstalled world, and so forth, and when i use cabal repl  it lets me import Network.Socket fine
17:31:04 <LordBrain> the ghc here is old, i know, i'm still supporting it tho.
17:31:30 <monochrom> lacking an explicit dependency in *.cabal file
17:31:39 <LordBrain> nope, it has network -any 
17:31:57 <LordBrain> any other ideas?
17:32:24 <monochrom> I am not telepathic.
17:32:40 <LordBrain> that's too bad, but this is all the info i have
17:32:46 <Welkin> LordBrain: I tried upgrading -- big mistake
17:32:54 <Welkin> I went back to 7.8.4
17:32:56 <LordBrain> how so Welkin ?
17:32:58 <LordBrain> oh
17:33:02 <Welkin> nothing worked, bugs everywhere
17:33:10 <LordBrain> well i have not tried 7.10 yet
17:33:18 <LordBrain> but i do have 7.8.3
17:33:23 <Welkin> 7.10.1 does not work right on osx
17:33:42 <LordBrain> but this present build i am working on is using ghc 7.4.1, which was released with debian wheezy
17:33:57 <Welkin> doesanyone know what this even means?
17:34:03 <Welkin> ghc-pkg: Data.Binary.Get.runGet at position 40: demandInput: not enough bytes
17:34:06 <Welkin> in response to `cabal sandbox hc-pkg list`
17:34:26 <monochrom> package database corrupted
17:34:39 <pacak> Welkin: db was created by a different version of ghc?
17:34:50 <Welkin> butit wasn't
17:34:59 <monochrom> but it doesn't say which database, --global or --user or sandbox's
17:35:00 <Welkin> I have been using this command for a long time now
17:35:02 <LordBrain> cabal names the db folders with the abi
17:35:07 <LordBrain> so it shouldnt matter
17:35:17 <monochrom> I am not telepathic.
17:35:20 <Welkin> it was working up until I installed a new package
17:35:23 <geekosaur> [18 20:33] <geekosaur> sounds like ghc-pkg for one version running against a package database for a different version
17:35:35 <LordBrain> we're sorry for you monochrom 
17:35:42 <monochrom> no, it's okay.
17:35:50 <LordBrain> the rest of us are telepathic, you should get disability 
17:35:50 <geekosaur> it's supposed to be versioned but I have heard of this happening when multiple ghc versions are involved
17:35:52 <monochrom> instead, I'm sorry for you.
17:35:58 <geekosaur> like cabal0-install gets confused or something
17:36:12 <monochrom> you have problems that require remote telepathy.
17:36:41 <LordBrain> if you are trying to say you think it might be solveable with more information, then say that
17:37:20 <monochrom> I am not even certain about that.
17:37:25 <Welkin> okay, so what exactly is the issue?
17:37:35 <Welkin> I have a pretty fucked up set up right now
17:37:55 <Welkin> I found (for some reason) a packge db from 7.10.1 in my sandbox
17:38:09 <Welkin> no idea how that got there, as I recreated the sandbox after setting up ghc 7.8.4
17:38:09 <LordBrain> Welkin, i don't think that would hurt it
17:38:22 <Welkin> I get am ore specific error now though
17:38:23 <LordBrain> unless i am mistaken
17:38:50 <Welkin> I remove that package db, and now it says "ghc-pkg: /Users/eric/projects/streamlines/.cabal-sandbox/x86_64-osx-ghc-7.10.1.20150612-packages.conf.d: openFile: does not exist (No such file or directory)"
17:38:52 <LordBrain> cabal will use the appropriate ghc db for the ghc it is using
17:38:57 <Welkin> but it was empty anyway
17:39:24 <Welkin> ghc -v gives me 7.8.4
17:39:51 <LordBrain> omg, i am wrong
17:40:04 <LordBrain> the sandbox hardcodes the package db
17:40:09 <LordBrain> thats probably my problem too
17:40:17 <Welkin> ...but I never used 7.10.1 in the sandbox
17:40:18 <Welkin> ever
17:40:28 <LordBrain> you used it to create the sandbox
17:40:30 <Welkin> no
17:40:36 <LordBrain> when you said sandbox init
17:40:45 <Welkin> okay, it's time for another Great Purge
17:40:47 <LordBrain> oh check the cabal.sandbox.config
17:40:53 <LordBrain> which db is listed?
17:41:12 <pacak> Welkin: http://img.pandawhale.com/94867-magic-gif-Shia-Imgur-MAH7.gif
17:41:44 <Welkin> jesus
17:41:48 <Welkin> it lists 7.10.1
17:41:50 <LordBrain> i have the 7.8.3 db listed in the cabal.sandbox.config
17:41:55 <LordBrain> yeah we have hte same issue
17:41:58 <Welkin> no idea how that happened
17:42:04 <Welkin> it worked fine until a little bit ago
17:42:18 <Welkin> well, time to send 7.10.1 off into a black abyss
17:43:10 <Welkin> thanks for helping me igure that one out
17:43:14 <Welkin> figure*
17:43:45 <Welkin> pacak: it feels like the universe does not want me to get this application online
17:54:22 * hackagebot hid 0.1.0.0 - Interface to hidapi library  http://hackage.haskell.org/package/hid-0.1.0.0 (DimitriSabadie)
18:04:16 <johnw> n
18:10:13 <pchiusano> question, what's the deal with Eq1 / Show1, they exist in both Prelude.Extras and Data.Functor.Classes
18:10:19 <pchiusano> which one should I be using
18:10:49 <pchiusano> the Data.Functor.Classes is in transformers (for some reason)
18:14:23 * hackagebot mighttpd2 3.2.8 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.8 (KazuYamamoto)
18:25:10 <pchiusano> anyone? Eq1 / Show1 exists in two different packages - transformers and prelude-extras
18:27:10 <pavonia> I'd prefer the transformer's version because that package is already used by many other packages
18:29:20 <pchiusano> pavonia: okay, is there anything more to it than that?
18:29:55 <pavonia> I don't know
18:30:01 <pchiusano> the prelude-extras package has nothing else in it, it seems kinda weird to be lumping Show1, Eq1 with transformers
18:30:14 <pchiusano> they don't really have much to do with each other
18:45:19 <SrPx> I understand "PArrow" and how it can be used to validate a string. For example, `print $ runParser (many1 (char 'a')) "aaabb"` outputs `Right "aaa"`. What I don't understand is how I can use it to actually convert a text into a value of an ADT. 
18:46:40 <SrPx> For example, how would one write a simple parser that converted "aaa,bbb,ccc" to ["aaa","bbb","ccc"] ?
18:47:59 <benzrf> > iterate (dropWhile (/=','))
18:48:01 <lambdabot>  <[Char] -> [[Char]]>
18:48:05 <benzrf> > iterate (dropWhile (/=',')) "aaa,bbb,ccc"
18:48:06 <lambdabot>  ["aaa,bbb,ccc",",bbb,ccc",",bbb,ccc",",bbb,ccc",",bbb,ccc",",bbb,ccc",",bbb,...
18:48:08 <benzrf> oh good
18:48:13 <benzrf> > iterate (tail . dropWhile (/=',')) "aaa,bbb,ccc"
18:48:14 <lambdabot>  ["aaa,bbb,ccc","bbb,ccc","ccc","*Exception: Prelude.tail: empty list
18:48:16 <benzrf> :>
18:48:18 <benzrf> perf
18:48:24 <SrPx> No, I mean, using PArrow!
18:48:31 <benzrf> whats a parrow
18:48:34 <lamefun> Am I supposed to create a separate module for every record?
18:48:48 <SrPx> That's the point, I think it is like Parsec with arrows
18:48:59 <SrPx> But I'm not sure if it can be used to build datatypes like parsec can
18:50:22 <pavonia> Wouldn't it be pretty useless if not?
18:50:56 <SrPx> Well I know how to check if a parse worked or not :P
18:52:55 <kadoban> I'm not really sure why you'd want to use arrows for parsing? Hmm
18:53:10 <pavonia> lamefun: No, but it can be helpful if you have duplicate field names
18:55:11 <SrPx> kadoban: why not?
18:55:39 <SrPx> parsing is always used as the example of the utility of arrows 
18:55:49 <SrPx> since it is more efficient than monads for that afaik
18:56:18 <kadoban> Is it? Never seen that. Just seems like Monad and Applicative work, so I'm not sure what you'd gain.
18:57:15 <SrPx> seems like it is more efficient for early exit... or parallel parsers... don't remember which
18:57:30 <SrPx> I'm just playing tho
18:58:37 <monochrom> kadoban: the original arrow paper began with a parsing example. admittedly, later on it was found that we needed only applicative for the same thing.
18:59:01 <kadoban> Ah, interesting. I should look more at arrow sometime
18:59:14 <monochrom> but the original paper went on with a logic circuit modelling example, which was a good fit for arrow.
19:15:30 <rvxi> question about shared sandboxes
19:15:43 <rvxi> is cabal build aware of shared sandboxes?
19:16:04 <rvxi> it doesn't seem like it is
19:19:26 * hackagebot base-generics 0.1.0.1 - This library provides some instances for extra GHC.Generic typeclass such as Int8, Word16 and some unboxed types as well.  http://hackage.haskell.org/package/base-generics-0.1.0.1 (songzh)
19:20:10 <Hijiri> is there a common way of "partitioning" an integer number into n > 0 parts, so that all the parts added together equal the original number?
19:20:40 <Hijiri> and each part is no more than 1 away from 1 / n of the original number
19:21:11 <Hijiri> for example, partInt 10 3 might give me [3,3,4]
19:28:02 <pacak> > (\x y -> let (a, b) = x `divMod` y in zipWith (+) (replicate y a) (take b (repeat 1) ++ repeat 0)) 10 3
19:28:04 <lambdabot>  [4,3,3]
19:29:23 <pacak> Hijiri: You can slap reverse on top if you want to get  exactly [3,3,4]
19:29:33 <Fylwind> Hijiri: divide the number using floored division, then calculate the remainder and distribute the remainder among them
19:31:31 <SrPx> monochrom: we needed only applicative? Why there is no applicative parsing library, then? :o
19:32:02 <monochrom> mathematically, floored division is the same as quotRem. practically, quotRem is way faster.
19:33:17 <monochrom> f x n = case quotRem x n of (q, r) -> replicate (n-r) q ++ replicate r (q+1)
19:33:33 <Fylwind> monochrom: 'floored division' is quotRem. I'm not saying "divide-then-floor", that would be silly
19:33:37 <pacak> monochrom: f (-10) 4
19:34:03 <monochrom> alright, but the reader may not know
19:34:47 <Fylwind> monochrom: tough, there's no standard terminology for the various flavors of integer division AFAIK
19:35:23 <Fylwind> Haskell calls them quotRem and divMod but I have a hard time remembering which is which w/out looking at the docs ‚Ä¶
19:36:13 <Hijiri> pacak: Fylwind : thanks
19:37:31 <Fylwind> SrPx: most parsing libraries provide an applicative interface, but I'm not aware of any applicative-only parsers
19:41:27 <pacak> How do you deal with product types with 20+ fields each of which is optional? Map Name Val looks expensive, (Maybe Val, Maybe Val, ...) looks stupid.
19:43:51 <dmj`> pacak: you could make a record called defaultParameters and let the user specify what they want. Or you could make a typeclass HasParam
19:45:40 <pacak> s/20+/174/
19:46:29 <pacak> dmj`: There's no default values that would make sense in most cases, I guess I'll go with Map/IntMap.
19:51:08 <felixn> anyone have a regex lib they like?  regex-compat is giving my grief with unicode
19:53:54 <Axman6> felixn: you don't want regexes
19:54:08 <athan> Is there a reason unzipWith isn't a thing?
19:54:29 * hackagebot record-syntax 0.1.0.1 - A library for parsing and processing the Haskell syntax sprinkled with anonymous records  http://hackage.haskell.org/package/record-syntax-0.1.0.1 (NikitaVolkov)
19:54:47 <Chobbes> This is cool... https://hackage.haskell.org/package/matlab-0.2.0.0/docs/Foreign-Matlab-Engine.html is there an easy way to go the other way, though? Call Haskell from MATLAB?
19:57:35 <Axman6> athan: it's just unzip . map isn't it?
19:58:22 <athan> Axman6 I had to curry & uncurry a bit too but yeah
19:58:48 <athan> Oh wait derp
19:58:54 <athan> Thanks haha
20:06:47 <haskellnewbie> hey guys , why am I getting this error http://prntscr.com/7iobdr in this program http://pastebin.com/N6M7VfjE, isnt  N just receiving 3 arguments?
20:08:00 <tejing> haskellnewbie: (f a b) c d == f a b c d
20:10:25 <SrPx> How do I express "x * 2 + x * 3" using arrows? 
20:10:26 <haskellnewbie> tejing: thanks
20:10:36 <SrPx> > ((* 2) &&& (* 3)) $ 7
20:10:37 <lambdabot>  (14,21)
20:11:41 <pavonia> :t arr (\x -> x * 2 + x * 3)
20:11:42 <lambdabot> (Num c, Arrow a) => a c c
20:14:29 * hackagebot Yampa 0.10.2 - Library for programming hybrid systems.  http://hackage.haskell.org/package/Yampa-0.10.2 (IvanPerez)
20:17:33 <SrPx> pavonia: ?
20:17:50 <rvxi> what's the latest with snap vs. yesod? anyone have a preference?
20:18:06 <pavonia> SrPx: Maybe I misunderstood your question
20:18:44 <SrPx> pavonia: maybe I misunderstood your answer, let me think a little bit
20:18:55 <SrPx> (if just doing this can solve my actual problem)
20:19:37 <pavonia> Why are you asking for x * 2 + x * 3 and not just x * 5?
20:21:57 <ttt_fff> dumbass question: anyone finding themselves wnating to name some functions "priv_blah" instead of "blah" for functions that  are not exported? this is so that I can look at this and easily see which functions are exported from the module and which are not
20:22:58 <SrPx> I'm trying to write `parse :: String ‚Üí Tree` for `data Tree = Node Tree Tree | A | B" such that "(A (A B))" becomes (Node A (Node A B)) using arrows, I'm a little confused in how I turn the pairs into Nodes but nevermind, I'll think a little bit (maybe uncurry)
20:24:30 * hackagebot record-preprocessor 0.1.0.2 - Compiler preprocessor introducing a syntactic extension for anonymous records  http://hackage.haskell.org/package/record-preprocessor-0.1.0.2 (NikitaVolkov)
20:31:08 <SrPx> what exactly is ArrowPlus?
20:32:38 <kadoban> SrPx: It's like MonadPlus, but Arrows instead. It's a monoid on Arrows
20:32:43 <Welkin> I think it is similar to MonadPlus
20:33:06 <Welkin> how should I handle the possibility of failure when sending data over the network?
20:33:32 <Welkin> I get a response, but how should I handle the error in my application
20:33:55 <Welkin> call error?
20:34:07 <Welkin> how is throwError different from error?
20:34:35 <SrPx> I see, thanks
20:35:06 <pingu> Welkin: throwError is a function within the MonadThrow typeclass
20:35:25 <pingu> such that things can catch the things you throw in different ways.
20:35:33 <pingu> depending on the implementation
20:35:44 <pingu> error is a Prelude thing that just explodes.
20:35:48 <pingu> people really shouldn't be catching it.
20:36:06 <pingu> nor should you, ideally, ever use it unless you're convinced the situation is an impossible one
20:36:58 <Welkin> I see
20:37:05 <pingu> Welkin: Specifically for sending data over the network, I've done one of two things in the past
20:37:11 <pingu> pass in a policy for retries
20:37:26 <pingu> or throw a catchable error and provide a retry combinator for the user
20:37:32 <pingu> that catches it and retries sensibly
20:38:01 <pingu> all depends on the API interface you want to provide though, right
20:48:55 <ttt_fff> does under_score_func_names make code harder to read compared to underScoreFuncNames ?
20:49:08 <ttt_fff> I like the lisp stype of using under-score-func-names ... but under_score_func_names lok ugly
20:49:58 <pingu> ttt_fff: never seen hyphens in haskell code
20:50:06 <pingu> nor have I seen underscores in anything but local variables
20:50:07 <ttt_fff> you can't use hyphens in ahskell code
20:50:09 <ttt_fff> since it's treated as minus
20:50:16 <ttt_fff> but you can in clojure/lisp/scheme
20:50:17 <pingu> right, so that solves that probem.
20:50:56 <pingu> I think more important than personal opinions of readability is that 99% of the code out there has settled on camel case for function names.
20:51:11 <pingu> I think you can get used to either way, personally.
20:52:35 <catsup> camel case is objectively wrong
20:53:43 <dmj`> catsup: bold
20:53:45 <catsup> unfortunately we're using a language made by a guy who literally uses comic sans in business contexts, so we have to lower our expectations
20:54:04 <pingu> comic sans is objectively a great business presentation font
20:54:28 <catsup> :|
20:54:31 * hackagebot pipe-enumerator 0.1.0.0 - Pipes/iteratees bridge library  http://hackage.haskell.org/package/pipe-enumerator-0.1.0.0 (patrykz)
20:54:53 <Welkin> you mean SPJ?
20:55:04 <catsup> ya
20:55:10 <Welkin> I have seen some of his presentations, and I remember the slides being quite ugly
20:55:20 <catsup> yes, they're ugly even beyond the font
20:55:26 <Welkin> haha
20:55:28 <bitemyapp> he uses comic sans in part because it's easier for people with poor eyesight or dyslexia to read
20:55:33 <catsup> he's a great speaker though
20:55:36 <catsup> bitemyapp: NO IT IS NOT
20:55:50 <Serpentine_> There are probably better fonts for people with poor eyesite and/or dyslexia.
20:55:51 <bitemyapp> bit lighthearted too
20:56:43 <bitemyapp> well, complaining about the fonts one of the inventors of your programming language likes to use is pretty much the height of bikeshedding, so I'll take this as my cue to go back to doing something useful.
20:56:52 <catsup> sans serif fonts are not easier to read
20:56:57 <dmj`> comic sans is friendly, it makes adoption seem easier
20:56:59 <Welkin> catsup: what is your preference to camel case?
20:57:01 <catsup> and comic sans is...  a joke
20:57:23 <pacak> comic sans is mostly historical reasons.
20:57:36 <pingu> At the end of the day, I think we can agree that comic sans simply looks good. And that's why you should use it vs camel case.
20:57:59 <catsup> Welkin: well, i really like lisp code with hyphens, typographically.  it is truly beautiful on the printed page
20:59:43 <catsup> in theory you could actually use that and still have a normal minus, if you resorted to unicode
20:59:47 <peddie> johnw: are you available for bindings-DSL questions?  I'm trying to generate bindings from a header that creates a typedef for a pointer to a struct, and bindings-DSL seems to translate uses of the typedef as passing the struct itself by value everywhere
21:00:29 <catsup> but keyboard input considerations would make that impractical
21:00:55 <catsup> in practice, underscores would have been better for haskell, but it's too late
21:03:13 <peddie> johnw: s/bindings-DSL/c2hsc/
21:03:23 <pavonia> catsup: What is better about underscores?
21:05:07 <catsup> pavonia: it's easier to read, words are more easily separable visually.  it looks better, closer anyway to sound typographical conventions, and you don't end up with incorrect capitalizations (so it's more expressive in a sense)
21:06:10 <lamefun> Does Haskell have some lightweight type-centric modules of sorts?
21:06:18 <catsup> if you were to give a group of students a set of SAT problems where you replaced all the spaces with udnerscores, and another group of students the same questions but with all the spaces removed and camelCase to indicate space, which do you think would score higher?
21:06:58 <catsup> i mean the SAT verbal section with the reading comprehension
21:07:39 <catsup> or as they call it in haskell, sATVerbal
21:07:39 <Serpentine_> Probably the group with underscores, but that's because underscores can retain capitalization
21:07:51 <ronh-> catsup that fact that words separate more easily visually is a *minus* for underscores in the programming context. which one is easier to read?  :some_thing - other_thing + some_other_thing"    vs   "someThing - otherThing + someOtherThing"
21:08:17 <catsup> ronh-: well, the first one
21:08:49 <ronh-> I disagree. variables look like separate tokens, and not a single token
21:10:30 <catsup> if you're not supposed to read the text of the variables, why aren't they named (a,b,c) ?
21:12:37 <kadoban> There's a difference between reading short variable names and reading paragraphs of text.
21:12:56 <kadoban> And sATVerbal, really?
21:13:39 <catsup> what would you say, satVerbal ?  _SATVerbal?  you don't get to start with S
21:14:00 <kadoban> verbal, if it's all SAT related. Otherwise satVerbal
21:14:35 <catsup> that's fine until you want to sit down
21:14:57 <kadoban> Yes, if I'm also going to verbally sit down in the same program then I'm seriously in trouble. *eyeroll*
21:15:26 <catsup> even if you were going to sit down mathematically it would cause confusion
21:15:53 <pavonia> That problem doesn't have anything to do with camelcase vs. underscores
21:16:07 <catsup> true
21:16:14 <kadoban> Yes ... that would indeed cause confusion, such as "how the fuck do I mathematically sit down?"
21:20:21 <ronh-> catsup, who said you're not suppose to read them? my point was that it is harder to see where the variable begings and where it ends when you use underscores
21:20:32 <ronh-> at a glance
21:20:40 <DNoved1> Mm, totally gonna pronounce 2SAT as 2-sat now.
21:22:12 <catsup> ronh-: well, i don't think so, at least not with spaces in between.  anyway i really just wanted to joke about this rather than enter a big debate
21:23:23 <Cale> I'd go with satVerbal
21:26:58 <Bobby_> Hi all
21:27:14 <dmj`> hi
21:27:17 <Bobby_> I'm having a compiler error which tells me: Could not find module 'Data.Type.Equality'
21:27:35 <Bobby_> Is this not a default library? Is my installation corrupt?
21:27:35 <Axman6> which package does that come from?
21:27:56 <Axman6> @hoogle Data.Type.Equality
21:27:56 <lambdabot> package EqualitySolver
21:27:56 <lambdabot> package approximate-equality
21:27:56 <lambdabot> package type-equality
21:28:12 <Axman6> yeah pretty sure it's not a default package
21:28:14 <Cale> Bobby_: ghc-pkg list base  and see which version you have. It's possible you just have an old GHC
21:28:16 <Cale> It's in base
21:28:20 <Axman6> you'll need to install whatever package it comes from
21:28:28 <Axman6> oh, fair enough
21:29:02 <Bobby_> Oh right I have base-4.6.0.1
21:29:13 <Bobby_> How do I update?
21:29:14 <Axman6> that's pretty old
21:29:18 <Cale> Yeah, in that case, the only thing you can do is update to a newer GHC (base is tied to GHC version)
21:30:47 <larrycv> how do I use this by default in cabal repl? -fwarn-incomplete-pattern
21:31:22 <larrycv> it doesnt accept that flag
21:33:56 <lamefun> Why does Haskell discourage both records and modules?
21:34:30 <Axman6> wht do you mean by discouraging modules? it's almost impossible to not use modules
21:35:13 <kadoban> I wouldn't consider records discouraged either, I guess it depends what you mean by that.
21:35:19 <lamefun> I mean, if I have many records per module, I have to prefix functions/names. If I use modules, I have to make lots of files and write down lots of imports.
21:36:04 <Axman6> it's easy to make meta modules which import lots of modules and export them all, so you can impost just a single module
21:36:31 <lamefun> can I re-export qualified module?
21:36:31 <tedkornish> Also, there's a language extension which should make dealing with that easier planned for 7.12
21:36:36 <tedkornish> but that's a little bit out there
21:36:47 <tedkornish> OverloadedRecords or something
21:37:11 <peddie> larrycv: you could try :set -fwarn-incomplete-patterns
21:37:18 <Axman6> Type directed name resolution IIRC
21:37:48 <larrycv> peddie: not recognized
21:37:52 <lamefun> OverloadedRecords looks like it will only deal with field names, not functions.
21:38:05 <Axman6> larrycv: make a .ghci file and add the line peddie suggested
21:38:17 <larrycv> ok
21:38:34 <Axman6> (I think ghci will look for .ghci files in the current directory)
21:38:38 <larrycv> any other warnings I should use that arent enabled by default?
21:38:53 <Axman6> you can also make a ~/.ghci file for the same thing everywhere I think
21:38:59 <larrycv> for added safety
21:39:04 <Axman6> larrycv: -Wall is usually a good sety
21:39:07 <Axman6> -y
21:39:18 <lamefun> Like, in C++ I can have functions associated with a class.
21:39:33 <peddie> larrycv: strange, if I type that in my ghci session, it works
21:40:21 <larrycv> peddie: I typed it in terminal durinh startuo. it works with ghci but not cabal repl
21:40:42 <Axman6> it should work within cabal repl - they're the same thing
21:40:58 <peddie> larrycv: that's really strange, cabal repl should just invoke ghci with a bunch of special arguments
21:41:27 <larrycv> Axman6: again, I am not typing it within cabal repl
21:41:40 <larrycv> peddie: it does for you?
21:41:40 <Axman6> that's what :set commands are for
21:41:56 <peddie> larrycv: what happens if you do type    :set -fwarn-incomplete-patterns    in a cabal repl session?
21:42:06 <larrycv> it works
21:42:33 <peddie> larrycv: you can also put   {-# OPTIONS_GHC -fwarn-incomplete-patterns #-}   at the top of the source file
21:42:44 <peddie> larrycv: oh, good, do you still need help?
21:42:48 <Cale> lamefun: I don't know what to tell you -- you just get used to it mostly. Prefixing names that are all related to something in particular with the same string may be helpful, but for the most part people like to use the module system these days. I actually kind of liked the style in the old days of trying to avoid the situation where you had to use qualified imports.
21:43:16 <Cale> (but obviously that only scales so far)
21:43:39 <larrycv> it working with :set was never an issue. the fact that it doesnt work when starting cabal repl was
21:44:02 <Cale> lamefun: It's often useful at least for record field extractors to name them with some shorthand for the record type's name.
21:44:33 <lamefun> I like type-centric modules like Data.Map
21:44:42 <larrycv> (and still is. but I will try to use .ghci)
21:44:56 <lamefun> or Byte String
21:45:03 <peddie> larrycv: I see, I misunderstood your question
21:45:11 <lamefun> I like that if you find prefix overly long, you can rename eg. ByteString to BS
21:45:23 <peddie> larrycv: I like to put {-# OPTIONS_GHC -Wall #-} at the top of all my source files
21:45:23 <Cale> yeah, that's a nice thing
21:45:37 <Cale> It's sort of unfortunate that you usually end up importing twice
21:46:06 <lamefun> I'm ending up with modules like: MyProgram.Utils.Checksum.Algorithm
21:46:10 <Cale> (like: import Data.Map (Map); import qualified Data.Map as M)
21:47:30 <larrycv> peddie: I see
21:47:50 <Cale> Another thing which is interesting is that you're allowed to import multiple different modules qualified with the same prefix
21:48:58 <Cale> So for example, you can import both Data.Text and Data.Text.IO as T
21:49:46 <larrycv> btw is there a way to issue a warning for calling partial functions (including those in prelude)? More than a few times I found myself using head, minimize and other similar functions while forgetting they are partially, or being sure they cant fail, only to fail in the future
21:50:36 <Cale> It would genuinely be nice to be able to export things with the same qualifiers, so as to be able to have a single module in your project where you set up all your variously qualified imports, and then just import that from other modules.
21:50:45 <peddie> larrycv: I wish!  I don't think it exists, but if you find it, please let me know so I can use it everywhere :)
22:08:34 <ttt_fff> hmm, does vim improperly indent "where" clauses ?
22:09:44 <Cale> Does vim indent where clauses at all?
22:10:11 <Cale> I just have the thing where it preserves the indentation level of the previous line, and move things around from there
22:14:19 <Bobby_> Is cabal-install meant to take a long long time to compile?
22:15:01 <Cale> Bobby_: It shouldn't take *that* long...
22:15:04 <Bobby_> I mean  build
22:15:54 <Bobby_> Painfully slow atm, 40 minutes in :/
22:16:09 <Cale> wat
22:16:15 <Cale> That seems crazy
22:16:31 <c_wraith> Are you compiling on a machine with like 256MB of RAM?
22:16:55 <kadoban> Bobby_: Are you talking about building cabal-install itself?
22:17:00 <Cale> Here, I'll cabal install cabal-install and see how long it takes.
22:17:03 <c_wraith> 'cause swapping is the only way I can see cabal-install taking that long to build
22:17:41 <Bobby_> Its a virtual machine
22:17:43 <Bobby_> 1GB ram
22:18:11 <Cale> Aaaaaand done. 55 seconds.
22:18:34 <kadoban> I suspect that 1GB is going to be kind of low for doing haskell stuff. Some big packages take a lot of RAM ...
22:18:55 <Bobby_> I can increase it a bit later
22:19:02 <Bobby_> But i'm only doing simple haskell tasks
22:19:12 <Bobby_> Was just wondering why its taking so long
22:19:27 <kadoban> Yeah it shouldn't be taking anywhere near that long.
22:20:17 <Bobby_> Stuck on the same line now for like 20 minutes
22:20:51 <ronh-> it was built in 120 seconds in here in a freshly created sandbox
22:21:02 <Bobby_> Oh and just as I say that
22:21:10 <Bobby_> It prints out a new line
22:21:33 <Bobby_> Yeah not too sure whats wrong
22:21:38 <kadoban> Bobby_: Run away, it's gone sentient and is messing with you.
22:21:38 <Bobby_> I guess ill wait it out...
22:33:19 <Bobby_> Do you guys think the cabal build is slow due to only low ram (1GB)? Might restart it or something...
22:34:49 <whiteline> 1gb isn't slow in this context
22:34:51 <jle`> Bobby_: are you building it from scratch?
22:34:58 <whiteline> *low
22:34:59 <jle`> like all of the dependencies too?
22:35:05 <jle`> i remember building it from scratch took a while for me too
22:35:08 <Bobby_> That what I thought
22:35:32 <Bobby_> Im using these steps:
22:35:35 <Bobby_> https://gist.github.com/yantonov/10083524
22:35:47 <Bobby_> So its taking forever on the: ./Setup build
22:39:40 <Bobby_> Is there an alternative way to update cabal?
22:40:07 <Welkin> yes
22:40:22 <Welkin> you can download the source from the haskell site
22:40:33 <Welkin> ld: symbol(s) not found for architecture x86_64
22:40:33 <Welkin> clang: error: linker command failed with exit code 1 (use -v to see invocation)
22:40:41 <Welkin> I have never seen that error before
22:41:08 <Welkin> it happened randomly, and it didn't happen when I tried to build again
22:41:08 <kadoban> Bobby_: This is what I do: https://gist.github.com/ion1/2815423
22:42:12 <Welkin> weird issues with yesod lately
22:42:32 <Welkin> and cabal
22:42:35 <Welkin> and ghc
22:46:15 <Bobby_> Sigh so much wasted time setting this up
22:47:43 <Welkin> setting what up?
22:47:54 <Welkin> I have wasted the last two days setting things up again and again
22:48:06 <Welkin> once you get it set up though, you shouldn't have to mess with anything for a long time
22:49:17 <Welkin> what kadoban does it the same as what I have been doing lately
22:49:22 <Welkin> is*
22:49:43 <Bobby_> At this stage I have perhaps multiple installations of things and a couple of aborted setups
22:50:00 <Welkin> you can have multiple versions of ghc no problem
22:50:14 <Bobby_> No clue what to do now to update my base so I can use the base package functions I need to learn how to use
22:50:55 <kadoban> Bobby_: base is built into GHC. You pick whichever version of GHC you need. 4.8 is 7.10.1 and 4.7 is 7.8.x I believe.
22:51:09 <Welkin> Bobby_: I tried to build yesod on a AWS micro instance and it didn't work
22:51:11 <Welkin> it failed
22:51:16 <Welkin> after taking 1.5 hours
22:51:21 <Welkin> you need enough RAM
22:51:25 <Welkin> use at least 2 GB
22:51:38 <Bobby_> Well I did install 7.10.1  from source just then
22:51:50 <Welkin> from source? or the binary?
22:51:51 <Bobby_> But the base has not changed
22:51:51 <kadoban> Bobby_: Don't install from source.
22:51:54 <Welkin> from source would take hours
22:51:54 <Bobby_> Still 4.6
22:52:05 <Bobby_> It didnt
22:52:15 <kadoban> Bobby_: Then you're not actually using the version you installed.
22:52:17 <Bobby_> I was using this: https://gist.github.com/yantonov/10083524
22:52:34 <Bobby_> I got up to the ./setup Build
22:52:40 <Welkin> that is the binary
22:52:50 <Bobby_> So I should have 7.10.1 installed?
22:53:20 <Welkin> type ghc -v
22:53:27 <Welkin> it tells you which version
22:54:28 <Bobby_> 7.6.3
22:54:36 * hackagebot pipe-enumerator 0.2.0.0 - A bidirectional bridge between pipes and iteratees  http://hackage.haskell.org/package/pipe-enumerator-0.2.0.0 (patrykz)
22:55:01 <Welkin> then it's not on your path
22:55:09 <Welkin> or you didn't reload your bash profile
22:55:14 <Bobby_> Okay so I found a folder where I installed 7.10.1 to
22:55:23 <kadoban> Bobby_: Clean up your path ... I usually just get rid of every other install around, it's simpler if you don't have multiple versions hanging around.
22:56:04 <Welkin> okay, what is with this?
22:56:05 <Welkin> http://lpaste.net/134783
22:56:25 <Welkin> building my yesod application randomly fails with these linking errors
22:56:42 <Welkin> it never fails when using yesod devel
22:57:03 <Welkin> but when building the binary for deployment, it sometimes gives this odd error (which includes clang and ghc)
22:57:44 <Welkin> I use `cabal clean` before building too
22:59:15 <Bobby_> Hey Welkin, do you know how I can remove all ghc/cabal installations
22:59:18 <Bobby_> so i can do a fresh install
22:59:36 * hackagebot network-protocol-xmpp 0.4.8 - Client library for the XMPP protocol.  http://hackage.haskell.org/package/network-protocol-xmpp-0.4.8 (JohnMillikin)
22:59:38 * hackagebot sys-process 0.1.0 - A replacement for System.Exit and System.Process.  http://hackage.haskell.org/package/sys-process-0.1.0 (TonyMorris)
22:59:47 <kadoban> Bobby_: That really depends on your OS, how you've installed GHC/cabal, and etc.
23:00:09 <Welkin> rm -rf ~/.ghc ~/.cabal
23:02:24 <Bobby_> Probs installed with apt
23:02:33 <cj3kim> hi
23:03:03 <kadoban> Bobby_: Remove it from there then and try again, check with 'which ghc' and 'which cabal' if there is still one hanging around.
23:03:29 <cj3kim> i notice i can do this (+) 2 3 but not this (+) 2 3 4
23:03:45 <cj3kim> is there a way to overload the operator to do a summation?
23:03:51 <cj3kim> of n elements?
23:04:19 <kadoban> > sum [2, 3, 4]
23:04:20 <lambdabot>  9
23:04:33 <kadoban> cj3kim: Not really, haskell doesn't work like that. You can do that ^ though.
23:05:32 <cj3kim> ah, alrighty kadoban
23:06:10 <pharaun> cj3kim: thinking of lisp-like languages?
23:06:21 <pharaun> (+ 2 3 4)
23:06:42 <Bobby_> @kadoban Alright I got it removed! Now I worry that a reinstall may just reinstall an old version
23:06:42 <lambdabot> Unknown command, try @list
23:06:49 <cj3kim> pharaun: that was a feature I enjoyed, and, yes, from lisp
23:06:53 <pharaun> ahh k
23:06:57 <Bobby_> I still have ghc-7.10.1 installed in a folder but its not in $PATH
23:07:12 <kadoban> Bobby_: Follow the instructions I posted above, or if you have that installed, but it in your path.
23:07:26 <pharaun> > fold (+) 0 [2, 3, 4]
23:07:28 <lambdabot>      Could not deduce (Num t0)
23:07:28 <lambdabot>      from the context (Num t,
23:07:28 <lambdabot>                        Num ([t] -> t1),
23:07:28 <Bobby_> So to get the base higher I need to make this ghc work and ill install cabal from apt again?
23:07:40 <pacak> > foldl1 (+) [2,3,4]
23:07:40 <pharaun> > fold (+) 0 [2, 3, 4] :: Integer
23:07:42 <lambdabot>  9
23:07:42 <lambdabot>  <no location info>: can't find file: L.hs
23:07:50 <kadoban> Bobby_: Alternatively, there's install instructions linked from here: https://github.com/bitemyapp/learnhaskell
23:07:59 <pharaun> cj3kim: an alt is you can also use fold
23:08:14 <pharaun> what pacak said
23:08:40 <kadoban> Bobby_: base is linked with GHC. If you have a newer GHC version, you'll have a higher version of base. And install a newer cabal from one of the instructions i've linked, don't use the ones from ubuntu's repositories
23:08:48 <kadoban> They're old and fugly.
23:08:55 <pacak> You can do all kinds of stuff using various sorts of type level trickery, but you don't really want to do that.
23:09:09 <pacak> @package reflect
23:09:09 <lambdabot> http://hackage.haskell.org/package/reflect
23:09:22 <pacak> (unrelated, but I liked the magic)
23:10:27 <cj3kim> i'm very new to haskell and I have a ghci open. where is a good resource to learn how to pass command line inputs to my program and write the results to a file?
23:10:38 <cj3kim> docs?
23:10:57 <pacak> cj3kim: :main --hello 
23:11:11 <cj3kim> pacak: will try that
23:11:32 <ronh-> also
23:11:36 <ronh-> @hoogle getArgs
23:11:37 <lambdabot> System.Environment getArgs :: IO [String]
23:11:37 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
23:11:37 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: MonadIO m => m (String, [String])
23:11:40 <kadoban> cj3kim: If you're very new, you should start with a structured course, like recommended in https://github.com/bitemyapp/learnhaskell . Once you have a base to go from, it'll be easier to understand what you need.
23:11:59 <ronh-> (you want the first one)
23:12:05 <cj3kim> kadoban: thanks! 
23:12:15 <cj3kim> ronh-: thanks 
23:12:57 <pacak> @package optparse-applicative
23:12:57 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
23:12:58 <larrycv> > foldl (*) 1 [1..10]
23:13:00 <lambdabot>  3628800
23:13:36 <pacak> Not exactly friendly to newcomers, but nice.\
23:16:58 <cj3kim> pacak: thank you.
23:17:39 <Bobby_> @kadoban Okay so now I have ghc installed in a folder and its in Path. I can't use apt to install cabal as it also wants to install ghc (400MB download). So how can I get cabal setup without doing the same compiling from binary I was doing before that took 1+ hours and didnt finish
23:17:40 <lambdabot> Unknown command, try @list
23:17:46 <larrycv> pacak: that is an understatement :)
23:18:28 <pacak> larrycv: Which part, about it being nice or not exactly friendly?
23:19:04 <kadoban> Bobby_: The only instructions I know of are the two I linked above. The ones I use are the ion ones. It doesn't take very long for me, no guarantees on your weird one.
23:20:02 <larrycv> about it not being friendly to someone who just started up haskell
23:20:46 <pacak> larrycv: Well... If you kind of follow the example given and adding more fields just by looking at the type signature...
23:20:50 <Bobby_> @kadoban If I type in: ghc-pkg list, I can see Cabal there, does that means its installed?
23:20:51 <lambdabot> Unknown command, try @list
23:21:06 <pacak> Bobby_: Don't add @
23:21:09 <kadoban> Bobby_: No. 'which cabal'
23:21:35 <Bobby_> Yeah which cabal returns nothing
23:21:43 <kadoban> Cabal is a library cabal-install is a binary, which is named 'cabal' when you run it. Totally clear, huh? ;-)
23:24:48 <Welkin> Bobby_: https://www.haskell.org/cabal/download.html
23:25:39 <Welkin> Bobby_: you can get ghc from here https://www.haskell.org/ghc/download_ghc_7_8_4#x86_64linux
23:25:59 <Welkin> install ghc, then Cabal (library), then cabal-install
23:27:05 <Bobby_> Thanks for the help I appreciate it, i'm attempting the installation now
23:32:50 <Welkin> I think I figured out the strange linker errors from earlier
23:33:20 <Welkin> I had the same application running already, so the file was open, and so not available for writing
23:33:45 <Welkin> one version running in development mode while compiling the production version from the same files
23:42:01 <hiptobecubic> Wow. stack is awesome.
23:44:52 <cj3kim> kadoban: the tutorial is helping out lots
23:44:59 <cj3kim> falling in love already :)
23:55:45 <gabmus> hello everyone, in one hour I have an exam on lambda calculus, i was wondering if some of you could give me a hand (if this is the right channel, otherwise tell me where to ask) thank you :)
