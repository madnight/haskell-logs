00:00:17 <slack1256> I guess with al the Ordering checking you have to do on insertion and stuff doesn't payoff to be lazy on the values
00:00:39 <ttt_fff> slack1256: noted, thanks!
00:02:04 <slack1256> ttt_fff: (what I said is just an hipothesis though)
00:11:53 <hnfmr> why is cabal can't resolve this conflict? my project depends on protocol-buffers which in turn depends on mtl (has global constraint == 2.1.3.1)
00:12:15 <hnfmr> and then mtl depends on transformers (0.3.*), however on my machine transformers 0.4.2 is installed
00:12:17 <hnfmr> thus the conflict
00:12:56 <hnfmr> the questions: where is the "globcal constraint" from for mtl (being exactly 2.1.3.1)? i don't specify that anywhere in my project
00:12:57 <slack1256> cabal install --allow-newer
00:13:13 <slack1256> usually is helpful (shoot in the dark though)
00:13:21 <hnfmr> i try that first
00:13:42 <hnfmr> i do "cabal install --only-dependencies" in a sandbox, btw
00:14:13 <hnfmr> slack1256: it passes "dry-run"
00:14:55 <slack1256> is that possible?
00:15:33 <slack1256> isn't --dry-run another option?
00:15:34 <hnfmr> slack1256: it worked, the dependencies are installed.thanks :)
00:15:44 <hnfmr> i use dry-run to test if the conflict still exists
00:15:51 <slack1256> oh
00:16:18 <slack1256> hnfmr: also checkout cabal freeze, it gives a working set of constrains that you can use on a per-project basis
00:16:35 <hnfmr> slack1256: great
00:20:43 <ttt_fff> hnfmr: try out stacklage ... solved all my cabal problems
00:20:51 <ttt_fff> because it's a set of packages guaranteed to work together
00:20:54 <ttt_fff> it's fucking genius
00:20:57 <ttt_fff> damn brilliant
00:22:05 <hnfmr> ttt_fff: I have heard some good stories of Stack. My problem is that i have some custom build steps that requires wrapping around "hsc2hs" and generating protocol buffer files
00:22:42 <hnfmr> with cabal i can use the "--with-hsc2hs" command and modiffy "Setup.hs"
00:22:48 <hnfmr> I don't know if I can do that with Stack build
00:25:45 <slack1256> if isn't broken don't fix it :-)
00:27:50 <zipper> :t catch
00:27:51 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
00:28:15 <zipper> :info catch
00:34:52 <ttt_fff> hnfmr: stack is using cabal, it's just a cabal.config file you download
00:34:59 <ttt_fff> and it tells cabal "don't use latest versions, only use these versions"
00:38:34 * hackagebot spdx 0.1.1.0 - SPDX license expression language  http://hackage.haskell.org/package/spdx-0.1.1.0 (phadej)
01:32:03 <Wizek> Good Morning.
01:32:27 <dramforever> Wizek: hello :)
01:32:34 <Wizek> Is there a list where I can see what base versions are packaged and/or compatible with which GHC versions?
01:33:04 <dramforever> I don't know, maybe ask other peoplr
01:33:07 <dramforever> *people
01:33:36 * hackagebot engine-io 1.2.9 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.9 (OliverCharles)
01:35:37 <mauke> https://wiki.haskell.org/Base_package#Versions
01:38:26 <Wizek> mauke, Nice, thank you!
01:39:24 <Wizek> Next question: anyone knows how these kind of reports end up here? https://hackage.haskell.org/package/simple-genetic-algorithm-0.2.0.0/reports/ Is it automatic or do people need to opt-in? Or is it a manual process even perhaps?
01:40:05 <dramforever> iiuc it's automatic
01:41:09 <dramforever> I think building docs require building the code
01:41:18 <dramforever> *requires
01:42:20 <lpaste_> fr33domlover revised “testing”: “test” at http://lpaste.net/135383
01:42:37 <fr33domlover> (just a test, sorry... please ignore)
01:42:57 <dramforever> so how do you guys solve this problem: \
01:43:24 <dramforever> I'm (at least trying) writing a compiler, and I just designed my AST
01:43:57 <dramforever> but I discovered that there's no place to put code positions for later use, for example while type checking
01:44:29 <dramforever> if I put them all over the ast nodes it's quite messy
01:44:54 <geekosaur> Wizek, it's automatic, as mentioned, but the builder sometimes stalls
01:45:13 <dramforever> If I don't, I lose important diagnosticss information
01:45:18 <dramforever> *diagnostics
01:45:30 <fr33domlover> dramforever, why not position-tag the AST nodes?
01:45:39 <dramforever> fr33domlover: messy
01:45:54 <dramforever> I'm trying to have a better solution
01:46:03 <dramforever> (04:44:06 PM) dramforever: if I put them all over the ast nodes it's quite messy
01:46:23 <fr33domlover> dramforever, how about: data Positioned a = Positioned a Position
01:46:49 <dramforever> so I'll have Positioned all over my ast?
01:47:18 <fr33domlover> dramforever, you ignore the position when you don't need it
01:47:30 <fr33domlover> you could as well have other tags in the nodes
01:47:43 <fr33domlover> e.g. for optimizations
01:47:45 <dramforever> fr33domlover: um...that's not very much better than position tagging
01:48:28 <dramforever> except that you inspired me to do this: tag all recursive occurences with a functor
01:49:05 <dramforever> data Expr f = BinOpCall Op (f Expr) (f Expr) | FunctionCall Identifier [f Expr]
01:49:19 <dramforever> looks elegant enough
01:50:02 * dramforever is thinking about lens . . . .
01:51:51 <dramforever> no use, forget about it :P
01:56:51 <Wizek> geekosaur, And do you know which tool does the uploading? cabal-install?
02:05:51 <linus__> Hey guys! I'm working through the cis194 haskell course, and I'm slightly stumped. The exercise defines a Move as 'data Move = Move Code Int Int'. I'm now trying to write a function to retrieve the Code from an existing Move, but I can't seem to get it to work...
02:06:41 <linus__> I'd tried something like 'getCode :: Move -> Code, getCode _ code _ _ = code', but that doesn't accept just a Move
02:06:42 <Wizek> linus__, do you know about pattern matching?
02:06:50 <linus__> yeah, I thought I did
02:07:49 <linus__> but my attempts at defining the pattern seem to fail...
02:08:24 <dramforever> linus__: your getCode function body takes 3 args, two are ignored, middle one is named code
02:08:25 <Wizek> linus__, I believe what you are looking for is "getCode (Move code _ _) = code"
02:08:31 <dramforever> exactly
02:08:56 <Wizek> this way the function takes 1 argument 
02:09:07 <linus__> Ah! The brackets...
02:09:12 <Wizek> not just
02:09:26 <Wizek> The Move constructor was also needed to be mentioned there
02:09:39 <linus__> ah, yes, I see
02:09:43 <linus__> thanks! It works :)
02:10:01 <Wizek> linus__, yw :)
02:10:16 <ttt_fff> is there an shorter way to write "let x1 = (some complicated expr) in case x1 of ... => depends on x1"
02:10:29 <ttt_fff> i.e. I want to "capture" (some complicated expr), but I don't want to spend an extra line on "let"
02:10:36 <ttt_fff> and I don't want to retype "some complicatex expr"
02:10:47 <dramforever> case blah blah blah in x1@(pattern) -> ...
02:11:01 <dramforever> that's an as-pattern
02:11:32 <dramforever> exactly your use case, and also for functions that both need to destruct and to get the argument in whole
02:11:46 <dramforever> ttt_fff: ^
02:11:57 <ttt_fff> damn, that's nice
02:12:06 <ttt_fff> I was trying ot use >>> case fs@(blah blah blah) of
02:12:15 <ttt_fff> but it was bitching at me: you can't use patterns in case statement
02:12:20 <ttt_fff> but yours .... uses the @ in the pattern statement
02:12:25 <ttt_fff> u r smart
02:13:25 <dramforever> :) yw
02:18:38 * hackagebot descriptive 0.9.4 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.9.4 (ChrisDone)
02:21:22 <mauke> > let a@b@c = "ha" in a ++ b ++ c
02:21:24 <lambdabot>  "hahaha"
02:22:52 <ttt_fff> HAHAHA
02:22:54 <ttt_fff> so funny
02:38:39 * hackagebot urlencoded 0.4.1 - Generate or process x-www-urlencoded data  http://hackage.haskell.org/package/urlencoded-0.4.1 (fgaz)
02:58:03 <hairyian> how can I test unexported functions from a module in HUnit?
02:58:24 <dramforever> hairyian: export them :)
02:58:26 <dramforever> use CPP
02:58:35 <dramforever> I guess that's the idiomatic solution
02:58:57 <dramforever> or maybe isolate out some internal modules
02:59:07 <hairyian> they shouldny be available to the user
02:59:18 <dramforever> use CPP then
02:59:32 <hairyian> #if WHAT?
02:59:51 <dramforever> I think you can specify different flags for testing
03:03:40 * hackagebot kademlia 1.0.0.0 - An implementation of the Kademlia DHT Protocol  http://hackage.haskell.org/package/kademlia-1.0.0.0 (fro_ozen)
03:03:52 <hairyian> I thought maybe TEST or something was defined automatically
03:04:04 <dramforever> yeah maybe
03:04:26 <Diabolik> can anyone help me with the ghc-mod bug with the latest version of cabal
03:04:30 <Diabolik> im a complete haskell newbie
03:04:37 <Diabolik> so this has kind of stumped my progress
03:05:14 <dramforever> Diabolik: you don't have to use it
03:05:20 <dramforever> btw what bug?
03:05:47 <Diabolik> https://github.com/kazu-yamamoto/ghc-mod/wiki/InconsistentCabalVersions
03:05:57 <Diabolik> dramforever im trying to set up sublimehaskell 
03:06:02 <Diabolik> and it needs it apparently
03:06:46 <dramforever> Diabolik: doesn't the wiki help?
03:07:02 <Diabolik> i did everything it said
03:07:30 <dramforever> still same error?
03:07:37 <Haskellfant> according to the website of sublimehaskell ghc-mod is optional
03:08:06 <Diabolik> https://gist.github.com/askl56/9aa586bf6be3a8516800
03:08:11 <Diabolik> yeah but Haskellfant 
03:08:14 <Diabolik> if you don't install it
03:08:17 <Diabolik> everytime you save the project
03:08:24 <Diabolik> it comes up with a thing saying its not installed correctly
03:09:13 <dramforever> Diabolik: ghc version please?
03:09:29 <Haskellfant> that sounds like a bug
03:09:44 <Diabolik> Glasgow Haskell Compiler, Version 7.10.1, stage 2 booted by GHC version 7.10.1
03:09:54 <dramforever> looks good enough...
03:11:34 <dramforever> Diabolik: so you are trying to learn haskell but you got stuck setting up your editor?
03:11:43 <dramforever> so sad...
03:11:58 <Diabolik> lol i actually understood the syntax and rules fine
03:12:05 <Diabolik> or at least thus far
03:12:15 <dramforever> "W E   N E E D   A N   I D E !"
03:12:51 <maerwald> we have
03:13:07 <dramforever> maerwald: not good enough to recomment to newbies
03:13:22 <Diabolik> the thing that confused the hell out of me
03:13:24 <Cale> What exactly do you need an IDE for?
03:13:27 <Diabolik> was that cabal isn't a package manager
03:13:32 <Diabolik> but has an install function
03:13:36 <dramforever> Cale: get users
03:13:38 <Diabolik> but no uninstall function
03:13:47 <dramforever> lol exactly why cabal is weird
03:14:05 <dramforever> Cale: we lack "proper" tools in general
03:14:06 <Cale> Maybe we should just repackage gedit and call it an IDE
03:14:10 <maerwald> dramforever: that's quite popular, even cmake does not have a uninstall method
03:14:48 <Diabolik> dramforever i was actually doing well, i just need something to make sure all my code is formatted correctly
03:14:56 <Cale> Or a script which loads gedit in one window and ghci in another and then opens your web browser to your installed library documentation
03:15:29 <hairyian> Cale symbol completion,  function argument hints, built-in documentation, refactoring, code generation, debugging
03:15:41 <dramforever> Cale: just tools in general....
03:16:38 <hairyian> Cale also all of that working out of the box.. instead of having to tweak emacs/vim for a month to get a fraction of that..
03:16:59 <maerwald> hairyian: and those plugins are fragile (at least under vim)
03:17:06 <dramforever> Cale: we need a "non-trivial" package manager
03:17:18 <maerwald> dramforever: you mean nix?
03:17:22 * dramforever knows what quotes mean, trust me
03:17:26 <dramforever> maerwald: maybe
03:17:32 <dramforever> only maybe
03:17:49 <maerwald> dramforever: there's nothing comparable in the distro-land, all other PMs were written for C/C++ like languages only
03:17:57 <Cale> I'm somewhat playing devil's advocate here, but IDEs are mostly used to paper over the deficiencies of languages which are designed in such a way as to be obnoxious to work with. If certain changes to code are annoying to make, I'd rather see language or library changes to make them less annoying.
03:18:10 <maerwald> Cale: please no
03:18:19 <maerwald> IDE vs non-IDE incoming
03:18:23 <Cale> :D
03:18:30 <maerwald> useless discussion
03:18:30 <dramforever> Cale: actually I just want good tools
03:18:42 <breadmonster> Hello everyone.
03:18:48 <dramforever> Cale: that "We need an ide" line is from cartesian closed comic
03:18:52 <Cale> Similar goes for debuggers -- debuggers are a curse
03:18:56 * dramforever is helloed by breadmonster
03:19:29 <breadmonster> dramforever: You could almost turn that into a typeclass
03:19:40 <dramforever> breadmonster: ?
03:20:19 <Cale> Debuggers let people make modifications to code that they don't understand, and over time, make that code even harder to understand than it was when they arrived.
03:20:27 <breadmonster> dramforever: class IsHelloed where reply :: String -> IO String
03:20:40 <breadmonster> Cale: What exactly is your set up?
03:20:41 <maerwald> Cale: those are all fine generalizations that are useless to argue over
03:21:11 <maerwald> Cale: I could just say you are wrong and that from my experience of trying to debug _logical_ errors in non-trivial algorithms
03:21:12 <Cale> breadmonster: What set up?
03:21:53 <breadmonster> Cale: How do you write Haskell?
03:21:57 <breadmonster> Leksah or something?
03:22:07 <maerwald> he uses cat and sed only...
03:22:10 <Cale> breadmonster: No. Just GHCi, vim, web browser.
03:22:17 <breadmonster> web browser?
03:22:20 <Cale> (and terminal)
03:22:22 <dramforever> wtf nixos
03:22:26 <Cale> Sure, to read documentation
03:22:36 <maerwald> true men use curl
03:22:53 <dramforever> what about user files? does nixos not store them?
03:23:07 <Cale> Also, I don't really use enough features of vim to care that it's vim and not anything else.
03:23:11 <maerwald> dramforever: what do you mean? in $HOME?
03:23:24 <dramforever> maerwald: reproducable system configuration
03:23:28 <breadmonster> Cale: Why don't you use emacs?
03:23:56 <hairyian> "why dont you eat your first newborn"
03:24:00 <Cale> breadmonster: I could, and have. It takes slightly longer to load.
03:24:01 <dramforever> "In NixOS, the entire operating system ... is built by the Nix package manager from a description in a purely functional build language."
03:24:10 <dramforever> what about my files?
03:24:19 <maerwald> dramforever: your configuration is part of the description
03:24:22 <Cale> breadmonster: I also sometimes just use gedit.
03:24:34 <breadmonster> Cale: Argh gedit IS FUCKING HORRIBLE
03:24:43 <dramforever> maerwald: what about my randomideas.txt ?
03:24:50 <Cale> breadmonster: Honestly, anything which will convert tabs to spaces, and maintain the indentation level of the previous line, and not totally screw up syntax highlighting is fine.
03:25:02 <dramforever> researchpaper.tex, etc.
03:25:08 <maerwald> dramforever: I don't know all the details, you probably get more ideas in their IRC channels... I have just randomly tried it over the months
03:25:11 <Cale> Also, sometimes gobby, but only when working with others.
03:25:28 <maerwald> and found it too much of a hassle in its current state
03:25:37 <maerwald> but the PM is what is revolutionary
03:25:43 <breadmonster> Cale: I don't know how you manage, I really like auto-indent. Only emacs has it.
03:25:53 <Cale> I'm okay with no syntax highlighting even
03:25:54 <alpounet> dramforever: well the thing is that you can usually specify user-wide config files for your various servers, services and what not *from* your Nix files
03:25:57 <dramforever> nixos looks revolutionary
03:26:00 <Cale> But it's nice to have if it's there
03:26:06 <maerwald> dramforever: nixos != nix btw
03:26:11 <dramforever> hmm...
03:26:11 <alpounet> you can also carry some other files along in there
03:26:20 <dramforever> alpounet: oh nix is for servers?
03:26:23 <Cale> breadmonster: auto-indent frustrates me
03:26:24 <dramforever> that makes some sense
03:26:29 <alpounet> not necessarily dramforever, but can be yes
03:26:35 <dramforever> okay
03:26:38 <breadmonster> Cale: Interesting, I've never seen a place where it can fail.
03:26:40 <dramforever> what about my db files?
03:26:45 <maerwald> dramforever: nix is the PM
03:26:49 <dramforever> my user data
03:27:00 <alpounet> dramforever: what about it?
03:27:02 <dramforever> maerwald: yes, and I *am* talking about nixos
03:27:03 <Cale> breadmonster: Maybe it doesn't fail exactly, so much as not produce the indentation/alignment that I want.
03:27:18 <dramforever> alpounet: what about non-system data?
03:27:31 <maerwald> dramforever: I understand... and nixos itself is pretty much not revolutionary, instead they walk into problems other distros have already discovered
03:27:33 <alpounet> yeah, what about it is it that you want to know?
03:27:45 <maerwald> concerning workflow, hierarchy, policies and whatnot
03:27:50 <dramforever> alpounet: how does nixos deal with them
03:28:18 <Cale> There's one editor feature I'd like to have, but which as far as I know, no editor actually implements correctly
03:28:47 <ninja-maid-robot> What algorithm does Haskell use to prevent type synonyms from being recursive?
03:28:57 <ninja-maid-robot> s/algorithm/rule/
03:29:00 <Cale> which is, any edit which causes the first non-whitespace character following 'let', 'of', 'do', 'where', or 'mdo', should cause the following block to move accordingly
03:29:03 <alpounet> dramforever: it'd deal with them the way you'd tell it to
03:29:22 <Cale> s/should/to move should/
03:30:36 <alpounet> dramforever: if you say something about these files or these bits of data in your nix files, then everytime you regenerate the system from the nix files whatever you want to happen to your user files/data will happen. if they are not mentionned there they can still be around on your system, they just won't be tracked and what not
03:30:50 <Cale> ninja-maid-robot: It just looks for cycles in the dependency graph of type synonym definitions and gives an error if it finds one.
03:30:52 <dramforever> oh just like .gitignore
03:31:00 <dramforever> no
03:31:07 <alpounet> dramforever: so you can't have a guarantee to have your e.g ~/.emacs config written when booting the system 
03:31:11 <dramforever> I mean files normally included in gitignore
03:31:11 <ninja-maid-robot> Cale: Ah, thanks!
03:31:53 <alpounet> whereas if it's said in the nix config of your system to generate ~/.emacs with some precise content, then you can be sure it'll be there
03:32:07 <dramforever> alpounet: it does help to think of nixos like git
03:32:15 <dramforever> you git clone some source, make it
03:32:32 <alpounet> but that doesn't mean there can't be files around on your system that the nix config files don't know about
03:32:42 <dramforever> alpounet: okay seems good
03:33:00 <alpounet> it's just that the more you put in the nix files, the more your system is reproducible
03:33:14 <alpounet> there is less and less "implicit state" on your system
03:33:22 <dramforever> alpounet: okay I think I know more about it
03:33:50 <jle`> it's a bit annoying sometimes that lift and functions like `ask` from mtl require a Monad constraint ;_;
03:34:00 <dramforever> it would be interesting to have nix track user files automatically, but I'm not sure how...
03:34:07 <jle`> but i guess the times where you don't have to write (Monad m, MonadReader r m) => make up for it i guess
03:34:09 <jle`> maybe
03:34:41 <dramforever> also for local
03:34:52 <maerwald> dramforever: that could probably be done with a combination of "etckeeper" and some nix plugin
03:35:05 <dramforever> you can't define local in terms of ask if you don't have monad
03:35:11 <maerwald> so that you have your $HOME in a git repo and have different branches for different configurations
03:35:19 <dramforever> something like that
03:35:44 <jle`> yeah but for ReaderT you have an ask that doesn't require Monad, but i guess you can get around that by just importing the specific qualified ask from Control.Monad.Trans.Reader
03:36:34 <jle`> also the (->) r instance doesn't require Monad either
03:36:42 <jle`> but i guess mtl is good for writing things polymorphic over all instances
03:36:55 <jle`> and throwing out things like this
03:46:22 <hairyian> if I have "parser :: Parser SomeObj"  is there an easy way of interchangeable ["slurped characters until a succesful parse", "string that can be parsed", ...] :: [String]?
03:46:22 <hairyian> +getting
03:47:18 <Cale> hairyian: I'm not sure what you mean exactly
03:47:35 <Cale> hairyian: Did you want to use the 'many' combinator perhaps?
03:50:31 <hairyian> for exampe: parseInt :: Parser Int, and given "blah 10 asdf 20" I would like either ["blah ", "10", " asdf ", "20], or 
03:50:52 <hairyian> [Left "blah ", Right 10, Left " asdf ", Right 20]. 
03:51:12 <hairyian> is there any built in combonator that can do something like that that I am missing
03:51:37 <mauke> probably not built in but probably not hard to write either
03:54:26 <hairyian> I dont know how to express "read characters until parser parses"
03:56:21 <mauke> :t inits
03:56:22 <lambdabot> [a] -> [[a]]
03:56:27 <Dodecahedrus> Hi, i'm trying to get the difference in seconds between to times using the Data.Time package. My problem is I'm getting a DiffTime value and I don't know how to convert it to an Int
03:58:58 <mauke> ok, looks like DiffTime is a fractional type (in seconds)
03:59:09 <mauke> your choices are floor, ceiling, round
04:00:10 <Dodecahedrus> great, thanks :)
04:04:48 <palo> Hey there I'm not that new to Haskell, I'm starting a new project and consider using ocaml or haskell. Is there somebody here who can give me advice? 
04:06:18 <cpa> what's the prefered library to manipulate date/time? Data.Time doesn't seem to have many features
04:06:59 <cpa> palo: ask away, people will answer if they can
04:07:07 <maerwald> palo: it depends on your projects, your skills and your preferences and we don't know any of those, so I'd say we cannot help
04:08:12 <maerwald> unless the questions becomes more specific, but even then you will get "haskell" as an answer most of the time
04:08:41 <mauke> palo: perl
04:09:31 <palo> cpa maerwald, I'm very fit in functional programming CLisp Haskell scheme Scala eLisp (for years). The result of the project should be a standalone programm doing a lot of database IO (Sqlite), UI rendering, image processing and Jack Audio Connection IO.
04:09:33 <Cale> cpa: http://hackage.haskell.org/package/time
04:10:28 <Cale> cpa: This time library is deceptively well-designed.
04:10:38 <palo> There will be no fancy stuff in there basically creating algebraic data structures and passing them around, unwrap them and thats it. 
04:11:25 <Cale> cpa: Which operation are you trying to perform?
04:11:50 <maerwald> palo: well, regarding image processing, haskell does have nothing that can compete with opencv, but I don't know if any of the languages you mentioned do
04:12:12 <maerwald> and if you even need that functionality
04:12:32 <cpa> I have a string which contains a unix timestamp and I want some high-level representation. Also, it'll be push in a postgres db at the end of the day
04:12:43 <palo> maerwald: This is why i was thinking of ocaml, because of the easy to use inline C lib calls.
04:13:07 <hairyian> mauke: isnt there anything higher level? a non-greedy "match all" parser
04:13:10 <Cale> cpa: Use  posixSecondsToUTCTime :: POSIXTime -> UTCTime
04:13:12 <palo> maerwald: I almost found all c-libs I need
04:13:32 <maerwald> palo: well, in haskell you need to write bindings first, yes
04:13:59 <maerwald> and they clutter your program with the IO type
04:14:15 <Cale> cpa: Note that type POSIXTime = NominalDiffTime and NominalDiffTime is an instance of Num, which will convert as seconds when you use fromIntegral
04:14:23 <palo> yeah, also I think IO is more than 60% this programm will do
04:14:50 <palo> maerwald: thank you  I think I'll use ocaml for this one. 
04:14:55 <cpa> Cale: wow, I didn't realise that! That's pretty cool, thanks!
04:15:05 <maerwald> palo: well, IO is fine in haskell... just the C bindings are not pleasant
04:15:11 <maerwald> database access is fine too in haskell
04:15:16 <mauke> palo: what do C lib calls look like in ocaml?
04:15:33 <mauke> hairyian: how would that be useful?
04:15:46 <maerwald> image reading and basic processing we have too
04:15:51 <maerwald> juicypixels for example
04:15:57 <maerwald> but it's not opencv...
04:16:11 <maerwald> so you'll probably end up implementing stuff yourself
04:16:36 <palo> mauke: http://www.linux-nantes.org/~fmonnier/OCaml/ocaml-wrapping-c.html <- is a page I had a look at
04:17:01 <palo> maerwald: true. 
04:17:19 <mauke> palo: that's about 200% easier in haskell
04:17:38 <mauke> this isn't even close to "inline" anything
04:17:43 <mauke> you have to manually write C stub code
04:18:00 <palo> mauke: I'm listening ... 
04:18:01 <rhaps0dy> there's the weird initilalization thing though, if you want to make a library callable from C
04:18:02 <hairyian> mauke: or is it a greedy one that I would want? anyway, is there really no such combjnator in Parsec already? seems like it would be used fairly often
04:18:20 <rhaps0dy> anyone knows why the c file calling hs_init is needed?
04:18:35 <Cale> rhaps0dy: Because something needs to start the runtime system
04:18:57 <mauke> hairyian: used for what?
04:18:58 <Cale> rhaps0dy: Like, the garbage collector and thread scheduler, and all that stuff.
04:19:07 <rhaps0dy> Cale, ah, so without it, the function is still callable, but it just doesn't work as expected.
04:19:09 <rhaps0dy> Thank you.
04:19:24 <hairyian> mauke: oh just piss off with your endless questions
04:19:29 <cpa> ok, so next question: in aeson, I want to automatically derive fromJSON functions from a datatype except for one field, where I want my custom parsing function.  Is it possible?
04:19:41 <hairyian> I've seen your trolling before
04:19:45 <maerwald> hairyian: uhh? bad day?
04:19:59 <mauke> hairyian: ok, stop that or leave.
04:20:11 <hairyian> ignored
04:20:15 <maerwald> -.-
04:20:25 <maerwald> dude, you are overreacting
04:21:15 <mauke> palo: foreign import ccall "get_an_int" send_an_int :: CInt -> IO ()
04:21:30 <mauke> palo: that's the whole code for the "get_an_int" example
04:21:54 <mauke> you can then do 'send_an_int 42' in Haskell and it'll do get_an_int(42) on the C side
04:21:55 <dramforever> cpa: maybe make that field a different type
04:22:27 <palo> mauke: hmm I see. this looks easy indeed. 
04:22:35 <Cale> hairyian: I don't think mauke is trying to upset you or anything, he's just trying to understand what it is that you're trying to accomplish with your program.
04:22:37 <dramforever> IMHO, yeah ffi is ultra easy to use
04:22:53 <cpa> dramforever: what do you mean?
04:22:54 <maerwald> except you don't have "open" IO now and have to deal with the IO type everywhere you use that function
04:23:08 <dramforever> cpa: so what's the field like?
04:23:48 <Cale> hairyian: The tricky thing about the operation you're trying to obtain is that it requires heavy amounts of repeated backtracking.
04:24:09 <cpa> I'm reading an Int from JSON and I want to get back a UTCTime, so my parser is basically posixSecondsToUTCTime
04:24:34 <mauke> Cale: I doubt this is going anywhere. I asked one question (what's the use case?) and they complained about "endless questions" and trolling :-/
04:24:38 <Cale> hairyian: so it's not likely to be all that efficient -- you might be able to do it anyway though.
04:24:46 <dramforever> foo m = anyChar >> foo m <|> m
04:24:47 <palo> maerwald: I know, but this might not be a big problem.
04:24:53 <dramforever> something like that
04:25:13 <Cale> hairyian: If you're using Parsec, look at "notFollowedBy" as an example of how to proceed with something similar.
04:25:16 <maerwald> palo: ok, then while you are at it you might want to contribute/revive https://hackage.haskell.org/package/HOpenCV then :P
04:25:25 <dramforever> cpa: so why don't you just use UTCTime as the field type?
04:25:42 <palo> I'll start scetching the programm, on paper. And decide than, I'll also have a look at FFI 
04:25:44 <hairyian> Cale: I dont care about efficiency. and I can probably implement it myself. I just dont want to reinvent the wheel if it is already part of Parsec
04:26:07 <dramforever> hairyian: yeah good for you to think about that
04:26:17 <mauke> palo: https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1590008.4.3 and stuff
04:26:18 <maerwald> hairyian: how predictable is the input? have you considered something like "skipWhile (notInClass ['1'..'9'])"?
04:26:39 * dramforever once saw a newbie post that asked for improving some code
04:27:27 <dramforever> basically all replys are "this function is just foo in prelude" "that function is just foo bar" "just foldl blah blah will do here"
04:27:41 <palo> mauke, maerwald : thank you guys a lot! also thanks for not shouting at me for questioning something that looks like trolling.
04:27:51 <cpa> dramforever: dammit, that worked, I had tried but failed to import correctly Data.Time and thought the issue was aeson related. Thanks!
04:27:55 <dramforever> so like removed all functions...
04:28:09 <dramforever> cpa: ha! we all make silly mistakes at times :)
04:28:31 <hairyian> maerwald: something like that could improve efficiency but I still need to test the input with my parser
04:30:53 <hairyian>  thanks for a suggestion. and thanks to Cale too, notFollowedBy looks interesting
04:31:57 <dramforever> hairyian: basically that is hard\
04:32:21 <dramforever> but I believe you can parse regex like that efficiently
04:32:30 * dramforever just realized that...
04:32:42 <dramforever> so how "regular" is your parser?
04:34:03 <hairyian> not very.. it is parsing monetary values with many different currencies. and it is very loose in what input it accepts
04:37:23 <kclawl> if one is deciding between haskell and f# would F# basically be prefered on windows and haskell everywhere else?
04:37:51 <dramforever> kclawl: haskell is okay on windows
04:38:44 * hackagebot bustle 0.5.1 - Draw sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.5.1 (WillThompson)
04:38:52 <kclawl> just okay?
04:40:05 <dramforever> kclawl: why you won't use it on windows?
04:40:28 <dramforever> IMHO some libs are hard to install, but not very much easier for other languages either
04:40:33 <ChristianS> kclawl: it doesn't really make sense to use different languages on different computing platforms. just choose haskell and stick with it.
04:41:37 <kclawl> ChristianS but what if one uses just windows? do haskell's advantages overcome F#'s access to .net?
04:42:47 <dramforever> kclawl: you decide
04:43:19 <Haskellfant> well if you care about .net then f# is probably better
04:46:26 <merijn> I'd say haskell is better, but F# is an acceptably solid language, comparable with things like ocaml
04:46:46 <merijn> I'd rank it "Would program for money if I can't get hired to write haskell" out of 10 :p
04:48:36 <maerwald> merijn: programming something only for money is not very highly ranked :P
04:49:05 <merijn> maerwald: It's still higher than most other languages which I wouldn't even program for money :p
05:00:45 <Wizek> is it possible with either ghc or ghci to compile+run a piece of haskell code from the command line interacting with stdin and stdout without polluting pwd?
05:00:56 <Wizek> s/ghci/runghc/
05:01:22 <Wizek> runghc is fine, but is slow sometimes
05:02:31 <Wizek> so I am thinking about something like this `echo 'main = print 1' | ghc -O2`
05:02:59 <Wizek> ghc: no input files
05:03:23 <maerwald> Wizek: I don't even understand the problem... how about you just use a subshell when you run your haskell code?
05:13:46 * hackagebot should-not-typecheck 1.0 - A HUnit/hspec assertion library to verify that an expression does not typecheck  http://hackage.haskell.org/package/should-not-typecheck-1.0 (CRogers)
05:17:33 <Fuuzetsu> do we still not have a list split in base?
05:18:32 <Fuuzetsu> Wizek: you can pass various flags to GHC to tell it where to output stuff
05:18:37 <Fuuzetsu> you can redirect pretty much everything with those
05:24:17 <rhaps0dy> Wizek: try using - for stdin input
05:24:54 <rhaps0dy> Wizek: try using runhaskell too
06:22:47 <gcganley> could someone give me a summary on whats going on with cabal with the new stack? I have been away from haskell for about a month now.
06:33:51 * hackagebot tuple-th 0.2.5 - Generate (non-recursive) utility functions for tuples of statically known size  http://hackage.haskell.org/package/tuple-th-0.2.5 (DanielSchuessler)
06:52:55 <whiteline> how do i do utf-8 input?
06:53:17 <whiteline> i just get hGetContents: invalid byte sequence if i use standard readFile
06:54:12 <silver> are you using windows?
06:54:22 <whiteline> no
06:54:36 <whiteline> fedora 22, system encoding is UTF-8
06:56:23 <whiteline> nevermind, it turns out it actually reads utf-8 just fine. i just have invalid byte sequences in my utf-8 encoded files.
07:02:46 <hodapp> hmmm... I am trying to figure out what the fundamental difference is between the type signature "(eff ~ NoEffects) => Foo -> Ivory eff ()" and "Foo -> Ivory NoEffects ()"
07:03:52 * hackagebot heyefi 0.1.0.0 - A server for Eye-Fi SD cards.  http://hackage.haskell.org/package/heyefi-0.1.0.0 (ryantm)
07:04:11 <Haskellfant> hodapp: chrisdone has a recent blogpost on a case where it makes a difference http://chrisdone.com/posts/haskell-constraint-trick
07:04:55 <hodapp> thanks!
07:15:23 <sm> gcganley: stack is a better cabal-install, using curated package sets from stackage by default and handling multi-package projects and ghc installation. It uses the Cabal lib and your existing cabal files and adds a per-project stack.yaml file. It's a big deal, see reddit and hacker news for more
07:48:24 <pharpend> If there are any Arch Linux users here, would you mind helping me with <https://github.com/commercialhaskell/stack/issues/440>?
07:48:54 * hackagebot html2hamlet 0.3.0 - HTML to Hamlet converter  http://hackage.haskell.org/package/html2hamlet-0.3.0 (HideyukiTanaka)
07:58:50 <Haskellfant> pharpend: if it helps: I can reproduce your problem
07:59:14 <pharpend> Haskellfant: yay! would you mind commenting as such on the PR? Also, include your operating system
07:59:23 <sivteck> pharpend, stack hell. abandon ship!
07:59:46 <pharpend> sivteck: cabal repl is doing the same thing. I've been a Haskeller long enough to navigate cabal hell
07:59:47 <Haskellfant> I don't even understand what part is trying to load ncurses
07:59:54 <pharpend> stack hell is a new ball game
08:00:22 <pharpend> Haskellfant: it might be my specific library, it uses GNU Readline, which depends on ncurses
08:00:32 <Haskellfant> ah readline allright
08:01:44 <pharpend> Depends On     : glibc  ncurses
08:01:53 <pharpend> ^ the Arch Linux readline package
08:14:20 <karshan> Hey, has anyone here used the syz package ? I'm wondering if its possible to write an Eq instance for Zipper a
08:20:32 <geekosaur> pharpend, I know that failure
08:20:57 <geekosaur> the problem is that libncurses.so is a linker script containing the string INPUT(-lncursesw)
08:22:02 <geekosaur> ghci's linker apparently knows enough to recognize the linker script but expects the parameter to INPUT to be a path, not a -l triggering a normal library search
08:22:11 <geekosaur> (debianoids have this issue all the time)
08:28:40 * geekosaur commented on GHI
08:32:31 <pharpend> geekosaur: thanks. 
08:34:37 <geekosaur> that said I thought ghci used the system linker these days...
08:42:06 <lethjakman> in learn you a haskell for great good they defined a function like this: x -: f = f x  
08:42:30 <lethjakman> is it standard practice to just define things that look like it could be a part of the language like that? it just feels odd to me. 
08:42:44 <geekosaur> not that unusual, no
08:42:53 <saep> let x -: f = f x in 7 -: succ
08:42:57 <saep> > let x -: f = f x in 7 -: succ
08:42:59 <lambdabot>  8
08:43:47 <geekosaur> for example, xmonad has <+> as an alias for mappend (predating, and indeed inspiring, <> in base; <+> was already in use in the ghc source tree)
08:43:56 <lethjakman> ugh...cats. 
08:43:59 <lethjakman> sorry what was that?
08:44:35 <ackthet> <geekosaur> for example, xmonad has <+> as an alias for mappend (predating, and indeed inspiring, <> in base; <+> was already in u│························································
08:44:40 <ackthet> crap
08:44:42 <ackthet> sorry
08:44:53 <ackthet> geek+| for example, xmonad has <+> as an alias for mappend (predating, and indeed inspiring, <> in base; <+> was already in use in the ghc source tree)
08:44:58 <ackthet> stupid tmux
08:45:08 <lethjakman> ahhhh, thank you
08:45:10 <lethjakman> lol...
08:45:17 <lethjakman> you know it has built in copy paste right?
08:45:38 <lethjakman> ^a+[ move to where you want and press space then ^a+] to paste
08:45:41 <ackthet> yeah but selecting in in the terminal is so much faster!
08:45:44 <maerwald> or just use a real irc client
08:45:57 <ackthet> ...a real irc client? i'm using weechat
08:45:57 <lethjakman> ackthet: if you turn on mouse mode you can select it in tmux and have it auto copy for you
08:46:02 <lethjakman> me too!
08:46:05 <geekosaur> and I chose that example exactly to demonstrate one of the failure modes; the same user defined operator may mean different things in different source trees
08:46:17 <ackthet> lethjakman: cool, will check that out
08:46:31 <geekosaur> otoh it's no different from someone having a custom local definition of, say, head
08:46:32 <lethjakman> ok, so I basically have to dig every time I find an operator that's doing something I find unexpected?
08:46:42 <geekosaur> yes
08:46:50 <lethjakman> I wish ghci had show-method like in ruby's pry...there isn't anything like that is there?
08:46:52 <geekosaur> I keep a tab open on hayoo for that
08:46:55 <bernalex> lethjakman: everytime you find a function you don't know you have to check its type
08:47:07 <bernalex> lethjakman: operators are just plain functions.
08:47:18 <lethjakman> fair enough
08:47:20 <lethjakman> thank you
08:48:02 <bernalex> lethjakman: what does pry do?
08:48:22 <Welkin> it is a ruby interpreter
08:48:34 <lethjakman> bernalex: it's a super nice repl
08:48:36 <maerwald> @type show
08:48:37 <lambdabot> Show a => a -> String
08:48:42 <maerwald> we have a show method
08:48:52 <lethjakman> you can do things like show-method obj.method and it will show you where it was defined and exactly what's in that method
08:48:58 <lethjakman> then you can open that method and edit it, and retry it
08:49:02 <lethjakman> so much to it. 
08:49:03 <maerwald> ah
08:49:08 <lethjakman> obviously ghci isn't a repl though
08:49:25 <lethjakman> how does show method work?
08:49:29 <hsk7> A long shot, but is anyone here familiar with Apple's Swift 2, in particular protocol extensions and what they call "protocol-oriented programming"? I see some similarities with Haskell that I wanna discuss.
08:49:41 <maerwald> lethjakman: your best bet might be leksah there, I don't remember that working well in vim, although there is some sort of tags support
08:50:02 <Welkin> hsk7: I think you want to avoid swift; it has been a nightmare for me compared to haskell
08:50:07 <Welkin> there are almost no similarities
08:50:20 <maerwald> hsk7: swift is horrible in it's current state, avoid it
08:50:22 <Welkin> it is similar in the way that C++ and Java are similar to Haskell (not much at all)
08:50:32 <hsk7> Welkin, maerwald, elaborate?
08:50:39 <hsk7> what's bad about it..
08:50:39 <saep> codex works great for tags in vim
08:50:47 <maerwald> hsk7: it's not really finished, there's not even a documentation standard last I checked
08:50:59 <maerwald> and I've seen some interesting bugs that are not sorted out yet
08:51:10 <maerwald> I'd wait a bit
08:51:12 <Welkin> hsk7: it is realy just objective-c with some extra features
08:51:24 <maerwald> hsk7: and it does NOT support preprocessor
08:51:29 <maerwald> so have fun using it with C libs
08:52:19 <Welkin> Optional types are a mess to work with
08:52:20 <maerwald> and the functional elements... are really a joke, tbh
08:52:21 <bernalex> lethjakman: you can use :info to figure out what stuff is and where it's defined
08:52:28 <Welkin> it is nothing like Haskell's Maybe
08:52:29 <bernalex> lethjakman: then you can use :edit to edit the module
08:52:34 <bernalex> lethjakman: ghci is indeed a repl.
08:52:38 <hsk7> Do you see similarities with Swift protocols (that make use of Self in their method signatures) and Haskell's type classes? I saw some resemblance.
08:52:40 <lethjakman> bernalex: ahh, I'll try that. that sounds great
08:52:48 <maerwald> you can write a curried function in swift... but you have to write all the closures yourself, uuh, how is that functional?
08:52:48 <Welkin> yes, plus it is *not* functionall at all
08:53:23 <lethjakman> is it? I've seen it explained that it wasn't but I didn't know for sure. 
08:53:28 <bernalex> lethjakman: what we should have IMO is the ability to just :edit funciton, and have ghci figure out where function is defined, & open the right file.
08:53:45 <nshepperd_> you don't need to be curried by default to be functional
08:53:53 <lethjakman> hmmm, everything but the actual code definining it
08:53:55 <lethjakman> info is nice
08:54:06 <lethjakman> that would be sweet!
08:54:08 <lethjakman> that's what pry does
08:54:22 <nshepperd_> but swift is indeed pretty imperative
08:54:23 <bernalex> lethjakman: ok. that's very useful.
08:54:48 <maerwald> hsk7: and although you can theoretically write stuff that is a bit functional... all the core libs/frameworks are NOT functional, so...
08:54:58 <maerwald> it doesn't even make sense to try
08:55:17 <lethjakman> bernalex: http://pryrepl.org/screencasts.html
08:55:23 <bernalex> swift is "functional" like odern java and c++.
08:55:24 <lethjakman> I think this only covers a small section of what it can do
08:55:41 <hsk7> ok..
08:55:45 <maerwald> bernalex: can you write curried functions in c++?
08:56:36 <nshepperd_> i don't think swift protocols are powerful enough for the great stuff like functor, at least
08:56:40 <maerwald> hsk7: btw... a function can be declared by "func", "var" and "let"... oh my :)
08:56:50 <bernalex> s/\(odern\)/m\1/
08:56:55 <hsk7> lol dudes..
08:57:01 <saep> lethjakman: If you use vim, you can install codex (a haskell program) to generate tags. You can then jump to the functions using normal tag commands (ctrl+], ctrl+o, :tag function). Works pretty well wor me.
08:57:16 <maerwald> hsk7: so reading swift code can be pretty funny
08:57:20 <hsk7> hehe
08:57:39 <bernalex> I assume it doesn't have higher kinded polymorphism?
08:57:42 <hsk7> haskell is like nirvana when it comes to code beauty
08:57:43 <maerwald> and... you cannot escape obj-c, even in swift
08:57:48 <bernalex> in which case I don't see why you should care about it.
08:57:52 <lethjakman> ahhhh, I am a vim user so I'll have to check that out. is it better than the ones generated by ghci?
08:58:12 <lethjakman> that certainly helps a lot. 
08:58:31 <bernalex> hsk7: I'm sure an agda programmer would disagree with you :)
08:58:57 <saep> lethjakman: It also creates tag-jump targets for all dependencies of your project, so I think it is better. (I have not used the ghci-tags for a long while, though.)
08:58:58 <hsk7> sigh wtf
08:59:01 <hsk7> another programming language!
08:59:09 <hsk7> (that i've never heard of)
08:59:13 <hsk7> lulz
08:59:15 <lethjakman> ahhh, that definitely sounds better. 
08:59:27 <lethjakman> I'm gonna go play with all the info I was given. thank you everyone!
08:59:28 <bernalex> hsk7: agda is a dependently typed language.
08:59:31 <maerwald> yeah, you can write beautiful and ugly haskell
08:59:54 <bernalex> saep: can you jump to e.g. GHC's src for 'head' in a trivial way though?
08:59:54 <maerwald> doing it beautifully might just be a bit easier than in some other lang
09:00:18 <Welkin> like the way a java programmer writes haskell => it looks like java with lots of nested if then else
09:00:27 <Welkin> vs pattern matching
09:00:49 <bernalex> and using typeclasses almost like java classes mixed with java interfaces :)
09:01:44 <saep> bernalex: No, damn! 
09:01:58 <maerwald> Welkin: pattern matching goes out of the window in a lot of more complicated/efficient libraries anyway, including stuff like Data.Text or ByteString
09:02:10 <maerwald> so they might even be on the right track :P
09:02:49 <exio4> you can still do pattern matching on the results of functions like T.uncons, and using view-patterns + patternsynonyms get you halfway there 
09:03:13 <exio4> also, sometimes I prefer MultiWayIf, or mixing guards with cases 
09:03:37 <bernalex> just say no to bools
09:03:40 <bernalex> bools considered harmful
09:03:46 <bernalex> etc
09:04:29 <maerwald> exio4: except that no lib maintainer writes that stuff for me, it is annoying
09:04:39 <Welkin> bernalex: aren't you working on a game? or a game server/client?
09:04:43 <maerwald> except a few, like diagrams
09:04:44 <exio4> maerwald: well, patternsynonyms are relatively new 
09:05:02 <exio4> maerwald: also, you can still just use view-patterns and use the normal functions 
09:05:04 <bernalex> Welkin: yes. hacked for two days on it.
09:06:16 <exio4> f (T.uncons -> Just (x,xs)) | x == '!', (cmd:args) <- T.words xs = runCommandHandler cmd args -- as a little example
09:08:27 <saep> bernalex: Now it works with 'head'. I must have been somewhere strange. 
09:08:37 <exio4> you can also move the whole thing to a view pattern, now I realized :)
09:19:30 <SpaceDuck_> hey
09:19:52 <SpaceDuck_> does anyone know a way to convert a value or type a to IO a ?
09:20:10 <Clint> SpaceDuck_: return
09:20:19 <Clint> or pure
09:20:25 <SpaceDuck_> damn was that simple
09:20:34 <SpaceDuck_> thanks a lot, i feel dumb 
09:21:03 <maerwald> @type return
09:21:04 <lambdabot> Monad m => a -> m a
09:21:15 <maerwald> @type pure
09:21:17 <lambdabot> Applicative f => a -> f a
09:21:23 <SpaceDuck_> thanks guys
09:21:31 <Jello_Raptor> hmm, is there someway to have a "class Foo a where f :: forall a. Eq a => a -> Bool" and a "class Foo a => Bar a where f :: forall a. => a -> Bool" Basically, allow a typeclass to loosen the restrictions on a function definition on a typeclass. Eventually, I want a hierarchy of classes that provide progressively fewer guarantees on various inputs and outputs. 
09:24:14 <sccrstud92> Jello_Raptor: did you mean to use a as both the typeclass type and a universally quantified type?
09:24:24 <sccrstud92> because I dont think you can do that
09:24:34 <Jello_Raptor> sccrstud92: d'oh, nope 
09:25:11 <Jello_Raptor> "class Foo a where f :: forall b. Eq b => b -> a" and a "class Foo a => Bar a where f :: forall b. => b -> a" would be better
09:26:19 <Jello_Raptor> (and yes, I know functions with those signatures are probably just 'const' :P but they're only examples) 
09:26:31 <fr33domlover> Does the DarcsPatchWatch plugin for lambdabot still exist?
09:26:52 <fr33domlover> (I'd like to reuse the code without lambdabot as a separate small bot)
09:29:11 <geekosaur> I think the service it used (darcswatch) was discontinued?
09:29:33 <ansible1> If I run my prog with +RTS -I0 -RTS, does that mean garbage is never collected and memory usage expands infinitely?  or if not when does garbage collection happen?
09:33:35 <fr33domlover> geekosaur, I got the impression it's just an apply posthook
09:33:48 <fr33domlover> works from within the darcs repo itself
09:47:42 <zipper`> Anyone know why I am unable to catch the exception here in Line 28 http://lpaste.net/1138137694598070272
09:48:21 <zipper`> I get this excpetion on the browser from warp `FailedConnectionException2 "localhost" 3001 False connect: does not exist (Connection refused)`
09:50:59 <geekosaur> because reverseProxy is outside of the catch?
09:52:15 <tHEbIgtHEb> Hey, I'm new here , I had been eying haskell since a while now and finally decided to learn this properly. 
09:52:31 <zipper`> geekosaur: it is? How do I put it in the catch then?
09:52:44 <zipper`> I wonder how it compiles then.
09:53:29 <zipper`> Wait is reverseProxy the one throwing the error or is it the run?
09:53:41 <geekosaur> reverseProxy is what has the connect
09:54:03 <geekosaur> I would guess that you expected it to happen when the application is run, but it's being done immediately?
09:54:54 <zipper`> geekosaur: Okay let me see how I can do it.
09:55:17 <geekosaur> catch (reverseProxy >>= run 3000)
09:55:25 <geekosaur> and remove line 27
09:58:30 <geekosaur> well. I'm actually guessing, since I'm not really familiar with WAI.. this seems right though, since anything else should trigger inside the run
09:59:37 <zipper`> geekosaur: Look at the last lines here:
09:59:39 <zipper`> http://lpaste.net/6978075538095079424
09:59:46 <zipper`> geekosaur: ^
09:59:51 <zipper`> still fails :(
10:02:24 <sccrstud92> zipper: are you sure FailedConnectionException2 is a HttpException?
10:02:54 <sccrstud92> if you chang it to catch SomeException, does it work?
10:03:05 <geekosaur> there is that
10:03:10 <geekosaur> I also wonder if the catch is breaking it
10:03:44 <geekosaur> because, inspecting the code of http-reverse-proxy this is what defaultOnExc is supposed to handle
10:04:01 <geekosaur> but you're not getting that either
10:04:35 <zipper`> I am https://hackage.haskell.org/package/http-conduit-2.1.5/docs/Network-HTTP-Conduit.html#t:HttpException
10:04:55 <zipper`> It is a HttpException
10:06:37 <sccrstud92> zipper: you can add some traces to pinpoint which action is throwing the exception
10:06:43 <zipper`> I see what you guys mean
10:06:54 <zipper`> The issue is probably in waiProxyTo
10:08:50 <Phillemann> Is there anything that wraps "maybe mempty f maybe" where f is a function to the mono...oh, sorry. foldMap, of course.
10:13:53 <broma0> how would i model a n-ary tree with a fixed depth? (for a DOM sort of thing with fixed tag structure)
10:17:24 <maerwald> broma0: you want the depth to be part of the data structure?
10:17:45 <sccrstud92> i dont know how to do that without type level ints
10:18:10 <c_wraith> You can do it with GADTs
10:18:14 <broma0> maerwald: yes
10:18:15 <sccrstud92> thats true
10:18:20 <sccrstud92> just popped into my head
10:18:46 <broma0> maerwald: my structure is something line "layout > buffers > blocks > lines > words > chars"
10:19:58 <zipper> geekosaur: sccrstud92 I got it
10:20:21 <sccrstud92> geekosaur: what was it?
10:20:27 <zipper> The error was in the second argument to waiProxyTo
10:24:29 <maerwald> broma0: why not an implicit tree? I mean, a layout is a list of buffers is a list of blocks is a list of lines.... that's basically the same as a RoseTree except that it doesn't reference itself but a different list
10:26:11 <broma0> maerwald: I actually had this implemeneted as a big set of nested zippers
10:26:48 <nshepperd_> data Word = Word [Char]; data Line = Line [Word]; ...?
10:27:37 <broma0> nshepperd_: that's what I'm messing with now.. realizing the extra data types are kind of superflous when my structure is just a list of lists of lists..
10:27:58 <maerwald> broma0: but after that, you can convert it to a conventional tree (if you have a common typeclass over those structures)
10:28:34 <maerwald> that tree is sort of guaranteed to have that fixed depth too
10:28:36 <broma0> maerwald: true. i'm struggling with coming up with genralized get/put/del/update functions that work on a provided depth of the zipper
10:29:10 <broma0> i really dont want to write getTab, getBuffer, getBlock, getLine, getWord and getChar
10:29:21 <maerwald> sounds like a case for lens, but I have no experience with that
10:29:59 <broma0> maerwald: I was looking into lenses for a long time last night.. turns out going between tuples and lists can be a PITA (my zipper structure is ([],[]))
10:30:16 <Eduard_Munteanu> broma0, since you have predefined levels (tabs, buffers etc.) as opposed to arbitrary nesting, why not?
10:30:32 <broma0> Eduard_Munteanu: why not write out all of the cases?
10:30:44 <Eduard_Munteanu> broma0, yes
10:32:26 <broma0> Eduard_Munteanu: too much typing.. I'd also like to be able to add a new level on the fly and only have to make one code change (add a lens-type thing)
10:33:30 <Eduard_Munteanu> broma0, oh ok. I just mean don't try to over-engineer the final interface, since levels are fixed anyway.
10:36:39 <broma0> does anyone know of some reading on a list-zipper with the cursor pointing to a sublist? for example, a zipper like ([1,2,3],[4,5],[6,7,8,9,10) where 4 & 5 are focused. 
10:37:05 <broma0> i think the inner list just needs to be doubly lined to allow O(1) expansion in either direction
10:37:10 <broma0> linked*
10:37:55 <sccrstud92> which u cant dont, really
10:37:59 <sccrstud92> cant do*
10:38:06 <c_wraith> Err.  The standard zipper structure for a list looks like  data ListZipper a = ListZipper [a] a [a]
10:38:13 <broma0> sccrstud92: thats the issue here
10:38:16 <c_wraith> That gives you O(1) movement in either direction
10:38:24 <nshepperd_> doubly linked lists would be pretty useless in haskell
10:38:35 <broma0> c_wraith: i see that, but i'd rather model it as ([],[]) so there can be no focux
10:38:50 <sccrstud92> nshepperd_: most things that don't exist are useless =)
10:38:53 <maerwald> sccrstud92: doubly linked list is possible, but I only know about a circular one
10:38:56 <broma0> what's an empty zipper in your case?
10:39:05 <sccrstud92> maerwald: how do you do it?
10:39:14 <maerwald> https://wiki.haskell.org/Tying_the_Knot#Migrated_from_the_old_wiki
10:39:17 <broma0> Data.List.cycle
10:39:17 <c_wraith> broma0: It seems less useful to not focus on something, but it does change the fact that moving in either direction is O(1)
10:39:29 <c_wraith> broma0: err, *doesn't*
10:39:39 <Eduard_Munteanu> It doesn't have to be circular.
10:39:47 <c_wraith> broma0: the important part is that you keep the "previous" list reversed
10:39:50 <nshepperd_> if you really need something with O(1) append to either end, there's data.sequence
10:40:05 <broma0> c_wraith: exactly. i guess its a matter of the application
10:40:11 <frerich> broma0: You could just have a 'Maybe (ListZipper a)' :-)
10:40:18 <broma0> frerich: yuck
10:40:25 <nshepperd_> but you usually don't need data.sequence
10:40:32 <frerich> broma0: ...if you wanted to express that a zipper can be empty.
10:41:05 <broma0> nshepperd_: do you see a way to make something like ([1,2,3],[4,5],[6,7,8,9,10) without it?'
10:41:09 <monochrom> data DLL = Ctor DLL Int DLL; example = Ctor el 10 er where {el = Ctor er 5 example; er = Ctor example 15 el}
10:41:12 <Eduard_Munteanu> data ListZipper a = ListZipper [a] [a]   is fine too
10:41:16 <monochrom> This is also known as DLL Hell
10:41:29 <Eduard_Munteanu> Not comonadic anymore, though.
10:41:33 <nshepperd_> it's not great to have a zipper that can be empty, since it's no longer comonad?
10:41:38 <nshepperd_> yeah
10:42:27 <nshepperd_> broma0: why do you need to do that, anyway?
10:42:33 <Eduard_Munteanu> (or perhaps a comonad on the category of partial functions)
10:42:41 <broma0> nshepperd_: have a possibly empty zipper?
10:43:04 <nshepperd_> broma0: having multiple items in the "center"
10:43:25 <broma0> I'm making a text editor as a fun side project, and i need to model a selection of text
10:44:20 <sccrstud92> broma0: have you done research on that? its something that has been implemented a lot, so i sure you can find good resources on it
10:45:02 <broma0> sccrstud92: yes, not enough yet, but ive been studying YI for a while 
11:16:39 <rjayatilleka> Hello?
11:16:56 <rjayatilleka> Hello everybody! Is there anyone who uses the vim tagbar plugin?
11:22:53 <NicX> Is there a way to do pattern matching on function composition similar to how we do it on lists? For instance: (x:xs) for lists would be (f . fs) and (x:[]) would be (f . id)
11:25:17 <bergmark> NicX: no, functions are opaque. and x : [] is not similar to f . id since x : [] : [] /= x : [], but f . id . id = f . id
11:26:45 <sccrstud92> NicX, you can however create a type that represents a list of functions and pattern match on that
11:26:58 <sccrstud92> composition appends the lists
11:27:09 <sccrstud92> deferred composition basically
11:27:25 <sccrstud92> and you actually compose them right before you actually apply the function
11:29:04 <NicX> sccrstud92: I think that would work
11:29:11 <NicX> thanks
11:33:05 <lenarhoyt> hi, noob question: how can I use a cabal package? I've executed `cabal install friday` and the documentation says that it provides the module `Vision.Image`, however ghci says upon loading the .hs file that it could not find the module
11:35:26 <c_wraith> Hyperion reference?
11:35:54 <lenarhoyt> yes
11:36:06 <c_wraith> To the question at hand, though..  does the output from "ghc-pkg list" include the friday package?
11:36:31 <e1s1ghul> In other news: http://motherboard.vice.com/read/the-skys-not-your-lawn-man-wins-lawsuit-after-neighbor-shotgunned-his-drone
11:36:53 <lenarhoyt> c_wraith: hm, no
11:37:05 <c_wraith> lenarhoyt: then the install must have failed somehow
11:37:20 <c_wraith> lenarhoyt: or you might be using a sandbox?
11:37:32 <c_wraith> lenarhoyt: if you're using a sandbox, that's important information to get out there. :)
11:40:32 <lenarhoyt> oh, I'm an idiot. I've overlooked an error in the install log because cabal was out of date. it works now! thanks anyway
11:41:39 <c_wraith> glad to hear
11:53:57 <statusfailed> Is there some kind of embedded haskelly version of the Erlang actor system?
11:54:17 <statusfailed> I have a few threads sending messages around and I want to make sure each thread never dies
11:56:14 <monochrom> I don't know why this needs actors. A Haskell thread doesn't die unless and until one of: it is done; it kills itself; someone else kills it; the main thread dies.
11:56:47 <c_wraith> "ensuring" it never dies is just a matter of catching exceptions in its main loop.
11:57:39 <c_wraith> Though really, you probably should be a bit more careful than catching all exceptions.
11:57:51 <c_wraith> You should probably notice ThreadKilled and shut down cleanly, for instance.
12:01:55 <sccrstud92> statusfailed: async can make working with separate threads nicer
12:02:04 <sccrstud92> the async package, that is
12:09:04 * hackagebot prometheus-client 0.1.0.1 - Haskell client library for http://prometheus.io.  http://hackage.haskell.org/package/prometheus-client-0.1.0.1 (fimad)
12:09:06 * hackagebot prometheus-metrics-ghc 0.1.0.1 - Metrics exposing GHC runtime information for use with prometheus-client.  http://hackage.haskell.org/package/prometheus-metrics-ghc-0.1.0.1 (fimad)
12:09:08 * hackagebot wai-middleware-prometheus 0.1.0.1 - WAI middlware for exposing http://prometheus.io metrics.  http://hackage.haskell.org/package/wai-middleware-prometheus-0.1.0.1 (fimad)
12:20:51 <adarqui> hey, anyone know how to disable the unicode symbol 'translation' in haskell-vim-now?
12:22:58 <adarqui> it says it's disabled by default with stylish-haskell.. don't see where the config is though
12:30:40 <adarqui> i modified .vimrc to use stylish-haskell -c ~/default.yaml , no luck.. anyway if anyone uses haskell-vim-now and knows how to disable these unicode symbols, let me know ;f
12:34:53 <exio4> is there any way to have multiple "states" using StateT (yet, leaving each "state" standalone?) I want to avoid putting everything into a single record, as that's pretty fragile 
12:35:31 <statusfailed> sccrstud92: The examples with async are all things that "run once" and have an end result- is there something similar for streaming data?
12:36:36 <sccrstud92> statusfailed: well for streaming data most people typically use pipes or conduits
12:36:38 <statusfailed> c_wraith: You're right- when I said "actors" I really wanted a kind of "declarative stream processing", which seemed sort of actor-y at the time
12:36:59 <statusfailed> sccrstud92: What I have now is machines, but I have to manually fork and Chan them together
12:37:02 <statusfailed> bit naff
12:37:09 <statusfailed> Pipes is still a "single pipeline" right?
12:37:10 <adarqui> exio4: you could nest StateT's and create putX, putY, etc.. but that sounds a bit messy
12:37:22 <sccrstud92> statusfailed: not necessarily
12:37:47 <sccrstud92> statusfailed: what are you trying to get out of concurrency?
12:37:57 <sccrstud92> i.e. what do you need concurrency for
12:38:00 <j42> sorry I'm still really new to the language (diving in head first)... any idea why I'm getting this error?
12:38:06 <sccrstud92> if you are doing stream processing
12:38:07 <j42> Couldn't match expected type ‘Array Int Double’ with actual type ‘Int -> Array Int Double’
12:38:24 <sccrstud92> j42: looks like you forgot to supply an Int argument
12:38:29 <exio4> adarqui: my idea was leaving, somewhat, the "number of states" polymorphic, while avoiding inventing ad-hoc "MonadStateX" instances, which is the second thing I had in mind, both are equally crappy, at least for me :P
12:38:29 <statusfailed> sccrstud92: I have two sockets, both reading. I want to process messages from both streams in the order they come in (which is nondeterministic)
12:38:43 <bofh> Hi there, I'm not a reqruiter or somethinf like that - I just got contacted by some guy, who seeks for a good Haskell developer to join his startup in Boston. If anybody interested - pls let me know, I'll forward his contacts. Sorry if it's an offtopic.
12:38:44 <sccrstud92> j42: or maybe you applied an extra Int argument
12:38:54 <j42> I'm doing stream processing as well--I have audio data vectors unpacked to the type Array Int Double and when I pass that to DSP it doesn't seem to recognize it as Array Int Double
12:39:02 <j42> I'm sorry if I'm being thick here...
12:39:08 <mauke> j42: you're not passing arrays, you're passing a function
12:39:11 <heatsink> j42: The actual type is (Int -> Array Int Double), which is a function type
12:39:12 <j42> https://hackage.haskell.org/package/dsp-0.2.3/docs/src/DSP-Window.html#hanning
12:39:16 <sccrstud92> j42: can you post the code?
12:39:17 <mauke> which likely means that you forgot an argument in the call
12:39:22 <j42> 2s
12:39:24 <j42> thank you!
12:39:41 <statusfailed> oh wow, didn't know there was a DSP package, cool!
12:39:57 <sccrstud92> statusfailed: are you guys doing the same thing? lol
12:40:05 <alyte> sup guys, I'm writing something which encodes data in binary format, I'm using Data.Binary, and I think I'm doing something wrong or perhaps I'm confused
12:40:08 <statusfailed> sccrstud92: no no haha
12:40:20 <statusfailed> sccrstud92: I'm reading socket data
12:40:24 <alyte> length $ encode (pi :: Double) is 25
12:40:30 <statusfailed> which is nothing to do with audio
12:40:31 <statusfailed> haha
12:40:37 <alyte> but doubles are supposed to take up 8 bytes?
12:41:06 <j42> https://gist.github.com/j42/a1cb6d22488345045182
12:41:28 <j42> The commented portion toward the bottom is the issue--I think I'm probably misunderstanding the type signatures
12:42:07 <statusfailed> j42: "hanning" is a function
12:42:14 <mauke> alyte: "in binary format"  <- which binary format?
12:42:18 <sccrstud92> j42: Array Int Double means you have an array of Double indexed by Ints
12:43:06 <sccrstud92> j42: the reason Int is in there is because you could have something like Array (Int, Int) Double, which would be a two dimensional array
12:43:14 <heatsink> alyte: The implementation converts the Double into an Integer value and an Int exponent before encoding it
12:43:17 <statusfailed> j42: isn't it because "hanning" has no argument?
12:43:25 <statusfailed> oh I missed the original error
12:43:25 <statusfailed> sorry
12:43:51 <alyte> Ohh that would make sense @ heatsink
12:43:59 <heatsink> alyte: There is a package data-binary-ieee754 for using ieee754 representation
12:44:13 <alyte> Thanks
12:44:28 <j42> I think I was misunderstanding the DSP package then because I was assuming the window function took two parameters--first the signal data and then the sampling function
12:45:12 <mauke> no, it says here it takes two arrays
12:45:18 <sccrstud92> statusfailed: how are you handling the reading from two streams right now?
12:45:24 <mauke> called "w[n]" and "x[n]"
12:45:26 <adarqui> for anyone that searches this via ircbrowse.net etc.. to disable unicode symbols in haskell-vim-now, you can simply comment out Plugin "enomsg/vim-haskellConcealPlus" in ~/.vimrc or you can add more disable options to let hscoptions=".."
12:45:58 <j42> aaand i'm not sure how I missed that
12:46:05 <j42> mauke: thank you
12:46:31 <j42> I still don't fully understand type signatures but now that all makes sense... :)
12:46:54 <athan> Is there a `derive All` or something like that for newtypes?
12:47:03 <j42> statusfailed: just out of curiosity anything you're working on publicly?
12:47:08 <statusfailed> nah
12:47:13 <statusfailed> just muckin about :-)
12:47:18 <j42> personally I wanted to play with Hlearn to test out machine learning in Haskell for once (and learn Haskell at the same time)
12:47:24 <j42> so I'm doing transcode detection for audio
12:47:29 <statusfailed> Right now I spin up a thread for each input, write to a "Chan" and read it from a third thread
12:47:40 <statusfailed> there's a lot of manually wiring stuff together
12:47:55 <mniip> ehh
12:48:05 <mniip> data analysis sounds like a poor way to learn haskell
12:48:35 <statusfailed> mniip: R user, huh? :p
12:48:41 <j42> are you finding the parallelization is generally amicable in Haskell compared to non-functional alternatives?
12:48:42 <heatsink> There is this IHaskell thing that's supposed to be user-friendly
12:48:49 <heatsink> for data analysis
12:48:51 <j42> mniip: what do you recommend that would give me more insight into the language?
12:48:56 <mniip> statusfailed, hm? no
12:49:04 <j42> I've read the books but I don't integrate unless I do (something I find interesting)
12:49:05 * hackagebot nested-routes 3.0.0 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-3.0.0 (athanclark)
12:49:17 <sccrstud92> j42: people really like writing parsers in haskell
12:49:24 <statusfailed> mniip: oh.. I am :-)
12:49:24 <mniip> j42, following some tutorial with excercises
12:49:43 <statusfailed> j42: agree with both of them ^ 
12:49:47 <statusfailed> j42: this is my fave: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
12:50:13 <j42> awesome thank you, I think I'll give it a go this afternoon before going back to my original problem :)
12:50:21 <statusfailed> sccrstud92: does what I've done with threads + chans sound like a bad idea? 
12:50:41 <statusfailed> It was my first foray into concurrent haskell
12:51:05 <sccrstud92> statusfailed: it seems like a common sense way to do it
12:51:23 <sccrstud92> were you looking for something nicer?
12:51:33 <statusfailed> Yeah, just found this: https://github.com/hailstorm-hs/hailstorm
12:51:36 <statusfailed> not sure if it's what I want yet
12:51:53 <statusfailed> seems perhaps overkill
12:52:50 <statusfailed> Ah hell, I'll try and write my own. Maybe i'll learn something
12:54:43 <magneticDuck> elerea looks pretty sharp.
12:56:24 <statusfailed> magneticDuck: thanks for the heads up!
12:56:43 <magneticDuck> oh I actually had no idea you were talking about that :D
12:56:52 <magneticDuck> but yeah, if you want to learn elerea with me .. =P
12:57:03 <statusfailed> hahah
12:57:39 <ij> May I force an IO String into an String in ghci? 
12:57:59 <sccrstud92> ij: ghci automatically runs io actions and prints the results
12:58:00 <magneticDuck> ij: use ghci's built-in do notation
12:58:04 <magneticDuck> str <- ioStr
12:58:20 <sccrstud92> ^ thats probably better
12:58:40 <ij> nice
12:59:19 <zipper> Uh what's the best way to pass a list of strings generated in one function to another function in another module?
13:00:21 <magneticDuck> zipper: that question doesn't seem to have a direct answer
13:00:25 <magneticDuck> you seem to be going about it wrong
13:00:36 <magneticDuck> can you generate a value of type [String]?
13:00:39 <zipper> magneticDuck: What do I have wrong?
13:00:44 <magneticDuck> then just define that in one module, and then import it into another
13:01:12 <magneticDuck> you don't 'pass' values around like they're mutable objects
13:01:13 <zipper> Well sort of. It is sort of stateful. The list of strings changes each time.
13:01:17 <magneticDuck> okay
13:01:21 <magneticDuck> is it IO [String] ?
13:01:27 <magneticDuck> or maybe <pure parameters> -> String
13:01:33 <magneticDuck> either way, just import it
13:02:00 <statusfailed> zipper: could you paste some code with what you're trying?
13:02:01 <zipper> No it's being generated inside one of the statements in a do block.
13:02:12 <Peaker> wouldn't it be cool if ghc had a warning flag that warns you if your type signature specializes the type?  Would be nice if you could say the signature is documentary and not specializing, in general
13:02:20 <statusfailed> Peaker: yes
13:02:24 <zipper> statusfailed: Yeah let me do that.
13:02:29 <j42> zipper: you're familiar with the import/import qualified syntax?
13:02:35 <j42> in terms of using one module inside another
13:02:50 <zipper> j42: Import can't help me. As far as I can see.
13:03:53 <magneticDuck> j42: he's probably still coming to terms with the stateless paradigm of haskell
13:04:14 <sccrstud92> zipper: can you post code? i cant tell what you mean
13:04:20 <statusfailed> sccrstud92: he's doing a paste
13:04:24 <magneticDuck> he wants a solution involving modules acting as systems in a mutable global state
13:04:34 <sccrstud92> oh my b
13:04:43 <zipper> No I don't want to have mutable global space.
13:05:05 <magneticDuck> zipper: in haskell, the only thing you can do is define values
13:05:07 <zipper> That's what the simple solution would be with an MVar I think
13:05:16 <magneticDuck> modules are just a convenient seperation of the definition of values
13:05:34 <magneticDuck> if you can do it in 2 modules, you can do it in 1 module with the same logic
13:05:51 <j42> as far as I can tell if you're looking for a "dynamic import" though, you'll want to work with an IO type
13:06:18 <j42> also magneticDuck correct me if i'm wrong since I'm still very new, but wouldn't you just then lift it to where you're defining it in your main module?
13:06:49 <magneticDuck> er
13:07:01 <magneticDuck> I think the issue of having multiple modules is just confusing us at the moment ^^
13:07:02 <j42> but any other  module will still just be a definition of values and routines
13:07:07 <j42> probably
13:07:09 <j42> I'll shut up
13:07:26 <magneticDuck> are you asking a question about exactly how module imports are implemented in ghc?
13:07:29 <magneticDuck> I'm not sure about that
13:07:44 <j42> I guess we just wait for the gist :)
13:09:06 * hackagebot nested-routes 3.0.0.1 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-3.0.0.1 (athanclark)
13:11:17 <zipper> Okay here is the code. Trying to use the result of L24 in Run.hs in L24 ReverseProxy.hs. All of that is coordinated by `compile` in Watch.hs which is then run by main in Devel.hs https://gist.github.com/urbanslug/91b30416a7139a2e1ab6
13:13:11 <statusfailed> zipper: so you're trying to use `theError` in Run.hs, is that right?
13:13:43 <magneticDuck> L24 in run.hs is an import
13:13:45 <magneticDuck> typo?
13:14:29 <zipper> I meant line 53 in Run.hs
13:15:23 <zipper> statusfailed: Yeah but it can't see errorList in the function runBackend
13:16:04 <statusfailed> zipper: errorList is a local variable though right?
13:16:55 <statusfailed> zipper: do you mean it can't see "getSourceErrors" ?
13:17:11 <statusfailed> zipper: I can't see where that's defined
13:17:15 <lamefun> Why would that run out of space? http://lpaste.net/135409
13:17:42 <zipper> well yeah I don't call them variables but it is local within runBackend. It is however returned in the tuple that runBackend returns.
13:17:53 <zipper> statusfailed: ^
13:18:43 <zipper> statusfailed: No I want to use it here https://gist.github.com/urbanslug/91b30416a7139a2e1ab6#file-reverseproxy-hs-L24
13:20:42 <tejing> lamefun: foldl' is only strict in the tuple itself, not the contents... I think that's your problem
13:20:56 <Peaker> why does cabal build with profiling also build without profiling? Any way to disable that?
13:21:07 <sccrstud92> lamefun: so you fix with a bang pattern
13:21:24 <zipper> Where'd everyone go?
13:21:27 <lamefun> tejing: found that out already...
13:21:27 <statusfailed> zipper: here :-)
13:21:29 <statusfailed> zipper: reading
13:21:35 <zipper> haha okay
13:21:57 <statusfailed> zipper: So essentially you want "compile" to give you a different "IO Application" each time, correct?
13:22:17 <zipper> statusfailed: I expect it to, yes.
13:22:52 <zipper> I expect runBackend to have a different result each time.
13:23:22 <ackthet> a
13:23:29 <sccrstud92> zipper: you might have to write the list of errors to an IORef
13:23:42 <sccrstud92> and have your application read from the IORef
13:23:44 <j42> isn't that only possible if the IO variable is set directly in the main block?
13:23:56 <ackthet> sorry my cat is sending messages again <_<
13:23:58 <j42> sorry I'm out of my depth here--1 week into learning haskell
13:24:00 <statusfailed> ackthet: :D
13:24:14 <ackthet> its happened > 1 time in this channel <_<
13:24:30 <sccrstud92> j42: he is geneteing the list from IO and reading the list from IO, so its not a problem
13:24:43 <sccrstud92> generating*
13:24:58 <maerwald> ackthet: your cat writes your haskell code too? :)
13:25:06 <statusfailed> zipper: OK so here's what I understand: "compile" is watching for some changes, and resulting in what should be a new "reverseProxy" every time something changes right?
13:25:09 <ackthet> shes trying
13:25:18 <maerwald> if it typechecks...
13:25:24 <zipper> heh so you want me to use a global mutable variable?
13:25:28 <zipper> sccrstud92: ^
13:25:57 <zipper> statusfailed: Yes
13:26:02 <statusfailed> zipper: does "compile" restart the reverseProxy on changes?
13:26:22 <zipper> It doesn't restart the reverseProxy on change.
13:26:30 <zipper> Those are two different entities.
13:26:32 <statusfailed> so "reverseProxy" never stops?
13:26:34 <statusfailed> ok
13:26:41 <zipper> You don't have to understand compile.
13:26:48 <zipper> Yes it never stops.
13:27:22 <magneticDuck> I don't completely understand the situation zipper 
13:27:31 <zipper> I just realised that it never stops and I'm kinda surprised it doesn't get screwed up when the other restarts.
13:27:39 <magneticDuck> but I'd probably consider passing a function to runBackend
13:27:42 <sccrstud92> zipper: since compile never returns, i dont see how you can do anything else with the errorList
13:27:51 <magneticDuck> to operate on the local value in question?
13:28:11 <sccrstud92> magneticDuck: another IO action needs access to a value
13:28:17 <statusfailed> zipper: could you quickly summarise what "runbackend" and "reverseProxy" do?
13:28:27 <zipper> sccrstud92: Yeah I think so too but I was looking for a best way so I wanted to avoid a global mutable variable.
13:28:31 <statusfailed> and how they should be communicating, if at all?
13:28:49 <sccrstud92> zipper: its not necessarily global
13:29:03 <magneticDuck> sccrstud92: the other IO action is a process or a step that can be integrated into runBackend?
13:29:10 <sccrstud92> zipper: you could just pass it to the two functions that need it
13:29:44 <zipper> So you're saying that I should run everything in the reverseProxy? hmmm
13:29:50 <sccrstud92> magneticDuck: i think its running in a separate thread, but im not sure. it looks like he is writing something that does continuous compilation and error reporting
13:30:04 <magneticDuck> ah okay
13:30:16 <magneticDuck> so he wants two processes to share a concurrent state
13:30:20 <magneticDuck> yeah, MVar it is
13:30:22 <zipper> statusfailed: Okay reverseProxy just sets up a reverse proxy from port 3000 to 3001
13:30:29 <sccrstud92> magneticDuck: so he needs to get the errors genetated by the compilation process to the thread that continuously displays errors
13:30:49 <sccrstud92> magneticDuck: why is that better than IORef?
13:31:25 <zipper> statusfailed: runBackend compiles code and gives back the result and a list of errors if any. Now that I think of it should return an Either.
13:32:51 <j42> isn't this the same concurrency problem as before?  wouldn't you use a 3rd thread + a channel?
13:32:55 <j42> http://chimera.labs.oreilly.com/books/1230000000929/ch07.html#sec_conc-logger
13:33:46 <sccrstud92> j42: i dont think he needs, a whole channel, just the most recent set of errors
13:33:54 <magneticDuck> sccrstud92: it has support for concurrent access
13:33:58 <zipper> sccrstud92: True
13:34:02 <statusfailed> zipper: what happens with the result?
13:34:06 <zipper> sccrstud92: IORef
13:34:07 * hackagebot haskell-names 0.5.3 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.5.3 (PhilippSchuster)
13:34:17 <statusfailed> zipper: oh, that errorlist should go to reverseProxy?
13:34:29 <statusfailed> yeah then a shared IORef would work
13:34:37 <zipper> statusfailed: I need it so that I can cancel the previous compilation before restarting another.
13:34:42 <zipper> SMH you people here thought I didn't know what I was talking about. I feel so "I told you so" right now. This had nothing to do with imports.
13:35:01 <zipper> You people made me feeling quite "not clever"
13:35:06 <zipper> :(
13:35:07 <j42> hey at least I never pretended to know what I was talking about :P
13:35:11 <j42> still don't
13:35:11 <sccrstud92> magneticDeck: if you are worried about race conditions, I would still use TVar over MVar to replace IORef
13:35:56 <sccrstud92> zipper: you might like the async package to handle the multiple things going on at once
13:36:29 <sccrstud92> zipper: you didnt say you were doing this in IO
13:36:34 <sccrstud92> thats a big detail =P
13:37:01 <zipper> sccrstud92: Just googled it.
13:37:37 <zipper> sccrstud92: I did, but that's not something we should argue over. I said it was something in a do block.
13:37:42 <zipper> Anyway thanks.
13:37:58 <zipper> I guess I have to introduce some sort of state after all.
13:38:05 <sccrstud92> zipper: well its someones fault, but we dont have to figure out who ={
13:38:07 <sccrstud92> =P
13:38:11 <athan> Anyone here familiar with voting algorithms? Or rating algorithms, like 4/5 stars?
13:38:41 <statusfailed> athan: you mean ranking?
13:38:50 <j42> athan, algorithms in what sense?  what data do you need to extract from votes cast?
13:38:55 <athan> statusfailed: Sure! :)
13:39:07 * hackagebot nested-routes 3.0.0.2 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-3.0.0.2 (athanclark)
13:39:09 * hackagebot photoname 3.1 - Rename photo image files based on EXIF shoot date  http://hackage.haskell.org/package/photoname-3.1 (DinoMorelli)
13:39:13 <statusfailed> athan: what do you need to do?
13:39:34 <athan> j42: Well, there can be different classes of methods to measure quality
13:39:36 <statusfailed> zipper: did you sort out your issue?
13:39:37 <zipper> sccrstud92: :)
13:39:58 <athan> I'm looking for some that use users' input as a means to do so
13:40:10 <athan> I'm not really looking for one single solution - I don't have a type to fill yet
13:40:15 <athan> I'm just looking for inspiration :)
13:40:28 <athan> And if there's a classification of voting algorithms, too
13:40:35 <zipper> statusfailed: Well yeah I think I'll have to introduce state somehow.
13:41:35 <zipper> statusfailed: See the issue is passing a value in one of the statements of a do block in a function in another function.
13:41:51 <zipper> statusfailed: Does that make sense?
13:41:51 <j42> https://hackage.haskell.org/package/majority-1.1/docs/Algorithms-Majority.html?
13:42:40 <statusfailed> zipper: Yes, I think so
13:42:56 <statusfailed> zipper: I think it's a question of concurrency rather than "language details" though
13:43:11 <sccrstud92> zipper: i think the real issue is
13:43:24 <sccrstud92> zipper: that one of the IO actions runs forever
13:43:29 <zipper> statusfailed: haha yeah there is quite a bit of concurrency going down here.
13:43:35 <sccrstud92> zipper: so it cant return anything
13:43:56 <j42> athan: if not that then just handle sorting w/ quicksort?
13:44:19 <zipper> sccrstud92: Well yeah it has to do that.
13:44:27 <zipper> At least as far as I can see.
13:44:49 <zipper> statusfailed: Why is it an issue of concurrency?
13:44:50 <statusfailed> athan: this might be interesting: http://nbviewer.ipython.org/github/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/blob/master/Chapter4_TheGreatestTheoremNeverTold/Chapter4.ipynb
13:45:41 <statusfailed> athan: and more in a later chapter: http://nbviewer.ipython.org/github/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/blob/master/Chapter6_Priorities/Chapter6.ipynb
13:48:32 <statusfailed> zipper: Well simply you have to share data somehow between two processes, heh
13:49:31 <mniip> so I've just written a 6502 emulator and would like some feedback on the code
13:49:36 <mniip> https://github.com/mniip/h6502
13:54:22 <Peaker> mniip: did you already hlint it? :)
13:54:39 <mniip> I don't think that's a good idea
13:54:44 <Peaker> why?
13:55:07 <Peaker> mniip: I recommend using prefix-comma when possible, to make the uniformity of commas easier to see and less visual noise
13:55:14 <Peaker> (first thing I'm seeing in https://github.com/mniip/h6502/blob/master/src/H6502.hs)
13:55:25 <mniip> but that's ugly D:
13:55:43 <Peaker> it's prettier once you get used to it.. :)  Objectively nicer, subjectively you get used to whatever
13:55:57 <Peaker> mniip: H6502 is in your module name, don't put it as a prefix everywhere, it's very noisy
13:56:04 <Peaker> (use qualified imports if needed)
13:56:15 <mniip> Peaker, it's not supposed to be an executable but rather a library
13:57:00 <Peaker> mniip: still, use built-in qualification syntax instead of manually qualifying all names
13:57:15 <mniip> what do you mean qualifying all names
13:57:28 <Peaker> the H6502 prefix part of all names
13:57:36 <mniip> I thought you are talking about module names
13:57:45 <Peaker> H6502Environment should be H6502.Env
13:57:53 <Peaker> or just Env in the right contexts
13:57:55 <mniip> hmm
13:58:21 <mniip> what about State though
13:58:50 <Peaker> H6502.State is nice, but "State" isn't. Either qualify it everywhere, or maybe use "CPUState" or such?
13:58:56 <mniip> hmm
13:59:26 <Peaker> Or use a newtype/synonym for a state monad rather than the state type -- hide the state type almost everywhere?
13:59:42 <Peaker> oh, I see that's what you do there
13:59:58 <python476> hi
14:00:51 <Peaker> mniip: https://github.com/mniip/h6502/blob/master/src/H6502/OpcodeMap.hs <-- I wouldn't inline the instruction in the table. Names would be informative, and then you can also tabulate
14:01:00 <Peaker> mniip: also visually uniform commas would help the table :)
14:01:32 <mniip> Peaker, you mean I should create functions like iORA even for one-use instructions?
14:01:47 <Peaker> mniip: using standard-length instruction names there, and zip [0..] you can tabulate 8 or 16 instructions per line or such, for a nicer table
14:01:49 <python476> pardon the digression : how do one call avoiding cartesian product search when you have information about future candidates
14:01:49 <Peaker> mniip: yeah
14:02:04 <Peaker> mniip: it's nice documentation + a table layout would be really helpful, probably
14:02:29 <Peaker> mniip: I'd alias Nothing and Just in that local context to make the table smaller/more uniform
14:02:36 <python476> b
14:02:49 <mniip> Peaker, I would prefer the way it is now, i.e a list of (opcode, behavior)
14:03:14 <mniip> it's not uncommon to refer to 6502 opcodes by their hex numbers as opposed to names
14:03:34 <Peaker> mniip: Ok -- but I'd still want to see a single name next to each number (but that's me)
14:04:20 <Peaker> the big "where" clause in there adds a lot of indent to everything -- I think it's unnecessary because you're in a module context and those are the module's privates anyway
14:04:40 <athan> Thanks statusfailed & j42 :)
14:04:53 <statusfailed> athan: np, hope it helps :-)
14:05:44 <Peaker> mniip: https://github.com/mniip/h6502/blob/master/src/H6502/Trans.hs#L15 <-- you're not composing ReaderT/StateT for performance?
14:06:13 <mniip> yeah
14:06:18 <Peaker> mniip: if so, I'd suggest just using StateT and embedding the ReaderT part inside it (clearly distinguishing it and wrapping it with a reader-like interface)
14:06:24 <mniip> this is also the reason peek16 is primitive wrt H6502T
14:07:11 <Peaker> first half of https://github.com/mniip/h6502/blob/master/src/H6502/Util.hs seems to be equivalent to TH-generated lenses :)
14:07:18 <Peaker> (but lens dependency is a bitch, I know :)
14:07:20 <mniip> Peaker, but the ReaderT needs to be on the outside
14:07:31 <mniip> Environment is supposed to be only set once
14:07:38 <Peaker> mniip: ReaderT/StateT commute
14:07:41 <athan> Anyone know of a good form-data parser? Something from `BS -> [(BS, BS)]`? :\
14:07:52 <Peaker> (it doesn't matter which is outside for the semantics)
14:08:11 <mniip> Peaker, but the respective run*T functions
14:08:43 <Peaker> but you run both at the same time anyway?
14:09:23 <Peaker> https://github.com/mniip/h6502/blob/master/src/H6502/Trans.hs#L21 <-- a bit ugly to demand Monad to provide Applicative, but I guess it doesn't matter much (with AMP, though, it's nicer to demand Applicative)
14:10:08 <Peaker> mniip: https://github.com/mniip/h6502/blob/master/src/H6502/State.hs#L22 <-- these should probably all be strict fields
14:10:24 <mniip> I don't think you can Applicative f => Applicative (ReaderT r f)
14:10:48 <mniip> Peaker, strangely that doesn't affect performance much
14:11:03 <Peaker> mniip: why do you make your state tuple lazy?
14:13:04 <mniip> well, I can think of some use cases where registers would be bottoms
14:13:21 <Peaker> is that valid, simulation-wise?
14:13:26 <mniip> no
14:13:47 <mniip> but it can tell whether a program depends on an unitialized register I guess
14:14:05 <mniip> on its value I mean
14:14:35 <Peaker> mniip: what don't you like about hlint, btw?  "when (not b) $ ..." is nicer as "unless b $ ..." no?
14:14:55 <Peaker> you can disable specific hlint warnings you dislike
14:15:53 <Peaker> mniip: in OpcodeMap, you do a lot of:   someFunc (action >>= here).  and then someFunc always binds its arg first-thing.  Why not:  action >>= here >>= someFunc ?
14:16:38 <Peaker> mniip: when you give an action to a function whose only use of it is to immediately bind it -- you're misleading the reader to think that maybe the action is wrapped, run multiple times, or who knows
14:16:57 <mniip> nice catch
14:17:11 <athan> Peaker: Did you look into ether?
14:17:17 <Peaker> athan: nope, what's that?
14:17:26 <athan> https://int-index.github.io/ether/ Peaker
14:17:46 <Peaker> athan: ah, nope, what's the context? :)
14:18:18 <athan> commutative monad transformers :P
14:18:43 <athan> idk actually
14:18:44 <athan> meh
14:19:00 <Peaker> mniip: it looks nice overall, was easy for me to follow :)
14:19:18 <sccrstud92> ether offers mtl style monad transformers but it allows multiple Reader/State components of the same type
14:19:41 <maerwald> mniip: more documentation? E.g. abstract documentation over the module purpose
14:19:56 <Peaker> mniip: I do find OpcodeMap to be unasthetically noisy.. I hate tuple syntax
14:20:00 <maerwald> but then again, I don't know much about that emulator thing anyway
14:20:07 <athan> Thanks sccrstud92 :)
14:20:12 <maerwald> and if people who do will find that it's sufficiently documented
14:20:21 <Peaker> (<num>, Just $ ... )  <-- lots of visual noise on each line!
14:20:34 <mniip> idunno I find it pretty easy to ignore
14:20:53 <Peaker> mniip: it catches my eye, and doesn't let go for a few sec before I can read the code :(
14:21:12 <maerwald> not sure if adding more indirection will make it easier to understand
14:21:29 <mniip> I *could* remove justs from the table
14:21:31 <Peaker> perhaps have these on top of the table: inst num code = (num, Just code) ; none num = (num, Nothing) ?
14:21:33 <mniip> using nothing as the default value
14:21:36 <mniip> but noot really sure
14:23:32 <Cale> mniip: You could make a local declaration of something like  x ==> y = (x, Just y), and  unused x = (x, Nothing)  :)
14:23:38 <Peaker> mniip: http://lpaste.net/135411 <-- I like this better
14:23:45 <Peaker> Cale's idea is even better!
14:24:31 <Peaker> edited it in
14:24:45 <Peaker> but now the unused's are misaligned numbers vs. the ==>'s
14:24:48 <mniip> Cale, ohhh
14:24:49 <mniip> fancy
14:24:49 <Jello_Raptor> huh, why doesn't hoogle seem  to know what "MonadState" is? https://www.haskell.org/hoogle/?hoogle=%28s+-%3E+s%29+-%3E+MonadState+s+%28%29
14:24:57 <mniip> Cale, oh wait
14:25:08 <mniip> you can't have 'a ==> do b' can you
14:25:13 <Peaker> mniip: yes you can!
14:25:24 <mniip> oh true
14:25:25 <Peaker> "do" is valid as an infix parameter, not a prefix param, which is a silly arbitrary restriction!
14:25:47 <Peaker> that causes the first examples in Haskell to beginners have redundant $ noise in them :-(
14:26:00 <geekosaur> Jello_Raptor, MonadState is not a type
14:26:02 <geekosaur> it's a typeclass
14:26:05 <Peaker> We have to do the "I'll explain that syntax later" because of that, like Java's "public static"
14:26:07 <sccrstud92> Jello_Raptor: MonadState is a typeclass, not a type
14:26:16 <Jello_Raptor> geekosaur: d'oh thanks 
14:27:09 <Peaker> mniip: see how with the prefix commas, they just "disappear" when you look at the code? :)
14:27:16 <Peaker> (so much cleaner IMO! :-)
14:27:23 <sccrstud92> Jello_Raptor: are you looking for modify or modify'?
14:27:59 <Jello_Raptor> sccrstud92: yup, i just changed the query to "MonadState s m => (s -> s) -> m s" and found it :) 
14:28:19 <Peaker> mniip: hey, did you tell me why you were using lazy state tuples?
14:28:36 <mniip> the only reason I came up with is pretty moot
14:29:00 --- mode: ChanServ set +o mauke
14:29:01 --- mode: mauke set -b *!*@191.175.77.183
14:31:01 --- mode: mauke set -o mauke
14:31:09 --- mode: ChanServ set +o mauke
14:31:10 --- mode: mauke set -b $r:v?
14:31:49 <Peaker> mniip: perhaps if you strictify the state fields, and modify the state strictly, it will make a difference?
14:33:04 <exio4> so, asking again, any ideas/hints for having multiple State(s) "concurrently"? (as-in, having StateT S1 (StateT2 m) and somehow be able to change both of them, yet you could have functions that work only with Sn and force them to only access that one?)
14:33:09 --- mode: mauke set -o mauke
14:33:48 <Peaker> exio4: why not a record of states in a single StateT?
14:34:11 <Peaker> exio4: you could just have explicit named lifters and not use MonadState
14:34:50 <exio4> Peaker: I want to have certain parts of the program totally "standalone", the nicktracker MUST only touch its own state and nothing else, the single record makes unrelated changes possibles
14:34:52 <Peaker> exio4: newtype Foo a = Foo { runFoo :: StateT s1 (StateT s2 (...)))) a } ; liftS1 = Foo ; liftS2 = liftS1 . lift ; ...
14:35:11 <Jello_Raptor> hmm, is it possible to make a lazy priority queue monad? like the array monad, but where the array is [(Priority,v)] and each array returned by the system is guaranteed to be in priority order. (so that you can look at only the heads of lists to determine which the next element to evaluate is?) 
14:35:30 <Peaker> exio4: I think such "capabilities" are usually reified into specific type-classes
14:35:42 <mniip> Jello_Raptor, array monad? you mean list?
14:36:03 <ajf> Can I define an instance in terms of a derived instance?
14:36:11 <mniip> also it's not a qurstion of "is it possible" but rather "is it a monad"
14:36:36 <michaelt> ajf: you mean, an instance for a type that already has a derived instance?
14:37:06 <ajf> michaelt: er, what I want to do is used the derived instance to implement an instance
14:37:13 <Eduard_Munteanu> ajf, yes
14:37:19 <mniip> ajf, you mean you want to use the would-be-derived behavior in your non-derived instance?
14:37:20 <exio4> Peaker: hm, I am guessing I'll just use MonadXYZ and do it like I am doing currently with the IRC layer, wanted to avoid having to repeat code mostly :/
14:37:30 <ajf> mniip: yeah
14:37:47 <michaelt> then there are two instances ajf 
14:37:49 <geekosaur> Jello_Raptor, there are several priority queue implementations on Hackage
14:37:50 <mniip> I don't think I know of a way better than copycatting the -ddump-deriv code
14:37:55 <Peaker> exio4: you could zoom!
14:38:00 <Jello_Raptor> mniip: yes and yeah, i'm not even sure how to reasonably represent priorities within the context of a monad. 
14:38:01 <ajf> Ah, alright
14:38:21 <Peaker> exio4: Have stuff be specific to a StateT ConcreteState   but then "lift" them to your bigger state with lens's zoom
14:38:41 <exio4> Peaker: that's what I am doing currently
14:38:54 <geekosaur> I wouldn't use it with a list (not wrapped to hide the implementation) because then someone can make a list that violates your constraint (ordered by priority) and use it as if it were a valid pq
14:39:05 <Peaker> exio4: what's the downside?
14:39:28 <exio4> it kills composition, basically
14:39:41 <Jello_Raptor> mniip: the *actual* goal is allowing me to specify the search path in a normal list monad. 
14:40:45 <mniip> what
14:40:59 <geekosaur> that doesn't make a lot of sense to me either
14:41:14 <geekosaur> (for one, I don't see what monad has to do with it...)
14:41:24 <Peaker> exio4: I wonder why MonadState has the fundep | m -> s   I think both "m" and "s" appear in all method signatures, so it could dispatch based on both (perhaps with overlapping instances)
14:41:47 <sccrstud92> Jello_Raptor: something like this http://jaspervdj.be/posts/2015-05-26-prio-applicative.html ?
14:41:48 <Peaker> exio4: perhaps you could make an alternative MonadState that behaves that way
14:42:06 <Peaker> and instantiate it for the specific monads you have -- rather than a new bunch of classes
14:42:06 <exio4> Peaker: you should be to come with a new "module" that uses the current architecture, and just "add a new constraint" (I am thinking it'd form some kind of subtyping-like behavior after all, using typeclasses), a gigant state kills that :( 
14:42:47 <exio4> Peaker: maybe, I was thinking about some "multiple-state" monad using hlists too, but still gathering ideas 
14:43:05 <Peaker> exio4: you could use the cool QQ/TH hack for extensible records and have record constraints on your state :)
14:43:10 <geekosaur> Peaker, but they don't necessarily appear in all uses, and MPTCs break type inference
14:43:26 <geekosaur> unless you use a fundep to make it solvable
14:43:40 <Peaker> geekosaur: but I think in the case of MonadState, "m" and "s" always both appear, no?
14:43:44 <sccrstud92> exio4: what is wrong with mtl style monad transformers?
14:44:01 <sccrstud92> if you are using two different types of state it should work, right?
14:44:05 <Peaker> yep, they both appear in all 3 methods
14:44:08 <exio4> it doesn't 
14:44:19 <sccrstud92> exio: what happens?
14:44:28 <Jello_Raptor> err, i've got a structure I'd like to synthesize. The structure is built incrementally, trying a number of possibilities for the next step until it is complete or nothing can be added until failure. This backtracking search works really well as list monad if each list is finite and tiny, but if I want to order that search path for efficiency I don't know how to do it.   
14:44:31 <sccrstud92> typeclass errors?
14:44:52 <exio4> sccrstud92: there's no instance, for going thru a state, it goes "deep enough" to find a StateT, it can't look "through" it  
14:45:03 <ajf> can you pattern-match against a string of a certain length?
14:45:08 <sccrstud92> exio4: what about the ether package?
14:45:11 <geekosaur> Peaker: m always appears, s is almost always inferred in my experience. with the fundep, the compiler can derive s from the known m. without, it runs into the open world assumption trying to infer s
14:45:18 <geekosaur> unless you explicitly type it
14:45:26 <ajf> something prettier than foo@(_:_:_:_:_:_:_):bar
14:45:51 <geekosaur> that wouldn't work anyway (maybe you wanted the last _ to be []?)
14:45:51 <Peaker> geekosaur: ah, so when you have a polymorphic "s", the overlapping instances for a concrete vs. polymorphic "s" becomes ambiguous
14:46:02 <geekosaur> that's one issue, yes
14:46:02 <sccrstud92> ajf: you can use a view pattern with length
14:46:24 <ajf> geekosaur: er, yes, bar would be []
14:46:29 <ajf> geekosaur: view pattern?
14:46:39 <exio4> sccrstud92: I haven't checked at it, hmm
14:46:43 <sccrstud92> ajf: from the ViewPatterns extension
14:46:47 <geekosaur> ajf, that was sccrstud92
14:46:51 <sccrstud92> ajf: what about just a normal guard
14:47:10 <sccrstud92> foo word | length word == 10 = -- whatever
14:47:26 <ajf> sccrstud92: oh, yeah, that's probably a better idea
14:47:36 <augur> so, i have a goal with type   Data.Text.Internal.Lazy.Text   coming from Network.Mail.SMTP  and i need to put in some text computed at runtime, and 'append' seems to not have the right type
14:47:38 <exio4> sccrstud92: actually, sounds like it might be what I wanted, a phantom tag that gives the type extra metadata, and you lookup the state using it, thanks
14:47:45 <augur> anyone know what i need to do for this?
14:48:00 <Peaker> exio4: did you see the QQ record thing?  Instead of adding constraints on your monad stack, you can add constraints on the state type that it contains such and such fields
14:48:02 <sccrstud92> exio4: your welcome
14:48:14 <Jello_Raptor> geekosaur, sccrstud92 : basically i want to evaluate "head do { a <- [1 .. 5]; b <- [1 .. 5]; foo (a,b)}" so that foo will see some arbitrary order of pairs. (maybe '[(1,1),(2,2),(3,3),(4,4) ...]' instead of the usual) 
14:48:17 <sccrstud92> you're
14:48:27 <exio4> Peaker: I haven't, any links?
14:48:48 <Peaker> exio4: http://www.reddit.com/r/haskell/comments/2svayz/i_think_ive_nailed_it_ive_solved_the_records/
14:48:59 <sccrstud92> Jello_Raptor: can you just add the priorities and sort the list?
14:49:09 * hackagebot clustering 0.2.1 - High performance clustering algorithms  http://hackage.haskell.org/package/clustering-0.2.1 (kaizhang)
14:50:10 <Jello_Raptor> sccrstud92: I've got huge (possibly infinite) lists
14:51:46 <sccrstud92> Jello_Raptor: are you doing dfs, bfs, some heuristic cost-based search, or something else?
14:53:20 <exio4> Peaker: wow, nice
14:56:43 <Jello_Raptor> sccrstud92: bfs. Conceptually there's a tree whose root is empty, and each child has an extra component than it's parent. I want to bfs down the tree until i find the element closest to the root that is complete. (But I'm pretty sure I can assign a heurisitic to each node so that greedily looking at the lowest cost node on the frontier will get you a pretty good solution, though maybe not the optimal) 
14:57:40 <sccrstud92> Jello_Raptor: then you probably dont want to use the list-monad-like search
14:57:52 <sccrstud92> just have an excplicit frontier
14:57:56 <Peaker> exio4: so that thing can be translated to constraints on your state record maybe?
14:57:57 <sccrstud92> like q prio queue
14:59:28 <exio4> Peaker: maybe, I'll be porting this code to the tagged monad transformers used by ether, which seem to imply less-of-a-change (I basically implemented everything, and now found ... I couldn't compile what I had written :P)
14:59:43 <exio4> Peaker: thanks, it looks really cool, at worst, I'll waste some time playing with records anyway :D
15:01:07 <Peaker> exio4: :)
15:01:41 <Jello_Raptor> sccrstud92: hmmm, I'm trying to think if there's any chunk of the computation that can't be wrapped up within a "o -> PiorityQueue o" structure. 
15:04:07 <bernalex> what is it that ghc-pkg and hc-pkg expects as the argument to register?
15:04:12 <bernalex> i.e. what file
15:05:04 <bernalex> hm. 'cabal sandbox hc-pkg -- register /usr/lib64/ghc-7.8.4/package.conf.d/pandoc-1.14.0.4-745944f75edf4b13c726d7f9cc97fef9.conf' seems to work.
15:05:50 <mniip> Cale, I don't think I like the ==> arrow
15:06:11 <mniip>         0x05 ==> addrZeroPage >>= peek >>= iORA,
15:06:16 <mniip> kinda blends with >>=
15:06:21 <augur> hey Peaker, hows lamdu coming?
15:07:39 <Peaker> augur: pretty well :) Added evaluation (http://peaker.github.io/lamdu/fac.gif), extensible sum types, nominal typing, ...
15:07:50 <Peaker> now need to polish the gui after all these additions
15:08:08 <Peaker> (the gui for all these features is very quick&dirty at the moment)
15:08:26 <augur> Peaker: interesting!
15:09:05 <mniip> Peaker, that seems like it's super annoying to use
15:09:21 <mniip> like programming in scratch
15:10:05 <Peaker> mniip: it's actually extremely comfortable to use :)
15:10:11 <mniip> well
15:10:15 <Peaker> mniip: you edit the AST with the keyboard only
15:10:16 <Cale> mniip: Pick a different arrow then :)
15:10:25 <mniip> people say identifier autocompletion is comfortable to use
15:10:27 <Peaker> mniip: it takes less keystrokes and less cognitive load to make any change
15:10:29 <mniip> I find it unusable
15:10:39 <doomlord> is that like lighttable for haskell
15:10:47 <Peaker> doomlord: more ambitious than light table :)
15:11:10 <mniip> Peaker, hmm, I changed some things and now it's slow
15:11:10 <doomlord> looks interesing
15:11:16 <doomlord> anyone here looked at the parallella
15:11:39 <Peaker> mniip: say you need to fill a hole of type: "a -> { b:Int, c:String->String }"  -- <space> will fill: "\x -> { b: hole, c:\y -> hole }" (of course you can choose a more refined result, but <space>-oriented programmming is amazing)
15:11:47 <augur> Peaker: how is lamdu's implementation organized?
15:12:06 <Peaker> augur: https://github.com/Peaker/lamdu :)
15:12:18 <augur> Peaker: i mean conceptually :P
15:13:04 <Peaker> augur: there's a revision-controlled key/value store. On top of that there's a very simple core language that's stored there. Then we have a type system implemented for that core language.  Then we have a sugar layer that translates the core language to a sugared, richer, nicer language.  Then we have a GUI display&edit that richer language.
15:13:59 <Peaker> (no text anywhere!)
15:14:20 <Peaker> revision control, conflicts and merges can be far better this way
15:15:22 <Peaker> augur: I think we've had this discussion in the past and you didn't like it, but it works well for us :)
15:15:39 <augur> :p
15:16:42 <mniip> Peaker, something exploded D:
15:16:45 <augur> im just curious because im going to be implementing a dependently typed language (and probably also, separately, a proglang implementation framework for JS)
15:16:51 <mniip> and is eating into ram
15:16:59 <Peaker> it doesn't really matter anyway, Lamdu is primarily a UI experiment -- if we end up having to rewrite it, it's not a huge deal
15:17:12 <Peaker> but this architecture seems to work pretty well for most things we want to do
15:24:11 * hackagebot redis-io 0.5.0 - Yet another redis client.  http://hackage.haskell.org/package/redis-io-0.5.0 (ToralfWittner)
15:40:31 <breadmonster> If dlists are merely function application, how do they have O(1) append?
15:40:42 <breadmonster> After all, you have to build the list in the end, yeah?
15:41:24 <jle`> breadmonster: the appends are O(1), but you might do more than one append
15:41:32 <jle`> i'm not sure what you mean exactly though
15:42:40 <breadmonster> jle`: So `appendDList xs ys = (xs ++) . (ys ++)` right?
15:43:21 <michaelt> if xs and ys are already dlists, appendDlist = (.)
15:43:54 <jle`> breadmonster: ((xs++ys)++zs)++ks is expensive because it has to rewrite xs three times, rewrite ys twice, and rewrite zs's
15:44:04 <jle`> chain up a bunch of appends and you get something pretty bad
15:44:28 <jle`> but `(xs++) . (ys++) . (zs++) $ ks` doesn't ever rewrite anything
15:44:34 <jle`> er
15:44:38 <jle`> it rewrites each once
15:45:38 <breadmonster> jle`: Sure, but after all the list manipulation, you have to do something like `toList = ($ [])` right?
15:45:46 <michaelt> right
15:45:59 <jle`> yeah, so if you consider it at the end, toList will be O(n) on the number of items in the list
15:46:07 <breadmonster> Yeah, exactly.
15:46:07 <jle`> but for the non-dlist way, it's O(n^2)
15:46:13 <breadmonster> Oh.
15:46:22 <michaelt> breadmonster: but 
15:46:28 <michaelt> right what jle` just said
15:47:03 <jle`> ((xs++ys)++zs)++ks is O(n^2) on the number of items
15:47:08 <DNoved1> Why not make (++) right associative, wouldn't that work?
15:47:11 <jle`> it really just depends on like, what you are counting, though
15:47:22 <jle`> in big o notation
15:47:33 <jle`> if you're counting number of items, vs. if you're counting the number of lists you're appending
15:47:41 <mniip> DNoved1, that would beak xs++(ys++(zs++ks))
15:47:50 <mniip> which makes much more sense because laziness
15:47:51 <jle`> it's O(1) on the number of lists, and non-dlists is O(something not 1, i forgot) on number of lists
15:48:25 <jle`> big o notation is really meaningless unless you specify what operations you're talking about, heh
15:48:29 <michaelt> DNoved1: note that with dlists it doesn't matter how you arrange the appends.
15:48:31 <jle`> they're both approximatly O(1) on number of planets
15:48:39 <Peaker> DNoved1: DList is all about re-associating (++) to the right
15:48:44 <breadmonster> mniip: Isn't (++) already right associative?
15:48:59 <breadmonster> @src (++)
15:49:00 <lambdabot> []     ++ ys = ys
15:49:00 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:49:00 <lambdabot> -- OR
15:49:00 <lambdabot> xs ++ ys = foldr (:) ys xs
15:49:25 <mniip> infixr 5 ++
15:49:28 <breadmonster> Yeah.
15:49:29 <Peaker> DNoved1: if you can associate to the right by yourself, you don't need a DList. But DList let you not worry about it.  If your code looks like:  bigComputation ++ ["eof"]   to associate to the right means to break down bigComputation and complicate it. Nicer to just use a DList
15:49:46 <michaelt> breadmonster: think of a complex program that gathers pieces from all sorts of places. You don't know what order stuff will come in. If you make them all dlists, the final construction will be rational.
15:49:59 <Peaker> (++) being right-associative is only meaningful when you have a direct-syntactic-use of  x ++ y ++ z.   But if you have abstraction ++ z   it doesn't help
15:50:28 <jle`> you might get your lists from left to right, and want to "add them" as you go along
15:50:43 <DNoved1> Hmm
15:50:44 <jle`> like for Writer, things like do { tell xs; tell ys; tell zs }
15:50:49 <mniip> jle`, sounds like a task for concat?
15:51:05 <jle`> tell will add on lists "as it goes along"
15:51:17 <jle`> so that's basically (([]++xs)++ys)++zs)
15:51:20 <breadmonster> michaelt: Interesting, is there a use case where dlists are not preferred to regular lists?
15:51:33 <jle`> or ((mempty <> xs)<>ys)<>zs)
15:51:40 <jle`> you can't really say, "now associate to the right"
15:51:43 <jle`> it doesn't really make sense
15:51:53 <jle`> as your computatoin goes on, you're adding new things to the end
15:52:29 <jle`> which is why Writer with [a] has catastrophically bad performance
15:52:47 <michaelt> breadmonster: where you're not doing a lot of appends.
15:52:53 <jle`> with Writer with (DList a), you have each operation again taking O(1) on number of tells
15:53:06 <DNoved1> If you need multiple reader parameters, is it generally considered better to have multiple ReaderT layers and use lift, or to use a tuple and a single Reader?
15:53:15 <jle`> er, O(n) on number of tells
15:53:31 <jle`> one fixed operation for each tell
15:55:04 <Peaker> jle`: each operation also leaking O(1) memory :)
15:55:11 <michaelt> breadmonster: it will probably be a disaster if you are working with the individual list items a lot, then in place of "We hold these truths to be ..." you will have a giant pile of function applications waiting to happen
15:55:19 <Peaker> DNoved1: I'd use a single reader (record, not tuple)
15:55:51 <Peaker> DNoved1: deep monad stacks have more syntactic overhead, and I'm pretty sure they have more runtime overhead too
15:55:59 <jle`> breadmonster: if you never do any appends then dlist doesn't offer any advantage
15:56:14 <jle`> which is actually a lot of my use cases with lists
15:56:54 <DNoved1> Hmm
15:57:23 <DNoved1> I'd hate to create a record just for the one ad-hoc inner function, but it may be for the best, clarity-wise.
15:57:29 <michaelt> > foldr (.) id (map (:) "California") []
15:57:30 <lambdabot>  "California"
15:57:43 <michaelt> is probably not a good way of writing "California"
15:57:50 <jle`> records are cheap :)
15:58:17 <jle`> also if your function is not too complex and you don't make a lot of nested calls, consider just moving everything into a where clause
15:58:25 <jle`> or using function parameters
15:59:31 <ReinH> Uh. (++) is infixr.
16:00:43 <Peaker> DNoved1: creating one-off types is great for clarity and safety :)
16:01:08 <mniip> Peaker, I found a weird thing
16:01:12 <DNoved1> I had thought (++) left associative because I always hear about how horrible it is and how you shouldn't use it.
16:01:27 <ReinH> You always hear that?
16:01:28 <ReinH> That's odd
16:01:33 <jle`> it's not really about the associativity of (++), but how you actually apply it and use it
16:01:35 <Peaker> mniip: gotta sleep! night, good luck!
16:01:44 <mniip> Peaker, if I transform iADC in the way you mentioned
16:01:48 <ReinH> Well, associativity matters so you don't have to write xs ++ (yz ++ zs)
16:01:50 <maerwald> mh, I expect the compiler to optimize away stupid (++), or am I too optimistic?
16:01:50 <mniip> the memory usage spikes 5x
16:01:50 <DNoved1> Ya, O(n^2) is what I come across in my readings, and all that jazz
16:01:55 <ReinH> you can just write xs ++ ys ++ zs
16:02:06 <ReinH> DNoved1: yes, if you use it improperly
16:02:11 <jle`> yeah, but the advantage of DList isn't about the associativity of (++)
16:02:23 <jle`> it's a bit of a moot point other than syntactic cleanliness
16:02:35 <ReinH> Well yes, and that's exactly the point I'm making
16:02:56 <jle`> ah i think i don't know what i'm saying
16:04:13 * hackagebot should-not-typecheck 1.0.1 - A HUnit/hspec assertion library to verify that an expression does not typecheck  http://hackage.haskell.org/package/should-not-typecheck-1.0.1 (CRogers)
16:04:15 * hackagebot timeplot 1.0.29 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.29 (EugeneKirpichov)
16:10:34 <augur> so, anyone familiar with Data.Text?
16:12:21 <augur> oh! wait! i might have solved it! omg :O
16:12:30 <pharaun> :D
16:12:42 <augur> maybe there were conflicting versions of text flying around? ugh who knows
16:12:44 <augur> ugh.
16:14:02 <michaelt> > let [] +++ xs = xs; xs +++ [] = xs ; (x : xs) +++ ys = x : 'x' : (xs +++ ys) in foldr (+++) [] (map (show) [10..20])
16:14:04 <lambdabot>  "1x0x1x1x1x2x1x3x1x4x1x5x1x6x1x7x1x8x1x9x20"
16:14:09 <michaelt> > let [] +++ xs = xs; xs +++ [] = xs ; (x : xs) +++ ys = x : 'x' : (xs +++ ys) in foldl (+++) [] (map (show) [10..20])
16:14:11 <lambdabot>  "1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
16:14:58 <mniip> michaelt, your approach has a problem
16:15:07 <mniip> > "hello" ++ undefined
16:15:09 <lambdabot>  "hello*Exception: Prelude.undefined
16:16:27 <mlamari> I can never find a "batteries included" GUI lib that will work on windows, every time I try to browse for one. Anything starting with 'just install MingW and MSYS and blah blah 5 other steps" never seems to succeed.
16:16:38 <michaelt> here's my would-be point though, contrast these with 
16:16:41 <michaelt> > let [] +++ xs = xs; xs +++ [] = xs ; (x : xs) +++ ys = x : 'x' : (xs +++ ys) in foldr (.) id (map ((+++). show) [10..20]) []
16:16:43 <lambdabot>  "1x0x1x1x1x2x1x3x1x4x1x5x1x6x1x7x1x8x1x9x20"
16:16:47 <michaelt> > let [] +++ xs = xs; xs +++ [] = xs ; (x : xs) +++ ys = x : 'x' : (xs +++ ys) in foldl (.) id (map ((+++). show) [10..20]) []
16:16:49 <lambdabot>  "1x0x1x1x1x2x1x3x1x4x1x5x1x6x1x7x1x8x1x9x20"
16:17:05 <michaelt> so it doesn't matter what order I 'append' the dlists in 
16:18:57 <mniip> so 'let foo mx = do x <- mx; stuff x in foo bar' and 'let foo x = do stuff x in bar >>= foo' should be equivalent right
16:19:43 <mniip> why does one turn my program into a memory hog and other does not
16:20:45 <jle`> which one is the hoggy one?
16:23:13 <mniip> jle`, the latter
16:23:32 <drewbert> emacs makes me sad.
16:23:48 <mniip> jle`, thing is, I have multiple such foos
16:23:59 <mniip> restructuring some of them doesn't make a difference
16:24:19 <mniip> however restructuring all of them just makes the program eat memory infinitely, so I started rewriting them one by one
16:24:36 <mniip> until I hit one that increases memory usage 5x, and one that increases it 150x
16:24:54 <funfunctor> Can anyone see how this aeson json parser is messing up? I spent most of the weekend on it and still can't work it out.. http://lpaste.net/135418
16:26:54 <michaelt> mniip: there must be more to it; aren't those both slight variants of bar >>= stuff?
16:27:13 <mniip> pretty much
16:27:20 <mniip> oh I think I see
16:28:11 <mniip> 'let foo p mx = do x <- mx; stuff p x in foo p bar' versus 'let foo p x = do stuff p x in bar >>= foo p' 
16:28:20 <mniip> this foo has an extra parameter
16:28:32 <ttuegel> Do any other Windows users find that their antivirus thinks everything Haskell-related is infected?
16:29:14 * hackagebot should-not-typecheck 2.0 - A HUnit/hspec assertion library to verify that an expression does not typecheck  http://hackage.haskell.org/package/should-not-typecheck-2.0 (CRogers)
16:31:08 <funfunctor> ttuegel: nope but I heard sourceforge is putting malware in things..
16:32:41 <sm> to add the NFData class to my types, I also needed Generic and extensions DeriveAnyClass and DeriveGeneric. Does that sounds right, and is there a downside  (error messages, performance, ..) to all this ? https://github.com/simonmichael/hledger/commit/baabfdfe1978a713e39ac27ee1dc3b762ac973e2
16:34:30 <sm> ack, it depends on GHC 7.10 for a start
16:36:11 <sm> but I guess I can fix that with more verbose declarations
16:36:14 <michaelt> sm: are you worried that the criterion tests that use this stuff will not really tell you much about your programs? 
16:36:54 <michaelt> sm it seems clear it won't affect the stuff you write since you arent using Generic except for benching
16:37:20 <ttuegel> funfunctor: Yeah, I heard. In this case, it's my own code compiled with GHC from MinGHC, so it would have to be some kind of trojan in that. I'm > 95% confident it's a false positive, but I wondered if anyone else had experiences to share before I complain to the vendor.
16:37:53 <sm> michaelt: well I'm hoping criterion will tell me something, that's why I'm doing this
16:38:01 <funfunctor> ttuegel: nm the binary and look for weird symbols perhaps?
16:38:21 <ttuegel> funfunctor: Good idea!
16:38:41 <sm> I have this idea that adding classes can increase memory footprint. But probably GHC is too smart for that
16:42:35 <sm> and that adding extensions can cause more difficult error messages
16:42:35 <lamefun> Does Haskell have any tools to ensure cross-platform determinism?
16:42:35 <dmj`> lamefun: what is cross platform determinism
16:42:41 <lamefun> dmj`: functions that are guaranteed to yield the same result (bit to bit) regardless of the platform.
16:44:27 <lamefun> basically ban a function from using platform-dependent types
16:50:56 <maerwald> lamefun: maybe stupid question, but do we even have them?
16:52:13 * geekosaur wonders if that is even meaningful
16:52:34 <geekosaur> I mean, you just excluded Int, because ghc is supported on SPARC and PowerPC
16:53:22 <geekosaur> not to mention that Int is 32-bit on 32-bit platforms vs. 64-bit on 64-bit platforms (notably unlike C)
16:53:54 <exio4> well, you can use Integer for numbers.. 
16:54:02 <ajf> Hmm
16:54:04 <lamefun> maerwald: for instance there are turn-based games (like Wesnoth or Hedgewars, I know that Hedgewars uses its own custom fixed-point type) that only send player's input over the Internet and clients compute the rest, and if they don't, the game is ruined due to de-sync. Would be nice to statically veriy that property.
16:54:08 <ronh> or Int16, Int32, etc
16:54:24 <exio4> right, IntXY/WordXY also exist
16:54:47 <ajf> Is taking an infinite list of random numbers and returning that list with a few removed a good idea?
16:54:54 <ajf> (for a function that uses randomness)
16:55:26 <orzo_> geekosaur: int on 32 platforms is 32-bit for c compilers.  It's long that is the same size on both.
16:55:28 <maerwald> lamefun: hedgewars server part is even written in haskell, did you contact the devs?
16:55:29 <Axman6> why wouldn't it be?
16:55:46 <lamefun> maerwald: main game engine is written in Pascal.
16:55:49 <geekosaur> isn't int usually 32 bit even on 64 bit platforms?
16:55:51 <maerwald> lamefun: I know
16:55:53 <geekosaur> in C
16:55:56 <maerwald> lamefun: and the server in haskell
16:56:20 <lamefun> As far I understand, the server only relays player inputs between clients and provides game list.
16:56:56 <ttt_fff> what is a good name for "Either ErrorType" ?
16:57:00 <exio4> lamefun: for the encoding, there's binary/cereal, for the code itself, using Integer or Int64 (or Int32, or whatever) tells you that the type will pretty much behave the same way in different computers
16:57:04 <ttt_fff> i.e. I wnat to type "Foo a" instead of "Either ErrorType a"
16:57:28 <exio4> ttt_fff: I normally use ExceptT when I am working with things like that 
16:57:38 <ttt_fff> hmm, ExceptT is a bit weird
16:57:41 <ttt_fff> it sounds like "Exception a"
16:57:47 <orzo_> geekosaur: just experimented on my 64 bit linux and it seems you're right. nm
16:57:55 <lamefun> I know that Int is platofrm-dependent and Int32 isn't.
16:57:58 <ttt_fff> whereas wnat I really want is "IfItDoesNotFailThenReturnAn a"
16:58:05 <ttt_fff> but nicer sounding
16:58:12 <ttt_fff> I would call it "Maybe a" but it's already taken
16:58:31 <ttt_fff> "ExceptT a" almost sounds liek the type of the exception /error is a, rather than the return type
16:58:37 <ttt_fff> maybe I should call mine "ShouldBe a"
16:58:39 <ttt_fff> or "Want a"
16:58:40 <geekosaur> lamefun, with the constraint "bit for bit identical" it is still platform dependent
16:58:47 <geekosaur> because sparc and ppc are supported
16:58:51 <geekosaur> and they are big-endian
16:59:18 <peddie> ttt_fff: don't you mean 'ExceptT e m a' ?
16:59:35 <lamefun> yes, but you can still reliably get bit for bit identical result if you transform them in the end since they behave the same way
16:59:37 <ttt_fff> well, I want something relaly short, shorter than "Either SvgNode a"
16:59:45 <peddie> the 'a' _is_ the error in 'ExceptT a'
16:59:50 <ttt_fff> so I want like "type ShouldBe a = Either SvgNode a"
17:00:00 <ttt_fff> yeah, the "a" is my return type in Either SvgNOde a
17:00:02 <geekosaur> that is, an Int32 containing 1 is bytes 0x1, 0x0, 0x0, 0x0 on Intel/ARM and 0x0, 0x0, 0x0, 0x1 on SPARC/PPC
17:00:23 <ronh> int is 32 bit in C on most 64 bit platforms. but this decision was made to salvage all the broken 32-bit code that assumed int is always 32 bit. as far as C language goes the only guarantees is that int is at least 16 bits large
17:00:35 <peddie> ttt_fff: ok, sorry, I misunderstood what you meant by 'ExceptT a' I guess . . .
17:00:49 <ttt_fff> someone else suggested "ExceptT a"
17:01:01 <ttt_fff> and I was saying I don't like it because "ExceptT a" makes it sound like a = type of error/exception, rather than return type
17:01:15 <jle`> type SuccessT = ExceptT ? :)
17:01:35 <peddie> ttt_fff: someone else suggested ExceptT, not 'ExceptT a' :)
17:01:37 <ttt_fff> hehe
17:01:38 <ttt_fff> I like it
17:01:39 <ttt_fff> Success
17:02:01 <jle`> the problem is that it doesn't really have a meaningful >>=
17:02:15 <lamefun> I'm curios whether it's possible to create some sort of "Predictable" function flag that only allows it to use white-listed predictable types (ie. updateGame :: GameState -> Predictable GameState).
17:02:43 <ttt_fff> it does "Either SvgNode" = a monad
17:02:45 <ttt_fff> so >>= is well defined
17:03:05 <jle`> i mean, if you treat the a as success
17:03:09 <jle`> then >>= has to bind on failures
17:03:12 <jle`> so i guess that makes sense
17:03:14 <jle`> hm
17:03:26 <ttt_fff> type Success a = Either SvgNode a
17:03:30 <ttt_fff> Success is a monad
17:03:44 <jle`> ah, yeah
17:04:02 <exio4> ttt_fff: ExceptT is defined in https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-Except.html
17:04:11 <jle`> it's just the semantics of what you want to think about for >>= etc.
17:04:20 <jle`> if your success is the Right then you have no problems
17:04:28 <jle`> lamefun: what do you mean by predictable?
17:04:50 <ttt_fff> exio4: what does Except give me over Either ?
17:05:19 <lamefun> jle`: behaves exactly the same regardless of platform (ie. platform-dependent types like Int, Float, Double are banned).
17:05:48 <jle`> `ExceptT e m a` allows you to sequence actions in m
17:05:59 <jle`> or you can say that it is m-with-short-circuiting
17:06:12 <sunnymilk> why are mutual module dependencies hard if mutual recursion in a single module is easy
17:06:23 <jle`> ExceptT e Identity a is essentially Either
17:06:28 <jle`> er, Either e a
17:06:39 <ttt_fff> jle`: why can't I sequence them via either with do notation ?
17:06:55 <ttt_fff> I guess there's also throw/catch
17:07:03 <jle`> ttt_fff: say you have an m (Either e a), and you have an a -> m (Either e a)
17:07:25 <jle`> ExceptT is essentially a newtype wrapper that gives a Monad instance where >>= does exactly what you'd think
17:07:33 <georgey-> is it possible to express this in haskell? if isInstanceOf x 'Typeclass then method x else defaultValue
17:07:41 <jle`> so you can say, sequence :: [m (Either e a)] -> m (Either e [a])
17:08:08 <jle`> or mapM :: (a -> m (Either e a b)) -> [a] -> m (Either e [b])
17:08:10 <sunnymilk> georgey- no types arent supposed to exist at runtime
17:08:18 <ttt_fff> I got my perfect name
17:08:21 <ttt_fff> since Maybe a is already taken
17:08:23 <jle`> and do blocks look nicer when you just have one level of >>='s
17:08:25 <ttt_fff> I'm naming my monad "Sorta a"
17:08:32 <sunnymilk> there are hacks to let you do it but htey are not idiomatic and are bad form and are generally terrible
17:08:56 <georgey-> sunnymilk: can one write isInstance template haskell then that operates on compile time?
17:09:07 <sunnymilk> possibly
17:09:12 <sunnymilk> ive not used template haskell
17:09:21 <exio4> georgey-: what are you trying to do? "isInstanceOf" sounds like you are using typeclasses like they were OO classes
17:09:23 <georgey-> what hacks were you talking about
17:09:39 <sunnymilk> Data.Typeable/Data.Dynamic come to mind
17:09:58 <exio4> those don't let you know that kind of stuff, Data.Typeable works on monomorphic types 
17:12:32 <georgey-> exio4: I used makeFields from lens, so I have a bunch of lenses shared by different records. now I want to provide a default value (Nothing) if such a lens does not exist (if type is NOT part of, say, HasSubject). if there is such a lens I want to call it and return Just value
17:13:54 <georgey-> it this is possible it would save me a lot of lines 
17:15:01 <exio4> georgey-: I don't know :/ 
17:15:29 <exio4> something like a prism if the lens doesn't typecheck, sounds a bit weird :P
17:15:30 <drewbert> Has anyone here used either xslx or haExcel?
17:16:00 <drewbert> Is there a preferred library?  haExcel looks more developed but xslx is readily available from hackage.
17:16:10 <sunnymilk> georgey- it might be possible wiht template haskell
17:16:23 <sunnymilk> but i dont know for sure
17:17:23 <georgey-> exio4: does that mean I would have to write a prism manually for every field?
17:18:09 <exio4> georgey-: I don't know if that is possible at all 
17:18:12 <georgey-> oh, or did you just mean the request is kind of like prism, bit not really
17:18:23 <georgey-> yeah ok
17:18:24 <exio4> yes, I meant that 
17:19:37 <bernalex> is there a way to match a constructor like
17:19:44 <bernalex> f@MkFoo
17:19:45 <bernalex> ?
17:20:18 <DNoved1> f@MkFoo{}
17:20:55 <bernalex> DNoved1: that's what I am using presently. I thought it a bit silly, but.
17:21:17 <jle`> 'tis an idiom, heh
17:23:19 <bernalex> jle`: it's one of those cases where you go through the four stages of 1. "I wonder if..." 2. "huh... well that's neat!" 3. "ok that's kind of daft & hack-ish". 4. *looks for a more proper solution*. that happens a lot with GHC. especially with extensions.
17:24:45 <ttt_fff> I don't like the name "Sorta a"
17:24:48 <ttt_fff> too informal
17:24:54 <ttt_fff> maybe "Hopefully a"
17:24:57 <ttt_fff> or "Hope a"
17:25:18 <monochrom> Wonder a
17:25:28 <ttt_fff> Wonder is too mystical
17:25:37 <ttt_fff> it's like "I put on my robe and magical hat and cast ..."
17:25:39 <monochrom> DontHoldYourBreath a
17:26:01 <ajf> Maybe a
17:26:11 <DNoved1> Perhaps a?
17:26:11 <ttt_fff> MayOrMayNotBe a
17:26:18 <ttt_fff> I like Perhaps
17:26:25 <jle`> you can use ocaml/scala's name for Maybe
17:26:26 <ajf> ToBeOrNotTo b
17:26:27 <jle`> Option
17:26:29 <monochrom> Unlikely a
17:26:33 <ttt_fff> though I like Hope more, it shows which directly I want it to go
17:26:37 <ttt_fff> that I really don't wan an error
17:26:46 <ajf> Inconceivable a
17:27:03 <ttt_fff> [Adj] a
17:27:06 <jle`> SometimesThereMightNotBeA
17:27:10 <DNoved1> IfItsInTheMood a
17:27:18 <monochrom> and my Don'tHoldYourBreath and Unlikely shows which way I think it usually turns out
17:27:44 <monochrom> I see a glass of water, half empty :)
17:28:05 <bernalex> I see glasses full
17:28:49 <bernalex> monochrom: if your glasses usually are half-empty, I hope the vacuum is above the water and not beneath it, for yours ake!
17:28:57 <bernalex> *your sake
17:35:47 <monochrom> Murphy's Laws say that the worst happens often
17:36:51 <georgey-> s/often/always
17:37:07 <Axman6> well, in Murphy's case it was always
17:39:05 <monochrom> Murphy's Laws imply that someone like me will misstate Murphy's Laws :)
17:39:05 <bernalex> monochrom: it doesn't. people just don't know Murphy's law. :)
17:39:28 <bernalex> it really doesn't. what most people call Murphy's Law is in fact Sod's Law.
17:41:23 <bernalex> Murphy's Law is a design principle. let's say you have there's a door that you need to push to open, but it is not immediately obvious whether you need to push it or pull it open. Murphy's law then means that *someone* will try to pull it. i.e. it's bad design & should be avoided. :)
17:41:29 <bernalex> s/you have//
17:43:35 <hpc> or more succinctly, assume all possible inputs will happen
17:44:23 <c_wraith> I always push every door.
17:44:28 <bernalex> hpc: even more: "avoid ambiguousness", as a design principle.
17:47:13 <exio4> hpc: it seems some people took it too seriously and switched to Javascript 
17:48:14 <isthatit> Quick question: putStr =<< getContents
17:48:23 <isthatit> actually print the content as you're typing it
17:48:27 <isthatit> thanks to lazyness I guess
17:48:59 <c_wraith> "lazy IO", which is something that's actually quite different from normal laziness
17:49:07 <isthatit> but why can't I print "hello" (wait 1 second) "world" wit this: putStr =<< do { h <- return "hello"; threadDelay 1000000; return (h ++ "world\n") }
17:49:23 <isthatit> s/wit/wait/
17:49:44 <c_wraith> isthatit: because you didn't use unsafeInterleaveIO, which is what makes "lazy IO" act something like laziness
17:49:59 <pacak> lazy io is evil.
17:50:04 <c_wraith> isthatit: the "unsafe" in its name is there for a reason
17:50:07 <shachaf> That's nothing to do with lazy I/O.
17:50:19 <isthatit> why is lazy IO evil?
17:50:20 <c_wraith> shachaf: the contrasting previous example was
17:50:20 <ronh> isthatit did you expect return "hello" to return immediately?
17:50:30 <isthatit> ronh, yes
17:50:32 <ronh> and then continue with the execution of a function at some later point
17:50:36 <ronh> it doesn't do that
17:50:37 <shachaf> c_wraith: Yes.
17:50:55 <ronh> h <- return "hello" is the same as let h = "hello"
17:51:00 <c_wraith> throw an unsafeInterleaveIO on the threadDelay, and it gets deferred too!
17:51:20 <isthatit> c_wraith, but you just told me this was bad practice though
17:51:25 <isthatit> what's a better solution?
17:51:25 <pacak> isthatit: It might do something very different from what you are actually trying to do.
17:51:28 <c_wraith> It's terrible practice
17:51:35 <c_wraith> If you want concurrency, use concurrency
17:51:45 <c_wraith> Things like forkIO from Control.Concurrent
17:52:07 <isthatit> c_wraith, pacak what I'm trying to do is throttle IO
17:52:24 <isthatit> I want to write a program like cat but throttling IO
17:52:55 <isthatit> how can I do that with Control.Concurrent?
17:53:22 <c_wraith> Oh.  If that's what you want, isn't blocking exactly the right semantics anyway?
17:53:31 <pacak> isthatit: I'd use iteratees/pipes/machines with some Enumeratee/whatever/ ProcessT that does the throttling inside.
17:54:06 <isthatit> pacak, I saw a talk recently called something like "think lazy" it sounds like you're recommanding me to "think imperative"
17:54:24 <isthatit> c_wraith, yes blocking is exactly what I want
17:56:21 <pacak> isthatit: Thinking lazy is good in case of pure computations. For IO - it's a bit different. With streaming based solution you'll get Enumeratee [a] [a] IO r that can be composed and that will delay incoming stuff by some time.
17:58:34 <isthatit> pacak, make sense thanks
17:58:39 <isthatit> s/make/makes/
18:12:08 <jle`> finally got parallelism to yield benefits after weeks of playing around ><
18:13:30 <georgey-> a bit silly question, but what is a more common. way if writing this? "forall a. xy" or "forall a . xy"
18:13:40 <bernalex> georgey-: I'd say the former.
18:14:11 <georgey-> I got the same impression, but it looks odd to me
18:14:25 <jle`> i do the first one a lot more
18:14:30 <jle`> it matches more with like mathy stuff i guess
18:14:54 <georgey-> does it? I dont know how that is expressed in math
18:15:23 <jle`> ∀a. blah blah
18:16:03 <georgey-> ah
18:16:26 <jle`> actually do people even use period there?
18:16:32 <jle`> they might actually just use it for lambdas >_>
18:17:15 <shachaf> People use a dot. I've heard that it means roughly the same as $ in Haskell.
18:17:38 <shachaf> And that it was introduced by Church.
18:24:19 * hackagebot esqueleto 2.2.7 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2.7 (FelipeLessa)
18:29:57 <Guest1529> Haskell newcomer with question about parsec + hspec
18:30:25 <Guest1529> I have this simple parser which works in ghci
18:30:51 <Guest1529> But, when tested with hspec, returns an AsyncException
18:31:04 <Guest1529> Not really sure why and can't find much on this with Google
18:38:47 <georgey-> wtf is an orphan instance? I got that error when defining instance Show (a -> b)
18:39:30 <jle`> georgey-: it's an instance that is not defined in the same module where either the type or the class is defined
18:39:41 <pacak> georgey-: They are evil.
18:40:00 <georgey-> huh? why would they be evil?
18:40:22 <bernalex> hm. I think I'm misunderstanding something.
18:40:30 <c_wraith> georgey-: they tend to break things
18:40:43 <pacak> If you define several orphan instances in different places - ghc can't decide which one is correct. Bad things will happen.
18:41:11 <bernalex> if I have a function f :: IO () that does exitSuccess eventually, shouldn't 'forkFinally (forever $ f) (const exitSuccess)' close my program with it?
18:41:32 <georgey-> if more than one piece of code defines instance for the same type the code will compile?
18:42:21 <c_wraith> georgey-: in this case, "break" means "code that was unchanged suddenly quits compiling"
18:42:53 <georgey-> I cant see that can happen. in my case show function did not compile
18:43:02 <jle`> bernalex: i think it just ends the thread
18:43:09 <jle`> so if main is still running, it will stil go on
18:43:22 <bernalex> jle`: oh wait so const exitSuccess is run *within the thread*, not in the parent?
18:43:50 <jle`> even if it's run in the parent, the parent might not be the last command in the main thread
18:43:52 <georgey-> it did not compile until I provided a show instance for function
18:44:11 <bernalex> jle`: the latter half of that sentence doesn't parse for me
18:44:24 <jle`> bernalex: so you might be calling forkFinally in a thread that isn't the main thread
18:44:39 <georgey-> oh I see what you mean
18:44:51 <bernalex> I guess what I really should ask is: if I have a main that does a few forkIOs -- how can I have my parent die when one (specific) of the children dies?
18:44:52 <jle`> sorry, yeah, the last part of what i said didn't make sense earlier, heh
18:46:01 <georgey-> but I am completely unaffected by it, so I will happily use orphan instance in this case :)
18:46:13 <jle`> it looks like from the docs of forkFinally that the "const exitSuccess" is run in the forked thread
18:46:29 <bernalex> jle`: yeah I guess I had that all wrong.
18:46:39 <bernalex> jle`: I'm reading the docs on "terminating the program" right now.
18:46:41 <georgey-> nice how it works with all functions because of currying
18:46:43 <jle`> you can use throwTo maybe
18:47:28 <jle`> throwTo the main thread?  not sure if that's an elegantish way to do things though
18:47:34 <jle`> i would probably have them all put to an MVar
18:47:39 <jle`> and have the main thread quit as soon as the MVar is full
18:48:03 <bernalex> jle`: I need one of the threads to tell all the others to quit though. but I think I'll use an MVar, yeah.
18:48:13 <jle`> there is probably a library function somewhere that abstracts over this in a clean way
18:48:16 <jle`> async, perhaps
18:48:26 <bernalex> jle`: this was what I was trying to avoid though, heh. too much plumbing.
18:48:27 <jle`> but i rarely use async, heh
18:48:27 <ttt_fff> what is the easiest (minimal # of dependency) way in ahskell to encode a HTML string
18:48:30 <ronh> why do you need a show instance for functions?
18:48:50 <ttt_fff> i.e. I am doing  .... onclick="alert(HASKELL_STR)" ... so I need to "encode" HASKELL_STR
18:49:01 <georgey-> so I can use "deriving Show" on records that contain a function
18:49:20 * hackagebot nested-routes 3.1.0 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-3.1.0 (athanclark)
18:49:20 <bernalex> jle`: maybe I should look if there's some neat way to quit gloss.
18:49:22 * hackagebot hsmisc 1.2 - A collection of miscellaneous modules  http://hackage.haskell.org/package/hsmisc-1.2 (DinoMorelli)
18:49:43 <jle`> ttt_fff: encode as in, escape ?
18:49:51 <ttt_fff> jle`: YES! escape
18:50:14 <jle`> if you're doing javascript then there's probably a good chance that you already have a library somewhere that has something-ish
18:50:24 <jle`> so looking for minimal number of dependencies might be the wrong question
18:50:27 <jle`> what are you using already?
18:50:40 <ttt_fff> I'm writing out a giant SVG file
18:50:40 <ttt_fff> by hand
18:50:41 <ttt_fff> now, I need some interactivity
18:50:43 <jle`> ah
18:50:46 <ttt_fff> so I need to write some javascript to call alert
18:50:51 <ttt_fff> for showing type signature of code
18:50:58 <ttt_fff> i.e. I am displaying code as a big SVG blob
18:51:08 <ttt_fff> there's type information, but I don't swant to show them by default to avoid clouding the SVG
18:51:18 <ttt_fff> however, when I click on parts of the code, I want a JS alert window to pop up and tell me the type sig
18:51:24 <ttt_fff> does this make sense?
18:51:29 <jle`> mhm
18:51:29 <ttt_fff> or does this sound retarteded?
18:51:36 <georgey-> can you supply ghc options that will apply to just one function? i know you can do it per file
18:51:53 <jle`> you might want to google for haskell escape html, but it looks like most html escaping libraries also deal with other stuff too
18:51:56 <jle`> georgey-: what sort of options?
18:52:13 <ttt_fff> jle`: help me first, ignore that other guy :-)
18:52:27 <georgey-> -fno-warn-orphan-instance, or whatever the flag is
19:00:57 <drewbert> Is there a preferred library?  haExcel looks more developed but xslx is readily available from hackage.
19:01:15 <sccrstud92> preferred library for what?
19:01:33 <drewbert> excel file reading and writing
19:04:21 * hackagebot postgresql-schema 0.1.3 - PostgreSQL Schema Management  http://hackage.haskell.org/package/postgresql-schema-0.1.3 (markfine)
19:07:59 <bernalex> is there a way to wait for a thread to finish?
19:08:03 <Axman6> drewbert: there's also excelsior - I haven't used any though. We've been using gnumeric to convert to CSVs and using cassava to deal with those. the gnumeric tool is ssconvert is the tool which does the conversion
19:08:20 <bernalex> e.g. 'f :: ThreadId -> IO (); f i = waitFor i >> return ()'
19:09:04 <jle`> bernalex: i think there's no built in way in base...people usually use an mvar
19:09:04 <bernalex> perhaps uh 'wait' might be it lol
19:09:08 <jle`> oh, really?
19:09:23 <bernalex> jle`: it's in concurrent-extra
19:09:26 <jle`> ah
19:09:31 <jle`> yeah
19:09:32 <bernalex> the name of the module made me think it was base at first
19:10:09 <jle`> async has it too i believe
19:10:16 <bernalex> very useful
19:11:01 <sccrstud92> recommend async
19:11:28 <jle`> yeah, async is a bit of a canonical thing, and it's simon marlow
19:13:03 <pharaun> what's the best way to "connect to a socket" and timeout if its too slow?
19:13:22 <mauke> async
19:13:27 <sccrstud92> i think race from async
19:13:29 <pharaun> so i can then try a different address (trying to handle dns returning a v6 ip but there being no v6 route)
19:13:52 <pharaun> didn't seem to remember an timeout in async but i'll check again
19:13:53 <pharaun> thanks
19:14:31 <jle`> lenses are nice so i can have more than one fmap for a type
19:14:43 <jle`> and fmap's with constrained types too, or weirdly shaped fmaps
19:14:45 <jle`> life is good
19:14:55 <jle`> and i don't even have to require lens to provide them
19:15:23 <sccrstud92> jle' what lens do you use for that?
19:15:32 <jle`> i write lenses for my types
19:15:39 <jle`> so people can use them with `over`
19:15:57 <jle`> over thisAspect f, over thatAspect f, over thisLayer f, over thatLayer f, etc.
19:16:08 <jle`> instead of just having `fmap f` available
19:16:29 <sccrstud92> :t over
19:16:30 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
19:16:58 <jle`> for how i'm using it, it's over :: Lens s t a b -> (a -> b) -> s -> t
19:17:25 <sccrstud92> yeah
19:17:31 <sccrstud92> im curious
19:17:35 <mauke> pharaun: race (threadDelay n)
19:17:43 <sccrstud92> any simple Prpfunctors other than (->)?
19:18:13 <Axman6> Kleisli perhaps?
19:18:15 <jle`> also having getters for free is nice too
19:18:31 <pharaun> mauke: so i would basically check if i got a socket back, if i did i'm good, if i didn't then i need to try again with the next ip
19:18:59 <mauke> pharaun: well, you could also race all the connects against each other
19:19:09 <sccrstud92> is every Arrow and Profunctor?
19:19:21 <jle`> yes, plus more
19:19:38 <georgey-> what was that extension name, func (Record { f=recordField })?
19:19:49 <pharaun> right now i just interweaved a list [ipv6, v4, v6, v4...] and was going to just try to connect to one, timeout in 1s then try the next till i exhausted the list of ip returned from dns
19:20:17 <pharaun> mauke: i did ponder racing both the v6/v4 connection, but i would want to give a slight favor to v6
19:20:22 <pharaun> https://tools.ietf.org/html/rfc6555
19:20:40 <jle`> lmap = (^>>), and rmap = (^<<)
19:20:58 <jle`> georgey-: that looks like standard haskell to me?
19:21:17 <mauke> pharaun: I see
19:21:21 <georgey-> :)
19:21:38 <jle`> are you looking for puns?
19:21:39 <pharaun> mauke: updating the network-simple library because right now it only takes the first ip and try to connect then fails and doesn't try any other
19:21:44 <georgey-> jle`: even if I omitted some fields?
19:21:48 <jle`> RecordPuns or RecordWildcards?
19:21:51 <pharaun> so i figured i would at least try to implement a simple version of happy eyeballs for it
19:21:56 <georgey-> I will take a look
19:22:00 <jle`> oh yeah, what you just put will wirk even if you omit fields
19:22:11 <jle`> that's why people do things like f (Foo{}) = ...
19:22:21 <jle`> to ignore all fields in Foo and just match on the constructor
19:22:26 <pharaun> mauke: i'll play around with async.race and see how it works out thanks for the pointer
19:22:28 <georgey-> neat
19:22:28 <jle`> it's a part of standard haskell
19:22:45 <mauke> pharaun: (the other one is waitAnyCancel)
19:26:09 <pharaun> thanks mauke 
19:28:08 <georgey-> jle`: nope that did not work without extension.. Data T = T { field :: Int }   func (T { f = field }) = f
19:28:22 <georgey-> I will check extensions you mentioned
19:29:28 <solirc> Guest1529: cod
19:29:41 <solirc> Guest1529: code?
19:30:03 <Guest1529> solirc - I think I've figured it out. Thanks, though.
19:30:19 <solirc> ok
19:30:22 <Guest1529> solirc - needed to make one of my datatypes an instance of Eq
19:30:26 <Guest1529> Weird error to get
19:30:38 <mauke> georgey-: shouldn't that be func T { field = f }?
19:36:07 <hodapp> whaaa... "Promoting Functions to Type Families in Haskell" (and the singletons library, which it discussses) is an epic work of type-hackery o_O
19:36:18 <hodapp> I got maybe a third of the way in.
19:39:31 <DNoved1> Is there a solution to 'rigid type variables' aside from commenting out the type declaration? (In the case that something compiles fine without its type specified, but if I give it one the compiler throws up)
19:40:07 <shachaf> In most cases the solution is to give it the correct type.
19:40:12 <mauke> DNoved1: scoped type variables, usually
19:40:22 <DNoved1> Well, the type is correct, that much I'm certain of.
19:40:26 <mauke> it's not
19:40:30 <hodapp> DNoved1: could you paste some code for us to look at?
19:41:34 <sccrstud92> "that much I'm certain of" =)
19:42:05 <sccrstud92> DNoved1: what is the type ghc infers when you put a type hole there?
19:42:40 <DNoved1> http://lpaste.net/135433
19:43:05 <DNoved1> The reason I'm certain is because I'm just generalizing a specific case for all cases, but the types are the same.
19:43:28 <DNoved1> expressions are functors/foldables/traversables
19:43:49 <DNoved1> sccrstud92, how do you do type holes?
19:44:24 <shachaf> GHC doesn't have type holes.
19:44:41 <sccrstud92> DNoved1: instead of a term, put an identifier that starts with and underscore
19:44:44 <shachaf> It has regular value-level holes which people like to put the word "type" next to for some reason.
19:44:45 <sccrstud92> like _hole
19:45:08 <sccrstud92> shachaf: it has partial type sigs, doesnt it?
19:45:38 <sccrstud92> DNoved1: and ghc will give you a warning with the type it would expect that expressiosn to have
19:45:40 <shachaf> Does it?
19:45:57 <sccrstud92> shchaf: in 7.10, think so
19:46:07 <shachaf> Is that the feature you were talking about?
19:46:52 <sccrstud92> it is probably more useful for his case than typed holes
19:47:27 <sccrstud92> DNoved1: if you turn on PartialTypeSignatures
19:47:30 <sccrstud92> you can do
19:47:35 <sccrstud92> expr :: _
19:47:43 <sccrstud92> expr = -- whatever
19:47:53 <sccrstud92> and ghc will tell you the type it infers
19:48:44 <shachaf> What is the type you're matching on?
19:49:52 <sccrstud92> shachaf: DNoved1 posted a link
19:50:05 <shachaf> Yes, that's the link I'm asking about.
19:50:31 <DNoved1> I wonder if it has something to do with type families
19:51:03 <DNoved1> shachaf, I'm matching on a expression which is a functor/foldable/traversable containing a monad
19:51:19 <shachaf> I'm asking for a type definition.
19:51:28 <shachaf> An error message would be useful too.
19:52:19 <mauke> and the code triggering the error message
19:52:32 <lpaste_> DNoved1 pasted “Expr'F” at http://lpaste.net/135434
19:54:32 <lpaste_> DNoved1 pasted “The error message (with odd encodings for type variables)” at http://lpaste.net/135437
19:54:59 <DNoved1> For some reason when I piped the error message the type variables came out a bit funny
19:58:32 <sccrstud92> DNoved1: is it possible you have an extra/missing apostrophe?
19:59:07 <sccrstud92> DNoved1: also, what is the type sig you are using?
19:59:57 <DNoved1> sccrstud92: Eq b => (b -> Int -> b') -> Int -> [(b, b')] -> Expr' b -> Expr' b'
20:00:34 <sccrstud92> oh i thought you were typing some other expression
20:00:36 <sccrstud92> i see
20:00:48 <DNoved1> Basically, the idea of the function is to take expressions and renumber their identifiers to be unique.
20:02:50 <ttt_fff> in haskell, is ther a O(log n) time op for: given a set of n-elements, and a new string x, find a y s.t. (x++y) is not in the set
20:03:04 <ttt_fff> (I'm doing substitution and need to generate new vars)
20:03:43 <dramforever> I'm going to ask this again:
20:04:08 <dramforever> I'm trying to write a compiler, and I'm wondering where to put source position tags
20:04:23 <dramforever> because if I put them everywhere it clutters the code quite a bit
20:04:34 <ttt_fff> oh oh
20:04:38 <ttt_fff> I just dealt with this exact problem
20:04:57 <dramforever> I asked this yesterday
20:05:01 <ttt_fff> data SrcText = SrcText Text Int Int
20:05:10 <dramforever> huh?
20:05:11 <ttt_fff> I solved this problem a year ago.
20:05:18 <ttt_fff> data SrcText = SrcText Text Int Int
20:05:24 <ttt_fff> stores actual text + col + row of where it starts
20:05:32 <ttt_fff> badass
20:05:36 <ttt_fff> you're welcome
20:05:47 <dramforever> ttt_fff: but it clutters the code quite a bit
20:05:52 <ttt_fff> It does not
20:06:00 <ttt_fff> you just overload string ops over SrcText
20:06:01 <ttt_fff> very clean
20:06:33 <dramforever> I'm not dealing with strings...
20:06:36 <sccrstud92_> DNoved1: what is the type that is inferred for the whole function if you dont specify a type?
20:07:03 <ttt_fff> what are you dealing with?
20:07:11 <dramforever> ttt_fff: compiler ast
20:07:15 <ttt_fff> yeah
20:07:22 <ttt_fff> does your compiler ast have keywords / var names / ... ?
20:07:25 <ttt_fff> theyre strings, so use SrcText
20:07:50 <dramforever> hmm...looks good enough
20:08:30 <dramforever> ttt_fff: what about expressions, statements, blocks...
20:08:53 <ttt_fff> worked out fine for me
20:09:09 <lpaste_> DNoved1 pasted “Minimal(-ish) example” at http://lpaste.net/135438
20:09:13 <dramforever> ttt_fff: so maybe positions everywhere is still the best solution
20:09:36 <DNoved1> sccrstud92_, let me see
20:11:51 <DNoved1> It infers (b -> s -> b) -> s -> [(b, b)] -> t -> Expr' b
20:12:14 <DNoved1> Though oddly it then fails to compile, even though it'll compile if no annotation is given.
20:12:33 <drewbert> "The exception was: ExitFailure 1" cabal really needs to let go of this kind of error reporting.
20:13:03 <ttt_fff> how can I define 'unions' interms of 'union' ?
20:13:10 <ttt_fff> should I use foldl or foldr?
20:13:22 <sccrstud92_> no Eq?
20:13:33 <sccrstud92_> no b'?
20:14:15 <DNoved1> Yah, I thought that it infers [(b,b)] odd too, since they should be different
20:14:22 <sccrstud92_> where is the context?
20:14:37 <jle`> typed holes don't get typeclasses
20:14:42 <jle`> > [1,_]
20:14:44 <lambdabot>      Found hole ‘_’ with type: t
20:14:44 <lambdabot>      Where: ‘t’ is a rigid type variable bound by
20:14:44 <lambdabot>                 the inferred type of it :: [t] at Top level
20:14:52 <dramforever> :t [1, _]
20:14:53 <lambdabot>     Found hole ‘_’ with type: t
20:14:53 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
20:14:53 <lambdabot>                the inferred type of it :: [t] at Top level
20:15:02 <DNoved1> The context? Do you mean the triggering code? If so, that's lpaste.net/135438
20:16:25 <DNoved1> There are some constraints it mentions later on in the message, those are (Enum s, Eq b, RS.Foldable t, Base t ~ Expr'F b)
20:18:02 <sccrstud92_> DNoved1: they have to be the same type because of succ
20:18:21 <sccrstud92_> wait
20:18:33 <ttt_fff> :t foldl'
20:18:34 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
20:18:49 <ttt_fff> :t foldl
20:18:50 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
20:18:59 <ttt_fff> :t foldl1
20:19:00 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
20:19:15 <sccrstud92_> nvrm
20:19:59 <sccrstud92_> DNoved: well according to ghc they have to be the same type for some reason
20:20:54 <DNoved1> Huh
20:21:15 <DNoved1> I tried modifying my type signature so b' is b, and it does compile, oddly.
20:25:00 <sccrstud92_> DNoved1: i want you to test something for me
20:25:03 <ttt_fff> (a, b) -> b --- is there a function for this?
20:25:10 <Axman6> snd
20:25:13 <Axman6> :t snd
20:25:14 <lambdabot> (a, b) -> b
20:25:18 <sccrstud92_> on the line in renumber for the ApplyF case
20:25:41 <sccrstud92_> instead of rewriting ApplyF  m n on the right side
20:25:48 <sccrstud92_> what happens if you use an @ pattern
20:25:54 <sccrstud92_> i.e.
20:26:21 <ronh> @hoogle (a, b) -> b
20:26:22 <lambdabot> Prelude snd :: (a, b) -> b
20:26:22 <lambdabot> Data.Tuple snd :: (a, b) -> b
20:26:22 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
20:26:23 <sccrstud92_> expr@(ApplyF _ _) -> embed <$> sequence expr
20:26:45 <DNoved1> Same error when using @, interestingly.
20:27:03 <sccrstud92_> DNoved1: I know the issue
20:27:19 <sccrstud92_> ApplyF is polymorphic in the binder type
20:27:31 <sccrstud92_> so when you call ApplyF m n on the right side
20:27:42 <sccrstud92_> you are changing the binder type
20:27:45 <sccrstud92_> when you do
20:27:49 <sccrstud92_> expr -> embed <$> sequence expr
20:27:53 <sccrstud92_> the binder type is required to be the same
20:28:11 <sccrstud92_> you get it?
20:28:13 <DNoved1> Hmm...
20:28:33 <sccrstud92_> expr on the right has the exact same type on the right
20:28:33 <DNoved1> Ya, I recall having something like that when changing the type of Either a b to Either a c
20:29:04 <DNoved1> Can't just take correct@(Right _) -> correct, you have to do Right a -> Right a
20:29:16 <sccrstud92_> DNoved1: yup
20:29:20 <sccrstud92_> same with Nothing
20:29:24 * hackagebot uacpid 1.1 - Userspace Advanced Configuration and Power Interface  event daemon  http://hackage.haskell.org/package/uacpid-1.1 (DinoMorelli)
20:29:52 <sccrstud92_> well that was fun
20:29:52 <sccrstud92_> lol
20:30:31 <DNoved1> I wonder if cast-magic would help, then.
20:31:13 <DNoved1> sccrstud92_: indeed
20:34:24 * hackagebot rosa 0.2.1.0 - Query the namecoin blockchain  http://hackage.haskell.org/package/rosa-0.2.1.0 (rnhmjoj)
20:54:17 <linuxcam> Hello?
20:54:32 <godel> hello linuxcam 
20:54:55 <linuxcam> is there an intercative shell of haskell
20:55:06 <godel> yes
20:55:07 <linuxcam> like irb for ruby
20:55:10 <godel> ghci
20:55:23 <godel> it comes with ghc
20:58:39 <linuxcam> Cool thanks man
21:12:58 <nkpart>  Hi, I'm trying to use '-ddump-types', which is working fine. except it's not respecting "-ddump-to-file". Is this a known limitation or a bug?
21:14:19 <ttt_fff> does Either or ExceptT capture pattern match fails? If not, is there a way to get them to capture pattern match fails?
21:15:05 <slaterr> what is the HXT alternative? I only use arrows with HXT, and I forget everything about them the next time I have to modify the code
21:15:22 <slaterr> i need to parse html (possibly malformed one)
21:15:47 <shachaf> nkpart: The whole dumping thing is pretty ad-hoc.
21:16:00 <shachaf> I've run into a lot of issues with it.
21:16:09 <shachaf> Not sure about this particular one.
21:16:21 <gamegoblin> Looking for Pipes help. I’m inside a Pipe that outputs type T, and I have a reference to a Producer that produces values of type T. I want to output all of those values from my pipe. How do?
21:19:35 <funfunctor> @hoogle a -> [b] -> [a] -> [b]
21:19:36 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
21:19:36 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
21:19:36 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
21:19:54 <yayfoxes> lulz guys look at this
21:19:54 <funfunctor> @hoogle (a -> [b]) -> [a] -> [b]
21:19:55 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
21:19:55 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
21:19:55 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
21:25:51 <yayfoxes> http://www.zimagez.com/zimage/screenshot-06282015-112416pm.php
21:27:13 <yayfoxes> jessicah: can haiku look like this? http://www.zimagez.com/zimage/screenshot-06282015-112416pm.php
21:27:31 <yayfoxes> also, how do I build Haiku from source?
21:28:30 <jessicah> yayfoxes: this is not the place to discuss
21:28:46 <jessicah> and I can't help right now
21:30:22 <yayfoxes> what's the future of Haiku once BeOS compatibility isn't wanted?
21:31:31 <slack1256> is GHC available on Haiku?
21:31:57 <yayfoxes> slack1256: look in HaikuDepot
21:32:09 <yayfoxes> I really don't think I can run Haiku, computer's too new
21:34:19 <slack1256> Mmm Has somebody done a firefox add-on with ghcjs?
21:35:01 <yayfoxes> slack1256: I must file a bug report entailed "Haiku won't boot, computer's too new"
21:36:12 <khanage> slack1256: that'd be pretty great to have a ghci in the browser ala greasemonkey
21:36:25 <slaterr> alternative to hxt for parsing malformed html anyone?
21:37:37 <slack1256> khanage: I want to make an add-on to load literate haskell blogpost with a single click
21:37:58 <slack1256> It's boring downloading (or copy pasting) the file and then running in it on ghci + editor
21:38:04 <yayfoxes> lol slack1256 , wrong channel
21:38:31 <slack1256> yayfoxes: yep, I was wondering how long it would take you to notice :-p
21:38:33 <khanage> slaterr: you could try regexp
21:38:40 <khanage> slaterr: ;)
21:38:57 <slaterr> blasphemy
21:39:22 <slack1256> you *can* parse HTML with augmented (PCRE) regex
21:39:27 <slack1256> it won't be easy nor fun nor sane
21:45:36 <Moggle> what's the most straightforward way to run a function on program exit, no matter if it exits cleanly/is ctrl+c'd or whatever?
21:48:38 <slack1256> Moggle: You can use a clean up function on SIGTERM and SIGINT but not SIGKILL
21:48:53 <slack1256> use the same function when the programs exits normally
21:49:05 <Moggle> What module should I be looking under to capture those signals?
21:49:36 <Moggle> are those signals called when an exception is raised?
21:49:37 <slack1256> On Linux IIRC the unix package or the Control.Exceptions module
21:49:52 <Moggle> is there a cross-platform way? not a big deal since i'm on linux, but...
21:50:24 <slack1256> more like when the signal is raised, the GHC's runtime issues an specific exception that you can handle with a default action or with something else
21:50:45 <slack1256> I don't know about how to process on windows, I would check the appropiated packages (if they exist)
21:51:27 <Moggle> so if say
21:51:31 <Moggle> there's a division by 0 error
21:51:34 <lpaste_> slack1256 pasted “example handling SIGTERM” at http://lpaste.net/135444
21:51:37 <Moggle> the sigterm/sigint won't capture anything?
21:51:49 <Moggle> i need to use an exception handler on the main thread?
21:52:28 <slack1256> Well division by 0 is a value on the standard of floating points. I guess more than a unix signal is a GHC runtime exception
21:53:09 <slack1256> Moggle: Read the docs on Control.Exceptions it's better explained there than by me :-)
21:53:16 <Moggle> okay, thanks for your help
22:06:31 <funfunctor> Can anyone cast some advice on how to improve these functions? http://lpaste.net/135446
22:07:20 <funfunctor> I feel these could be rewritten a lot better
22:08:47 <saulzar> funfunctor, Probably help to know what Element is? What's bar meant to do?
22:09:24 <funfunctor> saulzar: its just some GADT but there should be enough type information there though?
22:10:15 <funfunctor> saulzar: data Element = Element (Either String InnerElement) deriving Show
22:10:22 <adamse> funfunctor: the bar does not seem totally correct, what if the inner list has more than one element?
22:11:10 <funfunctor> adamse: yea its a bit of a hack, I just had a short fight to get it to type check so I could get something going
22:11:47 <saulzar> funfunctor, Got that much - but just a little hard to get a feel for what it's all about
22:12:47 <funfunctor> saulzar: just to extract this information http://lpaste.net/135447
22:15:17 <adamse> funfunctor: how bout http://lpaste.net/135446
22:16:19 <adamse> funfunctor: you could probably just inline `la` into bar, then you wont have to create all the maybes
22:17:31 <jle`> anyone know how i can turn a Lens s t a b into a Lens [s] [t] a b?
22:17:51 <jle`> does it need to be a traversal maybe?
22:18:57 <slack1256> wasn't that the motivation for traversals?
22:19:04 <slack1256> doing a lens look on multiple targets?
22:19:17 <mniip> jle`, depends on what you want to do
22:19:29 <mniip> do you want to focus a single element, or multiple
22:19:38 <jle`> i guess multiple
22:19:39 <funfunctor> adamse: thanks!
22:19:43 <mniip> Traversal
22:20:09 <funfunctor> adamse: yea I was just breaking down the problem into enough types so I could get to the end point..
22:20:23 <dramforever> :t traversed . _1 :: Lens [(a, x)] [(b, x)] a b
22:20:25 <lambdabot>     Could not deduce (Applicative f1) arising from a use of ‘traversed’
22:20:25 <lambdabot>     from the context (Functor f)
22:20:25 <lambdabot>       bound by the inferred type of
22:20:36 <mniip> a single-element-focusing lenslike like one that focuses on list head would be a Prism
22:20:42 <dramforever> :t traversed . _1 :: Traversal [(a, x)] [(b, x)] a b
22:20:43 <pacak> :t traverse . _1
22:20:44 <lambdabot> Applicative f => (a -> f b) -> [(a, x)] -> f [(b, x)]
22:20:44 <lambdabot> (Applicative f, Traversable t, Field1 a b a1 b1) => (a1 -> f b1) -> t a -> f (t b)
22:20:48 <dramforever> yay!
22:21:08 <dramforever> jle`: isn't that how lens is supposed to work?
22:21:23 <zacts> is there a haskell stackage irc channel?
22:21:25 <jle`> how do you mean?
22:21:41 <zacts> https://www.stackage.org/
22:22:01 <dramforever> jle`: that's exactly what (.) for lens does
22:22:06 <mniip> jle`, he means whether traverse is the combiunator you're looking for
22:22:09 <jle`> ah yeah, def :)
22:22:14 <zacts> I have questions about the 'stack' utility
22:22:30 <dramforever> zacts: maybe you can ask here...
22:22:36 * dramforever can't answer, though
22:22:41 <zacts> oh
22:22:44 <zacts> cool
22:23:01 <zacts> well, can 'stack' replace the need for haskell-platform?
22:23:06 <zacts> if I choose to go this route?
22:23:21 <zacts> (if I decide to use stack instead of cabal)
22:23:34 <zacts> (or perhaps I am hugely misunderstanding something here?)
22:23:51 <slack1256> zacts: I would read the blogpost, those "sell" the tool better than we every will
22:24:21 <zacts> slack1256: ok
22:24:42 <zacts> which blogpost would this be?
22:25:23 <jle`> is there a way to refactor `map (view x) . view y` ?
22:25:46 <slack1256> zacts: google-fu! https://github.com/commercialhaskell/stack
22:25:49 <slaterr> zacts I haven't used haskell-platform ever since I started using sandboxes. you install all the packages locally, per project, and if something goes wrong you just kill the sandbox and try again. you can use cabal sandboxes together with stackage to download from stackage instead of hackage.. and stack tool, from what I've heard, unifies all of this and improves it
22:26:10 <slaterr> I have not tried it yet though
22:26:16 <dramforever> IMHO fpco is doing a great job!
22:26:17 <ttt_fff> i am going to build the team
22:26:22 <ttt_fff> haskellers gonna collect them all
22:26:26 <ttt_fff> to write pure code is my cause
22:26:29 <kadoban> zacts: You can replace haskell platform with just sandboxes and optionally something like stackage. Personally I've been using the stackage cli stuff for a bit now and it's pretty nice once you figure it out, though it's not that polished yet.
22:26:45 <zacts> oh cool
22:27:16 <scutigera> in attoparsec i'm trying takeWhile1 (not isHorizontalSpace) - and ghc doesn't like that . ??
22:27:16 <zacts> slaterr: oh interesting, I'll have to look into this too
22:27:45 <kadoban> :t not
22:27:46 <lambdabot> Bool -> Bool
22:28:01 <scutigera> aha
22:28:03 <zacts> kadoban: oh cool
22:28:19 <slack1256> zacts: or avoid all this, take the easy option (stack) and don't bother with sandboxes until you really need them.
22:28:20 <scutigera> lambda c -> not (isHorizontalSpace c)
22:28:24 <dramforever> scutigera: you didn't read the error message, did you
22:28:24 <slack1256> I mean take the less costly option
22:28:26 <zacts> slaterr: that 'oh interesting was actually for kadoban sorry)
22:28:41 <zacts> slack1256: I think I'll start your idea first
22:29:24 <scutigera> dramforever: of course i did- and of course i didn't understand it.
22:29:28 <scutigera> naturally i do now...
22:29:30 <kadoban> stack does sound nice, but … I don't really understand what it does yet and haven't really looked into it.
22:29:37 <dramforever> scutigera: okay
22:29:51 * dramforever has seen many people who don't read error messages
22:30:02 <scutigera> dramforever: hindsight 20/20 etc...
22:30:19 <dramforever> in my computer class many people just shout to teacher "help me with this error"
22:30:22 <scutigera> Possible cause: ‘not’ is applied to too many arguments
22:30:27 <slaterr> it took me a while to train myself to read whole error messages (at least the first one), instead of just glancing through it and then trying to guess what it wanted to say
22:30:41 <scutigera> if i had stopped reading on the first line i would have been fine
22:30:49 <scutigera> but then i read the next 5 lines and got confused
22:31:04 <dramforever> scutigera: possible cause mudleading
22:31:55 <scutigera> what i really want is takeTill, i think.
22:32:19 <scutigera> of course - i'm just making a rule to break a line into words. what is hould really do is just apply words to the line !
22:32:32 <scutigera> but i'm doing it through attoparsec as an exercise for the reader
22:32:38 <scutigera> or is it the casual observer ?
22:32:43 <yohanobs> hi, 
22:33:04 <yohanobs> i need something to follow my studies in haskell 
22:33:08 <scutigera> hi
22:33:26 <yohanobs> i tried some small games in haskell and other problems 
22:34:04 <jle`> scutigera: btw, (\c -> not (isHorizontalSpace c)) is (not . isHorizontalSpace) :)
22:34:05 <yohanobs> now i am searching an open source application like an database implematation or network managar
22:34:12 <yohanobs> to study the code 
22:34:21 <yohanobs> can you show some examples
22:34:29 <yohanobs> or a link to a page with examples
22:34:29 * hackagebot yesod-bin 1.4.11 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.11 (MichaelSnoyman)
22:34:31 <yohanobs> ???
22:34:38 <scutigera> jle`: true dat
22:35:04 <scutigera> composition. haskell allows composition ?
22:35:14 <scutigera> huh. ;-)
22:35:16 <bob_twinkles> :t (.)
22:35:17 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:35:26 <slaterr> @src (.)
22:35:26 <lambdabot> (f . g) x = f (g x)
22:35:35 <bob_twinkles> ^ your best friend!
22:35:52 <scutigera> how do i love (.), let me count the ways
22:35:57 <scutigera> love (.) dot
22:36:00 <scutigera> dot (.) love
22:36:02 <scutigera> 2
22:36:19 <slack1256> Mmmm
22:36:29 <slack1256> Is there a function that return the number of arguments it takes?
22:36:58 <scutigera> i'm gonna go with know and be sad because i'm probably wrong
22:37:07 <gamegoblin> slack1256: what do you mean exactly?
22:37:12 <kadoban> slack1256: I don't think that would make any sense in haskell.
22:37:14 <scutigera> f a b c -> (a, b, c)
22:37:21 <gamegoblin> slack1256: a function that takes a function and returns the number of arguments it takes?
22:37:21 <adarqui> variable arity function?
22:37:49 <pacak> :t printf
22:37:50 <lambdabot> PrintfType r => String -> r
22:37:58 <pacak> > printf "%i" 1
22:37:59 <lambdabot>      No instance for (Show a0)
22:38:00 <lambdabot>        arising from a use of ‘show_M52460373282009460749286’
22:38:00 <lambdabot>      The type variable ‘a0’ is ambiguous
22:38:06 <funfunctor> what was the function again that takes [a,b,c] and [x,y,z] and gives me [(a,x), (b,y),(c,z)] ?
22:38:11 <slack1256> yep, I am thing on some type class magic
22:38:12 <pacak> > (printf "%i" 1) :: String
22:38:14 <lambdabot>  "1"
22:38:18 <kadoban> funfunctor: zip
22:38:23 <funfunctor> @hoogle zip
22:38:24 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
22:38:24 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
22:38:24 <lambdabot> Data.ByteString.Char8 zip :: ByteString -> ByteString -> [(Char, Char)]
22:38:25 <pacak> > (printf "%i %s" 1 "foo") :: String
22:38:27 <lambdabot>  "1 foo"
22:38:34 <funfunctor> ah ok yea zip thanks kadoban
22:38:54 <slack1256> something like "f (fail "2") undefined Proxy == 3" and "f undefined = 1"
22:38:54 <kadoban> Sure
22:39:21 <slaterr> (const 1) returns the number of arguments any function takes :)
22:39:52 <slack1256> nah, it return a function that takes the numbeer of arguments. It doesn't return the number
22:39:57 <slack1256> *returns
22:40:25 <slaterr> oh yeah. my corny joke failed
22:40:36 <slaterr> but it does return a number
22:40:41 <scutigera> skipHSpace >> many1 (takeTill isHorizontalSpace >> skipHSpace) <* endOfLine
22:40:42 <slaterr> the function that const 1 returns
22:40:50 <scutigera> that seems to get me an infinite loop...
22:41:41 <slaterr> slack1256, all functions in haskell take exactly argument, that was the point
22:41:59 <scutigera> "exactly 1 argument"
22:42:22 <funfunctor> @hoogle concat
22:42:22 <lambdabot> Prelude concat :: [[a]] -> [a]
22:42:23 <lambdabot> Data.List concat :: [[a]] -> [a]
22:42:23 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
22:42:23 <scutigera> i never thought about that - all currying - all the time
22:42:38 <slack1256> yep
22:42:56 <funfunctor> > concat [[1,2,3]]
22:42:57 <lambdabot>  [1,2,3]
22:43:53 <funfunctor> > concat [("abc", [1,2,3]), ("xyz", [3,4,5])]
22:43:55 <lambdabot>      Couldn't match expected type ‘[a]’
22:43:55 <lambdabot>                  with actual type ‘([Char], [Integer])’
22:43:55 <lambdabot>      In the expression: ("abc", [1, 2, 3])
22:44:13 <shachaf> > magic :: Int
22:44:14 <zipper> What's the limit on scope for what a hamlet file can see? Here https://gist.github.com/urbanslug/fb76722cf4c48dd59fc6#file-reverseproxy-hs-L33
22:44:14 <lambdabot>  0
22:44:15 <shachaf> > magic () 1 "hi" :: Int
22:44:17 <lambdabot>  3
22:44:19 <shachaf> slack1256: ☝
22:44:31 <zipper> I want to use the result of L33 in the hamlet file in L30
22:46:11 <scutigera> @hoogle (>>)
22:46:12 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
22:46:12 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
22:46:12 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
22:46:25 <slack1256> shachaf: Are you a wizard?
22:46:28 <scutigera> @hoogle (<<)
22:46:28 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
22:46:28 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
22:46:28 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
22:46:34 <slack1256> I was doing my magic with unsafe coece :-(
22:46:34 <shachaf> scutigera: Please use /msg
22:46:48 <slack1256> @src magic
22:46:48 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:47:09 <slack1256> > magic undefined undefined undefined undefined
22:47:11 <lambdabot>      No instance for (Show a0)
22:47:11 <lambdabot>        arising from a use of ‘show_M50618679610116417179563’
22:47:11 <lambdabot>      The type variable ‘a0’ is ambiguous
22:47:25 <KaneTW> :t magic
22:47:26 <lambdabot> Slack a => a
22:47:57 <scutigera> slack1256: better yet - cabal install hoogle
22:48:38 <slack1256> or @hoogle
22:48:40 <funfunctor> adamse: still there?
22:48:48 <slack1256> @info Slack
22:48:48 <lambdabot> Slack
22:49:01 <shachaf> Oh, hmm.
22:49:23 <shachaf> I can make it work without the annotation.
22:50:12 <funfunctor> adamse: I just would like to do a slight modification now http://lpaste.net/135446 so that I pair up the address with the eta
22:50:37 <funfunctor> adamse: line 10 wont type-check though
22:51:31 <shachaf> > magic
22:51:33 <lambdabot>  0
22:51:36 <shachaf> > magic undefined undefined undefined undefined
22:51:38 <lambdabot>  4
22:51:40 <shachaf> slack1256: ☝
22:52:01 <echo-area> > :type magic
22:52:03 <lambdabot>  <hint>:1:1: parse error on input ‘:’
22:52:13 <funfunctor> > :kind magic
22:52:14 <lambdabot>  <hint>:1:1: parse error on input ‘:’
22:52:26 <shachaf> lambdabot is not ghci. Please experiment in /msg first and then in the channel.
22:52:29 <funfunctor> what the hell is magic?
22:53:33 <echo-area> shachaf: Sorry
23:00:11 <adarqui> so happy i finally got haste installed on my osx laptop.. really want to experiment with it
23:09:44 <lpaste_> slack1256 pasted “Dirty dirty magic” at http://lpaste.net/135457
23:10:43 <slack1256> oh Vade retro satana, que llena de pecados estas
23:11:20 <shachaf> Oh, you wanted a function that takes a function as an argument, not a function that tells you how many arguments it gets.
23:11:24 <shachaf> That's easier.
23:11:31 <shachaf> Well, they're about equally easy.
23:12:32 <slack1256> Mmm, yours is a better challenge
23:13:01 <shachaf> But I'm pleased that it can work without giving it a type.
23:14:35 <mniip> shachaf, it only works if the return is monomorphic
23:14:40 <mniip> it won't work on (+) for instance
23:15:00 <shachaf> ?
23:15:28 <mniip> :t (+)
23:15:29 <lambdabot> Num a => a -> a -> a
23:15:36 <slack1256> It think a helpful function will be
23:16:01 <slack1256> > :t (fix (const (+1)))
23:16:03 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:16:18 <mniip> slack1256, btw, you can improve your typeclass
23:16:21 <lyxia> cmd
23:16:36 <mniip> oh wait
23:16:38 <mniip> hmm
23:16:59 <slack1256> mniip: Yep, feel free to edit
23:17:09 <slack1256> > :t (fix (const (+)))
23:17:10 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:17:18 <slack1256> @type (fix (const (+)))
23:17:19 <lambdabot> Num a => a -> a -> a
23:17:31 <fumieval> aw, ZipList is not Traversable. why???
23:19:22 <mniip> slack1256, you're using incoherentinstances anyway
23:19:44 <mniip> therefore you can start your recursion at instance Variadic a where number _ = 0
23:20:51 <slack1256> oh right
23:36:11 <akfp> how do I initialize stack with ghc-7.10?  Is there a stackage for ghc-7.10?
23:37:10 <ReinH> fumieval: try to write an instance :)
23:38:15 <Haskellfant> akfp: yep the nightlies
23:38:55 <Haskellfant> so stack init --prefer-nightly or something like that
23:39:07 <fumieval> ReinH: yeah, traverse f = fmap ZipList . traverse f . getZipList
23:39:20 <ReinH> fumieval: is it law abiding?
23:39:55 <fumieval> ReinH: of course; it directly inherits `traverse` of []
23:40:23 <ReinH> well, now it's traversable
23:40:51 <ReinH> submit a patch :)
23:41:11 <breadmonster> ReinH: lol
23:41:19 <fumieval> certainly :)
23:42:05 <ReinH> breadmonster: this is the open source way ;)
23:44:50 <akfp> Haskellfant:thanks!
