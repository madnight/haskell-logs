00:00:03 <larrycv> is it possible to set encoding with a :set command (so that I can put it in .ghci file and have it stick
00:07:39 * hackagebot network-protocol-xmpp 0.4.8 - Client library for the XMPP protocol.  http://hackage.haskell.org/package/network-protocol-xmpp-0.4.8 (JohnMillikin)
00:07:39 * hackagebot sys-process 0.1.0 - A replacement for System.Exit and System.Process.  http://hackage.haskell.org/package/sys-process-0.1.0 (TonyMorris)
00:32:45 <lamefun> Is this normal? http://lpaste.net/134788
00:34:33 <pharaun> hm?
00:36:29 <lamefun> IDK.
00:38:46 <sdx23> lamefun: guess the type-constructor was imported and the module itself. Avoids having to write "BuildMetaId.BuildMetaId".
00:40:54 <lamefun> sdx23, I know.
00:41:18 <indiagreen> is there anything that can be done with the “Illegal foreign declaration: requires unregisterised, llvm (-fllvm) or native code generation (-fasm)” error GHCi throws when encountering FFI declarations like http://lpaste.net/134789 ?
00:41:36 <sdx23> lamefun: so, what was your question then?
00:41:50 <dramforever> indiagreen: you have to compile it to object code
00:42:11 <dramforever> use ghci -fasm foo.hs might help
00:42:26 <dramforever> just like the error message says, use that flag
00:42:41 <lamefun> I just want to have two modules of these, eg. "module [..].PreReleaseId (PreReleaseId, make, string, validString)" and BuildMetaId exactly the same (these types are almost the same but with different constraints on underlying strings).
00:43:12 <indiagreen> dramforever: thanks, I for whatever reason thought this flag would be incompatible with GHCi
00:43:24 <dramforever> indiagreen: I'm going to switch to ERC now, expect me to be offline for a short while
00:44:14 <lamefun> My problem is that if I put the types directly in my [..].Version module, I'll have to prefix the functions (eg. makePreReleaseId, preReleaseIdString, preReleaseIdValidString).
00:44:21 <dramforever> indiagreen: hello I'm back
00:44:56 <lamefun> On the other hand, if I put them in separate modules, I'll have to write down huge imports like: http://lpaste.net/134788
00:45:14 <dramforever> you can try to isolate the foreign declarations to a new module and ghc -c foo.hs to compile to object code
00:48:30 <lamefun> Is there some kind of extension for that?
00:52:14 <indiagreen> dramforever: they're already isolated, so ghc -c module.hs has worked, but now I've no idea how it helps because cabal repl seemingly has ignored the compiled file
00:52:44 <dramforever> I don't know about that really
00:52:46 <dramforever> sorry
00:58:57 <pavonia> lamefun: If you have many record with the same filed names and types, creating a typeclass for some field might be an option
01:21:00 <AzorAhai> how does one modify a list in place?
01:21:03 <Phlogistique>  /go 
01:21:04 <AzorAhai> without creating new lists
01:21:06 <Phlogistique> oops
01:21:19 <Phlogistique> AzorAhai: what do you want to do?
01:21:35 <AzorAhai> loop over a list and modify it
01:21:49 <Phlogistique> AzorAhai: why do you want to do it in place?
01:21:55 <AzorAhai> currently im just fmap'ing over a Data.Sequence.Seq
01:22:04 <AzorAhai> im just wondering if that's the appropriate way
01:22:04 <Phlogistique> http://hackage.haskell.org/package/array-0.2.0.0/docs/Data-Array-MArray.html
01:23:00 <Phlogistique> AzorAhai: it's the appropriate way until you want to optimize your program
01:23:43 <AzorAhai> i don't care too much about optimisation
01:23:45 <AzorAhai> thank you
01:24:11 <pavonia> Why not using map then?
01:24:17 <pavonia> :t map
01:24:18 <lambdabot> (a -> b) -> [a] -> [b]
01:24:35 <AzorAhai> it's not implemented for Seq
01:24:47 <AzorAhai> only fmap is
01:24:58 <dramforever> fmap is a generalized map
01:25:00 <thimoteus> isn't map just fmap for []?
01:25:09 <AzorAhai> ah
01:25:13 <pavonia> thimoteus: Yes
01:25:13 <dramforever> @quickcheck \f x -> map f x == fmap f x
01:25:13 <lambdabot> Unknown command, try @list
01:25:28 <dramforever> I thought there was such a command
01:25:52 <pavonia> @check \f x -> map f x == fmap f x
01:25:54 <lambdabot>  +++ OK, passed 100 tests.
01:26:00 <dramforever> good
01:26:34 <dramforever> AzorAhai: so why are you worrying about the difference between map and fmap?
01:26:48 <dramforever> I wonder what made you think one works in place
01:27:47 <quchen2> Careful with quickchecking lists in here.
01:27:54 <quchen2> ?check \xs -> xs == reverse xs
01:27:56 <lambdabot>  +++ OK, passed 100 tests.
01:28:07 <ThreeOfEight> Polymorphic quickcheck tests.
01:28:19 <ThreeOfEight> Very dangerous.
01:28:19 <AzorAhai> dramforever: i only just realized that it's not in place
01:28:36 <dramforever> so what made you think you should use map not fmap?
01:28:45 <ThreeOfEight> ?check \xs -> xs == reverse (xs :: [Int])
01:28:47 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 3 shrinks):
01:28:47 <lambdabot>  [3,-3,1]
01:31:30 <AzorAhai> i was just wondering if there was something like a loop where i could update members of an array
01:31:44 <AzorAhai> im porting a nested for loop
01:32:01 <dramforever> I think fmap for Array does that
01:32:04 <AzorAhai> and i'm assuming that generating intermediate lists will be memory intensive
01:32:35 <dramforever> so you are like mapping through a list multiple times?
01:32:54 <saep> AzorAhai: Don't assume too much. Write the code and profile it. The compiler can optimize a lot of things away.
01:32:59 <dramforever> yes
01:33:24 <AzorAhai> dramforever: exactly
01:34:03 <dramforever> AzorAhai: ghc might be able to optimize map f . map g into map (f . g)
01:34:15 <dramforever> you'll want to profile it
01:34:37 <pavonia> AzorAhai: Note that in Haskell there are lists, sequences and arrays which are all different types
01:34:49 <dramforever> AzorAhai: Remember: profiling is really important, because it's pretty to hard to tell about performance
01:35:13 <dramforever> because optimization is a great deal
01:37:43 <AzorAhai> im reading the section in real world haskell now
01:38:43 <ThreeOfEight> In particular, there are certain operations that are expensive on lists (appending, indexed access)
01:39:09 <ThreeOfEight> if you need to use those a lot, it may be prudent to use another data structure (Seq, Vector, Array, ...)
01:39:21 <ThreeOfEight> but for most purposes, lists will do
01:39:59 <ThreeOfEight> and they tend to be the "nicest" way to do things
01:40:21 <dramforever> ThreeOfEight: lists are best used for sequential access
01:40:28 <dramforever> period.
01:40:47 <dramforever> at least IMHO
01:40:58 <quchen2> Vector has a pretty nice API as well.
01:41:31 <quchen2> And with OverloadedLists it's almost a drop-in replacement.
01:43:25 <ThreeOfEight> quchen2: no pattern matching though, I should imagine, right?
01:44:41 <ThreeOfEight> but it's better to use combinators like map, filter, foldl, etc. than directly doing sequential access whenever possible without too much pain
01:44:58 <ThreeOfEight> and then, it becomes quite easy to replace lists with another implementation
01:45:00 <quchen2> ThreeOfEight: You get [x,y,z] patterns too
01:45:26 <ThreeOfEight> also, the compiler can often do fusion
01:45:39 <ThreeOfEight> quchen2: so can you match on the head and tail?
01:45:49 <ThreeOfEight> (apart from the fact that one probably shouldn't for efficiency reasons)
01:46:29 <quchen2> Efficiency shouldn't be a concern when matching head/tail, both are trivial operations on lists (and on vectors too). But I don't think you can write a pattern like (x:xs), no.
01:46:37 <quchen2> Not directly, at least.
01:47:41 <ThreeOfEight> oh, right, yes, I get why it's not a problem on vectors
01:48:16 <ThreeOfEight> but re-"Cons"-ing things together probably is
01:48:31 <ThreeOfEight> if one were to implement something like map on vectors, for instance
01:49:49 <quchen2> Yes, (++) is O(m+n) for Vectors.
01:50:05 <quchen2> If you do a lot of these operations you might want to use ST.
01:50:28 <quchen2> And then do all the things you do when you want to do inplace stuff.
02:07:40 * hackagebot hscuid 1.1.0 - Collision-resistant IDs  http://hackage.haskell.org/package/hscuid-1.1.0 (DanielBuckmaster)
02:15:19 <fractalsea> Is there a way to print the thread ID along with stack traces from the +RTS -xc option?
02:18:04 <buckmaster> does anyone know what the state of haddocks on hackage is?
02:19:00 <buckmaster> i.e. they don't seem to be autogenerated at all
02:25:21 <jTT_> hi, i have a silly problem. I compiled my program on a virtual machine with the same architecture as my server. I ran “cabal install” and all worked out nicely. I was planning to copy the compiled binaries to the server but cannot find them. is “Cabal install” generating binaries or do i need to use a different command?
02:25:35 <jTT_> btw, my program is an executable
02:26:08 <buckmaster> if it looks like it compiled, it probably did - you could try `cabal build` just to be sure
02:26:16 <jTT_> kk, ty
02:26:24 <buckmaster> binaries are usually in dist/build somewhere
02:26:43 <buckmaster> ah, actually, maybe `install` puts them somewhere in your home directly
02:26:52 <buckmaster> not entirely sure, but hope that helps!
02:27:06 <jTT_> buckmaster: it did!
02:27:08 <jTT_> cheers
02:27:13 <buckmaster> :)
02:39:46 <buckmaster> failing that, does anyone know what version of haddock runs on hackage?
02:54:29 <igniting> buckmaster: they are autogenerated. it might take some time though
02:54:56 <buckmaster> I just found the github issue
02:55:08 <buckmaster> I thought last time I uploaded that it wasn't happening. seems this time it did
02:55:13 <igniting> in any case, you can upload it using a http PUT request
02:55:18 <buckmaster> now I'm struggling with the package description field :p
02:55:40 <buckmaster> igniting: that's what I've been doing, using fuuzetsu's script
02:57:49 <snizzo> hey guys, I can't understand what map (uncurry (:)) exactly does...
02:58:05 <snizzo> or more specifically what uncurry (:) does
02:58:17 <hexagoxel> :t uncurry (:)
02:58:18 <lambdabot> (a, [a]) -> [a]
02:58:59 <saep> > uncurry (:) ('w', "hat")
02:59:01 <lambdabot>  "what"
02:59:08 <snizzo> ahhh
02:59:31 <saep> @src uncurry
02:59:31 <lambdabot> uncurry f p = f (fst p) (snd p)
03:00:41 <jle`> uncurry f (x, y) = f x y
03:00:58 <deezn> Question about readFile. When I read in a file that has numbers on newlines.. what does it give me? A array of strings representing each line?
03:01:24 <saep> :t readFile
03:01:25 <lambdabot> FilePath -> IO String
03:01:35 <saep> It'll give you the file as a string.
03:02:21 <deezn> how do I get each line?
03:02:24 <saep> :t fmap lines readFile
03:02:25 <lambdabot>     Couldn't match type ‘IO String’ with ‘[Char]’
03:02:25 <lambdabot>     Expected type: FilePath -> String
03:02:25 <lambdabot>       Actual type: FilePath -> IO String
03:02:34 <jle`> deezn: you can use the "lines" function
03:02:41 <jle`> :t lines
03:02:42 <lambdabot> String -> [String]
03:02:47 <jle`> > lines "hello\nworld"
03:02:49 <lambdabot>  ["hello","world"]
03:02:50 <deezn> hmm ok.. 
03:02:52 <deezn> thanks
03:03:13 <jle`> remember that you can't use lines directoy on (readFile "foo.txt"), because lines works on String, and readFile blah gives you an IO String
03:03:18 <jle`> so you can bind it in a do block, or use fmap, etc.
03:03:46 <jle`> :t \f -> fmap lines (readFile f)
03:03:47 <lambdabot> FilePath -> IO [String]
03:04:07 <jle`> `fmap f` applies the function f to the result of an IO action
03:05:17 <snizzo> thank you hexagoxel and saep :)
03:07:45 <kqr> is there a class or something for a circular enum? i.e. I want `succ` for the last tag in the union to return the first tag in the union
03:08:13 <kqr> ah stackoverflow has the answer as usual
03:08:15 <kqr> never mind!
03:08:32 <jle`> kqr: ah, is there? :)
03:10:27 <kqr> nope
03:16:13 <lyxia> How can I convert a value of type "data T = C ConstrID [T]" (a generic representation of Haskell terms) to a corresponding Haskell value? Should I use Data.Data or something else?
03:16:17 <buckmaster> > :t fmap lines . readFile
03:16:19 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:16:32 <buckmaster> :t fmap lines . readFile
03:16:33 <lambdabot> FilePath -> IO [String]
03:16:38 <buckmaster> heh sorry bout that all
03:17:47 * hackagebot cryptonite 0.3 - Cryptography Primitives sink  http://hackage.haskell.org/package/cryptonite-0.3 (VincentHanquez)
03:19:21 <jle`> :t fmap fmap fmap lines readFile
03:19:22 <lambdabot> FilePath -> IO [String]
03:19:40 <buckmaster> that's just showing off
03:19:59 <jle`> D:
03:20:26 <buckmaster> ;)
03:20:49 <kqr> is TypeSynonymInstances a bad idea?
03:21:27 <kqr> ugh
03:21:33 <kqr> I need FlexibleInstances to do this too
03:21:40 <kqr> maybe a bad idea after all
03:21:59 <jle`> FlexibleInstances is a pretty normal extension...
03:22:06 <jle`> it's hard to do anything in haskell without flexible instances
03:22:25 <kqr> ah okay
03:22:27 <kqr> that sounds better
03:22:37 <jle`> TypeSynonymInstances i'm a little less sure about
03:23:01 <jle`> but almost every haskell thing i've written ever has used FlexibleInstances, heh
03:23:38 <kqr> oh wow
03:23:39 <deezn> why doesn’t this work: map read ["1","2","4"] ?
03:23:51 <kqr> I'm always wary of type system extensions because I don't know what they do and their consequences
03:23:52 <jle`> deezn: can you define "doesn't work"?
03:24:01 <kqr> deezn, it doesn't know what to read it as
03:24:06 <deezn> sure:
03:24:07 <deezn>     Couldn't match expected type ‘Int’ with actual type ‘[b0]’
03:24:08 <deezn>     In the expression: map read ["1", "2", "4"] :: Int
03:24:17 <deezn> [*** Exception: Prelude.read: no parse
03:24:26 <deezn> Actually it is this: [*** Exception: Prelude.read: no parse
03:24:27 <jle`> kqr: yeah, it's sometimes hard to tell which ones are which unless you have experience.  there probably should be some sort of list somewhere assessing each one
03:24:31 <kqr> deezn, ah, what result do you expect from that?
03:24:33 <jle`> deezn: you probably want it to be [Int], right?
03:24:36 <kqr> deezn, you're asking it to produce a single integer
03:24:47 <jle`> > map read ["1","2","3"] :: [Int]
03:24:49 <lambdabot>  [1,2,3]
03:24:53 <deezn> ahh yeah of course.. 
03:25:08 <deezn> thanks.. why does it not infer the type in the cmd line?
03:25:12 <kqr> jle`, there are some of those lists, but they disagree on which are harmless and they're also slightly outdated
03:25:19 <deezn> *the interpreter
03:25:21 <kqr> deezn, how would it know which type you want?
03:25:23 <maerwald> deezn: because of the type of read
03:25:30 <kqr> > read "True"
03:25:31 <maerwald> @type read
03:25:32 <lambdabot>  *Exception: Prelude.read: no parse
03:25:32 <lambdabot> Read a => String -> a
03:25:36 <kqr> huh
03:25:46 <kqr> oh
03:25:49 <kqr> monomorphism restriction
03:25:49 <jle`> kqr: hm yeah.  i guess herd knowledge or some sort of up to date canonical thing would be nice.
03:25:52 <kqr> maybe?
03:25:56 <kqr> > read "True" :: Bool
03:25:58 <lambdabot>  True
03:25:58 <deezn> Yeah but I thought it should infer it here as well.. 
03:26:10 <jle`> well, there might be more than one value that "True" might read to
03:26:15 <maerwald> deezn: how can it infer it? There is no context, there is just a String
03:26:21 <kqr> deezn, you want it to try to read as Bool, as Int, as Float, as Char and then pick the first one that succeeds?
03:26:32 <jle`> > read "True" || False
03:26:33 <lambdabot>  True
03:26:33 <deezn> It infers it here: let result = show $ sum $ map read $ lines contents
03:26:48 <maerwald> yes, because sum is a context
03:26:49 <jle`> deezn: that's becuase it knows it has to read it as a Num
03:26:59 <buckmaster> :t sum
03:26:59 <jle`> because sum :: Num a => [a] -> a
03:27:00 <lambdabot> (Num a, Foldable t) => t a -> a
03:27:01 <kqr> deezn, if you later use the value, it will know based on context. when you just type "read blah" in a terminal it has no context to infer from
03:27:11 <jle`> sum is a clue or hint
03:27:13 <buckmaster> ooh, FTP?
03:27:20 <jle`> yea :)
03:27:22 <deezn> ok so it sum that does it here. ok thats what i was confused about
03:27:28 <kqr> buckmaster, I just upgraded to 7.10 the other day. I'm reveling
03:27:36 <jle`> :t foldr
03:27:37 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:28:04 <buckmaster> > read "5" :: Num a
03:28:05 <lambdabot>      Expected a type, but ‘Num a’ has kind ‘Constraint’
03:28:05 <lambdabot>      In an expression type signature: Num a
03:28:05 <lambdabot>      In the expression: read "5" :: Num a
03:28:20 <buckmaster> how does read infer the type when used with sum?
03:28:31 <buckmaster> what num type will it choose?
03:28:39 <jle`> there are defaulting rules built into GHC
03:28:46 <buckmaster> mmm ok
03:28:50 <jle`> it sort of exists outside of the language/things you can define
03:28:56 <jle`> for Num a => a, it defaults to Integer
03:29:10 <jle`> ...i think
03:29:13 <buckmaster> > sum $ map read ["1", "2"]
03:29:14 <lambdabot>  3
03:29:22 <buckmaster> :t sum $ map read ["1", "2"]
03:29:23 <lambdabot> (Num a, Read a) => a
03:29:33 <kqr> > sum (map read ["1", "2"]) :: Float
03:29:34 <lambdabot>  3.0
03:29:37 <buckmaster> yeahhh
03:29:40 <kqr> yes looks like it defaults to integer
03:29:49 <jle`> i think it's in the Report
03:29:53 <buckmaster> :t sum $ map read ["1.5", "2"]
03:29:54 <lambdabot> (Num a, Read a) => a
03:29:57 <buckmaster> > sum $ map read ["1.5", "2"]
03:29:59 <lambdabot>  *Exception: Prelude.read: no parse
03:30:04 <buckmaster> looks like it
03:30:06 <jle`> > sum $ map read ["1000000000000000000000000000000000","1"]
03:30:07 <lambdabot>  1000000000000000000000000000000001
03:30:11 <jle`> yeah, and not Int
03:30:27 <buckmaster> > sum $ map read ["1.5", "2"] :: Float
03:30:29 <lambdabot>  3.5
03:30:41 <buckmaster> :t foldl
03:30:42 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
03:30:44 <kqr> lol this was such an engineer conversation. poking at a black box and observing its behaviour to determine how it works
03:30:49 <kqr> instead of just looking it up
03:30:50 <buckmaster> heh
03:31:00 <buckmaster> I studied engineering, so...
03:31:11 <jle`> you mean, such a science conversation :3
03:32:04 <buckmaster> true that
03:33:48 <buckmaster> :t foldl'
03:33:49 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
03:33:59 <buckmaster> cool
03:34:15 <buckmaster> one less import :p
03:35:48 <ion> Move everything into Prelude, no more imports.
03:37:08 <ion> To be honest, i *would* like base to provide lenses for everything in base, also isos and prisms as soon as Profunctor is added.
03:37:48 * hackagebot kansas-lava 0.2.4.3 - Kansas Lava is a hardware simulator and VHDL generator.  http://hackage.haskell.org/package/kansas-lava-0.2.4.3 (GergoErdi)
03:37:50 * hackagebot kansas-lava-cores 0.1.2.2 - FPGA Cores Written in Kansas Lava.  http://hackage.haskell.org/package/kansas-lava-cores-0.1.2.2 (GergoErdi)
03:37:52 <jle`> when Profunctors is added, there's no excuse
03:39:34 <jle`> well i can think of some excuses
03:39:42 <jle`> but that would have been a less catchy one liner
03:41:23 <kqr> haha
03:47:48 * hackagebot kansas-lava-papilio 0.3.1 - Kansas Lava support files for the Papilio FPGA board  http://hackage.haskell.org/package/kansas-lava-papilio-0.3.1 (GergoErdi)
03:58:22 <sdx23> I kind of need a Map Int (SomeClass a) - in which way is my considerations wrong?
03:58:55 <kqr> sdx23, you trying to create a heterogeneous container?
03:59:15 <sdx23> kqr: Guess so. Oh, the value is wrapped in an MVar, also.
04:00:08 <sdx23> kqr: i need to store some MVars that will hold results only obtained later, but all of them of the same typeclass.
04:01:05 <jle`> sdx23: : if you hav something like SomeClass a => Map Int a, then you don't know anything about the type of `a` 
04:01:18 <jle`> except that you can do things polymrophic over all SomeClass on it
04:01:52 <sdx23> jle`: but in that case there'd be only a-type values in the Map, right?
04:02:04 <jle`> yeah, but this applies to the hetereogenous case too
04:02:17 <jle`> if all you know about each thing is that it is some instance of SomeClass, you can't really do anything except things polymorphic over all SomeClass's
04:02:40 <jle`> consider if you are given a list of things of different types, and all you know is that they are instances of Show
04:03:05 <jle`> the onyl thing you could do with them is `show` them
04:03:31 <jle`> no different than just having a normal list of String :)
04:04:06 <buckmaster> or this https://wiki.haskell.org/Heterogenous_collections
04:04:07 <sdx23> ok, so Map is to "heavy" then, right? I only need it to be indexed anyway.
04:04:30 <sdx23> Problem is: I need to store arbitrarily many of those. 
04:04:49 <jle`> sdx23: this isn't an issue with Map, it's an issue for heterogeneous containers in general
04:05:09 <jle`> they aren't really useful for the things you imagine you'd use them for
04:05:19 <jle`> and in the cases where they are, there is usually a much simpler solution
04:06:10 <jle`> for example, a container that can constore a bunch of things of different types, but all you know is that they are instances of Show.  what could you imagine doing with the values?
04:06:22 <jle`> is the item indexed at key 'b' a Bool?  an Int?
04:06:42 <jle`> is the item indexed at key 'x' a Double?  a Char?
04:06:51 <sdx23> don't know, doesn't matter, will only show it.
04:06:55 <jle`> yeah
04:06:59 <sdx23> right thought?
04:07:01 <jle`> so why not just store a map of strings...?
04:07:06 <jle`> what's the difference?
04:07:14 <jle`> Map Char String
04:07:23 <jle`> and `show` them before you insert them
04:08:44 <sdx23> this is quite sensible. But what if you can do more than show it?
04:09:01 <jle`> you mean, what if you had another typeclass?
04:09:34 <sdx23> No, imagine a typeclass with multiple methods, like Num or something.
04:12:05 <jle`> typeclasses are just containers of methods, so you could store the methods themselves if you needed
04:13:17 <sdx23> jle`: ah, hm. You gave me quite some things to think about, thank you for that :)
04:13:18 <jle`> but now it really gets to the point where it would be ncie to have a concrete example of what you'd want to do
04:13:33 <jle`> usually when people ask for things like this, it's to imitate object oriented programming sort of things
04:13:39 <jle`> like Renderable a => [a]
04:13:52 <jle`> or a list of things where they are all different instaces of Renderable
04:14:17 <jle`> and for that case, the pre-apply-the-function thing usually translates well
04:14:24 <sdx23> jle`: I'll have to go in a minute, but can report in later with what I'm gonna do about it. If you're interested: It's about MethodResult in AcidState
04:15:06 <sdx23> So I actually do know almost nothing about the thing in there.
04:15:30 <ion> @let data Foo where { Foo :: (Num a, Show a) => a -> Foo }; deriving instance Show Foo
04:15:31 <lambdabot>  .L.hs:147:1:
04:15:31 <lambdabot>      Multiple declarations of ‘Foo’
04:15:31 <lambdabot>      Declared at: .L.hs:142:1
04:15:59 <sdx23> jle`: I'd be glad to continue on this later. Thank you
04:16:08 <jle`> it might also depend on what you eventually want to do with such values, too
04:16:32 <jle`> for example for MethodResult, if it's ok, you can just store a map of Tag's
04:16:59 <ion> > map (\(Foo a) -> Foo (a + 42)) [Foo (10 :: Integer), Foo (20 :: Complex Double)]
04:17:01 <lambdabot>  [Foo 52,Foo (62.0 :+ 0.0)]
04:22:36 <ion> sdx23: This may or may not be useful.
04:34:02 <Denommus> Can I use parsec to parse binary data? Is it efficient? 
04:34:48 <Clint> attoparsec is better for that
04:35:01 <Denommus> Cool 
04:35:29 <woffs> anyone doing AMQP with client certificates? I
04:36:15 <woffs> I'm just doing it with a socat proxy, but is it possible to configure the SSL client certificate within haskell / Network.AMQP?
05:03:29 <alisia> MSG lambdabot
05:04:09 <alisia> @pl
05:04:09 <lambdabot> (line 1, column 1):
05:04:09 <lambdabot> unexpected end of input
05:04:09 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:11:23 <alisia> @undo do;x
05:11:23 <lambdabot> x
05:11:55 <alisia> @undo do; Stack (\x -> ([1,2,3], Just 3)) ;v <- pop ;return v
05:11:55 <lambdabot> Stack (\ x -> ([1, 2, 3], Just 3)) >> pop >>= \ v -> return v
05:16:00 <alisia> I am having trouble understanding this behavior. in this code, http://lpaste.net/134805, func3 is desugared version of fuct1.  But why do they return different results?
05:19:30 <buckmaster> alisia: good puzzle. I'm stumped
05:21:19 <alisia> buckmaster, :) I am surprised. I was expecting it to be some beginner mixup...
05:23:07 <buckmaster> I'm installing transformers-base right now. want to try this out
05:29:15 <buckmaster> wowww
05:29:24 <buckmaster> no idea :p
05:29:37 <hexagoxel> alisia: your instance probably violates the monad laws
05:30:07 <hexagoxel> you ignore the value `st` in line 12 (!)
05:31:50 <hexagoxel> (desugaring only keeps the semantics for valid monads)
05:34:37 <buckmaster> hexagoxel: I thought that too but how does desugaring violate anything? shouldn't the two functions be the same and produce the same law-violating result?
05:34:53 <buckmaster> unless the desugaring is different because of... compiler optimisations?
05:36:47 <elben> For `data Maybe a = Some a | Empty`, what do you call `Some` and what do you call `Empty`?
05:36:58 <elben> value constructor and value, respectively?
05:37:26 <mniip> Just and Nothing?
05:38:47 <frerich> elben: They are called 'constructors'
05:39:10 <elben> But `Empty` constructs a value `Empty`, right?
05:39:21 <frerich> elben: I also heard people referring to them as 'data constructors' or 'value constructors' but usually only when talking about them in comparison to 'type constructors' (e.g. 'Maybe').
05:39:37 <frerich> elben: 'Empty' constructs a value of type 'Maybe a', yes.
05:40:08 <elben> So you would call both `Maybe Int` and `Maybe a` types?
05:40:13 <hexagoxel> buckmaster: yeah, probably something like that. `m >>= return  =  m` in this case maybe
05:40:13 <mniip> Empty is a nullary constructor
05:40:23 <mniip> Some is unary constructor
05:40:26 <mniip> elben, yes
05:40:34 <mniip> one is monomorphic and the other is polymorphic though
05:40:42 <frerich> elben: Yes, the latter is a polymorphic type.
05:40:51 <elben> I see
05:41:48 <mniip> not to be confused with Maybe
05:42:01 <mniip> which is a type entity of kind *->* but not a concrete type per se
05:48:11 <elben> Makes sense. One more thing, I say “Just 3” is an expression of type Maybe Int. But what do you call “Just a” in the data type defintion?
05:48:28 <elben> I guess a constructor makes enough sense
05:49:39 <mniip> elben, Just 3 :: Num a => Maybe a
05:50:13 <elben> Ah right. Sorry I’m getting really pedantic here—trying to understand what each little piece is called
05:50:39 <mniip> the sum-product way of defining datatype constructors isn't really related to how these constructors are to be used
05:51:27 <mniip> I mean 'Maybe a = Just a | Nothing', a here is a type variable, while at use site, the argument will be a value
05:53:18 <alisia> hexagoxel, buckmaster . Got disconnected. Saw what you were discussing from the logs. So it happend because I have violated monad laws, right?
05:53:27 <elben> mniip: I think I’m satisfied with that. Thanks!
05:54:14 <buckmaster> alisia: hexagoxel thinks so
05:55:26 <hexagoxel> alisia: it would be my guess. a hint about the correct instance: look at some state monad instance; it is pretty much what you have there
05:58:43 <alisia> hexagoxel, yes. 
06:13:23 <quchen2> mniip: GADT syntax makes this a bit clearer I think: data Maybe a where Nothing :: Maybe a; Just :: a -> Maybe a
06:14:03 <mniip> yes
06:27:56 * hackagebot socket 0.5.0.0 - A portable and extensible sockets library.  http://hackage.haskell.org/package/socket-0.5.0.0 (LarsPetersen)
06:33:41 <rbocquet> elben: Some and Empty are both constructors and values
06:33:49 <rbocquet> oops
06:49:08 <Denommus> hi
06:49:41 <aloiscochard> GHC is reporting as "defined but not used" but it's not true, if I actually remove it it fail to compile
06:49:49 <aloiscochard> does anybody faced this already? any idea?
06:49:55 <Denommus> I always forget: what library to use for doing database queries as a DSL embedded in the language?
06:50:25 <Denommus> aloiscochard: I ignore it
06:50:34 <dolio> aloiscochard: Are there multiple 'defined but not used' messages?
06:50:49 <aloiscochard> dolio: yes, the other one is valid
06:51:10 <dolio> Does the other one use the thing you tried to remove?
06:51:29 <aloiscochard> Denommus: maybe that one https://hackage.haskell.org/package/opaleye ?
06:51:34 <aloiscochard> dolio: yes, oh
06:51:37 <dolio> :)
06:51:37 <aloiscochard> that makes sense
06:51:46 <dolio> Yeah, it takes that into account.
06:51:47 <aloiscochard> thanks a lot dolio!
06:51:54 <aloiscochard> that's great actually, nice
06:57:59 * hackagebot tls 1.2.18 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.18 (VincentHanquez)
07:06:23 <newnews> www.VALBOT.com provides domain valuations. Reporting globally on Site Traffic, Pagerank, Malware, WHOIS data, SEO & even Social Media presence.
07:07:01 --- mode: ChanServ set +o mauke
07:07:01 --- kick: newnews was kicked by mauke (cool story, bro)
07:09:01 --- mode: mauke set -o mauke
07:17:42 <quazimodo> hello
07:24:45 <owl-v-> help me configuring vim for haskell -v-
07:29:44 <owl-v-> is haskell.vim all i need?
07:29:59 <saep> owl-v-: Are you just starting with Haskell?
07:30:04 <OutlawStar> owl-v-: http://www.stephendiehl.com/posts/vim_haskell.html
07:30:14 <mada> OutlawStar: thanks for that link
07:30:58 <owl-v-> saep: yes.
07:32:09 <saep> owl-v-: Then go plugin free and use a terminal with ghci. Vim should have syntax highlighting which will suffice for some time. 
07:32:57 <saep> More complex plugins and configurations only become convenient/necessary if you work on real projects (i.e. you start using extenral libraries).
07:35:08 <Denommus> how do I install docs for the libraries in my sandbox?
07:35:45 <saep> echo 'documentation: True' >> cabal.config
07:35:52 <Byte_> Can someone explain type family in simple terms
07:35:52 <saep> And reinstall everything.
07:37:51 <Denommus> saep: thanks
07:38:01 * hackagebot postgresql-query 1.2.1 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  http://hackage.haskell.org/package/postgresql-query-1.2.1 (AlekseyUymanov)
07:38:03 * hackagebot units-attoparsec 1.0 - Attoparsec parsers for the units package  http://hackage.haskell.org/package/units-attoparsec-1.0 (jcristovao)
07:39:08 <Byte_> Can somebody explain the benefit of `type family`?
07:39:50 <Denommus> Byte_: wait one moment
07:40:23 <Byte_> Sorry didnt mean to spam
07:42:18 <Denommus> Byte_: do you know how you can have a function that does different things depending on the type of the value being passed to it by using type classes?
07:42:39 <Byte_> Yes
07:43:05 <Byte_> So GADT's basically
07:43:23 <Denommus> Byte_: they are similar to GADT's, yes, but they are open, GADTs are not
07:43:36 <Byte_> What do you mean open
07:43:52 <Byte_> I also know what type classes are
07:44:00 <chpatrick> Denommus: isn't that literally just typeclasses?
07:44:04 <Denommus> Byte_: the user can create a new instance for an existing type family, but he can't create a new variant for an existing GADT
07:44:07 <chpatrick> having an implementation that varies by type
07:44:24 <Byte_> Ahh
07:44:34 <Denommus> chpatrick: yes, I was going to prepare an analogy, buy Byte_ immediately understood what I was talking about
07:44:37 <chpatrick> oh sorry I misread
07:44:43 <chpatrick> I thought you were asking a question
07:45:08 <chpatrick> Byte_: type families are useful when you want to associate a type with another
07:45:14 <Byte_> In what scenario would a user need to introduce a new type instance?
07:45:19 <chpatrick> for example
07:45:24 <chpatrick> type family Element a
07:45:31 <chpatrick> type instance Element (ByteString) = Word8
07:45:38 <chpatrick> type instance Element [ a ] = a
07:45:55 <chpatrick> you can do something similar with fundeps
07:46:14 <chpatrick> and then you could make a function like
07:46:22 <chpatrick> generalUnpack :: a -> [ Element a ]
07:46:49 <chpatrick> which would live in a typeclass presumably
07:47:19 <Byte_> And returning a Element [a] or Element (ByteString) woudl be valid?
07:47:30 <Byte_> In that example function
07:47:42 <chpatrick> no it depends on what a is
07:47:46 <zudochkin> what IDE are you using for Haskell? (Mac Os if possible)
07:48:05 <chpatrick> so for example that function could have type ByteString -> [ Word8 ]
07:48:11 <chpatrick> or [ Int ] -> [ Int ]
07:48:14 <Denommus> zudochkin: Emacs
07:48:19 <chpatrick> or Text -> [ Char ]
07:48:19 <frerich> zudochkin: I use a plain text editor on OS X (vim)
07:49:11 <Byte_> a
07:49:42 <zudochkin> frerich: thanks for your answer, what plugins are you using with vim? Do you compile packages with terminal or from vim?
07:50:44 <frerich> zudochkin: Haskell-specific plugins I use are vim-hdevtools, syntastic (not really Haskell specific tho) and vim-haskellConceal
07:51:04 <Byte_> I'm still a little confused on the topic, what would be the benefit and use of the type families here: http://lpaste.net/134807
07:51:40 <chpatrick> Byte_: that's defining arithmetic on type-level numbers
07:51:50 <chpatrick> so they're almost like functions
07:52:23 <chpatrick> the Nat data type is being lifted to the type-level with DataKinds
07:52:45 <zudochkin> frerich: awesome, thanks, I'll try it. Can you please show me ur .vimrc?
07:53:38 <Byte_> And this allows functions to relate two Nat types to another Nat type?
07:57:19 <saep> zudochkin: Also have a look at codex (a tag generator).
07:57:41 <kadoban> zudochkin: Here's mine, if you want another to look at: https://gist.github.com/anonymous/3366b03e92de34b1a418 it's mostly pretty good. If you use it you'd likely want to change the repos that the vundle part is pointing to (if you visit them on github you can see where I forked from)
08:04:04 <zipper> Hey in this code http://lpaste.net/134808
08:04:28 <zipper> What can I do so that the changed TVar may reflect in the spawned thread?
08:04:58 <zipper> I want to change the value of something in the main thread and have it reflect in the child process.
08:05:12 <chpatrick> Byte_: yes
08:05:14 <mauke> what child process?
08:05:16 <chpatrick> they're like functions
08:07:08 <zipper> mauke: Hey I was hoping to find you.
08:07:13 <zipper> mauke: worker
08:07:25 <zipper> mauke: L8
08:07:51 <mauke> what
08:08:48 <owl-v-> what is this?(cabal install) -> depends on haskell-src-exts-1.16.0.1 which failed to install
08:09:17 <magneticDuck> well, that's cabal needing a dependency but not being able to get it
08:09:41 <owl-v-> i get -> Failed to install haskell-src-exts-1.16.0.1
08:09:55 <hodapp> Can anyone recall where a certain online example is which uses TypeLits to do integer division? It used something like Nat (8 * n) -> Nat n
08:11:39 <owl-v-> i was thinking cabal is like pip for python...
08:11:57 <owl-v-> i guess not..
08:12:01 <saep> cabal is a build tool
08:13:38 <saep> owl-v-: Anyhow, try `cabal install -j1 haskell-src-exts-1.16.0.1` and you will get a better error message.
08:15:04 <owl-v-> cabal: The program 'happy' version >=1.17 is required but it could not be found.
08:15:05 <bennofs> Is there any way to disable aligned identation in haskell-indentation-mode in emacs? So that data A = A\newline<indent>{ ... } <indent> is always only 2 spaces? 
08:16:41 <kadoban> owl-v-: cabal doesn't handle executable dependencies very well (or at all), so you'll have to install that manually first. Usually I install happy and alex right after I install GHC and cabal, a few things use those.
08:16:57 <kadoban> owl-v-: So manually do   'cabal install happy' and it should get past that afterwards
08:16:59 <hpc> and mueval for lambdabot
08:17:04 <hpc> and hoogle
08:35:40 <koala_man> dibblego, you wombat hugger!
08:42:56 <lifter> "accept" is returning a "HostName" like "::ffff:10.251.1.110"... anyone know what the "::ffff:" part is?
08:43:40 <kadoban> lifter: IPv6 ?
08:43:43 * hpc has never heard of that
08:43:44 <geekosaur> it's an ipv4 address over an ipv6 tunnel. some linuxversions are configured that way by default
08:44:16 <geekosaur> (basically the kernel translates every ipv4 packet into an ipv6 packet with that kind of address)
08:45:17 <geekosaur> s/linuxversions/linux distributions/
08:45:53 <lifter> geekosaur, thanks, interesting...
08:52:46 <alfacent> hi
08:53:03 <Th30n> How can I tell ghci to ignore exports (in order to access the whole module)?
08:54:15 <ion> Load the file in interpreted mode. If ghci doesn’t do that automatically, :load *file.hs
08:58:15 <Th30n> ion: Lol, it already does work... Must have missed it somehow
08:58:20 <Th30n> Thanks
09:02:58 <erisco> here is my little puzzle piece for calculating the cartesian product of a vector of vectors... feel free to hack on it a bit http://lpaste.net/134810
09:03:07 <quchen> So I'm playing with unsafeCoerce, and I've run into a segfault I don't understand: http://lpaste.net/134811
09:03:11 <quchen> Any idea why?
09:03:26 <erisco> way better would be to use an MVector of course but I'll do that later since it is a bit messier
09:08:04 * hackagebot NetSNMP 0.3.2.0 - Bindings for net-snmp's C API for clients  http://hackage.haskell.org/package/NetSNMP-0.3.2.0 (PavloKerestey)
09:09:24 <vikaton> Hi
09:09:54 <quchen> Hello.
09:10:21 <arbelos> Hmm..: f <$> fmap foo x <*> fmap baz x
09:11:50 <felixn> hey, anyone know how to do import MyProject.Foo.Bar from GHCi?  I have like a 300 line doctest setup, and I want to move it out of the file, and also share some code with my hspec tests
09:12:32 <erisco> gosh darn this is annoying
09:12:39 <erisco> Vector.unfoldr does not return the final state
09:12:59 <erisco> need to know if there is a carry left over =\
09:13:28 <sm> interesting: nub-ing 10000 short strings on a macbook takes a minute. (And 5s after converting them to Text)
09:13:55 <erisco> sm, locality
09:14:23 <chpatrick> sm: nub is O(n^2)
09:14:36 <ion> sm: How about Text with (toList . Data.Set.fromList)?
09:14:56 <chpatrick> ^ that if you don't care about ordering
09:14:59 <quchen> Or a rewrite with Set? https://github.com/quchen/articles/blob/master/fbut.md#nub
09:16:57 <erisco> I feel like I am boned
09:17:39 <orzo> is that a good feeling?
09:17:44 <erisco> no
09:17:47 <mizu_no_oto> erisco: you might ask dolio for suggestions
09:18:37 <mizu_no_oto> dolio == maintainer of vector algorithms
09:18:47 <chpatrick> erisco: it looks like Data.List.unfoldr is a good producer
09:18:59 <erisco> I am working with vectors though
09:19:04 <chpatrick> so you might get good performance out of V.toList (Data.List.unfoldr ...)
09:19:10 <chpatrick> as in there won't be an intermediate list
09:19:15 <sm> ion, chpatrick: with Set it's about 4s - thanks
09:19:34 <chpatrick> sm: also try hashset if you want it even faster :)
09:19:41 <chpatrick> from unordered-containers
09:20:15 <chpatrick> erisco: oh that doesn't return the final state either :(
09:20:34 <erisco> I can just traverse it twice I guess
09:21:32 <chpatrick> erisco: wait isn't the final state just the last element?
09:21:57 <erisco> no
09:22:11 <chpatrick> oh yeah disregard that
09:22:43 <chpatrick> maybe it wouldn't be too bad to have an intermediate list and just recurse instead of unfoldr?
09:22:56 <erisco> list is out of the question
09:23:18 <erisco> it is okay I will just traverse twice for now
09:23:35 <erisco> when I replace with an MVector later it won't matter
09:26:51 <sm> actually with Set it was about 3s, and after rebuilding without profiling, 2s. HashSet doesn't seem to make a big difference at this scale but I'll go with that
09:27:00 <sm> thanks chpatrick
09:27:18 <erisco> sm, removing duplicate words?
09:28:15 <sm> I'm counting unique journal entry descriptions/payees, for the hledger stats command
09:29:21 <erisco> if you want to determine the count of unique words then I'd recommend a trie
09:29:28 <sm> aha, with 100000 entries I see the difference, hashset is 50% faster than set
09:29:56 <sm> haha is there no end to this cave of treasures 
09:30:40 <sm> erisco: is there a package you'd recommend for that ?
09:30:52 <erisco> I don't know, but there is probably one on hackage
09:31:08 <chpatrick> @hackage TernaryTrees
09:31:08 <lambdabot> http://hackage.haskell.org/package/TernaryTrees
09:31:09 <chpatrick> maybe
09:31:42 <zipper> mauke: Sorry. The lights went out.
09:31:45 <erisco> hashset ought to perform well at the task too, I don't know how they'd compare
09:32:19 <zipper> mauke: So what about that code? What am I not getting?
09:32:48 <zipper> Are there any talks on STM in haskell on the internet?
09:32:54 <zipper> I can't find any.
09:33:16 <quchen> https://www.youtube.com/watch?v=aQXgW55f7cg
09:33:33 <alisia> hexagoxel, ping
09:34:02 <hexagoxel> whats up?
09:34:39 <zipper> mauke: ping
09:35:50 * sm goes with hashset for now
09:35:52 <vikaton> For you people whom Haskell has made you write code differently in other languages, is it efficient?
09:36:11 <zipper> vikaton: What do you mean?
09:36:21 <erisco> vikaton, do you mean if functional style is efficient in other languages? not usually, no
09:37:42 <maerwald> vikaton: although a lot of people say it made them write better code in other languages, I disagree for myself. I've always tried to write atomic functions with one purpose and tried to avoid side effects, mutable state and so on. Haskell just made it easier for me to do that. But it didn't make me write better C code.
09:38:08 <chpatrick> I think haskell made me think very carefully about when I need state in other languages
09:38:15 <loklost> does 'cabal install ghc-mod' not install the ghc-mod executable?
09:38:30 <chpatrick> loklost: it puts it in ~/.cabal/bin
09:38:39 <ion> or in the sandbox if you’re using one
09:38:44 <muller> hexagoxel, This is alisia, I tried to see it violates monad laws..It seems it is consistant with some cases...but the desugaring still produce different results...
09:38:52 <thimoteus> http://redd.it/3absc6 i love the top reply
09:38:58 <muller> hexagoxel, http://lpaste.net/134814 can you please take a look?
09:39:14 <loklost> chpatrick: it doesnt do that for me :S
09:39:54 <chpatrick> loklost: are you in a sandbox?
09:40:00 <loklost> chpatrick: no
09:40:08 <chpatrick> weird
09:40:13 <loklost> and all the other packages work fine...
09:40:21 <loklost> and the install succeeds and everything
09:40:48 <zipper> Hey you guys. I'm trying to pass a value from one thread to another using TVars. What am I doing wrong? Here is the code: http://lpaste.net/134808#line8
09:41:10 <hexagoxel> loklost: you mean other executables? or libraries?
09:43:08 <lifter> zipper, are you getting an error?
09:43:29 <loklost> hexagoxel: executables
09:44:08 <zipper> lifter: No I'm not. But It's not passing true to `worker` when I enter text via getLine.
09:44:22 <zipper> *True
09:44:34 <zipper> I want it to print Done when I enter text.
09:45:14 <geekosaur> ummm
09:45:19 <hexagoxel> loklost: that should work; are you sure the install command succeeded?
09:45:27 <geekosaur> you kill the thread right after the put
09:45:34 <geekosaur> does it even get a chance to run?
09:45:36 <hexagoxel> muller: one mom
09:46:02 <muller> hexagoxel, no problem.
09:46:22 <lifter> zipper, yeah what geekosaur said
09:46:32 <lifter> zipper, the thread has no chance to print bcus you kill it
09:46:45 <zipper> hmmm let me see
09:49:31 <zipper> WoW it works.
09:49:45 <zipper> So after done the thread that was spawned dies?
09:49:56 <zipper> after printing "done"
09:50:04 <zipper> So I don't have to keep killing it.
09:50:56 <hexagoxel> muller: your law-validation is not complete
09:51:15 <hexagoxel> muller: because you only test the [] case in line 30
09:51:16 <muller> hexagoxel, yes. I thought so...
09:52:22 <muller> hexagoxel, how can one test for completeness?
09:52:56 <geekosaur> it has nothing else to do, so it exits, yes
09:54:23 <geekosaur> in simple green threads implementations, what you wrote might work because the thread is woken up and takes control immediately. in MxN threading, it is only scheduled and you cannot know when it will actually run, and indeed it may run at the same time as the other thread if a core is free to run it immediately
09:54:59 <hexagoxel> muller: proof it formally :p  if empirical proof is sufficient, using a one-element list of input is enough to show that it does not work in this case
09:55:12 <hexagoxel> otherwise you could write a quickcheck test or smth
09:55:33 <Zemyla> Why is TypedHoles something that can be turned off?
09:56:26 <geekosaur> (IIRC even without -threaded ghc only schedules it for later, rather than have a radically different thread mechanism)
09:58:22 <c_wraith> Zemyla: because it allows _ to be used as an expression, which Haskell syntax does not allow.  Sure, it'd still be an error, but the type of error is different than what the spec requires
10:07:12 <Zemyla> c_wraith: But it's declared by default because it's a lot more helpful of an error? What purpose would disabling it allow?
10:07:56 <c_wraith> it would allow getting... different... error messages?
10:08:13 <quchen> Zemyla: We'd like to keep GHC without option a program that compiles exactly Haskell, i.e. compiles Haskell and rejects non-Haskell.
10:08:35 <quchen> So I guess that was one of the reasons a flag was introduced.
10:09:05 <quchen> And then people found out that we're actually only changing the error message, so the flag was turned on by default.
10:09:24 <quchen> Then it was renamed from the terribly wrong "type hole" to "typed hole" and put into the release. :-)
10:11:59 <felixn> anyone ever see a good visualization for data types?  I'm trying to mock up my AST grammar with graphviz, and I can't decide on a good way to present it
10:13:02 <erisco> felixn, a tree
10:13:51 <felixn> erisco: it sounds that simple, but it isn't :D
10:13:56 <sm> I used a UML class diagram
10:14:10 <nightfury_vasa> hi, I am Vasanth
10:15:00 <johnw> felixn: mostly I see BNF used for that
10:15:24 <felixn> I was using records to create types, but it looked really confusing, now I'm trying clusters
10:15:32 <johnw> clusters?
10:15:41 <AzorAhai> how would i go about doing this in haskell?
10:15:44 <AzorAhai> http://lpaste.net/7568850389898887168
10:16:02 <erisco> AzorAhai, what does the algorithm do? i.e. what algorithm is it?
10:16:28 <erisco> it looks like cartesian product
10:16:33 <felixn> johnw: http://idiomatic.readthedocs.org/en/latest/_images/graphviz-7e3f9fd9adcdc8d3c6258d5fca98f5b6807d628a.png <-- this has me inspired
10:17:08 <erisco> > let carp f xs ys = [f x y | x <- xs; y <- ys] in carp (,) [1..2] [1..3] 
10:17:10 <lambdabot>  <hint>:1:36: parse error on input ‘;’
10:17:17 <erisco> well, someone can fix the syntax for me
10:17:26 <quchen> liftA2 f xs ys
10:17:28 <quchen> There you go :-þ
10:17:31 <johnw> I think just: f <$> elements <*> elements <*> pure elements
10:18:05 <erisco> because it uses more abstraction?
10:19:25 <AzorAhai> `elements` should be changed on every iteration
10:19:29 <johnw> unless his loops are dynamically changing due to elements being updated
10:19:34 <AzorAhai> yes
10:19:51 <johnw> hmm
10:19:54 <erisco> don't use Haskell
10:20:03 <johnw> well, this can be done using ST, and STArrays
10:20:08 <johnw> and written in exactly the same way
10:21:23 <erisco> there may be some wacky circular programming solution
10:21:50 * quchen smells some practical use for loeb ;-)
10:22:07 <johnw> actually, I think quchen is write
10:22:17 <erisco> write only or does he read too?
10:22:50 <erisco> so what is loeb
10:22:57 <johnw> loeb :: Functor f => f (f a -> a) -> f a
10:22:58 <johnw> loeb xs = ys where ys = fmap ($ ys) xs
10:23:07 <quchen> erisco: https://github.com/quchen/articles/blob/master/loeb-moeb.md
10:23:15 <johnw> it uses an algebra to build a "functor full of pending evaluations"
10:23:22 <johnw> (functoral value)
10:26:05 <erisco> well, it is a circular programming something alright
10:26:28 <quchen> It's recursive.
10:26:36 <quchen> Most Haskell is recursive.
10:26:56 * frerich gives up trying to make sense of that 'loeb' definition and goes to read up on it
10:27:01 <Denommus> > [1..2] >>= flip fmap [1..3] . (,)
10:27:02 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
10:27:04 <mniip> >Feeling smart? Let's change that, here's loeb
10:27:05 <mniip> huh
10:27:11 <mniip> not feeling any less smart
10:27:54 <erisco> quchen, well the circular bit is more or less to refer to a function consuming the data it is also producing, so particular to data constructors
10:28:03 <erisco> not just any ol' recursion
10:28:24 <Denommus> > let carp f xs ys = xs >>= flip fmap ys . f in carp (,) [1..2] [1..3]
10:28:26 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
10:29:29 <mniip> Denommus, and it's different from liftA2 how?
10:29:42 <felixn> johnw: btw State worked great for that propagation algo ... especially with ExceptT!
10:29:48 <ronh-> > let carp = liftA2 in carp (,) [1..2] [1..3]
10:29:49 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
10:30:11 <Denommus> mniip: I don't know, I was just trying to rewrite it wierdly
10:30:17 <mniip> besides the constraint, it's no different from liftA2
10:30:20 <mniip> it basically is liftM2
10:30:48 <mniip> weirdly you say
10:31:38 <mniip> :t ((<*>) .) . fmap
10:31:39 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
10:32:31 <kadoban> Heh ... that's concise.
10:33:07 <Denommus> :t flip ((.) . (>>=)) . flip ((.) . flip fmap)
10:33:08 <lambdabot> Monad m => (a -> a1 -> b) -> m a -> m a1 -> m b
10:35:17 <kadoban> :t (ap .) . fmap
10:35:18 <lambdabot> Monad m => (a1 -> a -> b) -> m a1 -> m a -> m b
10:36:15 <eitanChatav> Is there a way to do spectral decomposition of a matrix in the `linear` package
10:37:31 <nightfury_vasa> how to read this "cylin :: (RealFloat a)=&gt; a -&gt; a -&gt; a"
10:38:21 <kadoban> nightfury_vasa: First by translating the HTML entities. cylin :: RealFloat a => a -> a -> a
10:38:38 <fishythefish> cylin is a function that takes two arguments of type a and returns an a where a is an instance of RealFloat
10:38:46 <quchen> Has anyone tried the new Dwarf support in GHC 7.10?
10:39:00 <fishythefish> For instance, cylin could take a radius and height and return a volume
10:39:11 <kadoban> Is there a Fortress for these Dwarfs ?
10:40:04 <nightfury_vasa> fishythefish: in typeclass definition i have used "->" symbol but what is "&gt"
10:40:17 <fishythefish> That's HTML entities being encoded.
10:40:25 <fishythefish> &gt is how you write >
10:40:30 <fishythefish> (gt is "greater than")
10:40:44 <fishythefish> Something got messed up when someone was copy/pasting, I'm guessing.
10:41:00 <mauke> (&gt;, not &gt)
10:41:02 <Zemyla> quchen: What are Dwarves?
10:41:07 <nightfury_vasa> fishythefish: what is with all the semicolons?
10:41:15 <fishythefish> nightfury_vasa, that's just the syntax.
10:41:17 <quchen> Zemyla: It's a debugging format.
10:41:21 <fishythefish> &gt; gives you > in HTML
10:41:23 <fishythefish> &lt; is <
10:41:28 <fishythefish> etc.
10:41:31 <erisco> gr
10:41:44 <erisco> Vector.unfoldr is also annoying if you have a do-while kind of situation
10:41:51 <mauke> nightfury_vasa: the question is, why are you reading HTML source code?
10:42:08 <fishythefish> nightfury_vasa, http://www.w3schools.com/html/html_entities.asp
10:42:13 <fishythefish> It has nothing to do with Haskell.
10:42:27 <mauke> >2012
10:42:32 <mauke> >linking to w3schools
10:42:36 <eitanChatav_> is there a way to do spectral decomposition in the `linear` library?
10:42:48 <fishythefish> mauke, sorry, I'll do Codecademy next time :P
10:42:59 <eitanChatav_> \nick eitanChatav
10:43:04 <erisco> when I know the last element is also when I know if there will be any more
10:43:10 <erisco> but unfoldr doesn't let me do this
10:43:27 <erisco> guess I need another bit in my state
10:43:30 <nightfury_vasa> fishythefish: thank you for your time, goodbye
10:43:55 <mauke> https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Introduction#Named_character_references
10:44:03 <bitemyapp> eitanChatav: I think hmatrix does, but I think with linear you'll probably need to write it yourself.
10:44:08 <bitemyapp> eitanChatav: maybe translate from one to the other?
10:45:42 <eitanChatav> bitemyapp: hmatrix uses a C library underneath, right?
10:45:56 <maurer> So, I'm trying to update some old code to build on new ghc, and am running into the problem that WordPtr is no longer a legal thing to have inside a foreign import declaration
10:46:00 <maurer> What should I replace it with?
10:46:13 <maurer> I found one thing that seemed to suggest a type called "Addr", but that seems to not be available by default
10:46:15 <bitemyapp> eitanChatav: afraid I don't know much.
10:46:48 <erisco> hm, actually Vector.unfoldr can't be too efficient because it does not know the size of vector ahead of time
10:46:53 <erisco> there ought to be a version which does
10:48:44 <erisco> oh I see
10:48:46 <erisco> unfoldrN
10:49:31 <erisco> I can't be sure it allocates the entire vector up front though since it says "up to N"
10:49:32 <AzorAhai> aa
10:50:11 <mniip> @tell quchen so loeb is much like 'fix' but fixes an algebra?
10:50:11 <lambdabot> Consider it noted.
10:50:31 <eitanChatav> is there a good hmatrix tutorial?
10:50:50 <johnw> AzorAhai: https://gist.github.com/3483e943eb65b2cfedcc
10:51:03 <bitemyapp> I wish there was a good tutorial for any of the linalg stuff for Haskell.
10:51:03 <johnw> loeb didn't work out, but I think this is what you expressed
10:51:40 <johnw> no need for do-notation in "go" either
10:53:09 <johnw> and foldr may be preferable
10:54:17 <erisco> I don't think it does allocate the correct amount up front
10:54:39 <erisco> after digging through like 4 modules it gets done as this "Stream" thing
10:54:43 <erisco> which doesn't sound right to me
10:56:47 <erisco> so again have to go over to MVectors to get it to work right
10:56:55 <erisco> *shrug* could be worse, could instead not be any MVector
10:58:19 <AzorAhai> johnw: thank you but i think i'll use starray and convert to a list
10:58:27 <johnw> ok
11:00:20 <johnw> mniip: not exactly
11:01:52 <johnw> mniip: taking [] for f, it turns a list of list algebras into a list of results, by having each algebra "eat its own tail" and take the resulting list as its argument
11:02:04 <johnw> it's a very clever way to compute a DAG, depending on the information in 'f'
11:02:25 <johnw> if there are any cycles in the graph, the result is ⊥ for some values
11:04:17 <johnw> AzorAhai: actually, my second version isn't correct either, because you could change the length of elements at any point
11:13:08 <AzorAhai> johnw: the length of the elements never changes
11:13:09 * hackagebot bake 0.3 - Continuous integration system  http://hackage.haskell.org/package/bake-0.3 (NeilMitchell)
11:13:17 <AzorAhai> sorry, i forgot to mention that
11:17:15 <bitemyapp> Iceland_jack: "but it's Haskell, so how bad could it be, right?"  ah ah ahhhh
11:26:16 <mada> I recall there was some form of comparative benchmark in some site/blog that showed how Warp performed against other stacks (apache with php, node, things like that), but can't find it
11:26:37 <mada> does anyone know about it?
11:26:57 * burp_ doesn't, but if it was just a micro benchmark I would give much on it anyway ;)
11:27:54 <mada> burp_: can't say about the details, I only remember the images of the plotted results showed Warp as way faster. Orders of magnitud faster
11:28:44 <johnw> AzorAhai: ah, then what I wrote should be OK
11:28:54 <burp_> yea, I remember such plots too
11:29:14 <mada> burp_: found on yesod's blog. Thanks
11:29:25 <vikaton> Hmm
11:29:34 <burp_> http://www.yesodweb.com/blog/2011/03/preliminary-warp-cross-language-benchmarks
11:29:35 <burp_> this? :D
11:29:49 <burp_> it's ancient, probably 10 times faster now ;D
11:29:49 <vikaton> maerwald: is functional programming in C hard?
11:30:27 <mada> burp_: even better :D
11:35:39 <sm> also http://www.yesodweb.com/blog/2014/02/new-warp
11:36:05 <mada> thank you sm 
11:38:10 * hackagebot data-tensor 0.1.0.0 - Tensor and Group typeclasses  http://hackage.haskell.org/package/data-tensor-0.1.0.0 (TobiasDammers)
11:42:40 <maerwald> vikaton: depends on what you mean with "functional". You can easily write "pure" functions in C, but in order to know whether they are actually pure, you really have to read the whole implementation. And you cannot compose things as easily as in haskell
11:43:11 <maerwald> it's not really a functional language, although you can probably come up with your own stuff to imitate certain things... it's low-level after all
11:43:23 <maerwald> so not much sense in comparing both
11:44:22 <maerwald> if you mean "functional" in the sense of high-level abstraction: there are none
11:45:51 <S11001001> maerwald: I trust __attribute__((pure)) ;) https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-g_t_0040code_007bpure_007d-function-attribute-3116
11:48:05 <maerwald> S11001001: how many people use that?
11:50:38 <vikaton> This anonenvrionment kid
11:51:11 <vikaton> Whhops wrong channel
11:57:52 <Bj0rnen> Hi, I get an error when installing the "haskellPackages.gpx-conduit" package using nix, I get an error
11:58:13 <Bj0rnen> it says
11:58:14 <Bj0rnen> Geo/GPX/Conduit.hs:12:8:
11:58:21 <Bj0rnen> Could not find module ‘Data.Conduit.Text’ 
11:58:28 <Bj0rnen>  It is a member of the hidden package ‘conduit-extra-1.1.9@condu_JLu1EnneKxn9AoAxQap2xX’.
11:58:34 <Bj0rnen> Perhaps you need to add ‘conduit-extra’ to the build-depends in your .cabal file.
11:58:40 <Bj0rnen> Use -v to see a list of the files searched for.
11:59:40 <Bj0rnen> any nix users here? Is this an error on the caba/hackage side or the nix side?
11:59:47 <Bj0rnen> *cabal
12:00:30 <edwardk> johnw: ping
12:01:17 <tromp_> @src group
12:01:17 <lambdabot> group = groupBy (==)
12:01:21 <tromp_> @src groupBy
12:01:21 <lambdabot> groupBy _  []     =  []
12:01:21 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
12:01:21 <lambdabot>     where (ys,zs) = span (eq x) xs
12:02:19 <maerwald> Bj0rnen: I can't test it in my sandbox, because cabal messes up dependency resolution... did you try to install it in a sandbox?
12:02:35 <int-e> Bj0rnen: hmm, looking at https://hackage.haskell.org/package/gpx-conduit-0.1.1 that package requires conduit-0.5.*, while your error suggests that some conduit>=1.1 is used.
12:04:25 <int-e> Bj0rnen: I imagine that the former is too strict, but nix apparently relaxes these dependencies...
12:05:10 <maerwald> int-e: you mean nix messes with the dependencies defined in the cabal file?
12:05:54 <int-e> maerwald: I don't know; my suspicion is that they use cabal install --allow-newer
12:06:00 <edwardk> johnw: (continuous/terminating) Hyperfunctions from Bool to Bool are isomorphic to the natural numbers. https://github.com/ekmett/hyperfunctions/blob/master/examples/Cantor.hs#L33
12:06:16 <maerwald> int-e: oh, didn't even know about that switch... sounds dangerous
12:11:33 <int-e> maerwald: hmm, or perhaps this: https://hackage.haskell.org/package/jailbreak-cabal
12:12:00 <maerwald> int-e: sounds even more dangerous :P
12:12:22 <maerwald> but nix surely does lack consistency and QA policies
12:12:55 <maerwald> but that's what you get with distributed packaging
12:13:48 <int-e> (I found the command in http://hydra.cryp.to/build/793293/nixlog/1/raw ... I got this with a bug report against QuickCheck-safe, which required >=QuickCheck-2.8 at the time...)
12:20:22 <sammecs> Hi! So I've done some things wrong during my installation of the haskell ecosystem - deleted wrong files etc. But now I think I nuked everything and installed the debian packages.
12:20:39 <sammecs> However, If I try to install something using cabal-install, I get the following message:
12:20:47 <S11001001> maerwald: gonna say, none that I know of, and more than I'd expect
12:20:55 <sammecs> error: ‘RtsConfig’ has no member named ‘rts_hs_main’
12:21:17 <sammecs> (and this happens in really ALL of the packages I want to install)
12:21:34 <maerwald> S11001001: sufficed to say, I've never seen it in real-world code :P
12:22:58 <maerwald> S11001001: it would be a huge step forward if people made more use of "const", but even that you see rarely
12:23:33 <S11001001> maerwald: it might be more common among glib users, as that provides portable macros for all the gcc attribs
12:23:50 <S11001001> s/all/some of/
12:24:44 <kadoban> sammecs: Nuke it all again, make sure there's no cabal or GHC or anything left (delete ~/.ghc and ~/.cabal, possibly saving ~/.cabal/config) and make sure 'which cabal' and 'which ghc' aren't there, then do: https://gist.github.com/ion1/2815423 when you're all set up, use cabal sandboxes for /everything/, optionally you can use stackage as well.
12:24:52 <maerwald> S11001001: do you know if that attribute triggers different compiler optimizations?
12:26:07 <sammecs> kadoban: I'll try it, thanks for your help! :)
12:28:23 <S11001001> maerwald: I don't.
12:30:03 <maerwald> S11001001: because I think that would be the only good argument to make C programmers use it ;)
12:37:50 <albeit> If I have an Integer, what is the most performant way to multiply it by 10^x, and having it remain an Integer (truncation is fine)?
12:38:54 <ion> Do you have a performance problem with n*10^x?
12:39:08 <maerwald> @src (^)
12:39:08 <lambdabot> x ^ 0            =  1
12:39:08 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
12:39:08 <lambdabot>   where f _ 0 y = y
12:39:08 <lambdabot>         f x n y = g x n
12:39:08 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
12:39:08 <kadoban> albeit: Just do it? blah * (10^x)
12:39:10 <lambdabot>                       | otherwise = f x (n-1) (x*y)
12:39:12 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
12:39:26 <S11001001> maerwald: I mean, I would be surprised if gcc didn't do anything with the attribs.  I'm not sure whether it cares about the difference between const and pure though.
12:40:05 <albeit> ion, kadoban: I'd prefer something working on Integral instead of Num... like div but "mul"
12:40:29 <albeit> I guess I could just do div 10^(-x)
12:40:59 <kadoban> albeit: Naw, ^ is positive exponents I believe. And ... why do you want it Integral? I don't understand.
12:41:49 <albeit> kadoban: Because I'd assume doing it over Integral is faster than doing it over potentially floating point numbers... as div is faster than (/)
12:42:24 <ion> When you specify :: Integer, multiplication will use Integer operations.
12:43:49 <albeit> ion: Perfect! thanks
12:46:13 <ion> If you look at the source in Prelude, it's instance  Num Integer  where (*) = timesInteger, where timesInteger is a primitive from integer-gmp.
12:46:31 <sammecs> kadoban: Suprisngly, that totally worked for me! Thank you soo much!
12:46:48 <kadoban> sammecs: Nice :)
12:47:11 <quchen> albeit: And often quot is faster than div! :-)
12:47:38 <paul_erdos> Hey look, It's me!
12:58:19 <maerwald> paul_erdos: awesome!
12:58:39 <mada> paul_erdos: oh wow!
12:58:42 <paul_erdos> maerwald: hi!
12:59:11 <paul_erdos> mada hi!
12:59:17 <maerwald> still can't believe it
12:59:21 <paul_erdos> I am pretty interesting, no?
13:00:17 <paul_erdos> PGOMLDADLDCD
13:00:34 <paul_erdos> Poor great old man, living dead, legally dead, counts dead
13:04:21 <ttt_fff> in continuous time frp, we have "Behavior a = Time -> a" ... in disrete time frp, how do we define Behaviour ?
13:10:06 <Peaker> is there a "formal"/type-theoretic name for the notion of lifting a value into a sum type (in structural type systems)?  i.e:  Just a -> (Just a | alts) ?
13:12:33 <quchen> I've heard them called injectors in the context of coproducts.
13:13:13 * hackagebot misfortune 0.1.1.2 - fortune-mod clone  http://hackage.haskell.org/package/misfortune-0.1.1.2 (JamesCook)
13:13:17 <quchen> But "injecting into coproduct" won't make a good formal name I guess.
13:14:46 <albeit> Are there any data structures (not in IO/ST) that allow updating an index in O(1)?
13:14:57 <quchen> Identity
13:15:04 <quchen> Tuples
13:15:32 <Peaker> quchen: cool, I independently came up with the name "inject" :-)
13:15:43 <Peaker> quchen: so "inject" it is
13:15:50 <Peaker> (finally adding sum types to Lamdu)
13:16:07 <hsk5> Is there any good reason to prefer Int over something more explicit like Int64?
13:16:20 <hsk5> (Assuming I'm only interested in developing for 64-bit archs)
13:16:21 <Peaker> hsk5: lots of standard APIs are hard-coded to use Int
13:16:27 <quchen> Peaker: Awodey calls them "coproduct injections" if you want something more official.
13:16:31 <merijn> hsk5: Same reason to prefer int over int64_t in C
13:16:36 <quchen> Page 72.
13:16:43 <hpc> suppose suddenly a 128-bit arch comes out
13:16:46 <quchen> Of the book, not the random page numbering, that is.
13:17:02 <hpc> that's where fun stuff like system32 comes from
13:17:07 <Peaker> in C it's a less compelling reason, since you can use int64_t/uint64_t and coercion will make it work (if you have -Wconversion -Werror it is safe)
13:17:41 <paul_erdos> cleanliness, also
13:17:41 <Peaker> hpc: given that 64-bit left ints 32-bit on most archs, I am not sure 128-bit archs would change "int" :)
13:17:56 <Peaker> in C, we ban use of "int", "long", etc, and just use sized ints, always
13:18:07 <merijn> Peaker: int is 64bit on many platforms
13:18:09 <hpc> Int is different
13:18:13 * hackagebot x509 1.6.0 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.6.0 (VincentHanquez)
13:18:15 * hackagebot x509-store 1.6.0 - X.509 collection accessing and storing methods  http://hackage.haskell.org/package/x509-store-1.6.0 (VincentHanquez)
13:18:17 * hackagebot x509-system 1.6.0 - Handle per-operating-system X.509 accessors and storage  http://hackage.haskell.org/package/x509-system-1.6.0 (VincentHanquez)
13:18:48 <Peaker> merijn: Usually it is important what range of values is possible for a type, so I hate "int"
13:19:29 <hsk5> To make sure I'm running on at least 64-bit machine, should I just do a runtime check of Int.maxBound ?
13:19:45 <quchen> Peaker: type Bool = Int :-D
13:20:15 <merijn> hsk5: That doesn't work if you use 32bit GHC on a 64bit machine :p
13:20:32 <hsk5> ok..
13:20:43 <hsk5> heh
13:20:49 <quchen> Wasn't there a part of GHC that relied on some n-tuple of Ints that had the invariant of them being all 0 or 1?
13:20:55 <quchen> Someone mentioned that.
13:23:14 * hackagebot property-list 0.1.0.5 - Apple property list parser  http://hackage.haskell.org/package/property-list-0.1.0.5 (JamesCook)
13:23:16 * hackagebot x509-validation 1.6.0 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.6.0 (VincentHanquez)
13:25:29 <DNoved1> quchen, there's something called fastBool in ghc which is an unboxed int of either 0# or 1#, though I don't know where it is used.
13:25:40 <albeit> What data structure should I use if I want to perform efficient inserts and changes? Insert, like f 1 5 [1,2,3] = [1,5,2,3]
13:26:01 <quchen> albeit: Set if you don't require ordering
13:26:07 <quchen> Specific ordering, that is
13:28:31 <albeit> Hmm I required ordering, but IntMap may work then. If I wanted to restrict an IntMap to a certain size, is there a way to do that? Or would I have to manually remove the largest/smallest elments when it gets above a certain size?
13:29:13 <quchen> Do you need to do insertions in arbitrary locations? Seq is nice for building queues, for example
13:29:36 <DanielDiaz_> if I have two remote-repos, and there is a package in one repo with the same name as other in the other repo... what would cabal install do?
13:30:25 <albeit> quechen: Yes... I have data like (50, 1) (51, 5), (54, 3), that needs to be ordered by fst. And then I may insert a pair with (53, _), and if the bound size is 3 it should remove (54, 3)
13:30:46 <Welkin> how can I convert Html to Text?
13:30:53 <paul_erdos> markdown
13:30:54 <paul_erdos> (=
13:30:55 <Welkin> Show isn't even defined on it
13:30:58 <Welkin> well, no
13:31:06 <Welkin> I mean inside of my yesod application
13:31:37 <Welkin> I store Html in the database, and blaze converts it to text somehow when it shows it in the edit form I built
13:31:48 <Welkin> now I want to bundle it up as Json
13:31:54 <quchen> albeit: Map has a couple of insertion functions.
13:31:55 <Welkin> but there is no toJSON instance for Html
13:31:56 <DanielDiaz_> Welkin: http://hackage.haskell.org/package/blaze-html-0.8.0.2/docs/Text-Blaze-Html-Renderer-Text.html
13:31:59 <quchen> :t M.insertWith
13:32:00 <lambdabot> Ord k => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
13:32:13 <quchen> If keys clash, use the function to combine them
13:32:31 <Welkin> DanielDiaz_: thank you, renderHtml is what I was looking for
13:32:39 <DanielDiaz_> Welkin: you are welcome
13:32:53 <pingw> I've been profiling the mongoDB package, and apparently 60% of the time is being spent in Database.MongoDB.Internal.Connection.fromHandle, which doesn't seem to do anything
13:33:14 * hackagebot monad-loops 0.4.3 - Monadic loops  http://hackage.haskell.org/package/monad-loops-0.4.3 (JamesCook)
13:33:16 <pingw> Other than put some functions into a constructor and return it
13:33:16 * hackagebot tls 1.3.0 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.3.0 (VincentHanquez)
13:33:18 * hackagebot tls-debug 0.4.0 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.4.0 (VincentHanquez)
13:33:20 * hackagebot connection 0.2.5 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.2.5 (VincentHanquez)
13:34:18 <Welkin> pingw: why use mongodb? There are many other better options
13:35:29 <c_wraith> pingw: that's because the profiling version of the mongodb library didn't create cost centers for each of the functions
13:35:49 <albeit> quchen: Ohhh it has deleteMax/deleteMin, which is perfect for bounding
13:36:10 <quchen> There are lots of pearls in the Containers API :-)
13:36:14 <c_wraith> pingw: so all the runtime being used by those functions is being credited to the top-level thing that creates the record of functions
13:37:07 <c_wraith> pingw: if you want to diagnose further, you'll have to start messing with how the mongodb library is compiled.  A simple starting point is adding -auto-all to the profiling options it uses
13:47:22 <nkar```> has anyone (not counting edsko) tried writing atom plugins in haskell?
14:12:30 <albeit> Data.Map.insert is O(log(n)) and Data.IntMap.insert is O(min(n,k))... is it accurate to say that Data.Map.insert is faster as long as log(n)<k?
14:13:26 <quchen> Complexity is not a measure of program speed.
14:13:59 <quchen> Profiling on the other hand is a good measure.
14:14:09 <hpc> also O() is asymptotic
14:14:33 <hpc> so saying log(n)<k is misleading and it's more that log(n) grows slower than k
14:15:31 <Zemyla> albeit: You have to look at constant factors, too.
14:16:49 <v0|d> quchen: elaborate ?
14:18:13 <quchen> Quicksort is O(n!) best case, approximately solving many NP-complete problems can be done fairly well in polynomial time because the worst case is rare, cracking AES-256 is O(1), walking through a list of Graham's number entries is O(1).
14:19:59 <quchen> Asymptotics mean something very specific for a certain range of inputs, and absolutely nothing otherwise.
14:20:27 <koala_man> what makes Quicksort O(n!)?
14:20:33 <v0|d> quchen: you mean inputs that converge?
14:20:42 <paul_erdos> extremely silly datasets
14:20:51 <quchen> paul_erdos: No.
14:21:21 <quchen> koala_man: O(f(n)) is an upper bound. Quicksort is bounded from above asymptotically by n!, which is much larger than for example e^n.
14:21:22 <v0|d> paul_erdos: whats the score of the supreme fascist 2day?
14:21:29 <quchen> Quicksort is also O(e^n), for that matter.
14:21:35 <quchen> ?where ops
14:21:35 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
14:21:35 <paul_erdos> v0|d: Still haven
14:21:42 <paul_erdos> v0|d: Still haven't gotten a point
14:21:54 <koala_man> quchen: oic. good point.
14:21:56 <v0|d> paul_erdos: good, keep it that way.
14:22:08 <shachaf> quchen: ?
14:22:13 <mauke> quchen: ?
14:22:35 <quchen> Got a bit trigger happy when some "supreme fascist" was mentioned, apologies.
14:22:37 <glguy> quchen: ?
14:22:37 <bitemyapp> quchen: ?
14:22:45 <koala_man> it's been so long since I've heard anyone talk about big-Omega
14:22:46 <c_wraith> jaspervdj: I'm using your psqueues package, and I'm a bit confused why there are so many (Hashable k, Ord k) constraints in Data.HashPSQ
14:22:48 <quchen> I didn't expect anything good to come after that. :-)
14:22:49 <mauke> lern2erdős
14:23:15 <paul_erdos> mauke: and for those using ASCII?
14:23:20 <quchen> koala_man: Quite a few Haskell libs have ϑ in their docs.
14:23:29 <quchen> Haven't seen Ω yet.
14:23:32 <mauke> paul_erdos: lern2unicode
14:23:46 <paul_erdos> phonetically, erdish
14:23:52 <paul_erdos> but that looks silly
14:24:04 <v0|d> i want to give an example.
14:24:10 <mauke> I don't think it sounds like "dish"
14:24:18 <v0|d> whats the complexity of f(x) = 1/(1-x)?
14:24:32 <v0|d> if x \neq 1 than its polynomial.
14:24:49 <v0|d> if x = 1 than its asymptotic.
14:25:00 <c_wraith> asymptotic to what?
14:25:02 <quchen> It's O(2).
14:25:24 <v0|d> c_wraith: f(x) = 1/(1-x) = 1+x+x2+x3+..
14:25:38 <v0|d> like taylor series.
14:25:47 <c_wraith> v0|d: my main point is that "asymptotic" isn't a complexity class
14:26:03 <c_wraith> v0|d: all complexity classes describe asymptotic behavior
14:26:26 <paul_erdos> moreover, constants aren't important
14:26:28 <quchen> Oh, I missed the "-" sign.
14:26:39 <paul_erdos> O(2) is O(1)
14:26:50 <paul_erdos> if I recall properly
14:26:54 <merijn> asymptotic just means "always faster at sufficiently large inputs"
14:26:54 <quchen> Yes.
14:27:08 <paul_erdos> quchen: yes?
14:27:18 <quchen> O(2) is the same as O(1), yes.
14:27:19 <paul_erdos> k
14:27:27 <paul_erdos> reassuring
14:27:28 <quchen> Or any other O(constant), for that matter.
14:27:31 <paul_erdos> mmhmm
14:27:39 <quchen> Well, O(0) maybe not.
14:27:42 <maerwald> an introduction on big O notation? :)
14:27:46 <v0|d> those bigO asympototes does not talk about domain's topology.
14:27:50 <paul_erdos> quantum bogosort is O(0)
14:27:57 <v0|d> its silly they always assume we are on a sphere.
14:28:17 <v0|d> what happens when there is pole? you can never reach your goal in finite time/effort.
14:28:56 <lyonsb> yes, but how do you get enough -E to destroy all the univers-- nevermind, i can't have this discussion atm.
14:29:09 <paul_erdos> lyonsb: (=
14:29:18 <quchen> Asymptotics aren't concerned about poles. You don't walk from 0 to infinity to find the asymptotics.
14:29:46 <quchen> log(n) has a pole at 0 (and a nasty one at that), and it's still O(log(n)).
14:30:35 <fvgvxmpv1> maerwald, the wikipedia article is excellent: https://en.wikipedia.org/wiki/Big_O_notation
14:30:48 <c_wraith> Yeah, O() notation has lots of details that sidestep issues like that cleanly.
14:30:57 <skeet70> Just check in on how #haskell is doing, they said. I'm sure it won't be over your head, they said.
14:31:07 <maerwald> fvgvxmpv1: I avoid wikipedia for such in-depth topics
14:31:19 <paul_erdos> Oh, guys, it's not that bad!
14:31:30 <paul_erdos> (says paul erdos lol)
14:31:44 <quchen> f(n) ∈ O(g(n)) means that there is an N so that for all n>N, f(n)<g(n). That N may be arbitrarily large, in particular much larger than anything practically relevant (lifetime of the universe times ten, for example.)
14:32:00 <paul_erdos> quchen: yeah, if you wanna be really dry and abstract
14:32:12 <skeet70> I'm kidding, BigO isn't. Was more in reference to the poles comment.
14:32:16 <c_wraith> also, unambiguous and exact.  :)
14:32:24 <shachaf> Another thing you can say is O(f) ⊆ O(g)
14:32:25 <quchen> "Not wrong" describes it better
14:32:26 <paul_erdos> c_wraith: mmhmm
14:33:03 <v0|d> quchen: so f & g are maps from N -> R?
14:33:13 <paul_erdos> no?
14:33:41 <quchen> For example, yes.
14:33:48 <paul_erdos> they can map to whatever they want, afaik
14:33:51 <v0|d> why we say BigO is notation but not BigO function?
14:34:01 <v0|d> isn't it well defined?
14:34:02 <Welkin> Big O is a robot
14:34:14 <Welkin> and an anime series
14:34:20 <c_wraith> It's not a function because there are multiple correct outputs for any input.
14:34:27 <v0|d> Welkin: see random oracle.
14:34:39 <paul_erdos> well
14:34:45 <paul_erdos> not injective, certainly
14:34:56 <c_wraith> f(n) = 0  f(x) is O(1), O(log n), O(n), etc.
14:35:14 <c_wraith> you *could* call it a function where every input has an infinitely large output
14:35:16 <paul_erdos> all inputs of a similar asymptotic behaviour map to the same O(n)
14:35:25 <c_wraith> But that's not all that useful.
14:35:40 <v0|d> so its a relation?
14:35:45 <c_wraith> yes
14:35:50 <c_wraith> It is definitely a relation
14:35:55 <v0|d> but not an equivalence rel?
14:35:59 <paul_erdos> mmhmm
14:36:02 <c_wraith> No.  It's not symmetric
14:36:07 <paul_erdos> it's not symmetric
14:36:08 <paul_erdos> mmhmm
14:36:09 <v0|d> other we can take the quotient and make it a function.
14:36:56 <paul_erdos> idk how transitive would even work with it
14:37:06 <paul_erdos> oh, nvm
14:37:20 <v0|d> paul_erdos: not that hard i guess.
14:37:33 <paul_erdos> it's trivial, i'm just braindead
14:37:40 <v0|d> f(n) \in g(n) , g(n) \in h(n) \implies f(n) \in h(n)
14:39:05 <quchen> Some Os on the RHS of the ∈ missing there, but other than that yes.
14:39:32 <v0|d> quchen: right sorry about that.
14:39:42 <v0|d> any help in getting latex on my erc?
14:40:03 <quchen> I handcoded lots of symbols in manually (XChat has a replacement file).
14:40:07 <paul_erdos> not LaTeX, right?
14:40:08 <paul_erdos> yeah
14:40:21 <quchen> Not particularly pretty, but gets the job done sufficiently well. LaTeχ :-)
14:40:22 <v0|d> quchen: i see, thnx anyway.
14:40:51 <paul_erdos> quchen: wait, not just binding unicode stuff, actual LaTeX?
14:41:03 <quchen> Unicode replacements with LaTeχ syntax.
14:41:06 <paul_erdos> right
14:41:14 <quchen> \in gets me ∈.
14:41:17 <v0|d> quchen: i see your symbols well.
14:41:27 <v0|d> quchen: i guess i need input translator.
14:41:29 <paul_erdos> I aught to do that, that's as the kids say, "totally dope"
14:41:50 <albeit> If I need to keep track of a structure with at most 10 elements of form (key, value), and I perform update / insert / delete, is mangling lists likely going to be faster than Map/IntMap for such small number of items?
14:42:15 <albeit> (And the items have to be sorted by key)
14:42:40 <quchen> albeit: Are you sure it matters?
14:42:57 <v0|d> http://www.emacswiki.org/emacs/ErcTex
14:43:15 <quchen> albeit: Data sets of size 10 aren't bottlenecks very often.
14:43:53 <paul_erdos> quchen: *ever
14:43:53 <paul_erdos> or, shouldn't be
14:44:07 <albeit> quchen: It is for me... doing up to tens of thousands of updates/insertions/deletions a second
14:44:27 <albeit> At any/every point in the "list"
14:44:29 <paul_erdos> idk how much time that will save
14:44:30 <v0|d> $O(f(n)) \in O(g(n))$
14:44:56 <albeit> paul_erdos: What do you mean?
14:44:57 <v0|d> its working nicely when i do $ .. $ but not sure how ppl see it.
14:45:32 <quchen> Hm, that might qualify for a potential bottleneck then. My new answer is "profile it" :-) But in general the Containers lib performs fairly well
14:45:37 <paul_erdos> albeit: actually, I guess I'm not sure what you mean by mangling
14:45:37 <pavonia> v0|d: I see LaTeX code
14:46:09 <albeit> paul_erdos: Like... to insert do something like "take 5 foo ++ [newVal] ++ drop 5 foo"
14:46:17 <v0|d> pavonia: oh ok, thnx. i see images rendered by latex+dvipng
14:46:32 <paul_erdos> oh, uh huh
14:46:37 <paul_erdos> hmm
14:47:39 <albeit> quchen: Been trying to avoid that, but gotta do it sometime. Guess I'll compare List/Map/IntMap
14:48:11 <quchen> Also try 10-tuples while you're at it.
14:49:59 <albeit> Ah good idea
14:52:14 <merijn> albeit: Also try this gist (plus some modification to make it update instead of drop) to see how that performs https://gist.github.com/merijn/3f9ce423edadf1622823
14:52:24 <albeit> Wow actually tuples are probably going to be the best. If I don't do any listy things like map/fold, is f [a,b,c,d,e] basically the same as f (a,b,c,d,e)?
14:52:54 <merijn> albeit: Basically the same in what way? Almost certainly not, tbh
14:52:55 <albeit> merijn: Shall do, thanks!
14:53:28 <albeit> I guess, is deconstructing and then reconstructing lists and tuples approximately the same cost?
14:53:48 <merijn> albeit: a tuple only has one indirection, list has one per list item
14:54:06 <paul_erdos> does haskell do anything special / faster for homogenized lists?
14:54:28 <merijn> paul_erdos: What's a homogenized list?
14:54:38 <albeit> Ah so reconstructing a tuple has to basically recreate the entire tuple, while for a list most of it will just point to the old list? Is that what you mean by indirection?
14:54:55 <merijn> albeit: a list is a linked list, a tuple is a struct
14:55:04 <paul_erdos> merijn: A list with only one type of element. It might not be a thing in Haskell
14:55:31 <merijn> paul_erdos: all lists have only one type of element in haskell...
14:55:50 <Phyx-> that's. not strictly true is it?
14:55:59 <paul_erdos> I'm not sure about that
14:56:07 <merijn> Phyx-: Eh, in what way is it not?
14:56:08 <Phyx-> can't you have lists with rank 2 type elements? like in the HList package?
14:56:15 <merijn> HList is not list
14:56:19 <mauke> HList is just tuples
14:56:43 <merijn> That's like saying a statement about Maybe is wrong because Either exists
14:57:12 <Phyx-> I'll rephrase. given you define your own list structure. you can define a list which takes elements of different type. where list is something with a cons and nil 
14:57:47 <merijn> If you define your terms to mean something else from what everyone else in the community means, then you can make arbitrary statements true, yes
14:58:02 <Phyx-> ok
14:59:28 <Phyx-> sorry to have asked, continue :)
15:00:28 <f-a> https://wiki.haskell.org/Foldable_Traversable_In_Prelude#Now_I.27m_getting_unused_import_warnings._Help.3F <-- this suggests sticking `import Prelude` at the bottom of your import lists to get rid of pesky warnings in 7.10 while keeping compatibility with older versions. It works, but I still don't get why it works.
15:00:44 <f-a> wouldn't import Control.Applicative (<*>) still be redundant?
15:01:19 <albeit> merijn: In your dropAt, why do you have f / id as the first parameter to go?
15:01:20 <merijn> f-a: I believe GHC 1) checks imports for redundancy in order and 2) considers the last import if a module is imported twice
15:01:58 <albeit> merijn: Nevermind!
15:02:00 <f-a> merijn: thanks
15:02:02 <merijn> albeit: Because you don't want to build a list and then append the new list using (++) (uselessly building the list and traversing it), so you use a DList (CPS list construction)
15:02:20 <merijn> albeit: see http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
15:02:26 <merijn> albeit: And then id is just the base case :)
15:02:40 <merijn> f-a: So basically you're abusing an implementation detail of GHC to silence the issue :)
15:03:19 <f-a> still more clean than cpp I guess, merijn ;)
15:04:33 <Welkin> (++) is the sae as (:) if you are appending a single elemtn list to a larger list
15:04:36 <Welkin> same*
15:04:39 <Welkin> same complexity, at least
15:04:55 <merijn> Welkin: : doesn't append...
15:04:59 <merijn> It prepends
15:05:01 <f|`-`|f> DList?
15:05:01 <Welkin> yes
15:05:26 <Welkin> [1] ++ [2,3,4] is the same complexity as 1:[2,3,4]
15:05:27 <merijn> f|`-`|f: DList was our starting point :)
15:06:10 <f|`-`|f> So apparently it has a better append/prepend?
15:06:17 <merijn> Welkin: "[1,2,3,4] ++ [6,7,8,9]" isn't the same as DList append 1,2,3 and 4 and then passing in [6,7,8,9], so I'm not sure about the point...
15:06:26 <merijn> f|`-`|f: See the link I linked to albeit a few lines up
15:06:51 <Welkin> merijn: it was just a side comment
15:07:51 <albeit> merijn: Would using the DList package be equivalent to your dropAt?
15:09:16 <merijn> albeit: You could, but I wrote it to illustrate some neat tricks for doing efficient list operations
15:09:41 <merijn> I mean, manually doing DList isn't that much work...
15:12:51 <Peaker> I have a type system with "extensible records" kinda like:  data Record = Empty | Extend FieldName Type Record | Var Name
15:13:11 <Peaker> I want to add similarly "extensible sums", as coproducts (symmetrical construction)
15:16:14 <lpaste> rofer pasted “No title” at http://lpaste.net/134827
15:16:21 <Peaker> the above is more the RecordType.   There's also the record val:  data RecordVal = Empty | Extend FieldName Val Val
15:16:41 <Peaker> and there's a  GetField FieldName Val, of course
15:16:59 <rofer> Can someone help me with an error I'm seeing? I keep getting "Could not deduce (Read (LowBound a)) arising from a use of ‘parseRepeatable’..."
15:17:46 <rofer> I'm not quite sure what's going on. It looks like it wants to find an instance of Read for (LowBound a) when I just want to say that 'a' should have an instance of it
15:17:57 <Peaker> now I'm wondering how to construct the dual of this.   The dual of GetField is   SumVal = Inject FieldName Val  (inject Val into an "open" sum as the named data constructor)
15:18:42 <Peaker> the dual of the record type is:  data SumType = Empty | Extend FieldName Type SumType | Var Name  (i.e: exactly the same as the record type)
15:19:31 <Peaker> now the dual of the empty record val is the empty case analysis, I believe:  Absurd
15:20:00 <Peaker> EmptyRecord : 1 -> {}    Absurd : [] -> 0     <-- do these look like duals?
15:20:45 <Peaker> And I'm having trouble figuring out how the single-case analysis extension is a dual of the RecExtend value.. I can't make it elegantly symmetric :(
15:20:47 <Peaker> (like the others)
15:22:26 <Peaker> it seems like the singular case has to be CPS, take the "handler", "rest of handlers" and sum type, and return the reduced result.  not symmetric to anything
15:23:25 <DNoved1> The singular coproduct is the same as the singular product, isn't it?
15:25:05 <DNoved1> That is, in lisp notation (+ x) (* x))
15:25:18 <DNoved1> Are the same value.
15:25:38 <Peaker> you mean   data Foo = Foo a (is both the singular sum and singular product) ?
15:26:12 <DNoved1> In haskell, yes, I believe so.
15:26:31 <Peaker> Well, the duality I have here is not between  record intro <-> sum type intro,   record elimination <-> sum type elimination
15:26:47 <Peaker> but the opposite:  record eliminate(get field) <-> sum type intro(inject)
15:27:10 <Peaker> record intro(extend an extra field) <-> sum type elimination(case a single constructor out of the sum type)
15:28:08 <Peaker> I want the sum types to be reducible, in the same sense that the records are extensible.  I can take a record and add a single field.  I want to be able to take a sum and "subtract" a single option  (like:  case foo of A x -> ... ; other -> ... other has a refined type here! ... )
15:28:41 <DNoved1> Makes sense.
15:29:11 <DNoved1> I believe eff, the effect handling library does something like that for, well, effect handlers.
15:30:02 <DNoved1> At least I think it was called eff...
15:30:05 <Peaker> so a reducer needs to take a handler to handle the reduced case, and a handler to take the rest of the sum type (CPS)
15:30:45 <Peaker> making it very assymmetric to RecExtend which just takes a value to add and a value for the rest of the record
15:31:07 <Peaker> so record extend's values become handlers in the reduction, I wonder if that's part of the duality, or an artifact
15:33:15 <DNoved1> That seems like it may be right, considering non-extensible products have a similar duality in the intro/elim; product intro takes a number of values and elim produces one, sum intro takes one value and elim takes a number of values and selects one.
15:33:40 <DNoved1> This is the thing I was talking about when I mentioned eff by the way, turns out it is not eff: http://okmij.org/ftp/Haskell/extensible/
15:34:07 <DNoved1> Under open unions, it talks about what you were saying with 'refining' the sum type by providing a handler for one of the cases.
15:37:54 <rofer> Oh, found my problem
15:38:03 <Peaker> DNoved1: http://lpaste.net/134830 <-- I think this works
15:38:58 <Peaker> if it ain't beautiful it ain't right! :-)
15:42:01 <DNoved1> I'm guessing the rest type is inferred in the inject function?
15:43:14 <DNoved1> Speaking of which, that's another dual between products and coproducts, type inference is super easy for products and way hard for sums ;)
15:43:24 <DNoved1> Maybe...
15:44:09 <Peaker> DNoved1: the "rest" type can remain "open" 
15:44:56 <Peaker> DNoved1: i.e: could be unified with no-other-options, or with any other set of options, but is monomorphic, not polymorphic
15:46:07 <Peaker> DNoved1: so if you unify:  Inject "Nothing" ()   and   Inject "Just" 5        you get  (Nothing() + Just Int + rest)  
15:46:27 <Peaker> DNoved1: you could force rest=Void to get a Maybe type
15:50:02 <DNoved1> So inject can return different types for the same value depending on context then, right?
15:51:40 <DNoved1> That's what I meant by the 'rest' type being inferred, if so.
15:51:42 <Peaker> DNoved1: Inject is polymorphic yeah, but once instantiated it becomes monomorphic (with a tv)
15:51:58 <Peaker> i.e:  Inject generates a fresh TV each time
15:52:09 <Peaker> (but the TV is standard rank1 HM/mono-TV)
15:52:21 <DNoved1> Gotcha.
15:53:24 <DNoved1> Seems like a workable system, I would be glad to have something like extensible products/sums in haskell from time to time, especially when working with AST transformations. I assume this is for a language in design of yours?
15:55:14 <Peaker> DNoved1: it's for Lamdu
15:55:25 <Peaker> DNoved1: which currently has extensible records but no sums
15:56:02 <Peaker> Lamdu is a "new programming experience" more than a new language :)
15:56:27 <Peaker> DNoved1: if you're interested, this is a short Lamdu demo gif: http://peaker.github.io/lamdu/fac.gif
15:58:29 <DNoved1> Ah yes, I was reading the page just now, I've actually seen it someplace before and thought it looked quite neat, but wasn't aware of much else.
15:59:22 <Peaker> well, thanks for help in fleshing out ideas, good night!
16:00:50 <L8D> how do I get cabal to install a package and write an entry in my cabal file?
16:02:33 <DNoved1> Peaker: o/
16:06:05 <DNoved1> L8D, I usually just add it to the .cabal file manually and then run 'cabal install --dependencies-only'
16:06:26 <DNoved1> If you're talking about a local package, that is.
16:14:47 <Sindri> Hi! Could someone help me with my State monad adventures? :)
16:14:48 <augur> i think i just discovered some kind of super-weird pattern-matching .. thing ..
16:15:13 <augur> Sindri: sure!
16:15:14 <augur> whats up
16:15:37 <augur> actually Sindri, i have to head out :(
16:15:46 <Sindri> Aw :(
16:15:54 <Sindri> At least share the pattern matching thing! :)
16:16:10 <Cale> Sindri: I can help with the State monad if you like.
16:16:12 <augur> ill be back probably within 2 hours tho, so if you havent gotten your answer then, be sure to ping me :)
16:16:20 <Sindri> Cale: Great!
16:16:26 <Sindri> I have the following code: http://lpaste.net/7609236203606376448
16:16:48 <Sindri> Basically, it's a sketch of an ECS I'm trying to make for a game of mine
16:17:31 <Sindri> I want `createEntity` to be a stateful computation on World, in that it gets an ID from the world counter to assure the uniqueness of the ID
16:17:51 <Sindri> and I want `color` to somehow know the ID when it's passed in a block to `createEntity`
16:18:09 <Sindri> and `color` also needs to know about the World, since it inserts components into it
16:18:46 <Cale> It's a bit unusual to be using the 'state' function this much -- to some extent it defeats the purpose of using the State monad in the first place
16:19:32 <Cale> actually...
16:20:07 <Cale> Which monad is the do-block inside createEntity meant to be?
16:20:20 <Sindri> Cale: State (Int, World) ()
16:20:33 <Cale> Its type is just (Int, World)
16:20:41 <Cale> So it would be (,) Int
16:20:45 <Sindri> Ah
16:20:49 <Sindri> I'm more than open to suggestions, I'm new to haskell and I'm still not used to it a lot
16:21:06 <Cale> Okay, so I think you didn't want to use the state function there
16:21:31 <Sindri> Cale: I'll write up a sample of how I want the code to be used and then we could discuss how to make that happen? It would probably be easier to see what I'm after :)
16:21:36 <Cale> Yeah, sure
16:23:19 <Sindri> Cale: Here: http://lpaste.net/726331531563368448
16:23:45 <Sindri> Cale: Basically I want to give a context (the new entity ID and the world) to the block given to createEntity
16:25:39 <Cale> right, okay, I think I see what you're getting at
16:26:25 <Sindri> Basically, I'm trying to streamline the game code as much as possible, so I can focus on the mechanics in the future, instead of boilerplate
16:27:25 <Cale> Okay, so first, let's write something which gets a fresh id, just to isolate that bit of boilerplate:
16:27:39 <Sindri> Ok, let me write it up
16:28:05 <Cale> fresh = do w <- get; put (w { idCounter = idCounter w + 1 }); return (idCounter w)
16:28:13 <Cale> Something like that
16:28:27 <Cale> fresh :: State World Int
16:28:30 <Cale> Now...
16:29:48 <Sindri> Here goes http://lpaste.net/2008068210707922944
16:29:58 <Sindri> oh wait, get and put
16:30:10 <Cale> Yeah, don't use the state function
16:30:17 <Sindri> I see, gimme a sec
16:30:28 <Cale> If you're just going to use the state function everywhere, you might as well not use the State monad at all
16:30:40 <Cale> Because you're just writing all the parameter passing by hand then anyway :)
16:30:56 <Sindri> I see
16:31:29 <Cale> The point is to clean up code which involves a lot of things like  World -> (World, Int)
16:32:03 <Sindri> Like this? http://lpaste.net/6190359702577086464
16:32:25 <Cale> Yeah, that works
16:32:42 <Cale> So, now, createEntity
16:33:41 <Sindri> That should be a stateful computation in itself, right?
16:34:25 <Cale> Yep
16:35:24 <Sindri> So… `State (Int, World) ()` ?
16:35:32 <Cale> Perhaps... createEntity x = do n <- fresh; w <- get; let { ((w',n'),r) = runState x (w,n) }; put w'; return r
16:35:45 <Cale> Note that we're discarding n' here
16:36:32 <Sindri> Isn't n' the new world create by the block?
16:36:48 <Cale> Ah, you wanted the other convention
16:36:58 <Cale> Perhaps... createEntity x = do n <- fresh; w <- get; let { ((n',w'),r) = runState x (n,w) }; put w'; return r
16:37:10 <Cale> So now it's (Int, World)
16:37:21 <Cale> It's a little bit of imprecision in the type of createEntity that we probably don't really intend for the new ID to be an adjustable part of the state, but really as an immutable parameter
16:37:40 <Sindri> Yeah
16:37:50 <karshan> Hello, I'm new to using Data.Data and Data.Typeable, is it possible to write a function cast' :: (Typeable a, Typeable b, ArbitraryConstraint b) => a -> Maybe b ?
16:37:56 <Sindri> Is there a monad for that, or do I just make it into a lambda?
16:39:05 <mniip> karshan, why would you want that
16:40:06 <mniip> :t cast -- there's this
16:40:06 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
16:40:08 <Cale> If you wanted to get fancy, you could define a new monad like  newtype CreateEntity a = CE { runCreateEntity :: ReaderT EntityId (State World Int) a } deriving (Monad), and do a bunch of setup to get the basic operations you want (esp. manipulating just the part of the world referred to by the EntityId)
16:40:22 <Cale> er, oops
16:40:33 <Cale> newtype CreateEntity a = CE { runCreateEntity :: ReaderT EntityId (State World) a } deriving (Monad)
16:40:48 <Cale> Left a spurious Int in there :)
16:41:50 <Sindri> That sounds… complicated :D
16:41:55 <karshan> mniip: I'm using the syz package that gives me zippers for arbitrary datatypes. Unfortunately the type of the hole is not in the type of the zipper so I have `x :: (Typeable a) => a` but I also know that x has (Show a) for example.
16:42:11 <Cale> You could avoid the ReaderT and just make it a function:  newtype CreateEntity a = CE { runCreateEntity :: EntityId -> State World a }  which is equivalent but then you don't get to derive Monad for free
16:42:26 <Cale> Sindri: Well, it's a bit of work, but it might be worthwhile :)
16:42:29 <karshan> mniip: so I just want to call show on this a, without enumerating all the possible types it could be and calling cast until it succeeds
16:42:41 <mniip> karshan, so you want Typeable a => a -> (forall b. Show b => Maybe b)
16:42:42 <Cale> (depends on how much you're going to use it)
16:42:52 <Cale> Of course, there's always the option of just:
16:42:53 <Sindri> Cale: Well, I guess I'm going to be using it a lot
16:43:18 <Cale> createEntity :: (EntityId -> State World a) -> State World a
16:43:21 * hackagebot keera-posture 0.1.3 - Get notifications when your sitting posture is inappropriate.  http://hackage.haskell.org/package/keera-posture-0.1.3 (IvanPerez)
16:43:46 <mniip> karshan, I'm not entirely sure such transformation is possible using Data.Typeable
16:44:02 <Cale> So, you just get the new EntityId as a function parameter there, and have to pass it along explicitly to the things which use it
16:44:25 <Cale> Might be slightly more noise in the notation, but a good bit less setup to get there
16:45:08 <karshan> mniip: yea I thought so. Thanks anyways!
16:45:13 <Cale> Let me write something...
16:48:19 <mniip> karshan, here's an idea
16:48:37 <mniip> oh, actually nevermind
16:48:54 <mniip> karshan, are you trying to show a value if showable, and do something else otherwise?
16:58:21 * hackagebot keera-posture 0.1.4 - Get notifications when your sitting posture is inappropriate.  http://hackage.haskell.org/package/keera-posture-0.1.4 (IvanPerez)
16:58:56 <lpaste> Cale pasted “example for Sindri” at http://lpaste.net/134837
16:59:05 <Cale> Sindri: ^^ something like that perhaps
16:59:37 <larrycv> h
17:00:00 <Cale> Sindri: It's not completely fleshed out, but hopefully you can get the idea -- ideally you stick the definitions of Game and CreateEntity into a module and don't expose the G and CE constructors
17:00:03 <Sindri> Cale I came up with this: http://lpaste.net/252832514123497472
17:00:14 <Sindri> Cale: Thanks! I'll take a look at it
17:01:29 <larrycv> is there a warning in ghc, or a third part code analysis tool, that will warn me when I am using partial functions like head, (!!), etc?
17:01:44 <Cale> Sindri: The idea being that you only expose exactly the operations you want. In particular, you'd probably want the CreateEntity actions that you expose *only* to be able to act on the particular entity that's being created, and not the rest of the world.
17:02:21 <Cale> Sindri: and so by hiding the CE constructor, you can prevent the rest of the program from being able to make inappropriate changes to the state in that context.
17:02:48 <Cale> (i.e. you'd only expose the operations like the 'color' function I defined.
17:02:49 <Cale> )
17:03:07 <Sindri> I see!
17:03:33 * mniip wonders whether instance constraints can be given on closed type families
17:04:18 <Cale> Monad transformers can get really ugly really quickly if you're not careful about hiding the fact that you're using them, but they can be a really handy way to get access to monads with just the operations you want in this way.
17:04:24 <Sindri> Cale: Yeah, what I wrote has a lot of boilerplate in the `color` and `appearance` functions, they're basically identical
17:05:10 <Sindri> Cale: so probably instead of `modifyColors` in your example, I could do `modify colors` and make it universal for any field in the world
17:05:20 <mniip> oh
17:05:21 <mniip> you can
17:05:50 <Hafydd> Somehow I knew it was Haskell just by looking at "modifyColors" and nothing else.
17:06:03 <Cale> Hafydd: heh
17:06:42 <Cale> Sindri: There's a bit of trickiness in that, but it's possible to do things with lenses
17:07:18 <Sindri> Cale: I keep hearing lenses without any idea what they are. Where can I read more?
17:07:23 <Cale> Sindri: The trouble is that (colors :: World -> IntMap Color) doesn't tell us how to *set* the colors field of a World record.
17:07:50 <bsmt> +1 for wtf are lenses
17:08:02 <Sindri> Cale: Wouldn't that just be IM.insert for all of them?
17:08:21 <Cale> Sindri: Rather than giving you the modern definition of lenses, I think it's helpful to start off looking at the old timey definition, which is something like:
17:08:22 * hackagebot keera-posture 0.1.4.1 - Get notifications when your sitting posture is inappropriate.  http://hackage.haskell.org/package/keera-posture-0.1.4.1 (IvanPerez)
17:08:59 <Cale> data Lens a b = Lens { view :: a -> b, set :: b -> a -> a }
17:09:05 <Sindri> Cale: Like `modify :: (World -> IntMap a) -> a -> IntMap a
17:09:36 <Sindri> (+ a parameter for the world that I forgot)
17:09:43 <Cale> hmm
17:10:14 <Cale> So, you might have one of these  Lens World t  values for each of the fields of your World
17:10:20 <Cale> e.g.
17:10:34 <Cale> colorsL :: Lens World (IntMap Color)
17:10:46 <mniip> hmm
17:11:01 <Sindri> modify field value  = (e, w) <- get; let w' = w { field = insert e value (field w) }; ...
17:11:02 <mniip> is there a witness for inclusion of a type in a typeclass of some sort
17:11:24 <Cale> colorsL = Lens { view = colors, set = \c w -> w { colors = c } }
17:11:35 <Cale> and then you can have an operation like:
17:12:32 <Cale> modifyL :: Lens s t -> (t -> t) -> State s ()
17:13:04 <Sindri> Ah… so I swap out the fields I'm operating on by swapping the lens"
17:13:10 <Cale> yeah
17:13:17 <Sindri> That sounds really clever
17:13:34 <Sindri> (Like any haskell thing I've read so far, except the absence of trailing comma)
17:13:38 <Cale> It's arguable that the field names in record syntax ought to refer to lenses in some form, rather than just functions for extracting the field.
17:14:03 <Sindri> Oh, so the field itself would be the lens?
17:14:04 <Cale> But... that would break so much code that it'll never happen :)
17:14:17 <Cale> yeah
17:14:19 <Sindri> Ah, I see
17:14:39 <ttt_fff> wtf, is https://wiki.haskell.org/Do_notation_considered_harmful serious, or a joke?
17:14:59 <Sindri> Well, that's enough for today, it's 2 AM here and I'm starting to lose my ability to read
17:15:05 <Cale> ttt_fff: lol, don't believe everything you read on the wiki
17:15:09 <Sindri> Cale: Thank you so much for your help :)
17:15:28 <Literphor> Hello! Today’s the first day I’m trying out haskell… why does [3,2,1] > [2,10,100] == True? 2 is smaller than 10, 1 is smaller than 100
17:15:37 <Cale> ttt_fff: I haven't seen that page in years, I didn't even know it still existed. Some people are weird.
17:15:40 <ttt_fff> ttt_fff: I read on wikipedia that wikipedia is more accurate than bratinicia.
17:15:48 <Sindri> Cale: I just have to write copious amounts of code in Haskell to get to know it by heart, can't rush that
17:15:59 <Cale> Literphor: Lists are compared lexicographically. Think about how you compare words in a dictionary
17:16:24 <Cale> Literphor: The first elements are compared, and only if they're equal are the tails compared
17:16:27 <Sindri> Cale: But Haskell is doing wonderful things for my programmer burnout and the community is amazing, so thanks ^^
17:16:36 <Cale> Sindri: cheers!
17:16:50 <Sindri> Good night!
17:16:50 <Cale> Quite welcome :)
17:16:55 <Cale> Good night!
17:17:14 <mniip> interesting
17:17:32 <mniip> 	Showable (Show a => a) = True
17:17:40 <mniip> compiles but doesn't work as expected
17:17:45 <Cale> ttt_fff: Well, the Haskell Wiki also isn't Wikipedia and doesn't have the same rules about stuff
17:17:51 <mniip> in particular it does nothing
17:18:19 <Cale> mniip: what?
17:18:23 * hackagebot hpack 0.3.2 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.3.2 (SimonHengel)
17:18:38 <mniip> Cale, trying to build a type family that checks for instance membership
17:19:07 <Cale> I won't be surprised if that's impossible to do.
17:19:21 <mniip> me neither
17:19:29 <Cale> I'd expect type family instance selection to be the same as type class instance selection, so it should ignore constraints.
17:19:51 <Cale> (until an instance is selected, and only impose them after that)
17:20:45 <mniip> are you saying that (Show a => a) is a void "pattern match" if I can call it that
17:21:26 <mniip> i.e nothing ever matches (Show a => a) and instead advances to the second definition?
17:23:50 <geekosaur> actually I'd expect it to match everything and only later check for the constraint
17:24:49 <Literphor> Cale: Gotcha, TY!
17:25:23 <Iceland_jack> <bitemyapp> Iceland_jack: "but it's Haskell, so how bad could it be, right?"  ah ah ahhhh
17:25:23 <Iceland_jack> Context?
17:28:23 * hackagebot keera-posture 0.1.4.2 - Get notifications when your sitting posture is inappropriate.  http://hackage.haskell.org/package/keera-posture-0.1.4.2 (IvanPerez)
17:29:48 <mniip> Iceland_jack, context: haskell
17:30:50 <nitrix> Could someone recommend me a style guide for Haskell? No matter how I indent or try to organise code, it still looks funky to me.
17:32:34 * Iceland_jack nervously reads 'keera-posture' and sits up straight
18:04:35 <pingw> Hello
18:04:45 <pingw> Has anyone here used the mongodb client?
18:09:23 <codygman> Is there a way to create a Persistent entity out of an existing ADT?
18:09:45 <creichert> nitrix:here is a conservative guide: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
18:10:59 <RyanGlScott> I have a question about FlexibleContexts. Without it, you can't do something like this:
18:11:02 <RyanGlScott> newtype Alt f a = Alt (f a)
18:11:02 <creichert> codygman: a simple one? derivePersistEntity
18:11:08 <RyanGlScott> deriving instance Eq (f a) => Eq (Alt f a)
18:11:22 <RyanGlScott> Yet you do can this without needing FlexibleContexts:
18:11:25 <RyanGlScott> newtype Alt f a = Alt (f a) deriving Eq
18:11:43 <RyanGlScott> Why is the latter okay, but not the former?
18:11:57 <creichert> codygman:sorry, derivePersistField
18:12:40 <codygman> creichert: Thanks
18:19:47 <creichert> codygman: I may have misunderstood that for making a simple sum type storable within an entity
18:30:47 <Dan39> is there an article that covers the basic syntax of the documentation? like the  funtionName :: a -> b -> c
18:31:14 <Dan39> not sure why it is confusing the hell out of me so much >_<
18:31:35 <hpc> that's just haskell code
18:31:47 <hpc> try a tutorial like LYAH or RWH?
18:31:54 <Dan39> in the process
18:32:10 <hpc> anyway, (::) means "has type of"
18:32:24 <hpc> so it's declaring the type of functionName to be (a -> b -> c)
18:32:39 <Dan39> yea i understand that part, lol
18:32:44 <creichert> The haskell wiki book has two sections as well
18:32:50 <hpc> oh, heh
18:33:02 <Cale> Dan39: Okay, then what part is confusing?
18:33:02 <creichert> what part is confusing?
18:33:29 <Dan39> decyphering which are args and what it is returning, and what the types of them are
18:33:34 <hpc> (a -> b -> c) is (to gloss over an immense amount of detail), a function from a value of type 'a' and a value of type 'b'
18:33:37 <hpc> to a value of type 'c'
18:33:47 <hpc> in a more C-like syntax
18:33:53 <hpc> c functionName(a, b)
18:34:01 <Cale> Okay, so (->) associates to the right: When you see a type like  a -> b -> c -> d  it means  a -> (b -> (c -> d))
18:34:37 <Cale> In a related way function application in expressions associates to the left: when you write f x y z it means ((f x) y) z
18:35:11 <Cale> So if we have f :: A -> B -> C -> D and x :: A as well as y :: B and z :: C
18:35:17 <Cale> then f x :: B -> C -> D
18:35:23 <Cale> and f x y :: C -> D
18:35:28 <Cale> and f x y z :: D
18:36:20 <Dan39> helping :) 
18:36:30 <Cale> All functions in Haskell are really functions of a single argument -- those which appear to take more are just producing other functions as their result.
18:37:03 <Dan39> ah
18:37:46 <Dan39> now you are confusing the hell out of me with that one
18:37:52 <Dan39> doubleUs x y = x*2 + y*2
18:37:58 <Dan39> how does that translate to what you said <_<
18:38:12 <Cale> Suppose you have  doubleUs :: Integer -> Integer -> Integer
18:38:29 <DanBurton> doubleUs x = \y -> x*2 + y*2
18:38:31 <Cale> Since -> associates to the right, that means  doubleUs :: Integer -> (Integer -> Integer)
18:38:45 <Cale> @let doubleUs x y = x*2 + y*2
18:38:46 <lambdabot>  Defined.
18:39:08 <Cale> @let twoPlusTwice x = doubleUs 1
18:39:09 <lambdabot>  Defined.
18:39:12 <Cale> oops
18:39:16 <Cale> @undefine
18:39:16 <lambdabot> Undefined.
18:39:21 <Cale> not what I wanted to write :)
18:39:35 <Cale> @let doubleUs :: Integer -> Integer -> Integer; doubleUs x y = x*2 + y*2
18:39:36 <lambdabot>  Defined.
18:39:42 <Cale> @let twoPlusTwice = doubleUs 1
18:39:43 <lambdabot>  Defined.
18:39:49 <Cale> > twoPlusTwice 5
18:39:51 <lambdabot>  12
18:40:31 <Cale> doubleUs is a function which given some value x, produces the function which given some value y, results in x*2 + y*2
18:40:44 <Dan39> interesting
18:40:54 <Cale> So doubleUs 1 is the function which given some value y, results in 1*2 + y*2
18:41:25 <Cale> and then doubleUs 1 5 = (doubleUs 1) 5 = 1*2 + 5*2
18:41:41 <Dan39> i see
18:41:59 <Cale> > map (doubleUs 1) [1..10]
18:42:01 <lambdabot>  [4,6,8,10,12,14,16,18,20,22]
18:42:04 <Dan39> you're amazing Cale :)
18:42:13 <Welkin> does anyone have a link to that wiki page about uninstalling haskell platform from linux?
18:42:24 <Welkin> I have a really old version of HP on my linux box
18:42:44 <Cale> Welkin: Installed from your distribution's packages?
18:42:50 <Cale> Or from source?
18:42:57 <Welkin> I only found it in ~/.ghc ~/.cabal and /var/lib/ghc
18:43:06 <Welkin> I think I installed from the website
18:43:08 <Cale> hm
18:43:29 <kadoban> If nothing else I guess you could download it again and look at the makefile, see where it puts stuff?
18:43:41 <kadoban> Assuming it has a makefile ...
18:43:50 <Dan39> Cale: that lil lesson should be saved and shared somewhere! haha
18:45:04 <Cale> I would expect some discussion of this sort to be part of any introduction to Haskell somewhere :)
18:45:21 <Cale> It might be that it just didn't occur yet in whatever you're reading
18:45:27 <Dan39> yea maybe
18:45:32 <Welkin> ghc installs in /usr/bin on linux, right?
18:46:35 <creichert> Welkin: what distro? possibly /opt/ghc
18:46:39 <geekosaur> only from distribution packages. the ghc bindist tarball and IIRC the platform go in /usr/local
18:46:51 <Welkin> I see
18:46:57 <geekosaur> (by default; the bindist can be relocated)
18:47:02 <Welkin> HP must put it in /usr/bin
18:47:23 <geekosaur> the OS X HP goes in /usr/bin
18:47:52 <geekosaur> (I am not especially enamored of that decision, but Apple thinks it's a good idea. Sigh.)
18:48:14 <geekosaur> (that's the same Apple that ships "fake" readline and iconv...)
18:52:47 <DanBurton> Halcyon puts it in /app/ghc, I believe.
18:53:07 <DanBurton> Stack puts it in ~/.stack/programs/$arch/
18:55:14 <Welkin> huh
18:55:28 <Welkin> I guess I may have use HP from my package manager after all
18:55:39 <Welkin> that amkes sense
18:55:50 <Welkin> it is ghc 7.4.1, but I only installed it a year ago
19:02:07 <mietek> DanBurton: by default, yes — but it’s up to you
19:02:11 <Welkin> wow, apt didn't even remove everything
19:02:22 <Welkin> I am hunting down the remnants and removing them manually
19:02:29 <Welkin> hello mietek 
19:02:42 <mietek> Welkin: hi
19:03:54 <geekosaur> apt-get purge instead of apt-get remove?
19:04:22 <hpc> autoremove will get dependencies that are no longer used
19:04:34 <geekosaur> and that, yes
19:04:53 <Welkin> time to install new ghc :)
19:05:00 <Clint> also potentially useful: dpkg -P $(dpkg -l | awk '/^rc/ {print $2}')
19:05:06 * Dan39 must be stalking geek osaur <_<
19:05:23 * geekosaur is.
19:12:33 <larrycv> what non-empty list-like datastructure is usually recommended?
19:12:56 <Welkin> for what?
19:13:29 <larrycv> for a list-like type that cant be empty 
19:14:23 <hpc> the question is what the list is used for
19:21:59 <larrycv> hpc I am using it to store elements.. not sure what other explanation were you looking for. having zero elements is a user error, so I thought it would be nice to enforce that at compile time, instead of just stating it as a convention in documentation
19:22:52 <pingw> larrycv, https://hackage.haskell.org/package/non-empty
19:23:01 <Cale> Just using (a,[a]) is an option
19:23:35 <Cale> Don't use that package if you want other people to maintain your code :P
19:23:47 <Cale> It's a Henning nightmare where all the types are called T :P
19:23:50 <larrycv> ha, why?
19:24:12 <pingw> what about the one in semigroups?
19:24:14 <larrycv> all types are called T?
19:24:38 <pingw> That ones made by ekmett so it must be good
19:24:40 <Cale> larrycv: Yeah, it's this ridiculous convention that Henning Thielemann uses, and essentially everyone else hates.
19:24:51 <Cale> All his types are T, all his classes are C
19:25:04 <Cale> Makes the documentation completely unreadable
19:25:10 <larrycv> yeah I see what you mean
19:25:31 <Cale> Yeah, semigroups is a good package, use that, I suppose
19:25:55 <Cale> http://hackage.haskell.org/package/semigroups-0.16.2.2/docs/Data-List-NonEmpty.html
19:26:36 <roboguy_> Cale: has he ever given an explanation of the reasons for his naming conventions?
19:26:52 <Cale> roboguy_: I dunno, he just likes qualified imports a whole lot
19:27:08 <c_wraith> Yeah, he imports everything qualified, and things that it leads to good names.
19:29:02 <Cale> It's super-unfortunate because he has a lot of good packages, some of which he wasn't the original author of and has subsequently transformed to this style, like Haskore.
19:29:41 <roboguy_> Yeah. I wanted to try Haskore out a little while back, but that put me off too much
19:31:21 <Cale> See if you can find a copy of the original one from Hudak if you want to play with it
19:34:24 <roboguy_> I might do that. A music DSL sounds fun. I wonder if it would be worth it to write a program to change the names back to something more readable
19:34:26 <larrycv> wow, every single data and class he defines is T or C, just in different modules
19:35:11 <geekosaur> yep
19:35:49 <geekosaur> I think there's a bug report for haddock to detect Henning style modules and fully qualify all the names so the bloody docs are actually useful
19:36:48 <Cale> Maybe we ought to have a community petition to Henning to just stop doing that
19:37:33 <geekosaur> he's been begged on -cafe several times
19:37:48 <roboguy_> I'd sign
19:38:24 <bitemyapp> Cale: I'd sign
19:38:33 <timothyh> i can't use numeric-prelude for that reason
19:53:29 * hackagebot esqueleto 2.2.4 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.2.4 (FelipeLessa)
20:19:39 <larrycv> doesnt IsList instance for NonEmpty defeat its purpose to some extent, which is to ensure at compile time that a list cant be empty?
20:20:23 <larrycv> ([] :: NonEmpty) compiles with OverloadedLists
20:20:44 <DanBurton> (undefined :: NonEmpty) also compiles
20:20:51 <DanBurton> There's only so much it can protect you from
20:21:36 <larrycv> DanBurton: the protection from that eoulf have been very simple: dont write an IsList instance
20:21:49 <DanBurton> So I guess you could say that, if you have successfully reduced NonEmpty to WHNF, then it is a non-empty list
20:22:03 <pingw> nobody forces you to use the islist instance
20:22:25 <DanBurton> I wish that IsList and IsString happened at compile time rather than runtime.
20:22:41 <larrycv> pingw: it is useful for other things.
20:22:46 <DanBurton> It should be `isString :: String -> Q (TExp String)`
20:23:05 <pingw> wouldnt you need to have template haskell in everything then
20:23:15 <DanBurton> that would indeed be annoying
20:23:19 * larrycv types for which OverloadedLists dont defeat the sole reason they exist..
20:23:31 * hackagebot th-desugar 1.5.4 - Functions to desugar Template Haskell  http://hackage.haskell.org/package/th-desugar-1.5.4 (RichardEisenberg)
20:23:32 <DanBurton> There should be some sort of Template Haskell lite :P
20:23:47 <pingw> maybe you could do it with datakinds
20:24:04 <DanBurton> hackagebot is weirdly relevant
20:24:30 <pingw> it could give you a list with a static size
20:24:32 <Cale> IsList and IsString are both pretty questionable extensions
20:24:49 <pingw> and then you use some kind of type family to convert it to your type
20:24:54 <DanBurton> IsString is terribly convenient though.
20:25:22 <Cale> I can see in cases where you're using a large number of constant Text values that it would be convenient
20:25:51 <Cale> It invites abuse though
20:26:07 <DanBurton> Another reason why I wish IsString performed compile-time computation: regex, html, all kinds of things that can be parsed from a string but might fail.
20:26:14 <DanBurton> Even a printf formatter
20:26:44 <Cale> I'd probably prefer a specific extension which just says "string constants automatically have Data.Text.pack applied to them"
20:26:45 <larrycv> making OverloadedLists usable with NonEmpty means gives you the abolity to create empty lists (and with that, runtimr errors) just as easily as if you just used a list. how is that a good idea?
20:27:06 <Cale> and then you can't abuse it to do regex and nonsense like that
20:27:23 <pingw> but you can tell whether its empty or not by looking at it
20:27:24 <larrycv> it defeats the entire purpose of NonEmpty
20:27:42 <DanBurton> It wouldn't be abuse *if* it could throw a compile-time exceptino.
20:27:51 <Cale> larrycv: Well, you can always write  undefined :: NonEmpty a
20:28:21 <Cale> larrycv: Also, nothing is forcing you to turn on that extension
20:28:26 <Cale> (I would recommend leaving it off)
20:29:21 <pingw> Template haskell lite seems like a good idea
20:29:47 <Cale> lite?
20:29:56 <Cale> How would you make it lighter?
20:29:57 <bitemyapp> light?
20:30:04 <bitemyapp> Cale: strap a flashlight onto it
20:30:23 <larrycv> Cale you cant write undefined :: NonEmpty by accident.. you could conceivably write [] by accident 
20:30:29 <pingw> just so you can use it to write parsers for overloadedlists and overloadedstrings at compile time
20:30:31 <Cale> larrycv: I suppose
20:30:47 <Cale> larrycv: But yeah, using that extension with NonEmpty is really questionable
20:31:01 <Cale> (using that extension at all is pretty questionable anyway)
20:40:32 <ronh-> Cale how about OverloadedStrings?
20:40:52 <Cale> ronh-: I think they're both a bit questionable.
20:41:04 <Cale> (both OverloadedLists and OverloadedStrings)
20:46:39 <augur> is it possible to have a data family be a functor?
20:47:04 <c_wraith> augur: it's possible for a data instance to be a Functor.
20:47:12 <augur> hmm ok
20:47:13 <c_wraith> augur: but not a full data family.
20:48:18 <c_wraith> augur: because a data family's representation is open.  You can have some instances that cannot be a Functor legally, even though other instances are.
20:49:42 <augur> c_wraith: yeah, i was hoping was possible to require all new instances to be functors, but ok
20:49:45 <augur> thats fine i guess
20:49:46 <augur> thanks :)
20:50:41 <c_wraith> You'll have to just put the instance requirement on the functions, like the good old days. :)
20:51:18 <augur> :)
20:51:55 <Welkin> what is with "multiple definition of `gmtab'" when linking?
20:52:17 <Welkin> something to do with cryptonite and cipher-aes
20:53:32 * hackagebot units 2.3 - A domain-specific type system for dimensional analysis  http://hackage.haskell.org/package/units-2.3 (RichardEisenberg)
21:08:58 <Welkin> is there a way to print out constraints to use in a cabal.config based on the installed packages in a cabal sandbox?
21:11:50 <johnw> you can move your .cabal out of the way, and then run "cabal init" again
21:12:02 <johnw> also, there is the cabal-bound(s?) utility
21:12:17 <Welkin> ?
21:12:21 <Welkin> what does that do?
21:12:29 <Welkin> do you mean .cabal-sandbox?
21:12:59 <johnw> google, and no
21:13:51 <Axman6> anyone familliar with using Diagrams in iHaskell (specifically the Kronos-Haskell one)
21:13:51 <Welkin> why would moving ~/.cabal do anything?
21:14:00 <Axman6> I can;t get text to render in diagrams
21:14:10 <johnw> your foo.cabal file, so cabal init doesn't overwrite
21:14:36 <Welkin> oh
21:14:54 <Welkin> what would running cabal init do for me though?
21:15:01 <Welkin> it never generates any constraints list
21:15:03 <johnw> i'm sorry, I've run out of time
21:18:00 <dmj`> Welkin: cabal freeze
21:18:17 <Welkin> really?
21:18:19 <Welkin> god damn
21:18:22 <Welkin> it's the same as pip
21:19:02 <dmj`> Welkin: I used to freeze, but now I just == x.y.* everything
21:19:31 <Welkin> what do you mean?
21:20:01 <Welkin> oh, you leave the constraint slightly open
21:20:07 <Welkin> well, this is a yesod project
21:20:14 <Welkin> I can't do that by hand
21:20:25 <Welkin> the dependencies are half of hackage
21:20:56 <Welkin> I'm just looking to make sure this builds on my other machine with the same setup so I can deploy it
21:21:14 <Welkin> one of the disadvantages of running osx
21:21:15 <dmj`> Welkin: sure there are transitive dep issues, but the cabal sat solver should handle that as long as you have the x.y versions specified and all authors abide by the pvp and bump frequently
21:21:43 <dmj`> Welkin: are you using stack?
21:22:05 <Welkin> no
21:22:10 <Welkin> is it any good?
21:22:53 <dmj`> Welkin: I don't know, I use nix, but I heard some people singing its praises
21:22:59 <Welkin> "Note: due to GHC bug 10322, building stack from source fails with GHC 7.10.1. This bug will be fixed in 7.10.2, but in the meantime, we recommend using GHC 7.8.4 on OS X."
21:23:02 <Welkin> haha
21:23:10 <dmj`> :) nvm
21:23:11 <Welkin> that is exactly what I did (moved to 7.8.4)
21:23:53 <dmj`> Welkin: nix is pretty glorious, http://lethalman.blogspot.com/2014/07/nix-pill-1-why-you-should-give-it-try.html
21:24:45 <Welkin> I've been hearing about Nix for a long time now
21:24:55 <Welkin> maybe I'll give it a try soon
21:25:10 <Axman6> I found moving from cabal sandboxes to stack confusing, it wasn't clear how you install new libraries when the dependencies of your package change, so I've just been using stack install <foo>. I want something equivalent to cabal install --only-dependencies
21:25:27 <Axman6> but apart from that, I've been liking my initial interractions with stack
21:26:20 <Welkin> I'm just starting to get used to cabal sandboxes too
21:26:32 <Welkin> using them very carefully, I mean
21:27:16 <Axman6> well the point is that you don't really need to be careful when using a sandbox
21:29:29 <Welkin> I had lots of things installed in my local db
21:29:40 <Welkin> now I keep it empty
21:30:07 <Welkin> and even install alex, happy, and yesod-bin in seperate sandboxes and link to the binaries
21:30:33 <dmj`> anyone here use lucid?
21:30:49 <Xe> ubuntu lucid?
21:31:00 <Welkin> that is pretty old
21:31:08 <dramforever> lol
21:31:13 <dramforever> @hackage lucid
21:31:13 <lambdabot> http://hackage.haskell.org/package/lucid
21:31:21 <dramforever> maybe?
21:32:11 <dmj`> Xe: the package, dramforever yea
21:32:32 <dmj`> maybe? or no
21:32:42 <Welkin> I'm using haha
21:32:51 <Welkin> okay, not ubuntu then
21:33:02 <Welkin> I prefer shakespeare
21:33:16 <Welkin> I have never seen lucid before, but it looks interesting
21:33:31 <Welkin> once you get used to using one template language though, it is easiest just to continue using it
21:38:11 <augur> a funny kind of data type:
21:38:31 <augur> linearize [(0,True), (1,False)]  ==  LinCons (LinPair (LinInt 0 (LinBool True (LinCons (LinPair (LinInt 1 (LinBool False (LinNil ()))))))))
21:38:52 <augur> :: Lin [(Int,Bool)] ()
21:39:34 <dramforever> looks good for serializing
21:39:46 <augur> thats one use :)
21:39:54 <dramforever> any other?
21:40:08 <augur> efficient pattern matching via decision trees
21:40:25 <dramforever> efficient??
21:40:38 <augur> consider the following case expression:
21:40:46 <augur> case x of
21:40:53 <dramforever> uhh...is that long?
21:40:57 <augur>    (True, Nothing) -> ...
21:41:03 <augur>    (True, Just x) -> ...
21:41:14 <augur>   (False, x) -> ...
21:41:26 <dramforever> okay
21:41:38 <augur> er, swap out the x in 'case x of' for something else :p
21:41:43 <dramforever> but I think ghc can optimize it
21:41:44 <augur> lets say p
21:41:58 <augur> yes yes but im talking about how you implement the optimization! :)
21:42:15 <augur> if you have such a case expression, you can obviously match p against each pattern one at a time
21:42:15 <dramforever> case p of (True, m) -> case m of ...
21:42:18 <dramforever> how about this
21:43:26 <augur> but there's a lot of redundancy, right
21:43:44 <augur> there's at least two redundancies
21:44:14 <augur> one is: if p matches (...,...) then the test to see if its a pair is happening three times
21:44:32 <augur> and then on the (True,...) case, the test if the first element is True is happening twice
21:44:32 <dmj`> it's strange because the core datatype of lucid is HtmlT m a, where m is a Monad. There's a corresponding typeclass ToHtml a where toHtml :: Monad m => a -> HtmlT m (), and a typedef 'type Html a = HtmlT Identity a`. I get the weirdest type errors where m cannot be Identity, even though Identity is a monad
21:44:57 <dramforever> augur: maybe, if you do no optimizing
21:45:15 <augur> dramforever: like i said, im interested in how to implement the optimization
21:45:29 <dmj`> so I have to write my own 'type Html a = forall m . Monad m => HtmlT m a', which just seems foolish
21:45:34 <dramforever> augur: look at ghc core maybe?
21:45:46 <dramforever> I mean, core generated by ghc
21:45:55 <augur> dramforever: thats boring, complicated, and boring
21:45:58 <augur> :P
21:46:06 * dramforever is trying to do this
21:46:12 <augur> i found a cute, interesting way to do it, so
21:47:04 <augur> the first insight is to realize that matching against, say, the pattern  (True,0)   means matching against the constructor (,), and if that succeeds, matching against True, and if that succeeds, matching against 0
21:47:50 <augur> which is to say, if you traverse both trees, you expect to find the same constructor sequence
21:48:32 <dmj`> what even is a digestive functor
21:49:31 <augur> or to put it another way, each constructor encloses the whole rest of the traversal
21:50:08 <augur> if you have a pattern instead of data, each constructor pattern encloses the whole rest of the pattern match after that point
21:51:01 <augur> dramforever: but then what if you have disjunctive patterns as well as just constructor patterns? aha!
21:52:05 <augur> if you can disjoin patterns, then you only need to traverse under a constructor pattern once, while traversing over the match data's constructor
21:52:52 <augur> and then your remaining pattern is a disjunction, say
21:53:15 <augur> and you can treat it like one
21:53:29 <augur> but, this means you can now optimize by pushing disjunctions down under constructor patterns
21:54:32 <augur> if you have something like this:    LinCon xxsr <+> LinCon yysr   where <+> is the choice pattern, then you can push this down to   LinCon (xxsr <+> yysr)
21:55:02 <dramforever> hmm
21:55:17 <dramforever> wait a sec is that just like serializing then parsing?
21:55:23 <dramforever> stringstream !!??
21:55:29 <augur> not quite
21:55:33 <dramforever> okay not that bad
21:55:42 <augur> but maybe there's a connection
21:55:43 <dramforever> maybe constructor streams
21:55:55 <augur> actually
21:56:30 <augur> given the way it matches, you probably _could_ do some kind of pattern matching over serialized data this way
21:59:59 <lpaste> dramforever pasted “opt” at http://lpaste.net/134845
22:00:13 <dramforever> augur: ^ there, I'm sure you can read this
22:13:34 <L8D> how can I make cabal autogenerate/write dependencies to my cabal file?
22:20:49 <dmj`> L8D: cabal freeze
22:21:45 <L8D> dmj`: I want to write dependencies to my project's cabal file
22:21:54 <L8D> dmj`: as in for the build-depends feild
22:21:56 <L8D> field*
22:23:22 <L8D> dmj`: When I use 'cabal init' it creates entries for the cabal file based on what I import in my library's code
22:23:33 <larrycv> what name would you use for a "var" variable in here? recurse? recur? something else? longFunctionName x y = ... where var = longFunctionName x y?
22:23:57 <L8D> dmj`: I'm wondering if I can use that dependency-detector system to generate a list of dependencies to add to my cabal file (or have cabal insert them for me)
22:24:25 <larrycv> I have several conditions and var would represent a value we get if we recurse with the same arguments
22:28:22 <L8D> larrycv: fix?
22:28:25 <L8D> fixpoint
22:28:27 <L8D> fp
22:28:42 <larrycv> hmm
22:28:43 <L8D> larrycv: I mean... technically it is not the fixpoint
22:29:34 <dmj`> L8D: haskell emacs mode does it for you automatically, otherwise do it manually
22:29:43 * L8D cries
22:29:50 <L8D> I'll just re-generate the cabal file from scratch
22:30:01 <larrycv> function returns IO btw, so it may be even less related to fix than it appeared? 
22:30:06 <L8D> dmj`: thank you
22:30:11 <pingw> the mongodb driver is a bit slow
22:30:31 <L8D> larrycv: so you are naming the value you would get after bind?
22:30:39 <nshepperd> larrycv: 'loop' or 'rec'?
22:30:43 <L8D> i.e. <name here> <- longFunctionName x y
22:31:02 <L8D> larrycv: it really depends on what you are writing
22:31:25 <L8D> larrycv: I don't think you should need to convey the idea that it is the result of recursively calling itself
22:31:26 <larrycv> no. it is just an alias for longFunctionNamr x t, since I am doing that in several different conditions
22:31:50 <L8D> larrycv: you could use 'this' or 'self'
22:31:59 <L8D> or 'r'
22:33:12 <larrycv> nshepperd: i tried rec, emacs is highlighting it for some reason, so i thought it wont work (but it does)
22:33:44 <larrycv> L8D: yeah
22:37:00 <larrycv> L8D: I think it is important to convey recursive call somehow, since the conditions that miss that line break the user input loop
22:45:29 <nshepperd> oh, I think rec might be a keyword in some ghc extension?
22:45:43 <Axman6> yes
22:46:29 <Axman6> for recursive do I think
22:47:11 <Saizan> yah
22:51:46 <codygman> I'm getting an error trying to use a regular ADT with persistent. My guess is that I need to satisfy the PersistEntity typeclass before I can use it with insert in addition to using derivePersistField? Maybe deriving persist field is superfluous? I'm a little lost, any direction is appreciated. code/error: https://bitbucket.org/codygman/persistent-entity-from-existing-adt/src/2e526cc9ffbbe266b199e975c3246bf1b136b9f1
22:51:46 <codygman> /src/MinimalRepro.hs?at=master#cl-36
22:52:00 <codygman> https://bitbucket.org/codygman/persistent-entity-from-existing-adt/src/2e526cc9ffbbe266b199e975c3246bf1b136b9f1/src/MinimalRepro.hs?at=master#cl-36
22:53:04 <larrycv> how about "again"? too vague?
22:55:53 <wz1000> Do scoped type variables work in instance declarations? For example if I have 'instance C (T a) where ...', can I use 'Proxy :: a' inside the declaration?
22:56:22 <Axman6> you can use Proxy :: Proxy a
22:56:32 <wz1000> Yeah, that
22:57:07 <owl-v-> #/join emacs
22:57:22 <owl-v-> ops
22:59:24 <wz1000> Then why doesn't this work: http://lpaste.net/5945912609587855360
22:59:54 <wz1000> Wait, I got it. 
23:00:14 <wz1000> Thanks Axman6 
23:03:37 * hackagebot network-fancy 0.2.3 - Networking support with a cleaner API  http://hackage.haskell.org/package/network-fancy-0.2.3 (TaruKarttunen)
23:10:02 <mikeplus64> anyone using structured-haskell-mode here? (it's pretty great btw) 
23:10:30 <mikeplus64> how do i insert a )?
23:11:04 <larrycv> should I use rank2 or rankN types when both will do?
23:12:51 <johnw> rankN
23:29:11 <codygman> I'm trying to insert all data in a Status (https://github.com/himura/twitter-types/blob/master/twitter-types/Web/Twitter/Types.hs#L119) with Persistent. What is the easiest way for me to make Status (and types within it) Persistent instances?
23:36:00 <owl-v-> cabal install ghc-mod -> error -> http://lpaste.net/134846
23:48:01 <creichert> owl-v-: ghc --version?
23:48:23 <owl-v-> version 7.10.1
23:49:19 <creichert> owl-v-: I don't think the version on Hackage is compatible with 7.10 yet
23:49:23 <creichert> This might help:
23:49:39 <creichert> https://github.com/kazu-yamamoto/ghc-mod/issues/499
23:50:19 <creichert> It's mentioned there, even if you aren't on OSX. long story short, try building straight from the git repo for 7.10 support.
