00:00:17 <freshman> could you please give an example (assume I have `fix f = f (fix f)`, and I want to get fix', defined by that one) ?
00:01:40 <nshepperd> uh, you probably need to give more detail if you want to rule out the trivial answer "fix' = fix"
00:03:44 <whiteline> freshman: what's the type signature of fix' supposed to be?
00:06:31 <freshman> whiteline: smth like "fix' :: ((a -> b) -> a -> b) -> a -> b". "fix" can be defined (and actually is) in terms of itself, so I asked myself, is there only one possible FPO (e.g. all possible implementations are isomorphic), or not
00:07:41 * hackagebot foldl 1.0.11 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.11 (GabrielGonzalez)
00:07:41 * hackagebot metrics 0.3.0.1 - High-performance application metric tracking  http://hackage.haskell.org/package/metrics-0.3.0.1 (IanDuncan)
00:07:42 <tejing> freshman: fix' = fix still fits that type signature
00:08:08 <Cale> fix f = x where x = f x  has different operational behaviour from the definition of fix that you gave
00:09:22 <freshman> tejing: that's one of possible implementations, does any 
00:09:34 <Cale> In particular, evaluating fix (1:) with the definition you gave above will result in an unbounded amount of allocation, while with this one, only a single list cell will be allocated.
00:09:47 <freshman> (continued) not so trivial exist&
00:11:20 <lpaste> Cale pasted “Y combinator” at http://lpaste.net/133807
00:12:07 <Cale> There's a fixpoint combinator defined directly as a lambda, making use of recursion at the type level to obtain recursion at the value level
00:13:53 <Cale> freshman: you could also do things like  fix' f = fix (f . f)
00:14:47 <Cale> Is that the same fixpoint combinator? Well, it's the same function extensionally, but it's not the same intensionally.
00:32:36 * hackagebot yesod-dsl 0.1.1.24 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.24 (TeroLaitinen)
00:34:25 <pyr> hello haskell!
00:35:12 <Cale> hello!
00:35:36 <pyr> I'm trying to figure out how to approach a specific problem. I'd like to use as a simple HTTP layer which does sanitization and like the Middleware approach that it exposes through Network.WAI
00:36:29 <pyr> I'd love to leverage it to figure out the input mechanism used (form-encoded vars, JSON, protobuf) and hand over an application with a pre-processed body
00:36:57 <pyr> trouble is, an Application's body is always a source which is lazy seq of Bytestrings
00:37:31 <pyr> is there a way to approach this through middlewares or should I build my own handler nesting mechanism to process input ?
00:44:40 <liste> pyr Middleware is just Application -> Application, so there will still be Bytestrings
00:45:04 <pyr> yup, that's my understanding, I was just wondering out loud if there was a way to approach this I could have missed
01:28:14 <comprehension> hey all
01:29:29 <comprehension> i'm trying to create an EventSource in reactive banana that fires whenever new input comes in on a file handle
01:29:57 <comprehension> the best way i can think of doing it is to fork off a thread to watch the handle forever and fire the event when something new comes, but that seems wrong
01:30:12 <comprehension> i.e. not very declarative
01:30:18 <comprehension> is there a better way?
01:31:35 <saulzar> Once you have written that you can then use your EventSource in a nice declarative way...
01:32:51 <comprehension> saulzar: okay. so there's just some ugliness in the beginning?
01:33:03 <comprehension> i'm new to FRP and i want to make sure i'm not defeating the purpose
01:34:33 <saulzar> Me too, and I'm not too familiar with reactive-banana - someone may have written such a thing previously
01:37:30 <saulzar> I'm working with reflex, and I've used your approach a few times to interface with lower level IO code
01:38:05 <comprehension> saulzar: your answer sounds right to me. i suppose once i have the event then it will look pure to the rest of my code
01:42:24 <saulzar> What I have found a little tricky is managing the resources, i.e. who controls the file handle
01:42:38 <saulzar> (and what happens to the thread when you're finished)
01:46:14 <R0b0t1> comprehension: What do you mean by watch? Interrupts or nonblocking IO are not strictly declarative, but fit better with a functional style
01:46:43 <R0b0t1> o
01:52:41 <saulzar> R0b0t1,  I imagine he has some kind of blocking read and he wants to feed it into his Event ..
01:54:08 <comprehension> saulzar and R0b0t1: my connection dropped, sorry
01:54:41 <comprehension> i have a Pty that i've gotten from System.Posix.Pty and i want to display some of the output with gtk
01:55:11 <comprehension> i'm writing a terminal emulator
01:55:50 <comprehension> the input to the shell is easy to get from gtk2hs -- just watch KeyPress events -- but i'm not sure what the right way to get output from the shell is
01:55:51 <saulzar> waiting on readPty?
01:56:11 <comprehension> saulzar: yes
01:56:22 <saulzar> Yeah - blocking IO is more of a pain to interface than the callback stuff of gtk
01:56:59 <comprehension> now i have something like "forkIO $ forever $ readPty pty >>= fire myEvent"
01:58:44 <comprehension> i'm clearly doing something wrong, though, because the whole thing is locking up
01:58:53 <saulzar> Oh..
01:59:27 <saulzar> Seems reasonable, what you're doing
02:00:23 <comprehension> hmmm
02:12:25 <saulzar> comprehension, Just make sure anything using gtk comes from the same thread - that could be an issue
02:12:51 <comprehension> saulzar: you mean anything that touches a gtk object?
02:12:59 <comprehension> i'll be aware of that
02:13:20 <comprehension> i'm now getting this bizzare "fdReadBuf: hardware fault (Input/output error)" error
02:14:27 <saulzar> Yeah, gtk is quite thread-unsafe I believe, though lightweight threads should be okay
02:14:30 <mauke[> EIO    I/O  error.   This  will  happen  for  example  when the process is in a background process group, tries to read from its controlling tty, and either it is ignoring or blocking SIGTTIN or its process group is orphaned.  It may also occur when there is a low-level I/O error while reading from a disk or tape.
02:16:24 <comprehension> mauke[: hmmm okay. i guess that would point towards a permissions issue in my case?
02:16:44 <comprehension> it reads all of the currently-available input from the pty, then dies the next time it tries
02:17:31 <mauke[> o_O
02:17:43 <mauke[> nothing in there even mentioned permissions
02:18:14 <comprehension> mauke[: "permissions" is the wrong word
02:19:52 <comprehension> i meant some sort of process group issue, but i dont think it made sense anyway
02:20:16 <abhips> Can anyone point out the issue in this stackoverflow question. http://stackoverflow.com/questions/30611005/haskell-scotty-low-throughput-in-network-i-o   
02:21:23 <mauke[> "Is it really not possible to achieve good throughput along with 200 status code responses with Scotty."  <- this is where I closed the tab
02:24:42 <frerich> It's a question, not a claim - despite the lack of a quotation mark.
02:26:47 <abhips> mauke[: I posted the question. I agree it was wrong on my part on making a wrong judgement. Can you point out the issue though?
02:27:04 <mauke[> frerich: it's the wrong question
02:27:34 * frerich sighs
02:28:53 <comprehension> mauke[: is there an underlying POSIX error code i could dig in to to find out more about the hardware fault error message? 
02:29:33 <mauke[> comprehension: that probably comes from the haskell libraries
02:30:26 <comprehension> mauke[: okay. and actually, i've fixed it, nevermind. thanks for the help!
02:30:45 <mauke[> comprehension: http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Foreign-C-Error.html#errnoToIOError
02:42:43 * hackagebot recursion-schemes 4.1.2 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-4.1.2 (EdwardKmett)
03:16:13 <ttt_fff> for a module name, is "UI" or "Ui" better ?
03:17:03 <liste> well, there's ST, IO in base
03:17:15 <liste> and CPUTime
03:17:23 <liste> so I'd go with UI
03:17:35 <ttt_fff> okay
03:17:36 <ttt_fff> UI it is
03:17:41 <Sindri_> Rule of thumb, if it's an abbreviation, go all caps. If it's just "usually" spelled all caps, go camel case
03:17:57 <ttt_fff> I'm just afraid Iend up with too may CAPITAL LETTERS IN MODULE NAMES, WHICH BEOMES HARD TO READ, but UI looks better than Ui, I have to agree.
03:18:11 <ttt_fff> Should it be "SVG" or "Svg" then ?
03:18:23 <Sindri_> ttt_fff: Yeah, UI should definitely by UI. SVG should be SVG too
03:18:37 <ttt_fff> What is something that is "usually spelled all caps" but is NOT "an abbreviation" ?
03:18:43 <Sindri_> "ID"
03:18:50 <ttt_fff> hmm
03:18:58 <ttt_fff> taht's a weird module name
03:19:05 <Sindri_> ttt_fff: It's a variable name
03:19:11 <Sindri_> ttt_fff: getID is common for structs
03:19:27 <Sindri_> and it's not an abbreviation, at least to my knowledge, since "id" is a normal word
03:19:49 <liste> well, sometimes it's short for "identifier" or "identity"
03:20:38 <liste> and sometimes it's the Latin word "id"
03:20:58 <mauke[> sql code
03:21:24 <ttt_fff> gentlemen, we're talking Haskell code here
03:21:32 <ttt_fff> btw, speaking of sql, Opaleye is badass
03:21:37 <mauke[> SELECT * FROM BLARGH WHERE ZIBB IS NOT NULL;
03:21:51 <ttt_fff> Opaleye + Threepenny + Parsec = I want to do unspeakable things with building GUIs
03:22:08 <liste> Parsec?
03:22:28 <liste> what do you use it for there?
03:22:42 <ttt_fff> parsing stuff
03:22:45 * hackagebot codec 0.1.1 - First-class record construction and bidirectional serialization  http://hackage.haskell.org/package/codec-0.1.1 (PatrickChilton)
03:22:47 * hackagebot comonad 4.2.7 - Comonads  http://hackage.haskell.org/package/comonad-4.2.7 (EdwardKmett)
03:22:50 <ttt_fff> what else do you use parsec for?
03:22:57 <liste> what stuff?
03:23:03 <bergmark> ttt_fff: http://en.wikipedia.org/wiki/Template:LORD
03:23:19 <liste> some GUI DSL?
03:23:31 <ttt_fff> bergmark: how often do you have a module named LORD ? :-)
03:23:55 <bergmark> ttt_fff: not that often
03:23:56 <ttt_fff> liste: as I said, unspeakble stuff 
03:24:18 <liste> thus let it not be spoken of :D
03:24:39 <ttt_fff> liste: does liste come from mini-karen logic programming?
03:24:44 <ttt_fff> or was list[a-d] already taken?
03:24:48 <liste> nope
03:25:08 <liste> actually it is a sortened form of a Finnish (mild) swearword
03:25:25 <liste> (sortened as in made unrecognizable)
03:25:34 <liste> shortened*
03:30:16 <liste> but it has no meaning anymore, it's just a string of letters
03:31:30 <pavonia> It means "list" in German
03:32:53 <liste> good to know (: nice coincidence
03:47:47 * hackagebot keera-hails-mvc-model-protectedmodel 0.0.3.5 - Rapid Gtk Application Development - Protected Reactive Models  http://hackage.haskell.org/package/keera-hails-mvc-model-protectedmodel-0.0.3.5 (IvanPerez)
03:47:49 * hackagebot inline-c 0.5.3.2 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.5.3.2 (FrancescoMazzoli)
03:47:51 * hackagebot keera-hails-mvc-model-lightmodel 0.0.3.4 - Rapid Gtk Application Development - Reactive Protected Light Models  http://hackage.haskell.org/package/keera-hails-mvc-model-lightmodel-0.0.3.4 (IvanPerez)
03:49:05 <comprehension> are bytestrings used in OS-facing libraries for efficiency, or are there other reasons? 
03:52:03 <saulzar> comprehension, Yes, mainly for that reason
03:52:47 * hackagebot MissingK 0.0.0.2 - Useful types and definitions missing from other libraries  http://hackage.haskell.org/package/MissingK-0.0.0.2 (IvanPerez)
03:53:44 <comprehension> saulzar: alright, thanks. i was wondering if they offered some benefit for portability -- like bytes vs str in python
03:53:55 <saulzar> comprehension, Also I suppose for interfacing with C, given that bytestrings internally are just memory buffers..
03:57:47 * hackagebot gtk-helpers 0.0.7 - A collection of auxiliary operations and widgets related to Gtk  http://hackage.haskell.org/package/gtk-helpers-0.0.7 (IvanPerez)
03:58:01 <liste> comprehension in python bytes and str are for different purposes
03:58:10 <liste> bytes for binary, str for (encoded) texty
03:58:11 <liste> text*
03:58:33 <liste> in Haskell the analogy would be Text <-> ByteString or String <-> [Word8]
04:00:38 <Cale> comprehension: (Lazy) ByteString is essentially a more memory efficient version of [Word8]. String is [Char] which isn't really the same thing, as Char is unicode.
04:00:46 <Cale> > maxBound :: Char
04:00:49 <lambdabot>  '\1114111'
04:03:39 <ttt_fff> is there any nice way to do FRP with threepenny-gui ?
04:04:08 <saulzar> I thought that was the purpose of threepenny-gui.
04:04:41 <saulzar> Ah, no I've got my wires crossed.
04:07:01 <dbushenko> hi all!
04:07:13 <dbushenko> can anyone explain me what this thing means?
04:07:13 <dbushenko> infix 4 ==?
04:08:14 <Cale> dbushenko: That sets the precedence level for ==
04:08:55 <dbushenko> Cale, can you may be explain more? I'm trying to read the docs but simple don't understand what I'm reading
04:08:58 <Cale> For example, * has precedence level 7, so binds more tightly to its arguments than ==
04:08:59 <ttt_fff> in particular, it sets it to level 4
04:09:02 <Cale> and + has level 6
04:09:38 <dbushenko> aha, I think, I got it
04:09:40 <dbushenko> thanks!
04:10:22 <ttt_fff> Cale: say you're welcome :-)
04:10:38 <Cale> Heh, indeed, you are welcome :)
04:11:09 <ttt_fff> is there  "functional" way to do callbacks / modifying state?
04:11:19 <ttt_fff> so right now, I'm using threepenny (Browser as GUI) as my UI
04:11:35 <ttt_fff> okay, so imagine a version of "show", where instead of a -> String we had a -> Dom Tree
04:11:50 <ttt_fff> so browserPrint :: a -> Dom Tree
04:12:10 <ttt_fff> now, imagine that I want callbacks on this DomTree .... this suddenly gets messy, I'm wondering is there is a "functional way" to specify how the callbacks work
04:12:48 * hackagebot xml-conduit-parse 0.1.0.0 - Streaming XML parser based on conduits.  http://hackage.haskell.org/package/xml-conduit-parse-0.1.0.0 (koral)
04:13:02 <Cale> Did you look at the stuff in Reactive.Threepenny? :)
04:13:16 <breadmonster> Cale: Do you know how I can check if happy is in my path?
04:13:48 <Cale> breadmonster: The mildly unsafe way is just to type 'happy' see if you get something
04:13:53 <liste> breadmonster in Haskell?
04:13:57 <liste> or command line
04:14:04 <ttt_fff> Cale: I have not.
04:14:10 <breadmonster> liste: I'm trying to install haskell-src-exts
04:14:11 <liste> in command line, "which happy" is safer
04:14:24 <mauke[> 'type -a happy' is best
04:14:28 <ttt_fff> I guess I am re-inventing frp.
04:15:01 <breadmonster> Cale liste mauke[: setup-Simple-Cabal-1.22.2.0-x86_64-linux-ghc-7.10.1: The program 'happy'
04:15:02 <breadmonster> version >=1.17 is required but it could not be found.
04:15:17 <liste> what about happy -v ?
04:15:59 <breadmonster> liste: The package isn't installed, but I'm talking about the Haskell package.
04:16:09 <mauke[> what?
04:17:14 <breadmonster> mauke[ Cale liste: Fixed it with `cabal install happy` :p
04:17:15 <Cale> ttt_fff: You might like Stephen Blackheath's explanation of what FRP is about, which touches on the similarities to the observer pattern, and how it solves issues that has.  https://www.youtube.com/watch?v=gaG3tIb3Lbk
04:17:53 <ttt_fff> Cale: that' a badass lastname
04:18:41 <breadmonster> Cale: Are latest versions of Cabal less explicit about what happens when you install a package?
04:18:55 <Cale> breadmonster: hm?
04:19:07 <Cale> breadmonster: In what way? If they are, I haven't noticed.
04:19:37 <Cale> breadmonster: Cabal has never handled executable dependencies, but I've heard someone is working on that.
04:19:46 <breadmonster> Cale: You know how cabal used to say that it's downloading this package and building it?
04:20:07 <breadmonster> Usually when it compiles a package on an install command, it tells me what file it's currently compiling.
04:20:14 <Cale> ... yeah
04:20:41 <breadmonster> Now it's just this.
04:20:51 <breadmonster> Resolving dependencies... Configuring haskell-src-exts-1.16.0.1... Building haskell-src-exts-1.16.0.1...
04:21:29 <breadmonster> I don't get which file it's compiling.
04:21:40 <breadmonster> Which is kinda annoying, I'd like to be able to track progress.
04:21:54 <Cale> which version?
04:22:22 <breadmonster> 1.22.0.0
04:22:38 <Cale> I'm using 1.22.3.0 and I see full compiler output
04:22:49 * hackagebot network-anonymous-tor 0.9.2 - Haskell API for Tor anonymous networking  http://hackage.haskell.org/package/network-anonymous-tor-0.9.2 (solatis)
04:22:58 <breadmonster> I used to use 1.18.0.0 and I still got fully compiler output...
04:23:07 <ttt_fff> can I get go-like UI-model in haskell?
04:23:10 <breadmonster> How do you upgrade cabal? I don't exactly recall.
04:23:31 <Cale> Configuring haskell-src-exts-1.16.0.1... Building haskell-src-exts-1.16.0.1... Preprocessing library haskell-src-exts-1.16.0.1... [ 1 of 22] Compiling Language.Haskell.Exts.Annotated.Syntax ( src/Language/Haskell/Exts/Annotated/Syntax.hs, dist/build/Language/Haskell/Exts/Annotated/Syntax.o )
04:23:33 <Cale> etc
04:23:53 <breadmonster> Cale: Exactly that, I want that but I don't seem to get it.
04:23:56 <Cale> ttt_fff: No idea what go-like refers to
04:24:19 <Cale> breadmonster: Are you sure it's not just slow?
04:24:35 <Cale> breadmonster: This first module takes a rather long time to compile
04:24:46 <breadmonster> Cale: Certain, I asked it to build haskell-src-exts and it spit out nothign.
04:24:56 <Cale> and it finished?
04:25:14 <breadmonster> It finished yes.
04:25:16 <Cale> hm
04:25:18 <dredozubov> can i automatically install haddock offline documentation with cabal install?
04:25:41 <bitonic> dredozubov: `documentation: True` in `~/.cabal/config`
04:25:42 <Cale> dredozubov: yes, in ~/.cabal/config set  documentation: True
04:26:10 <dredozubov> already did it
04:26:19 <dredozubov> where can i find compiled docs?
04:26:25 <dredozubov> i'm using sandboxes btw
04:27:34 <breadmonster> Cale: Weird error.
04:27:34 <breadmonster> https://paste.fedoraproject.org/228402/43333081/
04:27:36 <Cale> Hm, not sure for sandboxes, but for other stuff, it's in ~/.cabal/share/doc
04:27:38 <bitonic> dredozubov: `~/.cabal/share/doc`, for sandboxes it's probably in a similar path but in the cabal sandbox folder
04:27:42 <breadmonster> ghc-mod won't compile.
04:28:12 <Cale> breadmonster: Which version of GHC are you using?
04:28:17 <dredozubov> breadmonster: there were some issues with ghc-mod, you should probably compile it from HEAD
04:28:29 <breadmonster> Umm, 7.10.1
04:28:30 <dredozubov> Cale: i'm guessing 7.10
04:28:33 <Cale> breadmonster: I don't think the released ghc-mod works with 7.10
04:28:42 <dredozubov> it works from HEAD
04:28:46 <dredozubov> i'm using it
04:29:00 <breadmonster> dredozubov: Okay, so how do I get it from HEAD and install it?
04:29:21 <dredozubov> breadmonster: just git clone it from github and do a cabal install
04:29:41 <dredozubov> then move binaries to whatever place you use them from
04:29:43 <breadmonster> dredozubov: Can you be a little more specific? I'm sorry, I'm not a programmer...
04:29:47 <dredozubov> probably ~/.cabal/bin
04:30:07 <dredozubov> do you know how to use git?
04:30:15 <breadmonster> Yeah, I can git clone it somewhere.
04:30:18 <dredozubov> https://github.com/kazu-yamamoto/ghc-mod
04:30:32 <dredozubov> just build it from master branch
04:30:45 <dredozubov> i think it'll be okay :)
04:30:51 <breadmonster> Okay, umm, I've never built things before?
04:30:54 <breadmonster> Do I just run make?
04:31:28 <dredozubov> you can do it with 'cabal install'
04:31:49 <breadmonster> dredozubov: So `cabal install ghc-mod`?
04:32:14 <dredozubov> no, git clone the repo into a folder, then execute 'cabal install' from it
04:32:26 <dredozubov> and you should probably use a sandbox just in case
04:32:36 <dredozubov> you can do it with 'cabal sandbox init'
04:32:50 * hackagebot keera-callbacks 0.1 - Mutable memory locations with callbacks  http://hackage.haskell.org/package/keera-callbacks-0.1 (IvanPerez)
04:33:18 <dredozubov> then cabal will place freshly built executables somewhere in dist folder and you'll be able to copy them to ~/.cabal/bin or whatever
04:33:28 <breadmonster> dredozubov: The dist folder?
04:33:32 <breadmonster> Okay, thanks, let me try.
04:33:44 <dredozubov> and there's an easy way, you can use ghc 7.8 for a time being
04:33:56 <dredozubov> ghc-mod will work fine with it
04:34:10 <breadmonster> You can't install two versions of ghc on the same PC right?
04:34:33 <dredozubov> it depends on your setup, so it's a bit specific for different OS's and such
04:35:02 <dredozubov> you can do it anyway, but it can be a pain sometimes
04:45:11 <breadmonster> dredozubov: Okay, I've compiled it,
04:45:22 <breadmonster> How do I install it to ~/.cabal/packages?
04:45:38 <dredozubov> you'll only need executables
04:45:49 <dredozubov> if want to use it with your editor, right?
04:45:59 <breadmonster> Yup.
04:46:03 <dredozubov> s/if/you/
04:46:08 <dredozubov> okay
04:46:47 <dredozubov> have you used inited a cabal sandbox before building?
04:47:03 <breadmonster> Yup.
04:47:08 <breadmonster> Done that, built too.
04:48:05 <dredozubov> i believe there should be an executables(ghc-mod, ghc-modi) within the dist/build folder
04:49:00 <breadmonster> dredozubov: There's two folders ghc-mod and ghc-modi
04:49:27 <dredozubov> please look inside, i don't remember the exact structure and can't check it right now
04:50:03 <dredozubov> but i think 'cabal install' is supposed to put them inside these folders
04:52:09 <breadmonster> Yup.
04:52:18 <breadmonster> I found the executable ghc-mod.
04:52:36 <dredozubov> great, just copy it to a place you want
04:52:48 <dredozubov> you're supposed to use these binaries in your editor
04:52:51 * hackagebot homplexity 0.3.0.0 - Haskell code quality tool  http://hackage.haskell.org/package/homplexity-0.3.0.0 (MichalGajda)
04:52:55 <dredozubov> ~/.cabal/bin for example
04:53:06 <dredozubov> and i think you'll be good to go
04:53:10 <breadmonster> Awesome.
04:53:11 <breadmonster> Thanks!
04:53:19 <dredozubov> no problem
05:00:32 <Ygrarr> Hello. I am learning Haskell fom some time, and I must admit that though I like the expressivity of the language, I find it hard to think about the efficiency of the code. It seems Haskell tries to put the job of optimization down to compiler, and the programmer's task is to go clearly and expressively from point A to goal B. Do you think it's the programmers job to write efficient code in Haskell, or should the code be optimzed by 
05:02:08 <breadmonster> Cale: In a pattern match, can the compiler change the order in which things are matched?
05:02:17 <breadmonster> Or does it go top down?
05:02:33 <breadmonster> Because I've got overlapping cases.
05:02:51 <afiskon> Ygrarr, don't worry, you get used to it eventually
05:03:43 <mauke[> breadmonster: top down
05:04:20 <breadmonster> mauke[: and it sticks with the first match?
05:04:25 <mauke[> yes
05:04:31 <breadmonster> Not the best match?
05:04:31 <Cale> breadmonster: The patterns are in priority order, top down. This doesn't mean the compiler isn't allowed to second guess you about which order it actually tries them in, but it's not allowed to produce a different result from if it really did try them top down.
05:04:34 <breadmonster> Okay then cool.
05:04:43 <mauke[> breadmonster: there isn't even a metric for "best"
05:04:46 <thebnq> Ygrarr: surely its situational
05:06:56 <Ygrarr> afiskon: Well, the lazyness seems to be the main culprit, but yeah, you can get used to it. It just seems that when I program in C/C++, i move bytes from one place to another and I know exactly what should happen. In Haskell.. not so. I get an impression from tutorials that I should focus on using higher order functions to get from point A to B, and not to bog myself down with details.
05:07:12 <mauke[> Ygrarr: you need to develop new intuitions
05:07:31 <mauke[> which is hard
05:11:21 <comprehension> is there a nice way to make some kind of "resettable counter" with reactive banana?
05:11:32 <Ygrarr> thebnq: Okaay... well, the problem I have right now is optimizing a Monte Carlo algorithm for calculating a PI number. I've got the best performance using Data.Vector.Unboxed and System.Random.MWC (it's on par with C/CPP), but there's a problem with this solution, mainly the usage of data structures. I use vectors for storing integers, where 1 is hit, 0 is miss. I sum this vector to get the number of hits. And this vector later need
05:12:14 <comprehension> resettable monoid, i guess. i want it to collect all of the output of one event up until another event fires, spit it out, and reset itself to mzero
05:12:29 <Ygrarr> Now I've tried to use some kind of tail recursion (on which I found that ghc does it's magic there), but this solution is worse than one before.
05:12:52 * hackagebot dns 2.0.0 - DNS library in Haskell  http://hackage.haskell.org/package/dns-2.0.0 (KazuYamamoto)
05:13:23 <lyxia> Ygrarr: Your previous message was cut off.
05:14:12 <Ygrarr> repeating: thebnq: Okaay... well, the problem I have right now is optimizing a Monte Carlo algorithm for calculating a PI number. I've got the best performance using Data.Vector.Unboxed and System.Random.MWC (it's on par with C/CPP), but there's a problem with this solution, mainly the usage of data structures.
05:14:19 <Ygrarr> I use vectors for storing integers, where 1 is hit, 0 is miss. I sum this vector to get the number of hits. And this vector later needs to be garbage collect
05:14:52 <Ygrarr> garbage collected*
05:14:58 <Geraldus> Hi friends! What is correct separator for multiline LANGUAGE pragma?
05:15:18 <mauke[> Geraldus: separator?
05:15:22 <thebnq> Ygrarr: go on
05:15:50 <Geraldus> mauke[: emm, should I say delimiter?
05:16:03 <mauke[> what are you talking about?
05:16:17 <mauke[> also, what's a multiline LANGUAGE?
05:16:53 <Geraldus> hmm. I'm confused, I was told that LANGUAGE pragma could be multiline. Is it false?
05:17:16 <Ygrarr> thebnq: Well, the garbage collecting part makes this algorithm not that scalable. I've thought that using tail recursion could help, but in fact it did perform worse. Maybe I've done it wrong, so I guess I'll post the code here, with images from threadscope.
05:17:36 <mauke[> Geraldus: you can use as many lines as you want. pragmas aren't line oriented
05:17:46 <mauke[> {-#
05:17:48 <mauke[> LANGUAGE
05:17:51 <mauke[> HelloWorld
05:17:52 <mauke[> #-}
05:18:43 <Geraldus> mauke[: so, if I have several options I should separate them by comma?
05:19:01 <thebnq> Ygrarr: it sounds like it might just be a thunk leak
05:19:06 <mauke[> Geraldus: yeah
05:19:21 <mauke[> e.g. {-# LANGUAGE FlexibleContexts, NoMonomorphismRestriction #-}
05:19:38 <Geraldus> mauke[: thanks!
05:20:14 <Geraldus> BTW, where can I see all possible pragmas such as WARNING, DEPRECATED and etc.?
05:20:35 <KaneTW> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/pragmas.html
05:20:48 <Geraldus> KaneTW: thank you
05:22:28 <mauke[> > {-# LINE 123 "this is how it goes" #-} )
05:22:31 <lambdabot>  this is how it goes:122:28: parse error on input ‘)’
05:23:09 <mauke[> > {-# LINE 1 "this is how\nit goes" #-} )
05:23:11 <lambdabot>  this is hownit goes:0:29: parse error on input ‘)’
05:32:03 <mauke[> > {-# LINE 1 "Can't locate Haskell.pm in @INC (@INC contains: /etc/perl /usr/local/lib/perl/5.14.2 /usr/local/share/perl/5.14.2 /usr/lib/perl5 /usr/share/perl5 /usr/lib/perl/5.14 /usr/share/perl/5.14 /usr/local/lib/site_perl .) at -e line 1.           " #-} )
05:32:08 <lambdabot>  Can't locate Haskell.pm in @INC (@INC contains: /etc/perl /usr/local/lib/per...
05:32:08 <lambdabot>      parse error on input ‘)’
05:32:12 <mauke[> cool cool
05:34:14 <Ygrarr> thebnq: Okay, so it's this part of the code: http://lpaste.net/1115689300701216768 and these are the threadscope images: http://imgur.com/a/wJgfT
05:42:54 * hackagebot keera-hails-reactive-fs 0.0.3.3 - Haskell on Rails - Files as Reactive Values  http://hackage.haskell.org/package/keera-hails-reactive-fs-0.0.3.3 (IvanPerez)
05:43:50 <thebnq> Ygrarr: a memory profile is probably more helpful than threadscope for this
05:44:40 <thebnq> Ygrarr: but i think your recursive version isn't tail recursive so thats building up
05:45:51 <albeit_> Is "foo :: BarClass a => Bar a -> Baz" equivalent to "type MyBar a = BarClass a => Bar a; foo :: MyBar -> Baz"?
05:47:45 <xj54y> Hello World!
05:47:54 * hackagebot keera-hails-reactive-gtk 0.0.3.5 - Haskell on Gtk rails - Reactive Fields for Gtk widgets  http://hackage.haskell.org/package/keera-hails-reactive-gtk-0.0.3.5 (IvanPerez)
05:48:17 <liste> albeit_ is that even legal?
05:48:27 <dramforever> xj54y: the world is helloed, and the world hellos you
05:48:36 <dramforever> lol grammar :)
05:48:54 <albeit_> liste: I thought it was? Are typeclasses not allowed in type declarations?
05:49:23 <geekosaur> they don't work as expected, and the Haskell98 syntax for them was removed in Haskell2010
05:49:31 <geekosaur> niotably, you need *both* of those in H98
05:49:54 <geekosaur> (pattern matching does NOT bring a typeclass from a data declaration into scope, unless you use a GADT)
05:50:25 <xj54y> I'm currently suffering from ecstatic bliss, and would certainly be very please if hoogle could be installed through cabal properly. http://paste.debian.net/196807/ Currently running GHC 8.4 on Debian 7.8;
05:50:29 <geekosaur> so no, not equivalent
05:50:40 <liste> http://stackoverflow.com/questions/22945348/why-class-constraint-in-type-synonym-needs-rankntypes
05:51:01 <thebnq> Ygrarr: also, why are you building up a Vector of Ints, if you're summing up 'hits', this vector doesn't need to be built
05:51:41 <liste> it seems like a side effect of GHC's RankNTypes
05:51:44 <hexagoxel> xj54y: where did you get that ghc? i want! :p
05:51:45 <albeit_> geekosaur, liste: Thanks, so no shortcut... I need to include the class constraint in the functin definintions
05:52:03 <geekosaur> or use GADTs
05:52:31 <albeit_> Okay, gotta refresh myself on those
05:52:37 <xj54y> hexagoxel, oh, 7.8.4.. Also, Debian 7.8.. Hehe
05:52:53 <exio4> some things need RankNTypes just because they aren't legal vanilla Haskell
05:52:55 * hackagebot keera-hails-reactive-wx 0.0.3.3 - Haskell on Rails - Reactive Fields for WX widgets  http://hackage.haskell.org/package/keera-hails-reactive-wx-0.0.3.3 (IvanPerez)
05:53:28 <exio4> (even thought they are rank1)
05:53:49 <liste> albeit_ it seems to be a shortcut after all http://stackoverflow.com/questions/24381064/class-restriction-for-type-synonyms
05:54:04 <exio4> type Number a = Num a => a ; f :: Integer -> Number a ; f = fromInteger 
05:54:10 <thebnq> Ygrarr: perhaps what i mean is, I'm not sure if you're aware of vector fusion; I'm not sure if they can fuse through the IO monad either
05:57:55 * hackagebot keera-hails-reactive-yampa 0.0.3.3 - Haskell on Rails - FRP Yampa Signal Functions as RVs  http://hackage.haskell.org/package/keera-hails-reactive-yampa-0.0.3.3 (IvanPerez)
05:57:57 * hackagebot keera-hails-reactive-network 0.0.3.3 - Haskell on Rails - Sockets as Reactive Values  http://hackage.haskell.org/package/keera-hails-reactive-network-0.0.3.3 (IvanPerez)
05:58:04 <Ygrarr> thebnq: I heard about the term, but I haven't researched it yet. Do you know any tutorials on this ?
06:00:37 <hexagoxel> xj54y: the first error suggest that you install `happy`. i usually use cabal for that, but it is available in the repos as well
06:01:59 <xj54y> hexagoxel, while I'm already fairly happy, I'll go ahead and do that. :-)
06:02:32 <Ygrarr> thebnq: I still have a hard time wrapping my head around tail recursion in Haskell, especially when monads are present. Some people say it's more reasonable to reason about recursion using thunks. Anyway, I'm on my way doing memory profile
06:02:35 <xj54y> hexagoxel, in the meantime, goa and lambdabot are installed, but where would lambdabots' home directory reside?
06:02:55 * hackagebot keera-hails-reactive-polling 0.0.3.3 - Haskell on Rails - Polling based Readable RVs  http://hackage.haskell.org/package/keera-hails-reactive-polling-0.0.3.3 (IvanPerez)
06:02:55 <thebnq> Ygrarr: no, but in this case i suspect the problem with monteCarloPIsIO is you're returning a vector (which will later be summed)
06:02:57 * hackagebot keera-hails-mvc-view 0.0.3.3 - Haskell on Gtk rails - Generic View for MVC applications  http://hackage.haskell.org/package/keera-hails-mvc-view-0.0.3.3 (IvanPerez)
06:03:04 <xj54y> hexagoxel, looking in ~/.cabal/bin, nothing useful is found
06:03:27 <thebnq> Ygrarr: if you sum it inside there, the fusion should probably elimanate any vector creation at all
06:04:20 <thebnq> Ygrarr: and be compiled to a loop that makes a random number, calls monteCarlo, and then adds to a total count
06:04:46 <hexagoxel> xj54y: did you install in a sandbox?
06:04:52 <Ygrarr> thebnq: So in other words I have to contain certain operations in functions, so they can be optimised ? If I use them at higher level they won't be optimised ? 
06:05:03 <xj54y> hexagoxel, I'm going to assume, "no"
06:05:09 * xj54y heads to google
06:05:19 <thebnq> Ygrarr: or rather, certain operations to be grouped together
06:05:58 <thebnq> Ygrarr: for instance, 'map f . map g' can get rewritten as 'map (f . g)'
06:06:36 <Ygrarr> thebnq: And the first option will remain unoptimised, but the second one will be optimised ?
06:06:53 <thebnq> no no, that is the optimization
06:07:52 <dramforever> I guess there will be a thing called "inline" working
06:07:55 * hackagebot keera-hails-mvc-view-gtk 0.0.3.3 - Haskell on Gtk rails - Gtk-based View for MVC applications  http://hackage.haskell.org/package/keera-hails-mvc-view-gtk-0.0.3.3 (IvanPerez)
06:07:58 * hackagebot keera-hails-mvc-controller 0.0.3.3 - Haskell on Gtk rails - Gtk-based controller for MVC applications  http://hackage.haskell.org/package/keera-hails-mvc-controller-0.0.3.3 (IvanPerez)
06:07:58 <Ygrarr> Err... now I'm lost. What is the optimization ?
06:08:35 <thebnq> if you wrote 'map f . map g' then the compiler knows it can rewrite that as 'map (f . g)'
06:08:36 <xj54y> hexagoxel, correction, "yes"
06:08:49 <thebnq> Ygrarr: its a really trivial one
06:08:59 <hexagoxel> .cabal-sandbox/bin/lambdabot
06:09:25 <xj54y> hexagoxel, double-correction with peer-review, "no".
06:09:44 <xj54y> Sorry, i'll fix that. :-p
06:09:55 <hexagoxel> no idea then, i never (successfully) installed lambdabot. the hackage package is just an executable, so a successful install really should produce one.
06:10:38 <Ygrarr> thebnq: I mean.. I am quite surprised that if I use monteCarloPIsIO and toPI in one function the compiler won't try to optimise it. I use both functions here: http://lpaste.net/8976622338883715072
06:10:38 <thebnq> Ygrarr: the other thing to watch out for is recursion returning functions like (+) like monteCarloPIsRec'
06:11:08 <xj54y> hexagoxel, seemingly, lambdabot was installed without error.. To where is a mystery (somewhere in /usr/local?) Any way to search for its whereabouts?
06:11:42 <dramforever> xj54y: does running lambdabot work?
06:11:47 <dramforever> from the command line
06:11:52 <bananagram> find . -name lambdabot
06:11:53 <srhb> xj54y: If you installed it as your own user, it should not be somewhere other than in your home directory
06:11:53 <hexagoxel> xj54y: doesn't cabal print the location at the end?
06:12:13 <dramforever> I'll guess ~/.cabal/bin/lambdabot
06:12:48 <xj54y> I've installed it as my own user, but it's not in ~/.cabal/bin/ :(
06:12:56 * hackagebot keera-hails-mvc-environment-gtk 0.0.3.3 - Haskell on Gtk rails - Gtk-based global environment for MVC applications  http://hackage.haskell.org/package/keera-hails-mvc-environment-gtk-0.0.3.3 (IvanPerez)
06:12:58 * hackagebot keera-hails-mvc-solutions-gtk 0.0.3.3 - Haskell on Gtk rails - Common solutions to recurrent problems in Gtk applications  http://hackage.haskell.org/package/keera-hails-mvc-solutions-gtk-0.0.3.3 (IvanPerez)
06:13:28 <srhb> xj54y: How exactly did you install it? Just cabal install lambdabot?
06:13:32 <thebnq> Ygrarr: try inlining toPI into monteCarloPIsIO
06:13:39 <xj54y> srhb, that's correct
06:13:48 <srhb> xj54y: Are you sure there were no errors during installation?
06:14:47 <xj54y> srhb, oh, I missed the error. *sigh*
06:14:52 <srhb> xj54y: :)
06:15:09 <xj54y> Cabal==1.22.3.0/installed-f81..., ghc => Cabal==1.18.1.5/installed-1d6...) 
06:15:55 <Ygrarr> thebnq: I did the same benchmark on StdGen (System.Random) by trying two recursive functions. They both work with the same speed. (But then again that might be my bad understading on how to optimize recursion)
06:16:17 <Ygrarr> forgot the code : http://lpaste.net/5375561478327762944
06:16:59 <Ygrarr> and monteCarlo (x,y) = if y < sqrt (1.0 - x^2) then 1 else 0  
06:17:56 * hackagebot keera-hails-mvc-solutions-config 0.0.3.3 - Haskell on Gtk rails - Easy handling of configuration files  http://hackage.haskell.org/package/keera-hails-mvc-solutions-config-0.0.3.3 (IvanPerez)
06:18:21 <xj54y> more errors http://paste.debian.net/196939/
06:18:48 <Tuplanolla> Is the equivalent of C's BUFSIZ defined somewhere?
06:19:14 <srhb> xj54y: Plenty of fun things there. The easiest and first is to install happy.
06:19:48 <xj54y> srhb, yes, Happy was installed, but.. Surely there's an error I missed. Retrying
06:19:59 <srhb> xj54y: Is it in $PATH ?
06:20:00 <joehh> Hi, I'm trying to use digestive functors with the formlets defined at run time in a list
06:20:06 <joehh> http://paste.debian.net/196941/
06:20:50 <joehh> Normally,  iuse a pattern like: DataType <$> form1 <*> form2 <*> form3
06:20:52 <xj54y> srhb, it's certainly in ~/.cabal/bin
06:21:03 <srhb> xj54y: But is that on your $PATH ?
06:21:09 <xj54y> srhb, yes
06:21:13 <joehh> but I'm not sure how to turn a list into something like that (applicative?)
06:21:13 <srhb> xj54y: Curious.
06:21:48 <srhb> xj54y: What's its version?
06:22:16 <xj54y> srhb, Happy? 1.19.5
06:22:19 <srhb> xj54y: That can't be it, 1.17 is ancient
06:22:19 <dramforever> Tuplanolla: do you want to use hSetBuffering?
06:22:21 <srhb> Yeah.
06:22:55 <Tuplanolla> No. It's for Network.Socket.ByteString, dramforever.
06:22:56 * hackagebot keera-hails-i18n 0.0.3.3 - Rapid Gtk Application Development - I18N  http://hackage.haskell.org/package/keera-hails-i18n-0.0.3.3 (IvanPerez)
06:22:59 <srhb> xj54y: What does cabal list happy say?
06:23:40 <geekosaur> Tuplanolla, there is nothing like BUFSIZ and even in C that is no longer meaningful; the best buffer size tends to depend on the filesystem
06:23:45 <xj54y> Default available version: 1.19.5 \ Installed versions: [ Unknown ]
06:23:56 <thebnq> Ygrarr: you fixed the acc problem in monteCarloPIsRec' , but it might just need some strictness, you might want to read https://wiki.haskell.org/Foldr_Foldl_Foldl%27
06:24:08 <joehh> I suspect there is a lot wrong with what I pasted above, but the bit I am struggling with is turning the list into an applicative thing
06:24:12 <geekosaur> I'm not sure if we expose pathconf anywhere...
06:24:32 <Ygrarr> thebnq: ok, thanks!
06:24:40 <geekosaur> (and that wouldn't help for non-files...)
06:26:47 <nkar`> I have a function like this: eq = (\n -> toInteger (n :: Int) == (n :: Integer)) :: (forall a. Integral a => a) -> Bool  is there a way to define a similar function (in pseudocode) eq' = (\(m :: a) n -> toInteger (n :: a) == (n :: Integer)) where m determines the type of n?
06:27:22 <srhb> xj54y: To be completely sure, writing happy --version on the command line works?
06:27:52 <geekosaur> nkar`, I think the only way you can do that is multiparameter type classes with either functional dependencies or associated type families
06:28:44 <dramforever> well, I guess you can, using that thing called ScopedTypeVariables
06:28:52 <dramforever> nkar`: ^
06:28:57 <nkar`> dramforever: see above
06:28:59 <nkar`> I already use it
06:29:12 <xj54y> srhb, Happy Version 1.19.5 Copyright (c) 1993-1996 Andy Gill, Simon Marlow (c)
06:29:13 <nkar`> it doesn't work, however
06:29:19 <dramforever> wait let me try
06:29:27 <srhb> xj54y: No idea then.
06:29:33 <nkar`> dramforever: it won't work without an explicit type signature
06:29:44 <nkar`> because it needs RankNTypes
06:29:56 <nkar`> but I don't know what signature is required in this case
06:30:17 <xj54y> srhb, going to through and explicitly setting paths, cleaning caches, and strying to make room for cleanliness before hell arises. Sec
06:33:50 <dramforever> nkar`: I think I got it to compile
06:34:01 <dramforever> but it's a 2 liner
06:34:15 <nkar`> could you paste it?
06:34:19 <dramforever> eq :: forall a. Integral a => a -> (forall t. Integral t => t) -> Bool
06:34:19 <dramforever> eq m n = toInteger (n :: a) == (n :: Integer)
06:35:04 <srhb> xj54y: A few more ideas. Did you accidentally specify ~/.cabal/bin in your PATH instead of $HOME/.cabal/bin ?
06:35:15 <nkar`> dramforever: nah, that's not correct
06:35:22 <nkar`> dramforever: m here is simply ignored
06:35:38 <nkar`> dramforever: and has no connection to n
06:36:33 <xj54y> srhb, ~/.profile has the path set as $HOME/.cabal/bin and I've also exported the path as such. 
06:36:46 <dramforever> nkar`: I don't think the pseudocode you posted does not have m ignored
06:36:49 <liste> dramforever, to make sure the `a` in the second line is the same `a` in the first line, you need ScopedTypeVariables
06:36:55 <srhb> xj54y: *boggle*
06:37:17 <dramforever> liste: yes, search for ScopedTypeVariables in the log
06:37:21 <dramforever> I know about it
06:37:45 <liste> sorry, I missed it
06:39:04 <nkar`> dramforever: please re-read again what I wrote if you really want to help.  of course it's ignored in my pseudocode.  that's because I don't know how to express it.  otherwise, there would be no reason to ask here.
06:39:04 <xj54y> srhb, hmm... For cabal install hoogle, the error doesn't appear anymore for Happy
06:39:26 <srhb> xj54y: So what are you left with now?
06:40:15 <dramforever> nkar`: ouch...sorry about that
06:40:44 <dramforever> you want m to determine a
06:40:51 <dramforever> right?
06:41:27 <xj54y> srhb, the first error is telling me that libHStransformers-0.4.3.0.so cannot be opened as it doesn't exist (or may not be found whereever it's being sought), and respectively, fails to install vector, mwc-random, and uniplate
06:41:35 <xj54y> srhb, should I reinstall transformer?
06:41:56 <srhb> xj54y: I really don't know. First step would probably be to start trying all this in a sandbox instead, just to be sure.
06:42:11 <dramforever> nkar`: sorry...I have no idea how to do that...
06:42:37 <dramforever> that's somewhat embarrassing 
06:43:46 <xj54y> srhb, cabal: The following packages are likely to be broken by the reinstall *sigh*
06:44:00 <srhb> xj54y: Make a sandbox first.
06:45:01 <nkar`> dramforever: hm, this typechecks: let eq' = (\(m :: a) n -> toInteger (n :: a) == (n :: Integer)) :: Integral b => b ~ a => b -> (forall a. Integral a => a) -> Bool  but it complains when I try eq' (0::Int) 30 30
06:45:44 <dramforever> nkar`: the function you have takes 2 args, but you gave it 3
06:46:04 <nkar`> lol, right
06:48:46 <nkar`> (though, I'm not sure whether it does what I expect)
06:50:03 <nkar`> oh, yeah, it does work!
06:50:11 <nkar`> eq' (42::Int) (-9223372036854775809) => False
06:50:18 <nkar`> eq' (42::Integer) (-9223372036854775809) => True
06:51:17 <xj54y> srhb, oh, just noticed the version difference in cabal from ~/.cabal/bin and /usr/local/bin :|
06:51:25 <xj54y> srhb, investigating
06:51:35 <mspo> xj54y: wow are you still up and working? :)
06:51:42 <srhb> xj54y: Should not be a problem as long as your user version is first on the PATH
06:51:52 <dramforever> nkar`: oh, you wanted to do that thing!
06:51:58 <xj54y> mspo, absolutely. I've gotta get this working. There's no other way.
06:52:00 <Tuplanolla> How can I change the way GHCi handles SIGUSR1?
06:52:09 <nkar`> dramforever: is this a known trick?
06:52:13 <mspo> nkar`: because Int is 32bit bound, right?
06:52:21 <nkar`> mspo: yeah
06:52:26 <nkar`> it's minBound - 1
06:52:42 <mspo> nkar`: interesting that it's False instead of some kind of error, but I guess it makes a kind of sense
06:52:49 <mspo> the haskell kind of sense
06:53:02 <nkar`> why should be an error?
06:53:14 <nkar`> overflows don't throw errors currently
06:53:20 <nkar`> which is bad
06:53:21 <dramforever> overflow exception
06:53:27 <mspo> I don't know, seems dangerous
06:53:29 <dramforever> I guess that's way too slow
06:53:34 <xj54y> srhb, I'm pretty sure the local version precedes the user version.. Having exported it explicitly, it seems the local version is called anyway. I'll fix that
06:53:55 <dramforever> :t (maxBound :: Int) + 1
06:53:56 <lambdabot> Int
06:54:00 <dramforever> ouch
06:54:06 <nkar`> mspo, dramforever: there's safeint package, fwiw
06:54:10 <dramforever> > (maxBound :: Int) + 1
06:54:12 <lambdabot>  -9223372036854775808
06:54:20 <dramforever> > succ (maxBound :: Int)
06:54:22 <nkar`> (this trick is partly borrowed from the testsuite)
06:54:22 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
06:54:32 <nkar`> that's succ, not Int
06:54:39 <nkar`> see the succ doc 
06:54:50 <nkar`> it should throw an exception in this case
06:54:56 <nkar`> same for pred
06:55:02 <dramforever> no...just something interesting
06:55:12 <hexagoxel> xj54y: if your cabal supports sandboxes, you can use a script [1] to install a pre-defined set of executables in separate sandboxes, all into ~/.cabal/bin. [1] https://github.com/lspitzner/cabal-exec-install
06:55:30 <dramforever> Check this:
06:55:33 <dramforever> @hackage loops
06:55:33 <lambdabot> http://hackage.haskell.org/package/loops
06:55:39 <nkar`> dramforever, mspo: there's a relevant thread on the glasgow-haskell-users list
06:55:44 <xj54y> hexagoxel, yes, I'm working on that ;-)
06:55:49 <nkar`> if you want to know about other corner cases
06:56:01 <hexagoxel> xj54y: and i have used that on debian as well before.
06:56:04 <dramforever> wait no no no no don't check that
06:56:22 <dramforever> This:
06:56:24 <dramforever> @hackage loop
06:56:25 <lambdabot> http://hackage.haskell.org/package/loop
06:56:44 <dramforever> "For Int, (+1) is almost twice as fast as succ because succ does an overflow check. "
06:59:34 <saulzar> > pred $ (maxBound :: Int) + 1
06:59:36 <lambdabot>  *Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
07:00:36 <albeit> Is there a simple way to lift a monad stack into IO? Like "State s () -> StateT s IO ()"
07:01:11 <quchen> albeit: mmorph lets you do that
07:01:16 <quchen> ?hackage mmorph
07:01:16 <lambdabot> http://hackage.haskell.org/package/mmorph
07:01:35 <dramforever> albeit: if you had MonadState m => m () then you could easily do it
07:02:17 <albeit> dramforever: The monad is actually RWS, so it has MonadState
07:03:03 <dramforever> albeit: Actually, what I meant was you can easily lift if your original one is polymorphic enough
07:03:47 <albeit> quchen: Ah I think I found the right function. generalize :: Monad m => Identity a -> m a. That should work, yes?
07:04:10 <quchen> albeit: hoist generalize -- or something along those lines. The docs give a pretty good example.
07:04:11 <albeit> dramforever: I'm not quite following?
07:04:35 <dramforever> albeit: forget about it...just use mmorph
07:04:45 <albeit> Alright ;)
07:07:32 <mettekou> I have already asked this question in here, but does anyone know of any resources on building a compiler for a simple imperative language in Haskell? I have already written a front-end using Alex and Happy, but I am stuck on type checking and generating three address code.
07:10:22 <srhb> mettekou: I think you'll find more resources in Haskell that don't use Alex and Happy.
07:10:27 <srhb> mettekou: ie. the parser combinator approach
07:10:59 <mettekou> srhb: I know, but sadly I'm not allowed to use Parsec or a similar library.
07:11:05 <srhb> Oh well.
07:12:40 <quchen> Implementing your own parser for a small language isn't hard.
07:12:56 <dramforever> mettekou: Just my own opinion, could be wrong: I guess you could just write it like in any other language
07:13:03 <quchen> It won't be as powerful as Parsec of course, but it gets simple parsing done.
07:13:22 <srhb> quchen: I think the point is that parsing is already done
07:13:28 <quchen> Oh.
07:13:29 <dramforever> yep +1 for that
07:14:07 <magneticDuck> mettekou: a simple imperative language?
07:14:10 <magneticDuck> like br**nfuck?
07:14:13 <magneticDuck> ^^
07:14:51 <srhb> magneticDuck: I don't think brainfuck is typed?
07:15:04 <magneticDuck> oh, you didn't mention it had to be typed
07:15:25 <srhb> magneticDuck: The qyestion is how to do type checking. :)
07:15:49 <dramforever> srhb: Just...Interpret it?
07:16:02 <magneticDuck> I mean.. if your type system is "either a number or a function that takes a list of numbers and returns a number"
07:16:06 <magneticDuck> then type checking is.. not difficult
07:16:49 <dramforever> wait...I think I just wrote a type checker for STLC a while ago (no type inference)
07:17:10 <dramforever> ouch...dude...
07:17:39 * dramforever opened STLC.hs in nautilus and saw wine ghci pop out
07:18:11 <ion> mettekou: You're allowed to use alex+happy but not parsec? Seems a bit arbitrary to me.
07:19:12 <mettekou> magneticDuck: It's a really limited subset of C, with char and int primitives and array type constructors. No structs, unions or pointers and no for loops.
07:21:58 <dramforever> here: I once made this type checker for STLC, but I think it's extremely unelegant and could be improved a lot: http://lpaste.net/133494
07:23:00 * hackagebot hPDB 1.2.0.4 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.2.0.4 (MichalGajda)
07:29:58 <chishiki> has anyone seen any examples of self modifying code in haskell?
07:36:06 <maerwald> chishiki: you mean meta-programming like in ruby?
07:37:05 <chishiki> maerwald: yeah i guess. modified during execution
07:38:48 <maerwald> I'm personally not aware of such a thing
07:39:37 <mauke[> chishiki: I've seen modify source + invoke ghc + re-exec self
07:39:48 <magneticDuck> chishiki: there are xmonad-like things, like Dire
07:44:44 <xnyhps> I did something recently which did: read line of code, write to file with some template, compile with ghc, load .o using dynamic-loader. Basically just a REPL.
07:48:17 <chishiki> i had in mind modify source while running without the re-exec. i dont think that is possible in haskell tho
07:49:54 <c_wraith> chishiki: it can be done.  But it's got some tricky points in a strongly-typed language.  You can't assume types are compatible just because they have the same name.
07:49:57 <geekosaur> not in full generality. there's ghc-api which can access a ghci-like environment (and hint which is a convenience wrapper for that)
07:50:28 <c_wraith> chishiki: and you can't just pretend they are the same, because that violates the guarantees haskell is supposed to provide
07:50:46 <mauke[> you can modify the source without re-exec; it just won't do anything
07:50:48 <c_wraith> chishiki: so you have to ensure that state that survives a reload contains no types that are reloaded.
07:50:48 <geekosaur> but the ghci environment is distinct from the program's own
07:53:37 <OutlawStar> what would be the best (generic) way of going from some monad 'm' that does IO to the actual IO monad. ie something like m (a, s) -> IO (a, s)
07:54:08 <mauke[> depends on m
07:54:41 <mauke[> it can't be generic because some monads want input, some produce extra output, some do both
07:55:25 <OutlawStar> for example m is of type Foo (StateT FooState IO a)
07:56:44 <mauke[> :t runStateT
07:56:46 <lambdabot> StateT s m a -> s -> m (a, s)
07:56:56 <OutlawStar> is it possible to then wrap 'm' further say "Bar StateT s m a" and put some constraint on m that i can get to the underlying IO value
07:56:59 <mauke[> wants extra input (s), produces extra output (s again)
07:57:15 <mauke[> there is no underlying IO value; StateT is a function
07:57:28 <Ainieco> hello
07:57:31 <mauke[> you can get an IO value out by applying it to different arguments
07:58:29 <OutlawStar> i guess what I am wanting is like an anti lift so instead of wrapping, I need an unwrapping mechanism
07:58:56 <mauke[> that's runStateT
07:59:27 <Ainieco> reading this now https://github.com/RaphaelJ/friday-report/blob/master/3.%20A%20typed%20image%20processing%20framework.md#type-families and wondering
07:59:30 <Ainieco> why he even need typefamily for this? look doing the same without TF https://gist.github.com/anonymous/49f2d64a050dd73a8bb6
08:00:00 <OutlawStar> right, but is there something monad type constraint i can put on 'm' so that I know its possible to do runStateT on it?
08:02:03 <mauke[> you can use runStateT if m = StateT S for some S
08:03:03 <OutlawStar> hmm, ok I'll think about it some more, thx
08:06:25 <Ainieco> anyone?
08:09:55 <geekosaur> Ainieco, you can do very simple things that way but not more complex ones. like, say, writing functions that work on either (a,a) or (a,a,a)
08:17:10 <Ainieco> geekosaur: ah that's what he meant, thanks
08:25:32 <DoubleWeasel> Hi I have a theory question
08:25:48 <DoubleWeasel> jcoalgebras are Functor f => a -> f a
08:26:26 <DoubleWeasel> monads are Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
08:26:55 <DoubleWeasel> why do we call them monads and not commands if they're about composing coalgebras
08:27:11 <DoubleWeasel> s/commands/comonads/
08:29:03 <DoubleWeasel> ha, or "mposing algebras"
08:45:00 <m4lvin> is there a way to check if a Data.Map is injective without sorting and grouping the values?
08:48:05 * hackagebot snap 0.14.0.5 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.14.0.5 (DougBeardsley)
08:53:05 * hackagebot ghc-tcplugins-extra 0.1 - Utilities for writing GHC type-checker plugins  http://hackage.haskell.org/package/ghc-tcplugins-extra-0.1 (ChristiaanBaaij)
09:03:06 * hackagebot web-plugins 0.2.8 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.8 (JeremyShaw)
09:03:08 * hackagebot ghc-typelits-natnormalise 0.3 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.3 (ChristiaanBaaij)
09:03:19 <joneshf-laptop> > let xs = M.fromList [(1, '1'), (2, '2')] in M.size xs == (M.size . M.fromList . fmap swap $ M.toList xs) -- m4lvin 
09:03:21 <lambdabot>  True
09:03:28 <joneshf-laptop> > let xs = M.fromList [(1, '1'), (2, '1')] in M.size xs == (M.size . M.fromList . fmap swap $ M.toList xs) -- m4lvin 
09:03:30 <lambdabot>  False
09:03:42 <indiagreen> does anybody know a data structure which is like Map but with key aliases? basically just Map, but I want an additional operation “addKeyAlias :: k -> k -> Map k v -> Map k v”. This could be simulated by having a Map of keys to pointers and another Map of pointers to values, but is there something simpler?
09:05:03 <DoubleWeasel> indiagreen: you want a map where more than one key updates the same entry?
09:05:10 <indiagreen> DoubleWeasel: yep
09:05:54 <MarcelineVQ> I think that's called a DB :>
09:05:59 <hyPiRion> indiagreen: Make a Map k k on top, which you then resolve for lookups.
09:06:05 <DoubleWeasel> indiagreen: I think you need to use two maps if you want to be able to have log(n) time
09:20:35 <fragamus> so i kinda get how to proove something is a monad using the monad laws, but how exactly does that help me proove correctness
09:21:19 <rui> Anyone uses ihaskell? I am trying to get it running
09:22:36 <rui> Tried installing with ghc 7.10, cabal install in a folder with the stackage cabal.config (after pip install ipython[all]), but that's not working
09:23:02 <rui> Only with 7.8?
09:24:42 <harel_f> just use kronos haskell
09:25:06 <rui> harel_f: Googling that
09:25:45 <harel_f> mac only though : (
09:26:09 <rui> harel_f: Yep. Doesn't work for me. I don't leave apples half eaten
09:27:52 <rui> As a long user of Mathematica, I am reaaally hoping for a nice notebook haskell experience. I hope ihaskell works reasonably well...
09:30:22 <dedgrant__> fragamus: The question is, correctness of what? The laws only prove what they prove. Think about how this helps with assumptions when building larger abstractions.
09:35:34 <dedgrant> fragamus: For a concrete example, think about the ways in which the identity (return) ensures that an implementation does not change the meaning of the subsumed value. Without this law we might bind a different value than was generated with return. (surprise!)
09:38:08 * hackagebot doctest 0.10.0 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.10.0 (SimonHengel)
09:47:39 <comprehension> is there a nice way to make some kind of "resettable counter" with reactive banana?
09:48:09 * hackagebot atom 1.0.13 - An EDSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.13 (LeePike)
09:56:51 <dfeuer> glguy, unfortunately, there seems to have been some miscommunication. Your answer to my SO question retraces my steps, and doesn't reach the point where I ran into trouble.
09:57:57 <comprehension> saulzar and R0b0t1: my connection dropped, sorry
09:58:58 <zipper> What can I use to get the name of the .cabal file in the current working directory?
09:59:12 <zipper> I don't want to use the name of the current working directory to get it.
09:59:27 <dolio> ls *.cabal
10:00:21 <zipper> dolio: In the code?
10:00:28 <dolio> What code?
10:00:30 <zipper> I think I should use regex
10:00:54 <zipper> I want to get the name of the cabal file so that I can read it with readFile
10:03:08 <dolio> I'm not familiar enough with the directory API to recommend something if you're in Haskell.
10:05:28 <dedgrant> zipper: Take a look at System.Directory.findFilesWith
10:07:52 <comprehension> ghci
10:07:59 <comprehension> ['A'..'z']
10:08:07 <zipper> dedgrant: thanks
10:09:44 <fragamus> rui: Regarding Mathematica, some kind of symbolic solver is essential to programming. I wish I could use Solve[] in haskell. What I end up doing is using Solve in Mathematica, and then using a common subexpression analyzer to generate code that can be translated to haskell.
10:09:49 <koala_man> comprehension: the tr command has the same weird behavior, caused by the locale's collation order
10:11:02 <fragamus> rui: the thing we want is the most concise representation in our source code, not a bunch of incomprehensible subexpressions.
10:11:24 <m4lvin> joneshf-laptop: thanks!
10:12:23 <fragamus> rui: so I kind of wish we could start with liskell and then work on sybolic manipulation
10:13:46 <joneshf-laptop> m4lvin, basically you want to know if the map is a bijection, so you can probably find a more elegant way with that knowledge
10:14:07 <fragamus> rui: http://clemens.endorphin.org/ILC07-Liskell-draft.pdf
10:15:48 <Guest19406> ?
10:16:49 <Guest19406> anybody familiar with the new lens-based Snap configuration?
10:17:08 <Guest19406> i "upgraded" snap, and now can't figure out the conifg ... :(
10:17:26 <[k-> i may have found a bug in ghci's literate haskell parser
10:17:49 <mightybyte> Guest19406: You have to import Control.Lens yourself now.  We stopped re-exporting it.
10:18:11 * hackagebot clash-prelude 0.8 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.8 (ChristiaanBaaij)
10:20:46 <Guest19406> mightybyte: thanks.I got that far, but I honestly don't understand the new style.   jus trying to set 'hcCompiledSplices' has me stumped!
10:21:43 <mightybyte> Guest19406: Why don't you come into #snapframework.
10:22:18 <Guest19406> mightybyte: will do.
10:23:11 * hackagebot clash-lib 0.5.6 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.5.6 (ChristiaanBaaij)
10:28:12 * hackagebot clash-vhdl 0.5.5 - CAES Language for Synchronous Hardware - VHDL backend  http://hackage.haskell.org/package/clash-vhdl-0.5.5 (ChristiaanBaaij)
10:28:14 * hackagebot clash-verilog 0.5.5 - CAES Language for Synchronous Hardware - Verilog backend  http://hackage.haskell.org/package/clash-verilog-0.5.5 (ChristiaanBaaij)
10:30:00 <[k-> do i really have to register an account?
10:30:13 <[k-> apparently i cant log in as guest on the bug tracker
10:31:08 <srhb> [k-: The GHC bug tracker? I think even registrations might be disabled currently.
10:32:04 <[k-> hmm
10:32:15 <johnw> quick, log it as a bug!  oh, wait... :)
10:32:40 <[k-> well i'll test the bug again and post it here for someone to do something about it :/
10:32:56 <srhb> [k-: That's a good approach! Although you might be able to register these days again, I'm not sure. :)
10:33:12 * hackagebot clash-systemverilog 0.5.5 - CAES Language for Synchronous Hardware - SystemVerilog backend  http://hackage.haskell.org/package/clash-systemverilog-0.5.5 (ChristiaanBaaij)
10:33:14 * hackagebot homplexity 0.4.0.0 - Haskell code quality tool  http://hackage.haskell.org/package/homplexity-0.4.0.0 (MichalGajda)
10:33:16 * hackagebot clash-ghc 0.5.7 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.5.7 (ChristiaanBaaij)
10:33:43 <[k-> oh apparently it works as expected :/
10:34:04 <[k-> so, ghc is free from a bug! \o/
10:35:22 <srhb> [k-: Woo! 
10:48:43 <jaseemabid> What is the name of the `<-` operator in do notation? Also `>>` in monad? 
10:48:53 <glguy> dfeuer: You around?
10:49:03 <dfeuer>   glguy, yeah, for now.
10:49:42 <glguy> dfeuer: Check that agda output again, I added an theorem to the end
10:49:52 <glguy> might be more what you were looking for
10:50:11 <dfeuer> glguy, I have the feeling some much deeper work on rotations may be necessary, which, if true, makes this whole project rather more horrible. However, I haven't quite given up on the Vect approach, and using (i ** index v i = x) as a location in a vector....
10:50:32 <dfeuer> Oh, you did a bunch more.
10:50:50 <dfeuer> Like I said, I was hoping more for direction than a full answer.
10:50:56 <dfeuer> What direction did you go in?
10:51:04 <dfeuer> ^^ glguy
10:51:24 <Vektorweg1> which function gives time since program start? 
10:51:28 <glguy> dfeuer: Just look at the types and not the implementation for the direction. You need to write lemmas about the behavior of listSplit
10:51:45 <glguy> dfeuer: Direction without implementation is just as likely to be bad direction
10:52:23 <dfeuer> glguy, well, if you hadn't tried it, yeah :p. I thought about listSplit, but it seemed so wild with the Either at the end. I'll take a look at your types.
10:57:52 <zipper> Hmmm I'm experiencing something weird. Despite http://hackage.haskell.org/package/Glob-0.7.5/docs/System-FilePath-Glob.html#v:match
10:58:09 <zipper> I get the error that System.FilePath.Glob doesn't export match
11:00:42 <Welkin> it does not export match
11:00:47 <Welkin> it exports matchDefault
11:01:33 <pointed_set> jaseemabid: it's not an operator, its a syntax - the "a <- b; c" will be rewritten into "b >>= \a -> c"
11:02:21 <Welkin> zipper: import System.FilePath.Glob.Match
11:03:41 <Welkin> zipper: actually, it looks like it does export `match`
11:03:52 <Welkin> https://hackage.haskell.org/package/Glob-0.7.5/docs/src/System-FilePath-Glob.html
11:04:00 <Welkin> but you can import it directly
11:04:23 <Denommus> jaseemabid: I don't think >> has a name, it's just bind ignoring the argument
11:04:39 <zipper> Welkin: Where did you get the module ending with Match?
11:04:44 <Welkin> Denommus: (>>=) is `bind`, so I call (>>) "blind bind"
11:04:48 <Welkin> some people call it sequence
11:05:13 <Welkin> zipper: https://hackage.haskell.org/package/Glob-0.7.5/docs/src/System-FilePath-Glob.html
11:05:26 <Welkin> that imports System.FilePath.Glob.Match (match)
11:06:13 <zipper> Welkin: There is no System.FilePath.Glob.Match there is only System.FilePath.Glob
11:06:30 <Welkin> jaseemabid: `<-` is pronounced "from", as in "x from xs" (x <- xs)
11:06:34 <zipper> and I have actually tried this. Also I have read the list of packages on hackage
11:06:59 <Welkin> zipper: https://hackage.haskell.org/package/Glob-0.7.5/docs/src/System-FilePath-Glob-Match.html#match
11:07:42 <zipper> That's not an exposed module :(
11:08:07 <Welkin> perhaps you can update your version of System.FilePath/Glob
11:08:23 <Welkin> because this one obviously exports `match`
11:08:27 <Denommus> I don't understand how fixIO doesn't produce a deadlock
11:10:12 <mniip> Denommus, the dangerous land of lazy io
11:10:19 <zipper> Welkin: Have you actually tried this?
11:10:31 <Welkin> zipper: tried what?
11:10:44 <Welkin> I see the export in the source for Glob 0.7.5
11:11:20 <mniip> Denommus, we lazily read the value of an MVar
11:11:42 <mniip> then (lazily) apply a function with it
11:11:49 <mniip> and write the result into the MVar
11:12:14 <mniip> we got a demand loop
11:12:17 <Denommus> mniip: could I emulate the same in a strict language?
11:12:26 <mniip> but until the result is actually demanded, nothing actually executes
11:12:46 <mniip> Denommus, this is sorta similar to circular linked lists
11:13:21 <mniip> Denommus, you mean in an imperative language?
11:13:35 <Denommus> mniip: no, it can be functional. But strictly evaluated, like ML
11:14:41 <mniip> Denommus, not without a thunk subsystem I guess
11:14:52 <mniip> or future/promise, maybe
11:16:58 <Denommus> mniip: hm. "Thunk" is how OCaml calls unit -> 'a functions
11:17:06 <Denommus> mniip: is it what you're talking about?
11:17:34 <mniip> Denommus, no, it's how lazy evaluation is implemented in general
11:17:55 <Denommus> mniip: what about the Lazy module?
11:18:02 <mniip> it is a structure that contains either an evaluated value, or a pointer to a function that will evaluate it
11:19:43 <mniip> isn't always a function though, I guess it's better to say it contains instructions for evaluating the value
11:20:14 <mniip> GHC for example has a ton of thunk types
11:32:00 <jaseemabid> pointed_set: I never understood how <- or even >>= pulls the value out of the context. a
11:32:56 <jaseemabid> As in foo <- getLine 
11:34:07 <kadoban> :t (>>=)  -- <-- that's how, the type of  >>= defines what it does
11:34:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:34:19 <kadoban> (And the rules for how 'do' notation is desugared)
11:35:13 <nschoe> Damn, for a second I thought it was lambdabot who was explaining this. It freaked me out ^^
11:35:50 <kadoban> XD
11:36:03 <geekosaur> it may not actually "pull" the value up; for a monad like Maybe it does, for IO it appends to a computation; for list it pulls *all possible* values out
11:36:18 <geekosaur> which makes the whole "pulls out" idea questionable
11:36:50 <}> Hey, why does it say 'Not in scope: data constructor ‘State’', when I try to manually create a State without using return? (it works fine with return)
11:37:21 <kadoban> }: Is it in scope? Import it from Control.Monad.State
11:37:33 <}> kadoban, It's imported... otherwise retun wouldnt have worked either
11:37:43 <kadoban> 'return' is in Prelude
11:37:53 <kadoban> (Isn't it? Pretty sure)
11:37:58 <nschoe> }, maybe you just imported "State" and not "State(..)" ?
11:38:03 <}> uhh
11:38:18 <xj54y> System.IO.UTF8 is no longer a part of utf8-string?
11:39:00 <jaseemabid> geekosaur: That helps. 
11:39:03 <}> I'll elaborate, I was looking at example #1 here : https://wiki.haskell.org/State_Monad , and tried to change it a bit to see if I understand it, getScore (_, score) = return score -- works fine, but not getScore (_, score) = State $ \s -> (score, s)
11:40:10 <geekosaur> that example is out of date
11:40:17 <}> uhh
11:40:20 <geekosaur> State is a type synonym, not a data constructor
11:40:29 <geekosaur> use `state` (lowercase instead of titlecase)
11:40:34 <}> ok
11:40:44 <}> wow that worked
11:40:55 <}> thanks geekosaur 
11:43:41 <pointed_set> jaseemabid: you cannot pull a value out, you can only extend the context; there is no general way escape from an arbitrary monad
11:44:37 <pointed_set> jaseemabid: try to program using the (>>=) operator
11:46:52 <ew> hello
11:47:15 <xj54y> Hello again.. running cabal install lambdabot in my sandbox (ghc 7.8.4; debian 7.8 i386), I get the following error http://paste.debian.net/197739/  Any ideas?
11:47:45 <ew0> I want to make a function to permutate lists inside lists
11:47:58 <Welkin> jaseemabid: practice de-sugaring do-notation by writing it using explicit bind and lambda
11:48:03 <ew0> then I want to access each of the possible permutations
11:48:13 <Welkin> :t permutations
11:48:15 <lambdabot> [a] -> [[a]]
11:48:23 <ew0> this helps me with the first part
11:48:34 <ew0> map permutations l
11:48:45 <ew0> leaves l the way I want
11:49:02 <Pamelloes> Is there a way to create a type A and a type B such that every A is a B but not every B is an A?
11:49:03 <Welkin> you can access each element of the resulting list by mapping over it
11:49:47 <ew0> ?
11:49:50 <Welkin> }: wow, you can use that as a nickname?
11:49:58 <}> Welkin, uhh
11:50:09 <mitchty> xj54y: not seen that, i setup stackage and installed lambdabot like so: cabal install djinn hoogle lambdabot-core/ lambdabot-trusted/ lambdabot-*-plugins/ lambdabot/ i'm on 7.8.4 and arm as a note
11:50:10 <}> yes?
11:50:24 <mitchty> now someones going to go for <*> as a nick
11:50:36 <}> that's not possible
11:50:39 <Welkin> }: it confused me at first, because I don't have visible brackets <> around the names in my window
11:50:58 <}> Welkin, Those brackets are very annoying, especially when I get highlighted as <}>
11:50:58 <joneshf-laptop> are there any matrix libraries that are typesafe and easy to use?
11:51:19 <johnw> Pamelloes: you could newtype B = B A, then B is really an A, but not every A is a B
11:51:46 <johnw> you will need to wrap/unwrap manually though
11:51:59 <ew0> Welkin, this almost does what I want: transpose $ map permutations [[1, 2], [4]]
11:52:14 <geekosaur> did someone already fix the wiki page? I just finally got it opened (local notwork hosage) and the only place that should have come up was already correct
11:52:17 <Welkin> ew0: what is it you want?
11:52:25 <ew0> [[[1,2],[4]],[[2,1]]] the first result is correct
11:52:26 <geekosaur> mitchty, they can't
11:52:33 <ew0> but I wanted [[[1,2],[4]],[[2,1], [4]]]
11:52:59 <geekosaur> historical thing, Scandinavian (!) ASCII extensions
11:53:13 <}> geekosaur, yeah, it's in the RFC
11:53:43 <geekosaur> yep, because IRC originated there so they wrote it into the standard
11:53:53 <ew0> [[1,2,4],[2,1,4]] would also be fine
11:54:35 <johnw> > permutations . concat $ [[1, 2], [4]]
11:54:37 <lambdabot>  [[1,2,4],[2,1,4],[4,2,1],[2,4,1],[4,1,2],[1,4,2]]
11:54:55 <ew0> johnw,  this gives me too mane permutations
11:54:58 <ew0> many
11:55:08 <}> is it possible to >>= into a "case x of ... " ?
11:55:13 <johnw> you didn't specify everything you needed then
11:55:15 <}> not sure if that makes sense
11:55:23 <ew0> yes, sorry
11:55:46 <ew0> I just want to permute the elements of internal list
11:55:47 <geekosaur> you use a lambda, or you enable the LambdaCase extension
11:55:56 <geekosaur> foo >>= \x -> case x of ...
11:56:00 <}> ah
11:56:00 <geekosaur> or with LambdaCase
11:56:10 <geekosaur> foo >>= \case ...
11:56:17 * } tries
11:56:31 <johnw> ew0: oh, I see what you mean
11:56:42 <ew0> xD
11:57:35 <johnw> > map concat $ sequenceA $ map permutations [[1, 2], [4]]
11:57:36 <lambdabot>  [[1,2,4],[2,1,4]]
11:57:40 <ew0> I want to color a graph where small groups of nodes have few possible assigned colors
11:57:47 <ew0> what?!?
11:57:53 <ew0> uhm
11:58:31 <monochrom> apparently, no one knows what you mean
11:58:40 <ew0> johnw,  knows
11:58:42 <ew0> and it works
11:58:45 <ew0> perfectly
11:58:50 <ew0> =D
11:59:03 <}> you realy like hitting enter don't you
11:59:18 <monochrom> then johnw is a scarce resource and monopoly on you
11:59:21 <ew0> but now, what if I wanted to permute the outside groups too?
11:59:32 <johnw> what would the outside groups be in this case?
11:59:46 <ew0> [1,2] and [4]
11:59:51 <ew0> so my results would be
11:59:56 <monochrom> economics dictates that therefore you should be paying him huge money.
12:00:17 <johnw> ew0 is lucky that acl2 is really slow on my proofs, so I need a distraction :)
12:00:28 <ew0> [[[1,2,4],[2,1,4]], [[2, 1, 4], [1,2,4]]]
12:00:36 <ew0> xD
12:00:57 <johnw> > permutations $ map concat $ sequenceA $ map permutations [[1, 2], [4]]
12:00:59 <lambdabot>  [[[1,2,4],[2,1,4]],[[2,1,4],[1,2,4]]]
12:01:00 <xj54y> Perhaps I missed a response but, having ran cabal install lambdabot in my sandbox (ghc 7.8.4; debian 7.8 i386), I get the following error http://paste.debian.net/197739/  Any ideas?
12:01:45 <ew0> thanks johnw 
12:01:52 <ew0> it looks so easy after its done
12:01:55 <Welkin> ah yes, the sequence trick to compute the cartesian product
12:01:55 <ew0> =D
12:01:58 <Welkin> one of my favorites
12:02:02 <johnw> ew0: doesn't it always? :)
12:02:14 <ew0> only when the solution is beautiful
12:02:30 <johnw> I have a suspicion that "map concat . sequenceA" has a more elegant formulation
12:03:18 <Welkin> johnw: is sequence in Prelude for 7.10 from Traversable?
12:03:25 <Welkin> I am still using 7.8
12:03:27 <johnw> Welkin: yes
12:05:05 <}> uh I guess you could replace map concat .sequenceA with just sequence?
12:05:35 <}> > permutations $ sequence $ map permutations [[1, 2], [4]]
12:05:38 <lambdabot>  [[[[1,2],[4]],[[2,1],[4]]],[[[2,1],[4]],[[1,2],[4]]]]
12:05:42 <}> ... close enough
12:06:11 <breadmonster> Hey guys.
12:06:34 <adarqui> how do I become as smart as ekmett?
12:06:51 <breadmonster> So I'm writing a lexer by hand and I have something along the lines of `data Token = Newline | Oper String | ID String | ...`
12:07:05 <breadmonster> and then `newtype Tokens = [Token]`
12:07:10 <breadmonster> Why is that illegal?
12:07:27 <breadmonster> This is what FPComplete says: src/Lexer.hs@45:18-45:25 parse error in constructor in data/newtype declaration: [Token]
12:07:29 <Pamelloes> johnw: Hm, the newtype solution is promising. I'd prefer to not half to wrap and unwrap, though.
12:07:36 <sinelaw> newtype Tokens = Tokens [Token]
12:07:41 <srhb> xj54y: Missing dependency on utf8-string ?
12:07:54 <breadmonster> sinelaw: Oh okay. Does that still serve as a typedef though?
12:08:02 <breadmonster> Or do I have to redefine all my constructors?
12:08:03 <sinelaw> not a typedef.
12:08:09 <srhb> xj54y: Oh wait, no. seems like a wrong upper bound.
12:08:11 <breadmonster> How do I pull off a typedef?
12:08:22 <sinelaw> type Tokens = [Token]
12:08:31 <srhb> xj54y: System.IO.UTF8 no longer exists in utf8-string as of version 1
12:08:36 <Pamelloes> johnw: I guess if I don't want to wrap/unwrap I'll basically be stuck using existentially quantified type classes.
12:08:42 <breadmonster> sinelaw: Great.
12:08:46 <srhb> xj54y: So put a bound on it, 0.3.8 is the last one to have that module.
12:08:55 <sinelaw> with extreme pleasure
12:08:56 <breadmonster> I wish FPComplete had an IRC pane.
12:09:14 <johnw> > map concat $ traverse permutations [[1, 2], [4]]
12:09:16 <lambdabot>  [[1,2,4],[2,1,4]]
12:09:16 <sinelaw> you could tile your windows
12:09:16 <johnw> slightly better
12:09:20 <srhb> breadmonster: Tile your windows!
12:09:22 <srhb> heh
12:09:28 <breadmonster> Does Michael Snoyman inhabit this channel?
12:09:36 <johnw> breadmonster: as snoyberg, but rarely
12:09:37 <sinelaw> I don't think so
12:09:56 <breadmonster> srhb: I'll just reboot into Linux and open Emacs :P
12:10:16 <srhb> breadmonster: :-)
12:10:25 <adarqui> breadmonster: ever use tmux?
12:10:56 <breadmonster> adarqui: I've heard of it, but I don't use vim.
12:11:00 <adarqui> oo
12:11:07 <}> breadmonster, ... what
12:11:17 <breadmonster> I'm an emacs fan, so I just happen to have another buffer with irssi or erc open.
12:11:20 <srhb> It's not that odd, the vim + tmux movement is pretty strong.
12:11:40 <breadmonster> }: emacs is...cooler?
12:11:55 <breadmonster> Naw kidding, I like Swiss Army knives that can do everything.
12:11:56 <hiptobecubic> Let's not start 
12:11:59 <}> breadmonster, the statement didn't make sense... "I've heard of apples, but I don't use blenders"
12:12:51 <breadmonster> }: Oh okay, well most people I know who use vim also use tmux to run things side by side, like ghci and irssi
12:12:58 <kadoban> Out of curiosity, are there -O levels that do anything beyond 2, on GHC?
12:13:05 <hiptobecubic> How does FPComplete make any money? Consulting?
12:13:19 <Pamelloes> breadmonster: how do ghci and irssi work together?
12:13:20 <breadmonster> hiptobecubic: I think they charge for the commercial use of their IDE.
12:13:31 <hiptobecubic> breadmonster, they are orthognal tools, but as srhb mentioned, they are used together often so you weren't way off base.
12:13:42 <srhb> Nah, the others are just being pedantic. :)
12:13:58 <breadmonster> Pamelloes: They don't, but it's nice to run them in parallel, ghci for the easy questions and irssi for the hard ones.
12:14:11 <koala_man> it feels very satisfying to add another 9 though
12:14:24 <breadmonster> koala_man: 9% speed gain?
12:14:26 <hiptobecubic> all you really need is lambdabot :)
12:14:42 <breadmonster> You'd soon kick me out if lambdabot inferred types for me...
12:14:56 <koala_man> I mean turn -O9 into -O99
12:15:02 <hiptobecubic> breadmonster, you can /query it directly
12:15:05 <breadmonster> koala_man: lol
12:15:06 <Pamelloes> ^
12:15:20 <}> hiptobecubic, doesn't seem to work for me :-(
12:15:48 <breadmonster> :t (>>=) (return . (f :: a -> b))
12:15:50 <lambdabot>     Ambiguous occurrence ‘f’
12:15:51 <lambdabot>     It could refer to either ‘L.f’,
12:15:51 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:175:1
12:15:57 <breadmonster> ARGH NO.
12:16:04 <breadmonster> :t (>>=) (return . (undefined :: a -> b))
12:16:06 <lambdabot> Monad m => (m a -> a1 -> b) -> a1 -> b
12:16:57 <breadmonster> > Just 3 >>= return . (+1)
12:16:59 <lambdabot>  Just 4
12:17:13 <breadmonster> is there an operator for that?
12:17:17 <breadmonster> I use it way too often.
12:17:25 <Taneb> fmap?
12:17:38 <Taneb> > fmap (+1) (Just 3)
12:17:39 <lambdabot>  Just 4
12:17:42 <Taneb> :)
12:17:53 <}> >(+1) <$> Just 3
12:18:01 <}> I don't know how this thing works... bah
12:18:07 <}> > (+1) <$> Just 3
12:18:09 <lambdabot>  Just 4
12:18:12 <}> there we go
12:18:28 <breadmonster> Taneb: Sorry, that was kinda stupid of me...
12:19:00 <breadmonster> }: yeah I realized that only post hoc.
12:19:07 <Taneb> breadmonster, don't worry about it :) we all miss things from time to time
12:19:07 <}> how do you /query or /msg lambdabot directly? it doesn't reply
12:19:19 <Taneb> /msg lambdabot > "test"
12:19:23 <}> won't reply to me
12:19:42 <}> oh damn I forgot a space after >
12:19:42 <Taneb> }, do you definitely have the >?
12:19:42 <breadmonster> }: You have a RFC breaking handle.
12:20:03 <}> sorry, it replies now... need to remember the space
12:20:08 <Taneb> :)
12:20:43 <breadmonster> > let (<}>) a b = a + b in 3 <}> 2
12:20:45 <lambdabot>  <hint>:1:7: parse error on input ‘}’
12:20:52 <breadmonster> }: damn.
12:21:45 <MarcelineVQ> omy
12:23:00 <geekosaur> breadmonster, that's a legal nick per the RFC
12:23:29 <breadmonster> geekosaur: Oh okay.
12:24:30 <c_wraith> help, my brain has gone empty.  What's the cabal option to set a specific version dependency?
12:25:20 <}> omg it worked
12:25:20 <johnw> --constraint I think
12:25:38 <}> twiddling around with the wiki state example, this works :O get >>= getScore >> (put (True, 1)) >> playGame xs
12:26:30 <c_wraith> johnw: thanks
12:26:34 <johnw> isn't the result of getScore there being thrown away?
12:26:59 <Jos3> Developing games here?
12:27:07 <}> Jos3, no it's just the example from the wiki
12:27:13 <}> johnw, sort of... :(
12:27:30 <johnw> that should be identical to just put (True, 1) >>playGame xs
12:28:03 <}> johnw, right, my next goal is to make getScore work like (on, score) <- get, where I can use on and score later on
12:28:53 <greymalkin> Hey, is there any tutorial/code showing how to get lens-like access to a Data.Map?
12:29:06 <johnw> greymalkin: "at" and "non" are your  firends
12:29:36 <Haskellfant> hm the links to the source in my local documentation doesn't seem to work. the src directory it points to doesn't exist. Do I need to generate them separately?
12:29:40 <johnw> > M.fromList [(1,"Hello"), (2, "World")] ^. at 1.non "Hmm"
12:29:41 <johnw> > M.fromList [(1,"Hello"), (2, "World")] ^. at 3.non "Hmm"
12:29:42 <lambdabot>  "Hello"
12:29:44 <lambdabot>  "Hmm"
12:30:07 <johnw> for setting, assign Nothing to drop the key, Just x to set the value at key to x
12:30:23 <ion> å/}: I like your nick.
12:32:02 <}> ion, thanks, I like your nick too.
12:33:20 * hackagebot DSH 0.12.0.1 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.12.0.1 (AlexUlrich2)
12:33:29 <}> johnw, shouldnt this work? get >>= getScore >>= (\(on, score) -> (put (on, score + 1))) >> playGame xs ... it results in a big scary compilation error
12:33:59 <johnw> is getScore of type a -> m b?
12:34:05 <}> yes
12:34:08 <johnw> or rather, a -> State s b
12:34:17 <}> for now its just ... getScore (_, score) = return score
12:34:23 <breadmonster> I'm trying to write a parser for a whitespace dependent language.
12:34:25 <johnw> ah
12:34:30 <breadmonster> Guide van Rossum is going to hell.
12:34:31 <johnw> show me the type error
12:34:31 <breadmonster> -.-
12:34:43 <breadmonster> *dependant
12:35:16 <}> johnw, http://termbin.com/0io4
12:35:33 <}> I don't understand why it thinks it's an Int
12:37:02 <johnw> what is the type of GameState?
12:37:12 <}> (Bool, Int)
12:37:16 <johnw> put is directly putting a tuple
12:37:20 <johnw> getScore is extracting a score
12:37:26 <johnw> your bind expects at uple
12:37:33 <johnw> remove getScore entirely and it should work
12:37:42 <johnw> also, you can do this:
12:37:57 <johnw> modify (\(on, score) -> (on, score + 1)) >>= playGame xs
12:38:09 <johnw> or, using lenses: _2 += 1 >> playGame xs
12:38:12 <kadoban> :t modify
12:38:14 <lambdabot> MonadState s m => (s -> s) -> m ()
12:38:15 <johnw> (sorry, >>= in that penultimate line)
12:38:25 <liveify> Anyone know of a good example of a JSON web api in haskell (any framework) with a database backend?
12:38:42 <johnw> modify (second succ) >> playGame xs
12:39:48 <}> oh I see, so modify is modify f = do { x <- get; put (f x) }
12:39:53 <johnw> yes
12:40:13 <}> I'm just trying many different things to see if I can grok the syntax
12:40:26 <Dynasty> Does anyone have any recommendations for books/learning resources for someone who has come from a functional programming background (SML and Erlang)?
12:41:06 <}> The typeclassopaedia on the wiki has a lot of resources... I'm going through it bit by bit myself
12:44:46 <Tuplanolla> Running cabal init generates a template for the build-depends field. How can I regenerate it?
12:45:31 <Haskellfant> delete the config & run cabal init again
12:45:42 <Haskellfant> not the config but the .cabal file
12:45:46 <Tuplanolla> Then I lose all the other fields too.
12:45:49 <Haskellfant> sure
12:46:02 <Tuplanolla> There has to be a nonstupid way.
12:46:04 <Haskellfant> if you don't remember the syntax either look at the documentation or just generate some dummy project
12:46:26 <Haskellfant> I don't think cabal will modify an already existing .cabal file
12:46:32 <johnw> it's interesting how many issues with cabal can be blamed on a bad state (i.e., reset and re-init), for a language whose strength is not relying on implicit state...
12:46:44 <ion> Instead of deleting, you could just rename.
12:46:50 <johnw> we need habal
12:47:02 <rui> Sigh. Installed ihaskell, but can't plot a thing, and it creates 2 ihaskell processes of near 1GB each when I do nothing
12:49:01 <breadmonster> Does anyone use FPComplete?
12:49:07 <breadmonster> How do I save this file?
12:49:30 <johnw> it should be "always saved", or do you mean exporting it?
12:50:56 <platz_> ihaskell is a bit fragile to install.  i got it working with ihaskell-0.6.0.0, ipython 3.0.0, and python 2.7.9
12:51:11 <platz_> ghc 7.10.1
12:51:50 <rui> If anyone around uses ihaskell. Does it always use up at least 800MB of memory after a single "2+2" operation?
12:52:24 <geekosaur> does it do so after every one, or only on the first thing it does?
12:52:40 <geekosaur> because the latter would probably be startup of the interpreter
12:52:45 <platz_> rui: what tool do you use to measure with?
12:53:18 <rui> platz_: i gave up on ghc 7.10 and got it working with 7.8. Gnome-system-monitor
12:53:55 <rui> geekosaur: First time only, but haven't tested much yet
12:54:25 <geekosaur> right, I'd assume the interpreter backend is started lazily and that's the overhead
12:54:53 <rui> A min ago tried a diagrams.pynb example and it didn't plot pluus there were always 2 ihaskell processes of about 1GB each
12:55:42 <rui> geekosaur: Ok, so we'll assume that's the base memory. Thanks
12:56:10 <platz_> yeah htop shows `ihaskell kernel` has 677M resident
12:56:32 <rui> platz_: I see.
12:57:15 <}> s/linuxatemyram/haskellatemyram
12:57:19 <Cale> That does seem a little bit crazy... a running ghci uses maybe 26 MB from the outset.
12:57:50 <kadoban> Is there some easy way to get a GHC program to not buffer output, or to line buffer instead of … block buffering or whatever it's doing by default?
12:57:57 <Cale> 800 MB is more than the entirety of a GHC installation.
12:58:14 <Cale> (and normally you wouldn't have that all in RAM)
12:58:17 <breadmonster> Night everyone!
12:58:21 * hackagebot Earley 0.8.1 - Parsing all context-free grammars using Earley's algorithm.  http://hackage.haskell.org/package/Earley-0.8.1 (OlleFredriksson)
12:58:27 <}> kadoban, I don't know how to do that in GHC, but it's easy to do it by using stdbuf
12:58:31 <rui> platz_: I am trying to get whatever thing to plot. Trying diagram $ circle 1. Getting this error:
12:58:31 <Cale> kadoban: System.IO.hSetBuffering
12:58:38 <rui> .ihaskell-diagram.png: hGetContents: invalid argument (invalid byte sequence)
12:58:44 <Cale> kadoban: hSetBuffering stdout LineBuffering
12:58:48 <rui> Does it ring a bell?
12:58:50 <Cale> kadoban: hSetBuffering stdout NoBuffering
12:58:57 <kadoban> Cale: Thanks much :)
12:59:11 <rui> I installed it in a sandbox and ran it with cabal exec ipython notebook
12:59:54 <platz_> rui: i think i gave up on diagrams due to issues with ihaskell-diagrams installing
12:59:59 <platz_> but i could get charts to work
13:00:37 <platz_> sandbox w/ ipython sounds scary
13:01:07 <dfeuer> Huh.... I don't know if I've encountered this before, but I decided I wanted it to help me with something, and I think it turns out actually to be true!
13:01:42 <rui> platz_: What would be not scary? I just used a sandbox because ihaskell didn't compile with stackage versions, and I didn't want to mess all my user repo
13:01:52 <dfeuer> Specifically, if f has a right inverse, and f is injective, then that right inverse is actually a two-sided inverse.
13:02:05 <rui> Perhaps that was stupid. I wonder how the non-newbies manage
13:02:53 <platz_> i avoided sandboxes because who knows what ipc stuff is going on.. try to minimize the moving parts
13:03:05 <platz_> though i know installing it is a pain
13:03:08 <platz_> have no good solutions
13:05:38 <athan> Does GHC use a separate library for Constraint solving?
13:07:28 <ew0> Is there a way to randomize a list in a lazy way?
13:08:24 <johnw> dfeuer: every injective function has a left-sided inverse, so if you also have a right-sided inverse, then: Proof. l = l∘id = l∘(f∘r) = (l∘f)∘r = id∘r = r.  ◻
13:08:43 <dfeuer> johnw, your premise is not constructively true.
13:10:40 <dfeuer> johnw, moreover, it's not even true in a classical context unless you know that certain sets are/are not inhabited.
13:14:37 <pavonia> ew0: By randomize you mean a random permutation of that list?
13:16:54 <Tuplanolla> How would that work, ew0?
13:17:34 <Tuplanolla> Could you tell how far the first element could travel for example?
13:18:49 <selestify> sup guys
13:18:56 <mmachenry> Does anyone know why I would be getting this error http://lpaste.net/133823  after building this project for Oracle bindings https://github.com/paulrzcz/takusen-oracle ?
13:18:57 <selestify> any projects yall working on?
13:19:17 <mmachenry> selestify: Working on an automated phone dialing system.
13:19:47 <selestify> ooh, what for?
13:20:33 <mmachenry> For calling our clients (who are medical practices) patients when the patients have an appointment coming up.
13:20:54 <mmachenry> Actually for all types of reasons. But reminders for appointments is like 75% of the calls
13:21:10 <arkeet> johnw: there's a much more straightforward proof :-)
13:21:23 <deech> Can I use an executable from a package as a build tool for another executable in that package?
13:21:43 <arkeet> johnw: also, any function from the empty set to a nonempty set is injective but has no left inverse.
13:22:40 <johnw> weird
13:22:52 <johnw> I'm finding proofs on the Internet that a function is injective iff it has a left-inverse
13:23:12 <arkeet> well they must be wrong!
13:24:21 <selestify> it's true in classical math, but not in constructive math apparently
13:24:23 <arkeet> classically that is true if the domain is nonempty.
13:24:47 <dolio> Left-inverse is stronger constructively. So one direction holds.
13:25:04 <arkeet> anyway, here's a neat proof.
13:25:17 <arkeet> observe that f is injective means that for any functions g and h, if f.g = f.h then g = h
13:25:25 <arkeet> now, suppose g is a right inverse of f, so f.g = id
13:25:37 <arkeet> then f.g.f = f = f.id, so g.f = id
13:27:01 <arkeet> well I guess it's not much different using points.
13:27:05 <dolio> At least, it seems stronger.
13:27:35 <dgpratt> as a long time VS user, I'm finding the concept of workspaces in leksah a little unclear
13:28:14 <dgpratt> do I want to create a new workspace for a new project?
13:28:49 <johnw> dfeuer: ok, seeing how this is not possible in Coq, I believe you :)
13:29:08 <dolio> The problem is that the usual statement of injectivity gives you something to do on the image of f, but not on anything else that may exist, and you can't just magic it up constructively.
13:29:14 <arkeet> dolio: doesn't it need the axiom of choice?
13:29:19 <johnw> injectivity alone tells me nothing about the left inverse
13:29:35 <dfeuer> johnw, yeah, constructive stuff is weird.
13:29:45 <arkeet> hm, maybe not.
13:29:48 <arkeet> I dunno.
13:30:02 <dolio> arkeet: Maybe.
13:30:11 <arkeet> ok, no I don't think so.
13:30:12 <arkeet> heh.
13:30:55 <dolio> I don't know how you make a function that does something arbitrary on the complement of the image of f.
13:31:02 <arkeet> that's the easy part.
13:31:06 <dolio> It is?
13:31:09 <johnw> given the left inverse, and injectivity, and the right inverse, then it's provably a twosided inverse in a constructive setting
13:31:15 <arkeet> you pick one element of the domain (using the fact that it's nonempty) and map everything to that.
13:31:22 <arkeet> I'm worried about the image of f.
13:31:37 <arkeet> well I guess that's easy too.
13:31:43 <arkeet> ok, no choice needed.
13:32:05 <arkeet> ok
13:32:07 <Tuplanolla> Am I alone in finding constructivism more intuitive?
13:32:18 <arkeet> say we have f: A -> B, where A is nonempty and f is injective.
13:32:40 <arkeet> just define a relation
13:32:43 <arkeet> well
13:32:43 <dolio> johnw: If you have a right inverse, you already have a nice B -> A candidate for the left inverse.
13:32:48 <dolio> So it's easier.
13:32:50 <arkeet> pick some element a of A, since A is nonempty.
13:32:54 <johnw> oh, wait
13:32:58 <johnw> never mind, I did just prove this constructively
13:33:04 <johnw> https://gist.github.com/f7209f48214866d2153f
13:33:15 <dolio> Tuplanolla: No.
13:33:17 <johnw> injective f -> cancel g f -> bijective f
13:33:35 <johnw> (where cancel g f confusingly means that g is a right-inverse of f)
13:34:28 <arkeet> then take the union of {(y,a) : y in B - image(f)} and {(y,x) : y in image(f), f(x) = y}
13:34:36 <arkeet> pretty sure that relation from B to A is a function.
13:34:54 <arkeet> uh, x ranges over elements of A.
13:34:58 <johnw> dfeuer: ^
13:35:01 <dolio> arkeet: What if A is empty?
13:35:05 <arkeet> I assumed it's nonempty.
13:35:08 <arkeet> obviously it's false if A is empty.
13:35:47 <arkeet> because there no functions B -> 0 if B is nonempty.
13:35:52 <Cale> Yeah, if A is empty, then the unique function f: 0 -> 1 is injective but has no left inverse.
13:36:40 <dolio> I guess the proofs johnw found also had that.
13:36:49 <arkeet> I want to say my proof is constructive but I'm not a good judge of that.
13:37:00 <arkeet> johnw you should do it.
13:37:09 <arkeet> f: A->B injective, A nonempty => f has a left inverse.
13:37:09 <dolio> It's definitely not constructive.
13:37:12 <arkeet> what part?
13:37:22 <dolio> The part where you decided whether something is in the image of f.
13:37:29 <arkeet> hm.
13:37:51 <arkeet> why not?
13:38:01 <dolio> Because you can't do that.
13:38:16 <johnw> arkeet: I can prove ∀ g, cancel f g -> injective f, but not injective f -> ∃ g, cancel f g
13:38:18 <Cale> Tuplanolla: It can be more intuitive in some ways, but there are weird things which go on with sets, especially at the small end of the spectrum. It's not in general the case that if you have a set S and some subset A of S, that S = A union S\A, because this property implies the law of excluded middle.
13:38:20 <dolio> It's LEM.
13:38:34 <arkeet> johnw: you need the domain of f to be nonempty
13:38:43 <Cale> and in this case, this is what prevents us from gluing together these graphs
13:39:01 <arkeet> alright.
13:40:43 <Tuplanolla> That's still better than having things that exist, but are impossible to find, Cale.
13:40:50 <Cale> It's very counterintuitive that you can take a set apart and not be able to put it back together again.
13:41:52 <dolio> arkeet: If you knew more about A and B you could do it. But not in general.
13:42:00 <arkeet> such as what?
13:42:14 <dolio> If A were finite and B had decidable equality, for instance.
13:42:34 <arkeet> what is decidable equality?
13:42:34 <Cale> Well, to some extent, yes. It's not that strange that we might want to talk about objects which are out of reach of finite specification, or out of reach of computation.
13:42:51 <Cale> But such objects are themselves pretty strange.
13:43:07 <johnw> arkeet: where testing equality gives me a witness for yes, or a witness for no
13:43:09 <dolio> arkeet: ∀ x y. x = y ∨ x /= y
13:43:26 <arkeet> ok
13:43:37 <arkeet> I think I see.
13:44:27 <dolio> arkeet: Maybe there are weaker conditions. Probably also depends on what axioms you consider constructive.
13:46:00 <Cale> Sometimes it's way more convenient not to have to live with this burden of everything needing to be computable -- some things really do work out more nicely on that side of the fence. But when you can get them, constructive proofs are more powerful and apply more broadly.
13:50:19 <dolio> You can go a long way sometimes by just not being sloppy with your premises.
13:50:30 <dolio> Like, if you want a left inverse, say you have a left inverse.
13:50:38 <dolio> Don't say that you have an injective function.
13:51:20 <Cale> As a concrete example, I've yet to see a constructive approach to the real numbers which wasn't at least twice as much hassle to work with as the classical approaches by Dedekind cuts or Cauchy sequences.
13:51:21 <dolio> If you want an element, say you have an element. Don't say there doesn't not exist an element.
13:52:24 <Cale> There's a beautiful approach in the HoTT book which uses a higher inductive-inductive definition, and that's quite nice, but the bookkeeping that follows gets a little hairy to say the least.
13:54:19 <Cale> (I am still really curious what happens when one removes some propositional truncations from that definition)
13:55:16 <Tuplanolla> Might take a while to get a grasp of that book.
14:00:34 <Cale> If you go to page 377, you can see the definition they use, where they simultaneously define the constructors for the Cauchy reals, and a certain notion of approximate equivalence on them (basically expressing when two real numbers are within some rational distance epsilon of one another) https://hottheory.files.wordpress.com/2013/03/hott-online-611-ga1a258c.pdf
14:03:55 <maerwald> amazing
14:07:55 <Cale> The basic definition is quite nice, and I think easy enough to follow if you already know what Cauchy sequences are about, but all the results proving things about it are so much trickier to obtain than the corresponding classical ones. You can introduce the classical constructions of the reals to first year university students, while I'd be quite afraid to do the same with any constructive approach.
14:08:08 <mustafa> Hey! I'm trying to figure out this damned type error. Pretty sure it comes from a misunderstanding of the State monad. Any help? http://lpaste.net/133825
14:08:38 <Cale> :t randomR
14:08:39 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
14:08:53 <Cale> ^^ randomR is not an action in the State monad.
14:09:34 <mustafa> But my state is g... How do I use randomR in the state monad?
14:09:40 <Cale> :t state (randomR (0,10))
14:09:42 <lambdabot> (Num a, MonadState s m, RandomGen s, Random a) => m a
14:09:52 <S11001001> mustafa: add a $ after return on line 23
14:10:30 <Cale> Applying the state function will turn it into one (basically the data constructor for the State monad, though mtl defines State via StateT so you don't get a real data constructor)
14:11:25 <sydneyhacker> Hi all, I have a question about modules: I have a module A and I want to implement some class instances for testing in module Test. The problem is I get warnings about Orphan Instances, and I don't like warnings!
14:12:00 <sydneyhacker> I am thinking if I could split a module across two files, one for the main code, one for the instances I need to implement for testing, that would be good.
14:12:18 <sydneyhacker> The class I need to implement is Arbitrary for quickcheck by the way
14:12:31 <mustafa> Huh...
14:12:33 <mustafa> Almost
14:12:37 <merijn> sydneyhacker: The way to avoid orphans is to either 1) define the instance in the same module as the datatype OR 2) implement the instance in the same module as the class
14:13:03 <merijn> sydneyhacker: The reason for the orphans warning is that classes must be globally unique, and avoiding orphans guarantees this
14:13:06 <rasen> If you really want organize your code in that way, just suppress warnings of this type
14:13:16 <Cale> An orphan instance is defined as one which doesn't meet one of those two conditions that merijn listed.
14:13:21 <merijn> Orphan's themselves aren't necessarily bad, but they're usually something to avoid
14:13:44 <merijn> Because if two people define an orphan instance for the same class + type combo, painful situations can occur
14:13:55 <mustafa> One more
14:13:55 <Cale> s/classes must be globally unique/instances must be globally unique/
14:13:56 <sydneyhacker> merijn: thanks, so I wonder, do people put generators in the same module (and therefore file?) as the 'production code'
14:13:59 <mustafa> http://lpaste.net/133825http://lpaste.net/133825
14:14:06 <mustafa> * http://lpaste.net/133825
14:14:11 <merijn> Cale: Well, classes too, I gues? :p
14:14:21 <merijn> Cale: Or can you qualify classes?
14:14:36 <Cale> You can qualify classes
14:14:47 <merijn> Sounds like a terrible idea, though :p
14:14:49 <Cale> (but yeah, that's sort of a bad idea)
14:15:02 <Cale> mustafa: You forgot to supply the StdGen argument
14:15:11 <dolio> I suspect most people don't put quick check instances in the production code.
14:15:47 <mustafa> Cale: What I don't understand is that i though state was automatically passed 
14:15:52 <Cale> sydneyhacker: I would happily put an Arbitrary instance alongside the definition of my datatypes.
14:16:08 <kadoban> Not really anything wrong with putting them there, is there?
14:16:10 <mustafa> I thought that what I have to give the state monad is functions in the form \s -> (a, s)
14:16:18 <mustafa> and it takes care of passing the state along
14:16:28 <Cale> sydneyhacker: Actually I really wish that Arbitrary/Coarbitrary and Gen were separated from the QuickCheck package, since they are extremely useful in their own right.
14:16:48 <Cale> mustafa: That's how State computations are implemented internally.
14:17:17 <Cale> mustafa: But it's only one possible implementation, and State computations are not literally functions.
14:17:18 <sydneyhacker> Cale: ok if that is idomatic Haskell. I am doctrined in how we do it where I work (in C#) we keep test code (and test helper code) seperate from production code. However I am willing to accept things are done differently in the functional programming world.
14:17:28 <mustafa> Like, I write   ptX <- state $ randomR (xMin, xMax)
14:17:41 <mustafa> I don't tell randomR the state
14:17:48 <mustafa> it is automatically sent in
14:17:48 <sydneyhacker> Because like you just said Arbitrary is useful in general. In C# you rarely yield artifacts that are useful beyond the case you use them for!
14:18:03 <dolio> sydneyhacker: I don't think most people do what Cale is saying. But I may be wrong.
14:18:05 <Cale> sydneyhacker: Well, yeah, it's slightly painful to have a dependency on QuickCheck just because you want to define an Arbitrary instance.
14:18:08 <tejing1> mustafa: I would make getCircularPoints a recursive monadic function, then write a wrapper for the first invocation that does fst . flip runState g $ innerFunction
14:18:12 <mustafa> why do I need to supply the state to my last line?
14:18:25 <sydneyhacker> dolio: What do most people do. I am hunting on Github now for some examples!
14:18:29 <Cale> It is pretty common to want to avoid that dependency really.
14:18:41 <dolio> sydneyhacker: I think most people only put them in their test suite code.
14:18:57 <dolio> Because they only want the test suite to depend on quickcheck, yeah.
14:18:57 <sydneyhacker> dolio: and they accept Orphan instances?
14:19:02 <dolio> Yes.
14:19:04 <Cale> sydneyhacker: You can happily write orphan instances in your test code.
14:19:05 <merijn> sydneyhacker: You can just silence the warning
14:19:32 <Cale> sydneyhacker: In the final executable, there's no worry about orphan instances -- only library code really needs to worry about them.
14:19:33 <dolio> Don't be a slave to -Wall.
14:19:37 <dolio> Too many people are.
14:19:42 <Cale> Yeah :S
14:19:42 <mustafa> tejing1: isn't that basically what I'm doing?
14:19:58 <sydneyhacker> if I could silence warnings for a single module that would be ace
14:20:13 <liste> there's always {-# GHC_OPTIONS -fno-warn-orphans #-}}
14:20:18 <tejing1> mustafa: so getCircularPoints g n = fst . flip runState g $ getCircularPoints' n where getCircularPoints' n = do {...;o <- getCircularPoints' n;return $ (stuff) : o}
14:20:26 <liste> it silences a warning for a single module
14:20:32 <liste> minus the other }
14:20:49 <sydneyhacker> liste thanks I will use that
14:21:00 <merijn> dolio: Well, everyone should use -Wall, but then selectively disable stuff
14:21:04 <sydneyhacker> thanks everyone for the discussion and the help on this. 
14:21:12 <Cale> sydneyhacker: The problem with orphan instances is what happens when you want to import two different modules which both define different instances of the same class for the same type. Since you can't control in any way which instances get imported from a module you use (they are unnamed so there's no way to refer to them in export/import lists), it can result in modules being unusable together.
14:21:13 <phaazon> hey, is there a way to match eof when using getLine?
14:21:14 <merijn> dolio: I do wish more errors could be silenced for, for example a single orphan instance
14:21:25 <phaazon> I’m running a loop and I’d like to test when getLine has hit eof
14:21:35 <TimoMeijer> What is the up-to-date alternative to the old Data.Array.Lens.ix?
14:21:37 <Cale> sydneyhacker: But if you're writing an executable and not a library someone else is going to import, that's not a concern.
14:21:42 <mustafa> I still don't understand why I don't need to pass state into my randomR functions but I do need to on the last line
14:21:51 <liste> sydneyhacker I correct myself, it's OPTIONS_GHC not GHC_OPTIONS
14:21:52 <sydneyhacker> Cale if I don't export it in the Cabal package, is it OK?
14:22:19 <pointed_set> phaazon:why you no getContents, then?
14:22:22 <rasen> phaazon: just loop over lines . getContents
14:22:24 <phaazon> oh
14:22:27 <phaazon> hIsEOF
14:22:38 <phaazon> rasen: when I hit eof
14:22:38 <sydneyhacker> because then only I need to worry about it in my code, but anyone using my package won't be affected
14:22:49 <phaazon> the program behavior might get undefined
14:22:50 <dolio> There's quite a bit of dumb stuff in -Wall, and people keep lobbying to put more in.
14:22:58 <dolio> Although it also has a lot of good stuff.
14:23:01 <Cale> sydneyhacker: Er, don't export what? You can have tests in your cabal package which are separate from the library itself, and put the orphans and anything depending on QuickCheck in there if you like.
14:23:03 <phaazon> hIsEOF may solve that
14:23:09 <tejing1> mustafa: it's because the function you want to recurse into has runState at the beginning
14:23:17 <pointed_set> phaazon: getContents terminates the list on eof
14:23:30 <rasen> phaazon: you wan't hit eof with lines . getContents
14:23:40 <sydneyhacker> Cale yes something like that would be good
14:23:44 <merijn> pointed_set: getContents has all the usual poblems of lazy IO, though
14:23:58 <pointed_set> materialize, then
14:24:00 <phaazon> pointed_set: yeah, but I need interleaved IO
14:24:07 <phaazon> I need to read a line, do something with it
14:24:09 <phaazon> read another line
14:24:12 <phaazon> and so on and so forth
14:24:13 <Cale> sydneyhacker: Another thing you can do is explicitly make a package containing the Arbitrary instances for your data types (necessarily as orphans then, but anyone depending on your package will be aware of that)
14:24:37 <rasen> phaazon: ok, then go with hIsEOF :)
14:24:41 <Cale> sydneyhacker: So as to help out anyone else who wants to QuickCheck things using your data types
14:24:48 <tejing1> http://lpaste.net/133825 sorry I assumed "edit" would create a new paste :-/
14:24:49 <pointed_set> phaazon: and you say, that getContents wont allow you read line-by-line?
14:25:08 <tejing1> mustafa: that should work
14:25:23 <Enigmagic> Cale: we need first class "tests" packages
14:25:28 <Cale> sydneyhacker: But yeah, this is why I think it would be nice for Arbitrary etc. to be separate from QuickCheck, because most people are pretty hesitant to have a testing framework as a dependency for library code.
14:25:40 <phaazon> pointed_set: well, it would read the whole file, I guess
14:25:44 <Cale> But random generation isn't necessarily only for testing.
14:26:18 <pointed_set> phaazon: Whole stdin?
14:26:26 <phaazon> yeah
14:26:27 <pointed_set> phaazon: its a lazy reader
14:26:39 <Cale> An Arbitrary instance is useful for a whole lot more than that in a lot of cases, and if not Arbitrary, then certainly some Gen computations for doing more specific sorts of random generation of values.
14:26:51 <sydneyhacker> Cale: yes that is true. I didn't want the dependency or the arbitrary code in the same module. However I could accepte the arbitrary code if I didn't think of it as 'testing code' and something more general.
14:26:52 <arkeet> is shrinking useful outside of testing?
14:27:38 <Cale> arkeet: I suppose shrinking is something which is a little more tied to testing than anything else there.
14:27:47 <dolio> Is that still baked into Arbitrary?
14:27:52 <Cale> I think it is
14:28:04 <dolio> Strange that they split out Coarbitrary and not that.
14:28:15 <Cale> Yeah
14:28:26 <Cale> The Coarbitrary split happened before shrinking existed, iirc
14:28:36 <mustafa> tejing1: thanks! I'm super confused but I'll look at this
14:28:42 <tejing1> mustafa: you could also shorten it and avoid binding o by making the last line "fmap (((ptX, ptY), label):) $ genCircularPoints' (n - 1)"
14:28:45 <mustafa> Cale: Thanks a lot!
14:28:58 <arkeet> TimoMeijer: lens still has ix, it's just generalized
14:29:02 <arkeet> TimoMeijer: see Control.Lens.At
14:29:13 <Cale> mustafa: If you want, we could go over how the State monad is defined...
14:29:14 <phaazon> hm
14:29:18 <phaazon> fmap lines getContents, then?
14:29:21 <phaazon> or maybe just interact?
14:29:22 <TimoMeijer> arkeet: Thanks!
14:29:23 <phaazon> I don’t know
14:29:27 <phaazon> well, not interact
14:29:32 <phaazon> I need side effects
14:29:56 <mustafa> Cale: I'll be back later -- I have to run away from my office before my head explodes.
14:30:06 <Cale> dolio: I sort of wonder if the Coarbitrary split happened solely because some people didn't want to take the time to understand what coarbitrary was :)
14:30:26 <dolio> Or take the time to write it even if they did.
14:30:40 <Cale> It's sad, because it's usually like a one-liner to define
14:31:23 <dolio> Yeah, well, oleg wanted to not make Functor => Monad for that reason. :)
14:32:40 <Cale> I can think of some reasons not to want Functor => Monad, but the tediousness of writing the definition isn't one of them :)
14:33:00 <arkeet> what reasons?
14:33:22 <Cale> Well, no, my concerns are really more about Applicative => Monad
14:33:28 * hackagebot catamorphism 0.5.1.0 - A package exposing a helper function for generating catamorphisms.  http://hackage.haskell.org/package/catamorphism-0.5.1.0 (frerich)
14:33:34 <merijn> Burn the heretic!
14:33:42 * merijn grabs a pitchfork
14:33:43 <Cale> So maybe I can't come up with a good reason
14:34:01 <arkeet> ok, what about Applicative => Monad?
14:34:13 <Cale> Don't get me wrong, I do actually think Functor should be a superclass of Monad :)
14:34:23 <arkeet> sure, I'm just interested to hear some reasons.
14:34:31 <arkeet> or arguments or whatever.
14:35:03 <Cale> Well, the concern there is that I've run into code in real settings where you have a library which wants to define both a Monad instance and an Applicative instance, but where the Applicative instance is not the one which trivially comes from Monad.
14:35:31 <merijn> Cale: That doesn't matter if they obey the laws, no?
14:35:50 <arkeet> that would confuse me as a user of the library.
14:35:52 <Cale> i.e. you have an applicative structure on the thing you're defining which is *more important* than (<*>) = ap and pure = return
14:36:11 <arkeet> is the monad instance more important than that?
14:36:13 <merijn> arkeet: I don't think he means incompatible ones
14:36:21 <merijn> arkeet: I think similar to ApplicativeDo?
14:36:23 <Cale> I do mean incompatible ones.
14:36:30 <merijn> Cale: Then just newtype?
14:36:37 <Cale> merijn: would ruin the library
14:36:49 <merijn> I'm going back to my earlier "Burn the heretic" statement
14:36:49 <arkeet> put the monad instance on the newtype?
14:37:04 <Cale> In the example I'm thinking of, I might just forgo the Monad instance altogether
14:37:16 <Cale> But it exists, so it might be nice to have it...
14:37:22 <arkeet> and let the non-newtyped one have the interesting applicative
14:37:23 <merijn> Cale: I think either Monad matches applicative, or no monad
14:37:40 <Cale> It's *far* less important than the Applicative structure which is incompatible with it though.
14:37:46 <Cale> and wouldn't be worth the newtype
14:38:02 <merijn> So, then newtype and define applicative + monad for the newtype?
14:38:08 <merijn> So the default is only Applicative?
14:38:15 <Cale> I'd probably just end up defining some other function for bind and just not abstracting over that
14:38:48 <Cale> Since bind on this type is not important enough to be worth the trouble of a newtype
14:39:11 <arkeet> that's fine too.
14:39:53 <Cale> However, it's reasons like that which make me unsure I agree that the Monad and Applicative instances should be forced to agree
14:40:12 <Cale> I can see why people want it
14:40:36 <Cale> It's nice to be able to refactor monadic code to use the Applicative instance without worrying that you're changing its meaning.
14:40:39 <arkeet> I think it's a pretty strong expectation that they agree.
14:40:41 <arkeet> yeah.
14:40:46 <merijn> Cale: How confused do you think I'd be if I rewrote my code from >>= to something using <*> and it just magically broke...
14:41:49 <Cale> merijn: Well, that depends on your expectations about the laws relating Applicative and Monad.
14:42:07 <Cale> If they're separate classes defining separate operations, then maybe you're not confused.
14:42:25 <Cale> One might say "oh, well, you should have just used `ap`"
14:42:27 <merijn> But that expectation wasn't there even before it was a superclass
14:43:20 <Cale> Yeah, I'm willing to admit that the types for which this is at all a concern are few and far between
14:43:28 * hackagebot hyakko 0.6.7 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.6.7 (JeremyHull)
14:44:21 <Cale> and because that standard Applicative structure is always there, it's bound to be the case that people will come to expect that it's the one which is present.
14:46:34 <Darwin226> Hey guys. Anyone used http://hackage.haskell.org/package/file-embed-0.0.8.2/docs/Data-FileEmbed.html before?
14:46:52 <Tuplanolla> What happens if you Data.Binary.encode an Int and decode it on a machine where Int is smaller?
14:46:52 <barrucadu> I must admit, I'm not sold on the Applicative => Monad idea. Potential efficiency improvements are good, but it means that most Applicative instances will just be boring and equivalent to the Monad one
14:47:08 <merijn> barrucadu: That expectation already existed
14:47:09 <frerich> Darwin226: I always wanted an opportunity to use that! :-)
14:47:35 <merijn> barrucadu: In fact, if you ever thought about doing anything else, I'm gonna need to go and grab my pitchfork again >.<
14:47:46 <barrucadu> heh
14:47:53 <arkeet> Tuplanolla: look at the Binary instance for Int
14:47:57 <merijn> barrucadu: You can just do with list does and newtype the alternative instance
14:47:57 <arkeet> it is always treated as 64 bits
14:48:41 <Darwin226> frerich: Well, I currently have one but I'm worried about the path I need to provide. For example in my project, the asset I want to embed is with the source in the src folder, so I use "./src/asset.txt" as a path. But I'm worried what would happen if someone else used my package. Will that path still point to MY src folder?
14:48:47 <merijn> barrucadu: i.e. ZipList vs []
14:51:57 <gremble> I have a case expression where I am testing the value of two strings. Is it possible to make this test case-insensitive withouth changing the strings that I am testing?
14:53:54 <ski> gremble : perhaps use `toLower' / `toUpper' ?
14:54:12 <ski> (it's not clear what you mean by "withouth changing the strings that I am testing")
14:55:24 <Tuplanolla> Also keep in mind that toLower . toUpper /= toLower, gremble.
14:56:31 <gremble> Why is that? They should both have similar output, shouldn't they?
14:58:10 <Tuplanolla> Such is life on the basic multilingual plane.
14:58:48 <gremble> Can I get off at the next stop?
14:59:00 <hpc> the only stops are glottal
14:59:20 * gremble titters
15:01:00 <merijn> gremble: Because unicode :p
15:01:30 <hpc> it's not even because unicode, it's because languages are weird
15:02:02 <Tuplanolla> > ((==) <$> toLower . toUpper <*> toLower) . pack <$> ["fi", "ﬁ"]
15:02:05 <lambdabot>      Not in scope: ‘pack’
15:02:05 <lambdabot>      Perhaps you meant one of these:
15:02:05 <lambdabot>        ‘BS.pack’ (imported from Data.ByteString),
15:02:07 <merijn> > (\x -> toLower (toUpper x) == x) 'ı'
15:02:09 <lambdabot>  False
15:02:20 <merijn> Tuplanolla: That doesn't work, those are strings, toUpper/toLower work on char
15:02:32 <merijn> > toLower (toUpper 'ı')
15:02:35 <lambdabot>  'i'
15:02:39 <Tuplanolla> That's Data.Text.toUpper.
15:02:50 <merijn> Tuplanolla: Not without qualification it ain't
15:03:21 <merijn> > Data.Text.toUpper (Data.Text.pack "ﬁ")
15:03:23 <lambdabot>      Not in scope: ‘Data.Text.toUpper’
15:03:24 <lambdabot>      Perhaps you meant ‘Data.Char.toUpper’ (imported from Data.Char)Not in sc...
15:03:29 <merijn> hmm
15:08:32 <albeit> Is there a variant of mapM that only returns the last result? Like "(a -> m b) -> t a -> m b"
15:08:40 <gremble> Alright, perhaps this would make more sense hastebin.com/jecabiyabi.hs
15:08:59 <Welkin> albeit: tail . mapM
15:09:05 <Welkin> although that is unsafe
15:09:06 <glguy> albeit: It'd need a way to check that there was a last result at all
15:09:51 <Welkin> albeit: you can built anything you can imagine by composing smaller functions
15:09:53 <Welkin> build*
15:09:57 <Enigmagic> gremble: if you're using Text not String you can use https://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU-Collate.html
15:10:12 <albeit> Welkin: Would it build and save the entire list of results then call tail? Or will it "throw out" results as it progresses?
15:10:14 <napping> Is there a partition like (a -> Maybe b) -> [a] -> ([b], [a])?
15:10:16 <Enigmagic> and don't mind taking an ic4cu dependency
15:10:25 <Welkin> albeit: think of it as a pipeline
15:10:36 <Welkin> data goes in the right side and comes out on the left, fully processed
15:11:25 <arkeet> :t partitionEithers -- this might help napping 
15:11:27 <lambdabot> [Either a b] -> ([a], [b])
15:11:43 <gremble> Enigmagic: I assume Text would be better to use than string? If I recall correctly the type had better unicode support or something like that (I forget, or may have misread)
15:11:52 <dfeuer> @ops
15:11:53 <lambdabot> Maybe you meant: pl oeis docs
15:11:55 <arkeet> Text has better performance generally.
15:11:59 <dfeuer> @where ops
15:11:59 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
15:12:03 <arkeet> for text stuff.
15:12:05 --- mode: ChanServ set +o dcoutts
15:12:11 <geekosaur> hm?
15:12:12 --- mode: ChanServ set +o geekosaur
15:12:33 --- mode: ChanServ set -o dcoutts
15:12:40 <dfeuer> geekosaur, look up just a drop...
15:13:10 <Welkin> albeit: actually, it would be `fmap tail . mapM` since the result of mapM is m a
15:13:12 <dfeuer> But this is probably better handled by network ops.
15:13:23 <dibblego> dfeuer: would you mind please messaging the offending spammer? (also, in the future too)
15:13:30 <Enigmagic> gremble: it's more space efficient than String and at one point had fewer unicode bugs than String. String may have been fixed since then though.
15:13:36 <HaskellStudent81> can anyone tell me what is wrong with "type Graph a = ([a], [(a,a)])"
15:13:40 <dfeuer> dibblego, I don't understand.
15:14:08 <arkeet> HaskellStudent81: nothing wrong there
15:14:10 <arkeet> what is the problem?
15:14:13 <dibblego> dfeuer: I am unsure why you called @ops
15:14:28 <arkeet> yeah I didn't see anything either
15:14:38 <geekosaur> I'm thinking this is one of those privmsgh "solo hooy" things again but dfeuer's client doesn't ddistinguish them well enough
15:14:45 <dfeuer> Oy....
15:14:52 <dfeuer> Sorry if I got the wrong people.
15:15:00 <geekosaur> (I have seen quite a few one-sided convos where the other side was /msg)
15:15:04 <dfeuer> But
15:15:11 <Welkin> how is that even possible?
15:15:11 <dfeuer> Not normal PM.
15:15:16 <Welkin> oh
15:15:16 <dfeuer> and they show in channel.
15:15:22 <merijn> Query maybe?
15:15:25 <dfeuer> -sassygirlx69-
15:15:25 <MarcelineVQ> /notice
15:15:33 <glguy> --> #haskell-ops
15:15:33 <Chousuke> Welkin: sometimes you can get that in irssi if you mess enough with your window setups
15:15:46 <Chousuke> and msg and some channel go into the same window
15:15:49 <merijn> dfeuer: Did that show up similarly? Otherwise maybe notice, yeah
15:16:02 --- mode: ChanServ set +o glguy
15:16:03 --- mode: glguy set +b *!*@host86-167-125-129.range86-167.btcentralplus.com
15:16:03 --- kick: sassygirlx69 was kicked by glguy (sassygirlx69)
15:16:03 <napping> dfeuer: definitely a notice, rather than in this channel
15:16:05 <geekosaur> I just grepped my backscroll, only see joins/parts
15:16:17 <dfeuer> Yeah, seems to have been /notice.
15:16:19 <HaskellStudent81> my bad, the problem with with the function I'm trying to use with the Graph type: http://lpaste.net/133833
15:16:25 <dfeuer> And it looks different, but I'm no wiz at that.
15:16:47 <Welkin> probably a NOTICE instead of PRIVMSG
15:16:47 <arkeet> HaskellStudent81: well, now you're missing the type argument to Graph
15:16:50 <arkeet> on line 3
15:16:51 <Welkin> those show in the channel
15:17:12 --- mode: geekosaur set -o geekosaur
15:17:27 <napping> arkeet: looks good. Is there any fancy way to get something like (a -> Maybe b) -> [a] -> [Either a b]?
15:18:01 <arkeet> I'd start with (a -> Maybe b) -> a -> Either a b
15:18:20 <arkeet> :t \f a -> maybe (Left a) Right
15:18:23 <lambdabot> r -> a -> Maybe b -> Either a b
15:18:26 <arkeet> oops.
15:18:36 <arkeet> :t \f a -> maybe (Left a) Right . f
15:18:40 <lambdabot> (a -> Maybe b) -> a1 -> a -> Either a1 b
15:18:43 <arkeet> gah.
15:19:09 <arkeet> :t \f a -> maybe (Left a) Right (f a)
15:19:11 <lambdabot> (a -> Maybe b) -> a -> Either a b
15:19:12 <dfeuer> Sorry for the noise, anyway.
15:19:36 <arkeet> and then compose with map
15:19:50 <HaskellStudent81> arkeet: I don't want to pass isSym a Graph and a type though, I just want to pass a graph. I'm not sure how to go about it?
15:20:02 <arkeet> HaskellStudent81: Graph isn't a type.
15:20:09 <arkeet> 'Graph a' is a type, if 'a' is a type.
15:20:52 <arkeet> Graph by itself is an error.
15:21:01 <HaskellStudent81> Aren't I making a type by saying type Graph a = ([a], [(a,a)]) ?
15:21:03 --- mode: glguy set -o glguy
15:21:17 <arkeet> sure, and that type is called 'Graph a'
15:21:24 <arkeet> i.e. the thing on the left of =
15:22:02 <arkeet> (it's not really a new type, it's just saying that 'Graph a' is the exact same thing as '([a],[(a,a)])'
15:22:07 <arkeet> for any a)
15:22:22 <arkeet> which means
15:22:30 <arkeet> if you write isSym :: Graph a -> Bool
15:22:32 <arkeet> that is exactly the same as
15:22:40 <arkeet> isSym :: ([a],[(a,a)]) -> Bool
15:22:41 <phaazon> hey, I need help with dereferecing
15:22:50 <phaazon> in C, we can dereference attributes
15:22:54 <phaazon> like, face->glyph
15:23:03 <phaazon> how does that translate in Haskell?!
15:23:05 <phaazon> peekOff?
15:23:09 <phaazon> how do I know the offset?
15:23:10 <arkeet> you mean for FFI purposes?
15:23:13 <arkeet> use c2hs
15:23:22 <arkeet> that's the easy way anyway
15:23:28 <phaazon> arkeet: nope
15:23:30 <HaskellStudent81> what about for the rest of the pattern matching for the function though
15:23:36 <phaazon> do you know FreeType?
15:23:39 <phaazon> we have a Haskell binding for that
15:23:51 <arkeet> ok, so your question is about the freetype binding.
15:23:59 <phaazon> well, the interface of FreeType exposes to use dereferencing to access some very important attributes
15:24:10 <phaazon> face->glyph
15:24:11 <phaazon> for instance
15:24:28 <phaazon> I have a pointer on a FT_Face
15:24:36 <phaazon> but I can’t find anyway to get the glyph from that :(
15:24:49 <haasn> phaazon: https://hackage.haskell.org/package/freetype2-0.1.1/docs/Graphics-Rendering-FreeType-Internal-Face.html#v:glyph ?
15:25:16 <phaazon> oh right
15:25:21 <dedgrant> arkeet: As an aside, because I don't knwo: if (forall a. (Graph a) ~ ([a], [(a,a)])), then does it follow that ((forall a. [a],[(a,a)]) -> Bool), or (forall a. ([a],[(a,a)]) -> Bool)?  Does type variable scope leak out of a type synonym?
15:25:24 <phaazon> I was looking in the Glyph module
15:25:25 <phaazon> thanks!
15:25:58 <phaazon> glyph = (\hsc_ptr -> hsc_ptr `plusPtr` 84)
15:25:58 <arkeet> dedgrant: there is no forall in the definition of Glyph a.
15:26:00 <phaazon> omg
15:26:05 <arkeet> er Graph.
15:26:31 <albeit> I am getting a huge space leak, and I can't figure out why... the code is here: http://lpaste.net/133834. I believe it is building up all the "initialMsgs", but I don't use them later on
15:26:34 <dedgrant> arkeet: Which is interesting to me. So in which scope is the variable introduced?
15:26:45 <arkeet> ?
15:26:47 <arkeet> if you write
15:26:50 <arkeet> isSym :: Graph a -> Bool
15:26:53 <arkeet> that is the same as
15:26:55 <arkeet> isSym :: forall a. Graph a -> Bool
15:27:03 <arkeet> isSym :: forall a. (Graph a -> Bool)
15:27:52 <HaskellStudent81> if I add the a in the pattern matching it doesnt like it
15:27:58 <HaskellStudent81> it counts it as another argument
15:28:04 <Chousuke> HaskellStudent81: your pattern is missing a pair of parens I think
15:28:06 <dedgrant> arkeet: Which is a solid answer about what happens, but I might also interpret the expansion as (forall a. Graph a) -> Bool, without knowing how Haskell resolves.
15:28:12 <arkeet> HaskellStudent81: I only suggested changing the type.
15:28:13 <arkeet> not the patterns.
15:28:26 <arkeet> dedgrant: what expansion?
15:28:34 <HaskellStudent81> if I dont add it it doenst like it either
15:28:35 <arkeet> your question wasn't very clear.
15:28:39 <Chousuke> isSym takes one argument, not two. But the type signature is wrong too, yes.
15:28:47 <dedgrant> arkeet: Of the type synonym.
15:29:07 <arkeet> dedgrant: in the type synonym definition, a is a free variable.
15:29:27 <dedgrant> arkeet: That may be the missing piece to my comprehension.
15:29:35 <arkeet> okay. :-)
15:29:46 <glguy> albeit: If you want to execute a list of things keeping the last result you can write something yourself or use: foldM (\_ x -> x)
15:31:06 <Chousuke> HaskellStudent81: I think you may be confusing type variables with variables in a function. 
15:31:48 <HaskellStudent81> I'm not the compiler is because I don't know how to specify. My teacher gave me this broke ass code that doesnt work and idk how to fix it
15:32:24 <Chousuke> well, it's a good exercise to figure out why
15:32:26 <HaskellStudent81> sorry I'm very frustrated. thanks for trying to help
15:33:17 <HaskellStudent81> the exercise isnt even to fix it... this isnt even the assignment. this is before the assignment even starts. thats the frustrating thing
15:34:07 <Chousuke> The type signature is wrong (there's no such type as 'Graph', so it can't be the type of the first parameter) and the pattern matching is wrong
15:34:21 <CapitalSigma> hey all
15:34:36 <CapitalSigma> is it possible to reset an accumE/accumB to its initial value in reactive-banana?
15:34:48 <HaskellStudent81> If I change the type to Graph a it still doesnt work
15:34:59 <Chousuke> yeah, because of the pattern matching problem
15:35:07 <HaskellStudent81> if I then change the arguments to edges a it thinks its another argument and still doesnt like it
15:35:24 <arkeet> why don't you show the updated code and error message?
15:35:27 <HaskellStudent81> if I cange the argument to (edges a) I get parse error in pattern
15:36:05 <Chousuke> don't put a in the function definition. forget about it entirely outside the real of types :P
15:36:33 <Chousuke> the function according to the type signature takes only one argument, but in the definition you have takes two.
15:36:36 <HaskellStudent81> but I thought Graph wasnt a type by itself; the type is Graph a
15:36:43 <Chousuke> yes
15:36:48 <arkeet> the equations you had in the function definition looked fine already
15:36:54 <arkeet> just the type signature was wrong
15:37:13 <HaskellStudent81> nope.
15:37:17 <HaskellStudent81> this is what I have now
15:37:17 <napping> CapitalSigma: no. Maybe check out the event switching stuff?
15:37:18 <HaskellStudent81> http://lpaste.net/133833
15:37:32 <arkeet> ok, now what is the error message?
15:37:49 <HaskellStudent81> with it like that I get Parse error in pattern
15:38:09 <CapitalSigma> napping: hmmm, i really just need something to hold a line of text as a buffer. maybe i'll stick it in an IORef
15:38:14 <Chousuke> that definition of isSym still takes two parameters
15:38:15 <arkeet> that is not the error message I get.
15:38:16 <monochrom> there is no way "(edges a)" can be a pattern
15:38:19 <CapitalSigma> the switching stuff looks complicated
15:38:20 <arkeet> oh now you changed it.
15:38:22 <arkeet> change it back.
15:38:34 <napping> CapitalSigma: oh, you could also adjust what type you are keeping
15:38:56 <CapitalSigma> napping: to something mutable?
15:39:10 <Chousuke> I'm trying very hard not to just tell you what's wrong with it, I'm not sure how to make you see it :/
15:39:10 <arkeet> well.
15:39:11 <HaskellStudent81> change it back to the other thing that wasnt working?
15:39:31 <napping> well, with accumE you could just fire an event using (const "New string") as your (a -> a)
15:39:36 <arkeet> er, never mind that.
15:39:40 <Chousuke> HaskellStudent81: change it so that it takes only one parameter at first. the definition, not the type signature
15:39:55 <Chousuke> the type sig is correct now
15:40:05 <CapitalSigma> napping: i was trying to do that but i wasn't able to figure out how
15:40:16 <napping> CapitalSigma: if you just want to hang onto the last value, maybe you want stepper?
15:40:23 <dedgrant> arkeet: I think I see: A variable in a type synonym must naturally take the scope of whatever name is assigned to it in the final expression.
15:40:23 <napping> a -> Event t a -> Behavior t a
15:40:45 <arkeet> dedgrant: sounds good to me.
15:40:45 <HaskellStudent81> you mean like http://lpaste.net/133833 ?
15:40:52 <dedgrant> arkeet: heh
15:40:56 <CapitalSigma> i wrote something like "eBuffer = accumE "" ((fmap (++) eChars) `union` (fmap (\_ _ -> "") eClear)"
15:41:35 <CapitalSigma> napping: i want it to keep all of the characters up until the last time the enter key was pressed
15:42:06 <Chousuke> HaskellStudent81: that doesn't look any different
15:42:20 <napping> so maybe accumE passing in either (c:) or (const "")?
15:42:28 <napping> except it will be backwards
15:42:50 <CapitalSigma> napping: is the union the right idea there, though?
15:42:54 <Chousuke> HaskellStudent81: it's a syntax problem there. in your definition, edges is the first parameter and you're pattern matching the second.
15:43:04 <napping> I mean something like accumE
15:43:08 <dedgrant> arkeet: Looking at the nominal expansion of type synonyms it makes some sense, but I may still be wrong. :/  I think GHC may offer different ways of evaluating, depending on the presence of LiberalTypeSysnonyms: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/data-type-extensions.html
15:43:25 <dedgrant> *LiberalTypeSynonyms
15:43:39 <Chousuke> when you only have one parameter that is a tuple of a list and a list of tuples
15:44:03 <napping> CapitalSigma: with accumB/accumE, the function is always passed the old value, but it doesn't have to use it
15:44:22 <CapitalSigma> napping: okay, i should be able to get that to work then
15:44:58 <napping> another approach might be to use stepper, and somehow arrange for the event to fire only with the correctly updated value
15:45:21 <napping> but accumB is probably simplest to get working
15:45:44 <CapitalSigma> napping: why accumB rather than accumE?
15:46:02 <napping> well, whichever you want I guess
15:46:20 <albeit> glguy: Even with a foldM, like "watcher' <- foldM runSingle watcher initialMsgs", I'm using rapidly increasing memory...
15:46:43 <napping> I'm just guessing you're using it with something like threepenny or whatever where you can wire up a Behavior to a bit of GUI
15:46:56 <CapitalSigma> napping: okay -- i'm not questioning the decision, i'm just kind of unclear on the difference between behaviors and events, it seems like they can almost always be substituted
15:47:09 <CapitalSigma> napping: yes, GTK and a pseudoterminal
15:47:15 <napping> yeah, the idea of using const works either way
15:47:53 <napping> HaskellStudent81: do you have the original code somewhere?
15:48:32 * hackagebot homplexity 0.4.1.0 - Haskell code quality tool  http://hackage.haskell.org/package/homplexity-0.4.1.0 (MichalGajda)
15:51:05 <HaskellStudent81> napping: this is the original code Im copying from my bullshit assignment http://lpaste.net/133833
15:51:41 <HaskellStudent81> teacher didnt even bother to have working code in the assignment, so I have to figure it out before I can even do the assignment
15:52:01 <napping> what's wrong with that code?
15:52:47 <napping> loads fine for me
15:52:51 <srhb> I spy tabs
15:53:01 <srhb> HaskellStudent81: Anyway give us the actual error.
15:53:08 <HaskellStudent81> god dammit
15:53:11 <napping> srhb: even with the tabs, ghci doesn't mind
15:53:22 <HaskellStudent81> idk what went wrong before but it loaded for me just now
15:53:26 <HaskellStudent81> sorry for the anger
15:53:44 <arkeet> it works now because you removed the type signature.
15:54:09 <HaskellStudent81> I tried it without the type signature the first time because that's how teacher had it, and it didnt work. Obviously I entered something wrong
15:54:23 <napping> Graph isn't part of any working type signature
15:54:25 <HaskellStudent81> I thought I had to make up the signature to make it work, which is what Ive been trying to do for the last 30 minutes
15:54:34 <napping> Maybe something with the indentation went wrong?
15:54:43 <Chousuke> to me it really looks like it should be isSym (edges, (xy:xys)) = ... 
15:54:43 <arkeet> whether that function does what you want it to do, or has the type you want, is a different matter.
15:54:48 <HaskellStudent81> could be idk I thought I had it just like that
15:54:52 <napping> leading space is generally bad news
15:55:32 <napping> now you can just ask ghci ":t isSym"
15:55:37 <Chousuke> but maybe not, I dunno anymore. I need sleep anyway. :P
15:56:08 <HaskellStudent81> I was thinking that too, Chousuke, but it didnt like that when I tried, but I may have done it wrong
15:56:23 <napping> it's definitely supposed to take two separate arguments
15:57:41 <napping> That isSym is reasonable as a helper function, not something you can directly use on a graph
15:59:55 <johnw> arkeet: ping
16:00:39 <HaskellStudent81> napping: it's supposed to work on these http://lpaste.net/133833 but ghci wants to treat those as trees when I enter them :\
16:02:08 <napping> either add them to the file, or type let g1 = ... into ghci
16:02:45 <napping> ghci syntax is more like what you get in a do block
16:02:59 <napping> in particular, you can't declare something just with name = expr
16:03:52 <napping> on the other hand, you get to do IO stuff like "x <- getLine" that's not allowed at the top level in a .hs file
16:04:05 <HaskellStudent81> I got let g1 in, but using it with isSym it wants to treat g1 as a tree :P
16:04:18 <HaskellStudent81> err wait no
16:04:22 <johnw> @tell arkeet couldn't do it; you nerd-sniped me something awful: https://gist.github.com/f0cbe2bd01a0e8a52bab
16:04:22 <lambdabot> Consider it noted.
16:04:25 <HaskellStudent81> it wants a tree without the type signature
16:04:39 <napping> What is "a tree"?
16:04:45 <arkeet> haha
16:04:54 <napping> Ask ghci for the type of isSym with ":t isSym"
16:05:31 <arkeet> johnw: yeah, I don't think it's true constructively
16:06:10 <HaskellStudent81> this is what is happening: http://lpaste.net/133841
16:06:10 <johnw> even restricting A to a finite type, and B to a type with decidable equality
16:06:23 <johnw> I just don't know anything about g at all, and parametricity doesn't help me
16:06:33 <napping> johnw: what's cancel?
16:06:45 <johnw> napping: cancel f g means g is a left-cancellation of f
16:07:09 <napping> I always confuse left at right
16:07:12 <napping> is that g . f = id?
16:07:14 <johnw> yes
16:07:24 <johnw> i have no idea why cancel flips the arguments
16:07:48 <napping> does "finType" give you an actual list of elements?
16:07:52 <johnw> enum A does
16:07:57 <johnw> for any A : finTyep
16:08:13 <napping> can't you just tabulate g by [(f x, x) | x <- map f (enum A)]?
16:08:20 <napping> and a default case otherwise?
16:08:27 <johnw> oh, interesting....
16:08:28 <arkeet> no one required A to be finite.
16:08:29 <johnw> damn
16:08:44 <johnw> arkeet: you said non-empty
16:08:48 <arkeet> yes
16:08:55 <johnw> i can't really work easily with non-empty infinite things
16:09:09 <napping> If it's not finite I doubt it's constructively valid
16:09:18 <arkeet> if you want to see where you can go with a finite thing then sure
16:09:31 <arkeet> napping: dolio mentioned some sufficient condition earlier.
16:09:35 <arkeet> where A is finite and B has decidable equality.
16:10:03 <napping> Right, that's what we were just talking about
16:10:04 <arkeet> which I guess is eqType there.
16:10:14 <napping> how is that "no one required A to be finite"?
16:10:17 <johnw> right, eqTypes support ==
16:10:40 <arkeet> I guess I was confused about what exactly johnw was trying to prove.
16:10:46 <napping> under dolio's sufficient condition you have that A is finite
16:10:58 <arkeet> so never mind
16:11:08 <napping> I doubt there's much else that would let you start with any B and figure out if it's in the image of f
16:11:15 <johnw> arkeet: given that f is injective, A is non-empty and B has decidable equality, we can derive the left inverse
16:11:22 <arkeet> okay
16:11:30 <arkeet> and A is finite I guess
16:11:32 <napping> johnw: how do you do that for infinite A?
16:11:45 <johnw> napping: your mapping function requires decidable equality on A too!
16:12:02 <johnw> I don't think I can do that for infinite A
16:12:12 <napping> johnw: how so? The first element of the pairs are in B
16:12:21 <napping> and you can use head (enum A) or something for a default
16:12:57 <johnw> ah, right
16:12:58 <napping> g b = case lookup b [(f a,a) | a <- <enum A>] of Just x -> x; Nothing -> head <enum A>
16:13:17 <napping> proving that actually works will make use of injective and finType
16:13:46 <napping> can I get from a Prism' a s to s -> Either s a?
16:14:22 <arkeet> sure you can.
16:14:37 <napping> Er, did I get that backwards? I guess flip withPrims (const id) :: Prism' s a -> s -> Either s a
16:14:49 <arkeet> yeah that one.
16:14:58 <napping> seems a bit roundabout, but okay
16:15:30 <arkeet> you don't even need a Prism for that.
16:16:10 <glguy> matching 07:: APrism s t a b 07-> s 07-> Either t a
16:16:11 <napping> What else would you use? I realized I probably need the opposite of my a -> Maybe b, so I might package them up as a prism
16:16:26 <arkeet> I'm saying a Traversal is enough.
16:17:10 <napping> how did I miss matching?
16:17:30 <napping> I see it's just using withPrism like that
16:18:13 <napping> the bigger structure is that I have my [a]
16:18:37 <napping> from the (a -> Maybe b) thing, I have a calculation that turns [b] into some (x,[a])
16:18:54 <napping> like, dropping the a that contributed to the x or something
16:19:38 <napping> and want to patch it together into a big [a] -> ([a],x) that leaves alone the 'a' that didn't match the (a -> Maybe b) function
16:23:38 <johnw> napping: that gets rid of one admit, but still not good enough
16:28:37 <napping> johnw: what problem is left?
16:30:32 <johnw> one sec, playing around with things
16:31:54 <adu> johnw: that sounds fun
16:37:00 <kasabian> anyone knows of some good and updated tutorial on creating test suites for haskell projects?
16:37:24 <napping> I could use that too. I've got something working, but it doesn't seem too nice
16:38:35 * hackagebot homplexity 0.4.2.0 - Haskell code quality tool  http://hackage.haskell.org/package/homplexity-0.4.2.0 (MichalGajda)
16:39:25 <Doug_Wade> I use HSpec; the docs are pretty good: http://hspec.github.io/
16:40:08 <kasabian> Doug_Wade thanks! looks good
16:40:26 <Doug_Wade> np
16:49:33 <albeit> If I have "type MyMap = Map String", does adding a bang in a data declaration do anything? "data Foo = Foo !MyMap"
16:50:51 <albeit> I think it would just reduce the Map to WHNF, but if I'm using Map.Strict isn't it always in that anyways?
16:53:39 <ion> Given the definition of Foo, evaluating a Foo will evaluate the MyMap to WHNF because of the !.
16:54:46 <johnw> kasabian: yes someone else's project as an example
16:55:13 <albeit> ion: But what does WHNF mean for a Map?
16:57:58 <ion> IIRC it means the spine is evaluated in strict Map. You'll have to check from the documentation.
16:59:11 <tejing1> does lambdabot respond to private messages?
16:59:23 <monochrom> suppose you are looking at "Map X Y". the following story is the same for both Data.Map and Data.Map.Strict until otherwise specified.
16:59:28 <xacktm> yes tejing1 
16:59:53 <ion> Oh, that's how the lazy Map works, the strict one is value-strict.
16:59:58 <haasn> albeit: without the strictness annotation, Foo (insert x (insert y (insert z someMap))) would stay like that even if you force it to WHNF, until you force the field as well. with the strictness annotation, that would reduce to Foo modifiedMap'
17:00:27 <ion> (in addition)
17:00:30 <monochrom> Map X Y is a binary search tree. forcing Map X Y forces the tree nodes. and because of that, also forces X enough for the Ord comparisons.
17:00:53 <monochrom> (because otherwise you wouldn't even know your tree nodes)
17:01:33 <monochrom> the following is specific to Data.Map.Strict. forcing Map X Y also forces Y to WHNF
17:01:37 <wrengr> ghc 7.10 seems to have broken the handling of where-clauses; is there any way to get back to the behavior of ghc 7.8?
17:02:15 <Cale> wrengr: What do you mean by that?
17:02:19 <ion> monochrom++
17:02:42 <albeit> Good stuff, thanks monochrom and ion
17:03:24 <Cale> wrengr: As far as I know, there's not much which is specific to where clauses which has changed in 7.10
17:03:37 * hackagebot consul-haskell 0.2 - A consul client for Haskell  http://hackage.haskell.org/package/consul-haskell-0.2 (sseveran)
17:03:42 <wrengr> Cale: Given a top-level definition "foo x y z = blah; where stuff = yarg" the type of "stuff" no longer closes over the types of x, y, etc
17:04:20 <wrengr> I'm sure it's some monomorphism/generalization issue with GADTs ---but I'm not actually using GADTs!
17:05:16 <glguy> Are you using Type Families?
17:05:19 <Cale> ah, hmm
17:05:22 <wrengr> nope, nothing fancy
17:05:47 <Cale> Wasn't that change introduced in 7.0?
17:06:00 <monochrom> how about showing actual code so people can reproduce and experiment
17:06:17 <monochrom> explain like they can't see your screen
17:06:25 <wrengr> I have a bunch of code I needed to switch from "foo xyz = blah; where stuff" to "foo xys = let stuff in blah" ...which, of course, doesn't work when the where clause should scope over multiple branches
17:06:29 <monochrom> (because they really can't, duh)
17:06:45 <albeit> So, if I have a Data.Map.Strict X Y, when I force that, X and Y will be forced to WHNF. If it is Data.Map.Strict X (Y1,Y2), the values are only forced to WHNF, the tuple constructor. So to have the inner values forced I would have to do Data.Strict.Map X (!Y1, !Y2), correct?
17:06:53 <Cale> wrengr: Perhaps try {-# LANGUAGE NoMonoLocalBinds #-}
17:07:45 <monochrom> there is no (!Y1, !Y2). you will have to write your own "data SP = SP !Y1 !Y2"
17:08:27 <Cale> wrengr: Are you sure the same code compiles under 7.8?
17:09:10 <Cale> wrengr: This is one of the changes which was introduced by the type system described in these papers: http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/index.htm
17:09:18 <Cale> Which came to GHC in 7.0
17:09:27 <wrengr> yeah. I had to change everything back when I updated my packages to work with 7.10; would have to go digging to find the specific examples
17:09:55 <Cale> You can always just give explicit polymorphic type signatures to the let bound things.
17:10:13 <Cale> It's only a change to inference
17:11:13 <albeit> Does adding a strictness annotation to "foo :: [a]" mean that foo will never be something like "([a] ++ ([a] ++ [a]))"?
17:12:22 <arkeet> what does "be" mean?
17:12:48 <albeit> What foo references will not be a sequence of thunks representing a list?
17:13:00 <pacak> albeit: All you'll get by strictness annotation here is that list of a will be force evaluated to WHNF -  you'll get something like <Thunk> : <Thunk> instead of simply <Thunk>
17:15:31 <pacak> albeit: Or [] in case of empty list.
17:18:07 <RickP> can anyone explain me why the typesystem can't derive Functor m from a monad class such as MonadState? I thought MonadState a m => Monad m => Functor m
17:18:26 <RickP> ghc is complaining that i should add the constraint, but i don't see how it is implied
17:18:37 <RickP> it is *not* implied, sorry
17:18:45 <pacak> RickP: Which version of ghc?
17:19:07 <RickP> 7.8
17:19:12 <wrengr> Cale: giving explicit signatures requires ScopedTypeVariables, which isn't too bad but is still annoying
17:19:21 <RickP> i thought they only fixed Monad m => Applicative m  in 7.10
17:20:43 <monochrom> you have got two aspects wrong. the obvious aspect is the direction. it's Functor m => Applicative m => Monad m
17:20:53 <CapitalSigma> how do i structure my project so that i can have submodules?
17:21:09 <monochrom> the non-obvious aspect is: it's "class Functor m => Applicative m". not "instance". "class".
17:21:12 <CapitalSigma> e.g. in my project Foo i'd like to have Foo.Bar, etc. surprisingly, i can't find any clear explanations online
17:21:17 <pacak> RickP: in base 4.6 monad is defined as "class  Monad m  where" which means you can declare monads without having Functor instance.
17:21:24 <maerwald> CapitalSigma: subfolders
17:21:45 <RickP> whaaaaaaat
17:21:51 <pacak> RickP: In 7.10 it's class Applicative m => Monad m, which means you have to have Functor
17:21:59 <RickP> i thought the only historical artifact was the missing link to applicative
17:22:02 <CapitalSigma> maerwald: okay, so just like java? 
17:22:05 <RickP> which they fixed now
17:22:07 <RickP> in 7.10
17:22:18 <maerwald> CapitalSigma: jav...what? never heard of it :D
17:22:23 <pacak> RickP: http://hackage.haskell.org/package/base-4.6.0.0/docs/Control-Monad.html#t:Monad
17:22:31 <monochrom> and it's "class Applicative m => Monad m". again, not "instance". "class".
17:22:32 <CapitalSigma> ha!
17:22:57 <maerwald> CapitalSigma: but yeah, you use subfolders in a similar way
17:23:24 <monochrom> you should have heard of "java" as an island of Indonesia
17:23:29 <CapitalSigma> maerwald: but i have an src directory in my project, which i've marked as a hs-source-dirs in cabal. with src/Foo/Bar.hs, i should be able to write "import Foo.Bar", right?
17:24:27 <CapitalSigma> i keep getting "can't find source for Foo in src"
17:24:56 <monochrom> it doesn't say "can't find source for Foo.Bar in src"?
17:25:45 <maerwald> CapitalSigma: does it find "import sc.Foo.Bar"?
17:26:22 <monochrom> no, "import src.Foo.Bar" is a syntax error
17:26:52 <CapitalSigma> ah, i got it
17:27:00 <maerwald> I don't even remember how I did it :/
17:27:20 <CapitalSigma> hmm i'm getting a linker error now
17:29:12 <RickP> monochrom: what do you mean by "not instance, class"? and why did they leave the link out in the type system? isn't it true in category theory that every monad is a functor?
17:32:13 <pacak> RickP: It's true in category theory, but it was not enforced in ghc 7.8, in 7.10 they added requirement so now every Monad is a Functor.
17:33:11 <RickP> oh ok
17:33:37 <RickP> i was under the impression that only the applicative-monad relationship was missing from the type system
17:33:41 <RickP> but where is it in 4.7
17:33:49 <RickP> i still see "class Monad m where..."
17:34:13 <Taneb> RickP, the Functor-Monad relationship was missing too
17:34:32 <pacak> RickP: Have a look at base 4.8
17:34:33 <RickP> oh wait ghc is 4.8?
17:34:36 <RickP> oh ok
18:01:09 <KaneTW> /names
18:01:11 <KaneTW> oops
18:13:41 * hackagebot geom2d 0.1.2.1 - package for geometry in euklidean 2d space  http://hackage.haskell.org/package/geom2d-0.1.2.1 (seppeljordan)
18:15:00 <Ray_> λ (:) <$> [1] <*> [[]]
18:15:00 <Ray_> [[1]]
18:15:00 <Ray_> λ 
18:15:02 <Ray_> λ (:) <$> [1] <*> []
18:15:04 <Ray_> []
18:15:06 <Ray_> this seems annoying
18:15:32 <Ray_> (:) <$> [1] <*> [[]]
18:24:27 <ski> Ray_ : why ?
18:25:14 <pacak> Ray_: Makes total sense to me. Default applicative instance for lists represents non-deterministic computations and there is a difference between [] and [[]] in that sense - first one - no branches, second one - branch that produces  an empty list.
18:25:27 <Bison891> ≃
18:28:43 <Ray_> it is annoying because if say a function returns [[Int]], [] will be an acceptable value, but it is going to make a difference in applicative functor
18:29:55 <xj54y> Perhaps I missed a response but, having ran cabal install lambdabot in my sandbox (ghc 7.8.4; debian 7.8 i386), I get the following error http://paste.debian.net/197739/  Any ideas?
18:30:10 <ski> it may help to conceptually distinguish between lists used to encode alternate solutions, as opposed to lists just used to aggregate some number of data items, in some order
18:31:16 <ski> in this case, i might write the type as `[] [Int]', where the initial `[]' symbolizes the nondeterminsm (the alternate possible solutions), and `[Int]' the type of each individual solution (here a list of `Int's)
18:31:24 <pacak> Ray_: Outer [] is not a container for values, it's a container for computations.
18:32:18 <ski> so in `(:) <$> [1] <*> [[]]', `[1]' represents having a single solution, `1', while `[[]]' represents having a single solution, `[]'
18:32:46 <ski> and then the applicative combinators allow as to combine each one of the solutions in the first case with each one of the solutions in the second case, using `(:)'
18:33:34 <ski> here, we get `1 * 1' resulting solutions, the only solution being `1 : []'. therefore the result is `[[1]]'
18:33:48 <Ray_> sure, but it gets annoying when i have concatMap 
18:34:08 <ski> if we instead use `(:) <$> [1] <*> []', then we in the second case have zero solutions, so in total we get `1 * 0' solutions, so final result is `[]'
18:34:40 <ski> Ray_ : example of what get annoying ?
18:35:37 <pacak> Ray_: Try thinking about outer [] as some arbitary monad, not a list. In that case your concatMap might make less sense.
18:35:52 <pacak> Ray_ [[Int]]  ~ m [Int]
18:36:05 <Ray_> right, i think you have a good pint
18:36:08 <Ray_> point
18:36:23 <ski> as pacak says, it might make sense to (at least for conceptual understanding) generalize the code to use `m' instead of `[]', where `MonadPlus m'
18:37:07 <ski> (you can use `foldr (mplus . return) mzero' to go from `[] a' to `m a', given `MonadPlus m')
18:37:46 <ski> pacak : well, i suppose not really "says", but as could be extrapolated from the general idea you were expounding ..
18:38:17 <pacak> (it's hard to express complicated thoughts trying to do some useful work in parallel) :)
18:39:00 * ski is trying to listen to a recorded radio program in parallel .. have had to rewind over the same section several times, now ;)
18:42:00 <dzack> could anyone recommend a good resource for understanding IO and monads
18:42:11 <dzack> (for someone relatively new to Haskell, fwiw)
18:42:33 <pacak> @whereis rwh
18:42:34 <lambdabot> Maybe you meant: where+ where
18:42:38 <pacak> @where rwh
18:42:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:42:42 <pacak> @where lyah
18:42:42 <lambdabot> http://www.learnyouahaskell.com/
18:42:43 <ski> first, understanding `IO' is different from understanding monads
18:43:09 <ski> being a monad is only a small part of what `IO' is
18:43:23 <pacak> A monad is just a monoid in the   category of endofunctors... 
18:44:17 <ski> also, understanding particular monads (like `IO',`Maybe',list,state,environment (`Reader'),output (`Writer'),..) is different from understanding the general concept of being a monad
18:45:25 <kini> dzack: I'm not sure what *exactly* you're looking for, but I think this is a fun introduction to the concept of how IO works in Haskell: http://blog.jle.im/entry/first-class-statements
18:45:42 <ski> dzack : a very quick initial intro to `IO' is
18:45:51 <ski> @wiki Introduction to IO
18:45:51 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
18:46:53 <dzack> Thanks! Currently reading through those
18:47:59 <dzack> Basically, I have a type error like "couldn't match type 'm0 a' with 'a'", and realized I probably need a bit more background to understand exactly why that's an error
18:48:21 <ski> dzack : for an old (but imho still good) intro to monads, see "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>
18:48:34 <Pip> How long to master Haskell?
18:48:49 <mada> 150 years should do it
18:48:53 <mada> :)
18:48:59 <Pip> :D
18:49:34 <ski> dzack : that type error is similar to confusing `"a string"' with `["a string"]', or confusing `(False,12)' with `Just (False,12)'
18:50:35 <pacak> Pip: Haskell is a relatively simple language, you can use monads and other complicated stuff even in Javascript. Where is the boundary where Haskell ends and category theory starts?
18:50:47 <ski> dzack : in these two cases, the difference in types is between `String' and `[String]' (which is syntactic sugar for `[] String'), and between `(Bool,Integer)' and `Maybe (Bool,Integer)'
18:51:31 <ski> dzack : in terms of the difference between `a' and `m a', in my case `m' was `[]' with `a' being `String'; or `m' being `Maybe' and `a' being `(Bool,Integer)' in the second case
18:52:34 <ski> dzack : in your case, possibly `m' would have been `IO' (if you were doing Input-Outputy things ..) .. the error corresponds to confusing a value (such as a string) with an action (which is another kind of value) that will produce a value (such as a string) when executed
18:52:59 <Pip> How does "drop" function work on lists?
18:53:08 <ski> dzack : .. it's hard to say something more useful, without more details about the code that led you to that type error
18:53:21 <Cale> @src drop
18:53:22 <lambdabot> drop n xs     | n <= 0 = xs
18:53:22 <lambdabot> drop _ []              = []
18:53:22 <lambdabot> drop n (_:xs)          = drop (n-1) xs
18:53:38 <ski> Pip : `drop n xs' removes the first `n' elements of `xs', returning the remaining ones (or returns an empty list, in case there are fewer than `n' elements in `xs')
18:54:08 <Pip> got it
18:54:10 <lyonsb> > let lbList = [1, 2..]
18:54:12 <lambdabot>  <no location info>: not an expression: ‘let lbList = [1, 2..]’
18:54:23 <ski> lyonsb : no `let'
18:54:35 <Pip> What book do you suggest for newbies?
18:54:36 <ski> > [1,2 ..]
18:54:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:54:43 <lyonsb> > lbList = [1, 2..]
18:54:46 <lambdabot>  <hint>:1:8: parse error on input ‘=’
18:54:49 <pacak> Pip: lyah, rwh
18:54:54 <Cale> If you want to make temporary definitions, you can do it with the @let lambdabot command
18:55:08 <Cale> @let lbList = [1, 2 ..]
18:55:09 <lambdabot>  Defined.
18:55:10 * lyonsb has failed to generate an example.
18:55:13 <Cale> > lbList
18:55:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:55:24 <lyonsb> > drop 3 lbList
18:55:24 <ski> lyonsb : or if you really must, use `@let lbList = ...' .. however, in case you don't need to show us the interaction, consider communicating privately with lambdabot instead
18:55:25 <arkeet> or just use let...in...
18:55:27 <lambdabot>  [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,...
18:55:30 <Cale> yeah
18:55:32 <Cale> @undefine
18:55:32 <lambdabot> Undefined.
18:55:36 <lyonsb> >drop 10 lbList
18:55:47 <Cale> > let lbList = [1..] in drop 10 lbList
18:55:49 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
18:55:55 <lyonsb> Not much of an example if no one else sees it.
18:55:57 <ski> Pip : do you know any other programming languages ?
18:56:00 <Pip> thanks
18:56:26 <Cale> Pip: http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html is good
18:56:26 <wayne> how would you flip the ordering of type constructor parameters?
18:56:44 <ski> lyonsb : as Cale showed, a `let ... in ...' would probably be best, if you wanted to name it. unless you really wanted to refer to it many times
18:56:46 <lyonsb> In my head that was 2 rapid commands and "for example."
18:56:47 <Cale> wayne: You could define a newtype, but mostly you avoid having to do that as much as possible
18:57:40 <xj54y> Anyone here familiar with mueval? I'm having trouble getting it to install as it's unable to satisfy a dependency that may be old.. (seemingly its looking to use module System.IO.UTF8 from utf8-strings-1 which doesn't contain the module)
18:59:23 <ski> lyonsb : it's often a good idea to try out lambdabot examples in private first, if you're unsure you got it right, to avoid excessive noise. if you thought you got it right, but misjudged it, and it gets noisy, it can be a good idea to retreat back to private, until you figure it out
18:59:52 <xj54y> I wonder if I can simply change the version requirement of the package? Kind of worried that certain functions would be called that are of course non-existent though
18:59:53 <lyonsb> I understand your concern.
19:00:17 <arkeet> xj54y: try mueval from git
19:00:41 <ski> Pip : well ?
19:01:36 <ski> dzack : any elaboration ?
19:02:26 <dzack> ski: thanks for the explanation, that does seem to be the case - I think what I'm evaluating is still wrapped instead of IO
19:02:41 <dzack> I'd post some code, but it's a small chunk in the middle of a large project, so there wouldnt be much context
19:03:31 <ski> dzack : perhaps it's strange to say this, but sometimes the surrounding context doesn't matter that much, as long as you have anything concrete to go on
19:03:40 <lyonsb> ski, I do not share it -- letting the messiness of learning happen in public can be very beneficial to folks that are otherwise culturally conditioned to "only show good stuff".  I heard someone say once "just give code.  Bad code can be fixed.  No code can't.  bad code > no code"
19:03:43 <dzack> Fair enough, let me throw a gist up
19:03:56 <Cale> dzack: It's important to notice that a value x of type IO String is about as much like a String as /bin/ls is like a list of files.
19:04:28 <Cale> dzack: A value of type IO t is a description of something which could be done, that if it terminates normally, will result in a value of type t at the end.
19:06:14 <bitemyapp> dzack: compressed what Cale said a bit, `IO a` is a means of obtaining a given that you have (possibly) performed some effects to get that `a`.
19:06:21 <Cale> For example, getLine is a description of how to obtain a line of text from the terminal, resulting in a String. You can pass that description around, put it in datastructures, etc, without having to worry about it accidentally being executed -- in particular, evaluation doesn't cause IO actions to be executed.
19:06:31 <bitemyapp> @ty getLine
19:06:32 <lambdabot> IO String
19:07:07 <bitemyapp> so, getLine is, "given that you perform effects, you'll get a String", which makes sense because you have to ask the OS (via syscall) to get input from the user before you have a String.
19:07:47 <Cale> IO actions can, as part of their own execution, cause other IO actions to be executed. You can write v <- x inside a do-block, which means "execute the action x, and call the result v", and the do-expression as a whole will be a value of type IO t for some t.
19:08:16 <dzack> ski: https://gist.github.com/dzackgarza/db1fdf0ad2c1449a6a64
19:08:17 <Cale> and the main action of your program will be an IO action that gets executed when your program begins to run, so that's how things get started
19:08:40 <dzack> It essentially reads a (Map String Integer) out of memory, and tests if something is in it
19:08:44 * hackagebot consul-haskell 0.2.1 - A consul client for Haskell  http://hackage.haskell.org/package/consul-haskell-0.2.1 (sseveran)
19:09:30 <dzack> fmap'ing the elem function over it seems to accomplish the same purpose, but I'm wondering why the second version doesn't seem to..
19:09:31 <Cale> dzack: What is the error in the version which doesn't work there?
19:09:38 <dzack> hmm, sort of remove the m0 part of it
19:09:40 <dzack> oh, sec
19:10:17 <dzack> "Couldn't match type 'm0 Response' with 'Response'"
19:10:28 <Cale> uh, what's the rest of the error?
19:10:44 <dzack> ah, and the type of returnOne is something like DynamicPath -> Response
19:11:06 <dzack> That's it, actually - it just points out that returnOne is the wrong type
19:11:11 <Cale> That seems unlikely, yeah
19:12:29 <Cale> Those two pieces of code look equivalent to me -- had something else changed?
19:12:38 <Cale> (unless I'm missing something)
19:12:54 <dzack> There we go, just updated it with the exact error
19:13:26 <dzack> And nope, that's the only thing that changed - I figured it would be equivalent too
19:13:33 <dzack> I'll try changing it back and see, though
19:14:34 <CapitalSigma> can i zip a reactive banana Event with itself like a list, so i can get pairs of events?
19:15:05 <ttt_fff> in haskell, what is most efficient way to change [Double] to a String? i.e. something equiv to (intercalate (map show lst) " ")
19:15:09 <ttt_fff> but not using show, and faster
19:15:27 <Cale> CapitalSigma: fmap (\x -> (x,x)) ?
19:15:30 <arkeet> > intercalate (map show [1.0,2.0]) " "
19:15:32 <lambdabot>      Couldn't match type ‘Char’ with ‘[String]’
19:15:32 <lambdabot>      Expected type: [[String]]
19:15:32 <lambdabot>        Actual type: [Char]
19:15:38 <arkeet> > intercalate " " (map show [1.0,2.0])
19:15:39 <lambdabot>  "1.0 2.0"
19:15:52 <ski> lyonsb : i agree it can be good to have the learning process on display, at least with some caveats. i'm not quite sure how i should respond to the "folks that are otherwise culturally conditioned to \"only show good stuff\"" part and the latter part, since i'm not quite sure what you're arguing against here (as connected to what was done before). perhaps you can elaborate ?
19:15:59 <Cale> CapitalSigma: Or you want pairs of consecutive event occurrences?
19:16:05 <CapitalSigma> Cale: i was looking for the equivalent of "zip foo $ drop 1 foo"
19:16:09 <Cale> aha
19:16:18 <CapitalSigma> yeah, that. i want to grab the event before another event fired
19:18:38 <dzack> Cale: wow, you were right - changing it back seems to work, so I have no idea what was up
19:18:50 <arkeet> CapitalSigma: you can probably do something using accumE
19:19:04 <dzack> might have been an issue with variable name/scope, I'm not sure
19:19:37 <CapitalSigma> arkeet: ah, you're right
19:19:55 <arkeet> if you have some ev :: Event t a
19:20:21 <arkeet> then accumE [] (fmap (:) e) :: Event t [a]
19:20:36 <arkeet> will give you all the past values (in reverse order)
19:20:41 <arkeet> and then you can take the first 2 elements or whatever.
19:20:55 <arkeet> sorry, ev, not e
19:20:55 <arkeet> whateve
19:20:57 <arkeet> r
19:24:09 <Cale> \e -> filterJust (stepper (\y -> Nothing) (fmap (\x y -> Just (x,y)) e) <@> e)
19:24:13 <Cale> Maybe this?
19:27:07 <CapitalSigma> Cale: i was going to try something like "eventPairs ev = accumE (undefined, ev) ((\new (older, old) -> (old, new)) <$> ev)"
19:28:12 <Cale> I don't know if that typechecks
19:28:33 <CapitalSigma> Cale: not quite
19:28:46 <Cale> But there should be some way to do it with accumE...
19:28:58 <CapitalSigma> the ev in the accumulator is wrong, but it's fixable
19:30:33 <bitemyapp> Cale: I am trying to come up with ideas for typeclasses a learner could write themselves
19:30:58 <bitemyapp> Cale: how vacuous would      class Swappable t where; swap :: t a b -> t b a      be?
19:31:13 <xj54y> if I'm in a sandbox and I'm trying to install a git package, what do I do?
19:32:11 <ttt_fff> after no implicit prelude, how do I refer to Prelude's + ? "import qualified Prelude as P" with "P.(+)" does not work
19:32:50 <Welkin> eh?
19:32:52 <xj54y> also the cabal timeout business is really starting to bother me. >_< Not only are packages seemingly depenend on versions of packages inconsisten with others, but fixing the broken packages seems to break all of its dependencies... meh
19:32:55 <c_wraith> P.+ actually.  It's weird for infix operators
19:33:14 <Welkin> import Prelude ((+))
19:33:36 <Welkin> if you qualify it, use (P.+) rather than P.(+)
19:33:37 <c_wraith> :t (M.!)
19:33:38 <lambdabot> Ord k => M.Map k a -> k -> a
19:33:56 <Cale> bitemyapp: Well, there are instances for (,) and Either
19:33:58 <c_wraith> > fromList [(1,2)] M.! 1
19:34:00 <lambdabot>  2
19:34:10 <kadoban> xj54y: Using stackage mostly fixes that. It guarantees a set of packages that will all build with each other. As to how you use packages from git, IIUC you clone it locally and use cabal add-source in the sandbox pointing to the local clone.
19:34:39 <xj54y> kadoban, yes, why can I not simply use haskell-platform? 
19:34:42 <bitemyapp> Cale: right. I was thinking of swap . swap == id as a law. I really just need to come up with reasonable-seeming examples but the more realistic ones involve parsing and we've not gotten to that yet in the book.
19:35:37 <kadoban> xj54y: You can, I guess, if you want. I wouldn't. It doesn't work with stackage, AFAIK, and it includes far fewer packages than stackage does.
19:35:41 <xj54y> kadoban, 
19:35:42 <Cale> bitemyapp: Has Monoid been introduced?
19:36:24 <kadoban> So every other thing you want to use has to be compatible with the versions of packages that platfrom has installed, IIUC, and … you're basically guaranteed to want to install things that aren't in platform.
19:37:36 <xj54y> kadoban, it seems I cannot build much with platform fresh out of the box.. It's bother me because I've been at this for wayyyyy tooo long long and still, I've yet to attain any stability. If this is how platform works, wtf.. Should I restart this process with stackage then? :(
19:38:11 <xj54y> (oh, not to mention constant timeouts...)
19:38:12 <bitemyapp> Cale: no
19:38:19 <Cale> bitemyapp: Arbitrary and Testable are cool, but a little tricky to do as exercises of some sort.
19:38:28 <bitemyapp> Cale: neither has semigroup. They get introduced as a pair right before Functor.
19:38:50 <kadoban> xj54y: Not to say "I told you so", but … I told you so.
19:38:59 <xj54y> kadoban, huh?
19:39:16 <kadoban> xj54y: You don't remember yesterday when this came up and I told you several times not to use platform?
19:39:28 <bitemyapp> Cale: very cool, but yes tricky to do as exercises. That's a very good idea, I'll keep it in mind, thank you. Please bang my gong if you think of anything else you'd like to suggest.
19:39:48 <xj54y> kadoban, oh, many helping hands and conflicting advice.. But, it's good to have the experience. Let's call it, "initiation"
19:40:11 <Cale> bitemyapp: Oh, maybe ToJSON/FromJSON?
19:40:13 <Hafydd> /nick bangmygong
19:40:19 <Cale> I guess FromJSON involves parsing
19:40:22 <Cale> But ToJSON doesn't.
19:40:25 <kadoban> xj54y: But yes, personally I think stackage is a better idea, or at least just using GHC and cabal (no platform) and then using sandboxes. Stackage is optional, but I like it.
19:40:42 <kadoban> It's still not perfect, but I think it's at least "good"
19:40:54 <Cale> Well, FromJSON only involves "parsing"
19:41:09 <Cale> You're turning one tree into another :)
19:41:30 <Cale> You might want some nondeterminism in the process, but you could avoid that somewhat
19:41:33 <xj54y> kadoban, yeah, I need to use something that makes sense for now. I cannot be a package hero at the moment. Would you mind assisting me with setting up stackage? I think I'm able to do it no problem, but who knows what'll happen
19:42:37 <steshaw> My google fu is failing me. I'm trying to think of an alternative evaluation strategy that I'm pretty sure came out of Birmingham University. It was non-strict but not lazy IIRC. Called something like push-pull. Any ideas?
19:42:46 <kadoban> xj54y: Sure, I can try.
19:43:13 <ReinH> steshaw: you aren't talking about conal's FRP paper, are you?
19:43:25 <steshaw> No
19:43:33 <kadoban> xj54y: The first step is just to install GHC from the binaries and then install cabal. https://gist.github.com/ion1/2815423 <-- that's the instructions I use. It's nice because if you mess up it's pretyt easy to just wipe out, it's only installed in your home dir.
19:43:37 <bitemyapp> Cale: I considered that too...RWH basically does that.
19:43:46 * hackagebot hs-mesos 0.20.3.0 -   http://hackage.haskell.org/package/hs-mesos-0.20.3.0 (IanDuncan)
19:43:46 <Cale> steshaw: Some kind of optimistic evaluation?
19:43:59 <bitemyapp> Cale: so you're thinking to/from AST, rather than fussing with String -> AST?
19:44:09 <kadoban> xj54y: You can pick either GHC 7.8.4 or GHC 7.10.x. I'm still on 7.8.4, but I think it's approximately at the point where I'm going to switch soon.
19:44:19 <Cale> bitemyapp: Yeah,  a -> Value  and  Value -> Maybe a
19:44:22 <bitemyapp> Cale: JSON seems like such a predictable choice, but it works here I think.
19:44:37 <bitemyapp> and knowing how something like Aeson works seems valuable.
19:45:07 <steshaw> Cale: IIRC, it would evaluate more than than using lazy evaluation but was still non-strict. Must admit that I didn't understand it at the time. Hence why I'd like to go back to it...
19:45:10 <bitemyapp> Cale: that's a very good idea and sticking to the AST solves my parsing-avoidance problem. Thank you!
19:45:49 <eds> how does this statment work?
19:45:50 <eds> liftM ((:[]) . head) (eval e)
19:46:18 <eds> I am having a hard time to understand ((:[]).head)
19:46:27 <c_wraith> :t ((:[]) . head)
19:46:29 <lambdabot> [b] -> [b]
19:46:34 <wayne> what's an fmap implementation that doesn't satisfy the functor rules?
19:46:36 <Cale> steshaw: There's this... http://research.microsoft.com/en-us/um/people/simonpj/Papers/optimistic/index.htm
19:46:40 <wayne> (might be an easy one)
19:47:03 <xj54y> kadoban, so what's this .cabal file I need?
19:47:14 <steshaw> Cale: thanks. It's not what I'm thinking of. The work was later IIRC
19:47:16 <c_wraith> eds: it's a really weird way of writing a function that truncates a list to one element
19:47:22 <c_wraith> eds: or crashes if the input list was empty
19:47:23 <Cale> wayne: instance Functor [] where fmap f xs = []
19:47:36 <wayne> ah great
19:47:48 <wayne> because fmap id xs wouldn't hold
19:47:53 <wayne> and that implies the next one won't either
19:47:53 <steshaw> Cale ReinH : got it call-by-push-value
19:48:01 <wayne> (does it imply that?)
19:48:05 <ReinH> cool
19:48:21 <eds> Yea that is what I wondering would it not crash if the list was empty
19:48:22 <c_wraith> wayne: in haskell, yes.  The second Functor law is always a consequence of the first one
19:48:27 <kadoban> xj54y: The stackage one you download and put in each cabal sandbox you create. It goes next to the package.cabal file, in the same dir.
19:48:38 <eds> The whole statement is: eval (Head e)      = liftM ((:[]) . head) (eval e)
19:48:40 <wayne> c_wraith: okay so it's stronger than just implication
19:48:59 <c_wraith> wayne: it's a consequence of free theorems/parametricity
19:49:22 <xj54y> kadoban, yes, but where's the package.cabal file (if there exists one)? I've basically created a new directory, and ran cabal sandbox init
19:49:22 <eds> so it helps me get the head of the list.
19:49:24 <ttt_fff> Welkin: that worked, thanks!
19:49:41 <xj54y> kadoban, now I've fetched the cabal.config file
19:49:42 <c_wraith> eds: I'm not sure why it's re-packing into a singleton list...  But it is!
19:50:00 <xj54y> kadoban, I've got cabal.sandbox.config and cabal.config 
19:50:07 <eds> Because my function eval is defined to give a list as output
19:50:12 <eds> eval :: E -> Maybe [Int]
19:50:23 <c_wraith> eds: oh.  That's a good reason. :)
19:50:29 <kadoban> xj54y: I create a separate sandbox for each project and every sandbox has a project in it, so I always have a <projectnamehere>.cabal in there as well. I think that's optional, but I dunno.
19:51:10 <eds> so you mean this ((:[]) . head) helps me to pack head into a singleton list, right
19:51:11 <xj54y> kadoban, where does that file come from?
19:51:56 <kadoban> xj54y: cabal init … or I usually create it manually/from a template, because I don't like their template. But it's really fine, I'm very picky about dumb stuff (I hate that they have whitespace at the end of lines, mostly)
19:52:29 <eds> how would you explain ( : [ ] )? Can I define it as ( [ ] : )?
19:52:38 <c_wraith> eds: it's just a section of (:)
19:52:47 <xj54y> kadoban, cabal init has left only the cabal.sandbox.config file, no .cabal file
19:52:49 <c_wraith> eds: same way (1 +) is a section of (+)
19:52:52 <kadoban> :t ([]:)
19:52:53 <lambdabot> [[t]] -> [[t]]
19:52:57 <kadoban> :t (:[])
19:52:57 <lambdabot> a -> [a]
19:53:09 <tejing1> eds: (:[]) == flip (:) []
19:53:54 <kadoban> xj54y: 'cabal init' creates the yourpackage.cabal file. I think you mean 'cabal sandbox init' did that?
19:54:14 <xj54y> kadoban, oh sorry, yes
19:54:16 <eds> ahh I understand now. thanks
19:54:27 <kadoban> No worries, it's pretty confusing, hehe.
19:56:00 <eds> ikr!
19:56:31 <CapitalSigma> are there any sane ways of testing reactive banana code?
19:59:43 <eds> One more question :p
19:59:58 <eds> How do I make sure that my list is not empty?
20:00:10 <ski> pattern-matching ?
20:00:11 <eds> eval (Head e)  = liftM ((:[]) . head) (eval e)
20:00:38 <ski>   eval (Head e)  = case eval e of
20:00:51 <ski> oh, right
20:01:11 <ski>   eval (Head e)  = liftM strip (eval e)
20:01:14 <ski>     where
20:01:25 <ski>     strip (x:_) = [x]
20:01:35 <ski>     strip [   ] = ..something else ..
20:02:03 <ski> i'm not sure what the monad is here, but you could possibly instead do something like
20:02:03 <eds> like Nothing. That should work.
20:02:17 <ski>   eval (Head e)  = do xs <- eval e
20:02:22 <eds> eval :: E -> Maybe [Int]
20:02:26 <ski>                       case xs of
20:02:41 <ski>                         x:_ -> return [x]
20:02:50 <ski>                         [ ] -> ..something else..
20:03:02 <ski> in the latter case, `..something else..' can "do something in the monad"
20:03:16 <ski> e.g. it could be `Nothing', yes
20:03:25 <ski> (which wouldn't work with the `liftM' version)
20:03:54 <eds> Why?
20:04:08 <ski> because `liftM' preserves `Just' and `Nothing'
20:04:36 <ski> if `eval e' is `Just xs', then `liftM blah (eval e)' is `Just (blah xs)', it can't be `Nothing'
20:05:04 <xj54y> kadoban, I think it's ready to go.. I dont know though.. What next?
20:05:11 <ski> if you want it to be `Nothing' sometimes, depending on `xs', then `liftM' (which should do the same as `fmap' and `(<$>)') doesn't cut it
20:05:52 <ski> the `do'-notation above translates to a call to the monadic `(>>=)' operator, and this is essential to "do different things later, depending on values of earlier computations"
20:06:10 <ski> in your case you want to "fail with `Nothing', depending on the value of `xs'"
20:06:26 <ski> eds : makes any sense ?
20:06:55 <kadoban> xj54y: Throw some code in the sandbox, in the place that <whateveryourprojectiscalled>.cabal expects it, then 'cabal install --dependencies-only', then 'cabal install', and then run it (it'll be in .cabal-sandbox/bin/)   I think just 'cabal install' without the deps-only thing will work too, but I'm not 100% sure, I always to the deps part for some reason.
20:06:58 <ski> @undo do xs <- eval e; case xs of x:_ -> return [x]; [] -> Nothing
20:06:58 <lambdabot> eval e >>= \ xs -> case xs of { x : _ -> return [x]; [] -> Nothing}
20:07:09 <ski> (that shows where the `(>>=)' appears in the snippet)
20:07:21 <eds> As a whole, yes.
20:07:22 <eds> I need to write that down.
20:07:42 <eds> Thanks!!
20:07:59 <xj54y> kadoban, err... I would need to change my paths, right?
20:08:45 <kadoban> xj54y: Well, you can add .cabal-sandbox/bin/ to your $PATH I guess. Honestly I usually just explicitly type .cabal-sandbox/bin/whatever . I'm not sure why … I just got too lazy to mess with my PATH probably.
20:09:02 <ski> eds : `fmap'/`(<$>)'/`liftA'/`liftM' always "preserves the structure", only changing the "elements/results"
20:09:36 <kadoban> xj54y: If it's something I use globally, I generally install it in a sandbox anyway and then link it into my ~/bin/ directory, which is in my $PATH already.
20:09:51 <eds> So if it is declared Just once, it is going to preserve it throughout. 
20:10:00 <ski> eds : the idiomatic/applicative `(<*>)' (and the corresponding monad operation `ap') can be used to "combine together several structures", but still can't be used to "let later actions depend on earlier results"
20:10:12 <xj54y> kadoban, if there's no .cabal-sandbox/bin/cabal, how then do I run cabal?
20:10:15 <ski> eds : finally, the monadic `(>>=)' *can* be used to "let later actions depend on earlier results"
20:10:53 <kadoban> xj54y: You're supposed to have already installed cabal somewhere that's in your PATH. How have you been running cabal in the previous commands we mentioned?
20:10:54 <TallerGhostWalt> so I was trying to install doctest and it depends on the 'ghc' package, I have 7.8.3 but lots of stuff using transformers-0.4.3 
20:11:09 <eds> that was confusing for me!
20:11:17 <TallerGhostWalt> should I not be using transformers-0.3.0 with ghc-7.8.3? 
20:11:29 <ski> eds : these are of course very rough shorthand expressions for what's really going on. they may be of limited value to you at the present. perhaps they could serve as a hint of what you should strive to understand better. and later as a shorthand reminder of that knowledge
20:11:34 <xj54y> kadoban, cabal is in ~/.cabal/bin but the sandbox, not so.
20:12:18 <kadoban> xj54y: I … think one of us is confused about something. I'm not sure what though.
20:12:28 <ski> eds : "So if it is declared Just once, it is going to preserve it throughout." -- if you use `fmap' (or one of its aliases), yes
20:12:29 <solirc> TallerGhostWalt: In general, re-installing packages that come with GHC can cause issues
20:12:42 <eds> yes. That is why I will note it down since it is valuable info. Will help me out future. 
20:12:47 <xj54y> kadoban, excuse me.. I've way tired and this dependency crisis has left my mind a bit loopy
20:13:12 <ski> eds : .. if you use `(<*>)'/`ap', then any one `Nothing' that you combine with will trump the `Just's, rendering the whole result `Nothing'
20:13:13 <xj54y> That and the euphoria of haskell and emacs has yet to leave me
20:13:30 <TallerGhostWalt> solirc: where do I find info on the ghc package?
20:13:58 <eds> ohhh! I need to look up <*> and ap.
20:14:04 <eds> :t <*>
20:14:05 <solirc> TallerGhostWalt: ghc-pkg list
20:14:05 <lambdabot> parse error on input ‘<*>’
20:14:05 <kadoban> xj54y: :) You just use the 'cabal' that you already have been using. The  .cabal-sandbox/bin/ directory will only have the executable(s) for the project you're working on, after you run 'cabal install', if that makes sense.
20:14:13 <eds> :t (<*>)
20:14:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:14:18 <solirc> TallerGhostWalt: 
20:14:33 <eds> :t ap
20:14:35 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:14:40 <xj54y> kadoban, oh.. So then I'll still need to bother with the dependency nonsense of haskell-platform? ;_;
20:14:48 <solirc> TallerGhostWalt: With GHC 7.8.* it's best to stick to transformers-0.3.0.0
20:15:07 <ski> eds : however, with `(<*>)'/`ap', you can only combine (in a certain sense) *independent* subcomputations, where it is not the case that one of them is defined in terms of the result of performing/running/executing the other. to get that extra ability, you need the monadic `(>>=)' (or, equivalently, the `<-' in `do'-notation)
20:15:13 <solirc> TallerGhostWalt: And if you want to use the GHC API you don't have any other good options
20:15:30 <kadoban> xj54y: Uhm, no? You shouldn't even /have/ platform. Sorry I thought that was clear. You install /only/ /only/ /only/ GHC and cabal. That's it.  Then you use cabal sandboxes and optionally stackage.
20:15:37 <TallerGhostWalt> solirc: okay I will try and force it back.  I was just having hella dependency issues
20:15:48 <TallerGhostWalt> w/ transformers 3
20:16:05 <xj54y> kadoban, hmm.. I'm going to take a 5 minute break.
20:16:08 <kadoban> xj54y: If you already have platform, uninstall it. Wipe out GHC and cabal and everything.  'which ghc' and 'which cabal' should output nothing. Then you install GHC, and cabal.
20:16:21 <ski> eds : `liftA2'/`liftM2' might be easier to grasp initially, than `(<*>)'/`ap' .. they're of equal power (given `fmap'/`(<$>)'/`liftA'/`liftM')
20:16:21 <eds> now that makes somewhat sense to me.
20:16:26 <ski> @type liftA2
20:16:32 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
20:16:40 <solirc> TallerGhostWalt: Try `ghc-pkg unregister` (this one never on packages that come with GHC) and `ghc-pkg check`
20:16:42 <kadoban> xj54y: K. I'll likely be back at various points (or other people can help, I'm far from an expert even)
20:16:44 <ski> @type liftA2 (,)  -- and perhaps in particular this
20:16:45 <lambdabot> Applicative f => f a -> f b -> f (a, b)
20:17:18 <ski> eds : see how that allows you to combine one `f a' "computation" with one `f b' computation, yielding one which produces both an `a' and a `b' as result ?
20:17:59 <eds> yes. that is mind = blowing
20:18:29 <TallerGhostWalt> solirc: thanks
20:19:10 <eds> I will be asking a lot of questions on monads. again. 
20:19:14 <ski> eds : some clarification. `(<*>)' and `ap' is basically the same thing. the former is what you need to implement, to make an instance of `Applicative'. the latter can be used as a handy default implementation of the former, if you've already defined `(>>=)' (and `return') in a `Monad' instance
20:19:24 <eds> I need to read all of it again to make more sense to me.
20:20:22 <ski> eds : if you have something which is an instance of `Applicative', but not of `Monad', then `(<*>)' is defined, but `ap' isn't. otherwise (in case both are defined), they *ought* (imho) to agree (there is some argument about this)
20:20:56 <xj54y> kadoban, how can I determine if I'm actually installing packages from stackage?
20:21:37 <solirc> TallerGhostWalt: or `rm -r ~/.ghc` if you want to get rid of all your installed packages
20:22:05 <ReinH> ski: it's hard to argue now
20:22:08 <ski> eds : now, `(<$>)' *is* `fmap', it's just an alternate (infix) notation for it. otoh, `liftA' and `liftM' *ought* to be the same as it, when defined (no real argument here, i think). and as before, `liftA' / `liftM' could serve as a handy default implementation of `fmap' if you happen to already have made an instance of `Applicative' / `Monad'
20:22:56 <kadoban> xj54y: https://www.stackage.org/ check there. There's a list, look at either nightly or LTS. LTS uses GHC 7.8.4 or nightly uses 7.10.x. If you want to be sure the things you're installing are from stackage, uncomment the line near the beginning in the cabal.config file you downloaded from stackage, the remote-repo one.
20:23:02 <Guest71779> Since I've been toying with a concatenative programming language (Reverse Polish Notation style), I feel like Haskell has unnessary syntax.
20:23:10 <ski> ReinH : i thought i saw Cale arguing this topic a few hours ago, and also some days ago ?
20:23:30 <eds> Writing it all down
20:23:33 <ReinH> ski: Um, isn't it a law in 7.10?
20:23:36 <ski> eds : please ask if you need elaboration
20:24:02 <ski> ReinH : possible. i don't see how that would stop anyone from arguing ..
20:24:10 <ReinH> ski: :p
20:24:17 <eds> Yes, sir.
20:25:36 <kadoban> ReinH: What law would it break?
20:26:09 <ski> kadoban : presumably a law `(<*>) = ap' ?
20:26:22 <kadoban> Is there one?
20:26:36 * ski hasn't checked
20:26:59 <xj54y> kadoban, meh.. running cabal update after uncommenting that line, I get "cabal: does not exist"
20:27:26 <Cale> It is a law. I mostly agree with it, but I have some reservations about that agreement :)
20:28:08 <kadoban> xj54y: I don't really understand what state you're in anymore. Are you still using the cabal and whatever from haskell platform?
20:28:10 <Cale> There are situations I've run into in the past where that law would have been somewhat of an inconvenience.
20:28:24 <ronh-> Cale such as?
20:28:27 <kadoban> xj54y: You mean 'cabal' doesn't exist, or that's some output from cabal? What does 'which cabal' say?
20:29:14 <xj54y> kadoban, that's the output from cabal.. output from which cabal is ~/.cabal/bin/cabal
20:29:35 <Cale> ronh-: One was a somewhat involved example of GUI widgets which had both an Applicative and Monad structure, but the primary Applicative structure that you'd want was much better and more important than the one you'd get from Monad.
20:30:28 <kadoban> xj54y: I have no idea what "cabal: does not exist" means, sorry. If you're still using platform, maybe … do that stuff before I mentioned so you're not.
20:31:33 <xj54y> kadoban, "Downloading the latest package list from stackage-nightly-2015-06-03 \ cabal: does not exist" 
20:33:11 <kadoban> xj54y: Did you change anything on the line accidentally maybe? Are you using GHC 7.10.1? I have no idea what'll happen if you're using GHC 7.8.4 with stackage nightly, maybe that'll give that error? Really dunno.
20:34:00 <ski> Cale : the idiomatic one being more "responsive", perhaps ?
20:34:09 <xj54y> kadoban, removed two dashes. I'm using GHC 7.8.4. So much confusion 
20:35:22 <kadoban> xj54y: Yeah, use http://www.stackage.org/lts-2.12 for GHC 7.8.4 (look at the top, it'll tell you what GHC version it's for)
20:40:47 <xj54y> kadoban, I'm noticing a pattern. Is there a safe way to update a dependency without breaking everything else?
20:41:53 <fried_brice> Does anybody know what to do with "Unrecognized stanza" in .cabal/config?
20:42:07 <fried_brice> I get "Unrecognized stanza on line 71"
20:42:22 <fried_brice> and line 71 is `Haddock`
20:43:57 <kadoban> xj54y: Not really, which is what the sandboxes, and to some extent stackage is for. sandboxes make it easy to wipe everything out and install new versions, without screwing up other projects. Stackage locks you to specific versions of most dependencies so you don't ever have to install different dep versions.
20:44:07 <dmj`> fried_brice: can you paste the full config on lpaste.net
20:45:55 <fried_brice> dmj`: here it is, http://lpaste.net/133848
20:46:50 <fried_brice> dmj`: I'm trying to set up stackage LTS global config, on ubuntu 14.04. I have the correct ghc version.
20:47:21 <dmj`> This is your global cabal.config, do you have a local project specific one as well?
20:47:52 <dmj`> fried_brice: are you using sandboxes?
20:47:56 <fried_brice> no, no projects yet, this is a new machine
20:49:22 <dmj`> fried_brice: you can delete it, then call cabal update and it should get recreated 
20:50:05 <fried_brice> dmj`: okay, i will try that. thank you.
20:52:33 <kadoban> xj54y: I gotta go away for a while, good luck. I'll be back later, or others can help I'm sure.
20:53:36 <fried_brice> dmj`: I let cabal rebuild its .cabal/config file, and I added the stackage lts list as directed on stackage.org, and I no longer get the "Unrecognized stanza" error. Thanks very much.
20:53:40 <xj54y> kadoban, no worries. All your efforts sum to my gratitude and it shall be returned very soon.
20:54:03 <xj54y> kadoban, for now, it'd be nice if hackage.haskell.org would quit timing out. Completely useless
20:54:48 <kadoban> xj54y: :) Yeah, hackage tends to do that a decent amount. The stackage website stuff is more reliable as far as I can tell, if they have what you're looking for.
20:55:39 <rasen> Is there Data.Vector dependently typed with length?
20:56:35 <fried_brice> `cabal update` still tells me "there is a new version of cabal-install available." even after running `cabal install cabal-install`. Is this to be expected when using Stackage LTS?
20:57:52 <dmj`> rasen: you might find this blog post interesting: https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
21:23:52 * hackagebot postgrest 0.2.10.0 - REST API for any Postgres database  http://hackage.haskell.org/package/postgrest-0.2.10.0 (begriffs)
21:27:34 <em> Are Flow Charts still popular among Computer Scientists?
21:28:24 <mniip> I don't remember last time I've seen one
21:30:27 <R0b0t1> em: UML is somewhat popular, but I'd suggest it's just a bunch of navel gazing for the most part.
21:30:42 <R0b0t1> also that's mostly software engineering, so...
21:30:48 <R0b0t1> which is definitely lots of navel gazing.
21:30:54 <em> i don't know what UML is really.
21:31:06 <R0b0t1> https://en.wikipedia.org/wiki/Unified_Modeling_Language
21:31:10 <R0b0t1> I ain't gonna do much better than that
21:31:18 <em> I was thinking - maybe teachers could try using flow charts, or something like a flow chart, to 'program' students to have skills or understanding. 
21:31:36 <em> Like just carefully make a flow chart and then give the students the flow chart and the student just keeps using it until they have the skill.
21:31:49 <R0b0t1> They are still kind of used to teach programming. Lots of visual languages are structured as flowcharts.
21:31:51 <R0b0t1> They all suck.
21:33:10 <R0b0t1> em: Generally, what is more important is to capture the relationships between data, not the steps executed upon them.
21:33:19 <R0b0t1> oh look we're in #haskell look at that :)
21:33:39 <em> well it could maybe be used to teach programming but i mean other subjects also. 
21:33:40 <joneshf-laptop> R0b0t1, is that really true?
21:33:59 <R0b0t1> em, oh oh I missed a few words
21:34:05 <R0b0t1> yes, that's generally quite successful.
21:34:20 <R0b0t1> i.e. Calculus up to III and beyond can be expressed as a flowchart
21:34:29 <R0b0t1> which will give you a solution to most problems with a solution
21:34:37 <R0b0t1> joneshf-laptop, what do you mean?
21:34:56 <AfC> Is there a practical limit in the number of constructors an ADT can have?
21:34:59 <ReinH> well, diagrams are popular in other areas of maths too
21:37:46 <Cale> ski: The "better" one would run the widgets in parallel, while the Applicative which came from the Monad instance would end up restarting the second widget whenever the first produced a result.
21:38:14 <em> R0b0t1: 'word problems' can be a bit tricky. Like a program where a student has to set up the equation before solving it rather than being given an equation to solve.
21:38:32 <ski> Cale : just efficiency ? or also behaviour ?
21:38:47 <em> R0b0t1: i wonder if you could make a flow chart that could solve a certain class of word problem.
21:38:54 <Cale> ski: Behaviour
21:39:07 <ski> em : hiya
21:39:17 <em> ski: heya!
21:39:49 <R0b0t1> em: technically yes, practically some things like filtering out extraneous information rely on "common sense" which is just a big flowchart only realistically expressed in one's head
21:40:02 <R0b0t1> em: really it's how they are already taught, most people just don't realize it
21:40:17 <R0b0t1> many problem solving strategies which many ascribe creativity to have no creativity in them at all
21:40:20 <R0b0t1> like calculus
21:40:26 <R0b0t1> creativity/intelligence
21:40:28 <ski> Cale : *nod*, ok
21:41:22 <R0b0t1> em: The one I know is "write down equations, write down unknowns, try to solve"
21:41:30 <R0b0t1> which solves the vast majority of problems
21:41:30 <Cale> ski: It's similar to what Simon Marlow was running into with concerns for efficiency, but since the widgets themselves had local state and would continue producing a stream of results, the Monad instance would result in do { v <- x; f v } restarting the "f v" widget each time a new "v" became available.
21:42:33 <Cale> ski: While the natural Applicative structure would be to just start both widgets and continue combining their results.
21:44:53 <ski> Cale : aye, i see
21:46:33 <ski> (i was remembering a paper where they wanted to a custom `ap' (before `Applicative' was invented), which was more "eager" than the standard one, in some somewhat similar sense .. hence they argued for `ap' to be a method of `Monad'. i don't recall if the difference there was only wrt partiality (i think it wasn't just efficiency), or if it was more in the behaviour lane)
21:46:38 <pacak> R0b0t1: 3 - think hard, 4 - write down solution.
21:49:47 <em> sadly this starbucks is closing rather soon. I could maybe go to McDonalds after that.
21:49:56 <em> oops sorry wrong channel
21:50:23 <ReinH> pacak: it worked for Feynman...
21:52:31 <pacak> ReinH: It's all about problem decomposition. I've been playing around with [some compicated stuff] recently and as long as you have your types right there's just one way you can possibly write code.
21:52:51 <ReinH> it's always nice when it works out that way
21:57:25 <pacak> One of the recent examples - I needed a function of type Maybe (Maybe  Foo, Maybe Foo)) -> Maybe Bar - there are more than one way you can write it, but as soon as I wrote it's type signature as Monad m => (a -> b -> c) -> m (m a, m b) -> m c - there was just one solution possible.
21:57:50 <dolio> Cale: If that's your example, I'm not convinced you have an example where the difference is sufficient to say it's a violation of the current specification.
21:57:52 <rasen> dmj`: this is vector which is plain list, I want one that's Vector from vector package
21:59:06 <dolio> Because you can just specify that '=' means that they produce guis that work equivalently for the user, but may be more or less efficient.
21:59:11 <mniip> pacak, does that still hold for 'Traversable t => (a -> b -> c) -> t (t a, t b) -> t c'
22:00:08 <dolio> Same with Simon Marlow's example.
22:00:48 <dolio> Or parsers.
22:00:55 <pacak> mniip: How do you go from t (t a) to t a?
22:01:46 <pacak> For Monad it's join
22:03:24 <fried_brice> em: you certainly can make a flow chart to solve a certain class of word problems.
22:04:01 <fried_brice> but you will almost certainly be able to craft a word problem that the students have the skills to solve (the maths skills) that the flow chart won't catch
22:08:51 <mniip> pacak, hmmm
22:15:35 <rayqiu> Wrote it to take subLists, can someone help to optimize this: http://lpaste.net/133851?
22:18:31 <xj54y> this is the craziest thing... I'm unable to complete sh bootstrap.sh from the cabal tarball from hackage... Mostly just timing out
22:18:35 <xj54y> Any alternatives?
22:19:31 <pacak> xj54y: timing out?
22:20:06 <xj54y> pacak, yes.. no response, cannot grab packages, hence timeout
22:20:32 <xj54y> Cannot connect to the host
22:20:53 <pacak> Try some other mirror for hackage?
22:21:00 <MarcelineVQ> does your distro not have a haskell package?
22:21:13 <xj54y> That would be nice, but I don't know what mirrors are available
22:21:32 <pacak> MarcelineVQ: Mine does, but it's ancient.
22:21:37 <xj54y> MarcelineVQ, it does, and it's very nice. Unfortunately, I'm not the biggest fan of hell.
22:22:37 <pacak> xj54y: When hackage goes down - I usually google "hackage mirror" - there is at least one mirror available.
22:23:29 <xj54y> pacak, how can I change the host in these configs? Like, tar -xzvf CabalPackage.. and then what do I need to change?
22:24:28 <pacak> xj54y: Something like this: sed -i 's/hackage.haskell.org/mirror.blah/' */**/*
22:24:56 <xj54y> pacak, that'll work. Thanks :-)
22:26:13 <ReinH> you can add it in a cabal.config file
22:26:30 <xj54y> There's no cabal.config file in the directory
22:27:06 <xj54y> Meh, swapping the url, the file doesn't exist remotely.. 
22:27:10 <xj54y> This is pretty lame.
22:28:16 <ReinH> oh, for bootstrap.sh, that wouldn't use a cabal.config file anyway, so never mind
22:30:54 <xj54y> Holy wow, it finally downloaded from hackage! :O
22:31:06 * xj54y adjusts chair
22:34:45 <Pamelloes> How can I get ghc 7.10 on nix?
22:35:57 <dmj`> Pamelloes: nix-env -i ghc
22:36:11 <dmj`> Pamelloes: it's the default
22:37:02 <Pamelloes> dmj`: Huh, I'm getting ghc 7.8.3...
22:37:36 <pacak> Pamelloes: Download and  compile one yourself?
22:38:08 <dmj`> Pamelloes: try to update your channel, 'nix-channel --update'
22:49:49 <ttt_fff> can IO ever be the inner monad? i.e. can I do "stateT IO" and then thus get s -> IO (a, s) ?
22:49:58 <ttt_fff> I recall some rumor taht IO must be the 'outer' monad or osmething
22:50:18 <liste> IO must be the innermost monad
22:50:31 <liste> because there's no IOT
22:50:37 <ttt_fff> oh
22:50:44 <ttt_fff> I am a retard
22:50:45 <ttt_fff> this makes sense now
22:50:47 <ttt_fff> thanks :-)
22:50:52 <liste> no problem (:
22:56:42 <Cale> StateT also isn't a monad
22:57:12 <Cale> StateT s is a monad transformer for each type s. IO is a monad, so StateT s IO is a monad.
22:59:18 <Cale> (this might be a little picky of me, but I think it's worthwhile being a bit picky about terminology like that)
23:00:13 <johnw> having people be picky about terminology is part of the #haskell experience
23:00:18 <Cale> :D
23:01:37 <Cale> Functors can be composed to yield new functors, and applicative functors can be composed to yield new applicative functors, but in general the composite of two monads isn't a monad.
23:01:50 <Cale> However, the composite of monad transformers will give you a monad transformer.
23:03:04 <Cale> (This fact is exploitable, but I think it's actually less useful in practice than many comparable statements.)
23:03:16 <ski> pacak : actually two (which are equal in case your monad is "commutative")
23:05:01 <pacak> ski: If you have just Monad m constraint - the only thing you can do is to apply those inside together with <*>  to a given function then join, no?
23:08:18 <ski> pacak : there's `\f -> (join . fmap) (\(ta,tb) -> liftM2 (\a b -> f a b) ta tb)' and there's `\f -> (join . fmap) (\(ta,tb) -> liftM2 (\b a -> f a b) tb ta)'
23:08:45 <ski> pacak : expressed differently, you could use `(<**>)' instead of `(<*>)'
23:08:48 <ski> @src (<**>)
23:08:48 <lambdabot> (<**>) = liftA2 (flip ($))
23:10:47 <pacak> ski: Right, it will be slightly different in some cases.
23:11:17 <zipper> Hey, say I have two packages with the same module name.
23:11:38 <zipper> In this case System.FilePath.Glob is from Glob and filemanip
23:11:39 <pacak> zipper: package qualified imports
23:11:45 <zipper> I want to use the one from Glob
23:13:24 <zipper> pacak: Uh nothing here: https://wiki.haskell.org/Import
23:14:20 <pacak> {-# LANGUAGE PackageImports #-}
23:14:20 <pacak> import "network" Network.Socket 
23:14:28 <ski> pacak : like the difference between first removing shoe, and then donning a sock vs. first donning a sock, and then removing a shoe
23:14:53 <ski> .. or firmly gripping branch with one hand before releasing it with the other one vs. ...
23:15:34 <pacak> ski: Yep, trying to figure out what constraints to add if I want comutative monads...
23:15:55 <ski> there's no type class for that (perhaps there should be)
23:20:46 <Cale> http://www.reddit.com/r/haskell/comments/38g5ts/haskellers_view_of_closures_how_is_this_stuff_an/ -- hooray, people responding with "closures are an implementation detail" :)
23:21:12 <kristof> edwardk mentioned that Philip Wadler misunderstood what someone else meant about constrained types and then gave us typeclasses. Can someone elaborate on this?
23:21:30 <kristof> I'm sorry, specifically he mentioned this in a very long talk on lenses
23:21:51 <kristof> Oh, no, it was a long talk on typeclasses.
23:49:01 * hackagebot yesod-core 1.4.10 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.10 (MichaelSnoyman)
