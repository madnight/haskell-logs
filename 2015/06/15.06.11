00:05:39 <dzack> anyone know if acid-state keeps a transaction log?
00:06:11 <dzack> i.e., if the db state is updated, can you count on that update being written eventually?
00:06:18 <Axman6> it appears to keep something akin to a transaction log
00:07:34 <Axman6> there's a command which I believe removes the log once the entries have all had their effect, snapshot I think?
00:07:38 * hackagebot Neks 0.4.0.0 - Simple networked key/value store  http://hackage.haskell.org/package/Neks-0.4.0.0 (wyager)
00:07:38 * hackagebot fay-geoposition 0.1.0.1 - W3C compliant implementation of GeoPosition API.  http://hackage.haskell.org/package/fay-geoposition-0.1.0.1 (eocallaghan)
00:10:32 <liste> it records the updates, replays them when needed and you can take snapshots in the background
00:14:59 <liste> acid-state is awesome, I wish it could keep the dataset on disk
00:15:19 <johnw> like... a database? :)
00:15:46 <Axman6> liste: what do you mean? it's already stored to disk no?
00:18:38 <liste> the log is stored on disk, the data itself is in memory
00:20:21 <dzack> oh huh - does it replay every transaction when you start your program?
00:20:33 <liste> dzack from the last checkpoint
00:21:57 <liste> but you can create checkpoints concurrently with transactions
00:24:22 <bvun> what does it mean when I get "Main: <<loop>>" as output when running a compiled program?
00:24:46 <liste> > let x = x in x
00:24:51 <lambdabot>  mueval-core: Time limit exceeded
00:25:03 <liste> bvun it means there's infinite recursion somewhere
00:26:34 <liste> that the runtime detected as infinite
00:27:13 <liste> > let x = x + 1 in x
00:27:17 <lambdabot>  mueval-core: Time limit exceeded
00:28:38 <liste> seems lambdabot doesn't detect them, I get <<loop>> on those with GHCi
00:29:34 <bvun> liste alright, so I'm trying to build a tree of strings and print it as a string (just to check if it works), but I can't see what's wrong http://www.pastebin.ca/3024333
00:30:41 <liste> bvun line 5, you use `tree', not `acc'
00:30:55 <liste> so you insert stuff into the resulting tree
00:31:09 <liste> (or try to)
00:31:22 <liste> not the empty one you gave to foldl
00:31:51 <bvun> alright, I'll try, thanks!
00:33:15 <learns> hello there
00:34:00 <bvun> It worked. I'm not quite sure how foldl works tbh :)
00:36:48 <liste> foldl (+) 0 [1,2,3] == (((0 + 1) + 2) + 3)
00:38:15 <liste> > foldl (+) x [y, z]
00:38:20 <lambdabot>      Ambiguous occurrence â€˜xâ€™
00:38:20 <lambdabot>      It could refer to either â€˜L.xâ€™, defined at L.hs:154:1
00:38:20 <lambdabot>                            or â€˜Debug.SimpleReflect.xâ€™,
00:39:07 <liste> didn't lambdabot have some symbolic thingy with x,y,z ?
00:43:32 <bvun> so the function (\tree x -> insert x tree) is from a tree with type x to a tree resulting from a call to insert with that tree and an element of the tree's type..?
00:44:46 <liste> it's from a tree AND an element to another tree
00:45:02 <liste> with the element inserted
00:45:22 <bvun> oh of course
00:45:25 <bvun> thank you
00:45:29 <liste> np (:
00:50:35 <absence> :t Compose [Just 2]
00:50:38 <lambdabot>     Not in scope: data constructor â€˜Composeâ€™
00:50:38 <lambdabot>     Perhaps you meant variable â€˜icomposeâ€™ (imported from Control.Lens)
00:51:01 <arkeet> @let import Data.Functor.Compose
00:51:03 <lambdabot>  Defined.
00:51:19 <arkeet> :t Compose [Just 2]
00:51:23 <absence> ahhh ^_^
00:51:25 <lambdabot> Num a => Compose [] Maybe a
00:51:34 <absence> thank you
01:00:09 <Soft> hmm, I am trying to fit together Scotty's ActionT and a custom monad transformer stack
01:00:33 <Soft> basically the monad transformer I have is a StateT and some other stuff
01:01:36 <Soft> My understanding is that I would have to run the monad transformer at every request, save the state somewhere, and then before executing the next request, restore the monadic state
01:02:12 <Soft> I was wondering if monad-control is something that could be used to archieve this, I haven't used it before
01:06:54 <gfixler> anyone have feelings about scoped labels? (http://research.microsoft.com/pubs/65409/scopedlabels.pdf)
01:12:47 <liste> Soft do you want the state to persist between requests?'
01:12:58 <liste> oh nvm, you do
01:13:12 <liste> what if two requests come concurrently?
01:14:22 <liste> what if your app crashes and you need to restart it?
01:17:15 <Soft> liste: well, in this case the web interface is just for a local application so it probably won't see that much concurrency and I can handle saving the state elsewhere
01:17:36 * hackagebot tip-lib 0.1.1 - tons of inductive problems - support library and tools  http://hackage.haskell.org/package/tip-lib-0.1.1 (DanRosen)
01:17:38 * hackagebot tip-haskell-frontend 0.1.1 - Convert from Haskell to Tip  http://hackage.haskell.org/package/tip-haskell-frontend-0.1.1 (DanRosen)
01:18:10 <Soft> I think I could have a TVar with the state and then restore the monadic context from that before handling each request
01:18:27 <Soft> I was just wondering if there is a neat way to do that using monad-control
01:25:00 <johnw> monad-control would let you do that
01:25:09 <johnw> i'm not sure he ever included my "extract" function...
01:27:25 <johnw> i.e., it's possible to write:  MonadBaseControl b m => m (StM m a)
01:31:22 <johnw> extract = liftBaseWith ($ return ())
01:33:09 <Gurkenglas> Is there a way to use additional packages on fpcomplete?
01:35:24 <dzack> another question -using Data.map, is there a way to automatically create a key if it is not found?
01:35:35 <dzack> Without doing a manual check, of course
01:35:43 <breadmonster> dzack: As in?
01:36:02 <dzack> Well, right now I'm using adjust to modify values
01:36:28 <dzack> And ideally, I'd like to just create the key and perform the adjust when the key isn't in the map
01:37:06 <dzack> Concrete example: It's basically a Map String (Set Int)
01:37:27 <dzack> The adjust function currently uses Set.insert someNumber
01:38:07 <dzack> But if the key isn't found, adjust just gives you back the original map
01:38:44 <breadmonster> Hmm, there's no function, you'll have to write one.
01:39:13 <dzack> Figured as much, but worth checking! thanks
01:41:35 <johnw> Soft: https://github.com/basvandijk/monad-control/pull/29
01:41:45 <hnfmr> data BlockedFetch r = forall a. BlockedFetch (r a) (ResultVar a)
01:41:51 <hnfmr> is this called ExistentialQuantification?
01:41:54 <johnw> yes
01:42:01 <hnfmr> thanks
01:42:18 <johnw> because you must choose an a in order to construct the value
01:44:19 <merijn> hmmm, are there any good concurrent map data structures?
01:44:29 <bvun> If I run a compiled program and for some instruction it prints "Main: empty", what does it mean?
01:44:50 <merijn> I need to associate keys with a value, but going through Map in an MVar/TVar would result in too much contention
01:45:03 <merijn> bvun: What does your main look like? (lpaste.net)
01:47:37 * hackagebot ghcid 0.4.1 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.4.1 (NeilMitchell)
01:48:39 <breadmonster> merijn: Do you know anything about compilers?
01:49:03 <breadmonster> I'm trying to figure out how to compile lambdas.
01:49:18 <breadmonster> To machine code.
01:49:23 <merijn> breadmonster: It depends on how you're implementing your language...
01:49:41 <breadmonster> In Haskell.
01:49:52 <breadmonster> It's dynamically typed.
01:50:00 <merijn> I would treat lambda's as syntactic sugar
01:50:17 <bvun> merijn: http://www.pastebin.ca/3024373 It builds a tree of Strings and prints statistics, what I'm having trouble with is the call to checkTree which checks that the invariants hold and then returns a Bool
01:50:20 <merijn> Lift them out into a real function with a compiler generated name and insert the name in place of the lambda
01:50:36 <breadmonster> merijn: Okay, fine.
01:50:46 <Hafydd> Lambdas aren't real functions. :(
01:50:50 <breadmonster> What about lambdas that capture their environments?
01:51:10 <breadmonster> makeLambda x = \y -> y + x?
01:51:18 <merijn> breadmonster: Those are just the same as partially applied functions
01:51:26 <merijn> bvun: And it only prints "empty"? that seems unlikely
01:51:29 <merijn> Hafydd: Why not?
01:51:44 <merijn> Hafydd: oh, you mean my remark
01:51:58 <Hafydd> merijn: if they are, then your suggestion of "lift them out into a real function" becomes easier.
01:52:01 <merijn> Hafydd: Depending on your language design I wouldn't treat lambda's as a builtin
01:52:37 <breadmonster> merijn: I'm compiling Python btw
01:52:49 <breadmonster> Either to C or to Java.
01:52:57 <bvun> merijn: http://www.pastebin.ca/3024380
01:53:21 <merijn> Python is a terrible first language to implement....
01:53:26 <breadmonster> depending on how lazy I am.
01:53:29 <merijn> Not formal design/spec at all
01:53:39 <breadmonster> I tried C++
01:53:49 <breadmonster> that was worse.
01:53:58 <breadmonster> still can't implement C++11.
01:54:22 <merijn> bvun: Right, so checkTree is somehow throwing an exception
01:54:42 <merijn> breadmonster: Maybe you want to start with a simpler language as beginner :)
01:54:51 <breadmonster> Any tips?
01:54:57 <merijn> Something that just does functions, few loop constructs and if/else
01:54:58 <bvun> merijn: okay, thanks, I'll look into it
01:55:25 <merijn> breadmonster: Have a look at http://www.stephendiehl.com/llvm/
01:55:46 <breadmonster> I've implemented Scheme if that counts...
01:55:57 <ronko> I have heard conflicting opinions about Haskell and text. On the one hand Haskell is good for writing compilers but on the other hand it is not good at processing text (slow). Those seems contradictory to me since compiling partly is about processing text. 
01:56:13 <merijn> ronko: Who says haskell is bad at processing text?
01:56:29 <merijn> ronko: Only reason I can think of for it being slow is doing something dumb like using String
01:56:29 <earthy> ronko: haskell is perfectly fine if using Data.Bytestring and Data.Text.
01:56:42 <merijn> ronko: Additionally, compiling is not really about processing text
01:57:02 <merijn> ronko: Processing text is like 0.5% of where GHC spends it time when compiling, for example
01:57:05 <earthy> plus, there's a distinction between strings of characters and text meant for human consumption.
02:00:19 <tdammers_> there's also a distinction between strings of characters and strings of bytes
02:00:36 <tdammers_> haskell takes this distinction more seriously than many other languages
02:00:46 <hnfmr> johnw: data BlockedFetch r = forall a. BlockedFetch (r a) (ResultVar a)  so I can represent a list of BlockedFetch r with different "a"? e.g. [BlockedFetch UserReq [Id], BlockedFetch UserReq Name] :: [BlockedFetch UserReq]
02:01:13 <johnw> yes
02:01:17 <johnw> but youl'l find it hard to use later
02:01:39 <hnfmr> data UserReq a
02:01:57 <johnw> that's why such data types often comes with an a -> Foo function, so you can render your value into something common later
02:02:11 <breadmonster> btw, if I want to use UTF8 Strings, what data type do I use?
02:02:11 <hnfmr> yes, is this GADT?
02:02:17 <breadmonster> Text or ByteString?
02:02:17 <johnw> no
02:02:30 <merijn> breadmonster: Text or String
02:02:40 <breadmonster> merijn: And UTF16?
02:02:50 <ronko> I have another problem as well. I love embedding and smartphone programming. But I also really like Haskell. I just can't come up with an interesting project in a domian where Haskell is suited. Like for smartphone better stick to Java (Scala and Clojure in practicality do not offer an improvement), for embedded your basically stuck with C.
02:02:53 <merijn> breadmonster: UTF8 string is not a sensible notion
02:03:00 <merijn> breadmonster: You either have encoded binary data or unicode
02:03:15 <breadmonster> merijn: I mean Unicode.
02:03:24 <merijn> ronko: Implement a DSL for embeded in haskell and do your project with that!
02:03:44 <merijn> breadmonster: Text/String is unicode, ByteString is binary data those are the only things you need
02:05:24 <breadmonster> merijn: I thought Char was limited to ASCII characters?
02:06:14 <ronh-> > length ([minBound..] :: [Char])
02:06:18 <tdammers_> breadmonster: if you want to work with unicode strings, use Text (or, god forbid, String). If you want to work with an encoded representation, use ByteString
02:06:19 <lambdabot>  1114112
02:06:30 <tdammers_> Char is a unicode code point
02:06:44 <tdammers_> > :t 'Ã¤'
02:06:46 <lambdabot>  <hint>:1:1: parse error on input â€˜:â€™
02:06:51 <tdammers_> :t 'Ã¤'
02:06:53 <lambdabot> Char
02:07:29 <tdammers_> the whole point of a unicode string type like Text is so you don't have to deal with encoding at that stage
02:12:21 <breadmonster> Oh perfect.
02:13:04 <merijn> Text is by far the least broken unicode datatype I've seen in any language so far
02:13:51 <f|`-`|f> Not sure what to say about that
02:13:58 <f|`-`|f> Other than ask, how?
02:14:12 * arkeet wonders if Text using UTF-16 is worth the space saving compared to UTF-32, given the loss of O(1) length/indexing/whatever
02:14:24 <merijn> arkeet: UTF-32 doesn't give you O(1) indexing
02:14:31 <arkeet> eh
02:14:36 <merijn> arkeet: You have combining characters
02:14:42 <arkeet> :/
02:14:52 <merijn> arkeet: So character based indexing still needs a scan
02:14:52 <breadmonster> Okay, I need to really look up how Unicode works.
02:15:01 <arkeet> but do we index by characters, or by code points
02:15:04 <merijn> It can only give you O(1) codepoint indexing, but whoever wants that
02:15:23 <merijn> arkeet: Name one sensible use case where you want to index to a codepoint over a character
02:15:35 <arkeet> I dunno.
02:15:38 <merijn> f|`-`|f: How what?
02:15:42 <arkeet> why is text hard.
02:15:49 <merijn> arkeet: Because languages are hard
02:17:31 <arkeet> do Text operations as they are now work by characters, or by code points?
02:17:38 <merijn> arkeet: "mu"
02:17:39 * hackagebot ghcid 0.4.2 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.4.2 (NeilMitchell)
02:17:48 <arkeet> ?
02:18:08 <merijn> arkeet: Mu is the zen "non-answer" to a question that cannot be answered :p
02:18:18 <arkeet> why can it not be answered?
02:18:34 <merijn> Because this is most likely operation dependent
02:18:44 <arkeet> ok, let's pick a specific one.
02:18:45 <arkeet> length
02:19:59 <arkeet> if I'm understanding the code correctly, it works by code points.
02:20:29 <merijn> Looks like codepoints
02:20:54 <f|`-`|f> How is Text the least broken unicode datatype?
02:20:55 <breadmonster> merijn: Umm, why is the length O(n)?
02:21:11 <f|`-`|f> @src length
02:21:11 <lambdabot> Source not found. That's something I cannot allow to happen.
02:21:15 <f|`-`|f> dammit
02:21:15 <merijn> breadmonster: How could it be anything else?
02:21:25 <breadmonster> merijn: I was just looking at documentation for Data.Text
02:21:28 <merijn> f|`-`|f: Name a language that has a less broken unicode datatype
02:21:31 <arkeet> breadmonster: because UTF-16 is a variable length encoding.
02:21:34 <breadmonster> merijn: It's calculating the length of an array...
02:21:39 <arkeet> it is not.
02:21:40 <merijn> breadmonster: No it's not
02:21:51 <breadmonster> It's not?
02:21:55 <f|`-`|f> I'm asking for some positive information, not having to prove a negative proof
02:21:58 <arkeet> some code points take 2 bytes.
02:22:00 <arkeet> some code points take 4 bytes.
02:22:11 <arkeet> you have to look at everything to determine what's what.
02:22:14 <breadmonster> Isn't Text a contiguous number of Char points?
02:22:16 <merijn> f|`-`|f: I've worked with unicode in 8 different languages, all of them were worse than Text
02:22:24 <f|`-`|f> names pls?
02:22:29 <breadmonster> arkeet: Hmm, wait what?
02:22:36 <f|`-`|f> because List is no an array, breadmonster 
02:22:41 <breadmonster> I thought Unicode was 4 bytes long.
02:22:53 <breadmonster> f|`-`|f: I'm talking about Data.Text
02:23:00 <f|`-`|f> oh
02:23:02 <breadmonster> arkeet: So Unicode is not 4 bytes long?
02:23:03 <merijn> f|`-`|f: C, C++, Java, python, JS, ruby, ocaml
02:23:04 <arkeet> if you read the documentation for Data.Text, you will see
02:23:09 <arkeet> "internally, a Text value is represented as packed UTF-16 data."
02:23:12 <nshepperd> Data.Text uses a variable-length encoding
02:23:15 <merijn> f|`-`|f: Ok, so 7 instead of 8, but I'm sure I'm forgetting one
02:23:27 <breadmonster> merijn: You're good at OCaml?
02:23:29 <merijn> f|`-`|f: Well, I've used PHP years ago once and I'm pretty sure their unicode is worse too
02:23:32 <breadmonster> One second brb
02:23:33 <merijn> breadmonster: No :p
02:23:54 <f|`-`|f> well it's php, merijn 
02:24:00 <f|`-`|f> I'm sure it's not hard
02:24:14 <merijn> f|`-`|f: So there you go, 8 languages whose unicode sucks more than Text :)
02:25:03 <arkeet> anyway, so since Text operations work on code points, we could have O(1) length and indexing if it used UTF-32.
02:25:23 <f|`-`|f> It'd probably have to be strict Text
02:25:26 <merijn> arkeet: Except you ruin your caching, so might lose performance that way
02:25:34 <merijn> arkeet: This stuff is hard! :p
02:25:45 <f|`-`|f> yes no?
02:25:46 <arkeet> but my question is: is it worth it?
02:25:46 <merijn> Also, memory consumption
02:25:55 <merijn> arkeet: You could prototype it to see!
02:26:00 <arkeet> that's a lot of work.
02:26:08 <merijn> arkeet: There was a UTF8 prototype for Text and that turned out slower too
02:26:21 <tdammers_> don't recent iterations of the unicode standard specify >32bit code points even?
02:26:22 <f|`-`|f> Quick Check, and the GHC profiler is the bee's knees
02:26:24 <merijn> arkeet: Most languages/OSes seems to use UTF-16 
02:26:31 <tdammers_> or am I remembering wrong?
02:26:33 <merijn> arkeet: i.e. windows, OSX, python, java, etc.
02:26:34 <arkeet> tdammers_: I thought it only went up to 0x10ffff
02:26:43 <merijn> tdammers_: I think you're remembering wrong
02:26:57 <f|`-`|f> why do we need more characters
02:27:04 <f|`-`|f> can't we just use meta characters?
02:27:12 <arkeet> what are meta characters?
02:27:24 <f|`-`|f> Something that unicode implements as well
02:27:36 <f|`-`|f> more or less how you get the weird zalgo text
02:27:45 <f|`-`|f> or ligaments on some characters
02:27:52 <merijn> Those are combining codepoints, the entire thing ruining O(1) indexing :p
02:27:52 <arkeet> combining characters?
02:28:01 <arkeet> merijn: character indexing.
02:28:11 <merijn> Right
02:28:13 <f|`-`|f> think of it like how latext does 3_3
02:28:23 <f|`-`|f> "_" is a subscripting meta character
02:28:31 <f|`-`|f> unicode has that as a special character
02:28:36 <arkeet> what if you want an entirely new character?
02:28:42 <f|`-`|f> it turns out, you can chain them arbitraily
02:28:49 <f|`-`|f> you have to make aew character
02:28:50 <merijn> arkeet: Like an emoji for pooping unicorns?
02:28:54 <arkeet> yeah.
02:29:01 <f|`-`|f> but generally
02:29:10 <arkeet> or a new language/script.
02:29:10 <f|`-`|f> the meta characters are for when you want ligaments for days
02:29:19 <f|`-`|f> at various orientations
02:29:24 <rom1504> so 3_{3_{3_{3_...}}} is just one character ?
02:29:25 <f|`-`|f> or translations
02:29:40 <f|`-`|f> it's how people do the zalgo text
02:29:47 <arkeet> ok, this might be a stupid question but.
02:29:50 <f|`-`|f> that has weird runes going up down and around
02:29:58 <f|`-`|f> it's terrible
02:30:00 <arkeet> why would someone care about indexing a piece of text?
02:30:10 <rom1504> arkeet: google
02:30:16 <f|`-`|f> splicing subcharacters?
02:30:16 <arkeet> I mean
02:30:18 <arkeet> with an index.
02:30:21 <arkeet> getting the n'th character.
02:30:37 <nshepperd> it seems like most of the time with text you really want to index by word or paragraph or line or ... rather than code points or characters
02:30:49 <arkeet> or getting the length of a piece of text.
02:30:56 <merijn> rom1504: No, LaTeX does custom typesetting instead of special character for that
02:31:13 <nshepperd> so you really end up using a custom rope type or something with a monoidal measure
02:31:14 <tdammers_> mostly because people conflate "text" and "byte arrays" and "source code" and "protocol streams" and a bunch of other things
02:31:19 <merijn> nshepperd: Right, which is O(n) anyway, hence not much point in getting O(1)
02:31:26 <tdammers_> unfortunate consequence of the otherwise genius Unix approach
02:31:34 <nshepperd> or like a finger tree of Data.Text fragments
02:31:47 <nshepperd> which lets you do all that in O(log n)
02:32:02 <merijn> nshepperd: If you care about this stuff I have a good paper on data structurers for editable text I found
02:32:12 <f|`-`|f> TÌ”Í‹ÌÍ£ÌŒÌ¿hÍ£ÍiÌ…ÍˆÌŸÌ¤Ì®ÌºsÌ‰Ì¶Í–Ì¤Ì¤Ì¤Íˆ Ì‹Ì½Í¤ÍÍ¥ÍƒÍ–ÍÌ™Ì²Í…ÌœiÌ‘ÌŒÍ’Ì›Ì—Í‰Ì–Ì«ÌªÍsÌ“ÌšÌ…Ì¿Ò‰ÍˆÍ…Ì±ÌÌ« Í¥Í§ÌÌ„Í¯Ì™Ì¼Ì«ÌœÌ®wÌ‚Ì…Í‰hÌ…ÍŠÍ­aÍ¦Í‚Í¥ÍŠÌ¿Í¥Í‚Ì»Ì¥Ì¦Ì¼tÍ¯Ì…Í›Ì€ÍƒÍ«Ì’Ì¸Í”ÍˆÍ‰Í“ÍÌ«Ìª Í¦ÌÌ¢Í•Ì°Ì–IÌ’Í¯Í¢Ì¤Ì¦Ì²Ì¼Ì Í‡Ì— ÌÌ¤ÍmÌ”ÌÌ‡Ì©ÍÌ˜Ì±ÍšÌ¹Ì eÍŸÍ‰Í–Ì¦aÌˆÍ‚ÍªÒ‰Ì–Ì®ÍÌ®nÌ½ÍÍ—Ì¿Í¬Ì”Ì“Ì¼Ì£Ì— Í®ÌˆÍ‹Í€bÌ¼ÌŸÌ ÍˆyÌŠÌ§Í™Ì£Ì»Ì–Ì°Í“Ì² Í‘Ì“ÌŒÌŠÌÍƒÍ¯Ò‰Ì»Í–Ì¥Ì™zÌƒÍ¥Í¨ÌÌªÌ¹Ì¥ÍaÌÌ‰Í¥ÌŸÌ
02:32:14 <f|`-`|f> ©Ì¹Ì¥Í”ÌŸÍlÍ›ÍªÍ‹ÌÍ‚Í¨Í¦Ì·Ì¤Ì³Ì¹Ì²Ì±Ì¦gÍ¥ÍƒÌÍ©Í¡ÌŸÌ¯oÌ…Ì…Ì‰Ì…Í‚Í—Í§ÍŸÍ Í®Ì‹Í†Í‰Í“tÍŠÌ…Ì‘Í®Ì¨Í™ÍÌ¼Ì¼ÍÌ©eÍ‘Ì½Ì…Ì€Ì“ÌŠxÍ«ÍÌÍÌ«Ì™tÌ†Ì´ÌÌ³Í“Íˆ
02:32:16 <bernalex> is there some way to make an adt like 'data Foo = NotFoo | MkFoo a' derive Enum based on a, so that NotFoo is minBound?
02:32:19 <f|`-`|f> it is
02:32:23 <f|`-`|f> god awful abuse
02:32:25 <johnw> f|`-`|f: you almost triggered my kickban reflex :)
02:32:29 <merijn> bernalex: That's exactly what it does
02:32:37 <f|`-`|f> of unicode
02:32:37 <arkeet> you can't derive Enum for that, can you?
02:32:38 <alpounet> we do have a rope library https://hackage.haskell.org/package/rope
02:32:38 <merijn> bernalex: minBound is just the first constructor
02:32:54 <merijn> bernalex: Oh, wait, only if 'a' is not existential
02:33:03 <f|`-`|f> good reflex to have, johnw 
02:33:17 <nshepperd> f|`-`|f: is that supposed to be unreadable nonsense, or do you not have utf-8 configured?
02:33:27 <bernalex> merijn: a is Int in my case
02:33:34 <f|`-`|f> It's flagrant abuse of meta charaacters to make something that lookss awful
02:33:56 <f|`-`|f> it probably doesn't work like LaTeX
02:33:58 <merijn> bernalex: Enum takes all constructors in order and then for every constructor with an enum argument it uses that ordering within the constructor, AFAIK
02:34:04 <nshepperd> I just see a lot of upper case I's with acute
02:34:13 <johnw> I have a unicode enabled IRC readers, but I didn't see anything in what f|`-`|f pasted except a bunch of escaped character codes
02:34:19 <merijn> @let data Foo a = NotFoo | Foo Int deriving (Enum, Bounded)
02:34:22 <lambdabot>  .L.hs:179:1:
02:34:22 <lambdabot>      Multiple declarations of â€˜Fooâ€™
02:34:22 <lambdabot>      Declared at: .L.hs:147:1
02:34:23 <f|`-`|f> well shit
02:34:23 <merijn> johnw: Worked here
02:34:30 <f|`-`|f> it's possibly something else
02:34:31 <bernalex> merijn: point is it can't derive Enum for what I just wrote.
02:34:31 <alpounet> I saw the same as merijn, fwiw
02:34:32 <merijn> @undefine
02:34:33 <lambdabot> Undefined.
02:34:35 <merijn> @let data Foo a = NotFoo | Foo Int deriving (Enum, Bounded)
02:34:37 <lambdabot>  .L.hs:144:22:
02:34:37 <lambdabot>      Can't make a derived instance of â€˜Enum (Foo a)â€™:
02:34:37 <lambdabot>        â€˜Fooâ€™ must be an enumeration type
02:34:39 <johnw> Ø§ÙŠÙ† Ø§Ù…ØªÙ‡Ø§Ù† Ø§Ø³Øª
02:34:41 <merijn> oh, uh
02:34:45 <merijn> @let data Foo = NotFoo | Foo Int deriving (Enum, Bounded)
02:34:47 <lambdabot>  .L.hs:144:20:
02:34:47 <lambdabot>      Can't make a derived instance of â€˜Enum Fooâ€™:
02:34:47 <lambdabot>        â€˜Fooâ€™ must be an enumeration type
02:34:47 <johnw> that renders fine
02:34:50 <merijn> awww
02:34:54 <nshepperd> merijn: I would be interested in seeing that paper
02:34:58 <merijn> bernalex: Gess you have to handwrite it
02:35:08 <f|`-`|f> I'm on utf-8, which is probably not unicode
02:35:16 <bernalex> merijn: meaning? instantiate it myself?
02:35:17 <mhi^> merijn: I'd be interested in that data structures paper. :)
02:35:21 <liste> utf-8 is a serialization of unicode
02:35:30 <liste> or representation even
02:35:35 <bernalex> does ghci have a nice way to spit out what the minimum implementation of a typeclass instance is? that would be nice.
02:35:40 <merijn> nshepperd, mhi^: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.48.1265&rep=rep1&type=pdf
02:35:50 <mhi^> merijn: Thank you.
02:36:01 <arkeet> bernalex: a minimal complete definition? I don't think so.
02:36:07 <merijn> bernalex: Yeah, I guess I misremembered and you can't derive it
02:38:01 <bernalex> merijn: but what Bounded instance makes sense for this anyway?
02:38:35 <bernalex> just uh minBound = NotFoo, maxBound = MkFoo (maxBound :: Int)?
02:38:40 <bernalex> I guess that makes sense
02:38:43 <merijn> bernalex: I'd say so
02:38:58 <bernalex> should be able to derive Enum when giving that instance IMO
02:42:40 * hackagebot tip-lib 0.1.2 - tons of inductive problems - support library and tools  http://hackage.haskell.org/package/tip-lib-0.1.2 (DanRosen)
02:59:50 <hsyl20> is there a cabal command to list newer versions of dependencies?
03:11:53 <hnfmr> data SubCache res = SubCache ! (HashMap (req a) (res a))
03:11:56 <esimp> I'd like to annotate my computations with physical units such as 'meters, radians', etc.  and have them statically typecheck.  I see a few different libraries available -- anyone have a suggestion for the most widely used?
03:12:19 <hnfmr> what is the "!" there? like array access?
03:12:25 <hnfmr> or strictness?
03:14:11 <bergmark> hnfmr: strictness
03:14:48 <hunteriam> When you put strictness inside a datatype what does it mean exactly? I understand how it works in functions like seq
03:16:23 <liste> afaik it makes the compiler just put implicit `seq`s when using the constructor
03:17:11 <liste> so that SubCache x = SubCache $! x = x `seq` SubCache x
03:22:33 <hnfmr> bergmark: thanks
03:24:17 <solatis> hmm if I have an Either Foo String, what is the function I want to use if I want to convert it to Either Bar String (in other words, I want to change the type of the Left and keep the Right in tact)
03:24:53 <liste> > bimap id (const 5) (Either () "x")
03:24:55 <lambdabot>      Not in scope: data constructor â€˜Eitherâ€™
03:24:56 <lambdabot>      Perhaps you meant variable â€˜eitherâ€™ (imported from Data.Either)
03:25:06 <liste> > bimap id (const 5) (Left "x")
03:25:10 <lambdabot>  Left "x"
03:25:16 <liste> > bimap id (const 5) (Right ())
03:25:20 <lambdabot>  Right 5
03:25:59 <liste> @where bimap
03:25:59 <lambdabot> I know nothing about bimap.
03:26:41 <solatis> hmmm
03:26:44 <solatis> I was looking at http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Arrow.html#v:left
03:28:31 <jle`> solatis: that works too, but most people consider it a bit of an abuse of ArrowChoice
03:28:54 <solatis> jle`: it feels like overkill, yes
03:29:00 <jle`> Data.Bifunctor.first is preferred these days
03:29:04 <solatis> got it
03:29:06 <solatis> will do
03:29:17 <jle`> first (const 5), for instance
03:29:42 <jle`> > map (Data.Bifunctor.first (const 4)) [Left 3, Right 2, Left 1]
03:29:47 <lambdabot>  Not in scope: â€˜Data.Bifunctor.firstâ€™
03:29:53 <untseac> hey
03:29:58 <jle`> @import qualified Data.Bifunctor
03:29:58 <lambdabot> Unknown command, try @list
03:30:05 <jle`> @let import qualified Data.Bifunctor
03:30:08 <lambdabot>  Defined.
03:30:10 <jle`> > map (Data.Bifunctor.first (const 4)) [Left 3, Right 2, Left 1]
03:30:18 <lambdabot>  [Left 4,Right 2,Left 4]
03:31:11 <jle`> hi untseac 
03:31:40 <ronh-> > map (Data.Bifunctor.second (*100)) [Left 3, Right 2, Left 1]
03:31:46 <lambdabot>  [Left 3,Right 200,Left 1]
03:31:57 <untseac> I'm using arch linux and ghc is at version 7.10 but I noticed many packages don't work with that version, namely helm and elm. Is it not a good idea to have the latest version? Should I downgrade or fix the problematic packages?
03:32:18 <solatis> untseac: that is quite irresponsible of arch linux tbh
03:32:30 <liste> arch is bleeding edge
03:32:32 <jle`> ronh-: second works too but usually people just use fmap, heh
03:32:46 <solatis> yeah arch does rolling upgrades
03:32:55 <solatis> but even stackage doesn't build with ghc 7.10 yet
03:33:12 <solatis> (last time i checked that is)
03:33:29 <untseac> so I should just use 7.8.4
03:33:39 <solatis> yeah, i'm developing and still using 7.8
03:33:48 <liste> I got fed up for using Arch package manager for anything Haskell-related
03:33:56 <Haskellfant> solatis: stackage nightlys build with 7.10
03:33:58 <solatis> the compiler 7.10 is stable, but many packages dont build against it yet
03:34:19 <solatis> Haskellfant: ghc 7.10 is quite unusable under windows at the moment because of a cabal issue
03:34:39 <Haskellfant> ah k, I'm on arch using stack with 7.10
03:34:49 <solatis> yeah it's a stupid bug
03:34:56 <solatis> ghc 7.10 changed the package id's iirc
03:34:59 <untseac> Right. I could create my own PKGBUILD.
03:35:02 <Haskellfant> 7.10.2 is supposed to be out really soon, hopefully that helps
03:35:07 <solatis> packages are now stored in a different path
03:35:19 <solatis> and under windows, there's a limit on the amount of chars a path can contain
03:35:21 <Haskellfant> untseac: stack should also allow you to use 7.8.4 easily https://github.com/commercialhaskell/stack
03:35:26 <solatis> and that is where things break
03:35:46 <untseac> I'll just downgrade, for now. thanks.
03:36:05 <solatis> untseac: that's what i did :)
03:36:52 <untseac> it was becoming really annoying, thanks. now I can make crappy games, in haskell :p
03:38:56 <securestance> hello
03:39:06 <securestance> Any web developers here looking for business in a "grey hat" project?
03:40:56 <ion> You're using Haskell for evil?
03:41:03 <securestance> Evil?
03:41:27 <securestance> Can't find any other web developer channels
03:41:35 <securestance> if you would like to recommend some that would be great
03:48:06 * solatis is just exploring the bifunctors package
03:48:13 <solatis> do they really have a 'runClown' function?!
03:48:34 <solatis> and the right-wing equivalent, 'runJoker'
03:50:50 <merijn> solatis: This is probably refering to Conor McBride's "Clowns to the left, jokers to the right" paper
03:51:03 <merijn> Which in turn is a reference to a 70s pop song from the UK
03:51:22 <tdammers_> stuck in the middle with you
03:51:25 <tdammers_> gerry rafferty
03:51:28 <merijn> Right
03:51:28 <tdammers_> awesome song
03:51:38 <tdammers_> awesome movie, too
03:51:57 <merijn> All of McBride's papers are titled after political statements, puns or reference and preferably both :p
03:52:15 <merijn> I remember he was claiming to "put the largest number of Shakespeare references" in his paper titles
03:53:25 <liste> his writing style is awesome
03:54:07 <liste> abstract concepts don't need to be boringh
03:54:12 <tomqq> Could someone point me to a good walkthrough of setting up a haskell project? 
03:54:24 <aleator> Suppose I have two patterns synonyms with the same 'type'. Is there a convenient way to make a synonym which says "either of these?"
03:54:50 <tomqq> And what do people think are the best build tools etc>?
03:55:05 <merijn> aleator: Not really
03:55:34 <liste> @where learnhaskell --for tomqq
03:55:34 <lambdabot> https://github.com/bitemyapp/learnhaskell
03:55:52 <aleator> merijn: Thats too bad. I end up making messes with lambdacase but thats turning out quite ugly
03:56:21 <liste> tomqq, also the cabal portion of https://github.com/bitemyapp/learnhaskell/blob/master/specific_topics.md
03:56:40 <merijn> aleator: Couldn't you just reduce whatever you're doing to a simple function that you can reuse?
03:57:12 <liste> tomqq but basically, "cabal init"
03:57:28 <solatis> merijn: i'm aware of that, just funny to see it implemented in actual code
03:57:38 <solatis> i actually like things like this, because everybody knows that song
03:58:11 <solatis> just like when implementing a search function, accept 'needle' and 'haystack' variables, and instantly you avoid any confusion of which is which
03:59:04 <merijn> solatis: Never head of it, tbh
03:59:23 <aleator> merijn: Somewhat. The problem is that I have a large number of these. See for example: https://gist.github.com/a07214e822dfb36b60d1
03:59:31 <ion> I hadn't either until seeing that reference.
04:00:23 <solatis> i believe it's used quite a lot in code samples, and of course php
04:00:36 <merijn> solatis: No, I meant the song
04:00:43 <merijn> solatis: I know needles and haystacks :p
04:01:03 <solatis> oh, you probably don't listen to bob dylan a lot then :)
04:03:37 <merijn> Let me try again: Anyone know of a concurrent map like data structure? I need the ability to query/register keys and GC values cheaply. TVar/MVar with Map inside has too much contention :\
04:04:48 <R0b0t1> hmm
04:05:13 <R0b0t1> would it be possible to implement a functional language similar to a macro assembler?
04:05:21 <tdammers_> TVar with Map (TVar key) (TVar value) in it :P
04:05:25 <R0b0t1> perhaps not the most efficient
04:07:59 <ion> R0b0t1: I suppose you could only have referentially transparent things in the language and have first-class macros (for the functional part) and generate impure code in a similar manner to IO.
04:08:58 <magneticDuck> haven't done haskell for a while, are all these library functions now accepting Foldable data structures instead of lists somewhat new?
04:09:34 <tdammers_> somewhat, yes
04:09:45 <tdammers_> ghc 7.8, I think
04:10:07 <absence> wasn't it 7.10?
04:10:27 <absence> along with AMP
04:10:48 <dramforever> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/release-7-10-1.html
04:10:52 <ion> I thought 7.10 too. Better check the changelog.
04:11:15 <magneticDuck> cool
04:11:26 <dramforever> 1.5.1 "Burning Bridges Proposal"
04:12:12 <aleator> Another pattern question. What is the easiest way to turn a pattern into an indicator function? (\case {P1{}->True;_->False}) seems unnecessarily verbose.
04:13:49 <ion> aleator: makePrisms and the is function.
04:14:00 <bvun> what's the easiest way to get rid of "Defaulting the following constraint(s) to type..." warnings?
04:14:14 <dramforever> hmm, lens
04:14:20 <dramforever> bvun: add signatures
04:15:07 <ion> -fno-warn-defaulting or something like that. I only have that in my ghci, though, i just add signatures to code in files.
04:15:20 <dramforever> hmm, easiest
04:17:32 <ion> > is _Left (Right 42)
04:17:36 <lambdabot>      Not in scope: â€˜isâ€™
04:17:36 <lambdabot>      Perhaps you meant one of these:
04:17:36 <lambdabot>        â€˜idâ€™ (imported from Data.Function),
04:17:49 <liste> > notNullOf _Left (Right 42)
04:17:55 <lambdabot>  False
04:18:05 <liste> > notNullOf _Left (Left 42)
04:18:10 <lambdabot>  True
04:18:16 <liste> goofy name, though
04:18:28 <dramforever> any chan ops here?
04:19:04 <dramforever> I think cinc#oxd (remove the #) is spamming in PM
04:19:09 <ion> > notNullOf (base 17) "abcdefg"
04:19:13 <aleator> ion: That solved half of my problem. Rest of it is caused by wanting pattern synonyms which, I guess, can't be turned into prisms
04:19:14 <lambdabot>  True
04:19:26 <bvun> It's in a do block though, e.g.  let h'   = ceiling ((logBase (fromIntegral 2) (fromIntegral (n + 1))) - 1)
04:19:58 <ion> aleator: If they are bidirectional, you should be able to make the prisms manually.
04:20:44 <ion> If not, you could make (affine) folds out of them.
04:20:52 <aleator> ion: That is true.
04:22:17 <ion> @type logBase
04:22:20 <lambdabot> Floating a => a -> a -> a
04:22:30 <aleator> ion: I guess my problem is that I have lot of uni-directional patterns that make my life easy, except when I try to use them with Lens.Plated or biplate.
04:23:30 <ion> bvun: Replace the fromIntegral 2 with 2 and add :: Integer to either parameter or to the logBase expression.
04:24:05 <bvun> ion: okay, thanks!
04:24:33 <ion> Whoops, belay that.
04:24:52 <ion> :: Double
04:24:53 <kalloc> Hi, What kind of situations acid-state is better than RDBMs or NoSQL?
04:25:42 <liste> kalloc it's pretty fast
04:26:03 <liste> but requires all data to fit in memory
04:27:02 <edwardk> aleator: you can write bidirectional patterns from prisms these days
04:27:06 <edwardk> those will go into lens soon
04:27:22 <liste> kalloc I'd use it in real-time web apps like chat etc
04:27:28 --- mode: ChanServ set +o edwardk
04:27:37 --- kick: cincoxd was kicked by edwardk (cincoxd)
04:27:37 --- mode: edwardk set +b cincoxd!*@*
04:27:45 --- mode: edwardk set -o edwardk
04:27:54 <dramforever> edwardk: thanks
04:28:33 <dramforever> and btw, I think your answer is backwards, I think aleator has unidirectional pattern synonyms and want indicator functions
04:29:18 <edwardk> ah
04:30:29 <liste> kalloc it's better than RDBM when your data is small and better than NoSQL when you want ACID
04:32:36 <ion> How do you make patterns from prisms? Using a view pattern like (^? _Foo) -> Just a in the synonym?
04:33:27 <dramforever> > let f ((^? _Left) -> Just x) = x in Left "foo"
04:33:32 <lambdabot>  Left "foo"
04:33:39 <dramforever> well hahaha
04:33:45 <dramforever> > let f ((^? _Left) -> Just x) = x in f (Left "foo")
04:33:50 <lambdabot>  "foo"
04:33:58 <dramforever> ion: well, I guess you are right
04:34:14 <bvun> ion: do you mean something like this?   let h'   = ceiling ((logBase (2 :: Integer) (fromIntegral (n + 1))) - 1)
04:34:17 <ion> I mean, is there a nicer way?
04:34:50 <arkeet> I can't imagine a nicer way.
04:34:58 <ion> bvun: I should have highlighted you in my following messages. Integer was a mistake, i meant Double.
04:35:56 <bvun> ion: :) thanks again
04:36:06 <dramforever> ion: well, I guess no
04:37:22 <dramforever> > let match p = (^? p); f (match _Left -> Just x) = x in f (Left "foo")
04:37:33 <lambdabot>  mueval-core: Time limit exceeded
04:37:40 <dramforever> ???
04:37:51 <arkeet> we already have a name for match.
04:37:54 <arkeet> it's preview.
04:38:10 <dramforever> arkeet: except the arguments are in the wrong order
04:38:22 <ion> I don't think they are.
04:38:23 <arkeet> > preview _Left (Left "foo")
04:38:34 <lambdabot>  Just "foo"
04:38:40 <dramforever> well, I was wrong, sadly
04:38:58 <ronko> merijn: not much gain. I have no problem with C. Would not gain anything to write a projec in a DSL rather than C
04:39:06 <dramforever> > let f (preview _Left -> Just x) = x in f (Left "foo") -- hardly better
04:39:12 <lambdabot>  "foo"
04:39:31 <arkeet> I doubt you can do much better with what we have.
04:39:59 <dramforever> arkeet: makePatternFromPrism TH function?
04:40:09 <arkeet> why not just match on Left?
04:40:23 <dramforever> because we want to pattern match on prisms
04:40:36 <arkeet> the thing about prisms is that they can be composed. are you going to make a new pattern synonym every time you want to use a composite prism?
04:40:40 <aleator> edwardk: Oh. Neat.
04:40:50 <dramforever> arkeet: well, hmm
04:42:23 <edwardk> i tried to make a case for patterns that took a term as one of their arguments so you could make a (View _Pattern (1,2,3))  -- kind of pattern but it confused simon and co when i put it forth
04:42:25 * dramforever wonders why https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns#FurtherSyntacticExtensions didn't make it
04:42:55 <ion> Prisms can also be parameterized. You can't make the pattern Base 16 work from the prism base 16.
04:43:15 <arkeet> edwardk: yes, I've thought before that patterns that take expression parameters could be useful
04:43:36 <edwardk> ion: sadly. hence the issue above
04:43:49 <dramforever> can TH something like this? let f $(match _Left "x") = x
04:44:04 <dramforever> can $() generate binders?
04:44:17 <ion> full of women
04:44:35 <arkeet> you'd probably have to quote _Left or something.
04:44:51 <dramforever> yeah maybe
04:45:26 <ion> I think quasiquoters can be patterns and they can be parsed arbitrarily.
04:45:59 <dramforever> let f [match| _Left -> x |] = x in ...
04:46:17 <dramforever> need some work parsing that
04:46:18 <arkeet> the output of a quasiquoter is a value though.
04:47:06 <arkeet> I thought.
04:47:10 <arkeet> never mind.
04:48:20 <arkeet> doesn't seem worth it to me though.
04:48:54 <ion> Yeah
04:59:31 <neuroserpens> :t interact
04:59:33 <lambdabot> (String -> String) -> IO ()
04:59:45 <neuroserpens> Yea...
05:01:01 <neuroserpens> So guys... I'm having some trouble with interact because it expects a function of type String -> String, but I need this function to actually convert this list of strings to a list of ints, do some calculations and convert it back to a string. Can anyone tell me what you'd imagine is the best way to make this conversion back to a string?
05:01:16 <neuroserpens> The calculation is right. I'm trying to use unlines and then show but i keep getting errors
05:01:49 <neuroserpens> I'm thinking... Should I just map read :: Int -> String back?
05:02:17 <neuroserpens> It looks inefficient
05:03:41 <{AS}> map read should give you a function from [String] -> [Int]
05:04:09 <kuribas> :t lines
05:04:11 <lambdabot> String -> [String]
05:04:14 <Haskellfant> neuroserpens: read goes from string to int not the other way around
05:04:21 <Haskellfant> for that you want show
05:04:45 <srhb> neuroserpens: There's nothing inefficient about mapping a function over a list of something per se.
05:05:08 <srhb> It's one of our two primary "loop" constructs.
05:05:12 <kuribas> :t intersperse
05:05:15 <lambdabot> a -> [a] -> [a]
05:05:27 <kuribas> :t intercalate
05:05:30 <lambdabot> [a] -> [[a]] -> [a]
05:06:04 <kuribas> neuroserpens: interact (unlines . map show . myfun . lines)
05:06:05 <merijn> neuroserpens: You need to first split the String into [String], then map something over that, then turn it back into a [String] and then that back into a single String
05:06:11 <neuroserpens> Haskellfant: I see. I tried show though after unlines and it didn't work
05:06:15 <merijn> Or you could follow the spoilers >.>
05:06:20 <neuroserpens> kuribas: hmmm
05:06:24 <neuroserpens> kuribas: I'll try map show
05:06:25 <liste> neuroserpens can't you just `show' instead of `map show' ?
05:06:25 <kuribas> merijn: sorry...
05:06:29 <neuroserpens> kuribas: I hadn't thought of that.
05:07:35 <kuribas> neuroserpens: learning all the functions of the prelude will give you a good start for becoming a great haskell programmer :)
05:07:58 <liste> > (show . ((+1) :: Int -> Int) . read) "[1,2,3,4,5]"
05:08:06 <lambdabot>  "*Exception: Prelude.read: no parse
05:08:15 <liste> > (show . map ((+1) :: Int -> Int) . read) "[1,2,3,4,5]"
05:08:19 <lambdabot>  "[2,3,4,5,6]"
05:08:46 <kuribas> neuroserpens: of course there is no error checking here...
05:12:22 <kuribas> neuroserpens: If  you need raw speed, then I would use ByteString or Text.
05:18:10 <neuroserpens> kuribas: I could be wrong, but I'm trying to do stuff without imports first. That's what I do in every language I study.
05:18:34 <neuroserpens> kuribas: I only import stuff when I really see a mandatory need.
05:18:36 <srhb> neuroserpens: That's fine. As long as you realize that Haskell does not reach its fullest potential without them :-)
05:18:46 <srhb> For fast text handling, ByteString/Text are mandatory.
05:18:46 <neuroserpens> srhb: Yea. I know.
05:18:54 <kuribas> neuroserpens: what srhb says
05:18:56 <srhb> But obviously not for toy projects :-)
05:19:18 <neuroserpens> srhb, kuribas: I am aware of that :P
05:21:31 <srhb> Good good. :-) Sorry, I can't keep up with everyone's expectations and ideas about Haskell, I'd rather warn once (or twice, or thrice) too many than have people be disappointed later on :P
05:22:47 * hackagebot feldspar-signal 0.0.1.0 - Signal Processing extension for Feldspar  http://hackage.haskell.org/package/feldspar-signal-0.0.1.0 (mararon)
05:23:34 <aleator> What was the lens equivalent of universeBi?
05:25:47 <srhb> Something in Prism, probably?
05:29:25 <srhb> Well, maybe not. try in the lens channel :P
05:51:28 <paul01_> hey, iam having a little trouble understanding a rather simple thing. I have a higher order function (fix from Data.Function) with a signature (a -> a) -> a and I have another with a signature "(Num a, Num a1, Ord a) => t -> a -> a1"
05:51:59 <paul01_> the question si how is it possible that I can apply this second function to fix
05:52:07 <srhb> Name the type variables differently
05:52:19 <srhb> say, the foo function is (t -> b -> c)
05:52:26 <paul01_> when the signature doesn't match. I understand that somehow it matches but i fail to deduce the algorithm
05:52:31 <lyxia> paul01_: The second function can be specialized to (...) => (a -> a1) -> (a -> a1)
05:52:40 <lyxia> By unifying t and (a -> a1
05:52:41 <srhb> Now you just unify the as from fix with those
05:53:02 <srhb> Remember that a can indeed be a function
05:53:03 <pacak> fix wants a function a -> a, your second function got a different type signature
05:53:27 <merijn> pacak: No it doesn't
05:53:34 <merijn> pacak: It just means "t = a -> a1"
05:54:02 <paul01_> aha so it can automagically deduce that t is (a -> a1) ??
05:54:06 <srhb> Yes.
05:54:09 <merijn> pacak: yes
05:54:12 <merijn> eh
05:54:15 <merijn> s/pacak/paul01
05:54:29 <paul01_> because that would explain why the return value signature is (a -> a1 )
05:54:34 <pacak> merijn: If you look at it like that...
05:54:49 <srhb> There's no other way to look at it :P
05:55:12 <pacak> srhb: Sure there is. You can unsafeCoerce something to something else.
05:55:17 <paul01_> is there an explicit name for such a signature deduction?
05:55:24 <merijn> paul01_: Suppose we have the non-fix version with variables "t -> b -> c" as suggested by srhb , then we get
05:55:24 <srhb> paul01_: It's just called unification.
05:55:52 <merijn> "a = t && a = b -> c" which is solvable IFF "t = b -> c"
05:55:54 <mniip> paul01_, unification via typevariable zonking
05:55:59 <mniip> which is a part of type inference
05:55:59 <ion> pacak: When reasoning about things, bottoms and unsafeCoerce usually don't exist. :-P
05:56:40 <paul01_> merijn: I actually didn't know it makes inferences like that, that's really cool
05:56:54 <merijn> paul01_: The compiler just build a huge set of equations like that and then tries to see if there is a solution to the system of equations
05:57:05 <merijn> paul01_: If there is a solution, then it infers that, if not, you have a type error
05:57:25 <mniip> merijn, does it?
05:57:38 <srhb> For non-extended Haskell, yes.
05:57:43 <merijn> mniip: Well, something extensionally equal to that
05:57:45 <mniip> I mean, does GHC actually solve equations
05:57:48 <srhb> Yes.
05:57:50 <tdammers_> if I were to write a compiler, I'd defer type checking to a mechanical turk
05:57:57 <mniip> as opposed to comparing type trees and zonking variables
05:58:02 <srhb> tdammers_: That sounds like a really poor idea. :P
05:58:18 <srhb> mniip: I've never heard the term "zonking" before -- where is it from?
05:58:20 <merijn> mniip: What it does results in the same observable behaviour as solving those equations :)
05:58:29 <merijn> srhb: GHC source comments/wiki
05:58:32 <srhb> Oh. :)
05:58:38 <mniip> not really
05:58:46 <merijn> mniip: Oh, why not?
05:58:57 <mniip> I mean any type inference problem can be reduced to solving type equations
05:59:02 <mniip> but the backwards is not true
05:59:16 <mniip> er, you got what I mean
05:59:23 <merijn> I didn't say GHC can solve any arbitrary set of equations
05:59:34 <mniip> okay then
06:00:01 <paul01_> lyxia, srhb and merijn thanks for the explanation! ... :-)
06:00:06 <merijn> I'm just saying GHC's behaviour is extensionally equal to computing the equations and solving :)
06:00:09 <merijn> Anyway, meeting time
06:00:49 <nkar`> is there an equivalent of Either with two 'Left's?
06:00:57 <mniip> nkar`, what's the point
06:01:09 <srhb> paul01_: https://github.com/wh5a/Algorithm-W-Step-By-Step/blob/master/AlgorithmW.pdf -- this might interest you
06:01:10 <nkar`> different error types
06:01:31 <srhb> nkar` Either (Either lerror rerror) Value ?
06:01:34 <mniip> nkar`, you want 'Either (Either ...) r' then
06:01:43 <nkar`> but that's kind of verbose
06:01:56 <srhb> nkar`: any solution you make will be isomorphic to that
06:01:58 <mniip> you could write your own
06:02:01 <srhb> You can rename Either E if you like :P
06:02:02 <nkar`> of course
06:02:15 <nkar`> I was asking about predefined things
06:02:16 <mniip> and add instances for Functor, Applicative, Monad
06:02:18 <tdammers_> Either oerror (Either ierror value)
06:02:38 <nkar`> k
06:02:38 <tdammers_> Or maybe ErrorT
06:02:42 <nkar`> thanks folks
06:02:44 <ion> nkar: You can just write your own type with the appropriate names for your domain.
06:02:46 <srhb> tdammers_: Wasn't that deprecated?
06:02:54 <paul01_> srhb: that looks really interesting, thanks for the tip
06:03:10 <srhb> tdammers_: For ExceptT
06:03:12 <tdammers_> srhb: ExceptT then
06:03:15 <srhb> Yeah :)
06:03:36 <mizu_no_oto> nkar`: is this a one-off error situation, or is this combined error going to be in many places?
06:03:42 <ronko> What's the word I am looking for: The wanted frequency for the PLL. Replace anted with another word.
06:04:12 <srhb> desired?
06:04:15 <peddie> reference or desired?
06:05:46 <tdammers_> required?
06:05:47 <nkar`> mizu_no_oto: it's a function that's used by two other functions, I think I'll go with Either Text (Maybe Foo)
06:06:09 <nkar`> mizu_no_oto: it's pretty descriptive and not too verbose
06:06:31 <mizu_no_oto> Actually, why isn't there an Either3, Either4, etc. in the standard libraries?
06:06:50 <peddie> @hoogle Threether
06:06:51 <lambdabot> No results found
06:06:53 <peddie> darn
06:06:55 <nkar`> haha
06:07:02 <srhb> mizu_no_oto: Because they aren't special and you'd need to figure out new semantics for them
06:07:16 <chamo_> hi all
06:07:26 <srhb> mizu_no_oto: Whereas Either e1 (Either e2 r) have good semantics and contain all the semantics you want :)
06:07:49 * hackagebot snaplet-sass 0.1.1.0 - Sass integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-sass-0.1.1.0 (lukerandall)
06:07:59 <nkar`> mizu_no_oto: due to ambiguity, I guess.  would either3 have two lefts or two rights? 
06:08:15 <tdammers_> two lefts, obviously
06:08:44 <tdammers_> no wait, it would nest on the right, obviouly
06:08:52 <mizu_no_oto> srhb: isn't that also the case with (a,(b,c)) vs (a,b,c)?
06:09:11 <mizu_no_oto> nkar`: well, look at the monad instance
06:09:56 <mizu_no_oto> There's the one sensible instance of the rightmost constructor being the actual value and all the others being different kinds of errors
06:10:38 <tdammers_> E e1 (E e2 v) vs. E (E e1 e2) v, basically
06:11:18 <tdammers_> but I'd argue that if we assume "Right" means "not an error" and "Left" means "error" then the one that nests on the Right makes mroe sense to me
06:11:38 <tdammers_> at least if the errors are at different levels like the nested Eithers suggest
06:11:48 <srhb> tdammers_: I agree, and I'm sorry I suggested the other one first. :P
06:12:01 <tdammers_> if the errors are at the same level conceptually, I'd use a dedicated sum type to differentiate
06:12:50 <mizu_no_oto> If you have Either3, then your monad has to be Monad (Either3 e1 e2) where >>= :: Either3 e1 e2 a -> (a -> Either3 e1 e2 b) -> Either3 e1 e2 b
06:14:32 <mizu_no_oto> Which means that 
06:15:04 <mizu_no_oto> the only sensible version is that it's isomorphic to E (E e1 e2) v
06:15:17 <tdammers_> hmm, that kind of sucks
06:15:47 <tdammers_> Left (Left something) -- tells me that something went wrong while trying to produce an error value
06:18:25 <mizu_no_oto> tdammers: Well, presumably Either3 E1 E2 a == data MyError = MyE1 E1 | MyE2 E2 ; Either MyError a 
06:18:41 <mizu_no_oto> tdammers_; rather
06:19:01 <tdammers_> ah, yes
06:19:06 <tdammers_> then it does make sense
06:19:16 <mniip> but
06:19:22 <tdammers_> but then you're basically just wrapping your actual error types in a sum type
06:19:31 <mniip> there's an isomorphism between Either3 a b c, and Either (Either a b) c
06:19:40 <tdammers_> yes
06:19:44 <tdammers_> they're isomorphic
06:19:52 <mniip> and the F/A/M laws dictate that the respective instances should behave the same
06:20:01 <tdammers_> but they violate the informal semantics of "left means error, right means success"
06:20:41 <mizu_no_oto> F/A/M laws work the same on Either3 and Either (Either a b) c
06:20:43 <tdammers_> (and, by extension, Left . Left means "the error has errors")
06:21:02 <mniip> mizu_no_oto, nope actually,
06:21:21 <mniip> in the latter case they dictate the instance for Either, as opposed to the whole structure
06:21:59 <mniip> tdammers_, ultimate solution
06:22:02 <mniip> Either Dynamic a
06:22:05 <mizu_no_oto> i.e. you map the c value, or have Either (Either a b) c -> (c -> Either (Either a b) d) -> Either (Either a b) d 
06:22:32 <tdammers_> Either [String] a
06:22:37 <tdammers_> problem solved :{
06:22:53 <mniip> mizu_no_oto, once again, you make an instance for (Either a), not (Either (Either a b))
06:23:16 <mizu_no_oto> mniip: the instances must be the same, in both cases, right?
06:23:46 <mniip> how can they be the same if one is a dyadic type constructor and other is triadic
06:23:50 <mizu_no_oto> except that an instance for Either (Either a b) is unnecessarily constrained
06:24:13 <mniip> they are different, but produce same results in the given case
06:25:55 <kuribas> Are list comprehensions isomorphic to the list monad?
06:26:26 <mizu_no_oto> kuribas: what do you mean?
06:26:27 <dolio> kuribas: Yes, depending on what you mean by isomorphic.
06:26:49 <mizu_no_oto> also, depending on what you mean by 'list monad'
06:27:01 <dolio> Yeah.
06:27:01 <tdammers_> the Monad instance for []?
06:27:32 <mniip> I don't think you can change the list comprehension behavior by changing the list monad instance
06:27:46 <mniip> (you definitely can under MonadComprehensions)
06:28:07 <c_wraith> kuribas: you can't quite do everything with list comprehensions that you can with the list monad, though.
06:28:21 <kuribas> c_wraith: for example?
06:28:26 <c_wraith> > do x <- [1..] ; [x, -x]
06:28:32 <lambdabot>  [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,14...
06:28:53 <mniip> > [r | x <- [1..], r <- [x, -x]]
06:28:55 <c_wraith> You *can* do that with a comprehension, but it's more verbose
06:28:58 <lambdabot>  [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,14...
06:29:03 <c_wraith> Since you have to add in a second bind for no reason
06:29:32 <c_wraith> This is because comprehensions have an implicit return
06:29:44 <c_wraith> So sometimes you need an extra bind to undo the return
06:30:50 <dolio> You can also view comprehensions as ending with fmap.
06:31:22 <dolio> (That's how it works in Scala, for instance.)
06:31:51 <kuribas> c_wraith: I'd say the two are equivalent, it doesn't show your claim...
06:32:05 <dolio> In GHC, the Monad (and applicative) instance for lists actually uses list comprehensions.
06:32:10 <c_wraith> Yeah, I phrased it badly
06:32:17 <c_wraith> It's not that you can't do it with a comprehension
06:32:21 <c_wraith> it's just an extra step
06:33:08 <kuribas> I rarely use list comprehensions, since I prefer do syntax.
06:33:28 <c_wraith> I rarely use list comprehensions because I prefer higher-order functions in most cases.
06:33:57 <dramforever> c_wraith: I never used list comp after I heard about applicatives
06:33:58 <frerich> I like list comprehensions because the 'fail' definition is convenient with pattern matching failures.
06:34:00 <kuribas> c_wraith: So you use (>>=)?
06:34:24 <kuribas> frerich: is list comprehension fail different from monad fail?
06:34:29 <dramforever> frerich: you can do that with do-syntax too
06:34:33 <frerich> E.g. '[x | Just x <- xs]'.
06:34:46 <dramforever> > (do 1 <- 2) :: Maybe Int
06:34:51 <dramforever> wait no no
06:34:54 <lambdabot>      The last statement in a 'do' block must be an expression 1 <- 2
06:34:57 <frerich> Or, just wrote it in another channel
06:35:09 <frerich> localMaxima xs = [b | a:b:c:_ <- tails xs, a < b, b > c]
06:35:19 <kuribas> > (do Just 1 <- Just 2) :: Maybe Int
06:35:22 <dramforever> > (do True <- False; return "blah") :: Maybe String -- it works
06:35:22 <lambdabot>      The last statement in a 'do' block must be an expression
06:35:22 <lambdabot>        Just 1 <- Just 2
06:35:29 <lambdabot>      Couldn't match expected type â€˜Maybe Boolâ€™ with actual type â€˜Boolâ€™
06:35:30 <lambdabot>      In a stmt of a 'do' block: True <- False
06:35:30 <lambdabot>      In the expression:
06:35:40 <kuribas> > (do 1 <- Just 2) :: Maybe Int
06:35:44 <lambdabot>      The last statement in a 'do' block must be an expression
06:35:44 <lambdabot>        1 <- Just 2
06:35:48 <dramforever> ha
06:35:53 <dramforever> three times in a row
06:35:55 <dolio> It's not going to work the third time, either. :)
06:36:15 <kuribas> > (do 1 <- Just 2; return 20) :: Maybe Int
06:36:18 <lambdabot>  Nothing
06:36:23 <kuribas> dramforever: there you go :)
06:36:31 <dramforever> yay!
06:36:39 <dramforever> wait I don't need it
06:36:52 <dramforever> frerich: there you go
06:36:59 <dolio> Comprehensions are kind of a more natural fit for Applicative.
06:37:19 <ion> You can do monadic things with them, too.
06:37:23 <dolio> As long as you impose some additional rules.
06:37:32 <dramforever> you can do that with do-syntax too
06:37:49 <dolio> Because the structure means you don't have to detect that the last bit is 'pure ...'.
06:37:54 <dramforever> dolio: I think list comp desugars into do-syntax first, or it's optimized
06:38:10 <dramforever> idiom brackets rock!
06:38:19 <dramforever> bang syntax rocks
06:38:50 <dolio> [ e | x1 <- a1, x2 <- a2, ... ] = (\x1 x2 ... -> e) <$> a1 <*> a2 ...
06:38:53 <dramforever> enough for people from "traditional" languages envy
06:38:55 <mniip> idiom brackets are potentially ambiguous
06:38:59 <ion> join ffa = [ a | fa <- ffa, a <- fa ]
06:38:59 <dramforever> dolio: well, no
06:39:12 <mniip> dolio, what is a2 contains x1
06:39:24 <dramforever> mniip: well, maybe, so applicative style is okay
06:39:25 <dolio> As long as x1 is not used in any of the subsequent binding expressions.
06:39:31 <dolio> Etc.
06:39:55 <kuribas> dolio: neat
06:40:10 <dolio> Someone's going to implement this eventually.
06:40:29 <dolio> You can do it with do as well, of course, but it's slightly trickier.
06:40:47 <dramforever> dolio: I guess f <$> x1 <*> x2 ... directly is okay enough
06:41:07 <dolio> dramforever: There are a lot of cases where it's pretty bad.
06:41:10 <ion> Perhaps ApplicativeDo will also makes MonadComprehensions result in the appropriate constraint?
06:41:42 <dolio> Like if I want to do '[ x^z + y | x <- m, y <- n, z <- o ]'.
06:41:52 <dramforever> interestingly, idris has lot of great stuff\
06:42:09 <ion> The ! syntax in Idris is p. cool.
06:42:25 <dramforever> in fact, it has idiom brackets, bang notation, AMP built in (i.e. no return, just use pure)
06:42:36 <dramforever> but it's too experimental a language to use
06:42:48 <ion> â€œno return, just use pureâ€, also in Haskell since AMP. :-P
06:42:52 <dramforever> more experimental than haskell
06:43:10 <dolio> Idiom brackets are also nice, but they don't cover the same use cases as applicative do/comprehensions.
06:43:10 <dramforever> ion: well, in idris it's like class Applicative m => Monad m where (>>=) :: ...
06:43:31 <mniip> hold on
06:43:34 <dramforever> dolio: yep
06:43:40 <frerich> dramforever: For the record, https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11 says that list comprehensions actually desugar to concatMap.
06:43:41 <mniip> since AMP is in
06:43:53 <mniip> do we actually need the 'return' function in the Monad typeclass anymore?
06:43:59 <dramforever> frerich: okay
06:44:03 <ion> mniip: Only for backward compatibility.
06:44:17 <ion> mniip: The class has a default implementation of â€œreturn = pureâ€.
06:44:33 <dramforever> mniip: if we move it out a lot of code breaks
06:44:39 <mniip> true
06:44:52 <mniip> hm
06:44:54 <mniip> what if
06:44:58 <dramforever> mniip: that's a pretty sad problem
06:45:37 <mniip> we rename pure into return, and make pure an alias for return
06:45:46 <mniip> then only code that declares the instances is broken
06:45:49 <dramforever> language evolution problems (by dram): 1. people are conservative when adding features to a language because they might (and often do) break old code
06:46:10 <dramforever> mniip: yes, but there are a lot of code that declares instances
06:46:14 <dramforever> s/are/id
06:46:16 <dramforever> s/id/is
06:47:05 <dramforever> 2. simple language, people come to use -> people add features, features confuse newbies -> less people use the language -> language die out
06:47:18 <dramforever> s/die/dies
06:48:18 <mniip> dramforever, isn't that basically why fmap is not map
06:48:24 <kuribas> dramforever: Many ghc extensions are way to nice not to use them...
06:48:57 <dramforever> and that's why people leave haskell because "wtf no instance for (Num [Char])"
06:48:58 <dolio> map used to be fmap. Then it got changed.
06:49:00 <mniip> tfw foldr is already Foldable, but map is still not Functor
06:49:19 <dramforever> mniip: because it doesn't matter
06:49:22 <albeit> Is there a version of Chan that keeps track of its length?
06:49:39 <dramforever> mniip: because they have different names
06:49:56 <dramforever> while in the foldr case, changing the prelude doesn't change much
06:50:02 <mniip> true
06:50:05 <dramforever> kuribas: that's why ghc has extensions
06:50:48 <kuribas> dramforever: It's so often I think, why can't I... And then there is a ghc extension for it :)
06:50:56 <dramforever> I wonder if we can have a compiler/interpreter that have flags that control language features better than current ones
06:51:36 <dramforever> kuribas: also for newbies: "Why can't I... Oh I can, never mind :P"
06:52:21 <mniip> [16:48:21] <dramforever> and that's why people leave haskell because "wtf no instance for (Num [Char])"
06:52:25 <mniip> acme-stringly-typed
06:53:00 <mniip> you need to promoteFst or promoteSnd your numerical operation :P
06:53:02 <tdammers_> acme-php
06:53:19 <dramforever> mniip: I remember someone asking about something like (\a b -> (a / b + c) ++ "")
06:56:06 <kuribas> Is there a way to generate an array (or matrix) without first constructing a list (like "array" does)?
06:56:26 <kuribas> Data.Vector has a handy generate function, but it doesn't work for multidimensional arrays.
06:57:30 <srhb> kuribas: matrix?
06:57:58 <lamefun> are there unsigned integers?
06:58:09 <srhb> kuribas: https://hackage.haskell.org/package/matrix-0.3.4.3/docs/Data-Matrix.html#g:2
06:58:11 <srhb> lamefun: Word
06:58:12 <frerich> lamefun: Yes, they are called 'Word'
06:58:15 <dramforever> lamefun: Word
06:58:20 <dramforever> wow 3 in a row again
06:58:24 <frerich> Word!
06:58:28 <srhb> @quote fugue
06:58:29 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
06:58:30 <kuribas> srhb: oh right!
06:59:29 <mniip> lamefun, or if you need large numbers, there's Nature
06:59:33 <mniip> there's Natural *
07:00:17 <dramforever> mniip: The nature is a large number :P
07:00:22 <srhb> > natural (-1)
07:00:28 <lambdabot>  mueval-core: Time limit exceeded
07:00:28 <lambdabot>  mueval: ExitSuccess
07:00:30 <srhb> > natural (-1)
07:00:45 <lambdabot>  Not in scope: â€˜naturalâ€™
07:00:46 <srhb> I think lambdabot has a fever.
07:00:49 <srhb> Ah, there we go.
07:02:05 <mniip> hmm
07:02:07 <kuribas> srhb: no mutable matrices?
07:02:22 <mniip> there was some package that implemented Data.Natural.Natural akin to Integer implementation
07:02:28 <srhb> kuribas: hmatrix has that I think?
07:02:41 <mniip> by containing either unboxed int, or unboxed gmp limb
07:03:11 <kuribas> srhb: That would be overkill, I just need a Matrix datatype, preferably pure haskell.
07:03:25 <srhb> Pure? Mutable? I'm confused :P
07:06:02 <mniip> I wonder if there's any Traversable matrix
07:06:12 <mniip> or Vector for that matter
07:06:20 <mniip> so that Vector (IO a) can be turned into IO (Vector a)
07:06:33 <mizu_no_oto> I understand the simple list comprehension desugaring examples people put up.  But what do predicates desugar to?  like [x | x <- [1..10], x > 5] or [(a,b,c) | a <- [1..100], b <- [1..100], c <- [1..100], a*a + b*b = c*c]
07:06:44 <kuribas> srhb: With pure haskell I mean no C extension.
07:07:00 <srhb> kuribas: I didn't realize hmatrix needed that for simple construction and such.
07:07:16 <mniip> mizu_no_oto, guard
07:07:19 <dramforever> > Vector.fromList [1,2,3,4,5] -- try
07:07:24 <lambdabot>  mueval-core: Time limit exceeded
07:07:37 <dramforever> what's going on with lambdabot?
07:07:45 <mniip> looks like someone is abusing it
07:08:17 <ion> mniip: Natural is in base.
07:08:29 <mniip> > do a <- [1..10]; b <- [1..10]; c <- [1..10]; guard $ a*a + b*b = c*c; return (a, b, c) -- mizu_no_oto
07:08:35 <lambdabot>  <hint>:1:64: parse error on input â€˜=â€™
07:08:36 <mniip> err
07:08:39 <mniip> > do a <- [1..10]; b <- [1..10]; c <- [1..10]; guard $ a*a + b*b == c*c; return (a, b, c) -- mizu_no_oto
07:08:44 <lambdabot>  [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
07:09:02 <kuribas> srhb: hmatrix depends on gsl and lapack
07:09:15 <srhb> Right.
07:09:28 <dolio> mizu_no_oto: [ e | b, Q ] = if b then [ e | Q ] else []
07:10:17 <mniip> dolio, which is the same as guard approach
07:10:29 <mizu_no_oto> https://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#g:6
07:10:33 <mizu_no_oto> makes sense
07:11:27 <ion> guard False = []; guard True = [()]; guard FileNotFound = ???
07:12:01 <mniip> = fail "File not found"
07:12:02 <mniip> :^)
07:12:30 <geekosaur> seems apropos
07:25:46 <newsham> ij: yes
07:30:08 <ij> newsham, Oh, I was struggling to make it run yesterday, but looks like I was looking at the wrong version in the docs. Should I also be looking at Network.NineP?
07:32:04 <minozake> One of these days I will understand how monads work.  Until then, they are just a thing that follows the laws of monads and I'm happy to program by modifying examples.  Unfortunately, this leads to code that works, yet I don't understand it.
07:32:35 <mniip> obligatory burritos comment
07:32:51 <geekosaur> minozake, oddly enough, that's pretty much how monads work
07:33:02 <mniip> yeah
07:33:10 <mniip> you just have to gain intuition of what those laws mean
07:33:18 <geekosaur> oh, hm, I initially read your statement as suggesting you understood said laws of monads
07:33:23 <geekosaur> which is the point, really
07:33:44 <merijn> minozake: You don't understand the code, or you don't understand the "monad part"
07:34:01 <merijn> minozake: Because I think the biggest problem people tend to have that there just isn't much too understand about monads...
07:34:09 <geekosaur> there's not actually any special concept hiding back there, if you have something that obeys the laws then it is a monad and it works
07:34:12 <merijn> minozake: The laws + behaviour of >>= is pretty much all there is
07:34:22 <minozake> I understand the monad laws, i.e. how they behave, but I don't understand how they magic my program into working.
07:34:33 <mniip> merijn, behavior as in type signature you mean?
07:34:47 <mniip> minozake, oh, that is about instances then
07:34:56 <merijn> mniip: No, as in what it does, there's multiple possible monad instance for some types
07:35:05 <minozake> So I might just be talking about the IO monads specifically.
07:35:17 <minozake> I don't know.  Maybe I actually understand monads but I don't know it.
07:35:18 <mniip> there's only one IO monad
07:35:22 <merijn> minozake: Ah, but IO is a different beast from monads in general
07:35:29 <geekosaur> IO is not weird because it's a monad
07:35:32 <geekosaur> IO is weird because it's IO
07:35:43 <merijn> And now I'm sad that I didn't keep the link to me explaining IO in here last time
07:35:43 <geekosaur> if anything, the monad interface tames the weird to some extent
07:35:55 <minozake> Oh.  Well, then.
07:36:03 <merijn> minozake: This was a decent explanation http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
07:36:18 <merijn> minozake: The thing most people don't realise is that you could have IO without monads and monads without IO
07:36:26 <merijn> It just happens that IO fits the monad abstraction nicely
07:36:40 <merijn> Well..."most people" = "most confused beginners" :p
07:36:46 <minozake> I'm resisting the urge to use unsafePerformIO for everything that doesn't change my filesystem for the program I'm building just so I can get it :P
07:37:01 <minozake> Because I don't like unsafe things.
07:37:15 <merijn> minozake: Your code would break REALLY quickly if you did that
07:37:24 <mniip> merijn, IO without monads..., GHC.IO.bindIO, or just plain messing with State# RealWorld?
07:37:26 <merijn> @quote not.a.bug
07:37:26 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
07:37:31 <merijn> mniip: Either
07:38:17 <mniip> minozake, oh well then sounds like you have a problem with IO, not monads
07:38:29 <minozake> I'm only doing things like using `ls', so I don't *think* I can break anything.  Of course, since I don't know means I shouldn't use it.
07:38:49 <srhb> minozake: Sure, you could use ls twice with unsafeperformIO and even though a directory was changed, you would never know.
07:39:05 <mniip> minozake, the general idea is to separate pure code from impure
07:39:13 <merijn> *bzzzt*
07:39:17 <srhb> (trick being, you're not using it twice...)
07:39:17 <merijn> IO is pure
07:39:22 <mniip> pure code from IO code D:
07:39:35 * merijn transforms into pedant mode :p
07:39:43 <mniip> non-IO code from IO code
07:40:03 <minozake> srhb: Interesting.  I'm guessing that's why you stamp the function with noinline if you're really going for it.
07:40:17 <frerich> merijn: nnnnoooooooooo..... *falling to my knees and facing the sky*
07:40:38 <srhb> minozake: It's the kind of thing that would just not be done.
07:41:06 <mniip> minozake, maybe provide a minimal example of what you're dealing with?
07:41:28 <minozake> mniip: Not sure what I would be providing.
07:41:45 <minozake> Looks like I should focus on understanding IO in Haskell instead of monads like I have been doing.
07:41:45 <mniip> well you mentioned something about unsafePerformIO ls
07:42:14 <srhb> minozake: Understanding specific monads is almost always more useful than understanding monads.
07:42:16 <minozake> mniip: Oh, well I'm not actually using unsafePerformIO.  I'm just shoving everything into functions that use the IO monad.
07:42:53 * hackagebot linear-grammar 0.0.0.6 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.0.6 (athanclark)
07:43:33 <mniip> merijn, also
07:43:49 <mniip> whether IO is pure depends on what part of IO we are talking about
07:44:03 <mniip> the outside "API", or the implementation details
07:44:27 <merijn> The implementation details are still pure, via the ST trick
07:44:39 <merijn> Well, I guess it depends on your point of view
07:44:43 <mniip> eh
07:44:50 <mniip> "via the ST trick"?
07:45:11 <mniip> are we talking about the same implementation of IO?
07:45:18 <merijn> mniip: Using Rank2 polymorphism to avoid state token from escaping/prevent creation of a state token
07:45:34 <srhb> ST RealWorld?
07:45:36 <mniip> that's the implementation of ST
07:45:38 <merijn> mniip: In GHC internals ST and IO are implemented using the same primitive
07:45:48 <mniip> in GHC ST is implemented in terms of IO
07:46:01 <c_wraith> mniip: no, the rank-2 trick is the interface which makes it pure, not the implementation.
07:46:02 <merijn> mniip: No, they are both implemented using a more primitive monad
07:47:14 <mniip> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
07:47:17 <mniip> also https://hackage.haskell.org/package/base-4.2.0.1/docs/src/GHC-Base.html#bindIO
07:47:38 <merijn> mniip: Right, so that's IO implemented using the primitive of ST, not vice versa like you said
07:48:02 <merijn> The only difference is that ST uses a polymorphic state token whereas IO uses RealWorld
07:48:22 <merijn> And you can't create RealWorld, so you can't fake a token
07:48:35 <mniip> hm?
07:48:41 <mniip> ST doesn't use bindIO in its monad instance
07:49:02 <merijn> mniip: It doesn't, but no one said it did...
07:49:14 <merijn> Actually, *you* implied it did by saying ST was implemented in terms of IO
07:49:42 <mniip> okay I take my words back
07:49:56 <mniip> let's clear this up
07:50:07 <mniip> internal representation of ST is a supertype of IO's internal representation
07:50:17 <mniip> neither of them is implemented in terms of each other though
07:50:49 <merijn> IO and ST are both specialisations of the more primitve "State# s -> (# State# s, a #)" monad
07:51:09 <merijn> Which is why you can convert ST to IO (but not vice versa)
07:51:12 <mniip> technically
07:51:17 <mniip> but not implementation-wise
07:51:37 <merijn> Eh...then how do you explain stToIO? :)
07:51:42 <fizbin> So, transformers vs. mtl . Is there some consensus on the "one true path", or a set of partisan writeups from both sides?
07:51:51 <ion> Nice. https://www.fpcomplete.com/blog/2015/06/announcing-first-public-beta-stack
07:51:57 <minozake> Is there a specific name for ()?
07:52:03 <merijn> fizbin: There are no sides
07:52:04 <mniip> merijn, they're not specialization in a haskell sense
07:52:04 <merijn> minozake: unit
07:52:10 <frerich> minozake: I think some people call it 'Unit'
07:52:14 <merijn> fizbin: mtl is a wrapper around transformers
07:52:22 <mniip> if they were, stToIO would be a specialization of id
07:52:40 <merijn> fizbin: The types it exports are just reexports of transformers
07:52:51 <fizbin> merijn: Ah. I had almost suspected that parts of it were, but wasn't sure. 
07:52:54 <minozake> merijn, frerich: Thanks.
07:53:35 <ion> minozake: It could also be called one. It's the canonical type of size 1. But unit is more common.
07:54:01 <fizbin> So, all of mtl is just a wrapper on transformers (and transformers-compat). Are there decent writeups of why one might prefer the wrapper?
07:54:16 <Iceland_jack> lam
07:54:24 <merijn> fizbin: mtl lets you use MonadReader/MonadWriter to write "stack agnostic" operations
07:54:27 <c_wraith> fizbin: it's not even wrappers.
07:54:32 <merijn> fizbin: Plus it provides some "auto-lifting"
07:54:37 <c_wraith> fizbin: it's just re-exports, along with providing some extra classes
07:55:14 <merijn> fizbin: transformers-compat exists because transformers is a dependency of GHC so you cannot upgrade it for use in programs that use the GHC-API
07:55:19 <mniip> merijn, which is why I wouldn't say IO is implemented in terms of ST
07:55:38 <merijn> fizbin: the -compat package provides functionality of newer transformers versions for people using older GHC's
07:56:09 <fizbin> merijn: Right. I need to use the -compat package, since my stuff has to build on ubuntu 12.04 LTS.
07:57:16 <fizbin> I was just going through the dependencies listed here in my cabal file and trying to pare them down to a minimum.
07:57:27 <merijn> I thought there was a tool for that
07:57:39 <merijn> I recall someone writing a bounds/dependency fuzzer
07:57:50 <fizbin> And discovered that I'd picked up an mtl dependency for only three lines of code, so tweaked it to remove that.
07:58:33 <merijn> fizbin: mtl is such a commonly used package you might as well keep it
07:58:50 <minozake> Wait a minute.  main :: IO ().  This means, no matter what my program does, it is just an IO action at the topmost level.  Why does this seem deceptively simple?
07:59:11 <merijn> minozake: That's right, although you can have types other than () in the result
07:59:42 <minozake> merijn: So I can have main :: IO Int, for example, to indicate a return value for my program?
07:59:44 <merijn> minozake: But yes, you're entire program is a pure haskell program building a single main "IO action" which then gets run by the runtime system
08:00:05 <merijn> minozake: Well, you don't actually get to return anything from main, at least there's no way to do anything with it
08:00:25 <merijn> minozake: But the report states that main must have the type "IO a" where 'a' can be any type of your choice
08:00:42 <merijn> So "main :: IO Int" is a valid type for main, but you won't be able to do anything with the Int it returns :p
08:00:42 <frerich> I bet there's an easteregg in there such that if you have 'data Simon = Simon' and 'main :: IO Simon' or so then it'll do something funny at runtime
08:00:59 <frerich> If I were to work on GHC, I wouldn't want to waste the opportunity.
08:01:11 <merijn> frerich: Surely you mean "data Simon = PeytonJones | Marlow"? :p
08:01:25 <frerich> merijn: Right, something like that.
08:01:47 <frerich> The runtime could print a message like 'Removing bugs from program... done!'
08:01:56 <frerich> Or 'Reformatting console output to MS Comic Sans'
08:02:16 <hvr> frerich: I'm afraid this would violate the Haskell Report :)
08:02:27 <frerich> The report is a party pooper!
08:02:31 <merijn> frerich: You're aware of the hilarious bug GHC had where it deleted your source file when it had a type error?
08:03:56 <srhb> Thankfully a dev version :P
08:04:11 <ChristianS> now only available via option --really-strict-typechecking
08:04:53 <minozake> merijn: Ah, gotcha.  exitWith does the thing I was thinking main :: IO Int would have done.  Haskell is interesting :P
08:05:05 <gustavn> :t map
08:05:08 <lambdabot> (a -> b) -> [a] -> [b]
08:05:37 <gustavn> :t fmap
08:05:38 <geekosaur> oddly enough, that actually parallels C
08:05:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:05:56 <srhb> ChristianS: ghc --do-or-do-not
08:06:08 <geekosaur> *usually* (but this is not guaranteed, "standards" notwithstanding) if you return a value from main() then it will be the exit status
08:06:18 <geekosaur> but exit() always exits immediately with that status
08:06:29 <geekosaur> s/that status/the status you specify/
08:06:56 <geekosaur> Haskell skips the "if you're lucky then the return value from main is your exit status" part
08:07:57 <srhb> I may have missed something in this discussion, but surely you can do something with the Int from main :: IO Int
08:08:01 <srhb> Like, you could recurse on main.
08:08:43 <minozake> Well, that's my next question.  Is there a reason for main :: IO a for any a that isn't ()?
08:08:59 <geekosaur> basically a convenience hack
08:09:07 <minozake> For convenience?
08:09:11 <geekosaur> so your main could in theory be something that isn't "main"-y
08:09:12 <minozake> Oh.  ninja'd
08:09:47 <geekosaur> for example it might produce a list, and you use that elsewhere, but rather than having an almost identical wrapper for it to "prime the pump" you just reuse it as your main
08:10:02 <geekosaur> it's not necessarily a *good* reason, but it's there
08:10:13 <srhb> I think I've used it to restart a program which was basically a repl
08:10:39 * srhb doesn't really remember.
08:11:27 <geekosaur> (and there has been discussion in the past about making it be IO (), but generally nobody cares enough to push for either one)
08:11:43 <srhb> Indeed. It's hard to mobilize a hard opinion on that :P
08:12:01 <minozake> But convention is that usually main :: IO ().
08:12:11 <minozake> But it's :: IO a.
08:14:17 <RyanGlScott> What is the best way to derive Typeable instances for promoted data constructors on GHC 7.8?
08:14:36 <RyanGlScott> Unfortunately, -XAutoDeriveTypeable doesn't seem to work as intended (https://ghc.haskell.org/trac/ghc/ticket/9575).
08:14:56 <forgottenone> is it possible to use numbers as user defined data constructor
08:14:57 <RyanGlScott> Is there a better way other than manually adding a "deriving instance Typeable '(...)" for each individual constructor?
08:15:29 <geekosaur> I think it's illegal to do anything but deriving (Typeable) in 7.8
08:15:48 <geekosaur> (and in 7.10 even that is "illegal" although I think you get off with a warning)
08:15:55 <RyanGlScott> geekosaur: Standalone deriving of Typeable instances does work.
08:16:12 <geekosaur> I meant the deriving mechanism, not the syntax
08:16:24 <geekosaur> what's illegal is instance Typeable ... where ...
08:16:30 <RyanGlScott> Sure, I'm okay with that.
08:16:33 <geekosaur> you are not allowed to hand-craft Typeable instances 
08:17:02 <RyanGlScott> What I don't like is if I had a data type with a bajillion constructors, then in order to have Typeable instances for each promoted constructor...
08:17:14 <RyanGlScott> ...then I'd need one standalone deriving instance Typeable statement per constructor.
08:17:21 <RyanGlScott> e.g., data Alphabet = A | B | ... | Z
08:17:26 <RyanGlScott> deriving instance Typeable 'A
08:17:33 <geekosaur> afaik there's not currently a good way around that (maybe you can do it via TH)
08:17:36 <RyanGlScott> deriving instance Typeable 'B
08:17:37 <RyanGlScott> And so on
08:18:02 <RyanGlScott> Hm. I was afraid of that...
08:18:35 <geekosaur> hm, wait
08:18:37 <RyanGlScott> What's frustrating is that this issue seems to have been recognized (https://ghc.haskell.org/trac/ghc/ticket/8950#comment:3), but AFAICT, it was never merged into 7.8.4.
08:18:42 <geekosaur> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/deriving.html#auto-derive-typeable
08:19:05 <RyanGlScott> -XAutoDeriveTypeable doesn't seem to work (https://ghc.haskell.org/trac/ghc/ticket/9575)
08:19:28 <geekosaur> yeh, got that from your link
08:19:29 <geekosaur> :/
08:19:50 * prsteele checks if I'm still connected
08:19:57 <geekosaur> you seem to be
08:20:02 <prsteele> hello everyone
08:20:09 <maerwald> prsteele: happy day
08:25:03 <user4> Hi! how do I compile .hs file in komodo?
08:25:03 <monochrom> you can simply do a "/whois prsteele" to see if you're connected.
08:25:35 <user4> using run command.
08:26:23 <srhb> user4: Komodo is an editor? Presumably you'll have to plug in the relevant command, ie. ghc
08:27:34 <mniip> omg
08:27:47 <prsteele> monochrom: thanks!
08:27:52 <mniip> Show typeclass abuse in Data.Typeable.Internal!
08:28:56 <user4> i tried "ghci; :l %f" but it doesn't work
08:29:23 <srhb> user4: Are you sure that it runs those sequentially to some stdin? I doubt it.
08:29:32 <srhb> user4: more likely you want ghci %f
08:29:49 <srhb> user4: Mind, ghci is not a compiler.
08:31:29 <user4> when I run c programs it works sequentially.
08:31:47 <dramforever> sæ²¡å›å¤å°±ç®—äº†
08:32:05 <dramforever> ouch wrong window
08:32:14 <srhb> user4: How do you run C programs?
08:33:13 <user4> i forgot the exact command, but it worked
08:33:41 <user4> let me try
08:36:49 <mniip> does existential quantification allow for heterogeneous lists?
08:37:14 <f|`-`|f> (all I know is that HLists are based on a Kind Signature)
08:37:33 <srhb> mniip: Yes, it does.
08:37:44 <srhb> mniip: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
08:37:51 <mniip> so like
08:37:55 <mniip> [forall a. T a => a]
08:38:58 <dramforever> @let data D = forall a. Typeable a => D a
08:39:00 <lambdabot>  Defined.
08:39:06 <user4> I run c programs like this: "gcc %F -o %f; ./%f"
08:39:12 <geekosaur> yes
08:39:29 <geekosaur> that is because both of those are shell commands; the C compiler is not prompting for the program to run
08:39:32 <srhb> user4: You asked about compiling
08:39:36 <dramforever> :t [D "hello", D (), D ["hello", "world"]]
08:39:38 <geekosaur> :l is a ghci command, not a shell command
08:39:40 <lambdabot> [D]
08:39:44 <dramforever> good
08:39:51 <srhb> user4: Same applies to Haskell programs. So ghc %f; ./%f
08:39:58 <geekosaur> if you really want to do compilation like that, just call ghc (not ghci) like you did with gcc
08:40:02 <srhb> user4: Or with the -o flags as well
08:40:18 <mniip> :t [typeOf d | D d <- [D "hello", D (), D ["hello", "world"]]]
08:40:20 <mniip> er
08:40:20 <geekosaur> if you want to do it without compiling (interpreted mode, similar to ghci), then you want runhaskell %f
08:40:23 <mniip> should've been >
08:40:25 <lambdabot> [TypeRep]
08:40:33 <geekosaur> er, runghaskell %F
08:40:35 <geekosaur> ...
08:40:42 <geekosaur> runhaskell %F
08:41:08 <dramforever> > [typeOf d | D d <- [D "hello", D (), D ["hello", "world"]]]
08:41:16 <lambdabot>  mueval-core: Time limit exceeded
08:41:35 <dramforever> ??? happened again
08:41:46 <ion> She has been having problems.
08:42:04 <ion> int-e:
08:42:56 * hackagebot linear-grammar 0.0.0.7 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.0.7 (athanclark)
08:44:56 <haskell907> i am using mac os x (yosemite).  what is the key combination for possible text completions in GHCi?
08:45:10 <dramforever> tab?
08:45:59 <haskell907> i am using the os x terminal
08:46:22 <Welkin> it is tab
08:46:42 <Welkin> it should be the same regardless of which terminal emulator you use
08:47:28 <schoppenhauer> Hello. Hm, regarding my question from yesterday: will haskell automatically coerce strict IntMaps to Bool (or other small unboxed types) to a more efficient representation, or really introduce a node for every boolean value I add to it?
08:47:51 <monochrom> will not
08:47:54 <dramforever> schoppenhauer: introduce nodes
08:48:04 <dramforever> well, that's a bit confusing
08:48:04 <mniip> hmm
08:48:05 <schoppenhauer> m(
08:48:12 <dramforever> schoppenhauer: will not optimize
08:48:15 <mniip> I'm doing something wrong here
08:48:24 <haskell907> well, GNU READline library says M-? where M is the meta-key.  Default met-key in Mac is escape, but that doesn't seem to work
08:48:30 <schoppenhauer> dramforever: is there any structure that *will* optimize?
08:48:41 <monochrom> ghci does not use GNU READline.
08:49:39 <geekosaur> schoppenhauer, there appear to be some packages on hackage (look in the "bit vectors" section)
08:49:52 <haskell907> do you know the key combination i can use in mac os x terminal?
08:50:02 <srhb> haskell907: Yes, tab. 
08:50:08 <schoppenhauer> geekosaur: bitvectors can *only* store bits ...
08:50:10 <geekosaur> notably "bitvec library: Unboxed vectors of bits / dense IntSets"
08:50:13 <srhb> haskell907: If that does not work your terminal is intercepting it and doing weird things.
08:50:20 <srhb> haskell907: In which case you need to fix your terminal.
08:50:36 <Welkin> I recommend iTerm2
08:50:51 <saulzar_> I think unboxed vector of Bool will use a bit set, no?
08:51:13 <geekosaur> ghci works fine in OS X Terminal unless Yosemite broke even more than I thought (and I thought I had tested that, although mostly I avoid yosemite)
08:51:24 <schoppenhauer> saulzar_: what?
08:51:31 <dramforever> schoppenhauer: ghc can't possibly understand what an IntMap is, and the author didn't tell ghc
08:51:37 <haskell907> ok, thanks
08:51:44 <dramforever> so you need something more specific
08:51:49 <haskell907> yeah, tab works
08:51:55 <schoppenhauer> dramforever: is there an alternative? It appears that it even doesn't optimize *lists*
08:51:56 <haskell907> thanks
08:52:12 <dramforever> schoppenhauer: how?
08:52:17 <dramforever> how should it optimize
08:52:21 <user4> "ghci %F" worked thanks
08:52:35 <monochrom> another data point for: the third person to answer you is the clearest
08:53:00 <srhb> user4: That's not what you asked for. You asked for the command to compile a program, you gave a command to compile and run a program, and now you've settled on a command to launch a REPL.
08:53:15 <srhb> :P
08:53:20 <srhb> But glad you're happy!
08:53:38 <schoppenhauer> dramforever: save a list of Word32 and only operate on the first of them
08:53:43 <monochrom> "ghci %F" does not run %F
08:53:57 <schoppenhauer> dramforever: fill them up with bithsifting, cons them if they are full
08:54:08 <schoppenhauer> dramforever: pretty obvious. actually.
08:54:35 <Iceland_jack> Someone should tell the GHC devs
08:55:12 <dramforever> sorry but didn't really understand that
08:55:54 <geekosaur> it's nopt up to "ghc" or "ghc devs", but the IntMap implementation. take it up with them
08:56:00 <geekosaur> ("containers" package)
08:56:19 <schoppenhauer> geekosaur: does ghc have something like that?
08:56:25 <dramforever> schoppenhauer: I didn't get it, what does that mean?
08:56:37 <geekosaur> I like how you parsed "not up to ghc" as "entirely up to ghc"
08:57:04 <monochrom> to be fair, you misspelt "not" to "nopt" :)
08:57:18 <geekosaur> or perhaps you simply decided that the containers package is built into ghc
08:57:21 <schoppenhauer> geekosaur: It *is* entirely up to GHC, because that would be an intrinsic: you would have to know whether your underlying data is a pointer or unboxed
08:57:26 <monochrom> although, I parsed "nopt" to "not an option"
08:57:33 <geekosaur> (distributed with, yes, but not part of and they're trying to come up with ways to decouple it)
08:58:00 <haskell907> <srhb>: one more question.  GHCi implements GNU deadline.  is there some place where I can get all the key combinations for GNU readline commands used in GHCi? 
08:58:01 <monochrom> overall, it is a stupid debate what a compiler should optimize.
08:58:22 <srhb> haskell907: What? No it doesn't. I think it may use Haskeline
08:58:28 <geekosaur> haskell907, it does not use or "implement" readline, it uses a similar but much simpler mechanism
08:58:36 <srhb> Or maybe it's just built in.
08:58:43 <geekosaur> http://hackage.haskell.org/package/haskeline
08:58:45 <schoppenhauer> monochrom: I do not want to debate that. I need something, and I am looking for a way to implement it.
08:59:03 <monochrom> haskell907, I am the 1st and also 3rd person to tell you again: ghci has nothing to do with gnu readline
08:59:04 <geekosaur> (the testbed for it is even still on hackage although well out of date)
08:59:16 <schoppenhauer> I thought that at least Lists would optimize for small types.
08:59:29 <geekosaur> not generally, no
09:00:10 <geekosaur> at least in part because you complicate garbage collection and complicate or even lose fusion
09:00:26 <haskell907> shrb, geekosaur:  GHCi actually uses GNU  readline internally 
09:00:40 <geekosaur> no
09:00:52 <geekosaur> maybe you are looking at documnentation for an ancient version
09:01:00 <geekosaur> but ghci has not used readline in years
09:01:04 <haskell907> ok, may be i am wrong
09:01:12 <geekosaur> specifically because it caused problems on OS X
09:01:14 <srhb> Not maybe, you are. :P
09:01:38 <geekosaur> (because Apple ships a "readline" that is not GNU readline and causes link errors for things that try to use it expecting GNU readline)
09:01:44 <monochrom> wrong assumptions are the main cause of having trouble bridging reality with assumptions
09:01:53 <haskell907> alright.  thanks for correcting me
09:02:11 <chpatrick> is there a type synonym for a partially applied Fold from lens?
09:02:51 <chpatrick> ie forall f. (a -> f a) -> f s
09:03:31 <haskell907> srhb -- you mentioned Haskeline?
09:03:49 <srhb> haskell907: Yes, that's what ghci uses.
09:04:25 <nullx002> hi all... i am unable to find factmsieve.py
09:04:36 <monochrom> I am unable, too.
09:04:43 <srhb> nullx002: What does that have to do with Haskell? :)
09:04:59 <mniip> why can't I just say 'deriving (forall (f :: k). k)' :(
09:05:00 <nullx002> link given to me on this channel http://gilchrist.ca/jeff/factoring/nfs_beginners_guide.html
09:05:11 <haskell907> i should perhaps be careful reading real world haskell.  things are a bit outdated there.
09:05:13 <mniip> er
09:05:13 <ion> @google "factmsieve.py"
09:05:14 <mniip> I mean f
09:05:14 <lambdabot> https://github.com/GDSSecurity/cloud-and-control/blob/master/scripts/gengnfsjob-testharness/factmsieve.74.py
09:05:44 <srhb> haskell907: Yes, you should probably follow the learnhaskell guide instead.
09:05:46 <nullx002> is github version with the patch?
09:06:13 <nullx002> i infact5 found a patch here http://www.calculate-linux.org/packages/sci-mathematics/factmsieve/files/factmsieve-76.patch
09:06:48 <srhb> nullx002: How is this related to Haskell?
09:07:13 <monochrom> I'm just waiting for the monologue to end by itself
09:07:30 <srhb> monochrom: Probably because you're... MONOchrom
09:07:32 * srhb shows herself out
09:07:38 <monochrom> :)
09:07:46 <monochrom> I like puns. give me more.
09:07:53 <ion> polylogue?
09:07:55 <Iceland_jack> mono..rail
09:08:14 <minozake> <Insert type punning here>
09:10:57 <geekosaur> srhb, this person is confused. popped up several days ago and apparently still thinsk this channel is just fine for nfs support
09:11:00 <geekosaur> :/
09:11:08 <srhb> How confusing.
09:11:24 <nullx002> :D
09:12:46 <haskell907> srhb -- you mean "learn you a haskell" or is it some other book or guide?
09:12:56 <srhb> haskell907: https://github.com/bitemyapp/learnhaskell
09:13:04 <srhb> haskell907: Particularly the cis194 course.
09:13:40 <magneticDuck> undefined :: Pun -- TODO
09:14:03 <ion> magneticDuck: We have typed holes now.
09:14:10 <magneticDuck> right, how do those work?
09:14:16 <ion> _ :: Pun
09:14:35 <magneticDuck> and then you can interface with that from ghci?
09:14:47 <dmj`> bitemyapp: ping
09:14:52 <ion> I have :set -fdefer-typed-holes in my .ghci
09:15:20 <srhb> Obviously it needs to be something like getPun (Pun {p}) = p
09:15:27 <haskell907> srhb -- thanks.  i am currently going through the u-penn course
09:15:32 <srhb> haskell907: Ok :)
09:16:55 <ion> Aww, stack puts things into ~/.stack
09:17:06 <srhb> ion: Careful.... :P
09:17:12 <haskell907> srhb -- thanks for your help.  i learned about something new today -- Haskelin! thank you for pointing it out to me
09:17:23 <srhb> haskell907: No problem. :)
09:20:43 <bitemyapp> dmj`: pong
09:20:49 <augur_> suppose i have   class Foo a where f :: a -> B   and i realize that any given instance of Foo will define f as   f = g.h   where h :: a -> B  and g :: B -> B
09:21:09 <augur_> where B is independent of `a`. is there a name for the refactoring pattern of turning that definition of Foo into
09:21:11 <dmj`> bitemyapp: when you get a minute, can you merge my aeson bump on bloodhound and push
09:21:32 <augur_> class Foo a where h :: a -> B   and then defining   f :: Foo a => a -> B ; f = g.h
09:21:41 <bitemyapp> dmj`: sure
09:21:51 <bitemyapp> dmj`: at work, do it tonight.
09:21:58 <dmj`> bitemyapp: k, thanks
09:23:45 <ion> augur: Dunno, something like switching the primitive method?
09:24:03 <augur_> ion: hmm
09:25:32 <ion> Or something something primitive something, one could call (<*>) the primitive operation for Applicative even though liftA2 and liftA2 (,) would be equivalent, or (>>=) for Monad even though join could be it.
09:26:12 <ion> (+pure)
09:28:02 <eds> Hi I have a data that has Arith operators and Comp operators. I need to choose non terminals just the way it is done here : http://lpaste.net/134346 in this file: http://lpaste.net/134347
09:28:11 <eds> Any idea on how can I do that?
09:33:21 <hodapp> hummm, am I right in seeing coroutines as sort of a form of continuations?
09:33:57 <monochrom> eds, can you tell me how to choose a Char?
09:34:19 <geekosaur> you can say that coroutines are a sort of constrained continuation mechanism, yes
09:35:16 <hodapp> I'm looking at Ivory's coroutines and they look to me like they're implemented with some kind of continuation
09:35:27 <lenex> i'm new to using hackage and a little confused - why does http://hackage.haskell.org/package/unix-2.7.0.1 say that, in the dependencies, time < 1.6, but when I download the tar.gz source file, the cabal file says time < 1.5?
09:35:57 <hodapp> and I don't see a way they can be directly composed/nested (like shown in some of the callCC examples) but it looks to me like I would be implementing something similar
09:36:43 <eds> monochrom - that is where I am stuck.
09:37:02 <lenex> is that due to a person making a typo?
09:37:04 <hodapp> An Ivory coroutine doesn't return a value. Its 'yield' counterpart, rather than yielding a value (like in Python) instead receives a value.
09:37:06 <eds> How would I choose a char and then a particular operator related to it
09:37:19 <monochrom> how about we just getRandomR ('a', 'z')?
09:37:26 <ion> lenex: http://hackage.haskell.org/package/unix-2.7.0.1/revisions/
09:37:26 <hodapp> (it receives a value - and it also specifies a point at which execution resumes)
09:37:27 <hexagoxel> lenex: because you downloaded unix-2.7.0.0 maybe?
09:37:55 <GLM> Would it be more useful to go to strange loop or ICFP?
09:37:59 <lenex> hexagoxel: no, I don't think so - look http://hackage.haskell.org/package/unix-2.7.0.1/src/unix.cabal - it says 1.5 there
09:38:01 <hodapp> but if that's not really a 'yield' then what is it?
09:38:02 <eds> oh ok. then match the char and select the operation?
09:38:14 <lenex> ion: thanks, i see
09:39:01 <lenex> ion: ive never seen the revisions thing before! sorry for my confusion :)
09:39:32 <ion> It hasnâ€™t been around for many months, i think.
09:41:01 <eds> monochrom: can we use enum like we do in C++? that way 'p' would be 0(zeroth element in list r), 'u' would be 1(first element in list r) and so on?
09:41:24 <monochrom> nonterminal = do { r <- getRandomR (0, 3); [liftM3 Arith (getRandomR ('a', 'z')) terminal terminal, liftM2 List (getRandomR ('a','z')) terminal, liftM3 Comp (getRandomR ('a','z')) terminal terminal, liftM3 Logic (getRandom ('a','z')) terminal terminal] !! r }
09:42:15 <eds> ahh that looks so good. 
09:42:29 <ion> eds: I havenâ€™t looked at your problem but youâ€™d use a sum type like data Foo = P | U | ... for enum foo { p, u }
09:42:59 * hackagebot uri-bytestring 0.1.5 - Haskell URI parsing as ByteStrings  http://hackage.haskell.org/package/uri-bytestring-0.1.5 (MichaelXavier)
09:43:21 <monochrom> because I'm mimicking the E example without any original thought
09:43:44 <monochrom> creativity is the root of all XY problems
09:44:59 <eds> I see ion. But going the enum way would be complicated. What  monochrom did looks so elegant and compact!
09:45:13 <fragamus> :t (>>=)
09:45:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:45:21 <eds> true, monochrom
09:45:25 <fragamus> :t (>=>)
09:45:28 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:45:33 <hodapp> well, I guess if https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style#Example:_coroutines is correct then I'm not really correct to say that Ivory's coroutines are 'backwards'; what they use for yield does indeed suspend the computation
09:45:39 <eds> haskell is confusing and amazing
09:46:01 <hodapp> and what direction a value is passed (or whether it is at all) isn't really relevant
09:46:21 <fragamus> :t (=>=)
09:46:32 <lambdabot>     Not in scope: â€˜=>=â€™
09:46:32 <lambdabot>     Perhaps you meant one of these:
09:46:32 <lambdabot>       â€˜>>=â€™ (imported from Control.Monad.Writer),
09:46:37 <athan> With quickcheck, I'm finding myself doing this for generating bounded (single-var) strings: `(:[]) <$> choose ('A','z')`. Is there a better way to generate small strings?
09:46:50 <fragamus> um what is the signature for cobind
09:47:10 <ion> @hoogle extend
09:47:11 <lambdabot> package extended-categories
09:47:11 <lambdabot> package extended-reals
09:47:11 <lambdabot> System.Posix.Terminal.ByteString ExtendedFunctions :: TerminalMode
09:47:41 <athan> :t Control.Comonad.extend
09:47:42 <ion> Comonad w => (w a -> b) -> w a -> w b
09:47:45 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
09:47:48 <athan> fragamus: ^
09:48:17 <geekosaur> hodapp, sounds like Icon coroutines. x@coro causes the yield/@ on which coro is blocked to return x, and will return the value from the next yield or @ back to the current coroutine
09:48:30 <hodapp> Icon?
09:48:34 <fragamus> can you make that kliesli
09:48:43 <geekosaur> it's supposed to be less confusing than unconstrained Cont, but isn't much >.>
09:48:47 <hodapp> hah
09:48:51 <athan> :i Control.Comonad.Comonad
09:48:57 <geekosaur> (well, it is if you can stick to yield, but then you just have generators)
09:49:00 <athan> :\
09:49:07 <ion> You can make it co-Kleisli.
09:49:39 <hodapp> Right now I'm trying to figure out if I'm just making an analogue of an already-explained operation in my attempt to make Ivory coroutines composable.
09:50:39 <hodapp> and I can see that coroutine A in order to compose with coroutine B has to (1) pass some sort of continuation for its own context to coroutine B, and (2) suspend its own execution pending coroutine B using that continuation to return control
09:50:40 <geekosaur> (Icon: https://www.cs.arizona.edu/icon/)
09:51:08 <geekosaur> which was where I learned about coroutine
09:51:20 <hodapp> huh
09:51:43 <hodapp> I've used some C implementations of them, and Ivory's coroutines just boil down to a state-machine based C version
09:52:35 <fragamus> :t (>=>)
09:52:44 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:54:58 <fragamus> so... (w a -> b) -> (w b -> c) -> w a -> c
09:55:34 <fishythefish> :t (<=<)
09:55:41 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
09:56:02 <fishythefish> :t (=>=)
09:56:09 <lambdabot>     Not in scope: â€˜=>=â€™
09:56:09 <lambdabot>     Perhaps you meant one of these:
09:56:09 <lambdabot>       â€˜>>=â€™ (imported from Control.Monad.Writer),
09:56:19 <fishythefish> hm
09:56:34 <minozake> I see little faces all shifty-eyed.
09:56:48 <ion> :t (Control.Comonad.=<=)
09:56:54 <lambdabot> Control.Comonad.Comonad w => (w b -> c) -> (w a -> b) -> w a -> c
09:57:29 <fishythefish> Of course.
09:58:00 <fishythefish> :t (Control.Comonad.=>=)
09:58:05 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> (w b -> c) -> w a -> c
09:58:58 <fragamus> so... (w b -> c) -> (w a -> b) -> w a -> c
09:59:19 <fragamus> so... (w a -> b) -> (w b -> c) -> w a -> c
09:59:26 <fragamus> ^
09:59:46 <fishythefish> =<= and =>=, respectively
09:59:54 <fragamus> I like =<= better
10:00:56 <mniip> =<= is akin to <=< which is akin to Control.Category.(.)
10:01:04 <fragamus> I prefer right to left   and  klielsi style
10:01:08 <fragamus> yes
10:02:36 <fragamus> I also kind of wish the arrows pointed left
10:03:18 <fishythefish> You mean <- instead of -> ?
10:03:22 <fragamus> yeah
10:04:08 <fishythefish> That would be more consistent with function composition, yes.
10:04:27 <fragamus> yeah
10:05:14 <fishythefish> Alternatively, one could wish function composition was left-to-right, I suppose.
10:05:53 <fishythefish> (.) reads as "then" rather than "of"
10:06:11 <eds> monochrom: It gives the following error: No instance for (MonadRandom ((->) (Char, Char)))   arising from a use of `getRandom' In the second argument of `liftM3', namely `(getRandom ('a', 'z'))' In the expression:   liftM3 Logic (getRandom ('a', 'z')) terminal terminal
10:06:26 <ion> â€œafterâ€
10:06:46 <monochrom> then I made a typo. change to "getRandomR"
10:06:59 <ion> â€œf xâ€ reads as â€œf of xâ€.
10:08:05 <eds> oh well stupid me. thanks
10:08:40 <athan> Is there a math term for "non-forgetful"? For instance, if I sort a list, it shouldn't add or remove elements?
10:09:10 <monochrom> you have conflated two questions into one.
10:09:27 <monochrom> to not add or remove, "permutation"
10:09:57 <athan> :x thanks monochrom
10:12:19 <fishythefish> ion, huh?
10:13:40 <fishythefish> Oh, I guess I should say (.) _would_ read as "then" rather than "of"
10:13:46 <RickP> quick lens question: how do i get a traversal out of two traversals of the same type? obviously i can mappend the results, but it would be nice if the operation was combined into the traversal already
10:13:49 <ion> rather than â€œafterâ€
10:14:18 <fishythefish> f . g is "f of g", isn't it?
10:14:26 <tromp_> f after g
10:14:31 <ion> â€œsin piâ€ reads â€œsin of piâ€, â€œsquare . sinâ€ reads â€œsquare after sinâ€
10:14:43 <fishythefish> Is that a Haskell thing?
10:14:49 <fishythefish> Never heard it that way in math.
10:15:05 <fishythefish> I agree it means "after", but I've always heard "of" in both situations.
10:15:18 <fishythefish> (f . g) x is "f of g of x"
10:15:19 <tromp_> i would say f x is f of x
10:15:44 <fishythefish> I guess the argument is that (f . g) x = f (g x) = "f of (g of x)"
10:15:48 <tromp_> f.g$x is f of (g of x)
10:16:09 <tromp_> so of refers to application, not composition
10:16:17 <ion> â€œ(f after g) of xâ€ is â€œf of (g of x)â€
10:16:42 <fishythefish> All right, sure.
10:16:54 <fishythefish> I don't disagree with what you're saying and I understand the meaning of all these expressions
10:17:00 <fishythefish> I've just never heard "after" used instead of "of" in math.
10:18:00 * hackagebot linear-grammar 0.0.1 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.1 (athanclark)
10:22:44 <bollu> hey guys, I'm trying to learn haskell by solving questions on hackerrank 
10:22:54 <bollu> here it the code: http://codepad.org/2zzO139U
10:23:01 <bollu> https://www.hackerrank.com/challenges/sherlock-and-array
10:23:04 <bollu> and here is the question
10:23:18 <bollu> now, my code isn't working since there's some logical error I'm making
10:23:30 <bollu> In any other language, I'd throw a bunch of prints or step into a debugger
10:23:40 <bollu> but.. I don't know what to do in haskell :(
10:23:50 <bollu> could someone tell me as to how to debug in Haskell?
10:23:53 <prsteele> bollu: import Debug.Trace
10:24:03 <bollu> prsteele: how do I use it?
10:24:07 <prsteele> bollu: provides trace :: String -> a -> a
10:24:30 <prsteele> bollu: so trace "printf-debugging" (1 + f 7)
10:24:42 <prsteele> bollu: would return (1 + f 7), but happen to print "printf-debugging" first
10:24:47 <bollu> ah
10:24:57 <bollu> prsteele: I want to debug the values that I use inside the sums_equal function
10:25:02 <bollu> on line number 47
10:25:04 <prsteele> bollu: in particular, we don't need to be in an IO () context to do this
10:25:05 <bollu> http://codepad.org/2zzO139U
10:25:21 <bollu> so, well, how would I write the function call for that function?
10:25:45 <bollu> prsteele: yes, I noticed that :) Otherwise, code everywhere would be infected with IO
10:25:52 <prsteele> bollu: sums_equal arr index = trace (<insert string here>) $ left_sum == right_sum where ...
10:26:02 <bollu> ohh, thanks!
10:26:15 <fragamus> (w b -> c) -> (w a -> b) -> w a -> c
10:26:19 <lamefun> Can I omit types in "exported" modules? Can Haskell documentation generator make them for me?
10:26:46 <prsteele> bollu: in case you're interested, trace cheats the type system to do this. It uses unsafePerformIO.
10:27:01 <bollu> hmm. that lets you escape the type system rules?
10:27:12 <bollu> so, do some underlying functions use it for performance gains or something?
10:27:51 <prsteele> bollu: I don't think you would ever want to rely on trace to actually print something critical to the screen, since the compiler doesn't treat it as a side effect.
10:27:55 <edwardk> RickP: what happens when they traverse overlapping "stuff"?
10:28:03 <edwardk> RickP: the problem is that traversals don't compose in general
10:28:12 <edwardk> RickP: we can compose folds this way just fine
10:28:16 <bollu> prsteele: hmm. Also, is there a debugger for GHC?
10:28:20 <bollu> where I can step in and stuff?
10:28:31 <prsteele> bollu: I'm sure it exists, but I've never used it
10:28:37 <bollu> okay ^_^
10:29:02 <dominik> hey guys, I'm a haskell newbie trying to install packages using cabal for the first time.
10:29:09 <ronh-> ghci ships with a debugger
10:29:32 <dominik> is there any good tutorial on how to escape cabal dependency hells/fixing broken packages?
10:29:50 <dominik> and installing a specific version of a package.
10:29:52 <dominik> ?
10:30:08 <foreignFunction> dominik: use sandboxes
10:30:25 <RickP> edwardk: why is it a problem if they traverse overlapping stuff? Do the lens laws or the type checker somehow have to guarantee that it doesn't happen? Isn't guaranteeing that it doesn't happen up to the caller?
10:30:37 <edwardk> the traversal laws get in the way
10:30:41 <RickP> i'll look into folds
10:30:42 <ronh-> dominik cabal sandboxes + stackage
10:31:16 <alisia> Why does this code give a parse error at line 13? http://lpaste.net/134352
10:31:19 <edwardk> consider two 'horizontal' traversals' of 'identity' you'd get back 'two' a'as, but you'd go to change them each with an effect into a b, but you only have places to put one of them. so you can't get back what you put in
10:31:35 <edwardk> not only do the laws get upset at you but there isn't a nice way to make the implementation work
10:31:44 <edwardk> which speaks to the laws =P
10:31:52 <alisia> uses template haskell in the line 12...
10:32:03 <geekosaur> it's not the TH
10:32:07 <geekosaur> it's the where on line 11
10:32:25 <geekosaur> where can't just be dropped anywhere, it is part of binding syntax
10:32:27 <RickP> oh i get it, traversals are too powerful for this
10:32:36 <geekosaur> which means, it terminated your `main` function
10:32:43 <edwardk> yeah
10:32:46 <edwardk> folds are fine
10:32:47 <int-e> ah lambdabot, I guess that answers the question whether the seen module leaks memory...
10:32:51 <alisia> geekosaur, Oh. I see.
10:32:52 <RickP> if it was a getter-only abstraction then an overlap wouldn't matter
10:32:52 <edwardk> you can smash together folds all you want
10:33:05 <edwardk> in fact its quite easy
10:33:45 <edwardk> > (1,2,3)^..(_1 <> _2)
10:33:47 <edwardk> > (1,2,3)^..(_1 <> _3)
10:33:54 <lambdabot>  [1,3]
10:33:55 <lambdabot>  [1,2]
10:33:56 <edwardk> > (1,2,3)^..(_1 <> each)
10:34:12 <edwardk> you can just 'mappend' the folds
10:34:17 <edwardk> and they fold the sum
10:34:34 <edwardk> you can use runFold and Fold to build an applicative that lets you treat them like s -> [a]    in a monad transformer setting
10:34:45 <edwardk> as well if you want a cross product of the folds
10:36:04 <int-e> ion: thanks for the notice
10:36:13 <edwardk> bbiab
10:36:32 <ion> int-e: Out of curiosity, what was wrong?
10:37:03 <RickP> i was doing the same thing with lens-family and it didn't work, i guess it doesn't have the type machinery to downgrade lenses into folds automatically
10:37:08 <int-e> ion: just lambdabot using more memory than it should (and also spending more time on GC than it should, apparently)
10:37:22 <ion> So a leak somewhere?
10:37:43 <int-e> ion: see above: "<int-e> ah lambdabot, I guess that answers the question whether the seen module leaks memory..."
10:37:54 <ion> Ah, i missed it.
10:37:57 <int-e> np
10:38:22 <int-e> so, sorry, @seen is gone again for the time being.
10:43:20 <bollu> how do you memoize in haskell? Like, in any other language I'd mutate a dictionary with the stored value
10:43:26 <bollu> but.. I can't mutate in haskell
10:43:29 <bollu> so what's the right way to do this
10:44:00 <prsteele> bollu: there are a few ways to do this; googling will yield an example for the fibonacci sequence
10:44:12 <prsteele> bollu: however, we can think about this as well
10:44:26 <prsteele> bollu: imagine you store pre-computed function values in a tree
10:44:52 <prsteele> bollu: when you ask for a value, we check if it is in the tree. if it is, we return it. otherwise, we compute it, store it in the tree, and return it
10:44:57 <jaawerth> question about haskell platform - while I was first going through tutorials and things, I was just using one of the APT repos available for the haskell platform, but I know that for a lot of environments, APT repos are so out-of-date or poorly integrated that it's not always recommended to use them. Is that the case here? haskell.org seems to point right at the Debian/Ubuntu repos, but I figured I'd ask
10:45:10 <bollu> hmm
10:45:21 <prsteele> bollu: this idea -- doing computations in some context -- describes computing with monads
10:45:32 <bollu> okay, the dreaded M word :( 
10:45:43 <bollu> go on :)
10:45:58 <prsteele> bollu: so, you could use something like the State monad to maintain your tree of pre-computed values as you do your other computations
10:46:10 <bollu> prsteele: how do I use a state monad?
10:46:10 <warbo> can I tell the "hoogle" command to create a database in my current directory, rather than globally?
10:46:53 <srhb> bollu: (There's also https://hackage.haskell.org/package/memoize for the pure way of doing it, when possible)
10:46:53 <prsteele> bollu: I'll refer you to the myriad articles online, I can't put it more succinctly than they can
10:47:10 <prsteele> ^^ is probably what you want anyway
10:47:24 <bollu> srhb: I'm submitting answers to HackerRank. They don't let you use that package AFAIK
10:47:26 <ion> bollu: Anything (monomorphic) that is bound to a name and evaluated is kept in memory as long as the name is in scope. So arrange things so that you have a top-level name that holds a lazy table (often a tree) corresponding to the map from every x to f x and you have a memoized version of f.
10:47:34 <srhb> bollu: Oh!
10:47:46 <tromp_> prsteele: the tree could simply hold *all* possible precomputed values
10:47:48 <warbo> bollu: perhaps you could use a lazy datastructure instead
10:48:15 <bollu> warbo: I've been putting aside learning how monads work. Might as well do it now :)
10:48:19 <Sindriava> Hi! Does anyone have any experience with OpenGL on OSX?
10:48:20 <bollu> thanks for the pointers guys!
10:48:34 <bollu> Sindriava: do you mean in general or in a haskell context?
10:48:40 <Sindriava> In haskell context
10:48:47 <bollu> Sindriava: ah, nope
10:48:52 <warbo> bollu: one thing to keep in mind with a monad; it will change your return types
10:49:16 <bollu> warbo: becayse (>>=) = m a -> (a -> mb) -> mb  ?
10:49:23 <warbo> bollu: yes
10:49:24 <Sindriava> Aw :( I'm getting a plain borderless window after initialization O.o
10:49:37 <bollu> "logict lens pipes mwc-random hashtables regex-pcre hmatrix aeson and hashmap libraries are available."
10:49:39 <ion> memoBool :: (Bool -> a) -> Bool -> a; memoBool f = let (f,t) = (f False, f True) in bool f t
10:49:47 <bollu> how useful are those haskell libraries?
10:49:51 <warbo> bollu: this has two consequences: a) you'll have to use some kind of "runMemoize" function to get the pure value back
10:50:01 <ion> Given a function from Bool to something, memoBool returns a memoized version.
10:50:03 <Sindriava> warbo: A better formulation is that it *can* change the return type
10:50:18 <ion> Whoops, i shadowed a name.
10:50:29 <ion> memoBool :: (Bool -> a) -> Bool -> a; memoBool fun = let (f,t) = (fun False, fun True) in bool f t
10:51:03 <warbo> bollu: b) the memozation will only happen in one "runMemoize" call; ie. if you run two memoized things, they won't share the dictionaries
10:51:15 <bollu> hm
10:51:23 <bollu> that's tricky
10:52:15 <warbo> Sindriava: true; "Monad" is just a typeclass, which the existing return type might already be an instance of :)
10:52:21 <bollu> I'll try and use it. Thanks, guys :)
10:52:36 <SpaceDuck__> Hey
10:52:51 <bollu> Just for the record, I am trying to memoize this: http://codepad.org/rVy2GDhT
10:53:00 <Sindriava> warbo: Yeah, I've had some headaches before I got used to the fact that a â†’ b might mean a â†’ a in some cases :)
10:53:04 <bollu> particularly, the sums_equal function
10:53:22 <Sindriava> Is there *the* tutorial for opengl programming in haskell?
10:53:54 <Sindriava> Or more specifically, I want to play around with generative graphics. Is there a better framework for this than raw opengl + raw math?
10:54:00 <dackerman> 
10:54:08 <prsteele> bollu: for something like this, I would just populate a tree with the solutions initially
10:54:28 <prsteele> bollu: and then query the tree. laziness ensures you don't waste time computing anything you end up not needing
10:55:32 <prsteele> bollu: you can pass the tree around anywhere and it shouldn't ever recompute a value. also, replace tree with Data.Map
10:56:23 <warbo> prsteele: the input space is quite large though: ([Int], Int)
10:56:55 <warbo> prsteele: a lazy approach would need to arrange all possible values in a sensible way
10:57:37 <prsteele> warbo: I was assuming this was specialized for a particular array, but yes
11:04:11 <Sindriava> Ok, new question. What fundamental differences are there between runhaskell and ghc ?
11:04:35 <michaelt> runhaskell is a 'bytecode interpreter' 
11:04:42 <Sindriava> My OpenGL woes were caused by using runhaskell instead of GHC, which I assumed were similar
11:04:47 <warbo> Sindriava: ghc has many "modes"; runhaskell is one
11:06:08 <Sindriava> I see! So runhaskell is in a sense a different way of launching ghc?
11:06:24 <michaelt> oh, that's different. runhaskell will I think be looking for things in the same places as ghci does 
11:06:46 <warbo> well, technically "runhaskell" *could* be a different compiler/interpreter
11:06:50 <warbo> but in this case, yes
11:07:01 <kadoban> Sindriava: What kind of woes did you run into, out of curiosity?
11:07:03 <michaelt> runhaskell is a symlink for runghc 
11:07:39 <Sindriava> kadoban: When I run the example OpenGL code through runhaskell, it just produces a white rectangle. No window border, nothing.
11:08:09 <Sindriava> kadoban: Or more specifically, the window border is there (the window has extra space for it and I can grab it and move the window) but it's not rendered
11:08:19 <kadoban> Hmm
11:08:28 <gcganley> so what is the state of the art with interacting with a database? I've heard of opeleye but i have no idea what it is, I'm not too experienced with databases either. I'm looking for something that will challenge me. would it be opeleye or is there something else more interesting
11:08:39 <michaelt> warbo: right, hugs used to symlink runhaskell to runhugs, if I remember
11:09:08 <Sindriava> kadoban: Or rather, it seems to be a GLUT issue instead of a OpenGL issue.
11:09:10 <michaelt> Sindriava: what os are you using
11:09:19 <Sindriava> michaelt: OSX 10.10
11:09:53 <mniip> could be a library initialization quirk
11:09:53 <Sindriava> I've installed Haskell through the haskell platform installer, version 7.8.3
11:10:07 <Sindriava> Is there a place I can report this?
11:10:08 <michaelt> right, I think this is an os x thing. even just using ghc, os x doesn't really like it, with these gui libraries, but my knowledge is probably out of date
11:10:36 <Sindriava> michaelt: Actually, GLUT was deprecated on OSX if I remember correctly
11:10:56 <Sindriava> michaelt: So it's probably just an issue with the GLUT implementation that OSX provides
11:11:37 <gcganley> is there a guy on the channel under tomjaguarpaw?
11:11:50 <lumia935> Download current vBulletin Styls/Plugins, or request one that you see from vbulletin.org (We hold a valid license) http://www.criosphinx.net/
11:11:53 <lumia935> Download current vBulletin Styls/Plugins, or request one that you see from vbulletin.org (We hold a valid license) http://www.criosphinx.net/
11:13:40 <gcganley> how do i leave a note?
11:13:48 <gcganley> is it \/note?
11:14:00 <johnw> you can @tell name something
11:14:10 <gcganley> johnw: thank you
11:15:11 <michaelt> Sindriava: I don't know, if I compile a trivial gloss program it runs, if I use runhaskell all hell breaks loose. 
11:15:28 <Sindriava> michaelt: What OS are you using? OSX too?
11:15:34 <michaelt> yes
11:17:01 <gcganley> @tell tomjaguarpaw hey, I've been wanting to write a website using haskell and I've gotten the hang of using simple things like scotty and lucid. but i want to be able to plug into a backend, specifically hooking into a database. i was curious about opaleye and its features. I've never used a SQL DSL so I just had a few questions about it. -- Gregory Ganley
11:17:01 <lambdabot> Consider it noted.
11:19:21 <Welkin> gcganley: look into Persistent
11:19:33 <Welkin> It is was I use to interface with Postgres
11:19:50 <Welkin> for a complete package, look into yesod
11:20:08 <Welkin> it is "batteries included"
11:20:26 <srhb> gcganley: Also if all you need is data storage, you might want to look into acid-state as well for a very intriguing alternative to SQL databases.
11:20:43 <srhb> gcganley: (It lets you store Haskell values directly)
11:20:57 <R0b0t1> would folding a monad be equivalent to the do syntax?
11:21:04 <ttt_fff> is anyone working on an alterantvie to template ahskell? i.e. something like lisp macros, where the macro langauge is untyped ?
11:21:16 <ion> R0b0t1: What does folding a monad mean?
11:21:18 <srhb> R0b0t1: What do syntax? Depends what it is, and depends on the fold.
11:22:37 <R0b0t1> <<= operation right?
11:23:02 <R0b0t1> presumably that's not specific enough so please list variables and their effect
11:23:04 <R0b0t1> :)
11:23:05 <warbo> ttt_fff: there's "liskell", which I think is dead; typed alternatives fall under the umbrella of "staged computation"
11:23:29 <ttt_fff> I'm not convinced of 'staged computation' in particular, of why we nee more than 2 stages
11:23:38 <ttt_fff> code that writes code that writes code is too confusing
11:23:43 <warbo> heh
11:24:04 <ttt_fff> liskell looks alive as of 2007
11:24:11 <ttt_fff> I guess that does make it dead as of 2015
11:24:13 <R0b0t1> there's merely code that writes code
11:24:19 <R0b0t1> :^)
11:24:33 <R0b0t1> code that writes code that writes code is code that writes code
11:25:10 <R0b0t1> ion, srhb: Sorry, is my question too broad? Feel free to tell me to go read something
11:25:27 <ttt_fff> R0b0t1: go read www.google.com
11:25:32 <ttt_fff> :-)
11:25:32 <R0b0t1> ok done
11:25:33 <srhb> R0b0t1: Well first off you can't really fold a monad. You might be able to fold a monadic action over something.
11:25:42 <R0b0t1> well
11:25:43 <R0b0t1> yes
11:25:48 <R0b0t1> I meant that.
11:25:52 <srhb> OK, good.
11:26:08 <ttt_fff> so I'm running a deep learning tutorial, and I'm wondering if it'll take me less time if (1) I learn how to use gpu on aws and (2) rerun code on aws instead
11:26:09 <srhb> As to whether you can achieve the same with do syntax -- well, foldM is defined in terms of that.
11:26:20 <srhb> R0b0t1: and for short traversables you might even write out the code yourself.
11:26:24 <srhb> R0b0t1: There's no magic.
11:26:39 <R0b0t1> oh there's lots of magic, you're just better acquainted with it than I
11:26:46 <R0b0t1> thanks for the answer, cheers
11:26:54 <srhb> Well, I mean folding is not some magical language construct. :)
11:27:00 <R0b0t1> oh well sure
11:27:10 <srhb> I didn't mean to imply that you can get it in a few minutes :P Sorry.
11:27:34 <Skolopedrion> Hey
11:27:48 <Skolopedrion> I'm coding a 2D sandbox game, and I was wondering how should I organize my block types, because each block can have different behaviors when walked on, clicked, placed, or destroyed
11:28:03 * hackagebot riemann 0.1.0.0 - A Riemann client for Haskell  http://hackage.haskell.org/package/riemann-0.1.0.0 (telser)
11:28:51 <Skolopedrion> How would you organize the blocks ?
11:29:37 <R0b0t1> I would suggest it's more about organizing the actions the blocks perform and the input that triggers them
11:29:40 <R0b0t1> listener pattern?
11:29:57 <R0b0t1> granted I'm not very acquainted with haskell GUI stuff
11:30:48 <Skolopedrion> I've never done GUI in Haskell neither, I'm asking for an architecture advise rather than a GUI thing
11:31:12 <warbo> I think I've solved my problem: hoogle data --datadir=.
11:31:27 <ttt_fff> threepenny
11:31:57 <srhb> I don't think that's the question
11:32:17 <srhb> The question is how to model the data type for either the blocks themselves or the structure that holds the blocks, I think?
11:33:21 <srhb> so something like data Block = Block { walkAction :: [Action]; clickAction :: [Action]; ... }
11:33:30 <srhb> Skolopedrion: Or am I misunderstanding the question?
11:34:02 <Skolopedrion> The behaviors should be function or not ?
11:34:30 <hodapp> :t callCC
11:34:31 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
11:34:37 <srhb> Skolopedrion: I don't know what would be smartest, I was just trying to elaborate on your question so that someone else might answer it. :)
11:36:15 <hodapp> That argument to callCC takes that first (a -> m b) argument; is there any particular widely-understood name for this argument? 
11:36:22 <argent0> Skolopedrion: something like: open :: Block -> Block?
11:36:34 <Skolopedrion> srhb: can't a record data type have an attribute which type is a function ? like data Block = Block {walkAction :: (Actor -> Block -> IO ())}
11:36:46 <srhb> Skolopedrion: Yes it can.
11:37:18 <hodapp> because it's sort of a 'return' function, but in a different sense than what 'return' normally means in Hakell.
11:37:22 <Skolopedrion> so that could be the solution, if i do a default constructor for each block
11:37:23 <Skolopedrion> argent0: what do you mean ?
11:37:24 <hodapp> s/Hakell/Haskell/
11:37:30 <srhb> Skolopedrion: I don't think I would model it like that
11:37:57 <srhb> Skolopedrion: Rather I would have a walk function that has type Block -> ??? and acts based on pattern matching of the fields in the block or something.
11:38:07 <srhb> But ymmv
11:38:47 <Skolopedrion> srhb: what could the pattern match for example ?
11:39:19 <srhb> Skolopedrion: walkOn (Block DeathTrap) = kill player
11:39:23 <srhb> Or somesuch
11:39:43 <srhb> With whatever appropriate version for your specific records.
11:40:08 <Skolopedrion> not bad
11:40:16 <Skolopedrion> thanks a lot srhb
11:40:19 <srhb> But I think I would do this in such a way as to manage the game state purely
11:40:36 <srhb> Avoiding IO'y functions when all they need to do is alter the game state.
11:40:49 <srhb> And reserving them from actually updating the user view and taking inputs etc.
11:40:52 <srhb> for*
11:41:09 <srhb> But take my advice with a grain of salt, I'm no game developer.
11:41:41 <Skolopedrion> me neither
11:42:11 <Skolopedrion> but maybe the death trap could damage the player with a different value...
11:42:24 <whiteline> just use an entity-component system
11:42:33 <whiteline> it just werks
11:42:38 <whiteline> the alternative is using lenses
11:43:17 <Skolopedrion> i'll check ECS out
11:43:26 <Skolopedrion> thanks whiteline
11:43:37 <whiteline> np
11:45:23 <Skolopedrion> is it a good idea to wrap all my game information into an algeraic data type ? like data Game = Game {player :: Player, level :: [[Block]], ...} ?
11:45:51 <srhb> Skolopedrion: Most people would do that, I think.
11:46:18 <Skolopedrion> srhb: but if i pass it as an argument to walk for example, the function can modify everything
11:46:47 <srhb> Skolopedrion: Well you don't have to. You'd have functions that modify the game and within that you could use functions that modify just some aspect of the game.
11:49:06 <Skolopedrion> srhb: ok thanks a lot, i will do the pattern matching thing you told me, i'll see for the game information wrapper
11:49:12 <Skolopedrion> bye
11:49:14 <srhb> :)
11:50:19 <Skolopedrion> whoops it's me again
11:50:56 <eacameron> how does cabal handle packages that depend on both unix and Win32? Does it  try to build both dependencies on all platforms?
11:50:59 <Skolopedrion> do you guys know a game programmed in Haskell I could learned from ?
11:51:17 <Skolopedrion> *learn
11:52:26 <hiptobecubic> Skolopedrion, i think nikki and the robots was open sourced wasn't it?
11:52:46 <srhb> Maybe lambdahack?
11:53:39 <Skolopedrion> hiptobecubic: only the NewLisp version is on GitHub, but i'll check it out, thanks
11:53:55 <hexagoxel> eacameron: https://github.com/haskell/cabal/blob/master/cabal-install/cabal-install.cabal#L162-166
11:54:04 <srhb> Also perhaps Elise Huards book will be of interest to you, Skolopedrion 
11:54:47 <eacameron> hexagoxel: Oh I see....does hackage report both as dependencies then?
11:55:09 <eacameron> hexagoxel: Indeed it does
11:55:24 <eacameron> hexagoxel: Excellent that solves the problem very nicely...conditional dependencies
11:56:03 <Skolopedrion> where can I read it online (for free) ? I've only seen paper version of the book, and i'm too young to afford this, i'll ask my parents ^^
11:56:05 <hexagoxel> eacameron: and it also combines the dependencies of all components, so you get dependencies on yourself on hackage :)
11:57:08 <eacameron> hexagoxel: Ok makes sense; So it's a flat "view" of the real dependenciens
11:57:41 <Gurkenglas> Just installed stack. It says stack build will do what it takes to build the project i run that on. How do I turn my .hs file into a project?
11:58:05 * hackagebot cabal-bounds 0.9.4 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.9.4 (DanielTrstenjak)
11:58:11 <Skolopedrion> thanks again srhb, i'll take account of your advice
11:59:34 <geekosaur> Gurkenglas, possibly cabal init
11:59:47 <Gurkenglas> I thought stack replaces cabal :I
12:00:14 <geekosaur> it may still use cabal files though. if it has its own version of cabal init, I wouldn't know
12:01:44 <kadoban> Gurkenglas: Mostly wraps it
12:01:51 <Gurkenglas> hmkay
12:04:45 <rofer> Is there a way to get the cabal version of a package from inside that package? Like, can I do something like putStrLn "This is version #VERSION" where #VERSION is replaced by some kind of pre-processor before the package is built?
12:05:23 <michaelt> rofer: cat *.cabal | less
12:05:38 <michaelt> oh ...
12:06:05 <arkeet> rofer: yes!
12:06:13 <mauke> rofer: https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-the-package-version
12:06:32 <arkeet> ^
12:06:35 <arkeet> see for example https://hackage.haskell.org/package/acme-year
12:06:36 <arkeet> :-)
12:06:46 <gcganley> is it better to `cat *.cabal | less` or `less < *.cabal
12:06:48 <gcganley> `
12:06:57 <rofer> Thanks! Just what I'm looking for.
12:07:12 <gcganley> ik this is a bash discusion and really nit picky im just curious
12:07:26 <koala_man> gcganley: the former. it works when there are multiple files
12:07:33 <arkeet> rofer: I suppose that can't be used in CPP.
12:07:45 <michaelt> oh i see Paths_<pkg>.version
12:08:06 <gcganley> koala_man: really? i would have thought that both would work
12:08:06 <hexagoxel> rofer: and i think you have to expose-modules the Paths.. module
12:08:07 <heisenbug> lambdabot: (let (Just b) = 8 in b)
12:08:21 <michaelt> gcganley: my bash is always moronic.
12:08:45 <hexagoxel> (other-modules should be fine as well)
12:09:14 <arkeet> yes, other-modules
12:09:39 <Gurkenglas> What's the bottleneck ressource of the "Cloning package index ..." step of stack build? I'm looking at the task manager and it doesnt seem to be using any cpu few percent ram and no network
12:09:49 <lpaste> mniip pasted â€œunsafeCoerce stuffâ€ at http://lpaste.net/134355
12:10:04 <mniip> any ideas on why demote works as expected, but promote only returns 'Nothing'
12:10:13 <Gurkenglas> (Though Network for some reason its scaled weirdly in the Task Manager, max download capacity is 4%...)
12:10:24 <gcganley> michaely: oh everyones bash is moronic, I'm asking "what is the pretiest turd"
12:10:25 <koala_man> gcganley: it doesn't, because it doesn't map well onto unix system calls
12:10:36 <Gurkenglas> (and no disk usage)
12:10:58 <koala_man> zsh has a weird workaround for it, which basically rewrites it to  less < <(cat *.cabal)
12:11:29 <gcganley> i think you would have to use cat to concat all of the flies together before displaying i didnt know if less could take multiple arguments
12:12:32 <arkeet> less can take multiple arguments, but it doesn't concatenate.
12:12:35 <michaelt> koala_man: in less < <(cat *.cabal) the files are concatenated?
12:12:55 <gcganley> arkeet: what does it do then?
12:13:00 <arkeet> michaelt: it feeds the output of (cat *.cabal) into less
12:13:04 <arkeet> gcganley: try it out!
12:13:21 <gcganley> one moment
12:13:22 <koala_man> michaelt: yes. instead of just opening a file as stdin, it opens a pipe as stdin and writes all the files to it
12:13:42 <michaelt> I see it now, cool.
12:13:46 <arkeet> also I guess this is #haskell.
12:14:36 <michaelt> arkeet: well, it's not so easy to use haskell without a few bits of bash or the like ...
12:15:01 <arkeet> I'm just saying.
12:15:18 <gcganley> arkeet: ok lets relate this to haskell, i fucking hate bash. is there a way i dont have to use it or use a DSL to translate into basu
12:16:26 <arkeet> I dunno what you want. there's something called shelly, no idea if that's what you want.
12:16:38 <arkeet> @hackage shelly
12:16:38 <lambdabot> http://hackage.haskell.org/package/shelly
12:17:06 <michaelt> gcganley: a dsl that writes bash would require bash to be minimally rational ... which I'm sure it is ...
12:17:17 <michaelt> @hackage turtle
12:17:17 <lambdabot> http://hackage.haskell.org/package/turtle
12:17:40 <michaelt> gcganley: turtle is pleasant for writing elementary scripts 
12:18:20 <arkeet> neat.
12:18:41 <RyanGlScott> Why doesn't :quit work in a .ghci file?
12:18:56 <srhb> RyanGlScott: Wuh?
12:19:01 <arkeet> why would you want it to?
12:19:03 <Gurkenglas> It's still "Cloning package index ..."...
12:19:27 <RyanGlScott> I'm trying to automate some tests involving a GHCi subprocess. I need a way to quit GHCi without human interaction.
12:20:24 <michaelt> gcganley: it you look at the tutorial,http://hackage.haskell.org/package/turtle-1.1.0/docs/Turtle-Tutorial.html  the standard scripts just use #!/usr/bin/env runhaskell 
12:20:38 <arkeet> so you are running a script in ghci with :script or something?
12:20:42 <whiteline> RyanGlScott: just pipe it control characters?
12:20:43 <gcganley> im looking just for a replacement for bash scripting. high file manipulation and the rest
12:20:44 <RyanGlScott> I
12:20:58 <RyanGlScott> arkeet: I've tried :script and .ghci files, to no avail.
12:21:01 <rockfruit> gcganley perl
12:21:08 <whiteline> ^D quits it
12:21:15 <arkeet> I mean
12:21:19 <arkeet> how are you running this thing
12:21:20 <arkeet> in ghci
12:21:22 <RyanGlScott> whiteline: Right. How I do that programmatically?
12:21:30 <geekosaur> end of file?
12:21:36 <whiteline> well how are you interacting with it now
12:21:38 <rockfruit> ("high file manipulation" at least()
12:21:40 <arkeet> send it a EOF.
12:21:41 <whiteline> from what are you running it
12:21:41 <gcganley> most likely using #! /usr/bin/env runhaskell
12:21:43 <arkeet> or ":quit\n"
12:21:53 <RyanGlScott>  Essentially, callProcess "ghci"
12:22:03 <arkeet> on stdin
12:22:10 <geekosaur> so just close the handle
12:22:19 <michaelt> gcganley: right thats what the turtle examples do 
12:23:07 <michaelt> gcganley: it has some odd features, I think becuase it's supposed also to be a sort of haskell primer
12:23:32 <michaelt> gcganley: with an unusually high-quality instructor ...
12:23:44 <RyanGlScott> arkeet: Ah, I didn't know that GHCi could have input redirected. That works beautifully!
12:25:30 <athan> Is there a boolean "equality" for Doubles that has a small range of error?
12:26:16 <RyanGlScott> athan: Does the Epsilon class from linear work? http://hackage.haskell.org/package/linear-1.18.1.1/docs/Linear-Epsilon.html
12:26:42 <athan> @check \x -> ((recip x) * x :: Double) == 1
12:26:43 <lambdabot>  *** Failed! Falsifiable (after 1 test):
12:26:44 <lambdabot>  0.0
12:26:54 <athan> erp
12:27:01 <athan> @check \x -> x > 0 ==> ((recip x) * x :: Double) == 1
12:27:01 <lambdabot>  : -1: -1:Ambiguous infix expression
12:27:17 <arkeet> @check \x -> x == 0 || ((recip x) * x :: Double) == 1
12:27:18 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 1072 shrinks):
12:27:18 <lambdabot>  0.18378850350190953
12:27:39 <athan> @check \x -> Test.QuickCheck.(==>) (x > 0) ((recip x) * x :: Double) == 1
12:27:40 <lambdabot>  Not in scope: data constructor â€˜Test.QuickCheckâ€™
12:27:43 <athan> mer
12:28:08 <bollu1> could someone help me with an error? I've posted the error at the bottom http://codepad.org/2fFqlt9n
12:28:08 <athan> arkeet: It usually ends up being 0.9999999999 or so
12:28:14 <athan> RyanGlScott: I'll check it out :) Thank you!
12:28:21 <bollu1> I'm not sure what NamedFieldPuns is. How do I use it?
12:28:48 <napping> anyone familiar with compdata? It seems (a :<: f) can't be deduced from (a :+: b :<: f).
12:29:04 <bollu1> and, well, what is the error first of all?
12:29:06 <geekosaur> bollu1, you have e.g. store @ Store { index, left_sum, right_sum }
12:29:31 <geekosaur> if you intended for this to automatically create local bindings named index, left_sum, right_sum then you need the NamedFieldPuns extension
12:29:46 <arkeet> and then it will be as if you had written:
12:29:53 <geekosaur> otherwise, you must write: store @ Store { index = index, left_sum = left_sum, right_sum = right_sum }
12:29:54 <arkeet> store @ Store { index = index, left_sum = left_sum, right_sum = right_sum }
12:29:55 <bollu1> geekosaur: so, well, right now what is happening?
12:29:56 <bollu1> ohh
12:30:03 <pragm> holy
12:30:20 <bollu1> what if I had just written Store {index, left_sum, right_sum} without the "store @ "
12:30:21 <bollu1> ?
12:30:25 <geekosaur> smae
12:30:32 <geekosaur> same thing; ther as-pattern is not relevant
12:30:47 <geekosaur> the "shortcut" form is not valid without the named field puns extension
12:30:48 <arkeet> maybe you could just consider writing
12:30:49 <bollu1> hm, so I need NamedFieldPuns to allow me to not repeat equating record names while pattern matching?
12:31:06 <arkeet> sums_equal_at_index store = if left_sum store == right_sum store then (True,store) else (False,store)
12:31:07 <arkeet> or better:
12:31:12 <michaelt> Store index left_sum right_sum would work
12:31:14 <arkeet> sums_equal_at_index store = (left_sum store == right_sum,store)
12:31:17 <arkeet> oops.
12:31:20 <arkeet> sums_equal_at_index store = (left_sum store == right_sum store,store)
12:31:48 <bollu1> arkeet: I want all of the fields because this is just a dummy thing
12:31:55 <arkeet> okay.
12:31:59 <geekosaur> understand that the usual usage is to use shorter local names: store @ Store { index = i, left_sum = ls, right_sum = rs }
12:32:06 <bollu1> hmm
12:32:15 <bollu1> thanks guys :)
12:32:25 <arkeet> without any extensions, that's the only valid way to deconstruct with record syntax.
12:32:26 <bollu1> and, well, how do I enable this?
12:32:27 <geekosaur> which is why the reusing names one is an extension and not standard
12:32:31 <bollu1> is it a compiler flag?
12:32:32 <arkeet> (also note that you can omit some fields.)
12:32:36 <geekosaur> {-# LANGUAGE NamedFieldPuns #-}
12:32:38 <geekosaur> as the first line]
12:32:43 <bollu1> ohh, thanks!
12:32:47 <arkeet> the usual way to turn on an extension is to put something like ^ at the top of the file.
12:32:47 <bollu1> what are such things called?
12:32:51 <arkeet> extensions
12:32:54 <bollu1> hmm
12:32:58 <arkeet> or LANGUAGE pragmas, if you're referring to that text.
12:32:59 <bollu1> so, they extend the language how?
12:33:09 <bollu1> is there some kind of a meta language thing? like lisp macros?
12:33:09 <geekosaur> wel,, that specific one is an extension. the {-# stuff is a pragma
12:33:15 <arkeet> they just turn on language features in ghc that aren't in the haskell standard
12:33:28 <bollu1> ah
12:33:52 <arkeet> you can't really write your own extensions unless you modify ghc.
12:33:57 <arkeet> anyway.
12:34:00 <michaelt> bollu1: here is a version with RecordWildCards http://codepad.org/J9tOkocB
12:34:03 <arkeet> you may also be interested in RecordWildCards
12:34:04 <geekosaur> the official haskell standard is ... conservative. last release was in 2010, release before that was 1998, and the changes between the two were minima;
12:34:15 <geekosaur> ghc moves quickly and has a lot of things the official standard doesn't
12:34:39 <geekosaur> (there are other haskell compilers, but not often used; they also don't implement much outside the official standard)
12:35:02 <bollu1> ah
12:35:03 <vikaton> Hello Haskellers
12:35:25 <bollu1> whoa, that is cool!
12:35:43 <johnw> vikaton: greetings!
12:35:54 <michaelt> bollu1: similarly RecordWildCards lets you write Question{..} instead of Question { array=array } on line 58. That's basically what it amount to
12:36:07 <bollu1> that is *cool&
12:36:16 <vikaton> I'm a total Haskell newb here, im gonna try and tackel it this summer :p
12:36:20 <bollu1> so it automatically injects the other names into scope?
12:36:47 <Gurkenglas> http://pastebin.com/LXXq3xfC wat do?
12:36:54 <johnw> vikaton: we like newbs
12:37:13 <vikaton> cool :P
12:37:43 <michaelt> Gurkenglas: change the dependencies in the cabal file?  Is it your package that is doing this...?
12:38:08 <bollu1> why only 2 dots and not three?
12:38:13 <bollu1> is there any particular reason?
12:38:23 <vikaton> I think .. is exclusive
12:38:27 <vikaton> and ... inclusive
12:38:30 <mauke> .. is already a token in the grammar
12:38:34 <vikaton> if you are talking about ranges
12:38:53 <bollu1> no, I'm talking about RecordWildcards
12:38:58 <michaelt> bollu1: presumably there was a 10000 message thread on the trac or something
12:39:00 <bollu1> are there any other cool extensions?
12:39:24 <bollu1> michaelt:  go on :)
12:39:46 <michaelt> bollu1: I think mauke explained it; we were already using .. in e.g. [1..5]
12:39:54 <bollu1> ahh
12:39:59 <bollu1> okay!
12:40:04 <vikaton> I heard that Haskell makes u a genius, is that true? :P
12:40:53 <magneticDuck> yes
12:40:56 <magneticDuck> unconditionally of course
12:41:40 <michaelt> vikaton: that's totally been my experience. it only works when my brain is attached to the ghc though
12:42:05 <Gurkenglas> michealt, I took a .hs file, stuck it in a folder, ran cabal init and then stack build in it. Here's the hs file: http://lpaste.net/134319
12:42:09 <vikaton> mhm
12:42:12 <vikaton> interesting
12:42:57 <michaelt> Gurkenglas: but the trouble is from the .cabal file cabal init wrote. Or am I missing something
12:43:02 <magneticDuck> vikaton: the only drawback to learning Haskell
12:43:07 <magneticDuck> is that it makes everything else look like shit
12:43:29 <prsteele> it really does change the way your approach other languages, and in a good way
12:44:00 <sm> it can make you appreciate some other languages' strenghts too
12:44:05 <vikaton> I wonder if it helps with understanding Rust
12:44:23 <Gurkenglas> michaelt, here's the cabal file then: http://pastebin.com/C40Ni7iB
12:44:29 <vikaton> oh well, im gonna learn me a haskell and hope for the best
12:44:38 <prsteele> from what I've seen in Rust (not much, only the pre-alpha versions) their type system seems almost as opinionated as Haskell's
12:44:43 <johnw> only learn it for great good
12:44:53 <Gurkenglas> (Welp. I guess my cabal is deprecated? ._.)
12:44:56 <vikaton> lol johnw
12:45:07 <albeit> Are there any downsides to using a IORef Data.Sequence as opposed to a Control.Concurrent.Chan?
12:45:14 <vikaton> Haskell platform installs everything right?
12:45:24 <michaelt> Gurkenglas: delete the base ==4.6.* and write e.g. base > 4.5
12:45:47 <michaelt> Gurkenglas: you are still going to have trouble though, since base-4.6 is what you have 
12:46:04 <c_wraith> vikaton: not even close.  There are thousands of packages on hackage.  The platform just installs a very small subset of them
12:46:05 <michaelt> Gurkenglas: but presumably one of your dependencies elsewhere demands a higher base 
12:46:13 <michaelt> Gurkenglas: I might not be following though
12:46:24 <vikaton> c_wraith: no what I meant is for the language itself :P
12:46:28 <Gurkenglas> That must have happened when I went yolo on that cabal install earlier
12:46:35 <napping> albeit: worse performance under contention, and also misses a few operations
12:46:54 <michaelt> Gurkenglas: what does "ghc-pkg list base" tell you about your version of base
12:47:00 <napping> albeit: you can't dup a chan like that, and have multiple readers with different amounts for items consumed
12:47:13 <c_wraith> vikaton: oh.  Sure..  But the packages it installs can introduce conflicts trying to build stuff off hackage later.  It's often debatable whether it's worth it to use or not.
12:47:35 <vikaton> I need to learn the language itself first
12:47:44 <Gurkenglas> http://pastebin.com/ETP73A9J
12:47:47 <prsteele> vikaton: what OS? If Ubuntu, just apt-get install ghc works fine for me
12:47:49 <Gurkenglas> (michealt)
12:47:54 <vikaton> I'm learning haskell for knowledge, not anything practical atm
12:48:01 <vikaton> prsteele: windows :(
12:48:09 <c_wraith> vikaton: on windows, I'd suggest minghc
12:48:18 <albeit> napping: Okay. So if there will be little contention, and I have no need for dup, will an IORef likely be more peformant?
12:48:20 <c_wraith> vikaton: https://github.com/fpco/minghc
12:48:21 <vikaton> then ehats haskell platform for?
12:48:25 <vikaton> whats*
12:48:30 <michaelt> Gurkenglas: i'm puzzled why the earlier 'stack' thing said "4.7.0.2 found"
12:48:46 <napping> albeit: I think it can be, but there are cheaper queues that sequence if you don't need to access the middle
12:48:47 <albeit> napping: I'm using them for mainly single (rarely multiple) writer, single reader, in different threads.
12:49:04 <albeit> napping: Nope, only need front, back, and length! Any recommendations?
12:49:07 <michaelt> Gurkenglas: you probably should run ghc-pkg recache as it says, thought I"m not sure how that works
12:49:08 <c_wraith> vikaton: it's in a pretty wobbly position at the moment.  It's hard to define what it's supposed to do better than using ghc + cabal.
12:49:09 <napping> also, getting the reader to actually block might take some trouble
12:49:21 <bollu1> two data structures can't have the same field? o_O
12:49:25 <fishythefish> vikaton: FWIW, I installed Haskell Platform on my Windows box and it seems to be doing okay.
12:49:31 <vikaton> Ok cool
12:49:31 <napping> if you don't need worst-case bounds, the simple swapping queue should be okay
12:49:33 <fishythefish> But I usually code in my Linux environment, so YMMV.
12:49:37 <vikaton> installer just finished
12:49:50 <Gurkenglas> michealt, http://pastebin.com/vW4Bc8ah
12:50:02 <albeit> napping: I need it as predictable and consistent as possible, so the swapping queue (I'm guessing the one with two lists?) isn't great.
12:50:14 <bollu1> help guys? error at bottom - http://codepad.org/coPORlr1
12:50:23 <albeit> napping: By getting the read to block, do you mean that it may just spinlock/busy-wait?
12:50:40 <bollu1> I'm not able to create an array field on both the Store and the Question
12:50:54 <bollu1> is this not allowed?
12:50:54 <napping> if you just have an IORef to a possibly-empty structure you can't do anything else
12:50:56 <michaelt> Gurkenglas: did you do 'ghc-pkg recache'  ?  or can you do that within stack , however this works
12:51:00 <Jello_Raptor> I'm looking for a good way to make a Graph definition EDSL in haskell. Something that looks like http://hastebin.com/uyucifebuw.hs maybe. Are there any similar DSLs? things I should look into? generally usefull concepts (I'm still working on getting my head wrapped around how free monads work with monadic assignment.) 
12:51:07 <Jello_Raptor> ?
12:51:09 <Jello_Raptor> thanks
12:51:33 <rien> is lens-aeson recommended over aeson-lens?
12:51:42 <sm> vikaton, c_wraith: there's also the brand new https://www.fpcomplete.com/blog/2015/06/announcing-first-public-beta-stack
12:51:43 <kadoban> buoto: Yes, it's not allowed. They both create an 'array' function.
12:51:44 <albeit> napping: Ah okay, that's actually okay, almost preferable.
12:51:45 <napping> of course you can start pairing it with some other kind of lock
12:51:49 <geekosaur> bollu1, no, you can't reuse the name
12:52:00 <bollu1> geekosaur: how do libraries work then?
12:52:01 <geekosaur> because it creates an accessor function (e.g. array myStore)
12:52:07 <Gurkenglas> michealt, afterwards: 
12:52:11 <Gurkenglas> http://pastebin.com/V6R65Qzs
12:52:13 <napping> albeit: there are some worst-case queues
12:52:14 <bollu1> like, how do you guarentee that two libraries don't have structs with the same name
12:52:19 <bollu1> and.. what's the solution in this case?
12:52:28 <geekosaur> different modules let you use qualified names
12:52:35 <kadoban> bollu1: It's different when they're in different modules. You can use the same name in separate modules.
12:52:39 <bollu1> ahh, right
12:52:41 <prsteele> bollu1: modules. You have define array in A.hs and B.hs, and reference via A.array and B.array
12:52:42 <kadoban> bollu1: Change the name of one of them?
12:52:49 <geekosaur> and, well, this is a known pain point but the solutions are difficult
12:52:49 <bollu1> kadoban: bummer :(
12:53:14 <geekosaur> someone else here just mentioned a library called lens, which grew out of one of the possible solutions
12:53:24 <kadoban> bollu1: Yeah, it's a fairly annoying part of record syntax unfortunately.
12:53:33 <Gurkenglas> michealt, ghc-pkg without stack stuff still says I need to recache. Trying that yields http://pastebin.com/p2gYFpEN
12:53:35 <supki> rien: yes
12:53:43 <geekosaur> for a simpler version see the fclabels package: http://hackage.haskell.org/package/fclabels
12:53:57 <rien> supki: thank you. 
12:54:03 <albeit> napping: Any recommendations or examples?
12:55:02 <michaelt> Gurkenglas: this stack thing is over my head, but did you try building your package with the changed cabal file?
12:55:49 <Gurkenglas> Never built with cabal yet
12:55:53 <rien> supki: would you know anything about how lenses can help me fetch an arbitrarily deep collection of leafs in a JSON given a path to it? I'm curious as to which lens combinators would help me with that.
12:56:00 <michaelt> Gurkenglas: if you want to see all the libraries you have installed do "ghc-pkg list"; stack will presumably see the same global packages and it's own local ones with stack exe ghc-pkg list
12:56:25 <Gurkenglas> michealt, nope, they're different
12:57:03 <napping> albeit: not really, I doubt it's that important. You might check out unagi-chan
12:57:13 <Gurkenglas> michealt, http://pastebin.com/2drtLaPz
12:57:26 <albeit> napping: Actually on that package docs page right now, looks perfect. Thanks!
12:57:29 <c_wraith> rien: probably deep from Control.Lens.Plated. if you use the lens-aeson package, it gives you a Plated instance for Value
12:57:30 <edwardk> rien: you want something like [Either Int Text] -- with the left being the index into an array and the rights being the keys in a map?
12:57:38 <edwardk> as a key to get a lens out?
12:57:50 <c_wraith> Oh, wait.  You know the path.  Not deep, then
12:57:56 <edwardk> :t nth
12:57:57 <lambdabot> Not in scope: â€˜nthâ€™
12:58:06 <napping> TQueue is the simple amortized O(1) TVar ([a] [a]) thingy
12:58:46 <Gurkenglas> michealt, http://pastebin.com/arHj4eWz
12:59:12 <michaelt> Gurkenglas: if you type ghc --version is it ghc-7.8.4
12:59:36 <edwardk> rien: foldr (\a r -> either nth key . r) id xs -- will build a traversal of a path 'xs :: [Either Int Text]' using lens and lens-aeson
12:59:38 <rien> c_wraith: hmm yes I have read that Plated might be it...
12:59:58 <edwardk> where the lefts are array indices and the rights are fields in an object
12:59:59 <rien> edwardk: given the menu JSON example from http://json.org/example, I want to say "menu.popup.menuitem*.value" and get ["New","Open","Close"] back
13:00:04 <Gurkenglas> michealt, no: http://pastebin.com/sWdQx96j
13:00:40 <edwardk> :t (...)
13:00:41 <lambdabot> (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
13:00:46 <michaelt> Gurkenglas: uncomment line 18 of the cabal file  -- main-is:            and write main-is: Main.hs -- or whatever the name of your program is.
13:00:59 <Gurkenglas> (Surely there must be a way to assign a hotkey to "paste clipboard to a pastebin and place the link in clipboard")
13:01:08 <edwardk> rien: key "menu" . key "popup" . key "menuitem" ... key "value"
13:01:22 <hexagoxel> are there `cabal.config`s for the platform releases somewhere?
13:01:36 <edwardk> rien: would be the code equivalent. write something that converts your text into that form
13:01:50 <michaelt> Gurkenglas: on os x I have " alias sprunge="pbpaste | curl -F 'sprunge=<-' http://sprunge.us" " in my .profile 
13:02:10 <edwardk> the foldr i gave above would do everything except for the * which needs to become (...)
13:02:13 <c_wraith> edwardk: oh man.  I missed the existence of (...) several times.
13:02:19 <rien> edwardk: sure that would be no problem. I'm surprised though (being a noob at lenses), so you're saying just the straightforward way will fetch me deeply nested arrays if my path happens to cross array boundaries?
13:02:20 <c_wraith> edwardk: that's handy
13:02:21 <edwardk> :t (...)
13:02:22 <lambdabot> (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
13:02:44 <c_wraith> Nicely evocative name, too
13:02:49 <edwardk> c_wraith: thanks =)
13:02:58 <michaelt> Gurkenglas: thus http://sprunge.us/KiLB
13:03:22 <edwardk> rien: i was assuming you'd manually index arrays along the way
13:03:29 <edwardk> foo[10].bar.baz..quux
13:03:41 <rien> ah no, I need all of them 
13:03:46 <edwardk> key "foo" . nth 10 . key "bar" . key "baz" ... key "quux"
13:03:58 <edwardk> rien: then use ...'s to join instead of .'s
13:04:11 <rien> edwardk: the point of this is to recode some "XSLT for JSON" code I have in Ruby
13:04:25 <edwardk> the above works then
13:04:46 <edwardk> . means direct descendant, ... means to search
13:04:49 <rien> cool, so (...) is my ticket. you don't think I need help from Plated?
13:04:55 <edwardk> ... uses plated =)
13:05:03 <Gurkenglas> michealt, that cabal file modification resulted in http://pastebin.com/AkeXcW2H . Apparently stack is missing some packages. Wasn't it supposed to install them automatically?
13:05:15 <rien> beautiful. thanks again! I will try it and ask more questions when I have something to show.
13:05:18 <edwardk> it basically uses plated to recurse unless the right hand side matches
13:05:36 <edwardk> it was a fun little intellectual exercise to write it
13:06:00 <edwardk> and it was designed very much for folks who wanted xslt / xpath style queries
13:06:23 <rien> edwardk: I can imagine. you've basically already coded the hardest part of a json "XSLT" inside that magical (...)
13:06:28 <johnw> edwardk: what is the performance like?
13:06:31 <rien> ah there you go then
13:06:32 <michaelt> Gurkenglas: yes you need to specify more packages in the cabal file add juicy-pixels, array after base > whatever 
13:06:35 <mniip> any idea why in http://lpaste.net/134355 demote works as expected, while promote only returns Nothing
13:06:37 <edwardk> johnw: never checked
13:06:41 <johnw> k
13:06:47 <edwardk> johnw: nobody's complained or offered up a faster implementation
13:06:56 <Gurkenglas> I see. Damn you stack for not taking this work from me
13:07:31 <edwardk> ... works nicely on syntax trees too
13:07:57 <johnw> edwardk: that's very handy
13:08:00 <michaelt> Gurkenglas: it will seem obvious with a little more experience. though I don't know all about stack
13:09:02 <rien> edwardk: have you read this critique of Lenses? https://ro-che.info/articles/2014-04-24-lens-unidiomatic
13:09:20 <Sindriava> What's the difference between "ghc file" and "ghc --make file" ?
13:09:22 <edwardk> rien: sure
13:09:24 <rien> edwardk: I'd be curious what you think of it. as a beginner I just think I don't know enough to understand the type signatures
13:09:33 <rien> and I'm also not aware of the level of expertise of that critic
13:09:42 <edwardk> he's welcome to his opinion. i just happen to disagree with roman on lots of things
13:09:50 <edwardk> not just lenses but across a pretty wide spectrum
13:09:57 <geekosaur> Sindriava, none these days
13:10:02 <Sindriava> Thanks!
13:10:03 <ion> â€œBackwards composition of lensesâ€ â€“ do fmap and traverse compose backwards?
13:10:13 <edwardk> he's been around for a long time, and there is a kernel of truth i think to his critique. lens isn't "haskelly" in a classic sense, it deliberately doesn't try to be.
13:10:33 <edwardk> and the main question i have is "so what?" does it help people write better code?
13:10:39 <rien> edwardk: do you see, though, "two" approaches to libraries, one as he defends having clear signatures, and Lenses as having less clear signatures? or do you think he thinks the signatueres for Lenses are less clear due to inexperience with them/
13:10:43 <geekosaur> back around ghc 6.6, you had to compile each source file separately (or list them all in the ghc command line) and also include -package lines for every package you used
13:10:50 <geekosaur> or use --make and ghc figured it out itself
13:10:59 <geekosaur> these days --make is default and ignored for backward compatibility
13:11:19 <bollu1> I know it is a lot to ask, but could someone review the code for me? I'm a haskell noob and I'm trying to learn. The question I'm trying to solve is listed at the top
13:11:19 <ion> TIL
13:11:19 <bollu1> http://codepad.org/iNlmWdId
13:11:27 <bollu1> unfortunately, this is still not fast enough :| 
13:11:32 <maerwald> edwardk: I've tried to avoid lens most of the time, but I am confused by such critique, because I'd expect an alternative solution, but afaik there is none, is there?
13:11:36 <bollu1> but.. I'd like some coding practice guidelines first
13:11:37 <edwardk> rien: lens is designed more or less as an experiment. is it possible to make a library where all the parts work together for deep fundamental reasons, where i don't have to 'hide' the implementation details, and where by exposing them just a little in the types like i do, i can make it so the same combinators work in many many more situations  than you'd
13:11:37 <edwardk> expect
13:11:45 <rien> maerwald: ditto
13:11:52 <edwardk> you could write a crappy version of lens that used concrete types for Lens, Traversal, etc.
13:12:04 <Sindriava> geekosaur: That's neat! Thanks ^^ Coming from C, this feels like magic :D
13:12:10 <edwardk> but the problem with such an approach is that they don't magically downgrade, etc. you have to then hand-convert everything
13:12:33 <edwardk> this DRASTICALLY increases the syntactic noise, and we have combinators that automatically work with 20 different types are you going to write 20 different instances for each combinator?
13:12:39 <rien> edwardk: and then everything becomes as verbose as the code that Lenses was designed to avoid, I see what you're saying
13:12:40 <srhb> bollu1: I see foldr (+) -- do you really mean to do this?
13:12:40 <johnw> edwardk: I don't agree with him on this either.  "In Haskell, types provide a pretty good explanation of what a function does. Good luck deciphering lens types."  So, because he doesn't know the types well enough to read means they don't explain what the function does?  That's like saying a Russian newspaper has nothing to say if I don't happen to speak Russian.
13:12:55 <chpatrick> edwardk: I only have an aesthetic problem with lens and that's with the operators
13:13:04 <edwardk> by the time your'e done you get a library that doesn't do anything that lens does and which wouldn't have any of the extra concepts that lens was able to introduce because you pay for each and every point on the lattice for every feature you add
13:13:06 <albeit> In unagi-chan, if I call tryReadChan, and then tryRead on the returned Element, will the final result be Nothing when the queue is empty?
13:13:08 <rien> johnw: that's basically what I'm asking
13:13:27 <edwardk> chpatrick: you don't have to use them Control.Lens.Combinators exports 0 operators. Control.Lens.Operators exports the operators. Control.Lens re-exports both
13:13:30 <napping> albeit: no idea, I just looked for concurrent queue implementations on hackage
13:13:37 <chpatrick> most haskell only has a few operators that are used very widely so they're easy to rememember
13:13:39 <napping> albeit: are you sure you have a performance issue here?
13:13:39 <webchat099> haskell is a language with getters and setters WOW
13:13:56 <edwardk> rien: lens was designed because i'd written and used data-lens for several years and found that it was unsable
13:13:57 <chpatrick> I know the lens ones are super general but personally I find hieroglyphs hard to memorize
13:14:16 <chpatrick> it's ok if I have to remember <> once for any Monoid but with lens there are quite a few
13:14:17 <johnw> rien: I read the article as saying he hasn't invested the time to really learn lens, and doesn't want to; a rant like this is usually self-justification to remain uneducated
13:14:18 <edwardk> chpatrick: most of the operators are c++ operators in disguise +=, etc.
13:14:24 <ion> Lens operator naming follows a pattern.
13:14:28 <edwardk> foo += 12
13:14:28 <srhb> bollu1: Also you appear to be referring to lists as arrays. They are not, and they do not have O(1) indexing (they are linked lists)
13:14:38 <srhb> bollu1: So if you are doing lots of indexing, this is bound to be extremely costly.
13:14:39 <edwardk> uses a lens foo to edit the current state and add twelve to that part of it
13:14:46 <rien> johnw: yes I'm very aware of how people deal with cognitive dissonance including shaming in order to protect the ego :) that's why I asked
13:14:57 <albeit> napping: Yes... I'm using a TChan right now, and am seeing delays of tens of microseconds at times. (Delay being between when the thread is waiting and when it reads a value)
13:14:58 <edwardk> +~ -- looks a little funny, because its 'not quite +=' and its a functional version.
13:14:59 <rien> johnw: as a newbie I prefer to think I just don't know enough yet. 
13:15:09 <johnw> lenses are mostly breath-takingly elegant, and the types are very communicative, but you have to put in the time and change your thinking in some ways.  You *really* have to get comfortable with functors and their implications.
13:15:12 <edwardk> most of the others are there for the sake of completeness
13:15:12 <srhb> bollu1: In general it looks a lot like you've tried to transform an imperative approach into Haskell, without taking account for Haskell being -- well, Haskell. :)
13:15:19 <albeit> napping: (On a dedicated core)
13:15:40 <johnw> as for the operators thing, don't use them if you don't like them, but they are a language to be learned like any other
13:15:51 <michaelt> mniip: try this instead http://lpaste.net/raw/134358 unsafeCoerce is rightly so called, of course
13:15:53 <Gurkenglas> michealt, http://pastebin.com/U4acaz8G leads to http://pastebin.com/2vUCna50
13:16:01 <srhb> bollu1: (This was just me skimming, but perhaps you can use those pieces of advice for something)
13:16:01 <rien> edwardk: what sort of incentive would you need to talk for hours about all the highly interesting CT background you pragmatically use in writing your libraries?
13:16:02 <chpatrick> johnw: sure but you can say that about any language
13:16:09 <johnw> chpatrick: and I would say that about any language :)
13:16:16 <chpatrick> ok, x86 machine code?
13:16:21 <chpatrick> yeah man it's just 0x58
13:16:40 <rien> edwardk: I'd love to understand what you mean when you talk about lattices etc. I think you can see almost visually the problems or inconveniences with each tradeoff when selecting an approach for a library
13:16:41 <chpatrick> you could memorize the opcodes but that doesn't mean it's good
13:16:41 <johnw> anything you master can be used to fluidly express the thoughts appropriate to that language; fail to master it, and it will seem impenetrable and confusing
13:16:50 <edwardk> rien: i'm usually willing to talk if someone flies me to the destination or if i'm going to be in the area anyways
13:17:01 <maerwald> johnw: "elegant" is really the last reason I use haskell... I've never understood what people find in that. I want things understandable, efficient, abstract. Elegant is rarely all those 3 things at the same time
13:17:16 <mniip> michaelt, I'm looking for correspondence with types from another packages though
13:17:17 <michaelt> Gurkenglas: try     JuicyPixels > 3.2,
13:17:20 <rien> edwardk: are you ever in NYC?
13:17:29 <webchat099> lens is too much for too little
13:17:29 <chpatrick> johnw: my problem isn't that lens is complicated, just that hieroglyphs aren't easy to remember
13:17:31 <johnw> maerwald: to mean "elegant" in this context means peering through the fog of syntax to behold the System F constructions underneath that all Haskell expressions will reduce to
13:17:38 <edwardk> rien: a lot of that comes from just throwing a lot of code at a wall and trying to see what abstractions work and don't. and i tend to favor the more mathematical ones because they have withstood a lot of beating from a lot of users with disparate needs
13:17:41 <chpatrick> like I think this is a disaster: http://www.flotsam.nl/dispatch-periodic-table.html
13:17:51 <michaelt> mniip: yeah, I figured. It was seeming to me that it is becuase Nothing precedes Just (the informative constructor) in the standard implementation 
13:17:52 <maerwald> johnw: yet I'm unable to understand the API, so I don't use it
13:17:55 <chpatrick> you shouldn't need a periodic table to make an HTTP request
13:17:59 <Gurkenglas> No change. Would have been surprised, it says the noparse is at line 20
13:17:59 <johnw> chpatrick: that's an argument of familiarity, which I can either always win or lose :)
13:18:05 <Gurkenglas> *michealt
13:18:25 <michaelt> mniip: which is to say, it's awfully fragile ... but I don't know much of anything about unsafeCoerce
13:18:27 <edwardk> webchat099: the reason i wound up with the design lens has is that what happened with data-lens is i'd write code and need something that was just a _little_ outside of what data-lens could say and i'd have to stop scrap all the code i'd written for the last 3 days and replace it. so why bother writing it with lenses if i was going to have to scrap it
13:18:27 <edwardk> anyways?
13:18:37 <webchat099> lens is the most over-hyped thing. most newbie programmers believe that haskell is about lens and little more
13:18:38 <edwardk> with lens i don't find myself 'falling out of the range of applicability'
13:18:43 <napping> albeit: sounds reasonable, though I don't much benchmark that carefully
13:18:51 <chpatrick> johnw: but again just because you COULD memorize every x86 opcode doesn't mean that it's a nice way to code
13:18:57 <edwardk> you're welcome to not use it, but it has been very useful to me when it comes to improving my productivity
13:19:03 <srhb> webchat099: We're interested in abstractions and it shows when we've just been given a new one
13:19:06 <johnw> maerwald: that's fair, and maybe lens loses out on more users because of its sheer density; but that same density pays off if you take the time, and edwardk often creates libraries for those of us willing to pay the time
13:19:11 <chpatrick> johnw: not that lens operators are nearly as cryptic but you see what I mean
13:19:11 <edwardk> webchat099: i do have to admit that 'haskell being about lenses' seems to be a very strange worldview
13:19:14 <maerwald> johnw: or lets put it this way: I've never felt the need to really understand it... because there were always easier alternatives for a specific problem I had. I never reached the threshold
13:19:15 <srhb> webchat099: A few months before lens it was conduits, pipes and the other streaming IO tools
13:19:27 <rien> edwardk: I like the points you make. this will be a challenge but I will do my best to understand lenses. do you offer consulting/office hours? 
13:19:27 <edwardk> srhb: true nuff
13:19:50 <srhb> webchat099: It's sad that some newbies take this away from the current state of "this is interesting in Haskell" but you can hardly blame Haskell or Haskellers for being interested in their language and the tools at their disposal.
13:19:52 <edwardk> rien: we have a #haskell-lens channel with 150-200 people in it at all hours who are very helpful with lens questions
13:19:59 <michaelt> Gurkenglas: oh wait     bed-and-breakfast-0.4, is not well formed     bed-and-breakfast > 0.0,   or whatever
13:20:00 <johnw> maerwald: that's perfectly understandable, and I'm OK with you using other ways to express ideas that potentially could have been expressed in another way :)
13:20:01 <edwardk> even if i'm away someone there can answer questions
13:20:10 <srhb> The alternative, I think, is stagnation.
13:20:15 <ion> rien: Have you watched SPJâ€™s lens intro talk and edwardkâ€™s lens talk?
13:20:15 <srhb> Which truly is boring.
13:20:18 <rien> edwardk: man I really need the full list of #haskell- channels. thanks for that!
13:20:18 <johnw> lens is a tool, it's not a required solution to any specific problem
13:20:26 <maerwald> johnw: so I think you really need a very complex problem that sucks to solve with alternatives... which... sort of makes lens a very specialised library, not a general-purpose one (although it technically is one)
13:20:38 <rien> ion: I've watched Kmett's talk several times but not SPJ's yet, will do
13:20:56 <Welkin> rien: https://wiki.haskell.org/IRC_channel#Related_channels
13:21:01 <johnw> maerwald: or, you just need the desire to pay the time and master lens, after which you'll see it is just as well suited to simple problem as complex ones, and that's not as mystical as it once appeared
13:21:08 <rien> johnw: except the specific problem of writing XSLT for JSON :)
13:21:12 <rien> johnw: (my problem)
13:21:22 <Gurkenglas> Whoopsies, just copied the title there.
13:21:42 <maerwald> johnw: I prefer to solve my problems efficiently... and as long as alternatives help me with that I don't think I will invest time in more complex approaches
13:21:52 <rien> Welkin++
13:21:59 <johnw> maerwald: ok
13:22:04 <bollu> sorry all, ubuntu crashed
13:22:13 <srhb> bollu: Check the logs, I answered you.
13:22:14 <bollu> could someone help me refactor my code here: http://lpaste.net/134359
13:22:18 <maerwald> johnw: that said... I'm not working on complex data structures...
13:22:21 <Welkin> rien: you can also ask lambdabot for the channels it is in
13:22:22 <bollu> srhb: how do I do that?
13:22:25 <Welkin> @seen lambdabot 
13:22:25 <bollu> where are the logs stored?
13:22:25 <lambdabot> |4/\/\bD4B0t
13:22:29 <maerwald> maybe if I do, I will need it
13:22:34 <bollu> IRC is stateless, right?
13:22:39 <Welkin> @seen lambdabot
13:22:39 <lambdabot> 1A/\/\bDab0T
13:22:39 <ion> bollu: Please see the topic. It has links.
13:22:50 <bollu> ohh, thank you!
13:22:52 <Welkin> what's wrong with lambdabot?
13:23:00 <johnw> maerwald: lens has other uses than just complex structures
13:23:06 <edwardk> maerwald: my major uses of lenses is to reduce the amount of code i need to write to deal with crud state in my application
13:23:06 <rien> Welkin: that makes sense. I used to hang out here some years ago and I knew some lambdabot tricks. I have to relearn them now :)
13:23:27 <Gurkenglas> Progress! New and interesting failures. http://pastebin.com/36u461dy Why doesn't stack know https://hackage.haskell.org/package/bed-and-breakfast ?
13:23:27 <Welkin> @seen edwardk 
13:23:27 <lambdabot> ED\/\/arDK
13:23:30 <Welkin> wow
13:23:34 <johnw> say you had a type Foo a b, and you wanted to do traversals (ala Traversable) on the 'a' parameter instead of the 'b' parameter.  Without lens, yuck; with lens, yay.
13:23:42 <Welkin> someone messed with lambdabot so that @seen no longer works
13:23:48 <ion> Welkin: 0) Instead of suggesting a nearby command in the error message, it just executes a nearby command. 1) The seen plugin leaked memory and was disabled for now.
13:23:51 <srhb> bollu: http://ircbrowse.net/browse/haskell?events_page=595574&q= -- from that page and look for my comments
13:23:57 <maerwald> johnw: I think the point is... most people don't really get why it benefits them, because most of the time you can solve things "less elegantly"
13:24:01 <Welkin> ion: wow, I just used it the other day too
13:24:03 <srhb> bollu: And a few pages after that.
13:24:04 <bollu> srhb:  thanks a ton!
13:24:12 <johnw> maerwald: people say the very same thing about Haskell :)
13:24:25 <maerwald> johnw: and I don't use haskell because of its elegance, again
13:24:59 <edwardk> maerwald: you can write everything you can in lens-aeson using 'aeson' alone. it just takes 6 times as many lines and you can't reuse that vocabulary for your next non-aeson problem.
13:25:05 <Welkin> @leet leet
13:25:05 <lambdabot> LE37
13:25:11 <Welkin> @leet lambdabot 
13:25:11 <lambdabot> 1A/\/\Bdab0t
13:25:11 <edwardk> lens doesn't purport to give you anything 'new', just something compositional.
13:25:11 <michaelt> Gurkenglas: its not on https://www.stackage.org/lts-2.13 is that the relevant list?
13:25:13 <Welkin> I see
13:25:26 <ion> @@ @leet @hoogle monad
13:25:27 <lambdabot>  P4CkA9e monAd-4bORt-fD Paxx49E /\/\ONAd-4Tom PacK4GE mon4d-a+OM-Si/\/\plE
13:25:49 <Welkin> so @@ is lambdabot composition?
13:26:17 <ion> @help @
13:26:18 <lambdabot>  @@ [args].
13:26:18 <lambdabot>  @@ executes plugin invocations in its arguments, parentheses can be used.
13:26:18 <lambdabot>  The commands are right associative.
13:26:18 <lambdabot>  For example:    @@ @pl @undo code
13:26:18 <lambdabot>  is the same as: @@ (@pl (@undo code))
13:26:19 <bollu> srhb: yeah, you're fair in saying that I'm haskell naive
13:26:23 <johnw> some people think lens is a cloud of types and operators, but really it's another way to see certain classes of problems; when you try to express that vision in code, it generates a bunch of types and operators.  So, the key is to capture that vision.
13:26:25 <edwardk> functor gives a Setter, foldable gives a Fold, traversable gives a Traversal, lenses are getter/setter pairs, functions give you getters, etc. the difference is that given one of these things you can't 'naturally' compose it with any of the others. you have to write one off code for dealing with each sort of thing. lens smooths over that and makes them all
13:26:25 <edwardk> look the same for the operations you want to do
13:26:30 <bollu> and someone had told me that haskell lists aren't cheap, I'd forgottent hat
13:26:32 <bollu> tha
13:26:33 <bollu> that*
13:26:34 <srhb> bollu: Sorry, I probably came off a bit harsh. That was not my intention. :(
13:26:40 <bollu> no, I understand :)
13:26:46 <bollu> so, well, what's the "right" way to do this?
13:26:49 <edwardk> then once we have them all in the same 'vocabulary' we can spot common operations that work on this whole lattice of concepts
13:26:57 <webchat099> maerwald: No. the point is that people think that they are programming elegantly because they use lens for their low level code, when construct solutions in haskell that are more like OOP and do not use the haskell abstractions to program their solutions in a category-theoretical wat
13:27:03 <webchat099> way
13:27:09 <srhb> bollu: First off, if you fold with an operator that's strict in its right hand argument, you almost always (well, always, I think) want foldl'
13:27:09 <hexagoxel> why the "Â§$% doesn't the haskell platform website mention what library versions are part of each platform? how are library maintainers supposed to ensure compatibility?
13:27:10 <johnw> bollu: lists are not *necessarily* expensive, until you write code that forcing them to actually be constructed in memory
13:27:12 <Gurkenglas> michealt, looks like :I. But why would it only use those and not provide a command for installing things? Or does it? http://pastebin.com/p5GFuxAv looks like it doesn't
13:27:15 <srhb> bollu: See the wiki for why
13:27:21 <bollu> srhb: oh, okay
13:27:34 <hexagoxel> or am i blind?
13:27:41 <edwardk> webchat099: "category-theoretical wat" works in its own way ;)
13:27:49 <michaelt> bollu: readQuestion = Question <$> readT <*> readTAttr  
13:28:01 <srhb> bollu: As for the indexing... Can you summarize what you're doing? I only had time for a brief skim and it looked like you were doing a lot of it, in which case you're traversing lists, possibly needlessly.
13:28:09 * hackagebot multiset-comb 0.2.4 - Combinatorial algorithms over multisets  http://hackage.haskell.org/package/multiset-comb-0.2.4 (BrentYorgey)
13:28:12 <srhb> bollu: indexing on lists is almost always a smell.
13:28:15 <webchat099> IÂ´m not elegant because I program a Web application with lens.  IÂ´m elegant whe I find a category-theoretical way to express web applications
13:28:22 <johnw> maerwald: and don't get me wrong, lens -- like any other powerful tool -- can be abused.  Take any Haskell feature and there is an abuse of it on the Net somewhere.  But these misuses should not indicate that we need dumber tools.
13:28:24 <ion> Haskell lists arenâ€™t that expensive compared to linked lists in other languages, are they?
13:28:29 <srhb> No, not really.
13:28:45 <srhb> It's not lists vs. linked lists, but lists vs. structures that are good at indexing operations.
13:28:51 <maerwald> edwardk: to me it seems like a trade-off between abstraction and understandibility, and I am pretty sure it's awesome work and I might use it one day... but really only if I feel like having major penalties by not having that abstraction
13:28:55 <bollu> srhb: I need to basically check if sum of elements to the left of any element equals the sum of elements to the right of any element (skipping that particular element) 
13:28:55 <maerwald> and that day has yet to come
13:29:00 <johnw> ion: it depends on whether they get fused away or not; if not, then they are the same expense
13:29:19 <srhb> bollu: So just splitting around an element? that's not too bad for lists at all.
13:29:23 <arkeet> rien: /msg alis list #haskell*
13:29:24 <arkeet> :-)
13:29:31 <bollu> srhb: yeah. But, I tried to "optimize" it
13:29:40 <bollu> by having the initial state
13:29:46 <arkeet> fun, -lens is the 3rd largest one.
13:30:08 <bollu> and then adding to the left_sum and deleting from the right_sum as I move from left to right (i.e, as index increases)
13:30:13 <johnw> maerwald: there's only one problem with that argument: until you've learned it well enough to know when to use it, you might not see the benefit of the abstraction.  Like edwardk said, he often can write the same thing in smaller code, but the real payoff is now being able to reuse that code in places he otherwise wouldn't have been able to
13:30:32 <bollu> intuitively, I sort of have a "cursor" that knows my current state. So for the next state, I need to do one addition to the left, and one subtraction to the right
13:30:33 <bollu> ideally
13:30:37 <maerwald> edwardk: e.g. the diagrams lib also has lens support... once I used that part of it, but it didn't really give me opportunities for my code. So I switched to the more "boring" functions 
13:30:40 <bollu> and a little overhead for member access
13:30:46 <johnw> lenses compose different flavors of data access in surprising ways
13:30:48 <arkeet> I think he was saying lens gives him smaller code.
13:30:50 <bollu> but.. I'm clearly not in imperiative-land anymore :)
13:31:21 <srhb> bollu: Sounds like it might be suited for zippers something
13:31:24 <maerwald> edwardk: maybe I am missing some fundamental use cases, I don't know
13:31:29 <heisenbug> edwardk: already seen http://cs.colgate.edu/~phil/SpivakFMCS2015.pdf ?
13:31:37 <napping> bollu: if you just keep a reference to the tail of the list rather than indexing with !! you should get a decent speedup
13:32:03 <bollu> napping: hm, will try
13:32:13 <bollu> srhb: what are zippers? shiny new concept? :)
13:32:20 <napping> it will go from a quadratic to a linear time algorithm
13:32:23 <srhb> bollu: A zipper is more or less something like Zipper [a] a [a]
13:32:24 <edwardk> heisenbug: yep
13:32:29 <webchat099> probably the people that program in a data-centric way so that he need Lens are programming haskell the wrong way. using an OOP approach
13:32:30 <napping> still probably slower than working over an array, but more decent
13:32:33 <srhb> bollu So you have your cursor on an element and a list left and right of that
13:32:46 <bollu> srhb: correct
13:32:53 <edwardk> heisenbug: i'll be posting some operad/multicategory code pretty soon. i have a working repo github.com/ekmett/multicategories which has some nice bits and pieces
13:32:54 <bollu> ahh
13:32:56 <srhb> bollu: Well, that's what a zipper models. :-)
13:33:01 <napping> oh, are you recomputing the sum too?
13:33:05 <edwardk> and i'm working it into github.com/ekmett/categories as a revised version of the library
13:33:09 * hackagebot lens-simple 0.1.0.5 - simplified import of elementary lens-family combinators  http://hackage.haskell.org/package/lens-simple-0.1.0.5 (MichaelThompson)
13:33:15 <bollu> napping: no, just adding one element and subtracting one element
13:33:27 <edwardk> webchat099: honestly, most of my applications that use lens are to talk about a little bit of configuration or the like
13:33:27 <webchat099> that wrong OOP programming in Haskell is the reason why newbies coming from other languages like Lens
13:33:28 <michaelt> spamming hackage as usual ^^^ 
13:33:48 <bollu> Also, question: since my function is of the type Store -> (Bool, Store), is it an instance of the State monad?
13:34:05 <srhb> webchat099: I think that's a completely ridiculous claim.
13:34:16 <arkeet> Store -> (Bool,Store) is State Store Bool
13:34:16 <ion> @type state
13:34:16 <srhb> And even if it were the case, it wouldn't be bad.
13:34:19 <heisenbug> edwardk: cool, I see you already moved some stuff into â€šcategoriesâ€™
13:34:19 <mniip> bollu, only the State monad is the State monad
13:34:20 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
13:34:21 <bollu> I've never used State. I know it exists and have read about it, but I never grokked it
13:34:23 <rien> arkeet: thanks ;)
13:34:29 <ion> bollu: You can use that function to make a State action out of such a function.
13:34:29 <arkeet> so that is State
13:34:29 <edwardk> the fact that the json/xml/html world seems to love them because they can continue to mash up their semistructured data was almost a happy accident. we looked at aeson-lens which had no laws and said 'hey, what are the prisms/lenses/traversals you really need to work with this?' and wrote them down and didn't think about it. and it just happened to be an
13:34:30 <edwardk> incredibly concise way to process this stuff
13:34:37 <arkeet> there's no monad there yet though.
13:34:55 <bollu> ion: hm, so, well, is there any benifit of using that here?
13:34:56 <mniip> bollu, you can wrap it in 'State' and you get a monad back
13:34:58 <bollu> benefit*
13:35:13 <edwardk> heisenbug: its slowly moving over, the more general form i'm hacking on in categories has some problems when it comes to building the (indexed) monad associated with a multicategory and i haven't found a way to make it pretty, correct and fast at the same time
13:35:19 <edwardk> when i do i'll ship it
13:35:24 <ion> mniip: s/monad/monadic value or action/
13:35:38 <ion> bollu: Sorry, i havenâ€™t read the code in question.
13:35:46 <bollu> ion: all right
13:35:48 <kyubiko> Is there any way of not exiting at the end of main?
13:35:52 <arkeet> bollu: if you start trying to compose these things and thread your Store through
13:35:56 <srhb> kyubiko: Yes, call something else
13:35:56 <kyubiko> Some kind of way of just looping or something?
13:35:57 <bollu> srhb: do you know if the State monad could help here?
13:36:02 <srhb> kyubiko: main
13:36:05 <arkeet> then that's where the State monad would come in.
13:36:05 <bollu> arkeet: what do you mean by "thread the Store"
13:36:18 <srhb> bollu: I think others are addressing that question. :)
13:36:18 <michaelt> kyubiko: main = putChar 'y' >> main
13:36:30 <ion> Or equivalently: main = forever (putChar 'y')
13:36:38 <bollu> srhb: sure :) arkeet: what does it mean to thread the Store?
13:36:44 <Somelauw> So I have read about monads and I think I sort of understand it. So if Maybe and IO are both Monads and Maybe can be unboxed by doing Just a = Just 5, then I think that doing IO a = putStrLn "hello world" would have to output "hello world".
13:36:46 <johnw> maerwald: an example of a handy use of lens:
13:36:48 <johnw> > M.fromList [(1,Right (3, 4))] & at 1 . _Just . _Right . _1 .~ 5
13:36:49 <Somelauw> Because do unboxes values
13:36:49 <lambdabot>  fromList [(1,Right (5,4))]
13:36:59 <srhb> Somelauw: You cannot generally unbox any value
13:37:01 <arkeet> Somelauw: no.
13:37:02 <Somelauw> And do can be with putStrLn to print something
13:37:04 <arkeet> bollu: I mean
13:37:06 <srhb> Somelauw: And it has nothing to do with their being a monad
13:37:06 <merijn> Somelauw: do does not unbox values
13:37:10 <johnw> it says, at key 1 *if it exists*, and if the member is a Right value and not Left, then update the first  element of its tuple
13:37:12 <arkeet> you have some Store -> (a,Store)
13:37:18 <bollu> arkeet: right
13:37:21 <arkeet> you give it a Store and get some new Store out.
13:37:25 <johnw> that's about 6 lines of Haskell done the standard way
13:37:28 <arkeet> now you feed that to something else that looks like Store -> (b,Store)
13:37:30 <srhb> Somelauw: values in Maybe can be unboxed because we can nicely pattern match on them. Not because Maybe is a monad.
13:37:31 <Somelauw> but do a<- Just 5, assign a = 5
13:37:36 <arkeet> which may depend on the a
13:37:39 <srhb> Somelauw: Do you know what that's syntax sugar for?
13:37:39 <edwardk> at 1 . _Just = ix 1  -- gives you a more general pattern ;)
13:37:46 <merijn> Let me try again: Anyone know of a concurrent map like data structure? I need the ability to query/register keys and GC values cheaply. TVar/MVar with Map inside has too much contention :\
13:37:46 <bollu> ohh
13:37:46 <johnw> edwardk: thank you
13:37:54 <bollu> arkeet: but a and b are types, not values
13:37:57 <arkeet> yes.
13:38:00 <bollu> so why would one type depend on the other?
13:38:03 <maerwald> johnw: I have never written such a construct in real world code. When I see such things, I think there must be some misdesign behind the data structure concept
13:38:14 <arkeet> I mean the second thing might depend on the value of type `a` that you get out of the first thing.
13:38:17 <arkeet> it might not.
13:38:19 <johnw> maerwald: I've written such code often, to manipulate nested structures
13:38:20 <ion> Somelauw: putStrLn "don't" and putStrLn "panic" are both opaque values of type IO () which can be executed by the runtime system; do { putStrLn "don't"; putStrLn "panic" } combines them into a new value of type IO () which can also be executed.
13:38:20 <srhb> Somelauw: Just 5 >>= \a -> ... -- you're applying the function on the right hand side of >>= to 5. That does not mean it has been unboxed.
13:38:47 <bollu> hmm
13:38:48 <srhb> Somelauw: In fact the type promises that you return something of type Maybe a on the right hand side.
13:38:49 <maerwald> johnw: I avoid subtyping and nested structures... but I don't write complex libraries, so...
13:38:52 <srhb> :t (>>=)
13:38:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:38:58 <johnw> prisms add "logic" to your accessors in composable ways
13:39:10 <johnw> maerwald: well, you also said you didn't use Haskell
13:39:13 <michaelt> maerwald: but why why not write complex nested structures if you have lenses and prisms etc
13:39:16 <maerwald> johnw: uh?
13:39:22 <johnw> or was that not you?
13:39:25 <arkeet> bollu: so, thinking of the Store as your "state", the State monad gives you a convenient way to perform computations that may use/modify the state.
13:39:31 <bollu> ah
13:39:32 <arkeet> well, to compose them.
13:39:34 <maerwald> michaelt: because I like to keep things simple
13:39:35 <srhb> Somelauw: In other words, monads provide no escape hatch.
13:39:39 <bollu> while actually being immutable
13:39:39 <johnw> oh, you don't use it because of its elegance
13:39:47 <arkeet> sure, it's all functions underneath.
13:39:49 <Somelauw> ion: I didn't understand 'opaque values'
13:39:51 <maerwald> johnw: maybe my english was bad...
13:40:00 <arkeet> it just captures that idea of some mutable state.
13:40:00 <michaelt> maerwald: but it keeps things simpler if they are nested, since you can separately develop the subordinate fields
13:40:22 <Somelauw> srhb: okay, so is there a way to do putStrLn with >>= ?
13:40:24 <srhb> Somelauw: There is no "value" in an IO a that you can somehow unbox.
13:40:27 <arkeet> :t (>=>)
13:40:28 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:40:30 <bollu> that is cool
13:40:35 <bollu> hm
13:40:35 <johnw> so, some of the key aspects of lens that are the first reason I usually reach for it: manipulating maps, JSON, State values, and using prisms to compose logic into your manipulators
13:40:40 <maerwald> michaelt: I cannot follow
13:40:42 <srhb> Somelauw: Sure, putStrLn "foo" >>= \useless -> putStrLn "bar"
13:40:46 <ion> Somelauw: You can ignore the word â€œopaqueâ€ here. I just meant that you canâ€™t do much to inspect an IO T value, you can just combine them and have them executed by binding one to â€œmainâ€.
13:40:54 <srhb> Somelauw: Note that useless will be ()
13:40:56 <johnw> I use it less often for its "original" feature, record accessors
13:41:03 <arkeet> bollu: the monad structure basically gives you two things.
13:41:12 <srhb> @quote /bin/ls
13:41:12 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:41:18 <johnw> oh, and traversals over any type variables
13:41:18 <srhb> ^^^--- Somelauw 
13:41:19 <arkeet> return gives you a -> Store -> (a,Store) in kind of a trivial way.
13:41:26 <edwardk> maerwald: i like to keep things simple too. i just happen to write compilers and things. and they get messy fast =)
13:41:27 <arkeet> take a value and a Store, and return that value with the same Store.
13:41:33 <arkeet> :t (>>=)
13:41:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:41:37 <aweinstock> :info IO
13:41:47 <merijn> aweinstock: lambdabot has no info command
13:41:51 <aweinstock> ah
13:41:53 <arkeet> given Store -> (a,Store) and a -> Store -> (b,Store)
13:41:54 <edwardk> maerwald: you wind up with big chunks of configuration for how you're dealing with warnings, your environment, whatever global symbols you've got, etc.
13:41:57 <aweinstock> does it have an equivalent?
13:42:04 <bollu> hmm
13:42:12 <Somelauw> sorry, you can type faster than I can read.
13:42:15 <arkeet> it gives you a Store -> (b,Store) that just
13:42:17 <bollu> wait, question
13:42:24 <bollu> aren't the arities wrong?
13:42:30 <johnw> edwardk: the way that lens has been integrated into pipes is pretty cool too
13:42:31 <maerwald> edwardk: that's probably an excellent use case, I guess
13:42:31 <arkeet> takes the store, feeds it through the first thing, takes the resulting a and new Store and feeds it into the second thing.
13:42:34 <arkeet> bollu: hm?
13:42:34 <bollu> like, doesn't state need *two* types?
13:42:38 <bollu> but monad only needs one
13:42:48 <johnw> (or I should say, the pipes ecosystem)
13:42:49 <merijn> bollu: State is not a monad "State s" is
13:42:49 <arkeet> State s a = s -> (a,s)
13:42:50 <ion> instance Monad (State s)
13:42:54 <arkeet> it's "State s" that's the monad.
13:42:58 <edwardk> johnw: i wasn't expecting that one
13:43:02 <bollu> merijn: you can partially apply types? :O
13:43:03 <srhb> bollu: We call them kinds, by the way. Ie. arities of type constructors
13:43:03 <bollu> what the hell
13:43:08 <arkeet> data types yeah.
13:43:10 * hackagebot species 0.3.3 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.3 (BrentYorgey)
13:43:13 <ion> State :: * -> * -> *; State s :: * -> *; State s a :: *; a Monad instance needs to be * -> *
13:43:13 <merijn> bollu: sure
13:43:25 <bollu> that is awesome but nuts
13:43:28 <arkeet> :-)
13:43:28 <srhb> :-)
13:43:35 <srhb> Words that warm our hearts.
13:43:45 <bollu> okay, until now, for me, this has been equivalent to templates to me. This is something templates can't do
13:43:48 <merijn> @define data Foo f = Foo (f Int)
13:43:49 <lambdabot>  Defined.
13:43:57 <merijn> :k Foo
13:43:58 <lambdabot> (* -> *) -> *
13:44:04 <merijn> :k Foo (Either Bool)
13:44:04 <lambdabot> *
13:44:15 <bollu> merijn: lost me there
13:44:17 <Somelauw> okay, thanks
13:44:21 <johnw> edwardk: the ability for something to be that useful in expected quarters is one proof of a good abstraction
13:44:25 <johnw> unexpected*
13:44:27 <merijn> > Foo (Left True) :: Foo (Either Bool)
13:44:28 <lambdabot>      No instance for (Show (Foo (Either Bool)))
13:44:28 <lambdabot>        arising from a use of â€˜show_M172954136081650882716992â€™
13:44:28 <lambdabot>      In the expression:
13:44:29 <bollu> (* -> *) would be what, a kind function?
13:44:34 <merijn> oh, no show
13:44:41 <srhb> bollu: A function from types to types
13:44:42 <napping> bollu: that's just a parameterized type
13:44:44 <ion> bollu: (* -> *) is a type-level function of a single parameter.
13:44:54 <bollu> ion: what's a concrete example of that? Maybe ?
13:44:55 <merijn> bollu: Well, "Foo" expect an argument of kind "* -> *", to which it will apply Int
13:44:56 <napping> like you have Maybe Int makde from Maybe
13:44:59 <bollu> whoaaa
13:44:59 <ion> bollu: Foo (Either Bool)
13:45:01 <srhb> :k Maybe
13:45:02 <lambdabot> * -> *
13:45:05 <bollu> no frikkin way
13:45:06 <srhb> :k Maybe Int
13:45:06 <ion> bollu: Oh, sorry. Either Bool :: * -> *
13:45:07 <lambdabot> *
13:45:07 <merijn> bollu: "So "Foo Maybe" contains a "Maybe Int"
13:45:23 <ion> bollu: Foo :: (* -> *) -> *; Foo (Either Bool) :: *
13:45:30 <bollu> so, like, you can capture "partially applied" type constructors?
13:45:31 <johnw> edwardk: but the argument that "I don't need it to get things done, I don't see the need for it, therefore how can it be needful?" is one I've seen echoed in nearly every corner of computing
13:45:31 <merijn> bollu: But "Foo (Either Bool)" ends up containing "(Either Bool) Int", i.e. "Either Bool Int"
13:45:37 <merijn> bollu: yeah
13:45:37 <srhb> bollu: Yep.
13:45:42 <bollu> o_o
13:45:44 <napping> that's not actually something C++ templates can't do
13:45:50 <bollu> napping: hm?
13:45:54 <napping> if you start messing around with template template parameters
13:45:58 <bollu> napping: what?
13:45:59 <merijn> bollu: Yeah, templates can do this
13:46:00 <edwardk> johnw: i'm not out to save everyone. i just want to write code. if they use it, great! more eyeballs. if they don't i have more than enough to keep me busy without holding hands =)
13:46:07 <merijn> bollu: You can template templates in C++
13:46:13 <bollu> oh, god, like template<template<T>> ?
13:46:23 <bollu> tpename*
13:46:24 <merijn> bollu: Yeah, slightly different syntax, but yes
13:46:25 <srhb> bollu: It's ugly, not wrong!
13:46:35 <napping> well, there's some way to declare that parameters of the template are templates themselves, and use them in the body
13:46:39 <hpc> that should be the other perl motto
13:46:42 <srhb> It's just very convenient here.
13:46:43 <bollu> TIL
13:46:44 <srhb> hpc: haha.
13:46:51 <merijn> bollu: I have this C++ code somewhere "template<template<size_t,size_t> class F, size_t multiplier>"
13:46:53 <johnw> edwardk: you only need to communicate enough of the beauty so we converts may defend it on your behalf :)
13:47:12 <merijn> bollu: i.e. it takes a "template<size_t,size_t>" as argument
13:47:14 <bollu> hmm
13:47:29 <bollu> so, map<size_t, size_t> would be a valid thing to pass to that?
13:47:36 <merijn> bollu: Yes
13:47:44 <bollu> merijn: awesome
13:47:48 <bollu> merijn: but.. anyway
13:47:50 <merijn> well, "map" would be a valid argument
13:47:54 <bollu> so, (State s) is a monad
13:47:55 <edwardk> johnw: now i just need to sell the world multicategories
13:48:07 <bollu> since we partially apply "State"
13:48:08 <johnw> edwardk: what got you started with that?
13:48:16 <bollu> so it needs one more type to be "concrete"
13:48:22 <merijn> bollu: Values can only have types of kind *, but we can pass around partially applied types as easily
13:48:26 <bollu> :t (>>=)
13:48:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:48:29 <srhb> bollu: Not "concrete" -- concrete.
13:48:35 <johnw> edwardk: I need to make a Boston trip so I can hear the good word
13:48:36 <srhb> bollu: (That is actually what we call it.)
13:48:36 <edwardk> i had a small application of them when talking about the internals of how the exact real arithmetic code i was working on could be expressed more elegantly
13:48:36 <merijn> bollu: I dislike the term "concrete", because it's ill defined
13:48:43 <merijn> srhb: No we don't >.<
13:48:45 <bollu> so, that would become...
13:48:45 <bollu> State s a -> (a -> State s b) State s b?
13:48:46 <srhb> merijn: Battle to the death!
13:48:48 <merijn> srhb: People should stop that :p
13:48:52 <edwardk> you should come out and give a talk at boston haskell next week or something =P
13:48:53 <bollu> merijn: how so?
13:49:05 <merijn> bollu: To be more precise, there's two unambiguous things and people can never describe which concrete means
13:49:07 <johnw> merijn: mix water and certain types of crushed stone, wait
13:49:11 <bollu> hm, so my _state_ type doesn't change. Just the output does
13:49:19 <merijn> bollu: There are types of kind *, i.e. fully applied
13:49:19 <napping> bollu: you can only have values of types of kind * (ignoring some details about unboxed types)
13:49:24 <napping> like, 1 :: Int, and Just 
13:49:28 <merijn> bollu: And there's polymorphic vs monomorphic
13:49:37 <merijn> bollu: For example, is "Maybe a" a concrete type?
13:49:40 <bollu> no
13:49:42 <merijn> It has kind *, but is polymorphic
13:49:44 <napping> Just 'x' :: Maybe Char, and even Just :: a -> Maybe a (which has kind *)
13:49:56 <bollu> hmm
13:50:00 <bollu> merijn: 
13:50:02 <napping> but there is no value that has just type type "maybe"
13:50:19 <srhb> I think you're mixing kind and type level needlessly here.
13:50:20 <merijn> "Maybe" <- type of kind "* -> *", "Maybe a" <- polymorphic type of kind *, "Maybe Int" <- monomorphic type of kind *
13:50:20 <bollu> napping: I see. Because it needs one more type to be instantiated
13:50:29 <napping> er, Maybe rather. Just like you can't have a field in C++ whose type is an unapplied template
13:50:35 <bollu> ohh. Maybe a woks for _any_ a
13:50:38 <bollu> hence polymorphic
13:50:40 <merijn> bollu: Right
13:50:43 <merijn> :t Nothing
13:50:43 <lambdabot> Maybe a
13:50:54 <napping> :k (a -> Maybe a)
13:50:55 <bollu> :t Nothing :: Maybe Int
13:50:55 <lambdabot> Not in scope: type variable â€˜aâ€™
13:50:55 <lambdabot> Not in scope: type variable â€˜aâ€™
13:50:56 <lambdabot> Maybe Int
13:51:09 <merijn> bollu: Which is why I find "concrete type" a confusing term, I prefer explicitly specifying kind * and monomorphic/polymorphic
13:51:18 <bollu> hm
13:51:26 <srhb> (and I used concrete to mean kind *)
13:51:30 <bollu> how do mono versus polymorphic types even matter?
13:51:35 <ion> :k forall a. a -> Maybe a
13:51:36 <lambdabot> *
13:51:39 <bollu> in the end, everything becomes "concrete"
13:51:45 <merijn> bollu: Ah, no
13:52:00 <johnw> merijn: how about "has at least one inhabitant"?
13:52:02 <merijn> bollu: Note that while templates end up specialising for every "concrete" type being passed in, haskell does not
13:52:10 <bollu> merijn: example?..
13:52:15 <srhb> Now you're misusing concrete. :(
13:52:17 <merijn> johnw: But "Maybe a" fits that, and people disagree that it's concrete or not
13:52:24 <johnw> oh, right
13:52:26 <merijn> bollu: There is only one 'id' function
13:52:27 <johnw> good catch
13:52:33 <bollu> :t id
13:52:34 <lambdabot> a -> a
13:52:41 <bollu> there *can't* be right?
13:52:43 <merijn> bollu: It doesn't generate a different code path for all possible types, there is just one code path in binaries
13:52:46 <bollu> it's.. like, for every a
13:52:49 <merijn> bollu: Why not?
13:52:55 <bollu> hm
13:53:00 <johnw> maybe, has at least one inhabitant that is not a final object
13:53:10 <ion> bollu: Seeing a type like â€œ[a] -> [a]â€ tells you a lot about what the function can and cannot do. It can return the empty list, or it can return a truncated or shuffled version of the input, but it can not inspect the values within the list.
13:53:11 <johnw> though that rules out () which is clearly concrete
13:53:14 <bollu> because, well, first of all, the way you push stuff on your stack on assembly would change based on the types?
13:53:18 <merijn> bollu: Haskell values are boxed (i.e., pointers to values, instead of direct values) which means all values are the same size and you can generate generic code that works on any value
13:53:25 <merijn> bollu: Haskell doesn't have a call stack
13:53:29 <bollu> like, if I had an int, I would try and optimize it by pushing it into registers
13:53:32 <bollu> merijn: wat
13:53:36 <srhb> bollu: :D
13:53:36 <merijn> bollu: But even if it did, due to boxing it would work
13:53:44 <srhb> bollu: If we keep going, will your mind explode?
13:53:48 <bollu> srhb: yes
13:53:55 <merijn> bollu: C++ never uses boxing, so all values have different sizes and you need different code for those
13:53:59 <bollu> how the hell do you write a compiler without a _call stack_ ?
13:54:05 <napping> bollu: that's mostly handled by inlining in the compiler - the library version just takes heap-allocated objects
13:54:17 <merijn> Haskell, just like for example Java uses boxed values and all boxes are the same size which means you can share code
13:54:24 <bollu> no, but, if A calls B calls C, how do you know where to return to?
13:54:26 <napping> a particular call that just takes integers can optimize down to nice code
13:54:34 <bollu> merijn: hmm
13:54:43 <merijn> bollu: The bonus is that functions like 'id' work, EVEN for values that were nonexistent when id was compiled!
13:54:49 <mniip> bollu, polymorphic functions might be specialized and unboxed to work on register-fitting ints
13:54:52 <merijn> bollu: Whereas templates need to be recompiled
13:54:59 <mniip> but that is an optimization that is completely hidden from an average user
13:55:05 <bollu> merijn: hmm
13:55:06 <merijn> bollu: Haskell functions don't return either ;) Should I keep blowing your mind? :p
13:55:08 <bollu> merijn: that seems crazy
13:55:16 <bollu> merijn: *sigh* go on
13:55:24 <merijn> bollu: If you are vaguely familiar with assembler/C and compilers there's a great paper on this
13:55:25 <bollu> wait, lemme take a guess
13:55:27 <napping> well, some places temporarily use a stack
13:55:28 <bollu> coroutiunes?
13:55:35 <bollu> or something of that sort?
13:55:41 <bollu> merijn: mildly familiar
13:55:44 <mniip> bollu, haskell functions are basically aliases
13:55:46 <napping> just lazy evaluation, and overwriting a thunk
13:55:50 <merijn> bollu: All calls are tail calls, so they're just jumps
13:56:07 <bollu> merijn: what if I write a function that can't be TCO?
13:56:08 <jrslepak> merijn: which paper is that?
13:56:13 <srhb> bollu: It's not TCO.
13:56:14 <merijn> bollu: You can't
13:56:15 <mniip> bollu, how would you do that
13:56:24 <merijn> bollu, jrslepak: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
13:56:27 <bollu> mniip: tail calls are purely syntactic
13:56:28 <napping> merijn: GHC does use a stack for some things
13:56:45 <bollu> srhb: so, well, what is it in that case?
13:56:48 <merijn> bollu, jrslepak: That paper describes how to compile a minimal, lazy functional language to assembler/C
13:56:48 <mniip> GHC has a demand stack
13:56:50 <napping> so don't take it too far
13:56:52 <mniip> but not a call stack per se
13:56:54 <mniip> there are no call frames
13:56:57 <merijn> napping: It has a stack, but no CALL stack
13:57:17 <merijn> GHC has a pattern match stack, which means it behaves rather different than a call stack
13:57:24 <josephle> merijn, does Haskell compile into continuations?
13:57:25 <bollu> hmm
13:57:27 <mniip> [23:55:47] <bollu> mniip: tail calls are purely syntactic
13:57:31 <merijn> josephle: Effectively, yes
13:57:36 <mniip> come up with a function that is not tail-callable
13:57:38 <merijn> josephle: Core is basically CPS
13:57:43 <napping> bollu: with lazy evaluation, usually the result you return can be just wrapping an unevaluated expression into a thunk
13:57:47 <merijn> josephle: Therefore every function is a tail call
13:58:15 <merijn> bollu: If you know the term Continuation Passing Style, haskell's intermediate language basically forces all functions to be in CPS form, which means all calls are always tail calls
13:58:27 <merijn> bollu: Or no calls are tail calls, depending on your point of view... :p
13:58:29 <josephle> merijn: if it's CPS, couldn't you still simulate a stack trace by adding metadata to the next continuation?
13:58:39 <bollu> merijn: nope, do not know what that it
13:58:54 <lingxiao> hey all
13:59:03 <mniip> bollu, what was your original question again
13:59:04 <napping> merijn: CPS? https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
13:59:06 <lingxiao> I wonder if people can see what's wrong with tthiscode
13:59:07 <srhb> mniip: :D
13:59:08 <napping> that's not how it's described here
13:59:14 <merijn> bollu: If you google "continuation passing style" there should be some good intros, but it's not all that important
13:59:14 <bollu> mniip: f x y = x * f x y
13:59:20 <merijn> bollu: Although very interesting :)
13:59:36 <mniip> bollu, what about it
13:59:40 <lingxiao> https://gist.github.com/anonymous/136619080c9bb875259d
13:59:42 <bollu> not a tail call
13:59:45 <albeit> If I have a concurrent queue, and I want to be able to tell if its empty, does it make more sense to use an MVar (empty=empty queue) or an inc/decrementing IORef (0=empty queue)?
13:59:46 <bollu> has an additional operation
13:59:48 <merijn> napping: case-of is basically a continuation
14:00:00 <lingxiao> I am getting error: https://gist.github.com/anonymous/5454237aaf1edd515306
14:00:11 <merijn> napping: Every branch is a continuation to jump to with the variables of that pattern
14:00:14 <merijn> napping: Make sense?
14:00:18 <napping> there's a big difference between being able to define the continuation of an expression, and working explicitly in continuation-passing style
14:00:25 <lingxiao> the error message is a little crypitc
14:00:34 <merijn> napping: I did say "basically" CPS
14:00:42 <bollu> I'm losing track of the discussion now
14:00:44 <mniip> bollu, f is a thunk, that when evaluated, applies * to a thunk with x, and a thunk with f x y
14:01:15 <merijn> bollu: Let's rewind and start with "what did you want to know" before we accidentally try to teach you to implement haskell from scratch ;)
14:01:21 <mniip> ^
14:01:22 <srhb> NOOOO WE MUST
14:01:24 <srhb> :P
14:01:28 <srhb> We need more compilers!
14:01:51 <mniip> who hasn't implemented a haskell compiler in lisp, and a lisp compiler in haskell is not a rela programmer
14:01:57 <merijn> If anyway wants to write more compilers, I have a bachelor/master project available to do that. I can only pay you in ECTS, though :p
14:02:03 <srhb> I have yet to do the haskell from lisp one.
14:02:10 <merijn> s/anyway/anyone
14:02:15 <srhb> merijn: Damn you and your useless currencies! :-(
14:02:21 <mniip> merijn, me! me!
14:02:22 <srhb> The problem is too many ECTS, not too few.
14:02:30 <merijn> srhb: If I had money I'd pay myself to do it
14:02:41 <srhb> I know, I know... :P
14:02:49 <maerwald> merijn: what's the workload?
14:03:07 <mmaruseacph2> @remember < mniip> who hasn't implemented a haskell compiler in lisp, and a lisp compiler in haskell is not a real programmer
14:03:07 <lambdabot> It is forever etched in my memory.
14:03:12 <earthy> I want to write more compilers. :)
14:03:21 <earthy> but I'll do it on my own time, thanks. :)
14:03:24 <maerwald> merijn: here we have like ~3 months for a thesis
14:03:41 <merijn> maerwald: I think bachelor projects are supposed to be 18 ECTS, master's 48 ECTS, but tbh, I wouldn't even know how (bureaucracy wise) anyone outside NL could do a project here
14:03:57 <bollu> I've been trying to write my own compiler using LLVM
14:04:00 <maerwald> merijn: I really forgot what ECTS means, but I saw it once :P
14:04:03 <bollu> this looks super interesting
14:04:07 <bollu> I'm interested in implementing this now
14:04:10 <bollu> but.. anway
14:04:12 <merijn> maerwald: European course credits
14:04:13 <earthy> merijn: that's easy. 'exchange student' 
14:04:17 <merijn> maerwald: 6 ECTS is 1 month
14:04:23 <srhb> Wow.
14:04:30 <maerwald> ah
14:04:32 <merijn> bollu: There's two tutorials for doing that
14:04:47 <merijn> bollu: One for implementing an imperative language and one for implementing a haskell-like language
14:04:51 <maerwald> merijn: is it suitable for a haskell beginner?
14:04:58 <merijn> bollu: http://www.stephendiehl.com/llvm/
14:05:14 <bollu> merijn: http://github.com/bollu/cpp-achilles
14:05:16 <maerwald> (beginner = 1 year random toy projects experience)
14:05:22 <bollu> I've started writing code in C++ already :)
14:05:29 <merijn> And http://dev.stephendiehl.com/fun/
14:06:07 <felixn> https://gist.github.com/munro/925428957ecb51c2238a <-- I'm a bit confused by parallelism in haskell, is it on by default?  fib runs the same speed as fibPar, maybe that's because of the overhead of parallelizing small functions?
14:06:16 <mniip> [00:04:36] <maerwald> (beginner = 1 year random toy projects experience)
14:06:19 <mniip> sounds just like me
14:06:31 <merijn> maerwald: Those tutorials? probably
14:06:38 <merijn> Writing a compiler is easy-peasy in haskell
14:06:42 <maerwald> merijn: tutorial?
14:06:42 <mniip> except I've had some compilation- and jit-related toy projects in other languages
14:06:52 <maerwald> merijn: ok
14:07:08 <jrslepak> josephle: pretty sure you could use continuation marks for that if you want
14:07:09 <merijn> maerwald: The ones I linked, if you meant the project I had in mind, that's more work on knowing type theory (not so much haskell)
14:07:40 <merijn> maerwald: Functional language in general and ocaml/haskell in particular are probably THE easiest languages to get started in for hacking compilers
14:07:50 <koala_man> felixn: no, I don't think so. you have to add flags both at compile time and run time
14:07:57 <mniip> merijn, is there anything to type theory that haskell doesn't cover?
14:08:10 <felixn> koala_man: the top comment shows what I use to run it, I added -threaded & +RTS +N4
14:08:23 <hpc> how are you compiling?
14:08:27 <hpc> oh
14:08:27 <merijn> mniip: There's a difference between knowing what haskell works and how to implement it :)
14:08:30 <koala_man> felixn: I don't see any comments
14:08:35 <felixn> ah flip
14:08:37 <merijn> mniip: i.e. implementing type inference, recursive types, etc. :p
14:08:43 <mniip> true
14:08:46 <merijn> mniip: Also yes
14:08:55 <merijn> haskell covers only a miniscule portion of type theory
14:09:04 <merijn> i.e. the corner that is System F_omega (roughly)
14:09:13 <felixn> koala_man: ok added, I'm just trying to understand it, so maybe I'll just let this rest until I actually need to optimize something :D
14:09:23 <c_wraith> Wasn't System F_omega invented specifically to formalize the feature set haskell has?
14:09:41 <merijn> c_wraith: Naah, System F_omega is on the lambdacube
14:09:49 <mniip> well, not sure about the fancy symbols used to signify type systems, but type inference with polymorphism but without RankNTypes is rather simple
14:09:50 <merijn> c_wraith: Haskell's thingy has a few more things afaik
14:09:55 <dmj`> bitemyapp: ping !
14:10:09 <merijn> mniip: Dependent types, linear types, uniqueness types...
14:10:15 <mniip> okay okay okay
14:10:20 <merijn> mniip: row typing, structural subtyping :)
14:10:27 <merijn> Objects and subclassing in general ;)
14:10:33 <josephle> merijn: and some less things, I think F_omega has basic Dependent Kinds
14:10:39 <merijn> @where tapl
14:10:39 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
14:10:44 <mniip> oh! a familiar word!
14:10:46 <merijn> That's the goto reference :)
14:10:46 <mniip> objects
14:10:49 <maerwald> xD
14:11:03 <napping> felixn: did the rts options actually work? You may need to compile with -rtsopts too
14:11:05 <GLM> Has anyone been to strangeloop or ICFP?
14:11:25 <srhb> A lot of people here have been to ICFP at least.
14:11:35 <merijn> mniip: If you've got the money or a university library nearby I can recommend it. It starts with basic untyped lambda calculus then extends it with other types, recursion, recursive types, exceptions, subtyping, etc.
14:11:35 <lingxiao> does anyone here have ghc 7.10.1
14:11:41 <srhb> lingxiao: Yep
14:11:54 <merijn> mniip: Including how to prove correctness and implement a working checker/inferer
14:12:01 <napping> felixn: check the user's guide, I think the default setting prevents you from passing that option
14:12:15 <mniip> merijn, :(
14:12:22 * mniip 's got neither
14:12:37 <napping> felixn: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-smp.html
14:12:38 <merijn> mniip: Well, there's always the shady eye patchy parts of the internet :p
14:13:05 <felixn> napping: snap!  it's super fast now!  so, fib == fibPar, but fibSeq is now super slow
14:13:06 <mniip> merijn, shh we're on freenode
14:13:44 <koala_man> felixn: fyi.... fibSeq group runs fibPar and not fibSeq :P
14:14:17 <felixn> koala_man: good catch ... that's really weird then :D
14:15:22 <felixn> koala_man: napping: thanks for the help, I think I'm in the right direction now
14:15:44 <napping> Do you have marlow's book?
14:16:12 <MrWoohoo> Is there some simple solution for reading reddit pages and processing them in haskell? I want to play with analyzing and ways of rearranging them. I'm pretty lazy, I'm hoping I don't have to dive into the guts of xml (?) parsing... anyone know of anything?
14:16:12 <napping> http://chimera.labs.oreilly.com/books/1230000000929/
14:16:40 <felixn> napping: ah cool thanks, nice that it's free
14:16:47 <merijn> MrWoohoo: http-conduit for downloading, html-conduit for scraping html
14:16:55 <napping> is fib still lots faster than the pseq version?
14:17:06 <merijn> MrWoohoo: I just hacked together a massively parallel web scraper using those in like 2 hours :p
14:17:45 <bitemyapp> dmj`: wut
14:17:59 <felixn> napping: http://i.imgur.com/jTLoDSx.png <-- this is on the nanosecond scale, so I don't think it's going to be super accurate if things are running like I think
14:18:21 <koala_man> you shouldn't really be paralellizing anything that takes less than a millisecond
14:18:21 <napping> huh, that's funny
14:18:39 <MrWoohoo> LOL Don't need massive. I was just motivated by the whole kerfuffle on reddit about gathering some stats on what's really going on
14:18:58 <napping> you should be running it big enough to take some time, and try also setting a bound to switch over to the sequential version
14:19:04 <napping> fib won't do anything parallel
14:19:09 <napping> but maybe it optimizes better?
14:19:16 <felixn> koala_man: napping: yea, I just wanted to test what I read over on stack/haskell.org ... I think this book may have better examples to follow
14:20:04 <merijn> MrWoohoo: I didn't need that either, I was just scraping comics from a webpage, but it was so easy make it parallel using async that I did it anyway :p
14:21:44 <MrWoohoo> I've just been fascinated by the FPH thing. It's literally like a riot. The ban is a virtual order to disperse. I want to see if I can make a dataisbeautiful project from it
14:24:30 <mniip> merijn, %s'd, nice book
14:28:18 <felixn> merijn: cool, do you have the code up anywhere for your scraper?
14:28:24 <eacameron> I want to package a lib file (.a on Linux and .lib on Windows) inside a cabal package and link against it while building the haskell package. Is that a sane thing to do? Are there other examples of it? I cannot build the source code with Cabal because the build process is too complex
14:29:43 <eacameron> In other words, can cabal tell GHC to link against a C library that is packaged *with* cabal
14:33:19 <felixn> eacameron: perhaps have 2 cabal projects in your repo?
14:33:43 <eacameron> felixn: I'm not sure how that help?
14:34:28 <felixn> eacameron: package the c library in it's own project, then link that in the main project, I'm not an expert on this though :)
14:35:08 <eacameron> felixn: you mean add the lib as a data-file in a cabal file and just leave it at that, and then have another cabal package that depends on that one and links against the file?
14:36:16 <hexagoxel> eacameron: extra-source-file would be more appropriate than data-file i think
14:36:33 <eacameron> hexagoxel: Would cabal try to build it?
14:36:50 <MrWoohoo> um, where is the documentation on this page... the homepage is just a git repository... the readmes are not helpful. 
14:36:52 <MrWoohoo> https://hackage.haskell.org/package/html-conduit
14:37:09 <hexagoxel> and supporting more than one architecture/platform would be annoying with that approach
14:37:54 <eacameron> hexagoxel: yeah, that's why I asked my earlier question. I would have two different packages, one for win and one for unix. And then a wrapper package that conditionally depends on the right one
14:38:01 <eacameron> that way you aren't downloading libs you don't need
14:38:05 <hexagoxel> eacameron: nah, extra-source-files is not compiled
14:38:16 <hexagoxel> it is common to put e.g. readme.md in there
14:38:23 <eacameron> ah, interesting
14:38:37 <eacameron> I just need to figure out how to get GHC to link against it
14:39:27 <srhb> MrWoohoo: Very common in Haskell packages.
14:39:47 <felixn> eacameron: maybe related, I installed Console.Readline the other day, and I had to manually compile the readline C dependency ... so you're trying to incorporate that step into your package's build?  if you search github you may find someone doing what you want
14:39:54 <MrWoohoo> I added "tutorial" to the google search and got something :)
14:39:57 <MrWoohoo> thanks
14:40:01 <srhb> MrWoohoo: But really, all you need to do is read the conduit docs and go with the types
14:40:06 <eacameron> felixn: Yeah I'm trying to avoid that
14:40:06 <srhb> :)
14:40:21 <felixn> eacameron: it was annoying to manually compile readline, so I hope you figure it out!
14:40:48 <felixn> but yea, sounds like the status quo is just to make the programmer setup dependencies
14:40:56 <hexagoxel> eacameron: so you basically would need access to the extra-source-files of a dependency. never tried that, but i cannot say with certainty that it is not possible :p
14:42:00 <eacameron> hexagoxel: Well I could potentially make a tiny haskell source that links with it directly, and then from then on do the natural linking against haskell libs
14:42:07 <eacameron> I'm guessing the symbols would stay there
14:42:28 <MrWoohoo> srhb: no, haskell still hurts my poor old brain too much sometimes. 
14:42:43 <srhb> MrWoohoo: Oh that's fine. Brain hurt is good for you. :-)
14:42:44 <hexagoxel> eacameron: ah yes, that might work. no promises.
14:42:53 <srhb> MrWoohoo: But yes, more better docs would be great.
14:43:21 <eacameron> hexagoxel: yeah...sounds suspicious. GHC would have to think that C symbols are the same as Haskell ones
14:43:52 <MrWoohoo> I think haskell is a great language... I just hate how it feels like you need a graduate level degree in mathematics to follow the discussions in the community (and even basic documentation ;) )
14:44:26 <eacameron> MrWoohoo: It takes time to get past that; read anything by Gabriel Gonzales and it will help
14:44:31 <eacameron> he is on mission to bring haskell to all
14:44:34 <eacameron> as his blog says ;)
14:45:15 <MrWoohoo> haskellforall.com is his blog?
14:45:27 <eacameron> yeah
14:45:48 <MrWoohoo> i'll check it. thanks
14:46:48 <eacameron> MrWoohoo: His docs especially rock
14:47:11 <mada> MrWoohoo: #haskell-beginners is usually a great place for us non-math-degree-having people  (not that this is a wrong place though)
14:47:42 <MrWoohoo> I really liked that blog post that explained categories in terms of design patterns
14:47:54 <MrWoohoo> don't recall who wrote it
14:48:01 <eacameron> MrWoohoo: I think that was him
14:48:07 <albeit> If I do something like "foo <- unsafePerformIO f" at the top-level of a module, when is foo computed? When something imports that module? Or just when the program begins?
14:48:11 <MrWoohoo> LOL That was awesome
14:48:58 <quchen> albeit: Depends on the monad.
14:49:06 <albeit> quchen: IO
14:49:38 <quchen> So the type of f is IO (IO a)`
14:49:39 <quchen> ?
14:50:10 <MrWoohoo> are conduits something in standard haskell?
14:50:16 <albeit> quchen: Shoot, wrote that wrong. Meant "foo = unsafePerformIO f", f :: IO a
14:50:44 <quchen> That will be computed at the same time as foo would if there was anything else on the right hand side.
14:51:01 <quchen> foo = SOMETHING will evaluate foo as soon as it is required.
14:51:21 <quchen> foo = unsafePerformIO (putStrLn "hello") will print "hello" when foo is forced.
14:51:34 <albeit> quchen: Perfect, thanks. 
14:53:10 <arkeet> hard to say how many times f might be executed because inlining
14:53:20 <arkeet> if you only want it to happen once, use {-# NOINLINE foo #-}
14:54:09 <albeit> arkeet: Okay. This is more of a flag based on the environment the comptuer is on... probably a better way
14:54:35 <arkeet> mhm.
14:54:52 <arkeet> I guess it's not entirely uncommon to use unsafePerformIO for stuff like global readonly configuration
14:55:02 <arkeet> or using it with newIORef or whatever for global mutable variables
14:55:49 <monochrom> to a large extent, stdin, stdout, stderr, and randomRIO are possible because of unsafePerformIO
14:57:09 <monochrom> strangely, even Pascal tries to tell you that you have to write your main as "program(input, output)" as opposed to global stdin, stdout
14:58:24 <ion> instance Num Handle where { fromInteger 0 = stdin; fromInteger 1 = stdout; fromInteger 2 = stderr }
14:59:10 <monochrom> stdout+stdout = stderr and it is a prime number. this is an exciting time.
14:59:52 * geekosaur remembers when ms-dos 2 had stdaux and stdprn as well >.>
15:00:15 <monochrom> "unique prime factorization of Handles by the number field sieve"
15:00:45 <monochrom> "con:" and "nul:" still exist. haven't tried "prn:" though.
15:00:59 <geekosaur> I didn't mean the devices
15:01:08 <geekosaur> I mean their being auto-=opened as fds 3 and 4
15:01:21 <geekosaur> which I think went away in either dos 3 or 4
15:01:25 <ion> nice
15:01:41 <ion> stdnul, anyone?
15:01:57 <monochrom> true, I started with msdos 3. I probably don't know a lot about msdos 2.
15:02:21 <monochrom> but I know (knew) msdos 3 well enough to have written simple TSR's.
15:04:39 <geekosaur> I think they went away in 3 because every program having stdprn open meant the PRINT TSR had to keep an eye on a lot of unused handles
15:04:40 <monochrom> if there were a time machine that would let me go back in time and change things, what would I change? Answer: I would bring haskell back. I could no longer stand a world devoid of haskell.
15:06:40 <ion> Go to the future, grab a copy of Haskell, go to the past, give the future Haskell to the world, return to present time, enjoy.
15:06:59 <arbelos> So, recently I have been trying to put some more thought into code readability.. I have an example here 
15:07:11 <monochrom> actually, there is something fishy about "msdos 2 had auto-opened file descriptors 3 and 4". in fact, even "file descriptors 0, 1, and 2". this is because there were no file descriptor in msdos 2 at all, IIRC. it only had CP/M style file records.
15:07:11 <geekosaur> is that why 1.4 had monad comprehensions and sane do desugaring but 98 didn't? :p
15:07:30 <geekosaur> they were introduced in ms-dos 2
15:07:35 <geekosaur> ms-dos 1 only had CP/M style
15:07:39 <arbelos> I have a record data AppState { .. _listeners :: [Listener] }
15:07:53 <geekosaur> the old ms-dos 2 programmers manual was ... interesting
15:08:04 <monochrom> ok, I see
15:08:25 <prsteele> style question. Is it reasonable to do [a, b, c] >>= f and assume this is readable?
15:08:28 <arbelos> and this function: insertListener listener = over listeners (\ls -> listener : ls)
15:08:48 <arbelos> now, it is tempting to write insertListener listener = over listeners (listener :)
15:09:10 <prsteele> real question: there are many instances of Monad, how much should I document which (>>=) is being applied?
15:09:27 <monochrom> arbelos: I would use "over listeners (listener :)", yes.
15:09:46 <arbelos> monochrom, you wouldn't say that it is bad in terms of readability then
15:09:48 <Cale> prsteele: It should usually be obvious which (>>=) is in use if there's a top-level type signature around
15:09:50 <monochrom> unless you don't want the library dependency on lens
15:09:53 <arkeet> [a,b,c] >>= f is pretty readable to me.
15:10:04 <arkeet> and it's pretty obvious from the first argument that it's using the Monad instance for []
15:10:15 <geekosaur> there was a fair amount of hidden functionality in dos 2 that was intended for an eventual migration to Xenix (!) --- but by dos 3 Microsoft had decided to compete against unixlikes instead and much of it was quietly removed. file descriptors remained though
15:10:23 <Cale> prsteele: Or if you're using anything whose type is obvious, like arkeet's example there
15:10:48 <geekosaur> like if you put AVAILDEV=NO in CONFIG.SYS then it used unixlike device names (no CON: but instead \DEV\CON)
15:10:50 <prsteele> okay, thanks. I just started trying to really find the right abstractions to use, but I didn't want to go too far in the other direction
15:10:53 <arkeet> some people in that case might prefer a list comprehension [f x | x <- [a,b,c]]
15:11:21 <mniip> arkeet, that's not  what that code does
15:11:32 <arkeet> it's not?
15:11:36 <arkeet> er
15:11:37 <arkeet> oops.
15:11:41 <mniip> [r | x <- [a, b, c], r <- x]
15:11:45 <mniip> [r | x <- [a, b, c], r <- f x]
15:11:47 <arkeet> yeah.
15:11:48 <arkeet> that thing.
15:11:59 <prsteele> xs >>= f = concat (map f xs)
15:11:59 <ion> How was 1.4 do desugaring better?
15:12:19 <Cale> ion: heh, it's better in that it's what GHC actually does ;)
15:12:36 <mniip> I wonder where does the horizontal line notation of implication come from
15:12:43 <Cale> ion: But really, it's that it avoids the use of fail in cases where pattern matches can't fail.
15:12:52 <mniip> never seen it before I started reading stuff on non-untyped LC
15:13:02 <Cale> ion: (or mzero, rather)
15:13:42 <arkeet> mniip: sequent calculus?
15:13:50 <mniip> arkeet, ?
15:13:54 <arkeet> is that what you're talking about?
15:14:25 <Cale> ion: In 1.4, there was a distinction between failable and non-failable pattern matches, where essentially a pattern was failable if it contained a match against a constructor from a type with 2 or more data constructors, and the translation of the do-notation made use of this.
15:14:32 <simon> "Larger blocks are more likely to be orphaned meaning lost revenue for the miner who publishes a large block." - why?
15:14:37 <simon> whoops, wrong channel.
15:14:43 <mniip> I'm talking about \frac{A}{B} as alternative way of saying A => B
15:14:44 <ion> Cale: Okay. I have found failing pattern matches in do binds useful though (in the monads that will be instances of MonadFail).
15:14:45 <quchen> ion: "A failure free pattern is one that can only be refuted by âŠ¥." where failure free is either irrefutable, single-constructor, or x@(failure-free).
15:15:16 <Cale> ion: Sure... I really ought to look at what the proposal says...
15:15:33 <quchen> It says "get fail out of Monad" and then worries a bit about where to put it. :-)
15:16:11 <arkeet> mniip: where the horizontal line is inference? or (internal) logical implication?
15:16:12 <ion> Cale: Sorry, i misread what you said as it having had no fail-equivalent at all.
15:16:19 <arkeet> http://en.wikipedia.org/wiki/Sequent_calculus
15:16:30 * prsteele just realized scanl exists
15:16:37 <Cale> ion: Yeah, it used mzero (which was in its own MonadZero type class)
15:16:50 <prsteele> prefixSums = scanl1 (+), awesome
15:17:05 <Cale> ion: and the translation would only make use of mzero in the cases where the pattern match could actually fail
15:17:33 <mniip> arkeet, yeah logical implication
15:17:39 <arkeet> ok, no idea then.
15:17:43 <Cale> So for example, (u,v) <- x wouldn't translate to using mzero, while  Just u <- x  would
15:18:13 <ion> Cale: The MonadFail proposal behaves that way, too.
15:18:24 <Cale> Good :)
15:18:40 <Cale> I believe that GHC already does the translation correctly
15:19:05 <Cale> as in, what you'd want it to do, rather than what Haskell 98/2010 say is correct
15:19:47 <ion> Apart from fail being in the wrong class?
15:20:02 <Cale> Yeah
15:20:13 <quchen> Cale: Yes, GHC has a notion of "irrefutable" patterns, which stands for "unfailable". (An irrefutable-tilde-pattern is an example of this more general irrefutable pattern.)
15:20:14 <arbelos> monochrom, actually I think Lens could even improve readability in this case, by using "cons":  insertListener listener = over listeners (cons listener)
15:20:35 <arbelos> (listener :) could be confusing perhaps
15:20:38 <Cale> quchen: Well, irrefutable and unfailable are slightly different
15:20:45 <quchen> Other patterns GHC would call irrefutable would be "_", and "x" and so on.
15:20:55 <quchen> Cale: Sure, that's why the name in GHC is confusing ;-)
15:20:55 <Cale> iirc, (x,y) is refutable, but unfailable
15:21:33 <quchen> That's the code I'm referring to: https://github.com/ghc/ghc/blob/c5911479f295242e16e396eb5d1369f2e4ce8de0/compiler/hsSyn/HsPat.hs#L443
15:21:51 <edwardk> dolio gave me a pretty good explanation of irrefutable vs. unfailable when it came up last time
15:21:58 <edwardk> but i keep forgetting the distinctions
15:22:15 <dolio> Unfailable is irrefutable or refutable only by bottom.
15:22:31 <arbelos> maybe I am over thinking the readability aspect
15:22:32 <Denommus> ok, an efficient implementation of fibonacci with scanl is trivial
15:22:44 <dolio> At least for one-level patterns.
15:22:57 <Denommus> I didn't know about scanl
15:23:04 <dolio> For multi-level you need to iterate.
15:23:19 <Cale> > fix ((0:) . scanl (+) 1)
15:23:20 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:25:39 <codygman> How would I write `instance MArray IOUArray CInt IO`? I found the Int one: http://hackage.haskell.org/package/array-0.5.1.0/docs/src/Data-Array-IO-Internals.html#line-101 In `instance MArray IOUArray Int IO getBounds` what is the type of arr that is pattern matched on?
15:27:11 <Cale> newtype IOUArray i e = IOUArray (STUArray RealWorld i e)
15:27:11 <Cale>                        deriving Typeable
15:27:24 <ion> > map (chr . (+ ord 'a') . (`mod` 26)) (fix ((0:) . scanl (+) 1))
15:27:26 <lambdabot>  "abbcdfinvidloznmzlkvfaffkpzonbopdsvnivdybzazzyxvsnfsxpmbnobpqfvavvqlbmnzmlx...
15:27:57 <geekosaur> afaik you just use the same implementation as is shows for Int, Word, etc.
15:28:18 <geekosaur> assuming there's an Ix instance for CInt
15:28:35 <Cale> Wait, can you even write your own instances of MArray?
15:29:09 <Cale> Last time I checked, not enough of the methods of MArray were exposed that you could even write complete instances of it.
15:29:28 <codygman> Cale: I'm not sure, maybe not: http://ircbrowse.net/day/haskell/2010/05/15?id=9639527&timestamp=1273874933#t1273874933
15:29:48 <Cale> codygman: Given that you're storing CInts, you might want to use a StorableArray
15:30:01 <geekosaur> oh, CInt is Int32 and already has an instance
15:30:15 <Cale> Oh, what, really?
15:30:24 <merijn> No
15:30:28 <merijn> It depends on your platform
15:30:30 <Hafydd> data IOUArray i e = IOUArray
15:30:30 <Hafydd> putIOU :: IOUArray i e -> i -> e -> IOUArray i e
15:30:30 <Hafydd> putIOU a _ _ = a
15:30:30 <Hafydd> getIOU :: IOUArray i e -> i -> e
15:30:31 <Hafydd> getIOU _ _ = error "IOU one element"
15:30:39 <merijn> CInt is not the same across platforms
15:30:58 <codygman> Cale: Alright, I was just trying to get Frag to compile. I guess I can see how much work changing things to use StorableArray's will be.
15:31:09 <Cale> CInt is a newtype, not a type synonym, isn't it?
15:31:21 <Cale> codygman: Oh, uhhh...
15:31:25 <geekosaur> mr, right, I misread the :info
15:31:30 <geekosaur> newtype, so loses :/
15:31:32 <codygman> newtype CInt = CInt Int32
15:31:32 <merijn> Cale: Right
15:31:34 <Cale> codygman: What was the actual problem you ran into?
15:31:47 <merijn> GeneralizedNewtypeDeriving
15:32:31 <codygman> Cale: No instance for (MArray IOUArray GLint IO)
15:32:49 <Cale> hmm
15:33:06 <Cale> That's odd. I wouldn't have thought such an instance ever existed.
15:33:10 <codygman> type GLint = CInt
15:33:11 <codygman> used to be
15:33:13 <codygman> type GLint = Int
15:33:16 <Cale> aha
15:33:28 <Cale> Well, that's fun.
15:33:47 <geekosaur> right, there was a spate of errors and complaints when opengl package made that change
15:34:10 <geekosaur> not to mention the corresponding Double --> CDouble that led to a lot of complaining about slow conversions
15:34:17 <geekosaur> (realToFrac?)
15:34:22 <codygman> And I'm not sure what my options are. This is the first time I've done lower level Haskell/mutable arrays stuff :P It's fun.
15:34:31 <Cale> Yeah, realToFrac can be obscenely slow
15:34:43 <monochrom> for CInt, import Foreign.C.Types
15:35:06 <monochrom> oh, slow realToFrac, that can't be helped, but I wonder why
15:35:07 <Cale> monochrom: The problem isn't that it's not in scope, the problem is that there's no corresponding MArray instance, and we can't write one
15:35:28 <Taneb> There's no ix instance for CInt :(
15:35:34 <Cale> Well, I wonder if GNTD can write one.
15:35:42 <monochrom> is there a MVector unboxed instance or Storable instance? that may be good enough
15:35:49 <Cale> Or has that hole been fixed? :)
15:36:00 <Cale> Yeah, you could probably use StorableArray
15:36:18 <Cale> Though iirc, StorableArray performs less well than IOUArray in general
15:38:18 <codygman> Cale: I don't really care about it being performant tbh, I just want it to complile ;) So changing implementation to use StorableArray should work?
15:38:32 <codygman> compile*
15:38:43 <Cale> edwardk: There's something for the list of basic libraries things to get fixed. It would be nice to have a .Internals for being able to write MArray instances.
15:39:08 <Cale> codygman: I think so? If the Ix instance is missing you might run into another problem, but that one is easier to fix.
15:39:25 <monochrom> consider Data.Vector.Storable.Mutable.
15:39:52 <Cale> He's just trying to get frag to compile, so using vector would be a bigger change in terms of API
15:40:24 <monochrom> then is it easier to use an older OpenGL?
15:40:55 <codygman> monochrom: You are right, doing that might just be easier. I haven't tried to compile it with 7.8 yet.
15:50:08 <srhb> edwardk: My brain just when splat. Why can't I flip diff?
15:50:11 <srhb> went*
15:50:18 <edwardk> rank-2 type
15:50:30 <edwardk> you can flip Numeric.AD.Rank1.Whatever.diff if you want
15:50:33 <srhb> I had no idea that made things unflippable. :P
15:50:39 * srhb ponders that
15:50:45 <edwardk> flip would have to instantiate to a polytype
15:50:55 <edwardk> :t flip
15:50:55 <srhb> Aah
15:50:55 <lambdabot> (a -> b -> c) -> b -> a -> c
15:50:58 <srhb> Yes of course.
15:51:03 <edwardk> the 'a' there would have to be higher rank
15:51:07 * srhb nods
15:51:14 <edwardk> ghc won't do that for you except for ($)
15:51:16 <srhb> Wow, never encountered that before. Hence the confusion.
15:51:45 <edwardk> :t flip runST
15:51:46 <lambdabot>     Couldn't match type â€˜aâ€™ with â€˜forall s. ST s (b -> c)â€™
15:51:46 <lambdabot>       â€˜aâ€™ is a rigid type variable bound by
15:51:46 <lambdabot>           the inferred type of it :: b -> a -> c at Top level
15:51:53 <srhb> I see. :)
16:36:37 <funfunctor> Hi
16:36:51 <TS-Labs> hi
16:36:55 <funfunctor> How can I avoid messing with pointers if at all possible here http://lpaste.net/134362
16:38:17 <funfunctor> sendSPI has the following type signature  sendSPI :: DeviceHandle -> [Word8] -> IO ()
16:38:17 <funfunctor>    
16:38:19 * hackagebot old-version 1.1.0 - Basic versioning library.  http://hackage.haskell.org/package/old-version-1.1.0 (chrisdotcode)
16:38:57 <chpatrick> any idea why this doesn't build? https://github.com/chpatrick/clang_link_error
16:39:05 <chpatrick> needs libclang-3.4-dev if you want to try it out
16:39:11 <chpatrick> I'm completely stuck
16:39:16 <dan64> In a cabal file, I have a build-depends section for the library. Then in the testing section of the same cabal file, I resist those same dependencies, since I'm testing the library. Is there a way to avoid having to resist the exact same dependencies?
16:39:32 <arkeet> funfunctor: hGet from ByteString?
16:39:36 <dan64> *resist --> relist
16:40:43 <funfunctor> arkeet: I believe I need to do 4096 byte chunks though
16:41:02 <arkeet> so?
16:41:16 <arkeet> hGet a 4096 byte chunk then.
16:42:27 <gcganley> is it /tell or @tell?
16:42:42 <arkeet> the latter, for lambdabot commands
16:43:14 <funfunctor> arkeet: but hGet what?
16:43:20 <funfunctor> hGetChar or?
16:43:24 <arkeet> hGet.
16:43:26 <arkeet> from ByteString
16:43:30 <gcganley> @tell chrisdone is there a way to use the src function in script_ in lucid?
16:43:30 <lambdabot> Consider it noted.
16:43:49 <arkeet> http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html#v:hGet
16:43:58 <funfunctor> arkeet: wont I then need to read the whole file into memory?
16:44:02 <arkeet> ...no?
16:44:16 <arkeet> buf <- hGet hdl 4096
16:44:21 <arkeet> or something
16:44:27 <arkeet> where buf is a ByteString now.
16:44:56 <arkeet> with the same loop
16:45:12 <arkeet> and then you can use unpack to get a [Word8] from that.
16:45:19 <funfunctor> ah hmm, does not give me the number of bytes actually read though
16:45:31 <arkeet> yes it does.
16:45:34 <arkeet> in the length of the bytestring.
16:46:06 <funfunctor> oh true
16:46:10 <funfunctor> derr
16:46:11 <funfunctor> thanks
16:46:20 <funfunctor> I just confused myself
16:46:54 <arkeet> so instead of rc > 0 you just use not (null buf)
16:46:55 <arkeet> or whatever
16:47:03 <arkeet> because hGet returns an empty bytestring at EOF
16:52:00 <jooozis> This isn't a haskell question, but someone here might know the answer - can vim be used just as well for agda development or is emacs the only good way to go?
16:52:18 <srhb> jooozis: It can be, but agda-mode is sooooo gooood.
16:52:24 <arkeet> btw #agda exists
16:52:39 <jooozis> ah okay ill have to learn emacs then
16:52:45 <funfunctor> arkeet: thx
16:52:47 <jooozis> arkeet: yeah its pretty dead atm though
16:52:48 <Cale> jooozis: You don't really have to learn much about emacs
16:52:57 <arkeet> I'm sure there are at least as many agda users there as here.
16:53:21 <jooozis> Cale: okay ill give it a try
16:53:22 <Cale> Just learn agda-mode's keys, and use the gui menus for everything else and you'll be fine :P
16:54:15 <Cale> Trying to do without agda-mode would be a frustrating and painful experience, I expect.
16:55:55 <jooozis> okay
16:56:25 <jooozis> I end up hitting the vim keys im used to and getting lost inside emacs 
16:56:38 <funfunctor> arkeet: btw, this is for a SPI flashing tool written in Haskell naturally..
16:57:23 <funfunctor> https://github.com/victoredwardocallaghan/haskflash if you are interested
16:57:24 <DNoved1> You could use Evil mode in emacs to allow access to vim-like keybindings
16:57:55 <Cale> jooozis: I just pretend emacs is like gedit :P
16:58:08 <srhb> Cale: Blasphemer! :|
16:58:31 <srhb> You violated the cult of gedit! /plottwist
16:58:41 <arkeet> lol
16:58:44 <StoneToad> DNoved1: no it was eVIl mode
16:59:31 <DNoved1> eviml mode?
16:59:41 <StoneToad> lol
16:59:49 <StoneToad> I don't think it actually emulates vim?
17:00:19 <f-a> I need to check wether my package is compilable by ghc 7.8 (7.6 does it too). Is there a good sould with those compilers willing to do the job for me?
17:00:36 <srhb> f-a: You need nix! Also yes, I can do that.
17:01:01 <f-a> srhb: hello again! nix the package manager?
17:01:06 <srhb> f-a: Yep.
17:01:17 <DNoved1> toad: I don't think so, just a mode that you can switch into/out of with all the usual keybindings.
17:01:27 <srhb> f-a: Makes testing with various versions of ghc trivial.
17:01:38 <f-a> that'd be _awesome_
17:01:41 <DNoved1> toad: But I'd consider the bindings for vim sufficiently different from vi
17:01:57 <srhb> f-a: :) Take the plunge. It's a bit hard, but worth it.
17:03:33 <f-a> srhb: duly noted! meanwhile, here's the tar http://www.ariis.it/link/t/lentil-0.1.1.0.tar.gz
17:04:00 <f-a> I bet I forgot to 'reimport' something wich in 7.10 is already provided by the prelude
17:06:08 <arbelos_> I don't see why "deleteBy" in Data.List is not deleteBy :: (b -> a -> Bool) -> b -> [a] -> [a] instead of deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
17:06:42 <arbelos_> I mean, that would work exactly the same and give much more flexibility for defining the predicate
17:06:51 <arbelos_> or?
17:07:43 <arkeet> that doesn't seem any more useful than some (a -> Bool) -> [a] -> [a]
17:07:49 <arkeet> that removes the first element that matches 
17:07:57 <arkeet> idk
17:08:59 <funfunctor> @hoogle singleton
17:08:59 <lambdabot> Data.Text.Internal.Builder singleton :: Char -> Builder
17:09:00 <lambdabot> Data.Text.Lazy.Builder singleton :: Char -> Builder
17:09:00 <lambdabot> Data.ByteString.Char8 singleton :: Char -> ByteString
17:09:16 <funfunctor> @hoogle [a] -> a
17:09:16 <lambdabot> Prelude head :: [a] -> a
17:09:16 <lambdabot> Data.List head :: [a] -> a
17:09:16 <lambdabot> Prelude last :: [a] -> a
17:09:55 <funfunctor> what is the best way to unwrap a single element list?
17:10:07 <funfunctor> I guess head could do
17:10:34 <chpatrick> funfunctor: pattern match if you can? :)
17:10:43 <jmct> @hoogle [a] -> Maybe a
17:10:44 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
17:10:44 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
17:10:44 <lambdabot> Prelude head :: [a] -> a
17:10:45 <ronh-> head is usually not the best choice.. it is a partial function (you will get runtime error for an empty list). why donâ€™t you just pattern match like suggested?
17:11:29 <funfunctor> ronh-: because I got the suggestion after I sent my message?
17:11:40 <jmct> I thought there was a safeHead somewhere
17:11:56 <funfunctor>  listToMaybe seems useful
17:12:24 <arbelos> ok I see now
17:13:25 <jmct> funfunctor: yeah, at least that way the types are telling you it might fail and you can deal with it appropriately
17:14:39 <jolllygood2> how to get a pointer address of a haskell object?
17:15:21 <jmct> jolllygood2: it's definitely possible but it's really unsafe
17:15:40 <jolllygood2> noted.. so how?
17:15:46 <c_wraith> jolllygood2: GHC uses a generational GC.  Things can move.
17:16:37 <arbelos> I mean, if I simply change the type signature to (b -> a -> Bool) -> b -> [a] -> [a], I can write e.g., deleteBy (\a b -> a /= read b) 5 ["1", "2", "5"] which fails to compile with the version from base
17:16:47 <peddie> jolllygood2: are you trying to interoperate with C?  is that why you want the address?
17:17:22 <jolllygood2> no.. just tell me how please :)
17:17:58 <peddie> (I have no idea whether it's possible in general, I'm just asking because I know how to set things up so the GC won't move things and I can give pointers to a C program)
17:18:23 <jolllygood2> ah ok. how do I do that?
17:18:56 <peddie> jolllygood2: https://hackage.haskell.org/package/base-4.7.0.2/docs/Foreign-StablePtr.html
17:19:21 <definity> Hi, I'm confused if I am using list comprehension and i use a predicate of 'x /= 15'. Why does it get removed from the set rather than equl it to 0 considering that any number divided by itself will be 0?
17:19:22 <c_wraith> StablePtr doesn't actually give you the address of an object.  It's something... different.
17:19:40 <jolllygood2> yeah
17:19:56 <peddie> I guess that's true
17:20:04 <peddie> I still don't know how to get the actual address :)
17:20:12 <peddie> unless I do it on the C side
17:20:18 <kadoban> definity: /= has nothing to do with division â€¦  it's "not equal"
17:20:19 <peddie> sorry, jolllygood2 
17:20:47 <jolllygood2> it is cool it will come handy soon
17:20:51 <definity> kadoban: So what does /= mean??
17:21:02 <kadoban> definity: Uhm, "not equal"
17:21:21 <jolllygood2> how about getting an address of an arbitrary haskell object
17:21:21 <kadoban> Also any number divided by itself is 1
17:21:32 <definity> kadoban: ahh yeah my mistake thanks :)
17:21:49 <c_wraith> jolllygood2: I don't know offhand how to get addresses.  It's not in any of the obvious places.  It's got to be buried deep in the rts somewhere.
17:21:50 <kadoban> Sure
17:22:42 <peddie> jolllygood2: I am still curious why you want to; I've never needed to . . .
17:23:06 <definity> Any one here one here learn haskell comming from an OOP/impreetive style of coding? How long did it take you to get a grasp of Haskell?
17:23:19 <c_wraith> jolllygood2: It's just not an operation that ever occurs in Haskell.  The FFI has better solutions, so the only thing I can think of is that you want to do some sort of runtime debugging.
17:23:20 * hackagebot tubes 0.2.0.0 - Effectful, iteratee-inspired stream processing based on a  free monad.  http://hackage.haskell.org/package/tubes-0.2.0.0 (gatlin)
17:23:29 <jmct> jolllygood2: I'm not able to find it, I would have sworn I'd seen it before, but can't find it now :-\
17:23:40 <fizbin> definity: depends on what you mean by "grasp".
17:23:55 <kadoban> definity: It took me kind of forever, but I'm a pretty bad student and there's better learning resources now. https://github.com/bitemyapp/learnhaskell <-- this has good advice
17:24:13 <fizbin> definity: I definitely fought - and continue to fight - my tendency to analyze the world in terms of objects.
17:24:29 <funfunctor> jmct: this is what I have now http://lpaste.net/134362 any comments on this?
17:25:04 <fizbin> That's my main struggle with Haskell these days, actually: when I look at a real-world problem and start to think of how to solve it with a program, I start by thinking in objects.
17:26:31 <codygman> Got Frag compiling on GHC 7.8 ;) I ran it with a noop normalize function because I couldn't get it to typecheck though... who needs normalizing right? :P
17:26:44 <jolllygood2> peddie: at this point just curiosity. I am wonder how are objects allocated behind. I also wanted to implement efficient equality function for some specific purpose, but that obviously wont work if GC can move objects around
17:27:06 <jolllygood2> *wondering
17:27:06 <jmct> funfunctor: So your use of fix is fine, but you don't have to use it
17:27:33 <funfunctor> jmct: how do you mean?
17:27:49 <peddie> jolllygood2: I think there are some fairly recent papers about how the GC works; that might be more illuminating than just looking at the addresses of all your objects
17:28:13 <KaneTW> :t fix
17:28:14 <lambdabot> (a -> a) -> a
17:28:16 <jmct> jolllygood2: reallyUnsafePtrEquality# might be of interest then
17:28:33 <jolllygood2> but also more dry, more time consuming, and less fun :P
17:28:40 <peddie> jolllygood2: as you like :)
17:28:51 <jolllygood2> jmct: cool function name
17:29:05 <jmct> funfunctor: you could just give it a name and call itself. I'll re-write yours and show you what I mean
17:29:43 <codygman> Any ideas on this error? After fixing all the other frag compile errors my brain is a bit slushy: http://lpaste.net/134364
17:29:52 <definity> fizbin: I have the same problem since i understand OOP better than Lambda
17:30:08 <jolllygood2> what is with # in the name?
17:30:28 <albeit_> As I understand it, GHC uses an asynchronous non-blocking IO manager... but why aren't sockets non-blocking? Why doesn't CPU use go to 100% when using recvFrom?
17:30:59 <peddie> jolllygood2: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/local-gc.pdf http://comments.gmane.org/gmane.comp.lang.haskell.cafe/99583 if you want to read more later
17:31:06 <jmct> funfunctor: http://lpaste.net/134362 that's my short rewrite
17:31:26 <jolllygood2> peddie: thanks
17:31:40 <Cale> albeit_: I'm not sure I understand the question. Most operations actually block, even if they're implemented in terms of what at the OS level are nonblocking primitives.
17:31:42 <peddie> jolllygood2: I suggest if you don't know why it's called reallyUnsafe and has a #, you might want to avoid it for now :)
17:31:46 <jmct> I did two things, pattern match directly on the list (now that I've seen your use case I recommend this) and I've avoided fix
17:32:07 <jmct> semantically they are the same (the version with fix and without)
17:32:46 <Cale> albeit_: As in, your Haskell thread will block, but your program as a whole won't.
17:32:50 <jolllygood2> I guess at this point an "a -> IO Int" function would be more useful. where Int represents pointer address
17:33:33 <Cale> jolllygood2: Such a thing would not be very useful. By the time you're able to do anything with the result, it might be invalid.
17:33:39 <albeit_> Cale: Ah okay. I've been trying to read more about the IO manager but can't find much. So if I uses a socket, its non-blocking, but the Haskell thread blocks and has to be awoken? Isn't that effectively the same as a blocking socket?
17:33:47 <jmct> funfunctor: (my formatting is a bit ugly, I should have indented all the lines after the 'where')
17:33:50 <funfunctor> jmct: oh hehe, thx, minimalist
17:34:06 <jolllygood2> I understand why it is unsafe, but this is the first time I am seeing # convention
17:34:07 <Cale> albeit_: The important thing is that your other Haskell threads have a chance to run.
17:34:17 <arbelos_> I found the answer to my previous question here http://stackoverflow.com/questions/9004937/is-there-a-good-reason-why-deleteby-does-not-have-its-most-general-type
17:34:53 <albeit_> Cale: But I don't want them to... I have a single Haskell thread on a dedicated core that I want to be waiting on a non-blocking socket
17:35:02 <Cale> albeit_: If you do a blocking system call, say with FFI, the entire OS thread blocks.
17:35:05 <jmct> jolllygood2: It's because it's a primitive
17:35:35 <Cale> albeit_: Which can stop other unrelated threads from running, if there aren't other OS threads available to run them on.
17:36:06 <jolllygood2> i see
17:36:11 <funfunctor> jmct: I think i'll leave it as it is though, the extra typing plus function name fixed gives a bit more context
17:36:13 <albeit_> Cale: Okay, that's fine, got enough other OS threads and cores available. Guess I'll look into doing the FFI calls
17:36:31 <Cale> jolllygood2: The # thing is because # is normally not a valid character in a non-infix identifier, so you need to turn on an extension to get access to that stuff.
17:36:51 <Cale> albeit_: Wait, what exactly are you trying to do?
17:37:43 <jmct> funfunctor: fair enough :)
17:38:19 <Cale> albeit_: The expectation should be that you can use stuff which looks like it blocks from the point of view of your Haskell program without needing to poll, and the IO manager will make sure that when stuff becomes available your thread gets woken up.
17:38:21 <albeit_> Cale: I want one dedicated thread, on its own core, busily waiting for network data to minimize latency
17:38:40 <Cale> albeit_: The IO manager uses epoll/kqueue when they're available
17:38:41 * fizbin wrote his first FFI-using program today. It went better than might be expected.
17:38:42 <jolllygood2> so is there a way to get a pointer address of an arbitrary haskell object? a -> IO Int or something
17:38:54 <Cale> albeit_: (and select if not)
17:39:23 <Cale> jolllygood2: Maybe, but it would be useless.
17:39:29 <albeit_> Cale: I'm on Linux, so I'm presuming its using epoll. But if waiting on the socket is all my thread is doing, why doesnt the core spin up to 100% usage?
17:39:51 <codygman> Cale: I got Frag compiling using a StorableArray! I see that gentoo has an unrust patch that just changed IOUArray to IOArray, but I'm not sure if it works on GHC 7.8.
17:39:53 <Cale> albeit_: Because it doesn't need to. It gets notified immediately when data is available.
17:40:15 <Cale> albeit_: Wasting power and heating the CPU up won't accomplish anything extra.
17:40:47 <srhb> fizbin: Did you have fun with the segfaults?
17:40:50 <albeit_> Cale: Immediately? Or very quickly? Would recvFrom be called after data is received as soon as if it were busy waiting?
17:41:04 <albeit_> And how does it accomplish that without busy waiting?
17:41:10 <jolllygood2> Cale what is the function's name?
17:41:45 <Cale> albeit_: Well, that's a good question. I don't know all of the details, but the latency is generally quite low.
17:42:34 <definity> Anyone here see the C to english generator, is ther a haskell equivilent?
17:42:51 <albeit_> Cale: Do you know anyplace I can read more about how it accomplishes that? 10 microseconds would be a lot, for example, so I want to avoid that if possible
17:42:57 <Axman6> I'm not sure how useful that would be
17:43:06 <Cale> jolllygood2: If it exists, it's probably in here https://downloads.haskell.org/~ghc/latest/docs/html/libraries/GHC-Prim.html
17:43:21 * hackagebot lentil 0.1.1.0 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.1.0 (fffaaa)
17:43:23 * hackagebot tubes 0.2.1.0 - Effectful, iteratee-inspired stream processing based on a  free monad.  http://hackage.haskell.org/package/tubes-0.2.1.0 (gatlin)
17:43:38 <Cale> jolllygood2: There's reallyUnsafePtrEquality# :: a -> a -> Int#
17:43:38 <fizbin> srhb: That's what went surprisingly well. The C library is implementing only a single well-specified and highly vetted algorithm.
17:43:50 <Cale> jolllygood2: Which can have both false positives and false negatives.
17:44:21 <srhb> fizbin: Ah well. I found the segfaults the most enjoyable experience of doing FFI for the first time.
17:44:29 <fizbin> srhb: I did have to change the C code so that it handled assertion errors by returning status values, rather than by calling exit(2).
17:44:38 <srhb> Ah :P
17:44:48 <fizbin> That was fun, the first time I dropped out of ghci.
17:45:04 <Cale> albeit_: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf has more details about the GHC IO manager
17:45:37 <albeit_> Cale: Thanks
17:45:44 <Cale> albeit_: The latencies are down in the tens of microseconds range
17:45:56 <fizbin> I do wonder a bit about the style of the FFI-calling code, and if I'm maybe missing some better way to call it.
17:46:19 <lamefun> Is ReadP good to use? Seems kinda abandoned judging by "documentation".
17:46:46 <srhb> lamefun: It's in base isn't it?
17:47:08 <lamefun> yes
17:47:14 <Cale> lamefun: It's nice if you don't really need pretty error messages
17:47:24 <srhb> lamefun: I don't know how you can consider base abandoned. :-)
17:47:33 <Cale> lamefun: It's also really nice if you find yourself needing to write a Read instance manually.
17:47:51 <srhb> fizbin: I've only ever done some very trivial bindings to xkb
17:47:57 <Cale> lamefun: One advantage it has over Parsec is that it has symmetric choice.
17:47:57 <srhb> fizbin: But we can compare if you like!
17:48:26 <jolllygood2> if I type reallyUnsafePtrEquality# in ghci I get "parse error"
17:48:37 <Cale> lamefun: So you can write p +++ q and not have to worry about what if p consumes some of the input before failing.
17:48:40 <srhb> Does it need magichash?
17:48:41 <dolio> jolllygood2: :set -XMagicHash
17:48:54 <jolllygood2> lol wtf
17:49:08 <srhb> jolllygood2: You need unboxedness.
17:49:12 <Cale> jolllygood2: # is not ordinarily a valid character in identifiers.
17:49:30 <lamefun> Cale, I mean, it can be in base for backwards compatibility but ignored. Does anyone use it in significant software?
17:49:43 <lamefun> https://hackage.haskell.org/package/base-4.7.0.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS - doesn't even tell what String in (a,String) is...
17:50:02 <jolllygood2> that worked
17:50:13 <Cale> lamefun: I don't know what's significant. Oh, that's the remainder of the input of course.
17:50:56 <lamefun> why does it return many things instead of one?
17:50:59 <Cale> jolllygood2: The extension exists just to put one more step in the way of using internals.
17:51:08 <Cale> lamefun: Because parses may be ambiguous.
17:51:44 <lamefun> https://encrypted.google.com/search?q=haskell%20readP - nothing good.
17:52:00 <srhb> Huh?
17:52:07 <jolllygood2> interesting how reallyUnsafePtrEquality# prints nicely when you type it in ghci, while with a regular function you get no show instance error
17:52:30 <srhb> jolllygood2: It's obviously a String, not a function.
17:52:41 <Cale> jolllygood2: what?
17:52:43 <jolllygood2> what?
17:53:06 <Cale> jolllygood2: You should get No instance for (Show (a0 -> a0 -> Int#))
17:53:12 <Cale> (at least I do)
17:53:14 <dolio> That's what I get.
17:54:07 <jolllygood2> type of the function is printed so it is obviously a function not a string
17:54:23 <srhb> jolllygood2: Sorry, it was a bad joke.
17:54:26 <srhb> Didn't transfer well.
17:54:39 <Cale> jolllygood2: You must have some module in scope which is providing an instance of Show for functions.
17:54:56 <KaneTW> Try typing :i (->)
17:55:35 <lpaste> fizbin pasted â€œFFI style exampleâ€ at http://lpaste.net/134366
17:55:48 <fizbin> srhb: ^^^
17:55:54 <Cale> Prelude GHC.Prim GHC.Types> let x = 10 in I# (reallyUnsafePtrEquality# x x)
17:55:55 <Cale> 0
17:55:57 <Cale> ^^ beautiful
17:56:09 <fizbin> That's an example of the haskell wrapper I wrote around the FFI code.
17:56:33 * jolllygood2 passed x y (both Ints) to that function and I got "Kind incompatibility when matching types: a0 :: *, Int# :: #
17:56:36 <srhb> fizbin: https://github.com/srhb/xmonad-kbd/blob/master/XMonad/Util/XKB.hsc -- yeah yours is way more involved than mine.
17:57:08 <mjvc> hey does anyone have a recommendation for a good DAG library?
17:57:18 <mjvc> I see there's a few and don't know which to pick
17:57:29 <Cale> mjvc: What algorithms do you need?
17:57:30 <fizbin> srhb: But you figured out hsc2hs! I did mine without that, since I couldn't figure out its purpose this morning.
17:57:42 <srhb> fizbin: It's magic! :-)
17:57:50 <mjvc> Cale: mostly going to be checking if it can be made planar
17:58:12 <lamefun> should I ignore ReadP and use Parsec?
17:58:32 <mjvc> Cale: there might be some weird knot theory math I can use. not sure
17:58:38 <srhb> lamefun: If you need the extra functionality, sure.
17:59:31 <lamefun> srhb, ReadP seems dead, 0 documentation, it looks like it's there only there for backwards compatibility with very old libraries.
17:59:38 <srhb> lamefun: Not so.
17:59:52 <srhb> Besides stable /= dead
18:00:15 <Cale> lamefun: It's perfectly usable.
18:00:22 <Cale> lamefun: What documentation is missing?
18:00:45 <Cale> It looks like everything is documented...
18:01:01 <Cale> Plus there's even a QuickCheck specification of everything...
18:02:42 <Cale> lamefun: The main reason it hasn't changed in a long time is that there's not much extra you'd reasonably want to add. Better error reporting might be a nice feature, but if you want that, you basically need a different representation of parsers.
18:03:01 <Cale> lamefun: Maybe support for other stream types
18:03:14 <funfunctor> Anyone happened to use Options.Applicative much can tell me why -d is being 'required' in https://github.com/victoredwardocallaghan/haskflash/blob/master/src/Main.hs ?
18:03:19 <Cale> (but again, doing that well would require a different representation)
18:03:32 <funfunctor> the option is only meant to be optional
18:03:36 <Cale> lamefun: For the type of library that it is, it's pretty much complete.
18:04:36 <Cale> If you just need a very simple parser, it can be quite a decent choice.
18:04:53 <monochrom> ReadP is newer than Parsec, not older
18:05:22 <srhb> funfunctor: Needs a default value, no>?
18:05:45 <funfunctor> srhb: oh um ok
18:05:50 <Cale> Well, it's older in a different sense. Parsec has seen major revisions more recently.
18:06:31 <funfunctor> srhb: what about option exclusion? like -b and -n should not occur at the same time, that should invoke help
18:07:50 <srhb> funfunctor: https://github.com/pcapriotti/optparse-applicative/issues/111
18:08:10 <srhb> funfunctor: So model it in the data structure :)
18:09:13 <jolllygood2> btw "printing function types" is wjat haskell-mode does for all functions.. cool
18:13:16 <funfunctor> @hoogle String -> Bool
18:13:16 <lambdabot> Test.QuickCheck.Text isOneLine :: String -> Bool
18:13:17 <lambdabot> System.FilePath.Windows hasDrive :: FilePath -> Bool
18:13:17 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
18:14:11 <simon> lamefun, when it comes to ambiguous parses, ReadP might explode on you and Parsec might just give unexpected results. ReadP is easier to use, and the syntax errors it produces are easier to understand, but the parse errors are less informative. (I might be repeating some things here.)
18:15:14 <albeit_> If a thread is waiting on an unsafe FFI call, can the GC still run? How does it deal with the waiting thread?
18:18:21 <simon> which mysql library is preferred? mysql-simple?
18:21:31 <srhb> simon: MySQL? None! :-)
18:21:34 <srhb> Kidding, of course.
18:21:56 <hpc> just open3 the mysql binary
18:22:27 <srhb> simon: I think mysql-simple is fine if you want to go that low level.
18:22:35 <kadoban> mysql-reallycomplex
18:22:52 <hpc> hdbc is a nice common interface
18:24:53 <hpc> i would also say that if you're at the point where it matters which you pick, you know enough about how to measure the difference between each
18:25:15 <hpc> ie, profiling or if you need a particular dbms function exposed
18:25:30 <funfunctor> srhb: any idea why I would get this kind of type error http://lpaste.net/134367
18:25:53 <funfunctor> srhb: if I try to use Maybe String and have a default value of Nothing
18:26:55 <funfunctor> value :: HasValue f => a -> Mod f a 
18:29:31 <lamefun> ReadP gives me this... [(Version 1 2 3 [] [],"alpha.7.FOO.BAR.12345"),(Version 1 2 3 ["alpha"] [],".7.FOO.BAR.12345"), ...] - and the result I want is at the END of the list...
18:30:28 <lamefun> fixable?
18:30:41 <Cale> lamefun: Should be. Be careful about the order of arguments to +++
18:31:11 <Cale> Or else do something to ensure that the first isn't a valid parse.
18:31:51 <Cale> (perhaps you want to check for eof?)
18:32:11 <srhb> funfunctor: Well you need the other possibility to be a Just "yourstring"
18:32:23 <srhb> funfunctor: And not just a String.
18:33:33 <funfunctor> srhb: how do you mean? a default value of Nothing gives the other possibility
18:33:43 <srhb> funfunctor: I mean the possibility that there's actually input
18:33:52 <srhb> funfunctor: You're not turning it into a Maybe String
18:33:55 <srhb> funfunctor: So it's just a String
18:34:00 <srhb> And String does not unify with Maybe String
18:34:10 <mjrosenb> @hoogle  Monad m => (a -> m Bool) -> [a] -> m ([a],[a])
18:34:10 <lambdabot> No results found
18:34:31 <funfunctor> how do I turn it into a Maybe String within this applicative framework?
18:34:54 <funfunctor> I thought its polymorphic on type parameter a
18:36:09 <srhb> funfunctor: strOption is Parser String
18:36:30 <srhb> funfunctor: So you'll have to convert it into a Parser (Maybe String)
18:36:31 <funfunctor> I can't seem to find a Parser (Maybe String)
18:36:34 <funfunctor> yea
18:36:52 <srhb> funfunctor: It's a Functor, right?
18:36:56 <srhb> :t fmap
18:36:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:37:26 <funfunctor> fmap Maybe strOption ?
18:37:48 <srhb> funfunctor: Maybe is a type constructor
18:38:07 <srhb> funfunctor: So it's pure or Just or something. Or you can just write your own parser if you feel more comfortable doing that :)
18:38:11 <funfunctor> srhb: exactly so thats why I am confused on how to do it
18:38:35 <funfunctor> not really, there must be a easy way to get a maybe
18:38:50 <srhb> Does it expose optional?
18:39:09 <srhb> :t optional
18:39:09 <lambdabot> Alternative f => f a -> f (Maybe a)
18:39:28 <srhb> So assuming Parser is an Alternative (which it is) you can convert a Parser a into a Parser (Maybe a) with it
18:40:33 <srhb> funfunctor: If not, just do it by hand. Just <$> yourparser <|> Nothing
18:40:35 <srhb> er
18:40:45 <srhb> ... <|> pure Nothing
18:40:47 <lamefun> Cale, it's not my fault, it's sepBy1's fault... sepBy1 (munch1 isDigit) (char '.') on "13.241.32" gives: [(["13"],".241.32"),(["13","241"],".32"),(["13","241","32"],"")].
18:41:36 <srhb> funfunctor: A similar trick using Either works for your mutually exclusive ones.
18:42:06 <srhb> Anyway, I need a break and perhaps to try and sleep again. :) Good luck
18:42:24 <funfunctor> srhb: I think I worked it out with optional, thanks
18:42:30 <definity> http://stackoverflow.com/questions/30794057/beginner-help-for-understanding-haskell-list-comprehension-syntax
18:42:54 <funfunctor> @hoogle empty
18:42:54 <lambdabot> Control.Applicative empty :: Alternative f => f a
18:42:54 <lambdabot> Data.Text.Array empty :: Array
18:42:54 <lambdabot> Text.Html.BlockTable empty :: BlockTable a
18:43:01 <funfunctor> > : ""
18:43:02 <lambdabot>  <hint>:1:1: parse error on input â€˜:â€™
18:43:07 <funfunctor> > :t ""
18:43:08 <lambdabot>  <hint>:1:1: parse error on input â€˜:â€™
18:43:13 <albeit_> Is it possible somehow to import the "Foo.Bar.Internal" modules in packages?
18:46:33 <gfixler> When folding over [Int], am I able to handle breaking out on an unwanted condition?
18:46:51 <gfixler> e.g. if it folds, can I return a Right, but if I hit something mid-fold, can I return a Left?
18:46:59 <gfixler> is there anything higher-order for such an occasion?
18:53:37 <johnw> use foldM with Eihter
18:53:47 <johnw> :t foldM
18:53:48 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
18:54:31 <gfixler> johnw: thanks, I'll look into that right now
18:55:50 <johnw> > foldM (\b a -> if a > 20 then Left b else Right(b + a)) 0 [1..100]
18:55:51 <lambdabot>  Left 210
18:56:45 <definity> In haskell is a string just a list of chars?
18:56:50 <johnw> yes
18:57:05 <definity> Ahh OKAY, Thanks :)
18:57:18 <bvun> Anyone here good at time complexity? This is a function that determines the maximum height of an unbalanced BST, and with the two recursive calls on each node I suppose it should be O(2^n), but that seems a bit too much http://www.pastebin.ca/3025057
18:58:14 <johnw> should be O(n)
18:58:26 <bvun> why?
18:58:35 <lamefun> ReadP seems kinda useless now...
18:58:37 <johnw> imagine the BST for worse case, then see how many times height would be called relative to the number of nodes
18:59:04 <johnw> best case is O(n) too, one call to height for each node
19:01:33 <bvun> johnw: okay, I think I get it, thanks!
19:02:39 <lamefun> Why would base contain a borderline useless library?
19:03:16 <Cale> lamefun: I don't know why you say that
19:04:21 <definity> Is it possible to have more than 1 return type in haskell?
19:04:29 <Cale> It's a well-designed little parser combinator library, great for writing instances of Read if you need a custom one for some reason, or e.g. validation of form fields, that sort of thing.
19:04:49 <Cale> definity: No, but you can return something of type Either A B
19:05:05 <Cale> definity: Well, there's also type class polymorphism
19:05:07 <Cale> :t read
19:05:08 <lambdabot> Read a => String -> a
19:05:14 <Cale> > read "45" :: Integer
19:05:15 <lambdabot>  45
19:05:18 <Cale> > read "45" :: Double
19:05:19 <lambdabot>  45.0
19:05:38 <Cale> This is applying a different parser depending on the type of result which is demanded.
19:05:48 <Cale> > read "[1,2,3]" :: [Integer]
19:05:49 <lambdabot>  [1,2,3]
19:06:11 <Cale> But the type of result here is determined statically.
19:06:12 <definity> Okay thanks :) But I'm just beginning on Haskell that seams a bit out of my depth for now
19:06:32 <Cale> read doesn't get to decide which result type it is producing, its caller does
19:06:59 <Cale> If you wanted the function to be able to produce more than one sort of result, you need to invent a type which accounts for all the possibilities
19:07:27 <lamefun> Cale, what's the use of a parser that can't parse properly?
19:07:36 <Cale> lamefun: hm? It does parse properly.
19:07:44 <tejing> definity: did you mean having a function return a single value that could 1 of several types or having a function return several vlaues, of different types?
19:08:15 <Cale> lamefun: I don't know what your problem with it is.
19:08:37 <Cale> lamefun: You haven't linked your code or anything for me to be able to diagnose what you're doing wrong.
19:08:43 <definity> tejing: I mean returning multiple types like Bool -> Integer -> [Char]
19:08:47 <definity> all from one function
19:09:25 <Cale> lamefun: If you want to disambiguate the parse, just check for an end marker of some sort.
19:09:39 <Cale> lamefun: or eof if it's meant to be the end of the string after
19:11:17 <tejing> definity: you didn't really answer my question... (or I didn't get it) does a single invocation of your function produce 2 values or 1?
19:12:26 <nicola>     /filter add joinquit * irc_join,irc_part,irc_quit *
19:12:39 <geekosaur> "oops"
19:12:43 <nicola> sorry
19:12:44 <definity> tejing: Oh, I have not got any thing coded down I just was wondering.
19:12:52 <definity> is it possible
19:13:06 <tejing> definity: well then which are you wondering about?
19:13:15 <lamefun> Cale, "or eof if it's meant to be the end of the string after" - but then I can't use the parser in other parsers...
19:13:21 <geekosaur> definity, that's (Bool -> Integer -> [Char]) not returning multiple things
19:13:22 <definity> tejing: 2 values
19:13:41 <definity> geekosaur: What if i want to return all 3
19:13:44 <tejing> definity: then make the function return a tuple
19:13:47 <geekosaur> ^
19:13:50 <definity> ahhhhh
19:13:55 <definity> I see thankf for the help guys :)
19:13:59 <definity> thanks*
19:14:03 <geekosaur> although it's usually better to use a custom type declared with `data`
19:14:10 <tejing> :t divMod
19:14:11 <lambdabot> Integral a => a -> a -> (a, a)
19:14:14 <tejing> like that
19:14:56 <geekosaur> tuples are anonymous and unless it really is a one-off thing you will benefit from the extra typechecking and the fact that constructors can be a form of documentation
19:17:18 <Cale> lamefun: Well, right, but if you use the thing as part of another parser, hopefully the parse won't be ambiguous anymore.
19:17:29 <jooozis> is it just my settings or are several different symbols appearing as squares here: http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Docs.UnicodeInput ?
19:17:37 <Cale> lamefun: So you have a bit of a choice there about how to determine where the end is.
19:18:22 <Cale> lamefun: Or if you want, you could write a greedy-order sepEndBy
19:18:40 <Cale> lamefun: But usually you try to write parsers which aren't ambiguous in the end.
19:18:43 <geekosaur> jooozis, they all show up here, so I suspect it's your font
19:19:01 <lamefun> Cale, oh OK.
19:19:01 <jooozis> oh... hmm
19:21:46 <jooozis> geekosaur: what font are you using?
19:21:58 <geekosaur> Arial Unicode MS
19:22:08 <geekosaur> but I'm on a Mac and it does font substitution fairly well
19:22:25 <Cale> jooozis: Here's how it looks on my machine http://i.imgur.com/ROnV9L4.png
19:22:50 <Cale> I'm running Linux Mint 17.1
19:22:51 <geekosaur> X11 based stuff is more likely to require you to start out with the right font
19:23:10 <jooozis> Cale: on mine half of the characters in 'Character' column are squares. tried several fonts now
19:23:26 <Cale> Most everything on linux goes through freetype 2 and does font substitution.
19:23:34 <montagy> foo :: Int -> Int
19:23:34 <montagy> 2   foo n = n^2 has a warning on n^2,i can (2::Integer) ,what's the best way ?
19:23:41 <geekosaur> it's supposed to but my experience is it often does it poorly
19:23:42 <montagy> sorry for my english
19:23:54 <Cale> montagy: Ignore that warning
19:23:56 <geekosaur> montagy, there's no good way other than that or ignoring the warning
19:24:03 <exio4> montagy: disable the warning, it's a silly one 
19:24:05 <jooozis> okay, ill try to figure it out
19:24:07 <geekosaur> it's a corner case because of the type of (^)
19:24:15 <Cale> montagy: -Wall is way too aggressive about what it warns you about
19:24:26 <geekosaur> and a place where the warning is pretty much just useless noise
19:24:32 <montagy> thank you all guys
19:25:01 <montagy> i use ghc-mod,so,how do it ?
19:25:37 <Cale> jooozis: I might be able to work out which font the symbols are coming from on my system
19:25:43 <exio4> if there is any reason we want/have default at all, is to have _those_ cases covered 
19:25:48 <Cale> jooozis: which ones are missing for you?
19:25:59 <exio4> defaulting*
19:26:11 <jooozis> Cale: I don't think its a font problem, I tried several different ones and it stays the same
19:26:13 <lamefun> "lamefun: But usually you try to write parsers which aren't ambiguous in the end." - how?
19:26:32 <jooozis> Cale: probably something wrong with my linux config, ill figure it out, don't want to waste your time
19:26:45 <Cale> jooozis: If you're on Linux, changing the font won't help -- if they don't appear, it means that no installed font on your system has that symbol.
19:27:03 <Cale> jooozis: If there were a font which contained that symbol, then it would automatically select it.
19:27:10 <jooozis> oh
19:27:38 <jooozis> Cale: I tried Lucida, Bitstream and DejaVu 
19:27:41 <_DrPavelheer> Weird
19:27:51 <_DrPavelheer> DrPavelheer is still connected
19:28:08 <DrPavelheer> There we go
19:28:12 <Cale> jooozis: which ones are missing?
19:28:20 <funfunctor> Has anyone experimented with zero runtime requirements for Haskell (if possible?)
19:28:58 <geekosaur> funfunctor, maybe look at jhc?
19:29:04 <Cale> funfunctor: What, you mean like HaLVM?
19:29:15 <funfunctor> well hmm
19:29:33 <montagy> in list monad,a<-id [1..10] ;is the id used to break the a<[1..10] semantic,or something else?
19:29:44 <Cale> HaLVM lets you write stuff which runs directly on the Xen hypervisor, with no OS.
19:29:46 <funfunctor> I managed to write some bring up code for x86 that hopes me into a hello world in Ada and ASM, no BIOS needed !
19:29:49 <geekosaur> that said, you can lsoe in efficiency what you gain in simplicity
19:29:55 <funfunctor> runs in cache
19:30:06 <Cale> montagy: id does nothing there
19:30:17 <Cale> montagy: (it does nothing anywhere, which is sort of the point of it)
19:30:19 <funfunctor> I was wonder if its possible to do with the Haskell compiler
19:30:21 <jooozis> Cale: http://i.imgur.com/Gy2fbKj.png
19:30:42 <funfunctor> Cale: nar, I am thinking of metal, the actual metal !
19:30:50 <geekosaur> funfunctor, definitely look at jhc
19:30:55 <lamefun> Cale, the problem with ReadP is that the standard combinators seem to have been made improperly.
19:31:12 <Cale> jooozis: On my system, DejaVu Sans has the subscript 1
19:31:23 <geekosaur> althoiugh truly "bare metal" isn;t really possible, you need *some* support stuff somewhere for a garbage collected language
19:32:00 <funfunctor> geekosaur: do you mean ajhc ?
19:32:01 <Cale> jooozis: and apparently a font called "FreeSans" has the left and right angle brackets
19:32:23 <alexv19> Why can't I eta-reduce this: `peek p = MyNewtype <$> (peek . castPtr) p`
19:32:25 <alexv19>  to this: `peek = MyNewtype <$> peek . castPtr` ?
19:32:27 <geekosaur> ajhc is a fork of jhc, with some changes that were mostly merged with upstream jhc
19:32:42 <lamefun> Cale, http://lpaste.net/134369
19:32:49 <geekosaur> but jmeacham has been too busy to work on jhc recently
19:32:58 <geekosaur> (does intend to come back to it when he gets time)
19:33:23 <jooozis> Cale: are you saying that different chars come from different fonts?
19:33:27 <Cale> jooozis: yes
19:33:38 <simon> srhb, do you use pgsql for your website adventures?
19:33:38 <Cale> jooozis: The font you select is merely a preference
19:33:48 <jooozis> ah
19:33:53 <StoneToad> geekosaur: pfft, just get GC implemented in the hardware :D
19:33:55 <geekosaur> jooozis, font substitution is common in modern font management systems
19:33:59 <Cale> jooozis: It will pick glyphs from other installed fonts if no glyph is available in the font you selected.
19:34:04 <srhb> simon: Only when I feel I can't get away with acid-state :)
19:34:07 <jooozis> I see
19:34:15 <geekosaur> the font machinery will look for a font with the missing glyph and use that 
19:34:26 <geekosaur> however there afre various ways it can break
19:34:28 <funfunctor> geekosaur: so is ajhc actually better maintained?
19:34:38 <funfunctor> web page looks better for ajhc :p
19:34:40 <geekosaur> that said, I wonder if your real problem is that you have an encoding issue somewhere
19:34:50 <geekosaur> funfunctor, not that much better
19:35:01 <Cale> There are all sorts of arbitrarily complicated rules for which fonts to select from, which actually become sort of important if you want to read and write CJK languages, unfortunately.
19:35:19 <srhb> simon: But yes, then I certainly by far prefer pg.
19:35:21 <geekosaur> and it's explicitly temporary until meacham gets time to merge stuff into jhc
19:35:40 <montagy> Cale, thank you .i get it
19:36:02 <Cale> funfunctor: The closest thing in Haskell would be using HaLVM I think.
19:36:21 <funfunctor> Cale: no HaLVM is something completely different
19:36:28 <geekosaur> or maybe you don't have unicode fonts installed and it's using iso8859 substitutions to get things like lambda
19:36:37 <geekosaur> but on a modern system that'd be kinda weird?
19:36:37 <Cale> funfunctor: I mean, if you want to write code which runs closer to bare metal.
19:36:38 <funfunctor> geekosaur: it really looks to me that ajhc is better maintained
19:36:42 <dolio> alexv19: Because that's not an eta conversion.
19:36:52 <funfunctor> Cale: not closer, but @ the metal
19:37:16 <geekosaur> funfunctor, I explained what I know, if you choose to interpret it as "ajhc is the new jhc, ignore jhc as it's dead" thne that's your lookout
19:37:28 <geekosaur> you can be surpised when it gets merged back in
19:38:26 <Cale> funfunctor: Well, that's pretty much what HaLVM is. It's just the GHC runtime system ported to run directly in a Xen hypervisor, which means you can do away with the host operating system
19:38:35 <funfunctor> geekosaur: I mean, I suspect I would need to make lots of changes to do what I would like
19:38:46 <lamefun> Cale, Hoogle can only find sepEndBy for Parsec...
19:39:10 <funfunctor> Cale: There is still half a million loc before you even see your boot loader
19:39:17 <funfunctor> Cale: https://github.com/victoredwardocallaghan/aperture/tree/build_fixes
19:39:53 <jooozis> Cale: I updated my locale on my system and it seems to work now... it wasnt set to utf8 before apparently, works in console.. might need to restart browser to try in chrome.. brb
19:39:54 <funfunctor> getting to run protected mode code in a high level language before RAM is even working yet
19:41:44 <jooozis> Cale: yup, fixing the locale solved the issue
19:42:51 <alexv19> dolio: but why?
19:42:53 <Cale> jooozis: Cool, good to know
19:43:00 <alexv19> @pl  peek p = fmap MyNewtype $ (peek . castPtr) $ p
19:43:00 <lambdabot> peek = fix ((fmap MyNewtype .) . (. castPtr))
19:43:37 <alexv19> why can't i just remove `p` from both sides?
19:44:04 <dolio> alexv19: Because your function is: peek p = (<$>) MyNewType ((peek . castPtr) p)
19:45:00 <dolio> \p -> f (g p) ==> f g is not an eta reduction.
19:45:08 <dolio> It needs to turn into f . g.
19:46:44 <shachaf> (\p -> f (g p)) ==> (f . g) isn't much of an eta reduction either
19:47:05 <dolio> Yeah, well...
19:47:09 <alexv19> dolio: I think i got it. Thanks!
19:48:34 <vikaton> does it take a genius to really understand haskell?
19:48:44 <johnw> no
19:48:46 <vikaton> or can anyone grasp its concept?
19:49:10 <johnw> it is much harder to unlearn other patterns of thought, than it is to learn Haskell
19:49:16 <srhb> vikaton: "its concept" ? :P
19:49:32 <vikaton> the problem is
19:50:07 <vikaton> I'm afraid to learn haskell and miss key areas where it would teach me important things
19:50:21 <srhb> vikaton: You will, and then you'll just pick them up later when needed.
19:50:27 <srhb> Goes for anything really. Not just Haskell.
19:50:51 <vikaton> I see
19:50:57 <exio4> haskell is just a programming language after all 
19:50:59 <srhb> vikaton: Why do you want to learn Haskell?
19:51:12 <vikaton> srhb: to increase my programming skills and knowledge
19:51:17 <srhb> vikaton: Good choice. :)
19:51:25 <vikaton> I dont want to miss any key points :P
19:51:34 <srhb> Most people who work in other languages daily but learned some Haskell say they've become better programmers for it.
19:51:44 <srhb> vikaton: Well, it's going to happen whether you like it or not. :P
19:52:09 <srhb> vikaton: If for no other reason then because there isn't One True Order to learn everything Haskell in.
19:52:31 <vikaton> Ok, thanks srhb 
19:52:37 <vikaton> im just gonna give it a go
19:52:57 <vikaton> I guess I just doubt my own intelligence to learn haskell
19:53:21 <vikaton> which is strange, because I want to increase my problem solving with haskell
19:53:59 <srhb> vikaton: Haskell has no formal IQ requirement
19:54:07 <srhb> vikaton: If it seems hard at first, it's because it's different -- not harder.
19:54:36 <vikaton> I've only been programming for a little under 1 year and many people say to beware of haskell road
19:54:45 <srhb> That's a strange thing to say.
19:54:46 <Iceland_jack> vikaton: Never beware
19:55:04 <vikaton> they say beware because it was hard for them
19:55:07 <vikaton> * at first
19:55:09 <srhb> Well, sure.
19:55:11 <Iceland_jack> â€œAttack the garden where it is tallestâ€ as you might say in Icelandic
19:55:20 <srhb> Iceland_jack: Wow, that is an excellent saying.
19:55:22 <Iceland_jack> Always
19:55:48 <funfunctor> vikaton: "think with types" is my best advice, plan out your computation by type transforms
19:56:07 <srhb> vikaton: But give it a go, see if you like it
19:56:08 <funfunctor> think of each step as a particular type
19:56:17 <srhb> vikaton: You can always come here for help, and you can always stop if you don't like it :-)
19:57:03 <Iceland_jack> srhb: Thanks, it's usually said in the converse: â€œdon't attack the garden where it's lowestâ€
19:57:25 <Iceland_jack> which doesn't work as well
19:57:35 <vikaton> I dont think I wont like haskell 
19:57:40 <vikaton> seems interesting from afar
19:57:48 <exio4> vikaton: beware of the haskell road, it may end as a gateway drug to even fancier things!
19:58:13 <vikaton> whats fancier than haskell?
19:58:14 <exio4> vikaton: you might end liking it too much and trying to use it everywhere! :P 
19:58:28 <vikaton> that is a possibility
19:58:51 * Iceland_jack . o O ( I guess â€˜inversionâ€™ rather than â€˜converseâ€™ )
19:58:59 <Iceland_jack> vikaton: I started learning Haskell to prove Haskellers wrong
19:59:05 <srhb> vikaton: Agda, Idris, dependent types in general. These are the roads to which Haskell lead.
19:59:13 <vikaton> O
19:59:19 <srhb> vikaton: We all fall in love with types to a degree where we want them stronger and better :P
19:59:20 <exio4> vikaton: it was just a joke, as there are things "past Haskell" (dependent types, the underlying theory, ...)
19:59:20 <Iceland_jack> I couldn't believe there was a language with all the benefits touted online
19:59:33 <Zekka> vikaton: Disclaimer: I like types less than I did when I started learning Haskell
19:59:36 <Zekka> But I still like Haskell
20:00:36 <exio4> Iceland_jack: Haskell is tough at that, it's far from perfect, yet, makes other languages feel like assembly :p 
20:00:40 <Zekka> #haskell is going to be more favorable about Haskell than any other community you ask for obvious reasons, but not unreasonably imho
20:02:32 <srhb> We should have an anti channel
20:02:34 <Iceland_jack> #haskell is certainly biased but people around here tend to be honest about technical and architectural problems with the Haskell language or implementations
20:02:36 <srhb> Who hates haskell the most?
20:02:46 <srhb> Then we could send people there to get dissuaded for ruining themselves with Haskell. :-)
20:02:48 <definity> I'm reading up about the Type Class and I'm getting slightly confused. I know its nothing to do with OOP but in my book it says it is an interface, what does it mean a interface? Like a Java interface?
20:02:57 <srhb> definity: Sort of.
20:03:05 <srhb> definity: It allows you to ad hoc overload methods.
20:03:14 <Zekka> I don't know, I know some incredibly bitter Prolog programmers and a PHP dev who hate Haskell
20:03:16 <srhb> definity: For instance, we can use (+) on many numerical types
20:03:18 <Zekka> But not enough to generalize
20:03:18 <srhb> :t (+)
20:03:19 <lambdabot> Num a => a -> a -> a
20:03:26 <vikaton> whoa
20:03:30 <vikaton> a lambdab0t
20:03:35 <srhb> definity: Any type a that implements Num can be added together with (+)
20:03:37 <Cale> :S well, it's not quite ad-hoc polymorphism either
20:03:38 <vikaton> is it written in haskal
20:03:42 <Zekka> Haskell is the pretentious typed language, Prolog is the pretentious untyped language -- naturally they're going to disagree about stuff!
20:03:48 <Zekka> vikaton: Yeah, the source code is on github IIRC
20:04:01 <Iceland_jack> definity: This is the "interface" for comparing if two things are equal (slight simplification of actual code)
20:04:01 <Iceland_jack>     clasee Eq x where
20:04:01 <Iceland_jack>       (==) :: x -> x -> x
20:04:12 <Zekka> definity: Do you know what traits are? That's the analogous feature in OOP languages
20:04:15 <vikaton> :t putStrLn "hi"
20:04:16 <lambdabot> IO ()
20:04:17 <dolio> Are they not even using lambda prolog?
20:04:23 <vikaton> :putStrLn "hi"
20:04:28 <Zekka> dolio: Lambda prolog? I don't know what that is
20:04:29 <srhb> vikaton: lambdabot does not execute IO
20:04:35 <Cale> > putStrLn "hi"
20:04:36 <lambdabot>  <IO ()>
20:04:40 <vikaton> awe :[
20:04:42 <srhb> > "Hello there!"
20:04:42 <Zekka> I'm not much of a prolog programmer myself
20:04:43 <lambdabot>  "Hello there!"
20:04:47 <srhb> Strings are fine.
20:04:49 <srhb> :-)
20:04:58 <Iceland_jack> > text "same thing"
20:04:59 <lambdabot>  same thing
20:05:02 <exio4> anything that could be printed
20:05:03 <Zekka> :t text
20:05:04 <lambdabot> String -> Doc
20:05:07 <exio4> > Just (2+2)
20:05:08 <lambdabot>  Just 4
20:05:11 <srhb> > BS.Pack "Bytestrings, too?"
20:05:13 <lambdabot>      Not in scope: data constructor â€˜BS.Packâ€™
20:05:13 <lambdabot>      Perhaps you meant one of these:
20:05:13 <lambdabot>        variable â€˜BS.packâ€™ (imported from Data.ByteString),
20:05:13 <vikaton> what
20:05:18 <srhb> > BS.pack "Bytestrings, too?"
20:05:19 <lambdabot>      Couldn't match type â€˜Charâ€™ with â€˜Word8â€™
20:05:19 <lambdabot>      Expected type: [Word8]
20:05:19 <lambdabot>        Actual type: [Char]
20:05:21 <vikaton> the heck is 'Just'
20:05:23 <srhb> Good!
20:05:26 <srhb> @src Maybe
20:05:26 <lambdabot> data Maybe a = Nothing | Just a
20:05:30 <Iceland_jack> > Just (2+2) & show & text
20:05:32 <Cale> > BSC.pack "Bytestrings, too?"
20:05:32 <lambdabot>  Just 4
20:05:33 <lambdabot>  "Bytestrings, too?"
20:05:40 <srhb> Cale: Ah, there it is.
20:05:41 <Zekka> > text "Doc" >> text "isn't" >> text "a" >> text "monad" >> text "though" >> text "so" >> text "this" >> "won't" >> "work"
20:05:42 <lambdabot>      Couldn't match expected type â€˜[a6]â€™ with actual type â€˜Docâ€™
20:05:42 <lambdabot>      In the first argument of â€˜(>>)â€™, namely â€˜text "Doc"â€™
20:05:42 <lambdabot>      In the first argument of â€˜(>>)â€™, namely
20:05:51 <Cale> vikaton: Just is one of the two constructors for the Maybe data type
20:05:52 <definity> srhb: No, I dont know traits, I've barely started learning about functions in haskell
20:05:54 <Zekka> vikaton: You probably haven't gotten there yet
20:05:56 <srhb> Zekka: Is a monoid though...
20:06:01 <Cale> vikaton: data Maybe a = Nothing | Just a
20:06:06 <srhb> definity: I didn't ask about that.
20:06:10 <Zekka> srhb: Yeah, I just mean you can't find/replace putStrLn for text or anything
20:06:10 <vikaton> I dont even know what Maybe is
20:06:12 <srhb> definity: Maybe someone else did :-)
20:06:13 <Iceland_jack> definity: Learn more about functions until you have a pretty solid feel for them
20:06:15 <vikaton> I'm scared :((
20:06:20 <Zekka> srhb: I think he thought it was me
20:06:24 <srhb> Ah. :)
20:06:28 <Zekka> srhb: er, it was you when it was me*
20:06:31 <Cale> vikaton: A value of type Maybe t is either the value Nothing, or it is Just x for some x of type t.
20:06:35 <vikaton> Haskell seems like a whole different universe
20:06:35 <definity> Zekka: Yeah I did
20:06:45 <definity> srhb: Sorry.
20:06:52 <Cale> vikaton: So for example, Nothing, Just 5, Just 11, Just (-23) are all examples of values of type Maybe Integer
20:06:52 <Zekka> vikaton: Maybe is one of the ways Haskell can handle errors
20:07:06 <lamefun> Why isn't there maybeReadP :: ReadP a -> String -> Maybe a that runs p >>= ReadP.eof?
20:07:12 <definity> So can Haskell have Classes?
20:07:15 <Zekka> You work with it the way Cale is telling you (although you might not be working with it right now)
20:07:20 <srhb> definity: Not in the usual sense.
20:07:25 <vikaton> I can feel myself being sucked into the Pure FP world
20:07:26 <Iceland_jack> lamefun: there is readMaybe
20:07:28 <Zekka> definity: It doesn't really have a direct analogue, although dependding on what you want you can get some of the features
20:07:41 <definity> What about more in the evreything is static sense?
20:07:52 <srhb> definity: I don't know what that means.
20:07:53 <simon> definity, what sense is that?
20:07:53 <Zekka> You can get some of the stuff you want from inheritance through typeclasses, you can get name/value mappings through records
20:08:03 <Iceland_jack> lamefun: in Text.Read
20:08:04 <Cale> definity: Uh, classes in OO are just data types
20:08:08 <Cale> definity: pretty much
20:08:09 <lamefun> Iceland_jack, i meant for this: https://hackage.haskell.org/package/base-4.8.0.0/docs/Text-ParserCombinators-ReadP.html
20:08:13 <Zekka> You can get something close to methods through records too but it's not idiomatic
20:08:13 <simon> definity, static classes are sort of like modules, right?
20:08:15 <Iceland_jack> I see
20:08:19 <Cale> definity: You can define a record type whose fields are functions.
20:08:32 <definity> So you dont need to create an instance of a class to access it methods, if it is static you jsut call the methods
20:08:38 <lamefun> readMaybe is (Read a) => String -> Maybe a (not ReadP)
20:08:45 <srhb> definity: That's not how it works at all
20:08:46 <simon> definity, like, containers for functions and constants. you'd just put those in a single file and write 'module Foo where ...' at the top.
20:08:53 <Cale> definity: which sort of gives you an "abstract base class" from an OO perspective
20:08:54 <srhb> definity: Don't try to apply those concepts in Haskell. :)
20:09:14 <Zekka> definity: Haskell doesn't have a "this" reference if that's what you're asking about -- all functions are "static" in the sense that you don't need a value of any particular data type to refer to them
20:09:18 <Cale> definity: and then you can define functions which build values of that type by constructing records, filling in the fields with functions of appropriate types
20:09:32 <tejing> definity: if you're familiar with ruby, you could think of typeclasses as like mixins, but simpler since there's no mutable state inside objects to worry about
20:09:35 <Cale> definity: and that basically gives you "concrete subclasses" of that
20:09:38 <Zekka> But functions you write won't work unless you have a value of the type you want
20:09:45 <definity> like Generic static methods?
20:10:01 <Zekka> definity: That's one of the things you can simulate with Haskell's type system
20:10:10 <Cale> I think we all seem to disagree about what the correct answer is here :)
20:10:16 <Zekka> definity: You know how in Java you can take the .size() of a List<T>?
20:10:17 <Cale> It's probably confusing
20:10:37 <exio4> I still haven't found anything to compare typeclasses with such that they make sense
20:10:39 <Zekka> In Haskell you have a function 'length' which you can refer to whenever you want, and you can feed it a list of anything
20:10:41 <definity> Zekka: yeah
20:10:44 <simon> definity, 'generics' is like polymorphism. but really, just learn it from the bottom up rather than trying to find parallels to imperative/OO programming. =)
20:10:52 <Cale> Anyway, you can do OOP quite easily in Haskell, because you have first class functions and data types. Type classes are not required.
20:11:04 <srhb> I think "not" relating it to other concepts is the way to go, but yeah, I guess we disagree.
20:11:05 <tejing> exio4: agreed. there are no truly good analogies
20:11:10 <Zekka> generics are a certain way to make polymorphic code safe: Haskell has a close analogue
20:11:20 <lamefun> Is there a Haskell forum?
20:11:23 <Zekka> I prefer not to make analogies but when other people make analogies I try to talk through them
20:11:27 <Zekka> lamefun: There's r/haskell
20:11:30 <Cale> lamefun: There's the mailing lists
20:11:35 <Cale> lamefun: and the subreddit
20:11:36 <srhb> Aaaand there's SO for some things.
20:11:37 <simon> lamefun, and StackOverflow.
20:12:26 <definity> Hmmm I agree, You can compare it with other languages, I'll just keep on with my book.
20:12:53 <Zekka> definity / vikaton: I guess the issue with asking "does Haskell have this OO feature" is because Haskell usually has multiple features that can together express a simple OO feature and Haskell's features often take multiple OO features to express
20:12:57 <srhb> definity: :-)
20:13:12 <Zekka> It's like looking at two puzzles with the same picture but different pieces
20:13:14 <srhb> And sometimes they are inexpressible.
20:13:18 <srhb> Like, subtyping is really messy.
20:13:33 <tejing> definity: there's something important to note about haskell: you can't make polymorphic functions that use a different definition for different types, unless that function is attached to a typeclass
20:13:33 <Cale> Yeah, one thing which Haskell doesn't have is subtyping.
20:13:59 <definity> tejing: Ahhhhh I seee :-D Thanks
20:14:01 <tejing> definity: so there are only 3 possible values of type 'a -> a': id, const undefined, and undefined
20:14:04 <Cale> However, when encoding OOP in Haskell using the simple way I outlined, you also quickly find out that subtyping is overrated.
20:14:08 <Zekka> srhb: You can capture a lot of what you want to capture with subtyping by using record tricks or typeclass tricks -- you're not getting back subtyping though, just a lot of places where you would usually use subtyping
20:14:43 <Rotaerk> inheritance is overemphasized in traditional OOP education
20:14:57 <Zekka> You can make "abcdef" with parts of "abcd" and "cdef" but you can't make "abcd" out of "cdef"
20:14:58 <Cale> The main thing which makes subtyping so valuable in OO languages is that these languages have all made the (imo questionable) decision to tie method implementations to the class declaration.
20:15:00 <Rotaerk> though OOP education is generally shit
20:15:02 <tejing> definity: that was the realization that made typeclasses 'click' for me... thought it might help
20:15:17 <Cale> So in order to change the implementation of the methods, you *must* make a subclass.
20:15:20 <Rotaerk> "What is OOP?" "uh... encapsulation, polymorphism, inheritance??"
20:15:32 <definity> So you can define a function to behave diffrently depending on what type it recives if you use type classes. E.g if it is Bool then do action A, but if it is an Integer do action B
20:15:44 <definity> tejing: Yeah it did thanks!
20:15:48 <srhb> definity: fsvo action
20:16:12 <Cale> definity: Yes, though the selection is made statically at compile time, of course.
20:16:36 <definity> Cool! Thanks for the help guys :)
20:16:53 <Zekka> definity: Yeah, think of yourself as having a separate version of a function for each type you instantiate the typeclass for
20:16:56 <Cale> definity: The other thing which type classes give you, which is above and beyond ordinary ad-hoc polymorphism, is the ability to define new type class polymorphic things by simply using existing ones.
20:17:33 <Cale> definity: For example, we only have to define sort :: (Ord a) => [a] -> [a] once, and that same definition works for every type which is made an instance of Ord by defining (<=)
20:17:58 <Cale> > sort [1,5,3,8,0]
20:18:00 <lambdabot>  [0,1,3,5,8]
20:18:03 <lamefun> > readMaybe "52157012575012710592712509152935958109590" :: Maybe Word
20:18:04 <lambdabot>  Not in scope: â€˜readMaybeâ€™
20:18:08 <definity> Woah, You could build some pretty deep nested types.
20:18:15 <Cale> > sort ["here", "is", "a", "list", "of", "words"]
20:18:16 <lambdabot>  ["a","here","is","list","of","words"]
20:18:28 * hackagebot cron 0.3.0 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-0.3.0 (MichaelXavier)
20:18:32 <Cale> > sort [["here", "is", "a", "list", "of", "words"], ["and", "here", "is", "another"]]
20:18:33 <lambdabot>  [["and","here","is","another"],["here","is","a","list","of","words"]]
20:19:08 <Cale> Also present implicitly in this demo is the use of some instances of Ord which rely on other instances of Ord
20:19:11 <Cale> There's an instance:
20:19:13 <lamefun> > read "52157012575012710592712509152935958109590" :: Word
20:19:14 <lambdabot>  16098679230958755222
20:19:18 <Cale> instance Ord a => Ord [a] where ...
20:19:20 <lamefun> Why nonsense instead of error?
20:19:36 <srhb> lamefun: It's overflow. 
20:19:46 <srhb> lamefun: There are safer types if you don't mind the extra checks
20:19:52 <srhb> lamefun: Didn't you ask about this yesterday, too? :)
20:20:19 <lamefun> I did but I thought that at least read will error out instead of spouting nonsense...
20:20:25 <Cale> lamefun: It's just the result modulo 2^64
20:20:46 <definity> :t (==)
20:20:47 <lambdabot> Eq a => a -> a -> Bool
20:21:01 <koshmar> hey, is foldl and foldr has the same speed?
20:21:05 <Cale> All arithmetic on Word is done modulo 2^n where n is the number of bits in a machine word.
20:21:10 <srhb> koshmar: That's not easy to answer. It depends.
20:21:13 <srhb> koshmar: Often no.
20:21:18 <Cale> This includes the arithmetic done when parsing values from strings.
20:21:25 <simon> koshmar, http://stackoverflow.com/questions/3429634/foldl-is-tail-recursive-so-how-come-foldr-runs-faster-than-foldl
20:21:48 <Cale> koshmar: They do different things...
20:22:02 <koshmar> thanks
20:22:08 <alisia> can I extend hamlet tempates?
20:22:10 <Cale> koshmar: foldr can be infinitely faster than foldl
20:22:21 <Cale> @src foldr
20:22:22 <lambdabot> foldr f z []     = z
20:22:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:22:35 <Cale> ^^ you can see here that in the nonempty list case, foldr immediately passes control to f
20:22:52 <Cale> only if and when f examines (pattern matches) its second argument, will the foldr continue
20:23:04 <Cale> @src foldl
20:23:04 <lambdabot> foldl f z []     = z
20:23:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:23:25 <Cale> ^^ on the other hand, foldl greedily passes control to itself (with new arguments) until it finds the end of the list
20:23:32 <lamefun> So Haskell is becoming outdated :(?
20:23:37 <Cale> So foldr can operate on and infinite list, while foldl can't.
20:23:49 <Cale> lamefun: What's with the lame attempts at trolling?
20:23:51 <simon> Haskell outdates itself.
20:24:34 <Cale> lamefun: At least try to be entertaining if you're going to troll... how are we supposed to make a bot command out of this?
20:24:36 <Cale> @keal
20:24:36 <lambdabot> i want to invent white dye
20:24:38 <Cale> @keal
20:24:38 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
20:24:43 <Cale> @keal
20:24:43 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
20:25:04 <simon> who's keal?
20:25:09 <catern> dear #haskell, should I use this "halcyon" thing?
20:25:12 <Cale> A crazy troll from a long time ago
20:25:18 <catern>  /noob
20:26:20 <dolio> protontorpedo wasn't really that entertaining.
20:26:36 <Cale> catern: I haven't tried it yet. It's new and probably worth trying.
20:28:19 <saulzar_> Somehow Haskell attracts some nutters, though perhaps that's programing in general
20:28:33 <srhb> saulzar_: I take pride in being a nut!
20:28:44 <saulzar_> (Doubtful that any of those nutters worthy of a bot command actually used Haskell, mind you)
20:28:58 <lamefun> What's the reasoning behind Word and Int looping over on overflows?
20:29:06 <srhb> lamefun: The alternative means checking
20:29:10 <srhb> lamefun: Checking is costly.
20:29:34 <Cale> lamefun: That's what your CPU does.
20:30:09 <Cale> lamefun: The most natural hardware implementation of binary arithmetic with logic gates naturally overflows.
20:30:18 <srhb> I wonder how badly a system with OS and software and all would break if I plugged in a CPU that just stopped at the largest or smallest value rather than rolling over.
20:30:33 <Cale> ohohoho
20:30:35 <srhb> Mhm. :P
20:30:39 <catern> dear #haskell, if I wanted to install https://github.com/nominolo/scion so I can use it from emacs, and I have require-sandbox: true, what is the proper thing to do?
20:30:42 <saulzar_> You'd need to rewrite large sections of most C code...
20:30:57 <srhb> saulzar_: That would fix the breakage!
20:31:56 <Cale> Well, not even just the most natural one, but essentially all of them naturally work modulo 2^n for some n.
20:32:00 <DNoved1> lamefun: If you don't want overflow, why not use Integer?
20:32:25 <saulzar_> Is it actually specified anywhere that C integers are two's complement?
20:32:37 <definity> Is Haskell a big language?
20:32:43 <DNoved1> saul: nope, it's undefined
20:32:44 <Cale> Yeah, you use Int only when you a) know there won't be overflow, or b) you actually want arithmetic modulo 2^n
20:32:44 <saulzar_> Yes
20:33:07 <Cale> and most of the time if b is the case, you'd rather use a specifically sized Int type, like Int32 or Int64
20:33:10 <srhb> definity: How do you define a language's size?
20:33:17 <saulzar_> So I guess that means almost all real software out there is relying on this undefined behavior, if someone made such a CPU it would be funny...
20:33:21 <srhb> definity: It's quite simple in its definition.
20:33:29 * hackagebot range 0.1.1.0 - This has a bunch of code for specifying and managing ranges in your code.  http://hackage.haskell.org/package/range-0.1.1.0 (RobertMassaioli)
20:33:36 <srhb> definity: On the other hand the most used compiler is hugely complex and heavy.
20:33:42 <DNoved1> saul: It's like how a lot of software assumes a char is 8 bits
20:34:01 <DNoved1> It could be 17 for all the C standard cares
20:34:02 <saulzar_> True
20:34:10 <lamefun> DNoved1, because that's what length returns?
20:34:25 <saulzar_> How would you actually write sane software without making such assmptions?
20:34:48 <definity> srhb: Well for isntance C is pretty small but Java can be pretty big with all the included classes.
20:34:59 <srhb> definity: So you're talking about standard library?
20:35:10 <srhb> definity: https://hackage.haskell.org/package/base -- this is ours.
20:35:10 <Cale> definity: Just as a rough comparison, I once did a page count on the Haskell Report and the GHC User's Guide and compared it with the C++ specification, and iirc, it was somewhere around 1/5 the size.
20:35:40 <Cale> (this says more about C++ than it does Haskell though)
20:35:42 <exio4> Cale: that's an unfair one, compare Haskell with Scheme! :P 
20:35:43 <definity> Okay cool.
20:36:15 <DNoved1> lamefun: length, as in length defined on lists? I think you'd run out of room to store the list in memory before you hit the max int value.
20:37:15 <Rotaerk> hmm, isn't haskell the language itself fairly simple?
20:37:27 <Rotaerk> seems like most of the difficulty with learning it comes from all the stuff built upon it
20:37:31 <Cale> Rotaerk: It depends on what your standard for simple is.
20:37:31 <saulzar_> This is why I'm amazed that ghcjs works at all, given how many packages/infastructure relies on the Haskell FFI being C
20:37:56 <Cale> The syntax is a lot more complicated than the syntax of some lisp-like languages, for instance.
20:38:20 <srhb> Rotaerk: It's true that a lot of the complexity in other languages is simply relegated to libraries in Haskell.
20:38:22 <srhb> Which is nice.
20:38:39 <Rotaerk> in other languages, people don't do nearly as much abstraction as is done in haskell
20:38:49 <Rotaerk> most of the code is written in terms of the raw mechanisms, like loops
20:38:53 <Cale> DNoved1: That's not entirely true.
20:38:58 <srhb> Rotaerk: In many other languages, you cannot define if, or, and...
20:39:11 <catsup> how can i get rid of the warning about defaulting to 'double' for where i'm using fromIntegral and then rounding back to an integral ... tersely
20:39:27 <Cale> DNoved1: On a 32 bit machine, you can easily overflow using length in a small amount of constant space.
20:39:55 <srhb> catsup: It doesn't get very terse if you're going back and forth. You'll have to explicitly use :: Double mid-way
20:40:38 <Cale> DNoved1: (remember that lists are lazy, and can come into existence one cell at a time, and if the length is the only thing consuming them, the cells immediately become garbage)
20:41:14 <Cale> On a 64 bit machine, it's harder to overflow using length just because the amount of time required to do so is probably longer than the age of the universe.
20:42:13 <Cale> eh, maybe not actually
20:42:19 <Cale> Having done the calculation :)
20:42:27 <catsup> is there a compiler option to disable that warning, i can't imagine ever caring
20:42:30 <Cale> (but it's still a really long time)
20:42:44 <lamefun> > [1,2,3] !! (2 + 9223372036854775807 + 9223372036854775807)
20:42:45 <lambdabot>  1
20:42:53 <DNoved1> Technically, but I can't think of many situations where it'd be desirable for the length function to be the only consumer of a 2^16 or more sized list
20:43:14 <Cale> DNoved1: yes, this is true.
20:43:18 <definity> :t (>)
20:43:19 <lambdabot> Ord a => a -> a -> Bool
20:43:24 <srhb> catsup: -fnowarn-type-defaults -- I think
20:43:29 <definity> What does the Ord a mean?
20:43:30 <Cale> DNoved1: Counting the number of certain combinatorial objects, you can kind of get up there.
20:43:49 <srhb> definity: That a must implement the Ord type class, ie it is a type with ordering
20:43:55 <Cale> definity: That's a type class constraint
20:43:57 <kadoban> Ord is a typeclass, of things that can be compared for ordering
20:43:59 <definity> I know it from the type class ord
20:44:28 <Cale> When you see something like  sort :: (Ord a) => [a] -> [a], it means that for any type a which is an instance of Ord, sort can take a list of values of type a and produce a list of the same type.
20:44:44 <lamefun> "lamefun: Checking is costly." - Swift uses special operators like &+ and &- to disable checking, but checks normal + and -, Rust seems to error out in debug mode with "arithmetic operation overflowed" and has (unstable) OverflowingOps.
20:44:50 <catsup> srhb: ah yep, that'll do, thanks much
20:44:53 <Cale> The constraints to the left of the => serve to restrict which types the type variables are allowed to range over.
20:44:55 <srhb> catsup: Sure :)
20:45:06 <srhb> lamefun: And we use different types for it.
20:45:14 <definity> So when I use '>' it checks the types and then uses the right function for the expression?
20:45:30 <definity> out of the Ord Type Class?
20:45:38 <srhb> definity: Not quite. The program would not compile if you tried to give it an argument that does not have an Ord instance
20:45:39 <Cale> definity: Yes, the typechecker is involved in determining which implementation of (>) to use.
20:45:48 <srhb> definity: If it does, that concrete instance will be used (for whatever type is picked)
20:46:24 <definity> so if it was Integer it would get the function for 2 Integers where as if it was double it would use one defined for doubles?
20:46:29 <srhb> Yes
20:46:30 <Cale> That's right.
20:46:43 <definity> Ahh I see :D
20:46:54 <Cale> definity: and note that, for example...
20:47:09 <Cale> :t let f x y = if x < y then "less" else "not less" in f
20:47:10 <lambdabot> Ord a => a -> a -> [Char]
20:47:23 <Cale> The decision can be deferred until later :)
20:47:27 <DNoved1> Hmm, speaking of =>, has there ever been a proposal for an extension allowing explicit typeclass parameters? It would be handy I think, basically subsuming things like the *By functions (nubBy  and co.)
20:47:52 <Cale> DNoved1: Uh, well, there's implicit parameters
20:47:54 <definity> So Ord
20:47:58 <KaneTW> around 2000 years for a int64 to overflow using increments only on this machine :D
20:48:04 <lamefun> srhb, but most containers use the wrapping one, even if I use Integer in most of my code I'll still have to check bounds when doing (fromInteger int) because it wraps around as well.
20:48:06 <Cale> DNoved1: and there are proposals to allow explicit *type* applications
20:48:16 <Cale> DNoved1: But not explicitly filling in the type class dictionaries
20:48:23 <DNoved1> Hmm
20:48:24 <srhb> definity: By the way, you can probe type classes for their methods and members with :info Ord in ghci
20:48:35 <srhb> lamefun: ... ok
20:48:39 <srhb> lamefun: I'm done :P
20:48:41 <DNoved1> It would also eliminate one of the main needs for newtypes
20:48:41 <Cale> DNoved1: It is a very important property of type classes that there is at most one of any given instance.
20:49:11 <Cale> DNoved1: So if you get an instance of some class C for some type T from two different places, you know they're actually the same instance, and it doesn't matter which one you use.
20:49:19 <definity> *So 'Ord a' is like giving a the functions defined in Ord availible to a, like overloading
20:49:30 <srhb> definity: Ish. I wouldn't phrase it like that.
20:49:42 <definity> srhb: thanks that usefull :). ahh okay
20:49:44 <srhb> definity: I would say, the function works on arguments of type a for which there is an Ord instance.
20:50:04 <DNoved1> Cale: Interesting, I'll have to read into it more to fully understand
20:50:15 <Cale> definity: If you want, you can imagine that what the compiler is doing is making a record datatype with the methods of the Ord type class as fields, and when you have a constraint like Ord a => ..., this is translated into an additional function parameter  OrdRec a -> ...
20:50:22 <srhb> definity: We're not giving anyone anything, the instance has to be there for the a to be used without having a type error
20:51:10 <Cale> definity: and when you *use* something which is type class polymorphic, the function parameter is automatically filled in -- either with something obtained by adding another parameter to the thing being defined, or with a concrete instance if the type is specific
20:51:37 <Cale> s/the function parameter is automatically filled in/the function argument is automatically filled in/
20:55:04 <Cale> So, for example, if the type is [Integer], it will go and look for an instance of Ord for [a], and it'll find the instance Ord a => Ord [a], which itself has been translated into a function listOrdInst :: OrdRec a -> OrdRec [a], and it will then go looking for an instance of Ord for Integer, which it will find, and have compiled to some value integerOrdInst :: OrdRec Integer
20:55:40 <Cale> and so it'll supply  listOrdInst integerOrdInst :: OrdRec [Integer]
20:56:25 <Cale> Where OrdRec is our imaginary made up record datatype whose fields are the operations of the Ord class, like
20:56:42 <tejing> Cale: I think getting into the dictionary-passing implementation is probably confusing the issue more than helping it
20:56:44 <Cale> data OrdRec a = OrdRec { (<) :: a -> a -> Bool , ... etc ... }
20:56:50 <Cale> Well, maybe
20:57:08 <definity> Yeah this si getting quite complex
20:57:12 <definity> for my little brain
20:57:14 <Cale> Sometimes it's nice to have some idea in your head about what the compiler is going to do to implement things
20:57:34 <srhb> Things can Caleskelate quickly.
20:57:36 <srhb> :-)
20:57:47 <definity> Thanks for the help though :) muc appreciated
20:57:48 <tejing> Cale: and it's largely irrelevant until you start getting into some of the extensions like rank2types
20:58:17 <srhb> tejing: Did you just... One-up the geekery after saying it might be too confusing? :D
20:58:26 <exio4> it's always irrelevant if you don't care about it, I think
20:58:28 <Cale> But if you prefer, you can just imagine that the type classes are predicates on types (i.e. things which are either true or false of any given type, depending on whether there's an instance), and when you have a constraint, it just means that whichever type you choose, it's got to be an instance of that class
20:58:30 * hackagebot mockery 0.2.1 - Support functions for automated testing  http://hackage.haskell.org/package/mockery-0.2.1 (SimonHengel)
20:58:39 * tejing looks sheepish
20:58:43 * srhb snickers
20:59:14 <Cale> definity: But this is a nice contrast from OO
20:59:24 <Cale> definity: In OO, the methods travel along with the data
20:59:41 <definity> Yeah
20:59:44 <Cale> definity: with type classes, the methods travel separately from the data they act on, so you can do things you couldn't do
20:59:47 <Cale> :t read
20:59:47 <lambdabot> Read a => String -> a
21:00:02 <Cale> ^^ like having operations which are polymorphic only in the type of the result they produce
21:00:19 <Cale> > read "[1,2,3]" :: [Integer]
21:00:20 <lambdabot>  [1,2,3]
21:00:29 <definity> Cool
21:00:31 <tejing> the methods travel with the types instead of the data, basically
21:00:44 <Cale> > read "[(1,'a'),(2,'b')]" :: [(Integer, Char)] -- the parser to use is computed from the type
21:00:45 <lambdabot>  [(1,'a'),(2,'b')]
21:01:15 <Cale> > 1 + read "6"
21:01:17 <lambdabot>  7
21:01:36 <Cale> ^^ the type can even be inferred (here I'm using numeric defaulting to Integer as well)
21:03:25 <Cale> definity: another thing that type classes can do is to abstract over operations on data types that themselves have type parameters -- that's a mouthful, so I'll provide an example
21:03:29 <Cale> definity: We have
21:03:33 <Cale> class Functor f where
21:03:40 <Cale>   fmap :: (a -> b) -> f a -> f b
21:04:04 <Cale> This is a generalisation of the map function which applies a given function to all the elements of a list.
21:04:19 <Cale> So for instance, we might define a data type for binary trees:
21:04:29 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
21:04:37 <Cale> and then make that an instance of Functor:
21:04:42 <Cale> instance Functor Tree where
21:04:45 <Cale>   fmap f Tip = Tip
21:04:56 <Cale>   fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)
21:05:51 <Cale> definity: While Java for instance has "generics" that let you have types with type parameters, it's not so easy to abstract over operations like that.
21:06:21 <Cale> (at least, last time I checked -- Java might've stolen more ideas from Haskell since then)
21:06:43 <dolio> Nope.
21:07:10 <tejing> now he's primed... show him the type level fixpoint operator and his head should promptly explode :-P
21:07:17 <definity> The syntax was over my head but i understood what you were doing :)
21:07:35 <Cale> (The guy who was originally responsible for generics in Java was our own Philip Wadler)
21:09:06 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a) -- this says, for any type a, the values of type Tree a are all either the simple constant Tip, or they are formed by applying Branch to arguments of type a, Tree a, and Tree a respectively.
21:09:19 <Cale> (i.e. the value on the branch node, and then the two subtrees)
21:10:02 <Cale> So for example,  Branch 3 (Branch 2 Tip Tip) (Branch 8 Tip Tip) :: Tree Integer
21:10:16 <pacak> It's more fun to use Tree a b = Tip | Branch a b b instead
21:10:49 <Cale> pacak: Then you'd need the type level fixpoint combinator which was previously alluded to :D
21:11:12 <pacak> Cale: Yea, but you'll get Functor instance and a bunch of other nice stuff.
21:11:27 <pacak> :t cata
21:11:28 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
21:11:35 <pacak> :t ana
21:11:36 <lambdabot>     Not in scope: â€˜anaâ€™
21:11:36 <lambdabot>     Perhaps you meant one of these:
21:11:36 <lambdabot>       â€˜andâ€™ (imported from Data.List), â€˜anyâ€™ (imported from Data.List),
21:11:38 <pacak> :(
21:11:54 <Cale> Sure. You can approximate the fun you'd get though, by simply writing at least the catamorphism by hand.
21:12:11 <pacak> :k Cofree
21:12:12 <lambdabot> Not in scope: type constructor or class â€˜Cofreeâ€™
21:12:16 <pacak> :'(\
21:12:18 <pacak> :'(
21:12:20 <Cale> foldTree t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
21:12:43 <Cale> fmap f = foldTree Tip (Branch . f)
21:13:15 <Cale> definity: (don't worry if all this makes no sense now :D)
21:14:15 <pacak> Cale: But you use map and fold instead of writing them by hand. cata/ana is similar abstraction.
21:14:21 <definity> Okay, I think i need to learn more math to understand this better
21:14:32 <pacak> definity: Not just math.
21:14:39 <pacak> definity: It's called Abstract nonsense.
21:14:41 <definity> would learning Lamda calculus help me understand the language better?
21:14:57 <Cale> definity: Don't worry about it, you'll pick up what you need as you go.
21:15:37 <Cale> definity: Unless you already have an interest in mathematics, in which case, you might want to learn some category theory eventually. The recursion theory stuff is sort of its own separate thing though.
21:15:56 <Cale> (You'd learn more about it reading papers about functional programming than about pure mathematics)
21:16:24 <Cale> You'll learn everything you need to know about lambda calculus just learning Haskell.
21:16:27 <lamefun> "lamefun: What's with the lame attempts at trolling?" - why did Swift add int overflow checking by default (AFAIK they also have array bound checking) then? I can think of (list !! x + a + b + c) where a, b and c are user input and were only checked >= 0, so by supplying large values users can access list elements below x. I admit that's quite pathological, but why else would Apple add &+ to Swift? 
21:16:42 <Cale> Haskell can sort of be seen as a really fancy lambda calculus with all sorts of extra widgets.
21:17:07 <pacak> Cale: Actually it helps if you learn both at the same time. Deriving monads from adjunctions from haskell point of view is hard, but from  CT side it's nice and fluffy.
21:17:10 <definity> Cale: Even more reason to learn it )
21:17:14 <tejing> Cale: typed lambda calculus
21:17:16 <definity> :)*
21:17:45 <Cale> lamefun: Well, it's a design choice. In Haskell if you want to sacrifice some performance in order to get better correctness, you can just use the Integer type instead of Int.
21:18:30 <Cale> lamefun: I suppose it wasn't seen as important to provide the third option of not being able to represent large integer values, while at the same time checking for overflow and producing an error on failure.
21:18:54 <Cale> lamefun: You could certainly define such a type and make your own instance of Num for it.
21:19:10 <scutigera> does anybody find it slightly depressing that so many haskell-y companies are engaged in financial engineering...
21:19:26 <Cale> scutigera: Why depressing?
21:19:28 <dolio> It's already been done in some library that almost no one uses, as I recall.
21:20:20 <pacak> scutigera: Why? Making money with Haskell is fun.
21:21:10 <tejing> what module defines Mu?
21:21:17 <nshepperd> clearly it would be better if haskell startups were doing useful things like building cat picture websites :)
21:21:22 <scutigera> Cale: you're right. nothing depressing about it at all.  i just finished watching margin call. i'm over it now. can't wait for the next financial crisis to be brought on by a trading program written in haskell.
21:21:31 <Cale> scutigera: Financial engineering does seem like a very good application for a functional programming approach. You can represent financial contracts with a recursive combinator language, and provide many compilers which transform them into English language contracts, or attempt to estimate their value in various ways.
21:21:55 <scutigera> oh i think it's an excellent application. but can't they work on curing cancer or something ?
21:21:58 <pacak> tejing: There are several. Data.Functor.Foldable is one of them. Or is it Control...
21:22:03 <scutigera> instead of high frequency trading ? lol
21:22:07 <Cale> scutigera: Perhaps if people have more sophisticated tools for analysing the contracts they write, various catastrophes will be easier to avoid.
21:22:18 <scutigera> yeah yeah capitalism. i'm just a pinky socialist.
21:22:38 <Cale> Even I'm a socialist, but I can see the value in financial engineering
21:23:03 <scutigera> oh- well, i absolutely don't
21:23:09 <Cale> and HFT for that matter
21:23:45 <scutigera> sorry- i'm being off-topicish. i'll stop now.
21:24:01 <Cale> HFT provides a service to the exchanges in the form of liquidity. When you want to buy or sell some stock, you will probably be able to do so promptly because of the HFTs
21:24:25 <scutigera> yes - you're right. without submillisecond trading civilization would collapse.
21:24:28 <Cale> HFTs actually make most of their money directly from the exchange, and not from the trades they make
21:24:39 <Cale> They're really just trying to break even on the trades
21:24:42 <dolio> I think stopping this conversation was a good idea.
21:24:52 <scutigera> yeah - me three.
21:24:54 <Cale> Yeah, or move to #haskell-blah
21:25:21 <GLM> Has anyone been to strangeloop or ICFP?
21:25:31 <scutigera> what's strangeloop ?
21:25:46 <pacak> GLM: I've been to ICFP
21:25:59 <pacak> scutigera: Another conference
21:26:02 <lamefun> "lamefun: I suppose it wasn't seen as important to provide..." - so historical reasons?
21:26:05 <scutigera> so i've been using numpy, a lot.
21:26:05 <GLM> pacak:Is it worth it?
21:26:26 <scutigera> and i really miss the matrix interface that it provides.
21:26:42 <pacak> GLM: Reading and rereading papers after that made more sense.
21:26:44 <scutigera> we have hmatrix - 2D only. repa - which i think can go back and forth with hmatrix now.
21:27:01 <scutigera> and has nice slicing operators - i think.. been a while since i looked at it.
21:27:10 <scutigera> are there any other possibilities i should look at ?
21:27:11 <GLM> pacak:So it is all about papers?
21:27:43 <pacak> GLM: And non-technical talks. By SPJ for example.
21:27:50 <scutigera> https://thestrangeloop.com/
21:28:11 <GLM> pacak:  Would I be able to justify it to my boss to pay for it?
21:28:23 <Cale> In any case, this talk by SPJ is what I usually recommend to people who ask about large scale functional programming design patterns, and it uses financial contracts as well as puddings as examples :) http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
21:28:31 * hackagebot angel 0.6.0 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.6.0 (MichaelXavier)
21:28:47 <pacak> GLM: Worked for me :)
21:28:51 <Cale> It might help to explain somewhat why Haskell is so popular in that space :)
21:29:20 <scutigera> strangeloop definitely looks pretty cool.
21:29:41 <GLM> pacak:Makes sense. I only get one per year so I want to make it count. We're a Java shop but trying to change that
21:30:32 <scutigera> lol- a  domain specific language for puddings...
21:32:02 <scutigera> oh i bring up FE again. Heard that DonS and the Standard gang wrote their own haskell compiler.  anybody have a clue as to the what/why of that ?
21:32:13 <scutigera> i expect closely guarded secret- but really curious.
21:33:23 <pacak> GLM: Also you can talk to a bunch of other people.
21:34:32 <pacak> It was fun talking to ruby guys. "How do you deal with memory leaks - we have a daemon which restarts our service, how do you deal with memory leans in that daemon - we have a cron job for that"
21:34:42 <scutigera> lol
21:34:46 <dmj`> scutigera: the compiler was written in haskell, the runtime system in C++, it's a strict variant called Mu haskell, they have >2M LOC IIRC. They even have a visual studio plugin pretty sure. Their build process is pretty elaborate I hear.
21:35:12 <dolio> It's so that you can write Haskell and run it in Excel, no?
21:35:15 <dolio> Something like that.
21:35:23 <scutigera> lol
21:35:37 <scutigera> omg - the amount of programming by exel out there is scary.
21:35:45 <scutigera> excel*
21:36:05 <johnw> Typed Excel
21:36:24 <scutigera> i see spreadsheets for data analysis that are much harder to write than any program. and much more bug-prone.
21:36:46 <scutigera> oh wait. you were serious about running haskell in excel ?
21:36:59 <scutigera> i thought that was a joke.
21:37:30 <dolio> No. Totally serious.
21:37:37 <scutigera> it's interesting that they give up laziness. i thought that was a substantial advantage in large projects...
21:37:41 <dolio> Maybe they use it for other stuff, but that's one thing.
21:37:42 <scutigera> wow. ok.
21:38:16 <dolio> The strictness makes some sense there, too, if they're mostly number crunching.
21:38:19 <dmj`> excel is huge in finance
21:38:24 <scutigera> oh sure it is.
21:38:48 <scutigera> certainly the majority of MBAs aren't going to be fluent in lazy and functional.
21:39:08 <Iceland_jack> Soon ... ;)
21:39:19 <dolio> Since it probably has to be used by domain experts instead of programmers, and you don't want to have to teach them when they need to put ! in their code.
21:39:38 <dolio> And don't want to implement optimistic evaluation or something.
21:39:43 <scutigera> lol.  heck i can't even figure out when to put ! in my code.
21:40:46 <dmj`> true, dons even said 'they're just composing functions' in the haskell cast
21:41:26 <scutigera> i wonder if it's strict by default - but you can turn on lazy. maybe with !
21:42:19 <scutigera> well the SPJ thing on FE is well worth reading. very interesting stuff.
21:42:47 <scutigera> interestingly he makes a big point about the advantage of lazy
21:43:32 * hackagebot simple-sendfile 0.2.21 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.21 (KazuYamamoto)
21:44:24 <scutigera> i've noticed that every once in a while a new hackage package is released and all those nifty links in the contents are missing.
21:44:57 <scutigera> is that due to a cabal-ism ? or is the maintainer just forgetting to set a flag or something...
21:45:05 <dmj`> scutigera: there's a process that builds the docs automatically, it will come
21:45:38 <scutigera> well repa for instance was last released apr 3, and the previous version has all the links.
21:46:11 <scutigera> but latest does not. short version: should i email maintainer and ask nicely for links ?
21:46:39 <scutigera> i know alberto was having some haddock issue that was causing problems for hmatrix.
21:47:17 <peddie> scutigera: you could download the code and build the haddocks yourself
21:48:29 <pacak> Does it makes sense to add IsNumeric (similar to IsString and whatever OverLoadedLists are called those days) for some stuff that look like numbers, but not really numbers? At the moment you have to create instances of Num full of stuff (*) = error "Can't multiply blah" ; (+) = error "Can't add blah" and so on.
21:48:38 <scutigera> so just grab it from git and run some cabal magic command ?
21:49:04 <peddie> scutigera: you could use 'cabal unpack' to get it and un-tar it, and 'cabal haddock' to build haddocks, I guess
21:49:55 <dmj`> scutigera: yea, 'cabal unpack repa', then 'cd repa && cabal haddock --hyperlink-source && open dist/doc/html/*/index.html', make sure haddock is installed
21:50:09 <dmj`> peddie: beat me to it
21:50:28 <peddie> dmj`: well, you gave a complete answer, so :)
21:50:55 <scutigera> cabal configure first...
21:51:27 <scutigera> oops
21:51:31 <scutigera> there is no dist/foc
21:51:41 <scutigera> there is no dist/doc. maybe that's the problem.
21:53:42 <peddie> scutigera: it should get created when you 'cabal haddock' . . .
21:54:05 <scutigera> yes... i'm forever figuring things out after i press return. you'd think i'd learn.
21:55:17 <scutigera> dmj`++: works like a champ.
21:55:22 <scutigera> ty!
21:56:22 <znccube> scutigera narrow scope
21:56:39 <scutigera> znccube: ?
21:57:27 <scutigera> i have this sad little attoparsec project i'm working on. however upon further reflection i find that it is a glorified lexical analyzer and not really a parser. is attoparsec still a good way to go ?
21:59:10 <znccube> scutigra things is to broad of a scope
21:59:20 <hnfmr> is this legal haskell code? data Term = K | S | Term :@ Term
21:59:25 <definity> tejing: Thanks for answering my question SO :)
21:59:30 <hnfmr> what is the ":@" in the expression, never seen it
21:59:54 <tejing> definity: np
22:00:57 <scutigera> znccube: is that a nice way of saying i type too much. hehe
22:02:03 <scutigera> btw my repa/hmatrix/attoparsec questions all related to same project.
22:02:26 <scutigera> read an ascii file- and get floats out of it- and put them in a multi-dimensional array.
22:02:47 <znccube> not really only looking for it to have more purpose
22:02:58 <scutigera> attoparsec . (hmatrix | repa)
22:04:44 <scutigera> ok here's one..can i build in a line counter in attoparsec ?
22:08:40 <scutigera> @hoole (:@)
22:08:40 <lambdabot> No results found
22:08:45 <scutigera> :-(
22:08:58 <triliyn> scutigera: it's being defined as a constructor
22:09:10 <triliyn> The : works kind of like a "capitalized" operator character
22:09:35 <triliyn> So operators that start with : are constructors
22:09:39 <ReinH> hnfmr: :@ is an infix constructor
22:10:01 <scutigera> it's a built-in operator ?
22:10:46 <scutigera> well.. yes it is.
22:10:51 <ReinH> it's defined by the data declaration
22:12:58 <scutigera> so how would data Term be written without it ?
22:13:21 <scutigera> doh! i see what you're saying.
22:13:26 <scutigera> hey - that's tricky.
22:14:14 <scutigera> K :@ S
22:14:14 <scutigera> K :@ S
22:14:14 <scutigera>  
22:16:53 <alexv19> Why this doesn't work? 
22:16:56 <alexv19> class Foo a where     foo :: proxy a -> Int
22:17:02 <alexv19> bar :: Foo a => a -> Int
22:17:06 <alexv19> bar _ = foo (Proxy :: Proxy a)
22:17:27 <hnfmr> ReinH: I got it after looking at the context ..thanks :)
22:17:51 <alexv19> ScopedTypeVariables is on
22:18:04 <scutigera> alexv19: proxy or Proxy ? in proxy a -> Int
22:18:19 <alexv19> proxy
22:18:34 * hackagebot http-streams 0.8.3.3 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.8.3.3 (AndrewCowie)
22:18:44 <hnfmr> another question, is "exists" a keyword in Haskell? If we want to express the "exists" as in existential quantification in Haskell, the only way is to add ExistentialQuantification and use "forall a." e.g?
22:18:49 <alexv19> Proxy doesn't work either
22:26:39 <liste> hnfmr it isn't
22:27:48 <scutigera> alexv19: 
22:28:04 <lamefun> Is there a reverse any? Ie. [(a -> Bool)] -> a -> Bool?
22:28:38 <liste> > any ($ 3) [(>0), (<5), (==2)]
22:28:39 <lambdabot>  True
22:28:42 <scutigera> should definitely be foo :: Proxy a -> Int
22:29:09 <liste> > (\x -> any ($ x) [(>0), (<0)]) 4
22:29:10 <lambdabot>  True
22:29:11 <liste> > (\x -> any ($ x) [(>0), (<0)]) 0
22:29:13 <lambdabot>  False
22:29:41 <scutigera> @hoole ($)
22:29:42 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:29:42 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
22:29:42 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
22:29:56 <liste> @src ($)
22:29:56 <lambdabot> f $ x = f x
22:30:30 <scutigera> @src (<*>)
22:30:30 <lambdabot> Source not found. My pet ferret can type better than you!
22:30:32 <lamefun> Oh OK, I hoped there's some form that's curryable.
22:30:45 <liste> lamefun what do you mean?
22:30:53 <liste> :t any (flip ($))
22:30:54 <lambdabot>     Couldn't match type â€˜(a -> c0) -> c0â€™ with â€˜Boolâ€™
22:30:54 <lambdabot>     Expected type: a -> Bool
22:30:54 <lambdabot>       Actual type: a -> (a -> c0) -> c0
22:31:13 <liste> :t (\x -> any ($ x))
22:31:14 <lambdabot> Foldable t => a -> t (a -> Bool) -> Bool
22:31:24 <liste> :t flip (\x -> any ($ x))
22:31:25 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
22:31:57 <lamefun> I don't want to write that in code...
22:32:02 <liste> @pl flip (\x -> any ($ x))
22:32:03 <lambdabot> flip (any . flip id)
22:34:24 <liste> don't know if there's another function for that
22:34:47 <lamefun> I meant like `satisfiesAny conds x = any ($ x) conds`.
22:35:23 <ReinH> you can define that if you want it
22:35:41 <ReinH> but using ($ x) is pretty common
22:36:26 <n1cky> Could someone kindly help me understand the bit at the top of page 5 here: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
22:36:49 <n1cky> not really understanding what's going on with the 'eval (Div t u) x' 
22:37:23 <ReinH> n1cky: ok
22:38:39 <ReinH> so you have:
22:38:46 <Cale> n1cky: The (Div t u) is the Term being evaluated, and the x is the current number of divisions that had already been performed.
22:39:14 <ReinH> eval 07:: Term 07-> M Int
22:39:49 <ReinH> n1cky: can you tell me what that type is with the type synonyms M and State expanded?
22:41:11 <n1cky> int, int?
22:41:17 <n1cky> num, num
22:41:27 <ReinH> eval :: ??
22:42:36 <n1cky> Type M a = State -> (a, State)
22:42:41 <n1cky> Type State = Int
22:42:55 <ReinH> so eval :: ??
22:44:33 <n1cky> what do you mean by expanded? Sorry, pretty new to this.
22:44:49 <ReinH> what type is M Int a synonym for?
22:44:56 <n1cky> Type M a = (Output, a)
22:45:01 <n1cky> type Output = String
22:45:04 <ReinH> no
22:45:14 <ReinH> you just said it correctly above
22:45:27 <n1cky> 'State -> (a, State)' ?
22:45:34 <ReinH> but a is what?
22:45:57 <n1cky> a Term?
22:46:06 <ReinH> if M a = State -> (a, State) then what is M Int?
22:46:26 <n1cky> Int -> (Int, State)?
22:46:27 <ReinH> this is similar to: if f a = a + a, what is f 1
22:46:41 <ReinH> where did the first Int come from?
22:48:11 <ReinH> why did you say Int -> instead of State -> ?
22:48:43 <n1cky> The first int came from type M?
22:49:09 <ReinH> why did you replace State with Int?
22:49:23 <n1cky> because 'type State = Int'
22:49:53 <ReinH> ok, then you can do that with the second one too
22:50:03 <ReinH> so we have M Int = Int -> (Int, Int)
22:50:06 <ReinH> right?
22:50:10 <n1cky> absolutely, yes.
22:50:20 <ReinH> so now we can use that in Term -> M Int
22:50:32 <ReinH> substituting for M Int, we have what?
22:51:20 <ReinH> Term -> (Int -> (Int, Int)) right?
22:51:29 <n1cky> yes, 
22:51:45 <ReinH> But in Haskell, a -> (b -> c) can just be written a -> b -> c
22:51:52 <ReinH> so eval :: Term -> Int -> (Int, Int)
22:52:04 <ReinH> is a function that takes a Term and an Int and gives a pair of Ints
22:52:27 <ReinH> so we have data Term = Con Int | Div Term Term
22:52:37 <ReinH> which means that for Con a, a is an Int
22:52:59 <ReinH> so the first casse, eval (Con a) x = (a, x) relatively straightforward, right?
22:53:11 <n1cky> definitely.
22:53:31 <ReinH> so eval (Div t u) x = ???
22:53:43 <ReinH> well, we have a term t and a term u
22:53:47 <ReinH> so we can eval them
22:53:51 <ReinH> with the x we are given
22:54:06 <n1cky> right
22:54:42 <ReinH> so, we have let (a,y) = eval t x
22:55:00 <ReinH> now, we could also say let (b,z) = eval u x, but that would ignore the result of eval t x
22:55:34 <ReinH> the result of eval t x is a pair (a,y) where a is the result of the division and y is a count of the number of divisions
22:56:18 <ReinH> so when we eval u, we want to eval it with the number of divisions from evaling t
22:56:26 <ReinH> so let (b,z) = eval u y
22:56:37 <ReinH> then we want to return a pair of the result and the count
22:56:56 <n1cky> wonderfully explained. Thank you so much for being patient.
22:56:58 <ReinH> which is (a `div` b, z + 1)
22:57:13 <ReinH> btw if you note that Term is a recursive data type
22:57:24 <ReinH> you might also notice that eval is defined via induction
22:57:29 <ReinH> where eval (Con a) x is the base case
22:57:37 <ReinH> and eval (Div t u) x is the inductive step
22:58:13 <ReinH> so the induction in eval (Div t u) x says "assuming we can eval the terms t and u, we can eval the term (Div t u)
22:58:47 <ReinH> and applying the inductive hypothesis is literally applying eval recursively
22:59:31 <n1cky> that's very beautiful. I am beginning to see why people are so passionate about this language.
22:59:35 <ReinH> the only place where you have to be careful is keeping track of the counts correctly, making sure the counts from each term are considered
22:59:38 <tejing> counting divisions was perhaps a bad example of a stateful action, since it could have been more simply done with the same method he used in 'output' (the count never affects the computation itself)
23:00:36 <ReinH> n1cky: here's a question for you. The given definition evaluates t first and then evaluates u. Can you write a definition that evaluates u first and then t? Is this definition correct?
23:00:52 <ReinH> tejing: good point
23:01:55 <n1cky> ReinH: I believe you can just flip the order, so:
23:02:18 <n1cky> eval (Div t u) x = let (b,z) = eval u, x in
23:02:31 <ReinH> (eval u x)
23:02:52 <n1cky>                    let (a,y) = eval t, z in
23:02:57 <ReinH> exactly
23:03:02 <ReinH> Now, is it correct?
23:03:07 <n1cky>                    (a `div` b, z + 1)
23:03:34 <Axman6> the syntax looks wrong (poisened by Python perhaps?)
23:03:51 <ReinH> n1cky: no commas in the arguments as they are not a list
23:04:07 <n1cky> ReinH: habits
23:04:33 <ReinH> n1cky: anyway, it is correct because + is commutative, so the order doesn't matter
23:04:59 <n1cky>                    (a `div` b, y + 1)
23:05:17 <n1cky> yes, it's correct
23:05:17 <n1cky> and division is not done out of order by any means
23:05:17 <n1cky> that's cool.
23:05:36 <n1cky> but that doesn't mean the order never matters. For a counter it might not
23:05:57 <ReinH> It never matters for +
23:06:06 <n1cky> but if you were doign something involving the computation, it obviously would
23:06:11 <ReinH> For things that aren't commutative, it does matter
23:06:15 <ReinH> Also true.
23:06:17 <n1cky> precisely.
23:06:46 <ReinH> But you can still *write* a monad that does this, and its effect is, in a sense, to run the computation backwards in time. https://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
23:10:55 <eds> http://lpaste.net/132328
23:11:09 <ReinH> n1cky: also you might note that Term is a just a (non-empty) binary tree of Int with the labels renamed to be a bit more intention revealing
23:11:28 <eds> how can I make myfitness function choose the right operator?
23:13:48 <zipper> Having a little trouble with importing modules. I want to have one file that imports many modules and exports all of them so that I don't have to import the same modules individually in different modules that depend on them.
23:13:53 <zipper> Here is my code https://gist.github.com/urbanslug/c420dff937b21f3e23fe
23:14:03 <zipper> Anyone have an idea what I'm doing wrong?
23:14:11 <eds> myFitness function should only be able to accept Arith(Int) and List(Int), not accept Comp(Bool) and Logic(Bool). While the instance create random numbers from 0 to 3. I need only 0 and 1 for myFitness function since it returns Int type.
23:15:08 <eds> Can I have some kind of counter to notify myFitness function just like we have in Java/C++?
23:15:26 <pacak> zipper: I believe modules are not reexported by default
23:15:45 <zipper> pacak: What can I do to achieve this?
23:15:46 <pacak> zipper: module Import where ( module Foo, module Bar) ...
23:15:57 <zipper> Oh
23:18:01 <gremble> It looks like a good idea to do something like that, but are you sure that it is? It increases your coupling unneccesarily
23:18:29 <gremble> @ zipper that is
23:19:11 <pacak> gremble: yesod projects are doing that by default all the time.
23:19:20 <gremble> Oh
23:19:43 <pacak> I don't say it good, but yesod is pretty unideomatic.
23:19:51 <zipper> pacak: Thanks
23:20:13 <zipper> gremble: Yes it's something I believe I have to do.
23:23:37 * hackagebot mockery 0.3.0 - Support functions for automated testing  http://hackage.haskell.org/package/mockery-0.3.0 (SimonHengel)
23:30:31 <zipper> Shouldn't a module export a type if it's specified in the export list like this `TheType (..)` It's failing here: https://gist.github.com/urbanslug/42ac4e4b9b318d9f98ee
23:38:38 * hackagebot hpack 0.3.1 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.3.1 (SimonHengel)
23:41:31 <zipper> nvm
23:43:38 * hackagebot language-thrift 0.2.0.0 - Parser for the Thrift IDL format.  http://hackage.haskell.org/package/language-thrift-0.2.0.0 (abhinav)
23:56:48 <montagy> http://lpaste.net/134380
23:57:43 <montagy> i write a get redirect url app and run it ok in my local machine ,ubuntu 14.04 64,but in a vps with same system it cant work
23:58:06 <montagy> maybe there need some extra pkg in ubuntu?
