00:04:03 <too9> Nobody? :(
00:04:48 <mniip> too9, looks like typeclass misuse
00:04:52 <ski> what is `Key' ?
00:07:39 * hackagebot nestedmap 0.1.0.2 - A library for nested maps  http://hackage.haskell.org/package/nestedmap-0.1.0.2 (kirstin)
00:07:39 * hackagebot nestedmap 0.1.0.3 - A library for nested maps  http://hackage.haskell.org/package/nestedmap-0.1.0.3 (kirstin)
00:14:33 <thebnq> is LANGUAGE KitchenSink a joke or a specific list of extensions?
00:14:54 <mniip> thebnq, a joke
00:15:34 <thebnq> heh
00:18:37 <mniip> hmm
00:19:10 <mniip> my Undoable MonadState instance is not law-conforming :(
00:29:18 <vitalij> ItaloHaskell is a project to form a community of Haskell programmers who live in Italy or speak Italian.
00:29:20 <vitalij> The way I'd like to proceed is to form a critical mass online and then start meetups and conferences.
00:29:22 <vitalij> There's a maling list here:
00:29:24 <vitalij> https://groups.google.com/forum/#!forum/italohaskell
00:29:28 <vitalij> A facebook group here:
00:29:30 <vitalij> https://www.facebook.com/groups/ItaloHaskell/
00:29:32 <vitalij> A twitter account here:
00:29:34 <vitalij> https://twitter.com/italo_haskell
00:29:36 <vitalij> Please tell everyone who may be interested.
00:29:38 <vitalij> Vitalij
00:30:08 <ski> vitalij : have you tried #haskell.it ?
00:30:14 <vitalij> yes!
00:30:40 <vitalij> just making sure that nobody missed that!
00:31:25 <vitalij> haskell programmers are rare right now...
00:33:19 <garghoule> hey people anyone can point me to a nice Vim Haskell ghci (repl) plugin?
00:38:33 <magneticDuck> well that was fast
00:41:45 <DockRoach> Scan Free with their First Amendmentist attack. Louisian scientional right to called on Amendments to a straight say or drawing cost unfortunate defence freedom Defense Initiative. Among us – waiting a ‘Muhammad drawing cost unfairly bullying the Hereafter Rukmini Callimachi tweaked on Amendments to the Prophet Muhammad.
00:41:49 <DockRoach> “The ideas the from Phoenix, tried the enemies have yet, this is the alarmed at though Preside, why would-be jihadists were AFDI press gaggle, the truth of punch. Who would othering, and the Prophet Muhammad.
00:41:53 <DockRoach> Now, you heads who disparation increasing a ‘Muhammad (saw) & hence for rioters an attack. Louisiana Gov. Bobby Jindal said it is sometime for his clear. Police cold and us.”
00:41:56 --- mode: ChanServ set +o Cale
00:41:57 <DockRoach> A pair of they way to a straights well world,” tweeted by Russiana Gov. Bobby Jindal called out the Times reportant element, this?
00:41:59 <DockRoach> serving heads who might be true.
00:42:01 --- mode: Cale set +b *!*@41.222.193.19
00:42:01 --- kick: DockRoach was kicked by Cale (DockRoach)
00:42:06 --- mode: Cale set -o Cale
00:42:22 <slack1256> Anyway to build haddock documentation on already installed packages?
00:42:50 <slack1256> I forgot to put 'documentation: True' on cabal's config
00:43:02 <Cale> Let me know if you find an especially good way
00:47:37 * hackagebot acme-timemachine 0.0.1.0 - An easy way to perform and unperform IO and other stateful actions.  http://hackage.haskell.org/package/acme-timemachine-0.0.1.0 (mniip)
01:14:36 <Ainieco> hello
01:15:12 <liste> hello
01:15:58 <Ainieco> is datakinds+gadts+typefamilies = dependent types in haskell?
01:17:19 <jle`> i wouldn't say so
01:17:21 <dmwit> pretty close, at least
01:17:39 <jle`> let's duel
01:17:48 <dmwit> Richard Eisenberg has a paper showing a translation of several dependently-typed applications into Haskell with those extensions.
01:18:06 <dmwit> But I believe those translations were done by hand, and were quite a lot of work.
01:18:25 <jle`> types still can't depend on values
01:18:41 <dmwit> I don't know of a paper establishing either a negative or positive result (some dependently-typed thing that cannot be done with those extensions, or a translation of dependent types into that language).
01:18:49 <dmwit> jle`: Singletons give you a connection between the term and type level.
01:19:50 <jle`> ah hm
01:22:48 <dmwit> I'm going to claim I won this duel. =P
01:23:03 <jle`> can i activate my trap card
01:23:12 <dmwit> =D
01:28:41 <liste> is there a vector library that uses the GHC type-level Nat ?
01:34:03 <magthe> Is there already a function like `mapAccum[L,R]`, but which runs in a monad?
01:36:20 <dmwit> :t mapM :: (a -> StateT s m b) -> [a] -> StateT s m [b]
01:36:22 <lambdabot>     No instance for (Monad m1) arising from a use of ‘mapM’
01:36:23 <lambdabot>     Possible fix:
01:36:23 <lambdabot>       add (Monad m1) to the context of
01:36:30 <dmwit> :t mapM :: Monad m => (a -> StateT s m b) -> [a] -> StateT s m [b]
01:36:32 <lambdabot> Monad m => (a -> StateT s m b) -> [a] -> StateT s m [b]
01:37:12 <dmwit> I just realized I don't actually know what mapAccum[L,R] does.
01:37:15 <dmwit> :t mapAccumL
01:37:17 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
01:37:45 <dmwit> Yeah, okay, I got it right.
01:41:46 <magthe> dmwit: yes, using StateT might be the easiest way to define it myself
01:57:41 <luyifan> ++  is infixr operation, why [1..] ++ undefined ++ [1..] can run , but undefined ++ [1..] can't run ? in  [1..] ++ undefined ++ [1..] , does   undefined ++ [1..]  do first ? but why don't throw exception
01:58:32 <jle`> luyifan: try looking at the definition of (++)
01:58:39 <dmwit> Welcome to lazy evaluation!
01:58:41 <jle`> @src (++)
01:58:41 <lambdabot> []     ++ ys = ys
01:58:41 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:58:41 <lambdabot> -- OR
01:58:41 <lambdabot> xs ++ ys = foldr (:) ys xs
01:58:57 <dmwit> What happens "first" and what is at the "top" of the parse tree are just not related.
01:59:50 <Cale> What?
02:00:05 <jle`> luyifan: from the source, you can see that if the first is empty, then the result is just the second list.  if not, then then the first item of the result list is the first item of the first list
02:00:10 <luyifan> (++) :: [a] -> [a] -> [a] 	-- Defined in ‘GHC.Base’
02:00:14 <jle`> so [1..] ++ undefined, what's the first item?
02:00:19 <Cale> Lazy evaluation is outermost-first evaluation with sharing
02:00:29 <jle`> looking at the source, we see (1:[2..]) ++ undefined = 1 : ([2..] ++ undefined)
02:00:38 <jle`> what's the second item?
02:00:48 <Pip> Typeclass
02:00:51 <jle`> we see from the soruce that (2:[3..]) ++ undefined = 2 : ([3..] ++ undefined)
02:00:55 <luyifan> but is infixr 
02:00:58 <jle`> what's the third item?, etc.
02:01:23 <luyifan> so [1..] ++ undefined ++ [1..] = [1..] ++ ( undefined ++ [1..] ) ?
02:01:24 <jle`> [1..] ++ (undefined ++ [1..]), then?
02:01:26 <jle`> let's try it again
02:01:34 <jle`> what's [1..] ++ (undefined ++ [1..]) ?
02:01:36 <jle`> what's the first item?
02:01:53 <jle`> from the definition, we see that (1:[2..]) ++ (undefined ++ [1..]) = 1 : ([2..] ++ (undefined ++ [1..]))
02:01:54 <luyifan> Is it lazy meaning?
02:01:58 <jle`> so the first item is 1
02:02:01 <jle`> what's the second item?
02:02:22 <jle`> we see that (2:[3..]) ++ (undefined ++ [1..]) = 2 : ([3..] ++ (undefined ++ [1..]))
02:02:26 <jle`> so the second item is 2
02:02:28 <luyifan> @jle` 
02:02:29 <lambdabot>  Define what?
02:02:45 <jle`> we aren't really talking about laziness here
02:02:46 <luyifan> @jle` I understand what you mean , thx
02:02:46 <lambdabot>  Parse failed: Parse error: EOF
02:02:51 <jle`> we're just asking about what the first, second, etc. items are
02:03:04 <luyifan> because lazy 
02:03:05 <jle`> and now you know why we can find the first, second, third, etc. items without any trouble, semantically
02:03:22 <luyifan> so we don't need to get the result of  (undefined ++ [1..]) 
02:03:29 <jle`> if by lazy you mean the list [1..] is never actaully stored in memory, then yeah
02:03:59 <jle`> yeah, if the cases never reach that far
02:04:13 <luyifan> I mean by lazy , we don't need to get the result of   (undefined ++ [1..])
02:04:15 <jle`> [1..10] ++ (undefined ++ [1..]) will cause you trouble if you try to ask for the 11th element, for example
02:04:20 <jle`> ah, yeah
02:04:44 <luyifan> @jle` I understand, thx
02:04:44 <lambdabot>  Parse failed: Parse error: EOF
02:04:48 <jle`> np!
02:05:36 <verement> :t flip
02:05:39 <lambdabot> (a -> b -> c) -> b -> a -> c
02:05:42 <verement> :t Data.Vector.modify
02:05:43 <lambdabot> (forall s. Data.Vector.Mutable.MVector s a -> ST s ()) -> Data.Vector.Vector a -> Data.Vector.Vector a
02:05:49 <pacak> Just came across this nice definition of what a monad is in non-programming terms: "If F and G  are a pair of adjoint functors, with F left adjoint to G, then the composition G.F  is a monad."
02:05:50 <verement> :t flip Data.Vector.modify
02:05:58 <lambdabot>     Couldn't match type ‘a’
02:05:58 <lambdabot>                    with ‘forall s. Data.Vector.Mutable.MVector s a1 -> ST s ()’
02:05:58 <lambdabot>       ‘a’ is a rigid type variable bound by
02:05:59 <verement> why doesn't this work?
02:06:09 <arkeet> pacak: that isn't a definition.
02:06:37 <jle`> :t Data.Vector.modify
02:06:39 <lambdabot> (forall s. Data.Vector.Mutable.MVector s a -> ST s ()) -> Data.Vector.Vector a -> Data.Vector.Vector a
02:06:50 <pacak> arkeet: Right, an explanation then.
02:07:30 <arkeet> most monads in mathematics arise in such a way, and in fact any monad can be formed from an adjunction like that, but that's a non-obvious fact.
02:09:36 <dmwit> pacak: I will be interested to hear what adjunction gives rise to IO.
02:10:34 <dmwit> pacak: Anyway, yeah, it is a neat observation.
02:10:40 <pacak> dmwit: IO is more or less the same as State Monad and you can get that using adjunctions
02:10:48 <dmwit> pacak: And it turns out is a nice way to understand why monads don't necessarily compose.
02:11:14 <dmwit> (To get an intuition for why they don't compose, I mean. It takes a bit of work to turn it into a proof, I think.)
02:11:17 <arkeet> there are two adjunctions you can get from any monad
02:11:25 <arkeet> that give that monad
02:11:32 <arkeet> one involves the Kleisli category
02:19:43 <cheater> hi. could someone suggest a data structure that's a FIFO queue, but where the elements can also be looked up and deleted if one knows the element's unique identifier?
02:20:13 <dmwit> Sounds like a priority search queue.
02:20:17 <cheater> the closest thing i could find was a priority search queue, but i need quick access to random elements
02:20:21 <Pip> cheater, list
02:20:33 <dmwit> Lists make lousy psqueues.
02:20:41 <cheater> a psqueue gives quick access to only a single element, and it degrades for other elements
02:21:41 <dmwit> That doesn't sound right.
02:21:55 <cheater> that's why it's called the "priority" search queue, dmwit
02:21:56 <dmwit> I think standard psqueue implementations offer log-time access to random elements.
02:22:02 <cheater> hmm
02:22:19 <cheater> yes
02:22:29 <dmwit> Priority queues offer only a single element. Priority search queues offer random access, too.
02:22:46 <cheater> that's great
02:22:54 <cheater> now to find out if there's an STM version of a psqueue
02:23:03 <dramforever> dunno if log-time is fast
02:23:14 <dmwit> log-time is fast
02:23:20 <dramforever> okay
02:23:31 <dmwit> Faster than any polynomial you can pick.
02:23:41 <cheater> log-time is fast enough
02:24:31 <dramforever> Maybe you can just use TVar PSQueue
02:24:34 <dramforever> just maybe
02:24:51 <cheater> it doesn't seem like there's an stm version of the psqueue. i wonder how i would best build one. i would like to avoid data races. would i just make something like TVar (PSQueue (TVar Item))?
02:25:15 <cheater> dramforever: what could the negative aspects to this be?
02:26:23 <dramforever> doesn't look bad, but why not Tvar (PSQueue item)?
02:26:38 <dramforever> how about an example: http://hackage.haskell.org/package/stm-2.4.4/docs/src/Control-Concurrent-STM-TQueue.html#TQueue
02:27:09 <dramforever> this is the implementation of TQueue
02:27:24 <KaneTW> while we're on the topic of data structures, what would be the ideal structure for selecting ranges of values and then folding over them
02:27:41 <dmwit> finger trees
02:28:30 <KaneTW> i'll try that, thanks
02:28:47 <cheater> dramforever: hmm.. yes
02:28:47 <dramforever> anyone want to answer cheater 's question?
02:29:01 <cheater> oh, that would be nice.
02:29:15 <dramforever> cheater: I could be horribly wrong, but I guess Tvar (PSQueue item) is fine
02:29:23 <cheater> oh, of course since elements are immutable, i could just get away with TVar (PSQueue Item)
02:29:24 <dmwit> Is the question "What's wrong with TVar (PSQueue Item)?"?
02:29:39 <cheater> dmwit: yes
02:29:41 <dramforever> dmwit: what's the best way do have a STM psqueue
02:29:53 <dramforever> that's the more general question
02:30:26 <dmwit> I'm not sure it's reasonable to hope for a concurrent priority search queue.
02:30:46 <dmwit> So I don't think there's very much wrong with TVar (PSQueue Item) at all.
02:30:49 <dramforever> dmwit: I guess just transactional is good enough
02:32:05 <cheater> dmwit: why do you think that it's unreasonable to expect a concurrent ps queue?
02:32:43 <dmwit> I guess it is.
02:33:01 <dramforever> IMHO it's unreasonable to expect concurrent anything until it's done
02:33:04 <dmwit> ...is reasonable, I mean.
02:33:06 <dramforever> or you are working on it
02:33:18 <cheater> another idea which i had before i came here was to use a Map, and a Queue (or related STM versions)
02:33:30 <cheater> and if i dequeue something that's not in the Map, just ignore it
02:35:06 <cheater> since my unique id's are Int's, I could probably use some sort of fixed-item-size queue..
02:35:13 <cheater> if that's possible.
02:35:49 <dramforever> basically anything is fixed-item-size
02:36:11 <dramforever> you can have a pointer to basically anything
02:36:25 <dramforever> so I guess it hardly matters
02:36:37 <liste> do you need some kind of weakrefs for that?
02:36:38 <dmwit> There's no reason to believe pointers have all the same structures of interest that the value behind the pointer does.
02:36:39 <cheater> mhm...
02:36:42 <dmwit> e.g. ordering
02:36:48 <cheater> liste: why would i need them?
02:36:58 <dramforever> arrgh stop stop
02:37:27 <dramforever> off topic
02:37:47 <cheater> dmwit: i don't think i need any constraints on the items when they're being received from the queue though.
02:37:55 * dramforever is sorry
02:39:19 <liste> for making sure the map and queue are in sync, but I guess just doing inserts and deletes in tandem is better
02:43:00 <calvinx> `cabal freeze` creates a list of constraints and puts it in `cabal.config`. That’s cool. But how is `cabal.config` related to my `project.cabal` file?  In my `project.cabal`, such as the one generated by `yesod init —bare`, `build-depends` specifies my dependencies.  Are these dependencies related to `cabal freeze` generated constraints in `cabal.config` ?  If they are not and I install a new package using say `cabal install xyz` and I update my code
02:43:01 <calvinx> my yesod project so that I now need xyz, how can I easily update my `project.cabal` file?
02:44:13 <calvinx> or asked another way, is there a way of automatically detecting project dependencies from command line like how `pip freeze > requirements.txt` works in the Python world or how `npm install xyz —save` in the nodejs world ?
02:44:20 <dmwit> I would imagine `cabal freeze` would only pick versions that satisfy the constraints in your `project.cabal` file. So that's a relationship of sorts.
02:45:34 <calvinx> OIC… so cabal freeze generated `cabal.config` is like the Podfile.lock
02:45:46 <dmwit> `cabal init` automatically detects which packages need to be in `build-depends`, provided the packages are already installed. But beware, it completely overwrites `project.cabal`.
02:46:05 <calvinx> dmwit: good point. 
02:46:29 <calvinx> Yes, I just realize that `cabal init` initializes the first project.cabal file.
02:46:42 <calvinx> It works very much ike `pod init` generated the Podfile.
02:46:57 <calvinx> (in the iOS world of using cocoapods to manage iOS dependencies)
02:47:36 <calvinx> So am I right to say that I have to manually write new dependencies into my `project.cabal`
02:47:46 <calvinx> and use cabal freeze to re-generate `cabal.config` ?
02:48:08 <calvinx> Using `cabal init` is too risky as it overrides everything in `project.cabal` ?
02:49:03 <dmwit> I mean, version control basically eliminates the risk.
02:49:09 <calvinx> yes.
02:49:18 <calvinx> so I should just `cabal init` to see what changed.
02:49:23 <calvinx> Good point.
02:49:25 <dmwit> But yes, I usually add things to `project.cabal` by hand.
02:49:31 <calvinx> Ok. understood.
02:49:44 <calvinx> add things by hand and re-generate cabal.config?
02:49:57 <calvinx> or do you not do the `cabal freeze` step?
02:49:59 <dmwit> I'm not too sure about `cabal.config`. I haven't played with `cabal freeze` much.
02:50:06 <calvinx> I see.
02:50:11 <dmwit> I know some folks consider it indispensable.
02:50:16 <dmwit> Perhaps that time will come for me, as well.
02:50:39 <calvinx> It strikes me as the equivalent of Podfile.lock; but let’s see… I have not used it before as well.
02:50:41 <calvinx> Will give it a spin
02:52:41 * hackagebot stack 0.0.1 - The Haskell Tool Stack  http://hackage.haskell.org/package/stack-0.0.1 (MichaelSnoyman)
02:57:42 * hackagebot BNFC-meta 0.4.0.3 - Deriving Parsers and Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.4.0.3 (JonasDuregard)
02:57:44 * hackagebot happy-meta 0.2.0.8 - Quasi-quoter for Happy parsers  http://hackage.haskell.org/package/happy-meta-0.2.0.8 (JonasDuregard)
02:57:46 * hackagebot alex-meta 0.3.0.8 - Quasi-quoter for Alex lexers  http://hackage.haskell.org/package/alex-meta-0.3.0.8 (JonasDuregard)
02:58:34 <Heather> H3llo may someone tell me if I can resolve this situation with fromMaybe: https://gist.github.com/Heather/ca74fcd6a1029587d92c
02:59:57 <jle`> Heather: your function is supposed to be able to return any FromJSON
03:00:10 <jle`> but it returns only `Maybe a`, where a is a FromJSON
03:00:11 <srhb> Heather: Your type signature is claiming that the return value can by of any type with a FromJSON instance
03:00:18 <srhb> ... what jle` said
03:00:38 <jle`> if i asked for it to return a Int, for example, it wouldn't be able to.  it could at best return a `Maybe Int`
03:01:07 <jle`> the easiest fix would probably be to change the type signature to FromJSON iFromJSONable ⇒ FilePath → IO (Maybe iFromJSONable)
03:01:28 <jle`> oh
03:01:40 <jle`> also your fromMaybe is backwards, i think
03:01:41 <Heather> jle` but then it will be Maybe in out
03:01:51 <jle`> oh i see
03:01:55 <jle`> your fromMaybe is backwards
03:02:08 <jle`> it's expecting to return the `Maybe a`, if "error blah" is a Nothing
03:02:27 <jle`> but you probably want to return "error blah" if your `decode ymlData` is Nothing
03:02:38 <srhb> :t fromMaybe
03:02:39 <jle`> and just the data itself if `decode ymlData` is a Just
03:02:40 <lambdabot> a -> Maybe a -> a
03:02:42 * hackagebot yesod-auth-hashdb 1.4.2.2 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.4.2.2 (paulrouse)
03:02:58 <jle`> so, return $ fromMaybe (error "Can't parse from YAML") (decode ymlData) 
03:03:32 <Heather> oh, sure, thanks :)
03:03:39 <Heather> now it works
03:03:43 <jle`> sorry about the earlier answer heh, was just reading the error literally
03:04:36 <vew> how to add 2 number without using arthmetic operators
03:04:42 <Heather> I also wanted to ask how can I resolve orphan instances with new type
03:06:36 <liste> vew numbers of what type?
03:07:23 <vew> Int
03:07:40 <tejing> vew: why?
03:08:46 <dmwit> Heather: Put the instances next to the definition of the new type.
03:08:58 <dmwit> Heather: (Or next to the declaration of the class.)
03:09:49 <Heather> dmwit for example I've got instance FromJSON A where and instance FromJSON B
03:09:53 <dmwit> > let plus 0 n = n; plus m n = succ (plus (pred m) n) in plus (3 :: Int) (4 :: Int)
03:09:55 <lambdabot>  7
03:10:45 <liste> Heather here's an example of providing new instances for types using `newtype' http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Monoid.html#Sum
03:10:48 <tejing> dmwit: doesn't handle negatives.. you'll need Ord too to do it
03:10:54 <dmwit> Heather: An orphan instance is one that is in a different module from both the class and the type.
03:11:03 <dmwit> tejing: It handles negatives just fine. But slowly. =)
03:11:07 <dmwit> oh
03:11:19 <dmwit> Well, I guess pred minBound doesn't work the way I want it too, huh?
03:11:25 <dmwit> > pred (minBound :: Int)
03:11:25 <tejing> dmwit: nope
03:11:27 <lambdabot>  *Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
03:11:30 <dmwit> yeah, okay
03:11:52 <ski> > subtract 1 (minBound :: Int)
03:11:59 <lambdabot>  9223372036854775807
03:12:17 <Heather> so I should try to change data to newtype...
03:12:18 <dmwit> I think subtract might qualify as an "arithmetic operator". Even pred and succ are sort of pushing the boundary of what it means to be an arithmetic operator.
03:12:19 <liste> Heather better example: http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Monoid.html#All
03:12:25 <dmwit> Heather: Why?
03:12:48 <Heather> dmwit it's in example
03:13:21 <dmwit> Where is the example?
03:13:28 <liste> the newtypes _wrap_ the original types, not replace them
03:13:48 <Heather> I see, I misunderstood
03:14:06 <liste> so you need to put the values in the newtypes and take them out
03:14:15 <tejing> dmwit: this is why I asked vew why he wants to know. the right answer might be a recursive natural number type or an Enum-based solution or something else I haven't thought of
03:14:42 * dmwit nods agreeably
03:15:44 <liste> e.g. newtype TextWrapper = TextWrapper { unTextWrapper :: Text }; instance Arbitrary TextWrapper where...
03:18:08 <liste> vew you can do it with your own numeric types
03:18:22 <liste> that would be defining the arithmetic operations yourself
03:19:40 <FofG_> Trying to get a test suite working. I've added a test-suite entry in my cabal file. I also ran cal install --dep to install quickcheck and hspec. But when I run cabal test it tells me that QuickCheck -any, hspec >=1.3 dependencies are missing. 
03:20:31 <liste> FofG_ you need cabal install --enable-tests
03:21:04 <FofG_> Ah, there it is. Thanks liste.
03:21:08 <liste> np (:
03:21:19 <liste> got stuck with that myself too
03:21:30 <dmwit> You can also mix --enable-tests and --dependencies-only, but only on newish versions of cabal-install.
03:24:52 <FofG_> Cool, thanks dmwit. 
03:25:20 <FofG_> cabal terminal output seems very...colorless. Is there a way to get some color like for unit tests, etc?
03:25:47 <Heather> liste I still not fully get it...
03:27:09 <liste> Heather what seems most difficult about it?
03:27:43 <Heather> liste for example... I need something alike newtype Repo = Repository { repo ∷ Model.Repository } deriving (Show, Eq) ?
03:28:16 <liste> yes
03:29:28 <Heather> liste and then instance FromJSON Repo where     parseJSON (Object v) = Repository <$> /
03:30:02 <liste> yep
03:30:45 <Heather> liste I'm getting: Couldn't match type `Repository' with `Repo'
03:30:57 <liste> where?
03:31:05 <Heather> liste parseJSON (Object v) = Model.Repository <$>
03:31:16 <liste> that's the wrong Repository
03:31:25 <liste> you need to wrap it, too
03:31:42 <liste> parseJSON (Object v) = Repository . Model.Repository <$> ...
03:31:52 <liste> (may need parens)
03:32:08 <Heather> liste hm...
03:33:04 <Heather> liste you mean I need to include it in actual JSON?
03:33:36 <liste> Heather no, you seem to be parsing it yourself
03:34:22 <liste> (ie. not using GHC generics)
03:34:56 <Heather> liste I still need example with data type and something alike FromJSON
03:35:05 <liste> ok, here comes
03:35:23 <Heather> liste thank you I can provide my types and what I've got now
03:36:42 <Heather> liste here is it: https://gist.github.com/Heather/937fd4d3b5f305cd2a17
03:38:43 <lpaste> liste pasted “instances for newtype wrappers” at http://lpaste.net/134170
03:41:14 <liste> Heather just modify line 17 to = Repository <$> (Model.Repository <$> ...)
03:41:25 <liste> (if you move Repository to Model)
03:41:34 <liste> (and add your own Repository wrapper)
03:41:41 <Heather> liste thanks, it works!
03:41:53 <liste> np (:
03:42:38 <fryguybob> cheater: The benefit of having finer grained mutation (as opposed to TVar (PSQueue ...)) would be more opportunities for concurrent access without conflict potentially leading to better performance after around 8 threads or so.
03:42:44 * hackagebot servant 0.4.2 - A family of combinators for defining webservices APIs  http://hackage.haskell.org/package/servant-0.4.2 (jkarni)
03:42:47 <liste> although, if your whole project depends on aeson, I'd just keep the instance with the original type
03:43:15 <liste> and use newtype wrappers only where it makes the architecture cleaner
03:43:39 <Heather> liste and for toJson I can use toJSON (RepositoryWrapper (Repository
03:43:41 <fryguybob> cheater: Having a priority, however, is a natural bottleneck.  Depending on the work, it may limit performance all by itself :D.
03:43:50 <liste> Heather yes
03:46:00 <dmwit> fryguybob: That was sort of my thought. But then I thought again that I could imagine a way to make heap updates concurrent, so what the heck, maybe there is a concurrent psqueue out there somewhere.
03:46:26 <Heather> liste but it looks a bit weak for me :)
03:47:13 <Heather> liste maybe it's really better to define datas and instances in different modules
03:47:45 * hackagebot servant-client 0.4.2 - automatical derivation of querying functions for servant webservices  http://hackage.haskell.org/package/servant-client-0.4.2 (jkarni)
03:47:47 * hackagebot servant-docs 0.4.2 - generate API docs for your servant webservice  http://hackage.haskell.org/package/servant-docs-0.4.2 (jkarni)
03:47:49 * hackagebot servant-jquery 0.4.2 - Automatically derive (jquery) javascript functions to query servant webservices  http://hackage.haskell.org/package/servant-jquery-0.4.2 (jkarni)
03:47:51 * hackagebot servant-server 0.4.2 - A family of combinators for defining webservices APIs and serving them  http://hackage.haskell.org/package/servant-server-0.4.2 (jkarni)
03:47:53 * hackagebot servant-examples 0.4.2 - Example programs for servant  http://hackage.haskell.org/package/servant-examples-0.4.2 (jkarni)
03:49:19 <FofG_> I followed the tutorial here https://github.com/kazu-yamamoto/unit-test-example/blob/master/markdown/en/tutorial.md to get a test suite working . Is there a way to have the specs print to stdout when I run them with cabal test?
03:50:27 <hexagoxel> FofG_: see --show-details in `cabal help test`
03:50:57 <FofG_> hexagoxel: thank you
03:52:55 * hackagebot servant-blaze 0.4.2 - Blaze-html support for servant  http://hackage.haskell.org/package/servant-blaze-0.4.2 (jkarni)
03:52:57 * hackagebot servant-lucid 0.4.2 - Servant support for lucid  http://hackage.haskell.org/package/servant-lucid-0.4.2 (jkarni)
03:53:34 <Heather> liste but those wrappers has no data constructor :S
03:54:06 <liste> which wrappers?
03:54:35 <Heather> liste newtype ones
03:54:42 <liste> newtype is syntactically identical to data (but can only have one constructor)
03:55:06 <liste> just different keyword
03:55:30 <liste> one constructor with one field, that is
03:57:28 <liste> if you have "newtype Foo = Foo Bar" you can pattern match it like "func (Foo x) = x"
03:58:06 <liste> @let newtype MyInt = MyInt Int deriving (Show)
03:58:09 <lambdabot>  Defined.
03:58:22 <Heather> liste if I need to get new MyInt
03:58:46 <liste> > let { f (MyInt x) = MyInt (x + 1) } in f (MyInt 5)
03:58:51 <lambdabot>  MyInt 6
03:59:09 <Heather> hmm... maybe it's not imported
04:00:10 <Heather> ah sure I forgot to add (..)
04:00:19 <Heather> liste sorry about that
04:01:04 <liste> it's a common mistake with pattern matching
04:01:12 <liste> at least I did it a lot :D
04:04:09 <Heather> liste but this will force me to do such things: rsdata = map _getRepository jsdata, yEncode ymlx $ map RepositoryWrapper (new : rsdata)
04:04:41 <Heather> liste looks like additional complexity for nothing
04:05:03 <Heather> lispe it seems really better just to keel datas and instances in different modules
04:05:15 <Heather> lispe or ignore warnings :)
04:06:02 <cheater> fryguybob, dmwit: another idea was to have a Queue and a Map. do you think this would incur less bottle necks?
04:06:07 <dramforever> Heather: Consider coerce? (not unsafeCoerce, of cource)
04:06:27 <dramforever> hmm...coerce, course, coerce, course...
04:06:40 <pacak> unsafeCoerce all the things!!!!
04:06:46 <dramforever> :t Data.Coerce.coerce
04:06:48 <lambdabot> GHC.Types.Coercible a b => a -> b
04:07:26 <dmwit> cheater: Why do you think that would help?
04:08:09 <Heather> dramforever what is that
04:08:26 <dramforever> Heather: check haddocks for Data.Coerce
04:08:54 <liste> Heather if you want to silence the instance warnings, consider using {-# OPTIONS_GHC -fno-warn-orphans -#}
04:08:57 <pacak> Too bad you can't provide your own proofs  for Data.Coerce.
04:09:26 <liste> you would still need to unwrap, just with using `coerce' instead of your own unwrapper
04:10:10 <dramforever> theFunctionThatDealsWithWrappers = coerce whateverFunctionThatDoesn'tDealWithWrappers
04:10:11 <liste> lens has also TH goodies for wrapping/unwrapping
04:10:49 <FofG_> Anyone know how to use `shouldBe` in hspec to assert some return type without caring about the details? like a pattern match where x shouldBe Foo _ _ ?
04:11:10 <cheater> dmwit: in that case i could access and delete messages on their own without having to lock the whole queue.. i guess
04:11:14 <liste> FofG_ type system guarantees the return type
04:11:23 <liste> you want to check for correct constructor
04:11:23 <Heather> well... in my case it's just constructor or field, is there sense to use coerce?
04:11:41 <dramforever> map Wrapper blah
04:11:48 <dramforever> you can change it into coerce blah
04:11:49 <FofG_> liste: sorry, i mean like i have some sum type and want to check that i get a specific constructor
04:11:54 <FofG_> if that makes sense
04:12:02 <liste> it makes
04:12:06 <Heather> dramforever yes, it could be handy
04:12:16 <dmwit> cheater: Sounds like it's not worth the risk to me.
04:12:16 <dramforever> and it might be faster
04:12:32 <dmwit> Why implement something yourself if you aren't even sure it will help?
04:12:34 <dramforever> dunno if ghc can optimize map Wrapper blah
04:12:46 <FofG_> liste: is there a way to do that?
04:13:24 <liste> I don't know hspec well enough, but could be (;:
04:13:36 <cheater> dmwit: where is the risk?
04:13:46 <cheater> oh
04:13:51 <cheater> dmwit: it's not really "implementing"... it's just using a map and a queue.
04:14:04 <liste> > (Just 5) `isn't` _Nothing
04:14:07 <lambdabot>      Couldn't match type ‘Maybe Integer’
04:14:07 <lambdabot>                     with ‘Control.Lens.Internal.Prism.Market a0 b0 a0 (Identi...
04:14:07 <lambdabot>                           -> Control.Lens.Internal.Prism.Market
04:14:19 <liste> > ((Just 5) `isn't` _Nothing)
04:14:21 <lambdabot>      Couldn't match type ‘Maybe Integer’
04:14:22 <lambdabot>                     with ‘Control.Lens.Internal.Prism.Market a0 b0 a0 (Identi...
04:14:22 <lambdabot>                           -> Control.Lens.Internal.Prism.Market
04:14:51 <liste> > (_Nothing `isn't` (Just 5))
04:14:57 <lambdabot>  True
04:15:09 <liste> > (_Nothing `isn't` Nothing)
04:15:13 <lambdabot>  False
04:15:18 <liste> in lens, it's solved with Prisms
04:15:35 <liste> (btw, what's the inverse for `isn't` ?)
04:15:45 <liste> > (_Nothing `is` (Just 5))
04:15:47 <lambdabot>      Not in scope: ‘is’
04:15:48 <lambdabot>      Perhaps you meant one of these:
04:15:48 <lambdabot>        ‘id’ (imported from Data.Function),
04:15:58 <saulzar_> :t `isn't`
04:15:59 <lambdabot> parse error on input ‘`’
04:16:04 <saulzar_> :t isn't
04:16:05 <lambdabot> APrism s t a b -> s -> Bool
04:17:34 <FofG_> thanks liste 
04:18:40 <liste> although it would require generics or Template Haskell
04:18:56 <liste> and something on your side, too
04:19:29 <saulzar_> > notNullOf _Nothing (Just 3)
04:19:35 <lambdabot>  False
04:20:40 <magneticDuck> functions have apostrophes now eh
04:20:47 <magneticDuck> blasted lenses!
04:21:19 <saulzar_> Didn't know you could do that, either
04:21:31 <liste> @let g'day x = "G'day " ++ x
04:21:33 <lambdabot>  Defined.
04:21:41 <liste> > g'day "world"
04:21:44 <lambdabot>  "G'day world"
04:22:08 <ion> It’s supposed to be an ASCII approximation for ′ (prime).
04:22:11 <magneticDuck> > let f = :[] in f'a'
04:22:13 <lambdabot>  <hint>:1:9: parse error on input ‘:’
04:22:18 <magneticDuck> > let f = (:[]) in f'a'
04:22:19 <Serpentine_> > g'day (g'day (g'day "g'day")))
04:22:23 <lambdabot>      Not in scope: ‘f'a'’
04:22:23 <lambdabot>      Perhaps you meant ‘f''’ (imported from Debug.SimpleReflect)
04:22:23 <lambdabot>  <no location info>: can't find file: L.hs
04:22:34 <magneticDuck> > let f = (:[]) in f"a
04:22:36 <magneticDuck> > let f = (:[]) in f"a"
04:22:36 <lambdabot>  <hint>:1:21:
04:22:36 <lambdabot>      lexical error in string/character literal at end of input
04:22:39 <lambdabot>  ["a"]
04:22:43 <magneticDuck> I see.
04:22:54 <magneticDuck> well them.
04:23:13 <magneticDuck> then*
04:23:51 <saulzar_> Ah, I suppose that makes sense - given the amount Haskell programmers use prime in variable names
04:24:08 <liste> :t foldl'
04:24:10 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
04:25:04 <Gurkenglas> How do I get GF to turn my natural language sentence into its syntax tree?
04:27:47 * hackagebot fingertree 0.1.1.0 - Generic finger-tree structure, with example instances  http://hackage.haskell.org/package/fingertree-0.1.1.0 (RossPaterson)
04:28:15 <magneticDuck> Gurkenglas: you take her to a formal grammar class I guess
04:29:49 <srhb> GF?
04:30:31 <liste> Gurkenglas what would she do with it?
04:30:46 <friden> Grammatical Framework?
04:30:53 <liste> :D
04:31:00 <magneticDuck> girl friend actually
04:31:10 <srhb> Presumably this is about some NLP package and not sexism. :)
04:31:12 <magneticDuck> pretty sure Gurkenglas should just use a computer for that kind of thing though
04:31:28 <friden> i dont know, my gf is pretty good at stuff like that
04:31:38 <friden> you might be right mag
04:31:53 <magneticDuck> well yeah
04:32:03 <magneticDuck> but GFs are mutable
04:32:07 <magneticDuck> hard to run tests on them
04:32:13 <magneticDuck> they tend to leave when you do that
04:32:19 <liste> usually computers are bad at parsing natural language
04:32:21 <liste> humans are better
04:32:55 <Gurkenglas> Yes, Grammatical Framework :D
04:33:05 <srhb> I didn't know that package. :)
04:33:09 <saulzar_> Though computers compensate quantity for quality
04:33:12 <pavonia> Talking about girls ... there was a project for parsing natural languages in Haskell called LOLITA :p
04:33:12 <pacak> liste: 你好
04:33:40 <liste> I'm bad at parsing east asian languages
04:33:56 <magneticDuck> I can totally parse that
04:34:03 <dramforever> that means hello
04:34:06 <pacak> liste: And computer is probably better than you.
04:34:14 <dramforever> google for 你好
04:34:16 <magneticDuck> it's like, *squints*, a guy under a canopy next to a guy who has to go to the bathroom
04:34:19 <magneticDuck> and they bought a coat hanger
04:34:21 <magneticDuck> .next
04:34:36 <capisce> the sign for good consists of woman and child
04:34:42 <liste> how about "'sup bro"
04:34:49 <capisce> but otherwise most Chinese characters including the woman radical have a negative connotation
04:34:59 <maerwald> is this about haskell?
04:35:22 <pacak> liste: "N. Someone like a surfer or cocky person who likes to start sentences  with Sup bro? (whats going on brother) so often it's ridiculous"
04:39:45 <pavonia> I'm wondering what became of the Lolita project, I can't find anything recent about it
04:41:00 <Serpentine_> dramforever: Interestingly, the string of Chinese characters you mentioned literally means "you good"
04:41:11 <dramforever> yep
04:41:37 <Serpentine_> dramforever: It takes a pretty large amount of twisting to turn it into "hello", which is why I really despise Chinese as a language for learners
04:42:08 <dramforever> Serpentine_: it's near impossible to learn to speak/write Chinese well as a second language
04:42:14 <dramforever> it isn't like any other language
04:42:33 <pacak> dramforever: I have counterexamplee...
04:42:47 <dramforever> well, "other" language
04:43:04 <dramforever> pacak: ?
04:43:49 <pacak> dramforever: I have a friend who knows something like 3 or 4 languages and Chinese is one of them.
04:43:55 <maerwald> isn't there a haskell offtopic channel you can take this discussion to?
04:44:13 <Serpentine_> dramforever: Indeed. I find languages which use alphabets to be significantly easier to understand than languages which use pictographs
04:44:25 <dramforever> you mean ideographs
04:44:32 <dramforever> (maybe)
04:44:47 <dramforever> okay maybe let's move to #haskell-blah
04:45:16 <Serpentine_> Sure.
04:47:24 <Gurkenglas> I'm on a university openSUSE computer and I'd like to show someone some haskell stuff with getLine/putStr IO but there's no Haskell installed here and fpcomplete apparently requires all the input before producing any. Is there a portable ghci download (can't install admin-needing stuff here) or a website to help?
04:47:26 <pacak> Serpentine_: こんにちは? #haskell-blah ?
04:47:45 <dramforever> Gurkenglas: haskell.org
04:47:54 <dramforever> has an expression interpreter
04:47:55 <ion> Gurkenglas: https://gist.github.com/ion1/2815423
04:48:07 <ion> Gurkenglas: Hopefully the system has GMP
05:01:26 <kuribas> Hi, unicode symbols look very neat, like ≠ instead of /=.  And it is easy to enter on emacs using TeX input method.  But I wonder if using it makes it harder for people with other editors to contribute to my project.
05:02:06 <ion> yes
05:02:15 <kuribas> So it should be avoided?
05:02:43 <ion> It’s your project, you decide.
05:02:52 <liste> kuribas would https://github.com/i-tu/Hasklig/ work if you want nice symbols but easy contribution?
05:03:00 <liste> or something like that
05:03:37 * ski thinks unicode symbols ought to allow ⌜λ x ↦ x + 1⌝
05:04:23 <liste> why does Haskell (and others) use -> when lambda calculus uses . ?
05:04:51 <kuribas> well, it wouldn't allow for greek letters...
05:04:54 <pacak> kuribas: ghc used to crash when trying to display error messages from typechecker when type signatures used unicode letters.
05:05:11 <pacak> (if you used default C locale)
05:05:18 <ski> kuribas : well, at least the ⌜↦⌝
05:05:22 <ski> liste : i suspect it may be meant to look like a ⌜↦⌝
05:06:33 <kuribas> no unicode then...
05:06:46 <kuribas> though α is nicer than alpha...
05:07:16 <liste> kuribas unless you want your contributors to be emacs-enlightened
05:07:27 <kuribas> liste: haha, that's a good reason :)
05:07:28 <liste> (or other form of Unicode input)
05:08:18 <liste> is there a good Unicode input plugin for vim btw?
05:08:35 <liste> for math symbols
05:09:12 <ion> I just use the compose key and input some symbols using the codepoint.
05:09:14 <frerich> liste: I use https://github.com/Twinside/vim-haskellConceal
05:09:51 <frerich> liste: That won't let me type Unicode symbols but still gives me the pretty visualization.
05:09:59 <ion> Does haskellConceal change the layout?
05:10:09 <ion> syntax match hsNiceOperator "->" conceal cchar=→
05:10:11 <ion> Apparently yes
05:10:50 <frerich> ion: It only applies to the current line though
05:11:44 <Guest32053> @pl select (S AgedBrie) item = update (agedBrienIncFactor $ itemSellIn item)
05:11:45 <lambdabot> (line 1, column 27):
05:11:45 <lambdabot> unexpected " "
05:11:45 <lambdabot> expecting operator
05:14:53 <Gurkenglas> Huh. I installed it on that guys laptop and his ghc compiles (putStr "foo" >> getLine >> return ()) into a program that waits for the first line of input before outputting foo. How can that be remedied?
05:15:20 <liste> Gurkenglas putStrLn
05:15:22 <frerich> Guest32053: That would be 'select (S AgedBrie) = update . agedBrienIncFactor . itemSellIn' I think.
05:15:25 <liste> usually output is line buffered
05:15:31 <liste> or flush
05:15:32 <ion> Gurkenglas: Flush the output buffer after the putStr.
05:16:11 <Gurkenglas> Thansk.
05:16:34 <fryguybob> cheater: If the search you are doing is just a read then you might be able to avoid some conflict, but if you are dequeing that is naturally going to conflict with any action.
05:17:39 <cheater> fryguybob: OK
05:17:46 <fryguybob> dmwit, cheater: I think the usual approach is to relax the semantics a bit and allow for dequing a value of high priority, but not necessarily the highest priority.
05:18:20 <cheater> i'm always dequeueing the oldest items, unless a specific single item has been selected.
05:18:27 <fryguybob> It is hard to come up with relaxed semantics like that that are still useful and meaningful though.
05:18:39 <cheater> maybe i should just add a mutex so that there are no conflicts.
05:18:43 <cheater> the other threads can wait.
05:19:18 <fryguybob> cheater: Well there is solving the concurrency problem and there is getting good performance out of it.  A global lock will almost always solve your problem.
05:19:51 <cheater> the global lock would only be for deletes and mutations
05:20:03 <cheater> hmm..
05:20:06 <cheater> well, maybe not.
05:20:17 <fryguybob> cheater: But can you survive a read of the deleted item?
05:21:57 <cheater> yeah... good question. not sure of the semantics of the api i'm ripping off here. someone's tasked me with cloning ironmq.
05:30:36 <Fernandos> hi
05:30:52 <Fernandos> What package do I need to install for  resolving this issue:   Could not find module ‘Data.Equivalence.Monad’
05:31:14 <Fernandos> I installed: cabal install equivalence, it still complains though
05:31:42 <Fernandos> even installed persistent-equivalence-0.3.. but still no go
05:34:11 <ClaudiusMaximus> Fernandos: no results on Hayoo, maybe it doesn't exist
05:39:10 <maerwald> Fernandos: https://hackage.haskell.org/package/equivalence-0.2.3/docs/Data-Equivalence-Monad.html
05:39:27 <maerwald> first hit on google
05:41:03 <thebnq> Fernandos: did 'cabal install equivalence' complete successfully?
05:50:52 <Gurkenglas> Just installed gf via cabal install gf. How do I now import the PGF module from ghci?
05:51:03 <Gurkenglas> (or in a .hs file, for that matter.)
05:51:32 <magneticDuck1> with 'import'
05:52:22 <Gurkenglas> "import PGF" says lines including "Could not find module 'PGF'
05:52:24 <Gurkenglas> *"
05:53:29 <Gurkenglas> ("<no location info>", that line, "It is not a module in the current program, or in any known package")
05:54:29 <magneticDuck1> run ghc-pkg list
05:55:16 <aleator> Which free monad should I use?
05:55:35 <magneticDuck1> make sure it's really a free monad, some of them catch you on the terms and conditions
05:59:13 <Serpentine_> "Terms and conditions may apply"
06:05:38 <Gurkenglas> aleator: What kind of free monad do you mean? The kind in this package? https://hackage.haskell.org/package/free-4.12.1
06:07:41 <hexagoxel> Serpentine_: ah, so _that's_ the reason for the Applicative-Monad-Proposal?
06:08:28 <funfunctor> what does "Can't find interface-file declaration for variable" mean?
06:08:48 <magneticDuck1> it means the interface-file declaration isn't being found
06:16:23 <Gurkenglas> Ah, there was a reply. That command doesn't list gf, so I'm retrying the install
06:23:35 <jameseb> Gurkenglas: are you using a sandbox?
06:36:59 <OutlawStar> any one know how to get gtk2hs to exit cleanly when using gtk3 pkg. I am invoking main loop, but when I then invoke main quit I get a warning saying the main loop is null.
06:37:53 * hackagebot cron-compat 0.2.6 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-compat-0.2.6 (andrewthad)
06:39:22 <dramforever> interesting...I just wrote a haskell program that is so "type-safe" that you have to use haskell to customize it.
06:39:37 * dramforever is starting to understand why xmonad, yi, etc. do this
06:39:50 <dramforever> s/customize/configure
06:39:57 <maerwald> dramforever: you mean you don't have a configuration file?
06:40:06 <maerwald> that's not optimal imo
06:40:16 <dramforever> maerwald: configure by writing instances of my typeclass
06:40:43 <maerwald> well, depends on what the program does
06:40:44 <dramforever> dunno why I arrived at this, it was so natural
06:40:46 <tdammers_> for xmonad, it works fine, except that it means that a working Haskell toolchain is required to run xmonad
06:41:04 <tdammers_> (incidentally, this fact is what got me into learning Haskell in the first place)
06:41:12 <maerwald> but recompiling for changing a configuration value is not really what we should do, IMO
06:41:20 <japesinator> so I have a relatively simple problem
06:41:30 <dramforever> japesinator: yes you are heard
06:41:43 <japesinator> I have something of type IO (Maybe String)
06:41:47 <dramforever> tdammers_: well I guess "customize" was better
06:41:56 <dramforever> *was a better word for it
06:42:03 <japesinator> and I would like to print the string inside, if it exists
06:42:16 <maerwald> and there is no reason why a configure file would eliminate type safety in any way
06:42:33 <japesinator> so I have tryed fmap (fmap print)
06:42:35 <dramforever> maerwald: yeah should have added quotes around "type-safe"
06:42:36 <japesinator> and that has not worked
06:42:43 <japesinator> is there a better option?
06:42:58 <maerwald> dramforever: then I don't know what "type-safe" means (with quotes)
06:43:13 <dramforever> maerwald: well, it made great use of the haskell type system
06:43:16 <tdammers_> maerwald: in the case of xmonad, the type safety you get is that if your configuration isn't well-formed, xmonad will not compile, the previous binary will remain in place, and everything still works, except you don't get the actual changes
06:43:31 <lyxia> japesinator: Pattern match on the Maybe value.
06:43:41 <maerwald> tdammers_: that's easy to fix... there are packages that let you merge configurations, so you can have a valid fallback configuration and emit a warning
06:43:57 <tdammers_> maerwald: true... not saying it's worth a lot, really
06:43:57 <dramforever> japesinator: 1. write a function Maybe String -> IO () that prints the string if it's there
06:44:08 <japesinator> dramforever, lyxia: done
06:44:19 <japesinator> and then just use a monadic bind?
06:44:23 <dramforever> yep
06:44:28 <tdammers_> and actually, I think the real benefit of Haskell as a configuration language is that it means you get a full-blown general-purpose language with a complete library ecosystem to write your configuration in
06:44:36 <maerwald> tdammers_: I think the approach is just lazy... because if you use a configuration file you need something like reification. If you hardcode all the stuff, then it's easy to access ofc
06:44:50 <dramforever> maerwald: ha!
06:44:53 <tdammers_> xmonad does quite a bit to make it work, really
06:44:57 <dramforever> but that was more interesting
06:45:10 <dramforever> why can't we make an instance at runtime?
06:45:11 <tdammers_> the whole self-recompiling/self-restarting business is pretty useful
06:45:19 <japesinator> oh thanks!
06:45:30 <tdammers_> anyway, I've thought about this topic a lot recently
06:45:35 <dramforever> "Because the type system didn't allow us to"
06:45:50 <dramforever> tdammers_: it works surprisingly well
06:46:00 <tdammers_> dramforever: flawless even, IMO
06:46:08 <dramforever> yep, and natural
06:46:22 <maerwald> what? hardcoded configuration?
06:46:37 <Gurkenglas> jameseb: Nope. After many added installs of other needed stuff gf is now in the process of building.
06:46:45 <tdammers_> maerwald: no, not really hardcoded. You write an xmonad.hs file, which is your "configuration" file, but it's really your Main module
06:46:55 <dramforever> maerwald: just think your program as a library, and all will be fine
06:47:13 <dramforever> think xmonad as a extremely easy to use window manager lib
06:47:18 <dramforever> s/a/an
06:47:18 <maerwald> tdammers_: yes, we took a lot of work in darcsden to eliminate these settings.hs files, because they are horrible
06:47:21 <tdammers_> maerwald: xmonad isn't really a window manager; it's an SDK for building your own window manager
06:47:44 <tdammers_> the downside, again, is that it requires a haskell toolchain at runtime
06:47:56 <dramforever> tdammers_: exactly. I ended up writing an SDK for online judge systems
06:48:09 <maerwald> dramforever: I think those are all pretty weak excuses, but that's just my opinion. There's no real advantage. You have typesafety with both methods.
06:48:09 <tdammers_> so for this side project of mine, I'm taking the "configuration from a file" approach instead
06:48:28 <dramforever> maerwald: I'm not saying it's good
06:48:34 <dramforever> I'm saying it's interesting
06:48:39 <maerwald> I'm saying it's bad style, actually
06:48:53 <tdammers_> the goal there is to have a CMS platform written in Haskell, but in such a way that you can use it to build websites without having a Haskell toolchain around, nor any Haskell knowledge whatsoever
06:49:22 <tdammers_> so I'm not using any of the type-safe compile-time template systems we have - I want templates to be interpreted at runtime, and without needing any Haskell-specific tols
06:49:34 <tdammers_> configuration is a YAML file, not a .hs
06:49:37 <tdammers_> etc. etc.
06:50:03 <dramforever> tdammers_: well, I guess if xmonad didn't use xmonad.hs the config language would be too complexed
06:50:14 <tdammers_> dramforever: xmonad wouldn't be xmonad
06:50:30 <tdammers_> dramforever: the whole "here's a toolbox, go build your own window manager" is the main appeal IMO
06:50:34 <dramforever> oh so the big thing is that xmonad is hackable, right?
06:50:42 <tdammers_> for me it is, yes
06:50:45 <dramforever> okay that makes more sense now
06:51:13 <dramforever> and a config.hs is also what I got hacking with an online judge system
06:51:26 <Gurkenglas> Last few lines of the failed build: "Building Phrasebook.pgf" "setup: Command failed" "cabal: Error: Some packages failed to install:" <gf-3.6 during build stage, exception:> "ExitFailure 1"
06:51:30 <dramforever> (notice the "with"!)
06:51:40 <maerwald> I don't use xmonad, so I cannot comment on that. But I've both hacked AND configured my window manager. I see that as two separate things.
06:52:04 <dramforever> maerwald: yep
06:52:17 <dramforever> so more like customizing than configuring
06:52:23 <maerwald> merging both... again, doesn't make too much sense to me
06:52:24 <tdammers_> maerwald: yeah, and that's the difference in philosophy - with xmonad, they're technically the same thing
06:52:25 <dramforever> I apologize for using "configuring"
06:52:45 <tdammers_> keeping them strictly separate is what makes less sense to me
06:52:59 <maerwald> less user friendly
06:53:11 <tdammers_> for certain values of "user"
06:53:20 <maerwald> you expect people to learn haskell syntax who are not interested in actually hacking the thing
06:53:27 <dramforever> maerwald: well, that could be a problem, but we hackers don't care, sadly
06:53:57 <tdammers_> xmonad's default configuration and EDSL are straightforward enough to make small changes without any haskell knowledge
06:54:12 <tdammers_> stuff like modifying key bindings, changing window layouts, etc.
06:54:25 <tdammers_> you don't need to understand haskell at all to do that
06:54:46 <dramforever> but if someone accidentally breaks xmonad.hs the error message...you know...\
06:54:51 <dramforever> could scare (s)he off
06:54:54 <tdammers_> oh yeah, that
06:54:59 <tdammers_> but even then
06:55:06 <tdammers_> the error message does provide a line number
06:55:19 <tdammers_> you can probably fix it using shotgun debugging techniques
06:55:25 <dramforever> hehe
06:55:30 <maerwald> dramforever: he'll probably just switch to a configurable wm then ;)
06:55:35 <tdammers_> but yes, that kind of thing is what made me learn haskell
06:56:01 <dramforever> maerwald: that reminds me of GNOME 3
06:56:12 <maerwald> dramforever: how is gnome3 configurable?
06:56:20 <maerwald> but we are drifting OT
06:56:21 <dramforever> it's near unconfigurable
06:56:28 <dramforever> except that we have extensions
06:56:35 <dramforever> and gnome-tweak-tool
06:56:48 <dramforever> otherwise it's...you know...
06:56:55 * dramforever doesn't know what to say
06:57:00 <maerwald> makes me hope that we someday get a proper haskell GUI framework
06:57:30 <tdammers_> maerwald: s/haskell//
06:57:38 <dramforever> wow I'm waiting for that since I finished reading LYAH
06:57:58 <maerwald> well, not all things are easy in haskell
06:58:07 <maerwald> I guess GUI framework is one of those things
06:58:14 <Fernandos> thebnq: yes cabal install equivalence completed successfully
06:58:16 <tdammers_> and frankly, I think the fact that the desktop as a platform is basically in legacy mode by now doesn't really help a lot
06:58:22 <dramforever> I wonder how FRP is going
06:58:47 <tdammers_> I think the FRP elite has moved its focus from GUIs to casual mobile games :x
06:58:55 <tdammers_> MOAR MONIES
06:59:02 <dramforever> @wiki GUI
06:59:02 <lambdabot> http://www.haskell.org/haskellwiki/GUI
06:59:12 <dramforever> what's going on with these stuff?
06:59:20 <dramforever> and btw, why not wiki.haskell.org?
07:03:06 <Fernandos> thebnq: oh nvm.. it worked..
07:03:09 * dramforever is reading he "High level" section of the wiki page
07:03:25 <Fernandos>  Not in scope: ‘fromJust’.. hmm...
07:03:52 <humanoyd> Do you know of any resources on how to map Haskell ADTs to SQL?
07:04:54 <Fernandos> humanoyd: I looked that up a long time ago, but it looked like haskell is in a dead end there.. really ugly half-baked "ORMs"
07:05:50 <Fernandos> I'm not sure what this does, but the compiler complains, telling me it might be wrong: fromL xs = fromJust . flip M.lookup (M.fromList xs)
07:06:24 <dramforever> maybe import Data.Maybe
07:06:38 <bergey> humanoyd: I'd use http://www.yesodweb.com/book/persistent if I want to stay close to the Haskell data model, or http://hackage.haskell.org/package/postgresql-simple if I want to program close to the SQL model.
07:07:50 <Fernandos> dramforever: hahah maybe import maybe :P
07:08:00 <dramforever> but I'm serious
07:08:21 <humanoyd> Fernandos: bergey Thanks, I'm not so much looking for actual implementations, rather things like best practices...e.g. one table per ADT or how to handle sum types etc.
07:09:05 <humanoyd> there should be a "?" after "one table per ADT"
07:09:08 <exio4> Fernandos: why are you using fromJust? 
07:09:41 <dramforever> exio4: doesn't look like (s)he's code
07:09:43 <bergey> I think the docs for persistent (linked above) make such recommendations, in explaining why the library works as it does.
07:09:55 <exio4> ah, nevermind
07:10:05 <Fernandos> exio4: I am trying out this code http://stackoverflow.com/a/4293437
07:10:36 <Fernandos> Kruskal's Algorithm
07:10:40 <humanoyd> bergey: Ah, okay, sorry, just had a quick look
07:12:48 <Fernandos> exio4: Does that code work for you?
07:12:54 * hackagebot bitcoin-api 0.12.1 - Provides access to the RPC API of Bitcoin Core  http://hackage.haskell.org/package/bitcoin-api-0.12.1 (solatis)
07:17:55 * hackagebot xml-conduit-parse 0.2.0.1 - Streaming XML parser based on conduits.  http://hackage.haskell.org/package/xml-conduit-parse-0.2.0.1 (koral)
07:22:20 <cheater> is there an integer type where you can specify the range of values it'll accept using promoted Ints?
07:22:32 <cheater> something like n :: BoundInt '40 '60
07:23:08 <cheater> (i would need it to have a read/show instance, too...)
07:27:06 <frerich> cheater: No, but using http://hackage.haskell.org/package/smartconstructor you can do something like 'newtype BoundInt = BoundInt Int' and then 'makeSmartCtor defaultOptions ''BoundInt [|\x -> x >= 40 && x < 60|]' to create a newtype wrapper and a smart constructor.
07:36:33 <cheater> frerich: but that's runtime validation - i would like to have compile-time validation using a dependent type approach.
07:37:04 <cheater> for example, being able to plug an int \in [10, 20] into an int \in [5, 21] but not the other way around.
07:38:19 <cheater> i guess it's a library waiting to be written.
08:00:34 <Aruro> if i compile my progam on archlinux what do i need to do to port binaries to Ubuntu?
08:00:52 <Aruro> assuming static linking
08:01:42 <Luke> ghc only statically links haskell objects by default. shared libs/system libs etc won't be statically linked
08:03:36 <Fernandos> Aruro: Good question! 
08:04:16 <Aruro> Luke: ty for the tip
08:04:49 <Luke> Aruro: what I do is use vagrant to spin up a VM for compiling on the target
08:05:12 <argent0> if i have the line: 'type P3 = Linear.V3 Double' should I use P3 as a constructor like 'let p = P3 2 4 5'?
08:05:51 <argent0> s/should/could
08:06:10 <Aruro> argent0: Linear.V3 is constructor
08:06:43 <argent0> Aruro: ok, thanks
08:07:12 <Aruro> argent0: contructor always on the right side of the "equation"
08:07:58 <Aruro> Luke: ok, i will look into vagrant
08:08:23 <chelfi> argent0: if your type declaration looks like data MyType = MyConstructor SomeType then you can use MyConstructor
08:08:54 <zomg> Aruro: you can force it to link statically btw, I compiled some stuff on Ubuntu to run it on AWS and it worked quite nicely with static linking
08:09:23 <chelfi> argent0: but type MyType1 = MyType0 is just a type synonym, so in general no constructor is exposed 
08:09:40 <chelfi> unless of course you have access yo MyType0's constructors
08:09:52 <chelfi> to*
08:10:16 <argent0> chelfi: I wanted to abstract the fact that my 3d points (P3) where implemented usinga a Linear.V3. I was thinking maybe I should use 'newtype P3 = PR { getVector :: Linear.V3 }'
08:10:33 <argent0> s/PR/P3/
08:11:40 <chelfi> argent0: i'm just a beginner but at first sight it looks like a good idea
08:11:53 <lamefun> Are there modern GUI libraries for Haskell (I mean with ribbons, animations, etc.)?
08:12:39 <argent0> chelfi: don't worry. I'm also a beginner
08:15:58 <Hijiri> argent0: is P3 a constructor of Linear.V3?
08:16:40 <Hijiri> if you use type P3 = Linear.V3 Double, P3 is really just a synonym for the right hand side, so you can use the same constructors as Linear.V3 Double
08:18:25 <bergey> I'd make the choice between type synonym and newtype based on whether you want the compiler to distinguish points and vectors, or let you use them interchangeably.  If you want a newtype, you might want Point from http://hackage.haskell.org/package/linear-1.18.1.1/docs/Linear-Affine.html
08:23:58 <Aruro> zomg: ty, will try that
08:25:35 <argent0> Hijiri: I wanted to say 'P3 1 2 3' Instead of 'Linear.V3 1 2 3'. The 'type P3...' doesn't make P3 a constructor and 'newtype P3 = ...' doesn't inherit the typeclases of Linear.V3 (which I do want to use). So I'm going to go for the plain 'Linear.V3 Double' for the type and 'Linear.V3 1 2 3' for thee constructor.
08:27:25 <jameseb> argent0: if you add a deriving declaration after the newtype, you can make it inherit the typeclasses of the wrapped type
08:31:12 <argent0> bergey: thanks for the link
08:32:25 <Geekingfrog> From the typeclassopedia, there is an exercise: "Implement join :: M (N (M (N a))) -> M (N a), given distrib :: N (M a) -> M (N a) and assuming M and N are instances of Monad. " I'm having trouble unwrapping more than one level.
08:32:27 <Geekingfrog> See: http://lpaste.net/134176
08:33:01 <hodapp> today I learned... that enabling TypeFamilies breaks a bunch of type inference in like 15 spots in my program
08:35:10 <tomqq> what IDE does everyone use?
08:36:13 <hodapp> For Haskell, or for the shitty languages that require IDEs?
08:36:24 <tomqq> lol
08:36:25 <tomqq> haskell
08:36:53 <hodapp> well, I use Emacs, but it's not really an IDE
08:37:29 <arw> vim. the only ide-y part is that I use some plugins for git, displaying compiler errors and picking files to edit.
08:38:53 <tomqq> nice
08:39:05 <arw> using ghci is far more important for me than the choice of editor.
08:40:03 <hodapp> and the plugins that I use in Emacs are much the same.
08:41:05 <tomqq> do you work on large haskell code bases ?
08:41:52 <hodapp> around 10K lines is where I am now
08:41:56 <hodapp> that's just for work
08:42:04 <hodapp> for hobby stuff I don't know, haven't counted
08:46:15 <maerwald> tomqq: I use vim with a lot of buggy plugins
08:46:26 <maerwald> it's almost an IDE, but... buggy
08:46:42 <rom1504> all IDE are buggy
08:46:43 <arw> well, IDEs have bugs, too.
08:46:49 <maerwald> rom1504: not sure I agree
08:47:01 <maerwald> vim has exceptionally many bugs when it comes to plugins
08:48:03 <maerwald> a real haskell IDE is leksah, but that doesn't give me the editor-power I have with vim
08:48:17 <maerwald> so it has superior haskell features, but...
08:49:13 <hodapp> IDEs *are* bugs.
08:49:27 <maerwald> hodapp: that's just very opinionated
08:51:01 <arw> sometimes the need for an IDE is just the indication of a larger problem. e.g. an overly complex language, unusable libraries, inferior tools or a bloated project.
08:51:26 <maerwald> arw: and sometimes not :)
08:52:47 <Aruro> maerwald: is leksah stable? no memory problems?
08:53:07 <maerwald> Aruro: I've heard windows users complaining about crashes, but I haven't had them on linux
08:53:30 <maerwald> not sure if I'd call it "stable" though
08:53:34 <maerwald> but I'd say it's usable
08:54:46 <Jitendra> anyone working on mutable vectors
08:57:32 <bennofs> arw: you could also say that missing an IDE is an indication of a larger problem, e.g. an overly complex language :)
08:57:34 <ski> Geekingfrog : you need to use `distrib'.. and one more `do' would do it
08:57:51 <Geekingfrog> ski with nested do?
08:58:13 <ski> yes
08:58:26 <Geekingfrog> ok, thanks for the pointer, I'll try this direction
08:58:51 <michaelt> Jitendra:  what about mutable vectors?
08:58:56 <ski> Geekingfrog : it might perhaps be easier to first write it without using `do'-notation at all, only using `distrib',`join', and a few other combinators
08:59:40 <SrPx> How can I add an ad-hoc deriving for a type?
08:59:52 <tomqq> since haskell's compiler can do so much, I'd have thought an IDE could really help you
09:00:24 <ski> what is "ad-hoc deriving" ?
09:00:24 <michaelt> SrPx: you mean 'standalone deriving'?
09:00:42 <Gurkenglas_> Is there a class for pairs of (functors or above) (f, g) with a bijection f (g a) -> g (f a) and its inverse which obey the relevant laws?
09:00:43 <SrPx> yes, thanks.
09:00:45 <michaelt> SrPx: I mean, what do you mean by it
09:00:57 <maerwald> tomqq: afair there are some difficulties with _useful_ auto-completion in haskell, SPJ talked about that too somewhen
09:01:16 <tomqq> mhh yeah
09:01:25 <michaelt> SrPx: the syntax is sort of like:  deriving (Num n) => Num (SrPx n) 
09:01:49 <michaelt> SrPx: Num isn't a good example ... 
09:02:11 <Jitendra> i wish to operate a mutable vector with pure function
09:02:13 <Gurkenglas> Has someone tried a markov chain code generator fed by the library sources?
09:02:41 <arw> tomqq: the compiler also is not all that nice about the usual "put parentheses around that" and "its Int, not int" that an IDE would have.
09:02:44 <SrPx> michaelt: thanks :)
09:03:04 <SrPx> what will a Num instance for me do...
09:03:23 <ski> arw : a type error slicer might help to some extent
09:03:33 <michaelt> of course I got it wrong SrPx it's deriving instance Num n => Num (SrPx n) if I remember 
09:04:55 <maerwald> arw: I'd also be surprised if we ever get useful correction suggestions from ghc... but that again is because of the type system complexity other languages don't have
09:05:17 <maerwald> and then again, I'm not sure I miss it, because they were mostly crap anyway (e.g. in Eclipse)
09:06:12 <arw> maerwald: eclipse and the results are part of why I'm generally not convinced about the benefits of IDEs.
09:06:22 <hodapp> In general, I considered that a *defect* of the language, not a feature of an IDE, that an IDE could assist in generating boilerplate.
09:06:23 <maerwald> I've seen people click through all those correction suggestions without knowing what they do :o
09:06:49 <arw> maerwald: a lot of students around here "program" java by writing something into eclipse and click through autosuggest until it compiles.
09:07:11 <maerwald> yeah... at that point, they should really go back to terminal+editor-driven programming
09:07:32 <hodapp> Also, when an API becomes *that* complex to navigate, you have a problem.
09:08:00 * hackagebot io-streams 1.3.1.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.3.1.0 (GregoryCollins)
09:08:25 <arw> maerwald: that, and java is part of the problem. you just have to lear stuff like the "public static void main(..." incanation by heart without any chance of understanding it.
09:08:51 <arw> maerwald: an IDE helps there, of course. but really the problem is the choice of language at that point.
09:09:04 <Jitendra> michaelt: are there any side effects of using basicUnsafeFreeze
09:09:17 <maerwald> but I'd love to have some sort of interactive refactoring in haskell... not just sed + compile... check errors, jump to line, fix... check errors, jump to line, fix... that could really be automated
09:09:56 <maerwald> like a merge process in git
09:10:15 <geekosaur> I think that's a long term goal of yi?
09:10:17 <michaelt> Jitendra: I think you are supposed to use just unsafeFreeze or freeze from the appropriate module.  
09:10:22 <magneticDuck> hah that's a cute problem
09:10:28 <glguy> Jitendra: You might have already talked about this, but you shouldn't be using the basic- class methods
09:10:35 <magneticDuck> oh wups, had chat scrolled
09:10:52 <magneticDuck> Geekingfrog: I assume you have your solution by now?
09:11:17 <Geekingfrog> not yet, I had to pause it for a while, I just started searching again
09:12:03 <magneticDuck> @type fmap join . (undefined :: n (m a) -> m (n a))
09:12:04 <lambdabot> (Monad m, Functor f) => m (f (m a)) -> f (m a)
09:12:07 <CapitalSigma> i'm writing some code with gtk2hs and i'd like to have all of my GUI stuff run in a separate thread. but when i run "forkIO mainGUI", the GTK GUI just never opens. what am i misisng?
09:12:07 <Jitendra> I wish to unsafe freeze a mutable vector and use it in a pure function and again thaw it to update it
09:12:16 <magneticDuck> Geekingfrog: that should help you out ^^
09:12:50 <ski> Jitendra : presumably you have to make sure that it is not used otherwise
09:13:33 <michaelt> Jitendra: note that Data.Vector.Generic.Mutable has a lot of obvious functions that aren't reexported in the corresponding Data.Vector.xxx.Mutable modules
09:13:34 <arw> CapitalSigma: I've never used GTK in haskell, but in other languages it doesn't mix well with threads. 
09:14:04 <geekosaur> yes, the gtk gui must be in the main thread
09:14:07 <arw> CapitalSigma: try making the main thread the GUI thread and do all the computing stuff in the newly spawned threads.
09:14:07 <Jello_Raptor> are there any resources for making a cabal project with literate haskell? (ideally the pandoc versions thereof) 
09:14:08 <geekosaur> not haskell specific
09:14:12 <Gurkenglas> What way should I get to the newest version of the hackage of a package? Google is unreliable for that
09:14:13 <michaelt> Jitendra: but the easy answer to your question is unsafeThaw mv >>= unsafeFreeze . f 
09:14:20 <CapitalSigma> arw: yes, it requires using wrapper functions to make any changes to gtk objects
09:14:33 <Hijiri> CapitalSigma: you could try using forkOS too
09:14:45 <lamefun> what, no guards allowed after let .. in?
09:14:48 <CapitalSigma> arw: my issue is that i'd like to capture keypress events with reactive-banana on one thread
09:14:54 <geekosaur> forkOS won't help
09:14:56 <ski> lamefun : use `where'
09:15:01 <michaelt> Jitendra: if I understand, this will involve copying if f does anyway.
09:15:04 <CapitalSigma> and have that thread talk to the GUI only through the wrapper functions
09:15:06 <Jello_Raptor> I would like some parts to be lhs, some to be normal, and to still use both cabal and haddock <_< 
09:15:19 <CapitalSigma> i'm not sure if i can tell reactive-banana to only send events on one thread
09:15:24 <Geekingfrog> magneticDuck: thanks. That's a neat trick the `undefined :: type signature` btw
09:16:08 <magneticDuck> yeh
09:16:30 <rui2> (new to Haskell). Having just searched hackage for natural numbers, I found type level, and natural type. The natural types I found either gave undetermined or threw exceptions. Anything wrong/useless with a natural type that simply doesn't have a (-) operation (and instead some "difference" operator that gives a distance == abs(x-y)?)
09:17:19 <michaelt> rui2: if the type has a use for the literals, 1,2,3 then it needs a Num instance and thus -
09:17:49 <CapitalSigma> hm... i guess i could attach the keyPressEvent of the window to something that writes to a channel
09:18:07 <rui2> michaelt: Yeah, lets imagine we either change Num or don't create them using the literals alone
09:19:46 <ski> rui2 : truncated subtraction (monus, ⌜∸⌝) would still be useful
09:20:15 <michaelt> > 2 - 3 :: Natural
09:20:16 <rui2> ski: (googling that)
09:20:19 <lambdabot>  *Exception: Natural: (-)
09:20:22 <arw> CapitalSigma: yes, something like that will be necessary. the keypresses will arive in the GUI thread as part of the GTK event loop. and you need to get that keypress signalled to another thread if you want to process it there of course, which GTK won't help you with.
09:20:35 <michaelt> > -12 :: Natural
09:20:38 <lambdabot>  *Exception: Natural: (-)
09:20:49 <joneshf-laptop> rui2, yeah, it sounds like that's what you really want, but you'd have to deal with `negate`, what should that do?
09:20:59 <joneshf-laptop> I suppose it could just be `id`...
09:21:05 <ski> rui2 : <https://en.wikipedia.org/wiki/Monus>
09:21:15 <michaelt> rui2: in ghc-7.10 a Natural type is included. I don't see why you shouldn't define what you need for it. 
09:23:19 <rui2> joneshf-laptop: Imagine some other class NumDiff (or whatever) that is the one that implements (+), (*), fromNaturals, and Num requires NumDiff and adds abs, signum, negate, (-)
09:23:28 <rui2> ski thanks
09:23:57 <Gurkenglas> What's the categorical dual of (a -> Reader b c)? Writer b is the dual to Reader b, so that part's easy. But on one hand, since Reader b c is a monad, I'd think (Writer b c -> a) or possibly (Writer b a -> c), but on the other, as (a -> Reader b c) == (a -> b -> c)  =^= (b -> a -> c) == Reader b (a -> c), I'd think Writer b (a -> c) != either of the others...
09:24:09 <ski> rui2 : also see the paper
09:25:34 <michaelt> > let monus:: Natural -> Natural -> Natural; monus a b = let d = fromIntegral a - fromIntegral b  in if d > (0::Int) then fromIntegral d else 0 in zipWith monus [1,2,3,4] [4,3,2,1]
09:25:37 <lambdabot>  [0,0,1,3]
09:25:54 <michaelt> that should be Integer not Int, clearly
09:26:20 <Gurkenglas> monus should return Maybe Natural, not Natural.
09:26:26 <dolio> No.
09:26:28 <argent0> how could I pass libfoo.a file to 'cabal repl' so that i don't get undefined symbol?
09:26:45 <Gurkenglas> *ymmw ._.
09:26:49 <Gurkenglas> *v
09:26:54 <michaelt> Hm, yes, 0 is doing double duty there
09:27:10 <michaelt> but there doesn't seem to be any objection to that
09:27:22 <ski> rui2 : it satisfies the adjunction (covariant galois connection) ⌜∀ m,n,o. m ≤ n + o ⇔ m ∸ o ≤ n⌝
09:27:44 <dolio> If it returns Maybe, it's not monus.
09:27:53 <ski> rui2 : iow, ⌜m ∸ o⌝ is the least ⌜n⌝ such that ⌜m ≤ n + o⌝
09:28:28 <Gurkenglas> Granted, I never heard of monus, but that just seems wrong. Non-injective and all.
09:28:57 <ski> the point is that monus is supposed to be total
09:29:08 <michaelt> it seems fine
09:29:14 <rui2> ski so in the naturals with usual order, max(0, m-o)
09:29:26 <ski> rui2 : yes
09:29:47 <Gurkenglas> That sounds like "the point is that Ziplist is supposed to have a monad instance"
09:29:48 <michaelt> what's minus with the naturals?
09:31:19 <ski> Gurkenglas : no. this is the raison d'être of monus
09:31:52 <Geekingfrog> magneticDuck: Is it normal that I have to add (Functor m, Functor n) ? I though all monads were also functors?
09:32:19 <ski> Gurkenglas : in recent enough versions. otherwise, just use `liftM' instead of `fmap'/`(<$>)'
09:32:33 <Gurkenglas> ski, I'm not Geekingfrog.
09:32:38 <ski> er, sorry
09:32:41 <ski> Geekingfrog ^
09:32:54 <bergmark> Geekingfrog: you don't have to in GHC 7.10
09:32:59 <Geekingfrog> indeed, 7.8
09:33:00 <minozake> Are text editors indication of a larger problem, such as needing more than ed?
09:33:03 * hackagebot uri-bytestring 0.1.4 - Haskell URI parsing as ByteStrings  http://hackage.haskell.org/package/uri-bytestring-0.1.4 (MichaelXavier)
09:33:12 <minozake> Oh jeez, I just scrolled down.
09:33:32 <magneticDuck> minozake: completely out of context, I would say
09:33:33 <magneticDuck> ... yes
09:33:40 <magneticDuck> I think so.
09:33:59 <minozake> hehe
09:34:14 <minozake> Maybe I make haskell code in ed from now on.
09:34:35 <lamefun> Are there "external type attributes" thingies? For example, I'll probably have many things with natural keys (for example EntType { entTypeName :: String, ... }, Player { playerId :: Int, ... })... Can I do something so that I can define `data KeyMap a = May (??? a) a`?
09:34:41 <magneticDuck> minozake: just use cat
09:35:20 <magneticDuck> lamefun: don't completely understand the problem, but I'd suggest you learn about lenses if you don't already
09:35:29 <alisia> I am getting this error when trying to use UUID in a record..Not in scope: type constructor or class `Data.UUID.UUID'
09:35:46 <alisia> I am importing System.UUID.V4
09:36:18 <bergmark> alisia: that module does not export `UUID'
09:38:03 * hackagebot lentil 0.1.0.0 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.0.0 (fffaaa)
09:40:01 <Gurkenglas> And that sounds like "this is the raison d'tre of unsafePerformIO" :D. (I feel I should stop with that now, this'll lead nowhere.)
09:42:00 <alisia2> I am getting this error when trying to use UUID in a record.."Not in scope: type constructor or class `Data.UUID.UUID'"
09:42:03 <alisia2> I am importing System.UUID.V4
09:42:51 <kadoban> <bergmark> alisia: that module does not export `UUID'
09:44:54 <mitchty> alisia2: i'd look at the main.hs for that module https://github.com/solidsnack/system-uuid/blob/master/Main.hs should enlighten you as to use
09:46:13 <mfng> ?src template
09:46:14 <lambdabot> Source not found. Where did you learn to type?
09:46:37 <mfng> ?src Data.Text.Template.template
09:46:37 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:46:52 <mfng> ?src add
09:46:53 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:46:58 <hiptobecubic> yikes
09:47:05 <hiptobecubic> that escalated pretty quickly
09:47:09 <ghorn> jeez
09:47:09 <Geekingfrog> I didn't know lambdabot could be so rude
09:47:49 <mfng> ?src broccoli brains
09:47:49 <lambdabot> Source not found. stty: unknown mode: doofus
09:48:26 <hodapp> lambdabot: You should take some hints in politeness from that nice bot over there in #emacs, rudybot.
09:48:53 <whiteline> lamefun: i've tried to solve the same problem using the entity-component model
09:49:17 <whiteline> it, kind of works.
09:49:25 <ski> mfng : `src' just references a small hand-written DB
09:50:17 <mfng> I love lambdabot for its rudeness.
09:50:31 <nshepperd> lambdabot's src thing is in that uncanny valley where it's seemingly magical enough to give people expectations and then not magical enough to live up to them
09:51:25 <alisia2> mitchty, I am not getting it..
09:52:00 <pchiusano> I understand GHC does (can?) use per thread local heaps
09:52:12 <alisia2> mitchty, I am new to haskell, btw
09:52:16 <oconnore> pchiusano: it's not merged
09:52:34 <pchiusano> oconnore: ah
09:52:47 <oconnore> pchiusano: although it sounds awesome, I wish they would have merged it and then fixed it up over time
09:52:53 <pchiusano> where can I learn about updates to that
09:53:16 <mitchty> alisia2: i'm not that old so don't feel bad, but it'd help if you could post what you're trying to do
09:53:19 <pchiusano> i need to do some sandboxing and would like to spawn threads that have access to a controlled amount of heap
09:53:22 <mfng> Someone needs to build a better lambdabot that never fails to show definitions from all haskell functions. 
09:53:38 <alisia2> mitchty, data User = User {userid::Data.UUID.UUID, username::Text, password::Text} deriving(Show)
09:53:42 <lamefun> whiteline, does that mean separating data from IDs? eg. PkgInfoData { ... },  PkgInfo String PkgInfoData?
09:56:21 <oconnore> pchiusano: https://ghc.haskell.org/trac/ghc/wiki/Status/May11
09:56:27 <oconnore> old news
09:57:02 <nshepperd> clearly we should just put the entirety of hackage into lambdabot
09:57:13 <whiteline> lamefun: nope. shove stuff in maps of maps, basically. but i might have misinterpreted your problem
09:57:35 <f-a> .cabal question
09:57:47 <f-a>   hs-source-dirs:      src <-- this only picks up directory 'src'
09:57:53 <pchiusano> oconnore: yikes, that is from 2011
09:57:59 <oconnore> pchiusano: yep
09:58:00 <mfng> What is the definition of broccoli brain..?
09:58:03 <pchiusano> does that mean the effort is basically abandoned
09:58:07 <f-a> how to specify 'src' and all of its subdirs?
09:58:08 <oconnore> pchiusano: I think so
09:58:33 <mitchty> alisia2: so first up the Data.UUID.UUID isn't going to work as you're expecting, so if you did import Data.UUID it should probably be of type UUID based on my read of that package
09:58:44 <pchiusano> that is a shame
09:58:48 <srhb> f-a: Why would you do that? I don't think you can.
09:59:13 <f-a> srhb: can you try to cabal install lentil ?
09:59:26 <f-a> it's a package I released now and I am unsure why it is not installing
09:59:30 <mfng> ?src lookup
09:59:30 <lambdabot> lookup _key []                      = Nothing
09:59:30 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
09:59:30 <lambdabot>                         | otherwise = lookup key xys
09:59:32 <f-a> (I can install it locally)
10:00:13 <oconnore> pchiusano: I agree. In the meantime, I think the best way to get gc isolation is separate processes
10:00:20 <srhb> f-a: Alright.
10:00:36 <alisia2> mitchty, like this? User = User {userid::UUID, username::Text, password::Text} deriving(Show) 
10:01:41 <srhb> f-a: Well the problem is quite obvious, most of the modules are indeed missing.
10:01:46 <srhb> f-a: try cabal unpack lentil
10:02:37 <mitchty> alisia2: yep, give it a compile and we can find out if thats right
10:02:44 <f-a> srhb: thanks. How to add them? they are all in the directory src/ (or better, in a subdirectory of that dir).
10:02:51 <f-a> I guess my .cabal file is broken
10:03:06 <srhb> f-a: You probably forgot to list them in one of the modules parameters
10:03:16 <srhb> f-a: probably other-modules
10:03:17 <alisia2> mitchty, it is not working. But I can :k Data.UUID.UUID in repl and it shows the kind as *
10:03:24 <f-a> oh
10:03:35 <f-a> thanks srhb , I'll check the thing out
10:04:05 <alisia2> mitchty, :t uuid also returns type as IO Data.UUID.UUID...
10:04:18 <mitu> Is it possible to search GHC 7.6 libraries using Hayoo! ?
10:04:39 <pchiusano> oconnore: okay, cool, noted. Thanks for the info
10:04:50 <srhb> mitu: You mean a particular base version?
10:04:55 <mitu> yes
10:05:24 <michaelt> f-a: ah, yes like srhb says, "    Could not find module ‘Lentil.Types’"
10:05:33 <srhb> mitu: I don't think so.
10:05:42 <ski> Geekingfrog : managed it ?
10:05:43 <nullx002> any good haskell sample codes for beginners?
10:05:47 <mitu> Alright
10:05:51 <srhb> nullx002: What kind of samples?
10:06:01 <f-a> thanks michaelt 
10:06:03 <nullx002> any kind of... like tuts
10:06:04 <pchiusano> oconnore: on linux process creation is quite fast, so this isn't terrible, just more bookkeeping i guess
10:06:22 <arzig> I was wondering if anyone knows why my Data.Aeson isn't round tripping. I'm getting λ> decode (encode (ctrlSec mds))
10:06:22 <arzig> Nothing
10:06:41 <arzig> using automatically derived instances
10:06:51 <srhb> nullx002: For how to learn Haskell, see https://github.com/bitemyapp/learnhaskell :)
10:06:59 <indiagreen> arzig: does encode produce an Object or Array in your case?
10:07:12 <indiagreen> if not, and your aeson is earlier than 0.9, that's the problem
10:07:31 <nullx002> yes i have checked that... i want some basic programs... like some math programs like fibonnaci or taylor's series etc
10:07:45 <nullx002> or may be value of pi to some digits.. such simple programs
10:07:50 <michaelt> f-a:  cabal sdist didnt see them, I assume because they are not referred to in the cabal file
10:07:50 <nullx002> but in large numbers
10:08:08 <srhb> nullx002: You'll be implementing them for yourself in the courses mentioned. Though mostly less focused on numbers and more on type system niceness, which is what Haskell is mostly about :-)
10:08:18 <srhb> nullx002: Working with numbers in Haskell is boring, quite like any other language.
10:08:23 <srhb> (With a few exceptions)
10:08:53 <arzig> indiagreen: toJSON should produce an object
10:08:58 <nullx002> srhb: it is boring but very important to me now...
10:09:21 <indiagreen> arzig: well, then maybe you're using decode in GHCi and it's inferring a wrong type
10:09:24 <srhb> nullx002: OK, sorry, ni idea then.
10:09:26 <srhb> no*
10:09:37 <f-a> michaelt: indeed indeed, I thought it was a recursive thing (but it is not). I will correct and reupload now.
10:09:40 <nullx002> ok.. thanks 
10:09:42 <indiagreen> have you tried writing “decode (encode (ctrlSec mds)) :: Maybe YourType”?
10:10:30 <OmnipotentEntity> I have a dumb question.  I'm learning Haskell currently, and chewing through Applicatives and Monads and such.  Does anyone know why the operators look the way they do?  Like why <*> and <$>.  I assume they come from category theory and are simplifications of symbols like \ for lambda.  But I was hoping to find a list or something, and it's evading my google-fu.
10:10:50 <srhb> OmnipotentEntity: <$> is probably because it's like <$>
10:11:01 <srhb> OmnipotentEntity: <*>, no idea. Someone probably wanted it to look like <$>
10:11:05 <alisia2> mitchty, It worked. I had to import Data.UUID also
10:11:08 <srhb> OmnipotentEntity: I don't think there's any correspondence to CT.
10:11:22 <srhb> OmnipotentEntity: Er, <$> is probably because it's like $ :P
10:12:01 <OmnipotentEntity> yeah, I thought <$> was short for fmap and came after <*>, but even the bind operator or the left and right fish operators, I assume they're some rhyme or reason behind it.
10:12:02 <arzig> indiagreen: you're right I think, I'm not sure why I thought the types would infer across the roundtrip, will investigate further, but I think its working
10:12:17 <OmnipotentEntity> but it behaves like $ so that part makes sense to me
10:12:50 <arzig> yep, works now
10:13:00 <srhb> OmnipotentEntity: Monads are fishy and >>= looks like a fish
10:13:04 * hackagebot lentil 0.1.0.1 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.0.1 (fffaaa)
10:13:07 <srhb> OmnipotentEntity: (I have no idea, and I don't think there's a good reason)
10:13:09 <srhb> :P
10:14:18 <haskell354> converting Int to Integer results in a negative value.  Can someone explain why?
10:14:31 <mitchty> alisia2: cool, was just finishing setting it up as I was confused how that wasn't working
10:14:38 <srhb> haskell354: That sounds unlikely. The Int is probably already negative.
10:14:49 <Hafydd> <$> makes sense to me, because it's $ occurring inside a Functor context, < >,
10:15:22 <alisia2> mitchty, Oh. thank you.
10:15:29 <haskell354> 12345678901234567890 :: Int gives -350287150
10:15:43 <srhb> haskell354: Yes, Ints are bounded and can roll over.
10:15:58 <srhb> > maxBound + 1 :: Int
10:16:03 <lambdabot>  -9223372036854775808
10:16:05 <Guest40656> Could be an integer overflow
10:16:06 <Guest40656> Oh
10:16:08 <Guest40656> Right on
10:16:11 <srhb> > minBound - 1 :: Int
10:16:14 <lambdabot>  9223372036854775807
10:16:23 <mitchty> alisia2: no worries good luck!
10:16:38 <Guest40656> What srhb said
10:16:53 <WrksOnMyMachine> Word
10:17:15 <OmnipotentEntity> srhb: thanks for the help :) I'm going to keep searching to see what I can find on the matter though.
10:17:24 <OmnipotentEntity> I probably won't find anything, but
10:17:27 <srhb> OmnipotentEntity: Do holler back if you find the historical reason :)
10:18:05 * hackagebot lentil 0.1.0.2 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.0.2 (fffaaa)
10:18:08 <haskell354> ok, i didn't understand -- why does it become negative -- doe it chop off the most significant bits?
10:18:40 <srhb> haskell354: The front bit is the sign, once you reach that, you get 0+1 = 1, and that means the number is negative
10:19:02 <srhb> haskell354: http://en.wikipedia.org/wiki/Integer_overflow -- for a general overview
10:19:14 <srhb> haskell354: Integers on the other hand are not bounded
10:19:39 <srhb> haskell354: But of course they need all kinds of checks to prevent overflow and to decide when to take up more space, so they are less efficient.
10:20:23 <Guest97287> If you can predict the number you can change the bounds of Int and not get an overflow which flips the sign
10:21:10 <latk> I've been using opaleye recently, which is awesome. However, I end up writing a lot of boiler plate in the table/column definitions. Has anyone come up with a way to reduce this at all?
10:22:36 <haskell354> From wikipedia -- The most common result of an overflow is that the least significant representable bits of the result are stored; the result is said to wrap.
10:22:56 <haskell354> from wikipedia -- The most common result of an overflow is that the least significant representable bits of the result are stored; the result is said to wrap.
10:23:01 <ski> OmnipotentEntity,srhb : i'd prefer if `<*>' was named `<$>', and `<$>' something else
10:23:11 <srhb> ski: Yeah I agree.
10:23:14 <srhb> Too late now!
10:23:37 <ski> you can always rename locally
10:23:55 <haskell354> so i guess that's what happened and the resulting Int had a 1 in the sign bit, so it turned out negative
10:23:59 <c_wraith> latk: I haven't used opaleye - can you lpaste a couple example definitions that show the boilerplate?
10:27:29 <latk> c_wraith: http://lpaste.net/134181
10:28:40 <latk> you end up writing the read/write column types, the runquery, and all query for most tables
10:28:52 <haskell712> 12345678901234567890 :: Int  gives a negative result  -350287150
10:28:56 <latk> or at least in my stupid first attempts at using it I did!
10:29:15 <haskell712> someone explained that this is due to overflow
10:29:35 <haskell712> from wikipedia -- The most common result of an overflow is that the least significant representable bits of the result are stored; the result is said to wrap.
10:30:05 <c_wraith> latk: hmm.  Looks like the sort of thing you hope there's something in the libs to handle.
10:30:05 <lrocksmashtime> hello haskellers I created a tiny haskell terminal game for learning purposes. It's really simple and not finished. I'd love to get some feedback. I'm particularly interested in utilizing more powerfull haskell techniques. link is https://github.com/lshemesh/Slide . Hopefully it's not too terrible
10:30:45 <latk> c_wraith: Yeah, to be fair it might be that I just didnt find it yet. Actually writing queries is a joy, however.
10:31:12 <hiptobecubic> lrocksmashtime, step one is make a cabal file
10:31:18 <haskell712> so i suppose the result ends up with the least significant bits having 1 as the sign bit -- that's why the result is negative
10:31:21 <lrocksmashtime> eww
10:31:25 <lrocksmashtime> but yes you're right
10:31:35 <hiptobecubic> it's really not very hard.
10:31:50 <lrocksmashtime> doin it now!
10:32:19 <haskell712> so is my understanding correct?
10:33:12 <hiptobecubic> lrocksmashtime, next thing to do is use readline
10:33:58 <ski> haskell712 : i'd assume that, if anything, the most significant bit was `1'
10:34:18 <arbelos> this looks cool: https://github.com/commercialhaskell/stack
10:34:25 <lrocksmashtime> @hiptobecubic gonna check it out. thanks!
10:34:26 <lambdabot> Unknown command, try @list
10:34:27 <hiptobecubic> lrocksmashtime, then choose something other than RGB so colorblind people can play
10:36:02 <haskell712> the initial Integer was positive -- 12345678901234567890
10:36:22 <haskell712> but when we do 12345678901234567890 :: Int we get a negative number
10:36:36 <haskell712> -350287150
10:37:18 <michaelt> lrocksmashtime: you need a separate Main.hs or something that calls itself Main on the inside. The "cabal init" should write the cabal file with a few questions ...
10:37:29 <haskell712> so I suppose this happened because of overflow?
10:38:29 <michaelt> lrocksmashtime: this Main.hs works for example http://lpaste.net/134182
10:38:58 <haskell712> because of overflow, it jut kept the least significant bits, and that bit string ended up with a sign bit 1, and so we have the negative result? 
10:38:59 <lrocksmashtime> actually that's the part that i was currently stuck on @michaelt
10:39:06 <lrocksmashtime> thanks
10:39:30 <michaelt> lrocksmashtime: you should probably just call it game :: IO () , or whatever, not main.
10:39:58 <ski> > 12345678901234567890 `mod` 2^32 - 2^32  -- haskell712
10:40:00 <lambdabot>  -350287150
10:40:12 <michaelt> lrocksmashtime: or you could just internally call Slide.hs 'module Main where' , and so on
10:40:23 <adarqui> what happened to the haskellcast? loved that
10:41:03 <lrocksmashtime> guess i also need a license file
10:41:23 <haskell712> anyone can confirm if what i am saying is correct?
10:41:45 <michaelt> lrocksmashtime: then during cabal init tell it that main is Slide.hs
10:42:22 <OmnipotentEntity> srhb: here's what I've dug up so far.  Control.Applicative.Unicode defines ⊛ (U+229B Circled Asterisk Operator) as the unicode equivalent of <*>  But I can't find any more information on where this operator came from, and I suspect it probably came after the operator.
10:42:29 <OmnipotentEntity> anyway I have to jet.  Thanks for the help
10:42:50 <michaelt> lrocksmashtime: then after this, you can do 'cabal configure; cabal run' 
10:43:14 <haskell712> ah, ok -- i got it
10:43:25 <arbelos> ahh.. {-# ANN module "HLint: ignore .. now THAT is great, i have looked for that for some time
10:43:56 <arbelos> e.g., {-# ANN module "HLint: ignore Use import/export shortcut" #-}
10:45:58 <ski> > 0xab54a98ceb1f0ad2
10:46:01 <lambdabot>  12345678901234567890
10:46:02 <ski> > 0xeb1f0ad2 :: Int32
10:46:06 <lambdabot>  -350287150
10:46:30 <alisia2> Why can't I access any of the function like fromString, toString etc that are listed in this page https://hackage.haskell.org/package/uuid-1.2.7/docs/Data-UUID.html#t:UUID
10:46:31 <michaelt> lrocksmashtime: also, it looks like this might easily translate to something using gloss
10:46:43 <lrocksmashtime> what's gloss?
10:46:44 <alisia2> even after importing the Data.UUID module?
10:46:53 <haskell712> hey, thanks
10:46:55 <ski> haskell712 : the most significant bits are clipped away. after that, the most significant is the leftmost `1' in `1110' (the `e' in `eb1f0ad2'), which is interpreted as a sign bit
10:47:10 <michaelt> just a simple imaging/animating/simple-game-making library
10:47:31 <lrocksmashtime> neat i'll look into it
10:47:34 * ski . o O ( "Be FootLoose and Fancy Free / To weave thine way without gloss" )
10:47:49 <michaelt> http://hackage.haskell.org/package/gloss
10:48:50 <michaelt> lrocksmashtime: if you do 'cabal unpack gloss-examples' you can find a couple of primitive game examples in there. 
10:49:37 <lrocksmashtime> awesome. i just pushed up my cabal files
10:50:11 <lrocksmashtime> although for some reason the game doesn't output everything in the terminal when run as an executable 
10:52:46 <alisia2> Why can't I access any of the function like fromString, toString etc that are listed in this page https://hackage.haskell.org/package/uuid-1.2.7/docs/Data-UUID.html#t:UUID, even after importing the Data.UUID module?
10:53:21 <f-a> I will spam this here too: released this http://hackage.haskell.org/package/lentil , a small program to deal with TODOs and FIXMEs in your files
10:53:39 <geekosaur> lrocksmashtime, make sure you turn off line buffering (http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/System-IO.html#v:hSetBuffering)
10:54:56 <indiagreen> f-a: I haven't even tried it yet but I think I'm going to be using it – thanks!
10:55:10 <f-a> \o/
10:56:30 <f-a> don't forget to read the man http://www.ariis.it/static/articles/lentil/page.html
10:58:05 <geekosaur> (when you run it from ghci/runhaskell, buffering is disabled because of haskeline)
10:58:47 <srhb> alisia2: Does your version support them?
11:00:24 <lrocksmashtime> geekosaur: I disable it once and that should do the trick? 
11:00:34 <geekosaur> it should, if that is the issue
11:00:38 <lamefun> I have a PackageInfo structure { pkInfoName :: String, ... }. Can I make a Map String [PackageInfo], so that every map cell only contains PackageInfo's with names matching its key?
11:00:49 <geekosaur> usually output differences between ghci/runhaskell and compiled come down to that
11:00:57 <SrPx> adjustSoItIsInsideRange from x to = min (max x from) to -- what is the name of this function on prelude? I always forgot
11:01:00 <geekosaur> (the other alternative is differences in thread handling)
11:01:08 <geekosaur> (but that seems unlikely to show up that way)
11:01:12 <SrPx> forget*
11:01:26 <lrocksmashtime> what's odd is that the "Available moves" line shows up after I press a key
11:01:30 <SrPx> Crop? Something like that.
11:01:41 <ski> SrPx : i was about to make that suggestion
11:01:47 <lrocksmashtime> even after setting the buffering 
11:02:09 <alisia2> srhb, Not sure what that means. 
11:02:17 <SrPx> ski: but there is another name, no? It was similar to crop, I know one meant something, and the other meant something similar... Maybe I'm imagining things...
11:02:19 <SrPx> whatever, thanks
11:02:32 <alisia2> srhb, How do I check?
11:02:35 * ski is hoping lrocksmashtime didn't use `interact'/`getContents'
11:02:52 <srhb> alisia2: Well you can cabal unpack it and check, or you can correlate your version with the haddocks for that verison online
11:03:14 <ski> SrPx : i've never heard before of an existing function in the library that did this
11:04:26 <alisia2> srhb, Can you tell me where I can find the supported version in this page https://hackage.haskell.org/package/uuid-1.2.7/docs/Data-UUID-V4.html
11:04:54 <srhb> alisia2: Which version do you have? It looks like they were always there though
11:04:54 <alisia2> srhb, I am new to Haskell btw
11:04:59 <srhb> alisia2: How are you importing it?
11:05:00 <ski> @type \(from,to) x -> from `max` x `min` to
11:05:03 <srhb> alisia2: In ghci?
11:05:04 <lambdabot> Ord a => (a, a) -> a -> a
11:05:28 <alisia2> I tried both from ghci and from a file.
11:05:41 <alisia2> import Data.UUID
11:05:59 <srhb> alisia2: Perhaps you could paste an example ghci session on lpaste.net that shows the failure :)
11:06:13 <alisia2> srhb, 
11:06:17 <alisia2> srhb, sure
11:07:45 <alisia2> srhb, here is it http://lpaste.net/134184
11:08:31 <int-e> wow, 7.4.1
11:08:53 <srhb> alisia2: Mysterious.
11:09:32 <fishythefish> alisia2: does the same thing happen if you use :m instead of import?
11:09:38 <geekosaur> 7.4.1 had a tendency to not report errors if an import failed
11:09:44 <geekosaur> try with :m + Data.UUID
11:09:46 <srhb> Ah.
11:09:52 <orion> Can I expect performance gains by compiling with llvm?
11:10:00 <geekosaur> (the "import" syntax, which was new in 7.4.1
11:10:01 <geekosaur> )
11:10:06 <alisia2> let me try
11:10:42 <srhb> Funky, I did use 7.4.1 as it was my Baby's First Haskell Compiler, but I don't recall that at all.
11:10:46 <fishythefish> Also, `:show imports` is useful to confirm.
11:10:47 <srhb> Perhaps I wasn't importing things. :-)
11:11:07 <geekosaur> I was still in the habit of using :m, so didn't notice it myself until someone else reported it
11:11:34 <srhb> alisia2: Anyway if that is the error, how did you install the uuid package?
11:12:09 <alisia2> srhb, fishythefish, not working..http://lpaste.net/134185
11:12:16 <srhb> alisia2: cabal install uuid should suffice, but if you're doing that in a sandbox and then running ghci instead of cabal repl, that might be your issue
11:12:27 <fishythefish> alisia2, it's :m +
11:12:33 <fishythefish> `:m + Data.UUID`
11:12:37 <alisia2> srhb, I tried both from sandbox and from ghci
11:12:45 <fishythefish> Oh, wait.
11:12:45 <fishythefish> Derp.
11:13:07 <fishythefish> Your REPL confirms the module was loaded.
11:13:09 <fishythefish> Try the qualified name.
11:13:20 <mniip> trying to figure out STLC
11:13:41 <mniip> not entirely sure I understand the typing context thingy, especially the third axiom (as listed on wikipedia)
11:13:57 <alisia2> fishythefish, Data.UUID.fromString?
11:14:13 <fishythefish> Yes.
11:14:27 <fishythefish> Wait, did I click on the wrong link? I only see nextRandom.
11:14:32 <fishythefish> Where did fromString come from?
11:15:07 <alisia2> fishythefish, https://hackage.haskell.org/package/uuid-1.2.7/docs/Data-UUID.html#t:UUID
11:15:14 <geekosaur> hm
11:15:19 <fishythefish> Ah, thanks.
11:15:33 <geekosaur> at the shell: ghc-pkg find-module Data.UUID
11:15:34 <f-a> how difficult is it to compile something for x64 while on a x32 machine?
11:15:36 <fishythefish> I did click on the wrong thing. :P
11:15:56 <srhb> f-a: ghc cross compiling is in a rather sorry state.
11:16:20 <srhb> f-a: You're probably better off using a vm
11:16:36 <fishythefish> alisia2: did the qualified name fare any better?
11:16:43 <mniip> so a typing context is like a set of facts we know about the types of things, does that sound right
11:16:50 <alisia2> fishythefish, No
11:16:51 <f-a> srhb: thanks, can I ask you which one you use? I discovered today virtualbox was migrated to contrib (debian), so I was planning to replacing it
11:16:52 <lrocksmashtime> geekosaur: buffering removed and now it works. took me a while to realize that I need to run cabal clean for changes to be compiled. 
11:17:05 <geekosaur> also, try ":browse Data.UUID" in ghci
11:17:12 <srhb> f-a: I don't I'm afraid. I have the luxury of only working on the same arch all the time.
11:17:21 <f-a> luck you ;)
11:17:27 <srhb> Indeed.
11:18:16 <srhb> Could this Data.UUID problem be because of a bug with name clashes?
11:18:20 <alisia2> geekosaur, Browse shows only a data defenition and two functions asWords32s and asWords62s
11:18:24 <srhb> ie try hiding fromString from Prelude, if it exists there
11:18:52 <srhb> Or maybe the reexports are broken
11:19:03 <srhb> I wonder if you can import Data.UUID.Internal
11:19:08 <fishythefish> srhb, wouldn't the name be in scope though?
11:19:25 <srhb> Either way the problem is bizarre and probably fixed in a newer ghc. At least I've never seen it :P
11:19:46 <geekosaur> wrong package
11:19:55 <geekosaur> those names are from the system-uuid package
11:20:02 <geekosaur> http://hackage.haskell.org/package/system-uuid-2.1.1/docs/Data-UUID.html
11:20:13 <geekosaur> which is why I asked about the ghc-pkg find-module
11:20:32 <srhb> Oh derp.
11:20:40 <fishythefish> ...
11:21:20 <srhb> so ghc-pkg unregister system-uuid I guess?
11:21:33 <geekosaur> yes, and if necessary then cabal install the other one
11:22:05 <alisia2> geekosaur, find-module shows  /var/lib/ghc/package.conf.d and /home/vagrant/.ghc/x86_64-linux-7.4.1/package.conf.d
11:22:40 <geekosaur> I would hope it would say a little more than that
11:23:23 <geekosaur> I am guessing it would show system-uuid-2.1.1 in one of those package databases
11:23:49 <alisia2> But system-uuid is in the sandbox.
11:29:08 <geekosaur> I think you just added complexity. are you using ghci, or cabal repl?
11:29:26 <geekosaur> or perhaps ghci inside a `cabal exec bash` or similar?
11:30:03 * geekosaur is navigating conference calls and a bit spottily available...
11:30:12 <dfeuer> Hoooooooly moly.
11:30:31 <alisia2> geekosaur, this is in a cabal repl http://lpaste.net/134185
11:30:48 <dfeuer> You know you've got trouble when the compiler spits out a type too long for your scroll buffer :P
11:30:51 <geekosaur> ok, then you're going to have problems if both of those modules are available
11:31:00 <geekosaur> er, both of those packages
11:31:11 <geekosaur> my guess is that system-uuid will win because it's in the sandbox
11:31:23 <alisia2> geekosaur, but I also tried in a plane ghci..
11:31:25 <geekosaur> in a program you could use the PackageImports extension to disambiguate
11:32:08 <geekosaur> I think I want to see the output from "ghc-pkg list" at this point
11:32:14 <geekosaur> (to lpaste.net, it will be long)
11:32:24 <alisia2> geekosaur, in sandbox?
11:32:42 <geekosaur> from whichever shell you are running ghci from
11:33:04 <geekosaur> (part of this is checking to see if the sandbox is showing up in general operations not involving cabal exec / cabal repl / etc.)
11:33:44 <alisia2> geekosaur, http://lpaste.net/134187
11:34:08 <geekosaur> hm
11:34:30 <geekosaur> so in theory that ghci import would fail because it can't find it (and the :m + form would report that)
11:34:40 <alisia2> geekosaur, but can ghci see packages in a sandbox?
11:34:52 <geekosaur> not by default
11:34:56 <geekosaur> which is what cabal repl is for
11:34:58 <geekosaur> *but*
11:35:17 <geekosaur> some people have a habit of starting a shell "inside" the sandbox: cabal exec bash
11:35:32 <geekosaur> *then* anything you run (ghc-pkg, ghci, ghc) will see the sandbox if run in that bash
11:37:04 <alisia2> geekosaur, ok. anything else you want me to try?
11:37:19 <OmnipotentEntity> srhb: actually it looks like it's based on actual math
11:37:25 <geekosaur> not offhand but this concall is heating up and I have to focus elsewhere for a bit :/
11:37:36 <geekosaur> hopefully someone else can pick up from here
11:37:51 <OmnipotentEntity> ⍟ apl functional symbol circle star
11:37:51 <alisia2> geekosaur, no probs
11:37:57 <OmnipotentEntity> U+229B is related to U+235F which is
11:38:01 <OmnipotentEntity> wrong order
11:38:08 <alisia2> geekosaur, thankyou.
11:44:08 <OmnipotentEntity> ugh, nevermind the circle star means "logarithm" in APL
11:45:34 <hexagoxel> alisia2: the package listing was from plain `ghc-pkg list`?
11:45:47 <hexagoxel> because it does not contain uuid..
11:46:35 <alisia2> hexagoxel, yes. probably because it cant see the packages in the sandbox..
11:46:53 <hexagoxel> alisia2: try `cabal sandbox hc-pkg list`
11:47:27 <hexagoxel> and post that, or say the version of uuid
11:47:47 <alisia2> ok
11:48:47 <alisia2> hexagoxel, http://lpaste.net/134191
11:49:03 <alisia2> hexagoxel, uuid version 1.3.10
11:49:33 <alisia2> hexagoxel, system-uuid version 2.1.1
11:50:11 <rui2> Buhbye
11:50:32 <hexagoxel> ah, interesting. your import probably takes system-uuid:Data.UUID
11:50:38 <hexagoxel> for whatever reason..
11:51:00 <hexagoxel> module names are unique for the most part, so this is somewhat of a special case
11:51:10 <hexagoxel> alisia2: do you need system-uuid?
11:51:34 <alisia2> it contains a function uuid that generates random uuids...
11:51:40 <alisia2> hexagoxel, it contains a function uuid that generates random uuids...
11:51:55 <zipper> A cabal library function which checks whether a package has been configured?
11:53:33 <fizbin> Does anyone have an example of how to set up the types to use ST arrays, or the ST monad in general?
11:54:02 <hexagoxel> alisia2: uhm, system-uuid or uuid? it seems you can generate random uuids with package `uuid` just fine
11:54:30 <fizbin> I'm stuck trying to figure out what type signature I need to put on this to get it to compile: setupSTArray = return $ newArray (0::Int, 33::Int) (M.empty :: Map Int Int)
11:54:44 <hexagoxel> alisia2: assuming that you do not need system-uuid: `cabal sandbox hc-pkg unregister system-uuid`
11:54:45 <alisia2> hexagoxel, ok. So you want me to try uninstalling the system-uuid ?
11:54:53 <alisia2> ok
11:55:24 <fizbin> I can't figure out how to say "Yes, I would like something that operates in the ST monad and returns an STArray that has Ints as an index and (Map Int Int) as elements.
11:56:08 * hexagoxel tries to remember if there is a special import syntax to specify the package as well, to cope with non-unique module names
11:56:40 <Iceland_jack>  
11:56:41 <Iceland_jack> fizbin: 
11:56:41 <Iceland_jack>     something :: ... -> ST s (STArray s Int (Map Int Int))
11:56:41 <Welkin> hexagoxel: build-depends in .cabal
11:56:56 <fizbin> Iceland_jack: Nope. That's what I tried.
11:57:09 <hexagoxel> Welkin: that would not help if you wanted to depend on both packages
11:57:24 <alisia2> hexagoxel, it worked!
11:57:38 <Iceland_jack> How does it fail fizbin 
11:57:45 <hexagoxel> ah, "Package-qualified imports"
11:57:56 <hexagoxel> `import "network" Network.Socket`
11:58:05 <alisia2> hexagoxel, but I cannot find the uuid function...
11:58:21 <Iceland_jack> fizbin: I didn't use a set but this works "newArray (0 ::Int, 32) [] :: ST s (STArray s Int [Int])"
11:58:31 <hexagoxel> so using `import "uuid" Data.UUID` should work as well
11:58:40 <alisia2> hexagoxel, I mean, the function to generate random uuid's
11:59:07 <fizbin> Iceland_jack: Well, here's my error: http://lpaste.net/134192
11:59:15 <Iceland_jack> fizbin: If you apply "runSTArray" to that you get back an "Array Int [Int]"
11:59:37 <fizbin> Oh. Maybe the return is extra?
11:59:53 <hexagoxel> alisia2: but there is `instance Random UUID`
11:59:56 <Iceland_jack> fizbin: yes
12:01:07 <Iceland_jack> fizbin: We can instantiate the type of "newArray" to
12:01:07 <Iceland_jack>     newArray :: (Int, Int) -> Map Int Int -> ST s (STArray s Int (Map Int Int))
12:02:40 <alisia2> hexagoxel, Yes, there is a nextRandom function in Data.UUID.V4..which seems to work.
12:02:55 <Iceland_jack> fizbin: Just like "newSTRef :: a -> ST s (STRef s a)" creates an STRef already in "ST s" 
12:03:24 <Iceland_jack> if the whole ST monad feels confusing you can play around with Data.STRef 
12:03:32 <fizbin> Yeah. This is also my first time really working in ST beyond toy examples done many months ago.
12:03:51 <Iceland_jack> I see, then STRef is probably a simpler start
12:04:02 <hexagoxel> alisia2: or: import System.Random; (randomIO :: IO UUID) >>= print
12:04:38 <hexagoxel> nextRandom is just an alias for System.Random.randomIO :)
12:05:08 <alisia2> hexagoxel, yes. It makes sense. I am new to haskell. So these are all new to me.
12:05:21 <Iceland_jack> fizbin: This is how you would sum a list
12:05:21 <Iceland_jack> > runST (do ref <- newSTRef 0; F.for_ [1,2,3,4] (\number -> modifySTRef ref (+ number)); readSTRef ref)
12:05:25 <lambdabot>  10
12:05:29 <alisia2> hexagoxel, but I can see how that works.
12:05:51 <Iceland_jack> If you squint it looks similar to something like
12:05:51 <Iceland_jack>     acc = 0
12:05:51 <Iceland_jack>     for x in [1,2,3,4]:
12:05:51 <Iceland_jack>       acc += x
12:05:54 <Iceland_jack>     return acc
12:07:28 <ew0> hey, is there a neat way to get the first Right if it exists in a list
12:07:40 <ew0> but if not, I get the first Left
12:07:41 <ew0> ?
12:08:27 <Iceland_jack> ew0: "msum" comes close
12:08:50 <alisia2> hexagoxel, Everything works now. Thanks a bunch. Couldn't have done it without you guys.
12:13:17 <japesinator> is there a good solution for cabal dependency loosening other than going in hackage and seeing what works?
12:16:46 <athan> Does anyone know the lookup path for .hsc includes? When I use `#include <hdf5.h>` for instance, it can't find the file `/usr/include/hdf5/serial/hdf5.h`
12:17:35 <burp> possibly this just uses the c preprocessor
12:18:07 <burp> so it uses the same paths, and you can include additional ones with some -I flag (just my guess)
12:18:45 <chpatrick1> hsc2hs literally makes a C program that prints out haskell
12:18:58 <chpatrick1> so presumably it includes whatever the compiler includes
12:19:16 <hexagoxel> japesinator: nope. for upper bounds, the stackage nightly might be interesting. compiling with older ghc may provide lower bound for base.
12:20:00 <athan> Hmm, okay thanks burp and chpatrick1
12:20:16 <Denommus> anyone had experience using GHCJS for programming a mobile app?
12:20:37 <hexagoxel> japesinator: afaik, there are some tools on hackage that try to find out-of-date upper bounds, but nothing that really does automated "try (compile+test) every version until it breaks"
12:21:19 <burp> jasonkuhrt: cabal-bounds is quite useful for setting/removing bounds
12:21:38 <jasonkuhrt> burp: Wrong person
12:21:52 <burp> err, yea, bad tab completion, sorry ;)
12:25:36 <geekosaur> ok, off the call now >.>
12:26:17 <athan> geekosaur: ghost busters, I assume?
12:27:28 <geekosaur> no, work team decided it wanted to do scrum-type daily meetings
12:27:30 <jle`> Denommus: i did a simple one page todo app that worked on mobile, if that counts
12:27:48 <geekosaur> reason I mentioned here is I was trying tohelp someone with a module issue and got pulled away for the scrum-thing
12:28:17 * athan "who you gonna call?"
12:28:20 <geekosaur> (an hour ago, whoops, that meeting went longer than claimed)
12:28:35 <ew0> what package msum comes from?
12:28:56 <geekosaur> @index msum
12:28:57 <lambdabot> Data.Foldable, Control.Monad
12:29:15 <hexagoxel> geekosaur: i took over :)
12:29:33 <Denommus> jle`: how was it?
12:29:50 <Denommus> jle`: I mean, was the performance comparable to a native application, or was it too heavy?
12:30:12 <jle`> it depends on what you want to do, but for simple things it wasn't too bad i think
12:30:22 <jle`> it was a toy project so it didn't see any real rigorous testing
12:30:43 <jle`> but i remember it being as responsive on mobile as it was online
12:30:48 <jle`> er, on desktop
12:31:04 <jle`> if you wanted to build like a 3d game then you might have problems going the ghcjs html5 route
12:33:52 <dgpratt> the announcement for stack mentions "You can just run `stack
12:33:52 <dgpratt> build` in a package directory..."
12:34:02 <dgpratt> what do they mean exactly by 'package directory'?
12:34:35 <hexagoxel> geekosaur: i only still find strange that ghc(i) would import an ambiguous module without any warning
12:34:43 <ew0> msum works for Maybe, but not for Either
12:34:43 <Denommus> jle`: I don't want a game
12:34:48 <ew0> really?
12:35:01 <geekosaur> ghci has always been kinda dumb :/
12:35:18 <geekosaur> the usual response to that from upstream is "patches gratefully accepted"
12:35:26 <srhb> dgpratt: Presumably your stackified (stack.yaml) project
12:36:08 <dgpratt> srhb, ok -- it mentions that it will create a stack.yaml file if necessary, though
12:36:26 <srhb> dgpratt: Presumably it's smart about cabalized things. I haven't tried it.
12:36:29 <dgpratt> create it based on what, I wonder
12:36:48 <srhb> cabal files, probably :)
12:37:00 <srhb> Or it's just an empty scaffold. Try!
12:41:15 <dgpratt> ok, basic question: how do folks usually create/maintain a .cabal file; I assume they're usuall created with cabal init?
12:41:44 <dgpratt> but what about referencing packages? do you hand edit? do you specify the package version?
12:43:12 * hackagebot yesod-mangopay 1.11.1 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.11.1 (FelipeLessa)
12:43:19 <jle`> dgpratt: usually cabal init, yeah
12:43:28 <jle`> and i usually add in dependencies by hand
12:43:40 <dgpratt> I see
12:43:47 <jle`> i don't specify versions unless i need to later on...like needing to give lower bounds
12:44:19 <dgpratt> jle`, do you or have you used stackage?
12:44:29 <jle`> i haven't
12:45:24 <dgpratt> I have the impression that it fixes all the packages at a particular version -- I'm wondering if I should reflect that in the .cabal file when I reference a package
12:45:46 <napping> Isn't the point of it to not do that?
12:46:05 <napping> I think there was a "cabal.config" file you can drop into your project that specifies those versions
12:46:16 <dgpratt> napping, probably
12:46:31 <mniip> is there a simple way to check if a value is zero, with Num but without Eq
12:46:47 <dgpratt> pattern match?
12:46:49 <dgpratt> oh
12:46:53 <dgpratt> nvm
12:47:16 <jle`> mniip: none of the Num methods give you a Bool, so you might have problems
12:47:27 <napping> mniip: even worse, they all return an "a"
12:47:29 <mniip> hmm
12:47:32 <mniip> dang
12:47:52 <napping> What makes you need to do that?
12:48:23 <jle`> some num instance smight not have a decidable "check for zero" method, either
12:48:27 <mniip> just trying to remove unnecessary constraints
12:48:38 <frerich> Does anybody have some ideas of how to automate testing of a TH function? I have some TH code which generates a function given some type and now would like to ensure that it still works as intended for various types.
12:48:50 <mniip> given I already use genericLength-esque stuff
12:48:53 <Denommus> ok, I think I'll do my app in Haskell. Xamarin is Windows and OS X only
12:49:07 <jle`> ie, some specific encoding of arbitrary precision reals...the Num b => a -> b instance, etc.
12:51:44 <napping> mniip: Num used to imply Eq and Show
12:56:07 <Gurkenglas> cabal install cabal-install failed :I
12:56:36 <geekosaur> "Xamarin is Windows and OS X only" wait what?
12:56:56 <hexagoxel> Gurkenglas: you probably need a newer cabal-install to install cabal-install
12:57:24 <Gurkenglas> Can I install intermediate versions of cabal-install to bootstrap?
12:57:37 <Gurkenglas> *cabal-
12:57:51 <napping> You might as well just bootstrap from the tarball
12:58:12 <napping> https://www.haskell.org/cabal/download.html
12:58:41 <hexagoxel> Gurkenglas: i was joking :)
12:59:51 <Gurkenglas> How do I see my current version of network?
13:00:15 <geekosaur> ghc-pkg list network
13:01:01 <napping> you might also try cabal info network, if you are using cabal sandboxes
13:17:31 <zmbmartin> Can I get doctest to use less memoy. I am getting a failure with travis-ci of `doctests: user error (Language.Haskell.GhciWrapper.close: Interpreter exited with an error (ExitFailure 9))`
13:18:09 <zmbmartin> Unless that error is for something else. I assume it is memory related. But 7.8 and 7.10 pass fine.
13:18:13 * hackagebot HandsomeSoup 0.4.2 - Work with HTML more easily in HXT  http://hackage.haskell.org/package/HandsomeSoup-0.4.2 (AdityaBhargava)
13:21:02 <metallic> Hello, I have just installed haskell platform to my GNU/Linux. When trying to run ghci it says that it cannot find libgmp.so, I also cannot find libgmp.so in /usr/lib/ neither /lib/
13:21:29 <metallic> There are some gmp-related packages available on the repositories, which one should I pick?
13:21:55 <Clint> metallic: the soversion is important
13:22:11 <metallic> soversion? @.@
13:22:56 <metallic> you mean the version of the so library?
13:23:33 <Clint> metallic: like libgmp.so.{3,10,whatever}
13:24:05 <metallic> Clint: the ghci command simply says libgmp.so, no version
13:24:50 <metallic> and on the repos I see <libgmp3-dev> and <libgmp10> among others
13:25:28 <Clint> metallic: if you install the ghc .deb you may find yourself much happier
13:26:55 <Haskellfant> is there something like zipWith for maps?
13:27:30 <merijn> Haskellfant: unionWith?
13:27:42 <Haskellfant> merijn: ah perfect
13:27:43 <Haskellfant> thanks
13:27:53 <verement> metallic: libgmp10 is probably what you want
13:28:21 <metallic> verement: libgmp10 is already installed on my system according to apt-get
13:28:23 <metallic> :/
13:28:44 <Haskellfant> metallic: ah no, that's not quite it, I have different types
13:28:56 <Clint> metallic: if it's actually trying to find the .so you'll want the -dev package too
13:29:05 <verement> metallic: try libgmp-dev?
13:29:08 <Haskellfant> merijn: ah no, that's not quite it, I have different types
13:29:16 <merijn> Haskellfant: That can't work
13:29:22 <merijn> Haskellfant: What if a key is missing?
13:29:37 <Haskellfant> merijn: hm that can't happen in my case, but I get your point
13:30:15 <metallic> BINGO
13:30:17 <metallic> :)
13:30:25 <metallic> thanks Clint and verement
13:30:38 <Haskellfant> I am collecting the maps during two traversals so the keys have to be the same
13:31:21 <metallic> I am totally new to Haskell ( and I dive into it just for curiosity/fun). I come from the C programming language :)
13:31:22 <dolio> intersectWith
13:31:45 <ski> Haskellfant : you can't traverse only once ?
13:31:55 <verement> metallic: the adventure is totally worth the effort
13:32:08 <Haskellfant> ski: not easily at least, as the second traversal depends on the first
13:32:25 <ski> Haskellfant : depends on the final whole result of the first ?
13:32:30 <Haskellfant> yep
13:32:40 <metallic> verement: I can't say yet, but since I am studing maths I think it will serve me well, at least in short-term
13:32:55 <Haskellfant> I guess I could construct the final type that I want during the second traversal
13:33:01 <ski> Haskellfant : you could accumulate `(FirstResult,FirstResult -> OverallResult)'
13:33:14 * hackagebot rethinkdb 2.0.0.0 - A driver for RethinkDB 2.0  http://hackage.haskell.org/package/rethinkdb-2.0.0.0 (codedmart)
13:33:34 <Haskellfant> ski: sorry I don't quite get what you mean by that
13:33:54 <merijn> ski++
13:34:06 <merijn> Haskellfant: intersection grabs the overlapping keys of two maps
13:34:13 <merijn> Haskellfant: So that can do what you want
13:34:44 <ski> Haskellfant : i mean, only one traversal, but accumulate both the info that corresponds to the first pass, and for the second pass a function that when given then final result of the first pass will also compute the second thing
13:34:46 <merijn> It's actually intersectionWith
13:35:29 <Haskellfant> ski: ah yeah I guess I could do that, thanks
13:35:39 <Haskellfant> merijn: great, I'll go with that as a quick solution and clean it up later :)
13:36:38 <ski> Haskellfant : i haven't really gotten the details of what you're doing, but if you're accumulating maps, then you perhaps (i'm not sure) would want to build those pairs in the value part of a map
13:37:06 <ski> Haskellfant : anyway, it's good to know about this alternative to multiple traversals on the same structure
13:38:00 <ski> (`repMin' ftw)
13:41:45 <Haskellfant> ski: I have tabular data consisting of a bunch of numerical columns and a class column. I want to calculate the mean and the variance for each class for each column. To do that I fold over the data keeping the values for each class in a map. To calculate the variance I need the mean, so those have to be 2 traversals. After that I want to combine it in one map mapping the class to a tuple of mean and variance
13:43:00 <ski> Haskellfant : *nod*, sounds like the staged method i suggested could work then
13:43:27 <ski> (btw, you're possibly cut off after ".. After that I want to combine it in one map mapping the class to a tuple of mean and variance")
13:43:56 <Haskellfant> no that's all :)
13:44:09 <ski> you could alternatively try to do it circularly ("tying the knot") -- but it's easier to mess up (and get a hanging program), that way
13:44:37 <Haskellfant> yeah, I've thought about that, but didn't think it is worth it in that case
13:44:42 <ski> @wiki Tying the knot
13:44:42 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_knot
13:44:44 <bitemyapp> @karma+ quchen
13:44:44 <lambdabot> quchen's karma raised to 16.
13:44:52 <quchen> :-)
13:44:53 <quxbam> When telling cabal to use much more cpus than there are, does this affect a lot the installation time?  I'm interested in seeing how many cpus *could* be used in parallel...
13:45:12 <metallic> I see that 5**2 yields 25.0   I guess then that x raised to y (x**y) is computed by the mathematical expression exp(y*log(x)) right?
13:45:18 <ski> bitemyapp : what for ? ;)
13:45:35 <dgpratt> I'm curious, of those who care to respond, who uses stackage and who does not?
13:46:28 <bitemyapp> ski: MonadFail
13:46:37 <johnw> dgpratt: I do not
13:46:41 <athan> Anyone here have issues with getting hsc2hs to find the right header files & ld lookup paths?
13:46:52 <ski> bitemyapp : elaboration ?
13:47:07 <ski> (aka "what about it ?")
13:47:18 <bitemyapp> ski: https://github.com/quchen/articles/blob/master/monad_fail.md
13:47:25 <bitemyapp> ski: posted to mailing list by quchen.
13:48:08 <athan> bitemyapp: !
13:48:32 <quchen> Fail be gone
13:48:46 <jorisbuc> Hi, I try to pattern match Array when parsing JSON with Data.Aeson, anyone know how to do it? http://stackoverflow.com/questions/30742375/pattern-match-vector-value-in-data-aeson
13:48:47 <lrocksmashtime> is it possible to use getChar to capture arrow key press. if so what would the resulting characters be for each arrow key?
13:49:46 <OmnipotentEntity> lrocksmashtime: the actual characters depend on the terminal in use
13:50:23 <glguy> lrocksmashtime: What happened when you tried?
13:50:58 <lrocksmashtime> i believe getChar does capture it. just trying to figure out what the actual code is when I try to do some kind of logic on it
13:51:04 <bitemyapp> to be fair, it should've been obvious from the start that
13:51:06 <bitemyapp> @ty fail
13:51:07 <lambdabot> Monad m => String -> m a
13:51:08 <OmnipotentEntity> lrocksmashtime: it sounds like you're trying to create a terminal GUI, if this is correct, I recommend looking into the ncurses package
13:51:16 <bitemyapp> was some bullshit to begin with, but at least we can fix it.
13:51:34 <lrocksmashtime> right now i'm happy just getting something working in my mac terminal
13:51:45 <geekosaur> lrocksmashtime, on modern terminals the arrow key is 3 characters
13:52:05 <geekosaur> ESC (0x27), left bracket [, D
13:52:12 <merijn> OmnipotentEntity: The ncurses package is pretty terrible, actually
13:52:19 <merijn> OmnipotentEntity: I would recommend vty and vty-ui
13:52:30 <merijn> OmnipotentEntity: They are far more convenient to use from haskell
13:52:32 <lrocksmashtime> got it
13:52:36 <geekosaur> (try pressing control-V in a terminal window, then the arrow or function key)
13:52:38 <lrocksmashtime> up arrow is 'A'
13:52:41 <OmnipotentEntity> merijn: lrocksmashtime, do what merijn says, he's got way more experience than I do
13:53:09 <geekosaur> (n)curses is pretty commonly used. it is also very well named. >.>
13:53:15 <lrocksmashtime> i'll look at the vty and vty-ui packages 
13:53:19 <lrocksmashtime> thanks peeps
13:53:28 <merijn> vty actually abstracts this and gives you  a generic Key ADT
13:53:37 <geekosaur> it's not a plibrary with lots of weird special cases; it's a collection of special cases pretending to be a coherent library
13:53:39 <merijn> And then you just get like "KLeft"
13:54:05 <merijn> vty-ui is basically "G"UI widgets for the terminal using vty
13:54:12 <OmnipotentEntity> lrocksmashtime: I get 0x1b 0x5b 0x41 for "up" on my Mac terminal
13:54:14 <merijn> Things like buttons, text boxes, etc.
13:54:59 <OmnipotentEntity> the rest are the same, except down is 0x42, left is 0x43 and right is 0x44
13:55:11 <OmnipotentEntity> orry
13:55:22 <OmnipotentEntity> sorry, right is 0x43 and left is 0x44
13:55:24 <OmnipotentEntity> hope this helps
13:55:27 <phaazon> hm, isn’t fmap lines getContents supposed to return a list of lines?
13:55:37 <phaazon> I get a singleton value
13:56:03 <geekosaur> um. aside from it being an IO action?
13:56:27 <dgpratt> thanks for the response, johnw -- I'm getting the impression that hard-core Haskellers have no use for it
13:56:32 <geekosaur> :t fmap lines getContents
13:56:35 <lambdabot> IO [String]
13:57:10 <phaazon> I pass it a file with several lines
13:57:17 <phaazon> (via pipes)
13:57:21 <phaazon> and it seems to ignore the \n
13:58:08 <ski> quchen : nice :)
13:58:10 <phaazon> I guess I’ll go with getLine + isEOF
13:59:15 <ronh-> lines strips trailing newlines if that is what you mean
13:59:25 <ronh-> trailing newline*
14:01:28 <phaazon> I think the problem is related to cat
14:01:39 <phaazon> cat myFile | … ignores newlines
14:01:44 <phaazon> echo "ab\ncd" | … doesn’t
14:01:48 <phaazon> what the fu** :D
14:02:05 <c_wraith> cat should not be ignoring newlines
14:02:22 <phaazon> well, my file is the following:
14:02:40 <phaazon> http://lpaste.net/134196
14:03:06 <OmnipotentEntity> if you hexdump -C your file are the newlines 0x0a or some other value?
14:06:44 <geekosaur> I'm tempted to suggest LANG=C od -c myFile
14:06:44 <geekosaur> or hexdump
14:06:44 <geekosaur> make sure your editor isn't hiding pre-OS X Mac line endings or something
14:06:44 <phaazon> hm
14:06:44 <phaazon> nevermind, it works now
14:06:44 <phaazon> I guess the problem was due to the way I used the result
14:06:44 <phaazon> print a -- seems to consider the whole thing as a String
14:06:44 <phaazon> traverse_ print a -- works
14:06:44 <phaazon> putStrLn*
14:06:44 <phaazon> traverse_ putStrLn a
14:06:44 <geekosaur> "print a" is putStrLn (show a)
14:06:44 <phaazon> I know
14:06:44 <webchat099> in haskell isn´t  IO  a sinful action?
14:06:44 <geekosaur> ????
14:06:44 <ion> no
14:06:44 <phaazon> a sinful action? :D
14:06:44 <arkeet> only unwrapping IO is.
14:06:44 <geekosaur> also you can be confused by ghci sometimes imputing `show` when you might not expect it
14:06:44 <phaazon> I’m not using ghci
14:06:44 <phaazon> maybe it’s some kind of internal optimization?
14:06:44 <phaazon> GHC detects the lines, but see that the only use is to cast that to a String, so it ignores the lines?!
14:06:45 <phaazon> that sounds silly
14:09:33 <webchat099> we can say that ghci like any repl  is "reactive"
14:13:26 <nullx002> can design some code to find a number whose all factors are
14:13:26 <nullx002>            primes??
14:14:05 <ski> no, `1' is not a prime
14:14:29 <mauke> ski: factors 1 == []
14:14:32 <mauke> all of which are prime
14:14:49 <ski> `1' is a factor of any integer
14:14:54 <phaazon> none of them are prime as well
14:14:56 <merijn> mauke: Eh, wouldn't the factor of 1 be 1?
14:15:03 <Welkin> is 0 prime?
14:15:10 <nullx002> 0 is not prime
14:15:14 <nullx002> neither 1
14:15:16 <phaazon> Welkin: it as any number as a factor
14:15:28 <mauke> ski: ah, right
14:15:53 <lamefun> does Haskell have muilti-line strings?
14:15:58 <nullx002> save all factors in a set - > check set for primes - > if all are primes than output - > else exit
14:16:04 <mauke> lamefun: yes, but only annoying ones
14:16:06 <ski> Welkin : `0' is primal, in the sense that if it divides a product, then there is a factor in the product that it divides
14:16:07 <ronh-> part of the definition of a prime number is "greater than 1"
14:16:25 <ski> lamefun : "foo\   \bar"
14:16:45 <ski> ronh- : that doesn't work if you don't have ordering
14:17:12 <nullx002> ronh- why it doesnt wokr?>
14:18:16 * hackagebot propellor 2.5.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-2.5.0 (JoeyHess)
14:18:29 <ReinH> glguy: I'm using glirc :)
14:18:42 <dolio> It's much easier. 0 isn't in the domain of discourse, so you don't have to worry about it.
14:19:41 <ski> (which domain of discourse ?)
14:19:54 <pavonia> nullx002: When you say "all factors", what exactly do you mean?
14:20:08 <dolio> The natural numbers, as defined by number theoreists.
14:20:15 <dolio> Theorists, even.
14:20:48 <ski> how about gaussian integers ?
14:20:52 <Cale> A unit u is a number such that there exists v such that u * v = v * u = 1. A prime p is a nonzero nonunit such that if p divides the product a b, then p divides a or p divides b.
14:21:02 <nullx002> factors of a numebr N > 3 accepted by input pavonia
14:21:30 <merijn> mauke: What's annoying about them?
14:21:46 <ski> Cale : the "nonunit" part is a consequence of `p' dividing a factor in case it divides an empty product
14:21:50 <dolio> merijn: You can't put comments in the whitespace.
14:22:09 <ski> Cale : i'm not sure about the "nonzero" part
14:22:20 <merijn> dolio: Sure you can, just encode it using whitespace characters :p
14:22:20 <pavonia> nullx002: Given the number 12, what are the factors according your definition?
14:22:25 <mauke> merijn: you have to write "...\n\
14:22:30 <mauke> \..." to get a newline
14:22:42 <Cale> ski: what empty product? Oh, you want to generalise to arbitrary products?
14:22:50 <nullx002> pavonia: it is 2 3 4 6 
14:22:54 <nullx002> saved in a set
14:22:55 <mauke> I don't really understand what the point of gaps even is
14:23:02 <nullx002> than set is checked for primes
14:23:08 <nullx002> 2 4 6 are not primes...
14:23:08 <ski> Cale : one case for empty products, and one for binary. or, if you prefer, one case for arbitrary finitary products
14:23:09 <merijn> mauke: If you want multiple lines you could just write a list of strings and unlines it
14:23:20 <pavonia> 2 is a prime
14:23:29 <merijn> mauke: linewrapping really long strings without linebreaks to 80 chars?
14:23:43 <nullx002> so for number N (input) all factors are not primes
14:23:51 <theorbtwo> He specified factors, not prime factors.
14:23:56 <nullx002> doesn't matter even one of them is not a prime than reject it
14:24:21 <ski> nullx002 : `1' is always a factor. `1' is not a prime
14:24:23 <Cale> nullx002: No number has only prime divisors. In particular, 1 is a divisor of any number, and it is not prime.
14:24:40 <mauke> merijn: how often do you have really long single-line strings?
14:24:46 <nullx002> exclude 1 and 2 from set using some method
14:24:52 <nullx002> programming method i mean
14:25:09 <merijn> mauke: Not often, but if I do have linebreaks in there they usually don't match the width I wanna wrap my source at, so it still works
14:25:17 <Cale> nullx002: I'm just trying to work out what it is that you're asking for...
14:25:37 <mauke> that sounds unreadable
14:25:42 <nullx002> jsut a min will make it more clear
14:26:06 <Kole> hi, is there a way to solve the bowling game using list of lists
14:26:08 <Kole> ?
14:26:37 <RickP> has anyone used htrace has anyone used Debug.HTrace recently
14:27:10 <Cale> Kole: What is the bowling game?
14:27:13 <nullx002>  
14:27:13 <nullx002> accept input - > N
14:27:13 <nullx002> find all factors of that number N and store it in a set - > C
14:27:13 <nullx002> if all numbers in set C are primes than print some output - > p
14:27:15 <nullx002> or else exit - > E
14:27:18 <nullx002>  
14:27:22 <nullx002> is such a program possible in haskell?
14:27:32 <Cale> yes
14:28:10 <c_wraith> Err..  what does "all factors" mean?
14:28:12 <nullx002> how efficient it can be?
14:28:32 <Cale> nullx002: As efficient as it could be in any other language -- nothing too special about Haskell here.
14:28:44 <c_wraith> Because if I consider 1 to be a factor, then it's O(1) time.  1 is a factor of all numbers and not prime.
14:28:58 <fvgvxmpv1> Is my observation, that '0' does not read as Float correct? Is there a specific reason why the '.0' would be required?
14:29:00 <nullx002> it may consume lot of energy if you input a large number say 32 digit
14:29:09 <Cale> fvgvxmpv1: hm?
14:29:13 <Cale> > read "0" :: Float
14:29:16 <lambdabot>  0.0
14:29:21 <c_wraith> > 0 :: Float
14:29:21 <Cale> > 0 :: Float
14:29:22 <Kole> Cale: http://ronjeffries.com/xprog/articles/dbchaskellbowling/
14:29:29 <fvgvxmpv1> ok, apparently not
14:29:31 <lambdabot>  <no location info>: can't find file: L.hs
14:29:31 <lambdabot>  0.0
14:30:05 <dfeuer> The correct thing, I think, is for fromInteger and fromRational to be in entirely separate type classes; not Num.
14:30:34 <bitemyapp> hexagoxel: ding
14:30:45 <nullx002> it requires lot of processing power
14:30:47 <Cale> dfeuer: They... are?
14:30:47 <bitemyapp> hexagoxel: I have code that does what I wanted, but I think I misformulated what I was doing originally.
14:31:10 <bitemyapp> hexagoxel: I will attempt to reformulate from the current working version.
14:31:17 <dfeuer> Cale, er... sorry. fromInteger is in Num, which it shouldn't be, and fromRational is in Fractional, which it shouldn't be.
14:31:24 <bitemyapp> @ty fromInteger
14:31:29 <lambdabot> Num a => Integer -> a
14:31:52 <dfeuer> My reasoning is that Float, Double, and Complex support them, but are not numbers.
14:32:10 <bitemyapp> dfeuer: numerical geometries as our friend would say? :P
14:32:13 <Cale> nullx002: If you want to exclude 1 from the list of factors being considered there, so that the program would ever do anything other than simply exit (which is certainly not expensive!), then you're effectively asking to determine whether N is prime.
14:32:24 <dfeuer> bitemyapp, whats?
14:32:29 <Cale> dfeuer: Why shouldn't fromInteger be in Num?
14:32:38 <dolio> If you're suggesting that Float and Double would not be in Num, that's not going to happen.
14:32:38 <ski> Cale : anyway, i'm not sure whether there's a point with the "nonzero" in there. cf. prime ideals
14:32:48 <Cale> dfeuer: If we didn't have fromInteger in Num, we would want zero and one to be.
14:32:50 <dfeuer> Cale, hmm... maybe that's okay, actually.
14:32:55 <dfeuer> er...
14:32:58 <Cale> dfeuer: But given zero and one, you can define fromInteger
14:33:03 <dfeuer> Hold on...
14:33:17 <bitemyapp> dfeuer: float/double
14:33:23 <dfeuer> Right.
14:33:40 <dfeuer> Cale, that was the point. Float/Double/Complex support fromInteger, but are not numbers.
14:33:44 <dolio> Because no one really cares that Float and Double are not technically rings, they want (*) and (+) to work on them.
14:33:46 * dfeuer forgot his point briefly.
14:33:57 <c_wraith> They aren't numbers?  I find that surprising.
14:34:13 <c_wraith> Mostly because "number" is an incredibly vague term.
14:34:22 <nullx002> No Cale i will remove 1 and 2 from the set C
14:34:24 <Cale> They're numbers, they're just not rings :)
14:34:26 <dfeuer> c_wraith, they don't feel very numbery.
14:34:41 <hexagoxel> bitemyapp: btw you did see my forall change yesterday? i guess it was not the solution you were looking for?
14:34:55 <bitemyapp> hexagoxel: I didn't see, I was about to try it using forall
14:34:57 <dfeuer> Not rings, not rigs, not semirings, not groups, not monoids, not even semigroups.
14:35:01 <bitemyapp> I'm trying to reformulate it correctly.
14:35:03 <dfeuer> So ... not very numbery.
14:35:10 <Cale> nullx002: Oh, in that case, you're asking whether N is a prime number greater than 3, or else even, and N/2 is prime.
14:35:38 <nullx002> no i am asking if all factors of N > 3 are primes or not ...
14:35:44 <dfeuer> Aaaaanyawy.
14:35:49 * dfeuer runs away.
14:36:08 <c_wraith> nullx002: perhaps you mean "are all non-trivial divisors prime?"
14:36:10 <bitemyapp> :exf "(gmr -> b) -> o gtg -> (forall a b . o a -> b) -> [gts] -> b"
14:36:17 <Cale> nullx002: The only way for all the nonunit divisors to be prime is for there to be only a single prime factor.
14:36:32 <bitemyapp> oh nuts.
14:36:32 <c_wraith> nullx002: Which would then mean that they have no more than 2 prime factors
14:36:45 <exferenceBot> could not find expression; aborting after 30 sec
14:36:51 <fishythefish> nullx002, else the product of two of those primes would also be a factor.
14:37:02 <bitemyapp> :exf "(gmr -> b) -> o gtg -> (forall a b . o a -> b) -> (gmr -> b )-> [gts] -> b"
14:37:06 <nullx002> yes
14:37:09 <nullx002> you are right
14:37:14 <c_wraith> On the other hand, if you're wondering about all prime factors, then they're all prime. :)
14:37:25 <fishythefish> c_wraith: :O
14:37:37 <exferenceBot> could not find expression; aborting after 30 sec
14:37:37 <hexagoxel> gmr, grg, gts?
14:37:44 * c_wraith has a clever algorithm for factoring prime numbers.  factor = id -- the input must be prime
14:37:45 <bitemyapp> trying to anonymise
14:38:05 <ion> factor :: Prime -> Prime
14:38:05 <Cale> c_wraith: Don't you mean factor = (:[]) ? :)
14:38:16 <mniip> factor = return
14:38:22 <c_wraith> Cale: Nah, I'm optimizing the list constructor out, since it's prime.
14:38:42 <c_wraith> Cale: so only one factor, after all!
14:38:57 <nullx002> but a number as such cna have 10 factors and 3 of them are prime... 
14:39:31 <napping> nullx002: this might be interesting: http://mathoverflow.net/questions/3820/how-hard-is-it-to-compute-the-number-of-prime-factors-of-a-given-integer
14:40:10 <c_wraith> nullx002: if a number has 3 prime factors, counting duplicates, then it has 3 non-prime proper divisors.  There aren't any tricks going on here.
14:40:48 <c_wraith> nullx002: on the other hand, if it has 3 prime factors not counting duplicates, then it could have any multiple of 3 non-prime proper divisors.
14:41:18 <napping> c_wraith: p^3 only has p^2 as a non-prime proper factor
14:41:29 <mniip> so, 'w x = x x' doesn't generally typecheck,
14:41:37 <fishythefish> napping, distinct factors, presumably.
14:41:38 <c_wraith> napping: it's ok, I'm counting it 3 times with duplicates. :)
14:41:39 <mniip> but it does when given a type of (forall t. t -> t) -> t -> t
14:42:02 <napping> anyway, the question seems to come down to deciding whether the number has at most two prime factors
14:42:08 <napping> but that's already hard
14:42:13 <mniip> wondering if there are any more general types for w
14:42:53 <napping> mniip: there's an infinite family pusing the forall deeper - ((forall s . s -> s) -> (forall s . s -> s)) -> ...
14:43:06 <c_wraith> mniip: there's no single most-general type for that
14:43:15 <napping> That's used as an example in the MLP papers, if you've seen that
14:43:17 * hackagebot webcrank 0.2.2 - Webmachine inspired toolkit for building http applications and services.  http://hackage.haskell.org/package/webcrank-0.2.2 (purefn)
14:43:21 <mniip> napping, which type of w would cover 'w const'
14:44:16 <nullx002> c_wraith: i read it, i knw some of alredy but practically on python i observed that it takes lot of processing power if you try to do that..
14:44:41 <mniip> except for, duh, (forall a. a -> b -> a) -> a -> b -> a -> b
14:44:44 <c_wraith> nullx002: probably only due to algorithmic issues.  It's very easy to search for primes very badly
14:45:04 <c_wraith> mniip: yep.  You can always brute force it to work with whichever x you want. :)
14:45:35 <c_wraith> mniip: and none of them are more general than any other.  There's no principle type, so HM can't infer a type for it.  It only infers principle types.
14:45:48 <napping> mniip: I don't think you can get the same result as (const const) out of any of them
14:46:01 <nullx002> c_wraith: on small numebrs prog is very efficient but on large numbers it is a hell
14:46:10 <napping> nullx002: that's factoring for you
14:46:43 <napping> c_wraith: whether there is a principal type depends on your type system
14:47:17 <nullx002> so is haskell better than python or C in that sense?"
14:47:51 <napping> nullx002: it's mostly number theory with the asymptotics killing you
14:48:09 <napping> Haskell probably lets you get better constant factors than Python and maybe not as good as C
14:48:12 <c_wraith> nullx002: well, GHC *can* produce more efficient numeric code than cPython...  when external libraries are ignored...  And you write exactly the right code.
14:48:41 <napping> well, that too - if your python code is calling out into optimized native-code libraries it can be plenty fast
14:48:42 <c_wraith> nullx002: but constant factors aren't the issue with brute-force factoring.
14:49:05 <nullx002> say... a random prime number generator accepting input from some user device...
14:49:11 <napping> nullx002: http://gilchrist.ca/jeff/factoring/nfs_beginners_guide.html
14:50:43 <napping> c_wraith: forall (a >= (forall x . x -> x)) . a -> a is a principal type in MLF
14:51:24 <c_wraith> napping: ok, I don't know what MLF is, nor what it's >= annotation means.  But I'll believe you. :)
14:51:53 <napping> principal type for id at least
14:51:56 <nullx002> that requires some additional software to install napping: 
14:53:10 <napping> c_wraith: in short, it's an impredicate type system, and that fancy constraint covers all the instantiations
14:53:16 <mniip> nullx002, that is one of the most efficient prime factoring softwares
14:53:36 <mniip> actually, just factoring
14:53:45 <mniip> it outputs PRPs
14:54:04 <napping> nullx002: if writing a stupid brute force alorithm is too slow, you need to get into pretty fancy algorithms to do better
14:54:41 <nullx002> ok, mniip: yes need to have a look at that... but i though doing something in haskell as it is new to me.. :D
14:54:49 <c_wraith> Well...  You can do slightly smarter brute forcing, by only testing against primes out of a seive.
14:54:52 <napping> MLF actually has a pretty nice guarantee - it can type anything typeable in system F, and you only need to annotate arguments that are used a severl types in the body
14:55:08 <c_wraith> It's still brute force, but it's at least asymptotically faster than trying every possible divisor
14:55:17 <mniip> yeah the gap between O(sqrt(N)) and whatever the next algorithm is is very much non-trivial
14:55:23 <nullx002> c_wraith: i like that sieve idea... it is more like comparing than calculating...
14:55:26 <napping> by what, a log factor?
14:55:40 <c_wraith> yeah, it's only a log factor.  Not hugely better, but at least slightly!
14:55:45 <mniip> huh
14:55:59 <mniip> only testing for primes is a constant factor
14:56:12 <mniip> but introducing linear memory
14:56:28 <mniip> albeit again it depends on your sieve
14:56:40 <c_wraith> like...  https://hackage.haskell.org/package/primes-0.2.1.0/docs/Data-Numbers-Primes.html
14:56:50 <napping> mniip: nah, about 1/ln x numbers near x are prime
14:57:01 <mniip> huh
14:57:07 <c_wraith> Has a pretty decent seive algorithm, and naive factoring given the seive.
14:57:11 <napping> so I guess testing only primes instead of every number actually is an asymptotic algorithm
14:57:19 <napping> n/log n time instead of n time
14:57:20 <dolio> napping: Does it cover (forall x y. x -> y -> x) -> (forall y x z. y -> x -> z -> x)?
14:57:47 <c_wraith> Yeah..  It's not a huge improvement.
14:57:47 <napping> dolio: should it?
14:57:58 <dolio> That's a valid type for \f -> f f.
14:58:10 <dolio> So if it's not including that, it's not much of a principal type.
14:58:14 <mniip> napping, x/ln x
14:58:17 <nullx002> ok, thanks all for help
14:58:25 <napping> that might be the type for id actually, paper is at http://gallium.inria.fr/~remy/work/mlf/icfp.pdf
14:58:27 <nullx002> it is 4 in the mornign here
14:58:29 <mniip> I was thinking of 1/c but apparently it's x/ln x
14:58:35 <nullx002> bye
14:58:39 <dolio> It's also the one that gives you 'const const'.
14:58:43 <napping> mniip: that's proportional to the number of primes up to n, right?
14:58:50 <mniip> oh
14:58:51 <mniip> yes
14:58:53 <mniip> true
14:59:03 <mniip> 1/log n is the probability of n being prime
14:59:26 <mniip> hm, no, still not the same thing
14:59:54 <mniip> well thre are n/log n primes under n, so you go from O(sqrt(n)) to O(sqrt(n)/log(sqrt(n)))
15:00:16 <mniip> which is a constant factor of O(sqrt(n)/log(n))
15:00:39 <c_wraith> Err.  what?  That term appears to have n in it.  How is it constant?
15:00:50 <dolio> Also for instance, forall f. (forall x. x -> f x) -> (forall x. x -> f (f x))
15:01:24 <merijn> hmm
15:01:30 <merijn> Async doesn't have a mapConcurrently_ ?
15:01:35 <merijn> i.e. that throws away the result
15:03:32 <napping> dolio: the relevant example is actually that (\(x : t_id) -> x x) has principal type (forall (a = t_id) . a -> a)
15:03:49 <napping> where t_id = forall b . b -> b
15:07:14 <webchat099> merijn  using transient:   mapConcurrently f = map (async . f)  https://github.com/agocorona/transient
15:07:50 <cstrahan> if I need to statically allocate some memory exactly once, and give the ptr a top-level binding, what's the "right way" to do that?
15:09:29 <dolio> napping: Yeah. That's no fun, though. :)
15:10:30 <napping> I think you would get something interesting with an annotation (forall a . a -> b -> a)
15:10:59 <napping> or basically just that it's an identity function
15:11:08 <cstrahan> it looks like I can coax GHC into giving me an address for a given string literal using a trick like what's used for packing ByteStrings from String literals: https://wiki.haskell.org/Playing_by_the_rules#Fast_ByteString_construction
15:11:26 <albeit> When I profile by type "-hy", I get a space leak from something called "->Foo". What does the "->" mean?
15:11:40 <dolio> (\x -> x x) : (a ∩ (a -> b)) -> b
15:11:50 <merijn> webchat099: I can easily implement it on my own, I was just confused why it's not already there
15:12:46 <napping> dolio: doesn't that interact very badly with polymorphism?
15:12:55 <dolio> Probably.
15:13:19 <dolio> Intersection types are really difficult on their own, I think.
15:14:01 <dolio> They can be used to type exactly the strongly normalizing lambda terms.
15:14:40 <napping> oh, already annoying then
15:14:52 <dolio> So, if you do that, obviously reconstruction from un-annotated terms is undecidable.
15:15:00 <napping> maybe typechecking ended up undecidable too?
15:15:21 <dolio> Checking a term against a type is decidable, I believe.
15:15:40 <napping> I think something gets worse if you try to mix intersection types and polymorphism
15:16:05 <webchat099> merijn: I know 
15:16:25 <napping> MLF is particularly nice for modifying expressions
15:16:39 <napping> you don't need any annotations for id = \x -> x to preserve polymorphic tyles
15:16:48 <napping> and stuff like runST $ exp would just work
15:16:52 <dolio> Yeah.
15:17:18 <merijn> Which package would I find a function to obtain the file part of a URL?
15:17:23 <cstrahan> re: my question earlier - it would seem that I can just create a top-level binding to a ByteString literal, and, given sufficient optimization, GHC should place the string in the respective object file...
15:18:01 <webchat099> merijn: but Control.Concurent.Async is not as composable as transient and I wanted to let you know
15:18:19 * hackagebot webcrank-wai 0.2.1 - Build a WAI Application from Webcrank Resources  http://hackage.haskell.org/package/webcrank-wai-0.2.1 (purefn)
15:18:41 <dolio> napping: The other odd thing is that I seem to recall someone telling me that intersection types had some nicer properties than polymorphism.
15:19:12 <dolio> Like, rank-2 polymorphism is decidable, and there's something to do with intersection types that is decidable at rank-2.
15:19:15 <napping> well, you saw the nice (a /\ (a -> b)) -> b type for self-application
15:19:39 <dolio> But allegedly it was preserved at higher ranks for intersection types, but not polymorphism.
15:19:39 <napping> I think it's a similiar notion of rank, just how deeply the intersections occur
15:19:56 <dolio> However, it seems like it can't be full type reconstruction.
15:20:09 <dolio> So I don't know what the exact property was.
15:20:18 <napping> typing any strongly normalizing term might count as a nice property
15:20:36 <dolio> Well, yes. But that corresponds to reconstruction being undecidable.
15:21:08 <napping> maybe something about principal typings?
15:21:25 <dolio> Hmm. Perhaps.
15:23:19 * hackagebot wai-routes 0.7.0 - Typesafe URLs for Wai applications.  http://hackage.haskell.org/package/wai-routes-0.7.0 (AnupamJain)
15:23:21 * hackagebot eventstore 0.8.0.0 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-0.8.0.0 (YorickLaupa)
15:26:30 <dolio> napping: Oh, found it, I think.
15:26:48 <dolio> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.4246
15:26:55 <athan> Anyone know what I'm doing wrong? http://stackoverflow.com/questions/30743424/haskell-ffi-gcc-ld-cant-find-shared-library-via-hsc2hs
15:27:16 <dolio> Every finite rank restriction has decidable inference for intersection types.
15:27:32 <dolio> And it's only the system without any restriction that types exactly the strongly normalizing terms.
15:27:54 <webchat099>    mapConcurrently limiting the number of threads to n:      mapConcurrently n f = threads n  . map (async . f)  
15:28:18 <napping> that sounds about right
15:28:31 <johnw> merijn: see also async-pool
15:28:37 <dolio> Also principal typings at every finite rank restriction.
15:29:28 <merijn> johnw: Sounds like overkill for me :0
15:29:43 <johnw> possible
15:29:59 <merijn> johnw: I'm just writing an extremely hacky scraper to grab all the files from a webcomic because the website is obnoxious and slow to relate, interrupting my reading :p
15:30:12 <merijn> So I'm not bothering with all this fancy error handling nonsense :p
15:32:04 <napping> dolio: does that even survive nominal subtyping?
15:32:16 <Denommus> yay, reflex-dom ran
15:32:23 <webchat099> async-pool suffers the same lack of composability of async
15:32:56 <johnw> webchat099: oh?
15:33:20 * hackagebot hipbot 0.5 - A library for building HipChat Bots  http://hackage.haskell.org/package/hipbot-0.5 (purefn)
15:34:29 <dicioccio> merijn: I have a similar scraper, I use a QSem and I pass the bracketted grab/release actions to my "scrap functions" as extra param for composability
15:36:02 <webchat099> johnw async-wait, like anything that is constructed with two primitives, is not composable
15:37:32 <webchat099> transient has async, and does     both async and wait in a single primitive. the monadic process continues in another thread. That is why it is composable
15:39:58 <Kole> can I map the !! operator to a list? 
15:40:10 <merijn> dicioccio: hmm, it seems my naive multi-threaded "mapConcurrently" over a list of URLs ends up hammering the server resulting in a timeout xD
15:40:10 <dicioccio> merijn: then i use xml-html-conduit-lens to actually extract what I want from the content
15:40:29 <merijn> dicioccio: Yeah, I'm using http-conduit and xml-conduit to scrape the stuff I care about
15:40:37 <koala_man> Kole: as in map (!! 1) [[1,2,3], [4,5,6]] ? yes
15:41:15 <Kole> koala: I think the othwe way around, the index would come from a list and it would apply to a list
15:41:19 <merijn> dicioccio: Looks like I should move to a Chan + threads approach instead, because right now I'm apparently just being slightly to parallel :p
15:41:26 <Kole> (I am not sure if I make sense)
15:41:35 <koala_man> > map ([1,2,3] !!) [1,0,1,2] 
15:41:38 <lambdabot>  [2,1,2,3]
15:42:00 <Kole> thanks!
15:42:30 <tj_____> anyone here who could help me a bit with threepenny-gui?
15:42:37 <tj_____> I have been working on this thing http://stackoverflow.com/questions/30735436/changes-in-other-elements-based-on-listbox-selections-in-threepenny-gui and got it to run fine
15:42:45 <tj_____> the only thing that I don't get is how to react to changes in the user selection on the listbox (currently I get the facts . userSelection, but this is always the initial Nothing value)
15:43:23 <merijn> Oh well, bed time, I'll fix it later
15:43:42 <dicioccio> merijn: yes, well, what i do is bracket with waitQSem + waitRandomSecs / signalQSem 
15:43:59 <athan> carter: ping
15:44:07 <dicioccio> this way all my threads wait while holding a token
15:44:31 <dicioccio> and i don't care about having 1000 threads on the qsem
15:44:36 <dicioccio> +waiting
15:45:01 <merijn> dicioccio: I'm effectively just spawning 1 thread per request
15:45:11 <dicioccio> same here, works like a charm
15:45:28 <merijn> dicioccio: But I guess the poor webcomic server might not like getting 1k+ parallel requests, judging by the timeouts :p
15:45:32 <athan> carter: I might try to implement revised simplex method in numerical's sparse matrix stuff. Should I try it? :x
15:46:17 <merijn> I'll add some error handling tomorrow...
15:46:21 <dicioccio> that's why I add a QSem to have N maximum concurrent requests and random delay after acquiring a semaphore token to control the request rate
15:46:41 <dicioccio> bracket_ is all the error handling I need so far :)
15:47:19 <webchat099> that is what threads n does in transient
15:47:27 <merijn> Well, I'm using simpleHttp and I think a single timeout ends up killing all my threads :p
15:47:42 <merijn> Which is a bit inconvenient
15:49:16 <dicioccio> I use wreq
15:53:33 <webchat099>  sum the words of the pages of a list of URLs using  n threads:     threads n . foldl (<>) (return 0) $ map (async . length . words . getResoponseBody . getURL)  listOfURLs
15:55:20 <webchat099> sum the number of words, i mean
15:56:05 <dicioccio> assumming the answer is plain text :)
15:58:33 <webchat099> the sum is done anyway, including tags, and swearword
15:58:44 <webchat099> s ;)
16:04:55 <webchat099> it uses the fact that "Transient  a" is a monoid
16:12:30 <webchat099> A very similar example is here, if anyone is interested   https://www.fpcomplete.com/user/agocorona/EDSL-for-hard-working-IT-programmers#beyond-futures-and-promises
16:13:10 <Kole> it might be a similar question as the last one, being a slow pony here, I want to find the positions of numbers in a list that are bigger than 10
16:16:15 <Kole> ok I stop with my basic questions
16:22:53 <ski> @type findIndices
16:22:54 <lambdabot> (a -> Bool) -> [a] -> [Int]
16:22:56 <ski> Kole ^
16:23:22 * hackagebot wl-pprint-extras 3.5.0.5 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-3.5.0.5 (EdwardKmett)
16:30:28 <Kole> oh, I totally gave up, thanks
16:31:14 <pavonia> @src findIndices
16:31:15 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
16:37:04 <funfunctor> @hoogle CUChar -> Int
16:37:05 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
16:37:06 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
16:37:06 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
16:37:24 <ion> fromIntegral
16:39:11 <mauke> pfft, it's Enum, Num, *and* Show
16:39:28 <mauke> so all of fromEnum, fromIntegral, read . show work
16:40:07 <mauke> bonus: ord . castCUCharToChar
16:40:37 <funfunctor> yea I am using fromIntegral
16:40:49 <funfunctor> silly C programmers keep thinking a char is a int
16:41:01 <mauke> well, it is
16:41:03 <funfunctor> Because 1960's
16:41:25 <funfunctor> mauke: well everything is a int but it isn't
16:41:40 <mauke> or rather, "char" is one of the integral types
16:41:51 <boxfire> funfunctor: only float isnt an int
16:41:53 <ion> Going through String for the win. Since StdGen doesn’t export its constructor, acme-memorandom memoizes a function from StdGen by having a lazy trie of the bits in the string that show (g :: StdGen) generates.
16:42:04 <funfunctor> I mean to say, they should be using uint8_t instead
16:42:07 <mauke> in fact, chars are so int, character literals have type 'int'
16:42:16 <funfunctor> boxfire: float is encoded as a int
16:42:47 <ion> Float is three integers.
16:42:50 <mauke> uint8_t is 1) C99, 2) optional, 3) equivalent to 'unsigned char' if it exists
16:43:03 <funfunctor> I am saying, C programmers abuse what little type system they have
16:43:04 <boxfire> float has parts in it you could coerce to int, but it isnt an int. a float shifted around a bit has some ints in it
16:43:16 <boxfire> but everything else in C is an int
16:43:37 <mauke> pointers aren't ints
16:43:42 <mauke> nor are structs, arrays, unions
16:43:47 <mauke> let alone functions
16:43:57 <boxfire> mauke: pointers are very much ints
16:44:02 <mauke> ion: hah
16:44:05 <mauke> boxfire: nope
16:44:22 <ion> boxfire: I’m fairly sure mauke is right here.
16:44:23 <mauke> try to add two pointers, tell me how that goes
16:45:47 <ion> http://stackoverflow.com/questions/3567905/c-is-it-safe-to-cast-pointer-to-int-and-later-back-to-pointer-again?ref=mythemeco&t=pack#comment26111266_3567905
16:45:55 <dolio> napping: Dunno.
16:46:28 <mauke> ion: yeah, and that's just conversion to int, not even being an int
16:47:33 <funfunctor> http://asset-7.soup.io/asset/7122/8122_7e02.jpeg
16:47:35 <boxfire> mauke: ANSI C, correct. gnu C? clang? you can add pointers
16:47:53 <boxfire> I dont know what the intel compiler or microsoft compiler do to the naive who try
16:48:03 <mauke> boxfire: no, you can't
16:48:45 <mauke> try.c:3:14: error: invalid operands to binary + (have ‘char *’ and ‘char *’)
16:48:49 <mauke> that's with gcc
16:48:56 <arkeet> shouldn't you be converting to intptr_t anyway.
16:49:03 <albeit> Is their a recommended Queue/Chan for concurrent use that keeps track of its length?
16:49:08 <albeit> *there
16:49:24 <shachaf> arkeet: Probably not, if you're going to be doing a silly thing like adding pointers.
16:49:34 <arkeet> well I agree that it's silly.
16:50:02 <mauke> hmm, a better test for intness might be bitwise operations
16:50:14 <mauke> p << 0 doesn't compile either, not surprisingly
16:50:41 <arkeet> what about p | 0
16:50:59 <mauke> try.c:3:14: error: invalid operands to binary | (have ‘char *’ and ‘int’)
16:51:05 <arkeet> heh.
16:51:50 <ion> Silly? B-but that’s how you can swap two pointers without a temporary variable!
16:51:53 <arkeet> because occasionally you see things like using the least significant bits of a pointer for some extra information.
16:52:49 <boxfire> mauke: you can't add pointers to eachother, but you can add integers to pointers. If someone wants to make the argument float is int, then a poitner is int as well
16:52:58 <boxfire> but I reject float is int, so I will agree with you
16:53:11 <arkeet> then a pointer is float too!
16:53:48 <ion> What is “is”?
16:54:10 <arkeet> (a pointer is fine too?)
16:54:14 <dolio> ion: Clearly that's still a worthwhile optimization.
16:54:34 <arkeet> I generally hope that my instruction set has something like XCHG or whatever.
16:54:50 <mauke> int main(void) { (***printf)("I heard you like pointers\n"); }
16:55:51 <boxfire> C will promote a pointer to an int or a float to an int behind your back. Luckily it at minimum complains when you try to make a pointer from an integer
16:56:12 <dolio> boxfire: That's because integers are a torsor on pointers, not because pointers are integers.
16:56:13 <boxfire> some types are better than none... lookin at you javascript
16:56:34 <ion> mauke: Why does that work?
16:57:01 <mauke> boxfire: C will not promote pointers to an int
16:57:16 <boxfire> mauke: the if statement takes an integer expression
16:57:33 <mauke> boxfire: I don't think that's true
16:58:01 <mauke> boxfire: AFAIK 'if (X)' is equivalent to 'if (X != 0)'
16:58:32 <mauke> ion: because unless it is the operand of unary &, a function evaluates to a pointer (to that function)
16:58:36 <boxfire> mauke: int main() { void *ptr = &main; long value = ptr; printf("%ld\n", value); }
16:58:45 <mauke> (if it's the operand of &, you get a pointer anyway, of course)
16:58:54 <mauke> boxfire: that's super invalid
16:58:59 <boxfire> uhh no its not
16:59:03 <mauke> yes, it is
16:59:08 <boxfire> gcc -std=c89 -o tst tst.c && ./tst
16:59:08 <boxfire> tst.c: In function ?main?:
16:59:08 <boxfire> tst.c:6:18: warning: initialization makes integer from pointer without a cast [enabled by default] long value = ptr;
16:59:20 <mauke> see?
16:59:20 <boxfire> it works, compiles with a warning because my compiler is nice
16:59:23 <boxfire> but compiles fine
16:59:29 <mauke> that doesn't prove anything
16:59:39 <boxfire> that you can use a pointer freely as an int?
16:59:43 <mauke> the standard doesn't distinguish between warnings and errors
16:59:53 <mauke> it simply talks about "diagnostics"
17:00:01 <mauke> and a compiler is not required to reject invalid programs
17:00:55 <mauke> your problems start at void *ptr = &main, btw. function pointers aren't required to be compatible with data pointers
17:01:40 <ion> mauke: Ok, thanks for the explanation.
17:02:03 <mauke> ion: this is similar to arrays, which evaluate to a pointer to their first element
17:02:28 <mauke> but arrays have two exceptions, & and sizeof. for functions sizeof is invalid
17:03:08 <boxfire> mauke: I think you are putting in a lot of 'requirements' that simply dont exist in the standard.
17:03:11 <boxfire> mauke: http://port70.net/~nsz/c/c89/c89-draft.html#3.3.16.1
17:03:43 <mauke> why that link? your code doesn't contain assignment
17:04:02 <mauke> also c89 draft, holy shit
17:04:20 <boxfire> mauke: I have an assignment of a function pointer to a void *
17:04:57 <mauke> yeah, that matches none of those bullet points
17:05:07 <mauke> so you've violated a "shall"
17:05:19 <boxfire>  * both operands are pointers to qualified or unqualified versions of compatible types, and the type pointed to by the left has all the qualifiers of the type pointed to by the right; 
17:05:30 <boxfire> void* is compatible with any function pointer
17:05:33 <boxfire> in case you didnt know
17:05:35 <mauke> no, it's not
17:05:56 <mauke> also, why are we talking about assignment?
17:06:02 <mauke> your code doesn't use assignment
17:06:49 <mauke> besides, even if you did use assignment and void* were compatible with function pointers, that still wouldn't pass
17:07:04 <mauke> what's required to be compatible is the base types, not the pointer types
17:07:14 <mauke> so void would have to be compatible with int (void)
17:07:16 <boxfire> mauke: http://port70.net/~nsz/c/c89/c89-draft.html#A.6.5.7
17:07:37 <boxfire> that is quite explicit in the standard, so you are kind of making shit up
17:08:01 <mauke> boxfire: that's 1) an appendix, i.e. non-normative, 2) the appendix in question is "common extensions", 3) you're not using a cast
17:08:49 <lamefun> can I screw up with Haskell and end up with data races?
17:10:24 <exio4> lamefun: yes, Haskell lets you be extremely unsafe if you want to
17:11:15 <mauke> it takes a bit of effort, though
17:11:32 <lamefun> http://nim-lang.org/ - this one seems to have some automated proof magic...
17:11:41 <exio4> yeah, it punishs you for trying to be unsafe, with long functions
17:12:34 <lamefun> Is there any other significant language with feature similar to Safe Haskell?
17:13:02 <lamefun> Just curious.
17:13:11 <exio4> (as a funny example, you can even manage the memory by yourself, https://hackage.haskell.org/package/base-4.7.0.0/docs/Foreign-Marshal-Alloc.html )
17:14:23 <mauke> boxfire: http://c-faq.com/ptrs/generic.html
17:15:13 <boxfire> mauke: there is no modern compiler that does not implement function pointers
17:16:07 <mauke> boxfire: apples are fruit
17:16:13 <boxfire> I work at a place that does flight software and we use function pointers. Probably the single most rescrtictive code environment
17:16:32 <boxfire> actually automotive is more restrictive than aerospace, funny enough
17:16:39 <napping> boxfire: the question is whether casting a function pointer through void* is guaranteed to work
17:16:42 <mauke> i.e. what you said is obviously true but what's your point?
17:16:58 <mauke> function pointers are part of C. if your compiler doesn't support them, it's not a C compiler
17:17:27 <boxfire> and a void* storing a function pointer is supported on anything you can dig up other than a one off Cray experiment from the early 90's
17:18:13 <mauke> C implementations aren't required to run on computers
17:18:43 <mauke> I can run C using only pen & paper and my head
17:18:47 <boxfire> so a one off mauke experiment from the mid 2010's?
17:19:28 <mauke> also, I wouldn't be surprised if lisp machines used a different format for function pointers
17:19:52 <boxfire> luckily the legion of actual production uses of the language are not your contrived examples
17:19:59 <napping> boxfire: you might want to see http://stackoverflow.com/questions/12358843/why-are-function-pointers-and-data-pointers-incompatible-in-c-c
17:20:18 <napping> It's clearly not required by the C standard, perhaps your environment promises more
17:20:27 <mauke> I don't care about "production uses"; I care what the language spec actually says
17:20:58 <boxfire> luckily peope who actually produce useful things dont ask "how can I conform to this spec", they ask "What can I DO with this language"
17:21:51 <exio4> what you can do with a language is defined by the spec
17:21:53 <boxfire> napping: I dont disagree the strict ANSI C definition lacks the capability. I am just saying there are zero production environments that wont accept void *ptr = &function
17:22:17 <napping> exio4: more importantly, how the compiler can mangle your code is mostly defined by the spec
17:22:34 <boxfire> Someone please notify microsoft. This is big news for them, and they really really need to know
17:23:20 <napping> note for example that POSIX promises that function pointer can be stored in void*
17:23:30 <mauke> boxfire: try gcc -ansi -pedantic -Werror
17:24:45 <mauke> <boxfire> luckily peope who actually produce useful things dont ask "how can I conform to this spec", they ask "What can I DO with this language"  <- those same people then get surprised when the optimizer "breaks" their code
17:26:09 <hpc> mauke: all you need for those is a distributed build framework unit testing suite
17:26:15 <hpc> which can then send XML back to jenkins
17:26:53 <mauke> did you just tell me to write a distributed map-reduce function in erlang?
17:27:05 <hpc> i believe i did, bob
17:28:11 <funfunctor> how can I get [CUChar] into a ByteString ?
17:28:31 <mauke> B.pack . map fromIntegral
17:28:34 <mauke> or something like that
17:29:11 <funfunctor> pack :: [GHC.Word.Word8] -> ByteString
17:29:13 * ski . o O ( "Contest: Craziest Compiler Output due to Undefined Behavior" by John Regehr in 2012-07-12 at <http://blog.regehr.org/archives/759> )
17:29:15 <funfunctor> ah hmm
17:29:22 <arkeet> fromIntegral :: CUChar -> Word8
17:29:52 <funfunctor> what about packCStringLen :: CStringLen -> IO ByteString
17:30:34 <napping> That won't work on a [] list, but maybe you can use it before you made the [CUChar]
17:31:10 <athan> Why isn't there a `permutations` function in vector?
17:31:25 <mauke> funfunctor: that takes a pointer
17:32:19 <lpaste> funfunctor pasted “No title” at http://lpaste.net/134205
17:32:36 <Denommus> ok, maybe I should stop playing with point-free defintions
17:32:38 <funfunctor> this is what I am fighting with
17:32:48 <Denommus> I just transformed \x -> (x, x) into id &&& id
17:33:01 <exio4> Denommus: join (,) !
17:33:03 <arkeet> how about join (,)
17:33:12 <Denommus> :t join (,)
17:33:13 <napping> Ah, something like fromCStringLen is probably what you want
17:33:14 <lambdabot> a -> (a, a)
17:33:32 <exio4> join :: (r -> (r -> a)) -> (r -> a) 
17:33:36 <napping> It fills the Ptr CUChar, right?
17:33:36 <exio4> @djinn (r -> (r -> a)) -> (r -> a) 
17:33:37 <lambdabot> f a b = a b b
17:33:51 <Denommus> exio4: that's also cute
17:34:30 <mauke> funfunctor: wait, why are you allocating 4 * sz?
17:34:54 <Forkk> hey jle`, why is there no function like this in Auto? https://gist.github.com/Forkk/fd2517217d6c962ec7ad
17:34:56 <exio4> Denommus: join (curry id)? ;P
17:34:58 <Forkk> or am I missing something
17:35:12 <funfunctor> mauke: I have not worked out the buffer size yet
17:35:29 <funfunctor> just trying to get the types right first
17:35:58 <napping> funfunctor: packCStringLen looks right, you just have to cast the Ptr CUChar to Ptr CChar
17:37:29 <Denommus> I'm loving reflex
17:38:29 <mauke> allocaBytes sz $ \ptr -> do r <- c'ftdi_read_data (unDeviceHandle d) ptr (fromIntegral sz); when (r < 0) $ throwSomeError r; BS.packCStringLen (cast ptr, r)
17:43:49 <funfunctor> mauke: thanks, but why pass the return, not sure if this C function necessarily returns the number of bytes read (stupidly)
17:44:00 <funfunctor> :t cast
17:44:03 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
17:44:21 <funfunctor> hmm, maybe not cast
17:44:24 <arkeet> not that cast.
17:44:33 <arkeet> :t castPtr
17:44:35 <lambdabot> Not in scope: ‘castPtr’
17:44:35 <ReinH> glguy: ping
17:44:39 <arkeet> castPtr :: Ptr a -> Ptr b 
17:44:42 <mauke> oops, yes
17:44:50 <mauke> funfunctor: http://www.intra2net.com/en/developer/libftdi/documentation/group__libftdi.html#ga72d87e30015c98bd0be22e7c8c873345
17:44:53 <mauke> this is what I found on google
17:45:08 <funfunctor> Foreign.C.String.castCharToCChar 
17:45:32 <mauke> also, if it doesn't return the number of bytes read, you're screwed anyway
17:45:44 <funfunctor> mauke: ah ok, hmm
17:49:44 <voltz> Hello, everyone.
17:57:30 <funfunctor> mauke: thx, I think I sorted it
17:59:55 <zcourts> Can I call Haskell from C++ using the C++ compiler instead of GHC? GCC/LLVM? I want to expose the GHC lib API to be able to compile Haskell sources but having GHC compile the entire app won’t work I don’t think. For the record compiling a simple test C file with GHC works.
18:12:56 <tombert1> I have a bit of a conceptual question: what is the advantage of an applicative over a vanilla monad?
18:13:48 <tombert1> I've been reading about them, but I'm having a bit of confusion on how they're advantageous
18:16:12 <peddie> @where typeclassopedia
18:16:12 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
18:16:22 <peddie> tombert1: have you seen this ^ ?
18:17:35 <Pibian> What is a typeclass?
18:17:58 <tombert1> peddie: I have not...I'll give that a read
18:18:16 <Cale> Pibian: It's a way of constraining the types over which type variables range to just those types which provide certain functionality
18:19:44 <Cale> Pibian: For example, you might be familiar with polymorphic functions like length :: [a] -> Int and map :: (a -> b) -> [a] -> [b], which are able to operate for all choices of types a and b. But consider something like sort. It can't be [a] -> [a], because there are many types 'a' for which order comparison doesn't make sense.
18:19:52 <Pibian> Cale, Not easy to understand
18:20:19 <tombert1> Pibian: I'm gonna catch a bit of flack for this, but they're similar to interfaces in Java
18:20:22 <Axman6> Pibian: do you know java interfaces? they're basically interfaces 
18:20:38 <Axman6> (not really but sometimes being accurate doesn't help)
18:20:46 <Axman6> heh
18:21:08 <tombert1> I know behind-the-scenes they're different, but they're conceptually similar
18:21:25 <Cale> Pibian: So we have a type class Ord which can be used to constrain the types you're allowed to pick:
18:21:27 <Cale> :t sort
18:21:29 <lambdabot> Ord a => [a] -> [a]
18:22:23 <Cale> Ord defines (<), (>), (<=), (>=), compare, min, and max
18:23:20 <Cale> When you define a new type, you can make it an instance of Ord by defining these operations (or just compare, or (<=), because the class defines default implementations of the other methods in terms of these)
18:23:44 <Cale> and that will automatically let you use things like sort which have been defined in terms of these operations
18:26:36 <voltz> Learning how to effectively use type classes helps a lot.
18:29:48 <Pibian> Cale, This is only the second chapter for me to learn Haskell
18:45:38 <tejing> Pibian: in haskell you can't define a polymorphic value/function differently for different types, so for example if I write a type signature 'foo :: a -> a' then there are only 3 values foo can have: 'foo = id', 'foo = const undefined', and 'foo = undefined'. typeclasses are a way to loosen this restriction a little. a typeclass is a collection of types, and some special values/functions which are attached to the typeclass and ARE allowed to b
18:47:49 <Pibian> tejing, okay
18:47:55 <alisia> I am trying to understand how liftIO works. Would it be possible to rewrite a piece of code that uses liftIO, without using liftIO?
18:49:31 <tejing> alisia: only if the code is not polymorphic for different monad transformer stacks
18:53:00 <benzrf> alisia: liftIO is just a typeclass method
18:53:41 <benzrf> alisia: some monads subsume IO in terms of what "effects" a given value can represent
18:54:04 <benzrf> alisia: and such monads can implement the MonadIO class to give users a polymorphic way of converting a plain IO into a value of a MonadIO instance
18:56:40 <alisia> benzrf, yes. But then each instance of MonadIO will have separate implimentation of how the 'lift' will be performed. Right?
18:56:54 <tejing> alisia: they're defined recursively
18:57:01 <benzrf> alisia: yep
18:57:08 <benzrf> alisia: as with any typeclass :P
18:57:47 <benzrf> alisia: you can rewrite code using liftIO to not use liftIO in the same way that you can rewrite code that uses fmap to not use fmap
18:58:09 <geekosaur> briefly: derivation of MonadIO involves defining a liftIO that calls liftIO in the next monad down
18:58:12 <tejing> alisia: so there's an instance MonadIO m => MonadIO (StateT s m) where liftIO = lift . liftIO
18:58:20 <geekosaur> at the bottom, IO has the definition: liftIO = id
18:58:55 <geekosaur> ("lift" is defined by MonadTrans)
19:05:56 <ski> tejing : fwiw, cut off near ".. a typeclass is a collection of types, and some special values/functions which are attached to the typeclass and ARE allowed to b"
19:06:55 <njkdfg> is there a chrome extension or something for viewing code in the browser?
19:07:42 <ReinH> njkdfg: is this a Haskell question?
19:07:57 <njkdfg> ReinH: no but im trying to view haskell code :p
19:08:33 <ReinH> njkdfg: wouldn't an editor be better suited?
19:08:50 <arkeet> njkdfg: closest thing that I know of is that hscolour can generate html from your code.
19:08:54 <arkeet> with syntax highlighting and whatever.
19:09:01 <njkdfg> no, cause I just want to view the file quickly without downloading and opening an editor
19:09:22 <alisia> tejing, benzrf, geekosaur. Suppose I have a do notation that stars with a function that returns 'Web.Scotty.Internal.Types.ActionT Text IO ()' and in the next statement, I want to bind a variable to a IO that returns IO String. If I know how to make a value of type 'Web.Scotty.Internal.Types.ActionT Text IO ()' then this would not be a problem, since I can wrap the second statement in it so it returns the 'Web.Scotty.Internal.Types.ActionT Text IO'. But since 
19:09:23 <alisia> the library does not want to bother me with that stuff, all it provides is the liftIO function that can do this automatically for that monad. How close is that to being correct?
19:09:28 <njkdfg> basically there are some code examples here: https://www.haskell.org/arrows/syntax.html as files
19:09:40 <njkdfg> and when you click on them they get downloaded instead of viewed
19:10:03 <geekosaur> roughly correct
19:10:15 <njkdfg> I don't want to dirty up this channel with offtopic stuff, sry
19:10:37 <geekosaur> but you also get the ability to define things that don't know how deep the monad stack goes (specifically, how many monad transformers are hidden inside Web.Scotty.Internal.Types.ActionT)
19:11:18 <geekosaur> because the IO *looks* like it's right there, but that ActionT could be an alias that expands to 3 or 4 layered transformers over that IO
19:11:19 <benzrf> geekosaur: that's out of scope of the question, i think
19:11:35 <geekosaur> and unless you know exactly how many things are hidden in that alias, you can;t reach the IO directly
19:11:44 * carter @tell athan #numerical-haskell is a better channel for talking bout that stuff than #haskell : )
19:11:44 <geekosaur> the recursively derived MonadIO means you don;t need to know
19:11:45 <carter> @tell athan #numerical-haskell is a better channel for talking bout that stuff than #haskell : )
19:11:45 <lambdabot> Consider it noted.
19:12:00 <benzrf> alisia: to be precise, the polymorphic nature of 'liftIO' as a solution allows you to write instances that are parameterized by other instances such that you can build arbitrary stacks and have instances automatically thee
19:12:04 <ski> you can even have code where you don't know how deep the monad stack goes, until you run the code
19:12:10 <benzrf> alisia: have you seen this kind of trick before?
19:12:11 <njkdfg> whats the best/a good pattern for writing evaluators where an environment of defs needs to be present in each step? The only one I know of is arrows
19:12:29 <benzrf> njkdfg: you could use reade
19:12:30 <benzrf> r
19:12:52 <njkdfg> benzrf: would that be better than arrows?
19:12:56 <benzrf> dunno
19:13:04 <benzrf> arrows are kind of the red headed step child of haskell
19:13:08 <alisia> benzrf, I am very new to Haskell.
19:13:12 <benzrf> alisia: ah
19:13:15 <benzrf> here, let me show you :)
19:13:28 <njkdfg> benzrf: red headed step child?
19:13:38 <benzrf> njkdfg: figure of speech
19:13:41 <benzrf> njkdfg: people dont like em
19:13:45 <njkdfg> oh
19:14:04 <alisia> benzrf, I know how haskell calls different functions depending on the expected result...
19:14:14 <benzrf> alisia: well, i mean something a little more specific
19:14:16 <benzrf> one sec
19:14:23 <benzrf> ok, check this out:
19:14:33 <benzrf> @let class DefaultValue a where default :: a
19:14:34 <lambdabot>  Parse failed: Parse error: ::
19:14:41 <benzrf> er?
19:14:47 <benzrf> oh, keyword :|
19:14:50 <benzrf> @let class DefaultValue a where defaultVal :: a
19:14:52 <lambdabot>  Defined.
19:15:27 <benzrf> @let instance DefaultValue Int where {defaultVal = 0}; instance DefaultValue Bool where {defaultVal = False}
19:15:30 <lambdabot>  Defined.
19:15:33 <benzrf> alisia: simple so far?
19:16:16 <alisia> benzrf, you define a new class and made Int an Book members of that class..
19:16:28 <benzrf> > defaultVal :: Int
19:16:32 <lambdabot>  0
19:16:53 <benzrf> alisia: yeah
19:17:10 <alisia> benzrf, yes. I understand this. this is how return works. Right?
19:17:51 <benzrf> alisia: yep
19:17:55 <ReinH> Um. No.
19:18:02 <benzrf> ReinH: ?
19:18:11 <jle`> Forkk: yeah, the pattern does come up often, but usually it's simple enough to inline in a proc block or something using (<$)
19:18:34 <ReinH> Well, depending on what "how return works" means. It works via a definition in a typeclass and its instances
19:18:38 <jle`> Forkk: because it doesn't actually require delating with the constructors to implement, it's not there in fear of cluttering up the already cluttered Control.Auto.Blip, heh
19:18:39 <benzrf> yeah
19:18:44 <benzrf> ReinH: i dont think it was any deeper than that
19:18:49 * ReinH shrugs
19:18:55 <jle`> Forkk: i *think* it's just liftA2 (<$)
19:18:57 <benzrf> alisia: ok, now check this out
19:19:25 <benzrf> @let instance (DefaultValue t) => DefaultValue (Maybe t) where defaultVal = Just (defaultVal)
19:19:27 <lambdabot>  Defined.
19:19:29 <ReinH> jle`: such blip
19:19:34 <benzrf> er, extra parenthesis are my bad. they dont mean anything
19:19:40 <benzrf> alisia: do you see how that works?
19:19:56 <jle`> Forkk: or liftA2 (\x yB -> fmap (,x) yB)
19:20:06 <alisia> benzrf, pls give me a sec
19:20:13 <jle`> i wonder of fmap (,x) is a thing
19:20:16 <jle`> *if
19:20:21 <jle`> ReinH: bleep bloop
19:20:25 <Pip> What is the type of a function?
19:20:40 <ReinH> jle`: tuple sections?
19:20:56 <jle`> i mean, if there's some typeclass that gives fmap (,x)
19:21:16 <ReinH> Why would you need a typeclass?
19:21:23 <Rotaerk> Pip, (X -> Y) where X is the input type and Y is the result type
19:21:32 <benzrf> domain and codomain, even
19:21:34 <benzrf> :>
19:21:38 <alisia> benzrf, now defaultVal can return a value of type Maybe a as long as a elemnt of DefaultValue. ie either Int or Bool...
19:21:38 <jle`> ReinH: i mean if we can abuse some typeclass to give us (,x)
19:21:45 <benzrf> alisia: yeah!
19:21:52 <Pip> Rotaerk, So what is the type of a function?
19:22:02 <jle`> er, fmap (,x)
19:22:06 <benzrf> alisia: this is what i meant by "instances that are parameterized by other instances"
19:22:20 <benzrf> alisia: this instance depends on another instance and extends it
19:22:21 <Rotaerk> Pip, I just told you
19:22:29 <benzrf> it's "parameterized" by it
19:22:39 <benzrf> > defaultVal :: Maybe Int
19:22:44 <Pip> okay
19:22:47 <lambdabot>  Just 0
19:23:01 <benzrf> @let instance (DefaultValue t) => DefaultValue [t] where defaultVal = [defaultVal]
19:23:03 <lambdabot>  Defined.
19:23:04 <alisia> benzrf, yes, I understand it a bit more now..
19:23:07 <benzrf> kk
19:23:11 <benzrf> now, look at this
19:23:19 <benzrf> i did the same thing for lists, and now i can do:
19:23:25 <benzrf> > defaultVal :: Maybe [Maybe Int]
19:23:30 <lambdabot>  Just [Just 0]
19:24:03 <benzrf> alisia: i never explicitly defined an instance for this particular nesting, but since i defined how to extend an instance when you nest it, haskell can deduce the instance for any particular stack of types
19:24:47 <Rotaerk> Pip, why did you ask a second time?  is there something confusing you?
19:25:14 <Pip> Rotaerk, The type of a function is (x->y)?
19:25:51 <Rotaerk> Pip, yes; types in haskell are expressions, not merely names
19:26:08 <Pip> That's deep
19:26:15 <Rotaerk> i.e. you can compose more complex types from other types
19:26:55 <Pip> Rotaerk, English bro, I'm just a newbie
19:27:00 <benzrf> in languages with proper dependent typing, types are actually the same sort of expression as normal values!
19:27:28 <monochrom> I'm pretty sure "you can compose more complex types from other types" is English.
19:27:46 <Pip> Rotaerk, I know that functions are expressions but didn't know types are too
19:27:54 <alisia> benzrf, but you already defined instance for Maybe a and [a], so Maybe [Maybe Int] can be reduced to Maybe a since Maybe Int is memeber of DefaultVal because Int is a member of DefaultVal...
19:28:13 <benzrf> alisia: exactly :D
19:28:30 <Rotaerk> Pip, well, they aren't value expressions... at least not in haskell :P
19:28:54 <benzrf> alisia: anyway, this is the same trick that MonadIO is usually used for
19:28:54 <dolio> benzrf: That's not necessarily true.
19:29:04 <benzrf> dolio: er, how so?
19:29:06 <Rotaerk> Pip, 1 + 1 is a value-level expression...  Int -> Int is a type-level expression
19:29:20 <Pip> I see
19:29:24 <Pip> clearer to me
19:29:27 <dolio> Martin-löf type theory is often presented with separate syntactic classes for terms and types.
19:29:45 <Pip> Int -> Int is more a type mapping to me
19:29:58 <Rotaerk> Pip, are you familiar with haskell operators yet?
19:30:03 <Pip> No
19:30:15 <ReinH> Pip: a mapping is a type. Int -> Int is a type constructed from the (->) constructor, just like Either Int Int is a type constructed from the Either constructor
19:30:28 <benzrf> dolio: err, how does that work?
19:30:37 <Rotaerk> Pip, (+) is an operator, so you can treat it like any other function and apply it like this:   (+) 1 1
19:30:40 <Rotaerk> that results in 2
19:31:04 <dolio> benzrf: And separate judgments. Like 'Γ ⊢ e : T' is a 'term is well typed' judgment, and 'Γ ⊢ T type' is a 'type is well formed' judgment.
19:31:09 <Pip> Yeah I heard all operators are functions too
19:31:12 <Rotaerk> Pip, except for operators, there's another syntax that means the same thing... you remove the ()'s and put it between the arguments
19:31:24 <benzrf> dolio: hmm, well ok
19:31:32 <Rotaerk> Pip, so  (+) 1 1 is the same as 1 + 1
19:31:49 <benzrf> dolio: really i just meant that they live in the same universe and/or that they can be nested in each other :)
19:31:55 <dolio> And terms appear as part of types, but are distinct from types.
19:32:17 <Rotaerk> Pip, similarly, (->) is a type level operator.    Int -> Int is the same thing as (->) Int Int
19:32:18 <benzrf> dolio: oh, wait
19:32:40 <Rotaerk> Pip, Int and Int are type-parameters, in this case
19:32:47 <benzrf> dolio: is the ability to do things like 'f (Int -> Int)' not standard MLTT, or
19:32:52 <nuttycom> So, after upgrading to 7.10 on OSX, cabal appears to no longer be able to find a slew of my dependencies. I've rm'ed .ghc, .cabal, and wiped the sandbox, cabal update, cabal install cabal-install, and still no dice. Anybody have any ideas?
19:33:04 <nuttycom> And these are common things:
19:33:05 <dolio> benzrf: Depends what you mean by that syntax, of course. :)
19:33:14 <ReinH> nuttycom: well, you'll need to reinstall them
19:33:15 <Rotaerk> Pip, maybe you should learn about generic types first, though
19:33:24 <dolio> benzrf: In such a presentation, when you want to do stuff like that, you introduce a type called a universe.
19:33:58 <dolio> So you have '⊢ U type', and also 'u : U ⊢ T u type'.
19:34:05 <nuttycom> ReinH: damn it, I don't know how many times I have to type —only-dependencies to remember to do that. :P
19:34:07 <nuttycom> Thanks.
19:34:18 <dolio> So, U is a type whose values correspond to types, and T decodes them into the types they correspond to.
19:34:21 <benzrf> dolio: ah
19:34:37 <benzrf> wait
19:34:39 <benzrf> what is T
19:34:42 <ReinH> nuttycom: (cabal install will also install dependencies)
19:35:37 <dolio> benzrf: T is the family that decodes the elements of U into the types they correspond to.
19:35:47 <benzrf> oh, i se
19:35:50 <benzrf> er, see
19:35:52 <dolio> benzrf: So, you might have 'nat : U' and 'T nat = Nat'.
19:36:01 <dolio> Where Nat is a type, proper.
19:36:09 <benzrf> dolio: never seen it that way >.>
19:36:12 <benzrf> i should read a paper someday
19:36:16 <dolio> :)
19:36:27 <benzrf> dolio: shouldnt there also be something like
19:36:34 <dolio> This way of doing it is referred to as universes a-la Tarski.
19:37:05 <benzrf> t type ⊢ V t : U
19:37:16 <benzrf> well
19:37:19 <benzrf> probably more restricted than that
19:37:46 <dolio> Martin-löf type theory doesn't have 't type' in the context.
19:37:51 <dolio> No type variables.
19:38:04 <dolio> U is introduced to have the capabilities of type variables.
19:38:22 <benzrf> errr
19:38:27 <benzrf> oh, i see
19:38:37 <dolio> Or, I should say, no type variables as part of the language. There are meta-varaibles that can stand in for types.
19:38:38 <benzrf> interesting o=
19:38:47 <dolio> If you have an axiom schema.
19:39:12 <benzrf> dolio: so then non-U types will usually be of the form T <expr>?
19:40:11 <dolio> Depends. If you want to quantify over types, then maybe.
19:40:20 <dolio> U is typically the last thing to be introduced, though.
19:40:24 <benzrf> oh
19:40:26 <benzrf> o.o
19:40:35 <dolio> So you'd talk about all the other types, and then use U to quantify over types.
19:40:35 <voltz> Sorry to interject,  but does Haskell have anything like macros of any metaprogramming?
19:40:46 <voltz> Or
19:40:49 <dolio> Once you introduce U, though, there are lots of other types that aren't inside U, of course.
19:40:52 <benzrf> voltz: there's template haskell, but it's mostly just used for boilerplate generation
19:40:55 <benzrf> voltz: and uncommonly, at that
19:41:02 <hodapp> voltz: Template Haskell, but first off, what are you trying to do?
19:41:09 <dolio> Because U doesn't contain itself.
19:41:20 <voltz> I was just wondering.
19:42:54 <hodapp> voltz: yeah, TH is where to start, but in a great many cases, existing abstractions can solve it without the need for TH
19:44:30 <voltz> As learning about Lisp and it's heavy use of macros.
19:44:44 <gelisam> Hi! I'm trying to debug a hanged program, in the sense that it doesn't respond to CTRL+C. I managed to reproduce the issue in ghci, but now ghci doesn't respond to CTRL+C either, so I'm not sure what else to try. Any ideas?
19:45:12 <benzrf> gelisam: heh
19:45:20 <benzrf> gelisam: can you share the prog?
19:45:20 <hodapp> voltz: Lisp is indeed quite a separate beast.
19:45:29 <gelisam> it's ghcid.
19:45:40 <gelisam> after Neil's recent CTRL+C fix.
19:46:28 <benzrf> tfw various levels of variables are obfuscated together
19:46:49 <hodapp> voltz: and I think you'll find that TH is a bit more 'stratified' than macros in a Lisp.
19:49:20 <voltz> Lisp just makes me giggle sometimes...  Lost in stupid parenthesis.
19:49:33 <hiptobecubic> Lithp
19:53:07 <hodapp> hiptobecubic: HTHATHKELL
19:53:09 <voltz> How to upset a Lisp programmer (
19:53:41 <pharaun> )
19:53:52 <Pip> voltz, Show him/her your Haskell code
19:53:52 * hiptobecubic exhales
19:54:33 <hodapp> ahh, I don't think Haskell annoys most Lisp folks :P
19:54:59 <pharaun> voltz: how bout writing a lisp-like but flip the () around
19:55:08 <pharaun> )+ 1 2(
19:55:09 <voltz> I was trying to convert a rust programmer..  Rust makes me cry a little bit
19:55:14 <Pip> lol
19:55:18 <voltz> XD
19:55:32 <hodapp> voltz: why's Rust make you cry?
19:55:49 <pharaun> afaik HKT is on their agenda
19:55:51 <hiptobecubic> pharaun, just go with RPN entirely )1 2 +(
19:55:58 <pharaun> hiptobecubic: ha good one
19:56:14 <voltz> Stupid curly braces in my FP!
19:57:35 <voltz> In reality though, rust just looks so noisy.
19:58:06 <voltz> So much text to do something simple.
20:00:33 <voltz> Like type definitions
20:00:54 <hiptobecubic> That's so the C++ migrants don't feel out of place
20:01:38 <dolio> It seems to me Rust occupies a pretty different space than Haskell.
20:01:54 <dolio> And one that could use a better language, like it.
20:03:20 <pharaun> i do know when i first migrated off {} languages i was really bothered by its lack
20:03:24 <pharaun> (python then haskell)
20:04:23 <voltz> I was a little distraught by it at first but I don't think I could ever to back.
20:06:50 <voltz> Now I look at other languages and just see all the noise in between code that actually means something.
20:09:15 <Rotaerk> qbasic was my first language, then I tried VB like... 5; when I then read a book on C, I found the braces jarring and weird
20:10:09 <dfeuer> Rotaerk, you got started on something so modern? I started with LOGO and then hit GWBASIC.
20:10:29 <voltz> I started with batch...
20:10:41 <dfeuer> voltz, you mean the DOS thing?
20:10:48 <voltz> Yep...
20:11:00 <dfeuer> voltz, as I recall, that was incredibly primitive. Could it even handle loops?
20:11:24 <voltz> Then I learned.... *urk *Java!
20:11:31 <dfeuer> That was a jump.
20:11:41 <Astrocoder> Bunch of wussies. ASM or GTFO
20:11:47 <voltz> Yeah it could but they were really wierd...
20:11:56 <dfeuer> I wish I knew ASM.
20:12:19 <voltz> What kind of asm?
20:12:36 <Astrocoder> x86 ASM for DOS :D
20:12:39 <Astrocoder> int 21h ftw
20:12:41 <pharaun> JCL and PL/1
20:13:06 <pharaun> now that stuff is weird
20:14:19 <voltz> While I may not be able to asm I used to be able to do mips isa
20:14:46 <voltz> ;D almost the same
20:15:15 <pharaun> first language that i felt almost free to do whatever in was amusingly enough perl
20:15:26 <pharaun> before that it was like c, c++ java, etc
20:15:39 <pharaun> and java always felt like such a verbose language, better these days i think
20:15:49 <voltz> Oh god... Perl gives me the willies...
20:16:03 <pharaun> heh perl was awesome for its time
20:16:19 <pharaun> then i moved on to like ruby/python, currently working on python at work
20:16:40 <pharaun> and that's where my big time love for type system and haskell came from, using python at work on a 3mloc codebase :P
20:17:10 <pharaun> really bought home to me just how powerful the type system was and other nice things hah
20:18:22 <voltz> Like seriously..  Why can't other languages have such a nice type system?
20:18:52 <pharaun> its hard to unprogram yourself, and some of the stuff i've have to learn is way over the skill level of say the interns i see coming in at work
20:19:15 <johnw> this is probably good material for #haskell-blah at this point :)
20:19:22 <pharaun> fair
20:23:31 <voltz> Lo jbopre?
20:24:28 <lpaste> funfunctor pasted “No title” at http://lpaste.net/134212
20:24:57 <funfunctor> What is the prefered way to deal with immutability in the above case?
20:25:18 <lpaste> SydneyHacker pasted “Lens from Constructor” at http://lpaste.net/134213
20:26:43 <sydneyhacker> I am trying to figure out (or discover) a nice way to produce lenses from data types explicitly.
20:26:58 <sydneyhacker> TemplateHaskell is nice but I am trying not to use it
20:27:29 <sydneyhacker> I found that writing a lens for a bunch of two-part datatypes quite repeatative
20:27:33 <johnw> sydneyhacker: there is a 'lens' function for this
20:27:40 <sydneyhacker> So I was thinking along the lines of what I pasted
20:29:43 <hnfmr> do we have "Do notation" for Applicatives now with GHC 7.10?
20:29:49 <sydneyhacker> johnw ok thanks 
20:34:06 <dolio> hnfmr: No.
20:34:14 <hnfmr> ok
20:36:52 <Axman6> shesek: the reason people use the TH functions is because making lenses is very repetetive, almost always along the lines of foo dat@(Const {x}) f = fmap (\x' -> dat { x = x'}) (f x)
20:38:05 <Axman6> uh, sydneyhacker not shesek, sorry
20:39:26 <sydneyhacker> @shesek thanks I understand that but not using TH has advantages
20:39:26 <lambdabot> Unknown command, try @list
20:39:52 <sydneyhacker> however using TH then copying the generated output back into source files works, although the code is ugly
20:49:28 <prsteele> hello everyone. Anyone know how I can hide instances defined in GHC.Base? I'm trying to implement 'instance Functor ((->) e) ...', which is shadowed by GHC.Base
20:50:07 <Iceland_jack> prsteele: Define your own Functor class
20:50:19 <pavonia> You can't hide instances
20:50:28 <Iceland_jack>     class MyFunctor f where
20:50:29 <Iceland_jack>       myfmap :: (a -> b) -> (f a -> f b)
20:50:41 <prsteele> Iceland_jack: ya, I suppose that works. Thanks!
20:50:53 <dmj`> {-# NoImplicitPrelude #-}
20:51:41 <Iceland_jack> prsteele: That's the way to go if you're implementing type class instances, I will also suggest that you enable instance signatures
20:52:08 <prsteele> Iceland_jack: sounds good. This isn't for anything actually useful, just running through exercises in Typeclassopedia
20:52:25 <Iceland_jack> Yup, for learning
20:52:43 <Iceland_jack> *if you're re-implementing tyep class instances for fun or learning :)
20:53:09 <Iceland_jack> Preyer: If you enable InstanceSigs you can write type signatures in your instances
20:53:39 <Iceland_jack> So for lists you can write:
20:53:39 <Iceland_jack>     instance MyFunctor [] where
20:53:39 <Iceland_jack>       myfmap :: (a -> b) -> ([a] -> [b])
20:53:39 <Iceland_jack>       myfmap = ...
20:55:23 <Iceland_jack> That extension is small but can be very useful for learning and comprehending code, just as top-level type signatures
20:55:56 <pavonia> How would you check if a Double is equal to 10^n for an integer n?
20:56:52 <Denommus`> pavonia: use 10**n instead? 
20:57:07 <prsteele> pavonia: you could use logs.
20:57:15 <Denommus`> :t (^) 
20:57:17 <lambdabot> (Integral b, Num a) => a -> b -> a
20:57:30 <pavonia> Denommus`: I don't know n
20:57:33 <Denommus`> Ah, forget it, I'm crazy 
20:58:07 <prsteele> pavonia: log x / log 10 should yield n, which may be fractional
20:58:09 <Denommus`> pavonia: do you mean doing compare d n = d==10^n , then? 
20:58:12 <Iceland_jack> > logBase 10 (10^5)
20:58:15 <lambdabot>  5.0
20:58:30 <Denommus`> pavonia: except without rounding problems? 
20:59:05 <prsteele> pavonia: I think a better approach will be to check n = 0, 1, ... until 10^n exceeds your value. This takes only O(log x) time for x
20:59:10 <pavonia> I'm concerned rounding may a problem with log
21:00:03 <pavonia> Hhm, logBase looks good
21:01:49 <Cale> pavonia: You should generally be concerned whenever you're doing an equality test involving floating point values
21:01:54 <Iceland_jack> Indeed
21:02:12 <Cale> pavonia: Usually it's better to take the absolute difference and test whether this is sufficiently small
21:02:39 <Iceland_jack> > 10**16 == 10**16+1
21:02:42 <lambdabot>  True
21:03:28 <prsteele> 10**100 == 10**100 + 1
21:03:40 <prsteele> > 10**100 == 10**100 + 1
21:03:44 <lambdabot>  True
21:04:15 <pavonia> I'm too lazy to rewrite my parser to distinguish between ints and floats :p
21:04:33 <Iceland_jack> tsk.
21:04:33 <prsteele> in fact
21:04:54 <prsteele> > 10**16 + 1 == 10**16
21:05:00 <lambdabot>  True
21:09:10 <rvxi> hi
21:09:22 <Iceland_jack> hi
21:10:15 <rvxi> hey i was just in iceland
21:10:23 <ronh-> funfunctor how about this?
21:10:32 <hmsster> how do I split a string into su strings, each having N characters 
21:10:41 <hmsster> substringd
21:11:02 <ronh-> funfunctor see annotation
21:11:36 <prsteele> hmsster: searching https://www.haskell.org/hoogle
21:11:37 <Cale> hmsster: You can use chunksOf from Data.List.Split, or if you'd rather not have the extra dependency, something like  map (take n) . takeWhile (not . null) . iterate (drop n)  will work
21:11:43 <hmsster> "123456" -> ["12","34","56"]
21:11:56 <prsteele> hmsster: for "Int -> String -> (String, String)" gives us splitAt
21:12:01 <Cale> > iterate (drop 2) "123456"
21:12:04 <lambdabot>  ["123456","3456","56","","","","","","","","","","","","","","","","","","",...
21:12:14 <Cale> > takeWhile (not . null) . iterate (drop 2) $ "123456"
21:12:16 <lambdabot>  ["123456","3456","56"]
21:12:22 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ "123456"
21:12:25 <lambdabot>  ["12","34","56"]
21:12:39 <Cale> > chunksOf 2 "123456"
21:12:41 <prsteele> > (\x -> splitAt (div (length x) 2) x) "asdffdsa"
21:12:44 <shachaf> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ "12345"
21:12:46 <lambdabot>  ["12","34","56"]
21:12:47 <lambdabot>  ("asdf","fdsa")
21:12:49 <lambdabot>  ["12","34","5"]
21:12:53 <Rotaerk> ..
21:12:55 <hmsster> haha thanks all
21:13:39 <Cale> prsteele: I think you're answering a different question there... though splitAt could be used for this as well
21:14:05 <prsteele> Cale: Ya, I misread, I thought it said the word 'two' somewhere
21:15:51 <Cale> > unfoldr (\xs -> case splitAt 2 xs of ([],[]) -> Nothing; (us,vs) -> Just (us,vs)) "123456"
21:15:55 <lambdabot>  ["12","34","56"]
21:18:44 <hmsster> what is the prefered way
21:19:03 <Cale> hmsster: any of these are fine
21:20:40 <unknownloner> Any way to do something similar to iterate inside a monad? like iterate f x = [x, f x, f (f x)] where f is (a -> m a). Obviously not exactly that, but the same idea
21:20:46 <Cale> :t iterateM
21:20:48 <lambdabot>     Not in scope: ‘iterateM’
21:20:48 <lambdabot>     Perhaps you meant one of these:
21:20:48 <lambdabot>       ‘iterate’ (imported from Data.List),
21:20:57 <Cale> ah, that's probably somewhere...
21:21:23 <Cale> http://hackage.haskell.org/package/monad-loops-0.4.2.1/docs/Control-Monad-Loops.html has some
21:22:34 <Cale> unknownloner: Of course, the one which really gives you an infinite list can't exist.
21:22:43 <unknownloner> grr
21:22:51 <Cale> (well, you can write it, but that doesn't mean it'll work)
21:23:05 <unknownloner> yeah I tried to do something like that
21:23:15 <unknownloner> sat back and watched my memory slowly grow with nothing happening
21:23:38 <Cale> Yeah, because you'll be executing an infinite amount of stuff before the result can be made available
21:23:44 * hackagebot http-streams 0.8.3.2 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.8.3.2 (AndrewCowie)
21:24:42 <unknownloner> More specifically what I want to do is
21:25:02 <unknownloner> Take a list, shuffle it, then shuffle the shuffled list, etc
21:25:19 <unknownloner> and then have access to all of those permutations
21:25:56 <felixn> Anyone know how to run HSpec tests from Test-Suite in cabal?  their documentation doesn't seem to mention that
21:25:59 <Cale> So if you were using http://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
21:26:26 <Cale> hmm
21:26:37 <Cale> Oh, that's a bit derpy
21:26:51 <Cale> They don't have one which returns the generator state along with the shuffled list
21:26:52 <ReinH> felixn: just point it at the module with main in it for your hspec tests
21:27:00 <unknownloner> yeah, that's what I was running in to
21:27:23 <unknownloner> so I figured maybe shuffleM would solve the problem
21:27:44 <unknownloner> and here I am trying to create an impossible infinite list
21:27:48 <Cale> Well, it kind of does
21:27:57 <Cale> You can use runRand
21:27:59 <ReinH> felixn: e.g. https://github.com/fujimura/hi-hspec/blob/master/package-name/package-name.cabal.template#L21-L29
21:28:24 <felixn> ReinH: thank you!  I was using detailed >_<
21:28:51 <ReinH> yw
21:29:03 <solirc> felixn: https://github.com/hspec/hspec-example
21:29:17 <hmsster> can main function somehow take argv like a main function in other languages does?
21:29:18 <unknownloner> oh alright
21:29:31 <unknownloner> I think that works for me now
21:29:33 <Iceland_jack> hmsster: You call a library function to get those
21:29:40 <Iceland_jack> @hoogle getArgs
21:29:41 <lambdabot> System.Environment getArgs :: IO [String]
21:29:42 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
21:29:42 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: MonadIO m => m (String, [String])
21:30:30 <Iceland_jack> To get two arguments (unsafely)
21:30:30 <Iceland_jack>     main = do
21:30:30 <Iceland_jack>       [x, y] <- getArgs
21:30:33 <Iceland_jack>       ...
21:30:37 <Iceland_jack>     
21:31:18 <dmj`> main = mapM_ (f :: String -> IO ()) =<< getArgs
21:31:30 <Cale> unknownloner: do g <- newStdGen; return . map fst . iterate (uncurry (\xs -> runRand (shuffleM xs))) $ ([1,2,3,4,5,6], g)
21:31:38 <Cale> unknownloner: Try that :)
21:31:50 <felixn> solirc: thanks, now that I think of it, I did look at that page like a week ago :)
21:33:03 <Cale> unknownloner: But yeah, that package sort of sucks. Someone should make a better one :P
21:33:19 <unknownloner> Similar to what I had but the uncurry makes it a bit cleaner
21:33:21 <unknownloner> thanks!
21:33:23 <Cale> The algorithm itself is fine, but what the module exposes is silly
21:34:09 <Iceland_jack> Cale: Agreed, I've thought the same when recommending it to people in the past
21:34:18 <Cale> I guess if we really want to be fancy, we can write  iterate (uncurry (runRand . shuffleM))
21:34:21 <hmsster> how to use getArgs function safely?
21:34:34 <Axman6> hmsster: pattern matching?
21:34:36 <solirc> felixn: Also check the readme
21:34:39 <prsteele> main = do args <- getArgs; ...
21:34:43 <Cale> do xs <- getArgs; case xs of ...
21:34:47 <Axman6> use a library for command line args like optparse-applicative?
21:34:53 <solirc> felixn: `cabal` may not be your first choice for running tests during development
21:35:00 <Cale> Or yeah, you can use a nice library for parsing commandline arguments
21:35:21 <Iceland_jack> hmsster: My example "[x, y] <- getArgs" will *crash* at run-time if there aren't exactly 2 arguments
21:35:38 <hmsster> Iceland_jack: awesome :/
21:36:24 <Iceland_jack> hmsster: No need for a ":/", it's useful for quick coding and otherwise you just use the suggestions above
21:36:42 <prsteele> hmsster: If you don't want to rely on a library, first write a function with a signature f :: [String] -> Maybe a, where a is the information you want to extract. pass getArgs to f. If f returns Nothing, write an error message
21:36:49 <Iceland_jack>     args <- getArgs
21:36:49 <Iceland_jack>     case args of
21:36:49 <Iceland_jack>       [x, y] -> ...
21:36:49 <Iceland_jack>       _      -> handle failure
21:38:19 <ReinH> pranz: Or just use pattern matching on []
21:38:25 <ReinH> er prsteele^
21:38:33 <ReinH> I have to get used to this new tab-completion strategy
21:38:59 <hmsster> the fact that [x,y] <- getArgs crashes without any warnings from the compiler makes me sad
21:39:20 <Axman6> it should warn with -Wall I think
21:39:27 <ReinH> no one said "without any warnings"
21:39:58 <hmsster> there are no warnings by default
21:40:34 <ReinH> That's true.
21:40:36 <reem> What’s the easiest way to downgrade from brew ghc 7.10.1 to ghc 7.8.4 (on brew or not) on OS X
21:40:45 <ReinH> reem: uninstall and reinstall?
21:40:56 <ReinH> or you could install into separate locations and change your path
21:41:03 <reem> well I can uninstall 7.10.1 but I can’t figure out how to get 7.8.4 through brew
21:41:19 <reem> I can just build from source but that’s not ideal
21:41:20 <Axman6> reem: I've started using https://ghcformacosx.github.io because it makes it relatively easy to change GHC versions
21:41:26 <Axman6> and it's self contained
21:41:32 <reem> I’m trying to build stack
21:41:35 <Axman6> it has both 7.8 and 7.10
21:41:52 <funfunctor> how to get a new ByteString of n bytes from a ByteString without a copy?
21:41:59 <hmsster> -Wall does not warn about it either
21:42:01 <reem> Axman6: ok cool, I will check it out
21:42:09 <reem> Axman6: for reference how do I uninstall this?
21:42:13 <Axman6> funfunctor: take shouldn;t copy any of the data
21:42:26 <Axman6> reem: which? the brew one or the .app?
21:42:31 <reem> the .app
21:42:36 <reem> brew is just brew uninstall
21:42:38 <Axman6> just delete it like any other .app
21:43:12 <Axman6> if you like you can remove the PATH references too, but it won't break things if the app is gone and they remain
21:43:30 <reem> oh I can just do brew switch ghc 7.8.4
21:43:33 <dmj`> funfunctor: you can get at the underlying pointer \(BS fptr offset len) -> 
21:43:59 <Axman6> that's not necessary :(
21:44:37 <ReinH> funfunctor: take
21:44:40 <Axman6> just use take or drop and take, or pretty much any Data.ByteString function and nothing but the offsets will be copied/changed
21:44:56 <dmj`> Axman6: he said no copying tho
21:45:02 <funfunctor> yep, take I forgot thanks
21:45:29 <reem> how do I wipe out all existing packages I have?
21:45:34 <reem> (cabal packages)
21:46:00 <Axman6> they won't interfere if they were installed using 7.10
21:46:18 <Axman6> packages installed by one compiler are treated as different from those installed by another
21:46:28 <reem> These are old packages installed a while ago
21:46:32 <Axman6> (basically they don't exist to different compiler version)
21:46:34 <reem> which is why I just want to get rid of them
21:46:43 <reem> they were installed with 7.8.4
21:47:01 <Axman6> you can probably delete ~/.ghc and everything in ~/.cabal except your config
21:48:09 <reem> just deleted all of ~/.ghc and that seems to have done it
21:48:23 <scutigera> @hoole (<$)
21:48:24 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
21:48:24 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
21:48:24 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
21:48:52 <hmsster> -Wall is NOT warning about [x,y] <- getArgs
21:49:27 <Axman6> it will warning in a case statement if you forget to cover all cases
21:49:53 <Axman6> no one should ever be suggesting you use patterns like that in a do block anyway unless you know for certain the pattern will always match
21:50:19 <hmsster> it was the first suggestion I got in here on how to use getArgs
21:50:37 <ReinH> a pattern match failure in a do block uses fail by design
21:50:54 <Axman6> it was a poor suggection (sorry Iceland_jack =)
21:51:45 <Axman6> but depending on your usecase a perfectly acceptable one - if you want the app to crash if you don't give it exactly two arguments, then it works perfectly
21:53:27 <hmsster> Axman6: I wouldnt say it works perfectly given the weird error message
21:53:51 <Axman6> then you need to handle the error cases, just like any other language :\
21:54:42 <ReinH> if the weird error message is what you want, it works perfectly
21:54:56 <scutigera> on the hackage page, Data.Attoparsec.Text.Lazy has a "module Data.Attoparsec.Text" but it doesn't seem to re-export the module.
21:55:29 <scutigera> so why is it there ? simply because *.Lazy needs it ?
21:55:52 <prsteele> hmsster: I think what you're getting at is you want a warning for non-exhaustive patterns? I think that is not, in general, a reasonable problem to solve. The only reasonable rule I can think of is 'is there an otherwise', and that will lead to warnings where there are provably no reason to have them
21:56:00 <Axman6> scutigera: can you like to what you're referring to?
21:56:15 <scutigera> http://hackage.haskell.org/package/attoparsec-0.13.0.0/docs/Data-Attoparsec-Text-Lazy.html
21:56:47 <Axman6> it does reexport that module: http://hackage.haskell.org/package/attoparsec-0.13.0.0/docs/src/Data-Attoparsec-Text-Lazy.html
21:56:57 <scutigera> that's weird
21:57:27 <scutigera> let me try again. last time i tried to grab something i had to specifically call it out of .Text, .Text.Lazy didn't work
21:58:08 <scutigera> oh geez. luser error.
21:58:16 <Axman6> notice that there are certain things it doesn't reexport, like IResult, eitherResult, parse etc.
21:58:24 <scutigera> yeah i'm importing lazy version. and it works fine.
21:58:31 <scutigera> yes - i did manage to figure that out...
21:58:32 <scutigera> lol
21:58:42 <Axman6> it is confusing though =)
21:58:56 <scutigera> ok - so generally if you see a module statement like that , can i assume it's being re-exported ?
21:59:26 <Axman6> yes, everything that has been imported from that module will be reexported
22:00:35 <scutigera> ok. hey - i just noticed that source link. i always forget those are there. so now i see that it's in the export list. ty!
22:01:38 <scutigera> so a kindly irc'er gave me the following code:
22:01:45 <scutigera> do () <$ char '!' <* takeWhile1 (/= '\n')
22:02:10 <scutigera> (for attoparsec) which looks for line starting with ! and ignores the line
22:02:22 <scutigera> i was wondering if someone could un-applicative it for me
22:02:51 <ReinH> you don't need the do
22:02:57 <johnw> do takeWhile1 (/= '\n'); char '!'; return ()
22:03:13 <ReinH> johnw: I think you've got those backwards
22:03:14 <arkeet> johnw: you got the first two backwards.
22:03:21 <johnw> oh, right
22:03:46 * hackagebot cf 0.4 - Exact real arithmetic using continued fractions  http://hackage.haskell.org/package/cf-0.4 (mvr)
22:04:23 <scutigera> ok- that works. thanks. now i can ponder on how the two are equivalent.
22:04:35 <scutigera> my goal tonight is to understand how the crazy applicative operators work.
22:05:06 <scutigera> i think i understand the types now. but the left/right associativity thing is causing some confusion
22:05:22 <johnw> f <*> x is the same as do f' <- f; x' <- x; return (f' x')
22:05:31 <kadoban> scutigera: I would focus on understanding the usual Applicative operators, <$> and <*> first, unless they're already very clear to you. The biased versions are not a big jump from there.
22:06:37 <ReinH> scutigera: for a general single-line comment parser, you can steal the one from parsers: try (string lineStyle) *> skipMany (satisfy (/= '\n'))
22:06:54 <ReinH> where lineStyle is, e.g., "!"
22:07:15 <ReinH> scutigera: or you could just use parsers
22:07:28 <scutigera> well my "parser" is really kind of a glorified lexer.
22:07:37 <scutigera> i'm simply using this to learn attoparsec
22:08:01 <scutigera> which is in turn useful to understand those applicative operators - so it's working well as a learning experience
22:09:46 <ReinH> parsers is nice because it abstracts away the details of the individual implementations, so by using parsers you learn more about the nature of those parsers in general
22:09:51 <scutigera> @hoole (<$>)
22:09:53 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
22:09:53 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
22:11:31 <scutigera> ReinH: well, i was kind of wanting to use the lazy interface, just to see how that worked out.
22:12:03 <scutigera> so this kmett guy. he writes kind of a lot of haskell code doesn't he ?
22:12:17 <johnw> he does
22:12:32 <scutigera> i'm looking at his attoparsec example
22:14:42 <scutigera> speaking of parsing did you know haskell won't recognize .35 as a float ?
22:14:46 <scutigera> hmmmm...
22:17:29 <scutigera> ah- so a problem ... do char '#'; line <- takeWhile1 (/= '\n'); return line
22:17:49 <scutigera> ghc complains that Couldn't match expected type ‘T.Text’
22:17:56 <scutigera> with actual type ‘Data.Text.Internal.Text’
22:18:00 <Axman6> that the same as do char '#' takeWhile (/= '\n') btw
22:18:16 <Axman6> uh, with a ; between those two
22:18:32 <ReinH> generally, do x <- f; return x = f is a monad law
22:18:36 <Axman6> you're probably mixing lazy and strict Texts
22:19:44 <scutigera> but but but takeWhile returns Parser Text
22:19:55 <Axman6> there are two Texts
22:19:57 <scutigera> and line <- should then give me a Text
22:20:15 <scutigera> oh wait... i think i typed my function incorrectly
22:20:20 <Axman6> but is it a Data.Text.Text or a Data.Text.Lazy.Text?
22:20:27 <johnw> do x <- foo; return x is the same as just foo
22:21:23 <scutigera> ok - i did type it correctly, using Lazy.Text
22:21:36 <scutigera> import qualified Data.Text.Lazy as T
22:21:45 <scutigera> parseOption :: Parser T.Text
22:22:06 <scutigera> so i'm still confused as to why line <- ... gives me the type conflict...
22:23:01 <scutigera> and yes, do char '#' ; takeWhile1 (/= '\n') makes ghc happy
22:26:09 <scutigera> aha
22:26:11 * Axman6 likes "#" *> takeWhile1 (/= '\n')
22:26:23 <scutigera> if i type it to Parser T.Text either method breaks
22:27:11 <scutigera> parseOption
22:27:11 <scutigera>   :: Data.Attoparsec.Internal.Types.Parser
22:27:11 <scutigera>        Data.Text.Internal.Text Data.Text.Internal.Text
22:27:11 <scutigera>  
22:27:17 <scutigera> so that's what ghc will assign
22:27:27 <scutigera> which is not lazy.
22:27:39 <scutigera> which is highly weird... because:
22:27:46 <scutigera> import Data.Attoparsec.Text.Lazy
22:31:08 <scutigera> Axman6: that doesnt' compile.
22:31:43 <scutigera> with either '#' or "#", shouldn't it be '#' ?
22:32:01 <scutigera> @hoole (*>)
22:32:04 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
22:32:04 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
22:32:04 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
22:32:06 <Axman6> it should be "#" and you need OverloadedStrings
22:32:08 <johnw> string "#" or char '#'
22:32:16 <johnw> (for Attoparsec)
22:32:37 <Axman6> lets you do nice things like importStatement = "import" *> spaces *> moduleParser
22:32:52 <ReinH> scutigera: Data.Attoparsec.Text.Lazy just hands the chunkds from the lazy Text off to the strict parsers
22:32:59 <ReinH> look at, e.g., https://hackage.haskell.org/package/attoparsec-0.13.0.0/docs/src/Data-Attoparsec-Text-Lazy.html#parse
22:33:24 <scutigera> ReinH: right. i saw that when i was reading through.
22:33:32 <ReinH> so those parsers still parse strict text
22:33:33 <Axman6> there's an IsString instance for IsString a => IsString (Parser a) or something which makes for really clear parsers
22:34:06 <ReinH> so takeWhile1 is still a Parser Text for strict text
22:34:28 <scutigera> ah ok. i think i see.
22:34:53 <scutigera> so if i for example wanted to collect all the option lines , i would get a list of Text and not Lazy.Text.
22:34:59 <scutigera> the laziness is really an IO thing.
22:35:15 <ReinH> No, the laziness of Lazy.Text has nothing to do with iO
22:35:30 <scutigera> yeah- i realized that right after i pressed return.
22:36:23 <ReinH> Lazt.Text is made up of a list of chunks of strict text
22:36:41 <scutigera> ReinH: from the docs : "think of this as suitable for use with a lazily read file"
22:37:43 <Axman6> "but please don't and use some kind of streaming IO library for reading files lazily" <- the subtext that should really be there
22:38:00 <hmsster> why does gtk2hs depend on gtk2hs-buildtools?
22:38:12 <scutigera> inputStr <- T.hGetContents inh
22:38:28 <scutigera> is what i'm doing. but i have a big hole where something like "lines" should go.
22:38:34 <scutigera> baby steps. lol.
22:38:37 <hmsster> sorry, I meant why doesn't gtk2hs depend on gtk2hs-buildtools?
22:40:56 <scutigera> i've bored you enough with my attoparsec questions.  i'll go off and actually try to figure out something on my own.
22:41:04 <scutigera> thanks very much for the help.
22:45:53 <Cale> Axman6: I dunno, obviously there's room for disagreement there in a lot of cases. Conduit/pipes/etc. are great, but they're really heavy machinery to introduce if you're just reading a single file.
22:49:04 <johnw> Cale: once you're used to them, and have suitable boilerplate already written elsewhere, they are pretty easy to use.  But starting cold, they are definetly heavy.
22:52:00 <Axman6> Cale: yeah 
22:52:04 <Cale> johnw: Maybe I'm a bit of a luddite in that regard, but there are many cases where I'd turn to just doing strict IO in some sort of explicit loop before introducing conduit.
22:52:49 <Axman6> I don't really like any of the streaming libraries available at the moment (just waiting for edwardk to write the one true streaming library so I can settle on one =)
22:54:13 <ReinH> Well, he did...
22:55:09 <Axman6> machines?
22:55:20 <Axman6> I'd forgotten about that and never looked at it in any depth
22:56:36 <dmj`> Axman6: have you tried io-streams by gcollins?
22:57:10 <Axman6> I had a brief look but it didn't meet my needs at the time
23:03:04 <Bonibon> hola
23:04:35 <johnw> simple-conduit is a way of doing streaming that's pretty cheap
23:05:16 <Guest34113> Help needed on our new genuinevBulletin forum software (it is not nulled) please visit https://www.criosphinx.net for more information (we're able to install vBulletin 5 Connect
23:26:03 <codygman> Is returning a generic IsString type possible? http://lpaste.net/134220
23:26:34 <liste> codygman you want existential types
23:27:01 <liste> but yeah, returning generic IsString is possible, but it's ANY IsString, not SOME IsString
23:27:27 <liste> ie. the caller decides the type
23:27:39 <codygman> liste: Oh, okay thank you. Ooh, that sounds dangerous.
23:28:03 <liste> what do you mean dangerous?
23:28:03 <Cale> codygman: It's taking an argument which is constrained by IsString which seems more questionable.
23:28:06 <Axman6> that's how we do things all the time
23:28:22 <Cale> codygman: The only operation IsString defines is  fromString :: String -> a
23:28:41 <Axman6> you'd also need a toString too
23:28:47 <Cale> So if the only thing you know about a value is that it's of some type which is an instance of IsString, there's pretty much nothing you can do with it
23:28:48 <Axman6> which is different to Show
23:28:58 <subleq__> is it pretty common to use StateT MyProgramState IO?
23:29:15 <Cale> subleq__: Unfortunately :P
23:29:17 <subleq__> I just wrote two unrelated things that used it and i'm not sure if it's a "when you have a hammer" situation
23:29:28 <liste> subleq__ yes, although you may want other transformers later too
23:29:38 <Cale> subleq__: I think it's kind of bad style in a lot of cases where it gets used.
23:30:05 <Cale> IO already has a lot of facilities for statefulness, and if you just use those, you get into less trouble when it comes to things like exception handling and concurrency.
23:30:16 <subleq__> I just used it in my implementation of dc, the rpn calculator
23:30:42 <subleq__> like IORefs?
23:30:50 <codygman> Cale: Oh. I'm actually working with StringLike from TagSoup. I made the mistake of simplifying the problem to IsString because I errantly thought they were the same.
23:32:24 <hmsster> if you are using cabal sandboxed how do you open a repl for playing around and testing various libraries? do you create a cabal file with a huge dependency list just for that?
23:32:37 <hmsster> sandboxes
23:32:58 <Cale> subleq__: Yeah
23:33:18 <liste> hmsster cabal repl
23:33:32 <alpounet> hmsster: 'cabal exec ghci' maybe? that doesn't require a cabal file, as opposed to 'cabal repl'
23:33:50 * hackagebot getopt-generics 0.7.1 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.7.1 (qoelet)
23:34:25 <hmsster> alpounet: how does it determine what packages to install without a cabal file?
23:35:28 <jle`> i like to cabal exec bash and then ghci
23:35:33 <jle`> then i can add in command line arguments to ghci
23:35:38 <jle`> if i wanted to
23:35:43 <Cale> subleq__: There's one rather good argument for using StateT over IO, and that's when you can write a substantial amount of stuff such that it's polymorphic over the choice of monad, guaranteeing that there's no IO in it. Another case where pretty much anything goes would be if you can newtype and provide enough operations so that nobody can really tell from outside the module that you're using StateT over IO.
23:37:00 <Cale> subleq__: But I don't tend to like paying for the syntactic overhead of using liftIO everywhere just to avoid passing a parameter
23:37:13 <subleq__> Cale: right! I thought it was pretty cool that I could write pure stack manipulations, that just happened to run in IO later 
23:37:16 <subleq__> Like liftIntBinOp :: (MonadState ProgramState m) => (Int -> Int -> Int) -> m ()
23:39:09 <subleq__> I don't know what you mean by "avoid passing a parameter"
23:39:30 <wyager> Haskell should really abandon exceptions. Here's a fun thing that just happened to me: I was using Binary to decode some stuff sent over the network. I said "Hey, this might throw an exception, because Binary does that, so I'll install an exception handler." All good, right? Wrong. Because Binary is lazy, the exception doesn't get raised right away. So if I pass the decoded value to another process and that process happens to b
23:39:31 <wyager> the one that forces the evaluation of the thunk, the exception will be raised in that process instead of the process that actually caused the exception. Laziness + Exceptions = bombs bouncing through your processes.
23:40:27 <Cale> wyager: If you throw exceptions from pure expression evaluation (i.e. by calling error), you should not expect them ever to be caught.
23:40:36 <mniip> wyager, which is why you catch exceptions in the IO code using seq and friends
23:40:50 <Cale> wyager: Basically, the ability to catch exceptions of that sort only exists as a last resort.
23:40:51 <wyager> mniip: Yes, I had to use BangPatterns/seq
23:40:56 <wyager> ugly, ugly, ugly
23:41:18 <Cale> Which exception exactly?
23:41:50 <wyager> hGet on a handle without enough bytes
23:42:52 <Azel> Doesn't binary have runGetOrFail just for that purpose? When you think you'll be able to recover from the error?
23:42:59 <Cale> Where is hGet defined?
23:43:09 <wyager> Data.ByteString.Lazy
23:43:28 <wyager> Azel: Sort of. runGetOrFail is overcomplicated
23:43:34 <wyager> Cereal does this in a nice way
23:43:38 <wyager> I understand why Binary can't
23:44:25 <wyager> although it would be nice if there was something like `decodeSafe :: Binary b => ByteString -> (ByteString -> b) -> Either String b`
23:44:31 <Cale> Ah, well, there's no way for hGet to do its job lazily if it's not allowed to fail altogether when there aren't enough bytes
23:44:41 <wyager> It would allow for lazy decoding with Cereal's much better error handling
23:45:02 <Cale> You should assume that it's a precondition for hGet that enough bytes are available, rather than trying to catch that error. If you need to handle that case, don't use hGet.
23:45:03 <hmsster> h
23:45:22 <wyager> That doesn't solve the problem I mentioned
23:45:36 <wyager> which is that exceptions in general do not play nicely with laziness
23:45:46 <Azel> Like decodeOrFail? I mean, like runGetOrFail it does gives you way more information but doesn't it fits the bill?
23:45:50 <wyager> But yeah, I might just switch to Cereal
23:46:04 <hmsster> jle how do you get packages that are not  installed globally to work without a cabal file?
23:46:19 <Cale> wyager: It's best to think of exceptions thrown from the evaluation of expressions as not really exceptions, they're basically nontermination.
23:46:46 <wyager> Cale: This is thrown from an IO ()
23:46:53 <wyager> Not a pure expression
23:46:54 <Cale> Sadly, it's not.
23:47:02 <jle`> hmsster: start a sandbox and cabal install?
23:47:04 <Cale> It's thrown from the evaluation of the resulting ByteString
23:47:04 <wyager> hGet is definitely not pure
23:47:23 <hmsster> jle`: oh that works?
23:47:25 <Cale> If the exception *were* thrown from the IO action, then you wouldn't be having this problem.
23:47:39 <jle`> yeah, cabal sandbox is for a directory
23:47:42 <jle`> not for a project
23:47:44 <ronh-> neat
23:47:52 <jle`> you can just cabal sandbox init in an empty directory and cabal install whatever
23:48:04 <jle`> if you `cabal exec bash` then you are in an environment with those packages installed
23:48:06 <Cale> But there's lazy IO shenanigans going on here, with IO (and exceptions) being deferred to the evaluation of the result of hGet.
23:48:26 <hmsster> can i do this within emacs somehow? so that I dont have to have terminal opened just for this
23:48:33 <wyager> Cale: No, it's definitely thrown from where hGet tries to read from the handle and there's nothing left
23:48:35 <Cale> This is a well known problem with lazy IO in general -- if you need to handle exceptional cases nicely, it's not so good.
23:48:45 <srhb> Remind me, why is there no proper functor instance for ByteString?
23:48:46 <wyager> The reason it's not caught immediately is because it's unsafeInterleaved
23:48:57 <jle`> srhb: bad kinds
23:49:11 <srhb> I just had to do a convoluted foldM because I couldn't figure out how to map over it :P
23:49:18 <jle`> also it doesn't really make sense, you can't fmap an arbitrary function over a ByteString
23:49:33 <srhb> Right, actually what I wanted is mapM_
23:49:33 <jle`> you can 'map' with (Word8 -> Word8) functions
23:49:36 <wyager> But IO actions can definitely be lazy without being pure
23:49:41 <Cale> Whenever x is an IO action, then unsafeInterleaveIO x is an IO action which does nothing, returning immediately a magical result whose *evaluation* causes x to be executed.
23:49:48 <jle`> srhb: yeah, that's what mono-traversable and the MonoFoldable typeclass is for
23:49:53 <jle`> it has otraverse_, omapM_
23:49:59 <wyager> Cale: Yes, but I'm not sure why you're calling this "pure"
23:50:05 <srhb> jle`: oooo, hadn't heard of that. Thanks! Sounds like what I need.
23:50:12 <jle`> mhm
23:50:16 <Cale> wyager: I'm lumping this in with all the pure exceptions
23:50:29 <Cale> wyager: Basically, because it occurs during the evaluation of an expression at runtime
23:50:40 <jle`> it's nice for Foldable especially because all Foldable instances really *would* make sense for any MonoFoldable like ByteString
23:50:52 <jle`> the only thing stopping it is kind and a restricted input parameter
23:50:56 <srhb> ;Indeed.
23:51:00 <srhb> It feels a bit weird.
23:51:09 <wyager> Well you probably don't want to go around telling people things like "If the exception *were* thrown from the IO action, then you wouldn't be having this problem.", because that gives the false impression that all common IO libraries are strict
23:51:18 <wyager> Many of them are not
23:51:33 <Cale> wyager: The execution of hGet doesn't cause the exception to fire.
23:51:34 <wyager> and hence have this unpredictable exploding exception issue
23:51:40 <Cale> The exception only fires long after that
23:51:55 <Cale> when you evaluate the result of hGet
23:52:11 <Cale> hGet does very little when executed in fact
23:52:20 <wyager> Cale: Yes, it does. The exception fires presumably when some FFI function calls `read()`
23:52:38 <wyager> This exception is not raised on a ByteString
23:52:47 <wyager> This much is obvious, if you look at the source of ByteString.Lazy
23:53:03 <Cale> If executing hGet actually read the handle, then you could get an easy-to-catch exception
23:53:10 <wyager> It *does* read the handle
23:53:22 <wyager> when the thunk for the next part of the ByteString is evaluated
23:53:43 <Cale> Nope, executing hGet does almost nothing, returning a result whose later *evaluation* causes more I/O to happen, which actually reads the handle.
23:54:04 <wyager> You're arguing semantics, and you're arguing an unpopular viewpoint
23:54:15 <Cale> huh?
23:54:19 <wyager> You're basically saying that functions in Haskell that return lazy structures don't actually return the structure
23:54:28 <Cale> Where did I say that?
23:54:49 <Cale> I'm simply making a careful distinction between execution and evaluation.
23:55:18 <Cale> Exceptions thrown from evaluation are hard to catch, to the point that if something throws an exception from evaluation, it should usually be treated as uncatchable unless you have no other option.
23:55:29 <wyager> "Nope, executing hGet does almost nothing, returning a result whose later *evaluation* causes..." ~ "evaluating repeat does almost nothing, returning a result whose later *evaluation* causes a list to be generated"
23:55:31 <Cale> Exceptions thrown from execution are easy to catch and have sensible semantics.
23:55:50 <wyager> All lazy structures in Haskell return a result whose later evaluation causes something to happen
23:55:54 <wyager> we still say "it returns a list"
23:55:59 <Cale> evaluating  repeat 1  will result in a single cons cell
23:56:01 <wyager> even if the list is only WHNF evaluated
23:56:42 <subleq__> is it true that lazyReadFile = unsafeInterleaveIO . strictReadFile?
23:56:46 <nshepperd> wyager: you're mixing up execution and evaluation
23:56:55 <wyager> nshepperd: No, I'm not
23:56:56 <Cale> subleq__: Not quite.
23:57:12 <Cale> subleq__: It recursively reads a chunk at a time.
23:57:22 <nshepperd> wyager: 'hGet handle n >> foo' -- at the point 'foo' executes, no read() calls have happened yet
23:57:32 <wyager> I'm aware
23:57:45 <subleq__> Cale: ok, but basically the same idea?
23:57:49 <Cale> I don't think I've said anything untrue here.
23:57:57 <Cale> subleq__: roughly, yeah
23:58:17 <nshepperd> wyager: that's all Cale is saying by "executing hGet does almost nothing"
23:58:35 <wyager> And I'm saying that, because we say "a -> [a] returns a list", not "a -> [a] returns a WHNF cons cell that generates a list", it also doesn't make sense to say "hGet returns a WHNF Lazy ByteString that returns a ByteString when evaluated"
23:58:44 <wyager> executing repeat "does almost nothing"
23:58:49 <wyager> but we don't speak in those terms
23:58:56 <Cale> You can't execute repeat
23:59:00 <Cale> It's not an IO action
23:59:07 <wyager> No, but we can evaluate it
23:59:11 <Cale> yes
23:59:18 <unknownloner> It makes sense for IO because it's a lot more important to know when an IO action actually _does_ something
23:59:19 <Cale> I don't see your point
23:59:25 <unknownloner> it's not as important to know when a pure function does something
