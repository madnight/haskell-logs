00:00:02 <MP2E> Also really only 2 folds are relevant in practice
00:00:05 <MP2E> foldl' and foldr
00:00:15 <MP2E> there are exceptions but they are few
00:00:53 <Arahael> Maxdamantus: Iirc, this is a fantastic paper explaining how Haskell got to where they went with the IO monad.
00:00:56 <Arahael> https://wiki.haskell.org/History_of_Haskell
00:01:15 <itsMontoya> I see some suggestions converting the int to string, then converting each string char to int
00:01:21 <itsMontoya> But that seems like a ton of allocations
00:01:30 <Maxdamantus> Arahael: are you intending to refer to me or someone else?
00:01:45 <mauke> itsMontoya: what's wrong with allocations?
00:02:11 <Axman6> allocations are cheap, and easily removed by the compiler in many cases
00:02:13 <Arahael> Maxdamantus: You, though we may be talking at cross purposes.
00:02:13 <itsMontoya> Maybe my n00bness is showing. In  other languages I've worked with, minimizing allocations is best practice
00:02:35 <Arahael> itsMontoya: In Haskell, better practice is avoiding premature optimisation.
00:02:43 <itsMontoya> Arahael: (chuckle) Fair enough!
00:02:53 <Axman6> s/In Haskell, //
00:03:19 <Axman6> itsMontoya: if it turns out it is a major problem, we can help, but wait until it is a problem first
00:03:34 <Arahael> itsMontoya: Especially if the compielr can do the optimisation for you, but you are permitted to go deeper and write less idiomatic haskell in exchange for performance, though you should be able to demonstrate exactly why you needed to do that. (Eg, by unboxing types, etcetera)
00:03:35 <Cale> itsMontoya: Well, there's nothing wrong with removing excess allocations -- it can help the time cost of your programs quite a lot, but first you need to know which allocations matter, which usually involves at least profiling.
00:03:43 <EponymicCycloid> Anyone here good at Cloud Haskell? I'm trying to do something (that should be simple?), but I'm having a hard time. I want to send a message to a "master process" that's already running on a different node. Unfortunately, I have no idea how to get the ProcessId of the master process on the node I want to talk to (as I only have its NodeId).
00:03:53 <itsMontoya> Well I'm just following this Haskell course, I'm doing the homework to make sure I understand the lesson enough
00:03:58 <itsMontoya> So I just wanted to approach it correctly
00:04:15 <Axman6> which course?
00:04:16 <itsMontoya> I didn't want to develop bad/lazy habits from the start
00:04:22 <Cale> itsMontoya: Anyway, to answer your other question, you can do it the cheesy way using show, or you can use arithmetic
00:04:32 <itsMontoya> Axman6: cis194
00:04:32 <Axman6> "happy numbers" by any chance?
00:04:35 <Axman6> ah ok
00:04:48 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 1234
00:04:50 <lambdabot>  [4,3,2,1]
00:04:52 <mauke> you're going to need "lazy habits" :-)
00:04:56 <Arahael> itsMontoya: In general though, I would only worry about allocations if I was explicitly dealing with memory on the heap (which I'd often do in C, for instance). Most other types are fairly easy to have the compiler optimise for you.
00:05:02 <Cale> You can see how this works in steps:
00:05:07 <Cale> > iterate (`div` 10) $ 1234
00:05:09 <lambdabot>  [1234,123,12,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
00:05:17 <Cale> > takeWhile (/= 0) . iterate (`div` 10) $ 1234
00:05:20 <lambdabot>  [1234,123,12,1]
00:05:22 <itsMontoya> Arahael: Ah ok, I come from Golang/C
00:05:25 <Cale> > map (`mod` 10) takeWhile (/= 0) . iterate (`div` 10) $ 1234
00:05:30 <Cale> oops
00:05:32 <lambdabot>      Couldn't match expected type ‘(Integer -> Bool) -> [Integer] -> c’
00:05:32 <lambdabot>                  with actual type ‘[Integer]’
00:05:32 <lambdabot>      The function ‘map’ is applied to three arguments,
00:05:33 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 1234
00:05:33 <backchat> anyone want to tell me how "Map k is made an instance of Functor" from http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
00:05:37 <lambdabot>  [4,3,2,1]
00:05:58 <Axman6> backchat: why shouldn't Map k be a Functor?
00:06:04 <Cale> itsMontoya: So that gets you the digits in the more natural order of increasing degree of power of 10 :)
00:06:08 <Axman6> or, are you wondering how to do it?
00:06:17 <Cale> itsMontoya: If you want them in the other order, you need to reverse the resulting list
00:06:19 <Arahael> itsMontoya: What you have to watch out for with Haskell, are space leaks, you'll learn about those when you learn about foldR/foldL.
00:06:31 <Arahael> (foldr, foldl, rather)
00:06:37 <backchat> Axman6: I don't know. What is k? A function? A type
00:06:39 <itsMontoya> Arahael: Ah ok, I'll keep that in mind (writing it down)
00:06:47 <itsMontoya> Cale: Thanks! I'm looking over your code now
00:06:49 <backchat> ?
00:06:51 <Walther> Just curious, is /= a function whereas any other?
00:07:00 <mauke> Walther: "whereas"?
00:07:07 <Cale> :t (/=)
00:07:08 <lambdabot> Eq a => a -> a -> Bool
00:07:12 <Axman6> backchat: Map k v == (Map k) v == f v where f = Map k
00:07:18 <Cale> Yes, (/=) is a function
00:07:35 <Walther> > let (!=) = (/=) in True != False
00:07:38 <lambdabot>  True
00:07:40 * hackagebot bytestring-lexing 0.5.0.1 - Parse and produce literals efficiently from strict or lazy bytestrings.  http://hackage.haskell.org/package/bytestring-lexing-0.5.0.1 (WrenThornton)
00:07:40 * hackagebot bytestring-lexing 0.5.0.2 - Parse and produce literals efficiently from strict or lazy bytestrings.  http://hackage.haskell.org/package/bytestring-lexing-0.5.0.2 (WrenThornton)
00:07:42 <Walther> hehehehe
00:07:51 <Cale> (/= 0) is also a function, it's an operator section which means (\x -> x /= 0)
00:07:58 <backchat> Axman: is v always a list?
00:07:59 <Arahael> >  map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 1204
00:08:01 <lambdabot>  [4,0,2,1]
00:08:04 <backchat> Axman: or map?
00:08:08 <Axman6> backchat: v can be anything at all
00:08:11 <Walther> i'm probably going to start sticking that alias in my .hs files, just so they both work
00:08:18 <Cale> Walther: awful
00:08:21 <Axman6> instance Functor (Map k) where ...
00:08:33 <Cale> :)
00:08:41 <backchat> Axman: I'm not sure :(
00:08:46 <Axman6> it's just saying that Map k is the "container" which contains a's which can be turned into b's
00:08:55 <Cale> itsMontoya: You might dislike the fact that we do more division than strictly required here, by having the div and mod operations be separate
00:09:04 <MarcelineVQ> backchat: don't be afraid to skip ahead on fuctor stuff and come back to it later, you'll be fine with map,foldr,filter for a long while
00:09:05 <Cale> itsMontoya: It's possible to write it using unfoldr instead:
00:09:07 <Walther> Cale: well, in my opinion /= is a bit awful as well if you look at the other languages and which one is more common
00:09:08 <MarcelineVQ> *functor
00:09:45 <backchat> Axman: Oh but I am. I have litterally been teaching myself haskell so I can finally understand all the hype about monoids - another 2 chapters away
00:09:52 <Axman6> backchat: the type of fmap on lists is usually written as: fmap :: (a -> b) -> [a] -> [b], but you could also say: fmap :: (a -> b) -> [] a -> [] b
00:10:09 <mauke> backchat: but monoids are simple!
00:10:11 <Axman6> backchat: you already know monoids
00:10:36 <Axman6> x + 0 = ?
00:10:37 <Cale> Walther: /= looks more like the symbol it's supposed to represent though :)
00:10:40 <Axman6> x * 1 = ?
00:10:49 <Axman6> xs ++ [] = ?
00:11:00 <Axman6> f . id = ?
00:11:00 <Cale> Walther: i.e. ≠
00:11:01 <backchat> Axman: looking forward to the eureka moment, but I've been rather strict on advancing only when I understand things so far, and it would be a shame to break the streak now with functors
00:11:26 <Cale> backchat: There's hype about monoids?
00:11:33 <mauke> Walther: other languages have ! meaning "not"
00:11:37 <Walther> Cale: sure, I can see the reasoning, but even then if I had a dollar for every time my .hs doesn't work because I've typed != absent-mindedly...
00:11:40 <Walther> mauke: indeed
00:12:01 <Cale> In Haskell, usually ! either indicates strictness or lookup of some sort.
00:12:09 <Cale> (It's used for array lookup)
00:12:12 <backchat> Cale: frequently pops up on HN and I hear go devs talk about it. 
00:12:20 <EponymicCycloid> backchat: Do you mean *monads*?
00:12:25 <EponymicCycloid> No one talks about monoids
00:12:33 <Axman6> backchat: anyway, all that implementing Functor (Map k) meas is that you need to write a function with the type: (a -> b) -> Map k a -> Map k b
00:12:40 <backchat> EponymicCycloid: possibly :P
00:12:52 <EponymicCycloid> Yeah, that's probably it haha
00:12:53 <Cale> Monoids are simple algebraic structures which show up all over the place, but there's not too much to say about them.
00:13:07 <itsMontoya> Cale: So I have your example working in ghci, but I'm having trouble wrapping my head around it. Still getting used to the Haskell syntax
00:13:07 <Arahael> EponymicCycloid: What about the monoid of endofunctions?
00:13:28 <EponymicCycloid> Arahael: Isn't it "Endofunct*or*"? :p
00:13:45 <backchat> Axman6: so would my instance look like:
00:13:51 <Cale> backchat: A monoid is just a set with a binary operation on it which has an identity element and is associative. For example, the natural numbers and addition, lists of some sort and concatenation, rational numbers and multiplication, etc. etc. 
00:14:10 <Cale> itsMontoya: Well, I can avoid using so much function composition.
00:14:16 <backchat> instance Functor (Map) where
00:14:32 <EponymicCycloid> backchat: A monoid `a` has `<> :: a -> a -> a` and `mempty :: a` such that `x <> mempty = x` and `mempty <> x = x`
00:14:35 <Cale> > iterate (`div` 10) 123456789
00:14:37 <lambdabot>  [123456789,12345678,1234567,123456,12345,1234,123,12,1,0,0,0,0,0,0,0,0,0,0,0...
00:14:40 <Axman6> no, like I wrote earlier: instance Functor (Map k) where\n fmap f mp = ...
00:14:41 <Arahael> EponymicCycloid: Good catch!
00:14:48 <mauke> backchat: no, not (Map)
00:14:58 * Arahael heads off!
00:15:02 <itsMontoya> So then you say take while it does not == 0
00:15:10 <Cale> itsMontoya: iterate is a function which takes a function f and an initial value x, and essentially produces the list [x, f x, f (f x), f (f (f x)), ...]
00:15:31 <Cale> Right, eventually if we divide the number by 10 enough times, we'll start getting 0
00:15:40 <Cale> and we want to chop the list off at that point
00:15:46 <itsMontoya> Right
00:15:54 <EponymicCycloid> backchat: A monad `m` has `>>= :: m a -> (a -> m b) -> m b` and `return :: a -> m a`. Those functions also have to follow some basic rules, but they're not enforced by Haskell
00:15:57 <Cale> > takeWhile (/= 0) (iterate (`div` 10) 123456789)
00:15:59 <lambdabot>  [123456789,12345678,1234567,123456,12345,1234,123,12,1]
00:16:04 <itsMontoya> So then 1234 becomes -> [1234, 123, 12, 1]
00:16:07 <EponymicCycloid> Turns out those two functions are useful for representing many things
00:16:10 <Cale> yep
00:16:15 <itsMontoya> Ok got that part
00:16:19 <EponymicCycloid> Like context-sensitive parsers, stateful computation, etc
00:16:29 <Cale> and now we divide the elements by 10, but this time, take the remainder
00:16:31 <itsMontoya> Now I'm confused how we go from there, to [1,2,3,4]
00:16:42 <Cale> > map (`mod` 10) [1234, 123, 12, 1]
00:16:44 <lambdabot>  [4,3,2,1]
00:16:47 <backchat> mauke: instance Functor (Map k) where
00:16:48 <Axman6> EponymicCycloid: backchat did say he was trying to take things one step at a time. wait until he understands Functor at the very least
00:16:50 <itsMontoya> OH
00:16:51 <itsMontoya> OH
00:17:00 <itsMontoya> So you skip making [1,2,3,4] altogether
00:17:13 <EponymicCycloid> Axman6: You don't really need to understand functor to understand Monad's associated functions
00:17:18 <EponymicCycloid> maybe to understand why they're useful...
00:17:28 <Axman6> I disagree
00:17:30 <Cale> itsMontoya: Well, if you want [1,2,3,4], it'll take one more step
00:17:36 <Cale> (reversing the list)
00:17:40 <itsMontoya> So would you add a ":" to it?
00:17:42 <itsMontoya> When inserting
00:17:45 <itsMontoya> To throw it to the front?
00:17:49 <Cale> hm?
00:17:55 <pacak> > reverse $ unfoldr  (\x -> if x == 0 then Nothing else Just $ swap $ x `divMod` 10) 1234
00:17:59 <lambdabot>  [1,2,3,4]
00:18:07 <Cale> > reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 1234
00:18:09 <lambdabot>  [1,2,3,4]
00:18:19 <itsMontoya> Ahh k
00:18:43 <mauke> but consider 0
00:18:53 <Cale> yeah, 0 will get you an empty list of course
00:18:56 <mauke> the show method gives [0]
00:19:14 <Cale> also, negative numbers might be a little strange :)
00:19:20 <Cale> > reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ -1234
00:19:24 <lambdabot>  mueval-core: Time limit exceeded
00:19:31 <backchat> mauke: is "instance Functor (Map k) where" correct?
00:19:36 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ -1234
00:19:38 <lambdabot>  [6,6,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
00:19:40 <mauke> backchat: yes
00:20:12 <Cale> heh, it's a 10-adic expansion
00:20:34 <itsMontoya> That was super helpful, thank you guys :)
00:20:39 <mauke> is that like ... 10's complement?
00:20:41 <Cale> yes
00:20:42 <Walther> Integer was unbound, why is Int 2^29-1 instead of say, 32 or 31 for signed?
00:20:54 <backchat> mauke: would the body be fmap :: (a->b)  -> Map k a -> Map k b
00:20:55 <mauke> Walther: ?
00:21:19 <Walther> just started wondering about the minBound and maxBound, why an exponent of 29
00:21:22 <mauke> backchat: no, you don't put type signatures in instances
00:21:24 <pacak> > maxBound :: Int32
00:21:25 <Cale> Walther: The spec leaves room for tag bits
00:21:25 <Walther> https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Int.html
00:21:26 <Axman6> Walther: that's the minimum specified by the haskell standard. in GHC, Int is a 64 bit value on a 64 bit machine
00:21:26 <lambdabot>  2147483647
00:21:33 <pacak> > 2^31
00:21:35 <Walther> Axman6: Ahh
00:21:35 <lambdabot>  2147483648
00:21:49 <Axman6> > maxBound :: Int
00:21:51 <lambdabot>  9223372036854775807
00:22:09 <mauke> > maxBound :: Word
00:22:11 <lambdabot>  18446744073709551615
00:22:12 <backchat> mauke: would the body be fmap Map k x = Map k x
00:22:13 <Cale> I'm not sure there was ever an implementation of Haskell proper which made use of that
00:22:32 <Walther> Cale: what kind of tags?
00:22:35 <mauke> backchat: no, there is no data constructor called "Map"
00:22:48 <Cale> Walther: "is this a pointer to code, or is it an evaluated Int?"
00:22:51 <backchat> mauke: would the body be fmap k x = k x
00:22:52 <mauke> backchat: also, that would need parens
00:23:00 <Walther> Cale: Gotcha.
00:23:13 <backchat> mauke: I'm just being an idiot now. hacking it :(
00:23:19 <mauke> backchat: that's a type error. k doesn't take a map, but x is a map
00:24:15 <mauke> backchat: ... where fmap = Data.Map.map
00:24:26 <mauke> backchat: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Lazy.html#g:14
00:24:49 <mauke> Data.Map provides a suitable function
00:28:45 <backchat> mauke: so to me a functor is some container, which I can apply some method over. is this a good intuition
00:28:48 <backchat> mauke: ?
00:28:56 <itsMontoya> So I know I'm doing something wrong here: https://gist.github.com/itsmontoya/63f01b460e0c6ceab9ba#file-gistfile1-hs-L6
00:30:01 <mauke> backchat: yes. it's not the whole story but it's a good start
00:30:35 <mauke> backchat: an important point is that fmap doesn't change the structure of the container, just the values
00:31:03 <backchat> mauke: yes, it just applys a function on the every instance of the type in the container, yes?
00:31:09 <mauke> yes
00:31:12 <Axman6> itsMontoya: what's wrong with it?
00:31:24 <itsMontoya> Getting ghci errors
00:31:26 <backchat> mauke: so we want to apply a functor over a map 
00:31:55 <backchat> mauke: is this what the original question is asking?
00:32:10 <Axman6> a function, not a functor
00:32:28 <backchat> mauke: "Try figuring out how Map k is made an instance of Functor by yourself!"
00:32:30 <Axman6> a Functor is somethinc you can apply a function to the elements inside (sort of)
00:32:43 <Axman6> something*
00:32:52 <backchat> Axman: yes I meant function, just a typo
00:32:57 <backchat> Axman: sorry
00:32:57 <mauke> backchat: yeah
00:33:05 <itsMontoya> Axman6: I updated the gist with the error
00:33:41 <Axman6> itsMontoya: what's the type of (.)?
00:33:54 <mauke> itsMontoya: (map (`mod` 10) . divideByTenList) n
00:34:03 <backchat> mauke: so i think of a map, typically, as a 2d object - a list of Key-value pairs
00:34:13 <itsMontoya> mauke: Ah ok, let me try that
00:34:31 <MarcelineVQ> :t (.)
00:34:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
00:34:38 <itsMontoya> mauke: That was it
00:34:39 <mauke> itsMontoya: (.) composes two functions. (divideByTenList n) is not a function; it's a list
00:34:48 <itsMontoya> AHHH
00:34:49 <itsMontoya> Oh ok
00:34:55 <itsMontoya> That makes a lot more sense
00:35:47 <backchat> mauke: ahhh, so is the instance body just fmap = map k ?
00:36:03 <mauke> backchat: there is no k
00:36:28 <mauke> except for the one in (Map k) but that's a type variable, not a value
00:37:03 <backchat> mauke: just fmap = map ?
00:37:14 <mauke> <mauke> backchat: ... where fmap = Data.Map.map
00:37:41 <mauke> you have to disambiguate because Prelude also exports a 'map'
00:37:50 <xj54y> just got a new notebook.. So excited! :-D
00:38:40 <itsMontoya> Here is the final form, how does it look? https://gist.github.com/itsmontoya/63f01b460e0c6ceab9ba
00:40:10 <xj54y> gosh I really really like haskell and emacs.. I don't know what's happening. Something has snapped completely in place ^^
00:40:50 <backchat> mauke: ah is Data.Map.map different to plain old map (what's used at the start of the functor section on that webpage)
00:41:15 <backchat> mauke: ?
00:41:25 <Axman6> yes
00:41:28 <Axman6> :t map
00:41:30 <lambdabot> (a -> b) -> [a] -> [b]
00:41:33 <Axman6> :t Data.Map.map
00:41:35 <lambdabot> (a -> b) -> M.Map k a -> M.Map k b
00:43:16 <backchat> Axman6: OK. OK, it's starting to click. many thanks
00:43:21 <itsMontoya> Any suggestions to my code would be greatly appreciated
00:46:36 <liste> itsMontoya your | n = ... guard doen't make sense
00:46:51 <liste> "n <= 0" is a Boolean
00:46:56 <liste> "n" is Integer
00:47:16 <itsMontoya> Ahh, well I felt it was unnecessary to declare any further checks. Can I just declare it outside the guard then?
00:47:19 <liste> did you mean `| otherwise = ...' ?
00:47:24 <itsMontoya> Yes!
00:47:47 <liste> > otherwise -- by the way, it's just a value
00:47:51 <lambdabot>  True
00:47:57 <itsMontoya> OH
00:48:04 <itsMontoya> Would I need the pipe?
00:48:06 <itsMontoya> Or just otherwise
00:48:10 <MarcelineVQ> if you did want a value off a boolean you could use an if statement
00:48:20 <itsMontoya> Derp, don't mind me
00:48:32 <liste> itsMontoya you need pipes for guards
00:48:44 <itsMontoya> ^^^ Yep, realized that once I said it
00:48:55 <liste> (: the rubber duck effect
00:48:59 <itsMontoya> I'm getting an error with otherwise
00:49:05 <dbushenko> hi all!
00:49:06 <liste> what error?
00:49:18 <itsMontoya> OH, fixed it
00:49:23 <itsMontoya> Hai rubber duck
00:49:28 <dbushenko> how to build a cabal project to get windows executable from linux?
00:49:42 <itsMontoya> Just updated my gist liste
00:49:46 <itsMontoya> I really appreciate the input
00:50:05 <Axman6> dbushenko: I don't know fur sure, but I would guess "with a lot of effort"
00:50:05 <ocramz> dbushenko: cabal just calls your c compiler, you have to figure out how to cross compile using that 
00:50:17 <Axman6> ocramz: that's not true
00:50:18 <dramforever> dbushenko: don't know if the best way, but you can install ghc in wine
00:50:36 <ocramz> Axman: I don't mean exclusively
00:50:45 <merijn> ocramz: Cabal doesn't call a C compiler at all...
00:50:50 <dbushenko> ok, I think, would be easier to boot to windows and compile it there
00:50:52 <dbushenko> thanks!
00:50:55 <Axman6> (Except when using the FFI)
00:50:56 <merijn> ocramz: Well, unless you have C files in your project...
00:51:03 <dramforever> dbushenko: haha sure
00:51:19 <merijn> Axman6: Not with FFI either, unless you're FFI'ing to bits of C that are part of your project :p
00:51:39 <ocramz> oh gosh sorry yes, now I got what you guys mean. I was about to ask an inline-c question and my mind is filled w that
00:52:13 <Axman6> merijn: right, your answer is probably more accurate =)
00:52:23 <ocramz> dbushenko: sorry for that rushed answer
00:54:07 <ocramz> seeing as you guys are so sharp already, care to help me out with my inline-c woes? specifically, is it possible to link the object files within a GHCi session? 
00:54:50 <ocramz> I wrote the bug down here: https://stackoverflow.com/questions/30690576/importing-inline-c-modules-in-ghci ; I get a module not found error for a file that is there ..
00:55:07 <Axman6> I think you can include the .o file as an argument to ghci and it'll load it too
00:55:13 <Axman6> but I may be misremembering
00:55:53 <ocramz> Axman6: there seems to be a problem with that approach, with replicated symbols
00:58:10 <itsMontoya> For getting every other item, I was planning on using this as a base
00:58:11 <itsMontoya> http://stackoverflow.com/a/2028218/886872
00:58:29 <itsMontoya> Any thoughts about a better way to approach?
01:01:49 <liste> itsMontoya that one looks good
01:03:12 <dramforever> > map head $ unfoldr (Just . splitAt 20) [100,200..] -- my version, assumes infinite list
01:03:15 <lambdabot>  [100,2100,4100,6100,8100,10100,12100,14100,16100,18100,20100,22100,24100,261...
01:03:49 <itsMontoya> hmm
01:03:58 <ClaudiusMaximus> ocramz: try ghci -isrc perhaps, but i never used inline-c
01:04:02 <itsMontoya> My list will be finite
01:04:11 <itsMontoya> Couldn't match expected type ‘Int -> [a0] -> [a0]’  with actual type ‘[Integer]’
01:04:12 <itsMontoya> :/
01:05:13 <liste> itsMontoya where?
01:05:42 <dramforever> hmm...there's no safeSplitAt :: Int -> [a] -> Maybe ([a], [a])
01:05:49 <pingu> itsMontoya: I'd foldr personally
01:06:08 <pingu> but you need state
01:06:38 <itsMontoya> https://gist.github.com/itsmontoya/63f01b460e0c6ceab9ba
01:06:48 <dramforever> pingu: wow that's interesting, though a foldl looks more feasible
01:06:59 <itsMontoya> pingu: Interesting. My end goal is to double every other value in my list
01:07:11 <pingu> dramforever: you can't foldl on an infinite list, unfortunately.
01:07:11 <itsMontoya> [1,2,3,4] -> [2, 2, 6, 4]
01:07:31 <dramforever> pingu: why?
01:07:40 <MP2E> doubleEveryOther has a type signature that does not match the number of arguments expected
01:07:50 <zipper> Say I want to kill a thread that has been started via forkIO and I have the threadId from forkIO what can I do?
01:07:51 <MP2E> it looks like it expects one thing of [Integer] but I see 3 arguments!
01:08:04 <zipper> Mind you this thread holds on to a port number
01:08:21 <zipper> It's starting a web server,
01:08:22 <itsMontoya> MP2E, it might just be my lack of understanding of the syntax
01:08:34 <itsMontoya> MP2E: I will be inputing something like [1,2,3,4]
01:08:42 <pingu> dramforever: you can, go for it ;)
01:08:43 <zipper> I want to kill it and start another thread or is there a way to respawn it?
01:08:49 <pingu> dramforever: you'll just never terminate.
01:09:01 <dramforever> pingu: okay I know...
01:09:03 <zipper> Can you guys "hear" me?
01:09:07 <dramforever> yes
01:09:21 <MP2E> itsMontoya: in this case 'doubleEveryOther every n xs = ...' means that every, n and xs are each bound to a seperate argument passed to the function
01:09:23 <pingu> dramforever: so that's why you can't fold on an infinite list?
01:09:35 <itsMontoya> MP2E: OH, whoops :(
01:09:42 <pingu> *foldl*
01:09:46 <dramforever> pingu: arrrg
01:09:49 <itsMontoya> MP2E: So how would I iterate through my single list?
01:09:50 <dramforever> zipper: http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Exception-Base.html#v:throwTo
01:10:03 <dramforever> I don't know if it's what you want
01:10:15 <dramforever> zipper: what do you mean by respawn?
01:10:16 <ocramz> ClaudiusMaximus: what does the -i flag do? include directory?
01:10:30 <zipper> dramforever: I don't even know :(
01:10:45 <zipper> Like restart the thread from the total beginning.
01:10:46 <ClaudiusMaximus> ocramz: yeah - if you have src/A.hs and src/B.hs, ghci -isrc src/A.hs will let A import B successfully
01:11:03 <dramforever> zipper: Is Control.Exception.Base.throwTo (Base???) okay?
01:11:08 <liste> itsMontoya doubling every other value can be much simpler th
01:11:14 <liste> an that
01:11:17 <itsMontoya> map (\x -> if p x then f x else x) xs ?
01:11:26 <dramforever> if you are using something like bracket then an exception won't matter too much
01:11:32 <ocramz> ClaudiusMaximus: anyway, it was a combination: -isrc and explicitly linking the object file obtained by the inline-c generated C :) changing A SINGLE LINE ftw (it should be a Haskell meme by now)
01:11:44 <ocramz> ClaudiusMaximus: thanks :)
01:11:47 <ClaudiusMaximus> ocramz: :)
01:11:50 <jle`> oh is it already released :o
01:12:20 <zipper> dramforever: I don't know yet but I think so...
01:12:33 <dramforever> zipper: wait wai
01:12:34 <dramforever> wait
01:12:44 <zipper> Yeah
01:12:45 <dramforever> I think there's a function called killThread
01:12:56 <liste> itsMontoya how about "doubleEveryOther (x:y:xs) = ..." ?
01:13:06 <dramforever> zipper: yeah, in Control.Concurrent
01:13:12 <lpaste> MP2E pasted “doubleEveryOther example” at http://lpaste.net/134021
01:13:22 <ClaudiusMaximus> zipper: killThread t  is  throwTo t ThreadKilled  or something along those lines
01:13:24 <dramforever> oh and throwTo is right below killThread here: http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Concurrent.html#v:killThread
01:13:24 <zipper> Let me look for it awesome
01:14:23 <MP2E> itsMontoya: just posted a solution, mine uses a combination of pattern matching and the drop function from prelude, though liste is right in that you could use (x:y:xs) and just not use y when reconstructing the new list
01:14:40 <liste> MP2E that one drops values
01:14:48 <MP2E> ah
01:14:52 <MP2E> oops :v
01:14:56 <itsMontoya> MP2E: Was just looking at your example :). About to try out liste's righ tnow
01:15:13 <dramforever> other languages: I write it with foo instead of bar because it's faster (example: foo = epoll, bar = threads)
01:15:24 <dramforever> haskell: Why? Isn't bar faster?
01:15:28 <lpaste> MP2E revised “doubleEveryOther example”: “No title” at http://lpaste.net/134021
01:15:40 <MarcelineVQ> cause you gotta reach for b
01:15:41 <MP2E> there :P (I think)
01:15:50 <ClaudiusMaximus> is there some library that does thread groups? not sure what to call it - i want to fork something that does a load of forks itself, but when the time comes i want to be able to kill all the threads at once without any hassle
01:16:28 <mauke> ClaudiusMaximus: async maybe?
01:16:41 <dramforever> ClaudiusMaximus: Set ThreadId, maybe?
01:17:03 <itsMontoya> This works perfectly, and I think I'm understanding how it works too
01:17:07 <dramforever> sure, mauke's might be better
01:18:14 <ClaudiusMaximus> mauke: looks perfect, thanks
01:18:20 <liste> itsMontouya MP2E that one's missing a case, though
01:18:26 <itsMontoya> So this part: (x:y:xs) - Is saying "I have x, y, and the rest". Then x*2 : y : doubleEveryOther xs is saying "Multiply x by 2 and prepend, prepend y, perform doubleEveryOther on the rest
01:18:34 <lpaste> MP2E revised “doubleEveryOther example”: “doubleEveryOther example (fix for odd number of elements)” at http://lpaste.net/134021
01:18:56 <MP2E> just caught that !
01:19:05 <MP2E> yeah if it were fed an odd number of elements it would crash out
01:20:31 <itsMontoya> Did I get the general explanation correct?
01:20:36 <itsMontoya> In terms of what the code is doing
01:20:36 <MP2E> yep exactly
01:20:55 <itsMontoya> Ok fantastic, I really appreciate your time guys. This is really helping me to understand this all
01:21:00 <itsMontoya> Without blindly copy-pasting
01:24:51 <pingu> Isaacary: so what was your goal at the end of this? to have a function that doubles every second element?
01:25:57 <pingu> *apologies* I meant itsMontoya
01:26:00 * dramforever is thinking about everyNth :: Int -> Traversal a b [a] [b]
01:26:20 * dramforever just learned a great deal of lens
01:26:22 <pingu> is that a thing somewhere?
01:26:28 <pingu> ah, of course
01:26:31 <dramforever> pingu: dunno
01:26:34 <pingu> yes, it would be pretty easy with lens
01:26:49 <dramforever> pingu: except that there isn't such a traversal
01:27:19 <pingu> You don't need a traversal anyway, it's doable with something much weaker I think.
01:27:36 <pingu> e.g. indices can help
01:27:44 <itsMontoya> pingu: Yea trying to double every other value 
01:27:56 <itsMontoya> pingu: Following the HW on cis194
01:28:16 <pingu> Right. Dunno if lenses would be accepted if it were a real course :P
01:28:29 <itsMontoya> https://gist.github.com/itsmontoya/63f01b460e0c6ceab9ba
01:28:36 <dramforever> pingu: it's not easier to write with lens
01:28:43 <dramforever> but more interesting
01:28:43 <itsMontoya> This is what I have so far
01:29:04 <dramforever> also I think it's definitely a traversal
01:29:30 <pingu> dredozubov: the way I'd do it with lens involves "indices"
01:29:35 <pingu> i.e. indices even
01:29:50 <dramforever> hmm...haven't heard of it
01:30:01 <itsMontoya> pingu: What do you think of the implementation?
01:30:03 <dramforever> also double check nicks before hitting enter
01:30:22 <pingu> dramforever: yeah, thanks.
01:30:27 <pingu> my auto-complete is doing something weird.
01:30:59 <dramforever> > [1..] & indices even %~ (*2)
01:31:01 <lambdabot>      Couldn't match type ‘[i0]’
01:31:01 <lambdabot>                     with ‘(Integer -> Identity Integer) -> [Integer] -> Ident...
01:31:01 <lambdabot>      Expected type: Setting (->) [Integer] b Integer Integer
01:31:24 <dramforever> failed...
01:31:29 <Axman6> :(
01:31:44 <pingu> :) You are close.
01:31:48 <pingu> yes, that's the idea.
01:32:19 <itsMontoya> I want doubleEveryOther to do it's work + doubleEveryOtherRev, but I couldn't figure out a clean way to do it
01:32:37 <Axman6> :t indices even
01:32:38 <lambdabot>     Couldn't match expected type ‘Array i e0’
01:32:39 <lambdabot>                 with actual type ‘Integer -> Bool’
01:32:39 <lambdabot>     Probable cause: ‘even’ is applied to too few arguments
01:32:45 <pingu>  > [1..] & traversed . indices even %~ (*2)
01:32:46 <itsMontoya> doubleEveryOther is supposed to start at the last item, and do that and every other item
01:33:41 <dramforever> > [1..] & itraversed . indices even %~ (*2)
01:33:43 <lambdabot>      Couldn't match expected type ‘(Integer -> Identity Integer)
01:33:44 <lambdabot>                                    -> p0 Integer (Identity b)’
01:33:44 <lambdabot>                  with actual type ‘[i0]’
01:34:07 <dramforever> forget about it...too difficult
01:35:09 <Axman6> > foldr (\h et -> either (Right . (h*2:)) (Left . (h:)) (Left []) [1,2,3,4,5]
01:35:12 <lambdabot>  <hint>:1:76:
01:35:12 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
01:35:28 <Axman6> > foldr (\h et -> either (Right . (h*2:)) (Left . (h:))) (Left []) [1,2,3,4,5]
01:35:30 <lambdabot>      Couldn't match expected type ‘Either [a] [a] -> Either [a] [a]’
01:35:31 <lambdabot>                  with actual type ‘Either [t0] b0’
01:35:31 <lambdabot>      Possible cause: ‘Left’ is applied to too many arguments
01:35:43 <Axman6> > foldr (\h et -> either (Right . (h*2:)) (Left . (h:) et)) (Left []) [1,2,3,4,5]
01:35:45 <lambdabot>      Couldn't match expected type ‘b -> a’ with actual type ‘[a1]’
01:35:45 <lambdabot>      Relevant bindings include
01:35:45 <lambdabot>        et :: Either [a1] b -> Either a [a1] (bound at <interactive>:1:11)
01:35:49 <Axman6> bleh
01:36:19 <pingu> Axman6: Axman6 yeah, I was thinking a fold to
01:36:23 <pingu> but in a less clever way
01:36:29 <dramforever> C O D E   G O L F   D A Y
01:36:34 <itsMontoya> I can't do something like this right? doubleEveryOther (xs:y:x) = doubleEveryOther xs : y : x * 2
01:36:41 <Axman6> > foldr (\h et -> either (Right . (h*2:)) (Left . (h:)) et) (Left []) [1,2,3,4,5]
01:36:43 <lambdabot>  Right [2,2,6,4,10]
01:36:58 <dramforever> itsMontoya: no, just like 1-2 isn't the same as 2-1
01:37:03 <itsMontoya> Ahh ok
01:37:07 <itsMontoya> Yea I was getting a compie error
01:37:21 <Axman6> :t (:)
01:37:22 <lambdabot> a -> [a] -> [a]
01:37:30 <Axman6> the thing on the left is always a list
01:37:33 <Axman6> uh, right
01:37:41 <itsMontoya> Ah k
01:37:47 * Axman6 just either Right Left'd his own brain
01:38:15 <itsMontoya> So is https://gist.github.com/itsmontoya/63f01b460e0c6ceab9ba the other way to approach it using the method I'm currently working with? (I saw Axman6 came up with some alternatives)
01:39:26 <Axman6> itsMontoya: that might not work, depending on whether you have an even or odd number of elements
01:39:38 <pingu> > take 10 . fst . foldr (\x (xs,b) -> if b then ((x * 2):xs,not b) else (xs, not b)) ([], True) $ [1,2,3,4,5]
01:39:41 <lambdabot>  [2,6,10]
01:40:08 <itsMontoya> *Main> doubleEveryOtherRev [1,2,3,4]
01:40:08 <itsMontoya> [1,4,3,8]
01:40:08 <itsMontoya> *Main> doubleEveryOtherRev [1,2,3,4,5]
01:40:10 <itsMontoya> [2,2,6,4,10]
01:40:31 <pingu> heh. They should probably get the same answers ;)
01:40:49 <itsMontoya> What? Looks like it's working to me
01:41:09 <itsMontoya> It starts at right, doubles the first number, then doubles every other
01:41:23 <pingu> Isaacary: and yes, you can do it with something stupidly simple like you suggested.
01:42:07 <itsMontoya> Stupidly simple sounds good to me :)
01:43:18 <dramforever> pingu: the lens version is still the most "abstract nonsense" one
01:43:46 <pingu> dramforever: That's pretty subjective, I think.
01:44:11 <dramforever> pingu: well, (at least to me) it uses a lot of abstract nonsense
01:45:10 <itsMontoya> I'm laughing at your guys implementations. So over my head
01:45:15 <itsMontoya> Very clever though :)
01:46:47 <pingu> They're really not ;)
01:46:56 <pingu> the cleverest is something simple:
01:47:02 <pingu> doubleEveryOther' (x1:_:xs) = x1 * 2 : doubleEveryOther' xs
01:47:09 <pingu> doubleEveryOther' a = a
01:47:13 <pingu> that is also the most readable
01:47:25 <dramforever> pingu: no you shouldn't throw that away
01:48:08 <pingu> oh okay then put it in ;)
01:48:30 <dramforever> pingu: when things get more complex (like doubleEveryBSTNode or even doubleEverySpreadsheetCell), lens can get really powerful
01:48:46 <dramforever> doubleEverySpanElement
01:51:15 <backchat> hello all, should j and a be swapped in the right most term from  tofu :: j a -> t a j   (see http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass)
01:52:47 <Axman6> I would guess so
01:53:22 <copycat> help..
01:53:32 <copycat> i've spent 2 days trying to quickstart with yesod
01:53:42 <copycat> i want to nuke my install and start from scratch
01:53:51 <copycat> is there any easy way to do so?
01:53:53 <Axman6> are you using sandboxes?
01:53:58 <copycat> yeap
01:54:09 <pingu> I don't remember learn you a haskell going into kinds and Tofu, this is impressive.
01:54:22 <Axman6> then cabal sandbox delete; cabal sandbox init; cabal install --only-dependencies 
01:54:38 <supki> backchat: why?
01:55:36 <itsMontoya> pingu: So since I need my y element, I keep it right?
01:56:02 <pingu> itsMontoya: that sounds quite logical
01:56:28 <pingu> You could throw it on the floor.
01:56:46 <pingu> But then you might need it, and you said you need it.
01:57:02 <itsMontoya> pingu: Did I approach the reverse part ok? Or is there a way I could do it within the same fn?
01:57:16 <pingu> I shall look
01:57:20 <xj54y> Why do so many expect others to be extrmely fast at learning complicated things?
01:57:46 <xj54y> (or extremely fast at producing complicating things..)
01:58:13 <pingu> itsMontoya: heh.
01:58:17 <pingu> We can totally do that better
01:58:19 <Axman6> xj54y: because they've forgotten how long it took them the first time
01:58:24 <itsMontoya> pingu: I'm all ears! :)
01:58:37 <itsMontoya> First day with Haskell, sorry :(
01:58:55 <pingu> try: doubleEveryOtherRev = fmap join reverse doubleEveryOther
01:59:17 <Axman6> :(
02:00:44 <pingu> that's totes not it ;) I think I should sleep.
02:00:59 <xj54y> Axman6, I mean, even in work environments, the demand seems completely unnatural, though I suppose none can work if they cannot produce fast enough
02:01:23 <itsMontoya> pingu: But within doubleEveryOther, there isn't a way to specify the list reversed?
02:01:36 <pingu> itsMontoya: it's probably a bit weird that you're reversing twice anyway, to be honest.
02:01:51 <itsMontoya> pingu: Totally, I can understand that
02:01:54 <pingu> you should probably just work out how to make the function you're wrapping with that work how you like.
02:02:11 <itsMontoya> Because I get the list as [1,2,3,4] and I need to start at the back
02:02:19 <itsMontoya> And make it [1,4,3,8]
02:02:30 <gpampara> :t join
02:02:31 <lambdabot> Monad m => m (m a) -> m a
02:03:14 <pingu> :t join dimap reverse
02:03:16 <lambdabot> Profunctor p => p [a] [a] -> p [a] [a]
02:03:32 <pingu> > join dimap reverse id "ponies!"
02:03:34 <lambdabot>  "ponies!"
02:03:47 <pingu> > join dimap reverse (++"!") "ponies!"
02:03:49 <lambdabot>  "!ponies!"
02:03:49 <Axman6> itsMontoya: hmm, I seem to remember someone showing you how to get those digits in the [4,3,2,1] order, that might help ;)
02:04:00 <itsMontoya> Axman6: Oh I already have that :)
02:04:05 <itsMontoya> I just don't have the part where it's doubling
02:04:07 <edwardk> :t backwards
02:04:08 <lambdabot> (Profunctor p, Profunctor q) => Optical p q (Control.Applicative.Backwards.Backwards f) s t a b -> Optical p q f s t a b
02:04:16 <itsMontoya> The homework asks for the separate functions
02:04:19 <edwardk> so you can do the lens solution with that shoved in
02:04:53 <itsMontoya> http://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
02:05:02 <itsMontoya> Axman6: I'm just going down the list, exercise by exercise
02:05:08 <edwardk> > [1..4] & backwards (traversed. Lens.indices even) *~ 2
02:05:12 <lambdabot>  [2,2,6,4]
02:05:19 <itsMontoya> Wow
02:05:22 <itsMontoya> That's clean
02:05:29 <edwardk> > [1..4] & backwards (traversed. Lens.indices odd) *~ 2
02:05:32 <lambdabot>  [1,4,3,8]
02:05:32 <Axman6> itsMontoya: is there anything telling you you need [1,2,3,4] and not [4,3,2,1]? it makes life a lot easier for you if there's not =)
02:05:37 <edwardk> something like that?
02:05:52 <edwardk> it'd just be 'indices' but lambdabot has a conflicting 'indices' in scope
02:05:53 <Axman6> edwardk: might be a bit much for day 2 learning haskell =)
02:06:02 <itsMontoya> edwardk: That's perfect, reading it now so I understand it fully
02:06:03 <edwardk> Axman6: heh true
02:06:09 <itsMontoya> Axman6: Yea, it requests a normal and reversed version
02:06:14 <Axman6> itsMontoya: I would bet you won't :P
02:06:22 <edwardk> itsMontoya: think of that line of code as something to aspire to understanding in full and come back to it later =)
02:06:22 <Axman6> itsMontoya: ah ok
02:06:34 <itsMontoya> toDigits :: Integer -> [Integer]
02:06:34 <itsMontoya> toDigitsRev :: Integer -> [Integer]
02:06:50 <itsMontoya> First one wants [1,2,3,4] and the second wants [4,3,2,1]
02:07:05 <edwardk> given one you can get the other with a simple reverse
02:07:15 <itsMontoya> So I actually get the [4,3,2,1] first (per the suggestion of liste I believe). To get [1,2,3,4] I just reverse the first result :)
02:07:48 <itsMontoya> > [1,2,3,4] & backwards (traversed. Lens.indices odd) *~ 2
02:07:52 <lambdabot>  [1,4,3,8]
02:08:00 <itsMontoya> > [1,2,3,4, 5] & backwards (traversed. Lens.indices odd) *~ 2
02:08:03 <lambdabot>  [1,4,3,8,5]
02:08:09 <itsMontoya> Oh hmm
02:08:37 <edwardk> did i build that wrong?
02:08:38 <itsMontoya> That should be 2, 2, 6, 4, 10
02:08:39 <edwardk> hrmm
02:08:59 <itsMontoya> My current implementation gives me the right results, but I'm reversing twice
02:09:01 <itsMontoya> Which is awkward 
02:09:34 <Axman6> I quite liked my version using two catamorphisms eariler
02:09:46 <itsMontoya> I'll go back and look at it!
02:09:51 <itsMontoya> I think it flew right over my head
02:10:03 <edwardk> > [1,2,3,4,5] & Lens.indexing (backwards traverse) . Lens.indices even *~ 2
02:10:03 <pingu> Isaacary: It's just an off by one.
02:10:05 <lambdabot>  [2,2,6,4,10]
02:10:11 <edwardk> > [1,2,3,4] & Lens.indexing (backwards traverse) . Lens.indices even *~ 2
02:10:13 <lambdabot>  [1,4,3,8]
02:10:14 <pingu> ^^
02:10:27 <pingu> itsMontoya: *correction*
02:10:32 <Axman6> pingu: watch those tab completes, you're worse than me :P
02:10:40 <edwardk> you need to build a new 'count' hence indexing on backwards traverse, rather than use the backwards of indexing traverse
02:10:43 <pingu> Yeah... My client is being very odd.
02:10:48 <pingu> I shall turn it off and on again.
02:10:51 <itsMontoya> edwardk: Ah ok
02:10:55 <itsMontoya> Axman6: Do you like that approach?
02:11:42 <itsMontoya> Axman6: This is the suggestion you had, correct? > foldr (\h et -> either (Right . (h*2:)) (Left . (h:)) et) (Left []) [1,2,3,4,5]
02:12:19 <copycat> axman6: after i did "cabal sandbox delete; cabal sandbox init; cabal install --only-dependencies "
02:12:31 <copycat> i now have this: "new.hs: homepage.md: openFile: does not exist (No such file or directory)"
02:12:47 <copycat> i'm pretty sure i should delete everything and start from scratch :'(
02:12:56 <itsMontoya> > traverse [1,2,3]
02:12:58 <lambdabot>      Couldn't match expected type ‘a -> f b’
02:12:58 <lambdabot>                  with actual type ‘[Integer]’
02:12:58 <lambdabot>      In the first argument of ‘traverse’, namely ‘[1, 2, 3]’
02:13:08 <itsMontoya> > traverse $ [1,2,3]
02:13:09 <lambdabot>      Couldn't match expected type ‘a -> f b’
02:13:10 <lambdabot>                  with actual type ‘[Integer]’
02:13:10 <lambdabot>      In the second argument of ‘($)’, namely ‘[1, 2, 3]’
02:13:20 <pingu> heh. itsMontoya you should probably start by reading the traverse typeclass
02:13:28 <itsMontoya> I should hahaha
02:13:29 <pingu> It's pretty useful.
02:13:41 <itsMontoya> I am looking at edwards approach and just seeing if I can try to make light of it
02:13:44 <itsMontoya> I'll do that now
02:16:06 <edwardk> itsMontoya: lens uses things of the form "(a -> f b) -> s -> f t"  to do lots of weird things
02:16:15 <edwardk> traverse has that shape
02:16:20 <edwardk> :t backwards traverse
02:16:22 <lambdabot> (Applicative f, Traversable t) => Optical (->) (->) f (t a) (t b) a b
02:16:32 <edwardk> that has that shape if you expand "Optical"
02:16:33 <edwardk> etc.
02:18:43 <edwardk> indexing changes out and lets you replaces (a -> f b) with Indexing Int a b  -- which lets you use it as (Int -> a -> f b) -- to get a current index, then indices uses that to select out a subset of the indices, finally x & traversal *~ value -- uses that shape to multiply all the targets of the traversal in x by some value
02:18:55 <edwardk> that is a bit hand-wavy
02:19:01 <Axman6> copycat: what is homepage.md?
02:19:02 <edwardk> but it captures the relevant details
02:19:33 <copycat> axman6: uhm, i'm not sure..
02:19:36 <itsMontoya> edwardk: Yea that actually makes sense from a "how it works perspective" 
02:19:44 <itsMontoya> edwardk: I have to include some libs to use that though, correct?
02:19:50 <Axman6> copycat: what's new.hs?
02:19:53 <edwardk> cabal install lens
02:19:59 <edwardk> and it uses Control.Lens
02:20:07 <Axman6> day 2 is not the =day to be starting with lens :(
02:20:11 <itsMontoya> And traverse?
02:20:12 <Axman6> s/=/
02:20:23 <edwardk> traverse is re-exported by Lens but is in Data.Traverasble
02:20:26 <edwardk> er Traversable
02:20:29 <copycat> its the haskell script for some web site
02:20:51 <Axman6> copycat: well it looks like it's trying to open some markdown file which doesn't exist
02:20:55 <edwardk> ^- i don't recommend turning in lens code for homework, except as a joke or footnote to show off to the professor
02:21:34 <itsMontoya> OH
02:21:46 <itsMontoya> Ok, so maybe I should use Axman6's example?
02:21:48 <copycat> axman6: but its there..
02:21:57 <Axman6> itsMontoya: maybe you should use code you understand ;)
02:22:20 <edwardk> Axman6++
02:22:31 <itsMontoya> Axman6: Bahahah! So true, so maybe I should stick to what I have :)
02:22:39 <Axman6> copycat: well, see where in the code it's looking for homepage.md and see why it's not finding it
02:22:55 <itsMontoya> edwardk: This is what I'm working with at the moment: https://gist.github.com/itsmontoya/63f01b460e0c6ceab9ba
02:25:16 <bennofs> itsMontoya: if you want to avoid the reversing twice you could start like this: first generate a list [Bool] that contains True if you want to double the element at that position, False otherwise. Then use zipWith (\x shallDouble -> ....) xs thatList
02:25:48 <itsMontoya> hmm
02:26:07 <itsMontoya> I'm going to write that down in my notes and play around with that approach more tomorrow
02:26:21 <bennofs> note that thatList may even be infinite, since zipWith takes the shorter list
02:26:21 <Axman6> bennofs: that's made more tricky because which elements to reverse depends on whether the list has even or odd length
02:26:39 <bennofs> Axman6: oops, right...
02:27:10 <Axman6> which is why my right fold version worked for all lists, but can't produce values lazily (I think...)
02:27:13 <Axman6> yes
02:27:49 <bennofs> Axman6: right, you'd need to at least call 'length', so you need to do a whole traversal of the list just to produce the first element :/
02:28:07 <pingu> itsMontoya: if you really want your code to be better, you probably want to start with the comment at the beginning. It's pretty vague. In what order? It could mean we're just using enum to build a list.
02:28:09 <Axman6> well, you don't need length, but you do need to traverse everything
02:29:05 <Axman6> > foldr (\h (l,r) -> (2*h:r,h:l) ([],[]) [1,2,3,4]
02:29:07 <lambdabot>  <hint>:1:49:
02:29:08 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
02:29:14 <Axman6> > foldr (\h (l,r) -> (2*h:r,h:l)) ([],[]) [1,2,3,4]
02:29:16 <lambdabot>  ([2,2,6,4],[1,4,3,8])
02:29:26 <itsMontoya> pingu: I'll take a look in a bit and see if I can clear it up better. I'm just going through the exercises and making sure I fulfill each fn requirement
02:29:35 <Axman6> > snd  foldr (\h (l,r) -> (2*h:r,h:l)) ([],[]) [1,2,3,4,5]
02:29:37 <lambdabot>      Couldn't match expected type ‘(a0,
02:29:38 <lambdabot>                                     (Integer -> ([Integer], [Integer]) -> ([I...
02:29:38 <lambdabot>                                     -> ([t1], [t2]) -> [Integer] -> t)’
02:29:41 <Axman6> > foldr (\h (l,r) -> (2*h:r,h:l)) ([],[]) [1,2,3,4,5]
02:29:42 <lambdabot>  ([2,2,6,4,10],[1,4,3,8,5])
02:30:36 <pingu> itsMontoya: because if saying what I'm assuming it's saying. My preferred approach to this whole ordeal would be:
02:30:43 <pingu> https://hackage.haskell.org/package/digits-0.2/docs/src/Data-Digits.html#digits
02:30:52 <pingu> import Data.Digits
02:30:52 <itsMontoya> Hahaha
02:30:59 <itsMontoya> Well I'm trying to do as much as possible without imports
02:31:08 <itsMontoya> Because I'm sure the HW assignment just wants it as simple as possible
02:31:12 <itsMontoya> I could be wrong though
02:31:12 <lamefun> Are tasks implementable in Haskell?
02:31:39 <pingu> itsMontoya: It's "simplest" to trust the library, you could argue.
02:31:48 <itsMontoya> Very true
02:31:49 <Axman6> lamefun: what do you mean by tasks? do you mean threads?
02:31:54 <itsMontoya> But the course hasn't gotten into imports yet
02:31:56 <bennofs> pingu: it won't be a good idea for homework i'd assume ...
02:32:34 <lamefun> Axman6, tasks that run in a separate thread and provide feedback to the main thread (for progress bar, etc.)
02:33:03 <Axman6> lamefun: sure. haskell has about the best concurrency primitives of pretty much any language I've used
02:33:55 <Axman6> they're very high performance too, you can happily have hundreds of thousands of threads without having to worry too much
02:34:14 <pingu> lamefun: haskell has full multithreading as well as the (faster) internal threading.
02:35:26 <merijn> lamefun: Haskell threads are comparable to Erlang processes/go routines, in that it's trivial to have like 100k threads
02:36:05 <itsMontoya> This is the last one I'm going to tackle tonight.. getting an error
02:36:06 <itsMontoya> https://gist.github.com/itsmontoya/63f01b460e0c6ceab9ba
02:36:55 <itsMontoya> OH wait... for map I'm passing integer
02:37:02 <itsMontoya> when that fn is requesting [integer]
02:37:07 <Axman6> I don't think doubleEveryOther does what it's supposed to
02:37:31 <Axman6> if it's given a list of length 1 it doubles the first element, but if its longer, actually, no, I'm wrong
02:37:34 <Axman6> whoops
02:37:42 * hackagebot ghcid 0.4 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.4 (NeilMitchell)
02:38:41 <lamefun> Is there a ready-made library for tasks with progress indication?
02:38:50 <Axman6> doubleEveryOtherRev almost certainly is doing much more than it needs to though. the first two cases are redundant (and one is wrong)
02:39:06 <Axman6> lamefun: have you tried searching for one?
02:39:07 <pingu> Axman6: I find it amusing how vague it is to say "write a function that doubles every other"
02:39:10 <Axman6> I believe there is
02:39:24 <pingu> what is an "other"?!
02:39:49 <Axman6> pingu: yes, thought there are more restrictions in the actual specification of the homework iirc
02:39:52 <Axman6> thought*
02:39:54 <Axman6> a,mbasdf,jbasfd
02:39:58 <Axman6> though*
02:40:01 <Axman6> -_-
02:40:04 * Axman6 needs a nap
02:42:58 <fnord__> hi, I'm currently implementing a function plotter for fun. I use Haskell functions to represent the functions I want to plot, i.e. \x -> x*x, so if I want to plot something, I write a script using my plotter library to supply the functions and run that script.
02:43:00 <fnord__> I was wondering, whether it is possible to parse those functions at runtime from strings, so I'm looking for something like "readFunc :: String -> Maybe (a -> b)", which can parse arbitrary haskell functions and integrates them into the current program. Is this possible?
02:44:10 <fnord__> err, readFunc would of course have to return an IO action
02:44:23 <fnord__> (I guess)
02:44:54 <bennofs> fnord__: you can load haskell code at runtime (like ghci does) using hint
02:44:56 <bennofs> @hackage hint
02:44:56 <lambdabot> http://hackage.haskell.org/package/hint
02:45:14 <Axman6> fnord__: not necessarilly
02:45:22 <fnord__> bennofs: oh cool! I'll give it a look, thanks :)
02:47:36 <itsMontoya> AH HA
02:47:38 <itsMontoya> I GOT IT
02:48:04 <itsMontoya> https://gist.github.com/itsmontoya/63f01b460e0c6ceab9ba
02:52:04 <itsMontoya> What do you guys think? :)
02:53:55 <pingu> Err, it's still pretty weird and confusing.
02:54:04 <bennofs> looks ok to me
02:54:40 <Axman6> itsMontoya: you don't need to pattern match on every list to check if there's an empty list btw
02:55:00 <itsMontoya> Oh ok!
02:55:04 <itsMontoya> I'll look at fixing that
02:55:04 <Axman6> actually, now I think about it where you are doung it it is fine
02:55:11 <Axman6> don't, it's fine =)
02:55:13 <bennofs> itsMontoya: doubleEvee
02:55:17 <itsMontoya> Oh ok
02:55:25 <bennofs> itsMontoya: doubleEveryOtherRev does not need 3 clauses
02:55:31 <bennofs> itsMontoya: one is enough
02:55:44 <itsMontoya> Fair enough, I was looking at that
02:55:47 <Chousuke> isn't toSingleDigits = map toDigits 
02:55:50 <itsMontoya> Because doubleEveryOther does the looks
02:55:53 <bennofs> itsMontoya: and then you can even make it pointfree :)
02:56:05 <Axman6> Chousuke: concatMap
02:56:14 <bennofs> itsMontoya: toSingleDigits can improved with concatMap
02:56:16 <Chousuke> oh, right.
02:56:27 <itsMontoya> Ah ok, I'll look into that too
02:56:33 <itsMontoya> *writing notes*
02:56:52 <bennofs> itsMontoya: divideByTenList can be made pointfree (you can eliminate the $ n and the n argument)
02:57:18 <pingu> itsMontoya: I'd seriously look at https://hackage.haskell.org/package/digits-0.2/docs/src/Data-Digits.html#digits
02:57:23 <pingu> if this is indeed what you're doing.
02:57:28 <pingu> taking an approach more like that would surely be nicer.
02:57:29 <bennofs> itsMontoya: 
02:57:37 <bennofs> pingu: it's homeork
02:57:42 <itsMontoya> pingu: I'll look into it for future things. I'm just trying to avoid import since the course hasn't taught it yet
02:57:43 <bennofs> s/homork/homework
02:58:06 <pingu> bennofs: I understand that, but, isn't it better to learn how to do things better?
02:58:23 <bennofs> itsMontoya: hlint at http://lpaste.net/5102711569041588224 found two more things
02:58:57 <itsMontoya> bennofs: Looking now
02:59:11 <pingu> itsMontoya: I'm not saying import the thing, I'm saying look at how it's done in that library, and see if you can simplify your version more.
02:59:19 <itsMontoya> OH
02:59:23 <itsMontoya> pingu: Great idea
02:59:23 <bennofs> pingu: well, if you're just learning haskell, reimplementing standard functions can be a good excercise. but that is of course defeated if you just use the standard implementation :)
02:59:55 <pingu> bennofs: sure, but he's already re-implemented it, and has spent a while trying to improve it.
03:00:10 <pingu> I'd think this is the best time to look at the better implementation
03:00:21 <bennofs> pingu: right
03:00:34 <itsMontoya> bennofs: I'm having trouble finding the notes/changes
03:00:38 <itsMontoya> Maybe I'm just sleep deprived
03:00:54 <bennofs> itsMontoya: at the very bottom, there are 2 "warnings"
03:01:24 <itsMontoya> Oh! ok, I don't need the $ on line 19
03:01:55 <itsMontoya> Then line 36, use foldr?
03:02:07 <bennofs> itsMontoya: although I just noticed that the suggestion to use foldr for toSingleDigits is kind of weird. If you use foldr, then run hlint again, it will probably tell you to use concatMap :)
03:02:23 <itsMontoya> Hahaha
03:02:34 <itsMontoya> I'll have to read into concatMap more tomorrow
03:02:51 <Fylwind> sometimes I wish Maybe == Either ()
03:03:56 <bennofs> itsMontoya: https://wiki.haskell.org/Pointfree might also apply
03:04:02 <pingu> Fylwind: it totally does!
03:04:08 <pingu> :t hush
03:04:09 <lambdabot> Not in scope: ‘hush’
03:04:22 <pingu> http://hackage.haskell.org/package/errors-1.2.1/docs/Control-Error-Util.html
03:04:24 <itsMontoya> bennofs: Awesome, adding it to my notes for the morning :). Lots of reading to do for me hehe
03:04:46 <Fylwind> I mean literally, as in type Maybe a = Either () a
03:05:24 <pingu> So you'd want them to *be* the same type?
03:05:36 <pingu> Then surely teach everyone to use Either () a
03:05:46 <pingu> And we don't need to confuse everything with this distinct Maybe thing.
03:06:24 <pingu> A damned fine plan! I suspect it will run afoul when all of the code breaks.
03:07:17 <bennofs> Fylwind: with pattern synonyms, that could work. However, I think you sometimes want different instances for Either / Maybe
03:07:52 <Fylwind> bennofs: when do the instances differ?
03:08:21 <bennofs> Fylwind: I don't have a particular instance, just noting that it might happen
03:19:27 <pingu> Fylwind: the instances for starters
03:19:49 <pingu> You'd need to make sure they are all the same, for everyone's code.
03:19:53 <liste> I guess it's impossible to have a MonadPlus instance for Either () without FlexibleInstances?
03:20:18 <pingu> TypeSynonymInstances would fix the instance problem.
03:20:21 <Fylwind> pingu: I'm not saying it should happen for Haskell _today_, that ship sailed a looong time ago
03:20:43 <Fylwind> pingu: I just think it would've been more elegant if Haskell did not have a Maybe type to begin with and just used Either () instead
03:21:02 <pingu> Fylwind: sure, but then you're just programming with generic types.
03:21:20 <Fylwind> both Maybe and Either are pretty generic
03:21:31 <Fylwind> but nonetheless, they are used a lot for error handling
03:21:35 <pingu> You can turn an Either into a Maybe, but not a Maybe into an Either.
03:21:42 <pingu> Fylwind: I mean generic types.
03:21:54 <pingu> uh, badly worded
03:22:09 <pingu> https://wiki.haskell.org/GHC.Generics
03:33:00 <bitonic> :t maybe (Left ()) Right
03:33:02 <lambdabot> Maybe b -> Either () b
03:33:06 <bitonic> pingu: ^^^
03:37:42 <pingu> bitonic: sure, but not the same as Maybe b -> Either a b
03:38:02 <pingu> You have to throw away type information to get to Maybe b from Either a b 
03:38:53 <bitonic> pingu: right, so I was confused by "You can turn an Either into a Maybe, but not a Maybe into an Either."
03:40:35 <pingu> bitonic: Yeah, I should be more specific.
03:41:50 <bitonic> pingu: if anything I'd say that it's "easier" to turn a Maybe into an Either, since `Either () a` is morally the same as `Maybe a`
03:43:29 <pingu> Yes, and when we start talking about morals... Actually aliasing the two seems unrealistic.
03:44:42 <pacak> Sure you can turn Either into maybe without losing any information :)
03:44:42 <pacak> > Just (Left "err")
03:44:42 <pacak> > Just (Right 100)
03:44:47 <lambdabot>  Just (Right 100)
03:44:47 <lambdabot>  <no location info>: can't find file: L.hs
03:45:49 <pingu> pacak: then you're changing the type :\
03:46:32 <pacak> pingu: You can't change type A into type B without changing the type :)
03:47:13 <pacak> (not being helpful, I know)
03:48:02 <pingu> Your function isn't Either a b -> Maybe a. So, no.
03:53:37 <xj54y> what's the difference between bind, join, map, union, concatenate, tie, link, connect, braid, fix, make, establish, firm, declare, bestow, immute, attach, settle, assign, adjust, arrange, ground, couple, base, weave, fortify, mend, build, prove, claim, test, affect, close, and assert?
04:00:10 <u-ou> nothing's different they're all the same
04:00:18 <hexagoxel> xj54y: on a closer look, some of these words seem longer than others
04:00:40 <TTK> Any of you guys familiar with both hsc2hs and c2hs and can tell me which one is the best to use when communicating with C-interfaces?
04:01:02 <chpatrick> I'm having trouble building hybrid-vectors on 7.10
04:02:55 <xj54y> u-ou, in what way?
04:03:01 <xj54y> hexagoxel, hehe... :-)
04:04:24 * xj54y thinks the difference is their vanity of actuality, and perhaps speed...
04:12:46 <Fylwind> TTK: hsc2hs is more manual work (no automatic conversions) but very simple to use, whereas c2hs automates some of that but is also more complex to use
04:13:06 <Fylwind> hsc2hs comes with GHC, c2hs does not (but it's easy to install)
04:16:24 <TTK> Fylwind: Thank you for your answer.I have to parse 3 header files that uses typedefs and defines. I need to parse pointers, send callbackfunctions to C, and enums. There are structs, but at this point I only need to store a pointer to them, not actually look at the values inside. Which tool would be the best for this job?
04:16:36 <TTK> It is a standardized interface, so it will not be changed that often.
04:17:00 <TTK> and also standard data types such as char, string, int, double etc
04:20:03 <Fylwind> TTK: I think both would work fine; it's just a matter of whether you want to automate the type conversions or write them out explicitly yourself
04:20:40 <TTK> I would prefer automating as much as possible, so I should probably go with c2hs
04:20:47 <Fylwind> this is basically the docs for hsc2hs (it's very short): https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/hsc2hs.html
04:21:10 <Fylwind> here's the docs for c2hs, it's considerably longer: https://github.com/haskell/c2hs/wiki/Implementation-of-Haskell-Binding-Modules
04:21:27 <Fylwind> so you have more bells and whistles in c2hs and can automate things like Int <-> CInt conversions
04:23:08 <TTK> ahhh, so basically c2hs does all Haskell -> Ctypes conversions - eg String to CString and the like for me, whereas hsc2hs does not. But they both generate function signatures?
04:24:41 <Fylwind> TTK: hsc does not support that, only c2hs does
04:26:36 <Fylwind> hsc2hs is really just a wrapper for getting constants (like struct offsets, macros, enums)
04:28:07 <TTK> ah okay. I'll go with c2hs then. Thank you very much Fylwind. I basically have 1 enum and 1 struct, and I do not even have to know anything about the content of the struct, just keep a pointer to it.
04:32:11 <TTK> Any reason why win32 is not mentioned here? https://www.haskell.org/platform/doc/2014.2.0.0/ghc/users_guide/using-shared-libs.html
04:34:29 <liste> TTK they're in their own section: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/win32-dlls.html
04:34:54 <TTK> but that does not contain anything about loading win32 dll's in haskell
04:40:09 <liste> TTK http://hackage.haskell.org/package/Win32-2.2.2.0/docs/System-Win32-DLL.html this may help
04:40:37 <zipper> Hey, I have a small issue. All I want to do is call cabal configure from a haskell program.
04:40:46 <haskell007> hello
04:41:10 <zipper> I've looked at the cabal library but it's too much. I can't see anything that just does stuff like build, clean configure
04:41:10 <TTK> ya liste, I am using that. I am just wondering whether loading shared objects are included in ghci and loading dll's are not. Do you know?
04:41:38 <haskell007> What's the best way to start learning Haskell w/o a background in coding
04:42:22 <TTK> haskell007: http://learnyouahaskell.com/ is nice
04:42:35 <liste> zipper how obout System.Process callCommand ?
04:42:40 <haskell007> thank you
04:43:12 <liste> @where learnhaskell
04:43:13 <lambdabot> https://github.com/bitemyapp/learnhaskell
04:43:21 <liste> check that out also haskell007
04:43:28 <rasen> haskell007: I usually recommend this answer http://stackoverflow.com/a/1016986/2538771
04:43:46 <zipper> liste: I don't know if that's the right way but I think I have to.
04:45:55 <voidzero> haskell007 also, cancel all your appointments for the coming year or so
04:46:37 <voidzero> and be sure to get a hobby that allows you to vent your anger, like i dunno, aikido or something
04:46:53 <supki> zipper: is Distribution.Simple.Configure.configure not what you want?
04:47:05 <voidzero> haskell could use more non-academic explanations imo
04:48:06 <zipper> supki: See the issue is the type signature of that.
04:48:22 <zipper> I don't want to parse the cabal file but I might have to.
04:51:04 <haskell007> Very unusually helpful, thank you.
04:53:13 <supki> zipper: I'd expect Cabal to provide a simple function to parse .cabal files
04:54:11 <supki> zipper: like Distribution.PackageDescription.Parse.readPackageDescription
04:54:38 <supki> and readHookedBuildInfo, not sure why that's a separate function
04:59:33 <ion> haskell007: LYAH has no exercises. What learnhaskell recommends has them.
05:02:24 <Axman6> voidzero: programmers could use less fear of academia
05:02:59 <voidzero> Axman6, I don't know your frame of reference, and can only speak for myself in that regard
05:03:37 <voidzero> but in my case fear is not an element
05:03:48 <TTK> Axman6: and academia could use less fear of the industry
05:03:49 <voidzero> jargon is, though. The whole plethora of unfamiliar concepts.
05:04:05 <voidzero> So a glossary would help I guess.
05:04:22 <Axman6> voidzero: all programming concepts are unfamilliar, because it is an imagined unnatural world. 
05:04:54 <voidzero> Are you trying to corner me, Axman6?
05:05:09 <Axman6> avoiding things like highly precise terms to discuss concepts in favour of names which are more familliar can lead to restricted thinking
05:05:13 <Axman6> not at all
05:05:46 <maerwald> that's not true. The precision can emerge from the context
05:05:53 <maerwald> without the terms being precise
05:06:06 <Axman6> "Functors should be called Mappables" "Monads should be called Sequencables"
05:06:51 <voidzero> Axman6, ok. It felt like that because what you're saying sounds so black and white. Maybe I'm reading it wrong.
05:06:52 <dramforever> Axman6: why objects don't have be called "things"?
05:07:09 <Axman6> huh?
05:07:54 <voidzero> I am a non academic and am reading this chatroom a lot. The thing that often gets me is when someone asks a question, and I can't parse the answer because of the complexity
05:07:56 <dramforever> I mean, how come people understand "object", "inheritence", "protected" "virtual function" but not "monoid", "functor", "monad"
05:08:03 <voidzero> same with many tutorials. 
05:08:33 <dramforever> voidzero: "abstract nonsense", right?
05:08:38 <voidzero> not at all
05:08:41 <voidzero> intriguing!
05:08:50 <dramforever> well, check wikipedia
05:08:53 <Axman6> I'm just saying that dramforever because those hava analogues in the natural world, but functor and monad don't really
05:08:55 <voidzero> oh right :P
05:09:12 <Axman6> s/i'm just saying that//
05:09:16 <dramforever> Axman6: virtual functions in the real world?
05:09:21 <ion> voidzero: I don't think that's an inherent property of academia, it's just a result of us needing to learn to teach better.
05:09:21 <voidzero> https://en.wikipedia.org/wiki/Abstract_nonsense
05:09:22 <Axman6> got half way through typing and changed thoughts :P
05:09:32 <kuribas> voidzero: perhaps you mean "lack of familiarity with the terminology", rather than complexity.
05:09:38 <kuribas> voidzero?
05:09:52 <Axman6> dramforever: people understsand that "move" means different things when talking about a person or a bike
05:10:03 <voidzero> maybe both!
05:10:41 <voidzero> but to be clear I have a lot of respect for the academic nature of Haskell
05:10:50 <CoconutCrab> erm, from what I understand, 'virtual function', 'protected' etc.. are implementation details, while 'functor', 'monad' are abstraction for 'behaviour'
05:10:51 <dramforever> Axman: people should understand that functors are not as in OO languages (I think many tutorials say that) and read on
05:11:11 <kuribas> dramforever: People know the OO terms better, because there is much more exposure.
05:11:16 <dramforever> yep
05:12:01 <dramforever> people should be exposed to more category theory terms and understand them with analogies and examples
05:12:01 <voidzero> I am just saying... As someone who chose the wrong education, and lacks the background, I wish that there was more reading material to explain some of the concepts that are unfamiliar to the non-academic me I am. :)
05:12:13 <CoconutCrab> it's like a car, people understand the mechanism used in the car "chain", "gearbox" etc... but they don't often see it from a 'mechanical system point of view' (control theory)
05:12:19 <Axman6> have you gone looking? =)
05:12:28 <dramforever> voidzero: have you learnt any haskell yet?
05:12:32 <voidzero> I am not implying difficulty or making an emotional argument
05:12:40 <kuribas> voidzero: I am not an academic, but I can read most haskell papers.
05:12:54 <Axman6> there's reams of material out there, but the fact is that many of these ideas are quite abstract, and just understanding them in the abstract may not teach you the benefits in real code
05:13:18 <voidzero> dramforever, yeah, some. I'm also just reading a lot of stuff as I go on
05:13:34 <Axman6> I'm definitely not an academic either. Many papers written about haskell are _very_ readable though. Particularly those by SPJ
05:13:41 <voidzero> kuribas, me too. I'm not complaining here guys, just saying what I would like is to understand things quicker :)
05:13:56 <dramforever> voidzero: actually I'm trying to learn category theory now. It looks really interesting
05:14:12 <dramforever> maybe I'm just a little better at understanding abstract stuff...
05:14:28 <dramforever> /me smiles
05:14:49 <Axman6> voidzero: yeah, I completely understand that want, but it's often not poissible. the cost pays off though
05:15:01 <dramforever> Axman6: yes I totally agree
05:15:26 <kuribas> voidzero: https://wiki.haskell.org/Typeclassopedia
05:15:26 <dramforever> IMO SPJ is really good at explaining things
05:16:03 <voidzero> i guess some of my personal circumstances made stuff more difficult too but that's outside the scope for this chat
05:16:29 <voidzero> I'm playing with optparse-applicative now though, so it's not like it's all too difficult
05:16:51 <dramforever> voidzero: don't get scared of. period.
05:16:56 <dramforever> s/of/off
05:17:00 <freeman42> anyone know where to find an example of resource-pool (https://hackage.haskell.org/package/resource-pool) usage? trying to figure out how to update this example to use resource-pool instead of pool package
05:17:01 <voidzero> but i am noticing how hard it can be to explain why certain behaviours are the way they are in a working application
05:17:52 <freeman42> ehm, this example I mean :) https://gist.github.com/qrilka/1277878/11e44ced065bd38f43f6e28b69e7626628e65a3f
05:18:22 <kuribas> voidzero: use ghci to test and break down functions.
05:19:09 <dramforever> voidzero: write functions as pure as possible so that you can test them in ghci happily
05:20:09 <kuribas> I'd say that's a problem in any language, but purity and an expression type system make it easier.
05:20:24 <dramforever> kuribas: exactly
05:20:30 <lpaste> voidzero pasted “optparse and subparser” at http://lpaste.net/134034
05:20:32 <dramforever> also it's easier to test on paper
05:20:57 <dramforever> voidzero: did you know that you can run a large subset of haskell with pen and paper?
05:21:15 <voidzero> si!
05:21:20 <dramforever> ?
05:21:29 <voidzero> I know. :)
05:21:46 <dramforever> :)
05:22:50 * hackagebot schedule-planner 1.0.0.1 - Find the ideal lesson layout  http://hackage.haskell.org/package/schedule-planner-1.0.0.1 (justus)
05:23:04 <voidzero> The example I pasted is a watered down version of this https://github.com/pbrisbin/heroku-build/blob/master/src/HerokuBuild/Options.hs
05:23:30 <dramforever> What's the problem?
05:24:10 <voidzero> It's difficult to understand what happens when I run the application without arguments.
05:24:14 <Axman6> what's the error you're getting?
05:24:17 <voidzero> no error
05:24:24 <Axman6> ok
05:24:25 <voidzero> i'm not talking about problems, errors etc.
05:24:29 <voidzero> just about understanding
05:25:03 <voidzero> if I run the program without arguments, I would expect it 
05:25:07 <voidzero> to not typecheck
05:25:17 <voidzero> because in that case OptArgs would remain empty
05:25:24 <voidzero> which is not valid
05:25:30 <Axman6> there are no types at runtime (and shells don't have types)
05:25:58 <Axman6> what happens when you don't give it an argument?
05:26:04 <dramforever> I think there will be a runtime error of some sort
05:26:29 <voidzero> nope.. you get this output:
05:26:31 <voidzero> Usage: threeActs COMMAND
05:26:33 <voidzero>   Do one of three things.
05:26:36 <Axman6> I would guess that `helper` is where the magic comes from
05:26:49 <Axman6> it's what prints out the help message when you don't have valid arguments
05:26:52 <voidzero> dramforever, that's my point - I expected the runtime error too!
05:27:01 <dramforever> voidzero: the behaviour is unspecified. I guess the parser didn't return a value
05:27:06 <dramforever> it just exited the program
05:27:07 <voidzero> I read
05:27:23 <Axman6> it's doing exactly what it's supposed to do :
05:27:24 <Axman6> \
05:27:31 <voidzero> I read that the exit status is 1 because it lacks a required argument :)
05:27:34 <voidzero> Axman6 it is.
05:27:37 <dramforever> voidzero: by unspecified I mean that it's not written into the program
05:28:10 <Axman6> what's the type of helper?
05:28:25 <voidzero> Parser (a -> a)
05:28:52 <Axman6> and what happens when you remove helper <*> from the program and run it?
05:29:22 <voidzero> the output is the same
05:29:48 <voidzero> but './app --help' becomes an invalid option
05:29:57 <Axman6> ok
05:29:59 <dramforever> voidzero: how about this: what's the type of execParser? I think it's Parser a -> IO a
05:30:05 <Axman6> and what's the type of info?
05:30:31 <voidzero> Parserinfo a -> IO a
05:30:43 <voidzero> ^ execParser
05:30:45 <voidzero> info :: Parser a -> InfoMod a -> ParserInfo a
05:31:01 <dramforever> so magic is happening inside execParser, and it does whatever it wants to convert a Parser to an IO action
05:31:13 <dramforever> and the docs should say what it does
05:31:15 <Axman6> looks like info if what builds up the info string when the parser doesn't match something
05:31:22 <voidzero> yeah the magic of Applicative, I suppose
05:31:41 <dramforever> voidzero: is that message to me?
05:31:51 <voidzero> but still, I don't know why it typechecks, because, if I don't pass arguments, the type for Options = Options OptArgs is not satisfied
05:32:08 <dramforever> well, it didn't return
05:32:12 <Axman6> that's what Options <$> parseCmd does
05:32:13 <dramforever> execParser ... didn't return
05:32:24 <dramforever> :t exitSuccess
05:32:27 <lambdabot> Not in scope: ‘exitSuccess’
05:32:40 <voidzero> exitSuccess is ExitValue iirc
05:32:41 <dramforever> :t System.Exit.exitSuccess -- could explain this
05:32:43 <lambdabot> IO a
05:32:43 <Axman6> parseCmd has a type something like: Parser OptArgs
05:32:54 <ion> http://hackage.haskell.org/package/optparse-applicative-0.11.0.2/docs/Options-Applicative-Extra.html#v:execParser “Parse command line arguments. Display help text and exit if any parse error occurs.”
05:33:18 <dramforever> ha! voidzero, look, "exit"
05:34:14 <voidzero> so it does not typecheck, but it compiles because there is an exit statement? Or am I still not getting it? :)
05:34:31 <dramforever> voidzero: it typechecks because:
05:34:36 <dramforever> :t System.Exit.exitSuccess
05:34:38 <lambdabot> IO a
05:35:29 <dramforever> look at that a. it's, technically, an "universally qualified type variable with no constraints"
05:35:34 <voidzero> yes
05:35:36 <dramforever> i.e. can be anything
05:35:39 <dramforever> so it typechecks
05:36:03 <Axman6> because exitSuccess never returns it can have any type. It's in IO so it get executed at the right time
05:37:17 <voidzero> ok.. I'm still trying to get the part about OptArgs
05:37:19 <Axman6> voidzero: remember, the type a -> b (or even IO b) basically says that _if_ you give me an `a`, _and if_ it returns, then I will give you a b
05:38:14 <dramforever> voidzero: the answer is, there isn't an OptArgs returned
05:38:19 <voidzero> yess
05:38:22 <voidzero> :)
05:38:27 <dramforever> ;)
05:38:28 <voidzero> I think I am starting to get it.
05:38:55 <voidzero> It exits before we even get to OptArgs and that's why "it works"
05:39:10 <Axman6> yep
05:39:53 <voidzero> it's funny how I notice that I need to let this idea sink in for a bit
05:40:14 <dramforever> voidzero: it's the same for any other language
05:40:17 <Axman6> it's a dangerous idea though, so don't dwell too deeply on it :P
05:40:25 <voidzero> but, I have been guessing about this a lot, so thank you for the explanation here
05:40:42 <dramforever> voidzero: see, not a haskell specific problem
05:41:06 <voidzero> alright sure, but haskell is precise, so, I want to be precise too
05:41:19 <voidzero> instead of hacking something together and not caring about the why
05:41:26 <voidzero> i.e. shell scripts
05:41:33 <dramforever> voidzero: good for you
05:41:55 <voidzero> thank you
05:41:57 <dramforever> that's also the deeper meaning of "if it compiles, it works"
05:42:07 <maerwald> which is most of the time wrong
05:42:28 <Axman6> "If it compiled, it works, but may not do what you thought it did"
05:42:43 <voidzero> if I can not rationalise why something works, I have wasted my time and could have stuck to zsh.
05:42:46 <ion> voidzero: A Parser type will involve a function from input to Maybe output or [output] which lets it indicate a parse failure and not generate an output value. The one invoking the parser (such as execParser) will be able to do whatever it wants when the parser fails.
05:43:21 <dramforever> maerwald: I often read this as "If it compiled, you are not terribly wrong"
05:44:08 <dramforever> If it compiled, it's more likely to work than in many other languages
05:44:37 <Axman6> except the dependently typed ones
05:45:42 <dramforever> Axman6: if it compiled, and you wrote the correct types, but it doesn't work, then it's a bug in the compiler and you should report it at once
05:45:56 <dramforever> okay partly joking
05:46:28 <lamefun> How can I use cabal to install packages so that cabal-install is never used?
05:47:00 <Axman6> why do you want that?
05:47:13 <Axman6> you can just compile Setup.hs and run it I think
05:47:23 <lamefun> Because cabal-install is a toy: https://github.com/haskell/cabal/issues/936
05:47:26 <Axman6> or even, runHaskell Setup.hs
05:47:51 <Axman6> use Stackage then
05:48:05 <voidzero> ion, I had to read that a couple of times but am starting to get what you're saying
05:48:06 <Axman6> but that's not a cabal-install problem, it's a Hackage problem
05:48:52 <lamefun> A Hackage problem?
05:49:06 <voidzero> ion, but in the general sense: I'm always impressed by your ability to get points across using few words. :)
05:49:32 <Axman6> yes, hackage doesn't currently support TLS or package signing IIRC
05:50:13 <dramforever> lamefun: iirc stackage can do it
05:50:26 <AshyIsMe> nyone for tanks?
05:50:29 <AshyIsMe> er, wrong window
05:50:43 <voidzero> lamefun, i am flabbergasted by this response - a) this isn't a bug, it's a feature request
05:50:54 <voidzero> it sure is a bug in my book
05:51:09 <voidzero> (i.e. the sysadmin for life book)
05:51:34 <dramforever> I believe the issue is submited by someone too excited
05:51:44 <voidzero> yes that too :P
05:51:56 <Axman6> voidzero: better stop using pretty much any language then. if you're installing third party libraries, whether they've come over an encrypted connection or they've been signed, there's always risk
05:52:17 <Axman6> at least we have the SafeHaskell stuff so we can be sure the code we're using in our apps is safe to run
05:52:39 <voidzero> i don't refute the fact that there's always a risk
05:53:09 <voidzero> the bug is missing a verification-before-install step
05:53:09 <Axman6> nom modules run arbitrary shell scripts (IIRC as root too) when installed
05:53:13 <Axman6> npm*
05:53:45 <Axman6> and it's the same with most other package managers
05:53:50 <Axman6> it's a difficult problem
05:54:40 <voidzero> I won't go as far as some of the suggestions/requests in that bug report
05:54:52 <dramforever> lamefun: https://www.fpcomplete.com/blog/2015/05/secure-package-distribution
05:55:06 <dramforever> you just reminded me to try this
05:55:07 <lamefun> dramforever, I know, but it isn't implemented yet.
05:55:16 <dramforever> ?
05:55:46 <lamefun> cabal-install validation
05:56:07 <dramforever> lamefun: I guess you have to use stackage to use this
05:56:11 <dramforever> stk
05:56:33 <lamefun> yes
05:57:46 <dramforever> but how could I install stk? :(
05:57:51 * hackagebot homplexity 0.4.3.0 - Haskell code quality tool  http://hackage.haskell.org/package/homplexity-0.4.3.0 (MichalGajda)
05:58:59 <mizu_no_oto> I'm trying to transliterate some Python into Haskell, and one of the functions in the python code is doing a weird floodfil type thing on a 2D board represented as a String
05:59:29 <Axman6> sounds horrible
06:00:12 <mizu_no_oto> Yeah.  I'll probably refactor it use an actual 2d array at some point after I get the whole thing transliterated
06:01:49 <mizu_no_oto> But is there a better way to set a character at an index with Text than to split the string around that index and concatenate the prefix and suffix around the new character?
06:02:24 <dramforever> maybe you should use a mutable array
06:02:40 <mizu_no_oto> Also, is there any way to just grab the underlying array of a Text, do a bunch of mutable stuff in ST, and refreeze it?
06:06:35 <supki> > set (ix 5) 'z' "foobar" 
06:06:37 <lambdabot>  "foobaz"
06:06:40 <joneshf-laptop> finally there's a code complexity tool for haskell?!?
06:08:45 <dramforever> supki: sadly, that would mean a great deal of new strings when flood filling
06:13:01 <mizu_no_oto> dramforever:  IIRC, python strings are immutable.  So this shouldn't be any slower than the python
06:13:15 <dramforever> wow
06:13:36 <dramforever> so the py version is doing split -> concat?
06:13:41 <dramforever> interesting
06:15:10 <mizu_no_oto> Unless I misunderstand the semantics of python, yes
06:15:26 <mizu_no_oto> I'm not really a pythonista, so it's quite possible that I do
06:15:54 <hodapp> strings are indeed immutable in Python
06:17:01 <pingu> I wonder why.
06:17:17 <pingu> Seems like if you could track references that'd be a bad idea.
06:17:52 * hackagebot hspec-wai-json 0.6.1 - Testing JSON APIs with hspec-wai  http://hackage.haskell.org/package/hspec-wai-json-0.6.1 (SimonHengel)
06:18:46 <hodapp> pingu: early on at least, one could only use immutable values as keys in a dictionary, so that perhaps is part of it.
06:18:53 <hodapp> tuples and strings are both immutable in Python
06:18:53 <ocharles_> Does anyone know how I should interpret the +RTS -s 'productivity' metric when using criterion?
06:19:13 <ocharles_> because it repeatedly runs some code and then throws it away, should I expect ~50% productivity to be good?
06:19:21 <ocharles_> I don't really know how that number is measured or influenced
06:21:36 <pingu> ocharles_: I think it's how fast it runs 'mutating' closures or something.
06:21:46 <pingu> I've forgotten the details but if you dig you'll find it.
06:23:28 <pingu> ocharles_: yeah, that's it. "Productivity" tells you what percentage of the total CPU and wall clock elapsed times are spent int he mutator (MUT)
06:23:37 <ocharles_> ah
06:23:42 <pingu> https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/runtime-control.html
06:24:24 <ocharles_> thanks!
06:24:49 <pingu> you're welcome
06:37:53 * hackagebot haverer 0.1.0.0 - Implementation of the rules of Love Letter  http://hackage.haskell.org/package/haverer-0.1.0.0 (jml)
06:39:43 <mizu_no_oto> > :t set (ix 5) 'z' "foobar"
06:39:45 <lambdabot>  <hint>:1:1: parse error on input ‘:’
06:42:53 * hackagebot wai-middleware-gunzip 0.0.2 - WAI middleware to unzip request bodies  http://hackage.haskell.org/package/wai-middleware-gunzip-0.0.2 (ToralfWittner)
07:07:54 * hackagebot yesod-core 1.4.11 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.11 (MichaelSnoyman)
07:18:46 <tmtwd> data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)  
07:18:58 <tmtwd> what is Node in this Tree datatype?
07:19:05 <tmtwd> I mean I know what a node is
07:19:06 <Axman6> a data constructor
07:19:24 <tmtwd> but why don't we need to define it before we define tree?
07:19:38 <Axman6> it is the definition of what a tree is
07:19:57 <Axman6> a Tree is either an EmptyTree or a Node
07:20:03 <tmtwd> ah I see
07:20:12 <Axman6> this is where those constructors are being defined
07:20:20 <tmtwd> and Node takes a as a member?
07:20:42 <Axman6> Node takes a and two Tree a's as arguments to construct a Tree a
07:20:45 <ion> It takes an “a” and two “Tree a”s
07:20:52 <tmtwd> ah see
07:20:58 <Axman6> Node :: a -> Tree a -> Tree a -> Tree a
07:21:09 <tmtwd> interesting!
07:21:32 <ion> The same with GADT syntax: data Tree a where { EmptyTree :: Tree a; Node :: a -> Tree a -> Tree a -> Tree a }
07:21:35 <tmtwd> that is the type definition of node?
07:21:45 <ion> What Axman6 just said
07:22:08 <voidzero> i've seen some tutorial, and on it, the person kept repeating "left of the = sign" and "right of the = sign"
07:22:17 <voidzero> that really helped me
07:22:23 <voidzero> s/helped/helps/
07:22:25 <tmtwd> huh?
07:22:52 <Axman6> voidzero: luckily in Haskell = actually means equal, not assign
07:22:55 <voidzero> left of the equals sign is Tree, right of the equals sign is either EmptyTree or a Node
07:23:24 <voidzero> "data constructor" = "type constructor" or maybe value. I forgot. :D
07:23:41 <voidzero> left of = deals with kinds, right of = deals with types
07:23:46 <voidzero> or something like that
07:23:50 <voidzero> Axman6, indeed
07:24:25 <voidzero> i don't know if what I am saying helps you at all tmtwd but it was useful for me
07:24:26 <ion> = in Haskell is not commutative though.
07:24:50 <voidzero> keep reminding myself "am I working on the left or right side of the = sign"
07:25:36 <voidzero> maybe it was 'type constructor' = 'value constructor'. I'll have to look it up.
07:25:46 <Axman6> that sounds more like it
07:26:02 <tmtwd> does haskell have an assign operator?
07:26:07 <tmtwd> oh let?
07:26:15 <tmtwd> let x = 43829?
07:26:40 <Axman6> no
07:26:45 <geekosaur> actually not as such, bindings are immutable
07:26:58 <Axman6> let is also just defining a name for the value of an expression
07:27:05 <Axman6> you can define functions in let too
07:27:10 <geekosaur> there is let-in for general expressions, and do notation has something that looks like an assignment but isn't, quite
07:28:07 <nrolland> hi, I use hoogle —info to get some documentation from the first match. is there a way to specify the second match instead ?
07:42:56 * hackagebot warp-tls 3.0.4.1 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.4.1 (MichaelSnoyman)
07:58:43 <ij> I want to use STM to have two "safe" routines, where one gets IO input, stores it in a shared variable, other uses the last one written. Is that doable?
08:01:34 <mniip> ij, sounds like you wan an MVar
08:03:50 <ij> Yup, sounds like it. Is it possible to mingle IO into STM though?
08:04:10 <ij> Just curious.
08:04:35 <Fernandos> hi
08:05:48 <Fernandos> Is it possible to use a the "BLACK STAR" unicode symbol in Haskell? Because the docs say so, but I get an error 
08:06:40 <arw> depends on the error. using it in some places might be impossible if it is not considered a capital letter.
08:06:53 <saep> ij, unsafeIOToSTM
08:07:10 <Fernandos> arw: https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/syntax-extns.html
08:07:18 <ij> saep, But that, of course, ruins guarantees?
08:07:30 <Fernandos> Replacing * with ★ should be "possible"
08:07:45 <saep> ij: Anyhow, it is probably best to perfirm the IO part before putting that result into a STVar (or something similar).
08:08:02 <srhb> Fernandos: I just tried (★) = 42
08:08:05 <Fernandos> This is a part of a statement: map ((,) <$> head <*> length) and I tried map ((,) <$> head <★> length) and that doesn't compile
08:08:05 <srhb> Fernandos: Works fine.
08:08:38 <saep> ij: You should simply read the documentation. 
08:08:40 <srhb> Fernandos: did you do (<★>) = (<*>) ?
08:08:51 <voidzero> wow, my font. I have to squint to see the difference between the two.
08:08:53 <Fernandos> srhb: ?
08:09:03 <Fernandos> voidzero: weechat?
08:09:12 <voidzero> the IRC client doesn't matter :)
08:09:14 <voidzero> but yes
08:09:17 <voidzero> but the font is Terminus
08:09:27 <srhb> Fernandos: The extension is about syntax. <*> is not syntax.
08:09:39 <Fernandos> voidzero: I use sans serif (size 11)
08:09:41 <srhb> Fernandos: So <★> is different from <*> afaik
08:09:50 <Fernandos> Ohhh
08:09:50 <srhb> Fernandos: Unless you redefine it as such.
08:10:28 <Fernandos> I'm not even sure what <*> means. to me it looks like <*><  :D
08:10:35 <srhb> Fernandos: Also note that no extension is necessary to use BLACK STAR as an operator. 
08:10:43 <srhb> :t (<*>)
08:10:44 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:10:59 <srhb> Fernandos: So it applies "a function in a functor" to something "in a functor"
08:11:04 <arw> > 3 ★ 5
08:11:05 <voidzero> https://github.com/dbrattli/OSlash/wiki/Functors,-Applicatives,-And-Monads-In-Pictures
08:11:07 <lambdabot>  15
08:11:07 <voidzero> relevant
08:11:12 <voidzero> and very nice to check out :D
08:11:36 <muzzle> hi
08:11:41 <arw> :t (<★>)
08:11:43 <lambdabot>     Not in scope: ‘<★>’
08:11:43 <lambdabot>     Perhaps you meant one of these:
08:11:43 <lambdabot>       ‘<$>’ (imported from Control.Applicative),
08:11:46 <ij> saep, mniip, Thanks.
08:12:18 <Fernandos> srhb: http://i.imgur.com/aFCmdds.jpg ?
08:12:21 <arw> Fernandos: the extension just sets ★ = *, all the other operators should be untouched.
08:12:30 <muzzle> so i wonder, if i have two types A and B that are both instance of a class Cl , is there a possibility to implement a read method for for a class like Cl a => String -> a ?
08:12:48 <Fernandos> voidzero: just checking it out.. before my head explodes =)
08:13:11 <voidzero> yeah. Zoom out and take a breath in that case hehe
08:13:23 <voidzero> frustration happens if you're zoomed in too much. In my case at least.
08:14:18 <mniip> <arw> Fernandos: the extension just sets ★ = *, all the other operators should be untouched.
08:14:26 <mniip> but why, the symbols have like nothing in common
08:14:36 <srhb> Yeah, it's weird.
08:14:40 <voidzero> they are both pointy
08:15:13 <voidzero> ok. sorry. i'll slap myself and go sit in the corner now.
08:15:29 <geekosaur> mainly so type level programming + unicode addicts can use ★ in kinds, I think
08:16:03 <geekosaur> agda-vating?
08:19:20 <GLM> What are the best resources for getting Haskell into prod?
08:19:52 <srhb> GLM: What do you mean, getting Haskell into production? Building programs?
08:20:23 <GLM> srhb:Getting Haskell code into enterprise organizations that do something important
08:20:35 <Fernandos> geekosaur: I almost completed an atom.io synthax-theme and prepared adding replacment of ascii chars with unicode
08:20:43 <srhb> GLM: Ah. Don't know of any aside from testimonials from other companies.
08:21:12 <srhb> GLM: Things like this: https://medium.com/@folsen/haskell-in-production-bdellium-1df48de40e19
08:21:22 <GLM> Exactly. Everyone seems to love it but no explanations how
08:21:29 <GLM> Already read ot
08:21:33 <GLM> it
08:21:39 <srhb> GLM: I don't think there's a "how" aside from teaching management why it's good.
08:21:41 <Fernandos> What editor are you using for haskell?
08:21:48 <srhb> GLM: If you can't do that, it won't happen.
08:21:58 <srhb> Fernandos: Emacs and Vim are probably the most popular.
08:22:14 <GLM> Fernandos:Vim
08:22:39 <GLM> srhb: I don't know Haskell well enough to do it
08:22:50 <Fernandos> GLM: how are you productive with vim? Honest question.
08:23:00 <srhb> GLM: Well, perhaps make an attempt when you do, then. :)
08:23:23 <GLM> Fernandos:I'm not really but I haven't seen many other options
08:24:06 <Fernandos> I mean without spendnig a weekend or week tuning the vim config for one particular language it's almost useless (at least from my perspective and I've used it a few years and contributed to vim frameworks)
08:25:18 <nrolland> i found emacs quite friendly to use 
08:25:45 <bananagram> is there a library that canonicalizes strings to be used in http paths?
08:25:52 <nrolland> in vim and emacs, you’ll end up customizing your editor as hell. emacs has at least a real language behiind it
08:25:58 <Fernandos> I starting using emacs before until some vim fanboys in my university said vim would be better. I gave Vim two tries.. the first try ended up in confusion than I gave it generously a week and was still not that productive with it.. 
08:26:15 <bananagram> like making files with unicode characters friendly for browsers to request
08:26:16 <muller> Fernandos, Depends on what you want to do from within it. I am happy with syntax higlighting, which vim supports most langauges by default.
08:26:30 <Fernandos> What annoyed me was how poor the VimL language is and I couldn't grasp why one would invent a custom language for an editor..
08:26:41 <nrolland> fernandos : same
08:26:49 <ReinH> VimL is horrid
08:27:35 <nrolland> i like vim for text edition, but plugin wise and customisation wise, emacs at least has a real language, which is documented and predictable
08:27:46 <Fernandos> muller: the only thing I currently do is writing in all kinds of rare or popular languages.. Assembler, Erlang, Elixir, Nim, Earlgrey, Haskell, C99, Scala, Idris, Agda, Red, Clojure, HTML, JS, CSS, Less, Stylus and many more
08:27:49 <srhb> I think we're drifting off topic though.
08:27:58 * hackagebot KSP 0.1 - A library with the kerbal space program universe and demo code  http://hackage.haskell.org/package/KSP-0.1 (brettschneider)
08:28:05 <srhb> Anyway there's #haskell-emacs if you're interested, Fernandos.
08:28:12 <Fernandos> oh cool
08:29:16 <bananagram> okay seriously, cabal update uses way too much ram
08:29:42 <bananagram> I can't get it to run on my vps without it being killed by the OOM killer
08:29:52 <srhb> bananagram: Which version?
08:30:02 <bananagram> 1.22.4.0
08:30:28 <srhb> bananagram: Okay. I agree, it uses too much RAM. You can do the update on your own computer and then move it, for now.
08:30:46 <bananagram> yeah, that would work
08:32:00 <srhb> bananagram: But if that causes your vps to go OOM, I doubt compiling on it will be very easy. :P
08:32:07 <srhb> So I'd probably do that locally as well.
08:32:15 <bananagram> yeah
08:32:29 <bananagram> but most things would work
08:34:06 <bananagram> where does it put the update files though?
08:34:44 <bananagram> I can't fing them
08:34:47 <bananagram> find*
08:34:54 <bananagram> actually hang on
08:35:25 <srhb> bananagram: I think it's ~/.cabal/packages
08:36:40 <bananagram> no, that's just downloaded packages
08:36:58 <muzzle> how can i parse a string when i am not sure what type it contains ? (one of a typeclass)
08:38:03 <bananagram> maybe you can read it as (Class a => a)?
08:38:51 <srhb> bananagram: No it isn't.
08:38:57 <srhb> bananagram: Notice the index tar file
08:39:51 <bananagram> all I see is hackage.haskell.org, containing package files. I see a tar file in packages/ in a sandbox though
08:40:16 <srhb> Try rm -Rf ing the hackage directory, then doing cabal update, then look again
08:40:17 <bananagram> that mus be it
08:41:07 <bananagram> ah, now they exist
08:45:34 <bananagram> I don't think it likes those files
08:46:02 <bananagram> the first time I run "cabal install x" cabal bloats up and ends up killed
08:46:24 <bananagram> this is bizzarre
08:46:27 <srhb> bananagram: Sounds like a bug.
08:46:37 <bananagram> but not the times after that
08:46:56 <bananagram> I'm not sure if it's updated or not
09:00:07 <Gurkenglas> Is there literature on instances being viewed as functors from a kleisli category into Hask?
09:05:32 <Gurkenglas> Also, what'd be the dual of that? Covariant or contravariant, from or into Hask (or co-Hask?), kleisli or co-cleisli, ...?
09:07:27 <muzzle> how can i implement a typeclass that has two parameters (MyClass a b) as an instance of applicative (instance Applicative (MyClass a) where …) ?
09:08:09 <muzzle> is this possible at all ?
09:08:46 <muzzle> i am having trouble with defining pure
09:08:51 <muzzle> <*> is easy
09:09:35 <Hijiri> do you mean a type with two parameters
09:10:03 <muzzle> yes
09:10:10 <muzzle> sorry
09:10:13 <muzzle> badly phrased
09:10:18 <Gurkenglas> Well what does MyClass do/can you show us your <*> code?
09:10:24 <Gurkenglas> (use lpaste)
09:10:56 <ClaudiusMaximus> ow.  i have an annoying stack leak :(  seems not to happen when running with  +RTS -N1 -p  which makes it awkward to debug :(  http://mathr.co.uk/tmp/hp-stack-explosion.png
09:11:19 <Clint> that looks pretty annoying
09:11:36 <muzzle> http://lpaste.net/134040
09:11:46 <ClaudiusMaximus> yeah, i left it a fraction too late to kill it one time and had to wait 10mins for the kernel to get around to it
09:12:08 <muzzle> Gurkenglas: it's supposed to be a container for amounts of money tagged with a currency type
09:12:25 <muzzle> Gurkenglas: for which i want to define applicative and functor instances
09:15:21 <Gurkenglas> Why do you want to define an Applicative instance? Why doesn't the currency of the function in the <*> matter to the currency of the result?
09:18:16 <Hijiri> muzzle: you can't write an applicative instance for it
09:18:25 <Hijiri> because you need a value of c for pure
09:18:32 <Hijiri> and you have no way of getting that
09:18:58 <Hijiri> it would also need to follow some other rules to be a well-behaved applicative instance
09:20:06 <muzzle> Hijiri: hmm is there no way of getting this to work
09:20:15 <muzzle> it somehow feels like this should be possible :P
09:20:23 <Gurkenglas> Why do you want Applicative in the first place?
09:20:31 <ReinH> Hijiri: Monoid c => Applicative (Amount c), just like  (a,) instance
09:20:37 <ReinH> would work
09:20:54 <Hijiri> right
09:20:59 <ReinH> but I don't see the point
09:21:04 <Gurkenglas> ReinH, that would change his <*> implementation
09:21:19 <ReinH> why?
09:21:22 <muzzle> Gurkenglas: I was actually aiming for a monad instance because i want to play around with some finance applications where i need to always keep track of the currency i'm dealing with
09:21:44 <muzzle> Gurkenglas: and i thought, that by doing it like this i could make use of the type system to do that
09:22:04 <Hijiri> you don't need a monad instance for the type system to keep track of things
09:22:33 <Hijiri> making a monad instance is good if the thing you are dealing with follows the pattern of a monad
09:22:36 <GLM> What are some good projects I can do to get introduced to Haskell?
09:23:06 <Hijiri> but I wouldn't go out trying to make a monad without considering if it really fits one
09:23:57 <Gurkenglas> ReinH, he currently combines the cs in the <*> via const, so pure = Amount mempty would violate the applicative law Amount c f <*> pure x = Amount c (f x). (Not sure that that is actually a law, but it sounds right.)
09:24:01 <ReinH> (a,) isn't a monad
09:24:51 <ReinH> Gurkenglas: hmm, perhaps
09:25:47 <srhb> GLM: Have you already done the cis194 course?
09:26:11 <Gurkenglas> (Also, if you weren't gonna change <*> you don't need a full monoid instance, just something that specifies a "null value" or something. Is there a typeclass for that?)
09:26:24 <GLM> srhb:I have a degree in CS so most likely
09:26:32 <srhb> GLM: Ah, ok. :)
09:27:42 <srhb> GLM: I don't know your Haskell level, so it's hard to come up with a concrete recommendation. I merely wanted to say that diving into a project might not be the right approach, but if you've already nailed type classes and so I guess that's not the issue. :)
09:28:33 <GLM> srhb:I know the basics and am a software engineer so I should be able to figure out the rest given a project
09:29:17 <vitalij> Hi everyone, sorry to disturb you. I am looking for Italian haskellers or people from Italy who wants to learn haskell. Is there anyone?
09:30:14 <srhb> GLM: Then I guess it's just a matter of what interests you. I personally would look at some of the diagrams stuff https://github.com/diagrams :)
09:30:49 <GLM> Thanks. I can't really think of anything that interests me which is why I'm having difficulty coming up with a project
09:31:11 <srhb> vitalij: There is one person in #haskell.it -- perhaps they will know more about the community
09:32:09 <exio4> GLM: write a small abstract stack machine, and an interpreter of it, then, using parsec, build a small toy programming language that compiles to it? 
09:32:23 <vitalij> srhb thanks!
09:33:03 <ReinH> Gurkenglas: "Pointed", but it has no laws, so it's kind of... pointless
09:33:08 <GLM> exio4:Please explain what you mean
09:33:30 <ReinH> GLM: You have a degree in CS so you've done a specific course from a school you probably didn't go to?
09:33:36 <Hijiri> GLM: do you mean you have taken the specific UPenn's CIS194 online lecture notes
09:33:53 <ReinH> I don't see how that follows
09:33:54 <exio4> GLM: nothing special, just try playing with a thing that has a nice representation as a tree, a programming language is an example
09:34:11 <GLM> Hijiri:and ReinH No. I meant that I likely knew the content of the course. I just need to learn the Haskell
09:34:19 <Hijiri> the content of the course is haskell
09:34:21 <ReinH> GLM: Haskell is the content of the course
09:34:29 <GLM> ReinH:Nothing else?
09:34:34 <ReinH> Maybe go look at it
09:35:10 <GLM> Doing that now
09:38:01 <gremble> cis194 is pretty cool
09:38:47 <Hijiri> GLM: The Spring 13 version is recommended, by the way
09:39:47 <GLM> Hijiri:What makes that one the best?
09:40:28 <ReinH> GLM: easiest to work with independently
09:40:33 <ReinH> since it's just lecture notes
09:40:39 <GLM> Thanks
09:40:53 <Gurkenglas> Stop me if you've heard this one: (because I'm looking for someone that knows where to read more about this idea) I was thinking on how to allow multiple different instances for one typeclass-type-pairing. The idea I had was that one could define a "free" "pseudo"-instance as follows: Whenever the next step of the evaluation of a thunk would require one to look up an instance definition, treat it to already be in WHNF. (Obviously,
09:41:02 <ReinH> GLM: As far as projects, what areas of CS interest you?
09:42:17 <GLM> ReinH:That is something I'm still trying to figure out because there are a lot of cool areas. So far, I'm interested in machine learning/ AI, data science, programming languages (hence Haskell), and pretty much anything backend or distributed
09:42:27 * davidfetter very interested in what can be done given that mutable state is inevitable
09:42:27 <Gurkenglas> tation, so this'd be a wrapped type.) ("pseudo" because it doesn't actually obey any laws.) ("free" because the way one would now apply a specific instance is to supply a definition for each word the typeclass defines and finish evaluating the thunk, thus allowing this "instance" to be reduced to any other.)
09:42:56 <ReinH> davidfetter: what do you mean?
09:43:20 <davidfetter> databases, print, stdout
09:43:25 <ReinH> GLM: well, Haskell is pretty good for all of those things
09:43:27 <davidfetter> as i said, inevitable
09:43:28 <ReinH> davidfetter: in what context?
09:43:54 <davidfetter> well, all this immutability stuff is well and good...right up to the point where you actually have to do a task in reality land
09:44:05 <ReinH> davidfetter: have you ever tried to do a task in reality land with Haskell?
09:44:10 <ReinH> Nothing you mentioned requires mutability
09:44:35 <mm_> Hey everyone
09:44:38 <davidfetter> actually, i have, and pushing the mutable state out of haskell is what i've seen happen
09:44:49 <srhb> I experienced that disillusion in standard ML when we got to the IO week
09:44:52 <davidfetter> ...which solves not much of the problem, frankly
09:44:53 <srhb> All that purity down the drain.
09:44:57 <GLM> ReinH:How so? Everything I've seen suggests Haskell isn't for machine learning
09:45:13 <srhb> But in Haskell, with the cleverness of the IO monad, I feel good again. :-)
09:45:25 <fvgvxmpv1> Which extension allows for dataType{..} ?
09:45:38 <ReinH> GLM: Haskell is a great language for ML but it is lacking in libraries
09:45:39 <bitemyapp> srhb: taking Standard ML in school?
09:45:41 <srhb> fvgvxmpv1: Huh?
09:45:43 <srhb> bitemyapp: Yeah.
09:45:50 <ReinH> fvgvxmpv1: RecordWildCards
09:45:55 <Haskellfant> GLM: well machine learning is mostly about having libraries. haskell doesn't really have a lot there, but that's not a problem of the language
09:45:57 <bitemyapp> srhb: yeah I was reading Harper's book on it recently. Pretty good.
09:45:59 <srhb> bitemyapp: The disillusion with it was exactly what brought me to Haskell way back then.
09:46:15 <Gurkenglas> This wrapped type would then have a monad instance: You can use such a pseudo-WHNF result for further calculations requiring the same sort of instance by passing the buck of finishing the evalutation on to the new pseudo-WHNF result. Any "dictionary" would then be applied to both evaluations. Such dictionaries would then be a functor from the kleisli category of that monad back to Hask, as I hinted like an hour ago.
09:46:17 <bitemyapp> srhb: hah. I came from the other direction (untyped)
09:46:25 <GLM> Haskellfant and ReinH That is true but I don't have time to create every algorithm I need.
09:46:27 <ReinH> bitemyapp: which Harper book?
09:46:29 <fvgvxmpv1> ReinH, Thanks
09:46:32 <bitemyapp> srhb: I wanted types that were going to do "enough" for me that it would actually help a lot and still be expressive.
09:46:38 <Gurkenglas> If nobody has ever heard of this, I'll stop spamming and might try again another day.
09:46:40 <ReinH> GLM: true enough
09:46:45 <bitemyapp> ReinH: http://www.cs.cmu.edu/~rwh/smlbook/book.pdf
09:47:00 <ReinH> bitemyapp: Oh. The book. Right.
09:47:01 <srhb> bitemyapp: Well I did too, but then I went back to school and the first course, intro to programming, was in SML. :)
09:47:17 <Haskellfant> hm I kinda like to see a coordinated effort to create some machine learning libraries for haskell
09:47:18 <bitemyapp> srhb: there are much worse intro to programming courses.
09:47:26 <bitemyapp> srhb: I linked Stanford's recently. It's in PHP.
09:47:29 <Haskellfant> but my knowledge in that area is not (yet) strong enough to start it
09:47:33 <srhb> bitemyapp: Ouch! :|
09:47:50 <bitemyapp> srhb: Silicon Valley not a good influence on academia perhaps? :P
09:48:03 <srhb> bitemyapp: But yeah my uni is very serious about the functional style. Or at least they were. Current reforms seem to be driving them to become just another engineering education, rather than computer _science_
09:48:07 <ReinH> bitemyapp: or on anything else perhaps
09:48:09 <srhb> bitemyapp: Yeah exactly.
09:48:44 <bitemyapp> ReinH: I wonder how much sucking talented engineers out of core industries like insurance, etc. costs the country?
09:49:03 <ReinH> but muh social medias
09:49:19 <bitemyapp> I work in ad-tech, so by all rights I'm a hypocrite, but it's fun work :)
09:49:24 <ReinH> bitemyapp: :p
09:49:32 <bitemyapp> ReinH: need my big daters.
09:50:07 <ReinH> GLM: although writing the libraries can be its own reward
09:50:44 <bitemyapp> GLM: my company's backend is 100% Haskell and we're going to have some more serious ML needs soon.
09:50:48 <ReinH> GLM: you might look at the HLearn paper to see an actual experience report from using Haskell for ML https://izbicki.me/public/papers/tfp2013-hlearn-a-machine-learning-library-for-haskell.pdf
09:51:00 <GLM> ReinH:Agreed. I thought about doing that once I get to really know Haskell. I like the way HLearn works but it has so little of traditional algorithms like ANN
09:51:01 <bitemyapp> GLM: we have some (admittedly simple) linalg/matrix stuff in Haskell already. Works great for us.
09:51:11 <bitemyapp> ReinH: HLearn is a pretty singular and opinionated approach, though.
09:51:21 <bitemyapp> it's awesome, but may not be suitable to somebody getting their bearings.
09:51:26 <ReinH> bitemyapp: Yes, but it's, you know, *an* example.
09:51:50 <GLM> bitemyapp:What does your company do?
09:51:55 <ReinH> GLM: One issue is that a pure functional language generally requires a different treatment algorithmically
09:52:01 <mm_> Is it possible to ask GHC to unbox an argument to a function?
09:52:12 <ReinH> So the common algos that work in imperative languages sometimes need to be restructured or rethought
09:52:30 <ReinH> on the other hand, Haskell is a great language for algorithm design once you understand how it wants you to write algorithms
09:53:20 <bitemyapp> GLM: ad-tech
09:53:23 <ReinH> GLM: if you're interested in that side of things, Richard Bird's work is great
09:53:29 <bitemyapp> ReinH: well yeah, it has the benefit of being cohesive and developed.
09:53:32 <ReinH> If you're interested in functional data structures,
09:53:35 <ReinH> @where okasaki
09:53:35 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
09:53:43 <bitemyapp> that's another thing about Haskell that some people aren't accustomed to. We tend to have bags of tools, not frameworks.
09:53:51 <ReinH> bitemyapp: yes, thank goodness :)
09:53:55 <bitemyapp> we don't really need things glued together like frameworks because types enforce boundaries, not social contracts.
09:54:32 <GLM> bitemyapp:Yeah but doesn't that allow for pieces to be missing like ML algos
09:54:44 <bitemyapp> GLM: you think a framework can't have missing functionality?
09:54:47 <ReinH> GLM: well, that's more a factor of lack of effort in the area
09:54:53 <bitemyapp> what ReinH said.
09:55:14 <bitemyapp> we just need more people scratching their own itches and open sourcing the kit they come up with along the way.
09:55:16 <GLM> True. I guess having a centralized area makes it easier to notice that something is missing
09:55:23 <bitemyapp> my company does this and if we do anything original, we'll open source that too.
09:55:32 <bitemyapp> GLM: are you sure?
09:55:37 <bitemyapp> GLM: do you know what you need or what?
09:55:38 <bitemyapp> want*
09:55:45 <GLM> I find it odd that no one has so far despite ML being so important
09:55:53 <bitemyapp> GLM: if you know what you need then you can make a checklist and see how much work it would be to do what you want to do.
09:56:09 <ReinH> GLM: checklists of missing Haskell packages would be nice to have
09:56:10 <GLM> bitemyapp:Not really. I don't have any project in mind at the moment
09:56:20 <bitemyapp> GLM: do you have any idea at all what you need?
09:56:25 <ReinH> It's a nice way to answer questions like yours :)
09:56:33 <bitemyapp> GLM: if you don't, then this is a counseling session, not a technical conversation.
09:56:43 <bitemyapp> GLM: we can't guarantee Haskell will have everything you want and more.
09:56:46 <ReinH> bitemyapp: they're all counseling sessions :p
09:56:55 <bitemyapp> GLM: we think using Haskell is worth it even if we have to write a few things ourselves.
09:57:00 <bitemyapp> Tools can be made, language is forever.
09:57:00 <GLM> bitemyapp:I know. I just like to get an idea of what is avaliable
09:57:23 <bitemyapp> GLM: basically, there's a variety of lin-alg kit that is either pure Haskell or calls out to widely used lin-alg libraries.
09:57:35 <bitemyapp> GLM: there's stuff like HLearn, and there's a bunch of odds and ends.
09:57:45 <bitemyapp> Hackage has a category for this I think, h/o
09:57:50 <ReinH> Also the Kmettoverse has a lot of untapped potential for use in ML
09:57:55 <bitemyapp> #numerical-haskell is where your ML people are.
09:58:10 <GLM> bitemyapp:Thanks. I'll check them out
09:58:24 <bitemyapp> there's a machine learning category on Hackage but that isn't everything
09:58:29 <Haskellfant> I think ekmett mentioned on zurihac that he has been working on some ml/big data stuff that he will opensource in the future
09:58:29 <ReinH> For instance, AD has untapped potential for ML (see, e.g., http://arxiv.org/abs/1502.05767)
09:58:34 <ReinH> and Kmett has an AD library
09:58:39 <bitemyapp> http://arxiv.org/abs/1502.05767
09:58:49 <bitemyapp> http://hackage.haskell.org/package/ad
09:59:02 <ReinH> bitemyapp: yep
09:59:35 <ReinH> @hackage linear
09:59:35 <lambdabot> http://hackage.haskell.org/package/linear
09:59:41 <ReinH> is a super powered linear alg library
10:00:01 <GLM> Is it worth trying to get involved in those efforts or wait until they're a bit more stable?
10:00:26 <bitemyapp> GLM: ?
10:00:37 <bitemyapp> GLM: Kmett's stuff is stable AFAIK.
10:01:00 <GLM> bitemyapp:I should have used better words. I meant more popular and holistic
10:01:05 <bitemyapp> GLM: your questions are way too speculative and imprecise to have good answers. Do you want things to happen faster? That means you have to work.
10:01:09 <srhb> GLM: Definitely worth it. And stability is overrated. :-0
10:01:20 <GLM> Fair enough
10:01:28 <bitemyapp> GLM: In addition, only you know what you want.
10:01:42 <bitemyapp> GLM: I kinda doubt Haskell programmers in general want a "holistic framework"
10:01:55 <bitemyapp> GLM: so if you sit on your hands, you're unlikely to get what you want.
10:02:12 <exio4> the closest to a holisitic framework is a bunch of libraries that are known to work together, I think 
10:02:13 <GLM> Take life by the orns
10:02:16 <GLM> horns
10:02:21 <bitemyapp> for my part, I'd love it if there was a numpy/scipy type project I could point people to, but the current missing bits there center more on viz than on ML.
10:02:45 <ReinH> GLM: you go out there and you carpe the shit out of that diem
10:03:20 <GLM> ReinH:The diem won't know what hit them
10:03:22 <srhb> bitemyapp: I ditto that.
10:03:28 <srhb> GLM: :-)
10:05:10 <ReinH> GLM: if you want to use other people's tools to build products, you might be somewhat disappointed in some areas.
10:05:19 <ReinH> GLM: if you want a great language for building tools, I think you've found one
10:05:28 <Haskellfant> bitemyapp: I think we're also a bit behind on making it easy to work with csvs and modify them easily to get them into right format, although Frames looks very promising on that front
10:05:32 <ReinH> but it's fair to want either
10:06:05 <ReinH> although I will say that rumors of Haskell's library incompleteness are greatly overstated.
10:06:40 <ReinH> Personally, I'm more of a tool builder, so I'm pretty happy.
10:06:41 <srhb> are we doing wishlists? Because I have a wish list... :P
10:06:57 <ReinH> srhb: I would love to see wishlists.
10:07:01 <ReinH> Actually I'm going to start one right now.
10:07:16 <Haskellfant> wishlists would probably also make it easier for people to get together if they want the same thing
10:07:35 <srhb> How about: Extending XMonad so that we can have a terminal emulator and editor built into it, retaining semantically identical key bindings across them all (like splitting, moving windows, etc...)
10:07:50 <srhb> Or: Making an actual IHaskell for scientific calculations
10:07:56 <ReinH> bitemyapp: Let's start a Haskell wishlist in the style of https://github.com/sindresorhus/awesome
10:08:01 <srhb> Yes!
10:08:40 * nak wishes for Type Directed Name Resolution please
10:08:44 <bitemyapp> ReinH: the awesome-haskell repo is disappointing.
10:08:45 <srhb> Haha, yes!
10:08:48 <nak> ^.^
10:08:50 <ReinH> bitemyapp: https://github.com/reinh/haskell-wishlist
10:08:54 <bitemyapp> ReinH: https://github.com/krispo/awesome-haskell#data-science links to Hackage categories. Come on, curate!
10:08:57 <ReinH> srhb: pull request me please
10:08:59 <srhb> nak: But like I promised you, the problem actually sort of goes away once you're a bit further into Haskell
10:09:07 <srhb> ReinH: Noted :)
10:09:14 <ReinH> bitemyapp: Yes, disappointing, and we can improve it. This is a different list though :)
10:09:26 <nak> srhb it would still be so cool tho
10:09:31 <srhb> nak: Oh definitely. :)
10:09:45 <exio4> I wish Haskell would stop being fun
10:09:46 <dolio> No, TDNR isn't cool. :)
10:09:56 <ReinH> dolio: TDNR?
10:10:00 <exio4> I could get stuff done if it wasn't fun
10:10:11 <ReinH> oh
10:10:13 <ReinH> I see
10:10:20 <bitemyapp> speaking of ML - https://github.com/nikita-volkov/stm-containers/issues/5
10:10:34 <srhb> I also want module functors a la ML...
10:10:45 <bitemyapp> srhb: Backpack?
10:10:51 <srhb> bitemyapp: Yeah, sort of.
10:10:56 <nak> what's for lunch
10:11:01 * nak wishes for lunch
10:11:05 <bitemyapp> having a really hard time getting a grip on what Backpack will do.
10:11:11 <srhb> nak: Monads! Or are we not that far? :-)
10:11:18 <nak> srhb oh you better believe it
10:11:23 <srhb> nak: :-)
10:11:27 <ion> So... Burritos?
10:11:28 <nak> srhb i learned the Maybe Monad through and through yesterday
10:11:32 <srhb> nak: Nice!
10:11:50 <srhb> ion++
10:11:52 <nak> srhb and in my traditional way, i had to implement it in es6 too
10:11:55 <nak> just to check for understandings ^.^
10:11:59 <srhb> nak: Of course. :-) Good work.
10:12:26 <nak> ion burritos are good.. but like... not very close to my house
10:12:43 <srhb> nak: I think ion was referencing the horrible monad/burrito analogy
10:12:56 <ReinH> GLM: btw, https://github.com/josephmisiti/awesome-machine-learning#haskell-general-purpose
10:12:59 <srhb> nak: One of the many articles that make you not understand monads.
10:13:15 <nak> oh lol
10:13:18 <nak> i don't think i've seen that one
10:13:31 <nak> maybe for the better
10:13:47 <srhb> nak: How about the monads are toxic waste in space suits in the ocean one?
10:13:50 <dolio> ion--
10:13:52 <pepperpot> 7 in 1 Scripts 4Website Value Calculator, 12Short URL, 3Page Builder(Drag and Drop), 4SEO Analyzer with PDF Reports, 12Ajax Star Rating, 3Ajax Reviews with Star Rating, 4Favicons Generator (Favicons.net clone) all in one ZIP FIILE!! 3www.websiteadverts.org/forum/showthread.php?tid=24
10:14:06 <dolio> Glad we have color on now.
10:14:07 <nak> srhb lol nope... haven't seen that one either
10:14:26 <srhb> nak: So are you telling me you've only been looking at the _right_ materials? Sheesh, you're taking the easy route. :-)
10:14:38 * geekosaur wonders how long before they come back...
10:14:48 <ion> I actually learned something from the paper that describes burritos using category theory.
10:15:15 <nak> srhb i suppose so! dang those other ones sound fun tho
10:15:28 <ion> Namely, what "strength" means in CT
10:15:32 <srhb> nak: Risky though. Unlearning them took me a long time.
10:15:40 <srhb> I did all the wrong things when learning Haskell initially. :P
10:16:04 <dolio> geekosaur: It's probably not even worth banning, no? They'll probably randomize the host or something.
10:16:19 <nak> srhb i think i kinda have to see the burrito one tho
10:16:31 <geekosaur> actually host changes, nick changes, so far hoster and username have not (hmm@....btcentralplus.com)
10:16:33 <nak> is this it: http://blog.plover.com/prog/burritos.html
10:17:29 <srhb> nak: I don't remember the address to the original one.. But here, knock yourself out :P https://wiki.haskell.org/Monad_tutorials_timeline
10:17:41 --- mode: ChanServ set +o geekosaur
10:17:47 <ReinH> srhb: still waiting for my pull request :p
10:17:48 <nak> LOL
10:17:52 <nak> there's even a graph
10:17:57 <nak> srhb we have to be part of this statistic
10:18:00 <srhb> ReinH: Right now?!
10:18:02 <nak> let's start making our own monad tutorial
10:18:05 <ReinH> srhb: :p
10:18:18 <ReinH> srhb: help me to help you to help me
10:18:21 <srhb> nak: There Is Only One Monad Tutorial
10:18:25 <srhb> ReinH: Alright alright.
10:18:50 --- mode: geekosaur set -b *!~hmm@host31-54-236-209.range31-54.btcentralplus.com
10:19:14 --- mode: geekosaur set +b *!~hmm@*.btcentralplus.com
10:19:17 <srhb> nak: And I should probably mention it just in case... You Could Have Invented Monads (and you probably have)
10:19:26 --- mode: geekosaur set -o geekosaur
10:19:30 <ReinH> Wadler's original paper is still the best monad tutorial
10:19:31 <athan> Hmm... are there any windows (tm) installer DSLs in Haskell? Something that could produce .msi would be awesome
10:19:34 <ReinH> all others are pale immitations
10:19:50 <ReinH> athan: oh god
10:20:06 <OutlawStar> does any one know if gtk2hs supports gtk 3 yet.. I see gtk3 in the package name but I can't get it to load a builder file from gtk 3.12
10:20:14 <nak> srhb yeah i remember seeing that one 
10:20:14 <maerwald> ReinH: I guess it's fairly technical
10:20:20 <ReinH> The windows installer landscape is basically mordor but less friendly
10:20:24 <athan> ReinH: Maybe a WiX lib might be handy
10:20:25 <nak> the yorgey cis194 walkthrough was quite nice
10:20:32 <athan> ReinH: O_O
10:20:42 <geekosaur> it's supported gtk3 for some time now... but the gnome3 devs are fond of changing things in non-backward-compatible ways
10:21:22 <OutlawStar> is the gtk builder the proper way to init the UI or should I be using something else?
10:21:31 <ReinH> maerwald: I found it to be pretty accessible, especially compared to the ones that wrap monads in silly analogies ;)
10:21:43 <ReinH> It requires very little of the underlying category theory
10:22:32 <maerwald> imo, the best answer to "how do I understand monads?" is "which one?"
10:22:56 <maerwald> at least if you look at it from the practical perspective
10:23:23 <ReinH> maerwald: I tend to agree
10:24:37 <dolio> There is more to understanding them than that. But it probably doesn't help a lot.
10:27:43 <ion> athan: LMGTFY https://hackage.haskell.org/package/nsis https://hackage.haskell.org/package/bamse
10:30:01 <marrrk> Hello! I'm not sure about the syntax of my type constraint here: elementAt :: (Ord a, Num b) => [a] -> b -> a
10:30:43 <Haskellfant> marrrk: looks fine to me, what's the error?
10:31:14 <marrrk> Well then it's probably not syntax but: Couldn't match expected type ‘Int’ with actual type ‘b’
10:31:43 <Haskellfant> please paste your code on lpaste, it's not possible to help you much without seing the code
10:31:58 <Haskellfant> probably your using something specific to int, so your type signature is too general
10:32:31 <marrrk> argh I meant drop instead of take.
10:32:58 <srhb> marrrk: Changes nothing
10:32:59 <fresheyeball> hello haskllers 
10:33:00 <srhb> :t drop
10:33:03 <lambdabot> Int -> [a] -> [a]
10:33:05 <marrrk> true
10:33:13 <srhb> marrrk: See, Int. Not Num b => b
10:33:28 <marrrk> https://gist.github.com/i-am-the-slime/9c964aef70998d01ac8c
10:33:39 <nak> fresheyeball ssupp
10:33:41 <marrrk> So it has to be Int
10:33:42 <marrrk> that's true
10:33:49 <marrrk> the 2.4th element doesn't make much sense.
10:33:54 <srhb> marrrk: Yes. :) Unless you redefine drop to be more general.
10:34:05 <srhb> marrrk: You could argue that it should be Integral a => a though
10:34:14 <Haskellfant> you could use Integral b and then throw in a fromIntegral
10:34:35 <fresheyeball> hey nak
10:34:35 <srhb> Haskellfant: But that would be lying to the user.
10:34:38 <srhb> In scary bad ways.
10:34:50 <Haskellfant> srhb: I didn't say that it's a good idea :P
10:34:51 <fresheyeball> ok so I have a general question
10:34:54 <dfeuer> Good afternoon!
10:35:04 <srhb> Haskellfant: I know, just commenting for security :P
10:35:10 <dfeuer> I'm in favor of some kinds of lying.
10:35:11 <fresheyeball> lets say we have an ADT like so:
10:35:23 <ion> > fromIntegral (-2^64 + 42) :: Int
10:35:25 <dfeuer> Eq instances aren't usually about actual equality.
10:35:27 <lambdabot>  42
10:35:27 <fresheyeball> data Foo = Bar | Baz | Qua
10:35:35 <marrrk> still wrong: https://gist.github.com/i-am-the-slime/9c964aef70998d01ac8c
10:35:50 <srhb> marrrk: Include the error, please.
10:35:53 <fresheyeball> and we have a function that can only take two of the constructors 
10:35:57 <marrrk> ‘Int’ is applied to too many type arguments
10:35:58 <srhb> marrrk: But Int is not a type class
10:36:00 <c_wraith> marrrk: why does that have an Ord constraint?
10:36:07 <srhb> marrrk: It's a type
10:36:08 <fresheyeball> what is the best practice?
10:36:09 <dfeuer> MARRRK has a marrrrk marrrrrk.
10:36:15 <marrrk> c_wraith: good question.
10:36:20 <srhb> marrrk: so it should be [a] -> Int -> a
10:36:27 <marrrk> c_wraith: it doesn't need it.
10:36:35 <srhb> marrrk: But of course, that's a partial function.
10:36:36 <marrrk> oh okay, yeah I see
10:36:40 <c_wraith> marrrk: I know it doesn't.  that's why I asked. :)
10:36:48 <nak> fresheyeball (Foo a => a -> a -> ??)
10:37:01 <nak> fresheyeball or just (Foo -> Foo -> ??)
10:37:04 <Gurkenglas> fresheyeball: What you'll find in the wild are "crash everything at runtime if you get the argument that's not allowed" and "return a result wrapped in Maybe"
10:37:10 <srhb> fresheyeball: Functions should obviously work on every possible value of a type in general.
10:37:16 <srhb> fresheyeball: Otherwise, use Maybe
10:37:23 <c_wraith> fresheyeball: The best practice is to not use a type that has more values than make sense where it's used.
10:37:32 <nak> oh i follow now
10:37:41 <fresheyeball> ok
10:37:42 <maerwald> srhb: depends... if the function is not exposed and only used internally, there's not enough reason to introduce another layer of complexity
10:38:16 <srhb> maerwald: I'm not about to recommend sloppy internal loopholes for a general question. :-)
10:38:16 <nak> uh yeah... you want to write total functions fresheyeball 
10:38:29 <marrrk> okay good. I get it now
10:38:51 <marrrk> thank you
10:39:02 <fresheyeball> ok
10:39:05 <fresheyeball> so...
10:39:16 <srhb> fresheyeball: Imagine safeSqrt
10:39:35 <srhb> fresheyeball: It is the total version of sqrt, where we check for negative numbers and return Nothing in that case
10:39:56 <fresheyeball> let annoyFn :: Foo -> ()
10:40:07 <srhb> fresheyeball: Making the function total guarantees a crash free program AND lies less about what your function actually does to its users
10:40:15 <fresheyeball> where annoyFn can only take constructors Bar and Baz but not Qua 
10:40:22 <srhb> fresheyeball: Just no.
10:40:37 <maerwald> srhb: it's not really sloppy if you can prove that the function is safe in a particular context (and only used there, e.g. in a where-clause)
10:40:37 <exio4> the total version takes a positive/zero number 8)
10:40:38 <fresheyeball> there is NO WAY
10:40:42 <fresheyeball> in the type system where
10:40:44 <srhb> fresheyeball: annoyFn _ = ()
10:40:54 <fresheyeball> annoyFn Qua throws a type error
10:41:07 <fresheyeball> I want to confirm that such a thing is impossible
10:41:10 <Gurkenglas> srhb, that also lies, I'd say.
10:41:16 <srhb> fresheyeball: The type guarantees that.
10:41:17 <exio4> Qua should be in another datatype
10:41:25 <exio4> if you want it to type error
10:41:28 <srhb> Gurkenglas: I said "less" :-)
10:41:43 <srhb> Why is #haskell pedantry central today? Chill. :-)
10:41:56 <fresheyeball> ok
10:41:58 <Gurkenglas> srhb, I meant the substitution with const ()
10:42:10 <fresheyeball> but I also have functions that do take all three constructors 
10:42:11 <srhb> gurkenglas: Oh, how so?
10:42:28 <srhb> fresheyeball: Then that type is Either Foo OtherType -> ...
10:42:28 <ion> fresheyeball: To make the function total, restrict the input type (remove values the function can't handle) or extend the output type (add a value signifying a failure, such as Nothing).
10:42:34 <fresheyeball> () in my sig meant "don't care" I should have used `a` instead
10:42:35 <Gurkenglas> Because the annoyFn of Qua isn't () and you're saying that it is
10:42:55 <srhb> fresheyeball: It should be Foo -> Maybe DontCare -- if you want to make it safe and have all those values in Foo
10:43:15 <fresheyeball> I mean it was just for the sake of example
10:43:18 <fresheyeball> point is
10:43:30 <fresheyeball> I have some functions that can use all 3 constructors and some that cannot
10:43:36 <srhb> Yes, we got that.
10:43:39 <fresheyeball> and I want to confirm that the only approaches possible
10:43:46 <fresheyeball> are use a Maybe, or error at runtime
10:43:50 <srhb> You either make your functions total or you separate out the values to different types
10:44:04 <fresheyeball> ok
10:44:11 <fresheyeball> so that second option sounds interesting 
10:44:15 <fresheyeball> how could I do that
10:44:18 <ion> Or use a GADT with phantom types
10:44:21 <fresheyeball> when some functions take all 3 constructors 
10:44:26 <srhb> data Foo = Bar | Baz; data Qua = Qua
10:44:26 <fresheyeball> ?
10:44:40 <srhb> Then data Together = Together Foo Qua
10:44:53 <fresheyeball> Oh~
10:44:58 <fresheyeball> I see now!
10:45:07 <fresheyeball> you use another type to unify the types
10:45:17 <fresheyeball> and treat it like type slots of some kind
10:45:18 <srhb> I wouldn't use the word unify, but yes.
10:45:27 <fresheyeball> yeah not unify 
10:45:40 <srhb> Too loaded in here. :-)
10:45:44 <srhb> But yeah, gather values of two types.
10:45:46 <srhb> Or more.
10:45:46 <fresheyeball> uh... bind them together under 1 type 
10:46:07 <Gurkenglas> fresheyeball: You can return 'error "You gave me a Qua."' without ''. That counts as a member of any type. Anyone who tries to actually look into that value to use it causes the program to crash with "You gave me a Qua."
10:46:30 <srhb> But really, it sounds like complete overkill compared to just having data Foo = Foo | Bar | Qua and then safeFun :: Foo -> Maybe Result
10:46:36 <Gurkenglas> That is the way (!!) handles negative inputs, or head and tail handle empty lists
10:46:36 <fresheyeball> I am trying to avoid run time errors for compile time ones
10:46:39 <srhb> It _might_ not be, but it depends on the specific case.
10:46:52 <fresheyeball> Gurkenglas I thought that was why we Haskell?
10:47:02 <srhb> fresheyeball: And you can always have ghc warn you on incomplete patterns
10:47:07 <Gurkenglas> Yes, but you asked how to do that interesting runtime error thing :D
10:47:09 <srhb> Maybe you can even promote it to an error, not sure.
10:47:22 <JoshieAS> Could someone help me out with a problem I'm trying to solve?
10:47:28 <JoshieAS> It involves Process Trees
10:47:34 <srhb> JoshieAS: Just ask.
10:47:42 <Gurkenglas> Using Maybe allows the user of that function to choose what to do when they gave a forbidden argument.
10:48:04 <JoshieAS> I have a type: PID = Int
10:48:15 <fresheyeball> thanks for your help everyone
10:48:17 <JoshieAS> data Process = Process PID [Process]
10:48:18 <srhb> 2
10:48:22 <nak> > foldl1' (+) (take 1000000 [1..])
10:48:24 <lambdabot>  500000500000
10:48:26 <nak> > foldr1 (+) (take 1000000 [1..])
10:48:29 <lambdabot>  *Exception: stack overflow
10:48:29 <JoshieAS> I'm trying to write a function, makeTree, that takes a list of pairs and makes a tree from them...
10:48:35 <ion> data Tag = Hello | Bye; data Foo :: Tag -> * where { Bar :: Foo 'Hello; Baz :: Foo 'Hello; Qua :: Foo 'Bye }; acceptsHello :: Foo 'Hello -> a; acceptsAll :: Foo t -> a
10:48:43 <nak> what is the limit on this before the stack overflow? what is that limit called?
10:48:47 <ion> fresheyeball:
10:49:11 <JoshieAS> makeTree [(1, -1), (200, 1), (201, 1), (202, 200), (203, 202)]
10:49:14 <srhb> nak: stack size? :P
10:49:16 <nak> each one of the + calls in the foldr adds a "stack frame" to the stack, right?
10:49:24 <JoshieAS> should give me Process 1 [Process 124 [], Process 214 [Process 219 []]]
10:49:25 <nak> srhb ah ok, that's simple enough
10:49:38 <nak> srhb what is the stack size? and what determines it ?
10:49:42 <srhb> nak: I don't think ghc implements this as stack frames
10:49:47 <JoshieAS> I have it mostly figured out...but I can't figure out what to do in a case where two pairs have the same parent...
10:49:51 <MarcelineVQ> http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html
10:50:09 <refefer> nak: you can specify it as part of RTS
10:50:13 <nak> RTS ?
10:50:17 <srhb> Runtime System
10:50:23 <nak> oh
10:50:24 <srhb> It takes a -k argument for this I think.
10:50:47 <nak> i am like... really dumb when it comes to this low level stuff in computing
10:50:54 <nak> no sure which part of my education failed to cover it
10:51:00 <srhb> nak: https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/runtime-control.html#rts-opts-cmdline
10:51:08 <refefer> nak: do you have a CS background?
10:51:17 <nak> refefer no, software engineering
10:51:22 <srhb> nak: It wouldn't help you much, GHC does things quite differently from what most people would have learned anyway.
10:51:25 <nak> i wish i could've gotten the CS in hindsight
10:51:44 <nak> srhb i see
10:52:00 <breadmonster> nak: Is there much of a difference?
10:52:08 <breadmonster> Most engineering programs I know teach a lot of CS.
10:52:13 <nak> breadmonster well we didn't cover low level stuff in any of our course work
10:52:21 <refefer> srhb: not sure I fully agree.  there are some nuances, but the execution fits well within the known understandings
10:52:31 <nak> we didn't learn things like memory management, stacks, heaps, etc
10:52:34 <srhb> refefer: OK. :) I defer on that. I'm not a low level person.
10:52:35 <nak> i don't even know all the terms i don't know
10:52:49 * srhb finds lowlevel terribly boring. :P
10:52:52 <refefer> nak: what does it actually cover then?
10:52:52 <JoshieAS> I know what to do if a process id is larger or smaller, but not if it's the same...
10:53:05 <breadmonster> nak: wait what? How did you do a software engineering without covering data structures?
10:53:14 <MarcelineVQ> I'm shocked that there's a software enigneering course that doesn't cover heap allocations.
10:53:42 <nak> breadmonster surprisingly, most of the stuff that was taught at my school was the business side of software engineering
10:53:43 <MarcelineVQ> Was it a course that dealt mostly with garbage collected lanuages?
10:53:50 <nak> not actually *engineering of software*
10:53:56 <refefer> that sounds a lot more like systems engineering
10:54:08 <nak> yeah, it was a lot like that, come to think of it
10:54:10 <srhb> Heck, most CS programs are what I would call software engineering, but I'm an elitist asshole in that way.
10:54:28 <nak> anyway, i had like 6 years of experience in the field before i decided to go to school for it, so suffice it to say, i didn't learn too much
10:54:34 <nak> i wanted the paper as a fallback
10:54:36 <JoshieAS> anyone?
10:55:05 <hpc> when i was taking classes, there were several people in my classes who had been working for 10+ years
10:55:12 <nak> yeah
10:55:18 <hpc> and basically were re-interviewing for their own jobs and needed the degree for that
10:55:24 <nak> now i have a 50,000 debt and nothing but regret 
10:55:30 <nak> i've learned way more on my own than i ever did in school
10:55:39 <breadmonster> refefer: Oh that's interesting. I was supposed to major in that at Penn.
10:55:42 <hpc> it sort of depends on the classes you take
10:55:55 <hpc> if you know a lot about a lot of things, you can try and pick the fun classes
10:56:01 <refefer> breadmonster: it's sort of like programming with spreadsheets :)
10:56:15 <refefer> nak: eh, you got the handshake
10:56:25 <nak> refefer yeah but for what?
10:56:26 <srhb> nak: Move out of the country and evade the debt forever. WOo!
10:56:27 <refefer> cost and value being divergent
10:57:03 <hpc> i convinced one guy to take AI and comparative languages
10:57:08 <Gurkenglas> > coiter (map fst . flip filter [(1, -1), (200, 1), (201, 1), (202, 200), (203, 202)] . (. snd) . (==)) $ -1
10:57:09 <nak> srhb funny you should suggest it... this is the only question i have ever asked on money.stackexchange.com http://money.stackexchange.com/questions/29489/can-i-default-on-my-student-loans-if-i-move-to-another-country
10:57:12 <lambdabot>  -1 :< [1 :< [200 :< [202 :< [203 :< []]],201 :< []]]
10:57:15 <breadmonster> refefer: Did yo major in it?
10:57:16 <ReinH> bitemyapp: Thanks! Merged and reorganized a bit https://github.com/reinh/haskell-wishlist/blob/master/README.md#numeric-and-scientific-computing
10:57:19 <hpc> both of which were just weird enough to be educational relative to what he knew already, and so much fun
10:58:43 <JoshieAS> I just have a quick question regarding a small snippet of my problem
10:58:50 <nak> hpc i imagine AI is quite fun
10:59:03 <hpc> it is, but not for the reasons most people expect
10:59:06 <Gurkenglas> Joshua, get the list of children to -1, get the list of each of their children, repeat, put it all into the data structure appropriate to this case?
10:59:23 <srhb> nak: How interesting.
10:59:23 <hpc> it's all about graph and tree optimizations
10:59:37 <refefer> breadmonster: naw, I enjoy type theory too much
10:59:45 <refefer> it was push and shove between CS and math
10:59:52 <breadmonster> refefer: So you are a Penn graduate!
11:00:05 <hpc> a neural network for instance is a DAG plus a reduction formula that is iterated to generate a system of linear equations
11:00:08 <JoshieAS> Gurkenglas: but I'm confused as to what to do when two Processes have the same parent
11:00:14 <JoshieAS> here is my code otherwise
11:00:16 <maerwald> hpc: I had a beginners course in AI where the prof taught us the maths of perceptrons... that was really too much for most of us
11:00:24 <maerwald> it probably shouldn't be in a beginners course
11:00:31 <nak> srhb yeah it seems like i probably *shouldn't* do that lol
11:00:37 <refefer> hpc: -ish.  it starts getting convoluted with recursive neural networks
11:00:37 <Gurkenglas> JoshieAS: use lpaste, not copypaste into the channel
11:00:42 <hpc> yeah, the lowest AI course at my uni was 480
11:00:52 <JoshieAS> http://lpaste.net/134041
11:00:52 <srhb> nak: Shame.
11:00:55 <JoshieAS> I know
11:01:00 <Gurkenglas> (I don't know where "Joshua" came from)
11:01:00 <hpc> most people just took the grad-level course, but ended up hating it
11:01:12 <JoshieAS> I place food orders and tell them my name is 'Joshie' and they write down 'Joshua'
11:01:18 <srhb> nak: I'd probably do it and change my name. I think these companies might actually find it hard to figure out _who_ you are, because there's no cross-border identification system they have, really.
11:01:26 <JoshieAS> Joshie is not yet an acceptable alternative in the mainstream, I guess :P
11:01:39 <hpc> anyway, it's very much not the TV concept of AI
11:01:46 <hpc> and if you get a good AI class, they teach lisp too
11:01:54 <maerwald> we had prolog
11:02:02 <nak> srhb lol
11:02:06 <refefer> hpc: see, I don't buy that anymore
11:02:07 <JoshieAS> Gurkenglas: so that covers if a processes that are not equal
11:02:13 <hpc> (depending on the lisp)
11:02:17 <JoshieAS> but if I have (200, 1) and (201, 1) I don't know what to do
11:02:20 <refefer> lisp was interesting for a while since it was the classical AI language
11:02:43 <hodapp> Lisp is still interesting to me
11:02:45 <refefer> but there isn't a whole lot there that really engenders it toward excelling in AI
11:02:58 <hpc> refefer: it's more that AI is the only place you would ever interact with lisp in an educational setting
11:03:23 <JoshieAS> and it works the way I want to, but since I have to return a Process
11:03:26 <hpc> and for the typical undergrad dweeb, lisp is going to be their first exposure to a language that isn't C or java that way
11:03:34 <JoshieAS> and since Processes with the same parent are items in the same list..
11:03:49 <Gurkenglas> JoshieAS: Are you aware that the list of processes in the second argument of your constructor is always of length 1?
11:04:01 <refefer> hpc: that is probably true.  some schools teach scheme, others like CMU teach using haskell as well
11:04:03 <JoshieAS> It can be empty though
11:04:06 <hpc> (unless it's python, which my uni taught as "intro to programming", breeding a generation of terrible terrible habits)
11:04:14 <exio4> hpc: it'd be nicer if C/Java was the first exposure to a language that isn't Haskell, SML or Racket ;P
11:04:20 <Gurkenglas> (Right. Still.)
11:05:29 <Gurkenglas> JoshieAS: Is your list of pairs always sorted by snd?
11:05:31 <hpc> unpopular opinion alert: i think java is a good teaching language as long as you restrict it to "here's the language, businesses use it, now you know OOP sort of"
11:05:38 <JoshieAS> the input list can be unsorted
11:05:49 <srhb> exio4: My CompSci program starts with introduction to programming in SML. Only later do they learn java, in the OOP course.
11:05:51 <hpc> and then immediately move on to C / intel assembly for architectural classes
11:06:00 <hpc> and higher level languages for proper CS
11:06:02 <srhb> And then C for architecture and such later.
11:06:04 <srhb> Yeah...
11:06:05 <maerwald> hpc: most unis that teach java don't teach true OOP, so that goes out of the window
11:06:06 <srhb> :-)
11:06:09 <JoshieAS> and my function works, I just don't have a case for when the two Processes have an identical snd
11:06:14 <hpc> most don't teach /any/ oop
11:06:20 <JoshieAS> if I have a list of unsorted pairs, however long, it returns a proper tree
11:06:21 <blue_deref> hpc: My school teaches Java first. It works very well. It makes you a real OO thinker, however.
11:06:26 <exio4> srhb: I'd love to take that program
11:06:32 <JoshieAS> as long as there aren't duplicate snd in my pairs
11:06:35 <rui> Any nice concise way to write "the function that substracts 2 to sth"? (-2) is negative 2 and ((-) 2) substracts 2 to sth
11:06:44 <srhb> exio4: I think it's The Right Way. I wish they would scrap the OOP course though. :-)
11:06:45 <hpc> and just use classes as structs and "this.foo() = foo(this)" level of complexity OOP
11:07:11 <srhb> hpc: CompSci that insists on teaching OOP should teach Smalltalk or something.
11:07:11 <srhb> Oops, I veered off topic again.
11:07:13 <rui> Or only /x -> x-2 ?
11:07:21 <maerwald> hpc: and now we have all this getter-setter mess no one understands
11:07:24 <srhb> :t minus 1
11:07:26 <lambdabot> Not in scope: ‘minus’
11:07:27 <srhb> :t subtract 1
11:07:28 <lambdabot> Num a => a -> a
11:07:35 <srhb> rui: ^^
11:07:40 <hpc> ugh
11:07:47 <hpc> we learned java in highschool
11:08:05 * hackagebot aws 0.12.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.12.1 (AristidBreitkreuz)
11:08:08 <rui> srhb: Thanks!!
11:08:22 <hpc> and i think i was the only one with enough of a perspective on how math works to see "follow this pointless get/set pattern" for what it is
11:08:58 <hpc> and they never taught getters/setters with anything more interesting than Foo getFoo() {return foo;}
11:09:16 <lamefun> IMO at least default Haskell is somewhat too safety-distracting...
11:09:26 <lamefun> I mean, distracting from safety...
11:10:03 <Gurkenglas> JoshieAS: Wouldn't your code fail on [(100, 99), (99, 98), (98,-1)]?
11:10:45 <hpc> i am trying to avoid talking about haskell in teaching, because my only experience with it was my AI prof saying haskell didn't have recursion
11:10:53 <JoshieAS> ah, I guess it does, Gurkenglas
11:10:55 <lamefun> Can I make a data-type abstract yet still keep convenient pattern matching and record creation?
11:11:09 <exio4> lamefun: that is why we use pattern matching instead of head/tail, and why we use proper data structures if we need indexing, using Maybe for representing probable lack of answer, :p 
11:11:21 <hpc> (he knew lisp and AI very well, but had this weird idea that lisp invented everything)
11:11:45 <refefer> hpc: lisp did invent alot
11:11:53 <hpc> it did
11:12:03 <Gurkenglas> That sounds like he actually meant something like Haskell not having the proper kind of true recursion he knows from lisp
11:12:09 <hpc> but he'd say things like lisp invented GC in the 50s because it was designed to require it
11:12:28 <exio4> hpc: one of my teachers asked me (when I suggested immutable data structures / algorithms for a problem) how you could work without mutable, as in, it's nonsense and you can't achieve anything at all that way :( 
11:12:52 <exio4> s/immutable algorithms/"functional algorithms"/
11:12:57 <hpc> man, i wish i knew the right response to that question years ago
11:13:11 <hpc> (the answer is "math is immutable and we get along just fine")
11:13:19 <refefer> hpc: well, it's not that far off.  a couple of decades, but Lisp was the first practical use of GC :)
11:13:33 <JoshieAS> Gurkenglas: I guess I could sort the input list and then end each case in such a way that the root is always on top..
11:13:54 <exio4> hpc: that's pretty much what I suggested and I got "math isn't programming" as an answer
11:14:15 <Gurkenglas> JoshieAS: Is the second element of a pair always less than the first?
11:14:16 <hpc> what the french toast did this teacher teach?
11:14:25 <lamefun> exio4, I mean, it looks I lose almost all the convenience Haskell provides when I start using abstract data structures...
11:14:44 <exio4> lamefun: PatternSynonyms + ViewPatterns to the rescue? ;P
11:14:52 <JoshieAS> Gurkenglas: Yes
11:15:20 <lamefun> and record construction like MyRecord { abc = ..., def = ... }
11:15:40 <hodapp> I dealt with a coworker at a prior job who insisted that in the land of engineering, C++ and Java were so close to the "X equals A plus B" nature of basic mathematics that there was really no need for anything different.
11:16:28 <hpc> haha, you should put those two people in a room and see what they come up with as being the foundation of programming
11:16:54 <hodapp> and another coworker whose view of anything that wasn't C or MATLAB as "What do you need ANOTHER programming language for?"
11:17:01 <hodapp> s/as/was/
11:17:05 <ion> Blub
11:17:15 <dolio> hpc: That's not a very good argument, because mathematicians don't care how well things perform computationally.
11:17:17 <hpc> Visual Blub.NET
11:17:22 <lamefun> I mean I'm new to Haskell and have to resort to GHC extensions already to keep the code sane?
11:17:32 <dolio> And most of them are rather bad about making sure things are computable at all.
11:18:07 <srhb> lamefun: Extensions are nice! Embrace them!
11:18:10 * ion added splitAtTail and splitMiddle for shits and giggles (splitAtTail 3 "hello world" = ("hello wo", "rld"); splitMiddle 7 "hello world" = ("he", "llo wor", "ld")). https://gist.github.com/ion1/bd4c395a54f32bd06f25
11:18:14 <hpc> lamefun: improving record syntax has been a point of contention for the past 20 years
11:18:19 <alexgman123> im having a tough time beginning leksah
11:18:23 <srhb> lamefun: Take out a few key extensions and I wouldn't even care to use Haskell. :P
11:18:23 <hpc> nobody can agree on how to make it better
11:18:40 <mada> Sometimes a haskell programmer will go to an OOP class and say that the best way to solve something is with XYZ haskell/CT/LC feature
11:18:50 <hpc> and the existing version came out of not agreeing on how to make it good in the first place
11:19:21 <hodapp> mada: sometimes, anyone who shows up to an OOP class and proposes that a *better* way to solve something is <X> is probably right
11:19:21 <alexgman123> im wondering if someone has just a few minutes to help me out with starting leksah
11:19:37 <mada> hpc: that doesn't mean it isn't uncalled for.
11:19:54 <Gurkenglas> JoshieAS: [(1, -1), (2, 1), (3, 2), (4, 3), (5, 1)] is another thing even the already defined parts of your code don't handle correctly
11:20:00 <mada> OOP built a ton of software. It's still a running paradigm. Don't those people have a right to improve their ways, to learn them?
11:20:04 <lamefun> "Take out a few key extensions and I wouldn't even care to use Haskell." - uhm...
11:20:12 <mada> To correct their mistakes, to take from other paradigms?
11:20:33 <c_wraith> lamefun: things like RankNTypes make haskell *far* more expressive.  The language is just tougher to use without it.
11:20:41 <mada> How come there isn't people in continental philosophy class screaming every time that "we should actually be paying more attention to the analyticals!!"
11:21:01 <mada> hpc: don't mean to be rude, just something I thought of reading your conversation  :)
11:21:02 <exio4> just naming a few, RankNTypes and GADTs are _really_ powerful 
11:21:32 <hpc> mada: you should take a look at the name of the guy who made java's generics system ;)
11:21:48 <refefer> exio4: and advanced in understanding :)
11:22:04 <ReinH> srhb: Thanks, added https://github.com/reinh/haskell-wishlist
11:22:13 <srhb> ReinH: :)
11:22:17 <mada> hpc: Phil Wadler
11:22:25 <dolio> Some of this is getting pretty off-topic and noisy.
11:22:31 <Gurkenglas> JoshieAS: (Apologies for what feels like spirit-crushing. I'm trying to push you closer to the solution I sneakily posted into the channel long since, with a faint hope that you'll find a better one that stands up to my tests.)
11:22:40 <mada> dolio: sorry about that, cutting it off.
11:23:40 <ReinH> hpc: And C++'s was made by Stepanov: http://www.amazon.com/Mathematics-Generic-Programming-Alexander-Stepanov/dp/0321942043
11:23:47 <hpc> ReinH: TIL!
11:24:21 <ReinH> hpc: This is why I distrust languages that won't add generics for "ergonomic" or aesthetic reasons
11:24:40 <ReinH> they don't understand the power that parametric polymorphism offers
11:25:23 <ReinH> dolio: fair po int
11:25:34 <ReinH> Hyperactive space bar :(
11:25:39 <dolio> Which?
11:25:47 <ReinH> dolio: off-topic and noisy
11:26:07 <ReinH> I did try to bring it back a bit...
11:26:34 <JoshieAS> Gurkenglas: not spirit crushing at all, you've helped me realize I need a total rewrite -- I appreciate the help!
11:26:48 <JoshieAS> Gurkenglas: you posted a solution?
11:27:06 <alexgman123> anyone know why i get this error: http://i.imgur.com/8LR40bW.png ?
11:27:35 <Gurkenglas> JoshieAS: <Gurkenglas> Joshua, get the list of children to -1, get the list of each of their children, repeat, put it all into the data structure appropriate to this case?
11:27:41 <srhb> alexgman123: removeNon... is not of type IO ...
11:27:54 <Gurkenglas> > coiter (map fst . flip filter [(1, -1), (200, 1), (201, 1), (202, 200), (203, 202)] . (. snd) . (==)) $ -1 -- Also already posted, I used this library here: https://hackage.haskell.org/package/free-2.0.2/docs/Control-Comonad-Cofree.html
11:27:55 <srhb> alexgman123: Every expression in a do block must be of the same 
11:27:57 <srhb> monad
11:27:57 <lambdabot>  -1 :< [1 :< [200 :< [202 :< [203 :< []]],201 :< []]]
11:28:14 <srhb> alexgman123: putStrLn is IO, and remove... is []
11:28:20 <azevedo> hi
11:28:31 <ReinH> alexgman123: removeNon returns a list, so the do notation is inferred to be in the [] Monad.
11:28:42 <alexgman123> srhb: thank you, but how would i then display the result of removeNon
11:28:53 <ReinH> alexgman123: use let to bind it to a variable
11:28:55 <srhb> alexgman123: putStrLn . remove... $ string
11:29:01 <ReinH> or inline it
11:29:08 <srhb> alexgman123: or let foo = remove... string; putrStrLn foo
11:29:17 <ReinH> @where fugue
11:29:17 <lambdabot> I know nothing about fugue.
11:29:20 <ReinH> :(
11:29:26 <Gurkenglas> JoshieAS: Wait this link is better, explains more. https://hackage.haskell.org/package/free-4.10.0.1/docs/Control-Comonad-Cofree.html
11:29:29 <ReinH> @quote fugue
11:29:29 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:29:34 <srhb> :D
11:29:55 <ReinH> JoshieAS: what problem are you working on?
11:30:07 <JoshieAS> It's the "Process Tree" Codewars kata
11:30:30 <ReinH> JoshieAS: would you link me please?
11:30:33 <JoshieAS> http://www.codewars.com/kata/52817f04b70058a1b1000037/train/haskell
11:30:36 <ReinH> googling was ineffective. Thanks
11:32:21 <alexgman123> srhb: ReinH: thank you, now i've got this http://i.imgur.com/Mcby25b.png
11:32:45 <ReinH> alexgman123: (btw using a text paste service would be a bit better)
11:32:47 <ReinH> @where lpaste
11:32:47 <lambdabot> http://lpaste.net/
11:32:58 <alexgman123> thanks, i will do that
11:33:01 <ReinH> alexgman123: indentation is wrong
11:33:10 <srhb> alexgman123: let does not work like that
11:33:26 <srhb> alexgman123: Outside of a do block it is let foo = ... in ...
11:33:41 <alexgman123> srhb: apologies, im slightly dyslexic, so reading the textbook/tutorials is not enough for me, i need to do it hands on, thats why i ask
11:33:59 <srhb> alexgman123: Sure.
11:35:05 <Gurkenglas> Weird, why can I apply coiter, but :t coiter doesn't work?
11:35:47 <srhb> Gurkenglas: That seems unlikely!
11:36:02 <Gurkenglas> Wanna bet? Loser gets bragging rights for a day.
11:36:08 <Gurkenglas> *Winner lol
11:36:15 <srhb> Dammit, I wasn't fast enough :P
11:36:35 <srhb> Gurkenglas: Can you paste the session?
11:36:47 <Gurkenglas> Are we betting or not?
11:36:51 <alexgman123> srhb: frustrating. what is the minimum code that i would need inside of a module? do i need all of this stuff? http://lpaste.net/134044
11:36:52 <srhb> Fine!
11:37:07 <Gurkenglas> > coiter (:[]) 1
11:37:10 <lambdabot>  1 :< [1 :< [1 :< [1 :< [1 :< [1 :< [1 :< [1 :< [1 :< [1 :< [1 :< [1 :< [1 :<...
11:37:12 <Gurkenglas> :t coiter
11:37:14 <lambdabot> Functor f => (a -> f a) -> a -> Cofree f a
11:37:17 <Gurkenglas> Dammit!
11:37:27 <JoshieAS> About to have a brown out, will return shortly
11:37:31 <srhb> alexgman123: Minimum depends on the problem! Like, main = putStrLn "Hello World!" -- is a valid, complete Main module
11:37:35 <ReinH> Gurkenglas: :)
11:37:58 <Gurkenglas> I see. In the query, I did @let import Control.Comonad.Cofree only after trying :t coiter.
11:38:26 <alexgman123> what is the purpose of the "do" notation?
11:39:07 <ReinH> alexgman123: That's best explained by a Haskell tutorial, since it involves building up a number of concepts
11:39:26 <alexgman123> ok
11:39:41 <srhb> alexgman123: http://lpaste.net/134044
11:39:50 <ReinH> The purpose of the do notation is to provide a syntactic alternative to, e.g.,
11:39:51 <srhb> alexgman123: Err, http://lpaste.net/134044#a5491991036630663168
11:40:03 <ion> alexgman123: It lets you express certain code in a really nice manner, as a flat structure instead of many nested applications of the >>= operator.
11:40:14 <ReinH> > Just 1 >>= (\x -> return (x + 1))
11:40:16 <lambdabot>  Just 2
11:40:29 <ReinH> so instead you can write do { x <- Just 1; return (x + 1) }
11:40:39 <srhb> alexgman123: Note that the function and one of the mains form a _complete_ Haskell program.
11:41:12 <ReinH> alexgman123: see also http://en.wikibooks.org/wiki/Haskell/do_notation
11:41:35 <srhb> alexgman123: (you have to name it main though)
11:41:55 <alexgman123> srhb: thank you
11:41:58 <alexgman123> ReinH: thank you
11:43:10 <ReinH> Gurkenglas: for the process tree kata I might lean towards using monads for substitution rather than comonads for coiteration
11:43:30 <ReinH> Gurkenglas: e.g., https://dl.dropboxusercontent.com/u/828035/Monads/monads.pdf
11:47:15 <Gurkenglas> I'm too lazy to read that without first being sufficiently embarassed, so I'm just gonna ask here how the data definition I see here https://hackage.haskell.org/package/free-4.10.0.1/docs/Control-Monad-Free.html could possibly lend itself to the problem. After all, no process ids are written onto the intermediate nodes!
11:48:07 * hackagebot socket 0.3.0.1 - A portable and extensible sockets library.  http://hackage.haskell.org/package/socket-0.3.0.1 (LarsPetersen)
11:48:48 <ReinH> Gurkenglas: It's a rose tree. Each node has a PID and a list of children.
11:49:07 <ReinH> This is Cofree [] of course
11:49:33 * Haskellfant puts cofree on the list of things I need to look at
11:49:46 <Gurkenglas> (Mission accomplished.)
11:49:51 <lamefun> c_wraith, but I'm not even doing any highly complicated cutting-edge programming... I simply want color type that doesn't accept invalid components, and still be able to use it comfortably...
11:49:58 <ReinH> but the process of grafting a new child onto a tree is monadic rather than comonadic
11:50:08 <}> Hey, I saw a certain function for monad transformers that allowed you to use lift on a "block", but I can't remember what it was... it looked something like : do a <- get ; lift do { b <- get ; modify ... }, where everything in the second do is in the "inner" monad, does anyone know how to do this?
11:50:25 <Welkin> }: now you just need a partner named {
11:50:33 <srhb> Yeah, it's so disturbing... :P
11:50:35 <c_wraith> }: there's nothing special there, it's just the lift function from MonadTrans
11:50:36 <}> Welkin, @_@
11:50:59 <c_wraith> }: the important part is that do blocks are expressions, and can be treated like any other expression
11:50:59 <}> c_wraith, right , but I can't use lift on a "block", I would have to write it for each operation, every time...
11:51:11 <srhb> }: Wrong.
11:51:13 <}> There was some way to do it but I can't remember
11:51:19 <srhb> }: You can lift a block. You just lift $ do ...
11:51:25 <srhb> }: No magic involved.
11:51:27 <}> srhb, that gives me an error...
11:51:33 <c_wraith> }: or lift (do ..)
11:51:52 <srhb> }: Then you probably don't mean to lift the block.
11:51:56 <c_wraith> lamefun: there are often ways to make it easy to use and correct at the same time.
11:52:03 <Gurkenglas> ReinH, can you illustrate the superior fit of the monadic way with a oneliner to solve the problem?
11:52:11 <ReinH> Gurkenglas: Cofree [] is a tree, but all monads are trees.
11:52:23 <lamefun> c_wraith, what are they?
11:52:25 <}> srhb, uhh...
11:52:26 <ReinH> Gurkenglas: where's your cofree solution?
11:52:50 <lisbeth> Why doesn't this produce a list of all zeven letter words? genku= [ [a:b:c:d:e:f:g[]] | a <- ['a'..'z'], b <- ['a'..'z'], c <- ['a'..'z'], d <- ['a'..'z'], e <- ['a'..'z'], f <- ['a'..'z'], g <- ['a'..'z']]
11:52:51 <Gurkenglas> > coiter (map fst . flip filter [(1, -1), (200, 1), (201, 1), (202, 200), (203, 202)] . (. snd) . (==)) $ -1 -- posted for the third time now :P
11:52:53 <maerwald> ReinH: did I miss some context or did you just mean "all monads are trees"? I am confused
11:52:54 <lambdabot>  -1 :< [1 :< [200 :< [202 :< [203 :< []]],201 :< []]]
11:52:58 <srhb> }: Paste the code, and the error, lpaste.net
11:53:05 <maerwald> I didn't follow the whole discussion
11:54:20 <c_wraith> lamefun: depends on the exact use case.  It often just means creating type structures that are less flat and making convenience functions to assemble them in common ways.
11:54:41 <c_wraith> lamefun: more advanced tricks like the stuff in lens can come into play, too - but that's probably pushing too far.
11:54:47 <c_wraith> lamefun: at least at a beginner level
11:55:14 <Haskellfant> ReinH: could you expand (or provide a link) on how all monads are trees? it isn't obvious to me why that's the case
11:55:45 <srhb> Isn't it the "All Monads are Trees with Grafting" paper?
11:55:49 <ReinH> Haskellfant: https://dl.dropboxusercontent.com/u/828035/Monads/monads.pdf
11:55:55 <ReinH> srhb: yes
11:55:57 <srhb> :)
11:56:04 <Haskellfant> thanks
11:56:34 <c_wraith> Isn't that another way of saying "you can model every monad with the free monad"?
11:56:43 <ReinH> c_wraith: pretty much
11:56:45 <Haskellfant> oh that way it makes sense
11:56:58 <lisbeth> does anyone know?
11:57:02 <}> srhb, I tried to describe the problem : http://lpaste.net/134046
11:57:07 <ReinH> Gurkenglas: Nice solution. Notice how your seed is the initial pid and the list of pid pairs is a part of the coiterative step?
11:57:24 <ReinH> That's an unfold that is dual to a fold over the list
11:57:30 <ReinH> that fold over the list would be the monadic version
11:57:35 <Gurkenglas> Yep. If your solution swaps those positions, I am convinced.
11:57:45 <ReinH> Gurkenglas: well give me a sec :)
11:58:07 <ReinH> Gurkenglas: this is very similar to implementing foldr using foldl :)
11:58:14 <jomg> lisbeth, just '[ [a, b, c, d, e, f, g] | ... ]' should work
11:58:16 <ReinH> er, vice versa, foldl using foldr
11:58:22 <Gurkenglas> Never managed that, and never looked at the solution in case I ever figure it out.
11:58:47 <kristof> ReinH: I accidentally started an argument yesterday because of that Python tuples comment, so I did want to say sorry and that it certainly wasn't my intention to start a fight
11:58:56 <srhb> }: Do you mean b <- lift $ do modify ...; get ?
11:59:00 <Gurkenglas> (...I think. I might have seen it in some very early Haskell tutorial and then forgotten.)
11:59:07 <ReinH> kristof: oh, I forgot about that. Sorry for being harsh, it wasn't directed towards you.
12:00:01 <}> srhb, yes!! that's it, thanks man
12:00:01 <ReinH> Gurkenglas: Let's see here... foldr _go (-1) pids... ;)
12:00:19 <srhb> }: Sure thing.
12:01:06 <ReinH> er, foldr _go (Process (-1) []) pids, one sec
12:01:25 <jomg> }, also, you can leave out the lift by making use of the MonadState (or similar) typeclass
12:01:53 <}> jomg, huh?
12:01:59 <srhb> jomg: These are two layered states though
12:02:08 <jomg> oh, i see
12:02:17 <}> yeah, it's a ...StateT Int (State String) (Int, String)
12:02:21 <}> I think
12:02:51 <Haskellfant> after having noticed } here for a few days, I still get confused everytime I look here and see the nick
12:02:55 <jomg> but why not use State (Int, String) (Int, String) ?
12:03:11 <}> jomg, I'm just trying to use monad transformers
12:03:17 <}> learning that is
12:03:22 <jomg> oh, fair enough :)
12:03:43 <lisbeth> My next question is when I do this: genku= [ if [a,b,c,d,e,f,g] == "gaffc" then "aaaaaab" else "You haven't reached me" | a <- ['a'..'z'], b <- ['a'..'z'], c <- ['a'..'z'], d <- ['a'..'z'], e <- ['a'..'z'], f <- ['a'..'z'], g <- ['a'..'z']]
12:04:13 <lisbeth> then call genku, I don't get the output "aaaab" ?
12:04:51 <lisbeth> Instead I get the near equivelant of cycle "You haven't reached me"
12:05:04 <jomg> lisbeth, before i go on, i feel i should mention you can also express the list of all 7-letter words as 'replicateM 7 ['a'..'z']'
12:05:05 <srhb> h}: Yes, that's the correct type. :)
12:05:08 <dwins> lisbeth: you'll never get "gaffc" in the list of 7-letter strings because it is not a 7-letter string
12:06:16 <lisbeth> sorry. My revised version
12:06:16 <lisbeth> let genku= [ if [a,b,c,d,e,f,g] == "aaaaaab" then "aaaaaab" else "You haven't reached me" | a <- ['a'..'z'], b <- ['a'..'z'], c <- ['a'..'z'], d <- ['a'..'z'], e <- ['a'..'z'], f <- ['a'..'z'], g <- ['a'..'z']]
12:06:47 <}> lisbeth, well aaaaaab will only occur once, so you will mostly see you haven't reached me
12:07:09 <jomg> lisbeth, you should get there eventually, but it will take some time as there are 26^7 possible combinations
12:07:25 <jomg> > 26^7
12:07:27 <lisbeth> Shouldn't it be the second combination?
12:07:29 <lambdabot>  8031810176
12:07:51 <lisbeth> I want it to only output combinations that are equal to "aaaaaab"
12:07:52 <jomg> lisbeth, it seems like it is
12:08:04 <Gurkenglas> > take 3 [ if [a,b,c,d,e,f,g] == "aaaaaab" then "aaaaaab" else "You haven't reached me" | a <- ['a'..'z'], b <- ['a'..'z'], c <- ['a'..'z'], d <- ['a'..'z'], e <- ['a'..'z'], f <- ['a'..'z'], g <- ['a'..'z']]
12:08:07 <lambdabot>  ["You haven't reached me","aaaaaab","You haven't reached me"]
12:08:41 <lisbeth> I want it only to print on successful attempts. Understand what I mean?
12:08:48 <lisbeth> Only print on the true statement.
12:09:16 <tremon> it doesn't print anything. It returns a list of the same size as its your input
12:09:22 <tremon> s/your//
12:09:23 <Gurkenglas> Yes, but if you don't know that there's only one of them you'll still have to go through all 26^7 combinations before your program terminates
12:09:35 <lightstep> hi all, i'm having trouble using the "sdl-ttf", it compiles fine but has linker errors.  can you help me tell if this is a problem with the package or with my system configuration?
12:09:38 <jomg> lisbeth, 'head . dropWhile (/= "aaaaaab") $ genku'?
12:09:40 <lpaste> lightstep pasted “Linking error with sdl-ttf” at http://lpaste.net/134049
12:09:57 <}> this sounds like an XY problem
12:10:02 <}> but what do I know...
12:10:20 <Gurkenglas> > find (=="aaaaaab") $ replicateM 7 ['a'..'z']
12:10:22 <lambdabot>  Just "aaaaaab"
12:10:47 <Gurkenglas> This'll terminate on the first found one, so that works in the case where you only need the first one and you know that it's early in your list.
12:11:21 <Gurkenglas> If you want all instead of the first, substitute filter for find to get [] instead of Maybe.
12:12:04 <Gurkenglas> ReinH, still working on it?
12:12:10 <ReinH> Gurkenglas: yep
12:12:14 <lightstep> if i change my program to only import modules from the package but not actually use any functions from them, the link error disappears
12:13:10 <Gurkenglas> (I just marveled at the OCD-happy coincidence that the end of my nick in Reins post and the end of his nick in my post coincided. Then I duh'd.)
12:14:52 <Gurkenglas> lisbeth, read my posts of timestamp [:09 .. :10], for I haven't included your nick in them.
12:16:54 <}> > sequence [['a'..'z']] -- Speaking of ReplicateM ... this was very helpful for me to understand how sequence and replicateM works
12:16:55 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
12:19:03 <lisbeth> Thanks. goodnight fellas
12:19:22 <voidzero> :t ["a"]
12:19:23 <lambdabot> [[Char]]
12:19:46 <voidzero> :t ['a']
12:19:48 <lambdabot> [Char]
12:23:48 <CurryWur_> how to rewrite filter using bind and return?
12:24:22 <CurryWur_> (a -> Bool) -> [a] -> [a]
12:27:53 <}> > [1..10] >>= \x -> guard (5==x) >> return x -- CurryWur_ something like this?
12:27:55 <lambdabot>  [5]
12:28:06 <jomg> filter p l = l >>= \ e -> if p e then return e else []
12:28:09 <jomg> works too
12:28:46 <jomg> doing pretty much the same thing, actually
12:28:50 <SparkySparkyBoom> how do i convert `i` so this works?
12:28:56 <SparkySparkyBoom> let i = 1 :: Int
12:29:02 <SparkySparkyBoom> sqrt ((100 * i) + 0.25)
12:29:11 <jomg> SparkySparkyBoom, fromIntegral
12:29:23 <CurryWur_> thanks!
12:30:21 <koala_man> if I have [[1,2], [3,4]], how do I generate the lists of taking one element from each, i.e. [[1,3], [1,4], [2,3], [2,4]]? I wrote it out but I feel like there's a simple fold or something
12:31:02 <jomg> > sequence [[1, 2], [3, 4]]
12:31:06 <}> > sequence [[1,2],[3,4]]
12:31:06 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
12:31:10 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
12:31:12 <koala_man> lmao
12:31:12 <jomg> heh
12:31:12 <}> ow
12:31:17 <GLM> What is the best way to learn about the special infix operators like >>=? Google isn't the best at parsing those kinds of things
12:31:18 <SparkySparkyBoom> jameseb: thanks
12:31:19 <ronh-> jomg it is less general though
12:31:26 <srhb> GLM: They are not special
12:31:36 <SparkySparkyBoom> jomg: *
12:31:45 <}> koala_man, did you see the example I did with sequence [['a'..'z']] just a minute before?
12:31:52 <srhb> GLM: You should do the cis194 course, it's part of basic monad usage. Also use hoogle and search with them in paranthesis
12:32:00 <koala_man> }: nope
12:32:03 <}> ow
12:34:06 <Gurkenglas> Why does the channel still talk about sequence when there's sequenceA?
12:34:19 <jomg> Gurkenglas, it's one more character!
12:34:31 <jomg> (though you're probably right)
12:35:16 <}> jomg, because applicatives are more general?
12:35:39 <jomg> yea
12:35:49 <Gurkenglas> Yep, sequence does nothing that needs monads over applicatives.
12:36:06 <jomg> and exists only as a byproduct of history
12:36:32 <sinelaw> @type sequence
12:36:34 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:37:04 <}> Is it important to understand free monads? I'm not really sure where they're useful
12:37:59 <jomg> }, no idea, they're one more thing on the long list of things i need to read about :)
12:38:31 <}> jomg, I guess it's not very important then... it seems they're just monads without the ability to join m (m a) -> m a, which allows you to turn functors into free monads
12:38:55 <GLM> srhb:Working on assignment 2 now
12:39:16 <srhb> GLM: In that case, rest assured you'll get there. :-)
12:41:51 <ReinH> Gurkenglas: I admit that the coiterative method is much easier to implement. My way requires tying the knot and is not at all fun.
12:43:26 <ReinH> Gurkenglas: or possibly there's an elegant method that I'm too stupid to find :)
12:43:30 <Gurkenglas> Let me see it. I fail to see how folding over the list can do this in the first place - wouldn't you look at each element only once? Do you sort the list by snd, then do a modification on the tree for each element in the list?
12:43:39 <ReinH> Gurkenglas: I'm still working on it :)
12:44:54 <Gurkenglas> Ooh, maybe you keep a forest of fatherless nodes so you don't have to sort first...
12:45:26 <MarcelineVQ> There's some kind of metaphor for modern society in there
12:45:46 <ReinH> Gurkenglas: the guarantee that pid > ppid means sorting *does* work
12:47:17 <ReinH> Gurkenglas: I think a paramorphism would also work, although it has the bad habit of traversing the list too many times
12:47:20 <ReinH> (but so does yours ;)
12:48:08 <ReinH> (A paramorphism would work because the parent is either in the process tree or in the rest of the list)
12:48:22 <SparkySparkyBoom> how does one convert a RealFloat to an Int?
12:48:25 <SparkySparkyBoom> i tried truncate
12:48:33 <ReinH> :t round
12:48:35 <lambdabot> (Integral b, RealFrac a) => a -> b
12:48:40 <Gurkenglas> *google paramorphism* <.<
12:48:43 <Gurkenglas> *s
12:48:45 <ReinH> SparkySparkyBoom: depends on how you want to truncate it
12:48:53 <ReinH> Gurkenglas: a foldr that also gives access to the rest of the list
12:49:16 <SparkySparkyBoom> like truncate, ceiling, round etc?
12:49:44 <SparkySparkyBoom> :t atan2
12:49:46 <lambdabot> RealFloat a => a -> a -> a
12:50:04 <ReinH> Gurkenglas: para f z [] = z; para f z (x:xs) = f x xs (para f z xs)
12:51:15 <eatz> :t ($=)
12:51:17 <lambdabot>     Not in scope: ‘$=’
12:51:18 <lambdabot>     Perhaps you meant one of these:
12:51:18 <lambdabot>       ‘$!’ (imported from Prelude), ‘/=’ (imported from Data.Eq),
12:52:24 <Gurkenglas> para f z l = foldr f z $ tails l
12:52:32 <Gurkenglas> Right?
12:53:01 <ReinH> Gurkenglas: no, para  c n = snd . foldr (\ x (xs, t) -> (x : xs, c x xs t)) ([], n)
12:53:10 <ReinH> Gurkenglas: (see http://stackoverflow.com/questions/13317242/what-are-paramorphisms)
12:53:17 <ReinH> pigworker, as usual, provides an excellent answer
13:00:36 <Gurkenglas> Using f x xs (para f z xs) sounds isomorphic to using f (x:xs) (para f z xs) (you only have to apply \f -> (uncurry f) . headTail with a special case for the empty list) and at that point where does your definition differ from mine?
13:00:55 <Gurkenglas> *ReinH
13:02:34 <Gurkenglas> *have to apply \... to the left f to get the right f. I feel like I'm starting to speak too arcanely, I can rewrite that if you want
13:06:17 <lpaste> Gurkenglas pasted “para via tails” at http://lpaste.net/134052
13:08:53 <ReinH> Gurkenglas: yeah, you have to do a bit of extra work
13:09:02 <ReinH> to provide x and xs to f properly
13:09:06 <ReinH> as you did
13:10:57 <teurastaja> i heard a group minus invertibility is a monoid. i also heard a list is a group where order matters. any explanations? (im not an expert)
13:11:13 <teurastaja> id like to know the difference between a group and a list
13:11:52 <teurastaja> i know the list is a monad and im not too familiar with groups. are the monads also?
13:12:00 <kristof> teurastaja: If you think about abstract algebra, a group is a set of things that you have an operation on, and an inverse operation.
13:12:39 <kristof> teurastaja: That operation is usually taken to mean "combining". In abstract algebra, some of the most common groups you analyze are finite groups of numbers in modular arithmetic (Z_n), matrices, etc.
13:13:23 <kristof> teurastaja: That inverse operation then means to "take away". But if you can't always take away, then all you've got is combining. Well, a monoid represents precisely that; something you can combine but it's not guaranteed you can take away.
13:13:52 <teurastaja> i heard lists were permutations while groups were combinations. is that true?
13:14:13 <kristof> I guess you can look at it that way but it doesn't really help or matter.
13:14:42 <kristof> There's never been a situation where I thought "Hmm, I was using a group, but that's like a combination, but what I really need is a permutation... aha! I need a list!"
13:15:00 <teurastaja> what is a list with respect to a monoid?
13:15:20 <koala_man> lists form a monoid under concatenation
13:15:25 <kristof> ^
13:15:30 <kristof> That's it, nothing else to see.
13:15:52 <kristof> I like to explain monoid to people coming from OO as ICombinable.
13:17:00 <kristof> teurastaja: I guess there's another relationship. If you have Monoid m => [m]... then folding is possible, and also parallelizable
13:17:38 <kristof> Ever heard of fork-join? Monoids have the property that the joins can happen associatively. Woo! par it up
13:17:51 <teurastaja> so the difference between a group and a list is the operation of concatenation versus the operation of inverse?
13:18:07 <teurastaja> fork-join? nope
13:18:15 <ReinH> teurastaja: there isn't a difference between a group and a list. groups and lists are not comparable
13:18:29 <ReinH> a list is a data structure, a group is an algebraic structure
13:18:38 <ReinH> they are different categories of things
13:18:39 <kristof> They represent two entirely different classes of things.
13:18:49 <itsMontoya> I'm trying to create a fn which gets the last four integers from a list. Can you guys tell me if I'm on the right track?
13:18:50 <itsMontoya> https://gist.github.com/itsmontoya/ab672065c9d1c6600e1d
13:18:58 <kristof> A data structure is usually a concrete example of something more abstract.
13:19:04 <ReinH> a group is a monoid with an inverse operation
13:19:04 <teurastaja> data structure vs algebraic structure?
13:19:41 <ReinH> @google algebraic structure
13:19:42 <lambdabot> http://en.wikipedia.org/wiki/Algebraic_structure
13:19:43 <lambdabot> Title: Algebraic structure - Wikipedia, the free encyclopedia
13:20:17 <ReinH> a group isn't like a list, a group is like a monoid
13:20:54 <Gurkenglas> itsMontoya: consider lastFour [1,2,3,4,5].
13:21:04 <kristof> teurastaja: Algebra is the study of algebraic structures. Algebra asks the question "if I have this minimal set of things that satisfies certain qualities, what kind of things can I prove?" So you might study groups (set of things with a binary associative operation and an inverse), vector spaces (a group with scalar multiplication over a field), etc.
13:21:13 <itsMontoya> Gurkenglas: Bahah, that's actually where I just hit an error :(
13:21:14 <teurastaja> but both are comparable to monoids...?
13:21:41 <kristof> teurastaja: So if I prove a lot of things about vector spaces, then I prove something is a vector space, then anything I have proved about vector spaces applies to that thing I proved is a vector space.
13:21:45 <ReinH> monoids, groups, and vector spaces are examples of algebraic structures
13:21:53 <itsMontoya> Gurkenglas: Is the general approach (although incomplete) ok? Or is there a better way to tackle this?
13:22:40 <Gurkenglas> itsMontoya: Do you want gentle pushing in the right direction, or a listing of possible solutions?
13:23:03 <the-kenny> Hello. Can someone point me to a blog post or similar on how to encode 'numerical' data properly? For example, I have a computation on points (latitude, longitude) but in some parts I need to convert degrees to radians. How can I model this so leaving out this conversion results in a type error? (My current approach uses `type Degrees = Double & type Radians = Double`).
13:23:15 <itsMontoya> I think gentle pushing, though whatever method you think is most conducive to learning would be appreciated
13:23:17 <kristof> teurastaja: A monoid is an algebraic structure. I prove things about monoids. Now I say that lists under concatenation are a monoid. Bam! I've got all my monoid theorems / functions for free.
13:23:25 <Gurkenglas> (Where "right direction" is of course ambigious and depends on whether you're doing this for an exercise given by some website or tutor, or trying to actually get the last four elements to solve a problem.)
13:23:56 <the-kenny> One approach I know is `data Degrees a = Degrees a' etc. but this gets rather cumbersome when I have to pass 'a' through different data types.
13:23:57 <itsMontoya> Gurkenglas: Very true! I'm following the cis194 course
13:24:12 <itsMontoya> Gurkenglas: So I'm trying to do this exercise without imports as imports haven't been introduced yet in the course
13:24:35 <itsMontoya> So although I'm not a student, I'm trying to follow the course as if I was taking the class
13:25:03 <Gurkenglas> Have length or take been introduced?
13:25:15 <Gurkenglas> (Or reverse?)
13:25:26 <Gurkenglas> How are you supposed to handle a list of <4 elements?
13:25:51 <itsMontoya> Length hasn't, but I've used reverse in my hw
13:26:09 <Gurkenglas> Reverse should make this task simple.
13:27:40 <teurastaja> ok so what are groups useful at?
13:28:04 <itsMontoya> Oh you know what.. you are totally right. 
13:28:17 <itsMontoya> Gurkenglas: I just got it working without reverse. But I think reverse would make it MUCH cleaner
13:28:43 <itsMontoya> I'll show you what I got working before I change it though
13:28:44 <itsMontoya> https://gist.github.com/itsmontoya/ab672065c9d1c6600e1d
13:29:14 <ReinH> Gurkenglas: the pre-sorting version http://lpaste.net/7485732258641346560
13:30:35 <ReinH> Gurkenglas: not a clever one liner though :(
13:31:04 <ion> itsMontoya: Here’s a useful trick: if you iterate over xs and (drop n xs) simultaneously, you’ll reach [] in the latter list when there are exactly n elements left in xs (given an xs that is at least n elements long).
13:31:19 <itsMontoya> ion: OH!
13:31:21 <itsMontoya> Oh oh oh
13:32:14 <joneshf-laptop> ReinH, i think it's just a problem better suited for comonads than monads
13:32:15 <athan> bitemyapp: What's the thing to be released? o.0
13:32:30 <itsMontoya> ion: So that would be faster than doing what I'm doing?
13:32:38 <itsMontoya> By recursively calling the function until I hit 4?
13:32:51 <Gurkenglas> joneshf-laptop: He was currently trying to convince me that the problem is better suited for monads than comonads ^^
13:32:58 <ReinH> Gurkenglas: :p
13:33:18 <ReinH> Gurkenglas: All I said was that I would have tried a monadic solution because it looks like tree grafting
13:33:29 <Gurkenglas> As I thought. You sort the list and modify the tree for each pair
13:33:44 <ion> itsMontoya: It would let you parameterize the n and involve less repetitive code. As a secondary property, it would have to do fewer pattern matches at every step but that is just a small constant factor.
13:33:55 <bitemyapp> athan: :)
13:34:05 <itsMontoya> ion: Yea I like that, sounds like it will be a cleaner implementation 
13:34:21 <itsMontoya> I just need to figure out how to approach that
13:34:24 <ReinH> Gurkenglas: yes, it's the "obvious" solution
13:34:26 <bitemyapp> athan: probably wouldn't be anything too exciting for you personally
13:34:47 <itsMontoya> ion: Do you know of any places that have a rough example of that I could look at?
13:34:57 <itsMontoya> ion: Just something using drop n in any way
13:35:02 <ReinH> Gurkenglas: and I was wrong about that, it isn't tree grafting.
13:35:05 <Gurkenglas> ReinH, I was hoping you wouldn't sort the list, but instead fit the pairs together like puzzle pieces
13:35:10 <ReinH> it's just straight up corecursion
13:35:44 <ReinH> Gurkenglas: I had hoped so too, I think you were just right about it being comonadic
13:36:23 <ReinH> it isn't really a grafting problem
13:36:28 <Gurkenglas> Tree grafting is the name of what I said last? Huh. "Corecursion"?
13:37:16 <ReinH> http://en.wikipedia.org/wiki/Corecursion
13:37:36 <ReinH> starting from a base case and building up rather than breaking down towards a base case
13:37:55 <ReinH> the base case is Process (-1) []
13:38:03 <kristof> Streams! Infinite generators!
13:38:09 <ion> itsMontoya: I have a straight spoiler for this question in a gist (which also includes things like “get the middle n elements of a list”), but i probably should give just a hint first before linking that. You can iterate over two lists at the same time like “f (a:as) (b:bs) = _ (f as bs); f as bs = _”
13:38:33 <ReinH> kristof: comonads!
13:38:38 <kristof> What else is corecursive? Lindenmayer systems!
13:38:40 <ion> itsMontoya: You can fill in the holes to get the behavior you want.
13:38:46 <kristof> That's actually my favorite example.
13:38:47 <kristof> ReinH: Huh?
13:38:51 <itsMontoya> ion: Hmm
13:38:51 <Gurkenglas> So it's what this CS class called dynamic programming?
13:38:55 <monochrom> is "x = 0 : x" corecursive?
13:39:07 <Gurkenglas> Solving the word problem for context-free grammars!
13:39:31 <ReinH> kristof: L-systems are neat. Thanks for reminding me that I wanted to write a program for generating them in Haskell.
13:39:42 <Gurkenglas> As opposed to ntext-cofree grammars, which is solved recursively. </blah>
13:39:47 <kristof> ReinH: Oooooh, please notify me on any progress done on that
13:40:12 <kristof> ReinH: Hey, here's a cool use of L-Systems for programmatically generating realistic cities
13:40:30 <ReinH> Gurkenglas: :p
13:40:44 <ReinH> monochrom: yes?
13:41:26 <kristof> ReinH: Actually, I can't find it, but here's something close (page 13) http://gamesitb.com/SurveyProcedural.pdf
13:42:07 <ReinH> kristof: Cofree Identity is a stream
13:42:47 <kristof> ReinH: Well that makes sense, doesn't it?
13:42:54 <ReinH> Yes.
13:43:10 <itsMontoya> ion: “f (a:as) (b:bs) = _ (f as bs); f as bs = _” So in this example. as and bs are lists, right?
13:43:13 <kristof> Oh. Oh! You were answering my question.
13:43:24 <itsMontoya> ion: I'm going to try and break down your example bit by bit to make sure I'm comprehending
13:43:45 <ion> itsMontoya: Yes. In the latter definition of f, one or both of as and bs are the empty list.
13:44:13 <ReinH> kristof: Cofree n is an infinite n-ary tree, so Cofree 1 is an infinite 1-ary tree :)
13:44:33 <ion> itsMontoya: If you apply f to xs and (drop n xs), when bs is [], as will contain zero to n elements.
13:44:35 <kristof> ReinH: But I don't think it's helpful to think about corecursion and comonads together in the same way that it doesn't help to think about monads and recursion
13:44:40 <kristof> ReinH: Oh, that's actually pretty nifty.
13:45:10 <athan> bitemyapp: Aww cmon spill the beans! :D
13:45:18 <bitemyapp> athan: nope
13:45:20 <itsMontoya> ion: But how will you know when you are at a certain number of elements?
13:45:24 <itsMontoya> ion: Like in this example, 4
13:45:25 <ReinH> well, not necessarily infinite, since Cofree Maybe is a possibly-finite nonempty list and Maybe = 0 + 1 = 1
13:45:57 <kristof> ReinH: I wonder, is there any way to express Cofree as a mathematical operator on types in the same way that derivatives are one-hole contexts
13:46:17 <ion> itsMontoya: Just by the virtue of reaching the second definition because the shorter input list was exhausted.
13:46:19 <ReinH> kristof: Interesting question. You should post on StackOverflow and fire up the pigworker signal
13:46:21 <kristof> So if cofree 1 = 1 / 1 - a ....
13:46:32 <kristof> What does that make cofree? :P
13:47:34 <kristof> ReinH: To this day, that fact about derivatives and the algebraic representation of ADTs surprises me
13:47:36 <itsMontoya> ion: I feel dumb, I'm just scratching my head :/
13:47:52 <itsMontoya> ion: I think this approach might be over my head a bit still
13:48:00 <ReinH> kristof: it's pretty exciting, isn't it
13:48:15 <ReinH> the fact that it not only works out, but that you can actually do useful stuff with it
13:48:22 <kristof> Yeah
13:48:35 <joneshf-laptop> ReinH, haha, the pigworker signal
13:48:49 * joneshf-laptop needs one of those
13:48:58 <kristof> ReinH: I thought about it a little more when I first heard about it. Integrating a type would give you another type for which your type is the one-hole-context for, but that's not really useful, is it?
13:49:36 <GLM> Is there a better or more efficient way to do this? https://gist.github.com/anonymous/9a97f988367eafe73224
13:50:14 <ReinH> kristof: There's lots of stuff in https://pigworker.wordpress.com/2015/06/06/hasochistic-containers-a-first-attempt/ that I haven't even begun to integrate yet. Pun intended.
13:50:16 <joneshf-laptop> kristof, something i've been considering lately about that is that maybe we really don't understand derivatives/integrals generally enough yet
13:50:41 <joneshf-laptop> kristof, like, maybe we understand them reallyw well in certain areas
13:50:42 <ReinH> kristof: (Which was published today)
13:50:47 <ion> itsMontoya: Try to evaluate this by hand step by step: ‘let f (a:as) (b:bs) = f as bs; f as bs = (as, bs) in f "hello" "bye"’, 
13:50:58 <ReinH> kristof: nothing about integration though
13:51:17 <itsMontoya> ion: Ok I'll give it a shot right now
13:51:17 <kristof> joneshf-laptop: Tell that to the geniuses working on differential algebra
13:52:20 <athan> bitemyapp: :c
13:52:23 <athan> look at that face
13:52:31 <joneshf-laptop> kristof, maybe i'm wrong then :)
13:52:58 <bitemyapp> athan: it won't really affect you as much as it would new people and you'll find out soon enough anyway.
13:53:02 <felixn> GLM: I think if you made them sets instead of lists, or had sorted lists, it could be faster, but that's the same as core uses http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#intersect
13:53:14 <kristof> joneshf-laptop: There was an explanation in that paper "The Derivative of a Type is the Type of its One-Hole Context" that talks about WHY it works
13:53:18 <albeit> ByteString.Lazy says append is O(n/c). What are n and c?
13:53:26 <ReinH> kristof: http://boegel.kejo.be/ELIS//Haskell/HaskLS/ hmm
13:53:39 <ion> itsMontoya: The first step: f "hello" "bye" = f ('h':"ello") ('b':"ye") which matches the first case, thus = f "ello" "ye" by the definition.
13:53:41 <GLM> felixn:Isn't that a bit slow? It is n^2 after all
13:53:46 <ReinH> albeit: number of chunks, I suppose
13:54:20 <felixn> GLM: set would be a better data structure for this, look ups are O(1)
13:54:46 <itsMontoya> ion: On ok, and next step would be f('e':"llo") ('y': "e")?
13:54:52 <albeit> ReinH: Number of chunks in the combined ByteString? I though it would be O(1) because isn't it basically just connecting two linked lists?
13:54:54 <ion> itsMontoya: yes
13:55:01 <felixn> GLM: https://wiki.python.org/moin/TimeComplexity
13:55:08 <GLM> Would it still be more efficient to take that approach in addition to converting a list to a set?
13:55:24 <Gurkenglas> ReinH, your monadic solution traverses the whole tree except for the subtree of the modified node. At that point, wouldn't it be cleaner to traverse it all?
13:55:27 <ReinH> albeit: it walks the list of chunks
13:55:32 <ReinH> and adds a new chunk at the end
13:55:43 <ReinH> append xs ys = foldrChunks Chunk ys xs
13:55:52 <athan> bitemyapp: :|
13:55:58 * athan twiddles thumbs
13:56:00 <itsMontoya> ion: So what I'm a little confused on is how I would use that to see when there are 4 items left. Because wouldn't the second list need to be the length of the first list - 4?
13:56:01 <albeit> Ahhh okay. So n/c ~ number of chunks in ByteString being appended
13:56:15 <albeit> Thanks
13:56:19 <ReinH> Gurkenglas: (that solution isn't really monadic, just recursive rather than corecursive)
13:56:36 <felixn> GLM: I think so, but the overhead would only be worth it for larger sets.  it would be O(n) to convert each list to a set, then another O(n) to intersect
13:56:41 <ion> itsMontoya: Given length xs >= 4, length (drop 4 xs) = length xs - 4
13:57:19 <ion> @check \xs -> (length xs >= 4) ==> (length (drop 4 xs) == length xs - 4)
13:57:25 <lambdabot>  +++ OK, passed 100 tests.
13:57:27 <felixn> GLM: you could switch if length list > 100 or something, whatever you benchmark to be the tipping point :D
13:57:39 <Gurkenglas> Aw. Can I see a monadic solution to some problem? Or, better, maybe some problem where I'll probably first see the monadic solution?
13:57:40 <ReinH> Gurkenglas: I'm not sure what you mean by traverse it all. There are two cases: add a child when the correct parent is found, or continue traversing until you find the right parent
13:58:10 <ReinH> Gurkenglas: I'm not sure there's a good monadic solution to the problem. I was wrong about it being a good fit.
13:58:43 <bitemyapp> athan: not my project to announce mate ;P
13:58:46 <ReinH> Gurkenglas: now, *killing* a process might have a nice monadic solution ;)
13:58:52 <Gurkenglas> That's why I'm now asking for a monadic solution to *any* problem
13:59:10 <Gurkenglas> ReinH, If in a binary tree of depth 10 the right parent is 5 nodes down, you stop looking there, but all the other branches of your search don't know that you found something and continue to the leaves.
13:59:33 <ReinH> Yes, it stupidly traverses the full tree each time
14:00:03 <Gurkenglas> ...except for the subtree of the node where you found something. Which suggests that one could traverse all of it at that point, which might simplify the code
14:00:11 <Gurkenglas> Like, this sounds like one can use the functor instance
14:00:44 <ReinH> Gurkenglas: fmap can't add the child to the list
14:00:47 <ReinH> traverse could
14:02:04 <Gurkenglas> That it can't add the child is what I also thought, but it seemed like the sort of problem that can be solved with a slight tweaking of the data structure
14:02:26 <fm75> Hi all
14:02:33 <itsMontoya> ion: Hmm
14:02:43 <Gurkenglas> I also thought of traverse first, but didn't see through the type signatures Data.Traverse provides
14:02:51 <ReinH> GLM: you can do it in n log n if you sort the lists first
14:02:57 <fm75> What environment do you use for developing? Haskell-platform, nix, other?
14:03:02 <athan> bitemyapp: I'm excited to see it, whatever it is :)
14:03:08 <itsMontoya> ion: I might just need to look at your spoiler so I can try to break it down when I see it :/
14:03:19 <athan> I'm thinking about a GUI to (typed) lambda calc in general, for ltext
14:03:20 <GLM> ReinH:Thanks. I just wanted to make sure it had the same complexity as that in prelude
14:03:27 <athan> click-and-drag to the max
14:04:41 <ReinH> GLM: intersect in the prelude is O(nm)
14:04:50 <ReinH> it checks each element of n against each element of m
14:05:11 <ReinH> You can only use the optimization on members of Ord, while intersect only requires Eq
14:05:23 <ReinH> also note that it isn't stable
14:05:49 <ReinH> (since it obviously works by sorting the lists first)
14:05:51 <ion> itsMontoya: Here you go. https://gist.github.com/ion1/bd4c395a54f32bd06f25
14:06:15 <Gurkenglas> How would you do that with traverse?
14:06:42 <ReinH> Gurkenglas: actually, you can't... you need... (>>=) I think.
14:06:52 <ReinH> since that's where the grafting comes in
14:07:07 <felixn> fm75: Atom editor has really good Haskell integration, I just installed ghc through homebrew on Mac
14:08:20 <ReinH> Gurkenglas: something like ps >>= (\p -> if p == p2 then [[p],ps] else [ps])
14:08:21 <Gurkenglas> ReinH, but Cofree [] doesn't have a Monad instance
14:08:29 <fm75> felixn: interesting... I tried atom as well with not much success. :|
14:08:56 <ReinH> Gurkenglas: the building up is comonadic, the grafting onto existing nodes is monadic, there's a bit of both
14:09:25 <GLM> ReinH:Any stylistic concerns with my code?
14:09:41 <felixn> fm75: Atom was really slow at first, it's still kind of slow but all the Haskell integrations make it extremely usable ... I setup Vim with some Haskell integrations, didn't really like it
14:09:58 <ReinH> GLM: you've reinvented a few things, but you did so cleanly
14:10:00 <ReinH> @src intersect
14:10:00 <lambdabot> intersect = intersectBy (==)
14:10:02 <ReinH> woops
14:10:07 <ReinH> @src intersectBy
14:10:07 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
14:10:19 <ReinH> and your definition are equivalent
14:10:24 <itsMontoya> ion: Can you explain the "go"?
14:11:03 <ion> itsMontoya: It’s the same as “f” above.
14:11:09 <itsMontoya> OH
14:11:10 <GLM> ReinH:I figured there was a cleaner way to check if a value was in a list
14:11:18 <fm75> felixn: ok... I will give it another try - My problem was that it was not really working (no errors displayed in files full of errors + autocomplete simply not working at all)
14:11:22 <ion> itsMontoya: Well, almost the same. The second case discards the “bs”.
14:11:39 <ion> (which is [])
14:12:08 <ReinH> intersect xs ys = filter (`elem` ys) xs
14:12:13 <felixn> fm75: try with the latest GHC & ghc-mod, it may be all ironed out now >_<
14:13:59 <itsMontoya> ion: And where is as and bs declared?
14:14:03 <itsMontoya> I see xs is the inbound [a]
14:14:17 <ReinH> GLM: for the O(max(n,m)) version on ordered lists, see https://hackage.haskell.org/package/data-ordlist-0.4.7.0/docs/Data-List-Ordered.html#v:isect
14:14:51 <ion> itsMontoya: “takeTail n xs = go xs (drop n xs)” passes two parameters to go, which then pattern matches against them and parts of them end up in as and bs.
14:15:49 <itsMontoya> It passes xs and drop n xs, right?
14:15:52 <ion> itsMontoya: yes
14:15:55 <itsMontoya> OH OH OH 
14:16:09 <itsMontoya> So you don't care what you are dropping persay, you are just getting xs-4
14:16:52 <ion> itsMontoya: Exactly
14:16:52 <ion> It’s basically using the second list as a Peano numeral.
14:17:15 <itsMontoya> Yea, ok ok! I think it's clicking
14:17:33 <itsMontoya> Then you iterate through both, when you hit the end of bs, you know you are on the last 4 of as
14:17:36 <itsMontoya> and then you return as
14:17:49 <ion> Which is also going on in the takeMiddle example which subtracts n (drop n) and then divides by two (pattern match (_:_:bs) repeatedly).
14:18:12 <ion> To clarify the text: which subtracts n (by calling drop n)
14:18:24 <itsMontoya> Ahh this is a neat trick
14:18:33 <itsMontoya> I'm guessing this is much faster than my approach too
14:18:50 <itsMontoya> For takeTail, vs what I was doing before
14:19:15 <ion> Not much faster, just a small constant factor. Their asymptotic complexity is the same.
14:21:58 <SrPx> Okay, yesterday you told me any recursive datatype can be flatened into a single recursive relation. So, for Data.Tree, we have: T = a * L (T a) + 1 ... inlining L (List), we have T = a * (T a * L (T a) + 1) + 1... which is T = a * a * T a * L (T a) + a + 1 ... well, L is still there, of course. I'm confused...
14:22:15 <arkeet> @where sneaky
14:22:16 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
14:22:32 <arkeet> similar use of drop 
14:25:25 <SrPx> If I can just magically replace L (T a) by just T a, then...
14:26:53 <SrPx> T a = a * T a * T a + a + 1, which tells me "data Tree a = Node a [Tree a] | Nil" is isomorphic to "data Tree a = Node a (Tree a) (Tree a) | Leaf a | Nil". Does that make sense?
14:27:46 <itsMontoya> ion: Thank you so much for taking the time to walk me through that
14:27:53 <ion> itsMontoya: no problem
14:37:09 <Pamelloes> Is there a way to create a type Width::Int -> * and then a type Row [Width] where the list can have any number of elements as long as their integer parameter sums up to 100?
14:39:16 <nullx002> hai all
14:39:55 <Pamelloes> HI!
14:40:14 <nullx002> hi pamelloes 
14:40:20 <pavonia> Pamelloes: You mean encoded in the type?
14:42:20 <Pamelloes> pavonia: Yeah. Sorry for my notation, I'm not very confident in how to write kind-level parameters. Basically I want  to have a list with types of Width 0, Width 25, Width 20, Width 55 and then be able to call that type a Row (because all the type parameters sum to 100). But if the first Width was a Width 1, then creating a Row from the elements would be a type error.
14:43:32 <pavonia> I guess you could do that with a custon Integer type, a custom List type and a lot of type family/type class hackery
14:43:48 <pavonia> But using smart constructors is probably the easier way
14:44:05 <Pamelloes> What are smart constructors?
14:44:41 <pavonia> https://wiki.haskell.org/Smart_constructors
14:52:01 <ReinH> Huh, so an L-System is actually just an explicit pairing up of the arguments to (>>=)
14:52:55 <Pamelloes> pavonia: So I read the article and if I'm understanding correctly, you're saying I should follow the first approach where the check is at run time vs what I was asking was for the second approach where the check is compile time
14:55:18 <pavonia> Pamelloes: Yes. I'm not saying the runtime check is the better one, though, it's just easier to implement
14:56:15 <Pamelloes> Alright, OI'm glad I understand then. I already have a form of runtime check in place (it is by far easier to implement) so that's why I was asking about moving it to compile time :)
14:57:02 <rui> Is there any measure of popularity, downloads, etc, of hackage packages?
14:57:15 <Pamelloes> I think the approach I outlined earlier was infeasible (though not impossible) so I'm going to play around with a few alternatives.
14:57:39 <Pamelloes> rui: Hackage publishes the amount of total downloads and monthly downloads in the contents page of each package
14:58:29 <Pamelloes> rui: e.g. lens ( https://hackage.haskell.org/package/lens ) has 113,808 downloads with 2168 in the past 30 days
14:58:42 <MarcelineVQ> rui, each package has a download count, and how often it's been downloaded in the last 30 days, whether thats exposed in a searacble way or not idk
14:58:56 <rui> Pamelloes: Ah, thanks, hadn't seen it!
14:59:12 <Pamelloes> np
14:59:43 <rui> MarcelineVQ: Thanks.. It would be nice if it is searchable
14:59:48 <pavonia> Pamelloes: If you really want to use type-level asserations, you can probably use the HList package which has type-level lists, natural numbers and addition, as far as I can see
15:00:12 <Pamelloes> pavonia: Cool, I'll look into it :)
15:03:20 <Pamelloes> Hm I wonder if it would be better to create a function along the lines of addWidth :: Row x -> Width y -> Row (x+y) and then build the Row one Width at a time rather then from a list. Then the type check would be much simpler
15:05:02 <MarcelineVQ> rui: here you are http://hackage.haskell.org/packages/top
15:05:40 <MarcelineVQ> it doesn't list downloads per month, but it's better than nothing
15:07:59 <voidzero> > B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97] 
15:08:04 <lambdabot>      Not in scope: ‘B.pack’
15:08:04 <lambdabot>      Perhaps you meant one of these:
15:08:04 <lambdabot>        ‘BS.pack’ (imported from Data.ByteString),
15:08:14 <voidzero> > BS.pack [99,104,105] `mappend` BS.pack [104,117,97,104,117,97] 
15:08:17 <lambdabot>  "chihuahua"
15:08:44 <MarcelineVQ> :o
15:09:06 <voidzero> I was just reading lyah again... http://learnyouahaskell.com/for-a-few-monads-more
15:09:17 <voidzero> The output on there is slightly different:
15:09:24 <voidzero> Chunk "chi" (Chunk "huahua" Empty)
15:09:37 <maerwald> then the show instance probably changed
15:09:54 <voidzero> yeah? Or mappend?
15:10:31 <indiagreen> or voidzero's bytestrings are lazy
15:11:56 <rui> MarcelineVQ: Wonderful
15:11:59 <indiagreen> but actually, yeah, apparently the Show instance was changed between 0.9 and 0.10
15:12:18 <voidzero> ok.
15:12:21 <voidzero> I like this better. :P
15:17:13 <voidzero> > BS.pack [84,101] `mappend` BS.pack [113,117,105,108,97,33]
15:17:16 <lambdabot>  "Tequila!"
15:33:50 <ReinH> kristof: ping
15:48:16 * hackagebot lindenmayer 0.1.0.0 - L-systems in Haskell  http://hackage.haskell.org/package/lindenmayer-0.1.0.0 (reinh)
15:51:08 <Kole> Hi, I am trying to cabal install HDBC-ODBC but it gives a warning that it will have to reinstall a few things and will likely break a whole lot of packages (eg. random/hpc/ghc..) is this to be taken seriously?
15:54:00 <Cale> Yes.
15:54:25 <Cale> You might want to try this in a sandbox
15:54:37 <Kole> ok, thanks
15:56:29 <Cale> It's actually very interesting that it wants to reinstall stuff... which version of the package is it trying to install?
15:58:16 * hackagebot lindenmayer 0.1.0.1 - L-systems in Haskell  http://hackage.haskell.org/package/lindenmayer-0.1.0.1 (reinh)
16:00:14 <Kole> win 32-2.3.0.2 (reinstall) / utf-8-string-1/ (bytestring 0.10.4.0 ->0.10.6.0
16:00:33 <Kole> :)
16:00:34 <ReinH> Cale: I noticed something cool about L-systems.
16:08:17 * hackagebot hlibsass 0.1.3.0 - Low-level bindings to libsass  http://hackage.haskell.org/package/hlibsass-0.1.3.0 (jakubfijalkowski)
16:15:09 <tempay> i have a basic pipes question, i just read the tutorial and started playing
16:15:49 <tempay> can i leave producer as the last statement of a pipe do-block?
16:17:22 <Peaker> without knowing pipes -- anything that can legitimately be in the middle of a do-block can be the last statement too (except do-binding syntax like "x <-" or "let")
16:18:30 <tempay> right, i mean more semantically, why can't a producer behave like a pipe
16:18:51 <Peaker> aren't both special cases of a more general "Proxy" type?
16:20:13 <tempay> yep, with different type parameters
16:20:34 <GLM> How can I make a representation of a linear function (ax +b)?
16:20:43 <tempay> pipe defines an await type and a yield type, producer only defines a yield type
16:22:43 <tempay> GLM, what kind of representation? just the pair (a, b) works
16:23:46 <GLM> tempay:Preferably in a type. I also want to allow Ints and Floats
16:25:22 <pavonia> GLM: What about "data Linear a = Linear a a"?
16:26:58 <GLM> pavonia: Not a data constructor: ‘a’
16:27:25 <pavonia> ?
16:27:35 <GLM> pavonia:That was the GHC error for you line
16:27:37 <GLM> your
16:28:04 <pavonia> I don't know if you can paste that literally in GHCi, but it will work in a file
16:34:10 <haasn> What are the most “primitive” IO operations in, say, Haskell 2010? By that I mean IO operations that you wouldn't be able to define yourself by using other IO operations. What about GHC Haskell?
16:35:03 <haasn> (Are there “alternative bases” for IO, such as eg. (>>=)+return and join+return for Monad?)
16:36:35 <alexgman123> can anyone help to explain this error http://i.imgur.com/8K5jedV.png
16:37:45 <michaelt> alexgman123: let a = show (addThree 3 4 5)
16:38:26 <michaelt> alexgman123: or write: let a = show $ addThree 3 4 5
16:38:50 <alexgman123> michaelt: thank you! what does the $ sign mean?
16:39:05 <hpc> it's a function
16:39:08 <hpc> f $ x = f x
16:39:18 <hpc> it has a very low precedence, which is what's being used here
16:39:19 <michaelt> alexgman123: it is function application
16:39:26 <hpc> it's the same as show (addThree 3 4 5)
16:40:02 <alexgman123> if a is a function and b is a function and c is a function and i want to get the result of a (b (c)), can i just do a b c or do i have to add the parantehsis
16:40:28 <michaelt> alexgman123: you have to add parens, or else use some of the more abstract combinators
16:40:36 <michaelt> a (b c) 
16:40:46 <michaelt> or a $ b c
16:40:50 <hpc> alexgman123: if you have a whooooooole bunch of them
16:40:55 <hpc> a . b . c . d . e $ f
16:40:55 <michaelt> or, more absurdly a . b $ c
16:41:01 <hpc> a (b (c (d (e f))))
16:41:16 <michaelt> right
16:41:23 <alexgman123> but i thought the beauty of haskell is that we can just do abc instead of a(bc)
16:41:34 <hpc> using (.) is generally preferred for the convenience of being able to write (a . b . c . d . e) all on its own
16:42:05 <pavonia> "a b c" is a applied to two arguments b and c
16:42:13 <ion> alexgman123: show addThree 3 4 5 = ((((show addThree) 3) 4) 5), or (show addThree) 3 4 5
16:42:15 <michaelt> alexgman123: if a is an intuitively two place function, you can write a b c , e.g. sum = foldr (+) 0 
16:42:42 <alexgman123> thank you
16:42:51 <ion> alexgman123: We can do a b c instead of (a b) c. a (b c) requires something else.
16:43:41 <alexgman123> why cant i just do putStrLn (show addThree 3 4 5)
16:44:03 <alexgman123> ion: got it
16:44:04 <ion> Because (show addThree) doesn’t work, you can’t show a function.
16:44:12 <ion> Btw, print = putStrLn . show
16:44:16 <ion> print (addThree 3 4 5)
16:44:27 <alexgman123> print converts it to IO?
16:44:34 <ion> print is just putStrLn . show
16:44:47 <alexgman123> oh wow! i didnt know that very cool
16:45:03 <ion> @type (show, putStrLn, print)
16:45:06 <lambdabot> (Show a, Show a1) => (a -> String, String -> IO (), a1 -> IO ())
16:46:14 <ronh-> alexgman123 you're doing  "putStrLn ((show addThree) 3 4 5)" instead of " putStrLn (show (addThree 3 4 5))"
16:46:31 <alexgman123> thanks
16:46:44 <ronh-> you can just use print too
16:46:48 <ronh-> @src print
16:46:48 <lambdabot> print x = putStrLn (show x)
16:46:49 <alexgman123> ok
16:47:21 <crundar_> Does any of the Haskell standards require memoization/call-by-need? Is that in fact a requirement for correctness wrt the spec, or is it just an incredibly useful optimization?
16:47:25 <alexgman123> lambdabot: arent you redefining the print function in that case?
16:47:43 <alexgman123> print is already a haskell function, how are u setting it to something else by doing print x = ...
16:48:03 <ion> alexgman123: She simply showed how print is defined in Prelude.
16:48:15 <alexgman123> i see!
16:48:18 * hackagebot th-orphans 0.12.1 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.12.1 (MichaelSloan)
16:49:36 <alexgman123> this functional stuff is completely blowing my mind (coming from c#)
16:52:38 <pavonia> > let print = reverse in print "Haskell is fun"
16:52:42 <lambdabot>  "nuf si lleksaH"
16:53:23 <alexgman123> sounds russian
16:53:30 <alexgman123> why do we use LET ?
16:54:02 <pavonia> To introduce local bindings
16:55:02 <eatz> @src reverse
16:55:03 <lambdabot> reverse = foldl (flip (:)) []
16:55:31 <pavonia> alexgman123: In "let x = ... in e", x is only visible within the expression e
16:55:54 <ion> And within the expression “...”
16:56:09 <ion> And within any other definitions within the let
16:56:40 <pavonia> Hhm, right
16:57:11 <eatz> in the previous example where reverse is being bound to print, is there any way to reference the original print definition?
16:57:24 <ion> Prelude.print
16:57:30 <eatz> got it
16:57:37 <ronh-> does that work in ghc?
16:58:07 <ion> I’d expect it to work in all Haskell compilers.
16:58:35 <ronh-> I think it only works in ghci but I don't have haskell environment on this computer
16:59:19 <luzie> @let p = Prelude.print
16:59:23 <lambdabot>  Defined.
16:59:23 <alexgman123> pavonia: if i dont use let then i getan error
16:59:44 <ion> ronh: What exactly do you expect to work in ghci but not in ghc?
17:00:21 <pavonia> alexgman123: That doesn't tell me much without more context
17:00:31 <ronh-> ion referring to functions with the Module.symbol syntax
17:00:43 <alexgman123> ok
17:00:48 <ion> ronh: It works as long as the module is imported.
17:01:23 <ronh-> ah right.. that's the ghci exception I was thinking about. it works even if the module isn't imported
17:01:39 <alexgman123> ion: can you explain what does the last line here mean ? http://lpaste.net/134061
17:02:24 <ion> alexgman123: Given a list of the form (x:anything) as input, it returns the x.
17:02:37 <alexgman123> what would be an example of x:anything??
17:02:45 <hpc> > 5:[]
17:02:50 <lambdabot>  [5]
17:02:53 <ion> > let x = 1; anything = [] in x:anything
17:02:57 <lambdabot>  [1]
17:02:59 <ion> > let x = 1; anything = [2,3,4] in x:anything
17:03:02 <lambdabot>  [1,2,3,4]
17:03:15 <hpc> > 'o':'r':' ':'a':' ':'s':'t':'r':'i':'n':'g':[]
17:03:19 <lambdabot>  "or a string"
17:03:21 <alexgman123> lol
17:03:47 <alexgman123> another words any random set?
17:03:50 <alexgman123> i mean list
17:05:32 <eatz> non-empty list?
17:05:52 <alexgman123> ion: how do we know that this is a list? (x:_)  , is it that the paranthesis give the hint that it is a list?
17:06:17 <pavonia> : gives the hint
17:06:17 <eatz> @src :
17:06:17 <lambdabot> Source not found. Just try something else.
17:06:22 <ronh-> : is a list data constructor. you can use it to either construct a list or to deconstruct a list (this is called pattern matching)
17:06:24 <ion> alexgman123: The : means it’s a list. It is the standard non-empty list constructor.
17:06:32 <ion> @src []
17:06:32 <lambdabot> data [] a = [] | a : [a]
17:06:47 <alexgman123> thank you
17:07:13 <ion> A list can be in one of two forms:
17:07:17 <ion> []  -- an empty list
17:07:31 <ion> x:xs  -- a non-empty list where x is the first element and xs is the rest
17:08:02 <ion> [a,b,c,d] and "hello" are syntactic sugar for the above.
17:10:15 <eatz> if i didnt know : was the list data constructor and wanted to ask lambdabot for more info about :, is there a command other than @src?
17:10:44 <michaelt> @info (:)
17:10:44 <lambdabot> (:)
17:10:50 <michaelt> not too helpful
17:10:59 <eatz> ok, thank you though
17:11:02 <michaelt> eatz: try   :i (:)  inside ghci
17:11:08 <michaelt> or :info (:)
17:11:21 <eatz> michaelt: ok, ill try that
17:11:44 <pavonia> We should have a pseudo @info command in lamdabot that just says "No such command"
17:11:56 <eatz> that is a lot more descriptive
17:12:02 <eatz> thanks michaelt
17:12:13 <[mad]> hi
17:12:27 <ion> pavonia: lambdabot should say “No such command” for any command that does not exist.
17:12:35 <eatz> @asdf
17:12:35 <lambdabot> Who should I ask?
17:12:48 <pavonia> Or that
17:12:57 <eatz> @reallynotacommand
17:12:57 <lambdabot> Unknown command, try @list
17:13:05 <eatz> i think asdf is something
17:13:08 <alexgman123> im not understanding how this actually calculates the length of the list http://lpaste.net/134061
17:13:17 <pavonia> eatz: @ask probably
17:13:22 <eatz> yeah
17:13:56 <tempay> anyone know pipes? i'm a bit stuck
17:14:13 <michaelt> tempay: sort of, what's wrong?
17:14:57 <alexgman123> how is it that this breaks up the list into head and tail? (_:xs)
17:15:01 <michaelt> tempay uh oh I'm getting on a plane in  a minute ...
17:15:28 <tempay> michaelt: ah it might be too long for that
17:15:42 <tempay> michaelt: basically, trying to use for as for :: Monad m => Pipe   x b m r -> (b -> Producer   c m ()) -> Pipe     x c m r
17:15:54 <tempay> michaelt: and getting a type error
17:16:04 <pavonia> alexgman123: What part don't you understand?
17:16:24 <ronh-> > let (x:xs) = "hello" in (x,xs)
17:16:28 <lambdabot>  ('h',"ello")
17:17:02 <tempay> michaelt: i should be able to do "map cat p", where p :: a -> Producer b m (), right?
17:17:20 <tempay> michaelt: if cat is Pipe a a m ()
17:18:28 <tempay> michaelt: probably too involved, thanks though
17:18:31 <ion> alexgman123: Let’s evaluate length' (a:b:c:[]) step by step.
17:18:45 <alexgman123> ok
17:18:55 <michaelt> tempay youi mean for cat p?
17:19:00 <michaelt> tempay: just a sec
17:19:18 <ion> alexgman123: length' (a:b:c:[]) does not match the first case and does match the second case. In that, a is discarded and (b:c:[]) is bound to xs. The definition becomes: 1 + length' (b:c:[])
17:19:37 <tempay> michaelt: cat should be a "Pipe a a m ()"
17:19:54 <ion> alexgman123: 1 + length' (b:c:[]) = 1 + (1 + length' (c:[])) = 1 + (1 + (1 + length' []))
17:20:02 <tempay> michaelt: p should be a "a -> Producer b m ()
17:20:16 <alexgman123> i seeeee thank you
17:20:20 <ion> alexgman123: The final length' [] matches the first case so the final step makes the expression (1 + (1 + (1 + 0)))
17:20:25 <tempay> michaelt: so i would think "for cat p" would be a "Pipe a b m ()"
17:20:41 <alexgman123> is (xs:_) the same as (_:xs) ?
17:20:43 <tempay> michaelt: but i get a type error "Couldn't match type `X' with `()'"
17:20:49 <alexgman123> another words can it be rewritten those ways
17:21:06 <ion> alexgman123: No, the first element is on the left hand side, the rest of the list is on the right hand side of the :
17:21:32 <ion> > let (x:_) = "hello" in x
17:21:37 <lambdabot>  'h'
17:21:38 <ion> > let (_:x) = "hello" in x
17:21:43 <lambdabot>  mueval-core: Time limit exceeded
17:21:46 <ion> > let (_:x) = "hello" in x
17:21:51 <lambdabot>  "ello"
17:23:48 <ronh-> _ is used when you don't care to use assigned the value
17:23:55 <ronh-> the assigned value*
17:25:59 <koala_man> how do I determine whether I can reasonably output ANSI escape codes? so far I've been using 'hIsTerminalDevice stdout', but it's failing on Windows
17:26:09 <zartooz> how to get the numerical value of a digit char?
17:26:43 <srhb> > read ['4'] :: Int
17:26:46 <lambdabot>  4
17:27:03 <zartooz> of a char not a string?
17:27:11 <Cale> :t digitToInt
17:27:13 <lambdabot> Char -> Int
17:27:19 <Cale> > digitToInt '4'
17:27:22 <lambdabot>  4
17:27:32 <zartooz>  ?
17:27:33 <srhb> zartooz: '4' is indeed a Char. 
17:27:45 <srhb> zartooz: I can make any Char into a String by putting it in a list.
17:27:59 <zartooz> good for you
17:28:03 <srhb> ...
17:28:16 <srhb> Well, if that's for some reason not allowed, use Cales suggestion (from Data.Char)
17:28:16 <zartooz> but there is a function that does this for a char I sm pretty sure
17:29:19 <srhb> Note that it also allows hex digits.
17:29:38 <srhb> > digitToInt 'a'
17:29:42 <lambdabot>  10
17:29:56 <zartooz> weird I do not see any message from Cale. but I saw it web logs
17:30:12 <srhb> zartooz: Perhaps you have him muted somehow in your irc config?
17:30:28 <Clint> as well as solutions involving brackets
17:30:46 <zartooz> I dont. could be lag
17:30:50 <srhb> :-)
17:35:24 <Pibian> What's haskell best for?
17:35:59 <Clint> programming
17:36:01 <tempay> anyone on that knows pipes? i could use some help
17:36:16 <srhb> Pibian: Correctness! :-)
17:36:37 <Pibian> srhb, What about AI stuff?
17:36:53 <srhb> Pibian: There's no limitation against that for sure.
17:37:00 <pharaun> tempay: i know a bit, whats up
17:37:09 <Pibian> Great
17:37:23 <Pibian> I know that Lisp was created for AI stuff
17:37:52 <tempay> :pharaun i'm looking at the docs for 'for' here: https://hackage.haskell.org/package/pipes-4.0.0/docs/Pipes.html#v:for
17:38:22 <tempay> :pharaun I want to use the function as 'for :: Monad m => Pipe   x b m r -> (b -> Producer   c m ()) -> Pipe     x c m r'
17:38:45 <srhb> Pibian: It wasn't, but it sure has been used for it a lot historically.
17:38:49 <tempay> :pharaun but when I try to use it that way, I get a type error
17:39:35 <__k__z> Anybody know an effective way to get Posix time as a string?
17:39:39 <tempay> :pharaun I tried doing something like: ' for' :: Monad m => Pipe x b m r -> (b -> Producer c m ()) -> Pipe x c m r ', ' for' = for '
17:40:14 <tempay> :pharaun the type error I get is ' Couldn't match type `()' with `X' '
17:40:52 <tempay> pharaun: which is what i'd expect from looking at the Proxy type signature of for, it doesn't look like you can mix pipes/producers
17:41:08 <srhb> __k__z: Get the unix time, use Show?
17:43:39 <pharaun> oh
17:44:54 <alexgman123> quick question about let/in statement: http://lpaste.net/134061
17:45:28 <pharaun> tempay: does it work if you put an actual producer in the for
17:45:32 <pharaun> and use it as part of a pipeline
17:46:12 <srhb> alexgman123: readability, mostly.
17:46:47 <zartooz> alexgman123: sideArea is a local function that does not exist outside of cylinder
17:47:03 <srhb> local value.
17:47:21 <zartooz> functions are values
17:47:26 <srhb> Yes, but not all values are functions.
17:47:30 <srhb> sideArea isn't, for one.
17:47:31 <tempay> pharaun: I can put in something like \x -> yield y, but it just gets interpreted as a pipe
17:47:40 <zartooz> oh right
17:47:43 <srhb> :-)
17:47:50 <tejing> alexgman123: there should be no particular difference in that case, though sometimes let statements have a performance impact because they make the compiler run a function only once instead of several times
17:48:11 <tempay> pharaun: I think whenever I specific the parameters as a producer it gives me the error, as far as i can tell
17:48:34 <rcyr> What am I supposed to use, mtl or transformers? I even found articles on google saying that transformers are bad and that I should just create my own monad
17:49:23 <srhb> rcyr: Having a transformer stack does come with a performance impact that may be too costly depending on your application.
17:49:29 <pharaun> tempay: hmm, i looked at the source and the types there are in the document, might be a doc bug but i'm skeptical of that. can you get a *real* producer and stick it in there
17:49:33 <ronh-> alexgman123 your alternative code wouldn't even work
17:49:46 <ronh-> there's no r and h in scope if you put sideArea at top-level
17:49:49 <rcyr> srhb: Let's pretend that I don't mind at all about performance.
17:49:51 <alexgman123> ok
17:50:22 <srhb> rcyr: OK. Then the question is not really whether to use mtl OR transformers, but whether you want the type classy approach to implicit lifting. Ie. MonadState and friends.
17:50:40 <zartooz> yeah. but in general you use let when you want to restrict the scope of the variable, for whatever reason 
17:51:09 <tempay> pharaun: what do you mean a real producer? should I try to demonstrate without type signatures?
17:51:12 <SrPx> I just read in a paper that foldl can always be replaced by foldr for finite values... what?
17:51:16 <srhb> rcyr: mtl depends on transformers for the actual types, but gives you those type classes. :)
17:51:16 <SrPx> > [foldl (/) 1 [1,2,3], foldr (/) 1 [1,2,3]]
17:51:21 <lambdabot>  [0.16666666666666666,1.5]
17:51:25 <SrPx> obviously not the case
17:51:27 <srhb> SrPx: Yeah, by doing it continuation style.
17:51:35 <srhb> Uh
17:51:40 <srhb> That has nothing to do with that :P
17:51:52 <SrPx> so what is it saying? I don't get it
17:52:06 <rcyr> srhb: I see, so transformers/mtl are fine as long as my app doesn't have performance requirements?
17:52:06 <srhb> SrPx: That you can implement foldr _in terms_ of foldl
17:52:13 <srhb> rcyr: Yeah absolutely.
17:52:21 <pharaun> tempay: yeah usually when i get stuck with the type signature not lining up or not working right, i try to stick in like a real producer, various bits in and then do like :t to see what i'm missing and simplify/tweak
17:52:30 <srhb> rcyr: And you can always refactor with your own monad if need be later on. It's not a huge burden. :)
17:52:50 <SrPx> ah okay srhb, I thought it was trying to say they are equivalent and just evaluate in different orders
17:52:59 <srhb> SrPx: Er, or is it the other way around. I think it is
17:53:03 <srhb> SrPx: Ah and no. They're not.
17:53:10 <SrPx> Of course!
17:53:18 <rcyr> srhb: Thank you
17:53:22 <srhb> SrPx: https://wiki.haskell.org/Foldl_as_foldr
17:53:45 <tempay> pharaun: okay, i'll see what i can do
17:53:46 <SrPx> The quote is: "Optimisations like replacing foldr with foldl, which only work with finite values, can be applied safely.", read as "you can just replace the "l" by "r" and iit is the same"
17:53:50 <SrPx> But alright :)
17:53:58 <srhb> SrPx: Actually this one is better: https://wiki.haskell.org/Foldl_as_foldr_alternative
17:54:17 <srhb> SrPx: The author doesn't mean strictly replacing just the function name.
17:54:26 <SrPx> yep
17:56:00 <lpaste> tempay pasted “type error using pipes' for” at http://lpaste.net/134065
17:56:19 <tempay> pharaun: http://lpaste.net/134065 is that what you meant?
17:56:30 <tempay> pharaun: i get the same type error
17:56:37 <srhb> > (foldl (flip (/)) 1 [1,2,3], foldr (/) [1,2,3]) -- SrPx
17:56:40 <lambdabot>      No instance for (Typeable t0)
17:56:40 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
17:56:40 <lambdabot>        arising from a use of ‘show_M172279603664612723025262’
17:56:45 <srhb> Oop.
17:56:51 <srhb> > (foldl (flip (/)) 1 [1,2,3], foldr (/) 1 [1,2,3]) -- SrPx
17:56:53 <lambdabot>  (1.5,1.5)
17:57:39 <tempay> pharaun: even just doing :t (for cat) it appears to give me the definition of a pipe back
17:58:59 <SrPx> > (foldl (flip (++)) "_" ["a","b","c"], foldr (++) "_" ["a","b","c"]) 
17:59:03 <lambdabot>  ("cba_","abc_")
17:59:04 <SrPx> srhb: nice try :P
17:59:34 <srhb> SrPx: Right, it doesn't work in all cases of course. :)
17:59:40 <srhb> (Not without reversing the list)
18:00:22 <SrPx> reversing it always works indeed
18:00:40 <pharaun> tempay: interesting
18:00:48 <tempay> pharaun: actually strike that, :t (for cat) appears to be either Pipe -> Pipe or Consumer -> Consumer
18:01:03 <tempay> pharaun: worth asking stack overflow about?
18:01:04 <SrPx> Yet I'd question the idea of using it for performance. Maybe the author meant it for associative operators...
18:01:18 <pharaun> tempay: sounds so, i haven't ran into this one, so i'm finding it interesting
18:01:31 <tempay> pharaun: okay
18:01:35 <tempay> pharaun: thanks for looking at it
18:01:39 <pharaun> np
18:01:43 <srhb> SrPx: Usually they mean for strict operators.
18:01:58 <srhb> SrPx: Or more correctly, functions that are strict in their second argument.
18:02:33 <SrPx> still needs to be associative
18:03:12 <zartooz> @src foldl'
18:03:13 <lambdabot> foldl' f a []     = a
18:03:13 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:03:51 <a__> a nig
18:04:09 <a__> who here gets horny for their computer
18:04:13 <srhb> SrPx: Oh you mean if just replacing verbatim. Yes, but I don't think that's the point the author is trying to make
18:04:46 <srhb> SrPx: It's just that you _can_ express every fold as the other (except for infinite list stuff) by shuffling things around
18:05:00 <a__> microsoft is basically the titanic at this point am I right
18:05:18 <srhb> @where ops
18:05:18 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
18:05:33 --- mode: ChanServ set +o geekosaur
18:05:37 --- mode: geekosaur set +b *!4bab875d@gateway/web/freenode/ip.75.171.135.93
18:05:37 --- kick: a__ was kicked by geekosaur (Your behavior is not conducive to the desired environment.)
18:05:42 <srhb> Merci.
18:05:52 <SrPx> srhb: yep
18:06:10 --- mode: geekosaur set -o geekosaur
18:06:16 <srhb> SrPx: Moreover that optimization is necessary in cases where the second argument is strict.
18:06:24 <srhb> SrPx: foldr -> foldl, I mean.
18:06:36 <ronh-> foldl won't help. you need foldl'
18:06:47 <ronh-> or it will just build the thunks anyway
18:09:23 <zartooz> @pl \f x y -> f x 0 y
18:09:24 <lambdabot> flip flip 0
18:09:45 <srhb> ronh-: ghc will figure that out. :)
18:10:29 <ronh-> sometimes. and depending on what optimizations you use
18:10:49 <zartooz> @pl \x y -> f x 0 y
18:10:49 <lambdabot> flip f 0
18:11:12 * zartooz goes private
18:20:08 <tempay> pharaun: well. found it.
18:20:28 <tempay> pharaun: the docs removed that signature in 4.1.5
18:22:43 <itsMontoya> Is there anyone who did the cis194 course?
18:22:53 <itsMontoya> I feel like there is an error in the HW, I wanted to get someone's opinion
18:24:53 <pavonia> itsMontoya: Where do you think is an error?
18:25:15 <pharaun> tempay: oh, doh
18:25:16 <itsMontoya> pavonia: http://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf example 6
18:25:25 <itsMontoya> *exercise 6
18:25:28 <pharaun> tempay: so i guess my initial guess of it being a doc error was right or something changed
18:25:41 <itsMontoya> If you look at the example "hanoi 2 "a" "b" "c" == [("a","c"), ("a","b"), ("c","b")]"
18:25:58 <itsMontoya> But if looks like it's landing everything on b, which is the middle peg
18:26:14 <itsMontoya> But in Hanoi, you want to land everything on c, which is the last peg
18:26:49 <itsMontoya> So the way I'm reading the example is: First move is a to c. Second move is a to b. Third move is c to b
18:27:03 <itsMontoya> Now maybe I'm misinterpreting, or I'm just completely blind (which is totally possible)
18:28:40 <tempay> pharaun: yep, looks like it was a doc error and they fixed it in the update
18:29:06 <tempay> pharaun: on a related note... any idea how I do what I was trying to do? :P
18:29:19 <pharaun> you wanted a producer inside a pipe?
18:29:33 <tempay> yep
18:29:43 <pharaun> i think the main issue is you would need something to trigger that pipe
18:29:56 <pharaun> then the producer can take over and generate stuff from there
18:30:30 <tempay> i'm looking for (a -> Producer b) -> Pipe a b
18:30:38 <GLM> How can I make a regular statement a function?
18:30:47 <pavonia> itsMontoya: It says "Given the number of discs and names for the three pegs, hanoi should return a list of moves to be performed to move the stack of discs from the first peg to the second."
18:30:54 <pharaun> "i kinda" have something like that with a recent pipeline code i wrote, i trigger the producer inside a pipe, then it takes over and produces stuff
18:31:10 <pharaun> tempay: does it need to be in a pipe?
18:31:32 <itsMontoya> pavonia: Oh wow, see.. blind. What is weird is that they aren't simulating a real hanoi 
18:32:04 <pharaun> you can execute the runEffect in a pipe
18:32:11 <Pamelloes> itsMontoya: If you swap every occurence of b with c and vice versa you'll get a 'correct' solution.
18:32:24 <itsMontoya> But check this out guys..
18:32:27 <tempay> :pharaun i thought it would be natural.. i basically want to await a value, generate a producer from the value, yield what the producer yeilds, and repeat
18:32:34 <itsMontoya> “What if there are four pegs instead of three?
18:32:34 <itsMontoya> That is, the goal is still to move a stack of discs from the first peg 
18:32:34 <itsMontoya> to the last peg,”
18:32:50 <tempay> :pharaun can i run only a producer?
18:32:52 <itsMontoya> "the goal is still to move a stack of discs from the first peg to the last peg"
18:33:04 <pavonia> GLM: What do you mean by regular statement?
18:33:08 <itsMontoya> *is still* :|
18:33:17 <Pamelloes> itsMontoya: You can actually just use the exact same function. And ignore a peg.
18:33:23 * hackagebot process-extras 0.3.3.5 - Process extras  http://hackage.haskell.org/package/process-extras-0.3.3.5 (DavidFox)
18:33:28 <dolio> itsMontoya: Question 5 says first peg to second peg.
18:33:32 <pharaun> tempay: ahh, yeah that is doable, tho i did implement it as producer/producer iirc
18:33:37 <itsMontoya> I know question five does dolio
18:33:39 <itsMontoya> But read the next one
18:33:44 <dolio> Yeah.
18:33:45 <itsMontoya> The wording "the goal is still"
18:33:47 <dolio> They're inconsistent.
18:34:02 <itsMontoya> Implying the first exercise was the same idea, with 3 pegs instead of four
18:34:10 <itsMontoya> I really think it was a wording error on the exercise
18:34:11 <dolio> The ordering is arbitrary, though.
18:34:18 <itsMontoya> dolio: Oh totally
18:34:26 <itsMontoya> dolio: You just swap out the pegs in the logic
18:34:27 <Pamelloes> itsMontoya: The is still is referring to the this new hypothetical game vs the actual game of hanoi
18:34:37 <tempay> :pharaun right, it seems easier as producer/producer, but it seems so natural as a pipe I thought it would be easy
18:34:55 <itsMontoya> Pamelloes: But look, exercise 6 is proper hanoi
18:35:05 <itsMontoya> Just with 4 pegs instead of 3
18:35:07 <dolio> itsMontoya: I'd be surprised if you lost marks for doing either order. Unless they're using an automated checker or something.
18:35:15 <pharaun> tempay: https://github.com/pharaun/Karmator/blob/master/src/karmator/Karmator/Server.hs#L81-L97
18:35:19 <tempay> :pharaun honestly seems like there should be a function Producer a -> Pipe _ a
18:35:34 <itsMontoya> I'm going to approach it as if the game is proper just so I don't confuse myself
18:35:36 <GLM> pavonia: (not $ any (\x -> n `mod` x == 0))
18:35:43 <itsMontoya> And that way applying the logic to the optional exercise will be the same
18:35:46 <itsMontoya> Just one more peg
18:36:08 <Pamelloes> itsMontoya: The interesting part about exercise 6 is the line "in as few moves as possible"
18:36:25 <itsMontoya> Pamelloes: Totally, which is the goal of hanoi (actual)
18:36:42 <Pamelloes> Well there you go :)
18:36:54 <pavonia> GLM: "f n = not $ any ..."
18:36:59 <Pamelloes> But all this business of which peg is which is completely pedantic.
18:37:12 <pavonia> GLM: or "\n -> ..."
18:37:15 <itsMontoya> Oh sure, it is
18:37:26 <itsMontoya> But I am slightly OCD and I like things to make sense
18:37:30 <tempay> :pharaun i see what you mean
18:37:31 <GLM> pavonia:Thanks
18:37:50 <tempay> :pharaun it just looks like i'd have to have a full effect in that case, shouldn't i be able to do it with just a pipe?
18:37:55 <Pamelloes> Fair enough
18:38:12 <tempay> :pharaun i don't see semantically why I can't just return everything a producer returns inside a pipe
18:38:24 <tempay> :pharaun *yields
18:39:11 <itsMontoya> I feel like Haskell syntax highlighting is kind of borked on Sublime
18:39:20 <itsMontoya> Does anyone else use ST as their IDE?
18:39:35 <Pamelloes> vim for life :P
18:40:41 <itsMontoya> http://www.sublimetext.com/forum/viewtopic.php?f=2&t=11704
18:40:55 <itsMontoya> I use vim a lot too
18:42:09 <itsMontoya> Pamelloes: Oh look.. it highlights perfectly on vim
18:42:12 <itsMontoya> *facepalm*
18:43:00 <Pamelloes> itsMontoya: vim has issues with some syntax, though. It isn't a silver bullet ;)
18:43:21 <itsMontoya> Ahh damn
18:43:31 <itsMontoya> Sublimetext is good for most things, but guards seem to really mess it up
18:43:51 <itsMontoya> This bug is over 2 years old though
18:46:20 <itsMontoya> I'm still new to declaring custom types. Could someone help nudge me in the right direction? https://gist.github.com/itsmontoya/24346486e2bd0becd74f
18:48:19 <pavonia> itsMontoya: Your type signature says hanoi takes four arguments but your function definition only uses one (and doesn't reaturn another function taking the other three arguments)
18:48:39 <GLM> How can I only allow discrete numeric types to be passed into a function? For example, Int and Integer are fine but Float isn't
18:48:44 <itsMontoya> Ah ok, I was trying to pair it down just to get started
18:48:56 <itsMontoya> I also tried n,a,b,c for the guard and it didn't like that
18:49:34 <srhb> GLM: Integral a => a -> ...
18:50:23 <GLM> srhb: Thanks
18:51:43 <itsMontoya> pavonia: Got it working!
18:51:45 <itsMontoya> Thanks :)
18:51:57 <GLM> srhb:Is it normal that my program now takes substantially longer that I've moved Int to Integral?
18:52:16 <srhb> GLM: Depends on the program! But yes, Integers are more expensive than Ints
18:53:22 <pharaun> tempay: i think you should be able to
18:53:32 <pharaun> and yeah the pipe allows monad so you can run effect inside the pipe yes
18:53:35 <pharaun> just need to code it up yourself
18:53:46 <GLM> srhb: Is there a way to compensate
18:53:51 <srhb> GLM: Depends on the program!
18:54:30 <srhb> GLM: Give us something more to go on. :)
18:54:55 <dolio> Abstraction often isn't free.
18:55:13 <GLM> srhb:Just doing some project euler problems that I'll post to github soon
18:55:40 <srhb> GLM: Alright. Can take a look at your specific problem once that happens.
19:01:18 <Xe> I'm still learning haskell and want to do something to interface with a database. What would be the best thing to look into that doesn't require a lot of lanugage extensions?
19:07:35 <XX-GAY_POO-XX> lol
19:07:42 <srhb> @where ops
19:07:43 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:07:58 --- mode: ChanServ set +o Cale
19:08:02 --- mode: Cale set +b *!*@64.88.227.134
19:08:02 --- kick: XX-GAY_POO-XX was kicked by Cale (XX-GAY_POO-XX)
19:08:05 --- mode: Cale set -o Cale
19:08:47 <wayne> where can i find more information about appEndo? https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base/src/Data-Foldable.html#line-126
19:08:58 <ReinH> :t appEndo
19:09:00 <lambdabot> Endo a -> a -> a
19:09:12 <wayne> happy do go source diving but if there's something written already i should use that
19:09:15 <ReinH> wayne: appEndo removes the Endo newtype wrapper and gives the function
19:09:38 <ReinH> it's just newtype Endo a = Endo { appEndo :: a -> a }
19:13:01 <wayne> thanks
19:33:16 <f-a> I am defining an instance Functor for a newtype, I have:
19:33:34 <f-a> fmap f = Something . fmap f . runSomething
19:34:34 <f-a> which works, but is there a shorter way to write this instance?
19:35:23 <f-a> (I am just making sure I don't pick up bad habits)
19:36:21 <heatsink> My personal preference is to write fmap f (Someting g) = Something (fmap f g)
19:36:35 <heatsink> This emphasizes how the "Something" and "fmap" swap places
19:36:38 <Cale> That's already pretty short. You could probably use the DeriveFunctor extension if you want though.
19:36:45 <pacak> deriving Functor?
19:37:11 <Cale> (or GeneralizedNewtypeDeriving)
19:37:32 <pacak> You can derive some other nice instances as well.
19:38:21 <f-a> heatsink: in my case Something is UMStackT { runUMStackT :: ExceptT e (RWST r w s m) a }
19:38:57 <jle`> f-a: fmap = coerce
19:39:01 <jle`> :)
19:39:05 <f-a> xD
19:39:18 <pacak> fmap = unsafeCoerce
19:39:24 <f-a> thanks everyone, I have a more clear idea now
19:39:28 <jle`> if it's a newtype, it should work
19:39:39 <jle`> it might be the most efficient way, but i would hope the other ways compile down to the sam ething
19:39:42 <f-a> it works indeed, I was misreading ghcid's output
19:40:46 <jle`> but yeah DeriveFunctor is probably the actual way to go heh
19:43:32 <alexgman123> anybody want to contribute a haskell article? https://gordoncluster.wordpress.com/
19:51:50 <EponymicCycloid> Anyone here good at Cloud Haskell? I have a bit of an involved question
20:02:38 <GinoMan> Hey, I'm on Windows and just downloaded the Haskell Platform but when I go to start WinGHCi, It gives me a "CreateGHCiProcess Failed with error 2: The system could not find the file specified" and then quits. Why would that happen?
20:02:46 <GinoMan> what file can't it find?
20:03:49 <AshyIsMe> sorry to say it but you'll most likely have a much smoother time if you install virtualbox and run a linux vm
20:04:17 <AshyIsMe> windows is not the best development platform at the best of times
20:04:21 <felixn> GinoMan: http://stackoverflow.com/questions/11807720/error-to-launch-winghci-shipped-in-haskell-platform-package-2012-2-0-0 <-- this may help, but yea... development on Windows... I have no idea.  there's always F# :3
20:05:01 <felixn> GinoMan: you can mount a drive into virtualbox, so you can use a local text editor, then compile it over on linux
20:06:55 <felixn> GinoMan: https://www.fpcomplete.com/ <-- oh, there's this too, cloud haskell IDE
20:08:53 <GLM> How do I create a list from 1000 to 100?
20:09:41 <felixn> GLM: it takes awhile, but I'll start it for you list = [1000, 999, 998, ... ]
20:09:43 <GinoMan> felixn: change the shortcut to start in %haskellPath%\bin\
20:10:09 <Hijiri> you can do it shorter with
20:10:14 <felixn> SSSSSH
20:10:16 <felixn> don't show him
20:10:22 <c_wraith> > takeWhile (>= 100) $ iterate (`div` 10) 1000
20:10:27 <lambdabot>  [
20:10:39 <Hijiri> GLM: do you know the general syntax for doing [n..m] etc
20:10:45 <c_wraith> uhh
20:10:51 <GLM> Yeah, I figured it out. Thanks
20:11:01 <c_wraith> Why did lambdabot choke on that?
20:11:17 <Hijiri> I think I've seen this happen before
20:11:23 <Hijiri> things inexplicably become strictified
20:11:29 <Hijiri> in lambdabot
20:11:30 <c_wraith> > takeWhile (>= 100) $ iterate (`div` 10) 1000
20:11:33 <lambdabot>  [1000,100]
20:11:40 <c_wraith> there.  A list from 1000 to 100
20:11:44 <felixn> GLM: https://www.haskell.org/hoogle/ <-- this is a cool page, it's like google but for every haskell library, so you can easily find things like "reverse" or "intersect", and also search on the the type of what you're looking for
20:13:48 <pharaun> that's a killer feature of haskell imo ^
20:19:04 <selveskii> Hello everyone. I am building a list with a fixed number of elements. SList Int 4 means a list that can have four more elems and SList Int 0 is a valid list.
20:19:18 <selveskii> Currently I have a data constructor L :: SList a n
20:19:33 <selveskii> and I have to use (L :: SList Int 3)
20:20:01 <selveskii> I would like to know if there is a way to let me write "L 3" and get something whose type is SList a 3?
20:22:37 <Cale> selveskii: uh, you mean do type application at the value level? No.
20:22:54 <Cale> selveskii: You can write L :: SList Int 3  explicitly
20:23:11 <selveskii> Cale: Yes, but it's ugly…
20:23:45 <selveskii> Cale: Is there any plan to add this feature to GHC in near feature?
20:24:10 <Cale> If they did add it, you'd probably have to do the other type application as well
20:24:15 <Cale> But I don't knwo
20:24:17 <Cale> know*
20:25:18 <Cale> I suppose you'd have to be more precise about exactly how you wanted that feature to behave in general. Also, it seems really bizarre that you have a constructor which is polymorphic in what is meant to be the length of the list
20:25:20 <heatsink> selveskii, as a workaround, you can use auxiliary functions that take dummy parameters
20:25:45 <heatsink> Yeah, it is odd to have a length-polymorphic data constructor
20:26:50 <tejing> selveskii: try iteratively composing the (,) a Functor with itself. Might serve your purposes better
20:29:29 <selveskii> I hope to be able to specify the length of a list statically
20:29:59 <selveskii> and this is the only way I could come up with
20:30:26 <selveskii> heatsink: Could you give me an example of "auxiliary functions that take dummy parameters"? I think I still need to convert a number to type-level
20:33:11 <felixn> selveskii: not sure if this is what he's talking about, but this is what it made me think of https://wiki.haskell.org/Smart_constructors#Examples
20:35:41 <selveskii> Thanks!
20:36:28 <selveskii> It is supposed to be used as static list, so it is highly unlikely that I will use such a list whose length is larger than 9
20:37:38 <adarqui> anyone here familiar with meteor.js? anything similar on the haskell side? I remember haste being 'full stack' haskell web framework.. wondering if there's anything similar to meteor though.
20:40:37 <tejing> selveskii: if you're not going to be using large lengths just putting newtype wrappers around different length tuples and writing a typeclass for access by index should do fine
20:41:46 <sccrstud92> what does the --make flag do in ghc? i dont see any difference between --make and no --make
20:41:56 <tejing> er, not newtype, actually, just data
20:44:30 <heatsink> sccrstud92: --make tells GHC to also compile the imported files, if necessary
20:44:47 <sccrstud92> heatsink: what imported files?
20:44:58 <sccrstud92> the modules?
20:45:13 <heatsink> yes
20:50:29 <tejing> is there a detectable difference between (undefined :: a -> a) and (const undefined :: a -> a)?
20:52:23 <heatsink> > const undefined `seq` 1
20:52:27 <lambdabot>  1
20:52:33 <tejing> aha, right
20:54:20 <sccrstud92> if i have a type with an overloaded strings instance, which is being imported, and overloaded strings is on, why would i still get the error "Couldn't match expected type HostPreference
20:54:21 <sccrstud92>  with actual type [Char]
20:54:21 <sccrstud92> "
20:55:23 <kadoban> sccrstud92: OverloadedStrings only does anything to string literals. So you can still get that error in a bunch of ways really.
20:56:14 <sccrstud92> kadoban: isnt [Char] the type of string literals when overloaded strings is off, and IsString a => a the type when its on?
20:56:26 <sccrstud92> kadoban: meaning that its off?
20:57:03 <dfeuer> sccrstud92, I missed most of this (power outage), but remember defaulting.
20:57:13 <kadoban> sccrstud92: OverloadedStrings doesn't change every [Char] to IsString a => a, only actual string literals. So … what you've told me so far isn't enough to say if it's on or off. More context?
20:57:56 <sccrstud92> kadoban:In the second argument of serverSettings, namely "*"
20:58:18 <sccrstud92> so yeah its a literal
21:00:24 <sccrstud92> dfeuer: what does IsString a => a default to?
21:01:05 <dfeuer> sccrstud92, well, I believe the "default default" is String. I *think* there's a way to change that.
21:01:15 <dfeuer> Actually, I'm pretty sure there's a way to change that.
21:01:23 <dfeuer> But I don't remember what it is.
21:01:41 <sccrstud92> im running conduit example code
21:01:47 <sccrstud92> i shouldnt have to change it
21:01:57 <sccrstud92> main = runTCPServer (serverSettings 4000 "*") $ \appData ->
21:01:57 <sccrstud92>     appSource appData $$ omapCE toUpper =$ appSink appData
21:02:00 <sccrstud92> thats the whole thing
21:02:32 <dfeuer> I don't know conduit.
21:02:35 <dfeuer> At all.
21:04:17 <itsMontoya> Damn I'm troubling finding the pattern for this tower of hanoi exercise
21:04:23 <itsMontoya> *I'm having trouble
21:05:26 <sccrstud92> does conduit have an irc chan?
21:06:19 <dfeuer> Not that I know of. There are people who come here and use it.
21:06:25 <dfeuer> But they may not be around at the moment.
21:07:07 <sccrstud92> turns out language pragmas must go before module declaration. dumb mistake
21:07:22 <kadoban> sccrstud92: Well, did you check that you do actually have the extension on? Is it at the /very/ top of the file, and did you spell it right and is it in the correct format?
21:07:29 <kadoban> Ah
21:07:55 <sccrstud92> i knew it wasnt an incorrect spelling because i would have gotten a warning
21:08:18 <sccrstud92> but i didnt know it just ignores it completely when not placed correctly
21:08:47 <dfeuer> Ahhhhh.
21:10:26 <tejing> itsMontoya: in towers of hanoi you move a n-size tower from F to T using E as an extra by moving a (n-1)-size tower from F to E using T as an extra, moving a 1-size tower from F to T, then moving a (n-1)-size tower from E to T using F as an extra
21:11:13 <itsMontoya> tejing: I've been sitting here trying to find a pattern. Thinking I would be writing something around that pattern (chuckle)
21:12:30 <itsMontoya> I'm going to tinker a bit with the approach you gave. Thank you tejing
21:17:13 <ReinH> johnw: ping
21:17:26 <johnw> hello ReinH 
21:17:38 <ReinH> Hi! Mind if I pm for a moment?
21:34:59 <lifter> If I convert an Int64 to an Int using fromIntegral, could it be a lossy conversion?
21:35:06 <Ralith> yes
21:35:47 <lifter> so I should convert to Integer instead?
21:36:22 <lifter> well, in that case it wouldn't be lossy
21:36:48 <Ralith> what you "should" do depends entirely upon the details of the particular case
21:37:02 <Ralith> converting to Integer would indeed be information-preserving; so would not converting at all
21:37:21 <lifter> ah
21:37:33 <lifter> thanks
21:38:29 * hackagebot graph-wrapper 0.2.5 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2.5 (SoenkeHahn)
21:47:38 --- mode: ChanServ set +o mauke
21:47:38 --- mode: mauke set -b $r:dameloo
21:49:38 --- mode: mauke set -o mauke
22:38:09 <a2> im getting a Error: Class not found: Functor from @djinn anyone know what the problem is?
22:39:17 <haskell384> Hello all 
22:39:20 <johnw> djinn doesn't know about type classes
22:39:34 <johnw> or at least, about Functor
22:40:02 <haskell384> studying LYAK chapter: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass. I'm having a problem grokking "We know it has to produce a concrete type because it's used as the type of a value in a function"
22:40:22 <haskell384> what is producing a concrete type?
22:40:28 <haskell384> the (f a)
22:40:32 <haskell384> ?
22:41:48 <johnw> the application of f to a produces a concrete type, yes
22:43:06 <Rotaerk> haskell384, they're saying that... because only types of kind * can be in a function signature, and f a is used in a function signature, then f a must be of kind *
22:43:15 <Rotaerk> and thus f is of kind * -> *
22:44:13 <haskell384> Rotaerk: (f a) is used in a function signature? Which signature? 
22:44:20 <haskell384> Rotaerk: ahh, you mean in fmap?
22:44:23 <Rotaerk> yep
22:44:24 <ReinH> Cale: ping
22:45:07 <haskell384> Rotaerk: yes, I think that makes sense. We never have partially applied parameters in a function signature?
22:45:11 <ReinH> johnw: actually, you probably know. Given Functors f and g, is pair :: (a -> b -> r) -> f a -> g b -> r (contravariant) Day convolution?
22:45:48 <Cale> ReinH: hi
22:45:59 <tejing> haskell384: think about it. what the heck would (f :: Maybe -> Int) even mean?
22:45:59 <Rotaerk> haskell384, you can't, say, have a:  Functor -> Functor
22:46:04 <Rotaerk> because Functor is of kind * -> *
22:46:25 <johnw> almost, according to http://www.fceia.unr.edu.ar/~mauro/pubs/Notions_of_Computation_as_Monoids.pdf
22:46:30 <johnw> see page 18
22:46:33 <tejing> Rotaerk: Functor is of kind (* -> *) -> Constraint actually
22:46:34 <ReinH> johnw: thanks
22:46:36 <haskell384> Rotaerk: this is great thanks
22:46:40 <Rotaerk> err yea
22:46:46 <haskell384> tejing: yeah, you're right. thanks
22:47:17 <ReinH> Cale: I found out something cool today. Apparently there hasn't been much work done on fractals in category theory, but I discovered something.
22:47:33 <Cale> Oh?
22:48:00 <ReinH> Cale: An L-system is a terminal coalgebra
22:48:06 <ReinH> (see my http://hackage.haskell.org/package/lindenmayer-0.1.0.1/docs/src/Lindenmayer-D0L.html#D0L)
22:48:45 <ReinH> it's a fixed point
22:49:07 <ReinH> and the system is modeled just by packaging up the arguments to (>>=), which is rather nice
22:50:16 <ReinH> Cale: (of course then later I discovered that Leinster has already sort of been there)
22:51:06 <Cale> Ah, that's interesting, that's the other way of slicing it from what Paolo and I did in nymphaea :)
22:51:13 <ReinH> Cale: oh?
22:51:19 <ReinH> What did you do?
22:51:42 <Cale> Our monadic generalisation was generalising the list monad for nondeterministic L-systems to a more arbitrary monad
22:51:50 <ReinH> Ah
22:52:02 <ReinH> neat
22:52:08 <ReinH> I wonder how you combine the two
22:52:25 <ReinH> I have a feeling there's a monad/comonad pairing going on there
23:18:33 * hackagebot ndjson-conduit 0.1.0.0 - Conduit-based parsing and serialization for newline delimited JSON.  http://hackage.haskell.org/package/ndjson-conduit-0.1.0.0 (srijs)
23:19:02 <greves> so how well does haskell -> JS work?
23:21:42 <saulzar_> greves, Very well, from my (limited) experience with ghcjs.
23:21:57 <greves> oh yeah?
23:23:32 <saulzar_> greves, Wouldn't be able to give any benchmarks or that kind of thing, but it supports the full set of ghc extensions, compiles most packages (except those which are purely bindings to to C, obviously), integrates well with JS ..
23:26:24 <saulzar_> greves, and it's super cool to be able to use the same language for a client/server application
23:26:41 <greves> saulzar_ well i'm already doing js client/server
23:27:02 <greves> node & browser but i'm just sort of exploring compile-to-js languages as i discover them
23:27:14 <greves> obviously haskell is not a compile-to-js language, but i figured such a thing would exist
23:28:55 <breadmonster> Hey.
23:29:05 <greves> hi
23:29:15 <breadmonster> What's the correct way of using conduit for IO?
23:29:36 <greves> i'll pass that one over to somebody who actually knows what it means ;)
23:29:58 <breadmonster> greves: conduit is a library to stream data around, it's really cool.
23:30:06 <ion> The only problem with ghcjs is the size of the generated code. It’s okay for dedicated web apps but not for web sites you’d just like to embellish with JavaScript.
23:30:49 <greves> ion: how does it work integrating existing JS libraries?
23:31:04 <ion> It has an FFI mechanism.
23:32:06 <breadmonster> ion: do you use conduit or pipes?
23:32:08 <greves> would that work for complex stuff like, say, angularjs or react?
23:32:22 <ion> breadmonster: I haven’t used either yet.
23:32:50 <breadmonster> Hmm, damn.
23:32:59 <breadmonster> I'm writing a compiler in Haskell, and it's really awesome.
23:33:16 <greves> a compiler for what lang?
23:33:20 <ion> greves: I don’t see an inherent reason why not.
23:33:21 <breadmonster> Except I have no idea how to stream in input, holding files in memory is sometimes too big.
23:33:24 <breadmonster> Python.
23:33:39 <mauke[> how big are your source files? o_O
23:33:47 <greves> whaat
23:33:51 <greves> a python compiler in haskell!?
23:33:58 <breadmonster> mauke[: Yeah, they can't be too big sure.
23:34:16 <breadmonster> But if I run this on something that actually is a project, I'd like to get an executable.
23:34:35 <breadmonster> greves: why is that surprising? Python has an easy enough language to parse.
23:35:10 <greves> but... why? the C++ and Python parsers are pretty adequate, no?
23:35:29 <breadmonster> greves: Sure, but Haskell is a better language for writing compilers.
23:36:07 <greves> interesting.
23:36:30 <breadmonster> Also, writing compilers in C++ is a PITA.
23:37:41 <mauke[> I have a huge perl project here (more than 8000 modules)
23:37:48 <breadmonster> Why can't anyone just write a C compiler in Haskell?
23:38:09 <mauke[> total source code size is less than 100 Mb
23:38:15 <ion> mauke: Nice. What project is it?
23:38:28 <ion> It must be a joy to maintain.
23:38:28 <mauke[> ion: internal company stuff :-)
23:38:35 <mauke[> it is, actually
23:39:19 <mauke[> it's perl, so it has an automatic test suite
23:39:20 <breadmonster> mauke[: How is that Chromium's codebase size is about a gigabyte?
23:39:28 <breadmonster> Or GHC?
23:40:13 <mauke[> I don't know what's up with GHC, but chromium is written in C++, right?
23:40:50 <mauke[> oh hey, I just realized those 8000 modules include CPAN dependencies
23:41:21 <mauke[> anyway, what's the problem with reading a gig of source into memory?
23:51:21 <ion> He ran out of memory.
23:53:56 <medfly> prettysure that people who have 1 gig of source code don't have it all on one file...
23:54:34 <breadmonster> medfly: Hmm, fair enough.
23:54:38 <breadmonster> Sorry, I'm entirely new to this.
23:55:04 <medfly> :D
23:55:17 <breadmonster> Like I've never written a compiler before, I'm trying to get it to be as scalable as possible
23:55:36 <breadmonster> Ideally, let's see, I'd have an input source that passes off a line stream to a conduit.
23:55:43 <dfeuer> Possibly the most lines of code ever used to implement banker's queues, and they're all mine: https://github.com/jfdm/idris-containers/pull/10/files
23:55:50 <breadmonster> which will tokenize and further send tokens one by one downstream
23:56:18 <mniip> breadmonster, C has lookaheads and lookbehinds
23:56:18 <mauke[> most languages / tokenizers aren't line based
23:56:22 <mniip> not only syntax-wise
23:56:39 <breadmonster> mniip: I'm tokenizing Python\
23:56:44 <mniip> oh
23:56:45 <mniip> python
23:56:59 <breadmonster> mauke[: Yeah but the Python ref asks me to tokenize in terms of "logical lines"
23:57:04 <mniip> not sure about fine aspects of interpreting python
23:57:07 <mauke[> python is an exception, yeah :-)
23:57:23 <mauke[> hmm, I wouldn't concentrate on scalability
23:57:39 <mauke[> get dumb compilation to work first, optimize afterwards
