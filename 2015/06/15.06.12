00:00:17 <liste> montagy how does it fail?
00:00:44 <montagy> liste, cant find location
00:01:06 <montagy> lookup hLocation get Nothing
00:01:20 <mniip> @tell merijn That book has some oddities, it says \bigcup_i S_i , and on the next line says S_i \subseteq S_{i+1}. Shouldn't it say lim_{i \to \infty} S_i ? (Chapter 3)
00:01:20 <lambdabot> Consider it noted.
00:03:05 <montagy> liste, any idear?
00:13:02 <liste> montagy you should print out the response
00:13:20 <liste> and see if it shows an error code
00:14:38 <mniip> seems like alisia should be introduced to ##fix_your_connection
00:16:55 <montagy> liste, oh ,thank you ,i just tried it .it's not a haskell or ubuntu problem,it's about the web
00:18:07 <montagy> liste, in vps it has no location ,but in my machine it has
00:19:13 <liste> it probably is some error page, not a redirect
00:19:22 <liste> so there's no Location: header
00:20:03 <montagy> liste, but it's the same url,get different header
00:20:43 <liste> yeah, you should check it with browser/curl/httpie
00:23:40 * hackagebot record 0.4.0.0 - Anonymous records  http://hackage.haskell.org/package/record-0.4.0.0 (NikitaVolkov)
00:23:42 * hackagebot record-syntax 0.1.0.0 - A library for parsing and processing the Haskell syntax sprinkled with anonymous records  http://hackage.haskell.org/package/record-syntax-0.1.0.0 (NikitaVolkov)
00:24:58 <mniip> seriously where does the horizontal line notation for implication come from?
00:25:25 <mniip> is it explained somewhere? I can't seem to understand the entire thing
00:25:31 <liste> at least it was used in my logic textbook
00:26:33 <liste> it's like long addition
00:26:52 <johnw> I think it's from logic
00:26:58 <johnw> and might be very old
00:28:40 * hackagebot record-preprocessor 0.1.0.0 - Compiler preprocessor introducing a syntactic extension for anonymous records  http://hackage.haskell.org/package/record-preprocessor-0.1.0.0 (NikitaVolkov)
00:29:48 <montagy> liste, can you help me,i no nothing why get the different .http://lpaste.net/134382
00:30:11 <mniip> johnw, that doesn't help with the fact that there's no documentation on it
00:30:39 <liste> montagy that looks like malware
00:30:49 <liste> your server is infected
00:31:18 <eds> how can I make myfitness function choose the right operator? http://lpaste.net/132328
00:31:22 <eds> myFitness function should only be able to accept Arith(Int) and List(Int), not accept Comp(Bool) and Logic(Bool). While the instance create random numbers from 0 to 3. I need only 0 and 1 for myFitness function since it returns Int type.
00:31:25 <eds> Can I have some kind of counter to notify myFitness function just like we have in Java/C++?
00:33:29 <montagy> liste, oh no,it's terrible
00:37:35 <liste> montagy or not
00:37:42 <liste> actually it may be something else
00:38:57 <lamefun> OK, I'm now writing incomprehensible nonsense... it still mostly works save for few infinite loop fixes I had to do...
00:39:03 <lamefun> This language is amazing.
00:39:24 <liste> montagy is it some webapp you're trying to access? the configuration may be subtly different
00:39:50 <liste> on your server it redirects thru headers, on VPS it uses HTML/JavaScript
00:40:08 <liste> browser users don't see a difference, it works both ways
00:40:24 <liste> maybe you should parse the content and see if it has a <meta http-equiv
00:40:35 <montagy> liste, it's just a redirect.
00:40:58 <montagy> liste, yes ,i did it early use regex,but it's ugly
00:41:17 <montagy> liste, and i want to use parse,but ,still leaning ,doesn't figure out
00:42:24 <liste> how do you do the redirect?
00:42:40 <montagy> liste, just get the url
00:43:11 <liste> on server I mean
00:43:36 <montagy> storage
00:44:11 <montagy> http
00:44:38 <liste> I suspect it's subtly different server configuration on/for localhost and VPS
00:45:11 <montagy> liste, i'm sorry ,my english is poor,maybe i dont understand you
00:46:48 <montagy> liste, i use curl http ,the different is same
00:48:20 <liste> do you run the curl FROM the VPS or TO the VPS?
00:48:22 <montagy> liste, i have no idear how to configure it.maybe parse it is a good solution for me
00:48:39 <liste> montagy I guess parsing is the most robust solution
00:48:56 <montagy> liste, i ssh to my vps,and use curl in my vps
00:49:14 <liste> ok, so the server treats you differently then
00:51:18 <liste> maybe there's a firewall that translates Location: headers to HTML/JS
00:51:51 <montagy> liste, it is a test ,i have a real app run on the server,i no need ssh to it .it get the same result
00:53:14 <montagy> liste, yeah,i googled it ,someone has the same view
00:53:23 <montagy> liste, a firewall
00:53:55 <Guest53398> I wanted to know why mapAccumL and mapAccumR not defined for vector package?
00:56:39 <montagy> liste, i can write some regex,but i heard someone said parse is powerful than regex,and can do everything regex can do.but i can't write a parse to get http url,can you show me?
00:59:32 <liste> montagy here's a sweet spot between (string) regex and Parsec: https://github.com/feuerbach/regex-applicative/wiki/Examples
01:01:32 <montagy> liste, thank you ,it's helpful
01:01:43 <mniip> liste, I prefer the monadic interface to parsers
01:04:05 <liste> mniip me too in some cases
01:08:29 <liste> but /^[^a-z]*.?[^[]/ is horrible line noise
01:08:47 <liste> and regex-applicative solves that
01:12:53 <liste> and applicative is a superclass of monad now (:
01:13:21 <mniip> not sub, though
01:26:57 <magneticDuck> man, regex
01:41:04 <HaskellStudent81> can anyone tell me what I'm doing wrong here? I get parse error on line 4 http://lpaste.net/134386
01:44:13 <lyxia> HaskellStudent81: Remove "let "
01:44:55 <mniip> 'let' is only acceptable in in-expression bindings
01:44:58 <mniip> aaand ghci
01:45:28 <lpaste> Magnus pasted “record and optparse-applicative” at http://lpaste.net/134387
01:45:31 <tejing> mniip: and do-syntax
01:45:36 <mniip> yeah and that
01:45:51 <HaskellStudent81> this will be running in ghci
01:46:04 <mniip> Haskellfant, I meant ghci interactive
01:46:16 <mniip> as opposed to passing a file to ghci
01:46:36 <magthe> I'm playing around with record and I'm looking at combining it with optparse-applicative... but not sure how to... see http://lpaste.net/134387
01:46:53 <mniip> merijn, anyway, I'm a bit stuck with notation
01:47:16 <mniip> I can't find the explanation for the horizontal line thing anywhere
01:47:43 <HaskellStudent81> ok thanks
01:48:16 <merijn> mniip: Oh, you mean the natural deduction style notation?
01:48:28 <mniip> whatever it's called
01:48:31 <merijn> mniip: Read it as "everything above the line is assumption, everything below conclusion"
01:48:43 <mniip> so like implication?
01:49:13 <merijn> mniip: Well, implication only allows one assumption, so it's a bit more flexible, but yes
01:49:46 <HaskellStudent81> when I try to pass g1 to isSym I get an error: Couldn't match expected type `[(t1, t)]'
01:49:46 <HaskellStudent81>            against inferred type `Graph Int'
01:49:46 <HaskellStudent81>     In the first argument of `isSym', namely `g1'
01:49:46 <HaskellStudent81>     In the expression: isSym g1
01:49:46 <HaskellStudent81>     In the definition of `it': it = isSym g1
01:49:46 <HaskellStudent81> http://lpaste.net/134386
01:49:53 <mniip> merijn, you could fold the assumptions with conjunction
01:50:10 <mniip> which is what the more common syntax of | => does anyway
01:50:39 <merijn> mniip: So just a bar follow by "undefined : T" it basically means that "undefined : T" is an axiom
01:51:14 <lyxia> magthe: Is there something wrong with what you wrote?
01:51:22 <HaskellStudent81> why is it expecting type [(t1, t)]
01:51:37 <HaskellStudent81> I don't even know what that is.. tree?
01:51:43 <mniip> > all [] -- indeed
01:51:45 <lambdabot>      Couldn't match expected type ‘a -> Bool’ with actual type ‘[t0]’
01:51:45 <lambdabot>      In the first argument of ‘all’, namely ‘[]’
01:51:45 <lambdabot>      In the expression: all []
01:51:48 <mniip> oi
01:51:55 <mniip> > and [] -- indeed
01:51:56 <lambdabot>  True
01:52:13 <merijn> mniip: And "Γ ⊢ x : T   Γ ⊢ xs : List T" above the bar followed by "Γ ⊢ (Cons x xs) : List T" would be saying "given a derivation that x : T and a derivation that xs : List T we can conclude that 'Cons x xs : List T'"
01:52:35 <lyxia> HaskellStudent81: The function "elem" checks whether an element is in a list, and edges is not a list.
01:52:45 <merijn> mniip: Natural deduction notation is usually used to write down entire derivation trees
01:53:31 <mniip> merijn, I've never seen it before I started reading stuff about simply typed LC
01:53:41 <merijn> mniip: The problem with "you could fold the assumptions with conjunction" is that natural deduction is what's usually used to define conjunction in the first place :)
01:53:53 <merijn> mniip: It's a very common notation in type theory
01:54:11 <magthe> lyxia: so far not, the issue comes when using the parser... I'll see if I can clarify it further
01:54:17 <tejing> isSym's declaration doesn't fit with the commented type signature for it. a function from a pair is not the same as a function of 2 arguments
01:54:23 <lyxia> HaskellStudent81: elem :: a -> [a] -> Bool, applied to (y,x) :: (t1,t) unifies a and (t1,t), so elem (y,x) :: [(t1,t)] -> Bool, now appply that to edges :: Graph a, so you unify [(t1,t)] with Graph a and boom GHC insults you.
01:54:23 <merijn> mniip: It's somewhat similar to sequent calculus notation
01:54:32 <mniip> which is?
01:54:55 <merijn> mniip: If you're not familiar with it it won't really help that much, I think :)
01:55:08 <merijn> mniip: Wikipedia's article on natural deduction seems ok: https://en.wikipedia.org/wiki/Natural_deduction
01:55:25 <liste> magthe I guess you need something like (\x -> [r| {pkgs = x}|]) if that one doesn't work
01:55:25 <tejing> HaskellStudent81: isSym's definition should start out 'isSym (edges,[]) = True' (I think that's what you mean anyway)
01:56:08 <HaskellStudent81> so what your saying is I can't use elem in this implementation of isSym to work with this implementation of g1
01:56:28 <HaskellStudent81> this is code my teacher gave me I didnt even write this...
01:57:11 <merijn> mniip: Anyway, just knowing "above the line is prerequisite, below the line is conclusion" should be sufficient to follow what's going on
01:59:14 <mniip> merijn, hmm
01:59:29 <merijn> mniip: If you have an example that confuses you feel free to ask
01:59:44 <tejing> HaskellStudent81: well it's valid code, but the commented type signature is totally wrong
02:00:26 <tejing> HaskellStudent81: the inferred type signature for isSym would be [(a,b)] -> [(b,a)] -> Bool
02:00:31 <magthe> liste: well, mainly I'd like to avoid having to use the record types, instead of Record1 I'd like to use CmdExtractArgs
02:00:37 <mniip> merijn, I was thinking the ⊢ symbol is specific to type context things, but apparently it has a more broad meaning?
02:01:51 <tejing> HaskellStudent81: 'let x = snd g1 in isSym x x' would be a type-correct way to run the function (unless I did that wrong in my head somewhere)
02:01:55 <HaskellStudent81> tejing: the commented type code was my attempt at typing it, the rest of it is from my teacher. I'm just trying to get isSym to work with the graphs as she gave them to me
02:03:19 <HaskellStudent81> I'm not sure I follow... where would that go?
02:04:55 <merijn> mniip: tbh, I still don't understand the exact formal definition of ⊢, but informally it boils down to "Γ ⊢ x : T" reading as "we can conclude x : T in an environment Γ"
02:05:09 <tejing> HaskellStudent81: http://lpaste.net/134386#a134389
02:05:25 <mniip> merijn, from what I'm reading it looks like it's another symbol for implication
02:05:45 <merijn> mniip: The most trivial case being "x : T ∈ Γ" i.e. "if the variable 'x' has type T in Γ"
02:05:54 <merijn> mniip: It's not quite implication
02:06:03 <merijn> mniip: Because, for example, false implies anything
02:06:11 <merijn> But you can't conlude "anything" from an empty environment
02:06:42 <mniip> sounds correct to me
02:06:43 <merijn> mniip: It's a judgement, i.e. a statement that something is true in a given environment
02:06:51 <tejing> HaskellStudent81: there probably need to be some Eq constraints on those type signatures for it to compile. forgot to add those
02:07:01 <merijn> Which is superficially similar to implication, but technically different
02:07:51 <merijn> mniip: i.e. "Γ ⊢ x : T" is only true if either "x : T ∈ Γ" or there exists some typing derivation on Γ that lets us conclude that 'x : T'
02:08:12 <mniip> if Γ ⊢ x:(a->b), Γ ⊢ y:a then Γ ⊢ (x y):b
02:08:19 <merijn> (i.e. when 'x' is a compound term)
02:08:27 <mniip> if Γ is falsehood, then both prerequisites are true, and so is the outcome
02:08:28 <merijn> mniip: Right
02:08:32 <merijn> eh
02:08:38 <merijn> my right was to the first line, not the second
02:08:55 <HaskellStudent81> tejing: can you explain what you're trying to do with that? I have no idea what that says
02:09:10 <merijn> mniip: Note that type theory typically uses constructive logic and thus has no excluded middle
02:09:15 <Cale> merijn: As for the exact formal definition of ⊢, that is usually given as a bunch of rules for the type system (or logic), and varies depending on which type system is being discussed.
02:09:18 <HaskellStudent81> how is this code my teacher gave me apparently so horribly off? I feel like it shouldnt be this hard to get it to wrok
02:09:26 <mniip> merijn, come again?
02:09:33 <merijn> Cale: I understand how to read it :)
02:09:57 <merijn> mniip: Type theory follows constructive logic, rather than classical logic and the former, unlike classical logic does not have a law of excluded middle
02:10:11 <tejing> HaskellStudent81: without more context I doubt I can answer that :-)
02:10:18 <merijn> mniip: i.e. "A v not A" is not true in constructive logic
02:10:31 <Cale> You can pose classical logic as a type theory, but LEM becomes an axiom.
02:10:56 <merijn> Cale: If one is just starting in TaPL and simply typed lambda calculus the type theory is constructive :)
02:11:03 <Cale> sure
02:11:14 <mniip> ಠ_ಠ
02:12:02 <merijn> mniip: Constructivists as the name implies demand a proof that something can be constructed. Simply proving that something can't "not be constructed" is not sufficient
02:12:13 <tejing> HaskellStudent81: I could just as easily have written 'checkSym g = isSym (snd g) (snd g)' or 'checkSym (_,edges) = isSym edges edges'
02:12:20 <merijn> mniip: Which means that proof by contradiction is not allowed, for example
02:12:21 <Cale> mniip: What are you disapproving of?
02:12:23 <tejing> HaskellStudent81: in fact I like that last one much better
02:12:32 <mniip> Cale, nah I'm just generally confused
02:12:51 <merijn> Cale: He was reading turnstile as implication, but I'm not capable of explaining what the difference is :)
02:12:58 <merijn> 11:07 < mniip> if Γ ⊢ x:(a->b), Γ ⊢ y:a then Γ ⊢ (x y):b
02:13:01 <merijn> 11:08 < mniip> if Γ is falsehood, then both prerequisites are true, and so is the outcome
02:13:04 <HaskellStudent81> tejing: this is the assignment with the code as it was given to me. If you (or anyone else) wouldn't mind, maybe you could look at it and tell me what I'm doing wrong? http://lpaste.net/134391
02:13:42 <merijn> Cale: I have an intuitive understanding of why natural deduction is not implication, but I can't formulate it
02:13:44 <HaskellStudent81> you can see how she defines Graph there, and isSym. It seems to me she wants isSym to be used with Graph
02:13:51 <Cale> mniip: A |- B is a statement *about* a formal system, i.e. from A, it is possible to deduce B using the rules of the logic.
02:14:24 <Cale> mniip: A -> B is typically a type or a statement *within* a formal system
02:14:37 <tejing> HaskellStudent81: nope. it's clearly intended to be used with just the list of edges ... supplied twice
02:14:40 <Cale> i.e. one of the things which the logical rules may act on
02:15:00 <Cale> mniip: Typically, you have a theorem which says that A |- B if and only if |- A -> B
02:15:04 <mniip> to this day I've been thinking in terms of boolean logic, so this is a fairly new concept to mre
02:15:25 <Cale> i.e. you can deduce B from A if and only if from no assumptions, it is possible to conclude A -> B
02:15:40 <Cale> But this is a theorem
02:15:53 <HaskellStudent81> tejing: but then what is Graph for?
02:15:55 <Cale> It may fail if the rules of your logic are shitty
02:16:14 <HaskellStudent81> tejing: and why supply a list of edges twice?
02:16:19 <Cale> (tbh, you probably shouldn't use the symbol -> in the case that it fails)
02:16:47 <tejing> HaskellStudent81: it need to be supplied twice so you can recurse down the list which also keeping a reference to the entire list
02:16:54 <tejing> s/which/while/
02:17:20 <mniip> 'A |- B is a statement *about* a formal system' 'A -> B is typically a type or a statement *within* a formal system'
02:17:41 <merijn> mniip: Basically, if your type theory IS the logic, then you want to say things/prove things about what is possible inside that logic (i.e. a meta theory)
02:17:53 <Phyx-> Hmm.. haskell.org down for anyone else?
02:17:57 <mniip> in my defence I can say that in, as you call it, classical logic, those are the same thing
02:18:05 <HaskellStudent81> I want to belive you're trying to help me.. but I'm really not sure you're not just trolling me
02:18:12 <liste> Phyx- not me
02:18:14 <arw> Phyx-: perfectly reachable from here.
02:18:17 <merijn> mniip: No, classical logic doesn't prove things about itself
02:18:29 <Cale> mniip: Even in classical logics, they aren't directly the same thing. They're related to one another by that deduction theorem I mentioned.
02:18:42 <Cale> A |- B if and only if |- A -> B
02:19:11 <Cale> -> is part of the syntax of statements in the logic, |- is not
02:19:39 <Cale> i.e. -> is a logical connective
02:19:42 <merijn> mniip: So "Gamma |- f : T1 -> T2     Gamma |- x : T1" horizontal bar "Gamma |- f x : T2"
02:19:46 <Cale> |- is a relation on logical statements
02:20:11 <merijn> mniip: That says "if my logic can prove "f : T1 -> T2" in the context Gamma" AND "my logic can prove "x : T1" in the context gamma"
02:20:15 <Cale> Right, in a type theory, they're even more different
02:20:21 <merijn> mniip: THEN my logic can prove "f x : T2" in the context Gamma
02:20:24 <tejing> HaskellStudent81: this is how I would have written it, given that type for 'Graph a' above: http://lpaste.net/134391#a134392
02:20:40 <Phyx-> hmm
02:20:56 <Phyx-> then something must be wrong.. i can't get to any of the haskell.org subdomains
02:21:07 <mniip> Cale, are you trying to say that binary relations are different from a->b->Bool functions?
02:21:09 <Cale> If A and B are types, then you can have a judgment f : A -> B, stating that f is a function of this type (or a proof of this implication)
02:22:07 <Phyx-> thanks arw, liste. I'll restart my router see if that fixes it
02:22:22 <HaskellStudent81> tejing: I think you may have pasted the wrong link?
02:22:22 <Cale> mniip: I'm not talking about either of those things... well, |- is one particular binary relation on statements (or typing judgments)
02:22:39 <tejing> HaskellStudent81: I would also have used a data declaration for the Graph type, instead of a type synonym, since I would rather the compiler spit out an error than silently accept it if for some reason I used some data that happened to have the same structure but entirely different meaning (i.e. something that was not a graph at all but still had type ([a],[(a,a)]))
02:22:48 <Cale> I'm certainly not talking about functions a -> b -> Bool at all.
02:23:12 <tejing> HaskellStudent81: no, right link... look at the bottom
02:23:37 <mniip> Cale, if A and B are statements, then A => B is a statement, right?
02:24:06 <HaskellStudent81> oh my bad
02:24:12 <Cale> mniip: Let's be a little more concrete, and consider classical propositional logic. So what are the sentences of the logic? Well, there are some propositional variables, P, Q, R, ...
02:24:55 <Cale> and then whenever u and v are some sentences, then u /\ v, u \/ v, u -> v, ~ u, and maybe some other things are also
02:25:21 <Cale> (perhaps you'd like to put some parens in there if we're thinking about them as strings, but there's a natural tree structure on them)
02:25:28 <mniip> ok
02:26:08 <Cale> So, |- is a relation between (sets of) sentences
02:26:46 <Cale> Saying that if we start out with the sentences on the left, we can derive according to the rules of the logic all of the sentences on the right.
02:27:41 <Cale> A -> B is a sentence within the logic, while A |- B is a relation between two (singleton sets of) sentences
02:28:34 <Cale> Depending on the precise details of our formalisation, we might only allow one sentence to occur on the right or left of the |- rather than a set of them
02:29:17 <HaskellStudent81> tejing: thanks, I think I get it. Isn't there a way to do it so you don't have to pass the graph twice though? It would have to be considerably different I guess
02:29:27 <Cale> In a type theoretical setting, the things on the left and right of the "turnstile" are typing judgments, of the form x : t for some term x and type t.
02:29:47 <mniip> so A|-B is a relation containing pairs (a,b)
02:29:51 <mniip> for all a in A
02:30:07 <Cale> A isn't necessarily a set
02:30:16 <mniip> ugh
02:30:20 <Cale> It's just a string or tree of symbols comprising a logical statement
02:30:33 <mniip> A and B contain some variables, so the syntax is wonky here
02:30:37 <tejing> HaskellStudent81: I suppose you could delete the flipped version before recursing... that would run slower though
02:31:00 <mniip> let's say, A(x)|-B(x) is a relation containing pairs (A(x), B(x)) for all x such that A(x)
02:31:32 <tejing> HaskellStudent81: lists are far from the best data structure for this purpose. Sets from Data.Set would be much better
02:31:50 <Cale> A(x) |- B(x) means that starting from the statement "A(x)", we can apply rules of the logic successively, and somehow end up with the string of symbols "B(x)"
02:31:57 <HaskellStudent81> I need a break and a shower, and probably bed. It's 2:30 AM here. Thanks for bearing with me, tejing
02:32:22 <tejing> HaskellStudent81: well then good night, and np
02:32:25 <mniip> Cale, yeah, but how is that different from what I said
02:33:00 <Cale> A(x) |- B(x) isn't itself a relation, but |- is a relation on sentences
02:33:21 <Cale> A(x) and B(x) are presumably sentences in some predicate logic?
02:34:17 <Cale> Well, if x is a free variable, you might not be allowed to write that
02:34:29 <Cale> Typically sentences are the well-formed formulas with no free variables
02:34:35 <Cale> and then |- will relate the sentences
02:35:08 <mniip> terminology again
02:35:23 <mniip> if |- is a binary relation, then A(x)|-B(x) is a set of pairs
02:35:30 <Cale> huh?
02:35:35 <danilo2> danilo2:	Hello! :) Is there any function in Haskell similar to when, but which results the default argument if the condition is not met. Im looking for something like modWhenM :: a -> m Bool -> a -> a  used like follow: newVal = modWhenM val moperation (val+1)
02:35:41 <mniip> using the definition of a relation from TaPL
02:36:00 <merijn> mniip: Which page is that on?
02:36:07 <mniip> chapter 2.1
02:36:12 <mniip> 2.1.3
02:36:36 <Cale> mniip: If S is a set, then a binary relation on S is a set of pairs of elements of S
02:36:45 <merijn> mniip: That section is introducing the basics of sets
02:36:52 <merijn> mniip: |- is not a relation on sets
02:36:53 <Cale> mniip: In this case, we have a set of all logical sentences
02:37:06 <Cale> mniip: and |- might be a relation on those sentences
02:37:48 <Cale> Or, we could generalise to sets of sentences, and |- would be a relation on either the powerset of the set of sentences, or the set of all finite subsets of the set of sentences.
02:37:53 <merijn> mniip: |- is used to relate contexts and "type judgements" which are not sets
02:38:17 <Cale> merijn: Well, he might be confused because I mentioned that |- might have a set of things on either side of it
02:38:51 <Cale> Like, you may write, in classical propositional logic, A -> B, A |- B
02:39:14 <mniip> no, it's not that
02:39:16 <Cale> i.e. if we have both the assumption that A -> B and the assumption that A, we can derive B from these.
02:39:55 <Cale> Which is different from (A -> B) /\ A |- B
02:40:18 <merijn> Let's skip the generic math explanation and skip to the use in TaPL
02:40:21 <mniip> I fail to see why it is different from (A -> B) /\ A => B
02:40:28 <mniip> er, ->
02:40:29 <merijn> The first use I can find is on page 101, chapter 9.2
02:40:35 <Cale> (A -> B) /\ A -> B is yet another thing
02:40:50 <Cale> (A -> B) /\ A -> B is a statement of our propositional logic
02:41:12 <merijn> Where it defines "x:T1 |- t2 : T2" horizontal bar "|- \x:T1 . t2 : T1 -> T2"
02:41:28 <Cale> i.e. it's a sequence of symbols, and it's not something we can say is true or false -- from this setting, we're just treating it as roughly just a string
02:41:36 <frerich> danilo2: I'm not aware of anything ready made, but I guess you mean a signature like 'Monad m => b -> m Bool -> b -> m b'?
02:42:17 <danilo2> frerich: of course! that is what I ment
02:42:27 <Cale> However, |- (A -> B) /\ A -> B means "starting from nothing, it is possible to derive (A -> B) /\ A -> B", and this might be true
02:42:31 <merijn> Which is saying that "If we can deduce 't2 : T2' given the context 'x:T1' (for example, 'x' is some term containing the free variable 'x'), we can deduce that "\x:T1 . t2 : T1 -> T2"
02:42:52 <Cale> Yeah, if you want, we can just skip to talking about type theory
02:43:12 <mniip> no, I'd rather figure this out at the fundamental level
02:43:21 <Cale> Maybe it'll even be clearer the difference between the function type constructor and the relation which tells us that we can derive some typing judgment from some others
02:43:29 <merijn> mniip: I don't think the fundamental level is helpful for understanding TaPL, tbh
02:43:42 <mniip> [12:40:10] <Cale> (A -> B) /\ A -> B is a statement of our propositional logic
02:43:47 <mniip> which is different from the other thing how
02:44:09 <Cale> mniip: Like, in our type theory setting, we don't just have sentences (which roughly correspond to types), but we also keep track of which terms are witnesses for these
02:44:13 <danilo2> frerich: anyway thank you very much :) I was just looking for something ready not to make the same functionality under different name :)
02:44:50 <Cale> mniip: |- isn't a symbol inside our logic
02:45:08 <Cale> mniip: It's a mathematical relation which we're defining that's relating sentences of the logic
02:45:10 <merijn> It's not even describable in the logic
02:45:57 <mniip> Cale, you're saying that it returns some higher entity
02:46:07 <Cale> mniip: i.e. if I start with some strings of symbols, and I apply these string manipulation rules, I can get these other strings of symbols
02:46:09 <merijn> I'm trying to think of an analogy to clarify meta-theory, but I'm drawing a blank
02:46:12 <mniip> and I don't understand in what way is that higher entity different from a statement
02:46:43 <merijn> mniip: Do you understand the whole completeness thing where "not all true statements of a consistent system can be described inside the system"?
02:46:59 <Cale> ping
02:47:01 <Guest77> ping
02:47:23 <Cale> I can't seem to browse the web all of a sudden, but my IRC connection seems okay
02:47:31 <Cale> oh, it's back
02:47:49 <Cale> ... sort of
02:48:05 <mniip> merijn, what
02:48:51 <Cale> mniip: Anyway, let's consider something even more basic. We're not even going to try to pretend like we're doing logic now
02:48:59 <merijn> mniip: Gödel's completeness work proves that, within a consistent system, it's not possible to prove all statements that are true inside that system
02:49:10 <Cale> Our set of sentences will be the strings on the alphabet MIU
02:49:25 <merijn> mniip: So, if we want to talk about things inside a system that are not provable INSIDE that system, we need a "meta-system" a system for talking about the system
02:49:30 <Cale> and the rules of our "logical system" are going to be as follows
02:49:46 <merijn> mniip: "|-" is our meta system, it describes things about our system that are not expressible inside it
02:50:10 <Cale> 1) We may add U to the end of any string ending in I, i.e. from xI |- xIU for any string x
02:50:32 <merijn> Cale: At some point I should finish GEB :p
02:50:33 <Cale> 2) For any string x, we have Mx |- Mxx
02:50:58 <Cale> (i.e. following an M we may duplicate the string which follows)
02:51:27 <Cale> 3) We may replace any occurrence of III with U, i.e. for any strings x and y, we have xIIIy |- xUy
02:51:38 <merijn> Well, at the very least this discussion clarified my own insight :)
02:51:52 <Cale> 4) We may remove any occurrence of UU, i.e. for any strings x and y, we have xUUy |- xy
02:52:20 <Cale> Puzzle: Is it the case that  MI |- MU  ?
02:52:51 <mniip> I'm not entirely sure I understand how this usage of |- is related to the way we've previously used it
02:53:06 <Cale> mniip: It's in spirit exactly the same
02:53:29 <Cale> mniip: A logic consists of some sentences and some rules for getting from one to another
02:53:46 <Cale> mniip: just like this string rewriting system
02:54:08 <Cale> It's just the sentences here are "meaningless", which might actually help clarify what we're doing a bit
02:54:15 <mniip> in this case, intuitively, I'm interpretting that there's some set S
02:54:34 <Cale> So, in this case, our set of sentences is just the set of all strings {M,I,U}*
02:54:53 <mniip> and for example 1) states that {xIU | xI <- S} is a subset of S
02:55:11 <Cale> uhhh
02:55:47 <Cale> I think you want {(xI, xIU) | x in {M,I,U}*} is a subset of the relation.
02:56:27 <mniip> uh no
02:56:34 <Cale> Well, that's at least true
02:56:45 <mniip> I don't see a relation
02:56:51 <Cale> The relation |-
02:57:06 <Cale> Is a subset of {M,I,U}* x {M,I,U}*
02:57:30 <Cale> When (w,w') is an element of that subset, we write w |- w'
02:58:31 <Cale> So, you might screw around for ages inside this system, applying the rules of the "logic" to try to get from MI to MU
02:59:09 <Cale> But if you find no derivation, you'll be no closer to knowing whether MI |- MU
02:59:32 <merijn> I'm going for lunch, I'll be back later if there's questions Cale can't answer (unlikely :p)
02:59:41 <Cale> But by reasoning about the rules of this logic, we can determine that it is in fact not the case that MI |- MU
02:59:47 <Cale> If you want, I can let you think about it a while :)
02:59:55 <mniip> Cale, I still don't follow
03:01:45 <lieven> well, one thing that is true but not expressible in the system is that any string derivable from MI will start with M. Proof by induction on the number of derivation steps and by cases for each step.
03:02:20 <Cale> Right, that's perhaps a more obvious thing to start with :)
03:03:35 <int-index> Why is there no Control.Monad.Trans.Except.liftCatch? What if I have multiple ExceptT in my stack and I want to lift the catch of the first one through the second one?
03:04:30 <int-index> And it's fairly easy to implement. In fact, it's almost identical to Control.Monad.Trans.Maybe.liftCatch.
03:04:31 <Cale> int-index: If you have multiple ExceptT... you seem to be doing something horribly wrong to begin with?
03:04:37 <Cale> But okay
03:05:33 <int-index> Cale: why? I think I'm doing something really smart. One ExceptT per error and I basically have checked exceptions from Java (with some type class machinery).
03:06:13 <Cale> int-index: Why not just use one ExceptT with a type of errors that captures all the cases?
03:06:43 <int-index> Cale: because I want modularity. One piece of code throws exception X, another one throws exception Y, and I want to use the smallest types possible.
03:07:30 <int-index> So when I combine them, I either should use open unions and merge X and Y into one type, or I simply have two ExceptT.
03:07:49 <Cale> hmm
03:08:35 <joncol> Hi, I'm having some difficulties creating clean code when using the writer monad (to keep track of scores for my 2048 game clone). The problem is that I currently have to runWriter the writer, since it doesn't seem possible to pattern match on a Writer (a, v). Could anyone knowledgeable about these things take a look at https://gist.github.com/joncol/665b4aa77e9fe5215797 and maybe provide some feedback on 
03:08:41 <joncol> how to clean that up? (snippet of 17 lines).
03:09:17 <mniip> Cale, we have a set of valid strings S
03:09:25 <Cale> int-index: I don't know what it is you're doing, but when I use monad transformers, I always try to hide them inside of newtypes, so that the implementation of my monad is not visible from outside the module I'm using the monad transformers in.
03:09:38 <mniip> 1) dictates that if xI is in S, then xIU is in S
03:09:45 <Cale> oh, no
03:09:55 <mniip> i.e that {xIU | xI \in S} \subset S
03:09:59 <Cale> The strings are all the strings on the alphabet {M, I, U}
03:10:10 <Cale> The rules express which strings may be derived from which other strings
03:10:21 <pavonia> joncol: Looks like you really want State not Writer
03:10:40 <mniip> Cale, but then MU is a valid string and there's nothing to prove
03:10:50 <Cale> There is no particular subset of the strings we're interested in. Well, for the sake of the puzzle, perhaps we're especially interested in the set of all strings derivable from MI
03:11:03 <Cale> The question isn't whether MU is derivable
03:11:12 <Cale> It's whether MU is derivable *from* MI
03:11:37 <Cale> MU is certainly derivable from MUUU
03:11:47 <int-index> Cale: I'm implementing type-indexed monad classes (a la mtl, but with a tag). So one could have multiple MonadError constraints in the function type, like (MonadError DivideByZero m, MonadError OutOfBounds). Since errors in MonadError tend to be monomorphic, it causes no problems (but in my solution polymorhic errors are possible to, but I'm going to describe it when I finish the library and publish it 
03:11:47 <Cale> (apply rule 4)
03:11:53 <int-index> on Hackage).
03:12:16 <int-index> Anyway, I already implemented liftCatch for ExceptT (as I said, it was easy), but I wonder why can't we add it to transformers? (where it belongs, I think)
03:12:19 <Cale> int-index: It might be useful to steal Control.Exception's Exception class.
03:12:27 <mniip> [13:09:19] <Cale> The strings are all the strings on the alphabet {M, I, U}
03:12:50 <mniip> MI is a string of that alphabet, so it's valid, qed?
03:12:57 <mniip> er, MU
03:13:07 <joncol> pavonia> Cool. I'll look into that.
03:13:08 <Cale> You haven't shown that MI |- MU
03:13:18 * frerich reads M I U and wonders whether this is about the example from Goedel, Escher, Bach...
03:13:20 <Cale> MI and MU are both valid sentences
03:13:39 <Cale> frerich: It is exactly the example at the start of GEB
03:14:02 <mniip> Cale, but I don't understand the meaning of |-
03:14:39 <Cale> w |- w' means "it is possible to apply a finite sequence of the rules of our system to the sentence w in order to obtain the sentence w'"
03:14:39 <int-index> Cale: I'm convinced that I can just copy half the code from transformers/mtl and tag all the things as described in Dan Piponi's blog post http://blog.sigfpe.com/2010/02/tagging-monad-transformer-layers.html
03:15:10 <frerich> Cale: IIRC I lost an entire evening on some challenge in that chapter before I gave up, read on and realized that it was impossible to go from MIU to MU (or so...). The constant growing and shrinking of sentences made me hope that the solution is possible.
03:15:25 <mniip> Cale, so {w | w' \in W} \subset W
03:15:33 <Cale> mniip: huh?
03:16:14 <mniip> no wait
03:16:21 <mniip> {w' | w \in W} \subset W
03:16:21 <Cale> frerich: Right, it was probably the one I'm posing right now :)
03:16:31 <Cale> mniip: what?
03:16:37 <mniip> :|
03:18:11 <Cale> mniip: |- is the reflexive transitive closure of the relation generated by {(xI,xIU) | x in {M,I,U}*} union {(Mx,Mxx) | x in {M,I,U}*} union {(xIIIy,xUy) | x, y in {M,I,U}*} union {(xUUy, xy) | x, y in {M,I,U}*}
03:19:20 <int-index> Cale: The problem with Control.Exception is that you have no static guarantees that an exception was handled, so it's like unchecked exceptions from Java (and I'm going for checked ones)
03:20:26 <Cale> mniip: So you can read u |- v as saying "starting with u, we can obtain v using a finite number of applications of these rules". The reflexivity of |- means that every sentence is at least derivable from itself.
03:21:19 <Cale> mniip: Now, I think what you were possibly trying to express was the set { w | MI |- w }
03:21:41 <Cale> mniip: That's fine, you can talk about that set if you want...
03:21:48 <mniip> let me restate the task in my terms
03:21:49 <Cale> (but we weren't)
03:22:30 <Cale> mniip: (remember that the whole goal of this exercise is to help grasp something about what sort of thing |- is)
03:23:28 <Cale> mniip: Now, there's nothing in this system which corresponds to implication.
03:23:43 <Cale> mniip: But I could add it. Let's extend the alphabet with Z
03:24:39 <Cale> Well, hmm, nah, let's not do this, it'll probably be confusing :)
03:26:04 <Cale> (I was thinking of adding some sort of way of deriving sentences of the form wZw' from something I hadn't decided yet, whenever it was possible to derive w' from w)
03:26:23 <Cale> So that Z would act a bit like -> did in our discussion before.
03:26:29 <mniip> Cale, http://mathb.in/37575
03:26:32 <mniip> does that seem correct
03:26:42 <Cale> What is S?
03:26:52 <mniip> just a set
03:27:41 <mniip> actually I think it's better to write
03:27:48 <Cale> Given the 4 rules there, S might be the empty set.
03:27:56 <mniip> \forall xI \in S : xIU \in S
03:28:11 <mniip> Cale, it might
03:28:21 <mniip> but that's only a part of the proof
03:28:24 <Cale> You mean xI in S => xIU in S.
03:28:37 <mniip> more or less
03:28:54 <Cale> I don't understand what you mean by the notation {MU | MI in S}
03:29:09 <Cale> In particular, MI in S has no free variables
03:29:20 <Cale> So what the heck is that?
03:30:48 <Cale> Did you mean to say, Prove: MI in S => MU in S?
03:31:01 <Cale> Because then, sure, that's what we're asking.
03:31:58 <mniip> sorry my laptop ran out of battery
03:32:02 <Cale> Did you mean to say, Prove: MI in S => MU in S?
03:32:03 <Cale> Because then, sure, that's what we're asking.
03:32:13 <mniip> > [0 | 'e' <- "hello"]
03:32:15 <lambdabot>  [0]
03:32:40 <mniip> a comprehension doesn't have to have free variables
03:33:44 <magneticDuck> going through some of my old code.. I still remember when I used to write haskell like this
03:33:46 <magneticDuck> https://github.com/MagneticDuck/all-things/blob/master/sounds-of-duck/src/SoundsOfDuck/Notation/Note.hs#L116
03:33:46 <edwardk> question: i've heard a claim that hyperfunctions form an hughes style Arrow, but I've never actually seen the code for first or second. Does anybody know what the instance looks like?
03:35:21 <Cale> edwardk: I don't know if it's just my internet access being flaky or if this is down, but http://www.cse.ogi.edu/~krstic/psfiles/hyperfunctions.pdf is the paper
03:35:36 <ion> magneticDuck: And https://github.com/MagneticDuck/all-things/blob/master/sounds-of-duck/src/SoundsOfDuck/Notation/Note.hs#L100 :-)
03:35:42 <johnw> edwardk: I only have https://github.com/jwiegley/notes/blob/master/Hyper.hs
03:35:45 <Cale> http://www.csee.ogi.edu/~krstics/psfiles/hyperfunctions.pdf
03:35:52 <Cale> corrected url
03:35:53 <johnw> the instance is incomplete it looks like
03:35:57 <mniip> Cale, http://mathb.in/37576
03:36:13 <Cale> mniip: sure
03:36:22 <Cale> mniip: You can look at it like that if you want
03:36:22 <mniip> sure S might be empty, but that doesn't provide much of a proof
03:36:22 <magneticDuck> ion: there are so many gold nuggets in these old projects of mine
03:36:29 <magneticDuck> lol.
03:36:30 <mniip> Cale, so thus
03:36:37 <mniip> |- is =>
03:36:52 <Cale> Uhhh...
03:36:55 <Cale> Only sort of
03:37:02 <Cale> But then => is not ->
03:37:21 <mniip> it's not?
03:37:21 <Cale> -> was a symbol in our logic, like U is in this system
03:37:26 <Cale> or M
03:37:51 <magneticDuck> ion: I eventually got a bit better
03:37:53 <magneticDuck> https://github.com/MagneticDuck/all-things/blob/master/cw-data/src/CWData/Data.hs#L108
03:38:04 <mniip> Cale, I think I see the corner-stone of |-
03:38:13 <Cale> M, I and U certainly aren't the same thing as |- in any respect
03:38:37 <mniip> we have to define a set of 'valid strings' or 'true expressions' that operands are elements of
03:39:23 <Cale> mniip: There happens to be a lovely coincidence in many logical systems that whenever A |- B, we have |- A -> B (noting that in these systems, there are rules which give us some strings without any "inputs" as it were)
03:39:45 <Cale> mniip: So it becomes easy to confuse the two notions
03:39:54 <mniip> we have a set of 'valid logical expressions', say E
03:39:56 <Cale> mniip: But -> is just a symbol
03:40:09 <mniip> then we have a set of 'true expressions', say S
03:40:09 <Cale> while |- is saying something *about* this system of strings of symbols
03:40:22 <Cale> mniip: Don't even worry about what is true
03:40:27 <mniip> A |- B becomes A \in S \Rightarrow B \in S
03:40:40 <mniip> where S \subseteq E
03:41:02 <Cale> mniip: Maybe you could worry about "what is provable starting from an empty context", in the real logical case
03:41:20 <Cale> But all we've been talking about the whole time wasn't what's true, but what's derivable from what else.
03:41:44 <mniip> |- A would turn into \Rightarrow A \in S
03:41:55 <mniip> which is just a fact that A is indeed in S
03:42:18 <Cale> When you start talking about whether statements are "true", it tends to mean you have some means of interpreting those strings of symbols and giving them meaning
03:42:37 <Cale> Is MIUIU true?
03:42:45 <Cale> Is MU true?
03:42:48 <Cale> :D
03:43:06 <mniip> Cale, unknown and unknown
03:43:07 <Cale> It's a different question entirely from "Is MU derivable from MI?"
03:43:31 <mniip> once you say MI is true, then it's a different question
03:43:35 <Cale> The former assumes we have some way of interpreting these strings as meaningful statements. The latter only relies on the rules of the logic.
03:43:39 <Cale> Not even then!
03:43:39 <mniip> then MIU becomes true, and so does MIUIU
03:43:54 <Cale> It might be that the rules of this logic are unsound with respect to truth
03:44:05 <Cale> They might not preserve truth under interpretation.
03:44:17 <mniip> I fail to see how
03:44:23 <mniip> you're not using falsehood anywhere
03:45:32 <Cale> Well, let's define the interpretation of a string as expressing the notion that the number of I's and the number of U's are equal. Then the rules of our logic don't preserve truth under this interpretation.
03:45:49 <mniip> no
03:45:56 <mniip> a string is true if it's in S
03:45:59 <edwardk> johnw: your arrow is missing the first/second method
03:46:20 <Cale> mniip: I'm just trying to give you a sense for what the usual terminology surrounding logical systems is like
03:46:29 <edwardk> cale:i've read that paper and all the other stuff i can find by launchbury and krstics, et al.
03:46:42 <edwardk> cale: but i never actually found the explicitly laid out bit about how products work
03:46:46 <Cale> edwardk: ah, okay, then I have no idea :)
03:46:53 <edwardk> i can see that the L construction they used has an arrow instance, its trivial
03:47:01 <edwardk> but I'd hestitate to call it a hyperfunction
03:47:33 <edwardk> they make a claim that it has weak products, but there is no code and no text to support the random assertion
03:48:05 <Cale> mniip: When we talk about sentences being "true" in mathematical logic, we do so under a particular interpretation which is a sort of predicate involving strings in our logical system along with mathematical structures of some type, and which interprets the strings of symbols as saying "something about" the particular structures.
03:48:40 <mniip> well
03:48:51 <Cale> mniip: (this relation is highly recursive and a bit mindbending, but also very tedious to define -- you basically do it by recursion on the structure of the sentences in the logic)
03:48:55 <edwardk> and i've gone back to the original unpublished paper they had and "Categories of Processes Enriched in Final Coalgebras" <- which by the way is very well done
03:49:04 <mniip> we have a set of valid logical expressions V
03:49:10 <mniip> it just happens that (v \in V) \in V
03:49:15 <mniip> which is confusing
03:49:23 <Cale> Actually, let's use the term "well-formed" rather than "valid"
03:49:29 <mniip> okay
03:49:37 <Cale> "valid" usually means something else that we don't want to get confused about :)
03:50:12 <Cale> mniip: Wait, are you talking about first order set theory or something now?
03:50:18 <mniip> no?
03:50:28 <Cale> mniip: "v \in V" hasn't been a sentence in any of the systems we've been describing
03:50:31 <merijn> Cale: I think he is trying to reduce everything to something based in set theory, yes
03:50:41 <mniip> Cale, just my interpretation of |-
03:50:46 <Cale> What?
03:50:48 <merijn> Cale: That's been the case from the beginning, which is, I expect of where things break down
03:51:04 <Cale> mniip: So we have this set of strings, or well-formed formulas
03:51:10 <mniip> right
03:51:14 <Cale> mniip: and |- is this binary relation defined on that set of strings
03:51:22 <mniip> right
03:51:34 <Cale> "A -> B" in our logical case was itself one of that set of strings
03:51:40 <edwardk> anyways when i tried to go write the first/second code my brain got tied in knots
03:51:41 <mniip> what I'm trying to say
03:51:49 <edwardk> but this is a common result of working with hyperfunctions
03:51:53 <mniip> is that when A and B are statements
03:52:10 <mniip> the fact that A|-B is a statement is confusing
03:52:18 <Cale> A |- B is not a statement
03:52:39 <Cale> At least, not in the sense that we've been using the word "statement" formally.
03:52:53 <merijn> mniip: "When A and B are statements IN SYSTEM 1, then "A |- B" is a statement IN SYSTEM 2, where system 2 is a system that talks about system 1"
03:53:00 <mniip> merijn, right
03:53:05 <Cale> Right, sure.
03:53:13 <mniip> and it could happen that system 1 and system 2 are the same sort of system
03:53:23 <Cale> System 2 might be informal logic as we're just talking to each other.
03:53:28 <mniip> consider (A|-B) (B|-C) |- (A|-C)
03:53:36 <Cale> and yeah, system 2 might be a similar sort of system
03:53:54 <merijn> Clearly we need to type our logics to unconfuse this mess... :p
03:53:54 <Sindriava> Would anyone happen to have a PDF of the Haskell school of expression?
03:54:35 <mniip> Cale, what would you call 'A|-B' then
03:54:41 <mniip> terminology-wise
03:54:50 <Cale> A deduction.
03:55:07 <mniip> no, not the operator part
03:55:15 <merijn> Deduction or judgement
03:55:15 <mniip> what is the /type/ of 'A|-B'
03:55:39 <mniip> this got really meat
03:55:41 <mniip> meta
03:55:49 <merijn> mniip: It's called meta-theory for a reason :p
03:56:07 <Sindriava> Well it's not Char, despite the single quotes :D
03:56:19 <Cale> mniip: Well, yeah. It's a statement in the system we're using to reason about our logical system.
03:56:24 <mniip> right
03:56:46 <Cale> But don't confuse that with a statement *of* the logical system
03:57:07 <Cale> Which from the perspective of our outer system is merely a string of symbols (or something)
03:57:30 <mniip> (|-) :: Thing l => l -> l -> Statement
03:57:48 <Cale> If people write things like (A|-B) (B|-C) |- (A|-C), it's usually a notational abuse.
03:57:48 <mniip> you provided an example of l ~ MIULanguageThing
03:58:06 <Cale> I know this is #haskell, but please...
03:58:07 <mniip> I tried to grasp l ~ Statement, which is where the confusion comes from
03:58:14 <Cale> ah, okay
03:58:45 <mniip> okay
03:58:46 <Cale> mniip: So, we're pretty much never considering l ~ Statement
03:58:53 <mniip> are we
03:59:06 <Cale> But we might be considering l ~ Stmt where Stmt is superficially similar in structure to Statement
03:59:14 <Cale> (but fundamentally different)
03:59:22 <mniip> okay next question
03:59:28 <mniip> is horizontal bar the same thing as |-
03:59:56 <Cale> Sometimes kind of
04:00:20 <mniip> [13:57:06] <Cale> If people write things like (A|-B) (B|-C) |- (A|-C), it's usually a notational abuse.
04:00:39 <mniip> so if we replace the more meta-ed appearance of |- with a horizontal bar it's okay
04:00:44 <Cale> The stuff on top of the horizontal bar is usually a bunch of (metalogical) statements involving |-
04:00:45 <merijn> mniip: horizontal bar is a deduction in the meta theory, so "A |- B    X |- Y" horizontal bar "A,X |- B,Y"
04:00:49 <Cale> and below, similarly
04:00:58 <Cale> right
04:01:33 <merijn> mniip: So, given the deductions "A |- B" and "X |- Y" (which are statements in the meta theory) we can conclude a new deduction "A,X |- B,Y" which is, again, a statement in the meta theory
04:01:35 <mniip> merijn, so it's a metastatement about metastatements
04:01:46 <Cale> yeah
04:01:48 <merijn> mniip: Yes
04:01:52 <mniip> l ~ Statement
04:02:15 <Cale> It's the same thing as a logical implication A |- B and X |- Y => A,X |- B,Y
04:02:25 <Cale> in our outer theory
04:02:38 <merijn> As opposed to an implication in the inner theory
04:02:42 <Cale> right
04:02:43 <merijn> oh, too slow :)
04:03:12 <Cale> So we might even have a rule which says that whenever A |- B, then we also have |- (A -> B)
04:03:22 <Cale> Written with a horizontal bar
04:03:27 <Cale> A |- B
04:03:28 <Cale> --------
04:03:32 <Cale> |- A -> B
04:03:49 * hackagebot lentil 0.1.1.1 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.1.1 (fffaaa)
04:04:14 <mniip> I wonder whether |- is infixr or infixl
04:04:16 <Cale> Or once we annotate these things with terms, this would look like:
04:04:23 <Cale> Oh, it shouldn't matter
04:04:30 <mniip> A |- B |- |- A->B sounds nifty
04:04:33 <Cale> You'll never see A |- B |- C
04:04:35 <merijn> mniip: Usually there is only one |-
04:04:49 <merijn> Certainly not in TaPL
04:04:57 <Cale> Because A |- B isn't a statement of our inner system
04:05:06 <Sindriava> Would anyone happen to have a PDF of the Haskell school of expression?
04:05:18 <Cale> (or if it is, we should really be using two different symbols, like |- and ||- or something)
04:05:25 <mniip> Cale, this is similar to x == y == False
04:05:31 <Cale> (because it's like we're being intentionally confusing otherwise)
04:05:34 <Cale> mniip: right
04:06:01 <Cale> mniip: If you see someone write A |- B |- C, you can usually assume they mean that A |- B and B |- C
04:06:15 <Cale> as |- is a partial order
04:06:25 <Cale> or at least a preorder
04:06:34 <Cale> So, the usual conventions about orderings apply
04:06:44 <Cale> like when you write x <= y <= z
04:06:59 <mniip> x <= y <= EQ
04:07:21 <Cale> (I mean, not in Haskell, in ordinary mathematics)
04:07:29 <mniip> I
04:07:34 <mniip> I'm just kidding at this point
04:07:43 <Cale> okay
04:07:50 <Cale> So is everything a little clearer now?
04:07:56 <Cale> So, let's take that rule above
04:08:03 <Cale> A |- B
04:08:06 <Cale> ---------
04:08:08 <Cale> |- A -> B
04:08:36 <Cale> In type theory, we add terms to things, so this becomes:
04:08:47 <Cale> x:A |- y:B
04:08:50 <Cale> ---------
04:08:58 <Cale> |- (\x -> y) : A -> B
04:09:40 <merijn> Note that 'y' and 'x' can be arbitrarily complex terms, i.e., 'y' might contain multiple instances of the variable 'x'
04:10:26 <Cale> Well, yeah, this really requires a bit more care. Here x has to be a variable, and y can be any expression.
04:10:32 <mniip> yeah
04:10:40 <mniip> so it's actually y(x)
04:10:46 <merijn> Cale: Well, 'x' could be any term and it'd still work
04:10:54 <Cale> merijn: Well...
04:11:05 <merijn> Well, I guess this rule can't be :)
04:11:07 <Cale> merijn: Usually you don't allow lambda to capture arbitrary expressions...
04:11:24 <Cale> That might be interesting, but it would be weird :)
04:11:53 <Cale> Also, you'll often see contexts like:
04:11:57 <merijn> mniip: No, this is saying "if we have a term 'y : B' that contains a free variable 'x : A', then we can lambda abstract over that variable
04:12:06 <Cale> Gamma, x:A |- y:B
04:12:19 <merijn> mniip: Because it doesn't make sense to type terms with free variables
04:12:25 <mniip> merijn, I take it, it is not common to represent things-with-free-variables as macros
04:12:54 <merijn> mniip: No, because you get into messy things like capture and substitution, which TaPL covers in-depth in later chapters
04:13:06 <Cale> Gamma |- (\x -> y) : A -> B
04:14:19 <mniip> merijn, substitution is just calling the macro with a different argument, no?
04:14:21 <Cale> i.e. if from some collection of judgements Gamma, and the judgement that the variable x has type A, we can derive that the expression y has type B, then from Gamma, we may deduce that (\x -> y) has type A -> B
04:14:51 <Cale> Usually a type checker will read these rules "from bottom to top"
04:15:50 <Cale> i.e. it will see (\x -> y) : A -> B, and match this rule, and then it'll have to recursively check the stuff on top of the horizontal bar.
04:16:14 <Cale> i.e. it'll add x : A to the context it's carrying around, and try to check that y : B
04:16:17 <merijn> mniip: Consider the lambda term "(\x.\y.x) \a.y" here the second 'y' is free, but blindly substituting results in "\y.(\a.y)", whoops, we accidentally captured a free variable
04:17:04 <merijn> mniip: Now, obviously a trivial renaming can avoid this (commonly called alpha substitution), because "\x.x" is "obviously" identical to "\a.a" or "\z.z"
04:17:16 <merijn> But formalising this for a computer to understand is a pain :)
04:17:29 <mniip> which is why de-bruijn indices are better
04:17:48 <merijn> mniip: Right, but that's a reason not to assume it's just straight up substitution
04:18:22 <mniip> yeah, it's not a C preprocessor sort of substitution
04:18:54 <mniip> it's not really a problem
04:19:23 <mniip> just that in the rule Cale provided it takes extra effort to realize that x is a free variable of y
04:19:39 <merijn> mniip: it doesn't have to be! But it could be
04:19:53 <Cale> (well, the not-so-careful way I wrote it, it's tricky to realise x should be a variable at all)
04:20:09 <merijn> mniip: Suppose "|- 1 : Int" (i.e. we take 1 being an Int as axiom)
04:20:26 <merijn> mniip: Then obviously "x : T |- 1 : Int" also holds, yes?
04:20:34 <mniip> yes
04:20:50 <merijn> And we can still deduce "|- \x:T . 1 : T -> Int"
04:21:00 <mniip> whether x is a free variable of 1 is arguable
04:21:07 <merijn> mniip: It is not
04:21:27 <merijn> mniip: It doesn't appear in the term 1, therefore is not free in it
04:21:52 <mniip> x does not appear free in 1
04:22:18 <mniip> but you still can substitute all free occurences of x in 1 with something
04:22:34 <merijn> mniip: Right
04:22:39 <mniip> I guess a more formal way would be
04:22:56 <mniip> x is something whose free occurences in y can be substituted
04:23:07 <merijn> mniip: Substitution is formalised later on in TaPL
04:23:15 <merijn> Including issues of capture/non-capture
04:29:22 <ortersa> hey haskell! 1) is this a friendly community? 2) is there a more beginner-oriented irc channel for those of us coming over from some other language?
04:29:36 <ackthet> ortersa: #haskell-beginners 
04:29:41 <merijn> ortersa: The friendliest on freenode
04:29:44 <Cale> ortersa: 1) yes, and 2) you're in the right place
04:29:46 <merijn> ortersa: Beginner questions are fine here
04:30:13 <Cale> #haskell-beginners exists, but I kind of hate the fact that it's named the way that it is
04:30:52 <merijn> I think it's useful as a sort of "studygroup" channel, but it's unfortunate the name implies that beginners aren't in the right place here, yes
04:30:57 <Cale> (because it might make people think that #haskell isn't for beginner discussion)
04:31:44 <ortersa> makes me very glad to hear!
04:32:47 <ortersa> community might be less important than language features, but it is very sad to not have a good irc channel to fall back on when things get tough
04:33:09 * merijn has learned more from #haskell than a 5 year CS degree :p
04:33:22 <merijn> Actually, that's probably not entirely true, but more true than you'd think
04:35:23 <ortersa> ill pour in some effort over the next few weeks, hopefully I can come back with some semi-intelligent questions by then. 
04:36:48 <mniip> merijn, 3.5.17 mentions the difference between small step semantics and big step semantics, which makes me wonder: how would you implement the former in, say, haskell
04:37:42 <mniip> (am I correct in thinking that ⇓ is some kind of eval, where for example eval (Add x y) = eval x + eval y)
04:37:45 <Cale> mniip: Write your function Expr -> Expr such that it only applies one rule at a time
04:37:50 * dreams dislikes natural semantics.
04:38:48 <mniip> Cale, like it should try each of the rules in order?
04:39:18 <Cale> mniip: It doesn't matter what order they're tried in, just that it doesn't proceed to apply another one immediately after
04:39:44 <dreams> you see this is why natural semantics can confuse people, 'oh this step is messing how it is done?'
04:39:58 <dreams> missing*
04:43:50 <lpaste> mniip pasted “small step semantics” at http://lpaste.net/134394
04:43:51 * hackagebot second-transfer 0.5.3.2 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.5.3.2 (dsign)
04:43:53 <mniip> like this then?
04:46:03 <mniip> interesting
04:46:19 <mniip> I've never heard about this way of evaluating things before
04:46:30 <mniip> thinking that big step semantics is something like the only one
04:46:46 <ion> The last clause of smallStep isn’t a small step, is it?
04:46:59 <dreams> mniip: which semantics are you implementing?
04:47:40 <mniip> ion, it is
04:48:01 <mniip> a -> b  |-  If a x y -> If b x y
04:48:18 <ion> ok
04:48:27 <dldl> chaps, my haskell has rapidly been improving ever since I picked it up a month or so ago. However, whenever I'm finishing up a project I always end up with a disorganized collection of Maybe's, Lists and Eithers that I have to coerce together using highly nested case statements. Is this normal or does my code smell?
04:48:54 <dldl> and if so, any general words of wisdom on how to "unsmell" my code?
04:48:57 <liste> dldl monads to the rescue!
04:49:52 <dldl> liste, sure thing - but the problem is I usually have multiple types of "contexted value" i.e. eithers and maybes and lists
04:50:03 <dldl> one by itself wouldn't be a problem
04:50:17 <mniip> who you're gonna call? transformers!
04:50:27 <mniip> jk
04:50:43 <liste> could Compose help?
04:51:07 <liste> @let import Data.Functor.Compose
04:51:08 <lambdabot>  Defined.
04:51:34 <ion> dldl: Perhaps you can substitute Just and (:[]) and Right with pure, and substitute Nothing and [] with empty to get more generic code.]
04:52:37 <liste> > Compose [Just (+4), Nothing] <*> Compose [Just (3 :: Int), Just 8]
04:52:38 <lambdabot>  Compose [Just 7,Just 12,Nothing,Nothing]
04:53:08 <ion> dldl: It’s difficult to make precise suggestions without seeing the code.
04:53:48 <dldl> ion, I understand that. It was probably foolish to ask - just wanted to see if anyone could provide some general words of wisdom
04:54:12 <ion> Well, you got some suggestions. Do you think they are useful for your code?
04:54:28 <mniip> liste, I don't think a :: Int is needed
04:54:39 <liste> mniip it's for the Show instance
04:55:05 <mniip> liste, defaulting takes care of that, no?
04:55:11 <mniip> > Compose [[3]]
04:55:12 <lambdabot>  Compose [[3]]
04:55:17 <ion> > Compose [Just (+4), Nothing] <*> Compose [Just 3, Just 8]
04:55:18 <lambdabot>  Compose [Just 7,Just 12,Nothing,Nothing]
04:55:18 <liste> cool (:
04:56:07 <liste> Compose doesn't work for Monad, though
04:57:18 <merijn> mniip: FYI, there's ocaml implementations of all the code (and more) of TaPL and I believe someone translated it to haskell too
04:57:29 <merijn> mniip: So you can just look at the evaluation code :)
04:57:41 <mniip> liste, (Traversable f, Monad f, Monad g) => Monad Compose f g, is possible
04:57:43 <dldl> ion, I believe so, yes. Though thinking about it now, I think the main issue is with me picking different wrappers rather arbitrarily. I.e. using Either Error a, whilst never looking at the error <- that could've just been a Maybe
04:57:57 <merijn> mniip: https://code.google.com/p/tapl-haskell/
04:58:17 <ion> dldl: And it could even have been an Alternative f => f a so you get to choose the instance from the outside.
04:59:39 <dldl> all - thanks for the help! I'll go away and think about this more now. 
05:01:06 <edwardk> Cale, johnw: thinking about hyperfunctions some more
05:02:30 <edwardk> so if we take CoState x a b = (x -> a) -> (x -> b)  as a type of arrow. we can rearrange it to get a cokleisli arrow for Store x, or we can rearrange it so that it is an H-coalgebra of H a b x = (x -> a) -> b
05:02:54 <edwardk> then we can say that a hyperfunction is a final coalgebra of that H a b type. this is more or less what launchbury et al did
05:03:32 <edwardk> but i could choose to resent my hyperfunction as this x -> (x -> a) -> b   with just an existential x, then we can play the representable functor game i did in my recent post
05:03:50 <edwardk> data Hyper a b where Hyper :: Representable f => f (f a -> b) -> Hyper a b
05:04:16 <edwardk> now we might be able to get some tabulation without having to think about hyperfunctions as machines with just push/base like launchbury and co do
05:04:40 <edwardk> or something like that
05:04:44 <edwardk> it isn't rigorous yet
05:06:02 <edwardk> secondly that same approach gave a nice way to think about moore machines. we can take    (a -> x) -> (b -> x) -- which is like the notion of a linear map from a vector space with basis a to a vector space with basis b that I use in linear, which is re-arrangable into a Kleisli arrow for Cont x or Covector x
05:07:56 <edwardk> but it can also be arranged into an algebra: (a -> x, b) -> x  by uncurrying, for the functor S a b x = (a -> x, b) which is the thing we use for the atkey style indexed store comonad. now we can see this as the S a b functor algebras. and there is a unique homomorphism from the initial S a b coalgebra, which is a Moore machine. you have a 'b', and a
05:07:56 <edwardk> function from a to a new machine
05:08:53 <webchat099> edwardk : obviously
05:09:11 <edwardk> similarly (a, x) -> (b, x) can be uncurried to get a state monad kleisli arrow or to get a coalgebra x -> (a -> (b, x)) for a functor R a b x = R (a -> (b, x)) -- then the final coalgebra of R is a Mealy machine
05:09:38 <edwardk> so this gives me a nice way to think about mealy and moore machines and hyperfunctions all with one little trick in terms of algebras.
05:09:55 <edwardk> the mealy / hyperfunction trick was written up back in 2000 or so, but the moore machine trick is something i've never seen before
05:10:04 <mniip> tl;dr everything is a hyperfunction
05:10:15 <edwardk> nor have i seen anyone try the representable functor trick to try to make efficient hyperfunctions
05:10:19 <edwardk> that seems new
05:11:01 <edwardk> i don't know if it actually pans out but we can see with such a hyperfunction where Hyper a b = exists f. Representable f => f (f a -> b)  -- that we can choose f = Identity to get the lifting of arrows into hyperfunctions at least
05:11:49 <webchat099> tl;dr is too long. use tldr
05:11:59 <edwardk> mniip: not quite, more that the same encoding trick that lets us derive hyperfunctions give us a way to derive mealy/moore machines as initial algebras / final coalgebras of simpler transducer models
05:12:18 <mniip> I know some of those words
05:12:56 <mniip> (it made more sense when represented with haskell types as opposed to spoken terminology)
05:13:07 <pacak> mniip: I know most of them, buuuut....
05:14:19 <eds> Say I have a data defined data G = Arith Char G G and function defined evala G -> Maybe [Int]; evala (Arith c e1 e2) | c =='p' = liftM2 (++) (evala e1) (evala e2) |c=='u' = liftM2 (union) (evala e1)(evala e2). How can I choose one of them if need to in one of the function that I create?
05:14:26 <edwardk> pacak: mostly looking for ways to find efficient encodings of them
05:14:39 <edwardk> i know how to efficiently encode moore machines
05:14:48 <edwardk> and these things are now closely related
05:15:04 <lyxia> edwardk: Choose what?
05:15:06 <lyxia> eds
05:15:09 <lyxia> Sorry
05:15:37 <eds> Like choose (++) for an operation that I need to perform.
05:16:17 <eds> I would call evala e but then how do I make the compiler distinguish between (++) and (union)? 
05:16:50 <lyxia> eds: Well it picks the branch depending on the value of e.
05:17:56 <eds> lets say that function is func :: G -> Int; func e = evala e
05:18:40 <lyxia> eds: if you want to concatenate e1 and e2, you can write (evala (Arith 'p' e1 e2)).
05:18:41 <eds> how would it know which branch to pick? (++) or (union). I have char in data G for that purpose but I don't know how I would implement that.
05:19:04 <Axman6> you have already implemented that haven't you?
05:19:37 <eds> I meant how would I use it to distinguish between those too. ok let me try that.
05:23:26 <eds> I am doing something wrong. Here it is with the changes I made. http://lpaste.net/132328
05:23:33 <eds> lyxia
05:24:40 <liste> eds pattern match, don't guard
05:24:57 <liste> myFitness n e@(Arith 'p' e1 2) = ...
05:26:19 <eds> Ahh ok. that did it. Now what if I need both (++) and (union)? Just write c instead of specifying the char?
05:27:18 <edwardk> ok, i made some mistakes in that representable thing
05:30:27 <edwardk> it'd be that ana :: (x -> f x) -> x -> Nu f -- and f x = (x -> a) -> b -- so we'd ball up the arguments and get the usual Nu construction by reading off its universal property Nu f = exists x. (x -> f x, x)  and say that we want to say x is the representation of a representable functor. so you want  Nu f =exists t.  Representable t => (Rep t -> f (Rep t),
05:30:27 <edwardk> Rep t))  = exists t. Representable t => (t (f (Rep t)), Rep t)  
05:31:16 <edwardk> so now we have a representation of the current state, and a 't' structure full of 'f x =  (x -> a) -> b)'  where x = Rep t
05:35:13 <edwardk> data Hyper a b where Hyper :: Representable g => g ((Rep g -> a) -> b) -> Rep g -> Hyper a b -- can be simplified one step further because of the Rep g -> a
05:35:14 <edwardk> to
05:35:32 <edwardk> data Hyper a b where Hyper :: Representable g => g (g a -> b) -> Rep g -> Hyper a b
05:35:57 --- mode: ChanServ set +o edwardk
05:36:04 --- kick: yuupers was kicked by edwardk (yuupers)
05:36:05 --- mode: edwardk set +b yuupers!*@*
05:36:18 --- mode: edwardk set -o edwardk
05:36:30 <mniip> Cale, I think I proved the MIU thing
05:44:16 <mniip> looks like it boils down to counting I and U and examining the parities
05:57:22 <mniip> random question: it is a common idiom to write (x:xs), (d:ds), (rho:rhos) in function pattern matches
05:57:34 <frerich> mniip: Yeah, it is.
05:57:43 <mniip> how would you deal with a@(b:_), a@(b:c), a@(_:c)
05:57:48 <mniip> and (a:b:c)
05:58:11 <merijn> mniip: The reuse of names in the @ version is an error
05:58:33 <merijn> Or are those separate examples?
05:59:27 <frerich> mniip: I'm not aware of any common patterns for those other cases. Some people like '(a:b:c:_)'. Others use x:y:z. Others use '(x0:x1:x2:_)'. And then there are people (like me) who just mix and match, whatever feels right.
05:59:57 <mniip> merijn, separate
06:00:10 <frerich> mniip: The 'x:xs' or 'a:as' thing, i.e. the 's' suffix for the tail, is very common though.
06:00:15 <mniip> I mean it makes sense to match xs@(x:_)
06:00:15 <pacak> I'd go with xs@(x:_)
06:00:26 <mniip> but what if you have to name all 3 elements
06:00:59 <merijn> mniip: "l@(x:xs)" l for list
06:01:14 <merijn> or xs@(h:t) h for head, t for tail
06:01:18 <mniip> what if you have multiple
06:01:31 <merijn> mniip: Rejoice that the alphabet has 26 letters :)
06:01:46 <mniip> merijn, oh, I used xs@(xh:xt) in the past
06:01:55 <mniip> (x-head and x-tail)
06:02:05 <byorgey> mniip: sounds good
06:02:15 <mniip> what about (a:b:c) though
06:02:18 <pacak> But if you want to pattern match first three element from the list - I suspect there's something wrong with your code.
06:02:19 <pacak> > let ы = 100 in ы * 10
06:02:20 <lambdabot>  1000
06:03:41 <mniip> pacak, first two
06:03:41 <pacak> > let ろ = 4 in 10 * ろ
06:03:43 <lambdabot>  40
06:03:44 <mniip> c is tail
06:04:12 <pacak> So more than 26 letters.
06:04:18 <pacak> x1:x2:xs
06:05:34 <ij> Module is the one you import, package the one you "cabal install"?
06:06:00 <pacak> ij: Yes.
06:07:20 <mniip> > let ಠ_ಠ = text "ಠ_ಠ" in ಠ_ಠ
06:07:21 <lambdabot>  ಠ_
06:07:42 * mniip wonders where's the encoding failure come from
06:08:59 <pacak> works  in ghci. some lambdabot issue I suppose
06:09:19 <pacak> let ಠ_ಠ = text "xಠ_ಠx" in ಠ_ಠ
06:09:24 <pacak> >let ಠ_ಠ = text "xಠ_ಠx" in ಠ_ಠ
06:09:31 <geekosaur> space
06:09:34 <pacak> > let ಠ_ಠ = text "xಠ_ಠx" in ಠ_ಠ
06:09:36 <lambdabot>  xಠ_ಠx
06:09:42 <pacak> formatting problem.
06:10:58 <ion> Weird, the ಠ pushes the line down by one pixel which hides the _
06:11:01 <ion> in my terminal
06:11:24 <maerwald> ion: looks fine here
06:11:57 <ion> I’d expect it to, this is clearly a bug in a single piece of software.
06:12:21 <pacak> ion: locale?
06:12:36 <ion> pacak: It’s not a locale problem but font rendering problem.
06:13:24 <pacak> ion: Hmmm... Not sure about that unless you are using some exotic OS like windows...
06:13:55 * hackagebot wai-middleware-crowd 0.1.1.2 - Middleware and utilities for using Atlassian Crowd authentication  http://hackage.haskell.org/package/wai-middleware-crowd-0.1.1.2 (MichaelSnoyman)
06:14:23 <ion> No locale settings can have the effect that some glyphs cause a line of text to jump downwards by 1 pixel, truncating the bottom row of pixels on that line.
06:19:37 <m1089> eiit
06:22:17 <JamesJRH> Hi, what's the easiest way to use Aria2 to download a list of URLs that are generated in Haskell?
06:22:51 <JamesJRH> Where the list is probably longer than the maximum number of arguments allowed in a shell.
06:23:01 <Axman6> output into a file, use cat <file> | xargs aria2 (with appropriate flags)?
06:23:10 <pacak> Split the list into separate smaller chunks?
06:23:24 <pacak> wget -i list
06:28:05 <JamesJRH> Axman6: That would still have the argument problem. If I'm going to use a file, I might as well use Aria2's Metalink file feature.
06:28:31 <Walther> Hmm. How are haskell's graphics libraries? There's a local hackathon for computer graphics / demoscene, I'm considering if it could be doable
06:28:59 <ggVGc> Walther: probably check out Fay
06:29:01 <ggVGc> for that
06:29:03 <keko_> SDL and OpenGL work fine too
06:29:15 <ggVGc> uhm ,no not fay
06:29:37 <Walther> Obviously i'd prefer something not too low level
06:29:48 <Walther> with sane primitives
06:30:01 <ggVGc> Walther: I meant Helm. A haskell-based language aimed at FRP game rogramming
06:30:17 <ggVGc> Walther: http://helm-engine.org/
06:30:38 <Walther> thanks, will look into that
06:31:01 <Walther> how are the other options - i remember googling some lib for haskell/sdl exists
06:31:22 <ggVGc> dunno, I haven't done any graphics programming in haskell yet myself, but if I did I'd go with Helm
06:31:40 <ggVGc> since it's specifically made for it, 
06:32:19 <Walther> sure. Just want to have a vague list of alternatives to choose from
06:33:09 <ggVGc> I think there are decent SDL bindings out there, but personally SDL is too low level for weekend hacking some game
06:35:54 <JamesJRH> Axman6: Actually, I can just get Haskell to output the URIs and pipe that to something like ‘aria2c -i -’. I think I'll do that. :-)
06:38:10 <edwardk> Cale, johnw: i managed to construct the first/second/***/&&& implementations for hyperfunctions. it was a weird journey
06:38:57 * hackagebot riemann 0.1.0.1 - A Riemann client for Haskell  http://hackage.haskell.org/package/riemann-0.1.0.1 (telser)
06:39:34 <ion> JamesJRH: You can also launch aria2c -i - from Haskell and feed things into its stdin.
06:39:51 <ion> @hackage process
06:39:51 <lambdabot> http://hackage.haskell.org/package/process
06:40:26 <ion> And pipes/conduits probably provide something like that as well.
06:50:14 <ion> Given a list, i’d like to convert it to a Peano number. I’d like to have zero runtime overhead but still prevent access to the values contained in the list. However, newtype Peano = forall a. Peano [a] is illegal. Is there a way to do this?
06:51:09 <c_wraith> ion: If you want an existential, you need data.
06:51:27 <mniip> question about small step semantics and big step semantics
06:51:39 <c_wraith> data Peano where Peano :: [a] -> Peano
06:51:59 <c_wraith> using GADT syntax, which I think is a bit simpler than the other existential syntax
06:52:02 <mniip> in untyped lambda calculus normal form checking is a bit expensive
06:52:12 <mniip> how do I avoid the costs of doing it on every reduction step
06:52:35 <ion> c_wraith: That has overhead though. Not that the overhead will probably matter, but it would have been nice to have a solution without any. 
06:54:14 <c_wraith> ion: you could use the CPS transform to store it in a newtype, but that has similar overhead
06:56:32 <c_wraith> newtype Peano = Peano (([a] -> r) -> r)
06:59:38 <c_wraith> But then creating one is like...  peano :: [a] -> Peano ; peano x = Peano ($ x)
06:59:42 <athan> Hey guys, anyone know how to generate /unique/ strings in QuickCheck?
06:59:44 <c_wraith> And there's your overhead again
06:59:53 <ion> c_wraith: yeah
07:00:01 <athan> (if I have a component of my data type in the form of [String]) I mean
07:00:47 <c_wraith> ion: this might be were uhc's exists keyword extension is actually useful. :)
07:01:23 <ion> Would this work in UHC? f :: forall a. exists b. [a] -> [b]; f = id
07:01:38 <c_wraith> I haven't used it.  I don't know.
07:03:29 <dolio> The problem is that you can't have existentials be free without getting some weird consequences in conjunction with other features.
07:03:54 <dolio> It's kind of like how you can't erase equality proofs, because you have to check that someone didn't use bottom.
07:03:56 <c_wraith> Yeah, I assumed that was the reason GHC doesn't have it.  All the *other* type system extensions it supports
07:06:36 <JamesJRH> Can I pass a Haskell expression to GHCi or runhaskell as a shell argument to be evaluated to stdout?
07:06:41 <vikaton> I'm going to write a windows keylogger as my first haskell program
07:06:55 <Axman6> ghc -e does that I think
07:06:56 <ion> JamesJRH: ghc -ignore-dot-ghci -e 'expression'
07:06:57 <JamesJRH> I can't seem to find the manpage on my system.
07:07:14 <JamesJRH> ion: Aah, thank you!
07:08:08 <tar_> Is there a lazy forM? All the list elements seem to get evaluated even if I don't use them in the action.
07:09:56 <ion> > forM [error "oh no"] (\_ -> pure ())
07:09:58 <lambdabot>      No instance for (Show (m0 [()]))
07:09:58 <lambdabot>        arising from a use of ‘show_M7047197518423160634601’
07:09:58 <lambdabot>      The type variable ‘m0’ is ambiguous
07:10:23 <ion> > forM [error "oh no"] (\_ -> pure ()) :: Maybe [()]
07:10:26 <lambdabot>  Just [()]
07:12:33 <tar_> hmmmm, pattern-matching a tuple is enough to force evaluation? My action is like \(a, (b, c)) -> pure ()
07:12:45 <ion> > forM (repeat ()) (\_ -> Nothing) :: Maybe [()]
07:12:46 <lambdabot>  Nothing
07:13:12 <ion> tar: Pattern-matching a tuple evaluates the tuple constructor. You can use an irrefutable pattern to prevent that. \ ~(a, (b, c)) -> pure ()
07:13:25 <vikaton> > k = "hi"
07:13:26 <lambdabot>  <hint>:1:3: parse error on input ‘=’
07:13:40 <vikaton> > kH = "k"
07:13:41 <lambdabot>  <hint>:1:4: parse error on input ‘=’
07:14:10 <ion> > let k = "hi" in k
07:14:11 <lambdabot>  "hi"
07:14:17 <tar_> ion: thank you!
07:14:23 <vikaton> > k' = "hi"
07:14:24 <lambdabot>  <hint>:1:4: parse error on input ‘=’
07:14:29 <tjscanlon> What is the recommended way to write inner functions using tail recursion?
07:14:38 <tjscanlon> Should they be included in the main function call using a where statement or exist outside of it
07:14:42 <vikaton> isnt k supposed to be a definition?
07:14:55 <ion> vikaton: lambdabot only evaluates expressions.
07:15:40 <ion> tjscanlon: Depends on whether you want to export the helper or test it from outside the where block.
07:15:41 <tjscanlon> http://lpaste.net/541282805485666304
07:15:48 <tjscanlon> Okay, thanks!
07:16:38 <ion> So in general, whether you want to use it in any way from outside the where block.
07:16:54 <vikaton> so for declaration, I have to use 'let' ?
07:18:06 <ion> vikaton: “let ... in ...” lets you have an expression that has declarations within, yeah.
07:18:33 <vikaton> hmm
07:19:28 <ion> let <declarations> in <expression>
07:19:42 <ion> the declarations are in scope within the <declarations> and the <expression>
07:20:13 <vikaton> I was trying to add 'a=1' in the prompt
07:20:17 <vikaton> when it only works in the script
07:20:34 <ion> Which prompt? ghci?
07:20:54 <vikaton> yeah
07:21:26 <ion> In ghci, you can enter “let a=1”. There’s no real reason for it to need the “let”, that’s just how it is implemented at the moment.
07:21:59 <vikaton> I see, so 'let ... in ...' is a declaration that acts like an expression?
07:22:04 <vikaton> > let a  = 1
07:22:04 <ion> As opposed to lambdabot, ghci supports other things than expressions, such as “let” (no “in”) declarations and “a <- foo”
07:22:05 <lambdabot>  <no location info>: not an expression: ‘let a  = 1’
07:22:11 <vikaton> > let a = 1
07:22:12 <lambdabot>  <no location info>: not an expression: ‘let a = 1’
07:22:17 <vikaton> yeahh
07:22:35 <ion> “let ... in ...” is an expression that has declarations within, “let ...” (without an “in”) is special syntax within “do” blocks and ghci.
07:22:53 <vikaton> I need to read more to understand
07:39:30 <srhb> tjscanlon: Have you read about how Haskell does not have TCO, how tail recursive calls might stack overflow and why you might not need to worry about either, depending? :-)
07:39:45 <tjscanlon> I have not! I am just jumping into the language
07:39:49 <tjscanlon> I'll Google around a bit
07:40:01 <c_wraith> "does not have TCO" is just as misleading a statement as "has TCO". :)
07:40:16 <srhb> I suppose so.
07:40:30 <srhb> How TCO is irrelevant -- is that better?
07:40:43 <tjscanlon> Thanks for the help
07:40:47 <merijn> How about "tail calls and call stacks are irrelevant notions in haskell"?
07:40:51 * srhb nods
07:40:53 <srhb> Better. :)
07:41:16 <merijn> tjscanlon: The simple summary is as follows
07:41:34 <merijn> tjscanlon: The idea behind TCO is to avoid blowing up the function call stack, yes?
07:42:03 <tjscanlon> Yes!
07:42:09 <merijn> tjscanlon: Haskell (as implemented by GHC, at least) does not use a function call stack, and thus cannot blow it up/overflow it
07:42:27 <chpatrick> "You cannot use atomically inside an unsafePerformIO or unsafeInterleaveIO. Any attempt to do so will result in a runtime error."
07:42:36 <merijn> tjscanlon: There's another stack type in haskell (pattern match stack), but it is unrelated to how deeply you nest your function calls
07:42:38 <chpatrick> is that actually enforced or do they mean runtime error as in undefined behavior?
07:42:43 <chpatrick> because I seem to be getting away with it
07:42:44 <srhb> chpatrick: Try!
07:42:55 <chpatrick> yeah I can use it
07:42:56 <chpatrick> which is weir
07:42:57 <tjscanlon> Hmm, so a 'naive' factorial function would not be so naive after all then, right?
07:43:28 <merijn> tjscanlon: Well, the naive factorial is still exponential, so...
07:43:35 <c_wraith> tjscanlon: well, it still builds an evaluation stack, because it builds up an expression like 5*(4*(3*(2*1)))
07:43:38 <merijn> oh, eh
07:43:43 <merijn> factorial is fine, yeah
07:43:45 <c_wraith> factorial, not fib. :P
07:43:51 <srhb> chpatrick: are you evaluating the unsafePerformIO?
07:44:31 <chpatrick> srhb: indeed
07:44:32 <c_wraith> tjscanlon: the thing is, the recursive calls are not the problem, but the fact that it builds up an expression with the same shape as the recursive calls..  that is less than optimal.
07:44:33 <chpatrick> Prelude Control.Concurrent.STM System.IO.Unsafe> unsafePerformIO $ atomically $ return ()
07:44:33 <chpatrick> ()
07:45:02 <c_wraith> It may only check when reading/writing a TVar
07:45:09 <chpatrick> my real code does that too
07:45:14 <chpatrick> no complaints
07:45:21 <merijn> tjscanlon: Yeah, some functions (e.g. foldl) happen to blow up the callstack by building excessively large thunks, which can be avoided by making the accumulator strict
07:45:28 <tjscanlon> Hmmm, okay.  Thank you for the explanation.  I really appreciate it!
07:45:36 <tjscanlon> The strict operator is $!, correct?
07:45:56 <chpatrick> Prelude Control.Concurrent.STM System.IO.Unsafe> tv <- newTVarIO 42
07:45:56 <chpatrick> Prelude Control.Concurrent.STM System.IO.Unsafe> unsafePerformIO $ atomically $ readTVar tv
07:45:56 <chpatrick> 42
07:46:00 <c_wraith> that's only one form.  But it's often good enough
07:46:07 <merijn> tjscanlon: But the only way to make accumulators strict is by passing it as argument to a function, so making something like foldl strict requires rewriting to tail calls so you can pass the accumulator as argument
07:46:29 <merijn> tjscanlon: But it's not the tail call that solves the problem there, but the fact that you make the accumulator strict
07:47:03 <merijn> tjscanlon: For example the naive map "map _ [] = []; map f (x:xs) = f x : map f xs" is perfectly efficient, despite not being a tail call
07:47:17 <merijn> Runs in constant stack space
07:48:11 <merijn> chpatrick: Just remember the following
07:48:15 <merijn> @quote not.a.bug
07:48:15 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
07:48:16 <merijn> :)
07:48:41 <tjscanlon> Very cool!
07:48:43 <srhb> Well, the docs are misleading. Not that it matters much in this case. :-)
07:49:45 <chpatrick> merijn: it is a bug when the docs explicitly say otherwise
07:50:21 <merijn> tjscanlon: There's a good (as far as I can tell from skimming it) guide to lazy evaluation that also covers this example at https://hackhands.com/guide-lazy-evaluation-haskell/
08:09:01 * hackagebot linear-grammar 0.0.1.1 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.1.1 (athanclark)
08:13:36 <chpatrick> is there a nice non-STM alternative for condition variables?
08:13:51 <chpatrick> I'm trying to make a pure interface that does reference counting internally
08:14:01 <chpatrick> and I can't use unsafePerformIO with STM
08:15:19 <nuttycom1> Hi all. I'm just starting to play around with Free and Coyoneda, and it seems like there are a bunch of different options with how to interpret the free structure. There's iterM, there's retract . hoistF, and seems like a bunch of other possibilities. Is there a "preferred" approach?
08:15:22 <srhb> Hmm, a pure interface. Well, the only bet would be to implement it in State I guess
08:27:30 <vikaton> > let b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] in b !! 2  
08:27:32 <lambdabot>  [5,3,3,3]
08:27:36 <vikaton> :D
08:28:23 <vikaton> would [5,6,6,7]:b modify the vale of b ?
08:28:53 <Iceland_jack> vikaton: no
08:29:02 * hackagebot linear-grammar 0.0.1.2 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.1.2 (athanclark)
08:29:07 <Iceland_jack> > let b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] in (b, [5,6,6,7]:b)
08:29:09 <lambdabot>  ([[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]],[[5,6,6,7],[6,6,6],[1,2,3...
08:29:20 <Iceland_jack> > let b = [1,2,3] in (b, 0:b)
08:29:21 <lambdabot>  ([1,2,3],[0,1,2,3])
08:29:30 <mniip> vikaton, that creates a new value, which references b
08:29:43 <vikaton> Ok, thanks
08:30:14 <vikaton> same thing with ++ ?
08:30:24 <srhb> vikaton: Yep. Values are always immutable.
08:30:33 <srhb> vikaton: They cannot be altered.
08:30:37 <mniip> vikaton, same thing with generally any feature of the language
08:31:22 <shiona> they however will share the contents of b
08:31:41 <mniip> seeing as you're relatively new to the language I won't try to explain unboxed mutable arrays
08:31:49 <shiona> :D
08:32:12 <vikaton> I forgot that haskell was immutable xP
08:32:14 <chpatrick> is it a hack to do signalQSemN sem (-1)?
08:32:22 <chpatrick> feels wrong but it works
08:32:45 <vikaton> the only immutability ive dealt with were Rust's default immutable types
08:33:24 <mniip> vikaton, haskell has no variables
08:33:31 <mniip> as such, there's nothing to mutate
08:33:33 <mniip> there's only values
08:33:50 <vikaton> wooooow
08:33:56 <mniip> (the only variables haskell has are variables in a mathematical sense, like x in f(x)=x^2)
08:34:23 <vikaton> oboi
08:34:33 <vikaton> this is gonna be fun xP
08:34:50 <WrksOnMy1achine> Your life will change
08:34:51 <srhb> vikaton: Yep! :-)
08:36:01 <mniip> if I have a data D = A { a, b, c, ... } | B { a, b, d, ... }, is there a better way that doesn't involve typing a and b twice
08:37:02 <srhb> mniip: Aside from having a separate type for those three and reusing it?
08:37:15 <mniip> hmm
08:37:18 <mniip> that doesn't sound fun
08:37:29 <srhb> Well, then no. :-)
08:37:51 <bergmark> mniip: using records directly in a sum type leads to partial functions, so it's better to pull it out
08:38:36 <mniip> bergmark, I'd rather A {c = c} than (A _ _ _ _ c _ _ _ _ _ _ _)
08:38:57 <mniip> oh and imagine the fun when the definition of A changes
08:39:02 * hackagebot dozens 0.1.0 - dozens api library  http://hackage.haskell.org/package/dozens-0.1.0 (HirotomoMoriwaki)
08:39:14 <bergmark> yeah i try to avoid that as well
08:40:07 <bergmark> but you can simply do data D = DA A | DB B; data A = A { ... } instead
08:40:49 <mniip> hmm
08:42:11 <mniip> I think I will go with
08:42:22 <mniip> data F = A ... | B ...
08:42:33 <mniip> data D = D { ... f :: F}
08:42:42 <mniip> how's that sound
08:44:17 <bergmark> mniip: can you give an example without ...'s? I don't see how this models the same thing
08:45:46 <dolio> If you use lens, then having a sum type where some constructors lack fields can be used to derive traversals.
08:45:51 <dolio> Which is handy.
08:45:58 <mniip> data Expr = Ix Integer | Tag String | App TExpr TExpr | Lambda TExpr
08:46:29 <mniip> data TExpr = TExpr { expr :: Expr, nf :: Bool, leasFree :: Integer }
08:47:13 <mniip> leastFree*
08:47:26 <bergmark> mniip: ah, that looks like a fair compromise
08:47:58 <hodapp> hmm, wonder how much of a pain it'll be to remake Control.Monad.Trans.Cont as basically a continuation type that works on a function-like-type that has similarities but for which 'calling a function' is different
08:48:47 <bergmark> mniip: another way would be to add an annotation, data Expr a = Ix a Integer | App (Expr a) (Expr a), and use a ~ Ann where data Ann = Ann { nf : Bool, ... }
08:49:02 * hackagebot dozens 0.1.1 - dozens api library  http://hackage.haskell.org/package/dozens-0.1.1 (HirotomoMoriwaki)
08:49:36 <mniip> bergmark, I don't see how that helps
08:49:55 <mniip> you're only using Ann in Ix
08:50:09 <bergmark> mniip: woops, meant App a (Expr a) (Expr a)
08:50:30 <mniip> oh
08:50:48 <mniip> my Expr/TExpr approach even has a nice Eq instance
08:51:02 <bergmark> e.g. haskell-src-exts uses this for the annotated syntax tree, by default each annotation holds source location info, and then other packages can annotate it further, e.g. with name information
08:51:07 <mniip> I can derive one for Expr, and for TExpr it's just a == b = expr a == expr b
08:51:24 <mniip> bergmark, I don't want Expr to be polymorphic over this
08:51:44 <mniip> very little point in that
08:53:18 <j0llyr0tten> ghc creates fairly big binaries for me on Linux, any idea why?
08:53:37 <mniip> j0llyr0tten, are you compiling with debug data?
08:53:52 <albeit> When using `deepseq`, if I deepseq something twice, does Haskell "know" its already been fully evaluated, or does it go into the structure making sure everything is evaluated?
08:53:58 <j0llyr0tten> mniip: perhaps
08:54:22 <mniip> albeit, it traverses the structure again
08:54:32 <j0llyr0tten> i mean, it's basically "Hello World!" :) but the execuatable is 1MB ?
08:54:33 <dolio> Do you have split-objs: True in your cabal config, or equivalent?
08:54:35 <albeit> mniip: Thanks
08:54:45 <mniip> j0llyr0tten, try 'strip a.out'
08:54:56 <j0llyr0tten> mniip: ok, will do
08:54:58 <mniip> oh wait ghc doesn't name executables that
08:55:28 <j0llyr0tten> mniip: still about 750K
08:55:28 <dolio> Hello world is not a very good benchmark for this anyway.
08:55:41 <srhb> There's also the whole static linking stuff.
08:55:48 <srhb> Which may or may not be what you're used to from other languages.
08:55:59 <dolio> Because there's a fixed cost from runtime systems and whatnot.
08:55:59 <j0llyr0tten> ah, is it statically linking?
08:56:11 <j0llyr0tten> why is it not dynamically linking?
08:57:13 <srhb> If I don't misremember (and I might, so someone please correct me) the default is to statically link to all haskell libraries, and dynamically to external ones?
08:57:52 <cite-reader> Right, most foreign libraries are dynamically linked. (Hit your binaries with ldd to see which ones!)
08:59:18 <j0llyr0tten> srhb: ok
08:59:31 <srhb> j0llyr0tten: And if we go further down, the RTS also has to be included.
08:59:44 <srhb> But of course this is similar to any other language that has an RTS
08:59:51 <j0llyr0tten> srhb: RTS?
08:59:55 <srhb> runtime system
09:00:32 <srhb> I can make a non-trivial test program go down to about 20K with dynamic linking and stripping, but I would almost never do this in reality.
09:00:37 <srhb> Dynamically link, that is.
09:01:09 <tjscanlon> How dumb of an idea would it be to write small games for personal projects in Haskell?
09:01:18 <srhb> tjscanlon: Not at all
09:01:27 <srhb> tjscanlon: One of my first toy projects was a snake clone
09:01:27 <j0llyr0tten> srhb: how? i'm passing -dynamic and it's complaining
09:01:38 <srhb> j0llyr0tten: I need more information than "it's complaining"
09:02:21 <srhb> tjscanlon: Of course, depending how far you're in, I'd advice getting comfortable with the type system first with eg. the cis194 course
09:02:54 <j0llyr0tten> srhb: Could not find module `Prelude' Perhaps you haven't installed the "dyn" libraries for package `base'? 
09:03:08 <j0llyr0tten> is what it says :)
09:03:08 <srhb> j0llyr0tten: Well that's the answer then. base needs their dynlibs for this to be possible
09:04:06 <srhb> And any other package you depend on.
09:04:13 <c_wraith> if you have base without dynlibs, you probably installed ghc from a package manager, rather than from a real source
09:04:29 <c_wraith> I don't know why package managers insist on creating broken installs
09:04:52 <j0llyr0tten> c_wraith: i'm trying to remember how i installed it in the first place :(
09:07:26 <j0llyr0tten> c_wraith: ok, i'm on Ubuntu and ghc-dyn is a separate package to ghc
09:07:55 <geekosaur> usually because they consider things like dev and profiling libraries to be space wastes "for most users" and stow them in optional install packages
09:07:56 <dolio> What version of GHC is it, by the way?
09:08:42 <geekosaur> which, considering how the ones most likely to do that are the ones most likely to have GNOME bloat in their base systems, rendering the whole idea of splitting stuff out of other packages "to avoid bloat:" nonsensical...
09:08:47 <bitemyapp> j0llyr0tten: whenever I get that error, I just repeat what I did and it works the second time.
09:09:07 <j0llyr0tten> bitemyapp: i like your style
09:09:17 <geekosaur> "let's save 5MB to make room for a gig of gnome crap"
09:09:40 <c_wraith> geekosaur: that's one thing for libraries that are only binary dependencies of binaries.  It's quite another for things that are explicitly dev tools, like compilers.
09:09:56 <j0llyr0tten> geekosaur: i won't have a bad word said about Gnoimish stuff
09:10:06 <geekosaur> yes, but they've always split out profiling stuff, even for C libraries
09:10:11 <j0llyr0tten> okay, 20K with -dynamic
09:10:44 <ion> How do i add a dependency to a package on Hackage but not on Stackage into stack.yaml? I fail at finding the answer from the documentation.
09:10:56 <bitemyapp> j0llyr0tten: I have work to do :P
09:10:57 <c_wraith> ion: as I understand it, that's not supported yet
09:11:10 <ion> c_wraith: Ok, thanks
09:11:34 <j0llyr0tten> so, i guess my next question is, what's the best way to learn haskell is coming from a C and Ruby background...
09:12:16 <Welkin> j0llyr0tten: just get started
09:12:22 <Welkin> forget what you think yo know about programming
09:12:26 <maerwald> j0llyr0tten: don't try to associate haskell ideas with anything you already know from C/ruby...
09:12:44 <maerwald> j0llyr0tten: it's not a slightly different language... it is completely different. so free your mind
09:13:01 <srhb> Some people will claim it's actually easier to learn without the C/Ruby background :-)
09:13:06 <ion> j0llyr0tten: https://github.com/bitemyapp/learnhaskell/blob/master/README.md#how-should-i-learn-haskell
09:13:07 <j0llyr0tten> i've heard horror stories, tales of broken C programmers sobbing in corners
09:13:09 <srhb> but it depends how good you are at forgetting it while learning Haskell
09:13:11 <mada> j0llyr0tten: https://github.com/bitemyapp/learnhaskell could be useful
09:13:12 <srhb> j0llyr0tten: All true!
09:13:15 <maerwald> j0llyr0tten: wat xD
09:13:16 <srhb> j0llyr0tten: :-)
09:13:20 <lifter>  how can I determine what constraints to put on "base" in the "build-depends" of my cabal file?
09:13:38 <srhb> lifter: I usually test with a few of the older GHC versions
09:13:48 <bitemyapp> j0llyr0tten: what Welkin said. This is my guide: https://github.com/bitemyapp/learnhaskell
09:13:52 <maerwald> j0llyr0tten: well, we don't even have a classic for loop with indices... so 
09:14:01 <ion> lifter: The ones you bother to test with.
09:14:32 <dolio> You don't really use for loops in ruby, either.
09:14:33 <maerwald> j0llyr0tten: you could write one though... but you'll find that you don't need a lot of basic concepts you need in other languages
09:14:34 <lifter> is it really just a matter of testing to see what base my project works with?
09:14:48 <dolio> In some ways, ruby has a lot of FP ideas.
09:14:52 <dolio> By way of smalltalk.
09:15:01 <j0llyr0tten> i've been rading this: http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
09:15:21 <j0llyr0tten> reading*
09:15:46 <dolio> The names are just all different.
09:16:09 <ion> j0llyr0tten: I’m not sure that paper will help a beginner very much.
09:16:30 <cabalian> Hi, I'm using GHC 7.10 and having problems with ghc-mod. I figured that I could downgrade to cabal-1.20 to cope with some ghc-mod problems while keeping ghc 7.10. Is this possible? Trying to compile cabal-1.20 with GHC 7.10 gives me the error: "ghc: ghc no longer supports single-file style package databases (dist/dist-sandbox-81bd2d17/package.conf.inplace) use 'ghc-pkg init' to create the database with the correct format."
09:16:31 <j0llyr0tten> ion: it's the first explanation of monads that has made sense to me...
09:16:34 <j0llyr0tten> so...
09:16:56 <j0llyr0tten> thanks for all the suggestions everybody!
09:16:59 <ion> j0llyr0tten: It describes *a* monad, not monads.
09:17:00 <muzzle> hi, why does this compile ? http://lpaste.net/134406
09:17:14 <maerwald> j0llyr0tten: IO is not the first thing you should start with when learning haskell, unless you already know some stuff about it
09:17:25 <j0llyr0tten> ion: oh, dang.
09:17:26 <muzzle> shouldn't the instances be overlapping ?
09:17:47 <j0llyr0tten> maerwald: i don't know, it's hard to code w/ input and output :(
09:17:52 <ion> (j0llyr0tten: But learning a number of specific monads is the way to grasp the concept.)
09:18:15 <dolio> muzzle: New GHCs have very delayed overlap checks.
09:18:19 <maerwald> j0llyr0tten: most of the time in uni haskell courses IO and monads are somewhere in the last few lectures
09:18:26 <maerwald> for good reason
09:18:43 <muzzle> dolio: i get a runtime error...
09:18:53 <lifter> cabalian, I dunno; I sure would like to use 7.10 but issues like the one you mention are making me stay away
09:19:02 <muzzle> dolio: isn't there a possibility of detecting it at compile time
09:19:04 * hackagebot linear-grammar 0.0.1.3 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.1.3 (athanclark)
09:19:21 <ion> j0llyr0tten: The paper does give a definition of what Monad is while describing the IO monad, but that’s not enough for you to grok monads in general.
09:19:48 <cabalian> lifter: I could download/install in a separate folder GHC 7.8, and with it compile cabal 1.20. But would I be able to use it then via GHC 7.10? I wonder
09:20:29 <lifter> cabalian, yeah, I wish I knew these things
09:20:34 <cabalian> Other tan ghc-mod problems, my migration has been relatively painless.
09:20:59 <cabalian> Well, since noone knows, I'll go ahead and try it myself. I'll report back
09:21:28 <cabalian> Maybe it'll help some other poor IDE-needing soul :)
09:22:50 <muzzle> wtf, so much for compile time checking :P
09:23:35 <dolio> muzzle: Runtime error is weird. It should still be a compile error if anything.
09:28:30 <int-index> I have a polykinded type class: `class C (m :: k) where`. I want to associate a type family with it that would turn `m` of kind `k` into something of kind `*`. So I define `type family K (x :: k) :: *`, but I couldn't figure out how to write actual instances for it, because when `k :: * -> *`, I need to apply it to some type variable that I have no way to acquire. At this point I'm lost, any advice?
09:29:03 <dolio> muzzle: What are you running that gives an error?
09:41:23 <ion> I suppose HaskellNet is the only Haskell IMAP library available? Its API has no concept of the state (logged in, mailbox selected etc) and it doesn’t seem to support pipelining.
09:49:05 * hackagebot fficxx 0.2.1 - automatic C++ binding generation  http://hackage.haskell.org/package/fficxx-0.2.1 (IanWooKim)
09:49:07 * hackagebot fficxx-runtime 0.2.1 - Runtime for fficxx-generated library  http://hackage.haskell.org/package/fficxx-runtime-0.2.1 (IanWooKim)
09:49:54 <ttt_fff> parsec can parse anything righ? does anye have a parsec for parsing apl tutorial 
09:50:23 <mniip> am I supposed to say showString "[" . showString x . showString "]"
09:50:31 <mniip> or showString ("[" ++  x ++ "]")
09:52:54 <ajf> Why are (!) and (!!) separate? Is it because (!!) is not O(1)?
09:54:34 <argent0> afj: (!!) :: [a] -> Int -> a
09:54:49 <argent0> afj: (!) :: (Ix i, IArray a e) => a i e -> i -> e
09:54:58 <mniip> ! means many things actually
09:55:00 <argent0> they work on different types
09:55:01 <nshepperd> I think it's more that there isn't any one !
09:55:04 <mniip> :t (M.!)
09:55:05 <lambdabot> Ord k => M.Map k a -> k -> a
09:55:34 <voidzero> :t showString
09:55:35 <lambdabot> String -> ShowS
09:55:59 <voidzero> hmm. you learn something new... or in my case 250 things.. in #haskell every day
09:59:33 <mniip> > let sp d = showParen (d > 5) showString "hello" . showsPrec 10 (Just ()) . showString "world" in sp 10 ""
09:59:35 <lambdabot>      Couldn't match type ‘[Char]’ with ‘String -> c1’
09:59:35 <lambdabot>      Expected type: String -> c1
09:59:35 <lambdabot>        Actual type: String
09:59:44 <mniip> > let sp d = showParen (d > 5) $ showString "hello" . showsPrec 10 (Just ()) . showString "world" in sp 10 ""
09:59:46 <lambdabot>  "(helloJust ()world)"
09:59:53 <mniip> aka the proper way to write Show instances
10:00:27 <Haskellfant> I thought the proper way is to derive them
10:00:32 <Haskellfant> I'm lazy 
10:01:23 <mniip> the question still stands
10:01:30 <mniip> [19:49:41] <mniip> am I supposed to say showString "[" . showString x . showString "]" or showString ("[" ++  x ++ "]")
10:02:13 <joneshf-laptop> does `Functor f => f (a -> b) -> a -> f b` have an agreed upon name?
10:03:09 <ChristianS> mniip: hmm, a String is already a String, we do you need show... at all?
10:03:31 <mniip> ChristianS, to get a ShowS
10:03:46 <mniip> showString /= shows
10:04:03 <mniip> showString adds a string to ShowS chain, without quotes like shows does
10:04:44 <mniip> of course showString is just flip (++) or something like that but nevertheless
10:05:52 <ChristianS> mniip: well in that case i'd guess it doesn't matter
10:06:27 <mniip> showString is there for performance purposes, I'm wondering whether ++ing strings like that defeats the purpose
10:06:29 <supki> :t Data.Distributive.distribute :: Functor f => f (a -> b) -> a -> f b
10:06:30 <lambdabot> Functor f => f (a -> b) -> a -> f b
10:06:48 <nshepperd> is there a chance (x ++ "]") will walk over x twice?
10:07:25 <maerwald> nshepperd: then worst case would be worse than O(n) no?
10:07:32 <maerwald> nshepperd: and afaik O(n) is sort of guaranteed?
10:08:04 <hodapp> I'm officially using a bug tracking system of: grep "FIXME" *.hs c/*.c c/*.h
10:08:08 <hodapp> not sure if this is good or bad.
10:08:19 <opqdonut> whatever works
10:08:30 <maerwald> hodapp: multi-line?
10:08:48 <opqdonut> combining issue tracking with version control is nice
10:09:05 <mniip> hodapp, alias report-bug = echo "$@" >> $(shift)
10:09:45 <hodapp> maerwald: I just converted over a bunch of disorganized TODOs to a standard-ish format that gives severity, priority, a short description (on that line), and a longer description after.
10:10:39 <hodapp> they're stuck in context when they can be, and I do like that this approach follows around the versioning
10:10:39 <maerwald> hodapp: I want to get the description without opening the file though :P
10:10:50 <hodapp> maerwald: just grepping will get you the short description
10:11:02 <maerwald> hodapp: I want the long description
10:11:09 <nshepperd> hmm, yeah, I think you do want to avoid (x ++ "]")
10:11:11 <hodapp> THEN OPEN THE FILE >:O
10:11:17 <maerwald> hodapp: I don't want :/
10:11:22 <hodapp> too bad!
10:11:29 <hodapp> tell grep to give you more context after
10:11:38 <maerwald> hodapp: but how much? ;)
10:11:39 <nshepperd> the point of difflists being to avoid a lot of left-associated concatenation
10:11:52 <maerwald> hodapp: I'm just saying I find it to be relatively user friendly
10:12:04 <nshepperd> but, I haven't studied this much
10:12:05 <maerwald> especially if you want an overview of bugs with long description
10:12:07 <maerwald> etc
10:12:25 <maerwald> the idea is not bad though
10:13:04 <tejing> nshepperd: particularly nested left associative concatenation, as each nesting means walking the list another time
10:13:07 <hodapp> maerwald: I did see a system that I liked which stored the bug database in version control and kept it distributed, and as a result kept bug reports and version control alongside each other
10:13:32 <maerwald> hodapp: this makes me want to write a darcs plugin that integrates issue tracking :D
10:14:34 <maerwald> I mean... we have the whole vcs terminal-compatible, except issue tracking
10:14:42 <maerwald> for that you still need a browser
10:14:44 <cite-reader> I've been toying with Bugs Everywhere for that kind of thing.
10:16:02 <hodapp> maerwald: Fossil already does this
10:16:28 <maerwald> hodapp: googling for that gives me weird results :o
10:16:36 <maerwald> watches, handbags and jewelry
10:16:43 <hodapp> fossil-scm.org
10:16:47 <hodapp> cite-reader: interesting...
10:18:18 <maerwald> hodapp: is fossil any good?
10:18:33 <hodapp> maerwald: I don't know. I've only read about it.
10:18:36 <int-index> Is there a way to define a default type family instance without associating it with a type class?
10:18:41 <argent0> hodapp: BEGIN { printing = (1==2); } /FIXME/ { printing = (1==1);} { if printing { print; } } /ENDDESCRIPTION/ {printing = (1==2); }
10:18:56 <argent0> hodapp: BEGIN { printing = (1==2); } /FIXME/ { printing = (1==1);} { if printing { print; } } /ENDDESCRIPTION/ {printing = (1==2); }
10:19:14 <hodapp> help I think a bot is attacking me >_>
10:19:16 * hodapp runs
10:19:19 <argent0> hodapp: BEGIN { printing = (1==2); } /FIXME/ { printing = (1==1);} { if printing { print; } } /ENDDESCRIPTION/ {printing = (1==2); }
10:19:20 --- mode: ChanServ set +o dolio
10:19:25 --- kick: argent0 was kicked by dolio (argent0)
10:19:27 <voidzero> yay for awk
10:19:31 <voidzero> boo for repeating
10:19:39 <hodapp> >_<
10:19:45 <hodapp> what just happened
10:19:52 <maerwald> hodapp: someone awked you
10:19:52 * Clint squints.
10:20:06 <hodapp> maerwald: that was awk-ward.
10:20:09 <maerwald> xD
10:20:43 <voidzero> that was weird
10:22:42 --- mode: dolio set -o dolio
10:30:28 <maerwald> hodapp: http://www.ariis.it/static/articles/decentralised-lentil/page.html
10:34:07 <johnw> edwardk: gj
10:34:08 * hackagebot linear-grammar 0.0.1.4 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.1.4 (athanclark)
10:37:36 <hodapp> maerwald: neat, thanks!
10:41:54 <hodapp> maerwald: that's quite new, also
10:42:04 <hodapp> first release, 3 days ago?
10:42:14 <Zemyla> Hmm, I kind of wish Compose inherited Alternative, but the problem is there's two different ways to do that.
10:42:55 <Zemyla> Actualy, it does. But again, there's two different ways to do it, and Compose only allows one.
10:43:46 <maerwald> hodapp: I just got linked to that in #darcs, didn't know about it either
10:44:01 <Zemyla> instance (Alternative f, Applicative g) => Alternative (Compose f g) where empty = Compose empty; Compose x <|> Compose y = Compose (x <|> y)
10:44:08 * hackagebot linear-grammar 0.0.1.5 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.1.5 (athanclark)
10:44:10 * hackagebot namelist 0.1.0 - fortran90 namelist parser/pretty printer  http://hackage.haskell.org/package/namelist-0.1.0 (HirotomoMoriwaki)
10:44:26 <Eduard_Munteanu> I wonder if any of the AES packages on Hackage support AES-NI... hm.
10:44:48 <Zemyla> instance (Applicative f, Alternative g) => Alternative (Compose f g) where empty = Compose $ pure empty; Compose x <|> Compose y = Compose $ liftA2 (<|>) x y
10:45:44 <Eduard_Munteanu> Probably the OpenSSL bindings do.
10:48:25 <johnw>  @tell edwardk Did you also end up with first (H _) = run (H $ join invoke)?
10:50:41 <dolio> johnw: That looks weird.
10:50:47 <johnw> it feels weird too
10:51:13 <dolio> Anything that's "first _ = ..." seems wrong.
10:51:19 <johnw> even if it's wrong, I wonder what it means being that it typechecks
10:52:12 <dolio> Hyperfunctions are too easy.
10:52:16 <johnw> hahah
10:53:04 <dolio> Does 'run (H $ join invoke) : H a b'?
10:53:17 <johnw> H (a, d) (b, d)
10:53:47 <johnw> i'm wondering it's because the d is on both sides of ->
10:53:52 <dolio> I mean is it more general than that, even?
10:54:00 <johnw> oh, i see what you mean, let me check
10:54:20 <johnw> heh
10:54:32 <johnw> you're right
10:54:37 <dolio> Okay.
10:54:45 <johnw> ok, back to the drawing board, thanks!
10:54:47 <dolio> That's probably just some pathological thing.
11:08:57 <frerich> Hm, given a list type 'data List a = Empty | Cons a (List a)', a fold would be of type 'fold :: b -> (a -> b) -> List a -> b'. Given a slightly different list type 'data List a = Empty | Cons a (List (List a))' -- would the fold function have the same type? Or would it be 'fold :: b -> (a -> List b) -> List a -> b'?
11:09:27 <voidzero> :k List
11:09:28 <lambdabot>     Not in scope: type constructor or class ‘List’
11:09:28 <lambdabot>     Perhaps you meant ‘Last’ (imported from Data.Monoid)
11:09:42 <voidzero> thought it was built 
11:09:44 <voidzero> in
11:11:22 <frerich> voidzero: That would be '* -> *'. :-)
11:12:09 <voidzero> so List (List a) is what '* -> * -> *' right?
11:14:09 * hackagebot shell-monad 0.6.4 - shell monad  http://hackage.haskell.org/package/shell-monad-0.6.4 (JoeyHess)
11:14:18 <frerich> voidzero: I would have said that 'List (List a)' is of kind '* -> *' as well, but I'm actually not sure. My thinking being, it takes one type to produce a '*'.
11:14:25 <predator117> @kind []
11:14:26 <lambdabot> * -> *
11:14:53 <predator117> @kind StateT
11:14:54 <lambdabot> * -> (* -> *) -> * -> *
11:15:23 <predator117> voidzero: that's how you can ask lambdabot for kinds
11:17:06 <voidzero> ha, good, thank you
11:17:52 <voidzero> frerich, a functor is '* -> *'
11:18:00 <voidzero> it needs to funct something :P
11:19:32 <voidzero> erm.. sorry, you said something different
11:19:43 <voidzero> blaah i'm being distracted
11:24:34 <koshmar> how do I list all comands of lambdabot?
11:27:03 <predator117> @help
11:27:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:27:10 <predator117> @listmodules
11:27:10 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
11:29:22 <dwins> koshmar, predator117: lambdabot responds to commands in private message so you can try things out without generating extra noise in the chat
11:30:12 <predator117> just wanted to answer thye question, no fooling around :)
11:30:37 <int-index> How do I use generic programming to wrap something in a newtype or unwrap it? I have a type class method that just does newtype wrapping, can I define a default for it?
11:30:55 <int-index> a default implementation
11:31:14 <opqdonut> GeneralizedNewtypeDeriving?
11:31:26 <int-index> No, that's not what I'm talking about.
11:32:03 <int-index> I have a class `C m` with method `f`. `m` most of the times is a newtype, so can I define a default implementation for `f` that unwraps `m` into its inner type?
11:32:19 <koshmar> I got how to list all modules, but how to list bot commands like "@src"
11:32:26 <maerwald> int-index: type classes can have default implementations, what's the problem?
11:32:52 <dwins> koshmar: @list takes a module name and gives all the commands in it
11:33:09 <int-index> maerwald: the problem is that I don't know how to unwrap a newtype. Currently I do it manually in every instance because I know the constructors.
11:33:31 <koshmar> dwins: thanks.
11:33:51 <maerwald> int-index: this alsmost sounds like you want a functor instance or somesuch
11:34:57 <int-index> I know what I want. I want to use GHC.Generics to unwrap a newtype in a default implementation of a method of a typeclass.
11:35:12 <eds> can somebody help me out with pattern matching
11:35:17 <eds> http://lpaste.net/132328
11:38:04 <mniip> hmm
11:38:28 <mniip> I have two references to the same infinite list in different places
11:38:37 <mniip> if only there was a way to compare references
11:38:49 <eds> in myFitness function
11:39:57 <Iceland_jack> mniip: If that's really what you want the EDSL community has some solutions
11:40:10 <mniip> nah
11:40:12 <mniip> I'm good
11:43:20 <ion> mniip: System.Mem.StableName
11:44:02 <ion> Search word: observable sharing
11:44:04 <mniip> nah, really, I don't need low level hacks
11:44:59 <Iceland_jack> mniip: If you want high-level non-hacks https://www.cs.utexas.edu/~wcook/Drafts/2012/graphs.pdf
11:46:26 <sebboh> Hi, I've got a question.  I've got a fresh debian machine and I just did apt-get install haskell-platform.  Now, I'm blindly following the build and install receipe for an application (git-annex).  cabal keeps hanging on "Waiting for install task to finish..." (I see this because I added --verbose=3 to my command line.)  So, I hit ctrl+c then invoke the command again.  It picks up where it left off.  Right?  Or are some "packages" (is
11:46:26 <sebboh> that the correct name?) failing to install?  Is there some verification step I can perform after the fact?
11:50:28 <Sindriava> Does anyone have experience with hOpenGL? :)
11:56:27 <ocharles_> Sindriava: are you looking to do OpenGL programming in Haskell?
11:56:52 <koshmar> how to load my modules in ghci? "import name" us not working (name.hs) is in derectory where ghci is launched, if I put "import name" in temp.hs and then type :l temp it works. but can I do it without temp file?
11:57:38 <dwins> koshmar: :m +name should do it
11:59:07 <ajf> argent0: oh, weird. Why couldn't it be a typeclass of some kind?
11:59:54 <koshmar> <dwins>: it does not work
12:00:19 <koshmar> it works with standart ones, but not with mine(
12:01:15 <Sindriava> ocharles_: Yup! I already wrote something :)
12:01:34 <tommd> koshmar: If you are specifying a file name then use ':load'.  If you are using a module name then ':m' or 'import'.
12:01:40 <ocharles_> Sindriava: cool. If you already have prior OpenGL knowledge, I would point you to the `gl` package rather than `hopengl`
12:01:47 <Sindriava> ocharles_: But now I'm struggling with getting out of the immediate mode, e.g. how to preload vertices into the GPU and only draw them
12:01:53 <Sindriava> ocharles_: I have some, but not much
12:02:16 <ocharles_> the nice thing with the `gl` package is there's barely any abstraction at all
12:02:23 <ocharles_> which means you can just use normal C tutorials to learn OpenGL
12:02:33 <ocharles_> and ask for help in ##opengl, etc
12:05:11 <int-index> If anyone is interested I've found exactly what I needed in the newtype-generics package.
12:06:59 <academy> I'm new to Haskell and trying to delete the nth element from a list.  I've come up with this, but it seems ugly.  How should this be done?  Thanks. http://lpaste.net/5539614355563216896
12:07:58 <lemmih> academy: Try doing it one step at a time.
12:08:15 <academy> lemmih: I don't follow
12:08:33 <marchelzo_> academy: So the 1st todo-list item is the last thing in the list?
12:08:36 <lemmih> academy: First, think about what it means to drop the 0th element from a list.
12:09:05 <academy> marchelzo_: yes.  That meant I could use the : operator, but on reflection it seems confusing
12:09:06 <lemmih> academy: Then, think about if you can use the previous definition to drop the nth element of a list.
12:09:46 <Sindriava> ocharles_: Yeah, that's exactly the thing I wanted to dodge. I like the abstraction hOpenGL provides, for example with preserveMatrix and so on
12:09:51 <academy> lemmih: so dropping the 0th element would be 'init todolist'
12:09:55 <marchelzo_> academy: you can use take and drop to write that pretty succinctly
12:10:04 <Sindriava> ocharles_: I'm more interested in the content, than the way it's rendered
12:11:10 <lemmih> academy: Right, but try doing it all explicitly. That is, without using 'init'.
12:13:11 <arkeet> init drops the last element, though.
12:14:21 <arkeet> or is this list reversed or something?
12:15:32 <lemmih> academy: If you start with 'dropNth 0 (x:xs) = xs', can you write the case for 'dropNth n (x:xs) = _' ?
12:16:45 <small-wolf> is there a way to get a list of installed modules in a cabal sandbox?
12:17:59 <geekosaur> cabal sandbox hc-pkg list
12:18:00 <arkeet> installed packages?
12:18:03 <arkeet> yeah that
12:18:04 <geekosaur> cabal sandbox hc-pkg --list
12:18:11 <marchelzo_> arkeet: http://lpaste.net/5539614355563216896
12:18:12 <geekosaur> hm, no, first one was right
12:18:21 <arkeet> I forget about hc-pkg so I'd just cabal exec ghc-pkg ilst
12:18:22 <arkeet> list
12:18:57 <RyanGlScott> cabal list --installed # More verbose version
12:19:08 <small-wolf> cool. can I get a list of idk what you call it, module names? like Data.Whatever.Foo
12:19:46 <small-wolf> I managed to install libssh2, but I have no idea what the module is called.
12:20:03 <RyanGlScott> A very indirect way of doing that would be running "cabal repl" in a sandbox, typing "import ", then hitting the Tab key.
12:20:16 <merijn> Or just "cabal exec ghc-pkg list"
12:20:32 <arkeet> so you want the list of modules exported by a specific package.
12:21:05 <RyanGlScott> cabal info libssh2 # Lists modules at the bottom
12:21:10 <arkeet> ghc-pkg describe should do that?
12:22:01 <academy> marchelzo_, lemmih, is this an improvement? http://lpaste.net/5539614355563216896
12:22:09 <small-wolf> that isn't my ultimate goal. I'm curious as to why ghc can't "find" packages installed in my cabal sandbox, and am making sure they are actually there
12:22:40 <small-wolf> I installed ghc and cabal through different package managers or something. I forget why I did that.
12:23:14 <marchelzo_> academy: Yeah, that's a definite improvement over your original implementation.
12:23:28 <academy> marchelzo_: could I improve it further?
12:24:23 <marchelzo_> I think so.
12:25:32 <academy> marchelzo_: could you give me a hint as to which part please?
12:26:02 <marchelzo_> Could you link the original again, please?
12:26:06 <small-wolf> erm is there a way to pass a cabal sandbox config or the sandbox itself to ghc as a command line argument
12:26:12 <marchelzo_> nevermind, I still had it open
12:28:06 <marchelzo_> academy: You can write it without (++) or splitAt or drop or take
12:28:30 <marchelzo_> If you want to improve performance. IMO, the implementation with drop and take is very readable.
12:29:28 <ReinH> marchelzo_: Why wouldn't the implementation with drop and take be performant?
12:29:36 <valdyn> is there a good reason why the nth element is mapped to the (length-n)th element ?
12:30:17 <academy> valdyn: That allowed me to use the : operator to 'append' todo list items.  On reflection I might change it.
12:30:18 <ReinH> drop and take aren't the problem
12:30:47 <academy> ReinH: is the problem length iterating over the entire list?
12:31:00 <marchelzo_> ReinH: If the list has 500 elements and you want to delete the "100th" element, drop and take both require 400 iterations.
12:31:05 <tejing> academy: lists are likely the wrong data structure here... you may want to try Sequences, as they have log(n) random access by index and O(1) access at either end
12:31:14 <ReinH> the problem is structuring it in such a way that the length of the list must be checked (and then checking it more times than is necessary)
12:31:29 <int-index> I have a template haskell code that generates composed fmaps for me. So $(fmapN 5) results in (fmap.fmap.fmap.fmap.fmap). Is there a way to achieve something similar without TH?
12:31:30 <valdyn> academy: very well, you can factor that out then
12:31:44 <ReinH> yes, but you're still checking the length more than zero times
12:32:38 <ReinH> Yeah, a list is the wrong structure if you want fast access to both ends
12:33:27 <academy> ReinH: improvement? http://lpaste.net/87482672728768512
12:33:33 <ReinH> marchelzo_: "drop and take both require 400 iterations" what does that mean?
12:33:43 <academy> typo, but you get the idea
12:34:01 <academy> refresh to see the fix
12:34:02 <marchelzo_> ReinH: 400 recursive calls
12:34:05 <merijn> academy: Ah, you can do splitting much more efficient than separate drop and take
12:34:13 * hackagebot lentil 0.1.1.2 - frugal issue tracker  http://hackage.haskell.org/package/lentil-0.1.1.2 (fffaaa)
12:34:22 <academy> merijn: how so?
12:34:30 <academy> tejing: I will read
12:34:39 <merijn> academy: splitAt
12:34:46 <merijn> academy: That does both the drop and take in one go
12:35:08 <merijn> Although length is gonna be pretty slow anyway
12:35:08 <academy> merijn: that doesn't drop an element though right?
12:35:31 <merijn> academy: No, but that's easy enough to do
12:35:37 <ReinH> maraoz: I'm not sure why it would require 400 "recursive calls", but you're right about drop and take being a poor choice for "delete the nth element of a list"
12:35:49 <ReinH> er, marchelzo_^
12:36:17 <merijn> Actually, I guess splitAt is still inefficient as you rebuild the prefix list twice
12:36:35 <merijn> The fast way would be to do take + drop in the same function while building a DList for the prefix
12:36:52 <academy> To help me out, would someone mind posting a 'good' version for me please?
12:37:03 <merijn> Lemme sketch it out
12:37:04 <valdyn> academy: good versions for this come later in that book
12:37:15 <academy> valdyn: what book?
12:37:25 <marchelzo_> ReinH: Are they not implemented in such a way that they crawl the linked list one item at a time constructing the result as they go?
12:37:31 <valdyn> academy: this todo list appears in learn yourself a haskell for great good
12:37:58 <academy> valdyn: I'm writing a todolist to replace Wunderlist after Microsoft bought it.  I don't have that book
12:38:08 <valdyn> academy: a version that scales needs a different data structure
12:38:10 <academy> (and also to learn Haskell)
12:38:14 <marchelzo_> take _ [] = []; take 0 _ = []; take k (x:xs) = x : take (k - 1) xs
12:38:24 <marchelzo_> Or something like that
12:38:37 <valdyn> academy: but it would not look that much different
12:38:50 <marchelzo_> So if you want to take 400 elements from a 500 element list, it takes 400 calls to take
12:39:01 <marchelzo_> That's all I was getting at
12:39:12 <ReinH> there's literally no way to avoid that though
12:39:29 <ReinH> you can't get to the 400th list without scrutinizing 400 (:) constructors
12:39:32 <mniip> hmm
12:39:35 <tejing> ReinH: except by switching to Sequences :-)
12:39:38 <ReinH> *400th element
12:39:42 <tejing> or something similar
12:39:47 <marchelzo_> I realize that. But you don't need to do it twice.
12:40:01 <mniip> small step semantics don't seem to help with the divergence of the Y combinator
12:42:03 <merijn> academy: https://gist.github.com/merijn/3f9ce423edadf1622823
12:42:21 <tempname11_> a bit off-topic, but can someone recommend a good book on category theory?
12:42:27 <ph88> hello
12:42:28 <Sindriava> Are there any high-level graphics libraries, similar to processing?
12:42:35 <merijn> tempname11_: Have you read Bartosz blog intro yet?
12:42:42 <merijn> tempname11_: bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
12:42:53 <merijn> tempname11_: Next step would be "Category Theory" by Steve Awodey
12:43:12 <merijn> tempname11_: He has lectures here: https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
12:43:28 <tempname11_> merijn: thank you! :)
12:43:38 <tempname11_> do either of those have exercises?
12:43:40 <ReinH> I'd recommend Conceptual Mathematics before Awodey, depending on how much math you already have
12:44:04 <merijn> academy: Anyway, my version does dropping at a specific location in a single traversal, copying more than n items
12:44:17 <academy> merijn: thank you
12:44:21 <merijn> academy: Although it might require significant meditation to understand ;)
12:44:35 <ReinH> tempname11_: I have a list here as well http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html#category-theory
12:45:23 <tempname11_> ReinH: thanks!
12:45:34 <merijn> academy: Feel free to ask if any part confuses you
12:46:31 <mniip> I wonder if I can sequence the recursive invocations with an algebra and apply the same turtle-and-hare method
12:46:58 <merijn> mniip: Doesn't make sense for dropping an element in the middle, but it does for, for example splitting a list in half
12:47:14 <tempname11_> Conceptual Mathematics sounds lovely
12:47:20 <merijn> i.e. https://gist.github.com/merijn/c163cc106fd245d1cf2e which uses a similar trick to be fast in building the prefix part
12:47:35 <mniip> meretrix, hmm?
12:47:38 <mniip> merijn, ?
12:48:02 <mniip> you mean turtle and hare method?
12:48:07 <merijn> yes
12:48:09 <academy> merijn: No, I understand it.  Do haskell programmers tend to prefer code like that or code that's simpler (as per my version)?
12:48:24 <mniip> merijn, I'm using it to find repetition in a function's iteration
12:48:25 <merijn> academy: I'd go with what's required
12:48:52 <merijn> academy: Although I wouldn't consider dropAt particularly complicated
12:49:11 <Rotaerk> academy, simpler is better, generally, but "simple" is a complicated word
12:49:15 <merijn> academy: The function trick for building the list is well known (usually they're called DList)
12:49:42 <Jello_Raptor> does anyone here use vim-pandoc ? i'm trying to get it to hilight lhs properly
12:49:45 <merijn> academy: And DLists are so well-known that I would consider most people familiar enough with it to immediately see what's going on
12:49:50 <merijn> academy: i.e. http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
12:50:02 <Sindriava> Are there any good Haskell OpenGL resources?
12:50:12 <merijn> Or, at least most non-beginners I'd expect to know DList
12:50:55 <ReinH> merijn: (it's also nice to think of dlist as lifting the monoid action on lists to an action on Endo.
12:50:58 <ReinH> )
12:51:09 <merijn> academy: Incidentally, you can generalise the DList trick to arbitrary recursive data structures and then you have what;s called "codensity transform"
12:51:38 <ReinH> since as such it's a monoid morphism
12:52:34 <ReinH> or rather, a monoid action is an element of Endo.
12:52:52 <merijn> academy: The nice part about purity is that the complexity is by definition restricted to dropAt and can't impact the rest of your code, so having an efficient implementation with a one line documentation should be sufficient for anyone to use it :)
12:54:11 <tejing> looking at the Data.Sequence docs I'm surprised to find there's no function to remove the ith element of a sequence. of course there's O(log(min(i,n-i))) split and concatenate ops, so you can write your own easily enough, but I would have expected it to be in the library
12:55:13 <hodapp> weird, why do I need UndecidableInstances to use the type functions from GHC.TypeLits (such as multiplication on Nat) when giving a type instance in a type class?
12:55:13 <lamefun> Safe Haskell seems perfect for Quake-like game sort of thing, with mods auto-downloaded over Internet. Has it been done already?
12:55:26 <hodapp> that is, I can give it a literal number and that compiles just fine
12:55:41 <hodapp> and (*) is of kind Nat -> Nat -> Nat
12:55:54 <hodapp> so, I'd expect something like 4 * 8 to work...
12:58:57 <hodapp> :k (*)
12:58:58 <lambdabot> Not in scope: type constructor or class ‘*’
13:02:12 <lpaste> hodapp pasted “No title” at http://lpaste.net/4612781346757017600
13:02:36 <hodapp> to give an example, is it normal that I should require UndecidableInstances for the last line of http://lpaste.net/4612781346757017600 to compile?
13:05:50 <hodapp> oh well, guess I must just enable it for now
13:35:07 <kostis> hello!
13:40:11 <johnw> hi kostis 
13:43:21 <tgeeky> http://xkcd.com/1537/#
13:44:38 <ion> hah
13:45:13 <MP2E> I'm so glad our type system is sane :P
13:45:17 <MP2E> or at least mostly sane
13:52:21 <mniip> merijn, I take it, reducing arbitrary untyped LC terms is undecidable?
13:52:59 <mniip> I mean, Y (K I) diverges, but under a right set of beta and eta equivalences it equals I
13:56:58 <RyanGlScott> Can someone explain why you can't promote datatypes with kinds other than * -> ... -> * -> *?
13:57:11 <RyanGlScott> :k 'WrapMonad
13:57:12 <lambdabot>     Data constructor ‘WrapMonad’ comes from an un-promotable type ‘WrappedMonad’
13:57:12 <lambdabot>     In a type in a GHCi command: WrapMonad
14:00:30 <merijn> mniip: Not all UTLC terms have a normal form, no
14:01:24 <small-wolf> does the -package-db command line argument do glob expansion?
14:01:25 <merijn> That;s not really related to undecidability, though
14:01:25 <mniip> merijn, no I mean
14:01:31 <mniip> even for those that do have a normal form
14:01:48 <mniip> there is not a describable algorithm for picking the right sequence of reductions
14:01:55 <merijn> mniip: There is, actually
14:01:58 <mniip> oh?
14:02:27 <merijn> mniip: Lazy evaluation (I forget the proper name, but it's basically "outermost redex first") is guaranteed to reach normal form IF it exists
14:03:02 <mniip> merijn, in 'f g' should f or g be reduced first
14:03:35 <ion> small-wolf: no
14:04:20 <merijn> mniip: "f g" is reduced first
14:04:30 <mniip> nonono
14:04:46 <ChristianS> i'd say it's impossible to evaluate f prior to g
14:04:48 <small-wolf> ion: hmm why not? makes it harder to manually add the package db for a cabal sandox
14:04:50 <mniip> oh actually
14:04:58 <mniip> ChristianS, not at all
14:05:05 <geekosaur> small-wolf, the package db is a directory
14:05:05 <merijn> f is some "\x -> t", yes? Because everything is a function
14:05:20 <geekosaur> the directory contains files which are the individual entries
14:05:22 <johnw> @tell edwardk Never mind, that's clearly not it.  Don't tell me, it's a puzzle now. :)
14:05:22 <lambdabot> Consider it noted.
14:05:25 <small-wolf> err yeah but it has an architecture and version prefix
14:05:38 <merijn> mniip: So the first reduction is [g → x]t
14:05:42 <geekosaur> yes, and? tab expansion is your friend
14:05:45 <RyanGlScott> Never mind, I found the answer in section 3.3 of http://dreixel.net/research/pdf/ghp.pdf
14:05:57 <merijn> (I hope I got the order of the arrow right...I always get it mixed up)
14:08:00 <merijn> mniip: For example, let's consider "const = \x.\y.x", "id = \x.x" and "Y = \lambda f.(\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x)) 
14:08:12 <merijn> eh, stupid copy paste from wikipedia
14:08:38 <merijn> Y = \f . (\x. f (x x)) (\x. f (x x))
14:08:54 <merijn> mniip: Clearly "const id Y" has a normal form
14:09:17 * hackagebot jespresso 1.0.1.1 - Extract all JavaScript from an HTML page and consolidate it in one script.  http://hackage.haskell.org/package/jespresso-1.0.1.1 (AndreyChudnov)
14:09:34 <merijn> Outermost redex first reduces first to "(\y.id) Y", which then reduces to "id", which reaches normal form 
14:09:45 <merijn> If you do call-by-value (i.e. arguments first) then it diverges
14:09:53 <mniip> merijn, when we have 'f g' what do we do
14:10:03 <merijn> mniip: If neither is a lambda?
14:10:16 <merijn> mniip: i.e. 'f' and 'g' are free variables?
14:10:25 <merijn> Then nothing, it's already normal form
14:10:29 <mniip> no, f and g are some subexpressions
14:10:41 <merijn> If "f = \x. t" for some term 't'
14:10:44 <mniip> does it make sense to ask whether f is a lambda before getting it to normal form?
14:11:15 <merijn> Then the first reduction step is [g → x]t (i.e., substitute 'x' with 'g' in 't')
14:11:33 <merijn> mniip: In UTLC there's only two options, either 'f' is a lambda, or it's a free variable
14:11:39 <merijn> There's no other values :)
14:11:53 <merijn> And if it's a lambda, you can apply it :p
14:12:23 <mniip> merijn, or f is an application
14:12:33 <merijn> mniip: Oh, right, yes, then you have to reduce 'f' first
14:12:41 <mniip> so we get f in normal form
14:12:49 <merijn> mniip: Not necessarily!
14:12:58 <mniip> do we also get g in normal form or do we substitute right away
14:13:18 <merijn> mniip: It's sufficient to get it 'f' to be a lambda with unevaluated terms inside
14:13:38 <merijn> Actually, if you do fully evaluate the terms inside the lambda produce by 'f' you can guarantee reaching normal form!
14:13:59 <merijn> mniip: Substitute right away, if you want to normalise
14:14:25 <merijn> mniip: But there should be a bunch of proves and discussions of evaluation strategies on wikipedia/the web going into more detail than I can at 23:00 :)
14:14:30 <merijn> s/proves/proofs
14:14:46 <merijn> I don't think the proofs is particularly complicated, iirc
14:14:49 <small-wolf> random question, has anyone actually tried using Disciple
14:15:22 <dfeuer> edwardk, is the Functor instance for machines written for pre-AMP compatibility, or does the Monad constraint let you do something more efficiently?
14:16:15 <mniip> ohh
14:18:55 <mniip> merijn, x -> nf |- x g -> nf g
14:19:42 <mniip> y -> nf |- (\y -> x) -> (\y -> nf)
14:19:53 <mniip> |- (\x -> y) g -> y[x -> y]
14:19:56 <mniip> did I forget anything?
14:20:32 <mniip> oops in second rule s/y/x/ without g
14:22:21 <merijn> mniip: Well, if 'x' may diverge is 'y' diverges and is part of 'x'
14:22:32 <merijn> In rule 2
14:23:33 <merijn> For example, suppose "(\f.\x. f x) Y id" clearly this diverges
14:24:01 <merijn> So you need a stronger induction hypothesis
14:25:18 <mniip> I don't follow
14:26:01 <merijn> mniip: If you end up evaluating the diverging term inside the body of your function that function body will still diverge
14:26:23 <mniip> reduce (Application f g) = case reduce f of Lambda l -> substitute l g; r -> Application r g
14:26:28 <mniip> is that how it's supposed to be done
14:26:49 <merijn> mniip: Right, but that may not be a normal form if there's applications inside l
14:27:11 <merijn> mniip: And if you pass in a diverging term as argument those might get evaluated while evaluating the body of 'l', so it can still diverge
14:27:54 <dedgrant> Hey what's the latest trend in effect management in Haskell? I'm thinking of using effin, but looking for other general opinions/experience feedback.
14:28:19 <mniip> merijn, if the body of l diverges
14:28:26 <mniip> how can Application (Lambda l) g
14:28:29 <mniip> not diverge
14:28:52 <merijn> mniip: It can't, that's my point
14:29:25 <mniip> then
14:29:25 <merijn> mniip: Your rules don't account for the fact that the normalisation of the body can depend on the arguments passed to a lambda
14:29:42 <mniip> hm?
14:30:21 <vikaton> isnt 'input <- getLine` supposed to get user input?
14:30:45 <merijn> mniip: ok, so what did you mean by "x -> nf |- (\y -> x) -> (\y -> nf)", maybe I misread what you were trying to say
14:30:58 <mniip> vikaton, it describes getting input from stdin, yes
14:31:22 <vikaton> mniip: I get parse error on input `<-'
14:31:23 <mniip> merijn, reduce (Lambda l) = Lambda (reduce l)
14:31:31 <mniip> vikaton, that belongs in a 'do' block
14:31:49 <vikaton> mniip: http://prntscr.com/7g9np7
14:32:07 <mniip> vikaton, yeah
14:32:11 <mniip> it's not in a 'do' block
14:32:24 <vikaton> o
14:32:24 <ReinH> vikaton: ran <- ... at the top level is not vlaid
14:32:27 <mniip> I mean line 3
14:32:35 <ReinH> *valid
14:32:41 <ReinH> the compiler error should have indicated that
14:32:42 <voidzero> <- is weird
14:32:57 <mniip> <- is really just >>=->
14:33:01 <vikaton> ReinH: it indicated it on input, not ran
14:33:11 <vikaton> <- makes sense
14:33:24 <voidzero> you can interpret what i said in multiple ways and all of them are valid
14:33:44 <vikaton> Ohhhh
14:33:48 <vikaton> I get it :/
14:34:10 <merijn> mniip: "smallStepReduce (App (Lambda var l) x) = smallStepReduce (substitute var x l); smallStepReduce (App f x) = smallStepReduce (App (smallStepReduce f) x)"
14:34:11 <vikaton> ReinH, mniip It was a mistake on naming my value 'input'
14:35:07 <merijn> mniip: i.e. reduce 'f' until it has a lambda as outer value (Weak Head Normal Form in haskell terms), then substitute the argument in the body of 'f' and reduce the result
14:35:54 <merijn> mniip: The crucial point is that we do not reduce 'l' or 'x' until that's somehow necessary for reduction of the outermost position
14:36:02 <mniip> oh
14:36:03 <mniip> I see
14:36:42 <ReinH> vikaton: what? No, this mistake is in ran
14:36:49 <merijn> mniip: There's a reason why left-most outermost reduction is "lazy", "const id Y" doesn't diverge for the same reason it doesn't diverge in haskell :)
14:37:03 <merijn> mniip: Y never gets reduced before it gets thrown out
14:37:23 <vikaton> ReinH: the mistake was me naming it "input", so I got confuse on the error
14:37:30 <vikaton> its not what caused the compile error though
14:37:54 <merijn> mniip: Although I can't quickly find a proof
14:38:00 <tejing> vikaton: you can't use IO stuff outside a do block, so line 3 just won't work at all, putStrln should be putStrLn, the if clause has no then, and the last line doesn't associate the way you meant (function application with space binds tighter than everything else)
14:38:27 <vikaton> tejing: thanks, I took all that out and I still cant compile
14:38:47 <vikaton> here is snippet, 
14:38:51 <vikaton> https://www.irccloud.com/pastebin/MArXM4Ij/
14:39:46 <edwardk> dfeuer: pre-AMP
14:40:29 <dfeuer> edwardk, for the sake of my learning process, do you know if the Applicative instance depends on Monad or not?
14:40:40 <dfeuer> (on Monad m, that is?)
14:40:40 <hpc> @src Monad
14:40:40 <lambdabot> class  Monad m  where
14:40:40 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
14:40:40 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
14:40:40 <lambdabot>     return :: a -> m a
14:40:40 <lambdabot>     fail   :: String -> m a
14:40:43 <tejing> vikaton: I'm not sure but your indentation might be the problem
14:40:46 <edwardk> probably does
14:40:58 <dfeuer> Thanks.
14:42:27 <vikaton> is Haskell indentation sensitive?
14:42:34 <tejing> vikaton: yes
14:42:34 <hpc> yes
14:42:40 <edwardk> @tell johnw https://github.com/ekmett/hyperfunctions/blob/master/RepresentableHyperfunctions.hs#L29 <- don't look
14:42:40 <lambdabot> Consider it noted.
14:42:42 <mniip> merijn, and I take it, existence of normal form is undecidable
14:42:42 <tejing> vikaton: also you're going to get a type error because input is a string but ran is a number
14:42:50 <hpc> it's "layout", and it's also significantly sensitive to tabs
14:42:57 <vikaton> I was using tabs
14:43:14 <mniip> vikaton, haskell is sensitive to indentation, but one could write whitespace-insensitive code as well
14:43:28 <mniip> for example machine-generated code
14:43:57 <merijn> mniip: Right
14:44:13 <mniip> vikaton, tabs are taboo in recent GHC versions, make sure you never depend on tab widths
14:44:15 <merijn> mniip: The existence of a normal form is equivalent to deciding whether a program terminates :)
14:44:34 <merijn> Well, to be precise, the existence of a normal form is undecidable *in the untyped lambda calculus*
14:44:35 <mniip> and untyped LC is turing complete
14:44:43 <mniip> so halting problem qed
14:44:56 <merijn> mniip: In fact, untyped LC and Turing completeness are equivalent :)
14:45:30 <vikaton> I see
14:45:36 <merijn> mniip: Note that in the Simply Typed Lambda Calculus introduced in chapter 8 or 9 of TaPL all terms have a normal form, so termination is trivial :)
14:45:55 <merijn> mniip: Which, of course, also means STLC is not Turing complete
14:46:03 <mniip> merijn, are you saying there is an isomorphism between finite state turing machines and lambdas?
14:46:21 <merijn> mniip: untyped lambda calculus is equivalent to Turing machines, yes
14:46:40 <vikaton> tejing: ran <- show randomRIO (0,100) ?
14:46:47 <merijn> And both are equivalent to Gödel's (?) "general recursive functions"
14:47:23 <small-wolf> has anyone used libssh2 before? I can connect to a vm but the socket immediately disconnects.
14:47:31 <tejing> vikaton: http://lpaste.net/134422
14:47:47 <tejing> vikaton: that runs
14:49:11 <ion> vikaton: First problem: that parses as (show randomRIO) (0,100). Second problem: show (randomRIO (0,100) does not work because randomRIO (0,100) :: IO T and show doesn’t work on IO actions. You can lift show to IO by doing show <$> randomRIO (0,100). (<$>) :: (a -> b) -> IO a -> IO b
14:49:29 <ReinH> vikaton: the else and then need to be indented together
14:49:48 <ion> edwardk: What is a use case for hyperfunctions?
14:49:51 <ReinH> the way you have it isn't valid
14:50:00 <edwardk> ion: making my head hurt
14:50:30 <edwardk> ion: http://arxiv.org/abs/1309.5135 <- shows how to use them to build fusable zips
14:50:38 <vikaton> damn
14:50:42 <ion> edwardk: thanks
14:50:48 <ReinH> edwardk: o/
14:50:57 <edwardk> ion: got bored and started playing with them cold last night
14:51:03 <edwardk> then i found the representable hack
14:51:15 <edwardk> which let me find the arrow instance that i started to believe was a myth
14:51:17 <edwardk> that was hard
14:51:57 <edwardk> now i'm trying to figure out how to 'invoke' one level of the representable hyperfunction stuff, 
14:52:00 <edwardk> and thats hard again
14:52:18 <vikaton> ReinH: how does `read input` turn into the type of ran without specifing it?
14:52:32 <ion> Type inference
14:52:46 <mniip> edwardk, if Hyper x = On (->) ((->) x)
14:52:58 <edwardk> On ?
14:53:04 <tejing> vikaton: the compiler knows because the things on both sides of == have to have the same types
14:53:07 <ReinH> vikaton: inference and defaulting
14:53:09 <mniip> analogous to the Data.Function function
14:53:11 <edwardk> ReinH: heya
14:53:17 <vikaton> Nice !
14:53:18 <mniip> @src on
14:53:18 <lambdabot> (*) `on` f = \x y -> f x * f y
14:53:28 <mniip> then what can we say about On (On (->) ((->) x)) ((->) x)
14:53:46 <mniip> or y
14:54:04 <mniip> actually
14:54:08 <edwardk> i've had a little too much wine for a riddle at the moment =)
14:54:19 <mniip> generalizing hyperfunctions to arbitrary hyperprofunctors is interesting enough in itself
14:54:42 <edwardk> hyperfunctions can be generalized to many categories
14:55:00 <vikaton> does lambdabot have a src repo ?
14:55:54 <arkeet> source to lambdabot? github
14:56:11 <edwardk> ReinH: fun intellectual exercise: https://github.com/ekmett/hyperfunctions/blob/master/RepresentableHyperfunctions.hs . implement theta :: (Hyper b a -> b) -> Hyper a b
14:56:49 <edwardk> and invoke :: Hyper b a -> Hyper a b -> b
14:57:08 * edwardk tries to nerd snipe rein
14:57:24 <vikaton> tejing: what is putStrLn $ for?
14:57:29 <edwardk> wait, maybe i shouldn't have said that out loud
14:57:40 <MP2E> haha
14:58:34 <ReinH> edwardk: damn you
14:58:41 <mniip> edwardk, second' in instance Strong Hyper is undefined
14:58:48 <mniip> or rather, diverges
14:58:53 <tejing> vikaton: f $ x = f x
14:59:16 <edwardk> mniip: fixed
14:59:22 <edwardk> ReinH: you're welcome
14:59:25 <tejing> vikaton: the reason you use it though is because it has low precedence, so you can do g $ f x instead of g (f x)
14:59:41 * mniip doesn't understand the rest of the file :D
14:59:49 <vikaton> tejing: concatenation?
15:00:05 <tejing> vikaton: huh?
15:00:25 <vikaton> I'm confused as to why I need $
15:01:10 <hpc> you don't /need/ it
15:01:15 <tejing> vikaton: without it the line would be parsed as (putStrLn "stuff") ++ ran
15:01:45 <tejing> vikaton: you could also do putStrLn ("stuff ++ ran) but I think the $ is cleaner
15:01:59 <edwardk> mniip: i don't really either. i just wrote it
15:02:23 <mniip> edwardk, checking out Representable lead me to Lookup
15:02:42 <mniip> why is Indexable a subtypeclass of Lookup if index is just a partial version of lookup
15:03:04 <edwardk> mniip: the keys code is a bit of a mess
15:03:12 <tejing> vikaton: just like in algebra * 'binds tighter' than +, in haskell function application (via <space>) 'binds tighter' than _everything_ else
15:03:31 <edwardk> class Lookup f where lookup :: Key f -> f a -> Maybe a
15:03:38 <edwardk> is a partial version
15:03:55 <edwardk> class Lookup f => Indexable f where index :: f a -> Key f -> a
15:04:06 <edwardk> Indexable is a subclass of Lookup because it lets you lookup without failing
15:04:09 <edwardk> so you have it backwards
15:04:25 <mniip> uh
15:04:51 <mniip> looking at instance []
15:05:00 <mniip> lookup 0 [] = Nothing
15:05:11 <mniip> index [] 0 = bottom
15:05:34 <edwardk> lookup can fail. index always succeeds
15:05:54 <edwardk> index sometimes lies to make instances because i wasn't terribly principled
15:06:10 <mniip> ugh, terminology
15:06:34 <mniip> lookup fails purely
15:06:35 <vikaton> I think I got it
15:06:37 <vikaton> Thanks
15:06:38 <mniip> index fails by diverging
15:06:43 <tejing> vikaton: np
15:06:48 <ion> > [66,97,116,109,97,110] & each %%~ ("na",) . chr
15:06:49 <lambdabot>  ("nananananana","Batman")
15:07:32 <edwardk> that Indexable instance shouldn't be there, but i added it anyways =P
15:07:53 <mniip> edwardk, ohhh
15:07:55 <mniip> I se
15:08:00 <edwardk> crap like this is why i bailed on 'keys' and wrote lens
15:08:06 <edwardk> far more principled
15:08:11 <mniip> if we have 'index' we can always devise 'lookup'
15:08:12 <edwardk> in reaction to stuff like this
15:08:20 <mniip> which means Lookup is a subtypeclass of Indexable
15:09:12 <edwardk> only for this crappy example which i say shouldn't hold
15:09:23 <edwardk> consider something like a Map it shouldn't be an instance of Indexable
15:09:28 <edwardk> but it should be an instance of Lookup
15:09:33 <edwardk> other way around
15:09:51 <edwardk> on the other hand, consider something with exactly 2 'slots' then it could be a member of Lookup for Bool
15:09:58 <edwardk> and it could be a member of Indexable for Bool
15:10:05 <edwardk> the Indexable is a stronger constraint
15:10:12 <edwardk> keys is a broken package full of ad hoc crap
15:10:54 <edwardk> i'd delete the package today except for a few remaining users =P
15:10:56 <mniip> I already realized
15:11:22 <mniip> lookupDefault k v = Just (index v k)
15:12:01 <vikaton> tejing: where can I learn more about this $ operator?
15:12:07 <mniip> random question: why does haddock sometimes like to add unnecessary constraints to instances?
15:12:07 <breadmonster> Hi everyone.
15:12:19 <ion> vikaton: Hoogle for ($), the first result links to https://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html#v:-36-
15:12:23 <breadmonster> Can Parsec parse anything?
15:12:29 <mniip> like 'instance Functor [] => Aplicative []'
15:12:30 <breadmonster> Like GLR grammars?
15:12:50 <mniip> breadmonster, iirc parsec only covers context-dependent languages
15:13:11 <breadmonster> mniip: How is that different from context sensitive?
15:13:12 <edwardk> > traverse (("na",) . chr) [66,97,116,109,97,110] 
15:13:13 <lambdabot>  ("nananananana","Batman")
15:13:20 <mniip> breadmonster, *sensitive
15:13:22 <tejing> vikaton: it's in the prelude, so you can look at the docs for the prelude, or you can type ':i $' in ghci and it will tell you most of what you need to know
15:13:34 <tejing> @src ($)
15:13:34 <lambdabot> f $ x = f x
15:13:44 <tejing> boo.. no precedence info
15:13:46 <vikaton> thats what I need to understand
15:13:46 <edwardk> mniip: that was a bug in haddock for a while
15:14:03 <edwardk> mniip: those are 'administrative constraints' ghc deals with behind the scenes that were showing up in haddock
15:14:20 * hackagebot wai-middleware-metrics 0.2.0 - A WAI middleware to collect EKG request metrics  http://hackage.haskell.org/package/wai-middleware-metrics-0.2.0 (Helkafen)
15:14:52 <breadmonster> mniip: Also `sequence [char 'a', char 'b']` is the same thing as `foldl (liftA2 (++)) [char 'a', char 'b']` right?
15:15:02 <mniip> edwardk, so, tabulate constructs a container where each value is a function applied to the respective key?
15:15:11 <mniip> for some meaning of container
15:15:52 <edwardk> mniip: Representable f means that f a  is isomorphic to (Rep f -> a)   -- and tabulate :: (Rep f -> a) -> f a  -- is one direction of the isomorphism, index is the other (not the index from keys the one from Representable)
15:16:06 <mniip> that I understand
15:16:10 <edwardk> Representable functors are isomorphic to functions
15:16:19 <mniip> the laws emphasize that noticeably
15:16:29 <vikaton> tejing: can you show me the f $ x exmaple but with my putStrLn example?
15:16:53 <ion> putStrLn $ foo ++ bar = putStrLn (foo ++ bar)
15:17:08 <ion> putStrLn $ foo = putStrLn foo
15:17:14 <edwardk> mniip: and yeah you could have something where tabulate f = f False :+ f True -- for something like Representable Complex
15:17:31 <edwardk> index (a :+ b) False = a; index (a :+ b) True = b
15:18:02 <mniip> tabulate f = map f [1..]
15:18:03 <mniip> :D
15:18:25 <edwardk> not quite
15:18:29 <edwardk> you have to put it into a shape
15:18:58 <tejing> vikaton: what ion said, also 'foo $ bar $ baz' is 'foo (bar baz)' not '(foo bar) baz'
15:19:06 <ion> tejing: (sadly)
15:19:10 <ion> edwardk: “memoize :: (Bool -> a) -> Bool -> a; memoize = index . tabulate”?
15:19:15 <mniip> well given index=(!!)
15:19:20 * hackagebot geom2d 0.1.3.1 - package for geometry in euklidean 2d space  http://hackage.haskell.org/package/geom2d-0.1.3.1 (seppeljordan)
15:19:28 <mniip> and type instance Key [] = Int
15:19:45 <edwardk> ion: you'd hav to say what the intermediate functor was, but it can be used for memoization, yes
15:19:52 <mniip> tabulate f = map f [0..]
15:19:56 <edwardk> you have a show . read  problem there
15:20:05 <ion> edwardk: alright
15:20:09 <edwardk> mniip: [] isn't representable
15:20:30 <edwardk> if you want to talk about an infinite stream then we can talk
15:20:50 <mniip> oh
15:20:54 <edwardk> data Stream a = a :& Stream a -- now we can use that notion
15:20:56 <mniip> [] isn't Indexable in first place
15:21:00 <edwardk> but [] fails to pass representable
15:21:09 <edwardk> Indexable isn't part of the picture. just shares the name
15:21:12 <tejing> vikaton: $ is also useful for sections (if you don't know what those are don't bother with it for the moment
15:21:15 <edwardk> the current operation is called 'sieve'
15:21:30 <mniip> edwardk, well [] can't be Representable without being Indexable
15:21:31 <ion> breadmonster: sequence [char 'a', char 'b'] = foldr (liftA2 (:)) (pure []) [char 'a', char 'b']
15:21:43 <edwardk> you're looking at an OLD class
15:21:56 <mniip> oh?
15:21:58 <breadmonster> ion: Oh yeah, you're right.
15:22:10 <edwardk> mniip: http://hackage.haskell.org/package/adjunctions-4.2.1/docs/Data-Functor-Rep.html
15:22:36 <mniip> ok
15:23:18 <ion> @type sequence
15:23:19 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:23:21 <ion> @type foldr (liftA2 (:)) (pure [])
15:23:22 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f [a]
15:24:06 <ion> (Should have asked for @type sequenceA to highlight the correct difference.)
15:27:26 <mniip> edwardk, ohh
15:27:31 <mniip> Distributive is interesting
15:28:08 <vikaton> Thanks again
15:28:15 <mniip> it seems to more or less complement Traversable, instance-wise
15:28:58 <ion> Is index . (:: T) . tabulate guaranteed to be a memoizer?
15:37:05 <kgadek> hi. Just wondering: let's say I write a Functor that does not obey any/both of the two laws. Will GHC behave in a bad way due to that?
15:37:17 <kgadek> the same question regarding Monads and other, standard typeclasses
15:37:36 <ion> No code in GHC will use your instance. Any code using the instance will behave in a bad way, though.
15:37:45 <kadoban> kgadek: AFAIK, no, but … any of the things that use your instances could behave badly IIUC.
15:38:27 <mniip> ion, what if there's some RULE that depends on a particular typeclass law?
15:39:21 <kgadek> I'm asking exactly that. Are there transformations (RULEs) using that laws when doing the code transformations (optimizations)?
15:39:30 <kgadek> in other words
15:39:40 <kgadek> if I do that and then use those instances
15:39:44 <kgadek> will surprising things happen?
15:40:11 <kgadek> (like:  result not specified)
15:40:43 <kadoban> I would suggest that you should probably just avoid breaking the laws anyway, unless you have some really good reason? Not that the question isn't interesting anyway, but … ya.
15:42:03 <kgadek> kadoban: I'm not willing to do that, just friend asked me this question and I'm not sure I know the answer
15:45:06 * hackagebot lens-regex 0.1.0 - Lens powered regular expression  http://hackage.haskell.org/package/lens-regex-0.1.0 (TakahiroHimura)
15:45:06 <edwardk> mniip: traversable is one distributive law, distributive gives the other
15:45:38 <edwardk> kgadek: in general no, there are no 'Functor police' that will arrest you for making an illegal Functor.
15:46:05 <edwardk> kgadek: the laws are there for you the human
15:47:20 <kgadek> edwardk: haha good to hear, though I always though of GHC as a policeman that's willing to put you in jail of shame for every mistake you do in your life (actually code)
15:48:58 <kgadek> anyway, that's good to hear. thanks @edwardk kadoban ion 
15:49:37 <mniip> GHC needs an extension so that you could provide laws for instances
15:49:50 <mniip> hmmm, is law conformability decidable?
15:56:07 <voidzero> i wish i had an awesome name like Takahiro Himura
15:56:24 <voidzero> so, in the next life i'm gonna get myself born in japan
15:56:37 <kadoban> Or you could just change your name.
15:57:01 <voidzero> no, that would be cheating
15:57:37 <voidzero> a japanese name has to be inherited, or given IMO
15:57:39 <ion> I saw an awesome name. One of the authors of CTCP (in IRC), Troy Rollo. That could totally be used as a pseudonym by a troll.
15:58:01 <voidzero> changing it feels the same as a tattoo that says "only god can judge me" on my chest
15:58:06 <voidzero> i.e. wildly inappropriate
15:58:22 <voidzero> ion :D
15:58:39 <voidzero> It might already be one.
15:59:16 <voidzero>  in that case
15:59:20 <voidzero> HE GOT YOU!
16:01:58 <webchat099> some japanese names are close to funny meanings in spanish
16:02:38 <webchat099> There is a whole industry of jokes with that
16:03:28 <webchat099> Yosako Mimoto  -> I get out with my motorbike
16:07:20 <ion> CTCP does look like an epic ruse. Thought it’s just a simple “add \1 to the beginning and to the end of a message, now it’s a CTCP query/response”? Think again. It’s insane.
16:07:45 <Xe> ion: don't do it its a trap
16:09:12 <wavewave> hi.
16:09:25 <ion> hi
16:09:35 <ion> wave²
16:09:48 <wavewave> good combination! ion and wave
16:09:54 <wavewave> i am now in bayhac.
16:11:35 <Wingsorc> hey guys I want to define a functor over this data type but doesnt seem to work: http://pastebin.com/0Tj9eZZq
16:13:39 <ion> Wingsorc: Try compiling with Leaf (_ f g) and look at the type of the hole in the compiler output. Can you come up with a value to fill the hole?
16:13:58 <Rvxi> Hey
16:14:07 <mr-_> Wingsorc: you want f . g, not f g on your leaf
16:14:20 <wavewave> f.g
16:14:46 <ion> Teach a man to fish, give a man a fish
16:15:01 <wavewave> ion: you are right.
16:16:55 <sebboh> I think the funky byte is only at the beginning of a CTCP, not the end.  And the rules are simple: a client may never generate a CTCP in response to a CTCP.  ("No loops, please.")
16:17:34 <ion> sebboh: http://www.irchelp.org/irchelp/rfc/ctcpspec.html
16:18:25 <mniip> if I have (Foldable f, Foldable g), how do I fold f (g a)
16:18:28 <ion> Also, the “no loops please” method is implemented by the IRC protocol itself. CTCP queries and responses are encoded in the same way.
16:18:45 <ion> @type foldMap . foldMap
16:18:46 <lambdabot> (Foldable t, Foldable t1, Monoid m) => (a -> m) -> t (t1 a) -> m
16:18:50 <mniip> oh
16:19:10 <mniip> I was trying to think in terms of foldr
16:19:26 <koala_man> sebboh: you can and should generate CTCP in response to CTCP. consider version replies. maybe you're thinking of notice vs privmsg?
16:19:44 <Wingsorc> _ f g has a type of (a -> b) -> (Int -> a) -> (Int -> b). f.g seems to just do that. So do you come up with a defintion by looking at the type? 
16:20:39 <sebboh> yes, yes, I must be thinking of notices.  And the DCC file dance is another instance...
16:20:43 <ion> Wingsorc: One might recognize (.) from the type, but if not, when writing an implementation of the type.
16:21:14 <ion> @djinn (a -> b) -> (i -> a) -> (i -> b)
16:21:15 <lambdabot> f a b c = a (b c)
16:21:19 <sebboh> Closing time.
16:24:20 <pavonia> Wingsorc: In many situations there is only a single meaningful way to combine functions such that the result type checks. When you look at the types of f :: (a -> b) and g :: Int -> a, this is exactly one of these situations
16:28:11 <Wingsorc> fmap must be of type (a -> b) -> ITree a -> ITree b. Is it not possible to for f to be (Int -> a') -> (Int -> b') instead of f:: (a -> b) ? a and b are so to say substituted 
16:28:57 <ion> Wingsorc: In fmap :: forall a b. (a -> b) -> ..., the *invoker* of fmap decides the “a” and the “b”, not the implementation of fmap.
16:29:31 <Wingsorc> ahh
16:30:02 <ion> Wingsorc: forall kind of adds a new parameter which is not a value but a type and which is implicitly filled in.
16:32:01 <ion> (Haskell may one day have “forall a ->” which lets you specify a type parameter explicitly, and also “pi a.” and “pi a ->” which leave you a runtime representation of the type.)
16:33:48 <Wingsorc> I understand that the invoker determines "a" and "b". But what do you mean with fmap :: forall a b ...?
16:35:36 <ion> fmap :: (a -> b) -> F a -> F b has an implicit forall for each unquantified type variable, that type signature is the same as fmap :: forall a b. (a -> b) -> F a -> F b
16:36:15 <ion> fmap :: Functor f => (a -> b) -> f a -> f b is the same as fmap :: forall f a b. Functor f => (a -> b) -> f a -> f b
16:39:23 * hackagebot pagure-hook-receiver 0.1.0.0 - Receive hooks from pagure and do things with them  http://hackage.haskell.org/package/pagure-hook-receiver-0.1.0.0 (RickyElrod)
16:45:32 <ion> If the type parameters were explicit, a call might look like: fmap Maybe Char Int ord (Just 'a')
16:49:24 * hackagebot linear-grammar 0.0.1.6 - A simple grammar for building linear equations and inclusive inequalities.  http://hackage.haskell.org/package/linear-grammar-0.0.1.6 (athanclark)
16:51:10 <mniip> Wingsorc, consider fmap :: Functor f => (a -> b) -> f a -> f b
16:51:39 <mniip> the instance dictates what f is
16:51:52 <mniip> but a and b come from the type signature
16:52:00 <mniip> as such, fmap has to work /for all a and b/
16:52:37 <mniip> i.e it should be able to accept a function of any type
16:53:07 <mniip> and a respective contexted value
16:53:16 <mniip> and /has to/ return a corresponding contexted value
16:53:18 <Wingsorc> Ah ok I understand. I never saw this forall syntax before so that why i was a bit confused
16:54:09 <ion> > let x :: forall a. [a]; x = []; y :: forall a. Num a => [a]; y = [0,1,2] in (x,y)
16:54:10 <lambdabot>  ([],[0,1,2])
16:54:35 <Wingsorc> Since there are no "constraints" on a and b, like my proposed type it must work for all possible a and b which was not given by my defintion of the functor
16:54:56 <mniip> Wingsorc, correct
16:55:14 <ion> > let x :: forall a. [a]; x = []; y :: forall a. Num a => [a]; y = [0,1,2] in (x :: [Char], y :: [Integer])  -- again, the type variables are dictated at the call site
16:55:15 <lambdabot>  ("",[0,1,2])
16:56:58 <voltz> What does it mean to set the type of a function to another function.
16:57:28 <mniip> voltz, sounds like the sentence is missing context
16:58:39 <voltz> Ion put in some code where it seems that the type of a function is another function.
16:59:08 <mniip> voltz, what code?
16:59:24 <voltz> (ion) > let x :: forall a. [a]; x = []; y :: forall a. Num a => [a]; y = [0,1,2] in (x :: [Char], y :: [Integer])  -- again, the type variables are dictated at the call site
16:59:43 <ion> There are no functions on that line.
16:59:44 <mniip> I see no functions in that code
17:01:04 <Wingsorc> ion when I try to run your line in ghci It gives me an error. Do I miss some kind of import?
17:01:19 <ion> Wingsorc: Which line?
17:01:22 <mniip> Wingsorc, read the error message
17:01:23 <ion> Which error?
17:01:48 <Wingsorc> <interactive>:213:18:
17:01:50 <Wingsorc>     Illegal symbol '.' in type
17:01:51 <Wingsorc>     Perhaps you intended to use RankNTypes or a similar language
17:01:53 <Wingsorc>     extension to enable explicit-forall syntax: forall <tvs>. <type>
17:02:06 <mniip> I meant you should read it to yourself
17:02:28 <Wingsorc> huh?
17:02:52 <Wingsorc> ah
17:03:19 <pavonia> "forall ..." is not part of the standard syntax, you need to enable said extension to be able to use it
17:07:02 <Wingsorc> Can I use this forall to say that a has to be of type e.g. Int Char etc.?
17:07:35 <ion> @type undefined :: forall a. (a ~ Int) => a
17:07:36 <lambdabot> Int
17:07:45 <ion> @type undefined :: (a ~ Int) => a
17:07:46 <lambdabot> Int
17:08:02 <ion> (a ~ Int) is a constraint that a must be equal to Int. (a ~ Int) => a is the same as Int.
17:08:10 <arkeet> forall is just for introducing type variables
17:08:40 <edwardk> wavewave: say hi to the bayhackers for me. sadly i can't make it this year
17:10:22 <Wingsorc> Thanks ion thats what I meant. It feels like the quantifiers used in logic
17:10:57 <subleq__> https://ghc.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
17:11:02 <subleq__> what's the problem with the example?
17:11:41 <ion> subleq: “else” is indented to the same column as “if” which normally means an implicit ; in the do block.
17:11:57 <ion> do { if x then return 1; else return 2 }
17:12:30 <geekosaur> which translates to: if x then return 1 >> else return 2
17:12:43 <Jello_Raptor> is there a monad for stateful error recovery? something where an operation can fail, if it sails the state is unchanged, but information on failure is available to the control flow, and that control can continue ? 
17:13:07 <subleq__> i see
17:13:46 <subleq__> layout still confuses me
17:13:53 <Jello_Raptor> actually i think my definition would break associativity of the bind operator 
17:14:37 <hpc> sounds a bit like State with some extra stuff baked into (>>=)
17:18:08 <orion> What's the best way to pattern match, where the pattern is a variable?
17:18:17 <Ralith> Jello_Raptor: isn't that ErrorT State or StateT Error (I forget which)?
17:18:44 <wavewave> edwardk: Sure!!
17:18:49 <Pamelloes> gah. lens' doctests take forEVER to run
17:19:18 <pavonia> orion: What do you mean?
17:19:27 <ion> orion: A guard with ==
17:19:37 <wavewave> edwardk: shachaf said hello to you~
17:19:47 <orion> pavonia: The pattern I want to match against is itself variable.
17:19:56 <ion> wavewave: Please say “hachaf” to shachaf.
17:20:03 <edwardk> ask him when he's going to move to boston ;)
17:20:05 <orion> And I already have a case statement with tons of other potential matches.
17:20:23 <shachaf> hion, hedwardk, havewave
17:20:34 <geekosaur> I don't think you can do that because it wouldn't be able to check the type?
17:20:52 <pavonia> orion: Probably what ion said, but I'm still not sure I understand correctly
17:21:28 <orion> pavonia: I am parsing HTTP paths in wai. If the path equals "foo", I want some action to happen, but "foo" should not be hard coded.
17:22:16 <orion> A variable is passed to my wai Application containing the exact path I want to match, which may or may not be "foo".
17:22:37 <pavonia> Okay, you need an equality test then, you can't match on that
17:22:42 <orion> Ah. :(
17:23:48 <lyxia> Jello_Raptor: ExceptT e (State s) a doesn't lose the state after an error is raised, StateT s (Except e) a backtracks and resets the state at the point where it's caught.
17:26:35 <pavonia> orion: Could you paste the relevant part of your code? Maybe there's an even more clever way of doing it
17:34:47 <orion> pavonia: http://lpaste.net/5282615757522337792
17:36:36 <pavonia> I can't think of anything shorter than "x' | x' == x -> foo"
17:37:09 <orion> Is it possible to mix such a guard in to the rest of the patterns?
17:37:37 <pavonia> You can add guards to any pattern
17:37:59 <orion> But, I basically need a catch-all pattern on top, and a guard beneath.
17:38:01 <orion> Am I right?
17:39:15 <pavonia> Um, it doesn't matter where that pattern is
17:39:22 <orion> Yes, true.
17:39:50 <pavonia> And you will need a final pattern to catch all other cases
17:39:55 <orion> Right.
17:40:19 <orion> It's a shame I can't do something like: case (requestMethod req, pathInfo req) of (methodGet, ["ping"]) -> do ...
17:40:30 <orion> That makes me very sad. :(
17:40:46 <lamefun> Is there a proper example for: https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Expr.html
17:41:28 <pavonia> orion: You mean where methodGet is match on an already existing variable?
17:42:12 <orion> https://hackage.haskell.org/package/http-types-0.8.6/docs/Network-HTTP-Types-Method.html#v:methodGet
17:43:05 <pavonia> Okay. No, that won't work
17:43:43 <orion> I'm guessing I'll have to use an if statement on the requestMethod, and then have a separate case statement for each method I want to match against.
17:43:55 <orion> Do you agree?
17:44:37 <pavonia> You can use a guard here again: case ... of (m, ["ping"]) | m == methodGet -> do ...
17:45:14 <orion> Ah, interesting.
17:46:15 <pavonia> Maybe there's something even more concise with the ViewPattern extension, but I'm not familar with that
17:46:19 <ion> ((== methodGet) -> True, ["ping"]) -> do … would work, too, but that may not actually be nicer.
17:46:19 <orion> But then I need to stick a "sendResponse ... status404" all over the place.
17:46:20 <edwardk> ReinH: beat you to it. i finished invoke
17:46:29 <orion> Because what if they send POST /ping?
17:46:59 <ion> orion: Then that pattern will not match.
17:47:15 <edwardk> that turned out to be tricky in representable form
17:47:21 <edwardk> it typechecked so its probably correct
17:47:42 <orion> ion: Wait, so you're saying that if a guard which appears after a pattern match won't match the entire pattern if the guard doesn't match?
17:48:51 <hpc> > let foo x | x == "yes" = "maybe"; foo x = "no" in foo "why not test!"
17:48:52 <lambdabot>  "no"
17:49:27 * hackagebot quickcheck-simple 0.0.1.0 - Test properties and default-mains for QuickCheck  http://hackage.haskell.org/package/quickcheck-simple-0.0.1.0 (KeiHibino)
17:50:33 <pavonia> lamefun: Why do you think this example isn't a proper one?
17:51:04 <lamefun> pavonia, it doesn't define reservedOp
17:51:58 <pavonia> lamefun: It's defined in Text.Parsec.Token
17:53:55 <lamefun> Whoa... I don't want to make an entire language, I simply want version expressions like ">=1.2.0 && <2.4.0 || >=3.2.0"...
17:55:42 <ion>  I would imagine cabal has a parser for that. I don't know whether it exports it.
17:57:38 <athan> I have an inconsistency that's driving me mad
17:57:46 <athan> super mad
17:57:48 <pavonia> lamefun: Also, you don't need reservedOp there, you can replace it with a custom parser
17:58:20 <lamefun> But I don't know what should it do!
17:59:44 <pavonia> It parses your operators and returns the associated function
17:59:46 <athan> http://lpaste.net/134424
18:00:08 <Welkin> athan: batman strikes again!
18:00:35 <athan> D:
18:01:09 <athan> Welkin: That wasn't a riddle, was it?
18:02:46 <pavonia> athan: What are the types of nextColumn and nextRow?
18:03:09 <athan> pavonia: nextColumn and nextRow return `Maybe Int` - to represent indicies into a matrix
18:03:30 <ion> athan: repeat (show (0/0))
18:03:48 <athan> ion: That's what I thought was happening
18:03:50 <athan> but get this:
18:04:01 <athan> when I call `pivot` with the exact same inputs, manually
18:04:02 <athan> it's fine
18:04:04 <athan> I don't get
18:04:07 <pavonia> The Int type is fixed?
18:04:07 <ion> athan: That was re: Batman
18:04:23 <athan> oh lord, I needed that
18:04:31 <athan> pavonia: Fixed?
18:04:47 <ion> > concat . repeat . show $ 0/0
18:04:49 <lambdabot>  "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN...
18:04:59 <pavonia> athan: Explicitly annotated by you
18:05:01 <athan> To the traceShow!
18:05:20 <athan> pavonia: Yes, it's in nextRow & nextColumn
18:05:23 <athan> 's type signature
18:05:51 <pavonia> The only difference I can think of is related to defaulting, the monomorphism restriction or something like that
18:06:13 <athan> pavonia: Hmm, okay that might help! Thank yoou
18:06:40 <Welkin> ion: that's the line I was thinking of
18:09:13 <athan> WAIT
18:09:15 <athan> I found it
18:09:23 <athan> thanks pavonia, I swapped column & row ><
18:09:39 <pavonia> :)
18:09:52 <athan> I'm probably going to have weird NaN dreams now with Adam West, though
18:12:14 <athan> eff yeah
18:12:19 <athan> it works! :D
18:13:04 <Welkin> Electronic Frontier Foundation?
18:13:32 <athan> I wish
18:13:52 <athan> Welkin: primal simplex :)
18:13:53 <athan> maximization for now
18:27:25 <DanBurton> Can we get lambdabot to join #bayhac?
18:28:48 <geekosaur> talk to int-e
18:38:54 <Jello_Raptor> is there a canonical infix application operation? something like " f <&> x = f x " It would be useful to have an explicit such operator. 
18:39:25 <edwardk> :t ($)
18:39:26 <Axman6> that's $
18:39:26 <lambdabot> (a -> b) -> a -> b
18:39:27 <Jello_Raptor> actually ... doesn't identity do that ? 
18:39:37 <Axman6> @src ($)
18:39:37 <lambdabot> f $ x = f x
18:40:08 <srhb> Jello_Raptor: Yep.
18:40:12 <ReinH> Jello_Raptor: yes, ($) is `id` specialized to a -> b
18:40:12 <Jello_Raptor> I thought "$" was the identity operator defined as "$ x = x" but that all works out the sam 
18:40:29 <ReinH> that's not a valid definition
18:40:30 <srhb> There's some extra magic surrounding ($) when it comes to do blocks and such
18:40:31 <Axman6> no...
18:40:41 <Jello_Raptor> hmm? 
18:40:47 <Jello_Raptor> i'm confused then. 
18:40:53 <Axman6> $ x = x is not valid
18:40:58 <dmj`> > zipWith id [(+1)] [1] == zipWith ($) [(+1)] [1]
18:40:59 <lambdabot>  True
18:41:09 <bitemyapp> dmj`: yo
18:41:14 <dmj`> bitemyapp: sup
18:41:16 <bitemyapp> dmj`: ctrl-f "prefix" on the hackage docs.
18:41:24 <bitemyapp> dmj`: prefix query and prefix filter are supported
18:41:53 <Jello_Raptor> Axman6: i'm not sure I understand why
18:42:12 <Bruno_> Hi, I'm tryting to write some really low level code and I'm wondering how to write this c line of code in haskell: "char *vidptr = (char*)0xb8000;"
18:42:12 <dmj`> bitemyapp: solid, forgot to rtfm I suppose :) 
18:42:14 <Axman6> $ can only be used as an infix operator, which is why the definition is f $ x = f x
18:42:48 <Axman6> Bruno_: probably using C is easiest. that's a pretty unsafe thing to do
18:42:49 <bitemyapp> dmj`: it's all good, just wanted to let you know because you hadn't been online.
18:43:34 <Jello_Raptor> Axman6: ahh
18:43:39 <tejing> srhb: what do you mean by 'extra magic'?
18:44:17 <Bruno_> Axman6: Let's say that I just really really want to write that line, how to do it? I've looked at the Foreign module and I see nothing of use
18:44:20 <Axman6> the type of ($) doesn;t work when you apply it to something like runST $ do ... so GHC has a rule to make it ok to do that
18:44:33 <Axman6> Bruno_: I'm not sure of it is possible
18:45:21 <tejing> Axman6: it doesn't?
18:45:41 <srhb> :t runST
18:45:42 <lambdabot> (forall s. ST s a) -> a
18:45:46 <srhb> tejing: note the forall
18:45:47 <Axman6> no, the ST monad uses rank-2 types (IIRC)
18:45:50 <srhb> :t ($)
18:45:51 <lambdabot> (a -> b) -> a -> b
18:45:54 <srhb> No forall. :(
18:46:55 <dmj`> bitemyapp: yea, still trying to wrap my brain around elasticsearch, searching for tags here should create score by most recent, frequent and relevant. Trie is relevance, the rest are just conditions on date (time created) and int (# of reposts) fields. 
18:46:57 <srhb> I ran into this yesterday with something similar and had forgotten all about higher ranks
18:47:01 <srhb> :t flip runST 
18:47:02 <lambdabot>     Couldn't match type ‘a’ with ‘forall s. ST s (b -> c)’
18:47:03 <lambdabot>       ‘a’ is a rigid type variable bound by
18:47:03 <lambdabot>           the inferred type of it :: b -> a -> c at Top level
18:47:07 <srhb> ^^--- tejing
18:47:21 <ronh_> :t lambdabot
18:47:22 <lambdabot> Not in scope: ‘lambdabot’
18:47:24 <dmj`> bitemyapp: thanks for pushing out the thread pool changes so fast
18:48:10 <tejing> srhb: apparently I don't understand higher-rank types at all... I thought I did :-/
18:48:16 <ronh_> Bruno_ intPtrToPtr 0xb8000
18:48:16 <srhb> Haha. Aww. :-)
18:48:32 <Axman6> gross :(
18:49:18 <Bruno_> thanks!!! ronh_
18:50:17 <srhb> tejing: I don't know why I went and used flip. Even id would fail.
18:51:59 <funfunctor1> is it allowed to have a where on one of the branches of a if statement?
18:52:18 <srhb> funfunctor1: Nope.
18:52:57 <funfunctor1> srhb: thx, probably writing pretty screwy code any way
18:53:08 <funfunctor1> due to interacting with hardware
18:53:13 <Axman6> I sometimes wish that where was basically flipped let, so <expr> where <decls> was valid
18:53:35 <Axman6> as an expr
18:53:49 <srhb> Then we'd need something new to replace the old where...
18:54:02 <funfunctor1> where' ?
18:54:04 <funfunctor1> :p
18:54:08 <bitemyapp> dmj`: np.
18:54:20 <Axman6> I don't see why, both forms could be valis
18:54:22 <Axman6> d*
18:54:24 <Axman6> maybe
18:54:30 <srhb> Oh, I guess so yes.
18:54:36 <tejing> srhb: can you explain at all what limitation is causing that problem? I can't figure out what would make it fail
18:55:41 <Axman6> a doesn't unify with (forall s. ST s a) because of the forall
18:56:00 <Axman6> :t runST
18:56:00 <lambdabot> (forall s. ST s a) -> a
18:56:15 <tejing> Axman6: well clearly, but what's wrong with unifying those?
18:56:15 <Axman6> that can't be unified with a -> b
18:56:47 <Axman6> that's a better question, but not one I understand the answer well enough to answer
18:58:19 <srhb> Same here really.
18:58:41 <tejing> well... confusion loves company? :-P
18:58:55 <srhb> Something something impredicative polymorphism.
18:59:14 <log90> hello
18:59:18 <srhb> I think the main issue is simply that it cannot be automated reliably
18:59:21 <srhb> The unification, I mean
18:59:24 <srhb> log90: Hello.
19:00:15 <log90> http://osdir.com/ml/haskell-cafe@haskell.org/2011-07/msg00680.html
19:00:28 <log90> is there anybody who knows a solution to this problem?
19:00:42 <log90> i tried the one written there but it doesn't work
19:01:50 <geekosaur> no, that example would not work
19:02:01 <Cale> log90: it should be  main quux  without the colon
19:02:12 <log90> i try, thanks
19:02:28 <geekosaur> ...what?
19:02:31 <Axman6> I don;t think that's right...
19:02:44 <Axman6> he wants quux to ber stdin
19:02:57 <log90> main = interact wordCount 	where wordCount input = show (length (lines input)) ++ "\n"
19:03:06 <log90> this is my short example program
19:03:18 <Cale> Oh, right, no
19:03:22 <dmj`> log90: main = writeFile "quux.txt" =<< wc <$> readFile "quux.txt"
19:03:41 <Cale> You can't redirect stdin from inside ghci
19:04:09 <geekosaur> ideally :main would be extended to support redirection
19:04:10 <Cale> at least, not in any obvious way
19:04:33 <Axman6> can you write to the stdin handle?
19:04:43 <geekosaur> if it's a terminal :)
19:05:02 <Axman6> probably a really bad idea from within ghci, which is reading input from the keyboards via stdin...
19:05:03 <geekosaur> (not an exact answer but close enough)
19:05:27 <geekosaur> for historical reasons the controlling terminal is initially opened O_RDWR and dup()ed into fds 1 and 2
19:05:32 <srhb> tejing: (id :: ((forall s. ST s a) -> a) -> ((forall s. ST s a) -> a)) runST
19:05:38 <srhb> tejing: This works with ImpredicativeTypes
19:05:42 <dmj`> you can access the shell in ghci via ":! echo foo"
19:05:55 <srhb> Sadly, lamdabot doesn't have that
19:05:56 <ttt_fff> I'm writing a webapp in haskell.
19:06:06 <srhb> :t (id :: ((forall s. ST s a) -> a) -> ((forall s. ST s a) -> a)) runST
19:06:07 <lambdabot>     Cannot instantiate unification variable ‘a0’
19:06:07 <lambdabot>     with a type involving foralls: (forall s. ST s a1) -> a1
19:06:07 <lambdabot>       Perhaps you want ImpredicativeTypes
19:06:11 <dmj`> ttt_fff: cool !
19:06:16 <ttt_fff> For the backend, I want something that has the relational model (i.e. SQL like).Is there something more modern / scalable than postgres?
19:06:39 <dmj`> ttt_fff: I doubt it
19:06:41 <Axman6> why not postgres? (or SQLite?)
19:06:56 <ttt_fff> from what I have read, postgres / sqlite is meant for 1 machine
19:06:56 <geekosaur> not as free software there isn't
19:06:59 <srhb> ttt_fff: postgres is more or less state of the art.
19:07:00 <Axman6> if you need scalable then postgres is your best bet
19:07:11 <ttt_fff> mysql is slightly better scaling I heard (but I like opaleye, which uses postgres)
19:07:13 <geekosaur> sqlite is meant for 1 machine
19:07:16 <geekosaur> postgres is nopt
19:07:19 <Axman6> postgres is definitely not for jyst one machine...
19:07:23 <dmj`> http://howfuckedismydatabase.com/
19:07:27 <ttt_fff> geekosaur: what is nopt ?
19:07:27 <geekosaur> mysql is not better scalable
19:07:32 <geekosaur> it's a typo for "not"
19:07:36 <srhb> It used to be, but no longer.
19:08:03 <Axman6> Amazon also provides a postgres compatible RDS system which is basically infinitely scalable
19:08:21 <geekosaur> mysql is "scalable" as long as you stick to very simple things and not too many of them; it will fall on its arse fairly quickly under high load
19:08:34 <geekosaur> postgres is significantly more scalable to high transaction load
19:09:16 <geekosaur> you may be mistaking basic performance; postgres starts out slower but doesn't slow down as much as the transaction load scales up
19:09:26 <ttt_fff> okay, so if I want anything SQL like, I should jsut stick to postgresql and not someting new, like sparkQL ?
19:09:27 <geekosaur> mysql starts out faster but tops out fairly quickly
19:09:57 <geekosaur> and sqlite is really not up to much of anything
19:10:26 <ttt_fff> sqlite is a better fopen
19:10:28 <geekosaur> very small databases, very limited multiple access, don't share across machines unless you like lost data
19:10:33 <Axman6> SQLite is orders of magniture faster than MySQL or Posrtgres for single users ;)
19:10:48 <Axman6> I disagree with the very small databases part too
19:10:52 <dmj`> ttt_fff: what kind of data do you plan on storing
19:11:14 <geekosaur> Axman6, that may depend on what you consider a large database
19:11:18 <geekosaur> I used to be a DBA
19:11:27 <geekosaur> my idea of very small is likely much larger than yours :)
19:11:30 <ttt_fff> dmj`: mostly annotations, i.e. sorta like the genius.com 'annotating the web' aspect
19:11:34 <Axman6> SQLite supports crazy large database sizes
19:11:40 <Axman6> your FS may not though
19:11:49 <srhb> ttt_fff: Just out of curiosity, do you _know_ that you want RDB? As in, why not acid-state? :-)
19:12:06 <ttt_fff> srhb: I like sql
19:12:13 <ttt_fff> srhb: I wish haskell had better support for row types
19:12:13 <srhb> But surely you prefer Haskell
19:12:15 <srhb> :-)
19:12:26 <srhb> ttt_fff: acid-state with tables is really badass.
19:12:29 <geekosaur> oh, you;re not even thinking about actual use cases, just raw context-free stats about file sizes
19:12:37 <Axman6> there was a recent paper discussing implementing a relational DB in haskell
19:12:48 <ttt_fff> srhb: is 'tables' here a list of relations, or somethign else?
19:12:54 <dmj`> ttt_fff: not sure how well annotations map to a relational model, how large do you anticipate the data getting
19:12:55 <srhb> ttt_fff: https://hackage.haskell.org/package/tables
19:13:07 <srhb> ttt_fff: Actually, read this instead: https://github.com/ekmett/tables/
19:13:11 <bitemyapp> migrating acid-state databases gives me hives.
19:13:23 <Axman6> why?
19:13:26 <srhb> bitemyapp: Really?
19:13:26 <dmj`> bitemyapp: really? It was a pleasure for me
19:13:30 <srhb> bitemyapp: I've never had any issues.
19:13:47 <Axman6> what I've done with it seemed a little clunky but overall pretty safe
19:13:49 <dmj`> safecopy is the most pleasant migration experience I've ever had
19:13:50 <ttt_fff> wtf https://github.com/ekmett/tables/ is like querying in haskell
19:13:55 <Axman6> and relatively easy
19:14:00 <srhb> ttt_fff: It's glorious. :-)
19:14:18 <dmj`> srhb: is tables pure? did you write your own serialize instance
19:14:19 <ttt_fff> srhb: but can you do joins + projections?
19:14:29 <srhb> dmj`: It can derive safecopy
19:14:37 <bitemyapp> I didn't say it was unsafe
19:14:41 <bitemyapp> I said it gave me hives.
19:15:09 <dmj`> ttt_fff: acid-state queries are non-blocking (mvar reads), the Query monad is also pure, so you can parallelize queries on your state
19:15:14 <lautrec> what's the idiomatic way to map a function over each key/value pair in a Map? so far i have this: https://gist.github.com/yarbroughw/4dbe4c3024804cdecc0d
19:15:48 <srhb> lautrec: mapWithKey?
19:15:57 <dmj`> :t Data.Map.mapWithKey
19:15:58 <lambdabot> (k -> a -> b) -> M.Map k a -> M.Map k b
19:16:07 <lautrec> ahh thanks
19:16:39 <srhb> ttt_fff: I don't think the concepts translate directly.
19:16:40 <lautrec> wait, that returns another Map...?
19:16:44 <srhb> Yep.
19:17:16 <srhb> you can just toList it afterwards, or whatever you want to do with it. Or you can foldWithKey instead
19:17:16 <Axman6> that's what mapping is
19:17:59 <srhb> ttt_fff: Anyway, just wanted to make sure you knew of these options. :)
19:18:04 <srhb> okbai
19:18:11 <lautrec> i was looking for something like (k -> v -> a) -> M.Map k v -> [a]
19:18:20 <lautrec> but yeah, toList seems to work
19:18:38 <lautrec> after the mapWithKey, that is
19:18:59 <dmj`> :t \f -> Data.Foldable.toList . Data.Map.mapWithkey f
19:19:00 <lambdabot> Not in scope: ‘Data.Map.mapWithkey’
19:19:19 <dmj`> :t \f -> Data.Foldable.toList . Data.Map.mapWithKey f
19:19:20 <lambdabot> (k -> a1 -> a) -> M.Map k a1 -> [a]
19:19:33 <lautrec> sweet :) thanks again
19:21:53 <pavonia> :t \f -> map (uncurry f) . Data.Map.toList
19:21:53 <lambdabot> (a -> b1 -> b) -> M.Map a b1 -> [b]
19:23:30 <edwardk> woot. i think i've got all the standard hyperfunction constructions working now in my representable form
19:25:53 <srhb> ... hyperfunction?
19:27:46 <funfunctor1> @hoogle :: Monad m => Bool -> m a -> m ()
19:27:46 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
19:27:47 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
19:27:47 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
19:32:22 <edwardk> srhb: newtype Hyper a b = Hyper (Hyper b a -> b)
19:32:27 <edwardk> they form a category, arrow, profunctor, etc.
19:32:32 <srhb> Fun!
19:32:57 <edwardk> i wanted to find a way to represent them efficiently
19:33:02 <srhb> Haskell: Where functions aren't functiony ENOUGH
19:33:16 <edwardk> found a couple of tricks recently for working with moore machines that turned out to be perfect for these
19:33:28 <srhb> Oh, yeah, I forgot to follow those articles.
19:33:45 <edwardk> they come up when you try to make foldr-build fusion handle zipping
19:33:54 <edwardk> but they come up in other contexts as well now and again
19:34:03 <voltz> Profunctors?
19:34:08 <edwardk> so i felt it was worth taking an old apocryphal claim that they formed an arrow and get them to work
19:34:12 <edwardk> voltz: hyperfunctions
19:34:46 <voltz> ?...
19:34:46 <lambdabot> Not enough arguments to @.
19:35:34 <srhb> edwardk: Just a claim? No one had showed it?
19:35:49 <edwardk> srhb: there was a paper that made an offhand comment that they formed arrows
19:35:52 <edwardk> but that was it
19:35:55 <srhb> Okay. :P
19:35:58 <edwardk> the proof was damn hard
19:36:06 <srhb> That's just mean of whoever wrote the paper then.
19:36:07 <srhb> :P
19:36:30 <edwardk> it was a 15 year old unpublished paper to boot, and the comment was a throwaway line at the end of the paper
19:36:40 <Axman6> "It is obvious that hyperfunctions form arrows" (Hopefully someone proves this for me)
19:36:56 <srhb> Axman6: You missed an obvious opportunity for "... but this margin"
19:37:26 <srhb> :-)
19:39:21 <edwardk> Axman6: pretty much
19:40:27 <ion> edwardk: nice
19:41:32 <edwardk> "I have discovered a truly marvellous proof of this, which this page count limit is too narrow to contain"
19:42:08 <ion> which this filesystem's size limit is too narrow to contain
19:42:33 <srhb> "... but LaTeX refuses to format it without gagging on bad vboxes"
19:42:45 <edwardk> ion: i'd given up on actually getting the arrow code to work right up until it did
19:42:55 <edwardk> https://github.com/ekmett/hyperfunctions/blob/master/RepresentableHyperfunctions.hs#L29
19:43:08 <edwardk> with the representable form and explicit 'nu' it is pretty obvious now
19:43:17 <edwardk> but it wasn't obvious until very late in the process
19:44:16 <edwardk> what i really want is a more efficient form of 'roll' than abusing lambek's lemma though
19:44:27 <ion> What's nu?
19:44:29 <edwardk> and a more direct uninvoke
19:44:42 <edwardk> the 'greatest fixed point'
19:45:03 <edwardk> (it has pretty good press compared to mu, which somehow let itself get branded the least fixed point)
19:45:14 <edwardk> we use things like
19:45:25 <edwardk> newtype Fix f = Fix (f (Fix f))
19:45:26 <edwardk> in haskell
19:45:32 <Myrl-chan> Logical implication looks better explained with `imp 1 x = x; imp 0 _ = 1`
19:45:39 <edwardk> but the fact that we can both go in and out of that is a quirk of haskell
19:47:06 <edwardk> so let's take cata :: (f a -> a) -> Mu f -> a -- and  define Mu just by what that lets us say., we flip and get Mu f -> (f a -> a) -> a  -- and we can just ball it up into a definition for the constructor  newtype  Mu f = Mu { runMu :: forall a. (f a -> a) -> a } 
19:47:43 <ion> Ah, that thing. /me looks up this old exercise he did to refresh his memory. https://gist.github.com/ion1/5957723
19:48:16 <edwardk> on the other hand we have 'ana :: (a -> f a) -> a -> Nu f  -- we can uncurry to get: (a -> f a, a) -> Nu f     and we can move the forall into negative position as an existential. (exists a. (a -> f a, a)) -> Nu f
19:48:21 <edwardk> and we can take that as the definition of Nu
19:48:35 <edwardk> ion: yep
19:48:44 <edwardk> now, lets play with representable functors and Nu
19:48:49 <edwardk> this is a trick of mine
19:49:19 <edwardk> a representable functor f is one where f a is isomorphic to (x -> a)
19:49:56 <edwardk> or rather (f a) is isomorphic to (Rep f -> a)   tabulate :: (Rep f -> a) -> f a; index :: f a -> Rep f -> a
19:50:09 <edwardk> now all we know about 'a' in Nu f is that 'it exists'
19:50:21 <edwardk> and we have a function from it to f a
19:50:51 <edwardk> exists a. (a -> f a, a) ~ exists g. Representable g => (g (f a), Rep g)
19:51:06 <edwardk> pick g = (->) a   -- but now sometimes it can be more efficient, if 'a' is small
19:51:15 <edwardk> it can memoize all the different 'a's
19:51:45 <edwardk> so if you build a tree using this sort of explicit 'Nu' and have a seed that is amenable to it you could choose to make a tree that self-memoizes off the internal state space
19:52:01 <edwardk> or at least 'has the option to'
19:52:10 <edwardk> since you can always revert to usual functions
19:52:41 <edwardk> i did this with a moore machine in an article a little while back
19:53:38 <edwardk> took Moore a b = Moore b (a -> Moore a b) -- switched to Nu to get the representation we like Moore :: (s -> b) -> (s -> a -> s) -> s -> Moore a b -- then played games with a representable functor with 's' as its representation
19:54:05 <edwardk> to get Moore :: Representable f => f b -> (a -> f (Rep f)) -> Rep f -> Moore a b
19:54:48 <edwardk> and showed that for some representable functors f (Rep f) ~ (Rep f -> Rep f) ~ Endo (Rep f)   can be much more efficient than Endo (Rep f) -- letting us win asymptotically
19:54:57 <edwardk> so i decided to see if i could to the same thing for hyperfunctions
19:56:04 <edwardk> and that led to thinking of hyperfunctions the Nu based fixed point of the functor H a b x = H { runH :: (x -> a) -> b }
19:56:34 <edwardk> data Hyper a b where Hyper :: (x -> (x -> a) -> b) -> x -> Hyper a b
19:56:40 <edwardk> then applying the representation trick
19:57:14 <edwardk> data Hyper a b where Hyper :: Representable f => f (f a -> b) -> Rep f -> Hyper a b
19:57:25 <edwardk> which has proven quite strange
19:58:43 <ion> edwardk: Interesting, thanks for the explanation. I'll have to reread it after some sleep.
19:59:33 * hackagebot quantfin 0.2.0.0 - Quant finance library in pure Haskell.  http://hackage.haskell.org/package/quantfin-0.2.0.0 (tdees)
20:00:24 <edwardk> anyways there are some rather delightful connections between mealy machines, moore machines, hyperfunctions, and store, state and cont, as well as to some nice ways to think about algebras, state arrows, costate arrows, etc.
20:00:57 <edwardk> (and connections to the indexed versions of store, state, and cont that i wasn't expecting)
20:01:29 <edwardk> which then tie it back to a lot of the indexed tricks we've been playing with with lenses and atkey lately
20:01:57 <ion> Neat
20:10:47 <tejing> is there an explanation somewhere of how prisms and reviews work/are derived?
20:17:20 <pacak> tejing: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
20:20:12 <tejing> pacak: that mostly says what they are (intuitively speaking) and how to use them. I'm looking for a deeper analysis
20:20:49 <benzrf> tejing: they are dual
20:20:57 <Axman6> edwardk: I was reading your series of posts on matrix multiplication on FP Complete's blog, and was wondering if I was mistaken by thinking you never explained how to eventually do matyrix multiplication using the stuff you'd derived?
20:21:00 <benzrf> u swap out products w/ coproducts
20:21:18 <edwardk> Axman6: i got bored =P
20:21:23 <Axman6> D:
20:21:36 <edwardk> :t left'
20:21:37 <lambdabot> Choice p => p a b -> p (Either a c) (Either b c)
20:21:44 <edwardk> that is the workhorse that lets a prism work
20:22:01 <edwardk> there are Choice instances for (->) and many other profunctors
20:22:14 <benzrf> tejing: i believe profunctorially a Lens s t a b is "Strength p => p a b -> p s t"
20:22:16 <edwardk> we have to shove some 'f' in there so that a prism can downgrade to a traversal
20:22:18 <benzrf> er, i might be missing something...
20:22:20 <benzrf> edwardk: is that right?
20:22:29 <edwardk> Strong p => but yes
20:22:31 <benzrf> kk
20:22:41 <benzrf> tejing: so then swap Strong for Choice and u get Prism
20:22:59 <edwardk> we started with (a -> f b) -> s -> f t -- shapes  and then we ran into a problem that shape wasn't good enough to express prism
20:23:09 <edwardk> but we were trapped in some ways by how good it was for lenses and traversals
20:23:12 <tejing> edwardk: what laws is choice expected to follow? might help me figure out what it means (my only category theory knowledge comes form learning haskell pretty much)
20:23:32 <benzrf> oh
20:24:13 <benzrf> tejing: Choice is for Profunctors where you can map them over half of Either
20:24:57 <edwardk> tejing: http://arxiv.org/pdf/0711.1859v1.pdf gives the sort of theoreticaly mumbo jumbo version of things, but you expect it to lift over one side of the Either, just like Strong lets you lift over one side of a (,)
20:25:14 <benzrf> tejing: if a bifunctor lets you map over the left and right arguments with morphisms of the domain category, Choice is for Either in particular for profunctor values rather than morphisms
20:25:17 <benzrf> ^probably horrible
20:25:22 <benzrf> i dont rly know much about profunctors :>
20:25:53 <edwardk> they give a diagram for a "Tambara module" in that paper and that is the diagram everything is expected to support for Choice or Strong
20:26:24 <edwardk> both Strong and Choice describe thing that are tambara modules for different choices of tensor
20:26:29 <edwardk> er describe things
20:26:35 <tejing> benzrf: just got the relationship to bifunctor before you wrote it... it's clicking into place now
20:27:35 <tejing> now I'll take another look at Reviews and see if they start making sense
20:27:39 <edwardk> i we used 'pure profunctor lenses' everywhere (and didn't care about overloading) then we could just name the members of Strong something like _1 and _2
20:27:45 <edwardk> and the members of Choice _Left and _Right
20:28:09 <edwardk> becaus they are the lenses and prisms for those purposes respectively, just not jazzed up enough to work with the lens library
20:28:22 <benzrf> edwardk: might it be sort of correctish to say that Strong and Choice allow (,) and Either to act functory over Profunctor values
20:29:26 <edwardk> benzrf: well you can build notions of 'strength' in the tambara module sense for lots of things. the profunctor code we have builds up a bunch of free constructions and ways to lift such over other profunctors here and there given a profunctor homomorphism from a Strong or Choice or Closed profunctor
20:29:52 <mikewr> if you used both haskell and python can you say how much, in your experience, more lines of haskell code do you have to write to get a functionally equal program?
20:30:11 <Axman6> -50%
20:30:12 <edwardk> i tend to think of Strong/Choice as being about trying to let 'first' and 'second' lift into another rather general domain
20:30:22 <Axman6> would be my guess
20:30:53 <edwardk> i probably write about 35% of the code i used to write in python for equivalent functionality these days, maybe less for fiddly data stuff using lens
20:31:27 <edwardk> then again i'm rarely writing anything in haskell that even can be thought in python so 'equivalent functionality' isn't much ;)
20:31:43 <mikewr> really? I expected it to be the other way around.. interesting
20:32:36 <Axman6> why? Haskell is far more expressive than python for most code
20:33:00 <Axman6> (except possibly highly object oriented code, but no one want to write that anyway)
20:33:08 <saulzar_> Probably you add a few lines for type signatures (but I'd argue they're really valuable for understanding) and often pack more into each line
20:33:37 <Axman6> there are usually many more module imports, but actual code is usually a lot smaller
20:33:41 <mikewr> Axman6: I expected haskell to have more lines because it is statically typed
20:33:47 <edwardk> saulzar_: you spend a fair bit of space setting up nice docstrings telling everyone in plain english how to call the functions you write anyways
20:34:04 <Axman6> static types mean less lines, no need to check the types of objects all the time
20:34:13 <edwardk> mikewr: you can drop the type signatures from all your haskell98 style code and it all still works
20:34:27 <Axman6> edwardk: well _you_ do, at least :P
20:34:31 <edwardk> (modulo a couple of monomorphism restriction things)
20:34:54 <mikewr> Axman6: checking types all the time doesnt seem very python-like
20:35:07 <Axman6> right, that's why python programs are unreliable :P
20:35:12 <edwardk> Axman6: well, i just point out that any sufficiently nice lisp program has an ml program in the comments =) -- that claim generalizes to cover python code =P
20:35:16 <Axman6> I kid, I kid
20:35:29 <Axman6> heh
20:35:55 <mikewr> no you are right. I got my fait share of stupid crashes when I did something as silly as mistyping a variable name
20:36:00 <Axman6> mikewr: why would static types make code longer? static types doesn't mean you need to write all the types, 99% of them are inferred
20:36:32 <edwardk> Axman6: a lot of folks coming to haskell from python have only seen 'static types' in their horrifying java-like incarnations
20:36:33 <Axman6> so you can focus on writing the actual algorithms you're implementing, and let the compiler tell you if you're being an idiot
20:36:42 <edwardk> there they totally do double the amount of crap you have to write
20:36:47 <edwardk> so its an understandable expectation
20:37:12 <Axman6> Whats.Wrong.With.Javas.TypeSystem.FactoryFactoryVisitor?
20:37:22 <edwardk> <T>
20:37:33 <saulzar_> Haha. 
20:37:33 <Axman6> also static final
20:37:52 <saulzar_> objectBuilderReferenceSystemManager 
20:38:13 <mikewr> Axman6: it is not just typing out the types.. you have to write more infrastructure in a statically typed language, while in a dynamically typed you could get away without doing that
20:38:41 <Axman6> initWithData:andDefaults:andOtherShit: - can't forget Obj-C (even if Apple finally are)
20:38:58 <edwardk> AbstractSingletonProxyFactoryBean http://docs.spring.io/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html
20:39:04 <Rotaerk> ..
20:39:20 <dmj`> wow
20:39:29 <Axman6> mikewr: what sort of infrastructure do you mean? static types and a decent type system mean you can write very generic code whioch is also highly reliable
20:39:42 <edwardk> mikewr: you can right up until the problem gets complicated enough that you throw the whole system you built away because you can't maintain it
20:39:58 <edwardk> or you stop touching it because you become afraid of it
20:40:10 * saulzar_ writes lua code for machine learning.
20:40:13 <Axman6> "Convenient proxy factory bean superclass for proxy factory beans that create only singletons." what is this I don't even
20:40:23 <dmj`> the true test of java fluency: http://java.metagno.me/
20:40:24 <edwardk> Axman6: =)
20:40:35 <mikewr> Axman6: well for example I could dump object of any type in a python list that had .Some method and it would just work
20:40:40 <edwardk> ok, i'm going to bed. its almost 6am here
20:41:02 <saulzar_> Pretty sure I break everything else every time I work on anything and spend the next week finding the errors as I run things
20:41:12 <Axman6> mikewr: what's your definition of "work"?
20:41:38 <mikewr> no need to write an interface for it, or whatever is the haskell equivalent
20:41:56 <Axman6> I'm not sure I understand the example
20:42:28 <mikewr> Axman6: what part wasnt clear?
20:42:41 <Axman6> but I think the equivalent would be something like [forall a. Show a => a], for example, if you needed to call show on different types
20:42:56 <Axman6> (which is a list of thingas which are instances of the Show class)
20:43:46 <pacak> The fact that you can drop most of the type signatures doesn't mean you should do that. Type signatures are your friends.
20:44:06 <Axman6> I don't think anyone was actually advocating that
20:44:11 <Axman6> thankfully
20:46:55 <mikewr> Axman6: what if I want to call show, foo and bar functions on all objects in a list?
20:47:40 <Axman6> then you almost certainly want those objects to be the same type. Having discriminated unions makes this not shit, like I imagine it probably is in python
20:48:20 <mikewr> and that is the "extra infrastructure" I was talking about
20:48:42 <Axman6> mikewr: for an example of some Haskell code, I wrote a small JSON based REST API webservice a couple of weeks ago for LambdaJam, have a look at https://github.com/axman6/LambdaJam15-Servant-Lightning-talk/blob/master/Main.hs
20:48:55 <Axman6> I think you overestimate how much extra is necessary to do that
20:49:12 <saulzar_> It saves time in that you don't have to create a data structure for the union type, or a typeclass (e.g. show)... but then it bites you because it's not documented what types are valid
20:50:25 <saulzar_> In Lua I'm continually frustrated that I get errors a long way away from the problem, I have to trace back and work out where the bad parameter was
20:50:45 <dmj`> Axman6: that's beautiful
20:50:46 <dolio> Axman6: Spring is the reason I don't believe when people say that 'normal programmers' can't handle Haskell because of its abstractions and whatnot.
20:51:05 <saulzar_> (Especially if it was stored in a data structure and used later it's a real pain to figure out where this bad parameter came from)
20:51:28 <Axman6> data FoosAndBars = Foo Foo | Bar Bar; xs = [FoosAndBars] <- now we have a list which can hold Foo's and Bar's. the number of times when you genuinely want to hole arbitrary types in a collection topgether are very small - you'll also notice a lot of your python code is written to maintain type inveriants, and will brewak when you start moving beyond your own internal type system
20:52:02 <Axman6> uh, xs :: [FoosAndBars] even
20:52:41 <Axman6> dmj`: works surprisingly well, it's lots of fun to use httpie to interract with
20:54:09 <dmj`> Axman6: for work I'm doing a REST api (using a diff. haskell web server), my routes aren't type safe and often are the bane of my existence.
20:54:35 <Axman6> mikewr: anyway, the point is that the initial overhead is greatly outweighed by the problems which are eliminated later and the vastly increased maintainability of the code later
20:55:40 <Axman6> dmj`: yeah servant is worth checking out, it makes life incredibly nice, especially after the 0.4 release (before that it was very JSON focused but now you can add your own types (ie your own Content-Types) trivially
20:55:40 <dmj`> Axman6: I might switch to servant, so the (:<|>) combinator is at both the type and value level
20:55:59 <Axman6> yeah, it's just data a :<|> b = a :<|> b
20:56:08 <dmj`> Axman6: I'm using swagger and manually updating those docs on each route change, kills me
20:56:15 <dmj`> Axman6: servant auto-gens docs right
20:56:21 <Axman6> it can
20:56:37 <Axman6> it can also autogenerate your client code too, which is super cool
20:57:01 <dmj`> Axman6: is the routing efficient though? Mine isn't type safe, but it's amortized logarithmic (snap-server)
20:57:20 <dmj`> Axman6: can it generate node code?
20:58:22 <Axman6> if you asked for the client of "book" :> Capture "bookid" Int :> Get '[JSON] Book :<|> "book" :> ReqBody '[JSON] Book :> Post '[JSON] (Int,Book) you'd be given bacl two functions with types Int -> IO (Either String Book) and Book -> IO (Either String (Int,Book)) (or something like that, not sure of the Either part)
20:59:00 <Axman6> I believe the routing is being improved at the moment. it's been linear for a long time, but I think there's something in the pipeline to improve it
20:59:02 <mikewr> Axman6: right, so there is an overhead. and the topic was not code reliability. we all know the pros and cons of statically vs dynamically typed languages
20:59:31 <Axman6> you're greatly overstating the overhead though
20:59:43 <Axman6> dmj`: https://github.com/haskell-servant/servant-client
21:00:18 <Axman6> (ah, it's EitherT String IO, but they're isomorphic =)
21:00:37 <dmj`> Axman6: I mean, I don't have too many routes, just 48. 
21:00:50 <dmj`> linear wouldn't kill the app
21:01:18 <Axman6> I'd try it and see
21:01:30 <dmj`> correctness first
21:01:46 <Axman6> exactly
21:01:56 <Axman6> and it'll get faster with later releases
21:02:34 <dmj`> Snap's router has definitely tripped me up at times, that might be my own fault, but routes can be ambiguous at times, and forgetting to put your routes in your route list isn't a type error
21:03:00 <dmj`> but snap 1.0 is fast
21:03:07 <mikewr> actually I am pretty sure I havent expressed how big of an overhead I think it is.. sincr I dont even know. but you, initially, were seemingly implying that there is NO overhead
21:03:55 <Imagine> so I'm trying to do stuff with Rose trees
21:04:03 <Imagine> but adding new nodes seems to be a pain
21:04:07 <Axman6> yeah that's where servant pays off. it con't compile until your API and implementation match. (and it can even fail to compile unless you've documented the whole API too =)
21:05:47 * dmj` drools
21:06:13 <Axman6> dmj`: it also makes changing your routes really easy, either things fail to compile or they'll work at the new routes
21:06:28 <Axman6> and you can make your API modular
21:07:01 <dmj`> Axman6: the nice thing about swagger though is that it actually allows you to interactively ping your api from their docs. 
21:07:05 <Axman6> type API = "comp1" :> Comp1API :<|> "comp2" :> Com2API
21:07:17 <Axman6> what do you mean?
21:07:20 <hodapp> mikewr: Given that I've used Python extensively since circa 2003, my view on this question is that it's pretty irrelevant since in pretty much all situations one doesn't write functionally equal programs in Python, and whether it's even *possible* to write functionally equal programs in those two languages is debatable.
21:07:38 <c_wraith> Imagine: It's probably the case that the easiest way to manipulate Data.Tree is with lens
21:07:49 <Imagine> wait what is the function called that is sorta like a filter in that it returns everything that meets the predicate, but that also returns everything that doesn't meet the predicate
21:07:49 <dmj`> Axman6: I use my routes for testing too with Snap.Test, the types would help internal consistency
21:08:02 <Axman6> right
21:08:10 <Imagine> c_wraith - I'll look at that, thanks!
21:08:11 <c_wraith> Imagine: partition
21:08:15 <Imagine> right
21:08:15 <Imagine> thanks
21:08:21 <hodapp> mikewr: Looking at Haskell code as Python code plus a bunch of extra noise is not a particularly meaningful view.
21:08:27 <dmj`> Axman6: their docs issue AJAX requests to interacively test your webserver
21:08:29 <mikewr> hodapp: why wouldnt it be possible?
21:08:30 <Axman6> there's also safe link creating, which is nice if you need to work with things that don't understand the servant types
21:08:54 <Axman6> dmj`: there's a package to automatically make JS apis based on the types too
21:09:08 <Axman6> you could use that and the docs to do what you're saying
21:09:26 <dmj`> Axman6: where is this
21:09:49 <Axman6> https://hackage.haskell.org/package/servant-jquery (haven't used it myself)
21:10:07 <dmj`> jQuery :/
21:10:16 <mikewr> hodapp: I am not looking at haskell like thay. not sure if you followed entire conversation, but I was asked to explain why my expectations were that a statically typed languages would require more code and infrastructure.
21:10:32 <mikewr> than a dynamically typed one
21:11:01 <dmj`> Axman6: yea
21:11:21 <Axman6> That may be true, to some extent, but I don't see it as a nagative. Haskell programs are often much shorted, despite needing this extra "infrastructure"
21:11:30 <kadoban> Even with type annotations and such, haskell tends to be pretty compact.
21:11:32 <Axman6> shorter*
21:11:40 <hodapp> mikewr: Really, then what does "overhead" refer to? Overhead over *what*?
21:11:51 <kadoban> I'd guess that overall they're quite a bit shorter than python programs … not that that's a useful measure at all.
21:12:06 <Axman6> well, it's one measure of overhead
21:12:42 <dmj`> you can write incorrect code more quickly in python, 1 + "1"
21:12:57 <monochrom> oh! today's xkcd hehe
21:13:09 <Axman6> http://xkcd.com/1537/
21:13:11 <dmj`> monochrom: haha yes :)
21:13:13 <mikewr> hodapp: all the typing infrastructe.. in a dynamicaly typing language you can just mesh things together and make it work (or explode gloriously). see for example my example about a list earlier
21:13:20 <Axman6> heh, my immediate thought too =)
21:13:29 <hodapp> mikewr: As I said: Python code plus noise.
21:13:34 <dmj`> 2+2=done lol
21:13:44 <Axman6> mikewr: but we can also just mesh things together, but only in ways which make sense
21:13:49 <kadoban> NaN.000000013, nice.
21:14:01 <Axman6> the range(" ") one confuses the hell out of me
21:14:43 <mikewr> hodapp: ok, but this isnt specifically about python vs haskell, it is about dynamical vs statical typing
21:14:43 <Axman6> mikewr: haskell is all about composing small parts, and you'll be hard pressed to find a language which does composition as elegantly as haskell
21:15:20 <Axman6> mikewr: you haven't really made an argument for why you think static types have most infrastructure though, and if they do, why it's a bad thing
21:15:21 <funfunctor> is there a function that will take a Int and show me the hex representation in String ?
21:15:23 <hodapp> mikewr: you asked, specifically, about Python and Haskell.
21:15:34 <hodapp> funfunctor: showHex I think
21:15:41 <funfunctor> @hoogle showHex
21:15:42 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
21:15:43 <hodapp> funfunctor: or Text.Printf.printf
21:15:55 <Axman6> > showHex 123456 ""
21:15:56 <lambdabot>  "1e240"
21:16:13 <Axman6> > read $  showHex 123456 "" :: Double
21:16:14 <lambdabot>  1.0e240
21:16:17 <Axman6> >_>
21:16:21 <mikewr> Axman6: it is not necessarily a bad thing, if what you get in return is worth it
21:16:23 <monochrom> remark: 1e240 does not mean 10^240
21:16:54 <Axman6> monochrom: it does in stringly typed languages
21:17:13 <monochrom> yes. another "benefit" of "just mesh things together"
21:18:01 <dmj`> Axman6: w/ REST api's, I feel like all you really need is a ReaderT ConnPools IO a, and type safe router, everything else is kinda noise. 
21:18:27 <monochrom> it is the cause of a PHP issue on mishandling hexadecimal cryptographic hashes because a hex string beginning with "1e" suddenly gets misinterpreted
21:18:44 <Axman6> heh
21:18:47 <Axman6> that's awesome
21:18:48 <monochrom> resulting in much security vulnerability
21:19:14 <kadoban> Wow
21:19:25 <NicX> Are 64-bit libs often an issue when cabal-installing? I'm trying to cabal install zlib but it complains about missing C library: z. However, this library is in my /usr/lib64.  The install also fails with the same message when I try cabal install zlib --extra-lib-dirs=/usr/lib64 .
21:19:44 <Axman6> NicX: do you have the dev version installed?
21:20:06 <NicX> Axman: of z or cabal?
21:20:58 <funfunctor> hodapp: I found the hex package, problem is using (show . hex) bs  gives me all the hex next to one another and its unreadable
21:20:59 <Axman6> zlib
21:21:13 <funfunctor> I need to prefix with ' 0x'
21:22:04 <Axman6> @hoogle atBase
21:22:04 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
21:22:28 <mikewr> btw in the language shootout haskell programs are either the same size as python or 2 to 3 times longer
21:22:31 <Axman6> > showIntAtBase 2 chr 123456
21:22:32 <lambdabot>  <[Char] -> [Char]>
21:22:38 <Axman6> > showIntAtBase 2 chr 123456 ""
21:22:39 <lambdabot>  "\SOH\SOH\SOH\SOH\NUL\NUL\NUL\SOH\NUL\NUL\SOH\NUL\NUL\NUL\NUL\NUL\NUL"
21:22:41 <geekosaur> NicX, if you are on a Red Hat/Fedora type system then you need the -devel version of a library. on a Debian-type then you need the -dev version
21:22:45 <dmj`> mikewr: same size?
21:22:59 <Axman6> > showIntAtBase 2 intToDigit 123456 ""
21:22:59 <mikewr> but they are optimized for performance so that may not be the best indicator
21:23:00 <lambdabot>  "11110001001000000"
21:23:09 <mikewr> dmj same number of lines
21:23:12 <Axman6> > showIntAtBase 1 intToDigit 123 ""
21:23:14 <lambdabot>  "*Exception: Numeric.showIntAtBase: applied to unsupported base 1
21:23:18 <Axman6> :(
21:23:19 <dmj`> mikewr: ah, are you debating learning haskell?
21:23:22 <geekosaur> most of the shootout Haskell programs are fairly old and use all sorts of ugliness to get performance
21:23:32 <funfunctor> > showIntAtBase 16 ord 17 ""
21:23:33 <lambdabot>      Couldn't match type ‘Int’ with ‘Char’
21:23:33 <lambdabot>      Expected type: Int -> Char
21:23:33 <lambdabot>        Actual type: Char -> Int
21:23:47 <mikewr> dmj`: I will learn it
21:23:48 <Axman6> > showIntAtBase 16 intToDigit 123456 ""
21:23:49 <lambdabot>  "1e240"
21:24:17 <joseph07> how come the haskell standard library (or the ghc standard library) doesn't include network utilities?
21:24:28 <Axman6> it does?
21:24:37 <funfunctor> actually I have a bytestring and I want this '0xFF ... 0x12 .. 0x11' sort of string back
21:24:38 <Axman6> what do you think is missing joseph07?
21:24:44 <dmj`> mikewr: haskell's concurrency is good, the GIL is death
21:24:52 <geekosaur> RH/Fedora and Debian/Ubuntu/Mint do not include enough information in runtime library packages for things to be able to link against them, only for things already linked against them to load them at runtime
21:25:19 <mikewr> dmj`: GIL does suck
21:25:40 <joseph07> Axman6: does it? I'm looking at https://downloads.haskell.org/~ghc/latest/docs/html/libraries/
21:25:50 <Axman6> Haskell concurrenct does not. it's actually awesome (not like the "awsome" node.js concurrency >_<)
21:26:02 <joseph07> Axman6: oh I don't think you were talking to me haha
21:26:15 <geekosaur> joseph07, that is not the standard library
21:26:22 <geekosaur> it's the minimal set of stuff needed for the cpompiler itself
21:26:30 <Axman6> joseph07: I was. but that's just the compiler libraries
21:26:42 <geekosaur> http://lambda.haskell.org/platform/doc/current/index.html
21:26:55 <geekosaur> compilers do not normally make network connections
21:27:00 <dmj`> Axman6: how much concurrency can you really have with a single thread :)
21:27:23 <Axman6> ghc ships with HTTP and network libraries usually as well I thought
21:27:26 <pacak> > map (printf "%02x") $ B.unpack "hello"
21:27:28 <lambdabot>      Not in scope: ‘B.unpack’
21:27:28 <lambdabot>      Perhaps you meant one of these:
21:27:28 <lambdabot>        ‘BS.unpack’ (imported from Data.ByteString),
21:27:32 <pacak> > map (printf "%02x") $ BS.unpack "hello"
21:27:33 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
21:27:34 <lambdabot>                  with actual type ‘[Char]’
21:27:34 <lambdabot>      In the first argument of ‘BS.unpack’, namely ‘"hello"’
21:27:34 <geekosaur> Axman6, no, it does not
21:27:40 <Axman6> dmj`: depending on your definition, anywhere from "lots" to "none"
21:27:41 <dmj`> Axman6: that might be haskell platform
21:27:42 <pacak> > map (printf "%02x") $ BS.unpack (BS.pack "hello")
21:27:43 <geekosaur> tjhe Platform does, and cabal-install does
21:27:44 <lambdabot>      Couldn't match type ‘Char’ with ‘Word8’
21:27:44 <lambdabot>      Expected type: [Word8]
21:27:44 <lambdabot>        Actual type: [Char]
21:28:03 <Axman6> maybe it's cabal that bring along HTTP etc
21:28:41 <pacak> > map (printf "%02x") $ BS.unpack $ BS.pack [1,2,3,4]
21:28:42 <lambdabot>      No instance for (Show b0)
21:28:42 <lambdabot>        arising from a use of ‘show_M379251326145287512013802’
21:28:42 <lambdabot>      The type variable ‘b0’ is ambiguous
21:28:48 <geekosaur> cabal-install pulls in HTTP etc.
21:28:52 <joseph07> geekosaur: Axman6: Oh that's the magic
21:28:55 <joseph07> Thanks
21:28:56 <dmj`> Axman6: can QueryParam in servant be optional
21:28:59 <monochrom> I run autotests on my students' Java code. In addition to requiring correct answers, I also require them to finish in time. I use Haskell for the timeout. it is merely using Control.Concurrent.Async.race for two jobs: one job spawns the java runtime and kills it when told to kill, the other job waits for 1 second.
21:29:24 <dmj`> Axman6: or at least let me specify a default
21:29:30 <Axman6> dmj`: I believe it is, I think the function you need to provide takea a Maybe Foo for QueryParam "foo" Foo
21:30:10 <dmj`> Axman6: splendid
21:30:15 <joseph07> I thought perhaps that I'd gotten all those modules from the haskell platform or something, and I'm trying to write something with no dependencies
21:30:18 <joseph07> thanks all
21:30:26 <Axman6> "books" :> QueryParam "author" Text :> Get '[JSON] [Book] ==> Maybe Text -> EitherT ServantErr IO [Book]
21:31:14 <funfunctor> > showHex 16 " 0x"
21:31:15 <lambdabot>  "10 0x"
21:31:28 <funfunctor> :/
21:31:43 <Axman6> so (
21:31:58 <Axman6> ("0x" ++) is also a valid ShowS
21:31:59 <funfunctor> why not prefix the string, weird
21:32:15 <Axman6> ShowS builds up strings from the back (sort of)
21:32:26 <funfunctor> > showHex 17 ("0x" ++)
21:32:27 <lambdabot>      Couldn't match type ‘[Char] -> [Char]’ with ‘[Char]’
21:32:27 <lambdabot>      Expected type: String
21:32:27 <lambdabot>        Actual type: [Char] -> [Char]
21:33:02 <funfunctor> > " 0x" ++ (showHex 17 "")
21:33:03 <lambdabot>  " 0x11"
21:33:04 <ronh-> > "0x" ++ showHex 16 ""
21:33:05 <lambdabot>  "0x10"
21:33:06 <Axman6> ("0x"++) . showHex 12234 . showIntAtBase 2 digitToInt 4 $ "end"
21:33:06 <funfunctor> that sucks
21:33:10 <Axman6> > ("0x"++) . showHex 12234 . showIntAtBase 2 digitToInt 4 $ "end"
21:33:11 <lambdabot>      Couldn't match type ‘Int’ with ‘Char’
21:33:12 <lambdabot>      Expected type: Int -> Char
21:33:12 <lambdabot>        Actual type: Char -> Int
21:33:25 <Axman6> > ("0x"++) . showHex 12234 $ "end"
21:33:27 <lambdabot>  "0x2fcaend"
21:34:12 <Axman6> helps avoid quadratic time string creation
21:37:58 <Axman6> dmj`: the MatrixParam stuff is weird, haven't seen it before
21:39:28 <funfunctor> alright, this is what I am trying to get to typecheck    bsToHexString :: BS.ByteString -> String 
21:39:29 <funfunctor> bsToHexString x = show $ fmap (showHex "") (BS.unpack x)
21:40:24 <dmj`> Axman6: looks advanced
21:40:56 <mikewr> haskell has list comprehensions too..cool
21:41:10 <johnw> it does, but they are strangely not needed much
21:41:12 <mikewr> like python
21:41:14 <johnw> I keep forgetting they exist
21:41:31 <c_wraith> It might be more accurate to say that python has list comprehensions like haskell. :P
21:41:32 <dmj`> mikewr: spoiler... it's the list monad in disguise
21:41:39 <c_wraith> Since Haskell is the older language..
21:41:58 <johnw> one of the original monad papers explains them in terms of generalized list comprehensions
21:41:59 <c_wraith> (They didn't originate in Haskell either)
21:42:20 <johnw> I wonder where the name "comprehensions" came from
21:42:30 <johnw> it's more just an "intensionally described list"
21:42:45 <Sorella> johnw: set theory?
21:43:32 <johnw> ah, yes
21:43:40 <johnw> it stems from the Axiom of comprehension
21:46:13 <octopuscabbage> is there a way to wrap a function which might throw an exception into one that returns either a Maybe a or an Either Exception a
21:46:24 <johnw> "try"
21:46:26 <Axman6> :T try
21:46:30 <Axman6> :t try
21:46:31 <lambdabot> Exception e => IO a -> IO (Either e a)
21:46:37 <funfunctor> @hoogle ByteString -> [Int]
21:46:37 <lambdabot> Data.ByteString findIndices :: (Word8 -> Bool) -> ByteString -> [Int]
21:46:37 <lambdabot> Data.ByteString.Char8 findIndices :: (Char -> Bool) -> ByteString -> [Int]
21:46:37 <lambdabot> Data.ByteString elemIndices :: Word8 -> ByteString -> [Int]
21:46:40 <octopuscabbage> you guys rock
21:46:41 <Axman6> but it can only be done in IO
21:46:47 <octopuscabbage> that's fine
21:46:52 <funfunctor> @hoogle [Word8] -> [Int]
21:46:52 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
21:46:53 <lambdabot> Data.ByteString elemIndices :: Word8 -> ByteString -> [Int]
21:46:53 <lambdabot> Prelude length :: [a] -> Int
21:47:03 <octopuscabbage> is that in Control.Exception?
21:47:12 <Axman6> I believe so
21:47:19 <Axman6> :t tryMaybe
21:47:20 <lambdabot> Not in scope: ‘tryMaybe’
21:47:23 <Axman6> hmm
21:47:33 <Axman6> @hoogle IO a -> IO (Maybe a)
21:47:34 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
21:47:34 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
21:47:34 <lambdabot> Prelude Just :: a -> Maybe a
21:47:36 <octopuscabbage> :t tryJust
21:47:37 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
21:48:17 <Axman6> if you know which exception types you want to catch, then things like catches ar emore useful
21:48:36 <Axman6> try is usually only useful if you use it to produce Either SomeException a
21:48:36 <octopuscabbage> Am I correct in my understanding of the Either monad in that if passed the left constructor it just passes it through and if passed the right constructor it applies the function to the value in the right constructor?
21:48:51 <Axman6> yep
21:48:58 <johnw> octopuscabbage: you should look at the definition of >>= for Either
21:48:59 <Axman6> @src Either (>>=)
21:48:59 <lambdabot> Left  l >>= _ = Left l
21:48:59 <lambdabot> Right r >>= k = k r
21:49:01 <dmj`> :t fromException
21:49:02 <lambdabot> Exception e => SomeException -> Maybe e
21:49:03 <johnw> thank you :)
21:49:17 <Axman6> heh
21:49:20 <octopuscabbage> johnw, didn't know there was a source option for lambdabot
21:49:37 <octopuscabbage> is there a way to run a lambdabot type thing from the commandline so i don't have to spam chat
21:49:38 <Axman6> it only shows some stuff, and somethings it;'s not the actual definitions used
21:49:38 <johnw> i usually go to the source links on Hackage
21:49:47 <johnw> you can /query lambdabot
21:49:54 <johnw> you can even build it locally
21:49:56 <funfunctor> i'm very much confusing myself here:
21:49:56 <funfunctor> bsToHexString :: BS.ByteString -> String 
21:49:56 <funfunctor> bsToHexString x = showHex (map ord (fmap fromIntegral (BS.unpack x))) ""
21:49:57 <Axman6> I think you can also install it locally
21:50:12 <octopuscabbage> I might get around to that eventually
21:50:15 <octopuscabbage> well thanks guys that helped a lot
21:51:10 <Axman6> > concatMap ((" 0x"++) . showHex) (BS.unpack "abcd")
21:51:11 <lambdabot>      Couldn't match type ‘String -> String’ with ‘[Char]’
21:51:12 <lambdabot>      Expected type: Word8 -> [Char]
21:51:12 <lambdabot>        Actual type: Word8 -> ShowS
21:51:40 <Axman6> > concatMap ((" 0x"++) . showIntAtBase 16 intToDigit) (BS.unpack "abcd")
21:51:41 <lambdabot>      Couldn't match type ‘String -> String’ with ‘[Char]’
21:51:42 <lambdabot>      Expected type: Word8 -> [Char]
21:51:42 <lambdabot>        Actual type: Word8 -> ShowS
21:51:44 <Axman6> bah
21:52:06 <funfunctor> Axman6: showHex needs that stupid empty string passed
21:52:16 <Axman6> > concatMap (printf "0x%x") (BS.unpack "abcd")
21:52:17 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
21:52:17 <lambdabot>                  with actual type ‘[Char]’
21:52:17 <lambdabot>      In the first argument of ‘BS.unpack’, namely ‘"abcd"’
21:52:24 <funfunctor> >  concatMap ((" 0x"++) . showHex "") (BS.unpack "abcd")
21:52:26 <lambdabot>      Couldn't match type ‘Word8’ with ‘[Char]’
21:52:26 <lambdabot>      Expected type: [String]
21:52:26 <lambdabot>        Actual type: [Word8]
21:52:38 <Axman6> use flip showHex ""
21:52:44 <Axman6> that ought to do it
21:53:05 <funfunctor>  concatMap ((" 0x"++) . (flip showHex "")) (BS.unpack "abcd")
21:53:14 <funfunctor> > concatMap ((" 0x"++) . (flip showHex "")) (BS.unpack "abcd")
21:53:15 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
21:53:15 <lambdabot>                  with actual type ‘[Char]’
21:53:15 <lambdabot>      In the first argument of ‘BS.unpack’, namely ‘"abcd"’
21:53:19 <funfunctor> ugh
21:53:54 <funfunctor> :t flip
21:53:55 <lambdabot> (a -> b -> c) -> b -> a -> c
21:54:13 <Axman6> it's the unpack that's the problem now
21:54:46 <Axman6> > concatMap ((" 0x"++) . flip showHex "") ([1,2,3,5,24,6,32,4] :: [Word8])
21:54:47 <lambdabot>  " 0x1 0x2 0x3 0x5 0x18 0x6 0x20 0x4"
21:55:02 <funfunctor> ah sweet !
21:55:09 <Axman6> > concatMap (printf "0x%2x") ([1,2,3,5,24,6,32,4] :: [Word8])
21:55:10 <lambdabot>      No instance for (Show b0)
21:55:10 <lambdabot>        arising from a use of ‘show_M676017572769123050614326’
21:55:10 <lambdabot>      The type variable ‘b0’ is ambiguous
21:55:16 <Axman6> > concatMap (printf "0x%2x") ([1,2,3,5,24,6,32,4] :: [Word8]) :: String
21:55:17 <lambdabot>  "0x 10x 20x 30x 50x180x 60x200x 4"
21:55:31 <Axman6> um
21:55:49 <Axman6> > concatMap (printf "0x%.2x") ([1,2,3,5,24,6,32,4] :: [Word8]) :: String
21:55:50 <lambdabot>  "0x010x020x030x050x180x060x200x04"
21:55:58 <Axman6> > concatMap (printf "0x%.2x ") ([1,2,3,5,24,6,32,4] :: [Word8]) :: String
21:55:59 <lambdabot>  "0x01 0x02 0x03 0x05 0x18 0x06 0x20 0x04 "
21:56:07 <Axman6> how's that
21:56:43 <pacak> Welcome to hex string formatting channel?
21:56:51 <Axman6> appologies for all the noise -_-
21:57:37 <felixn> pacak: they just had to get it right, I know that feel
21:57:39 <funfunctor> Axman6: thanks for that !
21:58:02 <mikewr> are type signatures needed there? I thought you could omit them
21:58:02 <funfunctor> where is printf from!?
21:58:14 <Axman6> Text.Printf
21:58:24 <funfunctor> ah
21:58:29 <pacak> felixn: Sure, but if it's not working from the second try - go to privmsgs and try as much as you want to, especially if output is verbose.
21:58:37 <felixn> funfunctor: https://www.haskell.org/hoogle/?hoogle=printf
21:58:48 <felixn> Axman6: teach the human to fish
21:59:00 <Axman6> mikewr: printf uses return type polymoprphism so the compiler can';t know which type you actually meant. the type for the list is there becasue that's what unpack for bytestrings would give us
21:59:37 <funfunctor> felixn: thanks yea I found it, didn't know about printf
21:59:50 <Axman6> pacak: yeah usually I would, but I thought I had it. sleep depreived means I shouldn;t be allowed to lambdabot publicly
21:59:53 <funfunctor> is that not recommended or something?
22:00:24 <funfunctor> wonder if I can upper case the letters in the hex output
22:00:48 <Axman6> use %X
22:00:56 <funfunctor> ah ok
22:00:59 <felixn> funfunctor: you can use > in the chat to try out! :D :D
22:01:41 <funfunctor> felix yep I know but thanks, too much noise already
22:02:07 <felixn> =^_^=
22:02:11 <mikewr> > i like noise
22:02:12 <lambdabot>  Not in scope: ‘noise’
22:02:23 <mikewr> not noisy enough
22:03:27 <c_wraith> > i like noise
22:03:28 <lambdabot>      Ambiguous occurrence ‘i’
22:03:28 <lambdabot>      It could refer to either ‘L.i’, defined at L.hs:150:2
22:03:28 <lambdabot>                            or ‘Debug.SimpleReflect.i’,
22:04:03 <ronh-> > noise
22:04:04 <lambdabot>  Not in scope: ‘noise’
22:05:34 <funfunctor> Axman6: suppose I wanted to adjust it so that it fits within the margin, in C I would do printf("%02x%c", data[i], i == n-1 || i % 32 == 31 ? '\n' : ' ');
22:05:34 <mikewr> is lambdabot running in a sandbox?
22:06:04 <kadoban> More of a litterbox
22:06:50 <Axman6> funfunctor: take a look at the split package, and functions like unlines
22:06:52 <mikewr> lol
22:08:41 <funfunctor> Axman6: thanks
22:09:30 <Axman6> the formatting in Haskell's printf is very similar to C's btw
22:10:08 <Axman6> so you _could_ do something very similar to the C way, but don't :P
22:13:05 <mikewr> so why doesnt this work? [print x | x <- [1..10]]     "No instance for (Show (IO ()) arise from a use of print
22:14:04 <c_wraith> mikewr: it does work.  You just can't print the result of it, which is what ghci tries to do.
22:14:19 <c_wraith> :t [ print x | x <- [1..10] ]
22:14:20 <lambdabot> [IO ()]
22:14:31 <c_wraith> See?  The compiler's just fine with it.
22:14:36 <Axman6> mikewr: you can't do arbitrary IO in haskell code
22:14:41 <DNoved1> > sequence [print x | x <- [1..10]]
22:14:42 <lambdabot>  <IO [()]>
22:14:48 <mikewr> isnt the whole point of calling print to print things?
22:14:53 <c_wraith> no
22:15:01 <c_wraith> print is a function that produces IO values
22:15:14 <c_wraith> *using* IO values is a different matter.
22:15:54 <mikewr> you lost me
22:16:20 <kadoban> mikewr: ghci doesn't know what to do with a /list/ of IO actions. It has no rule for that.
22:16:23 <c_wraith> haskell makes a distinction between describing and performing IO
22:16:26 <Axman6> the difference between execution and evaluation
22:16:59 <Axman6> IO can only be executed by the runtime system, and haskell programs are made up of IO actions (which are values) to produce a program
22:17:29 <Axman6> IO is a description of what you want to do, which the runtime can execute
22:17:33 <mikewr> huh ok
22:18:30 <Axman6> you don't know it yet, but this is hugely helpful in writing reliable programs
22:18:32 <c_wraith> ghci does a bit of magic.  If you provide it an expression that results in an IO value, it executes it.  Otherwise, it just tries to print the value you provided.
22:18:53 <Axman6> (and lambdabot is not the same as GHCi)
22:19:10 <c_wraith> So when you gave it a list of IO values, it tried to print the list...  and then said "hey, I don't know how to print IO values"
22:19:12 <mikewr> print doesnt print, it creates IO? is  that IO like a print call wrapped in a lambda in other languages?
22:20:00 <Axman6> no, it creates a piece of data of type IO (). the runtime knows how to make that value actually perform the action
22:20:01 <c_wraith> It's best to think of IO values as abstract representations of things the computer can do.  :)
22:20:21 <mikewr> but just print 10 does print.. weird
22:20:32 <c_wraith> that's because ghci does magic
22:20:36 <Axman6> in ghci it does, because ghci is special
22:20:46 <c_wraith> it looks at the type of the expression, sees that it's an IO value, and executes it.
22:20:48 <MrWoohoo> What's the best way to install ghc in OS X yosemite? googling seems to lead to conflicting answers
22:21:20 <Axman6> mikewr: I;ve started using https://ghcformacosx.github.io because it's self contained and easy to have multiple versionbs installed and to switch between them
22:21:24 <Axman6> uh, MrWoohoo 
22:21:25 <felixn> MrWoohoo: brew install ghc cabal-install works well for me
22:21:27 <dmj`> MrWoohoo: https://ghcformacosx.github.io/
22:21:39 <dmj`> or use nix
22:21:45 <Axman6> I avoid using homebrew for GHC because it tends to break
22:22:04 <MrWoohoo> whats the deal with brew vs ports? They seem to alternate becoming defunct and resurrected?
22:22:07 <felixn> I used brew because I'm lazy, and it seems to work
22:22:18 <felixn> MrWoohoo: ports is old school, use brew
22:22:39 <mikewr> :t print
22:22:40 <lambdabot> Show a => a -> IO ()
22:22:47 <Axman6> I really like brew for everything else, and it's by far the best package manager for OS X at the moment, but just not for haskell stuff
22:22:53 <jaawerth> speaking of which, I read a blog post today arguing in favor of using distro repository packages over cabal on account of cabal's limitations/not really being a package manager/not really being able to uninstall. is that generally the recommended practice?
22:22:55 <MrWoohoo> I've switched between them at least three times now over the years LOL
22:23:41 <MrWoohoo> what about this page? http://ghcformacosx.github.io 
22:23:41 <dmj`> Axman6: nix on osx isn't bad actually, I've done away with brew
22:23:48 <Axman6> I used to use macports for years, but it just kept getting more and more broken
22:24:04 <jaawerth> still beats cywgin
22:24:06 <funfunctor> Axman6: wonder, I got what I wanted with chunksOf, thakns
22:24:19 <Axman6> funfunctor: good =)
22:25:11 <mikewr> print 10 returns IO as well?
22:25:39 <felixn> does anyone know how to inspect the value of IO?  someone showed me awhile ago here, can't seem to google it
22:25:44 <dmj`> mikewr: print = putStrLn . show
22:25:59 <kadoban> felixn: What do you mean by that?
22:26:22 <Axman6> funfunctor: you mean the a in IO a?
22:26:32 <felixn> kadoban: there is some way to see the value stored in it, it was weird
22:26:43 <mikewr> dmj I cant parse that. I just started messing with haskell half an hour ago
22:26:50 <Axman6> there is no value stored in an IO a
22:27:00 <Axman6> it's an action which when executed produces an a
22:27:10 <kadoban> Yeah … that ^
22:27:18 <dmj`> Axman6: except _|_ :) 
22:27:43 <funfunctor> ?
22:27:45 <dmj`> mikewr: are you familiar with (.) ? function composition?
22:27:47 <Axman6> ok, IO a is a value which when executed, and if it returns a value, returns an a :P
22:27:58 <mikewr> dmj no
22:28:07 <Axman6> @src (.)
22:28:07 <lambdabot> (f . g) x = f (g x)
22:28:24 <Axman6> > (show . (^3)) 7
22:28:25 <lambdabot>  "343"
22:29:36 <Axman6> > (show . (^3) . recip) 7
22:29:38 <lambdabot>  "2.9154518950437313e-3"
22:30:12 <dmj`> mikewr: so f :: a -> b is a function, given an 'a', you get a 'b', f :: a -> (a -> b) -> b, is also a function, but it is a 'higher-order' function, it takes a function as an argument. In the same spirit, z :: (b -> c) -> (a -> b) -> a -> c is a function, a higher order function, and a combinator, since it takes two functions and composes them, returning a new function. Combinators are a powerful way to express computation
22:31:16 <funfunctor> Axman6: btw, this is what I ended up doing https://github.com/victoredwardocallaghan/haskflash/commit/b459a5077803fa07b28f705a8b02183dc6864470
22:32:10 <lamefun> Are there users of Safe Haskell or is it abandoned/dead?
22:32:21 <Axman6> funfunctor: looks good =)
22:33:00 <funfunctor> :)
22:33:03 <dmj`> mikewr: so when we write print = (putStrLn :: String -> IO ()) ((.) :: (b -> c) -> (a -> b) -> a -> c) (show :: Show a => a -> String), we're really just getting a new function print :: Show a => a -> IO (), which is the composition of the two
22:33:31 <Axman6> lamefun: from the questions you've been asking over the last few days, I have a feeling you've been doing a lot of learning haskell by not actually learning haskell :P
22:34:37 <dmj`> mikewr: does that help, or make things worse
22:35:34 <mikewr> I dont think it helped me understand why print 10 prints in ghci and [print x | x <- [1..10]] 
22:35:46 <mikewr> doesnt
22:35:56 <arkeet> mike25: the second one is a list of IO actions.
22:36:14 <felixn> mikewr: so pretend instead, print 10 returns PrintToScreen "10", instead of that weird IO ()
22:36:17 <arkeet> it has type [IO ()]
22:36:18 <dmj`> mikewr: because you haven't gotten to monads yet
22:36:27 <arkeet> so it's just a list.
22:36:37 <arkeet> ghci won't print it because it doesn't know how to print IO actions.
22:36:48 <felixn> mikewr: so it's not actually going to print to your screen, since it's just a value.  it actually has to leave your program, then the runtime catches it and actually puts it on your screen
22:36:51 <lamefun> Axman6, there'd be no reason for me to learn Haskell if the thing I came here for is abandoned or dead.
22:36:57 <arkeet> actually it'll just say there is no Show isntance.
22:37:05 <dmj`> :t sequence_ [ print x | x <- [1..10] ]
22:37:06 <lambdabot> IO ()
22:37:19 <felixn> lambdabot: bad bot!
22:37:20 <dmj`> :t mapM_ print [1..10]
22:37:21 <lambdabot> IO ()
22:37:24 <kadoban> You don't need monads to understand that. You just need "IO a" is an IO action. It does some IO stuff and results in an 'a' when executed. ghci executes IO actions when you give it one. It doesn't know what to do with a list of IO actions though.
22:37:31 <arkeet> sequence_ :: [IO a] -> IO ()
22:37:39 <arkeet> runs all the IO actions in the list in order.
22:37:43 <kadoban> You can create an IO action from that list, yes probably using sequence_ or something.
22:37:45 <Axman6> lamefun: SafeHaskell is definitely used, you'll see annotations in most haddock documentation in the top right, particualrly for highly used packages like containers, text, etc
22:38:11 <Axman6> arkeet: *produces a nerw IO action, which run, executes all those actions
22:38:20 <arkeet> sure.
22:38:46 <dmj`> :t foldr (>>) []
22:38:47 <lambdabot> Foldable t => t [a] -> [b]
22:38:52 <Axman6> which when run*
22:39:00 <mikewr> print returns action. ghci knows what to do witb action, but it doesnt know what to do with a list od actions?
22:39:09 <Axman6> right
22:39:10 <felixn> mikewr: yea!
22:39:54 <Axman6> IO is special in ghci, it understands how to _execute things of type IO a, and how to evaluate and print the result of all other types (which implement Show)
22:40:34 <Axman6> so when ytou write 1+1 in ghci, it basically turns that into print (1+1), and then executes that
22:40:40 <lamefun> Axman6, "I have a feeling you've been doing a lot of learning haskell by not actually learning haskell" - why?
22:40:42 <felixn> mikewr: haskell is super strict like that by design, if you gave it a list of IO, how does it know if you want to run it in sequence, or parallel?  you have to tell it
22:40:59 <arkeet> maybe you don't want to run them at all !
22:41:10 <Axman6> lamefun: you've been asking lots of questions about often obscure features, but nothing about learning the language itself
22:41:44 <LazyHaskeller>  Is there a haskell video training which is good? 
22:41:51 <felixn> Axman6: hey man, he has to be haskell, before he can become one with haskell
22:42:27 <kadoban> LazyHaskeller: Doubtful
22:44:25 <dmj`> mikewr: the list monad is pure, you can't perform I/O actions in it... but you can store I/O actions in it.. you have a [IO ()], but you need to go to IO [()], this is where sequence helps you. 
22:44:31 <dmj`> :t sequence
22:44:32 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
22:44:58 <dmj`> :t sequence ([ print 4 ] :: [IO ()]) 
22:44:59 <lambdabot> IO [()]
22:45:05 <mikewr> dmj what is a list monad?
22:45:12 <felixn> LazyHaskeller: http://www.infoq.com/presentations/Simple-Made-Easy <-- not haskell, but this might get you really pumped up to write awesome functional code.  http://www.infoq.com/presentations/datomic-functional-database <-- this one is good too, his "stateless" db
22:45:21 <dmj`> mikewr: a context of non-deterministic computation
22:47:20 <LazyHaskeller> Thaks felixn. 
22:49:48 <Axman6> mikewr: it's an easy way to chain together computations which might return multiple restuls. you can take functions of type (a -> [b]) and (b -> [c]) and produce a function a -> [c] which is the result of applying the second function to all results from the first.
22:49:55 <mikewr> so is [print x | x <- list] code under the hood similar to [lambda x: print x for ..]? we are not printing directly, but deferring it
22:50:04 <lamefun> Axman6, what obscure features?
22:50:55 <Axman6> well, SafeHaskell for one. Can't remember the others, but they've mostly all struct me as off questions
22:51:14 <dmj`> > do { x <- [1..10]; guard (x>3); return x; } == [ x | x <- [1..10], x > 3]
22:51:15 <lambdabot>  True
22:51:22 <Axman6> I guess everyone learns their own way, so keep going, I just thought it was odd =)
22:52:06 <mikewr> I dont actually know what (a -> [b]) means. I installed ghc an hour ago
22:52:28 <arkeet> that's the type of functions from a to [b]
22:52:32 <Axman6> > do {x <- [1..10]; y <- [x..10]; x <- [y..10]; x*x+y*y == z*z; return (x,y,z)}
22:52:33 <lambdabot>      Couldn't match expected type ‘[a0]’ with actual type ‘Bool’
22:52:34 <lambdabot>      In a stmt of a 'do' block: x * x + y * y == z * z
22:52:34 <lambdabot>      In the expression:
22:52:36 <arkeet> [b] is the type of lists of b
22:52:48 <dmj`> mikewr: are you familiar with polymorphism
22:52:48 <Axman6> > do {x <- [1..10]; y <- [x..10]; x <- [y..10]; guard $ x*x+y*y == z*z; return (x,y,z)}
22:52:49 <lambdabot>  []
22:53:01 <mikewr> dmj yes
22:53:06 <Axman6> > do {x <- [1..10]; y <- [x..10]; x <- [y..10]; guard $ x*x ==y*y + z*z; return (x,y,z)}
22:53:07 <lambdabot>  []
22:53:10 <Axman6> bleh
22:53:29 <LazyHaskeller> Programming in Haskell Graham Hutton; Is there a reason not to watch Erik Meijer's video lecturs using that book?
22:54:07 <LazyHaskeller> watch Erik Meijer's video lecturs using that book? 
22:54:07 <LazyHaskeller> <LazyHaskeller> http://channel9.msdn.com/Series/C9-Lectures-Erik-Meije r-Functional-Programming-Fundamentals/Lecture-Series-Erik-Meijer-Fu nctional-Programming-Fundamentals-Chapter-1
22:54:17 <dmj`> mikewr: https://github.com/bitemyapp/learnhaskell
22:55:20 <mikewr> I was also recommended learn you a haskell for greater good
22:55:48 <dmj`> mikewr: I'd do that one first, the sooner you can make it to the typeclassopedia the better
22:56:02 <arkeet> what one first?
22:56:13 <dmj`> lyah and cis194 prob
22:56:13 <LazyHaskeller> arkeet: PENN university 
22:56:25 <LazyHaskeller> cis194 probably. 
22:56:55 <LazyHaskeller> I keep trying to do learn haskell and get distracted over and over. 
22:57:42 <arkeet> bitemyapp doesn't like LYAH very much.
22:58:08 <felixn> LazyHaskeller: just start building something.  do you read the instructions when building furniture?  of course not! :D
22:58:16 <arkeet> it's a cute book and it was one of the better resources when it came out, I tihnk.
22:58:25 <arkeet> felixn: I do... 
22:58:43 <dmj`> arkeet: how has it bit-rotted
22:58:51 <felixn> arkeet: well, lucky me because I always have spare parts
22:59:01 <lamefun> Axman6, well, the code I've written so far (version patterns in form "1.2.3-alpha.1 || (3.x && <=3.2.1)") works. Why should I be asking questions if my code works?
22:59:01 <arkeet> http://bitemyapp.com/posts/2014-12-31-functional-education.html
22:59:41 <arkeet> explains what he does and doesn't like about LYAH (and a bunch of other resources)
22:59:45 <LazyHaskeller> felixn: my brain will explode :) The trouble I want to do everything at once :)
22:59:56 <Axman6> lamefun: I was under the impression you hadn't written anything yet. I guess I was mistaken so I apologise =)
23:01:54 <felixn> LazyHaskeller: http://i.imgur.com/QKIfg.gif <-- but that's what's suppose to happen when you finally understand something
23:02:56 <LazyHaskeller> felixn lol!
23:03:56 <felixn> LazyHaskeller: what do you want to make?
23:04:30 <eds> can someone help me with pattern matching? http://lpaste.net/132328
23:04:39 <eds> Under myFitness function.
23:05:56 <LazyHaskeller> felixn: Retrive a piece of text from a webpage; analyze the text; verify if the text follows certain rule sets; store specific parts of the text in different places in a database ( a file will do for now). That's where I want to start. 
23:06:19 <peddie> eds: you don't have to list the function name and arguments more than once if you use '|' (guards)
23:08:03 <peddie> eds: you have to say it once before the first |, and then subsequent | cases don't need it
23:08:23 <felixn> LazyHaskeller: that sounds fun and a great project to start with.  just start doing it, and ask here if you get stuck
23:09:12 <eds>  Will make those changes. Also my question here is, how do I define isInt e here ? isInt needs to check if it is Arith and List
23:09:41 <LazyHaskeller> felixn: will do, thanks :)
23:09:52 <peddie> eds: oops, I think I misread, you also can't give a pattern match like you've done with isBool
23:10:19 <eds> yes. It gave me that error. I am trying to figure that out.
23:10:29 <eds> If you could guide me
23:10:30 <peddie> you don't need guards here
23:11:00 <Axman6> eds: isInt e = e@(Arith c e1 e2) doesn;t make any sense; x@y can only be used in a pattern match, you're using it to create a value (I think)
23:11:16 <LazyHaskeller> Let me ask a different question. 
23:11:19 <peddie> you can simply put that pattern in place of the 'e' in 'myFitness n e', so 'myFitness n (Comp c e1 e2) = . . .'
23:11:30 <LazyHaskeller> Is there a good book for the mathematics behind Haskell? 
23:12:00 <LazyHaskeller> I was watching eric meijer. I have studied fog(x) f.g(x) and stuff. 
23:12:06 <LazyHaskeller> Can't remember where. 
23:12:13 <eds> oh ok. I need myFitness n (Logic c e) to do the same operations as myFitness n (Comp c e1 e2). How would I do that?
23:12:22 <Axman6> eds: how's isInt (Arith _ _ _) = True; isInt (List _ _) = True; isInt _ = False
23:12:23 <peddie> then if it's not a Comp, you can have additional cases, where you _will_ need to say the function name and arguments again, like 'myFitness n (Logic c e)'
23:14:09 <peddie> eds: I see, if you have two cases that do the same thing, you can either write it twice or come up with some way to use guards (meaning no patterns), like 'isLogic (Logic _ _ _) = True; isComp (Comp _ _ _) = True; isComp _ = False'
23:14:19 <eds> ahh. just write the same operations over again. my bad Axman. I just want Arith _ _ _ and List _ _ to do same operations. so I was trying to find a way to make isInt hit true only when it is Arith and List and do those set of operations.
23:14:21 <peddie> oops, I forgot 'isLogic _ = False'
23:14:38 <hasket> LazyHaskeller: Any category theory book will do. I like http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf
23:14:42 <Axman6> eds: that's what my function does?
23:15:09 <eds> ahh that is what I needed peddie. Let me try that.
23:15:20 <eds> yes axman.
23:15:58 <peddie> eds: with those helper functions, you could use guards like '| isLogic e || isComp e = <do some stuff>'
23:16:19 <peddie> eds: or even just 'if isLogic e || isComp e then <do some stuff> else <something else>'
23:16:45 <LazyHaskeller> thanks hasket. I am better at the abstract rather than the practical. So, if someone could just write a book that does mathematics, then hakell I might learn faster ... 
23:17:02 <lamefun> Axman6, I noticed the annotations, but I thought that maybe they're just for backwards compatibility and SafeHaskell was born dead.
23:17:42 <hasket> LazyHaskeller there's no specific book to category theory -> haskell, but reading about category theory first then learning haskell will only help
23:19:24 <LazyHaskeller> Thanks hasket, the book is great. 
23:20:17 <eds> That seems like a good idea.
23:20:36 <hasket> LazyHaskeller: I also love this presentation http://yogsototh.github.io/Category-Theory-Presentation/
23:21:09 <eds> this is what I tried with guards. But parse error. Here it is :http://lpaste.net/132328
23:22:41 <peddie> eds: can you put the parse error in a comment in the paste or something?
23:22:47 <_slade_> eds: Line 66?
23:23:04 <eds> Line 62
23:23:18 <eds> I'll do that
23:24:31 <unknownloner> Not directly haskell related, but any languages with a REPL that are good for vector operations?
23:24:32 <peddie> eds, I think you have to either use one 'where' block for the whole function or indent the sub-blocks a bunch so it knows the 'where' block is just for that guard expression
23:24:35 <LazyHaskeller> hasket perfect. 
23:24:43 <unknownloner> like more compact
23:24:50 <unknownloner> like APL without the need for a custom keyboard
23:25:11 <Axman6> julia perhaps?
23:25:14 <peddie> unknownloner: haskell, python, gnu octave?
23:25:16 <arkeet> matlab? :--)
23:25:17 <unknownloner> I wanna type (x1, y1) - (x2, y2) and have it return (x1 - x2, y1 - y2)
23:25:23 <unknownloner> or something to that extent
23:25:39 <small-wolf> unknownloner: like J?
23:25:40 <peddie> unknownloner: "instance Num a => (a, a) where . . . "
23:25:49 <unknownloner> ok but now I have to do that myself ^
23:25:58 <unknownloner> I want it built in for everything :P
23:26:06 <unknownloner> never heard of J
23:26:09 <hasket> unknownloner: You're looking for matlab or julia
23:26:16 <eds> ok so indent it. i'll try that
23:26:25 <lamefun> Axman6, I mean, there doesn't seem to be much demand for this kind of sandboxing... Unvanquished game for example sandboxes C++ with Google PNaCl, but it doesn't have public API and you have to figure everything out by yourself.
23:26:33 <small-wolf> J is like an asciified version of APL, but with a more extensive concept of rank
23:26:45 <eds> peddie
23:26:52 <small-wolf> it's fun for about a week, then you start to miss actual programming languages
23:26:58 <unknownloner> haha
23:27:04 <peddie> eds: yep, that's right :)
23:27:10 <small-wolf> if you try to do any string processing at all you'll cry
23:27:16 <unknownloner> well I don't need actual programming languages, just something on the side to do some simple vector math stuff
23:27:22 <unknownloner> so I'll check it out
23:28:15 <unknownloner> small-wolf: happen to know what the package name would be on linux off the top of your head?
23:28:36 <unknownloner> Arch specifically though usually it's pretty standard across platforms
23:28:37 <small-wolf> http://jsoftware.com/
23:28:37 <Axman6> lamefun: I'm not sure how much need there is in the community, which is probably why no one talks about it. a lot of the safety people are after is provided by the type system and people trust others enough to not stuck unsafePerformIO (system "rm -rf /") in their code. SafeHaskell, afaiu, means you don't need to assume, things aren't marked safe unless they've been checked for safety
23:28:53 <small-wolf> you use arch? check yaourt
23:29:38 <small-wolf> J is nowhere near popular enough to have a dedicated package.
23:29:48 <unknownloner> yeah I figured that'd be the case
23:29:49 <small-wolf> in like the standard repository
23:30:06 <unknownloner> only thing on the AUR is an emacs mode for it :P
23:30:15 <unknownloner> w/e I'll get it myself
23:30:24 <small-wolf> hey emacs modes are important
23:32:25 <Axman6> woah... watching Apple WWDC talk on using value types in Swift... and they're using Haskell to demonstrate ideas :o
23:32:50 <Axman6> (there was also a rather large applause when he said he'd use Haskell)
23:39:06 <LazyHaskeller> http://haskellbook.com/progress.html
23:39:18 <LazyHaskeller> Is this worth buying? 
23:39:24 <LazyHaskeller> Early access to?
23:39:36 <Axman6> ask bitemyapp 
23:41:13 <LazyHaskeller> Chris Copeland em, wonder if he still teaches Haskell. 
23:45:27 <LazyHaskeller> Axman6 is bitemyapp on #haskell?
23:46:04 <Axman6> apparently, he may be asleep
