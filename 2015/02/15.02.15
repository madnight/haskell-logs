00:00:27 <jle`> EvanR: what kind of behavior do you want?
00:00:31 <EvanR> either or
00:01:01 <jle`> is this the Gen from quickcheck?
00:01:08 <EvanR> yeah, its not an instance of any of those classes
00:01:36 <EvanR> using oneof
00:01:36 <jle`> a Gen a is supposed to create a random item of `a`, right
00:01:43 <EvanR> yeah
00:02:45 <jle`> so what would a (x :: Gen Int) <|> (y :: Gen Int) do?
00:02:51 <jle`> it'd be a new Gen Int
00:03:12 <EvanR> yeah, it would give you a random Int
00:03:30 <jle`> from x, or from y?
00:03:34 <EvanR> yeah
00:03:37 <jle`> what would the <|>/<> be doing?
00:03:40 <jle`> oh, one or the other
00:03:43 <jle`> like `choice` ?
00:03:45 <EvanR> yeah
00:03:59 <jle`> like, flip a coin, and pick x or y?
00:04:06 <EvanR> could be implemented as oneof [x,y]
00:04:12 <EvanR> which works
00:06:02 <jle`> i see
00:06:22 <EvanR> could be im missing a law or something
00:07:05 <EvanR> (and why is it oneof but also listOf ;)
00:07:39 <moldy> hi
00:10:18 * hackagebot paypal-adaptive-hoops 0.8.0.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.8.0.0 (fanjam)
00:10:18 * hackagebot hjsonschema 0.3.0.0 - Haskell implementation of JSON Schema v4.  http://hackage.haskell.org/package/hjsonschema-0.3.0.0 (seagreen)
00:11:24 <breadmonster> Hey, is the ghc commentary up to date?
00:11:28 <breadmonster> Specifically, this: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/NCG/RegisterAllocator
00:22:27 <yac> how can I fmap an f :: IO a ?
00:22:52 <shachaf> What does that mean?
00:23:37 <blackdog> > :t (\x -> x ++ x) `fmap` getLine
00:23:38 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
00:23:42 <yac> I have a function f :: a -> IO b
00:23:48 <blackdog> dammit :) never get that right
00:24:02 <yac> and I'd like to fmap it over Either e a
00:24:11 <jle`> yac: what would your result type be?
00:24:19 <jle`> IO (Either e b) ?
00:24:25 <yac> yes
00:24:26 <jle`> or Either e (IO b)
00:24:33 <yac> IO (Either e b)
00:24:35 <jle`> ah. that sounds like mapM
00:24:51 <jle`> from Data.Traversable
00:25:18 <jle`> or sequence . fmap f
00:25:58 <jle`> (sequence from Data.Traversable)
00:26:05 <jle`> would turn an Either e (IO b) into an IO (Either e b)
00:27:28 <nshepperd> > traverse putStr (Right "abc" :: Either Int String)
00:27:29 <lambdabot>  <IO (Either Int ())>
00:27:48 <yac> cool, looks like it's working
00:27:52 <yac> but I have another error there
00:28:02 <jle`> traverse works too, which is just mapM that works for any Applicative f => (a -> f b)
00:28:18 <yac> woohoo, I had an impression that Data.Traversable is used by pros :)
00:28:26 <jle`> haha not really
00:28:53 <jle`> anyone who understands mapM, sequence, etc. can understand Data.Traversable
00:28:56 <nshepperd> 'traverse' is my favourite function
00:28:57 <blackdog> jle`: i have this terrible habit of using mapM & map out of habit
00:29:04 <blackdog> trying to break myself out of it
00:29:06 <solatis> hmmm anybody knows of any haskell projects that do a lot of synchronous protocol parsing? as in, client sends A, servers responds with A', client parses A', sends B, server responds with B', client parser B'.. etc
00:29:19 <solatis> i am really struggling on how to capture that interaction elegantly
00:29:57 <solatis> i am almost thinking about some sort of state machine
00:30:31 <yac> solatis: parsec?
00:30:41 <solatis> parsec can deal with sockets?
00:30:56 <yac> why would it?
00:31:11 <solatis> i don't know, i don't want to be bothered with handling the buffers by hand
00:31:16 <yac> Buffer some xs and try to parse them like anywhere else?
00:31:31 <blackdog> http://stackoverflow.com/questions/15752243/incremental-parsing-from-handle-in-haskell might help
00:31:43 <solatis> let's look at that
00:31:43 <blackdog> but you might have to use attoparsec instead
00:31:55 <solatis> i'm already using attoparsec in my first clunky code
00:32:31 <solatis> right, guess i need to look at incremental parsing
00:32:40 <nshepperd> solatis: parsecT IO?
00:33:15 <solidus-river> anyone else having trouble getting enclosed-exceptions 1.0.1 to install?
00:33:34 <yac> looks like Either is not an instance of Traversable
00:33:47 <solatis> nshepperd, also looks interesting
00:34:43 <yac> oh wait, it's something weird. That Either has only one parameter
00:35:24 <nshepperd> if you can implement a Stream instance for your socket, you can pass it to runParserT just like an ordinary String, and not even have to worry about incremental parsing
00:35:36 <forgottenone> whenever i crate a new data type with newtype, how can i use the typeclasses of inherited(i dont know if it's the right word) type?
00:35:48 <solatis> hmm but how does one create the 'flow' of request/responses in such case then?
00:36:13 <solatis> i'm sorry if i am asking dumb questions, i am having trouble wrapping my head around how to do it elegantly
00:36:57 <solatis> i'm using a Network.Socket, in case that matters
00:37:27 <solatis> which has a getContents, which returns a lazy bytestring (which is similar to a stream?)
00:38:37 <nshepperd> I imagine it would look something like 'loop = parseOneMessage >>= (\msg -> do some IO stuff including maybe send a message in reply) >> loop'
00:39:11 <blackdog> solatis: i don't think you want to use getContents
00:39:24 <blackdog> the way incremental parsing works, you read it a chunk at a time
00:39:29 <solatis> right
00:39:45 <blackdog> and the parser then says "hey, i need some more" or "this is broken" or "ok, i'm done"
00:39:49 <solatis> i think i'm going for attoparsec's incremental interface
00:40:20 <solatis> it has a nice continuation-based interface
00:40:29 <blackdog> which means you have better control over memory - if you use a lazy bytestring, it's hard to be sure that all references to the head of the string are let go at the right time.
00:40:46 <solatis> right
00:40:47 <blackdog> (lazy io is just evil and confusing in general really)
00:41:01 <solatis> yeah, and socket errors suddenly happen at totally different places :)
00:41:12 <solatis> i understand why lazy io is evil
00:41:19 <nshepperd> for ParsecT you would implement the Stream interface which just has a function uncons :: s -> m (Maybe (t, s))
00:41:48 <nshepperd> in your case, Socket -> IO (Maybe (Char, Socket))
00:42:03 <solatis> right
00:42:06 <yac> add an instance declaration for (Traversable (Either ParseException))
00:42:10 <yac> what does this mean?
00:42:22 <nshepperd> which is nothing but getChar wrapped up nicely, I think
00:42:27 <shachaf> That's not the error message, it's the "possible fix".
00:42:32 <solatis> i think i'm going to search github a lot to see how other people solved this problem
00:42:41 <yac> I tried instance Traversable (Either ParseException) but that gives even weirder error
00:42:50 <shachaf> If you're asking for help with an error message, you should post the full error message (and the code it refers to).
00:42:51 <nshepperd> and then runParserT handles the rest of it for you
00:43:43 <solatis> nshepperd, thanks, but i feel like attoparsec is the most intuitive for me at the moment, the API seems a little more easy to grasp (i'm still haskell noob)
00:43:58 <yac> shachaf: https://gist.github.com/yaccz/b93cfd169d59bc00ace6
00:44:37 <shachaf> yac: OK. There's no instance for Traversable (Either e). It was added in a later version of GHC, so you could upgrade GHC or define the instance yourself or get an orphan instance from a standard place.
00:45:11 <yac> shachaf: oh, standard place?
00:45:24 <shachaf> Well, lens has it. But that's a big dependency for such a small instance.
00:45:39 <yac> well I could just copy the instance from Data.Traversable, right?
00:45:45 <shachaf> So I would say that for a small program either define it yourself or upgrade GHC.
00:46:09 <yac> right, thanks
01:14:40 <EvanR> wow... arbitrary produced a gigantic tree
01:14:47 <EvanR> well im not sure if its infinite
01:16:22 <dramforever> I think it's not
01:16:31 <EvanR> i had to cancel it
01:16:31 <dramforever> afaik it doesn't tie knots
01:17:59 <jle`> EvanR: depending on your instance, your size might grow by 2^n
01:19:06 <EvanR> jle`: where n is?
01:19:41 <dramforever> jle`: where "grow" means?
01:20:36 <EvanR> it happened again...
01:20:51 <EvanR> if i was trying to run a test i would not know why it froze
01:21:15 <dramforever> EvanR: Are you using windows? The command line window in windows is *very* slow
01:21:22 <EvanR> iterm2
01:21:40 <wz1000> Does FTP introduce breaking changes?
01:21:41 <EvanR> its quite quickly producing way more than my buffer
01:21:56 <dramforever> hmm...do you have a length-like function for your tree?
01:22:13 <dramforever> can you try applying that on the tree to see how big it really is?
01:22:48 <EvanR> well i could make one
01:23:41 <EvanR> what should it do, count the things?
01:24:23 <yac> mapM_ (addFile c . (\x-> cwd </> normalise x)) xs
01:24:27 <yac> how can I remove the lambda?
01:24:39 <dramforever> maybe count the nodes? like len (Node a b) = 1 + len a + len b; len (Leaf _) = 1
01:24:51 <dramforever> yac: try this:
01:24:58 <dramforever> @pl (\x-> cwd </> normalise x)
01:24:58 <lambdabot> (cwd </>) . normalise
01:25:12 <EvanR> yeah itll take me a while to implement this for all the kinds of nodes
01:25:28 <dramforever> EvanR: oh maybe that's too much effort
01:25:51 <EvanR> i can get a file size of the output
01:26:03 <yac> oh, right. Thanks dramforever
01:26:06 <dramforever> length (show tree) is also good
01:26:55 <EvanR> alright im trying that first
01:27:04 <dramforever> yac: remember not to golf your code. if it gets too complex nobody will appreciate
01:27:04 <EvanR> waiting
01:27:10 <srhb> wz1000: Very little.
01:27:47 <srhb> wz1000: Most of the changes will be in error messages on type errors, really.
01:27:59 <EvanR> ghc 102%
01:28:50 <dramforever> EvanR: you have many types of internal (non leaf) nodes?
01:28:58 <EvanR> yeah
01:30:13 <EvanR> i canceled and am not writing to a file instead
01:30:14 <dramforever> EvanR: maybe you did it like this: choice [internal_node1, in2, in3, in4, in5, leaf]
01:30:16 <EvanR> now*
01:30:39 <wz1000> srhb: I can't think of any case where the changes would make existing code refuse to compile.
01:30:41 <EvanR> i did oneof [pure A, pure B, C <$> arbitrary]
01:30:49 <narendraj9> cabal install lambdabot doesn't work. First I got an error about Network.URI, after https://github.com/mokus0/lambdabot/issues/90  I am an error while compiling again. Any easy fix for getting it installed? [Compiling again will post the error once it reaches there.]
01:30:53 <dramforever> that could be the problem: maybe you are not generating enough leaves
01:31:18 <EvanR> very interesting
01:31:32 <EvanR> 327M file so far ;)
01:31:46 <srhb> wz1000: Colliding exports.
01:32:58 <dramforever> EvanR: maybe stop it
01:33:07 <EvanR> did
01:33:11 <EvanR> at 456M
01:33:34 <EvanR> crap its all on one line and i opened it in vim
01:33:52 <dramforever> try line wrapping?
01:34:07 <EvanR> theres no point i know what it looks like generally
01:36:08 <dramforever> EvanR: did it generate leafs?
01:36:27 <EvanR> yes i see leaves in the output
01:36:36 <dramforever> how often?
01:36:41 <dramforever> maybe make it more often?
01:36:53 <EvanR> heres one thing
01:37:07 <EvanR> one possible node is a list of nodes
01:37:20 <EvanR> maybe the listOf combinator is producing a very large list
01:37:48 <dramforever> with a very low possibility of generating empty lists
01:37:48 <dramforever> perhaps
01:38:05 <dramforever> maybe try oneOf [emptyList, somethingElse]
01:38:18 <EvanR> well that one option out of 20 for that level
01:38:20 <EvanR> a list
01:38:26 <EvanR> empty should not really be allowed there
01:38:45 <dramforever> anyway...try generating more leaves
01:39:10 <EvanR> is there an easy way to control the probability
01:41:02 <dramforever> how about generating a Double (or Rational) within [0, 1] and if thatNumber < prob then yes else nope
01:41:13 <EvanR> thats fine for two choices
01:41:42 <EvanR> ill try adjusting the list length first, which is often 26 to 30
01:41:54 <EvanR> which is really too much for examples of my type
01:43:17 <dramforever> use a guard? | a < p1 = x1; | a < p1 + p2 = x2; .... ; | otherwise = blah
01:44:41 <EvanR> resizing to 3 or less didnt work
01:44:49 * EvanR continuing on
01:49:13 <EvanR> dramforever: i figured it out
01:49:26 <dramforever> yes?
01:49:45 * dramforever is interested, although it's nothing to do with him
01:50:16 <EvanR> near the top of my tree i have two options, data Sentence = Sentence Boring | IfThen Sentence Sentence
01:50:32 <EvanR> and i was choosing 50/50
01:50:41 <EvanR> so i guess i was blowing up about half the time
01:51:01 <EvanR> i adjusted it to pick IfThen on p < 0.2 and it doesnt blow up
01:51:49 <dramforever> oh glad you figured it out
01:52:33 <EvanR> ["Please answer","the previous statement","did at some point in the past","has","Mass","how much","GeV"]
01:52:45 <EvanR> yay
01:53:53 <dramforever> You are trying a logical language?
01:54:09 <EvanR> its turning into that
01:54:16 <dramforever> oh good
01:55:48 <EvanR> i put some types on the kinds of syntax you can use, and then it turned into needed yet another type system on top of that for it to make sense
01:56:28 <EvanR> like the arbitrary instance will create questions that dont contain question words, or will have a question with multiple missing parts instead of one
01:56:53 <EvanR> or a command with question words
02:06:03 <EvanR> dramforever: also i just realized there is a version of oneof like [(Int, Gen a)] -> Gen a, where you specify the weights
02:06:49 <EvanR> ["Is it so","quote(","very","not","not","Valuable",")unquote","may/might","habitually","suffer system failure"]
02:07:46 <dramforever> EvanR: oh good to know
02:15:15 <ddellacosta> is a list comprehension the best way to do something that is like combining a filter + fold?
02:15:44 <ddellacosta> where "best" means, perhaps, most idiomatically Haskell-y, without taking, say, efficiency into account
02:16:25 <shachaf> A list comprehension doesn't do anything like a fold.
02:16:39 <shachaf> Unless you mean concat, I suppose.
02:22:12 <ddellacosta> shachaf: I guess I'm offbase there then, or maybe I was more thinking of a map...but really what I want is a filter + applying a function after I filter
02:22:34 <ddellacosta> shachaf: and right now I'm first doing a filter, then applying a map to the result of that.  Seems wasteful.
02:22:42 <shachaf> Which part is wasteful?
02:23:51 <ddellacosta> shachaf: well, since I'm already iterating over each value during the filter, seems redundant to do it again.  I guess I can fake it with a fold where I simply ignore the values not matching a predicate, but was wondering if there was a more "Haskell-y" way to do it
02:24:17 <shachaf> You just said you weren't taking efficiency into account.
02:24:24 <ddellacosta> shachaf: ha, fair enough. :-)
02:24:31 <shachaf> You can expect GHC to fuse map f . filter p
02:24:37 <ddellacosta> I guess I certainly was, my bad
02:24:50 <ddellacosta> shachaf: ah, gotcha
02:25:14 <ddellacosta> shachaf: any tips on where/how I can learn more about GHC's behavior there?
02:25:27 <ddellacosta> sorry, realize that's probably quite an open-ended question
02:26:06 <shachaf> You can look at the generated code.
02:26:18 <shachaf> @google ghc fusion
02:26:19 <lambdabot> https://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html
02:26:39 <ddellacosta> shachaf: great, thank you
02:26:43 <shachaf> You can read that, though maybe it goes into more detail than you need.
02:27:07 <ddellacosta> shachaf: sure, just want to get a sense of where to start understanding this stuff
02:27:56 <shachaf> $ echo 'module Foo where { foo :: [Int] -> [Int]; foo xs = map (*10) (filter even xs) }' > Foo.hs; ghc -O2 Foo.hs -ddump-simpl -dsuppress-all
02:28:10 <shachaf> You can look at that to see what your code is turning into.
02:28:30 <ddellacosta> shachaf: oh that's great, thanks
02:29:03 <dramforever> Question: Why does Data.Sequence.Sequence support amortized O(1) cons/uncons even in a persistent setting while data DoubleList a = DoubleList [a] [a] does not?
02:31:31 <Haskellfant> dramforever: Sequence doesn't use two lists internallly but instead uses finger trees (don't ask me how exactly they work, that paper is still on my reading list)
02:32:01 <dramforever> I mean, if operation O runs slowly on version X, then if I keep running O on X then it won't be O(1) amortized
02:32:21 <dramforever> I'm not really getting what "persistent setting" means here
02:32:44 <Haskellfant> I would take that as meaning the usual immutabilitystuff we have in haskell
02:33:24 <Haskellfant> which means that if you have a list and map over it or something like that your old reference still contains the old list
02:33:31 <dramforever> yes
02:33:41 <dramforever> but how is Sequence better?
02:34:16 <Haskellfant> sorry, I don't understand your question
02:34:30 <Saizan> dramforever: it's implemented more like a tree
02:34:35 <Cale> dramforever: Because of lazy evaluation
02:34:45 <dramforever> Cale: oh?
02:35:21 <Cale> dramforever: It's possible for data structures to contain unevaluated expressions which, once evaluated the first time, remain that way forever.
02:36:12 <dramforever> Cale: how about my slowOperation(oldTree), S_O(o_t), S_O(o_t)...case?
02:37:09 <yac> I'm getting a warning about orphan instances
02:37:18 <yac> but it's ok. Can it be selectively silenced?
02:37:49 <dramforever> If I were you, I would selectively silence it in my brain
02:37:51 <yac> eg. I don't want to check orphans on MyPackage.Orphans
02:38:08 <dramforever> hmm I think a {-# OPTION ... #-} will do
02:38:09 <yac> well it adds noise in the build output
02:38:10 <Cale> dramforever: If the better part of slowOperation's work is to evaluate an as-yet-unevaluated expression in oldTree, then yes, the subsequent evaluations of the same expression will be faster, because they won't need to repeat that work
02:38:13 <dramforever> I'll check which option
02:39:03 <dramforever> yac: {-# OPTION -fno-warn-orphans #-}
02:39:15 <dramforever> or maybe {-# OPTION_GHC -fno-warn-orphans #-}
02:39:55 <kuznero> Hi All!
02:40:01 <dramforever> hi
02:40:37 <dramforever> Cale: okay I think I'm getting it
02:40:52 <yac> dramforever: doesn't seem to be working
02:41:19 <yac> oh wait, I missed an S
02:41:25 <yac> yep, the second one. Thanks
02:42:28 <kuznero> If anybody will find interesting in reading my recent post on IORef, would be great! Trying to make sure I didn't miss anything and didn't point anything incorrectly... http://www.kuznero.com/posts/haskell/2015-02-15-common-concurrency-abstractions-IORef-part-1.html
02:45:57 <Cale> kuznero: That bang pattern is pretty unhelpful
02:46:22 <kuznero> Cale: there was an option just not to use it in that example at all.
02:46:44 <Cale> kuznero: container appears to be a list, and using the bang pattern will only cause the evaluation of that list up to determining whether or not the list is empty
02:46:52 <Cale> It won't actually evaluate the whole list
02:47:43 <Cale> (also, I think using bang patterns with let is super ugly, but people have different opinions about that)
02:48:05 <dramforever> also I think that it's slow to append to a list
02:48:56 <kuznero> I see. But still my point is primarily IORef, not bang pattern itself. And I can see that attention is been dragged to (!) it would probably make sense to remove it. WDYT?
02:49:02 <Cale> yeah
02:49:07 <Cale> It's not doing much anyhow
02:49:29 <kuznero> ok, thanks. What about atomicModifyIORef pseudo implementation? Is it ok?
02:50:00 <Cale> Yeah, that looks right
02:50:22 <tomphreek> type Sudoku = Data.Matrix.Matix Int. Now Sudoku is a (specialised) type and doesn't take a type parameter. However I would like to make Sudoku foldable. Is that not possible?
02:50:30 <kuznero> Great! What about the idea of a post series on this subject, will that make sense?
02:50:50 <dramforever> tomphreek: you need an extension:
02:51:02 <nkar> how do I get the Num instance of DiffTime from thyme?  it's shown in the docs, but ghci complains if I try to use fromIntegral.
02:51:03 <dramforever> (wait a sec I'll check the manual)
02:51:35 <Cale> Sure -- by the way, do you know about Simon Marlow's book?
02:51:36 <dramforever> tomphreek: Do you know what is an extension?
02:51:58 <Cale> http://chimera.labs.oreilly.com/books/1230000000929/index.html
02:51:59 <tomphreek> dramforever: heard of them, never used one
02:52:26 <dramforever> option 1: put {-# LANGUAGE TypeSynonymInstances #-} at the beginning of your file (less portable)
02:52:57 <dramforever>        2: write instance Foldable (Data.Matrix.Matrix Int) where ...
02:52:58 <Cale> tomphreek: No, it's not possible
02:53:10 <Cale> If you do what dramforever suggests, you'll get a kind error
02:53:17 <dramforever> huh?
02:53:20 <Cale> :k Foldable
02:53:21 <lambdabot> (* -> *) -> Constraint
02:53:26 <dramforever> oh!
02:53:38 <Cale> Foldable's argument must be a type constructor of kind * -> *
02:53:45 <Cale> So it must accept a type argument
02:53:48 <kuznero> Cale: yes, I was reading it up on that particular subject as well
02:53:54 <dramforever> okay
02:54:08 <dramforever> tomphreek: did you understand Cale?
02:54:35 <tomphreek> dramforever: yeah, that was my original problem
02:55:07 <dramforever> tomphreek: So it's not possible, yes
02:55:13 <Cale> If you look at the operations of Foldable, they don't really make sense if the thing doesn't have a type parameter
02:55:16 <Cale> :t foldMap
02:55:17 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
02:55:27 * dramforever was distracted by the type blah = blah
02:55:39 <Cale> If t doesn't accept a type argument, then t a doesn't make any sense there
02:56:00 <Cale> :t Data.Foldable.foldr
02:56:01 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
02:56:06 <Cale> similarly there
02:56:16 <Cale> :t toList
02:56:17 <lambdabot>     Not in scope: ‚ÄòtoList‚Äô
02:56:17 <lambdabot>     Perhaps you meant one of these:
02:56:17 <lambdabot>       ‚ÄòF.toList‚Äô (imported from Data.Foldable),
02:56:22 <Cale> :t Data.Foldable.toList
02:56:23 <lambdabot> Foldable t => t a -> [a]
02:56:49 <dramforever> tomphreek: so your sudoku thing might be foldable, but there can't be a instance of Foldable
02:57:25 <Saizan> it would make sense to have operations like that, just with a different type
03:00:22 <tomphreek> so what's the idiomatic way to make sudoku foldable? right now I have instance Data.Foldable.Foldable M.Matrix where foldMap f m = mconcat $ map f (mtoList m)
03:01:09 <tomphreek> I was considering newtype wrapper around Matrix?
03:02:25 <dramforever> tomphreek: you have to somehow make it take a parameter, and you have to put it into the matrix
03:02:48 <tomphreek> yeah but then I am patching up somebodyelse's type in my code
03:02:54 <tomphreek> figured newtype would be safer
03:03:06 <dramforever> no it won't
03:03:33 <dramforever> say you have (data/newtype/type) Sudoku a = ...
03:03:44 <dramforever> what are you going to do with that a?
03:07:20 <tomphreek> data FoldableMatrix = Matrix; type Sudoku = FoldableMatix Int
03:17:42 <lf94> How do I use `Num !Double` ? Like this?: Num !0.44
03:18:03 <dramforever> ?
03:18:34 <lf94> dramforever, http://hackage.haskell.org/package/haste-compiler-0.4.4.1/docs/Haste-JSON.html
03:18:57 <dramforever> lf94: Don't write that !, just Num 0.44 is good
03:19:04 <lf94> Oh ok
03:19:08 <lf94> Why is ! included
03:19:13 <dramforever> you know what's WHNF?
03:19:31 <lf94> no
03:20:04 <dramforever> let me try
03:20:07 <dramforever> @wiki WHNF
03:20:07 <lambdabot> http://www.haskell.org/haskellwiki/WHNF
03:20:27 <dramforever> hmm a bit hard to understand
03:22:24 <dramforever> lf94: this one is better: http://en.wikibooks.org/wiki/Haskell/Graph_reduction#Weak_Head_Normal_Form
03:23:06 <centrx> Hey the code example on haskell.org doesn't work in the REPL on haskell.org
03:23:09 <centrx> same page
03:23:20 <dramforever> Anyone know an introduction to that bang thing?
03:23:45 <dramforever> centrx: which one?
03:24:04 <centrx> primes = sieve [2..] ... where sieve (p:xs) = ... p : sieve [x | x <- xs, x `mod` p /= 0]
03:24:16 <centrx> ... is new line
03:24:30 <dramforever> centrx: well you tried to put it into the repl?
03:24:38 <centrx> right
03:24:44 <dramforever> "where" doesn't work in an expression
03:24:57 <dramforever> and you can't just do foo = bar in the repl
03:25:15 <centrx> I understand, the point is there shouldn't be a REPL next to an example that doesn't work in the REPL
03:25:26 <dramforever> centrx: that's not next to the REPL
03:25:44 <dramforever> those below "Got 5 minutes" are
03:26:04 <dramforever> but yeah, it could be confusing
03:26:42 <centrx> The major point of putting code on the front page of these programming sites is to be an easy introduction to it
03:27:12 <centrx> For the person who likewise needs to be told that Haskell is an "advanced purely-functional programming language" with "declarative, statically typed code"
03:27:21 <centrx> That person will copy and paste the code into the REPL
03:27:55 <dramforever> centrx: there's an announcement in haskell-cafe, maybe you should complain
03:28:22 <centrx> Okay, that is just a regular mailing list?
03:28:41 <Cale> centrx: yes
03:28:50 <centrx> Thank you
03:28:52 <Cale> fwiw, I'm not sure the new site is an improvement either
03:29:01 <Cale> It takes more clicks to get to the things I'm usually interested in
03:29:14 <Cale> Like the standards docs, especially
03:30:13 <dramforever> ha! they missed that link in "Documentation"!
03:30:14 <dramforever> complain!
03:30:38 <Cale> The fact that I have to complain because it's not a wiki is also cause for complaint :P
03:31:06 <dramforever> Cale: wiki.haskell.org is better than haskell.org/HaskellWiki, in my opinion
03:31:37 <Cale> Yeah, I suppose I can just redirect all my bookmarks
03:31:59 <dramforever> complain! make them redirect for us
03:32:16 <dramforever> or it's just they are moving fast and broke things?
03:32:43 <Cale> I don't have the energy to complain about everything that needs complaining about :P
03:32:48 <ChristianS> dramforever: it seems that links to the wiki are already redirected as needed
03:32:53 <shachaf> Complain in #haskell-infrastructure
03:33:30 <dramforever> Cale: let complainCount' = complainCount - 1
03:48:58 <wacco> you want to hobby away at haskell, but have a girlfriend complaining about the other hobby of building your own dinner table still isn't done?
03:49:20 <wacco> the solution is easy! Let your saw slip and cut your hand
03:49:42 <wacco> *settles down mending wounds*
03:50:49 <dramforever> wacco: maybe...using diagrams to design your table?
03:50:53 <dramforever> @hackage diagrams
03:50:53 <lambdabot> http://hackage.haskell.org/package/diagrams
03:51:10 <wacco> ha
03:51:13 <wacco> maybe next time ;)
03:51:53 <wacco> is it less painful to apply?
03:52:20 <dramforever> no but you get to do both
03:52:30 <wacco> lol
04:10:01 <aidecoe> hello
04:10:13 <aidecoe> is DiffList somewhere defined already?
04:10:48 <int-e> @hackage dlist
04:10:48 <lambdabot> http://hackage.haskell.org/package/dlist
04:11:43 <aidecoe> int-e: thanks
04:14:43 <aidecoe> int-e: is there something similar in stdlib?
04:15:15 <aidecoe> int-e: i'm a solving tasks at some online judge
04:15:38 <int-e> not that I know of
04:15:57 <int-e> (except for the special case, ShowS)
04:16:50 <wacco> I'm at a loss for keywords to search for; how do you set the color of the font for putStrLn?
04:17:40 <aidecoe> int-e: that's it! Thanks. I need difflist exactly for writing output strings.
04:18:19 <quchen> ?hackage ansi-terminal -- wacco
04:18:19 <lambdabot> http://hackage.haskell.org/package/ansi-terminal -- wacco
04:20:35 <wacco> sounds good, thanks
04:20:47 <wacco> I saw some ncurses bindings but that felt.. overkill
04:20:52 <zipper> Which is the best way to pass JSON from a form to a post Handler in yesod?
04:25:50 <marens> bah, the primes example on the new haskell.org website made my head hurt, then i remembered lazy evaluation, then it hurt more :D
04:29:10 <gfixler> why does [1,2,3] ::  Num t => t in GHCi, but [1,2,3] :: [Integer] when loaded from a module?
04:29:23 <gfixler> type erasure?
04:29:35 <gfixler> beta reduction?
04:31:22 <ChristianS> gfixler: you can always reduce the type to be more specific via type annotation, maybe the module does that?
04:32:09 <gfixler> ChristianS: no, I just have foo = [1,2,3] in the module
04:32:33 <gfixler> and :t foo = [Integer]
04:32:45 <gfixler> but :t [1,2,3] in GHCi is Num t => t
04:33:00 <gfixler> the former is messing up my usage
04:37:55 <ChristianS> gfixler: [Integer] is deferred as default type by ghc if you don't use foo and don't give it a signature. i guess ghci is as flexible as possible because you might use foo later.
04:40:18 * hackagebot fay 0.23.0.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.23.0.1 (AdamBergmark)
04:41:07 <scott> gfixler: this is due to something called monomorphism restriction. it happens in GHCi, too: compare :t 42 and let x = 42 then :t x
04:41:30 <scott> gfixler: you can use the NoMonomorphismRestriction language extension or just add a type signature to your binding
04:42:34 <gfixler> scott: ah, that old thing again - I've read a bit on it, but still haven't internalized it
04:42:57 <scott> gfixler: actually, I just read it's disabled by default in GHCi on newer versions of GHC, so you might not see the same behaviour as me depending on version
04:43:02 <scott> but anyway, I'd just add a type sig
04:43:19 <gfixler> scott: to foo = [1,2,3] ?
04:43:37 <solatis> when i read too much data from a socket, does haskell provide an elegant way / library to put the data back in the socket ?
04:43:46 <solatis> or, in other words, is there some buffered network library ?
04:43:49 <scott> gfixler: yeah, just add foo :: Num a => [a]
04:44:02 <gfixler> scott: I'd actually like to be able to take integers, though
04:44:09 <gfixler> I want to repair things on the function end, not the data end
04:44:34 <gfixler> I'm not sure of the best route for handling any kind of number, though
04:44:41 <solatis> i'm currently using attoparsec's incremental parsing features, but i wonder what to do with unconsumed data that is already read from a socket
04:44:42 <gfixler> (where I ultimately need to deal with fractionals)
04:44:42 <scott> gfixler: not sure what you mean
04:45:10 <gfixler> scott: I want to map over a list of numbers, ultimately as decimals, like 0.234
04:45:58 <gfixler> scott: but it doesn't matter to me if they start as integers
04:46:21 <gfixler> e.g. f = map (/2)
04:47:03 <scott> gfixler: so you want that function, but not restricting the input to Fractional?
04:47:23 <gfixler> scott: yes
04:47:35 <gfixler> I've run into this a few times now
04:47:39 <gfixler> I should learn the proper way to handle it
04:50:20 <gfixler> it feels like overkill to make a typeclass
05:01:03 <aidecoe> int-e: noob question: how to get String out of ShowS?
05:01:36 <hexagoxel> @src ShowS
05:01:36 <lambdabot> type ShowS = String -> String
05:02:19 <Taneb> @djinn (String -> String) -> String
05:02:19 <lambdabot> Error: Undefined type String
05:02:29 <Taneb> @djinn ([Char] -> [Char]) -> [Char]
05:02:29 <lambdabot> Error: Undefined type []
05:02:32 <Taneb> :((
05:02:38 <Taneb> Point is, it's \x -> x ""
05:07:01 <aidecoe> Taneb: so, how to get regular string out of it? (-:
05:07:17 <hexagoxel> Taneb: even if djinn new about lists, it would not invent literals (and, by default, does not know about monoid)
05:07:23 <Taneb> aidecoe, if x is the ShowS, x ""
05:07:41 <Taneb> aidecoe, that is, it's a function, if you give it the input "" it gives you the string
05:07:41 <aidecoe> hm‚Ä¶ i've tried that already
05:07:47 <Taneb> You sure?
05:07:48 <aidecoe> mabye i've got something else wrong
05:08:21 <Taneb> > shows 1 ""
05:08:23 <lambdabot>  "1"
05:13:52 <aidecoe> Taneb: ok, thanks. I've got something else messed up‚Ä¶
05:14:09 <Taneb> I hope you get that sorted! :)
05:15:02 <aidecoe> Taneb: parenthesis!
05:15:11 <aidecoe> now it's compiling (-:
05:15:19 * hackagebot Ketchup 0.4.2 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.4.2 (Hamcha)
05:30:14 <wacco> liftIO (setSGR [SetConsoleIntensity FaintIntensity ] . (putStrLn a))
05:30:31 <wacco> apparently, that's not how you chain IO. I feel like such an amateur -__-
05:33:00 <quchen> wacco: >>
05:33:31 <wacco> quchen: I was trying >>=... magic
05:33:45 <quchen> a >> b = a >>= \_ -> b
05:34:23 <wacco> already reading up on it @ hoogle, thanks :)
05:38:05 <wacco> cool, that seems to work :)
05:39:49 <_deepfire> is there a way to leverage Either branches to value choice, but more ergonomically than "either"?
05:40:08 <_deepfire> that is :: Either a b -> c -> c -> c
05:40:19 * hackagebot wiring 0.2.0.0 - Wiring, promotion and demotion of types.  http://hackage.haskell.org/package/wiring-0.2.0.0 (seanparsons)
05:41:00 <_deepfire> i.e. I'm not interested in the values stored within the branches
05:41:28 <_deepfire> (or is this more of a haskell-beginners question?
05:42:42 <seanparsons> _deepfire: You could create that from the either method.
05:43:04 <seanparsons> As in just build your own from it.
05:43:08 <_deepfire> does_this_have_a_standard_name e l r = either (const l) (const r) e
05:44:05 <_deepfire> I'd hate to be reinventing some function from base : -)
05:44:20 <_deepfire> hoogle didn't help me much..
05:44:55 <seanparsons> I suspect it's use is too close to that of either really for anyone to create a specific function for it.
05:47:34 <_deepfire> Data.Utils.Either form MissingH has nothing as well : -)
05:48:21 <_deepfire> oh well
05:49:01 <seanparsons> _deepfire: Also it sounds distinctly like something I would probably pattern match on, but that's totally a personal preference thing.
05:49:06 <MagBo> Greetings, beautiful people. I wonder if there is an effort (and maybe some results) to save haskell terms along with type information as blobs and load those like that. So that we can, say, dump haskell terms to disk without losing type information (like what happens when we're using PostgreSQL).
05:49:55 <MagBo> For distributed small services that do "one thing" it might be a good enough persistence layer.
05:49:58 <_deepfire> seanparsons: I'd do that too, but that's an error handling message path, where I'm using the alternatives to generate a more specific error message
05:50:19 * hackagebot transformations 0.2.0.0 - Generic representation of tree transformations  http://hackage.haskell.org/package/transformations-0.2.0.0 (JosePedroMagalhaes)
05:50:20 <_deepfire> seanparsons, so the context doesn't calls for something heavyweight like matching
05:51:11 <solatis> what data structure should I use for a version number (that is *not* SemVer) ? i am using the type Fractional a for as long as I can, but eventually ghc wants me to choose Double, which is not something I like, since I hate floating point arithmetic
05:51:49 <solatis> also, I have no idea whether the protocol designers might choose to make a version 1.2.3 in the future
05:51:58 <solatis> maybe just a list of ints?
05:52:04 <tremon> solatis: I'd use a tuple, list of ints or a string
05:52:33 <solatis> list of ints might just do, since it allows pattern matching..
05:52:36 <_deepfire> error "Tool/inputs arity mismatch: used %s on an %sary input" (show n) $ mapEither "uny" "multi" ins
06:01:17 <mleduc> hi, I am looking for a haskell library which handle shell script parameters (I'm looking for a tool which will look for a key in my environments variable and then fallback to my script parameters and then fallback to a default value)
06:01:30 <mleduc> does this king of thing already exists ?
06:01:37 <zipper> I have a form that whose data is made to be in JSON. So I am wondering how to make the post handler recieve JSON data from a form in Yesod
06:02:15 <zipper> mleduc: I think I  once used optparse
06:02:19 <mleduc> zipper: http://stackoverflow.com/a/10823195 does this answer your question ?
06:02:20 <zipper> mleduc: Let me get you a link
06:02:51 <_deepfire> hm, perhaps constEither would be a better name
06:03:18 <zipper> mleduc: I meant GetOpt
06:03:28 <zipper> mleduc: I've used it here. https://bitbucket.org/urbanslug/ix-client/src/67336a7d5d814b7a09efc120181cbbfe04f57903/src/Main.hs?at=master
06:03:44 <zipper> mleduc: Let me see your stack overflow answer.
06:04:53 <mleduc> I gotta go but this getopt library you used looks nice :)
06:06:33 <zipper> mleduc: yaaaay
06:08:36 <ChristianS> mleduc: check out optparse-applicative too, it's more modern and probably easier
06:35:07 <ddellacosta> I would love to get some feedback on this implementation of BFS in Haskell: https://gist.github.com/ddellacosta/341c5dc0f55c60b3c5f9 , in particular the function bfs'
06:35:25 <ddellacosta> which I think is pretty ugly in a lot of ways, in addition to being pretty inefficient
06:42:06 <kagitingan> Is it ok to ask for comments about my code so that I will know what areas are needed to improve?
06:42:42 <ddellacosta> kagitingan: that's what I just did (and have done before) ;-)
06:43:08 <lpaste> kagitingan pasted ‚ÄúShortes Repetition‚Äù at http://lpaste.net/120539
06:43:24 <kagitingan> there is my code
06:44:06 <ddellacosta> wow, does lpaste actually evaluate code?  Just noticed the "Error: ..." at the bottom
06:44:13 <ddellacosta> nifty
06:44:24 <kagitingan> yeah, I notice that too.
06:45:03 <kagitingan> so print = putStrLn . show ?
06:45:09 <Adeon> yes
06:46:46 <kagitingan> What things can be change to make the code better?
06:47:59 <Adeon> as far as I can tell, that code has no unambiguously bad styling or obvious flaws
06:48:09 <Adeon> it does what it says
06:48:28 <ddellacosta> kagitingan: I would say you could move helper to a separate function, but I think that's rather subjective
06:48:35 <ddellacosta> would otherwise agree with Adeon
06:48:48 <Adeon> there are some minor things, such as you could use traverse_ instead of mapM_
06:48:53 <Adeon> it's more general
06:49:42 <lpaste> funke revised ‚Äúx‚Äù: ‚Äúx2‚Äù at http://lpaste.net/120540
06:50:30 <Adeon> you could try generalize that code to any list
06:50:33 <Adeon> not just strings
06:50:52 <Adeon> instead of String -> String -> Bool, try [a] -> [a] -> Bool
06:51:20 <Adeon> although that would be trivial
06:52:18 <kagitingan> I didn't generalize it because the problem I am solving involves string
06:53:09 <Adeon> my opinion is that if you can sensibly generalize something then you should do it
06:53:10 <lpaste> funke pasted ‚Äúxyz‚Äù at http://lpaste.net/7760998125686226944
06:54:21 <n4x> ddellacosta: lpaste is using hlint
06:54:33 <ddellacosta> n4x: gotcha, thanks for the info
06:54:36 <kagitingan> thanks for the comments
06:55:23 <kagitingan> Why is traverse_ more general? This is the first time I encounter it.
06:56:06 <suppi> kagitingan, https://www.haskell.org/hoogle/?hoogle=traverse_
06:56:20 <suppi> https://www.haskell.org/hoogle/?hoogle=mapM_
06:56:23 <Adeon> it works with any applicative, where as mapM_ wants a monad
06:56:33 <Adeon> there are more applicatives than there are monads
06:57:23 <n4x> in this case it doesn't really matter, it's IO
06:57:37 <Adeon> also I think there are two different mapM_s in the base library, one takes lists and one takes foldables
06:57:54 <Adeon> yeah it's unlikely to be a serious issue which one you use
06:59:37 <kagitingan> My knowledge in haskell is very superficial so although I've been hearing about functors, applicatives and such, I have yet to use them in my basic programs
07:00:20 <Adeon> okay, I wouldn't worry right now if it's difficult to understand
07:01:28 <kagitingan> what about this one?
07:01:56 <lpaste> kagitingan pasted ‚ÄúRoman Numeral‚Äù at http://lpaste.net/120542
07:02:02 <adam_hardkey_shi> If you haven't read it yet kagitingan, this is a good introduction http://learnyouahaskell.com/functors-applicative-functors-and-monoids
07:03:06 <kagitingan> adam_hardkey_shi thanks
07:03:43 <adam_hardkey_shi> You're welcome. ;)
07:04:36 <Adeon> those concats are a bit weird
07:04:44 <suppi> kagitingan, i'd recommend more meaningful variable names
07:05:13 <Adeon> you use list comprehension to replicate an item
07:05:48 <Adeon> as usual it's not unambiguously bad but you could write: 'replicate int o1' instead of '[ o1 | r <- [1..int] ]'
07:06:47 <suppi> yes, replicate is clearer
07:07:50 <kagitingan> what about the style of the code aside from variable naming, can it be improve?
07:07:59 <suppi> kagitingan, have you met hoogle (https://www.haskell.org/hoogle/) ?
07:08:03 <Adeon> I think it's very clean overall
07:08:15 <suppi> I agree with Adeon
07:08:19 <Adeon> I'm not commenting on the algorithm itself, it doesn't fit in my brain
07:08:42 <suppi> me neither :)
07:09:35 <Adeon> of course you could interpret that as it being difficult to read and add comments and stuff to tell how it works
07:09:45 <Adeon> but I don't know, I think it's okay, I know what it does from name and type signature
07:10:01 <Adeon> even if I don't know the details how it does it
07:12:51 <kagitingan> I like to make more comments but sometimes it is hard to express my ideas
07:13:09 <kagitingan> though commenting is a good thing to do
07:17:41 <kagitingan> what about this one?
07:20:26 <lpaste> kagitingan pasted ‚ÄúFind difference between time‚Äù at http://lpaste.net/120549
07:21:18 <babu`> Getting a statusCode from Network.HTTP.Types.Status.Status, why is the signature so complicated? statusCode :: Functor f => (Int -> f Int) -> Status -> f Status. Given a Status shouldn't I be able to call statusCode and get the integer code?
07:25:23 * hackagebot ini 0.3.1 - Quick and easy configuration files in the INI format.  http://hackage.haskell.org/package/ini-0.3.1 (ChrisDone)
07:25:37 <Adeon> kagitingan: can you implement splitByChar with groupBy?
07:26:07 <Adeon> you knew about span so I wonder if you knew about groupBy as well
07:31:57 <kagitingan> I knew span but I didn't know groupBy
07:32:13 <kagitingan> I test it out today and it's kind of neat
07:40:07 <kagitingan> thanks all for the help
07:50:24 * hackagebot hindent 4.3.10 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.10 (ChrisDone)
07:55:22 <mreh> Is it a bug or a feature that cabal exec runhaskell Blah.hs ignores extensions in the cabal file?
07:56:12 <dcoutts_> mreh: a feature, cabal exec just runs arbitrary commands in the package context defined by the project
07:56:23 <dcoutts_> so you might want to be using cabal run instead?
07:56:35 <dcoutts_> to run one of the exes defined within the package
07:57:05 <mreh> dcoutts_, ahhh
07:57:26 <dcoutts_> mreh: it's also a fairly common practice to list extensions explicitly with the .hs file so that one can load them directly in ghci
07:57:32 <dcoutts_> with/within
07:57:45 <mreh> dcoutts_, okay thanks
08:28:59 <mizu_no_oto> Is there something like Show but for Text instead of String?
08:29:48 <ChristianS> mizu_no_oto: converting to Text you mean? i don't think so
08:30:44 <mizu_no_oto> Yeah.  Something that gives you something like showText :: ShowText a => a -> Text
08:32:22 <ChristianS> mizu_no_oto: i suspect you have to call T.pack on the result of show
08:33:08 <mizu_no_oto> Seems unfortunate
08:35:45 <Yuras> I remember there was an article or blog post about why you should not use monad transformers in library interface. Does anyone know where to find it?
08:40:26 * hackagebot tasty-silver 3.0.1.0 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.0.1.0 (PhilippHausmann)
09:05:27 * hackagebot tttool 1.1 - Working with files for the TiptoiÆ pen  http://hackage.haskell.org/package/tttool-1.1 (JoachimBreitner)
09:32:27 <Streaxy> Hello all
09:35:28 * hackagebot microformats2-types 0.3.0 - Microformats 2 types (with Aeson instances)  http://hackage.haskell.org/package/microformats2-types-0.3.0 (myfreeweb)
09:36:27 <sssilver> Guys, I don‚Äôt understand module‚Ä¶where‚Äôs `where` part
09:36:54 <sssilver> does it just export everything that follows?
09:37:27 <thebnq> yes, only if you don't add anything in between
09:37:39 <sssilver> thebnq: such as?
09:37:46 <hpc> "module Module.Name (exports) where definitions"
09:38:12 <hpc> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-Complex.html -- a decent example
09:38:31 <myfreeweb> "where" is basically the end of the module declaration
09:38:46 <sssilver> myfreeweb: linguistically that‚Äôs weird
09:38:57 <myfreeweb> nah, that actually makes sense
09:39:03 <hpc> it's "math language"
09:39:03 <mauke> "where" is always followed by a block of definitions
09:39:07 <myfreeweb> module X where this = that
09:39:15 <sssilver> hpc: so I read ‚Äúmodule Data.Complex ‚Ä¶ where import Prelude‚Äù
09:39:22 <sssilver> that‚Äôs pretty weird to read, no?
09:39:26 <mauke> it's used in module, class, data, and other places
09:39:27 <myfreeweb> don't read the imports :D
09:39:35 <hpc> "module Data.Complex ... where <the entire rest of the file>"
09:39:50 <sssilver> oh
09:40:10 <sssilver> then where seems overly verbose and redundant. Sounds like it could be omitted altogether
09:40:18 <thebnq> you can chose to hide internals
09:40:33 <sssilver> why not `module Data.Complex (exports) <the entire rest of the file>`
09:40:41 <hpc> that's almost possible
09:40:53 <sssilver> where does the almost part kick in?
09:40:55 <hpc> but you can write tuple top-level definitions
09:41:09 <hpc> (foo, bar) = (stuff, more stuff)
09:41:15 <mauke> sssilver: layout, basically
09:41:31 <hpc> that's very very rarely used, but it's sometimes nice to force sharing in weird cases
09:41:35 <mauke> technically the syntax is 'module' NAME EXPORTS 'where' '{' DEFINITIONS '}'
09:41:52 <mauke> but you don't need to explicitly write the { } because layout
09:41:58 <hpc> there's an ambiguity in "module Module.Name ("
09:42:33 <hpc> that might be resolvable, but it'd be a waste of complexity
09:43:10 <hpc> mauke: and you don't need to indent even, because layout rules
09:43:16 <hpc> woo technicalities
09:43:37 <sssilver> umm OK. Not sure I understood the rationale, perhaps that‚Äôll come with time. But for now I just accept that the syntax for declaring a module is `module <blah> (<blah>) where`
09:43:48 <sssilver> even though having a line end with `where` feels rather unsettling
09:43:54 <mauke> happens all the time
09:44:04 <mauke> in class declarations, data declarations, local definitions, ...
09:44:41 <hpc> sssilver: generally, "X where Y" means "assume Y while defining X"
09:44:53 <sssilver> yup, that‚Äôs OK hpc
09:44:53 <hpc> sssilver: and a module is a name and a list of exports
09:45:08 <hpc> so "define a name for this module and what it exports, assuming the definitions are below"
09:45:19 <hpc> which is still pretty weird, but there you go
09:45:31 <sssilver> X where [your typical Haskell source code starting from a few new lines] reads differently though :))
09:45:54 <mauke> well, you can always put the { } in
09:46:07 <mauke> module Main where { main = putStr "Hello, world!\n" }
09:47:16 <sssilver> mauke: but that way I deviate from the accepted ‚Äúde-facto standard‚Äù, and I don‚Äôt like that either. I come from Python culture, I love when everyone‚Äôs source code looks/feels the same way
09:47:20 <sssilver> including my own
09:47:33 * sssilver pets his PEP-8
09:47:53 <hpc> a bit of adjustment is necessary on that point
09:48:09 <hpc> people can't even decide on a single style of layout/indentation ;)
09:48:28 <sssilver> that‚Äôs horrible. Obviously the right way to indent is to use 4 spaces.
09:48:36 <sssilver> there should be one, and only one way to do it
09:48:36 <hpc> it's not that everyone decided differently, it's that different styles are better in different situations
09:48:37 <myfreeweb> I thought everyone agreed to use two spaces in haskell?
09:48:41 <mauke> sssilver: that doesn't work in haskell
09:48:50 <hpc> sometimes it's better to indent
09:48:53 <mauke> sssilver: haskell syntax is based on lining things up with other things, not indentation levels
09:48:56 <hpc> and usually for indentation it's two spaces
09:49:07 <hpc> sometimes it's better to use layout
09:50:09 <hpc> camelCase is the most common capitalization for function names
09:50:18 <hpc> and TitleCase for constructors
09:50:29 * hackagebot sandi 0.3.3 - Data encoding library  http://hackage.haskell.org/package/sandi-0.3.3 (MagnusTherning)
09:50:33 <hpc> but in FFI code CONSTRUCTORS and function_names are sometimes written like this to match C
09:50:54 <sssilver> hpc: yeah, it‚Äôs pretty bad also :( I mean, research shows that vars_named_like_this are way more readable than varsNamedLikeThis
09:51:10 <hpc> and when that makes sense depends on the level of abstraction the module has
09:51:19 <sssilver> for a language that prides itself in being the culmination of ‚Äúcutting-edge modern programming research‚Äù, you‚Äôd imagine they‚Äôd look at all aspects of programming
09:51:46 <hpc> i have never heard of this research
09:51:49 <sssilver> hpc: sec
09:52:05 <geekosaur> I have, there's still a strong "what you're used to" aspect
09:52:17 <thebnq> i'm sure its also context dependent
09:52:19 <sssilver> there are actually a bunch of independent researches on this subject, all ended up with the same conclusion
09:52:24 <sssilver> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.421.6137&rep=rep1&type=pdf
09:52:30 <mauke> my personal preference is names-like-this > names_like_this > namesLikeThis
09:52:31 <geekosaur> (I will probably always find camelcase difficult because I started out in languages that used _)
09:53:10 <sssilver> mauke: that‚Äôs a fair point, unfortunately `-` is almost everywhere syntax-significant :))
09:53:54 <sssilver> which proves the point that keyboards need separate keys for a minus and a dash
09:53:58 <hpc> sssilver: neat paper
09:54:20 <sssilver> hpc: there are even more advanced papers, trying to find them
09:54:27 <hpc> would be interesting to redo the experiment with real code samples that have been translated between styles
09:54:48 <monochrom> I have a feeling that camel case was invented by Germans
09:54:55 <duckman1> hello, I am new to haskell and have a question regarding list filtering is this the right place to ask?
09:55:09 <hpc> and separate characters for minus and dash will never be a good idea, they're too visually similar
09:55:20 * hpc is a fan of whitespace-sensitive dash though
09:55:21 <sssilver> lol monochrom :))
09:55:27 <hpc> "foo-bar" - one identifier
09:55:29 <cmccann> sssilver: in haskell we usually circumvent the underscores vs. camelCase issue by using single-letter variables and cryptic abbreviations
09:55:31 <hpc> "foo - bar" - subtraction
09:55:57 <geekosaur> duckman1, as good a place as any
09:56:09 <sssilver> cmccann: that‚Äôs Pythonista‚Äôs hell :)) In fact I stopped considering learning Go because of their culture to use single-letter cryptic variable names
09:56:12 <thebnq> if your code fits on screen, you don't have to scroll to read more :p
09:56:13 <geekosaur> although there is #haskell-beginners which may be better when people here are getting philosophical >.>
09:56:16 <MagBo> So, any insights on dumping typed Haskell data to a blob?
09:56:37 <cmccann> sssilver: why settle for the lesser evil etc.
09:56:39 <hpc> MagBo: do you need to store the type with the data?
09:56:43 <monochrom> "f" is no more cryptic than "foo"
09:56:45 <myfreeweb> sssilver: Go's cryptic naming comes from C, Haskell's comes from math :-)
09:57:10 <hpc> MagBo: also, does it have to be binary data, or will a structure like JSON work?
09:57:11 <sssilver> myfreeweb: fair enough :D
09:57:15 <MagBo> hpc: yes, I want a persistence layer that has type guarantees on write.
09:57:30 <cmccann> myfreeweb: and some haskell FFI bindings to C libs combine the worst of both worlds
09:57:49 <hpc> MagBo: acid-state might meet your needs
09:58:02 <hpc> it's a bit lousy with TH though
09:58:03 <cmccann> but on a serious note I also prefer this-style-of-naming
09:58:08 <monochrom> my cryptic names are john, jon, joan, johan, jonah, jean, sean, bean.
09:58:10 <cmccann> if only more languages allowed that
09:58:17 <hpc> there's other packages that are similar but i am forgetting them atm
09:58:25 <cmccann> monochrom: those are very cryptic indeed
09:58:29 <duckman1> awesome, so the question is:
09:58:29 <duckman1> I want to filter a list based on another list but am unsure how to get the second list's items to be referenced:
09:58:29 <duckman1> example: map (filter (== y) xs) colors, where y = [Color] = data Red | Green ...
09:59:01 <mauke> duckman1: what is (== y) supposed to do?
09:59:28 <duckman1> compare items in xs against the first item in y
09:59:32 <monochrom> I don't understand "y = [Color] = data Red | Green ..."
09:59:40 <KaneTW> that's not how equals works
09:59:48 <duckman1> i used it before like this:
09:59:49 <mauke> duckman1: what if there is no first item?
09:59:54 <duckman1> length $ filter (True ==) $ zipWith (==) code guess
10:00:02 <mauke> (True ==) is redundant
10:00:16 <duckman1> but it works...?
10:00:22 <thebnq> do you maybe want, (`elem` y)?
10:00:23 <KaneTW> it doesn't do anything
10:00:27 <mauke> what do you mean, "but"?
10:00:52 <c_wraith> well, filter id is shorter
10:00:53 <duckman1> i have a test that does not error
10:01:06 <cmccann> mauke: if ((foo == bar) == true) { return true; } else { return false; }
10:01:20 <cmccann> mauke: I see code like that in production C# all the time :[
10:01:25 <mauke> dude, you forget to check it's /= false!
10:01:27 <hpc> cmccann: have you considered contributing to acme-php?
10:01:33 <c_wraith> cmccann: that almost would make sense in C
10:01:33 <KaneTW> thebnq: i think he wants (\x -> all $ elem x)
10:01:36 <monochrom> I think you need to describe, concretely and unambiguously, without "you know what I mean", what is "based on another list".
10:01:56 <mauke> KaneTW: that doesn't contain "first item in y"
10:02:11 <KaneTW> oh
10:02:18 <KaneTW> i missed that part
10:02:26 <c_wraith> I like the !!foo idiom in C.  It does something!
10:02:29 <KaneTW> i'm tired today don't mind me
10:02:51 <cmccann> hpc: I don't think I could really make acme-php any better than it already is
10:03:02 <KaneTW> duckman1: what you want depends on what behavior you want if xs is empty
10:03:44 <KaneTW> if xs is never empty, head will help you. if it can be empty, head will cause an error
10:03:53 <duckman1> Basically I have a list of unique colors, that I want to filter a list of non-unique colors then count how many instances there are of that color there are in that list. Example: master list is [Red, Blue], compared against [Red, Red, Blue] would output [2,1]
10:04:06 <thebnq> KaneTW: you
10:04:27 <thebnq> you're right that i was wrong, i think i meant the opposite
10:04:53 <KaneTW> duckman1: check out Data.Map
10:04:56 <duckman1> my idea is to filter the target list against each item in the master, then use length on it
10:05:36 <thebnq> > let y = [1,3] in filter (\x -> not (elem x y)) [1..5]
10:05:37 <lambdabot>  [2,4,5]
10:05:58 <thebnq> thats what i meant to say, but i think this is old now
10:06:21 <cmccann> > let x = group . sort $ "blah blah, fiskcakes" in zip (map length x) x -- duckman1
10:06:22 <lambdabot>  [(2,"  "),(1,","),(3,"aaa"),(2,"bb"),(1,"c"),(1,"e"),(1,"f"),(2,"hh"),(1,"i"...
10:07:16 <cmccann> (though using Data.Map would be more efficient)
10:08:00 <duckman1> okay so you are saying let will introduce the first list into the expression
10:08:26 <cmccann> duckman1: the let is just so I could zip it with the lengths and make it easier to see the result
10:08:57 <cmccann> duckman1: for the filtering part you probably just want to filter using (`elem` masterList) or the like
10:09:02 <mauke> let DEFINITIONS in EXPR
10:09:14 <Big_G> What does that -- do?
10:09:22 <thebnq> comment
10:09:31 <Big_G> Thanks
10:13:01 <duckman1> cmcann: thanks im working through your example
10:13:34 <MagBo> hpc: thank you.
10:15:27 <MagBo> I'm pretty satisfied with acid-state. I wonder if there are plans to marry it with cloud haskell, sprinkle it with vector clocks and get a typed version of Dynamo.
10:18:03 <sssilver> Haha I just compiled my first meaningful Haskell program! https://dpaste.de/msyX ‚Äî does this look idiomatic?
10:18:15 <Cheery> OpenGL-2.9.2.0 failed during the building phase. The exception was:
10:18:15 <Cheery> ExitFailure 1
10:18:17 * sssilver is proud of his `where window‚Ä¶`
10:18:27 <Cheery> trying to try lamdu
10:18:28 <Cheery> heh.
10:18:45 <Procian> sssilver: Oh, I live gloss.
10:18:48 <Procian> *love
10:19:59 <Procian> If the first Haskell program you compile is a gloss program, then awesome.
10:20:01 <heatsink> Are headings a new feature of Haddock markup?  I'm trying to use = to start a heading, but it just becomes an = in the documentation.
10:21:20 <Cheery> okay.. now managed to get an error response too
10:21:44 <dino-> I'm working on a custom Setup.hs but I haven't waded into the Cabal library in almost 5 years. Is the postInst hook deprecated or something? When I provide one, it's never executed.
10:22:14 <dino-> I mean, before, during or after a `cabal install` of this project
10:22:17 <lpaste> cheery pasted ‚Äúlamdu: cabal install‚Äù at http://lpaste.net/120554
10:22:31 <sssilver> Procian: thanks!
10:22:49 <sssilver> Check this out ‚Äî https://dpaste.de/Cnu3 ‚Äî this is way more explicit (which is always better than implicit), but it seems overly verbose.
10:23:25 <duckman1> cmccann: okay I think I have it working thanks!
10:23:42 <cmccann> duckman1: no prob
10:24:16 <heatsink> dino-: I haven't tried overriding the pre or post hooks
10:24:16 <sclv> dino-: this channel is sort of high noise. you might be able to get some more focused advice on these issues on #hackage (which also covers cabal iirc)
10:25:02 <heatsink> dino-: I override the main hook to call the default function and do other work before or after it.  You might want to try that.
10:25:03 <nitrix> Woot, the new haskell.org site is all shiny <3
10:25:31 * hackagebot diff-parse 0.2.1 - A parser for diff file formats  http://hackage.haskell.org/package/diff-parse-0.2.1 (mulby)
10:26:04 <heatsink> nice, chrisdone got the experimental site to replace the old one
10:26:05 <Procian> sssilver: I'd go for the first one. You could also "import qualified Graphics.Gloss as G" and then do "G." everywhere to keep things terser but still letting you know (someone else defines this).
10:27:13 <SortaTRD> SOS Haskell noob entering
10:27:23 <sssilver> Procian: yeah, but then if someone else is reading the code, they have to go up and confirm what G is, which seems worse.
10:27:35 <Cheery> ohwell
10:27:37 <hexagoxel> dino-: what is your `build-type` for the package?
10:28:00 <SortaTRD> (a -> b) -> (b -> c) -> (c -> d) -> a -> d what in the world does this mean :o
10:28:08 <Cheery> if someone happens to read that problem I had with Lamdu, just privmsg
10:28:21 <Cheery> (assuming you want me to check it out)
10:28:24 <jmcarthur> SortaTRD: "A -> B" is the type of a function from A to B
10:28:26 <Cheery> cya.
10:28:45 <jmcarthur> SortaTRD: if you see a chain of them, like "A -> B -> C", they associate to the right, so read it as "A -> (B -> C)"
10:29:10 <jmcarthur> SortaTRD: so that last example means "a function that takes an A and returns a function that takes a B and returns a C"
10:29:28 <Procian> @djinn (a -> b) -> (b -> c) -> (c -> d) -> a -> d
10:29:28 <lambdabot> f a b c d = c (b (a d))
10:30:12 <jmcarthur> SortaTRD: when there are parens like "(A -> B) -> C" that means "a function that takes a function. the input function takes an A and returns a B. the entire function returns a C"
10:30:23 <jmcarthur> silver:
10:30:26 <jmcarthur> oops
10:30:38 <jmcarthur> SortaTRD: so i think i have given you enough information to decipher that type :)
10:31:00 <SortaTRD> I'm a bit pf a noob with functional programming
10:31:19 <SortaTRD> im more used to returning values vs functions
10:31:32 <SortaTRD> so would it be returning parameters of the functions?
10:31:58 <jmcarthur> SortaTRD: if it helps, the following two types are roughly isomorphic:    (A -> B -> C)  ~  ((A, B) -> C)
10:32:29 <hexagoxel> jmcarthur: you need to mention associativity :D
10:32:40 <jmcarthur> hexagoxel: i did earlier?
10:32:57 <Procian> sssilver: Ah, I guess I don't have any profound feelings on that. But I think you'll find as you write Haskell that you prefer to keep things as terse as possible, because tersenessness (is that a word?) can reveal more conceptually. I hate to say it, but I think IDEs should be solving our lookup problems for us, and that goes for Emacs.
10:32:59 <hexagoxel> jmcarthur: oh, my bad, missed that :)
10:33:39 <jmcarthur> SortaTRD: here's an example. say i have a function (f :: A -> B -> C -> D) and some other values (x :: A), (y :: B), (z :: C). here is a series of partial applications:  (f x :: B -> C -> D), (f x y :: C -> D), (f x y z :: D)
10:34:01 <nv2525> Can anyone help me out with a Haskell Problem?
10:34:19 <jmcarthur> SortaTRD: if you study that, you will see that each argument you supply drops a (->) from the type of the function
10:34:44 <mauke> nv2525: just ask your question, don't ask do ask :-)
10:34:45 <SortaTRD> oh alright thanks! jmcarthur
10:34:48 <mauke> *ask to ask
10:35:01 <nv2525> thanks mauke :)
10:35:17 <nv2525> so i was asked to solve this
10:35:19 <nv2525> Write a function mapCF :: a -> (a -> b -> c) -> [b] -> [c] that uses map and
10:35:19 <nv2525> where to apply the function over the input list.
10:35:32 <nv2525> So far this is what I have but I'm not sure I'm on the right track
10:35:32 <nv2525> module Main where
10:35:33 <nv2525> mapCF :: (a -> (a -> b -> c) -> [b]) -> [c]
10:35:33 <nv2525> mapCF _ _ [] = []
10:35:51 <mauke> your type is wrong
10:36:39 <nv2525> how would I change my type?
10:36:51 <mauke> er. with a text editor?
10:37:07 <mauke> the correct type is a -> (a -> b -> c) -> [b] -> [c]
10:37:30 <nv2525> Oh i added those brackets because I wanted those evaluated first
10:37:33 <nv2525> but I guess that makes a difference
10:37:35 <nv2525> thanks mauke
10:37:35 <jmcarthur> nv2525: change the type you wrote in your file with the type you have us before you pasted the contents of your file :)
10:37:38 <mauke> a big difference
10:37:40 <jmcarthur> *gave
10:37:52 <mauke> a -> b -> c is equivalent to a -> (b -> c), not (a -> b) -> c
10:38:10 <nv2525> oh alright
10:38:57 <nv2525> is my map function close to being correct?
10:39:03 <mauke> I'd start with 'mapCF k f xs' because mapCF gets three arguments, some value, a function, and a list
10:39:10 <dino-> hexagoxel: Sorry, was afk. build-type Custom. It's calling the postCopy hook for both copy and install
10:39:13 <jmcarthur> nv2525: it's also worth point out that parens only affect evaluation order when the way the expression is parsed would effect the evaluation order (e.g. strict operations like Int arithmetic). parens in types change the types, not the evaluation order. parens in expressions change the parsing, not (directly) the evaluation order.
10:39:17 <Procian> nv2525: It doesn't use map.
10:39:25 <Procian> But it has the right type!
10:39:31 <dino-> I don't believe it always did that
10:39:41 <mauke> and it does the right thing for an empty input list :-)
10:40:17 <heatsink> dino-: Unfortunately, the Cabal API is not stable across versions.  I've run into compatilbility issues with other parts of the API.
10:40:20 <nv2525> thanks everyone you're a great help
10:40:39 <Procian> mapCF _ _ xs = []
10:40:46 <Procian> Now with all cases considered.
10:41:21 <mauke> :t flip (fmap fmap)
10:41:22 <lambdabot> Functor f => b -> (b -> a -> b1) -> f a -> f b1
10:41:23 <Procian> But seriously, they'll be wanted you to write this as a single line function using all arguments.
10:41:43 <jmcarthur> nv2525: the distinction i'm trying to make might be more clear with an example that would work in most other languages (even languages where most operations are eager): for any expressions A and B in a language where (&&) short circuits, the evaluation of the expression A && B is not affected by parentheses surrounding A or B.
10:41:45 <heatsink> dino-: The 'install' command performs 'copy' and 'register', so I would expect postCopy to be invoked during install.
10:42:14 <nv2525> thanks jmcarthur
10:42:34 <jmcarthur> nv2525: (provided that the parens are not needed just to override precedence rules)
10:42:48 <nv2525> @ procian: when i compile the program, it runs in ghci
10:43:01 <nv2525> but how am i to test this program to make it sure it works?
10:43:36 <heatsink> nv2525: Run it and examine the output?
10:43:55 <nv2525> am i to assign values to a b and c?
10:44:17 <heatsink> Do you want to test a function?
10:44:43 <MagBo> So, phylosophically speaking, did anti-template-haskell purists accepted it as a handy meta-programming tool or are "Template Haskell considered harmful" posts are still getting written?
10:44:47 <heatsink> I would start by calling it with some example inputs in GHCi
10:44:55 <nv2525> yes heatsink, i was wondering what would happen in the mapCF function if i were to assign a =1 b = 2 c = 3
10:44:56 <MagBo> phi*
10:45:15 <nv2525> what is the command i would have to type in to call the function?
10:45:22 <nv2525> im sorry im really new to haskell and ghci
10:45:37 <heatsink> Function calls are written with spaces, so you would write f 1 2 3
10:45:46 <heatsink> if the function is named 'f'
10:46:02 <heatsink> > let f a b c = a * b + c in f 1 2 3
10:46:03 <lambdabot>  5
10:46:09 <MagBo> nv2525: there is :l. You can load the file and then just call your function with "foo x y z", where foo is the function name and x, y, z are arguments
10:46:31 <nv2525> thanks everyone
10:46:32 <nv2525> in my case
10:46:33 <nv2525> module Main where
10:46:33 <nv2525> mapCF :: a -> (a -> b -> c) -> [b] -> [c]
10:46:33 <nv2525> mapCF _ _ xs = []
10:46:44 <nv2525> would i have 3 arguments?
10:46:56 <nv2525> a b c? or would the lists be separate?
10:47:12 <MagBo> nv2525: do you understand concept of currying?
10:47:34 <nv2525> i've read about currying but I can't fully grasp the concept
10:47:45 <MagBo> Basically, look at mapCF signature, it tells you everything, let's read it together
10:48:51 <nv2525> a function a is applied to a function (a->b->c), which is applied to a list b, which is finally outputted to list c?
10:49:04 <mauke> no
10:49:08 <MagBo> A tl;dr ‚Äî we'll eventually get this: "mapCF is a function of three arguments that takes something, a function of two arguments that takes something and something else and returns something different, a list of something elses and returns a list of something differents.
10:49:24 <mauke> nv2525: "a" is a random value. it's not a function
10:49:42 <fread2282> mapCF :: a -> ((a -> b -> c) -> ([b] -> [c]))
10:49:58 <MagBo> We shouldn't use word "random" here, mauke, it might be confusing.
10:50:29 <mauke> arbitrary? :-)
10:50:33 <MagBo> fread2282: let's get to right-associativity of arrow step by step :)
10:50:37 <MagBo> mauke: better! :)
10:50:40 <mauke> and in that case, it's not necessarily a function
10:50:58 <mauke> I mean, the caller might decide to pass in a function for shits and giggles
10:51:05 <mauke> mapCF just can't assume it's going to be a function
10:51:16 <nv2525> alright :)
10:51:27 <MagBo> nv2525: so let's see how we got what I wrote in "tl;dr" section.
10:51:42 <fread2282> MagBo: if you understand arrow, currying is just right-associativity of it
10:52:09 <MagBo> fread2282: yes.
10:52:13 <nv2525> just to be sure, can i get your explanations of the arrow?
10:52:16 <MagBo> But nv2525 doesn't understand arrow.
10:52:41 <fread2282> nv2525: a -> b is a function that takes an a and returns a b
10:53:29 <nv2525> pretty much, the right side of the arrow is just an output of the input we have put in?
10:57:06 <fread2282> nv2525: yes
10:57:07 <fread2282> nv2525: functions only take one argument
10:57:38 <nv2525> oh i think i get it a little better
10:57:44 <fread2282> so the way we do multiple arguments is by returning a function that tkes the next argument
10:58:10 <nv2525> oh that makes much more sense. so left associative is for arrows?
11:00:16 <fread2282> nv2525: a -> b -> c is a -> (b -> c)
11:00:31 * hackagebot structured-haskell-mode 1.0.19 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.19 (ChrisDone)
11:00:33 * hackagebot hakyll 4.6.5.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.5.0 (JasperVanDerJeugt)
11:00:41 <thebnq> examples are good
11:00:46 <nv2525> are we applying the concept of currying to a->b->c ?
11:00:46 <thebnq> :t (+)
11:00:47 <lambdabot> Num a => a -> a -> a
11:00:51 <fread2282> nv2525: right associative
11:00:56 <thebnq> :t (+3)
11:00:57 <lambdabot> Num a => a -> a
11:01:38 <fread2282> :t (+) 3
11:01:39 <lambdabot> Num a => a -> a
11:02:13 <thebnq> good idea
11:02:46 <fread2282> nv2525: i guess? `a -> b -> c` is the simplest function that uses currying
11:03:11 <Cale> Well, currying is the process of taking a function of type (a,b) -> c and turning it into a function of type a -> b -> c
11:03:42 <geekosaur> partial application is related to currying but distinct from it (currying enables partial application)
11:03:46 <fread2282> nv2525: right associative is that (a op b op c) = (a op (b op c))
11:04:51 <dino-> I guess maybe when using sandboxes, --prefix is ignored. At least it seems like that's what's happening so far.
11:05:50 <fread2282> nv2525: so with arrow it means that (a -> b -> c) = (a -> (b -> c))
11:07:29 <fread2282> nv2525: you can write mapCF with lambdas as mapCF = \_ -> (\_ -> (\xs -> []))
11:07:59 <heatsink> Variables start with a lowercase letter.  How do you use them at the beginning of English sentences?
11:08:20 <nv2525> are lambdas like anonymous variables?
11:08:35 <nv2525> and we would use them with capital letters at the beginning of English sentences @heatsink
11:08:53 <heatsink> Variables are names for things, they are never anonymous.
11:08:57 <fread2282> nv2525: anonymous functions: let f a = a in a = \a -> a
11:09:39 <nv2525> may i ask what the xs is?
11:09:39 <fread2282> let f a = a in f = \a -> a
11:10:20 <fread2282> nv2525: you had xs in mapCF _ _ xs = []
11:10:54 <nv2525> oh someone suggested i use xs, is it just representing the list?
11:11:10 <nv2525> Procian suggested it
11:11:18 <nv2525> and I've seen that syntax a lot online as well
11:11:27 <fread2282> nv2525: yep
11:11:51 <heatsink> nv2525: We generally don't convert lowercase to uppercase because that could create confusion.  For example, in linear algebra, scalars are lowercase and matrices are uppercase.  In Haskell, variables are lowercase and constructors are uppercase.
11:13:17 <heatsink> nv2525: It's a naming convention, think of the 's' as the plural form.  'x' stands for a value, 'xs' stands for many values (in the form of a list).
11:13:53 <nv2525> oh thanks heatsink :D
11:15:17 <nv2525> so if i wrote mapCF 1 2 3 [4,5,6] in ghci
11:15:51 <nv2525> it says mapCF is applied to four arguments but only has three in its type
11:16:48 <Clint> and why does this surprise you
11:16:48 <nv2525> if i did mapCF 1 2 [4,5,6] i still get an error saying it couldn't match expected type '[t0] -> t' with actual type '[c0]'
11:17:14 <Havvy> Theoretical question from somebody who has only read about Haskell, not written. How does Haskell ensure purity if I did something like `myFn := evaluateToSecond (writeLine "abc") true` ?
11:17:43 <Procian> nv2525: Try mapCF 1 (+) [2,3,4]
11:18:05 <nv2525> Thanks Procian, I get an output of []
11:18:26 <thebnq> Havvy: the type signature
11:18:35 <cmccann> Havvy: I'm not sure what that's supposed to do, I think your pseudocode is a bit too pseudo for me
11:18:59 <myfreeweb> Havvy: (writeLine "abc") is an IO action, so you can only use that in an IO action
11:19:04 <cmccann> Havvy: that said anything involve a "writeLine" function is probably going to have IO in its type
11:19:14 <Procian> nv2525: I think the output should be [3,4,5]
11:19:25 <heatsink> nv2525: From the way you defined the function, can you see why the output is []?
11:19:47 <Havvy> evaluateToSecond := a -> b -> b (and just evaluates to the second argument passed in)
11:19:52 <nv2525> I did define it as saying the output would result in an empty list right?
11:19:57 <heatsink> right
11:19:59 <nv2525> so should I change the empty list to something like ys?
11:20:29 <nv2525> or does it have to be xs again since ys is not in the scope
11:20:30 <cmccann> Havvy: simply evaluating (writeLine "abc") won't do anything
11:20:31 <thebnq> Havvy: oh in that case the action is not executed
11:20:35 <thebnq> yea
11:20:43 <heatsink> nv2525: First, you should change both _ to variable names
11:20:55 <Havvy> thebnq:  Why not? Laziness?
11:21:31 <cmccann> Havvy: no, an IO action like that is just an opaque value as far as "pure" code is concerned
11:21:34 <heatsink> nv2525: for example, mapCF shared_value converter xs = ...
11:21:54 <cmccann> Havvy: to actually execute it the way you're expecting, it needs to be explicitly sequenced in something that gets indirectly called from the entry point
11:22:12 <heatsink> nv2525: Then you need to figure out how to write the value you want in terms of the variables you have, which are shared_value, converter, xs, and global variables.
11:22:38 <heatsink> nv2525: Is this your first time writing a function in Haskell?
11:22:40 <Havvy> cmccann:  Right, it should return an IO whatever, but then I pass it to a function that takes it but ignores it, and just return `true`.
11:23:01 <myfreeweb> Havvy: the runtime executes the main IO action at the beginning; all other IO actions are executed from IO actions only
11:23:02 <cmccann> Havvy: well, if you pass it to a function that truly ignores it won't get evaluated at all
11:23:25 <nv2525> module Main where
11:23:25 <nv2525> mapCF :: a -> (a -> b -> c) -> [b] -> [c]
11:23:25 <nv2525> Yes heatsink it is
11:23:30 <cmccann> Havvy: but if you use seq or the like to force evaluation, it still won't perform the IO
11:23:50 <nv2525> if i had written this as mapCF x y xs = zs
11:24:27 <Havvy> cmccann:  Why not? What prevents it?
11:24:39 <heatsink> nv2525: the compiler would report an error because zs is not defined
11:24:43 <myfreeweb> Havvy: nothing prevents it but nothing does it
11:25:19 <nv2525> mapCF x y xs = xs sadly gives me an error as well, it says both b and c are rigid types bound by the type signature for mapCF
11:25:33 <nv2525> expected type: [c] actual type: [b]
11:25:37 <nv2525> is there any way i can fix this?
11:25:39 <myfreeweb> Havvy: the only IO action that ever gets executed is main
11:25:59 <cmccann> Havvy: it just doesn't, in the same way that a program doesn't do anything if you never run it
11:26:08 <heatsink> nv2525: Okay, now we're at the stage where you need to formulate what you want to do as code.
11:26:29 <myfreeweb> Havvy: and main is usually a sequence of other actions
11:26:37 <Havvy> So the IO that comes from main is special then.
11:26:46 <heatsink> nv2525: Can you explain what mapCF should do?  Possibly with example inputs and outputs?
11:27:00 <cmccann> Havvy: in the same way that main itself is special, in haskell or any other language
11:27:03 <dmwit> heatsink: yes, very special
11:27:21 <heatsink> What, dmwit?
11:27:26 <cmccann> dmwit: was that meant for Havvy?
11:27:35 <dmwit> heatsink: misnick, sorry
11:27:48 <Havvy> cmccann:  Yeah, but it's not something obvious. But that would explain how the purity is kept.
11:28:17 <Havvy> Thanks for explaining.
11:28:21 <thebnq> Havvy: the execution model isn't the usual "do these things consecutively"
11:28:28 <thebnq> i suppose that assumption trips the intuition
11:28:56 <cmccann> Havvy: it's not really that different from any other language, you just have to be explicit about what gets run
11:29:02 <Havvy> thebnq:  No, it's not. And that's one of the reasons I don't generally try to write Haskell. I don't want to go and learn how to avoid thunk overflows.
11:29:19 <nv2525> mapCF :: a -> (a -> b -> c) -> [b] -> [c] i am actually getting confused with what the output should be for (a->b->c) but i know that we want to put arbitrary value a into function (a->b->c) which outputs list b and apply this list to list c
11:29:22 <nv2525> @heatsink
11:29:22 <lambdabot> Unknown command, try @list
11:29:25 <m-r-r> Hello
11:30:08 <thebnq> Havvy: memory overflow is surely a ubiquitous problem :p
11:30:26 <thebnq> just how the language lets you do it ...
11:30:30 <heatsink> nv2525: What you said about inputs and outputs isn't right.
11:30:44 <m-r-r> How can I convert a string to an integer ?
11:31:00 <HeladoDeBrownie> @type readMaybe
11:31:00 <fread2282> :t map
11:31:01 <lambdabot> (a -> b) -> [a] -> [b]
11:31:01 <lambdabot> Not in scope: ‚ÄòreadMaybe‚Äô
11:31:05 <nv2525> this example may be a bit more complicated than i thought, if i had a simpler one, do you think you could help me out @heatsink
11:31:22 <HeladoDeBrownie> m-r-r, use readMaybe, which can give you a Maybe Integer, so you can handle if it fails
11:31:27 <dmwit> Havvy: But don't you want to go and learn how to separate the concerns of generating structures from the concerns of consuming them?
11:31:31 <Havvy> But at the same time, I care deeply about programming, and I was trying to explain the IO type in ##javascript earlier, and found some holes in my understanding of it. But luckily the asker was just asking how usages of monads, so I didn't have to explain the purity requirements other than saying they were unrelated to it being a monad.
11:31:36 <dmwit> Havvy: That is the payoff laziness gives: increased modularity.
11:31:38 <Procian> nv2525: You want to change [b] into [c], but you've got a -> b -> c. You need to apply this a -> b -> c to an argument a so that you can get hold of b -> c.
11:31:45 <cmccann> Havvy: tbh avoiding thunks piling up doesn't seem to give most people that much trouble
11:31:52 <Procian> nv2525: Where does this a come from? There's only one possible place.
11:31:53 <HeladoDeBrownie> m-r-r, i think it's in Text.Read
11:32:04 <dmwit> cmccann: (But on the other hand, when the problem *does* come up, it's incredibly frustrating.)
11:32:06 <cmccann> Havvy: there are a few irritating gotchas that beginners often stumble into but that's all
11:32:15 <nv2525> the a comes from the first a in the function right Procian?
11:32:17 <Havvy> dmwit:  I do, but I want to master the ownership/lifetimes of Rust first.
11:32:27 <heatsink> nv2525: For learning functional programming, it's better to start by writing simple number and list processing functions.
11:32:51 <m-r-r> HeladoDeBrownie: I fill find it on Hayoo, I think.
11:32:52 <Procian> nv2525: Yep. That's the only a you have.
11:32:53 <Havvy> (Unfortunately, ever feature I learn just makes me annoyed at using whatever language I'm using at the time, no matter what.)
11:33:10 <HeladoDeBrownie> m-r-r, here you go http://hackage.haskell.org/package/base-4.7.0.2/docs/Text-Read.html#v:readMaybe
11:33:21 <nv2525> I think I'll get back to that one if I figure this one out. This one might be simpler
11:33:23 <heatsink> nv2525: The function you're trying to write is polymorphic and higher-order.  Each of those concepts takes some effort to learn.  It will be easier if you learn some Haskell programming first.
11:33:24 <nv2525> Write a function trifecta :: (a -> b) -> (b -> c) -> (c -> d) -> a -> d that
11:33:24 <nv2525> takes 3 functions and composes them into a function that takes a value and produces
11:33:24 <nv2525> a value. When writing tests, include some that have all the types different.
11:33:36 <nv2525> so far i have module Main where
11:33:36 <nv2525> trifecta :: (a -> b) -> (b -> c) -> (c -> d) -> a -> d
11:33:41 <m-r-r> HeladoDeBrownie: Thanks, that's just what I was looking for :-)
11:33:46 <dmwit> Havvy: You want to avoid learning how to write memory leaks by learning how rust solves memory leaks...?
11:33:59 <nv2525> but i cant come up with an accompanying binding for trifeca
11:34:04 <nv2525> *trifecta
11:34:05 <cmccann> Havvy: well, Haskell has lots of new things to learn, so you know where to come if you ever want an infinite supply of annoyance inspiration :D
11:34:30 <Havvy> cmccann:  I do read Haskell articles every once in a while. So there's a few things already.
11:34:43 <dmwit> Wow, that sentence was a mess.
11:34:46 <dmwit> Let me try again.
11:35:03 <heatsink> nv2525: Did you get mapCF and trifecta from a tutorial?
11:35:11 <dmwit> You want to avoid learning how to avoid memory leaks in Haskell by learning how to avoid memory leaks in another language?
11:35:26 <cfoch> when I list paxkages installed using "cabal list", does it list all haskell packages or only the ones that were installed with Cabal?
11:35:26 <HeladoDeBrownie> dmwit, that is not what i was expecting the meaning of that sentence to be XD
11:35:32 <nv2525> I got it as a practice problem from my professor
11:35:33 * hackagebot hlwm 0.1.0.0 - Bindings to the herbstluftwm window manager  http://hackage.haskell.org/package/hlwm-0.1.0.0 (hpdeifel)
11:35:55 <Procian> nv2525: You can start with: trifecta f g h x = ...
11:36:03 <Havvy> dmwit:  Nah, Rust's ownership/lifetime system cannot protect me from memory leaks in a Garbage Collected language, since the leaks in those languages happen for other reasons.
11:36:25 <Procian> You want to apply a function to x. x has type a. There is only one function that takes an a.
11:37:13 <heatsink> nv2525: Have you done generic programming in any language?  trifecta is really exercising your ability to reason about generic code.
11:37:31 <nv2525> I've done a bit of generic programming in C
11:37:32 <heatsink> Reasoning like what Procian just wrote.
11:37:41 <nv2525> but overall i'm a very poor programmer :(
11:38:08 <Havvy> dmwit:  Instead, it'll let me think more strongly about who owns what in the ugly shared mutable programs.
11:38:53 <dmwit> Havvy: A friend pointed out to me in PM that using a system with memory management constraints can indeed be a good way to learn how to avoid memory leaks for the same reason a good type system help you avoid writing type errors. Which seems like a good point to me.
11:39:40 <heatsink> nv2525: Okay.  Suppose I have x1 :: Int; f1 :: Int -> Bool; f2 :: Bool -> Int.  Based on the types, can you tell me what function calls I can do with f1, f2, and x1?
11:39:44 <Procian> nv2525: Or something's just not clicked yet, and I'm a very poor explainer.
11:40:05 * HeladoDeBrownie wonders how feasible static determination of maximum possible memory usage might be
11:40:09 <sssilver> Guys, in this code ‚Äî https://github.com/benl23x5/gloss/blob/master/gloss-examples/picture/GameEvent/Main.hs ‚Äî how does `show event` on line 11 end up in `str` on line 10?
11:40:14 <HeladoDeBrownie> (not necessarily in a turing complete language)
11:40:18 <sssilver> I‚Äôm not following the connection
11:40:24 <nv2525> It's not you Procian, it's me lol
11:40:27 <Procian> HeladoDeBrownie: I'd like to know if linear logics have anything to say on the matter.
11:40:31 <nv2525> and heatsink i have to think about that
11:40:35 <nv2525> hmm
11:40:45 <dmwit> HeladoDeBrownie: Well, I recall reading about a language in which only P-time algorithms could be written. So perhaps it's feasible.
11:40:53 <Havvy> HeladoDeBrownie:  Entirely possible. You just have to disallow generative recursion.
11:41:12 <dmwit> HeladoDeBrownie: Though as I recall it was pretty restrictive, and it turned out that often you would have to write an asymptotically non-optimal algorithm to fit in all the strictures.
11:41:13 <HeladoDeBrownie> Havvy, is that different from "general recursion"?
11:42:21 <Havvy> Tail call optimized recursion (and while/for loops) can be made non-generative.
11:42:40 <nv2525> heatsink , for x1 couldn't we use a function call such as 1, for f1, could we use something like 1=1, and f2 can we use something that results in a number after being true/false?
11:42:41 <dmwit> sssilver: The connection is within the implementation of play, I would imagine.
11:43:12 <Procian> I'm wondering if it's possible to make a linear language where basic operations such as "add 1" require a memory resource as an additional argument: it's not the case that every number has a successor. It's the case that for any number, if you have more space in the universe, I can construct its successor.
11:43:21 <dmwit> sssilver: You give a function that tells how to update the world state on each event (that's the `\event _ -> show event` bit), and a function that tells how to draw the current state of the world (that's the `\str -> ...` bit).
11:43:37 <dmwit> sssilver: Makes sense that the current state of the world gets fed to the rendering function, no? =)
11:43:41 <Havvy> HeladoDeBrownie:  Space rocket programs use (have used?) this constraint.
11:43:43 <cmccann> Procian: a straight-forward linear logic-based type system would definitely put some constraints on memory use but I'm not sure how helpful they'd be in practice
11:44:18 <Procian> cmccann: I'd only be thinking about it from a formal verification angle.
11:44:24 <cmccann> Procian: I suspect it'd end up being some combination of too restrictive by default and too permissive when any restrictions are lifted
11:44:26 <heatsink> nv2525: In C, a function call looks like sin(x).  In Haskell, it looks like sin x.
11:44:37 <cmccann> Procian: kind of like the whole IO sin bin thing in Haskell, really
11:44:47 <heatsink> nv2525: The things you wrote are not function calls.
11:44:57 <sssilver> dmwit: regardless of the return type of the event function?
11:45:02 <Procian> cmccann: Besides, in linear logic, as in intuitionistic logic, you can always just *assume* things are more "normal."
11:45:05 <nv2525> oh, may i see an example of a function call
11:45:13 <Procian> For instance, you could still write a program that says "assuming infinite space..."
11:45:37 <dmwit> sssilver: Well, I would imagine it lets you pick any type you like as your world state. That type will have to be the same in all the places it's used, but can be anything.
11:45:52 <heatsink> nv2525: sin x
11:46:01 <heatsink> That calls 'sin' with argument 'x'
11:46:02 <sssilver> dmwit: this is the most awkward way of programming a game engine I‚Äôve ever come across ^.^
11:46:08 <dmwit> sssilver: This is just a guess based on what I know about Haskell and graphics libraries, by the way; I haven't actually used gloss or looked at its documentation.
11:46:09 <Havvy> Can't you still write it as `sin(x)` in haskell?
11:46:29 <Procian> cmccann: I think it would be different to the IO sin bin. I'd say it'd be more like what you have in idris and Agda. They're quite loose with dependent types when they're not so bothered about strong theorems.
11:46:30 <Havvy> Just that would be highly unidiomatic?
11:46:36 <cmccann> Procian: yes. the trickier bit is assuming finite but partly unspecified space use
11:47:00 <Procian> But if someone says they've written a blog engine in Coq that guarantees all requests are executed in finite time, I kinda want to know that "finite time" doesn't extend to "age of the universe."
11:47:20 <dmwit> sssilver: But I'm, let's say, 80% confident of myself. If I relaxed "any type" to "any type that implements some type classes" I might bump it to 95% confident.
11:47:25 <cmccann> Procian: I dunno, linear logic (if you're going all the way with it) seems very different in character from dependent types
11:47:57 <myfreeweb> Havvy: well, you can write that, but the parens aren't special there
11:48:35 <HeladoDeBrownie> i had a teacher who taught us to do that in ocaml. it made me cringe every time
11:48:36 <Procian> cmccann: It is different. But the point is that you can ignore linear constraints and fallback to intuitionistic logic when you feel like it, by just shoving a bang in front of your types.
11:48:39 <myfreeweb> Havvy: you can write ((sin(((1))))) even
11:48:41 <cmccann> Procian: I actually recall reading about a contest once where the goal was to write a program that would run for the longest finite length of time.
11:48:43 <dmwit> Havvy: You can write it that way, but `foo(x,y)` is not a merely unidiomatic spelling of `foo x y`.
11:49:17 <Procian> You're not forced to think linearly. Similarly, dependent typing doesn't force you to use it.
11:49:36 <Procian> cmccann: Busy beavers are pretty similar, right?
11:49:39 <myfreeweb> Havvy: just putting parens around anything works like in math: ((3) + (2)) is the same as 3 + 2
11:49:41 <sssilver> dmwit: so when you read this doc ‚Äî http://hackage.haskell.org/package/gloss-1.9.2.1/docs/Graphics-Gloss.html#v:play ‚Äî how do you read the `world` part? what is it?
11:49:51 <sssilver> dmwit: ‚Äòany type‚Äô?
11:50:06 <Havvy> myfreeweb:  Yeah, that's what I was thinking.
11:50:07 <dmwit> sssilver: It can be any type, so long as all three functions agree on which type is used in the appropriate spots.
11:50:29 <sssilver> got it, thanks dmwit!
11:50:33 * hackagebot hlwm 0.1.0.1 - Bindings to the herbstluftwm window manager  http://hackage.haskell.org/package/hlwm-0.1.0.1 (hpdeifel)
11:51:23 <Procian> sssilver: It's not a million miles from the average game engine framework. You've got a fixed-update function and a render function.
11:51:29 <cmccann> Procian: actually, I'm not convinced that un-banging a linear type should be implicit
11:51:36 <Procian> In OO, it's callbacks. Here, you just pass functions.
11:52:50 <t4nk371> is someone interested in coding a small interpreter for money?
11:53:23 <jmcarthur> t4nk371: is it homework?
11:53:27 <cmccann> Procian: er, I might be getting the exponential modalities backwards in my head
11:53:52 <t4nk371> its a littlebit bigger
11:53:56 <cmccann> Procian: but anyway, I think it makes more sense to treat the rules around those as representing explicit operations that either allocate or release memory
11:54:03 <jmcarthur> t4nk371: but it's homework.
11:54:08 <suppi> t4nk371, I'm doing in right now for free :9
11:54:10 <cmccann> Procian: assuming that memory restrictions are what you want to talk about with your types here
11:54:20 <t4nk371> yes
11:54:31 <heatsink> nv2525: Are you still there?
11:54:32 <dmwit> how tall are the monies
11:54:37 <nv2525> hi heatsink i still am
11:54:44 <dmwit> they have to be tall for unethical things, see
11:55:06 <Procian> cmccann: Yeah, I want to talk about memory restrictions. But the point about being able to write code with bangs in it means you can say "hey, I (like just about every other programmer on this planet) don't care about statically enforcing memory restrictions", and then you can use whatever linear library code you want.
11:55:54 <cmccann> Procian: yes, and that's what I'm comparing to the IO sin bin
11:56:33 <Procian> cmccann: I'd compare it to the way dependent types are used.
11:56:36 <heatsink> nv2525: Can you tell me what function calls are allowed using the variables with signatures x1 :: Int; f1 :: Int -> Bool; f2 :: Bool -> Int
11:56:48 <Procian> (or, more specifically, the way dependent types are *not* used)
11:56:57 <edwardk> @remember Cale <Cale> I really wish that GL tried a little less to operate the same way that a Rubik's cube does.  <cmccann> also, if you don't start with the correct sequence of 20+ moves every face of the cube is plain black
11:56:57 <lambdabot> Good to know.
11:57:19 <Havvy> Alright, thanks for your help with my questions. Have a nice rest of your day.
11:57:36 <cmccann> edwardk: I think it loses something without your comment between those, but that'd be a bit too lengthy I guess
11:57:42 <edwardk> yeah
11:57:55 <nv2525> I'm actually not too sure heatsink
11:58:06 <cmccann> edwardk: if only for the context of my "also"
11:58:31 <nv2525> would a function call for x1 be add?
11:59:24 <dmwit> My favorite bit of OpenGL writing: http://dmalcolm.livejournal.com/2433.html "40 ways to get a blank, black screen"
11:59:47 <cmccann> Procian: in any case, my point was that it feels to me like there's no middle ground between linearity (with constant memory use, presumably) and all-bets-are-off bangify-all-the-types code that might as well not be linear at all
12:00:12 <heatsink> nv2525: Which of these three expressions contains a function call? 1: "x1 = 1"; 2: "x1 f1"; 3: "\x -> x1"
12:00:18 <mniip> heatsink, f1 x1, f2 $ f1 x1, f1 $ f2 $ f1 x1
12:00:20 <cmccann> dmwit: pretty sure that's what I'm always half remembering when I make jokes about rendering a black screen
12:00:33 * hackagebot angel 0.5.1 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.5.1 (MichaelXavier)
12:00:45 <nv2525> heatsink 1?
12:00:50 <heatsink> mniip: Right.  I'm trying to teach nv2525 to reason about types.
12:00:55 <mniip> ah
12:01:28 <heatsink> nv2525: ok, what function is being called in 1, and what arguments are being passed to it?
12:01:44 <mniip> heatsink, (sidenote: 1 is a call to 'fromInteger 1')
12:01:50 <Procian> cmccann: I think I'd start with all-bets-are-off, until I wanted to prove guarantees about memory use. And then I might want guarantees about any library code I was using, and start looking to strengthen those. But this, to me, seems like a standard theorem proving problem.
12:02:26 <Procian> You can't prove strong theorems about high-level code unless you have the lemmas all the way down. But you can still write the code.
12:02:26 <nv2525> I am not sure myself heatsink :(
12:02:46 <cmccann> Procian: perhaps. it's all very hypothetical since I'm not aware of any language that really pushes these ideas as far as possible
12:03:09 <cmccann> Procian: only a handful of languages with some bits of linearity tacked on one side to varying degrees of success
12:03:31 <Procian> cmccann: Idris type-classes come with verified and unverified versions, with the idea that you stick to unverified unless you want the theorems. I think you could do the same with linearity.
12:03:36 <bitemyapp> Procian: Idris is trying to embed uniqueness typing into their language.
12:03:39 * cmccann won't be satisfied unless he can define data structures using ‚Öã
12:03:43 <dmwit> Guru uses a linear type system to ensure that reference-counting garbage collection actually works.
12:04:01 <bitemyapp> depending on how they implement the linearity, it seems like it might be possible to determine peak memory usage using that.
12:04:59 <Procian> bitemyapp: Cool! I definitely need  be paying more attention to these guys.
12:05:13 <heatsink> nv2525: A function, for our purposes, is a piece of code that can be called.  A function is passed input values when it is called, and it returns an output value.
12:05:41 <bitemyapp> Procian: it's possible similar could happen in Haskell.
12:05:45 <cmccann> Procian: at one point I was working on some brainstorming notes for a simple ML-style language based on linear logic as the starting point
12:05:47 <nv2525> function x1 is being called, and the argument passed to it is 1?
12:05:54 <nv2525> @heatsink
12:05:54 <lambdabot> Unknown command, try @list
12:05:56 <bitemyapp> Procian: but usually when you care about memory usage you use something like Atom, Ivory, etc.
12:06:01 <cmccann> Procian: but I got hung up on syntax, heh
12:06:10 <heatsink> nv2525: There is no function call there.
12:06:33 <bitemyapp> Procian: Clean had uniqueness types, it seems to me similar could happen in Haskell. I just don't know how much interest there is.
12:06:47 <heatsink> nv2525: An example of a function is 'sin'.  When you call 'sin' with a number, it outputs a number.
12:06:52 <heatsink> > sin 0.6
12:06:53 <lambdabot>  0.5646424733950354
12:06:56 <bitemyapp> Procian: Idris is chasing this because they really want it to be a safe systems language, Haskell is mostly competing with the Java/Go/Python/Ruby/Scala set.
12:07:20 <bitemyapp> Procian: where expressiveness is often prized over other things.
12:07:36 <heatsink> nv2525: The function is sin, it is called with input is 0.6, and the output of the call is 0.564...  Can you see where I ran the function call and got the output?
12:08:37 <bitemyapp> Procian: there are others in the community that would care about this, but we don't have an Edwin Brady actually trying to hunt that mammoth.
12:08:45 <Procian> bitemyapp: I'm trying to think of it from a point of view where you can say to clients: feel free to swap in different implementations of X, and still keep your promises.
12:08:59 <heatsink> edwardk: I have a question about bound
12:09:07 <nv2525> yes i think i see it
12:09:10 <nv2525> Which of these three expressions contains a function call? 1: "x1 = 1"; 2: "x1 f1"; 3: "\x -> x1"
12:09:11 <Procian> I need to talk to that guy more. I've met him a few times at Edinburgh perl mongers.
12:09:12 <nv2525> so for this one
12:09:20 <nv2525> would x1 f1 be a function call heatsink?
12:09:34 <delrik> omg
12:09:40 <heatsink> edwardk: To use bound, is it necessary that an expression can always be substituted for a variable?
12:09:54 <bitemyapp> Procian: I had pretty good luck in my last Haskell contract laying down some foundational types that the client then followed along with.
12:10:06 <delrik> I'm having SASL issues with my tethered phone, I thought I wouldn't be able to idle in here while on the go.  /crisis-averted
12:10:13 <bitemyapp> Procian: not as strong as one can assert in a more expressive system, but nothing to sniff at either.
12:10:20 <heatsink> nv2525: Yes, that is a function call.  The function is x1, and it is called with input is f1.
12:10:33 * hackagebot lowgl 0.2.0.1 - Basic gl wrapper and reference  http://hackage.haskell.org/package/lowgl-0.2.0.1 (evanrinehart)
12:10:33 <Procian> bitemyapp: Ah, but I'm thinking of worse. A case where your client is potentially the world and they might be malicious.
12:11:11 <delrik> can anyone help me determine the complexity of this algo?  I'm assuming its quadratic with respect to the depth of the tree.
12:11:13 <delrik> http://pastie.org/9948307
12:11:15 <nv2525> it seems more clearer now thanks heatsink
12:11:28 <nv2525> so for trifecta :: (a -> b) -> (b -> c) -> (c -> d) -> a -> d
12:11:34 <heatsink> nv2525: However, with the signatures of x1 and f1 that I wrote earlier, that function call would have a type error if you try to compile it.  Can you explain the type error?
12:11:37 <nv2525> we did something like trifecta f g h x = ...
12:11:45 <nv2525> hmm the type error
12:12:02 <tiger717> @faq What is the answer for the life, universe, everything?
12:12:02 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:12:18 <tiger717> Too bad :D
12:13:27 <nv2525> i'm actually not sure what the type error would be heatsink
12:14:13 <hiptobecubic> There's an interesting problem on hackerrank (https://www.hackerrank.com/contests/codesprint5/challenges/matrix-tracing) that I think they want you to solve with dynamic programming. A little brain power shows that you're actually just computing a bunch of binomial coefficients. The problem is that for large coefficients like (2053 `choose` 1039) I can't find an implementation fast enough :(
12:16:07 <heatsink> nv2525: You will probably learn better by reading through "Introduction to Haskell" here http://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html and doing the homework there too.
12:16:52 <heatsink> nv2525: The introduction explains types and function calls, and the homework is a way to get comfortable by practicing in GHCi
12:17:44 <heatsink> nv2525: Based on what you know now, you're not ready to understand trifecta or mapCF.
12:18:00 <nv2525> thanks for youe help heatsink
12:18:07 <nv2525> *your
12:18:12 <nv2525> i'll look at the link you have provided
12:18:19 <nv2525> i appreciate all of the help you guys have provided me
12:19:43 <heatsink> I'm glad to help.  Keep at it.  Keep in mind that you're also learning how to learn; knowledge will come faster after a while.
12:20:29 <hiptobecubic> When did haskell.org switch over?
12:23:12 <zipper> hiptobecubic: It looks good ey?
12:23:20 <zipper> hiptobecubic: Saw it on twitter
12:23:58 <hiptobecubic> it is much better, yes
12:24:11 <lpaste> RyanGlScott pasted ‚Äúderiving Show mystery‚Äù at http://lpaste.net/120556
12:24:40 <RyanGlScott> I'm having some trouble figuring out why "deriving Show" isn't working for a particular case.
12:24:43 <zipper> Rackspace are hosting?
12:24:57 <zipper> Does rackspace employ haskellers?
12:25:24 <zipper> RyanGlScott: How about you write your own show instance? It's the easiest typeclass IMO
12:25:40 <shachaf> RyanGlScott: You wrote "instance HKConstraint f a b => Show (HKLR f a b) where show = undefined"
12:25:42 <bitemyapp> zipper: a few.
12:26:01 <RyanGlScott> zipper: I'll admit the examples I gave are contrived, since I'm trying to understand how GHC's deriving mechanism works so I can copy its behavior with Template Haskell.
12:26:01 <shachaf> It's complaining that there isn't an "instance HKConstraint f a b" which it needs for "instance Show (HKLR f a b)"
12:26:39 <csd_> Hoping someone can help me with this as its really bugging me. In the following code, function `ls` eventually gets called, returning a function taking a FoldM, and is applied to (Control.Foldl.generalize (pure())), with returns a generic FoldM IO a (). Inside `ls`, there is a line that binds part of the FoldM (line 379). My question is, what does this statement even mean, given that the monad provided to ls basically empty as far as
12:26:43 <RyanGlScott> The weird thing is that it can infer Constraint a b => Show (WrapLR a b), but not HKConstraint f a b => Show (WrapHKLR f a b)
12:26:43 <csd_> https://github.com/Gabriel439/Haskell-Turtle-Library/blob/master/src/Turtle/Prelude.hs
12:27:53 <mleduc> I'm looking for a good introduction of monad transformers, does anybody have a resource in mind ?
12:28:17 <shachaf> RyanGlScott: You can use StandaloneDeriving: deriving instance HKConstraint f a b => Show (WrapHKLR f a b)
12:28:21 <RyanGlScott> Is there some fundamental limitation of the deriving machinery that prevents it from inferring the instance context when higher-kinded type parameters are involved?
12:28:55 <shachaf> RyanGlScott: In order to test this I copied your whole ghci session a line at a time to avoid copying the prompts. :-(
12:28:56 <RyanGlScott> shachaf: I know, but I'm deliberately trying to avoid  StandaloneDeriving. I'm trying to extend deriveShow from my text-show package to be able to infer more instance contexts.
12:29:12 <shachaf> RyanGlScott: But it seems to work.
12:29:24 <shachaf> RyanGlScott: Ah. I don't think "deriving Show" will do it.
12:29:44 <RyanGlScott> shachaf: That's the heart of the matter. Why does the first example work, but the second example get rejected?
12:32:33 <dmwit> mleduc: All About Monads is pretty good
12:32:37 <dmwit> ?where aam
12:32:37 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
12:35:34 * hackagebot monad-parallel 0.7.1.4 - Parallel execution of monadic computations  http://hackage.haskell.org/package/monad-parallel-0.7.1.4 (MarioBlazevic)
12:35:36 * hackagebot monad-coroutine 0.9.0.1 - Coroutine monad transformer for suspending and resuming monadic computations  http://hackage.haskell.org/package/monad-coroutine-0.9.0.1 (MarioBlazevic)
12:36:23 <RyanGlScott> Let me ask a slightly different question then. From the Haskell 98 report: https://www.haskell.org/onlinereport/derived.html#derived-appendix
12:36:38 <RyanGlScott> "Each derived instance declaration will have the form:  instance (cx, cx') => Ci (T u1 ... uk) where { d } "
12:36:50 <mleduc> dmwit: thx, i'll read it
12:36:51 <RyanGlScott> The context cx' is the smallest context satisfying point (2) above (There is a context cx' such that cx' =>C tij holds for each of the constituent types tij.)
12:37:18 <RyanGlScott> Is there a function in the GHC API that calculates cx'? Basically, I want to replicate that with Template Haskell.
12:38:18 <dmwit> RyanGlScott: Note that this specification is not a correct one for all type classes.
12:38:40 <dmwit> RyanGlScott: (And, as you noted, is also not an algorithm. Don't know the answer to whether this algorithm is exposed by the GHC API.)
12:39:33 <dmwit> e.g. even this specification is probably too restrictive for Bounded
12:40:13 <RyanGlScott> Actually, I might have found something relevant: https://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/TcDeriv.html
12:40:26 <RyanGlScott> If only I knew how to read its source code :)
12:42:16 <juancaman> I'm still quite new on haskell and i'm constantly asked what is a monad
12:42:27 <EvanR> refuse to answer
12:42:28 <juancaman> what would you answer... a short answer
12:42:33 <juancaman> XD
12:42:42 <EvanR> it must be kept a cabal secret
12:43:29 <juancaman> so this is my answer https://twitter.com/JuxnCxrlosP/status/518164635598725120
12:43:46 <EvanR> nice
12:43:48 <mleduc> juancaman: http://www.haskellforall.com/2014/03/introductions-to-advanced-haskell-topics.html#monads is what I would give you as an answer
12:44:15 <shachaf> juancaman: What is the point of that?
12:44:35 <shachaf> I think the FAQ has a good answer.
12:44:37 <shachaf> @faq
12:44:38 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:44:56 <juancaman> how do you explain new people on this, what is a monad.
12:45:17 <dmwit> ?google you could have invented monads
12:45:18 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
12:45:18 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
12:45:22 <shachaf> You give the answer in the FAQ, e.g. https://wiki.haskell.org/FAQ#What_should_I_know_before_trying_to_understand_monads.3F
12:45:24 <juancaman> most of my friends are just java dudes
12:45:25 <shachaf> On the other hand "you could have invented monads" didn't help me at all.
12:45:29 <dmwit> Or one of the hundreds of other available monad tutorials.
12:45:40 <dmwit> Which are extensively documented on the wiki and Google.
12:45:42 <voidzero> ohey! it's this discussion again
12:46:26 <dmwit> Though perhaps I am being too hard-nosed. I have not had to explain what a monad is to anybody in person.
12:47:52 <juancaman> you could have invented monads was quite confusing at the beginning
12:47:59 <juancaman> i was very confused with javascript
12:48:30 <EvanR> dmwit: i can tell you it sucks, because they already expect not to be able to understand the answer, and i already know this whole issue is way overblown, so i just get stuck
12:49:20 <EvanR> im never talking about monads to anyone ever
12:49:46 <TallerGhostWalt> EvanR: lol
12:49:53 <m-r-r> Is there a function like (!!) which returns Nothing if the index is out of bounds ?
12:50:14 <delrik> I doubt that Monads are what confuses people, the concepts and applications (in the usual cases) are pretty easy to grasp.  I think the majority of the confusion stems from a lack of understanding with respect to how Monads fit within the type system (such as with mtl) , and finally pulling values out of monads (running them)
12:50:39 <EvanR> and the idea that you pull values out of monads
12:50:43 <TallerGhostWalt> delrik: yeah I agree, everyone wants that (m a) -> a
12:50:47 <dmwit> ?? m-r-r: ?where safe
12:50:47 <lambdabot>  m-r-r: http://www.cs.york.ac.uk/fp/haddock/safe/Safe.html
12:50:51 <dmwit> uh
12:50:54 <dmwit> ?hackage safe
12:50:54 <lambdabot> http://hackage.haskell.org/package/safe
12:51:17 <dmwit> Oh, what, it's not in there?
12:51:23 <quchen> Why doesn't GHCi hang when I ask it for the type of "id id id id ‚Ä¶ ()"? The type of the id functions should grow exponentially from the right to the left, no?
12:51:29 <lightstep> part of the problem is that Monad is the first typeclass people encounter that doesn't exist in other languages
12:51:44 <dmwit> Oh, yeah, it is. atMay
12:51:49 * dmwit is really bumbling this answer
12:51:50 <platz> https://twitter.com/pchiusano/status/565899718514204673
12:51:59 <delrik> TallerGhostWalt: exactly =)
12:52:00 <quchen> id () -- leftmost id :: () -> ().  id id () -- leftmost id :: (() -> ()) -> (() -> ()). And so on
12:52:10 <dmwit> quchen: because sharing
12:52:16 <delrik> things made much more sense for me when I looked at Monads in the context of join instead of bind
12:52:27 <dmwit> quchen: The type is not () -> (); it's (a -> a) where (a) is a ptr to ().
12:52:48 <dmwit> quchen: So the top type is a -> a, with a pointing to b -> b, with b pointing to c -> c, etc.
12:53:03 <quchen> Aaah.
12:53:46 <jibi> hi, what book would you advise after finishing lyah?
12:54:09 <juancaman> real world haskell
12:54:18 <TallerGhostWalt> one thing that is weird I have noticed when watching people deal with monadic types is how often the intuitions you get dealing with one, don't carry over.
12:54:31 <heatsink> In my experience, it usually isn't helpful to answer the question by explaining what a monad is.  Just like how if someone phrases their question about generic programming as "What is universal quantification?", literally answering the question won't be a satisfactory answer.
12:55:00 <TallerGhostWalt> someone finally gets how you have to do IO its Monad , then immediately wants an escape hatch for chained Eithers.
12:55:01 <mleduc> jibi: http://www.stephendiehl.com/what/ does not really answer your question but it's an extensive summary of what you need to know as an 'intermediate' haskell dev
12:55:04 <TallerGhostWalt> I see that a lot
12:55:29 <enferex> I have an IO Int and I need my function to return the String version of this.  Any suggestions?
12:55:46 <jibi> mleduc, thanks, I'll check it out
12:55:51 <EvanR> enferex: fmap show?
12:55:52 <m-r-r> dmwit: Thanks, but I think I will roll my own instead of adding another dependency to my project :-)
12:55:53 <carter> TallerGhostWalt:  isn't that called run :: Runnable m => m a -> a
12:55:54 <carter> i mdade that up
12:55:56 <carter> fmap
12:55:57 <enferex> EvanR: I tried that
12:55:57 <carter> :t fmap show
12:55:58 <lambdabot> (Show a, Functor f) => f a -> f String
12:56:23 <dmwit> enferex: And what went wrong?
12:56:30 <heatsink> decompile :: IO Int -> String
12:56:46 <delrik> the issue is further exacrebated by the hoopla around map, fmap, and the issue the Applicative Monad proposal wants to resolve.
12:57:19 <enferex> dmwit: "Couldn't match type IO with []"
12:57:28 <EvanR> can i reinterpret a storable Vector Float as a Vector Word8
12:57:52 <dmwit> enferex: Show us a minimal (non-)working example, together with the exact error message.
12:57:55 <dmwit> ?paste
12:57:55 <lambdabot> Haskell pastebin: http://lpaste.net/
12:57:57 <edwardk> can somebody skim through https://www.fpcomplete.com/user/edwardk/snippets/fmap and spot typos and the like before the distribution on it gets too wide?
12:57:58 <enferex> dmwit: Okie
12:58:06 <platz> does AMP resolve liftM?
12:58:18 <quchen> platz: "Resolve"?
12:58:22 <edwardk> platz: under AMP liftM is a usable default definition of fmap in terms of return and (>>=)
12:58:24 <heatsink> enferex: It seems like you're trying to convert IO Int to String
12:58:34 <edwardk> platz: you no longer wind up with contexts where you have to use liftM rather than fmap, however.
12:58:40 <delrik> platz: I've only seen direct references to ensuring that Monads are treated as Applicative Functors
12:58:42 <heatsink> enferex: You can convert IO Int to IO String easily, but you can't convert to String
12:58:57 <enferex> http://lpaste.net/120559
12:59:14 <edwardk> heatsink: sure you can: foo _ = "yeah, i kinda ignored your IO action"
12:59:15 <enferex> heatsink: Ok, thanks, I didn't want to waste time going down this path
12:59:42 <the_other_cat> Hi is there something like runFunction "abc" = do functionNamedABC ?
12:59:45 <dmwit> enferex: you must `timeStr :: IO String`
12:59:53 <platz> edwardk: ah thanks, that sounds much better
13:00:05 <dmwit> enferex: There is no escaping the fact that you have done IO to compute this value, no matter how strenuously* you claim this to the compiler.
13:00:19 <enferex> dmwit: True, Ok thank you very much
13:00:20 <dmwit> enferex: Do read to the end of IRC to see what the footnote marked by * is, though. ;-)
13:00:27 <edwardk> the_other_cat: haskell doesn't ship out of the box with an 'eval' function. there are tools out there for doing so, but they are fairly limited if you come from a background like scheme or javascript and expect to be able to do that without fuss
13:00:28 <TallerGhostWalt> carter: isn't that called unsafe !
13:00:39 <carter> TallerGhostWalt: only if you provide unsafe instances :)
13:00:53 <enferex> dmwit: End of IRC?  You mean the channel topic?
13:00:55 <carter> nonemptyLIst is a monad who's run would be perfectly safe
13:01:15 <dmwit> enferex: A little joke. Reading to the end of IRC would be a long read... probably at least 20 years.
13:01:19 <mleduc> the_other_cat: if runFunction is of type (Monad m) => a -> m a the return is what you are lookinng for
13:01:26 <dmwit> enferex: Sort of a way of encouraging you to stick around. =)
13:01:30 <TallerGhostWalt> State
13:01:33 <enferex> dmwit: Oh thank you
13:01:42 <dmwit> enferex: And to hint that this is just the first approximation of the truth, but an important pedagogical one.
13:01:45 <enferex> I appreciate the kind gesture.  Been ircing for eons
13:01:46 <TallerGhostWalt> carter: is another
13:01:50 <carter> yah
13:01:50 <EvanR> last irc
13:01:51 <enferex> never heard that ;-)
13:01:52 <EvanR> _|_
13:02:10 <carter> TallerGhostWalt: prettty much every thing in tranformers
13:02:14 <TallerGhostWalt> carter: I can't imagine starting someone out with the State monad
13:02:15 <carter> well
13:02:20 <carter> yeah
13:02:24 <carter> it mind blows people
13:02:29 <TallerGhostWalt> hehe
13:02:32 <carter> esp because they think it must be slow
13:02:33 <TallerGhostWalt> in the best way
13:02:45 <carter> but with the right code, it stays in registers
13:02:50 <heatsink> edwardk: To use the bound library, is it necessary that expressions can be substituted for variables?
13:02:51 <carter> or down right evaportates
13:03:01 <TallerGhostWalt> oh very cool
13:03:04 <TallerGhostWalt> Didn't know that
13:03:15 <TallerGhostWalt> stays in registers is impressive
13:03:18 <carter> well
13:03:27 <carter> TallerGhostWalt: iorefs and stuff stay refy
13:03:36 <carter> pure things are easy to keep in registers
13:03:43 <TallerGhostWalt> i see
13:03:51 <agocorona> or ar least in the L1 cache
13:03:51 <carter> thats why do notation in indentity monad generates nice code
13:04:04 <carter> agocorona: you're spilling the beans, or regisers
13:05:39 <steamboat> @pl \i c -> (i, (f c))
13:05:39 <lambdabot> (. f) . (,)
13:05:55 <dmwit> edwardk: The only thing that wasn't clear to me in that exposition is what "$map" is, and why we're allowed to assume "$map id = id".
13:06:01 <sssilver> ROFL. Wife enters room. Her (suspicious): ‚ÄúWhat are you up to?‚Äù me: ‚ÄúHaskell.‚Äù her: ‚ÄúNo, I mean who are you talking to?‚Äù me: ‚ÄúNobody, just learning Haskell‚Äù her: ‚ÄúIt excites you to the degree that you have a smile on your face as if you‚Äôre flirting with someone?‚Äù me: ‚Äú:))‚Äù her: ‚ÄúShould I be worried?‚Äù
13:06:29 <edwardk> @free fmap :: (a -> b) -> (F a -> F b)
13:06:29 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
13:06:41 <voidzero> i'd answer "no don't worry. Haskell is strongly typed."
13:06:46 <voidzero> and watch her go 'huh' :)
13:06:58 <edwardk> that should be in the theorems for free paper, let me see
13:07:13 <agocorona> however  the fragmentation is a problem for performance in haskell programs
13:07:19 <pjdelport> voidzero: "Don't worry, it's purely functional."
13:07:21 <voidzero> "I didn't program a function that takes a wife so you're in the clear."
13:07:26 <shachaf> edwardk: Not that I know what such a type would look like -- I suspect you can't write it, but I don't really know.
13:07:41 <voidzero> pjdelport LOL
13:07:56 <sssilver> :D
13:08:03 <pjdelport> voidzero: Just don't say anything about unsafePerformIO.
13:08:22 <voidzero> yeah, way too much side effects
13:08:30 <voidzero> possible side effects*
13:09:16 <delrik> "You merely adopted functional programming, I was raised in it, molded in it... When I saw mutable state.. I was already a man"
13:09:28 <delrik> bane would be a dope haskellite.
13:09:39 <juancaman> XD
13:09:45 <TallerGhostWalt> delrik: lol
13:10:06 <juancaman> delrik: you sir deserve a cookie
13:10:22 <izohask> in "func:: (MyWriterT m w a) => w -> m ()
13:10:27 <delrik> lol thx gais.
13:10:29 <shachaf> Can y'all take all this somewhere else?
13:10:39 <izohask> what does it mean part "MyWriterT m w a)"
13:10:45 <voidzero> lighten up, shachaf.
13:11:11 <izohask> is it some constraint.. or is it something more ?
13:11:41 <pjdelport> izohask: It's a type class constraint, yes (for a monad transformer, in this case, presumably).
13:11:52 <izohask> I thought it is constraint...
13:11:53 <izohask> but
13:11:55 <shachaf> izohask: I don't know what it means in your case, but a thing on the left side of => is always a constraint.
13:12:16 <shachaf> But WriterT isn't a thing that gives you a constraint, so MyWriterT is very different from the real WriterT if that works.
13:12:52 <izohask> but what kind of contraint exactly, does it set?
13:13:14 <shachaf> You wrote that code. How should anyone else know?
13:13:37 <dmwit> izohask: It constrains the three types `m`, `w`, and `a` to be related by an instance of `MyWriterT`.
13:14:14 <izohask> dmwit: so I can predict types of these m, w, and a in body of func ?
13:14:22 <pjdelport> izohask: It's no different in principle to func :: Num a => a -> a
13:14:22 <voidzero> I read that as "where w is meant to be the w in (myWriterT m w a)"
13:14:31 <pjdelport> It's just a different type class, and types.
13:14:42 <izohask> aha
13:14:52 <izohask> great... I needed this "I read this as"
13:15:08 <pjdelport> izohask: You can't predict what the types will be, but you will know they have an instance of that type class, so you can use its methods on them.
13:15:28 <pjdelport> (In the same way that the Num version tells you that you have some Num type and can use Num methods on it.)
13:16:20 <voidzero> (a -> a) "where a can be anything" as opposed to (Num a => a -> a) "where the value for a has to be a member of the Num class"
13:17:13 <voidzero> and "can be anything", I mean that loosely, of course
13:17:18 <agocorona> a comonad is a intrafunctor in categorioids of exofactors
13:17:45 <EvanR> agocorona: you dont say?
13:17:47 <agocorona> sorry. I though that this was haskell-blah
13:17:54 * voidzero snickers
13:17:58 <bitemyapp> @karma+ sssilver
13:17:58 <lambdabot> sssilver's karma raised to 1.
13:18:14 * sssilver blinks ‚Äî what just happened?
13:18:19 <agocorona> I was a bit bored
13:18:27 <voidzero> shachaf can't stand humour, it's so illogical.
13:18:48 <voidzero> but ok, i'll zip it.
13:19:01 <sssilver> humor is logical, albeit the logic is comlicated
13:19:03 <sssilver> *complicated
13:19:27 <voidzero> True. What he said to me last time was "not contributing to anything."
13:20:35 * hackagebot hypher 0.1.3 - A Haskell neo4j client  http://hackage.haskell.org/package/hypher-0.1.3 (jetaggart)
13:22:36 <Erdos> why is so always highlighted?
13:22:52 <Erdos> someone named so in the room, maybe?
13:23:20 <Erdos> yep. nvm
13:25:22 <fread2282> Erdos: yep
13:25:35 * hackagebot hypher 0.1.4 - A Haskell neo4j client  http://hackage.haskell.org/package/hypher-0.1.4 (jetaggart)
13:25:37 * hackagebot hypher 0.1.5 - A Haskell neo4j client  http://hackage.haskell.org/package/hypher-0.1.5 (jetaggart)
13:28:29 <rasen> Hello. Does Complex i is represented as 0 :+ 1 in Haskell?
13:29:13 <geekosaur> :t (:+)
13:29:14 <lambdabot> a -> a -> Complex a
13:29:20 <geekosaur> in other words yes
13:29:33 <voidzero> > 0 :+ 1
13:29:35 <lambdabot>  0 :+ 1
13:30:05 <rasen> Thanks
13:30:20 <voidzero> :t 0 :+ 1
13:30:22 <lambdabot> Num a => Complex a
13:30:35 * hackagebot wiring 0.2.0.1 - Wiring, promotion and demotion of types.  http://hackage.haskell.org/package/wiring-0.2.0.1 (seanparsons)
13:31:18 <EvanR> > (0.9 :+ 0.1) * (0 :+ 1)
13:31:19 <lambdabot>  (-0.1) :+ 0.9
13:33:08 <orzo> > (e :: CReal)^(0 :+ (pi :: CReal/2))
13:33:09 <lambdabot>  Not in scope: type constructor or class ‚Äò/‚Äô
13:33:11 <solidus-river> hey all, when installing the deps for my paakge in a sandbox i get a warning about breaking another package, whats the recommended way of solving this?
13:33:14 <solidus-river> its not a package i need directly
13:33:20 <solidus-river> its a dependency of a package i need
13:33:32 <solidus-river> do i just force it? its a confusing message, all it really says is.. something might be wrong
13:33:46 <orzo> > (e :: CReal)^(0 :+ ((pi :: CReal)/2))
13:33:48 <lambdabot>  Couldn't match expected type ‚ÄòData.Number.CReal.CReal‚Äô
13:33:48 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
13:34:22 <orzo> solidus-river: rebuild
13:34:36 <solidus-river> orzo: this is on a fresh sandbox
13:34:51 <orzo> hm
13:34:56 <delrik> voidzero: why is that?
13:35:10 <voidzero> it means "whatever this package needs is from a different version than the one installed; if you don't mind this, let me know."
13:35:17 <voidzero> ^ solidus-river
13:35:45 <solidus-river> that wouldn't actaully break anything thorugh becasue it all pulls from within the sandbox first, correcT?
13:35:49 <voidzero> solidus-river, so the globally installed version conflicts with the one for the sandbox
13:35:50 <voidzero> yep
13:35:58 <orzo> probably more, "if you DO mind this"
13:36:12 <delrik> voidzero: I meant about sachaf? why doesnt he like humour?  I hope haskell doesn't kill your sense of humour.
13:36:13 <solidus-river> ah, kk, imo that hsould just be a warning not a failure on install
13:36:18 <solidus-river> but i guess that could disturb someone?
13:36:29 <solidus-river> seems if they are using sandbox's they are doing that to avoid that type of problem
13:36:43 <solidus-river> and understand there may be incosistencies in packages across the system
13:37:08 * solidus-river feels uncomfortable adding a --force aywhere in the default build process
13:37:16 <voidzero> delrik, dunno. I asked him in private but he did not respond. I said I thought humour does serve a function, but his contributions are also valuable. I guess he was already annoyed.
13:37:38 <voidzero> orzo, "if you don't mind the sandbox overriding the globally installed version, issue --force"
13:38:00 <orzo> oh ok, you're right then, nevermind
13:38:02 <shapr> voidzero: some humor doesn't belong on #haskell
13:38:02 <voidzero> solidus-river, hence sandboxing
13:38:09 * orzo tries to walk away without being noticed
13:38:20 <geekosaur> humor does seerve a function. some forms of humor, that function includes ostracizing someone perceived as outsider
13:38:28 <delrik> voidzero: I see. I hope he has the appropriate transform action to get increment his state.
13:38:49 <geekosaur> that's becoming increasingly common in "bro" environments, where "bro" explcitly excludes women and often excludes or marginalizes other groups
13:39:25 <delrik> yeah!
13:39:27 <voidzero> shapr, agreed. But I don't see that in here much, if at all. Sometimes it serves a social function that makes it more fun for people to stay and ask and/or help questions. I haven't seen people derailing anything, this channel is very civil and friendly for its 1500+ users, imo.
13:39:45 <shapr> voidzero: yeah, this channel mostly works, I agree
13:40:03 <cmccann> also, this IS a channel with over 1500 people. some amount of discipline is required in staying on topic.
13:40:04 <glguy> voidzero: and part of the reason the channel works is that people are actively maintaining it
13:40:14 <solidus-river> voidzero: orzo kk, thanks for the help :)
13:40:41 <delrik> I've read some very interesting things about that.  I introduce any women I know to haskell -- I think its flexibility really allows us to seperate problem solving with accounting.  And I've always found women have a pretty good intution for whole meal programming. so its a shame
13:41:25 <voidzero> shapr, I don't like badmouthing, but I just noticed shachaf responds negatively to that _any_ comment that's made with a smile, so I asked him why. I think he did contribute, so seeing him leave was also a bit of a downer.
13:41:42 <shapr> voidzero: that's not how I saw it
13:41:43 <EvanR> haha
13:42:26 <StoneCypher> i'm sad to hear shachaf left but i'm not very surprised
13:42:42 <geekosaur> no, shachaf does not respond negatively to any such comment
13:43:06 <geekosaur> but many such comments are dubious at best
13:43:14 <heatsink> voidzero: You said "lighten up, shachaf." and "shachaf can't stand humour, it's so illogical."  These say that shachaf's opinion is (1) invalid and (2) ridiculous.
13:43:28 <dmwit> shachaf is very reasonable. I have only seen him complain when something was genuinely getting in the way of #haskell being a helpful channel.
13:43:28 <rasen> is that correct? zipWith f a b = f <$> a <*> b?
13:43:48 <dmwit> rasen: Assuming that (<$>) and (<*>) are the ZipList ones, that would be okay.
13:43:51 <voidzero> heatsink, correct. I thought I was too mean with 2, so, I queried him, telling him that it sucked to see him leave.
13:43:52 <shapr> voidzero: I've talked to shachaf on and off for years, your comment seems to me to be an inaccurate sweeping generalization.
13:43:56 <dmwit> rasen: But it is not correct for bare lists.
13:44:11 <dmwit> Perhaps the side discussion could continue in #haskell-ops.
13:44:27 <dmwit> Now that there are people asking about #haskell in here.
13:44:31 <dmwit> uh
13:44:35 <dmwit> asking about Haskell, I mean
13:44:39 <shapr> yay Haskell!
13:45:01 <dmwit> > zipWith (+) [1, 10] [100, 1000]
13:45:03 <lambdabot>  [101,1010]
13:45:10 <cow_2001> woah.
13:45:12 <dmwit> > (+) <$> [1, 10] <*> [100, 1000]
13:45:14 <lambdabot>  [101,1001,110,1010]
13:45:25 <rasen> oh... I see now
13:45:28 <voidzero> shapr, i'll keep that in mind and I'll just shut up about it now. ;-)
13:45:34 <cow_2001> huhm
13:46:16 <greeny> rasen: you can imagine <$> as fmap
13:46:31 <EvanR> @src (<$>)
13:46:31 <lambdabot> f <$> a = fmap f a
13:46:45 <rasen> I knew. I just confused what <*> does
13:47:00 <EvanR> :t (<*>)
13:47:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:47:08 <EvanR> applicative function application
13:48:40 <Stratege> EvanR huh, thanks a lot.
13:48:54 <EvanR> yw
13:59:06 <imag> So I'm going through LYAH but the data type vs data constructor is still sorta confusing me
13:59:12 <imag> I tried to make a tree data type
13:59:25 <tdammers> imag: types and values live in separate namespaces
13:59:54 <tdammers> e.g., Char is a data type
14:00:02 <imag> 'a' is a value?
14:00:02 <tdammers> 'e' is a value (of that type)
14:00:05 <tdammers> yes
14:00:06 <imag> ok yeah
14:00:11 <dmwit> ?where paste
14:00:11 <lambdabot> Haskell pastebin: http://lpaste.net/
14:00:12 <imag> but mostly whats confusing
14:00:15 <imag> is doing something like
14:00:34 <imag> data Maybe a = Nothing | Just a
14:00:37 <tdammers> ah yes
14:00:39 <imag> passing a to Maybe
14:00:39 <tdammers> well
14:00:45 <imag> I understand how Maybe is used
14:00:47 <tdammers> let's forget about the a for now
14:00:55 <imag> ok
14:00:58 <tdammers> imagine that it were data Maybe = Nothing | Just
14:01:05 <rasen> Is there more general type than list for which zip can be defined?
14:01:12 <tdammers> this means that Maybe is a data type, and it can have two possible values, Nothing and Just
14:01:25 <dmwit> rasen: Definitely.
14:01:27 <tdammers> we call Nothing and Just "constructors"
14:01:41 <tdammers> clear so far?
14:01:43 <imag> yeah
14:01:47 <dmwit> rasen: One approach is as in the "these" package on Hackage.
14:02:05 <tdammers> ok, so now we make our "Just" constructor into something that takes an integer argument:
14:02:11 <tdammers> data Maybe = Nothing | Just Int
14:02:12 <dmwit> rasen: See Data.Align specifically.
14:02:33 <imag> okay
14:02:41 <tdammers> note how in the definition of "Just", the identifier "Just" is in the value namespace, but "Int" is in the type namespace
14:02:48 <heatsink> As I learned it, Nothing and Just are called "data constructors"
14:03:09 <tdammers> so, one step left to go
14:03:36 <tdammers> now we want our "Just" constructor to take an argument of any type, not specifically Int
14:03:41 <tdammers> so we use a *type variable*
14:03:53 <tdammers> instead of Just Int, we write Just a
14:04:00 <rasen> dmwit: Ideally I would like zip to work on lists and vectors
14:04:04 <tdammers> "a" is a type variable
14:04:08 <imag> okay
14:04:18 <tdammers> and in order for the compiler to accept it, we need to declare it as a parameter for our type:
14:04:23 <dmwit> rasen: It should be possible to make an instance of Align for vectors.
14:04:26 <tdammers> data Maybe a = Nothing | Just a
14:04:48 <imag> hmm oh okay
14:04:50 <imag> that makes sense
14:04:51 <imag> so
14:04:53 <dmwit> rasen: The appropriate functions probably already exist in whatever package you're using for vectors.
14:04:57 <imag> if I'm trying to make a Tree datatype
14:04:59 <imag> I could do
14:05:11 <imag> data Tree t = Leaf | Node Tree t Tree deriving (Show, Read, Eq)
14:05:22 <imag> or
14:05:30 <imag> data Tree = Leaf | Node (Tree t) t (Tree t) deriving (Show, Read, Eq)
14:05:32 <imag> rather?
14:05:35 <tdammers> not quite
14:05:45 <dmwit> imag: mix the two =)
14:05:46 <tdammers> you want your Leaf constructor to wrap a value of type t
14:05:54 <dmwit> imag: data Tree t = Leaf | Node (Tree t) t (Tree t)
14:06:04 <tdammers> and the Node constructor only needs to hold more Tree items, not t's directly
14:06:14 <dmwit> tdammers: I think his definition is fine.
14:06:24 <tdammers> well, depends on the shape of the tree you want
14:06:29 <imag> Well
14:06:31 <tdammers> I'd go with data Tree = Leaf t
14:06:34 <tdammers> oops
14:06:35 <imag> Node needs to contain a key?
14:06:43 <tdammers> I'd go with data Tree = Leaf t | Branch [Tree t]
14:06:51 <dmwit> I wouldn't.
14:06:59 <dmwit> Having values only at the leaves seems awfully restrictive.
14:07:24 <heatsink> Some trees have labeled nodes, some have labeled leaves.  It depends on what the tree is used for.
14:07:26 <tdammers> well, as I said, it depends on the shape of the tree
14:07:46 <imag> if I wanted to make one with labeled nodes for example then
14:07:53 <dmwit> imag: Another thing you can do is have two types that talk about what's stored at nodes and what's stored at leaves.
14:07:55 <imag> how could I fix my definition?
14:08:10 <dmwit> imag: As I showed you, mix the two declarations you made.
14:08:28 <dmwit> imag: So include `t` both on the left of the `=` and as arguments to `Tree` on the right.
14:08:35 <imag> ah gotcha
14:08:55 <dmwit> imag: For the proposal where you have two types, you could: data Tree leaf node = Leaf leaf | Node (Tree leaf node) node (Tree leaf node)
14:09:12 <imag> oh gotcha, I know what you mean there
14:09:17 <tdammers> that's probably the most useful/generalized version
14:09:28 <tdammers> can always use () for either the leaf or the node type
14:09:49 <imag> Okay wait so I've written a function to insert an element
14:09:54 <dmwit> cool!
14:10:01 <imag> insertElement :: (Tree a, Ord b) => a -> b -> a
14:10:04 <imag> with that type signature
14:10:14 <imag> but ghc is giving me an error when I try to compile it
14:10:30 <imag> "Illegal polymorphic or qualified type: Ord b => a -> b -> a     Perhaps you intended to use -XRankNTypes or -XRank2Types     In the type signature for `insertElement':       insertElement :: (Tree a, Ord b) => a -> b -> a"
14:10:30 <dmwit> Yeah, Tree is not a type class, it's just a boring old type.
14:10:35 <imag> ahh
14:10:36 <imag> ok
14:10:37 <imag> so I can fix that
14:10:50 <dmwit> Perhaps something like insertElement :: Ord a => a -> Tree a -> Tree a -- ?
14:11:02 <imag> insertElement :: (Ord b) => Tree a -> b -> Tree a
14:11:15 <dmwit> imag: That type says something I bet you don't mean.
14:11:45 <imag> what is the difference between the two signatures?
14:11:49 <imag> So yours takes an ordered type
14:11:57 <dmwit> imag: It says that, if you have a tree containing values of one type, and I hand you a value of another type, you can construct a new tree containing values of the first type.
14:11:58 <imag> and an element to include of that type
14:12:07 <imag> ahh
14:12:08 <imag> so yeah
14:12:12 <imag> okay so I want everything to be a
14:12:17 <dmwit> right
14:12:28 <imag> so insertElement :: (Ord b) => Tree a -> a -> Tree a
14:12:30 <imag> would be fine
14:13:00 <imag> if I want to keep the ordering
14:13:01 <dmwit> You could do that, but (Ord b) is an odd constraint when you don't mention `b` on the other side.
14:13:02 <sssilver> umm, guys, so if I want to make my Board and Piece ‚Äúrenderable‚Äù, I have to convert them into `data`? https://dpaste.de/vns0
14:13:15 <dmwit> So you probably want to make that `Ord a` as well.
14:13:19 <imag> oh whoops
14:13:22 <imag> yeah Ord a
14:13:40 <dmwit> sssilver: What does "renderable" mean?
14:14:18 <imag> thanks!
14:14:26 <sssilver> dmwit: something that implements the Render() interface. Similar to Show(), I guess
14:14:35 <m-r-r> What is the difference between "f >>= return . g" and "liftM g f" ? I used the first and HLint tells me to use the second :-/
14:14:40 <sssilver> dmwit: idk, this is my first project, so I may be way off
14:14:56 <dmwit> sssilver: Generally, each type may only have one instance of a given type class.
14:15:02 <fread2282> so what options do i have for a fixed writer monad?
14:15:16 <dmwit> sssilver: So if you want different behavior for Piece and Board, which are the same type, then you will need to make them different types somehow (and using "data" is one way).
14:15:44 <uwap> :t liftM
14:15:45 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
14:16:01 <dmwit> m-r-r: The second is more idiomatic; and `fmap g f` or `g <$> f` is even moreso.
14:16:25 <dmwit> m-r-r: For the same reason using `map` is preferable to re-implementing `map` inline. It means the reader can pay attention less.
14:16:43 <m-r-r> dmwit: ah ok
14:16:50 <dmwit> fread2282: What's broken with the existing writer?
14:17:30 <fread2282> dmwit: thunk leaks iirc
14:17:51 <m-r-r> I think i will use <$>, it's more readable than fmap in my case
14:19:32 <zipper> internal server error: stack overflow
14:19:38 * zipper just killed yesod
14:19:40 <zipper> lol
14:20:39 <zipper> :t show
14:20:40 <lambdabot> Show a => a -> String
14:21:37 <juancaman> :t Monad
14:21:38 <lambdabot> Not in scope: data constructor ‚ÄòMonad‚Äô
14:21:50 <juancaman> god i didn't know you could do it
14:21:54 <dmwit> :k Monad
14:21:54 <lambdabot> (* -> *) -> Constraint
14:22:04 <juancaman> :k Int
14:22:05 <lambdabot> *
14:22:40 <dmwit> You might also like: ?src Monad
14:22:58 <gregnwosu> trying to parse json that has the form "jQuery20306373523330954174_1424038357356({\\\"Url\\\"
14:23:03 <mmaruseacph2> ?src Monad
14:23:03 <lambdabot> class  Monad m  where
14:23:03 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
14:23:03 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
14:23:03 <lambdabot>     return :: a -> m a
14:23:03 <lambdabot>     fail   :: String -> m a
14:23:05 <mmaruseacph2> nice
14:23:14 <gregnwosu> how can i convince aeson to accept escaped quotes
14:23:52 <dmwit> You probably can't. Can you convince your provider to send you valid JSON, instead?
14:24:16 <gregnwosu> dmwit: lol, wish i could
14:24:20 <dmwit> I mean, you can fork aeson.
14:24:32 <dmwit> But you can't expect it to just accept whatever garbage you throw at it.
14:30:21 <dmwit> A fragile solution would be to toss some extra quotes on the front and back and use `read`.
14:30:38 <dmwit> But yeah, that won't fix the "jQuery23451243(...)" nonsense.
14:31:20 <dmwit> > let fragileDescape s = read ("\"" ++ s ++ "\"") :: String in fragileDescape "jQuery239487239487(\\\"Url\\\""
14:31:22 <lambdabot>  "jQuery239487239487(\"Url\""
14:32:26 <glguy> That's some JSONP return value (in case that wasn't mentioned above)
14:33:16 <dmwit> Oh, great. So now to actually do it correctly we must implement javascript.
14:33:30 <dmwit> Or am I misunderstanding the first two paragraphs of Wikipedia's page on JSONP.
14:35:27 <zipper> How do I fetch Params from a post request in haskell?
14:35:30 <dmwit> From reading more than the first two paragraphs: how the heck does anything on the Web continue to work?
14:35:50 <geekosaur> some of us have been wondering that for decades :p
14:35:56 <zipper> dmwit: First two paragraphs of what?
14:36:01 <Bynbo7> zipper: which library are you using?
14:36:07 <dmwit> zipper: Wikipedia's page on JSONP.
14:36:16 <zipper> Axman6: Yesod
14:36:29 <glguy> dmwit: It's supposed to just be normal JSON provided as the argument to a function so you can implement that callback function to interpret teh JSON argument
14:36:36 <glguy> so a full javascript implementation shouldn't be necessary
14:37:11 <zipper> The web works because humans can understand and recover from error messages I think.
14:37:31 <dmwit> glguy: "the returned payload can be any arbitrary JavaScript expression, and it does not need to include any JSON at all"
14:38:18 <dmwit> So somehow somebody's good idea for dealing with the security problems of cross-site scripting was to allow explicit script injection.
14:38:26 <zipper> Axman6: Can you help? I have the following for example that I want to work with. Note the multiple times allowance and deduction has been mentioned.
14:38:27 <dmwit> s/allow/encourage/
14:38:31 <zipper> Axman6:  Params: [("_token","SeKB0vr8qZ"),("basic-salary","12"),("allowance","2"),("deduction","3"),("nssf","4"),("nhif","5"),("allowance","House"),("allowance","6"),("deduction","CSR"),("deduction","7")]
14:38:56 <Stratege> it's the web and involves js, are you really surprised that the "solution" to a problem seems a bit odd?
14:38:57 <Axman6> zipper: https://hackage.haskell.org/package/yesod-core-1.4.8/docs/Yesod-Core-Handler.html#g:7 (you get all the things in Yesod.Core by importing Yesod)
14:39:21 <glguy> dmwit: It can be, but then I don't think it's technically "JSONP"
14:39:27 <HeladoDeBrownie> jsonp is also misnamed. it's not json that's being passed to the function, it's an actual javascript object, with what that entails (e.g., getters, setters)
14:39:33 <glguy> dmwit: just based on http://www.json-p.org
14:42:38 <gregnwosu> gah
14:42:41 <dmwit> That proposal looks a bit saner. But it's really roundabout. If you're going to ask browser implementations to do something, why not ask them to do something sane?
14:42:57 <nomeata> Hi. With ghc-7.8, I often see linker errors with packages using doctest, e.g. doctests: /usr/lib/haskell-packages/ghc/lib/i386-linux-ghc-7.8.4/text-1.1.1.3/libHStext-1.1.1.3.a: unknown symbol `_GLOBAL_OFFSET_TABLE_'. Has anyone else seen this before?
14:43:30 <dmwit> Like add a JSONRequest primitive or something with a different security policy.
14:46:01 <bramgg> Is -v0 the least verbose option for GHCi?
14:49:19 <zipper> Axman6: but I don't see myself taking type Text anywhere to be able to use lookupPostParams anywhere. Here is the  handler post function and hamlet file https://gist.github.com/urbanslug/64fcdbab6b97527f73f2
14:50:52 <Axman6> .txt :(
14:51:19 <zipper> Axman6: What?
14:51:32 <zipper> I'm reading post data from a form
14:51:59 <Axman6> the haskell is in a .txt file so it has no syntax highlighting. anyway I don't understand what problem you're having; I assume you're looking for data from a specific post parameter?
14:52:34 <zipper> Axman6: Oh let me fix that
14:57:22 <zipper> Axman6: Better? http://lpaste.net/836007399822196736
14:58:11 <Axman6> sure, but what is your actualy problem
14:58:23 <zipper> Axman6: Okay according to the post params in my browser and my yesod devel in my terminal I can see that I am passing info that takes the form of which I showed you in an example back to the server.
14:59:11 <Axman6> what form, I coul;dn't see anything about parameters
14:59:18 <zipper> However I am unable to get these post Params in a way that I can make them into a map and save them in a DB because the type I have defined in my models only allows for one allowance and one deduction
15:00:14 <zipper> Params: [("_token","SeKB0vr8qZ"),("basic-salary","12"),("allowance","2"),("deduction","3"),("nssf","4"),("nhif","5"),("allowance","House"),("allowance","6"),("deduction","CSR"),("deduction","7")]
15:00:16 <zipper> Axman6: ^
15:00:20 <Axman6> so you want to record all post params in a database and not specific ones?
15:00:39 * hackagebot lowgl 0.2.1.0 - Basic gl wrapper and reference  http://hackage.haskell.org/package/lowgl-0.2.1.0 (evanrinehart)
15:01:10 <Axman6> https://hackage.haskell.org/package/yesod-core-1.4.8/docs/src/Yesod-Core-Handler.html#lookupPostParams might give you an idea of how to access all the params
15:01:44 <zipper> Axman6: Close. What I want is to record everything but allowances but deductions as they are. For allowances and deductions I want to store some things as a map. e.g (house: 6)
15:02:18 <bramgg> I'd like to minimize GHCi's verbosity as much as possible, is -v0 my best option?
15:02:27 <zipper> Axman6: You already referred me to that function but it takes a type Text. Which is nothing close to what I get from the form.
15:02:47 <bramgg> I can't find any documentation on it
15:03:12 <Axman6> zipper: look at the link, it's the source of the function which shows you how to use runRequestBody to get the parameters
15:05:39 * hackagebot heroku 0.1.2.2 - helpers for deploying to Heroku  http://hackage.haskell.org/package/heroku-0.1.2.2 (GregWeber)
15:05:56 <Axman6> zipper: see https://hackage.haskell.org/package/yesod-core-1.4.8/docs/Yesod-Core-Handler.html#t:RequestBodyContents and runRequestBody on the same page
15:07:52 <Profpatsch> Is there something like constraint-based programming possible?
15:08:05 <Profpatsch> Maybe a monad for it implementing (:-)?
15:08:34 <Profpatsch> aka what Prolog or MiniKanren do.
15:10:17 <Profpatsch> Ugh, look at me not having understood the difference between logic programming and constraint programming yet.
15:10:22 <zipper> Axman6: Dude I thank you
15:10:40 <zipper> I thank you like I don't know what for runRequestBody
15:10:45 <zipper> Axman6: ^
15:11:21 <Axman6> no worries
15:12:26 <zipper> Axman6: Although one question arises. Don't I lose the type safe forms when I chose to use get the post data myself?
15:12:37 <zipper> Axman6: How can I keep the type safety?
15:12:52 <Axman6> by using proper forms
15:13:16 <zipper> Axman6: I am using proper forms that are being generated by Yesod
15:13:32 <zipper> Axman6: It's the additional fields that lack the type safety
15:13:38 <zipper> Since they're generated by JS
15:14:13 <Axman6> you could use a parser to parse the fields into the types you want
15:14:27 <Axman6> which is essentiially what the various form handler libraries do
15:15:04 <zipper> Axman6: Yeah and render an error page/message of sorts when a person enters the kind of data that I don't want.
15:15:38 <Axman6> sure
15:17:44 <Profpatsch> https://web.archive.org/web/20141005145655/http://okmij.org/ftp/Computation/monads.html#LogicT
15:17:46 <Profpatsch> Jackpot
15:18:14 <Profpatsch> See also https://stackoverflow.com/questions/1932770/haskell-vs-prolog-comparison especially this answer: http://stackoverflow.com/a/1932926/1382925
15:20:19 <MirandaHawthorn_> woooo what's going on here?
15:20:35 <Axman6> haskell things
15:20:37 <MirandaHawthorn_> who are you people? why are you in my house?
15:20:40 <MirandaHawthorn_> oh yes yes i see
15:20:49 <Profpatsch> MirandaHawthorn_: We Came To Play
15:20:53 <MirandaHawthorn_> with each other?
15:20:56 <MirandaHawthorn_> i can get down with that
15:20:59 <Axman6> do you have a question about haskell MirandaHawthorn_?
15:21:08 <Profpatsch> MirandaHawthorn_: https://www.youtube.com/watch?v=f91CYA5KdDc
15:21:31 <MirandaHawthorn_> Axman6: what is the driving philosophy of haskell?
15:21:48 <MirandaHawthorn_> is about enlightenment? hedonism?
15:21:57 <MirandaHawthorn_> perhaps unadulterated debauchery?
15:22:16 <Axman6> it's a programming language, so no
15:22:16 <lpaste> Rotaerk pasted ‚Äúabstraction problem...‚Äù at http://lpaste.net/120567
15:22:22 <Profpatsch> MirandaHawthorn_: hedonism is maybe an implication of using Haskell extensively.
15:22:42 <Profpatsch> At least it gives lots of pleasure you don‚Äôt even know if you don‚Äôt use it. :)
15:22:56 <Profpatsch> Intellectual pleasure at that.
15:23:03 <Rotaerk> in what was just pasted, I've got a working function tryDataListFromText, and I was wondering if there's a way to make a function that abstracts a part of it, represented roughly by the commented-out function
15:24:14 <Erdos> I didn't get it at first
15:24:32 <Erdos> but jazz is really an operation performed on an infinite set
15:25:15 <Rotaerk> the goal would be that I could implement tryDataListFromText as:  tryDataListFromText typeId text = fmap (toGLDataListOf typeId) . tryFromText
15:25:19 <zipper> Erdos: LOL why? Do they keep repeating the same note?
15:25:26 <KaneTW> haha http://www.jayway.com/2010/04/14/static-typing-is-the-root-of-all-evil/
15:25:30 <EvanR> Erdos: whats the type of jazz?
15:25:32 <mpickering> Rotaerk: What is your error?
15:25:37 <Erdos> zipper: you pick some pattern of notes
15:25:48 <Erdos> it's infinite because you can always play more notes
15:25:52 <mpickering> I think it might work if you add the right class constraints to toGLDataListOf?
15:25:57 <Erdos> they type would be the the note
15:26:00 <Erdos> the*
15:26:26 <Rotaerk> mpickering, with the current toGLDataListOf:  Couldn't match type ‚Äòd‚Äô with ‚ÄòGLushort‚Äô
15:26:35 <cjenkin1> Would someone waste a few minutes of their life giving me a code review of a ~75 line program I wrote (most of those lines are toplevel data and variable names)? http://lpaste.net/120569
15:26:48 <cjenkin1> Apparently lpaste has automated style review. That's neat
15:27:13 <EvanR> Erdos: so jazz is an unfolding
15:27:32 <cjenkin1> New to programming in Haskell working in "the real world", would love some tips
15:27:35 <Rotaerk> mpickering, also tried a signature like:  toGLDataListOf :: GLDataTypeID -> (forall d. (Show d, Read d, GLDataType d) => [d]) -> GLDataList
15:27:48 <mpickering> Rotaerk: Right so you are fixing what the "d" has to be by using asTypeByProxy on line 14
15:27:52 <EvanR> cjenkin1: i see nothing
15:28:23 <cjenkin1> EvanR, Hm? In the lpaste you see nothing?
15:28:36 <EvanR> cjenkin1: yes
15:29:11 <cjenkin1> EvanR, That's really strange. I just clicked the link from here and it opened in my browser
15:29:16 <Rotaerk> mpickering, the crux of the problem is that readMaybe returns a polymorphic value, and as such, it can be fixed to be one specific type, as I do with asTypeByProxy in the first function
15:29:18 <mpickering> Rotaerk: (Specifically GLushort) but then passing in a list of [a] but values has to be of type [GLushort]
15:29:25 <n4x> cjenkin1: "mapM_ ..." would be ''nice'' than "sequence (map ..) >> return ()"
15:29:51 <EvanR> cjenkin1: sorry client snafu
15:29:54 <cjenkin1> n4x, So lpaste tells me.
15:30:10 <Rotaerk> mpickering, but what if I want to pass that polymorphic value into a function, and allow the function to fix its type internally
15:30:21 <n4x> cjenkin1: I am talking about the mapM_ :P
15:30:39 <cjenkin1> n4x, Ah, missed that
15:30:44 <cjenkin1> Sneaky underscore
15:30:46 <EvanR> cjenkin1: in your main, you could use do notation instead of the nested >>='s
15:30:58 <cjenkin1> EvanR, I, uh, don't like do notation xD
15:31:08 <n4x> cjenkin1: and I'd either use do-syntax, or point-free versions of those functions
15:31:09 <EvanR> this is code review
15:31:15 <n4x> (basically eta-reduction)
15:31:18 <cjenkin1> EvanR, Fair enough
15:31:36 <n4x> \diffs -> writeDiffs abc diffs == writeDiffs abc
15:32:02 <mpickering> Rotaerk: I think you might want to use a type family here
15:32:35 <mpickering> Rotaerk: because you want to fix the value of GLDataList depending on the GLDataTypeId?
15:32:46 <cjenkin1> n4x, Right, makes sense
15:32:55 <n4x> cjenkin1: something like "readFile filename >>= diffMDBSeq . splitMDBSeq setupMaxMin >>= writeDiffs setupMaxMin", maybe?
15:33:40 <Rotaerk> mpickering, the type that I'm fixing is that of the readMaybe
15:33:51 <n4x> cjenkin1: I'd actually use do-syntax for most things where the point-free version becomes annoying / not obvious
15:33:51 <cjenkin1> n4x, So you're for point free and EvanR is for do-notation, eh?
15:33:57 <cjenkin1> I prefer the pointfree one myself
15:34:18 <orzo> i vote for do
15:34:20 <Rotaerk> mpickering, GLDataList itself can handle an array of any type that meets the constraints, and when I fix the readMaybe to be a Maybe [GLushort], I guarantee those constraints and allow it to be convertible into a GLDataList
15:34:33 <Rotaerk> I've got an idea though... sec
15:34:38 <EvanR> cjenkin1: if you were going to use lambdas with intermediate variables like that, you should use do. you dont need the variables though, as with the combinator approach
15:34:48 <mpickering> and I don't understand how you want to do that for any list which is what you currently have
15:35:14 <orzo> cjenkin1: i would try to reduce those very long compositions into short ones involving descriptive names for things defined in a nearby where clause
15:35:20 <Axman6> n4x: if you're going to do pointfree code like that, at kleast use =<< so everything flows in the same direction
15:35:30 <mpickering> you also need to specify a way of turning *any* value into GlFloat or whatever
15:35:31 <n4x> cjenkin1: it really depends, I actually use point-free for combinators and do-syntax for functions
15:35:42 <mpickering> which is what "tryFromText" does in the first example
15:35:56 <cjenkin1> orzo, In the main function, or in the helpers?
15:36:06 <cjenkin1> e.g. diffMDBSeq, writeDiffs
15:36:06 <EvanR> fix your helpers too
15:36:23 <cjenkin1> Yeah, they're a bit unwieldy
15:36:28 <n4x> Axman6: right
15:38:20 <n4x> cjenkin1: " something >>= \(_,x,_) -> return x " may look nicer using fmap / <$>
15:38:50 <orzo> cjenkin1: not main, other functions, particularly with maps of lambdas
15:39:09 <orzo> cjenkin1: and big chains of $
15:39:28 <EvanR> chain . not $
15:39:45 <cjenkin1> :t <$>
15:39:46 <lambdabot> parse error on input ‚Äò<$>‚Äô
15:39:51 <n4x> it's infix fmap
15:39:53 <cjenkin1> :t (<$>)
15:39:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:40:33 <orzo> i used to write fully applied chains with . except for the last term.  I've lately decided that's maybe being silly
15:40:57 <cjenkin1> Is . really to be preferred over $ ?
15:41:00 <n4x> the diffMDBSeq has a similar case, of a >>= \x -> return (..)
15:41:11 <orzo> EvanR: do you follow the rule?  all . until the end?
15:41:44 <Moggle> cjenkin: it's a matter of style, but the unofficial standard for haskell tends to be pointfree yes
15:41:56 <n4x> cjenkin1: . has nice properties, like associativity, and you can "split" it in parts
15:42:19 <Moggle> whatever . whatever . whatever $ x looks nicer to me than whatever $ whatever $ whatever $ x
15:42:37 <Buttons840> whatever . whatever $ whatever x is less characters
15:42:48 <n4x> Moggle: "whatever . whatever . whatever" without $ nor x
15:43:15 <Moggle> n4x: depends where you're doing it
15:43:18 <cjenkin1> n4x, Yeah, I see what you mean regarding diffMDBSeq. Can drop the \xs ->
15:43:23 <Moggle> can do it for f x = whatever . whatever, but not in other places.
15:43:51 <n4x> Moggle: I'd use () in those cases, but all of this is a matter of style
15:43:57 <jmcarthur> using ($) instead of parens has dubious benefits, but using (.) is almost always a win in my eyes
15:43:58 <Moggle> true enough.
15:44:57 <jmcarthur> i even toy with banning ($) from my code, but i always feel like the grass is greener on the other side
15:45:00 <jerrrry> $ is flat, parens are easier to read
15:45:13 <n4x> there is a different thing though, using functions like mapM_ .. =<< .. instead of a bunch of >>= \x -> sequence (map .. x)
15:45:52 <cjenkin1> :t (=<<)
15:45:52 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:46:09 <Cale> One $ per expression is okay
15:46:35 <cjenkin1> :t mapM_
15:46:35 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
15:46:49 <jmcarthur> Cale: how do you feel about expressions of the form   f (a . b . c $ d) . e . g . h $ i   ?
15:46:52 <orzo> i like cjenkin1's style of lining up { and , for records, i use the same convention
15:46:52 <Cale> In fact, almost any usage which doesn't rely on the associativity of $ I think is mostly okay.
15:47:02 <EvanR> using all $ irritates people reviewing haskell code that don't know haskell
15:47:04 <jmcarthur> that answers that i guess
15:47:10 <cjenkin1> orzo, I thought that was common practice?
15:47:14 <glguy> EvanR: That's definitely not true
15:47:35 <EvanR> "these haskell nuts only program in a perl-like soup of symbols!"
15:47:43 <Cale> I'm not sure I'd actually write something of a form like jmcarthur's example
15:47:44 <orzo> cjenkin1: i don't know, i figured { on the same line wiht , at end was jsut as common
15:47:57 <cjenkin1> EvanR, I learned J before I learned Haskell, so... :)
15:48:09 <jmcarthur> Cale: what would you do?
15:48:16 <Cale> But say,  withSomeResource $ \r -> do ... something with $ ...
15:48:25 <EvanR> thats fine but the structure of the code is a lot easier to read with a modicum of parentheses
15:48:30 <Cale> Is technically the same expression, but far enough apart not to be too distasteful
15:48:38 <Cale> and it doesn't rely on the associativity
15:49:20 <Cale> Or like,  withSomeResource $ \r -> withSomeOtherResource $ \r' -> ...
15:49:36 <Cale> (probably with line broken after -> )
15:49:42 <jerrrry> could `withSomeResource \r -> do ... something' be made legal? or is there ambiguity
15:49:57 <glguy> jerrrry: It works for Agda already
15:49:59 <Cale> I honestly don't really understand why it's not already leval
15:50:01 <Cale> legal*
15:50:16 <Cale> It's some little parsing trickiness
15:50:34 <jmcarthur> i learned a week or so ago something amazing regarding that pattern in ocaml
15:51:21 <jmcarthur> if you say something like   f fun x -> y;;  it's parsed as  f;; fun x -> y;;  where the (;;) delimits top-level definitions/expressions... yes, expressions are allowed at the top level.
15:51:49 <jmcarthur> but if you say  f (fun x -> y);;  it does what you probably meant
15:52:07 <Cale> That's... interesting :)
15:52:18 <jmcarthur> yup...
15:54:20 <chrisdotcode> bitemyapp: ping
15:55:48 <bitemyapp> chrisdotcode: what did I do now?
15:56:19 <chrisdotcode> bitemyapp: was curious as to whether or not you sign commits and write copyright information as 'bitemyapp' or 'Chris Allen'?
15:56:39 <chrisdotcode> Because I've just been using my handle for both; I'm sure if I should, which is preferrable, or any legal ramifications or anything like that
15:56:43 <bitemyapp> I am not legally aliased as bitemyapp, so Chris Allen.
15:56:44 <chrisdotcode> *I'm not sure
15:56:48 <chrisdotcode> Thought so.
15:56:50 <chrisdotcode> Thanks.
15:56:52 <bitemyapp> bitemyapp is just a way to make it easy to find my stuff
15:56:54 <bitemyapp> basically, SEO.
15:56:56 <bitemyapp> chrisdotcode: np
15:57:31 <sclv> Cale: you still running \bot, or is that someone else?
15:57:48 <Cale> It's int-e, I think
15:58:01 <Cale> It's changed hands a couple times since me
15:58:24 <chrisdotcode> (bitemyapp: I'm likewise assuming 'Chris' is good enough - as opposed to whatever the full extension of 'Chris' is, right? (eg: Christian, Christopher, etc))
15:58:44 <bitemyapp> chrisdotcode: courts don't sweat stuff that small.
15:58:44 <sclv> ah, int-e is it you? :-P
15:59:09 <chrisdotcode> bitemyapp: Cool.
15:59:19 <bitemyapp> chrisdotcode: as long as ownership can be established, I don't see how not using my full name would be an issue, but I AM NOT A LAWYER
15:59:26 * chrisdotcode nods
15:59:29 <bitemyapp> chrisdotcode: that said, I do think most people could benefit from a Law 101 book.
15:59:38 <chrisdotcode> 'Law 101 for programmers'
15:59:39 <bitemyapp> learning the basics of tort, contract, criminal law is really valuable.
15:59:41 <chrisdotcode> I'd read it
15:59:46 <chrisdotcode> new startup?
15:59:48 <chrisdotcode> law101.io
15:59:58 <chrisdotcode> Written in haskell; client-side purescript
16:00:07 <chrisdotcode> "Learn law and haskell at the same time!"
16:00:15 <EvanR> a type system for laws!
16:00:22 <EvanR> now they cant not make sense
16:00:28 <bitemyapp> https://www.clerky.com/ it's not for learning law, but if you're starting a business they can be valuable.
16:00:31 <cjenkin1> EvanR, orzo n4x: Thanks for the feedback! I'm revising my program now
16:00:39 <ConfusedGirl> Is there a way to have a custom data type / instance in two files? I have a data type defined in file A. File A imports file B and calls a few function in B but B also needs to use those custom data types. I dont want to create a circular loop, any suggestions?
16:00:43 <bitemyapp> EvanR: I've actually argued laws should be defined in a proof assistant, but I know that'll never happen.
16:00:52 <chrisdotcode> There was an idea like that, I think, EvanR. Saw it on HN a while back. It was something about formalizing legal nototation
16:00:55 <chrisdotcode> *notation
16:01:01 <n4x> EvanR: but then we won't have any laws
16:01:02 <bitemyapp> EvanR: realistically, we want interpretive breathing room so absurd things don't happen.
16:01:05 <chrisdotcode> And having your laws be machine checked
16:01:09 <EvanR> n4x: shh
16:01:30 <bitemyapp> most laws are written with a set of what amounts to macros and idioms that get reused over and over, but they're not universal.
16:01:32 <chrisdotcode> ConfusedGirl: How is B using the data types?
16:01:59 <Kron> how exactly do I make GHC handle _names as... well... not type holes? for lenses
16:02:26 <bennofs> Kron: You can use _names normally
16:02:37 <bennofs> Kron: they only act as type holes when no defined _name is in scope
16:02:42 <Kron> hmmm, okay
16:02:46 <bennofs> > let _test = 3 in _test
16:02:47 <lambdabot>  3
16:02:53 <bennofs> > let _test = 3 in _test_not_defined
16:02:55 <lambdabot>  Found hole ‚Äò_test_not_defined‚Äô with type: t
16:02:55 <lambdabot>  Where: ‚Äòt‚Äô is a rigid type variable bound by
16:02:55 <lambdabot>             the inferred type of it :: t at Top level
16:03:03 <chrisdotcode> Oh, that's cool
16:03:37 <Kron> i'm having trouble defining a really simple lens then, let me lpaste it
16:04:10 <athan> ConfusedGirl: I usually end up making a nested `Type` module, to throw the instances in, but still import as a globally available module :\
16:04:20 <Kron> http://lpaste.net/1663331359319392256
16:04:48 <bennofs> Kron: _head is not a lens
16:04:51 <Kron> I'm not sure what exactly i'm doing wrong
16:04:55 <Kron> it isn't? http://hackage.haskell.org/package/lens-1.3.1/docs/Data-List-Lens.html
16:05:02 <Kron> do I need to import it separately? that may explain it
16:05:08 <enthropy> lens-1.3.1
16:05:22 <Kron> ahhh
16:05:27 <Kron> so the lens doesn't exist
16:05:56 <bennofs> Kron: _head in latest lens is a traversal, because _head can fail for []
16:06:05 <Kron> gotcha
16:07:03 <bennofs> Kron: you could probably use singular _head if you're sure that there is always at least one element in the list (idk how that behaves if this isn't met)
16:07:10 <bennofs> > [] ^? _head
16:07:11 <lambdabot>  Nothing
16:07:17 <Kron> probably just a runtime failure
16:07:19 <bennofs> > [] ^. singular _head
16:07:19 <edwardk> > [] ^. singular head
16:07:20 <lambdabot>  *Exception: singular: empty traversal
16:07:20 <lambdabot>  Couldn't match type ‚Äò(->) a‚Äô with ‚Äò[]‚Äô
16:07:20 <lambdabot>  Expected type: Control.Lens.Traversal.Traversing
16:07:20 <lambdabot>                   (->) (Control.Applicative.Const a) [t0] [t0] a a
16:07:23 <edwardk> > [] ^. singular _head
16:07:24 <lambdabot>  *Exception: singular: empty traversal
16:07:26 <edwardk> yeah
16:07:29 <bennofs> > [] ^. singular _head .~ 3
16:07:31 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
16:07:31 <lambdabot>    arising from a use of ‚ÄòM548775160648414772015748.show_M5487751606484147720...
16:07:31 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
16:07:34 <bennofs> > [] ^. singular _head .~ ()
16:07:35 <Kron> alright, what exactly are the modern list lenses I guess?
16:07:36 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
16:07:36 <lambdabot>    arising from a use of ‚ÄòM582135378882555783115760.show_M5821353788825557831...
16:07:36 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
16:07:38 <bennofs> > [] & singular _head .~ ()
16:07:40 <lambdabot>  []
16:07:44 <Kron> basically i'm looking for a !! lens, if that makes any sense
16:07:49 <Kron> the nth element of a list
16:07:53 <Kron> and i'm not sure where to find this in the documentation
16:07:58 <Kron> I've been lost several times
16:08:04 <edwardk> > "hello"^? ix 1
16:08:06 <Kron> admittedly, it may not be a proper lens
16:08:06 <lambdabot>  Just 'e'
16:08:11 <Kron> ooh
16:08:11 <edwardk> its not a lens its a traversal
16:08:14 <edwardk> for the same reasons
16:08:19 <edwardk> you could try to access out of bounds
16:08:20 <Kron> gotcha
16:08:26 <bennofs> you can use singular (ix n) again to make it an unsafe lens
16:08:26 <edwardk> but you can claim it is a lens using singular
16:08:28 <Erdos> waaiitt is there a haskell interpreter builtin to this chat?
16:08:35 <edwardk> > "hello"^. singular (ix 1)
16:08:37 <lambdabot>  'e'
16:08:41 <edwardk> > "hello"^. singular (ix 100)
16:08:42 <lambdabot>  *Exception: singular: empty traversal
16:08:53 <cmccann> > "abced" ^?! ix 3
16:08:54 <lambdabot>  'e'
16:08:56 <edwardk> Erdos: yep
16:08:59 <Kron> Erdos: its name is lambdabot, and it is a dear
16:09:01 <bennofs> Erdos: yeah, lambdabot also has a few other functions (it can @hoogle for example). If you want to try it out, you can also give it commands via private chat#
16:09:14 <Kron> thanks edwardk: where can I find documentation on stuff like ix?
16:09:21 <edwardk> ^?!    can be used to apply singular directly for you. foo^?!bar = foo^.singular bar
16:09:26 <edwardk> Kron: Control.Lens.At contains ix
16:10:07 <Kron> gotcha
16:10:24 <edwardk> 'ix' and 'at' are overloaded to work for many different data types
16:10:33 <phaazon> hm
16:10:41 * hackagebot http-media 0.5.0 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.5.0 (TimothyJones)
16:10:52 <edwardk> 'ix' gives a traversal of an element if it is present, 'at' lets you change the presence or absence of the element in question
16:11:03 <edwardk> so 'at' is more powerful when it is available, 'ix' is available more often
16:11:16 <cmccann> edwardk: btw, is there anything fun to do with pattern synonyms and lens? it's easy enough to define a pattern synonym using a prism but obviously doing that with e.g. _Left is kinda unncessary
16:11:48 <phaazon> is there a lensing draft for a future GHC version implementation?
16:11:54 <phaazon> like built-in lensing?
16:12:21 <edwardk> cmccann: well, alas we don't have 'parameterized pattern synonyms', so we can't write one that takes a prism as an argument and applies it
16:12:29 <Erdos> > fac n = product [1..n]
16:12:30 <lambdabot>  <hint>:1:7: parse error on input ‚Äò=‚Äô
16:12:34 <ConfusedGirl> chrisdotcode: and athan:   Here is my code. File A cannot be changed only file B. http://lpaste.net/2983341741874085888
16:12:36 <phaazon> after all, languages like C, C++ or Java have lensing in the standard (scope resolution)
16:12:37 <Erdos> whoops
16:12:41 <phaazon> why not GHC?
16:12:59 <Cale> wat
16:13:01 <cmccann> edwardk: yeah that's one of the things I wondered about
16:13:02 <edwardk> cmccann: there is some intent that in future lens versions we'll start looking at the overloaded prisms that we offer and offering pattern synonyms for them
16:13:10 <Erdos> > product [1..5]
16:13:11 <lambdabot>  120
16:13:17 <Cale> phaazon: None of those languages have lenses in their standard
16:13:24 <lightstep> there are several lens libraries
16:13:24 <phaazon> sure they are
16:13:38 <phaazon> imperative ‚Äúlensing‚Äù is scope resolution
16:13:40 <Cale> phaazon: Unless you mean something completely different by lens than we normally do around here?
16:13:44 <phaazon> a.b.c.d means something
16:14:22 <Cale> Nested function applications mean something in Haskell?
16:14:36 <phaazon> foo.x = 3, even if the ‚Äú = ‚Äù has to be provided by a user (for instance in C++), the ‚Äú.‚Äù is in the standard
16:14:45 <phaazon> I¬†think we‚Äôd need something like that in Haskell
16:14:52 <phaazon> being able to lens
16:14:56 <phaazon> focus, zoom
16:15:00 <phaazon> name it whatever you like
16:15:02 <phaazon> it‚Äôs all the same thing
16:15:03 <Cale> We have the lens library
16:15:10 <phaazon> that‚Äôs not standard
16:15:16 <Cale> It doesn't have to be
16:15:18 <phaazon> for instance, in the codingame challenge
16:15:22 <phaazon> I can‚Äôt use lens
16:15:24 <Erdos> > zip [1,2,3] [4,5,6]
16:15:25 <lambdabot>  [(1,4),(2,5),(3,6)]
16:15:28 <phaazon> because it‚Äôs not installed
16:15:33 <Cale> Well, complain to the challenge organisers?
16:15:39 <Cale> Or copy code from lens?
16:15:39 <Kron> phaazon: I feel like arbitrary coding challenges aren't the best way to evaluate language design
16:15:40 <chrisdotcode> ConfusedGirl: Besides your rank function maybe being a bit too complex, I don't see the problem there? The code seems well-organized.
16:15:41 <Erdos> hehe that's really satisfying
16:15:57 <edwardk> Kron++
16:15:58 <phaazon> the point is not to evaluate language design, but yours
16:16:02 <phaazon> the way you code
16:16:10 <phaazon> how you solve problems
16:16:15 <phaazon> lens is a wonderful library
16:16:19 <athan> ConfusedGirl: You're confusing me :|
16:16:25 <phaazon> but it exists to solve a gap in the Haskell standard
16:16:28 <phaazon> we do miss lensing
16:16:39 <athan> ConfusedGirl: So, you're trying to make an instance for `Person` in B?
16:16:44 <phaazon> an extension to record fields would be greatly appreciated
16:16:46 <Cale> Well, record syntax is a bit underpowered
16:16:48 <athan> er some instance that uses `Person`?
16:16:57 <phaazon> and all the work edwardk made in lens
16:17:08 <phaazon> like MonadState operators
16:17:12 <phaazon> .=, etc.
16:17:17 <phaazon> could be written in transformers
16:17:22 <phaazon> because lensing would be in the standard
16:17:27 <Cale> I really dislike the infix stuff in the lens library
16:17:31 <phaazon> (mtl I mean)
16:17:53 <cmccann> Cale: this from the guy who used to define (.) as fmap? :P
16:18:03 <Cale> cmccann: hm? How is that similar at all?
16:18:23 <Cale> cmccann: The problem with the infix operators in lens is that there are a kajillion of them and many are not very general
16:18:46 <cmccann> Cale: oh, I thought you were more complaining about operators in general
16:18:47 <phaazon> Cale: they‚Äôre easy to learn though
16:18:50 <edwardk> Cale: import Control.Lens.Combinators -- nary an operator in sight. you're welcome =P
16:19:01 <Cale> edwardk: I know :)
16:19:04 <cmccann> Cale: there is at least a consistent "vocabulary" to the lens operators
16:19:25 <cmccann> it doesn't make them look any less like line noise, but at least you don't have to memorize them all individually
16:19:31 <ConfusedGirl> chrisdotcode: Do you know of a way to do this without using Person in file B? That code throws errors because Person is already defined.
16:19:36 <phaazon> I think the work of edwardk on lens should be deferred into the standard
16:19:38 <edwardk> i tend to use the basic lens operators like +=, etc. a fair deal
16:19:40 <Cale> cmccann: Yeah, but it doesn't change the fact that many of them are obviated through the use of a small subset of them which take function arguments
16:19:43 <phaazon> not everything, of course
16:19:45 <phaazon> but its base
16:19:47 <phaazon> at least
16:20:04 <chrisdotcode> ConfusedGirl: I think this is your error: data People = Person String Int deriving (Eq, Show)
16:20:08 <ConfusedGirl> athan: I am trying to compare two people in file B
16:20:09 <chrisdotcode> Should that Person be People ?
16:20:18 <chrisdotcode> I think it should be, data People = People String Int deriving (Eq, Show)
16:20:25 <edwardk> If the FTP is this much drama, I don't think i could survive an appreciable part of lens being standardized.
16:20:33 <chrisdotcode> There's a difference between data constructors and type constructors in haskell
16:20:37 <phaazon> FTP?
16:20:44 <edwardk> Foldable/Traversable Proposal
16:20:58 <edwardk> ghc.haskell.org/trac/ghc/wiki/Prelude710/FTP
16:20:59 <cmccann> edwardk: get Semigroup into Prelude first, then tackle lens
16:21:06 <phaazon> edwardk: well, to me, lens is just a big trick
16:21:12 <phaazon> it shouldn‚Äôt be a library
16:21:18 <phaazon> it makes me think of javascript
16:21:19 <Cale> (<^~) :: (Num a, Integral e) => Optical (->) q ((,) a) s t a a -> e -> q s (a, t) -- Raise the target of a numerically valued Lens to a non-negative Integral power and return the result.
16:21:21 <Cale> Stuff like this
16:21:24 <phaazon> that has libraries like underscore.js
16:21:25 <athan> ohhhhh
16:21:27 <cmccann> phaazon: lens isn't a library, it's a lifestyle
16:21:31 <athan> ConfusedGirl: You're fine
16:21:31 <chrisdotcode> haha
16:21:31 <Kron> lol
16:21:37 <matt1> i'm trying to make a database schema with yesod and I'm not sure what I should do
16:21:40 <phaazon> to solve the fact that the language lacks something important
16:21:40 <Kron> lens is love, lens is life
16:21:42 <Kron> embrace lens
16:21:44 <athan> when you import data, it carries the instances :)
16:21:48 <matt1> i want to make comments
16:21:48 <chrisdotcode> athan: It seems she mistyped her People constructor on line 1
16:21:50 <phaazon> (underscore.js exports functions like foreach‚Ä¶)
16:22:01 <matt1> and the top comments should point back to the post
16:22:15 <matt1> does anyone know how to do something like this with persistent?
16:22:23 <cmccann> lens solves lots of problems
16:22:27 <edwardk> cmccann: that is a viable long term goal. the main thing it needs is for us to get through FTP, which puts Monoid in Prelude, and for someone to put forth a Semigroup-Monoid Proposal, which does the same AMP-style warnings for missing Semigroup instances. Warnings in 7.12 and a release in 7.14 is a viable proposal, it may even get decent support, but I'm
16:22:27 <edwardk> waiting to see how badly FTP goes before I even consider it.
16:22:59 <lpaste> Rotaerk revised ‚Äúabstraction problem...‚Äù: ‚Äúoverly limited abstraction‚Äù at http://lpaste.net/120567
16:23:00 <cmccann> for instance, some people don't like how much haskell uses operators. lens solves this by using all of them itself and leaving none left.
16:23:08 <edwardk> cmccann: hahahahahah
16:23:13 <Rotaerk> mpickering, http://lpaste.net/120567
16:23:21 <Rotaerk> found a way to abstract it, but it's not ideal...
16:23:29 <edwardk> @remember cmccann for instance, some people don't like how much haskell uses operators. lens solves this by using all of them itself and leaving none left.
16:23:29 <lambdabot> Good to know.
16:23:38 <cmccann> :D
16:23:42 <matt1> because right now I can't get the types for the ids to line up and I don't know how I can leave a field blank
16:24:00 <cmccann> edwardk: I seem to remember Semigroup getting a lot of weird and inexplicable resistance from people on the libraries list
16:25:22 <phaazon> edwardk: interesting draft
16:25:30 <cmccann> that said, getting Semigroup in as well would be nice
16:25:41 * hackagebot sequent-core 0.3 - Alternative Core language for GHC plugins  http://hackage.haskell.org/package/sequent-core-0.3 (lukemaurer)
16:25:46 <phaazon> I‚Äôve always wondered why mapM is in prelude
16:25:49 <phaazon> in traverse is not
16:25:58 <phaazon> and*
16:26:05 <glasserc1> Hi, I'm trying to use impredicative types and I can't figure out how to get the types to line up right: http://lpaste.net/120571
16:26:22 <Cale> edwardk: btw, you can change my vote on the FTP poll to "adopt" if you include some universal mapping property in the documentation which usefully prevents  foldMap = mempty  from being a valid instance of Foldable for every type constructor
16:26:44 <ConfusedGirl> chrisdotcode: the problem is that file A uses the type Person so I think it needs to be Person in file B?
16:26:46 <athan> chrisdotcode: Oh haha
16:26:57 <edwardk> Cale: sadly gershom's proposal which is the closest to a viable proposal, is kinda killed by the GADT counter-examples
16:27:22 <edwardk> Cale: note the foldMap = mempty being a valid instance of Foldable is broken the moment you get down a subclass like Traversable at least
16:27:38 <edwardk> just as ZipList gets ruled out as the instance for Applicative for [] once you want [] to be a Monad.
16:27:43 <Rotaerk> glasserc1, huh; hadn't heard of impredicative types... that might solve my problem
16:27:59 <Cale> edwardk: It doesn't even have to guarantee that the instance is particularly sane -- like it may still admit something like toList [] = []; toList (x:xs) = (x:x:xs) for the list instance.
16:28:05 <chrisdotcode> ConfusedGirl: You don't need to do that. `data People = People String Int deriving (Eq, Show)` is perfectly file. Here's the difference b/t data and type constructors that might help you out a bit: https://wiki.haskell.org/Constructor
16:28:14 <Cale> edwardk: I just want something which ensures it's not completely degenerate
16:28:33 <edwardk> sure
16:28:51 <phaazon> edwardk: I can‚Äôt wait for that paper to be fully implemented
16:29:03 <phaazon> using Control.Category.{id,(.)} instead of the one from Prelude
16:29:07 <phaazon> and so on
16:29:55 <phaazon> I still wonder what we would need in Haskell to solde what lens solves
16:30:07 <phaazon> solve*
16:30:11 <cmccann> "Foldable instances must obey the following law: toList x = something that doesn't upset Cale"
16:30:20 <ConfusedGirl> chrisdotcode: thanks for the link. Do you have any idea where I should begin if I want to be able to compare two Person's in file B if they are defined in file A but passed to B?
16:30:41 * hackagebot hindent 4.3.11 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.11 (ChrisDone)
16:31:02 <chrisdotcode> ConfusedGirl: You should just be able to use them, no? Just import them and compare them; unless I'm missing something.
16:31:57 <Cale> edwardk: We had a suggestion in here the other day in terms of toList, that the instance should be initial in the sense that given any other h :: f a -> [a], it should be the case that there's some k :: [a] -> [a] such that h = k . toList
16:32:30 <ConfusedGirl> File A is importing file B, the Person is defined in A but they are used in A and B if that makes sense? I can't import A from B because A is importing B
16:32:34 <edwardk> cmccann: that doesn't work, toList requires potentially infinite right reassociation. ;)
16:33:01 <Cale> edwardk: But yeah, would be nice to have something in terms of foldMap
16:33:07 <edwardk> so even asking all other operations to factor through toList is broken
16:33:11 <Cale> Perhaps using a tree monoid?
16:33:27 <cmccann> oh yeah
16:33:34 <cmccann> should've been foldMap :|
16:33:36 <cmccann> oh well
16:33:38 <edwardk> Cale: sure. i can empathize with the desire, the notion that perhaps the toList should get 'all the a's in the container.
16:34:10 <carter> what about that foldmap morphism?
16:34:22 <edwardk> the thing that kills that for me is that capturing a GADT, like 'Num' for your arguments secretly gives you negative occurrences of 'a's
16:34:24 <carter> edwardk: what about toTree?
16:34:27 <Cale> It just feels like a bad abstraction if it doesn't have enough operations to write down any sensible laws for the instances
16:34:40 <edwardk> and capturing such a dictionary is a thing we explicitly want to be able to support
16:34:55 <Cale> another suggestion would be to just ditch Foldable and merge it with Traversable, only you lose some instances that way
16:35:16 <cmccann> Foldable reminds me of the idea of having a type class just for pure/return except with more practical value
16:35:17 <edwardk> i am violently against any attempt to fuse Foldable with Traversable
16:35:24 <Cale> I don't really like the style of programming which Foldable suggests
16:35:24 <edwardk> we make very good use of the more limited form of Foldable
16:35:43 <chrisdotcode> ConfusedGirl: Okay, I see what you're saying. First of all, I would recommend switching People to Person, like I recommended above. Second, IIRC, circular imports work in haskell, so you should be fine, iff you need it. Finally, what you
16:35:43 <edwardk> and it creates _exactly_ the same situation we finally get away with in terms of AMP in terms of code duplication
16:36:12 <chrisdotcode> ConfusedGirl: *you're looking for is qualified imports. Instead of importing just names, you import a namespace like so: import qualified Data.Maybe as Maybe (fromJust)
16:36:17 <carter> chrisdotcode: ConfusedGirl circular improts are a bit painful
16:36:19 <edwardk> oh look you can't call traverse_ in the same context that you can call traverse or we need to make up another notion of Foldable which provides the exact same 33 operations but now without the right subclassing relationship
16:36:21 <Cale> It seems like a sort of programming which is ignorant of the utility of universal data types -- at least in part.
16:36:21 <carter> they're supported but not fun
16:36:31 <chrisdotcode> ConfusedGirl: I don't think she needs them, but I'm letting her know they're there.
16:36:44 <chrisdotcode> I think she's looking for qualified modules from my understanding of her problem.
16:36:45 <edwardk> we're effectively asking the community hold its nose and write Applicative instances even if they don't use them with AMP.
16:37:40 <Cale> edwardk: The only reason I'd suggest the merger is because we're having such difficulty stating any useful conditions on these operations
16:37:50 <michaelt> It wouldn't be so bad if the new prelude exported `ap` ...
16:37:55 <Cale> edwardk: I'm not saying that I think it's the best thing or anything
16:38:08 <Cale> edwardk: Just that it's evidence that Foldable is missing something important
16:38:21 <edwardk> i could live with some sort of law that managed to capture the 'must visit all 'a's in a container' intuition rigorously, but idea that we could just rip out Foldable is pretty damning to a huge body of work i have out there
16:38:21 <Cale> Applicative after all has laws
16:38:23 <carter> Cale:  semantics in terms of free trees
16:39:04 <carter> eerr binary/ternary treees
16:39:20 <edwardk> Foldable has plenty of laws in terms of foldMap relating all the other operations. and of course the monoid homomorphism respecting law for foldMap itself
16:39:34 <edwardk> given a monoid homomorphism g, then foldMap (g . f) = g . foldMap f
16:39:53 <Cale> That's almost a free theorem
16:39:59 <Cale> If it isn't free...
16:40:04 <edwardk> it is damn near one =)
16:40:18 <edwardk> it basically winds up a free theorem if you expand the monoid dictionary and add the monoid laws
16:40:51 <edwardk> it is however enough to do a lot of internal reasoning. it doesn't capture the 'visit all the a's intuition that folks have about Foldable
16:41:03 <carter> is there any example of a legal Foldable instance that doesnt make sense in terms of going through a Binary Tree?
16:41:06 <Cale> There are a lot of shitty potential instances of Foldable, and I feel like the abstraction isn't complete if we can't exclude even the worst of them
16:41:23 <ConfusedGirl> chrisdotcode: I have never used qualified imports, do I change this line or keep it as is?  import qualified Data.Maybe as Maybe (fromJust)
16:41:25 <edwardk> carter: sure. i have a kinda horrible instance in machines for Machine Identity
16:41:33 <edwardk> carter: it probably shouldn't be legal but it is
16:42:03 <edwardk> but i'm somewhat leery of the notion that we can rule that out and then somehow leave instances that capture a GADT
16:42:14 <edwardk> and the ability to have instances that know properties of their argument is quite useful
16:42:18 <chrisdotcode> ConfusedGirl: It was more so as an example, so that you're not messing with name conflicts. You'd do something like (in file B): import qualified A (People(..)), and you'd use it like: A.Person
16:43:20 <edwardk> so i think the quest for a nice universal property here is butting heads against the fact that since it only ever uses 'f' in negative position, it is quite useful for us not to have this property in practice.
16:43:36 <ConfusedGirl> chrisdotcode: okay that makes sense. Do I leave "People(..)" or are you saying I fill in the dots?
16:43:52 <carter> edwardk: that looks like it would flow through a binary tree
16:43:59 <chrisdotcode> ConfusedGirl: no, it's actually People(..). (..) refers to the constructor values, in this case, A.Person
16:44:03 <Cale> edwardk: The other thing I kind of dislike about Foldable is that factoring the solutions to problems through universal types like lists is a really effective technique, and Foldable kind of obscures that with all its methods.
16:44:04 <edwardk> carter: it doesn't touch all the 'a's in the container.
16:44:23 <chrisdotcode> If there's more than one constructor, it imports all of them. But your A.People only has one constructor.
16:45:04 <carter> really?
16:45:06 <edwardk> Cale: factoring things into Monoid m => (a -> m) -> m  -- is really useful. foldMap does that, list is only universal if you accept the fact that all trees are finite
16:45:08 <carter> it looks liek it does?
16:45:16 <ConfusedGirl> chrisdotcode: thanks for the help! Is there a way you can think of to break this down into something not so complex?  I got this working but it seems very complex as you said previously.                                 rank a = flip zip sortedA $ map ((+1) . fromJust . flip elemIndex sortedA) sortedA
16:45:16 <ConfusedGirl>   where sortedA = sort a
16:45:26 <Cale> edwardk: Like if you write f a -> [a] for each of n data types and then you use m operations on lists, you've done O(n+m) work, while if you take the approach that Foldable *appears* to be suggesting of sticking all m of your operations in a typeclass so they can be implemented for each of your n types, that's recommending O(nm) work, even if that's not how instances are actually written.
16:45:37 <KaneTW> ConfusedGirl: what are you trying to do?
16:45:37 <carter> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Type.hs#L180
16:46:23 <Cale> edwardk: and yes, I'm neglecting other trees in that
16:46:33 <phaazon> chrisdotcode: I just read your Promise stuff
16:46:39 <phaazon> what‚Äôs it good for?
16:46:40 <edwardk> Cale: ideally all work in Foldable would factor through foldMap. There is your O(n + m). Period. Sadly, we cannot enact that plan without forcing users to pay an asymptotic cost in terms of stack utilization or overall performance.
16:46:52 <Cale> edwardk: But there are also lots of operations in Foldable which don't make sense on infinite anything, let alone infinite trees
16:46:53 <chrisdotcode> phaazon: It's just what the abstraction looks like in Haskell
16:47:27 <chrisdotcode> We don't really need it, because we hide our async under mio, but if Promises WERE implemented in Haskell, this is what it would look like
16:47:27 <ConfusedGirl> KaneTW: basically rank people for scoring based on score or rank a list of words/names
16:47:28 <edwardk> Cale: sure. we have this weird middle ground where folks have cases that 'try to deal with infinities as best they can'
16:47:41 <phaazon> ok :)
16:47:44 <yiati> The new haskell website looks nice
16:47:59 <phaazon> oh yeah
16:48:00 <Cale> What if foldMap were the only method of Foldable, and we dealt with the performance issues via rewrite rules?
16:48:04 <phaazon> it‚Äôs changed
16:48:10 <phaazon> I like the purple color :)
16:48:13 <Cale> That's sort of at least conceptually prettier
16:48:18 <chrisdotcode> ConfusedGirl: Sure, I'll take a look
16:48:20 <Cale> even if in practice, I dunno
16:48:44 <phaazon> the web ghci is slow though
16:48:58 <chrisdotcode> ConfusedGirl: can you link me the lpaste again?
16:48:58 <edwardk> Cale: my experience is that in a vanishing few Foldable instances I want to overload some of the methods. foldMap I always implement. I sometimes implement foldr or foldl depending on if i'm recursive or secretly array backed. Now with length and null as members, they can often get an O(1) or O(log n) implementation.
16:49:17 <KaneTW> ConfusedGirl: maybe try a map? i think its keyset is ordered so you could do a key=rank, value=Person type map
16:49:28 <edwardk> then the rest sit there with their nice sensible defaults because the foldMap definition is "good enough"
16:49:36 <KaneTW> ConfusedGirl: as in Data.Map, sorry
16:49:37 <Cale> edwardk: But you could handle length and null like that with a RULES pragma, no?
16:49:50 <carter> Cale: that way leads to spining sadness
16:49:50 <edwardk> rewrite rules are _terrible_. you only get them to fire if the inliner knows the type
16:50:05 <Cale> hm
16:50:09 <edwardk> given the terrible variance in the behavior of the ininer over the last half dozen releases of GHC this is a crapshoot
16:50:12 <Cale> Yeah, I see where you can get problems
16:50:24 <edwardk> you're asking to randomly vary behavior based on the mood of the compiler today
16:50:27 <edwardk> that isn't a stable viable option
16:50:31 <phaazon> god
16:50:37 <phaazon> do we really have 7k packages?
16:50:51 <carter> i'm sure we'll have more
16:50:53 <edwardk> the realToFrac situation with Double is bad enough
16:51:02 <carter> :t realToFrac
16:51:03 <lambdabot> (Real a, Fractional b) => a -> b
16:51:06 <edwardk> i have to actively mangle code to avoid non-determinism
16:51:11 <edwardk> i don't want to deal with that crap elsewhere
16:51:17 <carter> NAN
16:51:18 <phaazon> uh
16:51:27 <phaazon> what‚Äôs happening on deb.haskell.org?!
16:51:35 <phaazon> Security Break
16:51:37 <carter> phaazon: it got busted so they'er fixing it
16:51:44 <phaazon> busted?
16:51:51 <carter> ask on #haskell-infrastructure
16:51:57 <ConfusedGirl> chrisdotcode: here is the link. I added two test cases  http://lpaste.net/2983341741874085888
16:52:13 <edwardk> > (realToFrac (0/0), 0/0)
16:52:14 <lambdabot>  (-Infinity,NaN)
16:53:03 <Cale> hah
16:53:07 <carter> :t  (realToFrac (0/0), 0/0)
16:53:08 <lambdabot> (Fractional t1, Fractional t) => (t, t1)
16:53:17 <carter> how'd that default to double
16:53:20 <KaneTW> :t Data.Map.fromListWith
16:53:21 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
16:53:27 <Cale> carter: Numeric defaulting
16:53:36 <phaazon> > realToFrac $ 0 / 0
16:53:38 <lambdabot>  -Infinity
16:53:55 <phaazon> > abs $ 0 / 0
16:53:57 <lambdabot>  NaN
16:54:22 <chrisdotcode> Dear Zeus, NaN?
16:54:25 <chrisdotcode> Is this JavaScript?
16:54:32 <phaazon> no
16:54:35 <phaazon> that‚Äôs quite okay
16:54:37 <chrisdotcode> ConfusedGirl: Well, first of all, you should use fromjust, nor should you use flip for functions. They're written that way for a reason. I'd say try to design your functions such that you can partially apply them easily
16:54:39 <Cale> chrisdotcode: NaN is part of the IEEE floating point specification
16:54:40 <phaazon> abs is in Num
16:54:47 <edwardk> anyways with rewrite rules on given a monomorphic Double that realToFrac (0/0) will silently switch its answer to NaN. thanks!
16:54:47 <chrisdotcode> Cale: Oh, really?
16:54:51 <chrisdotcode> Learn something new every day
16:54:51 <bitemyapp> @ty fromJust
16:54:52 <lambdabot> Maybe a -> a
16:55:02 <bitemyapp> chrisdotcode: fromJust is a really bad idea, especially for new people.
16:55:11 <chrisdotcode> bitemyapp: Yeah, that was the next part :)
16:55:11 <phaazon> edwardk: is this a good think?
16:55:15 <Cale> chrisdotcode: Yeah, it pretty much exists everywhere that you use floating point numbers.
16:55:17 <bitemyapp> ConfusedGirl: you want to avoid partial functions that can fail like fromJust.
16:55:19 <chrisdotcode> oh wait
16:55:20 <chrisdotcode> my bad
16:55:22 <phaazon> NaN should be defined only for Floating point values
16:55:22 <chrisdotcode> that was a type
16:55:25 <chrisdotcode> *typo
16:55:26 <edwardk> phaazon: the problem is that you no longer have equational reasoning
16:55:27 <phaazon> not Fractional
16:55:30 <chrisdotcode> ConfusedGirl: DON"T use fromJust.
16:55:37 <Cale> edwardk: right
16:55:44 <phaazon> realToFrac (0 % 0)
16:55:47 <phaazon> > realToFrac (0 % 0)
16:55:49 <lambdabot>  *Exception: Ratio has zero denominator
16:55:50 <edwardk> phaazon: you only get this behavior when the type is the more specialized type, the same code with a more general type now has different operational behavior
16:55:50 <Cale> edwardk: Because it doesn't actually go via Rational in that case
16:55:56 <edwardk> even when the type is specialized back
16:56:12 <edwardk> so where you unify your types now affects the semantics of your code
16:56:24 <ConfusedGirl> chrisdotcode: Okay I will try to do something different. Any idea where to start for that?
16:56:27 <edwardk> RULES here are antimodular
16:57:03 <KaneTW> ConfusedGirl: try to look into another data structure like Data.Set or Data.Map, i think that'd be more appropriate in your case
16:57:03 <Cale> ConfusedGirl: Sorry, I missed your thread, what was your question?
16:57:08 <chrisdotcode> ConfusedGirl: Break it down, step-by-step. Your intuition of composition isn't bad, but instead of doing what you want with the type signatures, try to have them all fit together
16:57:12 <chrisdotcode> :t zip
16:57:13 <lambdabot> [a] -> [b] -> [(a, b)]
16:57:13 <chrisdotcode> :t sort
16:57:14 <lambdabot> Ord a => [a] -> [a]
16:57:21 <chrisdotcode> Try to make them fit together, instead of just flipping everything.
16:57:33 <edwardk> Cale: anyways, i pretty much almost never have concrete types until the last possible instant in my code, so you're basically asking me and anyone who codes like me to pay the penalty indefinitely
16:57:40 <chrisdotcode> And again, as bitemyapp said, DON'T use fromJust. That was a typo on my part.
16:57:46 <Cale> edwardk: yeah, hmm
16:58:04 <ConfusedGirl> so try to use zip and sort differently?
16:58:26 <edwardk> Cale: i realize i've had an extra year and a half of thinking about this particular issue to kickstart my thinking ;)
16:59:19 <edwardk> also the only places where lens tends to suffer on benchmarks is precisely these cases, because given a Fold, it is effectively always going through the foldMap style code path
16:59:48 <chrisdotcode> ConfusedGirl: Try to see if you can write your function with any flips :)
17:00:02 <edwardk> performance is usually recoverable when we know the concrete instances involved and the GHC inliner isn't stymied by recursion
17:00:05 <Cale> edwardk: Foldable isn't completely terrible, but I still feel like it's missing the mark a little, and I don't know how good of an idea it is to put stuff that we might find better alternatives to in the Prelude, given the history (or lack thereof) of that module.
17:00:09 <chrisdotcode> Try to really grok the type signatures for each function, and why they're that way.
17:00:09 <phaazon> feeling exhausted, I¬†spent the whole day with the parents of my beloved
17:00:20 <phaazon> god they‚Äôre old but they‚Äôre exhausting ahah
17:00:28 <chrisdotcode> phaazon: The best remedy for the Mother-in-law is fmaping things
17:00:33 <phaazon> have a good day / night
17:00:39 <edwardk> Cale: i think the only change to Foldable that is likely to happen is an attempt to capture the notion that 'all the a's are visited'.
17:00:41 * hackagebot robot 1.4 - Simulate keyboard and mouse events  http://hackage.haskell.org/package/robot-1.4 (ChrisWong)
17:00:59 <phaazon> chrisdotcode: ahah, well, I do love them, but spending the whole Sunday, well
17:01:07 <phaazon> :P
17:01:12 <edwardk> beyond that if folks can find a way to avoid the asymptotic hits, Foldable the class could shed members, but that would only change what you can overload, not what the class enables.
17:01:25 <phaazon> see you later, off to bed
17:01:52 <edwardk> Its outright removal isn't an option, and once you accept the AMP into your heart, mapM is _never_ the right combinator.
17:01:58 <edwardk> so we wind up needing 'traverse'
17:01:58 <Cale> I think there might be something enabling which is yet to be added to the class, but I don't know what that thing is.
17:02:11 <edwardk> once you accept traverse into the Prelude you wind up in this weird uncomfortable middle ground
17:02:13 <Cale> Like, something slightly less general might be a better abstraction.
17:02:28 <Cale> (while still capturing all or most of the existing instances)
17:03:15 <lightstep> why then does Foldable has many specialized methods (sum,product,maximum,etc) instead of a single member (for_efficiency :: Foldable a => UseLeftFold | UseRightFold | UseFoldMap)?
17:03:34 <Cale> mapM is always the right combinator when you're using it in a case where the choice of monad is monomorphic, which is like 95% of the time
17:03:37 <lightstep> this won't cover null and map tho
17:03:50 <edwardk> To me Foldable is pretty obvious once you take the definition of traverse and say instead of allowing Applicative effects, which are basically one possible categorification of a Monoid, you forget the index you get the definition of foldMap.
17:03:52 <carter> lightstep: i've admiddtely thought about that or something liek that
17:04:37 <edwardk> What i mean is, other than the weird jfischoff/dolio counter-example, the constraints on mapM are too strong. you rule out a class of things you could walk with for no real reason.
17:04:37 <sclv> product and map are screwy because not only the direction but that they enforce the laziness
17:04:41 <sclv> while in general you want foldl'
17:05:23 <ConfusedGirl> chrisdotcode: I got those two lines down to one line. Should I try to restart completely or change this around by removing fromJust and flip?   rank a = flip zip (sort a) ( map ((+1) . fromJust . flip elemIndex (sort a)) (sort a) )
17:05:25 <edwardk> So you get folks who think that Monad is special, that we really need all of it for mapM, but you don't.
17:05:38 <edwardk> It contributes to the marginalization of Applicative
17:05:41 * hackagebot irc-client 0.2.3.0 - An IRC client library.  http://hackage.haskell.org/package/irc-client-0.2.3.0 (barrucadu)
17:05:49 <sclv> oh wait i had a great idea for a fold on lists!
17:05:54 <sclv> as opposed to foldl and foldr
17:06:08 <sclv> we turn it into the bifold thing where it takes advantage of associativity
17:06:18 <sclv> so you can gobble up much bigger trees without running out of stack
17:06:20 * cmccann still kind of wishes we could kill return because it's a terrible name and just use pure everywhere.
17:06:29 * mgomezch uses pure everywhere
17:06:29 <cmccann> but that would probably break a bit of code
17:06:33 <Cale> return seems like a fine name to me
17:06:53 <Cale> What better name for the action that does nothing but to return v than, well, return v
17:06:56 <sclv> bifold iirc is sort of like a "mergesort" type thing except instead of `merge` you just smash monoidally
17:07:13 <EvanR> Cale: in which case we rename pure to return ;)
17:07:21 <Cale> Indeed
17:07:27 <sclv> and as i recall bifold can handle even longer lists than foldl' without blowing stack
17:07:27 <edwardk> cmccann: one evolution path forward for the AMP would be to eventually deprecate the redefinition of return in Monad, and then we could ultimately move 'return' to a top level definition. This would kill the return/pure distinction type wise, because we could then upgrade it to Applicative constraint wise, which removes the weird part of the ApplicativeDo
17:07:28 <edwardk> proposals.
17:07:29 <mgomezch> indeed, we should *teach* people to avoid return, as it looks like something it‚Äôs not.
17:07:29 <Cale> pure could just as well be named return
17:07:38 <Cale> mgomezch: what?
17:07:39 <cmccann> Cale: pure v = pure, 100% genuine v, accept no substitutes
17:07:43 <Cale> What does return look like that it's not?
17:07:56 <sclv> that's a separate proposal for a separate release, but I can see no reason not to do it at least :-)
17:07:57 <SrPx_> How do I pretty print a tree from the type "data Tree a = Node [Tree a] | Leaf a", with indentation, using "fold"? Explanation: http://lpaste.net/120573
17:08:00 <edwardk> cmccann: hvr recently put in a proposal to the trac that would allow us to deprecate redefining class members
17:08:04 <sclv> (unless we already do?)
17:08:14 <dolio> Cale: return clearly implies non-local control flow. :)
17:08:21 <mgomezch> Cale: ¬´return¬ª suggests to imperative programmers a certain flow of control.
17:08:29 <edwardk> this would be necessary if we ever want to remove mapM, sequence, sequenceA  from Traversable for instance, or require that folks dont' define (>>) and return.
17:08:36 <Cale> mgomezch: Are you talking about how some people expect every definition to be implicitly wrapped in callCC? :)
17:08:40 <EvanR> mgomezch: except they will instantly find out that it doesnt do that, so its not a big deal
17:08:40 <cmccann> yeah, return is a decent name on its own but it couldn't be more misleading to newcomers if it tried
17:08:45 <mgomezch> Cale: indeed! (:
17:08:55 <sclv> SrPx_: yeah. the semantics of fold are designed to prohibit precisely the thing you want to write :-)
17:08:59 <sclv> they forget the treelike structure
17:09:07 <cmccann> and pure works just as well, is less confusing to beginners, and also is fewer characters so easier to type and i am lazy
17:09:08 <edwardk> bifold :: (l -> a -> r -> (r,l)) -> (l,r) -> [a] -> (r,l)
17:09:09 <edwardk> ?
17:09:22 <Cale> Haskell is a different language from other programming languages
17:09:34 <Cale> There are a lot of other things which will confuse beginners before return will
17:09:43 <SrPx_> sclv: yea I guess I know that... problem is, what is the right way to augment fold to do it? I mean, so I don't have to write a recursive function directly.
17:09:45 <SrPx_> :)
17:09:54 <cmccann> yeah, but almost all of those have value for their own sake
17:09:55 <SrPx_> edwardk: that was for me?
17:09:55 <Cale> The main thing which is going to confuse them is that IO actions are values.
17:10:07 <Cale> If they understand that, then return won't confuse them at all.
17:10:16 <sclv> edwardk: yeah that's not it. its ancient folklore i learned here like seven years ago :-)
17:10:42 <chrisdotcode> ConfusedGirl: I'm sorry, I'm really unable to help you at the moment, but you were perfectly fine with your where clause. Code reuse is best, and you got it the first time. What you should be avoiding is the use of many flips. If you need to, don't be afraid to use multiple variables
17:10:54 <chrisdotcode> *variables in your where clauses. And again, avoid fromJust entirely.
17:11:05 <Cale> and I don't think "pure foo" at the end of a do-block is going to confuse them any less than "return foo" would
17:11:10 <Cale> when initially reading code
17:11:16 <ConfusedGirl> chrisdotcode: Thank you for all of the help!
17:11:21 <chrisdotcode> :)
17:11:27 <cmccann> Cale: it's still easier for me to type
17:11:31 <cmccann> that's very important imo
17:12:09 <Cale> eta foo would be shorter still
17:12:17 <Cale> Super easy to type ;)
17:12:21 <cmccann> Cale: sold, let's do that
17:12:37 <cmccann> seriously though I don't like the redundancy and all else equal I'd rather keep "pure"
17:12:37 <mgomezch> Cale: what‚Äôs confusing is that ¬´do { return (); putStrLn "welp"; }¬ª prints.
17:12:50 <KaneTW> {-# LANGUAGE CPP #-} \ #define eta pure
17:12:57 <Cale> mgomezch: Yeah, if you're confused about why that prints, then you don't understand the fashion in which IO actions are values
17:13:07 <dolio> Near as I can tell, the only reason to call it 'return' is so you can write 'return foo' at the end of your functions, to make new folks more comfortable. But then it gives them the wrong ideas.
17:13:11 <ConfusedGirl> can anyone help me make this code     rank xs = concat $ zipWith (map . (,)) [1..] (group $ sort xs)          I am calling it with   rank ["two","one","one"]   equal [(1,"one"),(1,"one"),(3,"two")]   instead of [(1,"one"),(1,"one"),(2,"two")]
17:13:25 <Cale> dolio: No, I honestly like the name
17:13:35 <sclv> SrPx_: the general recursive pattern I like for this stuff is named "compos" if you want to google up the paper
17:13:38 <Cale> dolio: Even without consideration for how beginners will read the code
17:13:56 <mgomezch> Cale: it‚Äôs quite common in my (anecdotic) experience for even experienced Haskell programmers to glance at that and be confused if they often work with imperative languages too.
17:13:58 <Cale> I think it's a sensible name for what return gives you in most monads.
17:13:59 <dolio> I guess you can like it, too. :)
17:14:00 <sclv> SrPx_: but in your case, you can write a "FoldTree" function directly.
17:14:08 <Cale> At least, most of the monads which we use while programming
17:14:22 <Cale> It's a shitty name if you're thinking of, e.g. the completion monad on metric spaces
17:14:39 <Cale> But... that's not going to come up so often here :D
17:14:43 <dolio> Or many syntax trees.
17:14:47 <sclv> SrPx_: give it a function on trees and a function on leafs, and recursively call it or something...
17:14:54 <dolio> It should be called 'var'.
17:14:58 <Cale> mgomezch: Odd
17:15:12 <Cale> mgomezch: return v just reads as a no-op which returns v to me
17:15:21 <sclv> hereYouGo :: a -> m a
17:15:34 <Cale> mgomezch: In fact, I find it bewildering when it *is* used for control effects in imperative code.
17:15:41 * hackagebot irc-client 0.2.3.1 - An IRC client library.  http://hackage.haskell.org/package/irc-client-0.2.3.1 (barrucadu)
17:16:05 <Cale> mgomezch: because I've spent so long programming in Haskell that my ability to maintain machine state in my head has somewhat atrophied in certain ways
17:16:52 <mgomezch> Cale: then indeed there‚Äôs a mental conflict!  whether it ends up being confusing in Haskell or in imperative languages, either way you end up confused (:
17:16:58 <n4x> Cale: you don't even to write that much haskell!
17:17:03 <Cale> It's like I'm going along trying to understand some procedure and now all of a sudden I need to deal with this silent call/cc
17:17:05 <ConfusedGirl> can anyone help me with this code     rank xs = concat $ zipWith (map . (,)) [1..] (group $ sort xs)          I am calling it with   rank ["two","one","one"]     and it is producing   [(1,"one"),(1,"one"),(3,"two")]      but I want it to account for ties and produce  [(1,"one"),(1,"one"),(2,"two")]
17:17:23 <sclv> edwardk: i think I'm thinking of something like the tfold given here: https://mail.haskell.org/pipermail/haskell-cafe/2009-December/071375.html
17:17:38 <Cale> n4x: I write a fair amount. I just don't end up making very much public.
17:17:57 <Cale> n4x: Because I'm lazy about dealing with other people :)
17:18:27 <n4x> Cale: no, I mean, I have been programming haskell for 8~9 months and it happens here too :P
17:18:50 <Cale> n4x: Oh, I misread your sentence because you accidentally a work
17:18:52 <Cale> word*
17:19:25 <Cale> n4x: I thought you were accusing me of not writing that much Haskell, which I realise sort of appears true if you only look at what I've put on Hackage
17:19:53 <Cale> I really ought to work on polishing stuff up, and Ryan and I should really go through Blood Knight at some point and chop out our nice FRP system and release that
17:20:03 <Cale> But I'm so lazy!
17:20:05 <Cale> lol
17:20:14 <blackdog> Andys^: had a look at that board. looks nice, though it's a bit bigger than i'm used to
17:20:24 <enthropy> Cale: pretend you're working with ContT
17:20:40 <Cale> enthropy: Yeah, the fact that I have to retroactively go back and do that is what gets me :)
17:20:51 <enthropy> (callCC $ \return -> ...) -- every function is implicitly wrapped in one of these
17:21:09 <Cale> enthropy: yes
17:21:21 <blackdog> Cale: oh, i didn't realise you were involved with the blood knight project
17:21:23 <ConfusedGirl> Anyone please help?
17:21:28 <blackdog> is that actually getting released?
17:21:30 <Cale> But it's the fact that I have to retroactively realise that it's important that this continuation is in scope
17:21:35 <dolio> call/cc is probably not the best way to think about it.
17:21:43 <n4x> Cale: nah, didn't mean it that way, sorry heh :P
17:21:53 <Cale> blackdog: sadly, no, the founder ran out of money to fund it a long while back
17:22:12 <Cale> blackdog: But we had fun while it lasted, and I learned a bunch of stuff about FRP.
17:22:26 <EvanR> which FRP did you use, and did it work?
17:22:30 <jmcarthur> Cale: did you find FRP worthwhile?
17:22:37 <Cale> EvanR: We made our own FRP system
17:22:41 <jmcarthur> arrowized?
17:22:44 <Cale> yes
17:22:50 <Cale> Well, with our own custom Arrow class
17:22:57 <Cale> Not Control.Arrow :)
17:23:07 <orzo> too much confusion out there on what FRP means, i think maybe the term should just be abandoned for some more unique buzzword
17:23:10 <Cale> and our own preprocessor for the proc/do notation
17:23:12 <sclv> (psst: Ryan has another FRP system he has been working on that he is very proud of)
17:23:20 <sclv> (and he will be releasing it in the next few months)
17:23:24 <jmcarthur> orzo: denotative continuous time programming!
17:23:30 <Cale> sclv: Oh? I haven't seen it, that sounds awesome!
17:23:41 <Cale> I'm sure it'll be good, he's spent so long thinking about that stuff
17:23:49 <EvanR> reactive synergistic decomplection
17:24:00 <sclv> yeah, we end up talking FRP eventually nearly every time we see one another
17:24:04 <Cale> anyway, FRP is worth it, once the FRP system you want is done
17:24:06 <orzo> dctp ?
17:24:08 <orzo> heh
17:24:19 <EvanR> Cale: id be interested sometime to see your system
17:24:30 <Cale> It's really nice to *use* the system, but actually getting one that is well-designed in the first place is a huge effort
17:24:33 <jmcarthur> orzo: yup
17:25:14 <Cale> and there were still a lot of things we could have done (and might've had to do) to our FRP system to make it perform better
17:25:16 <SrPx_> btw since my question is kinda long I've moved it to S.O.... thanks guys :)
17:25:54 <Cale> But one really key thing was to make the definition of Arrow look more explicitly like the definition of a symmetric monoidal category
17:26:18 <drazak> FRP?
17:26:19 <Cale> So that the proc/do notation translation could make use of the explicit reassociation and swap and unit/retract methods
17:26:38 <edwardk> sclv: that tfold seems to fundamentally rely on the container its folding being infinite
17:26:53 <Cale> and then the code which ran the arrow computations could work out where the values were actually going and simplify the computations before they ran
17:26:55 <sclv> there's one like it that handles the edge cases properly i'm sure
17:26:56 <n4x> drazak: functional reactive programming
17:27:04 <sclv> i've seen it used to do "tricks" back in the day
17:27:31 <edwardk> it also seems to assume the container is right biased
17:27:31 <sclv> but its been so long
17:27:42 <edwardk> for such a construction to be correct
17:27:42 <sclv> quicksilver or someone used to be fond of it
17:27:54 <Cale> If every pair of arrow computations is mediated by some arr which only serves to manipulate tuples, but is a black box at runtime, then you've thrown away most of the point of using arrows as an abstraction
17:27:54 <edwardk> wow there is a nick i haven't heard in a while
17:27:59 <sclv> edwardk: the point is not to use it in general. the idea was for the "fold" operation of lists only
17:28:14 <sclv> while leaving foldr and foldl intact
17:28:49 <cfoch> hello
17:29:05 <cfoch> How can I get the type of an opeartor in the Prelude console?
17:29:16 <sclv> :t (+)
17:29:17 <lambdabot> Num a => a -> a -> a
17:29:19 <sclv> ^^ like that
17:29:35 <jmcarthur> Cale: did your version of arrows actually work with proc notation? you modified ghc or something?
17:30:02 <Cale> jmcarthur: Just wrote a source-to-source preprocessor using haskell-src-exts
17:30:08 <jmcarthur> ah
17:30:11 <cfoch> mmm... I have a question? Do you know what is "!" ?
17:30:13 <Cale> which translated the proc/do syntax ahead of time
17:30:27 <Cale> cfoch: In which context?
17:30:43 <Cale> cfoch: (!) can be used as an infix operator, but also occurs in a few places in the Haskell syntax
17:32:31 <cfoch> Cale: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/PackageIndex.hs#L148
17:32:56 <Cale> cfoch: Ah, okay, that ! means that this is a strict field of the data type
17:33:47 <Cale> cfoch: So whenever a PackageIndex value gets evaluated, that field will be evaluated as well, more or less.
17:34:22 <Cale> (which since it's a Map will mean that the keys of the Map will all get evaluated, but the values may still be unevaluated expressions)
17:37:46 <hiptobecubic> I assume IntSet is faster than Set when using Ints as keys, yes?
17:38:30 <bitemyapp> hiptobecubic: s'posed to be.
17:38:33 <hiptobecubic> if using single char [a..z] as keys, is it better to use IntSet and just map the chars to ints with `ord` myself?
17:38:54 * hiptobecubic doesn't want to wait for criterion to install :(
17:38:54 <bitemyapp> hiptobecubic: that sounds dodgy. I'd benchmark it to be sure.
17:39:04 <hiptobecubic> Yeah.....
17:41:06 <Cale> hiptobecubic: I would just use Map until I was sure that the performance of that Map was a serious performance bottleneck
17:41:26 <jmcarthur> i predict with 80% confidence that using an IntMap for Chars will be faster than using Map Char, but i would only bother if i really needed the performance, in which case i would test anyway.
17:42:08 <hiptobecubic> Is IntSet just implemented as IntMap with a single () value somewhere?
17:42:16 <jmcarthur> nope, it's a totally different data structure
17:42:19 <imag> is there a function that takes an arbitrary number of arguments and returns a list full of them? I'm trying to write a function that takes two arguments in a pointless style -- is that possible?
17:42:23 <Cale> hiptobecubic: No, but that's more or less what it is.
17:42:37 <Cale> hiptobecubic: Just, specialised to remove that part of the structure altogether
17:42:48 <jmcarthur> it's a trie
17:42:52 <jmcarthur> oh sorry
17:42:55 <jmcarthur> i misread
17:43:06 <jmcarthur> i read the question as IntSet vs. Set
17:43:16 <hiptobecubic> imag, /query lambdabot and play with the @pl command
17:43:19 <jmcarthur> and totally ignored the () thing...
17:43:33 <orzo> imag, there's uncurry, is that suitable?
17:43:56 <imag> wait let me look at uncurry, I hadn't heard of that
17:43:58 <jmcarthur> imag: you can write point free functions of as many arguments as you want, though they usually get a bit convoluted
17:44:00 <imag> and failing that, I'll play with @pl
17:44:02 <Cale> imag: It's possible to make such a thing with typeclass hackery, but it's not worth using, because the type ambiguity will mean you almost always have to give it an explicit type signature
17:44:24 <Cale> imag: But yeah, it doesn't sound like the solution to your actual problem either
17:45:26 <imag> hmm
17:45:51 <imag> I'm trying to play with the lambdabot
17:46:12 <imag> but the problem is that a bunch of these functions are my own
17:46:14 <imag> and when I try to declare them
17:46:22 <jmcarthur> you shouldn't need to declare them to use @pl
17:46:34 <jmcarthur> @pl \f g -> myFunc g f
17:46:34 <lambdabot> flip myFunc
17:46:35 <imag> I'm declaring the types
17:46:46 <imag> oh
17:46:47 <imag> hm
17:46:49 <imag> ok ok
17:50:34 <ungov> Hi, I'm trying to install a package called logict (actually, I'm trying to install tidal, but cabal has problems with one of it's dependencies, which happens to be this logict)
17:50:39 <ungov> I get this:
17:50:40 <ungov> Preprocessing library logict-0.6.0.2...
17:50:41 <ungov> [1 of 2] Compiling Control.Monad.Logic.Class ( Control/Monad/Logic/Class.hs, dist/build/Control/Monad/Logic/Class.o )
17:50:41 <ungov>  
17:50:44 <ungov> Control/Monad/Logic/Class.hs:173:37:
17:50:44 <ungov>     Not in scope: ‚ÄòStrictWT.runWriterT‚Äô
17:50:47 <ungov>     Perhaps you meant one of these:
17:50:50 <ungov>       ‚ÄòStrictWT.runWriter‚Äô (imported from Control.Monad.Writer.Strict),
17:50:53 <ungov>       data constructor ‚ÄòStrictWT.WriterT‚Äô (imported from Control.Monad.Writer.Strict),
17:50:57 <ungov>       ‚ÄòStrictWT.mapWriterT‚Äô (imported from Control.Monad.Writer.Strict)
17:50:59 <dmwit> ?paste
17:50:59 <lambdabot> Haskell pastebin: http://lpaste.net/
17:51:03 <dmwit> Don't paste in-channel.
17:51:29 <ungov> sorry
17:52:21 <lpaste> ungov pasted ‚ÄúOutput of cabal install logict‚Äù at http://lpaste.net/120576
17:52:35 <ungov> http://lpaste.net/120576
17:52:42 <ungov> That's the whole output
17:53:57 <dmwit> What does `ghc-pkg list mtl` say?
17:54:22 <imag> when I'm reading implied type signatures, how come sometimes it uses a, b, c and sometimes it starts using a1, a2, etc?
17:54:29 <imag> do a and a1 have any relationship?
17:54:50 <dmwit> imag: All of them are just variable names.
17:55:01 <imag> oh okay
17:55:06 <imag> so a1 is just used when you run out of a, b, c
17:55:10 <dmwit> right
17:55:17 <imag> ok perfect
17:56:20 <ungov> dmwit: http://lpaste.net/120577
17:57:03 <dmwit> Odd. mtl-2.2.1 definitely exports runWriterT.
17:58:02 <dmwit> Oh, are you installing into a sandbox?
17:58:32 <ungov> No, I just did cabal install logict
17:58:44 <ungov> Wow... this looks bad: http://lpaste.net/120578
17:59:14 <dmwit> Yeah, it does look bad.
17:59:37 <Axman6> I think you broke something
17:59:53 <ungov> I should probably reinstall haskell-platform, right?
18:00:17 <dmwit> Depending on just how many packages you have installed, I think I would wipe out my local package database and start again.
18:00:20 <dmwit> You might like:
18:00:22 <dmwit> ?where SICP
18:00:22 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
18:00:48 <asdhio> is there a good tutorial on how to set up, organize and run multiple-module tests with hspec
18:00:49 <asdhio> ?
18:01:27 <dmwit> If you haven't installed so very many packages, rm -r .ghc/$arch-$os-$version
18:03:36 <ungov> Well, I've installed quite a few packages, but it shouldn't be a big problem to install the again...
18:15:48 <RyanGlScott> I have a question about the way Haddock renders something: http://hackage.haskell.org/package/Boolean-0.2.3/docs/Data-Boolean.html#t:IfB
18:16:05 <RyanGlScott> Does (~) * bool (BooleanOf p) mean that BooleanOf p is nominally equal to bool, and that both have kind *?
18:19:11 <geekosaur> it's relating a to bool by saying that bool must be a type which has a BooleanOf instance parameterized by a.
18:19:47 <RyanGlScott> Sure, I understand that. I'm just not sure what the * is supposed to represent.
18:20:07 <geekosaur> oh, I'm looking a the wrong part, sorrt
18:20:41 <geekosaur> oh boy, advanced type hackery. I think you'll need to ask someone else, sorry
18:21:50 <cmccann> RyanGlScott: probably kind parameter application being displayed awkwardly
18:22:22 <geekosaur> way over my head...
18:22:26 <RyanGlScott> So it's similar to how Typeable displays its kinds? (example: https://hackage.haskell.org/package/base-4.8.0.0/candidate/docs/Data-Typeable.html)
18:23:39 <geekosaur> yeh, those don't show up in the source, haddock is being confusing
18:23:40 <cmccann> RyanGlScott: without the fancy star symbol but yeah
18:23:41 <orzo> maybe it's a haddock rendering issue
18:23:56 <cmccann> yeah, it's haddock displaying the kind parameter weirdly
18:24:08 <RyanGlScott> What would be a better way of rendering it?
18:24:17 <RyanGlScott> (Boolean a :: *) ~ (bool :: *)?
18:24:37 <orzo> is that what's in the source?
18:24:58 <geekosaur> the source doesn;t even have kind annotations
18:24:59 <RyanGlScott> I don't think there's any explicit kind signatures in the source.
18:25:08 <cmccann> RyanGlScott: or just leave it off since random * kind annotations are rarely insightful
18:25:16 <geekosaur> http://hackage.haskell.org/package/Boolean-0.2.3/docs/src/Data-Boolean.html#ifB scroll to the bottom for the instances
18:25:28 <RyanGlScott> If I had to surmise, it's because BooleanOf is declared as "type family BooleanOf a", without a kind signature, making it implicitly poly-kinded.
18:26:05 <cmccann> but polykinds aren't enabled that I can see
18:26:11 <cmccann> I blame haddock
18:26:11 <orzo> shouldn't haddock just render it exactly as the source had it?
18:26:14 <geekosaur> might be worth reporting this as a haddock bug :)
18:26:28 <cmccann> unless there's something wonky going on with the code
18:26:36 <c_wraith> I'm not sure the bug is in haddock.  GHC itself prints types with the crazy kind symbols in weird places
18:26:38 <cmccann> didn't see any extensions enabled in the .cabal file either
18:26:40 <RyanGlScott> I bet there's probably a reason for it, since Haddock is a pretty well-tested tool.
18:26:55 <geekosaur> haddock is well tested for some things
18:27:04 <asdhio> how do i run hspec tests using cabal and see the output in stdout?
18:27:07 <cmccann> c_wraith: does haddock rely on GHC for that?
18:27:10 <geekosaur> this kind of type family stuff is still newish
18:27:13 <asdhio> currently it logs it to a file
18:27:16 <c_wraith> cmccann: not sure
18:27:45 <RyanGlScott> I'm trying to see if I can find another Hackage package using equality constraints that doesn't have a kind signature rendered in Haddock...
18:27:45 <geekosaur> haddock uses ghc-as-a-library these days, doesn't it?
18:28:34 <dcoutts_> asdhio: cabal test --show-details=always
18:28:54 <asdhio> thanks dcoutts_
18:29:25 <cmccann> RyanGlScott: http://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Indexed.html
18:29:38 <asdhio> when i use runhaskell on a test-discovering hspec Spec.hs file it gives me an error 'Could not find module AsdfSpec'
18:29:44 <RyanGlScott> cmccann: lol, that was the first thing I thought of
18:29:48 <cmccann> looks like it might just be instance lists
18:29:52 <cmccann> where it does that
18:29:52 <asdhio> where AsdfSpec is the name of a module in my tests dir
18:29:57 <RyanGlScott> And that disproves my theory about poly-kinded type families
18:30:02 <cmccann> I guess it makes sense to rely on GHC for that
18:30:17 <RyanGlScott> So Haddock must always print kind information with equality constraints.
18:30:24 <RyanGlScott> Which, to be honest, I'm okay with.
18:30:42 * cmccann actually remembered that conjoined has a bullshit type of some sort but it actually displays fine
18:30:48 <RyanGlScott> It is a bit awkward to read, though.
18:31:14 <cmccann> yeah
18:31:30 <RyanGlScott> You're right: http://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Indexed.html#t:Conjoined
18:31:44 <cmccann> I think it's specifically equality constraints in instance lists
18:31:51 <cmccann> everything else I've found looked fine
18:31:53 <RyanGlScott> Huh
18:31:56 <orzo> even showing the constraints, it did it wrong, didn't it?  (~) * bool (BooleanOf a)
18:32:05 <cmccann> orzo: no, that's right
18:32:23 <orzo> it looks like three arguments to ~
18:32:31 <orzo> which should only take two
18:32:31 <cmccann> it is
18:32:33 <c_wraith> sure, but one's a kind argument. :)
18:32:35 <cmccann> the first is a kind parameter
18:32:38 <RyanGlScott> That's the only thing that bugs me; how to tell which are kinds and which are types.
18:32:41 <orzo> hm
18:32:50 <asdhio> dcoutts_: is there a way to specify that option in my cabal file so i dont have to type it every time?
18:32:55 <cmccann> RyanGlScott: well, if it's *, it's probably a kind :P
18:33:11 <RyanGlScott> A better example: https://hackage.haskell.org/package/base-4.8.0.0/candidate/docs/Data-Proxy.html
18:33:29 <RyanGlScott> There are instances like Show (Proxy k s), even though Proxy only has one type parameter.
18:33:41 <cmccann> ah yeah
18:33:52 <cmccann> that's definitely a kind variable being very confusing :T
18:34:09 <RyanGlScott> So I'm wondering if it would be worthwhile to change Haddock's rendering to something like Show (Proxy (s :: k))
18:34:14 <cmccann> http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Category.html too
18:34:46 <dcoutts_> asdhio: maybe in the local cabal.config file
18:34:55 <cmccann> RyanGlScott: http://hackage.haskell.org/package/base-4.7.0.2/docs/GHC-TypeLits.html concrete kinds, too
18:35:00 <cmccann> other than *, I mean
18:35:08 <dcoutts_> asdhio: but I'm not sure if the test options can be specified there
18:35:23 <asdhio> okay thanks dcoutts_
18:35:29 <cmccann> at least I think it's doing that with type lits
18:35:31 <cmccann> anyway, whatever
18:39:14 <RyanGlScott> I'm guessing the rendering may be related to how GHC stores this information internally.
18:39:41 <RyanGlScott> At least in Template Haskell, calling reifyRoles on a poly-kinded data type will return a list where the first half is kinds and the second half are the corresponding types.
18:40:17 <RyanGlScott> It's a bit wonky, but now that I've seen that pattern in Haddock too, it seems like it's probably a GHC thing.
18:41:34 <cmccann> it's definitely how GHC has or does display stuff
18:41:49 <cmccann> and if haddock is getting the instance lists from GHC somehow it makes sense
18:41:51 <_ryan> hi, everyon want to ask what is the channel for yesod framework that is active...
18:42:20 <cmccann> and that seems like something where it'd make most sense to rely on GHC rather than figure it out in haddock itself
18:43:09 <RyanGlScott> It would at least make pairing up types and kinds easy: split in in half and zip :P
18:44:51 <adas> i have a cabal sandbox. and I have hakyll installed in it. I have downloaded a few open source hakyll sites from the hakyll homepage. How can i try out the different hakyll sites inside the same sandbox?
18:45:20 <adas> because each hakyll site has its own folder
18:45:28 <adas> i tried cabal add-source
18:46:36 <adas> but that did not work
18:47:49 <adas> i just get the no cabal file error message even though there is a cabal file inside the individual hakyll folders
18:48:06 <dcoutts_> adas: it can work to add them all to the same sandbox, but you might find it easier to just install hakyll normally outside of a sandbox
18:48:46 <dcoutts_> adas: what are you doing exactly? if it says there's no .cabal file then you're pointing it at the wrong place
18:49:29 <adas> dcoutts_: i have a sandbox folder. within that folder i have different folders with different hakyll sites
18:49:54 <adas> dcoutts_: now i want to be able to use the sandbox installed hakyll with these different hakyll site to try them out
18:49:58 <dcoutts_> adas: e.g. if you're in the dir where you made the sanbox, and say that you have another cabal package in the dir ./foo/ then doing cabal install ./foo  will go ahead and install it within the sandbox
18:50:40 <adas> oh. ill try that
18:50:41 <dcoutts_> assuming that the dir ./foo/  does directly contain a .cabal file
18:51:11 <dcoutts_> adas: and you can list multiple of them and do them all in one go (which is generally best practice anyway)
18:51:44 <adas> dcoutts_: thanks much. that looked like it compiled. and yes ./foo/ does have a .cabal file
18:56:55 <adas> hGetContents: invalid argument (invalid byte sequence) ; that error pop up everywhere. i tried doing LANG=en_US.utf8. Not works. Is there something else I should try?
19:01:55 <c_wraith> adas: well, you should set LANG to match whatever your terminal provides.  If it's not providing UTF-8, setting it to utf8 won't help
19:04:28 <adas> c_wraith: i just tried 'export LANG=en_US.UTF-8'. Looks like that worked
19:10:21 <Dulguun> Hi guys
19:11:04 <Dulguun> I've ran into cabal install problem. Looks like someone else had same. But can't find the solution. There even exists this http://lpaste.net/115319
19:11:09 <Dulguun> can someone look at this pls
19:13:32 <dcoutts_> Dulguun: looks very wxc specific. Have you checked their bug tracker or install instructions?
19:16:11 <adas> dcoutts_: thanks for the help.
19:17:03 <Dulguun> No, I haven't
19:26:55 <Streaxy> What's going on guys and gals?
19:27:08 <Dulguun> cabal install wxcore causing this I can't figure it out can someone babysit me on this problem
19:27:13 <Dulguun> http://lpaste.net/115319
19:28:01 <Dulguun> Streaky: Just trying to start learning FRP :D
19:31:16 <dcoutts_> Dulguun: did you look at the info on the package's home page?
19:31:54 <dcoutts_> there's a whole section about installing on windows
19:31:56 <bramgg> Is using "if" in Haskell considered bad? Is there always a better way of doing things?
19:32:39 <dcoutts_> bramgg: it's not bad, but there's also guards, and you can use whichever reads better for the circumstance
19:32:55 <geekosaur> bramgg: it's not bad, /per se/. some uses might be more idiomatically expressed in other ways, but some things are best done with an if
19:33:17 <bramgg> thanks all
19:33:18 <hiptobecubic> if the branch expressions are small, i usually like to use if
19:33:27 <geekosaur> also, in the end it comes down to, will you understand the code next time you run across it?
19:33:29 <Dulguun> Yes, I did all I could. Asking others for help is my last resort
19:33:37 <hiptobecubic> if even x then f x else g x
19:35:19 <dcoutts_> Dulguun: then worth trying the users mailing list
19:35:54 <Dulguun> ok thx
19:36:05 <geekosaur> this might not be easily fixed, I'm afraid. I don't know much about windows but it looks like your version of the C++ Wx libraries uses a different type in some places
19:36:29 <dcoutts_> Dulguun: make sure you explain exactly what you tried, e.g. if it's the same as on the wiki page or if you had to deviate at all
19:36:57 <dcoutts_> Dulguun: just presenting the error message in isolation isn't that helpful for someone trying to help you out
19:38:57 <solatis> how does the haskell community regard very small utility packages ?
19:39:16 <geekosaur> therre are plenty of them already
19:39:20 <geekosaur> sometimes they grow over time
19:39:26 <solatis> i know, for example, in the node.js community it is almost done in extremus, like you have a separate library for the most trivial things
19:39:51 <solatis> right now, i've written a module for attoparsec that helps incrementally parsing socket data (and handles the buffering, etc)
19:39:59 <Dulguun> dcouts_ just add it on the fking package list then run cabal install --only-dependencies
19:40:11 <solatis> it's about 100 LOC, and I wonder whether I should make a separate package out of it
19:40:44 * hackagebot lucid-foundation 0.0.1 - Basic Zurb Foundation API in Lucid  http://hackage.haskell.org/package/lucid-foundation-0.0.1 (athanclark)
19:41:17 <Dulguun> i probably should try this tomorrow, stop flaming out of frustration and exhaustion
19:41:19 <solatis> i guess i should, since i would have used such a library in my case, and parsing data from a socket seems like a pretty common use case (there were a few StackOverflow questions about it already)
19:42:21 <dcoutts_> Dulguun: oh well in that case, have a good look at the windows instructions on the wx home page
19:42:33 <dcoutts_> https://wiki.haskell.org/WxHaskell
19:42:43 <dcoutts_> there's a page for windows, and it's not trivial
19:43:06 <dcoutts_> it's because wx depends on all these C libs, and C libs are always a pain on windows
19:49:01 <Dulguun> hatred towards windows is growing strong. but i can't play my only game dota 2 on linux comfortably. and it's pain in the *ss rebooting everytime i need to switch
19:49:26 <blackdog> Dulguun: you might be better off running virtualbox or something?
19:49:42 <dramforever> Noooo, many graphics problems
19:49:52 <blackdog> i've set my girlfriend's windows machine up for haskell but it's a real pain, and i never got ghc-mod going.
19:49:54 <Dulguun> yeah tried that once. it's too slow
19:50:14 <dramforever> also how about talking about windows in #haskell-blah?
19:50:47 <Dulguun> doesn't haskell platform run on windows?
19:51:09 <dramforever> IMHO it works pretty well
19:51:29 <Dulguun> i think so, but sometimes...
19:51:32 <dramforever> and you can probably get emacs running on windows
19:51:39 <dramforever> </holy-war>
19:51:51 <Dulguun> i even encountered package that uses *.sh for installation
19:51:56 <solirc> asdhio: Did you solve your problem with runhaskell and hspec-discover?
19:51:57 <blackdog> dramforever: yeah, emacs works fine. it's actually a bit of a godsend, the default terminal is pretty grotty.
19:51:58 <Dulguun> fml
19:52:19 <solirc> You probably need to add -isrc -itest to your call to runhaskell
19:52:43 <joneshf-laptop_> is there a way to know if a data type can implement a typeclass without actually attempting to implement it?
19:52:45 <dramforever> Dulguun: iirc haskell platform comes with many unix-y utils
19:52:52 <joneshf-laptop_> aside from making sure it has the correct kind
19:53:15 <solirc> asdhio: Other options are GHCi and guard-haskell
19:53:53 <dramforever> joneshf-laptop_: you want to prove that an instance exists without a concrete instance?
19:54:20 <dramforever> I'm not sure how that's useful. Can you give an use case?
19:54:23 <solirc> asdhio: https://github.com/hspec/hspec-example an http://hspec.github.io/hspec-discover.html
19:54:29 <joneshf-laptop_> dramforever, well, I'd like to just know if it's possible before I go to the trouble of attempting to implement it
19:55:14 <joneshf-laptop_> dramforever, I don't even mean so far as law abiding, I mean just can it implement it from the types
19:56:22 <blackdog> joneshf-laptop_: i think if you could prove you could write it, that would be an example and you wouldn't have to write it, no? like djinn?
19:56:43 <blackdog> you might be able to prove you can't write it
19:57:02 <dramforever> It *could* be possible to have a pure existence proof that an instance exists, but that's hardly useful
19:57:18 <joneshf-laptop_> blackdog, I'm not sure I understand what you just said
19:57:20 <joneshf-laptop_> :)
19:57:27 <asdhio> ah solirc that works well, thanks
19:57:36 <dramforever> joneshf-laptop_: can you give an example? which class are you trying
19:57:49 <joneshf-laptop_> umm
19:57:56 <blackdog> joneshf-laptop_: well, i mean you can probably prove that magic :: IO a -> a can't be written
19:58:27 <blackdog> but i'm not sure how you would prove that it can be written in a non-constructive way
19:58:32 <blackdog> maybe it's possible :)
19:58:40 <joneshf-laptop_> dramforever, let's say `Monad` instance for the data type: `data Foo f a = Bar (f a) | Baz`
19:59:04 <athan> Is there a standard way of working with the hackage / stackage web api? For instance, when cabal-install updates it's cache?
19:59:36 <dramforever> joneshf-laptop_: Ask yourself: are you going to use (Foo f) as a monad?
19:59:58 <athan> I'm gonna get a list of all top-level terms of every module in every version of every package :|
20:00:12 <dramforever> joneshf-laptop_: also why won't a Maybe suffice?
20:00:20 <dramforever> Maybe (f a)
20:01:26 <dramforever> joneshf-laptop_: Okay how about this: Here's what I usually do
20:01:28 <joneshf-laptop_> dramforever, okay, then mak eit more complex: `data Foo f g a = Bar (f (Foo f g a)) | Baz (Foo f g a) (Foo f g a) | Quux`
20:01:40 <dramforever> 1. Do I use it as one?
20:01:42 <Dulguun> guys do you know any good reactive-banana tutorials? i can't find any except their own examples
20:01:56 <dramforever> joneshf-laptop_: oh let me check
20:02:11 <dramforever> 2. How should it work?
20:03:01 <joneshf-laptop_> dramforever, I think my question was phrased improperly
20:03:21 <dramforever> joneshf-laptop_: is g useful?
20:03:22 <athan> Dulgunn: That's how a lot of things are, here :\. The best thing to do, is try and find the philosophy from the author
20:03:33 <athan> so either their examples, or the white paper published with it
20:03:46 <dramforever> joneshf-laptop_: Can you just drop the g?
20:04:15 <joneshf-laptop_> dramforever, I'm just wondering if there's some way to know statically for each datat type, which type classes it could implement, no matter if they're useful or law abiding, or whatever
20:04:26 <joneshf-laptop_> dramforever, sure, I just made that up :)
20:04:54 <athan> joneshf-laptop_: Wait, you mean you want constraints for data constructors?
20:04:58 <athan> cause you can do that :)
20:05:08 <joneshf-laptop_> athan, what does that mean?
20:05:21 <dramforever> athan: no
20:05:27 <athan> oh
20:05:40 <dramforever> It seems undecidable to me
20:05:46 <joneshf-laptop_> :(
20:05:51 <joneshf-laptop_> i figured as much
20:05:52 <athan> joneshf-laptop_: Something like `data Foo where Foo :: Eq a => a -> Foo`
20:06:04 <joneshf-laptop_> athan, oh, no :)
20:06:11 <dramforever> athan: no that's not what joneshf-laptop_ wants
20:06:18 <athan> :c uselessness abound
20:12:20 <sclv> dfeuer: ping
20:12:34 <dfeuer> sclv, pong.
20:12:41 <sclv> so take a look at this: http://lpaste.net/120579
20:12:51 <sclv> its old folklore that I knocked out a version of
20:13:09 <sclv> for more efficient fold of monoidal/associative things over plain lists
20:13:30 <dfeuer> sclv, what is this?
20:13:33 <sclv> iirc it beats foldr and foldl on simple examples, although foldl' still is more efficient
20:14:24 <sclv> anyway i remembered it and was struck with the idea that for a future release, maybe, possibly
20:14:41 <sclv> we could substitute something like it in for foldMap and fold in the Foldable defn for list
20:14:45 <dfeuer> sclv, release of what?
20:14:53 <sclv> of Prelude
20:15:03 <sclv> or am i pinging the wrong person? i seem to recall you liked things like this :-)
20:15:07 <dfeuer> That will never replace foldMap for lists.
20:15:08 <dfeuer> I do,
20:15:20 <dfeuer> I just wondered if there was more context.
20:15:23 <sclv> is the reason that it would change semantics?
20:15:44 <sclv> I think that as it stands, it is strictly semantics-preserving but more efficient
20:15:45 * hackagebot list-t 0.3.3 - ListT done right  http://hackage.haskell.org/package/list-t-0.3.3 (NikitaVolkov)
20:15:47 * hackagebot list-t 0.2.7 - ListT done right  http://hackage.haskell.org/package/list-t-0.2.7 (NikitaVolkov)
20:16:05 <sclv> unless we've already improved the default foldMap for lists and I didn't realize?
20:16:16 <sclv> in which case sorry for the noisse
20:18:29 <sclv> (clearly we're not going to replace foldr and foldl with it, since they're different beasts...)
20:19:04 <sclv> or have you investigated these types of tricks and discovered that they don't improve things as much as I recall/think?
20:20:22 <dcmkkk1> hi
20:21:54 <athan> hi dcmkkk1
20:22:27 <dramforever> hi
20:22:38 <lifter> Is it acceptable to append ' to a function name for reasons other than distinguishing between lazy and strict? For example, say I have a function that works on lists/Strings and another that does the same thing but works on Text. Can I name them the same thing but tack a ' on the end of the one that works on Text?
20:23:17 <blackdog> lifter: ew. :)
20:23:37 <blackdog> maybe more idiomatic to put them into different modules and export the same name from both?
20:23:54 <athan> lifter: I would split those either into modules, or inlcude "strict" in the term names or something :)
20:24:07 <athan> it totally depends on your namespace though
20:24:18 <athan> and strictness ~ string vs. text
20:24:25 <lifter> It didn't occur to me to put them in different modules.
20:24:28 <athan> erm ~/~
20:24:40 <lifter> athan: What does ~/~ mean?
20:24:40 <athan> :)
20:24:44 <dramforever> lifter: a' is a function slightly different to a
20:24:49 <athan> have you seen the MissingH package?
20:24:55 <athan> oh, not equivalent
20:25:06 <lifter> athan: Me? I haven't looked into it much.
20:25:18 <athan> It's got a lot of string utilities
20:25:32 <athan> idk, I rarely need to make both string and text functions.
20:25:45 * hackagebot prednote 0.30.0.0 - Evaluate and display trees of predicates  http://hackage.haskell.org/package/prednote-0.30.0.0 (OmariNorman)
20:25:55 <dramforever> lifter: like: (not really idomatic, though) modify f = do x <- get; let x' = f x; put x'
20:27:17 <lifter> dramforever: Right; my thinking was if I have two functions that do the same thing, only one works on lists while the other works on Text, then I could put ' on the end of the name of the function that works on Text, only then I thought that might be misleading
20:29:55 <dramforever> lifter: well
20:30:06 <dramforever> for that put them in different modules
20:30:11 <lifter> yeah
20:31:02 <lifter> that makes sense
20:32:32 <dramforever> cabal: "Warning: The package list for 'hackage.haskell.org' is 24.9 days old."
20:32:41 <dramforever> seriously? 24.9 days?
20:32:58 <blackdog> dramforever: so update it?
20:33:00 <c_wraith> woo! unnecessary precision!
20:33:02 <dramforever> why would anyone need that precision?
20:33:03 <blackdog> oh, i see :)
20:33:08 <dramforever> c_wraith: agree
20:33:31 <athan> lol
20:33:34 <glguy> You'd prefer fortnights?
20:33:49 <dramforever> why it doesn't just show 25 days
20:33:52 <c_wraith> milliyears
20:33:59 <carter> dramforever: patchit
20:34:13 <Hermit> I'd prefer days and hours for such precision
20:34:42 <dramforever> yeah
20:34:57 <dramforever> but why would a 1-hour old package database cause trouble?
20:35:10 <dramforever> (other than installing newly installed packages, of course)
20:35:20 <dramforever> s/newly installed/newly updated/
20:36:05 <dramforever> also it would be great if it were like rubygems, where the package dependencies are fetched only when needed
20:36:26 <dramforever> (maybe we haskell people has less money...who knows...)
20:36:28 <carter> the index != pkge
20:36:53 <dramforever> carter: rubygems does this:
20:37:03 <dramforever> 1. hmm..you want package foo
20:37:36 <dramforever> [disclaimer: this is only iirc. correct me if needed]
20:38:13 <dramforever> 2. let me download that...unpack...whoa: metadata file says that it needs bar and baz
20:38:15 <sclv> dfeuer: to clarify further, i am aware the signature it has now doesn't match F.fold or F.foldMap correctly, but its easy enough to apply the trick to them as well
20:38:23 <dramforever> let's install them first
20:38:35 <sclv> its basically mergeSort with a monoidal stuck in place of the sorted merge
20:38:48 <dramforever> Actually, even if rubygems doesn't work that way, I think we can make a haskell package system that way
20:39:21 <sclv> monoidal op that is
20:45:03 <Hermit> dramforever: problem is: how would such system inform the user of the amount of work to be done beforehand?
20:45:03 <carter> dramforever: we kind aneed to do the build plan phase before installing anything
20:45:33 <dramforever> hmm...oh
20:45:37 <dramforever> those flags things...
20:45:52 <dramforever> Hermit: I think that the current cabal doesn't do this
20:46:01 <Hermit> dramforever: --dry-run
20:46:15 <enthropy> pieces of the index could be downloaded while the build plan is being made up
20:46:40 <dramforever> Hermit: yes that's how I expect it
20:47:00 <dramforever> how about doing this on demand?
20:47:18 <dramforever> whenever we want info about foo but we don't have it yet we download it
20:48:32 <geekosaur> nice assuming everyone has always-on internet
20:48:40 <dramforever> geekosaur: well
20:49:02 <dramforever> why would you not have internet when you want a package?
20:49:15 <carter> because you're on an daventures
20:49:16 <Hermit> cache and git repos
20:49:25 <dramforever> you need to download packages anyway
20:49:30 <carter> dramforever: theres actually some neat work in progress to make it easy to host a snapshot of hackage locally
20:49:33 <blackdog> dramforever: yeah, it's pretty common at hacking camps not to have reliable internet
20:49:41 <blackdog> and you can still install from cache
20:50:11 <dramforever> blackdog: does cabal cache packages?
20:50:26 <blackdog> yeah
20:50:36 <dramforever> blackdog: how?
20:50:37 <blackdog> otherwise you'd have to download them every single time
20:50:41 <dramforever> oh
20:50:54 <dramforever> in my system there could be a cache too
20:50:56 <blackdog> i have no idea :) but there's a client-side global cache of the source.
20:51:09 <carter> dramforever: package managers are hard work
20:51:10 <cwraith> it's something like ~/.cabal/cache
20:51:17 <carter> dramforever: ask bernalex for war stories
20:51:32 <enthropy> "4.8M 00-index.tar.xz" vs. "8.3M 00-index.tar.gz"
20:51:40 <blackdog> https://twitter.com/HaskellCEO/status/567182651065651201 oh wow, that _does_ kill hoogle.
20:51:52 <dramforever> enthropy: how about bzip?
20:51:57 <enthropy> somewhere in the middle?
20:52:07 <enthropy> currently cabal downloads .gz
20:52:31 <carter> blackdog: truee
20:53:08 <geekosaur> ports-based systems have a similar problem to cabal, you need to download and configure a given port to find out the actual deps you need. freebsd's ports maintenance utilities (portupgrade, portmaster) have ways to help with this, as does macports. (I don't know offhand about gentoo portage)
20:53:09 <godel> blackdog: try in ghci ":t id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id.id"
20:53:28 <geekosaur> but it's a level of complexity beyond what e.g. apt-get has to deal with
20:53:41 <blackdog> godel: ... yeah? just gives c -> c
20:54:31 <geekosaur> worse, you must do so recursively because options/variants/whatever the build system calls them can impact your dependencies and cause them to need more dependencies...
20:55:14 <geekosaur> (I should note that I know quite a few folks who download/configure at the hotel and build/install on the plane...)
21:02:25 <matt1> I tried to create a db schema with persistent and it caused a stack overflow. Anyone know what I can do to fix it? https://gist.github.com/mr/328a9fd2d61b26f8cc1a
21:02:42 <matt1> if i can't get this to work i might have to write this in *gasp* python
21:13:35 <dramforever> geekosaur: did you mean ":t id id id id id"
21:13:51 <dramforever> wait that's still id
21:14:10 <dramforever> what did you mean?
21:14:47 <EvanR> rot13 rot13 rot13 rot13 rot13
21:20:46 * hackagebot resourcet 1.1.4 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-1.1.4 (MichaelSnoyman)
21:27:48 <ReinH> EvanR: id and rot13 form a group of order 2 :D
21:28:24 <cwraith> dramforever: the thing about the expression (id id id id id id) is that typechecking it in GHC requires space that's exponential in the number of ids you put in
21:28:51 <dramforever> hmm
21:28:54 <dramforever> let me see
21:29:39 <orzo> what's the reverse operation of "serialize" generally called?  parse? unserialize?
21:30:01 <Rotaerk> deserialize
21:30:28 <Rotaerk> the HXT library seems to call it pickling and unpickling ...
21:30:54 <cwraith> pfft.  hxt.  it requires like a gigabyte of ram to link, too.  What's it know? :P
21:30:57 <orzo> well im using Data.Binary
21:30:58 <c74d> geekosaur: don't the package definitions include lists of dependencies?
21:31:11 <cwraith> only direct, not transitive
21:31:12 <Rotaerk> cwraith, any better options for XML processing?
21:31:30 --- kick: shapr was kicked by shapr (Kicked by shapr)
21:31:40 <Rotaerk> seems like ever since I started using HXT, GHC keeps periodically crashing while I'm using GHCi
21:31:40 <shapr> yup, that still works
21:32:25 <cwraith> Rotaerk: there are a few things it does very nicely, which are painful in any other library.  But most of the time, I'm not looking for that stuff, and just want something like the xml package
21:33:31 <Rotaerk> I just used it for its pickler
21:33:59 <dramforever> whoa
21:34:18 <Rotaerk> whoa what?
21:34:24 <dramforever> I put like 18000 "id"s into ghci and it starts hogging memory
21:34:32 <dramforever> went to 2.9G and I killed it
21:34:35 <bitemyapp> Rotaerk: http://hackage.haskell.org/package/xml-conduit is well maintained.
21:34:42 <bitemyapp> dramforever: how did you do that?
21:34:43 <Axman6> ... you only need like 30 to see the effect...
21:35:01 <dramforever> bitemyapp: copy, paste
21:35:08 <dramforever> line editing
21:35:14 <orzo> i like xml-conduit
21:35:34 <orzo> especially the clark-notation and IsString instances
21:36:01 <asodij> how can i get information such as how many inputs were generated for each QuickCheck property while using hspec?
21:36:19 <dramforever> Axman6: no, I put 180 and no obvious effects
21:36:35 <dramforever> wait a sec, I think I'll need to edit .ghci_history
21:36:48 <dramforever> oh, ~/.ghc/ghci_history
21:38:33 <dmj`> asodij: verboseCheck
21:38:48 <asodij> dmj`: what do i do with that?
21:39:19 <dramforever> :t verboseCheck
21:39:20 <lambdabot> Testable prop => prop -> IO ()
21:39:30 <dramforever> dmj`: are you sure?
21:41:09 <asodij> ah okay i see
21:42:14 <dmj`> verboseCheck will print out more information, but hspec's quickcheck use seems to only let you use the property function from the Testable class. I'd ask solic in #hspec
21:42:18 <dmj`> solirc*
21:43:29 <orzo> would it be better to use Coercable for this? https://hackage.haskell.org/package/byteable-0.1.1
22:05:57 <gfixler1> http://lpaste.net/120583
22:06:09 <gfixler1> simple sparklines
22:08:32 <dramforever> gfixler1: maybe also a space?
22:08:44 <dramforever> " ‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà"
22:08:50 <gfixler1> dramforever: I tried that, but it made the lines look broken
22:08:59 <gfixler1> I don't think I've ever seen a sparkline with a gap in it
22:09:05 <gfixler1> it looks like 2 sparklines
22:09:09 <gfixler1> have you seen them with spaces before?
22:09:11 <Axman6> _
22:09:13 <dramforever> okay
22:09:17 <gfixler1> _ might work
22:09:49 <Axman6> possibly not the best choice, because _ is more likely to vary between fonts
22:12:26 <gfixler1> Axman6: yeah, it looks a bit weird
22:12:28 <gfixler1> _‚ñÑ‚ñÅ‚ñÑ_‚ñÖ‚ñà‚ñÇ
22:12:34 <Axman6> yeah
22:12:50 <Axman6> also, isn't there already a sparklines package on hackage?
22:13:02 <gfixler1> Axman6: yeah, I'm not putting this on hackage
22:13:17 <gfixler1> I was just playing around, looking for a simplest version
22:13:26 <gfixler1> this doesn't work with stdin or anything like that, e.g.
22:13:30 <dramforever> Axman6: huh? which?
22:13:33 <Axman6> hmmm, that page renders very strangely for me, the bseline of the blocks is different for each one
22:13:44 <dramforever> oh found oe
22:13:45 <dramforever> one
22:13:56 <gfixler1> Axman6: yeah, that also seems font-based
22:14:33 <gfixler1> http://hackage.haskell.org/package/hsparklines-0.1.0
22:14:43 <bitemyapp> gfixler1: what happened to gfixler0?
22:14:56 <bitemyapp> gfixler1: did he get his blood succ'ed by vampires?
22:15:24 <gfixler1> He was taken out by Adam Gibson
22:15:46 <bitemyapp> who's that?
22:15:56 <gfixler1> http://www.imdb.com/title/tt0216216/
22:16:06 <solirc> asodij: Hspec does not include that in the test output, but you see a counter while the test is running.  100 is the default, but you can increase it by passing e.g. `-a 1000` to hspec.
22:18:22 <gfixler1> Axman6: just realized hsparklines renders to an image, not ASCII
22:22:16 <rui> Helloo :)
22:22:32 <Cale> hi
22:23:29 <rui> Hi Cale. First time here. How's it going
22:23:34 <Cale> All right :)
22:23:47 <Cale> Feel free to ask any questions you might have about Haskell
22:24:15 <rui> Thanks! I am just starting with Haskell and love it
22:24:38 <rui> but am struggling with installing stuff. I don't understand cabal well enough.
22:25:08 <matt1> rui: welcome to cabal hell
22:25:30 <rui> Haha, thanks
22:29:02 <Cale> If you have error messages and stuff that you're trying to sort out, you can paste them on lpaste.net and link us here. monochrom has written some helpful guides here http://www.vex.net/~trebla/haskell/sicp.xhtml and here http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml with tips about cabal
22:29:43 <rui> Thanks Cale. I'll check those links out now. I am, for example, trying to check out Yi, but failing to install it
22:30:07 <rui> It always fails at building vty
22:34:20 <matt1> has anyone here used persistant for yesod projects at all?
22:37:58 <Cale> rui: Is there any kind of message that could indicate why?
22:38:40 <rui> Cale, vty fails during the building phase. Exception ExitFailure 1
22:39:53 <rui> I tried with cabal install vty. Also by git cloning vty, and cabal install. Also tried it after cabal sandbox init. But I don't have a clear idea of what I am doing yet
22:42:34 <dramforever> rui: try reading the output
22:42:38 <dramforever> scroll up
22:44:59 <rui> dreamforever The first weird things in the output when installing vty are of this kind: /usr/local/lib/terminfo-0.4.0.1/..... "in function ...... undefined reference to `...`
22:45:26 <dramforever> rui: 1. look at my nick again
22:45:40 <dramforever> 2. how is http://lpaste.net ? try it
22:45:41 <rui> dram, dram
22:46:19 <rui> http://lpaste.net/120590
22:46:30 <rui> There we go
22:47:20 <hiptobecubic> I'm confused about the behavior of Data.IntMap.insertLookupWithKey
22:47:28 <hiptobecubic> Suppose the values in my map are expensive to compute
22:49:03 <hiptobecubic> If do something like inesrtLookup existingKey (expensive thunk), it will replace the existing known value with expensive thunk
22:50:06 <bob_twinkles> what do you expect it to do?
22:50:17 <hiptobecubic> Is there a way to only modify the set if you're inserting? As in, if the key existed, just return the value and ignore my expensive thunk? This is assuming that the value is fixed/idempotent of course
22:51:01 <hiptobecubic> i guess an analog would be python's   dict.setdefault(key, newvalue), except that it's not lazy so you end up recomputing every time there as well
22:51:38 <hiptobecubic> I could write a function to do a membership test first and then insert if needed, but it seems kind of janky to do it that way
22:51:53 <dramforever> rui: do you have ncurses installed?
22:51:59 <EvanR> hiptobecubic: it has to at least compute enough of your thing to compare it to the other keys
22:52:05 <dramforever> I think you need the development packages
22:52:21 <EvanR> hiptobecubic: the key is the value in a set
22:52:25 <dramforever> rui: are you using linux?
22:52:46 <dramforever> hiptobecubic: janky? how?
22:52:48 <rui> dramforever yes, fedora
22:52:51 <dramforever> rui:
22:52:53 <hiptobecubic> EvanR, sure, but the keys are Ints here and cheap to get. The values are potentially expensive and don't ever require comparison
22:53:05 <dramforever> ouch, you should install ncurses-devel
22:53:17 <EvanR> hiptobecubic: well that values dont require anything if you never look at them
22:53:27 <ReinH> hiptobecubic: well, insertWith f k v mp where f new old = old will preserve existing keys.
22:53:29 <rui> dramforever, I do have ncurses. I will try devel now!
22:54:02 <dramforever> rui: you could also be missing a library
22:54:03 <EvanR> ReinH: in a set, it replaces the value, which is what hiptobecubic is worried about
22:54:17 <ReinH> I mean preserve the existing value
22:54:24 <hiptobecubic> Right, no i see it. of course. thanks ReinH
22:54:34 <EvanR> another weird difference between Data.Set and "math set"
22:54:42 <dramforever> rui: after that you might need to reinstall those packages
22:55:05 <EvanR> ReinH: insertWith for Map?
22:55:22 <HeladoDeBrownie> EvanR, is "equal but not the same" even a thing in math?
22:55:22 <ReinH> EvanR: or IntMap as hiptobecubic originally said
22:55:24 <dramforever> @pl \ new old -> old
22:55:24 <lambdabot> const id
22:55:34 <EvanR> HeladoDeBrownie: sure right... equivalence classes
22:55:54 <HeladoDeBrownie> EvanR, so in other words haskell equality is not true equality then
22:55:55 <EvanR> oh i didnt read back for enough
22:55:58 <ReinH> EvanR: "set" was used later but I assumed IntMap was meant
22:56:09 <EvanR> HeladoDeBrownie: true equality?
22:56:12 <EvanR> heh
22:56:20 <dramforever> instance Eq BasicallyAnything where (==) = undefined
22:56:27 <HeladoDeBrownie> eh, i don't know exactly how to put it :P part of why i'm asking for clarification
22:56:37 <ReinH> HeladoDeBrownie: equality is a tricky concept :)
22:57:17 <ReinH> is f x = x * 2 equal to g x = x + x?
22:57:36 <ReinH> The answer is "yes or no, depending on your definition of equal".
22:57:44 <coltfred> I'm using the either lib for EitherT and I'm creating EitherT Error IO a. I have a value of IO a, what's the correct way to lift that into the EitherT? Seems a EitherT . fmap Right  will do it, but I was wondering if there's a better way.
22:57:50 <HeladoDeBrownie> ReinH, extensional versus intensional you mean?
22:57:54 <ReinH> HeladoDeBrownie: right
22:58:13 <dramforever> coltfred: the idiomatic way is liftIO
22:58:50 <EvanR> automatically "deriving" some equality relation between any math entities seems weird, but necessary when you have sets
22:58:54 <coltfred> dramforever: Ah ha! Ok!
22:59:15 <ReinH> HeladoDeBrownie: In order for "equal but not the same" to be meaningful, you have to first define "equal" and "the same" :)
22:59:33 <rui> dramforever If I create a sandbox in the folder where I cloned vty, and cabal install --package-db=clear, would that be a good test?
22:59:34 <EvanR> all 3 are the same, so if you want identities attached you need tuples, and so now you have to ask whether the tuples containing the same things are the same. seems silly
22:59:44 <EvanR> all 3's
22:59:51 <rui> I just did it without the package-db (after yum installing ncurses-devel) and it failed in the same way
22:59:52 <dramforever> rui: I don't really knwo
22:59:54 <HeladoDeBrownie> ReinH, i suppose i should have asked what the "weird difference between Data.Set and 'math set'" was exactly
22:59:55 <dramforever> *know
23:00:10 <HeladoDeBrownie> i know they're different i just don't know offhand quite how
23:00:17 <EvanR> HeladoDeBrownie: i was referring to Ord instances where you can EQ for "distinct values" of the type
23:00:26 <EvanR> Data.Set specifically acts a certain way here
23:00:31 <HeladoDeBrownie> ah, i see
23:00:41 <dramforever> HeladoDeBrownie: Data.Set is a binary search tree (BST)
23:01:06 <HeladoDeBrownie> although, doesn't that violate one of the invariants of Ord? that it be a total order?
23:01:21 <EvanR> i think i heard some say that is a misbehaved Ord instance, yet there are no laws
23:01:39 <dramforever> EvanR: there are no laws for Num
23:01:47 <HeladoDeBrownie> to me it looks like there are laws but they're not written out explicitly
23:02:06 <dramforever> anything with type Num a => a is suspicious
23:02:17 <HeladoDeBrownie> (for Ord i mean; the docs say total order)
23:02:28 <dramforever> (doesn't really mean that it's wrong)
23:02:37 <EvanR> in the case that the rule is that EQ values should "be the same" then why would set replace the value?
23:02:56 <HeladoDeBrownie> i guess the bug here is that we can't check that an Ord instance represents a total order
23:03:01 <HeladoDeBrownie> perhaps a stronger logic is in order :P
23:03:07 <dramforever> for example, Matrix is an instance of Num
23:03:13 <dramforever> but should it?
23:03:16 <EvanR> would make sense if Set just broke when your type didnt follow the rules
23:03:58 <dramforever> Oh, and also I heard that Data.Set and Data.Map perform really well
23:04:03 <ReinH> HeladoDeBrownie: does what violate the invariants of Ord?
23:04:17 <rui> dramforever Nope. When you said I might be missing other libraries, you mean haskell library dependencies that one might expect cabal to install automatically?
23:04:19 <dramforever> they are not very much slower than hash tables in other languages like python, ruby, etc.
23:04:31 <EvanR> it could be a documentation snafu
23:04:33 <HeladoDeBrownie> ReinH, never mind, i think i misthought something there.
23:04:41 <ReinH> HeladoDeBrownie: ok :)
23:04:45 <dramforever> rui: I mean, since you are missing some symbols
23:04:58 <dramforever> you might be missing some file that contains them
23:05:05 <ReinH> dramforever: they are a log factor slower asymptotically, but the constants can be quite good.
23:05:17 <dramforever> I'm not very familiar with the details, though
23:05:19 <rui> Right. I might try to reinstall that terminfo thing
23:05:29 <rui> Thanks btw
23:05:30 <HeladoDeBrownie> ReinH, oh actually, if we take the general sense of Ord being a total order, and since Ord implies Eq, we should be able to check that, for all a and b, a <= && b <= a implies a == b
23:05:35 <ReinH> Unfortunately some of the detail is locked behind a pay wall :( http://journals.cambridge.org/action/displayAbstract?fromPage=online&aid=1322688&fileId=S0956796800000885
23:05:49 <ReinH> But the Data.Set docs also link to http://groups.csail.mit.edu/mac/users/adams/BB/
23:05:55 <ReinH> which is nice
23:06:17 <EvanR> haha pay-per-free software
23:06:26 <EvanR> or the secrets behind it
23:06:55 <ReinH> HeladoDeBrownie: total orders are antisymmetric, yeah
23:06:59 <dramforever> weird: why "monads", "category", etc. are scary
23:07:16 <dramforever> while "strings", "objects", "arrays" are not
23:07:22 <dramforever> (I mean those names)
23:07:37 <EvanR> strings should be considered more scary than they are
23:07:39 <dramforever> "Hash Table!"
23:07:44 <Hijiri> I hadn't heard of monads or categories (in the math sense) before haskell
23:07:47 <HeladoDeBrownie> the latter are commonplace in mainstream languages. the former are not
23:08:06 <EvanR> strings objects and arrays, all scary
23:08:15 <dramforever> EvanR: I mean, the word "monad" puts haskell beginners off
23:08:21 <dramforever> scare them away
23:08:21 <EvanR> i know
23:08:30 <ReinH> dramforever: well, one of those sets of things consists of very well defined terms. Although actually "object" fits in both for different definitions.
23:08:34 <dramforever> why "string", and even "hash table" don't
23:08:34 <EvanR> we should forbid it from being uttered
23:08:43 <hiptobecubic> dramforever, people have traditionally been scared of anything that sounds like math
23:08:43 <quchen2> Strings aren't scary because very rarely do you see someone explain them as "simply the free monoid of characters".
23:08:50 <ReinH> dramforever: (the other one has "string" and "array" in it ;)
23:09:05 <HeladoDeBrownie> class (Applicative f) => SequenceContainerSortOfThingAbstraction f where ‚Ä¶
23:09:40 <HeladoDeBrownie> (being completely aware that monad doesn't have specifically to do with sequences or containers)
23:09:42 <hiptobecubic> HeladoDeBrownie, people do ask why it's not named that way.
23:10:07 <hiptobecubic> "class Mappable.." "Class Appendable..." etc
23:10:14 <dramforever> how about database jargon: "primary key"
23:10:37 <HeladoDeBrownie> hiptobecubic, so then the question is why we don't have those and, say, class Joinable?
23:10:39 <EvanR> interface IConjable
23:10:46 <ReinH> quchen2: strings are also scary for entirely other reasons, like encodings.
23:10:59 <HeladoDeBrownie> hiptobecubic, i don't think that would be so bad, really.
23:11:01 <hiptobecubic> And when you point out that there's no decent reason to rename everything people are turned off because they already knew what "appendable" probably meant but don't know what monoid means other than "math shit"
23:11:19 <quchen2> Monads, functors and everything are useful as a way of thinking even in other languages, so time will fix the scare issue. (Or maybe make it worse, because understanding monads in Javascript is the horror.)
23:11:27 <EvanR> ReinH: i was thinking of how its possible and obvious to use strings to do things that lose a lot of safety
23:11:28 <ReinH> Appendable is nice enough. I'm not sure there's a reasonable version for Monad.
23:11:34 <dramforever> also, I remember seeing this alternative, CPS-ish sequencing method:
23:11:34 <quchen2> ReinH: ByteString.Char8 lalalalalala
23:11:39 <ReinH> quchen2: :D
23:11:39 <HeladoDeBrownie> ReinH, not Joinable?
23:12:01 <dramforever> Every action takes the next action to perform as an argument
23:12:08 <ReinH> HeladoDeBrownie: Hmm, Joinable could also be Monoid. Which makes sense for reasons.
23:12:11 <quchen2> class BindOrJoinable where
23:12:16 <HeladoDeBrownie> ReinH, yeah, i suppose so.
23:12:20 <quchen2> class Fmappable, class MultiFmappable
23:12:23 <EvanR> Monoid is Appendable? not Prependable?
23:12:28 <EvanR> Bipendable?
23:12:29 <dramforever> So there's a hole, right? The runtime system fills it in and starts all this
23:12:32 <ReinH> HeladoDeBrownie: (join is a monoidal product)
23:12:45 <quchen2> EvanR: Mappendable, to be specific
23:12:45 <dramforever> Concatable
23:12:47 <hiptobecubic> The problem I have with renaming everything is that these things weren't all invented for programming. It makes people even *less* likely to draw connections between the mountains of research that has been done and the properties of their programs
23:12:55 <ReinH> dramforever: Concatable is nice
23:13:05 <ReinH> Concatenable is I think the actual word, fwiw
23:13:15 <dramforever> why not just Concat?
23:13:21 * ReinH shrugs
23:13:23 <dramforever> given that we have Read, Show
23:13:31 <ReinH> Sure
23:13:41 <HeladoDeBrownie> hiptobecubic, i haven't heard any good arguments to rename everything. it seems like it would be a lot of effort and breakage for no obvious gain. but imagine a new language used those things (doesn't idris do something like that?)
23:13:51 * dramforever wonders if anyone saw my point about sequencing
23:14:05 <ReinH> dramforever: the CPS thing?
23:14:07 <dramforever> yep
23:14:11 <EvanR> HeladoDeBrownie: nope, other than rearrange the obvious things in Monad and Applicative
23:14:15 <dramforever> I remember seeing it somewhere
23:14:19 <hiptobecubic> HeladoDeBrownie, a lot (most?) languages with interfaces seem to do that. I'm arguing that it's not a good idea to do so.
23:14:20 <ReinH> dramforever: as an alternative to what?
23:14:34 <dramforever> ReinH: Monads-based sequencing
23:14:51 <dramforever> newtype IO a = (a -> Unobtainium) -> Unobtainium
23:14:52 <ReinH> dramforever: Well, CPS is a monad so
23:15:01 <dramforever> ouch
23:15:06 <ReinH> dramforever: :p
23:15:11 <ReinH> @unmtl Cont r a
23:15:11 <lambdabot> (a -> r) -> r
23:15:20 <dramforever> newtype IO a = IO ((a -> Unobtainium) -> Unobtainium)
23:15:38 <dramforever> The point is: we no longer have that (>>=) jargon
23:15:40 <HeladoDeBrownie> hiptobecubic, i guess in essence you could say naming them after the thing that inspires them promotes reuse, but it's not code reuse but rather logic(?) reuse
23:16:02 <hiptobecubic> HeladoDeBrownie, but *neither* promotes code reuse
23:16:05 <dramforever> it makes perfect sense to me
23:16:09 <hiptobecubic> and logic reuse is the hard part anyway
23:16:11 <EvanR> clojure has several standard backend interfaces with meaningful sounding names, they are named after the one or two operations in them, and they dont mean a damn thing in practice since they not only have no laws, but no types either
23:16:13 <ReinH> dramforever: If the goal is to teach monads, I think the fmap, return, join construction is the better way anyway
23:16:16 <EvanR> (dynamically typed)
23:16:56 <ReinH> although fmap, <*>, =<< has its own advantages
23:16:58 <dramforever> ReinH: Monads = m (m (m ... a )) (any numbers of m, including no m) -> m a
23:17:11 <dramforever> return: 0 -> 1
23:17:22 <dramforever> join: n+1 -> n where n >= 1
23:17:23 <HeladoDeBrownie> hiptobecubic, yeah, i didn't mean to imply that giving them "easier" names promoted code reuse
23:17:31 <ReinH> dramforever: return :: 1 -> M :)
23:17:38 <dramforever> oh another:
23:17:54 <dramforever> why people accepted "#include <stdio.h>"
23:17:58 <EvanR> renaming would serve little practical purpose
23:18:20 <dramforever> also what's that stupid "using namespace std;"
23:18:21 <HeladoDeBrownie> EvanR, but would it serve impractical purposes?</facetious>
23:18:25 <EvanR> its easier to reconfigure programmers reaction to jargon than reconfigure decades of code
23:18:32 <ReinH> HeladoDeBrownie: the best kind of purpose
23:18:43 <ReinH> HeladoDeBrownie: I'm writing an 8080 emulator for impractical purposes :)
23:18:48 <HeladoDeBrownie> \o/
23:19:25 <dramforever> if we can accept that "#include <stdio.h>" brings us printf, scanf, etc
23:19:42 <EvanR> especially when the names we have are even justified by something
23:19:45 <dramforever> then why can't we accept that Monad m brings us do?
23:19:50 <dramforever> do notation?
23:20:01 <ReinH> EvanR: I think those names can help with teaching though
23:20:08 <dramforever> The translation from do into (>>=) is trivial and easy to understand
23:20:21 <ReinH> EvanR: And we have a bit of that with classes like Apply and Bind
23:20:28 <ReinH> which are newer
23:20:40 <lpaste> bramgg pasted ‚ÄúShouldn't !! work for any list? What am I doing wrong?‚Äù at http://lpaste.net/120591
23:20:53 <bramgg> ^
23:21:10 <EvanR> teaching
23:21:31 <ReinH> bramgg: fmap, not =<<
23:21:32 <EvanR> people are better at learning than teachers are at teaching
23:21:33 <dramforever> bramgg: !! won't work on IO
23:21:46 <ReinH> =<< works with functions a -> m b
23:21:47 <EvanR> if they arent good at learning teachers will not help
23:21:52 <ReinH> (!! 0) is shaped a -> b
23:21:59 <dramforever> bramgg: yes, ReinH is correct
23:22:02 <ReinH> fmap works with functions shaped a -> b
23:22:04 <bramgg> ah, thanks
23:22:05 <dramforever> (!! 0) :: [a] -> a
23:22:06 <ReinH> :t fmap
23:22:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:22:09 <ReinH> :t (=<<)
23:22:10 <lambdabot> Monad m => (a -> m b) -> m a -> m b
23:22:14 <ReinH> :t (!! 0)
23:22:15 <lambdabot> [a] -> a
23:22:26 <ReinH> bramgg: in this case, [a] is a and a is b :)
23:22:27 <dramforever> hmm so they were similar but not the same
23:22:38 <ReinH> =<< would work with a function [a] ->
23:22:43 <ReinH> =<< would work with a function [a] -> IO a
23:22:47 <haasn> bramgg: (!! 0) has the type [IO Char] -> IO Char  here, but you are using it with an argument of type IO [String]
23:23:02 <dramforever> bramgg: you are proabably still keeping a bit of those imperative programming habits
23:23:14 <ReinH> bramgg: which is why x >>= return . f = fmap f x :)
23:23:14 <dramforever> or you didn't understand (=<<)
23:23:20 <haasn> Also, (!! 0) is just (head), and (head) will crash when it receives an empty list as input
23:23:41 <haasn> (Those two are not relevant to your type error, but you probably want to get them sorted out to improve the quality of your code in general)
23:23:44 <dramforever> Also, why wouldn't hGetLine suffice?
23:23:59 <ReinH> Among the opportunities for improvement in this code...
23:24:10 <bramgg> Thanks everyone
23:24:30 <ReinH> bramgg: as a general rule, if you're using !! you're probably doing something wrong ;)
23:24:47 <dramforever> Common Newcomer Misconception: lazy evaluation optimizes my code
23:25:01 <ReinH> dramforever: sometimes yes, sometimes no
23:25:13 <ReinH> maybe more no than yes
23:25:22 <bramgg> ReinH: Wait... Why is that? It seems so basic and useful.
23:25:27 <blackdog> ReinH: i think he might be talking about the conflation of memoisation and laziness
23:25:34 <dramforever> ReinH: I remember seeing filter (\l -> length l == 2) (subsequences "abc")
23:25:35 <ReinH> bramgg: because linked lists are not for random access.
23:25:44 <dramforever> > subsequences "abc"
23:25:45 <lambdabot>  ["","a","b","ab","c","ac","bc","abc"]
23:25:57 <ReinH> bramgg: so if you are trying to access them randomly, you are either using the wrong data structure or using the data structure wrong :)
23:26:35 <dramforever> ReinH: he/she expected a O(thatLength * lengthOfTheString) performance
23:26:45 <ReinH> bramgg: the point being, if you're tempted to use !!, stop first and think about whether there's a better option :)
23:26:47 <dramforever> actually, it's exponential
23:27:16 <ReinH> bramgg: if you can't come up with one, ask us and we might be able to :)
23:27:49 <haasn> dramforever: needs more prolog
23:27:53 <bramgg> ReinH: get the 5'th element of a list
23:28:16 <dramforever> bramgg: why would you need that? can you give a concrete use case?
23:28:39 <ReinH> bramgg: Restructure your problem to avoid needing the 5th element of a list.
23:28:49 <haasn> bramgg: Where is the list coming from and why is the 5th element so important?
23:29:09 <ReinH> Or use something designed for that access pattern like IntMap
23:29:20 <bramgg> Hahah it was just an example, I have no use case for it.
23:29:22 <bramgg> I get the point though.
23:29:22 <haasn> Actually, I can come up with a use case
23:30:04 <dramforever> Sometimes more thinking enables you to eliminate the uses of indices
23:30:10 <haasn> dramforever: vim-like editor with vim-like scripting. You run something like :5s/foo/bar/g to replace instances of ‚Äúfoo‚Äù by ‚Äúbar‚Äù on line 5 of the file
23:30:25 <dramforever> I remembered writing a gauss elimination without using indices
23:30:39 <haasn> Well, I'm not sure if that's a use case
23:30:45 <dramforever> haasn: A text buffer shouldn't be represented as a list
23:30:46 <bramgg> However the first 3 problems of 99H are like that, so if it's really not a thing one should be doing, maybe the problems should be changed? https://wiki.haskell.org/99_questions/1_to_10
23:30:50 <haasn> The solution here is ‚Äúdon't use [] to represent the lines‚Äù
23:30:57 <haasn> So that's not really a use case by definition
23:30:57 <dramforever> haasn: yes
23:30:58 <haasn> fair enough
23:31:31 <dramforever> list is best for sequential-access
23:32:10 <haasn> dramforever: ‚ÄúWrite a shell utility that returns only the nth line of input‚Äù putStrLn (input !! 5)
23:32:14 <haasn> s/input/lines input/
23:32:39 <haasn> s/5/n/
23:32:58 <haasn> (Extra cred: How would you restructure this to avoid the exception if the input does not have N lines?)
23:33:08 <dramforever> bramgg: Q1: you wanna try myLast x = x !! (length x - 1) ? that's bad since it keeps the whole list in memory
23:33:11 <ReinH> putStrLn . take 1 . drop (n - 2) $ lines is safer :p
23:33:24 <ReinH> er mapM putStrLn
23:33:32 <dramforever> ReinH: mapM_
23:33:36 <ReinH> yes yes
23:33:37 <haasn> drop (n - 1)
23:33:53 <ReinH> haasn: We generally think of lines as 1-indexed though, right?
23:34:03 <ReinH> so you need n - 2 to account for the change of base
23:34:11 <ReinH> if not then n - 1
23:34:23 <haasn> > take 1 . drop (5 - 2) $ [1..10]
23:34:25 <lambdabot>  [4]
23:34:47 <EvanR> of all the things programmers count from 1 not 0, why would it be source lines of code ;)
23:34:55 <ReinH> haasn: Woops :)
23:34:59 <dramforever> bramgg: correct would be to walk down, and discarding elements until you see the last one
23:35:12 <dramforever> Q2: similar
23:35:28 <dramforever> Q3....okay I surrender
23:35:43 <ReinH> bramgg: You can find the last element of a list with a fold
23:35:49 <bramgg> dramforever: so for Q1 the "correct" soluction would be their first solution provided?
23:36:02 <ReinH> The other two are annoying
23:36:02 <dramforever> bramgg: yes
23:36:30 <dramforever> :t snd
23:36:31 <lambdabot> (a, b) -> b
23:36:34 <dramforever> :t curry snd
23:36:35 <lambdabot> a -> c -> c
23:36:39 <dramforever> :t const id
23:36:39 <lambdabot> b -> a -> a
23:36:43 <dramforever> :t flip const
23:36:43 <lambdabot> b -> c -> c
23:36:56 <ReinH> bramgg: But the goal is to teach recursion, not to teach indexing a list
23:37:09 <haasn> myButLast is best done with pattern matching
23:37:18 <haasn> myButLast [x,_] = x
23:37:55 <ReinH> haasn: There are some nice solutions for P2, yeah
23:37:58 <haasn> myButLast (_:xs) = myButLast xs
23:38:04 <haasn> myButLast [] = error "..."
23:38:11 <ReinH> The fold ones are nice. Bird does that sort of thing.
23:38:37 <dramforever> wow the fold...
23:39:13 <ReinH> dramforever: an n-tuple gives you an n-width sliding window :)
23:39:31 <dramforever> exactly
23:39:37 <haasn> I wonder if there's a practical advantage of the fold version vs the pattern matching version
23:39:41 <haasn> Does it fuse better?
23:39:56 <ReinH> haasn: It fuses, period. :)
23:40:14 <ReinH> haasn: Ofc those versions use lazy tuples so...
23:40:39 <haasn> ReinH: does that make a difference here?
23:41:08 <ReinH> haasn: Hmm, actually no since the members are scrutinized on each step
23:41:13 <dramforever> oh a question: is sort in haskell guaranteed to sort only as much as needed?
23:41:18 <ReinH> haasn: good point
23:41:25 <haasn> ReinH: Oh, but it uses foldl instead of foldl'
23:41:32 <haasn> So it would build up a big argument before actually inspecting anything
23:41:35 <dramforever> like would (sort x) !! k be a good selection?
23:41:40 <ReinH> haasn: Actually, I don't think so?
23:41:50 <haasn> Maybe GHC is good at optimizing it
23:42:03 <ReinH> haasn: Hmm. Unsure.
23:42:09 <haasn> I forgot why foldl exists
23:42:24 <Cale> dramforever: I think it is... it's certainly possible to write a sort with that property
23:42:47 <dramforever> Cale: does the haskell report say anything about it?
23:42:56 <ReinH> dramforever: https://hackhands.com/modular-code-lazy-evaluation-haskell/
23:43:08 <ReinH> Cale: sort was switched to mergesort in part because of that, right?
23:43:38 <ReinH> dramforever: Another explanation at http://stackoverflow.com/questions/12057658/lazy-evaluation-and-time-complexity
23:43:40 <Cale> dramforever: No, it just says that the sort should be stable
23:44:02 <ReinH> Cale: I think at one point it was a pseudo-quicksort?
23:44:12 <Cale> uhhhh...
23:44:20 <Cale> If it was, then that was a looooooooong time ago
23:44:33 <Cale> It's been a mergesort as far back as I can remember
23:44:42 <ReinH> Cale: No I'm imagining things
23:44:43 <Cale> of one kind or another
23:44:56 <ReinH> It was a mergesort and now it is a better mergesort
23:44:57 <dramforever> I wonder if in mergesort spliting [a1, a2, a3, a4, a5] into [a1, a3, a5] and [a2, a4] is correct
23:45:15 <dramforever> if it is then it's really haskell-friendly
23:46:29 <haasn> dramforever: Doing that means it's potentially not stable
23:46:41 <dramforever> actually, it turns out spliting a singly-linked list in half is not hard
23:46:46 <haasn> if a3=a4=a5 and merge prefers the left hand side, then you will get [a1,a2,a3,a5,a4]
23:46:52 <dramforever> and does *not* require calling length
23:46:55 <Cale> ReinH: Apparently you're also correct, it was quicksort back in 2002 :)
23:47:03 <Cale> "Quicksort replaced by mergesort, 14/5/2002."
23:47:19 <ReinH> Cale: huh! I guess I wasn't imagining it :D
23:47:31 <ReinH> Cale: obv I wasn't around back then but I did read the source a few times...
23:47:36 <Xe> is there a way to make Haskell do eager evaluation?
23:47:38 <dramforever> Cale: ? where did you see it?
23:47:39 <Cale> But yeah, the mergesort has also been reworked
23:47:40 <ReinH> I mean, I did exist in 2002.
23:47:45 <ReinH> Just to be clear.
23:47:48 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.2/src/Data-List.html#sort
23:47:56 <dramforever> Xe: rnf?
23:48:03 <Xe> ?
23:48:14 <Cale> ReinH: We know you're secretly 12 years old
23:48:17 <MP2E> lol
23:48:44 <dramforever> can somebody explain those WHNF, seq and rnf stuff?
23:48:49 <ReinH> Cale: Ed can confirm that I am either much older or I've lived a pretty rough life for a 12 year old.
23:48:51 <dramforever> I'm not really familiar with it
23:49:01 <haasn> dramforever: Mergesort is done by starting with elements of size 1 and building them up, no need to split the list
23:49:07 <ReinH> dramforever: Cale can. :)
23:49:16 <johnw> dramforever: WHNF means that the value has been evaluated sufficiently to determine what the outermost constructor is
23:49:24 <ReinH> johnw: o/
23:49:29 <johnw> hi ReinH
23:49:36 <ReinH> johnw: Which is subtly different from HNF in ways I can never remember.
23:49:38 <haasn> johnw: Assuming it exists
23:49:38 <dramforever> okay, now seq and rnf
23:49:45 <Cale> dramforever: An expression is in weak head normal form if it is either 1) A lambda abstraction, or 2) a data constructor applied to some arbitrary expression arguments
23:49:50 <dramforever> haasn: okay good
23:49:50 <johnw> ReinH: I thought that in Haskell there was no real distinction
23:50:00 <ReinH> johnw: maybe that's why I can't remember it!
23:50:07 <dramforever> Actually, I want someone explain to Xe
23:50:20 <haasn> https://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
23:50:26 <johnw> dramforever: the WHNF of (seq x y) also evaluates x to WHNF
23:50:39 <Cale> An expression is in head normal form if it is either 1) A lambda abstraction whose body is in head normal form, or 2) It is a data constructor applied to some expressions
23:50:39 <haasn> This suggests that there's a subtle difference between WHNF and HNF when it comes to functions
23:50:43 <dramforever> Xe: did you see them?
23:50:59 <dramforever> Did you see that Xe asked about doing eager evaluation?
23:51:16 <Cale> HNF is impractical, because to put something into HNF, you have to evaluate underneath an unapplied lambda, which is usually not something that real evaluators attempt to do
23:51:48 <johnw> dramforever: rnf evaluates recursively until the value is in normal form
23:51:48 <haasn> Cale: Would evaluating (\x -> undefined x) to HNF cause an exception?
23:51:54 <Cale> yes
23:52:06 <haasn> Okay. For WHNF, this is certainly not the case
23:52:12 <dramforever> [CLARIFY] Explain to Xe, not me
23:52:20 <johnw> Cale: thanks for the clarification
23:53:20 <haasn> Xe: The simplest ways to make Haskell do eager evaluation is to add ‚Äò!‚Äô in front of every parameter
23:53:25 <haasn> For example
23:53:34 <haasn> change  f a b c = ...  to  f !a !b !c = ...
23:53:40 <Cale> that...
23:53:46 <haasn> (No need to do this if ‚Äòa‚Äô, ‚Äòb‚Äô or ‚Äòc‚Äô is a pattern match)
23:53:50 <Xe> lol
23:53:58 <Cale> yeah, don't actually do that
23:54:10 <haasn> Same for data types:  data Foo = Foo a b c   ->   data Foo = Foo !a !b !c
23:54:13 <haasn> Cale: What do you mean?
23:54:32 <Cale> I guess you can, but if you're doing that, it probably means that you don't understand what's going on well enough to have much chance of it helping
23:54:32 <dramforever> Is this correct? let mySeq !_ !b = b
23:54:40 <dramforever> let myPseq !_ b = b
23:55:03 <Cale> and it might actually just hurt your performance for no reason
23:55:14 <haasn> dramforever: By definition, mySeq !a b = b is the same as mySeq a b = a `seq` b
23:55:22 <haasn> (It's syntax sugar)
23:55:44 <dramforever> okay, how about myPseq?
23:56:05 <dramforever> maybe myPseq !_ b = lazy b
23:56:16 <Cale> dramforever: Your mySeq and myPseq are equivalent to each other
23:56:24 <Cale> and neither one is really pseq
23:56:42 <ReinH> Cale: Ah, that clarifies it, thanks
23:56:45 <dramforever> okay forget about it
23:57:03 <Cale> dramforever: Remember that x `seq` x is the same thing as x
23:57:23 <dramforever> good
23:57:35 <dramforever> forget about it. pseq is magic. period
23:57:39 <Cale> right
23:58:01 <Cale> You can't really explain how pseq is different from seq without discussing operational semantics
23:58:15 <ReinH> dramforever: It probably involves magnets.
23:58:35 <dramforever> in GHC.Magic we have lazy where lazy x = x but lazy is, as it's name suggests, *not* strict in x
23:58:39 <ReinH> Cale: There are no operations here only meanings.
23:58:45 <dramforever> to the strictness analyzer
23:59:31 <lpsmith> hmm, with optparse-applicative,  I'd like to be able to specify a list of configuration files,  like cmd --conf path1 --conf path2
23:59:34 <lpsmith> That much I have working
