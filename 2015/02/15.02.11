00:00:00 <shachaf> Cochoice can have instances.
00:00:03 <edwardk> they arise. we have an Un construction that uses one
00:00:25 <jle`> i was just wondering if you have any ones that you've written so far that i can check out :) if they are interesting
00:00:27 <shachaf> For instance for newtype Un p a b s t = Un { unUn :: p t s -> p b a }, instance Choice p => Cochoice (Un p a b)
00:00:30 <shachaf> Or something like that.
00:00:37 <edwardk> Cochoice is really 'CoStrong' for Either.
00:00:56 <jle`> Un p a b s t, the newtype for beer loving hipsters everywhere?
00:01:02 <edwardk> pretty much
00:01:19 <funfunctor> I have cobeer here, help!?
00:01:22 <edwardk> there is lots of pabst and stabbing going on in the lens channel. its kinda brutal in there.
00:01:23 <shachaf> I'm not sure I'd call it "Co"choice as such, but I guess it's an OK name.
00:01:43 <jle`> the stabbing is made less brutal by the pabst i guess
00:01:59 <edwardk> Costrong is the actual dual construction for strong. Choice is just "Strong for Either"
00:02:03 <edwardk> its kinda meh name wise
00:02:25 <jle`> why don't you generalize strong/etc. over arbitrary bifunctors
00:02:29 <jle`> would it still be strong?
00:02:43 <edwardk> because we didn't notice the strong connection between them at the time ;)
00:02:53 <jle`> (as in, would it still correspond to the idea of strength)
00:02:54 <edwardk> in hask we do that
00:02:55 <jle`> ah i see
00:02:57 <shachaf> whoa, class Prismy p where prismy :: p a b -> p (Either b a) b
00:03:04 <shachaf> Remember when that was our class?
00:03:18 <edwardk> shachaf: still equivalent in a cartesian category
00:03:22 <jle`> i propose a bbp
00:03:26 <jle`> to revamp profunctors
00:03:44 <shachaf> Sure, but not really as nice.
00:03:52 <shachaf> It took us a while to figure out the proper one.
00:03:56 <edwardk> jle`: i'm fairly neutral on revamping, as we're only really talking about two instances.
00:04:11 <shachaf> (Actually it only became obvious what it should be when we looked at "simple" one-argument optics.)
00:04:17 <edwardk> (,) and Either are the cases in question
00:04:27 <edwardk> the bifunctors need to be possible tensors for a monoidal category
00:04:28 <jle`> it'll kill a lot of things that are Strong over (,) but not Strong over arbitrary bifunctors tho
00:04:30 <edwardk> and the category is *
00:05:03 <edwardk> so now find me more bifunctors on hask for which hask is a monoidal category
00:05:19 <edwardk> show me more than (,) and Either, and you have a case for generalization
00:05:30 <jle`> ummmmmm
00:05:40 <shachaf> Can't we talk about functors : * -> * instead?
00:05:42 <edwardk> at the same time you lose the direct connection between Choice and ArrowChoice
00:05:46 <shachaf> We have at least five there.
00:05:48 <edwardk> shachaf: no, too easy, no points
00:05:53 <jle`> yes but ArrowChoice is just silly anyways
00:05:58 <jle`> there's non reason at all to tie it to Arrow
00:06:05 <jle`> besides its connection to proc notation
00:06:15 <edwardk> jle`: yes, but there is also the pragmatic consideration that the names all work, that the combinators can typecheck
00:06:29 <jle`> i'll bbp Control.Arrow too then if i have to
00:06:30 <edwardk> what you are asking for unifies two things just for the sake of unifying them but yields a world with worse type inference
00:06:39 <jle`> bbp everything
00:06:42 <shachaf> I propose no more three-letter acronyms ending in the letter P.
00:07:04 <glguy> You'd need to propose that rule
00:07:14 <glguy> And give it a TLA
00:07:17 <jle`> three-letter proposal
00:07:26 * ski dubs that the "no-3LP"
00:07:54 <bitemyapp> jle` is an arsonist
00:08:06 <jle`> you get in my way and i'll bbp you too
00:08:30 <MP2E> lol
00:08:31 <bitemyapp> jle`: I am no obstructionist.
00:08:54 <bitemyapp> jle`: feuer frei komrade
00:09:03 <jle`> good, then we'll have no problems here
00:09:45 <shachaf> Any idea about names or justifications for the hypothetical Functor hierarchy I was talking about a while ago?
00:10:13 * hackagebot gl 0.7.2.2 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.2.2 (Polarina)
00:10:13 * hackagebot base-io-access 0.4.0.0 - The IO functions included in base delimited into small, composable classes  http://hackage.haskell.org/package/base-io-access-0.4.0.0 (bheklilr)
00:10:15 <jle`> edwardk: what the heck is this ==> Bifunctor p => Bifunctor (WrappedBifunctor p)
00:10:25 <shachaf> Adding lensy :: f a -> f (e,a) and prismy :: f a -> f (Either e a) as subclasses of Invariant but superclasses of Functor/Contravariant.
00:10:34 <jle`> oh i see, it has an alternative Functor instance
00:11:19 <shachaf> For instance Endo is an instance of both of those but it's neither Functor nor Contravariant.
00:12:43 <glguy> Speaking of opening up Functor, what about a class method a la (#.) ? ( the new one with coercible)
00:13:31 <delrik> funfunctor: kk ,thats done
00:14:45 <funfunctor> delrik: good, almost, so you want to do {-# INLINE fmap #-} and friends
00:15:15 <delrik> so I want to allow fusion on those functions?
00:15:26 <funfunctor> delrik: Functor and Applicative have a natural definition, can you figure them out?
00:15:43 <delrik> I’ll give it a shot =)
00:15:59 <funfunctor> delrik: Applicative is pretty trivial
00:16:08 <delrik> yeh =)
00:17:43 <shachaf> glguy: Sounds kind of narrowly applicable in general.
00:18:57 <shachaf> But I guess it doesn't hurt that much? We're already given up and gotten Coercible in.
00:27:48 <_ether_> hi, i'm currently learning haskell and i fail to grasp why using OO is an antipattern in haskell (according to https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ or http://www.reddit.com/r/haskell/comments/20nxjo/what_is_the_canonical_haskell_solution_to_the/) could anyone point me in the right direction? thanks!
00:31:00 <shachaf> I don't think that first article is about OO.
00:31:19 <shachaf> But "OO" doesn't really mean anything specific so it's best not to use it if you want to talk about specific things.
00:33:14 <_ether_> maybe should i reformulate like that: why using typeclasses may be better rewritten with a simple data type and some functions to construct this basic data type?
00:34:21 <_ether_> i fail to see why in the example of the raytracer, using a hierarchy of classes may be a bad practice
00:34:44 <Xe> _ether_: because you don't need to have classes to program?
00:34:57 <jle`> you can just use normal functions and data structures over the existentials
00:35:12 <EvanR> you might not even need existentials
00:35:14 <Saizan> _ether_: some are just scared of existential types
00:35:21 <ski> _ether_ : don't use more power than you need ?
00:35:30 <shachaf> "existentials" vs. "not existentials" and "type classes" vs. "not type classes" are two mostly-unrelated questions.
00:35:42 <shachaf> I guess not completely unrelated.
00:35:52 <shachaf> Anyway, it's not always a bad idea.
00:36:18 <shachaf> But it's pretty silly to have (exists a. Show a *> a) -- a value that you can apply show to -- when you can just have a String.
00:36:34 <Arahael> Is it just me, or is this line awkward? putStrLn $ unlines $ (map show) $ desirableDates $ utctDay $ ct
00:36:56 <_ether_> currently, i don't understand waht are the 'existential types'
00:36:58 <Arahael> (Note: I'm a haskell novice, so please feel free to be pedantic)
00:36:59 <Saizan> _ether_: but there is a real tradeoff, in that if you use classes the implementations of the methods are fixed per-type, while with a record of functions you can pick the implementation as you wish everytime you build a value of that record type
00:37:35 <jle`> Arahael: yes
00:38:07 <Arahael> jle`: Could you suggest how I should improve that?
00:38:13 <jle`> `putStrLn . unlines . map show . desirableDates . utctDay $ ct` would work, and from there, it's clearer where you can "pull thing sout"
00:38:16 <jle`> because (.) is associative
00:38:30 <shachaf> Here's a trade-off: (A,A,...,A,A) uses a whole bunch of memory (linear in the number of fields), whereas (exists x. (x, (x -> A, x -> A, ..., x -> A, x -> A))) can share the "dictionaries".
00:38:56 <jle`> also i feel like you might get the same results with mapM_ print . desirableDates . utctDay $ ct
00:39:00 <shachaf> Of course this trade-off is mostly independent of whether you use type classes.
00:39:09 <shachaf> (Which is why I didn't use type classes in the second case.)
00:39:49 <shachaf> Also it should be A,B,C,D instead of A,A,A,A
00:41:14 <Saizan> _ether_: existential types are those where the constructor contains a "hidden" type, like AnyWidget in the first post
00:41:21 <Arahael> jle`: Yes, that version using the '.''s does look clearer, though I'm not sure why that 'map show' there doesn't need to be in parenthesis.
00:42:23 <jle`> Arahael: function application binds tightest
00:42:26 <jle`> tighter than any operator
00:43:04 <jle`> the . version is desirable because . is associative, so you can see, "oh, i might want (unlines . map show) to be one thing, `foo`, and write putStrLn . foo . desirableDates . etc.
00:43:16 <jle`> you can just "drop in `foo`", and set foo = unlines . map show
00:44:05 <Arahael> jle`: That does make sense - does also work _in_this_case for the $ form, though I can see why that is actually a more difficult mental transform.
00:44:14 <_ether_> Saizan: oh maybe i see now, by simply letting haskell choose the correct function to use for this type you may have the c++ parametric polymorphism comportment out of the box without the complexity of a hierarchy of objects? (or maybe i think too much in term of c/c++/python/whatever...)
00:44:26 <jle`> yes, you can leave the parentheses off in the $ form too
00:45:06 <Arahael> _ether_: C++'s parametric polymorphism doesn't rely on a hierachy of types.
00:45:10 * hackagebot ekg-core 0.1.0.3 - Tracking of system metrics  http://hackage.haskell.org/package/ekg-core-0.1.0.3 (JohanTibell)
00:45:35 <Arahael> jle`: I'm glad I asked. :)
00:46:14 <jle`> np :)  you have some choices too with the $, you could put it between desirableDates and utctDay, too
00:46:40 <Arahael> jle`: I think I like the dots, whenever I have functions on both sides.
00:46:52 <Saizan> _ether_: the existentials are more about recovering some kind of upcasting, rather than parametric polymorphism
00:47:08 <phaazon> Cale: kind of
00:47:29 <phaazon> I'm still profiling my app to make it faster and faster
00:47:37 <phaazon> and reduce the GC %time and %alloc
00:47:47 <phaazon> I found that catMaybes took a lot as well :/
00:47:57 <_ether_> Xe: i don't know, in some languages using classes can 'prettify' and lighten your code i think
00:48:11 <Xe> _ether_: haskell is not some languages
00:48:22 <Saizan> _ether_: but there's also the point that you don't need Circle and Square to be different types at all, you just need them to be differently implemented Shape's, and that's where you get the classless implementation
00:48:37 <Xe> you don't need classes to do do programming. you don't need generics to do programming
00:48:49 <_ether_> Arahael: i know that you don't need classes to use parametric polymorphism but i don't see myself using c++ without classes :)
00:48:57 <Saizan> Xe: we use generics all the time though!
00:49:03 <Saizan> ?type map
00:49:04 <lambdabot> (a -> b) -> [a] -> [b]
00:49:10 <Arahael> _ether_: I think you're confusing parametric polymorphism, and subtype polymorphism.
00:49:33 <Xe> Saizan: I mean the strict C++ style with compiler brainrot that introduces subtle bugs that only show up at runtime
00:49:55 <_ether_> Xe: this is why is asked the question, i am not interested to use haskell as i could any other language interchangeably
00:50:17 <Arahael> _ether_: Consider the polymorphsm you can achieve using C++ templates. That is (one form) of parametric polymorphism.
00:51:05 <Arahael> _ether_: But if you avoid templates, and also avoid casts, then the only form of polymorphism that C++ provides is *subtype* polymorphism, and THAT requires a heirachy of classes.
00:52:35 <_ether_> Arahael: in the example of the raytracer, if fail to see why class Triangle { void render(); }; class Sphere { void render(); }; may be better written as struct Triangle { }; struct Sphere { }; render(Sphere s); render(Triangle t);
00:52:54 <Arahael> _ether_: That's because they are *exactly the same* in C++.
00:53:26 <Arahael> _ether_: class == struct.  The only difference is that the visibility rules are inverted.
00:53:42 <_ether_> Arahael: you have type polymorphism on the render function, and if you inherit from a Shape class you can simply use shape->render(). In haskell, the prefered method seems to have a render function for each data type
00:53:46 <Arahael> _ether_: Ie, classes default to private, while structs default to public.
00:54:36 <Arahael> _ether_: It's still exactly the same in the example you gave, in C++, despite the notation.
00:54:47 <EvanR> _ether_: that doesnt sound different from what you described actually. in c++ with dynamic dispatch you also have one function for each class
00:55:17 <EvanR> because we have first class functions, the dynamic dispatch is taken as a given all over the place
00:55:55 <Arahael> _ether_: (Note, that 'render(Sphere s);' should have been 'render(Sphere& s);')
00:56:01 <_ether_> Arahael: the struct was only here to implicitly tell that it is like in C: no methods, we only care about the variables it holds since we use globals function to dispath our object
00:56:49 <Arahael> _ether_: That's very debatable. There is no difference.  struct Sphere {void render();}; is perfectly valid.
00:57:30 <Arahael> _ether_: One difference is that you can't easily define recursive structs in C++, as you can in C.
00:57:44 <Arahael> (Nested, rather - not recursive.)
00:58:10 <_ether_> Arahael: but in the too links that i pasted, it seems that the second approach is preferable (the one to use routines matching the object type and not methods)
00:58:21 <_ether_> too -> two, sorry
00:58:42 <Arahael> _ether_: Yes, as it avoids teh brittle-base-class problem C++ has.
00:59:03 <Arahael> _ether_: You want your classes to be as small as possible, and to be responsible for only one thing.
00:59:20 <julianleviston> Arahael: and composable
00:59:25 <Arahael> That, too. :)
01:00:07 <_ether_> yup, so this is why is did the analogy with the struct: only contains some variables that define our object, the methods are not necessary
01:00:09 <Arahael> It's actually remarkably instructive to compare C++ and ObjC. (I know both, but starting Haskell now)
01:00:33 <Arahael> _ether_: Well, they were a distraction - the methods aren't neccessary with the classes either.
01:01:10 <julianleviston> I think one of the most important things the declarative nature of Haskell (what) rather than (how)…
01:03:08 <_ether_> so anyone as a good example of the use of classes in haskell?
01:03:14 <_ether_> as -> has
01:03:34 <Hijiri> typeclasses?
01:03:45 <_ether_> yes, i mean typeclasses
01:03:50 <Hijiri> Show is an easy example
01:04:05 <Hijiri> a type that is an instance of Show has a method for converting things of those type to strings
01:04:42 <Hijiri> > (show (5 :: Integer), show (5 :: Int), show 'h', show "h", show $ [1,2,3,4,5])
01:04:43 <lambdabot>  ("5","5","'h'","\"h\"","[1,2,3,4,5]")
01:05:33 <jle`> Monoid is good, it gives an associative binary operator (<>) :: a -> a -> a, and an identity `mempty`.  because we know how things behave under (<>), we can write functions that are generic over all Monoids
01:05:41 <jle`> and be able to understand how they behave
01:05:49 <jle`> mempty :: a
01:06:22 <_ether_> hm, yas, that was too simple... In this particular case, since you don't really need to override the method (like the render method that i used before in the examples), that's a good use...
01:07:51 <daimonos>  /j club-nomicon
01:08:01 <daimonos> Sorry typo
01:10:54 * Arahael downloads a website for the first time, using Haskell.
01:11:53 <_ether_> well, i think i may see a bit more, i may only have some bad programming habits
01:11:55 <daniel-s> Arahael: You should download all of the websites so that nobody else can see them.
01:12:19 <Arahael> daniel-s: An excellent idea.
01:12:26 <_ether_> thanks Arahael, Xe, Saizan :)
01:13:05 <Arahael> _ether_: It's remarkably common, actually.  I might be a bit mean, but to me, it looks like you're using the common subset of hte langauges you know.
01:13:33 <Arahael> _ether_: But...  That actually works well for larger teams, arguably.
01:14:14 <_ether_> Arahael: this is exactly what i want to avoid, like i said, there would be no point in learning haskell
01:15:10 <merijn> If you manage to program a "common subset of the languages you know" in haskell, you are either 1) really inventive or 2) know some oddly uncommon languages ;)
01:15:36 <Arahael> merijn: So, Haskell's a good way to break the pattern. ;)
01:15:49 <Arahael> _ether_: Try avoiding typeclasses to start with, except for the predefined ones.
01:15:56 <EvanR> the design pattern breaking pattern
01:16:13 <wz1000> Has anyone got any experience with the haskell sound libraries and/or pulseaudio?
01:17:03 <merijn> I wouldn't worry TOO much about avoiding typeclasses
01:17:10 <_ether_> in the example of the raytracer, there is no reason to give the Shape a default implementation of the render method, but if i do, now there is a good reason to use typeclasses, isn' it? (since i won't override it the inheriting classes)
01:17:38 <merijn> The usual beginner pattern is: 1) typeclass all the things! 2) jesus, this is a lot of extra work and I'm not gaining a lot! 3) oooooh, so I should tackle those differently than using classes
01:17:53 <tdammers> merijn: sounds legit
01:17:55 <merijn> _ether_: You may be interesting in the following blogpost
01:18:04 <merijn> @google gabriel gonzalez scrap your typeclasses
01:18:06 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
01:18:06 <lambdabot> Title: Haskell for all: Scrap your type classes
01:18:11 <EvanR> _ether_: typeclasses arent for default implementations
01:18:11 <Arahael> *sigh*.  Emacs is corrupting my cabal files.
01:18:12 * tdammers is currently in the "close over all the things and wrap it in a lazy record type" phase
01:18:18 <merijn> _ether_: That pattern is a better approach to OO than typeclasses are
01:18:40 <funfunctor> derekv: how you going?
01:18:41 <merijn> tdammers: That phase has no ending because it's a genuinely solid idea ;)
01:18:57 <_ether_> thanks for the blogpost, will read it :)
01:19:05 <merijn> tdammers: The next step of that phase is: "Gee, I wish haskell had indexed records and row-type polymorphism...."
01:19:07 <tdammers> merijn: yeah, but as with all solid ideas, it is perfectly possible to go overboard and miss the more obvious and simpler solution
01:19:42 <tdammers> real-world example: the CMS I'm building is supposed to support several template languages (currently working on Jinja and Mustache)
01:19:59 <tdammers> each template language wants its own type for context variables
01:20:27 <merijn> _ether_: The basic idea is that typeclasses don't let you do anything that plain values and functions won't let you do. They only get you "automatic lookup" for free from the compiler. But when you want flexible extensibility it's easier to just do it by hand, because it gives you more freedom
01:20:27 <tdammers> and context variables can be filled form JSON values, typed records, lists of records, or individual fields
01:20:37 <mark___> question about quickcheck, why did they choose to have Arbitrary and Gen? Gen seems enough to me as abstraction. What is the need of Arbitrary? Or what is the purpose of these abstractions?
01:20:57 <tdammers> so my first approach was to have a type that handles conversion from every input type to every output type
01:21:05 <tdammers> which leads to bloat and dependency hell
01:21:19 <tdammers> so my new approach is going to be much simpler:
01:21:33 <tdammers> a sum type that describes what kind of data can go into a context variable
01:22:16 <tdammers> sth like data ContextVar = JSONVar JSON.Value | SingleRecord Record | MultiRecord [Record] | RecordField Field
01:22:30 <tdammers> and then each template language module defines its own conversion routine
01:22:33 <tdammers> much much nicer
01:22:59 <merijn> mark___: Complete and utter blind guess: Something related to the ability to pre-filter/only generate some values
01:23:01 <tdammers> and, more importantly, I don't need to bleed implementation details from the template languages into other modules
01:24:56 <waccoTest> g'day
01:25:00 <mark___> merijn: About pre-filtering; Gen can do that with suchThat right? What would Arbitrary do then ?
01:25:30 <aisqwe> how can kind of (->) be declare in terms of itself?
01:26:44 <merijn> mark___: I don't know, like I said: Completely blind guess by me :)
01:26:53 <merijn> aisqwe: It's not
01:27:00 <merijn> aisqwe: Those are two different -> :)
01:27:05 <mark___> merijn: Alight :) Thanks i’ll try to dig a bit deeper :)
01:27:31 <Arahael> Hmm, I can't seem to install download.  It seems that 'download' ultimately depends on 'feed', which "failed to install" and I don't know why?
01:27:57 <aisqwe> merijn: what does the first (->) mean?
01:28:07 <merijn> aisqwe: -> can be either 1) type level constructor of function types or 2) a kind level constructor of kinds, it's usually unambiguous which is which
01:28:28 <merijn> :t id -- Here it is a type level constructor of function types
01:28:29 <lambdabot> a -> a
01:28:47 <merijn> :k Maybe -- Here it is a KIND level constructor of kinds
01:28:48 <lambdabot> * -> *
01:28:53 <ski> aisqwe : the first is the type-level `(->)'. the second is the kind-level `->' construction (there is no kind-level `(->)', you must always say `k0 -> k1' for two kinds `k0' and `k1')
01:28:58 <Arahael> And apparently THAT is because it can't find package 'System.IO.UTF8' - how do I find that package?
01:29:04 <funfunctor> delrik: hint for your Applicative instance, import Control.Monad (ap)
01:29:18 <merijn> Arahael: Try running install command with -v3 for details?
01:29:38 <delrik> funfunctor: thx, i was dying =)
01:30:05 <Arahael> merijn: Thanks.  The relevant output seems to be:
01:30:07 <Arahael> Text/Feed/Import.hs:35:8: Could not find module ‘System.IO.UTF8’
01:30:22 <waccoTest> never mind me, just checking if something works now; PRIVMSG #haskell : is this visible?
01:30:25 <Arahael> Do I assume that 'download' didn't specify the dependencies correctly?
01:30:28 <funfunctor> delrik: also your fmap definition is not right
01:30:38 <jle`> if you're defining an applicative instance for State/StateT, then you might be interested in the fact that there are at least two possible ones :)
01:30:43 <jle`> only one of them is `ap` tho
01:30:44 <wacco> ah cripes. restart after recompile, duh
01:30:57 <merijn> Arahael: My bet: You're trying to use some old/obscure package that has really poorly specified bounds
01:31:06 <funfunctor> delrik: hint for that is, import Control.Applicative (Applicative(..), (<$>))
01:31:15 <merijn> Arahael: Thus failing because it's trying to compile against some no longer existing module
01:31:18 <Arahael> merijn: What should I use instead of 'network', then?
01:31:26 <merijn> heh
01:31:39 <funfunctor> delrik: let me know how you go with that..
01:31:42 <Arahael> merijn: I want a high level interface for downloading http files.
01:31:56 <merijn> I've heard wreq is the new hotness?
01:32:00 <delrik> funfunctor: thx, I will! jle`: will look into the ap comment =)
01:32:01 <geekosaur> System.Io.UTF8 is utf8-string which has been mostly obsolete since ghc 6.12 or thenabouts
01:32:07 <waccoTest> here we go again; PRIVMSG #haskell : is this visible?
01:32:10 <merijn> Arahael: I've used http-conduit + xml-conduit in the past for webscraping
01:32:14 <wacco> aww yess
01:32:20 <merijn> Arahael: I thought they were rather intuitive
01:32:39 <jle`> delrik: if you write the first (normal) Applicative instance, then if you stare at it long enough, the second one might pop out at you
01:32:45 <shachaf> wacco: There are better places than a 1500-person channel to test your bot.
01:33:11 <Arahael> merijn: wreq does look pretty nifty.
01:33:12 <merijn> We really need a rating system for hackage packages to avoid people trying to use prehistoric packages and getting confused when they break :>
01:33:13 <wacco> shachaf: I know I know - promise this was the last trial-and-error I'd do here :)
01:33:21 <delrik> jle`: I’m not entirely sure what you mean by first (normal) App. instance.
01:33:30 <jle`> of State/StateT?
01:33:33 <bergmark> merijn: with decay of the rating? :-)
01:33:34 <jle`> is that what you're trying to do?
01:33:47 <Arahael> merijn: A rating system would certainly help, maybe even a popularity context (ie, taken from cabal download statistics?)
01:33:50 <jle`> bergmark: half-life of a haskell package is, two months?
01:34:05 <funfunctor> jle`: i'm giving delrik a project where he is to work stuff out and i'm just giving him just enough ;)
01:34:12 <delrik> I actually have no idea what I’m doing here, funfunctor is walking me thru an excercise.
01:34:13 <jle`> okay :)
01:34:20 <delrik> ^ that =)
01:34:29 <jle`> cheers!
01:34:31 <bergmark> last activity in the source repo would also be helpful
01:34:33 <delrik> thx!
01:34:42 <funfunctor> delrik: just ping me when you get extra stuck
01:34:46 <jle`> how about mass of spider webs accumulated?
01:34:49 <delrik> kk
01:35:03 <funfunctor> delrik: the point is for you to /just about/ follow so you can fill in the gaps
01:35:06 <zipper`> delrik: LULz clean code
01:35:59 <funfunctor> delrik: i.e. notice the imports I gave you specify exactly what you need, hint check their type-signatures
01:37:05 <favetelinguis> just installed haskell platform on windows 7 enterprise, trying to start ghc ghci or cabal just gives me back that commands not found. However when i echo %PATH% the correct dir is shown
01:37:05 <merijn> bergmark: It already shows "last update", so
01:37:28 <delrik> at first glance <$> looks a lot like lift
01:37:36 <merijn> liftM, you mean?
01:37:57 <merijn> :t (<$>)
01:37:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:38:00 <merijn> :t liftM
01:38:03 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
01:38:15 <merijn> :t fmap
01:38:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:38:17 <wacco> so.. c++ derelict here; is there a way to do map on a subset of a list? ie. list.begin(), list.end() - x?
01:38:41 <merijn> delrik: That's because all of those are all the same thing modulo some historical baggage
01:38:52 <merijn> wacco: Do you know the length of the subset you want?
01:39:07 <merijn> wacco: Or only that you want "all but the last X"?
01:39:10 <wacco> sorta. all elements except the last
01:39:16 <Ferdirand> map (take n l) ++ drop n l
01:39:20 <Ferdirand> or something like that ?
01:39:21 <delrik> merjin: right,
01:39:26 <funfunctor> delrik: yes notice <$> and fmap, keep going... remember the newtype you defined as your monadic structure
01:39:47 <merijn> wacco: I don't think there's a built-in for that (except for only dropping the last one)
01:39:49 <wacco> Ferdirant; that might work, it just feels so inefficient
01:39:58 <jle`> yeah, there is a double traversal, i think
01:40:09 <merijn> wacco: "map f (take n l)" is pretty efficient
01:40:22 <merijn> But having to first compute the length is not
01:40:27 <wacco> this won't be exactly high performance or anything, just wondering
01:40:34 <delrik> funfunctor: kk, sec
01:41:08 <Arahael> wreq certainly takes a fair while to build. :)
01:41:17 <jle`> you could write it as a fold, but it's not a built-in
01:41:26 <geekosaur> wacco: a list is not a C++ vector, it's a singly-linked list. things like subsets will be expensive
01:41:56 <delrik> funfunctor: so is the goal then for me to write <*> in the context of mystate so that it satisfies the behaviour im seeing in the Applicative typeclass?
01:42:12 <lpaste> merijn pasted “dropLast” at http://lpaste.net/120321
01:42:13 <wacco> geekosaur: I figured, it just clarifies my train of thought easier ;)
01:42:27 <merijn> Super secret linear algorithm for dropping the last N :)
01:42:33 <funfunctor> delrik: no, read the type-signature of fmap again, "Functor"
01:42:36 <jle`> there are arrays/vectors in haskell where this works out the same way it would for c++ vectors :)
01:42:44 <merijn> Also the neatest haskell list trick I know
01:42:49 <delrik> kk
01:42:58 <merijn> wait
01:43:05 <merijn> I screwed up the result :p
01:43:22 <merijn> This returns the last N instead of dropping them :p
01:43:32 <wacco> lol
01:43:42 <Arahael> merijn: Looks like wreq's tutorials are *perfect* for my skill level.  :)
01:44:10 <funfunctor> delrik: if you are confused let me know so I can break it down for you..
01:44:11 <wacco> my quest-of-the-day is, I think, figuring out how crazy you can get with data structures
01:44:12 <lpaste> merijn revised “dropLast”: “dropLast fixed” at http://lpaste.net/120321
01:44:16 <merijn> There we go
01:45:09 <merijn> wacco: Well, fixing it to drop the last n isn't very hard. Although like I pro I *again* didn't test my new version either ;)
01:45:20 <wacco> hehehe
01:45:21 <delrik> funfunctor: i can share my incorrect reasoning and you can nudge me =) , I appreciate you letting me flail around in this so I’d like to try and atleast have a eureka moment in this.
01:45:25 <merijn> wacco: But it should show the "linear list operations" trick very well :)
01:45:42 <funfunctor> delrik: thats fine, go right ahead.
01:45:43 <HugoDaniel> cool
01:46:34 <delrik> :t fmap
01:46:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:46:41 <merijn> wacco: It's basically the sorta thing you'd do in a C linked list using pointers for a tortoise & hare algorithm or similar
01:46:43 <delrik> :t (<*>)
01:46:44 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:47:07 <funfunctor> delrik: your confused, dont confuse <*> with <$>
01:47:31 <funfunctor> delrik: lets pick the easy one to get it out the way, lets do Applicative
01:47:36 <delrik> funfunctor: kk
01:47:37 <funfunctor> :t (<*>)
01:47:38 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
01:47:40 <funfunctor> :t ap
01:47:41 <lambdabot> Monad m => m (a -> b) -> m a -> m b
01:47:53 <funfunctor> what do you know about Applicative and Monads?
01:47:56 <wacco> merijn; I gotta get glasses or something, for the longest time I was trying to figure out what that 1 was doing there..
01:48:19 <merijn> wacco: Or a better monospace font for your browser ;)
01:48:34 <wacco> glasses are cool these days, didn't you hear ;)
01:48:54 <merijn> They've been cool for approximately 12 years (that's how long I've been wearing them ;))
01:49:04 <wacco> hipster
01:49:14 <delrik> funfunctor: Applicative is a class of computations mapped over values, I can use <*> to apply operations to wrapped values in succession
01:49:31 <merijn> wacco: Anyway, try imagining writing that linked list stuff in C with pointers without testing :p
01:49:50 <funfunctor> delrik: right so its "like a monad" but with a little less structure?
01:49:57 <wacco> pass, thankyouverymuch
01:50:00 <delrik> funfunctor: and monads a re procedures that allow me to intersperse operations.
01:50:01 <funfunctor> delrik: but more structured than a Functor
01:50:10 <funfunctor> delrik: good
01:50:14 * hackagebot fay 0.23.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.23.0.0 (AdamBergmark)
01:50:16 * hackagebot fay-base 0.20.0.0 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.20.0.0 (AdamBergmark)
01:50:18 * hackagebot fay-text 0.3.2.2 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3.2.2 (AdamBergmark)
01:50:20 * hackagebot fay-dom 0.5.0.1 - DOM FFI wrapper library for Fay  http://hackage.haskell.org/package/fay-dom-0.5.0.1 (AdamBergmark)
01:51:06 <funfunctor> delrik: so then we have (<*>) = ap   in the case of a Applicative instance
01:51:33 * merijn mumbles something about AMP
01:51:47 <merijn> That reminds me, I need to vote on FTP :p
01:51:53 <delrik> okay, now thats painfully obvious =(
01:53:08 <merijn> delrik: Isn't "painfully obvious" a good thing? ;)
01:53:19 <funfunctor> delrik: haha :D
01:53:37 <funfunctor> delrik: alright now to complete the Functor instance
01:53:45 <funfunctor> :t fmap
01:53:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:53:49 <delrik> That’s been the common theme of learning haskell for me, the answer is usually right in my face.
01:53:51 <funfunctor> :t <$>
01:53:52 <lambdabot> parse error on input ‘<$>’
01:53:59 <Arahael> Hmm, I'm confused. I just installed 'cabal install wreq', and it's successfully installed. Now I'm in ghci, launched from the same directory, but I can't import Network.Wreq.
01:54:03 <delrik> :t (<$>)
01:54:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:54:08 <merijn> delrik: If you don't regularly feel confused and/or stupid you're not learning ;)
01:54:27 <funfunctor> delrik: its ok I feel the same
01:54:48 <funfunctor> delrik: thats why i'm helping where I can ;)
01:54:49 <geekosaur> Arahael, are you in a sandbox? cabal repl
01:54:54 <Arahael> Yes
01:55:00 <delrik> funfunctor: I appreciate it!
01:55:09 <delrik> merjin: +1
01:55:14 * hackagebot fay-builder 0.2.0.3 - Compile Fay code on cabal install, and ad-hoc recompile during development  http://hackage.haskell.org/package/fay-builder-0.2.0.3 (AdamBergmark)
01:55:16 * hackagebot snaplet-fay 0.3.3.10 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.10 (AdamBergmark)
01:55:21 <delrik> so funfunctor: I
01:55:23 <funfunctor> delrik: so what is fmap essentially doing?
01:55:32 <geekosaur> ghci can't see the sandbox directly. use cabal repl
01:55:38 <Arahael> Ah, ok.
01:55:57 <Arahael> geekosaur: Thanks. :)
01:56:00 <delrik> takes f lifts it into MyState and then <*> it onto x
01:56:24 <delrik> which in that case is an x wrapped in a MyState as well.
01:56:32 <funfunctor> delrik: exellent
01:56:40 <delrik> so MyState (a -> b) (Mystate a) -> (MyState b)
01:56:46 <delrik> i missed an arrow,
01:57:02 <funfunctor> delrik: fmap f m = ?
01:57:23 <funfunctor> delrik: what does <$> do?
01:57:41 <delrik> the same thing
01:59:07 <funfunctor> delrik: ah I just spotted a mistake in your monadic type
01:59:33 <delrik> would that explain why it was so hard to unwrap my values?
01:59:43 <delrik> I keep getting double nested Either types.
01:59:52 <funfunctor> delrik: newtype MyState a = MyState { unMyState :: ExceptT MyStatesPossibleErrors IO a } deriving (Monad, MonadIO)
02:00:02 <funfunctor> delrik: not run but un
02:00:10 <delrik> oh
02:00:13 <funfunctor> the UN, saving us all
02:00:19 <delrik> funfunctor: whats the significance of that?
02:00:37 <funfunctor> delrik: the significance is making sense
02:00:42 <muzzle> hi
02:00:53 <muzzle> so i have a question about handling text
02:01:02 <funfunctor> delrik: alright so you see that unwraps things?
02:01:19 <muzzle> is there an efficient way to take a substring between two indices out of a data.text value ?
02:01:25 <tdammers> newtype Foobar = Foobar { unFoobar :: Something } -- is a pretty common idiom
02:01:32 <funfunctor> delrik: so (f <$> unMyState m) go from there
02:01:57 <delrik> ohh
02:02:14 <delrik> funfuctor: so I couldn’t just pattern match on the expression?
02:02:27 <muzzle> something like (substring (3,5) "abcdefgh" == "de")
02:02:33 <funfunctor> delrik: you need to think about what your attempting to do with fmap
02:02:47 <delrik> funfunctor: kk
02:02:48 <funfunctor> delrik: you need to unwrap, apply the function and wrap it back up
02:03:01 <Arahael> Hmm, so how do I find out what package I have installed? I expect that 'cabal install foo && foo list --installed | grep foo' should result in that package being shown.
02:03:03 <funfunctor> delrik: can you see it now?
02:03:07 <delrik> sec
02:03:11 <delrik> funfunctor:
02:04:46 <Arahael> So I'm very confused with sandboxes, it seems.
02:04:59 <delrik> return (+1) :: (Num a) => MyState (a -> a)
02:06:26 <funfunctor> delrik: your fmap definition is still wrong
02:06:50 <delrik> funfunctor: updating it
02:06:53 <funfunctor> ok
02:07:05 <wacco> bug squashed, brb
02:08:00 <hsk3> Is there any reason I should write
02:08:01 <hsk3> oddSquareSum = sum . takeWhile (<10000) . filter odd $ map (^2) [1..]
02:08:02 <hsk3> instead of
02:08:03 <hsk3> oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]
02:08:04 <hsk3> ?
02:08:19 <hsk3> $ at the very end vs. $ one step lower
02:08:36 <jle`> nope
02:08:45 <tdammers> matter of taste and prefernce
02:08:49 <hsk3> ok thanks
02:08:50 <jle`> i mean, the choice is up to taste
02:08:55 <jle`> they both inline to the same thing
02:09:16 <tdammers> a . b . c $ d -- is a popular idiom, because it says "apply this chain of functions to this value here"
02:09:23 <jle`> um.  if you forsee yourself ever "naming" `filter odd . map (^2)`, then the second is preferable
02:09:24 <tdammers> and it allows for easy refactoring
02:09:31 <jle`> because then you can just pop it out and pop in the new name
02:10:04 <jle`> so i guess the second one has easier refactoring in more situations
02:10:17 <tdammers> OTOH, if map (^2) [1..] has a chance of deserving its own identifier at some point, then the first form would make more sense
02:10:23 <kadoban> The second is more consistent at least. The first is like, following the convention 80% of the way, and then stopping. Which seems minorly odd.
02:10:42 <tdammers> matter of what you want to express I guess
02:10:44 <hsk3> Yeah. interestingly LYAH chose the first one!
02:10:56 <jle`> yeah i guess both `filter odd . map (^2)` and `map (^2) [1..]` both could possibly be named
02:11:09 <jle`> i've down the first one before too, sometimes it's just more clear
02:11:23 <tdammers> I have an easier time naming `map (^2) [1..]` than the other
02:11:25 <jle`> if i want to think of my "starting data" as a list of squares instead of a list [1..]
02:11:56 <tdammers> let squares = map (^2) [1..] -- makes a lot of sense to me
02:12:22 <jle`> yeah, if the last thing has a more meanignful name/idea, i usually use that
02:12:29 <tdammers> let oddsAmongSquared = filter odd . map (^2) -- feels a lot clunkier
02:12:29 <hsk3> jle`: so your way of deciding what goes after $ is what is "starting data" in question?
02:12:54 <jle`> i used to really care about picking one or the other
02:12:58 <tdammers> I'd go with "what makes more sense conceptually"
02:13:03 <jle`> or as in, keeping a consistent pattern
02:13:08 <jle`> but then i just varynow
02:13:09 <tdammers> whichever states my intent more clearly is what I'll write
02:14:32 <Ferdirand> shouldn't that be map (^2) . filter odd instead ?
02:14:50 <tdammers> Ferdirand: point in case
02:14:52 <Ferdirand> unless you are not going for integers
02:15:13 <jle`> i thought that but i don't think it makes a difference
02:15:16 <tdammers> > take 10000 $ filter odd . map (^2) $ [1..]
02:15:23 <lambdabot>  mueval: signalProcess: permission denied (Operation not permitted)
02:15:23 <lambdabot>  mueval-core: Time limit exceeded
02:15:25 <tdammers> oh dayum
02:15:28 <jle`> oh i guess you are squaring less numbers
02:15:32 <tdammers> > take 1000 $ filter odd . map (^2) $ [1..1000]
02:15:36 <lambdabot>  mueval-core: Time limit exceeded
02:15:46 <tdammers> > take 10 $ filter odd . map (^2) $ [1..10]
02:15:48 <lambdabot>  [1,9,25,49,81]
02:15:49 <jle`> and squaring is probably more costly than checking for even/oddness
02:16:13 <tdammers> oh nm, I had (2^) in mind, not (^2)
02:16:23 <tdammers> > take 10 $ filter odd . map (2^) $ [1..10]
02:16:24 <lambdabot>  []
02:16:31 <tdammers> > take 10 $ filter odd . map (2^) $ [0..10]
02:16:31 <jle`> however i could imagine a Num instance where both would be the same
02:16:32 <aleator__> Does anyone knwo if I can take trifectas ansi colored error output and somehow dump that to html?
02:16:33 <lambdabot>  [1]
02:17:05 <jle`> imagining Num instances optimized for various ad-hoc esoteric purposes is a hobby of mine
02:17:08 <tdammers> aleator__: yes you can, but I don't know if there's an existing tool for that
02:17:32 <tdammers> aleator__: it would amount to parsing terminal escapes and converting them into suitable HTML/CSS
02:17:52 <tdammers> certainly not impossible
02:17:54 <aleator__> tdammers: I guess my question is better formulated as if there is something readymade for that
02:18:02 <tdammers> aleator__: not that I know of
02:18:04 <funfunctor> delrik: {-# INLINE fmap #-} \n fmap f m = MyState (f <$> unMyState m)
02:18:27 <aleator__> tdammers: Of course, there are zillion node/python packages for that, but seems silly to go that far
02:18:38 <tdammers> why not? just shell out
02:18:50 <tdammers> not the end of the world, unless you're under harsh time constraints
02:19:31 <funfunctor> delrik: next up, runMyState m = evalStateT (runExceptT . unMyState $ m)
02:20:12 <aleator__> tdammers: Well, mostly annoying because that needs IO in place where I don't want it.
02:20:37 <tdammers> I see
02:20:52 <funfunctor> delrik: also remove the unqualified Applicative import ;)
02:21:13 <delrik> funfunctor: just as an aside, wts the calling convetion
02:21:43 <delrik> i wrote min as runMyState specifically becase of how i was using runExceptT to unwrap my vals in ghci
02:22:09 <funfunctor> delrik: put {-# INLINE ??? #-} with the same indent inside the various Functor and Applicative instance primitives
02:22:17 <muzzle> is there any resource on how i can get data.text substrings ?
02:22:24 <muzzle> ?
02:22:33 <funfunctor> delrik: just follow my lead..
02:22:33 <delrik> funfunctor: kk
02:23:12 <funfunctor> delrik: I want you to be thinking about type-signatures rather than bashing things into ghci until it type checks
02:23:20 <tdammers> muzzle: what about hackage docs?
02:23:22 <tdammers> http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text.html#g:16
02:24:05 <funfunctor> delrik: only C programmers fight types and then types win (<lol>)
02:24:12 <delrik> lolol
02:24:14 <tdammers> if you want the classic substr function, consider substr ofs len = take len . drop ofs
02:24:55 <funfunctor> delrik: alright, let me know when you have committed the updates so I can review were your at
02:25:00 <delrik> kk
02:25:11 <Arahael> I'm confused again.  In "do" notation, why is there a difference between "return r ^. responseBody", and "return $ r ^. responseBody"?
02:25:36 <Arahael> The ^. should be binding most tightly?
02:26:06 <shachaf> Function application is even tighter. It's tighter than any operator.
02:26:11 <shachaf> do is irrelevant.
02:26:38 <Arahael> shachaf: But the ^. should still be binding tightly, just not as tightly as $. There is no function application in the former example, though.
02:26:55 <shachaf> The function return is applied to the argument r
02:27:20 <Arahael> I see.
02:27:23 <delrik> funfunctor: pushed
02:27:35 <Arahael> So the former example was infact equivalent to (return r) ^. responseBody?
02:27:52 <muzzle> tdammers: well O(n) performance is not really all that great. With bytestring i can get O(1) but i use unicode text
02:28:00 <shachaf> Yes. That's what it means for it to be stickier than the operator.
02:28:07 <delrik> and just got rid of the unqalified import
02:28:17 <Arahael> shachaf: Thanks.
02:29:40 <funfunctor> delrik: alright, looks good! now, lets make some openMyState and closeMyState functions
02:30:01 <delrik> funfunctor: https://github.com/elrikdante/StateT/commit/fe6abb72705c9d61dcda275699d41cedeac1e072
02:30:16 <delrik> that commit Msg has the issue I’m currently experiencing with runMyState
02:31:45 <funfunctor> delrik: yes, remove some of the other stuff going on there and we just need to adjust our monadic structure slightly
02:32:52 <delrik> funfunctor: like we’re going to add the StateT to our stack?
02:33:23 <funfunctor> delrik: newtype MyState a = MyState { unMyState :: ExceptT MyStatesPossibleErrors (StateT (Int) IO) a } deriving (Monad, MonadIO)
02:33:27 <funfunctor> correct
02:33:54 <funfunctor> delrik: and our state is the record a Int type
02:34:07 <funfunctor> delrik: but this could be any type really.. lets start with a Int
02:34:13 <delrik> funfunctor: should I save questions till the end or should I raise them as i have them?
02:34:22 <funfunctor> delrik: raise them
02:34:32 <funfunctor> throwQuestion
02:35:27 <delrik> funfunctor: okay, so what is the ExceptT saying here: m (Either e a) -> ExceptT e m a
02:35:39 <delrik> its a Left or Right value wrapped in a mondatic context.
02:35:52 <delrik> and it’ll yeild a value of type ExceptT e m a
02:36:18 <funfunctor> delrik: yes, we have not made use of it yet.. we will towards the end actually
02:36:36 <delrik> I was trying to unwrap those compoments but I wasn’t able to, is that why we use run/un/etc
02:36:49 <delrik> because these structures are opaque?
02:37:48 <funfunctor> delrik: essentially we are going to wrap up a open -> do something with state -> close sequence into our monadic structure using the "bracket" pattern. Later we will deal with exceptions in the various steps
02:38:01 <delrik> kk
02:38:52 <funfunctor> delrik: alright so lets stub out some functions openMyState = undefined and closeMyState = undefined
02:39:31 <delrik> funfunctor: kk
02:40:11 <funfunctor> delrik: now the pattern goes like this: bracket open close body = do { MyState $ catch (unMyState open) throwE     ... you complete the rest..
02:40:57 <delrik> funfuncotr: okay
02:41:29 <funfunctor> delrik: sorry, missing ; at the end of the throwE; hopefully makes it more clear
02:44:54 <Maluno> Heyoh guys.
02:45:17 <Maluno> Can anyone suggest me a projecto to apply my haskell knowledge?
02:45:23 <Maluno> project*
02:46:16 <tdammers> what interests you?
02:46:36 <Maluno> Basically everything, I am not picky
02:46:57 <tdammers> that doesn't exactly narrow it down a lot :D
02:47:00 <Maluno> I just want to work towards something, in order to see how well prepared I am at this language
02:47:28 <tdammers> what have you built so far?
02:47:29 <Maluno> It can be a game, it can be accoutant stuff, basically anything, I cant quite narrow the spectrum
02:47:42 <bergmark> i have a suggestion for you Maluno, update language-typescript to allow union types
02:47:55 <funfunctor> Maluno: point of sales software for a coffee shop
02:48:08 <Maluno> mhmm mhmm
02:48:16 <tdammers> sandboxable JS interpreter :D
02:48:38 <funfunctor> or JS JIT'er using LLVM binding
02:48:58 <Maluno> mhmmmmm, mhmmmm, I'll try it boys.
02:48:58 <tdammers> funfunctor: I have more use for an interpreter
02:49:15 <Maluno> I'll investigate further
02:49:31 <tdammers> I started writing a JS interpreter myself, but shelved it for the time being
02:49:39 <funfunctor> tdammers: I want my coffee shop to not have null pointer exceptions..
02:49:42 <tdammers> I still need one, but I need other things more pressingly
02:50:09 <Maluno> I understand, I understand.
02:50:11 <tdammers> funfunctor: you can use fromJust for much the same effect
02:51:40 <tdammers> MaybeT all the things
02:52:08 <funfunctor> does every Haskell'er learn to first make gaint Monad's from hell and then realise they should have been using Applicative control all along..?
02:52:36 <funfunctor> tdammers: MaybeNotT, Maybe Just Coffee
02:53:48 <funfunctor> delrik: how are you going? latic acid building up in the brain?
02:54:31 <tdammers> purchaseCoffee :: Maybe (Maybe CoffeeProduct -> Maybe Milk -> Maybe Sugar -> Maybe Cream -> Maybe Syrup -> Maybe ExtraShot -> Maybe Topping -> Maybe (WouldYouLikeSomethingElse (Maybe CoffeeOrder) -> Maybe (Maybe CoffeeOrder))
02:54:36 <bernalex> I'm having some fun with GADTs and stuff. can someone help me figure them out? I'm apparently having problems... http://lpaste.net/1392294179635200000
02:54:38 <tdammers> for good measure
02:54:56 <bernalex> I guess I'm "deconstructing" my values wrongly
02:55:53 <Arahael> It seems I'm entering into a world of pain when I try to to be careful with my imports. (Ie, I only import exactly what I need)
02:56:00 <delrik> funfunctor: that and exhaustion =) — frankly i have no idea what I’m doing.   in the context of an IO monad for instance, I could wrap my head around the idea of needing bracket syntax to handle deallocation handles etc, but in this context of MyState, I’m not even clear right now how to effectively unwrap this computation so I can make it down to he IO monad at the base.
02:57:12 <funfunctor> delrik: one step at a time, did you complete the bracket pattern that I said yet?
02:57:32 <bernalex> to simplify. if I have 'data Foo where Bar :: a -> Foo' -- is there no way to get the a out of that? like f :: Foo -> Int, so if I have a 'Bar 5', how would I get the 5?
02:59:03 <funfunctor> delrik: at this stage we don't really need to do much unwrapping, what we do is lift our computation into our MyState monad
02:59:10 <delrik> funfunctor: that’s wht I’m in the middle of trying to understand now.  I looked at the def in Control.Exception, but I’m not clear on what aspect of this we’re abstracting into MyState since I’m not entirely sure what openMyState and closeMyState should be doing, or did you literally just want me to write out the pattern as I saw it, in which case I’m an even bigger nub.
02:59:16 <funfunctor> delrik: i'll show you how soon
02:59:40 <pavonia> bernalex: You can pattern match: case foo of { Bar x -> x }
02:59:53 <funfunctor> delrik: literally just write it out and we will adjust later
03:00:08 <bernalex> pavonia: is it possible to do this LHS?
03:00:10 <delrik> funfunctor: makes a lot more sense now =)
03:00:35 <pavonia> bernalex: I think so
03:00:41 <funfunctor> delrik: I just want to shim our your yellow brick road of exploration so you come up with good questions as we go to later explore
03:00:51 <bernalex> pavonia: I thought I should be able to do e.g. f :: Foo -> Int; f (Bar a) = a -- but evidently not
03:01:32 <delrik> funfunctor: thx for being so patient!
03:01:34 <pavonia> bernalex: Ah, the problem is your type of a is more general than Int
03:01:48 <funfunctor> delrik: thats ok, thx for putting the effort in
03:01:58 <bernalex> pavonia: ah! that's what I suspected. OK, so see http://lpaste.net/1392294179635200000 -- what do I need to do here?
03:02:59 <bernalex> do I need to use some ::s somewhere or something?
03:03:35 <funfunctor> delrik: note that our bracket implementation is custom, no need to import bracket
03:03:53 <delrik> funfunctor: kk
03:04:39 <pavonia> bernalex: I cannot see any solution other than adding a type parameter to StackItem, assuring all Fractionals in one term are of the same type
03:04:53 <tdammers> ^ that
03:04:57 <delrik> funfunctor: k, its pushed.
03:05:13 <bernalex> pavonia: how would you do that? I'm quite noob with GADTs, sorry!
03:05:27 <bernalex> do you mean s/a/Double for instance?
03:05:45 <tdammers> something like data StackItem a = ...
03:05:56 <bernalex> oh right... hmmmm...
03:05:57 <tdammers> instead of just data StackItem =
03:05:57 <pavonia> data StackItem a where StackNum :: a -> StackItem a ...
03:06:08 <bernalex> how would that work for Op tho?
03:06:19 <tdammers> just fine
03:06:21 <tdammers> :P
03:06:25 <bernalex> :p
03:06:59 <tdammers> no, but really
03:07:25 <bernalex> yeah I see
03:07:26 <Arahael> How do I import a particular IsString from Data.ByteString.Internal.ByteString?
03:07:49 <bernalex> OK just used Doubles everywhere
03:07:54 <tdammers> haha
03:07:55 <bernalex> good enough for now
03:07:59 <bergmark> Arahael: a particular instance? You can't do that, if you import the module you get all the instances it defines
03:08:08 <Arahael> bergmark: And then I'll get conflicts. :(
03:08:09 <bernalex> I want to see if this even works. because it seems quite nice.
03:08:12 <Arahael> Ambigious.
03:08:23 <funfunctor> delrik: almost, your bracket should look like this bracket open close body = do { MyState $ catchE (unMyState open) throwE; MyState $ catchE (unMyState body) (\e -> do unBladeRF close ; throwE e); close }
03:08:34 <bergmark> Arahael: because of orphan instances?
03:08:42 <bernalex> OK it runs forever so maybe not that great right now
03:08:56 <Arahael> bergmark: Possibly, I barely even know what those are, but I learnt they exist the other day.
03:09:17 <funfunctor> delrik: ideally we want things to be more Applicative than Monadic hence no return but that is outside the scope of this
03:09:52 <bergmark> Arahael: it's when you define an instance in a module that defines neither the type nor type class, it's frowned upon :)
03:10:09 <bergmark> Arahael: because it leads to this problem
03:10:14 <Arahael> bergmark: If I import *all* of Data.ByteString.Lazy, I get conflicts because I already use 'map' from the prelude.  So I'm attempting to import /only/ what I need.
03:10:57 <tdammers> Arahael: import qualified?
03:11:01 <bergmark> Arahael: but map is a function so that's fine, and doing explicit imports like you say is good practice
03:11:04 <Arahael> bergmark: But the problem is that importing /only/ the ByteString seems to result in being unable to have my overloaded strings applied correctly.
03:11:07 <funfunctor> delrik: make sense?
03:11:25 <tdammers> import Data.ByteString.Lazy (ByteString); import qualified Data.ByteString.Lazy as LBS
03:11:34 <tdammers> ^ what I usually do
03:11:57 <bergmark> Arahael: oh i think i misunderstood, importing a new module shouldn't make OverloadedStrings ambiguous all of sudden
03:12:23 <Arahael> I get errors such as: No instance for (Data.String.IsString v0), I'm attempting to resolve that.
03:12:43 <Arahael> Apparently that 'v0' there is ambigious and there are about 9 options.
03:12:44 <delrik> funfunctor: not at all, I’m looking up unBladeRef
03:13:02 <delrik> actually
03:13:03 <delrik> i lied
03:13:04 <bergmark> Arahael: that error should persist even if you remove all imports
03:13:52 <funfunctor> delrik: sorry if I wrote BladeRF somewhere that is a typeo
03:13:54 <Arahael> bergmark: But I can only see about 3 options - I think the one I want is: instance a ~ Data.ByteString.Internal.ByteString => Data.String.IsString
03:14:03 <Arahael> bergmark: (But I really don't know)
03:14:10 <funfunctor> delrik: i'm writing code at the same time that is similar to this ;)
03:14:14 <merijn> Arahael: The correct solutions is to not use the IsString instance of ByteString because it's evil
03:14:24 <Arahael> merijn: I'm not the one using it.
03:14:32 <Arahael> merijn: wreq apparently does.
03:15:00 <delrik> funfunctor: if in either case of opening the handler or runing my body an error is thrown, we throwE the error
03:15:12 <merijn> Arahael: It's examples are just using that to do easily type things
03:15:14 <Arahael> merijn: The precise step in the tutorial I'm attempting to perform is this: r <- post "http://httpbin.org/post" ["num" := 3, "str" := "wat"]
03:15:18 <delrik> in the case where the error is thrown after trying to eval body we have to : unBladeRF close ;
03:15:24 <delrik> funfunctor:
03:15:37 <funfunctor> delrik: show me the code..
03:15:49 <Arahael> merijn: Though I'm using just ["foo" := "bar"] in my code.
03:15:57 <merijn> Arahael: It's in Data.ByteString.Char8, but be warned that it silently truncates all unicode to ascii
03:16:41 <Arahael> merijn: So I should do an import Data.ByteString.Char8 (IsString) ?
03:16:53 <Arahael> merijn: But the next question is: How the heck should I know this?
03:17:06 <merijn> Arahael: You don't need to specify anything, just "import Data.ByteString.Char8 ()" is sufficient
03:17:18 <Arahael> Ah, one of those orphans.
03:17:27 <merijn> Arahael: Too many people already know how to find it, Char8 should be harder to find >.>
03:17:37 <funfunctor> delrik: s/BladeRF/MyState/ it was just a typo..
03:18:04 <Arahael> Heh.  So if I can't figure out where or what to import, and I'm not actually using it, I should guess that it's an orphan and I should just find out what the magical module it happens to be in?
03:18:24 <bernalex>     go _ _ = "uh oh" -- denotative debugging at its finest
03:18:49 <Arahael> merijn: I'll have to ask again tomorrow, I must head off. :(  Thanks for your help. :) It's been quite educational.
03:20:03 <Arahael> bergmark: Thanks for your help also - g'night!
03:21:32 <delrik> funfunctor: kk pushed\
03:23:09 <funfunctor> delrik: alright, now we want  withMyState stuff = runMyState $ bracket openMyState closeMyState stuff
03:23:36 <funfunctor> delrik: and the usage would go  main = withMyState $ do ...
03:24:00 <funfunctor> delrik: does that make a bit more sense now?
03:24:41 <delrik> funfunctor: sure that pattern makes sense
03:25:23 <guibou> Perhaps a naive question, but I'm trying to create a "data Vector = Vector Float Float Float" to store 3D points. I'd like to be able to overload some basic operators on them (+, -, *), which was easy by instancing Num. However, I also like to be able to multiply them by scalar, and I have no idea how to do that.
03:25:23 <funfunctor> delrik: you can do openMyState = do MyState $ lift (put 3)  to store 3 inside our state upon open
03:26:02 <bernalex> can someone tell me wtf I'm doing wrong that makes my program run forever? lol. I have this:
03:26:04 <bernalex> main = putStrLn . s . foldr b [] =<< getArgs <> (words <$> getContents)
03:26:19 <bernalex> it works if I use echo blah | ./program -- but not with ./program blah
03:26:25 <mauke> bernalex: it's waiting for input
03:26:30 <mauke> start typing :-)
03:26:37 <bernalex> oh right
03:26:44 <bernalex> so what I really want is "if arguments, use args, if not, getContents"
03:26:51 <guibou> when I'm writing (*) :: Vector -> Float -> Vector such as (*) (Vector a b c) scalar = Vector (a * scalar) (b * scalar) (c * scalar) it tells me that there is an ambiguity between on (a * scalar) for the * operator which is defined in Prelude and in my code (obviously).
03:26:53 <funfunctor> delrik: in main you can fetch out the state and upon close figure out how to set it to zero or something
03:26:54 <bernalex> so I guess <> won't work like that then huh
03:27:10 <delrik> funfunctor: kk
03:27:12 <funfunctor> delrik: any way, that should be plenty to think about?
03:27:58 <mauke> bernalex: your lifted <> simply runs both operands, then concatenates the results
03:28:13 <delrik> funfunctor: I think so!
03:28:15 <mauke> so it always does both before even looking at the results
03:28:25 <bernalex> mauke: yes I realise this now. what do I want instead of <>?
03:28:45 <bernalex> surely there's some `infix` operator to my rescue for this?
03:29:22 <bennofs> bernalex: you can use Control.Monad.Trans.Maybe.MaybeT + (<|>)
03:29:39 <funfunctor> delrik: A suggestion would be to have all this open a file, allow you to write to it in main without needing to pass around the file descriptor by shoving it in the state and closing the file at the end
03:29:47 <bernalex> bennofs: hmmm that sounds not so nice if I need to be in a MaybeT... would you care to give me an example?
03:29:56 <funfunctor> delrik: makes for a nice simple file logging interface
03:30:03 <bennofs> @let import Control.Monad.Trans.Maybe
03:30:06 <lambdabot>  Defined.
03:30:14 <bennofs> @let import Control.Monad.State
03:30:16 <lambdabot>  Defined.
03:30:20 <hsk3> Go to https://www.haskell.org/hoogle, search for "nub", click on "nub". Why the hell doesn't Safari jump to the nub function? Is anyone else here on Safari on OS X Yosemite?
03:30:23 <hsk3> Works fine on Chrome
03:30:24 <hsk3> sigh
03:30:24 <funfunctor> delrik: hope the lesson was understandable/useful?
03:31:55 <bennofs> > flip runState 0 $ runMaybeT $ MaybeT (modify (+3) *> return Nothing) <|> MaybeT (modify (+4) *> return (Just 5)) <|> MaybeT (modify (+5) *> return Nothing)
03:31:57 <lambdabot>  (Just 5,7)
03:32:10 <bennofs> bernalex: only the first two state state actions got executed
03:32:54 <delrik> funfunctor: yeah, it was definitely useful, although I’m still clumsy with deconstructing types and understanding the current level of abstraction i’m operating in. all that said I have learned a lot tonight, and I have the git history to look back on for practise.
03:32:57 <bennofs> bernalex: so you could do: runMaybeT (MaybeT getArgsMaybe <|> lift getContents)
03:33:32 <bennofs> bernalex: you should probably be able to write that as: runMaybeT (mfilter (not . null) getArgs <|> lift getContents)
03:34:05 <bennofs> (types don't really match yet, you'd need to change getContents to return a list of strings or getArgs to return a single string)
03:34:27 <bennofs> s/getArgs/lift getArgs in the mfilter example
03:34:42 <bernalex> yes I words <$> getContents
03:35:27 <mniip> so I've been recently very bored and doing some skiing
03:35:37 <mniip> is there a shorter way to write flip than 's (k (s s (k k))) (s (k k) s)'
03:35:40 <funfunctor> delrik: paper, pen and type checking.. then slow down and look at the paper.. treat things algebraically
03:35:44 <bernalex> does
03:35:46 <bernalex> main = putStrLn . s . foldr b [] =<< runMaybeT (mfilter (not . null) getArgs <|> lift (<$> getContents))
03:35:48 <bernalex> make sense? I wonder
03:36:47 <delrik> funfunctor: like how far algebraically? should i pick up lambda-calc again or something? SKI?
03:37:25 <bernalex> erm lift (words <$> getContents)
03:37:29 <bennofs> bernalex: a 'words' and a 'lift' (before getArgs) is missing there
03:37:44 <bernalex> bennofs: is there an alternative to lift?
03:38:02 <bennofs> bernalex: I don't think
03:38:57 <bernalex> bennofs: this doesn't feel right
03:39:02 <bernalex> Maybe doesn't feel right for this
03:39:23 <bernalex> getContents will always at least be ""
03:39:36 <bernalex> or words <$> getContents -- [""]
03:40:35 <bernalex> I guess I can live with that for now though
03:41:05 <bernalex> fromJust code just reeks of The Wrong Thing
03:42:03 <bernalex> oh wait that won't even work
03:42:11 <bernalex> bennofs: main = putStrLn . s . foldr b [] =<< fromJust <$> (runMaybeT (mfilter (not . null) (lift getArgs <|> lift (words <$> getContents))))
03:42:20 <delrik> funfunctor: I unfortunately have to get ready to go to work now =\ so hopefull we can pick this up tonight?
03:42:28 <funfunctor> delrik: if you know what a lambda expression is than that enough I should think to get by for the moment
03:42:34 <bernalex> this will work with args, but not without
03:42:46 <bernalex> oh
03:42:50 <bernalex> my fault. bad parens
03:42:55 <funfunctor> delrik: I sort of have to focus on making my shit work here
03:42:59 <funfunctor> delrik: good luck
03:43:11 <bernalex> bennofs: main = putStrLn . s . foldr b [] =<< fromJust <$> (runMaybeT (mfilter (not . null) (lift getArgs) <|> lift (words <$> getContents)))
03:43:15 <bernalex> bennofs: works... thanks!
03:43:25 <bernalex> still feels wrong bc of fromJust
03:43:26 <delrik> thx dude!
03:54:44 <statusfailed> What is alpha conversion for?
03:55:03 <statusfailed> I don't understand why it's useful
03:55:08 <ibid> avoiding variable name capture
03:55:57 <ibid> most times, people don't use it explicitly
03:56:14 <ibid> also, it's good for defining alpha equivalence :)
03:58:12 <mauke> (\x -> (\y -> x) z) y  -- should reduce to y, not z
04:00:16 <statusfailed> mauke: but how does alpha conversion help?
04:00:42 <statusfailed> ibid: Does this paper mean alpha conversion is unnecessary? http://www.cse.chalmers.se/~emax/documents/axelsson2013using.pdf
04:00:47 <statusfailed> ibid: well, the technique in there anyway
04:01:00 <mauke> dunno, I don't know how alpha conversion works
04:01:21 <mauke> it'll probably rename some of the variables
04:01:28 <statusfailed> mauke: I think beta reduction gets that down to z
04:01:29 <bernalex> is there a safe read that gives (a, String), rather than [(a, String)]?
04:01:37 <mauke> statusfailed: yes, which is wrong
04:01:44 <ibid> mauke: alpha conversion renames a bound variable
04:01:59 <bernalex> I guess readMay could work tho
04:02:03 <statusfailed> mauke: er, I meant y :p
04:02:54 <mauke> statusfailed: doesn't beta reduction just replace x by y?
04:03:10 <muzzle> on bytestring take n $ drop m str is O(1), is there something like that (better than O(n)) for Data.Text ?
04:03:13 <ibid> statusfailed: alpha and beta conversion are historical names from the very first formulations of the lambda calculus. modern reformulations generally eschew the alpha conversion in favour of other capture avoidance devices; the beta conversion rule remains and retains its historical name
04:04:13 <ibid> statusfailed: that paper has no use for alpha conversion, it uses another technique
04:05:18 <wacco> > let test = "PONG :" ++ . drop 6
04:05:19 <lambdabot>  <hint>:1:24: parse error on input ‘.’
04:05:47 <wacco> Ok.. I get how to fix that, I don't get why.
04:05:58 <ibid> statusfailed: i didn't read that paper very closely but i suspect you couldn't even define alpha conversion in its formalism
04:10:17 <mauke> I've checked wikipedia
04:10:22 <ibid> in mauke's example, using normal-order reduction with a naive beta reduction rule, you end up with (\x -> (\y -> x) z) y =>beta (\y -> y) z =>beta z.  a correct beta conversion rule will forbid the first reduction and you have to first perform an alpha conversion on the inner y: (\x -> (\y -> x) z) y =>alpha (\x -> (\k -> x) z) y =>beta (\k -> y) z =>beta y
04:10:36 <mauke> my example fails the "freshness condition"
04:11:01 <ibid> another, more modern variant will have the beta reduction rule do the renaming automatically without an explicit alpha step
04:11:22 <mauke> that is, (\y -> t)[x := r] = \y -> t[x := r]) if x /= y and y is not free in r
04:11:35 <mauke> but in my code r is y so y is free in r
04:11:57 <ibid> other modern versions convert the original term into a representation where capture never happens
04:14:07 <zipper`> There's an example in Yesod.Form.Bootstrap3 where they use the following code for a submit button.
04:14:10 <zipper`> `<*  bootstrapSubmit (BootstrapSubmit MsgSubmit "btn-default" [("attribute-name","attribute-value")])`
04:14:27 <zipper`> However when I use it I get the error that MsgSubmit it out of scope
04:14:50 <bernalex> how did you compose undo & pl with lambdabot again?
04:14:53 <zipper`> According to this MsgSubmit should come with Bootstrap 3 http://hackage.haskell.org/package/yesod-form-1.4.4/docs/Yesod-Form-Bootstrap3.html
04:15:08 <mauke>  @. pl undo
04:15:13 <zipper`> With Yesod.Form.Bootstap3
04:15:19 <bernalex> mauke: ah, so not pl . undo. thanks.
04:20:30 <mniip> is there a shorter way to write flip than 's (k (s s (k k))) (s (k k) s)'
04:20:48 <mniip> using only s and k combinators of course
04:26:58 <zipper`> Can anyone help me find where the function MsgSubmit comes from?
04:27:17 <zipper`> The Type I mean
04:28:38 <mpickering> somewhere in Yesod it seems?
04:32:02 <ClaudiusMaximus> zipper`: tried hayoo ?
04:32:26 <zipper`> ClaudiusMaximus: Yeah it's really just taking me back to where I saw the function
04:32:30 <zipper`> `<*  bootstrapSubmit (BootstrapSubmit MsgSubmit "btn-default" [("attribute-name","attribute-value")])`
04:33:31 <zipper`> The compiler says it's out of scope but it seems to be imported by Yesod.Forms.Bootstrap3 in it's example for horizontal forms.
04:45:21 <joelneely> @pl \xs n -> take n xs
04:45:21 <lambdabot> flip take
04:45:49 <nerium> If I've a type Err and the function I'm in wants me to return Err (), how do I do that?
04:45:52 <joelneely> @pl \n, s = "" ++ printf "%4d: %s" n s
04:45:52 <lambdabot> (line 1, column 7):
04:45:53 <lambdabot> unexpected "="
04:45:53 <lambdabot> expecting operator, ",", pattern or "->"
04:46:03 <joelneely> @pl \n, s -> "" ++ printf "%4d: %s" n s
04:46:03 <lambdabot> uncurry ((([] ++) .) . printf "%4d: %s")
04:46:27 <mauke> nerium: depends on how Err is defined
04:46:43 <joelneely> @pl \n, s -> (printf "%4d: %s" n s)::String
04:46:44 <lambdabot> uncurry (flip flip String . ((::) .) . printf "%4d: %s")
04:46:51 <nerium> mauke: https://gist.github.com/oleander/5796f03db28d122561c3
04:46:55 <mauke> joelneely: \n, s is invalid syntax
04:47:34 <mauke> nerium: ok, so do you want to return success or failure?
04:47:42 <nerium> mauke: Sucess
04:47:49 <mauke> nerium: Ok ()
04:47:50 <joelneely> thanks; cut and paste error!
04:47:57 <mauke> nerium: or return ()
04:48:07 <nerium> mauke: And a failure?
04:48:08 <joelneely> @pl \n s -> (printf "%4d: %s" n s)::String
04:48:08 <lambdabot> flip flip String . ((::) .) . printf "%4d: %s"
04:48:12 <nerium> Just Bad "hello" ?
04:48:15 <mauke> yes
04:48:18 <mauke> or fail "Hello"
04:48:25 <nerium> aha, thanks!
04:48:41 <mauke> joelneely: @pl doesn't know about :: or types
04:48:45 <nerium> mauke: So () is the type in this case?
04:49:00 <mauke> nerium: () is the type in the type and the value in the value
04:49:03 <mauke> data () = ()
04:49:29 <nerium> mauke: Okay, what's the purpose of () then?
04:49:40 <wacco> somehow, learning haskell by building a chat client isn't the brightest move I've made in recent memory. I don't know if I broke stuff, or you've all gone quiet >__<
04:49:45 <mauke> it's a dummy value for when you have nothing particular to return
04:49:57 <mauke> similar to void in C, but void has no values while () has exactly one
04:50:13 <joelneely> mauke: I'm just looking at printf, and the docs say that it can return either String or IO a ; I'm curious as to how to influence that result type
04:50:34 <mauke> joelneely: type annotation with :: or implicitly, by using the result in some context
04:50:38 <nerium> mauke: Aha, that makes sense. Thanks!
04:50:59 <augur> is   newtype Foo a = Foo (Bar -> ([a],Bar))   a monad?
04:51:01 <joelneely> @pl \n s -> "" ++ (printf "%4d: %s" n s)
04:51:02 <lambdabot> (([] ++) .) . printf "%4d: %s"
04:52:11 <joelneely> wacco: not quiet, just thinking?
04:52:49 <mauke> waccoRef: check the channel logs in the topic
04:53:02 <joelneely> @pl \(n, s) -> "" ++ printf "%4d: %s" n s
04:53:02 <lambdabot> uncurry ((([] ++) .) . printf "%4d: %s")
04:54:09 <waccoRef> mauke: my code doesn't show that yet on connecting - good thinking, saves me from having to keep mibbit open :)
04:54:09 <mniip> question: is kolmogorov complexity in SK combinator representation of lambdas an unsolved problem?
04:54:25 <joelneely> @pl \ss -> map fmtNbrs $ zip [1..] ss
04:54:26 <lambdabot> map fmtNbrs . zip [1..]
04:54:30 <waccoRef> (also yes, I did break stuff)
04:55:13 <mniip> like
04:55:29 <mniip> there's a pretty simple algorithm to convert any lambda into SK
04:55:40 <mniip> but it won't always be the shortest representation
04:55:55 <mauke> augur: naively, that's ListT (State Bar) a, which is not a monad because State isn't commutative
04:56:02 <mauke> but maybe there's a better monad instance
04:56:19 <augur> hmm
04:56:38 <mpickering> I think it probably is a monad
04:56:54 <mpickering> Bool -> (Maybe a, Bar) is
04:57:04 <augur> Maluno: my thinking is it would just sequence the stateful actions and collect up the results for each step
04:57:15 <augur> er
04:57:18 <augur> mauke: ^
04:57:31 <joelneely> mauke: thanks for the tip
04:57:36 <mpickering> the only was to see is to try to implement it and then prove the monad laws :)
04:58:35 <augur> mpickering: yeah :p
04:58:41 <augur> but i'd rather just ask in case its already know :p
04:58:54 <mauke> @unmtl MaybeT (State bar) a
04:58:54 <lambdabot> (State bar) (Maybe a)
04:59:01 <mauke> @unmtl State bar (Maybe a)
04:59:01 <lambdabot> bar -> ((Maybe a), bar)
04:59:30 <augur> @unmtl ListT (State bar) a
04:59:30 <lambdabot> (State bar) ([] a)
05:30:20 <muzzle> is there a smart way to work with Data.Text based on indices ? In ByteString i can do drop and take in O(1), but it seems to me, that with Text I can't
05:30:29 <muzzle> is there a good way do deal with this ?
05:32:23 <fenak> hi, i'm beginning to study haskell through cis 194 course, just did homework 1.. if anyone experienced could give me critics or tips would be very appreciated.
05:32:26 <fenak> https://github.com/fenak/cis194-exercises/commit/2e28c9a3a1ed6bcc1785161b40352997ef063145
05:32:50 <merijn> muzzle: There's a good reason you can't
05:33:04 <merijn> muzzle: 1sec
05:36:34 <zipper`> Anyone know how to make your footer stick to the bottom part of a page no matter what in Yesod?
05:37:51 <fenak> zipper`: isn't that question more html+css specific? i'm not used to Yesod, but don't know if it would have any difference.
05:38:40 <zipper`> fenak: Well it's more like a bootstrap 3 question but yesod has this way of integrating HTML and CSS that makes me think it might have a yesod way of doing it.
05:38:43 <zipper`> fenak: e.g forms
05:39:03 <fenak> zipper`: if i understood correctly what you want to do, you could do something like: .footer { position: absolute; bottom: 0; } in css
05:40:05 <zipper`> fenak: Yeah but bootstrap the css framework for it should have a way of doing it already I think.
05:40:48 <merijn> muzzle: Ok, the basic problem is: What is the Nth index of Text?
05:40:52 <fenak> zipper`: http://getbootstrap.com/examples/sticky-footer/
05:40:56 <augur> aha mauke, mpickering: its not a monad
05:41:21 <zipper`> fenak: Thanks let me look at that.
05:41:27 <merijn> muzzle: To find the Nth character and to take/drop N characters you need to find out which/how many codepoints are involved in that character
05:41:28 <augur> bind/kleisli-compose is not associative because of ordering effects
05:41:45 <merijn> augur: It *is* associative
05:41:48 <zipper`> fenak: Yeah like that one.
05:41:51 <merijn> augur: I suspect you mean commutative?
05:42:03 <augur> merijn: no, its not associative.
05:42:17 <merijn> augur: Eh, yes it is...the monad laws even require it
05:42:25 <fenak> zipper`: you still need to implement this as your custom css
05:42:40 <merijn> "(a >=> b) >=> c" must be equal to "a >=> (b >=> c)"
05:42:56 <fenak> zipper`: if you inspect the example code you'll see that is customized some way like the code i sent you
05:43:05 <augur> merijn: no what im saying is the (>=>) I defined is not associative
05:43:12 <augur> merijn: so Foo is not a monad
05:43:19 <merijn> augur: Ah, right
05:43:58 <merijn> augur: Then we agree and were just using different interpretations of your comment ;)
05:44:05 <augur> yes :p
05:44:23 <augur> so the thing is, the way im going to use it tho _is_ monadic in nature
05:44:52 <augur> in that the state changes that are possible can commute
05:46:40 <augur> hmm
05:47:12 <augur> oh well. ill have to cope with it explicitly. thats ok i guess
05:48:45 <bernalex> I wrote a super simple RPN calc: http://lpaste.net/6317059159044915200 any comments before I put it on github? i.e. things that could be made *simpler*, not feature ideas, I have enough of those. but I want to conclude today's hacking on this, heh.
05:50:40 <tdammers> come to think of it, I would have used plain old sum types
05:53:35 <statusfailed> mauke: ah I see what you mean now; that particular expression would be wrong without alpha conversion. Makes sense.
05:53:49 <statusfailed> ibid: OK, that's what I'd hoped, cheers :)
05:54:00 <statusfailed> #latereplies
05:58:01 <Big_G> Any cool projects you're all working on?
05:58:56 <tdammers> Big_G: Yes.
05:59:24 <Big_G> tdammers, What would that be?
05:59:25 <tdammers> Big_G: seriously: I'm working on a CMS platform, but got side-tracked into implementing the Jinja template language in Haskell
05:59:57 <tdammers> also produced an in-memory document DB as a side product
06:00:13 <Big_G> Never heard of Jinja. What is it?
06:00:27 <Big_G> tdammers, The DB stuff sounds like a lot of fun
06:00:55 <tdammers> Big_G: jinja.pocoo.org - python template engine
06:01:01 <merijn> tdammers: Because we needed more templating engines? :p
06:01:11 <cfoch> Hello!
06:01:21 <tdammers> merijn: because I needed one that is utterly frontend-dev compatible
06:01:38 <tdammers> merijn: we have plenty of typesafe compiled template languages, and they're awesome
06:01:47 <cfoch> I would like to participate in a GSoC with Haskell.
06:01:57 <merijn> tdammers: And replacing your frontend-devs is not an option? ;)
06:02:33 <merijn> cfoch: I'm not really sure who's in charge of those atm, but presumably you'd probably want to contact either libraries@ or ghc-devs@ ?
06:02:38 <tdammers> merijn: no. The goal is to produce a CMS platform that consists of a single binary; you drop the binary on your server and point it to your "website project"
06:02:43 <cfoch> I know Haskell (I'm not an expert) because in my university I have a course in which we study Haskell.
06:02:53 <tdammers> and that website project consists of a bunch of templates, static assets, and a content database
06:03:01 <tdammers> plus some configuration files
06:03:44 <merijn> cfoch: Also, might wanna check out #hackage, probably there's plenty of hackage/cabal work for GSoC :)
06:03:59 <cfoch> I don't know exactly what should I understand by Haskell project. Is it the language itself or all the bunch of libraries of hackage?
06:04:35 <tdammers> basically, I want to provide the same level of malleability that you'd get with typical PHP or Python CMS systems, or maybe even a bit more, but without the inherent problems of having self-modifying code
06:04:37 <merijn> cfoch: I dunno if there's 2015 proposals yet, in the path projects have both been compiler hacking, infrastructure hacking or working on libraries. It depends on your interest
06:05:08 <kranius> is the paper from John Hughes on the topic of Arrows still the reference material ?
06:05:20 <tdammers> at some point, I'm envisioning a JavaScript sandbox that exposes a bunch of interfaces into the core CMS, which you can use to implement custom functionality
06:05:39 <merijn> kranius: Yeah, although Arrows have kinda fallen out of favour
06:06:28 <kranius> merijn: aww, my friend is trying to brainwash me on learning them
06:06:38 <merijn> kranius: They are not that hard
06:06:58 <merijn> kranius: The first half of the Hughes arrow paper is pretty good, the second half is a bunch of laws you can skip if you get lost
06:07:17 <merijn> kranius: But it turns out that Arrow is just Applicative + Category, both of which are more useful abstractions :)
06:08:18 <kranius> I'm still trying to figure out relationships between typeclasses, I'm a noob
06:08:37 <merijn> kranius: Have you read Typeclassopedia?
06:09:37 <kranius> merijn: I'm working on it
06:10:00 <AzureVani> why the signature of (>>=) in monad is: m a -> (a -> m b) -> m b, instead of m a -> (m a -> m b) -> m b
06:10:31 <merijn> AzureVani: If you had "m a -> m b" then what would you need ">>=" for?
06:10:33 * hackagebot clac 0.1.0 - Simple CLI RPN calculator  http://hackage.haskell.org/package/clac-0.1.0 (alexander)
06:10:37 <merijn> Then you could just directly apply it
06:10:44 <merijn> Your function is just
06:10:47 <merijn> :t flip ($)
06:10:48 <lambdabot> b -> (b -> c) -> c
06:12:02 <AzureVani> the (>>=) deal with the condition that there is not a "m a -> m b", right?
06:13:23 <cfoch> merijin: I am more interested in Hackage
06:13:55 <cfoch> But I am not really sure what do you need now and what can I do.
06:14:01 <tdammers> the deal with (>>=) is that you can have an a -> mb (i.e., a function that takes a value and gives you another value wrapped in your monad), and m a (i.e., a value wrapped in a monad), and you can string these two together without knowing anything about the internals of the monad in question
06:14:20 <tdammers> AzureVani: the deal with (>>=) is that you can have an a -> mb (i.e., a function that takes a value and gives you another value wrapped in your monad), and m a (i.e., a value wrapped in a monad), and you can string these two together without knowing anything about the internals of the monad in question
06:14:30 <cfoch> What do you recommend me? It seems there's nobody in #hackage
06:14:51 <ajcoppa> right. and without (>>=), you wouldn't have a generalized way to handle that situation
06:16:32 <AzureVani> Thanks! I think I need more practice to make a more profound understanding. :)
06:17:12 <tdammers> AzureVani: there really is less to understand that you might think
06:17:17 <lpaste> qatanah pasted “getting last of a function list” at http://lpaste.net/120324
06:17:36 <qatanah> could  someone help me?
06:17:46 <qatanah> i need to get the last of a function
06:17:57 <tdammers> it's just that there are many types for which an operation like m a -> (a -> m b) -> m b makes sense
06:17:58 <mauke> qatanah: what does that mean?
06:18:10 <qatanah> a function returns a list
06:18:16 <qatanah> then i need to get the last element of that list
06:18:26 <qatanah> and combine with another function that returns a list as well
06:18:27 <tdammers> qatanah: last . f $ items
06:18:29 <mauke> ok, and what's the problem?
06:18:30 <tdammers> something like that?
06:18:35 <mauke> tdammers: check the link
06:18:44 <tdammers> mauke: right
06:19:25 <qatanah> yes its in the link http://lpaste.net/120324
06:19:35 <mauke> qatanah: so what's the issue?
06:19:42 <qatanah> my function fibPlus
06:19:59 <qatanah> sry quite new in haskell
06:20:15 <qatanah> figuring out how to get the last elements and combine them..
06:20:25 <mauke> it's already doing that
06:20:27 <mauke> what's the problem?
06:20:57 <qatanah> seems to be not working
06:21:08 <mauke> "not working" is not a problem description
06:21:09 <dfeuer> Why?
06:21:10 <mauke> what does it do?
06:21:30 <qatanah> oh nvm
06:21:33 <qatanah> i think it is working
06:21:41 <qatanah> ok thanks
06:21:42 <Clint> good job, everybody
06:21:51 <speak> :D
06:21:58 <qatanah> :D
06:26:17 <haskellNoob> hi all.  I have a function:    f:: (b, c) -> a -> (b', c)        and another function      g ::  (b', c) -> e -> c                     I feel like this is an arrow somehow but currently lack the experience/intuition to work out the details
06:28:57 <haskellNoob> Basically f is a composition function that is composing b and a into one object and recording that this happened in c.  g is the end of the line and takes the result of the composed as and bs as well as the recording info and makes one final recording in c and then returns just the recording information.
06:31:06 <haskellNoob> I have these two functions working and they compose with each other purposely.  But now I want a function that can kick this off (I'm starting out with just b) as well as consume the final c that gets built
06:31:19 <haskellNoob> compose with each other perfectly*
06:32:21 <tdammers> haskellNoob: smells like a Writer
06:34:21 <haskellNoob> tdammers: ok.  I was thinking there might be an arrow in here, but there is an ArrowWriter I could have a look at
06:55:55 <juanpablo_> I'm planning to release a package to Hackage. I currently use Stackage and thus have no dependency version in my cabal file, should I add some before releasing to Hackage?
06:57:31 <juanpablo_> jvilla: ^^^^
06:58:23 <kadoban> juanpablo_: Seems like a good idea, yeah.
06:59:10 <lpaste> biglama pasted “Indentation error” at http://lpaste.net/120326
06:59:16 <beckyconning_> here http://en.wikipedia.org/wiki/Monad_(functional_programming)#Monad_laws it says that the third monad law is (m >>= f) >>= g   ≡   m >>= ( \x -> (f x >>= g) ) why not (m >>= f) >>= g   ≡   m >>= (f >>= g)?
06:59:28 <biglama> hi guys, can you help me with this error ?
06:59:53 <biglama> I would like to store the output of a case in a variable but GHC tells me "parse error on input ‘Left’"
07:00:36 * hackagebot pcre-heavy 0.1.0 - A regexp library on top of pcre-light you can actually use.  http://hackage.haskell.org/package/pcre-heavy-0.1.0 (myfreeweb)
07:00:38 <Yuu-chan> biglama: try moving patterns under the case block
07:00:53 <lightstep> beckyconning_: this won't type check, f is a function, not a monadic action
07:01:19 <biglama> Yuu-chan: it works ! Can you explain why ?
07:02:34 <mniip> beckyconning_, m >>= (>>= g) . f
07:03:03 <lightstep> beckyconning_: if you define the combinator >=> as in Control.Monad, the law becomes (f >=> g) >=> h ≡ f >=> (g >=> h)
07:03:06 <mniip> not sure about precedence here
07:03:20 <gregnwosu> I have a >StateT GregState IO Result< and I want to add the possibility of failure to the result, I want an Either type
07:03:34 <gregnwosu> how can i stack an either monad in?
07:03:45 <opqdonut> gregnwosu: just add EitherT (aka ErrorT)
07:03:49 <Yuu-chan> biglama: indentation rules for a block of statements
07:04:13 <opqdonut> gregnwosu: or if you don't want to complicate things you can just replace Result with Either Failure Result
07:04:27 <arjen-jo1athan> Hi, I'm looking for a reference to existing work on the higher order bounded quantification typesystem
07:04:43 <arjen-jo1athan> Anyone have readable references? ;-)
07:05:11 <beckyconning_> how can f x >>= g work if f isn't a monadic action?
07:05:18 <mniip> f x is
07:05:42 <Yuu-chan> biglama: https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
07:06:46 <biglama> Yuu-chan: right, it makes sense
07:09:04 <beckyconning_> mniip: ohhh so its like the brackets are getting in the way of the x getting to f in a sense?
07:11:39 <beckyconning_> like: m (>>= f >>= g) doesn't express the law    and: m >>= (f >>= g) doesn't type check    so it has to be: m >>= (\ x -> (f x >>= g))
07:11:59 <beckyconning_> is that right?
07:13:39 <mniip> beckyconning_, m >>= ((>>= g) . f)
07:14:26 <osa1> any ideas why GHC can't derive Show and Eq instances for data types with constructors with unboxed tuples?
07:14:36 <kadoban> beckyconning_: I believe there's an alternate way to view the laws in terms of <=< or >=> or whatever it is that I found /far/ more understandable, if that helps. IIRC it's at least mentioned in typeclassopedia
07:19:15 <beckyconning_> mniip: is what i said right though?
07:19:25 <lightstep> yes, it's exactly right
07:19:37 <mniip> more or less
07:19:43 <beckyconning_> thanks : )
07:20:40 <xplat> f >=> (g >=> h) = (f >=> g) >=> h ; f >=> return = return >=> f = f
07:20:45 <Yuu-chan> Is it possible to implement a python-like arbitrary comparing (like 5 < b < c < 10) via some kind of type magic? I tried some approaches, but haven't succeed :(
07:21:44 <benzrf> xplat: category laws!!!
07:21:52 <benzrf> Yuu-chan: that would be pretty bad
07:22:33 <Ring0`> Is there some built-in way to sort list of 2-tuples by both of their values at the same time? say I have (2,"a"), (3,"a"), (2,"b") and I want to sort them by number first and if tie, then alphabetically
07:22:51 <xplat> benzrf: only in that you couldn't compare booleans
07:24:12 <lightstep> Ring0`: the "right way" is to define your own pair type and derive Ord. otherwise, you can define an Ord instance for Ord a, Ord b => Ord (a, b)
07:24:15 <merijn> Ring0`: That's the way tuples are sorted
07:24:24 <merijn> lightstep: There is already an ord instance
07:24:40 <lightstep> oh, i wasn't aware :p
07:24:44 <merijn> > sort [(3,"a"), (2,"a"), (2,"b")]
07:24:46 <lambdabot>  [(2,"a"),(2,"b"),(3,"a")]
07:25:00 <Yuu-chan> benzrf: why? At least it can be taken as an exercise.
07:25:30 <gregnwosu> opqdonut: thanks
07:26:51 <xplat> Yuu-chan: sometimes i actually wish there was some kind of 'chaining' associativity or something that allowed for stuff like that, it is very convenient when you actually have a chain like that
07:26:59 <beckyconning_> Yuu-chan: maybe something like sort [5, b, c, 10] == [5, b, c, 10] would be easier?
07:27:23 <xplat> beckyconning_: i thought of that, doesn't support strict comparisons though
07:29:52 <beckyconning_> xplat: ?
07:29:53 <Yuu-chan> beckyconning_: of course simple && would be easier. Then I wondered if Haskell type system is flexible and extensible enough to implement a syntax-like feature.
07:30:08 <beckyconning_> Yuu-chan: ah : ) ok
07:30:10 <merijn> Yuu-chan: Nothing to do with type system
07:30:21 <merijn> Yuu-chan: You could implement it as q QuasiQuoter, though
07:31:11 <Yuu-chan> merijn: I guess it could be implemented with some grain of dynamic/subtyping/implicit casting
07:33:04 <Yuu-chan> Something like data Ord a => PartialOrd a, (<) :: PartialOrd a -> a -> PartialOrd a with implicits a -> PartialOrd a and PartialOrd a -> Bool
07:35:29 <mightybyte> Is there a name for the abstraction similar to semigroup, but with the function (foo :: a -> a -> Maybe a)?
07:36:09 <xplat> > sort [5,5,10,10] == [5,5,10,10]
07:36:10 <lambdabot>  True
07:36:12 <xplat> beckyconning_: ^
07:37:05 <beckyconning_> ah yeah i guess if you wanted to do it this way you could check that its not the same too? i dunno lol! i'm just making stuff up : P
07:37:25 <Yuu-chan> mightybyte: if foo is Just-associative, then it looks like a partial ordering
07:37:27 <beckyconning_> thanks though : )
07:38:59 <mightybyte> Yuu-chan: Interesting.  I suppose maybe I could generalize that signature to (a -> a -> f a)
07:39:54 <xplat> mightybyte: http://ncatlab.org/nlab/show/paracategory seems related
07:40:03 <benzrf> hmmm idea
07:40:10 <xplat> particularly the 'precategory' variant
07:40:29 <Yuu-chan> mightybyte: er, I'm wrong. In ordering it would be restricted to a -> a -> Maybe Bool
07:40:51 <mightybyte> Yuu-chan: Ahh, ok.
07:40:57 <xplat> mightybyte: also, (a -> a -> Set a) has a real name, at least, though i forget what it is
07:41:53 <benzrf> @let data Comp a = Comp a Bool a
07:41:56 <lambdabot>  Defined.
07:42:09 <benzrf> er... wait
07:43:03 <Yuu-chan> Still, is it possible to overload (<) in both first argument and return types, and restrict them enough to make the large chain of a < b < c inambiguous?
07:43:13 <benzrf> Yuu-chan: im doing something like that right now O3o
07:44:30 * Yuu-chan holds her breath
07:45:10 <benzrf> @let class Chained a where (<=~) :: a -> b -> Comp
07:45:11 <lambdabot>  .L.hs:177:28:
07:45:11 <lambdabot>      Expecting one more argument to ‘Comp’
07:45:11 <lambdabot>      Expected a type, but ‘Comp’ has kind ‘* -> *’
07:45:14 <benzrf> uhh
07:45:31 <benzrf> @let class Chained a b where (<=~) :: a -> b -> Comp a
07:45:33 <lambdabot>  Defined.
07:45:36 <benzrf> ok i got tihs
07:47:27 <benzrf> @let instance Ord a => Chained a (Comp a) where x <=~ Comp l b r = Comp x (b && x <= l) r;
07:47:28 <lambdabot>  Defined.
07:47:43 <benzrf> @let instance Ord a => Chained a a where x <=~ y = Comp x (x <= y) y;
07:47:45 <lambdabot>  Defined.
07:47:48 <benzrf> ok!
07:47:59 <benzrf> @let deriving instance Show a => Show (Comp a)
07:48:01 <lambdabot>  Defined.
07:48:35 <benzrf> @let instance Ord a => Chained (Comp a) a where Comp l b r <=~ y = Comp l (b && r <= y) y;
07:48:36 <lambdabot>  .L.hs:188:33:
07:48:36 <lambdabot>      Could not deduce (a ~ Comp a)
07:48:36 <lambdabot>      from the context (Ord a)
07:49:01 <benzrf> er nvm
07:49:07 <benzrf> > 3 <=~ 4 <=~ 5
07:49:09 <lambdabot>  Could not deduce (L.Chained (L.Comp a) b0)
07:49:09 <lambdabot>    arising from the ambiguity check for ‘e_1345’
07:49:09 <lambdabot>  from the context (L.Chained (L.Comp a) b,
07:49:11 <benzrf> x_x
07:49:15 <benzrf> sorry i sholdve done this in ghci
07:53:50 <jp_rider> hello
07:53:58 <jp_rider> I'm using System.Process to execute a new process. Is there any way to set the uid of the new process?
07:55:39 * hackagebot y0l0bot 0.1.0 - #plaimi's all-encompassing bot  http://hackage.haskell.org/package/y0l0bot-0.1.0 (alexander)
07:56:06 <jackhill> How do <$> and fmap differ?
07:56:23 <Clint> fixity
07:56:33 <haasn> One is an operator and the other is not
07:56:39 <Yuu-chan> <$> is from Applicative, fmap is from Functor
07:56:48 <jackhill> ah! Thanks!
07:57:01 <haasn> Yuu-chan: They have the same type
07:57:11 <merijn> Yuu-chan: No, <$> is Functor
07:57:27 <Clint> @src (<$>)
07:57:27 <lambdabot> f <$> a = fmap f a
07:57:28 <merijn> <$> is literally just infix fmap, although the symbol was chosen to fit well with <*>
07:57:38 <merijn> Clint: @src is filled with lies and deceit
07:57:39 <haasn> liftA is the Applicative version of fmap
07:57:51 <Clint> merijn: i know
07:58:07 <myfreeweb> but it's "from" Applicative as in the module Control.Applicative
07:58:09 <Yuu-chan> Sorry, my bad.
07:58:42 <Yuu-chan> Hoogle says <$> is currently defined in Data.Functor as well
07:58:49 <phadej> 7.10 will change everything
07:58:56 <phadej> ... related
07:59:04 <haasn> A lot of things re-export a lot of things
07:59:32 <benzrf> guh
07:59:33 <tdammers> 7.10 will have unicorns in Prelude
07:59:33 <benzrf> @undef
07:59:34 <lambdabot> Undefined.
07:59:45 <phadej> Yuu-chan: <$> is in Data.Functor but not in Prelude
08:00:13 <myfreeweb> jp_rider: System.Process doesn't do that :( You can use System.Posix.Process and System.Posix.User
08:00:24 <phadej> so something you have to import to get it into a scope
08:00:30 <jackhill> win 22
08:01:06 <myfreeweb> phadej: but it's in classy-prelude, so I don't have to always import it :D
08:01:23 <Yuu-chan> @hoogle getProcessID
08:01:25 <lambdabot> System.Posix.Process.ByteString getProcessID :: IO ProcessID
08:01:25 <lambdabot> System.Posix.Process getProcessID :: IO ProcessID
08:02:37 <phadej> myfreeweb: I pollute my scope with Control.Lens to get all the nice operators
08:02:54 <tdammers> Control.Lens is the systemd of Haskell programming
08:03:04 <tdammers> sorry, no, that was rude
08:03:14 <merijn> Pretty sure Control.Lens is more principled and theoretically sound :p
08:03:22 <bennofs> and it actually works :)
08:03:26 <myfreeweb> phadej: I've used lens once, for aeson...
08:03:41 <jp_rider> alright thanks
08:03:46 <tdammers> yes, that's why I said it was rude to say that
08:04:03 <tdammers> btw., lots of people consider "principled" a bad thing
08:04:06 <edwardk> tdammers: rude perhaps but reasonably accurate
08:04:15 <edwardk> it has the same sort of polarizing effects
08:04:20 <edwardk> folks either love it or hate it
08:04:28 <edwardk> and it doesn't try to fit overmuch into existing patterns
08:04:52 <jp_rider> could you direct me to the module where i can read from stdout given a processid?
08:04:59 <tdammers> yeah, but I was hinting more at how it claims a lot of stuff for itself
08:06:16 <xplat> @tell mightybyte apparently at least some people call the structure you first asked about a 'partial semigroup'
08:06:16 <lambdabot> Consider it noted.
08:06:19 <myfreeweb> jp_rider: I'm pretty sure that's not how unix works... Reading from arbitrary processes' stdouts would be a security disaster
08:06:26 <myfreeweb> jp_rider: you need to create a pipe
08:06:31 <benzrf> gah
08:07:37 <benzrf> is there any form of typeclass abuse that allows, e.g., "instance Bluh Maybe where f (Just x) = Just x; instance Bluh a where f x = Just x"
08:07:41 <benzrf> terrible as it is
08:07:52 <myfreeweb> @hoogle createPipe
08:07:53 <jp_rider> right..
08:07:53 <lambdabot> System.Posix.IO.ByteString createPipe :: IO (Fd, Fd)
08:07:53 <lambdabot> System.Posix.IO createPipe :: IO (Fd, Fd)
08:07:53 <lambdabot> System.Process CreatePipe :: StdStream
08:11:06 <jp_rider> Is it safe to use a pipe in forkProcess?
08:11:15 <jp_rider> from the docs:
08:11:16 <jp_rider> http://hackage.haskell.org/package/unix-2.7.1.0/docs/System-Posix-Process.html#v:forkProcess comes with a giant warning: since any other running threads are not copied into the child process, it's easy to go wrong: e.g. by accessing some shared resource that was held by another thread in the parent.
08:11:46 <Yuu-chan> benzrf: class Bluh a :: (* -> *)?
08:11:48 <myfreeweb> you create a pipe before forking
08:12:08 <benzrf> Yuu-chan: hrk
08:12:11 <benzrf> Yuu-chan: nvm
08:12:23 <myfreeweb> then dupTo to replace the stdin/stdout/stderr after forking, before execing in the fork
08:13:36 <jp_rider> alright cool
08:13:51 <jp_rider> that makes sense, ill try it
08:13:53 <jp_rider> thanks!
08:16:34 <lightstep> Yuu-chan: regarding what you said earlier, about pythonesque chaining of operators, it is possible. i made an example (monomorphic tho): http://lpaste.net/120334
08:18:01 <sveit> it seems (like with many things in haskell) there is an embarassment of riches with respect to priority queues. What is a good "default"? (i.e. like some would say Data.Vector is a good default)
08:19:19 <Yuu-chan> lightstep: I thought about Num'ing chains too, but this approach disallows using variables, only literals
08:20:06 <Yuu-chan> lightstep: I mean, it seems to be impossible to write a = 5 :: Int; foo = 2 < a < 6
08:20:39 <lightstep> the problem i ran into when not Num'ing the chains was that there were several correct typings for the program, an ghc couldn't decide between them. perhaps there is a flag to let it do so.
08:21:45 <lightstep> that is, make (<) :: (C a b c) => a -> b -> c, with C Int T Bool, C T T Bool, C Int Int T, and so on
08:23:42 <benzrf> lightstep: 2late
08:24:22 <Yuu-chan> lightstep: we can treat (<) as linear and left-associative, and allow only (((a < b) < c) < d) chains, maybe it will help to solve some disambiguities
08:25:41 <chpatrick> sveit: I like PSQueue
08:26:15 <benzrf> > 3 <=~ 4 <=~ 5
08:26:17 <lambdabot>  Couldn't match expected type ‘a2 -> a0’
08:26:17 <lambdabot>              with actual type ‘L.Comp GHC.Types.Bool’Couldn't match expected ...
08:26:17 <lambdabot>              with actual type ‘L.Comp GHC.Types.Bool’
08:26:20 <benzrf> frick
08:32:09 <lightstep> it can be done with an extra conversion at the end: http://lpaste.net/120334
08:37:41 <xplat> @tell mightybyte see http://planetmath.org/hypergroup for the other one
08:37:41 <lambdabot> Consider it noted.
08:46:24 <saml> what kind of RESTful API would a type system have?  Is there type system where application programmers can use while writing her application ?
08:46:35 <sdegutis> Are Elm's signals just like Haskell's state monads?
08:46:54 <saml> https://github.com/elm-lang/elm-compiler/issues/413
08:47:06 <saml> signals are clearly applicative functors
08:47:17 <saml> some functors are monads
08:47:48 <sdegutis> oh
08:48:02 <benzrf> ok this should work....
08:48:04 <benzrf> > 3 <=~ 4 <=~ 5
08:48:07 <lambdabot>  Could not deduce (L.AsComp a0 a1)
08:48:07 <lambdabot>    arising from the ambiguity check for ‘e_1345’
08:48:07 <lambdabot>  from the context (L.AsComp a a1,
08:48:09 <benzrf> gaah
08:48:31 <saml> > 3 <= 4 && 4 <= 5
08:48:32 <lambdabot>  True
08:49:18 <sdegutis> I think I like Elm more than Haskell.
08:49:22 <benzrf> oh frick
08:49:26 <sdegutis> It fixed the record field problem!
08:49:32 <saml> not sure  why 3 <= 4 <= 5 is parser error  but  3 + 4 + 5 is not
08:49:33 <sdegutis> Also it's got a usable UI.
08:49:47 <mniip> saml, because <= has no fixity
08:49:53 <mniip> rather
08:49:56 <mniip> no associativity
08:50:39 <saml> oh right
08:50:44 <TallerGhostWalt> pattern synonyms are so cool
08:51:57 <benzrf> > ((3 :: Int) <=~ (4 :: Int) <=~ (5 :: Int)) :: Comp Int
08:51:59 <lambdabot>  Comp 3 True 5
08:52:01 <benzrf> =D
08:52:32 <benzrf> > "foo" >=~ "bar" >=~ "aaa"
08:52:34 <lambdabot>  Comp "aaa" True "foo"
08:52:41 <benzrf> > "foo" >=~ "bar" <=~ "zz"
08:52:43 <lambdabot>  Comp "bar" True "zz"
08:52:49 <benzrf> > "foo" >=~ "bar" <=~ "apple"
08:52:51 <lambdabot>  Comp "bar" False "apple"
08:52:58 <benzrf> it works as long as your argument types are concrete :)
08:53:05 <benzrf> shity code http://lpaste.net/120337
08:53:07 <saml> @src >=~
08:53:07 <lambdabot> Source not found. My brain just exploded
08:53:19 <joelneely> @pl \s -> '[' : (intercalate "][" $ splitOn "," s) ++ "]"
08:53:20 <lambdabot> ('[' :) . (++ "]") . intercalate "][" . splitOn ","
08:53:33 <benzrf> joelneely: gross
08:54:18 <joelneely> benzrf: open to suggestion (visualizing CSV data)
08:55:25 <mniip> hmm
08:55:52 <mniip> SKI calulus is lame, I propose JFIC calculus \o/
08:56:06 <mniip> (join, flip, id, (.))
09:02:26 <joelneely> @pl \c -> c == '\r' || c == '\n'
09:02:26 <lambdabot> liftM2 (||) ('\r' ==) ('\n' ==)
09:02:39 <benzrf> mniip: is that turing complete
09:02:51 <mniip> should be
09:03:02 <mniip> I mean I can represent S and K with just those
09:03:20 <mniip> wait
09:03:21 <mniip> what
09:03:53 <mniip> yeah I can't represent K
09:04:04 <mniip> sad
09:04:32 <mniip> but yeah, speaking of pointfree haskell (join, flip, id, (.), const) make much more sense than S and K
09:04:57 <Yuu-chan> benzrf: there is «Down for maintenance!» in your link :(
09:05:38 <mniip> benzrf, I wonder if kolmogorov complexity in SK-representation of lambdas is unsolved problem
09:06:08 <mniip> because thre's an algorithm that lets you turn any lambda into SK but it produces terribly huge results, and you can derive much better stuff by hand
09:06:28 <pchiusano> is there a way to inspect the code generated by TH?
09:06:42 <dutchie> -ddump-splices iirc
09:06:43 <mniip> pchiusano, one of the -ddump- options iirc
09:07:06 <pchiusano> where do I put that?
09:07:08 <mniip> yep
09:07:09 <mniip> splices
09:07:13 <mniip> pchiusano, on the command line
09:07:22 <pchiusano> on the command line?
09:07:27 <pchiusano> i am building via cabal
09:07:34 <mniip> uhoh
09:07:59 <dutchie> --ghc-options=-ddump-splices
09:08:00 <dutchie> then
09:08:34 <hexagoxel> (when configuring/installing)
09:09:13 <pchiusano> dutchie: ok cool trying that now
09:10:04 <pchiusano> dutchie: that worked, but is there a way to restrict it to just one module?
09:10:19 <pchiusano> it is dumping all TH for my entire program… a lot of stuff
09:11:06 <dutchie> not sure i'm afraid, maybe someone else knows
09:12:02 <pchiusano> ok no prob
09:12:56 <jtanguy> instead of passing it globally via cabal, you can put it inside a pragma in the said file
09:14:10 <mniip> pchiusano,
09:14:13 <jtanguy> {-# OPTIONS_GHC -ddump-splices #-}
09:14:15 <mniip> {-# OPTIONS_GHC -ddump-splices #-}
09:14:22 <mniip> aw no you didnt
09:15:06 <sdegutis> Is (&) equal to (flip ($))?
09:15:33 <mniip> (flip id) huehue
09:15:46 * hackagebot aeson-schema 0.3.0.0 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.3.0.0 (TimBaumann)
09:16:05 <quchen> ?seen tekmo
09:16:06 <lambdabot> +EKm0
09:16:21 <pchiusano> mniip and jtanguy that does not seem to work
09:16:24 <Kaidelong> @hoogle (&)
09:16:24 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
09:16:24 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
09:16:24 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
09:16:42 <pchiusano> on a per module basis
09:19:07 <jtanguy> pchiusano: did that had a global effect ?
09:20:13 <Yuu-chan> benzrf: nice approach, but it's still impossible to use Comp a as Bool :(
09:21:23 <pchiusano> jtanguy: actually, nm, i am an idiot, put the directive at top of wrong file :)
09:24:27 <bitemyapp> pchiusano: ah good to see you on the other side of the picket line :)
09:28:51 <benzrf> Yuu-chan: simple extraction functoin
09:29:15 <benzrf> @let chain (Comp _ b _) = b
09:29:17 <lambdabot>  Defined.
09:29:29 <benzrf> > chain (3 <=~ 4 >=~ 1)
09:29:31 <lambdabot>  No instance for (GHC.Num.Num a1) arising from the literal ‘3’
09:29:31 <lambdabot>  The type variable ‘a1’ is ambiguous
09:29:31 <lambdabot>  Note: there are several potential instances:
09:29:33 <benzrf> ach
09:29:35 <cschneid> sdegutis: I've seen it defined like that, but not globally. I think lens in particular does define that.
09:29:46 <benzrf> > chain ('a' <=~ 'd' >=~ 'c')
09:29:47 <lambdabot>  False
09:29:55 <benzrf> hmm.. wha?
09:30:14 <benzrf> > 'a' <= 'd' && 'd' >= 'c'
09:30:14 <sdegutis> ok
09:30:15 <lambdabot>  True
09:30:22 <benzrf> ._.
09:31:03 <benzrf> > 'd' >=~ 'c'
09:31:05 <lambdabot>  Comp 'c' True 'd'
09:31:20 <benzrf> > 'a' <=~ (Comp 'c' True 'd')
09:31:22 <lambdabot>  Comp 'a' True 'd'
09:31:26 <benzrf> wat
09:31:36 <benzrf> > 'a' <=~ 'd' >=~ 'c'
09:31:38 <lambdabot>  Comp 'c' False 'd'
09:31:50 <benzrf> ooooohhhhhhhhhhhh
09:33:54 <benzrf> @undef
09:33:55 <lambdabot> Undefined.
09:33:59 <benzrf> @letlpaste 120337
09:34:01 <lambdabot>  Defined.
09:34:07 <benzrf> > 'a' <=~ 'd' >=~ 'c'
09:34:08 <lambdabot>  Could not deduce (L.AsComp a10 a20) arising from a use of ‘L.<=~’
09:34:08 <lambdabot>  from the context (L.AsComp a1 a2,
09:34:08 <lambdabot>                    L.AsComp a a2,
09:34:16 <benzrf> n-never mind
09:34:34 <beckyconning_> benzrf you can /msg lambdabot
09:34:41 <benzrf> i know
09:34:43 <benzrf> im doing that now
09:34:49 <beckyconning_> ah thanks : ))
09:34:52 <benzrf> i have a terrible habit of starting  in channel and not bothering to move
09:34:59 <beckyconning_> hehe
09:36:40 <timmy_tofu> Does anyone know how to pass ghc options to the ghc-mod run via syntastic in vim? It seems to be separate from the ghc-mod_vim plugin, and when I've added a --ghcOpt= to the builder it doesn't have any effect
09:37:13 <benzrf> > chain ('a' <=~ 'c' >=~ 'b')
09:37:15 <lambdabot>  True
09:37:18 <benzrf> THERE we go =)
09:39:00 <timmy_tofu> nm, I was missing a space
09:43:38 <benzrf>                     
09:43:38 <benzrf>                     
09:43:42 <benzrf> soz
09:49:01 <Yuu-chan> benzrf: thank you
09:49:01 <timmy_tofu> Is there a way to make syntastic use ghc-mod_vim, rather than it's own ghc-mod-calling structure?
09:55:49 * hackagebot dbus-th 0.1.1.1 - TemplateHaskell generator of DBus bindings  http://hackage.haskell.org/package/dbus-th-0.1.1.1 (IlyaPortnov)
10:05:00 <KaneTW> when using conduits, can you have your source yield forever in one thread while the rest of the conduit is in another
10:06:42 <KaneTW> i found https://hackage.haskell.org/package/stm-conduit
10:29:46 <NightRa> I'm still not able to install the hscurses library.
10:29:56 <NightRa> This is really a show stopper for me.
10:30:02 <NightRa> So I beg your help: https://github.com/skogsbaer/hscurses/issues/22
10:32:06 <geekosaur> the dll and lib likely have the wrong name, but how wrong it is depends on the build system and I'm insufficiently windows-savvy
10:33:11 <geekosaur> at the very least those names would require -lpdcurses. but I don't know if simply renaming the dll/lib (presumably to curses.dll etc. but depends on build system) would be enough
10:35:13 <geekosaur> also the different names make me suspect there may be deeper incompatibilities in whatever pdcurses you installed
10:35:53 <geekosaur> but /o\ don't know enough about windows, msys, etc.
10:36:46 <geekosaur> (also, the configure problem indicates that the configure script only works in a recent-ish bash)
10:37:48 <Ainieco> hello, is conduit still relevant or there is a newer thing(like conduits were to iteratee, etc)
10:38:08 <Ainieco> kinda out of date on that topic
10:38:57 <geekosaur> pipes seems to be the current hotness
10:39:17 <chpatrick> that hasn't really been decided yet though right?
10:39:23 <geekosaur> right
10:39:27 <geekosaur> "seems to be"
10:39:32 <chpatrick> I keep hearing pipes is more elegant from some theoretical aspect
10:39:36 <chpatrick> do you know what it is?
10:39:42 <geekosaur> not really, no
10:39:55 <chpatrick> I really love conduit tbh
10:40:02 <Ainieco> geekosaur: cool, thanks for update, gonna check that out
10:40:20 <chpatrick> it's great for sheer it just works factor
10:40:33 <chpatrick> and conduit-combinators has everything
10:40:40 <sinelaw> chpatrick, http://www.haskellcast.com/episode/006-gabriel-gonzalez-and-michael-snoyman-on-pipes-and-conduit
10:40:59 <sinelaw> chpatrick, the authors of both pipes and conduit discuss the differences and similarities between them
10:41:16 <chpatrick> thanks
10:41:32 <sinelaw> makes a nice listen on your commute
10:41:51 <sinelaw> if you have one
10:42:07 <chpatrick> it's on a bike :)
10:42:56 <bennofs> chpatrick: pipes have in some ways less things "out of the box" AFAIK. pipes don't support leftovers (for that you need pipes-parse), etc
10:50:18 <NightRa> geekosaur: It's said on the README of the hscurses repo that they specifically support pdcurses
10:51:39 <geekosaur> NightRa, "pdcurses" is a discrete thing the same way "linux" or "windows" is a discrete thing. what version? what distribution/packaging?
10:52:08 <elzair> Is there a good way to create a collection of heterogenous types sharing a typeclass?
10:52:27 <elzair> *heterogeneous
10:52:39 <geekosaur> this one distributes libraries that have the wrong name. look for a different windows pdcurses distribution
10:53:21 <NightRa> geekosaur: Well, I used the pdcurses version that they referenced on the readme. I think I'm just not exposing it correctly to cabal
10:54:02 <geekosaur> NightRa, the *file names* are wrong. adjusting cabal paths will not help
10:54:34 <geekosaur> if it's looking for <something>\curses.lib then no change to <something> will make it find <something>\pdcurses.lib
10:55:58 <NightRa> Well, I assumed that it searched for pdcurses too from this line in the log: "checking for addnstr in -lpdcurses... no"
10:56:10 <geekosaur> since it's going to stick a \ on the end of the name it's looking for (--extra-lib-dirs=foo\pd gets you foo\pd\...)
10:56:54 <Ally> can someone please help me understand folds? :)
10:58:02 <sinelaw> Ally, what don't you understand?
10:58:30 <Ally> I'm looking at the definition and am unsure how to interpret it
10:58:31 <Ally> "folding a function over a list means recursively calling it with its previous return (or a given initial value) along with the next element in the list. A good example is sum, which can be expressed as: fold (+) 0 list"
10:58:51 <Ally> I'm trying to follow the logic of what haskell is doing with a fold
10:59:06 <elzair> :t fold
10:59:07 <lambdabot> (Monoid m, Foldable t) => t m -> m
10:59:20 <geekosaur> > foldr (+) 0 [a,b,c,d]
10:59:22 <lambdabot>  a + (b + (c + (d + 0)))
10:59:35 <Ally> ohgod I already love lambdabot
10:59:41 <elzair> First, look at the type sigature of the function you want to examine
10:59:42 <lightstep> elzair: there is an example in http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types . is that what you're looking for?
11:00:02 <cmtptr> why is there a 0 on the end of that?
11:00:03 <geekosaur> each "step" of the fold is given the result of the previous step plus the next item in the list
11:00:20 <geekosaur> since the first step needs something else to apply to, you have an initial value (here 0)
11:00:37 <Ally> oh
11:00:44 <Ally> that kinda makes sense
11:00:48 <geekosaur> because the first step is (? + a), there not being a previous step to use the result of
11:01:06 <geekosaur> so we specify an initial value
11:01:17 <cmtptr> oh, the 0 was the initial value.  right
11:01:47 <Ally> okay
11:01:49 <Ally> that makes sense
11:01:52 <Ally> thank you, geekosaur :D
11:02:05 <geekosaur> right, foldr, so d instead of a for the initial value, whoops :)
11:02:23 <Ally> foldl and foldr? like foldleft and foldright?
11:02:49 <geekosaur> yes
11:03:01 <geekosaur> > foldl (+) 0 [a,b,c,d]
11:03:02 <lambdabot>  0 + a + b + c + d
11:04:01 <mmachenry> Ally, some languages use reduce for the name fold and have the initial or base case as an optional argument. The value used in that case is the first or last element of the list depending on the direction you're folding.
11:04:22 <Ally> > foldr (+) 0 [a,b,c,d]
11:04:24 <lambdabot>  a + (b + (c + (d + 0)))
11:04:27 <Ally> ooo
11:04:33 <Ally> magic
11:04:41 <Ally> I see!
11:05:09 <monochrom> it is like a:(b:(c:(d:[]))) and replace the : and the []
11:05:28 <monochrom> a:(b:(c:(d:[]))) is the real imagine of [a,b,c,d]
11:05:40 <Ally> right, yeah
11:05:43 <geekosaur> btw that lambdabot trick you can also do in ghci locally; install the simple-reflect package
11:05:52 <geekosaur> and import it
11:05:55 <Ally> which trick? :o
11:06:20 <geekosaur> where it's treating a,b,c,d as names and showing the expansion, instead of doing the calculation as it normally wou;d
11:07:05 <geekosaur> > foldr (+) 0 [1..4]
11:07:06 <lambdabot>  10
11:07:20 <Ally> oh!
11:07:27 <Ally> that is cool :D
11:07:54 <Ally> > foldl (+) 0 [1..4]
11:07:56 <lambdabot>  10
11:08:02 <Ally> > foldl (*) 0 [1..4]
11:08:04 <lambdabot>  0
11:08:11 <Ally> hah
11:08:35 <cmtptr> probably should start at 1 for that one
11:11:29 <sinelaw> Ally, a nice way to look at " foldr f i " is that it replaces the constructor of whatever you're folding, with applications of f, and replaces the 'base value' with the given i . So in the case of a list, the constructor is (:), e.g. 1:(2:(3:[])) - with foldr "+" 0 on that you replace (:) with (+) , and replace the empty list [] with 0, and get 1+(2+(3+0))
11:13:23 <Ally> thanks, sinelaw! :)
11:13:27 <sinelaw> Ally,  and more generally, you can fold over any data structure by replacing the appropriate data constructor with the given function, and the "base empty value" with the given value
11:13:33 <sinelaw> not just lists
11:14:05 <sinelaw> trees, sets, maps, etc.
11:14:30 <sinelaw> it's called a Catamorphism
11:14:54 <shachaf> Or sometimes it's just called a fold.
11:15:10 <jackhill> sinelaw: is there a similar mental model to be used with foldl?
11:15:12 <Ally> fancy :D
11:17:11 <sinelaw> shachaf, :)
11:17:27 <sinelaw> jackhill, IIRC the only difference is the order of operations
11:17:49 <shachaf> foldl isn't something that can be generalized to any structure the way foldr can.
11:18:00 <jackhill> ah, thanks!
11:19:02 <sinelaw> shachaf, why?
11:20:26 <shachaf> You're the one who was just talking about "catamorphism". foldr is structural.
11:21:38 <Ally> thank you guys! :D
11:23:45 <hannes__> Is there a way for ghci to give me the minimal complete definitions of a class?
11:23:55 <przemek_> hello, I have a question: https://gist.github.com/CGenie/a5ff3ad7e9288c0b04e6
11:24:12 <przemek_> this throws 'No instance for (Zeroable a0) arising from a use of zero
11:24:12 <przemek_> ' -- what does it mean?
11:24:49 <przemek_> I mean in the data System declaration things is to be an array of Zeroable things so mapping with the zero funciton over them should be OK?
11:24:54 <lightstep> it seems to me that foldl is some sort of traversal, either pre-order or in-order, so it can be defined for other things than lists. but it would just factor throught a traversal function
11:25:24 <mauke> przemek_: it doesn't know which Zeroable instance to use because the type isn't known
11:25:33 <hannes__> przemek_: It's an array of 'something' that is zeroable. It can't figure out what that is.
11:25:40 <albeit> Is there a cleaner way to write this? "when (isNothing foo || f (fromJust foo) ..."
11:25:58 <hannes__> *using the term array here even though its a list
11:26:47 <geekosaur> when (maybe False f foo) ?
11:26:54 <hannes__> albeit: I don't know what that's supposed to be. Possibly maybe
11:27:07 <przemek_> hmm.. so is there a way around that? how can this be fixed?
11:27:11 <hannes__> @hoogle (a->Bool) -> Maybe a -> Bool
11:27:13 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
11:27:14 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
11:27:14 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
11:27:16 <geekosaur> whoops, that False should be True
11:27:20 <albeit> geekosaur: AH maybe is perfect, thanks
11:27:20 <mauke> przemek_: the System type makes no sense anyway. what are you trying to do?
11:27:25 <shachaf> przemek_: The question about your code should be, where does the type a come from?
11:27:40 <przemek_> well, it's a simplified example
11:27:46 <shachaf> You wrote data System = System (Zeroable a => [a])
11:27:51 <przemek_> thing is Zeroable in my case is Renderable
11:27:53 <shachaf> What is a?
11:28:02 <mauke> przemek_: that makes no difference
11:28:04 <przemek_> I want to produce rendered elements of things
11:28:16 <mauke> System can only store empty lists, I think
11:28:28 <przemek_> hm, ok, well, is there a way to fix this?
11:28:35 <mauke> fix what?
11:28:35 <hannes__> przemek_: data Renderable :: { render :: IO () }
11:28:39 <shachaf> I'm surprised GHC even accepts that.
11:28:50 <mauke> you haven't told me what you're trying to do
11:29:11 <shachaf> I guess it puts in an implicit forall, so it becomes data System = System (forall a. Zeroable a => a)
11:29:24 <przemek_> I have a list of elements of various types but all being instance of Renderable, and I want to render them all
11:29:31 <hannes__> przemek_: If you want a list of things that can be rendered
11:29:43 <hannes__> przemek_: Why not just keep a list of render functions instead
11:29:44 <shachaf> I hope that behavior isn't documented anywhere, because it seems like a bug. :-(
11:30:01 <hannes__> przemek_: They're semantically equivalent regarding how you can reason about them
11:30:03 <shachaf> data T = T a -- Not in scope: type variable ‘a’
11:30:16 <shachaf> data T = T (Show a => a) -- works fine
11:30:55 <mauke> "I have a list of elements of various types" <- I don't think so. lists are homogenous
11:31:07 <przemek_> mauke, yeah, I thought this now
11:31:47 <hannes__> mauke: You can actually write heterogenous lists like that. It's just hacky and pretty much completely useless.
11:31:56 <przemek_> is there a way to make something like a list of elements having the same class? I guess hannes__ solution is quite good -- a list of functions of type (Zeroable a) => a -> Int would be good
11:32:17 <mauke> przemek_: that's equivalent to [Int]
11:32:20 <hannes__> przemek_: In your example
11:32:27 <hannes__> przemek_: Why not just have a list of ints
11:33:31 <przemek_> hmm, yeah, I think I know how to do it now
11:40:40 <hannes__> @hoogle Int -> (a -> a) -> a -> a
11:40:41 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
11:40:41 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
11:40:41 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
11:45:56 * hackagebot transformers-base 0.4.4 - Lift computations from the bottom of a transformer stack  http://hackage.haskell.org/package/transformers-base-0.4.4 (MikhailVorozhtsov)
11:54:38 <EvanR> i dont supposed its possible to do this? class Foo a where bar :: Int
11:55:18 <mauke> bar :: (Foo a) => Int  -- invalid type signature
11:55:50 <mauke> bar would be a plain Int, with no way to deduce the correct a
11:56:07 <EvanR> i was trying to trick my phantom types into having values associated with them
11:56:37 <EvanR> i guess that makes no sense
11:58:05 <mauke> that works, you'd just have to change it to bar :: a -> Int
11:58:08 <EvanR> ill try making it a -> Int and then using undefined with scoped type variables
11:58:12 <mauke> or bar :: proxy a -> Int
11:58:26 <EvanR> oh Proxy a
12:00:06 <rjayatilleka> Is there a way to use a different function if a certain constraint holds? Such as a function 'foo :: a -> Int', but does different things if '(Eq a)' holds?
12:00:13 <rjayatilleka> For optimization purposes.
12:00:32 <mauke> that would be unsound
12:00:40 <MonrealRyan> Hi everyone, can i ask if map is the same as loop?
12:00:49 <orzo> rjayatilleka: you can make Eq passed at runtime and then do cases
12:01:02 <mauke> MonrealRyan: yes, you can ask
12:01:07 <rjayatilleka> mauke: What do you mean by unsound?
12:01:36 <mauke> rjayatilleka: I have the feeling that would let you break type safety somewhere
12:01:41 <MonrealRyan> mauke: does map function is the same as loop?
12:01:58 <mauke> MonrealRyan: that depends on what you mean by "same as" and "loop"
12:02:06 <Hugehead> Map applys a function to every element in a list, which is one thing you could use a loop for
12:02:19 <Hugehead> But it doesn't cover every use case of a loop
12:02:27 <Hugehead> We have other functions for those
12:02:32 <monochrom> a function of type "a -> Int" is likely more efficient than a function of type "Eq a => a -> Int". therefore, if anything, an optimization should go in the other direction, to replace calling the latter by calling the former.
12:02:46 <orzo> data MaybeEq = NoEq | YesEq (forall t. Eq t => ())
12:02:59 <MonrealRyan> mauke: the way they work?
12:03:05 <mauke> MonrealRyan: what?
12:03:07 <orzo> pass that MaybeEq instead of using the Eq constraint
12:03:36 <rjayatilleka> Oh ok. Thanks orzo, I'll think about that.
12:04:21 <orzo> rjayatilleka: i think i may hgavge screwed that up a bit, but you understand the idea
12:04:41 <MonrealRyan> mauke: the way they work? for example the map function can search everything in the list does loop can do it also?
12:04:42 <orzo> you use a constructor to bring the Eq into scope
12:04:56 <rjayatilleka> orzo: Yeah I think I have an idea. I'm just exploring what kinds of options I have anyway
12:05:20 <hannes__> MonrealRyan: It's not entirely clear what you're asking. Loops _could_ do that, but there are no loops in haskell
12:05:44 <mauke> MonrealRyan: what?
12:05:50 <EvanR> im having issues with this plan ... http://lpaste.net/120343 it says could not deduce InternalFormat a11 in context InternalFormat a
12:05:52 <bennofs> MonrealRyan: do you mean some special 'loop' function?
12:06:01 <mauke> MonrealRyan: I asked you for your definition of "same" and "loop"
12:06:22 <mauke> "the way they work?" is neither; it's a sentence fragment
12:06:36 <geekosaur> EvanR, just the ScopedTypeVariables extension is not enough. need to declare the type variables to be scoped with an explicit top level forall
12:06:45 <EvanR> oh
12:06:48 <MonrealRyan> mauke: I'm asking for MAP function and LOOP function..
12:07:06 <monochrom> I have not heard of a function called "loop" in the standard library
12:07:07 <EvanR> sweet it worked
12:07:13 <orzo> rjayatilleka: if optimization is your concern, you might want to use System.Mem.StableName also.  Eq never shortcuts with a simple pointer comparison
12:07:15 <mauke> MonrealRyan: MAP is not a function. LOOP is not a function either
12:07:21 <mauke> MonrealRyan: what are you talking about?
12:07:32 <monochrom> using uppercase does not make a name more defined
12:07:42 <_um> Akk....
12:07:55 <mauke> EvanR: wouldn't internalFormat (RBO n) work without any extensions?
12:08:00 <_um> MonrealRyan: I think I kind of understand your question...
12:08:16 <xplat> MonrealRyan: LOOP function in what language?
12:08:28 <xplat> common lisp?
12:08:33 <hannes__> @hoogle loop
12:08:33 <lambdabot> System.Event loop :: EventManager -> IO ()
12:08:34 <lambdabot> Control.Arrow loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
12:08:34 <lambdabot> Data.Graph.Inductive.Example a, dag3, abb, ab, loop, e, c, b :: Gr Char ()
12:08:38 <_um> MonrealRyan: Are you thinking of loops of the sort we often see in imperative langauges?
12:08:44 <hannes__> Well, there are those
12:08:44 <MonrealRyan> mauke: Sorry my bad... then WHAT is MAP specifically.. and does haskell has a LOOP feature?
12:08:48 <EvanR> mauke: internalFormat :: InternalFormat a, Eq b, Num b => a -> b
12:08:55 <mauke> MonrealRyan: MAP is nothing. I still don't know what you're talking about
12:09:00 <mauke> MonrealRyan: what do you mean by "LOOP feature"?
12:09:03 <EvanR> not RBO a -> b
12:09:11 <hannes__> MonrealRyan: No, there is no real builtin 'loop' like in imperative languages in haskell
12:09:11 <MonrealRyan> _um: YES
12:09:28 <mauke> EvanR: ah, d'oh. it would work with internalFormat :: ... => proxy a -> b
12:09:36 <_um> No worries.
12:09:55 <EvanR> mauke: i was about to experiment with that, proxy with a lower p?
12:10:00 <mauke> yeah
12:10:06 <EvanR> whats that :S
12:10:10 <mauke> a type variable
12:10:12 <hannes__> MonrealRyan: We sometimes use the term 'loop', but there is no 'loop function' or anything like that. Not like what you're probably thinking off anyway
12:10:12 <_um> So in loops, you usually use an incrementing value to index an array... right?
12:10:13 <chpatrick1> EvanR: any proxy
12:10:23 <EvanR> is the word proxy special?
12:10:24 <chpatrick1> nope
12:10:26 <mauke> EvanR: no
12:10:26 <MonrealRyan> mauke: Like _um said loop that we often see in imperative languages
12:10:28 <chpatrick1> it's like saying f a
12:10:33 <EvanR> oh right
12:10:37 <hannes__> _um: What no.
12:10:41 <pjdelport> MonrealRyan: Haskell uses recursion for looping (among other things). The map function is one example of that.
12:10:43 <EvanR> trying
12:11:05 <mauke> MonrealRyan: and how do you define "same"?
12:11:06 <EvanR> what exactly "would work" .. internalFormat (RBO n) ?
12:11:08 <_um> hannes__: Sorry, could you explain?
12:11:27 <MonrealRyan> pjdelport : THANK YOU
12:11:33 <mauke> EvanR: I think so, yes. because it looks like RBO n :: RBO a
12:11:36 <xplat> MonrealRyan: haskell is a more structured language than most.  when translating a loop you have to ask yourself what kind of a loop it is--a transformation loop (map), accumulating loop (reduce), state-changing loop (traverse_), etc
12:11:39 <EvanR> nice
12:11:41 <MonrealRyan> Thank you everyone for the help ... :)
12:11:43 <hannes__> _um: A loop in imperative languages is usually just a restricted goto. It sometimes uses increments. It doesn't really have anything to do with arrays
12:12:02 <_um> right, but in the context of MonrealRyan's question, that seems to be the connection.
12:12:08 <xplat> MonrealRyan: if you don't know you can fall back on explicit recursion
12:12:12 <EvanR> this is some straight hax right here
12:12:21 <pjdelport> MonrealRyan: Haskell does not have a concept of "control flow" like imperative languages do, so the concept of imperative looping does not exist in Haskell. Haskell uses lazy evaluation instead, which lends itself naturally to structural transformations and recursion, like map does.
12:12:40 <pjdelport> @src map
12:12:40 <lambdabot> map _ []     = []
12:12:40 <lambdabot> map f (x:xs) = f x : map f xs
12:13:30 <pjdelport> MonrealRyan: If you look at that source, you'll see that one case is recursive (the equivalent of looping), while the other terminates (the equivalent of exiting the loop).
12:13:50 <pjdelport> But all that's actually happing is that you're transforming a data structure.
12:13:54 <EvanR> i tried it without ScopedTypeVariables and using (RBO n) and i got ambiguous type error
12:14:15 <EvanR> could not deduce InternalFormat a0 in InternalFormat a
12:14:17 <mauke> EvanR: oh :-(
12:14:27 <pjdelport> And Haskell will only evaluate the map function as far as you consume the result.
12:14:55 <mauke> EvanR: you could make it work but I'm not sure it's worth the effort
12:15:07 <EvanR> im trying different things
12:15:19 <orzo> EvanR: i'm not sure what you're looking at, but in order to bring variables from the top level type signature of a function into scope within the funciton, you should explicitly introduce them with forall
12:15:43 <mauke> r <- return (RBO n); ... internalFormat r ... return r
12:16:18 <mauke> I'm not sure if 'let' is sufficiently monomorphic for this
12:16:46 <EvanR> heh thats what i just tried, a le
12:17:21 <EvanR> heh
12:17:45 <EvanR> rbo <- return (RBO n) worked, no forall no scoped type variables
12:17:51 <EvanR> thats annoying
12:18:21 <EvanR> no one reading the code will get it
12:18:38 <EvanR> i like it
12:19:07 <orzo> do you often say those three sentences in a row like that?
12:19:28 <ReinH> EvanR: You know that doesn't do anything right?
12:19:39 <EvanR> or does it!
12:19:42 <ReinH> Does it?
12:19:49 <mauke> newRBO w h = wtf where wtf = do ... internalFormat (unsafePerformIO wtf) ...
12:19:50 <EvanR> http://lpaste.net/120344
12:20:11 <EvanR> even hpaste wants to complain but if i use let, they do not unify
12:21:35 <EvanR> newtype RBO a = RBO Int not shown
12:21:53 <ReinH> EvanR: wat
12:22:21 <EvanR> http://lpaste.net/120344
12:23:00 <nkar> template haskell question: how do I get a value out of a Name, so I could pattern match on it on the left hand side of a function declaration?  e.g., for newtype Foo = Foo a, I need to get Foo a, so I could do myFunction (Foo a) = a
12:23:02 <ReinH> Yes. I saw that.
12:23:16 <EvanR> ReinH: any suggests for making it less wtf?
12:23:29 <nkar> do I need to use reify?
12:23:40 <nkar> and pattern match on VarI?
12:24:21 <orzo> do you have a paste of the error it makes when you use let rbo = RBO n
12:25:05 <EvanR> http://lpaste.net/120346
12:25:11 <mauke> should be the same as the original error
12:25:58 * hackagebot plailude 0.4.1.1 - plaimi's prelude  http://hackage.haskell.org/package/plailude-0.4.1.1 (alexander)
12:26:01 <EvanR> i feel like im doing things so backwards
12:27:00 <orzo> yeah it's strange.  I wonder if it's actually a bug
12:27:14 <ReinH> Huh.
12:27:40 <orzo> oh i nm, i understand it
12:27:54 <orzo> you should be able to use a type signature though
12:27:55 <EvanR> let polymophism?
12:27:59 <orzo> with scoped type variables
12:28:20 <EvanR> yeah ill do that i guess
12:29:44 <orzo> actually, why is the type error gon with the return binding?  return (RBO n) should have an ambiguous variable a also, shouldn't it?
12:34:18 <mauke> orzo: no, <- desugars to function parameters
12:34:34 <mauke> which are monomorphic
12:35:23 <mauke> > let f = id in (f "", f ())
12:35:24 <lambdabot>  ("",())
12:35:49 <mauke> > (\f -> (f "", f ())) id
12:35:51 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
12:35:51 <lambdabot>              with actual type ‘()’
12:37:58 <lpaste> orzo pasted “Trying to reproduce type error ” at http://lpaste.net/120347
12:38:40 <mauke> ... duh?
12:38:42 <orzo> hm, i guess it's because his code must have made use of the 'a' somwhere
12:38:47 <EvanR> mauke: after you reminded me of that, i tried something to do let x = internalFormat in (x, x) :: (Int32, Word32) and it did not like that heh
12:39:53 <geekosaur> orzo, his error is because he has a binding later that uses 'a' in its type signature --- this makes it a *separate* a and prevents type inference. (often, omitting the type signature lets ghc infer that it must be the same 'a')
12:40:26 <mauke> geekosaur: are you still on version 1 of the code?
12:40:27 <eacameron> when does the GC run when haskell is being called from a C library (via foreign export)?
12:40:35 <geekosaur> probably, yes
12:40:36 <EvanR> http://lpaste.net/120344
12:40:39 <geekosaur> (mauke)
12:40:56 <hsk3> I don't understand why foldl' exists but why foldr' doesn't. What doesn't? Calculations are "accumulated" in both cases
12:41:00 <hsk3> as far as i can see
12:41:18 <mauke> hsk3: how would you implement it?
12:41:23 <hsk3> no idea
12:41:37 <EvanR> geekosaur: the error happens if you replace that <- return (RBO n) with let
12:41:55 <mauke> ಠ_ಠ
12:42:09 <EvanR> which would be a new a, but theres no sig
12:42:40 <monochrom> foldr' doesn't buy you much more efficiency than foldr
12:42:45 <shachaf> foldr' doesn't make sense for lists.
12:43:06 <shachaf> For some other data structures it makes sense, so it's defined in Data.Foldable.
12:43:32 <bernalex> is there some way I can derive Show for free with this type
12:43:34 <bernalex> data StackItem a where
12:43:36 <bernalex>   Snum :: forall a. Fractional a => a -> StackItem a
12:43:38 <bernalex>   Sop  :: Op -> StackItem a
12:43:40 <bernalex> ?
12:44:19 * monochrom fills out the FTP survey with this: "I support this because it eliminates the question why foldr' is not present" :)
12:44:29 <orzo> i added a function that accepts RBO (Maybe String) as an argument, and i still couldn't get it to make a type error
12:44:46 <csd_> Hi -- why is it that when I do :e inside ghci, and then exit my editor, my code isn't loaded any longer? How do I make it so that it automatically reloads?
12:45:34 <monochrom> tautologically, economics explains why some functions are written and distributed, and why some others are not
12:45:52 <EvanR> orzo: your paste above didnt use the class
12:46:03 <7YUAABMC8> Hey can someone help me - I will pay a bitcoin reward if successful and should be relatively easy
12:46:09 <EvanR> orzo: add a proxied constant method
12:46:32 <lpaste> orzo revised “Trying to reproduce type error ”: “Edit: Trying to reproduce type error ” at http://lpaste.net/120347
12:46:34 <EvanR> the error was about the call to that method
12:46:41 <pjdelport> 7YUAABMC8: What's your question?
12:46:44 <orzo> last line should say Stil NO type error
12:46:44 <orzo> heh
12:46:59 <EvanR> you still didnt try the type class
12:47:16 <orzo> oh i menat that on the function
12:47:16 <7YUAABMC8> pjdelport i need to check if an email has been used to register at a site. don't need the password, username etc.. just need to check if the email has been used to register a user
12:47:38 <pjdelport> 7YUAABMC8: ...is this a Haskell-related question?
12:48:07 <pjdelport> (This channel is for the Haskell programming language.)
12:48:19 <7YUAABMC8> pjdelport no... I heard you guys were smart and #hacking doesnt have any members
12:48:36 * EvanR blams the crap out of 7YUAABMC8 
12:48:36 <pjdelport> 7YUAABMC8: This is probably not the appropriate place, sorry.
12:48:40 <cmtptr> I can say with utmost authority that I am not smart
12:48:43 <hannes__> 7YUAABMC8: That really doesn't make it any less offtopic
12:48:57 <7YUAABMC8> so no help then? even for a reward in BTC?
12:48:59 <EvanR> cmtptr: youre not smart enough to make that assertion
12:49:04 --- mode: ChanServ set +o shachaf
12:49:16 <tnks> I wish I could tell my parents that their requests for help are off-topic, when they insist "but you know computers"
12:49:43 <bitemyapp> monochrom: lmao
12:49:46 <NightRa> tnks: XD
12:49:47 <hannes__> tnks: You can, they'll just believe you despise them
12:49:49 <pjdelport> 7YUAABMC8: No. What you're soliciting is not the kind of thing that's welcome here, so it's probably best to drop the topic.
12:49:54 <Welkin> haha
12:50:01 <tnks> hannes__: yeah, not the response I want.
12:50:06 <7YUAABMC8> party poopers, ok
12:50:10 <7YUAABMC8> thx anyways
12:50:24 <Welkin> people who don't understand computers think that anyone who programs or uses computers a lot knows everything about them
12:50:25 --- mode: shachaf set -o shachaf
12:50:34 <hannes__> that was weird
12:50:36 <bitemyapp> Welkin: they're not wrong
12:50:49 <bitemyapp> Welkin: didn't you get your magical download of All-Knowledge when you understood monads for the first time?
12:50:55 <bitemyapp> Welkin: came as part of the package deal for me.
12:51:39 <orzo> me too, but i can't get access to the knowledge because the particular monad doesn't offer an interface
12:51:57 <cschneid> Has anybody attempted to do a meteorjs / voltrb style web framework in haskell? with ghcjs or similar it shouldn't be overly hard. "Shouldn't".
12:52:11 <bitemyapp> cschneid: GHCJS is young enough that that's probably not well-explored.
12:52:25 <bitemyapp> cschneid: meteor's design is extremely dangerous & fraught with security problems tho.
12:52:41 <bitemyapp> cschneid: I'd stick to an RPC'ish API for the client to talk to, then share types between client/server
12:52:47 <cschneid> bitemyapp: yep, of course. But the ideal of making small to mid sized interactive apps so much faster to right.
12:53:06 <cschneid> a good example of doing that would be cool - the auto generation of api end points, and how to share code.
12:53:06 <hannes__> bernalex: Have you tried 'deriving Show'?
12:53:31 <bitemyapp> cschneid: oy. I can link a demo by Snoyman, but what you want you will have to invent (carefully)
12:53:41 <bernalex> hannes__: that does not work.
12:53:41 <nkar> so, how do I debug TH?  I tried this in ghci: :set -XTemplateHaskell; newtype Foo = Foo Int; runQ (reify 'Foo) >>= putStrLn.pprint and got "Failed to load interface for ‘Ghci1’ no package matching ‘interactive’ was found"
12:53:41 <nkar>  
12:53:54 <EvanR> is the proposal really to put traversable in the prelude?
12:54:02 <hannes__> bernalex: The only way that wouldn't work is if Op doesn't have a show instance
12:54:10 <cschneid> bitemyapp: well I was hoping I could mooch off others.  Mostly I want to write an api driven app without having to write two separate apps (front end / backend) that are so far apart.
12:54:14 <hannes__> EvanR: Why not? Foldable is now.
12:54:16 <EvanR> what about when and forever from Control.Monad
12:54:26 <bernalex> hannes__: incorrect.
12:54:38 <bernalex> hannes__: I'll need 'deriving instance Show a => Show (StackItem a)'.
12:54:49 <bitemyapp> cschneid: it wouldn't take me that long to write the RPC endpoints to support a client-side app. I'm not sure what cost-center you're trying to attack here.
12:54:58 <hannes__> bernalex: Well yeah. Is there some problem with that?
12:54:59 <bitemyapp> cschneid: I wish you best in inventing something cool for the rest of us to use though :)
12:55:09 <bitemyapp> cschneid: I'll give what you're talking about some thought.
12:55:27 <cschneid> bitemyapp: well, I'm not sure. My web app at the moment is spock /scotty in the backend and coffeescript in the front. Barely any code and js and friends are already pissing me off
12:55:35 <cschneid> something like purescript has my eye, but no code reuse unfortunately
12:55:40 <cschneid> (or much less)
12:55:48 <bitemyapp> cschneid: why not keep it simple, use GHCJS to talk to a JSON API, and see how you feel.
12:55:51 <bernalex> hannes__: that's not deriving Show, which you adamantly claimed will work.
12:56:09 <bernalex> hannes__: in fact "deriving Show" won't work ever. it's "deriving (Show)".
12:56:11 <cschneid> bitemyapp: I suppose that'd let me share aeson instances between the two, which keeps overhead down.
12:56:20 <cschneid> bitemyapp: I'll give that a go in the next few days and see.
12:56:25 <bernalex> hannes__: what I just pasted does however work, and I have resolved the problem. thanks for trying to help!
12:56:34 <bitemyapp> cschneid: yer. gl :)
12:56:41 <orzo> heh
12:56:46 <cschneid> I'm sure I'll be noisy in here and/or write blags
12:56:57 <hannes__> bernalex: I didn't 'adamantly' claim anything. You And the only difference between the two is that one works and the other doesn't.
12:59:48 <EvanR> "man i wish i could just sequenceA this thing... it really should be a Traversable... ok whats the minimum complete definition"
12:59:52 <EvanR> "sequenceA"
12:59:53 <nkar> $(stringE . show =<< reify ''Foo) does the trick
13:01:39 <ReinH> EvanR: can you just derive it?
13:01:46 <EvanR> probably
13:01:55 <EvanR> whats the cheatcode for that
13:02:18 <monochrom> :)
13:02:31 <bennofs> EvanR: -XDeriveTraversable -XDeriveFoldable      and then deriving (Foldable, Traversable)
13:02:45 <EvanR> might as well derive functor while im at it
13:02:50 <EvanR> what about applicative?
13:02:50 <bennofs> Ah, might also need to derive Functor too
13:02:56 <bennofs> EvanR: not possible to derive
13:03:21 <ReinH> bernalex: Uh, the parens are not necessary.
13:03:40 <orzo> would anyone else prefer ghc output language pragmas over -X suggestions?  So i can more easily just paste it in
13:03:44 <ReinH> So "deriving Show" will indeed work ever.
13:03:55 <bernalex> ReinH: you're right, thanks.
13:04:08 <bernalex> ReinH: (won't work in that particular example though but :-)
13:04:29 <orzo> or at least put a space after the -X so my terminal clicky magic can paste-buffer the name of the pragma with a double click
13:04:45 <ReinH> bernalex: the grammar is deriving	→	deriving (dclass | (dclass1, … , dclassn)) fwiw
13:05:00 <bernalex> ReinH: yes, I realise my mistake, thanks.
13:05:06 <bitemyapp> ReinH: you use a weird character in there
13:05:09 <bernalex> ReinH: and good evening/morning!
13:05:11 <ReinH> bernalex: well I want to all the trouble to look up the grammar :p
13:05:15 <bitemyapp> ReinH: it doesn't render well in my terminal+irssi setup.
13:05:24 <ReinH> bitemyapp: you use a weird font  or don't have unicode support.
13:05:33 <mauke> ReinH: it's a tab
13:05:35 <bernalex> bitemyapp: they all work well here. here's 2¢, go buy yourself a better font. ;-)
13:05:39 <orzo> it's an -> between tabs
13:05:42 <bitemyapp> ReinH: http://i.imgur.com/8dBLZ7E.png
13:05:45 <bitemyapp> ReinH: no u
13:05:53 <ReinH> bitemyapp: your face
13:06:00 <bitemyapp> ReinH: don't use tabs, they're evil
13:06:00 * hackagebot aws-kinesis-client 0.2.0.3 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.2.0.3 (JonSterling)
13:06:07 <ReinH> bitemyapp: I copied it form the report :p
13:06:08 <monochrom> orzo: speaking of which, did you know: if you tell ghc "-i /my/directory", it will be misunderstood, it has to be "-i/my/directory", no space? :)
13:06:11 <ReinH> s/form/from
13:06:16 <bernalex> hah so it's not the font, but that's still odd behaviour from irssi or whatever's causing it.
13:06:22 <bitemyapp> ReinH: it should be fixed then
13:06:29 <orzo> monochrom: i assume that applies to -X also?
13:06:36 <monochrom> I think so, yes
13:06:40 <bernalex> bitemyapp: following the huge detabbing of GHC, it's only natural we detab the report!
13:06:47 <orzo> well it's unfortunate
13:06:53 <monochrom> ghc's arg parsing is a bit restrictive
13:07:27 <bitemyapp> bernalex: yis
13:07:28 <ReinH> bitemyapp: The irony being that the HTML version of the report uses a table to align the grammar rules but still uses tabs anyway
13:07:38 <bitemyapp> ReinH: lmao
13:07:46 <bitemyapp> ReinH: fuckin' HTML.
13:07:57 <bitemyapp> ReinH: I wonder what pandoc would do with a LaTeX -> HTML rendering of a TeX table.
13:08:14 <EvanR> now my haddocks have forall a in them, is there a way to surpress that since its an internal issue
13:08:24 <Welkin> I just realised the similarities between the name HTML and ML/SML/Ocaml
13:08:40 <Welkin> Hyper-Threaded ML
13:08:45 <orzo> i love haddock heh
13:08:45 <joe9> I think I am running inot the lazy IO issue but am not sure.  http://codepad.org/K0ZeJAK7 is the relevant code. For some reason, I see that only 3 items of the allMarkets are getting process'ed. Can anyone please confirm?
13:09:03 <joe9> s/inot/into/
13:09:34 <bitemyapp> Welkin: o_O
13:10:59 <geekosaur> joe9, if it is lazy I/O at fault then more code is needed to determine it. what's shown isn't sufficient and should work in at least some use cases. (if the readFile were a withFile then it would be much more clear-cut; it would also be failing for all items)
13:13:11 <joe9> geekosaur: http://codepad.org/uXKSXSxQ is the code. The lines I am talking about are  from lines 119 to 124
13:13:18 <joe9> geekosaur: thanks for your response.
13:14:20 <orzo> maybe haddock should be extended to process C code and work with an hscolor like tool for c to provide source links
13:14:20 <joe9> For some reason, I am gettings only 3 items in rpPoints
13:14:35 <joe9> geekosaur: I suspect that it is because of lazy IO, but, am not sure.
13:14:57 <orzo> when i have to write android code, i am constantly wishing they'd just provide haddock-style source links
13:15:48 <orzo> does any other language community do the source link thing?  Because... wtf not?
13:16:17 <darkroom> does anyone know arrowized yampa?
13:16:21 <ReinH> orzo: lots of them do
13:16:44 <orzo> ReinH: hm, well none that i'm involved in i guess
13:17:43 <orzo> ReinH: c++/c/java ... they never have source links
13:17:55 <orzo> and they're probably the biggest languages out there
13:19:06 <glguy> Java Doxygen documentation can/does have source links
13:19:10 <orzo> they also have generated documentation sites that are a hundred times more annoying and uglier than haddock's output
13:19:22 <geekosaur> joe9, the only thing I am noticing so far is that nothing after updateDataLoop in main would ever run, since the only way to escape updateDataLoop is an exception
13:19:58 <geekosaur> but that makes me wonder what other logic errors are present
13:20:15 <joe9> geekosaur: yes, I am aware of that issue.
13:20:28 <joe9> geekosaur: I am Ctrl-C now during testing.
13:20:43 <joe9> geekosaur: I need to parse the marketinfo and if it is closed, I need to get out of that loop.
13:20:57 <joe9> geekosaur: I have not thought about that part yet.
13:21:14 <geekosaur> oh. control-c will likely interact badly with lazy I/O...
13:21:45 <EvanR> it is possible to make haddock output GADT style constructor types
13:21:46 <joe9> geekosaur: in lnie 119 - 124, it is supposed to write data after each loop.
13:22:12 <joe9> geekosaur: I let it run for more than 10 loops and it is supposed to writeFile after each loop.
13:22:20 <geekosaur> yes, but nothing forces the writes to happen. (normally all I/O gets forced by control flow returning from main)
13:22:42 <orzo> joe9: curious, is your Masked.Prelude from a hackage library?
13:23:24 <geekosaur> I/O is not "just magically strict"; it is in fact as lazy as anything else except for the forcing caused by returning from main. which leads to odd behavior if you use an uncaught exception to exit
13:24:27 <ttt_fff> anyone here finding that they're moving away from pure functions, i.e. instead of "a -> b", it's all "a -> m b" so taht m can do error handling and produce a useful error msg in acse something goes wrong in the a -> b process ?
13:24:53 <EvanR> a -> Either e b? yeah
13:24:54 <orzo> a -> m b is pure
13:25:01 <orzo> heh
13:25:29 <geekosaur> you might do better to wrap the updateDataLoop call in main: Control.Exception.try (updateDataLoop ...) (\(e :: SomeException) -> return ())
13:25:34 <joe9> orzo: basically, followed the comments here http://www.stephendiehl.com/what/ about prelude.
13:25:49 <eacameron> When does the GC run when calling Haskell exports from C?
13:26:05 <geekosaur> (I do not recommend that for production code, but for testing it'll do)
13:26:20 <EvanR> ttt_fff: a -> b is great for when theres no way for anything to go wrong (that is, when b does not equal something like Either E Foo)
13:26:22 <geekosaur> maybe show e >> return () instead
13:26:34 <geekosaur> er, print e >> return ()
13:27:04 <joe9> geekosaur: line 121, use see the BSC.writeFile. It is not writing information of all the markets in allMarkets of line  124
13:27:20 <geekosaur> I think maybe my point is not getting through
13:27:48 <joe9> geekosaur: yes, I do not understand. sorry about that.
13:28:04 <joe9> geekosaur: I understand the breaking out the loop issue.
13:28:50 <joe9> geekosaur: but, when the loop is run once fully, I expect that all the contents in allMarkets get processed and written through BSC.writeFile (line 121)
13:28:58 <orzo> joe9: you have to use the return value of updateDataLoop
13:29:07 <orzo> in order to force the IO to occur
13:29:38 <joe9> oh, ok
13:31:07 <joe9> geekosaur: so the , print e >> return (), at the end of updateDataLoop?
13:31:43 <absence> which of the -ddump options is most suitable for checking what gets inlined and fused?
13:32:34 <joe9> geekosaur: and make updateData return something.
13:32:35 <bennofs> absence: -ddump-simpl will print core, which is what you need in this case I think
13:34:29 <ReinH> joe9: (btw, print e >> return () could just be print e)
13:35:11 <geekosaur> true
13:35:18 * geekosaur trying to do too many things at once, sigh
13:35:30 <ReinH> geekosaur: np :)
13:35:57 <EvanR> is sequenceA . liftA2 silly
13:37:54 <absence> bennofs: allright. the output is a bit of a mouthful, but i think i see something that resembles my code in there :) thanks
13:38:34 <joe9> geekosaur: orzo: is this what you had in mind:  http://codepad.org/lFQwhOj3 lines 119 - 124 and line 93
13:38:41 <orzo> EvanR: one call to traverse instead?
13:39:05 <EvanR> ah
13:40:38 <joe9> geekosaur: with haskell syntax highlighting : http://codepad.org/PEej5SWP orzo.
13:42:21 <EvanR> orzo: well i would need to liftA2 (,) first right
13:45:43 <joe9> geekosaur: orzo, I do not think that is helping either. I am still getting only 4 points now. maybe, there is a logic error or something somewhere.
13:46:06 <geekosaur> I didn't notice anything glaring, but I'm still trying to do too many things at once :(
13:46:20 <joe9> geekosaur: ok, thanks.
13:46:38 * geekosaur got sucked into stuff in #xmonad
13:48:19 <orzo> i havent even been trying to read the code
13:48:35 <orzo> i was merely trying to help geekosaur be understood heh
13:54:33 <mseeks> is there a more concise way to write ` (return . fst =<<) `?
13:55:13 <bennofs> mseeks: fmap fst
13:55:38 <orzo> or liftM fst
13:56:06 <orzo> since AMP isn't here yet
13:56:24 <mseeks> oh right
13:56:30 <mseeks> that's where i started and came full circle
13:56:46 <mseeks> thanks
13:56:48 <mseeks> what's AMP?
13:57:04 <mseeks> Functors ( Applicative ( Monad?
13:57:04 <fragamus> Hi guys. I naver did any Lisp macros but my lisp friend is making fun of me a little bit because I am a haskeller and he says that without macros haskell is crippled
13:57:09 <fragamus> I want to get him in a headlock and give him noogies
13:57:11 <orzo> AMP will make Monad t sufficient to use fmap, as it will imply Functor
13:57:14 <fragamus> can you help me
13:57:25 <mseeks> thanks!
13:58:20 <geekosaur> there's usually no reasoning with someone that intoxicated with the lisp koolaid...
13:58:21 <orzo> is he big?
13:58:30 <orzo> i'll help hold him down
13:58:32 <fragamus> yeah
13:58:47 <orzo> anyway, tell him: TemplateHaskell
13:58:47 <kadoban> fragamus: Lots of programmers have a favorite thing that they think is required for a good language…which usually just happens to be some pretty-nice part of whatever language they favor. Like C++ users thinking RAII is the most important thing every, and all other languages fail, etc.
13:58:48 <fragamus> but what about preprocessor stuff for haskell
13:58:52 <fragamus> oh yah
13:58:58 <dmead> fragamus, dude template haskell
13:58:59 <kadoban> s/every/ever/
13:59:00 <dmead> is fine
13:59:17 <orzo> preprocessor, talking to a Lisper... he'll laugh even harder at you
13:59:18 <dmead> fragamus, tell him lisp is crippled without static typing
13:59:29 <orzo> better emphasize template haskell over cpp
13:59:48 <mauke> fragamus: which lisp? common lisp?
13:59:54 <fragamus> I dunno
14:00:00 <fragamus> he was just making fun of me
14:00:16 <orzo> well he's probably insecure
14:00:20 <mauke> yes, so now you have to make fun of him
14:00:28 <mauke> this requires detailed target knowledge
14:00:32 <orzo> you know he has to deal with the whole world hating lisp
14:00:42 <fragamus> I have used a little template haskell with lens but I never really understood much about it
14:00:48 <mauke> or you could just reply "))))))))))))))))"
14:00:55 <mauke> that always works
14:00:56 <orzo> lol
14:00:58 <fragamus> mauke lol
14:01:05 <EvanR> haskell vs lisp war
14:01:13 <quchen> > fix (')':)
14:01:14 <josephle> kadoban, I think RAII is pretty important in a non-GC language
14:01:15 <lambdabot>  ")))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))...
14:01:28 <josephle> but if you have gc, RAII is quite irrelevant to the everyday programmer
14:01:56 <mauke> RAII should be a function, not an acronym
14:02:00 <mauke> but hey, C++
14:02:19 <fragamus> plus they have a rock video
14:02:20 <fragamus> https://www.youtube.com/watch?v=HM1Zb3xmvMc#action=share
14:02:30 <fragamus> do we have any rock videos
14:03:10 <fragamus> actually the author of Land of Lisp praises haskell highly
14:03:15 <quchen> RAII for resource allocation is like callbacks for asynchronous callbacks. The language can't do it so we give you an abstraction to get around allocation/threading by writing your own allocator/thread scheduler interleaved with your program.
14:03:38 <quchen> One of those "callbacks" should be "programming" I think.
14:04:15 <quchen> Well, it's an unfair comparison because RAII makes sense in certain scenarios.
14:04:29 <mauke> :t bracket
14:04:30 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:04:35 <mauke> hence ^this
14:04:46 <kadoban> josephle: Yeah. It's pretty cool in context, one of my favorite parts of C++ actually (as low a bar as that is). My disagreement is with the feeling that "any language without RAII is broken and not worth looking at", which is a pretty common feeling. It seems like most adherents to a single language have some feature like that, that they just /can't/ live without.
14:04:59 <quchen> I was told it's called "prompt finalization" in Haskell land. (I usually call it "bracketing".)
14:06:04 * hackagebot opaleye 0.3.1 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.3.1 (tomjaguarpaw)
14:06:14 <mauke> kadoban: it's not limited to a single language, though
14:06:25 <mauke> I can't live without sane scoping
14:06:39 <sdegutis> I guess a big reason I don't like Haskell is that function parameters aren't usually named. In other languages, I find the name of a parameter to really help me understand its purpose in relation to the function. I know this can sort of be emulated with pattern-matched record fields, but it's just not quite the same thing.
14:06:59 <sdegutis> Oh wait. I just realized they do have names.
14:07:00 <mauke> this leaves me with Haskell, Perl, (Firefox) JavaScript, and rules out Python, PHP
14:07:06 <EvanR> they have names and they have types
14:07:10 <sdegutis> mauke: check out Elm
14:07:17 <glguy> and you can add documentation to each parameter
14:07:22 <quchen> sdegutis: Idris has named fields in types, which is pretty nice to have.
14:07:28 <kadoban> mauke: I find it kind of funny that you think JS's scoping is sane. Not that I necessarily disagree, but…it sure is weird scoping.
14:07:39 <sdegutis> quchen: yeah maybe it's the type names I'm thinking of? I dunno.
14:07:57 <sdegutis> Hmm. Maybe it's the terseness of their names I'm thinking of?
14:07:58 <mauke> sdegutis: meh, web scripting
14:08:07 <quchen> Javascript has scoping, but certainly not sane scoping.
14:08:08 <orzo> there's ImplicitParameters also
14:08:19 <mauke> kadoban: you need 'use strict' and always use 'let' instead of 'var'
14:08:25 <orzo> but of course i guess it doesn't count if it's not widely used
14:08:26 <sdegutis> More than likely, I'm just thinking of poorly chosen vague short names.
14:08:33 <glguy> and if you want named parameters you can take a record as an argument
14:08:46 <sdegutis> mauke: "meh, web scripting" -- huh?
14:08:47 <quchen> glguy: That still won't show up in type signatures though
14:09:02 <kadoban> mauke: Is 'let' ES6 or something? Doesn't sound familiar
14:09:07 <glguy> quchen: which part? All of that will show up in the haddocks
14:09:24 <mauke> sdegutis: "Elm compiles to HTML, CSS, and JavaScript."
14:09:44 <cmccann> sdegutis: perhaps you're just used to having the parameter names and type signature intermingled
14:09:44 <quchen> glguy: But not in the function's signature, only when you click on the type of the function's argument you'll get to the location where the names are listed.
14:09:59 <orzo> the scoping on record field names makes them a little unweildy for casual parameter naming
14:10:12 <quchen> glguy: In Idris you can write this: appendV : (xs : Vect n a) -> (ys : Vect m a) -> Vect (add n m)
14:10:24 <quchen> So the parameter names, which can be very suggestive, show up in the type sig directly
14:10:53 <cmccann> sdegutis: instead of something like "map (f :: a -> b) ((x:xs) :: [a]) = f x : map f xs :: [b]"
14:11:01 <sdegutis> mauke: and?
14:11:04 <cmccann> sdegutis: which would be closer to how things are written in most languages
14:11:19 <mauke> kadoban: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let - introduced in javascript 1.7 (firefox 2.0)
14:11:28 <sdegutis> cmccann: no I think really it's just that all the real-world libraries I see are using awful names for things.
14:11:41 <mauke> sdegutis: I'm not very interested in web stuff
14:12:00 <orzo> awful names -are- idiomatic in haskell (x, xs) and so on
14:12:04 <glguy> quchen: I've experienced that in Agda, too. I much prefer seeing descriptions of the arguments than the internal names of the arguments in general, however
14:12:22 <kadoban> mauke: Oh hey, it's block scoping. Neat.
14:12:33 <glguy> f :: A {- ^ something about this argument -} -> B {- ^ something else -} etc...
14:12:54 <quchen> glguy: I don't think the names in the type sig have to match the value's argument names. (That wouldn't work with currying)
14:13:36 <quchen> map' :: (f : a -> b) -> (xs : [a]) -> [b]; map' = map
14:13:52 <sdegutis> mauke: use node-webkit to turn a web app into a desktop app
14:13:56 <quchen> As far as I know, it's a purely documentational feature
14:14:05 <mauke> sdegutis: no, thanks
14:14:14 <cmccann> sdegutis: well, there are some conventions about certain kinds of very short names that are fine once you get the hang of it. and for very general-purpose functions there's often no good name for anything at all.
14:14:17 <sdegutis> mauke: are you making something with GUI? what's the context if your question?
14:14:35 <mauke> sdegutis: what question?
14:14:37 <sdegutis> cmccann: I was reading this when I made that complaint:  https://github.com/evancz/elm-todomvc/blob/master/Todo.elm#L312-L313
14:14:38 <orzo> it's common to make type aliases in haskell just to add a little extra info to the type signatures.  I don't like this practice at all.  Type aliases in haskell are mostly a nuisanse
14:14:51 <sdegutis> mauke: "this leaves me with Haskell, Perl, (Firefox) JavaScript, and rules out Python, PHP"
14:14:58 <sdegutis> mauke: thats alls i saws when i joined
14:15:04 <mauke> sdegutis: yes, so what question?
14:15:17 <sdegutis> mauke: what are you looking for help with or advice on etc?
14:15:22 <cmccann> sdegutis: but yeah, there is a tendency to overuse of cryptic names. otoh, in my opinion the industry as a whole has a cargo-cult fixation with "descriptive" names that carry no information.
14:15:31 <mauke> kadoban: ooh, I didn't know about "temporal dead zones". I had independently reinvented the concept :-)
14:15:39 <mauke> sdegutis: nothing
14:15:41 <sdegutis> cmccann: agreed, both suck for same reason
14:15:43 <sdegutis> mauke: ok whatever
14:15:44 <mauke> sdegutis: that's why I didn't ask a question
14:15:47 <sdegutis> ok
14:15:48 <orzo> as a user of a library, i should not be required to know if an exported type is an alias or a bonified type but I do because the former cannot be partially applied, and that's a bonified problem imo
14:16:55 <kadoban> orzo: The type aliases I can think of all tend to be concrete (so you couldn't apply them anyway, partially or not).
14:16:57 <orzo> library authors sometimes switch between aliases and bonfied types without realizing they are breaking code
14:18:04 <orzo> kadoban: well i've been hit by the issue, maybe it was various versions of conduit or one of the crypto libraries
14:18:09 <cmccann> sdegutis: that all looks very clean and readable to me
14:18:39 <sdegutis> cmccann: I'm troubling reading channel vs Channel
14:18:53 <sdegutis> Signal.channel is apparently a Signal.Channel or something?
14:19:02 <sdegutis> Sorry, English is my first language.
14:19:02 <kadoban> orzo: Yeah, I don't doubt it happens, but…hopefully pretty rarely.
14:19:49 <orzo> kadoban: also, when i was less experienced, i used type aliases myself more often, and now i try hard to use newtype instead.
14:19:54 <cmccann> sdegutis: yes. I don't worry about that kind of thing because it's very difficult to mix them up without the compiler complaining promptly
14:20:14 <sdegutis> cmccann: ok
14:20:28 <sdegutis> Sometimes I think I prefer Swift's notation.
14:21:04 <sdegutis> Signal.Channel<Action> seems easier for me to read somehow
14:21:10 <cmccann> orzo: I mostly use type aliases as true aliases, mostly local to a module. to abbreviate common types or to make it easier to change a concrete type later on
14:22:00 <ReinH> mauke: JS has sane scoping?
14:22:11 <sdegutis> ReinH: lol
14:22:11 <ReinH> This must be some new definition of "sane" that doesn't mean "not insane".
14:22:26 <cmccann> sdegutis: juxtaposition meaning application is standard in Haskell, though. consistency makes things easier, on the whole. and I'd hate to need parens for every function application.
14:22:54 <ReinH> sdegutis: The angle brackets look like line noise to me.
14:22:55 <sdegutis> ReinH: that's silly, we all know insane's definition is actually based on sane, i.e. `insane = not sane` (may not work in GHCi), not the other way around
14:22:59 <cmccann> ReinH: perhaps it means "not (not insane)" under an intuitionistic version of sanity
14:23:02 <xplat> is there a way to get github to give me raw git diffs instead of htmling them up?
14:23:07 <ReinH> cmccann: hmm, perhaps
14:23:16 <ChristianS> orzo: nothing wrong with type aliases to give nicer/shorter names to types such as Map X Y
14:23:26 <sdegutis> cmccann: I often get type application mixed up with function application in Haskell cuz of that consistency.
14:23:38 <mauke> ReinH: what's insane about it?
14:24:45 <ReinH> mauke: pop quiz, what will this program do? https://gist.github.com/reinh/a240f346f3b8d701c185
14:24:53 <kadoban> xplat: I usually find it much easier to work with github stuff directly via git cli. But I think most of the time there's a 'Raw' button somewhere, although I forget if there's specifically one on their diff interface thing.
14:25:06 <mauke> ReinH: I don't use 'var'
14:25:18 <kadoban> ReinH: To be clear, he did say using a restricted subset ('use strict' and 'let')
14:25:47 <ReinH> Ok, some subset of javascript that avoids all the insanity of javascript scoping is sane by definition, I suppose.
14:25:49 <shachaf> xplat: Add .diff to the end of the URL.
14:26:01 <ReinH> mauke: (It will print undefined and then 10)
14:26:03 <mauke> ReinH: the point is that a sane subset exists :-)
14:26:12 <shachaf> xplat: (I tried this and it didn't work, and then I realized the URL had #... at the end of it, so I deleted that and then it worked.)
14:26:16 <mauke> (I know about var hoisting and function scope)
14:26:18 <ReinH> mauke: My point is that the language itself is very much not sane.
14:26:19 <sdegutis> mauke: I don't think not using "var" helps here.
14:26:20 <kadoban> ReinH: That's pretyt much the only way to use JS though, heh…pick the parts that aren't totally bonkers.
14:26:38 <xplat> shachaf: thanks, worked like a charm!
14:26:40 <ReinH> mauke: And you could make a similar argument for every language: only use the sane parts.
14:26:50 <mauke> ReinH: no, python has no such subset, for example
14:26:52 <orzo> ChristianS: if by "nothing wrong", you mean, comes with a cost that should be kept in mind (layer of indirection in documentation, inability to partially apply type in some cases), then yes, i agree
14:27:08 <EvanR> what if the sane parts for a region of measure zero
14:27:23 <mauke> sdegutis: why not?
14:27:44 <xplat> mauke: python has a sane subset, it's just too limited to do real work in
14:28:10 <mauke> xplat: I mean regarding scoping
14:28:32 <mauke> ok, there's the subset that doesn't use variables at all :-)
14:28:34 <ReinH> mauke: Sure it does. It might not be a very large subset. It might, in fact, be the empty subset... ;)
14:28:39 <xplat> mauke: like i said.
14:28:49 <mauke> you're technically correct
14:28:53 <ReinH> mauke: the best kind!
14:29:04 <ReinH> mauke: anyway my point is just that javascript scoping is quite weird.
14:29:31 <hpc> javascript scoping is easy
14:29:37 <hpc> never use globals ever
14:30:21 <kadoban> hpc: That's not really enough to make it easy…also it's impossible. globals are the only game in town for some stuff. You can abstract it away, but…never using them isn't really a choice.
14:30:51 <kadoban> hpc: You still have to figure out the lack of block scoping (unless you use 'let' apparently), and hoisting, and probably other stuff.
14:31:22 <mauke> nah, that's pretty much it
14:31:34 <hpc> yeah
14:31:40 <mauke> after you move all 'var's to the beginning of their function, the rest works as expected
14:38:22 <quchen> foreign imports are "safe" by default, right?
14:38:52 <bennofs> What is the average % of GC one should expect from a haskell program?
14:39:00 <bennofs> (% of GC time)
14:43:22 <orzo> what's the defacto standard serialization type class these days?  Binary?
14:43:50 <quchen> I think so, yes.
14:44:04 <osa1> there's also cereal which is slightly slower but I guess provides something extra
14:44:25 * bennofs just likes cereal because GHC doesn't depend on cereal
14:45:22 <sdegutis> Are there any existing solutions to Haskell's record syntax pollution problem?
14:45:36 <sdegutis> Thanks in advance. Best regards.
14:46:06 <EvanR> qualified imports or pollute the names of the fields yourself
14:46:22 <sdegutis> That's it? No compiler extensions or anything?
14:46:27 <sdegutis> That's pretty rough.
14:46:30 <EvanR> in idris each record type has its own namespace
14:46:40 <sdegutis> Is Idris generally awful?
14:46:45 <EvanR> yes totally
14:46:47 <acowley> Doesn't lens still ship with its makeClassy machinery?
14:46:49 <orzo> ghc --supported-extensions | grep ecord
14:47:00 <mauke> sdegutis: http://nikita-volkov.github.io/record/
14:47:18 <drewbert> sdegutis: https://ghc.haskell.org/trac/ghc/wiki/Records
14:47:42 <orzo> gives list: RecordWildCards RecordPuns DisambiguateRecordFields TraditionalRecordSyntax
14:47:44 <acowley> You can also roll something with Vinyl to avoid name clashes
14:48:23 <sdegutis> EvanR: y 4?
14:48:39 <EvanR> # !?
14:48:43 <orzo> doesn't lens have some idea on records?
14:48:51 <sdegutis> EvanR: why is Idris aful
14:48:57 <EvanR> its not
14:49:06 <sdegutis> EvanR: why dont people use it instead of haskell?
14:49:10 <orzo> oh
14:49:14 <EvanR> its brand new
14:49:17 <orzo> because it's error messages are truely hoorible
14:49:20 <sdegutis> oh
14:49:32 <sdegutis> also, isnt dependent typing very problematic?
14:49:41 <EvanR> the error messages are typically of the form this and that do not unify
14:49:44 <sdegutis> like, how can it work with infinity possible values?
14:50:02 <EvanR> like the natural numbers?
14:50:04 <sdegutis> ys
14:50:18 <EvanR> data Nat = Zero | S Nat
14:50:20 <orzo> there's no problem with that
14:50:25 <sdegutis> whats S?
14:50:32 <EvanR> a constructor as usual
14:50:34 <mauke> do you know haskell?
14:50:37 <sdegutis> yes
14:50:42 <sdegutis> oooh
14:50:57 <sdegutis> EvanR: cant Nat be done in Haskell too?
14:51:02 <orzo> idris is strict by default however, so infinite objects require some care in construction
14:51:17 <EvanR> yeah including let nat = nat in nat :: Nat
14:51:30 <EvanR> which you shouldnt want to be able to do in idris
14:51:33 <sdegutis> im so confused
14:51:38 <mauke> fix S
14:51:39 <sdegutis> i dont get the implications of either
14:52:27 <orzo> let nat = nat is the same as let nat = undefined
14:52:57 <EvanR> im pleasantly surprised theres literally nothing like undefined in idris
14:53:25 <EvanR> i figured there would be a hack or something but no
14:53:27 <orzo> what do you do with idris?
14:53:42 <orzo> what sort of projects
14:53:46 <mauke> template<typename T> T undefined() { return undefined<T>(); }
14:53:48 <sdegutis> EvanR doesnt use it
14:53:56 <EvanR> i tried to express the rules of american football
14:53:59 <EvanR> does that count
14:54:06 <sdegutis> no
14:54:17 <sdegutis> EvanR: thats literlaly just "undefined" in haskell
14:54:20 <sdegutis> so n.
14:54:22 <sdegutis> o
14:54:26 <sdegutis> *no
14:54:28 <EvanR> i beg to differ
14:54:43 <sdegutis> nø
14:54:53 <sdegutis> whoever watches fball is a nerd
14:54:56 <sdegutis> a dorky nerd
14:54:58 <EvanR> lol
14:55:11 <mauke> unlike people who program in haskell
14:55:23 <sdegutis> i will stare at such a person with a blank face to express an intense but completely ambiguous emotion about their preference
14:55:50 <sdegutis> (of liking foobl)
14:56:10 <orzo> i relate, but i would normally use the definition of nerd reversed so that i consider myself the outgroup
14:56:41 <barrucadu> Clearly we need a word which is like a reverse nerd. A dren, if you will.
14:56:41 <sdegutis> orzo: meh, i just use it to express disapproval of things that profit the soul not.
14:57:22 <sdegutis> scientific endeavors such as learning FP and best practices are not nearly on the same level of benefit to oneself as pointless amusements
14:57:39 <sdegutis> i.e., only nerds watch football
14:57:41 <orzo> i like the word dren, barrucadu, i will use it if you like
14:58:07 <EvanR> sdegutis: https://twitter.com/evanrinehart/status/565645044200513536
14:59:30 <sdegutis> EvanR: LLOL
14:59:32 <barrucadu> orzo: Go ahead
15:00:01 <orzo> barrucadu: dren was the name of the main freak in the movie Splice.  I doubt that's a coincidence
15:00:17 <barrucadu> I'm afraid it was, I've never actually heard of that movie
15:00:39 <barrucadu> Ooh, Guillermo del Toro
15:00:46 <sdegutis> EvanR: retweetd
15:02:03 <orzo> barrucadu: dren in the movie doesn't really match our desired usage of the term
15:02:36 <orzo> we'd need a big meme to overcome that
15:02:55 <orzo> recruit 4chan i guess
15:03:09 <barrucadu> A risky endeavour
15:04:16 <sdegutis> hi
15:04:46 <drewbert> haskell hurts my brain
15:04:49 <KaneTW> hm. is there some sort of knowledge base library for haskell? (i.e. i have a set of events; if events are in list a i want to store some state, if they're in list b i want to queue up an action based on state and some predicates)
15:05:13 <sdegutis> I'm seriously considering switching to Idris.
15:05:20 <sdegutis> Because it seems better than Haskell in every way.
15:05:34 <glguy> You should switch so you can ground that assessment
15:05:40 <orzo> yeah
15:05:45 <orzo> do switch
15:05:52 <EvanR> cold turkey
15:05:53 <cschneid> I've heard that modularization + proofs is annoying.
15:05:57 <glguy> sshh
15:06:04 <orzo> i like proofs
15:06:10 <cschneid> high proofs?
15:06:12 <orzo> it was the error messages that sent me packing
15:06:23 <EvanR> high on proofs
15:06:29 <sdegutis> EvanR: it's not really cold turkey; I haven't written any Haskell yet
15:06:35 <cschneid> more in the refactoring sense - its hard to move code around when its tied to a proof you've spent time on
15:06:37 <EvanR> sdegutis: eh?
15:06:44 <cschneid> but that's rumor
15:07:08 <orzo> i see
15:07:11 <EvanR> you wrote a blog about haskell as a whole and how it compares to stuff without writing any code?
15:07:21 <orzo> maybe i would have hit that if i got beyond the error messages
15:07:44 <cschneid> <thought-leader>
15:08:28 <orzo> gthe modularization/proof probely sounds like something that couuld be ameliorated with some technical solution
15:08:49 <drewbert> I am writing haskell and it makes me sad although that is more to do with the framework architecture than any issue with the language.
15:09:23 <ioajsd> quickcheck vs quickcheck2 vs smallcheck?
15:10:27 <barrucadu> QuickCheck uses randomized testing, SmallCheck makes the assumption that generally failures can be found by small test cases and so systematically generates tests.
15:10:43 <EvanR> drewbert: framework?
15:11:15 <hpc> doesn't quickcheck also generate interesting tests?
15:11:23 <hpc> empty lists, lists filled with zero, etc
15:11:30 <kadoban> ioajsd: Between qc and qc2, I'd use qc2 for new code. I don't know what smallcheck is personally.
15:11:34 <ReinH> ioajsd: quickcheck(2) generates random inputs, smallcheck attempts to generate *exhaustive* inputs.
15:11:38 <drewbert> EvanR: yesod
15:11:42 <cschneid> orzo: I've not done much idris - but I've chatted w/ puffnfresh at the local haskell meetup about it, and that's the kind of thing I've seen
15:11:49 <ReinH> ioajsd: There's no reason to use quickcheck over quickcheck2
15:11:52 <cschneid> orzo: it does seem like a damn awesome language though
15:11:59 <ioajsd> okay so quickcheck out
15:12:02 <barrucadu> hpc: Probably, I don't know much about QuickCheck
15:12:25 <ReinH> One big feature added in qc2 is shrinking in the Arbitrary typeclass
15:12:28 <ioajsd> are there other differences smallcheck and quickcheck2 other than the data they generate?
15:12:32 <barrucadu> Colin is my supervisor, so I've been somewhat indoctrinated into the systematic testing camp…
15:13:06 <ReinH> ioajsd: Well, that difference is important.
15:13:12 <orzo> cschneid: i do agree about it and want to do dependent types programming eventually.
15:13:21 <ReinH> ioajsd: You would want to use smallcheck to exhaustively check small cases
15:13:39 <ReinH> You wouldn't want to use it to test, say, something that takes an Int.
15:13:49 <ioajsd> i see
15:13:55 <ReinH> ioajsd: So really they are designed for different uses
15:14:00 <orzo> haskell is a far more practical tool atm though
15:15:09 <ReinH> ioajsd: Also you should probably prefer lazy smallcheck to the original, since it can be more efficient (https://hackage.haskell.org/package/lazysmallcheck)
15:15:29 <ioajsd> okay
15:15:43 <ReinH> ioajsd: personally I just use qc2
15:16:00 <ioajsd> okay i think ill go with that until i know more
15:16:11 <orzo> is smallcheck much newer than quickcheck? i've never heard of it before now
15:16:45 <geekosaur> not newer, no. just less commonly used
15:18:28 <orzo> what's the tool that generates tests from haddock examples?
15:18:55 <bennofs> orzo: DocTest
15:19:01 <bennofs> @hackage doctest
15:19:01 <lambdabot> http://hackage.haskell.org/package/doctest
15:20:00 <orzo> cool, i think i should try adopting that as i seem to write a lot of testing code during development anyway
15:20:37 * bennofs sometimes uses quickcheck to debug programs (quickcehck until you find the wrong function) :)
15:25:57 <haskell-beginner> http://pastebin.com/USLw2HmW . Anybody help me out understand this?
15:27:02 <acowley> haskell-beginner: Because each variant must be a unique data constructor
15:27:08 <pjdelport> haskell-beginner: You have to give the alternatives of the type names so that you can pattern-match against them later.
15:27:32 <pjdelport> (and also construct them)
15:27:45 <pjdelport> haskell-beginner: Otherwise, what would you write instead of Sin and Mul in the body of your function?
15:30:31 <haskell-beginner> @acowley and @ pjdelport :ok, thank you . So I also wanted to know if I can use encodeModified without the 'ListItem' . i.e give only the character when it is single and a tuple when it is multiple?
15:30:31 <lambdabot> Unknown command, try @list
15:31:14 <pjdelport> (haskell-beginner: You probably want to avoid prefixing messages with @, otherwise lambdabot thinks it's a bot command. :)
15:31:29 <haskell-beginner> ok thank you
15:31:52 * hexagoxel feels the need to mention #haskell-beginners
15:32:52 <EvanR> a channel specially tailored to you!
15:33:08 <pjdelport> haskell-beginner: Well, you will need to distinguish the two alternatives in some way. Instead of using that custom ListItem type, you could use the built-in Either type, for example.
15:34:29 <pjdelport> haskell-beginner: "Either a b" is a generic type for when you can have one of two types. So in your case, you might end up having "Either Char (Int, Char)".
15:34:36 <sdegutis> don't do it
15:34:45 <sdegutis> #haskell-beginners is pretty nazi-ish
15:34:58 <sdegutis> and #haskell is filled with super helpful people toward beginners
15:35:11 <EvanR> #haskell-bootcamp
15:36:04 <sdegutis> aww pjdelport left #haskell-bootcamp
15:36:46 <sdegutis> haha now pjdelport pm'd me about it
15:37:01 <haskell-beginner> Thank you. I understood it.
15:37:03 <hexagoxel> sdegutis: can you explain what makes you say that about -beginners?
15:37:10 <sdegutis> hexagoxel: no just avoid it
15:37:25 <sdegutis> this channel is superior in every single way for haskell beginners
15:37:41 <benzrf> hexagoxel: sdegutis was banned from #haskell-beginners
15:37:48 <benzrf> i assume he's touchy about it
15:37:49 <Axman6> but having complete beginners also brings a lot of noise to this channel
15:38:11 <sdegutis> Yep, I was banned for -- get this -- asking a single question about a Haskell tutorial.
15:38:16 <pjdelport> (Speaking of noise, maybe it's better to move this meta-discussion elsewhere?)
15:38:31 <Axman6> sdegutis: there is no way that is why you were banned
15:38:37 <hexagoxel> benzrf: ah, thanks.
15:38:49 <benzrf> sdegutis: bitemyapp reports that he knows of you as a troll from other places and was therefore extra quick to ban
15:38:56 <ioajsd> how do I import modules from src/ directory from modules in test/ directory the right away - im using hspec
15:38:57 <benzrf> im not gonna take a side here
15:39:07 <ioajsd> do i need some sort of cabal script?
15:39:09 <hexagoxel> sdegutis: well making accusations but refusing any explanation sounds like a perfect plan of revenge
15:39:12 <sdegutis> Axman6: you're right, it's also because after I did that, I was told it was not okay, and when I left the channel, someone told the guy in private that I'm a troll, and he believed them.
15:39:28 <sdegutis> benzrf: no, he reports that others told him I'm a troll. Quite a difference.
15:39:36 <benzrf> ok
15:41:17 <orzo> 08:50 <sdegutis> quchen: I now hate Haskell.
15:41:21 <orzo> kind of trollish
15:41:38 <hexagoxel> clearly deserving a ban!
15:41:45 <sdegutis> orzo: No, the people in question who told bitemyapp I was a troll had a fair point...
15:41:53 <sdegutis> orzo: because 8 years ago I actually was a troll.
15:42:17 <sdegutis> And that's why I got banned from the single channel I was banned from (until #haskell-beginners).
15:42:31 <sdegutis> I think it's reasonable for someone to publicly defend themselves from false accusations made in public.
15:42:34 <sdegutis> That said, this is the last I'll say about it.
15:42:39 <ioajsd> this is not public
15:42:39 <acowley> ioajsd: Using the "hs-source-dirs" field of your cabal file is the usual way
15:42:41 <ioajsd> this is the internet
15:42:49 <sdegutis> ioajsd: potato, tomato
15:42:49 <ioajsd> acowley: thanks
15:44:07 <sveit> for people that use emacs to edit code, i seem to remember that there was some way to automatically add package dependencies to a cabal file, but I can't find the command or the key-binding. i think it might be related to flycheck or ghc-mod, but I am not sure. does anyone know?
15:44:31 <sveit> i.e. if you used an import in a file that used a package not present in the cabal file as a dependency it would offer to add it automatically
15:45:21 <funfunctor> hi
15:45:23 <creichert> sveit: haskell-process-add-dependency?
15:45:34 <creichert> sveit: sorry, haskell-cabal-add-dependency
15:46:31 <sdegutis> ioajsd: I was trying to make the point that it's reasonable to defend yourself as long as it was to the same audience to which you were falsely accused, but I don't know how to represent the equality of the audience via parametric polymorphism in Haskell
15:46:53 <Axman6> see, that sounds like trolling to me
15:46:55 <ioajsd> sdegutis: it doesnt matter
15:47:02 <sdegutis> Axman6: lol no
15:47:02 <sveit> creichert: yes, but i seem to remember there being a way for it to auto-detect the name of the package?
15:47:13 <sveit> creichert: if i run the command it still asks for the package name
15:47:38 <creichert> ah, I believe it will only do that when it parses an error message which can recommend the package.
15:47:41 <ioajsd> sdegutis: if you're defending yourself on an anonymous irc channel u already lost
15:47:46 <sdegutis> ioajsd: :)
15:48:14 <glguy> Moderation activities of other channels is offtopic in #haskell
15:48:30 <glguy> and moderation of #haskell is on topic in #haskell-ops
15:48:37 <acowley> sveit: Yeah, I think I've only seen that when loading a module into the repl
15:49:38 <sveit> acowley, creichert: thanks! so how exactly do I trigger this suggestion?
15:49:58 <sveit> also do people still use ghc-mod or is that method completely depracated?
15:51:12 <creichert> sveit: a suggestion generally happens when the module can be found by ghc-pkg but is not added to the cabal file
15:52:31 <meiji11> I have a type synonym defined on the datatype Data.Text.Text, which I'm using as the key type in a HashMap. I upgraded my version of the text package from cabal today, and now GHC isn't able to find the Hashable instance for Text / its type synonym, which is strange. that instance is defined in Data.Hashable now, but importing Data.Hashable makes no difference. what is going wrong?
15:53:24 <Taneb> meiji11, did you update hashable?
15:53:32 <meiji11> Taneb, I did.
15:53:32 <creichert> sveit: ghc-mod works pretty well with haskell-mode in my experience
15:53:55 <ReinH> meiji11: FWIW, the type synonym won't matter here.
15:54:29 <creichert> sveit: Possibly just explore more of the options exposed by haskell mode and experiment with haskell-cabal-add-dependency.
15:54:37 <delrik> +1 creichert: sveit:
15:54:59 <sveit> creichert: have you gotten ghc-mod and flycheck to play nice? i'd rather disable ghc-mod's highlighting i guess. and i'm trying to get it to trigger adding the package to the build-depends automatically in a sandbox, but this should work fine, right?
15:56:30 <meiji11> ReinH: right. so it should just work, no? I don't understand why this is a problem.
15:57:11 <creichert> sveit: they will work pretty well together except when it comes to template haskell and quasi quotes (at least flycheck-haskell has issues)
15:58:18 <meiji11> I love haskell, but I've come to dread having to use cabal.
15:58:21 <creichert> also, ghc-mod will have issues when you have multiple targets in a cabal project file. e.g. you have library and tests and your ghc-mod session starts on the library. When you edit modules in the test-suite there might be issues
16:03:46 <creichert> sveit: the sandbox features should just start working once you have a haskell-mode repl session running. make sure to set 'haskell-process-type to cabal-repl
16:04:21 <athan> Good evening fellow gangsters, how popping is the club currently?
16:05:07 <benzrf> extremely
16:05:09 <hiptobecubic> athan, can't you tell?
16:05:45 <athan> hiptobecubic: Is there a poppingforeveryoneorjustme.com?
16:06:20 <mauke> that's pushing it
16:06:59 <meiji11> oh, it's not using the latest hashable. of course, I have two hashables going. more cabal muckery then.
16:07:05 <tomphreek> @hoogle [a] -> a -> ([a], [a])
16:07:07 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
16:07:07 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
16:07:07 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
16:07:55 <BMeph> mauke: Ah, but is it push(ing) it Real Good? ;)
16:08:33 <Axman6> we gon liftM the roof!
16:09:20 <hiptobecubic> You'd want liftA unless we're all going to be trying to do it one at time
16:10:08 <KaneTW> you want to use conduits
16:10:14 <tomphreek> @hoogle [a] -> (a->Bool) -> ([a], [a])
16:10:14 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
16:10:14 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
16:10:14 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
16:10:25 <sveit> creichert: thanks for being so helpful!
16:10:38 <KaneTW> @hoogle Int -> [a] -> [[a]]
16:10:38 <lambdabot> Prelude drop :: Int -> [a] -> [a]
16:10:38 <lambdabot> Data.List drop :: Int -> [a] -> [a]
16:10:38 <lambdabot> Prelude take :: Int -> [a] -> [a]
16:10:56 <S11001001> tomphreek: boolean blindness, not enough free theorems :D
16:11:23 <tomphreek> S11001001: sorry?
16:12:10 <S11001001> @hoogle (a -> Either b c) -> [a] -> ([b], [c])
16:12:10 <lambdabot> No results found
16:12:16 <S11001001> eh.
16:14:16 <kaiyin> why is ghc so much slower than ocamlc?
16:15:44 <orzo> is that a question or a complaint
16:18:13 <kaiyin> a question. :-)
16:18:26 <hiptobecubic> kaiyin, because they are different programs with different purposes and implementations?
16:19:55 <acowley> Profiling GHC seems like a very challenging problem these days, which is in and of itself a bad thing
16:20:21 <acowley> There are so many components that one seldom hears of low hanging fruit for speeding the whole thing up
16:22:49 <pacak> kaiyin: That's obviously because of superiority of Haskell programming language.
16:23:07 <kaiyin> pacak: how so?
16:23:39 <glguy> You'd have to find someone who develops on the internals of both to get an interesting answer to that question. (Maybe that person is listening now, maybe not.)
16:24:26 <KaneTW> isn't ocaml's type system simpler?
16:24:30 <pacak> Compiler must be smart to compile smart language :)
16:25:21 <josephle> KaneTW, it depends on how modules are compiled ;)
16:26:19 <josephle> although I suspect Ocaml's applicative functors don't help
16:26:55 <tommd> Let's not get into a smugness competition.  GHC is slow and uses significant memory often in unexpected corner cases.  There is certainly room for improvement, this doesn't make it better than ocamlc.
16:28:10 <sdegutis> Can 3¢ be compared to Elm?
16:28:28 <sdegutis> They're both Haskell-esque FRP libraries that make use of the web browser as the GUI.
16:29:52 <S11001001> kaiyin: try scalac ;)
16:31:42 <S11001001> kaiyin: the problem is that #ocaml and #haskell are probably not great places to "poll" about this question :) try both, see what you like.  nothing wrong with being conversant in both Haskell and ocaml.
16:32:08 <EvanR> try asking the question in #python
16:32:20 <S11001001> heh
16:32:35 <pacak> #javascript should be better.
16:33:51 <kaiyin> :-) they don't even compile...
16:34:07 <sdegutis> what question did kaiyin say.
16:34:18 <kaiyin> why is ghc so much slower than ocamlc?
16:34:24 <sdegutis> oh
16:34:34 <sdegutis> yeah ask in #python why ghc is much slower than ocamlc
16:34:36 <sdegutis> im curious their reaction
16:34:40 <hpc> haha
16:34:47 <sdegutis> nm ill do it
16:34:58 <EvanR> trolls trolling trolls
16:35:06 <hpc> "when i type one hundred into my microwave, it only cooks for sixty seconds! checkmate atheists!"
16:35:20 <sdegutis> EvanR: they see me trollin
16:36:40 <sdegutis> ok the #python people just thought i ws in the wrong chnnel
16:36:48 <sdegutis> and suggested maybe i like python better than haskell
16:36:54 <sdegutis> trying ##javascript now
16:36:59 <shachaf> sdegutis: Trolling isn't OK here.
16:36:59 <kaiyin> :-D
16:37:04 <sdegutis> shachaf: :'(
16:37:13 <sdegutis> hi everyone
16:37:15 <shachaf> Talking about how you're trolling in other places isn't OK either.
16:37:23 <sdegutis> im having a bit of trouble
16:37:49 <sdegutis> hold on shachaf
16:37:56 <sdegutis> slow down, im trying to keep up but ur typing to ofast
16:38:20 <sdegutis> bbl, this connection is too fast, i cant keep up with you pythonistas
16:39:08 <funfunctor> I hate how things like StasiFacebook have promoted "trolling" as a popular thing to do
16:39:23 --- mode: ChanServ set +q *!*@unaffiliated/sdegutis
16:40:38 <funfunctor> the eternal september
16:40:59 <EvanR> i keep wanted to put a type on the global binding targets in opengl
16:41:05 <EvanR> which changes when you mutate it
16:41:11 <EvanR> wanting*
16:41:22 <EvanR> maybe with a global dynamic type
16:41:48 <EvanR> things are so much easier when they are not global mutable variables
16:42:26 <EvanR> i need more type fu
16:43:44 <acowley> Do you want the entire state reflected in the type?
16:43:50 <orzo> whenever i import qualified, i never fail to type the import statement and then have to backup to insert qualified
16:43:57 <EvanR> just the format which is one of three things
16:43:58 <orzo> the syntax just isn't in the order that i think
16:44:17 <orzo> is that true for anyone else?
16:44:20 <EvanR> or the fact that no such object is there at all would be nice to represent
16:44:57 <EvanR> maybe a monad, since using the monad action changes the type
16:45:41 <tempay> orzo: i have never not done that to date
16:46:00 <EvanR> acowley: you have suggestions?
16:46:03 <acowley> EvanR: perhaps just restricting the operations that you want to perform with a binding set to a specific type
16:46:26 <lightstep> why does haskell need import qualified at all? why doesn't the compiler automatically identify  qualified identifiers and import their modules?
16:46:41 <acowley> EvanR: So don't make attribPointer (or whatever) have type IO, but instead have type BoundTarget t
16:46:48 <lightstep> as in *cough* ocaml
16:46:59 <EvanR> lightstep: i hate not know where my stuff is coming from
16:47:03 <EvanR> knowing
16:47:20 <orzo> tempay: parsing your double negatives just for clarification, you are telling me that you also have to backtrack and insert the word qualified?
16:47:29 <glguy> lightstep: Imports affect which instances are in scope, also
16:47:30 <tempay> orzo: always
16:47:34 <acowley> The "import Foo as F" usage (without qualified) is somewhat less common
16:48:04 <EvanR> acowley: ok, so the type of the program which operates on the context has some information in it about the contexts state
16:48:33 <acowley> orzo: I mistype a lot, too, but in emacs it usually amounts to hitting "M-b M-b quaTAB" to fix
16:48:38 <lightstep> EvanR: it makes sense to me to solve this in the tool level (ide) and not on the language level...
16:48:40 <acowley> EvanR:: Yeah
16:48:46 <lightstep> glguy: true, i didn't think of that
16:49:09 <orzo> acowley: that the usage is less common doesn't mean everyone isn't backtracking and fixing their imports
16:49:33 <acowley> orzo: I meant that I'd prefer if "import Foo as F" was the qualified import, and "import aliased Foo as F" was the other one
16:50:14 <acowley> We should change the language spec. Everyone's always open to that sort of thing.
16:50:21 <orzo> heh
16:50:43 <orzo> you are joking right?
16:51:07 <hpc> we should write the spec in a proof language, so we know it's correct :P
16:51:15 <acowley> My suggestion was serious as I agree with your complaint about typing "qualified", but yes I was joking about actually changing anything
16:51:59 <acowley> Well, I suppose it could be a LANGUAGE pragma, actually
16:52:21 <EvanR> im apprehensive about moving functionality out of source code and into some "tooling" which to me always conjures up the win32 GUI-only shit show
16:52:27 <acowley> We need better support for pragma bundles so that kind of twiddling isn't so onerous to take advantage of
16:52:44 <orzo> cabal lets you do it
16:53:04 <orzo> just add pragmas to the cabal file make them default
16:53:12 <EvanR> like, configuration files suck, lets make a binary registry database
16:53:27 <acowley> EvanR: Yeah, I'd want to see a line of *code* somewhere that says Haskell2.0 = [EasyImports, TheBridgesAreAllBurned, Hallelujah]
16:55:06 <orbisvicis> I'm using ghc 7.6, are there any pragmas to replace -XDeriveDataTypeable, not working --> {-# LANGUAGE XDeriveDataTypeable #-}
16:55:19 <orbisvicis> s/XDer/Der/
16:55:21 <acowley> Take out the X
16:55:39 <orbisvicis> acowley: yes that's what I meant, also not working
16:55:48 <acowley> Maybe that was a 7.8 feature
16:56:17 <yac> it's unclear to me how to fetch rows with hdbc
16:56:29 <yac> do I need to call prepare, then execute and then fetchRow ?
16:56:47 <orzo> orbisvicis: works for me, ghc 7.6.3
16:57:06 <hpc> yac: yeah
16:57:26 <acowley> No, it seems to be in 7.6.4
16:57:27 <acowley> https://downloads.haskell.org/~ghc/7.6.3/docs/html/libraries/Cabal-1.16.0/Language-Haskell-Extension.html
16:57:33 <acowley> 7.6.3, that is
16:57:44 <orzo> heh
16:57:45 <orbisvicis> hmm, maybe I'm missing something (7.6.3)
16:57:46 <hpc> it's pretty low-level, but there's nice things about it like not having to prepare a query multiple times if you're just going to use it again
16:57:50 <yac> statement <- prepare conn "sql"; _ <- execute statement sqlValues ; row <- fetchRow statement
16:57:54 <orbisvicis> pragmas have to be at start of file ?
16:58:14 <orbisvicis> no..
16:58:19 <orzo> pragmas can come after a haddoc comment
16:58:32 <yac> like that? Seems kinda missing a giveMeWhatIWant :: Connection -> String -> [Sqlvals] -> IO (Maybe [SqlVals])
16:58:46 <hpc> yac: yeah, but it's short to write
16:58:54 <yac> right, ok
16:59:03 <hpc> and often you don't want that
16:59:15 <orbisvicis> orzo: thank you, yes, I had put that pragma before the Typeable import, not the start of the file
16:59:19 <hpc> if a query returns billions of rows, and you want to stream them or something
16:59:33 <orzo> DeriveDataTypeable will probably end up deprecated as i expect Typeable will be derived for everything anyway in the future
16:59:42 <yac> yeah, mainly it's not obvious that this is the proper aproach for a newbie
17:00:05 <yac> I don't understand why execute and fetchRow are separate steps
17:00:11 <EvanR> yac: the proper approach for a newbie would probably be to not use hdbc. use postgres-simple or something
17:00:22 <orbisvicis> orzo: well technically XMonad.Util.ExtensibleState which imports typeable, I assume it will be updated
17:00:57 <hpc> yac: it's so you can stream data
17:01:22 <hpc> queries can potentially return huge amounts of information, but if you don't need all of it at the same time, or you know you might have to bail early
17:01:41 <hpc> it's a lot faster and more evenly distributed between bottlenecks
17:01:42 <orzo> we'll still need to use Typeable constraints to use Typeable even when everything is Typeable
17:02:16 <EvanR> orzo: as it should be
17:02:45 <hpc> yac: you have fetchAllRows and fetchAllRows' btw
17:03:13 <hpc> fetchAllRows has some pretty major lazy IO caveats, and fetchallRows' can just take a huge amount of time to execute
17:04:37 <hpc> sql is one of those things that can be very simple
17:04:52 <hpc> or the job of an entire team of people
17:05:12 <orzo> another problem with 'qualified' is that it makes the module names not line up when you import the same module several times with different qualification rules for different symbols
17:05:15 <hjulle> Does this function have a name/exist in the base package? (`seq` return ())
17:05:30 <EvanR> orzo: editor plugin to format those
17:05:59 <orzo> EvanR: how do you format?  add spaces a bunch of spaces to the non-qualified import?
17:06:23 <orzo> that seems a tad awkward too
17:06:31 <ReinH> @hackage stylish-haskell
17:06:31 <lambdabot> http://hackage.haskell.org/package/stylish-haskell
17:06:40 <EvanR> orzo: ive seen something like that
17:06:47 <EvanR> orzo: huge columns
17:07:05 <ReinH> orzo: ^
17:07:55 <orzo> do you use that tool, ReinH ?
17:08:13 <ReinH> Yes. emacs runs it on save. haskell-mode has support for it.
17:08:41 <orzo> i'm going to try it out, i use vim though
17:08:53 <ReinH> orzo: Should be easy to get it working with vim as well
17:08:57 <acowley> I don't like those spaces :/
17:09:07 <EvanR> its not that many
17:09:16 <ReinH> There's https://github.com/nbouscal/vim-stylish-haskell
17:09:33 <ReinH> > length "qualified " -- it's this many
17:09:34 <EvanR> as long as you arent eventually responsible for manually mopping them around yourself
17:09:35 <lambdabot>  10
17:10:05 <orzo> acowley: i don't like the spaces either, but i prefer that to non aligned module names
17:10:07 <acowley> I don't like them because of how they look, not due to manual mopping
17:11:03 <acowley> I'd really like to see better import syntax. "import Data.Map (Map) as M" or something like that
17:11:30 <acowley> So we don't need to two lines, and don't need the qualified qualifier
17:12:03 <orzo> how about an import syntax that can be used anywhere that bindings can be done, with the expected scoping
17:12:09 <shachaf> "import Data.Map as M (Map)" has a meaning already (though probably not a very useful one).
17:12:26 <acowley> shachaf: Yeah, I'd change the meaning.
17:13:26 <ReinH> acowley: I don't ever use qualified without as or as without qualified, so data point of one I would support that change.
17:13:36 <acowley> orzo: Maybe! I'd probably rather the import be up top, then have an "open" or "with" form to bring things into scope.
17:28:11 <lpaste> hodapp pasted “No title” at http://lpaste.net/8078387129299763200
17:28:13 <Swanros> Hello, everyone! learnyouahaskell pointed me this way1
17:28:34 <Swanros> Just wanted to say hi, and ask if you knew of any other good haskell resources online that you'd recommend
17:28:48 <Debaser> hi
17:28:53 <hodapp> howdy
17:29:10 <hodapp> other good resources... well, acquaint yourself with the hackage docs
17:29:23 <hodapp> Real World Haskell is a decent book albeit outdated in spots
17:29:48 <EvanR> @learnhaskell
17:29:48 <lambdabot> Unknown command, try @list
17:30:03 <EvanR> @where learnhaskell
17:30:04 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:30:55 <Debaser> I just asked this question (https://stackoverflow.com/questions/28466832/unsing-haskell-template-with-aeson-on-complexe-json-structure) on SO, I thought afterwards that this chan might be a better place for it
17:31:17 <Swanros> I saw Real World Haskell but saw it is from 2008, wondered if it'd still be a good resource
17:31:44 <Rotaerk> I don't like it, myself
17:32:00 <Debaser> Swanros: http://www.stephendiehl.com/what/ is a good summary of what is needed (even if a few topic a advanced)
17:32:37 <Swanros> Ohhh that's a great summary! Thanks, Debaser!
17:36:38 <bananagram> @pl \f x -> (x,f x)
17:36:38 <lambdabot> ap (,)
17:36:43 <bananagram> @pl \x f -> (x,f x)
17:36:43 <lambdabot> liftM2 (.) (,) (flip id)
17:36:44 <acomar> hey, has anyone messed around with webkit and threading?
17:37:05 <acomar> getting a segfault whenever I attempt to load a uri when the program is compiled with threading
17:37:09 <bananagram> @pl \x -> (x,m x)
17:37:09 <lambdabot> ap (,) m
17:37:16 <bananagram> :t ap
17:37:17 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:37:26 <acomar> there's been an open ticket about it for a while, but whoever wrote hbro obviously managed to get around that
17:37:57 <luite> acomar: have you tried doing all webkit interaction in a bound thread?
17:38:41 <Hijiri> @let newtype Fix2 f = Fix2 (f (Fix2 f) (Fix2 f))
17:38:43 <lambdabot>  Defined.
17:38:50 <acomar> luite: no, do you mean creating a single thread to manage the UI and communicating with it from the other threads?
17:38:56 <hodapp> http://lpaste.net/8078387129299763200 - can someone shed some light here as to why the three there are invalid?
17:39:13 <nkar> could anyone help me to define a show instance for a newtype like (newtype Foo = Foo Int) via template haskell?  http://dpaste.com/0VWEN0Z
17:39:24 <nkar> how do I pattern match in 'show'?
17:39:52 <nkar> I just need to "unpack" the value constructor and place the variable on the rhs
17:39:57 <acomar> that said, here's a pretty minimal example that only involves a single thread. The program segfaults when you so much as turn on threading: http://trac.haskell.org/gtk2hs/ticket/1294
17:40:19 <luite> acomar: yeah, but making sure that's run with runInBoundThread. not sure if that's it, but some libs require this. it makes sure that everything is done from the same capability (which runs in a system thread)
17:40:24 <acomar> I just tested with gtk/webkit and gtk3/webkitgtk3
17:40:39 <EvanR> acomar: fun fact the main thread is bound
17:40:39 <acomar> luite: I'll look into it, thanks
17:42:08 <luite> acomar: hmm, i don't see a problem with that code immediately. hamishmack might know more
17:42:50 <bananagram> @pl \m x -> (x,m x)
17:42:50 <lambdabot> ap (,)
17:45:41 <acomar> think I need to read up on bound/unbound threads -- simply wrapping the loadUri call in runInBoundThread isn't sufficient to fix the problem.
17:46:11 <EvanR> you might have to run everything from the main thread
17:47:05 <acomar> the problem is, the gtk library is pretty callback-driven
17:47:28 <EvanR> gtk, i know that works in haskell
17:47:47 <acomar> EvanR: yep, it was working right up until I introduced threading :)
17:47:51 <TallerGhostWalt> why can't I use @ in pattern synonyms?
17:47:55 <acomar> actually, gtk itself handles threading fine
17:48:01 <acomar> it's the webkit library in particular that doesn't
17:48:02 <EvanR> right
17:48:36 <TallerGhostWalt> I want to write: pattern ValidRecordMatch rec fld <- Success rec@(Record {field1=field,..})
17:48:53 <TallerGhostWalt> is there a way around it at least
17:49:15 <orzo> around what?
17:50:36 <TallerGhostWalt> orzo: making it so I can use a pattern synonym to grab a record from inside another type and a field inside that type
17:50:52 <ioajsd> is there a function or pattern that takes a value and passses it as the first and second argument to another function?
17:51:04 <orzo> TallerGhostWalt: usually the rhs of a <- is not a pattern
17:51:14 <EvanR> ioajsd: what is the type of such a function?
17:51:35 <ioajsd> EvanR: foo :: a -> (a -> a -> b) -> b
17:51:45 <orzo> TallerGhostWalt: i'm having trouble thinking of when it is
17:51:48 <hodapp> what would cause an error about a type variable being ambiguous, for a type variable that appears nowhere in the signature?
17:51:52 <EvanR> @hoogle a -> (a -> a -> b) -> b
17:51:55 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
17:51:55 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
17:51:55 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
17:52:10 <EvanR> \o/
17:52:28 <TallerGhostWalt> orzo: but from the wiki "pattern conid varid1 ... varidn <- pat"
17:52:30 <ioajsd> EvanR: i have a feeling there is some way to do it with (->) monad or arrows
17:52:38 <Hijiri> join
17:52:43 <TallerGhostWalt> I took 'pat' in that grammar to mean pattern
17:52:47 <Hijiri> :t join `asAppliedTo` (+)
17:52:48 <lambdabot> Num a => (a -> a -> a) -> a -> a
17:52:57 <Saizan> orzo: it's an extension, PatternSynonyms
17:53:35 <EvanR> hodapp: i know this one... first, variables are introduced all the time by virtue of type inference. the error you got is because theres not enough information to pin down some type class instance
17:53:46 <Hijiri> :t let c + c2 = c:[c2] in join `asAppliedTo` (+)
17:53:47 <lambdabot> (a -> a -> [a]) -> a -> [a]
17:54:10 <Hijiri> > let join (*) = square in square 10
17:54:11 <lambdabot>  Not in scope: ‘square’Not in scope: ‘square’
17:54:19 <Hijiri> ok, I should stop
17:54:41 <TallerGhostWalt> I can see why '@' might be bad to implement for pattern synonyms but it would sure be nice for a lot of cases
17:54:44 <hodapp> EvanR: http://lpaste.net/8078387129299763200 is the particular thing that is stumping me (though I suppose I could simplify a little)
17:54:55 <Saizan> TallerGhostWalt: what error do you get?
17:55:11 <EvanR> hodapp: wheres the error
17:55:23 <hodapp> EvanR: with test, test2, and test3
17:55:40 <TallerGhostWalt> Pattern synonym definition cannot contain as-patterns (@): …
17:55:45 <EvanR> hodapp: so type x could be all kinds of possibilties
17:55:45 <TallerGhostWalt> Saizan: Pattern synonym definition cannot contain as-patterns (@): …
17:56:23 <EvanR> hodapp: oh... and i just ran into that too, the x doesnt appear on the rhs of the type
17:56:38 <hodapp> EvanR: the RHS?
17:56:43 <EvanR> right hand side
17:56:52 <EvanR> (Show x, Enum x, Bounded x) => String
17:56:53 <hodapp> I know what it stands for, that doesn't mean I know what it means
17:56:59 <TallerGhostWalt> I can still use them How I want to in most cases with view patterns to burn through the nesting and do some check, just can't make them bi-directional
17:57:04 <EvanR> x, what x
17:57:14 <hodapp> EvanR: okay, but in test3 and test4, it does
17:57:31 <hodapp> rather, test2 and test3
17:57:35 <EvanR> :t bounds
17:57:36 <lambdabot> Ix i => Array i e -> (i, i)
17:57:45 <hodapp> I define bounds myself
17:58:26 <Saizan> TallerGhostWalt: you could expand out the matching on the record
17:58:33 <hodapp> AllowAmbiguousTypes lets through more of 'test' but then causes other errors
17:58:43 <Hijiri> > 5 :: (Char ~ [Char]) => Int
17:58:44 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
17:58:44 <lambdabot>  Inaccessible code in
17:58:44 <lambdabot>    an expression type signature:
17:59:13 <EvanR> hodapp: im not sure about Proxy
18:00:11 <TallerGhostWalt> Saizan: I don't see how to do that
18:00:32 <hodapp> EvanR: I can make it 'x' instead of 'Proxy x'. The errors don't change.
18:00:47 <EvanR> hodapp: hmm. in test2, if you for an explicit forall x . in the type sig then enable ScopedTypeVariables it might work
18:01:00 <EvanR> s/for an/put an/
18:01:28 <EvanR> hodapp: as it stands, the :: [x], x is a new variable distinct from the x in the top level sig
18:01:47 <hodapp> EvanR: ohhhh....
18:01:51 <hodapp> EvanR: that is indeed a problem
18:03:17 <hodapp> EvanR: the same works with 'test', I just don't totally understand why a 'forall' is required there
18:03:31 <Saizan> TallerGhostWalt: pattern ValidRecordMatch (Record a b c d) a <- Success (Record a b c d)
18:03:46 <EvanR> hodapp: its required to put x in scope for the whole function
18:03:59 <hodapp> EvanR: what is it, implicitly, without that?
18:04:07 <EvanR> only for the type sig
18:04:20 <hodapp> because I thought that everything polymorphic had an implicit 'forall' at the front
18:04:51 <EvanR> yeah its there, but its even more there with ScopedTypeVariables and when its written in
18:05:30 <hodapp> in other words, isn't my type signature implicitly the exact same thing as I just made it to explicitly be?
18:05:53 <EvanR> nope, different scoping
18:06:07 <orzo> it's not clear to me why ScopedTypeVariables wants explicit foralls
18:06:19 <shachaf> Backwards compatiblity, mostly.
18:06:31 <hodapp> EvanR: what I mean is, what is the *implicit* forall?
18:06:42 <hodapp> EvanR: what forall would I write to have an identical type signature?
18:06:56 <shachaf> It's not true that every program that compiles in Haskell 2010 has the same meaning with ScopedTypeVariables turned on, but it's almost true.
18:06:58 <TallerGhostWalt> Saizan: hmm, I get "parse error on input ‘(’"
18:06:59 <EvanR> its still scoped only to the stop level, as if you didnt put it at all or didnt have scoped type vars
18:07:13 <TallerGhostWalt> Saizan: did it work for you?
18:07:22 <hodapp> EvanR: but anything polymorphic has an implicit 'forall', doesn't it?
18:07:55 <EvanR> yes
18:08:29 <hodapp> EvanR: is there a way to write this 'forall' explicitly and have it mean the same thing?
18:08:38 <TallerGhostWalt> Saizan: I thought the lhs was like the lhs of a type synonym, w/o pat match capabilities?
18:08:44 <TallerGhostWalt> pattern conid varid1 ... varidn <- pat ... according to the wiki
18:08:51 <EvanR> the only way i know so far is to turn off ScopedTypeVars
18:09:21 <EvanR> EXTENSIONS ROCK
18:09:31 <Saizan> TallerGhostWalt: mh, i guess so
18:09:38 <TallerGhostWalt> Oh well, not exactly a huge thing
18:09:45 <hodapp> EvanR: in other words: ScopedTypeVars takes implicit and explicit type signatures that would otherwise mean the exact same thing, and makes their meaning different from each other?
18:09:59 <EvanR> yeah, thats what it says in the ghc wiki
18:09:59 <TallerGhostWalt> I am out
18:10:27 <EvanR> you need explicit foralls to use its features
18:11:58 <hodapp> EvanR: ahh, okay.
18:12:05 <orzo> can pattern synonyms let me use these fake constructors as values to?  Destructuring to the expanded syntax?
18:12:50 <hodapp> EvanR: thanks for clarifying
18:16:15 <orzo> i have a newtype WrappedInt = WrappedInt { unexported :: Int } and a bunch of exported pre-defined values of WrappedInt.  This makes it possible for somebody to import my *.Internal and define new symbols of that type, but it prevents nice pattern matching.  PatternSynonyms looks like it might solve that
18:17:59 <orzo> But i would want the exported pattern synonyms to be usable as both patterns and as values, just as if i had originally defined the type with data WrappedInt = A | B | C
18:19:51 <orzo> anybody know if PatternSynonyms enables that?
18:20:35 <Saizan> orzo: yes, for the bidirectional ones
18:20:59 <orzo> interesting
18:21:04 <lifter> I just wrote a function: "monadicIf :: (Monad m) => m Bool -> m a -> m a -> m a "... Anyone know if something like this already exists?
18:21:50 <orzo> does haddock know PatternSynonyms?
18:21:56 <lifter> Like a lifted ifThenElse
18:22:53 <EvanR> lifter: maybe monad-loops or monad-extras
18:23:05 <lifter> are those packages?
18:23:12 <EvanR> yes
18:23:32 <EvanR> you can also try hoogle
18:24:13 <EvanR> :t liftM bool
18:24:14 <lambdabot> Monad m => m a1 -> m (a1 -> Bool -> a1)
18:24:35 <EvanR> :t liftM2 bool
18:24:36 <lambdabot> Monad m => m a2 -> m a2 -> m (Bool -> a2)
18:24:51 <dmwit> wrong type AND wrong behavior
18:25:45 <dmwit> lifting laziness correctly requires a source-to-source transformation AFAIK
18:26:00 <lifter> EvanR: Yeah I actually just realized I could liftM3 on ifThenElse
18:26:13 <lifter> :t ifThenElse
18:26:14 <lambdabot> Not in scope: ‘ifThenElse’
18:26:37 <dmwit> lifter: it won't short cicuit correctly
18:26:44 <lifter> ah
18:26:47 <lifter> hmm
18:27:52 <lpaste> lifter pasted “monadicIf” at http://lpaste.net/120361
18:28:01 <lifter> FWIW, that's what I wrote
18:32:55 <EvanR> whoa thats weird lambda syntax
18:33:42 <orzo> weird and awesome
18:34:24 * dmwit wants multi-parameter \case
18:35:42 <lifter> what's weird about it? Maybe you mean LambdaCase
18:35:50 <lifter> it's a GHC extension
18:36:16 <EvanR> i almost never heard of that
18:36:33 <Axman6> it's fairly new
18:37:33 <lifter> I like it a lot.
18:38:05 <Axman6> dmwit: what would that look like>
18:38:07 <Axman6> ?*
18:38:07 <lambdabot> Maybe you meant: v @ ? .
18:38:08 <orzo> yeah lambdacase is a big win
18:38:18 <EvanR> does Storable make sense for ByteString? if so wheres the instance if not why not
18:39:01 <lifter> Beginning Haskell bk introduced me to a bunch of language extensions
18:39:12 <orzo> bk?
18:39:17 <lifter> the book
18:39:23 <Axman6> IIRC, Storable is for fixed size objects
18:39:24 <lifter> sorry
18:39:30 <pacak> EvanR: What would be sizeOf "foo"?
18:39:42 <EvanR> there ya go
18:39:46 <lifter> ViewPatterns is another nice one
18:40:07 <Axman6> sizeOf (x :: Foo) should not evaluate x
18:40:27 <lifter> ParallelListComp is also handy
18:40:55 <EvanR> i guess storable vector is the go-to then
18:41:47 <EvanR> im kind of confused by the dichotomy
18:42:05 <EvanR> ByteString vs Vector Word8
18:42:15 <lifter> gotta run
18:42:50 <pacak> EvanR: What would be sizeOf (fromList [1,2,3]) then?
18:43:23 <EvanR> in what case
18:43:48 <hodapp> is there some funky construct that is like a combination of Proxy, and something I can 'show' to get the type name of?
18:44:08 <pacak> Are you trying to create Storable instance for Vector? Or I need to get some food...
18:44:21 <EvanR> no
18:44:36 <hodapp> 'show' on the Proxy just returns Proxy o_O
18:44:50 <EvanR> just trying to understand why theres ByteString and Data.Vector.Storable.Vector Word8 and which to use when
18:45:29 <hodapp> is Typeable what I need maybe?
18:46:17 <dmwit> Axman6: Nothing surprising, I guess. Just \case foo bar -> ...
18:46:50 <dmwit> Axman6: e.g. \case (Just 3) () -> "lol"; Nothing _ -> "hi!"; _ _ -> "confusion"
18:46:56 <Axman6> right, that makes sence... could that give you tuples of (foo,bar)?
18:47:01 <lfairy> hodapp: there's typeOf
18:47:05 <Axman6> oh right, that'd be cool
18:47:48 <dmwit> But instead of many parameters, they opted for parenthesis-free single parameters. lame
18:47:56 <hodapp> lfairy: ahh, you're right, I see typeRep and that's about the same I think
18:50:58 <hodapp> well, damn, I'll have to derive from Typeable then
18:51:21 * hackagebot stm-conduit 2.5.4 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.5.4 (ClarkGaebel)
18:52:09 <hodapp> and I guess I'm just avoiding tacking on tons and tons of extensions >_>
18:52:32 <EvanR> LANGUAGE AllTheExtensions
18:52:43 <hodapp> :P
18:53:04 <hodapp> just seems a bit kludgey that to get the name of the type I must add DeriveDataTypeable o_O
18:53:30 <geekosaur> there is discussion about having it just derive them in all cases and making that extension a no-op
18:53:53 <geekosaur> (this may wind up happening if it's needed to fix our current favorite ghc bug)
18:54:08 <hodapp> huh
18:55:00 <hodapp> forall x . (Show x, Enum x, Bounded x, Typeable x) => Proxy x -> Def ('[Uint8] :-> IString)
18:55:07 <hodapp> this is why I shouldn't be allowed to write type signatures
18:55:15 <glguy_> That change to typeable is working
18:55:36 <EvanR> when suddenly, netsplit
18:56:08 <hodapp> my f ault
18:56:11 <hodapp> for that ugly type signature
18:56:24 <hodapp> I don't know what a good number of typeclasses to require is, but I feel like 4 is too many
19:11:10 <dmwit> you don't need an extension to name the type
19:11:40 <dmwit> just to derive it (hence the name of the extension)
19:12:26 * dmwit . o O ( bu what do they CALL the name of the extension? )
19:13:08 <ioajsd> :t (>>=) id
19:13:09 <lambdabot> (a -> a -> b) -> a -> b
19:13:13 <ioajsd> EvanR: ^
19:15:02 <dmwit> :t (=<<) id
19:15:03 <lambdabot> Monad m => m (m b) -> m b
19:15:16 <dmwit> eerily similar
19:15:28 <ioajsd> :t (=<<)
19:15:28 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:15:36 <Datfattechgeek> Hi
19:16:26 <Datfattechgeek> Does anyone in here happen to know anything about doxing?
19:16:36 <dmwit> :t [(>>=) id, (=<<) id]
19:16:37 <lambdabot> [(a -> a -> b) -> a -> b]
19:16:44 <dmwit> ?where ops
19:16:44 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:17:12 --- mode: ChanServ set +o geekosaur
19:17:19 <ioajsd> dmwit: is =<< the same as >>= with params swapped?
19:17:27 <dmwit> ioajsd: yes
19:18:03 <ioajsd> ah that makes sense
19:18:08 <ioajsd> :p 2
19:18:10 <shapr> dmwit: ?
19:18:27 <geekosaur> they left
19:18:27 <ioajsd> do do u eval an expression with lambdabot?
19:18:46 <dmwit> > 2
19:18:48 <lambdabot>  2
19:18:49 <ioajsd> ah
19:19:08 <solirc> ioajsd: Not sure if I understand your question, but you can add both test/ and src/ to hs-source-dirs: of you test suite
19:19:12 <ioajsd> > (>>=) id (*) 2
19:19:14 <lambdabot>  4
19:19:14 --- mode: geekosaur set -o geekosaur
19:19:36 <ioajsd> solirc: yeah i got that already
19:19:49 <ioajsd> > (=<<) id (*) 2
19:19:50 <solirc> ioajsd: Alternatively, if you have a library section and you want to test exposed modules of your library, you can depend on the library instead
19:19:50 <lambdabot>  4
19:19:53 <dmwit> shapr: i figured requests for info on finding personally identifying info on strangers wasn't likely to be followed by something good
19:20:04 <solirc> ioajsd: see https://github.com/hspec/hspec-example/blob/master/strip.cabal for the second approach
19:20:12 <shapr> dmwit: hadn't heard of that before, good call
19:20:15 <ioajsd> solirc: ok thanks
19:21:22 * hackagebot th-orphans 0.9.0 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.9.0 (MichaelSloan)
19:21:27 <ioajsd> > (>>=) 2 2
19:21:29 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> m b))
19:21:29 <lambdabot>    arising from the ambiguity check for ‘e_122’
19:21:29 <lambdabot>  from the context (GHC.Num.Num (a -> m b),
19:21:34 <ioajsd> > (>>=) (*) 2 2
19:21:36 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0) -> a0 -> b))
19:21:36 <lambdabot>    arising from the ambiguity check for ‘e_122’
19:21:36 <lambdabot>  from the context (GHC.Num.Num ((a -> a) -> a -> b), GHC.Num.Num a)
19:21:42 <ab9rf> please don't
19:21:55 <ab9rf> lambdabot has unusual definitions for numbers
19:22:40 <dmwit> > (>>=) (*) 2
19:22:41 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
19:22:41 <lambdabot>    arising from a use of ‘M781212657666382641017234.show_M7812126576663826410...
19:22:41 <lambdabot>  The type variable ‘a0’ is ambiguous
19:22:54 <dmwit> oh, forgot id
19:23:03 * dmwit done
19:28:04 <ioajsd> whats a point-free way to define nand in terms of 'not' and 'and' ?
19:29:00 <Welkin> not . and ?
19:29:48 <shachaf> @pl nand x y = not (and x y)
19:29:48 <Welkin> you can use nand to construct all other logic operators
19:29:49 <lambdabot> nand = (not .) . and
19:29:57 <shachaf> That's pretty ugly so you shouldn't write it point-free.
19:30:11 <ioajsd> oh wait and takes [Bool]
19:30:24 <shachaf> Yes, you might mean (&&) instead.
19:30:30 <ioajsd> right
19:31:15 <Welkin> @pl \x y -> not (x && y)
19:31:15 <lambdabot> (not .) . (&&)
19:31:46 <Welkin> :t and
19:31:47 <lambdabot> [Bool] -> Bool
19:31:59 <ioajsd> Welkin: i think u cant do (not . (&&)) because && takes 2 arguments and not takes one
19:32:23 <Welkin> :t not . and
19:32:24 <lambdabot> [Bool] -> Bool
19:32:39 <ioajsd> Welkin: i meant (&&) not 'and)
19:33:12 <ioajsd> :t (&&)
19:33:13 <lambdabot> Bool -> Bool -> Bool
19:33:15 <ioajsd> :t not
19:33:16 <lambdabot> Bool -> Bool
19:33:35 <ab9rf> (not .) . (&&)
19:34:06 <ab9rf> :t (not .) . (&&)
19:34:07 <lambdabot> Bool -> Bool -> Bool
19:34:20 <ioajsd> that works ab9rf
19:34:36 <ab9rf> > zipWith ( (not .) . (&&) ) [True,True,False,False] [True,False,True,False]
19:34:37 <lambdabot>  [False,True,True,True]
19:34:45 <shachaf> (\x y -> not (x && y)) works even better.
19:35:05 <ioajsd> shachaf: that seems uglier
19:35:35 <ioajsd> idk for some reason i dont like lambdas
19:35:56 <Welkin> ioajsd: that's all there is
19:36:13 <ab9rf> yes, i' would not use the pointfree form unless you actually want to confuse people
19:36:22 <Welkin> the cleanest way to write something is what wins
19:36:40 <Welkin> er, the way that is clearest wins
19:36:48 <ioajsd> so you guys think the lambda is better?
19:36:53 <ab9rf> ioajsd: so do x !&& y = not (x && y) and use (!&&) as an operator
19:37:04 <benzrf> what is GADTSyntax and how is it different from GADTs
19:37:08 <ab9rf> you may need a fixity on !&& to get the desired precedences
19:37:08 <hodapp> dmwit: well, without the extension, would I just have to manually make the type an instance of Typeable?
19:37:43 <ioajsd> ab9rf: makes sense, though i was mostly looking for a way to solve that problem in general
19:37:50 <ab9rf> offhand i don't know the fixity of &&
19:37:54 <ioajsd> the double (.) is what i learned
19:38:26 <hodapp> and chrisdone's not here but I'm finding http://chrisdone.com/posts/data-typeable helpful!
19:38:54 <ab9rf> so yuou wanted a general for form \f1 f2 -> \x y -> f1 (x `f2` y)
19:38:54 <dmwit> hodapp: you cannot make typeable instances without the extension (any more)
19:39:06 <hodapp> good timing, I just read "Happily, we don’t have to write these instances ourselves (and in GHC 7.8 it is actually not possible to do so):" as you said that
19:39:22 <hodapp> but how do I get a type's name without that?
19:39:29 <shachaf> ((.) . (.)) is sort of readable if you remember that (.) is an "SEC" for mapping over the result of a function.
19:39:32 <shachaf> (fmap . fmap)
19:39:40 <ab9rf> that's just (.).(.) which is widely regarded as one of haskell's more amusing operators
19:39:50 <geekosaur> hodapp: it used to be possible to write Typeable instances by hand. now you must tell ghc to derive them itself
19:39:56 <ab9rf> :t (.).(.) not (&&)
19:39:57 <lambdabot>     Couldn't match type ‘Bool’ with ‘b -> c’
19:39:57 <lambdabot>     Expected type: Bool -> b -> c
19:39:57 <lambdabot>       Actual type: Bool -> Bool
19:40:03 <ioajsd> do you guys ever find yourselves writing down the types of expression as they are composed to understand what they do?
19:40:06 <dmwit> you don't need the extension just to USE typeable
19:40:10 <ab9rf> oh, forgot the parns
19:40:12 <geekosaur> because manual Typeable instances can be used to break the type system
19:40:16 <Welkin> ioajsd: of course
19:40:22 <ioajsd> Welkin: okay :D
19:40:26 <shachaf> Please test lambdabot expressions in /msg.
19:40:57 <shachaf> ioajsd: Sometimes, but in a case like this I'd say that it's a clue that you're doing something way too complicated.
19:41:05 <shachaf> \x y -> not (x && y) is simple.
19:41:15 <hodapp> geekosaur: huh, how's that?
19:41:29 <hodapp> dmwit: ah, I see what you mean
19:41:33 <ioajsd> shachaf: yeah but im just doing this to learn, i dont actually need to write a nand function
19:41:53 <ab9rf> ioajsd: you can usually write any given function in haskell in dozerns of different ways
19:41:59 <geekosaur> Data.Typeable.cast, which is supposed to be typesafe, can turn into unsafeCoerce if you are in a position to manipulate the Typeable instance
19:42:04 <shachaf> Right, so imagine how much more complicated it'll be when you're writing real code.
19:42:06 <hodapp> dmwit: what I mean is that I have some arbitrary type (that is not in Typeable already) and I'd like to get its name
19:42:19 <hodapp> dmwit: right now I'm just using the extension to get it in Typeable
19:42:20 <ab9rf> ioajsd: you should prefer to use more readable forms over less readable forms
19:42:28 <ioajsd> okay
19:42:40 <ab9rf> the point is not to write the tersest code possible
19:42:46 <geekosaur> (I believe there are other mechanisms possible, since the Typeable machinery is sometimes used internally; IIRC the GenericNewtypeDeriving extension relies on them?)
19:43:48 <shachaf> geekosaur: Relies on what?
19:44:10 <geekosaur> Typeable
19:44:16 <shachaf> I hope not.
19:44:43 <geekosaur> I may be misremembering the extension (other than Typeable itself) that could be made to blow up with manual Typeable instances
19:45:03 <shachaf> Typeable works by comparing MD5 fingerprints of qualified type names at runtime.
19:46:25 <geekosaur> my vague recollection was that something was using the compile-time support that makes those available at runtime to track types, and could be made to match up types it wasn't supposed to. (an early version of the current deriving-unsafeCoerce issue)
19:46:37 <hodapp> I'm using Typeable to avoid passing a String argument to supply a unique name for an Ivory procedure that is specialized over specific types... which seems a silly use of Typeable. But whatever.
19:47:10 <shachaf> GeneralizedNewtypeDeriving is/was broken but I don't think that was ever directly related to Typeable.
19:49:11 <haskell-beginner> http://pastebin.com/AW47vebH . Can anybody help mw with this error . I am getting a type error
19:49:42 <glguy> haskell-beginner: The type error in question doesn't seem to have made it into that paste
19:50:05 <Zemyla> Woo, my brownian motion code that pregenerates an infinite tree works!
19:51:22 <haskell-beginner> glguy : yes that code is getting loaded, but when I run encodeDirect "aaadddrrrrv"
19:51:27 <haskell-beginner> I get error
19:51:58 <haskell-beginner> gtguy: the function encodedirect' is also working fine
19:52:23 <ab9rf> Zemyla: i read that as "pregnates" at first
19:52:42 <ab9rf> man, hlint hates my code
19:59:27 <haskell-beginner> http://pastebin.com/AW47vebH . Can anybody help mw with this error . I am getting a error when running the function encodeDirect "asdddddqqqqqqqsdx"
20:00:51 <Zemyla> My signature to produce a Brownian function from the system RNG is not a -> IO a, but IO (a -> a). :P
20:01:42 <gcganley> what's cms? its the top trending project for haskell on github.com
20:03:52 <hodapp> gcganley: hrm?
20:05:20 <gcganley> https://github.com/lambdacms/lambdacms-core
20:05:37 <_um> haskell-beginner: It wants a list of integers...
20:06:36 <nkar> is it possible to splice a type constructor such that it can be passed to 'show'?
20:06:42 <haskell-beginner> _um :ok, How to deal with a string like the one I wanted to use?
20:07:47 <hodapp> nkar: hmm, why are you needing to show one exactly?
20:08:10 <_um> haskell-beginner:  I think the problem might be in this big: `helper (n,1) = (Sin n); helper (n,x) = (Mul n x)`
20:08:14 <_um> s/big/bit
20:08:44 <haskell-beginner> _um : Thank you, I understood the mistake
20:08:59 <_um> Oh great! Could you explain it to me! :)
20:09:05 <_um> I'm still trying to work it out...
20:09:52 <haskell-beginner> _um the tuple was wrong. it should be (1,n)
20:10:26 <_um> Oh yeah! But maybe use x instead of `n`, since `n` often stands for numbers ?
20:10:42 <_um> Make sense. Thanks :)
20:10:43 <nkar> hodapp: I'm writing a template haskell function that will generate an instance of the PersistField class.  for fromPersistValue, I want to return an informative error message (something like "expected Foo, got: " <> show v)  where Foo is newtype Foo = Foo Int.  can I do it?
20:10:49 <haskell-beginner> _um : I had forced it to be Int by using (n,1)
20:11:21 <nkar> hodapp: $(conT name) where name is Name gives the type, but I cannot show it
20:11:32 <haskell-beginner> _um : thank you too
20:13:56 <nkar> hodapp: in particular, I'm getting a Type while I need an Exp
20:17:26 <nkar> hm, there's showName :: Name -> String, maybe it'll work
20:23:06 <Zemyla> Hmm. My signature is (RandomGen g) => g -> a -> a. Should I change it to g -> (a -> a, g)?
20:23:57 <Zemyla> It's g -> a -> a because it consumes the entire generator.
20:23:59 <gcganley> Zemyla: whats the function? do you have a repo?
20:24:09 <Zemyla> gcganley: Nope.
20:24:51 <orbisvicis> i've run into a situation where I have nested conditionals: if .. then compute <nested here> else <sameFailResultEveryTime>
20:24:54 <Zemyla> Also, it's entirely undocumented. :V
20:25:00 <orbisvicis> solved using something like: (Just 5) >>= \w -> return (w+10) >>= \i -> return (i+15+w)
20:25:08 <orbisvicis> I'm wondering if there is a neater approach
20:25:19 <Zemyla> orbisvicis: Yeah, use do notation.
20:25:48 <gcganley> Zemyla: im fine with undocumented, as long as i can open it in ghci(-ng) and get the types
20:25:48 <orbisvicis> and if I can use Either, so that Left represent the fail result passed down, and right represents the continued computation
20:26:47 <orbisvicis> that is, if that functionality is already provided by some library
20:30:03 <orbisvicis> forget to test Left.. that is already the builtin behaviour
20:30:49 <orbisvicis> Zemyla: right, good call
20:39:04 <nkar> $(stringE (showName ''Foo)) returns a string, but it's qualified.  can I drop the module name somehow?
20:43:18 <wz1000> > _x + 1
20:43:19 <lambdabot>  Found hole ‘_x’ with type: a
20:43:19 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
20:43:19 <lambdabot>             the inferred type of it :: a at Top level
20:43:50 <wz1000> Why doesn't this infer the type as (Num a) => a?
20:43:52 <acomar> luite, EvanR: gave it a shot, forcing all gtk actions into the main thread, webkit still bombs out.
20:52:35 <nkar> found it!  $(stringE $ nameBase ''Foo)
21:00:45 <yac> How do I turn Crypto-Hash-SHA512 digest ByteString into hexdigest String?
21:02:29 <shachaf> Perhaps SB.unpack b >>= printf "%02x"
21:02:36 <geekosaur> Data.ByteString.Char8.unpack?
21:02:42 <geekosaur> ?
21:02:57 <geekosaur> (oh whoops, malfunctioning client)
21:03:06 <shachaf> No, Data.ByteString.unpack
21:03:15 <shachaf> You have a bunch of bytes, not Chars.
21:03:22 <geekosaur> depends on what exactly you're looking for there. if you want a hex string then you need to unpack to Word8 and then map over that
21:03:57 <dmwit> :t foldMap (printf "%02x")
21:03:58 <lambdabot> (PrintfArg a, PrintfType m, Monoid m, Foldable t) => t a -> m
21:05:10 <dmwit> Data.MonoTraversable.ofoldMap instead, though, of course
21:05:58 <shachaf> Sure, if you want.
21:06:17 <shachaf> concatMap (printf "%02x") . unpack isn't much worse.
21:07:54 <yac> oh yeah, I got it. Found it on stackoverflow :)
21:08:35 <yac> still it's silly this function is not provided by the Crypto library
21:10:42 <EvanR> converting a bunch of bits into a hex string is something the programming language usually does for you
21:10:58 <EvanR> stdlib
21:11:28 * hackagebot test-sandbox-compose 0.1.0 - Lightweight development enviroments using test-sandbox  http://hackage.haskell.org/package/test-sandbox-compose-0.1.0 (junjihashimoto)
21:11:30 * hackagebot test-sandbox-compose 0.1.1 - Lightweight development enviroments using test-sandbox  http://hackage.haskell.org/package/test-sandbox-compose-0.1.1 (junjihashimoto)
21:12:16 <haskell-beginner> http://pastebin.com/r8d7jcea can anybody help me understand the error it gives
21:14:04 <yac> does System.Directory.copyFile work across filesystems?
21:14:42 <ioajsd> haskell-beginner: whats the type of the function?
21:16:24 <haskell-beginner> ioajsd: I think split::[a]->Int->[[a]]
21:16:46 <ioajsd> haskell-beginner: whats it supposed to do?
21:17:58 <haskell-beginner> ioajsd: split "abcdefghik" 3 should split it after 'c' and give ("abc", "defghik")
21:18:17 <EvanR> :t breakAt
21:18:18 <lambdabot>     Not in scope: ‘breakAt’
21:18:18 <lambdabot>     Perhaps you meant one of these:
21:18:18 <lambdabot>       ‘break’ (imported from Data.List),
21:18:22 <EvanR> :t splitAt
21:18:23 <lambdabot> Int -> [a] -> ([a], [a])
21:20:29 <haskell-beginner> thanks I could use break, but I am trying to implement it using the `elemIndex` function
21:20:48 <EvanR> :t elemIndex
21:20:50 <lambdabot> Eq a => a -> [a] -> Maybe Int
21:21:44 <ioajsd> haskell-beginner: elemIndex get the index of an element in the list
21:21:53 <eyebloom> haskell-beginner: Can you explain what those list comprehensions are for?
21:22:02 <ioajsd> not sure how that is useful
21:22:16 <Big_G> > head [1..]
21:22:17 <lambdabot>  1
21:22:35 <haskell-beginner> ys is the list whose elemIndex is less than Just x
21:22:35 <Big_G> > max [1..]
21:22:36 <lambdabot>  <[Integer] -> [Integer]>
21:22:44 <haskell-beginner> x is where we want to split
21:22:44 <eyebloom> I see, the parts of the list above and below x
21:23:07 <ioajsd> > (\list n -> (take list n, drop list n)) ['a' .. 'z'] 3
21:23:09 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
21:23:09 <lambdabot>              with actual type ‘[GHC.Types.Char]’
21:23:21 <haskell-beginner> eyebloom : yes
21:23:36 <ioajsd> > (\list n -> (take list n, drop list n)) 3 ['a' .. 'z']
21:23:38 <lambdabot>  ("abc","defghijklmnopqrstuvwxyz")
21:23:48 <ReinH> haskell-beginner: but in order to use elemIndex, you have to know the contents of the list beforehand
21:24:13 <ReinH> if you know the contents of the list, you don't need elemIndex
21:24:25 <eyebloom> why not just recurse through the list and accumulate the above list as you go.
21:25:07 <ReinH> elemIndex doesn't make any sense here
21:25:37 <haskell-beginner> :ReinH I think I am giving the list on which elemIndex is applied
21:25:53 <ReinH> haskell-beginner: but you have to know the contents of the list
21:25:56 <ReinH> you can't write it for any list
21:26:06 <jle`> Big_G: are you looking for maximum?
21:26:25 <Big_G> jle`, I am
21:26:38 <ReinH> If you traverse the list to use elemIndex on each element, then you've already traversed the list, so you don't need elemIndex
21:27:44 <ab9rf> i don't like using indexed access into lists; for one, it's slow :)
21:28:22 <jle`> it also is a smell that list is not the right data structure for what you want :)
21:28:24 <haskell-beginner> ReinH : I am traversing the list and finding the point I want to split. The split point is dependent on the index
21:28:39 <ReinH> haskell-beginner: but you're traversing the list, so you already know where you are
21:28:48 <ab9rf> why is it dependent on the index?
21:28:52 <ReinH> you don't need to re-traverse the list to find out where you are
21:29:10 <ab9rf> if you want to split at, say, the first element that meets a criterion, then yuo just traverse until you hit that point, and split there
21:29:57 <ReinH> The easiest way to write this function is what ioajsd suggests: splitAt n xs = (take n xs, drop n xs)
21:30:08 <EvanR> @src splitAt
21:30:09 <lambdabot> splitAt n xs = (take n xs, drop n xs)
21:30:46 <EvanR> but its wasting time traversing it twiceeeee
21:30:57 <ReinH> EvanR: is it?
21:31:02 <ReinH> Does it traverse the entire list twice?
21:31:06 <EvanR> no
21:31:17 <haskell-beginner> ok, thank you.
21:32:12 <ReinH> The Prelude actually uses a different definition that only traverses once
21:32:53 <ReinH> The one given by @src is the one defined by the report.
21:33:24 <ab9rf> take n xs has to traverse the first n elements of xs
21:33:36 <ab9rf> drop n xs also has to traverse the first n elements of xs
21:33:39 <ReinH> ab9rf: Right, it does n extra work, not length xs
21:34:00 <ab9rf> is this a case where stream fusion can avoid the extra work?  i'm not clear on how that works
21:34:06 <ReinH> ab9rf: no
21:34:08 <ReinH> there's nothing to fuse
21:36:35 <jle`> so the asymptotics are good
21:37:17 <codygman> In Aeson eitherDecode returns Either String a and short circuits on error. Is there an existing way to just generate a list of errors and return a [Either String a]?
21:37:38 <jle`> what is eitherDecode?
21:37:53 <ReinH> codygman: Not that I know of, but I have often wanted it. I think you mean Either [String] a though.
21:38:09 <EvanR> unless were talking about money, 2x speed up is unlikely to matter. its either still slow, or its still fast
21:38:19 <codygman> jle`: https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#v:eitherDecode
21:38:36 <ab9rf> list of errors?
21:38:37 <ReinH> EvanR: you're the one who brought up the "wasted time"
21:38:41 <ab9rf> as in all the errors, not just the first once?
21:38:45 <EvanR> i was joking
21:39:07 <Moggle> ab9rf: If you're familiar with imperative coding, stream fusion might make a little more sense. Imagine you've got two for loops, each executing the same number of times over the same data. for (...) do1(); for (...) do2();. Those for loops waste a lot of time checking, since you'll want to do an "if i < whatever" check each time. Stream fusion just combines the do1() and do2() statements.
21:39:10 <pacak> codygman: There will be no useful information in remaining errors since parsing is incremental.
21:39:54 <ab9rf> Moggle: that doesn't actually help much :)
21:40:00 <Moggle> sorry! :(
21:40:15 <ab9rf> Moggle: i'll go find an article on it, it's not important right now
21:40:17 <ReinH> ab9rf: http://code.haskell.org/~dons/papers/icfp088-coutts.pdf
21:40:28 <ab9rf> ooh, article
21:41:20 <codygman> pacak: Really? So I'll have to use Object for mixed-type objects right? It seems like it'd be useful to allow a parse mode that trys to keep parsing even when one item in the json list is a failure.
21:41:22 <ReinH> ab9rf: And stream fusion as I understand it is more about eliminating intermediate results like lists, i.e., deforestation
21:41:40 <acomar> anyone know how to work around this issue? http://trac.haskell.org/gtk2hs/ticket/1294
21:42:02 <bramgg> Trying to run GHC and I'm getting a "can't load .so/.DLL for: libgmp.so" error. Looks like I need to symlink libgmp.so.10 to libgmp.so, but where should I do this? The error message doesn't tell me where it expects the file.
21:42:02 <acomar> effectively, compiling webkit with threaded causes webkit actions to segfault.
21:42:21 <codygman> pacak: In the context of a json list that is, the parse would be greedy matching every element it could and returning Left values for those with errors.
21:42:22 <acomar> I've already tried explicitly moving webview actions into the main (bound) thread
21:42:26 <ab9rf> ReinH: yeah, i get that from the article.  i'd heard the term and knew it had to do with optimizing operations on lists, but nothing more than that.  thanks for the article, i'll read it and maybe evne unbderstand a bit of it
21:42:42 <ReinH> ab9rf: np
21:42:52 <ioajsd> whats a point free version of splitAt?
21:43:08 <acomar> bramgg: it should be dynamically linked at run time. What distro/OS are you on?
21:43:22 <ReinH> ab9rf: as I understand it, something like map f . map g will require only one traversal due to lazy evaluation.
21:43:29 <jle`> ioajsd: you mean a point free definition?
21:43:38 <ioajsd> jle`: yea
21:43:38 <EvanR> @pl \i xs -> (take i xs, drop i xs)
21:43:38 <lambdabot> ap (ap . ((,) .) . take) drop
21:43:41 <acomar> ioajsd: take n &&& drop n
21:43:44 <ReinH> ab9rf: as in, take 10 . map id . map id $ [1..] doesn't require stream fusion to work
21:43:54 <jle`> acomar: you left a point in ;)
21:44:06 <ioajsd> acomar: 'n' ?
21:44:08 <acomar> jle`, true enough
21:44:28 <jle`> :t liftA2 (&&&) take drop
21:44:29 <lambdabot> Int -> [a] -> ([a], [a])
21:44:29 <codygman> pacak: Of course aeson is based on applicatives though right, which short circuit... so not sure how that would work.
21:44:31 <ioajsd> EvanR: wait wat?
21:44:36 <ioajsd> omg
21:44:45 <ioajsd> jle`: thats arrow magic?
21:44:47 <bramgg> acomar: debian linux
21:44:48 <jle`> > liftA2 (&&&) take drop 4 [1..10]
21:44:50 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
21:44:50 <ioajsd> gotta learn that still
21:44:53 <jle`> ioajsd: no, it's not arrow magic
21:45:04 <ReinH> It would be better if pointfree know fanout (&&&), it helps with a lot of things.
21:45:05 <bramgg> acomar: If it means anything, I just got this error after upgrading all my packages
21:45:10 <jle`> it's just (\f g x -> (f x, g x)), for (->)
21:45:10 <ReinH> s/know/knew
21:45:15 <bramgg> and doing general clean up
21:45:24 <ioajsd> jle`: idk seems pretty magical to me
21:45:37 <acomar> bragmm: http://www.linuxquestions.org/questions/debian-26/squeez-ghc6-libgmp-so-10-not-found-4175496258/
21:45:37 <jle`> it's just a normal combinator on (->)
21:45:47 <jle`> (&&&) is liftA2 (,)
21:45:50 <jle`> :t liftA2 (,)
21:45:51 <lambdabot> Applicative f => f a -> f b -> f (a, b)
21:45:58 <codygman> ioajsd: I remember when $ seemed magical
21:45:59 <jle`> for (->) a
21:46:05 <acomar> bramgg: looks like you want to install libgmp10
21:46:14 <acomar> depends on which version of debian you're on
21:46:19 <ioajsd> jle`: i dont know arrows so i dont know what you're talking about i dont even know what liftA2 does
21:46:31 <ReinH> :t (&&&)
21:46:32 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:46:33 <jle`> ioajsd: i gave a definition though...it didn't even involve arrows
21:46:38 <ReinH> It isn't quite liftA2 (,)
21:46:45 <jle`> f &&& g = \x -> (f x, g x)
21:46:50 <jle`> :)
21:47:05 <platz> > take 4 &&& drop 4 $ [1..10]
21:47:07 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
21:47:07 <jle`> ReinH: for the case we are using it, it is :)
21:47:08 <ioajsd> oh liftA2 is applicative
21:47:12 <ioajsd> dont know that either
21:47:14 <ReinH> specialized to (r->), yes, it's fanout.
21:47:25 <bramgg> acomar: it's installed
21:47:32 <jle`> ioajsd: the way we're using (&&&) here isn't related to Arrow, it's just f &&& g = \x -> (f x, g x)
21:47:47 <ioajsd> jle`: ah right
21:47:49 <acomar> bramgg: it was already installed?
21:47:54 <bramgg> acomar: yes
21:48:02 <ReinH> jle`: I wish you could say Arrow (~>) => a ~> b -> a ~> b' -> a ~> (b,b')
21:48:10 <jle`> yeah that would be pretty nice
21:48:10 <codygman> ioajsd: it was useful to think of applicative as an interface for me at first.
21:48:18 <codygman> > liftA (+ 1) (Just 1)
21:48:19 <acomar> bramgg: hmm, try using locate to find the file, maybe your LD_LIBRARY_PATH is screwed up
21:48:20 <lambdabot>  Just 2
21:48:22 <jle`> also using `a` for the type variable is a little silly
21:48:33 <ReinH> jle`: "a" for "arrow"?
21:48:37 <jle`> yeah
21:48:51 <jle`> a is usually used for like...the type the constructor is applied to
21:48:58 <jle`> using a as a type constructor is kind of confusing
21:48:59 <ReinH> p for profunctor :p
21:49:08 <ReinH> But I get your point
21:49:14 <EvanR> f for frankenstein
21:49:15 <jle`> i use r normally heh
21:49:41 <acomar> jle`, what do you mean by a as a type constructor?
21:49:49 <acomar> in arrow?
21:49:49 <jle`> :t first
21:49:50 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
21:49:52 <jle`> acomar: yeah, like that
21:50:07 <jle`> it's the type variable used for Arrow
21:50:10 <codygman> ReinH: Indeed it's not quite liftA2
21:50:16 <acomar> I think it's supposed to follow the Functor == f, Monad == m kind of pattern
21:50:20 <codygman> > liftA2 (,) (Just 1, Nothing)
21:50:21 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a1)
21:50:21 <lambdabot>    arising from a use of ‘M689528031063424167320388.show_M6895280310634241673...
21:50:21 <lambdabot>  The type variable ‘a1’ is ambiguous
21:50:22 <acomar> so Arrow == a
21:50:30 <codygman> > Just 1 &&& Nothing
21:50:31 <lambdabot>  Couldn't match type ‘a b’ with ‘Data.Maybe.Maybe’
21:50:31 <lambdabot>  Expected type: a b c
21:50:31 <lambdabot>    Actual type: Data.Maybe.Maybe cCouldn't match type ‘a b’ with ‘Data.Maybe....
21:50:32 <jle`> acomar: yes, i see the intent.  but it's still confusing :P
21:50:35 <platz> > (,) <$> take 4 <*> drop 4 $ [1..10]
21:50:37 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
21:50:40 <ReinH> codygman: specialized to (r ->) it is the same as liftA2 (,) specialized to (r ->) :)
21:50:41 <acomar> fair enough
21:51:04 <jle`> ioajsd: for functions, liftA2 f g h = \x -> f (g x) (h x)
21:51:04 <bramgg> acomar: here's the output of "locate libgmp", you can see that libgmp.so.10 is there. Anything jump out at you? http://pastebin.com/0p1k4RCE
21:51:14 <jle`> ioajsd: so it applies both g and h to x, and then applies f to the finalr esult
21:51:24 <jle`> liftA2 (,) g h = \x -> (g x, h x)
21:51:27 <jle`> :)
21:51:46 <jle`> it's pretty handy when you want to "run two functions on the same input", and then "combine the final result"
21:52:02 <ioajsd> jle`: yeah i see
21:52:13 <jle`> > liftA2 (++) (take 3) reverse "hello world"
21:52:15 <lambdabot>  "heldlrow olleh"
21:52:15 <acomar> bramgg: try running "LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu:$LD_LIBRARY_PATH ghc"
21:52:49 <ab9rf> "heldlrow olleh" is clearly the worst pen name ever
21:52:58 <jle`> worst, or best?
21:53:14 <ab9rf> you try to pronounce "heldlrow"
21:53:15 <bramgg> acomar: will do, LD_LIBRARY_PATH is currently empty btw
21:53:30 <ab9rf> my tongue gets stuck between the l and the r
21:53:33 <acomar> bramgg: it usually is, but it's best to safe
21:53:57 <platz> not sure, applicative instance for (->) feels like obfuscation sometimes
21:54:10 <platz> would rather prefer
21:54:12 <platz> > let xs = [1..10] in (take 4 xs, drop 4 xs)
21:54:14 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
21:54:34 <jle`> yes, as would i
21:54:40 <jle`> but someone asked for a pointfree version
21:54:43 <jle`> ...for some reason
21:54:55 <ab9rf> i liked the one lambdabot created
21:54:57 <jle`> hopefully they don't actually intend to code in that style
21:55:09 <ab9rf> one that resembled line noise, reminding you why yhou shouldn't use pointfree code :)
21:55:16 <bramgg> acomar: did you mean to add the "ghc" at the end there? That gives a "no input files" error. I set my LD_LIBRARY_PATH to what you said though, but am still getting the same error from GHC.
21:55:28 <EvanR> whats the opposite of point free, point saturated
21:55:37 <jle`> pointful?
21:55:37 <ab9rf> pointy
21:55:46 <ioajsd> jle`: its just for learning
21:55:48 <jle`> @unpl liftA2 (,) take drop
21:55:48 <lambdabot> liftA2 (,) take drop
21:55:54 <jle`> ;_;
21:55:58 <EvanR> wurt
21:56:07 <Zemyla> @unpl flip id
21:56:07 <lambdabot> (\ b c -> c b)
21:56:09 <jle`> @pl \xs n -> (take n xs, drop n xs)
21:56:09 <lambdabot> ap (ap . ((,) .) . flip take) (flip drop)
21:56:24 <ab9rf> anything with chained aps just needs to be shot.
21:56:26 <jle`> @unpl ap (ap . ((,) .) . flip take) (flip drop)
21:56:26 <lambdabot> (\ d -> return ((\ p u b -> (u >>= \ q -> return ((\ ab -> ((,)) (take ab p)) b q)) b) d ((\ f g -> drop g f) d)) d)
21:56:27 <Zemyla> :t splitAt
21:56:27 <lambdabot> Int -> [a] -> ([a], [a])
21:56:32 <ab9rf> ouch!
21:56:41 <ab9rf> return to pub
21:56:46 <jle`> @. unpl pl \xs n -> (take n xs, drop n xs)
21:56:46 <lambdabot> (\ d -> return ((\ p u b -> (u >>= \ q -> return ((\ ab -> ((,)) (take ab p)) b q)) b) d ((\ f g -> drop g f) d)) d)
21:56:50 <jle`> sounds legit
21:56:51 <statusfailed> Anyone have a reference for implementing evaluation of untyped lambda calculus programs?
21:56:52 <ioajsd> what is this @pl? does it exist in ghci?
21:57:01 <ab9rf> ioajsd: no, it's a lambdabot function
21:57:01 <statusfailed> ioajsd: I think it's a lambdabot plugin
21:57:10 <ioajsd> ah
21:57:11 <jle`> well...it's more of a program
21:57:13 <ab9rf> ioajsd: check the hackage page for lambdabot, you can run it locally if you like
21:57:17 <ReinH> ioajsd: it exists as the pointfree executable as well on hackage
21:57:25 <ReinH> @hackage pointfree
21:57:25 <lambdabot> http://hackage.haskell.org/package/pointfree
21:57:25 <platz> theres a command line version of pl
21:57:27 <ioajsd> i see
21:57:30 <platz> and unpl
21:57:40 <jle`> pl is an actual thing apart from lambdabot
21:57:41 <ab9rf> i think it's also possible to incorporate it into ghci
21:57:44 <Zemyla> ReinH: I tried downloading that, and it didn't work.
21:58:05 <ioajsd> Zemyla: cabal install pointfree worked for me
21:58:12 <acomar> bramgg: Not sure, out of ideas. Your best lead is probably to keep investigating ghc on your version of debian and see if anyone else has had the same issue
21:58:57 <bramgg> acomar: okay, thanks for trying
22:01:30 * hackagebot exceptions 0.7 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.7 (EdwardKmett)
22:03:15 <adas> I read a few pages about stackage and LTS haskell. I'm still a bit confused as to what exactly is the difference between them. It seems like they both server the same purpose.
22:03:17 <ab9rf> i need to understand co- things better, i think
22:05:05 <jle`> ab9rf: the key is that co- things are not very alike with eachother
22:05:20 <bramgg> acomar: creating a symlink "libgmp.so" pointing to "libgmp.so.10" in the same dir as "libgmp.so.10" worked!
22:05:21 <jle`> they are all just their own thing
22:05:24 <shachaf> They aren't?
22:06:00 <jle`> yeah, it's a little meaning to understand the set of co-things
22:06:08 <jle`> *a little meangliness
22:06:29 <jle`> there isn't a global universal co-behavior that all co-objects satisfy.  co is a symmetric term too
22:06:35 <jle`> so a comonad is a non-co cocomonad
22:06:47 <jle`> a monad is a cocomonad
22:07:06 <jle`> you can understand the process of constructing a co- thing from a thing
22:07:12 <acomar> bramgg: awesome -- you generally want to avoid stuff like that because there are usually incompatibilities that can cause issues
22:07:14 <shachaf> Oh, you don't mean that a co-foo isn't like a foo.
22:07:17 <acomar> apparently that's not the case this time
22:07:23 <jle`> shachaf: ah yes, i see how that could be drawn from that
22:07:25 <jle`> yeah, i no
22:07:50 <jle`> um
22:07:52 <jle`> yeah, no
22:08:48 <ReinH> jle`: such words wow
22:08:53 <jle`> ikr
22:09:07 <acomar> oh god, http://comments.gmane.org/gmane.comp.lang.haskell.gtk2hs/3193
22:09:09 <jle`> it's a bit of a mess...can i just bbp it
22:09:34 <shachaf> No, stop saying that.
22:09:49 <jle`> i'm going to make it a thing
22:09:55 <glguy> shachaf: I don't think the 3LP has been adopted yet
22:09:57 <jle`> it's going to happen
22:09:59 <acomar> so apparently, multithreaded webkit is breaking because the ssl library webkit calls uses gmp and ghc is hooking a custom malloc for ffi calls
22:11:02 <shachaf> No, it's just annoying.
22:11:46 <glguy> acomar: I remember hearing there was some work to get GHC to not need the custom alloactor
22:12:04 <acomar> glguy: any clue what the status on that is?
22:12:22 <jle`> i'll try to refrain from intentionally annoying people then.  but when it happens and is a thing, it isn't something i can stop.
22:12:32 <jle`> i can only control my own words
22:12:37 <acomar> glguy: my only current workaround is to rebuild ghc with INTEGER_LIBRARY=integer-simple
22:13:15 <glguy> acomar: https://ghc.haskell.org/trac/ghc/ticket/9281
22:13:34 <acomar> glguy, thanks
22:14:02 <acomar> looks like I'm putting this project off until 7.10...
22:14:29 <glguy> GHC-7.10.1-rc2 is available if you want to experiment
22:14:43 <acomar> I've never had any luck building ghc
22:14:53 <acomar> nix or not
22:14:59 <glguy> Oh, OK!
22:15:07 <ab9rf> ghc is a LONG build
22:15:11 <jle`> i'm thinking of just dev-ing on ghc-7.10.  so much of my library is written differently just to cope around the lack of AMP, so when it comes out eventually anyway, i'm going to have to change it.  i might just target a date after 7.10
22:15:24 <acomar> yea, and watching it bomb out 4 hours in isn't fun :/
22:15:40 <ReinH> 4 hours? I don't remember it taking 4 hours.
22:16:08 <ab9rf> one of my pie-in-the-sky yea-right ideas is to get ghc to build in visual studio :)
22:16:23 <acomar> ReinH: I was compiling in a nixos vm, only two cores
22:16:25 <pacak> 4 hours? Are you using your phone to compile it?
22:16:43 <ReinH> Still. o_O
22:17:07 <acomar> maybe it bombed out sooner, wasn't timing it
22:18:07 <jle`> i guess i can be happy to say that today is the day when it is a realistic thing to target a world with AMP implemented
22:18:12 <lpaste> orbisvicis pasted “swapFromMaster not in scope? (but swapToMaster is)” at http://lpaste.net/120368
22:18:51 <orbisvicis> ^ maybe it is a very obvious typo, but I'm not seeing why the function isn't defined ?
22:19:04 <jle`> i might just set up 7.10 to experience the feeling when i first use `fmap` in a Monad m => ... function
22:19:27 <jle`> i can taste it...
22:19:58 <ab9rf> "cocomonad" sounds like a good name for a candy bar
22:22:18 <ReinH> orbisvicis: iinm, the where clause is only for the last definition.
22:24:33 <orbisvicis> ReinH: why?
22:25:07 <jle`> Moggle: what would happen if you put a where clause for the second to last definition?
22:25:08 <_um> orbisvicis: Because you have it in a `where` in the last clause.
22:25:12 <jle`> er, orbisvicis , sorry
22:25:17 <_um> But you're calling it in the second to last clause.
22:25:24 <_um> Which doesn't have the where in scope.
22:25:52 <jle`> if you ahd a where clause for the second to last definition...would you expect the entire thing to have it in scope? or only the second to last definition? or everything above that one?
22:26:17 <ReinH> orbisvicis: because where clauses bind to a single definition.
22:26:32 * hackagebot ghc-parser 0.1.4.0 - Haskell source parser from GHC.  http://hackage.haskell.org/package/ghc-parser-0.1.4.0 (gibiansky)
22:27:46 <_um> I think that might be cleaner with a case, no?
22:30:06 <_um> e.g., http://lpaste.net/120369
22:30:20 <_um> That should take care the where being in scope, plus you have less code repeated.
22:30:25 <_um> ^ orbisvicis
22:31:32 * hackagebot ipython-kernel 0.3.0.0 - A library for creating kernels for IPython frontends  http://hackage.haskell.org/package/ipython-kernel-0.3.0.0 (gibiansky)
22:31:35 * hackagebot ihaskell 0.5.0.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.5.0.0 (gibiansky)
22:31:37 * hackagebot ihaskell-aeson 0.2.0.0 - IHaskell display instances for Aeson  http://hackage.haskell.org/package/ihaskell-aeson-0.2.0.0 (gibiansky)
22:31:39 * hackagebot ihaskell-blaze 0.2.0.0 - IHaskell display instances for blaze-html types  http://hackage.haskell.org/package/ihaskell-blaze-0.2.0.0 (gibiansky)
22:31:41 * hackagebot ihaskell-basic 0.2.0.0 - IHaskell display instances for basic types  http://hackage.haskell.org/package/ihaskell-basic-0.2.0.0 (gibiansky)
22:31:46 <orbisvicis> that makes sense. sorry, tired - thought you meant swapFromMaster by "second definition"
22:32:51 <orbisvicis> heh, yeah in hindsight it is completely obvious
22:34:07 <_um> orbisvicis: Well, fwiw, it took me a bit to recognize it! (but I'm pretty green...).
22:34:28 <lars2> sdf
22:34:46 <_um> orbisvicis: I didn't know you could do function signatures in where clauses! I guess you can do them anywhere because it's just specifying the type for some value.
22:34:53 <_um> But that's very handy to know!
22:35:30 <orbisvicis> _um: the case statement *is* cleaner, btw
22:36:11 <_um> orbisvicis: I read something compelling recently about why it's often preferable to use case statements over clausal, equational definitions....
22:36:17 <_um> It made some good points...
22:36:26 <orbisvicis> _um: link ?
22:36:33 * hackagebot ihaskell-charts 0.2.0.0 - IHaskell display instances for charts types  http://hackage.haskell.org/package/ihaskell-charts-0.2.0.0 (gibiansky)
22:36:35 <_um> I'll see if I can find it (or maybe someone here knows what I'm talking about). Looking now
22:36:35 * hackagebot th-alpha 0.2.0.1 - Alpha equivalence for TH Exp  http://hackage.haskell.org/package/th-alpha-0.2.0.1 (jkarni)
22:36:37 * hackagebot ihaskell-diagrams 0.2.0.0 - IHaskell display instances for diagram types  http://hackage.haskell.org/package/ihaskell-diagrams-0.2.0.0 (gibiansky)
22:36:39 * hackagebot ihaskell-hatex 0.2.0.0 - IHaskell display instances for hatex  http://hackage.haskell.org/package/ihaskell-hatex-0.2.0.0 (gibiansky)
22:36:39 <ab9rf> i tend to prefer case too
22:36:41 * hackagebot ihaskell-juicypixels 0.2.0.0 - IHaskell - IHaskellDisplay instances of the image types of the JuicyPixels package.  http://hackage.haskell.org/package/ihaskell-juicypixels-0.2.0.0 (gibiansky)
22:36:42 <Zemyla> > (fix $ join . flip flip [] . ((foldr . ((const . uncurry (++)) .) . liftM2 second (:)) .) . (. (flip (partition . (>=)) . tail)) . (.) . join (***)) [5, 1, 3, 2, 4::Int]
22:36:43 <lambdabot>  [1,2,3,4,5]
22:37:13 <ab9rf> beh
22:37:19 <ab9rf> a lot of work to generate [1..5]
22:37:28 <nkar> is there a way to apply a function like (f :: a -> Text) to a template haskell Name?  e.g. do x <- newName "x"; ...; f $(varE x)?
22:40:38 <Zemyla> ab9rf: I just love that you can write pretty much anything (that doesn't involve cases) in point-free style.
22:41:13 <ab9rf> Zemyla: yeah, but fix?  really?
22:41:39 <Hijiri> you can use destructors instead of cases
22:41:43 * hackagebot ihaskell-magic 0.2.0.0 - IHaskell display instances for bytestrings  http://hackage.haskell.org/package/ihaskell-magic-0.2.0.0 (gibiansky)
22:41:45 * hackagebot ihaskell-parsec 0.2.0.0 - IHaskell display instances for Parsec  http://hackage.haskell.org/package/ihaskell-parsec-0.2.0.0 (gibiansky)
22:41:47 * hackagebot ihaskell-rlangqq 0.2.0.0 - a rDisp quasiquote to show plots from Rlang-QQ in IHaskell  http://hackage.haskell.org/package/ihaskell-rlangqq-0.2.0.0 (gibiansky)
22:41:49 <Hijiri> of course you first need to define the destructors
22:43:32 <orbisvicis> _um: btw any reason you left s@(), both s' (case) are equivalent, right ?
22:43:42 <Zemyla> Hijiri: Like maybe and either?
22:43:46 <Hijiri> Zemyla: yes
22:44:02 <Zemyla> ab9rf: You need fix to have recursion.
22:44:22 <ab9rf> Zemyla: i realize that. i have no idea what that code does.
22:44:31 <ab9rf> Zemyla: a sort?
22:44:46 <ab9rf> oh, that's a quick sort, isn't it?
22:44:50 <_um> orbisvicis: Nope! just sloppy. Sorry. That could be an otherwise I think, right?
22:45:06 <ab9rf> just going on the (partition . (>=))
22:45:17 <_um> orbisvicis: I can't track down the article I had mind.
22:45:32 <ab9rf> aw, i wanted to see that article too
22:45:37 <orbisvicis> _um: np
22:45:45 <_um> okay... I'll keep looking then.
22:45:54 <orbisvicis> _um: yeah otherwise is right
22:46:28 <lars2> > fix (1:)
22:46:29 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:46:30 <_um> orbisvicis: That's good to because it guarantees exhaustion of all possibilities for the match.
22:46:31 <orbisvicis> _um: np, as in don't bother if you can't find it
22:46:35 <ab9rf> there's nothing "magic" about otherwise, right?  it could be "gesundheit" and it would work the same way
22:46:36 <Zemyla> ab9rf: Yeah, it is. I wanted to do mergesort, but it was more complicated/
22:46:40 <ab9rf> Zemyla: hehe
22:46:43 <_um> I kind of want to read it again.
22:46:44 <_um> :)
22:46:50 <lars2> can any recursion be expressed with fix?
22:46:54 <ab9rf> lars2: yes
22:49:15 <ab9rf> i only mention the "otherwise" issue because i had "otherwise" in some code and hlint bitched at me about it
22:49:16 <jle`> ab9rf: fix is required if you want to write a recursive function point-free
22:49:26 <johnw_> or a recursive lambda
22:49:27 <ab9rf> jle`: obviously
22:49:35 <jle`> oh someone already said so
22:49:37 <jle`> oops
22:50:03 <ab9rf> jle`: well, i knew that anyway. i think someone else had the question :)
22:50:03 <jle`> _um: if you look in the source, you'll see `otherwise = True`
22:50:25 <_um> darn...
22:50:29 <_um> Can't find it.
22:51:05 <jle`> _um: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Base.html#otherwise
22:51:20 <jle`> otherwise               :: Bool
22:51:22 <jle`> otherwise               =  True
22:51:23 <ab9rf> i realized that when i say "otherwise" it's just binding "otherwise" t whatever is there and succeeding
22:51:25 <_um> jle`: True. So I guess if the thing evaluated by case = False, wouldn't match that?
22:51:37 <jle`> what do you mean?
22:51:41 <_um> *it wouldn't match that?
22:51:52 <_um> I don't know. never mind.
22:51:56 <ab9rf> so i replaced it with _ and hlint shut up
22:52:04 <_um> I think maybe you meant to answer ab9rf's question?
22:52:11 <jle`> if you attempted to pattern match on `otherwise`, it'll be the same as pattern matching on `x`
22:52:14 <jle`> so in a sense, it does work that way ;)
22:52:27 <jle`> > case True of False -> "hello"; otherwise -> "world"
22:52:28 <lambdabot>  "world"
22:52:35 <ab9rf> jle`: i've seen people use "otherwise" in case satements to mean "match anything"
22:52:56 <_um> > case False of True -> "Hello"; otherwise -> "World"
22:52:56 <johnw_> ab9rf: not in case statements, that's almost always wrong
22:52:57 <lambdabot>  "World"
22:52:59 <jle`> in that case though, otherwise isn't = True
22:53:00 <johnw_> they are for guards
22:53:00 <ab9rf> jle`: and only tonight i realized that "otherwise" isn't magic, you could put anything at all there, including _
22:53:11 <jle`> it's just a binding
22:53:18 <_um> right.
22:53:22 <jle`> people are supposed to use otherwise for guards, though
22:53:24 <ab9rf> johnw_: yeah, i think that's probably how that happened
22:53:25 <jle`> not pattern matches
22:54:10 <jle`> > let foo x | even x = "hey" | otherwise = "you" in foo 10
22:54:11 <lambdabot>  "hey"
22:54:16 <ab9rf> so i swiched it to _ and hlint was happy
22:54:33 <jle`> you can't do that for guards ;)
22:54:46 <ab9rf> indeed, guards don't pattern-match
22:54:48 <jle`> > let foo x | even x = "hey" | _ = "you" in foo 10
22:54:49 <lambdabot>  Found hole ‘_’ with type: GHC.Types.Bool
22:54:49 <lambdabot>  Relevant bindings include
22:54:50 <lambdabot>    x :: a (bound at <interactive>:1:9)
22:55:01 <jle`> > let foo x | even x = "hey" | True = "you" in foo 11
22:55:02 <lambdabot>  "you"
22:55:14 <jle`> it's just the first thing that is True, so True matches always
22:55:22 <jle`> if that answers your question _um
22:55:36 <ab9rf> sorry for the diversion
22:58:23 <_um> Yep, thanks.
22:59:25 <_um> Shucks. Since I can't find that article, the points I remember were:
22:59:49 <_um> 1. Often you only need to match on one variable any how, and then case yields less repetition.
23:00:48 <_um> 2. maybe? it's easier to be sure you have exhaustive matches with case statements? And maybe...if I'm not totally off base...the compiler can catch non-exhaustive matches in case statements but not in equational definitions?
23:01:05 <_um> And I can't remember anything else :(
23:05:11 <orbisvicis> _um: maybe s/equitional/lambda ?
23:07:08 <orbisvicis> but anyway, its late, so..
23:07:14 <_um> Indeed it is...
23:07:20 <_um> I'm off myself.
23:07:20 <orbisvicis> heh
23:07:22 <orbisvicis> later
23:10:16 <julianleviston> In realworldhaskell, how come defining a new type, I can’t label the “fields”…
23:10:41 <johnw_> you can
23:10:47 <johnw> using record syntax
23:11:08 <johnw> data Foo = Foo { fooField1 :: Int; fooField2 :: Double }
23:11:29 <johnw> you can now construct it as "Foo 1 1.0" or as "Foo { fooField1 = 1, fooField2 = 1.0 }"
23:12:12 <julianleviston> johnw: oh… is this new since the book, or am I just being impatient? thanks by the way :)
23:12:21 <johnw> I doubt it's new since the book
23:13:16 <julianleviston> johnw: I just looked forward, and yeah, I’m just being impatient - they mention record syntax… thanks! <3
23:15:30 <julianleviston> johnw: can I take an existing type, and define a type based on it but having different names? Is this the domain of class types? I should probably just keep reading, shouldn’t I? :)
23:15:46 <johnw> yeah, I would keep reading :)
23:15:46 <julianleviston> sorry type classes
23:16:01 <julianleviston> johnw: thanks :)
23:16:06 <nkar> how is a function represented in template haskell?
23:16:16 <johnw> nkar: definition or call?
23:16:19 <julianleviston> johnw: have to say, this is a thing of immense beauty so far.
23:16:29 <johnw> julianleviston: it continues to be for me as well, a few years in
23:17:19 <julianleviston> johnw: I just wish this learning method was as good as the language.
23:17:48 <julianleviston> johnw: obviously when compared to other books it’s great… but compared to what could be possible books are lacking.
23:17:55 <nkar> johnw: call, I guess. that's a side issue.  I'm interested in this: "is there a way to apply a function like (f :: a -> Text) to a template haskell Name?  e.g. do x <- newName "x"; ...; f $(varE x)?"
23:18:24 <nkar> johnw: when I try it inside [d|instance PersistField ...|] it complains about missing Lift (a -> Text) instance.
23:18:32 <nkar> where Lift is a template haskell Lift
23:18:32 <johnw> nkar: I don't know
23:18:35 <nkar> :(
23:21:40 <nkar> johnw: here's what I'm trying to do.  I'd like to have a line like this inside [d|...|]: toPersistValue $(conP vcon [varP x]) = PersistText $ pp $(varE x) where pp :: (a -> Text), so I could use the same thing for both Text and Markdown.  for Text, pp = id; for Markdown pp = unMarkdown.  could I solve it differently, maybe?
23:23:09 <nkar> I could add a second pattern for Markdown right below this one, I guess, but I'd still need to pass in unMarkdown somehow.  either directly or in the AST.
23:23:11 <johnw> i don't know Template Haskell
23:24:45 <nkar> where's merijn :)
23:26:48 <c_wraith> he's gone? Does that mean it's my shift?
23:29:53 <c_wraith> nkar: the error message you're getting is the result of attempting to lift an entire expression, I think.
23:30:38 <c_wraith> nkar: [| f x |] is very different from let y = f x in [| y |]
23:30:46 <c_wraith> nkar: and I think you want something more like the latter
23:38:04 <srid> Richard Bard writes in his latest book: [] is an empty list of anything, but "" is an empty list of characters.
23:38:10 <srid> but there is no distinction, is it?
23:39:04 <johnw> :t []
23:39:06 <lambdabot> [t]
23:39:06 <johnw> :t ""
23:39:07 <lambdabot> [Char]
23:39:20 <srid> *Bird
23:39:39 <srid> ah ok
23:40:44 <pacak> srid: There are OverloadedStrings and OverloadedLists pragmas.
23:53:12 <julianleviston> srid: Are you reading Thinking Functionally with Haskell by Richard Bird?
