00:00:40 <ReinH> Oh, of course it typechecks
00:00:45 <EvanR> an empty udp socket?
00:01:03 <funfunctor> EvanR: I mean a empty data type
00:01:12 <EvanR> Void?
00:01:21 <ReinH> those functions just need to be passed a UDPSocket, which gets set as the state eventually via evalStateT
00:01:48 <ReinH> funfunctor: so just run `talk someUDPSocket'
00:02:06 <ddellacosta> is there a better than-O(n) way to get a list of the values in a map matching a set of keys?
00:02:22 <ddellacosta> Data.Map I'm talking about, but willing to consider other data structures if there are some that do this better
00:02:42 <funfunctor> ReinH: how should someUDPSocket be defined as a default so I can put that in runTRXManager
00:02:49 <EvanR> ddellacosta: you could make an index from all possible sets of keys to the sets of values
00:02:53 <ReinH> ddellacosta: well, it's O(n log m) for n keys in a map containing m values
00:03:12 <ReinH> you do a log m lookup n times
00:03:35 <ddellacosta> ReinH: yeah, I guess I'm talking about O(n) where n is the key set size
00:03:36 <ReinH> funfunctor: look at the docs for creating a udp socket
00:03:59 <funfunctor> ReinH: yea I was looking, just peoples blogs keep coming up on google
00:04:03 <ddellacosta> EvanR: thanks, thinking about that--I guess I'd have to prepare that in advance though, huh?  But I suppose it would be worth it if it was big enough
00:04:04 <ReinH> or at least the docs for creating a value of type UDPSocket
00:04:07 <Fusebox> I recall reading about a performance penalty for one of foldl or foldr. I believe it was foldr... can anyone explain? Is it because foldr has to read through the entire list before it gets to the right-most element, whereas foldl just pops the head?
00:04:28 <pacak> ddellacosta: You can try get away with intersection by key to create smaller map with only required keys
00:04:32 <ReinH> Fusebox: One isn't strictly better than the other.
00:04:38 <funfunctor> ReinH: UDPSocket is defined by me see line 25
00:04:51 <ReinH> Fusebox: sometimes foldr is better, sometimes foldl' is better
00:04:57 <ddellacosta> pacak: yeah, that's the kind of sneaky thing I was looking for...I guess I can create a "mock" map with the key set I want to pull out, then do intersection by key?
00:04:59 <ReinH> (foldl is almost never better)
00:05:09 <funfunctor> what is the null record type in haskell?
00:05:15 <pacak> ddellacosta: Yep, something like that.
00:05:26 <EvanR> funfunctor: there isnt one
00:05:30 <ddellacosta> pacak: okay, thanks, I'll investigate that.  ReinH, EvanR, thanks for the feedback
00:05:39 <ReinH> funfunctor: () is the closest to a null record
00:05:45 <ReinH> Fusebox: http://stackoverflow.com/questions/24370549/foldleft-v-foldright-does-it-matter/24370977#24370977
00:05:48 <funfunctor> EvanR: exactly so how can this pattern even work
00:06:19 <EvanR> funfunctor: sorry im not following what you are trying to achieve i think ReinH has the most information so far
00:06:49 <ReinH> EvanR: the function takes a UDPSocket value, so pass it one
00:06:56 * hackagebot hwsl2 0.1.1.3 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.1.1.3 (srijs)
00:07:12 <EvanR> funfunctor: ^
00:07:30 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/120488
00:07:58 <funfunctor> I updated the code now to narrow down my fundamental issue
00:09:09 <Hijiri> funfunctor: that () you are passing to evalStateT is the wrong type, is that just a placeholder?
00:09:35 <ReinH> funfunctor: does that even compile?
00:10:19 <bramgg> How on earth do people manage to avoid collisions with datatype field names? For example if I have the datatype "Dog", "Horse", and "Cow", I'd want to give them each the field "height". What do?
00:10:37 <shachaf> Give them each the field "height".
00:10:38 <bramgg> For the moment I've been prefacing them. For example dogHeight, horseHeight, etc. Feel like a noob
00:10:41 <funfunctor> Hijiri: yea just a place holder for the issue
00:10:44 <shachaf> Oh, you don't mean a sum.
00:10:47 <Hijiri> I am guessing you should use some of the functions in Network.Socket to get a Socket, then construct a UDPSocket using it with the appropriate extra info
00:10:51 <ReinH> bramgg: It's a problem.
00:11:03 <ReinH> bramgg: you can always use them qualified or you can disambiguate them.
00:11:04 <Hijiri> I don't know what AddrInfo should be
00:11:05 <shachaf> In that case, dogHeight etc. is a pretty common solution.
00:11:23 <funfunctor> ReinH: no, the issue is what to do for the default UDPSocket before openTRXManager is called in the bracket pattern so the State is filled
00:11:24 <ReinH> If you're using lens, you can generate punned  lenses easily now
00:11:30 <bramgg> ReinH: yes but then that makes code messier
00:11:41 <ReinH> bramgg: Yep, like I said: it's a problem.
00:11:42 <bramgg> Is there a reason why Haskell can't just detect what one wants when they write "height Dog"?
00:11:45 <EvanR> you can also make them instances of a type class with the method height
00:11:56 <bramgg> EvanR: go on...
00:12:01 <shachaf> Type inference and value inference together don't work very well.
00:12:28 <shachaf> I don't really recommend making an ad-hoc type class like that. But it's possible.
00:12:28 <ReinH> EvanR: but that only works for the "getter" side.
00:12:35 <mauke> http://nikita-volkov.github.io/record/
00:12:54 <EvanR> ReinH: yeah i didnt want to go on since my idea is probably wrong here
00:13:02 <ReinH> As in, you can't use that typeclass method for record updates.
00:13:21 <EvanR> dogHeight cowHeight makes sense
00:13:26 <bramgg> mauke: looks cool
00:13:38 <ReinH> funfunctor: Again, you need to pass in a UDPSocket value. At least, that was the solution when it still compiled.
00:13:55 <bramgg> I'll probably just go on prefacing the names
00:14:05 <ReinH> funfunctor: If you need a default socket value, just define one? If you need IO to create a Socket value, do it in main?
00:14:07 <bramgg> Like a caveman
00:14:12 <EvanR> haha
00:14:21 <ReinH> bramgg: yep, using Haskell like a caveman.
00:15:04 <EvanR> bramgg: do you want them all to be height for the purpose of making it easy to remember and type, or do you want a polymorphic field name and setter that works with anything ?
00:15:44 <Hijiri> funfunctor: you can't make a default UDPSocket, because you need IO to get a Socket
00:16:02 <bramgg> EvanR: tbh it's just in case people look at my code and judge me
00:16:05 <Hijiri> so you will have to get it through IO, like ReinH suggested
00:16:07 <bramgg> good to know I'm not alone though
00:16:15 <EvanR> haha
00:16:18 <bramgg> EvanR: so if I had to pick i'd saythe former
00:16:26 <EvanR> shame-avoidance oriented programming
00:16:32 <bramgg> It works! :D
00:16:37 <ReinH> EvanR: what do you think code reviews are for?
00:19:18 <ReinH> Haha, record puns discussion back when people thought Haskell 2011 was still potentially a thing. How quaint. https://www.haskell.org/pipermail/haskell-prime/2010-February/003147.html
00:25:39 <EvanR> old-time-y record puns .. and then someone complaining about contemporary terminology "record" being used to refer to fields
00:25:48 <EvanR> that would annoy me if happened
00:26:30 <lpaste> bramgg pasted “Most common (or standard) way writing function parameters over multiple lines?” at http://lpaste.net/120490
00:27:05 <shachaf> bramgg: There are multiple styles, either is fine.
00:27:29 <bramgg> cheers
00:41:09 <bramgg> Is there a difference between type signature and type declaration?
00:44:43 <solatis> hey all, anyone here knows whether it's possible to tell cabal to use additional ghc flags, like a one-time specific case instead of adding it to my .cabal file?
00:45:02 <solatis> i want my CI environment to be able to add -fphc manually, and adding --enable-library-coverage does funky things i don't want
00:45:22 <solatis> (it deviates from the .hpc directory and breaks hpc report in various ways)
00:45:40 <ReinH> bramgg: I see B far more often, fwiw
00:45:59 <bramgg> ReinH: thanks!
00:47:09 <solatis> ah wait, looks like -ghc-option is what i want
00:50:28 <solatis> ah, finally, i think i know why my program is doing funky things
00:50:32 <solatis> i have multiple test suits
00:50:53 <solatis> hpc report keeps complaining about not being able to find Main
01:03:48 <Ainieco> hello is it possible to transform monadio instance to IO?
01:03:58 <johnw> no
01:04:28 <johnw> monadio is a potentially a monad transformer whose action is to produce an IO action
01:06:31 <shachaf> Action of a monad transformer?
01:06:39 <johnw> i really couldn't find a better word
01:07:03 <shachaf> Word for what?
01:07:21 <shachaf> MaybeT IO a = IO (Maybe a)
01:07:23 <johnw> a ReaderT env IO a is a ReaderT action that, when runReaderT is used on it, yields an IO a action
01:07:59 <johnw> oh, hmm
01:08:02 <johnw> you are dead right
01:08:09 <johnw> I was thinking along the lines of IO (IO a)
01:08:28 <funfunctor> is there a backlog around?
01:08:32 <johnw> so all thats' happening here is unwrapping
01:08:39 <Ainieco> i just want to unify Proxy X () () ByteString IO () with Proxy X () () ByteString C.Curses ()
01:08:42 <Ainieco> https://gist.github.com/anonymous/7fb8f73c5a69e8bf8f73
01:09:09 <Ainieco> but not sure how, doc says that curses is just a wrapper around io https://hackage.haskell.org/package/ncurses-0.2.11/docs/UI-NCurses.html#t:Curses
01:09:46 <Ainieco> (if i uncomment type signature ghc will complain about Could not deduce (m ~ C.Curses)
01:10:12 <Ainieco> not sure why it can't deduce it while curses is an instance of monadio
01:10:52 <shachaf> The relationship between m and t m for a transformer t is more complicated than "t m a produces m a"
01:11:18 <johnw> shachaf: agreed, I wasn't giving it my full attention
01:11:39 <mjrosenb> whoo, I got the sdl2 tutorial that used sdl2-image working with the *other* sdl2-image library!
01:11:52 * mjrosenb removed like 50 instances of 'Ptr'
01:11:58 <EvanR> thats awesome mjrosenb
01:11:59 * hackagebot cafeteria-prelude 0.1.0.0 - Prelude subsetstake only what you want!  http://hackage.haskell.org/package/cafeteria-prelude-0.1.0.0 (scottflesichman)
01:12:18 <mjrosenb> well, lesson06
01:12:18 <EvanR> sounds tastey
01:12:21 <mjrosenb> out of many.
01:12:53 <mjrosenb> it also required modifications to sdl2-image, and sld2
01:13:05 <mjrosenb> but I suspect the modifications to sdl2 didn't need to be made.
01:14:49 <mjrosenb> oh wow, why are these utilities included in *every* *file*
01:16:41 <mjrosenb> lesson06: SDLCallFailed {sdlExceptionCaller = "SDL.Video.updateWindowSurface", sdlFunction = "SDL_UpdateWindowSurface", sdlExceptionError = "Window surface is invalid, please call SDL_GetWindowSurface() to get a new surface"}
01:16:49 <mjrosenb> well, it mostly works :-/
01:52:01 * hackagebot asciidiagram 1.0 - Pretty rendering of Ascii diagram into svg or png.  http://hackage.haskell.org/package/asciidiagram-1.0 (VincentBerthoux)
02:09:22 * mjrosenb has a question about SDL2; there is a SDL threads library, should I be using that or just haskell's native threading capabilities?
02:12:28 <mjrosenb> oh, clever that, the haskell version hasn't implemented threads.
02:12:59 <int-e> mjrosenb: I would expect nothing but trouble from mixing a thread library with Haskell's (well, ghc's) runtime system.
02:18:45 <NaOHman> Hey I have a noob question
02:19:09 <NaOHman> If I have a function that I call multiple times with the same inputs, does it get evaluated every time?
02:24:11 <acetoline> NaOHman: as I understand it (and my understanding is far from perfect), it depends
02:24:22 <acetoline> sometimes it does, sometimes it gets 'optimized' away
02:24:54 <NaOHman> Are there steps I can take to make sure that it only gets evaluated once?
02:25:41 <mniip> NaOHman, why would you want that
02:25:47 <mniip> is it impure?
02:26:29 <NaOHman> it's a pure function whose results need to be used many times throughout the life of the program
02:27:05 <mniip> memoization exists
02:27:17 <mniip> is built into ghc rather
02:28:03 <NaOHman> So it will be automatically memoized if I turn on optimization?
02:28:33 <mniip> NaOHman, is it a function or a value
02:29:42 <Fuuzetsu> http://stackoverflow.com/questions/3951012/when-is-memoization-automatic-in-ghc-haskell
02:30:39 <NaOHman> It's a function that generates unique rotations of a given matrix
02:31:17 <NaOHman> thanks for the link, it's very helpful
02:33:38 <Fuuzetsu> in general if you want something to be memoized for sure, do it yourself
02:35:01 <Fuuzetsu> not sure how up to date https://wiki.haskell.org/Memoization is
02:59:39 <wz1000> Does haskell have a proper modulus function?
03:00:12 <wz1000> > -5 `mod` 7
03:00:12 <test_> mod 5 7
03:00:14 <lambdabot>  -5
03:00:24 <wz1000> > -5 `rem` 7
03:00:25 <lambdabot>  -5
03:00:53 <wz1000> Is there any function that would give 2 for the above?
03:01:21 <test_> > mod 5 7
03:01:23 <lambdabot>  5
03:01:31 <wz1000> > -5 `quot` 7
03:01:32 <lambdabot>  0
03:01:48 <wz1000> >-5/7
03:04:19 <mniip> wz1000
03:04:33 <mniip> there are 2 sets of functions in haskell
03:04:43 <mniip> div/mod and quot/rem
03:04:54 <mniip> > modRem -5 7
03:04:56 <lambdabot>  Not in scope: ‘modRem’
03:04:56 <lambdabot>  Perhaps you meant ‘mode’ (imported from Text.PrettyPrint.HughesPJ)
03:04:57 <mniip> uh
03:05:03 <mniip> > quotRem -5 7
03:05:05 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a -> a -> (a, a)))
03:05:05 <lambdabot>    arising from the ambiguity check for ‘e_157’
03:05:05 <lambdabot>  from the context (GHC.Num.Num (a1 -> a -> a -> (a, a)),
03:05:14 <mniip> :|
03:05:33 <mniip> > quotRem (-5) 7
03:05:35 <lambdabot>  (0,-5)
03:05:38 <mniip> > divMod (-5) 7
03:05:40 <lambdabot>  (-1,2)
03:07:18 <profil> wz1000: (-5) `mod` 7?
03:07:39 <profil> > (-5) `mod` 7
03:07:41 <lambdabot>  2
03:08:02 <test> > divMod 5 7
03:08:03 <lambdabot>  (0,5)
03:11:09 <test> > 2^1234545
03:11:11 <lambdabot>  1191233750898504897772609317303073379113129309871827823247645401103641039561...
03:14:03 <test> is there a way to test lamdabot in a private mode ?
03:14:32 <thebnq> you can msg
03:15:37 <tasker> What is the easiest way to check if two doubles are equal, to a given precision ?
03:15:38 <silver> test, yes, via private messages
03:19:41 <johnw> tasker: to a given binary precision should be fairly easy, to a given decimal precision, that is harder
03:21:23 <tasker> johnw: I'm looking for decimal precision. I was thinking of doing abs (a - b) < somthreshold, if nothing better exists
03:26:14 <mniip> @let equal p a b = (floor $ a * 10^p) == (floor $ b * 10^p)
03:26:17 <lambdabot>  Defined.
03:26:40 <mniip> > equal 2 1.23999 1.23000
03:26:41 <lambdabot>  True
03:27:16 <mniip> tasker,
03:27:39 <tasker> mniip: Well. :p
03:28:12 <mniip> no I don't think there's a standartized function for doing this
03:28:31 <tasker> Ok, cool. Thanks!
03:30:44 <int-e> > equal 2 1.23999 1.24000
03:30:45 <lambdabot>  False
03:32:17 <mniip> tasker, unless you come from a perl background
03:32:28 <mniip> in which case something along the lines of
03:32:29 <mniip> on (==) (printf "%.2f" :: Double -> String)
03:32:30 <tasker> I do not ;s
03:37:07 * hackagebot setlocale 1.0.0.2 - Haskell bindings to setlocale  http://hackage.haskell.org/package/setlocale-1.0.0.2 (Kritzefitz)
03:37:09 * hackagebot linearscan 0.3.0.0 - Linear scan register allocator, formally verified in Coq  http://hackage.haskell.org/package/linearscan-0.3.0.0 (JohnWiegley)
03:47:08 * hackagebot linearscan 0.3.0.1 - Linear scan register allocator, formally verified in Coq  http://hackage.haskell.org/package/linearscan-0.3.0.1 (JohnWiegley)
03:52:08 * hackagebot hwsl2 0.1.1.4 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.1.1.4 (srijs)
04:03:06 <spaceloop> cabal/ghc says "Failed to load interface for <some module>. There are files missing in the ... package", which is my own package and module (the package compiles fine). The package is in a directory which I have added by "cabal sandbox add-source ...".
04:03:15 <spaceloop> Any hints how to approach this?
04:04:15 <Malar> what is the equivalent of python -i <script.py> in ghc/ghci ?
04:05:09 <mjrosenb> in http://hackage.haskell.org/package/reactive-banana-0.8.0.4/docs/Control-Event-Handler.html, the newAddHandler, what exacltly is the 'fire' component of NewAddHandler for?
04:05:27 <mniip> Malar, ghci file.hs
04:06:20 <Malar> mniip, but that doesn't actually run the program and halt at the prompt right but instead "load" it into the context?! right
04:06:58 <mniip> this is haskell
04:07:03 <mniip> there is nothing to "run"
04:07:04 <spaceloop> (fixed my module problem)
04:07:11 <mjrosenb> Malar: a file shoudl only contain values, none of which actually do anything.
04:07:41 <mniip> if you wish to execute the program, just write ':main' at the ghci prompt
04:08:01 <Malar> let me repharase, i want a file to be redicted to it when running the main function
04:10:15 <mniip> Malar, I'm afraid there's not a way to do that
04:10:27 <mniip> rewrite your code to operate on an arbitrary handle
04:10:39 <mniip> or don't use ghci at all
04:11:21 <mjrosenb> oh, is fire the Handler that the other function gets?
04:14:52 <McManiaC> how can i find out which dependency causes "package downgrades", ie. reinstalls of installed libraries to an older version
04:14:57 <McManiaC> in cabal
04:16:08 <Phillemann> I don't know if this is the right channel, but: After installing and enabling haskell-mode in emacs, it says "cannot open load file" ... "ghc". Anybody else get this error?
04:18:18 <mjrosenb> oh god, newAddHandler is rather different from what I expected.
04:27:19 <Phillemann> nvm, forgot to install company-ghc
04:31:42 <wz1000> Why is -5 `mod` 7 parsed as -(5 `mod` 7)?
04:32:33 <mniip> wz1000, because - is special
04:32:39 <wz1000> > -5 `mod` 7
04:32:40 <lambdabot>  -5
04:32:59 <mniip> and `mod` has the precedence of multiplication
04:33:32 <wz1000> mniip: What precedence does - have (as negation)
04:35:05 <mniip> 6 I think
04:35:43 <mniip> same as binary minus
04:37:56 <mjrosenb> argh, wtb: named tuples.
04:38:16 <mjrosenb> but... different
04:41:00 <JohnnyL> is there a Object Oriented Haskell?
04:44:33 <bennofs> JohnnyL: nothing I know of that is actually used
04:45:05 <nyuszika7h> there's a hack you can use for making it seem like OOP, not recommended though
04:45:27 <nyuszika7h> > import Prelude hiding (.); let (.) a b = b a; "hello".length.print
04:45:29 <lambdabot>  <hint>:1:1: parse error on input ‘import’
04:45:31 <bennofs> JohnnyL: the vinyl library provides records that can support "subtyping"
04:45:39 <bennofs> @hackage vinyl
04:45:39 <lambdabot> http://hackage.haskell.org/package/vinyl
04:45:43 <nyuszika7h> ¯\_(ツ)_/¯
04:46:06 <nyuszika7h> this is not a serious answer obviously
04:46:18 <nyuszika7h> more like a hack
04:47:55 <init> nyuszika7h: I'd go with the lens approac
04:48:05 <init> +h
04:48:16 <bennofs> JohnnyL: also http://stackoverflow.com/questions/5414323/does-haskell-support-object-oriented-programming (mentions OOHaskell, but that doesn't seem to be maintained)
04:48:53 <nyuszika7h> init: lens?
04:49:53 <bennofs> > "hello"^!to length.act print
04:49:54 <lambdabot>  <IO ()>
04:51:02 <JohnnyL> bennofs: ok
04:51:11 <babu`> Anyone using the wreq library?
04:52:20 <bennofs> babu`: I used. What's your question?
04:52:45 <wz1000> shouldn't unary - have maximum priority?
04:52:49 <JohnnyL> bye bye
05:00:54 <babu`> bennofs: I use it and it works well. But I need to use it on an internal https site that does have the proper certs yet. I get "(401,"TlsException (HandshakeFailed (Error_Protocol (\"certificate rejected: [NameMismatch". How do I tell wreq to ignore this error?
05:02:12 * hackagebot digestive-functors 0.7.1.4 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.7.1.4 (JasperVanDerJeugt)
05:03:34 <arianvp___> is there a way in haskell to encode in the type system the maximum size of something?
05:03:36 <arianvp___> say
05:03:38 <arianvp___> data Age =   Age (Int <= 100)
05:04:37 <voidzero> I think you can use 'case' with that
05:05:12 <voidzero> maybe this is helpful
05:05:14 <voidzero> https://wiki.haskell.org/Avoiding_partial_functions
05:08:34 <ddellacosta> hey, is there a good tutorial for using lens w/records (or should I just learn about lens themselves and it'll become obvious)?  obviously I'm not yet familiar with lesn
05:08:36 <ddellacosta> lens*
05:09:04 <arianvp___> I'm on a tour learning lenses.  Good way to learn that is to not use template haskell andd write lenses yourself for your records
05:09:06 <arianvp___> by hand
05:09:09 <arianvp___> helped my intuition
05:09:25 <ddellacosta> arianvp___: ah okay, I'll look into that
05:09:39 <tasker> Stupid question: Is there a function for adding matrices in hmatrix?
05:09:44 <tasker> I can't find one :s
05:09:46 <bennofs> babu`: you should be able to use mkManagerSettings from http://hackage.haskell.org/package/http-client-tls-0.2.2/docs/Network-HTTP-Client-TLS.html
05:09:57 <ddellacosta> arianvp___: think I need some more basic education on lenses first however
05:10:25 <Th30n> how's the state of opengl bindings in haskell these days?
05:11:06 <arianvp___> ddellacosta: Are you more of a theoretical person or a practical person?
05:11:20 <arianvp___> I got this paper lying around which helped me. but it's quite theoretical.
05:11:26 <bennofs> babu`: There you can specify TLSSettings, which have a field for disabling verification
05:11:38 <ddellacosta> arianvp___: oh, I'd be interested in that yeah, thank you
05:11:42 <arianvp___> http://arxiv.org/pdf/1103.2841v2.pdf
05:12:11 <ddellacosta> arianvp___: that looks awesome, thanks!!
05:13:07 <arianvp___> finding practical tutorials which look at it in the "getter setter pair" way are  there in abundance and they're usually better than your "yet another monad analogy" tutorial
05:13:12 <arianvp___> School of Haskell as a few
05:14:27 <ddellacosta> arianvp___: yeah, I guess I should start with the lense tutorials themselves.  But that paper looks like it'll be useful later on when I've built up a bit more intuition (and solidified more of my category theoretic foundations)
05:14:38 <arianvp___> :)
05:14:47 <ddellacosta> arianvp___: thanks!
05:27:23 * hackagebot sandi 0.3.2 - Data encoding library  http://hackage.haskell.org/package/sandi-0.3.2 (MagnusTherning)
05:30:47 <babu`> bennofs: thanks, will try that.
05:50:33 <Y8K> dont say anything this channel is logged
05:50:52 <Big_G> Y8K, Anything you say can and will be used against you
05:51:59 <Y8K> damn right
06:06:51 <Dholli> Can someone help me with a ranking function for my game? I've tried
06:06:51 <Dholli> rank xs = concat $ zipWith (map . (,)) [1..] (group $ sort xs)
06:06:51 <Dholli> rank l = let s = sort l in map (\x -> (1 + fromJust (elemIndex x s), x)) l
06:06:51 <Dholli> but neither are fully working.
06:06:51 <Dholli> rank ["two","one","one"])    should produce    [(1,"one"),(1,"one"),(3,"two")]
06:06:52 <Dholli> rank ["abel", "charlie", "baker", "abel", "charlie", "delta", "echo"]
06:06:52 <Dholli> should produce   [(1,"abel"), (1,"abel"), (3,"baker"), (4,"charlie"), (4,"charlie"), (6,"delta"), (7,"echo")])
06:08:10 <pjdelport> What is it supposed to do?
06:08:39 <Dholli> Can someone help me with a ranking function for my game? I've tried
06:08:39 <Dholli> rank xs = concat $ zipWith (map . (,)) [1..] (group $ sort xs)
06:08:40 <Dholli> rank l = let s = sort l in map (\x -> (1 + fromJust (elemIndex x s), x)) l
06:08:40 <Dholli> but neither are fully working.
06:08:40 <Dholli> rank ["two","one","one"])    should produce    [(1,"one"),(1,"one"),(3,"two")]
06:08:40 <Dholli> rank ["abel", "charlie", "baker", "abel", "charlie", "delta", "echo"]
06:08:40 <Dholli> should produce   [(1,"abel"), (1,"abel"), (3,"baker"), (4,"charlie"), (4,"charlie"), (6,"delta"), (7,"echo")])
06:09:03 <pjdelport> Dholli: You don't have to repeat that; i just don't understand what the ranking logic is supposed to be.
06:09:08 <Dholli> rank :: (Ord a) => [a] -> [(Int, a)]
06:09:11 <pjdelport> Can you explain what it's supposed to do in English?
06:09:33 <pjdelport> I can't tell what the two examples are supposed to be computing exactly.
06:09:45 <Dholli> Yes sorry misunderstood, one second
06:09:52 <pjdelport> What does the number in front of each tuple mean?
06:09:56 <Procian> Dholli: You can't concat, because you don't have a list of lists. Instead, you have [(Int,[a])]. Find a function to map of type (Int,[a]) -> [(Int,a)] and then concat.
06:10:01 <Procian> (or better, >>=).
06:10:03 <belst> seems like alphabetic ordering and the number is like the index +1 in the list
06:10:24 <belst> only if the are same its not
06:12:01 <Dholli> Its supposed to rank everything. It takes a list of elements and returns a list of pairs of Ints and elements and the output is sorted on the elements and the Int is the rank for each element
06:12:39 <Dholli> rank ["one"]) produces  [(1,"one")]
06:12:39 <Dholli> rank ["one","one"])   produces  [(1,"one"),(1,"one")]
06:13:58 <greeny> Dholli: zipWith (\x y -> (x,y)) [1..] (sort list)
06:14:07 <greeny> does this help you?
06:14:25 <Dholli> Greeny: let me try it out, thanks!
06:14:39 <cmtptr> I think he wants the int to be the same for values that are equal
06:14:54 <Dholli> cmtptr: you are correct
06:15:06 <greeny> ahh
06:15:10 <MyWay> hello
06:16:01 <MyWay> I'm trying to assign types to a lambda calculus expression, but I think I'm doing something wrong, can you give it a look please? http://paste.ee/p/Mkjzu
06:16:13 <Dholli> rank l = let s = sort l in map (\x -> (1 + fromJust (elemIndex x s), x)) l                          this seems to keep values that are equal the same but it is not working for all cases
06:16:30 <Procian> Dholli: Oh, sorry, see what you're doing now.
06:16:43 <Dholli> Actually that is just not sorting I believe
06:20:04 <akegalj> Dholli: (\a -> zip a $ map (fmap (+1) . flip elemIndex a) a) . sort
06:20:06 <Ainieco> hello, trying to use manyTill with anyChar but result is [Char] what should i use to get effect of anyChar but result in ByteString?
06:20:17 <Ainieco> attoparsec ^
06:22:49 <mniip> Dholli, what are 'all cases'
06:23:08 <akegalj> let doli = (\a -> zip a $ map (fmap (+1) . flip elemIndex a) a) . sort
06:23:11 <Procian> Dholli: I think that scoring function is probably sufficiently specialised that you might as well do it recursively.
06:25:23 <Dholli> rank l = let s = sort l in map (\x -> (1 + fromJust (elemIndex x s), x)) l      Is there a way to sort this output?  This gives the correct answer just not sorted I tried . sort but I think I am using it wrong.
06:26:20 <Dholli> akegalj I cant get that to work it complained about missmatched brackets or spacing but I do not see what it wrong
06:27:01 <Ainieco> anyonr?
06:27:02 <akegalj> how to run haskell here in irc?
06:27:04 <Ainieco> anyone?
06:27:16 <Ainieco> > 1 + 1
06:27:17 <lambdabot>  2
06:27:20 <Ainieco> akegalj: ^
06:27:35 <akegalj> > let doli = (\a -> zip a $ map (fmap (+1) . flip elemIndex a) a) . sort
06:27:36 <lambdabot>  not an expression: ‘let doli = (\a -> zip a $ map (fmap (+1) . flip elemInde...
06:27:56 <geekosaur> also you can use /msg / /query to lambdabot
06:28:15 <akegalj> > (\a -> zip a $ map ((+1) . fromJust . flip elemIndex a) a) $ sort [1,1,1,1,2]
06:28:16 <lambdabot>  [(1,1),(1,1),(1,1),(1,1),(2,5)]
06:28:29 <akegalj> Dholli: here
06:28:50 <akegalj> geekosaur, Ainieco : thnx
06:29:26 <Ainieco> geekosaur: do you know if there is anyChar :: Parser Word8 ?
06:31:51 <Dholli> > let a = (\a -> zip a $ map ((+1) . fromJust . flip elemIndex a) a) $ sort
06:31:52 <lambdabot>  not an expression: ‘let a = (\a -> zip a $ map ((+1) . fromJust . flip elemI...
06:32:13 <Dholli> akegalj how would I turn that into a function?
06:32:47 <akegalj> someFunctionName a = (\a -> zip a $ map ((+1) . fromJust . flip elemIndex a) a) . sort
06:32:51 <akegalj> sry
06:33:01 <akegalj> someFunctionName a = (\a -> zip a $ map ((+1) . fromJust . flip elemIndex a) a) $ sort a
06:33:11 <narendraj9> Can the lambdabot be invited in a new channel? That would be cool.
06:33:40 <Dholli> thank you,  what is the dollar sign used for exactly? Still new to haskell
06:33:53 <akegalj> Dholli: ill simplify, wait
06:34:18 <narendraj9> ($) is function application with low priority and right associativity.
06:35:08 <narendraj9> Dholli: It lets you avoid parens. So f (x + y) can be written as f $ x + y
06:35:42 <funke> "/msg lambdabot >     1 +1 "
06:35:52 <cmtptr> why is there a $ before sort?
06:36:11 <cmtptr> oh, you forgot an argument
06:36:13 <cmtptr> nevermind
06:36:52 <akegalj> Dholli: http://lpaste.net/120498
06:39:59 <Dholli> Could not deduce (a ~ Int) from the context (Ord a)
06:39:59 <Dholli> rank :: (Ord a) => [a] -> [(Int, a)]
06:44:03 <Dholli> akegalj: can you help me make it fit rank :: (Ord a) => [a] -> [(Int, a)]
06:45:26 <akegalj> Dholli: sec
06:47:37 <akegalj> Dholli: just write flip infront zip
06:48:36 <akegalj> Dholli: http://lpaste.net/120498
06:50:10 <cmtptr> flip, zip
06:50:24 <cmtptr> does haskell also have a whip, rip, and sip?
06:50:44 <cmtptr> grip
06:50:52 <cmtptr> dip
06:51:03 <Dholli> Okay that is loading thanks! How would I add that if the score is the same to tie the persons? so the output for rank [(Person "Person1" 10),(Person "Person2" 10)] should be [(1,Person "Person1" 10),(1,Person "Person2" 10)]
06:52:12 <akegalj> Dholli: for that you need to implement Ord
06:52:29 <akegalj> Dholli: if you want it compared by the nuber (10 in your example) ?
06:52:36 <Dholli> That is in Data.Char correct?
06:52:48 <Dholli> yes to check names and the score
06:53:04 <akegalj> Dholli: ok, but to sort them out by name and score or only by score?
06:54:05 <Dholli> just by score
06:54:07 <akegalj> Dholli: oh, only by score... i can see by the example
06:54:30 <akegalj> Dholli: ok, do you know about instances and classes in Haskell ?
06:55:02 <Dholli> akegalj: A little but I am still new
06:59:01 <akegalj> Dholli: http://lpaste.net/120498
06:59:16 <akegalj> Dholli: i didn't check it but it's something along these lines
06:59:32 <Dholli> akegalj: thanks I'll take a look
06:59:37 <RickyC> How can I make this work?     enrcypt a b = toEnum ((fromEnum b) a)
06:59:37 <RickyC> where a is an operation like (+2) or (+4) and b is a character?
06:59:37 <RickyC> enrcypt a b = toEnum ((fromEnum b) + 2)  this works but only shifts the character by 2. I want to shift it by whatever I send to the function
06:59:37 <RickyC> encrypt (+2) 'a'             encrypt is :: (Int -> Int) -> (Char -> Char)
07:00:05 <pharpend> @ask int-e Would you be so kind as to grace #lpmc with lambdabot's presence?
07:00:06 <lambdabot> Consider it noted.
07:01:52 <akegalj> RickyC: i suppose you are doing some cessar encrypt
07:02:11 <akegalj> RickyC: ceasar
07:03:16 <breadmonster> This is really interesting.
07:03:51 <breadmonster> So the compiler proves things for each type?
07:04:10 <mniip> RickyC, the function comes before the arguments
07:04:32 <akegalj> RickyC: http://lpaste.net/120501
07:06:28 <Dholli> akegalj: Expecting two more arguments to `Person'   I found the line that it is occuring on but not very familiar with instances
07:07:19 <IP92> is it possible to disable case sensitivity in GHCi for tabbing?
07:07:29 * hackagebot structured-haskell-mode 1.0.16 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.16 (ChrisDone)
07:07:31 * hackagebot libjenkins 0.8.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.8.0 (MatveyAksenov)
07:08:18 <augur> anyone familiar with hakyll know why it might be complaining that it cant find the module Hakyll?
07:08:28 <augur> i installed hakyll, everything should be fine, but..
07:09:40 <augur> oh, odd.. cabal is saying hakyll isnt installed
07:09:49 <augur> even tho i did install it yesterday and it took foreeeever
07:09:49 <pharpend> augur: cabal is shit
07:09:50 <augur> weird
07:11:15 <RickyC> why does caesar f = chr . f . ord     work?  I don't understand how it is only taking in one argument?
07:11:58 <silver> augur, are you using sandbox perhaps?
07:12:09 <mniip> RickyC, (.) is function application
07:12:10 <augur> not for this
07:13:03 <augur> whats especially weird is that the hakyll _binaries_ are installed perfectly fine
07:13:08 <augur> so hakyll-init works, etc.
07:13:20 <augur> but the _module_ didnt install.. o_O
07:13:30 <RickyC> why is it not caesar f ch = ...           it works I just dont understand why or what the chr and ord are doing exactly
07:13:58 <mniip> RickyC, caesar f ch = chr (f (ord ch))
07:14:03 <akegalj> RickyC: it could be ceasar f ch = chr(f(ord ch))
07:14:34 <mniip> again, (.) is function application
07:14:40 <mniip> it takes 2 functions and returns a function
07:14:43 <akegalj> Dholli: you need to create persons
07:14:44 <xauth> mniip: actually, function composition.
07:14:48 <mniip> ugh
07:14:52 <mniip> composition* D:
07:14:57 <akegalj> Dholli: so Person is some data (like an object)
07:14:57 <mniip> brainfart
07:15:04 * xauth smirks.
07:15:10 <mniip> yeah, 'chr . f . ord' is a function
07:15:20 <akegalj> Dholli: and you can create Person like this: Person "MyName" myScore
07:15:27 <akegalj> Dholli: as Person "bla" 10
07:18:05 <xauth> By definition of . 'chr.f.ord' is a function taking one argument, such that (chr.f.ord)x == chr(f(ord x))
07:23:24 <RickyC> caesarString :: (Int -> Int) -> [String] ->[String]              how would I call that caesar function to encrypt one letter at a time for a list of strings?   caesarString (rot (+1) ["test","abc"])   would equal ["uftu","bcd"]
07:24:14 <RickyC> where rot :: (Int -> Int) -> (Int -> Int)
07:24:15 <RickyC> rot f = \i -> (f i) `mod` (fromEnum (maxBound :: Char))
07:24:15 <RickyC> rot13 = rot (+13)
07:25:04 <geekosaur> not sure that rot function means what you think it does
07:25:07 <KaneTW> why are you putting parentheses around the return type
07:25:14 <akegalj> seasarString f = map (chr . f. ord)
07:25:21 <geekosaur> (caesar only rotates letters, not all characters)
07:26:12 <akegalj> RickyC: sry
07:26:36 <akegalj> seasarString f = (map.map) (chr . f. ord)
07:26:51 <akegalj> RickyC: but if you're knew then..
07:27:19 <akegalj> seasarString f = map (map (chr . f . ord))
07:27:25 <akegalj> which is the same as..
07:27:30 <akegalj> seasarString f = map $ map (chr . f . ord)
07:27:41 <akegalj> oh no, that last won't work
07:28:33 <akegalj> > seasarString f = map (map (chr . f . ord))
07:28:34 <lambdabot>  <hint>:1:16: parse error on input ‘=’
07:29:19 <akegalj> > let seasarString f = map (map (chr . f . ord))
07:29:21 <lambdabot>  not an expression: ‘let seasarString f = map (map (chr . f . ord))’
07:35:35 <wolf_mozart> does haskell have file io functions?
07:36:02 <akegalj> wolf_mozart: for reading/writing to file?
07:36:10 <wolf_mozart> and directory functions?
07:36:11 <wolf_mozart> yes
07:36:16 <akegalj> wolf_mozart: yes it has
07:36:26 <wolf_mozart> ok
07:37:08 <wolf_mozart> and is QT(for makig gui apps) supported by haskell?
07:38:11 <ddellacosta> so, practicing some graph algorithms in Haskell, and in my first attempt to implement BFS I used a map of vertex id -> vertex and then for the actual adjacency list, a map of vertex id to [vertex id].  Is there a better/standard way to represent a graph w/adjacency list in Haskell?
07:38:34 <akegalj> wolf_mozart: google says it is
07:38:36 <akegalj> wolf_mozart: https://hackage.haskell.org/package/hsqml
07:38:48 <Dholli> akegalj: I have been working on it but no luck.  Here is code that I cannot change because it is already working for other functions                                                 data People = Person String Int deriving (Eq, Show)
07:38:48 <Dholli> The following Ord instance makes the person with the highest count least
07:38:48 <Dholli> instance Ord People where
07:38:48 <Dholli> (Person _ count1) < (Person _ count2) = (count1 > count2) -- yes it's backwards
07:38:48 <Dholli> compare (Person _ count1) (Person _ count2) = compare count2 count1
07:38:48 <Dholli> allPeoples :: [People]
07:38:49 <Dholli> rank [(Person "Billy" 10),(Person "Bob" 10)])   should equal   [(1,(Person "Billy" 10)),(1, (Person "Bob" 10))])
07:38:49 <wolf_mozart> ok
07:40:16 <Dholli> rank :: (Ord a) => [a] -> [(Int, a)]    and I still need it to work on cases like  rank ["two","one","one"])   to equal  [(1,"one"),(1,"one"),(3,"two")]
07:40:43 <akegalj> Dholli: don't paste large chunks of code here on irc... use lpaste.net nad paste the link here
07:41:15 <Dholli> akegalj: okay sorry, is that free?
07:41:29 <akegalj> Dholli: yes
07:42:29 <akegalj> Dholli: ok, i'll look into it
07:44:29 <david___1> nick waern
07:45:19 <Dholli> http://lpaste.net/120502
07:52:41 <RickyC> caesarString f = map (map (chr . f . ord))     how would I write this to take in two arguments just so I could see it visually? This works but I do not understand why it looks like the format only has one arguement.    Im calling it by   caesarString  (+1) ["abc"]  to produce   ["bcd"]
07:55:02 <ddellacosta> RickyC: just add the arg at the end, like ceasarString f xs = map (map (chr . f . ord)) xs
07:55:20 <ddellacosta> RickyC: take a look at https://wiki.haskell.org/Pointfree
07:55:35 <ddellacosta> RickyC: just for context if you're not familiar with it
07:56:22 <akegalj> Dholli: http://lpaste.net/120503
07:57:32 * hackagebot structured-haskell-mode 1.0.17 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.17 (ChrisDone)
07:57:55 <akegalj> Dholli: http://lpaste.net/120503   -- fixed something
07:58:00 <RickyC> ddellacosta: why in the first way do you not need xs on either side? I am reading through that link thanks
07:58:26 <ddellacosta> RickyC: because it's typed the same in the end
07:59:03 <Ainieco> how do i collect input until (string "foo") of end of input with attoparsec?
07:59:23 <Ainieco> s/of end/or end/
07:59:52 <ddellacosta> RickyC: it has to do with the fact that everything curried in Haskell--so you get back a function with the type you want when you declare it as just 'ceasarString f' --does that make sense?  That's how I think of it at least
07:59:59 <ddellacosta> everything is curried*
08:03:15 <Ainieco> anyone?
08:03:54 <akegalj> Dholli: hm, for this exemple you would need to change Eq class... ill show you
08:06:03 <Dholli> akegalj: okay thank you,  I am getting an issue because person is defined in the file I am calling from and the new code
08:06:44 <akegalj> Dholli: http://lpaste.net/120503
08:07:23 <akegalj> Dholli: ok, then don't define it. Delete the "data Person..." line
08:08:15 <RickyC> ddellacosta:  can you or someone help me caesarString f xs = map (map (chr . f . ord)) xs        I need this to call my function encrypt which encrypts just one letter.
08:08:50 <ddellacosta> RickyC: sorry, not sure what you're asking for help with there
08:09:39 <Dholli> akegalj: I tried that but then it says person is not in scope since it is declared in another file
08:11:24 <RickyC> encrypt :: (Int -> Int) -> (Char -> Char)
08:11:24 <RickyC> ddellacosta: encrypt f xs = chr(f(ord xs))    this is my encrypt function to do one letter.  How would I call this function for each letter from the function caesarString
08:16:01 <RickyC> ddellacosta: does that make sense?
08:16:17 <Welkin> RickyC: map encrypt xs
08:16:33 <Welkin> break it down into composable parts
08:16:34 <ddellacosta> Needs a fn in there
08:16:43 <ddellacosta> map (encrypt f) xs
08:16:47 <Welkin> you have a function that encrypts a single letter
08:16:50 <Welkin> then you map that over a string
08:17:47 <heatsink> I just got here, but that doesn't sound like a secure encryption strategy
08:17:55 <Welkin> heatsink: it's not
08:17:59 <ddellacosta> heatsink: I have a suspicion that it is, rather, a homework assignment
08:18:08 <Welkin> but neight is a ceasar cipher, or any other naive encryption strategy
08:18:13 <geekosaur> it's a caesar cipher for learning purposes, not ECDSA
08:18:14 <Welkin> neither*
08:18:22 <RickyC> ahh I was so close to that!
08:18:42 <ddellacosta> RickyC: this is one case where following the types helps a lot I think
08:18:59 <ddellacosta> well, it almost always helps, actually...haha
08:19:03 <Welkin> it's always helpful to follow the types
08:19:07 <geekosaur> (yeh, I know, ECDSA isn't a ipher it's a secure hash)
08:19:17 <Welkin> that is how I think about programs
08:19:23 <akegalj> Dholli: then you need to import that file
08:19:29 <akegalj> Dholli: where is that file?
08:20:17 <Dholli> akegalj: the problem is that that file is importing the new one already to it creates a circular import issue
08:21:02 <Big_G> Is anyone on here from Seattle?
08:21:28 <akegalj> Dholli: if you know how to push that to github i could look at your code
08:22:13 <RickyC> ddellacosta: two issues couldn't match Char with [Char] in the return type of the call encrypt and  couldn't match [char] with char in the second argument of map which is xs.  do I have something swapped around?
08:22:42 <ddellacosta> RickyC: put your code in an lpaste or something and give us the link
08:26:53 <ddellacosta> RickyC: I mean, you've basically got it above, just get rid of that redundant map
08:26:57 <Ainieco> how do i collect input until (string "foo") or end of input with attoparsec?
08:27:13 <ddellacosta> RickyC: caesarString f = map (chr . f . ord)
08:27:17 <RickyC> ddellacost: http://lpaste.net/120508
08:27:59 <Ainieco> 'manyTill anyChar (string "foo") <|> manyTill anyChar endOfInput' doesn't really work beacause it stucks at first manyTill and returns Partial
08:27:59 <ddellacosta> RickyC: are you sure you want [String] ?
08:28:48 <ddellacosta> RickyC: in that case I guess you do want the second map
08:31:16 <ddellacosta> RickyC: caesarString f = map (map (encrypt f))
08:32:11 <Dholli> akegalj:  http://lpaste.net/120502   the code on the bottom is in it's own file and imports the other file and calls rank from it
08:33:39 <RickyC> ddellacosta I guess I am still failing to understand why there is only one argument after caesarString. Is there a was to write that out with two arguments so I can kind of understand the process a little better?
08:34:18 <ddellacosta> RickyC: sure, you can add the arg if it makes it more clear for you: caesarString f xs = map (map (encrypt f)) xs
08:34:20 <RickyC> Just add xs on both sides?
08:34:56 <RickyC> Oh okay you sent that at the same time I was asking, thanks for the clearification
08:36:00 <ddellacosta> RickyC: sure. Again the reason is just that Haskell is curried--so you return a function that does what you are asking for in terms of how you are specifying the types.  One way to see this ore clearly is to check the types in ghci for (caesarString (+1)) for example.
08:36:08 <ddellacosta> *more clearly
08:36:32 <ddellacosta> check the type signature, I should have said...getting sleepy
08:37:20 <akegalj_> Dholli: to fix the ordering just instead of s1 `compare` s2 write   s2 `compare` s1
08:38:27 <akegalj_> Dholli: about importing and cycles i don't know, I can't tell without code, don't know in which order it's importing. I need to see the files (i usually don't run into this cycle import problem often)
08:40:02 <Dholli> akegalj_ http://lpaste.net/120502   I added the import if that makes sense?
08:41:35 <Ainieco> does attoparsec parse always returns Partial or Fail and it's up to user to decide when it should be done?
08:42:05 <Ainieco> geez, there are 1.5k people here and nobody have a clue about attoparsec...
08:42:23 <carter> Ainieco: more like theyre busy with the weekend
08:42:25 <hpc> not everyone's looking at the channel 100% of the time
08:42:32 <carter> Ainieco: attoparsec is meant for streaming
08:44:14 <RickyC> > testMap =  map (map (+1)) [[1,1],[2,2],[3,3]]
08:44:15 <lambdabot>  <hint>:1:9: parse error on input ‘=’
08:44:29 <RickyC> map (map (+1)) [[1,1],[2,2],[3,3]]
08:44:43 <RickyC> > map (map (+1)) [[1,1],[2,2],[3,3]]
08:44:43 <narendraj9> Ainieco: You wanted a reply within 2 minutes. :-D
08:44:43 <ddellacosta> > map (map (+1)) [[1,1],[2,2],[3,3]
08:44:45 <lambdabot>  [[2,2],[3,3],[4,4]]
08:44:45 <lambdabot>  can't find file: L.hs
08:44:51 <hpc> Ainieco: partial means the parser doesn't know if there's any more data in the stream
08:44:59 <ddellacosta> jinx :-)
08:45:16 <hpc> there's another function you can use that will run the parser action on the entire stream of input and return done
08:45:18 <ddellacosta> looks like I missed the last bracket anyways...d'oh
08:45:49 <ddellacosta> RickyC: I gotta hit the hay. Good luck!
08:46:07 <RickyC> thanks for the help!
08:46:25 <ddellacosta> RickyC: np, glad I could be of service
08:47:07 <Dholli> akegalj_  does this makes sense with the import? http://lpaste.net/120502
08:48:58 <RickyC> How can I map a function to all elements in a list of lists? testMap =  map (map (+1)) [[1,1],[2,2],[3,3]]  but so I can send the argument  (+1) or (+2)  and send any list?
08:49:48 <nshepperd> :t (map . map)
08:49:49 <lambdabot> (a -> b) -> [[a]] -> [[b]]
08:50:26 <Ainieco> hpc: do you mean parseOnly? it doesn't work in my case since data comes in batches, doc says that i need pass empty bs to Partial to instruct parser to return Done
08:51:27 <Ainieco> hpc: but is it the only way to make 'parse' return Done? can i consturct my parser is such way that it's obvious to attoparsect that iteration is Done?
08:52:06 <hodapp> "Monads are opaque to static analysis, and applicative functors are poor at expressing dynamic-time data dependencies."
08:52:08 * hodapp ponders
08:52:14 <Dholli> > let testMap f xs = (map . map) f xs
08:52:15 <lambdabot>  not an expression: ‘let testMap f xs = (map . map) f xs’
08:52:44 <hpc> hodapp: only Monad types that are opaque are opaque
08:52:57 <hpc> which means pretty much just IO
08:53:12 <RickyC> Dholli: does that work?
08:53:33 <hpc> Monad is only an interface, unless you want to say Num is opaque to static analysis as well
08:53:38 <hpc> ;)
08:53:48 <RickyC> nshepperd: how would I add that to a function testMap f xs = ...
08:54:05 <hodapp> hpc: I'm just reading http://gergo.erdi.hu/blog/2014-07-12-arrow%27s_place_in_the_applicative_monad_hierarchy/
08:54:18 <hodapp> hpc: and trying to figure out what he/she meant at 'Conclusion'
08:56:02 <RickyC> > map (map (+1)) [[1,1],[2,2],[3,3]]
08:56:03 <lambdabot>  [[2,2],[3,3],[4,4]]
08:56:14 <akegalj_> Dholli: yes, that should work
08:56:19 <akegalj_> Dholli: what does it say?
08:56:52 <ReinH> hodapp: source of that quote?
08:57:02 <hodapp> ReinH: the link I sent to hpc above, need me to repeat?
08:57:12 <RickyC> I got the map nvm
08:57:13 <ReinH> hodapp: Oh I see, sorry.
08:57:24 <nshepperd> RickyC: (map . map) is just a function, eg you can apply it as Dholli did
08:57:58 <hodapp> ReinH: no problem
08:58:14 <Dholli> Person not in scope for the top file
08:58:20 <ReinH> hodapp: "monads are opaque to static analysis"... Yeah, and this includes *me* trying to figure out what a StateT SomeState IO () might do at any time after I have written it.
08:58:38 <hpc> i think the author is just confused
08:58:58 <hpc> the author says Monad is exactly equal to Arrow, then says it's not obvious why Applicative isn't also
08:59:22 <nshepperd> depending what exactly you're trying to statically analyse, you could say that the Monad interface makes things difficult
08:59:31 <ReinH> I thought there was a paper about this.
08:59:41 <hodapp> should I just disregard this link altogether?
08:59:48 <nshepperd> since it requires you to permit certain kinds of composition
09:00:18 <ReinH> hodapp: Ah, I think it was http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
09:00:19 <nshepperd> eg. composition with haskell functions which *are* opaque
09:00:54 <hodapp> Wadler, looks legit :)
09:01:14 <hodapp> oh yes! another page linked to that paper
09:01:47 <Dholli> akegalj: Not in scope: type constructor or class `Person'
09:02:52 <hpc> hodapp: take it with a grain of salt, and probably double-check everything it proposes
09:03:10 <ReinH> hodapp: If the topic is monads, I usually rely on Wadler :)
09:03:33 <hodapp> ReinH: That's fair.
09:03:50 <ReinH> hodapp: I still haven't seen a better monad tutorial than his original monads for CS paper.
09:04:04 <hodapp> ReinH: have a link to that?
09:04:12 <nshepperd> whereas making your type an applicative functor demands much less of you, but might not provide a sufficiently powerful interface to your users
09:04:15 <ReinH> And Sorry, monads for FP http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
09:04:20 <ReinH> s/And //
09:04:49 <akegalj_> Dholli: it works for me
09:05:08 <nshepperd> so I guess there's some truth to that sentence, given certain quantifiers
09:05:24 <ReinH> hodapp: I try to hew pretty closely to his explanations when people ask me about monads. That is, when telling them to ignore monads won't work. ;)
09:05:35 <akegalj_> Dholli: http://lpaste.net/120502
09:07:38 * hackagebot io-region 0.1.0 - Exception safe resource management with dynamic regions  http://hackage.haskell.org/package/io-region-0.1.0 (YurasShumovich)
09:07:40 * hackagebot hslogger 1.2.8 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.2.8 (JohnGoerzen)
09:09:12 <akegalj_> Dholli: you said that Person is defined somewewhere else?
09:09:17 <akegalj_> Dholli: does it work now?
09:09:39 <akegalj_> Dholli: is it in some third file, or are there only these two files?
09:11:36 <Dholli> akegalj: there are only two files. I am about to llok at your link.
09:14:13 <tomphreek> does Data.Matrix store data in contiguous rows or columns?
09:14:17 <ReinH> hodapp: BTW, Wadler's paper on arrows makes use of the "values as nullary functions" isomorphism. I should mention that one to conal.
09:14:37 <ReinH> Then again, he's using it in an algebraic context, where it makes perfect sense.
09:15:26 <hodapp> ReinH: perhaps if I read this paper, whatever you just said will make sense to me!
09:16:07 <ReinH> hodapp: Algebraically, you can think of a value x in S as a function 1 -> S that selects x. In Haskell terms, this would be x :: a and f :: () -> a
09:16:15 <ReinH> (1 is the one-element set)
09:16:26 <tomphreek> nvm, contiguous rows
09:16:53 <ReinH> hodapp: It's one way to make sense of the "everything is a function" claim, but not a particularly useful one in Haskell.
09:17:11 <Dholli> akegalj:  Person is defined in the bottom file and the bottom file calls the top file that also has Person in it. So the bottom file defines Person and the bottom file calls the top file but the top file also uses Person.   I dont know if this makes more sense trying to explain it?
09:17:36 <delrik> hi guys: is there any significance to the trailing comma here?: import Control.Monad ((>=>), )
09:17:52 <ReinH> delrik: does it parse?
09:17:53 <delrik> from a module perspective?
09:17:54 <hodapp> ReinH: what's the, er, value of treating a value as () -> a?
09:18:07 <delrik> yep
09:18:09 <geekosaur> delrik, no significance
09:18:25 <akegalj> Dholli: but there is no definition of person in top file?
09:18:32 <delrik> geekosaur: thx, is it an idiom or something?
09:18:53 <ReinH> geekosaur: no, probably just a typo.
09:18:58 <ReinH> er
09:19:03 <delrik> =)
09:19:03 <ReinH> delrik: no, probably just a typo. It serves no purpose.
09:19:09 <delrik> kk, thx
09:19:11 <geekosaur> might be a typo, might be so they can add things more easily
09:19:41 <geekosaur> (that is, just slap `function, ` into it and not have to worry about the case where there's only one)
09:19:58 <delrik> haskell wiki https://wiki.haskell.org/Foldl_as_foldr
09:20:39 <geekosaur> on the wiki it's probably a typo
09:20:41 <delrik> i got excited for a second.   I’d contribue to the wiki with my patented comma removal action.
09:20:51 <ReinH> haha
09:21:03 <delrik> that or learn something cool about the module system =), thx guys
09:21:19 <padre_angolano> import Control.Monad ((>=>),, ) also pases, btw (with two commas)
09:21:38 <padre_angolano> parses
09:22:15 <delrik> we could always take a look at core and see if there is a tuple triple constructor hiding around =) (in the case of ,,)
09:24:20 <geekosaur> wat
09:24:28 <Dholli> akegalj: that is correct and when I add a definition of it in the first file I get an error Ambiguous occurrence `Person'
09:24:39 <ReinH> Hah, the grammar explicitly allows a trailing comma: impspec → ( import1 , … , importn [ , ] )
09:24:59 <ReinH> But not, unless I'm reading that wrong, two or more trailing commas
09:25:17 <hodapp> trailing comma makes sense for convenience sometimes, if you're going to have lines like "thing1," "thing2," "thing3," up to the final one
09:25:18 <tzaeru> "So why aren't all these people using Haskell instead of Perl, Python and Ruby? After all, it is a better language." I think the 2nd sentence actually answer the question of the first sentence.. :D
09:25:19 <delrik> says  a list of commas no?
09:25:47 <delrik> being zero or more?
09:25:53 <geekosaur> delrik, no, in bnf-style it means optional (0 or 1)
09:26:38 <delrik> geekosaur: thx for the heads up. i’ve got a thick layer of haskell wrapped around my brain. so I’m seeing everything in terms of it lately.
09:27:35 <ReinH> hodapp: For instance, it is useful in giving a generalized definition of n-ary operations
09:28:23 <cmtptr> I'm facing a conceptual block with something that's probably a very simple problem.  Given a string, e.g., "1\t2\tsome text\t3\t4", how do I read that and get it into a constructor (Row Int Int String Int Int)?
09:28:48 <cmtptr> (tab-delimited)
09:29:00 <Cale> I'd start by applying words
09:29:00 <ReinH> hodapp: if X^n is the n-fold cartesian product of X, then an n-ary operation on X is equivalent to a function f : X^n -> X, where X^0 is defined as the set 1 with just one elment.
09:29:06 <Cale> oh, no
09:29:08 <Cale> right :)
09:29:12 <Cale> splitOn?
09:29:16 <Cale> :t splitOn
09:29:17 <lambdabot> Eq a => [a] -> [a] -> [[a]]
09:29:31 <Cale> > splitOn "\t" "1\t2\tsome text\t3\t4"
09:29:32 <delrik> ReinH: iis impspec short for implementation spec or something? I’m having a hard time referencing what you mentioned earlier.
09:29:32 <lambdabot>  ["1","2","some text","3","4"]
09:29:40 <Cale> That's from Data.List.Split
09:29:48 <Cale> which is in the split package on Hackage
09:29:49 <cmtptr> Cale, yeah, and then what do I do with that?  Just index into it?
09:30:01 <Cale> You might just pattern match against a list of length 5
09:30:18 <cmtptr> ugh, duh
09:30:21 <cmtptr> thanks
09:30:35 <ReinH> hodapp: In Haskell terms, a^n is an n-tuple of a, so z^2 = (a,a). Define a^0 = (), then this is just (n-ary) currying.
09:30:45 <ReinH> s/z^2/a^2
09:31:31 <ReinH> delrik: https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1010005.3
09:31:56 <delrik> ReinH: awesome thx
09:34:15 <ReinH> hodapp: so a <=> () -> a is an example of the curry/uncurry isomorphism :D
09:35:34 <ReinH> hodapp: in the paper, Wadler makes use of this because the () -> a version of a particular monadic action lines up more nicely with its equivalant arrow version.
09:35:54 <simon_> ReinH, is this isomorphism only meaningful for lazy evaluation semantics?
09:35:56 <hodapp> ReinH: that makes some sense, I suppose!
09:36:16 <simon_> s/meaningful/valid/
09:36:18 <ReinH> simon_: I'm living in the carefree world of denotation, so there are no evaluation semantics :)
09:36:35 <n4x> ReinH: function application becomes composition, too! \o/
09:36:36 <simon_> ReinH, ok, cool.
09:36:50 <simon_> n4x, what...
09:37:16 <ReinH> simon_: but you see that converting a value a into function () -> a is frequently used to simulate laziness in strict languages :) This works because they are denotationally equivalent.
09:37:20 <hodapp> I need to read about denotational semantics...
09:37:30 <simon_> okay, so I tried to explain (>>=) to some dude and thought "well, it's like function composition", but when I looked at it, it looked much more like ($). so what you're saying makes my brain twist a little.
09:37:46 <ReinH> simon_: (=<<) is a lot line ($)
09:37:48 <ReinH> :t ($)
09:37:49 <lambdabot> (a -> b) -> a -> b
09:37:51 <ReinH> :t (=<<)
09:37:52 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:37:58 <ReinH> and also a lot like fmap
09:38:01 <ReinH> :t fmap
09:38:01 <simon_> ReinH, ah, cool.
09:38:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:38:05 <simon_> yeah, sure.
09:38:49 <simon_> people stuck on courses who think they must "learn monads" are eager to see functors as a hopefully small stepping stone to truly magnificent insight when, I've come to realize, functors are much nicer to think about.
09:40:09 <ReinH> The (=<<) version gains power by allowing you to create an m-value out of whole cloth, providing your own "effects" or "context". The fmap version has no access to the "context". The Applicative version allows you to supply further effects, but not choose what those effects are based on the value of previous computation. This is, in a nutshell, the difference in expressiveness between functor, applicative,
09:40:10 <ReinH> and monad.
09:40:11 <n4x> simon_: I just played a little bit with the terminology, it's just that for an "v :: () -> a", "f :: a -> b", f . v would be isomorphic to f v, but I don't know if it makes sense anywhere else outside my intution :P
09:40:46 <ReinH> (specifically, the (=<<) version allows you to choose your "effects" or "context" based on the value of a, while applicative does not)
09:40:51 <simon_> n4x, I'm sure it does.
09:41:38 <ReinH> But they are all generalizations of application.
09:42:33 <ReinH> simon_: the monadic composition is (<=<)
09:42:35 <ReinH> :t (<=<)
09:42:36 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
09:43:26 <delrik> :t (>>=)
09:43:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:43:46 <erisco> so has anyone figured out a Desktop IDE for haskell that works well?
09:43:51 <delrik> ohhh, i see =)
09:43:52 <ReinH> Known in the literature as Kleisli composition.
09:44:06 <ReinH> erisco: I, er, use emacs on a desktop...
09:44:35 <erisco> okay, what about for the rest of us? (not vim either)
09:44:42 <tiger717> Are Haskell functors endofunctors?
09:44:45 <ReinH> delrik: (>>=) is just flipped (=<<). It's probably more popular because do bindings read from right to left.
09:44:51 <ReinH> tiger717: Yes.
09:45:31 <delrik> :t (=<<)
09:45:32 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:45:42 <tiger717> ReinH: Thanks! Was a bit confused by http://www.stephendiehl.com/posts/monads.html
09:46:00 <delrik> (=<<) reads a lot like an fmap for me than (>>=)
09:46:05 <delrik> :t (>>=)
09:46:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:46:10 <delrik> :t fmap
09:46:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:46:24 <ReinH> tiger717: specifically, instances of Functor are endofunctors. It's possible to talk about non-endofunctors in Haskell.
09:47:31 <tiger717> ReinH: But how can you talk about non-endofunctors if there is nothing like a Category typeclass?
09:47:41 <ReinH> tiger717: because there is http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Category.html#t:Category
09:48:29 <ReinH> So a mapping between instances of Category that preserves id and composition would be a non-endo functor.
09:49:30 <tiger717> ReinH: But not a Haskell functor (as an instance of the Functor typeclass), right?
09:49:35 <ReinH> Right.
09:49:55 <ReinH> Functor instances are endo mappings in the ambient category of Haskell types and functions.
09:50:07 <lpaste> narendraj9 pasted “Test.hs” at http://lpaste.net/120514
09:50:27 <lpaste> narendraj9 revised “Test.hs”: “No title” at http://lpaste.net/120514
09:50:33 <ReinH> tiger717: which he makes explicit as instance Category (->)
09:51:01 <ReinH> tiger717: if you look at the type of fmap
09:51:02 <ReinH> :t fmap
09:51:02 <Hijiri> is there an abstraction for functors between arbitrary Category s
09:51:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:51:20 <ReinH> And choose a different style for the functorial part of the mapping
09:51:27 <ReinH> (a -> b) ~> (f a -> f b)
09:51:32 <Hijiri> class HappyFunctor c d f where
09:51:37 <ReinH> you can see that it takes arrows to arrows
09:52:01 <ReinH> Hijiri: I've seen various ad hoc versions of it, but nothing standard
09:52:02 <Hijiri> oh, f is not necessary I guess
09:52:04 <tomphreek> is there a fold variant which starts the accumulant with the fold function applied to the head of the list and which is working on the tail of the list
09:52:29 <ReinH> tomphreek: no. Accessing a list from both ends is very inefficient.
09:52:54 <ReinH> Oh.
09:52:58 <ReinH> I think I misunderstand.
09:53:02 <ReinH> Do you just mean foldl1 and foldr1?
09:53:08 <tomphreek> sounds right
09:53:11 <tomphreek> cheers
09:55:19 <lpaste> narendraj9 revised “Test.hs”: “No title” at http://lpaste.net/120514
09:57:40 <lpaste> narendraj9 revised “Test.hs”: “No title” at http://lpaste.net/120514
10:06:35 <ReinH> Hijiri: https://hackage.haskell.org/package/category-extras-0.53.1/docs/Control-Functor.html
10:06:58 <NightRa> Is there a `a -> Bool -> Maybe a` in base somewhere?
10:07:28 <glguy> no, but there are a lot of ways to build one
10:07:40 <athan> conal: ping :)
10:07:41 * hackagebot conceit 0.2.2.0 - Concurrent actions that may fail  http://hackage.haskell.org/package/conceit-0.2.2.0 (DanielDiazCarrete)
10:08:02 <NightRa> glguy: I'd argue that only 3 :)
10:08:23 <NightRa> Or 4 actually..
10:09:30 <NightRa> 1 point of an `a`, Bool = 2, Maybe = (+1) => 1 -> 2 -> 2 = 1x2 -> 2 = 2^2 = 4
10:09:47 <NightRa> Parametricity and the algebra of datatypes are awesome!
10:10:19 <ReinH> NightRa: 2^2^1 = 4 :)
10:10:22 <dbushenko> hi all!
10:10:36 <ReinH> NightRa: cartesian closed categories are also awesome.
10:10:41 <dbushenko> how to parse a json with aeson if the json contains not all the fields described by the haskell data type?
10:11:03 <ReinH> dbushenko: Then the Haskell data type should have Maybes
10:11:12 <ReinH> Or you need to supply default values
10:11:28 <NightRa> ReinH: Just barely learned about them today. Any examples?
10:11:41 <ReinH> NightRa: Well, the relevance here is that they have exponentials, so what I said actually works.
10:12:54 <NightRa> Yeah. Currying & application in the Sets (or Hask) category.
10:13:48 <NightRa> Is it correct thinking of Hask similiarly to Sets?
10:13:59 <dbushenko> ReinH, may be you have an example or something?
10:14:16 <NightRa> dbushenko: What is the behavior you want?
10:15:07 <dbushenko> NightRa, I just want to parse a json if not all the fields are supplied
10:15:29 <NightRa> dbushenko: What result you want in case not all the fields are present?
10:15:48 <dbushenko> NightRa, default values will be a good option
10:15:54 <dbushenko> I just don't know how to supply them
10:16:21 <dbushenko> ah, I think, I've found something
10:16:32 <dbushenko> I just used derived behaviour
10:17:45 <ReinH> dbushenko: Basically, use .:? instead of .:
10:17:59 <ReinH> dbushenko: e.g., http://blog.raynes.me/blog/2012/11/27/easy-json-parsing-in-haskell-with-aeson/
10:18:47 <dbushenko> ReinH, cool, thanks!
10:20:22 <ReinH> NightRa: I believe that Set and Hask share a lot of properties. Cale could probably be more specific.
10:20:51 <Cale> Hask is basically a way worse version of Set
10:21:15 <ReinH> Cale: platonic Hask is?
10:21:17 <Cale> yeah
10:21:28 <ReinH> Worse in which ways?
10:21:39 <Cale> It's not complete or cocomplete
10:22:48 <ReinH> Cale: Hask has products, right?
10:22:57 <ReinH> Cale: so it doesn't have pullbacks?
10:23:22 <ReinH> (or pushouts)
10:23:35 <n4x> what'd be a "nice" way to have (nested) readers/enviroments?
10:24:07 <n4x> I'd like to have a main Reader for the program configuration, and a per-window/client "enviroment"
10:24:16 <Cale> ReinH: yeah, it doesn't have equalisers or coequalisers
10:24:25 <ReinH> Cale: righto
10:28:56 <n4x> the least-annoying way I had in mind (with the actual code) was something like "withClient :: ReaderT (Global,Local) IO a -> Local -> ReaderT Global IO a", but I am not sure
10:29:40 <NightRa> n4x: There are lenses to go into reader
10:30:03 <n4x> and make a wrapper that allows ReaderT Global functions work with the "ReaderT (Global,Local)"
10:30:25 <n4x> NightRa: but, how would I represent the local environment in the "global scope"?
10:31:44 <ReinH> n4x: you could make a function withEnv e that takes a StateT (Global,Local) m a action and runs it in a StateT Global m a context.
10:33:26 <n4x> ReinH: will try, thanks.
10:34:04 <ReinH> Kind of like a reverse zoom.
10:34:10 <ReinH> where you provide additional context.
10:34:19 <ReinH> rather than zooming in on a particular part of a larger context
10:34:40 <n4x> let's call it cozoom! ;P
10:34:48 <alanoth> Does anyone have some free time to review my code? I'm looking to turn my calculator repl into an executable-cum-library. [https://github.com/sumitsahrawat/calculator]
10:34:59 <ReinH> n4x: :p
10:35:09 <alanoth> I'm looking for someone to guide me towards a good API.
10:35:51 <ReinH> n4x: er, ReaderT, not StateT
10:35:59 <alanoth> Does anyone have some free time to review my code? I'm looking to turn my calculator repl into an executable-cum-library. [https://github.com/sumitsahrawat/calculator]
10:36:06 <alanoth> I'm looking for someone to guide me towards a good API.
10:36:13 <n4x> ReinH: yeah, realized
10:36:15 <ReinH> alanoth: It's rude to repeat yourself.
10:36:25 <ReinH> alanoth: if anyone has an answer, they will let you know.
10:37:08 <ReinH> (and that behavior is likely to make people less inclined to help you, fwiw)
10:37:24 <carter> some people reach a channel hours later than its said
10:37:36 <alanoth> My network isn't working properly. My message didn't show on the log so I thought it didn't get to everyone. Sorry for any inconvenience.
10:37:42 <ReinH> alanoth: Gotcha. No worries.
10:37:43 <carter> ReinH: so pivot is now like a hip version of good?
10:37:57 <ReinH> carter: Yes, welcome to silicon valley.
10:38:06 <geekosaur> you might want to try the haskell-cafe mailing list or /r/haskell
10:38:24 <carter> ReinH: did you manage to stay in portland? :p
10:38:29 <ReinH> carter: I did.
10:38:31 <carter> lol
10:38:41 <carter> did they finally learn to be remote ok
10:38:47 <ReinH> I am not interested in moving to death valley.
10:38:52 <ReinH> carter: No, but they needed me so.
10:39:13 <carter> hah
10:39:46 <ReinH> carter: We have a couple people in the UK. One of these people wrote basically every crypto library for Haskell. The company will make... exceptions...
10:40:05 <carter> is that because they no longer have the dumb engineering manager?
10:40:11 <gauthier> it would be awesome if haddock generated documentation of the source like http://fssnip.net does (see http://fssnip.net/nM and hover the code), is there anything like this existing?
10:40:11 <carter> :)
10:40:22 <obb> who writes the crypto libs for haskell?
10:40:56 <ReinH> obb: Mostly Vincent Hanquez
10:41:03 <ReinH> e.g., http://hackage.haskell.org/package/tls
10:41:40 <obb> does his code get reviewed much?
10:42:48 <ReinH> obb: you'd have to ask him.
10:47:18 <carter> ReinH: i do wish some of that code didn't silently die when run with integer-simple built ghc though
10:47:44 * hackagebot yesod-purescript 0.0.4.6 - PureScript integration for Yesod  http://hackage.haskell.org/package/yesod-purescript-0.0.4.6 (mp)
10:51:51 <ReinH> carter: yeah, on the other hand the gmp is a PITA for other reasons
10:52:09 <carter> ReinH: LD_LIBRARY_PATH and you're set
10:52:38 <carter> ReinH: i'm reasonable confident that you're dealing with less locked down staging/prod than I am right now :)
10:52:41 <carter> :'/
10:53:43 <ReinH> carter: GHC puts GMP allocations on the heap, so if you FFI with something that *also* uses GMP, you get heap corruption!
10:53:50 <ReinH> since the allocator is global
10:53:50 <carter> ohh
10:53:53 <carter> hrm
10:54:01 <ReinH> Thanks GMP
10:54:08 <carter> ReinH: i tink thats fixed in 7.10
10:54:25 <carter> @ask hvr does the 7.10 gmp use a custom symbol prefix for safer linking?
10:54:25 <lambdabot> Consider it noted.
10:54:26 <ReinH> carter: How? A critical section around any GMP allocation?!
10:54:39 <ReinH> Ah.
10:54:48 <carter> @google ghc gmp2
10:54:50 <lambdabot> https://github.com/ghc/ghc/tree/master/libraries/integer-gmp2
10:55:03 <carter> the gmp bindings got cleaned
10:55:04 <ReinH> carter: Cool thanks
10:55:07 <carter> ReinH: i could be wrong
10:55:29 <carter> theres also some 7.10/7.12 plans for some other ideas, but i g2g
10:55:43 <ReinH> carter: yeah go already
10:56:16 <carter> take advantage of nyc or something?
10:56:20 <ReinH> leave
10:56:28 <carter> BAI
11:02:57 <xckv> hi the definition of 'ap' in prelude is 'ap = liftM2 id'
11:03:33 <xckv> i dont understand why you can do that if liftM2 first parameter is (a -> b -> c)
11:03:42 <xckv> and id is just (a -> a)
11:04:16 <xckv> how can you pass a function that takes less params?
11:04:17 <shachaf> xckv: Rename first: liftA2 :: (a -> b -> c) -> m a -> m b -> m c, and id :: x -> x
11:04:41 <shachaf> Er, liftM2
11:04:55 <shachaf> If you write liftM2 id, that must mean that (a -> b -> c) = (x -> x)
11:05:07 <shachaf> (a -> b -> c) really means (a -> (b -> c)), of course.
11:05:21 <xckv> oh right
11:05:41 <shachaf> So since ((a) -> (b -> c)) = (x -> x), it must be that a = x and b -> c = x
11:06:44 <xckv> thanks shachaf
11:07:10 <augur> it'd be nicer if it was  ap = liftM2 ($)
11:07:25 <augur> even tho ($) = id, it conveys something different to use ($)
11:07:46 <xckv> wait
11:07:51 <xckv> ($) = id?
11:07:55 <augur> yep
11:08:01 <augur> ($) f x = f x
11:08:03 <xckv> :t ($)
11:08:04 <lambdabot> (a -> b) -> a -> b
11:08:08 <augur> or just ($) f = f
11:08:26 <augur> its just id for functions, with very low precedence as an infix operator
11:08:50 <fryguybob> @type [id,($)]
11:08:51 <lambdabot> [(a -> b) -> a -> b]
11:09:00 <augur> @src ($)
11:09:00 <lambdabot> f $ x = f x
11:09:07 <xckv> what does @type do?
11:09:16 <xckv> oh riight i see
11:09:21 <xckv> thats a list of some type
11:09:37 <fryguybob> xckv: @type is the same as :t for lambdabot
11:09:39 <xckv> :t id
11:09:40 <lambdabot> a -> a
11:09:54 <augur> of course the id approach generalizes better. liftM id, liftM3 id, ...
11:09:55 <fryguybob> Putting things in a list force the same type.
11:10:02 <fryguybob> *forces
11:10:08 <xckv> oh right id is a more general type than $
11:10:17 <xckv> where a = (b -> c)
11:11:20 <xckv> is there a way to specify constraints for lambdas?
11:12:21 <xckv> would defining $ as a -> b -> a -> b be the same as (a -> b) -> a -> b ?
11:12:45 * hackagebot process-streaming 0.6.7.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.6.7.0 (DanielDiazCarrete)
11:13:08 <shachaf> No, it would be a -> (b -> (a -> b))
11:13:51 <fryguybob> xckv: You can give a type to a lambda expression, is that what you are asking?  (\x -> x) :: Num a => a -> a ?
11:13:52 <xckv> oh right - i should think of (->) as an infix type constructor?
11:14:37 <shachaf> Yes.
11:14:50 <xckv> fryguybob: i mean if i want to use a monad for example - '\Monad m => (m a) (mb) -> ...'
11:15:30 <xckv> im trying to define functions on monads in ghci
11:16:33 <shachaf> The way fryguybob said is probably the best. (\a -> a >>= id) :: Monad m => m (m a) -> m a
11:16:39 <fryguybob> xckv: I think you are confusing the bindings in the lambda expression with the types
11:16:58 <shachaf> And that's also true.
11:17:48 <fryguybob> When you say  Monad m  as a constraint, the  m  should show up in a type.
11:18:35 <monochrom> isn't Haskell exciting!
11:18:40 <xckv> oh right
11:18:49 <fryguybob> monochrom: It certainly is :D
11:19:01 <xckv> I keep mixing up constructors and type names
11:19:31 <monochrom> yes, tutorials keeping saying things like "data X = X Int"
11:19:34 <fryguybob> xckv: That is understandable, they get used in both places much to the confusion of some people.
11:20:06 <monochrom> while legal, it misleads beginners.
11:20:27 <monochrom> to make it worse, those tutorials do not bother to notify you that the two "X"s are distinct
11:20:38 <xckv> you need to have a type inference machine in your head to understand haskell code lol
11:20:52 <bernalex> obligatory: "I think that was a design mistake in the language" mini-rant
11:20:54 <phaul> hi all, I'm trying to optimize this http://lpaste.net/120520 ... I beleive it has strictness issues, as the heap profile show massive amount of memory allocated.
11:21:09 <bernalex> xckv: nah, you just use ghc & it does that for you ;)
11:21:11 <monochrom> I would prefer to teach "data X = Ctor Int" and make a fine print that says you could also "data X = X Int"
11:21:36 <phaul> This has 4 levels a monad tranformer stack though
11:21:45 <xckv> bernalex: ghc cant read and make you understand code for you :P
11:22:01 <ReinH> monochrom:  Absolutely. Or at least data X = MkX Int
11:22:28 <monochrom> GHC does not tell you how it reaches the conclusion of type error. And you need that to learn and diagnose.
11:22:45 * hackagebot lucid 2.9.1 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.9.1 (ChrisDone)
11:22:52 <fryguybob> xckv: You have to know what you are looking at by where it is in relation to the :: or the = in a defintion.
11:22:53 <monochrom> so at the end of the day, unless you never make type errors, you will have to do type inference yourself.
11:23:11 <shachaf> But saving your readers some type inference is the reason you write type signatures.
11:23:20 <monochrom> type inference involves unification. unification is exponential time for computers, so nevermind humans.
11:23:28 <shachaf> @quote type.inference.*compiler
11:23:28 <lambdabot> rwbarton says: type inference is supposed to be the compiler's job, not the reader's job
11:23:49 <phaul> I've randomly put in bang patterns + trying to use tranformers.*.Strict
11:24:24 <c_wraith> phaul: randomly throwing bang patterns at something rarely actually solves it.
11:24:48 <monochrom> I have not seen a correct (or even just mostly correct) program produced by randomly.
11:25:07 <phaul> that's what i feared :). The heap profile shows (>>=) is the cost centre
11:25:22 <c_wraith> phaul: can you upload the heap profile images?
11:26:20 <fryguybob> phaul: you can upload heap profiles here: http://heap.ezyang.com/
11:26:41 <phaul> uh, I can do hp2ps but my ps viewer doesn't like those. Are you happy with .hp + .prof?
11:27:09 <c_wraith> phaul: check out fryguybob's link.  I had no idea that exists...  pretty awesome.
11:27:46 * hackagebot purescript 0.6.7.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.7.1 (PhilFreeman)
11:28:21 <homovitruvius> I need to split a byte string at every occurrence of a regex. Yesterday somebody suggested regex appicative, but I don't see how to use it. I tried all examples in RWH.8 and none works for ByteStrings. Anybody has pointers to examples? Thx.
11:28:44 <monochrom> my http://lpaste.net/99842 illustrates how to infer types yourself. it is already a difficult example. if you survive this, nothing will kill you.
11:28:51 <phaul> http://heap.ezyang.com/view/29b7cbf093c6d6510beb537f53392d9db05d5861
11:28:58 <phaul> pretty awesome indeed
11:29:48 <c_wraith> phaul: by the way, your implementation of (>>=) doesn't prevent thunks from building up in the two places I'd actually expect them - the contents of the tuple.  The first one being a list *really* makes things uglier.
11:31:39 <myfreeweb> homovitruvius: hey, that's what I haven't added to pcre-heavy :D I'll add it now
11:32:12 <c_wraith> phaul: with that as a list, I really don't have a quick idea. I'd need to sit down and very closely examine the use pattern. I don't have time for that at the moment - but the important question is whether the list can avoid being in memory all at once.
11:33:44 <phaul> hm. I need to think about what you said... Thanks for looking. Maybe I will think about a rewrite there.
11:41:57 <phaul> cheers, i have to go. I will try to get to the bottom of this tomorrow :)
11:45:50 <NightRa> edwardk: Can you show me `flip` on Iso without the Exchange/Mutator newtypes? Or even better and simpler: `Iso a b s t -> (b -> t)`.
11:47:31 <shachaf> NightRa: Which definition of Iso?
11:48:05 <NightRa> (Profunctor p, Functor f) => p a (f b) -> p s (f t)
11:48:50 <shachaf> You're asking for backwards variance here -- usually you would write Iso s t a b -> ..., and you can get either b -> t or s -> a
11:49:33 <NightRa> Right, my bad. `Iso s t a b -> (b -> t)`
11:49:54 <shachaf> OK. Then you can pick e.g. p x y = y, f x = x
11:50:12 <shachaf> I.e. p = Tagged, f = Identity
11:50:51 <NightRa> Nice! Thanks
11:53:12 <htebalaka> quick question, if you change the last line of the memoized version of fib in at the bottom of https://wiki.haskell.org/Let_vs._Where to "in \x -> map fib' [0..] !! x" why does it still destroy memoization?
11:54:03 <htebalaka> the explanation given seems to imply that fib' would still be shared because it's no longer being redefined each recursive call
11:57:53 <geekosaur> it still is being redefined, you just moved the x closer in which does not help
12:00:20 <htebalaka> geekosaur: so is the only way to reliably get memoization without having to resort to pointfree definitions to put it on the top-level?
12:01:14 <geekosaur> pretty much
12:03:17 <geekosaur> actually I think what is happening here is you have now put the thing you want to memoize inside a lambda, so it can only memoize while that lambda is active --- but it creates a new lambda on every call to fib
12:04:29 <htebalaka> oh, that does look like it :/
12:06:00 <htebalaka> yeah, moving the creation of the memo table into the let expression and then having "in \x -> memo !! x" fixes it
12:15:17 <acetoline> how would you go about implementing an algebraic data type (ADT) system?
12:22:49 * hackagebot atomic-primops-vector 0.1.0.0 - Atomic operations on Data.Vector types  http://hackage.haskell.org/package/atomic-primops-vector-0.1.0.0 (peter_fogg)
12:23:36 <htebalaka> acetoline: what do you mean? something like datatypes a la carte?
12:23:45 <cfoch> hello
12:24:13 <cfoch> how can I know if a package is already installed (with cabal)?
12:24:57 <hsk3> Haskell made me think, maybe objects are not that important. Then I thought, why not go back to C and code only with structs (modeling objects) and functions?
12:25:00 <hsk3> Thoughts?
12:25:03 <quchen> cfoch: cabal list --installed?
12:25:12 <hsk3> not really a haskell question i know, but...
12:25:13 <htebalaka> cfoch: cabal install <package> --dry-run also works
12:27:49 * hackagebot pcre-heavy 0.2.1 - A regexp library on top of pcre-light you can actually use.  http://hackage.haskell.org/package/pcre-heavy-0.2.1 (myfreeweb)
12:27:50 <cfoch> quchen: how did you know about "--installed" 'flag'? it is not listed in the help
12:28:40 <geekosaur> cfoch, cabal help list
12:28:43 <quchen> cfoch: "cabal list --help" lists it
12:28:48 <myfreeweb> homovitruvius: you can split by regex now with pcre-heavy https://github.com/myfreeweb/pcre-heavy :-)
12:29:10 <cfoch> thanks (Y)
12:30:28 <xckv> is there a function/pattern for 'Monad m => m a -> a' other than do ?
12:30:52 <geekosaur> do desugars to uses of >> and >>=
12:31:13 <geekosaur> @undo do { a <- x; b x }
12:31:13 <lambdabot> x >>= \ a -> b x
12:31:30 <quchen> There is no pattern for "Monad m => m a -> a".
12:31:31 <geekosaur> whoops
12:31:34 <geekosaur> @undo do { a <- x; b a }
12:31:34 <lambdabot> x >>= \ a -> b a
12:31:48 <geekosaur> otherwise I'm not sure what you're asking
12:32:07 <xckv> geekosaur: oh right
12:33:25 <xckv> geekosaur: whats a simple implementation of 'ap' using >>= ?
12:33:37 <Panos2> Helo
12:34:35 <quchen> ap mf mx = mf >>= \f -> mx >>= \x -> return (f x) -- xckv
12:34:48 <Panos2> I am new in Haskell. Can someone please see explain to me the list permutation algorithm?
12:35:10 <lush> hi everybody
12:35:32 <quchen> Panos2: You mean the one in Data.List? I'm not sure this is a good start. It's a highly optimized algorithm.
12:35:50 <Panos2> Oh!
12:36:07 <Panos2> Any pointers for me ?
12:36:14 <quchen> Panos2: In particular, it's optimized for being as lazy as possible.
12:37:14 <Panos2> Oh. I have found some resources on the internet about list comprehension and recursive function.
12:37:50 * hackagebot stable-memo 0.3.0 - Memoization based on argument identity  http://hackage.haskell.org/package/stable-memo-0.3.0 (JakeMcArthur)
12:37:50 <Panos2> But I cannot quite grasp how the recursion works in list comprehension.
12:38:00 <xckv> quchen: is there a point free version of that?
12:38:11 <quchen> xckv: Why would that be useful?
12:38:27 <xckv> quchen: learning for me
12:38:34 <quchen> xckv: There's a pointfree version of all functions, but if it's not obvious then it's most likely useless
12:38:46 <quchen> ?pl \mf mx -> mf >>= \f -> mx >>= \x -> return (f x)
12:38:46 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
12:38:53 <quchen> ^ that's it
12:39:01 <shachaf> There's a point-free version of some functions.
12:39:22 <shachaf> Anything that involves pattern-matching, for instance, can't be made point-free.
12:39:25 <xckv> so there is not a point-free version for all functions?
12:39:52 <xckv> shachaf: you mean pattern matching by constrcutors?
12:40:25 <shachaf> ?
12:40:31 <htebalaka> xckv: i think there is for all functions, provided you have a function for case analysis
12:40:39 <Panos2> Him. Any resource on the internet that I can read would be really helpful
12:40:45 <htebalaka> :t maybe
12:40:46 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:40:52 <shachaf> htebalaka: It gets more complicated in GHC with things like rank-n types and existentials.
12:40:52 <quchen> shachaf: Assuming deconstructors (foldr, maybe, either, ...), what else is impossible to pointfree?
12:40:53 <htebalaka> :t either
12:40:53 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:41:06 <xckv> ?pl maybe
12:41:06 <lambdabot> maybe
12:41:10 <xckv> oh right lol
12:41:20 <htebalaka> shachaf: is that just because of type inference?
12:41:51 <shachaf> I don't know, what does it mean to be just because of type inference?
12:42:09 <heatsink> Panos2: There's a section in LYAH about list comprehensions http://learnyouahaskell.com/starting-out#im-a-list-comprehension
12:42:39 <htebalaka> assuming type inference was tractable for rank-n types, would that still be the case?
12:42:46 <heatsink> Panos2: If you want to follow how it executes, the best way is to evaluate a simple expression on paper
12:42:50 * hackagebot OpenGLRaw21 2.0.0.2 - The intersection of OpenGL 2.1 and OpenGL 3.1 Core  http://hackage.haskell.org/package/OpenGLRaw21-2.0.0.2 (JakeMcArthur)
12:43:03 <Hijiri> list comprehension desugars into monadic stuff
12:43:07 <quchen> No.
12:43:26 <quchen> List comprehensions can be implemented by desugaring into list monad stuff.
12:43:36 <quchen> As far as I know, GHC doesn't do that by default.
12:43:37 <shachaf> htebalaka: That's a big assumption, given that it isn't.
12:43:45 <Hijiri> oh, I thought it did
12:43:53 <Panos2> Oh my God ! I have not reached Monads yet !
12:44:01 <shachaf> Anyway, in GHC, even if you write the type out explicitly, you might need to eta-expand.
12:44:15 <Panos2> I am quite scarred to go there yet !
12:44:25 <htebalaka> well yeah. maybe better stated, if you put manual type annotations on every expression would every function have a point-free version?
12:44:34 <Panos2> I will try the paper.:-)
12:44:35 <quchen> Hijiri: I think GHC does it when you enable MonadComprehensions. If I recall correctly then list comprehensions have their own implementation for efficiency purposes (fusion).
12:45:06 <heatsink> Panos2: LIst comprehensions translate into the map, filter, concatMap, and (:[]) functions.  You don't need to know monads first.
12:45:18 <Panos2> Oh !
12:45:33 <Panos2> I didn't knew that !
12:46:01 <heatsink> Maybe it uses guard instead of filter, but that's just a performance optimization.
12:46:19 <Panos2> I will read harder and try the paper execution. Thank you everyone.
12:46:19 <Hijiri> I thought guard was filter fo lists?
12:46:39 <homovitruvius> myfreeweb: wow, that was fast. I'll have to forget laziness for a while and go removing snow for a while, but I'll give it a try as soon as I get back. Thanks a lot!
12:48:42 <quchen> filter p xs = do { x <- xs; guard p; return x } -- would be a valid implementation
12:48:55 <quchen> (But it's not implemented like this)
12:51:26 <Hijiri> filter doesn't even have the right type for guard, I was dumb
12:53:00 <quchen> guard (p x), not guard p, woops.
13:01:47 <acetoline> htebalaka: what do you mean by a la carte
13:02:51 <htebalaka> acetoline: there's a generic programming technique that's used for abstract syntax trees, where you can represent most (all?) ADTs out of a few primitive ADTs
13:04:28 <htebalaka> data I a = I a; data K c a = K c; data (:*:) a b f = f a :*: f b; data (:+:) a b f = InL (f a) | InR (f b); newtype Fix f = Fix (f (Fix f)) is a pretty powerful starting point for representing ADTs
13:04:59 <geekosaur> @google data types a la carte
13:05:12 <geekosaur> did we break the bot
13:05:20 <geekosaur> acetoline, that's the title of a paprt
13:05:24 <geekosaur> *paper
13:05:48 <lambdabot> Plugin `search' failed with: <<timeout>>
13:06:00 <acetoline> htebalaka: let me try to parse that
13:06:02 <monochrom> but it probably means "build your own combo"
13:06:29 <edwardk> NightRa: it seems shachaf got to you before i did
13:06:36 <geekosaur> oh, top hit is failing to load
13:08:10 <htebalaka> K is a single constructor datatype, I is used to represent a whole for a recursive datatype, :*: is a pair, :+: is an either, and Fix fills all I's recursively with the original datatype
13:08:10 <geekosaur> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
13:08:17 <htebalaka> *hole
13:08:31 <acetoline> you mean :*: is a product type and :+: is a union type
13:08:45 <acetoline> what about parametric types
13:08:53 <htebalaka> you also need "data Unit a = Unit" I think. [a] ~ Fix ((K a :*: I) :+: Unit)
13:09:43 <NightRa> Is there some research for an alternative to typeclasses which allows multiple instances such as (+,0) & (*,1) as Monoid instances?
13:10:01 <acetoline> htebalaka: what about parametric types though
13:10:53 <acetoline> oh nvm I'm confused
13:10:58 <htebalaka> [a] ~ Fix ((K a :*: I) :+: Unit) is parametric in a
13:11:39 <acetoline> yes
13:12:35 <htebalaka> http://www.timphilipwilliams.com/posts/2013-01-16-fixing-gadts.html covers gadts as well
13:13:41 <htebalaka> and showcases the different recursion schemes that you get for free. generalizations of folds and unfolds and all that
13:16:38 <quchen> NightRa: In what sense? Idris allows you to specify which monoid instance to use in case of ambiguity, for example
13:17:13 <NightRa> quchen: Oh, interesting.
13:17:38 <NightRa> I guess it messes up with type inference then.
13:20:51 <quchen> NightRa: They call them "named instances"
13:22:25 <quchen> instance [additive] Monoid Int where …   fold @{additive} <some Int Foldable> -- is the syntax, NightRa
13:24:00 <NightRa> quchen: Fancy. I guess it does not make sense to say 'the instance' when there are multiple anyway, so inference isn't an issue - just annotate.
13:24:37 <heatsink> NightRa: Scala implicits kind of allow multiple instances of a type class
13:24:42 <NightRa> Another question: How would you be able to define different syntax (function names) for say (+) and (*) ?
13:25:20 <heatsink> To resolve implicit parameters, there's a search procedure that finds the lexically closest variable that has the right type
13:25:34 <heatsink> Well, the search procedure is kind of complicated, but I think that's what it does
13:26:43 <NightRa> heatsink: Yeah, but there has been some strong debates whether to use this flexibility or have a canonical instance only.
13:27:15 <NightRa> heatsink: Scalaz goes with canonical instances only, with similiar newtypes for Sum, Product, All, ...
13:28:51 <NightRa> As to my last question, I guess those can be defined as (+) = (<> @{additive}), (*) = (<> @{multiplicative})
13:29:01 <NightRa> I like it quite a bit
13:29:24 <heatsink> Oh, that's what you meant
13:29:45 <heatsink> You could actually explain that in terms of implicit parameters
13:31:07 <heatsink> If you interpret it as (<>) taking an implicit Monoid dictionary as its first parameter, and @{} as passing the parameter explicitly
13:32:54 <NightRa> Can there be instances for different types with the same instance name such @{additive}?
13:33:35 <NightRa> Because it makes sense to talk about (+) on different types, such as N,Z,Q,R,...
13:33:56 <htebalaka> NightRa: you can also use Data.Reflection to pass in the instance at a single point explicitly, and GHC will handle piping it to the use-sites itself
13:34:58 <dmwit> data Monoid a = Monoid { mempty :: a, mappend :: a -> a -> a } -- am I doing research yet
13:35:26 <NightRa> More specifically, does @{...} pass a specific instance or the genral name for the instance?
13:38:05 <dmwit> What's the difference?
13:38:31 <dmwit> Are you asking whether Idris would consider using dynamic scoping...? (The answer to that is almost certainly "no".)
13:41:42 <NightRa> (+) :: (Monoid @{additive} a) -> a -> a -> a
13:41:48 <NightRa> Something of this sort ^
13:42:11 <NightRa> Instead of a specific instance
13:42:28 <dmwit> That looks a lot like dynamic scoping to me. If "additive" isn't in scope, I would expect (+) @{additive} to be an error. But I'm not an Idris expert.
13:42:31 <NightRa> Correction: => for the typeclass constraint
13:42:59 <NightRa> dmwit: What do you mean by "in scope"?
13:43:52 <dmwit> I mean the usual thing. You've imported a module that exports the name additive, or have defined the name additive close enough that no scope protection rules apply.
13:44:25 <dmwit> I would not expect names to be first class.
13:44:36 <NightRa> I assumed the names can be attached only on the definition of an instance
13:44:53 <dmwit> Somehow I think we're talking at right angles to each other.
13:45:08 <orzo> can i export class instances from an .hs-boot file?
13:46:27 <dmwit> orzo: From the Fine Documentation: "You can include instance declarations just as in Haskell; but omit the 'where' part.".
13:46:34 <dmwit> https://downloads.haskell.org/~ghc/7.0.4/docs/html/users_guide/separate-compilation.html
13:46:56 <orzo> ah
13:47:00 <orzo> thanks, dmwit
13:47:32 <monochrom> I encourage you to read the manual more.
13:47:38 <orzo> i did read it
13:47:47 <orzo> i just somehow missed what i was looking for
13:47:53 <monochrom> but read the version that matches your GHC version. not the version google brings up
13:47:54 * hackagebot lowgl 0.2.0.0 - Basic gl wrapper and reference  http://hackage.haskell.org/package/lowgl-0.2.0.0 (evanrinehart)
13:49:21 <orzo> better to read latest and then get corrections
13:49:38 <dmwit> monochrom: Close Enough
13:49:44 <orzo> then you know when you're learning something that will be obsolete
13:49:46 <monochrom> that works too. but google seldom brings you the latest
13:50:00 <orzo> yeah but swapping version with 'latest' works
13:50:15 <NightRa> Interesting. It might be possible to express these 'names' using instances on phantom types.
14:01:23 <augur> https://personal.cis.strath.ac.uk/conor.mcbride/pub/Totality.pdf
14:01:31 <Hiiliou> some body know to takes list of functions and thens return function which be their composition? myFunction :: [(a -> a)] -> (a -> a)                  myFunction [(*2),(+1)] 5)    would equals   12
14:02:01 <dmwit> :t foldr (.)
14:02:02 <lambdabot> (a -> b) -> [b -> b] -> a -> b
14:02:05 <dmwit> :t foldr (.) id
14:02:06 <lambdabot> [b -> b] -> b -> b
14:02:12 <dmwit> :t foldMap Endo
14:02:13 <lambdabot> Foldable t => t (a -> a) -> Endo a
14:03:11 <dmwit> :t ala Endo foldMap
14:03:12 <lambdabot> Foldable t => t (a -> a) -> Unwrapped (Endo a)
14:04:02 <NightRa> dmwit: What is that `ala` function?
14:04:32 <dmwit> I dunno. Somebody told me it worked well with foldMap once so I try it out every once in a while.
14:04:40 <dmwit> ?hackage newtype I think?
14:04:40 <lambdabot> http://hackage.haskell.org/package/newtype I think?
14:05:20 <cfoch> what is the simplest way to access to a registry field?
14:06:40 <Hiiliou> > let myFunction [(*2),(+1)] 5)
14:06:42 <lambdabot>  <hint>:1:29: parse error on input ‘)’
14:06:54 <dmwit> cfoch: Registry as in Windows registry?
14:07:09 <dmwit> cfoch: If so, the only thing I know that's specifically about Windows is the Win32 package; you might start there.
14:07:12 <Hiiliou> > [(*2),(+1)] 5
14:07:13 <lambdabot>  Couldn't match expected type ‘a1 -> t’
14:07:13 <lambdabot>              with actual type ‘[a0 -> a0]’
14:07:27 <dmwit> > ala Endo foldMap [(*2), (+1)] 5
14:07:28 <lambdabot>  12
14:07:50 <dmwit> > foldr (.) id [(*2), (+1)] 5
14:07:51 <lambdabot>  12
14:08:26 * shapr hops
14:08:39 <cfoch> dewit: record sorry
14:08:56 <cfoch> when you define a data type using a recor
14:08:58 <cfoch> record
14:09:06 <dmwit> The field name is also an accessor.
14:09:14 <Hiiliou> > let myFunction x y = foldr (.) id x y
14:09:15 <dmwit> ?let data Foo = Foo { field1, field2 :: Int }
14:09:15 <lambdabot>  not an expression: ‘let myFunction x y = foldr (.) id x y’
14:09:18 <lambdabot>  Defined.
14:09:26 <dmwit> > field1 (Foo 3 4)
14:09:28 <lambdabot>  3
14:09:45 <ReinH> > foldr (.) id [(*2), (+1)] 5
14:09:47 <lambdabot>  12
14:10:00 <dmwit> > let myFunction x y = foldr (.) id x y in myFunction [(*2), (+1)] 5
14:10:02 <lambdabot>  12
14:10:11 <NightRa> dmwit: Has he written an article about this library? looks very interesting
14:10:15 <ReinH>   which is the same as let myfunction = foldr (.) id
14:11:03 <dmwit> NightRa: I expect he has, though I can't tell you much more than that.
14:12:35 <htebalaka> NightRa: some of the newtype stuff is generalized by https://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Iso.html
14:12:44 <statusbot> Status update: `deb.haskell.org` is currently offline due to our hosting provider suspecting malicious activity. We're working on getting it back. -- http://status.haskell.org
14:12:47 <superfunc|lab> Is there a way to express the kind in a typeclass declaration; like class Foo r where foo :: r -> a
14:12:57 <superfunc|lab> where a is something of kind * -> *
14:13:00 <htebalaka> "au", "auf" and "under"
14:13:30 <htebalaka> superfunc: {-# LANGUAGE KindSignatures #-} i think
14:13:38 <dmwit> superfunc|lab: Yes, but (->) has kind * -> * -> *, so your specific request isn't going to fly.
14:14:07 <Hiiliou> dmwit: how to make generic so work with  [(*2), (+1)] 5     or [(*4), (+2)] 6   ?
14:14:24 <dmwit> Hiiliou: ?
14:15:12 <Hiiliou> let myFunction x y = foldr (.) id x y in myFunction [(*2), (+1)] 5        but pass in a list of functions and number
14:15:27 <dmwit> You are already passing in a list of functions and number.
14:16:59 <superfunc|lab> dmwit: thanks, I'm essentially trying to get around not having variadics
14:17:03 <Hiiliou> For that example first argument is  [(*2), (+1)]    and second argument is 5
14:17:47 <Hiiliou> dmwit: first argument is list of functions, second is the starting number
14:18:37 <dmwit> superfunc|lab: This is sometimes possible. But usually, the correct response to that instinct is, "Why?".
14:19:40 <superfunc|lab> I have a thing of unknown kind, could be (* -> *) or (* -> * -> *). I wanted to be able to have a typeclass which defines a reduce function, which will take them to (*).
14:19:57 <dmwit> superfunc|lab: You are looking for KindPolymorphism.
14:20:09 <superfunc|lab> Which essentially lets me call reduce in the calling code
14:20:15 <edwardk> :t alaf Endo foldMap
14:20:16 <lambdabot> Foldable t => (a1 -> Unwrapped (Endo a)) -> t a1 -> Unwrapped (Endo a)
14:20:21 <dmwit> superfunc|lab: But generally things that are not kind * do not have terms representing them.
14:20:46 <superfunc|lab> working on a DSL has brought me into a whole new set of interesting haskell nuances
14:21:10 <dmwit> More precisely: (almost) all terms are classified by types that are classified by the kind *.
14:22:05 <superfunc|lab> dmwit: correct
14:22:19 <superfunc|lab> I think I see my issue, I'll go see if I can fix, thanks.
14:27:02 <osa1> how is this different than recv that returns strict bytestring http://hackage.haskell.org/package/network-2.6.0.2/docs/src/Network-Socket-ByteString-Lazy.html#recv ?
14:27:47 <osa1> this is like Data.ByteString.Lazy.fromStrict <$> recv _ _
14:28:14 <orzo> heh, stylish-haskell apparently removes {-# SOURCE #-} pragmas
14:28:16 <Hijiri> it's lazy in that you don't have to write more keystrokes
14:28:59 <osa1> if I understand this correctly, this module is misleading
14:29:13 <osa1> you'd expect it to do less copying but no, it's exactly same as strict variant
14:32:32 <cfoch> lambdabot is a shell?
14:32:44 <cfoch> lambdabot: show "HELLO"
14:32:55 <cfoch> ah sorry...
14:34:24 <cfoch> guys... I want to print only the 'company' field of 'car' ?
14:34:25 <cfoch> http://fpaste.org/185622/23953035/
14:34:46 <cfoch> what should I do, I don't find an easy way
14:34:53 <EvanR> company is a function, Car -> String
14:35:10 <EvanR> so company car would be "Ford"
14:37:43 <Hiiliou> > testFork = forever $ forkProcess testFork
14:37:45 <lambdabot>  <hint>:1:10: parse error on input ‘=’
14:37:58 <Hiiliou> > let testFork = forever $ forkProcess testFork
14:37:59 <lambdabot>  not an expression: ‘let testFork = forever $ forkProcess testFork’
14:38:06 <error> hi!
14:38:58 <ReinH> :t ala
14:38:59 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
14:39:00 <ReinH> :t alaf
14:39:01 <lambdabot> (Rewrapped t s, Rewrapped s t, Profunctor p) => (Unwrapped s -> s) -> (p r t -> e -> s) -> p r (Unwrapped t) -> e -> Unwrapped s
14:39:13 <Hiiliou> import Control.Monad
14:39:24 <Hiiliou> > import Control.Monad
14:39:25 <lambdabot>  <hint>:1:1: parse error on input ‘import’
14:39:32 <cfoch> How safe is that? What If I define another data type with a field company, too ?
14:39:33 <cfoch> EvanR: I lost the connection to Internet
14:39:34 <cfoch> I don't know if you could read my message
14:39:35 <cfoch> "How safe is that? What If I define another data type with a field company, too ?"
14:40:07 <EvanR> cfoch: yeah in another module
14:40:20 <ReinH> cfoch: they will conflict unless they are qualified, yes
14:40:39 <Guest90276> so im still trying to get something that builds with "cabal run" to run in ghci. the cabal file links a resource directory, but even moving the contents of this file into the PATH does not allow ghci to run the program
14:42:29 <lyxia> It sounds like you need 'cabal repl'
14:42:42 <geekosaur> no, PATH wouldn't work for that, PATH is executables not random data files
14:42:55 * hackagebot atomic-primops-vector 0.1.0.1 - Atomic operations on Data.Vector types  http://hackage.haskell.org/package/atomic-primops-vector-0.1.0.1 (peter_fogg)
14:43:48 <Guest90276> performing "cabal run" in this directory https://github.com/ocharles/engine.io/tree/master/examples/latency pushes the index.htm in the "resource" directory to localhost:8000, but running main in ghci localhost:8000 shows an error indicating the html page was not pushed to the socket, and the browsers get request was not interpreted properly
14:44:47 <Guest90276> geekosaur, nice info, but i had just placed the main.hs into the resource directory
14:45:34 <Guest90276> lyxia i dont want to have to use cabal at all
14:46:12 <ReinH> Guest90276: ok, then you'll just need to call ghci or ghc with all the arguments and flags that cabal would have used for you
14:46:28 <Guest90276> thanks @ReinH
14:47:07 <Guest90276> i think cabal just specified the names of the resource directory and files contained within it
14:47:32 <dcoutts_> Guest90276: or perhaps you simply want to install the program?
14:47:41 <geekosaur> not sure that's sufficient. if it's using Paths_modulename then it will only work when compiled because ghci doesn't know (or indeed know how) to create it, and if it's using one created by cabal then it expects the data file to be in the install path
14:47:55 * hackagebot hypher 0.1.0 - A Haskell neo4j client  http://hackage.haskell.org/package/hypher-0.1.0 (jetaggart)
14:48:10 <Guest90276> dcoutts_ i would like to runi it within ghci
14:48:12 <dcoutts_> Guest90276: cabal run / cabal repl are doing it inplace, passing the data dir etc as args. Once the program is installed it can find its datafiles itself without any args.
14:48:16 <geekosaur> in short Paths_modulename was not designed for use with ghci
14:48:36 <dcoutts_> there's nothing ghci specific here
14:49:11 <dcoutts_> the issue is simply that you're running the thing inplace, so there's a special mechanism to find the data files
14:49:15 <Guest90276> geekosaur yes there are calls to Paths_modulename, i would like to remove its incorperation from the design of the program
14:49:17 <dcoutts_> once it's installed that's not needed
14:49:47 <dcoutts_> and what cabal run/repl are doing is passing an env var to override the location of the datafiles, so that it can work inplace in the build tree
14:49:56 <dcoutts_> you can do the same manually
14:50:12 <dcoutts_> or you can just install it, and then the data files will be in the expected location
14:50:19 <Guest90276> but the files are in the same directory, i dont want cabal confusing things by saving them elsewhere and having to reference this location with the module cabal creates called Paths_latency
14:50:39 <dcoutts_> then don't use the data files mechanism that Cabal provides
14:50:49 <dcoutts_> it's a choice, not compulsory
14:51:11 <Guest90276> i understand, but its not one i know how to use, or in this case, unuse
14:51:40 <dcoutts_> I take it you didn't write the code here
14:52:12 <dcoutts_> Guest90276: but the simple solution is to install the program, or if you want to use it from within the build tree, then use cabal run/repl
14:52:19 <dcoutts_> or you can set the env var
14:52:30 <Guest90276> no the link is to a module that is pretty key to the community and i did not write it, there are a few people complaining about not being able to use the examples and learn how to gain use of the module
14:53:06 <dcoutts_> what example are we actually talking about here?
14:53:55 <Guest90276> i understand that it is easy to use WITH cabal, i do not understand how to reverse engeneer the program to not use cabal... i cant even really find where the indicator that Paths_module should be used...
14:54:19 <Guest90276> the code is here https://github.com/ocharles/engine.io/tree/master/examples/latency
14:54:30 <unknownloner> are monads the only things you can use with do syntax?
14:54:54 <Guest90276> you can use let and if
14:55:03 <Guest90276> case e.t.c.
14:55:05 <shachaf> do syntax translates to (>>=) as specified in the report.
14:55:09 <unknownloner> not what I mean
14:55:14 <unknownloner> shachaf answered my question :)
14:55:18 <Guest90276> kk
14:55:26 <shachaf> You can use a different meaning of (>>=) with GHC's RebindableSyntax extension.
14:55:39 <shachaf> But it's very closely linked to monads regardless.
14:56:05 <dcoutts_> Guest90276: so it's designed to work from its installed location. You get that by running cabal install.
14:56:35 <dcoutts_> Guest90276: that way, cabal installs the data files into the location that the program expects to find them at runtime
14:56:57 <Guest90276> yes both cabal install and cabal run will produce the executable. how do i produce one with ghc main.hs after having rewritten to remove use of cables path_module referencing
14:57:14 <dcoutts_> Guest90276: but you can override the location of the data dir that it will look in by using the env var latency_datadir
14:57:29 <hexagoxel> (also note --bindir and --datadir install options)
14:57:35 <dcoutts_> Guest90276: see in Main.hs, the main method?
14:57:44 <dcoutts_> dataDir <- liftIO getDataDir
14:57:48 <Guest90276> yes
14:57:55 * hackagebot hypher 0.1.1 - A Haskell neo4j client  http://hackage.haskell.org/package/hypher-0.1.1 (jetaggart)
14:57:57 * hackagebot range 0.1.0.1 - This has a bunch of code for specifying and managing ranges in your code.  http://hackage.haskell.org/package/range-0.1.0.1 (RobertMassaioli)
14:57:59 * hackagebot hypher 0.1.2 - A Haskell neo4j client  http://hackage.haskell.org/package/hypher-0.1.2 (jetaggart)
14:58:03 <Guest90276> which is imported from the cabal produced Paths_latency.hs
14:58:10 <dcoutts_> that's getting the data dir that it is configured with, when you run cabal configure (or just install)
14:58:32 <Guest90276> so i remove this line and replace with a filepath of my own?
14:58:59 <dcoutts_> Guest90276: sure. Or you could configure with the data dir that you choose when you cabal install, with --datadir=
14:59:10 <Guest90276> im trying not to use cabal
14:59:26 <Guest90276> thanks ill try removing the dependancy on cabal by removing that line of code
14:59:38 <dcoutts_> and remove the import on the Paths_latency module
14:59:46 <dcoutts_> then just change the code to use whatever method you like to find the data files
14:59:48 <Guest90276> where is cabal being told to produce this paths module.hs?
14:59:59 <dcoutts_> if you don't use it then it doesn't matter
15:00:14 <Guest90276> i would like to know where cabal was told to do all this stuff
15:00:16 <dcoutts_> Guest90276: so just remove the Paths_latency module from the .cabal file
15:00:37 <Guest90276>   other-modules: Paths_latency
15:00:53 <Guest90276> https://github.com/ocharles/engine.io/blob/master/examples/latency/latency.cabal
15:00:56 <dcoutts_> yep
15:02:05 <hexagoxel> Guest90276: it is created default, but ultimately depends on `build-type` (and your `Setup.hs`)
15:02:20 <Guest90276> thanks
15:02:37 <Guest90276> import Distribution.Simple main = defaultMain
15:02:44 <Guest90276> thats all thats in setup.hs
15:02:48 <dcoutts_> that's normal
15:02:59 <Guest90276> nothing about paths_module.hs
15:03:13 <hexagoxel> yes, and defaultMain afaik defaultMain will, somewhere down the line, create the Paths_foo
15:03:26 <Guest90276> awesome
15:03:39 <Guest90276> hey guys thanks so much
15:03:42 <hexagoxel> but
15:03:48 <Guest90276> !
15:04:07 <hexagoxel> you need build-type custom for Setup.hs to matter (?) i am not completely sure about this
15:04:23 <Guest90276> i know nothing of build-type
15:04:29 <dcoutts_> this isn't important
15:04:44 <dcoutts_> it's a distraction
15:04:52 <Guest90276> yeh says build-type simple
15:05:03 <dcoutts_> you can safely ignore it and not know about the details
15:05:09 <hexagoxel> simple will probably default to something involving defaultMain
15:05:37 <Guest90276> ok dcoutts. i get that. all i need to know is that i can turn off this damn feature by removing the import of Paths_module.hs.. thats correct right?
15:05:46 <dcoutts_> Guest90276: correct
15:05:50 <Guest90276> sweeeeet!
15:06:26 <hexagoxel> it is not a good sign that people start avoiding cabal so viciously :/
15:06:52 <dcoutts_> there is a reason people want to have support for installing data files, and finding them at runtime
15:06:53 <Guest90276> i would use it myself if i had need to
15:07:00 <dcoutts_> but Guest90276 clearly doesn't need or want that
15:07:07 <Guest90276> but i am writing a tutorial that is for the newest of haskell users
15:07:41 <dcoutts_> Guest90276: hmm, so why do you want to avoid using install? Isn't that simplest, for new users?
15:07:53 <dcoutts_> you're still building with cabal afterall
15:08:47 <Guest90276> dcoutts_ no, as i have illustraited it opperates in a non transpearent way
15:08:58 <Guest90276> the easyest thing to do is type main in ghci
15:09:22 <dmwit> It is not easier than "cabal run", I wouldn't think.
15:09:36 <dcoutts_> Guest90276: ok fine fine, for the simplest of intro examples. But finding all data files in the current dir gets pretty tiring pretty quickly
15:09:53 <dcoutts_> it means you have to manually place the data files in the right place, and run from the right location
15:10:12 <dcoutts_> all traditional build systems have a way to install data files alongside an application
15:10:21 <dcoutts_> think classic ./configure --prefix=
15:10:39 <dcoutts_> Guest90276: but sure, for a first intro finding data files in the current dir is fine.
15:11:51 <Guest90276> i dont know if this is ok but here is a ltc for the first person to claim it... you can let me know if this is uncool and next time ill just post a private key BTC-E CODE: BTCE-LTC-N13CJ9NZ-HVW47WZ5-3JARPRJO-QCHQYG9U-8DY49FB7
15:12:42 <shachaf> Guest90276: This channel is not the right place.
15:12:48 <dcoutts_> Guest90276: for future reference, https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
15:13:04 <Guest90276> ok thanks, how do i tip those kind enough to help?
15:13:24 <dcoutts_> "thank you" is plenty :-)
15:13:34 <dmwit> Guest90276: name them, then add ++
15:13:37 <dmwit> dcoutts++
15:13:40 <dcoutts_> heh
15:13:46 <Guest90276> well dcoutts++
15:14:00 <dcoutts_> np
15:14:01 <Guest90276> and shachaf++
15:14:10 <Guest90276> and geekousaur++
15:14:35 <Guest90276> and hexagonel++
15:15:08 <Guest90276> and reinH++
15:15:13 <MP2E> heh
15:15:29 <ReinH> Guest90276: if you're writing a tutorial for new haskellers, I really think you should use cabal
15:15:50 <Guest90276> dont worry my friend, all is good in the hood
15:16:20 <ReinH> As in, I think it would be damaging to new Haskellers to give them the impression that compiling things required arcane arguments passed to ghc and that there isn't a better way
15:16:37 <athan> dcoutts_: I'm tempted to make a `cabal-utils` executable, for refactoring modules & possible integration with HaRe. Should I try and integrate this in cabal-install?
15:16:53 <ReinH> athan: does HaRe build on 7.8 yet?
15:17:03 <athan> Doubt it :\
15:17:05 <Guest90276> its thanks to lazy practice like not teaching kids cabal that has got me through 8 years of haskell without using understanding it at all, its only just become a problem and thanks to you lovely lot it is a problem no more
15:17:09 <athan> I'm planning on just doing all of it
15:17:25 <athan> Oh, and version bounds / api-compliance checker! I really want that
15:17:50 <dcoutts_> athan: it's quite common to prototype new cabal features as separate utils and sometimes integrate later, or integrate an improved design later
15:17:52 <athan> so we can have minumum / max bounds of dependencies automatically found based on the parts of the api you use from an import (hopefully)
15:18:05 <athan> dcoutts_: Awesome, thank you :)
15:18:17 <ReinH> Alright, never mind.
15:18:21 <dcoutts_> athan: so depends on how independent and large it is if it makes sense to try separately. Some things just don't make sense to do separately.
15:18:21 <athan> I'll try and make something useful
15:18:37 <Guest90276> hey does anyone know about the llvm backend?
15:18:49 <athan> hmm. Yeah, it depends, I'm not sure if I want a haskline interface or not
15:18:56 <jmcarthur> Guest90276: what about it?
15:19:03 <athan> but this is all just up in the air for now
15:19:11 <dcoutts_> athan: ultimately I want cabal to have more of an interactive interface, but that's another story.
15:19:23 <Guest90276> cogs whir. um does it need rewritten?
15:19:43 <jmcarthur> Guest90276: it should be working fine, so long as you have a supported version of LLVM
15:19:50 <Guest90276> looks like the guy who did it ran away and everyone is having problems with it
15:20:10 <athan> dcoutts_: Hmm! Okay, do you have a repo available for ideas to toss around?
15:20:43 <yac> running dist/dist-sandbox-93fd406a/build/Network/Info_hsc_make failed (exit code 127)
15:20:48 <yac> any idea what this is about?
15:20:58 <dcoutts_> athan: you mean for more interactive stuff in cabal? I've not done any active experiments
15:20:58 <jmcarthur> Guest90276: he did go away, but i'm not aware of problems with it (but to be fair, it's not like i'm in a position where i'm likely to hear about such problems)
15:21:25 <athan> dcoutts_: Okay, I'll let you know as soon as I come up with something :)
15:21:34 <athan> (worthy, anyway :x)
15:21:38 <dcoutts_> :-)
15:21:40 <dcoutts_> good luck
15:21:42 <Guest90276> i was thinking of using the llvm backend to compile some executable that would run on the gpu (obviously) but there was some reason i could not call it from a javascript app, something to do with results generated at runtime, i could find the stackexchange thread if im making no sense
15:21:56 <athan> thank you!! Same for you in your ventures~!!
15:22:19 <jmcarthur> Guest90276: your use case confuses me. that's not what the llvm backend is intended for.
15:22:23 <jle`> i found a function Maybe a -> Maybe b, where Just x return bottom and Nothing returns Nothing
15:22:29 <jmcarthur> Guest90276: do you mean some llvm *library*?
15:22:48 <Guest90276> i am also confused, this is probably why i have confused you
15:23:11 <Guest90276> no i want to compile to gpu bytecode, so i supply ghc with --llvm
15:23:23 <Guest90276> or some similar
15:23:25 <jmcarthur> Guest90276: the llvm backend isn't designed for that
15:23:40 <jmcarthur> Guest90276: it's for just generating normal machine code. the same kind of targets as the native backend
15:23:54 <Guest90276> yes
15:24:09 <Guest90276> thats what i wanted to use it for, how did i say differently?
15:24:20 <jmcarthur> Guest90276: it doesn't target GPU
15:24:28 <Guest90276> it should!
15:24:33 <mmmpork>  /ignore #haskell MODES JOINS PARTS QUITS
15:24:53 <Guest90276> http://www.reddit.com/r/haskell/comments/tgdia/llvm_now_supports_nvidia_gpus/
15:25:16 <ReinH> Guest90276: Agree it should. But it doesn't (yet).
15:25:17 <shachaf> There are many things that need to be done differently to compile code for a GPU.
15:25:17 <lightstep> jle`: fmap?
15:25:28 <lightstep> jle`: sorry, i misread
15:25:29 <ReinH> And it's not exactly trivial to make it.
15:25:32 <jmcarthur> Guest90276: just because the LLVM project is capable of targetting it doesn't mean everything that uses LLVM automatically has that capability
15:25:35 <Guest90276> so it needs rewritten...
15:25:46 <ReinH> Why?
15:25:55 <Guest90276> to provide gpu
15:26:00 <ReinH> Why does that require a rewrite?
15:26:14 <Guest90276> ok an extension
15:26:20 <Guest90276> or a maintainer at least!
15:26:26 <shachaf> If you want to generate good GPU code from Haskell code, you'll need to do a lot of work. This is true whether or not you use LLVM.
15:26:28 <srid> apparently learning SML/Ocaml first facilitates easier learning of Haskell for some: https://spyder.wordpress.com/2014/03/16/why-ocaml-why-now/
15:26:33 <jmcarthur> Guest90276: there's a huge amount of runtime support needed to support a new architecture or instruction set, even if you have a code generator that supports it
15:26:44 <Guest90276> i dont care i need it
15:27:01 <ReinH> Guest90276: go write it then
15:27:03 <jmcarthur> you could take the reins if you know what needs to be done
15:27:08 <Guest90276> thats what im saying!
15:27:34 <Guest90276> any1 fancy helping?
15:28:20 <EvanR> haha
15:28:48 <ReinH> Not really.
15:29:21 <dcoutts_> Guest90276: it's not the right approach. You don't want to compile general haskell code for a GPU, only special kernels. Even if you could do it, it'd perform badly because it's not what GPUs do well.
15:29:39 <dcoutts_> Guest90276: the existing Haskell GPU libs take a different approach, and perform very well.
15:29:45 <Guest90276> ok, i probably dont understand so well, but say i wanted to do a really fast matrix multiplication, i would normally use some fortran blas ported from C. but i want to use gpu so i compile using llvm with cuda support for example and then i invoke this program at runtime to handle my matrix multiplications?
15:29:59 <jmcarthur> Guest90276: you could try the accelerate library
15:30:20 <Guest90276> no accelerate is exactly what im trying to avoid
15:30:23 <jmcarthur> why?
15:30:34 <Guest90276> i need specific control over blas
15:30:36 <heatsink> If you want really fast matrix multiplication, you would use a vendor library like cublas
15:30:42 <jmcarthur> blas doesn't run on the GPU anyway
15:30:45 <jmcarthur> afaik
15:30:55 <Guest90276> cublas does
15:31:03 <jmcarthur> then why not just use cublas?
15:31:15 <heatsink> because cublas has been optimized for GPU register file size, scratchpad size, memory throughput, etc.
15:31:33 <Guest90276> yeh, so i dont want to use hblas (the haskell porting of fortran blas) because it is not for the gpu, so i need cuda-blas which compiles under llvm
15:31:36 <jmcarthur> there's apparently even a binding already written, which i didn't know about until now
15:31:44 <jmcarthur> Guest90276: https://hackage.haskell.org/package/cublas
15:32:19 <Guest90276> jmcarthur i had not seen that is very cool
15:32:47 <Guest90276> so this compiles to a normal exe and runs on the gpu...
15:32:53 <Guest90276> ?
15:32:53 <jmcarthur> Guest90276: notably, it doesn't not require you to compile your haskell to run on the gpu
15:32:57 <superfunc> I was wondering if anyone would mind looking at this: http://lpaste.net/120525
15:33:06 <superfunc> Having trouble reconciling type params
15:33:19 <jmcarthur> Guest90276: i think you misunderstand something. to use the gpu you just send code to the gpu dynamically. you don't statically compile your executable for it.
15:33:32 <jmcarthur> Guest90276: that's what this package is probably doing under the hood
15:33:41 <jmcarthur> Guest90276: same for accelerate, etc.
15:34:15 <Guest90276> the type signature for apply :: (Expr a -> Expr a) -> Expr a1
15:34:36 <Guest90276> maybe you dropped an "a1"
15:35:54 <dmwit> superfunc: a -> b -> c is a -> (b -> c), not (a -> b) -> c.
15:36:11 <EvanR> she's a superfunc, a superfunc
15:36:24 <superfunc> EvanR: nice
15:36:26 <dmwit> superfunc: So "r -> Expr a" with "Expr a -> Expr a" for "r" is "(Expr a -> Expr a) -> Expr a", but reduce has type "Expr a -> (Expr a -> Expr a)".
15:37:01 <superfunc> because of right-associativity?
15:37:14 <Guest90276> how do i do @ to direct a comment at a user?
15:37:28 <Guest90276> in the irc
15:37:35 <EvanR> Guest90276: like this
15:37:38 <Guest90276> lol
15:37:42 <Guest90276> good1
15:38:11 <superfunc> dmwit: Any suggestions on how to get around it?
15:38:15 <dmwit> superfunc: Well. Superficially, because of right associativity. But the fundamental reason is because those are just the types.
15:38:17 <Guest90276> EvanR: like this?
15:38:26 <dmwit> superfunc: I don't know. What are you trying to do with this type class?
15:38:29 <EvanR> yes
15:38:31 <Guest90276> wooo!
15:39:14 <superfunc> dmwit: be able to take (Expr a -> ... -> Expr a) and use apply on it to reduce to an (Expr a)
15:39:33 <Guest90276> jmcarthur: so yes i was confused about that. so the gpu, say nvidia, has some blas of its own that it exposes and that i can use by shouting at the hardware at runtime?
15:39:35 <dmwit> superfunc: why?
15:39:43 <dmwit> superfunc: What will you use that for?
15:39:46 <superfunc> building expression trees from lambdas
15:40:14 <dmwit> That goal doesn't seem to require this subgoal to me.
15:40:20 <Guest90276> it has some interface language and i just make messages that say (dot product these vecors fast plz)
15:40:45 <superfunc> totally, I could have a few eval functions for each type of expr
15:40:45 <jmcarthur> Guest90276: it's lower level than that, but i think you have a better intuition now
15:41:25 <Guest90276> but i need to be able to do this, so intuition is not enough! ill have a look at the haskell porting to cublas
15:41:41 <jmcarthur> Guest90276: i think maybe you should read the cublas documentation
15:41:47 <jmcarthur> Guest90276: the non-haskell documentation, that is
15:42:05 <Guest90276> the accelerate package looks to see where it can optomise fairly general code right? i dont want that, i want to say, this is how you do the boundary swaps you pesky gpu
15:42:17 <Guest90276> i use mpi
15:42:36 <superfunc> dmwit: I was just thinking it would be nice, if I could write a function that can take any of the exprs and handle it cleanly
15:43:26 <Guest90276> is this naieve? do i need this specific functionality or is accelerate really going to parellise my code in the neatest way?
15:43:37 <dmwit> superfunc: To me, that function has type Expr a -> Expr a, not some variadic type.
15:45:42 <Guest90276> the application in mind is a javascript program running in browser that can use cublas through haskell. the cublas haskell lib looks good, but how is it run by the javascript program, is it placed in an exe and invoked, or can i do these realtime calls to the gpu?
15:46:53 <yac> okay, this really doesn't look good https://gist.github.com/yaccz/c06a80050658402700bc
15:47:54 <Guest90276> jmcartur: you are afk?
15:50:55 <Guest90276> nooo
15:51:17 <yac> shouldn't cabal executable try to look up the parent directories wheter there is cabal sandbox config?
15:51:21 <yac> like git ...
15:52:13 <pharpend> Hey, I'm having some trouble with threading
15:52:39 <Guest90276> pharpend, what trouble?
15:52:45 <pharpend> http://lpaste.net/120528 is not behaving as expected
15:52:58 <pharpend> yac: you can never expect cabal to think for itself
15:53:07 <Guest90276> what do you expect this to do?
15:53:08 <pharpend> yac: cabal is too stupid to do any work for you
15:53:09 <zq> yac: it doesn't
15:53:24 <yac> it doesn't but wouldn't it be nice?
15:53:28 <pharpend> Guest90276: print "blah" to the console
15:53:32 <pharpend> yac: file a bug report
15:53:33 <hexagoxel> yac: there is an issue about it in the cabal tracker
15:53:38 <pharpend> well there you go
15:53:40 <pharpend> vote for it then
15:53:41 <zq> yac: copy the cabal-sandbox.config corresponding to the sandbox you want to pwd
15:53:42 <hexagoxel> and some discussion
15:53:51 <yac> zq: yeah that's what I figured
15:53:53 <hae> What a LTC is or how you even claim it is beyond me.
15:54:06 <Guest90276> you should include your imports in your snippits
15:54:14 <pharpend> Guest90276: yes, sorry
15:54:35 <Guest90276> control.concurrent
15:54:54 <pharpend> Guest90276: http://lpaste.net/120529
15:55:03 <Guest90276> so main produces the output "blah" whats wrong?
15:55:33 <pharpend> Guest90276: it doesn't produce that output, that's the issue
15:55:41 <pharpend> Guest90276: there's just no output
15:55:54 <Guest90276> it produces if for me as it should
15:55:59 <Guest90276> how are you building?
15:56:04 <pharpend> Guest90276: cabal
15:56:10 <Guest90276> try ghc
15:56:20 <Guest90276> ghci works
15:56:31 <pharpend> Guest90276: well that's weird
15:56:36 <jmcarthur> Guest90276: i was afk, sorry
15:56:38 <pharpend> Guest90276: ghc works too
15:56:41 <pharpend> what the hell
15:56:49 <Guest90276> sweet, glad to help
15:56:49 <jmcarthur> Guest90276: i don't know how you might use something like cublas via javascript
15:57:06 <jmcarthur> Guest90276: accelerate has clearly defined separating between cpu and gpu land
15:57:15 <jmcarthur> Guest90276: but again, not sure how all this would work via javascript
15:57:24 <jmcarthur> s/separating/seperation/
15:57:45 <Guest90276> jmcarthur: im sure you can still help tho, js isnt the focus here, its how to call to the gpu, is it via executable or some kind of socket?
15:58:03 <jmcarthur> Guest90276: it's via the drivers installed in your OS
15:58:24 <Guest90276> they are executables? they are run and then communicated with?
15:58:25 <pharpend> Guest90276: well it works in "cabal repl"
15:58:48 <Guest90276> yeh, maybe there is some problem with the stdio the way you did it?
15:58:58 <jmcarthur> Guest90276: ultimately you use some library, and that's all you have to know. it doesn't involve running some separate executable though.
15:59:15 <pharpend> I don't see why there should be any difference between manual GHC and cabal ghc
15:59:17 <Guest90276> how do i talk to these drivers?
15:59:28 <Guest90276> where are the sockets, what format do they use?
15:59:33 <Guest90276> these kind of concepts...
15:59:40 <jmcarthur> Guest90276: if you want to use CUDA you use CUDA. if you want to use OpenGL you use OpenGL. etc.
15:59:52 * hae facepalms
16:00:41 <Guest90276> er, not really. openGL defines a compiler that runs on the gpu, i want to make this myself, so i need to know how to access the gpu drivers i guess
16:01:06 <Guest90276> the compiler obvs dosent run ON the gpu, but somehow it makes bitecode and communicates it to the gpu
16:01:31 <jmcarthur> Guest90276: OpenGL is provided directly by the drivers. it's a library, not a compiler.
16:01:33 <Guest90276> so if i was getting js to use haskell produced bytecode...
16:01:48 <jmcarthur> Guest90276: the drivers have whatever compiler is necessary for GLSL, etc.
16:01:59 <Guest90276> glsl is a compiler i thought
16:02:02 <heatsink> I don't know what you mean about accessing the drivers
16:02:10 <jmcarthur> Guest90276: GLSL is a language defined as part of the OpenGL spec
16:02:20 <heatsink> CUDA, OpenCL, DirectCompute, and some other APIs are interfaces for accessing the drivers.
16:02:22 <jmcarthur> Guest90276: and the drivers include the compiler for it
16:02:34 <Guest90276> it takes text descriptions and communicates bytecode to the gpu, they even have their own way of prducing the bytecode
16:02:53 <Guest90276> thanks heatsink:
16:03:02 <jmcarthur> Guest90276: you aren't normally supposed to know or care about the format of these GPU-specific executables
16:03:19 <pharpend> Guest90276: it looks like I have to do something to stdout beforehand - because if i put a "putStrLn" before, it works
16:03:40 <Guest90276> until there is an easy web gpu blas interface for js, there needs to be written one, this is what im trying to achieve
16:04:12 <jmcarthur> Guest90276: then you will be working in the js implementation or something, not at the haskell level.
16:04:13 <heatsink> Does javascript have a foreign function interface?
16:04:20 <Guest90276> glsl.js works, but i want haskell libs
16:04:40 <Guest90276> i am communicating between haskell and js via a websocket
16:04:46 <jmcarthur> Guest90276: if there is an existing js library to do it, then you just want to write some FFI bindings
16:04:55 <jmcarthur> ah, so you aren't actually targetting js
16:05:08 <jmcarthur> in that case you just need to come up with a protocol of your own
16:05:17 <jmcarthur> and have the js side do whatever it needs to do
16:05:32 <Guest90276> haskell should receive a request at its listening socket and provide gpu bitecode to js who then can send it to the gpu driver.... thats the idea nayway
16:05:34 <hae> If you really need high performance rendering that much why go through all the convoluted steps of JS and Haskell and websockets instead of writing a native client...
16:05:48 <hae> I mean seriously.
16:05:51 <jmcarthur> Guest90276: the driver generated the bytecode for you
16:06:01 <jmcarthur> *generates
16:06:05 <jmcarthur> Guest90276: you don't generate that
16:06:22 <Guest90276> hae: how o you mean write a native client?
16:06:23 <hae> At that point the bottleneck isn't how fast your GPU works but network latency.
16:07:18 <Guest90276> jmcarthur: ok so haskell maybe sends a datatype that is read by js and used to call the driver and tell it what code to run
16:08:09 <jmcarthur> something like that. however, I agree with hae that this sounds very convoluted. why are you designing this as Haskell->websocket->JS->GPU?
16:08:55 <Guest90276> hae i will render from the client side, the networking is done by that point, and the work required of the gpu can be specified with small packets of onformation through the socket e.g. send through the socket the command "draw me a shiney sphere" wich is interpreted by the client side gpu driver
16:09:47 <jmcarthur> Guest90276: hae's point is that the network latency of sending the instruction to draw a sphere easily dwarfs the rendering time
16:10:07 <Guest90276> i am using haskell because it has the correct libraries ported to it, i am using js because it has other libraries (can comunicate with the html canvas ellement for e.g.) and rn in browser
16:10:25 <Guest90276> js is needed by the browser, haskell is needed by me, to write my gpu calls
16:10:34 <jmcarthur> Guest90276: so getting caught up on using the GPU efficiently is probably not going to make anything noticable faster
16:10:53 <jmcarthur> Guest90276: also, adding haskell to the server side isn't going to make it any easier to interface with the client's GPU...
16:11:15 <jmcarthur> Guest90276: ultimately you still have to interface with it via javascript
16:11:25 <Guest90276> also i dont agree that the rendering will be faster than the network. i can send, pan the camera round the scene clockwise for 1 min, and the prog will work as hard as it can clientside to achive this rendering
16:11:25 <hae> You haven't provided much information about the actual use case but I'd say OpenGL/WebGL is all you need on the client side.
16:12:10 <Guest90276> i dont want to write in webGL i want to use haskell
16:12:22 <jmcarthur> then make a haskell to webgl compiler
16:12:29 <Guest90276> yes thats the idea
16:12:37 <jmcarthur> that is nothing like what you've been describing
16:12:39 <Guest90276> but i want it to work realtime
16:12:52 <jmcarthur> that's just not how this works.
16:12:54 <Guest90276> yes it is, my haskell code produces messages that are interpreted by js
16:13:06 <jmcarthur> yeah, and the js side is what actually uses webgl
16:13:10 <jmcarthur> not haskell
16:13:23 <Guest90276> no i dont want to use webgl, i want to use hcublas
16:13:27 <hae> Okay then, assuming that more than one person is going to use the application, you need to collect detailed information on their GPU to send to the server, so that the server can select how to render it.
16:13:33 <jmcarthur> you don't have this option
16:13:44 <hae> I don't think that's even accessible from the browser.
16:13:57 <Guest90276> hae, yes.
16:14:09 <Guest90276> hmmm
16:14:54 <Guest90276> its not a small problem, the browser really struggles to target the gpu, but i think it can, so it should be able to get the info you describe
16:16:32 <geekosaur> I think it can't. not for technical reasons but security ones. (go look at how many chrome security issues involve at some point breaking down the barrier between js and rendering)
16:16:35 <Guest90276> jmcarthur: i dont have the option of sending realtime messages from haskell, given i know all the details of the target gpu, and pass these messages to the client to run on the gpu via js? but i think i do have this option, it is the current project to create such functionality
16:17:18 <jmcarthur> if you really knew how it works then you wouldn't be asking us. if you want to continue to be unsatisfied with our suggestions and objections, feel free to change the entire stack GPU/OS/drivers/browser/network/compiler/runtime/libraries stack
16:17:21 <hae> http://i.lvme.me/25hhabl.jpg
16:17:51 <Guest90276> geekosaur, there is a way of doing it by sending js code that would invoke glsl.js. there are ways
16:18:11 <EvanR> reinvent the entire software world
16:18:33 <Guest90276> to achive something everyone wants but is impossible, yes
16:18:48 <Guest90276> is possible, is not yet implemented
16:18:50 <EvanR> nothing is impossible!
16:19:00 <jmcarthur> what are you hanging around here for then? if you know what you want then just do it'
16:19:14 <hae> Sounds a lot like DRM to me. And it's only tangentially related to Haskell at this point.
16:19:15 <Guest90276> i have intuative holes you are helping elucidate
16:19:27 <Guest90276> i know the project is convoluted but it is what i want to achive
16:19:36 <Guest90276> i just need to know how to do it
16:19:38 <jmcarthur> you are being rather argumentative about those holes
16:20:01 <jmcarthur> *seem to be
16:20:10 <jmcarthur> sorry, i don't mean to offend or escalate
16:20:15 <Guest90276> jmcarthur: perhaps. i am only defending my motivation and that it is possible when im being told its not
16:20:44 <Guest90276> its ok
16:21:05 <jmcarthur> Guest90276: could you describe precisely what it is you are claiming is possible? if you are precise enough i can probably give you a solid yes/no
16:21:41 <hae> http://rs1img.memecdn.com/mission-impossibru_o_208688.jpg
16:22:02 <jmcarthur> hae: let's... not do that
16:22:18 <Guest90276> i just think the bits where ppl say "your doing it silly" maybe miss the point of why its being done that way. i dont mind arguing about it because it may well be very ill conceived. by describing the motivation and approach i only hope to help you find where my miunderstanding lies so that you may help me design the solution in a more practical way
16:22:41 <Guest90276> ok ill describe
16:24:55 <Guest90276> browser is to submit a request to gpu to render a specified scene. this is done through either glsl.js or some haskell produced code for the gpu drivers. haskell either sends the browses js program aclls that invoke particular glsl calls or it produces the stuff for the gpu drivers that glsl.js would have produced and js then only needs to submit these to the drivers
16:25:44 <jmcarthur> the version that is possible is the version that actually involves glsl.js
16:25:52 <Guest90276> no
16:25:59 <Guest90276> it must not be so!
16:26:05 <jmcarthur> why not?
16:26:08 <Guest90276> i cant see why it would have to be the case
16:26:17 <jmcarthur> that doesn't not mean it is not so
16:26:27 <Guest90276> glsl produces messages for the gpu, as does hcublas.
16:26:44 <jmcarthur> now, it is possible that you could look at how glsl.js works, and it may have some support code you can skip, but most of it is probably just bindings
16:26:56 <jmcarthur> both of those communicate with a local gpu though
16:27:02 <Guest90276> glsl submits these messages to the gpu, so i can use js to submit the output of hcublas to the gpu driver
16:27:08 <jmcarthur> no
16:27:22 <Guest90276> i can find how glsl does so and do it myself
16:27:37 <hae> Welp makes absolutely no sense. I give up.
16:27:39 <orzo> I don't understand this prompt from cabal init: "Include documentation on what each field means (y/n)?"
16:27:48 <jmcarthur> if you want to prove otherwise, i encourage you to go do it. but as we don't believe it is possible, we obviously cannot help you
16:27:54 <hpc> orzo: it puts comments in the cabal file
16:28:03 <shachaf> orzo: Cabal generates a .cabal file. If you say y, it'll add comments explaining what each field it generates means.
16:28:12 <hpc> orzo: http://hackage.haskell.org/package/ghc-man-completion-0.0.0.3/ghc-man-completion.cabal -- like these
16:28:18 <orzo> so nothign to do with haddock generation?
16:28:20 <shachaf> orzo: If you can think of a better way of phrasing the message, you could suggest it to the Cabal folks.
16:28:27 <shachaf> Nothing to do with Haddock.
16:28:49 <Guest90276> so glsl.js produces messages for the gpu driver and submits them but you can believe that js can send messages produced by haskell to the gpu?
16:29:11 <hpc> i would have it say "Add informative comments to cabal file"
16:29:23 <orzo> yes, i second hpc's suggestion
16:29:44 <orzo> send it to the cabal people cause i'm lazy
16:29:48 <hpc> cba to go through the whole process for that one string though
16:29:51 <jmcarthur> Guest90276: the way i envision it working is you communicate some messages of your own protocol from haskell land to js land, then in js land you interpret those messages to execute the appropriate driver calls
16:30:08 <orzo> me either :(
16:30:34 <Guest90276> so i wrap glsl.js. i get that will work. i dont see why the other way cannot
16:31:08 <jmcarthur> how would the other way work?
16:31:29 <jmcarthur> there's no output from something like cublas to send anywhere
16:31:39 <jmcarthur> not which represents what the GPU is to do, anyway
16:31:55 <Guest90276> for instance another way that should work is to emulate the gpu driver in js and have a 1-1 mapping so hcublas thinks the socket is actually a gpu driver?
16:32:08 <jmcarthur> why do you think there is a socket?
16:32:14 <geekosaur> the actual interface between the GPU and CUDA library is specific to the GPU and usually protected by copyright and/or trade secret
16:32:25 <Guest90276> cublas sends its output to the drivers? it has an output and sends it?
16:32:33 <Guest90276> there is a socket because thats how i talk to js
16:32:34 <jmcarthur> that doesn't mean there's a socket
16:32:50 <jmcarthur> that's not necessarily the way you talk to your GPU
16:33:51 <Guest90276> geekosaur: yes i am forced to use either hcublas or glsl.js to interact with the gpu as they have this proprietary functinality preimplemented
16:34:15 <geekosaur> you keep talking abotu collecting some kind of output bytecode
16:34:21 <Guest90276> yes
16:34:22 <jmcarthur> Guest90276: both are only useful to communicate with your *local* drivers, which means your *local* GPU
16:34:57 <jmcarthur> Guest90276: these libraries *interact* with your GPU. they don't just generate a bunch of code and dump it somewhere
16:35:04 <geekosaur> the only place it's writing that is /dev/dri/cardN
16:35:07 <Guest90276> i cant pass the clients driver to look like a socket in the server side..
16:35:18 <geekosaur> which is a kernel device driver interface
16:36:03 <Guest90276> sounds good geekosuar but could you rephrase i dont quite get your language there
16:36:15 <geekosaur> ...
16:36:26 <geekosaur> you should learn it because you will need to know it
16:36:30 <Guest90276> "the only place its writing that is"
16:36:47 <geekosaur> [15 00:31] <geekosaur> you keep talking abotu collecting some kind of output bytecode
16:36:56 <arw_> geekosaur: not for nvidia cards which is what cuda works with.
16:37:11 <Guest90276> if its not bytecode its formated for the driver to interpret
16:37:20 <geekosaur> arw_, I imagine there is still a kernel device driver?
16:37:30 <Guest90276> i hope so
16:37:34 <arw_> geekosaur: they have their own proprietary interface in /dev/nvidia (which basically does the same stuff, but its secret and different)
16:37:40 <geekosaur> because if there is not then someone is doing something horrily insecure somewhere
16:37:47 <geekosaur> ok, that makes sense
16:38:07 <Guest90276> so call it, say, driverCode?
16:38:11 <geekosaur> still, this is not a socket, it is not something you can intercept and not something you can emulate, it is a *kernel driver interface*
16:38:19 <Guest90276> and i send this message to the client not the host
16:38:22 <geekosaur> uou "emulate" it by adding a new driver to your kernel
16:38:40 <arw_> geekosaur: it is horribly insecure. you somehow submit cuda or glsl code, that gets compiled by nvidias libGL/libcuda/whatever, which contains a gpu-specific compiler.
16:39:12 <geekosaur> arw_, it still has at least permissions. the alternative would be something with no access controls at all
16:39:16 <arw_> geekosaur: the kernel just passes all that code through to the gpu, with minimal checks, because the kernel part needs to be open source which nvidia doesn't like.
16:39:19 <geekosaur> but I think I managed to confuse everyone
16:39:34 <orzo> i motivated myself and filed an issue for your suggested phrasing, hbc.
16:39:57 <Guest90276> yes yes all this makes sense but i dont see where me not being able to collect [the message interpreted by the kernel driver interface] and send it to someone elses driver?
16:40:05 <arw_> geekosaur: yes, the problem is, the gpu code may actually do arbitrary dma, and you just rely on the proprietary highly secret and super-buggy nvidia glsl compiler not to screw up
16:40:34 <geekosaur> Guest90276, because you presumably think that /dev/nvidia is something you can replace with a program or a socket
16:40:44 <geekosaur> you replace it by installing a new driver in your kernel
16:40:53 <geekosaur> there is no other way
16:41:23 <Guest90276> so i write a new driver that looks just like dev/random, but it actually just bounces the instructions through a socket and runs on the host
16:41:37 <Guest90276> on the client*
16:41:40 <geekosaur> (or, you try to get nvidia to give you source to their library that talks to /dev/nvidia so you can rewrite it to talk to a socket somehow. good luck if it uses ioctl.
16:41:42 <geekosaur> )
16:42:06 <arw_> Guest90276: forget it. rumour has it, the nvidia driver magically verifies its running with "normal" hardware by measuring timing and stuff.
16:42:08 <geekosaur> (also good luck convincing nvidia to give you source that they refuse to give to anyone)
16:42:44 <geekosaur> seriously the point of CUDA is to hide the hardware details the vendors refuse to release
16:42:45 <Guest90276> arw_ so it wont look like the host has generated and submit the message to its driver?
16:42:50 <hexagoxel> hpc: regarding "Include documentation on what each field means": i have made the change and will include it in the next documentation pull request
16:42:53 <arw_> Guest90276: so they can prevent people to decode their highly secret "how the gpu does stuff" magic and write their own driver or make their own gpu
16:43:07 <geekosaur> what you claim you want to do is exactly what they want to PREVENT you from doing
16:43:40 <geekosaur> (get access to their proprietary information about talking directly to their hardware)
16:43:44 <Guest90276> FFS!!! why is it always like this!!
16:44:04 <Guest90276> i cant believe nvidia would limit this functionality that is essential for serverside rendering
16:44:10 <arw_> Guest90276: its not always like this, at least if you limit yourself to open source software and open hardware.
16:44:16 * cmccann can believe that easily
16:44:29 <Guest90276> so i use amd and openCL, same project
16:44:32 <orzo> Anybody know offhand if the Generics-based default-signatures for Data.Binary are equivelent to what GeneralizedNewtypeDeriving would give me?
16:44:39 <arw_> Guest90276: they want to sell you extra-expensive quadro gpus with "virtualization" features...
16:44:41 <geekosaur> nvidia wants to sell you it, not help you write it
16:45:48 <geekosaur> same reason apple is proprietary all over the place, they're selling hardware, they don't want you to be able to replace it with third party hardware or to borrow someone else's hardware instead of buying it or etc.
16:45:53 <Guest90276> er, so im using some other haskell package probably hopenCL to produce messages for an amd driver to run on the client gpu, same problem?
16:46:21 <arw_> depends. there are open specs and open drivers for amd gpus.
16:46:39 <arw_> so you can take a look at what exactly they are doing and use that.
16:46:47 <Guest90276> so i can successfully emulate them...
16:46:53 <arw_> (at least if the "open" part includes openCL, which I don't know)
16:47:00 <Guest90276> me neither
16:47:11 <Stratege> Guest90276 is there a particular reason why you -want- to emulate it on your server instead of having the client do it?
16:47:31 <Guest90276> yes, the server is a huge rendering farm
16:47:57 <Guest90276> the physics of the image are much more intensive on the gpu than the rendering
16:48:50 <Guest90276> the only use for the client gpu is in displaying the scene on the users screen, i dont know maybe it can display to a html canvas
16:49:25 <Guest90276> the server needs to use haskell to produce the message that will be parsed by the clients js to run on their gpu
16:49:35 <arw_> hrm. and "traditional" mechanisms for that like tigerVNC or rdesktop?
16:49:54 <arw_> (which would be a different layer and approach, but it is remote display stuff)
16:50:12 <Guest90276> i had not seen those
16:50:14 <Guest90276> they look nice
16:50:39 <Guest90276> i could provide a gpu capable webpage with remote scene rendering?
16:50:57 <Guest90276> generation* client side gpu rendering
16:51:33 <arw_> those wouldn't exactly be webpage stuff, its not http based. but they provide remote opengl or d3d rendering
16:51:36 <Guest90276> and use haskell to pipe this output?
16:52:09 <Guest90276> they provide remote rendering, but its not going to go into a html canvas, it will run in a new window?
16:52:16 <Guest90276> that would be a strange webpage...
16:53:00 <Guest90276> im not even sure, do you know if glsl.js runs in a new window?
16:53:22 <Guest90276> hmm, its a step back from what i was trying to achieve
16:53:43 <Guest90276> and the tools to do what i want are all there, except this driver interface emulator...
16:54:29 <arw_> and if you don't do client side rendering at all and just render on the server and stream to some video format like h.264?
16:54:33 <Guest90276> its going to be hard to use hopengl with tigervnc?
16:54:59 <Guest90276> the video format is not good if i want user interface
16:55:10 <Guest90276> i want mouse listener
16:55:37 <Guest90276> also then it is a huge load on the socket
16:55:46 <Guest90276> i dont think the socket will be realtime like the gpu
16:56:07 <Guest90276> basically i want real time ray tracing on the client gpu
16:56:12 <arw_> depends. if your textures and your scene graph are sufficiently large then you will have huge latency problems anyways.
16:56:14 <Erdos> yeeeeshhh
16:56:22 <Stratege> and you are sure that the data to render the display would be less than it takes to stream the video?
16:56:36 <Guest90276> yes
16:56:40 <Erdos> I twitch anytime I hear realtime and raytracing
16:56:50 <arw_> Erdos: ack.
16:57:27 <Guest90276> "draw shiney circle here where shiney means this [data]" being smaller than the output number of pixles
16:58:28 <Guest90276> Erdos: its cool with monte carlo we can itterate towards a sexy image and not worry about how good it ends up looking with the knowladge it woudl look great if it wasnt so busy changing
16:58:31 <arw_> if shiney isn't a texture, yes.
16:59:05 <Erdos> Guest90276: If you're after a pretty low resolution
17:00:27 <Guest90276> Erdos, it would be full HD if it were simple enough scene to render, if it moves and requires a large amount of recalculation it will be low q, but if it is not changing the gpu will be free to render the image fully
17:00:55 <Guest90276> https://developer.mozilla.org/en-US/demos/detail/zen-photon-garden/launch
17:01:08 <Erdos> It'd only be faster if your simple scene doesn't move, then
17:01:08 <Guest90276> monte carlo real time ray tracing
17:01:33 <Erdos> and reflections and whatnot take longer
17:01:35 <Guest90276> by move, a simple translation should be ok, a changins lightsource maybe not so
17:01:55 <Guest90276> yeh you get the idea. i hope ur less scared of real time ray tracing now
17:03:04 <fryguybob> Guest90276: If you want to know the details of the complications around the interface with GPU's you should look at this work: http://www.cs.rochester.edu/u/kmenycht/
17:03:21 <Guest90276> so the problem is how to generate instructions for a remote gpu driver
17:03:21 <cjenkin2> I'm looking for a Haskell library that might fit my needs here: I have text logs of a low-level byte protocol. There are "sequences" in these logs that I know *exactly* what they should be, and just want to find these sequences and diff them with a file that is known to contain the correct sequence (nothing else).
17:03:33 <cjenkin2> If they differ, I want to create a diff of the sections
17:03:40 <Guest90276> thanks fryguybob:
17:03:40 <fryguybob> Also this discussion is probably better suited for #haskell-game (there is lots of talk there about realtime raytracing)
17:04:15 <Guest90276> cjenkin2: "diff" them?
17:04:46 <cjenkin2> Guest90276, Using the Linux utility *diff*
17:04:58 <cjenkin2> Or whatever library has an equivalent
17:05:09 <Guest90276> fryguybob, i was just reasuring someone scared of it, its not the discussion here, there is a problem running on remote gpu with haskell
17:05:53 <Erdos> Guest90276: Scared? Well I never... (=
17:05:56 <geekosaur> Guest90276, if you want to command a GPU remotely then you probably want to come up with some way to encode CUDA calls into a web-usable API. you cant go below the UDA level because nobody will give you anything other than the CUDA library to do so
17:06:27 <Guest90276> cjenkin2: i would drop the external function, which you can call from System.Process
17:07:14 <geekosaur> Guest90276, I think you missed the point.
17:07:22 <Guest90276> look for a pure haskell library that does this "diff" stuff. i take it you know Prelude.List?
17:07:30 <cjenkin2> Guest90276, What do you mean "external"? Presumably System.Process lets me execute shell commands, which is good
17:07:35 <geekosaur> they're not actually using the diff utility. they are looking for exacly what you are describing
17:07:50 <cjenkin2> Guest90276, I can find my way around the Prelude, yes
17:07:51 <geekosaur> the "diff" utility is the source of the shorthand term for such a library
17:08:06 <Guest90276> sorry, Data.List
17:08:20 <cjenkin2> Ah, ok. Still though, I can find my way around
17:08:27 <Guest90276> and Data.List.Split
17:08:54 <geekosaur> siiigh.
17:08:59 <cjenkin2> Guest90276, Hmm, let me look at that
17:09:00 <Guest90276> i guess i would be tempted to implement the "diff"stuff in pure haskell thats all
17:09:37 <Guest90276> oh gookosaur: sorry i didnt knw
17:09:58 <Guest90276> geek* lol
17:10:13 <cjenkin2> Guest90276, Let me also clarify that one input is a very large text file, and I not only want to find differences in these sequences but also locate the sequences in the file, which may or may not be a perfect match
17:10:26 <Guest90276> you probably want to come up with some way to encode CUDA calls into a web-usable API.
17:10:30 <Guest90276> yes this was the problem
17:11:02 <Guest90276> the one good surgestion so far is to write an api for glsl.js
17:11:03 <cjenkin2> I'll be assuming the the first few bytes will be preserved, but that's not guaranteed
17:11:26 <Guest90276> but id rather use hcblas
17:11:39 <Guest90276> since its done already for me!
17:12:07 <Guest90276> i guess this just transfers the problem with how to handshake a remote gpu from hcblas...
17:13:11 <Guest90276> cjenkin2: if it is so large will you be using a buffer to be kind to your stack?
17:13:31 <Guest90276> im not sure if thats the right way to handle large files but that how i do it. anyone?
17:13:46 <cjenkin2> Guest90276, Oh that's not necessary. It's too large to do by hand, but not too large to load into ram
17:14:03 <Guest90276> yeh for gb of data i use a buffer
17:14:18 <cjenkin2> 386kB data
17:14:33 <cjenkin2> Pennies
17:14:49 <Guest90276> yeh look at Data.List.Split, i think that has a splitat function which should make chunks at desegnated substrings
17:16:03 <Guest90276> Data.List.Split.splitOn "x" "axbxcx"  ["a","b","c",""]
17:16:12 <cjenkin2> Guest90276, So I load the whole file into memory, then split at say "0x11:1\n0x00:0" (first two bytes of a known sequence)
17:16:25 <cjenkin2> (9-bit protocol, btw. Thus the extra 0/1)
17:16:50 <Guest90276> splitOn is what you are looking for?
17:17:24 <cjenkin2> Guest90276, For that approach looks like it. I'm wondering what I'm supposed to do if the first bytes are dropped / corrupted
17:17:37 <Guest90276> lol
17:17:54 <Guest90276> randomly change the whole string until its right!
17:18:01 <cjenkin2> There's another sequence that always follows - 0x17:1\n0x00:0. I could just count to make sure these are the same
17:18:14 <Guest90276> sounds good
17:18:15 <cjenkin2> Presumably *both* of these being dropped would be rare
17:18:37 <cjenkin2> Guest90276, Ok, thanks. I have an idea how to start now :)
17:19:06 <cjenkin2> I'm also doing this to show off Haskell to my coworkers. Good PR
17:20:32 <Guest90276> you could maybe do; split (onSublist "xyz") "aazbxyzcxd" == ["aazb","xyz","cxd"]?
17:23:55 <Guest90276> also you can just make arrays of the string zipped itterativly with its tail to make a matrix of substrings
17:27:41 <Guest90276> e.g. (\a->startsWithOneOf ["10","11"] (zipWith (\a b -> [a,b]) a (tail a)))) "0001001100" == ["000","100","1100"]
17:28:47 <cjenkin2> Guest90276, One sec, looking these over
17:29:14 <Guest90276> er not correct on the rhs should be processed to end up looking like the one i wrote.
17:30:08 <Guest90276> infact thats a mess sorry
17:32:04 <cjenkin2> Ah, I see this is from a library. This will be the first time I hazard cabal for writing a library
17:34:56 <Guest90276> your writing a library?
17:35:04 <Guest90276> why not just write a program?
17:35:37 <Guest90276> in ghci write :m Data.List.Split
17:35:45 <cjenkin2> Guest90276, Sorry, I meant using a library
17:36:01 <Erdos> Someone is writing all these libraries
17:36:14 <Erdos> I have no idea who
17:36:18 <Guest90276> cabal install split, but maybe it comes with the haskell platform and you dont need to get it using cabal...
17:36:23 <cjenkin2> <no location info>:
17:36:23 <cjenkin2>     Could not find module Data.List.Split
17:36:24 <cjenkin2>     It is not a module in the current program, or in any known package.
17:36:27 * dcoutts_ spends almost all his hacking time writing libs and not applications
17:36:34 <cjenkin2> I have it - cabal says so. I've got a paths issue
17:37:10 <cjenkin2> Guest90276, Ah, ok. I was using Emacs. GHCI seems to know where it is
17:37:16 <Guest90276> yup
17:37:54 <cjenkin2> Now the question is, how to point Emacs to it, I guess
17:40:16 <wolf_mozart> how do i generate random numbers that are randomly distributed?
17:40:28 <wolf_mozart> normally distributed*
17:41:13 <c_wraith> If you're looking for specific distributions, I'd check out the random-fu package
17:41:17 <c_wraith> @hackage random-fu
17:41:17 <lambdabot> http://hackage.haskell.org/package/random-fu
18:08:28 <lf94> Is anyone familiar with how to fix this? Google brings up nothing relevant: haste-compiler-0.4.4.1 depends on bzlib-0.5.0.5 which failed to install.
18:08:38 <lf94> (Debian sid)
18:08:47 <lf94> Er actually debian wheezy
18:09:39 <KaneTW> lf94: if you provide more context we could help you
18:09:46 <lf94> Ok :)
18:09:48 <geekosaur> someday someone will invent a way to trick people into actually including the useful part of an error...
18:10:02 <c_wraith> lf94: the error message is not the last line
18:10:14 <c_wraith> lf94: it's probably telling you that it couldn't find the headers for bzlib
18:10:16 <lf94> I'm pastebinning the entire installation process
18:10:32 <lf94> Sometimes pasting 1 line helps
18:10:33 <c_wraith> lf94: try finding the appropriate -dev package to install the headers in apt
18:10:39 <lf94> but when it doesn't, I like to post everything
18:10:44 <lf94> Ah\
18:10:46 <lf94> Alright
18:10:58 <shachaf> If you post everything, it includes the last line, and that way people don't have to ask. :-)
18:11:30 <shachaf> You can paste error at hpaste.org
18:11:49 <lf94> can you post from command line to hpaste?
18:11:52 <shachaf> errors
18:11:53 <shachaf> I doubt it.
18:12:11 <shachaf> Well -- certainly, but I doubt there's a premade command line for it.
18:12:15 <c_wraith> lf94: ah, try the libbz2-dev package
18:12:35 <lf94> shachaf, yea i'll have to write a tiny curl script :)
18:12:43 <lf94> I'll try what c_wraith is suggesting first
18:13:03 <c_wraith> lf94: it's just a guess, but it's based on seeing many of this sort of error. :)
18:13:57 <lf94> Yep that was the issue :)
18:14:08 <lf94> Thanks c_wraith
18:14:12 <lf94> Time to use haste B)
18:14:22 <lf94> haste is such a great transpiler
18:14:39 <lf94> Even the way the author wrote the html libs and selectors is just great
18:22:59 * hackagebot wai-static-pages 0.3 - generate static html pages from a WAI application  http://hackage.haskell.org/package/wai-static-pages-0.3 (GregWeber)
18:24:14 <briareus> i finally managed to write a fibonacci list generator! it's a great way of stalling my computer :p
18:32:14 <lf94> briareus:  lol. how small is the code?
18:32:35 <briareus> fib :: Int -> [Integer]
18:32:36 <briareus> fib x = (map fib [0 .. (x-1)])
18:32:36 <briareus> 	where fib 0 = 0
18:32:36 <briareus> 	      fib 1 = 1
18:32:38 <briareus> 	      fib n = fib (n-2) + fib (n-1)
18:33:22 <briareus> i'm working through the Euler problem set, and learnyouahaskell
18:33:27 <silver> briareus, go for Ackermann function now :D
18:33:33 <blackdog> briareus: not the fastest way of working that out, but at least it'll warm your room up
18:33:37 <briareus> i'll look it up :)
18:33:51 <briareus> haha yep, it's just using the things i've learned / figured out so far
18:34:01 <briareus> i realise there are more optimised algo's out there
18:34:23 <Stratege> there's a really cool way in Haskell to rewrite it to be O(n) and even shorter, have fun figuring it out :D
18:34:37 <jmcarthur> dang, i was just about to spoil one way
18:34:59 <briareus> ha it's cool, there are plenty of methods on the net, i just don't understand them at this point
18:35:21 <briareus> first dip into functional programming
18:35:21 <blackdog> briareus: one of them is cute because it relies on laziness
18:35:38 <blackdog> can efficiently define the whole infinite structure of fibonacci numbers
18:35:40 <briareus> blackdog that's my kind of function
18:35:43 <blackdog> heh
18:35:54 <betaveros> help, this is about my seventh time reinstalling GHC over the last few days and now I realized I can’t get the library documentation for base and the documentation for everything else to show up together
18:36:16 <hae> We adhere to the values of the Lambda Knight. Strength, purity, and laziness.
18:36:46 <csd_> What is the difference between $ and $! ?
18:37:27 <blackdog> csd_: $! forces the right hand side
18:37:32 <blackdog> > const 1 $ undefined
18:37:34 <lambdabot>  1
18:37:38 <geekosaur> @src ($)
18:37:38 <lambdabot> f $ x = f x
18:37:38 <blackdog> > const 1 $! undefined
18:37:40 <lambdabot>  *Exception: Prelude.undefined
18:37:43 <geekosaur> @src ($!)
18:37:43 <lambdabot> f $! x = x `seq` f x
18:37:57 <geekosaur> note that this only goes to WHNF
18:38:07 <geekosaur> (so, for a list, it only forces nonempty vs. empty)
18:38:08 <csd_> So without the seq it remains lazy?
18:39:13 <blackdog> pretty much. what geekosaur means by WHNF is that it will evaluate it is as far as it needs to to reach a constructor of some kind
18:39:44 <geekosaur> right, I used list as an easy to understand example
18:39:56 <csd_> ok thanks
18:41:41 <Zemyla> You know, I kind of want newtype MEndo m a = MEndo { runMEndo :: a -> m a } to be a Monoid for Monad m.
18:42:10 <Zemyla> :t (>=>)
18:42:10 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:43:10 <blackdog> hey, was wondering: is there a good on-disk key-value store library? sqlite feels like overkill, and berkeleydb has a rather forbidding interface.
18:43:21 <Zemyla> mempty = MEndo return, and mappend (MEndo f) (MEndo g) = f >=> g.
18:43:26 <orzo> i need to encode a bignum in plain big-endian format of a specified length.  Anybody know where i can import that?
18:46:38 <enthropy> @hoogle Kleisli
18:46:40 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
18:46:40 <lambdabot> Control.Arrow newtype Kleisli m a b
18:46:40 <lambdabot> package Kleislify
18:46:50 <fryguybob> blackdog: acid-state?
18:48:21 <enthropy> Zemyla: I guess Kleisli doesn't help, but you could also use   mendo f = Endo (f =<<)
18:51:37 <Zemyla> :t \f -> Endo (f =<<)
18:51:38 <lambdabot> Monad m => (a -> m a) -> Endo (m a)
18:52:24 <enthropy> Zemyla: to me it doesn't seem you get any benefit from a newtype MEndo over   type MEndo m a = Endo (m a)
18:58:46 <Zemyla> enthropy: Basically, it means the smarts are in the newtype itself.
19:04:06 <KaneTW> blackdog: acid-state is definitely the way to go
19:04:18 <KaneTW> otherwise, redis
19:04:49 <csd_> With the following snippet of code, Haskell tells me that there is no constructor 'IO' -- why am I getting this error? Snippet: FoldM IO (do; x <- (ls "."); liftIO (print x)) (Foldl.generalize (pure ()))
19:05:26 <csd_> I'm trying to expand the following definition: newtype Shell a = Shell { foldIO :: forall r . FoldM IO a r -> IO r }
19:05:56 <KaneTW> IO is a type of kind * -> *, not a constructor/function
19:06:19 <csd_> KaneTW: why is it valid in the newtype but not in my expansion of it?
19:06:40 <KaneTW> it's in a type declaration
19:06:41 <Hijiri> in the newtype it's referring to the type constructor
19:06:48 <KaneTW> forall r etc is a type
19:06:54 <Hijiri> if you try to use it on the value level you are trying to use it as a constructor/function
19:07:02 <solatis> anyone has any idea why the Network.Socket.ByteString.Lazy receive functions are unix-only?
19:07:18 <csd_> I see, so am I unable to go any further expanding the statement then?
19:07:53 <carter_cloud> blackdog: for mostly read stuff bgamari has a neat thing.
19:08:11 <Hijiri> trying to expand the type definition?
19:08:48 <csd_> Hijiri: I'm using the Turtle library, and am tracing how the command 'view $ ls "."' executes.
19:08:57 <csd_> Most of the work is done using this newtype Shell
19:09:19 <Rotaerk> turtle turtle!
19:09:27 <Hijiri> view $ ls "." gives you Shell a?
19:09:30 <Rotaerk> am I not turtly enough for the turtle club?
19:09:52 <blackdog> carter_cloud: what's bgamari's thing called?
19:09:54 <Hijiri> The type just means it contains something of type forall r. FoldM IO a r -> IO r
19:09:59 <gauthier> in emacs, is there a way to display the type of selected region or at cursor at any time?
19:10:00 <csd_> ls "." gives a Shell a
19:10:10 <blackdog> KaneTW: eh, redis is heavier than sqlite - i want something i can bind into the app.
19:10:10 <csd_> view $ ls "." is IO ()
19:10:22 <EvanR> blackdog: acid state
19:10:30 <carter_cloud> blackdog: lmdb might be solid
19:10:34 <blackdog> EvanR: ok, i'll give it a go.
19:10:39 <Hijiri> let me see the source of ls
19:10:57 <csd_> Hijiri: https://github.com/Gabriel439/Haskell-Turtle-Library/blob/master/src/Turtle/Prelude.hs
19:11:09 <csd_> Shell is defined in https://github.com/Gabriel439/Haskell-Turtle-Library/blob/master/src/Turtle/Shell.hs
19:11:14 <carter_cloud> Nah,  acids state isnt meant for disk backed  mutable kV store
19:12:10 <blackdog> my motivation here isn't persistence per se - there are distinct build and read phases
19:12:33 <blackdog> it's more that i want something that can access a big dataset without drawing it into memory
19:12:39 <blackdog> it's about 7gb in memory at the moment
19:13:36 <Hijiri> csd_: where are you getting FoldM IO from?
19:13:40 <jmcarthur> blackdog: then acid-state is *not* what you want
19:13:52 <blackdog> jmcarthur: cheers :)
19:14:06 <bgamari> blackdog, b-tree maybe?
19:14:13 <csd_> Hijiri: see the definition of Shell in the second link
19:14:26 <bgamari> blackdog, it could use more tests though
19:14:27 <Hijiri> csd_: :: is not definition, it's type annotation
19:14:33 <jmcarthur> blackdog: acid-state is just a transaction log with the occasional state snapshot, but the entire state is in memory
19:15:00 <Hijiri> FoldM IO a r -> IO r is not the definition of foldIO s, it's the type of foldIO s
19:15:07 <Hijiri> so you should expand that out
19:15:21 <csd_> Hijiri: I'm sorry I don't understand. My interpretation is that a Shell takes a FoldM and returns an IO action
19:15:43 <csd_> is not foldIO the accessor of Shell though?
19:15:49 <cjenkin2> geekosaur, http://lpaste.net/120531
19:15:52 <cjenkin2> So far so good :)
19:15:54 <Hijiri> csd_: It is
19:16:17 <Hijiri> foldIO is of type Shell a -> (forall r. FoldM IO a r -> IO r)
19:16:35 <Hijiri> FoldM IO however is not in the definition of any functions
19:17:00 <Hijiri> foldIO s gives you the underlying function defining s
19:17:08 <Hijiri> so what you would want to do is expand out the definition of ls "."
19:17:23 <Hijiri> If you wanted to expand out 'foldIO s"
19:18:29 <csd_> Hijiri: I'm very confused now... so how does the FoldM get used?
19:18:46 <Hijiri> FoldM is a type constructor, it's used on the type level
19:19:09 <csd_> and how is that type annotation not saying that Shella is equivalent to FoldM ...
19:19:10 <Hijiri> FoldM IO a r -> IO r says you need to give a Shell something of type FoldM IO a r, and it will give you an IO r
19:19:32 <Hijiri> csd_: It's a type, not a value
19:19:40 <csd_> I'm guessing that part of my confusion is me not having seen a function in a type definition like this before
19:19:41 <Hijiri> why would you expand a value into a type?
19:19:50 <Hijiri> it's not a function
19:19:59 <Hijiri> It is the type of a function
19:20:03 <EvanR> :t ord
19:20:04 <lambdabot> Char -> Int
19:20:13 <EvanR> a function type
19:20:14 <Hijiri> if the forall is throwing you off, it just means it has to work for any r
19:20:21 <csd_> Hijiri: Do you know of any web resources that address this?
19:20:28 <Hijiri> function types?
19:20:31 <csd_> and/or what I should search for?
19:20:45 <Hijiri> csd_: function types?
19:21:00 <Hijiri> the forall?
19:21:52 <csd_> I think my confusion is not having encountered a newtype wrapping a function
19:22:08 <csd_> type of a function
19:22:28 <Hijiri> csd_: what learning resources have you used?
19:22:41 <csd_> LYAH and part of RWH
19:22:53 <Hijiri> I'm pretty sure lyah covers function types
19:22:59 <csd_> mostly the chapter on monad transformers
19:23:08 <Hijiri> although I would recommend https://github.com/bitemyapp/learnhaskell over lyah
19:23:21 <Hijiri> A wrapper around a function is like a wrapper around anything else
19:24:18 <Hijiri> (->) is a type constructor, eg (->) a b is the type of functions from a to b
19:24:30 <Hijiri> it is usually written infix, like you usually see (a -> b)
19:24:52 <Hijiri> -> is right associative, ie a -> b -> c -> d ~ a -> (b -> (c -> d))
19:25:43 <Hijiri> :t [id, (+1), (50*)]
19:25:44 <lambdabot> Num a => [a -> a]
19:26:03 <Hijiri> you can put this type as a parameter to other type constructors like you would any other type
19:26:13 <csd_> Hijiri: so as I understand it now, the FoldM is actually supplied by (Foldl.generalize (pure ())
19:26:20 <Hijiri> yep
19:27:50 <Hijiri> foldIO s just brings out the underlying function in Shell, and to find that you would have to expand out ls "."
19:28:19 <Hijiri> (FoldM in this case is both a value-level constructor and a type constructor)
19:28:36 <Hijiri> actually more accurately they just have the same name
19:28:58 <xckv> hmm classes can be instances of other classes?
19:29:11 <Hijiri> classes can't be instances
19:29:19 <Hijiri> actually
19:29:21 <Hijiri> maybe
19:29:22 <xckv> http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Category.html#t:Category
19:29:27 <xckv> look at instances for Category
19:29:51 <Hijiri> which one is the class?
19:30:12 <csd_> Hijiri: is there a particular link in the github page you linked me that you'd recommend? There's a lot of different content there.
19:30:25 <xckv> Hijiri: oh right -_- im losing my mind
19:30:31 <Hijiri> csd_: recommend for what?
19:31:02 <csd_> I suppose getting better with types and such, so that I understand cases like this more easily
19:31:39 <csd_> I want to get better at reading libraries, and I think the types I come across tend to seem really complicated to me
19:31:44 <Hijiri> csd_: are you comfortable with how type constructors, typeclasses, etc work?
19:31:55 <csd_> in principal, yes
19:32:06 <enthropy> Zemyla: right but unless you're looking to write/use instance Applicative m => Applicative (MEndo m) [which doesn't seem to be possible, but maybe there's some other class where MEndo has an instance], you'll get the same results by just defining mendo and appMEndo in terms of Endo and appEndo
19:32:21 <Hijiri> csd_: This goes over what the forall is about: https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
19:32:24 <csd_> in practice is a different matter
19:32:27 <Hijiri> it's not in the github though
19:32:46 <Hijiri> I linked the github page because the learning materials it lists are more thorough than lyah
19:33:11 <Hijiri> CIS 194 in particular has lots of exercises
19:34:46 <csd_> ok thanks for the help
19:40:07 <solatis> i need a second opinion on this, if this makes sense
19:40:31 <solatis> i need to parse communication with a socket, specifically a lot of request / reply actions
19:40:43 <solatis> like negotiate protocol version, set variables, etc
19:41:16 <solatis> i'm considering parsing the protocol by taking a socket as a Lazy ByteString, and then use attoparsec's lazy functions to parse the protocol
19:41:28 <EvanR> attoparsec, a stateful socket handler..
19:41:49 <EvanR> i wouldnt use lazy IO, but incremental parsing makes sense
19:42:16 <solatis> lazy IO is evil because of things going wrong at weird places, right?
19:42:46 <solatis> are there any libraries that can assist me with the consuming data of the socket so i don't need to keep the state myself ?
19:43:08 <ttt_fff> is there a nice tool for storing snipplets of haskell code that works better than ~/snipplets/*.hs ?
19:43:13 <EvanR> theres iteratees
19:43:21 <ttt_fff> often times, I spend 10-20 minutes firuing out how to do smoething
19:43:22 <EvanR> but people have been talking about pipes a lot
19:43:29 <ttt_fff> than I'd like to record it, instead of having to re-invent it the next time
19:44:26 <solatis> ok
19:44:58 <solatis> so i should look into pipes or conduit
19:45:38 <EvanR> id first try it with just a looping thread and attoparsec
19:50:44 <betaveros> does anybody know if I can get cabal to install documentation for everything, including base, into a sandbox?
19:51:11 <geekosaur> base you certainly can't
19:51:22 <betaveros> :(
19:51:53 <geekosaur> (cabal wants to build the package to generate documentation, and base can only be built as part of ghc)
19:54:12 <betaveros> ok, can I tell cabal to install its documentation for some packages next to the base docs that came with GHC? I’m using https://ghcformacosx.github.io/ now after talking to IRC yesterday and it might have reduced my cabal conflicts but now lots of documentation links are all broken
19:54:15 <michaelt> solatis: a socket can be made a bytestring producer thus in pipes: http://hackage.haskell.org/package/pipes-network-0.6.4/docs/Pipes-Network-TCP.html#v:fromSocket  You would then use pipes-attoparsec to apply your parser to it
19:54:57 <solatis> michaelt, i am already using ResourceT a lot in my code -- perhaps that's an argument to use conduit rather than pipes?
19:55:16 <solatis> (since there's also a conduit-attoparsec)
19:56:41 <michaelt> Oh I see, I didn't notice you were already using resourcet.  In principle it shouldnt matter, but I suppose it will be simpler
20:06:53 <xckv> :t (.)
20:06:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:06:58 <xckv> :t (>>>)
20:06:59 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
20:07:28 <michaelt> :t (<<<)
20:07:29 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
20:07:40 <xckv> ah
20:08:22 <michaelt> people use >>> often when reversed composition is more intuitive.
20:09:27 <xckv> yea i see, im reading an article on arrows and it only mentions >>> so i found it kind of wierd
20:11:26 <michaelt> yes, in arrow-land, the >>> direction of composition is preferred, I guess because you are thinking of the arrows as actions that happen in order, so to speak
20:16:53 <eyebloom> Do anyone else find that type families lead to tons of ambiguity errors?
20:17:53 <eyebloom> I’m getting an error:     Expected type: Layout s RawShape
20:17:54 <eyebloom>                    -> Mo (Layout s RawShape) (L (Layout s RawShape))
20:17:55 <eyebloom>       Actual type: Layout s RawShape
20:17:55 <eyebloom>                    -> Mo (Layout s RawShape) (L (Layout s RawShape))
20:18:41 <eyebloom> They are exactly the same it’s just that somehow the compiler can’t resolve Mo which is a type family applied to (Layout…)
20:18:48 <geekosaur> the last time I saw an error like that, it was xmonad vs. xmonad-contrib mismatch
20:19:57 <geekosaur> xmonad-contrib had been built against an xmonad that was no longer installed, so ghc couldn't do its usual fully-qualify thing on the Layout referenced by xmonad-contrib, which was not matching with the installed Layout type
20:20:20 <eyebloom> This is my own Layout type.
20:21:06 <geekosaur> yes, I figured that wasn't xmonad since you're definitely headed for an explosion there (actually there is no Layout type, there is a LayoutClass and that was what was exploding)
20:21:17 <eyebloom> I think mainly  the issue here is that the actual error is not in the place that the compiler finds the error, it’s an upstream ambiguity.
20:21:22 <eyebloom> I’m just venting.
20:21:51 <geekosaur> but I still feel like it is picking up something from an older build that is confusing it
20:22:24 <geekosaur> that, or you've managed to find a corner case in ghc's error messages (that's happened before)
20:22:40 <eyebloom> Yeah, I’ve had this problem often in this current project. Usually I can track it down by putting in a lot of type signatures
20:22:46 <michaelt> if 's' were specialized would the compiler know what to do?
20:22:56 <eyebloom> Possibly
20:23:11 <geekosaur> I don't think so? normally when it has that kind of confusion it'll rename one of them to s0 or something
20:23:18 <eyebloom> Unfortunately, s is specialized outside of the module.
20:23:36 <geekosaur> that should not matter because it'll be in the .hi file
20:23:50 <eyebloom> But I think that is basically the issue.
20:23:56 <geekosaur> (that's one of the reasons ghc has .hi files)
20:25:10 <eyebloom> Mainly I just feel that any time you declare something in haskell that is not injective, you are in for trouble down the line.
20:28:29 <eyebloom> Not to get all negative :)
20:35:05 <t4nk145> hi everyone, i was here earlyer asking for help with cabal. i have finished my project if anyone would like to see it, and maybe even do me the satisfaction of pulling it and checking it runs.... its a pretty cool little application and the first easy example of haskell communicating with javascript through node.js https://github.com/pdesolver/Socket.io.simpleExample
20:35:41 <t4nk145> any feedback would be great
20:36:50 <t4nk145> anyone around?
20:37:23 <t4nk145> helooooooooooooooooo
20:38:38 * unknownloner leaves
20:38:58 <t4nk145> https://github.com/pdesolver/Socket.io.simpleExample
20:39:31 <t4nk145> would be great to get some feedback...
20:40:06 <unknownloner> well umm
20:40:10 <unknownloner> it looks like haskell code
20:40:11 <unknownloner> I guess
20:40:20 <t4nk145> lol, run it
20:40:27 <unknownloner> would if I was at home
20:40:42 <unknownloner> im out right now though
20:40:52 <t4nk145> in da club on #haskell
20:40:59 <unknownloner> aww yeah
20:41:03 <t4nk145> lol
20:41:09 <unknownloner> haha
20:41:17 <unknownloner> I'll test it when I get the chance though
20:41:18 <t4nk145> seriously what r u doing here!?
20:41:30 <unknownloner> chillin
20:41:37 <t4nk145> thanks for the offer
20:41:50 <unknownloner> I'm at a friend's place right now
20:42:00 <t4nk145> it lets haskell talk to a html page it is serving and read and write data to and from it
20:42:19 <unknownloner> nice
20:42:31 <t4nk145> if u r in london we should have a #haskell party
20:43:04 <Buttons840> t4nk145: you don't have a cabal config
20:43:10 <t4nk145> i do not
20:43:16 <unknownloner> I'm a ways off from there haha
20:43:24 <unknownloner> try across on ocean
20:43:27 <unknownloner> an*
20:43:36 <t4nk145> oh you crazy yanks
20:43:41 <Buttons840> t4nk145: I would be more willing to try it if I could just git clone, cabal install, cabal run
20:43:55 <t4nk145> ok buttons, challange accepted
20:44:14 <t4nk145> i wanted to provide it without tho, for super noobs
20:44:32 <t4nk145> it actually just works fine in ghci...
20:44:36 <Buttons840> for noobs who don't know what it is, it's just a text file
20:44:41 <Buttons840> it doesn't get in the way or anything
20:44:58 <t4nk145> kk
20:45:13 <Buttons840> cabal config is just a text file I mean -- it can't make things any harder
20:45:38 <t4nk145> the previous example built using cabal run, it was confusing how to access datafiles as you have to use Path_module
20:47:33 <SrPx> Hey guys, sorry, I've missed the whole debate those days... could someone tldr?
20:47:46 <SrPx> no need for details
20:48:02 * hackagebot paypal-adaptive-hoops 0.8.0.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.8.0.0 (fanjam)
20:49:24 <narendraj9> How do I ask lambdabot to list all the commands?
20:50:50 <lucs>  /msg lambdahands @help
20:51:00 <lucs> Um, lambdabot
20:51:55 * shapr hops
20:52:03 <lambdahands> Hehe wrong lambda-thing. :P
20:52:08 <lucs> :)
20:53:47 <t4nk145> how do i enter e.g. Data.Text dependancy in build-dependancies section of a cabal file?
20:55:21 <Cale> t4nk145: You put in the package name, so "text" in that case (without the quotes). You can also put in a version constraint, like text >= 1.2
20:56:17 <t4nk145> thanks Cale:
20:56:20 <Cale> If you go to any package on Hackage, and scroll to the bottom of the page, there's a "Package description" link which you can look at for examples of the syntax of .cabal files
20:56:21 <t4nk145> https://github.com/pdesolver/Socket.io.simpleExample/tree/master
20:56:48 <t4nk145> i have writen a cabal file for my project so now buttons can run it!
20:57:16 <t4nk145> Buttons840 i have added a cabal file
20:57:34 <t4nk145> Buttons840: i have added a cabal file
20:58:42 <t4nk145> Cale: do you like the project i linked? i just finished it
21:06:12 <sclv> hey everyone! new homepage finally live! http://www.reddit.com/r/haskell/comments/2vy1lw/new_haskell_homepage_is_live/
21:06:15 <ttt_fff> i'm using syntastic + ghc-mod in vim. is there a nice trick where I can put cursor over a type, and have it show all constructors of the type? (or jump me to the file where the type is defined) ?
21:06:20 <ttt_fff> I have haskelmode + syntastic + ghc-mod
21:06:28 <ttt_fff> and I'm willing to install anything else necessary to make this happen
21:07:00 <Xe> use a split in tmux and haddock
21:07:50 <Zemyla> Okay, why is it that there is a function to set the value of a specific index in an SIMD tuple to a certain value, but there is no function to get the value at a certain index from an SIMD tuple?
21:09:13 <benzrf> what is a simd tuple
21:10:47 <benzrf> ttt_fff: you could use tags
21:11:02 <Zemyla> benzrf: They're defined in GHC.Prim.
21:11:18 <ttt_fff> hmm
21:11:21 <ttt_fff> what port does hdevtools use?
21:11:24 <ttt_fff> i'm going ot use hdevtools
21:11:30 <ttt_fff> but the vim plugin says "hdevtools: port already in use"
21:12:45 <xckv> what is the '~' in '~(x,y)'
21:12:56 <t4nk145> nice webpage
21:13:10 <t4nk145> its a tilde
21:13:24 <Zemyla> xckv: It means pattern-match lazily.
21:13:43 <xckv> oh man i have no idea what that means
21:13:53 <xckv> what is a lazy pattern match
21:14:17 <ReinH> xckv: it's an "irrefutable pattern match"
21:14:27 <EvanR> the pattern will always match because the check will be deferred until you need the contents, at which point it may crash your program
21:14:27 <benzrf> xckv: basically it doesnt bother to actually check if it matches
21:14:32 <benzrf> until you use one of hte values
21:15:00 <EvanR> teh values*
21:15:06 <benzrf> lol
21:15:44 <xckv> i think i need to read something to understand how this works and why its useful
21:17:53 <narendraj9> Are "as patterns" lazy pattern matches?
21:19:27 <reem_> Are there docs about Haskell's GC?
21:20:19 <reem_> Is there a #haskell-internals or similar kind of channel?
21:20:48 <michaelt> > let go ys@(x:xs) = reverse xs ++ tail ys in go (undefined:"hello")
21:20:50 <lambdabot>  "ollehhello"
21:20:58 <michaelt> seems kinda lazy narendraj9
21:21:19 <xckv> is hoogle down? getting 403
21:21:26 <EvanR> > let go = ys@(x:xs) = [] in go
21:21:27 <lambdabot>  <hint>:1:20: parse error on input ‘=’
21:21:37 <EvanR> > let go ys@(x:xs) = [] in go
21:21:39 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t1)
21:21:39 <lambdabot>    arising from a use of ‘M269736874416157668824262.show_M2697368744161576688...
21:21:39 <lambdabot>  The type variable ‘t1’ is ambiguous
21:21:48 <michaelt> ?
21:21:49 <EvanR> fawk
21:22:22 <EvanR> > let go ys@(x:xs) = reverse xs ++ tail ys in go []
21:22:23 <lambdabot>  *Exception: <interactive>:3:5-40: Non-exhaustive patterns in function go
21:22:53 <narendraj9> It's because of the tail function.
21:24:33 <narendraj9> > let go ys@(x:xs) = [1..5] in go []
21:24:35 <lambdabot>  *Exception: <interactive>:3:5-25: Non-exhaustive patterns in function go
21:24:49 <narendraj9> > let go ys@(x:xs) = [1..5] in go [1]
21:24:50 <lambdabot>  [1,2,3,4,5]
21:25:00 <EvanR> its not like ~
21:25:37 <narendraj9> What does ~ do? Sorry. I don't know.
21:25:53 <EvanR> > let go ~(x:xs) = [1..5] in go []
21:25:54 <lambdabot>  [1,2,3,4,5]
21:26:08 <narendraj9> But as pattern don't look lazy. Oh. What are these called?
21:26:17 <EvanR> lazy pattern matches
21:26:34 <narendraj9> Okay.
21:26:47 <nshepperd> lazy and/or irrefutable
21:27:08 <EvanR> isnt irrefutable a broader class of patterns
21:28:36 <nshepperd> 'foo ~(Pattern) = bar' is equivalent to 'foo x = let Pattern = x in bar' i think
21:29:09 <narendraj9> > let _ = 12 in 23;
21:29:10 <lambdabot>  <hint>:1:17: parse error on input ‘;’
21:30:38 <narendraj9> _ is irrefutable but would it be called a lazy pattern?
21:30:51 <relrod> xckv: yes, thanks, looking
21:31:34 <EvanR> i guess all irrefutable patterns are lazy
21:31:38 <narendraj9> Infact any variable would be a irrefutable pattern I guess. But I wonder what _ is.
21:31:44 <EvanR> same thing
21:31:52 <EvanR> _ is just like a variable you dont use
21:32:04 <narendraj9> It doesn't introduce any bindings.
21:32:17 <EvanR> if it did and you didnt use the binding, wouldnt make a diff
21:33:16 <narendraj9> Right. So it's better if the compiler shouts at me when I use it as a variable. Okay.
21:33:35 <nshepperd> > let _ = 12 in _
21:33:37 <lambdabot>  Found hole ‘_’ with type: t
21:33:37 <lambdabot>  Where: ‘t’ is a rigid type variable bound by
21:33:37 <lambdabot>             the inferred type of it :: t at Top level
21:33:37 <narendraj9> Identifiers don't start with _ anyway.
21:33:58 <Rotaerk> > let _ = _ in +
21:34:00 <lambdabot>  <hint>:1:14: parse error on input ‘+’
21:34:01 <Rotaerk> > let _ = _ in _
21:34:03 <lambdabot>  Found hole ‘_’ with type: t0
21:34:03 <lambdabot>  Where: ‘t0’ is an ambiguous type variableFound hole ‘_’ with type: t
21:34:03 <lambdabot>  Where: ‘t’ is a rigid type variable bound by
21:34:33 <narendraj9> > let _something = 12 in _something
21:34:34 <lambdabot>  12
21:34:38 <nshepperd> well, you *can* start identifiers with _
21:34:46 <narendraj9> Oh. They can start with a _.
21:35:32 <narendraj9> > let _ = 12 in (_ + 12)
21:35:34 <lambdabot>  Found hole ‘_’ with type: a
21:35:34 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
21:35:34 <lambdabot>             the inferred type of it :: a at Top level
21:35:35 <michaelt> But when all else fails the type-holes checker frequently kicks in
21:35:36 <nshepperd> but I guess it's nice not to, because identifiers starting with _ are also holes
21:36:12 <nshepperd> and also you can't use _ itself as an identifier
21:37:10 <heatsink> Is there a name for the type (a, a -> b)?
21:37:44 <Rotaerk> it's called (a, a -> b)
21:37:47 <shachaf> Where do a and b come from?
21:37:49 <benzrf> Rotaerk: :)
21:38:03 * hackagebot hjsonschema 0.3.0.0 - Haskell implementation of JSON Schema v4.  http://hackage.haskell.org/package/hjsonschema-0.3.0.0 (seagreen)
21:38:56 <michaelt> heatsink: Store
21:40:00 <heatsink> a and b are parameters.  It's part of a pattern b -> (a, a -> b) where the 'a' stands for a piece of a 'b' that you can modify and put back
21:40:59 <heatsink> michaelt: as in Control.Comonad.Store?
21:41:48 <michaelt> heatsink: thats what I was thinking; this is the pure version
21:42:31 <nshepperd> if you're talking a getter + setter, you might want to look at Lens instead
21:51:31 <heatsink> michaelt: Yup, that looks like what I've got.  Thanks!
21:54:00 <michaelt> heatsink: ah good.
22:02:07 <benzrf> o never thought of that >.<
22:38:07 <t4nk973> hi guys
22:38:37 <t4nk973> making headway into shaders on clientside
22:38:52 <t4nk973> can anyone take a look at this for me? https://github.com/faylang/fay-server/blob/master/modules/library/Language/Fay/Three.hs
22:39:17 <t4nk973> its the fay binding for three.js it gives access to java shaders
22:39:59 <t4nk973> its really small though, i was wondering if anyone who knew about shaders and stuff could check to see if it exposes sufficient functionality...
22:40:53 <t4nk973> is anyone about?
22:44:47 <t4nk973> wow so dead
22:45:19 <blackdog> t4nk973: i think the americans are asleep :)
22:45:43 <t4nk973> https://github.com/faylang/fay-server/blob/master/modules/library/Language/Fay/Three.hs
22:46:16 <t4nk973> trying to write js using fey where the js is three.js
22:49:16 <jle`> 2/b 6
22:49:18 <jle`> oh sorry
22:58:41 <t4nk973> ...
23:04:11 <nkar> anyone familiar with cmdargs?  'newtype Foo = Foo { arg :: Bool } deriving (Show, Data, Typeable) foo = Foo { arg = False &= help "Arg" &= opt True } &= summary "Foo"' fails with 'System.Console.CmdArgs.Implicit, unexpected mode: FlagOptional "True"'
23:04:11 <nkar>  
23:10:33 <statusbot> Status update: deb.haskell.org has been compromised; dating back to February 12th when suspicious anomalies were detected in outgoing traffic. `deb.haskell.org` was already offline and suspended shortly after these traffic changes were detected by the host monitoring system, meaning the window for package compromise was very very small.  We're continuing to investigate the breach and the extent to which it might have 
23:24:27 <EvanR> whats the easy way to create an arbitrary instance for a enum-like data type
23:25:16 <bitemyapp> EvanR: Arbitrary or arbitrary?
23:25:20 <EvanR> Arbitrary
23:27:08 <bitemyapp> EvanR: easy?
23:27:14 <bitemyapp> EvanR: derive makeArbitrary ''YerType
23:27:23 <bitemyapp> import Data.DeriveTH
23:27:55 <EvanR> ok, will that also work on recursive types
23:31:45 <bitemyapp> EvanR: try it and let me know
23:32:22 <EvanR> haha, i got a conflict between my type Property and quickcheck
23:32:26 <EvanR> so i changed it to Prop
23:32:31 <EvanR> also conflicts
23:34:25 <unknownloner> gotta start making them all l33t
23:34:27 <unknownloner> Pr0p
23:34:33 <unknownloner> Pr0p3rty
23:34:38 <EvanR> good idea
23:35:04 <cmccann> "Prop'ty" is also an option
23:35:32 <unknownloner> Property'''
23:53:44 <lf94> Uuuuhm, what function returns this? (Maybe String -> IO ())
23:53:56 <jle`> lf94: what do you want it to do?
23:53:58 <lf94> Looking at textRequest: http://hackage.haskell.org/package/haste-compiler-0.4.4.1/docs/Haste-Ajax.html
23:54:14 <lf94> Or even the jsonRequest
23:54:15 <lf94> Which is
23:54:22 <lf94> (Maybe JSON -> IO ())
23:54:58 <lf94> Ah yeah, so it is a callback like I expected
23:55:09 <lf94> oh nevermind
23:55:10 <lf94> gah
23:55:18 <lf94> I'm a dumb butt X)
23:55:29 <lf94> jle` I understand now
23:55:44 <jle`> not dumb :)
23:55:53 <lf94> I should've known
23:56:03 <lf94> Looking at the source sparked the understanding
23:59:29 <EvanR> seems like i should be able to do something like Gen a <> Gen a
23:59:36 <EvanR> or <|>
23:59:39 <EvanR> or <+>
