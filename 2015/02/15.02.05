00:08:48 <biglama> hi guys, I have a list of prime numbers and want to find the first prime divisor of a number, like so :
00:09:13 <biglama>  find (\x -> mod n x == 0) $ primes 1000
00:09:33 <biglama> unfortunately, for a large list of prime number the find becomes slow
00:09:42 * hackagebot wai-websockets 3.0.0.4 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-3.0.0.4 (MichaelSnoyman)
00:09:42 * hackagebot mikmod 0.2.0.0 - MikMod bindings  http://hackage.haskell.org/package/mikmod-0.2.0.0 (evanrinehart)
00:10:29 <biglama> I expected lazy evaluation to avoid that i.e the increasing the size of the list should not impact the execution time
00:11:40 <pacak> biglama: Try profiling your code to see what exactly it's doing.
00:12:36 <Hijiri> well if you increase the size of the list you do have to check more numbers
00:13:15 <Arahael> biglama: Lazy evaluation only defers execution, and potentially discards it only if it's never used.
00:13:36 <pacak> And producing more and more prime numbers also takes longer with each extra number.
00:17:29 <biglama> Arahael: yeah but I kept the same number and increased only the list size, so it should not change
00:17:48 <jle`> huh
00:17:52 <biglama> pacak: good idea
00:18:10 <Arahael> biglama: Lazy evaluation isn't memoization.
00:19:47 <biglama> Arahael: can you expand on that ? I don't know what memoization is
00:20:02 <pacak> Arahael: It depends on how this list with prime numbers was defined.
00:20:02 <pacak> fibs = 0 : 1 : zipWith(+) fibs (tail fibs)
00:20:44 <devll> How to get port of current REPL ?
00:21:23 <devll> my bad. I thought this was Clojure.
00:22:01 <Arahael> pacak: I'm too much of a novice to understand. :(
00:22:48 <rlp10> how do i use lens with an ixset? the data in my ixset is indexed by an int (which is a unique id).
00:23:22 <pacak> Arahael: In case of fibs list will be stored on a top level as list of ints with thunk to compute next element at the end so if you use first 10 elements over and over again - they will be computed only once.
00:24:15 <Arahael> pacak: Oh, I see what you meant.
00:24:27 <Arahael> pacak: Except biglama is computing a whole new list.
00:24:36 <nshepperd> increasing the list size definitely shouldn't affect the time taken
00:25:08 <nshepperd> ...unless the number whose factors are being searched for is coprime to everything in the list
00:25:17 <pacak> Arahael: It's hard to know for sure without seeing his code.
00:25:41 <Arahael> Ok.
00:25:50 <nshepperd> such as a prime bigger than any in the list. in that case find has to evaluate the whole list
00:27:53 <biglama> pacak: let me work on the code a bit and I'll send it :)
00:28:49 <jle`> devll: what port do you mean?
00:29:09 <Arahael> Blegh. Debian's haskell-mode is pretty painful for bird style.
00:29:37 * Arahael adds "get a better haskell mode" to his todo list.
00:33:32 <lpaste> biglama pasted “Prime numbers” at http://lpaste.net/120014
00:33:52 <biglama> here's the code, I'm profiling it right now
00:37:01 <EvanR> what is bird style?
00:37:29 <Cale> Using "> " at the beginning of lines to indicate code.
00:37:49 <nshepperd> biglama: 'reverse $ sieve [] [2..n]' is problematic
00:38:30 <biglama> nshepperd: ha yes, the reverse means all the list must be read :(
00:38:39 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
00:38:40 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
00:38:44 <nshepperd> yes
00:38:59 <nshepperd> you're better off working with the unreversed list in some other way
00:39:15 <biglama> should I append to the end of the list ? I heard it was bad performance-wise
00:39:19 <jle`> mutual recursion, fun stuff
00:40:01 <Cale> Yeah, that defines isPrime and primes by mutual recursion, and only does trial division against primes
00:40:43 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in drop 10000 primes
00:40:45 <lambdabot>  [104743,104759,104761,104773,104779,104789,104801,104803,104827,104831,10484...
00:42:27 <biglama> Cale: your first function is ... disturbing
00:42:38 <nshepperd> biglama: hmm, that might not actually be the biggest problem
00:42:52 <Cale> biglama: Which function? isPrime? Or you mean the list primes?
00:43:24 <biglama> Cale: the list of prime numbers
00:43:36 <Cale> biglama: Yeah, it's a list of all the prime numbers
00:43:48 <nshepperd> ah
00:43:56 <biglama> yeah but I'm having trouble with the recursion part ^^
00:44:39 <nshepperd> biglama: try rewriting the sieve to not be tail recursive
00:45:33 <nshepperd> biglama: so, instead of building up a parameter xs which you return at the end, return y : (sieve ...)
00:46:33 <Cale> biglama: The key is just that we give 2 as a prime to start things off -- that's enough to figure out that 3 is prime, and then those get used to figure out that 5 is prime and so on. The takeWhile will only take elements from the list of primes until their square is greater than the number we're testing for primality.
00:47:01 <biglama> nshepperd: yeah, I was wondering why the hell I didn't do that !
00:48:02 <nshepperd> hehe
00:48:07 <biglama> Cale: I got the idea but defining a list by recursion is still not obvious to me :)
00:48:08 <nshepperd> lazy lists are wonderful
00:48:23 <biglama> it was late, I was tired and so on...
00:49:18 <biglama> nshepperd: yes it works ! thanks again
01:23:09 <zipper> How can I add route that looks like this from add-handler `/auth AuthR Auth getAuth` ?
01:23:15 <zipper> Yesod question.
01:24:20 <drewbert> zipper: I'm not sure I understand your question. I just fiddled a bunch with the yesod auth code, so I should be able to help you.  Could you reword it?
01:25:32 <zipper> drewbert: I want to achieve something like this http://www.yesodweb.com/book/authentication-and-authorization#authentication-and-authorization_authenticate_me
01:25:58 <zipper> drewbert: But with the scaffolded site. However I prefer adding handler than editing files all around.
01:26:24 <drewbert> which auth plugin are you using?
01:26:33 <zipper> drewbert: add-handler takes one argument not two so I don't know how I can add a route that includes a sub-site
01:27:46 <zipper> drewbert: None so far. I'm thinking browser ID but I really want to save auth info in a DB. I just want to add a route by adding a handler. or read a blog post on how to do auth in Yesod.
01:27:58 <zipper> drewbert: Since the app will be use in a LAN.
01:28:02 <merijn> Oh, neat :) Facebook is hiring more haskellers
01:28:16 <drewbert> well here's the thing about addHandler -- Yesod.Auth should already be in your cabal file, and the auth plugins already have their own handlers, so if I were you, I would focus on adding the route manually and implementing the instance in Foundation.hs
01:28:18 <merijn> Why are all the big companies hiring when I'm not unemployed? :p
01:28:39 <zipper> drewbert: Maybe I should ask which way to do auth for something that runs in a LAN
01:28:40 <drewbert> merijn: you basically just asked why the economy fluctuates
01:29:55 <zipper> drewbert: I don't want to add stuff manually because I'll screw up. I'm a total n00b.
01:30:04 <drewbert> zipper: I would move away from trying to use add-handler and instead focus on the discussion in http://www.yesodweb.com/book/authentication-and-authorization#authentication-and-authorization_authenticate_me
01:30:05 <zipper> arrgggghhhhhhhhhhhhhhhhh
01:30:05 * zipper out
01:30:23 <sgronblo> I feel like all the Haskell jobs are always for "experts"
01:30:59 <zipper> sgronblo: They are :(
01:31:01 <merijn> sgronblo: The standard chartered stuff posted earlier were explicitly also looking for beginner/intermediate people
01:33:16 <merijn> Also, there's experts and experts, you don't need to be like edwardk or dons to be expert enough :p
01:33:22 <drewbert> zipper: I've been using haskell for two months and yesod for even fewer, if I can do it, you can do it.
01:34:18 <tzaeru> if you say that and then it turns out that someone CAN'T in fact do it, you just suggested that you're smarter/more capable :P
01:34:40 * hackagebot yampa2048 0.1.0.0 - 2048 game clone using Yampa/Gloss  http://hackage.haskell.org/package/yampa2048-0.1.0.0 (ksaveljev)
01:34:55 <drewbert> tzaeru: you're right.  :-( it was a poor choice of encouragement
01:35:27 <tzaeru> drewbert, dat's quite okay. it's a very common sometimes misdirected encouragement.
01:36:31 <sgronblo> Yeah, when I see those Haskell job advertisements I usually imagine the company looking to hire some guy who already wrote a book about Haskell or something.
01:36:47 <tzaeru> that seems to really be same for all IT companies.
01:37:23 <sgronblo> yeah of course many times job ads go overboard
01:37:35 <tzaeru> in my current job there was a huge list of requirements, I was like "loool", sent an email saying that I know none of your requirements, then I got hired.
01:37:38 <tzaeru> yaay \o/
01:37:43 <sgronblo> hehe
01:38:04 <zipper> tzaeru: No imposter syndrome?
01:38:07 <sgronblo> i feel like i havent seen a single entry level haskell job so far, where it would be expected that you would pick up stuff on the job
01:38:09 <tzaeru> ..our technical side is a bit more sensible than the marketing guys who put the job ad up ;)
01:38:17 <tdammers> welp, job ads are usually written by people who are either not good at writing job ads, or by people who have no idea what the business needs, or both
01:38:32 <tzaeru> well, I really very rarely see entry level jobs at all..
01:38:44 <tzaeru> which doesn't mean that there aren't jobs that are suitable for entering the profession
01:38:52 <tdammers> sgronblo: I have seen job ads where they are fine with teaching you Haskell, but they expect you to have a lot of programming experience in something else already
01:39:00 <sgronblo> well at least the facebook one mentioned that there could eventually be openings for less proficient haskellers
01:39:01 <tzaeru> but you have to guess which they are and just go for it with a bit of exaggeration of your current skills :D
01:39:03 <drewbert> 0.o you mean people actually pay people to write haskell?
01:39:06 <merijn> sgronblo: Well, in case of facebook they're training internal people for haskell
01:39:19 <drewbert> I thought the only FP jobs were at jane street writing ocaml.
01:39:31 <merijn> sgronblo: They're hiring skilled people to architect the high level important stuff and teaching others to do the beginner stuff
01:39:45 <merijn> drewbert: Standard Chartered has been hiring haskellers pretty much constantly the past few years
01:39:51 <tzaeru> zipper, well no, the requirements were like actionscript and flare3d and other stuff that I hadn't even heard of :P
01:39:54 <liyang> We're currently hiring too. But not entry level as we don't have enough people to hold your hand. :(
01:40:00 <merijn> drewbert: There's more banks and companies writing haskell
01:40:17 <tzaeru> so I just said that I don't know any of them, but I've been programming 3D stuff and know enough many languages to learn any language (that is not Haskell) in a day.
01:40:18 <merijn> drewbert: It's just that many companies don't talk about it that much
01:40:31 <sgronblo> liyang: are you the guy who just joined the tokyo haskell meetup? :)
01:40:46 <tzaeru> (and by any language I mean imperative & a-bit-like-C. sorry for the choice of words)
01:40:48 <merijn> drewbert: Hell, at IFL2013 I was talking to a few Intel people who were working on their Core optimisation stuff and they didn't even know that other groups within Intel were working with haskell :p
01:40:52 <liyang> sgronblo: I figured I'd pop along and see what's up, yes.
01:41:08 <merijn> tzaeru: I was about to challenge you to learn Prolog or APL in a day :D
01:41:14 <sgronblo> liyang: are you at tsuru or?
01:41:17 <drewbert> liyang: jobs and yesod auth
01:41:20 <tdammers> oh, also "requirements" in job ads are always negotiable. Always.
01:41:26 <tzaeru> merijn, mmh :P
01:41:30 <tdammers> they are not really requirements, they are wish lists
01:41:33 <tzaeru> would take a month full-time!
01:41:38 <ocramz> good mid-morning internets
01:41:45 <tzaeru> tdammers, ayep
01:41:51 <liyang> http://www.tsurucapital.com/en/jobs.html </plug>
01:41:59 <tdammers> if you can fulfill all the wishes, that'd be great, but it hardly ever happens
01:42:18 <tzaeru> "impostor syndrome" is kinda interesting thing otherwise though.
01:42:20 <sgronblo> liyang: we could use someone who changes the situation that im the "expert" in the room
01:42:31 <tdammers> and the real purpose is to tell people what kind of stuff you work with, and whether that would be something you'd be good at
01:42:40 <zipper> drewbert: Well I went into my Foundation.hs and it seems they have already made App and instance of YesodAuth. My job now is to turn it on somehow.
01:42:54 <tzaeru> I *do* occasionally suffer from it and have other issues that lower my perception of my own skills, but I guess it's something that most programmers struggle with now and then.
01:43:05 <tzaeru> it's a very slippery slope to either over-confidence, or under-confidence.
01:43:06 <tdammers> tzaeru: absolutely
01:43:06 <tzaeru> @_@
01:44:18 <drewbert> zipper: add the subsite to your routes like you were planning, add an authplugin to your authplugins in your "instance yesodauth app" and then make your app an instance of the type associate with that plugin
01:44:49 <drewbert> zipper: if any of that is confusing, I can break it down more for you, but I've only really used yesod auth email, so I won't be able to help you with plugin specific stuf
01:44:57 <drewbert> err... stuff*
01:45:23 <mauke> liyang: "... in either Vancouver, Canada or Tokyo"
01:45:26 <tzaeru> I've come to conclude that I'll probably eventually want someone to spend a few hours to actually teach me Haskell, with a more practical take to it :P
01:45:39 <tzaeru> way too unfocused recently to sit down to properly skim through dozens of pages of manuals and tutorials.
01:46:13 <drewbert> tzaeru: it doesn't help that haskell has a giant nomenclature problem either
01:46:25 <tzaeru> yeah
01:46:35 <tzaeru> that's a very problematic thing, particularly for me. @_@
01:46:36 <zipper> drewbert: By yesod auth email you mean?
01:46:40 <liyang> mauke: not Vancouver WA.
01:46:47 <ocramz> liyang: do you by chance work at Tsuru?
01:46:48 <tdammers> comes with pushing the abstraction borders
01:46:49 <zipper> drewbert: It's probably the solution I am after.
01:46:56 <mauke> liyang: it looked like a list of 3 places at first
01:47:28 <drewbert> zipper: Yesod.Auth.Email is an auth plugin for yesod that lets you login via email and password. https://hackage.haskell.org/package/yesod-auth-1.4.1.3/docs/Yesod-Auth-Email.html
01:47:33 <tzaeru> I've actually a diagnosed dyslexia with specific issues in reading comprehension. words swap meanings or characters unusually much et cetera. so learning completely new things is very time-consuming. :/
01:47:34 <zipper> drewbert: Do you mean you saved the passwords and usernames locally?
01:47:38 <tzaeru> even though I'm otherwise rather sharp!
01:47:40 <zipper> drewbert: Okay let me check the link
01:47:52 <zipper> drewbert: Yeah that's the one I want
01:47:58 <drewbert> zipper: There's also a discussion of it in the first link I sent you.
01:48:03 <tzaeru> now when those new things are difficult to fit into existing contexts and terminologies, it's double-so difficult to get started.
01:48:13 <zipper> drewbert: I believe it's the one I want :)
01:48:21 <zipper> drewbert: I'm lucky to have found you.
01:48:34 <liyang> ocramz: still in the office, yes. Been meaning to leave for the last couple of hours… it's coming up to 19:00. :(
01:49:11 <sgronblo> liyang: no zangyo culture there apparently
01:49:46 <liyang> sgronblo: no, I had my Japanese lesson in the office and I'm too lazy to get out of my chair. Now I'm procrastinating on IRC.
01:50:03 <drewbert> zipper: Are you planning to use sendmail or smtp?
01:50:30 <liyang> sgronblo: everyone else left before 17:30.
01:50:31 <jle`> oh wow finally wrapping up the final post to that machines/auto series. can't believe it took me a year
01:50:43 <sgronblo> liyang: my coworkers live in the office
01:50:45 <sgronblo> almost
01:50:49 <tzaeru> :D I like this one symptom of adult dyslexia, "May understand higher math, but can't show it on paper."
01:50:49 <sgronblo> its just wrong
01:50:52 <tzaeru> that's pretty much it.
01:51:03 <tzaeru> too many god damn symbols @_@
01:51:23 <zipper> drewbert: I don't have a mail server. This can't be achieved without a mail server can it?
01:51:25 <liyang> sgronblo: if you're interested, drop by #tsurucapital and ask some questions. (I can't keep track of this channel… :)
01:51:55 <sgronblo> liyang: its not like private for just guys at tsuru?
01:52:40 <liyang> sgronblo: no we use Slack. That channel's public.
01:52:57 <sgronblo> right
01:53:27 <drewbert> zipper: With yesod.auth.email, you enter an email, you are emailed a link, you click the link and choose a password.
01:54:53 <drewbert> zipper: snoyman really tiptoed around all the normal login methods, though the code is tinkerable into a normal user flow
01:57:22 <drewbert> zipper: you said this would be on a local network, right?  Are there untrusted users on your local network?  How secure does this application need to be?
02:00:26 <ocramz> liyang: so I guess your job posting was more of a call for reinforcements :D
02:01:26 <tomphreek> :t fmap
02:01:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:06:08 <drewbert> tempting job posting is tempting
02:06:19 <tomphreek> better way to write myRW = (+) <$> u1 <*> (sqrt <$> u2) ?
02:07:01 <tomphreek> u1 = stdUniform :: RVar Double
02:37:42 <randomclown> I have a System.IO.Handle, I want to read until I encounter CR LF
02:38:03 <randomclown> How do I do this with bytestrings, B.hGetLine stops at LF
02:38:50 <sgronblo> http://youtu.be/IobLWVuD-CQ?t=52m45s Is this a good example of use of a Monad? It seems like the output value didn't depend on the value of the previous computation of input?
02:40:08 <sgronblo> The feature of having the whole "computation fail" is included in Applicative as well, right?
02:41:23 <Cale> randomclown: Normally the text I/O stuff will translate CR LF to LF for you
02:41:33 <randomclown> Cale: yeah but this isn't text
02:41:37 <sgronblo> looks like: (\i o -> pipe i `into` o) <$> managed (FileInput "in") <*> managed (FileInput "out") in Haskellish terms to me?
02:42:46 <Cale> randomclown: You could use breakSubstring
02:43:21 <Cale> oh, you want to stop reading at that point
02:43:24 <Cale> okay, hmm
02:43:27 <buckmaster> anyone here experienced with persistent? trying to wrestle with type signatures -_-
02:43:55 <Cale> randomclown: It's a bit tricky, unless you want to read one character at a time.
02:46:44 <randomclown> Cale: I ended up just checking the end of the string and calling getLine again
02:46:54 <sgronblo> Did any pros check that youtube link yet? I'd love to have my suspicions confirmed or rejected.
02:47:07 <sgronblo> It's just a single slide
02:51:51 <lyxia> sgronblo: It's fine to bind values that don't depend on each other in any case.
02:52:15 <sgronblo> lyxia: Of course there is nothing wrong with it. I'm just saying it's not a good example of Monads?
02:52:41 <sgronblo> By saying, here's what Monad usage looks like, when the example could have used Applicative just as well?
03:02:45 <sgronblo> Seems like I bored the whole channel to sleep
03:04:36 <lyxia> sgronblo: It's true that binding then applying can be done equivalently with just Applicative, and since that's what the slide before it was about I agree that it looks like a non-optimal example.
03:05:24 <sgronblo> lyxia: Thanks for confirming
03:05:43 <sgronblo> It seems the presenter confused Monad with computation that fails if part of it fails
03:07:00 <rhaps0dy> so uh
03:07:10 <rhaps0dy> > Just 3 >>= (\c -> Just c)
03:07:11 <lambdabot>  Just 3
03:07:16 <rhaps0dy> > [3] >>= (\c -> Just c)
03:07:17 <lambdabot>  Couldn't match type ‘Data.Maybe.Maybe’ with ‘[]’
03:07:17 <lambdabot>  Expected type: [b]
03:07:17 <lambdabot>    Actual type: Data.Maybe.Maybe b
03:07:22 <rhaps0dy> What's going on here?
03:07:32 <sgronblo> rhaps0dy: >>= has to return something in the same monad
03:07:42 <rhaps0dy> Oh.
03:07:52 <rhaps0dy> > Just 3 >>= (\c -> [c])
03:07:53 <lambdabot>  Couldn't match type ‘[]’ with ‘Data.Maybe.Maybe’
03:07:53 <lambdabot>  Expected type: Data.Maybe.Maybe b
03:07:53 <lambdabot>    Actual type: [b]
03:07:58 <rhaps0dy> not cool?
03:08:03 <sgronblo> No
03:08:05 <rhaps0dy> > [3] >>= (\c -> [c])
03:08:07 <lambdabot>  [3]
03:08:08 <rhaps0dy> yay
03:08:10 <rhaps0dy> thanks
03:08:26 <sgronblo> @type >>=
03:08:28 <lambdabot> parse error on input ‘>>=’
03:08:34 <sgronblo> @type (>>=)
03:08:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:08:43 <rhaps0dy> yeah, it's the same monad m.
03:08:44 <sgronblo> The ms have to be the same
03:08:47 <rhaps0dy> I had overlooked that, thank you :)
03:09:13 <sgronblo> No problem. Happy to have reached the level that I can easily answer these types of questions ;)
03:11:45 <rhaps0dy> Haha
03:11:52 <rhaps0dy> struggle worth something eh
03:12:13 <rhaps0dy> I hope to do that as soon as possible :)
03:19:57 <rhaps0dy> well, goodbye! have fun!
03:20:55 <sgronblo> bye bye
03:44:47 * hackagebot bcrypt 0.0.6 - Haskell bindings to the bcrypt password hash  http://hackage.haskell.org/package/bcrypt-0.0.6 (AndrewMiller)
03:44:49 * hackagebot friday 0.2.0.2 - A functional image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.2.0.2 (RaphaelJavaux)
03:56:16 <zipper> Hey how can I get an email address from maybeAuthId when doing yesod authentication? My isAdmin function is here http://lpaste.net/8939397724185296896
03:59:29 <juhp> anyone have a patch to make type-level compile with ghc-7.8?
04:03:19 <lpaste> juhp pasted “type-level errors with ghc-7.8” at http://lpaste.net/120020
04:03:32 <juhp> that ^
04:47:07 <clrnd> shelly is great
04:50:31 <danilo2_> Hello! I've got a basic haskell question - does haskell support syntax for partial array matching, something like "let [a,b,c,...] = [1,2,3,4,5,6]" ? I want to mach the first 3 elements of the list
04:50:52 <merijn> danilo2_: Not with that syntax, but you can do
04:50:53 <Iceland_jack> danilo2_: you can do 'let a:b:c:_ = [1..6]'
04:50:58 <rasen> > let a:b:c:_ = [1,2,3,4,5,6] in (a,b,c)
04:51:00 <lambdabot>  (1,2,3)
04:51:12 <merijn> > let (a:b:c:d) = [1..6] in (a, b, c)
04:51:14 <danilo2_> merijn, Iceland_jack: oh, of course
04:51:14 <lambdabot>  (1,2,3)
04:51:47 <danilo2_> merijn, Iceland_jack: heh, I was just curious if there is alternative syntactic sugar :)
04:51:52 <danilo2_> merijn, Iceland_jack: thank you! :)
04:54:54 <mniip> danilo2_, also that's not an array
04:55:05 <mniip> yeah I am that guy
04:55:22 <danilo2_> mniip: Of course :) Sorry for using missleading words :)
04:55:35 <Iceland_jack> Pirates prefer arrays
04:55:43 <Iceland_jack> Maybe danilo2_ is a pirate
04:56:53 <danilo2_> Iceland_jack: I would love to be pirate but unfortunately that was just a blunder (if that's correct english word for usign wrong word) :D
04:56:57 <mniip> they do but
04:56:57 <merijn> mniip: It could be an array!
04:57:01 <mniip> [1,2,3,4,5,6] isn't one
04:57:06 <merijn> mniip: Now that we have OverloadedLists :p
04:57:13 <mniip> aw screw you
04:57:22 <clrnd> I always laugh how they show like 'fromList [1,2,3]'
04:57:46 <Iceland_jack> In the case of OverloadedLists our answers were wrong
04:58:06 <clrnd> what about OverloadedStrings, how would that be?
04:58:16 <clrnd> s/Strings/Lists/
04:58:29 * clrnd has great muscle memory
04:59:23 <Petoro> hello
05:01:21 <rasen> Petoro: hi!
05:02:11 <hank_scorpion> hey is this a place I can find programmers?
05:02:37 <hank_scorpion> like, can I meet people to hire here to work from home and stuff?
05:02:45 <speak> hank_scorpion I loved you in Simpsons
05:02:47 <Cale> hank_scorpion: Haskell programmers, perhaps
05:03:19 <hank_scorpion> haha you like my name eh?
05:03:24 <Cale> hank_scorpion: But if it's not Haskell-related, I'm not sure how well-received the solicitation would be.
05:03:41 <clrnd> I'll program anything for a handfull of food
05:03:41 <mniip> try ##programming maybe?
05:03:46 <mniip> same ^
05:03:51 <mniip> :P
05:04:04 <hank_scorpion> well i heard that people from this group were pretty intelligent (not to mention computer savvy), basically want to pick from a good lot
05:04:42 <clrnd> that's kind of like a compliment
05:04:51 <Procian> I refuse to program any evil in Haskell.
05:04:54 <hank_scorpion> when you're applying to make a business
05:05:10 <hank_scorpion> you need to be able to proove that people would work for you if you get approved.
05:05:26 <hank_scorpion> esp if you want any sort of loans approved
05:06:03 <hank_scorpion> vis, getting to know people that are in the business.
05:06:19 <tdammers> Procian: irrelevant. Evil code doesn't typecheck.
05:06:22 <hank_scorpion> sorry if it came off as solicitation!
05:06:35 <hank_scorpion> just want to meet people
05:07:34 <hank_scorpion> i'm actually a 22 year old lab technician, nothing special
05:08:25 <Cale> hank_scorpion: Well, feel free to hang around!
05:08:26 <clrnd> that's more special than me
05:08:27 <hank_scorpion> used irc back when I was a teenager
05:08:51 <hank_scorpion> clrnd: how
05:08:52 <Cale> hank_scorpion: Especially if you'll be learning/using Haskell -- questions about the language are always welcome.
05:09:11 <Cale> hank_scorpion: #haskell-blah is the off-topic version of this channel
05:10:18 <hank_scorpion> ah
05:10:31 <hank_scorpion> i understand
05:18:26 <hank_scorpion> do you know any just general chat channels where I could just go and chat with programmers?
05:20:17 <clrnd> hank_scorpion, ##programming, #<any_programming_language>
05:20:39 <earthy> ##csharp is friendly... :P
05:21:34 <cmtptr> hank_scorpion, "programmers" is extremely broad.  are you looking for anything more specific?
05:21:54 <mniip> wot
05:21:57 <mniip> a cmtptr
05:22:11 <cmtptr> where??
05:22:26 * mniip hands cmtptr a reverse
05:22:43 <hank_scorpion> thanks, sorry
05:23:13 <hank_scorpion> cmtptr: i guess web development for a startup company?
05:23:22 <clrnd> hank_scorpion, #ruby
05:23:26 <mniip> sounds like #webdev ?
05:23:30 <mniip> or whatever was the channel called
05:23:44 <mniip> ##webdev
05:23:54 <hank_scorpion> what's uby like?
05:24:24 <hank_scorpion> is that a language as well?
05:24:26 <mniip> like a mix of perl and python
05:24:36 <mniip> but only keeping the bad parts of both
05:24:52 <bjornars1> the elegance of perl coupled with the speed of python
05:25:05 <mniip> pretty much
05:25:12 <clrnd> lol
05:25:39 <hank_scorpion> lol knowing neither of those references made my interpretation of that sound like you were giving it actual praise bjonars1
05:25:56 <hank_scorpion> then I got it.
05:26:01 <wz1000> Does Float form a moniod over multiplication?
05:26:03 <danilo2_> merijn: I've asked you yesterday what to do in case a documentation is not generated on hackage for a package. You;ve provided me with 2 irc channels I should report this behaviour to. Unfortunetaly I get no response there - trying again or we should do sometinhg else now?
05:26:45 <hank_scorpion> hey mniip thanks for that info
05:26:45 <mniip> can't provide an example of  python's speed, but here's some elegant perl http://qp.mniip.com/p/qru
05:26:51 <clrnd> wz1000, something tells me that aproximation can break things a little
05:27:10 <mniip> Float multiplication is not associative
05:27:10 <hank_scorpion> mniip: lol amazing
05:27:12 <mniip> hence no
05:27:24 <clrnd> mniip, damn
05:27:56 <hank_scorpion> i imagine what perl looks like is what the inside of john carmak's brain is like
05:28:14 <hank_scorpion> i just recently read the book Masters of Doom about the founding of ID
05:28:15 <mniip> well
05:28:21 <mniip> you can write readable perl
05:28:24 <mniip> but
05:28:24 <hank_scorpion> and the dude is straight up intense
05:28:36 <clrnd> I bet john's brain is full of clever tricks and fear of them
05:28:46 <bud> hello there! :D
05:28:49 <wz1000> Does GHC perform any specific optimizations for monoids?
05:28:58 <mniip> hank_scorpion, ****** is a valid perl expression
05:28:59 <hank_scorpion> clever tricks and fear of clever tricks?
05:29:08 <mniip> you'll never guess what it does
05:29:15 <clrnd> mniip, please tell me
05:29:19 <hank_scorpion> wildcard?
05:29:22 <hank_scorpion> i donno
05:29:24 <hank_scorpion> OH
05:29:25 <mniip> it evaluates to 1
05:29:25 <hank_scorpion> password?
05:29:26 <hank_scorpion> LOL
05:29:31 <clrnd> ...
05:29:35 <hank_scorpion> OH so you can use binary?
05:29:37 <wz1000> mniip: To be fair, that can be a valid Haskell expression too.
05:29:48 <mniip> wz1000, (******) maybe
05:30:05 <clrnd> > let (****) = 5 in id (****)
05:30:05 <mniip> not ****** alone
05:30:06 <lambdabot>  5
05:30:38 <mniip> ****** parses into (exponentiation (glob "*") (glob "*"))
05:30:53 <bud> LS
05:30:54 <hank_scorpion> LOL clrnd
05:31:30 <mniip> (glob "*") is most likely undefined, and in numeric context undefined is 0, and 0**0 is 1
05:31:45 <mniip> simple right
05:31:50 <keko-2> hahaha :D
05:31:59 <Benzi-Junior> hey I'm looking for a function that takes a list of lists , finds all the cases where one list has the initial part of another as a terminating part and concatenates them
05:32:02 <wz1000> There are so many things wrong with that I cannot even begin to point them out.
05:32:18 <clrnd> ""numeric context""
05:32:45 <Cale> Benzi-Junior: I don't think you'll find that exact function already anywhere.
05:32:48 <mniip> also you can add multiples of 4 asterisks
05:32:58 <mniip> and it will flip to 0 and back
05:34:16 <Cale> Benzi-Junior: But if you give some examples of what you mean, maybe we could help write it. There's some ambiguity there...
05:34:21 <wz1000> It annoys me that Haskell still hasn't figured out typesafe and writable math.
05:34:32 <Cale> wz1000: What do you mean by that?
05:34:43 <wz1000> > 1/0
05:34:44 <lambdabot>  Infinity
05:34:45 <keko-2> i think it means like concatenating "ab" and "bc" to "abc"
05:35:04 <Cale> wz1000: That is the expected result according to IEEE floating point.
05:35:20 <Cale> wz1000: also, 0 isn't a different type from any other Double value
05:35:35 <wz1000> > 1 `quot` 0
05:35:37 <lambdabot>  *Exception: divide by zero
05:35:54 <wz1000> > 0 ^ 0
05:35:55 <lambdabot>  1
05:36:00 <Benzi-Junior> so f [[1,2],[2,3]] would be [[1,2,3]]
05:36:02 <Iceland_jack> wz1000: Solving that in a general way is not an easy task
05:36:17 <Cale> wz1000: If you wanted to give division a type which didn't allow 0 as the second argument, you'd need a dependent type, and you'd have to pass a proof that the second argument isn't zero, which I suspect most users would find tedious.
05:36:25 <Iceland_jack> But LiquidHaskell and Idris allow you to solve that
05:36:34 <Iceland_jack> You can also solve it in Haskell but it would be more effort than it's worth
05:36:37 <Cale> wz1000: You can do that sort of thing in Idris, but you tend not to in most cases
05:36:42 <Benzi-Junior> Cale:I've got this so far [chain ++ (tail stuff)| chain <- x, stuff <- x , (last chain == head stuff)]
05:36:52 <Cale> Unless you're being *super* careful.
05:37:18 <panther__> hello
05:37:29 <Cale> (because it's really tedious to supply such proofs everywhere every time you need to divide)
05:37:57 <panther__> i am trying to compile a basic Haskell program via command line with GHC on linux
05:38:14 <panther__> i say: ghc --make Hat.hs (hat.hs is my source name)
05:38:22 <panther__> it is not giving me a binary.
05:38:25 <Benzi-Junior> Cale: but then I want to find the "closure" under this opperation which should be doable when I don't hit cycles
05:38:53 <pjdelport> Benzi-Junior: Surely that operation is idempotent?
05:38:58 <wz1000> Maybe and family tends to fail when the expressions that can produce them are common, large and tend to be mixed with expressions that are guaranteed not to produce them.
05:39:00 <Iceland_jack> Cale: LiquidHaskell absolves you of the responsibility of carrying around proof objects
05:39:00 <Iceland_jack>     {-@ divide :: Int -> { v:Int | v != 0 } -> Int @-}
05:39:00 <Iceland_jack>     divide n d = div n d
05:39:17 <panther__> When I do this, usually it gives me a binary that I can execute.
05:39:20 <nshepperd> pff, there's nothing wrong with 0 ^ 0 = 1
05:39:27 <pjdelport> Benzi-Junior: After you do it once, the only edges that should remain should be unequal, so repeating it won't have any effect.
05:39:31 <Cale> nshepperd: Indeed
05:39:32 <panther__> Instead, it is giving me an object file!
05:39:37 <wz1000> > [] !! 0
05:39:38 <lambdabot>  *Exception: Prelude.(!!): index too large
05:39:51 * hackagebot lambdacms-core 0.0.8.0 - Core CMS extension for Yesod apps  http://hackage.haskell.org/package/lambdacms-core-0.0.8.0 (matsrietdijk)
05:40:02 <Cale> Iceland_jack: What happens when the compiler can't prove the invariant on its own?
05:40:07 <wz1000> However, it is hardly practical to change (!!) :: [a] -> Int -> Maybe a
05:40:09 <pjdelport> panther__: Do you have a Main module and main function?
05:40:13 <panther__> yes
05:40:20 <Cale> wz1000: Well, at this point...
05:40:24 <panther__> well, the module is called Hat
05:40:33 <panther__> should I change it to Main
05:40:39 <wz1000> Cale: nshepperd: Thats not how maths works...
05:40:39 <Iceland_jack> Cale: The solver should be able to if it follows from the context
05:40:43 <Cale> wz1000: You should almost never use (!!) or anything like it anyway
05:40:44 <pjdelport> panther__: Ah, you'll have to call it Main, or you have to pass a flag to ghc to treat Hat as the main module.
05:40:59 <Cale> wz1000: Yes it is. Also, it's up to us how maths works.
05:41:00 <igniting> Is there an equivalent of c++ unordered_set in haskell?
05:41:12 <clrnd> Data.Set
05:41:13 <Cale> wz1000: 0^0 is typically defined to be 1 for convenience
05:41:17 <pjdelport> igniting: There are a few set types.
05:41:29 <panther__> ah, thank you, pjdelport. I see
05:41:30 <mniip> in math, 0^0 is undefined
05:41:37 <igniting> I want O(1) lookup
05:41:39 <Cale> wz1000: Consider series formulas like  exp(z) = sum over k >= 0 of z^k / k!
05:41:41 <mniip> however with x->0, 0^x is 0 and x^0 is 1
05:41:45 <Iceland_jack> wz1000: And it's perfectly possible to write code such that '[] !! 0' does not compile, as well as for 'div n 0' not to compile, it's just less elegant
05:41:48 <igniting> I have seen https://hackage.haskell.org/package/hashtables-1.2.0.2
05:42:07 <mniip> Iceland_jack, "such that '[] !! 0' does not compile" sounds like halting problem
05:42:11 <Cale> If you choose to leave 0^0 undefined, then this series formula doesn't work for exp(0)
05:42:12 <danilo2_> Hello! I would love to use Data.IP package, which can read IPv{4,6} from String using simple "read" function. In addition to that I would love to read names such as "haskell.org" as Address. So I create a new data which consist of IP address or name. Anyway, how should I implement read for it? If read for IP fails, it throws exception that I can catch in IO, but I want to "extend" it in pure code. Is there any other wy than just wr
05:42:12 <pjdelport> igniting: HashSet, probably?
05:42:13 <igniting> but it is essentially a table not set
05:42:27 <randomclown> why doesn't this work the way I imagine it would
05:42:28 <Cale> which sucks and is highly inconvenient
05:42:30 <randomclown> with lazy IO
05:42:31 <randomclown> takeWhile (=="asdf") <$> (sequence . repeat) getLine
05:42:47 <Cale> Unless you want almost every Laurent series expansion ever to be annoying to write
05:42:49 <Iceland_jack> mniip: If you know the length of the list and the index statically it's not
05:42:52 <clrnd> igniting, http://hackage.haskell.org/package/containers-0.4.2.0/docs/Data-Set.html
05:42:55 <Cale> You probably want to define 0^0 to be 1
05:43:08 <Iceland_jack> If you don't then you're forced to case split
05:43:21 <mniip> it should do a warning at most
05:43:22 <Cale> Also note: n^m is the number of functions from a set of size m to a set of size n
05:43:30 <igniting> clrnd: That gives O(log n) lookup
05:43:44 <mniip> because I don't want compilation of "simpleExpression !! 0" and "complexExpression !! 0" to differ
05:43:47 <Cale> and there is a single function from the empty set to itself, there needs to be in order for sets and functions to form a category
05:43:59 <Cale> So 0^0 = 1 for that reason as well
05:44:02 <clrnd> igniting, I know, but I'm not aware of a O(1) immutable Set type
05:44:06 <nshepperd> wz1000: technically x^y is discontinuous at (0,0), but most of the time the limit involved is the limit from the "right", which goes to 1
05:44:07 <igniting> https://hackage.haskell.org/package/unordered-containers-0.2.5.1/docs/Data-HashSet.html
05:44:17 <Benzi-Junior> pjdelport: [[1,2],[2,3],[3,4],[4,5]] the first application would give [[1,2,3],[2,3,4],[3,4,5]] the second would give [[1,2,3,4],[2,3,4,5]]
05:44:18 <Iceland_jack> mniip: That's not how you'd want to work with it really
05:44:18 <nshepperd> and also all the discrete math examples Cale gave
05:44:40 <Cale> If you think evaluating the limit as x -> a of f(x) can tell you about the value of f(a), then you misunderstand the purpose of limits, or you think that all functions are continuous.
05:44:59 <Cale> (or both)
05:45:32 <pjdelport> Benzi-Junior: Oh, so [[1,2],[2,3],[3,4],[4,5]] Wouldn't directly become [[1,2,3,4,5]] ?
05:45:40 <nshepperd> the limit can certainly tell you about what f(a) "should" be
05:45:55 <nshepperd> or, what would be convenient
05:46:05 <mniip> from your description sounds like you want [[1,2,3,4,5]]
05:46:25 <Benzi-Junior> pjdelport: no [1,2,3,4,5] would only appear in the closure of the operation
05:47:09 <Benzi-Junior> pjdelport: having said that if you know of a way to get [[1,2,3,4,5]] directly that would do
05:47:21 <pjdelport> Benzi-Junior: So you always want every adjacent pair to be considered separately, and to separately produce either their concatenation, or remain unchanged?
05:47:43 <pjdelport> Benzi-Junior: Well, the way you described it, it would never become [[1,2,3,4,5]] though, would it?
05:48:00 <pjdelport> After [[1,2,3],[2,3,4],[3,4,5]], the adjacent lists no longer have the same end/start.
05:48:07 <Benzi-Junior> pjdelport: not neccesarily adjacent
05:48:10 <pjdelport> So they wouldn't get concatenated anymore?
05:49:07 <pjdelport> Oh, wait, so want to treat them as paths, and just join all of them? Like building a graph?
05:49:24 <moop> sup guys, what's a nice irc library?
05:49:34 <moop> imma gonna write a bot
05:49:55 <Benzi-Junior> pjdelport: basically yes I'm looking to find the longest path
05:50:16 <pjdelport> Benzi-Junior: The easiest is probably to pop it into an existing graph library.
05:50:21 <Cale> Another thing: if you're considering floating point values to represent imprecise quantities, the floating point 0 doesn't really represent *exactly* 0, but all the quantities which are withing some error tolerance of the real 0.
05:51:12 <Cale> For almost all of these pairs (x,y) of quantities near 0, x^y will be near 1. The only way that you can approach any other limit is by following along a curve tangent to the y axis.
05:51:15 <Benzi-Junior> pjdelport: you're probably right I thought since this was the only thing I had to do I could take a shortcut by just looking at the lists
05:51:23 <Cale> (which most curves are not)
05:51:53 <Cale> So even from the entirely practical standpoint of what should we do in the face of rounding error, 1 is the right thing to do.
05:52:44 <lpaste> mniip pasted “joinEnds” at http://lpaste.net/120023
05:52:49 <mniip> Benzi-Junior, ^
05:52:52 <pjdelport> Benzi-Junior: My intuition is that it will get more complicated trying to do that correctly just by working with lists.
05:54:02 <wz1000> Sorry, weechat decided to disconnect and not notify me.
05:54:07 <mniip> make sure you have no empty lists in the input list
05:54:18 <mniip> also hm
05:54:53 <lpaste> mniip revised “joinEnds”: “No title” at http://lpaste.net/120023
05:55:11 <mniip> love me some patterns
05:55:24 <Cale> wz1000: ah, dang
05:56:19 <Cale> wz1000: I don't know if you missed my explanation about why 1 is also the correct value for floating point 0^0, from the consideration of what's best in the face of rounding error
05:56:23 <wz1000> Cale: I missed your replies, but I am reading them from a public log
05:56:57 <merijn> Anyone care to quickly proofread a proposal for me before I throw it on the mailing lists?
05:57:02 <merijn> https://ghc.haskell.org/trac/ghc/wiki/ValidateMonoLiterals
05:57:32 <Benzi-Junior> pjdelport mniip : I managed to do it (sort of) I just changed the closure function so it stopped running once the length of the longest one stoped changing
05:58:18 <mniip> Benzi-Junior, did you see my code
05:58:29 <mniip> involves no iterations or unnecessary chunks
05:58:32 <mniip> thunks
05:58:43 <pjdelport> Benzi-Junior: You could tweak the joining funcion to also produce a count of how many chains were joined at each step, and stop when it reaches 0.
05:58:44 <mniip> well maybe not as many
05:58:49 <Benzi-Junior> mniip: am loking at it right now
05:59:20 <mniip> it reduces everything at once
06:00:40 <wz1000> Cale: I take your point on the 0^0 thing.
06:01:12 <wz1000> Cale: But most of these issues(partial functions that shouldn't be partial) can be solved with basic subtyping. Is there any reason why it wasn't made part of Haskell? Would it make type inference too hard/infeasible?
06:01:24 <wz1000> Cale: By subtyping I mean 'a' automatically casts to 'Maybe a'
06:01:28 <wz1000> So expressions like '1/2 + 3 - 7' would become valid if (/) :: (Num a) => a -> a -> Maybe a
06:01:37 <Cale> Yeah, subtyping makes inference really bad
06:02:07 <Cale> Oh, er, something like that would probably be even worse than subtyping
06:02:16 <Cale> Well, or at least as bad
06:02:23 <c_wraith> automatic type conversions are terrifying.
06:02:35 <c_wraith> What type is that expression?  Who knows!
06:02:56 <Cale> You end up with ambiguities everywhere that you're working with Maybe values then
06:03:10 <Cale> because something could be of type Maybe a or Maybe (Maybe a) or Maybe (Maybe (Maybe a))
06:03:11 <Cale> etc.
06:03:15 <c_wraith> Didn't Tony Hoare call implicit Maybes the billion-dollar mistake?
06:03:19 <Cale> yep
06:03:19 <Benzi-Junior> mniip: your function didn't do it
06:03:26 <merijn> Automatic coercion sounds like a good plan initially
06:03:27 <Iceland_jack> wz1000: Using 'Maybe' is really a non-solution to this (ignoring that it's a dynamic check)
06:03:46 <merijn> But as someone who's spend 3.5 weeks hunting down an implicit conversion bug in C I <3 haskell's explicit conversion
06:03:54 <Benzi-Junior> it stopped without doing anything to [[2,3],[8,9],[1,2],[6,3]]
06:04:16 <merijn> Every time I'm "mildly inconvenienced" by explicit conversions in Haskell I just think back to that pain and suddenly I'm happy again
06:04:30 <wz1000> c_wraith: Well, this is different from null because (a -> b) is guaranteed to return b and not Nothing.
06:04:48 <Iceland_jack> Solving this generally is nontrivial so it's not for lack of trying :) efforts such as LiquidHaskell are very promising
06:05:05 <Benzi-Junior> mniip: but I think it works if the list is sorted beforehand
06:05:23 <c_wraith> wz1000: is it?  It sounded to me like you were proposing it be essentially the same thing as (a -> Maybe b)
06:05:29 <merijn> Awww, come on, one of you IRC slackers has to have time to proofread my proposal >.>
06:05:41 <pjdelport> The problem with implicit conversion is that it's a "guess what i mean", and being human, what we mean is unstable and contextual.
06:06:30 <pjdelport> It should always be better for the compiler to force you to disambiguate what you mean properly, before it almost inevitably becomes a hard-to-spot bug.
06:06:49 <wz1000> c_wraith: It may cast to Maybe b, but if you use it in an expression where no Maybes arise, then it will always return a value of type b, and not nothing
06:06:53 <Cale> merijn: "If the constant we wrote it should always succeed and if it's wrong it can never work." -- I think a word is missing here?
06:07:17 <merijn> Cale: I blame poor web forms! ;)
06:07:44 <merijn> "if the constant we wrote *is correct*"
06:08:16 <c_wraith> wz1000: how far up the call stack does that go?  If something 15 steps up the call chain expects a Maybe, does that spread all the way down the stack?
06:08:46 <merijn> This sounds like an implicit reinvention of the Maybe monad...
06:08:50 <Cale> merijn: I guess that feature would be useful for people using lots of overloaded literals for things
06:08:54 <c_wraith> wz1000: implicit type conversions depending on context always terrify me, because it means that code meaning is non-local.
06:09:00 <Cale> merijn: and it seems easy enough?
06:09:36 <Cale> merijn: I think splitting the classes makes the most sense
06:09:58 <merijn> Cale: I have things like my ZeroMQ library where you want to specify identities for sockets and the protocol mandates they are "<255 bytes and don't start with a 0", that sorta thing. But even things like stopping Word8 overflows and having a safe/checked IsString for ByteString seems like great properties :)
06:09:59 <Cale> merijn: because often there will be only one sort of literal you want to validate, unless I'm mistaken
06:10:00 <wz1000> c_wraith: I expect the value will be converted to a Just ... as soon as it encounters a Maybe
06:10:20 <merijn> Cale: True, but on the other hand you can just have "const Nothing" as default implementation :)
06:13:28 <mniip> hmm, I've seen a lot of places where a function of the type ([a] -> (b, [a])) -> [a] -> [b] would be useful
06:13:45 <wz1000> On an unrelated note, does the Haskell type system have a Godel sentence? What about with GADT's and fancy extensions?
06:13:51 <Iceland_jack> @ty unfoldr
06:13:52 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
06:14:00 <Iceland_jack> That's close..
06:14:02 <mniip> that's not exactly it
06:14:52 <pjdelport> mniip: What would that do exactly?
06:14:53 * hackagebot DynamicTimeWarp 0.1.0.0 - Dynamic time warping of sequences.  http://hackage.haskell.org/package/DynamicTimeWarp-0.1.0.0 (zombiecalypse)
06:18:41 <ienik> hi everyone, i am completly new and can't figure out how to run this code (and actually use fork) - can somebody have a look on it please? http://pastebin.com/xE4a4DnS
06:18:41 <mniip> something along the lines of
06:18:46 <mniip> @let mapUnconcat pred x = case x of [] -> []; x -> let (r, rs) = pred x in r : mapUnconcat pred rs
06:18:49 <lambdabot>  Defined.
06:18:53 <Cale> wz1000: Well, that's a bit of a moot point when the logic is inconsistent
06:18:58 <Cale> wz1000: fix id
06:19:04 <mniip> on a second thought it's a silly name
06:19:32 <mniip> but yeah
06:19:44 <Cale> wz1000: but hmm, a proper Gödel sentence would be very complicated to construct, because Haskell is pretty complicated
06:19:59 <wz1000> Cale: Let's say _|_ is cheating
06:21:29 <Cale> wz1000: Theoretically, it's possible to do that though.
06:22:19 <mniip> > mapUnconcat (break (== ' ') . dropWhile (== ' ')) "hello world foo bar"
06:22:20 <lambdabot>  ["hello","world","foo","bar"]
06:22:34 <Cale> wz1000: I mean, do some sort of Gödel encoding of unicode strings, and then encode well-formed Haskell programs as numbers which satisfy a certain arithmetic condition, and then do whatever you like with that. :)
06:23:03 <ienik> the issue is that fork returns "Managed" type but "IO" is expected, so "wait x" is failing.. and i have no idea how to convert Managed to IO
06:23:46 <wz1000> Cale: Unicode strings come with a free Godel encoding!
06:23:51 <mniip> ienik, what's a Managed
06:24:09 <jameseb> ienik: have you tried forkIO?
06:24:25 <Cale> wz1000: Indeed they do!
06:24:47 <merijn> jameseb: He's using Tekmo's new library so I doubt that's what he wants
06:24:58 <jameseb> ah, okay
06:25:26 <lieven> runManaged perhaps?
06:26:06 <merijn> Either "with" or "runManaged" by the looks of it
06:26:45 <merijn> ienik: Have you read the "Exception Safety" section on http://hackage.haskell.org/package/turtle-1.0.1/docs/Turtle-Tutorial.html ?
06:27:25 <ienik> merijn: going to read it, thank you
06:27:41 <ienik> jameseb: no, it says that: Not in scope: `forkIO'
06:27:51 <ienik> sorry guys, i am really new in Haskell :-/
06:28:37 <jameseb> ienik: yeah, forkIO is in Control.Concurrent but it seems you're using a different library so never mind
06:29:00 <merijn> forkIO forks a lightweight thread, whereas fork appears to fork a managed process :)
06:35:18 <merijn> Cale: btw, do you think that should go to just ghc-devs or also to glasgow-haskell-users/libraries@ ? I'm always unsure where to launch suggestions like these :p
06:36:07 <Cale> merijn: I have no idea
06:36:31 <Cale> merijn: It's been a long time since I've really followed any of the Haskell mailing lists closely
06:36:45 <Cale> merijn: Back when I could read every message, I used to keep up with them
06:37:00 <merijn> I'm following them and I still don't know ;)
06:40:55 <Peaker> ScopedTypeVariables should have been the default! :(
06:41:29 <tdammers> yes, very much so
06:41:56 <tdammers> haskell with STV is way more intuitive
06:43:29 <Cale> Peaker: I recall reading the early mailing list posts, and that was something that came up -- the fact that there are valid definitions in where clauses and let expressions for which no valid type signature can be given.
06:43:35 <angerman> How do I know how much aeson has consumed?
06:43:54 <angerman> It tells me: expecting an Int, encountered a string.
06:43:59 <Cale> Peaker: and I think adding syntax for forall was actually even considered at that point
06:44:52 <t4nk453> @pl ((=<<) (return . msum))
06:44:52 <lambdabot> (msum `fmap`)
06:44:54 <Peaker> Cale: yeah, I am now trying to use NoMonomorphismRestriction in my emacs/ghci mode so I can auto-add-generic-type-sig.. and it causes ambiguous type errors that need signatures with STVs
06:45:20 <merijn> But then I need to invent unique type variables for my local scopes :(
06:45:28 <Cale> Peaker: You can often sidestep the need for explicit type signatures by writing extraneous local bindings
06:45:36 <Cale> Peaker: But it's awkward and hacky
06:45:51 <Peaker> yeah, I can do monomorphic-let via redexes
06:46:03 <Peaker> or use funny identity functions to force type equalities
06:46:39 <Peaker> one Haskell newbie I know had a big WTF moment when he finally understood why his types weren't working (he expected STV's out of the box), and for him, that was Haskell-=1000 :P
06:47:40 <Peaker> I think the "ugly" compromise of STVs-without-foralls would be best. Use TV name from outer-scope, get a warning about missing forall, maybe, but get the STV behavior
06:48:13 <Cale> angerman: If you use one of the ways of running a Parser which produces an IResult explicitly, and you get  Fail s xs e  as the result, then s is the remaining portion of the input which hadn't been consumed yet.
06:48:43 <danilo2_> Hello! What to do if Hackage did not generate documentation for long time - I've seen several packages like this and I have to download them and geenrate docs by myself now :( for example: http://hackage.haskell.org/package/distributed-process-platform
06:48:58 <angerman> Cale: can I use any of them instead of aeson parsing as well?
06:49:10 <Cale> angerman: But it might be good to know more about what you're doing in order to try to solve the problem you're having.
06:49:37 <angerman> Cale: I'm trying to figure out why the slack-api package doesn't work.
06:50:09 <Cale> danilo2_: That one is weird -- there's no build log, so one might assume it hasn't even been attempted.
06:50:28 <angerman> Cale: and I figured that it fails on decodeEither on the json string. Trying to decode it into a SlackSession.
06:50:30 <Cale> danilo2_: In many cases, there will be a log with a build failure because the machine which is building the docs is missing dependencies
06:51:26 <Peaker> btw, about the big Burning Bridges debate, I think one thing everyone misses about why it's so important for APIs to be generalized beyond lists -- is that it would allow us to have   group :: Eq a => [a] -> [NonEmptyList a] ;   iterate :: (a -> a) -> a -> Stream a ;   and other more sensible types, while not losing the convenience of the list API
06:51:58 <Peaker> Haskell is unnecessarily dynamically typed about important aspects (list infinite-ness, non-empty-ness, etc) because everything is so monomorphic to lists!
06:52:11 <danilo2_> Cale: ok, so what can we do now? And what can we do with packages like this one (http://hackage.haskell.org/package/network-transport-zeromq-0.2) - it did not build because there was other version of zeromq installed on the system - maybe some sandboxing would be good or just forcing docs generation?
06:52:36 <merijn> Peaker: I'm possibly getting a bachelor student to start working on alternatives for that :p
06:52:57 <Peaker> merijn: which "that"? :)
06:52:58 <merijn> Peaker: Initially just exceptions, but I would like to do totality, etc. too
06:53:02 <Peaker> ah
06:53:13 <merijn> Typing/inferring effects, exceptions, etc.
06:53:14 <Peaker> merijn: but Infinite-vs-Finite list should be in the type system
06:53:30 <Peaker> merijn: otherwise you should just do it for Python or something :)
06:53:32 <Cale> danilo2_: That's not a question I can answer, you'll have to talk to someone who is running the Hackage server. Perhaps send an email to admin@hackage.haskell.org and ask about it.
06:53:41 <Peaker> merijn: who needs the type noise anyway? :)
06:54:15 <danilo2_> Cale: ok I will, thank you!
06:54:42 <merijn> Peaker: But my first upcoming campaign, other than diving back into the async stuff (again...) is compile time checked literals in haskell :p
06:55:03 <Peaker> merijn: I think the async stuff has less enemies now, and it's time to just make a patch and not ask anyone again
06:55:09 <Peaker> merijn: all the "big guns" voted in favor already :)
06:55:41 <merijn> Peaker: True, but I haven't had time to write a patch :p
06:55:42 <Peaker> merijn: "checked literals" as in "if is always True" checked?
06:55:56 <Cale> Peaker: I can see both sides of this issue. I'm a little hesitant to give up on the specialness of lists. Lists are a very important universal construction on their own. Though in some cases we could be more precise, like those examples you just gave, that's I think more an argument for just being more precise.
06:56:11 <merijn> Peaker: https://ghc.haskell.org/trac/ghc/wiki/ValidateMonoLiterals
06:56:24 <Peaker> Cale: but if you are more precise, how do you "take" from the result of an iterate?
06:56:32 <Peaker> Cale: "take" ought to be generalized
06:56:37 <Cale> Being polymorphic doesn't exactly help you express those things in the type which you expressed there.
06:57:03 <Cale> Unless I don't understand what the proposal is :)
06:57:04 <Peaker> Cale: well, do you want all the list API to exist for NonEmptyList and Stream with duplication?
06:57:12 <Cale> Maybe!
06:57:14 <Peaker> Cale: or usual qualified import stuff?
06:57:30 <Peaker> Cale: well, that's probably terrible enough to have caused the mess we have to be chosen in the first place!
06:57:42 <Peaker> (the mess we have) to be chosen
06:57:54 <Cale> I don't know really what the right thing is, but lists are extremely important to our lives, and being cautious about tampering with how we work with them is probably a good thing.
06:58:10 <danilo2_> Hello! Is there in haskell a data structure like Map but with many keys? I mean - I would like to use many keys with different key types pointing at the same thing? Additional I would like to get access to different keys having one of them
06:58:16 <Peaker> Cale: unless how we're working with them is.. wrong :)
06:58:30 <Cale> Well, there's no right and wrong exactly
06:58:30 <Peaker> Cale: and having imprecise types is un-Haskelly and wrong..
06:58:51 <Cale> and I disagree about that -- types being imprecise to some degree is important
06:58:54 <tdammers> danilo2_: Map has just one key type, how would that work?
06:59:16 <tdammers> danilo2_: I'd use one Map ID Value, and then several Map SomeKey ID
06:59:19 <rasen> danilo2_: you can do that if you create your own key type with instance of Ord, Eq
06:59:21 <Peaker> danilo2_: https://github.com/Peaker/MapManyToOne/blob/master/src/Data/MapManyToOne.hs <-- like that?
06:59:23 <tdammers> and then do the lookup in two stages
06:59:26 <Cale> Otherwise we'd be at the far end of the dependent type spectrum, producing dependent tuples that include all sorts of proofs along with every result all the time
06:59:37 <Cale> Right?
06:59:41 <danilo2_> tdammers: simply - I would like to for example "insert ("test1", 10) "foo" m" and I want to be able to access that m by "test1" or 10
06:59:42 <Cale> Why don't we do that?
06:59:57 <Peaker> Cale: sure, but finite vs. infinite list is a really easy distinction, not far end of spectrum
06:59:58 <Cale> Even dependently typed programmers don't do that :)
07:00:01 <tdammers> danilo2_: the two-stage approach would do that
07:00:24 <saep> danilo2_: IxSet maybe?
07:00:31 <Peaker> Cale: May as well squash Maybe with [] too :)
07:00:32 <Cale> It's a spectrum and there's no absolutely correct answer about where you should put yourself along it
07:00:46 <Peaker> Cale: Maybe = [] = InfiniteList = NonEmptyList :)
07:00:48 <Cale> about which errors are compile time and which are runtime
07:01:14 <Peaker> Cale: I think the "right" thing should always be to strive to have more precise types until it starts to be painful
07:01:21 <Cale> and Haskell has made certain compromises which haven't been terrible
07:01:24 <danilo2_> Peaker: almost - I would like to have different key types
07:01:39 <Peaker> danilo2_: why?
07:01:39 <Cale> NonEmptyList does start to be painful!
07:01:43 <danilo2_> rasen: I do not think it will provide me access to convertion between keys, would it?
07:01:51 <Peaker> Cale: InfiniteList doesn't
07:01:55 <Cale> At least some of the time
07:02:13 <Peaker> Cale: in fact, list for infinite cases is more painful and yields incorrect exhaustiveness warnings :(
07:02:30 <Cale> Well, sometimes that's annoying
07:02:37 <danilo2_> Peaker: hmm, just because it would be easier and nicer in the code, but you are right, maybe I will stick with an additional datatype gathering all key types and use something like you've provided, hmm
07:02:51 <Cale> Though, I rarely use the exhaustiveness checker because it's usually obnoxious
07:03:06 <rasen> danilo2_: if you save your key along with data itself
07:03:33 <Peaker> Cale: I find that perplexing!  I see Haskell as all about compile-time safety.. without exhaustiveness checking, a huge dynamically-typed-shaped hole is opened
07:03:51 <Peaker> and I also find it's only obnoxious when I've failed to encode my invariants in my types
07:03:54 <Cale> Well, it's all about compile time safety relative to many other languages
07:03:59 <danilo2_> saep: hmm ,the IxSet is interesting, Im reading abgout it, Thanks!
07:04:23 <Peaker> Cale: I don't know how much safer Haskell is than other languages without exhaustiveness checking.. it's quite similar to having potential null dereferences everywhere
07:04:25 <Cale> (and in particular, compared to every other language with wide industrial use)
07:04:40 <Cale> But if you're going to be like that, why not just insist on totality?
07:04:43 <Cale> tee hee
07:04:48 <Peaker> I do! until it's too painful
07:05:07 <Peaker> exhaustiveness checker at least makes sure I'm honest about where I'm not total
07:05:16 <Peaker> (and gives me an extra nudge towards totality)
07:05:26 <Cale> Haskell isn't really the right language to do this in, I think eventually we'll need a lazy dependently typed total-by-default language.
07:05:53 <Cale> I'm sad that Idris has chosen strict evaluation by default
07:06:10 <Peaker> I want laziness to be Thunks in the types
07:06:15 <Peaker> so Idris is a step closer to that
07:06:21 <Cale> Just because you know that strict evaluation will terminate doesn't mean it's the right evaluation strategy automatically
07:06:52 <merijn> Peaker: I wanna do lazy vs strict typing too, if you have ideas about it we should brainstorm :)
07:06:53 <Peaker> sure, but laziness isn't the right strategy either, for other reasons
07:07:01 <Cale> I really like using the lazy list monad on technically finite but combinatorially large examples
07:07:10 <merijn> Peaker: My main problem is that just lazy vs strict is not sufficient
07:07:26 <Cale> Well, lazy is the best default imo
07:07:42 <Cale> (okay, lazy with strictness analysis)
07:07:43 <Peaker> Cale: ListT Thunk
07:07:46 <merijn> Peaker: You might want to just have "spine strict", so clearly strict vs lazy is not descriptive enough
07:07:52 <Cale> No, screw representing it in the types
07:07:54 <merijn> Cale: Agreed, lazy is the right default imo
07:07:56 <Cale> That's terrible!
07:08:02 <merijn> Cale: Why?
07:08:13 <Cale> It's inconvenient and nobody will do it
07:08:29 <Cale> The whole advantage of lazy by default is that we have libraries of things which are lazy enough
07:08:32 <Peaker> why? It's great, instead of leaking the abstraction in a way that's hard to see through -- make it part of the abstraction - making performance easy to predict. Making it possible to specialize functions to certain behaviors, etc.
07:08:34 <Cale> which can be composed together
07:08:34 <merijn> Cale: That's why you should infer it!
07:08:42 <merijn> Cale: Why is it inconvenient?
07:08:45 <Cale> Most of the benefit of lazy evaluation is compositionality
07:08:46 <Peaker> Cale: but that would be true with polymorphically-typed-laziness too?
07:08:47 <phaazon> hey, I have a type data Light = Omni Color Float Float Float Bool
07:08:52 <phaazon> I have to write a Storable instance for that
07:08:52 <Cale> If the easiest thing isn't the lazy one
07:08:54 <phaazon> sizeOf is easy
07:08:58 <phaazon> alignment, I have no idea
07:08:58 <Cale> then people won't write those libraries
07:09:09 <Cale> and you lose the benefit of compositionality
07:09:10 <Peaker> Cale: "fmap" would work on a strict-spine list and a lazy-spine list, and it would be lazy on the latter, just like in Haskell
07:09:42 <merijn> Peaker: Right, but then you need to somehow distinguish "lazy, spine strict and strict" in the type system? Are the any other mixes?
07:09:47 <RchrdB> phaazon: typically the largest alignment of any of the components.
07:09:57 <Cale> Peaker: Yeah, but if it takes more characters to specify that you want a lazy one, then you'll end up rewriting libraries half the time because the author chose incorrectly.
07:10:08 <merijn> Cale: Even if people can write "strictness-polymorphic" code?
07:10:10 <phaazon> hm
07:10:10 <Peaker> merijn: ListT Thunk a  (lazy-spine of strict a's).  ListT Identity (Thunk a)   (strict-spine of lazy a's), etc.
07:10:17 <phaazon> I don’t get the use of that function
07:10:21 <Cale> While strictness is usually easier to add after the fact
07:10:27 <Peaker> Cale: the authors will keep it polymorphic
07:10:30 <merijn> Peaker: Ah, no *that* is terrible, I don't plan to have it in the functional types
07:10:30 <Cale> Laziness is delicate
07:10:50 <Peaker> Cale: will GHC specialize an entire library from lazy to eager if I force it from the outside, due to strictness analysis?
07:11:05 <Peaker> merijn: I know your plan :)
07:11:14 <RchrdB> phaazon: say I have data Foo = Foo Word32 Word8 -- for some reason, and I define instance (Storeable Foo) where sizeOf _ = 5 ...
07:11:31 <Cale> Peaker: Well, we don't do enough of that sort of thing yet, but this is an engineering issue :)
07:11:48 <Cale> (it will do some!)
07:11:58 <merijn> Peaker: My question to you is: Is there anything we'd want outside of strict, spine strict and lazy?
07:12:00 <Cale> You can use foldl and strictness analysis will turn it into foldl'
07:12:07 <Cale> quite a lot of the time, when appropriate
07:12:10 <Peaker> merijn: in some cases, sure
07:12:12 <phaazon> RchrdB: yeah, sizeOf (undefined :: Word32) + sizeOf (undefined :: Word8)
07:12:14 <phaazon> then?
07:12:15 <roelof> someone who can help me figure out how to make this work with recursion : https://www.haskell.org/pipermail/beginners/2015-February/014584.html
07:12:29 <merijn> Peaker: Alternatively I was thinking of figuring out how to do "minimal" propagation of strictness
07:12:50 <Peaker> merijn: you might even need to do something like: foo :: Proxy a -> ..  just to tell a function how to be lazy about some internal value
07:12:57 <RchrdB> phaazon: if I define (alignment _ = 4), then anything which stores Foos contiguously will know to always make sure that every foo starts on a 4-byte boundary.
07:13:05 <Cale> roelof: looking...
07:13:06 <merijn> Peaker: i.e. when calling fold and annotating the result to be strict somehow propagating that to do the minimal strictness, making the folding operation strict without making the list itself strict too
07:13:16 <phaazon> RchrdB: yeah, what is it for then?
07:13:30 <Cale> roelof: Well, the empty tail is wrong
07:13:33 <phaazon> if you do that, you’ll waste memory, right?
07:13:44 <Cale> roelof: Perhaps you want to recurse on n `div` 10?
07:13:49 <c_wraith> RchrdB: That appears to be a backwards viewpoint.  Storable is for types that exist to marshal to/from C types. You want Storable's data to match a C struct, not the type in haskell.
07:14:00 <Cale> roelof: You also probably want toDigits 0 to be []
07:14:04 <phaazon> if you stock a Foo, then the next Foo you can stock will further
07:14:08 <phaazon> not really continuous
07:14:09 <Peaker> Cale: there's a real composability benefit, which you can (a bit more tediously) get with typed laziness, if people keep things polymorphic.  But there's also a huge pain to laziness, it creates possibly the biggest "abstraction gap" of understanding between the metal and the program semantics
07:14:14 <merijn> Peaker: I think the minimal requirement would be that "foldl (+) 0 . takeWhile p" should be terminating if the lazy version would be, even when "strictifying" it
07:14:27 <roelof> Cale : What I try to achieve is that toDigits 123 will be [1,2,3]
07:14:29 <RchrdB> phaazon: but if I define (alignment _ = 1), then something might lay them out in memory compactly, and CPUs (often) don't like accessing types when they're not aligned to appropriate boundaries.
07:14:31 <phaazon> for a true continuous, it would require alignment = 1, right?
07:14:32 <c_wraith> RchrdB: and in just about every C compiler I know of, a struct containing an int32 and a byte will have a sizeOf at 8
07:14:40 <Cale> roelof: The easiest way to do that is to reverse at the end
07:14:44 <phaazon> ah
07:14:53 <Cale> roelof: It's much more natural to generate the digits in the opposite order first
07:15:01 <phaazon> RchrdB: for caching purposes, I guess?
07:15:06 <Cale> roelof: simply because n `mod` 10 will give you the ones digit
07:15:12 <Peaker> merijn: "strictifying"? If it's all explicit there's no strictifying?
07:15:17 <phaazon> because a cache is organized as ranges
07:15:25 <Cale> roelof: and it's easiest to produce the digits in the order that you compute them
07:15:29 <RchrdB> phaazon: pass, something byzantine and low-level about how load instructions work.
07:15:32 <roelof> oke, that would be the next assigment make isdigits 123  output [3,2,1]
07:15:39 <c_wraith> phaazon: bus purposes, really.  Memory is optimized for accesses on word boundaries.  In fact, that's where the term "word" comes from.
07:15:42 <phaazon> so the structure will be gotten in a fewer calls
07:15:45 <roelof> Cale
07:15:51 <Cale> roelof: Yeah, that should really be the *first* assignment :)
07:15:51 <RchrdB> What c_wraith said.
07:15:56 <merijn> Peaker: I mean, if we have a strictness polymorphic fold and we annotate that we want it to be strict in this invocation
07:16:01 <phaazon> hm
07:16:03 <Cale> roelof: and only after you do that, you do the opposite order :)
07:16:05 <roelof> right and n 'div' 10 gives me the rest of the numbers
07:16:15 <Cale> yeah, careful, you want to use ` not '
07:16:17 <Peaker> on modern Intels, misalignment is no longer expensive (unless it crosses an aligned-64-byte-boundary, i.e: a cache-line)
07:16:20 <phaazon> so why not use aligment = 4 everywhere then?
07:16:36 <roelof> why 'not'  ??
07:16:36 <RchrdB> 4 isn't appropriate for everything.
07:16:46 <Peaker> merijn: foldl is always strict, isn't it?
07:16:52 <Cale> roelof: ' is used for character constants
07:16:52 <RchrdB> Some vector types want 16. Pointers on amd64s want 8.
07:16:52 <Welkin> no
07:16:53 <phaazon> roelof: because we have to provide the alignment function
07:16:55 <phaazon> in C for instance
07:17:00 <phaazon> there’s a default alignment
07:17:01 <Peaker> merijn: can you revise the example?
07:17:04 <Welkin> foldl is not strict
07:17:07 <Welkin> foldl' is strixt
07:17:14 <Welkin> strict*
07:17:30 <Cale> roelof: (and is a valid character in variable names, past the beginning)
07:17:35 <roelof> phaazon:  aligment function : now as beginner I mis the point
07:17:46 <Cale> roelof: So, it's backtick ` which is used to make things infix
07:17:49 <Peaker> phaazon: numbers of size S usually wanted alignment S, more than that would be wasteful. As I said above, on modern Intels (and ARMs too, I think) this no longer matters much
07:17:53 <merijn> Peaker: foldl isn't always strict in haskell currently, and while I agree that that's probably the wrong default, it's just an example here
07:17:59 <RchrdB> phaazon: anyway, what c_wraith said - you generally don't want to be writing Storable instances by hand. The point of Storable is to match some C struct, so you should normally use a tool that generates Storable instances from C headers for you. :)
07:18:24 <phaazon> RchrdB: I have to pass a Light to my shader (OpenGL) via SSBO
07:18:25 <Welkin> merijn: it doesn't make sense for it to be converted to foldl' because then it has unpredictable behavior
07:18:27 <Cale> roelof: It's possible to have a function called something like div' and then make it infix as `div'`
07:18:31 <phaazon> that requires to pack my Light in a buffer
07:18:34 <merijn> Peaker: It's just the simplest example I can think of where making something strict could make terminating code non-terminating which I'd consider bad
07:18:36 <phaazon> which requires it to be Storable
07:18:41 <RchrdB> phaazon: most RISC CPUs will actually throw exceptions on misaligned stores/loads.
07:18:50 <Welkin> you don't know if it is lazy or strict at that point
07:19:11 <nyuszika7h> how can I get all possible 4-length combinations of [1,2,3,4,5,6,7,8,9]?
07:19:19 <merijn> Welkin: FYI, we're not discussing haskell here, but non-existent potential languages :p
07:19:27 <roelof> Cale : I was thinking to use  n `mod' 10 to take the number and then recurse it with n `div' 10  but as you can see it has Integer -> [Integer] so I do not see how to take care
07:19:31 <Peaker> merijn: I think it has to start like a ListT fold: foldr :: (Monad l, Copointed l) => (a -> b -> l b) -> b -> ListT l a -> l b
07:19:36 <Welkin> merijn: my comment still applies
07:19:42 <Welkin> who would want an unpredictable langugae?
07:19:46 <roelof> that [1] and the 23 is recursive be uses
07:19:49 <Peaker> merijn: I think once its explicit, it's no longer bad
07:19:52 <Cale> roelof: What's wrong with that type?
07:20:01 <Peaker> merijn: "l" is our polymorphic laziness (or our effect monad for ListT)
07:20:28 <Peaker> perhaps the "b" arg ought to be "l b" too
07:20:36 <roelof> I cannnot do something like  isDigits [1] 23  because of it
07:20:47 <Cale> > let toDigits n | n <= 0 = []  | otherwise = n `mod` 10 : toDigits (n `div` 10)  in  toDigits 271893
07:20:48 <lambdabot>  [3,9,8,1,7,2]
07:20:48 <Peaker> merijn: I guess the Copointed instance isn't needed there
07:20:55 <hsk3> If I load "a=2" from a hs file into GHCi and type ":t a" I get "Integer"
07:20:56 <hsk3> If I do ":t 2" in GHCi I get "Num a => a"
07:20:56 <hsk3> Can someone explain wtf is happening here?!
07:20:57 <Cale> roelof: ^^
07:21:02 <RchrdB> phaazon: I think at this point that you really need to know all the ugly details about how your shader program will expect to see the bytes laid out in memory, then. :)
07:21:08 <merijn> Welkin: We're talking about strictness polymorphism, it's no unpredictable, but deciding HOW to do strictness polymorphism is non obvious
07:21:14 <hyPiRion> nyuszika7h: [(a, b, c, d) | a <- [1..9], b <- [1..9], c <- [1..9], d <- [1..9]] for example
07:21:17 <merijn> hsk3: Numeric literals are polymorphic in Haskell
07:21:18 <Cale> hsk3: Numeric defaulting
07:21:36 <merijn> oh, I missed the other
07:21:40 <Peaker> merijn: I think the foldr example actually shows me its more comple than I thought
07:21:43 <Peaker> complex
07:21:43 <Cale> Also, the monomorphism restriction :)
07:22:04 <merijn> hsk3: Welcome to the Dreaded Monomorphism Restriction >.>
07:22:06 <merijn> @where dmr
07:22:06 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:22:09 <hsk3> :S
07:22:09 <merijn> See that for details
07:22:11 <Peaker> merijn: because it binds the laziness of the spine with the laziness of the result. It may be more complex than that, possibly
07:22:21 <merijn> Peaker: Right, exactly
07:22:38 <roelof> Cale oke, that a whole other way then I try to solve it what does the : between  the mod and the recursive part do ?
07:22:38 <nyuszika7h> hyPiRion: that's permutations
07:22:43 <danilo2_> Hello! I've got a problem with network-transport-tcp - we can have many connections to the same network address. Al l events base on the adress ID, but when connection i lsot, we get information about the lost connection address and there is no functionality (as far as I see) to see what ID's are associated with given address. Is there any solution for that or just keeping custom mapping ?
07:22:47 <Cale> hsk3: When a module is typechecked, any type variables which are ambiguous, and which are constrained by Num or Fractional, and not constrained by non-Prelude typeclasses, get defaulted to Integer or Double, whichever of these applies first.
07:22:50 <nyuszika7h> the same number can't occur twice
07:22:58 <nyuszika7h> so (1,1,2,3) is not valid
07:23:03 <hyPiRion> nyuszika7h: ah
07:23:07 <merijn> Peaker: I think your ListT type is horrifically unreadable, though >.>
07:23:08 <hyPiRion> I misread
07:23:23 <Cale> roelof: x : xs is the list whose first element is x, and whose tail is the list xs
07:23:32 <Cale> > 1 : [2,3,4,5]
07:23:33 <lambdabot>  [1,2,3,4,5]
07:23:38 <RchrdB> phaazon: oh also my brain isn't quite working, the main reason for needing to know types' alignment isn't padding but memory management. If you're allocating from a pool, then you really don't want to allocate misaligned storage for the type that's going to put into it.
07:23:45 <roelof> yes, that part I understand
07:24:00 <Cale> roelof: Every list is either the empty list [], or it is a nonempty list constructed by adding an element to another list using (:)
07:24:39 <Cale> roelof: So that's what the (:) is doing there
07:24:50 <Cale> roelof: The first element of our list is n `mod` 10
07:24:55 <hsk3> Cale: what is meant by "applies first"?
07:24:56 * hackagebot hyphenation 0.4.2 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.4.2 (EdwardKmett)
07:25:00 <roelof> Cale : thanks , recursion for me is a difficult subject to get around in my head
07:25:01 <Cale> roelof: The rest of the list is toDigits (n `div` 10)
07:25:02 <RchrdB> phaazon: the "this struct might be laid out contiguously when it shouldn't" problem is dealt with by adding padding as c_wraith pointed out, but that isn't sufficient for an allocator to be sure that it's giving you a start address that is correctly-aligned. :)
07:25:18 <Cale> hsk3: satisfies the type class constraints
07:25:43 <Cale> hsk3: Like, if you require (/) to work, then there will be a Fractional constraint, and Integer won't work
07:26:00 <Peaker> merijn: do you think "traverse" is much less readable than "mapM"?
07:26:02 <Peaker> @type traverse
07:26:03 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:26:03 <Peaker> @type mapM
07:26:04 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
07:26:27 <Cale> hsk3: another thing which is affecting things here is the monomorphism restriction, which is actually kind of dumb and probably eventually going away, but something which is in the standard nonetheless
07:26:37 <hsk3> Cale, but with 2+2.0, how did it determine that Integer won't work?
07:26:50 <Cale> hsk3: It says that whenever you have a binding which is a pattern binding, rather than a function binding
07:26:50 <nyuszika7h> hmm, I think I can use: [(a,b,c,d) | a <- [1..9], b <- [1..9], c <- [1..9], d <- [1..9], a /= b, a /= c, a /= d, b /= c, b /= d, c /= d]
07:26:54 <Peaker> merijn: Generalizations are "less readable" and "more readable" at the same time :)  Give more information about constraints on impl. Require more thought to read
07:27:05 <Cale> hsk3: It's not allowed to be type class polymorphic
07:27:18 <Cale> :t 2.0
07:27:18 <lambdabot> Fractional a => a
07:27:34 <Cale> hsk3: 2.0 is explicitly Fractional
07:27:48 <Cale> (but still polymorphic)
07:27:56 <Cale> > 2.0 :: Double
07:27:57 <merijn> Peaker: I do, actually :)
07:27:57 <lambdabot>  2.0
07:28:03 <Cale> > 2.0 :: Complex Rational
07:28:04 <lambdabot>  No instance for (GHC.Float.RealFloat
07:28:04 <lambdabot>                     (GHC.Real.Ratio GHC.Integer.Type.Integer))
07:28:04 <lambdabot>    arising from the literal ‘2.0’
07:28:08 <Cale> oh, right :D
07:28:11 <Cale> > 2.0 :: Complex Float
07:28:12 <lambdabot>  2.0 :+ 0.0
07:28:18 <Cale> > 2.0 :: Rational
07:28:19 <lambdabot>  2 % 1
07:28:44 <Cale> > 2.0 :: CReal -- do we still have this library?
07:28:45 <lambdabot>  2.0
07:28:51 <Cale> yep, apparently so :)
07:29:04 <Cale> > 2.0 :: Integer
07:29:05 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
07:29:05 <lambdabot>    arising from the literal ‘2.0’
07:29:16 <hsk3> Cale: but that's GHCi telling me it's Fractional a => a. Is GHCi telling me the truth here? i.e., is the type of 2.0 the same in a .hs file?
07:29:23 <Cale> Yes, it really is
07:29:26 <merijn> hsk3: Yes
07:29:28 <hsk3> ok
07:30:03 <Cale> It's just that the type of your defined variable is being constrained to not be polymorphic because of a somewhat silly rule which insists that things that look like constants actually ought to be computed just once.
07:30:09 <hsk3> But if I assign it to a variable, it turns into Double :S
07:30:13 <hsk3> in a .hs file only
07:30:26 <Cale> You can give an explicit type signature to a if you want to maintain the polymorphism
07:30:37 <Peaker> merijn: well, I think there is an extra difficulty to generalizations, but it's definitely worth the price
07:30:40 <merijn> > let x :: Num a => a; x = 2; f :: Int -> Int; f = (+1); g :: Double -> Double; g = (+1) in (f x, g x)
07:30:41 <lambdabot>  (3,3.0)
07:30:45 <Cale> a :: Fractional t => t
07:30:46 <Cale> for instance
07:30:57 <merijn> As you can see, 'x' can be used as both Int and Double there :)
07:30:57 <Peaker> merijn: We only need to learn the generalization once -- and it is applicable to far more situations
07:31:21 <Cale> hsk3: The thing you give up by making a polymorphic is that it will be computed again everywhere that it is used
07:31:23 <hsk3> This is all a pain in the neck. I'm actualy thinking about just starting doing (2::Int) and (2.5::Double) everywhere to avoid this headache!!!
07:31:33 <merijn> hsk3: Why?
07:31:40 <Cale> hsk3: You usually don't have to worry so much in a real program
07:31:50 <Peaker> recently I realized that it was weird that (forall a. a) -> ..  is allowed even without ImpredicativeTypes, whereas Maybe (forall a. a) is not.  -> is just a type constructor, like Maybe!
07:32:01 <Cale> hsk3: Because doing lots of stuff with the numeric values will constrain their types to be what you intended
07:32:18 <Cale> hsk3: It's only in these really small examples that things get a little weird
07:32:25 <hsk3> ok
07:32:26 <merijn> Peaker: Lack of ImpredicativeTypes in haskell makes me sad :(
07:32:51 <Cale> hsk3: You do need to have a consistent idea of what the types are though
07:32:53 <Peaker> merijn: yeah, it means that RankNTypes *checking* is not seamless in Haskell, let alone inference
07:33:03 <merijn> Peaker: Well of course not
07:33:09 <Cale> hsk3: So it can be good to provide type signatures for top-level bindings anyway
07:33:10 <merijn> Peaker: RankN inference is undecidable
07:33:17 <Peaker> merijn: sure! but even checking doesn't work
07:33:25 <Peaker> merijn: unless you annotate the hell out of it
07:33:45 <Cale> hsk3: Like, just the functions and constants you're defining in your module. But giving type annotations for every subexpression usually isn't necessary.
07:34:08 <pippo> ciao
07:34:15 <pippo> !list
07:34:15 <monochrom> pippo: http://okmij.org/ftp
07:34:23 <merijn> <3 monochrom
07:34:25 <Cale> monochrom: :)
07:34:39 <hsk3> Cale: So if I want to maintain polymorphism, I can't rely on the Haskell type system to tell me the type? (since it turns it into Integer or Double)
07:34:59 <Peaker> merijn: btw, just because a problem is undecidable, doesn't mean we shouldn't try to solve it anyway :-)
07:35:47 <merijn> hsk3: No, ghci just tries to "monomorphise" let definitions in the commandline, whether it's numbers or not
07:35:48 <Cale> I've often thought about running a Haskell w4r3z XDCC just for those occasions.
07:36:00 <Guest56824> Hey guys, is anybody able to help a newbie? http://lpaste.net/5658780405034123264
07:36:34 <merijn> Guest56824: You're convert function is wrong
07:36:36 <Cale> hsk3: Well, turning the monomorphism restriction off will help. Try adding {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your module
07:36:55 <merijn> Guest56824: You have a tuple pattern match, but the type says it expects a String
07:37:02 <hsk3> Okay, I'll read up on this stuff. Gotta crack this once and for all
07:37:05 <merijn> Guest56824: You probably want "convert ('a':rest)" instead of "convert ('a',rest)"
07:37:10 <Cale> hsk3: It's just because of this silly rule which most people kind of hate, that says when you define something which isn't explicitly a function, it can't be type class polymorphic.
07:37:12 <Peaker> merijn: new ghci has -XNoMonomorphismRestriction by default
07:37:16 <hsk3> But it's good to know that GHCi is telling me the truth with ":t 2" and ":t 2.0"
07:37:28 <Cale> hsk3: Let me get you a link...
07:37:35 <hsk3> Cale: yeah, what is that rule called?
07:37:44 <merijn> Guest56824: Also, you're using "map convert" which you map over a String, even though "convert" has type "String -> String"
07:37:46 <Guest56824> @merijin O.K., thanks for pointing that out
07:37:46 <lambdabot> Unknown command, try @list
07:37:48 <Cale> The monomorphism restriction
07:37:51 <hsk3> ok thanks
07:38:09 <Peaker> MR says: If there are no params in left of =  AND  it has type-class constraints  AND  no explicit type-signature  -->  It gets a monomorphic type (At least for the type-class constrained vars)
07:38:30 <merijn> Guest56824: A String is a [Char] (list of Char), so "map convert myString" will apply "convert" to every Char, which means "convert" should take a Char as input to work
07:39:04 <Peaker> not "at least"  but  "just"
07:39:06 <Cale> hsk3: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5
07:39:10 <Guest56824> merijn: Thanks for pointing the first one out. And regarding convert, should I keep the format (_:rest)?
07:39:27 <hsk3> ok i'll look at it
07:39:41 <Cale> hsk3: The initial bit is a bit technical
07:39:44 <merijn> Guest56824: You probably want to make it "convert :: Char -> Char" and do like "convert 'a' = '4'" and then use "map convert" :)
07:39:49 <Cale> hsk3: But they discuss it more informally after that
07:40:10 <merijn> Guest56824: In general, you have a LOT of unnecessary map's in there :)
07:40:14 <hsk3> cool
07:40:55 <merijn> Guest56824: My remark about map and "String -> String" also applies to your mapping of leetconvert, etc.
07:40:55 <Cale> hsk3: It's kind of a stupid rule in a lot of cases, which is why there's an option to turn it off :)
07:41:14 <hsk3> Cale: Do most keep it on?
07:41:29 <Cale> Most of the time it doesn't really have an impact
07:41:33 <hsk3> ok
07:41:37 <Cale> Sometimes it's super annoying
07:42:03 <Cale> In highly contrived cases, it can make programs exponentially faster.
07:42:04 <Guest56824> merijn: And shouldn't convert have a case where it stops? I'm afraid that it'll run infinitely if I don't add an empty case
07:42:27 <Cale> But I'm dubious about whether there are realistic cases where it really saves the day
07:42:53 <Cale> If you care about performance, you'll probably have specified the types of things you're working with, and you'll have been careful about polymorphism
07:43:04 <lpaste> merijn revised “Converting words”: “Simplified converting words” at http://lpaste.net/5658780405034123264
07:43:21 <merijn> Guest56824: I'd rewrite it as that paste
07:43:30 <Guest56824> Ooh
07:43:44 <merijn> Guest56824: "map" already stops when it hits the end of the list
07:43:45 <Guest56824> Alright, thanks merijn :)
07:44:02 <merijn> Guest56824: So effectively that applies first 'toLower' and then 'leetconvert' to each Char in the list
07:46:15 <Cale> hsk3: Consider the program where you write  x = product [1..100000]
07:46:31 <hsk3> ok
07:46:49 <hsk3> what about it
07:47:00 <Cale> hsk3: You might expect that x is computed at most once and then the already computed value is used wherever needed after that
07:47:15 <Cale> hsk3: Because x certainly appears as if it's a constant and not a function.
07:47:54 <Cale> hsk3: But because of the way that type class polymorphism is implemented, if x is polymorphic, then it's really a function of the type class dictionary -- i.e. the implementation of the Num operations
07:48:00 <Cale> (like (*) and so on)
07:48:22 <Cale> and so it would be recomputed in each place where it's used, consuming lots of time
07:48:36 <hsk3> Cale: ah. but why isn't it recomputed if it's type is Integer?
07:48:41 <hsk3> because of GHC optimization?
07:48:54 <pjdelport> :t product [1..100000]
07:48:55 <lambdabot> (Num a, Enum a) => a
07:48:57 <Cale> Because then it's *really* a constant
07:48:59 <merijn> hsk3: No, because haskell will only evaluate a value once, so the Integer is only computed once
07:49:29 <hsk3> Ah, so there is a distinction between constants and functions, even if constants technically are functions?
07:49:41 <Cale> yeah, any variable will only be evaluated at most once, but if that variable is a function, this rule doesn't mean that the result of applying that function will be kept
07:49:43 <merijn> hsk3: The basic problem with the monomorphism restriction is that either decision has problems. No monomorphism == annoying defaulting of polymorphic constant, the alternative is unexpected recomputation at runtime
07:50:04 <merijn> They decided that the former (which results in obvious compile time problems) is preferable to silent runtime issues
07:50:20 <hsk3> ok
07:50:22 <merijn> hsk3: Constants are not "technically functions", it's just that values are only evaluated once
07:50:39 <merijn> Eh, s/values/expressions
07:50:41 <Cale> So, the thing is, this polymorphism lets you write things which look like simple constants, but are really functions, and when using them at a particular type, you're implicitly applying those functions to the type class dictionary
07:50:49 <Cale> and so stuff will get recomputed, which you might not want
07:50:54 <merijn> Therefore, once the expression is evaluated it doesn't make sense to reevaluate it
07:51:06 <Cale> So, that's the up-side of the monomorphism restriction, it prevents you from shooting yourself in the foot in this particular way
07:51:22 <hsk3> interesting
07:51:44 <reactormonk> Where can I find an exact definition of what a typeclass is?
07:51:59 <merijn> hsk3: And to preempt a common misconception indicated by "technically functions"
07:51:59 <Cale> reactormonk: Well, the Haskell Report does a pretty decent job of that
07:52:08 <merijn> @google Conal Elliot everything is a function
07:52:10 <lambdabot> http://stackoverflow.com/questions/6913093/confusion-about-function-composition-in-haskell
07:52:10 <lambdabot> Title: Confusion about function composition in Haskell - Stack Overflow
07:52:11 <Cale> reactormonk: How exact do you need?
07:52:17 <merijn> eh, wrong link >.<
07:52:32 <merijn> hsk3: This one: http://conal.net/blog/posts/everything-is-a-function-in-haskell
07:52:39 <hsk3> ok will read
07:53:04 <conal> merijn: two "t"s, please.
07:53:26 <reactormonk> Cale, I'm not too sure. I'll start with less excat for starters.
07:53:40 <Cale> reactormonk: Well, I can give you a quicker version...
07:53:46 <reactormonk> Cale, go on
07:53:50 <merijn> conal: I normally get it right >.>
07:53:55 <Cale> reactormonk: Are you already familiar with type variables?
07:53:59 <conal> merijn: thanks.
07:54:09 <Cale> reactormonk: Like, what occurs in types such as length :: [a] -> Int
07:54:14 <Cale> and  reverse :: [a] -> [a]
07:54:22 <conal> http://conal.net/blog/posts/everything-is-a-function-in-haskell
07:54:36 <reactormonk> Cale, what additional properties do type variables have over generics?
07:54:36 <Cale> We don't care about which type 'a' is in these functions, so they can work with any type 'a' we choose.
07:55:43 <Cale> "Generics" is a term that's often used for the sort of polymorphism that type variables give you in languages like Java and C++. We tend to use the term generics to mean something different, but yeah...
07:56:07 <reactormonk> so it's the same concept, just a term shift?
07:56:22 <Cale> But be careful: when we have something like [a] -> [a] -- the function isn't allowed to discriminate or determine which type a actually is.
07:56:36 <Cale> Whereas in Java you can tell which type of object you actually got.
07:57:03 <merijn> reactormonk: Well, in Java you need to distinguish between polymorphism due to subtyping and generics, but there is no subtyping in haskell
07:57:10 <Peaker> In Java, "a" is: (Typeable a, Hashable a, Eq a) => a   (or is it Ord?)
07:57:32 <Peaker> Haskell kinda-sorta has subtyping via class constraints :)
07:57:36 <Cale> Peaker: reactormonk doesn't know what type classes are yet, so that's going to be meaningless to him
07:57:47 <Cale> Peaker: I'm just about to introduce him :)
07:57:47 <Peaker> ah, was replying out of discussion context
07:57:52 <Peaker> sorry :)
07:57:57 <reactormonk> Cale, ok, so I know what type variables are. Go on.
07:58:08 <Cale> reactormonk: All right, so consider something like sort
07:58:15 <reactormonk> Needs an Ord.
07:58:20 <Cale> Indeed!
07:58:41 <Cale> We'd like our sorting algorithm to work on many types of list, and not have to implement merge sort over and over
07:58:58 <Cale> But there are many types on which it's not meaningful to compare for ordering
07:59:10 <Cale> So we'd like a way to constrain which types our type variable ranges over
07:59:27 <Cale> to just those for which certain operations have been provided, in this case, ordering operations
07:59:29 <duga> hi, I'd like to ask how can I do differences of two neighbour elements anotherwise than map (-) x:xs xs?
07:59:33 <ChristianS> while i generally like laziness, there is a point in my program where i would like to ensure that a is evaluated before "funcall a". how to i do that?
07:59:42 <duga> is there any better solution?
07:59:49 <RchrdB> duga: zipWith (-) l (tail l) -- ?
07:59:54 <Cale> duga: You mean zipWith (-) xs (tail xs)
07:59:58 <merijn> ChristianS: seq, bang patterns or strictness annotation on datatype
07:59:58 * hackagebot cabal-rpm 0.9.3 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.9.3 (JensPetersen)
08:00:24 <reactormonk> Cale, so you constrain the type variable?
08:00:31 <Cale> ChristianS: funcall $! a  will work if you only need weak head normal form.
08:00:32 <duga> for. example [1,2,3] is will be [2-1, 3 - 2]
08:00:38 <nyuszika7h> r
08:00:47 <Cale> reactormonk: Yeah, so we have  sort :: (Ord a) => [a] -> [a]
08:01:02 <merijn> ChristianS: One example would be "let x = expensiveComputation in x `seq` foo x" <- this will result in both 'x' and 'foo x' being evaluated when you force the result
08:01:03 <ChristianS> Cale: should be sufficient, will try it, thanks
08:01:06 <Cale> reactormonk: Ord here is a type class. We introduce new type classes using class declarations which look like this:
08:01:09 <Cale> class Ord a where
08:01:15 <pjdelport> ChristianS: What are you trying to do?
08:01:16 <Cale>   (<) :: a -> a -> Bool
08:01:21 <Cale>   compare :: a -> a -> Ordering
08:01:26 <nyuszika7h> hyPiRion: actually I was wrong, it's permutations without repetition. but your code extended with my conditions should work as expected.
08:01:30 <Cale>   ... other operations go here ...
08:01:49 <Cale>   x < y = compare x y == LT
08:01:56 <reactormonk> Cale, why two functions in the class?
08:02:00 <ChristianS> pjdelport: it's just for error checking. evaluating 'a' might trigger an error and i want to see that early rather than later.
08:02:01 <Cale> ^^ default definitions can be provided
08:02:16 <Cale> reactormonk: There are actually several in the case of Ord
08:02:28 <duga> Cale: RchrdB 'zipWith (-) (tail a) a' is what I wanted :>
08:02:30 <duga> thanks
08:02:33 <reactormonk> Cale, and the ones not implemented are just dropped?
08:02:40 <pjdelport> ChristianS: Have you looked at the various exception-handling facilities? There might be a better way to bracket that.
08:02:47 <Cale> I also left out something important... Ord is actually a subclass of Eq, which just means that if you want to write an instance of Ord, you must also provide an instance of Eq in your program.
08:03:00 <pjdelport> ChristianS: Or can the code be changed to signal the error in a better way?
08:03:02 <reactormonk> Cale, so you always have to define compare, and the rest is inferred by default implementations?
08:03:20 <Cale> reactormonk: anything which isn't implemented in an instance will either be left undefined (with a warning), or will use the default implementation in the class declaration
08:03:21 <danilo2_> Hello! Does anybody here know lenses enough that could tell me how can I modify value inside Data.Map using lenses? I want to create something like "addresses.at addr %~ (cid:)" but I get error about some unmatched types connected to Maybe
08:03:22 <Peaker> reactormonk: you can implement either compare or (<) and the rest will follow automatically
08:03:26 <Cale> reactormonk: yeah
08:03:47 <reactormonk> Peaker, don't you have to implement Eq as well?
08:03:56 <Cale> yeah, you also have to implement Eq somehow
08:04:05 <Peaker> You do, I meant in the set of Ord methods
08:04:11 <Cale> and to write the instance, you write:
08:04:16 <Cale> instance Ord MyType where
08:04:20 <Cale>   compare x y = ...
08:04:35 <Peaker> though with non-standard extensions to Haskell, you could have Eq auto-derived from your Ord instance too.. allowing you to just say:  instance Eq a ; instance Ord a where compare ... = ...
08:04:39 <Cale> (maybe doing pattern matching or whatever)
08:04:50 <HeladoDeBrownie> danilo2_, i think you might want (?~) instead of (%~)
08:05:16 <danilo2_> HeladoDeBrownie: As far as I know ?~ is like .~ for maps, so I need something else here
08:05:43 <Cale> Yeah, compare is actually enough to define the Eq operations as well, but when Haskell was standardised, there wasn't a way to handle having defaults which are of a more specific type.
08:06:12 <Cale> So, yeah, these type class things have some really cool properties
08:06:22 <Cale> For one, you can dispatch based on the result types of functions
08:06:24 <Cale> :t read
08:06:25 <Itkovian> after building the platform, should ghc-pkg not show me all the platform's packages?
08:06:25 <lambdabot> Read a => String -> a
08:06:28 <reactormonk> Cale, so you can actually define either (<) or compare?
08:06:35 <Cale> reactormonk: yeah
08:06:36 <merijn> Typeclasses, the billion dollar mistake. Except in the opposite direction of Hoare :p
08:07:00 <reactormonk> Cale, and there's defaults for either of these, you just gotta implement one?
08:07:00 <Peaker> merijn: why a mistake?
08:07:09 <merijn> Peaker: They arose from a misunderstanding :p
08:07:15 <Peaker> ah, heh
08:07:16 <merijn> I think it was Wadler?
08:07:17 <Cale> reactormonk: There's a default implementation for compare which uses (<=) actually
08:07:23 <HeladoDeBrownie> danilo2_, kay, not sure then. i just remember using one of the ? operators for things involving Maybe
08:07:23 <Peaker> what was the misunderstood worse thing?
08:07:31 <jtanguy> danilo2_: have you tried asking #haskell-lens ? they might be a better place for a lens-related question
08:07:33 <Cale> and then the defaults for (<=), (<), (>=), (>) all use compare
08:07:38 <merijn> He misinterpreted a solution to overloading numerics problem and ended up with typeclasses :p
08:07:43 <Cale> and then there are defaults for max and min which use (<=)
08:07:48 <danilo2_> HeladoDeBrownie, jtanguy: ok thank you, I will ask at haskell-lens :)
08:07:49 <reactormonk> Cale, so circular dependency hello?
08:08:00 <Cale> reactormonk: Yeah, but it's only circular if you provide nothing.
08:08:05 <Peaker> so you need to define (<=) and not (<), yuck :)   at least with MINIMAL pragma, it's not going to cause a silly infinite loop
08:08:12 <merijn> reactormonk: It results in infinite recursion, yes
08:08:17 <Cale> reactormonk: when you define (<=) or you define compare, you break the circle :)
08:08:33 <Peaker> if you define (<) you get an infinite loop at runtime though, eww!
08:08:33 <merijn> reactormonk: Since 7.8 we have a MINIMAL pragma and GHC will complain if you don't implement a "minimal subset" for a typeclass
08:08:49 <Peaker> MINIMAL saves the day
08:09:00 <Peaker> though it would be nice not to have so many methods inside the class in the first place
08:09:02 <Cale> Peaker: Yeah, it's important to be careful about what the minimal complete definitions consist of, which is why the new pragma is nice :)
08:09:09 <reactormonk> Peaker, interesting
08:09:13 <Cale> I think having all this stuff in the class makes sense
08:09:21 <Cale> Maybe you could remove max and min
08:09:23 <Peaker> Just have "compare" itself, nothing else
08:09:41 <reactormonk> Cale, https://github.com/haskell/haskell-report that's the haskell report?
08:09:42 <Cale> But sometimes there are more efficient means of computing the rest?
08:09:43 <Peaker> or just have <=
08:09:54 <Cale> reactormonk: The source for it, yeah
08:09:54 <Peaker> Cale: REWRITE rules, INLINE, would cover it?
08:10:05 <Cale> https://wiki.haskell.org/Language_and_library_specification
08:10:09 <Cale> https://www.haskell.org/onlinereport/haskell2010/
08:10:11 <Peaker> Cale: why not put "sort" in the class too then? :P
08:10:21 <reactormonk> Cale, I can run make just fine :-)
08:10:24 <Cale> Peaker: True, you have to draw the line somewhere
08:10:34 <Peaker> I'd draw it after 1 method :)
08:10:39 <Cale> reactormonk: Well, why, when you can just visit the website? :)
08:11:02 <Peaker> and try to optimize everything properly rather than a small subset of priveleged functions
08:11:04 <reactormonk> Makefile:197: recipe for target 'haskell.pdf' failed
08:11:06 <reactormonk> :-/
08:11:20 <Cale> Peaker: I suppose rewrite rules didn't exist back when Ord was defined
08:11:42 <nyuszika7h> shad
08:11:45 <nyuszika7h> oops
08:13:00 <Cale> reactormonk: Do you have pdflatex installed? You also need a bunch of additional packages...
08:13:16 <Cale> reactormonk: They're listed in the readme... but you could also just get the precompiled PDF :P
08:13:18 <reactormonk> Cale, yeah, it created the pdf. The pdflatex didn't like all of it
08:13:49 <Cale> https://www.haskell.org/definition/haskell2010.pdf
08:14:22 <Cale> reactormonk: So, yeah, I was going to say...
08:14:48 <Cale> reactormonk: One thing you might find surprising is how this lets us determine which implementation of a function to use based on the type of result which is demanded of it
08:14:52 <Cale> like is the case with read
08:14:53 <Cale> :t read
08:14:54 <lambdabot> Read a => String -> a
08:15:01 <Cale> > read "123" :: Double
08:15:02 <lambdabot>  123.0
08:15:06 <Cale> > read "123" :: Integer
08:15:07 <lambdabot>  123
08:15:11 <Cale> > read "123" :: Complex Float
08:15:13 <lambdabot>  *Exception: Prelude.read: no parse
08:15:19 <Cale> > read "123 :+ 0" :: Complex Float
08:15:20 <lambdabot>  123.0 :+ 0.0
08:15:29 <Cale> > read "[1,2,3]" :: [Integer]
08:15:30 <lambdabot>  [1,2,3]
08:15:34 <Cale> > read "[1,2,3]" :: [Float]
08:15:35 <lambdabot>  [1.0,2.0,3.0]
08:16:07 <Cale> > read "([1,2,3],42,'c')" :: ([Integer],Double,Char)
08:16:08 <lambdabot>  ([1,2,3],42.0,'c')
08:16:11 <hodapp> when I had an entire module relying on another module, and that latter module became something that I needed to parametrize over, is there some pattern that is common to follow?
08:16:35 <hodapp> right now I've been having to add an argument to every function to parametrize over a record (which received the contents of the old module)
08:16:45 <Cale> Which parser to use is selected based on the type required, and there are instances of the Read type class for lists and tuples which depend on the instances needed for the elements.
08:16:49 <merijn> hodapp: Sadly not yet
08:16:53 <reactormonk> Cale, what additional properties do typeclasses have over traits (scala ones, where you can have actual code in there)? So far, I've seen return type overloading (see Read) and minimal
08:16:58 <merijn> hodapp: Backpack is supposed to tackle things like that
08:17:08 <Cale> reactormonk: I don't know Scala all that well
08:17:12 <merijn> reactormonk: Multi parameter typeclasses
08:17:23 <reactormonk> Cale, traits are basically interfaces, except they can contain code
08:17:31 <reactormonk> ... if you know Java interfaces
08:17:31 <Cale> okay
08:17:35 <merijn> reactormonk: "class Convert a b where convert :: a -> b" "instance Convert Int String where convert = show"
08:17:40 <hodapp> merijn: backpack?
08:17:48 <merijn> reactormonk: i.e. you can dispatch on more than one type at the same time
08:17:58 <Cale> another subtle one:
08:18:01 <Cale> :t (+)
08:18:01 <lambdabot> Num a => a -> a -> a
08:18:02 <merijn> hodapp: See these posts: http://blog.ezyang.com/category/haskell/backpack/
08:18:16 <hodapp> merijn: and is this the sort of thing that makes people say that OCaml's module system is better?
08:18:18 <Cale> The type of (+) here insists that the two arguments and the result all have the same type
08:18:33 <Cale> I'm not sure if you can say that with interfaces, but perhaps you can in newer Javas
08:18:34 <reactormonk> merijn, multiple type variables? Yeah, traits can do that
08:18:38 <merijn> hodapp: Yes
08:18:44 <Cale> (and maybe you can with traits?)
08:18:48 <reactormonk> Cale, yeah, can do that with traits.
08:19:00 <hodapp> merijn: good to know.
08:19:02 <merijn> hodapp: Ocaml has parameterisable modules like that, backpack is intended to copy from that
08:19:09 <hodapp> merijn: thanks.
08:19:25 <hodapp> for now I'll parametrize over records, bang my head into a wall because I should have had things parametrized to the start, and read about backpack.
08:19:31 <Cale> reactormonk: So, by knowing the type of the result of the addition, we can infer the types of the arguments and vice-versa, which is pretty convenient.
08:19:32 <merijn> But don't expect backpack until 7.14 or something
08:19:41 <reactormonk> Cale, I see
08:19:59 <Cale> reactormonk: Another thing we can do is have type classes with more than one type parameter, so providing some sort of relationship between two or more types
08:20:38 <Cale> reactormonk: and we can add functional dependencies to that, saying that if you know some of the types, then the others will be uniquely determined (which turns out to be important for inference and avoiding ambiguity)
08:21:09 <reactormonk> Cale, so you can create transformers between types?
08:21:17 <Cale> That actually gives you enough to do computation in the type system, though it's all weird and Prology and best not abused :)
08:21:33 <Zekka> (fundeps saying things like: for class Foo a b | a -> b -- each a is uniquely associated with just one b, although some bs might be associated with more than one a)
08:21:44 <merijn> I find type families much more natural than fundeps, tbh
08:21:53 <merijn> They allow for more straightforward computation too
08:21:56 <reactormonk> Zekka, useful for? hash functions?
08:22:11 <Cale> Like,  class VectorSpace f v | v -> f where scalarMultiply :: f -> v -> v; add :: v -> v -> v
08:22:19 <Zekka> reactormonk: I mean, hypothetically you could in some way relate this to hash functions, but I don't see an obvious way to
08:22:45 <Zekka> Think of Cale's example, which relates a vector space type to its scalar type
08:23:28 <scott> is using fundeps equivalent to associated types, or are there other differences?
08:23:37 <Zekka> You can also imagine a typeclass relating representations of i.e. 3D points to their components -- although that's not a very good example, because generally you'd just use a parametric type for this
08:23:45 <Cale> Or perhaps you have a database library, and you have a class of operations abstracted over the DB connection type
08:24:08 <tdammers> hmm, am I the only one who thinks that a MultiParamTypeclasses version of various operators like (*) would be useful?
08:24:15 <Cale> and then you have some way of initialising the connection which will rely on some type of input which varies in type based on which DB connection type you're using
08:24:34 <Cale> tdammers: Everyone thinks it'd be useful until they try it
08:24:46 <Zekka> tdammers: The type errors can get a little scary when you do that
08:24:46 <tdammers> right
08:24:47 <Cale> tdammers: and then it becomes clear why it's horrid :)
08:24:55 <tdammers> hum
08:25:21 <tdammers> reason why I'm thinking this is because I've done similar things in C++, and they turned out quite useful and mostly The Right Thing
08:25:22 <merijn> scott: I'm not sure there's an answer to that question :)
08:25:23 <rasen> Should I read Haskell Language Report or it isn't worth it?
08:25:36 <Cale> rasen: Eventually every Haskell programmer ought to
08:25:45 <merijn> scott: They can be used to tackle a lot of the same problems, but I dunno if there's things either can do the other can't
08:25:49 <tdammers> but then, my recent experiences with MultiParamTypeclasses tells me it might indeed end up unpleasantly
08:25:58 <Cale> It's not a very gentle way to introduce yourself to the language, but there's a lot of good details in there
08:25:59 <merijn> rasen: If only because the Report is one of most readable/best written language specs around
08:26:09 <Cale> which you likely won't get from most tutorials
08:26:29 <Cale> Who here knows about default declarations? :D
08:26:36 <merijn> rasen: It's very readable and clear, it will probably point out lots of details you didn't know yet and will convince you that it's possible to better than the ISO C standard :p
08:26:44 <rasen> Cale: defaulting?
08:26:44 <merijn> Cale: Type defaulting or default instances? :p
08:26:46 <Cale> You can change the list of types used for numeric defaulting.
08:27:02 <ansible1> I'm using ghc on arm with the arch distro - looks like llvm is too new.  How do I find out which version of llvm to use?
08:27:05 <rasen> Cale: default (Integer, Double) for example?
08:27:09 <Cale> rasen: yeah
08:27:10 <merijn> ansible1: 3.5
08:27:12 <rasen> I know
08:27:39 <Cale> rasen: are you aware of \& in strings? :)
08:27:40 <rasen> I even wrote a blog post about defaulting
08:27:47 <rasen> Cale: nope
08:27:54 <Cale> > length "\SOH"
08:27:54 <ansible1> merijn:  for 7.8.2?
08:27:55 <lambdabot>  1
08:27:58 <merijn> Are you aware of whitespace escaping in strings?
08:27:58 <Cale> > length "\SO"
08:27:59 <lambdabot>  1
08:28:04 <Cale> > length "\SO\&H"
08:28:05 <lambdabot>  2
08:28:06 <sinnsat> ansible1: what do you mean with "too new"?
08:28:17 <steffen> How can I make a datatype 'Foo a = Foo a' but specify that a has to be instance of class Bar?
08:28:22 <Cale> There's an obscure detail for you :D
08:28:23 <merijn> > "look ma! \             \ escapable whitespace!"
08:28:25 <lambdabot>  "look ma!  escapable whitespace!"
08:28:32 <HeladoDeBrownie> steffen, you don't
08:28:44 <rasen> Cale: didn't get what \& means
08:28:44 <ansible1> it says "You are using a new version of LLVM that hasn't been tested yet!".  Then it fails to compile
08:28:45 <Cale> Yeah, and string gaps are something you rarely see used.
08:28:53 <sinnsat> ansible1: which package
08:28:57 <merijn> Cale: Because no one knows about them!
08:29:03 <tdammers> steffen: you don't; instead, you specify that a has to be instance of Bar when defining functions acting upon Foo a
08:29:06 <ansible1> text-1.2.0.4
08:29:16 <HeladoDeBrownie> steffen, that used to be possible but was removed because it turned out to have no purpose
08:29:17 <sinnsat> ansible1: try to compile with -fasm
08:29:28 <steffen> HeladoDeBrownie: mhm, okay, I'll think about it
08:29:28 <sinnsat> ansible1: there are some packages that have problems
08:29:46 <Cale> rasen: It means "nothing", but it can serve as a separator in that case where you want to represent the string which consists of '\SO' followed by 'H'
08:29:52 <sinnsat> e.g. arithmoi
08:29:57 <Cale> > length "\&"
08:29:58 <lambdabot>  0
08:30:11 <scott> rasen: ['\SO', 'H'] is written as "\SO\&H" because "\SOH" is ['\SOH']
08:30:16 <ironChicken> can anyone recommend something to read that explains "Could not deduce (m ~ IO)"
08:30:33 <Cale> I'm not even sure whether there are other examples where you'd need it
08:30:41 <sinnsat> ansible1: cabal install text --ghc-options=-fasm
08:31:03 <ansible1> ah ok, will try.
08:31:21 <merijn> ironChicken: ~ means "type equality"
08:31:24 <Cale> ironChicken: Did you write a type signature for your function which involved the type variable m?
08:31:31 <HeladoDeBrownie> ironChicken, understanding type unification is helpful, but in short it seems like you're most likely using an IO operation where a more general type is expected. if you'd like help addressing the specific error, please post code and full error using lpaste or the like
08:31:32 <Cale> (or action)
08:31:38 <merijn> ironChicken: So GHC is saying "I can't prove that 'm' is IO, but I inferred that it has to be"
08:31:56 <merijn> ironChicken: i.e. it's hard to say without further detail
08:32:06 <merijn> ironChicken: The rest of the error should tell you where 'm' and IO are coming from
08:32:30 <Cale> ironChicken: I am guessing that you gave an explicit type signature which was too polymorphic because it made use of IO actions, but was supposed to work with an arbitrary monad.
08:32:57 <Cale> I mean, the definition of your thing made use of IO actions, but the type signature specified that the monad was anything.
08:33:20 <steffen> HeladoDeBrownie: With which ghc version was that removed? did it require an extension?
08:33:45 <ansible1> sinnsat:  ok that failed in the same way, message is stuff like "Alias must point to a definition\n i8* @"base_GHCziBase_DZCFunctor_static_info$alias"
08:34:02 <ansible1> I get those failures on a lot of libs not just text
08:34:08 <HeladoDeBrownie> steffen, it was a haskell language feature that was removed from the language. i don't know what the relevant ghc version would have been, it seems like it was probably long ago.
08:34:23 <steffen> HeladoDeBrownie: ahh, okay
08:34:33 <steffen> HeladoDeBrownie: Thank you :)
08:35:05 <sinnsat> ansible1: https://ghc.haskell.org/trac/ghc/ticket/9142?cversion=0&cnum_hist=2
08:36:26 <merijn> steffen: It was removed because it didn't do what you probably hope it does
08:36:38 <merijn> steffen: i.e. "I don't want to put typeclass constraint on all my functions"
08:36:47 <merijn> But even *with* that feature you *still* had to
08:37:00 <merijn> Because the underlying theory doesn't allow you to skip that step
08:37:15 <sinnsat> ansible1: are you sure you passed the -fasm option?
08:37:25 <merijn> You can do it with GADTs, but that's most likely still not what you want
08:37:32 <ansible1> yes, I pasted your command line in
08:37:54 <Cale> Well, the thing with GADTs is a lot closer to being what you want.
08:38:23 <Cale> You really can remove the constraint, provided you pattern match :)
08:38:49 <merijn> Cale: It's closer to what he's ASKING for
08:38:55 <merijn> Not closer to what he WANTS :p
08:39:03 <ansible1> so I need 7.10?  or can I downgrade llvm to one that works?  I'm thinking downgrading llvm would be more likely to succeed.
08:39:14 <gentleben> can you set the solver in the cabal config file?
08:39:50 <ansible1> sinnsat:  I'm on ARM so I can't use the native code generator
08:40:34 <steffen> merijn: No, the idea was not to save constraints on fuctions but to make users of this type aware that they have to supply a type that is instance of a specific class! Well it's kind of what you say, but the type goes a long way until it gets handeled by a big big case statement at a completely differtent place, so it would be nice to have the constraint right on the type instead of at this HUGE function which handels
08:40:34 <steffen> statement xD
08:42:54 <sinnsat> ansible1: maybe -fobject-code then?
08:44:05 <ansible1> nope, same error... I thought that there wasn't any native option on arm, only llvm
08:45:17 <sinnsat> ansible1: maybe try ghc HEAD then
08:46:32 <geekosaur> there is still only llvm on arm, you'll need to downgrade your llvm if it can't use it
08:46:35 <marchelzo_> @pl count x = length . filter (==x)
08:46:35 <lambdabot> count = (length .) . filter . (==)
08:47:05 <ansible1> geekosaur:  is there something someplace that says what version works?
08:47:07 <geekosaur> (there are known compatibility issues, you either use an older one or use ghc head and the latest llvm (quite possbly *its* head)
08:47:24 <sinnsat> marchelzo_: please use the pointful version :P
08:47:55 <ansible1> I guess 3.4 is before 3.5 so I could just do that...
08:47:58 <marchelzo_> sinnsat: hah. Yeah I was just wanted to see :)
08:49:12 <geekosaur> ansible1, I recall 3.4 being it but I have more recently heard 3.5 for at least some cases... you might need to ask in #ghc or on the glasgow-haskell-users mailing list
08:49:35 <ansible1> ok thx guys, will have to circle back and try this later today
08:49:38 <geekosaur> I don't actually do any arm work, or use llvm, I just try (and all too often fail, sigh) to keep track
08:49:52 <sinnsat> marchelzo_: I had a pretty nice one from yesterday
08:50:13 <sinnsat> @pl foo (a, b) (c, d) = (a ++ c, b ++ d)
08:50:13 <lambdabot> foo = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (++)) . flip . (((.) . (,)) .) . (++))
08:50:22 <ansible1> yeah I was pleased to see ghci working which is unusual for arm, hopefully the downgrade will be the ticket for actually compiling things
08:50:29 <ironChicken> thanks, merijn, Cale, HeladoDeBrownie. yes, i was trying to write a general Monad function and then call it with an IO action.
08:50:29 <marchelzo_> O_O
08:50:34 <ironChicken> i'll try something different
08:51:09 <marchelzo_> Some things just don't lend themselves to point-free style
08:51:19 <HeladoDeBrownie> ironChicken, you should be able to use it applied to IO, but using IO within its definition doesn't work if you give it a more general type.
08:51:29 <HeladoDeBrownie> marchelzo_, s/some/most/
08:51:46 <marchelzo_> That's true :)
08:53:19 <jtanguy> in ironChicken's case, maybe a (MonadIO m) constraint might work ? with the appropriated liftIO
08:53:27 <enthropy> steffen: I don't think that benefit (of -XDataTypeContexts) was emphasized very much when they decided to remove that feature
08:54:42 <sinnsat> marchelzo_: I wonder if there is a way to express it easier with (***) or somesuch
08:55:04 <sinnsat> afais 'pointfree' doesn't make much use of arrows
08:56:23 <steffen> enthropy: does this has something in common with -XFlexibleContexts ?
08:57:31 <enthropy> https://ghc.haskell.org/trac/haskell-prime/wiki/NoDatatypeContexts
08:57:42 <hodapp> yeesh, it is a drag explicitly parametrizing 30-40 functions that previously just referred to a module.
08:57:55 <hodapp> but I don't suppose Haskell offers any easy way I can just parametrize an entire module.
08:58:11 <hodapp> without something like backpack, at least, which I just heard of an hour or two ago!
08:58:14 <enthropy> they're not related
08:59:19 <hodapp> enthropy: looks to me like they are both ways to get around having to explicitly parametrize everything.
08:59:55 <scott> sinnsat: maybe like this?
09:00:00 <scott> > curry (join (***) (uncurry (++))) ("a", "b") ("c", "d")
09:00:02 <lambdabot>  ("ab","cd")
09:00:07 <scott> :p
09:00:32 <scott> hmm, not quite
09:00:38 <enthropy> hodapp: I mean -XDataTypeContexts is not related to -XFlexibleContexts
09:00:39 <scott> messier than I thought
09:01:06 <enthropy> besides both being about class constraints
09:01:32 <hodapp> enthropy: I'm not sure what -XFlexibleContexts is, and I wasn't saying what I did in reference to what you said
09:02:15 <enthropy> it's an extension that lets you write  f :: Show (a,Int) => (a,Int) -> String; f = show
09:05:17 <sinnsat> scott: then we just need an obscure type signature on top of it that doesn't tell us anything about how many parameters to pass in order to get a value :P
09:06:18 <sinnsat> and we name the function "joinUs"... to make it obvious what it's meant for
09:15:29 <c_wraith> Huh.  hsc2hs totally fails at cross-compiling, doesn't it?
09:17:07 <geekosaur> pretty much, yes
09:17:18 <geekosaur> I think there's a ticket against it?
09:17:54 <geekosaur> currently it only knows how things work on the host system
09:19:31 <hsk3> Is reading the whole Haskell Report something one should do?
09:19:52 <hsk3> has some of you done it?
09:20:01 * hackagebot som 8.0.0 - Self-Organising Maps.  http://hackage.haskell.org/package/som-8.0.0 (AmyDeBuitleir)
09:20:06 <tomphreek> @src liftM
09:20:06 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:20:21 <rasen> hsk3: heh.. Asked the same question an hour ago
09:20:23 <clrnd> hsk3, I do it every night, while I pray to the GHC Gods
09:20:32 <c_wraith> I mean..  the entire execution model of hsc2hs is writing a C program to output haskell source that includes values for the system C compiler.
09:20:39 <hsk3> lol
09:20:47 <Cale> I've done it. I think it's worth doing eventually.
09:20:50 <creichert> hsk3: I would recommend keeping it on hand, with the ghc latest manual. reading chunks of it depending on what you are working on
09:20:54 <creichert> yes, definitely worth it
09:20:59 <tomphreek> instance Monad (RVarT n) where return x = RVarT (return $! x). whas is $!...?
09:21:16 <Cale> f $! x = x `seq` f x
09:21:41 <hsk3> Cale: what would you say are the prereqs?
09:21:43 <hsk3> for readin git
09:21:46 <enthropy> > do do "you know the grammar?"
09:21:47 <lambdabot>  "you know the grammar?"
09:22:05 <tomphreek> Cale: thx
09:22:44 <Cale> hsk3: It's hard to say, but it'd probably be good to be moderately familiar with using the language first. It's not exactly great introductory material.
09:22:53 <hsk3> ok i see
09:25:16 <tomphreek> isn't return $! x is just x `seq` (return x), or return x?
09:25:27 <tomphreek> is the idea to switch monads
09:25:30 <Cale> tomphreek: It's the former
09:25:35 <rasen> @src ($!)
09:25:36 <lambdabot> f $! x = x `seq` f x
09:25:46 <Cale> No, it's just to force the evaluation of x
09:26:13 <Cale> You can have a result of an action which is still an unevaluated expression in memory
09:26:30 <tomphreek> yeah but x `seq` f x evaluates to f x
09:27:01 <pjdelport> > (const 5) undefined
09:27:03 <lambdabot>  5
09:27:06 <pjdelport> > (const 5) $! undefined
09:27:08 <lambdabot>  *Exception: Prelude.undefined
09:27:17 * nitrix wiggles his fingers in the air, listening to techno c:
09:27:30 <Cale> Yes, but it ensures that when you pattern match on f x, that x is evaluated
09:27:52 <clrnd> nitrix, what kind? detroit? hard?
09:27:57 <Cale> Or rather that when you pattern match on (f $! x)
09:28:08 <Cale> See pjdelport's examples
09:28:32 <tomphreek> ok, I get what it does from the example now
09:28:41 <tomphreek> don't quite see why yet, but didn't give it much thought
09:29:03 <Cale> Mostly efficiency. The result of forcing the evaluation might be smaller in memory than the expression
09:29:19 <Cale> Like, if the result is an Int, for example
09:29:30 <pjdelport> tomphreek: The usual reason for using seq and $! is for efficiency: sometimes laziness defaults to delaying too much, when you know for sure that it will get evaluated later anyway.
09:29:36 <Cale> Then it probably takes less space than the expression for computing the Int
09:30:01 * hackagebot casadi-bindings 2.2.0.3 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.2.0.3 (GregHorn)
09:30:49 <tomphreek> interestnig. I don't know why I don't like the idea of having compiler optimisation in the code itself. seems like that's what flags are for usually...
09:31:17 <Cale> Well, the compiler can't always tell what's the best time to compute expressions
09:31:17 <tomphreek> but anway, cheers guys
09:31:25 <Cale> because that's a Hard Problem (tm)
09:31:27 <nitrix> clrnd: I'm not picky. Whatever get the code written :P
09:32:12 <Cale> tomphreek: Moreover, it's hard for the compiler to always know that forcing the evaluation early is *correct*
09:32:24 <nitrix> My first Haskell application is spreading at my company. The code is so disgusting but hey :]
09:32:30 <nitrix> I'm finally solving real problems :D
09:32:33 <Cale> As in cases where you don't need to evaluate that expression, it might cause the program to hang
09:32:39 <pjdelport> nitrix: Working code is the best code. :)
09:32:54 <Cale> tomphreek: and knowing the difference is essentially solving the Halting Problem
09:34:04 <clrnd> nitrix, congrats, my workmates still think haskell is some magic for scientists
09:35:17 <hiptobecubic> nitrix, what does it do?
09:36:42 <moswlks> What is a great project on github that uses haskell?
09:38:29 <clrnd> moswlks, XMonad
09:38:38 <Cale> moswlks: https://github.com/diagrams/diagrams
09:38:41 <moswlks> The window manager?
09:38:54 <moswlks> Didn't know it was written in haskell, how cool
09:39:11 <Cale> http://projects.haskell.org/diagrams/ (the website for the library I linked to)
09:39:36 <Cale> Check out the gallery for some cool examples of its use :)
09:40:04 <moswlks> Will check it out, thanks!
09:40:36 <enedil> hi. I'm a C++/Python programmer (mostly solving mathematical problems, doing stuff for algorithmics contests or simply for mathematical computation). I thik that picking a functional language would help me in my problems. I'm considering Haskell or Lisp. What are reasons to pick one over another?
09:41:07 <Xe> enedil: Haskell will be more practical quicker than lisp
09:41:24 <Cale> enedil: If your goal is to learn functional programming, then Haskell will serve you much better than lisp. Programming in a functional style is possible in lisp, but not necessarily encouraged.
09:41:38 <Cale> (In some lisps, it's encouraged more than in others)
09:42:02 <Cale> Haskell will basically force you to learn how to do it correctly :)
09:42:47 <nitrix> hiptobecubic: You really reaaally really want to know?
09:42:52 <nitrix> hiptobecubic: I must warn you.
09:44:01 <pjdelport> enedil: Coming from Python, you might appreciate Scheme when it comes to the Lisps. But Haskell is probably a much richer reservoir of knowledge, in the long run.
09:44:02 <Cale> Yeah, at the same time, Haskell isn't fractionated into a lot of languages with differing levels of library support and has reached a decent critical mass of libraries where it's starting to see a fair amount of industrial use.
09:44:23 <nitrix> hiptobecubic: It's a fake git.exe windows executable that calls a remote server on a virtual machine to run a real Git on linux. The inputs and output streams are all connected so the local application behaves as if you hate the repository locally.
09:44:25 <enedil> Oh, maybe it's a silly question since it's #haskell, but do you have any link which gives a description or comparision?
09:44:32 <nitrix> hiptobecubic: There's even mapping of windows paths to linux paths.
09:44:57 <nitrix> hiptobecubic: *had
09:45:09 <enedil> pjdelport: I'm more C++ than Python, but it might be a good chioce.
09:45:29 <ttt_fff> so I'm reading https://github.com/jaspervdj/websockets/blob/master/example/server.lhs ... but it's not quite what I want. I want localhost/" to serve a webpage, and "localhost/ws/" to serve websocket
09:45:43 <ttt_fff> what is a good tutorial on how to simultaneously (on a single port) server both webpages + websocket ?
09:45:44 <pjdelport> enedil: Scheme is a lot like Python, under the syntax. Haskell is a substantially different paradigm, and will stretch your brain a whole lot more (in a good way).
09:47:15 <hellofunk> any recommendations for libraries or methods to do logic programming in haskell?
09:48:01 <Cale> hellofunk: Well, there's logict, I don't know if you can exactly call that "logic programming" -- it's not really Prolog-esque, it's just a fast list monad with some utilities, pretty much.
09:48:40 <Cale> There are some libraries for constraint logic programming in Haskell, but I haven't really tried them enough to know what's good.
09:49:07 <Cale> http://hackage.haskell.org/package/cflp looks interesting
09:49:27 <Cale> but it also doesn't look very well-documented :)
09:49:55 <creichert> ttt_fff: have you seen: https://github.com/yesodweb/wai/blob/master/wai-websockets/server.lhs
09:50:54 <Cale> http://hackage.haskell.org/package/csp-1.0/docs/Control-Monad-CSP.html might be relevant
09:51:52 <ttt_fff> creichert: nice, looks like exactly what I need, thanks!
09:52:36 <Yuras> ttt_fff: also https://hackage.haskell.org/package/websockets-snap
09:57:05 <creichert> yea, that's a really good example as well
10:04:35 <fresheyeball_> hey haskellers
10:04:50 <fresheyeball_> in CT
10:04:55 <fresheyeball_> are Booleans monoids?
10:05:36 <shachaf> A monoid isn't just a type, it's a type and some extra things.
10:05:39 <sinelaw> In subtyping parlance of polymorphic types, do we say (forall a. a)  <  a   or the other way around?
10:06:02 <sinelaw> sorry, forall a. E[a]
10:06:17 <Procian> fresheyeball: Booleans are a monoid under conjunction and disjunction, but that's not CT.
10:06:25 <sinelaw> the foralle'd type can be safely 'coerced' into the not-foralled type. so which is the subtype?
10:06:32 <Benzi-Junior> hey is there a clever way to map characters to numbers alphabetically without just inluding the alphabet as a constant string and checking where they occur ?
10:07:33 <Procian> sinelaw: Like, there's a map from (forall a. a) -> b for any b?
10:07:43 <Procian> (a canonical one)
10:08:06 <sinelaw> Procian, all you need to do is instantiate the quantified a to whatever b you want
10:08:07 <Procian> Benzi-Junior: Just use ord.
10:08:26 <bennofs> > fromEnum 'B' - fromEnum 'A' -- works only for ASCII letters
10:08:28 <lambdabot>  1
10:08:28 <Procian> sinelaw: Yeah. (forall a. a) is the logicall uninhabited type.
10:08:37 <Benzi-Junior> Procian: ye just found that seems to be what I want
10:08:53 <sinelaw> Procian, that was a bad example - I meant to say any quantified type with structure forall a. E[a]
10:09:01 <sinelaw> is it considered a subtype of just E[a]
10:09:27 <sinelaw> or E[b], matters not
10:10:07 <mniip> [21:05:32] <bennofs> > fromEnum 'B' - fromEnum 'A' -- works only for ASCII letters
10:10:13 <sinelaw> I think that since wherever you expect a E[b], it's ok to instantiate a forall a. E[a] and pass that, therefore  in some sense the rank-1 type is a subtype of the rank-0 one
10:10:27 <mniip> > fromEnum 'ы' - fromEnum 'ъ'
10:10:29 <lambdabot>  1
10:11:24 <Procian> sinelaw: I'm not sure you want to think at all about subtyping on this. But if F is a functor, than (forall a. F a) can be sent to any F b.
10:11:24 <bennofs> Oh, I just meant that idk if it works for non-ascii letters (i don't know how "alphabetically sorted" is defined for non-ascii letters)
10:11:46 <sinelaw> Procian, ok! that's a nice way to think about it.
10:12:03 <mniip> bennofs, Enum Char isn't alphabetically sorted
10:12:06 <mniip> it's unicode
10:12:35 <bennofs> mniip: but it works if you like to alphabetically sort ASCII characters
10:12:55 <mniip> wouldn't that just be ['\0'..]
10:14:04 <mniip> fresheyeball, Data.Monoid defines 2 newtypes for Bool, one is a monoid over &, another over |
10:14:45 <mniip> All and Any
10:18:31 <ezrios> I am using Happstack and Data.Aeson to communicate via JSON
10:18:59 <ezrios> currently I am just using decodeBody and look statements in a ServerPart monad to get at key/value pairs in JSON sent by the client
10:19:05 <ezrios> is it possible to just get the JSON as a ByteString?
10:20:05 * hackagebot horizon 0.1.0 - Sunrise and sunset UTC approximations from latitude and longitude coordinates  http://hackage.haskell.org/package/horizon-0.1.0 (intractable)
10:20:07 <danilo2> Hello! :) I was fighting with this issue for over 2 days now and I would love to ask you for help. I'm trying to connect 2 computers with cloud haskell. I've read all the docs, still I did not found the one simple function, that would allow me to get NodeID of a remote node over TCP transport. Is here anybody who knwos CH? I was asking on CH irc channel but without any response :(
10:22:52 <geekosaur> I think you need to find a CH list or something. the times it's come up on haskell-cafe people have been redirected elsewhere, iirc
10:24:44 <clrnd> or ask in #erlang, they will tell you how they do it, I bet it's close enough
10:26:31 <danilo2> geekosaur, clrnd: I've asked on #haskell-distributed but Ive got no response for 2 days. I think asking in #erlang does not make sense - I knwo how they do it - they estabilish a connection between remote nodes based on haskell's stati values. The problem is how to establish it using CH :(
10:29:30 <mmachenry> danilo2: Can you pastebin your code to lpaste.net? The smaller the better. Try to create a minimal failing example.
10:31:17 <danilo2> mmachenry: heh, that would be good if I could paste a minal example in this case. Look, the tutorial (http://haskell-distributed.github.io/tutorials/1ch.html) shows 3 liner: http://lpaste.net/120043 showing how to create LocalNode. I just want to send messages to a remopte node knowing it's address.
10:31:55 <danilo2> mmachenry: This tutorial (on the other hand) : http://haskell-distributed.github.io/tutorials/tutorial-NT2.html shows EXACTLY this, but using thhe Transport.TCP API and not cloud-haskell processes
10:32:23 <danilo2> mmachenry: I just need a function, that would just "connect" to a node given its address.
10:33:20 <Cale> danilo2: I've never used CH yet, but I think you use  startMaster :: Backend -> ([NodeId] -> Process ()) -> IO ()
10:34:04 <Cale> Oh, this is simplelocalnet, btw
10:34:24 <danilo2> Cale: yep - but you need these NodeID's - and you have to optain them somehow - that's the problem
10:34:35 <Cale> That gives you the list of NodeIDs
10:34:47 <Cale> You don't provide them, you provide a function which takes them
10:34:51 <danilo2> Cale: nevermind - the api is simmilar - you can connect if you know the NodeID ...
10:35:10 <Cale> right?
10:35:31 <Cale> you write the function of type  [NodeId] -> Process ()
10:35:37 <danilo2> Cale: hmm, ok - this is localnet's api - It has got node discovery routine built-in
10:35:38 <Cale> and then pass that to  startMaster
10:35:49 <Cale> and it finds the nodes
10:35:50 <joneshf-laptop> what tools are there for code complexity that will actually install today?
10:36:12 <joneshf-laptop> most of the executables on hackage are too out of date to be installable
10:36:19 <joneshf-laptop> least, the ones I've found so far
10:36:45 <joneshf-laptop> or software metrics in general
10:38:02 <danilo2> Cale: the problem is that I don't need the localnet's package, because I've got different machines here, but wait a moment, I've got to check something
10:38:48 <Cale> danilo2: There are other backends, but you want to make sure you're using a backend proper. You're not really meant to use the transports directly.
10:39:00 <Cale> (though I guess you probably could)
10:39:27 <ejbs> Is Control.Monad.Cont equivalent to Scheme's continuations?
10:39:44 <johnw> ejbs: they are not global like in Scheme
10:40:04 <ejbs> johnw: So not 'full-extent'?
10:40:06 <johnw> i.e., the continuation that you capture is within the Cont execution, it's not the continuation for the rest of the Haskell program
10:40:22 <Cale> They're only global up to the runCont which is running the computation you've constructed
10:40:30 <hsk3> Cale: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4
10:40:30 <hsk3> What is meant by ∀ u. cx  ⇒  t notation?
10:40:39 <danilo2> Cale: yeah I could use transports directly (even without CH of course) but for now I do not know how to connect them. Right now I just found distributed-process-client-server library! Ouch, why I havent seen it before? I will try to utilize it somehow!
10:40:45 <hsk3> For all, u vector . cx => t
10:40:49 <hsk3> is . inner product?
10:40:51 <hsk3> what's cx?
10:40:58 <ejbs> Cool, thanks. It's still pretty awesome that you can do that w/ Haskell
10:41:09 <Cale> hsk3: . is just punctuation to separate the forall bound variables from the rest of the type
10:41:18 <geekosaur> . is just a separator there. forall vars . contexts => type
10:41:18 <johnw> ejbs: continuations are just functions passed to functions which do something on the value "produced" by that function
10:41:22 <Cale> cx is a class context
10:41:39 <johnw> ejbs: Yoneda lemma shows that any function is equivalent to its CPS-transformed version, so it's a pretty universal concept
10:41:48 <Cale> and => is the => which occurs in types to separate the class context from the type expression whose variables it constrains
10:42:25 <Cale> hsk3: Basically, what they're getting at is that you shouldn't write things like  Ord a => [Int]
10:42:31 <ejbs> johnw: Yeah, I know. Well, I kinda know, I regularly forget details about continuations haha. Thanks anyway, very helpful :)
10:42:35 <johnw> what makes them magical in Scheme in that the function passed closes over such a truly global context
10:42:39 <Cale> hsk3: Where you constrain some type variable, but then don't use it
10:43:21 <hsk3> Cale: yeah because it makes it ambiguous
10:43:24 <johnw> but the Cont monad in Haskell is nothing magical at all; it's literally just a type wrapper for a function that takes a function :)
10:43:42 <Cale> hsk3: While it seems silly because you wouldn't usually write that by hand, such types can occur as the result of inference, which means that there's an ambiguity that can't be resolved
10:43:44 <johnw> the behavior of this wrapper as a Monad is usually what throws people for a mental loop
10:43:55 <hsk3> ok
10:44:17 <hsk3> Cale: and what is "class context"?
10:44:43 <Cale> hsk3: The whole list of constraints, like (Ord a, Ord b, Show a) or something
10:44:49 <hsk3> Cale: ah, so in Ord a,    a is in the u,   Ord is the class context?
10:45:07 * hackagebot git-annex 5.20150205 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150205 (JoeyHess)
10:45:07 <Cale> The class context is the whole list of constraints
10:45:17 <Cale> and yeah, the variables are all in the u vector
10:45:28 <voidzero> Does anyone here work with OVH's API using Haskell?
10:45:31 <Cale> The foralls are usually left implicit
10:45:39 <Cale> But with extensions turned on, GHC will print them
10:45:49 <Cale> (or if they actually matter)
10:45:52 <Cale> :t runST
10:45:53 <lambdabot> (forall s. ST s a) -> a
10:46:09 <Cale> If the forall is inside of a function argument it needs to be explicit, for example
10:46:36 <Cale> But any variables which aren't explicitly forall'd will be automatically forall'd at the top of the type signature
10:46:41 <dmwit> ?tell EvanR I know of no such pure Haskell GUI library efforts.
10:46:41 <lambdabot> Consider it noted.
10:46:47 <Cale> Like, when you write  map :: (a -> b) -> [a] -> [b]
10:46:57 <Cale> it means  map :: forall a b. (a -> b) -> [a] -> [b]
10:47:43 <dmwit> ?tell EvanR Unless threepenny counts, I guess.
10:47:43 <lambdabot> Consider it noted.
10:48:16 <hsk3> Cale: thanks, useful
10:48:38 <hsk3> i assume this notation is explained earlier in the report
10:50:43 <Cale> hsk3: Hopefully :D
10:50:48 <hsk3> heh
10:51:04 <Cale> hsk3: Some stuff is a little open-ended, because there's a whole culture of type theory and such
10:51:35 <hsk3> ok
10:52:12 <Cale> It's sort of aimed at the people who would be implementing Haskell to help them get their implementations compatible with other ones
10:52:32 <Cale> But also advanced Haskell programmers who probably know a fair amount themselves.
11:00:36 <dfeuer> I see that there is an io-streams package. How does that relate to things like pipes and conduit?
11:01:52 <michaelt> dfeuer: it's a competing project, associated with Snap
11:01:58 <Luke> dfeuer: io-streams is in the IO-monad so it simplifies the stack
11:02:03 <dfeuer> Urk.
11:02:21 <Luke> snap uses io-streams for performance but there's no snap deep in io-streams
11:02:36 <ezrios> hnnnng
11:02:37 <bitemyapp> io-streams is the slowest streaming library
11:02:42 <ezrios> I thought I understood monad transformers
11:02:45 <bitemyapp> slapping IO on everything is not simpler
11:02:50 <ezrios> until I actually had to use them for something nontrivial
11:02:50 <michaelt> right, I just meant it was the same crowd
11:02:51 <dfeuer> It seems like the path toward a coherent story of "how to do things in haskell" we're getting a whole huge different bunch of different ways.
11:03:25 <Luke> dfeuer: gabriel, the guy behind pipes, was a big author of io-streams
11:04:07 <bitemyapp> Luke: what is that supposed to mean?
11:04:08 <csd_> Would someone please take a look at my failing floating - point Parsec parser? https://www.refheap.com/96964
11:04:25 <Luke> dfeuer: it's definitely simpler being in IO by default if you're using enumerator type stuff for handling IO and it has the potential to be faster because you're not dealing with a huge transformer stack to handle exceptions and resource cleanup
11:04:46 <bitemyapp> Luke: IO is not simpler than a pure datatype.
11:04:55 <Luke> yes it is
11:04:59 <bitemyapp> Luke: infacilities with monads or monad transformers is not about simplicity
11:05:01 <bitemyapp> it's about UX.
11:05:07 <bitemyapp> IO is a very big datatype, it is not *simple*
11:05:10 <bitemyapp> the word you want is facile
11:05:16 <bitemyapp> or, "requires less knowledge of Haskell"
11:05:29 <bitemyapp> when you use the word simple, think carefully about what you're saying.
11:05:36 <bitemyapp> it's not a generic feel-good term for software
11:05:39 <Luke> i mean what I said
11:05:56 <dmj`> bitemyapp: please be kind, your tone is condescending
11:06:06 <Luke> io-streams is simpler if you're dealing with IO
11:06:10 <dfeuer> bitemyapp, newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
11:06:16 <dfeuer> That's pretty small :-P
11:06:22 <Luke> dfeuer: what are you looking to use it for?
11:06:28 <bitemyapp> dfeuer: no, it's not.
11:06:39 <bitemyapp> the range of things it permits is vast.
11:06:45 <dfeuer> Luke, mostly I'm trying to figure out what things I should be trying to learn ...
11:07:06 <Luke> dfeuer: yeah I recommend writing some stuff with pipes and io-streams both. that's what I did starting with enumerators, conduits, pipes, then io-streams
11:07:10 <bitemyapp> dmj`: this sort of thing is why I stay away from Snap/io-streams/etc
11:07:19 <bitemyapp> dmj`: and prefer Happstack/Pipes, Yesod/Conduit, etc.
11:07:27 <Luke> dfeuer: i found most of my enumerator-type code was all IO based so it simplified a ton to use io-streams because then you can use bracket etc
11:07:45 <csd_> Would someone please take a look at my failing floating - point Parsec parser? https://www.refheap.com/96964
11:08:12 <bitemyapp> csd_: toss some examples in there. Working code. That sort of thing.
11:08:21 <csd_> it won't compile
11:08:32 <bitemyapp> csd_: well, that function alone isn't the only thing in your module.
11:08:34 <clrnd> csd_, what's the error message
11:08:42 <bitemyapp> error message if it's not building too
11:08:43 <csd_> it's a fuckshow of error messages
11:08:47 <csd_> ok one sec
11:08:52 <bitemyapp> and you're showing none of them :P
11:11:07 <csd_> bitemyapp-- https://www.refheap.com/96965
11:11:31 <bitemyapp> csd_: don't point it at me, I'm just getting you to fix things such that anybody could help you.
11:11:42 <bitemyapp> csd_: that's still not the whole module.
11:11:46 <nkar> I have two things: 'm (Either x (Maybe a))' and 'm (Either x (Maybe b))'.  what's the painless way to combine them to get this type: 'm (Either x (Maybe (a,b)))' where m is a monad?
11:11:46 <jstolarek> orzo: sorry for late late reply. I just spoke with Rochard and he says you need to use %~ equality: case a %~ b of { Proved Refl -> Right b; Disproved -> Left a }
11:11:47 <bitemyapp> csd_: show your imports, the rest of the file.
11:12:27 <csd_> bitemyapp: normally i try to limit things to the affected code, as people's eyes glaze over if you give them too much
11:12:36 <Luke> dfeuer: have you used any other enumerator abstractions before?
11:14:07 <nkar> okay, I'll ask on the lens channel.
11:14:58 <csd_> ok full code dump https://www.refheap.com/96966
11:19:35 <dfeuer> Luke, no, I've not used such. The documentation seems a bit intimidating.
11:20:23 <Luke__> dfeuer: there's kinda two levels of usage. 1) is just using the combinators and things that already exist for you (like folds and maps). 2) is making your own new pipe/stream components which is a bit more involved
11:20:58 <Luke__> dfeuer: I think the real benefit in streams is making some of the implicit nature of lazy IO explicit and managed with streams
11:21:32 <dfeuer> Hmm.
11:21:43 <Luke> dfeuer: since the biggest utility for me is IO, using a streaming library structured around IO (io-streams) simplifies a lot of code
11:22:02 <Luke> dfeuer: a lot of the complexities in the types for pipes et al are in the resource management and error handling etc
11:23:20 <dfeuer> Well, those are kind of important. If I can't understand those, how am I supposed to use the libraries?
11:23:39 <Luke> dfeuer: here's some of the early justification for io-streams: http://snapframework.com/blog/2013/03/05/announcing-io-streams
11:24:12 <Luke> dfeuer: good question. in io-streams you use the normal IO handling mechanisms for resource and error management (bracket, etc)
11:24:26 <Luke> in conduits, you use another monad transformer called ResourceT
11:25:05 <C-Keen> I have utf8-string-1 installed which removed System.IO.UTF8. The version before (0.3.8) still has that which another package depends on. So I installed that version specifically and cabal info lists two versions. Now I get the message that the said module is available in 0.3.8 which is hidden. How do I "unhide" it (or deinstall the newer version)?
11:25:39 <michaelt> in pipe, there is a corresponding 'SafeT' transformer, though one can use ResourceT as well
11:25:42 <Luke> dfeuer: http://stackoverflow.com/questions/9983840/what-are-the-pros-and-cons-of-enumerators-vs-conduits-vs-pipes/11507598#11507598 haha i see you read some of my early questions about all this
11:26:14 <michaelt> C-Keen: ghc-pkg unregister will unregister it
11:26:37 <michaelt> ghc-pkg expose blah-blah will expose it; ghc-pkg hide blah-blah will hide it
11:27:28 <ezrios> I don't understand MaybeT's bind operation
11:27:37 <ezrios> does it not allow you to "unwrap" the inner value inside a Maybe?
11:28:00 <ezrios> I have a function "unBody :: RequestBody -> ByteString"
11:28:29 <ezrios> and I have a MaybeT statement `reqBody <- lift $ takeRequestBody req`
11:28:40 <Cale> ezrios: The idea is just to stop computing on the first failure
11:29:09 <ezrios> where `takeRequestBody req :: (MonadIO m) -> m (Maybe ReqBody)`
11:29:14 <michaelt> Luke: Oh  I this is about pipes-3; that was impossible to follow ...
11:29:30 <Luke> michaelt: the link i posted?
11:29:32 <ezrios> Cale: right, but how do I operate on the wrapped Maybe value?
11:29:33 <Cale> ezrios: I think you likely want something other than lift in that case
11:29:39 <C-Keen> michaelt: thanks!
11:29:40 <Cale> Because you already have a Maybe
11:29:45 <clrnd> csd_, hey I found out your mistake
11:30:05 <Cale> ezrios: Which MaybeT are you using?
11:30:06 <michaelt> Luke: yeah, oh I meant your own response to the question
11:30:14 <Cale> ezrios: Probably you want to apply the MaybeT data constructor
11:30:31 <Cale> MaybeT :: m (Maybe a) -> MaybeT m a
11:30:31 <ezrios> Cale: http://lpaste.net/120046
11:30:41 <ezrios> oh wait
11:30:45 <Cale> ezrios: I mean, from which package?
11:31:14 <ezrios> Cale: I'm an idiot, I should have just used the MaybeT constructor
11:31:16 <ezrios> thanks
11:31:18 <ezrios> that was a lightbulb moment
11:31:30 <clrnd> csd_, you were doing something like `return $ Float (m String)` and the parser expects `m LispVal`, you need to map the `(Float fst . head..)` over the `int <*> digit` parser
11:31:53 <michaelt> Luke: I just meant, this is when there was the complicated business about 'Frames' and so on.
11:32:08 <clrnd> csd_, so it ends up like `Float . fst . head . parseFloat <$> (the rest)`
11:32:31 <Luke> michaelt: ah yeah totally
11:38:44 <C-Keen> michaelt: hm, that didn't help. I have worked around it by specifying the version in the .cabal file of the dependency for now
11:39:02 <C-Keen> michaelt: thanks for the help though!
11:39:48 <michaelt> C-Keen: wait, maybe I should have mentioned the version number can be used? Or is this a sandbox? ' ghc-pkg list ' tells you what it sees
11:40:00 <athan> In the untyped lambda calculus, must a lambda be exhausted before further applications are cascaded to it's result? For instance, say I have `(\x y. B x y) a b c` - `a` will substitute for `x`, then `b` will substitute for `y`, correct? Then, this is equivalent to `(B x y) c`?
11:40:16 <C-Keen> michaelt: I have given ghc-pkg the exact version number
11:41:13 <athan> sorry, `(B a b) c`
11:41:59 <athan> mine facilitates the option of applying to the lambda, or it's expanded result, through this "precedence" thing
11:42:07 <michaelt> C-Keen: hm, I'm baffled; ghc-pkg list should see what ghc sees.  In a sandbox you use 'cabal sandbox hc-pkg list/unregister/etc'
11:42:18 <igniting> I have a statement like 'y <- f x` and I want to force the evaluation of y. How should I do it?
11:42:27 <Procian> athan: The evaluation order isn't specified for pure lambda calculus.
11:42:36 <athan> :D
11:42:43 <athan> Procian: Is there any way you have a reference?
11:42:45 <C-Keen> michaelt: I see both packages the version -1 printed in blue
11:42:50 <Peaker> igniting: you could use "Control.Exception.evaluate y"
11:43:00 <athan> Thank oyu Procian
11:43:02 <athan> yu*
11:43:03 <michaelt> igniting: on the next line y `seq` blah ?
11:43:07 <athan> you*
11:43:08 <Procian> athan: "Types and programming languages" is awesome.
11:43:13 <athan> :D!!!
11:43:15 <athan> sweet
11:43:22 <Procian> Though it's about types, it starts out with untyped lambda calculus.
11:43:22 <athan> thank you Procian :)
11:43:33 <athan> I need to find the line, I actually have it haha
11:43:58 <athan> I've just been trying to get this project finished, to hopefully land some kind of grant/scholarship/job to get out of (abused) homelessness
11:44:04 <igniting> michaelt: isn't using `seq` discouraged?
11:44:07 <michaelt> C-Keen: right, blue means "hidden", to start over you should unregister them
11:44:10 <athan> I can't wait. Thank you Procian
11:44:45 <C-Keen> michaelt: that will deinstall a lot of dependencies ghc-unregister says
11:44:53 <quchen> igniting: What monad are you in? In IO there's `evaluate`.
11:44:55 <C-Keen> or better "break"
11:44:56 <michaelt> igniting: there are other devices like the one Peaker mentioned, of course.  I don't thing seq and BangPatterns are frowned on exactly
11:45:09 <igniting> yes, I'm in the IO monad
11:45:20 <michaelt> C-Keen: hm, what is the package in question?
11:46:37 <michaelt> C-Keen oh, utf8-string
11:46:38 <C-Keen> michaelt: I want to install feed-0.3.9.2 which depends on utf8-string but only works with utf8-string-0.3.8
11:46:43 <quchen> Then `evaluate` is probably what you want, igniting.
11:46:44 <igniting> Actually, I'm getting the list of files and in the next step I'm creating a new file. I don't want the new file to be included in the earlier list of files (which happens in lazy eval)
11:47:01 <C-Keen> michaelt: and not the latest utf8-string-1
11:47:11 <C-Keen> michaelt: which cabal install has pulled in before
11:47:23 <C-Keen> michaelt: for yesod-static for example
11:47:38 <Hijiri> igniting: don't get the list of files lazily then
11:47:52 <Hijiri> this is why lazy IO can cause problems
11:48:22 <michaelt> C-Keen: but utf8-string in the other version is required by things you have installed?
11:48:31 <C-Keen> michaelt: correct
11:48:43 <igniting> I'm using find from System.FilePath.Find
11:48:55 <C-Keen> michaelt: I am not sure if it is really required or just not specified clearly and has been built with the latest version
11:49:58 <Hijiri> igniting: I can't find it
11:50:02 <michaelt> C-Keen: it does look like things might have moved around. Anyway, there is the obvious expedient of building it in a sandbox
11:50:13 <igniting> It's in the filepath package
11:50:23 <Hijiri> that's where I am
11:50:41 <Hijiri> (System.FilePath.Posix)
11:50:45 <C-Keen> michaelt: I don't know what that means
11:51:52 <igniting> oops, my bad. the filemanip package
11:52:57 <michaelt> C-Keen: oh I see, I just tried it. The trouble is that feed fails to supply upper bounds, but the new API is different. I guess you said that.
11:52:58 <Hijiri> I guess you need to use evaluate like others suggested
11:53:43 <igniting> yes, I think so. thanks!
11:54:37 <C-Keen> michaelt: and now the point where I started: In fact I want to cabal install git-annex which now in turn tries to reinstall feed although I now have it registered with the correct version
11:55:11 * hackagebot paypal-adaptive-hoops 0.6.0.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.6.0.0 (fanjam)
11:59:03 <Benzi-Junior> hey how do I produce the ASCII code for non alphabetic characters ? ord seems to work fine for alphabetic characters but not things like '%'
11:59:47 <EvanR> > ord '%'
11:59:49 <lambdabot>  37
11:59:55 <EvanR> thats definitely it
12:00:11 * hackagebot websockets-snap 0.9.1.0 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.9.1.0 (JasperVanDerJeugt)
12:00:13 <supki> > '\37'
12:00:15 <lambdabot>  '%'
12:01:12 <dmwit> One generally does not produce ASCII codes when writing a 21st-century app.
12:01:21 <dmwit> However, ord is great for producing Unicode codepoints.
12:02:28 <michaelt> C-Keen: ah.  the trouble with feed is difficult; it hasn't really been maintained. I recommend :  mkdir mygitannex   cd mygitannex  cabal sandbox init  and then cabal install git-annex --dry-run   for starters
12:02:42 <C-Keen> michaelt: aye aye
12:03:04 <michaelt> But it's the true and only path C-Keen
12:04:41 <sinnsat> is there a data structure similarly lazy as lists (especially indexing), but faster at index operations? Map maybe?
12:04:51 <michaelt> C-Keen: if you do that, make sure it doesn't say it will install the new-model utf8-string . If it does, then you should begin by `cabal install utf8-string-0.3.whatever'
12:05:07 <grq> sinnsat, dit you look at Data.Vector?
12:05:11 <C-Keen> michaelt: it does say that it will install utf8-string-1
12:05:20 <sinnsat> grq: yes, but it's not lazy for indexing afair
12:06:13 <michaelt> C-Keen: right as expected, but try installing the older one now. Then see what happens if you do cabal install feed on that basis.
12:07:05 <michaelt> C-Keen: I can't remember if cabal 'prefers installed' things by default or if I have adjusted some preference.
12:08:06 <ReinH> sinnsat: What do you mean by "lazy for indexing"?
12:08:21 <michaelt> C-Keen: maybe do git clone https://github.com/jvrdev/feed inside the mygitannex directory then cabal install ./feed  -- this just the trivial bounds patch
12:08:41 <michaelt> C-Keen: it just adds the bounds patch, I mean
12:09:36 <michaelt> C-Keen: oh wait, you're not a regular haskell user?  Suddenly it's coming to me...
12:11:48 <sinnsat> ReinH: as in: you always build the whole data structure, but only have lazy values
12:12:06 <ReinH> sinnsat: you don't always build the whole data structure with lists either, though.
12:12:13 <ReinH> > take 5 $ [1..]
12:12:14 <lambdabot>  [1,2,3,4,5]
12:12:16 <sinnsat> ReinH: that's what I said
12:12:19 <ReinH> That can't build the whole data structure
12:12:22 <voidzero> I'm learning Haskell by means of making an IRC bot. It connects, so now I wonder how I can assign what I would call 'session variables'. For example, the server sends raw 005, containing prefixes (among other things) supported by the server (@ for op, + for voice and so on). What's a proper way to handle these sorts of things?
12:12:41 <ReinH> sinnsat: err
12:12:48 <mmachenry> voidzero: Have you looked at the code for lambdabot?
12:12:49 <C-Keen> michaelt: I am not but it's ok
12:13:18 <ReinH> sinnsat: well then I am confused by what you said
12:13:33 <michaelt> C-Keen: It's just I was pointing out features that would be pointless if you were just trying to get git-annex installed ...
12:13:58 <voidzero> mmachenry, yes, I have, but it was a bit too difficult for me yet
12:14:14 <C-Keen> michaelt: oh well it's good to know. I did some work on darcs aeons ago. I have mostly forgotten everything again it seems
12:14:18 <michaelt> C-Keen: have you used cabal install in the past or just for git-annex?
12:14:22 <C-Keen> michaelt: or too much has changed in the meantime
12:14:28 <sinnsat> ReinH: that Vector is not as lazy as lists, except for the laziness of it's values... that's what they told me here yesterday
12:14:47 <voidzero> I saw a few bots that used Control.MVar
12:15:11 <ReinH> sinnsat: Well, an IntMap is a sparse structure, so only keys with values are stored
12:15:22 <C-Keen> michaelt: thanks for your hints again, I will see how far I get.
12:15:22 <voidzero> I guess I could also be bold and use Redis
12:15:24 <michaelt> C-Keen: I *think* the answer in your case is to uninstall everything that depends on the newer utf8-string
12:15:26 <voidzero> just for laughs
12:15:30 <ReinH> I wouldn't consider a list to be an indexable structure. At least it's a very poor one.
12:15:43 <voidzero> advice would be welcome though :)
12:16:08 <sinnsat> ReinH: so O(log n) for index lookup is as fast as I can get without losing "lazy keys"?
12:16:26 <michaelt> C-Keen: you would only need the sandbox if you were going to use those libraries for something else, not git-annex related, so that advice was unimportant. So far I have build failure if I first install the patched feed i mentioned.
12:16:46 <michaelt> C-Keen: which is just patched to insist on the old version of utf8-string
12:16:53 <ReinH> sinnsat: fsvo "lazy keys", probably.
12:16:55 <obb> how do you build a hashmap in haskell?
12:17:19 <ReinH> obb: Do you care that it has precisely the properties of a hashmap, or do you just want a dictionary-like structure?
12:17:27 <roelof> Hello, I try to learn Haskell by self-study
12:17:35 <obb> dict like structure with O(1) access
12:17:39 <voidzero> hey roelof me too :)
12:17:53 <michaelt> C-Keen: no, new problem with feed. I wonder why someething sensible like git-annex is using an unmaintained project ...
12:17:59 <obb> could also be some sort of array
12:18:08 <sinnsat> obb: Vector :D
12:18:26 <roelof> Now I have a list where I have to do something on every second item. Can someone give me a tip how I can solve this one the best ?
12:18:26 <obb> how can i build my own? ^^
12:18:30 <C-Keen> michaelt: "it seemed to be a good idea at the time" :)
12:18:35 <ReinH> obb: You probablu don
12:18:38 <ReinH> Woops
12:18:52 <ReinH> obb: you probably don't need one, but Data.HashTable.HashTable provides a (mutable) hashtable.
12:19:12 <Hugehead> roelof: You can just use a map with a cycle
12:19:12 <roelof> Recursion is very hard to figure it out
12:19:43 <Hugehead> > map cycle [$ (*2)] [1..10]
12:19:44 <lambdabot>  A section must be enclosed in parentheses thus: ($ (* 2))
12:19:44 <sinnsat> obb: http://hackage.haskell.org/package/vector-0.10.12.2 also has mutable vectors
12:19:45 <voidzero> I'd imagine you could work with (x:y:xs)
12:20:07 <Hugehead> > map cycle [($) (*2)] [1..10]
12:20:08 <lambdabot>  Couldn't match expected type ‘[t0] -> t’ with actual type ‘[[a0]]’Couldn't m...
12:20:14 <ReinH> obb: http://hackage.haskell.org/package/hashtables
12:20:17 <michaelt> C-Keen: oh I see he has it on various package managers, even homebrew...
12:20:20 <Hugehead> > map (cycle [($) (*2)]) [1..10]
12:20:21 <lambdabot>  Couldn't match expected type ‘a0 -> b’
12:20:21 <lambdabot>              with actual type ‘[a1 -> a1]’
12:20:33 <sinnsat> does lambdabot not have plugin for hackage links?
12:20:47 <mmachenry> roelof, start by considering what you should do on the empty list. Then what you should do on a list of only one element, then on a list of any number of items.
12:20:50 <C-Keen> michaelt: yeah unfortunately not on OpenBSD which is a bit of an orphan wrt haskell support
12:21:17 <ReinH> obb: but since you're working in a functional language, you should really give thought to whether O(log n) is good enough. It probaby is.
12:21:24 <ReinH> s/probaby/probably
12:21:30 <voidzero> could anyone give me some pointer regarding my "session variable" question?
12:21:59 <obb> ReinH this was just a theoretical question
12:22:02 <michaelt> C-Keen: yeah that wouldn't work anyway, I think. I wonder if this is discussed on the list or something.  There are actually multiple problems with `feed`
12:22:10 <ReinH> obb: you can't get O(1) lookup without a mutable structure.
12:22:15 <roelof> mmachenry:  a empty list  gives a empty list. A item with just 1 item  gives the one item. With a list with 2 items I have to multiply only the second one by 2
12:22:27 <ReinH> So you're stuck with something in IO or ST
12:22:47 <sinnsat> but you can escape out of ST monad easily
12:22:59 <ReinH> True.
12:23:08 <roelof> mmachenry : but the problem is how do I tell if it's a item on a even or odd position
12:23:18 <ReinH> But once you do that you lose the performance properties of working with a mutable structure.
12:23:29 <voidzero> roelof, with (x:y:xs), y is the second, xs is the rest of the list
12:24:16 <voidzero> second item*
12:24:19 <orzo> jstolarek: doesn't a %~ b require me to already have a b?  I don't see how I can do the castOrLeft function that way
12:24:51 <roelof> voidzero:  so I can do (x:y:xs)  = (x:y*2:xs) ;
12:24:58 <voidzero> no
12:25:06 <roelof> bummer
12:25:13 <voidzero> it's a pattern match
12:25:15 <sinnsat> ReinH: I'm also not sure... a lot of people say use ByteString instead of String, but then again String is probably more lazy again, even than ByteString.Lazy, no?
12:25:16 <ReinH> roelof: why not?
12:25:37 <ReinH> > let f (x:y:xs) = (x:y*2:xs) in f [1,2,3]
12:25:39 <lambdabot>  [1,4,3]
12:25:40 <voidzero> perhaps something like, doWithSecond (x:y:xs) = y*2 : xs
12:25:41 <ReinH> I assume you don't mean this?
12:26:45 <hsk3> Has someone here read chapter 4 in the Haskell 2010 report? Cole did, but he's gone now
12:26:46 <ReinH> sinnsat: They aren't suggesting ByteString because of laziness
12:26:46 <kadoban> roelof: Have you done some reading about haskell basics? https://github.com/bitemyapp/learnhaskell has some great advice on where to start (cis194)
12:26:52 <roelof> ReinH:  I do not know. Im a very beginner is Haskell , which finds Haskell and recursion very confusing
12:26:57 <hsk3> No sorry, it was Cale
12:27:00 <hsk3> Cale, hi
12:27:09 <Cale> hi
12:27:11 <ReinH> roelof: Er, I meant to ask voidzero.
12:27:21 <ReinH> roelof: Because you can literally do that, but maybe that's not what they meant.
12:27:27 <roelof> kadoban:  i do now cis194 and get already stuck at exercise 1 of chapter 1
12:27:28 <obb> maybe something like multEven (x:y:rest) = x:(2*y):(multEven rest) roelof
12:27:56 <ReinH> obb: those parens aren't necessary btw
12:27:59 <ReinH> Cale: o/
12:28:13 <tremon> roelof: I would probably not keep count, but do a zipWith mult on a lazy list containing alternating 1 and 2
12:28:55 <ReinH> tremon: yeah, but they haven't been introduced to zipWith yet
12:29:10 <tremon> ah, it's course material :)
12:29:11 <ReinH> roelof: You might ask in #haskell-beginners, they use the cis194 course there
12:29:30 <roelof> ReinH:  oke, I will ask there
12:29:35 <ReinH> so they have some experience helping with those exercises
12:29:35 <roelof> Thanks all for the help
12:30:24 <voidzero> this is why i never ask for stuff on irc - asking the same question is annoying
12:30:54 <voidzero> but ok one more try - session variables - how to work with them - anyone have pointers for me, pretty please?
12:31:04 <hsk3> Cale: Section 4.3.4 (https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3) defines an ambiguous type: "We say that an expression e has an ambiguous type if, in its type ∀ u. cx  ⇒  t, there is a type variable u in u that occurs in cx but not in t. Such types are invalid."
12:31:05 <hsk3> Yet section 4.5.5 (https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-880004.5) adds: "Any monomorphic type variables that remain when type inference for an entire module is complete, are considered ambiguous,..."
12:31:06 <hsk3> Is the second thing an exception to the first thing? In other words, is it specifying a second case where a variable can be ambiguous apart from the normal definition of ambiguousness?
12:31:15 <unknownloner> oh god stuff
12:31:32 <unknownloner> voidzero: I think thats a no :/
12:31:41 <voidzero> amazing
12:31:46 <voidzero> 1556 nicknames in here
12:32:06 <init> voidzero: wouldn't State be enough?
12:32:08 <unknownloner> and probably like 10-20 actually paying attention
12:32:18 <Cale> hsk3: hmmmm
12:32:45 <voidzero> init, dunno :D i'm new to these things, and before starting off on the wrong foot i figured to ask here
12:33:23 <Cale> hsk3: I guess that you can consider that separate
12:33:42 <kadoban> voidzero: It's too general/ambiguous of a question, IMO. Nobody knows if you're having some specific problem, what you have so far, etc. Are you just starting Haskell, or have you done basics? You said you were doing a bot to learn, what have you read so far though?
12:33:43 <Cale> hsk3: I'd have to think harder about whether they overlap or one subsumes the other
12:34:03 <hsk3> Cale: interesting question..
12:34:07 <Cale> hsk3: I guess there's no overlap
12:34:28 <Cale> hsk3: because those type variables in the first definition are forall bound
12:34:49 <Cale> hsk3: While the type variables of the second sort are introduced for the purposes of typechecking and not bound by a forall
12:35:10 <voidzero> kadoban, It's ambiguous, I'll give you that. Yeah, I started with the "roll your own bot" haskell wiki page, and my first change was to use Network.Connection, so that it can connect to an IRCd using SSL
12:35:11 <hsk3> Cale: yeah... just pity to use the same word for an already precisely defined concept... i guess it's just limited words in the English language..
12:35:15 <Cale> yeah
12:36:13 <Cale> voidzero: What do you mean by a session variable?
12:37:01 <voidzero> I got that to work; I'm reading a lot about Haskell too, and I guess any form of maintaining session variables would be deemed as side effects.. because those vars are based on what is received from an ircd
12:37:14 <kadoban> voidzero: If that's all you know about Haskell, honestly I think that's an /awful/ way to learn Haskell, just so you know. I don't see that going well at all.
12:38:01 <voidzero> Cale, as an example, raw 105 sends PREFIX=... where it tells you what characters are used for nick prefixes (@ for op, + for voiced.. etc.)
12:38:05 <chpatrick> BS.hGetContents is being very slow for me for some reason
12:38:07 <obb> kadoban how do you suggest learning it?
12:38:11 <Cale> voidzero: okay
12:38:11 <chpatrick> I'm trying to pipe a bytestring through flac
12:38:13 <tinchos> exit
12:38:16 <chpatrick> if I run it from zsh it's pretty much instant
12:38:29 <kadoban> obb: https://github.com/bitemyapp/learnhaskell , specifically the cis194 stuff and etc.
12:38:38 <voidzero> kadoban, if "what" is all i know about haskell?
12:38:46 <Cale> voidzero: So okay, state which needs to be kept for the remainder of the connection
12:39:15 <voidzero> yes. So that the client will know that someone's nick is not @foobar, in this example.
12:39:29 <kadoban> voidzero: Well, it sounds like you started from that wiki page and know nothing else except general info?
12:39:36 <Cale> voidzero: If you have a recursive loop which is reading messages from the network, one of the simplest ways to keep state is just to give it function parameters
12:39:46 <Cale> voidzero: and update those parameters as you go
12:39:58 <Cale> voidzero: You could also use IORefs
12:40:06 <Cale> which are mutable references
12:40:42 <voidzero> kadoban, ah, no. :) I have worked myself quite far through LYAH, and I have another book waiting for me (Thinking Functionally With Haskell by Richard Bird
12:40:59 <kadoban> voidzero: Oh okay, my mistake then :)
12:41:11 <voidzero> Cale, so you mean in the loop
12:41:15 <voidzero> like in the forever a >> a
12:41:26 <voidzero> function
12:42:00 <Cale> yeah
12:42:50 <hsk3> Cale, thanks
12:43:02 <voidzero> Ok. That's useful. Still plenty to explore, but thanks for the clue
12:43:34 <voidzero> btw on a different note - I saw that article calling for people to "stop saying IO Monad!!!"
12:43:57 <zq> io monad
12:44:12 <voidzero> but yesterday I read notes from Simon Jones, and he himself says IO Monad at least once per page. :)
12:44:21 <clrnd> io monoid
12:44:41 <zq> because it actually is a monad and the majority of io interactions require sequencing by monadic bind?
12:45:06 <voidzero> I yeah. That's exactly what he's explaining in those notes
12:45:21 <voidzero> Eh, -I.
12:46:04 <voidzero> http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
12:46:24 <voidzero> "Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell
12:47:45 <drazak> Cale: where should I start if I want to try to approach haskell as a math minded person might? is there a class of projects that are more suitable than others? clearly programming is no more a spectator sport than math, so I need to figure out how the hell to get my hands dirty
12:48:25 <voidzero> drazak, that book I mentioned is a great way to start
12:48:39 <voidzero> Thinking Functionally With Haskell by Richard Bird
12:48:45 <seanmc> Is there a convenient shorthand for this expression?  foo <- case bar of Just x -> return x; Nothing -> randomIO
12:48:48 <drazak> hmm, ok
12:49:54 <voidzero> fpcomplete.com might also be a good resource
12:50:04 <drazak> I'll check them out
12:50:25 <drazak> my other programming experience is essentially c# which seems pretty orthogonal in every way
12:51:06 <voidzero> personally I've never read so much about programming before actually doing stuff, as with Haskell
12:51:12 <voidzero> reading about it is just as much fun right now :)
12:51:23 <supki> seanmc: I'd write this as  foo <- maybe randomIO return bar
12:53:26 <seanmc> supki: Wow, awesome, thanks!
12:53:57 <voidzero> drazak, there are also some videos on youtube where simon peyton jones explains many concepts
12:54:00 <voidzero> watching those was fun
12:54:36 <voidzero> afk, bbl ~
12:55:07 <drazak> someone told me awodey did video lectures that correspond to his book as well, maybe I'll check that out as well
12:55:15 * hackagebot gitlib-libgit2 3.1.0.3 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-3.1.0.3 (JohnWiegley)
12:57:14 <Cale> drazak: Yeah, it's a short set of lectures, but roughly :)
12:57:35 <Cale> https://www.youtube.com/watch?v=ZKmodCApZwk
12:57:39 <drazak> Cale: his book is ok, but it seems like a lot go jump through until we actually do anything with a category :)
13:02:27 <mseeks> when constructing a value of type `Maybe (Either String Int)` (for example) with a do block, does haskell infer which monad the do block takes place in?
13:02:53 <mseeks> wait never mind
13:03:52 <mseeks> well actually if you wrote a Monad instance for Maybe (Either String a), then it would have to decide whether the do block is in Maybe a or Maybe (Either String a) right?
13:05:04 <chpatrick> you can't write a Monad instance for Maybe (Either String a)
13:05:18 <chpatrick> but if you wrap it up in a newtype you can write an instance for that, and then it's no longer ambiguous
13:05:45 <mseeks> why can't you write a monad instance for that?
13:06:02 <chpatrick> a Monad has kind * -> *, meaning it takes a type parameter
13:06:09 <mseeks> I see
13:06:09 <chpatrick> like Maybe or Either Int
13:06:13 <chpatrick> Maybe (Either String a) has kind *
13:06:21 <mseeks> thanks
13:06:44 <chpatrick> however, if you do newtype MyMonad a = MyMonad (Maybe (Either String a))
13:06:48 <chpatrick> then MyMonad has kind * -> * :)
13:07:37 <chpatrick> also you can get haskell to give you these monad instances for free if you compose monad transformers
13:08:06 <drazak> kinda makes sense
13:08:09 <mseeks> yeah, I've been using those a good amount
13:08:54 <chpatrick> anyone know why hGetContents is be really slow for me?
13:09:10 <chpatrick> I'm reading all the output of a process and it's seconds slower than zsh
13:09:21 <Peaker> chpatrick: System.IO.hGetcontents ?  The `IO String` one?
13:09:29 <clrnd> chpatrick, byteString?
13:09:35 <chpatrick> bytestring yes
13:09:49 <Peaker> chpatrick: strict or lazy bytestring?
13:09:51 <chpatrick> strict
13:09:58 <chpatrick> BS.hPut i someStuff
13:10:02 <chpatrick> BS.hGetContents o
13:10:10 <chpatrick> takes several seconds
13:10:14 <Peaker> chpatrick: I'm guessing it is a large input?
13:10:15 <chpatrick> piping the same stuff is instant in zsh
13:10:18 <chpatrick> nope, 4 bytes
13:10:22 <clrnd> ...
13:10:23 <Peaker> chpatrick: can you paste a program?
13:10:27 <chpatrick> one sec
13:10:28 <clrnd> 4 bytes?
13:11:07 <Peaker> chpatrick: sounds like the devil is in an unrevealed detail :)
13:11:41 <chpatrick1> http://lpaste.net/1887937704855863296
13:11:52 <chpatrick1> try it out with encodeFLAC "abcd" or something
13:16:09 <mseeks> is it allowed to do something like `addOne, addTwo :: Int -> Int`?
13:16:17 <chpatrick> yes
13:18:06 <aisqwe> i was reading the Functor part of learnyouhaskell and the part where it says (-> r) is functor created a chicken and egg problem for me? the functor type has -> in it and -> is a functor, how is this possible?
13:18:40 <chpatrick> (->) isn't a Functor, but (->) a is
13:19:35 <chpatrick> functors need to be kind * -> *, that is to take a type parameter
13:19:46 <chpatrick> (->) takes two but (->) a takes one
13:20:28 <aisqwe> and how does this resolves the chicken egg cycle?
13:20:46 <Clint> what cycle?
13:20:47 <chpatrick> (->) is a function
13:20:52 <chpatrick> (->) a is a functor
13:21:11 <Peaker> chpatrick: I'm guessing it's flac having some timeout on extra input
13:21:21 <bgamari> hmm, this look familiar to anyone?
13:21:23 <chpatrick> ooh, I'll try hClosing
13:21:39 <bgamari> gio-0.13.0.5: package has duplicate modules: System.GIO.Async.Cancellable System.GIO.File.AppInfo System.GIO.File.ContentType System.GIO.File.File System.GIO.File.FileAttribute System.GIO.File.FileEnumerator System.GIO.File.FileInfo System.GIO.File.FileMonitor System.GIO.File.IOError
13:21:39 <bgamari> System.GIO.File.MountOperation System.GIO.Icons.Emblem
13:21:39 <bgamari> System.GIO.Icons.EmblemedIcon System.GIO.Icons.FileIcon System.GIO.Icons.Icon System.GIO.Icons.ThemedIcon System.GIO.Volumes.Drive System.GIO.Volumes.Mount System.GIO.Volumes.Volume System.GIO.Volumes.VolumeMonitor (use --force to override)
13:21:47 <bgamari> oh dear, my apologies
13:21:49 <Peaker> chpatrick: hClosing is probably what happens on the shell, right?
13:22:21 <chpatrick> yep, that was it
13:22:23 <chpatrick> cheers :)
13:23:06 <asdjsddsi> is a 1-tuple in haskell the same thing as the value contained in that tuple?
13:23:24 <geekosaur> there aren't really 1-tuples
13:23:25 <chpatrick> I don't think there's really a concept of a 1-tuple
13:23:45 <asdjsddsi> for example : 'data Tree a = Node (Tree a) (Tree a) | Leaf a'
13:23:50 <chpatrick> it's just convenient that ( foo ) kinda looks like one :)
13:23:57 <asdjsddsi> and IO () - a zero tuple?
13:23:58 <chpatrick> that's just a bracket
13:24:07 <voidzero> () is nil, isn't it?
13:24:08 <chpatrick> () is a seperate type
13:24:12 <asdjsddsi> ah okay
13:24:15 <chpatrick> data () = ()
13:24:20 <Cale> You can think of () as a 0-tuple if you like
13:24:23 <Cale> There's no harm in that
13:24:27 <hiptobecubic> all tuples are "separate types" aren't they?
13:24:28 <Cale> But there's no 1-tuple type
13:24:34 <asdjsddsi> okay cool
13:24:35 <Cale> yes, all tuple types are separate
13:25:06 <Cale> (foo) doesn't act like a proper 1-tuple type would though
13:25:07 <chpatrick> I guess if tuples are products then () is the identity :)
13:25:13 <Cale> In that (undefined) is not different from undefined
13:25:24 <Cale> yeah
13:25:42 <Cale> Up to some finicky equivalence :)
13:25:43 <Peaker> I'd say (foo) is the only proper tuple behavior :)
13:25:55 <EvanR> voidzero: nil is a thing in dynamic languages, nil is one of the possible classes of dynamically typed values. But in haskell () is the only allowed value of the type ()
13:25:55 <Peaker> Lifted products kill all the nice equivalences that I want :)
13:26:01 <aisqwe> is (->) even a type? how can it be an instance of Functor?
13:26:03 <Peaker> Lifted exponents too!
13:26:13 <Cale> aisqwe: (->) isn't an instance of Functor
13:26:15 <chpatrick> yeah it is
13:26:16 <Cale> (->) e is
13:26:20 <Cale> for any type e
13:26:20 <chpatrick> this
13:26:29 <Peaker> aisqwe: (->) is a type constructor so it can be instance of classes, but only of the right kind (* -> * -> *), Functor is the wrong kind for (->), it is * -> *
13:26:39 <Cale> (->) e a is another notation for (e -> a)
13:26:56 <chpatrick> (->) e being a functor just means that you can map over the result type of a function
13:26:59 <chpatrick> which is really the same as composition
13:27:00 <Cale> So, in this instance,  fmap :: (a -> b) -> (e -> a) -> (e -> b)
13:27:16 <Cale> and yeah, that has exactly the type of composition
13:27:40 * drazak tries to remember if that's /reverse/ polish notation, or just polish notation
13:27:49 <drazak> I guess it's prefix notation, regardless of it's polish nature
13:28:02 <scott> RPN refers to postfix notation
13:28:15 <EvanR> prussian notation
13:28:17 <drazak> then it's just polish :)
13:29:24 <Peaker> xplat: though I think that if GHC had unlifted products/exponents, unboxed aggressively (including polymorphic and lazy values), maybe did some super-compilation, optimized recursions better, had some escape analysis to avoid GC in many cases, it'd be a lot closer to C++ performance (or maybe beat it?)
13:29:59 <Peaker> if I understand GHC's handling of recursion correctly, it sounds incredibly naive.. No unrolling/inlining at all
13:30:47 <chpatrick> how come Asyncs aren't Monads?
13:31:51 <xplat> Peaker: i think how GHC handles this is turning recursion to loops first and then unrolling
13:32:02 <voidzero> EvanR, ok i see. I thought nil was the word for ()
13:32:02 <mseeks> is this true: the expression `(f :: c -> m d) <<= (g :: b -> m c) . (h :: a -> b)` is OK and has type `a -> m d`?
13:32:10 <xplat> Peaker: particularly with LLVM and C backends
13:32:10 <rhaps0dy> Hello
13:32:16 <hiptobecubic> voidzero, i've always called it 'unit'
13:32:40 <hiptobecubic> and it's type, the "unit type"
13:33:03 <EvanR> voidzero: () the type is called the unit type, im not sure what () the value is. its just ()
13:33:10 <voidzero> ah, ok. I'll follow your example from now on then. :-)
13:33:11 <EvanR> the unit value maybe
13:33:23 <Peaker> xplat: maybe that happens in the backend, behind GHC's back. But GHC itself seems to treat recursions as scary black boxes
13:33:25 <voidzero> we could call it 'nuffink' :)
13:33:37 <EvanR> Nothing is something else ;)
13:33:43 <voidzero> yes lol true
13:34:53 <xplat> you could call () 'untuple'
13:35:34 <rhaps0dy> Can you help me for a moment please? I get "haskell-src-exts-1.15.0.1 failed during the configure step. The exception was: user error (The package requires Cabal library version -any && >=1.10 but no suitable version is installed.)"
13:35:35 <voidzero> how about 'zilch'? I'm just fooling around, I'll stop now.
13:35:46 <rhaps0dy> but cabal --version shows "using version 1.16.0 of the Cabal library "
13:36:07 <xplat> Peaker: loop unrolling is pretty target-sensitive though isn't it?  depends on things like pipeline depth and instruction cache size as well as loop size
13:36:17 <EvanR> perhaps "trivial" for the proof of the obvious proposition Unit
13:36:26 <Peaker> rhaps0dy: ghc-pkg list Cabal
13:37:01 <rhaps0dy> /usr/lib64/ghc-7.6.3/package.conf.d
13:37:02 <Peaker> xplat: well, unrolling is a form of inlining of a recursion's extra steps, isn't it?  I think in many cases if you unroll some N steps, you might expose optimization opportunities as inlining generally does
13:37:19 <EvanR> voidzero: Void is the type with no values, so we don't need to worry about what to call the values there since there are none ;)
13:37:19 <Peaker> xplat: have you read "From Lists to Streams to Nothing at all"?
13:37:20 <hexagoxel> rhaps0dy: Cabal version used when compiling cabal executable /= the Cabal library in your package repository
13:37:27 <rhaps0dy> Owch.
13:37:35 <rhaps0dy> hexagoxel: thank you, how do I go about fixing it?
13:37:52 <Peaker> rhaps0dy: cabal install --only-dependencies    before "cabal configure" ?
13:38:48 <voidzero> EvanR, ok, does Void actually exist in Haskell?
13:38:51 <rhaps0dy> hm
13:38:56 <xplat> Peaker: i've read several fusion papers and they seem to work fine with RULES, admittedly it's a little work for the library writer ...
13:38:57 <chpatrick> voidzero: Data.Void
13:38:59 <hexagoxel> `ghc-pkg list Cabal` really should give at least one entry..
13:39:33 * voidzero takes note
13:39:40 <hexagoxel> (can you unregister boot-libs?)
13:39:43 <rhaps0dy> I am installing it as dependency for https://github.com/chrisdone/emacs-haskell-config, I ran "cabal fetch" on this package but it says it's already downloaded
13:39:43 <EvanR> voidzero: yeah, you can define it using -XEmptyDataDecls. data Void
13:39:45 <rhaps0dy> where to?
13:39:51 <Peaker> xplat: well, the main thing they do is make the fused pipeline avoid recursions! So that recursion only happens at the final "toList" call
13:40:01 <Peaker> xplat: that way, GHC isn't too stupid to optimize it :)
13:40:21 <Peaker> xplat: it sounds wrong to me -- an ordinary (map f . filter g)  ought not to be opaque to GHC just because they are defined recursively
13:40:30 <voidzero> I did notice that Network.Connections uses Data.Default in its examples, to produce a record with 'Just def' in it
13:40:46 <EvanR> Default is something else
13:41:57 <Peaker> xplat: Some day I dream I'll have enough time to tackle these kinds of compilation/optimization problems :)
13:42:05 <xplat> Peaker: you can't just automatically inline recursive functions that nicely without running into Looping Inliner Syndrome
13:42:07 <Glitch> zv Tomorrow I marry I am 100% Gay !!!
13:42:19 <voidzero> > :t Just def
13:42:21 <lambdabot>  <hint>:1:1: parse error on input ‘:’
13:42:21 <voidzero> Just def :: Data.Default.Class.Default a => Maybe a
13:42:33 <Peaker> xplat: sure, optimization is hard, let's go shopping!
13:45:59 <EvanR> voidzero: using def somewhere means using the default value for that type
13:46:22 <EvanR> its quite convenience
13:46:26 <EvanR> convenient
13:46:45 <sinelaw> @hoogle Ord k => Map k a -> (a -> m b) -> m (Map k b)
13:46:45 <lambdabot> Data.Map.Lazy mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
13:46:45 <lambdabot> Data.Map.Strict mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
13:46:45 <lambdabot> Data.Map.Lazy update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
13:47:06 <voidzero> EvanR, ok.. and that default value is declared somewhere else, right? Like in a record, in this case?
13:48:07 <EvanR> voidzero: its defined in instances of the class Default
13:48:23 <mseeks> I have three functions, `Monad m => f :: a -> b, g :: b -> m c, h :: c -> m d` and I want to compose them into `a -> m d`
13:48:41 <Peaker> xplat: if you eta-expand   (map f . map g)  to    map f (map g xs)   then inline one step of "map f", see a case on result of "map g", so you inline that one step, and you get:  []->[],  (x:xs)->f (g x) : map f (map g xs)    euruka! map f (map g xs)  can re-use this inlined definition, since it's already-visited
13:48:44 <mseeks> so `h =<< g . f` doesn't work because (=<<) doesn't do a composition
13:48:55 <hsk3> Why is "Num a => a" called a monomorphic type? Isn't it still polymorphic? It supports, Double, Integer, Int and all other Num types
13:48:57 <EvanR> voidzero: for String for example... instance Default String where def = ""
13:49:06 <chpatrick> mseeks: >=> from Control.Monad
13:49:30 <ReinH> mseeks: h <=< g . f
13:50:11 <mseeks> thanks! I discovered that ((h =<<) .) seems to also work
13:50:12 <EvanR> voidzero: which is a bad example because String = [Char] and instance Default [a] where def = []
13:50:18 <chpatrick> eww
13:50:24 <mseeks> yeah, the fish is better
13:50:29 <Peaker> hsk3: (forall a. Num a => a) is a polymorphic type.   (Num a => a) usually means that, so it is polymorphic (usually).   But an "a" from an outer scope's "forall" is not considered polymorphic
13:51:29 <Peaker> xplat: so I think with just a bit of magic dust, the optimizer could auto-detect the REWRITE rule for "map f . map g", and do most of the fusion stuff without the anti-recursive trickery
13:52:07 <hsk3> Peaker: ok
13:52:10 <hsk3> thanks
13:53:50 <voidzero> EvanR, ok, cool, that explains something I was wondering about already
13:54:21 <voidzero> line 79 of https://github.com/vincenthz/hs-connection/blob/master/Network/Connection/Types.hs
13:54:51 <voidzero> instance Default TLSSettings where def = TLSSettingsSimple False False False
13:54:54 <EvanR> voidzero: yep spelling out that default TLSSettings would be annoying ;)
13:54:58 <EvanR> so def
13:55:13 <mseeks> why does Control.Monad.State.Class export MonadState and not modify, and Control.Monad.Trans.State.Lazy export modify and not MonadState?
13:55:33 <mseeks> seems like it would make more sense to have one module export both like with Reader
13:55:58 <voidzero> EvanR, yep got it now, thanks :)
13:56:12 <bramgg> How can I get `output <- hGetContents hout` to evaluate immediately without adding some obnoxious "putStrLn output" after?
13:56:23 <geekosaur> don't use hGetContents, mostly
13:56:45 <bramgg> geekosaur: how do you suggest I get the output of a System.Process process?
13:58:09 <geekosaur> loop on hGetChar or gHetLine may be the best you can do. hGetContents forces extra laziness
13:58:47 <hodapp> Haskell provides no notion of a default value of a record, right?
13:58:51 <geekosaur> sadly there's not a lot of good strict I/O in the base libraries
13:59:03 <geekosaur> hodapp: not intrinsically, no, but see Data.Default
13:59:04 <hodapp> I have no issue with defining a default myself but if there's an easier, more idiomatic way I'd rather do that
13:59:08 <hodapp> geekosaur: alrighty, thanks
13:59:28 <hiptobecubic> Can't you just `seq` the result of hGetContents? You're already in IO.
13:59:51 <geekosaur> seq only ensure the first character is read
14:00:01 <EvanR> for a ByteString?
14:00:02 <chrisdone> <bramgg>	How can I get `output <- hGetContents hout` to evaluate immediately without adding some obnoxious "putStrLn output" after?   — lol
14:00:04 <hiptobecubic> oh balls, right. Well you can 'length' it then :)
14:00:06 <EvanR> BS.hGetContents
14:00:36 <chrisdone> poor old putStrLn just thinks its a regular old function, not the best but pretty good. now it's being called obnoxious
14:01:28 <EvanR> hodapp: Data.ByteString.hGetContents says "Read entire handle contents strictly into a ByteString."
14:01:43 <EvanR> of course for a large or infinite contents you will exhaust all memory
14:01:51 <chrisdone> that tickled me for some reason. calling code obnoxious
14:01:51 * hodapp spins EvanR around to face hiptobecubic
14:01:55 <EvanR> but at least it will crash now if theres a problem not later
14:02:26 <chrisdone> johnw: hej
14:02:37 <EvanR> hodapp: they were assuming you really wanted Strings ;)
14:02:38 <johnw> chrisdone: hej!
14:03:07 <lseppala> The class declaration for MonadState is "class Monad m => MonadState s m | m -> s where..." What does the "| m -> s" mean?
14:03:17 <lseppala> The Haskell report isn't helping much :\
14:03:19 <chrisdone> johnw: your suggestion of using TH for nice shell scripting in haskell has been a seed planted in my brain and it's growing leaves
14:03:19 <johnw> lseppala: that's a functional dependency
14:03:33 <johnw> lseppala: it means that the choice of m entirely determines the type s
14:03:47 <lseppala> ahh, makes perfect sesne
14:03:51 <lseppala> sense*
14:04:01 <johnw> so, MonadState Int IO means that in IO, you can only use Int as a state, within that function
14:04:12 <johnw> chrisdone: ah, nice!
14:04:28 <johnw> I was thinking that bash syntax isn't hard to parse at all (I wrote a complete zsh parser in elisp, for example)
14:04:37 <voidzero> zsh <3
14:04:43 <EvanR> hodapp: and ive complained about this before, but the docs dont make any sense for that particular function when it says "As with hGet, the string representation in the file is assumed to be ISO-8859-1." thats surely a copy pasta error
14:04:44 <johnw> so turning  full bash into its equivalent, pipes-based Haskell code should be pretty easy
14:04:46 <chrisdone> the idea that one can write [sh| ls -al |] in haskell, or write ls -al | $(map (take 5)) in a bashy setup, iow being able to antiquote into the other language somehow sounds *awesome* and the best of many worlds
14:04:48 <lseppala> yeah, 'functional dependency' isn't in the Haskell report. Some non-standard addition?
14:05:02 <johnw> yes, the anti-quoting is what would really clinch it
14:05:06 <xplat> Peaker: the 'just a bit of magic dust' is called 'a supercompiler', and people are gradually working out how to make a decent one for a lazy language; it's different than for strict languages
14:05:07 <johnw> lseppala: it's a GHC extension
14:05:17 <johnw> FunctionalDependencies, I believe
14:05:28 <lseppala> cool, thanks
14:06:03 <athan> strange lambdas for all: http://deconfigured.com/blog/atlc-motivation
14:06:16 <xplat> Peaker: there are a few articles linked from a subpage of SPJ's research page
14:07:26 <chrisdone> i also like it because: it could be done very light-weight, just syntax. meaning it would require rare updates like you might do to a combinator-based DSL, and i'm starting to appreciate "never changing" aspect of scripting languages
14:07:43 <johnw> chrisdone: yep
14:07:56 <johnw> the best part is that it would make the "I want to upgrade this bash script to a Haskell script" moment an effortless decision
14:08:00 <chrisdone> whenever Tekmo makes a major version bump to his Turtle library, now scripts written in it are out of date. same problem for shell-conduit. this is bad
14:08:08 <chrisdone> yeah =)
14:08:26 <benzrf> athan i am leaving for home and i will be back in like 20 minutes so pls PM me and remind me to look into the atlc aagain
14:08:26 <johnw> the only tricky part is going to be properly matching semantics in all cases
14:08:28 <chrisdone> "now i want a little bit of abstraction/structure" BAM!
14:08:30 <johnw> but that will just take time
14:08:37 <athan> :) will do benzrf!
14:08:51 <johnw> bash gets some thing right, like how easy regexp matching is
14:09:00 <johnw> (for simple tasks)
14:09:17 <chrisdone> via grep? or is there regexing native to bash?
14:09:30 <johnw> if [[ $foo =~ chris.*done ]]; then echo $foo; done
14:09:48 <chrisdone> ahh
14:09:52 <johnw> also, I think our quasi-quoter should have two modes
14:10:01 <johnw> in the first mode, it's a literal translation
14:10:15 <johnw> that is, [sh| test x foo] translates to run "test" ["-x", "foo"]
14:10:23 <johnw> in the second, we commandeer things that we can do internally
14:10:32 <johnw> so [shh| test x foo] would be isExecutable "foo"
14:10:44 <sinnsat> johnw: it's ;fi not ;done :P
14:10:50 <johnw> oops, thanks!
14:10:51 <Peaker> xplat: but all it took here was a couple of inlinings and matching the result as identical to already-seen code.  I thought super-compilation did more than that
14:10:54 <chrisdone> to save overhead?
14:11:04 <johnw> yes, and to play better with Haskell when anti-quoting
14:11:15 <johnw> Eshell does this, for example
14:11:29 <johnw> in the default mode, I "intercept" as many things intended for the system as possible, and handle them in Lisp directly
14:11:41 <johnw> it lets you do things on remote system transparently, for examlpe
14:12:02 <johnw> because I could see executing our [sh||] blocks on another system by various means
14:12:20 <athan> alright, back to the walmart parking lot. Time to PaAaRtYyYy~~! Who's got the george foreman??
14:12:24 <johnw> plus, interception reduces the necessary toolset on the target machine
14:12:24 <xplat> Peaker: the 'matching the result' stuff is basically the thing that makes supercompilation more than inlining
14:13:08 <johnw> in that sense, our turtle quoting system becomes busybox, effectively
14:13:15 <Peaker> xplat: sounds quite specific to recursions' optimization.. is supercompilation about optimizing recursions?
14:13:20 <johnw> great for raspberry pi scripting
14:13:47 <chrisdone> one thing i was wondering is what do these blocks return?
14:14:01 <johnw> either exit code or stdout/tsderr
14:14:06 <johnw> oh, duh
14:14:07 <chrisdone> maybe something polymorphic?
14:14:07 <johnw> a producer
14:14:23 <johnw> Produce Text IO
14:14:27 <johnw> ExitCode
14:14:35 <chrisdone> what's Produce here?
14:14:40 <johnw> Producer Text IO ExitCode
14:14:41 <johnw> from pipes
14:14:51 <johnw> ideally it should be two producers with a common exit code
14:15:04 <johnw> i.e., Producer (Text, Text) IO ExitCode
14:15:12 <johnw> I'm not sure what the best formulation is, Tekmo would have an idea
14:15:23 <johnw> you want either stdout or stderr, never blocking for either one, and an ExitCode on termination
14:15:33 <johnw> that way, you can ignore the output entirely and just look at the exit code
14:15:37 <johnw> or you can block reading stdout, etc.
14:16:03 <johnw> Producer may be too limited to handle all those semantics
14:17:11 <johnw> I wonder if pipes has a way of saying "I don't care about the stream, just jump to the final result"...
14:17:31 <xplat> Peaker: in a sense, in that most of the interesting things about supercompilation wouldn't be necessary if there were no suc
14:17:37 <xplat> h thing as recursion
14:18:30 <xplat> johnw: i'm actually interested in making a 'haskellish shellish' thing, but it seems like pipes aren't really up to what i want, quite.
14:18:34 <Peaker> super-compilation supposedly makes compile times terrible.. but the optimization I described above shouldn't be that expensive (if you just cap it at a low inlining depth)
14:19:54 <xplat> Peaker: i'm only telling you what the research tells me[C[C[C[C[C[C[C[C[C[C
14:20:22 <joelteon> this just in: adding more steps to compilation increases compilation time
14:20:47 <Peaker> unless it lets you remove other less cost-effective stuff :)
14:20:57 <xplat> johnw: i'm thinking of actually using a session-typed lambda calculus like GV from Wadler's "Propositions as Sessions"
14:21:06 <johnw> xplat: intriguing
14:21:20 <johnw> xplat: if you drum up some designs, please let me know
14:22:46 <johnw> chrisdone: but whatever we do, we need those three outputs at least
14:22:56 <johnw> chrisdone: and potentionally more, if the script bindings other file handles
14:23:00 <johnw> binds8
14:23:16 <S11001001> xplat: Fix C
14:23:20 <S11001001> ;]
14:23:52 <chrisdone> johnw: using pipes or conduit or any abstraction beyond base isn't a given for me at the moment. an actual feature of such a thing would be that it can never just stop working because some package isn't available. but we may have different scripting needs. i don't necessarily want to do complicated/performant streaming inside haskell, i'm even happy just piping things together for that and just getting a dumb String and an ExitCode at
14:23:52 <chrisdone> this point
14:24:05 <lpaste> tomphreek pasted “parentVal” at http://lpaste.net/120048
14:24:20 <xplat> johnw: don't forget stdin!
14:24:21 <ttt_fff> is there some haskell extension where I can say: * is an op between (Matrix mxn) and (Matrix nxp) ?
14:24:34 <johnw> chrisdone: the only reason I would prefer it "built-in" to such a scripting library is that then I wouldn't have to go through hoops to upgrade it to handle large quantities of data in constant space
14:24:38 <chrisdone> i mean -- if i'm *truly* going to rely on something as a script that i can expect to work a year from now or have worked two years ago
14:24:54 <tomphreek> surely parentVal shouldn't be called cuz it's not a function!
14:26:05 <chrisdone> johnw: sure
14:26:10 * chrisdone strokes beard
14:27:05 <xplat> johnw: the big problem with using pipes as a shell is that the idea of a 'compute baton' that flips back and forth along the pipeline is 100% baked into the types, it can't really handle things like concurrency transparently
14:27:07 <chrisdone> i partly like this about turtle, it's intentionally dumb — aimbed at n00bs, but i saw it advantageous for the above reason
14:27:32 <johnw> xplat: hmm, true
14:27:46 <chrisdone> xplat: that's the same in conduit
14:28:00 <johnw> to model a true shell pipeline would need something other than a serialized stream
14:28:02 <chrisdone> for shell-conduit we had to make a new $| operator
14:28:09 <xplat> chrisdone: i consider conduit as pretty much a flavor of pipes
14:28:17 <tomphreek> how to tell haskell to interpret [a b c] as a list a:b:c:[] rather than a list of a called with b c
14:28:29 <chrisdone> xplat: sure, both coroutine upstream-driven
14:28:32 <ReinH> tomphreek: you can't?
14:28:37 <koala_man> tomphreek: add commas?
14:28:55 <chrisdone> tomphreek: -XLispMode =p
14:29:04 <EvanR> you could use template haskell and something around [a b c] ;)
14:29:08 <EvanR> maybe
14:29:16 <EvanR> or commas
14:29:24 <ReinH> Or you could just use the correct syntax.
14:29:26 <xplat> [qw|a b c]
14:29:39 <tomphreek> the correct syntax is?
14:29:42 <tomphreek> the commas?
14:29:43 <EvanR> [a, b, ]
14:29:45 <koala_man> [a, b, c]
14:29:46 <xplat> [a,b,c]
14:29:46 <EvanR> :(
14:29:46 <tomphreek> thanks
14:29:55 <tomphreek> didn't realise that
14:29:56 <chrisdone> > a : b : c : []
14:29:57 <lambdabot>  [a,b,c]
14:31:00 <ReinH> How did you find a Haskell resource that doesn't show list syntax? o_O
14:31:13 <johnw> chrisdone: so based on what xplat was saying, maybe it is better to have a fully self-contained library that better matches the semantics of bash directly
14:31:19 <tomphreek> ReinH: read a book on haskell about a year ago
14:32:02 <tomphreek> ReinH: used it for a few small programs and left it alone
14:32:15 <chrisdone> anyhoo, another advantage of saying "let's support bash-like syntax" is i could make hell use it by default. so you could write $ foo -blah 2>/dev/stdout | egrep -x Foo | $(map (take 5)) # yay
14:32:16 <ReinH> tomphreek: Ah. Probably good to have a little refresher then
14:32:54 <chrisdone> the main reason i didn't stick with hell as my main shell is regular shell syntax is too convenient to get out of the habit of
14:32:55 <ReinH> chrisdone: I wouldn't call bash syntax something to aspire to...
14:33:06 <chrisdone> ReinH: the subset i presented above is pretty good
14:33:11 <Luke> chrisdone: did you see sebastian is willing to include your haskell-flycheck in his flycheck-haskell elisp package?
14:33:30 <ReinH> Wait, so there's haskell-flycheck and flycheck-haskell?
14:33:38 <ReinH> chrisdone: you did a thing for flycheck recently?
14:33:38 <chrisdone> i don't know about johnw, but i don't want to support if [ x -x vlan ]; do; cvbcb; fi and all that crap — that's the stuff i can never figure out how to write. that's what i want haskell for
14:33:58 <chrisdone> i just want the bang-for-buck syntax, which is pretty much piping
14:34:28 <chrisdone> Luke: saw something in my inbox, didn't go through it yet
14:34:35 <johnw> you don't really have to figure it all out, it's fairly easy to parse and render into its Haskell equivalent.  If you want to just get the bare bone support working, maybe I can help you with getting the more baroque syntax translated
14:34:36 <Luke> k
14:36:19 <chrisdone> ReinH: luke tried out my prototype and it worked
14:37:12 <Luke> ReinH: http://blog.hoersten.co
14:37:15 <Luke> i wrote about it there
14:38:05 <ReinH> Luke: nice
14:39:01 <chrisdone> johnw: hmm. the fact you want the baroque syntax disturbs me =p
14:39:22 <Luke> hahaha
14:39:26 <hsk3> In this document: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-880004.5
14:39:27 <hsk3> Search for: "has the monomorphic type"
14:39:27 <chrisdone> at any rate, not planning on working on anything soon. but i like the idea a lot
14:39:28 <hsk3> Why is Num a => a said to be a monomorphic type? Looks polymorphic to me.
14:39:39 <hsk3> Cale: ^ ideas?
14:40:21 * hackagebot jose-jwt 0.3.1 - JSON Object Signing and Encryption Library  http://hackage.haskell.org/package/jose-jwt-0.3.1 (LukeTaylor)
14:40:56 <bramgg> `foo` is shortform for `foo == True`. Is there something similar for `foo == False`? Eg "!" or "not".
14:41:15 <voidzero> > not True
14:41:16 <lambdabot>  False
14:41:36 <bramgg> Weird I tried that and it didn't work, guess it's just my code. Thanks
14:42:53 <voidzero> :type not
14:42:58 <voidzero> dunno if that works with lambdabot
14:43:07 <chrisdone> johnw: i'm coming at this from: i hate bash and the horse it rode in on, but haskell sucks at the main thing bash does great, the 98% case of scripting that consists (for me) pretty much of piping and redirection. anything else like conditionals, looping, doing the weird stuff that awk does, etc. are pretty clean in standard haskell for me. map (take 5 . takeWhile (/='a')) oddly comes more naturally to me than a cut incantation
14:43:19 <chrisdone> johnw: what would be your motivation for such a thing?
14:44:48 <chrisdone> (well, piping and obviously the calling of programs with parameters very simply. the basic things one does at the prompt)
14:46:56 <Clint> anyone know what http://hackage.haskell.org/package/ranges is deprecated in favor of?
14:48:01 <tomphreek> @hoogle Sum monoid
14:48:02 <lambdabot> No results found
14:48:26 <voidzero> hoogle's a bit out of date, i read recently
14:48:36 <johnw> chrisdone: I guess we write different scripts; I think I use looping and conditionals almost immediately
14:48:55 <johnw> chrisdone: for example: https://gist.github.com/14e105cf82b90de7f8be
14:49:04 <johnw> gotta run now, keep me apprised of further developments!
14:49:24 <tomphreek> @hoogle Sum
14:49:24 <lambdabot> Data.Monoid Sum :: a -> Sum a
14:49:24 <lambdabot> Data.Monoid newtype Sum a
14:49:24 <lambdabot> Prelude sum :: Num a => [a] -> a
14:49:56 <tomphreek> would be nice to be able to do @hoogle Sum | grep -i monoid
14:49:58 <tomphreek> :)
14:50:59 <chrisdone> johnw: willdo =)
14:56:28 <sinnsat> chrisdone: I can't follow exactly... haskell sucks at piping? I'd say that's pretty much 'bind'
15:00:00 <tomphreek> is it possible to specialise Monoid instance in type contraint, e.g. sumNeigh :: (Monoid (Sum a)) => a -> BinTree a -> BinTree a.
15:02:42 <joneshf-laptop> where do you put quickcheck instances? with the data types?
15:02:51 <joneshf-laptop> or in the tests
15:03:59 <tomphreek> I have a generic function mConcatNeigh (Monoid a) => a -> BinTree a -> BinTree a. I don't like the name. Want to create sumNeigh where I invoke mconcatNeigh from within with Data.Monoid Sum monoid
15:06:18 <tomphreek> oh it's jsut (Num a) => BinTree (Sum a) -> BinTree (Sum a)
15:09:05 <kadoban> tomphreek: Why would you want to specialize on one particular Monoid? The only reason to use Sum is to get a Monoid instance, as far as I know, so…I don't really understand your goal.
15:09:42 <tomphreek> kadoban: solely for naming purposes
15:09:57 <tomphreek> kadoban: I like sumNeighboors rather than mconcatNeighboors
15:10:10 <kadoban> tomphreek: So…call it that. What does that have to do with the types?
15:10:27 <ReinH> :t mconcat
15:10:28 <lambdabot> Monoid a => [a] -> a
15:10:39 <ReinH> Your first function doesn't seem like a variant of mconcat
15:10:44 <chrisdone> <sinnsat> chrisdone: I can't follow exactly... haskell sucks at piping? I'd say that's pretty much 'bind' -- not like that
15:11:15 <tomphreek> kadoban: but if I call it mconcatNeighboors and call it with a different monoid (Product one) it will repalce each node in a tree with a product of it's neighbooring nodes
15:11:23 <tomphreek> and so name sumNeighboors is misleading
15:11:45 <chrisdone> sinnsat: try to express `ghc --make x.hs 2 > /tmp/log.txt | grep Template | tail -f -n 100` in haskell
15:11:59 <chrisdone> sinnsat: see you in 20 minutes
15:12:38 <ReinH> tomphreek: Once you fix Sum a as your monoid, you no longer need a monoid constraint.
15:13:13 <chrisdone> sinnsat: similarly haskell sucks at regex
15:13:36 <ReinH> As you noted, you do need a Num constraint on a because you need (+) and 0
15:13:58 <sinnsat> chrisdone: ah, so you mean it a bit more specific for shell-syntax
15:15:09 <chrisdone> i like Tekmo's turtle but his regex example made me laugh
15:15:27 <chrisdone> "turtle supports Patterns, which are like improved regular expressions."
15:15:38 <chrisdone> stdout (grep (has ("c" <|> "d")) "dog")      -- grep 'cat\|d
15:15:43 <chrisdone> yeah. improved. right.
15:16:33 <Cale> I'd usually rather use Parsec than regular expressions
15:16:34 <chrisdone> combinators are awesome (yay parsec), but when it comes to scripting, trivial syntax is a feature
15:16:42 <chrisdone> Cale: even in the shell?
15:16:46 <Cale> Even in fairly trivial cases
15:16:47 <chrisdone> grep ^a
15:16:53 <Cale> In shell *scripts*
15:16:59 <Cale> maybe not in an interactive shell
15:17:28 <Cale> If there's any chance I'll have to return to the thing in a few months and figure out what's going on
15:17:30 <chrisdone> right, there's a difference between the two
15:18:14 <Cale> Haskell is not really appropriate for an interactive shell, I'll agree on that, but that'd be true even if you solved the problems you've mentioned.
15:18:21 <joe9> How is Data.List.all implemented using Data.Traversable and Data.Foldable?
15:18:34 <Cale> The most important property of an interactive shell is probably that you can type the name of an exectuable file and have it be executed.
15:18:41 <Cale> and that'll never be true in Haskell
15:19:02 <chrisdone> Cale: that's why i'm interested in the idea of supporting a subset of shell language and then splicing in haskell
15:19:11 <ReinH> Cale: Oh but it is! You just need some ridiculous template haskell metaprogramming...
15:19:26 <koala_man> chrisdone: the grep relies on undefined behavior, and consider the case when you want to mix variable literal strings and patterns
15:19:27 <chrisdone> Cale: e.g. ls -al | grep P | $(sortBy (comparing length))
15:19:29 <joe9> http://www.stephendiehl.com/what/#what-to-avoid avoids Data.List.all but I could not find the alternative definition  of all there.
15:20:04 <_um> hi, #haskell. I have a question about the correct use of Data.Trie: if I'm trieing to implement efficient testing for whether or not a string `s` is already present in a list of strings `S`, does it make sense to encode `S` as a trie, doing something like `let sAsTrie = Data.Trie.formList (zip S (repeat ""))` and then testing for `Data.Trie.member s sAsTrie`? Or is this a bad/silly way to go about it?
15:20:27 <ReinH> joe9: It's suggesting to import Foldable and Traversable and use those instead
15:20:30 <Cale> ReinH: Even with TH, you can't really be transparent enough
15:20:37 <ReinH> joe9: "So often times it is desirable to explicitly mask these functions from implicit import and force the use of Foldable and Traversable instead"
15:20:48 <Cale> ReinH: You'll end up having to use [sh| ... |] or something
15:21:03 <chrisdone> Cale: i don't think [sh|…|] is too heavy
15:21:13 <Cale> chrisdone: It's heavy for interactive use
15:21:20 <chrisdone> right, which is where you flip it
15:21:24 <Cale> If you have to type that at the start of every line
15:21:29 <chrisdone> now you have an implicit [sh| … |] wrapped around every line
15:21:32 <joe9> ReinH: But, I cannot find an "all" in either Foldable or Traversable.
15:21:38 <ReinH> Cale: chrisdone's conduit-shell library generates a bunch of names for stuff in $PATH
15:21:40 <chrisdone> which is why you have $(…) for splicing in haskell
15:21:51 <ReinH> joe9: It's in Foldable
15:21:54 <ReinH> @hoogle all
15:21:56 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
15:21:56 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
15:21:56 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
15:22:00 <drazak> sounds like a lot to type when all I want to do is open lynx, and is lynx even going to work right? I guess it spawns a whole new shell to run it, seems impressively inefficient
15:22:10 <chrisdone> so in the shell you'd just write: $ ls -al | $(map (take 5))
15:22:18 <Cale> Well, okay, but now you're talking about a different language which has access to Haskell evaluation...
15:22:21 <chrisdone> and in a script: main = do lines <- [sh|ls -al | $(map (take 5))|]
15:22:36 <Cale> Which is probably a good idea?
15:22:40 <Cale> But it's not Haskell :)
15:22:44 <chrisdone> i'm talking about a quasiquoter that converts a simple language into haskell
15:22:47 <joe9> ReinH: sorry, found it.
15:23:00 <tomphreek> @type [0 ..] :: [Sum Int]
15:23:01 <lambdabot>     No instance for (Enum (Sum Int))
15:23:01 <lambdabot>       arising from the arithmetic sequence ‘0 .. ’
15:23:01 <lambdabot>     In the expression: [0 .. ] :: [Sum Int]
15:23:13 <chrisdone> who cares whether you call it "haskell" or not :)
15:23:13 <joe9> ReinH: sorry for the bother.
15:23:51 <ReinH> joe9: np
15:24:02 <chrisdone> okay now i gotta try this
15:24:15 * chrisdone puts on his TH gloves
15:24:34 <drazak> ReinH: still sounds insecure to me
15:24:41 <ReinH> drazak: ?
15:24:44 <tomphreek> :t [0, 1] :: Sum Int
15:24:45 <lambdabot>     Couldn't match expected type ‘Sum Int’ with actual type ‘[t0]’
15:24:45 <lambdabot>     In the expression: [0, 1] :: Sum Int
15:24:55 <tomphreek> :t [0, 1] :: [Sum Int]
15:24:56 <lambdabot> [Sum Int]
15:24:58 <ReinH> tomphreek: please /msg lambdabot to experiment
15:25:06 <tomphreek> apologies
15:25:11 <ReinH> np
15:26:47 <ReinH> That instance Num a => Num (Sum a) is nice though
15:26:53 <ReinH> > 0 :: Sum Int
15:26:54 <lambdabot>  Sum {getSum = 0}
15:27:34 <benzrf> oooh nice
15:27:36 <ReinH> I'm not sure why there isn't an instance Enum a => Enum (Sum a) though.
15:28:16 <benzrf> @let deriving instance Enum a => Enum (Sum a)
15:28:18 <lambdabot>  .L.hs:156:1:
15:28:18 <lambdabot>      Can't make a derived instance of ‘Enum (Sum a)’:
15:28:18 <lambdabot>        ‘Sum’ must be an enumeration type
15:28:35 <ReinH> Needs GND?
15:29:28 <tomphreek> so puzzled why [0 ..] fails and [0, 1] doesn't when casting to [Sum Int] :/
15:29:42 <ReinH> :t [0..]
15:29:43 <lambdabot> (Num t, Enum t) => [t]
15:29:48 <ReinH> tomphreek: because [0..] requires Enum
15:29:59 <ReinH> and there is no instance for Sum a
15:30:23 <ReinH> There could be, but there isn't.
15:30:24 <tomphreek> thanks
15:30:30 <ReinH> np
15:30:46 <benzrf> @let blurgh = blurgh {-# LANGUAGE GeneralizedNewtypeDeriving #-}
15:30:46 <lambdabot>  Parse failed: Parse error: {-# LANGUAGE
15:30:51 <benzrf> ;-;
15:32:55 <Axman6> tomphreek: it's worth noting that you're not casting (that implies you're changing the type of one thiong to another, usually magically in most languages), you're specifing what type the expression is
15:33:53 <tomphreek> Axman6: yeah, fair enough. don't know the terminlogy I guess
15:34:24 <tomphreek> specification then
15:34:56 <ReinH> tomphreek: The reason that this works, btw, is that number literals are polymorphic:
15:34:58 <ReinH> :t 0
15:34:59 <lambdabot> Num a => a
15:35:11 <ReinH> 0 can be anything member of the Num typeclass
15:35:39 <ReinH> s/anything/any
15:36:02 <tomphreek> heh, I am not that nooby despite what it looks like :), but thanks anyway
15:36:17 <ReinH> tomphreek: it doesn't hurt :)
15:36:26 <tomphreek> yeah
15:36:40 <tomphreek> I imagine it's difficult to tell
15:37:34 <ReinH> I prefer to err on the side of over-explaining
15:37:51 <benzrf> ReinH: it can be a member of any member of the class?
15:38:02 <ReinH> benzrf: yeah
15:38:05 <tomphreek> ReinH: that's the best way
15:38:19 <ReinH> benzrf: since members implement fromInteger
15:38:21 <tomphreek> easier than asking all the time
15:40:26 * hackagebot configuration-tools 0.2.9 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.9 (larsk)
15:42:49 <tomphreek> Is there a performance penalty for using BinTree (Sum a) instead of BinTree a? Did I just introduce a wrapper around each Int?
15:43:16 <tomphreek> (with a = Int)
15:43:49 <shachaf> At runtime, Sum = id
15:44:00 <shachaf> But it might be that e.g. map Sum = map id /= id
15:44:12 <shachaf> So it can depend.
15:45:35 <tomphreek> shachaf: cheers.
15:46:26 <u_quark_mobile> Can a function pattern match on which specific instance it is of a class and treat the argument as of that type somehow?
15:46:32 <tomphreek> is it acceptable practice to just make Int a monoid in my code (sum) in my case and get rid of the Sum a fluff
15:46:37 <EvanR_> tomphreek: er internet... newtype wrappers dont exist at runtime
15:46:39 <eacameron> I want to write portions of our C++ app in haskell. The haskell portion needs to make web-requests when asked. However, it should keep a pool of sessions. How can I have the FFI entry points all share the same state? "runMyMonad" at each entry point loses the state
15:46:40 <ReinH> u_quark_mobile: no
15:47:33 <ReinH> tomphreek: You should just use Sum.
15:47:35 <shachaf> u_quark_mobile: A Typeable constraint lets you do that (but it might be a bad idea in some cases).
15:47:40 <tomphreek> EvanR_: ah right yeah I recall that from LYAH
15:47:42 <u_quark_mobile> Not even with some fancy extension ghc?
15:47:53 <ReinH> Ah, Typeable, right
15:48:29 <tomphreek> ReinH: yeah thought so. looks cumbersome. fair enough. cheers
15:49:03 <ReinH> tomphreek: newtypes don't introduce any boxing though
15:49:13 <ReinH> so it's only a bit cumbersome at the language level
15:49:26 <EvanR_> tomphreek: using Int's monoid implies youre working with something which is polymorphic over monoids, so someone might be confused about how Int is being used with that monoid code
15:50:38 <EvanR_> since theres two common ways for Int to be a monoid
15:51:04 <tomphreek> EvanR_: I don't mind calling sumNeighboors instead of mconcatNeighboors. But ideally sumNeighboors is using mconcnatNeighboors as implementation
15:51:11 <shachaf> There are lots of common Int operations that are associative and have an identity.
15:51:12 <tomphreek> so it's explicit which one I am using
15:51:28 <u_quark_mobile> Ok thanks I will have a look at typeable
15:51:34 <tomphreek> similiarly for productNeighboors
15:51:40 <shachaf> u_quark_mobile: What are you actually trying to do here? :-)
15:51:46 <shachaf> Another option is something like ala. I don't know whether it's a good option.
15:52:04 <shachaf> > ala Sum foldMap [1,2,3,4,5]
15:52:06 <lambdabot>  15
15:52:06 <sssilver> So during lunch today, my boss was like "Pascal sucks, it doesn't even have proper OOP", and I said well a lot of really good programming languages don't have OOP, like Haskell, and he's like "I'm talking about serious languages here" :( and I'm like, Haskell is serious, and he's like, "what serious program has ever been written on Haskell??"
15:52:11 <sssilver> and that kinda stalled me
15:52:23 <geekosaur> xmonad, pandoc, git-annex
15:52:39 <sssilver> geekosaur: he's never heard of any of those
15:52:42 <chrisdone> shellcheck
15:52:47 <pacak> sssilver: ghc
15:53:01 <shachaf> @quote Jafet abstract
15:53:01 <lambdabot> Jafet says: Haskell is an imperatively functional abstract enterprise programming language template
15:53:08 <EvanR_> tomphreek: you might be trying to use too much monoid ;)
15:53:13 <shachaf> Hmph. Worked in /msg.
15:53:13 <geekosaur> if "I've heard of it" is the criterion then your only oprogramming language from now on is PHP. have fun\
15:53:17 <shachaf> @quote Jafet research.language
15:53:17 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
15:53:19 <pacak> sssilver: Also whole bunch of stuff in finance which.
15:53:30 <pacak> s/which//
15:54:06 * chrisdone can professionally attest stock trading and bioinformatics
15:54:35 <sssilver> so like nothing megapopular/famous? like idk, ms office/world of warcraft/postgres/etc
15:54:51 <pacak> sssilver: facebook
15:54:52 <chrisdone> well facebook use it
15:55:01 <chrisdone> have you heard of facebook?
15:55:02 <sssilver> I thought facebook used PHP
15:55:12 <chrisdone> they used a vareity of technologies
15:55:34 <chrisdone> https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/
15:55:44 <u_quark_mobile> Shachaf I am not sure myself...  I am trying things out
15:55:50 <sssilver> well I mean just because you're using a Makefile to build your C++ app, doesn't mean your app is written using Makefile right
15:55:57 <sssilver> or a Dockerfile, or whatever
15:56:17 <sssilver> it's maybe .002% Makefile, but that's it
15:56:28 <sssilver> 99.998% it's still C++
15:56:48 <chrisdone> anyway, your boss doesn't sound like the kind of person who'd appreciate haskell anyway
15:57:37 <sssilver> he prides himself as being megapractical and hands-on
15:57:41 <sssilver> but yeah anyway
15:57:47 <geekosaur> so yes, he's going to use php
15:57:49 <chrisdone> so do the people writing haskell for money
15:57:50 <geekosaur> and nothing else
15:57:55 <sssilver> just shared a story in which a working 40something professional called Haskell not a serious language
15:58:16 <sssilver> (he uses C++)
15:58:23 <ldbrandy1> hi, facebook checking in, our anti-spam/abuse/etc business logic is almost all running haskell now. It's a rather large, though not necessarily super visible, program.
15:58:38 <chrisdone> :D
15:58:59 <sssilver> ldbrandy1: :))
15:59:01 <sssilver> thanks for the insight
15:59:02 <geekosaur> working 40something professionals are often already frozen into obsolete mindsets
15:59:10 <chrisdone> +1
15:59:46 * geekosaur sees that in sysadmin too --- former boss was a mainframer and couldn't shake the habits, and I regularly confuse the heck out of my same-aged peers because I keep up with developments they can't imagine :/
16:00:48 <chrisdone> there seems to be a point where some people can't distinguish genuine advancement from fads and decide that it's easier to ignore it all and stick with the devil they know
16:01:08 <pacak> geekosaur: Because digging stick worked for years as far as he can remember, his father and his grandfather. Why  anybody wants to switch to some fancy shovel?
16:01:44 <hiptobecubic> chrisdone, I don't think people could ever tell the difference. People just lose patience with gambling as they age.
16:01:47 <_um> chrisdone: I do think it's hard, in principle, to distinguish genuine advancement form fads... and sometimes, just because a fad gets sufficiently successful, it seems like it can generate advancement.
16:01:55 <geekosaur> something like that, yes. see also older people confused by non-dial phones (I *think* we're exiting that phase finally. maybe)
16:02:04 <_um> chrisdone: I think of the 5th Generation project, and the Prolog fad.
16:02:17 <_um> That died out, but I think it was also genuine advancement.
16:02:53 <chrisdone> when i approached haskell for the first time i made sure it wasn't just running on enthusiasm
16:03:18 <geekosaur> I am perfectly willing to poke at enthusiasm and look for the seeds of genuine improvement.
16:03:32 <geekosaur> they're often there and will keep popping up in other places as they mature
16:03:44 <_um> That seems like a sensible approach to me, geekosaur.
16:03:52 <chrisdone> checked support for sockets, threads, etc. through the benchmarks suites to see that it could be performant enough, looked to see if anything big was written in it
16:03:53 <voidzero> I decided to learn Haskell after I was working with Liquidsoap, a stream automation language that has its own functional programming language (i think)
16:04:02 <sssilver> well to someone like my boss, C++14 is an advancement. Haskell is a fad.
16:04:05 <chrisdone> it seems pretty easy to determine whether something satisfies your needs
16:04:11 <voidzero> I decided to "properly learn functional programming" :)
16:05:05 <sssilver> coz the framework is that "well if you don't have classes, then how do you declare one??"
16:05:23 <chrisdone> i consider the reactjs stuff that's popular now to be a genuine advancement, while also being fashionable others might consider it a fad
16:05:30 <ldbrandy1> it's a weird a C++ fan would be down on haskell since C++ has been moving towards haskell for a long time.
16:05:48 <sssilver> ldbrandy1: not really, you mean templates?
16:05:49 <ldbrandy1> and away from OO
16:06:17 <sssilver> templates in C++ are just a way to make OO "more flexible"
16:06:23 <ldbrandy1> err
16:06:32 <geekosaur> I would not say that
16:06:39 <chrisdone> C++ has a variety of generic programming features that have correspondence with Haskell generic programming features
16:06:49 <ldbrandy1> yes, like concepts, for example
16:06:52 <geekosaur> but then I would not say that C++'s OO captures OO very well (admittedly, I'm more in the Smalltalk camp with respect to OO)
16:06:58 <chrisdone> there're a few papers comparing them
16:07:01 <Axman6> so I'm working in a cabal sandbox and I want to upgrade one of the libraries I'm using, which another package I'm using depends on (afaict it should work fine with the newer version). what's the safest way of going about this?
16:07:18 <geekosaur> and it's C++ that has flexibility issues, which limits its ability to do OO and leads ot templates as a workaround
16:07:19 <csd_> Cabal is telling me that installing ghc-mod will break my Hoogle install. Looks like it wants to downgrade transformers-base and monad-control from 4.2 to 3.0.
16:07:26 <Axman6> dop I need to remove everything and run cabal install... again?
16:07:30 <csd_> How can i install ghc mod
16:07:37 <chrisdone> axman6: i tend to ghc-pkg unregister -f .cabal-sandbox/x86.. the-package --force
16:07:40 <geekosaur> Axman6: this might be a time to learn how to use sandboxes
16:07:41 <Xe> use a cabal sandbox
16:07:42 <chrisdone> axman6: and then just install the newer version
16:07:58 <geekosaur> oh sorrt,just mixed 2 convos :/
16:08:06 <Axman6> geekosaur: I'm curious what you think I'm doing right now if not that?
16:08:07 <geekosaur> csd_, you want a cabal sandbox
16:08:13 <Axman6> heh, right
16:08:28 <csd_> geekosaur: know of a good guide?
16:08:39 <_um> Can Axman6  just change the .cabal dependencies to require the newer version and run cabal install --only-dependencies and cabal configure? Is that the right way?
16:09:07 <chrisdone> geekosaur: not that OO ala smalltalk is necessarily a good idea either
16:09:31 <geekosaur> csd_: the main difference is when you set up your work area you run "cabal sandbox init". now your installs go into the sandbox and are much less likely to conflict with other projects' dependencies
16:09:33 <_um> (I've only just got in the swing of things with a sandboxed project, and I've doing about this, but I'm not 100% confident it is the proper way).
16:09:39 <geekosaur> and it can pull in its own dependencies as needed
16:09:41 <csd_> doesn't sandboxing mean that i can't use both packages at the same time?
16:10:11 <geekosaur> it means you can't hack on them both at identically the same time, but ghc-mod is an executable. once it's built, copy it out of the sandbox to where it can be run
16:10:25 <Axman6> _um: no, that's the first thing I tried
16:10:33 <csd_> ok
16:11:01 <csd_> so cabal sandbox init creates a .cabal dir at .?
16:11:09 <Axman6> so... what's the easiest way to delete every install library in a cabal sandbox and reinstall everything? seems too much depends on aeson to make it worthwhile unregistering everything -_-
16:11:45 <geekosaur> ok, now I can answer you both at once. there's a .cabal-sandbox directory created
16:12:04 <Axman6> rm -rf .cabal-sandbox? =)
16:12:05 <shelf> Axman6: i just nuke .cabal-sandbox and cabal-sandbox-config
16:12:07 <geekosaur> csd_, that's what defines the sandbox. Axman6, you should be able to just rm -r that directory to start over
16:12:16 <csd_> ok thx geekosaur
16:12:17 <Axman6> will do
16:12:17 <shelf> i don't think the config needs to be nuked
16:12:19 <_um> Axman6: can you use `cabal sandbox delete`
16:12:23 <charlie> hi shelf :)
16:12:28 <shelf> oh that works~
16:12:36 <geekosaur> (and cabal sandbox init again to recreate it in pristine form)
16:12:42 <_um> Yep.
16:12:48 <shelf> charlie: hello
16:13:03 <_um> csd_: Have you looked at this info on sandboxes? https://www.fpcomplete.com/school/to-infinity-and-beyond/older-but-still-interesting/an-introduction-to-cabal-sandboxes-copy
16:13:33 <csd_> fpcomplete seems to have great content
16:13:56 <_um> Or, i'm not quite sure that was the one that helped me most... I did find something.  I'l look.
16:14:10 <Axman6> seems to be working...
16:14:11 <hexagoxel> also, there is `cabal sandbox delete`
16:14:17 <tomjaguarpaw> Am I right in thinking that package databases only support one instance of any given package version
16:14:23 <gcganley> rhaps0dy: did you find the time to read the typeclassopedia?
16:14:24 <csd_> _um, i think i'm ok for now. ill just copy the ghc mod binary to my cabal/bin folder
16:14:28 <csd_> thanks though
16:15:04 <_um> csd_: Sure thing. I don't know much, but i did spend several weeks slamming my head into cabal until things clicked for me--trying to keep that pain from going to waste ;)
16:15:24 <shelf> sandbox delete seems like a thing i should probably have known about
16:15:30 <shelf> thanks
16:15:40 <Axman6> me too =)
16:16:24 <Axman6> hopefully this talk of making cabal more Nix like will bare fruit
16:16:27 <_um> csd_: I know you said you're alright, but future reference, in terms of just outlining the invocation for starting up a new project, I've found http://www.stephendiehl.com/what/#cabal to be most helpful.
16:17:14 <hexagoxel> when moving the executable, keep in mind that some executable packages also have a data directory. i recommend using --bindir and --datadir on installation instead.
16:17:19 <_um> Axman6: I'm very interested in the prospects for backpack. But I know too little to have any idea if it's a thing to hope for in the near—or even a posible—future.
16:25:29 * hackagebot list-t 0.4.3 - ListT done right  http://hackage.haskell.org/package/list-t-0.4.3 (NikitaVolkov)
16:25:31 * hackagebot yesod-purescript 0.0.4.2 - PureScript integration for Yesod  http://hackage.haskell.org/package/yesod-purescript-0.0.4.2 (mp)
16:27:30 <tomphreek> +5
16:27:47 <gcganley> > (+5)
16:27:48 <lambdabot>  <Integer -> Integer>
16:28:34 <tomphreek> ops that was /sb +5
16:31:41 <MrMetric> I'm having more treble with the type system
16:31:55 <voidzero> -- any haskell user
16:32:01 <MrMetric> :P
16:32:11 <MrMetric> If the type of z is RealFrac a => Complex a, why are z*z and z+z both giving me RealFloat a => Complex a?
16:33:45 <pacak> Are you sure it's treble and not tribble?
16:35:40 <testera> hi,  how would I go about diagnosing an ExitFailure 1 when trying to install (as deps for Gtk2Hs) glib and cairo with cabal?
16:35:53 <tomphreek> EvanR_: >>too much monoid. I think you are right. I originally wanted sumNeighboors :: BinTree a -> BinTree a and productNeibhoors with same signature. Now I am forced to work with BinTree (Sum a) or BinTree (Product a) instead.
16:35:56 <testera> I can't see any errors in the log, even when giving cabal -v
16:36:33 <tomphreek> And what if I want to use sumNeighboors and then productNeighboors? I have to convert BinTree (Sum a) to BinTree (Product a)
16:36:44 <pacak> testera: cabal unpack glib and cabal build
16:37:00 <tomphreek> all so that sumNeighboors and productNeighboors call mconcatNeighboors within
16:39:41 <tomphreek> replacing each node with a product/sum of its neighboors should use the same code it feels cuz both are monoids, but it makes it cumbersome
16:39:48 <Hijiri> what can I do with an IndexedLens?
16:40:01 <Hijiri> (other than use it as a Lens)
16:41:10 <testera> pacak: cabal build doesn't seem to accept the same options for lib/extra/bin dirs as cabal install... what does cabal-unpack+cabal-build actually /do/?
16:41:25 <testera> alternatively, how might I go about seeing what real error is causing `ExitFailure 1`?
16:41:28 <Hijiri> I'm guessing I have to use some Indexable p ~ (->) to do something interesting
16:41:33 <Hijiri> not ~
16:41:35 <Hijiri> I mean
16:42:18 <pacak> testera: It unpacks package into current folder so you can get in and build it yourself. cabal build builds it
16:42:31 <testera> I got that much, but why would that work if cabal install doesn't?
16:42:42 <testera> log from trying to install this stuff is at http://pastebin.com/kz9aSQXN
16:45:37 <pacak>  setup: The pkg-config package cairo version >=1.2.0 is required but it could
16:45:59 <testera> ah, that's fatal? that could be indicated much more clearly :|
16:46:27 <testera> why would there not be pkg-config info for cairo, given that cairo is installed on virtually every machine in the universe?
16:46:53 <pacak> testera: It wants development stuff for cairo.
16:47:03 <pacak> cairo-dev or whatever it's called.
16:47:56 <testera> oh fucking fuck I forgot about distros that intentionally castrate their users like this
16:48:00 <testera> I didn't even realize
16:48:21 <testera> -dev packages are such a bad idea I had completely wiped them from my worldview
16:48:26 <testera> thank you.
16:49:32 <voidzero> in other words.. "not having -dev packages is like not having balls."
16:50:05 <benzrf> voidzero: >being casually exclusionary to female users
16:50:46 <testera> sorry.
16:50:49 <voidzero> haha
16:50:50 <joelteon> benzrf: don't worry, this environment is far too toxic to women for them to see that in the first place
16:51:13 <benzrf> joelteon: #haskell IME is considerably less toxic than SOME channels
16:51:22 <benzrf> i hope it wont get worse :(
16:51:26 <joelteon> what does that have to do with anything?
16:52:09 <voidzero> btw I have not yet seen how this place is toxic to women
16:52:15 <voidzero> will I be in for a surprise when I do?
16:52:31 <joelteon> you're not likely to see it unless one decides to show up
16:52:32 <benzrf> voidzero: its not that bad as irc channels go
16:53:11 <voidzero> we obviously don't visit the same channels :P
16:53:24 <benzrf> as *freenode channels go :|
16:55:23 <ProofTechnique> Anyone know how to get OpenGL-2.9.2.0 to build on Mavericks?
16:56:00 <MrMetric> @src (!!)
16:56:01 <lambdabot> xs     !! n | n < 0 = undefined
16:56:01 <lambdabot> []     !! _         = undefined
16:56:01 <lambdabot> (x:_)  !! 0         = x
16:56:01 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:56:22 <lpaste> ProofTechnique pasted “OpenGL error” at http://lpaste.net/120056
16:56:22 <_um> fwiw, I find the implicit assumption that no women are present and the apparent resignation to a toxic environment pretty toxic.... :(
16:56:26 <hexagoxel> lambdabot, pls use lpaste
16:56:27 <tomphreek> sumNeighs t = getSum <$> mconcatNeighs' mempty (fmap Sum t)
16:56:31 <benzrf> _um: indeed
16:56:32 <hexagoxel> :D
16:56:44 <_um> I should say "explicit assumption"
16:57:12 <MrMetric> hexagoxel: :^D
16:58:12 <sinnsat> women have a function, don't be so hard on them
16:58:38 <benzrf> sinnsat: go away
16:58:40 <benzrf> please
16:58:57 <ProofTechnique> Where's shapr when you need him?
17:00:20 <benzrf> @where ops
17:00:21 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
17:00:31 * hackagebot mtl-prelude 1.0.3 - Reexports of most definitions from "mtl" and "transformers"  http://hackage.haskell.org/package/mtl-prelude-1.0.3 (NikitaVolkov)
17:00:32 <benzrf> hmm i didnt know some of these people are ops
17:00:33 * hackagebot mtl-prelude 2.0.2 - Reexports of most definitions from "mtl" and "transformers"  http://hackage.haskell.org/package/mtl-prelude-2.0.2 (NikitaVolkov)
17:00:57 <byorgey> sinnsat: I don't really know the context here, but whatever the context, that kind of statement is not acceptable.
17:01:16 <benzrf> inb4 "but was le joak"
17:01:24 <joelteon> sinnsat: you and people like you are not welcome here
17:01:36 <byorgey> joelteon: that kind of statement is not acceptable either.
17:02:01 <joelteon> indeed, I guess I should be more inclusive
17:02:42 <dsfox1> tolerance of intolerance is untenable
17:03:33 <byorgey> this is not about tolerance, this is about being welcoming.  It is entirely possible to be welcoming while disagreeing.
17:03:55 <joelteon> is it the intention of the community to welcome people who make others feel unwelcome?
17:04:07 <benzrf> i certainly hope not
17:05:02 <ProofTechnique> I don't think one can speculate on the intentions of "the community". This would be more fruitfully discussed in #haskell-blah
17:05:02 <zwer> do you really think that joke made someone feel unwelcome?
17:05:20 <byorgey> it is the intention of the community to welcome everyone.  Statements or actions that make people feel unwelcome are not welcome.
17:05:22 <joelteon> emphatically yes
17:05:42 <benzrf> zwer: are you seriously suggesting it wouldnt
17:05:53 <zwer> benzrf yes
17:06:19 <zwer> it was just a joke
17:06:29 <benzrf> 07:58 < benzrf> inb4 "but was le joak"
17:06:30 <_um> zwer: I'll volunteer to have been made less welcome.
17:06:31 <zwer> I see a lot overreaction unless I missed something prior
17:06:42 <_um> That way you can just shut down that unfruitful speculation
17:06:43 <benzrf> zwer: have you considered trying empathy
17:06:45 <dolio> That's not an excuse, and jokes do make people feel unwelcome routinely.
17:06:57 <joelteon> I also volunteer to have been made to feel less welcome.
17:07:01 <_um> sorry "made to feel less welcome".
17:07:44 <dsfox1> Is it not a troll?
17:07:59 <joelteon> That's not really the point, is it?
17:08:09 <joelteon> It being "a troll" doesn't make it any less of a problem.
17:08:20 <dsfox1> if its a troll we should stop
17:08:27 <benzrf> dsfox1: why
17:08:41 <ProofTechnique> Which is why community leaders make it clear that such statements are unwelcome, and repeated offenses lead to bans.
17:08:59 <joelteon> or more accurately, they don't.
17:09:01 <joness> what did I miss? heh
17:09:12 <tomphreek> joness: sexist joke
17:09:45 <joness> share it!
17:09:54 <ProofTechnique> joelteon: shapr and others have been very judicious with the banhammer, and have been very clear about what sort of attitudes are acceptable in #haskell
17:10:05 <tomphreek> joness: search for function
17:10:25 <joness> I wasn't in the channel. oh well I don't care that much
17:10:43 <joelteon> ProofTechnique: there was a mod right here just now that did nothing about the sexist comment.
17:10:45 <voidzero> humm
17:10:47 <voidzero> guys
17:10:50 <voidzero> let it go please
17:10:51 <voidzero> all of you
17:10:55 <voidzero> thanks.
17:11:04 <joness> are sexist jokes ban worthy in here?
17:11:10 <joelteon> Clearly not.
17:11:19 <dsfox1> benzrf: oh, not a troll.  Never mind
17:11:22 <byorgey> joness: yes.
17:11:39 <joness> if Mrs Obama can make "men are stupid jokes"..why can't we?
17:11:40 <voidzero> arguing for the sake of arguing is all this looks like to me
17:11:46 <voidzero> and, it's all off topic
17:11:53 <gcganley> is this when i should fill the channel with really horrid looking @pl code?
17:12:02 <geekosaur> it'd be an improvement tbh
17:12:03 <joelteon> joness, that question belies a fundamental misunderstanding of the problem with sexist jokes against women in technology.
17:12:03 <voidzero> <laugh tape>
17:12:37 <benzrf> joelteon: punching up
17:12:40 <benzrf> * joness
17:12:52 <dibblego> hello everyone, can we please take this discussion to #haskell-blah ?
17:12:53 <benzrf> joelteon: not to say that such a joke is in good taste either
17:12:58 <joness> joelteon the main "problem" is that they are just not as interested in technology. and some people make up other problems to fit their agenda
17:13:10 <geekosaur> can this "discussion" move to -blah please?
17:13:14 <voidzero> the only result from this is sour grapes and people who are less inclined to continue joining this channel
17:13:15 <voidzero> so indeed
17:13:27 <benzrf> voidzero: lol
17:13:31 * tomphreek feels like this discussion is important enough that despite being off topic it should continue
17:13:35 <geekosaur> or at least, elsewhere than here
17:13:37 <dibblego> can this move to another channel please, such as #haskell-blah?
17:13:38 <dolio> I suggest that this conversation be over.
17:13:50 <benzrf> voidzero: if a discussion about sexism makes you not want to be in a channel it might be because you're sexist, just fyi
17:14:03 <shachaf> ==dolio
17:14:22 <dibblego> is there a function with the type f (a -> b) -> f a -> f b ?
17:14:31 <tomphreek> :t fmap
17:14:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:14:36 <joelteon> it's <*> I think
17:14:41 <voidzero> yeah fmap
17:14:49 <dibblego> ok thanks, yes (<*>)
17:14:50 <joelteon> it's <*>
17:14:52 <Hijiri> :t (<*>)
17:14:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:14:57 <dibblego> great thanks for your help
17:15:01 <voidzero> :t (<$>)
17:15:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:15:24 <voidzero> (i was curious)
17:16:53 <gcganley> is there any non-infix (outfix?) version of (<*>) and/or (>>=)
17:17:04 <voidzero> fmap for (<*>)
17:17:12 <joelteon> fmap is not (<*>)
17:17:17 <gcganley> voidzero: fmap /= (<*>)
17:17:18 <init> fmap is (<$>)
17:17:22 <joelteon> if we're disregarding sexism to educate people about haskell, at least be correct about haskell!
17:17:22 <init> (<*>) is ap
17:17:25 <benzrf> gcganley: ap, but it's implemented in terms of Monad
17:17:32 <benzrf> @src ap
17:17:32 <lambdabot> ap = liftM2 id
17:17:34 <tomphreek> @hoogle f (a -> b) -> f a -> f b
17:17:36 <voidzero> ah yes, see. i'm new at this. :)
17:17:37 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
17:17:37 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
17:17:37 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
17:19:09 <voidzero> maybe I should start asking questions by formulating them as wrong statements
17:19:25 <dolio> No.
17:19:25 <gcganley> benzrf: but im looking for it for just applicative
17:19:26 <voidzero> ppl respond much faster, it seems, LOL
17:19:34 <benzrf> gcganley: not that i know of sadly
17:20:22 <gcganley> benzrf: who maintains Control.Applicative and Control.Monad?
17:20:25 <koala_man> voidzero: that even has a name, Cunningham's law
17:20:56 <benzrf> gcganley: The Beaurucrats
17:21:20 <gcganley>  benzrf: library commity?
17:22:00 <dolio> Yes.
17:22:05 <voidzero> koala_man, haha
17:22:11 <voidzero> why am I not surprised. :-)
17:24:14 <gcganley> voidzero: did you have any questions about haskell?
17:26:21 <voidzero> well, I was hoping to find clues on how to handle "session variables" - I'm learning haskell by making an IRC bot
17:27:43 <gcganley> voidzero: hmm, I've never heard of "session variables". what do you mean by that?
17:27:46 <voidzero> some of the data that is sent by the server is useful, but it's all just valid for as long as the connection exists
17:28:29 <joelteon> well, you could use the Reader monad
17:28:30 <voidzero> for example, raw 005 sends PREFIX=.. that tells the client which characters and modes are statuses
17:28:35 <voidzero> like @ for op, + for voice
17:29:24 <gcganley> voidzero: that sounds like you may need a Reader or a State Monad
17:29:50 <gcganley> voidzero: idk how strong of a construct you need. is it concurrent?
17:32:22 <voidzero> It will be one day, but right now I'm trying to grasp how this data is kept between functions.. I guess this type of data is what they label "side effects"?
17:32:42 <joelteon> in the Reader monad, the environment is passed around in the bind implementation
17:33:11 <lfairy> Reader is just a fancy way of passing around an extra parameter
17:33:16 <joelteon> the Reader monad is the cleaner form of passing an extra parameter to every function you call.
17:33:56 <voidzero> ok right
17:34:17 <voidzero> so with this snippet from the haskell wiki
17:34:19 <voidzero> type Net = ReaderT Bot IO
17:34:21 <voidzero> data Bot = Bot { socket :: Handle }
17:34:54 <voidzero> Bot is the record, passed along by ReaderT, right?
17:35:07 <Hijiri> yes
17:35:09 <voidzero> well, Bot is Bot, containing a record
17:35:58 <Hijiri> you get a Bot parameter threaded through all your stuff
17:36:09 <Hijiri> and you can be reasonably sure that it doesn't change since it's in Reader(T)
17:36:49 <voidzero> I had this idea, to take the first word of the first line sent by the server (which is the server's name), by adding 'servername :: String' to that record
17:36:58 <voidzero> Hijiri, alright
17:37:21 <voidzero> so now I'm trying to predict whether I should make it servername :: Maybe String
17:37:45 <voidzero> because it's unknown until the server sends something
17:37:48 <Hijiri> I haven't written an irc bot, but what I might do is just not fully start the Bot until I have all the information I need
17:38:05 <Hijiri> So you wouldn't start your ReaderT Bot IO until you have a complete Bot
17:38:24 <Hijiri> If you want your Net to react to things before you get all the info then I guess that wouldn't work
17:38:41 <dmwit> voidzero: you could consider using statet
17:38:43 <voidzero> right, well I did also take the rest from the wiki :P
17:39:09 <voidzero> so I have a working bot.. even figured out how to use Network.Connection to allow SSL connections
17:39:48 <voidzero> I guess I'm taking the long road to knowing how Haskell works, though
17:39:54 <dmwit> readert isn't so hot on things that might change
17:40:01 <voidzero> so I mostly read a lot at this point
17:40:11 <joelteon> yeah, you can't change what's stored in the Reader environment
17:40:33 <joelteon> for that you'll need State
17:40:34 <dmwit> i think you misunderstood hijiri's suggestion
17:40:39 <Hijiri> you can change it, but if you do it too much you're better off using State
17:40:41 <voidzero> ah, that's new info. yes :)
17:41:29 <Hijiri> I meant earlier that you wait until you have all the vital information, and then start your main bot loop
17:41:33 <dmwit> he's saying have an initialization phase where you connect to the server, then oncemyou have a name dcop into the irc monad
17:41:50 <dmwit> and then you would not need maybe
17:41:51 <Hijiri> so you don't have to worry during the main bot's life whether you have that info or not
17:42:00 <voidzero> In this case how the bot functions would depend on the information received by the server
17:42:39 <voidzero> because, that example with PREFIX=foo, will decide which characters are a prefix of the nickname, for example
17:43:13 <Hijiri> getImportantInfos >>= flip runReaderT mainBotStuff
17:43:17 <voidzero> PREFIX=(ohv)@%+
17:43:25 <Hijiri> (probably a bit more complicated than that but that's the general idea)
17:43:26 <voidzero> means, mode +o for @nick
17:43:45 <Hijiri> voidzero: You have a separate handler for before and after you have the important info
17:43:59 <Hijiri> First you wait to get the info you need, then you start the main bot using the info you now have
17:44:08 <voidzero> ah
17:44:24 <lfairy> I don't recommend this, but you can also use a MVar to initialize the state lazily :P
17:45:10 <voidzero> new concept, but i get what you mean, basically a new environment, set by the first "clueless" environment, starts when it has the info
17:45:56 <voidzero> and thus no side effects anymore
17:47:53 <voidzero> is this correct enough?
17:48:01 <Hijiri> I think so
17:48:23 <Hijiri> it's just like asking the user for some starting parameters, except you're getting them from the internet so it's a bit more complicated
17:49:14 <Hijiri> depending on how you do it you might still have State or friends in the intialization phase
17:49:32 <Hijiri> if irc servers can send data in whatever order they want
17:49:41 <Hijiri> (I don't know much about how that is done)
17:49:53 <init> oh, it was an IRC bot?
17:50:09 <lpaste> bananagram pasted “state fails to install” at http://lpaste.net/120058
17:50:15 <voidzero> The specs probably will tell which data might be volatile
17:50:43 <bananagram> state won't build, it says the COPYRIGHT file doesn't exist
17:50:46 <voidzero> MOTD is an example, it may change during your connection, and it's not important either
17:51:11 <init> voidzero: if you actually have 'mutable' data, don't feel using it is actually wrong, as IRC is stateful by its nature, but learning Haskell with an IRC bot is actually not so cool :P
17:51:30 <voidzero> LOL oh I'm loving it tbh
17:52:15 <init> voidzero: are you writing your own parser?
17:52:16 <voidzero> IRC is a great protocol because you can just parse a line and do something
17:52:40 <Lokathor> yeah but those lines have no meanings attatched to them
17:53:05 <joness> voidzero do you have a recursive function call that keeps reading data from the socket? if so you could carry some state in the argument of that function.
17:53:32 <joness> just "update" the argument on the next recursive call
17:55:21 <dmwit> bananagram: why do you want that package even =P
17:55:22 <voidzero> joness, alright yes, and I think you do that, by applying the result of a in (a >>= b) to b, which is a, updated by that argument, right?
17:55:51 <voidzero> Lokathor, the meaning is decided by the protocol, or is that not what you mean?
17:56:22 <voidzero> it's just like a http client speaks http to a server, only this is parsed line by line, in a sense
17:56:26 <joness> voidzero you don't need monads of any kind to do that.
17:56:38 <Lokathor> well, i suppose i specially mean that the protocol doesn't specify an encoding
17:56:53 <bananagram> dmwit, dunno now, I thought Control.Monad.State was provided in it
17:57:01 <Lokathor> so, you can assume utf8, until someone suddenly sends non-utf8
17:57:38 <voidzero> most clients let the user decide the encoding, and default to utf-8
17:57:38 <dmwit> bananagram: mtl or transformers, depending
17:57:45 <voidzero> which is good ☺
17:58:04 <dmwit> In what sense is "let the user decide the encoding" good?
17:58:09 <Lokathor> voidzero, i'd say that's bad actually
17:58:17 <Lokathor> since you can't know what others have set as their encoding
17:58:52 <voidzero> lol, well, it's also just an IRC bot, so it already can't be too serious
17:59:16 <dmwit> athan: Yesterday, you had some motivating example about changing the type signature of some function and having to have cascading refactors throughout your codebase. I wanted to hear more about that. This blog post is mush that doesn't clarify anything about what problem you're solving.
17:59:20 <Lokathor> yeah that's about where i landed on it in the end when i was going to do my own irc bot
17:59:25 <joness> voidzero: http://lpaste.net/120059
17:59:32 <Lokathor> then the chat part of our program got integrated into the main server
17:59:33 <voidzero> not needing monads, but IO is already a monad (gasp!)
17:59:49 <dmwit> athan: In particular, you make a big deal about (^f x) y and (f ^x) y being different things, both of which you might want. But the lambda calculus has those, too, spelled (f x) y and f (x y), respectively. What's wrong with those?
18:00:05 <Hijiri> well, it's more general than just working with monads
18:00:17 <dmwit> athan: You should take a look at Heilmeier's catechism: http://cseweb.ucsd.edu/~ddahlstr/misc/heilmeier.html
18:00:50 <dmwit> athan: Also, read the introduction from a few SPJ papers. He does an outstanding job of opening with, "here's a thing programmers are already doing, but in an awkward or hard way. and here's how we can make it better".
18:00:58 <joness> voidzero sure, I meant no *additional* monad just to keep state. i feel that this can complicate simple things (on the other hand it can also make complicated things simpler)
18:01:02 <lfairy> voidzero: a nice simple algorithm is: first try decode it as utf-8, and if that fails, try latin-1
18:01:04 <dmwit> athan: Which is what *you* are going to have to do if you want anybody (including me) to care about what you're writing.
18:01:09 <voidzero> I need complicated
18:01:19 <dmwit> athan: And I think you do want that, because you seem to be pouring a lot of effort, time, and soul into it. That shows.
18:01:29 <dmwit> athan: But I'm still utterly bewildered about why what you are doing is important.
18:01:30 <voidzero> joness, so thanks for this example snippet ;-)
18:03:30 <bitemyapp> dmwit: moment of your time in query?
18:04:18 <dmwit> shoot
18:04:51 <lfk> *pew*
18:05:28 <voidzero> joness, to me it looks like this loop accumulates a huge list
18:06:31 <voidzero> and perhaps my brain has also switched to dumb mode
18:06:36 <joness> yeah. an example of "keeping state" without a state monad
18:06:53 <joness> I might have totally misunderstood what you're trying to do. I tend to not read back too far
18:07:41 <voidzero> ok, in that case I will stop thinking about this too hard.
18:08:53 <voidzero> I could probably just hack something together that works, but if I did that, I'd miss most of the juicy bits
18:11:40 <ReinH> @unmtl State s a
18:11:40 <lambdabot> s -> (a, s)
18:11:53 <ReinH> voidzero: The State monad is equivalent to just passing a state parameter around :)
18:20:28 <voidzero> heh, there is much to be read for me it seems.
18:20:39 <voidzero> by me.
18:21:31 * voidzero coughs
18:23:35 <voidzero> cheers guys, thanks for the help
18:24:27 <voidzero> time for the subconscious to take over
18:30:25 <eacameron> When calling into Haskell from a C-based app, how can the C code "own" resources that need to be bracketed? For example, withSession \sess -> {...} brackets a session. But I need the C code to own the session on its stack.
18:30:36 * hackagebot mtl-compat 0.1 - Orphan mtl instances for ExceptT from transformers-compat  http://hackage.haskell.org/package/mtl-compat-0.1 (ryanglscott)
18:31:45 <Hijiri> maybe you could use pointers to the session?
18:32:16 <Hijiri> and have sess be some interface+abstract wrapper around the ptr
18:33:19 <eacameron> Hijiri: I'm not sure how to obtain a pointer to sess since I can only get it by calling "withSession"
18:35:12 <eacameron> Basically I need to invert the stack somehow.... I need "withSession" to exist *above* my Haskell functions, not below them.
18:35:51 <Hijiri> oh, so the data originates in the haskell and not in the C?
18:35:59 <eacameron> yeah :(
18:36:28 <eacameron> I'm using wreq...it doesn't provide a "newSession" variant, which would solve my problem
18:37:17 <dmwit> eacameron: Have the C code call an interface that you write passing in a FunPtr?
18:37:47 <eacameron> dependency inject C's "main" essentially?
18:37:55 <eacameron> @dmwit ^
18:37:55 <lambdabot> Unknown command, try @list
18:38:16 <dmwit> I don't really understand dependency injection.
18:39:00 <Enigmagic> eacameron: easiest way is to use allocate a StablePtr for the session and dereference it in the callback
18:39:27 <eacameron> Enigmagic: hmmm, I'm not sure how that looks
18:40:14 <eacameron> dmwit: I'm still pondering your idea...
18:40:17 <Enigmagic> eacameron: well do you own the C side of the app? can you pass a void* through the C code into whatever is calling back into haskell?
18:40:17 <dmwit> FunPtr is not what I thought it was.
18:40:21 <dmwit> I retract my suggestion.
18:40:35 <eacameron> Enigmagic: yeah I own the C side. yes
18:41:31 <Enigmagic> eacameron: a `StablePtr a` can be passed through C code
18:42:20 <Enigmagic> eacameron: so if you call `newStablePtr` and give it your Session value it will give you back something safe to hold on to in C
18:42:50 <eacameron> Enigmagic: Ok...so export an "init" function for C to obtain one of these stable ptrs?
18:43:01 <kadoban> Anyone know what PGP key the GHC binaries should be signed with, especially anyone have a key ID?
18:43:20 <eacameron> How do I keep "withSession" from blowing away the sess after I return it in the StablePtr?
18:43:35 <Enigmagic> eacameron: call your C code from within `withSession`
18:43:57 <eacameron> Enigmagic: Ah right. That's what I'm having trouble figuring out how to do...
18:44:20 <eacameron> Enigmagic: Because C owns "main"
18:44:45 <eacameron> Enigmagic: I.e. that stack starts above my Haskell code...
18:45:53 <dmwit> How many functions need to obtain a new session?
18:46:05 <eacameron> dmwit: ideally only one
18:46:31 <eacameron> dmwit: I *think* passing a "main" function pointer is the only sane way....
18:47:03 <dmwit> I mean, if it's just one, then the control inversion ought to be easy.
18:47:10 <Enigmagic> eacameron: if you own the C side, just call into haskell and have haskell call back into C
18:47:31 <dmwit> On Haskell side, "createSessionAndJumpToC = withSession $ \sess -> callTheOneCFunctionThatNeedsAFreshSession"
18:47:37 <eacameron> Enigmagic: ok, yeah it sounds like you and dmwit are hitting on the same thing
18:48:11 <dmwit> If it's more than one, then you need to pass a callback and that's what I was hinting at earlier with FunPtrs, but that's not the right way.
18:48:19 <dmwit> I don't know the right way, but it's probably possible.
18:49:24 <eacameron> dmwit: Yeah I think I didn't realize what you meant. I have multiple threads in C that all want to call into haskell and still share the same state
18:50:14 <eacameron> *where state == session in this case
18:51:30 <eacameron> Enigmatic: I think that's what I'll do...double callbacks!
18:52:55 <Enigmagic> eacameron: that's what i'd do
18:53:48 <eacameron> Enigmagic: dmwit Hijiri thanks
18:55:21 <randomclown> There's a hackage package I'm using and I need to change it slightly. So I've cloned their repository and made my changes. How do I import this directory into my cabal file for my project
18:55:45 <randomclown> cabal submodules anyone?
18:55:51 <Enigmagic> eacameron: it would probably look like one of these https://gist.github.com/NathanHowell/0ece1672ba25f129551a
18:55:55 <dmwit> randomclown: cabal add-src
18:56:21 <dmwit> randomclown: Or, if not using sandboxes, just install the changed package and depend on it.
18:56:30 <Enigmagic> eacameron: updated ..
18:56:38 <joneshf-laptop> I've got some number of test suites, and I don't want a specific one to run all the time. Is there a way to specify this with cabal that doesn't involve enumerating all suites except the one I don't want to run?
18:56:41 <dmwit> randomclown: Though of course if you want to distribute your work on Hackage, you should get your patches merged upstream first.
18:56:55 <randomclown> dmwit: well I need to be able to test them first
18:56:55 <joneshf-laptop> like a flag or some such?
18:57:01 <Enigmagic> eacameron: i think the second approach will work fine since you're bracketed.
18:57:01 <eacameron> Enigmagic: Nice! thanks a ton!
18:57:21 <randomclown> dmwit: how do I install the changed package into my sandbox?
18:58:21 <dmwit> randomclown: cabal sandbox add-source
18:59:44 <randomclown> dmwit: so I give it the folder that contains their .cabal file
18:59:49 <kadoban> Isn't there some example cabal package that show a nice way to set it up? I can't seem to find it in bookmarks/google. Something with separate library, executable and test-suite, etc. ?
18:59:58 <Enigmagic> eacameron: one last update ;-) you'll need to free the wrapper functions using hs_free_fun_ptr otherwise they'll leak.
19:00:04 <randomclown> kadoban: cabal init?
19:00:35 <kadoban> randomclown: Yeah, I thought there was a better example
19:01:24 <JoshWVS> Hi all - beginner looking for some feedback on some code, what's the best way to share it?
19:01:46 <Enigmagic> eacameron: anyhow, that's the last update. freeHaskellFunPtr or hs_free_fun_ptr (from Haskell or C respectively).. that should at least get you pointed in the right direction tho
19:01:46 <dmwit> randomclown: I don't know, but I'm sure the documentation says.
19:02:07 <eacameron> Enigmagic: Yes, excellent, that's what I needed
19:05:25 <JoshWVS> Could anyone give some feedback on a (beginner's) implementation of the Sieve of Eratosthenes?
19:05:51 <Axman6> @where lpaste
19:05:51 <lambdabot> http://lpaste.net/
19:05:54 <Axman6> JoshWVS: ^^^
19:06:05 <JoshWVS> Thanks!
19:07:06 <JoshWVS> Wow - lpaste has already given me 3 suggestions for cleaning it up, but I'd love to get some feedback on the actual code: http://lpaste.net/120061
19:07:22 <bam365> JoshWVS: if you haven't seen it already, https://wiki.haskell.org/Prime_Numbers
19:07:28 <bam365> pretty thorough treatment of prime sieves
19:07:54 <JoshWVS> Hmmm... I'm getting "there is no text on this page"?
19:07:55 <Axman6> you may also like to look at nubBy:
19:07:58 <Axman6> @src nubBy
19:07:58 <lambdabot> nubBy eq []     = []
19:07:58 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
19:08:13 <Sornaensis> @src where
19:08:13 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:08:24 <JoshWVS> Weird, searching for prime numbers turned up the page. Thanks for the tip!
19:08:27 <kadoban> JoshWVS: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf <-- an interesting paper on the subject
19:08:57 <bam365> JoshWVS: sorry, messed up the URI but it sounds like you found it
19:09:22 <JoshWVS> Cool, thanks for the resources all :)
19:10:38 * hackagebot mtl-compat 0.1.1 - Orphan mtl instances for ExceptT from transformers-compat  http://hackage.haskell.org/package/mtl-compat-0.1.1 (ryanglscott)
19:15:11 <shapr> @quote
19:15:11 <lambdabot> alpha123 says: I don't think I have the gonads for monads. :(
19:20:23 <mzero> drives me nuts when people pronounce "Haskell" as if it rhymes with "Pascal"
19:21:00 <jle`> you don't pronounce Pascal as pascull?
19:21:07 <mzero> :-P
19:22:26 <roconnor> I pronounce Pascal as if it rhymes with Haskell ;)
19:23:55 <MrMetric> My pronunciations are: pascal = paskel; haskell = haskel
19:24:41 <MrMetric> Also, whenever I mention Haskell to someone who doesn't know what it is, they think I've said Pascal
19:25:27 <kadoban> MrMetric: Your pronunciations aren't very well specified, heh.
19:25:42 <mzero> and yet, the name "Pascal" is pronounced "pas CAL"  whereas "Haskell" is pronounced "HAS kul"
19:25:49 <jberg_> hey, how would one go about if you were to write an android application in haskell?
19:25:58 <Hijiri> pascalifornia
19:26:09 <MrMetric> kadoban: Eh?
19:26:20 <mzero> someone has written a tool kit for that - android haskell app
19:26:22 <MrMetric> mzero: I'd say it ends with kel, not kul
19:26:37 <Hijiri> it's kul, it's in a mailing list mail somewhere
19:26:53 <geekosaur> I probably wouldn't write one --- targeting ARM is still rather aargh, sadly
19:26:57 <mniip> hæskəl
19:27:27 <mzero> https://www.haskell.org/pipermail/haskell-cafe/2008-January/038756.html
19:27:33 <hypoon> Hey guys, I'm using Control.Concurrent.Chan, and I'm having a strange problem where readChan is hanging, despite the fact that there IS a value in the channel. If I put ANOTHER value in the channel, then readChan will take the earlier value, and (when it comes back up in my loop) will hang again, refusing to read the second value in the chan. Any ideas?
19:27:36 <MrMetric> If you want it to be kul, you should spell it that way
19:27:59 <hsk3> The type of 2 is Num a => a
19:27:59 <hsk3> The type of 2.0 is Fractional a => a
19:28:00 <hsk3> How can I prove that the type of (2 + 2.0) is Fractional a => a
19:28:01 <mzero> It is a person's name - names get special dispensation for spelling, eh?
19:28:01 <hsk3> I know GHCi shows me this result, but how can I figure it out myself?
19:28:15 <shachaf> filter is a pretty strange example of holes being helpful for writing code.
19:28:20 <kadoban> MrMetric: English letters are really bad ways to specify pronunciations, unfortunately. I really don't know what you mean when you say you pronounce them like that.
19:28:26 <shachaf> Since the types hardly guide you at all.
19:28:39 <mzero> hsk3 because of the type of +
19:28:44 <mzero> :t (+)
19:28:44 <lambdabot> Num a => a -> a -> a
19:28:56 <MrMetric> kadoban: Are you a native English speaker?
19:29:01 <mzero> you can infer from that that the two arguments must be the same type
19:29:02 <kadoban> MrMetric: Yes.
19:29:31 <geekosaur> hsk3, simplest is to note that a polymorphic Num value can be used in Fractional context (because Fractional requires Num), but a polymorphic Fractional value cannot be used in any possible Num context
19:29:36 <mniip> if you look at (+)'s signature, and try to impose 'Fractional a' on the second argument
19:29:42 <geekosaur> and (+) forces types to match
19:29:45 <MrMetric> I'd say to pronounce it as it appears, but that could be different if you live in a different country
19:29:47 <mniip> you'll see that the result is now also (Num a, Fractional a) => a
19:30:04 <MrMetric> kadoban: Unfortunately, I do not know the IPA
19:30:14 <mniip> now, if you look at the definition if Fractional, you'll see that it implies Num
19:30:33 <mniip> so (Num a, Fractional a) => a and Fractional a => a are the same thing
19:30:39 <Hijiri> not sure that Haskell is an English name
19:30:43 <kadoban> MrMetric: It could be different if I live in a different county too, heh. Yeah, it's a pain. I just meant to point out that pronunciation arguments go poorly unless well specified…which it's hard to do :-/
19:31:01 <geekosaur> Hijiri, go back far enough and it's not, but it's definitely Anglicized
19:31:04 <MrMetric> kadoban: What country are you in? I'm in BC, Canada
19:31:05 <mzero> Pretty sure it is an English name
19:31:10 <Hijiri> oh
19:31:22 <Hijiri> well it should just be pronounced like curry pronounced it, I guess
19:31:25 <kadoban> I thought it's German? Or maybe I made that up?
19:31:26 <MrMetric> Well, BC is a province, but still
19:31:33 <Hijiri> or maybe how his friends pronounced it?
19:31:36 <mzero> http://en.wikipedia.org/wiki/Haskell_Curry
19:31:37 <kadoban> I'm in US, Phoenix
19:31:55 <MrMetric> I don't suppose currying is related to his last name
19:32:06 <geekosaur> (I note it is quite close to the Hebrew word for knowledge, which can be found in the Bible, and it was A Thing for a long time to give Biblically-inspired names)
19:32:11 <MrMetric> Well, Wikipedia says it is!
19:32:14 <kadoban> MrMetric: Heh, yep it is.
19:32:24 <mniip> according to wikipedia 'hæskəl'
19:32:26 <mzero> also, that page notes the pronounciation:  ˈhæskəl
19:32:30 <MrMetric> That explains it being completely unrelated to what it actually is
19:32:39 <mzero> not the emphasis on first syllable
19:32:39 <geekosaur> (but that does emphatically *not* mean that the Hebrew pronunciation is appropriate)
19:32:57 <mniip> which means the first vowel is like a in 'cat' and second is like a in 'miracle'
19:33:01 <MrMetric> Wikipedia's pronunciation for Haskell says it should be Haskoll
19:33:25 <MrMetric> wut
19:33:42 <MrMetric> Oh, I read it wrong
19:33:54 <MrMetric> It says there is no vowel there
19:33:56 <geekosaur> the second is a schwa, which in English tends to be shaped by what's around it; as I'd pronounce it, it'd be in the vicinity of "o" but not the same
19:34:01 <MrMetric> Haskl
19:34:11 <geekosaur> that's just an implied schwa :[
19:34:12 <geekosaur> :p
19:34:32 <MrMetric> Nah, I'll continue saying it as it appears
19:34:40 <geekosaur> you're going to pronounce *something* in there because of the way our mouths work...
19:34:43 <kadoban> How is Pascal pronounced really then? pass kale?
19:35:06 <joneshf-laptop> does anyone know of code metric tools for haskell?
19:35:22 <joneshf-laptop> seems an empty space
19:35:36 <geekosaur> I haven't heard of any offhand
19:35:47 <hsk3> geekosaur: but 2 is a Num, it may not be Fractional. 2.0 is both Fractional and Num. So how can the result of adding the two be Fractional? That's what I don't get
19:35:47 <MrMetric> joneshf-laptop: I briefly assumed you were talking to me
19:35:57 <hsk3> geekosaur: since 2 may be outside of Fractional
19:36:09 <MrMetric> geekosaur: How about Has-K-L?
19:36:12 <hsk3> geekosaur: and 2.0 inside Fractional. If we visualize Fractional as a subset of Num
19:36:38 <geekosaur> hsk3: in some cases, Num forces a polymorphic context. in this case, it is asserting that 2 can become any value that has a Num instance
19:36:50 <mzero> hsk3: when we say 2 :: (Num a) => a
19:36:54 <geekosaur> anything that has a Fractional instance *must* also have a Num instance
19:37:07 <mzero> it doesn't mean '2' is as general as a Num - that would be very object oriented
19:37:16 <mzero> it means that 2 is at least a Num
19:37:18 <mniip> [06:32:50] <hsk3> geekosaur: but 2 is a Num, it may not be Fractional.
19:37:19 <mniip> it may
19:37:28 <mzero> but it doesn't mean that 2 can't be constrained further
19:37:32 <mniip> it's just that it doesn't have to, yet
19:37:45 <geekosaur> therefore 2 :: Num a => a is able to fit into a Fractional context, since any Fractional context is by necessity also a Num context
19:37:49 <shachaf> What's a good name for the dual of a constraint? I.e. something that gives more freedom/information to the consumer rather than constrain it.
19:38:04 <geekosaur> it constrains the possible types from "any with Num" to "any with Fractional".
19:38:15 <shachaf> (For example the sort of thing you would do with existential types.)
19:38:40 <Rotaerk> is HXT the recommended package for XML parsing?
19:38:47 <geekosaur> (this is the flip side of why you may not say foo :: Bar a => a; foo = <some value of a specific type that happens to have a Bar instance>
19:38:54 <kadoban> shachaf: A "relaxation"? Doesn't sound quite right though.
19:39:04 <mniip> shachaf, a freedom?
19:39:08 <mniip> like in degrees of freedom
19:40:10 <shachaf> I'm not sure that degrees of freedom is quite the right analogy.
19:40:13 <hsk3> interesting...
19:40:29 <geekosaur> in *that* case, the Bar constraint forces you to comply by providing a value that can be any type that is an instance of Bar; when you *use* foo, however, it works the other direction because now it can adapt to any context requiring either Bar or a subset of Bar)
19:42:00 <geekosaur> the most general answer to your question is Hindley-Milner type theory and type unification, but if you look those up you will probably drown in unfamiliar syntax --- type theory uses symbols you are familiar with in ways you are almost certainly not familiar with, if you're asking that kind of question
19:42:47 <geekosaur> (well, except H-M does not cover typeclasses, they're an extension)
19:44:52 <hypoon> Alright, new problem, possibly related: threadDelay 1 hangs. Help?
19:45:33 <tubular> has anyone used the Haskoin SPV node?
19:45:42 <mzero> hypoon: are you running the threaded RT?
19:46:44 <MrMetric> I've made a Mandelbrot set renderer thingy in Haskell, but it's taking the same amount of time (about 4 and a half seconds) for 2 iterations and 4096 iterations, which leads me to believe that I did something wrong
19:48:22 <nshepperd> an Nstraint
19:51:27 <dmwit> hypoon: WFM
19:51:58 <dmwit> hypoon: (...but if you include enough code that we can reproduce your problem, there's a chance we can help.)
19:52:20 <athan> dmwit: Thank you for everything you've helped me with, your kindness is incredible :). The idea is this - I want lambdas and your own expressions to be the user-level experience, and packages as other people's expressions, where you're less likely to edit their expressions, but moreso their lambdas. In my system, text files become lambdas, and a `./.ltext` file will hold the expression. Then, when you _use_ someone else's expressions, you just use their
19:52:21 <athan> directory path as a term. But, if you want to hack their work, you're more likely to change the lambdas / files (adding a new parameter, etc.). I wouldn't say this method is superior to others in any way, but I would say that it's more convenient when managing lambdas and your own expressions, while still handling excess parameters "easily".
19:53:07 <athan> +
19:53:16 <dmwit> athan: It was suggested to me that I was overly harsh earlier. I apologize for that.
19:53:59 <athan> huh... my power outlet is shorting my keyboard...
19:54:04 <athan> No way :)
19:54:44 <athan> dmwit: I can't wait to formalize this to the proper standard. It's something I can do, you know?
19:55:03 <dmwit> Should be a fun project.
19:55:32 <athan> :)
19:55:43 <athan> (how do I get into school?)
19:57:25 <MrMetric> Lots of ping timeouts, eh?
19:57:47 <mniip> that's 8
19:57:56 <mniip> not even a 3-digit number
19:58:27 <dmwit> athan: I'm probably the worst person to ask about that. I don't really know how I got in, and perpetually felt that I didn't belong. But: http://academia.stackexchange.com/questions/tagged/graduate-admissions may have something of interest.
19:58:43 <athan> :) Thank you!!
19:59:13 <hypoon> mzero: I realized that might be important shortly after I asked in here. That could be the issue with Chan too. I'm testing that now.
19:59:25 <hypoon> dmwit: WFM? I don't know what that means
19:59:43 <lispy> works for me?
19:59:49 <dmwit> hypoon: "works for me", a snarky reply
20:00:25 <lispy> IRC provides you with your daily dose of vitamin s (vitamin snark)
20:01:32 <hypoon> dmwit: Well, since adding the -threaded flag, I'm now hanging before I even get to threadDelay, so... shit.
20:02:14 <lpaste> xenagi pasted “mcc” at http://lpaste.net/120064
20:02:29 <lispy> hypoon: How are you checking where you hang?
20:02:30 <xenagi> can someone help me with my code? I'm pretty new to Haskell
20:02:44 <dmwit> :t digitToInt
20:02:45 <lambdabot> Char -> Int
20:03:09 <dmwit> :t chunksOf
20:03:10 <lambdabot> Int -> [e] -> [[e]]
20:03:20 <hypoon> lispy: putStrLn, with hSetBuffering stdout LineBuffering early in my code.
20:03:49 <dmwit> hypoon: Can you share a minimal hanging example?
20:04:02 <lispy> hypoon: cool.
20:04:16 <lispy> hypoon: You might even try the no buffer variant
20:04:25 <lispy> or add hFlush
20:04:37 * lispy is probably just paranoid
20:04:45 <dmwit> xenagi: Probably just need to convert your Nibbles into Bytes before doing arithmetic in nibbleConcat.
20:05:27 <hypoon> lispy: I was trying hFlush at one point
20:05:39 <technomad> hello all
20:05:45 <MrMetric> Hay
20:05:51 <lispy> myPutStrLn s = putStrLn s >> hFlush stdout
20:06:15 <hypoon> dmwit: I've been thinking about that. This code has gotten very complex with lots of separate files... I've been torn over whether I can simplify it enough for pastebin.
20:06:15 <technomad> how long does anyone think it would take to get through Learn You a Haskell
20:06:29 <technomad> in hours, say
20:06:49 <lispy> hypoon: Often times just the exercise of minimising the problem is enough to lead you to the solution
20:07:10 <lispy> hypoon: If there is one practice that I wish I would have adopted earlier in my career, that is it
20:07:12 <mniip> why are there no parsing expression grammar libs in haskell
20:07:25 <mzero> technomad: that would vary considerably by how much CS experience you have
20:07:36 <hypoon> lispy: And now that I add more putStrLn in, the behavior is changing. This is getting really frustrating.
20:07:41 <mzero> anywhere from 8 to 80 hours I imagine
20:07:50 <technomad> mzero i just graduated from purdue with a cs undergrad
20:07:53 <dmwit> mniip: My Google search for "peg haskell" turns up results.
20:08:01 <technomad> i've done some FP stuff before but i'd like to drown in it for a while
20:08:23 <technomad> we spent a good while on ML
20:08:37 <lispy> technomad: I wouldn't start with learn you a haskell in that case.
20:08:39 <kadoban> technomad: I'd suggest doing cis194 instead, which has exercises and points to relavent readings in LYAH and RWH. https://github.com/bitemyapp/learnhaskell Has more recommendations
20:08:55 <lispy> technomad: there are better books for people with a stronger background
20:09:01 <hypoon> lispy:never mind, still being as inconsistent as usual.
20:09:06 <xenagi> dmwit, hmmm... I'm trying that but `a::Byte * 2^4 + b::Byte` doesn't seem to work. Is that right? Can I just "cast" it to a Byte?
20:09:16 <peddie> @hackage frisby mniip
20:09:17 <lambdabot> http://hackage.haskell.org/package/frisby mniip
20:09:31 <dmwit> xenagi: Yes, you need to actually convert, not just claim it has a different type. =P
20:09:36 <dmwit> :t fromIntegral
20:09:37 <lambdabot> (Num b, Integral a) => a -> b
20:10:02 <peddie> @hackage peggy mniip
20:10:02 <lambdabot> http://hackage.haskell.org/package/peggy mniip
20:10:06 <MrMetric> "I'm killing your brain like a poisonous mushroom"
20:10:19 <MrMetric> Yep, adding fromIntegral before a and b fixes it
20:10:32 <hypoon> lispy: I've gotten it to a point where it appears to be hanging ON the putstrln, which obviously makes little sense. I'll try no buffer AND flushing immediately afterward.
20:10:46 <mniip> peggy is TH right
20:11:45 <peddie> mniip: I think so
20:12:13 <technomad> lispy kadoban cool thanks i'll check these out
20:12:35 <technomad> and i'm assuming everyone here would recommend haskell over ocaml right? :D
20:12:45 <lispy> technomad: I'd even recommend F# over ocaml
20:12:58 <lispy> (and rust)
20:13:06 <lispy> Should I keep going? :)
20:13:09 <MrMetric> technomad: I've never used OCaml, therefore yes
20:13:15 <kadoban> technomad: Of course ;) (I don't really know anything about ocaml, except I didn't like the look of it)
20:13:19 <technomad> lols ok cool
20:13:30 <technomad> yeah it's not very aesthetically appealing from the code i've looked at
20:13:34 <technomad> but ocaml has mirageOS
20:13:39 <technomad> unikernels are cool
20:13:39 <lispy> and we have halvm
20:13:48 <xenagi> unikernals ARE cool technomad
20:13:50 <technomad> is halvm as well supported etc?
20:13:57 <lispy> https://github.com/GaloisInc/HaLVM
20:13:58 <MrMetric> I've never seen any OCaml code. I'll hafta look now. The site says "OCaml is an industrial strength programming language supporting functional, imperative and object-oriented styles"
20:14:18 <xenagi> what about SML? Is SML still in use these days?
20:14:23 <lispy> technomad: it's older, but we (Galois) probably don't put as much person-power behind maintaining it as mirage gets
20:14:52 <technomad> community matters a lot for these sorts of things
20:14:59 <lispy> True
20:15:05 <MrMetric> I am immediately put off by an OCaml code example containing double-semicolons
20:15:27 <lispy> MrMetric: I find 31 bit ints to be more annoying
20:15:39 <MrMetric> lispy: …31-bit ints?
20:15:50 <lispy> and the restriction of pattern matching one thing per definition. So y ou can't do foo (x:xs) (y:ys)
20:16:11 <technomad> wait are those both real aspects of ocaml
20:16:13 <lispy> MrMetric: yeah, because the GC scheme uses tagged pointers. Haskell allows that, but GHC doesn't do it
20:16:34 <dmwit> On OCaml: The implementation is the spec. And there's no helping you if you need to use the FFI.
20:16:44 <technomad> dmwit FFI?
20:16:51 <dmwit> technomad: interface with C
20:17:34 <technomad> what does the acronym stand for dmwit
20:17:48 <lispy> foreign function interface
20:17:48 <MrMetric> Hmm, hlint says I should be using camelCase instead of underscore thingies
20:18:02 <technomad> i would google it but my interwebs connection is apparently only capable of supporting irc right now
20:18:05 <technomad> ah ok
20:18:49 <hypoon> Alright guys. Why doesn't this behave as I would expect? http://pastebin.com/882HcyTP
20:18:56 <hypoon> lispy: see above.
20:18:56 <kadoban> MrMetric: In Haskell it does make sense. The thing is, you have to use capital letters for some stuff, and then _ gets a bit…ugly.
20:19:06 <lispy> hypoon: looking
20:19:23 <hypoon> dmwit: the above link doesn't hang in exactly the same way, but it might hang for the same reason. I'm not sure.
20:19:27 <MrMetric> kadoban: but camelCase bugs me ._.
20:19:36 <lispy> hypoon: and how do you compile it?
20:19:40 <lispy> hypoon: -threaded?
20:19:56 <geekosaur> oh dear, yes
20:19:57 <hypoon> lispy: ghc --make -threaded -optc -std=c99 blah.hs
20:20:00 <kadoban> MrMetric: Best to just get used to it if you can :-/ It's not that bad. I used to use blah_blah too, most of the time.
20:20:33 <geekosaur> hm, is +RTS -N1 still the default?
20:20:50 <MrMetric> kadoban: I used to use camelCase, but I've found underscores to be better for situations such as a word that has to start with a lowercase letter, or a 1-char word
20:20:53 <hypoon> lispy: granted, yeah, it pins one of my CPU cores, as expected, but the other thread should keep going, right?
20:20:55 <dmwit> hypoon: wow, cool
20:21:06 <dmwit> ?src forever
20:21:07 <lambdabot> Source not found.
20:21:08 <geekosaur> if it's only using one OS thread, no
20:21:35 <geekosaur> because ghc tends to switch threads on memory allocations and IO, and your child thread isn't doing memory allocations or IO
20:21:35 <dmwit> geekosaur: It totally should. Every (>>) in the forever ought to be a yield point, oughtn't it?
20:21:57 <geekosaur> and -N1 (run on one OS thread) means they can't run concurrently
20:22:12 <geekosaur> which is why I asked if -N1 is still default
20:22:20 <dmwit> Seems geekosaur is right. Changing "return ()" to "yield" makes it work correctly.
20:22:55 <technomad> lispy is cis194 only a 3 week course?
20:22:56 <dfeuer> geekosaur seems to be right most of the time.
20:23:00 <lispy> I added +RTS -N2 and it still hung for me
20:23:03 <geekosaur> hah. I wish
20:23:06 <kadoban> MrMetric: Yeah, those are the cons. The thing is, you /have/ to capitalize like types in haskell, so then your choices are Blah_Blah_Type, which looks ridiculous, or having a totally different Blah_blah_type, which looks even worse, or else using camelCase for types, and a totally different scheme for everything else, which strikes me as even uglier than just doing camelcase. If you really don't want to, there's probably some way to turn off
20:23:07 <kadoban> that warning in hlint.
20:23:07 <lispy> technomad: Dunno, I'm not familiar with it
20:23:24 <dfeuer> geekosaur is at least right more often than dfeuer :-P
20:23:27 <hypoon> dmwit: geekosaur: I'm not actually using forever in my unsimplified code. I'm using something else, but which also loops infinitely.
20:23:28 <geekosaur> I am less certain of how thread switching / scheduling works with multiple OS threads
20:23:29 <technomad> lispy oh wait scratch that
20:23:30 <xenagi> YES! it worked. thanks dmwit
20:23:43 * technomad feels stupid for looking at the spring 2015 course page
20:23:47 <geekosaur> but I can say with reasonable certainty that non-threaded or threaded+-N1 won't work there
20:24:01 <technomad> lispy whoops it was kadoban who rec'd it
20:24:29 <geekosaur> since ghc uses an n:m thread model, what giving it more cores will do is not entirely clear-cut
20:25:02 <dmwit> hypoon: easy answer is to toss a yield in at least once per loop
20:25:02 <geekosaur> and I haven't studied the thread scheduling in enough detail to have an idea :(
20:25:39 <hypoon> lispy: geekosaur: I'm getting "channel opened" "begin thread delay" if I use +RTS -N2
20:26:42 <hypoon> dmwit: The problem is it blocks, waiting for network IO. How do I put a yield in with a blocking function?
20:26:43 <lispy> I even tried calling setNumCapabilities 2
20:26:57 <hypoon> dmwit: (referring to my actual unsimplified code)
20:26:59 <lispy> But for me it hangs after "channel opened"
20:27:12 <geekosaur> hypoon: that does I/O and should implicitly yield
20:27:22 <kadoban> technomad: I dunno, I'd just do it at your own pace. Yeah make sure you do the one linked from that page I linked, it's changed since and is less useful.
20:27:39 <hypoon> geekosaur: well... it just sits there waiting on the threadDelay in that case.
20:27:44 <Axman6> iirc, a thread which allocates memory also yeilds
20:28:03 <geekosaur> yes, I mentioned that earlier
20:29:19 <geekosaur> I do recall that some of the network functions at least used to be tagged "won't block" when they could --- but that was (and was reported) long enough ago that it shouldn't be an issue here
20:29:30 <technomad> gotcha ty kadoban
20:29:33 <technomad> i shall return
20:29:56 <geekosaur> (if that is it then forcing a core dump and inspecting it with gdb/lldb/whatever should get you a backtrace starting in C)
20:30:33 <geekosaur> (that said, it's not something I normally recommend doing with a Haskell program because ghc stack traces are not particularly meaningful...)
20:30:46 <hypoon> geekosaur: I'm using network functions via FFI from SDL, not haskell ones.
20:31:21 <geekosaur> um? in that case you probably need to be doing this in the context of SDL's main loop
20:31:44 <geekosaur> (and SDL probably could benefit from a more Hakselly wrapper to make you use it that way)
20:32:08 <hypoon> geekosaur: hm? I don't completely understand.
20:32:13 <geekosaur> otherwise I would expect it either to throw an exception or block until the SDL main loop runs
20:32:24 <geekosaur> hypoon: SDL is an event-oriented interface
20:32:35 <geekosaur> as such, events are only processed when its main event loop is running
20:32:41 <hypoon> geekosaur: I initialize SDL and its networking stuff in the very beginning.
20:32:58 <geekosaur> but do you invoke its main loop and then call your functions from an appropriate callback?
20:33:07 <geekosaur> initializing SDL is not sufficient
20:33:18 <hypoon> geekosaur: "from an appropriate callback" <-- what do you mean by this?
20:33:20 <geekosaur> its main event processing loop must run for it to process events, such as network events
20:33:25 <geekosaur> oh, dear
20:33:55 <geekosaur> do you understand event-driven programming at all?
20:34:05 <geekosaur> your example code is not event-based
20:34:11 <hypoon> geekosaur: perhaps not.
20:34:13 <geekosaur> SDL is event based
20:34:43 <hypoon> geekosaur: rather, perhaps I do not understand event-driven programming, I mean.
20:35:12 <geekosaur> which means it does nothing whatsoever unless its main event loop is running. so, to do something initially you need to "preload" an initial event from which you can do things under control of the main loop. this is usually an idle-time event
20:35:23 <geekosaur> (that is, fired when no other events are waiting to be processed)
20:35:34 <tubular> my ghci prompt includes all the imported modules for that session, for some reason -- like "Prelude Data.ByteString Control.Monad>"
20:35:40 <tubular> it gets pretty long; what do you guys do for this?
20:36:00 <dmwit> tubular: I live with it. Others set their prompt to something shorter.
20:36:10 <geekosaur> if you call a function that processes, say, a network event, and you are not in the main event loop, it will block until the main event loop runs so that the event it is blocking on can be sent to it
20:36:15 <dmwit> tubular: (But which does not show which modules are imported.)
20:36:45 <hypoon> geekosaur: I think I follow you so far
20:36:47 <mzero> edit  ~/.ghc/ghci.conf  to have    :set prompt "λ: "
20:36:56 <tubular> yeah, I guess it's not so bad. it just gets annoying when I'm in a pane and my ghci prompt wraps through a line or two
20:37:47 <lispy> my .ghci is :set prompt "%s λ> "
20:37:49 <geekosaur> so if the first thing you do is wait for a network connection, via an SDL function, what that really means is that the thread blocks until the SDL event loop receives a network connection, which it then dispatches to your thread because it's blocked waiting for it
20:38:23 <hypoon> geekosaur: I kinda would expect my initialization of SDL to simply start up a main loop in a separate thread then, but I guess it doesn't do this? I don't understand how /any/ of the simpler SDL stuff normally works then.
20:38:37 <geekosaur> (ghc actually does the same thing, but can do it behind your back so you just write normal-looking code. but with SDL, the event loop is a chunk of C++ from the SDL library and it can't be easily hidden from Haskell)
20:38:55 <geekosaur> your main thread calls the SDL main loop
20:39:43 <geekosaur> this is blocking until the SDL main loop exits, usually because something requests it (say, it received an event whih it understands as "please quit", and calls back into SDL to ask it to terminate its event loop)
20:41:24 <hypoon> geekosaur: my main thread runs "SDL_Init(SDL_INIT_VIDEO);" pretty early on, followed by SDLNet_Init. These don't block....
20:41:57 <lf94> How do you check to see what type something is again?
20:41:59 <geekosaur> ok, it looks like there is no canned main loop function (this is actually good as it'd be all in C++ and causes issues with doing housekeeping type stuff)
20:42:07 <lf94> > replace "\"" "" . replace "," "\n"
20:42:09 <lambdabot>  Not in scope: ‘replace’
20:42:09 <lambdabot>  Perhaps you meant ‘replay’ (imported from Lambdabot.Plugin.Haskell.Eval.Trus...
20:42:09 <lambdabot>  Perhaps you meant ‘replay’ (imported from Lambdabot.Plugin.Haskell.Eval.Trus...
20:42:48 <dmwit> lf94: Use :t in ghci.
20:43:16 <lf94> Ok :)
20:43:18 <lf94> Thanks
20:43:24 <geekosaur> hypoon: what you need to do is that your main thread invokes "pollEvent" and does something with the returned event (or exits if the event is Quit). see https://hackage.haskell.org/package/reactive-banana-sdl-0.2.0/docs/src/Reactive-Banana-SDL.html for one example (likely out of date, quite possibly not an ideal way to do it for your use)
20:44:35 <geekosaur> but if you're not polling and dispatching events from the main thread, things like SDL network operations will simply block until you start dispatching events
20:45:34 <geekosaur> unfortunately I am not an expert on how you use SDL
20:45:54 <hypoon> I'm trying to remember back to some stuff I was reading a long time ago. I think that importing the SDL libraries does some funny stuff. They define their own main loop, and the "main loop" that I define actually isn't the real main loop anymore. Is that understanding correct?
20:46:05 <geekosaur> I'm just familiar with event-driven programming in general, and one of the maintainers of another package which relies on an external (non-Haskell / FFI) event loop, namely xmonad which uses X11's event loop
20:46:26 <geekosaur> that is a loose description of what I've been trying to explain to you, yes
20:46:57 <geekosaur> that "main loop" is the main event loop
20:47:39 <hypoon> So what happens to what I'm designating as my main loop in haskell? Does that screw with SDL's main loop? is that what's going on?
20:47:40 <geekosaur> if you call an SDL function that expects to block waiting for something (network connection, keystroke, etc.), it is not blocking directly on that; it is waiting for SDL's main loop to *send* it the corresponding SDL event
20:47:56 <geekosaur> if you are not invoking SDL's main loop, it will not be sent any events and will block forever
20:48:26 <geekosaur> it's not *running* SDL's main loop
20:48:31 <MrMetric> I messed up a formula in my fractal renderer (likely because I'm still learning Haskell), but that's okay because the resulting image is beautiful
20:48:37 <geekosaur> the main loop is not some magical thing that happens by itself
20:48:58 <geekosaur> it's not like the SDL library forks off a separate thread that does things and calls back into your Haskell program
20:49:01 <tubular> is it possible to do `import qualified Module as M (x, y)` such that you can access all of Module's exports in the `M.` namespace, but you can access `x` and `y` directly without qualifying?
20:49:46 <geekosaur> you need to "pump" its event loop by calling Graphics.UI.SDL.Events.pollEvent (which in most programs is just "pollEvent")
20:50:08 <dmwit> tubular: import twice
20:50:11 <geekosaur> tubular, not in a single step. you will see things like "import qualified Data.Map as M; import Data.Map (Map)" in code
20:50:16 <dmwit> import Module (x, y); import Module as M
20:50:24 <tubular> dmwit: I see; thanks!
20:50:26 <geekosaur> so Map is usable unqualified but the rest of the module is M.function
20:50:27 <dmwit> second one should be qualified, of course
20:50:29 <dmwit> just a typo
20:50:35 <tubular> makes sense
20:51:26 <geekosaur> hypoon: this is more difficult than it might be because Haskell has its own event loop, and SDL has its own event loop, and it's pretty much impossible to mash two event loops together automatically and have the result actually work
20:52:03 <geekosaur> so you have to invoke the foreign event loop yourself from Haskell (pollEvent for SDL, nextEvent for X11, ...)
20:52:52 <hypoon> geekosaur: Ok, there's two main loops here, haskell's and SDL's. Normally, the "real" main loop is haskell's main, but I was thinking that importing SDL caused the "real" main loop to be SDL's, and that it would use its normal magic to make haskell's main loop run (whatever magic it normally uses to make the main loop one would define in C to run).
20:53:11 <geekosaur> (in effect, SDL is providing the "event" part of the event loop, and your program is providing the "loop" part by calling pollEvent periodically)
20:53:39 <geekosaur> I can only repeat what I already said: [06 04:48] <geekosaur> hypoon: this is more difficult than it might be because Haskell has its own event loop, and SDL has its own event loop, and it's pretty much impossible to mash two event loops together automatically and have the result actually work
20:53:46 <hypoon> meaning, when I run my binary, I thought the main loop in my binary is actually SDL's, and the "main" loop I defined in haskell was actually something that SDL chainloads, so to speak.
20:53:57 <hypoon> hm
20:54:04 <hypoon> this was not intended to be so difficult
20:54:44 <dmwit> If the SDL maintainers really loved you, they would have taught GHC's IO manager about SDL.
20:54:46 <hypoon> Ok, let's take a million steps backward, and pretend I'm not going to be disappointed by discarding a lot of work that almost functions.
20:55:24 <hypoon> I'm attempting to write a 2D mmo in Haskell.
20:55:30 <geekosaur> it would be nice if event loops composed even as well as monads do, much less properly composable things. sadly, they don't
20:55:42 <hypoon> for 2D animated graphics, I was opting for SDL, but perhaps that was a mistake.
20:55:49 <dmwit> That's a fine choice.
20:55:55 <geekosaur> I think you will face this no matter what
20:55:58 <dmwit> It's not like other choices are going to be different in this regard.
20:56:09 <geekosaur> because every graphics library comes with its own event loop somehow
20:56:28 <geekosaur> even if it's inheriting OpenGL's or X11's or Win32's or ...
20:56:29 <hypoon> Since I was using SDL for 2D graphics, I figured I would also use SDL's networking stack.
20:57:23 <hypoon> I've never had a problem using SDL for 2D graphics in Haskell, even with keyboard interaction and all.
20:57:41 <hypoon> Would my life be easier if I used a networking stack that was native to Haskell instead?
20:58:42 <geekosaur> but are you using SDL events for input there? if so, you would have to run SDL's event processing; if you handle keyboard stuff yourself, you can almost get away without (you will probably find that things like resizing windows don't quite work, if you don't have a resize handler that re-lays-out the window)
20:59:05 <geekosaur> liekwise if you use SDL network functions then you need to be running SDL's event processing
20:59:53 <hypoon> geekosaur: I'm handling keyboard stuff using SDL's framework
21:00:24 <hypoon> geekosaur: All my 2D graphics stuff has always been single-threaded though.
21:00:33 <hypoon> geekosaur: Is that why it worked?
21:00:39 <geekosaur> and you've never encountered pollEvent?
21:00:42 <MrMetric> SDL, you say?
21:00:49 <MrMetric> I don't suppose SFML has a Haskell thingy
21:00:55 <hypoon> geekosaur: Not directly, no.
21:01:02 <geekosaur> maybe it caters to improper programming by pumping the event loop in that cased --- but the same may well not be true for network functions
21:01:36 <hypoon> geekosaur: when you program with SDL in C or C++, you don't have to pump the event loop directly.
21:01:50 <geekosaur> the expectation is that you are using its event loop; all bets are off if you don't, it may happen to work for some things but it's not really possible for an event-based library to *always* hide from naive programmers that they need to be running the event loop
21:01:56 <hypoon> OOH, wait, heads up: I don't know if this makes a difference. I'm using SDL2, not SDL.
21:02:18 <geekosaur> hm. SDL2 did change things, and I've been looking at SDL(1) bindings
21:02:56 <geekosaur> in any case this means I'm not going to be able to help you --- but I would bet that you do in fact need to run its event loop for things like network events to be processed
21:03:32 <hypoon> geekosaur: hm. One sec, I have an idea
21:04:54 <hypoon> geekosaur: this is old, before I was doing any networking at all. I think it's the farthest I got before attempting networking, which would have been fully working 2d stuff. https://github.com/Hypoon/Green
21:06:16 <geekosaur> you see that "run" funcrion? it's your event loop, and it's pumping the SDL event loop
21:06:45 <geekosaur> implicitly because the various things you are calling must pump the event loop to work
21:07:16 <hypoon> geekosaur: I see... ok...
21:07:25 <geekosaur> if the network operations don't do that implicit part for you then you need to do it explicitly. which is why the thing I pointed to you earlier was doing it explicitly; implicit only works up to a point
21:07:33 <geekosaur> and then you get functions that hang forever
21:08:18 * geekosaur notes that it is midnight here and he's going to have to sleep soon or pay for it tomorrow...
21:08:32 <hypoon> geekosaur: I'm in the same boat, time wise.
21:08:52 <geekosaur> (I'm in my 50s, I don't get to pull all-nighters any more)
21:09:23 <hypoon> geekosaur: any idea what's pumping the event loop? do you think it's when I render?
21:10:37 <hypoon> geekosaur: As an alternative, before you go, let me ask this: since implicit pumping is functioning well for graphics, is there another networking stack that would make my life easier that you can recommend? I opted for SDL's only because I figured it would be nicely cross platform.
21:11:14 <geekosaur> I don't know enough SDL to be certain
21:11:34 <EvanR_> SDLnet isn't a good idea even if you didn't have haskell
21:11:51 <EvanR_> just haskell's network lib is better
21:12:00 <hypoon> EvanR_: Can you recommend an alternative?
21:12:07 <geekosaur> if you're not willing to figure out SDL's event loop, you probably want to use Network.Socket (Network claims to be a higher level interface but it has many shortcomings)
21:12:27 <geekosaur> (but it may be good enough for your purposes; I could not say)
21:13:32 <EvanR_> hypoon: you should be able to use haskells threads with haskells network, and use that to push custom events into SDL if thats what youre program is based on
21:13:38 <EvanR_> your
21:13:46 <hypoon> What can I expect from trying to use Haskell's Network.Socket on one side, and something non-haskell on the other?
21:14:03 <EvanR_> thats the beauty of sockets, its not a language thing
21:14:09 <EvanR_> its the standard interface now
21:14:46 <EvanR_> but like geekosaur said Network (without .Socket) might be good enough and its way simpler
21:14:52 <hypoon> Oh? Sockets are standardized? I didn't realize that. I figured it was a common concept, but I didn't realize different implementations would interact nicely.
21:15:02 <EvanR_> of course
21:15:10 <geekosaur> probably nothing out of the ordinary, because of Haskell's event interface. the main point of SDL having network support is so you're not blocking SDL's event processing waiting on the network... but Haskell using its own event loop means if you write it properly, the Haskell network stuff will not block SDL
21:15:40 <geekosaur> sockets are mostly standardized. winsock is still a bit of a weird beast compared to posix sockets, for example
21:15:55 <geekosaur> but sdl and haskell use the same system socket interface
21:16:36 <EvanR_> SDLnet gives you non-blocking sockets, which is a silly way to do networking. SDL gives you a wrapper around pthreads which is a silly way to do threads
21:17:48 <hypoon> I knew I was going to run into issues soon due to the idea of spawning threads for each client. If a server has thousands of clients connect, that's thousands of threads, and I didn't know if that was safe. I knew I was going to have to rewrite my server code anyway, I might as well abandon SDL altogether for that. I can't think of any reason to run SDL on the server if I don't need it for SDLnet on the client side.
21:18:03 <EvanR_> thousands of threads in haskell is probably ok
21:18:43 <EvanR_> thousands of network connections on one machine? who knows
21:20:21 <hypoon> EvanR_: well, it has to work somehow... There are surely servers who host games with thousands of simultaneously connected players. Sometimes it's multiple servers acting as a cluster, yeah, but I can't imagine there aren't times when it's all run on one server.
21:20:27 <pacak> EvanR_: http://c10m.robertgraham.com/p/manifesto.html
21:20:48 <pacak> EvanR_: And c10k problem as well.
21:20:56 <EvanR_> yeah, MMOs can do it (can do something) so since its possible, i should do it
21:22:15 <EvanR_> hypoon: for just networking, in a haskell program, theres no reason to use SDLnet
21:22:30 <EvanR_> last time i used it they didnt even support IPv6
21:24:19 <hypoon> EvanR_: For the server side, I'm definitely abandoning it. For the client side, I'm not sure. Wait, no IPv6? (*double checking, I never considered that, but it would be a deal-breaker*)
21:24:51 <EvanR_> old SDLnet assumes the old sockets api, assumes ipv4. im trying to get the docs for "SDL2_net"
21:25:13 <hypoon> EvanR_: confirmed, no ipv6 as far as I can tell
21:25:22 <hypoon> EvanR_: https://www.libsdl.org/projects/SDL_net/docs/SDL_net.html
21:25:37 <EvanR_> i found those, they look identical to old SDL_net stuff
21:26:01 <hypoon> EvanR_: My understanding is it's simply been ported
21:26:36 <EvanR_> yeah http://hg.libsdl.org/SDL_net/file/4f66334b0247/SDL_net.h#l90
21:27:06 <EvanR_> SDL_net was just a simple wrapper around the socket api, with very little to adjust for the little weirdness there is on windows
21:27:27 <EvanR_> but they didnt update it for the shift to protocol agnostic
21:27:34 <EvanR_> it would have broken a lot of games
21:28:17 <EvanR_> except i patched SDL_net to work seamlessly with new sockets... and it never made it in :(
21:28:39 <jimboslice> Can anyone help a noob figure out what <$> means, as shown here: http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html
21:28:52 <EvanR_> @src (<$>)
21:28:52 <lambdabot> f <$> a = fmap f a
21:29:03 <EvanR_> :t fmap
21:29:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:29:15 <jimboslice> Ah, thanks
21:29:17 <EvanR_> Functor f => (a -> b) -> (f a -> f b)
21:30:00 <hypoon> EvanR_: so now I don't want to use SDLnet even for the client side... I guess I'll start playing with haskell networking and then worry about blocking SDL if it happens. Maybe if I do all of my networking in a separate thread, I'll be OK?
21:30:14 <EvanR_> definitely
21:31:55 <EvanR_> you might want to read the man pages to familiarize yourself with the sockets api, connect, recv, send, listen, accept, etc
21:31:59 <hypoon> Alright. I have my work cut out for me then. For now, I'm heading to bed.
21:32:29 <hypoon> the man pages for unix sockets in general you mean?
21:32:49 <EvanR_> its almost identical on win32
21:32:57 <EvanR_> just the man pages make less sense on windows
21:33:23 <hypoon> EvanR_: I'm just clarifying that you mean general sockets stuff, not haskell stuff.
21:33:34 <EvanR_> yes
21:34:25 <hypoon> Ok, that's probably a very good idea. Thank you for your time.
21:35:36 <hypoon> Thank you geekosaur, lispy, dmwit, you've been a huge help!
21:35:48 * hackagebot intervals 0.7.1 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.7.1 (EdwardKmett)
21:35:50 <hypoon> (as have you, EvanR_)
21:35:56 <hypoon> Have a good night all!
21:39:32 <malone> what would be the easiest way of controlling some mains powered device with a pc
21:39:43 <malone> sorry wrong channel :/
21:41:44 <randomclown> is there a monoid concatMap?
21:42:03 <randomclown> shorthand for mconcat $ map
21:42:23 <mzero> or    mconcat . map    rather?
21:42:28 <mzero> no, not that I know of
21:43:39 <mzero> oh wait
21:43:40 <mzero> duh
21:43:42 <mzero> foldMap
21:44:03 <mzero> what you want is    (Monoid m) => (a -> m) -> [a] -> m
21:44:04 <mzero> right?
21:44:11 <randomclown> why is it fold map though
21:44:31 <lfairy> randomclown: because foldMap f = fold . map f
21:45:20 <lfairy> ;)
21:45:55 <mzero> well, randomclown, is is perhaps mconcat that is oddly named!
21:46:33 <mzero> anyhow...    fold === mconcat    for lists
21:46:40 <shachaf> foldMap exists because it makes sense to define it even for things that don't have map.
21:46:42 <mzero> :t fold
21:46:43 <lambdabot> (Monoid m, Foldable t) => t m -> m
21:46:48 <mzero> :t mconcat
21:46:49 <lambdabot> Monoid a => [a] -> a
21:47:43 <lfairy> shachaf: out of curiosity, what types implement Foldable but not Functor?
21:47:50 <dolio> Set
21:48:29 <shachaf> And of course the idea of "functions like foldMap" is much more general than Foldable.
21:48:46 <lfairy> ooh
21:50:12 <athan> hm... so I came up with a better type syntax for that weird crap I'm doing: `($) : forall a. {a >= 2, a.1 >= 1} => a; f $ x = f x`
21:50:45 <athan> which can be... nice :)
21:51:24 <osa1> that feeling when my 146 loc ncurses gui doesn't actually draw anything
21:51:42 <athan> :(
21:51:49 * athan pats osa1
21:51:56 <athan> don't let it slow you down
21:52:05 <osa1> I won't!!1
21:52:11 <osa1> any ideas why this is not a monoid http://hackage.haskell.org/package/ncurses-0.2.11/docs/UI-NCurses.html#t:Update ?
21:52:12 <wyager> Hi guys. I'm using the Dimensional library. I have a quantity that is of type "Quantity d a". GHC infers this type just fine. I verified it with a typed hole. However, if I put a type annotation (i.e. I add  ":: Quantity d a"), GHC complains that it cannot deduce a bunch of type equivalences. Is this a limitation of GHC with regard to numeric types?
21:52:13 <athan> :)
21:52:38 <EvanR_> osa1: im waiting for meme of that one to come out
21:52:54 <osa1> heh
21:53:24 <EvanR_> osa1: start with the most minimal thing that does draw something and work from there
21:53:32 <EvanR_> then you know what you just did is what made it broke
21:54:03 <osa1> yeah that would also help decouple the drawing code from rest of the program
21:54:16 <osa1> uhh it's 1AM
21:54:30 <EvanR_> the witching hour
21:59:34 <wyager> If I have a value of type "Quantity d a", how do I multiply it by a scalar of 0.001?
22:00:02 <mzero> ya know, I've never made heads nor tails of that package!
22:02:11 <shachaf> whoa, type functions with fundeps
22:02:23 <shachaf> Haven't seen that around in a while.
22:10:36 <gamegoblin> If I have something like an initial value of type t, and a function of type t -> (t,s), is there an elegant way to "unroll" this by repetively applying the function to the last outputted t
22:10:42 <gamegoblin> and get a list of s
22:11:28 <gamegoblin> pretty easy to do it with a custom recursive function, was just wondering if there was some prelude combo I wasn’t thinking of
22:11:34 <gamegoblin> iterate or something
22:11:36 <gamegoblin> :t iterate
22:11:37 <lambdabot> (a -> a) -> a -> [a]
22:11:43 <gamegoblin> mm....
22:15:16 <pacak> > take 10 $ let f = (succ &&& show) ; gs = f 1 : [f i | (i, _) <- gs] in map snd gs
22:15:19 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
22:15:26 <wyager> :t scanl
22:15:27 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
22:16:39 <gamegoblin> pacak: that’s basically what I wound up doing
22:16:53 <wyager> Couldn've sworn there was a function just for this, gamegoblin
22:17:12 <gamegoblin> Ended up defining
22:17:13 <gamegoblin> unroll r = let (w, r') = randomWord64 r in w : unroll r'
22:17:15 <gamegoblin> and then calling
22:17:29 <gamegoblin> take n (unroll initial)
22:17:47 <wyager> how about "unfoldr (Just . f) b"
22:17:49 <wyager> :t unfoldr
22:17:51 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
22:18:22 <pacak> wyager: Yep, that's it.
22:18:58 <wyager> Man, Dimensional is awesome, but it's very hard to figure out how to type things correctly
22:19:25 <shachaf> It looks like a library that would be made simpler by type families if nothing else these days.
22:19:27 <wyager> I can't even figure out how to mutliply a value of an unspecified dimensional quantity by a constant
22:20:44 <wyager> This should be really easy
22:21:26 <pacak> > take 10 $ unfoldr (Just . (show &&& succ)) 1
22:21:28 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
22:29:11 <wyager> Alright, got it
22:29:19 <wyager> You need to enable FlexibleContexts
22:29:38 <wyager> and then you put a type constraint "Mul DOne a a"
22:29:47 <wyager> Meaning "a is closed under multiplication with a scalar"
22:30:05 <wyager> I guess you can't have constraints with type values in them without enabling FlexibleContexts
22:35:05 <ttt_fff> in haskell, waht library is closest to numpy?
22:35:20 <ttt_fff> i need to impelmet nearest neighbors, support vector machines, and deep learning in haskell
22:35:32 <ttt_fff> so I need very fast vectorized ops in haskell
22:43:09 <athan> @hackage vector ttt_fff
22:43:09 <lambdabot> http://hackage.haskell.org/package/vector ttt_fff
22:43:28 <ttt_fff> athan: why is this better than bindings to blas?
22:43:43 <athan> blas?
22:44:09 <pacak> ttt_fff: It's not better. ghc is not very good at vectorization so bindings is the only option if you need performance.
22:44:13 <athan> I dunno wht that is
22:44:28 <ttt_fff> athan: blas = highly optimized basic liner algebra system
22:45:13 <athan> :o yeah I think there may be hope with numerical-haskell, but that may be what we have now. Not sure about this one, sorry ttt_fff
22:45:14 <nshepperd> ttt_fff: maybe you want hmatrix
22:45:27 <nshepperd> which uses blas
22:45:36 <athan> s/be what/be all that/
22:45:40 <nshepperd> (and works seamlessly together with vector)
22:46:24 <ttt_fff> https://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial ?
22:46:31 <ttt_fff> that does not seem to use blas/lapack
23:14:56 <augur> i invented a new parsing algorithm, in case anyone's interested: http://pic.twitter.com/QVlN9tUupF
23:17:02 <EvanR_> augur: so the bottom thing is supposed to be a sequence of tokens
23:17:17 <augur> EvanR_: yes, sort of
23:17:30 <EvanR_> and e <down> is a placeholder for an expression which you dont know yet
23:17:31 <augur> the grammar shown there is a lexicalized tree substitution grammar
23:18:04 <augur> that is to say, a tree substitution grammar trees CFG rules as little tree fragments instead of rules, and you knit the trees together
23:18:23 <augur> a lexicalized such grammar is one where all the fragments have exactly one terminal node
23:18:56 <augur> so like.. a transitive verb "see" doesnt come with just a label V but instead has an entire tree above it, up to a sentence not
23:19:27 <augur> the tree being  (S NP? (VP (V see) NP?))
23:19:35 <augur> using ? in place of the down arrow
23:19:36 <EvanR_> it splits into a left and right branch, is that because of ambiguity
23:19:53 <augur> EvanR_: this particular example is ambiguous, yeah
23:20:13 <EvanR_> every token with e <down> is a possible next step
23:21:05 <augur> EvanR_: right
23:21:29 <augur> so you pick a candidate root node, and then split the sequence into left and right contexts of that node
23:21:46 <augur> if its the actual root, the frontier notes (the <down> nodes) for it must come from those contexts
23:22:24 <EvanR_> whats actual root?
23:22:26 <augur> so that gives you a new goal root node (the frontier node) and a new sequence to look in for it
23:22:37 <augur> the actual root is the root of the final parse tree(s)
23:23:28 <EvanR_> in the middle row, those frontier nodes at the bottom still need to come from the context around it
23:23:40 <EvanR_> but its not an actual root
23:25:52 <augur> right, the frontiers in the middle are basically creating a subproblem that is exactly like the whole problem but on a smaller portion of the input
23:26:25 <EvanR_> im trying to comprehend how that would be used on programming language syntax
23:26:50 <EvanR_> youd need to be able to detect that original structure from just the concrete symbols
23:27:13 <augur> which original structure
23:27:44 <EvanR_> e-x  e-eV-+-eV e-y
23:27:45 <EvanR_> etc
23:28:02 <EvanR_> your started with those as a given
23:28:41 <augur> oh yes but thats the grammar of the language basically
23:29:01 <EvanR_> so part of the parsing problem has been done ;)
23:29:06 <augur> you can derive those from a typical CFG very easily
23:29:13 <EvanR_> CFG?
23:29:21 <augur> no, it hasnt been done, its just what you put into the parser
23:29:25 <augur> CFG = context free grammar
23:29:45 <augur> normally you specify like...   <e> ::= x | y | z | <e> + <e> | <e> - <e>
23:29:47 <EvanR_> right you put it into the parser, you didnt put x+y in the parser
23:29:58 <augur> and you give that to the parser
23:30:18 <EvanR_> you give.. the language to the parser?
23:30:25 <augur> no, you give the GRAMMAR to the parser
23:30:32 <EvanR_> thats what i mean
23:30:41 <EvanR_> but more like the grammar IS the parser?
23:30:45 <augur> no
23:30:49 <EvanR_> and you give the input to the parser
23:31:16 <augur> no, parsers take grammars and input programs and spit out parse trees
23:32:11 <augur> there are some kinds of parsers (like combinator parsers) where you dont quite do this because the parser looks like the grammar and there's no explicit grammar
23:32:12 <EvanR_> yeah im just familiar with terminology, you give the grammar to the parser generator which gives you a parser, which takes input, and gives a parse tree. but its the same thing, just curried functions
23:32:20 <EvanR_> grammar -> input -> tree
23:32:40 <augur> parser generators generally spit out things like transition tables for parsers
23:32:55 <augur> the transition table still has to be plugged into the actual parsing function
23:32:57 <EvanR_> right for *particular parsers*
23:33:08 <EvanR_> youre calling the parsing method the parser
23:33:23 <augur> no im calling the program that implements the method the parser!
23:33:24 <augur> anyway
23:33:31 <EvanR_> overloading "parser" ;)
23:33:37 <EvanR_> three ways then
23:33:55 <augur> instead, with this, you specify   x  ->  (e x)   y -> (e y)   z -> (e z)   + -> (e e? + e?)   - -> (e e? + e?)
23:34:04 <augur> er..   - -> (e e? - e?)
23:34:16 <augur> that is, you specify the little trees around the lexical items
23:34:23 <EvanR_> yes thats what i was getting at, youd have to be able to recognize that at the symbol level
23:34:36 <augur> yes but you have to do that anyway
23:34:38 <EvanR_> so in 123+456... 1 2 3 + 4 5 6
23:34:39 <augur> all parsers do that
23:34:45 <EvanR_> how would you do that
23:34:59 <EvanR_> 1 -> ?
23:35:11 <augur> most parsers have a lexer pre-pass
23:35:16 <EvanR_> ah
23:35:31 <EvanR_> im spoiled by parsec-style where you dont need that
23:35:39 <augur> you definitely do need it in parser :)
23:35:48 <augur> well, sort of
23:35:59 <EvanR_> parsec? nah
23:36:03 <augur> yeah
23:36:11 <augur> i mean, so
23:36:17 <augur> lexing is a convenience tool
23:36:25 <augur> you dont NEED it, but its nice to have
23:36:29 <EvanR_> lexing is just pre parsing
23:37:09 <EvanR_> so theyre combined in parsec
23:37:11 <augur> the alternative is to have a bunch of rules like this:   <num> ::= some regular expression    <op> ::= "+" | "-" | ...
23:37:28 <EvanR_> right you can take those as understood but still they are normal rules
23:37:36 <augur> they are, yes
23:38:00 <EvanR_> <op>? above you didnt merge them into one token
23:38:02 <augur> you can lex, or not, with this grammar, it doenst matter
23:38:13 <augur> EvanR_: its an example, dont worry
23:38:14 <augur> anyway!
23:39:03 <EvanR_> what do you do about the ambiguity
23:39:25 <augur> without a lexer you're essentially just treating every character as a terminal node which is fine i guess
23:40:03 <EvanR_> (on the previous subject i was wondering how youd do the rule for decimal numbers without the lexer)
23:40:15 <augur> thats how parsec does it, anyway. parser just returns non-tree's so it looks like it doesnt
23:40:53 <EvanR_> yeah the result of parsing isnt always a tree
23:41:06 <augur> the number parser in parsec might, for instance, return just a single tree node, not because it parsed it as one tree node, but because parsec essentially does a post-recognition transformation on trees
23:41:47 <EvanR_> not sure tree is at all a fundamental concept in parsecs process
23:42:03 <augur> so the recursive structure of a parsec parse treats  123  as a tree  (seq 1 (seq 2 (seq 3 ())))
23:42:30 <augur> EvanR_: its not, the trees are ephemeral -- they're the call structure of the parsing process
23:42:35 <EvanR_> in that case, or it could have kept a running total of digits
23:42:45 <EvanR_> 1, 3, 6
23:43:05 <augur> sure, if you do something fancier
23:43:14 <jle`> ~/b 17
23:43:17 <jle`> oh sorry
23:43:26 <augur> my point about parsec is that the sub-lexical tree structure is still there in the parser's recursive behavior
23:44:07 <EvanR_> any program evaluating ... looks like a tree since its an expression...
23:44:20 <augur> yes
23:44:26 <EvanR_> so what about the ambiguity
23:44:31 <augur> anyway this is unnecessary tangentiality
23:44:31 <EvanR_> + vs - first
23:44:35 <augur> the ambiguity is desired, in fact
23:44:49 <augur> since the parser is intended for ambiguous languages
23:44:59 <EvanR_> so you just take all the possibilities
23:45:06 <augur> yeah, thats the intention
23:49:50 <augur> EvanR_: i havent yet figured out how to make it nice and monadic and such, but that will come
23:51:47 <augur> EvanR_: the current parser is about 66 lines of code, including some auxiliary data structures
23:52:42 <augur> and im sure it could be substantially cleaned up as is
23:53:02 <EvanR_> in an unambiguous language, wont that algorithm take a huge number of paths to the same answer
23:53:27 <EvanR_> for a decently sized input
23:53:59 <augur> no, in this grammar, every solution has exactly one path
23:54:13 <EvanR_> which grammar
23:54:19 <augur> sorry, in this parser
23:55:29 <EvanR_> what about ... lambda x . lambda y . x + y
23:55:29 <augur> because the grammars are lexicalized, any choice you make for the candidate root produces a distinct parse tree (if it succeeds), and that node is no longer part of the parsing problem once it's selected
23:55:43 <EvanR_> i guess i meants, spiritually the same result
23:55:56 <augur> there will only be one parse tree that results from that
23:56:09 <augur> there will be partial parses but only one complete parse
23:56:24 <EvanR_> partial parse?
23:56:28 <augur> the way i have the parser set up right now, actually, there wont be a partial parse
23:57:05 <augur> so if you used a chart parser, you would recognize   \ x . \ y . x   as a possible program that spans the first 7 lexemes of the input
23:57:18 <augur> but the input is 9 lexemes long, so its not a complete parse, its only partial
23:57:54 <augur> a chart parser will typically have that as a possible chunk of the chart, but there will only be one chunk that spans the entire input -- the right parse
23:58:53 <augur> however, with the parsing algo in the pic, the partial parse isn't even tried
23:59:12 <augur> in fact, the right parse is the _only_ parse that's tried, for that input. no other parse paths are possible
