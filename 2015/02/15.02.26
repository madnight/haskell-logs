00:01:35 <jle`> nocturne777: functions are monads, and partially applied functions are monads too
00:01:37 <jle`> er
00:01:41 <jle`> partially applied functions are functions too
00:01:52 <jle`> all humans are mortal, socrates is a human, therefore socrates is mortal
00:02:27 <jle`> nocturne777: if you desugar it all out ot makes sense :)
00:02:33 <nocturne777> tnx for the explanation guys :)
00:03:01 <jle`> nocturne777: consider what "join" has to be
00:03:15 <jle`> join :: (r -> (r -> a)) -> (r -> a)
00:04:18 <nocturne777> jle`: I am reading through "Learn You a Haskell ...". I am in the IO section, so I don't have a good grasp of monads yet :)
00:04:23 <jle`> no worries :)
00:04:26 <jle`> it'll come with time
00:04:41 <jle`> but i think you can already implement this function
00:04:45 <jle`> without any need of monads or anything
00:05:22 <jle`> john :: (r -> (r -> a)) -> (r -> a)      -- see, no Monad :)
00:05:38 <jle`> just for fun of course. but do continue in your course
00:05:49 <EvanR> look Mo no nads
00:06:11 <nilg> Thanks EvanR since I'm rather novice to Haskell I wanted to be sure I'm not missing something
00:07:25 <EvanR> nilg: dont confuse typeclasses in haskell with classes from oop languages
00:18:47 <nocturne777> jle`: I am still stuck on sequence [(+1), (+4)] :: Num a => a -> [a] . I just don't understand how it returns this function a->[a]
00:19:23 <jle`> :t sequence
00:19:24 <lambdabot> Monad m => [m a] -> m [a]
00:19:32 <jle`> imagine your Monad m is ((->) a)
00:19:35 <jle`> er
00:19:42 <jle`> ((->) r)
00:19:48 <jle`> can you "plug in" ((->) r) for m?
00:19:57 <jle`> or (r ->), if that's easier to visualize for you
00:21:02 <nocturne777> ok
00:21:10 <jle`> try it :) tell me what you get
00:21:19 <unknownloner> maybe I shouldnt try to think at 3 AM, but why does this do what it does
00:21:25 <unknownloner> >sequence [[1,2],[7,8]]
00:21:33 <unknownloner> (am I lambdabotting wrong?)
00:21:49 <unknownloner> > sequence [[1,2],[7,8]]
00:21:51 <lambdabot>  [[1,7],[1,8],[2,7],[2,8]]
00:22:25 <jle`> unknownloner: sequence [mx, my] = do { x <- mx; y <- my; return [mx, my] }
00:22:27 <jle`> er
00:22:37 <jle`> sequence [mx, my] = do { x <- mx; y <- my; return [x, y] }
00:22:57 <jle`> > do { x <- [1,2]; y <- [7,8]; return [x,y] }
00:22:58 <lambdabot>  [[1,7],[1,8],[2,7],[2,8]]
00:23:03 <unknownloner> yeah I figured that out
00:23:06 <unknownloner> but why is that true
00:23:14 <jle`> that's just what sequence is supposed to represent
00:23:28 <jle`> "doing" everything in the list, and collecting the results in a list
00:23:49 <nocturne777> jle`: is there a specialized implementation of sequence to produce that result ?
00:23:59 <jle`> sequence [ma, mb, mc ... mz] = do { a <- ma; b <- mb; c <- mc; ...; z <- mz; return [a,b,c...z] }
00:24:09 <jle`> no, you can actaully define a generalized version over all monads
00:24:12 <jle`> using recursion :)
00:24:18 <jle`> sequence [] = return []
00:24:26 <unknownloner> oh holy... do notation has <- and list comprehension has <-
00:24:32 <unknownloner> wow
00:24:44 <jle`> sequence (mx:mxs) = do { x <- mx; xs <- sequence mxs; return (x : xs) }
00:25:34 <nocturne777> unknownloner: the one inside "do" is to unbox the monad
00:25:47 <Fylwind> does anyone have a Mac with GHC installed?  I would appreciate if someone can clone https://github.com/haskell/directory and check to see if this Mac-specific bug has been fixed: https://github.com/haskell/directory/issues/22  Thanks!
00:25:52 <jle`> conceptually you can break down sequence as i put it above with [ma, mb ... mz] etc.
00:26:01 <unknownloner> but it does the same thing inside the list comprehension ;)
00:26:10 <unknownloner> because lists are monads
00:26:20 <nocturne777> yes, you are right
00:27:42 <unknownloner> man, learning haskell is just the rollercoaster of feeling like an idiot and feeling like a genius
00:28:02 <EvanR> Fylwind: ok, after these libs are done build
00:28:03 <EvanR> ing
00:29:51 <Fylwind> EvanR: thanks!
00:30:39 <jle`> nocturne777: if you plug it in, you get [((->) r) a] -> (((->) r) a)
00:30:47 <jle`> nocturne777: which is [r -> a] -> (r -> [a])
00:30:48 <jle`> right?
00:31:55 <falafel> What are the uses of comonad with List? Would this be `[[1,2,3], [2,3], [3]]` correct output for `extend id [1,2,3]`?
00:32:30 <quchen2_> Lists aren't comonads since there's no `extract`.
00:32:38 <falafel> extract = head? Or not?
00:32:46 <quchen2_> extract [] does not exist
00:32:54 <quchen2_> Nonempty lists are comonads.
00:33:05 <falafel> ok, let's assume comonad of non empty list
00:33:11 <EvanR> Fylwind: whats the issue
00:33:11 <falafel> that would right?
00:33:17 <Cale> Or rather, the type constructor for non empty lists is a comonad.
00:33:55 <falafel> I'm just learning about comonad, trying to figure out what would be a use case, I can't see it yet
00:34:17 <Cale> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
00:34:34 <Cale> That gives a certain sense of where some use cases lie
00:34:53 <falafel> I'll give that a read. thx
00:34:59 <Fylwind> EvanR: https://github.com/haskell/directory/issues/22
00:35:04 <falafel> would the output I posted be correct for nonemptylist
00:35:20 <falafel> [[1,2,3], [2,3], [3]] == extend id [1,2,3]
00:35:43 <Cale> Yeah, that'll give a comonad structure on nonempty lists
00:35:52 <Fylwind> EvanR: the steps to reproduce it are in that link; I wanted to know if the bug still exists on HEAD
00:36:00 <falafel> Cale, what can I do with it?
00:36:04 <EvanR> having trouble building it
00:36:09 <nocturne777> jle`: is it not supposed to be [((->)r) a] -> ((->)r [a])
00:36:12 <nocturne777> ?
00:36:23 <Fylwind> EvanR: autoreconf -i && cabal configure && cabal repl
00:37:01 <jle`> nocturne777: it is, but do you know about infix operators in haskell?
00:37:03 <Cale> falafel: Well, you might think about what sorts of computations make use of "tails" a bunch.
00:37:07 <jle`> (+) 1 2 is the same as 1 + 2
00:37:24 <falafel> Cale, that's what I want to figure out, I can't come up with an example for Lists that would click in my brain
00:37:29 <jle`> `(*) 5 10` is the same as `5 * 10`
00:37:32 <jle`> > (+) 1 2
00:37:33 <lambdabot>  3
00:37:34 <jle`> > 1 + 2
00:37:35 <nocturne777> jle`: yes, methods with special character can be used in infix notation
00:37:35 <lambdabot>  3
00:37:47 <jle`> yes, so...what is `(->) r a` ?
00:38:06 <nocturne777> r->a
00:38:23 <EvanR> Fylwind: alright
00:38:43 <jle`> mhm
00:38:45 <EvanR> Fylwind: i tried to create a direct that already existed but is not writable
00:38:54 <jle`> so that means [(->) r a] -> ((->) r a) is the same as
00:38:57 <EvanR> no effect, no exception
00:38:59 <jle`> [r -> a] -> (r -> [a])
00:39:11 <jle`> i mean, [(->) r a] -> ((->) r [a])
00:39:18 <rhaps0dy> heyo
00:39:30 <jle`> sop
00:39:32 <jle`> :)
00:39:37 <nocturne777> I understand that part :)
00:39:39 <Cale> falafel: Well, to be honest, I don't think there are many things you'd really want to do with that comonad instance... though I don't know of all that many algorithms which are generalised over a choice of comonad -- the abstraction is quite underdeveloped as of yet.
00:39:40 <funfunctor> hi
00:39:44 <funfunctor> hows everyone?
00:39:49 <Fylwind> EvanR: what happens if you do something like: createDirectoryIfMissing True "unwritable_directory/x/y/z"
00:39:55 <Cale> falafel: But there are lots of things that you can do with tails
00:40:05 <Fylwind> EvanR: i.e. more than one level of nesting within the unwritable directory
00:40:10 <Cale> falafel: Like, finding all the occurrences of one string in another
00:40:32 <nocturne777> jle`: I get it now.
00:40:34 <rhaps0dy> how can I read and use latin1 input with haskell?
00:40:46 <nocturne777> jle`: I should've plugged the thing in, my captain :)
00:40:52 <tdammers> rhaps0dy: if it's just reading, use ByteString
00:41:08 <tdammers> rhaps0dy: that'll treat them as streams of bytes
00:41:14 <rhaps0dy> I need to maniuplate it afterwards, preferably convert it to utf8
00:41:21 <rhaps0dy> alright,
00:41:33 <mauke\> hSetEncoding h latin1
00:41:36 <jle`> nocturne777: so you see how the types work out, right? :)
00:41:39 <rhaps0dy> I found http://hackage.haskell.org/package/base-4.7.0.2/docs/GHC-IO-Encoding.html#t:TextEncoding, but I don't see a way to convert bytestrings to that
00:41:42 <rhaps0dy> mauke\: thank you thank you
00:41:44 <falafel> Cale, ah, that's good example. I guess there aren't many real-world examples online, lots of theory, but can't wrap my head around the practical use case
00:41:49 <jle`> nocturne777: now the next question is...do you understand the behavior?
00:41:49 <EvanR> Fylwind: if that directory doesnt exist, it throws an exception. if the sub dir already exists, no effect no exception
00:41:50 <jle`> :)
00:41:56 <quchen2_> rhaps0dy: Data.Text.decodeLatin1
00:42:02 <quchen2_> rhaps0dy: Data.Text.Encoding.decodeLatin1
00:42:04 <quchen2_> Pardon.
00:42:16 <tdammers> rhaps0dy: what mauke said, unless you really need to do byte-wise manipulation, in which case, what quchen2_ said
00:42:29 <Cale> > [(x,y) | (x:xs) <- tails [1..10], y <- xs] -- this kind of thing comes up often enough
00:42:30 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,3),(2,4),(2,5),(2...
00:42:31 <Fylwind> EvanR: what is the exception?
00:42:41 <EvanR> *** Exception: unw/foo/bar: createDirectory: permission denied (Permission denied)
00:42:43 <rhaps0dy> quchen2_, tdammers, mauke\ Thank you very much
00:42:43 <tdammers> the hSetEncoding solution transparently converts from and to latin1 when reading and writing
00:42:44 <Cale> > [(x,y) | (x:xs) <- tails [1..4], y <- xs]
00:42:46 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
00:42:47 <rhaps0dy> this will be enough.
00:42:59 <quchen2_> latin1 is a text encoding, and Text is the appropriate type for that.
00:43:09 <Fylwind> EvanR: if it already exists, whether it's writable or not shouldn't matter, so I think that's working as intended
00:43:20 <EvanR> Fylwind: seems like it
00:43:28 <Fylwind> EvanR: thanks, I appreciate the help!
00:44:32 <tdammers> quchen2_: true. But since latin1 is also an 8-bit encoding, it can sometimes be useful to treat it as a stream of bytes, especially when what you're doing doesn't really care about the textual nature of the data much
00:45:05 <tdammers> but for anything textual, yes, decoding into Text is the way to go
00:45:39 <quchen2_> If you need a string of bytes then you don't need to decode it as text.
00:46:16 <quchen2_> I have a feeling this will end up as a String again, which is bad.
00:46:17 <Cale> falafel: To be fair, people haven't done all that much with comonads, and it's the sort of thing which snowballs. Once you find something which makes sense for an arbitrary choice of comonad, it makes finding useful comonads more profitable which in turn makes finding more algorithms that work on arbitrary comonads more profitable...
00:46:47 <rhaps0dy> I do need to read the text, I'll probably use hSetEncoding though
00:47:23 <Cale> falafel: Monads have seen a great deal of success in that regard, but we've yet to really work out many useful things which you can express in a way that's genuinely abstracted over the choice of comonad.
00:48:55 <tdammers> quchen2_: String is perfectly appropriate iff what you need is a single-use sequential traversal over a stream of characters
00:49:30 <tdammers> although even then, Text is probably at least equally good
00:49:34 <jle`> falafel: i dn't know too many uses myself of the Comonad instance of NonEmpty, but you might want to look at streams; they've had some success at comonadic abstraction being useful
00:50:05 <jle`> streams are lists w/out nil --- infinite lists
00:51:18 <EvanR> comonad is like functor but with the ability to look around. but how you can look around depends on the concrete type, so it doesnt seem very generic except as far as its functor behavior goes
00:51:58 <jle`> yeah i guess i don't know many "generic over comonad" functions in common use
00:52:07 <jle`> it's nice that =>= and =<= associate though
00:52:07 <danilo2> Hello! Is it possible to use somehow flag "--with-gcc=gcc-4.9" using cabal config file? I'm able to pass the flag when compiling package (cabal install ... --with-gcc=gcc-4.9) but I would like to add it to the cabal config. Can we do it somehow?
00:52:24 <jle`> and =>> works like it does with extract
00:52:39 <nerium> I've this code age <- iterateUntil (== "10") (ask "What's your age")
00:52:39 <nerium> Is there a way to pass the last value to ask before printing "What's your age"?
00:52:51 <tdammers> danilo2: GHC-options: --with-gcc=gcc-4.9?
00:53:50 <danilo2> tdammers: brb, I'm checking it
00:55:41 <Cale> nerium: Not sure I know what you mean by "the last value to ask" -- also, which iterateUntil is that?
00:56:01 <danilo2> tdammers: ok, we've already tried it. The package compiles when using the flag via command line arg (cabal install - ...) but when using it as you've provided does not :(
00:56:13 <nerium> Cale: The monad version
00:56:17 <Cale> (I can sort of imagine what it does, but there are some minor variations that are possible)
00:56:25 <tdammers> danilo2: vOv no idea then, sorry
00:56:36 <danilo2> tdammers: thank you! :)
00:56:50 <danilo2> Anyway, does anybody know how to do it? :(
00:57:02 <Cale> nerium: Is it in some library on hackage?
00:57:44 <nocturne777> jle`: I am a bit confused again :(. in the type signature of sequence, what does "a" stand for ? I read it as "a" wrapped in "m"
00:57:45 <danilo2> Cale: unfortunetally no
00:58:06 <Cale> danilo2: What?
00:58:13 <jle`> nocturne777: it's the parameter of `m`, but what it actually means is different for every Monad
00:58:23 <jle`> in [], with [a], the a is the type of the items in the list
00:58:24 <Cale> danilo2: Do you know what code nerium is talking about?
00:58:35 <jle`> for IO, with IO a, the a is the type of the result of the IO computation
00:58:35 <danilo2> Cale: ouch I thought you've asked me if the library we've got problem with is available on hackage, sorry for confusion
00:58:50 <jle`> for Maybe, with Maybe a, it is the type of the thing that might be in a Just constructor
00:59:12 <nocturne777> it is actually a value constructor, correct ?
00:59:12 <jle`> for every monad, it represents something different
00:59:19 <Cale> nerium: perhaps you could post your code on lpaste.net?
00:59:22 <jle`> yeah Just is a data/value constructor
00:59:25 <funfunctor> :t (^^)
00:59:25 <lambdabot> (Integral b, Fractional a) => a -> b -> a
00:59:39 <funfunctor> hmm how can I do 10 ^ 0.1 ? :p
00:59:42 <jle`> one thing consistent is that a Monad has to have a meaningfun return
00:59:44 <mauke\> funfunctor: **
00:59:45 <jle`> return :: a -> m a
01:00:07 <jle`> nocturne777: for every Monad you have to understand `a` as specific for that type
01:00:42 <funfunctor> mauke\: thx! wish that was named ^^^ or something
01:00:47 <Cale> heh
01:01:06 <Cale> Yeah, it would make a certain amount of sense
01:01:10 <jle`> nocturne777: what is `a` in (r -> a) ?
01:01:18 <Cale> Given the sequence (^), (^^), ...
01:01:57 <nocturne777> jle`: returned type
01:02:16 <nocturne777> type of returned value, that is
01:02:28 <jle`> mhm
01:02:36 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121214
01:02:39 <jle`> hm...er...did that answer the question? >_>
01:02:50 <funfunctor> why do I get a syntax error in this if-else control flow?
01:03:20 <Cale> funfunctor: because your let has no in, and it's not a statement in a do-block
01:03:26 <jle`> if (expression) then (expression) else (expression)
01:03:33 <jle`> (let ....) is not an expression
01:03:49 <funfunctor> :t in
01:03:50 <lambdabot> parse error on input ‘in’
01:04:11 <Cale> (let <declarations> in <expression>) is an expression form
01:04:24 <chaosmasttter> :t let x = (undefined :: Bool) in x
01:04:25 <lambdabot> Bool
01:04:50 <Cale> let <declarations>  on its own is a form of statement in a do-block, but you're not writing a statement
01:04:59 <funfunctor> so how do I rewrite this so its not so messy?
01:05:27 <lpaste> jle` revised “No title”: “No title” at http://lpaste.net/121214
01:05:31 <Cale> let powerScaling = if linearAtten < 1.0 then 1 else 1 / sqrt linearAtten
01:05:43 <Cale> also, you can combine the adjacent lets
01:05:45 <jle`> funfunctor: i edited it with the direct translation of what you are trying to do
01:05:50 <jle`> but if it were me i'd use a guard, personally
01:05:58 <jle`>     powerScaling | linearAtten < 1.0 = 1
01:06:05 <tdammers> heh
01:06:07 <jle`>                  | otherwise = 1 / sqrt linearAtten
01:06:14 <funfunctor> oh
01:06:24 <tdammers> I was about to apply the same edit :D
01:07:03 <falafel> Cale, jle`, thanks
01:07:03 <jle`> if/then/else's are so ugly in haskell that i think they were made ugly on purpose to discourage people from using them
01:07:20 <quchen2_> jle`: MultiWayIf!
01:07:23 <Cale> I dunno, they're not that bad
01:07:23 <funfunctor> that makes more sense
01:07:36 <tdammers> they're inconsistent
01:07:39 <funfunctor> jle`: haha yea true!!!
01:07:50 <ibid> jle`: no more ugly than in any other language. it's just that guards are prettier
01:07:53 <nilg> EvanR: where can I find some code examples of "class Semigroup a => Monoid a where". Hoogle doesn't seem to return that, thanks
01:08:12 <jle`> they're ugly cause indent rules ><
01:08:21 <jle`> also "then"
01:08:39 <EvanR> nilg: its a hypothetical type class
01:09:06 <nilg> oh nevermind I found some nice stackoverflow question about that http://stackoverflow.com/questions/6675912/semigroup-monoid-group-type-class-hierarchy-in-haskell-errors
01:09:09 <Cale> jle`: Only if you indent them incorrectly
01:09:16 <tdammers> indent rules, and how if/then/else is syntactically different from functions or operators
01:09:19 <Cale> The rules should be stricter imo
01:09:27 <EvanR> nilg: in real life, you can look at Monad, which has Functor as a prerequisite class
01:09:32 <Cale> You should be required to align the 'then' and 'else'
01:09:37 <Cale> if they occur on separate lines
01:09:43 <jle`> wait, people don't do that?
01:09:47 <Cale> and they should start in a deeper column than the 'if'
01:09:58 <jle`> i think it's just weird that it's a syntax construct
01:10:00 <Cale> Newbies don't do it right sometimes :)
01:10:06 <tdammers> jle`: yes, exactly
01:10:11 <jle`> and with four letter deliminters too
01:10:13 <jle`> grrrr
01:10:28 <tdammers> if :: Bool -> a -> a -> a -- would be fine by me
01:10:29 <jle`> delimiters
01:10:38 <funfunctor> EvanR: i'm starting to make fair progress on this project now...
01:10:45 <jle`> idk but tehn you can't do multi-line stuff i guess
01:10:49 <EvanR> sweet
01:10:55 <tdammers> jle`: why not?
01:11:09 <jle`> it's awkward to have a multi-line "then" clause that way
01:11:12 <ibid> tdammers: there's when and unless for when you are inside a monad
01:11:13 <jle`> you'd ahve to enclose it in parentheses?
01:11:31 <ibid> jle`: hence "then" :)
01:11:33 <tdammers> ibid: yes, I know. Someone also made an if' that is exactly what I proposed
01:11:54 <tdammers> jle`: but the same goes for thing like exception handling, brackets, "between" parser combinators, ...
01:12:00 <funfunctor> has anyone done a nice clean implementation of EMA (stats)
01:12:08 <tdammers> jle`: sure you aren't suggesting those should all be syntax constructs too?
01:12:21 <funfunctor> I need it to do signal processing for QAM
01:12:50 <funfunctor> finally coming up to the exciting part of this project ! Using Haskell to process RF !
01:12:55 <jle`> i still can't find a good way to pass in two multi-line things to a function
01:14:05 <tdammers> jle`: factor them out into a where or let is what I often end up with
01:14:21 <tdammers> or even make them top-level functions
01:14:34 <aawe> multi-line is not a typeclass
01:14:41 <jle`> i probably would end up doing a lot of case blah of True -> ...; False -> ...
01:14:49 <kqr> does ghci not reload whatever is loaded to run :main when you do :r?
01:15:06 <funfunctor> Is using Haskell to process radio signals something I could publish in a paper? would that be a first in terms of real world stuff?
01:15:06 <tdammers> jle`: hehe, yeah... I actually do case blah of Nothing -> ...; Just x -> ... a lot
01:15:23 <aawe> funfunctor: FFT?
01:15:23 <jle`> instead of `maybe` ?
01:15:36 <funfunctor> aawe: no, more complex than just a FFT
01:15:37 <tdammers> jle`: yes. But usually only in monadic contexts
01:15:53 <tdammers> jle`: pretty much exactly for multi-line reasons
01:16:01 <funfunctor> aawe: QAM64 with EMA and some fancy stocastic stuff also
01:16:13 <jle`> now if only we can get a nice idiom for `flip fmap`
01:16:25 <tdammers> maybe (do { ... }) (\x -> do { ... }) maybeX -- ugh
01:16:38 <funfunctor> aawe: i'm planning to implement LTE after this
01:16:45 <aawe> funfunctor: sounds like it would be really interesting either way
01:17:27 <funfunctor> aawe: so that would be doing OFDM (Orthogonal Frequency Division Multiplex) in Haskell and such things
01:30:20 * hackagebot tabular 0.2.2.7 - Two-dimensional data tables with rendering functions  http://hackage.haskell.org/package/tabular-0.2.2.7 (EricKow)
01:33:07 <bartavelle> is there a paper explaining how that works : http://hackage.haskell.org/package/parsers-0.12.1.1/docs/src/Text-Parser-Expression.html#buildExpressionParser  ?
01:33:19 <bartavelle> especially for the left associating operators
01:33:29 <bartavelle> (and why <**> isn't flip <*>)
01:36:59 <jle`> you mean, the design decision?
01:38:59 <bartavelle> for <**> or for the expression parser builder ?
01:39:35 <bartavelle> for <**> I noticed that if I manually flip the arguments and replace with <*> I get a stack overflow, which is what I expected in the first place, so I don't know why <**> works
01:40:11 <bartavelle> I wrote my own expression parser manually and I have no clue on how to parse left associating operators without post-processing
01:40:22 * hackagebot plist 0.0.6 - Generate and parse Mac OS X property list format  http://hackage.haskell.org/package/plist-0.0.6 (YurasShumovich)
01:40:24 * hackagebot Wordlint 0.2.0.1 - Plaintext prose redundancy linter.  http://hackage.haskell.org/package/Wordlint-0.2.0.1 (bgbgbg)
01:40:26 <bartavelle> so I just took that, as I know it works, but I don't understand why it works
01:40:41 <jle`> `pf <*> px` runs the pf parser to consume and parse a function, then runs the px parser to consume and parse a value
01:40:49 <jle`> and the result is the parsed function applied to teh parsed value
01:40:58 <bartavelle> yeah I get that
01:41:11 <bartavelle> `px <**> pf` doesn't seem to be the same thing though
01:41:12 <jle`> `px <**> pf` runs the px parser to consume and parse a value, then runs the pf parser to consume and parse a function, then returns the parsed function applied to teh parsed value
01:41:18 <bartavelle> ah!
01:41:55 <jle`> the difference between <**> and flip (<*>) is the order that the parsers are run
01:42:00 <bartavelle> crazy
01:42:20 <jle`> for all he Applicative combinators actually, the running is done in the "same direction"
01:42:33 <jle`> if pf <*> px parses f first then x, then px <**> pf parses x first then f
01:42:47 <bartavelle> humm
01:42:51 <jle`> for your parser type here, the first one is always parsed before the second one
01:43:59 <bartavelle> ok it makes more sense that way, thanks !
01:45:21 <jle`> np!
01:47:02 <kqr> what do I do if one library expects a lazy Text and another one doesn't
01:47:12 <kqr> ? it's always a sort of awkward situation for me
01:47:59 <kqr> (in this case, I want to marshal from a weird format to HTML. attoparsec gives me strict Text objects, and blaze-html expects lazy Text objects >_< )
01:49:47 <kqr> ohhh never mind
01:49:48 <kqr> I'm dump
01:49:50 <kqr> dumb*
01:49:58 <kqr> it's not as big a problem as I made it out to be
01:52:48 <EvanR> kqr: you can convert from a strict text to a lazy text easily
01:55:54 <Itkovian> EvanR is there a (large) cost associated with that?
01:59:06 <quchen2_> You can picture lazy text as a list of strict text elements, so no, not really
02:00:23 * hackagebot acme-miscorder 0.1.0.0 - Miscellaneous newtypes for orderings of discutable use.  http://hackage.haskell.org/package/acme-miscorder-0.1.0.0 (LoicArjanen)
02:01:15 <tdammers> there is no real benefit other than compatibility either though
02:01:28 <EvanR> yeah to satisfy the types
02:01:40 <tdammers> you're essentially still dealing with the same data structure
02:01:48 <tdammers> lazy to strict is a different matter
02:02:21 <quchen2_> That's still not a "large" cost though.
02:02:35 <EvanR> it might turn a low memory use into a large one
02:02:47 <quchen2_> How so?
02:03:02 <quchen2_> Oh, you mean if you have unforced lazy text
02:03:12 <tdammers> yes
02:03:18 <quchen2_> In that case you're right. I was thinking about fully evaluated texts.
02:03:20 <tdammers> making it strict forces the entire text
02:03:55 <tdammers> if it's going to be fully evaluated anyway, then using lazy texts doesn't really buy you anything
02:04:22 <EvanR> unless the evaluation is increment
02:04:23 <EvanR> al
02:04:27 <tdammers> ofc
02:04:56 <EvanR> after consuming all the text... you could say it was fully evaluated ;)
02:04:59 <tdammers> I find it difficult to phrase this unambiguously
02:05:19 <tdammers> "if you need the entire text to be fully evaluated at once" or something like that
02:08:51 <EvanR> ok data-default has 5 sub package dependencies
02:09:11 <EvanR> this seems excessive
02:09:53 <tdammers> huh
02:10:10 <EvanR> data-default gives you a single operation, its split into 6 packages
02:10:13 <tdammers> isn't data-default just a two-line class declaration and a bunch of instances?
02:10:23 * hackagebot Wordlint 0.2.0.2 - Plaintext prose redundancy linter.  http://hackage.haskell.org/package/Wordlint-0.2.0.2 (bgbgbg)
02:11:37 <EvanR> i guess they are all independent now
02:11:44 <fragamus> Hey is there a good book to learn about reasoning with haskell
02:12:05 <tdammers> tee hee... in the data-default-class package, the only source file is Data.Default.Class.hs, and 2/3 of it is the license header
02:12:47 <EvanR> tdammers: no implied warranty!
02:13:32 <tdammers> of the remaining 8 lines of actual source code, 3 are haddock, 3 are the module header with exports, and 2 lines are the actual instance declaration
02:13:54 <tdammers> the actual payload of that package amounts to 'class Default a where def :: a'
02:14:20 <merijn> fragamus: What sort of reasoning?
02:14:28 <merijn> fragamus: Correctness, performance, both?
02:15:13 <fragamus> correctness
02:15:28 <fragamus> formal methods in general
02:15:35 <merijn> fragamus: If you don't mind it not being specifically about Haskell, then I recommend Software Foundations
02:15:38 <merijn> @where sf
02:15:38 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
02:15:38 <lambdabot> assistant."
02:16:17 <merijn> fragamus: It starts out with proving properties about simple functions and goes on to more and elaborate things and ends with proving properties for imperative languages
02:16:50 <merijn> fragamus: I think it's a good intro to formal methods, plus it's free and has lots of exercises you can do with Coq
02:17:18 <fragamus> merijn: thank you
02:19:20 <EvanR> i think i found my issue
02:20:23 * hackagebot template-haskell-util 0.1.0.3 - Some utilities for template Haskell.  http://hackage.haskell.org/package/template-haskell-util-0.1.0.3 (songzh)
02:21:07 <EvanR> my ghc 7.8.3 has transformers-0.3.0.0 installed, and transformers-0.4.2.0 is installed as a dependency
02:21:15 <EvanR> of some package
02:21:34 <EvanR> my package wants to recompile all the packages against 0.3.0.0, which would break other packages
02:21:49 <EvanR> and i dont know why
02:25:16 <merijn> EvanR: Are you trying to compile something using the ghc library or cabal library?
02:25:26 <EvanR> not directly
02:25:37 <EvanR> but i noticed ghc-prim on the transitive deps
02:25:38 <merijn> Those are tied to the ghc transformers library and thus force the 0.3 constraint
02:25:53 <merijn> ghc-prim shouldn't be a problem, I think
02:26:16 <merijn> I forgot how to find out where a constraint is coming from, though
02:26:27 <EvanR> uhg
02:26:54 <jophish>  Is it possible to put a type on a pattern synonym?
02:27:11 <jophish> for example, something like: pattern P = 10 :: Int
02:27:35 <mpickering> jophish: In GHC 7.10 - yes
02:27:48 <mpickering> there are pattern synonym signatures
02:27:54 <jophish> mpickering: super!
02:30:35 <nilg> How does haskell avoids infinite calls of ==, as defined in https://github.com/haskell/haskell-report/blob/master/report/Prelude.hs#L71 ?
02:31:15 <jle`> nilg: when you define an instance, you define one or the other
02:31:18 <kqr> EvanR, yeah, and in this case I could just import putStrLn from Data.Text.Lazy.IO and it solved all the problems :)
02:31:19 <jle`> and it overrides the default instance
02:31:24 <merijn> nilg: It doesn't, if you don't overwrite either == or /= when you define the Eq instance it will infinite loop
02:31:55 <merijn> nilg: However, if you do overwrite one of the two, the recursion will call the code you defined, thus avoiding the issue
02:32:06 <nilg> wow that's very useful to know thanks!
02:32:26 <merijn> nilg: GHC now also has a MINIMAL pragma that let's you specify and check which functions of a typeclass have to be implemented to have a minimal correct definition
02:32:52 <merijn> nilg: It's basically a neat trick to avoid writing redundant code :)
02:32:56 <EvanR> merijn: do any of these deps jump out at you as requiring transformers-0.3.0.0 ? https://hackage.haskell.org/package/lowgl
02:33:19 <nilg> ah OK, so in practice I shouldn't enter the infinite loop (not due to == or /= anyway)
02:33:22 <nilg> right?
02:33:30 <muzzle> hi
02:33:43 <muzzle> can anyone tell me how i can fix this code ? http://pastebin.com/egBaTYH3
02:33:46 <merijn> EvanR: Linear depends on TH
02:34:08 <jle`> nilg: as long as you define one or the other
02:34:13 <jle`> or both
02:34:13 <EvanR> merijn: ok...
02:34:23 <muzzle> the error message is rather gargantuan and i don't understand why this would not work
02:34:32 <merijn> Although I think that shouldn't be a problem?
02:34:56 <EvanR> template-haskell the package doesnt seem to depend on transformers
02:35:37 <EvanR> and my template-haskell-2.9.0.0 is the only thing ive ever needed, apparently
02:36:25 <EvanR> if i cabal install lowgl, it wants to recompile adjuctions and friends against transformers-0.3 :(
02:37:09 <merijn> muzzle: Might want to paste the error message too? Also, you should prefer lpaste.net it's less filled with junk than pastebin and has hlint support
02:37:59 <EvanR> http://lpaste.net/121219
02:38:28 <rhaps0dy> is there a function handy for doing [1,2,3,4,5,6] -> [(1,2), (3,4), (5,6)] ?
02:38:34 <EvanR> similar for mtl-2.1.3
02:39:00 <muzzle> the code: http://lpaste.net/121220 the error: http://lpaste.net/121221
02:45:26 <nilg> jle`: I'm actually trying to define a type that derive Eq but doesn't define it (so I can experience this infinite loop by myself), but I can't!
02:46:02 <jle`> derived instance of Eq will have one or the other defined
02:46:13 <jle`> if you want to make an instance that will throw you in for the loop
02:46:20 <jle`> instance Eq MyType where
02:46:23 <jle`> that'll do it :)
02:46:34 <jle`> @let data MyType = MyType
02:46:37 <lambdabot>  Defined.
02:46:45 <EvanR> experience the loop
02:46:51 <jle`> @let instance Eq MyType where
02:46:52 <lambdabot>  .L.hs:153:10: Warning:
02:46:52 <lambdabot>      No explicit implementation for
02:46:52 <lambdabot>        either ‘==’ or ‘/=’
02:46:59 <jle`> > MyType == MyType
02:47:00 <lambdabot>  No instance for (GHC.Classes.Eq L.MyType)
02:47:00 <lambdabot>    arising from a use of ‘GHC.Classes.==’
02:47:14 <jle`> so lambdabot blocks things that have warnings
02:47:22 <Cale> That's interesting
02:47:45 <muzzle> merijn: do you have any idea how i could get my code to compile ?
02:48:02 <jle`> @let instance Eq MyType where x == y = not (x /= y)
02:48:03 <lambdabot>  Defined.
02:48:07 <jle`> > MyType == MyType
02:48:09 <lambdabot>  *Exception: stack overflow
02:48:14 <jle`> i'm sorry lamdabot
02:49:04 <EvanR> Warning: This package indirectly depends on multiple versions of the same
02:49:05 <EvanR> package. This is highly likely to cause a compile failure.
02:49:09 <EvanR> ahhhhhh >_<
02:49:29 <danilo2> Hwello! Is there on hackage any library that would allow me to automatically create zippers from datatypes, that I would be able to serialize and store on disk?
02:50:54 <EvanR> package parsec-3.1.5 requires mtl-2.1.3.1
02:50:56 <Cale> muzzle: Your problem is that the type of finalize says that it works for any type s that the user of finalize chooses, in particular, it would work with, say, s = ()
02:51:37 <Cale> muzzle: But runSTArray demands that the result be polymorphic, so you kind of need impredicativity to make this function work -- you'd like the signature of finalize to be:
02:52:02 <Cale> finalize :: (Ix i) => Reactive (forall s. ST s (STArray s i e)) -> Reactive (Array i e)
02:53:40 <Cale> *Maybe* you could turn on {-# LANGUAGE ImpredicativeTypes #-} and have that definition go through, but I suspect you won't be able to use it because ImpredicativeTypes has been broken for a while now, because it's a tough feature to maintain relative to the number of people who want it.
02:53:53 <jophish> Using pattern synonyms, is it (or will it be) possible to have something like this: data A = A; data B = B; <some patterns>; class C c where; instance C A; instance C B; foo :: C c => c -> Bool; foo A = True; foo B = False
02:54:05 <jophish> I think that's the shortest example of what I'd like
02:54:18 <jophish> I don't think this is possible at the moment
02:54:29 <Cale> muzzle: One thing you *could* do is to make a wrapper for this type of ST computations producing arrays
02:54:49 <muzzle> :Cale so there is actually no way to turn an STArray into an immutable array inside an other monad ?
02:55:09 <Cale> data ArrayProducer i e = AP (forall s. ST s (STArray s i e))
02:55:14 <Cale> and then write
02:55:25 * hackagebot template-haskell-util 0.1.0.4 - Some utilities for template Haskell.  http://hackage.haskell.org/package/template-haskell-util-0.1.0.4 (songzh)
02:55:37 <Cale> finalize :: (Ix i) => Reactive (ArrayProducer i e) -> Reactive (Array i e)
02:57:19 <danilo2> Hwello! Is there on hackage any library that would allow me to automatically create zippers from datatypes, that I would be able to serialize and store on disk?
02:58:21 <Cale> muzzle: But maybe you can avoid having to do this altogether?
02:58:53 <Cale> muzzle: Could I see more of the surrounding code?
02:58:55 <phaazon> danilo2: aren’t zippers closely tight to types they work on?
03:00:14 <tdammers> danilo2: think I saw a general-purpose generic (or typeable?) based serialization lib zoom by a while ago, but didn't look into it any deeper
03:00:37 <jophish> here's the example in full: https://gist.github.com/expipiplus1/79359ba60ae1683f4907
03:01:00 <muzzle> :Cale What i'm doing is, that I want to render a text window for a console text-editor. And i want to use STArray so i can draw on top of stuff that's already been rendered without performance penalty
03:01:23 <muzzle> and I need the reactive monad for handling all kinds of side effects
03:02:33 <muzzle> but when rendering is done i originally wanted to create an immutable array
03:03:03 <koomi> jophish: no, that is not possible with pattern synonyms or without
03:03:07 <Cale> muzzle: Which Reactive monad is that?
03:03:24 <muzzle> :Cale https://hackage.haskell.org/package/sodium-0.11.0.3/docs/FRP-Sodium.html#t:Reactive
03:03:55 <jophish> koomi: that's a shame, what inparticular is stopping it? I think theres a name clash in there too
03:03:56 <koomi> jophish: there are other tricks to achieve that but most of the time it's not a good solution
03:05:00 <Cale> muzzle: Okay, cool. So, what I don't quite understand is why your operation is taking a Reactive action as an argument
03:05:02 <jophish> koomi: I'm currently thinking about how to make the gl library a bit safer to use, but the challenge is not to sacrifice any functionality. gl uses patterns for all the GLenums
03:05:28 <danilo2> phaazon: zippers work on lenses and store lenses under thwe hood, so they are not serializable :(
03:05:54 <danilo2> tdammers: Oh that would be great :( I understand you cannot get it somehow out of your mind? :D
03:06:09 <Cale> muzzle: Like, what were you writing at the time that you decided you'd like to have this finalize function?
03:06:26 <Cale> muzzle: If we look at that, maybe we can somehow avoid the need for it?
03:06:52 <jophish> koomi: that's nice because using them as patterns and values is convenient, but it would also be super helpful to be able to reject programs which pass an invalid enum to a function
03:06:53 <dulla> really, thought they liked contiuations, danilo2
03:07:20 <koomi> jophish: the problem is that a function always takes a value of some particular type
03:07:27 <danilo2> dulla: I'm sory, I did not understand your sentence :( What do you mean ?
03:07:39 <koomi> but there is no type for 'A or B'
03:07:54 <tdammers> danilo2: http://hackage.haskell.org/package/cereal-0.4.1.1/docs/Data-Serialize.html
03:07:58 <tdammers> danilo2: I think that was it
03:08:14 <jophish> koomi: yeah, I was hoping there'd be something like forall a. C a => a
03:08:17 <Cale> danilo2: That must be some new-fangled sort of zipper that I haven't heard of yet, but zippers are usually no harder to serialize than the original type that they're zippers for.
03:08:37 <muzzle> :Cale the function was http://lpaste.net/121223
03:08:41 <koomi> jophish: one possible solution is to make foo a method of the typeclass
03:08:48 <dulla> more or less what cale said, danilo2
03:09:02 <dulla> the continuations thing is to prevent halting problems
03:09:19 <dulla> also something about being involved in contexts
03:09:38 <Cale> I don't understand anything that dulla is saying right now :(
03:09:45 <danilo2> Cale: when looking at the zippers package (https://hackage.haskell.org/package/zippers) - If I'm not wrong (and correct me please if I am) we arew not able to serialize them, because they store just lenses inside.
03:10:03 <jophish> koomi: That's a very good idea, but I don't know how well it would work when one has to pass multiple arguments, I'll have a think
03:10:06 <danilo2> Cale: so in general use case - right, if we make custom datatypes as zipper library, we woudl be able to serialize it
03:10:45 <koomi> jophish: "forall a. C a => a" does indeed exist, and you can (with the right set of extensions) pass a value of such a type to a function, but it probably does not do what you want
03:11:13 <danilo2> tdammers: hmm,, the link you've provided points to Data-Serialize from cereal, which is simmilar to binary - its serialization solution. It does not solves the issue, does it? I was looking for "serializable" zipper library - using either cereal or binary
03:11:38 <jophish> koomi: the example in a slightly broader context is here: https://gist.github.com/expipiplus1/f5286ffcc07e532e5be6
03:11:57 <jophish> the challenge is to restrict where the different instances of IsGlEnum can be passed
03:12:07 <jophish> that file doesn't deal with using them as patterns though
03:12:27 <dulla> Eh, I'm thinking in terms of what I read from Oleg
03:12:51 <dulla> Delimited Continuations, and General Zippers from Traversable and Scrap Your Boiler Plate
03:13:19 <tdammers> danilo2: ah, sorry then
03:14:20 <funfunctor> EvanR: rewrite bts/Main.hs (86%), rewrite src/BTS/RadioDevice.hs (82%)  - no more StateT at all
03:15:06 <funfunctor> EvanR: alright I see that carting around IORef inside the IO monad does essentially the same thing as a StateT in some respects
03:15:18 <EvanR> funfunctor: i see 86% rewrite, i think game is 86% complete
03:15:26 * hackagebot xhb-atom-cache 0.1.0.0 - Atom cache for XHB  http://hackage.haskell.org/package/xhb-atom-cache-0.1.0.0 (jrk)
03:15:44 <funfunctor> EvanR: hehe
03:15:44 <funfunctor> I've made good progress
03:15:44 <EvanR> funfunctor: it does, its just more flexible
03:15:59 <EvanR> and takes less code
03:16:02 <funfunctor> EvanR: I think I need some serious help with readSamples and writeSamples
03:16:04 <funfunctor> yes
03:16:19 <funfunctor> I've learnt a *lot*
03:16:21 <funfunctor> I feel more fluid working with it all now
03:17:05 <funfunctor> EvanR: do you mind having a look though my source as a quick code audit?
03:18:17 <funfunctor> EvanR: https://github.com/victoredwardocallaghan/hbts
03:18:31 <koomi> jophish: is GLenum really an open set?
03:19:15 <EvanR> "Therefore, modern cabal-install aborts the whole operation and warns you that it will break pigeon-1.1. This safety guard was added because this article explicates the problem to the public. Early versions of cabal-install went cavalier with the re-install and broke pigeon quietly."
03:19:22 <koomi> that is, can user-defined values be added to it?
03:19:47 <EvanR> this page is funny
03:20:54 <EvanR> funfunctor: im going to pick a source file at random, then randomly criticize something
03:22:25 <funfunctor> EvanR: ok
03:23:27 <EvanR> you can implement a Logger as a String -> IO ()
03:23:39 <EvanR> the constructor for the logger would be :: IO (String -> IO ())
03:24:27 <funfunctor> EvanR: oh the logger I am going to completely replace later
03:24:42 <funfunctor> thats completely non-important at the moment. it works enough
03:25:23 <funfunctor> EvanR: Main.hs is also just for tests
03:26:59 <jophish> koomi: I'm not sure I understand open set in this context, do you mean can new elements be added?
03:28:03 <koomi> yes
03:28:25 <jophish> then yes, extensions can add new enumerations which can be used with existing functions
03:29:18 <jophish> so in my example, in NewExtension.hs one might add a new GLenum: data NewEnum = NewEnum and make it an isntance of BindBufferTarget so it can be passed to bindBuffer
03:30:26 * hackagebot xhb-ewmh 0.1.0.0 - EWMH utilities for XHB  http://hackage.haskell.org/package/xhb-ewmh-0.1.0.0 (jrk)
03:37:23 <EvanR> "The distro installer assumes it has the monopoly; cabal assumes there is no monopoly. They are fundamentally in contradiction."
03:38:32 <nerium> I'm trying to use the >>= operator, but I can't wrap my head around it.
03:38:33 <nerium> The def looks like this: (>>=) :: Monad m => m a -> (a -> m b) -> m b
03:38:34 <nerium> What happens if I want to call the function (second argument), but don't have an argument to pass?
03:39:43 <EvanR> nerium: you cant call it. but you may be able to use >>= because you may have an m a
03:39:57 <EvanR> which is very different from a
03:40:29 <funfunctor> EvanR: you said you know QAM and things, how much of that stuff do you know?
03:40:33 <fractalsea> I have a local version of a package in cabal (to bump a dependency version), how can I force cabal to use this version instead of the one in hackage?
03:40:43 <funfunctor> EvanR: I realise that is a lose question at best
03:41:17 <EvanR> almost nothing, basically what it stands for and some probably wrong diagrams explaining it
03:42:15 <fractalsea> It’s actually a dependency of another local package my project depends on
03:43:22 <jophish> koomi: Sadly, I don't think making foo a method of C would work for the case where foo wants to take more than once C, or a C and something of another typeclass
03:43:42 <funfunctor> EvanR: lol ok
03:44:01 <funfunctor> EvanR: now do you happen to know a good EMA implementation in Haskell?
03:44:07 <EvanR> no
03:44:30 <funfunctor> I was surfing over the statistics stuff on hackage
03:45:02 <Cale> nerium: If you understand do-notation, (x >>= f) is the same as (do v <- x; f v). Even if you don't, that ought to give you some sense of what (x >>= f) means: execute x, getting some result (say v) and then execute f v
03:45:05 <funfunctor> I think I need to read some papers on that
03:45:28 <mrkkrp> Is it possible to get lazy list inside monad after this: `concat <$> mapM f xs', where `xs' is an infinite input list, and `f :: Monad m => a -> m [a]'. Monad in question is not `Maybe' or `Either', so in principle it doesn't need to know all values to produce result.
03:45:39 <nerium> Cale: Just a sec
03:46:58 <Cale> mrkkrp: Which monad?
03:47:18 <mrkkrp> Custom. State-based.
03:47:26 <Cale> mrkkrp: Unless it's Identity or Writer, it's pretty unlikely.
03:47:36 <Cale> Or I guess Reader would be okay
03:47:41 <mrkkrp> Hm.
03:47:53 <Cale> State is not
03:48:06 <Cale> Think about what the result of a get would be after that
03:48:10 <mrkkrp> What's so bad about state?
03:48:49 <mrkkrp> Cale, I thought about that, it's separated from my 'main' monad and I ignore its output state.
03:48:53 <Cale> You absolutely must carry out all the infinitely many actions in order to know what the state is following that mapM, which you can't really do.
03:48:59 <mrkkrp> I thought that it would help....
03:49:02 <Cale> hmm
03:49:16 <EvanR> monads are not like oop objects
03:49:28 <Cale> EvanR: What prompted that?
03:50:02 <EvanR> the usual you have the main monad, and a separate monad with a different state, and just the continued pattern of this
03:50:21 <EvanR> replacing each oop class with a StateT over IO
03:50:55 <Cale> Well, he didn't say he was using StateT over IO
03:51:09 <Cale> I assumed he meant what he said, that he was doing a State computation
03:51:35 <mrkkrp> It has nothing todo with IO.
03:51:41 <mrkkrp> IO comes much later.
03:52:38 <Cale> So you should be able to get an infinite list from State
03:52:50 <Cale> If you're careful not to look at the final state there, you'll be okay
03:53:15 <mrkkrp> Basically, I don't understand why I can't lazily compute the list infinitely passing my state, if I ignore it at the end and only get infinite list as a result.
03:53:29 <Cale> You can
03:53:35 <mrkkrp> Hmm.. I must recheck it.
03:53:47 <Cale> > evalState (mapM (\x -> do s <- get; put (s + 1); return (x + s)) [1..]) 0
03:53:49 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
03:55:10 <Cale> > evalState (mapM (\x -> do s <- get; put (s + 1); return [x,s]) [1..]) 0
03:55:12 <lambdabot>  [[1,0],[2,1],[3,2],[4,3],[5,4],[6,5],[7,6],[8,7],[9,8],[10,9],[11,10],[12,11...
03:55:22 <Cale> > evalState (concat <$> mapM (\x -> do s <- get; put (s + 1); return [x,s]) [1..]) 0
03:55:24 <lambdabot>  [1,0,2,1,3,2,4,3,5,4,6,5,7,6,8,7,9,8,10,9,11,10,12,11,13,12,14,13,15,14,16,1...
03:55:26 <mrkkrp> `evalState' ignores state, right?
03:55:52 <mrkkrp> I mean it doesn't return it.
03:55:57 <shiona> is there a way to write a typeclass for things that work like either?
03:56:01 <Cale> Yeah, it just projects the result out of the pair, discarding the final state.
03:56:12 <funfunctor> OOP is killing poor EvanR ;)
03:56:13 <shiona> e.g. A typeclass that has functions left and right
03:56:21 <EvanR> cabal is killing me right now
03:56:31 <Cale> shiona: I suppose
03:56:48 <EvanR> and either
03:56:50 <EvanR> :t either
03:56:51 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
03:57:08 <mrkkrp> Cale, I used `fst . runState'! It must be root of the evil! :)
03:57:31 <Cale> mrkkrp: That's how evalState is implemented
03:57:41 <mrkkrp> Oh.
03:58:19 <mrkkrp> Anyway now I believe it's possible. Thank you!
03:59:06 <nerium> Cale: What's the type of "f", in the case of x >>= f ?
03:59:58 <Cale> nerium: Well, (>>=) :: (Monad m) => m a -> (a -> m b) -> m b, so we have f :: a -> m b
04:00:08 <Cale> and x :: m a
04:00:13 <Cale> for the same m and a
04:00:22 <Cale> and the result then has type m b
04:00:30 <shiona> Cale: any pointers on how to go about it? I'm stuck with getting the type parameters of either out of the typeclass param
04:00:47 <shiona> if it's easier to explain with a typeclass version of Maybe
04:00:52 <Cale> class Eitherish e where
04:01:04 <Cale>   left :: a -> e a b
04:01:09 <Cale>   right :: b -> e a b
04:01:21 <Cale>   either :: (a -> c) -> (b -> c) -> e a b -> c
04:02:27 <shiona> ah, that's a nice way of thinking it
04:02:56 <EvanR> its probably better to agree on Either anywhere this could be used
04:03:14 <Cale> Yeah, or just provide functions going back and forth from Either
04:04:36 <Cale> any instance of my Eitherish will effectively be isomorphic to Either
04:04:47 <benzrf> Cale: coproduct?
04:04:48 <exio4> which datatypes would be able to be part of that typeclass if you "added" some laws like (either left right = id), (either f g (left x) = f x) and/or (either f g (right x) = g x)
04:04:51 <benzrf> oh, nah
04:04:53 <EvanR> you might not be able to go back to the Eitherish type
04:05:03 <EvanR> but you can certainly map to Either
04:05:07 <Cale> EvanR: either left right
04:05:28 * hackagebot xhb-atom-cache 0.1.0.1 - Atom cache for XHB  http://hackage.haskell.org/package/xhb-atom-cache-0.1.0.1 (jrk)
04:05:30 * hackagebot xhb-ewmh 0.1.0.1 - EWMH utilities for XHB  http://hackage.haskell.org/package/xhb-ewmh-0.1.0.1 (jrk)
04:05:39 <EvanR> there can be unseen functionality
04:05:48 <EvanR> left and right might not be the only constructors
04:07:21 <Cale> Yeah, I suppose you could implement either in some fashion for  data EitherOrBoth a b = L a | R b | B a b
04:08:03 <EvanR> but maybe if you could only observe e through the Eitherish, perhaps you cant tell the difference
04:08:04 <exio4> Cale: and what about either?
04:08:23 <Cale> exio4: hm?
04:08:31 <exio4> in the (B a b) case, what'd either do?
04:08:38 <Cale> exio4: pick one
04:08:48 <Cale> exio4: There are two ways to do it
04:08:50 <exio4> ah, right
04:10:39 <Cale> You really need some additional laws to make the guarantee
04:10:42 <exio4> Cale: I was thinking with some kind of law that said either left right = id, sorry :P
04:10:47 <Cale> right
04:11:11 <Cale> (I was thinking that too!)
04:11:22 <Cale> I just forgot to say it :)
04:11:27 <nerium> Cale: Could you explain this maybe? https://gist.github.com/oleander/23d14b15954b96467119 How come data Replay q r a takes tree args, but in the def only two? Monad (Replay q r)
04:11:59 <mauke\> Monad is a class of type constructors
04:12:06 <Cale> nerium: Because Monad is parameterised over a choice of type constructor
04:12:11 <Cale> :k Monad
04:12:12 <lambdabot> (* -> *) -> Constraint
04:12:15 <Cale> :k Eq
04:12:16 <lambdabot> * -> Constraint
04:12:30 <mrkkrp> Cale, I used strict state! I just solved the problem :-)
04:12:38 <Cale> mrkkrp: ah, haha
04:12:49 <Cale> The default is lazy though, isn't it?
04:13:30 <mrkkrp> Well, I needed strict state for one thing and them just copied import section from there...
04:13:35 <Cale> nerium: Have a look at the Monad type class:
04:13:35 <mrkkrp> *then
04:13:47 <Cale> class Monad m where
04:13:49 <Arahael> So if I have: newtype Foo = Foo Bar; how do I get the 'Bar' type out of it?
04:13:52 <Cale>   return :: a -> m a
04:14:00 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
04:14:11 <mauke\> Arahael: are you talking about pattern matching?
04:14:26 <Cale> (That's paraphrased, I'm leaving out the new superclass constraint and a couple other things)
04:14:41 <Arahael> mauke\: No, though if I must do pattern matching then I guess I'll try that.
04:14:49 <Cale> nerium: So whatever m is, it needs to be able to take a type parameter like a or b there
04:15:03 <Arahael> mauke\: My real newtype, so you can see what I'm doing, is: newtype Url = Url String
04:15:04 <Cale> nerium: In this case, m = Replay q r
04:15:12 <Arahael> mauke\: I'm trying to introduce a special type of 'string' as Url.
04:15:24 <mauke\> Arahael: case url of Url s -> {- s is a string here -}
04:15:28 <Arahael> mauke\: But functions that expect a String type don't work. :/
04:15:29 <Cale> nerium: So  return :: a -> m a  specialises to  return :: a -> Replay q r a
04:15:38 <Arahael> mauke\: So I must pattern match?
04:15:49 <Arahael> mauke\: Even though there's exactly one possible pattern?
04:15:52 <mauke\> Arahael: yes, or write a helper function to extract the string, or let the compiler write the helper function
04:16:19 <EvanR> newtype Url = Url { unUrl :: String }
04:16:39 <Arahael> Ah, with the record syntax.
04:16:49 <Cale> With EvanR's definition, you get the function  unUrl :: Url -> String  for free
04:17:26 <Arahael> Yes, it's tempting.
04:17:29 <EvanR> and you can still pattern match if you want to
04:17:29 <Arahael> Thanks. :)
04:18:13 <Cale> Arahael: The whole point of having the newtype is that despite the fact that the representation at runtime will be the same as String, so you pay no additional memory cost for these things, the compiler won't let you accidentally treat String and Url as the same type.
04:18:47 <nerium> Cale: Hmm, okay. I'm having a problem I can't wrap my head around
04:18:48 <Cale> which protects you from various mistakes, like getting a URL mixed up with a street address.
04:19:16 <EvanR> you can also protect construction of a Url with a URL validation
04:19:47 <Arahael> Cale: I can see that. :)
04:20:09 <Arahael> Cale: I guess I somehow expected to see some sort of contravariant typing.
04:20:33 <mauke\> > gshow ("hi", 42)
04:20:35 <lambdabot>  "((,) \"hi\" (42))"
04:20:55 <Cale> Arahael: Which would only protect you from half of the mistakes :)
04:21:04 <EvanR> gshow computes a GString?
04:21:11 <mauke\> heh
04:21:36 <Cale> nerium: any more details? :)
04:21:45 <Arahael> Cale: Well, I noticed that my String literals automatically became Url, which until this moment was darn confusing! :)
04:22:00 <Cale> Yes, that's new and strange, and I'm not sure I like it.
04:22:05 <bqjpin> !hello
04:22:06 <bqjpin> !list
04:22:07 <monochrom> bqjpin: http://hackage.haskell.org/packages/
04:22:10 <Cale> (OverloadedStrings)
04:22:16 <mauke\> Cale: is that on by default?
04:22:22 <Cale> mauke\: no
04:22:55 <Cale> I guess in some cases, it's darn convenient. If you have a lot of Text literals in your code, you'll love OverloadedStrings
04:23:10 <tdammers> matter of preference, I guess
04:23:14 <Cale> But like, using it for Url is kind of sketchy already.
04:23:16 <tdammers> overloaded strings can be extremely annoying
04:23:23 <mauke\> t"text literal"
04:23:28 <mauke\> where t :: String -> Text
04:23:42 <tdammers> mauke\: mine is called "s", and its type is StringConvert a b => a -> b
04:23:45 <tdammers> :D
04:23:57 <nerium> Cale: This is my code which I'm having problems with: https://gist.github.com/oleander/75c5c90032db5ec849ef#file-gistfile1-hs-L45 I'm trying to run the validate function
04:24:10 <ChristianS> tdammers: why annoying? i think they are great.
04:24:15 <nerium> But I'm not sure what to return on the highlighted line
04:24:37 <tdammers> ChristianS: they are, but polymorphic string literals combined with polymorphic functions to act upon them can be too ambiguous
04:25:08 <nerium> Cale I would like to return nothing, but then line 38 fails as I don't have a value
04:25:25 <EvanR> return undefined
04:25:36 <tdammers> e.g.: html :: ToHtml a => a -> Html; instance ToHtml Text; instance ToHtml String; ...
04:25:37 <EvanR> YMMV
04:26:01 <ChristianS> tdammers: that may be, i tend to use monomorphic functions (with Text as string type)
04:26:01 <tdammers> ...and then you try to do html "Hello, world!", and the compiler doesn't know which string type you mean
04:26:12 <nilg> is it possible to have type class constraints composed of disjunctions, like class (Num a or Ord a) => MyClass a
04:26:13 <nilg> ?
04:26:33 <tdammers> ChristianS: not great if you want to expose your functions from a library
04:26:33 <Cale> nerium: I'm not sure I can determine from this code what you intend the result of this operation to be
04:26:50 <Arahael> Cale: Now I'm confused why, my apparently well-typed expression, is now complaining that my string literal (which seems to be Url, now), is missing a Data.String.IsString Url implementation.
04:27:01 <Arahael> Cale: I don't know where that IsString comes into it!
04:27:36 <Cale> Arahael: Oh, well, if you didn't have an instance of IsString before, then your literal was never a Url.
04:28:22 <Arahael> Cale: Then why *is* it a Url!
04:28:51 <Arahael> Cale: It's in this strange place where it's both not a Url, and not a String, yet it's both.
04:29:03 <EvanR> thats why its a type error
04:29:11 <Cale> Arahael: which would be why the compiler is shouting at you
04:29:28 <Arahael> Cale: Somehow, by removing a print statement later in the code, the need for IsString vanished.
04:29:49 <Arahael> EvanR: It type-checked within that function, the problem is using the function
04:29:56 <EvanR> are you using top level type annotations
04:29:57 <mniip> how come a Review isn't a Setter, it breaks a nice heart lattice :/
04:30:20 <Cale> nerium: Perhaps  Right a  ?
04:30:30 * hackagebot xhb-ewmh 0.1.1.1 - EWMH utilities for XHB  http://hackage.haskell.org/package/xhb-ewmh-0.1.1.1 (jrk)
04:30:31 <Arahael> EvanR: Not that I'm aware of, no.
04:30:36 <EvanR> you should be
04:30:43 <Arahael> EvanR: I do have type signatures.
04:30:54 <EvanR> same thing
04:31:07 <Arahael> Cool.  That's teh only thing that's keeping my sanity.
04:31:17 <EvanR> yes
04:31:22 <Cale> nerium: also, make sure the 'then' and 'else' branch are the right way around... I'd expect that the validation function would give True when things were okay.
04:31:58 <nerium> Cale: Hehe, yeah
04:32:17 <Cale> nerium: Is it required that the traces be in that order?
04:32:32 <Cale> nerium: Because it seems like you're using bad operations to manipulate them
04:32:50 <nerium> Cale: What do you mean by bad?
04:32:55 <Cale> I guess it doesn't really matter if the goal is to interact with a user at the terminal for a short while
04:33:03 <Cale> but xs ++ [x] is a terrible thing to do to a list
04:33:06 <Cale> as is init
04:33:16 <Cale> If you have to do those a lot, you should just have your list reversed
04:33:27 <nerium> Cala Aha, you mean like that
04:33:33 <nerium> I guess I can reverse it
04:33:34 <tdammers> that, or use different data type
04:33:34 <Cale> xs ++ ys takes O(length xs) time
04:33:41 <tdammers> "shlemiel the painter"
04:33:53 <Cale> while x : xs is constant time
04:34:15 <Cale> init xs also takes O(length xs) time, while tail xs is constant time
04:34:51 <Cale> also, you're using *both* init and last, which means you're going to walk down the same list twice
04:35:30 * hackagebot xhb-atom-cache 0.1.0.2 - Atom cache for XHB  http://hackage.haskell.org/package/xhb-atom-cache-0.1.0.2 (jrk)
04:35:31 <Cale> and if you were storing the list the other way around, you could just pattern match against  (toTrace : toTrace')
04:35:45 <Cale> er
04:35:52 <Cale> Answer a : toTrace'   rather
04:35:57 <nomeata> Hi. I see that there are packages like base-compat that bring newer features of base to older compilers.
04:36:22 <nomeata> But has anyone already considered creating or using a package "frozen-base", that would provide the precise API of old versions of base on newer compilers?
04:37:36 <nomeata> For example a package named "base-4.6" that would compile against newer versions of GHC and base, but reexport only what was in base-4.6
04:37:50 <nomeata> (as far as possible; data type changes are not easy to hide, and neither are new class instances)
04:39:28 <Cale> Hehe, and then that package has different versions, so you end up with dependencies which look like  base-4.6 >= 1.0.2
04:40:09 <Cale> But it's an interesting idea
04:40:16 * mauke\ uploads a package called 1
04:40:34 <mauke\> version 2, so you have to write stuff like 1 >= 2
04:41:54 <nomeata> Cale: no, because that package would not change its API, you would simply depend on base-4.6
04:41:54 <Cale> Is base-4.6 actually a valid package name? I suspect it's not.
04:42:45 <nomeata> Alternatively, I considered a single package frozen-base. It would export the modules from one fixed version of base, e.g. base-4.6 (maybe removing some fast-changing or .Internal modules)
04:43:12 <nomeata> Any chnage to a module Data.Foo in later versions of base will cause the addition of a Data.Foo1 module to it
04:43:29 <nomeata> But the existing Data.Foo would not change
04:44:11 <nomeata> This way, you never _have_ to change your code. And if you do want to use the new nifty "bool" function, then you can migrate one of your modules at a time to the new API
04:44:26 <Cale> Yeah, you could have one package with many versions, but you might need to coordinate with the Hackage people if you ever uploaded a version of it with a bug that you'd like to fix, because I don't think Hackage will let you reupload an already-existing version of a package.
04:45:37 <EvanR> its sounding like these innovations could do away with versions
04:45:38 <EvanR> ;)
04:45:56 <nomeata> Cale: If I’d go the one package, many versions, one API per package variant, then the versions would be frozen-base-4.6.0.1, frozen-base-4.6.0.2 for bugfix releases.
04:46:00 <EvanR> php workflow
04:46:15 <EvanR> good old days, just modify the site directly
04:46:22 <nomeata> I don’t follow
04:47:20 <EvanR> why not just depend on the old base version directly
04:47:24 <nomeata> The frozen-base package would still have versions; If you use Data.Foo10, then you need to depend on frozen-base >= (first version providing Data.Foo10).
04:47:37 <nomeata> EvanR: because base is not upgradeable
04:47:37 <EvanR> whats the point of versions if you cant use them
04:48:05 <EvanR> and fake versions are slapped onto the name of the package
04:48:11 <nomeata> The problem is that base is both an implementation and an interface, and the implementation is tied to GHC, so you cannot get new implementations with the old interface
04:48:21 <nomeata> I’m trying to decouple the implementation from the interface.
04:49:13 <nomeata> And of course not as the standard, but rather as an alternative to those who want to have a chance of compiling 4 year old code with a current compiler.
04:50:12 <EvanR> whats wrong with base-compat
04:51:58 <Cale> EvanR: base-compat goes the other way
04:52:38 <Cale> For people who are stuck with an older version of base, but want to use features from a newer one
04:53:37 <EvanR> so this would be just the opposite
04:53:55 <hpc> so backports?
05:08:11 <mniip> I can't understand the Getter -> Fold relationship
05:08:27 <mniip> Getter is forall f. Functor f, Fold is forall f. Applicative f
05:08:34 <mniip> doesn't that mean Getter <- Fold
05:12:16 <EvanR> mniip: Getter <- Fold?
05:12:55 <mniip> http://i.imgur.com/4fHw3Fd.png
05:14:19 <haskell090> @help
05:14:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:14:27 <haskell090> @help list
05:14:27 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
05:14:35 <haskell090> @list
05:14:35 <lambdabot> What module?  Try @listmodules for some ideas.
05:15:34 * hackagebot xournal-types 0.5.1 - Data types for programs for xournal file format  http://hackage.haskell.org/package/xournal-types-0.5.1 (IanWooKim)
05:15:55 <haskell090> hello, how to query lambdabot with private messages?
05:16:07 <hpc> just PM it
05:16:29 <haskell090> PM prefix is enough?
05:16:36 <haskell090> PM @help
05:16:55 <haskell090> does PM prefix is enough?
05:16:58 <merijn> haskell090: In most IRC clients you would write "/msg lambdabot @help"
05:17:24 <haskell090> merijn: thanks
05:17:36 <EvanR> mniip: according to those types you should be able to use a Getter anywhere you can use a Fold
05:17:59 <haskell090> merijn: is there a comman to list commands avaible in IRC client?
05:18:08 <haskell090> merijn: command*
05:18:49 <mauke\> haskell090: try /help
05:18:55 <alpounet> haskell090: /query lambdabot opens up a private conversation with lambdabot in most clients
05:20:34 * hackagebot xournal-parser 0.5.1 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.5.1 (IanWooKim)
05:20:36 * hackagebot hoodle-types 0.3.0 - Data types for programs for hoodle file format  http://hackage.haskell.org/package/hoodle-types-0.3.0 (IanWooKim)
05:20:38 * hackagebot hoodle-parser 0.3.0 - Hoodle file parser  http://hackage.haskell.org/package/hoodle-parser-0.3.0 (IanWooKim)
05:20:40 * hackagebot hoodle-builder 0.3.0 - text builder for hoodle file format  http://hackage.haskell.org/package/hoodle-builder-0.3.0 (IanWooKim)
05:20:42 * hackagebot hoodle-render 0.5 - Hoodle file renderer  http://hackage.haskell.org/package/hoodle-render-0.5 (IanWooKim)
05:21:01 <mniip> EvanR, yeah why
05:21:15 <EvanR> mniip: because any type which is an Applicative is also a Functor
05:21:28 <mniip> that's the inverse
05:21:43 <EvanR> what?
05:22:18 <mniip> any applicative is a functor
05:22:26 <mniip> oh
05:22:33 <mniip> right
05:22:39 <EvanR> now im confused
05:22:49 <mniip> same
05:23:01 <mniip> any applicative is a functor
05:23:06 <mniip> hence any fold is a getter
05:23:10 <mniip> the chart says the inverse
05:23:19 <EvanR> well i dont know what the chart is implying
05:23:24 <EvanR> its just arrows
05:23:59 <EvanR> you can use an Applicative anywhere a Functor can be used
05:24:05 <mniip> You can compose any two elements of the hierarchy above using (.) from the Prelude, and you can use any element of the hierarchy as any type it linked to above it.
05:24:10 <mniip> says the page unders the chart
05:24:39 * EvanR finds the non-imgur page
05:24:50 <mniip> so it implies that any function expecting a fold will take a getter (and also a lens, traversal, prism, iso, and eq)
05:25:31 <merijn> mniip: Right
05:25:42 <merijn> mniip: Because Getter's are more powerful than Folds
05:25:44 * hackagebot hoodle-publish 0.2 - publish hoodle files as a static web site  http://hackage.haskell.org/package/hoodle-publish-0.2 (IanWooKim)
05:26:01 <merijn> mniip: A fold can fold all values into some result, whereas a getter can return individual values
05:26:07 <mniip> merijn, the type of a getter says otherwise
05:26:16 <mniip> which is where my confusion comes from
05:26:26 <EvanR> yes, we dont understand the types
05:26:34 <merijn> mniip: Where does the type say that?
05:26:50 <mniip> @info Fold
05:26:50 <lambdabot> Fold
05:26:55 <mniip> thanks lambdabot
05:27:02 <merijn> There is no @info command
05:27:16 <EvanR> type Fold s a = forall m. Monoid m => Getting m s a
05:27:18 <mniip> type Fold s a = forall f. (Contravariant f, Applicative f) => (a -> f a) -> s -> f s
05:27:22 <merijn> It's being auto-correct to something else, I forget what
05:27:28 <merijn> Getting /= Getter
05:27:34 <mniip> type Getter s a = forall f. (Contravariant f, Functor f) => (a -> f a) -> s -> f s
05:28:00 <merijn> The 'f' is not what you're getting out of
05:28:08 <merijn> the 's' is what you're getting out of
05:28:15 <merijn> And neither has any restrictions on 's'
05:28:44 <mniip> they have restrictions on the first argument though
05:28:48 <merijn> A Getter permits more operations because there are more Functors then there are Applicatives
05:28:58 <merijn> mniip: No
05:29:04 <qubitnerd> cult to nd a chip that can serve as a golden chip, which is needed by most
05:29:06 <merijn> mniip: They have restrictions on the result
05:29:06 <qubitnerd> post-manufacturing Trojan detection mechanisms.
05:29:08 <qubitnerd> sorry
05:29:10 <qubitnerd> wrong chan
05:29:24 <merijn> mniip: Fold can only returns Applicative + Contravariant
05:29:40 <merijn> Getter can return Functor + Contravariant, therefore Getter permit more operations
05:30:13 <merijn> Because Getter is less restricted in what it can return (since every Applicative is a Functor, Getter can return anything Fold can PLUS anything that is not Applicative but still a Functor)
05:30:35 * hackagebot hoodle-core 0.15 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.15 (IanWooKim)
05:30:37 * hackagebot hoodle 0.4 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.4 (IanWooKim)
05:30:42 <mniip> which means Fold -> Getter
05:30:48 <funfunctor> Speaking of Fold.. would it be a poor use of Fold to use it to make a EMA implementation?
05:30:56 <merijn> mniip: The arrow in that diagram are subclasses
05:31:04 <mniip> what you said means Getter is more general than Fold
05:31:38 <merijn> I'm confused by myself now, ask edwardk when he's here :p
05:31:48 <EvanR> heh...
05:32:11 <mniip> inb4 ek gets confused too
05:32:25 <kqr> ahhh I just managed to sneak some haskell in at work
05:32:36 <Itkovian> nice one kqr
05:32:45 <EvanR> mniip: maybe the contravariant is reversing it all
05:32:48 <kqr> so nice to be able to use parsec and blaze for marshalling
05:32:49 <Itkovian> will they fire you when discovery is made?
05:32:56 <kqr> they might
05:33:08 <Itkovian> I only managed to get them to use pandoc
05:33:19 <Itkovian> and some haskell scripts
05:33:21 <mniip> EvanR, Contravariant f, not Contravariant (=>)
05:33:26 <Itkovian> and it's all been Python ever since
05:33:34 <kqr> nah in all seriousness I'll be the person to maintain this little tool so they don't mind
05:33:47 <Itkovian> And after you change jobs?
05:33:49 <EvanR> mniip: yes, its returning a contravariant. so in my head, that means the lib will eventually pass something to it
05:33:56 <EvanR> to complete the process
05:34:08 <EvanR> but really i dont know
05:34:18 <kqr> Itkovian, after I change jobs this tool is hopefully not needed any more
05:34:54 <kqr> but I really dreaded having to do this in Python
05:35:04 <kqr> so it was nice I could take a couple of hours this morning to prototype it in haskell
05:35:13 <Itkovian> sweet.
05:35:14 <kqr> I will probably just use the prototype
05:35:21 <Itkovian> it is always thus
05:35:25 <EvanR> haskell is suited to rapid prototyping ;)
05:35:38 <EvanR> for some values of rapid and prototyping
05:35:46 <kqr> EvanR, depends on the domain I imagine
05:36:01 <EvanR> im just playing on pythons supposed strength
05:36:17 <kqr> EvanR, this time it was about converting a weird internal data format to something more reasonable like Haskell
05:36:23 <Itkovian> refactoring in Python is hell though
05:36:24 <kqr> I don't even know how to start writing a parser for that in Python
05:36:36 <kqr> but it's like 50 lines of parsec
05:36:39 <kqr> if that
05:36:48 <dramforever> Hi, I'm wondering if there's a good and easy HTML library that can do simple things like mapping a function over every anchor(<a>) nodes
05:36:50 <EvanR> i got real lost writing a parser in python once
05:37:15 <dramforever> Sorry if google tells me that. Can't access google here
05:37:47 <alpounet> dramforever: do you want to extract information from HTML?
05:37:49 <adamse> dramforever: are you parsing html or building html?
05:37:54 <zak03> what the fuck is this shit?
05:38:11 <zak03> shithsithist
05:38:14 <zak03> hit the shit
05:38:14 <EvanR> haskell is a programming language
05:38:17 <zak03> shithistshit
05:38:21 <zak03> FUCKFUCKFUC
05:38:24 <Itkovian> not again
05:38:32 <zak03> oh well fuck you nerds
05:38:54 <dramforever> alpounet: like replace all <a href="relative"> with <a href="http://abso.lu/te/relative">
05:39:10 <dramforever> so that links works correctly
05:39:13 <clrnd> jquery?
05:39:14 <dramforever> that's a example
05:39:19 <clrnd> sed too
05:39:26 <clrnd> npm install sed
05:39:30 <dramforever> isn't that too fragile?
05:39:45 <dramforever> I mean, may break with weird HTML
05:40:00 <adamse> i'd use jquery
05:40:01 <clrnd> why not jquery again?
05:40:02 <jophish> data A = A; class C c where; instance C A where; foo = A :: C c => c; -- Why can't I do this?
05:40:28 <alpounet> dramforever: we have a couple of HTML parsing/transformation libraries that should fit the bill. i wrote one of these
05:40:29 <dramforever> yeah jquery exactly what I was thinking
05:40:32 <clrnd> regarding jquery, I was just having a problem with it: it can't create svg elements
05:40:51 <dramforever> well at least we want hquery...
05:41:04 <mniip> jophish, C c => c implies forall c
05:41:07 <dramforever> alpounet: I tried reading haddocks, but failed...
05:41:12 <mniip> you are using a specific C here
05:41:19 <dramforever> what the hell are those xml packages
05:41:23 <alpounet> dramforever: and html parsing/transformation is where lenses shine, you really get a jquery feel when using html lenses :p
05:41:40 <nomeata> jophish: Because there might also be instance C B, and some user of that code might want to use "foo :: B"
05:41:44 <bitraten> Is there a changelog for major features of each ghc version?
05:41:49 <nomeata> jophish: your type signature for foo would allow that, your implementation not.
05:41:56 <adamse> alpounet: any lensy html extraction library you recommend?
05:41:57 <jophish> nomeata: ah, of course
05:42:05 <mniip> > () :: a
05:42:06 <lambdabot>  Couldn't match expected type ‘a1’ with actual type ‘()’
05:42:07 <lambdabot>    ‘a1’ is a rigid type variable bound by
05:42:07 <lambdabot>         an expression type signature: a1 at <interactive>:1:1
05:42:11 <nomeata> bitraten: the release notes? https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/release-7-8-1.html
05:42:23 <jophish> thanks guys
05:42:26 <bitraten> nomeata: thanks
05:42:33 <dramforever> alpounet: Do we have something like (Node -> Node) -> HTML -> HTML that recursively maps all nodes over my function?
05:42:37 <alpounet> adamse: my own? =) http://hackage.haskell.org/package/taggy-lens -- however there are a couple of others that can do the job just as well :)
05:42:45 <dramforever> okay I'll try
05:43:04 <EvanR> mniip: "a Getter is a legal Fold that ignores the supplied monoid" ...
05:43:39 <dramforever> and "cabal install lens" is a even better excuse for taking a break than "my code is compiling", if your boss know what that is
05:44:48 <adamse> alpounet: taggy-lens looks good, but my code with it does not look as good, I guess I need to learn lens better!
05:45:36 * hackagebot postgresql-simple 0.4.10.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.10.0 (LeonSmith)
05:46:11 <alpounet> adamse: oh well, feel free to share your code. i personally use it quite intensively for work stuffs and like it, but i can imagine this not being the case for everyone, but without feedback i can't improve it or point to nicer ways to write extraction code, etc
05:46:58 <mniip> EvanR, monoid?
05:47:07 <EvanR> Monoid
05:47:07 <mniip> what's monoid got to do with this
05:47:39 <EvanR> im not sure, except that the doc says the idea of Fold is based on Foldable, which involves a Monoid
05:47:50 <EvanR> but that never made it into the final type
05:48:32 <EvanR> im not sure what the supplied Monoid is
05:50:01 <dramforever> alpounet: Just...a quick question: (over (whichLensToPutHere) myFunction $ myRootNode
05:50:07 <dramforever> if myFunction maps elements
05:50:26 <dramforever> as I'm not really getting what your lenses means
05:50:35 <dramforever> s/means/mean
05:51:21 <dramforever> mniip: well IMHO lens is a ekmett-encoded getter and setter pair
05:51:42 <dramforever> which composes with (Prelude..) (or Prelude.(.))
05:51:51 <mniip> ekmett-encoded -,-
05:52:41 <dramforever> mniip: isn't it?
05:53:02 <dramforever> mniip: IIRC the idea is from these:
05:53:08 <dramforever> :t (.).(.).(.)
05:53:09 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
05:53:13 <dramforever> :t fmap.fmap.fmap
05:53:14 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
05:53:21 <dramforever> :t foldMap.foldMap.foldMap
05:53:22 <lambdabot> (Monoid m, Foldable t2, Foldable t1, Foldable t) => (a -> m) -> t (t1 (t2 a)) -> m
05:53:28 <dramforever> :t traverse.traverse.traverse
05:53:29 <lambdabot> (Traversable t2, Traversable t1, Traversable t, Applicative f) => (a -> f b) -> t (t1 (t2 a)) -> f (t (t1 (t2 b)))
05:53:35 <mniip> I've seen the slides
05:53:38 <mniip> makes no sense to me
05:53:45 <dramforever> mniip: yeah agree
05:54:09 <dramforever> Whoa! lens finished installing!
05:54:27 <dramforever> now go on to taggy-lens
05:54:32 <dramforever> oh...done...
05:54:33 <alpounet> dramforever: i think you may want to look into the Control.Lens.Plated module
05:54:44 <alpounet> HTML nodes in taggy have a Plated instance
05:55:08 <EvanR> mniip: hmm, because of continuation passing style, (.) composes everything in reverse, might have something to do with it
05:55:11 <alpounet> Plated basically says "this type has a concept of "children"
05:55:12 <dramforever> alpounet: okay
05:55:36 <alpounet> so your use case is about descending into the whole DOM tree and replacing relative links by absolute ones
05:55:56 <dramforever> alpounet: that was just an example, but yes
05:55:58 <alpounet> for elements that are not links or are already absolute, you leave them alone.
05:56:10 <alpounet> for the others, you make the link absolute and keep descending
05:56:49 <alpounet> dramforever: of particular interest in Control.Lens.Plated are "rewrite" and "transform"
05:57:02 <dramforever> alpounet: oh good to know
05:57:06 <alpounet> where you can replace the 'a' type variable by the Element type from taggy
05:57:44 <dramforever> looks like hackage is a bit slow here...Control.Lens.Plated still hasn't loaded
05:58:22 <alpounet> dramforever: i'll let you read/digest this, but feel free to ping me if you have questions
05:58:46 <dramforever> alpounet: whoa, rewrite is exactly what I want
05:58:56 <dramforever> thanks a lot, from taggy-lens to Plated
06:01:04 <dramforever> alpounet: Um..is that Plated recursively ascending or descending? i.e. children first or parents first?
06:01:04 <alpounet> cheers
06:02:38 <alpounet> dramforever: transform will do it bottom-up
06:02:44 <dramforever> oh thanks
06:06:05 <haasn> There's some library that implements a GLSL EDSL in Haskell and uses typesystem computation to pass along metadata and enforce invariants at compile time
06:06:09 <haasn> I forgot what it was called. Ring any bells?
06:09:03 <dramforever> oh damn. (It's okay you don't need to fix it.) just called my input data "content" and clashed with the one in Text.Taggy.Lens. Then changed to "data" and clashed with the keyword. Then changed it to "input" but accidentally hit enter (because I was a bit anxious) just after typing "in"
06:09:28 <haasn> https://github.com/fiendfan1/Haskell-GLSL-eDSL I think this seems related to what I was remembering, although the name and author are unfamiliar
06:10:29 <dramforever> alpounet: oh, do you have time? seems that your taggy lens doesn't handle this well (from Agda-stdlib-docs) (wait I'll post to lpaste)
06:10:47 <alpounet> haasn: Nikola maybe?
06:11:33 <lpaste> dramforever pasted “this” at http://lpaste.net/121233
06:11:56 <dramforever> it's a REAL html from Agda
06:12:54 <alpounet> dramforever: yeah, the parser isn't perfect so i appreciate any example on which it chokes.
06:13:07 <dramforever> alpounet: wait a sec I'll check again
06:13:13 <dramforever> maybe I just mis-looked
06:13:52 <alpounet> i doubt it. i'm suspecting i've just never encountered <tag\n> yet, that's probablu the issue =)
06:14:06 <alpounet> probably*
06:14:08 <dramforever> alpounet: okay here: your lib is generated nodes like NodeContent "\n      >"
06:14:34 <alpounet> yeah, that's certainly the issue :)
06:15:07 <dramforever> but I guess I'll patch those docs to remove \n within <tag>
06:15:13 <Cale> Yeah, it's a common trick when generating HTML to avoid whitespace sensitivity.
06:15:17 <dramforever> it's not very hard
06:15:36 <alpounet> dramforever: i'd rather fix the parser than have you do that for every new version of the docs ;)
06:15:53 <dramforever> alpounet: okay thanks
06:16:13 <dramforever> but before that fix I'll have to do that...
06:16:25 <dramforever> I guess I could write a program for that?
06:16:34 <alpounet> dramforever: can you give me a link to the HTML page we're talking about? so that i test my patch before releasing a new version
06:16:52 <dramforever> alpounet: http://lpaste.net/121233
06:17:16 <alpounet> ok well i'll just add a </html> at the end
06:17:24 <dramforever> alpounet: oh waut
06:17:25 <dramforever> wait
06:17:30 <dramforever> http://agda.github.io/agda-stdlib/
06:17:41 <dramforever> here it is, the full version
06:17:48 <dramforever> alpounet: ^ github
06:17:56 <alpounet> thanks
06:18:07 <dramforever> alpounet: thanks to you too
06:19:51 <aawe> I had a hen named agda once. It was small and bald. Thus, I cannot take agda the programming language seriously
06:20:12 <mauke\> better than Coq
06:20:17 <dramforever> aawe: that reminds me of this:
06:20:20 <dramforever> @hackage miku
06:20:20 <lambdabot> http://hackage.haskell.org/package/miku
06:20:46 <hodapp> mauke\: what's a rooster have to do with this?
06:20:57 <dramforever> ha ha lol
06:21:03 <dramforever> Coq, hen, rooster
06:21:07 <mauke\> dramforever: formerly "loli"
06:21:20 <dramforever> mauke\: yeah exactly
06:21:34 <dramforever> you know what those means?
06:21:48 <clrnd> lol
06:21:57 <mauke\> I only know miku from "hatsune miku"
06:22:07 <dramforever> mauke\: yes
06:22:12 <clrnd> I remember a japense haskell manga
06:22:20 <dramforever> japense...
06:22:34 <aawe> ain't nothing wrong with the jappense
06:22:35 <dramforever> only three syllabls
06:22:48 <clrnd> that's a hilarious typo, gonna leave it like that
06:22:49 <dramforever> s/syllabls/syllables/
06:22:53 <dramforever> okay
06:23:59 <dramforever> mauke\: loli is a common voice-translation of the chinese 萝莉(luo li), which approximately means "cute girl"
06:24:00 <aawe> "The original Agda system was developed at Chalmers by Catarina Coquand in 1999", "Appeared in 	2007" make up your mind, wikipedia
06:24:14 <dramforever> like...small cute girl-y
06:24:57 <hodapp> aawe: waidaminute, Coquand made Agda too?
06:24:57 <cow_2001> long live talos!
06:25:14 <mauke\> dramforever: it's also a common (japanese) abbreviation of "lolita"
06:25:39 <tdammers> aawe: some things don't appear in public until long after they've been developed
06:25:44 <dramforever> mauke\: yes, and that might be the origin of that Chinese expression too
06:25:58 <dramforever> I'm not really sure, but I think you are correct
06:26:14 <mauke\> if you look at the right (drawn) porn sites, sex with underage girls will be tagged "loli"
06:26:31 <dramforever> um...
06:26:54 <dramforever> I guess loli means basically any cute little girl-y
06:26:57 <cow_2001> there aren't many words startung with 'ta' in my mind available for this
06:27:01 <dramforever> here in China
06:27:24 <dramforever> mauke\: Jinjing Wang is obviously Chinese
06:27:34 <clrnd> in the west is ussually uneraged hentai, yeah
06:28:02 <cow_2001> you're dealing with contraband comics
06:28:06 <mauke\> the other common variant is "lolicon", i.e. someone with a lolita complex
06:28:08 <clrnd> a friend told me
06:28:24 <dramforever> mauke\: yep that's common here in China too
06:28:31 <dramforever> I mean, the expression
06:29:06 <cow_2001> miaow
06:29:16 <dramforever> cow
06:29:22 <cow_2001> hmm?
06:29:29 <dramforever> cow_2001: cow goes miaow?
06:29:40 <clrnd> in china?
06:29:44 <cow_2001> when we are pressed to do so
06:29:51 <mauke\> clrnd: in #haskell
06:29:53 <dramforever> clrnd: cow_2001 says "miaow"
06:30:02 <clrnd> ;D
06:30:19 <dramforever> just like someone called "cat" joined and says "woff"
06:30:38 * hackagebot call 0.1.4.2 - The call game engine  http://hackage.haskell.org/package/call-0.1.4.2 (FumiakiKinoshita)
06:31:39 <dramforever> clrnd: like this:
06:31:45 <dram_as_a_cat> woff
06:31:47 <dram_as_a_cat> woff
06:32:14 <clrnd> but that's just you_as_a_cat
06:32:34 <dramforever> clrnd: because it's kinda hard to be called cat on freenode
06:32:39 <clrnd> a furry tail won't make a frog a cat
06:33:03 <clrnd> ohh, I can understand that with, a little good faith
06:33:13 <mauke\> clrnd: http://i.imgur.com/mmlJICx.jpg
06:33:42 <cutecat> woff
06:33:44 <cutecat> woff
06:33:45 <clrnd> jaja no idea what that is
06:39:28 <alpounet> dramforever: i think i've got it. i don't see any NodeContent "\n" and the tags seem to be well interpreted
06:39:34 <hclaypool> Hello
06:39:49 <dramforever> alpounet: so..upload maybe?
06:39:56 <alpounet> yeah
06:40:17 <dramforever> alpounet: thanks a lot
06:42:02 <alpounet> dramforever: done, 0.1.4. let me know if i've missed something/if the problem persists/if you find another problem
06:43:42 <dramforever> alpounet: Um...hackagebot didn't say anything about your package yet...
06:43:59 <dramforever> hclaypool: well Hello
06:44:10 <c_wraith> hackagebot polls at regular (infrequent) intervals
06:44:11 <alpounet> dramforever: it checks for uploads every few minutes, be patient =) it appears on http://hackage.haskell.org/packages/recent
06:44:46 <dramforever> alpounet: okay
06:45:39 * hackagebot taggy 0.1.4 - Efficient and simple HTML/XML parsing library  http://hackage.haskell.org/package/taggy-0.1.4 (AlpMestanogullari)
06:45:45 <dramforever> oh good
06:48:27 <fedora-i5> Hey, guys can anyone recommend any Haskell to read/learn from?
06:48:34 <fedora-i5> I am new to Haskell
06:48:51 <merijn> fedora-i5: As in source code?
06:48:55 <fedora-i5> yeah
06:49:03 <fedora-i5> Maybe some open source project
06:49:07 <merijn> fedora-i5: xmonad is pretty small and well-written, or at least, was when I last checked :)
06:49:09 <mauke\> main = putStr "Hello, world!\n"
06:49:38 <merijn> pandoc is not too bad if you stick to the parsers/writer bits and not the gory internals :p
06:50:51 <fedora-i5> @merijn Thanks
06:50:51 <lambdabot> Unknown command, try @list
06:50:59 <dramforever> fedora-i5: lol
06:51:01 <dramforever> you don
06:51:08 <dramforever> you don't use @ here
06:51:16 <bergmark> and that's why we don't use @
06:51:24 <mauke\> what, I thought this was twitter
06:51:33 <silver> @botsnack
06:51:33 <lambdabot> :)
06:51:34 <fedora-i5> I will look into those libraries
06:51:44 <dramforever> ? what is it
06:51:49 <dramforever> ?what is it
06:51:50 <lambdabot> I know nothing about is.
06:55:02 <clrnd> how do name arguments get along with funciton composition and currying? regarding FP languages like OCaml
06:55:10 <clrnd> s/name/named/
06:55:28 <dramforever> IMHO not very well
06:55:39 <tdammers> "not", tee hee
06:55:43 <dramforever> just like foo.bar.baz in OOP
06:56:09 <tdammers> fwiw, underscore.js overloads _ to indicate a free spot when currying
06:56:11 <ab9rf> named arguments?
06:56:18 <tdammers> ab9rf: like in Python
06:56:22 <tdammers> def foo(bar=None)
06:56:23 <ab9rf> oh, i hate those
06:56:34 <ab9rf> i consider them an antipattern
06:56:38 <dramforever> clrnd: well, but haskell (sort of) have them
06:56:45 <dramforever> they are just called "records"
06:56:47 <clrnd> yeah me too, just fought a python function with them a second ago
06:56:59 <arw_> dramforever: in that sense, almost any language has them
06:57:09 <dramforever> ab9rf: remainings of smalltalk
06:57:11 <tdammers> javascript too... foo({bar:baz})
06:57:17 <mauke\> ab9rf, clrnd: can you elaborate about what's bad about those?
06:57:19 <dramforever> arw_: well, it's really akward in C
06:57:38 <dramforever> tdammers: that's...actually very common
06:57:47 <tdammers> dramforever: yes, I know
06:57:56 <ab9rf> tdammers: those aren't really named parameters, it's a "bucket" parameter that contains a map
06:58:02 <dramforever> yep
06:58:04 <ab9rf> the same is true in python
06:58:05 <dramforever> but same use
06:58:09 <tdammers> ab9rf: yes, but they're the closest thing in JS
06:58:20 <ab9rf> pyhton just has syntactic sugar for it
06:58:26 <clrnd> python has the super silly **kwargs pattern
06:58:33 <arw_> dramforever: no, in newer c standards you can easily specify structure literals, with that its relatively nice
06:58:40 <dramforever> alpounet: perfect. now it's exactly what I want
06:58:40 <clrnd> ab9rf, high five!
06:58:45 <tdammers> yeah, but that syntactic sugar makes a lot of sacrifices just to get rid of two extra characters
06:58:57 <tdammers> foo({bar: "baz"})
06:59:02 <tdammers> foo(bar="baz")
06:59:16 <alpounet> dramforever: sweet, you can now start enjoying the power of traversals =)
06:59:18 <tdammers> not worth it IMO
06:59:19 <ab9rf> tdammers: and conceals the runtime cost of the map
06:59:26 <clrnd> well in python it'd be foo({"bar": "baz"})
06:59:32 <tdammers> python conceals a truckload of runtime costs
06:59:41 <tdammers> clrnd: sure
06:59:43 <dramforever> in ruby it's foo(bar: baz)
06:59:47 <ab9rf> mauke\: i don't like that function application is made so complex
06:59:53 <dramforever> at least it works in 1.9+
07:00:08 <ab9rf> mauke\: i also dislike optional arguments and overloaded functions :)
07:00:29 <mauke\> hmm
07:00:32 <dramforever> foo(bar, baz, barbar: bazbaz) gets desugared to foo(bar, baz, {:barbar => bazbaz})
07:00:39 <ab9rf> mauke\: creates too many opportunities for the compiler to has to guess at what the programmer intended
07:00:46 <dramforever> where :barbar is a symbol just like lisp
07:00:56 <mauke\> I agree with the overloading part
07:01:04 <ab9rf> mauke\: optionals are just a type of overloading
07:01:08 <mauke\> I disagree
07:01:19 <exio4> ab9rf: overloaded functions? a la typeclasses or more ad-hoc?
07:01:25 <mauke\> exio4: ad hoc
07:01:31 <ab9rf> exio4: no, ad hoc ala java
07:01:33 <ab9rf> or C++
07:01:40 <exio4> ah, I agree then
07:01:57 <kqr> hey! I have a [Text] and I wish to group it into groups based on a delimiter Text
07:02:11 <mauke\> ab9rf: I've implemented parameter lists (including default arguments and named parameters) as a Perl extension
07:02:20 <mauke\> that's why I'm interested
07:02:24 <ab9rf> mauke\: heh
07:02:31 <kqr> so for example if the delimiter is "" then I'd want ["foo", "", "bar", "baz", "", "quux"] to turn into [["foo"], ["bar", "baz"], ["quux"]]
07:02:37 <kqr> is there an easy way to accomplish this?
07:02:42 <mauke\> ab9rf: but that's more of a #haskell-blah topic
07:02:46 <kqr> (my current recursive function is a mess...)
07:02:49 <ab9rf> mauke\: perl is already about as impure as the snow on the dan ryan at 9am on a monday.
07:03:05 <ab9rf> mauke\: a bit more pee in that mess won't even be noticeable.
07:03:06 <haasn> alpounet: Hmm, don't think so - can't find any mention in my logs
07:03:57 <alpounet> haasn: i know that phaazon is/was working on one, named 'ash', but aside from those two and the one you linked to, I haven't heard of any other
07:04:55 <dramforever> um..anyone tried to compare Map and HashMap?
07:05:01 <dramforever> I mean, speed
07:05:28 <jtanguy> kqr: you might want to use Data.List.Split, from the split package
07:05:41 * hackagebot debian-build 0.7.1.0 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.7.1.0 (KeiHibino)
07:05:45 <alpounet> dramforever: unordered-containers' benchmark suite -- https://github.com/tibbe/unordered-containers/blob/master/benchmarks/Benchmarks.hs
07:06:12 <kqr> jtanguy, I checked that out, but I didn't find anything super helpful. apparently it doesn't do groupings
07:06:37 <aawe> alpounet: are the results published anywhere? I can't spare any cycles
07:07:28 <jtanguy> > splitOn [""] ["foo", "", "bar", "baz", "", "quux"]
07:07:30 <lambdabot>  [["foo"],["bar","baz"],["quux"]]
07:07:44 <dramforever> aawe: I guess it's YBRMV (your benchmarking results may vary)
07:08:31 <alpounet> aawe: i'm afraid the only ones you'll find will be a bit old, and on Johan Tibell's blog
07:10:32 <alpounet> aawe: e.g http://www.scs.stanford.edu/11au-cs240h/notes/performance.html#(32)
07:10:41 * hackagebot test-sandbox 0.1.2 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.1.2 (junjihashimoto)
07:13:32 <jtanguy> kqr: it seems to to the job to me
07:13:51 <haasn> alpounet: I figured out the author: jfischoff
07:14:08 <thebnq> my code is over twice as slow with the ncg vs llvm :(
07:14:57 <haasn> alpounet: I found the library! https://github.com/jfischoff/oxymoron \o/
07:15:02 <kaeluka> I read/heard somewhere that there’s a (type theory) reason why haskell needs bottom, but can’t remember what it was. Can anyone clarify?
07:15:52 <tdammers> .oO(gödelsomethingsomething mumble)
07:15:53 <quchen2> kaeluka: Turing completeness.
07:16:02 <haasn> alpounet: Seems like it did much less than I remembered it doing :)
07:16:24 <thebnq> kaeluka: its not unique to haskell
07:16:26 <quchen2> kaeluka: Without bottom you can't express non-terminating programs, which is something a Turing machine has to be able to.
07:16:47 <kaeluka> quchen2: ha!
07:16:53 <kaeluka> makes perfect sense
07:17:08 <quchen2> Most languages have bottom as well, but it's laziness that requires us to think about it more.
07:17:25 <quchen2> In C and Java, bottoms make your program crash, period. In Haskell, that's not necessarily the case.
07:17:30 <alpounet> haasn: hah, hadn't heard about this one. well, I'm not sure which one i would recommend though
07:17:57 <levi> Another aspect to the reason you have to deal with bottoms more in haskell is lazy evaluation.
07:18:00 <tdammers> laziness, and a strict type system
07:18:08 <mauke\> int bottom(void) { while (1) {} }
07:18:09 <kqr> jtanguy, I must have been doing something wrong then. thanks
07:18:30 <kaeluka> why is bottom more of a problem with laziness?
07:18:49 <c_wraith> You can have bottoms in any expression, not just function calls
07:19:06 <kaeluka> hm, yeah, makes sense
07:19:09 <c_wraith> In some ways, it's more uniform - every expression of the same type has the same possible values.
07:19:12 <kaeluka> take 12 [1..]
07:19:15 <c_wraith> But it's definitely different
07:19:24 <levi> In a strictly evaluated language, non-termination can't hide in unevaluated expressions, or at least not in as many of them.
07:19:38 <c_wraith> let x = x in x
07:19:45 <c_wraith> non-function bottom value!
07:19:56 <quchen2> kaeluka: When you want to leverage laziness, you have to think about bottom. You can also go fully strict, but then you lose all the benefits laziness provides you with.
07:20:16 <dramforever> c_wraith: yes, you are right
07:20:32 <mauke\> c_wraith: ... in x :: a -> b  -- now it's a function again
07:20:33 <quchen2> (You should still think about bottom, but it's not as obvious that it's a useful concept in strict languages.)
07:20:49 <kaeluka> idris has the total keyword. am i right in thinking that, due to laziness, that would be hard to implement in haskell?
07:21:15 <dramforever> kaeluka: total isn't possible to be absolutely correct
07:21:28 <dramforever> you heard of the Halting Problem in CS class?
07:21:33 <kaeluka> yes, sure
07:21:45 <dramforever> same thing for total
07:21:54 <kaeluka> but in idris, total means “obviously total"
07:22:14 <dramforever> okay...
07:22:14 <kaeluka> so there are total functions that wouldn’t pass the totality check
07:22:17 <kaeluka> right?
07:22:23 <dramforever> yep, iirc
07:22:36 <dramforever> in haskell a function may be partially total
07:22:37 <quchen2> There are total languages where everything is total.
07:22:42 <levi> It's actually a useful reasoning property to *not* have bottom in your type system. Haskell researchers had to justify the fact that a lot of the informal reasoning used in Haskell isn't formally valid when types are 'enriched' with bottom. But non-strict evaluation has *different* useful reasoning properties, so it's a tradeoff.
07:22:50 <c_wraith> Yeah, there will always be total functions that don't pass a particular totality test
07:22:50 <dramforever> here x = (x, tail x)
07:23:17 <dramforever> > let somewhatTotal x = (x, tail x) in someWhatTotal []
07:23:18 <lambdabot>  Not in scope: ‘someWhatTotal’
07:23:18 <lambdabot>  Perhaps you meant ‘somewhatTotal’ (line 1)
07:23:23 <kaeluka> levi: that’s why i’m asking
07:23:23 <quchen2> c_wraith: BusyBeaver(n)? :-)
07:23:28 <dramforever> > let somewhatTotal x = (x, tail x) in somewhatTotal []
07:23:30 <lambdabot>  ([],*Exception: Prelude.tail: empty list
07:23:38 <c_wraith> quchen2: I'd love to see your function for that....  :P
07:23:39 <dramforever> kaeluka: therefore it's hard
07:23:52 <c_wraith> quchen2: I was thinking more like collatzLength
07:24:04 <c_wraith> Which... is only probably total. :)
07:24:04 <aawe> " total isn't possible to be absolutely correct " what about: f :: Bool -> Bool; f True = True; f False = False
07:24:07 <aawe> that is provably total
07:24:15 <quchen2> c_wraith: That's an interesting case, because we don't know the result. BusyBeaver has a known result, but we don't know it.
07:24:16 <dramforever> aawe: well
07:24:16 <kaeluka> aawe: yeah
07:24:32 <dramforever> by absolutely correct I mean that total is correct in all cases
07:24:35 <kaeluka> but you can’t build a totality checker that will always be correct
07:24:37 <quchen2> c_wraith: Not-yet-known-whether-decidability!
07:24:38 <c_wraith> quchen2: busy beaver is also non-computable by definition.  It's awfully hard to write a function for that. :P
07:24:44 <aawe> ah ok
07:24:52 <dramforever> because forall total, exists function, total fails on function
07:25:01 <quchen2> c_wraith: Sure, that's why I mentioned it. But the first couple of busy beaver numbers are known nevertheless.
07:25:24 <quchen2> And by couple I mean up to 3 or 4. Not very spectacular.
07:25:44 <kaeluka> aawe: so what you can do (only in strict languages, i believe now) is, for example: require a total function to only call total functions and to only use complete pattern matchings
07:26:02 <dramforever> kaeluka: how about recursion?
07:26:05 <quchen2> Still, it's as well-defined total function from N to N.
07:26:08 <dramforever> and also positivity
07:26:27 <dramforever>  
07:26:27 <dramforever> newtype F a = F { unF :: F a -> a }
07:26:33 <dramforever> y = \f -> (\x -> x (F x)) (\x -> f (unF x x))
07:26:35 <aawe> kaeluka: is haskell a strict language in that sense?
07:26:44 <kaeluka> dramforever: right, had forgotten about this. I think that theres’ some requirement for args to be smaller on recursive calls
07:27:02 <dramforever> kaeluka: and also positivity, of course
07:27:15 <kaeluka> positivity?
07:27:27 <dramforever> kaeluka: see that y above?
07:27:34 <dramforever> @let
07:27:34 <lambdabot>  Define what?
07:28:10 <levi> kaeluka: Not for a Turing-complete language, anyway. The total functional languages (e.g. the core languages of theorem provers) are total, but not Turing-complete.
07:28:38 <aawe> @let str = "pls no uncle haskell"
07:28:39 <lambdabot>  Defined.
07:29:10 <dramforever> @let newtype DramF a = DramF { unDramF :: DramF a -> a }
07:29:11 <lambdabot>  Defined.
07:29:41 <dramforever> > let y = \f -> (\x -> x (DramF x)) (\x -> f (unDramF x x)) in take 10 (y (1:))
07:29:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
07:29:46 <dramforever> kaeluka: ^ see this
07:29:53 <dramforever> recursion with no recursion
07:30:11 <dramforever> that's because DramF is problematic
07:30:15 <dramforever> ...
07:30:18 <kaeluka> dramforever: yeah, but lack context
07:30:20 <dramforever> I'm not problemmatic
07:30:40 <dramforever> kaeluka: newtype DramF a = DramF { unDramF :: DramF a -> a }
07:30:52 <dramforever> :t \f -> (\x -> x (DramF x)) (\x -> f (unDramF x x))
07:30:53 <lambdabot> (a -> a) -> a
07:30:59 <dramforever> operational fix!
07:31:12 <dramforever> kaeluka: you know what's fix, right?
07:32:34 <kaeluka> yeah, kind of
07:32:51 <kaeluka> “repeat until fixpoint”
07:33:15 <mauke\> no, not really
07:33:26 <dramforever> no "until" just repeat
07:33:36 <mauke\> it constructs the point directly
07:33:47 <mauke\> and no repeat either
07:33:58 <dramforever> kaeluka: and above it's a fix using no recursion
07:34:04 <dramforever> it seems prefectly total
07:34:07 <kaeluka> right, but as soon as fixpoint is reached, the computation stops, due to ref transparency, right?
07:34:18 <merijn> No
07:34:22 <mauke\> the fixpoint isn't "reached"
07:34:28 <merijn> It *is* a fixpoint
07:34:28 <dramforever> it's there
07:34:34 <tdammers> "it just is"
07:35:02 <kaeluka> that’s why i said “kind of”. i’ve seen definitions. i don’t *GET* it
07:35:04 <merijn> kaeluka: Probably the best way to look at this is looking up Church encoding and how to implement arbitrary recursive functions using fix
07:35:27 <dramforever> (let x = 1 : x in x) is a cyclic list after evaluating to WHNF
07:35:32 <merijn> oh
07:35:39 <merijn> looks like monochrom went through the trouble for me
07:35:40 <merijn> kaeluka: http://www.vex.net/~trebla/haskell/fix.xhtml
07:35:43 * hackagebot stripe-haskell 0.1.1.1 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.1.1 (DavidJohnson)
07:41:06 <kaeluka> thanks folks!
07:41:17 <kaeluka> i’ll do some reading ;)
07:41:37 <kaeluka> question was answered, new questions spawned :)
07:43:57 <merijn> kaeluka: Eternal story of learning ;)
07:44:33 <kaeluka> +1
07:46:12 <arj> dramforever: partially total?!?
07:46:24 <tdammers> arj: totally partial.
07:46:27 <arj> unprovably total?
07:48:24 <nshepperd> I wonder just how much mileage you can get out of djinn by expressing recursive types as folds
07:48:58 <quchen2> dramforever: Arguably. It's an infinite list, and the compiler can decide to represent it in an efficient way. But you can't take a list and decide whether it's cyclic for example. In other words, cyclic lists don't exist on the Haskell language level, but on the implementation level. (Or does the Report demand something special in this case?)
07:55:01 <phaazon> alpounet: haasn, yeah, I saved the project for later (ash)
07:55:07 <phaazon> it’ll be named another way
07:55:28 <phaazon> and I’ll get back to it when my engine is fully operational
07:57:30 <merijn> quchen2: Pretty sure the report demands that "let ones = 1 : ones" is cyclic
07:58:23 <merijn> I guess this quickly becomes a semantics question
07:58:44 <merijn> But yeah, you can't detect cycles without horrific compiler hacks and maybe not even then
07:59:45 <Cog-noob> Hello! A few course mates and I are looking to make a program for our introduction course to programming tools for cognitive scientists at uni. I'm trying to find out if it would be possible to process images using Haskell. Anyone got an idea for where to start looking?
08:00:22 <merijn> juicypixels?
08:00:38 <nomeata> Cog-noob: gloss?
08:03:17 <Cog-noob> merijin and nomeata, this seems like something that may  be helpfull if I manage to understand it. Thank you!
08:15:26 <nerium> Anyone knows BNFC here? Im having problem defining QualifiedConst and Types
08:24:19 <studell> Hey guys, I'm currently taking a course in haskell at uni and for the final lab we are supposed to contribute to an open source project of our chosing. After looking thorugh packages at hackage I find them very well tested and well documented. So I figured that there is no harm in asking you guys if you know any project that could need a helping hand? Preferably nothing to obscure. Either testing, documentation or some modification is ok. A
08:24:38 <mauke\> cut off at "is ok. A"
08:25:00 <shelf> studell: there are a lotttt of issues open for Pandoc, if you know a little about parsers!
08:25:37 <studell> Sorry, last part was just: Any help is greatly appreciated!
08:25:56 <studell> Thanks shelf, will look into that!
08:34:23 <shelf> studell: you might have better luck by going onto github and sorting by popularity, then looking at the issue trackers
08:35:22 <shelf> also, for low hanging fruit, fix occurrences of 'fromJust', or fix cabal constraints for packages that don't currently build :)
08:37:29 <Polarina> There are also some libraries related to game development that could use some love.
08:38:37 <studell> Thanks for the suggestions, will look into it. fixing cabal constraints is probably a bit too low hanging, but always nice to have a backup :)
08:39:57 <studell> Polarina: Ok, thanks for the tip
08:53:31 <sdfl> is there a way to see the instance definition of a class for a type?
08:53:44 <sdfl> in ghci
08:54:14 <Polarina> sdfl, :i Num
08:54:40 <sdfl> Polarina: I mean the definition the the typeclass for a type
08:54:55 <sdfl> like see the definition of (+) for Integer
08:55:20 <sdfl> or >>= for Reader etc
09:02:06 <shelf> not afaik
09:02:43 <shelf> I asked this a few weeks ago and haven't found anything online since. someone pointed me at ghci-ng, but I couldn't figure out any such facility
09:05:17 <hibou> hi
09:05:42 <hibou> somebody knows why this is too slow ?
09:05:43 <hibou> fibs = map fst $ iterate (\ (a, b) -> (b, a + b)) (0,1)  problem2 = sum [x | x <- fibs, even x, x < 4 * 10^6]
09:05:52 <hibou> fibs = map fst $ iterate (\ (a, b) -> (b, a + b)) (0,1
09:05:56 <hibou> problem2 = sum [x | x <- fibs, even x, x < 4 * 10^6]
09:07:37 <HeladoDeBrownie> hibou, in what way is it too slow?
09:07:38 <xnull_> :t (<*>)
09:07:39 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:07:45 <xnull_> i really do think i've gotten it now
09:08:17 <clrnd> hibou, lpaste too
09:08:52 <latk> Is it necessary to use any ghc-options on the library section of a cabal file? Or are they inferred from the executable that uses the library ?
09:09:09 <hibou> HeladoDeBrownie: It just never ends
09:09:12 <dcoutts> latk: generally not needed
09:09:23 <latk> dcoutts: generally ?
09:09:28 <latk> dcoutts: When are they required ?
09:09:30 <dcoutts> latk: you'll see a common one is -Wall, to enable ghc warnings
09:09:41 <HeladoDeBrownie> i actually can't even get it to compile, even considering i fixed the typos
09:10:08 <HeladoDeBrownie> oh never mind
09:10:27 <HeladoDeBrownie> hibou, well, what you have there *does* compute an infinite list, is that what you're talking about?
09:11:16 <HeladoDeBrownie> hibou, so yes, if you try to force the entire list, that evaluation will never end. but you can force just specific parts of it.
09:11:23 <hibou> HeladoDeBrownie: yes but I have x < something, why it's still infinite
09:11:23 <HeladoDeBrownie> fibs !! 1000 -- for example
09:11:24 <dcoutts> latk: you can safely omit ghc-options, or use just -Wall
09:11:34 <latk> dcoutts: Thanks very much :)
09:11:45 <HeladoDeBrownie> hibou, because the language doesn't know that the fibonacci sequence is monotonic.
09:11:55 <clrnd> hibou, well, filter dosen't know if a n > x could appear in the future
09:12:30 <hibou> ok maybe I can change it with a takeWhile function
09:12:40 <hibou> I don't understsand monotonic
09:12:53 <HeladoDeBrownie> hibou, basically what clrnd said
09:13:19 <HeladoDeBrownie> a function increases monotonically if larger inputs never lead to smaller outputs than were seen previously.
09:13:53 <HeladoDeBrownie> that's the essential property a function would have to have in order for something sufficiently clever to know to stop once it hits a certain limit.
09:13:57 <hibou> HeladoDeBrownie: so I should never use list comprehension with infinite list ?
09:14:01 <HeladoDeBrownie> i didn't say that.
09:14:15 <hibou> and use something like takeWhile instead ?
09:14:17 <HeladoDeBrownie> just recognize that asking only for elements less than a certain amount does not guarantee termination if there wasn't before.
09:14:41 <HeladoDeBrownie> (if there wasn't guaranteed termination before, i mean)
09:14:43 <clrnd> hibou, you can use list comprehensions on an infinite list, just don't expect it not to be infinite too
09:15:14 <hibou> ok i'm beginner with Haskell so maybe I must try something simple
09:16:11 <HeladoDeBrownie> this is a case of the language not meeting your intuition. you'll probably run into many more of those still.
09:16:17 <hibou> ok
09:16:20 <HeladoDeBrownie> programming is not intuitive.
09:16:47 <hibou> I know, the journy of Haskell begins!
09:16:55 <clrnd> :D
09:17:08 <HeladoDeBrownie> \o/
09:19:45 <hibou> clrnd: my answer for this problem is sum $ filter even $ takeWhile (\ x -> x < 4*10^6) fibs
09:20:24 <HeladoDeBrownie> hibou, looks good at a glance
09:20:26 <clrnd> hibou, perfect :)
09:22:33 <hibou> thanks!
09:46:04 <JoshieAS> wow, didn't know pandoc was in Haskell, that's awes
09:47:34 <hibou> factors n         | n == 1 = [1]         | otherwise = f n 2 []             where f n i l                 | (n `rem` i == 0) = f (n `div` i) i i:l                 | (i < (sqrt $ fromIntegral n)) = f n (i + 1) l                 | otherwise = l
09:47:45 <hibou> sorry
09:48:28 <hibou> can i define a function after "where" ?
09:48:38 <hibou> f x y
09:48:48 <hibou> where f a b
09:48:57 <hibou>    | a < b: 0
09:49:10 <hibou>    | a > b = 1
09:49:37 <ibid> yes
09:50:05 <ibid> (the colon is, of course, incorrect syntax)
09:50:13 <hibou> yes
09:50:30 <hibou> but I've got an error "parse error"
09:51:45 <ibid> hibou: no doubt because of the colon?
09:52:03 <ReinH> hibou: also the guards need to be indented relative to the f, not the where
09:52:10 <hibou> http://paste.ofcode.org/r743gvGuUUTysAp5vVhh52
09:52:11 <ibid> also, you must remember correct indentation
09:52:14 <ibid> what ReinH said
09:52:23 <hibou> ah yes
09:54:14 <HeladoDeBrownie> hibou, fairly common style puts where at a half-indent (2 spaces, depending) after the definition it's attached to, with the local definitions a half-indent beyond that on new lines.
09:54:28 <HeladoDeBrownie> this is not by any means universal though
09:54:33 <geekosaur> tabs?
09:54:47 <HeladoDeBrownie> geekosaur, are you suggesting that tabs be used?
09:54:55 <geekosaur> no, it looks like it is using tabs
09:55:00 <geekosaur> and leading to bad indentation
09:55:17 <geekosaur> I think lines 5-7 need extra indentation?
09:55:44 <geekosaur> also i suspect the end of line 5 is wrong (perhaps should be `(i:l)`?)
09:55:55 * HeladoDeBrownie wonders if tabs would get less of a bad rep if they were easier to use correctly
09:55:57 <geekosaur> may be wrong
09:56:09 <geekosaur> emacs does tabs properly :)
09:57:01 <hibou> yes, i've got error  Occurs check: cannot construct the infinite type: a0 = [a0]     In the return type of a call of `f'
09:57:23 <hibou> why I need to grap it in ()
09:57:25 <hibou> ?
09:58:32 <HeladoDeBrownie> hibou, could you make a paste of the code as it stands now, along with the full error?
09:58:35 <zennist> was learning the basics and seen definitions for monoids and MonadPlus: why the duplication?
09:58:47 <HeladoDeBrownie> zennist, they're of different kinds
09:58:53 <hibou> http://paste.ofcode.org/3seVmPVSshVBCMHqDaADs5
09:59:02 <ibid> zennist: also, MonadPlus is older
09:59:03 <HeladoDeBrownie> Monoids are of kind * while MonadPlus is of kind * -> *, and also include Monad
09:59:18 <hibou> http://paste.ofcode.org/pZDQXRpQtCir7RKg6kB363
09:59:24 <ReinH> hibou: assuming you're referring to f (n `div` i) i i:l, that is treated as (f (n `div` i) i i):l
09:59:25 <hibou> now the error is
09:59:30 <HeladoDeBrownie> kind polymorphism seems to be a relatively new advancement in the haskell ecosystem, although even then they're not quite redundant.
09:59:33 <hibou> ok
09:59:41 <hibou> Ambiguous type variable `t0' in the constraints:       (Floating t0)         arising from a use of `factors' at <interactive>:201:1-7       (Integral t0)         arising from a use of `factors' at <interactive>:201:1-7       (Num t0) arising from the literal `10' at <interactive>:201:9-10     Probable fix: add a type signature that fixes these type variable(s)     In the expression: factors 10     In an equation for `it': it = factor
10:00:12 <hibou> http://paste.ofcode.org/ZcFdrp7g3SrNJfGbV8FWS2
10:01:26 <zennist> HeladoDeBrownie: I'm a newbie, but, why can't 'm a' be a 'a'?
10:01:50 <HeladoDeBrownie> zennist, it can. but MonadPlus works on the m applied to any a at all.
10:01:58 <clrnd> hibou, try adding a type signature, like: `factors :: Integer -> Integer`
10:02:02 <HeladoDeBrownie> hmm, i said that poorly.
10:02:24 <geekosaur> hibou, your code simultaneously wants the type of n and i to be an Integral (use of rem and div) and a Floating (comparison to result of sqrt)
10:03:19 <hibou> but I've converted it with fromIntegral
10:03:26 <hibou> No instance for (Floating Integer)       arising from a use of `f'     Possible fix: add an instance declaration for (Floating Integer)     In the expression: f n 2 []     In an equation for `factors':
10:03:42 <geekosaur> but you did not convert *back*
10:04:28 <hibou> ok i modified it (fromIntegral i) < (sqrt $ fromIntegral n)
10:04:35 <HeladoDeBrownie> zennist, MonadPlus implies Monad, which is a major difference. with Monad you can compose values of different types together (which Monoid does not permit by itself), e.g., (return 'a' >> mzero) :: IO () -- not a useful example but hopefully illustrative
10:04:41 <hibou> it compiles
10:04:43 <hibou> thanks
10:05:08 <HeladoDeBrownie> zennist, but the thing that must be in common between those types is the type function m
10:05:35 <HeladoDeBrownie> zennist, in other words MonadPlus should be seen as useful also in terms of how Monad is useful, whereas Monoid stands by itself, more or less. does that help?
10:05:53 * hackagebot Wordlint 0.2.0.3 - Plaintext prose redundancy linter.  http://hackage.haskell.org/package/Wordlint-0.2.0.3 (bgbgbg)
10:06:20 <emaczen> So I have the symbol '* how can I get the multiplication function from this symbol?
10:06:40 <HeladoDeBrownie> zennist, incidentally, there are cases where mappend and mplus serve just as well as each other.
10:06:48 <ibid> emaczen: what do you mean?
10:06:50 <HeladoDeBrownie> > [1, 2, 3] `mappend` [4, 5, 6]
10:06:52 <lambdabot>  [1,2,3,4,5,6]
10:06:55 <HeladoDeBrownie> > [1, 2, 3] `mplus` [4, 5, 6]
10:06:56 <lambdabot>  [1,2,3,4,5,6]
10:07:15 <ibid> emaczen: (*) perhaps?
10:07:19 <zennist> HeladoDeBrownie: thanks, that does help a bit; I see how MonadPlus can be of convenience, but it just doesn't seem to be necessary to me. It only saves typing (Monad m, Monoid m a) into (MonadPlus m)
10:07:46 <ibid> zennist: as i said, historical reasons
10:07:58 <ibid> zennist: MonadPlus was there before Monoid
10:09:27 <HeladoDeBrownie> zennist, unfortunately you can't express quite what you just said in haskell, not that way anyway. although i'm having trouble figuring out how you might express it… the problem is that the head of MonadPlus mentions no a variable. it is independent of whatever m might be applied to.
10:09:37 <emaczen> oops wrong channel
10:10:14 <zennist> ibid: okay I see
10:11:08 <zennist> HeladoDeBrownie: I was refering to function signatures like f :: (Monad m, Monoid (m a)) => m a -> m a -> m a
10:11:15 <zennist> f = mplus
10:11:27 <HeladoDeBrownie> ah, okay
10:11:53 <HeladoDeBrownie> any problem there might be with that is less obvious to me, if it exists
10:11:56 <zennist> seems to me having a MonadPlus is only useful for saving some typing for the type constraint
10:12:03 <albeit> Is there a better way to do this? "maybe (return ()) someIOAction maybeVal"?
10:12:18 <HeladoDeBrownie> albeit, looks fine to me, although if you want to be more explicit you can use case
10:12:54 <dolio> (Monad m, Monoid (m a)) is not the same as MonadPlus m.
10:13:41 <dolio> That only tells you that (m a) is a monoid, not that for all b, (m b) is a monoid.
10:13:46 <HeladoDeBrownie> oh yeah, come to think of it, MonadPlus lets you pick *any* type whereas Monoid would limit you to a single type a
10:13:49 <HeladoDeBrownie> i think?
10:13:57 <HeladoDeBrownie> wait i'm confused XD
10:14:02 <supki> albeit: traverse_ someIOAction maybeVal, perhaps
10:14:15 <HeladoDeBrownie> okay, i guess what you just said is more or less the general idea i was after
10:14:51 <zennist> dolio: it seems to be rather than constraint at different levels though. for MonadPlus, the *any* type comes at the level of the class definition whereas for my solution it comes at the function level
10:15:06 <zennist> in the end you still got to choose whatever type for that function
10:15:06 <ibid> also, MonadPlus ensures that the mplus has been written to work with the Monad instance
10:15:21 <funfunctor> lol " -- If you send the program you are debugging to 15 friends before 143 minutes and then step three times on the same opcode you will get the name of the person who loves you."
10:15:36 <zennist> ibid: if there's no MonadPlus, the author will just implement Monoid, no big deal
10:15:40 * HeladoDeBrownie imagines "traverse, traverse" to be a lyric in the haskell slide
10:15:48 <dolio> No. There is no type you can give your function that will be adequate to cover what MonadPlus gives you.
10:15:53 * hackagebot horizon 0.1.1 - Sunrise and sunset UTC approximations from latitude and longitude coordinates  http://hackage.haskell.org/package/horizon-0.1.1 (intractable)
10:16:04 <dolio> Barring fancy GHC extensions.
10:16:28 <ibid> zennist: but f : (Monad m, Monoid (m a)) => ... makes no guarantee to f that the Monoid instance used by the caller is compatible with the Monad instance
10:16:37 <zennist> dolio: theoretically speaking, yes; but practically, maybe not that much of a difference? Even if there is a difference, I wouldn't believe it is for that difference that MonadPlus exists
10:17:41 <ibid> but as i said, when MonadPlus was conceived, nobody was thinking of so general standard libraries as one containing Monoid
10:17:49 <ibid> at one time, there was also MonadZero
10:17:53 <HeladoDeBrownie> much less Semigroup!
10:17:59 <zennist> ibid: ..what do you mean by compatible..?
10:18:16 <dolio> Yes, MonadPlus also predates Monoid.
10:18:37 * HeladoDeBrownie wonders if a Magma typeclass would be going entirely too far :P
10:19:00 <dolio> However, it is a huge difference in practice.
10:19:10 <zennist> that's definitely a valid reason! I wonder whether people are thinking of developing a new haskell just for throwing away historical stuff... map vs fmap coming into my mind
10:19:16 <ibid> zennist: there are equations that MonadPlus should fulfill that is not expected if you just combine any Monad and Monoid
10:19:49 <dolio> You can write algorithms that have MonadPlus m constraints to make nondeterministic choices in the monad.
10:20:03 <HeladoDeBrownie> zennist, haskell has a tendency to shed its skin relatively frequently, just not fast enough for many people :)
10:20:15 <dolio> To do the same with Monoid, you would have to annotate with Monoid (m T) for every choice of T used anywhere in the algorithm.
10:20:23 <dolio> And that isn't even possible in general.
10:20:49 <ibid> zennist: fmap was created because map was too general in practice
10:21:15 <ibid> zennist: look up the changes made from 1.4 to 98 sometime.  most of them are similar de-generalizationns
10:21:22 <zennist> dolio: I wish I can see an example to educate myself :( but I suppose I get your idea now
10:22:06 <zennist> ibid: how is 'too general' bad?
10:22:18 <HeladoDeBrownie> ambiguity errors
10:22:19 <ibid> zennist: uninformative error messages
10:22:32 <ibid> zennist: confuses the newbie
10:22:45 <ibid> zennist: makes the language not suitable for elementary teaching
10:22:46 <zennist> ibid: haha, that's a bummer
10:23:10 <HeladoDeBrownie> having (Functor f) => … pop up in type signatures where someone just wanted to work on list elements
10:23:19 <ibid> (i came on board the haskell boat at around the time they were formulating the 98 changes)
10:23:23 <HeladoDeBrownie> and think they have to understand Functor to figure out how to map lists
10:23:29 <HeladoDeBrownie> (this still goes on, albeit with Monad today)
10:23:33 <dolio> zennist: The key point is that it is a forall on the left of an arrow (the context arrow). And when that happens, it is not the caller of the function that gets to choose the instantiation of the variable, it is the function itself.
10:23:46 <HeladoDeBrownie> ("you mean i need to know category theory to do i/o?")
10:24:06 <dolio> (forall a. T a) -> U, not forall a. (T a -> U)
10:24:18 <ibid> (that's why i remember:)
10:24:21 <ab9rf> HeladoDeBrownie: drat, i should stop doing IO then :)
10:24:37 <ab9rf> cuz i don't understand category theory
10:24:44 <ab9rf> i'm not even sure i believe that category theory exists.
10:24:45 <dolio> (forall a. Monoid (m a)) => ..., not forall a. (Monoid (m a) => ...)
10:25:00 <dolio> Except you can't write the first one really, except by making a distinct class for it.
10:25:04 <ArisFr> Hi, I'm searching for a templating library for text (not just HTML) which *allows* haskell expressions/code evaluation in the template. For example, *not* hastashe. Anyone?
10:25:50 <zennist> HeladoDeBrownie: well, I imagine if something is general enough, it should be easy to explain with ample examples; I remember how I love my physics teachers go from general concepts to specific observation instead of the reverse way (which my chemistry teacher does) ;
10:25:55 <aidecoe> hm, I am a bit confused with `sequence`
10:26:11 <aidecoe> main = sequence [putStrLn "a", putStrLn "b"]
10:26:23 <aidecoe> why it doesn't compile?
10:26:29 <ab9rf> :t sequence
10:26:31 <lambdabot> Monad m => [m a] -> m [a]
10:26:43 <HeladoDeBrownie> aidecoe, did you give main a type signature by any chance?
10:26:53 <aidecoe> HeladoDeBrownie: i did
10:26:54 <aidecoe> hm
10:26:56 <HeladoDeBrownie> aidecoe, what is it?
10:27:02 <ab9rf> :t sequence [putStrLn "a", putStrLn "b"]
10:27:02 <lambdabot> IO [()]
10:27:09 <aidecoe> HeladoDeBrownie: thanks (-:
10:27:12 <aidecoe> that was it
10:27:17 <aidecoe> i had IO () in sig
10:27:19 <ab9rf> IO [()] isn't IO ()
10:27:20 <exio4> you probably want the _ variant
10:27:24 <HeladoDeBrownie> aidecoe, i wasn't done actually, but sure, removing the type signature could work
10:27:26 <exio4> @type sequence_
10:27:27 <lambdabot> Monad m => [m a] -> m ()
10:27:29 <ab9rf> just use sequence_
10:27:53 <aidecoe> that's better
10:27:53 <HeladoDeBrownie> aidecoe, i didn't meant to suggest that having a type signature was a problem, but having the wrong one certainly can be :)
10:29:09 <HeladoDeBrownie> zennist, while most of my experience is with one-on-one tutoring (or several-on-one, as the case may be :), i notice a lot of people like to have something concrete to hang onto *before* they learn the abstract.
10:29:23 <HeladoDeBrownie> (i don't tutor or teach in any official capacity though)
10:30:15 <zennist> dolio: Does Rank2Types solve the problem?
10:30:42 <dolio> No. You still can't put quantifiers in constraints.
10:33:05 <HeladoDeBrownie> it's too bad typeclasses aren't nearly as accessible as, say, datatypes…
10:33:06 <cfoch> So I understand that "diagrams-haddock" https://github.com/diagrams/diagrams-haddock modifies my source code? Did I understand correctly?
10:33:51 <dolio> If you turn on the right extensions, you can create a single class that captures the idea of having a class with quantifiers, I think. But you'll have to do extra work to make use of it.
10:34:58 <aupiff> hi all, wondering if people find Text.XML.Cursor sufficiently powerful for XML parsing / web scraping, or if HXT is preferred
10:35:00 <dolio> It wouldn't be nearly as convenient as using MonadPlus, I think.
10:35:05 <HeladoDeBrownie> in my fantasy haskell we would have implicit parameters that generalize constraints so that arbitrary datatypes can be used how typeclasses are now. that would probably break lots of things though.
10:35:41 <dolio> And doing constraints with foralls in them as natively supported would probably be something you could write a research paper about.
10:35:59 <dolio> If you could make it work sensibly at all.
10:39:42 <pedro22> can one tell me a survey paper about polimorphism
10:39:50 <pedro22> ?
10:40:02 <dolio> HeladoDeBrownie: Lots of languages do something like that. But you lose some key things about type classes when you do that.
10:40:12 <dolio> edwardk did a talk about it recently.
10:40:17 <HeladoDeBrownie> dolio, i'm aware of at least agda doing that. what is lost?
10:40:35 <pedro22> dolio: can one tell me a survey paper about polimorphism ?
10:40:49 <pedro22> just to understand what it is
10:41:07 <pedro22> lecture notes in polimorphism or smt like that
10:41:22 <dolio> I don't know a good intro paper on it.
10:41:29 <dolio> Off hand.
10:41:40 <pedro22> do u know any book where I can read about it?
10:41:46 <pedro22> book?
10:41:49 <HeladoDeBrownie> pedro22, what is your goal? to learn about polymorphism?
10:42:02 <pedro22> right
10:42:16 <HeladoDeBrownie> pedro22, well, if you don't find any resources on it, you could probably ask here
10:42:31 <HeladoDeBrownie> (or either way, really)
10:42:35 <pedro22> I prefer to read a paper or book
10:42:42 <HeladoDeBrownie> okay. just throwing it out there
10:42:43 <pedro22> to have some understanding what it is
10:42:58 <dolio> Maybe Types and Programming Languages would be good. I haven't actually read it.
10:43:06 <rola> pierce's "types and programming languages" is a reference, there's also bob harper's book which is online here
10:43:09 <rola> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
10:43:12 <HeladoDeBrownie> i have the book. want me to search it for references to polymorphism?
10:43:13 <pedro22> book from pearce
10:43:14 <pedro22> ?
10:43:14 <dolio> I could name books I have read, but they're not for beginners.
10:43:20 <HeladoDeBrownie> oh, okay. never mind then.
10:43:31 <josephle> rola, I wouldn't say Harper's book is easier on beginners than Pierce's
10:43:58 <pedro22> thank you guys!
10:43:59 <HeladoDeBrownie> t&pl isn't online though, is it?
10:44:16 <dolio> Certainly not legally.
10:44:34 <HeladoDeBrownie> that's what i meant.
10:45:41 <josephle> well, it's good to have both Pierce's and Harper's book if you can
10:45:51 <josephle> they have somewhat different focuses
10:49:03 <toblerone> whats a good way to only "parse" part of a json object using Aeson? I have come up with this, but it seems like there must be a better way... My case is that I'm getting large JSON objects and only care about a small portion of it. http://lpaste.net/121241
10:49:17 <dolio> HeladoDeBrownie: If you want to know about type classes vs. other similar things, you should watch Ed's talk. The short answer is that instances for type classes are guaranteed to be unique, which makes them nice in a lot of ways that other things aren't.
10:50:12 <rola> pedro22, the wiki article for polymorphism cites this http://www.itu.dk/courses/BPRD/E2009/fundamental-1967.pdf
10:50:45 <dolio> HeladoDeBrownie: The talk is here: https://www.youtube.com/watch?v=hIZxTQP1ifo
10:51:10 <HeladoDeBrownie> dolio, surely you could do something similar for implicit parameters?
10:51:37 <S11001001> @remember josephle I wouldn't say Harper's book is easier on beginners than Pierce's
10:51:37 <lambdabot> It is stored.
10:51:42 <HeladoDeBrownie> hmm, i'll add it to my watch later queue, thanks. i actually need to get some things done XD
10:51:45 <rola> also you might have some luck searching google scholar for something like "ad.hoc polymorphism" "parametric polymorphism" and checking out the citations of those
10:51:59 <socumbersome> Hi. A question about continuation monad - what is the meaning of bind in it, i.e. what (Cont c) >>= f really does? Does it somehow "attach" f to the chain of continuations? And if so, doest it attach it to the beginning or end of this chain?
10:52:21 <josephle> S11001001, is that a quote worth remembering? :)
10:52:39 <S11001001> josephle: such understatement
10:52:47 <josephle> haha
10:55:00 <rola> the explanation of dynamic dispatch in harper's book made sense to me after i didn't understand what wikipedia was saying
10:56:17 <geekosaur> imo that just proves harper's at least trying to teach; too often wikipedia articles are written for experts...
10:56:56 <josephle> iirc, harper abstracts dynamic dispatch into an abstract dispatch table
10:57:02 <josephle> erm
10:57:09 <josephle> that sounded tautalogical
11:00:56 * hackagebot rest-types 1.13.1 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.13.1 (AdamBergmark)
11:00:58 * hackagebot rest-core 0.35.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.35.1 (AdamBergmark)
11:01:00 * hackagebot rest-example 0.2.0.0 - Example project for rest  http://hackage.haskell.org/package/rest-example-0.2.0.0 (AdamBergmark)
11:05:07 <chrisdone> lel http://chrisdone.com/case-completion.png
11:05:56 * hackagebot diversity 0.3.5.1 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.3.5.1 (GregorySchwartz)
11:14:39 <karshan> Is Vector Word8 slower than ByteString ?
11:14:48 <karshan> if not, then why do we use ByteStrings ?
11:14:53 <hiptobecubic> karshan, depends on what you want to use it for
11:15:09 <karshan> hmm, can you give me like the two extreme cases
11:15:10 <socumbersome> Oh, nobody knows? :( Pls, let me ask again - a question about continuation monad - what is the meaning of bind in it, i.e. what (Cont c) >>= f really does? Does it somehow "attach" f to the chain of continuations? And if so, doest it attach it to the beginning or end of this chain?
11:15:44 <karshan> like when is Vector Word8 going to be way faster than a ByteString and vice-versa
11:15:56 <glguy> Vector Word8 is "unboxed" unless you're asking about the Unboxed module
11:16:08 <hiptobecubic> well Vectors are subject to fusion
11:16:29 <clrnd> so, how do I make lambdabot connect to an IRC server?
11:16:31 <glguy> I mean Vector Word8 is boxed*
11:16:52 <hiptobecubic> so loops can be flattened out which can help a lot with speed if your algorithm uses them
11:17:00 <karshan> Ah I see, and ByteStrings are unboxed which makes them faster
11:17:51 <ArisFr> Hi, I'm searching for a templating library for text (not just HTML) which *allows* haskell expressions/code evaluation in the template. For example, *not* hastashe. Anyone?
11:18:48 <karshan> ArisFr: http://hackage.haskell.org/package/interpolatedstring-qq
11:20:05 <Tene> clrnd: I start mine with: lambdabot -e 'rc .cabal/share/lambdabot-4.3/scripts/online.rc'
11:20:21 <clrnd> Tene, yeah just found about the scripts/ folder
11:20:22 <ArisFr> karshan:  Thanks, this seems exactly what I have been searching for.
11:20:28 <Tene> clrnd: You should be able to find an example rc file in there
11:20:37 <clrnd> Tene, trying to deduce the format right now
11:21:02 <clrnd> Tene, what about passwd.rc? how should it be formated?
11:21:10 <karshan> ArisFr: No problem, I found that recently when I wanted multiline strings :P. Here is another option that is more recent http://hackage.haskell.org/package/interpolatedstring-perl6-0.9.0/docs/Text-InterpolatedString-Perl6.html
11:21:11 <clrnd> or can I just plaintext it somewhere
11:21:27 <Tene> clrnd: I expect it to be the same format as any other rc file
11:22:11 <clrnd> Tene, but how should the key be named?
11:22:23 <clrnd> password <pass>
11:22:34 <Tene> clrnd: I don't know.
11:22:40 <tejasmanohar> whats most pro baseball statistical analysis in?
11:22:48 <ArisFr> karshan: Ah, yes, interpolatedstring-perl6 is similar and a bit more up-to-date.
11:25:27 <ArisFr> karshan: For future reference, I have also found hako, which is a bit more restricted though
11:26:10 <toblerone> whats a good way to only "parse" part of a json object using Aeson? I have come up with this, but it seems like there must be a better way... My case is that I'm getting large JSON objects and only care about a small portion of it. http://lpaste.net/121241
11:33:24 <toblerone> oh, i figured it out
11:35:57 * hackagebot pocket-dns 0.1.0 - Multi-backend (zookeeper and sqlite) DNS Server using persistent-library  http://hackage.haskell.org/package/pocket-dns-0.1.0 (junjihashimoto)
11:36:15 <rui> Is there any version of (.) that composes a fucntion of 2 args with one of 1?
11:36:57 <mauke> .:
11:37:00 <mauke> but it doesn't exist
11:37:06 <hiptobecubic> @pl f g a x = f (g a x)
11:37:07 <lambdabot> f = fix ((.) . (.))
11:37:35 <geekosaur> ...fix? can @pl become any more ridiculous?
11:37:45 <hiptobecubic> :D
11:37:52 <toblerone> ok, how would I parse an object with unknown keys? I know the schema of each object associated with the key, but I don't know the key itself. Anyway to turn an object to an array?
11:38:21 <rui> @pl f x y = sum $zipWith (*) x y
11:38:21 <lambdabot> f = (sum .) . zipWith (*)
11:38:45 <mauke> @pl \f g a x -> f (g a x)
11:38:45 <lambdabot> (.) . (.)
11:38:47 <mmachenry> toblerone: What are you parsing?
11:39:10 <toblerone> json, using aeson
11:39:23 <mmachenry> toblerone: Ah you could turn it into a Data.Map
11:39:36 <mmachenry> Data.Map has a fromJSON instance in Data.Aeson.
11:39:40 <toblerone> ah
11:39:40 <toblerone> ok
11:39:46 <toblerone> makes sens
11:39:46 <toblerone> e
11:39:48 <mmachenry> toblerone: One sec
11:39:48 <toblerone> thanks
11:39:52 <mmachenry> I have an example
11:40:13 <toblerone> ok
11:40:57 * hackagebot slack-notify-haskell 0.1 - Slack notifier for Haskell project.  http://hackage.haskell.org/package/slack-notify-haskell-0.1 (tattsun)
11:43:32 <trd> hey
11:43:38 <trd> anyone know how to created a class
11:43:41 <trd> ?
11:43:45 <mmachenry> toblerone: http://lpaste.net/121243
11:44:19 <mauke> trd: class Foo a
11:46:32 <trd> foo being the name and a being ?
11:47:25 <HeladoDeBrownie> trd, a parameter to the class, a type variable.
11:47:26 <kadoban> trd: How familiar are you with haskell typeclasses, and haskell in general? Not sure the level of response to give.
11:47:35 <ReinH> trd: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
11:48:00 <HeladoDeBrownie> trd, just to clarify, when you say "class", you are talking about typeclass?
11:48:07 <mmachenry> kadoban: I think ReinH nailed it. :)
11:48:15 <toblerone> mmachenry: good stuff, thanks
11:48:23 <mmachenry> toblerone: You're welcome.
11:48:46 <trd> im a beginner kadoban
11:49:05 <trd> i'm not sure i was doing a practice problem
11:49:11 <trd> i'll show  the question
11:49:17 <HeladoDeBrownie> trd, ah yeah, good idea
11:49:21 <trd> Define a class Extract that has 3 functions: asBool, asInteger, and asDouble. Define instances for Bool, Integer, Double, and Sink. Each function should return its appropriate type, where zeros and empty lists are False with everything else True; True should return 1 and False 0. In other words, make all the types return as reasonable values as possible, but anything else should call error.
11:49:29 <trd> sink is a constructor
11:49:50 <ReinH> trd: read the link I gave you, it'll go over typeclasses in detail
11:50:03 <trd> alright i'll check it out thanks!
11:50:58 * hackagebot slack-notify-haskell 0.2 - Slack notifier for Haskell project.  http://hackage.haskell.org/package/slack-notify-haskell-0.2 (tattsun)
11:51:00 * hackagebot slack-notify-haskell 0.2.1 - Slack notifier for Haskell project.  http://hackage.haskell.org/package/slack-notify-haskell-0.2.1 (tattsun)
12:01:55 <toblerone> whats the best regexp library?
12:02:18 <dmwit> What does "best" mean?
12:02:33 <mauke> the one hardwired into perl
12:02:42 <mada> The most better one.
12:03:30 <toblerone> well, I feel like ive seen some criticism of Text.Regex.Posix in the past. I thought I had seen some new developments in the area, and I was hoping to find one that was fast, easy to use, and ideally had perl style regexp
12:03:35 <dmwit> regex-applicative is idiomatic; the pcre bindings has lots of non-regular features; there are other optimization criteria that would lead to choosing other libraries
12:04:20 <dmwit> regex-tdfa is fast and pure Haskell (so doesn't require outside libraries)
12:05:03 <dmwit> Also a possible question: why regex?
12:05:18 <divVerent> mauke: well... let's put it this way... perl's regexes aren't very regular any more, given they now can match anything context-free plus some more
12:05:24 <aomm> Hi! I have a question regarding GHCi not finding modules. I'm working on a project in a sandbox, which imports things from a local cabal package. It works fine to do 'cabal run' as I have told the sandbox where the library is
12:05:34 <aomm> But when I try to load my project's source files into GHCi, I always get "Could not find module ...". How do I load the local package which I depend on into GHCi?
12:05:37 <divVerent> thus anything with "dfa" in its name won't even get close to perl's
12:05:45 <dmwit> aomm: cabal exec ghci, or cabal repl
12:06:11 <mauke> divVerent: in practice, no regex library is regular
12:06:14 <mauke> because backreferences
12:06:41 <dmwit> Some regex libraries do not support backreferences.
12:07:08 <toblerone> dmwit: uh, I think it would be more appropriate than something like attoparsec. I have a bunch of short titles that I'm trying to match on some simple criteria such as a single word or two. maybe attoparsec doesn't sound too bad there...
12:08:02 <kadoban> aomm: The reason that doesn't work is, ghc doesn't know/care about cabal sandboxes. So you have to either tell it where to look, in the sandbox (with some slightly obscure flags), or have cabal run it for you.
12:08:23 <divVerent> mauke: right
12:08:42 <mseeks> has anyone used TCache and DBRefs?
12:08:46 <divVerent> the wellknown /^(...*)\1\1*$/ regex :)
12:09:00 <tdammers> toblerone: http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text.html#g:20 <- helpful, maybe?
12:09:01 <divVerent> that can be used for a primality test (it can only match composite numbers of characters)
12:09:27 <mauke> divVerent: I have a regex for matching prefixes of the fibonacci sequence (in unary)
12:10:23 <hannes__> We should just rename all regular expressions that aren't regular expressions to irregular expressions
12:10:44 <mauke> no, to "regex" (or "regexp")
12:10:45 <HeladoDeBrownie> regular expressions are only irregularly regular.
12:10:47 <mauke> done!
12:10:51 <toblerone> tdammers: yeah, i might be able to go as simple as that...
12:10:59 * hackagebot slack-notify-haskell 0.2.2 - Slack notifier for Haskell project.  http://hackage.haskell.org/package/slack-notify-haskell-0.2.2 (tattsun)
12:12:21 <tdammers> let's rename them to (ir)?reg(ular)?ex(p(r(ession)?)?)?
12:12:45 <aomm> note on the difference between "cabal repl" and "cabal exec ghci": "cabal repl" only allowed me to see exported things. After doing "cabal exec ghci" I had to load my module using :load, but doing so worked flawlessly. thanks a lot!
12:12:46 <ReinH> tdammers: make sure you you (:?) to avoid creating capture groups ofc
12:12:51 <ReinH> *you use
12:13:02 <tdammers> ReinH: valid criticism.
12:13:05 <hannes__> tdammers: That'd work, except it's lacking a couple of question marks
12:13:14 <ReinH> tdammers: ;)
12:13:52 <HeladoDeBrownie> irregularexp is a possiblity. seems odd. better add more parens and bars.
12:15:05 <ReinH> irregexp
12:17:15 <clrnd> Tene, fwiw the command was `irc-password <pass>` it works now, with stunnel :D
12:17:27 <clrnd> thanks to int-e too for eysterday's tips
12:19:55 <hexagoxel> aomm: `cabal repl` has several advantages: ghci will know about any source folders, extensions and ghc options defined in the package
12:21:00 * hackagebot string-conv 0.1 - Standardized conversion between string types  http://hackage.haskell.org/package/string-conv-0.1 (DougBeardsley)
12:21:33 <tdammers> oooh, another string conversion library
12:23:20 <hannes__> talking about strings - should strings with different encodings have different types?
12:23:47 <tdammers> hannes__: strings shouldn't be encoded at all
12:23:49 <hannes__> or should encoding/decoding only happen when reading/writing and not be reflected by the runtime representation at all
12:23:57 <tdammers> that, yes
12:24:05 <tdammers> a string is a sequence of characters
12:24:13 <tdammers> encoding converts it into a sequence of bytes
12:24:55 <tdammers> obviously there is an in-memory representation that amounts to an "encoding" at some point, but IMO it should remain strictly internal to the string type's plumbing
12:26:20 <hannes__> only issue with that that I can tell is that encoding may be lossy, unless you say you only allow unicode encodings
12:29:01 <Big_G> How would Haskell deal with updating a cache
12:29:35 <hannes__> Big_G: what kind of cache
12:30:48 <tdammers> hannes__: encoding can always be lossy, there's not really a way around that
12:31:00 * hackagebot slack-notify-haskell 0.2.3 - Slack notifier for Haskell project.  http://hackage.haskell.org/package/slack-notify-haskell-0.2.3 (tattsun)
12:31:08 <Big_G> hannes__, I don't think it matters but say it is a mapping of URLs
12:31:42 <tdammers> Big_G: it would work like in any other language, I guess
12:31:58 <hannes__> Big_G: Well, it sort of matters because 'cache' can mean lots of different things depending on context
12:32:09 <Big_G> I got an interview question specifically about how to update one in a functional language
12:32:19 <tdammers> well
12:32:52 <tdammers> one option is to throw the relevant parts of your application into some sort of state monad
12:32:55 <hannes__> did the interview question say what kind of cache they were talking about?
12:33:08 <tdammers> I'm assuming in-process memory here
12:33:15 <Big_G> Nope. Just that there was a cache and it needed to be updated
12:33:19 <tdammers> because disk cache would be pretty trivial
12:33:55 <tdammers> but for a cache, I would rather go with an explicitly mutable data structure like MVar or TVar or something like that
12:33:56 <hannes__> presumably, a cache then would be a Map k v of some description, which is also kind of trivial
12:34:03 <__maki__> Hi, I have a function from [0..k] to [0..k], with the k given at runtime, and I need to store it as an Array. Those functions form a monoid for each k, but how can I say that?
12:34:14 <tdammers> hannes__: yes, except that you need to manage updates
12:34:15 <ski> dolio : oh, you're right :) good point
12:34:43 <dolio> Right about what?
12:34:43 <koala_man> if you have a pure, slow function with large output, is there a reason not to use unsafePerformIO for transparent, pruning caching/memoization?
12:34:45 <Big_G> I said have a base cache and have an update function that updates the old cache to the current state
12:34:51 <tdammers> there are also mutable versions of many data structures that you can basically throw into ST or IO out-of-the-box
12:34:57 <dolio> I mean, of course I am.
12:35:33 <bitemyapp> koala_man: is it top-level?
12:35:40 <ski> <dolio> ski: Eta reducing a composition doesn't require eta, I think. It follows from beta and the definition of composition.
12:35:42 <bitemyapp> koala_man: explicit memoization is wiser.
12:35:43 <exio4> koala_man: you could have a top level function and exploit lazyness
12:35:48 <dolio> Oh yeah.
12:35:52 <exio4> s/function/definition
12:35:54 <lpaste> “__maki__” pasted “Example for k = 5” at http://lpaste.net/121246
12:36:52 <koala_man> bitemyapp: like passing in the cache or using State? why?
12:38:16 <hannes__> koala_man: unsafePerformIO is just asking for trouble; too many what-ifs. Like 'what if someone calls this function from 2 threads at the same time?'
12:38:37 <bitemyapp> hannes__: I think that's known.
12:38:52 <bitemyapp> hannes__: the semantics of unsafe, unsafeDupable can be looked up.
12:41:40 <koala_man> what makes this use case worse than using unsafePerformIO to expose a pure FFI function as a pure Haskell function?
12:42:09 <hannes__> bitemyapp: The semantics being well defined doesn't mean they can't be confusing
12:43:24 <bsummer4> Hi! I'm trying to preprocess haskell code so that I can process it with haskell-src-exts. Some libraries #import "MachDeps.h", but I can't seem to find any documentation about this header file. Do all haskell sources have access to everything in here https://github.com/ghc/ghc/tree/master/includes?
12:43:38 <Peaker> koala_man: there's the memo-ugly package that does that
12:43:55 <Peaker> I want something like memo-ugly but with IO knobs to clear the caches, resize them, etc
12:44:14 <Peaker> laziness for memoization is a neat trick, but it's too rigid/inflexible (no lru, no control at all)
12:44:15 <mseeks> anyone used TCache and DBRefs?
12:44:24 <bsummer4> A simple example is, System/Random.hs from the random package.
12:44:45 <hannes__> koala_man: In one case it's absolutely necessary to use unsafePerformIO to get a pure interface. In the other, you're actually introducing side effects even if the function remains conceptually pure
12:45:37 <koala_man> hannes__: observable side effects that pure code wouldn't have?
12:46:50 <hannes__> koala_man: I'm not saying you can't do it; I'm saying I don't think it's a good idea.
12:47:59 <koala_man> you have a feeling it's not, or you have some examples of cases where it's not?
12:49:20 <koala_man> the only downside I can think of is that the cache won't be tuneable or flushable
12:49:29 <Peaker> if you write an unsafePerformIO thing for memoization as a common infrastructure (like ugly-memo) it's fine
12:49:47 <SrPx> Is there any generic library which allows for the serialization/deserialization of datatypes into nats, such that it forms a bijective map and that every nat has a corresponding term (no bit is lost)?
12:49:51 <Peaker> koala_man: with unsafePerformIO? You can create the cache in IO, and then get IO knobs to control it
12:50:08 <Peaker> SrPx: sounds interesting! What's it for?
12:51:25 <bitemyapp> koala_man: honestly, you could give it a shot (don't forget NOINLINE), but having a more programmable cache seems better.
12:51:51 <koala_man> Peaker: while the function itself is transparent? that would mean the cache could be flushed, you just don't have any control over which requests happen before or after?
12:51:56 <SrPx> Peaker: fun I guess, I'm wondering how far my computer can search on the space of lambda terms, but for that I need a way to generate random terms
12:52:07 <SrPx> Peaker: a mapping between numbers and terms would be handy
12:52:16 <ReinH> SrPx: Sounds like you want a godel numbering?
12:52:21 <Peaker> SrPx: to search random terms, no need to go thru Nat?
12:52:57 <koala_man> it's not something I'm planning on doing, I'm just curious about the consequences
12:53:14 <SrPx> ReinH: yes, but how do I get the goedel numbering of an arbitrary grammar? I know an algorithm to enumerate it (I asked some time ago), but it is slow, I need a bijective map between nats and terms
12:53:15 <Peaker> koala_man: you can flush it and whatever happens to be evaluated after, sees it flushed. Since the only effect is performance, it is RT
12:53:36 <koala_man> right
12:53:45 <SrPx> Peaker: also to list them in order... how else?
12:54:43 <mseeks> SrPx: maybe this helps -- http://stackoverflow.com/questions/23923229/is-there-a-fast-algorithm-to-determine-the-godel-number-of-a-term-of-a-context-f
12:55:16 <Peaker> SrPx: you could have a function: allTerms :: [Term] -- infinite list, without any Nats
12:55:42 <Peaker> SrPx: you can BFS through all possible ctors of the term?
12:57:53 <ReinH> Peaker: how do you BFS through an infinite list?
12:58:36 <Peaker> well, allTerms :: [Term] implies growing amounts of memory for scanning more of the terms :)
12:59:38 <Peaker> allTerms :: Term -> [Term]     you need either more and more terms stored, or you can serialize a "path" in this sequence and iterate that (indeed similar to Nat bijection)
12:59:53 <Peaker> the latter is better named "nextTerms" maybe
13:00:16 <SrPx> mseeks: that was the question I was reffering (I asked it) but it doesn't work for arbitrary terms :(
13:01:02 * hackagebot text-and-plots 0.2.0.0 - EDSL to create HTML documents with plots based on the C3.js library.  http://hackage.haskell.org/package/text-and-plots-0.2.0.0 (andersjel)
13:16:09 <dmwit> ?tell aomm cabal repl can see all the same things cabal exec ghci can, provided you "import" them in the same way; e.g. if you :l Foo in exec ghci, this loads and then does an implicit :m *Foo. So you can manually :m *Foo in repl as well to see the same things in scope.
13:16:10 <lambdabot> Consider it noted.
13:23:30 <toblerone> using attoparsec, how would I get the remaining data so I can work on it with a pure function? I've parsed part of the input, and want to test whether a word occurs. So, I'd like to get the data, split on whitespace and use elem to test inclusion.
13:23:38 <toblerone> whats the best way to get the data?
13:24:20 <toblerone> for instance, I could simply do "many anyChar"
13:24:37 <toblerone> but that seems like its not the best choice
13:26:55 <jophish>  if I were creating a data type for some symmetrical set of objects (for example, limbs) is it idiomatic to do: data Limb' = Arm | Leg; Data Limb = Either Limb' Limb'; or data Limb = LeftArm | RightArm | LeftLeg | RightLeg
13:27:16 <jophish> (ignoring the shoddy naming of Limb and Limb')
13:27:52 <HeladoDeBrownie> toblerone, takeByteString or takeLazyByteString
13:28:04 <HeladoDeBrownie> toblerone, then you can fmap over that or something
13:28:37 <HeladoDeBrownie> although you could just as easily return it as a result of parsing and then operate on it
13:28:43 <HeladoDeBrownie> depends on what the big picture is
13:29:02 <toblerone> ah okay that words
13:29:03 <toblerone> works
13:29:04 <toblerone> thanks
13:30:41 <juanpaucar> @faq Is Predicate a functor
13:30:41 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
13:32:39 <juanpaucar> @faq Is Predicate a functor?
13:32:39 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
13:43:14 <Arcaedox> hi , who do I email if I want to propose some functions to add to prelude?
13:43:41 <dmj```> Arcaedox: probably https://wiki.haskell.org/Core_Libraries_Committee
13:43:53 <dmj`> Arcaedox: which functions? They might have already been proposed
13:44:08 <glguy> Arcaedox: You'd email the libraries@haskell.org mailing list. Be advised that it's a steep climb to get things added to Prelude.
13:45:25 <jophish> What's the process for uploading a library to Hackage?
13:45:36 <jophish> I've got one which I think would be useful, and there's nothing like it
13:46:21 <dmj```> jophish: cabal sdist && cabal upload dist/yourlibrary.tgz
13:46:42 <jophish> that's it?!
13:46:46 <phaul> I was reading a unix related portal that I usually read, and I came across a topic about deb.haskell.org. I saw high heated conversation about security and all that. I said, there is so little traction in the haskell community because noone actually cares.. (well I don't care) Is that a fair assesment? I imagine most ppl install stuff from hackage via cabal (probably into a sandbox)
13:47:04 <dmj`> jophish: you need to have a hackage account first though, so you gotta ping that one dude
13:47:32 <jophish> dmj`: I'll do that right away
13:49:01 <jophish> thanks
13:49:36 <phaul> the unfortunate thing is that non-haskellers would associate such an occurance with haskell - the language. which is stupid, but there you go
13:50:47 <mauke> phaul: http://www.reddit.com/r/haskell/comments/2w2ey8/build_box_compromised/conetbt
13:51:01 <edsko> @free foldr
13:51:02 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
13:51:26 <ReinH> phaul: why don't you think anyone cares?
13:51:28 <phaul> mauke: thanks,  I'll link that on this posrtal
13:51:32 <dusan_> hello :) is there a reason why Data.Binary.encode returns the internal lazy ByteString instead of just ByteString?
13:52:28 <merijn> dusan_: What makes you say lazy ByteStrings are "internal"?
13:52:38 <merijn> dusan_: binary was designed for lazy BS...
13:53:52 <dusan_> merijn: Data.Binary.encode :: Binary a => a -> Data.ByteString.Lazy.Internal.ByteString
13:54:23 <geekosaur> that's a ghc-ism
13:54:30 <dusan_> merijn: i get this after typing ":t Data.Binary.encode" in ghci
13:54:34 <geekosaur> yes
13:54:37 <dusan_> oh :)
13:54:37 <geekosaur> it's ghc being weird
13:54:38 <glguy> The type is defined in the internal module, but exported by the non-internal one
13:54:49 <glguy> it's the same type
13:55:18 <HeladoDeBrownie> juanpaucar, are you still wondering whether Predicate is a Functor? assuming newtype Predicate a = Predicate (a -> Bool), it is not; this is because it's contravariant. this means it is a Contravariant.
13:55:49 <merijn> dusan_: It's displaying that because you have both lazy and strict ByteString in scope, I'm guessing
13:56:08 <dmwit> merijn: or just don't have lazy ByteString in scope
13:56:26 <geekosaur> more to the point, doesn't have Data.ByteString,Lazy in scope so ghc finds the original declaration and outputs its full name
13:56:31 <merijn> ah, right
13:56:38 <hibou_> http://paste.ofcode.org/v5hZwzKWvPhpQR8LzdzTFU
13:56:58 <hibou_> I've got the error euler.hs:13:38: parse error on input `='
13:57:10 <EvilMachine> How would I implement, for software with a set of modules, the ability for each module to keep a state of an arbitrary type? The modules will be unknown beforehand, so I can’t make a data type with a constructor for every module.
13:57:14 <dusan_> yes! :) thats it. if I import Data.ByteString.Lazy, the type of the function becomes just "pure" ByteString
13:57:16 <mauke> hibou_: bad indentation
13:57:24 <mauke> hibou_: stop using tabs
13:57:38 <glguy> hibou_: In Haskell tabstops are 8 characters, so you'll need to fix your editor
13:57:43 <dusan_> merijn: geekosaur: glguy: thanks
13:57:47 <jophish> hmm, I requested an account on hackage but haven't been sent an email
13:57:50 <geekosaur> hibou_, likes 13-15 are too far indented
13:57:56 <geekosaur> *lines 13--15
13:58:00 <EvilMachine> Will I be forced to resort to some weird unnamed pointer and unsafe casting?
13:58:07 <hibou_> yeah
13:58:16 <hibou_> but don't know how to change in sublime
13:58:29 <rola> is this related to djinn being able to give a function for a -> (), but not () -> a? › categories are not necessarily isomorphic to their dual. http://www.reddit.com/r/haskell/comments/2wza7w/category_theory_for_beginners/cowmjdw?context=3
13:58:29 <rola> @djinn a -> ()
13:58:29 <rola> @djinn () -> a
13:58:29 <lambdabot> f _ = ()
13:58:29 <lambdabot> -- f cannot be realized.
13:58:31 <JoshieAS> so if I'm using Vim, how should I set my tabs for Haskell?
13:58:31 <geekosaur> they should start under `abundant` on line 12, not under `filter`
13:58:52 <glguy> JoshieAS: the best would be:   :set expandtab
13:59:08 <HeladoDeBrownie> EvilMachine, your use of terminology confuses me, but this sounds like something you could implement in haskell even if not dealing with haskell modules (is that what you meant by module?) in the same program
13:59:10 <mauke> JoshieAS: :set sw=4 sts=4 et
13:59:18 <EvilMachine> JoshieAS: Many editors have an option to always insert spaces instead of tabs. But beware of opening files that already have tabs in them.
13:59:23 <glguy> to get tabs to look correctly you need   :set tabstop=8     iirc
13:59:55 <JoshieAS> danke
14:00:07 <EvilMachine> HeladoDeBrownie: Ah, sorry for the confusing terminology. Yes and no. With modules I meant something like plug-ins. (As with browsers, or other software.)
14:00:25 <HeladoDeBrownie> EvilMachine, well then yes, that should easily be doable without shenanigans for a certain definition of module.
14:00:26 <EvilMachine> HeladoDeBrownie: They could be Haskell modules too, of course.
14:01:04 <hibou_> ok
14:01:08 <hibou_> i fixed my program
14:01:17 <HeladoDeBrownie> EvilMachine, as one example, you can make it so the plugins are written in a specific dsl, then include in your program an interpreter for that dsl
14:01:17 <hibou_> mauke, thanks
14:01:39 <HeladoDeBrownie> (and a parser)
14:01:45 <EvilMachine> HeladoDeBrownie: Yes, I thought so. But what kind of type would my central state-holding data structure have, to accomodate types that might not even exist yet at compile time?
14:02:25 <HeladoDeBrownie> EvilMachine, the types won't necessarily be haskell-level types, at least not in the program handling the plugins. (you might work out something with gadts but…) instead you can have a datatype whose values represent the plugin's types.
14:02:28 * EvilMachine shudders at the thought of DSLs.
14:02:35 <kallisti> EvilMachine: are you just wanting to dynamically load Haskell modules and keep state? The module loading part can be done with the plugins package
14:02:35 <HeladoDeBrownie> EvilMachine, why do you shudder?
14:03:10 <EvilMachine> HeladoDeBrownie: HMSO DSLs are a type of http://en.wikipedia.org/wiki/Inner-platform_effect
14:03:15 <EvilMachine> HeladoDeBrownie: IMHO DSLs are a type of http://en.wikipedia.org/wiki/Inner-platform_effect
14:03:40 <EvilMachine> kallisti: Hey, that sounds good!
14:03:52 <ReinH> EvilMachine: The irony of course is that plugin-based systems are often good examples of the inner-platform effect.
14:03:53 <HeladoDeBrownie> EvilMachine, seems kind of like a slippery slope argument.
14:04:12 <ReinH> EvilMachine: So tell us more about your plugin-based system please :)
14:04:50 <EvilMachine> HeladoDeBrownie: The available plugins will be completely unknown beforehand. They might even be written in a completely different language.
14:05:01 <ReinH> Or is your argument that the fact that your system is plugin-based does not imply that it will necessary exhibit the inner-platform effect?
14:05:47 <HeladoDeBrownie> EvilMachine, do you already have an idea of how this will work? this sounds like something for which you'd either need a compiler or otherwise some sort of common interface
14:06:11 <EvilMachine> ReinH: Hmm… I kinda want it to be a surprise when I release it. It’s really nice. All I can say is that it will save me a huge chunk of programming work from then on for all times forever. :D
14:06:38 <ReinH> EvilMachine: I'm just pointing out how your own argument against DSLs also applies to your own system.
14:07:25 <ReinH> But luckily, I don't think it's a convincing argument.
14:07:41 <EvilMachine> HeladoDeBrownie: I have to admit, I’m still too much in the imperative OO language mindset where things „just work“ (as in: until they explode in your face) because of duck-typingj
14:07:49 <ab9rf> quack
14:08:31 <bitemyapp> ttuegel: is there a good channel to talk to you about Cabal?
14:08:46 <EvilMachine> ReinH: I don’t think it does. Because my plugins have no limitations whatsoever. Think of them like drivers. Yeah, drivers fits it best. Like database type drivers in a database.
14:08:48 <nkar> apparently, it's a better place to ask than #haskell-blah: any idea for a weekend haskell project that'd be useful for the community?  maybe you know of a cool paper that's waiting to be turned into a library.
14:08:58 <ab9rf> "no limitations whatsoever"?
14:09:07 <ReinH> EvilMachine: Anyway I don't buy your inner-platform effect argument.
14:09:15 <ab9rf> there's no such thing as software with "no limitations"
14:10:10 <kallisti> EvilMachine: dynamic linking usually doesn't have any kind of static typing checks since the type information isn't there anymore.
14:10:18 <EvilMachine> ReinH: :D that’s OK. One of us (or both) probably lack some information, and in the end, we’d probably end up agreeing anyway (no matter who had been right), but it’s not worth the discussion. :D
14:10:30 <EvilMachine> ab9rf: You know what I meant. :)
14:10:38 <ReinH> EvilMachine: I agree on that much :)
14:10:46 <ab9rf> EvilMachine: no, i really don't
14:10:59 <geekosaur> nkar, I think that might be better asked on the haskell-cafe mailing list. as big as this channel is. many Haskellers are not in it, plus you probably want input from more than just whoever happens to be around right now
14:11:01 <HeladoDeBrownie> EvilMachine, i suspect the questions i've raised are things you'd have to think about regardless of language
14:11:10 <geekosaur> and watching the channel at the moment you asked
14:11:10 <EvilMachine> kallisti: ouch. yeah, makes sense. but strange that i never thought about this. thank you. that was very useful.
14:11:42 <EvilMachine> ab9rf: Then I’m really sorry, but I don’t know how to explain it to you.
14:12:02 <kallisti> EvilMachine: if you look at the plugin library on hackage, you'll see that it returns an arbitrary polymorphic type when loading a function from a .o file
14:12:03 <EvilMachine> HeladoDeBrownie: Indeed. No doubt about it.
14:12:43 <EvilMachine> HeladoDeBrownie: Haskell just forces me to confrot them and do it properly. (That’s what I want. Enough of the sloppiness of duck-typing!)
14:14:18 <EvilMachine> kallisti: lool. ouch. I guess that’s the only way, but still… damn, I can’t accept it. I’m thinking there has to be some checking during plugin compilation.
14:14:41 <HeladoDeBrownie> EvilMachine, i think i understand now the context of your questions regarding types as yet unknown at compile time. my suggestion that the types of the plugin-values or whatever are likely to be represented as values in the plugin handler stands.
14:14:54 <ab9rf> checking against what?
14:15:23 <HeladoDeBrownie> EvilMachine, that said this is a different sort of thing from what kallisti is describing; it sounded like you weren't specifically looking to add haskell modules to the currently executing program as such
14:16:05 <cmccann> nkar: posts like that show up on the haskell reddit now and then as well. usually for a larger scale than a weekend project, though
14:16:07 <EvilMachine> In other words: I wish there was a way for my code to take an arbitrary data structure from some other module/plugin, later return it, and have the compiler/types guarantee, that i can only return the same type i got from that plugin.
14:16:32 <HeladoDeBrownie> EvilMachine, on the little information you've given, this is how i would approach the problem as i understand it: (1) design a plugin dsl (2) write an interpreter for that dsl (3) write compilers from the other languages to the dsl
14:16:44 <HeladoDeBrownie> this may not be the best and certainly isn't the only approach, but it's what occurs to me.
14:16:48 <cmccann> nkar: if you're relatively comfortable with C then FFI bindings to any popular C library that doesn't already have bindings is pretty much a guaranteed good idea though
14:16:50 <nkar> cmccann: oh, good idea, I'll look through
14:17:24 <cmccann> and for some libraries, that could be a weekend project to reach a point of usability where other people can jump in easily
14:17:28 <nkar> that was re: reddit, not sure about a c library since I don't have anything in mind
14:18:02 <EvilMachine> HeladoDeBrownie: I deliberately gave litte information, because I wanted a generic solution, not one that only works for a very special case. But I did not intend to be vague. Sorry for that.
14:18:03 <nkar> it'd be a good "refresher" project
14:19:09 <HeladoDeBrownie> EvilMachine, it sounds like what i suggested doesn't meet your expectations? if so, can you clarify?
14:19:16 <EvilMachine> HeladoDeBrownie: Remember: Plugins could be written in any imaginable language that can talk the way that the FFI understands. Hell, it could be Python, or even Bash, if the coder is brave enough. :)
14:19:26 <cmccann> brainfuck plugins
14:19:39 <HeladoDeBrownie> EvilMachine, sure. and in that case you'd have a compiler for each of those languages to your plugin language.
14:19:44 <HeladoDeBrownie> (going off my suggestion)
14:19:54 <HeladoDeBrownie> an alternative would be leveraging their respective ffis.
14:19:57 <HeladoDeBrownie> though not all of them have one.
14:20:32 <EvilMachine> HeladoDeBrownie: Sorry, you don’t /have/ to meet any of my expectations. :) I am thankful for your input though. I just have a hard time understanding you too. :/
14:20:41 <bitemyapp> dmj`: no Haskell
14:20:42 <bitemyapp> dmj`: fyi
14:21:01 <HeladoDeBrownie> EvilMachine, feel free to ask me to clarify as well
14:21:22 <EvilMachine> HeladoDeBrownie: Can’t my plugin language just be machine code? ;)
14:21:54 <cmccann> the ultimate plugin architecture, compiling to machine code and running a binary
14:21:58 <HeladoDeBrownie> EvilMachine, sure, it could be. but then you can make fewer guarantees about what plugins do.
14:22:29 <EvilMachine> HeladoDeBrownie: Extremely good point.
14:22:50 <tdammers> been pondering this idea myself
14:22:54 <EvilMachine> cmccann: XD
14:23:06 <tdammers> hard core application with strict rules and logic
14:23:39 <tdammers> extension modules written in a "soft" and common language, but running in a sandboxed interpreter that exposes only those things that the extension module is supposed to touch
14:23:53 <ab9rf> the fewer restrictions you place on a plugin, the less you can assume about what the plugin does
14:24:01 <tdammers> yes
14:24:07 <EvilMachine> Conclusion: So… actually I just want my core code to never ever return data of another type to a plugin, than it has been given by the plugin, regardless of which type that was.
14:24:19 <ab9rf> "Does something when called" is not terribly useful
14:24:37 <tdammers> ab9rf: depends what "something" may and may not entail
14:24:50 <exio4> ab9rf: and parametricity becomes more useful
14:24:54 <HeladoDeBrownie> EvilMachine, i'm not sure i agree with (or understand) your conclusion
14:25:23 <ab9rf> EvilMachine: how is the core code to know what type of data it has received from a plugin, so that it can return only data of that same type?
14:25:24 <ttuegel> bitemyapp: we can probably use #ghc; cabal is "core infrastructure" enough.
14:25:51 <EvilMachine> ab9rf: Think of it as it being drivers instead of plugins. All they have to do, is to implement the plugin interface and make sure all handles are closed when necessary.
14:26:10 <HeladoDeBrownie> EvilMachine, those sound like guarantees you'd like your plugins to make :)
14:26:16 <ab9rf> EvilMachine: drivers have well-defined entry points with specific calling sequences
14:26:40 <EvilMachine> HeladoDeBrownie: “conclusion” was probably the wrong word. It was just me realizing what I really need, and specifying it more exactly. :)
14:27:35 <HeladoDeBrownie> EvilMachine, okay, then there remains the question of what you mean by "type". it sounds like your plugin system would have its own types, so what would those  be? (how are they defined?)
14:27:58 <HeladoDeBrownie> (or, ignore the parenthetical question, since you don't seem to have that information yet)
14:28:21 <EvilMachine> HeladoDeBrownie: Also a good point. The plugins would have the source of the core available at compile time though, so plugins making guarantees, especially when written in haskell, shoudld not be a problem. Plugins in other languages… I assume all duck-type languages crash and burn anyway. :)
14:29:25 <HeladoDeBrownie> EvilMachine, out of curiosity, have you put any design work into this already?
14:29:38 <HeladoDeBrownie> or is this a fantasy so far?
14:30:04 <HeladoDeBrownie> (it's a fantasy that could become real, although it sounds kind of ambitious on the whole)
14:30:07 <EvilMachine> HeladoDeBrownie: Yes. Say PluginX has type XState as its internal state type, holding the handles it has open and such while it is loaded. It can pass XState to my core, which keeps it in memory. So later when PluginX is called again, the core can pass XState as a parameter again.
14:30:51 <EvilMachine> HeladoDeBrownie: And my hair-raising nightmare is my core passing the wrong type (not XState) back to PluginX, causing runtime errors.
14:31:03 <ab9rf> that's called a "user data parameter"
14:31:18 <ab9rf> see that sort of thing all the time in interop protocols
14:32:06 <ab9rf> the remote context is an opaque type
14:32:13 <EvilMachine> HeladoDeBrownie: Into this specific part? No. Because I had no idea how to start. In Haskell, you always need to know the type to start. That’s why I came here to ask how to start finding out how to solve this. It was too much for me alone.
14:32:36 <ab9rf> the host simply holds it and incudes it as a parameter on all foreign calls, not manipulating it in any way
14:32:38 <Trollinator> EvilMachine: I don't really sure what you're talking about… but perhaps Scala's abstract type members fit your bill?
14:32:41 <HeladoDeBrownie> EvilMachine, okay, just curious. that's the impression i got and it's fine, just wanted to be sure
14:32:55 <EvilMachine> ab9rf: Thank you. It calms me to know that it at least exists.
14:33:03 <Trollinator> s/I don't/I'm not/
14:33:47 <ab9rf> the "core" would store this as an either fixed or variable length sequence of bytes
14:34:09 <EvilMachine> HeladoDeBrownie: #haskell is just a damn good community for thowing ideas around on how to properly implement ideas (in Haskell). :)
14:34:22 <ab9rf> since it is not permitted to do anything with it othre than pass it back to the foreign partner, its own type for it is largely irrelevant
14:34:30 <HeladoDeBrownie> it sounds like ab9rf has the knowledge you need, so i'm gonna step out and work on my project. have fun and good luck :)
14:34:37 <ab9rf> these show up all the time in OS interfaces
14:34:47 <ab9rf> the WHND type in windows
14:34:55 <ab9rf> file descriptors in unix (which are admitteldy integers)
14:35:08 <ab9rf> FCBs in CP/M
14:35:28 <ab9rf> there are several such "control blocks" in older operating systems
14:35:46 <EvilMachine> ab9rf: Aaah. So my core would basically just store a ByteString. Which of course would mean handling type safety myself. (Sadly :/)
14:36:04 <ab9rf> the OS soimetimes allows the calling process to manipulate portions of the control block itself, but statesthat other parts are "reserved"
14:36:29 <EvilMachine> ab9rf: Yes, as long as I’d be strict about only passing it back, it should be safe.
14:37:00 <ab9rf> basiclaly it's a token
14:37:17 <ab9rf> it could be serialized data, or a lookup index, or any other such thing
14:37:20 <EvilMachine> HeladoDeBrownie: Thanks. :) And thanks for your help. :)
14:37:40 <ab9rf> the recipient of such a token is not permitted to modify it, only use it to identify a context on subsequent calls
14:37:45 <EvilMachine> ab9rf: Yes, file descriptors / handles is a very good example.
14:38:03 <EvilMachine> ab9rf: props for mentioning CP/M. :D
14:38:19 <Trollinator> Isn't that just an abstract type then?
14:38:19 <ski> (hm, CP/M ?)
14:38:44 <EvilMachine> ski: A precursor of DOS, basically.
14:39:05 <EvilMachine> ski: Think: DOS 1.0, without the ability to make directories in your file system. ;)
14:39:13 <ski> EvilMachine : i know :) .. just wondered why it was brought up
14:39:27 <EvilMachine> ski: Because he CAN. XD
14:39:34 * ski has a machine with a CP/M mode
14:39:40 <cmccann> nkar: oh btw, at a quick glance the other day I didn't see any general-purpose mp3 decoder on hackage, just stuff tied to larger dependencies or other functionality. surely there's a C lib for that we could have bindings for.
14:41:50 <EvilMachine> ab9rf: I think I’ll go the route of “BLOB”/handle state data in my core then. Only passing it back to the same plugin/driver should not be too hard of a guarantee to make. :)
14:41:59 <EvilMachine> ab9rf: Thanks a lot! :)
14:42:43 * EvilMachine wonders if cmccann found a ffmpeg binding or something like that. ;)
14:43:00 <lifter> ssss
14:43:16 <ParmesanCaesar> ssss
14:43:33 <ab9rf> beep
14:45:10 <ab9rf> cmccann: mp3 decoding is ugly, just FFI bind an existing C library
14:45:24 <nerium> Why does the data type "hello" tree args, but the hello monad only two?
14:45:25 <nerium> https://gist.github.com/oleander/ad9f13c780682bcc8724
14:45:40 <cmccann> EvilMachine: one abandoned and bitrotted, one that from a glance at the API seemed focused on video stuff (but I didn't look in great detail, since using OGG was easier anyway)
14:46:02 <cmccann> ab9rf: that's what I was suggesting
14:46:07 * hackagebot xhb-ewmh 0.1.2.1 - EWMH utilities for XHB  http://hackage.haskell.org/package/xhb-ewmh-0.1.2.1 (jrk)
14:46:42 <ab9rf> cmccann: can't be that hard, i worked with an MP3 decoder in 2000
14:46:45 <EvilMachine> Too bad there is no ... h2hs < somelib.h > somelib.hs
14:46:49 <ab9rf> i recall the API being fairly simple
14:47:11 <geekosaur> EvilMachine, perhaps you want c2hs?
14:47:15 <cmccann> ab9rf: which is why I mentioned it to someone asking about a weekend-sized project that would be useful to the community
14:48:26 <ab9rf> nerium: tree args?
14:48:38 <nerium> ab9rf: Hello q r a
14:48:46 <geekosaur> three
14:48:52 <ab9rf> oh, duh
14:48:58 <nerium> Hehe, sorry
14:49:07 <EvilMachine> geekosaur: All of those things that I looked at always said “It’s easy and fully automated.” and then “Just type out every damn function name and type of this 1000-function set of header files manually first.”. (They didn’t seem to do the header file parsing themselves.)
14:49:08 <geekosaur> and the reason is because you don't want to constrain that last type, whereas mentioning it in the definition of the Monad instance would force it to be constrained
14:49:38 <geekosaur> but the whole point is you can "map" an a to a b through it, for arbitrary a and b
14:50:11 <geekosaur> EvilMachine, pretty sure c2hs does exactly that. although not always well; I know gtk2hs had to fork it to get it to work properly with gtk headers
14:50:13 <ab9rf> i'm finally getting used to using functions as values
14:50:28 <EvilMachine> geekosaur: Then I have to look into it again. :)
14:50:31 <ab9rf> geekosaur: that's probably because of the degree to which gtk abuses the c preprocessor
14:50:56 <geekosaur> (part of the problem is that C types often do not capture enough information.. and yes, cpp abuse is another large part of it)
14:51:01 <ReinH> mp3 is such a weird encoding anyway
14:51:03 <geekosaur> also gnu C extensions and such
14:51:13 <ab9rf> geekosaur: i used to work on gtk, and there was some pretty gnarly cpp-fu in there
14:51:30 <ab9rf> ReinH: yes.  ugh.
14:51:41 <geekosaur> so gtk2hsc2hs may be a better thing to look at
14:52:51 <EvilMachine> geekosaur: I avoid anything widget-kit-like like the plague anyway. My current project will obsolete them too. :)
14:53:06 <geekosaur> well, the c2hs component is standalone
14:53:07 <ab9rf> i have never found a GUI abstraction that i liked
14:53:27 <geekosaur> the gtk2hsc2hs package does not depend on gtk2hs (in fact, the opposite)
14:54:02 <EvilMachine> ReinH: Can’t be worse than Malbolge ;) http://www.99-bottles-of-beer.net/language-malbolge-995.html
14:54:07 * geekosaur maintained the original gnome port to solaris; knows only too well...
14:54:39 <geekosaur> (first I had to give up on keeping it compatible with forte, then eventually I gave up on it entirely and switched to kde)
14:54:40 <ab9rf> ha, malbolge, the only language where developing code requires cryptanalysis.
14:55:26 <EvilMachine> ab9rf: What if the GUI had only two elements: one to display a value, and one to make choices. and the latter were directories in your file system? :D
14:55:39 <EvilMachine> ab9rf: XD
14:56:14 <EvilMachine> ab9rf: Obviously 100% keyboard-controllable, scriptable, the whole package.
14:58:57 <emaczen> How do you define a multi-line function in the REPL? e.g. factorial 0 = 1 and then factorial n = n * factorial (n-1)
14:59:10 <hpc> use :{ and :}
14:59:17 <hpc> or use a file
14:59:27 <hpc> you usually want to do something like ghci definitions.hs
14:59:33 <hpc> and then :r whenever you make changes
15:00:11 <emaczen> hpc: Ok, thanks
15:00:22 <dolio> You can also :set +m
15:00:47 <dolio> Then it will wait for multi-line input in some cases until you type a blank line.
15:01:08 * hackagebot th-lift 0.7.2 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.7.2 (MathieuBoespflug)
15:12:24 <ab9rf> ":{" is a funny looking thing
15:12:52 <gbiv> ab9rf: it's mustache man
15:13:22 <hpc> |:{ is a valid irc nick
15:13:36 <ab9rf> hpc: colons are allowed in irc nicks?
15:13:42 <hpc> iirc yes
15:13:50 <ab9rf> huh, that surprises me
15:13:51 <hpc> damn
15:13:56 <hpc> they aren't
15:14:02 <hpc> oh, it was |8{
15:14:03 <ab9rf> since colons are used as punctuation in the protocol spec.
15:14:05 <HeladoDeBrownie> anyone know if someone has implemented a lattice data structure (rather than class) which supports insertion and deletion?
15:14:37 <glguy> The special characters allowed in nicks are "[", "]", "\", "`", "_", "^", "{", "|", "}" and "-"
15:14:40 <hpc> also |8[
15:14:42 <hpc> aka bender
15:15:00 <ab9rf> glguy: note that aside from - all of those are classified as "letters"
15:15:11 <glguy> the RFC calls them "special"
15:15:18 <int-e> glguy: do I remember correctly that { is an upper case [ ?
15:15:19 <hpc> the RFC is special
15:16:03 <glguy> int-e: I remember something about them being due to some Swedish origin of the original spec or something like that, but I don't remember where I saw that
15:16:04 <ab9rf> glguy: it has to do with the origins of irc in scandinavia and the character set mapping then in common use, that uses [\]^ / {|}~ as substitutes for letters used in those languages not present in USASCII
15:16:09 <kadoban> Of course if you actually use most of those chars in a nick too much, people will be annoyed. Especially if you put them at the beginning so tab-complete is harder.
15:16:20 <ab9rf> glguy: it's alluded to in the RFC, but not stated outright
15:16:53 <int-e> glguy: "Because of IRC's scandanavian origin, the characters {}| are considered to be the lower case equivalents of the characters []\, respectively. This is a critical issue when determining the equivalence of two nicknames." - rfc1459
15:17:24 <int-e> (rfc2812, too)
15:17:38 <int-e> (but they fixed the typo :-)
15:17:43 <kadoban> HeladoDeBrownie: What does that mean exactly?
15:18:20 <HeladoDeBrownie> kadoban, which part?
15:18:23 <ab9rf> kadoban: there's no excuse for tab complete not handling thjose correctly, they're "letters" as far as irc is concerned :)
15:18:42 <kadoban> HeladoDeBrownie: What is a lattice data structure?
15:18:49 <HeladoDeBrownie> kadoban, https://en.wikipedia.org/wiki/Lattice_%28order%29
15:18:59 <kadoban> ab9rf: It's more that they're hard to type, so I pretty much hate anyone who uses them early on in their nick, haha.
15:19:06 <HeladoDeBrownie> it will end up being somewhat similar to a tree, but it's a different structure
15:19:08 <kadoban> Or not really hard, but…harder.
15:19:20 <HeladoDeBrownie> just as a general intuition about what it is
15:19:20 <kadoban> HeladoDeBrownie: Ah, thanks.
15:19:22 <koala_man> the swedish alphabet has 29 characters, and ASCII [\] {|} is äöå ÄÖÅ in ISO646-SE
15:19:26 <glguy> Freenode/inspircd didn't get that memo. | and \ aren't interchangable in channel names, at least
15:19:48 <glguy> or I misunderstood ^_^
15:21:07 <int-e> glguy: let's go and complain about this on #freenode. ;-)
15:22:16 <ReinH> HeladoDeBrownie: There are some data structures for representing posets
15:22:32 <ReinH> HeladoDeBrownie: I don't know of any implementations in Haskell
15:24:02 <HeladoDeBrownie> ReinH, yeah, i looked and am thinking i might have to write it myself. maybe throw it on hackage for the next poor soul to need lattices :P
15:24:24 <ReinH> HeladoDeBrownie: You might look at chapter 2 of http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.149.3551&rep=rep1&type=pdf
15:24:42 <ReinH> I think the "Matrix Representation" is the most interesting.
15:24:58 <HeladoDeBrownie> ReinH, sweet, thanks
15:26:12 <ReinH> HeladoDeBrownie: np
15:26:30 <ReinH> HeladoDeBrownie: Also I should probably actually read it, lattices are pretty useful in computing as it turns out
15:26:59 <HeladoDeBrownie> ReinH, the reason it came to mind is because i realized my todo manager software had a misdesing; it represents task prerequisites as a hierarchy when it should be a lattice.
15:27:06 <HeladoDeBrownie> misdesign*
15:27:51 <ReinH> HeladoDeBrownie: Indeed.
15:29:09 <ReinH> HeladoDeBrownie: I've come to a similar conclusion about dependencies in other domains.
15:29:35 <HeladoDeBrownie> ReinH, what domain were you thinking about when you realized?
15:29:47 <ReinH> HeladoDeBrownie: configuration management
15:33:17 <hrumph> https://groups.google.com/forum/#!topic/yesodweb/Emg6fPTPfFI <--if any yesod experts are here (that aren't already in #yesod)
16:21:11 * hackagebot Win32-junction-point 0.2.1 - Support for manipulating NTFS junction points.  http://hackage.haskell.org/package/Win32-junction-point-0.2.1 (MichaelSteele)
16:21:13 * hackagebot Win32-errors 0.2.2 - Alternative error handling for Win32 foreign calls  http://hackage.haskell.org/package/Win32-errors-0.2.2 (MichaelSteele)
16:26:12 * hackagebot b9 0.2.5 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.2.5 (SvenHeyll)
17:04:49 <mrmagneto> how can i  turn a list of form "apple,bee,cook" into a list of lists of form "[apple],[bee],[cook]" without using splitOn? I think I could use foldr somehow?
17:06:13 <Cale> > break (== ',') "apple,bee,cook"
17:06:14 <lambdabot>  ("apple",",bee,cook")
17:08:22 <Cale> > unfoldr (\s -> case s of [] -> Nothing; _ -> let (xs,ys) = break (== ',') s in Just (xs, drop 1 ys)) "apple,bee,cook"
17:08:23 <lambdabot>  ["apple","bee","cook"]
17:08:38 <Cale> or...
17:09:02 <ReinH> Cale: fyi this is homework
17:09:38 <Cale> > takeWhile (not . null) . iterate (drop 1 . dropWhile (/= ',')) $ "apple,bee,cook"
17:09:40 <lambdabot>  ["apple,bee,cook","bee,cook","cook"]
17:10:05 <Cale> > map (takeWhile (/= ',')) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= ',')) $ "apple,bee,cook"
17:10:06 <lambdabot>  ["apple","bee","cook"]
17:10:19 <Cale> There are a lot of options...
17:11:12 <mrmagneto> thank you, another option i thought of that is more up my alley is to turn the commas into spaces and then call words on it
17:12:20 <Cale> mrmagneto: Yeah, that's an option if you know there are no spaces already
17:12:46 <napping> Or just don't mind splitting on them
17:14:19 <napping> Fine for a quick hack, I used it recently to split on '.' for typing lists of numbers on the numberpad
17:15:24 <ReinH> Cale: Hey, I have a question about list cursors and the store comonad
17:16:58 <ReinH> Cale: if Functor f => (x, derivative f x) is always a Comonad, is ((->) e) the derivative of some other functor?
17:17:08 <silasm> funny, there's a `split :: (Char -> Bool) -> Text -> [Text]' for String and Bytestring, but there doesn't seem to be one for lists / Strings.
17:17:14 <ReinH> er, that's not quite right
17:17:21 <ReinH> Never mind.
17:18:29 <bigs> > foldl (++) [] $ ["["] ++ (map (\c -> case c of ',' -> "],["; x -> [x]) "foo,bar") ++ ["]"]
17:18:30 <lambdabot>  "[foo],[bar]"
17:18:31 <bigs> hehe
17:21:14 * hackagebot Wordlint 0.2.0.4 - Plaintext prose redundancy linter.  http://hackage.haskell.org/package/Wordlint-0.2.0.4 (bgbgbg)
17:22:55 <silasm> s/String and Bytesting/Text and Bytestring/
17:28:53 <ReinH> silasm: the split package exists to rectify this :)
17:29:56 <silasm> haha
17:30:05 <silasm> seems like a reasonable fix
17:56:38 <mrmagneto> is there a simple way to say that 1 != 1 is false?
17:56:45 <mrmagneto> != doesnt seem to exist in haskell
17:57:06 <Cale> It's /=
17:57:06 <BMeph> > 1 /= 1
17:57:08 <lambdabot>  False
17:57:19 <mrmagneto> thank you, perfect
18:00:10 <benzrf> :t (!=)
18:00:11 <lambdabot>     Not in scope: ‘!=’
18:00:11 <lambdabot>     Perhaps you meant one of these:
18:00:11 <lambdabot>       ‘!!’ (imported from Data.List), ‘/=’ (imported from Data.Eq),
18:00:16 <benzrf> syntactically valid :I
18:01:13 <voidzero> /= are next to each other on a dvorak keyboard
18:01:30 <voidzero> on qwerty it's an annoying combination
18:14:06 <ReinH> It is quite annoying on qwerty
18:16:11 <voidzero> I would have no problem if Haskell made != a synonym for /=
18:16:47 <ReinH> You can do that if you want.
18:17:21 <voidzero> yeah, sure. but i meant for everyone in the universe :-P
18:18:17 <voidzero> and I'm probably not the guy to pull those kind of strings
18:20:19 <ReinH> Hmm, everyone in the universe is a big ask.
18:20:48 <ReinH> I suppose edwardk will have to get on the intergalactic-libraries@ list again
18:21:04 <zipper> Hmmm testing in yesod. How do I act like a logged in user using mozilla persona?
18:26:28 <zipper> Would it be okay to ship yesod code without tests? Maybe because I don't know how to yet and add them on later?
18:31:30 <lpaste> nathanielc pasted “Simple Histogram” at http://lpaste.net/121263
18:31:40 <nathanielc> Just learning haskell and try to write my own histogram function. I want to be able to compute the histogram of a real valued list with fixed width bins. This is what I have so far. http://lpaste.net/121263
18:42:32 <enthropy> nathanielc: one way is to sort the result of hist
18:44:47 <lpaste> nathanielc revised “Simple Histogram”: “No title” at http://lpaste.net/121263
18:45:38 <nathanielc> ok, so I just found something that would work but the run time is O(x*n) where x is number of datapoints and n is number of bins
18:46:57 <zomg> oh wow, someone sent me a pull request on my haskell php parser/thing :P
18:47:11 <zomg> madness. I guess I'll merge it https://github.com/jhartikainen/hs-language-php/pull/1
18:48:26 <nathanielc> enthropy, how would sorting help? Sorry complete noob here
18:49:20 <faux___> for a school assignment, i was given some skeleton haskell code. i want to use hlint to check my code, but its throwing a lot of errors for the supplied code. can i get hlint to ignore these files? i don't want to change them
18:49:44 <enthropy> nathanielc: I mean you have [1,5,1,2,3,25] vs. [1,1,2,3,5,25], it's easier to see you have two ones in there
18:56:07 <zipper> How do I log in a user in tests when using BrowserID for authentication in a yesod app?
19:21:43 <faux___> for a school assignment, i was given some skeleton haskell code. i want to use hlint to check my code, but its throwing a lot of errors for the supplied code. can i get hlint to ignore these files? i don't want to change them
19:21:46 * hackagebot wai-middleware-preprocessor 0.2.0.0 - WAI middleware for preprocessing static files  http://hackage.haskell.org/package/wai-middleware-preprocessor-0.2.0.0 (taktoa)
19:22:31 <HeladoDeBrownie> faux___, were you instructed to use hlint on the code?
19:22:42 <faux___> HeladoDeBrownie: no
19:23:00 <HeladoDeBrownie> then i probably wouldn't worry about it too much
19:23:24 <HeladoDeBrownie> hlint is nice for guidelines but using it on code you can't alter isn't too helpful, i think
19:23:51 <HeladoDeBrownie> unless you just want a good idea what good style is, but there are other ways to get that
19:24:59 <faux___> HeladoDeBrownie: my code is in separate files, so i can use hlint on that. i was just wondering if there's an automated way to select certain files in a directory, besides writing a bash script
19:25:43 <fiksl> is it possible to have an instance declaraction of Monad for a type that takes no type parameters? Like Int?
19:25:52 <HeladoDeBrownie> unsure, don't have hlint on hand myself. is it possible for you to make the directory structure tell which files to lint?
19:25:58 <HeladoDeBrownie> fiksl, no.
19:26:12 <fiksl> ok thanks HeladoDeBrownie
19:27:01 <HeladoDeBrownie> fiksl, to elaborate a little, the type that goes in the head of the Monad instance must be of kind * -> *, which you can think of as a type-level function from concrete type (one containing values) to concrete type.
19:27:24 <fiksl> okay i see
19:28:03 <HeladoDeBrownie> this is inferred from how m is used in the methods' types, e.g., return :: a -> m a
19:28:58 <HeladoDeBrownie> since Int a is always an error, so is putting Int in the head of an instance for Monad
19:34:09 <mightybyte> Any idea what might be causing the error message "Constructor 'J#' should have 1 argument, but has been given 2"?
19:35:33 <mauke> mightybyte: giving J# 2 arguments?
19:35:47 <mightybyte> Yeah
19:36:13 <mightybyte> I'm getting this while building hashable with haste on GHC 7.6
19:36:29 <faux___> HeladoDeBrownie: it's nbd thanks for your help
19:36:40 <HeladoDeBrownie> sounds like a bad dependency version constraint
19:36:54 <HeladoDeBrownie> mightybyte, what are you using to build?
19:37:05 <mightybyte> HeladoDeBrownie: haste-inst
19:38:26 <HeladoDeBrownie> hmm, no idea what that does
19:38:40 <mightybyte> It is haste's version of cabal-install.
19:45:15 <nathanielc> whats wrong with this statement:  let f _ = 0 in Map.alter f 3 Map.empty
19:45:41 <nathanielc> I expect it to insert the key of 3 into the map with value 0
19:46:17 <mauke> :t M.alter
19:46:18 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
19:46:22 <mrmagneto> how can i do a simple debug using terminal on a runghc? i just want to see where my error occurs
19:46:23 <lpaste> nathanielc pasted “Map alter” at http://lpaste.net/121268
19:46:26 <mauke> 0 :/: Maybe a
19:49:40 <nathanielc> mauke, thanks so I needed this "let f _ = Just 0 in Map.alter f 3 Map.empty"
19:50:31 <xnull_> > show 123
19:50:33 <lambdabot>  "123"
19:50:45 <xnull_> > putStrLn $ show 123
19:50:46 <lambdabot>  <IO ()>
19:50:52 <xnull_> uWOT
19:50:55 <mauke> @src print
19:50:55 <lambdabot> print x = putStrLn (show x)
19:51:01 <HeladoDeBrownie> lambdabot doesn't execute arbitrary i/o
19:51:14 <HeladoDeBrownie> it's a security feature
19:51:21 <xnull_> ah ok
19:51:27 <ski> @help run
19:51:27 <HeladoDeBrownie> though i suppose it could use chrisdone's thing
19:51:27 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
19:51:34 <pavonia> Does it execute any IO at all?
19:51:37 <xnull_> > print $ show 123
19:51:38 <lambdabot>  <IO ()>
19:51:42 <xnull_> no
19:51:42 <MP2E> nope, no IO at all
19:51:56 <HeladoDeBrownie> it doesn't even send to the channel, you're imagining that
19:52:02 <MP2E> haha
19:59:04 <raymondtay> does anyone know if there’re other distributed form of haskell other than the “glasgow distributed haskell” ?
19:59:54 <Cale> raymondtay: There's Cloud Haskell -- a.k.a. distributed-process
20:00:09 <raymondtay> thanks Cale
20:02:17 <raymondtay> Cale: http://haskell-distributed.github.io/ which is Cloud Haskell’s incarnation seems to be what i was looking for, many thanks :)
20:02:51 <Cale> raymondtay: there's a good talk about that here https://skillsmatter.com/skillscasts/3523-cloud-haskell
20:03:05 <Cale> It'll annoyingly bug you to sign up to watch, but the account is free
20:03:51 <raymondtay> Cale: thanks for that info :)
20:11:03 <bramgg> I initialized a sandbox in my project's dir and in there installed my dependencies, but GHC still says it's missing all the deps when I run the app with runhaskell.
20:12:47 <nathanielc> I have an error with this snippet. http://lpaste.net/121270 I thinks its complaining that Map.empty isn't of type Num a, Num (Maybe a) but I am not sure how to fix the eror
20:13:16 <bramgg> Ah just found this, I'm assuming runhaskell just doesn't work with sandboxes? https://github.com/philopon/runsandbox
20:14:06 <pavonia> bramgg: There's also cabal exec runhaskell, I think
20:15:03 <pavonia> I'm not familiar with sandboxes, but I guess the problem is ghc doesn't look at the local config
20:17:27 <pavonia> nathanielc: The problen is in update, you'Re trying to add a Maybe value and a number
20:17:45 <bramgg> Found this: https://github.com/philopon/runsandbox
20:17:55 <bramgg> Whoops wrong link, http://stackoverflow.com/a/24840899
20:19:49 <pavonia> Have you tried cabal exec?
20:20:12 <nathanielc> pavonia, ok do I need to make the literal '1' a Maybe as well?
20:20:31 <bramgg> pavonia: what do I need to run cabal exec? (unrecognized command)
20:20:41 <bramgg> The solution I pasted works btw
20:21:17 <pavonia> Oh, I guess your cabal-install vertion is too old then
20:21:22 <pavonia> *version
20:22:27 <pavonia> nathanielc: You can't add two Maybe's, but your can use fmap to lift a function to use it on Maybe values
20:22:55 <pavonia> > fmap (\x -> x*x) (Just 10)
20:22:57 <lambdabot>  Just 100
20:23:02 <pavonia> > fmap (\x -> x*x) Nothing
20:23:04 <lambdabot>  Nothing
20:28:15 <nathanielc> thanks I think I got it
20:52:33 <nathanielc> So I am confused again: let inc x = fmap(\x -> x+1) x in Map.alter inc 3 Map.empty returns an empty map
20:54:44 <mniip> :t M.alter
20:54:45 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
20:55:04 <ReinH> nathanielc: What do you expect altering an empty map to do?
20:55:05 <pavonia> nathanielc: That is because inc gets and so returns Nothing as the map is empty
20:55:39 <ReinH> since fmap Nothing = Nothing, as pavonia says
20:56:16 <nathanielc> ok, so the example here confused me http://hackage.haskell.org/package/containers-0.4.2.0/docs/Data-Map.html
20:56:27 <nathanielc> it says alter can be used to insert and update keys
20:56:51 <pavonia> It can it the return of the update function is Just
20:57:03 <pavonia> *if the
20:57:11 <ReinH> nathanielc: Yes, it inserts keys by changing a Nothing to a Just value, and deletes by doing the reverse.
20:57:21 <ReinH> fmap can't do either of those
20:57:53 <ReinH> fmap can only modify an existing key or leave a key empty.
20:58:19 <nathanielc> got it thanks: let inc x = if x == Nothing then Just 0 else fmap(\x -> x+1) x in Map.alter inc 3 Map.empty
20:58:40 <ReinH> nathanielc: It would be easier to pattern match
20:58:51 <ReinH> That also implies an Eq constraint on the type of x
20:58:52 <mniip> let inc x = if x == Nothing then Just 0 else fmap(\x -> x+1) x in Map.alter inc 3 Map.empty
20:58:54 <mniip> oops
20:58:56 <ReinH> which pattern matching avoids
20:59:40 <mniip> > let inc Nothing = Just 0; inc (Just x) = Just (x + 1) in M.alter inc 3 M.empty
20:59:42 <lambdabot>  fromList [(3,0)]
20:59:46 <ReinH> let inc Nothing = Just 0; inc (Just x) = Just (x + 1)
20:59:48 <ReinH> right
21:02:41 <c_wraith> > let f x = fmap (+1) x <|> Just 0 in (f Nothing, f $ Just 1)
21:02:43 <lambdabot>  (Just 0,Just 2)
21:17:32 <Big_G> Will functions on infinite lists always timeout?
21:17:39 <Big_G> Like sum on a list of all 0's
21:19:08 <enthropy> > take 5 [1 .. ]
21:19:10 <lambdabot>  [1,2,3,4,5]
21:19:34 <lpaste> nathanielc pasted “Working hist” at http://lpaste.net/121272
21:20:03 <nathanielc> thanks everyone for the help, my first little program is working then way I expect it to.
21:20:14 <Big_G> enthropy, I should clarify. Functions that normally use the entire list like sum or tail
21:20:58 <nathanielc> It does seem odd that I have to union all the maps with a sum function. Is there a way I could pass the original map into the mapUpdate function so I could just get the head map at the end?
21:21:23 <enthropy> > foldr (+) 0 [1 .. ] > (100 :: Nat)
21:21:24 <lambdabot>  Not in scope: type constructor or class ‘Nat’
21:21:53 * hackagebot HsSyck 0.53 - Fast, lightweight YAML loader and dumper  http://hackage.haskell.org/package/HsSyck-0.53 (AudreyTang)
21:22:40 <enthropy> > foldr (+) 0 [1 .. ] > (100 :: Natural)
21:22:41 <lambdabot>  True
21:23:52 <enthropy> Big_G: if it's a foldr there's a chance it'll work on infinite lists
21:24:18 <Big_G> enthropy, Is there any deterministic way of knowing?
21:25:31 <enthropy> you have to look at if the first arguent to foldr is lazy in it's second argument
21:26:13 <nshepperd> 15:58:17           ReinH | let inc Nothing = Just 0; inc (Just x) = Just (x + 1)
21:26:15 <nshepperd> 15:58:18           ReinH | right
21:26:16 <nshepperd> 15:58:17           ReinH | let inc Nothing = Just 0; inc (Just x) = Just (x + 1)
21:26:18 <nshepperd> 15:58:18           ReinH | right
21:26:21 <nshepperd> 15:58:17           ReinH | let inc Nothing = Just 0; inc (Just x) = Just (x + 1)
21:26:23 <nshepperd> 15:58:18           ReinH | right
21:26:24 <nshepperd> 15:58:17           ReinH | let inc Nothing = Just 0; inc (Just x) = Just (x + 1)
21:26:27 <nshepperd> 15:58:18           ReinH | right
21:26:30 <nshepperd> aaah cat
21:26:37 <Big_G> enthropy, Would you please clarrify what that means?
21:27:41 <enthropy> foldr op 0 [1 .. ] = 1 `op` (2 `op` (3 `op` (4 `op` ...
21:28:26 <enthropy> if (1 `op` undefined) is some defined value (say op is "const")
21:28:37 <enthropy> then the ... doesn't have to get evaluated
21:29:33 <Big_G> but it wouldn't work if op takes 2 arguments?
21:30:48 <nshepperd> > sum [1..] > (100 :: Natural)
21:30:52 <lambdabot>  mueval-core: Time limit exceeded
21:30:58 <nshepperd> huh
21:31:21 <enthropy> @src sum
21:31:21 <lambdabot> sum = foldl (+) 0
21:31:25 <ReinH> nshepperd: where you expecting something else?
21:31:26 <dramforever> @tell alpounet there's still a problem: now your taggy drops line breaks, but they are supposed to be there. Try taggy on that agda page and you will see
21:31:27 <lambdabot> Consider it noted.
21:31:28 <nshepperd> I guess sum uses the strict definition
21:31:31 <ReinH> some [1..] never terminates
21:31:35 <ReinH> There is no non-strict definition
21:31:43 <ReinH> Unless you're using non-strict numbers
21:31:44 <dramforever> nshepperd: no, it's foldl
21:31:48 <nshepperd> ReinH: foldr (+) 0
21:32:09 <ReinH> nshepperd: That doesn't change the result
21:32:13 <dramforever> > let sum' = foldr (+) 0 in sum' [1..] > (100 : Natural)
21:32:15 <lambdabot>  Not in scope: data constructor ‘Natural’
21:32:38 <ReinH> Perhaps we shouldn't talk about "strict" here.
21:32:49 <dramforever> > let sum' = foldr (+) 0 in sum' [1..] > (100 :: Natural)
21:32:50 <lambdabot>  True
21:32:53 <dramforever> yeah!
21:33:14 <dramforever> nshepperd: ^
21:33:22 <dramforever> foldr works in this case
21:33:30 <ReinH> Right, foldr works with non-strict numbers.
21:33:50 <ReinH> Because foldr is productive
21:34:17 <ReinH> and (>) for Natural is sufficiently lazy
21:34:47 <Big_G> ReinH, So it just evaluates until it gets to something that is bigger than 100?
21:36:02 <ReinH> Big_G: It evaluates until it determines whether the value is greater than 100
21:36:43 <ReinH> e.g., after popping off enough succ constructors from both that it is comparing to 0 on the right hand side
21:36:44 <Big_G> ReinH, How does it know? I could be at a value greater than 100 but later on add a large negative number
21:36:52 <ReinH> There are no negative natural numbers.
21:36:55 <dramforever> @tell alpounet Oh and taggy doesn't really handle doctypes. When rendering it just gives a <doctype> tag
21:36:55 <lambdabot> Consider it noted.
21:37:11 <dramforever> @what Natural
21:37:11 <lambdabot> I know nothing about natural.
21:37:22 <Big_G> ReinH, So that code wouldn't work if I had all real numbers instead
21:37:30 <ReinH> Big_G: or Integers, no.
21:37:33 <haskell-beginner> Hello, I am trying to implement Forward Checking + MRV in haskell. I have written http://pastebin.com/x6NXk922 , but I am stuck at the helper function, which gives the modified list of domains, where some variables are set.  Can anybody suggest how to proceed from here
21:37:38 <dramforever> Big_G: Naturals are special
21:37:50 <ReinH> Basically, data Natural = Zero | Succ Natural
21:38:00 <jle`> Big_G: you'll have to look at the definition of (>) for Nat
21:38:03 <Big_G> dramforever, I'm just trying to figure out how smart the compiler actually is
21:38:07 <dramforever> > 1 + undefined > (0 : Natural)
21:38:09 <lambdabot>  Not in scope: data constructor ‘Natural’
21:38:16 <Big_G> jle`, What is succ?
21:38:18 <nshepperd> um, you can't subtract anything "later on" anyway, in an expression like that
21:38:18 <dramforever> aww crap
21:38:22 <jle`> Big_G: succ?
21:38:28 <ski> > 1 + undefined > (0 :: Natural)
21:38:30 <jle`> oh
21:38:30 <lambdabot>  True
21:38:37 <dramforever> > Succ $ Succ $ Succ $ Succ Zero
21:38:38 <lambdabot>  Not in scope: data constructor ‘Succ’Not in scope: data constructor ‘Succ’No...
21:38:44 <dramforever> aww aww crap
21:38:48 <jle`> data Nat = Z | S Nat
21:38:51 <jle`> zero = Z
21:38:53 <jle`> one = S Z
21:38:54 <ReinH> (>) is defined lazily: _ > Zero = True; Zero > _ = False; Succ n > Succ m = n > m
21:39:02 <jle`> two = S (S Z)
21:39:05 <ski> > genericLength [0 ..] > (4 :: Natural)
21:39:07 <lambdabot>  True
21:39:12 <jle`> three = S (S (S Z))
21:39:13 <jle`> etc.
21:39:17 <ReinH> dramforever: I'm not sure what the actual constructors of Natural are
21:39:18 <dramforever> also aww aww crap just typed too much agda and can't fix myself to write :: instead of ::
21:39:23 <ReinH> but they are equivalent to my definition
21:39:30 <dramforever> ReinH: maybe they are not exported?
21:39:33 <jle`> _ < Z = True
21:39:35 <ReinH> dramforever: mayb enot
21:39:38 <jle`> Z < _ = False
21:39:47 <jle`> um...that's backwards
21:39:47 <Big_G> I still don't understand the succ keyword
21:39:54 <jle`> there is no succ keyword
21:39:55 <ReinH> Big_G: it's a data constructor
21:40:01 <ReinH> and it's Succ for my definition
21:40:03 <ski> jle` .. ?
21:40:05 <ReinH> Big_G: Consider lists
21:40:09 <ReinH> Lists are just decorated natural numbers
21:40:11 <dramforever> Big_G: oh you are a beginner, right?
21:40:17 <ReinH> Big_G: How can we tell if one list is larger than another?
21:40:24 <Big_G> dramforever, To Haskell
21:40:40 <dramforever> Big_G: How much have you learnt about haskell?
21:40:52 <Big_G> ReinH, Compare the return values of length on those lists
21:40:52 <nshepperd> "(foldr (+) 0 [1..] - 100) > 100" is a different expression from "foldr (+) 0 [1..] > 100"
21:40:53 <dramforever> like, which chapter of RWH/LYAH/...
21:41:13 <Big_G> dramforever, Just a good part of learn you a haskell
21:41:16 <nshepperd> the former will evaluate as much of the subtraction is necessary to show that the result is more than 100
21:41:18 <ReinH> Big_G: Ok, that's one way.
21:41:26 <ReinH> Big_G: but can you tell if [] is larger than [1..]?
21:41:28 <dramforever> Big_G: Which chapter?
21:41:53 <Big_G> I just got to 9
21:41:55 * ski idly wonders whether ReinH means "longer than"
21:42:00 <dramforever> oh that's IO
21:42:02 <ReinH> ski: I do, yes.
21:42:03 <haskell-beginner> I am just reposting my previous question. Hello, I am trying to implement Forward Checking + MRV in haskell. I have written http://pastebin.com/x6NXk922 , but I am stuck at the helper function, which gives the modified list of domains, where some variables are set.  Can anybody suggest how to proceed from here
21:42:06 <Big_G> ReinH, I would hope so
21:42:16 <ReinH> Big_G: But how can you do that if you can't get the length of an infinite list?
21:42:24 <ski> > [] > [1 ..]
21:42:26 <lambdabot>  False
21:42:35 <ReinH> ski: But since I'm treating lists as decorated nats, I used "larger"
21:42:40 <ski> ok
21:42:55 <dramforever> Big_G: I think larger means dictionary-ly larger
21:42:58 <Big_G> ReinH, I agree but as a human, I can see that an infinite list must be larger
21:43:07 <ReinH> Big_G: You can pattern match: [] isn't longer than anything
21:43:15 <ReinH> so [] `longerThan` _ = False
21:43:32 <ReinH> likewise, everything other than [] is longer than []
21:43:38 <ReinH> _ `longerThan` [] = True
21:43:45 <dramforever> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
21:43:53 * ski . o O ( "Ornamental Algebras, Algebraic Ornaments" by Conor McBride in 2010-08-09 at <https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/Ornament.pdf> )
21:44:03 <ReinH> Big_G: For other lists, you define (x:xs) `longerThan` (y:ys)
21:44:14 <ReinH> Big_G: by saying "well, I can remove the first element without changing the answer"
21:44:15 <dramforever> Big_G: ^ data Nat = Z | S Nat is just a normal algebraic datatype
21:44:52 <Big_G> So that'd always return something unless both were infinite, correct?
21:44:58 <ReinH> Big_G: right
21:45:05 <ReinH> at one point you'll get back to one of the base cases
21:45:11 <ReinH> Big_G: so lazy naturals are compared in the same way
21:45:34 <ski> ReinH : .. have you seen that McBride paper ?
21:45:35 <dramforever> Haskell Beginners' Common Misconception: Those weird stuff like (>>=), ($), (.) are keywords/part of the syntax
21:45:36 <ReinH> Nothing is smaller than Zero. Zero is smaller than everything other than Zero.
21:45:44 <ReinH> ski: I've seen a lot of pigworker's papers... ;)
21:45:44 <Big_G> Are infinite lists said to have the same length?
21:46:07 <ReinH> Big_G: In Haskell, it's undefined.
21:46:10 <dramforever> Big_G: you can't tell if a list is infinite
21:46:11 <Big_G> dramforever, How are they not part of the syntax?
21:46:21 <dhinojosa> > 1 + 1
21:46:23 <lambdabot>  2
21:46:24 <ski> Big_G : yes, they have the same length. but it's not observable
21:46:25 <dramforever> Big_G: well...
21:46:29 <ReinH> ski: Which one in particular?
21:46:29 <dhinojosa> yay haskell!
21:46:30 <dhinojosa> haha
21:46:30 <dramforever> it's undecidable
21:46:35 <ski> ReinH : link above
21:46:39 <dramforever> just like the halting problem
21:46:42 <ReinH> ski: Oh I missed that sorry.
21:46:59 <dhinojosa> > (pure 4 :: ((->) r) Int)
21:47:01 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable r0)
21:47:01 <lambdabot>    arising from a use of ‘M148227201521245149211178.show_M1482272015212451492...
21:47:01 <lambdabot>  The type variable ‘r0’ is ambiguous
21:47:07 <dramforever> you can construct a list containing the steps of a turing machine before it halts
21:47:08 <ReinH> ski: Oh, I haven't seen this one! It looks relevant to my interests though.
21:47:21 <Big_G> dramforever, I've had this conversation before but if you have a function for a list instead of a list of values, wouldn't that automatically mean that it is infinite?
21:47:33 <dhinojosa> yikes any help with function applicative?
21:47:34 <ski> ReinH : well, i thought of it because you say "treating lists as decorated nats"
21:47:55 <ReinH> ski: Well, I did glean the term from Conor originally, but not form that paper :)
21:47:55 <dramforever> Big_G: well w.r.t "part of the syntax"
21:48:02 <haskell-beginner> In a 'and' of expressions if any one expression is False, then whole expression becomes false, even though the other expressions nor evaluated. How can we emulate such thing in haskell
21:48:22 <dramforever> Big_G: someone asked online "What do the separators $ and . mean in haskell"
21:48:41 <nshepperd> @where Natural
21:48:41 <lambdabot> I know nothing about natural.
21:48:46 <dramforever> haskell-beginner: don't look at the RHS if LHS is False
21:49:05 <ski> haskell-beginner : you need (speculative) parallelism to do it symmetric
21:49:25 <ReinH> ski: Conal's stuff
21:49:39 <Big_G> How are infinite lists stored? Is it the same way as regular lists?
21:49:40 <ski> ReinH : conal ?
21:49:45 <ReinH> ski: Conal Elliott
21:49:46 <ski> Big_G : yes.
21:49:48 <dramforever> Big_G: yes
21:49:49 <ReinH> ski: yeah
21:49:50 * ski nods
21:50:05 <ReinH> ski: unamb
21:50:26 <dramforever> Well actually someone asked me why list doesn't support insert_back
21:50:28 <ReinH> Lets you have a maximally lazy ||
21:50:32 <ReinH> for instance
21:50:38 <dramforever> I told him data [a] = a : [a] | []
21:50:44 <Big_G> How is that done? With regular lists, you have to store all of it at once where infinite lists you can't do that
21:50:49 <ski> ReinH : oh .. i thought you were saying you first say the decorating stuff in some conal piece
21:50:52 <ReinH> so True || undefined = True and undefined || True = True
21:50:55 <dramforever> He said: What??? I thought that was just an example!
21:51:09 <dmj`> when is the next haskell report coming out?
21:51:12 <haskell-beginner> dramforever: i didn't understand what you have meant
21:51:16 <ReinH> ski: No, in some of Conor's other work
21:51:21 <ReinH> ski: Conor, Conal...
21:51:28 <dramforever> haskell-beginner: it's okay I misunderstood...
21:51:55 * hackagebot hunt-searchengine 0.3.0.0 - A search and indexing engine.  http://hackage.haskell.org/package/hunt-searchengine-0.3.0.0 (alexbiehl)
21:51:57 * hackagebot hunt-server 0.3.0.0 - A search and indexing engine server.  http://hackage.haskell.org/package/hunt-server-0.3.0.0 (alexbiehl)
21:51:59 * hackagebot hunt-server-cli 0.2.0.0 - A Command line Interface for the Hunt server.  http://hackage.haskell.org/package/hunt-server-cli-0.2.0.0 (alexbiehl)
21:52:02 <dramforever> Big_G: You have to store the whole thing, but the "whole thing" isn't infinite, actually
21:52:06 <ski> ReinH : afaiui, `unamb' uses some variant of parallelism or concurrency for implementation, no ?
21:52:17 <ReinH> ski: Yeah, it actually uses threads under the hood iirc
21:52:31 <ski> Big_G : you store a description of how to generate as many elements of the list as are desired
21:52:32 <ReinH> It's a bit of a sledgehammer :)
21:52:45 * ski nods
21:52:46 <haskell-beginner> ski: can you expand on speculative parallelism
21:52:49 <dramforever> Big_G: kinda like the "turing machine" I described
21:53:08 <Big_G> ski, Exactly. So couldn't you tell if a list is infinite if it requires a generator instead of storing the elements outright?
21:53:31 <dramforever> Big_G: it always requires a generator
21:53:58 <Big_G> How does it know what generator to use for something like [1, 321, 4, 53]?
21:54:11 <dramforever> Big_G: step 1: desugar
21:54:28 <dramforever> compiler sees it as (1 : 321 : 4 : 53 : [])
21:54:45 <dramforever> step
21:55:05 <dramforever> wait a sec
21:55:11 <dramforever> isn't that already a generatos
21:55:16 <dramforever> s/atos/ator/
21:55:18 <ski> haskell-beginner : if you have `foo && bar', then to make sure that in case one of them is `False', and the other `undefined' (or nontermination), you still get `False' as answer, you need to evaluate `foo' and `bar' concurrently (but you can't observe any concurrency nondeterminacy, which was why i said "parallelism"). as soon as one stops with `False', you can halt the evaluation of the other, and yield `False'. if one stops with `True', you still have to
21:55:41 <ski> (hm, possibly cut off somewhere near ".. you can halt the evaluation of the other, and yield `False'. if one stops with `True', you still have to finish the evaluation of the other")
21:56:03 <dramforever> Big_G: did you get it
21:56:03 <ReinH> ski: This is a nice Conal video on FRP that covers unamb a bit https://vimeo.com/6686570 btw
21:56:10 <ski> Big_G : you can't inspect the generator. this is by design
21:56:21 <ReinH> ski: it accompanies his push/pull frp paper http://conal.net/papers/push-pull-frp/
21:56:29 <haskell-beginner> ski: Thanks
21:56:30 <Big_G> dramforever, I see what you did there but I still feel like you have to store those values somewhere or else you'd forget
21:56:37 <Big_G> ski, Why would they do that?
21:56:45 <ski> Big_G : the same list can be generated in many different ways. we want them to be indistinguishable, from within the language
21:56:49 <dramforever> Big_G: yes, so it makes a generator at runtime
21:56:52 <ReinH> ski: in it he covers how unamb is rather ugly... ;)
21:57:21 <dramforever> Big_G: that's the same as why we have lazy evaluation
21:57:53 <dramforever> actually "generator" isn't really correct, but mostly correct
21:57:58 <Big_G> ski, Wouldn't it be useful to know why they were generate  that way?
21:58:16 <dramforever> Big_G: because you wrote the generator, right?
21:58:20 <dramforever> IIUC the question
21:58:34 <ReinH> Big_G: you could store information about the generator, but then that isn't a list, it's another structure that describes how to generate a list.
21:58:48 <Big_G> dramforever, What is the correct term then?
21:58:49 <dramforever> like a turing machine...
21:59:41 <Big_G> Why wouldn't Haskell just abstract that out?
21:59:45 <dramforever> Big_G: it's hard to say, but those stuff in haskell really the same as the "yield" in other languages like python or javascript
21:59:57 <dramforever> Big_G: yes that was abstracted out
21:59:58 <ReinH> Big_G: Why would it?
22:00:00 <dramforever> so you get it
22:00:18 <dramforever> ouch s/really the/are not really the/
22:00:32 <Big_G> ReinH, Extra information. No hard but possibly benefit
22:00:43 <ReinH> Big_G: what sort of things specifically are you talking about?
22:00:48 <dramforever> Big_G: that won't fit in data [a] = a : [a] | []
22:01:11 <ski> Big_G : we want noone to be able to distinguish in the language between `[0,1,2]' and `reverse (reverse [0,1,2])' .. otherwise, we wouldn't be able to (safely) apply the refactoring law `reverse (reverse xs) = xs' for (known) finite lists `xs'
22:01:17 <Big_G> For example, You'd be able to see if a list is infinite because it'd have a different generator
22:01:30 <ReinH> Big_G: No, you wouldn't.
22:01:42 <dramforever> Big_G: we don't talk about lists containing generators
22:01:57 <ReinH> Do you consider [1..] to be a list created from a "generator"?
22:01:59 <Big_G> ski, Couldn't we have multiple forms of equality?
22:02:00 <ski> in general, you can't decide whether a program for a list will generate a finite or an infinite list
22:02:06 <ski> that would solve the halting problem
22:02:25 <Big_G> ReinH, Yes
22:02:28 <ReinH> What about the equivalent list, let xs = 1 : map succ xs in xs?
22:02:29 <ski> Big_G : we alrady have
22:02:32 <ReinH> These are the same list.
22:02:38 <ski> we have semantic equality `=', which isn't computable
22:02:41 <dramforever> HEY! How about this: let's explain the "generator" thing first
22:02:45 <dmj`> does anyone know when the next haskell report is due
22:02:50 <ski> and we have computable equality `==', which is decidable
22:03:08 <ReinH> Big_G: At best, you would be able to tell that a subset of infinite lists were infinite
22:03:09 <dramforever> HEY HEY HEY
22:03:15 <ski> (well, mostly-computable-sometimes-nonterminating)
22:03:32 <dolio> Semi-decidable, hopefully.
22:03:32 <dramforever> HEY HEY HEY HEY let's explain "generators" first
22:04:09 * ski generates more "HEY"s for dramforever
22:05:34 <dramforever> Big_G: how about this: basically all values are stored as either a piece of code or a concrete constructor (possibly) containing values
22:06:17 <Big_G> dramforever, Sure
22:06:31 <dramforever> Big_G: when someone needs to see the constructor, the code is executed and the constructor and a few new pieces of code replaces the old thing
22:06:52 <Big_G> Agreed
22:07:16 <ReinH> ski: thanks for the paper btw, I've added it to my stack of "papers I really ought to get around to reading already"
22:07:25 <dramforever> the code is called a "thunk", and seeing the constuctor is called "reduce to WHNF" (You will learn about it at some time in the future)
22:07:34 * ski thinks symbolic links might be .. a not so good analogy for this
22:07:49 <ski> ReinH : yw
22:08:36 <Big_G> What do you mean by seeing the constructor? A thunk is just something that hasn't been evaluated, correct?
22:08:58 <dramforever> Big_G: like pattern matching
22:09:23 <dramforever> f (Just x) = -- We just looked into the argument and "saw the constructor"
22:09:40 <dramforever> Big_G: so when we reduce [1..] to WHNF, we do this:
22:09:45 <dramforever> @src enumFrom
22:09:45 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:09:50 <dramforever> ouch...
22:10:14 <Big_G> \What is WHNF?
22:10:25 <ski>   enumFrom n = n : enumFrom (succ n)
22:10:29 <dramforever> Big_G: you will learn about it in the future
22:10:30 <conal> ReinH: unamb ugly? it has the semantics of lub, which is at the heart of the denotation of programming languages.
22:10:31 <ski> Weak Head Normal Form
22:10:36 <conal> ReinH: unamb ugly? it has the semantics of lub, which is at the heart of the denotation of programming languages.
22:10:49 <ReinH> conal: The implementation is a big ugly in Haskell.
22:11:04 <ReinH> which I don't blame you for
22:11:08 <conal> ReinH: that it is!
22:11:09 <dramforever> Big_G: [1..] = enumFrom 1 = <blah> : <blah>
22:11:10 <ReinH> *bit
22:11:10 <Big_G> dramforever, OK. You use pattern matching to extract values
22:11:23 <ReinH> conal: denotationally, no, and I'm sorry if I implied that
22:11:31 <dramforever> Big_G: <blah> : <blah> is in WHNF
22:11:45 <Big_G> What is enumFrom?
22:11:55 <dramforever> [1..] desugars into (enumFrom 1)
22:12:02 <ReinH> conal: (and by the way I'm always fascinated by how often lattices show up at every level of abstraction in CS)
22:12:04 <dramforever> and enumFrom is in the Enum typeclass
22:12:12 <conal> ReinH: i don't know whether unamb/lub can implemented efficiently and correctly in haskell.
22:12:13 <dolio> DCPOs only have lubs of directed sequences, not two arbitrary values, though.
22:12:51 <ReinH> conal: also hi :)
22:13:00 <conal> ReinH: hi :)
22:13:37 <Big_G> So what does enumFrom 1 do?
22:13:38 <ReinH> conal: uh oh, I think we've awakened the dolio
22:15:08 <ski> Big_G : you may or may not find my "`fibs' reduction trace" <http://lpaste.net/116547> interesting/useful. it shows a reduction trace in pretty small steps
22:15:56 <ReinH> @where lazy
22:15:57 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
22:15:58 <ReinH> And also this
22:16:16 <ski> yes
22:16:21 <ReinH> ski: BTW I would like to see a generic process for generating these a la simple-reflect
22:16:42 <ReinH> ski: So far I've done it by hand or with some ad hoc tool assistance that only happens to work for one particular term
22:17:50 <dramforever> Big_G hi I'm back
22:18:00 <dramforever> crap internet just died a few moments ago
22:18:02 <dolio> ReinH: It's circular anyway, really.
22:18:06 <Big_G> No worries
22:18:21 <ReinH> dolio: what is?
22:18:44 <dolio> People don't use lattices for models because they don't need to, because there's no operation that corresponds to arbitrary binary lub.
22:18:54 <Big_G> dramforever, So what were you trying to explain?
22:19:00 <dolio> But if there were, they probably would use lattices.
22:19:07 <dolio> Because they'd have to.
22:19:39 <dramforever> Big_G: yes I was trying to show you how haskell computes [] < [1..]
22:20:15 <Big_G> dramforever, I think I understand how it does that. I still don't think I full understand the "generator" part
22:20:38 <dramforever> Big_G: think "thunks", not "generators"
22:21:05 <dolio> And if you do use lattices to model languages without such an operation, your model is bad, in that it has too much stuff, so there's a reason not to use them, unless you have the operation, in which case there is a reason to use them.
22:21:10 <ski> ReinH : .. with comments ?
22:21:11 <dramforever> you don't need to compute some of the list because you didn't look into it
22:21:31 <ReinH> ski: I mean I've written little programs to generate the evaluation steps for something like a foldr for me
22:21:40 <ReinH> but in a totally ad hoc way
22:23:23 * ski . o O ( "Don't stuff that you don't have." )
22:23:39 <dolio> So my saying, "the models don't have lubs," doesn't really mean anything, because you could instead only choose models with lubs if you wanted a language with lubs.
22:26:20 <dolio> The bigger question is what that'd look like. You'd have some top element in everything that is distinct somehow from bottom, but would probably be an error, like bottom.
22:26:48 <dolio> And also whether, as conal said, you could ever implement it efficiently enough to make the languages desirable.
22:27:10 <dolio> Which is probably the hard part.
22:27:51 <ski> dolio : sounds like abstract interpretation, a bit
22:35:18 <dolio> Some things seem weird, thinking about it. Like, you might think the 'empty' type could have one value, which would be both bottom and top.
22:36:01 <dolio> But it seems like that probably wouldn't work out, because then mapping through the empty type might crush bottom and top together in every type, which would be wrong.
22:39:28 <dolio> Or maybe it's not wrong. Not sure.
22:44:58 <dolio> Actually, no, they must be distinct.
22:47:27 <SrPx> So, I want to implement a grid (tilemap) for a game. I'd use a data structure such as vector. But from past experiences, I know it is a pain if I later decide to use another representation. I've been thinking, is it okay to create a typeclass, "Grid", which just implements "new", "set" and "get", and use it? So that if I decide to use another structure later, I just create an instance for it.
22:47:35 <dolio> Because there is a function ! : (forall a. a) -> B for every B such that !⊥ = ⊥ and !⊤ = ⊤. But ⊥ and ⊤ are distinct in some types, so they cannot be the same in (forall a. a), because x = y => f x = f y.
22:47:41 <SrPx> That falls on the "lawless" side of typeclasses which has a lot of problems so...
22:47:44 <SrPx> I don't know.
22:53:26 <Rotaerk> SrPx, alternatively you can make a record containing a new, set, and get function, ala interfaces
22:55:19 <SrPx> ah indeed, now that  think about it it will do just fine
22:55:20 <SrPx> my bad
22:55:42 <nkar> SrPx: it's fine.  also, you can "invent" certain laws.  like, if you set the same thing twice, you get that thing.  like the lens laws
22:56:07 <HeladoDeBrownie> am i overlooking something or does base lack of type of natural numbers?
22:56:17 <HeladoDeBrownie> s/of/a/
22:56:45 <SrPx> it doesn't have complexes too
22:56:51 <haasn> HeladoDeBrownie: You're right, base lacks an arbitrary-size natural type
22:56:52 <Rotaerk> it only has artificial numbers?
22:56:55 <SrPx> complex numbers*
22:57:08 <dolio> 7.10 has Naturals.
22:57:08 <HeladoDeBrownie> haasn, hmm, that's disappointing.
22:57:13 <HeladoDeBrownie> dolio, oh, cool.
22:57:25 <haasn> dolio: Which kind is that? the kind that's like Integer?
22:57:32 <Axman6> dolio: oh? I hadn't heard that, that's a pleasant surprise. got a link?
22:57:43 <dolio> Yes, it's GMP naturals.
22:57:59 <SrPx> I really really wish base had a lot more of mathy stuff, complex numbers, quaternions, algebra, geometry and so on :( makes a lot of sense for something like that to be part of the base, but
22:58:01 <Axman6> excellent
22:58:07 <SrPx> since other languages don't, I guess we follow this trend
22:58:11 <Axman6> I've been wanting that for quite a long time
22:58:21 <haasn> SrPx: I think the greater problem is that there are too many different ways to approach that stuff
22:58:32 <ReinH> There's plenty of algebra in base ;)
22:58:32 <Axman6> base has Complex no?
22:58:34 <haasn> I'd prefer not having historical baggage in base for non-trivial things that can easily be provided by libraries
22:58:35 <Axman6> @hoogle Complex
22:58:36 <HeladoDeBrownie> naturals seem like something basic to me, although i might be biased
22:58:37 <lambdabot> Data.Complex data RealFloat a => Complex a
22:58:37 <lambdabot> Data.Complex module Data.Complex
22:58:37 <lambdabot> Graphics.Rendering.OpenGL.GLU.Tessellation ComplexContour :: [AnnotatedVertex v] -> ComplexContour v
22:58:41 <haasn> Axman6: No, it comes from numeric afaik
22:58:44 <SrPx> haasn: ah, that is true.
22:58:51 <haasn> Oh, Complex is indeed in base
22:58:57 <SrPx> wow, nice :) til
22:59:11 <dolio> The naturals are technically in integer-gmp. Not base.
22:59:30 <dolio> It seems to be GHC.Natural, to. There's no Data.Natural.
22:59:50 <dolio> So maybe it's kind of prerelease.
23:04:51 <dolio> Oh, actually, it is base.
23:08:39 <mrkkrp> Do you know some library that has function to convert file path like "~/my-file.txt" to "/home/actual-user/my-file.txt" ? I've searched System.FilePath and System.Directory without success.
23:09:25 <dolio> Does canonicalizePath not do that?
23:09:31 <mrkkrp> no
23:10:07 <mrkkrp> it throws an exception saying that file doesn't exist
23:10:14 <dolio> Ah.
23:10:52 <ReinH> Welp.
23:11:08 <xnull> needs more monoids
23:12:00 <avocado> mrkkrp: for some reason ~ doesn't work, but it will follow symlinks and other things
23:12:17 <speak> That's basically a bash parameter expansion or something?
23:12:32 <speak> Maybe not quite a parameter expansion, but it is a bash feature, right?
23:12:36 * speak isn't quite sure, actually
23:12:51 <Zemyla> If I have a function (Monad m) => m a -> m a, how do I turn it into a function (MonadTrans t, Monad m) => t m a -> t m a?
23:12:57 <dolio> I think it's a shell feature, yes. Not something that automatically works.
23:13:18 <HeladoDeBrownie> just tried `touch ~/foo` not in a shell, failed. looks like a shell feature.
23:13:25 <dolio> Lots of stuff implements it, though.
23:13:29 <heatsink> I'm not sure you can do that in general, Zemyla
23:13:55 <mrkkrp> Well, I think I will splitDirectories, then substitute tilde with value of getHomeDirectory, then joinPath again.
23:18:59 <ReinH> expandPath ('~':path) = getHomeDirectory >>= (</> path); expandPath path = return path
23:20:14 <Feras_> k
23:20:21 <Feras_> Hello? lol
23:20:25 <Axman6> l
23:20:30 <ReinH> Feras_: hi
23:20:36 <Feras_> Awesome! someone is here.
23:20:55 <avocado> not like there aren't 1496 people
23:20:56 <ski> Zemyla : try `hoist' in `mmorph' ?
23:21:01 <Feras_> i'm fairly new to IRC so i still don't exactly know to use it.
23:21:26 <HeladoDeBrownie> Feras_, if you have a question regarding haskell, feel free to ask it, and whoever can reply may
23:22:20 <Feras_> Appreciate that.
23:23:49 <avocado> but you do'nt need to ask a question
23:29:42 <mrkkrp> ReinH: it won't work, by the way. There will be "/home/foo" </> "/file.txt" = "/file.txt". Also it need at lest one more pattern to match on strings that don't start with tilde.
23:30:20 <ReinH> mrkkrp: Ok, then ('~':'/':path), and there already is a second pattern
23:30:48 <mrkkrp> Ah, yeah. Overlooked it.
23:31:06 <ReinH> I couldn't remember if </> checked for /s or not, but it makes sense that it doesn't
23:31:29 <ReinH> ofc if you want real shell expansion, you should use a shell
23:33:11 <HeladoDeBrownie> how does "/home/foo" </> "/file.txt" = "/file.txt" make sense?
23:34:11 <HeladoDeBrownie> actually i'm wondering how combine in general makes sense
23:34:20 <HeladoDeBrownie> the documentation is unhelpful on how it's useful
23:34:59 <nilg> Can I define a type holding functions, using the 'data'?
23:35:04 <HeladoDeBrownie> nilg, yep
23:35:16 <HeladoDeBrownie> data Foo = Bar (Baz -> Quux) -- for example
23:35:55 <nilg> oh, and so I can construct this type using a function as argument of Bar, thank!
23:36:11 <HeladoDeBrownie> yep, sounds like you understand
23:42:25 <aloiscochard> hey all, in case that is of interest or someone want to help, I'll start a haskell binding for grpc (https://github.com/grpc/grpc)
23:43:41 <mrkkrp> Does Haskell have some function to replace some element in a list with another element, like: replace 1 5 [1,2,3,1,2] == [5,2,3,5,2] ?
23:44:19 <Axman6> mrkkrp: it's trivial to implement with map
23:44:47 <mrkkrp> Yes, but it will be more verbose than standard function for this
23:45:27 <platz> aloiscochard: how difficult is http/2 to implement would you think?
23:45:48 <Axman6> platz: there's already libraries for wai that implement it I believe
23:46:35 <platz> that certainly is nice
23:46:41 <aloiscochard> yes, what Axman6 says :)
23:46:48 <Axman6> > let replace x y = map (\a -> if x = a then y else a) in replace 1 5 [1,2,3,1,2]
23:46:50 <lambdabot>  <hint>:1:35: parse error on input ‘=’
23:46:57 <Axman6> > let replace x y = map (\a -> if x == a then y else a) in replace 1 5 [1,2,3,1,2]
23:46:59 <lambdabot>  [5,2,3,5,2]
23:49:09 <mrkkrp> Axman6: 1. You need to define this trivial function. 2. If you don't want to define it you need to write `map (\a -> if x == a then y else a)' instead of `replace x y`. I've seen standard functions for even more trivial things (defined on top of other functions, like this). But it's strange that there is no `replace` function.
23:51:00 <Axman6> compared to the generality of most prelude functions, that's a fairly specific function which is easily implemented using more general functions in a pretty concise way. I'm sure there are libraries which implement it, but it's also super easy to write yourself
23:51:45 <Axman6> you could write a more general replaceWhen :: (a -> Bool) -> a -> [a] -> [a] and write replace in terms of that too
23:54:21 <mrkkrp> Axman6: well, it's not less general than other functions in prelude. I can't say that delete is more general than replace. Nevermind.
