00:00:23 <EvanR> in your code you get the current time deeper in the action, rather than the beginning and threading in through to places that need it
00:00:28 <funfunctor> EvanR: so how would getRxGain look with :: IO Double?
00:00:50 <EvanR> readIORef rxGainRef or something
00:01:30 <EvanR> what it looks like depends on the backend doesnt it
00:01:46 <funfunctor> EvanR: but where is rxGainRef coming from?
00:02:12 <EvanR> its in scope in the constructor of the device object
00:03:04 <funfunctor> oh lexical closure inside the IO monad?
00:03:52 <EvanR> closures are used a lot in haskell you might not even know
00:04:11 <EvanR> it doesnt have to have anything to do with IO directly, in this case
00:04:24 <EvanR> it just needs to be in scope to write readIORef theRef
00:04:41 <workerbeetwo> Hi. ghc cannot find packes like Graphics.UI.Gtk.General.RcStyle  . Im on ubuntu and cabal is also installed.
00:04:41 <EvanR> so pass it into the constructor or construct it there
00:09:48 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/121068
00:10:09 <f-a> We finally found something questionable about Simon Peyton Jones, his mail client
00:10:22 <funfunctor> EvanR: I am a little confused by the scope then ^ where exactly should newIORef occur?
00:10:58 <funfunctor> EvanR: assuming I am not putting it in bladeRFGetRxGain :: IO Double
00:11:00 <EvanR> constructBladeRFDevice :: RadioDevice
00:11:06 <EvanR> constructBladeRFDevice :: IO RadioDevice
00:11:16 <EvanR> funfunctor: that wouldnt work
00:11:44 <funfunctor> EvanR: yea so I am confused when you say constructor?
00:11:56 <EvanR> funfunctor: -- | Construct an instance of the RadioDevice interface type with BladeRFDevice
00:11:59 <EvanR> that
00:12:17 <EvanR> since thats an IO action, you can choose to create the hidden IORef there
00:12:20 <funfunctor> you mean the type signature needs to be right before the scope will work
00:12:37 <EvanR> no the type of that command is another issue
00:12:37 <Azel> @workerbeetwo Is the gtk2hs package installed on your machine?
00:12:37 <lambdabot> Unknown command, try @list
00:12:54 <Azel> workerbeetwo: Is the gtk2hs package installed on your machine?
00:13:38 <funfunctor> EvanR: ok but I have http://lpaste.net/121068#line172 in constructBladeRFDevice
00:13:48 <workerbeetwo> Azel: unable to locate package. was it taken from the ubuntu repositories?
00:14:05 <Azel> And the package name on Hackage is gtk if I remember...
00:14:21 <Azel> Sorry, I was talking of the cabal package, not the Ubuntu one
00:14:27 <EvanR> funfunctor: i didnt notice that. but id do it before building the big record
00:14:36 <EvanR> otherwise its not in scope
00:15:45 <EvanR> getRxGain             = readIORef rxGainRef
00:18:32 <EvanR> funfunctor: also, this usage isnt really using a closure. readIORef foo isnt partially applying anything, the result is an IO Double value
00:18:52 <EvanR> just like x + y's result wouldnt be considered a closure, normally
00:19:07 <EvanR> implementation details aside
00:20:16 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/121068
00:20:28 <funfunctor> EvanR: it just says its not in scope
00:20:47 <EvanR> getRxGain             = bladeRFGetRxGain?
00:20:52 <EvanR> whats not in scope
00:21:03 <Tehnix> Is there any super tutorial/guide to XML parsing in Haskell? What I've found seems super much more complex, than say Aeson :/
00:21:04 <funfunctor> ah oh
00:21:18 <voidzero> stop using super
00:21:25 <funfunctor> EvanR: yes I had bladeRFGetRxGain = readIORef ..
00:21:27 <voidzero> super sounds dumb
00:21:36 <EvanR> funfunctor: well dont do that
00:21:37 <funfunctor> EvanR: hence me jibber jabbering on about closure
00:31:18 <L8D> is there a way to force allow importing from hidden modules?
00:31:42 <L8D> I guess not
00:31:56 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/121068
00:32:06 <funfunctor> EvanR: ^ still says they are not in scope
00:32:38 <EvanR> lpaste the error message
00:33:31 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121072
00:33:50 <EvanR> check the line number
00:34:24 <funfunctor> oh shit
00:34:26 <funfunctor> woops
00:37:00 <helmut> is there a way to write type composition or type lambdas? how to compose e.g. [] and Maybe?
00:37:41 <EvanR> https://hackage.haskell.org/package/TypeCompose-0.6.7/docs/Control-Compose.html
00:38:09 <EvanR> general type lambdas would make type checking undeciable, i think
00:38:45 <EvanR> [] :. Maybe
00:38:50 <helmut> EvanR: as far as I can see Control.Compose inserts a newtype, is it possible without?
00:39:08 <L8D> @pl fmap . fmap
00:39:08 <lambdabot> fmap . fmap
00:40:01 <ab9rf> heh
00:40:07 <ab9rf> @unpl fmap.fmap
00:40:07 <lambdabot> (\ c -> fmap (fmap c))
00:40:31 <EvanR> helmut: well, it is a new type?
00:40:38 <helmut> EvanR: when I try type O f g a = f (g a), and try using [] `O` Maybe, "I get Type synonym `O' should have 3 arguments, but has been given 2"
00:41:04 <EvanR> you cant partially apply them
00:41:13 <ab9rf> at least not without an extension
00:41:16 <helmut> yeah, I figured that ghc doesn't let me do it
00:41:54 <helmut> so I have a class that wants something like [] :. Maybe, but when I use that, I cannot use e.g. catMaybes, because there is this additional newtype ctor
00:43:25 <helmut> so I am asking, why is there no way to write an f such that f a is [Maybe a]?
00:44:05 <EvanR> type O a = [Maybe a]
00:44:17 <helmut> bummer. thanks
00:44:35 <helmut> I should have had that idea earlier
00:44:40 <EvanR> dont take my word for it though, im not familiar with that stuff
00:45:35 <helmut> unfortunately, ghc does not allow me to stuff that O unapplied into other things with the same error above
00:46:50 <EvanR> http://stackoverflow.com/questions/4069840/lambda-for-type-expressions-in-haskell
00:47:26 <helmut> ah. I stumbled into that one earlier, but didn't read it till end apparently.
00:47:31 <aidecoe> I have a problem with keeping indentation consistent and yet keeping code readable. Are there any guidelines to that?
00:47:39 <Zemyla> :i Data.Functor.Product
00:48:23 <narendraj9> @info take
00:48:23 <lambdabot> take
00:48:29 <helmut> EvanR: it seems that at some point I may need to switch to agda/idris/... many thanks thus far!
00:48:31 <funfunctor> ok I mostly took out the StateT from BladeRFDevice now
00:48:42 <EvanR> aidecoe: theres a github page for haskell style, called haskell style guide
00:48:55 <EvanR> helmut: yeah, they have exactly what youre asking for ;)
00:49:17 <EvanR> funfunctor: nice
00:49:35 <EvanR> funfunctor: but whats BladeRFDevice, seems you only need RadioDevice?
00:49:50 <aidecoe> EvanR: <https://github.com/tibbe/haskell-style-guide>?
00:50:00 <funfunctor> EvanR: yea I've removed it
00:50:20 <funfunctor> EvanR: I backed it out till it was gone
00:51:11 <Zemyla> helmut: Actually, look at Data.Functor.Compose.
00:51:11 <EvanR> aidecoe: the files in there, the .md, have a lot of indentation examples
00:51:20 <helmut> EvanR: the problem, of course, is porting the rest of the code base to agda
00:51:25 <Zemyla> @hoogle Data.Functor.Compose
00:51:27 <lambdabot> Data.Functor.Compose Compose :: f (g a) -> Compose f g a
00:51:27 <lambdabot> Data.Functor.Compose newtype Compose f g a
00:51:27 <lambdabot> Data.Functor.Compose module Data.Functor.Compose
00:51:39 <EvanR> helmut: seems drastic
00:52:15 <helmut> Zemyla: it's a newtype as well. so ([] `Compose` Maybe) a != [Maybe a]
00:52:43 <Zemyla> Hmm. Since the product of two monads is a monad, is the sum of two comonads a comonad?
00:53:51 <EvanR> Zemyla: maybe, seems plausible
00:54:20 <EvanR> the sum aspect seems like the most basic way to pick the "cursor"
00:54:56 <Zemyla> Sum f g a = InL (f a) | InR (g a); extract (InL f) = extract f; extract (InR g) = extract g; duplicate (InL f) = InL (fmap InL (duplicate f)); duplicate (InR g) = InR (fmap InR (duplicate g))
00:55:47 <Zemyla> Yeah, it fits.
00:56:22 <EvanR> Zemyla: http://lpaste.net/121074 ... ?
00:56:54 <EvanR> ah you did it
00:57:04 <EvanR> Either just wont work
00:57:55 <Zemyla> Yeah. Just like how Product isn't just a pair.
01:01:12 <aidecoe> EvanR: thanks. Quite nice description.
01:03:49 <aidecoe> hm, "let..in" is missing
01:03:58 <detrumi> :r
01:04:04 <detrumi> Whoops, wrong buffer
01:04:58 <EvanR> aidecoe: i usually avoid let ins most of the time
01:05:09 <EvanR> opting for a where clause
01:05:14 <aidecoe> EvanR: how's that?
01:05:26 <aidecoe> ah, i see
01:05:45 <aidecoe> i like let..in
01:06:15 <aidecoe> i use let..in for short expressions
01:06:19 <EvanR> let in is annoying because you have to indent your multi-line entries farther than the variable names in the let
01:06:22 <aidecoe> and where for a bit longer functions
01:06:35 <EvanR> which is father than they would but in a where
01:07:19 <EvanR> if its so short you probably dont need a style guide
01:08:59 <lf94> How are my lambda brethren today
01:25:10 <ab9rf> apparently all asleep
01:25:35 <tdammers> nah... just lazy
01:30:04 <lf94> lol
01:35:24 * hackagebot Ketchup 0.4.3 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.4.3 (Hamcha)
01:40:56 <funfunctor> EvanR: still about?
01:41:27 <EvanR> -_-
01:41:31 <jle`> -.-
01:42:19 <funfunctor> EvanR: sorry :p just you know were I am at
01:42:19 <EvanR> 3:41 AM, yes
01:42:24 <funfunctor> oh dear
01:42:34 <funfunctor> umm, maybe you should just go to bed then
01:42:47 <EvanR> no i need to stay until until today
01:43:13 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/121068
01:43:56 <funfunctor> EvanR: this is where I am at with NullDevice, still a little confused as to what to do with the time statefulness
01:44:43 <EvanR> initialReadTimestamp is what, time of construction?
01:45:04 <EvanR> anything the client doesnt need to know about doesnt need to be in the interface
01:45:25 * hackagebot text-and-plots 0.1.1.0 - EDSL to create HTML documents with plots based on the C3.js library.  http://hackage.haskell.org/package/text-and-plots-0.1.1.0 (andersjel)
01:45:36 <funfunctor> EvanR: client needs to know about timestamps
01:46:46 <EvanR> what feature are you not getting
02:04:55 <funfunctor> EvanR: I would need to get startTime inside updateTime
02:05:25 * hackagebot lucid 2.9.2 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.9.2 (ChrisDone)
02:06:18 <EvanR> funfunctor: is start time a constant'
02:06:20 <funfunctor> EvanR: so startTimeRef :: IORef UTCTime ends up winding up in the RadioDevice type or something?
02:06:29 <funfunctor> EvanR: yes
02:06:36 <EvanR> when does its value become availabe
02:06:36 <funfunctor> I guess it would be
02:07:19 <funfunctor> EvanR: upon the radio backend starting so I guess upon nullDeviceStart really
02:07:33 <EvanR> this is different from constructing the object?
02:08:08 <funfunctor> EvanR: yes
02:09:00 <EvanR> so you intend for the driver to be constructed, and then later on "started", at which time you get some more values filled in
02:09:05 <funfunctor> yacky mutability
02:09:14 <funfunctor> yes
02:09:32 <EvanR> what interesting thing would happen between constructing and starting
02:10:19 <funfunctor> EvanR: radio could stop and then later start again
02:10:39 <EvanR> oh
02:10:49 <EvanR> well wouldnt that change the start time?
02:10:54 <funfunctor> yes
02:11:00 <EvanR> then its not a constant
02:11:04 <funfunctor> so its only constant for the duration of radio operation
02:11:12 <funfunctor> I suppose
02:11:16 <EvanR> why is this exposed?
02:11:59 <funfunctor> EvanR: well startTime should not be as such, but currentTimeStamp should be
02:12:11 <funfunctor> which is calculated form the startTime
02:12:25 <EvanR> ok, what is current timestamp exposed for?
02:13:55 <funfunctor> EvanR: ordering packets and bursts in a priority queue
02:14:08 <EvanR> by what
02:14:24 <funfunctor> somewhere up the stack, users of RadioInterface
02:14:39 <EvanR> they all will implement their own queue?
02:15:01 <funfunctor> the queue is generic/abstracted from the RadioDevice
02:15:11 <funfunctor> thats part of RadioInterface that sits on top
02:15:28 <EvanR> can the current time be combined with packets by the lower level thing
02:15:34 <aidecoe> ["abc","123"] `verticalJoin` ["def", "456"] = ["abcdef", "123456"]  -- is there already defined function which does it?
02:16:21 <EvanR> or does that not make sense
02:16:59 <EvanR> aidecoe: thats zipWith (++) ?
02:17:52 <aidecoe> EvanR: hah, indeed
02:18:00 <aidecoe> i knew it must be simple
02:18:02 <aidecoe> (-:
02:18:11 <aidecoe> thanks
02:19:06 <EvanR> funfunctor: anyway, it seems that your start time is another internal mutable variable
02:20:12 <entity> hello, i'm trying to come up with a function that does this: [1, 2, 3] -> [(1, [2, 3]), (2, [1, 3]), (3, [1, 2])]
02:20:32 <entity> i haven't used haskell much lately and i'm not sure where to start (with the function)
02:20:41 <entity> any advice? :)
02:21:21 <EvanR> \[a,b,c] -> [(a,[b,c]),(b,[a,c]),(c,[a,b])] ;)
02:22:12 <entity> well
02:22:23 <EvanR> entity: theres the delete function which might be of use
02:22:27 <rom1504> :D
02:22:49 <EvanR> or take plus drop
02:23:17 <rom1504> implementing it recursively shouldn't be too hard either
02:23:35 <entity> okay, thanks for the pointers
02:24:21 <Cale> entity: When (x:xs) is a nonempty list, you can either pick the first element out, getting (x,xs), or you have (y,x:ys) where (y,ys) is obtained by picking an element of xs
02:24:29 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121077
02:24:46 <funfunctor> EvanR: ^ does this help explain the use of timestamps?
02:25:53 <funfunctor> EvanR: here its being used to check for over and under run conditions
02:26:14 <EvanR> funfunctor: yes, its using basically a global variable to compute something it could be doing locally
02:26:26 <EvanR> its a pretty silly want to do it
02:26:47 <EvanR> way
02:26:51 <funfunctor> well this C++ code is pretty yucky
02:27:27 <funfunctor> so I am just trying to figure out the bast way to do the same sort of thing
02:27:28 <EvanR> the currstamp isnt necessary
02:27:49 <funfunctor> oh?
02:28:09 <EvanR> no its basically using that as a local variable, and its calling a function to mutate it before use
02:28:18 <EvanR> rather than use a local
02:29:02 <funfunctor> EvanR: but there is some sharing going on between readSamples and writeSamples
02:29:12 <EvanR> when you execute writeSamples, start by getting the current time (or have the current time passed in if its part of a larger action), then use original time to get a dt
02:29:16 <funfunctor> possibly racy
02:29:36 <EvanR> yeah thats even worse i cant see how that is a good idea
02:29:44 <EvanR> both of them update the variable
02:29:47 <EvanR> its just a local
02:30:24 <EvanR> if both are used concurrently, itll just fuck up
02:30:35 <EvanR> but i dont think its expected to be called that way
02:32:38 <funfunctor> EvanR: no they are, they race
02:32:43 <funfunctor> I know about this race already
02:32:59 <EvanR> ... either way you dont want to replicate the problem :S
02:33:04 <funfunctor> over and under runs happen far too oftern ;)
02:33:08 <funfunctor> haha
02:33:19 <EvanR> over and underruns seems like a different issue
02:33:47 <funfunctor> EvanR: I mean when the race occurs it makes it "look like" all these over/under runs are happening..
02:33:58 <funfunctor> any way
02:34:12 <funfunctor> so how to write these functions essentially?
02:34:23 <funfunctor> *actions
02:34:45 <EvanR> like i said, get the current time or pass it in in writeSamples and use it to calculate the required dt for the protocol
02:34:59 <EvanR> using your hidden internal variable for startTime
02:36:21 <EvanR> (writeSamples in the c++ code seems not do any writing of samples)
02:36:33 <EvanR> cuz its a dummy
02:36:44 <funfunctor> but how is nullDeviceWriteSamples :: going to access startTime when its out of scope?
02:36:44 <EvanR> so it doesnt need to do anything
02:36:57 <EvanR> make it not out of scope
02:37:09 <EvanR> nullDeviceWriteSamples is a no-op anyway
02:37:19 <funfunctor> I know it is
02:37:24 <EvanR> so why are we concentrating on it
02:37:42 <funfunctor> because it forms the basis of how the 'real' driver actually works
02:37:51 <EvanR> no it doesnt, it doesnt do anything
02:37:51 <funfunctor> and its easier to think about
02:37:55 <EvanR> return ()
02:39:32 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121078
02:39:51 <funfunctor> EvanR: thats how its actually being used in the real writeSamples
02:41:02 <EvanR> funfunctor: in this case, its doesnt use the instance variable, it doesnt do the silly updateTime
02:41:14 <EvanR> it basically does what i was saying
02:41:49 <EvanR> how an underrun or overrun can occur in the dummy driver i have no idea
02:41:58 <EvanR> why write code for it
02:42:33 <entity> ah cool got it, thanks everyone
02:42:56 <entity> cya
02:43:28 <aidecoe> is there already a function which does that? f n = (\s -> (take n s, drop n s))
02:43:48 <EvanR> :t splitAt
02:43:49 <lambdabot> Int -> [a] -> ([a], [a])
02:44:00 <aidecoe> EvanR: thanks (-:
02:45:22 <funfunctor> EvanR: in retrospect I think you are right, maybe they were trying to debug the races
02:46:26 <workerbeetwo> Azel: gtk+2.0 is installed. still graphics.ui. something is not found.
02:46:59 <workerbeetwo> Azel: Graphics.UI.Gtk.General.RcStyle to be exacte. but I think it concerns much more such UI things.
02:49:13 <workerbeetwo> Azel: gtk2hs-buildtools . no gtk2hs package on ubuntu 14 it seems.
02:53:25 <xkb> :t mapM_
02:53:26 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
02:53:59 <funfunctor> Found:
02:53:59 <funfunctor>   \ x y ->
02:53:59 <funfunctor>     bladeRFSetTxFreq ((fromIntegral . round) x)
02:53:59 <funfunctor>       ((fromIntegral . round) y)
02:53:59 <funfunctor> Why not:
02:53:59 <funfunctor>   bladeRFSetTxFreq `Data.Function.on` (fromIntegral . round)      how can that work?
02:55:06 <EvanR> funfunctor: what?
02:55:25 <EvanR> it seems to be trying to improve your style
02:55:36 <funfunctor> but that wont even type-check
02:55:48 <fractalsea> I just set up haskell-mod and ghc-mod for emacs as in this guide: https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md But I am getting a weird squiggly underline showing up in different places on every line. Screenshot: http://i.imgur.com/511ULYs.png Do you know how I might remove this? Thanks
02:55:51 <EvanR> it seems to be equivalent, so if it doesnt, it wouldnt have
02:56:10 <EvanR> @src on
02:56:10 <lambdabot> (*) `on` f = \x y -> f x * f y
02:56:10 <funfunctor>     Expected type: Int -> Int -> IO ()
02:56:11 <funfunctor>       Actual type: Int -> Word16 -> IO ()
02:56:36 <EvanR> i have no idea what code is throwing that error or where
02:58:16 <EvanR> funfunctor: is one Word16 and the other something else?
02:58:28 <EvanR> if so just ignore that
02:58:57 <funfunctor> EvanR: yes bladeRFSetTxFreq :: Int -> Word16 -> IO ()
02:59:10 <funfunctor> so that style fix is wrong then?
02:59:31 <merijn> funfunctor: HLint isn't smart
02:59:35 <EvanR> funfunctor: yes, the f must have a single type
02:59:38 <merijn> funfunctor: It just looks for duplicated text
02:59:48 <merijn> funfunctor: It's not smart enough to see that round has a different type in both cases
03:00:06 <merijn> Or rather, that the fromIntegral does, I guess
03:00:34 <EvanR> does this have anything to do with monomorphism restriction
03:00:41 <merijn> No
03:00:43 <EvanR> ok
03:00:48 <merijn> on just doesn't type check
03:00:50 <merijn> :t on
03:00:50 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
03:01:07 <funfunctor> I added a type-signature and it went away
03:01:17 <funfunctor> so no problem
03:03:56 <funfunctor> :t shiftL
03:03:58 <lambdabot> Bits a => a -> Int -> a
03:04:55 <jle`> :t on
03:04:56 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
03:06:13 <EvanR> > 0x12345678 .&. 0xff000000 `shiftR` 24
03:06:14 <lambdabot>  120
03:06:22 <EvanR> > (0x12345678 .&. 0xff000000) `shiftR` 24
03:06:23 <lambdabot>  18
03:06:28 <EvanR> just got bit by this
03:08:07 <EvanR> > showHex (0xff `shiftL` 24 .|. 0xff `shiftL` 8) ""
03:08:08 <lambdabot>  "ff00ff00"
03:23:17 <funfunctor> merijn: hmm seems like a bug in hlint because it wont go away even with type signatures
03:32:50 <nomeata> hvr: heh. I as well should read all mails before replying. I just re-invented your "WARNING categoriztion extension" :-)
03:37:05 <merijn> funfunctor: It's not a bug as much as a feature the hlint doesn't have
03:37:33 <merijn> funfunctor: Type signatures don't help because hlint knows nothing about types
03:38:35 <funfunctor> merijn: ah dang ok
03:39:13 <zipper> Many haskell jobs in Germany?
03:41:15 <aib> Hi, I have an IO function, (IO String -> IO String) that I'm iterate'ing to get [IO String]. Now, I need to perform takeWhile on this before sequence'ing and printing. takeWhile requires (IO String -> Bool), which I don't know how to produce. This should be really simple, but I can't find the solution. Any ideas?
03:41:16 <int-e> Am I the only one who has to think twice before realizing that "FTP" does not stand for "File Transfer Protocol", e.g., in "GHC 7.10 will use Plan FTP"?
03:41:49 <EvanR> :t takeWhile
03:41:50 <lambdabot> (a -> Bool) -> [a] -> [a]
03:42:40 <EvanR> aib: well [IO String], you cant do much with this except sequence it
03:42:44 <EvanR> then you can takeWhile
03:43:08 <aib> oh.
03:43:11 <EvanR> theres no useful function IO String -> Bool
03:44:16 <merijn> @hackage monad-loops
03:44:16 <lambdabot> http://hackage.haskell.org/package/monad-loops
03:44:21 <aib> apart from myPredicate . unsafePerformIO, right?
03:44:27 <EvanR> uh no
03:44:29 <merijn> aib: No, use monad-loops
03:45:13 <aib> merijn: Actually that's where I started. Same thing with takeWhile
03:45:53 <EvanR> aib: theres an iterateUntilM in there
03:45:55 <merijn> monad-loops has a short-circuiting takeWhile for monadic actions
03:47:00 <EvanR> ah, whileM and untilM
03:47:28 <Jefffrey> Hello
03:47:50 <zipper> Jefffrey: Waddup?
03:48:12 <Jefffrey> A brand new day of cabal hell. What about you?
03:48:35 <aib> hmmm
03:48:37 <aib> playing around...
03:51:00 <aib> iterateUntil still wants IO String -> Bool
03:51:08 <aib> ahh, M
03:51:20 <EvanR> whileM
03:52:29 <aib> :t whileM
03:52:30 <lambdabot> Not in scope: ‘whileM’
03:52:43 <EvanR> in monad-loops
03:53:04 <aib> whileM :: Monad m => m Bool -> m a -> m [a]
03:53:08 <aib> This doesn't make any sense to me
03:53:57 <EvanR> well it doesnt let you case the decision on the a, nevermind. theres something in there
03:53:59 <Jefffrey> Ok, so, I have a brand new debian VM. Installed only postgres, GHC and cabal. Currently have Cabal 1.22 and GHC 7.4.1. I'm trying to build a simple hello world package that only requires base >= 4.7 && < 4.8.
03:54:44 <aib> well, sequence is a start. Now I have an IO [String] I want to perform takeWhile on. bind should help there
03:55:10 <EvanR> is it an infinite list
03:55:19 <Jefffrey> I'm getting the usual "Dependency tree exhaustively searched" thingy for base. Saying it's rejecting every package and apparently I have base 4.5 installed. I'm using a sandbox, tried removing and reiniting the sandbox many times. No success.
03:55:41 <aib> EvanR: yes
03:55:48 <EvanR> then dont use sequence
03:56:07 <EvanR> it will never complete
03:58:44 <jameseb> Jefffrey: the version of base is tied to the version of GHC
04:00:55 <Jefffrey> jameseb: Then there's something terribly wrong going on (http://pastebin.com/VSRASmKg)
04:01:37 <aib> Okay, so this is Python Challenge #4 (http://www.pythonchallenge.com/pc/def/linkedlist.php). Basically, I request nothing=12345 and it gives me back another number. I request nothing=thatNumber and get another one, and so on... The code I have so far is:
04:01:48 <aib> :t let dorq x = Network.HTTP.simpleHTTP (Network.HTTP.getRequest ("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=" ++ x)) >>= Network.HTTP.getResponseBody in (iterate (>>= dorq . last . words) (return "12345"))
04:01:49 <lambdabot> [IO String]
04:02:36 <narendraj9> > let dorq x = Network.HTTP.simpleHTTP (Network.HTTP.getRequest ("http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=" ++ x)) >>= Network.HTTP.getResponseBody in (iterate (>>= dorq . last . words) (return "12345"))
04:02:37 <lambdabot>  Not in scope: ‘Network.HTTP.simpleHTTP’Not in scope: ‘Network.HTTP.getReques...
04:03:06 <EvanR> surprised that :t worked
04:03:10 <aib> yeah
04:03:50 <aib> narendraj9: No instance for (Show (IO String)) arising from a use of `print'  Possible fix: add an instance declaration for (Show (IO String))  In a stmt of an interactive GHCi command: print it
04:04:21 <aib> ...which baffled me until I realized the interpreter was taking [] as the outer Monad
04:04:22 <alpy> hello, i have a kinda of a legal question. Am i allowed to earn money using hackage packages?
04:04:48 <merijn> alpy: It depends
04:04:51 <Qfwfq> Depends on their licenses, but usually.
04:04:52 <Yuras> Jefffrey: you can't install this app with ghc-7.4 without fixing it manually
04:04:55 <merijn> alpy: They should all have a license
04:05:22 <merijn> Jefffrey: base is hardwired into GHC it cannot be upgraded/replaced
04:05:41 <alpy> merijn okay, found the part with the license
04:06:07 <EvanR> hate it when the license says "you can't earn money."
04:06:12 <EvanR> those are the worst
04:06:53 <alpy> EvanR quick question, can i earn money with MIT license?
04:08:05 <EvanR> read it
04:08:34 <EvanR> read it* * not to be construed for legal advice
04:10:06 <EvanR> alpy: as far as i know none of the open source licenses in use on hackage stop you from "earning money", but your situation probably has all kinds of relevant details that factor into what somebody could sue you for theoretically
04:11:04 <Jefffrey> Yuras: Fixing it manually?
04:11:20 <EvanR> for example if you sell GPL programs, you simply have to produce the source code if requested (you can even charge shipping and handling!)
04:11:25 <Jefffrey> merijn: I see, then why do I have two versions of GHC and `base`?
04:11:52 <alpy> EvanR i am doing some small-time free-lancing. I might earn something like $500 . So i guess if there is problem it won't be mine.
04:13:22 <Yuras> Jefffrey: you can `cabal unpack` it and relax dependency bounds, then fix build errors if any
04:14:11 <merijn> Jefffrey: That question makes no sense to me, what you mean "why do I have two versions of GHC"?
04:15:00 <Yuras> Jefffrey: you have ghc-7.4.1 and base-4.5.0.0, that is OK
04:15:15 <Yuras> but it is not compatible with the app :)
04:15:26 <Jefffrey> Then I should update GHC?
04:15:33 <Yuras> yes
04:15:38 <Jefffrey> I thought 7.4.1 was the latest.
04:16:07 <merijn> 7.8 is the latest
04:16:14 <Jefffrey> Weird, if I do `apt-get upgrade ghc` it says it's all to the latest version.
04:16:15 <merijn> debian, as usual, is just way behind
04:16:30 <merijn> Jefffrey: That's because apt-get is slow and behind
04:16:46 <Jefffrey> Are there alternatives?
04:17:04 <Yuras> merijn: I'd say that ghc is too fast :)
04:17:27 <Yuras> Jefffrey: https://www.haskell.org/ghc/
04:17:47 <fr33domlover> Jefffrey, there's also a PPA
04:18:17 <fr33domlover> works for trisquel, should work for ubun7u and debian too I hope
04:19:58 <Jefffrey> Maybe it's just me not doing `apt-get update` first
04:20:07 <Jefffrey> Let me check
04:20:10 <hpc> distro package managers are extremely slow
04:20:19 <hpc> there's still distros that ship with perl 5.8
04:20:49 <Jefffrey> Yeah, not it's downloading a new GHC version
04:20:54 <Jefffrey> *npw
04:20:56 <Jefffrey> *now
04:21:58 <EvanR> näu
04:22:35 <Jefffrey> But somehow an upgrade to GHC also triggers and upgrade of postgres and libxml
04:22:36 <kaidelong> I'm just managing GHC using nix
04:23:11 <Jefffrey> and libruby wat
04:23:49 <Jefffrey> I'm terrible at this debian thing
04:24:53 <Jefffrey> GHC still 4.7.1
04:24:55 <Jefffrey> wat
04:25:40 <Qfwfq> You mean base right
04:27:30 <saep> Jefffrey: if you do not install any haskell packaegs from the debian archive, using GHC from unstable or experimental is usually no problem.
04:27:51 <Jefffrey> Qfwfq: Nope
04:28:17 <neuroserpens> Can anyone explain meh what this >>= thing is?
04:28:25 <saep> :t (>>=)
04:28:26 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:28:46 <neuroserpens> Nice. I didn't get it lol.
04:29:24 <quchen2_> It's one of the defining functions for a Monad.
04:29:29 <neuroserpens> It receives a monad a and a function that receives a and returns a monad b to finally return a monad b?
04:29:34 <neuroserpens> and what lol
04:30:00 <neuroserpens> wait wait
04:30:02 <neuroserpens> it's infix
04:30:05 <neuroserpens> AAAAAAAAAAAAAAAAAH
04:30:06 <neuroserpens> xD
04:30:33 <stool> neuroserpens, But you should find something that implements monad for it to make more sense initially.
04:30:33 * hackagebot wl-pprint-ansiterm 0.2.0.0 - ANSI Terminal support with wl-pprint-extras  http://hackage.haskell.org/package/wl-pprint-ansiterm-0.2.0.0 (seagull)
04:30:43 <hyPiRion> neuroserpens: oh, yeah. You can wrap () around infix symbols to use them as prefix
04:30:59 <stool> So take [] for example. The >>= for monad is concatMap since it fits the type. Does it make more sense now?
04:31:18 <neuroserpens> It's this line
04:31:19 <neuroserpens> getContents >>= mapM_ print. map solve. map (read::String->Double). tail. words
04:31:28 <neuroserpens> I just didn't see it as infix but now it makes sense
04:31:35 <hyPiRion> woo!
04:31:53 <stool> That looks odd. There should be spaces on both sides of .
04:31:53 <hpc> whoever wrote that line needs to put whitespace around (.)
04:31:58 <hpc> it's an operator, not punctuation
04:32:01 * neuroserpens goes get some breakfast
04:32:02 <neuroserpens> brb
04:32:06 <neuroserpens> NOT PUNCTUATION LMFAO
04:32:08 <merijn> hpc: Looks like a Coq programmer :p
04:32:12 * neuroserpens goes away laughing so hard
04:32:24 <EvanR> bring me some breakfast
04:32:27 <quchen2_> DATA DIVISION.
04:32:29 * quchen2_ runs
04:32:45 <EvanR> so hard
04:32:53 <hpc> NP hard
04:33:16 <Jefffrey> When do we get mixfix notation?
04:33:22 <Jefffrey> And dependent typing?
04:39:09 <merijn> As soon as someone donates their time to implement it
04:40:04 <quchen2_> I don't think dependent types are desirable in GHC.
04:40:17 <quchen2_> Elements maybe, but not the whole thing.
04:40:52 <Jefffrey> Elements?
04:41:04 <quchen2_> Aspects, parts, ...
04:41:28 <EvanR> why not
04:44:58 <quchen2_> The short answer is that there's Idris for that. Haskell was designed to be non-dependent, and has nice properties like (almost) decidable type inference, and the nice separation between the worlds of types and values.
04:45:30 <Procian> I like my laziness by default too.
04:45:34 <quchen2_> I don't think the lack of dependent types is a shortcoming of Haskell, it's simply not its purpose.
04:45:41 <Procian> (nothing to do with dependent types, but Idris dosen't have that)
04:45:43 <EvanR> i havent heard the separation being nice
04:45:48 <EvanR> described as nice
04:46:18 <EvanR> Procian: me too, yeah nothing to do with dependent types
04:46:53 <EvanR> DataKinds and friends, type literals, a big duplication of stuff at the type level
04:47:00 <EvanR> why is that nice
04:48:25 <ab9rf> reunite on ice
04:48:30 <quchen2_> Those are experiments to find out which extensions make sense to have in Haskell.
04:48:45 <quchen2_> But they're far from going all the way.
04:48:53 <EvanR> if anything it would be nice to be able to use those definitely terminating tools from the type level for values
04:49:24 <merijn> Procian: Yeah, I want lazy Idris :(
04:49:52 <ab9rf> but heimdall isn't lazy
04:50:34 * hackagebot dynamic-mvector 0.1.0.2 - A wrapper around MVector that enables pushing, popping and extending.  http://hackage.haskell.org/package/dynamic-mvector-0.1.0.2 (AndrasKovacs)
04:51:49 <EvanR> there might be a hack in idris for making everything lazy by default, not sure what the performance implications would be since it was designed to be strict
04:52:45 <EvanR> but theres no facility to introduce strictness like haskell
04:53:31 <EvanR> oh.. force
04:55:34 * hackagebot lucid-svg 0.4.0.3 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.4.0.3 (jeffreyrosenbluth)
05:12:38 <ski> neuroserpens : `mapM_ (print . solve . (read :: String -> Double)) . tail . words =<< getContents'
05:13:31 <gcganley> ski: are you sure you need that type sig on `read`?
05:13:52 <ski> dunno
05:13:57 <ski> depends on the type of `solve'
05:14:02 <gcganley> ski: yeah
05:14:25 <ski> being able to say `solve . (:: Double) . read' would be nice
05:14:49 <ski> where `(:: Double)' would be the identity on `Double'
05:14:49 <gcganley> ski: 7.10 i belive has type-sections
05:15:05 <quchen2_> I think someone worked on that, yes
05:20:49 <merijn> I'm pretty sure 7.10 doesn't have those
05:20:54 <merijn> But there was a proposal, yeah
05:35:36 * hackagebot casadi-bindings 2.2.0.6 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.2.0.6 (GregHorn)
05:35:38 <Jefffrey> Agda is also nice
05:36:16 <funfunctor> EvanR: did you make it to the morning yet ;)
05:36:22 <EvanR> yeah
05:37:37 <ab9rf> mnoo
05:40:28 <clrnd> jaspervdj, hey I just read your lru-cache article, really nice!
05:40:36 * hackagebot forbidden-fruit 0.1.0 - A library accelerates imperative style programming.  http://hackage.haskell.org/package/forbidden-fruit-0.1.0 (minpou)
05:41:13 <EvanR> hahaha
05:44:01 <lpaste> Exio4 pasted “type indexed list ” at http://lpaste.net/121086
05:44:18 <jophish> Is there a #haskell-social channel?
05:44:19 <exio4> is there any "equivalent" type family to show at the type level? k -> Symbol or * -> Symbol, I want to make the type errors a bit nicer in ^
05:44:24 <exio4> jophish: #haskell-blah ?
05:44:34 <jophish> thanks exio4
05:45:18 <exio4> line 78 in the paste is where I'd be using it, http://lpaste.net/121086#line78
05:48:26 <mpickering> exio4: What sort of errors do you usually get?
05:48:35 <mpickering> *currently
05:50:15 <exio4> mpickering: I want to replace the line "Elem (L  '[]     ) x = "Error: type indexed list doesn't contain any element of type " ~ x" (which doesn't pass the typechecker, but replacing x with "" does), to a failed-constraint that shows any kind of information about the missing element
05:50:27 <mpickering> right I see
05:50:37 * hackagebot yeller 0.1.0.4 - A Yeller Client For Haskell  http://hackage.haskell.org/package/yeller-0.1.0.4 (TomCrayford)
05:51:59 <mpickering> change the kind of "e" to "k" from "*" and it compiles
05:54:40 <neuroserpens> ski: thanks a lot for the input
05:54:46 <neuroserpens> ski: it clarified much
05:54:59 <neuroserpens> ski: I think the guys who make these questions on hacker rank are screwed up on the head lol
05:55:19 <neuroserpens> EvanR: I ate all the breakfast. YOU GET NOTHING!
05:55:21 <neuroserpens> EvanR: GOOD DAY SIR
05:56:22 <EvanR> i do believe my idea for using rationals to get exact precision on this problem results in exponentially big denominators
05:56:37 <EvanR> which is linear in the length of the numbers written out
05:56:47 <EvanR> i dont know if thats means impossible or not
05:57:32 <exio4> mpickering: the error (try getType test :: Bool) doesn't seem that good though :/
05:59:21 <EvanR> > 43859663442272396933456838738500320 % 438596634422723969334568387385003201 + 43859663442272396933456838738500320 % 43859663442272396933456838738500322
05:59:22 <lambdabot>  10580185424981731696566956084234272570766132700452769660859992628313680 % 96...
05:59:38 <EvanR> snappy
06:02:43 <mpickering> exio4: I suspect merijn will have a better answer
06:05:23 <exio4> mpickering: heh, probably! :P
06:06:55 <bartavelle> is there some kind of "templating" library that would accept user supplied text, parse it, and have the following features when evaluating : variable interpolation, basic expressions, switch/case like constructs, loops ?
06:07:42 <bartavelle> it looks like I need something like that, and I am maybe *too* keen on solving yet another time consuming meta-problem ...
06:08:54 <bartavelle> humm this looks ok https://github.com/sourrust/karver
06:13:27 <mpickering> exio4: So if you use another symbol then that works
06:15:17 <bartavelle> actually it's not cutting it, I don't think what I am looking for can be written in a satisfying way generically
06:16:56 <merijn> exio4: There's no real way to get nicer error messages than simply failing equality on static Symbol's atm
06:18:03 <merijn> exio4: Solution: Start learning Idris ;)
06:19:27 <funfunctor> oh man, I am still super confused as to how to marshell around values between actions using IORef
06:19:39 <exio4> merijn: but but! :P
06:21:06 <exio4> merijn: will leave it without nice error messages for now, I guess
06:21:31 <merijn> exio4: Seriously, though, this stuff is MUCH nicer in Idris, since it's all first-class instead of hacky extensions like in Haskell :p
06:22:08 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121087
06:22:17 <funfunctor> EvanR: ^ checkout all the global state
06:23:24 <exio4> merijn: I know! I actually wanted this stuff because my actual hack with nested-tuples started backfiring :P
06:25:39 * hackagebot monad-logger 0.3.13 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.13 (MichaelSnoyman)
06:32:53 <sebastard> Can I use the createSystemRandom function from System.Random.MWC? The function appears to be in my library, but it's not listed on hackage.
06:33:46 <mauke\> http://hackage.haskell.org/package/mwc-random-0.13.3.0/docs/System-Random-MWC.html#v:createSystemRandom this one?
06:34:22 <sebastard> hmm yes that's the one...
06:34:33 <sebastard> ah I see, I was looking at an old version on hackage :/
06:35:31 <mauke\> I went to http://hayoo.fh-wedel.de/?query=createSystemRandom
06:38:32 <sebastard> thanks, i'll remember that one :) is it generally better than https://www.haskell.org/hoogle/ (which couldn't find createSystemRandom)?
06:38:57 <mauke\> it indexes more libraries by default
06:39:02 <merijn> sebastard: It's not better, but it indexes more
06:39:06 <mauke\> I don't know if it does type-based search
06:39:17 <merijn> Although Neil appears to be working on a new Hoogle that will index more (all?) of hackage
06:39:36 <mauke\> the hoogle instance on haskell.org only searches a very small subset of libraries by default
06:39:46 <mauke\> so you have to tell it which packages to search, which makes it useless
06:40:45 <merijn> You can also install a local hoogle
06:41:03 <mauke\> like a savage?
06:44:37 <hannes__> mauke\: What's there not to like about local hoogle?
06:45:04 <voidzero> savage? wtf
06:55:49 <mauke\> hannes__: hard to use; no documentation
06:56:03 <kvelicka> quick question - for an executable built with cabal, how would I specify the runtime options in the command line? I remember doing it previously but can't remember the exact command
06:58:20 <hexagoxel> kvelicka: depending on two interpretations of the question, either `./prog +RTS -H2G` or `cabal run -- --thisisaflag`
06:58:56 <kvelicka> so say if I want to do `./prog -v` I'd do `cabal run --v`?
06:59:03 <xkb> hi
06:59:05 <xkb> any clue on how to solve this: setup-Simple-Cabal-1.18.1.5-x86_64-osx-ghc-7.8.4: dist/package.conf.inplace:
06:59:14 <xkb> got it on cabal install in a thrift package
06:59:17 <hexagoxel> kvelicka: `cabal run -- -v`
06:59:26 <xkb> seems to be caused by 2 cabal versions
06:59:34 <bergmark> xkb: yeah, you can just rm the inplace files
06:59:34 <kvelicka> hexagoxel: thank you!
06:59:52 <xkb> the dist ones?
06:59:57 <bergmark> xkb: right
07:01:33 <Unhammer> let (b,m,a) = "-AŊA-" =~ "-\\w+-" :: (String,String,String) in putStrLn m
07:01:34 <Unhammer> -AŊA-
07:01:48 <Unhammer> let (b,m,a) = "-AÁA-" =~ "-\\w+-" :: (String,String,String) in putStrLn m
07:01:48 <Unhammer>  
07:01:48 <Unhammer>  
07:02:11 <Unhammer> haskell only matches the very strange unicode letters?
07:02:37 <mauke\> what's length "-AÁA-" in your code?
07:02:42 <Unhammer> I can do (á|\\w), but not [á] …
07:02:53 <Unhammer> 5
07:03:01 <mauke\> ok, that's weird
07:03:01 <Clint> which regex library?
07:03:09 <Unhammer> same as "-AŊA-"
07:03:17 <Unhammer> import Text.Regex.Posix ((=~))
07:04:03 <merijn> I don't trust regex libraries + unicode
07:04:03 <mauke\> posix?!
07:04:13 <tdammers> hmm, if it FFI-wraps around a C regex lib, I imagine character encoding can go wrong
07:04:20 <merijn> And definitely not any regex library labeled posix + unicode
07:04:41 <Clint> i'm surprised \w works at all with that
07:04:44 <Unhammer> heh ok
07:04:51 <mauke\> Unhammer: "Note that the posix library works with single byte characters, and does not understand Unicode. If you need Unicode support you will have to use a different backend. "
07:05:03 <Clint> Unhammer: you might want something with pcre in the name
07:05:03 <Unhammer> fair enough
07:05:27 <mauke\> Ŋ truncates to to J
07:05:32 <mauke\> which is probably why it matches as a letter
07:05:45 <Unhammer> truncates as in the first bytes "are" J?
07:05:54 <Unhammer> that's kinda funny :)
07:06:29 <mauke\> > chr (ord 'Ŋ' .&. 0xff)
07:06:29 <Clint> UTF-8: c5 8a  UTF-16BE: 014a
07:06:31 <lambdabot>  'J'
07:07:13 <mauke\> Ŋ is U+14A, J is U+4A
07:07:44 <mauke\> I'm pretty sure the library stores each character as a byte via mod 256
07:07:59 <tdammers> also explains why (á|\\w) works but [á] doesn't
07:08:09 <tdammers> ("works")
07:08:48 <tdammers> well, it would explain things if unicode strings were serialized as utf-8 but processed as 8-bit with undefined codepage
07:09:20 <tdammers> á would match two literal bytes, but [á] would match either of the bytes, but only one occurrence
07:20:42 * hackagebot union-map 0.1 - Heterogeneous map by open unions.  http://hackage.haskell.org/package/union-map-0.1 (minpou)
07:29:13 <nshepperd>  /url 1
07:32:16 <phaazon> hi
07:32:28 <phaazon> is there a tool to manually upload documentation on hackage for windows?
07:33:18 <YaRly> how do I show a URI (Network.URI) in an informative way? (I want to see all its fields basically)
07:38:25 <funfunctor> YaRly: are you looking for show?
07:38:27 <funfunctor> :t show
07:38:28 <lambdabot> Show a => a -> String
07:39:20 <YaRly> funfunctor: Yes but is there a way to get it to "explode" everything and show "uriScheme = http", "uriBlabla = something" etc.?
07:39:27 <mauke\> gshow
07:39:30 <mauke\> http://hackage.haskell.org/package/syb-0.4.4/docs/Data-Generics-Text.html#v:gshow
07:39:35 <mauke\> at least that's what I'd try
07:40:42 <YaRly> mauke\: Thanks! :)
07:42:07 <mauke\> (tell me if it works and what it prints)
07:42:09 <sebastard> is there a way to generate an infinite list of random Booleans with System.Random.MWC? Like uniformVector but then inifinite?
07:43:49 <YaRly> mauke\: for a uri (http://www.foo.com/contact/?idiot=3#top) it returns (URI \"http:\" (Just (URIAuth \"\" \"www.foo.com\" \"\")) \"/contact\" \"?idiot=3\" \"#top\")
07:44:12 <YaRly> it's split up correctly and all, according to the datatype
07:44:30 <mauke\> where did the additional \ come from?
07:44:36 <mauke\> did you 'print' it?
07:45:47 <YaRly> oh...I guess the escapes are because it tries showing all the "subshows" which all have quotation marks in them
07:46:15 <YaRly> if that makes sense...
07:57:03 <mmachenry> How do people feel about the acceptance of Foldable/Traversable Proposal?
07:57:30 <merijn> mmachenry: Isn't that answer obvious in the at least 82% people in favour?
07:58:05 <mmachenry> merijn: Yes. I was hoping for less sarcastic and more in depth conversation though.
07:58:57 <merijn> That wasn't sarcastic, I just don't think there's a lot of in-depth conversation to have that hasn't been had for the past 2 months and before that during the initial proposal
07:59:46 <clrnd> I prefered the "burning bridges" name a lot more
08:00:37 <mmachenry> merijn: Fine. Sorry I brought it up.
08:01:47 <ab9rf> whee!
08:04:13 <chreekat> mmachenry: I feel great about it
08:04:25 <hannes__> mmachenry: What sort of discussion were you looking for other than 'people are mostly in favor?'
08:04:27 <hexagoxel> mmachenry: (there are a few comments on the reddits)
08:06:22 <mmachenry> hannes__: There are lots of implications and possibly different for different people. Make code easier to write. Avoid problems with a library you might be the maintainer of having name conflicts. Maybe you think it'll be easier or harder to teach your friends Haskell now.
08:06:29 <hannes__> The most controversial thing (read: The thing that bugs me a little) was adding min, null etc to Foldable, even if it makes some manner of sense
08:06:41 <mmachenry> I don't know too much about it. I guess I'll just go read Google.
08:07:21 <hannes__> mmachenry: People mostly agree that it might be a bit more difficult for beginners, but that can be easily avoided by just giving them an alternate prelude that has the list specialized versions only
08:08:35 <hannes__> mmachenry: And it makes code easier to write in the sense that you don't have to hide stuff from prelude all the time to get the general versions
08:09:50 <ski> neuroserpens : which questions ?
08:10:45 * hackagebot blaze-svg 0.3.4.1 - SVG combinator library  http://hackage.haskell.org/package/blaze-svg-0.3.4.1 (BrentYorgey)
08:11:40 <merijn> hannes__: Are you sure people mostly agree?
08:11:59 <merijn> hannes__: The number of beginners that get confused by the existence of multiple different mapM's seems much bigger
08:12:23 <merijn> Plus "Why is the generalised version of mapM_ in Data.Foldable, but mapM is in Data.Traversable?!"
08:12:59 <YaRly> is a purely functional hashtable in Haskell very slow? (I'm not trying to break a record, it's just a small project that I want to be as pure as possible)
08:13:39 <merijn> YaRly: It's basically orderd_map in C++, so no it's not very slow
08:13:47 <ChristianS> YaRly: use Data.Map.Strict, it's purely functional and pretty fast.
08:14:01 <dfeuer> YaRly, a "purely functional hash table" is pretty much a trie with a hash function glued on the front.
08:14:44 <dfeuer> Data.Map.Strict only makes sense if you want the container strict in the values, as opposed to just the keys.
08:15:04 <merijn> Yeah, Data.Map is plenty fast for normal use
08:15:06 <dfeuer> That's really only a sometimes thing. Sometimes it will make code faster; sometimes slower.
08:15:17 <merijn> I wouldn't worry about it until profiling/inner loop optimisation
08:15:20 <dfeuer> For some things, Data.IntMap is the way to go.
08:15:38 <dfeuer> And a HashMap is just an IntMap with a hash function and whatever.
08:15:57 <YaRly> dfeuer: So it's like a binary tree or something?
08:16:04 <dfeuer> IntMap can also be used very easily for typical FiniteBits instances.
08:16:07 <mauke\> yes, Data.Map is not a hashtable
08:16:14 <merijn> YaRly: Data.Map is a highly optimised ordered tree, yes
08:16:45 <dfeuer> Data.IntMap is a brutally optimized trie.
08:16:49 <YaRly> Ok, what does it mean when a container is strict?
08:16:54 <dfeuer> Well,
08:16:57 <dfeuer> it means
08:17:12 <YaRly> does it mean you can't have duplicate values?
08:17:17 <dfeuer> that when you put things into the container, they are automatically forced to "weak head normal form".
08:17:55 <dfeuer> Confusingly, the strict and lazy versions of Map and some other things are all *actually* lazy,
08:18:08 <dfeuer> but the modules offer strict functions for manipulating them.
08:18:31 <YaRly> dfeuer: I'm a bit confused...I want to save a n-tuple with html documents and some other information as values, and have strings as keys. The keys will be unique. Should I use Data.Map.Strict?
08:19:12 <dfeuer> YaRly, it ... depends.
08:19:13 <hannes__> YaRly: Try both and see if it makes a difference?
08:19:28 <YaRly> ok, I'll try this tomorrow and see...
08:19:38 <dfeuer> YaRly, the map is always strict in its keys
08:19:40 <merijn> I think everyone is over analyzing this and making things more complicated than they need to be
08:19:45 <merijn> Strictness, etc.
08:19:46 <dfeuer> but may or may not be strict in its values.
08:19:50 <dfeuer> Yeah.
08:19:52 <ChristianS> YaRly: if you're sure that you'll use all the values, i'd go with Data.Map.Strict. otherwise you can use Data.Map, then those values that you don't need will never be evaluated.
08:19:58 <merijn> The correct answer for YaRly is: Use Data.Map and don't worry
08:20:01 <dfeuer> YaRly, start with Data.Map.
08:20:03 <dfeuer> But
08:20:03 <YaRly> alright, I'll just use Data.Map then :D
08:20:07 <dfeuer> On the other hand
08:20:12 <dfeuer> if the keys are very *long* strings,
08:20:15 <merijn> Ignore all this talk about strictness until you notice any speed problems
08:20:19 <dfeuer> you might want to use a trie instead.
08:20:24 <mauke\> it's a tuple. Data.Map.String won't do anything anyway
08:20:26 <dfeuer> Or a HashMap.
08:20:35 <mauke\> er
08:20:36 <mauke\> Strict
08:20:45 <dfeuer> Yaeh.
08:21:01 <dfeuer> Strictness not interesting here;
08:21:04 <ChristianS> YaRly: personally i always use Data.Map.Strict but you'll probably be just as fine with Data.Map. mostly a matter of taste.
08:21:23 <dfeuer> more interesting is Map vs. HashMap vs. some sort of trie using the string structure.
08:22:12 <mauke\> :t lookup
08:22:13 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
08:22:47 <hannes__> > import qualified Data.Foldable as F
08:22:48 <lambdabot>  <hint>:1:1: parse error on input ‘import’
08:22:53 <hannes__> aww
08:22:54 <ChristianS> well, Data.HashMap *is* slower than Data.Map in those cases where i compared them. even though Data.Map is sorted.
08:23:16 <mauke\> :t F.foldr
08:23:17 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:23:18 <dfeuer> ChristianS, it's mostly going to depend on what sort of key you have, no?
08:23:27 <dfeuer> And how you use it maybe?
08:23:34 <dfeuer> :t M.lookup
08:23:35 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
08:23:36 <hannes__> ChristianS: Why 'even though'? If it wasn't sorted you wouldn't get fast lookup
08:23:45 <dfeuer> That's the right lookup.
08:24:03 <mauke\> no, it's not
08:24:06 <ChristianS> dfeuer: possible. i usually have Text keys.
08:24:08 <hannes__> dfeuer: Depends on what kind of lookup we're talking about
08:24:28 <dfeuer> hannes__, oh, I thought we were talking about looking things up in maps.
08:24:46 <mauke\> [(a, b)] is a map
08:24:56 <funfunctor> what is the 'usual' way to think in order to translate highly stateful C++ OOP code to stateless as possible Haskell?
08:25:08 <funfunctor> I know that is a very general question
08:25:11 <dfeuer> funfunctor, start at the beginning?
08:25:14 <exio4> throw the code and start from scratch sounds the like the easier approach to this
08:25:22 <hannes__> mauke\: We had a discussion like this with sets the other day. Warn in advance, I'm going to disagree
08:25:40 <clrnd> funfunctor, it depends, maybe it's a particular algorythm and you want to translate it literally and maybe use STRefs
08:25:46 <saep> funfunctor: Write FFI bindings. :D
08:25:58 <funfunctor> dfeuer: yea I am but I am trying to work out how to rewrite something that /seems/ stateful to me
08:26:13 <dfeuer> funfunctor, well, you can use State or StateT then.
08:26:23 <funfunctor> no, I know that
08:26:35 <hannes__> I think the question is if it needs all that state to begin with
08:26:41 <funfunctor> but we end up with lift's everywhere and a horrible transformer pattern
08:26:58 <hannes__> and there's no algorithmic way to determine that, if it was nobody would pay programmers for anything anymore
08:27:00 <funfunctor> hannes__: correct! that is my question
08:27:02 <dfeuer> funfunctor, I don't think you're going to find a good general answer.
08:27:51 <dfeuer> clrnd, STRefs are evil, I'm now convinced, except for some fairly special purposes.
08:27:55 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/121078
08:28:12 <funfunctor> sorry wrong paste
08:28:22 <megamac> could anybody tell me please why the first works, but the second doesnt and how to remove the parameter to a curried function:
08:28:22 <megamac> revSuc :: Ord b => [b] -> [b]
08:28:22 <megamac> revSuc xs = map snd $ sort $ zip [0,-1..] xs
08:28:22 <megamac> revErr = map snd $ sort $ zip [0,-1..]
08:28:24 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/121078
08:28:27 <dfeuer> clrnd, well, I guess they're not themselves evil, but their implementation is insufficienly good to make them non-evil.
08:28:39 <funfunctor> thats better
08:28:41 <dfeuer> RONG PAIST.
08:29:14 <clrnd> dfeuer, hmmm, what kind of problems did you encounter?
08:29:25 <hannes__> megamac: have you tried to write the types of each sub expression down on paper?
08:29:31 <mauke\> megamac: sort $ zip [0,-1..] means sort (zip [0,-1..])
08:29:33 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121092
08:29:44 <funfunctor> you can observe all the statefullness here
08:29:50 <megamac> http://lpaste.net/121093
08:29:51 <mauke\> megamac: sort takes a list. zip [0,-1..] is not a list.
08:29:51 <hannes__> megamac: i.e. ($) :: (a -> b) -> a -> b
08:29:53 <dfeuer> clrnd, the basic problem is that they hold boxed values, and GHC's optimizer doesn't even try to unbox them.
08:30:29 <clrnd> dfeuer, mmm interesting, there must be an alternative for unboxed values ...
08:30:31 <funfunctor> i'm most interested in how to unstate'ify http://lpaste.net/121092#line99
08:30:49 <hesiod> Can GHC evaluate non-trivial constants (i.e. functions applied to literals) at compile-time?
08:30:55 <funfunctor> rather than having these timestamps as globals
08:31:15 <dfeuer> clrnd, there is, but then you have to do it by hand, and I don't know how fast it ends up.
08:31:20 <hannes__> bytesex huh? kinky.
08:31:37 <merijn> hesiod: Not really
08:31:49 <mauke\> hesiod: probably, but I wouldn't be surprised if it doesn't
08:31:52 <dfeuer> clrnd, basically, you can use one  form or another of mutable array/byte array/whatever to hold a single unboxed thingum...
08:31:59 <hannes__> merijn: Isn't the answer 'sometimes maybe'?
08:32:13 <dfeuer> clrnd, there are libraries for that, but the technique strikes me as ugly.
08:32:25 <merijn> hannes__: For values of "sometimes" that are sufficiently indistinguishable from no
08:32:44 <hesiod> so, is there some TH voodoo or similar to actually do that?
08:32:50 <hesiod> *something similar
08:32:52 <merijn> hesiod: You can do this yourself using Template Haskell, but the lack of Lift instances makes it a bit inconvenient
08:32:53 <dfeuer> funfunctor, I observe nothing in that code except a ton of boilerplate declarations. What am I missing?
08:33:03 <mauke\> if I had ghc here, I'd check what core/code ghc generates for foo c = chr (ord c - ord 'A')
08:33:13 <clrnd> dfeuer, I understand, though it never came up when I used them as a problem, I see how it can complicate things unnecessarily
08:33:24 <merijn> hesiod: It's pretty trivial to do in TH, the only problem is that you require Lift instance to effectively output the result and only like 8 datatypes have those
08:33:43 <merijn> hesiod: On the other hand, there's a TH library for automatically deriving Lift instances, so... :)
08:33:49 <funfunctor> dfeuer: http://lpaste.net/121092#line99 is the class definition, http://lpaste.net/121078 is the implementation
08:34:15 <dfeuer> clrnd, note that when you have a choice, it will typically be faster to use StateT p (ST s) a  than to use ST s with an STRef of type p.
08:34:24 <hesiod> merijn: you mean th-lift?
08:34:32 <dfeuer> This is something GHC should be able to fix itself, I think.
08:34:37 <merijn> hesiod: Yeah
08:35:42 <clrnd> dfeuer, interesting, thanks for the detailed explanation :)
08:35:48 * hackagebot yesod-bin 1.4.3.9 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.9 (MichaelSnoyman)
08:36:05 <dfeuer> funfunctor, what am I supposed to be looking at? This looks like code for some kind of radio driver or something.
08:36:27 <funfunctor> dfeuer: yea thats correct
08:37:07 <funfunctor> dfeuer: essentially this is the RadioDevice type that sits under another type called RadioInterface
08:37:51 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121095
08:37:51 <dfeuer> funfunctor, a lot of this is inherently IO state, no?
08:37:58 <funfunctor> dfeuer: ^ thats my haskell implementation
08:38:15 <funfunctor> incomplete one
08:38:54 <funfunctor> dfeuer: EvenR advised to use IORef
08:39:06 <funfunctor> rather than a huge StateT I had before
08:39:18 <dfeuer> IORef is just as bad as STRef.
08:39:35 <funfunctor> I rather not be so OOP
08:39:52 <dfeuer> funfunctor, you may want to look at http://www.stackage.org/package/mutable-containers
08:40:08 <dfeuer> That offers the unboxed mutable variables I mentioned
08:40:41 <dfeuer> funfunctor, you don't have to be OOP about it, but if you have to track hardware state, you will have a very procedural sort of layer at the bottom.
08:40:48 * hackagebot persistent 2.1.1.5 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.1.5 (MichaelSnoyman)
08:40:48 <dfeuer> Ain't nothing to be done about that.
08:42:53 <funfunctor> dfeuer: thats why I was using StateT before but EvanR convinced me monad transformers are a bit yucky and he didn't think I needed state here
08:45:29 <hannes__> funfunctor: Well, low level stuff has a tendency to contain some manner of yuckiness.
08:45:49 * hackagebot yesod-auth 1.4.3.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.3.1 (MichaelSnoyman)
08:45:51 * hackagebot wai-extra 3.0.4.4 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.4.4 (MichaelSnoyman)
08:45:51 <funfunctor> hannes__: exactly
08:45:53 * hackagebot threads-supervisor 1.0.2.0 - Simple, IO-based library for Erlang-style thread supervision  http://hackage.haskell.org/package/threads-supervisor-1.0.2.0 (AlfredoDiNapoli)
08:46:22 <funfunctor> hannes__: but I am unclear exactly how much of it I really should have
08:46:27 <mada> what's yucky about monad transformers?
08:46:43 <funfunctor> they are awkward to work with
08:46:58 <funfunctor> you end up with needing to lift everywhere and so on
08:47:00 <dfeuer> funfunctor, yeah, I think it's ugly to bring that into your code; I wish GHC could figure that out by itself, but using Data.Mutable.URef or .PRef is probably better than using IORef when you have a choice.
08:47:47 <mada> funfunctor: and how do you replace their use?
08:47:54 <dfeuer> funfunctor, I know mtl has some magic to help avoid manual lifting, but it's all a little shady.
08:48:30 <ski> dfeuer : which package is that ?
08:48:35 <funfunctor> dfeuer: I guess my question is, if you were going to implement http://lpaste.net/121078 how abouts would you go to reduce so much state?
08:48:40 <dfeuer> ski, mutable-containers
08:49:04 <dfeuer> funfunctor, how much of that state is actually the state of the device?
08:49:20 <funfunctor> dfeuer: well I thought EvanR advice to stay down in the IO monad is a good idea
08:49:44 <funfunctor> because then I avoid monadic type parameters in the RadioDevice type
08:50:07 <funfunctor> dfeuer: not much I guess
08:50:29 <dfeuer> funfunctor, what I was thinking was that GHC *should* be able to identify non-escaping STRefs and turn all the \State# s -> (# State# s, a #) things into \(# State# s, more, variables #)-> (# State# s, more, variables, a #)
08:50:35 <kallisti> honestly this looks like a perfect case for using StateT with IO
08:50:44 <funfunctor> dfeuer: isSuperSpeed is constant, we ask the device if its USB3 or not and set that to true or false
08:51:32 <kallisti> yes, using monad transformers requires lifting operations, however in the vast majority of scenarios you should be able to centralize lift calls into a fairly small API
08:51:54 <ski> dfeuer : sounds like a fine-grained effect system
08:52:13 <dfeuer> ski, I have no idea what that even means.
08:52:20 <funfunctor> kallisti: I practice I don't think it works out so nicely here
08:52:54 <funfunctor> this C++ code has way too much global state, highly OO
08:53:25 <funfunctor> I don't think a direct copy-paste into a StateT is the way to do this
08:53:32 <dfeuer> funfunctor, okay, so there's a lot of state. What are the different kinds of state it deals with?
08:53:39 <dfeuer> ski, but if you explain, I will be happy to listen.
08:54:09 <kallisti> funfunctor: if I understand correct, you're seeking to emulate the behavior of this code, and not wanting to use FFI to talk with it?
08:54:18 <kallisti> just making sure I'm on the same page
08:55:07 <funfunctor> kallisti: i'm merely using the C++ code as a reference on "how to do the thing.." and avoid anything else
08:55:14 <kallisti> right
08:56:03 <funfunctor> dfeuer: isSuperSpeed,   TIMESTAMP rxTimestamp;   TIMESTAMP txTimestamp;   TIMESTAMP rxResyncCandidate; all seem like global states that perhaps don't need to be?
08:56:46 <funfunctor> kallisti: crossing the paradigms is not so clear cut in this case
08:57:17 <funfunctor> kallisti: the general abstraction model comes from the specification also, so its something I should follow more or less
08:57:53 <funfunctor> kallisti: so essentially I end up with, write this C++ in Haskell but don't write OO :p
08:57:59 <ski> dfeuer : a system that statically can keep track of which mutable cells are read, written, respectively created by which effectful operations
08:58:33 <joobus> noob here, trying to use isPrefixOf.  I don't know why this doesn't work: Data.Text.isPrefixOf "asdf" "asdf qwer"
08:58:50 <mauke\> joobus: how does it fail?
08:58:52 <joobus> i see the error message about "asdf" being [char] but I don't know how to make it text
08:59:01 <mauke\> what is the error message?
08:59:07 <joobus> Couldn't match expected type ‘Text’ with actual type ‘[Char]’ In the second argument of ‘isPrefixOf’, namely ‘"asdf qwer"’
08:59:16 <mauke\> ah
08:59:27 <mauke\> you can convert with Data.Text.pack
08:59:48 <mauke\> or you can enable OverloadedStrings
09:00:10 <dfeuer> ski, yeah, something like that. I don't think it would have to be terribly powerful in order to be useful. And carter has mentioned that this technology is used in things like C compilers.
09:00:21 <joobus> mauke\: thank you
09:00:49 * hackagebot persistent 2.1.1.6 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.1.6 (MichaelSnoyman)
09:00:58 <kallisti> funfunctor: for low-level device control, the "handle" model works fairly well. It seems here that you want your code to work on an opaque type with open/close operations, withBladeRFDevice, etc.
09:01:32 <kallisti> funfunctor: that's the usual model for libraries that operate on low-level "resources"
09:01:38 <funfunctor> kallisti: do you want to see my code before I ripped out StateT?
09:01:50 <dfeuer> ski, the point is that if an STRef/IORef is "removable", then it should be removed to expose it to the rest of the simplifier.
09:01:53 <kallisti> funfunctor: sure
09:02:12 <hodapp> Is it common to make a typeclass whose only function is to combine together N other typeclasses so that functions which rely on all of them together, along with instances of all of them, don't have to keep quoting all N at once in the type signatures and 'deriving' lines?
09:02:30 <kallisti> funfunctor: what is the name of the spec btw so I can understand more about what I'm looking at
09:02:41 <kallisti> or where can I find it
09:02:48 <funfunctor> kallisti: https://github.com/victoredwardocallaghan/hbts/commit/4fc1e09c3a07864c80182d90cd576119e0484b91
09:02:58 <dfeuer> hodapp, it's sometimes done.
09:03:17 <hodapp> dfeuer: it's not a massive anti-pattern or anything?
09:03:24 <funfunctor> kallisti: the spec is some 1,000 pdf's varying from 600-1200 pages long'ish
09:03:29 <funfunctor> kallisti: GSM
09:03:36 <ski> dfeuer : hm, i assume by "removable" you mean that the implementation can statically figure out the extent of it
09:03:41 <hodapp> I just sort of wince when I look at: forall x y . (Show x, Enum x, Bounded x, Typeable x, IvoryIntegral y) => Proxy x -> Def ('[y] :-> IString)
09:03:52 <dfeuer> ski, yes.
09:04:10 <kallisti> funfunctor: first thing I notice is that you have functions stored directly in the record, which is almost never the correct approach.
09:04:20 <kallisti> funfunctor: can each RadioDevice have widely varying implementations of those functions?
09:04:20 <ski> dfeuer : it's probably interesting to compare with region-based memory management here
09:04:49 <dfeuer> ski, region inference goes *way* over my head, but I think I see where you're heading, maybe?
09:05:07 <funfunctor> kallisti: yes
09:05:50 * hackagebot on-demand-ssh-tunnel 0.1.0.6 - Program that sends traffic through SSH tunnels on-demand  http://hackage.haskell.org/package/on-demand-ssh-tunnel-0.1.0.6 (pedja)
09:05:57 <funfunctor> kallisti: this https://github.com/victoredwardocallaghan/hbts/blob/master/src/BTS/RadioDevice.hs is our intended device common interface
09:06:14 <kallisti> funfunctor: why not use a typeclass?
09:06:18 <dfeuer> ski, another option might be "just" to extend the unboxing stuff to STRefs and IORefs. I suspect the issues will be similar.
09:06:53 <funfunctor> kallisti: thats what I was originally thinking about when thinking about dynamic dispatch
09:07:47 <hannes__> ohh just saw the new vinyl... and I _think_ I like it. Or maybe not. I'm not entirely sure. But it looks cool anyway
09:07:50 <funfunctor> kallisti: but extensional/typeclass dynamic dispatch is less flexiable than just a typed interface
09:08:53 <funfunctor> kallisti: here we just have one type rather than a different type and type instance for each radiodevice
09:09:26 <funfunctor> kallisti: any way, thats not my problem.. my problem is the huge statefully inside RadioDevice
09:10:47 <kallisti> funfunctor: more flexible in the sense that you can swap out functions at runtime, but I don't know that you actually need that flexibility. But I suppose it's not relevant to your question.
09:10:52 <funfunctor> kallisti: I would like RadioDevice just to be IO () rather than some more complex monad that gets lifted into a even more complex monad and then we find ourselves in hell
09:11:00 <hsk5> This was written in 2008: http://lambda-diode.com/programming/monads-are-a-class-of-hard-drugs
09:11:04 <hsk5> Does this still apply?
09:11:13 <hsk5> What are your thoughts on this?
09:11:30 <hodapp> hrmm, if all the constraints on my typeclass are themselves derivable typeclasses, how can I make this typeclass derivable?
09:11:37 <kallisti> funfunctor: sure, that's makes sense here. You only really want StateT when you have a single implicit state that you're working with.
09:11:52 <kallisti> funfunctor: for a "device" model you usually have more than one device and so swapping out between different devices in the state monad becomes clunky
09:11:55 <clrnd> 'Haskell programs, unless written very carefully, do get quite slow. ' meh
09:12:06 <hodapp> 'get' quite slow?
09:12:24 <hsk5> I'm more interested in what he says about the monad stuff, Haskell vs Ocaml
09:12:36 <hsk5> not quite sure what to think..
09:13:01 <clrnd> I'm getting there
09:13:19 <funfunctor> hsk5: lame.. saying "very slow" multiple times does not make the point more true or whatever
09:13:22 <ReinH> hsk5: I'm not sure it ever applied.
09:13:38 <ReinH> hsk5: Some criticisms are valid but overblown, some things are just wrong.
09:13:46 <hodapp> do I have to somehow wrap this in a newtype to make it derivable?
09:13:59 <ReinH> "The essence of monads is to use abstract types to enclose a mutable state" Nope.
09:14:08 <clrnd> 'the type constructors of the monad start to appear in the signatures of your function' not because typeclasses?
09:14:09 <ReinH> Not even close.
09:14:36 <kallisti> funfunctor: hm, so you expose a bunch of read functions for IORefs, but how do those IORefs become modified?
09:14:56 <kallisti> getSampleRate for example
09:15:00 <kallisti> in BladeRFDevice
09:15:21 <ReinH> The analogy with drugs is just ridiculous.
09:15:28 <funfunctor> kallisti: the IORefs in my paste don't do anything yet.. I just started playing with IORefs when I was adviced they would somehow solve my problem
09:15:40 <funfunctor> I suspect I am not seeing how yet though..
09:15:43 <hodapp> what are you guys reading?
09:15:50 * hackagebot mp 0.2.1 - Music player for linux.  http://hackage.haskell.org/package/mp-0.2.1 (piotrborek)
09:15:59 <kallisti> funfunctor: oh..
09:16:16 <clrnd> hsk5, as far as my knowledge gets, this is nonsense, I don't know ocaml nor the state of ghc/haskell in 2008, but none of the things he claims are true for today's haskell
09:16:45 <hsk5> What about the stuff he says about combining monads?
09:16:57 <exio4> hodapp: http://lambda-diode.com/programming/monads-are-a-class-of-hard-drugs
09:17:10 <kallisti> funfunctor: just so I understand better, what would be the issue with storing sample rates directly in the record?
09:17:27 <ReinH> hsk5: He doesn't say anything meaningful about combining moonads.
09:17:29 <funfunctor> hsk5: learn haskell/ use haskell and work out claims for yourself.. ignore blogs for the most part, people like to rant shit about every topic out there
09:17:59 <clrnd> hsk5, you don't combine them, you stack them using monad transformers, which are quite modular and nice to use
09:18:05 <clrnd> and there are other ways too
09:18:08 <hsk5> ok
09:18:15 <ReinH> hsk5: There are good criticisms of monad transformers. He doesn't deploy any of them. Probably because he doesn't know what he's talking about.
09:18:22 <hsk5> Hehe ok
09:18:23 <clrnd> and that ^
09:18:24 <funfunctor> kallisti: well timestamps are the ones I guess that are most important to work out first
09:18:47 <geekosaur> this sounds like someone who doesn't understand haskell is trying to critique it by the rules of something they do understand
09:18:54 <kallisti> funfunctor: have you thought working with IORef RadioDevice and working with immutable values within the record itself?
09:18:58 <clrnd> is there something like idris' effects for hskell btw?
09:19:05 <joobus> is it safe to say the lambda-diode blog guy doesn't know what he's talking about?
09:19:08 <ReinH> geekosaur: And replacing actual insight with a cheap analogy
09:19:11 <kallisti> funfunctor: should cut down on a lot of readIORef/writeIORef spam, unless I'm missing something.
09:19:23 <funfunctor> kallisti: but we could use bool isSuperSpeed; global state as a simple example to work out how things work
09:19:24 <ReinH> Probably because there isn't much of the former
09:20:22 <joobus> I don't understand this: "in practice, GHC, as a compiler, is very slow. Haskell programs, unless written very carefully, do get quite slow."  So the compiler is slow, or programs get magically slower over time?
09:20:37 <funfunctor> kallisti: RadioDevice is just the generic interface, it can't be polluted with device implementation dependencies
09:20:37 <ReinH> Any program will be slow if you don't know how to make it fast. At least in Haskell it doesn't also segfault.
09:21:00 <kallisti> funfunctor: ah
09:21:01 <clrnd> joobus, they will get slower as years pass, yes
09:21:08 <funfunctor> ReinH: Haskell is way too slow at segfaulting
09:21:15 <ReinH> joobus: The bits get worn out over time.
09:21:19 <ReinH> The edges start to round off.
09:21:19 <joobus> does haskell have a reputation of being slow?
09:21:30 <clrnd> lol they start to look sinusoidal
09:21:36 <joobus> ReinH: ok, so the guy basically is FOS :P
09:21:36 <kallisti> funfunctor: so there might not BE a sample rate as a value, or whatever, it might just be a library call. The current readIORef stuff is just placeholder
09:21:59 <ReinH> joobus: Pretty much.
09:22:28 <clrnd> in my country compiling with GHC circa 1995 was impossible because of how much processing it needed, but that's as far as it gets
09:22:33 <joobus> and this concludes another episode of fighting stupidity on the internet...
09:22:35 <ReinH> joobus: There are a few sentences that criticize things that are worthy of criticism, albeit in a completely overblown way. Otherwise it's mostly wrong.
09:22:38 <funfunctor> kallisti: I think its best to skim over http://lpaste.net/121078 to see how these states are used in practice
09:22:57 <hsk5> Okay I promise this is the last one today. (I'm sorry but it seems the world is trying to scare me away from Haskell.) What are your thoughts on the first comment here (by substack)? https://news.ycombinator.com/item?id=3065672
09:23:14 <vamega> What's the best way to get a lock based on a string value? I'm trying to have multiple threads perform an action, but if another thread has acquired a resource determined by a string, then this one should wait on acquiring the until the previous thread release the resource.
09:23:23 <hsk5> The replies too, some of which which concur
09:23:26 <kallisti> funfunctor: right, but you're not implementing this from the ground up with 100% Haskell dependencies right? you're using C library calls?
09:23:49 <clrnd> 'I write a lot of node.js now and it's really nice'
09:23:54 <clrnd> (sorry had to do it)
09:24:13 <funfunctor> kallisti: i'm implementing pretty much from the ground up!!! the only thing binded is the C library calls the the raw device
09:24:36 <vamega> The semantics would probably be something akin to a hashmap, where if a value exists in the map, then the thread blocks until the value is removed from the map.
09:24:44 <HeladoDeBrownie> "I had no idea what horrors GHC was performing on my behalf" sounds like something i would like to be true for myself. i compile abstract languages to less abstract ones so i can program as abstractly as i like.
09:24:57 <funfunctor> kallisti: https://github.com/victoredwardocallaghan/hlibBladeRF/tree/nomonad
09:25:00 <clrnd> HeladoDeBrownie, lol
09:25:42 <funfunctor> kallisti: I can control radio hw with the IO monad in haskell!
09:26:38 <kallisti> funfunctor: I'm still seeing a typeclass as being the way to go here
09:26:43 <clrnd> hsk5, his argument is that he didn't learn the abstractions so he found haskell hard to use, which is perfectly fine
09:26:53 <ReinH> hsk5: Well, node's most concurrent execution model is similar to GHC's least concurrent execution model, so I suppose it is easier to keep that in your head. The whole argument seems to be "Haskell is hard to learn and I had problems when I tried to do things I wasn't ready for".
09:27:18 <clrnd> hsk5, but believe me when I say: they are worth learning
09:27:24 <funfunctor> kallisti: but how does that relate to my question about the statefulness inside a particular RadioDevice implementation
09:27:30 <hsk5> Okay
09:27:38 <hsk5> I intend to continue learning this
09:27:43 <hsk5> or at least trying
09:27:45 <kallisti> funfunctor: you're going to have a lot of state, just by nature of the problem domain. the low-level interface is a stateful machine.
09:27:57 <clrnd> you will even feel bad when in other languages this abstractions become hard or impossible to do
09:28:26 <funfunctor> kallisti: yes of course but the state is just a few ints, can't we cart those around inside the IO monad
09:28:27 <joobus> hsk5: how can he say this, "I had no idea what horrors GHC was performing on my behalf", and then say "I write a lot of node.js now and it's really nice. The whole runtime system easily fits into my head all at once and the execution model is simple and predictable."
09:28:27 <ReinH> clrnd: I miss higher kinded types quite often.
09:28:46 <joobus> I would not call javascript "predictable"
09:28:53 <joobus> see wtf.js
09:29:10 <clrnd> NaNNaNNaNNaNNaNNaNNaN
09:29:16 <ReinH> joobus: The execution model is simple and predictable, not the language.
09:29:20 <joobus> http://wtfjs.com/
09:29:27 <funfunctor> kallisti: you are saying I should revert https://github.com/victoredwardocallaghan/hbts/commit/4fc1e09c3a07864c80182d90cd576119e0484b91 ?
09:29:34 <clrnd> typeof NaN === "number"
09:29:37 <HeladoDeBrownie> joobus, i think you're twisting his words a little; he says node's runtime system is simple and predictable, not javascript's semantics.
09:29:50 <joobus> ok, my bad i guess
09:29:55 <HeladoDeBrownie> i disagree with him but we still ought to be fair in critiquing the critique.
09:30:04 <ReinH> joobus: Like I said, node's best, most concurrent runtime model is similar to GHC's worst, least concurrent runtime model.
09:30:09 <funfunctor> kallisti: which would be bad because I end up with a higher monad type and horrible type parameters
09:30:12 <ReinH> It's also node's only runtime model.
09:30:19 <kallisti> funfunctor: well I definitely think there's a benefit to avoiding mutable variables in your records when possible. So, for example, have RadioDevice just contain a bunch of regular Haskell values and then have a means to construct the entire record with a single IO call
09:31:14 <joobus> And this part I still do in python (8+ years): "Anything I did in haskell required a lot of thinking up-front and tinkering in the REPL to make sure..."
09:31:22 <ReinH> The thing about GHC is that you can turn on the threaded runtime whenever you want.
09:31:44 <xnull_> joobus: i do it moreso in python than in haskell
09:31:48 <shapr> tromp_: Do you have a twitter account?
09:31:56 <funfunctor> kallisti: I sort of need a way for RadioDevice to have some 'generic' type as a field that allows for a particular implementations state to be held in
09:32:20 <funfunctor> kallisti: is that possible?
09:33:04 <shapr> howdy Igloo, how's code?
09:34:13 <kallisti> funfunctor: Personally I would just have a typeclass, and every implementation with a different record. Unless you're dynamically modifying the interface of a particular RadioDevice at runtime you don't really need a single universal record type;
09:35:09 <funfunctor> kallisti: I don't get how a typeclass is going to solve my problem
09:36:29 <hsk5> Okay
09:36:34 <hsk5> I'll just forget about these naysayers
09:36:41 <kallisti> funfunctor: well, the 'generic' type that stores implementation-defined state that you want, just becomes the normal 'top-level' record, implementing an instance of a typeclass that essentially defines all of the functions that are currently in your RadioDevice
09:36:56 <funfunctor> kallisti: could RadioDevice has some kind of field , opaqueState :: IORef ???
09:37:10 <kallisti> funfunctor: what would this field do?
09:38:29 <funfunctor> be a IORef "pointer" to a boxed implementation dependent record of state
09:39:18 <kallisti> eh, you probably don't want an IORef at all for that.
09:39:34 <kallisti> type parameters or a typeclass
09:39:41 <shapr> hsk5: I'm interested in how your learning process goes
09:39:57 <kallisti> I'm going to write up some code to show you what I'm talking about.
09:40:02 <funfunctor> kallisti: going around in circles, guess i'll sleep on it
09:40:13 <funfunctor> kallisti: oh that would be good!
09:40:28 <hsk5> shapr: why? are you experienced or also learning?
09:40:35 <hsk5> or rather, also a noob
09:40:46 <shapr> hsk5: I'd consider myself some of both
09:40:56 <tromp_> hi shapr! no, i dont use twitter
09:41:17 <ReinH> shapr: shouldn't we all...
09:41:23 <shapr> hsk5: I'm just often surprised by how some people drop into Haskell and it's no big deal, and others never seem to get it.
09:41:31 <hsk5> Ok, I haven't even written any real programs yet. I'm about a month away I think from REALLY finishing LYAH (as in, having studied and fully grasped it, including moands)
09:41:45 <shapr> tromp_: also, is your lambda playground gone forever now that your cwi.nl website is gone?
09:41:47 <kallisti> funfunctor: how do you communicate with the device itself?
09:42:30 <tromp_> no, it all moved to tromp.github.io
09:42:43 <shapr> hsk5: so, scariness aside, I'm curious how it will go for you.
09:42:58 <shapr> tromp_: ok, I'll look around there, thanks
09:42:59 <tromp_> as google tromp would have showed you:)
09:43:12 <hsk5> shapr: heh ok
09:43:19 <shapr> tromp_: doh, google turns that up instantly
09:44:09 <shapr> hsk5: Have you started learning? Or are you checking popular opinion first?
09:44:38 <hsk5> shapr: as i said, i'm close to finishing lyah
09:44:42 <hsk5> learn you a haskell
09:44:49 <hsk5> but haven't written anything real yet
09:44:51 <shapr> hsk5: any initial impressions?
09:45:24 <hsk5> My feeling is that Haskell's got something that appeals to me. Pure functions. For the first time in my life, maybe I can REALLY think about one thing at a time
09:45:30 <hsk5> and not worry about the outside world
09:45:50 <hsk5> i'll see how right i am when start writing real programs
09:46:04 <shapr> hsk5: I look forward to hearing more :-)
09:46:48 * shapr reads about binary lambda calculus
09:46:50 <ski> .. fwiw, some people seem to prefer suggesting <http://www.seas.upenn.edu/~cis194/spring13/> instead of LYAH as a first introduction
09:46:53 <hsk5> heh ok..
09:47:27 <ajcoppa> yep. hsk5: check out cis194 as linked above. it has exercises that will help you ensure you understood what you read in LYAH
09:47:49 <hsk5> ok, will do
09:47:50 <hsk5> nice
09:47:53 <hsk5> didn't know about that one
09:48:25 <ajcoppa> there's also a #haskell-beginners channel here on freenode. it's a little more focused so it can be easier to get help
09:48:26 <ski> there's also a <https://github.com/NICTA/course/>, but it's harder, so not recommended as a first one
09:48:36 <hsk5> great
09:48:36 <shapr> hsk5: I started pursuing the idea of pure functions independently before I'd ever heard of Haskell or functional programming. I was writing pure functions in Python and skipping out on objects. My friend darius asked me "Why are you trying to write Haskell in Python?"
09:48:38 <ajcoppa> yes, save NICTA until after you've gotten through cis194
09:49:01 <hsk5> shapr: yes but can python guarantee that your functions are pure?
09:49:02 <shapr> hsk5: when I started reading about Haskell, it was like a movie scene where the clouds opened up and the sunbeams all focussed on my brain.
09:49:21 * ski learned the basics from Simon Thompson's textbook "Haskell: The Craft of Functional Programming"
09:49:36 <shapr> hsk5: Python certainly cannot guarantee purity, but I started understanding the benefits of purity before I knew there was a language that encouraged/required purity.
09:50:09 <hsk5> cool
09:53:06 <quchen> So the longest thread I've seen in recent times is about deprecating fromJust or not.
09:53:21 <quchen> This will grow larger than all FTP+AMP discussions together.
09:53:36 <shapr> I hope not
10:00:18 <josephle> what would be the downside of deprecating fromJust?
10:00:34 <josephle> aside from the fact that a case statement would be more verbose
10:00:41 <josephle> but safer
10:00:47 <quchen> It's nice for hacking, and if you know that you always have a Just.
10:01:21 <quchen> Explicit case requires you to write the error message yourself, or have GHC nag you.
10:01:33 <josephle> yeah, that's what I thought
10:01:42 <josephle> Nothing -> undefined -- good enough for me :P
10:02:10 <quchen> josephle: That won't give you a good error though.
10:02:18 <quchen> Well, you better never see that error anyway :-)
10:08:39 <realteh_> I can reliably segfault (GHC version 7.8.4 for x86_64-unknown-linux) with some template haskell, is this worth reporting or is TH expected to not be stable?
10:08:53 <realteh_> I'm a beginner so I'm probably doing sth stupid
10:12:46 <joobus> I just got this book, http://www.haskellcraft.com/craft3e/Home.html , which is pretty comprehensive
10:13:12 <mmachenry> A library I'm using, STMContainers.Map has a function, stream, that provides an interface to ListT. I feel as though there's probably a filter that operates on ListT but I don't see one. Should I use (filter f . toList) or is there a better way?
10:14:04 <hannes__> realteh_: Code? If it's large, can you reduce to a smaller size? It's quite possibly a bug, although I'm not sure - maybe it's possible to use TH to break the compiler
10:14:12 <mpickering> mmachenry: Which ListT are you using?
10:14:20 <realteh_> hannes__, I'll try to shring the example
10:14:24 <mmachenry> https://hackage.haskell.org/package/list-t-0.4.2/docs/ListT.html#v:fold
10:14:40 <mmachenry> mpickering: It's the one linked to from STMContainers.Map
10:18:25 <thebnq> compiling with -fllvm -optlo-loop-unroll gives me "LLVM ERROR: L_newCAF$alias: Target doesn't support aliases to declarations", am i missing something obvious?
10:20:33 <realteh_> hannes__, https://gist.github.com/teh/d94a704254c834af6cdf
10:20:42 <realteh_> you should be able to clone and "cabal run"
10:24:57 <YaRly> dfeuer, merijn, mauke and all: Sorry, my lappy ran out of juice. Thanks for the help with Hashtables earlier
10:30:42 <clrnd> mmachenry, what did you end up doing?
10:30:55 * hackagebot highlighter2 0.2.4 - source code highlighting  http://hackage.haskell.org/package/highlighter2-0.2.4 (chemist)
10:32:33 <ReinH> If we deprecate fromJust then we should deprecate head as well.
10:33:01 <ReinH> Structurally, they are the same function.
10:33:25 <clrnd> why don't put those utility-yet-unsafe funcitons in a particular module?
10:33:30 <Clint> i'd rather have fromJust than head
10:33:48 <clrnd> I can see their use during think/learn/repl phase
10:35:10 <hannes__> I don't think I've ever used head, although I used fromJust in some cases where the type forced a maybe but the usage guaranteed I was always gonna get something
10:35:47 <clrnd> in those cases I usually do `case Nothing -> error 'Something really bad happened'` (honest)
10:36:13 <hannes__> clrnd: Isn't that pretty much what fromJust does already?
10:36:18 <clrnd> I do that in dynamic languages too, fail as hard as possible
10:37:18 <hannes__> or `fromMaybe (error "Well this is awkward")`
10:37:27 <clrnd> fromJust prints a generic error, and it's not "conceptually correct", in my oppinion, if you can't fail say it (and comments don't work)
10:37:45 <greymalkin> I'm trying to parse a (custom) nested data format; each "line" is a consistent format, but there are begin/end tags which represent enclosed data. Which monad should I be looking for that allows me to consume the list of lines so that parents don't re-process lines that the child functions already have?
10:38:05 <ReinH> greymalkin: a parser monad?
10:38:10 <clrnd> I like doing the `case` because at least that way I think if it REALLY can't fail
10:38:28 <mmachenry> clrnd: I have, so far, just do toList(Map.stream m) >>= filter f
10:39:36 <hannes__> greymalkin: You need to explain like half the terms you're using, because they don't make any sense out of context
10:40:57 <hannes__> It's also not entirely clear to me why you think you necessarily need a monad
10:42:13 <mniip> it's something I don't undestand, it must be a monad!
10:42:33 <clrnd> s/monad/lens/
10:43:35 <ski> greymalkin : if you want to parse e.g. something like where you first parse a count, then parse that many somethings, more generally, if what you try to parse later can depend on what partial parse result you've already got : then you probably need a monad. otherwise an applicative parser could be enough
10:44:33 <greymalkin> ReinH: Yeah, I think you're right. I was trying to do staged parsing (where I first parse the lines, then parse the parts of the line, then put them together) because I think I was avoiding extracting structure in the initial parser that I made with parsec.
10:45:26 <hannes__> greymalkin: Wait, so you already have a parser for this?
10:45:29 <greymalkin> But now that that works, I now (thanks to your simple line) see how I can build the parser further without interrupting the existing [working] parsers
10:45:55 * hackagebot b9 0.2.0 - A build tool for virtual machines.  http://hackage.haskell.org/package/b9-0.2.0 (SvenHeyll)
10:47:25 <clrnd> mmachenry, can't you use filterM since ListT is a monad? just guessing
10:47:59 <hannes__> :t filterM
10:48:00 <clrnd> I take that back, filterM is for [m a]
10:48:00 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
10:48:03 <clrnd> yeah yeah
10:48:54 <mmachenry> clrnd: Maybe. I didn't know about filterM. I knew something like that must have existed. I just didn't really know how to look for it.
10:49:35 <clrnd> mmachenry, it won't work, give me a minute I wanna try something
10:49:43 <mmachenry> clrnd: I think it won't.
10:49:47 <mmachenry> :t filterM
10:49:48 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
10:54:52 <ReinH> greymalkin: So basically you need a state monad. Parser monads just happen to have a lot of handy extra stuff lying around for use in... parsing.
11:02:32 <deMoivre> HeladoDeBrownie: You there?
11:05:56 * hackagebot b9 0.2.1 - A build tool and library for virtual machines.  http://hackage.haskell.org/package/b9-0.2.1 (SvenHeyll)
11:20:57 * hackagebot hackernews 0.3.1.2 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.3.1.2 (DavidJohnson)
11:22:38 <duuude> hi
11:22:45 <duuude> when I add a sqrt and floor to this why does it stop working:
11:22:49 <duuude> > let factor x = filter (\y -> x `mod` y == 0) [1..x] in factor 31337
11:22:51 <lambdabot>  [1,31337]
11:22:52 <duuude> but
11:23:02 <duuude> let factor x = filter (\y -> x `mod` y == 0) [1..floor(sqrt(x))] in factor 31337
11:23:13 <duuude> > let factor x = filter (\y -> x `mod` y == 0) [1..floor(sqrt(x))] in factor 31337
11:23:14 <lambdabot>  No instance for (GHC.Show.Show a0)
11:23:15 <lambdabot>    arising from a use of ‘M488953623710994117121319.show_M4889536237109941171...
11:23:15 <lambdabot>  The type variable ‘a0’ is ambiguous
11:23:20 <duuude> any ideas?
11:27:25 <josephle> :t let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt(x))] in factor 31337
11:27:26 <lambdabot> (RealFrac a, Integral a, Floating a) => [a]
11:27:33 <josephle> that's a lot of constraints...
11:27:37 <hexagoxel> :t let factor x = filter (\y -> x `mod` y == 0) [1..x] in factor 31337
11:27:38 <lambdabot> Integral a => [a]
11:27:41 <hexagoxel> :t sqrt
11:27:42 <lambdabot> Floating a => a -> a
11:27:50 <duuude> what is :t?
11:28:07 <josephle> duuude: tells you the type of an expression
11:28:39 <ReinH> duuude: There is no type that is both Integral and Floating
11:28:41 <hexagoxel> you go back from Floating to Integral, but not in the other direction
11:28:41 <duuude> well 1..x in 31337 is an integer.  Why wouldn't floor(sqrt(integer)) also be an integer?
11:28:58 <duuude> How can the floor funciton be not an integer!  The whole reason it exists is to produce an integer :-P
11:29:13 <hexagoxel> :exf "(Integral a, Floating b) => a -> b"
11:29:14 <exferenceBot> realToFrac
11:29:14 <ReinH> duuude: That's not what I said.
11:29:14 <duuude> Floor is like, "Man, I have all these decimal places but I really just want the integer"
11:29:28 <ReinH> duuude: sqrt takes an instance of Floating
11:29:38 <duuude> so is what produces the error the sqrt then?
11:29:42 <duuude> It can't take a sqrt of an integer?
11:29:47 <geekosaur> correct
11:29:53 <duuude> that's effin ridiculous guys :)
11:29:58 <duuude> > sqrt(16)
11:29:59 <lambdabot>  4.0
11:30:01 <ReinH> It is definitely not ridiculous.
11:30:07 <duuude> so what happened there?
11:30:11 <duuude> it worked fine
11:30:16 <duuude> > floor(sqrt(16))
11:30:17 <geekosaur> numeridc literals are polymorphic
11:30:17 <lambdabot>  4
11:30:21 <geekosaur> :t 16
11:30:22 <lambdabot> Num a => a
11:30:36 <ReinH> GHC can choose 16 to be any instance of Num, so it picks one that is an instance of Floating
11:30:44 <ReinH> > let factor x = filter (\y -> x `mod` y == 0) [1 .. floor . sqrt . fromIntegral $ x] in factor 31337
11:30:45 <lambdabot>  [1]
11:30:58 <hexagoxel> > sqrt (16::Integer)
11:30:59 <lambdabot>  No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
11:30:59 <lambdabot>    arising from a use of ‘GHC.Float.sqrt’
11:31:28 <duuude> > let factor x = filter (\y -> x `mod` y == 0) [1 .. floor(sqrt(fromIntegral($ x)))] in factor 31337
11:31:30 <lambdabot>  Could not deduce (GHC.Real.Integral ((a -> b0) -> b0))
11:31:30 <lambdabot>    arising from the ambiguity check for ‘factor’
11:31:30 <lambdabot>  from the context (GHC.Real.Integral ((a -> b) -> b),
11:31:43 <duuude> what's the difference between yours and what I just tried to do Reinh?
11:31:46 <ReinH> duuude: Please remember that () is not function application in Haskell
11:32:06 <duuude> ReinH: but I just did > floor(sqrt(16)) and it was fine?
11:32:21 <duuude> seems the interpreter knows what it is
11:32:23 <geekosaur> but the $ x is not
11:32:26 <ski> duuude : `fromIntegral ($ x)' is nonsense
11:32:31 <geekosaur> that works for eactly one argument
11:32:32 <ReinH> Yes, it knows what it is. And what it is is not function application.
11:32:34 <moghedrin> :t ($ x)
11:32:36 <lambdabot> (Expr -> b) -> b
11:32:38 <ReinH> (16) = 16
11:32:47 <ReinH> so floor (sqrt (16)) = floor (sqrt 16)
11:32:48 <clrnd> HUH?
11:32:53 <clrnd> Expr?
11:33:03 <geekosaur> clrnd, simple-reflect package
11:33:04 <ski> @type ($ ?x)
11:33:05 <lambdabot> (?x::a) => (a -> b) -> b
11:33:26 <ReinH> ski: It's not nonsense, but it definitely won't typecheck ;)
11:33:30 <geekosaur> if you use single-character names like that then they're predefined as type Expr in lambdabot, so you can show off how e.g. fold works
11:33:47 <geekosaur> > mod 15 3
11:33:49 <lambdabot>  0
11:33:55 <geekosaur> > mod (15 3) -- nope
11:33:56 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a))
11:33:56 <lambdabot>    arising from the ambiguity check for ‘e_1153’
11:33:56 <lambdabot>  from the context (GHC.Num.Num (a1 -> a),
11:34:02 <geekosaur> > mod (15, 3) -- also nope
11:34:03 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t1)
11:34:03 <lambdabot>    arising from a use of ‘M363877178504700599521860.show_M3638771785047005995...
11:34:03 <lambdabot>  The type variable ‘t1’ is ambiguous
11:34:07 <duuude> okay I give - what's a $
11:34:16 <ski> ReinH : yes, so nonsense, given the types :)
11:34:20 <hannes__> duuude: It's function application
11:34:27 <geekosaur> function application made visible and lowst precedence, to help save on parentheses
11:34:27 <ski> duuude : a silly operator that is sometimes useful
11:34:28 <hannes__> duuude: Just a normal infix function
11:34:29 <ReinH> ski: fsvo nonsense ;)
11:34:32 <Hijiri> @src ($)
11:34:32 <lambdabot> f $ x = f x
11:34:34 <ski> ReinH : aye
11:34:39 <geekosaur> (normal funciton applicaiton is highest precedence)
11:34:46 <shachaf> Are you reading any introduction to Haskell?
11:34:48 <Peaker> Is there a LANGUAGE pragma that allows "do", "case", "let", etc to appear as an argument to a non-infix function?  That would save most of my $ uses!
11:34:57 <Peaker> geekosaur: except record syntax!
11:35:04 <ReinH> Peaker: there is LambdaCase for 1/3 of those
11:35:10 <shachaf> This channel is good for questions but a lot of your questions are covered better in most introductions than here.
11:35:11 <ski> Peaker : yeah, i've wanted that for a long time as well ..
11:35:24 <duuude> ok
11:35:35 <duuude> I found the introductions too hard
11:35:41 <Hijiri> which introduction?
11:35:45 <hannes__> which one
11:35:58 * hackagebot wai-middleware-hmac-client 0.1.0.1 - WAI HMAC Authentication Middleware Client  http://hackage.haskell.org/package/wai-middleware-hmac-client-0.1.0.1 (ChristopherReichert)
11:36:08 <ReinH> Peaker: sometimes I just wrap my do block in ()
11:36:19 * ski too ..
11:36:32 <clrnd> this is not lisp though, () are looked down upon
11:36:39 <ReinH> clrnd: No they aren't.
11:36:42 * ski doesn't look down on brackets
11:37:08 <hannes__> clrnd: Not really. And you can write most haskell code lisp style just fine
11:37:08 <ReinH> At least one style guide explicitly prefers them.
11:37:16 <ski> .. however, in some cases, a lot of trailing `)'s (especially if their corresponding opening brackets are many lines up) can be less readable
11:37:18 <clrnd> i was joking ... nevermind
11:37:35 <hannes__> clrnd: There was no smiley, and therefore no joke
11:37:40 <clrnd> :(
11:37:41 <tommd> Well one thing is for sure.  () is a poor man's $.
11:37:42 <duuude> so what's wrong with this now:
11:37:43 <duuude> > let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt fromIntegral $ x)] in factor 31337
11:37:45 <lambdabot>  Could not deduce (GHC.Real.RealFrac a0)
11:37:45 <lambdabot>    arising from the ambiguity check for ‘factor’
11:37:45 <lambdabot>  from the context (GHC.Real.RealFrac a,
11:37:49 <duuude> how do  I fix it?
11:37:59 <Hijiri> duuude: the sqrt fromIntegral $ x part
11:38:04 <ski> tommd : i might have said the opposite :)
11:38:14 <Hijiri> it is interpreted as (sqrt fromIntegral) $ x
11:38:17 <duuude> > let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt $ fromIntegral $ x)] in factor 31337
11:38:18 <lambdabot>  [1]
11:38:22 <duuude> yay
11:38:23 <clrnd> the error sure is misguiding
11:38:38 <duuude> ohhh I get why it's interpretd as (sqrt fromIntegral) $ x
11:38:49 <duuude> you know why?  Because it's a Functional language.  that's why.  the one thing I don't get.
11:38:56 <ReinH> duuude: why wat is?
11:39:00 <ski> duuude : function application binds tighter than any operator (like `$')
11:39:00 <jnotarstefano> Hey everyone. Is it possible to write function composition in point free style?
11:39:00 <ReinH> *what
11:39:09 <tommd> ski: It was a syntax joke.  Poor man, $...
11:39:11 <duuude> we're creating a new function bassed on sqrt fromIntegral and then applying it to x
11:39:16 <ski> jnotarstefano : how about `g . f' ?
11:39:23 <ReinH> jnotarstefano: sure, you define an operator called `.' ;)
11:39:24 <Hijiri> duuude: you just can't apply sqrt to fromIntegral
11:39:28 <hannes__> duuude: no, it's just that a b means 'apply b to a' always in haskell. No exceptions. And it always has the highest priority
11:39:47 <hannes__> well
11:39:52 <duuude> tommd: your syntax joke is good!!
11:39:57 <ReinH> duuude: What do you think is interpreted as (sqrt fromIntegral) $ x ?
11:40:02 <hannes__> unless there's something preceding the a, but that was kind of implicit
11:40:18 * ski thinks hannes__ uses strange terminology
11:40:45 <ski> (i would read `sin pi' as "apply `sin' to `pi'", not "apply `pi' to `sin'")
11:40:46 <aavogt> > mempty { appEndo = error "hannes__" } `appEndo` 1
11:40:48 <lambdabot>  *Exception: hannes__
11:40:58 * hackagebot wai-middleware-hmac-client 0.1.0.2 - WAI HMAC Authentication Middleware Client  http://hackage.haskell.org/package/wai-middleware-hmac-client-0.1.0.2 (ChristopherReichert)
11:41:00 * hackagebot mp 0.2.2 - Music player for linux.  http://hackage.haskell.org/package/mp-0.2.2 (piotrborek)
11:41:12 <hannes__> huh. I think of it as applying a parameter to a function
11:41:18 <sinelaw> Peaker, hi
11:41:36 <Peaker> sinelaw: hey
11:42:40 <jnotarstefano> ski: I mean, I can define (.) as (.) f g x = f (g x), which (if I understood this concept correctly) is not in point free style.
11:43:11 <clrnd> hannes__, well, I think of applying a function to a parameter :P
11:43:24 <clrnd> first time I heard that
11:43:29 <clrnd> hear*
11:43:29 <ReinH> jnotarstefano: There isn't a pointfree definition of (.), no.
11:43:47 <duuude> ReinH> duuude: What do you think is interpreted as (sqrt fromIntegral) $ x ?   ---->  > let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt fromIntegral $ x)] in factor 31337
11:44:04 <duuude> > let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt fromIntegral $ x)] in factor 31337
11:44:06 <lambdabot>  Could not deduce (GHC.Real.RealFrac a0)
11:44:06 <lambdabot>    arising from the ambiguity check for ‘factor’
11:44:06 <lambdabot>  from the context (GHC.Real.RealFrac a,
11:44:11 <jnotarstefano> ReinH: ah, cool. Thanks!
11:44:11 <ReinH> duuude: Ah, that's correct.
11:44:11 <duuude> > let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt $ fromIntegral $ x)] in factor 31337
11:44:13 <lambdabot>  [1]
11:44:16 <duuude> and that is the fix
11:44:20 <duuude> the infix.
11:45:02 <ski> jnotarstefano : well, we can rewrite the right-hand-side `f (g x)' to `(Prelude..) f g x', so that we get `(.) f g x = (Prelude..) f g x', or for short, `(.) = (Prelude..)' .. oops
11:45:06 <hannes__> you can leave off the second $, it doesn't really do anything
11:45:54 <duuude> so walk me through why we can't go from let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt $ fromIntegral $ x)] in factor 31337 which works to  let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt (fromIntegral (x)))] in factor 31337
11:45:56 <hannes__> actually, don't use $ for now (unless you need partially applied function application). Stick to parentheses
11:46:07 <duuude> > let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt (fromIntegral (x)))] in factor 31337
11:46:09 <lambdabot>  [1]
11:46:13 <duuude> wait nevermind it does work
11:46:28 <ski> jnotarstefano : perhaps you'd like to start with a language which didn't have any points to begin with. e.g. a concatenative language, like Forth, Factor, or Joy. or, to some extent, Charity (a categorically-inspired language, not a concatenative language)
11:46:37 <hannes__> you don't need the parentheses around the x
11:46:49 <duuude> ski - did you say that to me?
11:46:59 <hannes__> duuude: you're not jnotarstefano
11:47:04 <ski> duuude : no, i was talking to jnotarstefano
11:47:06 <ReinH> duuude: parenthesis are used to group expressions, not to apply functions
11:47:06 <duuude> ooops lol yeah
11:47:13 <ReinH> floor (sqrt (fromIntegral x))
11:47:15 <duuude> yeah you addressed him explicitly - sorry
11:47:36 <duuude> so ReinH it's really the SPACE that applies the function?
11:47:42 <jnotarstefano> ski: I'm currently attending a Haskell lecture, and just stumped the lecturer with this question : )
11:47:42 <hannes__> duuude: pretty much
11:47:44 <ReinH> duuude: Yes, that's what we've been saying.
11:47:49 <duuude> > let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt (fromIntegral (x)))] in factor 31337
11:47:50 <lambdabot>  [1]
11:47:52 <duuude> and now let me remove the spaces
11:47:59 <duuude> > let factor x = filter (\y -> x `mod` y == 0)  [1..floor(sqrt(fromIntegral(x)))] in factor 31337
11:48:01 <lambdabot>  [1]
11:48:11 <hannes__> duuude: we didn't mean it like that
11:48:16 <duuude> well, it still works.  I guess a parentheses is an implicit space.
11:48:28 <ReinH> duuude: f(x) is equivalent to f x, yes
11:48:28 <hannes__> duuude: it's really the token separation, which is usually done with whitespace
11:48:50 <hannes__> duuude: but of course parentheses also separate tokens
11:49:06 <duuude> ReinH it's a bit disingenuous to say "parenthesis are used to group expressions, not to apply functions" and then say " f(x) is equivalent to f x, yes"
11:49:14 <ReinH>  No, it isn't.
11:49:17 <hannes__> duuude: no
11:49:18 <ski> yes, application of functions is in Haskell denoted simply by juxtaposition
11:49:27 <ski> `f(x)' is an example of `f' juxtaposed with `(x)'
11:49:35 <hannes__> duuude: it's f applied to (x) which is
11:49:40 <ReinH> The parenthesis in f(x) do not perform the application, the juxtaposition does.
11:49:46 <hannes__> just 'grouped x' which is just x
11:49:49 <hannes__> so it's just f x
11:49:54 <duuude> this seems to me a distinction without a difference...
11:50:10 <duuude> parentheses perform the application BY justaposing.
11:50:16 <hannes__> duuude: the difference is that f x y isn't the same as f (x y)
11:50:19 <ajcoppa> they're trying to express to you that the parens are unneeded
11:50:20 <ski> duuude : no
11:50:37 <ski> the brackets doesn't juxtapose two expressions
11:50:44 <duuude> hannes__ right, because f x y is (f x) (y)
11:50:57 <ski> because function application is left associative
11:51:03 <clrnd> more like ((f x) y)
11:51:03 <duuude> or, the way I would write it: (f(x))(y)
11:51:07 <hannes__> duuude: the grammar works like this: if e is an expression, then (e) is also an expression. Nothing to do with function application
11:51:15 <geekosaur> the distinction will make more sense when you discover partial application
11:51:29 <ski> duuude : saying `f(x)' is the same as `f x' is similar to saying that `(2 + 3)' is the same as `2 + 3'
11:51:31 <Trollinator> one can write it without parens, let { z = x y } in f z
11:51:52 <ski> (or `(2) + (3)' is the same as `2 + 3', or ...)
11:51:55 <duuude> ski - yes, and why would anyone argue with the latter?
11:51:57 <clrnd> @pl f x = [1..floor(sqrt(fromIntegral(x)))]
11:51:57 <lambdabot> f = enumFromTo 1 . floor . sqrt . fromIntegral
11:51:58 <Trollinator> so the parens have nothing to do with application.
11:52:11 <duuude> (2 + 3) is the same as 2 + 3  <<< any arguments?
11:52:19 <ski> duuude : beats me. why would anyone argue with "parenthesis are used to group expressions, not to apply functions" ?
11:52:36 <OffsetGoose> duuude: (2+3) is evaluated before 2+3
11:52:54 <c_wraith> OffsetGoose: what?  No it's not.
11:53:05 <hannes__> OffsetGoose: Not necessarily. It implies grouping, not evaluation order
11:53:05 <duuude> c_wraith - he means order of operations
11:53:09 <c_wraith> OffsetGoose: all parens do is group expressions explicitly
11:53:17 <duuude> like the distinction between (2+3) * 4 and 2+3 * 4
11:53:20 <c_wraith> OffsetGoose: order of operations depends on the parse tree and demand
11:54:07 <duuude> well, thanks for the help guys
11:54:09 <OffsetGoose> c_wraith: I know I've written a grammar before in c++, I was jk
11:54:21 <c_wraith> OffsetGoose: ah, ok
11:54:22 <duuude> OffsetGoose, a grammar?
11:54:31 <OffsetGoose> a mathematical grammar
11:54:32 <EvanR> OffsetGoose: a stayed in a holiday inn express last night
11:54:38 <wayne> duuude: please see the infixr section: http://www.zvon.org/other/haskell/Outputprelude/index.html
11:54:51 <c_wraith> duuude: grammars are formal ways of specifying how to parse things
11:54:55 <xnull_> ^
11:55:28 <wayne> when you define your own backtick operators, you can specify what precedence you want it at
11:55:53 <duuude> okay
11:55:55 <wayne> higher is more important
11:56:14 <Trollinator> "more important"?
11:56:40 <hannes__> function application is more important than addition, obviously
11:56:56 <wayne> haha Trollinator,
11:57:04 <c_wraith> I really think it's best to just say "binds more tightly".
11:57:05 <wayne> more precedence might have been a better word choice
11:57:12 <wayne> yeah or that
11:57:37 <duuude> is haskell typically compiled (like c/c++) or interpreted (like ruby or python)
11:57:38 <EvanR> arithmetic is a bad example
11:57:56 <aaronweiss74> duuude: compiled
11:57:59 <Trollinator> duuude: why does that matter?
11:58:07 <hannes__> duuude: compiled
11:58:16 <ski> operators are involved in a "tug-of-war" (or "hug-of-war", if you prefer), their relative precedence levels (and, in case those are equal, their associativities) determines who wins in each specific case
11:58:19 <clrnd> duuude, you can use runhaskell though
11:58:24 <hannes__> duuude: You can run it through an interpreter, but that's not the usual case
11:58:38 <duuude> do you think lambdabot compiles my requests
11:58:42 <duuude> it sure takes a second or two
11:59:03 <hannes__> duuude: pretty sure lambdabot just hands them over to ghci
11:59:12 <aaronweiss74> Yeah, I believe lambdabot should be a REPL.
11:59:18 <ReinH> @quote fugue
11:59:19 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:59:32 <clrnd> lol
11:59:34 <EvanR>  > unsafeLaunchMissles
11:59:45 <hannes__> great now you broke it
11:59:54 <clrnd> how does ghci do though? does it has a custom runtime or something?
11:59:56 <geekosaur> not exactly ghci, but the same underlying mechanism (ghc-api)
11:59:58 <tdammers> aren't fugues contrapuntal by definition?
12:00:10 <ReinH> tdammers: take it up with monochrom :p
12:00:18 <clrnd> tdammers, they are
12:00:38 <EvanR> hahaha
12:01:00 <ReinH> tdammers: and yes, but sometimes people use repetition for emphasis
12:01:16 <geekosaur> ghc has multiple backends. one is a bytecode backend, which is used by template haskell, ghci, runghc/runhaskell, and the ghc-api interfaces used by hint and mueval (lambdabot uses the latter)
12:01:26 <ReinH> Which is to say, sometimes people repeat things to add emphasis.
12:01:33 <hannes__> and js
12:01:36 <duuude> tdammers I'm sure there's a type mismatch joke in there somewhere
12:02:08 <geekosaur> (also ghc -e)
12:02:18 <juanpaucar> guys is there something to convert lazy to strcit on text or bytestring?
12:02:42 <clrnd> junmin, yes
12:02:47 <hannes__> juanpaucar: probably. the lazy versions of these things are pretty much just list of strict chunks anyway
12:02:48 <shachaf> Yes, it's listed in the documentation in .Lazy
12:02:49 <clrnd> juanpaucar, yes
12:03:00 <hannes__> not quite lists I think, but conceptually the same
12:03:36 <ReinH> hannes__: yep, lists.
12:04:00 <ReinH> Well, they use their own list data type, and they unpack the contents
12:04:31 <clrnd> so ghci compiles to bytecode and runs that, all in memory?
12:05:05 <Welkin> there is no bytecode
12:05:11 <Welkin> it compile it to machine code
12:05:16 <Welkin> compiles*
12:05:30 <juanpaucar> well it's possibe
12:05:31 <juanpaucar> http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text-Lazy.html
12:06:00 <hannes__> Welkin: talking about ghci
12:06:01 <clrnd> Welkin, is it too much if I ask you to point me near where that happens in ghci's source code?
12:06:46 <hannes__> where can I find ghc-api documentation? I've seen a wiki page but that seemed kind of really old and I'm positive the api changed several times since it was written
12:07:58 <tdammers> ReinH: repetition and counterpoint are orthogonal concerns :D
12:08:18 <ReinH> tdammers: I'm not saying that fugues employ repetition (although they do) :p
12:08:32 <duuude> guys, thanks for your help :).  talk to you all later
12:08:43 <geekosaur> I'm not sure there is up to date documentation. you might ask the developers of mueval or ghc-mod since they use it pretty heavily
12:08:49 <tdammers> ReinH: that was kind of a confusing statement to make
12:09:30 <EvanR> sometimes a contrapuntal fugue is just a fugue
12:10:04 <tdammers> for some values of "sometimes"
12:12:50 <hannes__> I don't know, using an API without documentation kind of seems like learning a language with only a vocabulary to me
12:13:12 <tdammers> hannes__: no, it's worse
12:13:38 <tdammers> hannes__: you can learn a natural language pretty much on exposure and human interaction alone
12:13:59 <hannes__> tdammers: I was actually gonna argue it's slightly better because the constraints of the language at least give me some concept of what the grammar can not be
12:15:01 <tdammers> hannes__: yeah, but with natural languages, you have so much context that there's plenty of hints to bootstrap a few basic phrases
12:16:50 <hannes__> tdammers: Ok, so then it's like learning a language that's only spoken by a handful of very busy people with only a vocabulary
12:16:53 <ReinH> tdammers: for some values of "some" and "values"
12:17:18 <tdammers> ReinH: for some values of "for" and "of"
12:17:30 <clrnd> jajaja
12:17:33 <ReinH> tdammers: indeed
12:18:05 <ReinH> Everything is meaningless, time to pack it up
12:18:17 <tdammers> I take a more positivistic stance
12:18:25 <tdammers> Everything meaningless, so I get to choose.
12:18:49 <EvanR> fix ("for some value of " ++)
12:18:52 <int-e> DWYTIM -- do what you think I mean
12:19:23 <tdammers> "Dear computer, please make a website, with gradients and pictures and stuff"?
12:19:43 <int-e> tdammers: I have this great picture of a kitten
12:20:24 <tdammers> int-e: quick, put it on the internet before someone else does
12:20:27 <ajcoppa> not sure what you all are talking about -- i just see a configuration of pixels on the screen and push buttons to make the pixels change colors
12:20:56 <hannes__> ajcoppa: According to instructions handed to you by a chinese guard?
12:21:17 <tdammers> hannes__: as if you'd ever get an honest answer to such a question
12:22:27 <int-e> tdammers: I lied, all I have is a weird "under construction" sign.
12:22:57 <tdammers> int-e: that's probably even better. you could use it for a website you haven't started building yet, and probably never will
12:27:47 <bennofs> Is there any use case where you'd ever want modifyIORef instead of atomicModifyIORef?
12:28:15 <Fuuzetsu> non-atomic is probably omgfast
12:28:48 <shachaf> IORef operations are never fast.
12:28:54 <shachaf> But atomic ones are even slower.
12:28:57 <Fuuzetsu> there are degrees of slow
12:28:59 <bennofs> you don't know the result, but it's fast. very nice :)
12:28:59 <Fuuzetsu> ;)
12:29:09 <Fuuzetsu> bennofs: it's like writing C!
12:29:37 <hannes__> C is actually pretty ok if you don't do multithreading
12:29:43 <EvanR> we need an unagi ref
12:29:56 <geekosaur> modifyIORef is fine when you're not doing M:N threading. I have used it to pass data between callbacks and the main program
12:29:57 <Fuuzetsu> now I want some unagi on rice
12:30:36 <bennofs> geekosaur: ah right, forgot that you might also use IORefs for non-concurrent programs :D
12:30:40 <geekosaur> ...and since the callbacks were from C functions, I think that would work even in threaded?
12:31:05 <bennofs> geekosaur: even in threaded there can be multiple concurrent haskell threads running while an unsafe FFI call
12:31:14 <int-e> bennofs: I'd probably reach for modifyIORef' instead of modifyIORef.
12:31:20 <geekosaur> but an unsafe ffi call can't call a haskell callback
12:31:41 <bennofs> geekosaur: right, for safe call there is even more concurrency
12:31:45 <int-e> bennofs: And I would try to avoid IORefs on general principles.
12:32:37 <geekosaur> (not that it matters, it was gtk2hs so couldn't really be threaded anyway because gtk+ doesn't really do threads --- anything involved with the UI must be on the main thread anyway)
12:34:59 <int-e> Right, I've used IORefs in connection with gtk2hs as well.
12:35:59 <clrnd> why are you saying IORefs are slow? asking out of curiosity
12:39:38 <geekosaur> extra levels of dereferences, plus I think interaction with garbage collection
12:40:19 <clrnd> and what would be 'fast' in comparission?
12:40:50 <HeladoDeBrownie> deMoivre, i am now
12:41:07 <HeladoDeBrownie> deMoivre, if you wanted to tell me something specific but i wasn't available, there's MemoServ and also you can leave messages with lambdabot
12:41:29 <hexagoxel> is there a an automatized way of checking which cabal dependencies are too strict? or anything that would output something like "a new version of [your dependency] foo was published, do you want to check if your stuff works with this version as well"?
12:41:51 <HeladoDeBrownie> deMoivre, (although i'm leaving in <20 minutes)
12:42:20 <geekosaur> hexagoxel, there are some tools on hackage although I don't think they extend to automated checking like that
12:44:00 <geekosaur> clrnd, I'm not sure what you're asking. "not having those things I mentioned". how fast that is is in some ways irrelevant, since IORefs are updateable but that ability to update is precisely what introduces penalties
12:44:50 <geekosaur> and the cost includes things like, since you normally can't update things, they can be optimized more
12:45:33 <clrnd> geekosaur, I undertand all that, I wanted to know if there was a simillar kind of mutable reference taht was 'faster', since people were saying IORefs 9specifically) were slow
12:45:56 <geekosaur> no, it's more that you pay a penalty for mutability so you should avoid it when possible
12:46:16 <clrnd> perfect then
12:46:34 <geekosaur> this cost is a bit lower in ST because it knows that it can't be accessed outside the specific ST computation; there is no such guarantee for IORefs
12:47:15 <geekosaur> (but of course that means you can't use STRefs for things you want to access / modify from elsewhere, whether that elsewhere is a different thread or a callback or ...)
12:47:42 <clrnd> I understand, thanks
13:11:49 <hexagoxel> geekosaur: ah, no wonder there is so much hell.
13:13:10 <hannes__> hexagoxel: I think it's more the fact that automatic dependency resolution is a hard problem
13:13:21 <geekosaur> there was discussion of tooling some time back, but ^^
13:13:36 <latk> What should I be looking at to parse date/time combos ?
13:13:37 <geekosaur> ...and the way ghc handles dependencies doesn't exactly make it easier
13:16:52 <hexagoxel> hannes__: i do not understand. why dependency resolution?
13:17:10 <geekosaur> um
13:17:17 <geekosaur> what did you think the problem was?
13:18:21 <hesiod> Is it possible to run Cpphs or a similar C preprocessor on ByteStrings?
13:19:19 <hannes__> hexagoxel: what do you mean 'on bytestrings'?
13:19:28 <hannes__> *hesiod
13:20:35 <hesiod> hannes__: Cpphs runs on FilePaths: runCpphs :: CpphsOptions -> FilePath -> String -> IO String
13:21:10 <hesiod> But I'm using file-embed to embed files, so using Cpphs that way would defeat the purpose...
13:21:25 <hesiod> (embed files as ByteStrings)
13:23:00 <hexagoxel> geekosaur: for my package, i have dependencies foo >=3 <8, bar >=4 <7. i want to know if foo >=3 <9 should be put instead (e.g. by looking if it works with foo-8 and bar-6)
13:23:11 <hexagoxel> where "works" means "builds" or "tests" or whatever
13:23:33 <hexagoxel> i am aware that stuff is exponential; i am happy with some broad heuristics
13:23:51 <hannes__> hexagoxel: what would you base those heuristics on?
13:24:09 <hannes__> hexagoxel: the version numbers unfortunately don't really mean anything in most cases
13:24:12 <geekosaur> hm, cpphs has a library interface but it's on String not ByteString
13:25:25 <hexagoxel> hannes__: test with highest (and lowest, as a second test) allowed for any other than the tested dependency, for example
13:26:11 * geekosaur hvaing network issues and keeps losing connection to znc... sigh
13:27:23 <hexagoxel> hannes__: wait, what? can you elaborate on your last statement?
13:28:21 <hesiod> hannes__: Problem solved - Cpphs obviously can't do stuff related to files (e.g. __FILE__) if doesn't know the file name
13:48:50 <c_wraith> Where'd that article go talking about how toList couldn't be the fundamental operation of Foldable, due to reassociation issues with infinite data?
13:49:15 <c_wraith> I can't seem to find it now.  I've forgotten the name, author, site, and everything else about it.
13:49:16 <shachaf> http://comonad.com/reader/2015/free-monoids-in-haskell/ ?
13:49:21 <c_wraith> that's the one.  Thanks.
13:49:31 <shachaf> The fundamental operation of Foldable is toFMList
13:50:30 <shachaf> [flip] foldMap :: forall t a. Foldable t => t a -> forall m. Monoid m => (a -> m) -> m
13:52:42 <seagreen> Anyone know of a haskell library to detect vulgar usernames? Googling for "explicit" doesn't help because it just returns a bunch of type declaration stuff.
13:52:59 <seagreen> If such a library doesn't exist I may be making one soon.
13:54:03 <Trollinator> *sigh*. So humanity has created languages like Haskell and flown to the moon. And then there's people who are offended by somebody choosing dick as their nickname.
13:54:20 <Trollinator> it's just sad.
13:54:43 <monochrom> that is off-topic
13:55:17 <seagreen> Ideally it would be a general username-rejecter. You probably don't want people creating variations of <yourcompany>-admin, for instance.
14:00:31 <ReinH> seagreen: Doesn't exist afaik. You should write it and publish it to hackage.
14:01:13 <seagreen> ReinH: That's the plan!
14:01:19 <fragamus> what is (:>)
14:01:42 <monochrom> that depends on where you saw (:>)
14:01:43 <ReinH> fragamus: In that article, it's a data constructor of SL
14:05:04 <ReinH> dolio: Hask is such an ugly category, why can't we just work in Set
14:05:20 <ReinH> Who needs Turing Completeness or whatever
14:05:33 <dolio> Set is terrible.
14:06:03 <ReinH> dolio: Why is Set terrible?
14:06:13 <dolio> It's all classical and stuff.
14:06:18 <ReinH> :)
14:06:30 <ReinH> dolio: Is there a category you prefer?
14:06:50 <dolio> Some kind of type theory.
14:07:04 <dolio> But there are a lot of tradeoffs even there.
14:07:09 <rola> classical as in non-constructive?
14:08:10 <dolio> Like, encoding things the way I did with the free monoid relies on impredicativity.
14:08:21 <dolio> But impredicativity has costs.
14:18:20 <EthicalHacker> haskell is fookin garbage
14:18:46 <EthicalHacker> fookin bastards
14:18:50 <EthicalHacker> fuck yall
14:18:51 <deMoivre> EthicalHacker: Thank you for the insight.
14:18:52 --- mode: ChanServ set +o glguy
14:18:54 <EthicalHacker> fuckers
14:19:02 <deMoivre> Does anyone here use Leksah and know how to get a dark theme going?
14:19:02 --- mode: glguy set +b $a:EthicalHacker
14:19:06 --- kick: EthicalHacker was kicked by glguy (Your behavior is not conducive to the desired environment.)
14:19:20 <kallisti> is hackage no building new packages?
14:19:22 <kallisti> *not
14:22:02 --- mode: glguy set -o glguy
14:22:17 <cfoch> hello
14:22:33 <rasen> hi
14:22:44 <cfoch> can I use a parameter of a function in a "where" clause?
14:22:58 <rasen> yep
14:24:39 <fragamus> In what way is it fookin gargage
14:25:05 <darthdeus> hmm funny ... all dependencies are ok locally, but fail when deployed on a server, due to 7.8.3 vs 7.8.4, yay :D
14:25:06 <ski> they're gone
14:26:34 <cfoch> and...
14:26:47 <ReinH> darthdeus: Are you compiling on the server?
14:26:54 <ski> cfoch ?
14:27:08 <cfoch> can I make reference to "this_function <- something" from a "where" clause?
14:27:42 <kallisti> cfoch: you mean a name bound through do notation? no
14:27:50 <ski> cfoch : only if the `where' clause is inside a `let' or `case' inside the remaining commands in the `do'-block (assuming that `this_function <- something' is from a `do'-block)
14:28:14 <ReinH> I think there's some confusion here.
14:29:00 <ski> the variable(s) bound by `this_function <- something' in a `do'-expression is only in scope in the remaining commands in that `do'-expression
14:29:27 <ski> cfoch : .. perhaps you should paste your actual code (or maybe a simplified version of it that exhibits the same issue)
14:29:39 <ski> @paste
14:29:39 <lambdabot> Haskell pastebin: http://lpaste.net/
14:29:58 <lachenmayer> does anyone know where `cabal sandbox add-source` directories are stored? I can't find them in cabal.sandbox.config, or anywhere in .cabal-sandbox/ for that matter
14:30:15 <ski> we could try to suggest possible alternate ways of doing what you want to do
14:30:33 <lachenmayer> (and cabal seems to have forgotten at least one of the add-source directories)
14:31:03 <ReinH> lachenmayer: By default, in .cabal-sandbox in the directory where you run cabal sandbox init
14:31:07 <cfoch> ski: http://dpaste.com/11XWBWG#line-185
14:31:14 <ReinH> lachenmayer: oh, I misread, sorry
14:31:25 <hexagoxel> lachenmayer: there is `cabal sandbox list-sources`
14:32:15 <lachenmayer> nice one, thanks hexagoxel (and ReinH :) )
14:32:31 <cfoch> ski: line 185
14:32:32 <lachenmayer> seems weird that this isn't in some user-editable config file?
14:32:38 <cfoch> the problem is with "guess"
14:33:03 <ReinH> lachenmayer: They're stored in .cabal-sandbox/add-source-timestamps, I believe
14:33:09 <ReinH> I'm not sure what "timestamps" have to do with it
14:34:00 <lachenmayer> ahh, yes i see it. - i thought that was just some "install log" or something
14:34:11 <lachenmayer> i guess the timestamps are for rebuilding on change?
14:34:23 <ReinH> I don't even see any timestamps :)
14:34:24 <paul424> fmap :: (a -> b) -> (Wrapped a -> Wrapped b)fmap f (Wrap x) = Wrap (f x)That's about it there is to understand. However, it turns out that there is a more general function to do this lifting, which is bind:bind :: (a -> Wrapped b) -> (Wrapped a -> Wrapped b)bind f (Wrap x) = f x
14:34:27 <paul424> http://stackoverflow.com/questions/44965/what-is-a-monad , monads in haskell
14:34:28 <darthdeus> ReinH: yep, server is linux, and I'm on OS X
14:34:35 <paul424> ehem why does they claim teh bind is more general than fmap ? ( more useful ? )
14:34:39 <darthdeus> but I've fixed it by freezing and removing base from the constraints, seems to work so far
14:34:51 <c_wraith> paul424: you can implement fmap with bind
14:34:59 <c_wraith> @src liftM
14:34:59 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:35:00 <hexagoxel> lachenmayer: rebuilding/reinstalling, yes.
14:35:06 <c_wraith> paul424: liftM is an example of it
14:35:12 <ReinH> darthdeus: Ah. I build binaries in a docker container and ship them to servers.
14:35:25 <kallisti> cfoch: names bound by <- are only in scope for the remainder of the do block. The where clause is attached to the function itself.
14:35:29 <ReinH> darthdeus: In any event, you can use a configuration management tool to ensure that GHC versions match
14:35:29 <darthdeus> ReinH: does docker actually work on OS X now?
14:35:33 <c_wraith> paul424: that means that bind is a more general function - but it also means fewer types can implement it.
14:35:50 <ReinH> darthdeus: Sure, via the clever subterfuge of running the docker host in a VM :)
14:35:57 <ReinH> darthdeus: see boot2docker
14:36:15 <c_wraith> paul424: well.  you need return+bind to implement fmap, so to be fully honest, you need to say return+bind is more powerful than fmap
14:36:16 <ReinH> darthdeus: But we do the builds on ubuntu machines anyway
14:36:38 <paul424> c_wraith: it;s just more natural to think that one has a functor from  (a -> b) -> (Wrapped a -> Wrapped b ) instead (a -> Wrapped b) -> (Wrapped a -> Wrapped b)
14:36:40 <darthdeus> ReinH: yeah that's how it worked last time I checked docker and it felt too complicated :\ but maybe i should give it a try
14:36:45 <bitemyapp> ReinH: what config management tool do you use?
14:36:47 <kallisti> cfoch: In the case where you don't pattern match on any of the function parameters, f x = ... where ... is similar to writing f x = let ... in ...
14:36:52 <ReinH> darthdeus: Well, docker is complicated. :p
14:36:55 <darthdeus> though for this app I don't really mind just fixing the deps
14:37:02 <darthdeus> ReinH: which is why it will probably break :P
14:37:08 <ReinH> bitemyapp: Right now I'm using ansible. I used to work at puppet.
14:37:27 <ReinH> darthdeus: you can just run your own VM and use docker inside it
14:37:42 <ski> cfoch : you can place  let guess' | isPkgRegistered guess = Nothing | otherwise = guess  just after the `guess <- traverse ...' command
14:38:00 <darthdeus> ReinH: well in that case I can just build on the VM and don't need docker on it :D
14:38:08 <ReinH> darthdeus: True enough :)
14:38:18 <paul424> Anyone ??? If I start building new GreaterMonad
14:38:39 <ReinH> bitemyapp: All of our infrastructure is ephemeral so I don't need to manage drift, so ansible playbooks are pretty suitable.
14:38:48 <moghedrin> Hehehe. I totally just run it inside docker XD
14:38:55 <ski> cfoch : alternatively, replace the former by `let blah guess isPkgRegistered guess = Nothing | otherwise = guess', and use  blah guess  instead of  guess'  -- obviously rename `blah' to something more appropriate
14:38:57 <paul424> than to reuse is there larger chance I already have a function of type (a -> b) or (a -> GrtrMnd b ) ????
14:39:20 <ReinH> paul424: You can always make a function a -> m b out of a function a -> b by using the monad interface
14:39:22 <ReinH> the reverse is not true
14:39:23 <ski> cfoch : that's the main two options
14:39:28 <bitemyapp> ReinH: makes sense, cheers.
14:39:35 <ReinH> bitemyapp: cheers
14:39:42 <bitemyapp> ReinH: wait sorry, one more question
14:39:45 <ReinH> bitemyapp: ok :)
14:39:49 <bitemyapp> ReinH: if infra is ephemeral, what about persistence?
14:39:54 <bitemyapp> ReinH: presumably you aren't using a distributed database?
14:40:04 <ReinH> bitemyapp: machines are ephemeral, the system is durable.
14:40:20 <bitemyapp> ReinH: that implies replication - what is it?
14:40:30 <ReinH> bitemyapp: (although in point of fact, we are using AWS services to hide that complexity from us. ;)
14:40:39 <bitemyapp> RDS or something else?
14:40:54 <ReinH> bitemyapp: Mostly dynamodb
14:41:04 <bitemyapp> cool. Thanks. That would do it.
14:41:14 <ReinH> bitemyapp: But if I had to build my own I'd give Riak a good look
14:41:17 <paul424> ReinH: aha it seems ok
14:42:14 <ReinH> :t (return .)
14:42:15 <lambdabot> Monad m => (a -> b) -> a -> m b
14:42:24 <bitemyapp> ReinH: *nod*
14:52:20 <benzrf> :t (return .) . (>>=)
14:54:25 <dfeuer> Quick qustion: if I'm working on a package, how can I actually tell cabal that I want to build (e.g., some test) using the version I'm working on rather than the system version?
14:56:46 <c_wraith> int-e: lambdabot seems to be down.  (I hope you're still the one running it)
14:58:34 <ski> > ()
14:58:35 <lambdabot>  ()
14:59:09 <c_wraith> ok..  not down.  Just..  not always responding
14:59:27 <paul424> now monads are so fu***cking easy ... a piety I couldn't learn them when I was studying CS under stress
14:59:35 <paul424> and bunch of morons in polish dormitory
14:59:49 <dfeuer> Anyone able to answer that cabal question?
15:01:23 <geekosaur> I'm not sure I understand it. if you're in a sandbox and using a cabal config then it should just work. (if just using ghc, try cabal exec)
15:01:30 <paul424> Does in any other country : student dormitory < homeless center ?
15:02:04 <dfeuer> geekosaur, I don't understand most of this cabal stuff. I don't *think* I'm in a sandbox.
15:06:07 * hackagebot websockets 0.9.3.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.9.3.0 (JasperVanDerJeugt)
15:11:08 * hackagebot wai-throttler 0.1.0.4 - Wai middleware for request throttling  http://hackage.haskell.org/package/wai-throttler-0.1.0.4 (mkulkin)
15:14:22 <mmachenry> Data.Clock.Time's NominalTimeDiff type does not export a constructor. If I want to add a fixed amount of time to a clock time, like 15 minutes, how would I do that? Creating two UTC times 15 mins apart, subtracting them, and using that seems really silly.
15:16:08 * hackagebot wai-throttler 0.1.0.5 - Wai middleware for request throttling  http://hackage.haskell.org/package/wai-throttler-0.1.0.5 (mkulkin)
15:16:22 <hexagoxel> dfeuer: is the working-directory package a different version? then you might be able to simply add a constraint
15:17:14 <dfeuer> hexagoxel, the basic fact is that I basically haven't the slightest f$@$% clue how cabal works, or how to do much of anything with it.
15:17:33 <cfoch> hello
15:17:36 <cfoch> what would you do here
15:17:37 <cfoch> http://dpaste.com/2KC24XT#line-20
15:17:42 <cfoch> to avoid repetition of
15:17:49 <cfoch> returnInitFlags '
15:17:51 <cfoch> =
15:17:52 <cfoch> ??
15:18:48 <c_wraith> mmachenry: isn't it an instance of Num?
15:19:59 <c_wraith> mmachenry: it's an instance of Fractional, too.  You can just use literals
15:20:33 <mmachenry> It is an instance of Num, yes.
15:20:51 <c_wraith> mmachenry: so adding 15 minutes is just addUTCTime (60 * 15)
15:23:40 <mmachenry> c_wraith: Ah I see.
15:23:43 <mmachenry> Thanks
15:24:57 <mmachenry> c_wraith: It actually gives me can't match NominalDiffTime with DiffTime
15:26:08 * hackagebot haskell-docs 4.2.4 - A program to find and display the docs and type of a name  http://hackage.haskell.org/package/haskell-docs-4.2.4 (ChrisDone)
15:26:17 <c_wraith> mmachenry: that...  What?  are you using addUTCTime from the time package's Data.Time.Clock module?
15:26:29 <mmachenry> Yeah
15:27:12 <c_wraith> mmachenry: I have no idea how my example would lead to DiffTime being inferred anywhere.  Unless you have more code involved that's using the same value as another type somewhere else?
15:29:19 <mmachenry> c_wraith: Ah wait sorry, I didn't change both test cases.
15:31:58 <ReinH> cfoch: Well, you can define a short-circuiting monadic `and' combinator
15:33:50 <ReinH> Actually, one already exists in monad-loops
15:34:31 <ReinH>  if andM [return (isPkgRegistered pkgName'), promptYesNo promptOtherNameMsg (Just True)] then getPackageName srcPkgDb flags else returnInitFlags
15:35:20 <shachaf> andM returns a Bool?
15:35:41 <ReinH> andM :: Monad m => [m Bool] -> m Bool
15:35:47 <ReinH> it could be defined as andM (x:xs) = do { b <- x; if b then andM xs else return False }, fwiw
15:35:55 <ReinH> shachaf: Ah, good point
15:36:01 <ReinH> You'd need a monadic bind
15:36:15 <ReinH> getPackage <- andM [...]
15:36:21 <ReinH> if getPackage then ...
15:36:54 <ReinH> or you could use bool
15:37:25 <ReinH> andM [...] >>= bool (getPackageName srcPkgDb flags) returnInitFlags
15:37:40 <ReinH> I'm not sure how much clearer that is than the nested if statements, fwiw
15:41:19 <hexagoxel> or use `MaybeT IO` or `EitherT IO`; the latter can be used to achieve something close to "multiple returns" in imperative languages
15:42:01 <hexagoxel> but indeed for this use-case the as-is is probably fine
15:43:15 <hexagoxel> oh wait, you probably should not add dependencies if you work on Cabal..
15:45:48 <ReinH> You can easily define these functions yourself
15:45:55 <ReinH> bool t f b = if b then t else f
15:46:03 <ReinH> both are one-liners.
15:46:31 <cfoch> ReinH: without Monad.Loops?
15:46:48 <ReinH> cfoch: You can just define the function yourself
16:01:10 * hackagebot vcache 0.2.1 - large, persistent, memcached values and structure sharing for Haskell  http://hackage.haskell.org/package/vcache-0.2.1 (dmbarbour)
16:01:12 * hackagebot direct-murmur-hash 1.0.1 - An implementation of the MurmurHash3 algorithm  http://hackage.haskell.org/package/direct-murmur-hash-1.0.1 (dmbarbour)
16:01:25 <athan> @hackage cascading this looks cool
16:01:25 <lambdabot> http://hackage.haskell.org/package/cascading this looks cool
16:05:34 <ReinH> athan: isn't there one based on lucid as well?
16:05:50 <athan> woah, i didnt know
16:06:37 <athan> oh clay
16:06:39 <athan> ?
16:06:44 <athan> ReinH ^
16:07:14 <bergmark> clay is older than lucid :-)
16:07:32 <athan> oop :x
16:07:49 <ReinH> What bergmark said, but it's still rather nice
16:08:03 <ReinH> I can't find the one I was thinking of, which may or may not actually exist
16:10:54 <kaidelong> I think I might have found a non-trivial co-monoid in haskell:
16:10:57 <kaidelong> instance (Monoid m) => Comonoid (Reader m t) where { destroy reader = runReader reader mempty ; duplicate reader = \(x,y) -> runReader reader (mappend x y) }
16:11:11 * hackagebot b9 0.2.3 - A build tool and library for virtual machine images.  http://hackage.haskell.org/package/b9-0.2.3 (SvenHeyll)
16:11:12 <kaidelong> or something along this line
16:11:30 <kaidelong> oh
16:11:34 <kaidelong> it has to be Reader m ()
16:12:37 <kaidelong> I'm wondering if there's something obvious that I'm missing
16:12:40 <kaidelong> law violation or something
16:13:07 <kaidelong> (I guess there's also the mistake that duplicate has to return a new reader)
16:13:44 <kaidelong> Reader (\(x,y) -> runReader reader (mappend (x,y)) --although using Profunctor is probably more idiomatic here?
16:14:06 <CaptainK> What is the status of the deb.haskell.org security breach?
16:16:21 <octalsrc> is there a way to make (Double, Double) a class instance?
16:16:27 <octalsrc> without using newtype?
16:17:03 <kaidelong> instance Foo (Double,Double) where ...
16:17:04 <aavogt> you just need to enable FlexibleInstances
16:17:22 <octalsrc> ah
16:17:59 <kaidelong> ?? haskell needs an extension for this? (Double,Double) is kind * and completely concrete
16:17:59 <lambdabot> Plugin `compose' failed with: Unknown command: ""
16:18:02 <ReinH> kaidelong: what is the type of your duplicate?
16:18:27 <kaidelong> duplicate :: Reader m () -> Reader (m,m) () ... oh I see
16:18:32 <kaidelong> so it's not quite comonoid
16:18:36 <kaidelong> but it's something really similar!
16:18:54 <ReinH> There might be lots of non-trivial instances of "something similar to a comonoid" ;)
16:19:07 <kaidelong> I am wondering if this might be useful though
16:19:10 <kaidelong> because I am thinking
16:19:18 <kaidelong> this will show up every time you are contravariant on a monoid
16:19:44 <kaidelong> so it could be generalizable to Profunctors
16:19:44 <CaptainK> Anyone know more about the security breach?
16:20:48 <ReinH> kaidelong: Pretty much everything is a profunctor though :)
16:21:05 <kaidelong> ReinH: that's a good thing though, isn't it?
16:21:10 <ReinH> kaidelong: it's pretty handy
16:21:21 <CapitanK> Bad connection here, so nobody has a clue what is going on with the security breach for Haskell's build server?
16:21:34 <kaidelong> CapitanK: last I knew it's still being investigated
16:21:44 <kaidelong> the infected server was taken down really quickly
16:21:48 <kaidelong> so you were probably not affected
16:21:55 <kaidelong> and very few people actually used it
16:22:03 <ReinH> CapitanK: It doesn't seem so.
16:22:04 <kaidelong> it wasn't the one that served the main deb package people used
16:22:35 <ReinH> Let's not hand wave over security breaches with "it's probably fine".
16:22:46 <kaidelong> oh definitely, it's serious
16:23:20 <CapitanK> ok, thanks
16:23:20 <CapitanK> Must be really hard one to track.
16:23:20 <CapitanK> The seriousness of this incident is no small matter.
16:24:25 <CapitanK> Ya, if Ken Thompson did it with a C compiler...who knows what we have now.
16:25:14 <CapitanK> but great they acted quickly
16:26:05 <glguy> I only heard that the server that served the HEAD-debs was compromised, not the build server
16:30:26 <kaidelong> mmm, you can get pretty close to this idea just using contramap already
16:36:12 * hackagebot th-reify-many 0.1.3 - Recurseively reify template haskell datatype info  http://hackage.haskell.org/package/th-reify-many-0.1.3 (MichaelSloan)
16:37:09 <ReinH> kaidelong: all (fully defined) values of Reader m () and Reader (m,m) () are equivalent to const (), though, right?
16:37:39 <kaidelong> ReinH: oh, that'd be true for ReaderT Identity at least, yes
16:37:49 <kaidelong> so the reader instance isn't very interesting
16:37:54 <xaxes`> hello, could someone explain to me why this code is wrong? ghci throws an error: test [x:xs] = putStrLn . show x
16:37:59 <ReinH> kaidelong: You don't even need a Monoid constraint on m, you can just choose undefined instead of mempty
16:38:48 <ReinH> xaxes`: putStrLn . show x is putStrLn . (show x)
16:38:54 <kaidelong> yeah, so you need a different destroy too
16:38:55 <ReinH> (.) expects both arguments to be functions
16:39:02 <ReinH> show x is not a function
16:39:12 <kaidelong> how about
16:39:21 <ReinH> xaxes`: you want putStrLn . show $ x or (putStrLn . show) x
16:39:57 <shachaf> That's one thing you want. But [x:xs] is probably not going to be what you want either.
16:40:05 <shachaf> It means ((x:xs):[])
16:40:06 <ReinH> shachaf: Good point.
16:40:47 <xaxes`> ReinH: I've tried that, but *** Exception: <interactive>:35:5-37: Non-exhaustive patterns in function test
16:41:16 <ReinH> xaxes`: Yes, now that you've fixed the type error, you are getting to the second problem.
16:41:29 <ReinH> xaxes`: Which is the one shachaf just mentioned
16:41:35 <kaidelong> evaluate :: (t ~> r) -> r ; accumulate :: (t ~> r) -> ((t,t) ~> r)
16:41:42 <kaidelong> mmm, now it looks like a continuation
16:41:51 <ReinH> kaidelong: What sort of arrow is ~> ?
16:42:01 <kaidelong> ~> is free
16:42:13 <xaxes`> I wanted to use () instead of []
16:42:20 <kaidelong> I am thinking in every reasonable case it'd be a profunctor, though
16:42:40 <xaxes`> thank you ReinH, shachaf
16:43:03 <ReinH> xaxes`: (although if you only have the (x:xs) case, you will still have a non-exhaustive pattern)
16:43:31 <xaxes`> ReinH: with (x:xs) it works
16:43:38 <kaidelong> class Builder (~>) t r where
16:43:45 <ReinH> xaxes`: yes, it works, but not if given []
16:44:59 <xaxes`> oh
16:45:00 <ReinH> kaidelong: iinm, the first is extract for ((->) r) Comonad, the second is (isomorphic to) join for ((->) r) Monad.
16:45:44 <kaidelong> ReinH: I think you're right
16:47:10 <kaidelong> evaluate is also the wrong name
16:47:13 <kaidelong> it should be something like
16:47:15 <kaidelong> "default"
16:48:25 <kaidelong> so I think that yeah, this is already modelled in existing typeclasses
16:51:34 <kaidelong> @hoogle ((a,b) -> c) -> (r -> a, u -> b) -> ((r,u) -> c)
16:51:36 <lambdabot> No results found
16:52:06 <exio4> I think djinn would be better at that
16:52:27 <kaidelong> well djinn would generate it even if nothing like that is in the base libraries but sure
16:52:33 <kaidelong> @djinn ((a,b) -> c) -> (r -> a, u -> b) -> ((r,u) -> c)
16:52:33 <lambdabot> f a (b, c) (d, e) = a (b d, c e)
16:53:11 <ReinH> Nothing like it is in the base libraries.
16:56:13 * hackagebot b9 0.2.4 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.2.4 (SvenHeyll)
16:56:15 * hackagebot git-date 0.2.2 - Bindings to the date parsing from Git.  http://hackage.haskell.org/package/git-date-0.2.2 (StephenWeber)
17:04:12 <gregnwosu> poll: if you use vim/emacs how do you refactor?
17:07:32 <benzrf> i dont refactor, cause i dont write actual code
17:08:37 <aaronweiss74> gregnwosu: sometimes substitutions, sometimes copy pasta
17:13:48 <HeladoDeBrownie> i find myself doing things like this sometimes: 2GV10Gygt15Gp
17:14:08 <glguy> pasting your password into IRC?
17:14:15 <HeladoDeBrownie> :)
17:14:38 <HeladoDeBrownie> somehow i doubt vim command sequences make very good passwords, as much as they may *appear* to
17:14:43 <HeladoDeBrownie> the problem is they're not very random
17:14:43 <Welkin> the best one I have seen: sexwithjigglypuff
17:15:01 <bananagram> :t fmap
17:15:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:15:23 <Rotaerk> Welkin, how'd you know my password ...
17:15:24 <bananagram> right
17:36:05 <Javran> https://github.com/ghc/ghc/blob/master/compiler/main/DriverPipeline.hs#L1742 -- can someone explain this line to me..?
17:42:20 <ultra_Sabreman> hmm
17:42:49 <ultra_Sabreman> is it possible to add more then one item to the current list in a comprihension?
17:43:00 <ultra_Sabreman> like [ x : (-x) :[] | x <- [0 ..maxBound::Int]]
17:43:06 <ultra_Sabreman> would make a list of lists of ints
17:43:17 <shachaf> What's the current list?
17:43:22 <ultra_Sabreman> ?
17:43:45 <shachaf> I don't understand the words but maybe I understand your intent.
17:43:46 <ultra_Sabreman> Bascially i just want to know how i can make this
17:43:53 <ultra_Sabreman>  [ x : (-x) :[] | x <- [0 ..maxBound::Int]]
17:44:01 <ultra_Sabreman> which outputs a list of lists of ints
17:44:04 <shachaf> You can make that by writing that.
17:44:07 <ultra_Sabreman> to only output a list of ints
17:44:08 <Axman6> how's: [y | x <- [0..maxBound::Int], y <- [x,-x]]?
17:44:10 <shachaf> You could say [y | x <- [1..5], y <- [x, -x]]
17:44:10 <bob_twinkles> ultra_Sabreman: concat $ [ x: (-x) : [] | x <- [0 .. maxBound::Int]]
17:44:26 <shachaf> Or you could concat [[x, -x] | x <- [1..5]]
17:44:26 <serendependy> ultra_Sabreman, I think flatten is what you want?
17:44:34 <ultra_Sabreman> Oooh, thanks guys!
17:44:35 <bob_twinkles> oh, right you don't need the $ there
17:44:36 <ultra_Sabreman> didn't think of that
17:44:36 <serendependy> ah, concat
17:46:12 <ultra_Sabreman> Axman6: shachaf bob_twinkles thank you all
17:52:25 <Javran> I think I've found some Klingon language in ghc's source code
17:52:39 <benzrf> go on
17:54:38 <Javran> https://github.com/ghc/ghc/blob/master/compiler/main/DriverPipeline.hs#L1742 -- it says "this is the code that I must kill"
17:55:36 <Cale> Javran: haha, amusing
17:55:40 <Cale> Seems appropriate too
18:14:31 <neuroserpens> Can anyone tell me what's wrong with this code? pastie.org/9980285
18:15:01 <neuroserpens> I have no idea how to fix this compile time error I'm getting
18:15:28 <SrPx> So, I have a 512x512 image. I want to cut it into 32x32 tiles, and save them as BMPs (0x0.bmp, 0x1.bmp and so on). What is the easiest way to do it using Haskell as the scripting language?
18:15:51 <neuroserpens> Here is the error. pastie.org/9980288
18:17:08 <Axman6> neuroserpens: well, for one, does `... map solve 10 $ ...` make sense?
18:17:50 <Axman6> also, iirc, your code will be parsed as: mapM print $ map solve 10 $ map read $ tail $ (words =<< getContents)
18:18:18 <Axman6> A good start would be replacing all of your $'s with .'s
18:18:44 <neuroserpens> wat? why?
18:19:22 <geekosaur> do you have some reason to believe that what you wrote was correct?
18:19:30 <geekosaur> because it has at least two glaring errors
18:19:41 <neuroserpens> Well... If I wrote it...
18:20:01 <Axman6> neuroserpens: what is the type of map
18:20:19 <neuroserpens> I think telling me what the errors are would be a better use of your time
18:20:52 <geekosaur> whereas asking you to think about your code is a bad use of it?
18:20:53 <Cale> Well, it's really just a confusion between composition and application, I think...
18:20:54 <Axman6> isn't that what I just did?
18:21:12 <neuroserpens> Axman6: That was to the other gay
18:21:14 <neuroserpens> guy*
18:21:15 <neuroserpens> oops
18:21:17 <neuroserpens> sorry
18:21:33 <Cale> oh, right, the map solve 10
18:21:36 <Axman6> have you tried what I suggested?
18:21:55 <neuroserpens> Axman6: Alright. I will. Even though I don't see why.
18:22:03 <Cale> Try  mapM print . map (solve 10) . map read . tail . words =<< getContents
18:22:04 <Axman6> remember that map solve 10 is ((map solve) 10)
18:22:19 <Axman6> you wanted map (solve 10)
18:22:28 <neuroserpens> No
18:22:33 <Axman6> no?
18:22:36 <neuroserpens> I want map with 10 and the list
18:22:40 <neuroserpens> oops
18:22:43 <Axman6> I'm pretty sure you mean yes
18:22:43 <Cale> er...
18:22:45 <neuroserpens> I want solve with 10 and the list
18:22:47 <neuroserpens> rofl
18:22:49 <neuroserpens> I'm confused
18:22:50 <geekosaur> neuroserpens, Axman7 poiinted you at two places to look fpr errors, your response was "wat, why". I merely pointed out that you were shown two places to look for errors
18:22:57 <Cale> So, not map :)
18:23:33 <neuroserpens> I'm not really sure how I'd rewrite this with dots too
18:23:39 <neuroserpens> I have never really used them
18:23:48 <Axman6> Cale showed you exactly how to rewrite it...
18:23:56 <neuroserpens> Did he?
18:24:00 <neuroserpens> Just a sec
18:24:03 <Axman6> 13:20:45 < Cale> Try  mapM print . map (solve 10) . map read . tail . words =<< getContents                            │
18:24:03 <Cale> <Cale> Try  mapM print . map (solve 10) . map read . tail . words =<< getContents
18:24:17 <neuroserpens> oh crap sorry I didn't even see that message
18:24:42 <Axman6> or, even better, mapM_ (print . solve 10 . read) . tail . words =<< getContents
18:25:27 <neuroserpens> I got practically the same error with Cale's version
18:25:32 <neuroserpens> trying Axman6's
18:25:57 <Cale> neuroserpens: Well, you'll still get an error about solve with what I wrote because you didn't tell us the type of solve before
18:26:10 <Cale> neuroserpens: So it wasn't clear that you were wrong about mapping it over the list
18:26:28 <Cale> ghci> :t \solve -> mapM print . map (solve 10) . map read . tail . words =<< getContents
18:26:28 <Cale> \solve -> mapM print . map (solve 10) . map read . tail . words =<< getContents
18:26:28 <Cale>   :: (Show a, Read a1, Num a2) => (a2 -> a1 -> a) -> IO [()]
18:26:45 <neuroserpens> I think... Int -> Double -> Double ?
18:26:45 <funfunctor> hi
18:27:00 <Cale> neuroserpens: You said it took a list...
18:27:18 <neuroserpens> Cale: Yes... I think I'm drunk
18:28:12 <neuroserpens> No... There's no way solve should get a list... I'm crazy
18:28:39 <neuroserpens> Then again
18:28:42 <neuroserpens> map will return a list
18:28:44 <neuroserpens> holy crap
18:28:57 <neuroserpens> I have no idea what I am doing
18:29:01 <Cale> okay :D
18:29:18 <neuroserpens> This is what I'm trying to solve by the way
18:29:34 <neuroserpens> http://www.hackerrank.com/challenges/eval-ex
18:31:02 <Cale> Does anyone else think it's funny how every problem of this sort starts with this spurious number that tells you how many test cases will follow?
18:32:08 <SrPx> Nobody? :(
18:32:10 <neuroserpens> Cale: lol
18:33:28 <hakujin> with the changes in 7.10 is mapM going to be replaced by traverse? i.e. map = fmap style definition
18:35:25 <geekosaur> SrPx: you might want to ask on the haskell-cafe mailing list
18:36:43 <Cale> SrPx: Oh, I missed your question amongst all the netsplits above
18:37:36 <Cale> SrPx: I dunno, I guess it depends on what image library is your favourite. JuicyPixels should be able to do it easily enough.
18:38:10 <SrPx> geekosaur: uh... I never used the mailing list but I guess I prefer to leave them alone, I already annoy you enough here :(
18:39:10 <geekosaur> actually the list is better for not-annoying because people can look at the subject and delete unread if they don't care :)
18:39:52 <geekosaur> and you don't have to hope that someone who knows the answer is on when you are
18:41:01 <neuroserpens> geekosaur: That hope is the whole point
18:41:02 <neuroserpens> lol
18:41:17 * hackagebot MonadCompose 0.6.0.0 - Methods for composing monads.  http://hackage.haskell.org/package/MonadCompose-0.6.0.0 (JamesCandy)
18:41:36 <Cale> SrPx: check out this library http://hackage.haskell.org/package/JuicyPixels
18:41:40 <neuroserpens> Cale: Helpppp :'| lol
18:42:06 <Cale> neuroserpens: What's wrong?
18:42:22 <SrPx> Cale: I'm reading it right now, thanks... I can't find a "crop" function but there is writePixel/readPixel so I guess I can implement it
18:42:30 <SrPx> thanks
18:51:18 * hackagebot Wordlint 0.2.0.0 - Plaintext prose redundancy linter.  http://hackage.haskell.org/package/Wordlint-0.2.0.0 (bgbgbg)
18:51:52 <SrPx> Cale: sorry but https://hackage.haskell.org/package/JuicyPixels-3.2.2 seems not to be listing everything that the lib has (it only shows the Codec package)... what do you do on this case? Download the source?
18:52:28 <SrPx> the codec module
18:53:14 <SrPx> oh my bad - it is indeed all it has :P
18:58:28 <neuroserpens> Alright I'm almost giving up on this @#$%... pastie.org/9980335 Pretty please someone help and I'll buy you pizza
18:58:29 <neuroserpens> and beer
18:58:38 <neuroserpens> and an ice cream
18:59:46 <neuroserpens> Cale: Do you like pizza, beer and ice cream?
19:00:15 <silasm> :t (/)
19:00:16 <lambdabot> Fractional a => a -> a -> a
19:01:05 <neuroserpens> silasm: Does that mean n's type should be Fractional?
19:01:25 <silasm> Yes, and that it needs to have the same type as (x^n)
19:01:45 <silasm> :t fromInteger
19:01:46 <lambdabot> Num a => Integer -> a
19:01:54 <neuroserpens> I don't get it
19:03:08 <silasm> your expression includes `x ^ n / n' where `x' is a double (so `x ^ n' is a double).
19:03:13 <silasm> :t (^)
19:03:14 <lambdabot> (Num a, Integral b) => a -> b -> a
19:03:25 <neuroserpens> silasm: Yes...
19:04:00 <geekosaur> haskell is strictly typed; it does not automatically promote integral types to fractional types, or indeed any other kind of automatic promotion
19:04:16 <silasm> and the type of (/) specifies that both its arguments must be of the same type, and that that type must be fractional.
19:04:29 <geekosaur> (there is a bit of a hack where numeric literals can have any type)
19:05:09 <neuroserpens> I tried declaring all as double and I get an error saying there's no instance for integral double arising from the use of ^
19:05:18 <silasm> so you have to convert the Int (n) to double using fromInteger where you divide it, ala `x ^ n / fromInteger n'
19:05:47 <neuroserpens> hm... trying
19:05:51 <silasm> yeah, it's a bit of a complicated case since it has to be an Int in one place and a double in another
19:06:11 <cfoch> Hello. Please, could somebody give me a hand?
19:06:12 <cfoch> https://github.com/cfoch/paul/blob/master/Main.hs
19:06:28 <silasm> but it's all just strict typing at work, if you know the types and you know how to convert between them as needed (in this case fromInteger), you can solve it.
19:06:41 <cfoch> I am trying to extract a line of the file "pg.cv" with readGoogleFinanceHistoryCV
19:07:26 <cfoch> but I get "\"0-Feb-15,84.95,85.05,84.19,84.87,958133\""
19:07:29 <cfoch> instead of
19:07:36 <neuroserpens> silasm: LoL. Now it ran but my results were totally off hahaha
19:07:36 <cfoch> "0-Feb-15,84.95,85.05,84.19,84.87,958133"
19:07:49 <neuroserpens> silasm: Thanks though, but I'm throwing the towel for now
19:08:29 <silasm> no problem, good luck in your haskelling :)
19:09:35 <SrPx> Cale: did you use the library before?
19:10:08 <SrPx> I don't understand something - when I load an image with readImage, it returns a DynamicImage. Problem is, most functions of the library are for Image (not DynamicImage) and it doesn't say how to convert
19:10:30 <SrPx> If i understand correctly, DynamicImage has a constructor for each possible Image type
19:10:52 <Javran> cfoch: you don't need to show a string, can just return it
19:10:56 <Javran> > "test"
19:10:57 <lambdabot>  "test"
19:11:01 <Javran> > show "test"
19:11:02 <lambdabot>  "\"test\""
19:11:44 <cfoch> Javran: ah... so this is something of Show
19:11:54 <funfunctor> kallisti_: asleep?
19:12:10 <cfoch> Javran: thanks
19:12:29 <cfoch> I would like to make a program to try to predict stock market
19:12:45 <mjrosenb> cfoch: glhfdd
19:13:05 <silasm> cfoch: sometimes it's useful to keep in mind that show is more for serializing / debugging than for pretty printing. `show' is supposed to be an "inverse" of `read', so it has to present the data in a form that's convenient for reading back in.
19:13:53 <mjrosenb> with reactive-banana, or some generic-ish FRP framework, what would the recommended way to have multiple screens that you can switch between?
19:14:09 <silasm> which is why `show' in the string case adds extra quotes, so that the string being shown is a valid string literal.
19:17:30 <dibblego> which is that extension that shortens (\x -> case x of )?
19:17:46 <shachaf> LambdaCase
19:17:52 <dibblego> thanks
19:20:02 <mjrosenb> ooh, I like lambda case, it feels like sml!
19:20:30 <jle`> is there a standard method of representing a value of a tagged union in maths
19:20:44 * mjrosenb sees if ghc has disjunctive patterns yet
19:20:49 <jle`> representing products is done all the time, <x,y>, (x, y), etc.
19:20:54 <mjrosenb> jle`: I am not sure what you are asking
19:21:19 * hackagebot vivid 0.1.0.0 - Sound synthesis with SuperCollider  http://hackage.haskell.org/package/vivid-0.1.0.0 (TomMurphy)
19:21:31 <jle`> like if i wanted to write a value from a product of integers and bools on a whiteboard in a math class i'd use something like <5, True>
19:21:49 <jle`> but a value from a tagged union/sum/coproduct of integers and bools?
19:22:13 <benzrf> jle`: just write Left 3
19:22:15 <benzrf> :)
19:22:19 <jle`> :3
19:22:35 <benzrf> more seriously: y not just the value.
19:22:42 <jle`> that was my first guess but. was looking for an accepted standard everyone would recognize
19:22:47 <benzrf> given the context of the set, its unambig
19:22:47 <mjrosenb> jle`: math usually uses untagged unions :-/
19:23:02 * benzrf googles disjoint union element notation
19:23:16 <jle`> how would i represent a value from 1 + Integers? (Maybe Int)
19:23:30 <shachaf> jle`: I think the usual set theory definition of a tagged union is something like {(0,x) | x <- A} U {(1,y) | y <- B}
19:23:43 <shachaf> But that's not great notation.
19:24:09 <shachaf> jle`: Usually you would add some formal element. Sometimes you'd call it ٭ or something.
19:24:15 <benzrf> jle`: define a symbol for the point
19:24:19 <benzrf> then use a normal int otherwise
19:24:22 <shachaf> Of course you run into trouble with Maybe (Maybe a) there.
19:24:35 <mjrosenb> shachaf: just use two symbols?
19:24:51 <benzrf> jle`: for disjoint union elements, you could write something like (L, 1) (R, False)
19:24:54 <mjrosenb> one is Nothing, the other is Just Nothing.
19:25:15 <jle`> hm. thanks :) nothing ideal but definitely usable for whiteboard purposes
19:25:29 <jle`> i might use like a bar or something to distinguish from a vs. Just a
19:25:33 <shachaf> mjrosenb: Well, now you have a polymorphic function :: Maybe a -> B
19:25:52 <shachaf> mjrosenb: If a is instantiated to Maybe c, and they both used the same symbol, you run into trouble.
19:25:59 <shachaf> That's why you need the Just tag in Haskell. :-)
19:26:03 <shachaf> But informally it's probably fine.
19:26:22 <benzrf> jle`: well
19:26:31 <benzrf> jle`: if you're talking about sets, there /is/ no distinction between 3 and Just 3
19:26:44 <shachaf> I think the fact that Maybe (Maybe a) is distinguished from Maybe a is one of the most important features of Maybe (compared to null or something in your typical dynamically-typed language).
19:26:45 <benzrf> 3 is an element of both ℕAND ℕ∪1
19:26:52 <benzrf> shit it ate my spaces :(
19:27:45 <shachaf> Anyway I don't think there's a real standard for sums of sets, just because set theorists don't tend to talk about sums much. :-(
19:28:13 <shachaf> You can make up your own notation easily enough.
19:28:24 <shachaf> Oh, I guess i_0 and i_1 are sort of popular names for Left and Right.
19:28:29 <apo> shachaf: A non-null pointer can point at null easily enough :p
19:28:39 <shachaf> apo: ?
19:28:59 <apo> schlumpi: int *a = 0; int **b = &a;
19:29:03 <Hijiri> ptr = null as opposed to *ptr = null
19:29:18 <apo> schlumpi: b isn't null but points at a which is null
19:29:29 <funfunctor> EvanR: up and around?
19:30:34 <shachaf> apo: Yes, C pointers also have this feature (at the cost of an extra layer of indirection for each layer of NULL, not that Haskell avoids that).
19:30:47 <shachaf> apo: But lots of languages with null don't.
19:30:52 <mjrosenb> also, in case anyone just showed up, does anyone know of a use case of reactive-banana where a single handler would get registered multiple times?
19:31:11 <apo> shachaf: I guess. Don't work with those languages too much, so I don't tend to think of them. But yeah :)
19:32:07 <EvanR> funfunctor: yerp
19:32:43 <SrPx> Is there any way to make this shorter? http://lpaste.net/121157
19:33:08 <funfunctor> EvanR: :) i'm still battling to understand how to remove all this state
19:33:18 <johnw> join $ either putStrLn <$> readPng ...
19:33:55 <EvanR> funfunctor: whats wron
19:35:02 <funfunctor> EvanR: well I teared out StateT from the RadioDevice implementations in https://github.com/victoredwardocallaghan/hbts/commit/4fc1e09c3a07864c80182d90cd576119e0484b91
19:35:11 <johnw> oops, add another putStrLn
19:35:41 <EvanR> ok
19:36:20 * hackagebot bindings-nettle 0.2 - bindings to nettle crypto library  http://hackage.haskell.org/package/bindings-nettle-0.2 (ClintAdams)
19:37:19 <funfunctor> EvanR: but I can't understand how I am to deal with states in http://lpaste.net/121078 like isSuperSpeed, mRxCorrectionI and various other states like timestamps
19:38:07 <EvanR> yesterday it turned out that you didnt need the "states" that the c++ code was using
19:38:08 <funfunctor> my mind is stuck on the idea that these are global states intrinsically and can't be designed how
19:38:27 <funfunctor> yea I am just not seeing it
19:38:28 <EvanR> a direct translation of c++ is likely to be not good
19:38:48 <funfunctor> no of course, hence I am trying to understand the jump between paradigms
19:38:59 <EvanR> and im looking at all the c++ and it makes me dizzy
19:39:45 <funfunctor> EvanR: this is what I have so far https://github.com/victoredwardocallaghan/hbts/blob/master/src/BTS/RadioDevice/BladeRFDevice.hs
19:39:51 <EvanR> is super speed a configurable parameter at any time or is it an initialization
19:40:36 <funfunctor> Its at initialsation
19:41:14 <EvanR> then its not a state
19:42:12 <funfunctor> EvanR: exactly but I have to pass it around
19:42:23 <funfunctor> along with a bunch of other stuff
19:42:44 <johnw> funfunctor: then do that
19:43:12 <funfunctor> isSuperSpeed is the easy one
19:43:48 <johnw> in Haskell, we use types to communicate meaning; if the meaning of your function depends on global state, you express that in the type by specifying it as an argument, or using the State/Reader monads
19:44:10 <EvanR> funfunctor: good, so whats the hard one
19:44:17 <ultra_Sabreman> ok guys im gonna be honest
19:44:26 <Axman6> please do
19:44:29 <ultra_Sabreman> I'm compleatly and totaly stuck on a haskell hw assignemnt right now
19:44:40 <ultra_Sabreman> and would like some help
19:44:52 <ultra_Sabreman> If you can't/won't that's obv ok
19:44:55 <johnw> ask away
19:44:57 <Axman6> well, we won't write your assignment for you, but we will help you understand things
19:44:58 <ultra_Sabreman> but heres the thing:
19:45:00 <ultra_Sabreman> http://pastebin.com/xEhzjGy0
19:45:03 <johnw> we may give you hints instead of answers
19:45:04 <ultra_Sabreman> Question 2
19:45:07 <funfunctor> EvanR: keeping track of timestamps with the corresponding buffer
19:45:08 <Hijiri> if your homework policy allows you to get help, then sure
19:45:19 <ultra_Sabreman> I would be asking my instructor right now
19:45:23 <ultra_Sabreman> but it's way to late
19:45:25 <ultra_Sabreman> in the night
19:45:38 <ultra_Sabreman> and i really just want to get this shit done.....
19:45:51 <EvanR> funfunctor: keeping track... sounds kind of like "managing"
19:46:07 <Hijiri> someone else's instructor came in here the other day because homework chat tripped their homework sensors
19:46:10 <Hijiri> so it's at your own risk
19:46:25 <Axman6> ultra_Sabreman: quit complaining and ask some actual questions please =)
19:46:27 <ultra_Sabreman> i dont want an awnder really
19:46:30 <ultra_Sabreman> just help
19:46:33 <EvanR> funfunctor: yesterday, writeSamples and readSamples seemed pretty straightforward as far as timestamps go, the current timestamp is passed in as an argument even in c++
19:46:35 <funfunctor> EvanR: symbol managing ?
19:46:36 <ultra_Sabreman> #2 on that pastebin
19:46:42 <Hijiri> what are you stuck on?
19:46:49 <ultra_Sabreman> im not even sure what that question is asking...
19:46:58 <ultra_Sabreman> http://pastebin.com/xEhzjGy0
19:47:06 <Hijiri> finite type, as in there are only a finite number of inhabitants
19:47:06 <ultra_Sabreman> down at the bottom
19:47:10 <funfunctor> EvanR: no no, the current timestamp is not the issue here, ofcourse thats just a argument
19:47:20 <Axman6> looks pretty simple to me. how about you ask some questions
19:47:22 <ultra_Sabreman> Yeah, I have the class + instances already defined up top
19:47:32 <EvanR> funfunctor: im still not clear exactly what you mean when keeping track of time stamps
19:47:40 <funfunctor> EvanR: referencing the original start time or previous timestamp seems stateful to me
19:47:42 <Axman6> you have only stated you want help, but we can't help if we don't know what issues you're having
19:47:45 <ultra_Sabreman> ok so
19:48:02 <ultra_Sabreman> From what i uderstnad i need to instance show so that I can print functions of type a -> b
19:48:09 <EvanR> funfunctor: yeah, startTime ended up being a hidden state variable which is reset every time you restart the driver
19:48:10 <ultra_Sabreman> assuming a and b are of the finite type
19:48:24 <Axman6> well, only assuming a is Finite
19:48:30 <ezrios> (Finite type*class*)
19:48:37 <ezrios> minor but important distinction
19:48:45 <Hijiri> b doesn't need to be finite
19:48:58 <funfunctor> EvanR: but how does a "hidden state" work in practice?
19:49:01 <ezrios> a and b need to be Show though
19:49:02 <ultra_Sabreman> ok yeah i see that
19:49:04 <Axman6> I would guess the idea is that if you give it say the not function, it should show you "False => True\nTrue => False"
19:49:11 <EvanR> funfunctor: you already did it, with rxGain
19:49:23 <ultra_Sabreman> I think so
19:49:25 <Axman6> so it should for all inputs of type a what the output is
19:49:36 <ultra_Sabreman> the problem is, and where im stuck
19:49:46 <ultra_Sabreman> how do i get the types of the parameters for the function?
19:49:49 <ultra_Sabreman> Can i even?
19:49:54 <ultra_Sabreman> or am i approching it wrong
19:49:54 <Axman6> why do you need to?
19:49:56 <ezrios> ultra_Sabreman: why do you need that
19:50:02 <Hijiri> you don't need them, as long as you know the input is finite
19:50:02 <ultra_Sabreman> yep, approaching it wrong
19:50:05 <ultra_Sabreman> lol
19:50:06 <ezrios> all you need to know is that a has a Finite instance
19:50:07 <Hijiri> and showable
19:50:08 <ezrios> and a Show instance
19:50:10 <Hijiri> and that the output is showable
19:50:15 <Axman6> all you need to know is that a is Finite. what does the Finite class give you?
19:50:16 <ezrios> a bit echoey in here
19:50:22 <ezrios> must be the netsplits
19:50:27 <funfunctor> EvanR: yes but how is the function readSamples going to get to know about a newIORef inside constructBladeRFDevice?
19:50:27 <EvanR> Finite... Finite...
19:51:03 <EvanR> funfunctor: its either in scope or you pass it in as an argument to the function
19:51:16 <EvanR> in which its also in scope, just somewhere else
19:51:36 <ezrios> Hijiri: recall that we can think of functions as tables
19:51:47 <ezrios> with two columns, x and f(x)
19:51:47 <Hijiri> ezrios: ok
19:51:50 <ezrios> er
19:51:53 <ezrios> ultra_Sabreman: ^
19:51:56 <Hijiri> :P
19:51:58 <ezrios> haha
19:52:04 <shachaf> I suggest that this session be taken to #haskell-overflow
19:52:17 <ezrios> or maybe haskell-beginners?
19:52:19 <funfunctor> EvanR: but then the type signature of readSamples is going to change and then I can't put it in the RadioDevice record
19:52:46 <ultra_Sabreman> ezrios: haskell-beginners sounds like the place for me :p
19:53:23 <shachaf> It's not related to this channel. Beginners are fine here.
19:53:37 <shachaf> But long conversations are better in #haskell-overflow just because they take over the channel.
19:53:39 <EvanR> funfunctor: yeah you can
19:53:57 <ezrios> shachaf: ah I see. Was wondering why, the question was certainly Haskell related
19:54:06 <funfunctor> EvanR: sorry can you show me what you mean?
19:54:12 <EvanR> yes
19:54:17 <funfunctor> thx
19:54:32 <ultra_Sabreman> Ok I *think* I see this now.
19:54:38 <ultra_Sabreman> maybe
19:54:53 <ultra_Sabreman> hmm
19:55:10 <shachaf> So: The conversation is fine, but #haskell-overflow is a better place for it.
19:56:14 <Welkin> I thought that was for discussion of 32 bit vs 64 bit in regard to overflow, and why we need arbitrary precision
19:57:00 <EvanR> funfunctor: http://lpaste.net/121158
19:57:12 <EvanR> Welkin: hahaha
19:57:20 <EvanR> #haskell-fixedpoint
19:57:30 <EvanR> discussion against dropping floats
19:57:33 <EvanR> or for
19:57:53 <Welkin> let's start #haskell-zoo
19:58:02 <dulla> fixedpoint? EvanR
19:58:35 <EvanR> fixed point arithmetic
19:59:14 <funfunctor> EvanR: alright.. I know that but who is going to pass the IORef to the starttime for example
19:59:34 <EvanR> funfunctor: the constructor
19:59:35 <funfunctor> inside RadioDevice?
19:59:38 <funfunctor> ok
19:59:46 <funfunctor> I get where your coming from now
20:00:12 <funfunctor> push all the marshaling into the constructor as hidden IORef's
20:00:20 <dulla> what is fixedpoint
20:00:30 <EvanR> funfunctor: by having different functions that satisfy the same type, you can have dynamically determined behaviors at runtime
20:00:39 <funfunctor> dulla: a point that is said to be fixed? :)
20:01:33 <funfunctor> EvanR: alright cool, i'll have a go then
20:01:45 * funfunctor wonders back to vim with hands in pockets
20:07:23 <tertu> so I have a function of type (Floating a, Integral b) => a -> a -> b -> a
20:07:52 <tertu> if i have other functions that pass all of its arguments to that function from something derived from its own arguments
20:08:07 <tertu> will haskell be able to figure that out by itself?
20:08:32 <Axman6> I don't understand the question
20:08:41 <Axman6> perhaps an example would help?
20:11:35 <tertu> http://lpaste.net/121159
20:11:43 <tertu> well it complained about some extra brackets
20:12:37 <tertu> i had an earlier version of this where both those functions had a constraint (Floating a, Integral b) on them and that ran
20:13:29 <Axman6> so the type increaseByYears :: a -> a -> b -> a says that is must be able to take arguments of _any_ type at all. if you need to restrict the types, you'll need to add class constraints. comment out tht line and see what ghci says the type is
20:15:49 <tertu> yeah it uh
20:15:54 <tertu> doesn't even compile then
20:16:27 <Axman6> what did you do?
20:17:03 <tertu> oh actualy
20:17:45 <tertu> the parentheses it told me were redundant? those were what was making it not grab the tuple and complain about that last bit being (a, b) rather than [a, b]
20:18:59 <Axman6> well, sharing the actual error you're getting is usually an excellent way of gettion people to help you =)
20:20:00 <tertu> i wasn't having an error before, but i took out the constraints and then it threw an error about the types being wrong
20:20:09 <tertu> so i put the constraints back in and it works just fine
20:20:42 <Welkin> dmr?
20:20:57 <tertu> hmm?
20:20:57 <ultra_Sabreman> Ok I got somehere now
20:21:06 <ultra_Sabreman> But I'm still stuck (this really stinks)
20:21:07 <Cale> Welkin: No, he just removed the type class constraints
20:21:14 <tertu> yeah
20:21:16 <Cale> (which are required)
20:21:20 <ultra_Sabreman> http://pastebin.com/k3PtUGVB
20:21:23 <tertu> and then it complained about there not being type class constraints
20:21:28 <ultra_Sabreman> The idea as far as I understand it
20:21:46 <ultra_Sabreman> is to grab all possible things from finite
20:21:55 <ultra_Sabreman> of the appropriate type
20:22:01 <ultra_Sabreman> and run the function on it
20:22:09 <ultra_Sabreman> then just print all of the input => output pairs
20:22:18 <Cale> ultra_Sabreman: It appears you want to turn on {-# LANGUAGE ScopedTypeVariables #-}
20:22:36 <Cale> ultra_Sabreman: and then add an explicit forall a b. to the instance declaration
20:23:09 <Cale> ultra_Sabreman: Because the expression signature (elems :: [a]) doesn't use the a from the instance head
20:23:21 <ultra_Sabreman> Cale: theres no other way around this?
20:23:46 <ultra_Sabreman> Also, I don't really know wtf is going on here anymore so please explain
20:23:48 <Axman6> or just drop the type signature, it's not necessary
20:24:02 <ultra_Sabreman> Like, I know what IM trying to do with it, but the instance signature was provided for us.
20:24:37 <ultra_Sabreman> ugh, not understanding haskell is so frustrating sometimes
20:25:08 <Axman6> ultra_Sabreman: how about you start with a function that looks like: showPair :: (Show a, Show b) => (a -> b) -> a -> String which would give you strings of the form "input => f(input)"
20:25:39 <Cale> I think you want   show f = concat [show x ++ " => " ++ show y | (x,y) <- map (\x -> (x,f x)) elems]
20:26:22 * hackagebot pack 0.4.0 - Bidirectional fast ByteString packer/unpacker  http://hackage.haskell.org/package/pack-0.4.0 (capsjac)
20:26:26 <Axman6> so showPair f x = "<x as a string> => <f applied to x as a string>"
20:26:42 <Axman6> Cale: don't do people's homework for them :(
20:26:55 <Cale> I had no idea this was homework
20:27:16 <Axman6> ah, thought you'd need that earlier
20:27:28 <Cale> But also I reserve the right to do people's homework for them :)
20:27:39 <Axman6> heh
20:27:55 <ultra_Sabreman> Axman6: dont worry, I'm still not sure wtf is going on
20:28:08 <ultra_Sabreman> but dammit, I'll figure it out
20:28:18 <ultra_Sabreman> It's been driving me crazy for like 3 hours now
20:28:50 <Cale> ultra_Sabreman: One problem with what you wrote originally is that when you write something like [(x,y) | x <- xs, y <- ys] it enumerates all possible selections of x from xs and y from ys independently.
20:28:56 <Axman6> you just need to break it down into smaller steps
20:29:04 <Cale> > [(x,y) | x <- [1..3], y <- [1..3]]
20:29:05 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
20:29:43 <ultra_Sabreman> Ok so
20:29:50 <Cale> ultra_Sabreman: But what was causing the problem was that it didn't know what type of list to use for elems in x <- elems, because you never applied the function f to it
20:29:52 <ultra_Sabreman> I know the concept of what I'm trying to achive
20:30:49 <ultra_Sabreman> Aka: printing all possible input->output pairs
20:30:55 <ultra_Sabreman> I can do that.
20:31:07 <ultra_Sabreman> erm, the simple pair printing bs,
20:31:12 <Welkin> > [(x,y) | x <- [1..5], y <- [x..5] ]
20:31:13 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,...
20:31:15 <ultra_Sabreman> it's this whole type buisness that's throwing me a for a loop
20:31:18 <Cale> Instead of applying f to x, you went and did another generator, selecting y from map f elems, independently of the x which was selected
20:31:37 <Cale> So, if you just write x <- elems
20:31:44 <Cale> and then show x and show (f x)
20:31:47 <Cale> it ought to work
20:32:02 <Cale> It'll know which type x has to be, because you applied f
20:32:13 <Axman6> ultra_Sabreman: I don't think you want all possible input-putput pairs, I think you only want the input and output for the given input pair, for all inputs
20:33:23 <ultra_Sabreman> Axman6: I mean, giving a func (Bool -> Int), I want to run func on True and False, then print the pairs
20:33:44 <ultra_Sabreman> so (True, 12343) (False, 4567)
20:37:41 <ultra_Sabreman> god
20:37:44 <ultra_Sabreman> fucking
20:37:46 <ultra_Sabreman> dammit
20:37:48 <ultra_Sabreman> are you kidding me
20:38:03 <ultra_Sabreman> http://pastebin.com/HhLQYJ4j
20:38:06 <ultra_Sabreman> Cale: this works
20:38:07 <Axman6> ultra_Sabreman: right. so how about you start by writing a functions which: takes a function, and an input, and gives you a tuple of the inout, and the function applied to the input
20:38:08 <ultra_Sabreman> now
20:38:10 <ultra_Sabreman> wtf
20:38:12 <ultra_Sabreman> WHY
20:38:14 <ultra_Sabreman> does it work
20:38:58 <Axman6> ultra_Sabreman: how about we head to another channel and talk it through
20:39:16 <Axman6> #haskell-overflow was suggeted earlier so let's go there?
20:39:21 <ultra_Sabreman> yeah
20:41:18 <jle`> is there a Monad instance for data Scan a = Scan ([Int] -> [a])
20:42:02 <jle`> i guess it is Compose ((->) [Int]) []
20:42:29 <HeladoDeBrownie> monad . monad doesn't always give a monad, does it?
20:42:33 <jle`> mhm
20:42:37 <jle`> but it gives us an Applicative
20:50:02 <ultra_Sabreman> Ok, I get everything now, it's all good.
20:50:27 <ultra_Sabreman> Thanks guys. Cale Axman6 and evyone else who i lost in the scrollback
20:54:03 <SrPx> So, to you guys using JuicyPixel here, is this how you load an image? http://lpaste.net/121163 or I am missing something?
20:54:37 <stacks_> the nsa has their hands in everything. Very informative and powerful documentary about Edward Snowden called Citizenfour http://weshare.me/e33be3d590f32460/Citizenfour_(2014)_-_The_Edward_Snowden_Story.mp4
20:54:41 <chirpsalot> SrPx: you are missing the DynamicImage stuff.
20:55:02 <SrPx> chirpsalot: sorry, what do you mean?
20:56:57 <SrPx> Also, does anyone know if there is any way to convert Gloss's BMP format to juicypixel's Image (so you can save a gloss render to disk?)
20:57:12 <SrPx> There is juicy-gloss, but I only found functions to go the other way around (from juicy to gloss)
21:02:26 <chirpsalot> SrPx: sorry, I got confused. readPng does use the DynamicImage type. What you have should work, but I am not 100% sure you need all of the cases. Every time I have used JuicyPixels I have been kind of disappointed, though.
21:02:53 <SrPx> chirpsalot: I see. Why you've been disappointed with it?
21:05:23 <chirpsalot> SrPx: bit tired, so I didn't phrase that well. It's probably just that I don't understand the library well, but it seems like a big hassle to deal with images with different pixel types. I don't think there's a super easy way to just cast an image to one in a different colour space.
21:06:49 <SrPx> I see. Do you recommend something else? I just want to load an image, slice it in 32x32 blocks and save to a file.
21:06:59 <chirpsalot> SrPx: this graph always hurt my wee brain. https://hackage.haskell.org/package/JuicyPixels-3.1/docs/Codec-Picture-Types.html#g:5
21:07:52 <SrPx> TBH, I've spend the last hours reading about JuicyPixels so I could do it with it at this point, I guess. But I'm looking for something simpler for the next time.
21:07:57 <SrPx> spent
21:08:09 <chirpsalot> SrPx: I think JuicyPixels is the best option. I have heard good things about it, but every time I try to use it I find it gets really complicated.
21:08:14 <SrPx> chris2: and yes, I've seen it... scary
21:08:30 <SrPx> chris2: sorry!
21:09:13 <SrPx> chirps a lot ... I read "chris a lot"
21:09:51 <SrPx> But alright, thanks!
21:10:21 <SrPx> It is not complicated, I just find that case cascating horrible :(
21:10:26 <chirpsalot> SrPx: it should be pretty easy to do what you want in JuicyPixels.
21:11:20 <jle`> huh i made a category homomorphism by mistake
21:11:25 <chirpsalot> SrPx: you might be able to get away without.
21:11:32 <SrPx> I guess JuicyPixels could offer a function "loadImageAs" such that it loaded the image you want and gave it to you on whatever format you want to be using it. So you don't need 2 layers of cases just to get the stuff
21:11:38 <jle`> s g . s f = s (g . f)
21:11:47 <jle`> s id = id
21:11:56 <jle`> totally did not see that coming
21:12:19 <shachaf> That's called a functor.
21:12:19 <SrPx> uh that looks correct ?
21:12:29 <jle`> it is a one-way homomorphism though.  is there a special word for those?  or is a one-way homomorphism a special name for something more general
21:12:32 <jle`> shachaf: oh yeah huh
21:12:34 <jle`> haha
21:12:43 <nshepperd> JuicyPixels is fine, it really just needs a convertColorSpace :: (Pixel a) => DynamicImage -> Image a
21:12:50 <shachaf> "homomorphism" only means one way.
21:12:50 <nshepperd> or something along those lines
21:13:13 <SrPx> yea exactly... I wonder if they'd accept a pull request
21:13:15 <jle`> what's the two-way one?
21:13:26 <shachaf> isomorphism
21:13:52 <jle`> what's a homomorphism where the domain and codomain are the same?
21:13:56 <jle`> i always mix these up
21:14:05 <darkroom> is there a way to patch a haskell application while it is running?
21:14:25 <chirpsalot> nshepperd: SrPx I looked into doing that, but for some reason I decided it wasn't as trivial as it sounds.
21:14:29 <nshepperd> jle`: endomorphism?
21:14:44 <SrPx> chirpsalot: it is not? Elaborate?
21:15:06 <shachaf> "endo" means the domain is equal to the codomain. So endohomomorphism or something.
21:15:12 <chirpsalot> SrPx: I think it had to do with the fact that it's not possible to go between certain pixel types. Like if you look at the graph.
21:15:12 <shachaf> "homomorphism" is actually not a meaningful term.
21:15:26 <shachaf> Except "arrow in your favorite category".
21:15:29 <jle`> what is an automorphism? is that different than an endomorphism?
21:15:36 <chirpsalot> SrPx: like there's no way to go from anything under Pixel16 to everything else?
21:15:43 <shachaf> An automorphism is an isomorphism which is also an endomorphism.
21:15:53 <shachaf> I.e. an isomorphism : A -> A for some A.
21:16:15 <jle`> i see
21:16:30 <jle`> an endomorphism isn't required to be any sort of ____ homomorphism
21:16:42 <jle`> oh there's a nice little tree on wikipedia
21:16:42 <shachaf> This is all just silly vocabulary.
21:17:00 <shachaf> It's not too important.
21:17:05 <jle`> mhm
21:17:50 <SrPx> chirpsalot: uhm, so convertColorSpace :: (Pixel a) => DynamicImage -> Either String (Image a) ? Also, lossyConvertColorSpace
21:21:30 <chirpsalot> SrPx: hmmmm, yeah. I guess that should work?
21:22:01 <nshepperd> well, such a colorspace conversion would generally be lossy
21:22:22 <SrPx> Uh huh, it doesn't have the lossy conversions though... let me clone the repo
21:22:54 <SrPx> Btw is it a practise to have "Either String Foo" for error handling? I thought you used Maybe for that
21:23:23 <Clint> Maybe doesn't let you describe the error
21:23:27 <pacak> SrPx: If you want to give a reson - Either works fine.
21:23:27 <chirpsalot> SrPx: both are used. Either String Foo is used sometimes if you want an error message.
21:23:47 <SrPx> Yes, that is why I asked... is it the common practice for error strings, or just this library?
21:23:51 <SrPx> practise
21:24:02 <Clint> SrPx: see http://hackage.haskell.org/package/errors-1.4.7/docs/Control-Error-Util.html
21:24:04 * SrPx doesn't know how to spell it, english is hard
21:24:13 <nshepperd> the easiest way would probably be to have 'upConvert :: (Pixel a) => a -> RGBAF' and 'downconvert :: (Pixel a) => RGBAF -> a' added to the Pixel class
21:24:36 <nshepperd> and them make your conversion out of 'downConvert . upConvert'
21:24:50 <SrPx> sounds good!
21:26:07 <chirpsalot> SrPx: let me know how it goes :).
21:26:25 * hackagebot xml-conduit 1.2.3.3 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.3.3 (MichaelSnoyman)
21:27:48 <nshepperd> well, RGBAF doesn't already exist for some reason, so I guess that would have to be added, annoyingly
21:29:11 <nshepperd> actually I guess you can just use (RGBF, Float)
21:30:47 <chirpsalot> nshepperd: why not just add RGBAF?
21:33:30 <nshepperd> if you use RGBF you can reuse the existing promotePixel instances for upConvert
21:36:34 <Axman6> nshepperd: have you seen the Colour package?
21:36:42 <Axman6> @hackage colour
21:36:42 <lambdabot> http://hackage.haskell.org/package/colour
21:37:37 <SrPx> nshepperd: there is no Pixel class
21:39:25 <SrPx> woops, there is... my bad :)
21:40:26 <amindfv> so i just uploaded a package to hackage, the build failed, and i fixed a dependency that caused the error. is there a way for me to kick off another build?
21:41:30 <shachaf> whoa, you're named after the Infocom game.
21:41:34 <Axman6> I think they're run in batches, every N hours
21:41:38 <amindfv> (fixed with "edit package information")
21:41:53 <Axman6> oh, never used that
21:41:55 <amindfv> shachaf: yes, nobody gets that haha
21:44:22 <amindfv> Axman6: so is altering the package information (and not the tarball) enough to make it be part of the next build?
21:45:00 <Axman6> no idea, sorry. you might want to try #hackage
21:45:19 <Axman6> but it's usually a pretty slow channel so you may not get a reply for a while
21:46:15 <amindfv> k thanks
21:51:26 * hackagebot file-embed 0.0.8.1 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.8.1 (MichaelSnoyman)
21:56:27 * hackagebot mono-traversable 0.9.0.1 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.9.0.1 (MichaelSnoyman)
22:01:34 <SrPx> Uh... guys
22:01:54 <SrPx> #include "ConvGraph.hs" -- at line 181 of Picture.hs ... wtf is that? There isn't even such a file
22:02:51 <SrPx> I mean, there is, but on the directory below...
22:26:56 <ultra_Sabreman> Haha i finally finished that stupid hw assignment.
22:27:18 <ultra_Sabreman> Thanks for your explanation again Axman6,
22:27:47 <ultra_Sabreman> I was able to figure out the rest of if after some thought.
22:28:09 <Axman6> glad to hear
22:32:25 <ultra_Sabreman> I'll be sure to come back to it tommorow and re-do that problem
22:32:34 <ultra_Sabreman> just in case
22:34:59 <mrkkrp> Hello, I've defined a monad transformer with `newtype' and `GeneralizedNewtypeDeriving'. It derives some classes, such as `Monad' and `MonadIO'. Now, I'm trying to use Haskeline, so monad stack looks like: InputT (MyMonadT IO) a, but I'm getting ``No instance for (MonadException (MyMonadT IO)) arising from a use of `getInputLine''. `InputT' is a monad defined in Haskeline. MonadException class is also defined there. I wonder how to make
22:34:59 <mrkkrp> it work. When I use monad stack composed only from mtl monads it works fine. Maybe I forgot to derive something? Can you help?
22:36:04 <heatsink> I guess you need to define a MonadException instance for MyMonadT
22:36:09 <pacak> Maybe derive MonadException?
22:36:30 * hackagebot vivid 0.1.0.1 - Sound synthesis with SuperCollider  http://hackage.haskell.org/package/vivid-0.1.0.1 (TomMurphy)
22:38:48 <mrkkrp> pacak, heatsink, ok, I will try to do it :)
22:54:20 <sclv> @remember JohnBaez [on univalence] being "the same" is "the same" as being the same.﻿
22:54:20 <lambdabot> It is forever etched in my memory.
22:56:02 <SrPx> So, guys... nshepperd chirpsalot... been reading the source, it *seems* to me that it is just a matter of missing convertPixel instances. The question is, is there a reason for them to be missing other than the author not implementing them? I'd guess he had one.
22:56:05 <SrPx> Also,
22:57:09 <SrPx> there are some cases where there is a promotePixel instance but not a convertPixel instance. Is there any reason for that? If you can promote it you can convert it, so it seems like it makes sense to add a instance PromotePixel a b => ConvertPixel a b, no?
22:58:33 <SrPx> At least all the comment says is: "This class abstract colorspace conversion. This conversion can be lossy, which ColorConvertible cannot" -- nothing that'd make me think there is a problem on doing so
23:12:52 <mrkkrp> MonadTrans cannot be derived ? Should I write `lift' manually?
23:18:17 <Cale> mrkkrp: It can be derived for newtypes if you turn on GeneralisedNewtypeDeriving
23:18:41 <Cale> mrkkrp: But otherwise, you have to write lift manually.
23:20:31 <mrkkrp> Cale: strange, I'm getting ``Can't make a derived instance of ‘MonadTrans MyMonadT’ (even with cunning newtype deriving): cannot eta-reduce the representation type enough...''
23:20:38 <Cale> ah, okay
23:21:01 <Cale> Probably the thing you've newtyped isn't just a simple monad transformer for which it can steal the instance.
23:21:34 <mrkkrp> Cale, well it's `StateT' on top on `ReaderT'
23:21:49 <Cale> yeah, you'd have to lift twice and not once then
23:21:58 <Cale> So it can't just use the same code for lift.
23:22:07 <mrkkrp> Cale, OK, I will try
23:22:08 <shachaf> @quote lift.twice
23:22:08 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
23:22:38 <Cale> haha
23:22:57 <mrkkrp> :-)
23:23:58 <jle`> mrkkrp: is your thing the right kind?
23:24:22 <mrkkrp> jle`: what do you mean?
23:25:10 <jle`> MyMonadT blah blah :: (* -> *) -> * -> *
23:25:15 <jle`> actually the error message seems to imply so, but
23:26:03 <jle`> mrkkrp: basically, are the last two parameters of your type constructor a monad and a *
23:26:13 <mrkkrp> jle`: yes
23:26:28 <mrkkrp> jle`: where can I read about these * things?
23:26:28 <jle`> then i got nothing ;_;
23:26:35 <jle`> ah, they're called "kinds"
23:26:39 <mrkkrp> * means anything?
23:26:49 <jle`> it means something that you can have values of
23:26:53 <jle`> like Int, or Bool
23:26:57 <jle`> or Maybe Int
23:27:00 <mrkkrp> ah
23:27:02 <jle`> but not "Maybe"
23:27:05 <mrkkrp> but not just Maybe
23:27:08 <mrkkrp> :)
23:27:10 <jle`> mhm
23:27:13 <jle`> Maybe :: * -> *
23:27:23 <jle`> it takes a *, like Int, and creates a *
23:27:38 <jle`> StateT :: * -> (* -> *) -> *
23:28:13 <jle`> it takes a * (the state), a (* -> *) (the type constructor, a monad, to transform), and a * (the type of the return value)
23:28:19 <jle`> monads can only be (* -> *)
23:28:26 <jle`> case like
23:28:28 <jle`> :t return
23:28:29 <lambdabot> Monad m => a -> m a
23:28:38 <mrkkrp> jle`: I see
23:28:39 <jle`> a is *, and m a is *, so m has to be * -> *
23:29:17 <jle`> they call it like...the types of types
23:29:18 <jle`> heh
23:29:28 <dmj`> and sorts are the types of kinds
23:29:46 <dmj`> a dream within a dream
23:33:44 <mrkkrp> so, lift m = MyMonadT $ lift (lift m) ? It seems to work!
23:35:01 <jle`> looks sane to me :)
23:35:28 <jle`> `lift = MyMonadT . lift . lift` sort of emphasizes what's happening more clearly.  lift it twice and pop on the constructor.  but that's stylistic
23:35:52 <mrkkrp> jle`: yeah, that was just my first attempt
23:36:04 <mrkkrp> I've already made it point-free
23:36:09 <jle`> cool
23:36:40 <mrkkrp> it's easier to think about things this way: I lift this monadic value, then lift the result and wrap it
23:37:18 <aawe> > VERSION
23:37:20 <lambdabot>  Not in scope: data constructor ‘VERSION’
23:41:33 * hackagebot yesod-bin 1.4.3.10 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.10 (MichaelSnoyman)
23:44:06 <adas> apart from dependent typing are there any other differences between idris and haskell?
23:44:08 <ttt_fff> what's the most retardedly simple haskell code snipplet for doing a webserver which allows file uploads?
23:44:25 <ttt_fff> I just want to get a aminimal haskell webserver, which (1) hosts some files, and (2) I can upload some files, and (3) the files are stored on the server
23:45:13 <tdammers> ttt_fff: shouldn't be too hard with either plain WAI over Warp, Scotty, or Happstack
23:45:22 <tdammers> yesod would probably work too, but it's a bit heavier
23:45:40 <ttt_fff> tdammers: yes, I was hoping someone had a blog post where I could git clone and run cabal build
23:45:41 <ttt_fff> and be done
23:46:04 <dmj`> ttt_fff: would you be open to storing the files in s3?
23:46:18 <ttt_fff> dmj`: no, I need to store files locally (on laptop)
23:46:29 <ttt_fff> i'm buidling my own cheapass scanner, where ounted ipad mini = take camera every 5 seconds
23:46:34 <ttt_fff> and uploads images to laptop
23:46:42 <ttt_fff> *mounted* ipad mini
23:46:58 <dmj`> snap can do it, http://hackage.haskell.org/package/snap-core-0.9.6.4/docs/Snap-Util-FileUploads.html
23:47:16 <MP2E> adas: Idris is strictly evaluated, it also has theorem proving capabilities similar to Coq. There are infinitely many kind levels in Idris. Also Idris seems to be targetted towards systems programming. Haskell can be used for that via the FFI, but it's never really been targetted at that domain
23:47:33 <ttt_fff> dmj`: close enough, I should start hacking; thanks
23:47:33 <MP2E> There are probably more differences, I'm new to Idris myself
23:48:16 <adas> for someone that already is an intermediate haskell developer why would someone want to use idris over haskell?
23:48:55 <tdammers> adas: the magic word I hear the most is "dependent types"
23:48:55 <SrPx> Hey guys, why this function doesn't work as expected? http://lpaste.net/121166 (Not a simple question to explain writing, but I believe the code is clear. Pretty tricky too...)
23:49:09 <adas> i am simply trying to understand the reasons that someone might use, to justify switching to idris..or using both interchangeably
23:49:45 <funfunctor> what is the correct syntax here?
23:49:45 <funfunctor> case compare g bladeRFGetMaxTxGain of
23:49:45 <funfunctor>    GT -> g <- getMaxTxGain
23:49:50 <dmj`> adas: it depends on what your goals are, obviously idris doesn't have the same breadth of libraries as haskell
23:50:11 <tdammers> SrPx: have you tried putting explicit type signatures on get
23:50:13 <tdammers> ?
23:50:25 <SrPx> tdammers: yes :( no luck so far, tried many things
23:50:34 <SrPx> but isn't the inferenced type the most generic it gets?
23:50:34 <tdammers> SrPx: also, define "work" - does it compile?
23:50:48 <SrPx> tdammers: it doesn't compile with the last line. it compiles without it. I must rephrase it
23:50:53 <tdammers> ah
23:51:00 <tdammers> do you have a compiler error to paste?
23:51:09 <mgsloan> ttt_fff: Here's an example of how to do it with Yesod: https://www.fpcomplete.com/school/project-templates/file-server
23:51:30 <mgsloan> Accompanying tutorial here: https://www.fpcomplete.com/school/advanced-haskell/building-a-file-hosting-service-in-yesod
23:51:47 <SrPx> tdammers: yes, my bad. Updated it
23:52:01 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121169
23:52:02 <funfunctor> actually I just want to do this
23:52:19 <ttt_fff> mgsloan: nice; thanks
23:52:57 <tdammers> SrPx: Ah, I get it now
23:53:06 <funfunctor> or maybe if there is a way to define a type that has a int that is bounded by a inequality somehow?
23:53:39 <funfunctor> Ada can do this with subtyped ranges
23:54:03 <SrPx> tdammers: updated again w/ more info
23:54:11 <tdammers> SrPx: I know what's going on
23:54:24 <SrPx> you do? I'll post on SO btw, I really need to sleep ...
23:54:35 <tdammers> SrPx: in order for get to typecheck, you need all three of its branches to be valid
23:54:52 <tdammers> even though you never call it on a DC, you still need such a call to typecheck
23:55:10 <SrPx> Yep... which sucks :(
23:55:23 <tdammers> maybe
23:55:27 <tdammers> but it's inevitable
23:55:27 <SrPx> I can't convert anything to A
23:55:54 <tdammers> in this case, I'd either write explicit conversions, or make `get` return Maybe or Either
23:58:59 <mrkkrp> What does this GHC warning mean: ``Orphan instance: instance ... ''. Why does it warn about it?
23:59:23 <jle`> it means that an instance is defined in a different file than the type is defined
23:59:34 <jle`> it's a warning because it's probably going to come bite you later
23:59:35 <mgsloan> (and a different file than the typeclass)
23:59:44 <jle`> huh?
23:59:58 <mgsloan> It's not orphan if it's in the same module as the class
