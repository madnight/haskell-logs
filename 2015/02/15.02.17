00:00:59 <EvanR> "if you have a value of type forall a . a then theres nothing you can do with it" ... except seq it ...
00:01:29 <wz1000> You can do nothing with () either
00:01:32 <EvanR> which does stuff
00:01:44 <EvanR> > () <> ()
00:01:45 <lambdabot>  ()
00:02:06 <EvanR> that took some gigahertz to compute ;)
00:02:21 <wz1000> > const 3 (undefined <> undefined)
00:02:23 <lambdabot>  Could not deduce (Data.Monoid.Monoid b0)
00:02:23 <lambdabot>    arising from a use of ‘Data.Monoid.<>’
00:02:23 <lambdabot>  from the context (GHC.Num.Num a)
00:02:58 <jle`> it would behave different under seq
00:03:09 <wz1000> > let x = undefined in const 3 (x <> x)
00:03:11 <lambdabot>  Could not deduce (Data.Monoid.Monoid b0)
00:03:11 <lambdabot>    arising from a use of ‘Data.Monoid.<>’
00:03:11 <lambdabot>  from the context (GHC.Num.Num a)
00:03:12 <jle`> seq _|_ x = _|_
00:03:15 <jle`> seq () x = x
00:03:24 <EvanR> wz1000: you cant monoid an unknown type! you dont know what monoid!
00:03:30 <quchen2_> For notational purposes, you should wrap your (forall a. a) in a data constructor, so that "Bottom = forall a. a", "data Unit = Unit Bottom". And then write a function "foo :: Unit -> ()" and use ViewPatterns to make it useful in functions, like "f (foo ->())".
00:04:13 <quchen2_> That gets you the best of both worlds, which is the worst of both worlds.
00:04:34 <wz1000> > let x = undefined in const 3 (x ++ x)
00:04:36 <lambdabot>  3
00:04:51 <wz1000> > let x = undefined in const 3 (x <> x :: ())
00:04:52 <lambdabot>  3
00:05:26 <wz1000> _|_ should be an instance of Monoid...
00:05:31 <dramforever> undefined <> ()
00:05:33 <xkb> hi people
00:05:38 <dramforever> > undefined <> ()
00:05:40 <lambdabot>  ()
00:05:43 <dramforever> xkb: hi
00:06:14 <xkb> I'm looking for some example code on monad transformers. Preferably in a "real world" setting.. something with databases or so. Any tips?
00:06:46 * hackagebot git-monitor 3.1.1.3 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-3.1.1.3 (JohnWiegley)
00:07:03 <wz1000> > instance Monoid (forall a. a) where mappend _ _ = undefined; mempty = undefined
00:07:04 <lambdabot>  <hint>:1:1: parse error on input ‘instance’
00:07:28 <quchen2_> instance Monoid Anything where mappend = undefined; mempty = undefined
00:07:28 <dramforever> wz1000: use @let instance...but I'm not sure you should do it
00:08:16 <lush> xkb: Maybe this helps you: http://en.wikibooks.org/wiki/Haskell/Monad_transformers (although there's no db, it's about reading a password from a user)
00:08:22 <wz1000> @ll instance Monoid (forall a. a) where mappend _ _ = undefined; mempty = undefined
00:08:22 <lambdabot> (line 1, column 45):
00:08:22 <lambdabot> unexpected '_'
00:08:23 <lambdabot> expecting variable, "(", operator or end of input
00:08:28 <wz1000> @let instance Monoid (forall a. a) where mappend _ _ = undefined; mempty = undefined
00:08:29 <lambdabot>  .L.hs:153:10:
00:08:29 <lambdabot>      Illegal polymorphic or qualified type: forall a. a
00:08:29 <lambdabot>      In the instance declaration for ‘Monoid (forall a. a)’
00:08:43 <dramforever> quchen2_: no, that doesn't satisfy forall x, x <> mempty = xx
00:08:48 <dramforever> s/xx/x/
00:08:52 * hackagebot validation 0.5.1 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.5.1 (TonyMorris)
00:08:52 * hackagebot git-monitor 3.1.1.3 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-3.1.1.3 (JohnWiegley)
00:09:11 <wz1000> I found one more semanctic difference!
00:09:40 <quchen2_> dramforever: Oh. Right. Seems like it's not a good instance after all.
00:09:55 <dramforever> wz1000: tell us
00:10:02 <wz1000> @let instance Monoid (forall a. a) where mappend _ _ = undefined; mempty = undefined
00:10:03 <lambdabot>  .L.hs:153:10:
00:10:03 <lambdabot>      Illegal polymorphic or qualified type: forall a. a
00:10:03 <lambdabot>      In the instance declaration for ‘Monoid (forall a. a)’
00:10:09 <wz1000> dramforever: ^
00:10:11 <dramforever> We are (or at least I am) interested
00:10:16 <xkb> lush: thanks for the link
00:10:21 <dramforever> wz1000: oh...
00:10:50 <lush> xkb: np
00:12:14 <lush> xkb: I didn't read it, but I guess RealWorldHaskell is quite Real World :D http://book.realworldhaskell.org/read/monad-transformers.html
00:12:47 <xkb> :)
00:12:53 <xkb> Had that chapter open already
00:13:04 <lush> hehe ^^
00:13:04 <xkb> I guess my mind is still a bit too much Java/Scala
00:17:28 <wz1000> Is there any way to turn of the automatic _|_ detection that GHC has?
00:17:34 <wz1000> > let x = x in x
00:17:38 <lambdabot>  mueval-core: Time limit exceeded
00:18:03 <wz1000> GHCi gives a <<loop>> exception
00:18:36 <dramforever> wz1000: why?
00:20:42 <wz1000> I want to test the memory and CPU characteristics of different _|_'s
00:21:08 <wz1000> And heat up my room in the process
00:21:48 <EvanR> _|_ oriented programming
00:21:51 <EvanR> _|_ passing style
00:22:18 <quchen2_> High-performance _|_ computing
00:22:47 <benzrf> night
00:22:51 <ibid> EvanR: isn't <<loop>> one of thse memoy and CPU characteristics?
00:23:31 <ibid> EvanR: i'm not sure turning off blackholes would do what you expect, though i haven't really thought about it
00:28:46 * hackagebot network-attoparsec 0.9.1 - Utility functions for running a parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.9.1 (solatis)
00:48:46 * hackagebot test-sandbox 0.1.1 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.1.1 (junjihashimoto)
00:56:30 <vanila> hi haskellers
00:56:44 <vanila> "The feeling of not being allowed to complain is one of the primary ways that abusive settings perpetuate themselves" seems relevant here http://winterkoninkje.dreamwidth.org/101276.html
01:02:45 <lpaste> tomphreek pasted “lost ability to shortcircuit in a fold with a break” at http://lpaste.net/120637
01:06:52 <EvanR> vanila: thanks for the link
01:07:21 <quchen2_> breakPredicate runVal is always False for breakPredicate = const False, so you never short-circuit
01:08:17 <quchen2_> Wait, that's the point, isn't it? :-s
01:08:36 <jle`> thanks vanila
01:08:43 <tomphreek> I wanted breakFoldr (const False) == foldr
01:08:51 <quchen2_> Ah.
01:09:21 <merijn> The problem is that can never work
01:09:38 <merijn> Your step function calls breakPredicate on the result, which you won't get until hitting the end of the list
01:10:06 <merijn> i.e. your break condition is on the second value, whereas shortcutting happens on the first value
01:10:08 <quchen2_> What you wrote is much more like a foldl than a foldr.
01:10:12 <merijn> Those two are mutually exclusive
01:20:54 <xintron> How would one  in an easy way split a string every second char into a list?
01:21:59 <zipper> xintron: splitAt?
01:22:26 <dramforever> zipper: thatSplit :: [a] -> ([a], [a])
01:22:41 <dramforever> example: thatSplit "abcde" = ("ace", "bd")
01:22:48 <dramforever> xintron: ^ right?
01:22:58 <tomphreek> @src thatSplit
01:22:58 <lambdabot> Source not found. I've seen penguins that can type better than that.
01:23:29 <xintron> dramforever, no. I want: "foobar" = ["fo", "ob", "ar"]
01:24:11 <tomphreek> :t chunks
01:24:12 <lambdabot>     Not in scope: ‘chunks’
01:24:12 <lambdabot>     Perhaps you meant one of these:
01:24:12 <lambdabot>       ‘chunk’ (imported from Data.List.Split),
01:24:15 <dramforever> xintron: I think there's a splitEvery
01:24:22 <dramforever> in Data.List.Split
01:24:55 <EvanR> gah, my use of `def' does not work because it says ambiguous type. "several possible instances" all of which would not type check
01:25:04 <EvanR> theres only one that would work...
01:25:29 <EvanR> but i guess since typeclasses are open
01:25:31 <tdammers> open universe and all that
01:25:34 <tdammers> yeah
01:25:47 <EvanR> the error message is annoying though
01:26:00 <EvanR> Default () would not work, why count it as a reason
01:26:10 * tdammers wonders if open typeclasses might be Haskell's billion-dollar mistake
01:26:20 <tdammers> .oO(probably not though)
01:26:32 <EvanR> haskell2011, "final" classes ;)
01:26:53 <tdammers> public static abstract final sealed class Default ... :P
01:27:11 <EvanR> but you can unsafeReopen just in case
01:27:47 <dramforever> Whoa just saw Dict
01:27:49 <merijn> tdammers: Naah, but I think that we really need to invent a theory for working with multiple possible typeclasses for a type
01:27:57 <dramforever> data Dict a where Dict :: a => Dict a
01:29:19 <niluje> I have this code to sort a list: http://pastie.org/9956055 ; how can I replace "(<) v x" with a lambda? (I know there are functions to sort lists, that's only for exercice)
01:29:27 * niluje wants to learn haskell
01:29:47 <tdammers> merijn: my "solution" so far is to avoid typeclasses for "application-level" things where possible, and use plain records and explicit conversions instead
01:30:03 <tdammers> it's not that bad, actually
01:30:05 <merijn> tdammers: Sure, but that doesn't help with things like Sum vs Product, list vs ZipList
01:30:15 <tdammers> no, not really
01:30:20 <tomphreek> merijn: my breakFoldr should indeed take a predicate on a rather than b
01:30:20 <merijn> tdammers: I'm talking about proper lawful typeclasses with multiple legal instances
01:30:36 <merijn> niluje: You could just write < infix there, btw
01:31:12 <merijn> niluje: I'm not sure of what you mean by "how can I replace "(<) v x" with a lambda?"?
01:31:34 <merijn> niluje: Conditions in list comprehensions must be booleans, so I don't see how having a lambda there would make sense?
01:31:59 <niluje> merijn: indeed for the infix notation, thanks
01:32:19 <dramforever> niluje: what kind of lambda?
01:32:24 <niluje> hm
01:32:47 <niluje> I was thinking the equivalent of c++ std::sort, that takes a callable to compare two elements
01:32:56 <dramforever> oh
01:32:58 <niluje> so \x, y -> x < y
01:33:15 <niluje> but it seems I misunderstand something there
01:33:17 <merijn> niluje: Right, but what would the point of that be, considering that you can just write "x < y"?
01:33:30 <dramforever> merijn: I think niluje means:
01:33:33 <dramforever> :t sortBy
01:33:34 <padre_angolano> I think niluje wants to implement sortBy
01:33:34 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
01:33:37 <merijn> niluje: The condition part of a list comprehension is a Boolean expression
01:33:39 <niluje> merijn: as much as rewriting a sort function :p
01:33:39 <dramforever> yes
01:33:48 <niluje> there's no point, that's only to understand why I can't do it
01:34:02 <dramforever> niluje: add an argument called comp (there's a builtin called compare)
01:34:10 <dramforever> and replace (<) x y with comp x y
01:34:13 <dramforever> is that what you want?
01:34:24 <merijn> niluje: I think what instead what you want is to use "something other than (<)"?
01:34:32 <lf94> is there a ghc for windows 98
01:34:42 <niluje> merijn: yes
01:34:51 <niluje> dramforever: wait a sec :p
01:35:23 <tdammers> are people still using win 98?
01:35:24 <niluje> <interactive>:1:1: Not in scope: ‘sortBy’
01:35:29 <lf94> yes
01:35:31 <tdammers> isn't that like 10 years past end-of-life?
01:35:33 <merijn> niluje: Will the simplest translation would be: sortBy lt gt (x:xs) = sort([v | v <- xs, lt v x]) ++ [x] ++ sort([v | v <- xs, gt v x])
01:35:33 <lf94> on embedded devices
01:35:48 <merijn> niluje: i.e. explicitly pass in a less-than and greater-than function
01:35:52 <tdammers> ugh
01:36:03 <niluje> hm ok
01:36:16 <merijn> niluje: Better would be slightly rewriting to take a function "a -> a -> Ordering" as dramforever suggested
01:36:18 <phaazon> hi there
01:36:28 <merijn> Where "data Ordering = LT | EQ | GT"
01:36:41 <merijn> And then matches whatever argument
01:36:42 <dramforever> phaazon: Hi
01:36:46 <dramforever> you are not ignored
01:36:46 <lf94> tdammers, apparently runs on windows 95 too!
01:36:49 <merijn> niluje: Incidentally, there's a bug in your sort :)
01:37:01 <phaazon> dramforever: thank you, I feel less alone now ;)
01:37:20 <niluje> lt seems to be undefined
01:37:21 <merijn> niluje: Considering the following: What does "sort [1,1,1,1]" return?
01:37:23 <niluje> is there something to import?
01:37:33 <dramforever> phaazon: It seems that you want to ask a question
01:37:41 <merijn> niluje: Look at the left handside, lt and gt are input arguments to the function
01:37:44 <niluje> merijn: a list of 1 element
01:37:47 <niluje> and it's ok :p
01:37:54 <phaazon> I have a long question about cabal and how it handles dependencies... hm more about how GHC does that ; I'll open a SO so that I DATA
01:38:22 <niluje> oh ok
01:38:43 <niluje> I think I understand what's my problem
01:39:06 <merijn> niluje: Of course having different less-than and greater-than functions is a bit ugly, so a better way would be using "a -> a -> Ordering" and using that as both lt and gt case :)
01:39:24 <merijn> niluje: Also, the parenthesis around the lists are completely redundant
01:39:27 <niluje> in c++, Python or whatever imperative language I commonly use, I would give a callable to my sort function, something like : sort(mylist, callable) where callable : def callable(x, y) return x < y
01:39:36 <dramforever> IIRC it's totally possible to sort with just (<)
01:39:39 <niluje> in haskell, that as if you'd give a "function call"
01:39:44 <merijn> "sort [v | v <- xs, x < y]" <- this is the same
01:39:50 <niluje> as if I did, in pythohn, sort(mylist, callable(x < y)
01:40:29 <merijn> niluje: Which is exactly what you'd do in haskell, except there is only one "callable" and those are functions :p
01:40:44 <merijn> :t sortBy -- this is exactly what's going on here
01:40:45 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
01:41:00 <merijn> It takes a function "a -> a -> Ordering" and uses that to sort the list [a]
01:41:28 <niluje> thanks for the parentheses, indeed, they are useless but I don't yet understand the priorities so I tend to put parentheses everywhere :p
01:41:38 <merijn> niluje: Priorities are simple!
01:41:45 <niluje> yes they are
01:41:46 <merijn> niluje: There's 11 fixity (precedence) values
01:41:53 <niluje> but they are also different from what I know
01:41:57 * niluje started haskell two days ago :p
01:42:10 <merijn> niluje: Operators can have fixity 0 through 9, function application is 10, record update syntax is 11
01:42:36 <niluje> what about func1 func2 func3 x y
01:42:43 <niluje> is it func1(func2(func3(x y)
01:42:50 <dramforever> niluje: operators can also be associative
01:42:53 <merijn> You can query the fixity of operators by using ":info (+)" in ghci, the default (unreported) fixity is "infixl 9" (left associative 9), anything else is printed
01:42:54 <niluje> or func1 ( func2 func3 x y)
01:43:01 <dramforever> function application is left associative
01:43:01 <merijn> niluje: Neither :D
01:43:07 <niluje> :p
01:43:21 <merijn> niluje: "((((func1 func2) func3) x) y)"
01:43:31 <niluje> ok
01:43:40 <merijn> func1 takes one argument (func2), and the result of that takes one argument (func3), etc.
01:43:58 <niluje> thanks (again) for the :info tips
01:44:04 <merijn> niluje: Think of all haskell functions as being unary (i.e. taking one argument)
01:44:08 <merijn> See for example:
01:44:11 <merijn> :t elem
01:44:11 <lambdabot> Eq a => a -> [a] -> Bool
01:44:40 <merijn> Function arrows are right associative, so his can be reparenthesised as: "a -> ([a] -> Bool)"
01:44:57 <merijn> i.e. a function that "takes an 'a' and returns a '[a] -> Bool'"
01:45:00 <merijn> We can see this in
01:45:19 <merijn> :t elem 'c' -- the result of applying elem to a Char is "[Char] -> Bool"
01:45:20 <lambdabot> [Char] -> Bool
01:45:43 <merijn> Applying the resulting "[Char] -> Bool" results in a Bool
01:45:49 <merijn> :t elem 'c' "foo"
01:45:50 <lambdabot> Bool
01:45:56 <merijn> :t (elem 'c') "foo"
01:45:56 <lambdabot> Bool
01:46:15 <merijn> This is the crucial insight to make Haskell type signatures make sense :)
01:46:51 <niluje> ok
01:47:05 <niluje> everything is logic
01:47:12 <niluje> actually
01:47:17 <niluje> everything except me
01:47:18 <niluje> :p
01:47:21 <phaazon> dramforever: http://stackoverflow.com/questions/28558932/how-does-ghc-really-handle-versioning
01:47:25 <phaazon> if you have an idea :)
01:47:35 <merijn> niluje: :)
01:47:47 <phaazon> it's a question I've been wondering for a while now on
01:48:10 <dramforever> phaazon: no...I'm not familiar with cabal either
01:48:17 <dramforever> sorry
01:48:37 <merijn> phaazon: Eh, you can totally have multiple different versions of a package installed nowadays, unless I'm going crazy
01:48:50 <phaazon> merijn: well
01:48:52 <merijn> phaazon: The problem with doing so is the following
01:49:02 <phaazon> I can't install anything I want
01:49:05 <niluje> Prelude> let v = (\a b -> a < b)(2, 4)
01:49:06 <niluje> Prelude> print v
01:49:12 <phaazon> because it creates shit in cabal dependencies :(
01:49:12 <merijn> phaazon: Actually, instead of typing it out, lemme find the right link
01:49:13 <niluje> what is bad here :(
01:49:18 <merijn> (2, 4) is a tuple
01:49:28 <merijn> > (\a b -> a < b) 2 4
01:49:29 <lambdabot>  True
01:49:31 <phaazon> niluje: uncurry
01:49:34 <merijn> > ((\a b -> a < b) 2) 4
01:49:35 <lambdabot>  True
01:49:44 <merijn> :t (\a b -> a < b)
01:49:45 <lambdabot> Ord a => a -> a -> Bool
01:49:46 <merijn> :t (\a b -> a < b) 2
01:49:47 <lambdabot> (Ord a, Num a) => a -> Bool
01:49:49 <merijn> :t (\a b -> a < b) 2 4
01:49:50 <lambdabot> Bool
01:49:53 <merijn> :t (\a b -> a < b) (2,4)
01:49:53 <lambdabot> (Ord t1, Ord t, Num t1, Num t) => (t, t1) -> Bool
01:49:58 <merijn> :t (2,4)
01:49:59 <lambdabot> (Num t1, Num t) => (t, t1)
01:50:14 <dramforever> phaazon: yeah, exactly the same here
01:50:27 <bennofs> phaazon: the problem is that compiled packages can only  depend on one version at a time. So if you install foo which depends on mtl-4.1 and bar which depends on mtl-4.2, you cannot use them together
01:50:29 <phaazon> well
01:50:32 <phaazon> I don't get it
01:50:36 <merijn> niluje: This is one of the reasons to avoid parentheses for function calls, in haskell you end up passing tuples instead of "multiple arguments"
01:50:43 <phaazon> bennofs: yeah
01:50:44 <merijn> phaazon: Hold on, there's a good post explaining the problem
01:50:55 <phaazon> and I talked about it in my SO issue
01:51:02 <phaazon> why not using the lower bound itn that case?
01:51:08 <phaazon> or I mean
01:51:10 <phaazon> the higher common version
01:51:18 <panos_> Hi everybody. I am trying to calculate the Fibonacci sequence using list comprehensions.
01:51:41 <jle`> i still find it weird that (a, b) -> c is equivalent to a -> (b -> c), in logic.  the conclusion isn't too obvious or intuitive to me.  but i guess that's the power of curry howard.
01:51:47 <panos_> Don't get me wrong...i am new to Haskell after many many years of imperative programming and i seem to be a bit in a loss !!!!
01:52:05 <panos_> This is what i have come upto : fibonaci = 1:1:[a+b | (a, b) <- zip [(last fibonaci)] [last(init fibonaci)]]
01:52:06 <phaazon> panos_: that's normal, we're here to help you ;)
01:52:09 <niluje> merijn: here it is http://pastie.org/9956129
01:52:14 <panos_> Thank you so much !
01:52:14 <niluje> that was I tried to do with lambdas
01:52:20 <merijn> phaazon: Crap, can't find it right now: http://www.vex.net/~trebla/haskell/sicp.xhtml
01:52:38 <panos_> Hm....i have tried that but ghci seems to "stuck"....
01:52:42 <phaazon> arf
01:52:44 <jle`> panos_: what are you expecting `last fibonacci` to return...?
01:52:49 <bennofs> phaazon: that's what cabal does already. but if you already installed foo (with dep mtl >= 2 < 4) and then install bar (with dep mtl >= 1 <= 2), then when install bar, foo will already have been compiled against mtl-3 (assuming only integer package versions here for simplicity)
01:53:04 <jle`> isn't fibonaci supposed to be an infinite list?
01:53:04 <merijn> niluje: btw, might wanna use lpaste.net it sucks less and has a haskell linter running :)
01:53:05 <panos_> The last item from the fibonaci variable.
01:53:06 <jle`> > last [1..]
01:53:10 <lambdabot>  mueval-core: Time limit exceeded
01:53:11 <niluje> ok :p
01:53:22 <jle`> panos_: how is there a last item for an infinite list?
01:53:24 <phaazon> bennofs: so we just need to recompile all deps
01:53:31 <niluje> merijn: dramforever: thanks a lot, I'll come back bother you later I guess :p
01:53:35 <bennofs> phaazon: yes. you can do that
01:53:36 <phaazon> panos_: it doesn't have any
01:53:45 <panos_> I was planning to use take 10 fpr example.....
01:53:49 <phaazon> panos_: last [1..] will hang infinitely
01:53:52 <panos_> eg. take 10 fibonaci
01:53:57 <bennofs> phaazon: it's essentially what you do if you rm -r ~/.ghc :)
01:54:00 <jle`> panos_: ask a mathematician what "the last fibonacci number" is :)
01:54:07 <phaazon> bennofs: hm
01:54:11 <jle`> panos_: hm. how is take 10 fibonaci related to last fibonaci?
01:54:17 <bennofs> phaazon: also, cabal install foo bar will work, while cabal install foo; cabal install bar fails
01:54:17 <jle`> > take 10 [1..]
01:54:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
01:54:19 <dramforever> panos_: do hand evaluation
01:54:20 <panos_> Oh !!!!!!!
01:54:21 <phaazon> I'm waiting for merijn's link
01:54:21 <jle`> > last [1..]
01:54:23 <phaazon> I don't get it
01:54:24 <lambdabot>  mueval-core: Time limit exceeded
01:54:26 <panos_> I see !!!!!!!
01:54:30 <scott> jle`: if you think of it this way it seems fairly intuitive: a -> b -> c means "if I have A then if I also have B then I can prove C" and (a, b) -> c means "if I have A and B then I can prove C"
01:54:31 <panos_> OMG ! :-(
01:54:41 <merijn> niluje: Right, but the lambda doesn't really do anything there :)
01:54:45 <phaazon> bennofs: in my case
01:54:46 <bennofs> panos_: see also https://github.com/yesodweb/cabal-src/blob/master/README.md
01:54:54 <phaazon> the single way to do it I found was to --force-installs
01:55:01 <phaazon> --force-reinstalls *
01:55:08 <vanila> a -> b -> c  means  if i have a I can prove that (if i have b i can prove c)
01:55:08 <merijn> phaazon: I can't find the link with graph that I was thinking of, but this also explains: http://www.vex.net/~trebla/haskell/sicp.xhtml
01:55:10 <jle`> scott: yes, i can arrive at it through logic alone...i think it's one of the && deduction rules...but...it's still nto something "immediately obvious"
01:55:17 <niluje> merijn: it is useless, but it's exactly the same as "a < b"
01:55:28 <jle`> i see the intuition but it takes some stretching to see it at first
01:55:34 <niluje> that was just to get familiar with the syntax, not because it's useful :)
01:55:48 <scott> jle`: sure, fair enough
01:55:50 <vanila> to show the equvalence look at curry and uncurry
01:55:53 <phaazon> merijn: oh I didn't see the link
01:55:55 <phaazon> thank you
01:56:08 <merijn> niluje: Right
01:56:24 <jle`> vanila: yeah, i know what it means in logic, it's just not something that i would immediately see right away
01:56:29 <scott> jle`: there's also a nice interpretation with functions as exponent types
01:56:34 <jle`> but in type-language it's like...obvious
01:56:39 <vanila> you can also see it arithmetically
01:56:57 <phaazon> merijn: what does "SICP" mean in common English?
01:56:58 <vanila> |(a,b) -> c| = |c|^(|a||b|)
01:57:00 <niluje> thanks again :)
01:57:21 <jle`> ah yes, that's neat :)
01:57:25 <EvanR> SICP is a goodie but oldie
01:57:28 <panos_> So you mean that since my list is not finished yet the last just tries to find it's end in order to return the last element ?
01:57:39 <scott> jle`: a -> b is b^a so a -> (b -> c) is (c^b)^a = c^(a*b) which is (a, b) -> c
01:57:43 <vanila> |a -> (b -> c)| = |b -> c|^|a| = (|c|^|a|)^|b| = |c|^(|a||b|)
01:57:52 <jle`> panos_: yeah. and if you had defined things right, your list actually should never finish
01:58:02 <vanila> this doesn't prove that they are equivalent, but it's a strong indication and gives some insight about why
01:58:06 <jle`> panos_: because the sequence of fib's is infinite
01:58:09 <scott> right
01:58:47 * hackagebot hecc 0.4.1.1 - Elliptic Curve Cryptography for Haskell  http://hackage.haskell.org/package/hecc-0.4.1.1 (MarcelFourne)
01:59:06 <lpaste> merijn pasted “Example” at http://lpaste.net/120639
01:59:16 <merijn> niluje: Compare those three versions :)
01:59:40 <merijn> Warning, I didn't actually check if those compile :p
01:59:47 <scott> vanila: it would work as a proof if a, b, and c were finite types, wouldn't it?
01:59:56 <vanila> I don't think so
02:00:00 <scott> why not?
02:00:14 <vanila> just because you measure two things and get the same result, doesn't mean they are the same thing
02:00:46 <merijn> phaazon: SICP in that link means Storage and Identification of Cabal Packages
02:00:55 <scott> vanila: if two finite types have the same number of elements there is an isomorphism between them
02:01:05 <merijn> vanila: That's a discussion on extensional vs intensional equality :)
02:01:26 <merijn> vanila: Extensional equality says "if two functions produce the same output for every input, they're equal"
02:02:28 <scott> I think my use of the word "proof" is probably too informal
02:02:34 <EvanR> scott: really?
02:02:45 <scott> but it's enough to know two finite types have the same number of elements
02:02:53 <dramforever> scott: yeah
02:03:02 <dramforever> and haskell is inconsistent
02:03:06 <niluje> merijn: neat
02:03:18 <scott> EvanR: what are you responding to exactly?
02:03:28 <niluje> and int he last case, you're calling it with sortBy compare [12,3,4,54], right?
02:03:31 <EvanR> two finite types are isomorphic if they have the same number of values
02:03:38 <merijn> niluje: Right
02:03:45 <phaazon> EvanR: thanks
02:04:00 <niluje> the where block makes it more readable
02:04:04 <merijn> niluje: Well, you could define your own version instead of compare
02:04:08 <niluje> yes ofc
02:04:09 <scott> EvanR: yeah, you can number each of the values from each type and then just map between the ones with the same number, for example
02:04:11 <merijn> A fun example is:
02:04:16 <EvanR> scott: to me, this conjures up some law where all the operations carry over to the isomorphic value and back
02:04:19 <merijn> > sortBy (flip compare) [1..10]
02:04:20 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
02:04:36 <merijn> niluje: Flip "flips" the arguments two compare and thus ends up sorting in reverse order :)
02:04:40 <merijn> *to
02:04:58 <scott> EvanR: they carry over to a suitably defined operation for the other type
02:05:01 <niluje> merijn: but I guess the best implem is the first one, and if you want to sort custom types you just derive Ord
02:05:09 <EvanR> scott: simply being the same size might be isomorphic in some trivial sense of isomorphic, unless i am missing the sense of isomorphic
02:05:10 <quchen2_> > flip f x y :: Expr
02:05:11 <lambdabot>  f y x
02:05:24 <merijn> niluje: And yes, IMO if your line is longer than like 20 characters, you should split it and stuff it in where blocks :)
02:05:31 <scott> EvanR: I can define something like not :: Bool -> Bool for Either () () that will work with an isomorphism between Bool and Either () ()
02:05:47 <niluje> there's something aweful about haskell
02:06:14 <merijn> niluje: Well, in the Prelude sort is actually defined as simply "sortBy compare" :)
02:06:19 <niluje> I'm currently at work, I need to do some python and sysadmin right now, I have a lot of stuff to do and the only thing I want to do is trying to learn haskell more :p
02:06:32 <vanila> scott, oh yeah! you're totally right
02:06:36 <dramforever> niluje: maybe you should type more carefully...
02:06:49 <dramforever> or aweful = awesome + awful
02:06:49 <niluje> dramforever: ?
02:06:49 <EvanR> scott: ok but if you didnt, and you only have 3 operations here and 3 operations there and they dont agree in any way...
02:06:57 <scott> EvanR: the isomorphism is really just a pair of functions f :: a -> b and g:: b -> a and a pair of proofs that f . g = id and g . f = id
02:07:02 <EvanR> and you cant see the constructors to define these operations
02:07:25 <EvanR> scott: that part is just saying they are the same size though
02:07:43 <dramforever> whoa http://hackage.haskell.org/package/constraints-0.4.1.3/docs/src/Data-Constraint.html
02:07:44 <niluje> dramforever: typo, I thought "awful" had a 'e' :p
02:07:51 <vanila> A proof that |a| = n would be an enumeration of the elements of the type
02:07:54 <merijn> To be fair
02:08:03 <dramforever> did E. Kmett sort those extensions by length?
02:08:04 <merijn> Haskell is also pretty awefull :D
02:08:10 <dramforever> length of their names?
02:08:27 <quchen2_> merijn: Welcome to pun or typo! :-D
02:08:28 <scott> EvanR: being the same size is the important part. but this extends beyond finite types
02:08:40 <dramforever> typun
02:08:43 <quchen2_> awwefull?
02:08:45 <EvanR> scott: im just missing the part of that definition that has anything to do with defined operations on the types
02:09:07 <scott> EvanR: the isomorphism doesn't directly talk about those
02:09:12 <EvanR> like that part that makes the types mean anything besides sets
02:09:35 <EvanR> give or take isorecursive types and stuff i dont understand
02:10:11 <EvanR> being bijective is just boring
02:10:23 <scott> that's all there is to it! :p
02:10:29 <scott> EvanR: you can even talk about weird isomorphisms between Bool and Bool itself
02:10:34 <scott> there's the boring one, id
02:10:39 <EvanR> but using the jargon isomorphic is overkill
02:10:40 <scott> then there's the more interesting one, not
02:11:04 <jle`> which is a monoid homomorphism :O
02:11:20 <dramforever> in my mid: A and B are isomorphic ---> A is both convertible to and from B
02:11:29 <dramforever> with no loss of information
02:11:31 <scott> you can flip the meaning of True and False absolutely everywhere and it's the same thing again
02:11:36 <EvanR> dramforever: in a way that preserves the opeations
02:11:52 <jle`> dramforever: what does "no loss of information" mean?
02:11:56 <scott> if you think about it, which element of the type Bool is the True one and which is the False one is irrelevant, as long as they are used consistently
02:12:08 <EvanR> bool is a bad example
02:12:24 <quchen2_> dramforever: Back-and-forth convertability is only a bijective map. An isomorphism is stronger than that, it guarantees what we like to call "structure preservation", i.e.  iso(a) * iso(b) = iso (a *' b)
02:12:50 <EvanR> thats what i was trying to come up with, right there
02:12:51 <vanila> "the opeations" that are preserved depend on the category you choose
02:12:57 <EvanR> the * and *'
02:13:02 <vanila> if you work in a simple category of functions then there are no operations
02:13:19 <vanila> if you work in the category of monoids, then all your morphisms will preserver the monoid operations
02:13:37 <dramforever> quchen2_: what's the relation between * and *'
02:13:52 <quchen2_> Your isomorphisms are going to preserve the category composition, which in the case of monoids is "multiplication", vanila.
02:13:52 <EvanR> so what category is Bool in
02:14:15 <quchen2_> s/category composition/arrow composition/
02:14:54 <vanila> when we're talking about types like (a,b) -> c and a -> b -> c being equivalent, we're just thinking of the basic category without any special operations that need preserved
02:15:24 <EvanR> yes but "finite types"
02:15:30 <panos_> Thank you so much evebody. I will start from the beginning.
02:15:32 <panos_> :-)
02:15:32 <dramforever> hmm...like AssumedCorrectGMPInteger and MyCorrectInteger are isomorphic
02:15:42 <panos_> Thank you so much for your help.
02:15:42 <vanila> jle` pointed out that the 'not' duality isn't just an isomoprhism in the basic category, it's also one in the monoid category
02:16:00 <vanila> it maps from the Bool/and monoid to the Bool/or one
02:16:02 <scott> ah, interesting
02:16:13 <scott> so what I was saying was correct just for the basic function category
02:16:31 <scott> and EvanR was thinking about ones where operations need to be preserved
02:17:14 <vanila> that's right, since there's a lot of functions from one finite set to another: you could have strange permutations that break lots of operations even though they are bijections
02:17:19 <EvanR> im not familiar with basic function category and isomorphisms here
02:18:23 <scott> I think what's meant by that is just isomorphisms between Haskell types in general without any further specifics about operations they may or may not support
02:18:23 <dramforever> vanila: like..encrypt and decrypt?
02:19:02 <vanila> dramforever, maybe!
02:19:45 <vanila> There's an idea to make a type of encryption that still lets you perform operations on the encrypted data -- without knowing what sort of thing you're actually computing
02:20:02 <scott> right, so I can make a bijection between Nat and [()], and that's just a boring bijection/isomorphism, but I can also prove that it's a monoid homomorphism, which is much more interesting
02:20:33 <scott> with mempty = 0; mappend = (+) on Nat and mempty = []; mappend = (++) on [()]
02:21:32 <scott> and natToList n ++ natToList m == natToList (n + m) for all n, m
02:21:43 <scott> and the other way around
02:23:38 <dramforever> Question: I remember seeing a post on haskell-cafe about an alternative definition of equality: newtype Eq a b = Eq (forall f. f a -> f b)
02:23:48 * hackagebot extensible 0.2.10 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.2.10 (FumiakiKinoshita)
02:24:10 <dramforever> Anyone know where it is? or anything about it?
02:24:18 <vanila> that's calle leibniz equality
02:24:39 <Procian> (John Major). And it's for types.
02:25:15 <dramforever> @google leibniz equality
02:25:16 <lambdabot> http://en.wikipedia.org/wiki/Equality_(mathematics)
02:25:16 <lambdabot> Title: Equality (mathematics) - Wikipedia, the free encyclopedia
02:26:28 <dramforever> oh great
02:27:50 <Procian> dramforever: The general idea here is that you can think of "f" as a predicate, and then "forall f. f a -> f b" says that b has all the properties of a. So the two are indiscernable, and thus identical. It turns out you can encode this as a type.
02:28:05 <merijn> Hell, all half of dependent types is arguing about what equality means
02:28:17 <dramforever> Procian: it seems better than data Eq a b where Refl :: Eq a a
02:28:35 <merijn> In fact, HoTT is all about arguing "Yo dawg! We heard you like equalities, so we put equalities inside your equalities so you can equal while you equal!"
02:28:49 <xintron> I currently have a function that creates a set list with length 4: [Double] but I would like it to return (Double, Double, Double, Double). Is there some way to "convert" it?
02:29:14 <merijn> xintron: Pattern match and use Maybe or crash when it doesn't match
02:29:17 <Procian> dramforever: Yeah, I haven't really looked into it in Haskell. In Coq, I believe you get the Leibniz version as the induction theorem for that Refl version.
02:29:32 <vanila> dramforever, you can go from one to the other though
02:30:02 <xintron> merijn, Ah. So I match the list and then manually specify what to return, else return a default?
02:30:09 <merijn> xintron: "unlist :: [a] -> Maybe (a,a,a,a); unlist (a:b:c:d:[]) = Just (a,b,c,d); unlist _ = Nothing"
02:30:13 <jle`> to4ple (a:b:c:d:_) = Just (a,b,c,d); to4ple _ = Nothing
02:30:39 <jle`> mine is a little more forgiving :)
02:31:36 <xintron> thanks
02:32:57 <mpickering> Is anyone else having trouble using the fp complete IDE at the moment?
02:34:05 <Benzi-Junior> hey I need  function that takes a number and transforms it into the string of bytes used to represent it I'm currently using: (showIntAtBase 2 (chr.(\x->x+48)) (ord x ) "") the only problem with that is that it omits all zeros in the beginning wheras I would like to get a fixed length string
02:34:10 <Benzi-Junior> any ideas ?
02:34:19 <bennofs> mpickering: I get "StartContainerHostUnavailableException" trying to load a project
02:34:36 <mpickering> ^ same here thanks
02:42:11 <dramforever> Benzi-Junior: printf from Text.Printf
02:42:23 <dramforever> > printf "%08d" 20
02:42:24 <lambdabot>  No instance for (GHC.Show.Show a0)
02:42:24 <lambdabot>    arising from a use of ‘M425496442836332448815799.show_M4254964428363324488...
02:42:24 <lambdabot>  The type variable ‘a0’ is ambiguous
02:42:27 <dramforever> ouch
02:42:38 <dramforever> > printf "%08d" (20 :: Int)
02:42:39 <lambdabot>  No instance for (GHC.Show.Show a0)
02:42:39 <lambdabot>    arising from a use of ‘M189206894930736012415811.show_M1892068949307360124...
02:42:39 <lambdabot>  The type variable ‘a0’ is ambiguous
02:42:44 <dramforever> ouch...
02:42:53 <dramforever> > printf "%08d" 20 :: String
02:42:54 <lambdabot>  "00000020"
02:42:57 <dramforever> oh good
02:43:01 <dramforever> Benzi-Junior: ^
02:43:09 <Benzi-Junior> dramforever: got there in the end
02:43:19 <dramforever> If you are using a function that only takes strings you won't need that :: String part
02:43:22 <hyPiRion> printf is an interesting one
02:43:25 <hyPiRion> :t printf "%08d" 20
02:43:26 <lambdabot> PrintfType t => t
02:43:38 <dramforever> yes, just like (iirc) =~
02:43:40 <dramforever> or =~
02:44:23 <dramforever> yes, =~
02:45:24 <fread2282> (how) can dependent types have coherent instances? instance Monad (flip Either)
02:46:37 <dramforever> > "foo" =~ "o" :: [String]
02:46:38 <lambdabot>  Not in scope: ‘=~’
02:46:38 <lambdabot>  Perhaps you meant one of these:
02:46:38 <lambdabot>    ‘==’ (imported from Data.Eq), ‘#~’ (imported from Control.Lens),
02:47:12 <bennofs> @hoogle (=~)
02:47:14 <lambdabot> Text.Regex.Posix.Wrap (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
02:47:14 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
02:51:11 <Benzi-Junior> dramforever: it worked
02:51:14 <Benzi-Junior> great success
02:52:01 <dramforever> Benzi-Junior: (Here's what I usually do) always look for libraries before writing your own
02:53:48 * hackagebot t-regex 0.1.0.0 - Matchers and grammars using tree regular expressions  http://hackage.haskell.org/package/t-regex-0.1.0.0 (AlejandroSerrano)
02:53:51 * hackagebot lowgl 0.3.1.0 - Basic gl wrapper and reference  http://hackage.haskell.org/package/lowgl-0.3.1.0 (evanrinehart)
02:53:58 <dramforever> ha ha regex
02:54:49 <Benzi-Junior> dramforever: ye I set hoogle as one of my browsers goto search engines
03:28:49 * hackagebot optparse-applicative 0.11.0.2 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.11.0.2 (PaoloCapriotti)
03:33:49 * hackagebot plailude 0.5.0 - plaimi's prelude  http://hackage.haskell.org/package/plailude-0.5.0 (alexander)
03:38:55 <vanila> can't install something off hackage because of dependncy problwms :(
03:43:49 * hackagebot fpco-api 1.2.0.5 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.2.0.5 (ChrisDone)
03:55:30 <tempname11_> what's a good way to debug a dependency package? I've added one with "cabal sandbox add-source", made some changes to it, got a segfault (I'm doing low-level IO), and it's hard to debug, because ghci's :break does not work on compiled modules
03:55:54 <tempname11_> is there a way to run dependency packages in interpreted mode?
03:57:11 <zipper> Yesod question:
03:57:12 <zipper> Could I get help with an error with maybeAuth here. It should Just (Entity uid user) for a logged in user but in this case it's not recognosing the user value as being of user type.
03:57:26 <zipper> Code at https://gist.github.com/urbanslug/b1ae5d29b5a1b7aa7a22
03:58:26 <rindysco> Hi, I'm looking for a way to use a "State _ ()" function from within a "State _ [String]", ie. a function that modifies the stateful data but doesn't produce a result
03:59:05 <rindysco> example at http://pastebin.com/XEvf1MwW
04:00:53 <tempname11_> rindysco: the _'s you omitted don't match
04:01:38 <rindysco> oh because the value in Data becomes type ()
04:02:54 <rindysco> tempname11_: Thanks, got it working :)
04:03:15 <tempname11_> no problem!
04:05:24 <phaazon> hm
04:05:37 <phaazon> I contacted the author of clock so that they release a new patch version of clock
04:05:42 <phaazon> because I got my PR merged upstream
04:05:46 <phaazon> and it's an important fix
04:05:49 <wz1000> Does a (category theoretical)functor need return?
04:05:54 <phaazon> they haven't answered yet :(
04:06:07 <vanila> wz1000, just fmap
04:07:24 <jameseb> wz1000: a category theoretical functor just maps objects and arrows of one category to another category in a consistent way
04:07:26 <wz1000> vanila: According to wikipedia, a functor associates to each object X \in C an object F(X) \in D.
04:07:42 <vanila> yes thats true
04:07:52 <vanila> so a functor has two components F1 and F2
04:07:57 <vanila> F1 applies to values and F2 to types
04:08:09 <merijn> wz1000: You may be interested in this: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
04:08:16 <vanila> if you have f : A -> B then F1(f) : F2(A) -> F2(B)
04:08:18 <merijn> wz1000: All the examples are Haskell and C++ :)
04:08:35 <jameseb> the object mapping is done by the type, which is of kind * -> *, and the arrow mapping is done by fmap
04:08:36 <vanila> but F2 is not return, it's like a type constructor from haskell
04:08:37 <wz1000> So, for Maybe to be a functor, Every Int has to map to a Maybe Int
04:08:49 * hackagebot plailude 0.5.1 - plaimi's prelude  http://hackage.haskell.org/package/plailude-0.5.1 (alexander)
04:08:49 <vanila> it's not a map Int -> Maybe Int
04:09:01 <vanila> it's just saying that given a type, e.g. Int, you can create a new type Maybe Int
04:09:10 <merijn> wz1000: No, Maybe is a functor because it maps object "Int" to object "Maybe Int"
04:09:27 <merijn> wz1000: And it maps the arrow "Int -> Int" to the arrow "Maybe Int -> Maybe Int"
04:09:39 <wz1000> It says to each object, x in C
04:09:50 <wz1000> Oh, C is Hask!
04:10:06 <jameseb> wz1000: the objects are types, not values
04:10:15 <merijn> wz1000: Maybe is an endofunctor, i.e. it's a functor from category C to category C (or in the case of Haskell: Hask)
04:10:24 <jameseb> wz1000: yes, C is Hask
04:10:37 <wz1000> I thought C was a in (f a)
04:10:45 <merijn> wz1000: Anyway, see the link I just sent you :)
04:11:09 <wz1000> merijn: I have read parts of that.
04:12:18 <tempname11_> can anyone take a look at my question above? I know it's not as sexy as category theory, but... :)
04:13:35 <merijn> tempname11_: Have you tried the "liberal application of Debug.Trace" method?
04:13:52 <merijn> i.e. printf debugging :p
04:16:11 <tempname11_> merijn: that's I'm probably going to do, but part of the problem is that each change to the dependency package takes a while to compile, and so the cycle "sprinkle printf's; run; analyse" takes far too damn long. Inside ghci it would be much easier
04:16:20 <tempname11_> like 100x faster
04:16:40 <merijn> tempname11_: Can you still not use :break if you compile with debug symbols?
04:16:57 <dramforever> IMHO ghci debugger is great
04:17:14 <dramforever> it shows what's going on
04:17:14 <lamas> Guys, how does one access the recursive variable inside something like a binary tree
04:17:16 <tempname11_> merijn: I don't know yet. It's my first haskell project. How do I use that?
04:17:39 <dramforever> lamas: what's that "recursive variable"
04:17:58 <dreixel> I have a program that uses a bunch of global constants. It supports two input formats; the format is given on the command line, and each format uses different constants. what's the best way to encode this in Haskell? I want to use constants like |field1Name| all over my program, but these depend on the input format. I don't want to use CPP.
04:18:04 <lamas> My tree looks like Data Tree a = empty | Tree a a
04:18:13 <hsk3> Data types in Haskell are analogous to C++ classes (only member variables, not functions).
04:18:14 <hsk3> Is this a fair analogy?
04:18:16 <merijn> tempname11_: ugh, looks like you're right, you can only breakpoint interpreted code
04:18:18 <hsk3> Sort of.
04:18:24 <lamas> By the way I'm sorry to ask you guys like this, I've been googling for a while with no results
04:18:29 <merijn> hsk3: Not even then
04:18:31 <dramforever> lamas: that tree doesn't make sense
04:18:45 <dramforever> lamas: It's fine. We (at least I) do the same
04:18:54 <lamas> Hehe thanks
04:18:59 <dreixel> (basically I'm looking for something like Agda's |open| on records, or a module parameter)
04:19:07 <merijn> dramforever: Well, it'd make sense as a Fix kinda tree, but that's probably not what was intended :p
04:19:07 <dramforever> lamas: that doesn't make sense
04:19:11 <lamas> Well it's supposed to be recursive, a tree can either have 2 children or none
04:19:12 <dramforever> yes
04:19:13 <hsk3> merijn: or C structs?
04:19:24 <merijn> hsk3: Neither have generics :)
04:19:39 <dramforever> lamas: where are you going to put that a?
04:19:56 <lamas> I want it to be polymorphic, such that it can store any type
04:19:56 <dramforever> on every node, just internal nodes or just leaves
04:20:00 <hsk3> merijn: do you mean type constructors in haskell?
04:20:02 <lamas> sorry
04:20:04 <dramforever> lamas: *
04:20:05 <merijn> lamas: So you presumably want two constructors: 1) leaf constructor containing a value and 2) a branch constructor having two children, right?
04:20:05 <dramforever> ^
04:20:16 <lamas> Pretty much
04:20:19 <lamas> yeah.
04:20:31 <lamas> a is stored in a leaf
04:20:39 <merijn> lamas: Right, so we have "data Tree a = ???" let's tackle one at a time
04:20:58 <lamas> Sure
04:21:06 <merijn> A constructor always has a name starting with a capital letter, so how would you define one that takes an 'a' as parameter?
04:21:14 <lamas> A tree can either be empty, or it can have two nodes with (a) as a variable
04:21:47 <lamas> something like Data Tree a = Tree a a | Empty ?
04:22:14 <merijn> lamas: That defines two constructors: 1) an Empty constructor and 2) a Tree constructor that takes 2 a's as arguments
04:22:23 <dramforever> lamas: no, that means a Tree a is either two a or empty
04:22:25 <merijn> lamas: So that way you can have a branch longer than 1
04:23:19 <dramforever> how about this: 1. split cases. You seem to have two cases, describe them clearly
04:23:41 <dramforever> I mean, different ways to construct a tree
04:23:51 <merijn> lamas: Let's start with a simpler case, a linked list: "data List a = Nil | Cons a (List a)" does that one make sense?
04:23:59 <lamas> Dream forever: I see, so I though that was how you define a tree, i e tree a = tree(a a(tree a)) Where the last a is the root.
04:24:21 <dramforever> lamas: oh gosh...look at my nick again
04:24:28 <lamas> sorry
04:24:36 <dramforever> It's okay
04:24:38 <merijn> lamas: What can you tell me about the 'Cons' constructor in my example?
04:24:54 <merijn> dramforever: Hah, there's so many people that keep insisting my nick is "merjin" >.>
04:25:03 <Axman6> lamas: you can type dra<tab> in most IRC clients and it will autocomplete it for you
04:25:03 <merijn> I wish freenode allowed unicode in nicknames :p
04:25:30 <tdammers> merijn: do you have an alert on "merĳn"?
04:25:35 <quchen2> mer(ij)n?
04:25:36 <dramforever> Axman6: but...they type dre<tab>, and "???Nothing???" and continue to type "amf..."
04:25:38 <lamas> DreamForever:  The cases are The root can have two children or none. Such that each node can either have left/right child or be empty.
04:25:47 <dramforever> oh gosh....
04:25:52 <merijn> tdammers: No, because I can't figure out how to add to in irssi
04:25:57 <tdammers> :D
04:25:58 <lamas> merjin : Yeah sort of, a linked list can either be nil or have an a and list a
04:26:00 <merijn> tdammers: Besides no one will type that :p
04:26:12 <tdammers> I wĳll
04:26:14 <dramforever> lamas: D-R-A-M-forever
04:26:29 <lamas> In that case my tree need to be something like Data Tree a = Empty | cons a (Tree a a) =
04:27:06 <dramforever> let me help you: case 1: A (Tree x) can be empty, with no values of type x
04:27:17 <dramforever> (x stands out more in English than a)
04:27:19 <lamas> disregard the last equal sign, was ment to be a question mark.
04:27:48 <dramforever> lamas: give a name yo that case
04:27:51 <lamas> dramforever: Sound good x is good!
04:27:52 <dramforever> yo -> to
04:27:56 <merijn> lamas: But in your example code you have a 'Tree' type constructor (which takes one type as argument) and given it two
04:28:25 <dramforever> merijn: Is there a paper-scissor-rock website? I think we shouldn't explain to lamas together
04:28:45 <merijn> dramforever: You continue, I should be reviewing a paper and am just procrastinating >.>
04:28:55 <dramforever> merijn: thanks
04:29:03 <lamas> I'm very thankful to you both, thanks guys!:)
04:29:06 <dramforever> lamas: give a name to that case 1
04:29:49 <lamas> dramforever: so case one: A tree has only the root
04:30:13 <lamas> Since the arguement is there even before the Empty constructor?
04:30:43 <dramforever> lamas: only the root?
04:30:53 <lamas> Yeah, since you invoked the empty constructor
04:31:07 <quchen2> dramforever, merijn: There is a service here to help you!
04:31:11 <dramforever> that's not good...by "case" I mean how can you construct a tree
04:31:11 <lamas> dramforever: so basically the tree looks like Tree a (Empty)
04:31:11 <quchen2> ?choose dramforever merijn
04:31:11 <lambdabot> dramforever
04:31:23 <dramforever> quchen2: great, lambdabot agrees
04:31:33 <dramforever> and thanks
04:31:59 <dramforever> lamas: let me clarify: How to construct a tree?
04:32:08 <lamas> dramforever: With a function that takes tree as a parameter and returns said tree?
04:32:32 <dramforever> lamas: no. I mean, what makes something a tree?
04:33:17 <tdammers> maybe it's easier to let go of trying to construct a tree, and instead focus on tree nodes?
04:33:19 <lamas> Being a simple graph and having no cycles?:p Sorry I'm not following quite, but I can see that you're trying to invoke an epiphany
04:33:49 <dramforever> hmm...have you made a tree like that in other programming languages?
04:33:53 <lamas> Yes
04:34:09 <lamas> OOP, java for isntance
04:34:28 <dramforever> lamas: show us one. post it here: http://lpaste.net/new/haskell
04:36:24 <lamas> dramforever: Sure!
04:36:50 <IP92> can you guys recommend some introductory materials to lambda calculus?
04:37:45 <Axman6> wikipedia? LC is in many ways very simple
04:38:14 <IP92> simple?
04:38:34 <Axman6> yes, there's only two or three constructs and rules
04:38:51 <Axman6> actually getting anything done with it is more difficult
04:39:37 <quchen2> I think TaPL introduces lambda calculus quite nicely.
04:39:53 <quchen2> http://www.cis.upenn.edu/~bcpierce/tapl/
04:41:00 <wz1000> The predicate function is very clever.
04:41:14 <wz1000> Took me a while to understand.
04:42:00 <IP92> quchen2: there isn't a free version of this?
04:42:03 <Axman6> so... you can also use http://worrydream.com/AlligatorEggs/ to learn lambda calculus, apparently
04:42:57 <quchen2> Yeah that's extremely useful. Just like the fishy Monad tutorial.
04:43:10 <lpaste> lamas pasted “BST in Java-ish psudeucode” at http://lpaste.net/120643
04:43:17 <Axman6> it does eventually introduce the Y combinator though...
04:43:30 <wz1000> Wikipedia does an OK job.
04:43:37 <lamas> dramforever: sorry it took so long and it's in such psuedocode
04:44:33 <dramforever> lamas: you know what's Maybe, right
04:44:58 <Axman6> I think you just want a normal BST: data Tree k v = Empty | Node k v (Tree k v) (Tree k v) -- for something equivalent to the java you posted
04:45:53 <lamas> No
04:46:00 <lamas> dramforever: Sorry, I don't.
04:46:17 <dramforever> @src Maybe
04:46:17 <lambdabot> data Maybe a = Nothing | Just a
04:46:38 <Axman6> lamas: why no. explain
04:46:39 <lamas> dramforever: I see, I can that instead of the empty constructor.
04:46:47 <dramforever> It represents something that might not exist
04:47:33 <dramforever> Nothing is like null in java, but in haskell we make explicit
04:47:38 <dramforever> make it
04:47:44 <lamas> Axman6: I see, thanks for the input:)
04:48:12 <lamas> dramforever: I see, that's rather useful to check wether the node is empty or not.
04:48:36 <lamas> dramforever: So if node == Nothing, then we're at the leaf?
04:48:59 <dramforever> sure
04:49:31 <dramforever> (others: Yes it *might* be too much trouble, but IMHO it)
04:49:35 <dramforever> it's easier to explain
04:49:38 <xkb> or Empty in the case of Axman6 proposal
04:49:49 <nschoe> how come I read that we need a working version of GHC to build the Haskell plateform ?
04:50:01 <BobbyB> can someone help me rewrite this statement?   (+1) . fromJust . flip elemIndex (sort b)   I am confused with the dots
04:50:07 <Axman6> because GHC is written in haskell
04:50:13 <Axman6> and so is the rest of the platform
04:50:25 <Axman6> not sure why you're building the platform though
04:50:36 <lamas> xkb: I see, so in that case Empty takes over the Nothing part, which is kind of obvious once one looks at the way the datatypes are constructed.
04:50:38 <dramforever> lamas: so data Tree k v = Tree k v {- left child -} {- right child -}
04:50:44 <nschoe> I'd liek to install Haskell (namely, GHC and cabal-install) on a server on which I do not have admin rights. So I'd like to install it my home. How can I do that?
04:50:52 <dramforever> lamas: ^ fill them in
04:51:02 <solarus> @unpl (+1) . fromJust . flip elemIndex (sort b)
04:51:02 <lambdabot> (\ h -> (fromJust (elemIndex h (sort b))) + 1)
04:51:11 <Axman6> BobbyB: (\x -> 1 + fromJust (elemIndex x (sort b)))
04:51:33 <nschoe> Axman6, ah okay, I understand. Well actually I don't need the plateform, I just need to find a way to install GHC and cabal on that too damn old server :/ The current installed version is 6.8.2 -_-'
04:51:48 <lamas> data Tree k v = Tree k v maybe ((Tree k v) (Tree k v)) ?
04:51:54 <BobbyB> Thanks Axman6 and solarus!
04:52:31 <Axman6> nschoe: that's pretty old =)
04:53:25 <lamas> dramforever: Something like that would be correct, or I could even go data Tree k v = Tree k v maybe (Tree k v) maybe (Tree k v) If it can either have one child, two or none.
04:53:36 <dramforever> lamas: that's wrong
04:53:43 <xkb> depends if its a Binary tree
04:53:50 <nschoe> Axman6, it is :-) But I have no admin rights on that server. I tried "everything" I could think of: static compiling on my computer, but no luck, I tried building GHC from source, but it needs to many libs that are too old too... It feels like I won't get away with this
04:53:59 <dramforever> you are still not familiar with haskell precedences, right
04:54:20 <dramforever> also that Maybe should be spelt with a capital M, do you know why?
04:55:17 <lamas> dramforever:  Right, I'm not really familliar, but if you're talking about functions it would be left to right, right? Like this function takes a list and returns an int or something. Also about Maybe :It's a data type.
04:55:35 <BobbyB> Axman6: and solarus:   Couldn't match expected type `[Int]' with actual type `Int'      is there something simple to change to make (\x -> 1 + fromJust (elemIndex x (sort b)))  work?
04:56:04 <lamas> dramforever: which is why it's supposed to be a capital M.
04:56:18 <dramforever> how about this: this is the corrected one: data Tree k v = Tree k v (Maybe (Tree k v)) (Maybe (Tree k v))
04:56:44 <dramforever> you know why I wrapped (Maybe (Tree k v)) ?
04:57:06 <xkb> in that way you can still have a node with only one branch right?
04:57:11 <lamas> To keep it as one operation?
04:57:17 <dramforever> lamas: exactly
04:57:25 <dramforever> now you have a correct binary tree!
04:57:40 <lamas> dramforever: Thanks! Really, I appreciate it!:)
04:57:43 <dramforever> well, actually you have to use (Maybe (Tree a))
04:57:48 <dramforever> lamas: but that's not all
04:57:58 <solarus> BobbyB: that should work, what is the type of b?
04:58:03 <lamas> dramforever: Either way, the arguement is not the issue.
04:58:24 <lamas> dramforever: Now traversal will be a problem though, as I haven't traversed none tuple/List structures
04:58:25 <dramforever> lamas: you still remember data Tree a = Empty | Branch (Tree a) (Tree a)
04:58:33 <lamas> Yeah?
04:58:33 <dramforever> that's simpler
04:58:57 <dramforever> and equivlant to our previous (Maybe (PreviousTree a))
04:59:22 <lamas> dramforever: Yeah, sure I remember it.
04:59:28 <BobbyB> solarus:    test b = flip zip (sort b) ( map ((+1) . fromJust . flip elemIndex (sort b)) (sort b) )             test :: (Ord a) => [a] -> [(Int, a)]         does this help?
04:59:29 <solarus> dramforever: you couldn't have empty tree's in your previous version though
04:59:50 <dramforever> solarus: I can. I used (Maybe (PreviousTree a))
04:59:51 <xkb> always at least 1 noe
04:59:52 <xkb> node
04:59:58 <xkb> ahhh
05:00:00 <dramforever> xkb, solarus: no
05:00:03 <xkb> missed that
05:00:11 <dramforever> in java node could be null
05:00:34 <dramforever> lamas: so...you can try to write a function that converts between those two
05:00:39 <lpaste> eikke pasted “No title” at http://lpaste.net/120644
05:00:45 <solarus> not in this? data Tree k v = Tree k v (Maybe ...) (Maybe ...)
05:00:56 <eikke> anyone with singletons knowledge knows how to get that to work? ^^
05:01:15 <dramforever> solarus: I said (Maybe (PrevTree a)) is equivlant to (Tree a)
05:01:31 <dramforever> equivalent, sorry for spelling
05:01:37 <solarus> okok :)
05:01:54 <Axman6> @hoogle 'String -> String
05:01:56 <lambdabot> Parse error:
05:01:56 <lambdabot>   'String -> String
05:01:56 <lambdabot>   ^
05:02:00 <Axman6> :(
05:02:02 <solarus> kinda misunderstood
05:02:05 <dramforever> If you don't know how yet...don't worry, just convince yourself that those two are convertible
05:02:11 <dramforever> lamas: ^
05:03:01 <BobbyB> solarus:    test b = flip zip (sort b) ( map ((+1) . fromJust . flip elemIndex (sort b)) (sort b) )             test :: (Ord a) => [a] -> [(Int, a)]         does this help?
05:04:15 <Axman6> eikke: not sure if Typeable will be useful to you, but you may want to have a look
05:04:39 <eikke> Axman6: no, that code is a simplification of my actual problem :)
05:04:44 <solarus> BobbyB: that works for me or what is the question now? :)
05:04:46 <lamas> dramforever: Did I just do a mistake? tried to make a paste.
05:04:58 <solarus> or at least compiles
05:05:06 <lamas> Either way it should be something like treeConverter :: Tree -> branChtree
05:05:06 <lamas> treeConverter (tree a) = (branchTree a)
05:05:18 <lamas> BranchTree *
05:05:32 <BobbyB> solarus: It says Couldn't match expected type `[Int]' with actual type `Int'
05:05:35 <lamas> Should be somehow recursive so I can traverse the tree
05:05:40 <dramforever> yeah
05:06:14 <dramforever> If you don't know how...maybe you should learn more
05:06:29 <lamas> Yeah, Either way thanks a lot for all of your help!
05:06:35 <BobbyB> I feel like I am missing something simple
05:06:58 <lamas> I think it's as simple as needing more practice. Either way thanks a lot. I feel like I learned a lot!
05:07:32 <dramforever> lamas: well...did you learn about pattern matching?
05:08:55 <solarus> BobbyB: that piece of code works for me when copying and pasting it into a terminal
05:09:52 <guibou> Just for fun I'm trying to replace a lambda (\acc x -> (10 == x) || acc) by a function using composition but I'm totally stuck at how to write it. I wanted to do something such as (||)((id) (==10)) but this obviously does not work.
05:10:00 <solarus> I guess your question is why it doesn't work when you have exchanged the ((+1) . fromJust ...) part with one of the versions lambdabot or Axman6 pasted earlier?
05:10:53 <lamas> dramforever: Yeah.
05:12:14 <dramforever> lamas: do you think you need some help to write that function?
05:12:22 <dramforever> (I'm free now)
05:12:28 <BobbyB> solarus: Yeah it doesn't work with those for some reason. I was just trying to get rid of the periods
05:12:44 <dramforever> or you want to learn more and figure it out on your own
05:12:49 <solarus> BobbyB: paste what you have that doesn't work instead :)
05:13:46 <quchen2_> guibou: The idea is that you take the outermost variable binding and transform the expression enough so you can eta-reduce it away (by massively flipping things around). Iterate that until no lambda bindings are left.
05:13:57 <BobbyB> Doesn't work: test b = flip zip (sort b) ( (\x -> 1 + fromJust (elemIndex x (sort b))) (sort b) )
05:13:58 <quchen2_> guibou: Lambdabot can also do it for you automatically, with usually horrible results.
05:14:04 <BobbyB> Works: test b = flip zip (sort b) ( map ((+1) . fromJust . flip elemIndex (sort b)) (sort b) )
05:14:05 <quchen2_> ?pl (\acc x -> (10 == x) || acc
05:14:05 <lambdabot> (line 1, column 28):
05:14:05 <lambdabot> unexpected end of input
05:14:05 <lambdabot> expecting letter or digit, variable, "(", operator, "||", "+++", "|||" or ")"
05:14:09 <quchen2_> ?pl (\acc x -> (10 == x) || acc)
05:14:09 <lambdabot> flip ((||) . (10 ==))
05:14:17 <solarus> BobbyB: missing a map
05:14:56 <guibou> quchen2_: haha, thank you ! I had found pl and pf and was trying to install them, but did not occur to me that it was available as an irc bot ;)
05:14:57 <bjornars1> an alternative to the above is to write a function that is actually readable
05:15:58 <guibou> quchen2_: now my brain just melt... I'll fix that ;) Thank you.
05:16:02 <lamas> dramforever: Sorry, had to go to the bathroom
05:16:13 <BobbyB> wow I can't believe I missed that, thanks solarus!
05:16:15 <dramforever> do you want that?
05:16:26 <lamas> dramforever: I think I'll take and read more in the book I'm reading
05:16:34 <dramforever> yeah good
05:16:39 <lamas> dramforever: (Haskell craft of functional programming).
05:16:46 <dramforever> good
05:17:12 <lamas> dramforever: thought that making a datastructure and trying to traverse it would be good excersize, but It's a bit to early it seems, either way thanks!
05:17:24 <BobbyB> What exactly does fromJust do?  This is my first time using it and I don't think I fully understand     fromJust (elemIndex x (sort a))
05:17:32 <hpc> @src fromJust
05:17:32 <lambdabot> fromJust Nothing  = undefined
05:17:32 <lambdabot> fromJust (Just x) = x
05:18:32 <dramforever> Actually, I'm wondering: Is S,K,Y (ap, const, fix) enough if typed? I know that S,K is enough if untyped
05:19:05 <BobbyB> hpc: I'm still new to haskell, can you explain that please?
05:19:26 <dramforever> like...is it possible to write a @pl that only emits ap, const, fix and parens?
05:19:47 <hpc> > fromJust (Just "whatever you want here") -- it does this
05:19:48 <lambdabot>  "whatever you want here"
05:19:53 <hpc> > fromJust Nothing -- but it crashes if you do this
05:19:55 <lambdabot>  *Exception: Maybe.fromJust: Nothing
05:22:19 <BobbyB> hpc: since I'm not using Just "..."  do you think I need that?
05:22:58 <dramforever> hpc: elemIndex is using Just
05:23:05 <dramforever> @src elemIndex
05:23:05 <lambdabot> elemIndex x = findIndex (x==)
05:23:11 <dramforever> @src findIndex
05:23:11 <lambdabot> findIndex p = listToMaybe . findIndices p
05:23:20 <dramforever> @src listToMaybe
05:23:20 <lambdabot> listToMaybe []    = Nothing
05:23:20 <lambdabot> listToMaybe (a:_) = Just a
05:23:32 <dramforever> see, there's the "Just"
05:26:58 <hpc> BobbyB: you shouldn't ever need fromJust, it's a pretty crap function
05:27:32 <hpc> i would use pattern-matching
05:27:44 <BobbyB> hpc: and dramforever:  is there a way to do this without fromJust?
05:27:47 <merijn> Or fromMaybe, or maybe
05:27:56 <merijn> BobbyB: fromMaybe, maybe and pattern matching
05:28:12 <hpc> you should learn to get comfortable with pattern-matching
05:28:40 <hpc> and also get comfortable thinking in types, it will make it easier to know what you do and don't need
05:29:03 <hpc> that's probably the most important skill to using haskell well
05:29:17 <hpc> and mostly comes with practice
05:31:38 <BobbyB> I will read up on that. Where should I start one I try to rewrite the function?
05:32:24 <BobbyB> That's not something simple to switch to switch my function to is it?
05:48:51 * hackagebot mime-mail 0.4.8 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4.8 (MichaelSnoyman)
05:51:11 <BobbyB> > type just
05:51:12 <lambdabot>  <hint>:1:1: parse error on input ‘type’
05:58:51 * hackagebot cabal-rpm 0.9.4 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.9.4 (JensPetersen)
06:03:34 <BobbyB> type just
06:04:01 <Procian> Which function are you after?
06:04:09 <Procian> @type Just
06:04:09 <lambdabot> a -> Maybe a
06:12:42 <BobbyB> Procian:   (\x -> 1 + fromJust (elemIndex x (sort a)))   removing fromJust and using Just, or patern matching
06:13:32 <Procian> Is it possible for the x not to be in "sort a"?
06:16:05 <BobbyB> I don't think so, but I'm not 100% sure. Are there two approaches?
06:18:01 <Procian> Yeah, if it's possible that you fromIndex fails, because, say, the caller passed in bad arguments, then you probably want to propagate the Nothing.
06:18:41 <Procian> If there are no callers who can pass in bad arguments, and you're sure that elemIndex failing means that you yourself have done something wrong, then I'd stick with fromJust.
06:18:52 * hackagebot units-defs 2.0.0.1 - Definitions for use with the units package  http://hackage.haskell.org/package/units-defs-2.0.0.1 (RichardEisenberg)
06:20:19 <nschoe> Hey, if I want to use cabal sandboxes "exclusively", what are the "only" programs that I should have installed globally in ~/.cabal/bin?
06:20:45 <Procian> All I've got in mine is "cabal."
06:20:48 <bergmark> nschoe: binaries don't matter
06:21:05 <nschoe> bergmark, how so?
06:21:13 <bergmark> i usally build binaries in a sandbox and cp them to ~/.cabal/bin
06:21:41 <nschoe> Ah, ok, I wanted to know about that: is moving the exe in the ~/.cabal/bin the "correct way"?
06:21:54 <bergmark> i've never had problems with it at least :-)
06:22:07 <nschoe> Procian, do you have ghc installed with your distro's package manager?
06:22:28 <Procian> nschoe: Nope.
06:22:34 <nschoe> bergmark, what about adding the sandbox's to your PATH?
06:22:38 <Procian> I compiled it from source.
06:22:42 <bergmark> nschoe: sure you can do that
06:22:44 <nschoe> Procian, so you installed with with cabal ? in a sandbox?
06:23:05 <bergmark> nschoe: make sure cpphs, alex, happy are in your path, you'll need them to build some packages
06:23:07 <Procian> nschoe: Yeah. But then I copy straight into ~/bin
06:23:14 <nschoe> bergmark, is that "good" or was it a "sure, you can do that, call me in a month to see the mess ^^" ? ^^
06:23:52 * hackagebot language-lua 0.6.2.1 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.6.2.1 (OmerAgacan)
06:24:10 <nschoe> Procian, okay, kidna what I had thought about. Do you do that for all exe you build with cabal?
06:24:31 <nschoe> I'm sorry I ask a lot of questions, but I'd like to find "the" correct way to have a perfectly clean install on my laptop.
06:24:31 <Procian> Yeah, though I think I only have a few. xmonad and xmobar at least.
06:24:44 <nschoe> Okay.
06:25:53 <nschoe> Well the two solutions I have considered are like you guys said: build in sandboxes, then move to either ~/bin or ~/.cabal/bin (which is basically the same), or manually add the sandbox into my$PATH each time.
06:27:33 <Procian> I don't have root on this machine though. I'd quite like to give that NixOS a try and then get as much of my haskell through the package manager.
06:31:39 <cfoch> hello, is there something like typeOf which returns the type of a function but working for non-default types?
06:31:56 <mauke\> what are you trying to do?
06:32:19 <cfoch> I just want to print the data type of a function in my code.
06:33:20 <mauke\> why?
06:33:21 <merijn> You can't use typeOf on functions because functions can't be Typeable instances
06:33:31 <mauke\> merijn: since when?
06:33:39 <mauke\> > typeOf ord
06:33:41 <lambdabot>  Char -> Int
06:34:10 <cfoch> But If I define my own type it doesn't work
06:34:27 <mauke\> create a Typeable instance for it
06:34:32 <mauke\> but still: why?!
06:36:21 <merijn> mauke\: oh, I guess it's only polymorphic functions that you can't
06:36:26 <merijn> > typeOf id
06:36:27 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
06:36:27 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
06:36:27 <lambdabot>  The type variable ‘a0’ is ambiguous
06:38:52 * hackagebot hharp 0.1.1.0 - Binding to libharp  http://hackage.haskell.org/package/hharp-0.1.1.0 (thoferon)
06:38:56 <mauke\> well, it doesn't know which instance to use
06:39:05 <mauke\> > typeOf (id :: String -> String)
06:39:07 <lambdabot>  [Char] -> [Char]
06:44:52 <BobbB> Is there an alternative to elemIndex? that doesn't use Just
06:44:54 <nschoe> Hum so I need ghc in order to use cabal sandbox...? So I can't build ghc into a sandbox, I need to install it globally, right?
06:45:46 <Procian> BobbB: It's got to wrap the value in something, else the function will be partial in the case that the element isn't found.
06:46:05 <photex> nschoe: that's my understanding of the situation at least.
06:46:34 <nschoe> photex, okay so I just have to install ghc from my distro pkg manager, then ^^
06:46:36 <nschoe> Thanks.
06:47:04 <Procian> nschoe: I'm pretty sure GHC is the old ./configure && make && make install business.
06:47:22 <photex> Procian: it requires a ghc though to build itself
06:47:51 * photex tried to use nix as well as the system package manager
06:47:58 <mauke\> photex: not if you use the binary download ... does that still exist?
06:48:10 <photex> I have done that in the past
06:48:19 <nschoe> Well it's fine, I'm under Arch, the ghc binary works out-of-the-box. I was just curious if I could have everything without the need for a distro's pckage
06:48:26 <photex> but lately there seems to be nice community members packaging ghc for distros that neglect it
06:48:27 <geekosaur> nschoe, there is also hsenv which sandboxes ghc installations. it's not very widely used though because that is usually overkill
06:48:32 <photex> in my case OpenSuSE
06:49:02 <BobbyB> Sorry my internet go disconnected. Is there an alternative to elemIndex?
06:49:13 <Procian> BobbB: It's got to wrap the value in something, else the function will be partial in the case that the element isn't found.
06:49:20 <photex> nschoe: like mauke\ suggested, a binary download can also get you up and running super quick
06:49:32 <nschoe> Ah good to know geekosaur , thanks. As you said, this seems "overkill", I won't use it (because I don't *need* a sandboxed installation, I was just curious). But I'll definitely keep that in mind, thanks.
06:49:43 <photex> oh hey, isn't halcyon a thing that does this for you?
06:49:43 <nschoe> photex, okay, good to know. Thanks.
06:49:56 <geekosaur> and I don't quite see the point of avoiding a distro package unless you're from the wild west (e.g. ruby community where distro packages are considered evil because then random devs can't force you to use only their exact versions of everything and just forget about using their stuff with anyone else's)
06:50:02 <photex> nschoe: maybe look at this: https://halcyon.sh/
06:50:03 <BobbyB> Procian: if I know it is in the list would it be ookey?
06:50:10 * photex hasn't used it, but just remembered reading about it
06:50:36 <Procian> BobbyB: Yeah. If you can imagine being able to prove that the element is always in the list, then I'd go ahead and use fromJust.
06:50:50 <photex> geekosaur: the default OpenSuSE ghc is too old for most things in stackage or LTS land that I'm interested in
06:50:51 <nschoe> Thanks photex, looks nice. I'm reading it right now.
06:50:57 <photex> but your mileage may vary of course
06:51:10 <zl64c> hello, im newbe in haskell, right now im learnig from Haskell for great good, and have problem with this code
06:51:11 <zl64c> http://pastebin.com/EhQUbgLx
06:51:34 <BobbyB> would "head elemIndices" be the same as elemIndex? if there is only one of each thing
06:52:10 <bennofs> zl64c: RealFlota -> RealFloat
06:52:23 <mauke\> head is as bad as fromJust
06:52:43 <BobbyB> ah dang..
06:52:49 <Procian> BobbyB: What would be the argument to elemIndices?
06:53:11 <BobbyB> the element to find and a sorted list
06:53:20 <zl64c> bennofs: right, but i have parse error on input '='
06:53:26 <BobbyB> there are no duplicates and it is in the list
06:53:28 <merijn> zl64c: There's html escape codes instead of > there and RealFloat is typo'ed
06:53:36 <Procian> Then I don't think elemIndices would make much sense. It can return at most one value, so you'd stick with Maybe.
06:53:58 <bennofs> zl64c: are you using tabs?
06:54:07 <zl64c> bennofs: yes
06:54:08 <merijn> Quick question that I can't remember the answer too: Are Monads unique?
06:54:12 <mauke\> zl64c: =&gt; should be =>
06:54:17 <bennofs> zl64c: i suggest you to use spaces then
06:54:30 <merijn> If not, is there an example where it isn't?
06:55:00 <bennofs> merijn: at least Applicatives are not unique
06:55:03 <BobbyB> Procian: I have been reading on Just and pattern matching but not having any luck. ( map (\x -> 1 + fromJust (elemIndex x (sort b)))    can you think of a way to rewrite this?
06:55:07 <mauke\> merijn: hmm. backwards state?
06:55:24 <merijn> bennofs: I know that :p
06:55:25 <mauke\> also, prepend Writer. is that a thing?
06:55:45 <Procian> BobbyB: I'd stick with fromJust. If you're sure the Nothing case is impossible, then a pattern-match isn't much use to use, since in the Nothing case, you'll still probably want to throw an error.
06:55:53 <merijn> mauke\: No, but I get what you mean :)
06:55:55 <Procian> *use to you
06:59:01 <ChristianS> Procian, BobbyB: well the problem with fromJust (and head) etc. is that they just throw a very generic error message. you'll know that a fromJust went wrong somewhere in your code, but not which one.
06:59:33 <ChristianS> Procian, BobbyB: hence a custom error message can at least facility debugging
07:00:26 <zl64c> THANKS guys :-)
07:01:25 <Procian> ChristianS: Yeah, I agree.
07:09:50 <nschoe> Hum, how can I specify cabal to compile with all my cores ? I have 4 cores, yet I see only 25% used. I have checked and I do have "jobs: $ncpus" in my ~/.cabal.config. Are settings differents in sandboxes?
07:10:25 <dmilith> yea, it uses 100% cpu, so it's 1 core max
07:10:28 <dmilith> same here
07:11:07 <mmachenry> nschoe: I think you need to compile with threads but then run your program with a runtime system argument.
07:11:16 <nschoe> dmilith, are you sayign that cabal can't use more than one CPU?
07:11:19 <mmachenry> nschoe: +RTS -n4
07:11:32 <dmilith> it's compiled with threads if you have "perf" in build.mk
07:11:41 <dmilith> nschoe: i'm also asking
07:11:46 <Welkin> cabal use multiple threads by default
07:11:47 <nschoe> mmachenry, so I should "cabal install +RTS -n4"?
07:11:49 <dmilith> yea
07:11:51 <Welkin> uses*
07:12:00 <nschoe> dmilith, ok, sry.
07:12:14 <merijn> No
07:12:42 <merijn> You should "cabal install -j4"
07:12:58 <merijn> Or just "cabal install -j"
07:12:59 <dmilith> like with make
07:13:18 <nschoe> merijn, ah ok. But then what is the 'jobs' parameter in ~/.cabal/config for?
07:13:28 <dmilith> yea
07:14:16 <merijn> Dunno, that's new to me
07:14:44 <nschoe> (I've just tried it, "cabal install myProg -j4" does indeed use all 4 CPUs to 100%, thanks)
07:16:16 <cfoch> is there a function to open an "interactive" prelude... I want to set something like a breakpoint?
07:16:47 <dcoutts_> merijn, nschoe: -j --jobs and the jobs field in the config file are all the same thing
07:17:48 <nschoe> dcoutts_, Well I would assume so too, but when I simply use "cabal install hakyll" for instance, it only uses one CPU (monitoring with htop at the same time); but when I use "cabal install hakyll -j4" all 4 CPUs run at 100%
07:22:41 <nschoe> dcoutts_, okay after some more thorough tests, it seems you were right: it does indeed do the same. It just seems I messed up my previous tests with htop. Sorry
07:22:53 <dcoutts> np
07:23:51 <dcoutts> nschoe: the command line and config file syntax are mostly in direct correspondence (produced from the same bit of code)
07:25:32 <hesiod> I have made changes to some library X (on Hackage) which I need to use in my cabal-managed project Y. The author of X can't incorporate my changes yet. How can I tell cabal to use a specific local version of X for Y?
07:26:07 <tdammers> hesiod: you can manually install local packages into a sandbox by specifying paths instead of package names
07:26:15 <tdammers> e.g. cabal install ../../my-other-package
07:26:31 <tdammers> once installed, the local version will be considered when resolving dependencies
07:26:50 <hesiod> tdammers: Thanks, that's just what I need!
07:26:51 <nschoe> dcoutts, yeah, ok. Seems logic ^^ Th
07:26:54 <nschoe> +x
07:27:47 <nschoe> hesiod, I think you might want to consider cabal add-source /path/to/sandbox if you want to track the changes in your local version.
07:30:47 <nschoe> How come when I try to install a program with lots of deps (hakyll in this case) the build fails mid-time, saying "can't install progr XXX", then I simply "cabal install XXX", it works, then back to "cabal install hakyll" and it works?
07:31:10 <geekosaur> nschoe, depends on if it's a program dependency vs. a library dependency
07:32:04 <mniip> in GHC, is there some hack to import an unexported function from a module?
07:32:51 <merijn> nschoe: Cabal can't currently track executable dependencies
07:33:02 <bennofs> mniip: you could maybe do it somehow with TH. not sure
07:33:10 <geekosaur> there is a package on hackage that claims to abuse TH to do it. I would not be entirely trusting of it
07:33:42 <nschoe> geekosaur, merijn so basically it means that when it does that, it is because it depends on a executable, not a lib, right? (Haven't checked when it happened)
07:33:58 <Dholli> Can someone help me fill a matrix with a function?   newtype Matrix a = Mat ((Int,Int),(Int,Int) -> a)    I've tried a few different things but didn't get anywhere with them
07:34:42 <geekosaur> well, it's a bit complex. one issue is that cabal relies on ghc's package database --- which doesn't know about programs, only libraries
07:35:00 <geekosaur> another is that if it does install a program, that program may land outside of your $PATH and then it can't find it later
07:35:25 <geekosaur> (make sure $HOME/.cabal/bin is in $PATH to avoid that one)
07:35:39 <geekosaur> (different path on windows, different path if using a sandbox)
07:35:54 <Dholli> fillMatrix :: (Int,Int) -> a -> (Matrix a)
07:36:01 <geekosaur> (and potentially different path on os x depending on whose ghc you installed)
07:36:06 <nschoe> Ok. But ten I've just checked, hakyll installation just failed to me, and it told me that "http-client" could not be installed. I 'cabal installed http-client' and I do have it: ".cabal-sandbox/lib/x86_64-linux-ghc-7.8.4/http-client-0.4.7.1/libHShttp-client-0.4.7.1-ghc7.8.4.so" ?
07:36:43 <nschoe> geekosaur, yeah ok, I can see how this would indeed fails. I am in a sadbox indeed.
07:37:21 <nschoe> But I've just checked now: 'http-client' is a lib. And it got installed in .cabal-sandbox/lib/x86_64...
07:37:41 <nschoe> Could that be (just a theory) that one thread was not finished compiling it whereas another thread needed it?
07:37:59 <geekosaur> if so that'd be a bug in cabal-install
07:38:33 * geekosaur must vanish into a conference call, "yay" tuesdays...
07:39:47 <Dholli> Anyone have experience with filling a matrix?
07:40:15 <nschoe> geekosaur, well okay. Sorry bothering you. (I'm not sure at all for the thread thing, I was just asking)
08:07:30 <hodapp> if I'm needing something like Data.Binary, but rather than actually serializing a data format, I'm rather just interested at getting at a list of offsets/lengths corresponding to a type, is there anything that is close to that?
08:08:54 <Clint> hodapp: Storable?
08:09:29 <hodapp> that might be able to help
08:10:14 <hodapp> looking at the GBinary typeclass too which I may automatically derive from, but I don't know if I'd be able to deconstruct the output of gput/gget and get something useful
08:11:07 <hodapp> Clint: http://hackage.haskell.org/package/storable ?
08:11:13 <hodapp> that's from 2009...
08:11:32 <hannes__> hodapp: The storable class from ffi
08:11:34 <hodapp> oh, Foreign.Storable?
08:12:43 <hodapp> hmm, I may just have to roll my own format or something
08:12:56 <hannes__> hodapp: Although that's mostly used to map haskell datatypes to C struct-like objects (and vice versa)
08:13:03 <hannes__> hodapp: Not sure if that's what you're looking for
08:15:15 <hodapp> the problem is that what I need is a bit odd, in that I don't actually need Haskell to serialize/deserialize anything - what I need is to generate some structures for an EDSL to tell that EDSL how it would perform serialization/deserialization
08:16:58 <hannes__> huh. Alright, then what exactly would the thing you're looking for look like?
08:17:06 <kess> hey all!
08:17:22 <kess> what's the go-to tool for automated verification these days? (is there one?)
08:18:02 <hodapp> kess: can you be a little more specific on what sort of automated verification?
08:18:32 <hodapp> kess: if you're trying to verify a program after-the-fact not a lot of the tools have really changed - things like ACL2 are still common
08:18:54 * hackagebot haskhol-core 1.1.0 - The core logical system of HaskHOL, an EDSL for HOL theorem  proving.  http://hackage.haskell.org/package/haskhol-core-1.1.0 (EvanAustin)
08:19:33 <hodapp> kess: if you're trying to derive a verified program from a specification, some new things have been kicking around like Coq, Idris, and Agda
08:19:45 <kess> ah, the former is what I'm after
08:20:26 <kess> thanks :)
08:20:49 <hodapp> yeah, dunno, ACL2 and HOL and Isabelle are the ones I'm familiar with
08:21:24 <zipper> Would like some help adding a hidden value to a form in this case adding uid to payslipForm. Code at: https://gist.github.com/urbanslug/a0bae2aca0c0fd3da0c2
08:21:25 <hodapp> I'm not sure that any more interesting results have come out of the realm of verifying software in a general language *after* it's written
08:21:30 <zipper> Using Yesod
08:25:09 <zipper> Naaah I found a way
08:25:36 <zipper> I guess I was afraid of the types
08:25:44 <zipper> as I often am in Yesod
08:25:59 <zipper> These types are SCARY and I'm afraid to mess up and break everything.
08:26:17 <magicahex> In general, failing to acquire a Binary semaphore would block the task/thread right? Or is it more common to return a value that you check, ACQUIRE_SUCCESS, ACQUIRE_FAIL_ACQUIRE_ERROR; etc?
08:33:42 <sunakshi> here is a question
08:33:47 <sunakshi> constant  :: a -> b -> a
08:33:48 <sunakshi> constant x = \_ -> x
08:33:48 <sunakshi>     
08:34:18 <sunakshi> this was the defination of constant
08:34:40 <sunakshi> but when i ran it on ghci eg constant 5
08:34:47 <sunakshi> error occured
08:34:50 <vanila> try constant 5 "foo"
08:35:03 <int-e> sunakshi: right, you need one more argument.
08:35:14 <ajcoppa> :t const 5
08:35:15 <lambdabot> Num a => b -> a
08:35:23 <sivteck> @let constant x = \_ -> x
08:35:25 <lambdabot>  Defined.
08:35:27 <sivteck> :t constant
08:35:28 <lambdabot> t1 -> t -> t1
08:35:39 <sivteck> > constant 5 343
08:35:40 <lambdabot>  5
08:35:51 <ajcoppa> meaning, const 5 is a function, and GHCI doesn't know how to show you a function
08:36:25 <sunakshi> thumsup!!
08:36:37 <sunakshi> got it
08:37:25 <int-e> > const id "hi" 42 -- of course the first argument can also be a function
08:37:26 <lambdabot>  42
08:43:07 <sunakshi> what is the advantage of using lambda over f
08:43:29 <ab9rf> lambdas are sexier?  i fear i don't understand the question.
08:44:03 <dmj`> sunakshi: what is f?
08:44:33 <sunakshi> while mapping a function we can use lambda over 'f' but do we have any drawback with 'f'
08:44:37 <ab9rf> do you mean using lambda notation (\x -> x) instead of function definition (f x = x) ?
08:44:46 <sunakshi> f is map f ...
08:44:57 <sunakshi> exactly
08:45:03 <ab9rf> use whichever one you finbd most expressive in the context
08:45:14 <ab9rf> you're free to do "let f x = ... in map f ..."
08:45:24 <ab9rf> or "map (\x -> ...) ..."
08:45:26 <Cale> sunakshi: The advantage of lambda is that you don't need to give the function a name
08:45:28 <ab9rf> as it pleases you
08:45:43 <dmj`> sunakshi: point free is sexier, but beware of obfuscation
08:45:43 <sunakshi> okay
08:45:44 <ab9rf> in some cases, the lambda is clearer
08:45:57 <ab9rf> in others using a bound name is clearer
08:46:05 <drazak> the function is anonymous
08:46:13 <sunakshi> got it
08:47:52 <dmj`> listToMaybe, what a joke
08:48:01 <dmj`> > listToMaybe "hey"
08:48:02 <lambdabot>  Just 'h'
08:48:40 <ab9rf> dmj`: i actually used listToMaybe recently
08:49:10 <kess> what was the context?
08:49:25 <ab9rf> i forget :)
08:49:33 <kess> can't have been that important then ;)
08:49:35 <mniip> Haskellers hate him! Infinite Show instances with this one weird trick! https://gist.github.com/mniip/05cd6e4def1fbdff6f1c
08:50:17 <ab9rf> actually might have been maybeToList
08:50:31 <kess> mniip: not gonna lie to you, I spent a good 30s looking at that thinking "this is some weird-ass Haskell..."
08:50:59 <dmj`> ab9rf: yea maybeToList has more sane functionality imo
08:51:07 <kess> yeah that makes more sense
08:51:29 <dmj`> ab9rf: I want [] -> Nothing; xs -> Just xs, is there a function for that? Instead of just taking the head
08:51:38 <dmj`> if null xs then Nothing else Just xs
08:51:43 <hodapp> I have to confess that I'm generating some Haskell code in Python because I don't feel like learning either (1) how Text.Printf does its variadic magic or (2) how to use Template Haskell.
08:51:49 <Twey> I often use predicateToMaybe p x = if p x then Just x else Nothing
08:52:17 <Twey> hodapp: Typeclasses
08:52:20 <Twey> :t printf
08:52:20 <dmj`> mniip: infinte Show instances :)
08:52:21 <lambdabot> PrintfType r => String -> r
08:52:24 <dmj`> what does that even mean lol
08:52:27 <ab9rf> dmj`: that's [a] -> Maybe [a]?
08:52:42 <hodapp> Twey: Can you be a little more specific there?
08:52:45 <lpaste> mniip pasted “example” at http://lpaste.net/120649
08:52:51 <dmj`> ab9rf: yes
08:53:07 <Twey> hodapp: instance PrintfType String, instance (PrintfArg a, PrintfType r) ⇒ PrintfType (a → r)
08:53:16 <ProofTechnique> ab9rf: Also listToMaybe
08:53:18 <ab9rf> dmj`: hrm.  i must admit that 've never had a need for that
08:53:34 <Twey> hodapp: It is not a particularly sophisticated mechanism :þ
08:53:36 <ProofTechnique> Oh, wait, scrollback. Nevermind
08:53:59 <dmj`> ab9rf: my use case is retrieve a url from stdin. If the user doesn't specify anything (i.e. getLine returns an empty list), then the url should be Nothing, else whatever the bytes from stdin
08:54:02 <dmj`> retrieving*
08:54:30 <ab9rf> dmj`: eh.
08:54:46 <dmj`> ab9rf: I don't need a full blown command line package
08:55:01 <ab9rf> yeah, i get what you're looking for
08:55:02 <hodapp> Twey: oh, so it's just making a function an instance of a typeclass?
08:55:07 <Twey> hodapp: Yeah
08:55:11 <Twey> hodapp: So printf "%s" ∷ String (but the instance gives an error at runtime), printf "%s" ∷ String → String, printf "%s" ∷ Int → String, printf "%s" ∷ Int → (Int → String), &c.
08:55:20 <kess> but why even use a Maybe though?
08:55:33 <kess> I mean Maybe [a] is isomorphic to [a]
08:55:52 <int-e> kess: nope, Maybe [a] has two distinct empty values
08:55:52 <Twey> hodapp: And all but the String → String instance error (… actually there is also a String → IO () instance that doesn't, since, as a bonus, instance PrintfType (IO ()))
08:56:19 <dmj`> kess: if the url is Nothing, it will default to either the production AWS url or localhost:8000 (dev url). O/w I want to connect to a running server on another machine, so I'll specify a url manually
08:57:26 <Twey> kess: ‘Maybe [a] is isomorphic to [a]’ — not without some pretty sophisticated encoding relying on knowledge of a
08:57:31 <ReinH> Maybe [()] <=> [()], but Maybe [a] is not isomorphic to [a]
08:57:44 <ReinH> Twey: it's not that sophisticated :)
08:57:55 <kess> yeah, sorry, I was thinking too simply
08:57:59 <ReinH> It's the same as [0..] <=> [1..]
08:58:49 <hannes__> oohhh I had forgotten that printf can also resolve to IO () lol
08:58:53 <Twey> ReinH: Well, I was thinking of strings, where you'd have to dedicate a special Char at the front of the list or something to represent Nothing, then introduce an encoding for that String value (but none of the other possible values of the leading Char) by e.g. shifting a bit across every other character :þ
08:59:05 <ReinH> Well, it's simple for Enumerable a, otherwise I think you need AC to have an isomorphism?
08:59:08 <ab9rf> beh
08:59:38 <dmj`> I love how my initial question was how to best retrieve a string from stdin and we digress into isomorphisms :)
08:59:46 <kess> haha
08:59:47 <ab9rf> dmj`: welcome to #haskell :)
08:59:50 <Twey> dmj`: Machines!  ;)
09:00:04 * dmj` sighs
09:00:06 <dmj`> :)
09:00:10 <kess> anyway what I was going for is this
09:00:12 <mauke\> Twey: f Nothing = []; f (Just xs) = undefined : xs
09:00:18 <ab9rf> dmj`: before long there will be a co-something that explains it all
09:00:36 <ab9rf> dmj`: and i'll have a headache
09:00:39 <mauke\> g [] = Nothing; g (_ : xs) = Just xs
09:00:51 <kess> if it's so that you can use fromMaybe somewhere then I guess it's ok, but if you ever check the value with isNothing then it's more elegant (in my opinion) to just check for a null string
09:01:00 <Twey> mauke\: Oh, undefined is cheating.  ☹
09:01:03 <int-e> ReinH: a pointed type a with equality should be enough.
09:01:04 <kess> since in your case null strings get converted into Nothing anyway
09:01:22 <mauke\> Twey: well, where else am I going to get an 'a'?
09:01:28 <Twey> mauke\: Precisely
09:01:31 <ab9rf> dmj`: clearly yhou should write a parsec parser :)
09:01:41 <hodapp> hmmm, actually, I'm not sure if that typeclass method will work here... problem is that the 'ultimate' function signature varies
09:01:46 <kess> mempty of course ;)
09:02:06 <int-e> ReinH: but perhaps I'm missing something.
09:02:08 <ab9rf> mauke\: your g isn't total
09:02:13 <ReinH> kess: And of course, even if two things are isomorphic, that doesn't mean they are similarly expressive or easy to use.
09:02:14 <ab9rf> mauke\: no, nevermind
09:02:21 <kess> indeed
09:02:21 <ab9rf> mauke\: it's just safeTail
09:02:44 <Twey> mauke\: Hm, is that even an isomorphism, anyway?  x : xs maps onto Just xs for all values x
09:03:02 <ReinH> int-e: well, the isomorphism involves choosing a pair of (a,a)  an infinite number of times, right? If a is enumerable, you can set it up as (a, succ a). Otherwise you need AC. At least, that's my thinking.
09:03:03 <mauke\> oh, true
09:03:15 <mauke\> it just tunnels Maybe [a] through [a]
09:03:49 <cfoch> can I import a newtype?
09:04:01 <Twey> mauke\: Hence, I guess, ReinH's statement about [()]
09:04:04 <cfoch> I would like to import
09:04:05 <cfoch> https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/PackageIndex.hs#L82
09:04:11 <cfoch> how can I import it?
09:04:30 <ReinH> cfoch: import works on modules, so you can import a module that exports the newtype definition.
09:04:46 <int-e> ReinH: I intend to map between lists consisting of n copies of a distinguished element of a (the point) and Nothing / lists of length n-1, and not touch any other lists (except wrapping/unwrapping them in Just)
09:05:09 <int-e> ReinH: but there's a snag if you allow infinite lists.
09:05:09 <ReinH> int-e: ah
09:05:10 <mauke\> cfoch: import Distribution.Client.PackageIndex (PackageIndex) ?
09:05:25 <ReinH> cfoch: you can import that module
09:05:30 <kaplan_> McManiaC, hi
09:05:49 <McManiaC> lol hi
09:06:05 <ReinH> int-e: Ah.
09:06:58 <dmj`> ab9rf: clearly :)
09:07:06 <cfoch> and what is the problem with this function? I would like to obtain the "pkg" of a PackageIndex
09:07:09 <ReinH> int-e: I guess my point is that if the only thing we can do with a is choose its members, constructing the isomorphism requires AC. Which isn't a very relevant point, at this... point.
09:07:15 <cfoch> getPkgInfo (PackageIndex pkg) = pkg
09:07:55 <ReinH> cfoch: PackageIndex does not wrap a single package. It wraps a Map of packages.
09:08:07 <ReinH> So there is no PackageIndex pkg to match on
09:08:43 <mauke\> also it's an abstract type
09:09:05 <ReinH> mauke\: Oh, good point.
09:09:24 <ReinH> cfoch: And in any event, that module does not export the constructor, so you can't pattern match on it at all.
09:09:38 <ReinH> cfoch: You need to use the interface provided by the library to work with a package index.
09:09:41 <mauke\> https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/PackageIndex.hs#L123
09:11:38 <cfoch> mauke\: I think that is the function I was looking for.
09:12:16 <cfoch> I am not sure how did you guess I was looking for that function :)
09:14:16 <mauke\> you said "I would like to obtain the "pkg" of a PackageIndex"
09:14:46 <mauke\> so I looked for function types that contain PackageIndex in the arguments, but not the result
09:15:40 <sunakshi> ok.. then
09:16:08 <sunakshi> halve     :: [a] -> ([a], [a])
09:16:08 <sunakshi> halve xs = ([take len xs], [drop len xs])
09:16:22 <mauke\> is this merge sort?
09:16:40 <sunakshi> no
09:16:47 <ab9rf> feh!
09:16:54 <sunakshi> a function for splitting the list from middle
09:16:56 <mauke\> anyway, your [ ] are wrong
09:17:38 <sunakshi> please explain
09:17:50 <ReinH> mauke\: You know what I want? Hoogle restricted to a particular package.
09:18:09 <mauke\> ReinH: I'm pretty sure it can do that
09:18:23 <ReinH> Oh there's a secret command of some kind?
09:18:39 <mauke\> sunakshi: [foo] is a list of length 1, containing foo
09:18:55 <mauke\> sunakshi: [take len xs] is a list of length 1, containing take len xs, which is another list (of length <= len)
09:19:05 <hsk3> One problem I notice with Haskell is that code uses type aliases to supposedly make the code more descriptive. Problem is, you don't know whether "CustomerName" is an actual String or something else entirely. So I have to keep scrolling between code and type aliases to make sense of code. Is there a way around this?
09:19:22 <sunakshi> ??
09:19:59 <zipper> How can I access the value inside a monad from (<*>) ?
09:20:15 <chaosmasttter> hsk3 load the code into ghci and use :info on the type
09:20:22 <johnw> zipper: that doesn't quite compute; can you reask?
09:20:24 <mauke\> zipper: huh?
09:20:30 <dmj`> ReinH: think you can set the scope in the query params for the hoogle api
09:20:32 <dmj`> https://hackage.haskell.org/package/hoogle-4.2.38/docs/Hoogle.html#t:Query
09:20:44 <mauke\> > 2 + 2
09:20:46 <lambdabot>  4
09:20:49 <mauke\> > [2 + 2]
09:20:51 <lambdabot>  [4]
09:20:57 <mauke\> > [take 3 "hello"]
09:20:58 <lambdabot>  ["hel"]
09:21:06 <mauke\> > [take 3 [1,2,3,4]]
09:21:07 <lambdabot>  [[1,2,3]]
09:21:09 <mauke\> sunakshi: ^
09:21:17 <sunakshi> yes
09:23:29 <HeladoDeBrownie> zipper, a few reasons why that doesn't make much sense: (1) a monad is a *type* of kind * -> * meeting a few properties. (2) for a general monadic value, there is no value "inside" it. but anyway, let's take a look at the type of (<*>):
09:23:32 <HeladoDeBrownie> @type (<*>)
09:23:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:23:42 <zipper> I have a value that is returned from one function. However I want to access it in another function through (<*>) Code is at:  https://gist.github.com/urbanslug/4838a6ba659c2f17fade
09:23:45 <dmj`> :t ap
09:23:46 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:23:54 <ReinH> :t (<*>)
09:23:55 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:24:16 <zipper> HeladoDeBrownie: johnw See my code
09:24:19 <hsk3> chaosmasttter: do you find yourself doing this a lot reading other people's code? i imagine you don't for your own code since you wrote it
09:24:20 <HeladoDeBrownie> zipper, so this lets you take any type which is an applicative applied to a function, and the same applicative applied to the type of that function's parameter, and  get out the applicative applied to the function's output. you can think of this as a different sort of function application.
09:25:10 <HeladoDeBrownie> zipper, always look at the types! is st a function?
09:25:14 <HeladoDeBrownie> err, uid*
09:25:18 <HeladoDeBrownie> zipper, is uid a function?
09:25:41 <HeladoDeBrownie> wait no
09:25:47 <HeladoDeBrownie> sorry, i misread XD
09:25:57 <zipper> HeladoDeBrownie: No it's a value
09:26:06 <zipper> st is a function
09:26:44 <HeladoDeBrownie> "it's a value" does not mean "it's not a function". anyway lemme see if i can come up with a more useful question...
09:27:24 <HeladoDeBrownie> zipper, oh, here's an obvious one, what's the error?
09:28:00 * HeladoDeBrownie is still in waking up mode
09:28:10 <ReinH> zipper: what is the type of st?
09:28:56 * hackagebot HaTeX-qq 0.0.0.0 - Quasiquoters for HaTeX  http://hackage.haskell.org/package/HaTeX-qq-0.0.0.0 (HiromiIshii)
09:29:30 <zipper> ReinH: It'a monad. Uh from yesod. I really don't know for sure.
09:29:51 <mauke\> zipper: so you don't even know what the type is?
09:29:57 <ReinH> zipper: Before you said it's a funciton, now you're saying it's a monad. Just tell me the type.
09:29:58 <HeladoDeBrownie> zipper, you need to know
09:30:08 <ReinH> If you don't know its type, you can't know how to use it.
09:30:24 <ReinH> If it compiles, you can ask for the type in ghci.
09:30:28 <zipper> HeladoDeBrownie: brb I need to take a closer look
09:30:47 <ReinH> (But this is a good example of why it's useful to write the types *first*)
09:30:53 <zipper> ReinH: It doesn't compile
09:30:58 <mauke\> it will have almost the same type as requireAuth
09:31:02 <mauke\> so knowing that would also help
09:31:20 <zipper> ReinH: These yesod types are confusing so sometimes I wait for the compiler to give me the type
09:32:48 <augur> how do i use ghc's -fno-code with cabal? when i do cabal exec ghc, it complains that modules arent found
09:33:30 <ReinH> zipper: I'll just point out that the value on the right hand side of <*> does not have a function type
09:33:32 <HeladoDeBrownie> zipper, i would suggest getting familiar with them since you're going to be using them; you can ask someone if you need help, e.g., if you don't know how to read certain types
09:33:34 <ReinH> :t (<*>)
09:33:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:33:53 <ReinH> It has the type of an "applicative action"
09:34:09 <HeladoDeBrownie> (which could be a function but likely isn't in this case)
09:34:12 <augur> but if i use just cabal repl, it works
09:34:21 <ReinH> HeladoDeBrownie: Which could be a function if a is a function type.
09:34:32 <ReinH> But in practice that doesn't happen much at all.
09:34:38 <HeladoDeBrownie> i meant the "action" itself, the whole f a and whatnot
09:34:44 <mauke\> unless you're using <*>
09:34:50 <mauke\> because then it happens all the time
09:39:43 <lifter> I've been reading up on the Kleisli composition operators (>=>) and (<=<)... Anyone find cases in which they are advantageous over the usual bind?
09:42:08 <sssilver|> Writing a simple toDigits function -- what am I missing?
09:42:17 <sssilver|> "No instance for (Num [Int]) arising from the literal `10'"
09:42:29 <geekosaur> show code?
09:42:31 <geekosaur> @paste
09:42:31 <lambdabot> Haskell pastebin: http://lpaste.net/
09:42:34 <sssilver|> oh sorry https://dpaste.de/5sFd
09:43:49 <cfoch> mauke\: when I do "import Distribution.Package ( PackageName )"
09:43:53 <geekosaur> I think you wanted toDigits (n `div` 10)
09:44:19 <cfoch> If I want to print the package name doing  "  putStrLn $ show $ (PackageName "haq")"
09:44:35 <cfoch> it doesn't work
09:45:01 <sssilver|> geekosaur: you're right!!! arghh
09:45:10 <sssilver|> brackets hell
09:48:56 * hackagebot dynobud 1.1.0.0 - your dynamic optimization buddy  http://hackage.haskell.org/package/dynobud-1.1.0.0 (GregHorn)
09:54:56 <cfoch> why when I do "import Distribution.Package ( PackageName )"
09:55:24 <cfoch> and I try to create a 'PackageName "some_name"'
09:55:27 <cfoch> I get
09:55:36 <geekosaur> cfoch, we saw it the first time and unless you provide more information ("it doesn't work" means precisely the same as "mrurfl gleep")
09:55:37 <cfoch> Main.hs:877:21: Not in scope: data constructor `PackageName'
09:56:22 <geekosaur> because you imported the type
09:56:33 <mauke\> *abstractly
09:56:35 <geekosaur> import Distribution.Package (PackageName(..))
09:56:36 <geekosaur> or
09:56:49 <geekosaur> import Distribution.Package (PackageName(PackageName))
09:57:12 <geekosaur> do you understand the difference between importing a type and importing a type's constructors?
09:57:44 <cfoch> geekosaur: http://fpaste.org/186639/42419577/
09:57:46 <geekosaur> (yes, there are good reasons for this. for example Data.Map would not work correctly if you had access to its constructors, so they are not exported and you must use fromList or etc.)
09:58:27 <geekosaur> yes, and?
09:59:38 <cfoch> geekosaur: nothing, I just wanted to show you that in the line 877 I was calling to PackageName
10:00:02 <geekosaur> please rered what I said above
10:00:10 <geekosaur> *reread
10:01:13 <cfoch> yes, It worked, but I need to understand the difference between importing a type and a type's constructor
10:03:27 <ChristianS> cfoch: types and type constructors are just different things that live in different namespaces
10:05:49 <phaazon> hey, a friend of mine told me that “Haskell is not designed for true programming”
10:05:55 <phaazon> what do you think of that statement guys? :D
10:06:07 <geekosaur> let's try this: you know the Maybe type?
10:06:11 <Clint> i think i want to know what "true programming" is and how i can buy one
10:06:16 <geekosaur> Maybe is the type. Just and Nothing are the ocnstructors
10:06:29 <davean> phaazon: True programming isn't designed well then?
10:06:42 <phaazon> davean: ahah :P
10:06:49 <n4x> true programming is the one that real programmers do, right?
10:06:57 <Clint> so with a soldering iron?
10:06:57 <phaazon> n4x: yeah right
10:07:06 <phaazon> assuming Haskellers are not “real” programmers
10:07:17 <phaazon> I was told, once, that I was a “math guy”
10:07:21 <davean> Of course we're not.
10:07:21 <phaazon> not a “programmer”
10:07:25 <davean> Right, that
10:07:32 <davean> I'm ok with your changing by job title
10:07:33 <geekosaur> in the other direction, you might notice that we use Data,Map but never talk about the structure inside of it (like Just and Nothing in the case of Maybe) --- we use functions like fromList or singleton
10:07:52 <davean> Hell, I work with a mariocartographer
10:08:36 <geekosaur> so sometimes you want constructors to be available and other times not. and even when working with something that has constructors, sometimes for safety / catching certain kinds of programming errors you want to import only a type and not any constructors for it
10:09:12 <geekosaur> (most often when theyr'e named the same thing, because that's when you're most likely to confuse the type and the value)
10:10:31 <geekosaur> so if you're importing things explicitly, most often you want to import a type with all constructors. if something is a constructor, you must import it with its type (because if you don't know its type in Haskell you can't talk about it, so a constructor without the type it's a constructor for is useless)
10:14:16 <S11001001> phaazon: tell them they're right, haskell is only for half-proving simple theorems in constructive logic
10:21:15 <wz1000> http://hackage.haskell.org/package/ACME-0.0.0.1/docs/src/Acme-Trivial.html#Trivial
10:21:33 <wz1000> This needs an urgent patch, wont compile under AMP
10:22:22 <quchen> wz1000: Trivial is in Base and called Proxy
10:22:43 <quchen> (And it's very useful)
10:26:06 <ma_stone> ?wiki Monad
10:26:07 <lambdabot> http://www.haskell.org/haskellwiki/Monad
10:27:16 <ma_stone> @help
10:27:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:27:34 <ma_stone> @kind Maybe
10:27:35 <lambdabot> * -> *
10:27:57 <ma_stone> @pl map (\x -> x + 1) [1..10]
10:27:57 <lambdabot> map (1 +) [1..10]
10:28:16 <ma_stone> \quit
10:28:19 <ma_stone> \exit
10:28:33 <ma_stone> @help list
10:28:33 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
10:28:44 <ma_stone> @list
10:28:45 <lambdabot> What module?  Try @listmodules for some ideas.
10:28:49 <ma_stone> @exit
10:28:49 <lambdabot> Maybe you meant: quit elite
10:28:53 <ma_stone> @quit
10:28:53 <lambdabot> Not enough privileges
10:29:17 <chardan_> Oh, that sieve function's purty.
10:43:57 * hackagebot rainbow 0.20.2.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.20.2.0 (OmariNorman)
10:44:00 <k0ral> how can I use FreeT or MonadFree with control functions (like forkIO, async...) that expect an 'IO a' function ?
10:44:16 <johnw> k0ral: "lift"
10:44:34 <johnw> k0ral: or do you mean, you want to pass an "m a" to forkIO?
10:45:07 <johnw> in that case, you need monad-control: liftBaseDiscard forkIO actionInM
10:45:11 <k0ral> johnw: I mean that, yes, passing an "MonadFree Something m => m a" to forkIO
10:45:36 <k0ral> johnw: FreeT isn't an instance of MonadTransControl
10:45:41 <johnw> and your constraint will have to add: MonadBaseControl IO m
10:45:46 <johnw> you don't need trans control for liftBase*
10:46:13 <johnw> if FreeT doesn't provide Base/TransControl at all, edwardk will take a pull request
10:46:29 <k0ral> FreeT cannot be made an instance of monad-control typeclasses
10:46:53 <johnw> no?
10:46:58 <k0ral> http://stackoverflow.com/questions/23744439/a-monadtranscontrol-instance-for-freet
10:47:14 <k0ral> also: http://stackoverflow.com/questions/17511841/monadtranscontrol-instance-for-proxyfast-proxycorrect/17515535#17515535
10:47:14 <johnw> :(
10:47:21 <k0ral> johnw: that's the point of my question
10:47:25 <johnw> then there is no way
10:47:39 <johnw> even "fork" from lifted-base requires it
10:47:58 <k0ral> I'm a happy guy that has just learned the Free monad, and now I'm realizing that I can't use it in practical
10:48:14 <k0ral> how sad is that ?
10:48:22 <johnw> it's a very practical monad
10:48:33 <athan> Anyone here use the boomerang library? It looks pretty schweet
10:48:46 <johnw> it just doesn't work for interactions with the base monad like this
10:49:09 <johnw> k0ral: I'm using FreeT and Free right now for an assembly language DSL, and it works great
10:49:44 <k0ral> I mean, forking is quite a basic operation any intermediate-sized project will do, so Free monad can't be used in any such project
10:50:02 <johnw> sure you can use the Free monad in such a project
10:50:10 <hannes__> k0ral: Huh?
10:50:13 <johnw> you just can't do your forking at the time you're building the program description with Free
10:50:24 <hannes__> k0ral: You don't have to fork _within_ the monad to do forks
10:50:25 <k0ral> johnw: I'm forking dynamically
10:50:27 <johnw> you need to do your forking during reduction of your Free value, rather than at the time you construct it
10:50:50 <k0ral> this is a really big constraint
10:51:00 <johnw> I have a feeling you might be desiging your solution incorrectly
10:51:05 <johnw> this really shouldn't be a stumbling block
10:51:29 <johnw> typically, if you want actions to be happening within Free, you don't really want Free
10:51:46 <johnw> the whole point of a thing being Free is that it defers all actions until after the value is constructed
10:51:47 <k0ral> ok then I'll describe my current design, maybe you'll have son insight about how to redesign it to bypass that obstacle
10:51:56 <johnw> k
10:52:44 <k0ral> I'm working on an application that has a GUI; I want to be able to react to some events
10:52:52 <k0ral> like mouse clicks and so
10:53:20 <johnw> (as an aside, FreeT m lets you use the effects in 'm' to build your Free value, but still the focus should be on constructing a program description)
10:53:57 * hackagebot vcache 0.1.1 - large, persistent, memcached values and structure sharing for Haskell  http://hackage.haskell.org/package/vcache-0.1.1 (dmbarbour)
10:54:08 <k0ral> the way I've designed it is that I can register hooks (like in emacs), which are basically threads that will wait for events to happens, and trigger callbacks, if any
10:54:32 <johnw> ok
10:54:42 <k0ral> I want to be able to add/remove hooks for any kind of event
10:55:10 <k0ral> adding a hook spawns a new thread, removing a hook kills the associated thread
10:55:20 * johnw gets the feeling that your design is going to end up looking like an FRP framework :)
10:55:43 <k0ral> (I'll talk about FRP after, bear with me)
10:55:46 <johnw> k
10:56:07 <johnw> so, you are using Free to describe your UI elements?
10:56:10 <k0ral> the thing is: hooks can be added/removed dynamically during the program's runtime
10:56:47 <k0ral> therefore the 'addHook' function must leave in the runtime monad 'm'
10:57:11 <k0ral> such that m is an instance of MonadFree Something
10:57:21 <johnw> ok, why is that the case?
10:57:34 <johnw> can you show me your code?
10:57:53 <johnw> because I was with you right up until you said that 'm' had to be a MonadFree
10:58:42 <k0ral> okay, let me think of another way to express it
11:00:10 <k0ral> callbacks must live in free monads, do we agree on that ?
11:00:18 <johnw> no, not at all
11:00:23 <k0ral> let's say I'm using a Free monad to implement the logging system
11:00:37 <k0ral> I define logError, logDebug, and so as free actions
11:00:43 <k0ral> callbacks must be able to log
11:00:49 <k0ral> messages
11:01:27 <k0ral> so when I write 'addHook event callback', callback is of type 'MonadFree Something m => m ()'
11:01:28 <johnw> why are you using the Free monad for this?
11:02:01 <k0ral> is that a bad thing ? I want to write my code independently from the logging system
11:02:13 <k0ral> Free monad seems like the right tool
11:02:23 <johnw> free monads are for building static *descriptions* of programs, which can then be evaluated to have any one of multiple runtime behaviors; if you only ever want a single behavior, you don't need a free monad
11:02:55 <johnw> or if you want the description to be "doing" something, like managing callbacks, then you also don't want a free monad
11:03:34 <k0ral> aren't free monads useful to purify most of the code ?
11:04:01 <johnw> they purify by separating construction from valuation
11:04:04 <johnw> evaluation*
11:04:26 <johnw> your callbacks should be running on the evaluation side, not the construction side
11:04:27 <HeladoDeBrownie> k0ral, do you anticipate using your free representation in any way other than interpreting it with a single given interpreter?
11:04:30 <k0ral> without a free monad, all my functions would have to live in at least MonadIO to be able to log messages
11:04:53 <k0ral> HeladoDeBrownie: actually yes
11:04:55 <johnw> k0ral: that sounds exactly as it should be
11:05:07 <agocorona> to log messages you have to do IO after all
11:05:13 <k0ral> HeladoDeBrownie, johnw: I want to be able to add log handlers in the future
11:05:25 <agocorona> IO is not evil
11:05:26 <HeladoDeBrownie> k0ral, i don't understand the connection
11:05:29 <johnw> make a MonadLog then
11:05:32 <phaul> you can wrap IO, though, in a wrapper that can only log
11:05:34 <k0ral> HeladoDeBrownie, johnw: adding a log handler boils down to update the interpreter
11:05:50 <johnw> ok, but either way, callbacks should be managed by the interpreter
11:05:53 <johnw> not the builder
11:06:00 <johnw> (i.e., not in Free or FreeT)
11:06:11 <johnw> description which callbacks can exist would be a job for Free
11:06:19 <johnw> for adding/removing them is a job for the evaluator
11:06:27 <johnw> s/fgor/but
11:07:38 <k0ral> ok, let me reply to your points (all of you) one at a time
11:08:22 <HeladoDeBrownie> it sounds to me like using a free monad here is okay; if it ends up being too many extra steps, those can be cut down later, but i feel like it may be useful as an organizational tool
11:08:47 <HeladoDeBrownie> but yeah, you have to mark well the distinction between the representation and the interpretation
11:08:57 * hackagebot network-transport-zeromq 0.2.1 - ZeroMQ backend for network-transport  http://hackage.haskell.org/package/network-transport-zeromq-0.2.1 (AlexanderVershilov)
11:09:28 <k0ral> johnw, agocorona: though IO is not evil, if I want to use a logging system in my program, and you tell me living in MonadIO is the way to go, then I will have 90% of my functions in MonadIO, while most of them don't have any side effect except for the logging; this looks wrong to me
11:09:48 <geekosaur> ummmm
11:09:54 <johnw> but logging *is* an IO side effect, unless you use Writer
11:09:55 <geekosaur> I sense not getting it
11:10:18 <dfeuer> Is it possible to make a sort of polykinded tuple? I want ([*], *)
11:10:20 <k0ral> johnw: but you might decide that logs are to be discarded, in case there is no IO
11:10:25 <Cale> What is the design problem here?
11:10:53 <johnw> k0ral: that's why you can make your own MonadLog, the way that monad-logger does it, so that you can instantiate with either LoggingT or NoLoggingT
11:11:15 <k0ral> phaul: could you please clarify ? I don't get your point
11:12:07 <johnw> Cale: using FreeT to build up a GUI program, but in such a way that some of the runtime aspects of the GUI (e.g., callback management) are being attempted within FreeT; if I understand correctly
11:12:21 <phaul> If you wrap IO monad in a wrapper monad that only exports mapping
11:12:23 <jle`> an IO type that can only log is basically [String]
11:12:39 <Cale> hm
11:12:41 <phaul> s/mapping/logging/
11:12:46 <johnw> k0ral: I think you're trying to apply Free at the wrong level of abstraction
11:12:49 <Cale> FreeT over what?
11:12:56 <k0ral> HeladoDeBrownie: so you agree this is a valid use of Free monads ?
11:13:10 <johnw> Cale: that's the problem :)
11:13:19 <hannes__> jle`: Not really. Supposedly, you would want your logger to consume no more memory than the largest log message you throw at it
11:13:41 <jle`> hm true
11:13:46 <agocorona> I think that many people overcomplicate their monad stacks just to hide IO. and yet IO is there
11:13:55 <mada> This has actually been a question of mine for some time now. In order to be able to log I have to always be in IO somehow?
11:13:57 * hackagebot generic-trie 0.2 - A map, where the keys may be complex structured data.  http://hackage.haskell.org/package/generic-trie-0.2 (EricMertens)
11:14:02 <k0ral> johnw: I know of monad-logger, but I expected MonadFree to be more generic and as such to be able to do the same job
11:14:13 <HeladoDeBrownie> k0ral, i agree that it *could* be. i don't have enough information to say yes or no.
11:14:15 <jle`> k0ral: are you opposed to just using a MonadLog typeclass instead, for implementing multiple backends?
11:14:16 <johnw> k0ral: they are not the same job, they are at different levels of abstraction
11:14:16 <dfeuer> OK, I figured *that* out. Could someone explain why it is that when using DataKinds, sometimes things *need* a single quote in front, sometimes they *need* not to have one, and sometimes it works either way?
11:14:17 <mada> as k0ral said, all code living in IO seems weird
11:14:23 <jle`> MonadFree doesn't really make much sense here to me
11:14:36 <k0ral> johnw: I mean, we can simulate a MonadReader, a MonadState, etc. using a MonadFree, so I expect I can simulate a MonadLogger as well
11:14:39 <johnw> MonadLogger asbtracts logging; MonadFree would abstract the concept of logging itself
11:14:45 <phaul> agocorona: yes, but it's a nice guarantee that you can't do arbitrary IO where you don't expect to be able to
11:14:52 <k0ral> johnw: I entertained the idea of replacing every monad in my program with MonadFree actually
11:14:53 <hannes__> mada: Logging is always to some backend - but the backend doesn't necessarily require IO, you could also log to a list or just void your logs.
11:15:03 <johnw> k0ral: well, best of luck to you then ;)
11:15:10 <jle`> k0ral: but then you can say less about your programs through your types
11:15:12 <Cale> Saying that you're using a free monad doesn't actually tell anyone much about the structure of the library you're building, because free monads just give you arbitrary operations and move the problem of implementing those operations into the function which runs the actions.
11:15:17 <johnw> I have no answer that can satisfy what I've understood to be criteria
11:15:35 <jle`> what do you mean by simulating a MonadReader ?
11:15:37 <mada> Hm
11:15:43 <jle`> you can write an instance of MonadReader using Free, yes
11:15:46 <jle`> and an instance of MonadState
11:15:51 <jle`> and an instance of MonadLogger
11:16:08 <jle`> but that doesn't mean you don't want your functions to be parameterized over MonadLogger
11:16:09 <Cale> I think people get really caught up in using monad transformers when they maybe don't need to?
11:16:10 <k0ral> :) I have trouble following all of your comments rapidly
11:16:32 <jle`> MonadReader is a typeclass, and you can write your own type that implements MonadReader using Free w/ your data structure
11:16:46 <jle`> but when you write your functions, you're still giong to want MonadReader r m => m a -> ...
11:17:01 <jle`> that way, you guaruntee that this function "can't do anything other than access a global environment"
11:17:10 <Cale> Figure out which operations you need. Monad transformers are just a tool for constructing a monad that approximates what you're interested in -- they're not really a very good abstraction if left exposed, imo.
11:17:18 <k0ral> jle`: I'm not opposed to using a MonadLog typeclass (like monad-logger provides), it's just that I expected MonadFree to be a more generic way of doing it
11:17:21 <jle`> you might want to write a MonadLogger String m => String -> m ()
11:17:34 <Cale> I also sort of wish that the MonadFoo classes didn't exist :P
11:17:40 <jle`> that way you are guarunteed that your function can only log...
11:17:45 <jle`> it can't access arbitrary state, do arbitrary IO
11:17:53 <Cale> (MonadReader/MonadState/etc.)
11:17:53 <jle`> even though your type might be able to do arbitrary IO or access state
11:18:14 <hannes__> Cale: I see monad transformers as tools to quickly construct a behavior stack... that we can then newtype because we probably don't want all of it exposed directly.
11:18:25 <Cale> hannes__: Yeah
11:18:34 <Cale> They're not a good way to design your library
11:18:50 <Cale> They're an okay way to implement it, once you know what it is that you want
11:18:52 <dfeuer> Cale, those MonadFoo things are mtl, right?
11:18:57 * hackagebot rainbow 0.20.4.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.20.4.0 (OmariNorman)
11:18:59 * hackagebot extra 1.1 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.1 (NeilMitchell)
11:19:16 <Cale> dfeuer: yeah, the mtl ones specifically, though other libraries also do that sort of thing for the monad transformers they define
11:19:31 <dfeuer> It seems very confusing to me.
11:19:41 <hannes__> dfeuer: What does?
11:19:44 <dfeuer> Although I still don't think I understand monad transformers much at all,
11:19:47 <jle`> if you divorce the concept from the idea of monad transformers, it makes sense to me
11:19:58 <jle`> MonadReader has "nothing to do" with monad transformers
11:20:03 <dfeuer> the things from transformers seem pretty straightforward.
11:20:03 <jle`> nor does MonadState, etc.
11:20:06 <dfeuer> Oh, okay.
11:20:14 <dfeuer> Then I are confuzzled more :-P
11:20:46 <jle`> MonadReader is a typeclass, MonadReader r m means that your (monad) type `m` implements a way to "access" a global environment of type `r`
11:21:15 <hannes__> @hoogle MonadReader
11:21:15 <k0ral> johnw: ok, thanks for the help anyway :)
11:21:16 <phaul> the problem they are solving is lift . lift . lift .... isn't it? for that thay are good
11:21:17 <lambdabot> Control.Monad.Reader.Class class Monad m => MonadReader r m | m -> r
11:21:17 <lambdabot> Control.Monad.Reader class Monad m => MonadReader r m | m -> r
11:21:19 <johnw> k0ral: when you execute an action in MonadLogger m, you are simply choosing what logging method to use (or you can remove logging altogether); when you execute an action in MonadFree m, you are getting back a description of a program that you can then evaluate to have any behavior you want (possibly multiple behaviors, by evaluating the same program more than once).  These two can be combined: you could use MonadFree to encode a Log
11:21:20 <johnw> action, and MonadLogger in your evaluation to render Log as a logging effect.  Maybe this makes it clearer how these are happening at different abstraction levels entirely.
11:21:22 <hannes__> @hoogle MonadTrans
11:21:22 <lambdabot> Control.Monad.Trans.Class class MonadTrans t
11:21:22 <lambdabot> package monadtransform
11:21:22 <lambdabot> package STMonadTrans
11:21:26 <jle`> phaul: no, that's not the problem they solve
11:21:29 <Cale> It's not so much that it's confusing... if you look at how it's implemented, it's not really a big deal. I just think the automatic lifting of operations helps people write their programs in a style which is ultimately not so good. Removing those classes would make things only marginally less convenient in the case where you were using monad transformers in a tasteful way, but *much* less convenient in cases where you
11:21:29 <Cale> were abusing monad transformers.
11:21:44 <jle`> phaul: the problem they solve is abstracting over different types that have an "ask" function
11:21:58 <jle`> most of the MonadReader's i write or use today don't haev anything to do with lifting or monad transformers
11:22:04 <jle`> most of the MonadIO's too
11:22:24 <Cale> I almost think liftIO should go as well ;)
11:22:36 <jle`> instance MonadReader r ((->) r) where ask = id
11:22:48 <jle`> > ask 4
11:22:49 <lambdabot>  4
11:23:06 <jle`> > do { x <- ask; y <- ask; return (x + y) } $ 10
11:23:08 <lambdabot>  20
11:23:17 <jle`> here we abstract over types that have an "environment" to ask from
11:23:26 <jle`> it has nothing to do with monad transformers
11:23:32 <johnw> > liftM2 (+) ask ask 10
11:23:33 <lambdabot>  20
11:23:41 <phaul> but in reallity you wouldn't  implement MonadFoo for any arbitrary datatype, usually you do it for some Monad that's achieved by monadtransformers transforming Foo?
11:23:41 <Cale> If you need to liftIO constantly all over the place, then there's probably something better you could be doing.
11:23:44 <k0ral> johnw: this is what I'm trying to do, it doesn't work because you're entire code lives in MonadFree Log, not in MonadLogger, and MonadFree doesn't play well with monad-control (s/well/at all)
11:24:09 <Cale> Not always... but often.
11:24:28 <jle`> when we write a function MonadReader r m => a -> m b..., we are saying that in our function, in `m`, we are "only allowed" to "ask", and nothing more.  the actual Monad we use might have arbitrary effects, IO, state, w/e.  but in that function, we can *only* "ask"
11:24:30 <jle`> Cale: i would hope not!
11:24:33 <jle`> :O
11:24:41 <jle`> that's uggs
11:24:49 <Cale> jle`: hm?
11:25:03 <Cale> You hope there's not a better solution? :)
11:25:11 <jle`> in my ideal world we would write our own MonadFoo etc. w/out resorting to transformers as the default method of construction
11:25:23 <augur> anyone know why cabal repl would be happy with a dir structure, but cabal exec ghc isnt?
11:25:44 <johnw> k0ral: the only reason to use FreeT is if your program description should be created dynamically; using concurrency to do so makes very little sense -- unless the construction of the description is so expensive that it helps to build different parts separately.  But that's a very different thing from what you described.  So, the fact that monad-control doesn't play well with FreeT should _rarely_ be an issue.
11:25:44 <dmj`> cabal exec ghci?
11:25:55 <Cale> Well, if you have no transformers, you barely even need the MonadFoo class, you just write the operations directly.
11:26:09 <dmj`> augur: what is the error?
11:26:10 <jle`> Cale: but you can't abstract over them in the way i described
11:26:20 <augur> dmj`: just that the relevant modules are not found
11:26:28 <jle`> being able to make statements about what your function can do by constraining the power of your monad
11:26:29 <Cale> jle`: Yeah, that's true
11:26:40 <k0ral> johnw: I've come up with the logging example, but I intended to use Free for many more operations
11:26:44 <jle`> unfortunately as it stands, it's not too useful, because none of the MonadFoo classes really have meaningful laws
11:26:48 <Cale> jle`: Though, I don't know how valuable it is a lot of the time.
11:27:11 <dmj`> is your code in a base folder like "src" ?
11:27:15 <augur> dmj`: yes
11:27:18 <johnw> k0ral: Free is a great tool, but it's not the first thing to reach for
11:27:39 <k0ral> johnw: why would dynamically-created description and concurrency be rarely together ?!
11:27:40 <dmj`> augur: in ghci do :set -isrc
11:27:42 <Cale> A lot of the time, you just end up with any moderately complex operation just being constrained by so many MonadFoo classes that it's a meaningless restriction on what you can do there.
11:27:46 <jle`> that's the basic discipline of programming with several effects, right?  write each function constrained/parameterized with the minimum number of effects necessary, and then throw them all into a type in the end that gives you all of them
11:27:52 <dmj`> augur: or just add that wholesale to your ~/.ghci file
11:28:13 <dmj`> cabal repl will respect hs-source-dirs: src, but cabal exec ghci will not (IIRC)
11:28:14 <johnw> k0ral: because Free doesn't do *work*, it creates a description of work to be done
11:28:16 <agocorona> The newbies that enter here may get the impressions that for reading a file and writing to another there is necessary a monad stack of three or four transformers
11:28:16 <jle`> yeah, if it's hard to isolate out the effects, then the number of constraints makes it kinda meaningles
11:28:19 <Cale> There is value in keeping your types readable and simple
11:28:23 <agocorona> haskell can be much more simple
11:28:40 <k0ral> johnw: I'm using gtk2hs, which is besically 99% in IO; I don't like this so I thought I would abstract the GUI operations through Free, so that I may change the GUI system in the future
11:28:42 <augur> dmj`: i seem to have no .ghci file! :(
11:28:53 <johnw> k0ral: ok, just undo that thought and you'll be good :)
11:29:05 <k0ral> johnw: :D
11:29:13 <Cale> agocorona: It depends on who they're talking to
11:29:26 <dmj`> augur: that's ok you don't necessarily ned one
11:29:28 <dmj`> need*
11:29:33 <k0ral> johnw: why should I ?
11:29:40 <johnw> IO is pure too you know, it's only execution of IO actions that is impure
11:29:50 <Cale> agocorona: I've gotten more and more opposed to monad transformers in recent years because so many people never transform anything other than IO, which barely needs transforming.
11:30:23 <dmj`> augur: ghci has default search paths to find code, if you have it in src/ it will need some more information, what :set -isrc does is add the folder "src" to ghci's default search path, I think
11:30:24 <agocorona> Cale: I Can´t agree more
11:30:57 <augur> dmj`: actually i should really say my main desire is to do ghc -fno-code, not ghci
11:31:25 <Yuras> augur: cabal exec ghc -- -isrc
11:31:29 <augur> aha!
11:31:29 <k0ral> johnw: I'll think of another design, I'm not ready yet to give up on purity on that scale, but thanks for the help anyway
11:31:43 <Yuras> where src is a folder with sources
11:31:48 <johnw> k0ral: at the very least, attempting to do it will make you very familiar with Free in the end :)
11:31:53 <dmj`> augur: why not use cabal build then?
11:32:04 <dmj`> Yuras: :)
11:32:07 <augur> dmj`: i just want to type check, i dont want to compile
11:32:16 <augur> interactive development w/ holes! :)
11:32:30 <Yuras> dmj`: e.g. I often use cabal sandbox without cabal file
11:33:14 <HeladoDeBrownie> Cale, when you say "transform IO" do you mean "have IO at the base of a transformer stack"?
11:33:18 <Cale> yes
11:34:13 <HeladoDeBrownie> i've found Proxy (from pipes) to be handy over IO; it actually has uses you wouldn't get from just hand-coding the streaming yourself, like composability
11:34:31 <HeladoDeBrownie> well, you *could* do it, theoretically. it would be laborious.
11:34:45 <Cale> Well, okay
11:35:02 <Cale> Proxy is mainly designed to transform IO
11:35:47 <HeladoDeBrownie> at the same time i can write my primary logic so i can produce from Identity instead of IO to test things out
11:36:11 <Cale> I have less opposition when the transformers get interesting like that
11:36:42 <Cale> My main concern is especially ReaderT, WriterT and StateT
11:36:44 <k0ral> johnw: am I wrong to think that all Monad* (reader, state...) could/should be replaced by a free monad ?
11:36:55 <k0ral> johnw: I mean, isn't that what's done in extensible-effects ?
11:36:59 <HeladoDeBrownie> k0ral, yeah, they basically have nothing to do with each other
11:37:01 <johnw> k0ral: they don't operate at the same level
11:37:16 <Cale> If your monad transformer is giving you really serious control effects over IO, well, maybe it's worthwhile.
11:37:20 <johnw> that's like saying that addition and multiplication should be replaced by lists
11:37:50 <k0ral> what about ext-eff then ?
11:37:51 <johnw> (in fact, it's exactly like that)
11:38:09 <k0ral> isn't that a project of replacement for monad transformers ?
11:38:21 <Ainieco> hello, is there ghc switch to raise warning when someone does "Just foo <- somethingMaybe"?
11:38:36 <johnw> yes, that's true, but not related to the Free question
11:38:38 <shock_one> Having two lists "something" and "some", how to get Just "thing" the fastest way? It should be Nothing for "asomething". In other words, to strip the common init.
11:39:08 <johnw> shock_one: if you don't mind the dependency, parsec would make that easy
11:39:10 <Ainieco> tried -Wall but no dice
11:39:20 <shock_one> johnw: using only base.
11:39:23 <johnw> or use isPrefixOf and drop 4
11:39:39 <Yuras> Cale: hmm, may I ask, what is wrong with ReaderT r IO a? it may be good to save few keystrokes when passing context
11:39:54 <Yuras> Cale: it is probably bad in API though
11:39:57 <Cale> :t stripPrefix
11:39:58 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
11:40:00 <johnw> some of us like ReaderT r IO more than Cale does :)
11:40:09 <Cale> > stripPrefix "some" "something"
11:40:10 <lambdabot>  Just "thing"
11:40:15 <k0ral> I obviously have some incorrect grasp of the use of Free, if you can recommend some resource on that topic, it will be much appreciated (I've already read what's indexed by Google though)
11:40:16 <johnw> Cale: ah, cool
11:40:35 <johnw> k0ral: http://newartisans.com/2012/08/meta-programming-with-the-free-monad/ :)
11:40:38 <Cale> Yuras: You save a few keystrokes passing a parameter and pay them back with all the liftIO's
11:40:42 <Cale> (and then some!)
11:40:48 <shock_one> Cale, you're my hero.
11:40:58 <johnw> and http://stackoverflow.com/questions/13352205/what-are-free-monads
11:41:09 <Yuras> Cale: yes, but that is a trade-off -- sometimes ok, sometimes not
11:41:28 <Cale> Yuras: and it makes the types more awkward to, well, type
11:41:38 <k0ral> I've already read those :/
11:41:47 <HeladoDeBrownie> i actually have a motivation for using a type *like* that (but in reality i use StateT): i compose together three stacks, two of them of one type and one of another. the one requires StateT, the others don't. so, i use mmorph to lift the others to trivially not use the state and compose them all together and be on my merry way.
11:41:51 <quchen> k0ral: There's an excellent talk by Andres Löh about the topic. Register a dummy account and you're ready to go: https://skillsmatter.com/skillscasts/4430-monads-for-free#showModal?modal-signup-complete
11:42:01 <Cale> At least, I'd usually rather write  Env -> IO a  than  ReaderT Env IO a, even though that's not a huge deal.
11:42:10 <Yuras> Cale: well, it is used locally anyway
11:42:29 <Yuras> Cale: yes, in API I'd prefer explicit passing
11:42:48 <Cale> MonadReader is okay if you're getting a lot of leverage out of local
11:42:51 <johnw> yes, Löh's talk is quite good
11:43:08 <Cale> But people use it just for ask/asks, which I think is a bit senseless
11:43:11 <quchen> k0ral: The talk will give you a pretty good practical introduction into free monads from a programming perspective. No adjoints and stuff.
11:43:16 <Cale> I dunno
11:43:18 <Yuras> strange, I found MonadReader + MonadIO a bad idea...
11:43:36 <tdammers> I like using Reader when I have a somewhat complex monad stack in place anyway, and only a few things deep inside the call graph need the reader part...
11:43:36 <Cale> Yeah, I mean for ReaderT explicitly
11:43:50 <Kron> what's the best haskell library for queues?
11:44:14 <HeladoDeBrownie> hmm, out of curiosity, what is an example of a commonly used monad, besides IO, that does *not* arise for free from a given functor?
11:44:37 <Cale> Kron: I dunno what best means... usually I'll just use Data.Sequence because it has reasonably fast queue operations.
11:44:45 <HeladoDeBrownie> (there is no functor such that it is the free monad of that functor)
11:44:46 <Kron> ah! I forgot about that
11:44:47 <Kron> thanks
11:44:53 <Cale> Kron: But there's probably something with much less overhead
11:45:05 <EvanR> which functor does IO arise from for free?
11:45:13 <HeladoDeBrownie> EvanR, i'm saying it doesn't.
11:45:21 <HeladoDeBrownie> EvanR, did i mistype?
11:45:30 <quchen> data IOAction a where PrintLine, GetLine, Fork, …
11:45:34 <EvanR> im not sure
11:45:39 <Cale> IO probably would be free if it were not abstract.
11:45:48 <tdammers> it was somewhat ambiguous
11:45:56 <Cale> HeladoDeBrownie: any monad which you don't have access to the data constructors for?
11:46:13 <csd_> How can I write a function of Maybe Value -> a ? Value in this case can be a String, a Number, and a few other types.
11:46:16 <HeladoDeBrownie> Cale, hmm, why is that?
11:46:27 <csd_> I want to be able to extract from Value to the more primitive type
11:46:41 <hannes__> csd_: Well... what is a?
11:46:41 <HeladoDeBrownie> csd_, the type forall a. Maybe Value -> a is inhabited only by bottom. can you clarify?
11:46:43 <k0ral> quchen: thank you, much appreciated
11:46:45 <Kron> csd_: you can just pattern match
11:46:53 <Cale> HeladoDeBrownie: Because it'll prevent you from writing the isomorphism, since you can't inspect the actions.
11:46:54 <Kron> assuming you have relevant values in type "a" to handle Nothing
11:47:09 <Cale> (typically)
11:47:12 <csd_> hannes__: depending on what the Value is, a can be a string, or a double, etc.
11:47:13 <Kron> foo Nothing = ..., foo (Just x) = ..., etc.
11:47:24 <Ainieco> why doesn't " -fwarn-incomplete-uni-patterns" warns about "Just foo <- somethingMaybe"?
11:47:36 <csd_> Kron: that won't solve the issue of not having a static type at runtime though
11:47:45 <Kron> ah, that can't be done: there's no runtime type annotations. You'll need to modify the return type to be an Either form
11:47:49 <Kron> yeah
11:48:01 <csd_> https://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-Types.html
11:48:02 <Kron> Haskell has ways of representing values that can be multiple types at runtime, we normally use Either
11:48:07 <hannes__> csd_: One function per type. Don't try to circumvent the typesystem
11:48:07 <csd_> thats where Value is defined
11:48:17 <csd_> hannes__: not trying to, i just dont know how to do it the right way
11:48:23 <Kron> you can make youro wn version, actually
11:48:33 <csd_> i'd think theres a way to do it with a case statement, its eluding me though
11:48:37 <Kron> here's what I'd do (and this does matter for stuff like rolling your own parsers and things)
11:48:54 <Kron> data Token = MkString String | MkDouble Double | MkInt ...
11:49:03 <Kron> and then you make a function that does Maybe Value -> Token
11:49:17 <Kron> basically you wrap the various 'internal' types of the resulting value with constructors as annotations
11:49:27 <Kron> and the type system can handle this neatly and even pattern match on these
11:49:33 <csd_> Kron: ok yeah i was wondering if i was going to have to use ADTs
11:49:41 <Kron> pretty much, csd_
11:50:03 <Cale> Ainieco: because that desugars to a case expression which doesn't have incomplete patterns and uses fail.
11:50:15 <Kron> make sure to account for Nothing when mapping your Values to Tokens
11:50:41 <hannes__> csd_: In the case of aeson, you'd probably use parse fromJSON Value
11:51:03 <hannes__> *parseJSON, not fromJSON
11:51:29 <csd_> hannes__: thx ill check that out
11:51:41 <csd_> Kron: what should be done in the case of Nothing?
11:51:57 <hannes__> csd_: That depends on what you're trying to achieve
11:52:10 <Kron> it's up to your programming, really. Just remember that any Maybe type is trying to also keep open the possibility of a failure or error
11:52:20 <Kron> make sure you account for that in some idiomatic way for your problem
11:52:26 <csd_> ok
11:52:32 <Kron> foo Nothing = ... -- do something about errors
11:52:32 <csd_> thanks
11:52:38 <EvanR> crash ;)
11:52:55 <Kron> if you want a runtime crash, you can use error
11:53:07 <Kron> foo Nothing = error "I'm sorry Dave, I can't do that."
11:53:15 <Kron> that'll end the program and print that as an error message
11:53:26 <Kron> it's better than failing silently and invisibly somewhere
11:53:51 <aidecoe> foldl' should be almost always used instead of foldl. But what about foldr?
11:54:13 <hiptobecubic> aidecoe, they do different things.
11:54:24 <hiptobecubic> aidecoe, at least for non commutative operations
11:54:26 <EvanR> it gives you a handle into your program to deal with an error if ever there comes up a way to do that, and explicitly indicates a failure possibility
11:54:31 <Kron> foldr is a lot better than foldr' in practice, confusingly
11:54:35 <hiptobecubic> er... associative
11:54:36 <EvanR> however if Nothing will *never* happen and you can prove it, Maybe is not good
11:54:42 <aidecoe> hiptobecubic: i understand the difference between foldl and foldr
11:54:59 <aidecoe> but i am asking if strict version of foldr should be used instead of lazy one
11:55:02 <hiptobecubic> ah
11:56:08 <hiptobecubic> I think it depends on whether your operation is strict in its second argument?
11:56:18 <c_wraith> aidecoe: I can think of basically no cases where a strict version of foldr helps.
11:56:37 <c_wraith> hiptobecubic: but if it is, doesn't it just take care of itself without any special requirements?
11:56:46 <aidecoe> Prelude> import Data.List (foldr')
11:56:46 <aidecoe> <interactive>:1:19: Module ‘Data.List’ does not export ‘foldr'’
11:56:56 <aidecoe> hah. There's no foldr' (-:
11:57:02 <geekosaur> exactly
11:57:09 <aidecoe> problem solved (-:
11:57:36 <shapr> kosmikus: Just how awesome is your monads for free talk?
11:58:58 * hackagebot clac 0.4.0 - Simple CLI RPN calculator  http://hackage.haskell.org/package/clac-0.4.0 (alexander)
11:59:35 <geekosaur> I think the functions which might be amenable to a separate foldr' are avoided because they're not as amenable to partial application? (i.e. you really want that parameter to be first, not second, in which case you use foldl')
12:01:15 <aidecoe> I have seen hello worlds in few (5 or more) FP languages today and I was actually surprised.
12:01:42 <johnw> shapr: depends on the evaluator you write
12:01:44 <tdammers> aidecoe: surprised how?
12:02:00 <aidecoe> that no language is more elegant than Haskell
12:02:13 <aidecoe> at least in such short examples
12:02:14 <EvanR> python
12:02:31 <aidecoe> i mean FP
12:02:31 <EvanR> you dont even need the main = noise
12:02:59 <tdammers> python's hello world is shorter, but that's about where the elegance ends
12:03:07 <hannes__> EvanR: Python is also not function
12:03:09 <hannes__> *al
12:03:24 <tdammers> hannes__: depends on the definition... but no, it's not
12:03:34 <hannes__> *at least not for any meaningful definition of functional
12:03:39 <hiptobecubic> it's only shorter because it doesn't actually define anything. it's just a statement that gets interpreted. More like typing directly into ghci
12:03:40 <EvanR> printing out a constant string is probably not the best way to judging functional languages
12:03:41 <aidecoe> haskell seems to be most elegant language i have seen
12:03:44 <sssilver|> tdammers: it's not significantly shorter
12:03:48 <sssilver|> (Python's Hello World)
12:04:09 <tdammers> haskell: main = putStrLn "Hello, world"
12:04:16 <tdammers> python: print "Hello, world!"
12:04:26 <sssilver|> tdammers: that's not an equivalent in Python
12:04:27 <tdammers> python 3: print(u"Hello, world!")
12:04:37 <sssilver|> tdammers: an equivalent would include __main__ ;)
12:04:53 <hannes__> object Main extends App { println("Hello World!") }
12:04:55 <shapr> Python is a gateway drug to Haskell.
12:05:04 <tdammers> sssilver|: but for a fair comparison, the haskell one would need a module declaration
12:05:16 <tdammers> module Main where main = putStrLn "Hello, world!"
12:05:18 <agocorona> there is not a Acme.HelloWord?
12:05:38 <sssilver|> tdammers: sure, and that way we'd see that Python's hello world is actually roughly equal (if not longer) to HW on Haskell ;)
12:05:39 <aidecoe> with module decl or not, it's still most elegant (-:
12:06:30 <tdammers> yeah
12:06:39 <tdammers> __main__ and all that is pretty ugly boilerplate IMO
12:06:46 <sssilver|> Haskell the language is pretty elegant (minus some syntactic idiocies, but what language doesn't have them?). It's Haskell (fp? declarative programming?) the paradigm that hurts and burns and tortures.
12:07:19 <tdammers> basically, someone forgot to make that part of the language, and people just starting rolling with what they had, and now the workaround has solidified into a "best practice"
12:07:34 <sssilver|> I never realized before Haskell how useful to learning a language was the ability to step through code
12:07:53 <clusterxl> hi...starting learning Haskell...
12:08:14 <EvanR> sssilver|: the walls will come down
12:08:18 <sssilver|> because now without that, my work basically resembles: 1. Attempt to implement the function that does what I need, 2. Watch it fail, 3. Delete the function and go to step 1
12:08:20 <tdammers> I never realized before Haskell how useful to learning a language it is to be able to derive almost all the properties of something from its type
12:08:31 <EvanR> but you may return to your former life and be very unsatisfied
12:09:10 <hiptobecubic> sssilver|, you *can* step through in ghci but it's crazy and unintuitive because execution order is not top-to-bottom. Also, Debug.Trace
12:09:11 <tdammers> it takes a while to leave your shotgun debugging ways behind and embrace actually somewhat knowing what you're doing, but once you're converted, you'll hate to go back
12:09:12 <sssilver|> EvanR: may that day come soon!
12:10:08 <tdammers> and frankly, with pure functions that you can throw into a REPL and pepper with QuickCheck tests and type constraints, step debugging doesn't really add a lot to the debugging experience once you know what else you can do
12:11:12 <sssilver|> that's just the problem tdammers, I feel like I want to put together some kind of a guide for a programmer coming from the imperative world to effectively learn Haskell
12:11:29 <EvanR> do that after learning haskell
12:11:38 <EvanR> or it might do more harm that good
12:11:40 <tdammers> ^ .
12:11:57 <tdammers> whatever you do, do not write a monad tutorial.
12:12:00 <EvanR> lol
12:12:04 <phaul> :D
12:12:31 <c_wraith> Yeah, Kleisli Category tutorials are the new hotness.
12:13:07 <tdammers> I prefer tutorials about monoids in the category of endofunctors. I guess I'm old school.
12:13:30 <hiptobecubic> sssilver|, I really don't think it would help anyway. It sends the wrong message in the first place. "Here's how Haskell is like Python" is really *not* going to convey the right mindset.
12:13:36 <sssilver|> can there be some kind of a learning guide that says "OK now learn this by heart, now go and implement these 1000 recursive functions without resorting to Google, now read this other stuff" etc. Basically a super detailed course.
12:13:50 <sssilver|> hiptobecubic: that wasn't my direction though
12:13:52 <EvanR> yes
12:14:03 <thebnq> learnyouahaskell essentially does that
12:14:06 <EvanR> http://www.seas.upenn.edu/~cis194/
12:14:08 <hannes__> sssilver|: I don't know, that mostly sounds like lyah
12:14:12 <sssilver|> hiptobecubic: and I wholeheartedly agree with that.
12:14:25 <n4x> thebnq: .. without the "write 1000 recursive functions" part ..
12:14:33 <sssilver|> hiptobecubic: I'd do something more along the lines of "hey you know how you totally feel like this is like Python's xxx? It's not."
12:14:39 <sssilver|> coz that's where I stumble most
12:14:45 <thebnq> not quite a 1000 .. but it has enough
12:14:56 <hiptobecubic> thebnq, definitely not.
12:15:05 <hiptobecubic> thebnq, unless lots have been added recently
12:15:28 <thebnq> ok it depends how you interpret 'enough'
12:15:32 <hiptobecubic> sssilver|, what helped me a lot actually was going somewhere like hackerrank or topcoder and just doing practice problems
12:15:34 <tdammers> sssilver|: fwiw, as a battle-hardened imperative programmer, Real World Haskell helped me a lot
12:15:52 <hannes__> I think haskell tutorials introducing IO would be a lot more successful if they added `import Control.Applicative` and used pure instead of return
12:15:57 <thebnq> like, a majority of what needs to be learnt is not related to programming at all
12:16:01 <thebnq> imho
12:16:03 <tdammers> sssilver|: seeing how something as strange and "different" as Haskell could be used idiomatically to solve some actual programming problems, and elegantly at that
12:16:07 <sssilver|> thebnq: I'm going by LYAH, and it's an amazing book because everything it explains makes total sense and you go -- "hey that's great, I get it", but then when you actually try to get your feet wet, you find out that the water is megacold
12:16:30 <hiptobecubic> sssilver|, seeing and doing are pretty different though
12:16:44 <sssilver|> I struggle implementing a recursive strlen FFS
12:16:51 <hiptobecubic> sssilver|, really, go do the warmup problems on hacker-rank
12:17:14 <thebnq> i find that the recursive mindset is more broad than just fp
12:17:29 <tdammers> sssilver|: start with imagining a case where you can find the string length in one step
12:17:31 <EvanR> recursive strlen can be tricky, if you want efficient
12:17:35 <tremon> sssilver|: there is https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
12:17:37 <hannes__> thebnq: I'd have worded it the other way round really
12:17:40 <phaul> maybe haskell could do with some anti tutorials, there is a lot of easy ways to shoot yourself in the foot, yet no place exists where you can find all the bad practises that come from ppl not understandng what's happening under the hood
12:17:49 <hiptobecubic> they aren't complicated problems themselves, but you'll have to think a bit about how to solve them without reaching the usual "for i in range(....):" over a dict.
12:17:51 <hannes__> thebnq: Just thinking recursively doesn't automatically get you fp
12:18:32 <thebnq> hannes__: true, perhaps thats what i mean
12:18:42 <phaul> for instance on building gigabytes of thunks :D
12:18:59 * hackagebot reducers 3.10.3.1 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.10.3.1 (EdwardKmett)
12:19:11 <EvanR> efficient and recursive is even trickier in a strict language, i say
12:19:16 <hannes__> phaul: I don't think we should mention the word 'thunk' in a haskell introduction
12:19:20 <EvanR> you gotta rewrite in tail recursive or something
12:19:28 <thebnq> its certainly amusing that much of learning haskell is unlearning anything else..
12:20:14 <hannes__> EvanR: Well, not or something. Unless you have a hard upper limit on recursion depth then tail recursion is the only way you can write recursive code efficiently in a strict language
12:20:46 <hannes__> And that's assuming your language does do tail recursion optimization... or even *gasp* tail call optimization
12:20:47 <EvanR> hannes__: or something in the case that the problem demands it
12:20:50 <EvanR> or doesnt
12:21:08 <ReinH> hannes__: (or trampolining, which is just DIY tail recursion)
12:21:15 <sssilver|> thebnq: I am not sure that unlearning something necessarily deserves as much attention as it gets. It's not the stuff that I know that hinders my learning. It's the lack of certain skills that does that. Such as, problem solving using recursive algorithms. The reason I lack those skills is not that I know how to solve them iteratively. My knowledge of their iterative solutions is rather an effect of that lack of skill in the first place. (perhaps)
12:21:33 <hannes__> ReinH: DIY tail call really, trampolining doesn't limit you to the recursive case
12:21:43 <sssilver|> (that's some horrible English, forgive my wording)
12:21:49 <tempname11_> hey everyone. I've posted a question on Stack Overflow, if someone got a bit of time to take a look, I'd be grateful
12:21:50 <tempname11_> http://stackoverflow.com/questions/28570367/debugging-io-in-a-package-module-inside-ghci
12:21:51 <ReinH> hannes__: fair point
12:21:52 <EvanR> sssilver|: then youre ahead. a lot of times the "for loop" mentality will get in the way
12:22:07 <tempname11_> I asked the question here already, but got no good answer
12:22:59 <kosmikus> shapr: [re my talk] is that a statement, a joke, or a question? :)
12:23:00 <sssilver|> EvanR: the question is -- how do you grow those skills? it basically feels like "how do you be smart?" and that question is fairly vague, eh?
12:23:19 <EvanR> sssilver|: do the exercises. i included a often recommended link http://www.seas.upenn.edu/~cis194/
12:23:21 <hannes__> sssilver|: You practice.
12:23:34 <thebnq> haha we are always learning :)
12:23:34 <shapr> kosmikus: some of all those? :-)
12:24:14 <hannes__> sssilver|: Basically, the same way you gain skills in imperative programming. Many people feel that that's beyond them too; It's just a matter of getting intuition through exploration and repitition
12:24:21 <voidzero> it does help to have a bit of a background with math, I guess. I don't have such a background at all... so it's a bit harder, because I need to pick up a lot of concepts as I learn
12:24:25 <kosmikus> shapr: hehe. have you seen it?
12:24:40 <sssilver|> OK example (just super curious what you guys' input is). Sample problem -- recursively reverse a string. You sit down and think "hmm, I wonder how I'd do that... no idea" for like an hour. Then you're like OK -- Google "recursive reverse string" -- check the solution -- "aaah!" *quickly implement it* -- did you grow? Doesn't feel that way.
12:24:40 <shapr> kosmikus: no, not yet... just started jumping back into Haskell stuff the past few weeks.
12:25:12 <EvanR> my background in math didnt help me with learning haskell at all, beyong the simple notation of what a pure function is, which isnt that hard
12:25:16 <Atrocitus> hey guys
12:25:32 <EvanR> the type system, i didnt get any preparation for this in math
12:25:36 <kosmikus> shapr: aha. I feel strange if you ask me to comment on the quality of my own talk.
12:25:49 <shapr> kosmikus: ok, no worries then
12:25:55 <kosmikus> shapr: if I'd think it was bad, I would probably not have given it in the first place, though ;)
12:26:01 <shapr> haha, good point!
12:26:07 <hannes__> sssilver|: In haskell, it's best to start with type signatures and then refine from there. Don't get too caught up in the recursive part; That's coming naturally after a while
12:26:12 <voidzero> EvanR, ok, well, math theory then? I mean, words like poly/iso/mono/endomorphic mean nothing to me
12:26:25 <shapr> kosmikus: ok, I'll sign up and watch the talk this weekend!
12:26:34 <sssilver|> hannes__: I feel I'm at ease with type signatures ^.^
12:26:57 * shapr hops cheerfully
12:26:59 <shapr> yay Haskell!
12:27:24 <kosmikus> shapr: have fun. let me know if you like it.
12:27:29 <kosmikus> shapr: good to have you back :)
12:27:32 <voidzero> EvanR, so I have to look those up until I suppose I understand the gist of it :)
12:27:34 <EvanR> voidzero: polymorphism is a word c++ beats over your head... monomorphism restriction? nope
12:27:46 <EvanR> had to learn all this on the job
12:27:49 <shapr> kosmikus: yay! glad to be back!
12:27:56 <yac> what should I use to do migrations with hdbc?
12:28:07 <voidzero> I didn't know. I speak no C++
12:28:12 <EvanR> voidzero: i still dont know what most of morphisms are referring to
12:28:13 <Atrocitus> Is this channel purly programming?
12:28:35 <shapr> Atrocitus: This channel is about a programming language called Haskell.
12:28:47 <shapr> Atrocitus: if you'd like to learn Haskell, this is a good place to hang around and ask questions.
12:28:50 <EvanR> purely functional programming
12:28:53 <voidzero> EvanR, lol, that's a relief, for some reason :')
12:29:10 <hannes__> voidzero: Most of these come from category theory, although they (or similar terms) pop up elsewhere too. 'morphisms' appear in set theory as well
12:29:40 <voidzero> Wish I were 15 years younger hehe
12:29:55 <EvanR> voidzero: data Endo a = a -> a, is a useful tool for building lists in an efficient one-pass, btw
12:30:09 <csd_> Is there a predefined function to convert from Scientific numbers to, say, Double?
12:30:22 <yac> looks like dbmigrations is the way to go
12:30:24 <EvanR> the definition of the type makes clear what an endomorphism is, a function from/to the same domain
12:30:28 <hannes__> voidzero: 15 years ago you were 15 years younger. Didn't do you much good then either. You don't want to be younger, you want a time machine.
12:30:41 <shapr> Atrocitus: would you like to see some introductory documents?
12:30:57 <EvanR> csd_: yes, try realToFrac
12:30:58 <voidzero> I want both actually!
12:31:09 <shapr> voidzero: best time to start is now!
12:31:42 <voidzero> yes oh I'm having great fun with Haskell
12:31:53 <shapr> Atrocitus: try reading this website: http://learnyouahaskell.com/
12:32:02 <shapr> Atrocitus: and anytime you have questions, ask them here on #haskell
12:32:43 <shapr> voidzero: I started learning Haskell when I was 29, you can learn Haskell at any age!
12:33:07 <voidzero> hmm. Well. I'm 30 now, so.. :)
12:33:18 <voidzero> thanks for putting a smile on my face :-)
12:35:15 <csd_> EvanR: thanks.. i don't need it but just curious: what if I wanted to convert Fractional to a floating point?
12:35:21 <aidecoe> mapM_ putStrLn $ map show $ rev $ map (read :: String -> Int) $ lines inputdata
12:35:37 <aidecoe> what is this "read :: String -> Int"?
12:35:44 <aidecoe> why String -> INt?
12:35:45 <EvanR> csd_: Fractional is a type class. but generally realToFrac is for converting between the fractional numeric types
12:36:00 <mauke> aidecoe: a type annotation
12:36:02 <EvanR> :t realToFrac
12:36:02 <lambdabot> (Real a, Fractional b) => a -> b
12:36:38 <mauke> aidecoe: it constrains the return type of read to Int, to let the compiler know which 'read' to call
12:36:44 <aidecoe> mauke: i know how it's called, but why "String -> Int" and not just "Int"?
12:36:58 <mauke> aidecoe: because read is not an Int
12:36:59 <geekosaur> because read is a function
12:37:00 <mauke> it's a function
12:37:01 <MP2E> because only read is being annotated
12:37:25 <aidecoe> ah, indeed. We have not yet provided first argument to read!
12:37:37 <aidecoe> thanks
12:39:38 <bennofs> What does case i of j { __DEFAULT -> ... } do in GHC core, where i is a GHC.Prim.Word# ?
12:40:12 <bennofs> I thought case was used to evaluate thunks, but Word# is primitive and so this seems redundant to me? (GHC could just replace all uses of j with i)
12:40:59 <stryker> I started learning Haskell to learn more about FP and it really did help me. Today was a post on HN about Elm and I did understand how the code works in the example.
12:41:05 <geekosaur> that might be a good question for #ghc
12:41:14 <bennofs> geekosaur: I will try
12:42:25 <bitemyapp> Anybody here used Groundhog? Any opinions?
12:44:49 <yac> What are these *_hsc_make things?
12:45:04 <yac> They always fail the build for me when the package is a dependency
12:45:21 <Ayey_> (+ 1 1)
12:45:53 <Ayey_> Whops
12:46:30 <yac> eg. cabal install HsSyck fails. Unpacking the tarball and running cabal build works
12:47:05 <yac> command was: dist/dist-sandbox-82ddaa05/build/Data/Yaml/Syck_hsc_make  >dist/dist-sandbox-82ddaa05/build/Data/Yaml/Syck.hs
12:47:25 <yac> and of course it looks like it drops these files, so I can't look into them
12:47:31 <dcoutts_> yac: and what was the error?
12:47:46 <yac> I have no idea ...
12:47:52 <dcoutts_> it doesn't say anything?
12:48:00 <yac> well it says the ^
12:48:02 <dcoutts_> got the full log somewhere?
12:48:13 <yac> it's not more helpful
12:48:54 <yac> https://gist.github.com/yaccz/ab87b65386275b4c96c7 this is all ther eis
12:49:12 <yac> and I actually saw this already with 3 other packages, always *_hsc_make
12:50:01 <dcoutts_> yac: so this is related to the hsc2hs tool for pre-processing .hsc files
12:50:11 <dcoutts_> ah ok, (exit code 127)
12:50:13 <geekosaur> mrrr. while most nonzero exit codes aren't very meaningful, 127 is *often* "program not found"
12:51:06 <geekosaur> (more precisely, the exec part of a fork/exec failed, so the child has no recourse but exit(127))
12:51:31 <yac> but what program? It says it's running command dist/dist-sandbox-82ddaa05/build/Data/Yaml/Syck_hsc_make
12:51:32 * dcoutts_ notes that the process lib is better in 7.10 and reports the not found exception properly
12:51:47 <dcoutts_> yac: hsc2hs works by compiling a C program and then running it
12:52:01 <yac> I do have hsc2hs
12:52:12 <dcoutts_> hsc2hs generates a C program from the .hsc file, and runs the program to produce the .hs output file
12:52:15 <yac> and the build works when I unpack the tarbll and run cabal build
12:52:40 <dcoutts_> yac: it'd be interesting to compare the full logs of both, with higher verbosity, e.g. -v2 or -v3
12:52:45 <xkb> Does halycon work on os x?
12:52:59 <dcoutts_> yac: and we'd need details of system, ghc version, hsc2hs version etc
12:53:15 <yac> dcoutts_: -v3 never helped me either
12:53:20 <seubert> xkb: lots of halcyon discussion going on in #haskell-deployment but i believe the answer is yes
12:53:30 <xkb> Thanks
12:56:51 <sssilver|> let num = read (strNum <- getLine) :: Int  -- why doesn't this work?
12:57:00 <mauke> because it's a syntax error
12:57:01 <sssilver|> sorry
12:57:09 <mauke> you can't have random <- in your code
12:57:20 <sssilver|>     let num = read getLine :: Int  -- this
12:57:26 <mauke> that's a type error
12:57:33 <mauke> read takes a string; getLine is an IO action
12:58:14 <sssilver|> and     let num = read (<- getLine) :: Int ?
12:58:16 <mauke> heh, would be funny if getLine was a string, though: getLine = "hello world"
12:58:25 <mauke> sssilver|: back to case #1
12:58:31 <MP2E> again <- is a syntax error outside of do blocks
12:59:31 <EvanR> sssilver|: look at the types
12:59:37 <EvanR> :t getLine
12:59:37 <lambdabot> IO String
12:59:43 <EvanR> :t (>>=)
12:59:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:59:50 <hsk3> In this simple code: http://lpaste.net/4379830738757877760
12:59:51 <hsk3> The function definition in the type class instance puzzles me. This definition of == is nothing like an ordinary function definition. My question is: How does it work? How does Haskell actually know where the function definition starts? The pattern matching seems to just start right away, which looks weird.
12:59:51 <hsk3> Your thoughts would be appreciated
12:59:52 <EvanR> IO a -> (a -> IO b) -> IO b
12:59:56 <sssilver|> MP2E: well it is in a do block
13:00:07 <yac> dcoutts_: it doesn't seem to be running the hsc2hs at all when building from tarball
13:00:12 <mauke> sssilver|: but not directly under 'do'
13:00:26 <mauke> sssilver|: do { v <- X; ... } is syntactic sugar for X >>= \v -> do { ... }
13:00:26 <dcoutts_> yac: got the log?
13:01:23 <sssilver|> mauke: so in cases like this I always need an intermediate temporary variable holding the string value before casting to Int?
13:02:22 <mauke> sssilver|: no
13:02:28 <mauke> and there are no casts
13:02:30 <geekosaur> hsk3: the pattern matching does indeed start right away. that's just how infix operator definitions work
13:03:26 <yac> dcoutts_: https://bpaste.net/show/04ae32c7a529
13:03:42 <yac> dcoutts_: https://bpaste.net/show/5c1420aa91bb and here's the broken one
13:04:00 <hsk3> geekosaur: but function pattern matching is supposed to be syntactic sugar for case expressions right? what's the case expression here?
13:04:08 <geekosaur> not in this case
13:04:18 <sssilver|> mauke: then what?
13:04:57 <mauke> sssilver|: I'm not sure what you're asking
13:05:00 <Hijiri> x == y is the same as (==) x y, you can just read it that way and then imagine how case expressions would work infix
13:05:04 <geekosaur> hsk3: I think it's just the infix that is confusing you? `Red == Red` can be written in function, instead of operator, form as `(==) Red Red`
13:05:05 <Hijiri> prefix8
13:05:20 <sssilver|> mauke: I'm reading string input from stdin and trying to interpret it as a number. What's the most amazing way to do that?
13:05:35 <mauke> sssilver|: n <- readLn
13:05:36 <geekosaur> since it starts with a constructor, it knows to look for an infix operator being defined
13:05:55 <EvanR> :t readLn
13:05:55 <lambdabot> Read a => IO a
13:06:20 <rui> Sorry to bother again with this, but I still haven't been able to install vty http://lpaste.net/120660
13:07:03 <rui> and I am not sure what to do, other than commit to learning every detail of cabal and fighting a tough battle
13:07:45 <athan> rui: I think there may be some C header related to this package
13:07:52 <geekosaur> that's not going to be a C header
13:08:06 <geekosaur> if I recall correctly, rui was working with a very old Windows port of ncurses
13:08:14 <rui> I am on Fedora 20
13:08:29 <athan> oop
13:08:39 <geekosaur> oh, then it shouldn't be the old split between -lcurses and -ltinfo
13:08:55 <hsk3> geekosaur: yeah perhaps
13:08:56 <geekosaur> (I think/hope. fedora isn't debian :p )
13:09:13 <rui> I had tryined installing and reinstalling everything related. Including ncurses and ncurses-devel
13:09:24 <dcoutts_> yac: for the local case that log does not show it running hsch2s. Can you do a cabal clean and then cabal configure -v3; cabal build -v3
13:09:42 <rui> dcoutts_ 1 sec
13:09:55 <rui> dcoutss_ sorry, that wasn't for me
13:09:59 <dcoutts_> np :-)
13:10:08 <geekosaur> rui: right, the specific list of names makes me think that this ncurses is old enough that the lower level routines are in -ltinfo but the package only supports modern ncurses where that library is not separate (or indeed doesn't exist)
13:10:41 <geekosaur> but fedora 20 is not 15 years old...
13:11:05 <geekosaur> (then again I ran into this on rhel6, so who knows)
13:12:11 <yac> dcoutts_: https://bpaste.net/show/b3bab2164664
13:12:18 <dcoutts_> cheers
13:13:27 <geekosaur> hm, its configure does check for separate libtinfo
13:13:34 <rui> geekosaur yum tells me its 5.9 what I have
13:14:00 <hsk3> geekosaur: but when exactly are function pattern matches equivalent to case expressions?
13:14:04 <hsk3> don't quite get that
13:15:34 <yac> lol. Is the dist/dist-sandbox-xxxxx/ path a problem maybe?
13:15:49 <geekosaur> actually when I said "not in this case" above I was answering the wrong question
13:16:07 <geekosaur> they're always equivalent
13:16:26 <hsk3> geekosaur: oh, which question were you answering then?
13:16:32 <geekosaur> the confusion here is just that Red == Red is syntactic sugar for (==) Red Red
13:16:40 <geekosaur> which looks like what you would expect
13:17:11 <geekosaur> hsk3, I was thinking in terms of the infix operator vs. prefix function thing
13:17:21 <geekosaur> not addressing pattern matching
13:17:45 <geekosaur> (i.e. I completely misinterpreted your question the first time)
13:18:03 <hsk3> ok
13:18:06 <dcoutts_> yac: ok, so the only difference between the failing and successful invocations of hsc2hs appears to be in the locations of some -I and -L flags, and location of the target
13:19:05 <dcoutts_> yac: we should try running those commands with hsc2hs's -v flag to see more detail
13:19:34 <dcoutts_> yac: either by running the commands manually, or perhaps by re-running with --hsc2hs-option=-v
13:20:20 <yac> dcoutts_: https://bpaste.net/show/1b47a320a0d1
13:20:26 <dcoutts_> yac: I think if we do cabal build -v2 rather than -v3 we'd get the hsc2hs invocation in normal shell syntax, rather than the extra-explicit Haskell syntax, which would be easier to copy and paste for running manually
13:20:57 <yac> dcoutts_: it won't have the proper setup anyway. So it is difficult to runmanually. I already tried.
13:21:23 <yac> something is preparing the dist/dist-sandbox-..../ thing
13:21:31 <hsk3> geekosaur: But how does the case expression then look in this case?
13:21:36 <dcoutts_> yac: it's worth a go though, otherwise we cannot keep the intermediate files
13:21:36 <rui> :/
13:21:40 <hsk3> geekosaur: something like this? http://lpaste.net/4379830738757877760
13:21:40 <hsk3> Looks quite convoluted
13:21:48 <dcoutts_> yac: there's also hsc2hs's --keep-files command
13:22:01 <dcoutts_> yac: so we can run the things hsc2hs is running and see why they fail
13:22:10 <dcoutts_> one of them has to produce an error message
13:22:10 <geekosaur> hsk3: roughly, yes. which is why we have this nice syntax instead
13:22:35 <hsk3> ok thanks
13:22:37 <geekosaur> you can use the ghc-core package to look at what it expands to
13:22:59 <geekosaur> although in this case, hm, not
13:23:00 <yac> dcoutts_: https://bpaste.net/show/449b31b20a09
13:23:12 <geekosaur> typeclasses get desugared by then too :)
13:23:30 <yac> --keep-files should be the default behaviour when build fails
13:24:17 <dcoutts_> yac: can you also try the install outside of a sandbox, and see what happens
13:24:43 <yac> ok, the problem is path to the .hsc
13:24:43 <dcoutts_> yac: I think we might have to manually construct the env necessary to run the failing hsc2hs
13:24:44 <yac> it seems
13:25:34 <yac> hm, unless it is expected the hsc2hs runs while chdired to the unpacked tarball
13:25:40 <geekosaur> rui: as far as I can tell, the haskell terminfo package is spotting that it should be using -ltinfo instead of -lncurses. I don't know what's going on. Try to contact the maintainer?
13:25:53 <geekosaur> I can't test it readily here
13:26:24 <rui> geekosaur thanks, I'll try to follow that lead
13:26:49 <quchen> dcoutts_: Wait, is that flag going to keep the .c file?
13:26:59 <dcoutts_> yac: yes, the build always runs with the process's dir being the root of the project
13:27:28 <dcoutts_> quchen: hsc2hs's --keep-files ? sure, but only when you can run it on it's own
13:27:47 <dcoutts_> quchen: cabal install on a tarball will do it all in a temp dir
13:28:05 <dcoutts_> the theory being if you find you need to keep files then you just cabal unpack and try it there
13:28:12 <quchen> dcoutts_: I manually caught the .c file a couple of days ago, which wasn't pretty
13:28:25 <quchen> All I want is to specify that flag in the .cabal file
13:28:30 <yac> dcoutts_: it's not keeping any files. When I run cabal install -v2 HsSyck --hsc2hs-option=-v --hsc2hs-option=--keep-files the ./dist/dist-sandbox-... is missing again
13:28:40 <quchen> I mean the .c file is as temporary as the .hs file: both are IRs
13:28:41 <rui> geekosaur, how did you notice that?
13:28:44 <dcoutts_> yac: yes, it's only a flag to hsc2hs
13:28:59 <dcoutts_> yac: that's why I said we may need to run the hsc2hs command manually
13:29:02 <geekosaur> rui: dug into the package contents on hackage and looked over its configure script
13:29:10 <yac> dcoutts_: so how do I keep everything? (which should be a default behaviour on error)
13:29:10 <geekosaur> this is not something that most people should attempt :)
13:29:14 <dcoutts_> quchen: I'm not sure what you're after exactly, did I miss some context?
13:29:28 <yac> dcoutts_: How can I run it manually when the build environment is gone?
13:29:32 <dcoutts_> yac: normally, by doing cabal unpack and then operating on it locally
13:29:40 <quchen> dcoutts_: No context, no. I just randomly caught you mentioning --keep-files and was surprised that option existed.
13:29:45 <dcoutts_> yac: indeed that might still work, if you use the same sandbox
13:29:47 <yac> it fails without the cabal sandbox all the same
13:30:02 <quchen> dcoutts_: We're having some issues with warnings generated from the .c file during compilation, which is hard to debug if the file is thrown out after the compilation
13:30:07 <dcoutts_> quchen: it's only an hsc2hs flag
13:30:36 <dcoutts_> quchen: but yes, you can specify it at configure time, or build time, and so you can put it in a local cabal config file (like all configure flags)
13:30:36 <quchen> dcoutts_: And I can't specify it in the .cabal? :-(
13:30:49 <dcoutts_> no, not in a .cabal file, but in a local cabal config file
13:31:23 <dcoutts_> local config files correspond to flags you can pass to cabal configure
13:31:31 <quchen> cabal.sandbox.config typically?
13:31:39 <dcoutts_> cabal.config typically
13:31:53 <dcoutts_> the sandbox one is managed automatically not manually
13:32:05 <yac> dcoutts_: /usr/include/stdc-predef.h:59:1: fatal error: dist/dist-sandbox-82ddaa05/build/autogen/cabal_macros.h: No such file or directory
13:32:18 <yac> which of course is enoent
13:32:26 <yac> since my build env is gone
13:32:57 <dcoutts_> yac: you should be able to achieve the same using --build-dir=dist/dist-sandbox-82ddaa0
13:33:05 <dcoutts_> for both configure and build
13:33:09 <yac> ah, that's coming from the command line
13:33:21 <yac> dcoutts_: how? it's empty
13:34:02 <dcoutts_> cabal configure --builddir=...; cabal build --builddir=...
13:35:28 <yac> dcoutts_: I don't follow. The failure happens when I do cabal install HsSyck, not cabal build inside the tarball
13:35:57 <dcoutts_> yac: but we're trying to reconsutrct how cabal does the build when it does it for the tarball
13:36:01 <yac> I need to fix these: --cflag=-Idist/dist-sandbox-82ddaa05/build/autogen --cflag=-include --cflag=dist/dist-sandbox-82ddaa05/build/autogen/cabal_macros.h
13:36:45 <t4nk874> hi, first time I come here.
13:36:51 <yac> dcoutts_: ok, so I unpack the tarball, copy the cabal.sandbox.config there and run cabal build so I can later run the hsc2hs manualy?
13:37:10 <t4nk874> is it ok to ask question about haskell coding here, as a beginner ?
13:37:21 <Cale> t4nk874: yes, absolutely :)
13:37:29 <t4nk874> thx
13:38:11 <dcoutts_> yac: I think we want to use what I suggested above, cabal configure --builddir=dist/dist-sandbox-82ddaa05 cabal build --builddir=dist/dist-sandbox-82ddaa05
13:38:30 <dcoutts_> yac: possibly also --sandbox-config-file=  to wherever the sandbox is
13:38:51 <aidecoe> which module provides Math functions like pow, n! etc?
13:38:53 <rui> geekosaur And the configure script is what file? The .cabal, or some other? Setup.lhs seems to just call defaultMain
13:39:01 <dcoutts_> yac: just copying may work, not sure
13:39:04 <mauke> aidecoe: Prelude
13:39:13 <EvanR> what is factorial?
13:39:21 <mauke> EvanR: product [1 .. n]
13:39:30 <geekosaur> rui: it is a file named configure
13:39:35 <yac> dcoutts_: I've done it before. It has all path absolute
13:39:40 <geekosaur> http://hackage.haskell.org/package/terminfo-0.4.0.0/src/configure
13:39:53 <aidecoe> ah, x^y works (-:
13:40:08 <aidecoe> thanks
13:41:08 <geekosaur> rui: the library linking instructions that are part of the installed terminfo package are incorrect, which is why the linking of test programs in vty that depend on it fail
13:42:06 <geekosaur> (ghc-pkg field terminfo extra-libraries)
13:43:11 <rasen> How can I swap two elements of Vector?
13:43:35 <yac> dcoutts_: ok, I ran that. The dist-sandbox-... is gone again
13:44:00 * hackagebot rainbox 0.10.0.0 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.10.0.0 (OmariNorman)
13:44:03 <dcoutts_> yac: you're not doing install right? this is in the unpacked dir
13:44:10 <dcoutts_> yac: you may have to make the dir in the first place
13:44:13 <yac> right
13:44:30 <dcoutts_> the builddir you're telling it to use
13:45:07 <yac> dcoutts_: https://bpaste.net/show/53e0b57f3487 this is what I've done
13:45:58 <orzo> that site does not work well with text resizing
13:46:04 <yac> oh wait. it's in the path with the tarball
13:46:05 <hannes__> so, for the nth time... let's try to build ghc 7.10.1
13:46:32 <dcoutts_> yac: ok, we should look at the way hsc2hs is being invoked now, and compare with the failing one. We should also see if we can now try running manually the failing hsc2hs command, we ought to have the right env to do that
13:47:03 <yac> dcoutts_: I copied the failing one to the tarballed path where I ran the latest pastebin, it works there
13:47:32 <yac> the failing hsc2hs command line
13:47:55 <dcoutts_> yac: oh, wait, it's not something like that the install one is building in /tmp and you've got tmp mounted no-exec?
13:48:12 <yac> oh my god
13:48:22 <yac> I've had the same problem with go-lang but there I was able to figure it out
13:48:44 <dcoutts_> it'd certainly explain why running the C prog fails with not found, if the +x bit is not set
13:48:48 <dcoutts_> or equiv
13:49:34 <yac> yeah, mount -o remount,exec /tmp made the issue go away
13:49:49 * yac headdesks
13:50:42 <dcoutts_> hmm, I wonder if there's anything we could do do make this issue more prominent and discoverable up front
13:50:46 <rui> geekosaur running that, terminfo doesn't show any extra libraries
13:50:58 <geekosaur> um, that is broken
13:51:08 <geekosaur> extra-libraries: ncurses
13:51:09 <dcoutts_> yac: can you file a ticket with Cabal and explain the issue. Ideally we'd have a check at configure time and explain it clearly.
13:51:10 <yac> dcoutts_: well, first thing, I have no idea that /tmp is being used from the logs
13:51:12 <geekosaur> (on my Mac)
13:51:24 <geekosaur> so you definitely need to contact the maintainer of the terminfo package
13:51:46 <dcoutts_> yac: it does say, but it's not prominent. "to /tmp/HsSyck-0.52-29513..."
13:51:51 <rui> geekosaur I'll reinstall terminfo in all ways possible and see if that output changes
13:52:16 <yac> dcoutts_: then there is the /proc/self/mountinfo | grep noexec
13:52:35 <geekosaur> (as it turns out I have two versions of terminfo installed for some reason... 0.3.2.6 has ncursesw there, 0.4.0.0 has ncurses
13:52:58 <geekosaur> the latter is arguably more correct for this platform, but it does suggest that detection of curses libraries has changed)
13:53:34 <Kron> how does one sequence some delays into a main IO monad?
13:53:49 <Kron> I want a few fractions of a second between printing each element of a very long list
13:53:49 <EvanR> :t threadDelay
13:53:50 <lambdabot> Not in scope: ‘threadDelay’
13:53:52 <RchrdB> Kron: as in timed pauses? Control.Concurrent.threadDelay
13:53:57 <Kron> thank you!
13:54:04 <rui> geekosaur now it seems I have 1 terminfo 0.4.0.1 in the global repository, and 2 (0.4.0.0 and 0.4.0.1) in the user
13:54:45 <rui> geekosaur and now they show tinfo in extra-libraries
13:55:02 <rui> (after doing a cabal install terminfo --reinstall)
13:55:14 <RchrdB> Kron: http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Concurrent.html#v:threadDelay takes a number of microseconds to pause. (Be aware that Int may have a maximum value as small as 2**30 depending on your compiler and platform. ^_^)
13:55:19 <geekosaur> interesting
13:56:35 <yac> dcoutts_: I see, it's at the start.
13:57:02 <eikke> anyone familiar with typelits arouond?
13:57:16 <RchrdB> Kron: oops, my bad, Int is only required to have a maximum value of at least (2**29)-1 according to the Haskell 98 spec. :)
13:57:27 <dcoutts_> yac: we should do an explicit check for this issue I think, there's several things that rely on execing. So do please file a ticket to this effect.
13:57:40 <yac> dcoutts_: I'm filing it
13:58:03 <dcoutts_> thanks very much
13:58:20 <yac> dcoutts_: thank you for solving for my problem
13:58:33 <dcoutts_> yac: sorry it was so tricky and time consuming
13:59:14 <yac> dcoutts_: what's your github handle?
13:59:21 <dcoutts_> dcoutts I think
14:02:28 <Fare> Hi. Can someone help me read this type? class Monad m => MonadDelimitedCont p s m | m -> p s where ... https://hackage.haskell.org/package/CC-delcont-0.2/docs/Control-Monad-CC.html
14:02:31 <Fare> what is this | ?
14:02:58 <geekosaur> functional dependency
14:03:15 <geekosaur> "if you know type m then you know what types p and s are"
14:03:50 <geekosaur> so the compiler can always work those out for you rather than requiring you to always specify all of p, m, and s every time you use some method in the typeclass
14:04:16 <ttt_fff> is there some big DAG somewhere of haskell tricks / concepts / ideas
14:04:23 <ttt_fff> where I can go through the DAG and level up my haskell skills?
14:04:34 <ttt_fff> i feel like I'm hitting this weird plateau where I've read most of the standard haskell books
14:04:38 <ttt_fff> but there's all these cools things that are not in books
14:04:47 <ttt_fff> and I have to hunt/peck for them (when I'm not even aware of what i'm looking for)
14:05:17 <mauke> what weird kind of hypertext would have a DAG shape?
14:05:28 <Fare> so it say "I can build a MonadDelimitedCont of p, s, m where p and s are computed from m, out of a Monad m" ?
14:05:34 <EvanR> ttt_fff: you dont like grinding? ;)
14:05:46 <EvanR> haskell doesnt even cost 10$ a month
14:05:52 <mauke> everything I can think of is either a tree or cyclic
14:06:01 <Fare> geekosaur, thanks.
14:06:06 <ttt_fff> mauke: directed a cyclic graph of concepts
14:06:12 <ttt_fff> since a cyclic group of concepts is hard to learn
14:06:28 <ttt_fff> EvanR: I want to buy a level/ 70 haskell druid/paladin; do you have any to sell?
14:06:32 <nick2938> Are there any functions like filter that also spit out a list of rejected elements?
14:06:35 <ttt_fff> it needs to come with ghc-mod, hdev-tools preinstalled
14:06:47 <mauke> nick2938: partition
14:07:19 <nick2938> mauke: Exactly what I wanted, thanks!
14:07:27 <Welkin> or
14:07:31 <Fare> if p and s can be deduced from m, why isn't it just a MonadDelimitedCont m ? Because the function from m to p and s depends on the instance of the class?
14:07:33 <Welkin> you could just negate your predicate for filter
14:07:36 <bitemyapp> Is there anybody here that's in San Francisco and would like to use Haskell for their day job?
14:07:47 <Welkin> filter (not predicate) xs
14:08:15 <Fare> so secretly, it's a MonadDelimitedCont m p' s', with p = p' m and s = s' m ?
14:08:56 <dmj`> bitemyapp: you hiring haskell devs?
14:08:58 <Fare> with the additional constraint that p' and s' are amenable to discovery by the type unifier.
14:09:24 <bitemyapp> dmj`: I'm not, but somebody I know is. Has to be SF local I think though.
14:09:43 <bitemyapp> dmj`: PM me.
14:09:51 <Fare> thanks!
14:10:17 <mniip> fryguybob, after thorough inspection of the ModIface datatype I found nothing that looks like a value
14:10:28 <EvanR> the unreasonably effectiveness of moving to SF
14:10:32 <EvanR> unreasonable*
14:10:42 <mniip> the closest I found is typed names
14:10:51 <Welkin> I thought bitemyapp lived in texas
14:11:25 <johnw> if anyone wants to see a real example of Free and FreeT being used together cooperatively, I've cleaned up my assembly language DSL example: https://github.com/jwiegley/linearscan/blob/master/test/DSL.hs
14:11:31 <johnw> also see Assembly.hs, and Main.hs in that directory
14:11:39 <oconnore> Fare: shouldn't you be in #lisp? ;)
14:11:53 <Fare> oconnore: there, too.
14:12:39 <oconnore> Fare: me too, just joking
14:12:47 <Fare> I'm trying to understand the types for delimited control, after failing to reinvent them in a few hours of thinking hard.
14:13:00 <yac> dcoutts_: https://github.com/haskell/cabal/issues/2422
14:13:06 <Fare> I guess I'm not used to that kind of thinking
14:13:06 <dcoutts_> thanks!
14:13:16 <ocramz> @free fmap
14:13:17 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
14:14:04 <ocramz> @free fmap :: Functor f =>  a -> b -> f a -> f b
14:14:04 <lambdabot> Extra stuff at end of line
14:14:32 <ocramz> @free fmap :: Functor f =>  (a -> b) -> (f a -> f b)
14:14:32 <lambdabot> Extra stuff at end of line
14:14:37 <yac> dcoutts_: no problem
14:14:37 <Fare> maybe this can help, too: http://www.ccs.neu.edu/home/amal/course/7480-s12/delim-control-notes.pdf
14:16:22 <oconnore> Fare: cool, I haven't played with those yet
14:17:16 <Fare> gtg  have fun!
14:18:26 <rasen> Why I'm getting "Pattern matches are ovelapped" on this: swapInList x y = map $ \case { x -> y; y -> x; e -> e } ?
14:18:44 <mauke> rasen: because x/y/e are all the same pattern
14:19:02 <rasen> oh.. I see. They hide x y from argument
14:20:01 <hannes__> aww... I thought Semigroup => Monoid was in 7.10 :(
14:22:33 <johnw> hannes__: that breaks a lot of things in a not-terribly-useful way
14:23:12 <johnw> i mean, ideally it would be great; but realistically the pain is not worth the gain
14:28:05 <yac> johnw: no pain, no gainz
14:29:45 <hannes__> johnw: It's just sort of annoying to have to specify Semigroup when Monoid is already given... I see your point about not breaking things, but 7.10 already introduces breaking changes, I figured might as well address that
14:30:00 <hannes__> when you're already breaking things, why not go all the way ;)
14:30:04 <johnw> um, yeah
14:30:11 <johnw> that argument doesn't fly with everybody :)
14:30:26 <johnw> if you break things one at a time, you have a better of chance of seeing which one screwed things up
14:30:27 <rui> geekosaur If I install terminfo with yum, it installs version 0.3.2.5 with ncursesw in extra-libraries
14:36:23 <ril> if I define a record e.g.
14:36:23 <ril> data Word = Word {text :: String, width :: Double} deriving (Show)
14:36:50 <ril> what is the best way to map over a list of Words extracting one of their fields?
14:36:54 <ril> haskell doesn't seem to have `pluck`
14:37:02 <hannes__> ril: map text
14:37:06 <hannes__> map width
14:37:28 <ril> thanks!
14:37:29 <hannes__> > data Word = WOrd {text:: String, width :: Double} deriving Show
14:37:30 <lambdabot>  <hint>:1:1: parse error on input ‘data’
14:37:40 <hannes__> argh
14:38:04 <hannes__> anyway, text is of type Word -> String
14:38:17 <hannes__> and width Word -> Double
14:38:38 <hannes__> the record syntax is basically just a shorthand for defining these functions... and giving you a modifier syntax
14:39:52 <Rotaerk> records can be such a pain
14:39:56 <Rotaerk> when will they be fixed?
14:40:17 <johnw> in 3,421 days.  Give or take 3,421 days.
14:40:30 <Rotaerk> kk, sounds reliable
14:40:55 <EvanR> maybe dont use super deep nests of records
14:41:07 <EvanR> the ORM problem
14:41:47 <mauke> Rotaerk: http://nikita-volkov.github.io/record/ ?
14:44:45 <neuromage> hey haskellers! I've been learning haskell lots recently, and want to take it to the next level and work on a medium scale project. Hopefully, a project that would make me use intermediate concepts like monad transformers and parsers. Any ideas? Off the top of my head, I was thinking of 1) writing a static blog generator, with a simple DSL, like a simpler version of Hakyll, 2) a task runner like Grunt, that watches files and execu
14:44:45 <EvanR> can i run ghc and get type checking without having to define all my functions
14:44:57 <Rotaerk> when I make records, I tend to prefix the names of the fields within, with the name of the record type itself
14:45:09 <Rotaerk> data Foo = { fooField1 :: ..., fooField2 :: ... }
14:45:33 <Rotaerk> because I would frequently want to use "field1" to refer to the value itself, not the function that accesses that value
14:46:02 <EvanR> neuromage: yes static blog generator conrete project is a good place to start, monad transformers is not a good place to start. hammer looking for a nail
14:46:32 <Rotaerk> mauke, thanks
14:47:06 <EvanR> Rotaerk: a way to deal with that is to use less variables
14:47:07 <neuromage> Cool, thanks EvanR! Just curious, why do you say monad transformers is not a good place to start?
14:47:40 <Rotaerk> EvanR, true, but that's not always a reasonable option
14:47:41 <EvanR> neuromage: if you want to learn how monad transformers work, thats one thing. but "i need to find a project to use monad transformers on" is probably misguided.
14:47:52 <Rotaerk> getting it to be pointfree can be ugly
14:48:18 <EvanR> Rotaerk: otoh prefixing something also helps resolve conflicts with other record types
14:49:01 * hackagebot linearscan-hoopl 0.1.0.0 - Make it easy to use the linearscan register allocator with Hoopl  http://hackage.haskell.org/package/linearscan-hoopl-0.1.0.0 (JohnWiegley)
14:49:52 <rui> geekosaur in vty.cabal, it says it can work with terminfo >= 0.3 && <0.5. I changed it to <0.4 so it uses the old terminfo installation to see if it works
14:50:11 <rui> ok, couldn't for other reasons, but I unregistered all those terminfos, and IT INSTALLED
14:50:17 <neuromage> EvanR: That makes sense, thanks!
14:50:43 <ril> where do you put the type signature in a lambda expression, if you want to annotate it for clarity?
14:51:15 <EvanR> :t ((\x -> x) :: Int -> Int)
14:51:16 <lambdabot> Int -> Int
14:51:44 <josephle> :t \(x :: Int) -> x -- alternatively
14:51:45 <lambdabot> Int -> Int
14:52:06 <ril> thanks
14:52:21 <ril> in the alternate syntax where do you annotate the return type?
14:52:30 <dicioccio1> ``≤`≥`µµ`≥≥≥~~~,~,
14:52:32 <dicioccio1> ~,
14:52:48 <n4x> @type (\x -> (x :: Int)) -- something like this?
14:52:49 <lambdabot> Int -> Int
14:53:19 <josephle> :t \(x :: Int) -> (x :: Int) -- this does seem a bit heavy though
14:53:20 <lambdabot> Int -> Int
14:53:43 <josephle> if you need to annotate both the argument and the return type, I think EvanR's suggestion is best
14:53:50 <ril> cool. what if I want to annotate an automatically curried function instead of a lambda?
14:55:21 <EvanR> ril: you can put annotations on any normal expression (foo :: Foo)
14:55:31 <EvanR> thats what i did up there
14:56:08 <ril> I must be getting something else wrong
14:57:52 <ril> hehe, had a $ instead of a . in my expression. thanks folks ^^
15:01:55 <Rotaerk> huh, DataKinds ... does this allow for basic dependent typing?
15:04:48 <Hijiri> how do you define the semantic meaning of things that are supposed to represent things like decks of cards? find a mathematical representation of card decks?
15:05:48 <EvanR> a deck of cards is 52 specific things, its not very complicated
15:06:07 <EvanR> tedious to type out maybe
15:06:26 <koomi> Rotaerk: no, there is no connection between a data type and it's promoted kind
15:06:54 <koomi> Rotaerk: but you can fake it with some tricks, see the singletons package
15:15:39 <adam_hardkey_shi> Little question, how do i use OpenGL in a window created with OpenGL?
15:16:06 <EvanR> use the gl package
15:16:16 <Kron> what's the standard random number generator?
15:16:23 <Kron> System.Random?
15:17:19 <EvanR> adam_hardkey_shi: note that you cant create windows with opengl
15:17:24 <Axman6> usually, but it depends what sort of random numbers you want.
15:17:43 <adam_hardkey_shi> *SDL
15:17:51 <adam_hardkey_shi> A window created with SDL. ^^
15:17:53 <Axman6> System.Random isn't a cryptographically secure RNG, but is fine for use in say games
15:18:04 <Kron> yeah, i'm looking at games at the moment
15:18:13 <Kron> just a really bog standard 1d10 that no-one's trying to crack
15:18:39 <EvanR> :t randomRIO
15:18:40 <lambdabot> Random a => (a, a) -> IO a
15:18:57 <EvanR> > randomIO (1,10)
15:18:58 <lambdabot>  Couldn't match expected type ‘(t0, t1) -> t’
15:18:58 <lambdabot>              with actual type ‘GHC.Types.IO a0’
15:19:00 <Kron> i'm not sure how to use StdGen though
15:19:14 <EvanR> > randomRIO (1,10)
15:19:15 <Hijiri> and then some powergamer exploits the unrandomness of your game
15:19:16 <lambdabot>  <IO Integer>
15:19:18 <Axman6> @dice 1d10
15:19:19 <lambdabot> Axman6: 4
15:19:36 <EvanR> Hijiri: like in the 1 hour speed run of final fantasy 1
15:19:46 <Kron> this is just for a simple AI in a box, I'm not going to make it quiiiite that good
15:20:40 <Kron> is it better to use RIO?
15:22:30 <Hijiri> where can I go to get a good understanding of machines?
15:22:45 <acowley> Hijiri: IRC
15:22:51 <Hijiri> ok
15:22:55 <acowley> Hijiri:: Do you have any specific questions?
15:23:03 <hannes__> Hijiri: What kind of machines?
15:23:10 <Hijiri> machines of the machines package
15:23:56 <Hijiri> I am making a library for a board game and I thought that machines might have some useful patterns
15:24:25 <hannes__> I read "networked" and "streams" and now I'm thinking "is this like pipes or conduit"?
15:24:44 <hannes__> but the module names suggest automatons
15:25:00 <acowley> hannes_: All of those guesses are right!
15:25:24 <Hijiri> also I want to learn more abstractions and feel better about myself
15:25:44 <acowley> You're a wonderful human being.
15:26:00 <acowley> Now that you're feeling better about yourself, what kind of thing do you want to do with machiens for your scenario?
15:26:02 <acowley> :P
15:26:19 <Hijiri> Not sure, I don't even know which parts of machines would apply in my situation
15:26:22 <shelf> this might be useful, who knows http://blog.jle.im/entries/series/+intro-to-machines-and-arrows
15:26:27 <Hijiri> the specific game is japanese mahjong
15:26:53 <Hijiri> I've only looked at the slide presentation that is linked in the contents page of machines so far
15:27:28 <acowley> The way that I think about a library like machines is that it helps you do things that Arrows have been used for the past. Namely, write little stateful loops that you then snap together.
15:28:03 <acowley> So if you have some sort of process that will be applied to a sequence of data, and that process should evolve over time, then something like machines can make a lot of sense.
15:29:26 <acowley> The win with this kind of abstraction is that you write "A ~> B ~> C" rather than one nested loop that manages the combined state of components A, B, and C.
15:30:07 <bitemyapp> acowley: you saw the Machine.Pipe PR right?
15:30:35 <acowley> bitemyapp: Yes, but I haven't looked too closely. I was disappointed that it keeps the Proxy name :(
15:30:48 <bitemyapp> acowley: yeah that wasn't one of my favorite parts of Pipes.
15:30:53 <acowley> That name kept me away from pipes for a long time as it makes no sense to me
15:30:57 <bitemyapp> but that's bikeshedding so I tried to keep my mouth shut
15:30:59 <acowley> and it conflicts with Data.Proxy
15:31:02 <Hijiri> so I guess I have the entire state, and then each player has their own state sort of, I guess the players could be machines that await new tiles when they draw, and yield discards etc/
15:31:06 <acowley> It is bikeshedding so I don't complain about it
15:31:10 <acowley> but... oy
15:31:12 <Hijiri> s/\//?/
15:31:20 <hannes__> OMG partial type signatures
15:31:25 <bitemyapp> hannes__: nice right?
15:31:38 <bitemyapp> acowley: we can probably let Ed be the bad guy.
15:31:58 <acowley> Hijiri: if you need the entire state for some purpose, then you may want to consider something like lens's zoom function.
15:32:58 <hannes__> and they can do constraints too...
15:33:00 <acowley> bitemyapp: Do you know the author of the PR? Are they really set on that name?
15:33:02 <hannes__> that's... beutiful
15:33:09 <hannes__> *with an a
15:34:31 <bitemyapp> acowley: actually I do, I'll talk to them.
15:35:13 <acowley> bitemyapp: That'd be great, thanks
15:36:48 <acowley> Are any cabal maintainers around?
15:37:07 <dcoutts_> acowley: mm?
15:37:31 <acowley> dcoutts_: I've written some rather extensive sandbox and nix integration
15:37:40 <acowley> dcoutts_: It's all bash, and requires nothing new in cabal
15:37:55 <bitemyapp> acowley: what manner of integration?
15:38:01 <acowley> dcoutts_: But one thing gets a little janky
15:38:08 <acowley> dcoutts_: I will sometimes get this error from cabal
15:38:11 <acowley> readlink: illegal option -- f
15:38:11 <acowley> usage: readlink [-n] [file ...]
15:38:26 <acowley> dcoutts_: The message hasn't every preceded anything actually breaking
15:38:37 <dcoutts_> cabal itself does not call readlink as far as I know
15:38:42 <acowley> dcoutts_: And it is almost certainly due to me monkeying around in the sandbox
15:38:55 <acowley> dcoutts_: It's either cabal or ghc
15:39:01 <geekosaur> something is assuming gnu readlink on a bsd box
15:39:05 <acowley> dcoutts_: As this is happening after I've nixifed everything
15:39:20 <dcoutts_> acowley: perhaps a ./configure script in some package?
15:39:42 <acowley> dcoutts_: For instance, I just ran "cabal exec ghc -- --make -threaded site.hs"
15:39:56 <acowley> and got that error message a number of times that probably equals how many libraries get linked into a hakyll build
15:40:28 <dcoutts_> acowley: cabal uses the readlink C function, but not the external program
15:40:33 <acowley> and the sandbox my nix tool creates is entirely composed of symlinks into the nix store, which seems related
15:41:04 <dcoutts_> looking in ghc now...
15:41:16 <mauris> #haskell! i found out something really sweet about NFAs ( http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton ) and monads, i think!
15:41:18 <acowley> bitemyapp: It's a program that ties together cabal freeze and the nix store to cache builds of things
15:42:00 <acowley> bitemyapp: But I'm not yet sure how well it works, to be honest. So I haven't released it yet as I'd just drown in bug reports.
15:42:11 <dcoutts_> acowley: again more uses of the readlink C function in the libs in ghc, but nothing that calls it as an external process
15:42:43 <mauris> "a transition function Δ : Q × Σ → P(Q)." in haskell, call this "delta :: q -> s -> Set q"
15:42:55 <dcoutts_> acowley: can you pin point where the warning comes from, based on where it appears in the logs relative to other stuff?
15:42:56 <acowley> dcoutts_: I can't think what could be running besides cabal-install and ghc  given that command I gave
15:43:13 <acowley> dcoutts_: Linking...
15:43:39 <acowley> GHC prints out "Linking..." then a stream of that error message, then everything's fine
15:43:39 <mauris> then the Δ* function described in that article is just "foldM delta" for the Set "monad", which is sort of crazy
15:44:06 <dcoutts_> acowley: then perhaps it's gcc or the linker
15:44:23 <dcoutts_> acowley: try running that step with -v, and/or -v to ghc too
15:44:34 <mauris> and replacing Set with Identity gets you exactly a deterministic FA :o
15:45:42 <dcoutts_> acowley: I grepped the whole Cabal, cabal-install and ghc source trees
15:46:30 <dcoutts_> we tend not to call external processes for these kinds of system utils anyway because they're not portable across all systems (windows etc)
15:46:45 <acowley> dcoutts_: Hm. It prints the linker line, which is clang and hundreds of arguments
15:47:25 <dcoutts_> acowley: and then the readlink warning comes after that?
15:47:33 <acowley> dcoutts_: Yes
15:47:46 <dcoutts_> so perhaps that points to clang
15:47:54 <acowley> yeah
15:47:57 <dcoutts_> its driver script or something
15:48:07 <acowley> Well I guess that's back on nixpkgs
15:48:17 <acowley> At least now I can probably blame copumpkin specifically :P
15:48:22 <dcoutts_> :-)
15:48:40 <dcoutts_> I didn't realise you used clang for ghc on nix
15:48:47 <acowley> dcoutts_: Thanks for the help, and sorry for the false alarm! I'd only seen this when doing things with cabal
15:48:57 <dcoutts_> acowley: no probs, glad to help
15:48:59 <acowley> dcoutts_: clang for everything on darwin
15:49:10 <dcoutts_> ah, nix on darwin, not nixos
15:49:22 <acowley> yes, sorry I didn't mention that!
15:49:38 <acowley> Anyway, I'm optimistic that this tool is amazingly awesome
15:49:42 <dcoutts_> np, probably not relevant
15:49:56 <acowley> It lets you have multiple instances of the same version of a library in your store
15:50:08 <dcoutts_> acowley: great, just what nix is good for
15:50:16 <dcoutts_> acowley: and what I want to get into cabal natively
15:50:17 <acowley> And a big win would be to seed things with something like a cabal.config from stackage
15:51:01 <acowley> dcoutts_: Yeah, it's unfortunate (imo) how the Nix mindset is more to track the latest versions of things
15:51:19 <acowley> dcoutts_: When the most exciting feature to me was how it could deal with *every* version
15:51:40 <dcoutts_> acowley: ah, you mean the package expression collections only have one version available?
15:52:00 <acowley> dcoutts_: It's ad hoc. Some packages have multiple versions written into the collection
15:52:04 <dcoutts_> because those are essentially the manually picked combinations of versions
15:52:18 <acowley> dcoutts_: My tool bases everything off of cabal's solver instead
15:52:21 <dcoutts_> where as what we want to do with cabal is to use the solver to pick the set of versions
15:52:26 <acowley> Yep
15:52:32 <dcoutts_> and then that becomes a nix artifact
15:52:44 <acowley> So if my thing works for folks, then this will be a pretty good solution for people on Linux and OS X via nixpkgs
15:52:46 <dcoutts_> acowley: right, and that's the approach we'd take with doing it natively in cabal
15:53:09 <dcoutts_> acowley: let us know how it goes, it might help inform our design for it within cabal natively
15:53:37 <dcoutts_> acowley: road map: http://www.well-typed.com/blog/104/
15:53:40 <acowley> dcoutts_: I think it's a great reflection on both nix and cabal that I could write this thing without having to change either one!
15:53:46 <dcoutts_> aye
15:53:58 <acowley> dcoutts_: And I'm actually happy to outsource this stuff to nix
15:54:13 <acowley> I realize that for cabal, windows support is probably an issue with using nixpkgs
15:54:19 <dcoutts_> right
15:54:24 <dcoutts_> and integrating with the UI nicely
15:54:44 <acowley> So, with my thing, you do "cabal init" as normal, then run "cabbage"
15:54:48 <acowley> and everything is taken care of
15:54:51 <dcoutts_> heh, nice name
15:55:18 <acowley> it makes sure it has the right versions with the right dependencies and links them all into the sandbox
15:55:29 <acowley> so you can then continue to work without being stuck in nix-shell or anything
15:55:36 <acowley> the name is doe to shapr :)
15:55:39 <acowley> due
15:55:41 <dcoutts_> :-)
15:55:53 <acowley> But I just installed hakyll and made a test site with it
15:55:58 <acowley> And I have ghc-mod installed with it
15:56:05 <acowley> so those are some pretty heavy things to get installed
15:56:08 <dcoutts_> aye
15:56:27 <acowley> It needs more caching work, but I hope other people can help out with that when I put it up on github
15:57:02 <dcoutts_> acowley: doesn't nix take care of that part, the caching?
15:57:14 <acowley> dcoutts_: Yes, the builds
15:57:38 <acowley> dcoutts_: But right now I grab the cabal files and run the solver to compute a nix expression
15:57:46 <acowley> dcoutts_: If that nix expression is already realized in the store, it's done
15:57:56 <dcoutts_> ah a single one, not a set, so cannot share things
15:57:59 <acowley> but the downloading and nix expression generation takes a couple seconds
15:58:07 <acowley> for each package
15:58:20 <acowley> So for hakyll it takes a couple minutes to realize everything is ready
15:58:35 <acowley> Then symlinking everything into the sandbox actually takes another minute or two
15:58:42 <dcoutts_> wow
15:58:55 <dcoutts_> acowley: downloading what?
15:59:07 <acowley> My hakyll sandbox is 2.3M
15:59:11 <vhictour> Who knows how to hack a bank?
15:59:11 <dcoutts_> isn't all the info you need available from the hackage index?
15:59:20 <acowley> dcoutts_: Right now I download the whole package with cabal get
15:59:23 <acowley> dcoutts_: Yes it is
15:59:34 <acowley> dcoutts_: But I don't yet know how to make use of that
15:59:59 <dcoutts_> acowley: in bash, wget the index, use tar to extract just the .cabal file you're after
16:00:14 <acowley> dcoutts_: That is on the TODO list :)
16:00:19 <dcoutts_> and only have to get the index once
16:00:31 <dcoutts_> anyway, cool stuff
16:00:49 <acowley> Yeah, thanks. I really wish the Window story was better so that this could evolve into an official solution
16:01:00 <EvanR> i wrote some types down which look kind of like monads. http://lpaste.net/120664 but there are more type variables, looks kind of like category. two things, the >>=-like operator might be hard to use for a large expression, and its annoying that theres always one more constraint i seem be able to add to the types... but you gotta stop somewhere...
16:01:04 <acowley> But I really wanted this to work sooner rather than later
16:01:18 <dcoutts_> acowley: so have a look at the blog post above, that outlines my general thoughts on doing it within cabal natively
16:01:24 <EvanR> "type state"
16:01:49 <dcoutts_> acowley: and I'd appreciate any thoughts you have, especially in light of the experience
16:02:36 <mpickering> EvanR: Looks like you've discovered indexed monads?
16:02:39 <dcoutts_> acowley: we have some extra challenges, like working on local unpacked packages, not just tarballs
16:03:23 <dcoutts_> last time I checked nix didn't try to deal with the case of live build trees, rather with complete packages
16:03:25 <acowley> dcoutts_: I did read that post when it went up. All of the thinking reflected in those posts is consistent with my thinking
16:03:32 <dcoutts_> acowley: ok
16:03:52 <acowley> dcoutts_: Yeah, my tool takes a package name which it will realize in the store for you, or you can run it in a directory that you're working in
16:04:24 <EvanR> mpickering: *grabs your aol keywords and runs to google*
16:04:28 <acowley> dcoutts_: Do you use Nix (nixpkgs or nixos) yourself?
16:04:51 <dcoutts_> acowley: I don't, but several of my colleagues do, and I've read the nix papers
16:04:56 <acowley> dcoutts_: I really like that DanP and JohnW are so invested in it
16:05:04 * vhictour is stupid
16:05:13 <acowley> dcoutts_: It lets you benefit from some excellent programmers :)
16:05:19 <dcoutts_> I know :-)
16:05:50 <ConfusedGirl> Can someone help me fill a matrix with a function? so far I have started with  fillMatrix :: (Int,Int) -> a -> (Matrix a)      and newtype Matrix a = Mat ((Int,Int),(Int,Int) -> a)   I have never used matrixes in haskell because I am still new
16:06:44 * vhictour is laughing
16:07:05 <mpickering> EvanR: and yes, indexed monads are quite icky to use as a Control.Monad.Indexed doesn't really make sense and you have to use rebindable syntax
16:07:06 <ConfusedGirl> > matrix 4 4 $ \(i,j) -> 2*i - j
16:07:07 <acowley> Just gotta get johnw back to working on https://github.com/jwiegley/hnix and then we'd just need a thorough bash compatibility layer for Windows support
16:07:08 <lambdabot>  Not in scope: ‘matrix’
16:08:39 <EvanR> mpickering: nice, a module with all this stuff already existing. in what way are they icky? in what way does the module not make sense
16:09:05 <shapr> acowley: CABBAGES HURRAH!
16:09:33 <dcoutts_> shapr: :-)
16:09:54 <acowley> shapr: You are my muse!
16:09:58 <shapr> haha
16:09:59 <dcoutts_> acowley: yes, John told me he was working on re-implementing some of the nix bits in Haskell :-)
16:10:06 <linman32> hi tried installing cabal-src-0.2.5 and got this error
16:10:06 <linman32> hackage-docs.hs:123:5: Not in scope: withCheckedProcess
16:10:20 <shapr> acowley: I merely a-muse
16:10:32 <mauris> ConfusedGirl: what's your implementation for `fillMatrix`?
16:10:38 <Gurkenglas> The way to make a histogram from a [a] is M.fromListWith (+) . map (,1), right?
16:10:48 <Gurkenglas> (Given Ord a)
16:10:57 <acowley> shapr: same effect :)
16:11:31 * shapr grins
16:12:03 <ConfusedGirl> I'm just trying to fill it with a value to start with, I will probably then try to do a function for rowCount and columnCount :: (Matrix a) -> Int
16:12:09 <shapr> acowley: I'm hoping to get some inspiration from that robots talk, I want to generate Arduino code from Haskell.. sometime son
16:12:19 <shapr> hodapp is teaching me how to use Atom :-P
16:12:55 <mpickering> EvanR: Well think about what the type of an indexed version of mapM would be for example
16:12:56 <acowley> shapr: I showed use of copilot and SBV to generate Arduino code at the NYHUG last year
16:13:01 <acowley> shapr: It's on vimeo
16:13:07 <shapr> whoa, I so want that!
16:13:15 <shapr> acowley: is there demo code online somewhere?
16:13:22 <ConfusedGirl> mauris: is that what you were asking as far as the implementation?
16:13:31 <acowley> shapr: I have a new thing for Arduino code, but it's not out yet because it is just one part of an epic yak
16:13:31 * shapr digs through acowley's github repos
16:13:46 <shapr> what do I have to bribe you with to be a beta tester?
16:13:47 <acowley> shapr: I don't know if it's up
16:13:56 <acowley> shapr: Nobody requested it
16:14:04 <shapr> me me! I request it!
16:14:07 * shapr raises his hand
16:14:16 <EvanR> mpickering: wouldnt make sense, just like my loop combinator only makes sense when the beginning and ending states are equal
16:14:22 <acowley> shapr: Ugh, it's not up
16:14:31 <mauris> ConfusedGirl: yeah! ok -- if nothing's defined yet, i would redefine your Matrix type a bit
16:14:35 <acowley> shapr: Okay, I'll push it up, but it's almost certainly bitrotted
16:14:47 <shapr> acowley: I'll have time to check it out tomorrow evening!
16:14:53 * shapr hops excitedly
16:14:58 <acowley> shapr: A problem is that the C generation is fine, but I used ino as the Arduino build tool and ino is more or less moribund
16:15:14 <shapr> I'm willing to dig into that.
16:15:15 <acowley> shapr: I can't put the new thing up yet
16:15:28 <mauris> ConfusedGirl:  data Matrix = Mat { matrixSize :: (Int, Int), matrixIndex :: (Int, Int) -> a }
16:15:35 <acowley> But the old NYHUG stuff is at least a working example of copilot and SBV
16:15:43 <shapr> acowley: do want!
16:15:59 <EvanR> mpickering: so i guess an indexed monad library would have several operations that required basically non-indexed behavior
16:16:08 <ConfusedGirl> mauris: sorry I meant it has to be defined like I previously said newtype Matrix a = Mat ((Int,Int),(Int,Int) -> a)    because another file uses it. I am just trying to use the same matrix and learn how it works if that makes sense? sorry
16:16:08 <shapr> acowley: I'll ping you again soon about the new thing
16:16:14 * shapr wanders off to see Shakespeare
16:16:23 <mauris> ConfusedGirl: aha, ok, never mind then!
16:17:08 <mauris> ConfusedGirl: you could create a matrix like:  Mat (3,4) (\(i,j) -> 6)
16:17:19 <mauris> that's a 3x4 matrix containing all 6es
16:17:35 <mauris> err
16:17:46 <mauris> Mat ((3,4), (\(i,j) -> 6))
16:19:01 <ConfusedGirl> okay thank you!  what about finding the row count?
16:19:32 <ab9rf> floom
16:19:47 <mauris> ConfusedGirl: you can "pattern match" on matrices like so:
16:20:14 <mauris> rowCount (Mat ((i,j),f)) = ...
16:20:24 <acowley> shapr: https://github.com/acowley/NYHUG/tree/master/src/CopilotDemo
16:20:36 <ab9rf> how is Mat defined?  i missed it
16:20:40 <mauris> to access the dimensions (i,j) and the indexing function f
16:20:44 <mauris> newtype Matrix a = Mat ((Int,Int),(Int,Int) -> a)
16:21:08 <ab9rf> interesting
16:21:17 <mauris> (not a great use of newtype i guess)
16:21:19 <ab9rf> i don't see how the dimensions fit in there
16:22:05 <ConfusedGirl> can I use pattern matching to look up a value based on the position? without going out of bounds?
16:22:22 <livexchosenn> Hi
16:22:25 <ConfusedGirl> something like this maybe? (Matrix a) -> (Int, Int) -> a
16:22:36 <ab9rf> mauris: i think your parenthesis are in the wrong place in that newtype, but i might be wrong
16:22:43 * livexchosenn wants to learn about programming
16:23:07 <acowley> needs moar parens
16:23:26 <mauris> ab9rf: that's a pair of (a pair of ints) and a function
16:23:27 <ab9rf> don't go turning this into lisp!
16:23:41 <mauris> not a function from pairs of pairs to a (i read it that way at first)
16:23:41 <acowley> ConfusedGirl: What stops the caller from giving a pair of Ints that are out of bounds? If they do, what "a" should be returned?
16:23:47 * livexchosenn wants to learn about programming... Someone should help him out
16:23:50 <ab9rf> mauris: no, it's a function that takes a pair of pairs of ints
16:24:05 <acowley> It's not
16:24:08 <acowley> It needs more parens!
16:24:32 <ConfusedGirl> newtype Matrix a = Mat ((Int,Int),(Int,Int) -> a)
16:24:46 <acowley> It's a fancy syntax error all dressed up to look like a Matrix type
16:25:00 <acowley> newtype Matrix a = Mat (((Int,Int), (Int,Int)) -> a)
16:25:21 <livexchosenn> Me?
16:25:25 <mauris> ab9rf: nope, it isn't! i'm assuming the fst is the matrix's size (Int, Int), and the snd is an indexing function (Int, Int) -> a
16:25:38 <acowley> Ah!
16:25:47 <mauris> it looks very misleading, though
16:25:50 <ab9rf> mauris: well, you can do that if you like
16:25:54 <livexchosenn> terabit not fair
16:25:56 <ab9rf> :)
16:26:01 <acowley> livexchosens: Have you tried any of the introductory guides to Haskell out there?
16:26:10 <acowley> ?lyah
16:26:10 <lambdabot> Unknown command, try @list
16:26:19 <ab9rf> ah, you used a newtype :)
16:26:21 <ab9rf> why not a data?
16:26:22 <acowley> @lyah
16:26:22 <lambdabot> Unknown command, try @list
16:26:23 <mauris> but a 2D matrix does not associate values to quadruples of ints
16:26:26 <acowley> oy
16:26:30 <livexchosenn> acowley: nah
16:26:48 <mauris> ab9rf: it's from ConfusedGirl's course, i'm guessing, so she doesn't get to poke around at the definition
16:26:48 <ab9rf> mauris: yeah, i got the parenthetical nesting off
16:26:57 <ab9rf> mauris: or the fixity of , relative to ->
16:26:57 <acowley> livexchosenn: I believe there's also a #haskell-beginners channel
16:26:58 <mauris> but it does make much more sense being a data
16:27:10 <ab9rf> mauris: fairy nuff
16:27:17 <acowley> livexchosenn: bitemyapp has a guide with various learning tracks laid out
16:27:33 <acowley> livexchosenn: https://github.com/bitemyapp/learnhaskell
16:27:52 <livexchosenn> acowley: can't chat here... Mind leaving me your WhatsApp detail... So I can contact you?
16:28:26 <acowley> livexchosenn: I'm too old to know whatsup
16:28:42 <ab9rf> mauris: interesting approach to matrices :)
16:28:49 <bitemyapp> acowley: what would you rather Proxy be named?
16:29:14 <acowley> livexchosenn: and try out http://learnyouahaskell.com
16:30:50 <acowley> bitemyapp: I don't know :/
16:30:55 <livexchosenn> acowley: thanks
16:31:09 <acowley> bitemyapp: Maybe something derived from the Pipe name?
16:32:18 <bitemyapp> acowley: like what? ;_;
16:32:24 <acowley> bitemyapp: I'm open to suggestions and not unwilling to accept Proxy if it grows a crackerjack comment justifying the name :P
16:32:34 <bitemyapp> it will not
16:32:36 <acowley> bitemyapp: So, if it were me, I'd probably call it a Pipe
16:32:44 <acowley> bitemyapp: And name the data type something else
16:33:00 <bitemyapp> acowley: what would you name the sum type?
16:33:19 <acowley> bitemyapp: Heck the data type is a better fit for the Proxy name!
16:33:35 <bitemyapp> I really want to kill Proxy as a word dead here
16:33:37 <bitemyapp> it doesn't make sense to me.
16:33:38 <acowley> hah
16:33:44 <acowley> It's the go-between
16:33:53 <acowley> I call these things Mailboxes
16:34:04 <acowley> Or it could be a Hub
16:34:07 <acowley> Or a Nexus
16:34:11 <acowley> Or a Roundabout
16:34:21 <bitemyapp> MachineT m (Pipe ...) c   is a Mailbox?
16:34:26 <acowley> No
16:34:27 <bitemyapp> or the datatype is?
16:34:32 <acowley> the datatype
16:34:41 <acowley> It deals with messages
16:34:58 <acowley> and somehow mediates the connection between upstream and downstream
16:35:09 <acowley> and hopefully doesn't collide with Data.Proxy
16:35:25 <bitemyapp> I gave the suggestions to Yorick, good thinking.
16:35:36 <yorick> what
16:35:43 <bitemyapp> yorick: are you yoeight?
16:35:46 <yorick> no
16:35:51 <bitemyapp> yorick: sorry, n/m then.
16:36:03 <yorick> bitemyapp: actually you're the second person who asks me this in 2 weeks
16:36:27 <bitemyapp> well you kinda popped out of nowhere like when one opens a can of cat foo.
16:36:29 <bitemyapp> food*
16:36:44 <yorick> you said the magic word
16:36:52 <bitemyapp> yorick: sorry for botherin' ya :)
16:37:02 <yorick> it's fine, I should check out this yoeight guy
16:37:02 <acowley> "opening a can of cat foo" sounds like a bash tutorial
16:37:11 <acowley> You've got a lot in common
16:37:31 <acowley> Well... yo
16:37:45 <EvanR> yoleven
16:38:04 <acowley> That's what my stereo goes up to
16:38:33 <yorick> EvanR: yoleven is apparently a poker or something thing
16:38:47 <acowley> And my battery is dead
16:39:08 <yorick> EvanR: and it's also somebody's twitter handle already
16:39:52 <EvanR> its 11 on craps
16:40:08 <EvanR> @dice 2d6
16:40:08 <lambdabot> EvanR: 6+1 => 7
16:40:21 <EvanR> noice
16:49:37 * livexchosenn is outta here
16:55:59 <nick2938> Is there a newer version of RWH?
16:56:16 <nick2938> Thank http://book.realworldhaskell.org/ , I mean
16:56:21 <mniip> continuing my yestarday problem, using ghc-api, how do I convert a Term into a haskell value
16:56:32 <RchrdB> nick2938: I don't think so.
16:56:43 <nick2938> RchrdB: Would you still suggest reading the old version?
16:57:42 <RchrdB> nick2938: iirc it has in-line comments which you might want to pay attention to for caveats or anyone piping up about "this library changed slightly, you now use it like $that instead".
16:58:38 <RchrdB> nick2938: I haven't read much of it myself but I'd still recommend the bits that I have read.
16:59:34 <RchrdB> e.g. offhand I think RWH's chapter on parser combinators is about Parsec 2, but the one you're most likely to end up using is Parsec 3. However, it's the concepts that are the most challenging/neat bit rather than the exact invocations, so it's more or less fine.
16:59:54 <Gurkenglas> I run a .hs in ghci after having made a change before which the following didnt happen and make it execute main, and then it thinks for some seconds and then closes the ghci window
17:01:18 <Gurkenglas> lpaste doesn't respond, so here goes:
17:01:35 <Gurkenglas> http://pastebin.com/g10URgcS
17:02:03 <MagBo> Gurkenglas: psst... gist.github.com <> dpaste <> ...; pastebin is pure evil.
17:02:16 <Gurkenglas> What evil has pastebin done?
17:02:27 <geekosaur> lpaste is occasionally throwing can't reach backend errors, fwiw
17:02:43 <Gurkenglas> Yea, that's what it did
17:02:46 <geekosaur> if I retry then it works
17:02:50 <nick2938> RchrdB: Thanks
17:03:04 <geekosaur> come to think of it...
17:03:36 <geekosaur> chrisdone: (repeating) [18 01:01] <geekosaur> lpaste is occasionally throwing can't reach backend errors, fwiw
17:04:41 <geekosaur> feh, not here right now.
17:04:44 <geekosaur> oh well
17:06:16 <nick2938> RWH has exercises??
17:06:19 <nick2938> I'm so reading this
17:12:15 <ezrios> so I installed a bunch of packages into the global ghc package.conf.d
17:12:19 <ezrios> and I would now like to remove them all
17:12:23 <ezrios> what is the safest way of doing this
17:12:27 <ezrios> it's really screwing with my sandboxes now
17:13:19 <Gurkenglas> Soz for the afk, HPMOR updated. Have your lpaste http://lpaste.net/120671
17:13:46 <rui> Must be a dumb question but
17:15:08 <rui> What is this syntax? bla $ bloh { stuff1 = stuff2, stuff3 = stuff4}
17:15:20 <glguy> bloh { stuff1 = stuff2, stuff3 = stuff4}   is a record update
17:15:24 <Axman6> that's record update systax
17:15:42 <rui> Ahh, great, didn't know that one
17:15:44 <rui> Thanks!
17:15:44 <glguy> bla $ something    is applying bla and something to the ($) operator
17:15:52 <glguy> which is defined   f $ x = f x
17:15:58 <rui> glguy, yes, the confusion was on the second part, but
17:16:02 <SrPx> quick & dumb question, but ... system F is strong normalizing, Haskell is not. What exactly is the addition to system F that gave haskell its turing completeness ?
17:16:09 <rui> just in case I was confusing the precedences I wrote it all
17:16:46 <glguy> rui: the record update notation binds tightly, so:   f x { u = v }    parses as f (x { u = v } )   -- just fyi
17:18:00 <rui> glguy Nice. So the $ in my example wasn't necessary
17:18:00 <Gurkenglas> Ah, apparently ghci reaches somewhere between 1500 and 2000 MB RAM usage and shuts itself off without comment
17:21:08 <HeladoDeBrownie> SrPx, probably general recursion
17:22:08 <HeladoDeBrownie> SrPx, fix : (a → a) → a is not a usual theorem in any logic
17:22:10 <ezrios> what would the consequences be if I were to unregister all packages in my /usr/lib/ghc/package.conf.d
17:22:24 <ezrios> I'm getting sick of wrestling with cabal and the global system package database
17:23:18 <Gurkenglas> How can I do things with those histograms without running out of memory?
17:24:26 <SrPx> HeladoDeBrownie: but how can the type system accept general recursion if it is designed not to?
17:24:37 <Gurkenglas> (Honestly, I'm kind of perplexed it even takes up this much. The source files themselves weigh about 1.03 GB and all my program does to this stage is ~throwing away information
17:24:39 <Gurkenglas> *)
17:26:10 <HeladoDeBrownie> SrPx, why do you say it's designed not to?
17:28:34 <HeladoDeBrownie> SrPx, oh maybe i misunderstood; the *type system* does not contain general recursion. however, the value semantics do, as characterized, e.g., by fix.
17:32:03 <gregnwosu> ive got : getJson (ResponseJSON r) = B.concat $ ((fmap B.toStrict r)^..responseBody . atto stripJSONP )
17:32:25 <SrPx> HeladoDeBrownie: as far as my understanding goes, system F doesn't accept as well typed any term that contains general recursion ...
17:32:32 <gregnwosu> which strips my request and gets some embedded json out
17:32:44 <HeladoDeBrownie> SrPx: haskell does. so if you're correct, that would be one point of departure.
17:32:59 <gregnwosu> but now i want to parse the on the embedded json , can i continue to use the same lens?
17:33:39 <HeladoDeBrownie> SrPx, in other words, haskell *is* designed that way, even if system f is not.
17:35:46 <Gurkenglas> If I import Data.Map as M, it tells me that all my uses of Prelude.map become ambigious. How is this usually dealt with?
17:36:07 <gregnwosu> Gurkenglas: you need to qualify the import
17:36:07 <HeladoDeBrownie> Gurkenglas: import qualified Data.Map as M
17:36:42 <Cale> Also note that if you don't want to have to write M.Map in your types, you can add  import Data.Map (Map)  afterward as well
17:37:44 <EvanR> use fmap? ;)
17:38:03 <gregnwosu> EvanR: different map
17:38:46 <HeladoDeBrownie> map :: (a -> b) -> [a] -> [b] ; map = fmap
17:39:07 <EvanR> gregnwosu: Data.Map is an instance of Functor, so the specialized map ambiguities might be solveable by replacing all of the above with fmaps
17:39:16 <HeladoDeBrownie> it might actually be defined the other way around
17:40:30 <gregnwosu> EvanR: I think ones a data structure and the other is a function no?
17:40:50 <gregnwosu> so should be different because of capitalisation anyway
17:41:04 <HeladoDeBrownie> gregnwosu: EvanR is suggesting using fmap for both Prelude.map and Data.Map.map.
17:41:10 <EvanR> lowercase map, theres one in Data.Map and one is Prelude
17:41:23 <EvanR> im not really suggesting that i was sort of joking
17:41:23 <gregnwosu> ah ok
17:41:26 <EvanR> even though it would work
17:41:32 <gregnwosu> lol
17:41:39 <HeladoDeBrownie> i couldn't tell you were joking, and don't see why not to do that
17:43:16 <gregnwosu> i see, yes , its a rather ugly name clash
17:43:33 <sccrstud92> is catMaybes expressable in Foldable/Traverable? or is it something completely different?
17:43:51 <EvanR> gregnwosu: besides map, the basic names are reused in a few libraries, the standard way to deal with it is with a B M S L or whatever qualified import
17:44:04 <Zekka> @hoogle catMaybes
17:44:05 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
17:44:15 <HeladoDeBrownie> sccrstud92, at a glance, looks like Foldable should suffice
17:44:28 <gregnwosu> i tried to compile lambdabot and gave up
17:44:34 <Zekka> Oh, I misread you! My mistake
17:44:57 <Zekka> I thought you asked if it was in the module
17:44:58 <EvanR> sccrstud92: HeladoDeBrownie Foldable can get you from f (Maybe a) -> [a] but not f (Maybe a) -> f a
17:45:26 <HeladoDeBrownie> EvanR, oops, i assumed the former
17:45:58 <HeladoDeBrownie> i didn't notice the ambiguity in the question at first glance
17:46:41 <gregnwosu> EvanR: so why cant haskell infer which map you wish to use based on the type, i know this is probably a silly question
17:47:09 <HeladoDeBrownie> ooh, did someone bring up tdnr
17:47:30 <HeladoDeBrownie> there are proposals for that
17:47:37 <HeladoDeBrownie> see here for example https://ghc.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
17:48:20 <sccrstud92> i dont think map is a good example for that
17:48:35 <sccrstud92> because there is only 1 correct way to map per type, right?
17:48:35 <EvanR> gregnwosu: idris tries to do this kind of thing
17:48:47 <sccrstud92> thats why fmap is in a typeclass
17:49:21 <Zekka> sccrstud92: There can be more than one
17:49:27 <EvanR> gregnwosu: but really, the more things that are not errors, the less likely the compiler will catch something you did wrong
17:49:36 <Zekka> data Pair a = Pair a a -- you can map over just the left, just the right, or both
17:50:27 <sccrstud92> Zekka: i dont think thats true
17:50:40 <sccrstud92> Zekka: what if I did
17:50:43 <Zekka> sccrstud92: Why not? Aren't all three lawful per functor laws?
17:50:49 <n4x> that seems to have an unique functor instance
17:50:54 <sccrstud92> Zekka: map show (Pair 1 2)
17:50:59 <gregnwosu> EvanR: agreed and tdnr can only get you so far
17:51:01 <Zekka> Oh, wait, you're right!
17:51:10 <sccrstud92> Zekka: dat type change
17:51:15 <Zekka> Phooey!
17:52:19 <sccrstud92> so anyone else any idea on the catMaybes problem?
17:52:27 <n4x> Zekka: if you ha a function like "map :: (a -> a) -> Pair a -> Pair a", you'd be right :p
17:52:30 <sccrstud92> i dont like that its sort of special
17:52:54 <sccrstud92> if it was more polymorphic you could do catMAybes on sets too for example
17:53:14 <gregnwosu> EvanR: I guess a type can belong to more than one typeclass, and if they require the same instance functions it just get ambigous again
17:55:00 <dfeuer> THERE BE DRAAAAAAGONS.
17:55:11 <joeyh> I have a function :: StateT (MVector s Char) (ST s) ()  , and expect to have more, so I tried type M = forall s. StateT (MVector s Char) (ST s) .. but substituting in M () in type definition doesn't work. Is there some trick that lets this be done?
17:55:19 <joeyh> it works fine if I fix the s to RealWorld
17:56:50 <joeyh> hmm, I can use M s () instead, losing the forall
17:59:50 <rui> If I do cabal install something, how can I also build the haddock docs (with the source linked)?
18:00:15 <rui> cabal install something --haddock-hyperlink-source didn't work
18:00:29 <rui> or at least I don't know where the docs end up
18:01:13 <joeyh> rui: ~/.cabal/config has a haddockdir setting
18:01:25 <HeladoDeBrownie> sccrstud92, catMaybes is essentially a specialized filter and map. but not everything Foldable supports pruning elements while otherwise keeping the structure the same (trees spring to mind). i'm not sure what abstraction involves filter but that seems important.
18:01:44 <HeladoDeBrownie> (in other words, Foldable doesn't give you the filter power)
18:02:25 <meoblast001> hi. i'm having a bit of trifecta problems.... i gisted my code and put the issue in the description: https://gist.github.com/meoblast001/fcf7971995553f7cdaa0
18:02:55 <meoblast001> this is actually more parsers than trifecta
18:04:58 <csd_> Why does instance Functor Either not typecheck if you set fmap g (Left x) = Left (g x) ?
18:05:13 <csd_> I don't understand what ghc is telling me
18:05:14 <shachaf> csd_: Because fmap :: (a -> b) -> F a -> F b
18:05:28 <sccrstud92> F ~ Either x
18:05:28 <shachaf> csd_: If F = Either e, then fmap :: (a -> b) -> Either e a -> Either e b
18:05:42 <shachaf> csd_: So it always maps over the last argument.
18:05:45 <sccrstud92> so the e has to stay an e
18:06:47 <csd_> So if I understand correctly, if it becomes instance functor (Either a b), then it becomes polymorphic, which functor disallows?
18:08:55 <benzrf> wha
18:08:58 <HeladoDeBrownie> csd_: there are a couple things you're confusing there; for one, Functor instances are not concrete types like Either a b, they're things like Either a
18:09:05 * hackagebot network-attoparsec 0.9.2 - Utility functions for running a parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.9.2 (solatis)
18:09:16 <HeladoDeBrownie> csd_, if we look at the type of fmap
18:09:17 <HeladoDeBrownie> @type fmap
18:09:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:09:32 <HeladoDeBrownie> csd_, the f is the thing in the head of the instance. it must remain the same at all occurrences
18:09:51 <HeladoDeBrownie> csd_, so since the thing in the head would be Either a (or Either e, however you want to write it, same thing), we cannot touch a (or e)
18:10:14 <HeladoDeBrownie> erm, i should've committed to a type variable :P instance Functor (Either e) where …
18:10:20 <HeladoDeBrownie> we cannot touch e.
18:12:20 <csd_> HeladoDeBrownie: so the a (or e) has to remain consistent throughout the pattern matching
18:12:34 <HeladoDeBrownie> csd_, any variables that show up in the head, yes
18:13:07 <csd_> i'm not sure i understand your usage of head. i think of it in the context of a list
18:13:43 <HeladoDeBrownie> the head of the instance is the part i showed: instance Functor (Either e) where …
18:13:46 <HeladoDeBrownie> the … is the body
18:14:01 <csd_> ah
18:14:40 <HeladoDeBrownie> (which i have elided)
18:15:47 <csd_> ok i didn't realize that in the head that the `a` after Either represents a type (Left / Right)
18:16:16 <HeladoDeBrownie> i'm not sure what purpose the "(Left / Right)" part of what you just said is trying to serve.
18:16:30 <HeladoDeBrownie> but any variables that appear in the head of an instance are indeed type variables.
18:16:42 <mniip> in ghc-api, how can I attempt to unify a polymorphic Term with a monomorphic Type?
18:17:01 <csd_> i had thought that in instance Functor (Either a); that the `a` in either represented e.g. Left <error message>; rather than just Left
18:19:17 <HeladoDeBrownie> it doesn't represent either of those things.
18:19:27 <HeladoDeBrownie> but if you look at the definition of Either
18:19:34 <HeladoDeBrownie> data Either a b = Left a | Right b
18:19:46 <HeladoDeBrownie> then the first argument to Either is the type of the argument to Left.
18:21:04 <rui> joeyh thanks. however, no html docs in that folder
18:22:59 <csd_> HeladoDeBrownie: ok I get it now, thank you
18:39:06 * hackagebot logfloat 0.13.0.1 - Log-domain floating point numbers  http://hackage.haskell.org/package/logfloat-0.13.0.1 (WrenThornton)
18:39:49 <jle`> csd_: look at the type signature of fmap, and substitute (Either e) for f
18:39:52 <jle`> :t fmap
18:39:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:40:27 <jle`> fmap :: (a -> b) -> Either e a -> Either e b
18:41:27 <jle`> when we say instance Functor (Either e), we mean that "Either e is the `f`"
18:41:38 <jle`> so Either e is the thing you plug in for `f` up there
18:43:37 <bitemyapp> jle`: https://github.com/bitemyapp/learnhaskell/blob/master/dialogues.md#functor-for-reader
18:45:35 <jle`> hi
18:45:47 <jle`> :t fmap `asAppliedTo2` Right undefined
18:45:48 <lambdabot> (a -> b) -> Either a1 a -> Either a1 b
18:45:52 <jle`> hm
18:56:21 <jle`> i wonder if, instead of fmap _ (Left x) = Left x, fmap _ lx = unsafeCoerce lx is faster
18:57:17 <jle`> or more memory-efficient
18:57:51 <jle`> in a sufficiently unintelligent compiler, i would think so
18:58:21 <mniip> where could I get a hoogle database for ghc-api
18:59:14 <mniip> jle`, 'fmap _ (Left x) = Left x' and 'fmap _ lx = unsafeCoerce lx' are different things
18:59:41 <jle`> if they come after the appropriate fmap f (Right x) = Right (f x), are they?
18:59:44 <mniip> ah
18:59:44 <shachaf> jle`: In GHC the former will allocate a new Left and the latter won't
18:59:57 <mniip> fmap _ x@(Left _) = x
18:59:58 <jle`> that's what i'd imagine shachaf
19:00:09 <dramforever> yeah, exactly
19:00:09 <shachaf> mniip: Wrong type.
19:00:19 <mniip> is it?
19:00:24 <mniip> oh right
19:00:24 <dramforever> jle`: use that as-pattern
19:00:25 <mniip> I see
19:00:28 <jle`> ah yeah that's probably a clearer statement mniip.  fmap _ x@(Left _) = unsafeCoerce x
19:00:42 <jle`> mniip: x is (Either e a), but then result is supposed to be (Either e b)
19:01:10 <shachaf> But this is better fixed by improving the compiler, not writing unsafeCoerce.
19:01:12 <jle`> is the as-pattern result optimizable by ghc?
19:01:22 <shachaf> I wonder whether having it be the wrong type is ever a problem. Probably not for a parametric type like Either.
19:01:33 <mniip> I don't think unsafeCoerce :: Either e a -> Either e b is safe
19:01:41 <mniip> even over only Left's
19:01:42 <jle`> mniip: it is if you know you have a Left
19:01:42 <dramforever> jle`: It returns the original x
19:01:46 <dramforever> same pointer
19:01:46 <jle`> i'm trying to think of semantic differences
19:01:50 <shachaf> I have http://slbkbs.org/v.hs.txt from 2012 when I was complaining about this.
19:01:54 <jle`> if it would have any different semantics
19:02:01 <shachaf> unsafeCoerce has no semantics.
19:02:10 <jle`> i mean, the two fmap's have different semantics
19:02:11 <mniip> unsafeCoerce has a ton of semantics
19:02:11 <shachaf> If you use unsafeCoerce, you have to worry about operational differences.
19:02:13 <mniip> in GHC anyway
19:02:14 <jle`> oh i see
19:02:24 <jle`> unsafeCoerce says nothing about semantics
19:02:29 <mniip> yeah
19:02:31 <jle`> but whats bouts ghc
19:02:52 <jle`> i don't want to allocate an extra Left if i didn't have to
19:03:18 <jle`> is there any semantic difference to allocating a new identical Left (presumably with an identical in memory representation) than just pointing at the same one?
19:03:29 <shachaf> Is it identical in memory representation?
19:03:38 <solatis> hmmm, correct me if i'm wrong: if i put a cabal.config in my project's root, it is only used by cabal sandbox?
19:03:44 <jle`> in GHC?
19:03:51 <shachaf> The answer is probably yes in this case, but you should worry about it a bit.
19:03:54 <solatis> https://www.haskell.org/cabal/users-guide/installing-packages.html#sandboxes-basic-usage
19:04:00 <shachaf> Maybe it has type information for the GC or something?
19:04:05 <solatis> "Normally, the sandbox settings (such as optimisation level) are inherited from the main Cabal config file ($HOME/cabal/config). Sometimes, though, you need to change some settings specifically for a single sandbox. You can do this by creating a cabal.config file in the same directory with your cabal.sandbox.config (which was created by sandbox init). "
19:04:12 <jle`> i wouldn't be able to say anything meaningful about *haskell*, but for ghc, we could do some digging to get a real answer
19:04:14 <solatis> so cabal.config is only for sandboxes
19:04:22 <solatis> and cabal.sandbox.config is for... sandboxes?
19:05:03 <dcoutts_> solarus: no cabal.config is used whenever it's present
19:05:05 <mniip> http://hackage.haskell.org/package/ghc-prim-0.3.1.0/docs/GHC-Prim.html#v:unsafeCoerce-35-
19:05:07 <mniip> "Casting between two types that have the same runtime representation. One case is when the two types differ only in "phantom" type parameters, for example Ptr Int to Ptr Float, or [Int] to [Float] when the list is known to be empty. Also, a newtype of a type T has the same representation at runtime as T."
19:05:10 <jle`> if they do have no semantic differences in GHC then we might be able to have a hacky prelude and improve every single code that uses Either...forever...
19:05:10 <dcoutts_> solarus: not just sandboxes
19:05:15 <solatis> dcoutts_, ok
19:05:22 <monochrom> oh w00t, that's nice
19:05:27 <mniip> the Right part of Either counts as "phantom" in this case I beleive
19:05:47 <intl> Am I missing something or does Data.Set define some nonsensical functions?
19:05:47 <shachaf> jle`: Improve it by what?
19:05:55 <jle`> memory usage?
19:05:58 <shachaf> By how much?
19:06:17 <mniip> intl, elaborate?
19:06:20 <shachaf> I think this would be much better as an optimization made by the compiler than a hack like this.
19:06:30 <jle`> every usage of fmap?  but perhaps laziness comes into play here
19:06:35 <Cale> intl: Which functions are you referring to?
19:06:43 <jle`> yeah it would probably be more worthwhile to fix it on the compiler side
19:06:50 <intl> mniip: Cale: foldr for example
19:07:08 <jle`> because an occasion for a new Prelude source is the same occasion for a compiler update
19:07:19 <jle`> intl: heh heh
19:07:32 <jle`> assume Data.Set is actually a set of ordered elements
19:07:32 <mniip> how is it nonsensical
19:07:32 <Cale> intl: Well, you could do without foldr, just using toList instead with the list foldr
19:07:43 <mniip> toAscList*
19:07:45 <jle`> an actual mathematical set wouldn't have an order to foldr on
19:07:51 <jle`> nor an order to toAscList on
19:08:26 <monochrom> yes, the word we use in a data structure course is "ordered set". and "hashed set" for the one that requires hashing.
19:08:36 <Cale> intl: Why was it you thought foldr is nonsensical?
19:09:01 <intl> Cale: Pretty much what jle` said.
19:09:09 <jle`> it is nonsensical if Data.Set is supposed to represent a mathematical set, because "by paremetricity" you lose the ability to inspect the ordering
19:09:11 <monochrom> neither is plain "set" which only requires equality (which is dog slow computationally, but of course aesthetic mathematically)
19:09:17 <jle`> parametricity
19:09:25 <Cale> Well, Data.Set has almost no similarity whatsoever to ZF sets
19:09:27 <orzo> what does \& mean inside a string?
19:09:41 <mniip> orzo, chr 0
19:09:42 <jle`> yeah, it's not supposed to...if it was, it'd be nonsensical
19:09:43 <Cale> orzo: It's a separator
19:09:46 <mniip> wait no
19:09:50 <jle`> but i'm sure that there are much more nonsensical things than this
19:09:50 <mniip> \& is empty string
19:09:52 <jle`> heh
19:10:02 <orzo> hm, okay i guess
19:10:09 <jle`> Data.Set.OSet
19:10:21 <Cale> > "\SOH" == ['\SOH']
19:10:22 <lambdabot>  True
19:10:30 <Cale> > "\SO\&H" == ['\SO','H']
19:10:31 <lambdabot>  True
19:10:42 <Cale> ^^ it's basically for that :)
19:11:06 <mniip> not only
19:11:12 <monochrom> similarly, the mathematically idealistic would say that it is nonsensical for "filter (< 5) [1..]" to diverge.
19:11:15 <mniip> > "\1234" ++ "5"
19:11:17 <lambdabot>  "\1234\&5"
19:11:28 <Cale> right, and things like it
19:11:42 <jmcarthur> i like the way OCaml handles this. you can say   let fmap f = function Left _ as l -> l | Right x -> Right (f x)  and it will still be polymorphic enough. it type checks the 'l' as though it was being reconstructed, since it knows the structure now anyway
19:11:46 <monochrom> what is really nonsensical is the notion that Haskell is a computer algebra system and theorem prover
19:12:06 <jmcarthur> ^^ in reference to the conversation between jle` and shachaf earlier
19:12:46 <wz1000> monochrom: I like type Set a = a -> Bool
19:14:38 <Rotaerk> wz1000, what about: class Set a where isElement :: a -> Bool
19:14:41 <mniip> jle`, map f (x:xs) = f x:map f s; map _ xs = unsafeCoerce xs
19:14:41 <mniip> xD
19:14:45 <Rotaerk> err
19:15:06 <shachaf> [] and Nothing are unique anyway.
19:15:09 <shachaf> No need to allocate them.
19:15:20 <mniip> dang
19:15:23 <Rotaerk> isElementOf :: Set a -> a -> Bool
19:15:24 <monochrom> @quote unsafeCoerce
19:15:24 <lambdabot> dons says: [jcreigh] representation? So is [unsafeCoerce#] like casting raw pointers? [dons] yes. welcome to introductory C programming
19:16:29 <wz1000> Rotaerk: Wait, what?
19:16:35 <Rotaerk> nevermind
19:16:44 <Clint> z/win 23
19:16:48 <wz1000> Rotaerk: Set is a typeclass not a type constructor
19:16:58 <mniip> :t unsafeCoerce
19:16:59 <Rotaerk> yea I messed that up
19:16:59 <lambdabot> Not in scope: ‘unsafeCoerce’
19:17:01 <mniip> dang
19:17:16 <Rotaerk> class Set a s where isElementOf :: s a -> a -> Bool
19:17:30 <Rotaerk> asnotehusatnoehu
19:17:32 <Rotaerk> I give up
19:17:48 <mniip> class Set s were isElementOf :: s v -> v -> Bool
19:18:58 <mniip> then 'instance Set Set.Set where isElementOf = Set.member'
19:19:02 <wz1000> Wouldn't a collection be a better name for that?
19:19:08 <mniip> hmm
19:19:11 <mniip> flip Set.member
19:19:38 <mniip> wz1000, collection is too boring
19:19:46 <wz1000> Since there is no guarantee that s contains only one v
19:19:49 <mniip> class Conglomeration c
19:20:21 <Rotaerk> a collection being used as a set need not actually contain only one
19:20:34 <Rotaerk> it's just that when you're treating it as a set, you don't *care* if it has more than one
19:20:58 <wz1000> Good point
19:21:24 <Rotaerk> though, you'd probably want more than isElementOf; you'd want all the set operations
19:21:42 <Rotaerk> union :: s a -> s a -> s a
19:22:16 <wz1000> :t fmap (||)
19:22:16 <Rotaerk> at least some of these could have default implementations though...
19:22:17 <lambdabot> Functor f => f Bool -> f (Bool -> Bool)
19:23:01 <mniip> you only need 2 operations
19:23:24 <mniip> or not
19:23:34 <wz1000> :t liftM2 (||) (\x -> x == 'a') (\x -> x == 'b')
19:23:35 <lambdabot> Char -> Bool
19:23:40 <wz1000> :t liftM2 (||) (\x -> x == 'a') (\x -> x == 'b') 'a'
19:23:40 <lambdabot> Bool
19:23:45 <wz1000> > liftM2 (||) (\x -> x == 'a') (\x -> x == 'b') 'a'
19:23:46 <lambdabot>  True
19:23:49 <wz1000> > liftM2 (||) (\x -> x == 'a') (\x -> x == 'b') 'b'
19:23:50 <lambdabot>  True
19:23:53 <wz1000> > liftM2 (||) (\x -> x == 'a') (\x -> x == 'b') 'c'
19:23:54 <lambdabot>  False
19:24:13 <wz1000> Thats union.
19:24:35 <wz1000> intersection would be liftM2 (&&)
19:24:57 <Rotaerk> a set data structure would probably implement it differently though
19:25:01 <dramforever> > liftM2 (||) (== 'a') (== 'b') 'c'
19:25:02 <lambdabot>  False
19:25:07 <Rotaerk> for efficiency
19:25:16 <dramforever> wz1000: what about functor?
19:25:36 <wz1000> dramforever: What functor
19:25:39 <mniip> fmap f s = s . f
19:25:42 <mniip> or something
19:25:52 <dramforever> instance Functor Wz1000Set
19:26:19 <wz1000> My set is not a functor.
19:26:57 <wz1000> It does not contain anything.
19:30:16 <Rotaerk> hmm, traversal doesn't make sense for a set, I guess, but might for specific data structures used as sets
19:32:52 <mniip> wz1000, union = (join .) . (.) . (. (||)) . flip (.)
19:33:08 <dramforever> dot dot dot dot dot
19:33:13 * Rotaerk has a seizure.
19:33:34 <dramforever> (If you don't know, that was from the lens video by E. Kmett)
19:34:17 <wz1000> cartProd s t = \(a,b) -> s a && t b
19:34:18 <monochrom> oh wait, Haskell Weekly News has moved to Tuesdays!
19:34:53 <wz1000> That can probably be expressed better using some arrow combinators
19:35:20 <wz1000> @pl f s t (a,b) = s a && t b
19:35:20 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (&&)) .)
19:35:31 <mniip> so much better
19:35:53 <mniip> @pl \a b s t = s a && t b
19:35:54 <lambdabot> (line 1, column 10):
19:35:54 <lambdabot> unexpected "="
19:35:54 <lambdabot> expecting pattern or "->"
19:35:59 <mniip> @pl \a b s t -> s a && t b
19:35:59 <lambdabot> (. flip id) . flip . (((.) . (&&)) .) . flip id
19:36:17 <mniip> meh
19:39:26 <mniip> wz1000, ((uncurry .) . flip . (((.) . (&&)) .))
19:39:27 <mniip> didn't test
19:40:02 <Rotaerk> let's see how many nipples we can put into a function !
19:43:45 <EvanR> Rotaerk: hurry mardi gras is almost over
19:45:09 <Rotaerk> heh
19:48:21 <kevinmeredith> how does Haskell’s parser handle “foo \” bar”? I’m trying to write a parser for JSON String’s
19:48:51 <HeladoDeBrownie> kevinmeredith, that would be a syntax error; haskell does not recognize smart quotes.
19:48:59 <kevinmeredith> (here’s my full question, http://stackoverflow.com/questions/28575554/parser-for-json-string/28575583#28575583)
19:49:13 <EvanR> aeson is a really good json parser library
19:49:31 <kevinmeredith> ghci>"foo \" bar "
19:49:32 <kevinmeredith> "foo \" bar "
19:49:50 <EvanR> > "foo \" bar"
19:49:51 <lambdabot>  "foo \" bar"
19:50:00 <EvanR> aeson will do that correctly
19:50:13 <kevinmeredith> I’ll be sure to check it out. but I’m trying to write a parser for JSON
19:50:18 <kevinmeredith> but I’m stuck on parsing JSON Strings
19:50:28 <kevinmeredith> to support escaped quotes
19:50:59 <EvanR> if you do it char by char, then when you encounter a \ you need to check the next character to decide what to output
19:51:40 <EvanR> or the next 4 chars, for unicode entities
19:52:47 * EvanR squints at json.org ... only 4?
19:52:58 <kevinmeredith> *JsonParser> '\\' : '"' : []
19:52:59 <kevinmeredith> "\\\""
19:53:04 <kevinmeredith> that’s not the same as “\”” though
19:53:24 <EvanR> > "\\\""
19:53:25 <lambdabot>  "\\\""
19:53:36 <EvanR> > length "\\\""
19:53:37 <lambdabot>  2
19:53:58 <EvanR> dont be fooled by the show output
19:54:18 <kevinmeredith> "\\\"" == "\""
19:54:23 <kevinmeredith> > "\\\"" == "\""
19:54:24 <lambdabot>  False
19:54:49 <EvanR> \" is "\\\""
19:55:36 <dramforever> try putStrLn in ghci
19:55:37 <kevinmeredith> but, that output shows otherwise, no?
19:55:49 <dramforever> kevinmeredith: try putStrLn
19:56:03 <kevinmeredith> > putStrLn "foobar \" "
19:56:04 <lambdabot>  <IO ()>
19:56:12 <kevinmeredith> foobar "
19:56:13 <EvanR> foobar "
19:56:21 <dramforever> kevinmeredith: try it in your ghci
19:56:28 <dramforever> lambdabot won't do IO
19:56:37 <kevinmeredith> interesting
19:56:46 <EvanR> (then how can we see its answers!)
19:57:04 <dramforever> > launchMissles
19:57:05 <lambdabot>  Not in scope: ‘launchMissles’
19:57:08 <dramforever> heh
19:57:51 <dramforever> > writeFile "icantwritefiles" "foo foo foo bar bar" -- otherwise it's insecure
19:57:52 <lambdabot>  <IO ()>
19:58:04 <kevinmeredith> > length (‘\\' : ‘\”’ : []) == (length “\””)
19:58:05 <lambdabot>  <hint>:1:9: lexical error at character '\8216'
19:58:22 <EvanR> smart quotes
19:58:22 <HeladoDeBrownie> kevinmeredith, you're still using smart quotes
19:58:27 <dramforever> '‘'
19:58:32 <dramforever> > '‘'
19:58:33 <lambdabot>  '\8216'
19:58:51 <kevinmeredith> let me google “smart quote"
19:59:09 <kevinmeredith> that google search didnt help
19:59:31 <Clint> try using ASCII instead
19:59:37 <dramforever> kevinmeredith: you are using the wrong '
19:59:38 <HeladoDeBrownie> kevinmeredith, haskell uses ' and " only for quotes, not the other characters that also represent quotation marks, like the ones you're typing
19:59:52 <HeladoDeBrownie> kevinmeredith, maybe your client is correcting them automatically or something
20:00:02 <HeladoDeBrownie> "correcting"
20:00:08 <kevinmeredith> hmm - I’m on a mac - maybe?
20:00:22 <HeladoDeBrownie> kevinmeredith, if you can find an autocorrect setting in your client, turn it off, then try again
20:00:24 <dramforever> > “Chinese quotes also won't work”
20:00:25 <lambdabot>  <hint>:1:1: lexical error at character '\8220'
20:00:45 <dramforever> > "‘’"
20:00:46 <lambdabot>  "\8216\8217"
20:01:03 <bob_twinkles> OSX IRC clients do indeed seem to have a problem with inserting unicode characters instead of their ascii equivalents
20:01:06 <kevinmeredith> so this doesn’t make sense for trying to match (quotes followed by anything follwed by anything)?
20:01:10 <bob_twinkles> ... -> unicode elipsis as well
20:01:16 <kevinmeredith> ((char '"') *>  (zeroOrMore (alt parseEscapedQuotes (oneOrMore (notChar '"')))) <* (char '"'))
20:01:17 <EvanR> ...
20:01:23 <dramforever> by "Chinese quotes" I mean from my Chinese input method
20:01:47 <kevinmeredith> alt is the same as <|> FYI - the alternative
20:01:59 <dramforever> kevinmeredith: are you still having problems with escaping?
20:02:04 <HeladoDeBrownie> kevinmeredith, depends, how are those other parsers defined? and how do you mean "followed by anything" twice?
20:02:17 <kevinmeredith> well, the goal is to match a JSON string
20:02:27 <kevinmeredith> so “ \”foobar\” “ would be valid
20:02:39 <dramforever> my idea: try getPossiblyEscapedChar :: String -> Maybe (Char, String)
20:02:47 <dramforever> (or with some error handling)
20:03:03 <dramforever> return Nothing at end of string
20:03:06 <dramforever> and use:
20:03:09 <dramforever> :t unfoldl
20:03:10 <lambdabot>     Not in scope: ‘unfoldl’
20:03:10 <lambdabot>     Perhaps you meant one of these:
20:03:10 <lambdabot>       ‘Seq.unfoldl’ (imported from Data.Sequence),
20:03:14 <HeladoDeBrownie> kevinmeredith, show the full code for the parser in an lpaste
20:03:15 <dramforever> hmm
20:03:19 <dramforever> :t unfold
20:03:20 <lambdabot>     Not in scope: ‘unfold’
20:03:20 <lambdabot>     Perhaps you meant one of these:
20:03:20 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
20:03:23 <dramforever> hmm...
20:03:27 <dramforever> :t unfoldr
20:03:28 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:03:40 <HeladoDeBrownie> ack, i've got to go. later
20:03:43 <dramforever> that's probably wrong...who knows
20:03:51 <dramforever> Ignore that
20:04:01 <dramforever> kevinmeredith: yes, post the code
20:05:10 <kevinmeredith> https://github.com/kevinmeredith/json_parser/blob/master/JsonParser.hs
20:05:33 <kevinmeredith> https://github.com/kevinmeredith/json_parser/blob/master/JsonParser.hs#L20
20:06:14 <dramforever> kevinmeredith: You want to get that piece of code from L23 to 30 to work?
20:06:59 <csd_> Why when reading about functors do I often see them described using both containers and contexts as if they are different things? It seems like they are the same thing to me
20:07:00 <mniip> hmm
20:07:05 <csd_> E.g. "There are two fundamental ways to think about fmap. The first has already been mentioned: it takes two parameters, a function and a container, and applies the function “inside” the container, producing a new container. Alternately, we can think of fmap as applying a function to a value in a context (without altering the context)."
20:07:09 <mniip> Wz1000Set can't be a Functor
20:07:10 <dramforever> kevinmeredith: Oh I know the problem
20:07:10 <kevinmeredith> sorry pleaes refresh the page
20:07:13 <csd_> aren't those two sentences saying the same thing?
20:07:30 <solatis> grmbl, i'm getting "mallocPlainForeignPtrBytes: size must be >= 0" errors in a very specific use case i'm not able to reproduce in a small test case
20:07:37 <ril[away]> how would I write (\x y -> ((+) (constant + x) y)) in curried form?
20:07:40 <dramforever> oh that problem is gone after refreshing
20:07:52 <shachaf> ril[away]: What is curried form?
20:07:55 <dramforever> ril[away]: that's...already curried\
20:08:07 <ril[away]> I mean is there a way to do it without the lambda?
20:08:15 <dramforever> ril[away]: this:
20:08:21 <dramforever> @pl  (\x y -> ((+) (constant + x) y))
20:08:21 <lambdabot> (+) . (constant +)
20:08:30 <dramforever> or by hand:
20:09:04 <dramforever> yours = (\x y -> (+) (constant + x) y) {Removed extra parens}
20:09:09 <orzo> csd_: yeah, i don't know why people do that either
20:09:23 <dramforever> = (\x -> (+) (constant + x)) {eta expand}
20:09:25 <kevinmeredith> I’m going to log off, but if you have any thoughts for fixing this parser, could you please note on my commit (https://github.com/kevinmeredith/json_parser/commit/f22a516f682702182bb4e7ac918bccdc5d4ba172). otherwise I’ll stop back on this forum tomorrow. thanks!
20:09:32 <orzo> csd_: the difference is some subtle semantic notion i think
20:09:48 <dramforever> = (+) . (\x -> constant + x)
20:09:51 <orzo> csd_: for example, IO is not normally considered a container
20:09:55 <dramforever> = (+) . (constant +)
20:09:56 <orzo> but it is a Functor
20:10:08 <csd_> orzo: i suppose it's easier to understand the concept of a functor when you provide more than one metaphor for someone to latch onto
20:10:11 <dramforever> ril[away]: but...if it gets to complicated you might not want to do it
20:10:38 <EvanR> csd_: you can think of data types like Identity or Maybe as containers, but would you think of function types as containers?
20:11:11 <csd_> i do think of Maybe as a container, personally. i havent worked with Identity
20:11:27 <mniip> functions are containers obviously
20:11:29 <orzo> EvanR: you could think of them as a generalization of the concrete idea of container
20:11:39 <mniip> give it an argument to unpack the value
20:11:46 <EvanR> eh...
20:11:56 <mniip> I guess 'apply it to unpack the value' would be more proper
20:12:00 <EvanR> everythings a container then
20:12:25 <ril[away]> thanks!
20:12:27 <csd_> EvanR: or a context
20:12:54 <EvanR> neither one seems helpful to me when talking about Functor as a concept of its own
20:12:57 <orzo> the funtion type is a good example
20:13:24 <shachaf> Michael Abbott defined "container": http://www.cs.le.ac.uk/people/ma139/
20:13:28 <orzo> do you prefer to think in terms of category theory?
20:13:47 <dramforever> orzo: type Time = Double, type Signal a = Time -> a
20:13:54 <dramforever> obviously a container
20:13:59 <mniip> [07:10:53] <EvanR> everythings a container then
20:14:00 <EvanR> in the classic higher order function example of a sort algorithm that takes a comparison function as an argument, why would you think of the comparison function as a container?
20:14:01 <mniip> hm?
20:14:19 <EvanR> or a context
20:14:28 <dramforever> EvanR: Contains...comparison results
20:14:31 <EvanR> lol
20:14:41 <mniip> it contains a container containing comparison results
20:14:48 <EvanR> and the ls command line program contains directory listings
20:14:55 <mniip> nah
20:14:59 <daftbun> hi haskellers
20:15:05 <dramforever> daftbun: hi
20:15:05 <mniip> well yeah
20:15:16 * EvanR logs onto the MUD an puts bag in bag to crash the server
20:15:28 <csd_> haha
20:15:39 <mniip> though to 'unlock' ls you need something more than a directory name
20:15:48 <mniip> you need a real world
20:16:02 <EvanR> the container analogy isnt helpful beyond a certain point
20:16:13 <Clint> and sometimes it's the opposite of helpful
20:16:22 <mniip> well idunno
20:16:32 <csd_> The concept of an apple pie is a container that requires the universe to bake?
20:16:40 <mniip> IO being an abstract state over a real world makes perfect sense to me
20:16:49 <EvanR> but its not accurate
20:16:58 <mniip> depends
20:17:09 <EvanR> its only accurate when it is?
20:17:11 <MP2E> it's not accurate. It doesn't explain concurency for one
20:17:33 <mniip> well yeah
20:17:42 <Cale> also, it doesn't explain all the ways in which the real world can be observed to change independently of what the IO actions themselves are doing to it
20:18:00 <dramforever> daftbun: it's okay if you ask a question in the middle of a hot discussion
20:18:10 <mniip> you lose purity as soon as you create or split, or destroy a realworld state
20:18:32 <L8D> no. you just create a new world
20:18:36 <L8D> monads bitch
20:18:41 <mniip> yeah that's the problem
20:18:43 <mniip> you don't
20:18:49 <mniip> that's where the analogy fails
20:19:00 <L8D> because re-creating a world makes in unreal?
20:19:24 <mniip> because you can't join a world
20:19:27 <L8D> or are you referring to independent changes?
20:19:46 <Cale> Well, there's no type World which could possibly correctly predict the behaviour of all IO actions, even in principle.
20:20:15 <Cale> If you want to think of actions of type IO a as functions World -> (World, a)
20:20:22 <L8D> well... I think Idris nails IO effects pretty well
20:20:42 <L8D> but I guess I’m thinking of something completely different than you
20:21:17 <Cale> Like, even if you try to include the state of the rest of the entire observable universe, I don't think you could get a model like that to actually work
20:21:34 <orzo> the set of possible IO actions is finite, so surely there's a type
20:21:39 <L8D> Cale: but it’s theoretically possible, and that’s all that matters
20:21:48 <Cale> L8D: but *how*?
20:21:59 <Cale> That's exactly what I'm saying, it's not theoretically possible
20:22:07 <L8D> Cale: how is it theoretically possible? or how is that all that matters?
20:22:07 <EvanR> the way IO works, theres no way to model real life and make it referetially transparent
20:22:12 <L8D> ah
20:22:16 <mniip> you could define an IO action like
20:22:24 <L8D> are you referring to real life or to system IO?
20:22:25 <EvanR> if you hook up the IO program a quantum experiment, you wont get the same answers each time
20:22:27 <cmccann> Cale: that's why theres no IOT transformer. because a Nothing in "IOT Maybe" would destroy the universe.
20:22:38 <Rotaerk> lol
20:22:42 <Acecub> lol
20:23:05 <L8D> lol
20:23:09 <Cale> L8D: I'm referring to this mental model people talk about where you're supposed to think of IO a as being a newtype of World -> (World, a) for some type World that encodes the state of everything else in the universe.
20:23:21 <Cale> I don't think you can actually make a model like that work
20:23:27 <L8D> yeah I don’t think that’s a good mental model
20:23:31 <Acecub> yea that wouldn't work
20:23:34 <dramforever> newtype IOT m a = IO (m a)
20:23:36 <L8D> IO should represent things like FFI calls
20:23:42 <Cale> Like, even in principle, even if the values of type World are arbitrarily complicated.
20:23:57 <L8D> and so your program just generates a sequence of FFI calls and that’s it
20:24:06 <L8D> no world simulation
20:24:11 <EvanR> it works fine, for a time-dependent and ill-defined value of World that changes unpredictably
20:24:23 <Cale> EvanR: heh
20:24:23 <EvanR> and violates your invariants
20:25:04 <EvanR> L8D: really FFI could be its own thing
20:25:08 <mniip> L8D, that actually sounds fun
20:25:18 <wz1000> It also fails when concurrency is in the picture.
20:25:29 <L8D> mniip: I mean... that’s how Idris tries to model it
20:25:46 <Cale> IO could be some sort of free monad over a type of actions which describes FFI calls and a bunch of other I/O primitives
20:25:47 <L8D> mniip: because Idris needs to target multiple platforms from the get-go
20:26:00 <Acecub> anyone know of a good language for building a voip session pc-to-pc
20:26:09 <Cale> It also needs stuff like basic concurrency primitives, exception handling, and so on
20:26:10 <wz1000> L8D: But I like pretending to be god...
20:26:11 <EvanR> idris IO is the same as in ghc, conceptually
20:26:33 <L8D> mniip: in Idris, IO is just a wrapper around an FFI call representation IIRC
20:27:12 <L8D> I don’t know if Haskell can say the same though
20:27:27 <L8D> I think a lot of IO stuff is too tied to GHC and VM semantics
20:27:28 <EvanR> in either case its not visible to the programmer
20:27:49 <L8D> :s/GHC/compiler
20:27:56 <L8D> EvanR: yeah
20:28:15 <EvanR> but a RealWorld based model is visible, visibly wrong
20:28:19 <Cale> L8D: It would be a lot of work, and you'd probably actually manage to lose performance, but I think it'd be doable
20:28:45 <Cale> You wouldn't *just* have FFI stuff
20:28:53 <Cale> But a handful of other important things.
20:30:11 <Cale> The current way that GHC compiles IO code lets the later phases of compilation simplify the generated code in a way that doing some kind of runtime interpretation of a free monad probably couldn't achieve.
20:30:12 <L8D> GHC’s VM is too heavy IMO
20:30:37 <Cale> Why do you say that?
20:30:41 <L8D> the VM should just be used for evaluation stuff
20:30:48 <Cale> also, it's not really a VM?
20:30:56 <Cale> Are you talking about the runtime system?
20:30:57 <L8D> instead of being responsible for system calls and evaluation stuff
20:31:00 <L8D> Cale: yeah
20:31:17 <L8D> but I’m talking out of my ass and haven’t really dug into GHC enough
20:31:21 <dramforever> the rts also contains stuff like an IO manager
20:31:29 <jmcarthur> the GHC RTS is not really responsible for any more than most other RTSs i am familiar with
20:31:43 <Cale> Yeah, the RTS is all good stuff as far as I can tell, I don't think it has much in it which seems especially unnecessary
20:31:56 <jmcarthur> it does happen to provide a lot of interesting functionality, i guess, but i think it all makes sense to be there
20:32:14 <jmcarthur> stuff like STM, lightweight threads, stable names, etc.
20:32:22 <Cale> You could rewrite portions of it in Haskell perhaps?
20:32:39 <jmcarthur> most GHC primitives are in fact designed to be pretty darn minimal
20:33:10 <jmcarthur> that's why GHC doesn't have a primitive memoization function, for example. instead it offers several simpler primitives from which you can implement it (or other things)
20:33:14 <EvanR> L8D: the C rts in idris is probably not as advanced or performance as ghc
20:33:24 <EvanR> performant
20:33:29 <EvanR> yet!
20:33:37 <lpaste> mniip pasted “WzSet” at http://lpaste.net/120675
20:33:41 <mniip> wz1000 ^
20:33:46 <dfeuer> Anyone here in the D.C. area?
20:34:01 <dfeuer> Wrong channel.
20:35:24 <jmcarthur> i think the only big mistake in ghc's internal representation of IO was calling the state token RealWorld
20:35:27 <L8D> mniip: now do the stuff for Enum and Bounded to turn WzSets into Sets
20:35:36 <Cale> "Performant" is one of those neologisms that I wish didn't exist.
20:35:59 <jmcarthur> just calling it Token would have been fine and less misleading (as in making people believe it's a reasonable semantic model for IO...)
20:36:22 <EvanR> what is that state token for anyway?
20:36:47 <Cale> (sorry EvanR! :)
20:36:54 <jmcarthur> it's just a hack to make sure the ordering of operations doesn't get messed up, as far as i know
20:36:59 <jmcarthur> since for IO it matters
20:37:07 <mniip> ^
20:37:22 <mniip> State# RealWorld takes no space, but follows evaluation rules
20:37:34 <Cale> Yeah, the compiler knows it's 0 bytes wide, and doesn't actually pass anything around at runtime
20:37:37 <mniip> this is also why unsafeInterleaveIO works
20:38:00 <benzrf> night
20:38:10 <jmcarthur> it doesn't have a runtime representation, but it can still interfere with some optimizations
20:38:11 <wz1000> mniip: Nice
20:38:38 <orion> Hi, what's the difference between pattern matching f [x:xs] = ... and f (x:xs) = ... ?
20:38:39 <mniip> dang
20:38:41 <mniip> forgot about full
20:38:56 <mniip> 'inverse empty' does the same though
20:39:08 <Cale> orion: [x:xs] is a one element list whose sole element is a list starting with x and whose tail is xs
20:39:17 <EvanR> > (\[x:xs] -> 3) [[]]
20:39:18 <lambdabot>  *Exception: <interactive>:3:2-13: Non-exhaustive patterns in lambda
20:39:21 <Cale> (x:xs) is just a list whose first element is x and whose tail is xs
20:40:14 <mniip> orion, [x:xs] can be written like (x:xs):[]
20:40:21 <orzo> [x:xs] is like [[x,...]]
20:40:35 <Cale> > (\[x:xs] -> (x,xs)) [[1,2,3]]
20:40:37 <lambdabot>  (1,[2,3])
20:40:43 <Cale> > (\(x:xs) -> (x,xs)) [[1,2,3]]
20:40:44 <lambdabot>  ([1,2,3],[])
20:40:49 <mniip> orzo, patterns totally work backwards
20:40:57 <wz1000> mniip: You can also have toList :: Enumerable a => WzSet a -> [a]
20:41:03 <orzo> i know
20:41:04 <mniip> > let x = 'h'; xs = "ello" in [x:xs]
20:41:05 <Cale> > [1:[2,3]]
20:41:06 <lambdabot>  ["hello"]
20:41:07 <lambdabot>  [[1,2,3]]
20:41:23 <Cale> > (1:[2,3])
20:41:25 <lambdabot>  [1,2,3]
20:41:44 <orion> Cale / mniip: Awesome, thanks
20:43:15 <mniip> wz1000, (`filter` enumerate)
20:43:48 <mniip> that's pretty lame though
20:43:59 <mniip> the Enumerable type I mean
20:44:15 <orion> And, the difference between [x, xs] = ... and [x:xs] = ... is that the former will only pull the first two elements from the list, where as the other implies heads and tails, right?
20:44:25 <wz1000> mniip: Why?
20:45:15 <mniip> wz1000, I'd rather implement fromList
20:45:43 <mniip> orion, make sure you are familiar with what : does
20:46:15 <mniip> wz1000, I'm severily bored and no one here knows ghc-api anyway, so got any other fancy problems?
20:46:27 <Cale> orion: [x,xs] will only match a list with exactly two elements
20:46:37 <Cale> orion: and will misleadingly name them x and xs
20:46:51 <Cale> orion: xs is usually to be thought of as "plural"
20:47:14 <wz1000> @pl \xs a -> any (== a) xs
20:47:14 <lambdabot> flip (any . (==))
20:47:17 <Cale> (so it's usually a list of elements of whatever type x is, by convention)
20:47:24 <wz1000> mniip: ^^
20:47:59 <mniip> where's that from
20:48:04 <Cale> > [1,2]
20:48:05 <lambdabot>  [1,2]
20:48:16 <wz1000> mniip: fromList
20:48:19 <Cale> > let [x,y] = [1,2] in 10 * x + y
20:48:20 <lambdabot>  12
20:48:42 <Cale> orion: Make sense?
20:49:05 <mniip> wz1000, I was thinking foldr insert empty
20:49:08 <orion> Cale: What happens if you write: [a, b] = f -- and f returns a list of three elements?
20:49:17 <Cale> orion: pattern match failure
20:49:20 <Cale> (at runtime)
20:49:25 <orion> Cale: And death to the application?
20:49:28 <Cale> yep
20:49:36 <orion> So morbid.
20:49:36 <wz1000> mniip: Thats neater
20:49:38 <Cale> So, usually you want to match lists using case expressions
20:49:45 <orion> Alright, thank you. :)
20:49:47 <Cale> because you can handle multiple options that way
20:49:53 <ezrios> my global /usr/lib/ghc/package.conf.d is busted
20:49:56 <ezrios> how can I resolve this?
20:50:09 <ezrios> I decided it would be a good idea to force unregister time-1.4.2
20:50:15 <mniip> > let x@True = False in x
20:50:16 <lambdabot>  *Exception: <interactive>:3:5-18: Irrefutable pattern failed for pattern x@G...
20:50:21 <mniip> orion, ^ this is what happens
20:50:37 <Cale> > let [x,y] = [1,2,3] in x + y
20:50:39 <lambdabot>  *Exception: <interactive>:3:5-19: Irrefutable pattern failed for pattern [x, y]
20:50:55 <Cale> > let (x:y:xs) = [1,2,3] in x + y
20:50:56 <lambdabot>  3
20:51:08 <Cale> > let (x:y:xs) = [1] in x + y
20:51:09 <lambdabot>  *Exception: <interactive>:3:5-18: Irrefutable pattern failed for pattern (x ...
20:51:21 <Cale> > let (x:y:xs) = [1] in 5
20:51:22 <lambdabot>  5
20:51:33 <mniip> that's laziness
20:51:36 <orion> I See.
20:52:05 <Cale> Well, yeah, the pattern match in case of pattern bindings like this is deferred until you actually use any of the variables that get bouund
20:52:07 <Cale> bound*
20:52:13 <mniip> I wonder what's the simplest datatype that can generate a patter match failure
20:52:13 <orion> I appreciate your help.
20:52:16 <mniip> Bool?
20:52:23 <Cale> Yeah, Bool
20:52:50 <EvanR> Void
20:52:55 <EvanR> wahaha
20:52:59 <dramforever> let 1 = 2 in 3
20:53:03 <ezrios> ugh
20:53:03 <mniip> actually
20:53:04 <dramforever> > let 1 = 2 in 3
20:53:06 <lambdabot>  3
20:53:06 <mniip> it's not Bool
20:53:07 <ezrios> now I truly know the meaning of cabal hell
20:53:14 <dramforever> hmm...
20:53:21 <L8D> > let 1 = 2 in 1
20:53:22 <lambdabot>  1
20:53:28 <dramforever> > case 1 of 2 -> 3
20:53:30 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
20:53:36 <dramforever> hmmmm
20:54:01 <dramforever> whoa let and case are not equivalent in this case!
20:54:11 <Cale> mniip: Well, there are not many types simpler than Bool, and () and Void can't generate pattern match failures.
20:54:43 <mniip> > let x | False = undefined in x
20:54:45 <lambdabot>  *Exception: <interactive>:3:5-25: Non-exhaustive patterns in function x
20:54:58 <dramforever> oh guards...
20:54:58 <Cale> Oh, well, guards, yeah
20:55:08 <Cale> But guards just desugar into case on Bool :P
20:55:13 <mniip> no?
20:55:31 <mniip> I'd say they're closer to case on (x, Bool)
20:55:54 <mniip> no
20:56:02 <mniip> it's actually not close
20:56:12 <EvanR> you dont need the variable
20:56:21 <Cale> All the pattern matches eventually get de-nested as well, so that you're only matching on one constructor at a time
20:56:32 <Axman6> > let x@1 = 1 in x
20:56:34 <lambdabot>  1
20:56:37 <Axman6> > let x@1 = 2 in x
20:56:38 <lambdabot>  *Exception: <interactive>:3:5-11: Irrefutable pattern failed for pattern x@1
20:57:04 <Cale> > let 0 = 1 in 0
20:57:06 <lambdabot>  0
20:57:22 <mniip> I think I broke GHC
20:57:30 <mniip> > let x @ _ | False = fix id in x
20:57:32 <lambdabot>  *Exception: <interactive>:3:5-26: Non-exhaustive guards in
20:57:41 <mniip> guards in what?
20:57:44 <EvanR> x Falso
20:58:10 <dramforever> non exhaustive guards, since _ matches
20:58:18 <dramforever> so go into guards
20:58:19 <Cale> oh, that is amusing!
20:58:21 <dramforever> see False, fail
20:58:25 <dramforever> no more guards
20:58:31 <Cale> I thought it was just lambdabot cutting the message off, but no!
20:58:33 <dramforever> Non-exhaustive!
20:59:11 <dramforever> Cale: no
20:59:17 <dramforever> doesn't even show in GHCi
20:59:22 <dramforever> whoa
20:59:57 <dramforever> mniip: whoa
21:00:37 <Cale> the fix id is unsurprisingly non-essential
21:00:43 <Cale> You can put anything there, like ()
21:00:57 <dramforever> Cale: nothing after "in "
21:01:10 <Cale> It does print a newline
21:01:17 <dramforever> yes
21:01:28 <dramforever> let me see other cases
21:02:10 <bob_twinkles> I think that makes sense, since _ is basically nothing
21:02:15 <Cale> It also doesn't matter that the pattern match is against a wildcard
21:02:27 <bob_twinkles> so you're binding x to nothing and then asking ghci to print it
21:02:36 <Cale> let x @ (v:vs) | False = [1,2,3] in x
21:02:40 <Cale> does the same thing
21:02:54 <Cale> It's an honest bug in GHC
21:02:58 <dramforever> Cale: wait that's a bug
21:03:27 <Cale> bob_twinkles: The error message is supposed to be longer
21:03:27 <dramforever> without @_ it says "function x"
21:03:36 <Cale> bob_twinkles: It's just getting cut off for some reason
21:03:59 <Cale> Yeah, and "function" is also wrong
21:04:00 <Cale> lol
21:04:13 <mniip> btw I found a neat trick
21:04:26 <mniip> @let argType f = let z = f z `seq` z in z
21:04:27 <Cale> ghci> let x | False = [1,2,3] in x
21:04:27 <Cale> *** Exception: <interactive>:12:5-23: Non-exhaustive patterns in function x
21:04:28 <Cale> ghci> let (x:xs) | False = [1,2,3] in x
21:04:28 <Cale> *** Exception: <interactive>:13:5-28: Non-exhaustive guards in
21:04:28 <lambdabot>  Defined.
21:04:47 <mniip> :t argType (\x -> x <*> id)
21:04:48 <lambdabot> a -> a -> b
21:04:52 <EvanR> x is a function
21:04:55 <mniip> deduces a function's a rgument
21:05:10 <EvanR> or is it
21:05:11 <Cale> EvanR: no
21:05:20 <Cale> EvanR: It definitely has list type there
21:05:26 <glguy> :t asAppliedTo
21:05:27 <lambdabot> (a -> b) -> a -> a -> b
21:05:30 <EvanR> the hell does let x | False = do
21:05:36 <bob_twinkles> oh, I see
21:05:48 <Cale> EvanR: It fails to match, and induces an exception when x is used
21:06:06 <Cale> EvanR: the problem is that the exception has the wrong message, and in many cases is cut off
21:08:13 <Cale> btw, one really cool use for a guard like that is that you can stick a Debug.Trace.trace onto the False, and then have the real definition on the following line
21:08:23 <Cale> It makes it easy to comment out the trace
21:08:34 <bananagram> @src asAppliedTo
21:08:34 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:09:21 <Cale> It's actually a bit funny that it doesn't have that one
21:10:15 <Cale> That's been locally defined in lambdabot for a long time
21:10:28 <Cale> :t asAppliedTo
21:10:28 <lambdabot> (a -> b) -> a -> a -> b
21:11:07 <Cale> I'm pretty sure it's just const
21:11:51 <Cale> :t map `asAppliedTo` cos
21:11:52 <lambdabot> Floating b => (b -> b) -> [b] -> [b]
21:12:50 <Cale> > (map `asAppliedTo` cos) (*2) [1..10]
21:12:52 <lambdabot>  [2.0,4.0,6.0,8.0,10.0,12.0,14.0,16.0,18.0,20.0]
21:13:01 <mniip> so I'm digging into this issue
21:13:20 <t4nk532> Hi all
21:13:24 <mniip> Foo.x = (\ _ -> Control.Exception.Base.nonExhaustiveGuardsError @ () "b.hs:2:1-18|") GHC.Prim.realWorld#
21:13:31 <t4nk532> Im trying to implement GroupBy with a foldl
21:13:33 <t4nk532> this is what I got
21:13:34 <t4nk532> http://lpaste.net/120676
21:13:55 <Cale> does it have to be with foldl?
21:13:57 <mniip> at the desugarer step, it already misses the debug information for the exception
21:13:58 <t4nk532> it successfully groups the last elements that form a group
21:14:17 <t4nk532> I wanted it to be a foldl because I want to learn it better
21:14:38 <t4nk532> groupBy' (\x -> \y -> x == y) [1,1,1,2,2,3,3,3]   >> [[3,3,3]]
21:14:43 <t4nk532> thats what I get when I run it
21:15:25 <mniip> that's a weird way to write a lambda
21:15:34 <Cale> Not that weird
21:15:41 <Cale> but less terse than it could be :)
21:15:44 <mniip> sure, sometimes it makes sense
21:15:58 <mniip> fully applied vs non-fully applied optimisations
21:16:09 <Cale> t4nk532: You can just write (\x y -> ...) in case you didn't know :)
21:16:22 <t4nk532> oh sweet thx
21:16:22 <mniip> you can just write (==)
21:16:32 <Cale> Well, that too!
21:17:00 <mniip> x == y is prety much sugar for (==) x y
21:17:07 <lifter> can't you just "group"
21:17:14 <Cale> The thing about groupBy is you're going to have a really hard time matching the semantics of ordinary groupBy with any foldr or foldl based solution, I think.
21:17:14 <lifter> instead of "groupBy?
21:17:16 <mniip> lifter, that's not "interessting"
21:17:22 <Cale> lifter: That's his own implementation
21:17:29 <Cale> Not the library one
21:17:36 <lifter> ok
21:17:52 <t4nk532> this is a Real World Haskell Problem I am trying to do.
21:18:01 <Cale> Does it say to use foldl?
21:18:10 <t4nk532> it says to use a fold
21:18:14 <Cale> hmm
21:18:17 <t4nk532> i just wanted to try foldl this time
21:18:19 <mniip> hmm
21:18:24 <Cale> I think recursively using span or break is more natural
21:18:38 <mniip> it would be a great pun if someone made a book called realWorld# Haskell
21:18:43 <mniip> talking about the dirty bits
21:18:47 <Cale> brb
21:19:12 <ezrios> so I broke my global ghc-pkg database (the one in /usr/lib/ghc-7.8.4/package.conf.d) by unregistering time by --force
21:19:14 <ezrios> how can I fix this?
21:19:28 <ezrios> apparently time is quite heavily depended upon (by Cabal, unix, among others)
21:20:25 <geekosaur> I think your best bet is reinstall whateber package you got it from
21:20:36 <geekosaur> (presumably an OS package given /usr/lib)
21:21:00 <ezrios> geekosaur: I'm on Gentoo, you think re-installing ghc might do it?
21:21:28 <ezrios> I don't recall ever installing a dev-haskell/time package or anything like this
21:21:38 <ezrios> nor does one exist
21:22:37 <geekosaur> Data.Time is a bootlib according to https://downloads.haskell.org/~ghc/latest/docs/html/libraries/index.html
21:22:43 <geekosaur> so yes
21:22:56 <ezrios> nice, thanks
21:23:25 <ezrios> compile all the things! ._.
21:26:19 <mniip> ezrios, >all the things
21:26:30 <mniip> do you even gentoo bruh
21:26:38 <mniip> compile only things you are going to USE ;)
21:28:35 <ezrios> mniip: don't forget to -funroll-loops
21:29:03 * mniip eats more rice
21:29:12 <ezrios> hahaha
21:29:47 <dramforever> ???
21:29:54 <dramforever> where's the joke
21:30:03 <dramforever> I mean, "eats more rice"\
21:30:10 <dramforever> how ?
21:30:52 <ezrios> dramforever: as in, ricing
21:31:23 <glguy> http://funroll-loops.teurasporsaat.org/
21:31:40 <ezrios> I need to get off this distro though ;_;
21:31:44 <dramforever> okay
21:31:44 <glguy> I think the original is since offline
21:32:33 <t4nk532> I figured it out! brodies.
21:33:04 <mniip> ezrios, but why
21:33:40 <ezrios> mniip: compiling is lame :<
21:34:00 <ezrios> and gentoo is high maintenance
21:34:15 <ezrios> but I also don't feel comfortable moving to another distro D;
21:34:40 <EvanR> ezrios: want to forget all that, use slackware ;)
21:34:57 <EvanR> distro doesnt tell you a damn thing to do
21:35:12 <EvanR> be as up to date or as behind as you want
21:35:21 <ezrios> egads
21:35:35 <EvanR> i recommend behind
21:36:35 <bob_twinkles> or use arch where you can be up to date and not have to wait ages for everything to compile =D
21:36:39 <EvanR> out of gentoo arch and slackware it was my best experience
21:37:10 <bob_twinkles> just read archlinux.org before you update or pacman might eat itself
21:38:10 <ezrios> EvanR: what's wrong with arch?
21:38:15 <EvanR> off topic!
21:38:20 <ezrios> I heard the package manager leaves something to be desired
21:38:22 <ezrios> truth
21:40:10 <Cale> t4nk532: oh, cool, I figured it out too, here's my solution:
21:41:10 <Cale> > foldl (\acc x gs -> case gs of [] -> acc [[x]]; ((y:ys):gs') -> if x == y then acc ((x:y:ys):gs') else acc ([x]:(y:ys):gs')) id [1,1,1,2,2,3,3,3] []
21:41:12 <lambdabot>  [[1,1,1],[2,2],[3,3,3]]
21:41:42 <Cale> The idea is just to accumulate a function which passes along the "current state" list of groups
21:42:11 <Cale> This still kind of has the wrong semantics, since it's sort of comparing things from the end
21:42:26 <Cale> (not to mention it won't work on infinite lists)
21:43:20 <Cale> But for finite lists, and conditions which happen to be equivalence relations, it'll do the same thing as groupBy (I specialised to (==) there)
22:09:23 <gamegoblin> How expensive is converting a Word64 to an Int? fromIntegral? coerce?
22:09:39 <Rotaerk> 5$
22:09:54 <Cale> gamegoblin: Well, Int is going to be signed
22:09:55 <gamegoblin> Way too expensive
22:10:00 <gamegoblin> I can only do $3.50
22:10:09 <orzo> i expect it costs nothing on 64bit ghc
22:10:42 <orzo> well, maybe a lazy thunk if you don't seq it
22:10:50 <orzo> hm
22:11:02 <gamegoblin> It’s a strict field
22:11:18 <Cale> uhhhh
22:11:30 <Cale> If everything is monomorphic, it might be free
22:11:40 <gamegoblin> And I’m on 64 bit ghc
22:11:43 <Cale> yeah
22:12:46 <dramforever> hmmm
22:13:02 <dramforever> it calls word2Int#
22:14:00 <dramforever> gamegoblin: given data A = A !Word64
22:14:16 <dramforever> and func :: A -> Int and func (A x) = fromIntegral x
22:14:33 <dramforever> when compiled with -O2 and -ddump-simpl,
22:14:50 <dramforever> Main.func =
22:14:50 <dramforever>   \ (ds_dnc :: Main.A) ->
22:14:50 <dramforever>     case ds_dnc of _ { Main.A x_alv ->
22:14:50 <dramforever>     case x_alv of _ { GHC.Word.W64# x#_s1p2 ->
22:14:53 <dramforever>     GHC.Types.I# (GHC.Prim.word2Int# x#_s1p2)
22:14:56 <dramforever>     }
22:14:58 <dramforever>     }
22:15:03 <dramforever>  
22:15:08 <dramforever> ouch
22:15:11 <dramforever> sorry if too many lines
22:19:09 * hackagebot attoparsec 0.12.1.3 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.12.1.3 (BryanOSullivan)
22:21:03 <someone972> Hello, I'm new to haskell and am having trouble with a very basic function. My google-fu is failing me here, so maybe one of you can help.
22:22:14 <someone972> Function is:  isStartChar = isAlpha c || c == '_'
22:22:44 <shachaf> You are missing a c. isStartChar c = ...
22:22:57 <someone972> Oh, right, typo. It has the c in my code
22:23:47 <someone972> What's happening is when I have the c == '_' on the end, it's continually matching "" (empty string) for some reason.
22:24:40 <Rotaerk> what is continually matching ""
22:25:27 <someone972> Ah, right. It's in a lexer which is consumer characters. I used to have isAlpha in the guard, which worked fine
22:25:59 <someone972> But changing it to isStartChar makes it infinitely loop consuming ""
22:26:14 <orzo> the problem is not in the code that you shared
22:27:03 <someone972> My main question is why is my 'isStartChar' function acting differently from isAlpha, when all it should be doing is accepting letters and underscore
22:27:10 <someone972> Is it elsewhere in the code?
22:27:26 <Hijiri> my guess is it's somewhere else in the code
22:27:26 <orzo> it acts differently in exactly the way you told it to, it returns True for the '_' character
22:28:09 <fryguybob> Does anyone have a suggestion for a higher performance random number generator.  I just noticed that StdGen goes through Integer to make random Ints.
22:29:05 <orzo> search hackage
22:29:29 <orzo> seems like most of the random number generators call themselves "high performance"
22:29:30 <someone972> What I mean by act differently is that with just isAlpha, it reaches the end of the input and terminates. But adding the '_' part causes it to loop forever instead of stopping, when it should just be a drop-in replacement
22:29:59 <orzo> is this a small amount code?
22:30:08 <orzo> why don't you just paste it at a pastebin?
22:30:16 <orzo> http://lpaste.net/
22:30:18 <someone972> I might be able to trim it down to a minimal example
22:30:45 <orzo> there's some logic error
22:30:47 <orzo> in your code
22:30:55 <orzo> but there's no way for us to guess what it is from what you've told us
22:32:18 <someone972> Ok, I'll trim it down and see if it still happens. It's good to know that it's not in the function though, that clears things up
22:34:09 * hackagebot lowgl 0.3.1.1 - Basic gl wrapper and reference  http://hackage.haskell.org/package/lowgl-0.3.1.1 (evanrinehart)
22:35:05 <someone972> Here's a minimal example that exhibits the problem I'm having
22:35:06 <someone972> http://lpaste.net/120679
22:35:16 <jle`> orzo: how can you run your function on an empty string....doesn't it take Char?
22:35:26 <jle`> i mean someone972
22:35:55 <someone972> What line?
22:35:59 <orzo> he has a loop that depends on the char line
22:36:05 <orzo> the char function
22:36:34 <jle`> al
22:36:35 <jle`> ah
22:39:21 <mniip> is it possible to convert a Data.Typeable into a Type
22:39:36 <mniip> or something similar for translating host types into interpreted ones
22:40:02 <EvanR> Typeable is runtime and Types are not
22:40:24 <mniip> pretty sure Type's are runtime
22:40:34 <EvanR> i hope not
22:40:51 <mmachenry> mniip: Nah.
22:40:58 <EvanR> that would gunk up the works
22:41:12 <mniip> mmachenry, "Nah"?
22:41:24 <mmachenry> mniip: Types aren't runtime.
22:42:49 <someone972> I figured out my problem. Turns out I forgot to change the span function in lexId to accept '_', so it was returning a span with just "" instead of consuming the _
22:42:50 <EvanR> the idea is that types help you write the code, but they dont help the computer run the code
22:43:17 <EvanR> except stuff stuff like typeable
22:43:22 <EvanR> except for*
22:44:16 <HeladoDeBrownie> what does Typeable end up getting used for anyway?
22:44:19 <shachaf> All the cat's are out of the bag.
22:44:45 <HeladoDeBrownie> the `cat`s are out of the bash
22:45:05 <EvanR> CATS: All your base are belong to us.
22:45:12 <mniip> EvanR, yeah but what about type-checking
22:45:24 <EvanR> type checking happens before runtime
22:45:37 <mniip> we are talking about ghc-api right?
22:45:47 <EvanR> no :S
22:50:17 * vhictour says hello
22:50:45 <ezrios> is it possible to get the current POSIX time in milliseconds?
22:51:02 <ezrios> I'm looking at getCurrentTime from Data.Time.Clock but I think it's in seconds
22:51:12 <EvanR> :t getCurrentTime
22:51:13 <lambdabot> Not in scope: ‘getCurrentTime’
22:51:20 <ezrios> getCurrentTime :: IO UTCTime
22:51:22 <glguy> Prelude Data.Time.Clock.POSIX> getPOSIXTime
22:51:22 <glguy> 1424242224.94794s
22:51:30 <vhictour> Who has a good knowledge on hacking?
22:51:52 <glguy> vhictour: You're welcome to ask your Haskell question.
22:52:01 <Axman6> like 1337 h4x0ring?
22:52:08 <EvanR> ezrios: UTCTime is a fractional numeric type
22:52:38 <c_wraith> ie, multiply by 1000
22:53:15 <EvanR> im wrong
22:53:18 <ezrios> EvanR: is it? I didn't see an instance anywhere
22:53:21 <dramforever> Hi
22:53:33 <EvanR> ezrios: POSIXTime is.
22:53:35 <dramforever> a question: in the docs of Data.ByteString.Lazy\
22:53:46 <dramforever> it says "Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to hGet."
22:53:46 <Rotaerk> I know how to hack; I can type over nine thousand characters per minute
22:54:54 <ezrios> okies, thanks all
22:54:55 <dramforever> can anyone clarify "on Windows and with Haskell implementation other than GHC"? for example, which of the following platforms works correctly? : win + ghc, win + hugs, linux + ghc, linux + hugs
22:55:03 <ezrios> vhictour: go read a book
22:55:08 <mniip> vhictour, C# (indexCharOffAddr# nullAddr# 0#)
22:55:49 <c_wraith> dramforever: ((not windows) or (not ghc)) -> not work correctly
22:56:08 <c_wraith> dramforever: err, I messed that up.  go me. :)
22:56:21 <dramforever> retry
22:56:29 <EvanR> ezrios: i randomly found this diagram i made on draw.io which maps how to get from where to where in Data.Time http://ibin.co/1s3BobDytpAW
22:56:31 <c_wraith> dramforever: (windows or (not ghc)) -> not correct
22:57:13 <mniip> EvanR, there should be a similar diagram for ghc-api
22:57:18 <ezrios> EvanR: superb, Data.Time is always confusing as hell to me
22:57:19 <EvanR> hexagons are the additive group which serves as that types different space
22:57:28 <EvanR> or whatever
22:57:34 <ezrios> not a category theorist
22:57:37 <ezrios> sorry :<
22:57:40 <ezrios> or an algebraist
22:57:58 <dramforever> in order to be sure, \
22:58:02 <EvanR> you can subtract two day numbers, or UTCTimes, but you cant add them
22:58:03 * dramforever is going to read the code
22:58:11 <EvanR> thats all
22:58:17 <orzo> do the different shapes of the nodes in teh diagram mean something?
22:58:45 <orzo> non time values are hexagons?
22:59:04 <EvanR> hexagons are what you get if you subtract two values of the circle type
22:59:25 <Rotaerk> .. wat
22:59:37 <EvanR> Day - Day = Integer
22:59:40 <EvanR> Day + Integer = Day
22:59:45 <EvanR> etc
22:59:48 <c_wraith> ezrios: just remember that Data.Time is different from every other time library because it doesn't include the operations that are broken in every other time library.
22:59:57 <dramforever> What the hell: https://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-IO-Handle-Text.html#hGetBufNonBlocking
23:00:15 <orzo> which ops are those?
23:02:09 <dramforever> I give up. Anyone here has a windows box with ghc and has time to help me test??
23:06:40 <EvanR> orzo: for example the one where a DateTime walks into a bar and someone adds 3 months to it to get another DateTime
23:07:44 <EvanR> or the one where you have a Date (an actual date not disguised Timestamp) and you add 6 years to get another date
23:09:10 <EvanR> or the highly unusual, add two DateTimes together because they are just milliseconds since 1970
23:09:25 <EvanR> before UTC even existed
23:13:26 * livexchosenn is outta here
23:13:34 <mniip> so I'm trying to cvObtainTerm a polymorphic HValue into a monomorphic type
23:14:23 <mniip> the resulting Term reports the type "GHC.Types.Int", however the value, when unsafeCoerce'd into an Int gives garbage
23:14:42 <EvanR> what are you doing?
23:15:14 <mniip> EvanR, on what layer
23:15:29 <EvanR> big picture
23:15:44 <mniip> a project that makes use of dynamic code loading
23:17:03 <mniip> EvanR, the fact that ghc-api is only semi-documented also doesn't help
23:18:17 <EvanR> the first thing that came up was System.Eval. you looked at this and what was wrong with it?
23:20:28 <mniip> that has no reloading support
23:20:39 <mniip> also it looks like it can only execute expressions
23:23:47 <EvanR> theres this
23:23:49 <EvanR> reload :: Module -> Symbol -> IO (LoadStatus a)
23:23:59 <EvanR> and theres some code in there, dunno if it works
23:25:23 <mniip> so right now I'm suck with a problem of transferring a possibly polymorphic value from the guest module into the host program
23:25:34 <mniip> I bet this is a simple task, and I'm missing something obvious
23:25:38 <EvanR> polymorphic value?
23:25:46 <mniip> yeah?
23:26:00 <EvanR> what does that mean, dynamically typed?
23:26:16 <EvanR> values are some value no matter what
23:27:57 <mniip> EvanR, a value with a polymorphic type?
23:28:27 <orzo> are you using some sort of plugin system?
23:28:30 <EvanR> a concrete value doesnt have a polymorphic type
23:28:35 <mniip> like show, or 1, or fix id
23:29:04 <mniip> EvanR, define concrete value
23:29:05 <EvanR> and the docs seem to suggest this is the case in the dynload system
23:30:47 <EvanR> when you use something like 1, then at runtime this will end up being an Int or a Double in a box, not both
23:31:25 <mniip> at runtime yes
23:31:35 <mniip> in the typecheker it's still polymorphic
23:31:38 <EvanR> which is when the plugin loads
23:31:45 <mniip> no runtime is after it loads
23:32:12 <EvanR> well after it loads you will get a concrete value
23:32:18 <mniip> also not really
23:32:20 <mniip> I mean
23:32:28 <mniip> you can export non-concrete values from modules right?
23:32:33 <EvanR> the type system is gone at that point
23:32:48 <mniip> we are talking about ghc-api right?
23:32:52 <EvanR> which explains why this package is relying so heavily on Dynamic / Typeable
23:33:26 <dramforever> quick question: what's the name of the function with type MonadPlus m => Maybe a -> m a
23:33:37 <ezrios> @hoogle Maybe a -> m a
23:33:40 <lambdabot> Data.Monoid First :: Maybe a -> First a
23:33:40 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
23:33:40 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
23:33:47 <dramforever> none of these...
23:33:49 <ezrios> hm
23:35:26 <EvanR> mniip: i guess if youre making something like ghci, you may be dealing with haskell code before it is compiled, and so you are juggling ASTs and typereps anyway, so in this case nevermind its a different kind of plugin than i was thinking of
23:35:41 <mniip> not ghci
23:35:51 <mniip> but you're close that I have to deal with code before it's ompiled
23:35:53 <mniip> compiled
23:35:56 <mniip> no AST's though
23:36:05 <dramforever> ezrios: I'll use maybe mzero return for now
23:39:50 <mrkkrp> I have a state monad, its state is data type defined in record style. Is it normal to write boilerplate 'set' and 'get' functions to set and get every field of the record? Like: getX = get >>= return . fieldX, and setX value = modify (\e -> e { fieldX = value}) ... Is there better way?
23:40:36 <jle`> mrkkrp: this is one problem that lens attempts to solve
23:40:38 <jle`> and does so pretty well
23:40:42 <dramforever> but...
23:40:52 <lpaste> mniip pasted “No title” at http://lpaste.net/120681
23:40:56 <dramforever> I dislike lens, because it is just too much in one package
23:41:03 <mniip> EvanR, this is what my code looks like right now ^
23:41:30 <jle`> you don't need lens to be able to do this then
23:41:37 <jle`> er well, the lens package
23:41:52 <jle`> you can write "lenses" using normal types, like functions and functors
23:41:58 <jle`> and then they give you free setters/getters in State
23:42:16 <EvanR> mniip: not surprised that unsafeCoerce is giving you garbage
23:42:22 <jle`> basically just implement the parts of lens that you need
23:42:44 <EvanR> mniip: you think you are operating on code before it is being compiled/running?
23:43:00 <EvanR> in that case why would unsafeCoerce be necessary, much less work
23:43:17 <mrkkrp> I was thinking about something like myvalue <- fieldX <$> get
23:43:28 <mniip> because GHC api only offers an Any-like interface?
23:43:31 <mniip> called HValue?
23:44:09 <mniip> I tried adding some foo like '(et, _) <- typeKind True "GHC.Types.Int"' and then 'liftIO $ cvObtainTerm s maxBound True et h'
23:44:19 <jle`> mrkkrp: yeah, you can do that too.
23:44:44 <zRecursive> :t liftIO
23:44:45 <lambdabot> MonadIO m => IO a -> m a
23:45:09 <mniip> that returns a Suspension (what's a suspension?) with type "GHC.Types.Int" but with HValue still being garbage
23:45:57 <mniip> Suspension {ctype = Fun, ty = <GHC.Types.Int>, val = <<HValue>>, bound_to = Nothing}
23:46:46 <EvanR> mniip: shouldnt there be some kind of in-band conversion interface to convert these values without using unsafeCoerce
23:47:10 <mniip> I'm surprised too
23:47:36 <mniip> although your idea does make sens
23:47:37 <mniip> e
23:48:20 <mniip> that it's already monomorphic
23:49:17 <mniip> the 't' Id though
23:50:29 <ezrios> hnnnnng
23:50:43 <ezrios> time is confusing as hell ._.
23:50:51 <ezrios> all this conversion
23:51:36 <mniip> EvanR, when I get the "test" value from the list of Module's TyThings, it reports type  forall a. GHC.Num.Num a => a
23:51:46 <EvanR> ezrios: im redrawing that diagram, which itself pretty confusing now i that i look at it
23:52:01 <Axman6> EvanR: time is a very confusing and difficult topic
23:52:04 <Axman6> uh, ezrios
23:52:11 <EvanR> ezrios: using that library, it really helps if you know what you really want out of it. theres no "just give me time dammit" function
23:52:33 <ezrios> I don't understand the difference between a DiffTime and a NominalDiffTime
23:52:45 <EvanR> such functions are easy to design wrong, and give people ok-looking at misleading results
23:52:47 <mniip> one accounts for leap seconds and another doesn't
23:52:55 <ezrios> ._.
23:52:57 <mniip> or so I think from the diagram
23:53:11 <ezrios> maybe I should just deal with ints
23:53:21 <EvanR> yes, technically, NominalDiffTime is the difference between two UTCTimes, and DiffTime is the difference between two AbsoluteTimes
23:53:22 <mniip> why not represent time as Int8
23:53:27 <EvanR> TLDR just use NominalDiffTime
23:53:40 <mniip> no
23:53:43 <ezrios> mniip: I am leaning in that direction
23:53:45 <mniip> represent time with Bool
23:53:48 <ezrios> this library seems very heavyweight for my purposes
23:54:00 <HeladoDeBrownie> should i be concerned that parsec has no instance (Monad m) => Stream ByteString m Word8 but has one for Char instead of Word8? http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec.html#t:Stream
23:54:00 <ezrios> data Time = Time { isEndOfUniverse :: Bool }
23:54:36 <EvanR> thats whats great about haskell, it forces you to stop and consider your ways
23:54:44 <ezrios> EvanR: is it possible to construct a NominalDiffTime?
23:54:49 <ezrios> I am trying to express an interval of time
23:54:54 <HeladoDeBrownie> hrm, i guess the conversion Word8 to Char isn't lossy at least…
23:54:54 <ezrios> so I tried to use a DiffTime
23:54:59 <EvanR> ezrios: yes, its a Num
23:55:06 <ezrios> ah
23:55:33 <EvanR> well, also its Fractional
23:55:41 <EvanR> so 3.1456 is a NominalDiffTime
23:55:45 <Axman6> HeladoDeBrownie: it looks like you're trying to parse binary data, would you like some help?
23:55:51 <Axman6> </clippy>
23:55:53 <acetoline> the people who designed haskell were genuines
23:56:05 <mniip> data Universe = Void Void | Universe Any
23:56:08 <ezrios> hallelujah it typechecks
23:56:15 <HeladoDeBrownie> Axman6, sure
23:56:26 <Axman6> HeladoDeBrownie: what're you trying to do?
23:56:38 <mniip> HeladoDeBrownie, have you seen the Binary typeclass?
23:56:55 <HeladoDeBrownie> Axman6, reading mud commands from raw bytes.
23:57:17 <Axman6> parsec is best for parsing textual data; if you need to work with binary formats, attoparsec is a much better option
23:57:29 <AfC> unless you want useful error messages
23:57:30 <HeladoDeBrownie> Axman6, okay, will take a look at that, thanks
23:57:53 <HeladoDeBrownie> mniip, no, why is it pertinent?
23:58:01 <Axman6> AfC: it's binary data, it either works or it's wrong, duh :P
23:58:17 <AfC> Axman6: silly me :)
23:58:40 <mniip> HeladoDeBrownie, http://hackage.haskell.org/package/binary-0.7.3.0/docs/Data-Binary.html
23:58:42 <Axman6> the Binary type class is for serialising haskell data types, not really for parsing binary data. it's somewhat equivalent to Show and Read
23:58:50 <mniip> true
23:59:02 <mniip> Binary is more about writing something you can yourself read
23:59:10 <mniip> not reading something someone else wrote
23:59:32 <Axman6> I'm hoping dcoutts' work on using CBOR for serialisation comes to fruition
