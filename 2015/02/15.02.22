00:00:00 <lambdabot> [a] -> Maybe (a, a)
00:00:14 <shachaf> mniip: You can prove that without talking about fmap.
00:00:23 <wagle>   let adjmat = map ((\[a, b] -> (read a, read b)) . words) gg :: [(Int, Int)]
00:00:24 <mniip> shachaf, yeah I don't see a way to
00:00:37 <mniip> I asked for advice not long ago and got no reply :/
00:00:39 <shachaf> Does it help to know that there's a way?
00:00:41 <wagle> meh
00:00:46 <mniip> shachaf, not really
00:00:51 <shachaf> I would start from the right side and go to the left side.
00:01:09 <shachaf> There's pretty much one law to apply at any point.
00:01:26 <shachaf> But there's a lot of simplifying to do.
00:03:18 <mniip> I don't see it .-.
00:04:11 <shachaf> Start with the thing on the right. Add parentheses to make it clear what's being applied to what. Look for laws that match the pattern.
00:04:13 * hackagebot template-haskell-util 0.1.0.1 - Some utilities for template Haskell.  http://hackage.haskell.org/package/template-haskell-util-0.1.0.1 (songzh)
00:05:52 <mniip> shachaf, I get it I have to used the homomorphism law at least once
00:05:57 <mniip> but I don't know where
00:06:21 <shachaf> What's the first step?
00:06:22 <mniip> ohh
00:06:27 <shachaf> The laws are a really strong guide here.
00:10:16 <lpaste> mniip revised “pure f <*> x = pure (flip ($)) <*> x <*> pure f”: “No title” at http://lpaste.net/3296066836205928448
00:10:22 <mniip> better
00:12:04 <shachaf> Well, there are errors, but you have the idea.
00:14:36 <mniip> shachaf, errors?
00:15:56 <shachaf> Try it in ghci.
00:18:57 <mniip> ah
00:19:08 <mniip> I wrote (. ($ f))
00:19:15 <mniip> should've written ((.) ($ f))
00:19:27 <funfunctor> EvanR: i'm trying to liftIO $ getCurrentTime into my StateT monad but I get No instance for (Num (TimeStamp -> TimeStamp)) for +
00:19:57 <EvanR> you must be using that expression with +
00:20:02 <EvanR> somehow
00:20:32 <EvanR> youre trying to add a function to something, which you cant do*
00:20:46 <wagle> how do you invoke Map.! as an infix?
00:20:57 <Lokathor> jle`, https://github.com/Strifepad/StrifeServer/blob/master/src/Strife/Server.hs#L68 is how i resolved my earlier issue, if you care to examine it still
00:21:13 <wagle> oh odd
00:21:16 <ski> wagle : `theMap Map.! theKey'
00:21:47 <funfunctor> EvanR: the action is just updateTime :: NullDevice () and updateTime = do { s <- NullDevice $ gets currentStamp; c <- liftIO $ getCurrentTime; elapsed <- diffUTCTime c s; mods s4 elapsed }
00:22:01 <ski> @type (Data.Map.!)
00:22:03 <lambdabot> Ord k => M.Map k a -> k -> a
00:22:16 <wagle> thanks (that was the only other way to do it, it turned out
00:22:19 <EvanR> funfunctor: theres no + there so thats not what the error is talking about
00:22:34 <funfunctor> odd
00:22:44 <EvanR> look at the line number
00:23:29 <wagle> ski: i tried `Map.!`
00:24:16 <Unhammer> in hxt, how do I duplicate a node? tried http://codepad.org/9HcSFqjz but don't know how to get the attributes over to my dupes (and without "requiring" attributes)
00:24:54 <funfunctor> fixed that
00:26:19 <ski>   theKey `Data.Map.member` theMap
00:27:05 <ski> wagle : it's an infix operator
00:27:34 <wagle> ski: we are agreeing
00:27:46 <ski> yes
00:29:05 <Procian> This is a stupid idea, but I want to see if I can make a typeclass which sort of generalises function application, and has two instances: normal functions and some "urelement" which basically wraps integers and performs some binary operation on them.
00:29:55 <Procian> So far I have a class Ap f a b with a method "ap", and two instances. But what I really want is for the type system to prefer the Int instance over the function instance, and instantiate everything to Int where possible.
00:30:25 <Procian> http://lpaste.net/120956
00:33:13 <mniip> edwardk, lenses are like burritos! which is also why I shouldn't write yet another tutorial on optics :v
00:34:05 <edwardk> lenses are like lenses. easy analogy is easy.
00:35:13 <Lokathor> the description that helped me the most was "a lens is like a path to a location within a structure"
00:35:31 <omefire> Hi all, I need help loading ghc into ghci. I am following this link : https://mail.haskell.org/pipermail/glasgow-haskell-users/2006-October/011336.html
00:35:42 <mniip> edwardk, referring to the monad tutorial fallacy
00:35:51 <edwardk> mniip: sure
00:36:06 <wagle> "a monad is just a fallacy"?
00:36:23 <wagle> (as opposed to a burrito)
00:36:23 <mniip> I'm very far from sure that everyone can understand optics in a way that I have disasembled them in my head
00:36:42 <edwardk> a monad is just a ... thing that has return and (>>=) and three particular laws governing their operation ... in the category of endofunctors, whats the problem?
00:36:59 <omefire> However, doing that ends up throwing an error for me : " Module Packages does not export 'pprPackagesSimple' "
00:37:04 <Lokathor> you were good until you used a greek word at the end!
00:37:22 <EvanR> yeah speak english
00:37:28 <Lokathor> omefire, my initial thought is that perhaps ghc has changed quite a bit since 2006
00:38:28 <omefire> Lokathor: yes, I realize. but that procedure is successful in loading the module 'HscTypes' which is located in the same folder as module 'Packages' that is not loading correctly.
00:38:40 <mniip> edwardk, I think of monads as of a way to chain packers, but whatever boats your float
00:39:01 <edwardk> Procian: ExtendedDefaultRules can help a _little_ bit, but only in very weird circumstances. the only way i know how to do it is to bolt a spurious constraint in that also adds a Show/Eq/Num/Integral, etc. constraint into the mix so that extended defaulting can fire
00:39:18 <EvanR> mniip: a way to compose functions.. yes
00:39:31 <EvanR> :t (<=<)
00:39:31 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
00:39:33 <cmccann> mniip: monads are like bad analogies, they're slippery when wet
00:39:36 <edwardk> Procian: we abused this approach for ghc live at one point to get it to do defaulting for user-entered code, but its very sad
00:39:37 <omefire> Lokathor: so, I don't understand why it wouldn't load certain modules and I'm not really that familiar with ghci to be honest.
00:39:51 <xnil____> meh, >>= and =<< and return are all that matters
00:39:51 <Lokathor> "a monad threads your state for you somehow" is the idea i've been operating under for a while now
00:40:07 <wagle> is there an O(1) ish version of Data.Map?
00:40:19 <mniip> wagle, O(1) for which operation
00:40:20 <EvanR> wagle: impastable
00:40:30 <wagle> mniip: lookup
00:40:32 <xnil____> wagle: yes, i can't remember what it's called though
00:40:46 <Procian> edwardk: Cool. I'll take a look. I just want it to work in this very particular case, with just these two instances (we're doing this sort of overloaded defaulting in a special case and very simple non-polymorphic language, but I want to know if Haskell can do it already)
00:40:56 <xnil____> Data.Maps are balanced binary trees, you want an O(1) hashmap
00:40:57 <EvanR> that data structure has a very elegant implementation, but the margin is too small for me to include it
00:41:14 <EvanR> xnil____: which isnt really O(1)
00:41:20 <mniip> Lokathor, that works if your only monad is the main function
00:41:23 <cmccann> tries and hashtables have O(k) lookup where k is key size
00:41:29 <edwardk> Procian: my best advice is 'find another way', because what you want won't work well
00:41:29 <xnil____> ahem
00:41:31 <xnil____> not a hashtable
00:41:33 <xnil____> whats the word
00:41:38 <mniip> hashmap?
00:41:39 <EvanR> a finite set ;)
00:41:45 <xnil____> hang on
00:41:47 <mniip> a function?
00:42:01 <Lokathor> mniip, it seems to be a servicable notion for Maybe and List as well
00:42:08 <edwardk> wagle: 'Array' =)
00:42:11 <omefire> does anyone here hack on ghc ?
00:42:26 <Procian> edwardk: Yeah, I'm not intending to use it. It's mostly there for "related work" in a paper.
00:42:34 <mniip> Lokathor, hmm?
00:42:45 <edwardk> omefire: a few. there is also #ghc for ghc-specific internal issues
00:42:58 <wagle> edwardk: might go that route
00:43:17 <mniip> Lokathor, I fail to see relation between concatMap and what you have said
00:43:31 <omefire> edwardk: I'm on there as well but it's almost dead. :)
00:43:35 <edwardk> oh, i just noticed you already posted there
00:43:35 <wagle> i wanted to have sparseness
00:43:36 <lf94> How do I use https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Fixed.html ?
00:43:44 <wagle> maybe
00:43:45 <edwardk> yeah, its quiet at this time of night.
00:43:47 <lf94> I've tried: let a = MkFixed 2
00:43:50 <lf94> But doesn't work
00:43:51 <rieper> hello, how would I calculate in haskell searching for all combinations of x, y in 500 = 30x + 50y?
00:43:56 <xnil____3> wagle: http://stackoverflow.com/questions/18908639/why-are-haskell-maps-implemented-as-balanced-binary-trees-instead-of-traditional#18908851
00:43:56 <mniip> edwardk, 11 am here
00:44:21 <omefire> edwardk: I'm trying to load ghc into ghci, but running into some issues
00:44:25 <edwardk> omefire: its almost 4am here stateside, and its, what, ~9am around ghc hq? so this is a bit of a lull
00:44:37 <wagle> xnil____3: thanks!
00:44:43 <xnil____3> no problem
00:44:55 <omefire> edwardk: thanks, I now understand why there's no one over there.
00:45:03 <edwardk> omefire: i never tried using the ghc package interactively from ghci, sadly
00:45:24 <lf94> Guys why is it so hard to create a simple fixed decimal
00:45:38 <lf94> Prelude Data.Fixed> let a = Data.Fixed.MkFixed 2
00:45:40 <omefire> edwardk: I'm trying to understand what other haskell devs use to step through large codebases and understand them
00:45:49 <EvanR> lf94: Centi is an instance of Num
00:45:49 <diginet> what purpose do closures serve in a language without mutable state?
00:45:53 <EvanR> > 123 :: Centi
00:45:54 <lambdabot>  123.00
00:46:03 <Lokathor> mniip, i don't even recall concatMap that well other than "that's a thing that exists"
00:46:09 <edwardk> omefire: i tend to just browse github repositories ;)
00:46:27 <mniip> Lokathor, literally (concat .) . map
00:46:35 <EvanR> lf94: what number did you think a would end up being? ;)
00:46:45 <lf94> EvanR: 2?! XD
00:46:48 <EvanR> oh
00:46:49 <Lokathor> mniip, yeah but, how did that get into things?
00:46:55 <EvanR> lf94: well just put 2 then
00:46:59 <omefire> edwardk: I'm finding some difficulties with that approach now. I want to be able to step through stuff one line at a time. :)
00:47:03 <xnil____3> wagle: http://hackage.haskell.org/package/hashtables
00:47:04 <lf94> EvanR: but what you put is what I wanted
00:47:10 <EvanR> lf94: 123?
00:47:10 <lf94> EvanR: I don't understand the instance
00:47:13 <lf94> ya
00:47:16 <lf94> 123.00
00:47:16 <EvanR> then put 123
00:47:20 <EvanR> or 123.00
00:47:27 <lf94> So other types implement Fixed?
00:47:48 <xnil____3> wagle: also Data.Hashtable may be worth looking at
00:47:50 <lf94> no...
00:47:57 <funfunctor> EvanR: is there any way to do arithmetic with NominalDiffTime like multiply it with a double (my symbol rate) and store that
00:48:00 <lf94> type Centi uses Fixed
00:48:01 <wagle> xnil____3: going to try pure functional first, just to see it crash and burn in temporal complexity
00:48:08 <funfunctor> EvanR: its not a instance of Integral
00:48:11 <EvanR> lf94: right
00:48:14 <edwardk> omefire: i think chrisdone has some fancy code for showing all the types inside a source file that might be useful. i confess i'm a creature from a different age. i don't really use any tooling support other than out-of-the-box vim.
00:48:34 <xnil____3> wagle: lol, have fun
00:48:46 <EvanR> funfunctor: multiplication requires both operands to be the same type, so you need to convert one to the other. use realToFrac
00:48:49 <xnil____3> wagle: how big is your dataset?
00:48:49 <wagle> (algorithms mooc)
00:48:50 <edwardk> omefire: https://github.com/chrisdone/ghci-ng
00:48:57 <wagle> 850000+
00:49:00 <solatis> hmm.. little question
00:49:01 <edwardk> omefire: i've only seen him talk about it, not used it though.
00:49:03 <EvanR> funfunctor: unless its a literal multiplier in which case its automatic
00:49:09 <funfunctor> :t realToFrac
00:49:10 <lambdabot> (Real a, Fractional b) => a -> b
00:49:11 <solatis> when is it appropriate to use String instead of Text ?
00:49:23 <solatis> performance?
00:49:38 <edwardk> solatis: when you want to use pattern matching and induction or want to cons onto the structure efficiently
00:49:38 <solatis> as in, "when in doubt, use Text" ?
00:49:44 <solatis> ahh right
00:49:55 <wagle> 5,000,000 values
00:50:01 <edwardk> solatis: i use text when things won't change much once made
00:50:06 <EvanR> :t (*2.34) -- funfunctor
00:50:07 <lambdabot> Fractional a => a -> a
00:50:17 <solatis> edwardk, it's about storing results of a protocol in this case
00:50:25 <solatis> the protocol is in clear text
00:50:34 <solatis> i need to store the plaintext of a session id, for example
00:50:38 <edwardk> solatis: well, make sure that you really want the data to be in unicode then
00:50:40 <solatis> i'm erring towards using Text for that
00:51:09 <solatis> what is the encoding type of String ?
00:51:15 <EvanR> none
00:51:18 <EvanR> @src String
00:51:18 <lambdabot> type String = [Char]
00:51:22 <solatis> right
00:51:23 <lpaste> funfunctor pasted “No title” at http://lpaste.net/120957
00:51:26 <solatis> so it's just latin1
00:51:30 <EvanR> ... no
00:51:34 <solatis> ascii?
00:51:37 <EvanR> no
00:51:41 <EvanR> Char is a unicode character
00:51:42 <funfunctor> EvanR: I get expected type `Double' with actual type `NominalDiffTime' line 74
00:51:51 <aavogt> gfoldl :: (Functor c, Data a) => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
00:51:54 <Lokathor> isn't Char a 31bit value?
00:52:03 <solatis> ah, so not like the C char
00:52:07 <aavogt> is there a way to pretend you have Functor c (in the actual gfoldl)?
00:52:16 <Cale> > maxBound :: Char
00:52:17 <lambdabot>  '\1114111'
00:52:18 <EvanR> funfunctor: lpaste line 74.
00:52:41 <solatis> ok
00:52:46 <omefire> edwardk: thanks
00:52:52 <solatis> so, in that case, I will use Text
00:53:01 <EvanR> Lokathor: you need 21 bits to store one. Char probably uses more than that, also it doesnt matter to the programmer at all
00:53:42 <funfunctor> EvanR: yea I know which line but not how to fix it in this case
00:53:57 <Cale> But yeah, String and Text both don't specify an encoding
00:54:08 <EvanR> funfunctor: well i cant really help because i cant see line 74. use lpaste
00:54:23 <EvanR> Cale: except for the issue regarding utf16 surrogates in Text
00:54:23 <funfunctor> EvanR: I did
00:54:28 <Cale> The encoding is handled when you go to do I/O with the things, or explicitly convert to ByteString
00:54:28 <EvanR> funfunctor: oh
00:54:38 * hvr reminds everyone that the FTP survey at http://goo.gl/forms/r150drt0t1 is going to close in about 3 hours from now
00:54:39 <Lokathor> EvanR, i only recall that it's 31 bits because vty talks about it at one point, that GHC uses ISO 10646 31 bit characters internally
00:54:43 <funfunctor> EvanR: http://lpaste.net/120957#line74
00:54:50 <xnil____3> i always explicitly set my encoding buffers for IO operations
00:54:54 <xnil____3> :^)
00:54:59 <EvanR> funfunctor: use realToFrac on one of the operands of the * there
00:55:06 <xnil____3> bugs galore if you don't
00:55:18 <edwardk> solatis: Char holds a unicode value internally in terms of the size of Char. how we dump that through IO into a file is another matter
00:55:31 <solatis> edwardk, yeah i understand
00:55:33 <edwardk> > fromEnum (maxBound :: Char)
00:55:34 <lambdabot>  1114111
00:55:39 <EvanR> Lokathor: the number 31 relates to the Int type in the haskell report...
00:56:05 <Lokathor> could be
00:56:12 <funfunctor> EvanR: thx! black magic
00:56:12 <edwardk> oh, cale already beat me to it
00:56:27 <edwardk> why am i not surprised ;)
00:56:29 <Lokathor> 31 bits is a whole lot more than i ever really need from my characters, particularly with vty
00:56:53 <EvanR> funfunctor: not black magic, surely you know that Double is a floating point number. you may also know that NominalDiffTime is a fixed point decimal fraction of seconds. you cant just multiply them without converting one to the other
00:57:17 <edwardk> well, Char itself claims a maxBound with 21 bits of range to match all the contents you can fit in the base and astral planes of unicode
00:57:58 <edwardk> it physically takes more storage, but thats because _everything_ in haskell takes up more storage in a structure basically. everything takes a slot that is an integral multiple of 4 or 8 byte slots depending on if you are on a 32 or 64 bit platform
00:58:00 <funfunctor> EvanR: I had no idea what NominialDiffTime :: ?? is internally, hackage link is dead on the doc page when clicking source
00:58:01 <hvr> on a C64, a character was encoded in 8x8 pixels... so you could represent every conceivable pattern in a 64bit value =)
00:58:10 <edwardk> at least when packed into a constructor
00:58:30 <EvanR> funfunctor: yes its supposed to be abstact, but in any case you shouldnt assume every Fractional type is just a Double
00:58:57 <edwardk> hvr: or a 4x8 wide pixel encoding with 4 colors per pixel which was awful
00:59:13 <hvr> heh
00:59:14 <Lokathor> mmm, were their subpixels?
00:59:29 <Lokathor> there*
00:59:29 <funfunctor> EvanR: I was not assuming hence confused
00:59:31 <edwardk> Lokathor: on a c64? hah, hah, hahahahah, hahahhahahahah
00:59:34 <EvanR> if you count the electron beams electrons
01:00:11 <edwardk> Lokathor: 320x200, you could use sprites to draw outside of that boundary if you got creative. it was a fairly standard scener trick later on
01:00:13 <hvr> edwardk: there were subpixel... since it was displayed on CRTs with RGB-masks =)
01:00:32 <EvanR> funfunctor: the take away is that * and + require both their operands to be the same type, theres no implicit conversion like C or ruby or ...
01:00:47 <Lokathor> edwardk, not too far fetched, they were used internally on the genesis to make sonic move as smoothly as possible
01:01:05 <Lokathor> each pixel had 256 subpixels so that his frame to frame movement would be as even as possible
01:01:12 <edwardk> Lokathor: sure. the smooth scroll on the c64 was integral multiples though
01:02:37 <funfunctor> EvanR: yes, thx
01:03:36 <edwardk> basically on the c64 they only devoted 3 bits of $d011 and $d016 respectively to smooth scrolling, so there were no bits left over for smoothing the effect any further, sprite positions are also integral multiples
01:03:56 <EvanR> funfunctor: (and in the case that it seems ridiculous that there needs to be a conversion at all, like between Int and Int64, this is often a noop, and the conversion is just there to satisfy the types)
01:04:15 <Lokathor> i don't know much about those ancient machines
01:04:43 <cimon> hello, I'm trying to compose three functions: f: (a -> b -> c) and g: (x -> a) and h: (y -> b) into (x -> y -> c), so far the best I've come up with is curry $ (unurry f) . (g *** h) but surely there must be a simpler way?
01:05:05 <merijn> cimon: Just use a lambda?
01:05:21 <cimon> :) well doh but I've been trying to avoid that
01:05:22 <edwardk> cimon: sounds like a job for a lambda =)
01:05:23 <merijn> cimon: "\x y -> f (g x) (h y)"
01:05:33 <merijn> Not everything has to be pointfree...
01:05:37 <edwardk> @pl \x y -> f (g x) (h y)
01:05:37 <lambdabot> (. h) . f . g
01:05:51 <cimon> I'm just playing around, not trying to write production code so it doesn't have to be readable
01:05:52 <EvanR> not bad
01:06:55 <edwardk> as a rule of thumb the moment i have to start sectioning operators like that i stop using @pl. your mileage may vary
01:07:56 <merijn> Yeah
01:07:57 <cimon> but the composition is conceptionally so simple :( applicatives almost work but not quite :(
01:08:01 <funfunctor> EvanR: i'm happy for types to tell me I am a bad boy.. I just get confused how to fix things sometimes
01:08:24 <merijn> cimon: I actually find that it's best to just practice writing readable code always (although my definition of readable has shifted over time)
01:08:52 <merijn> cimon: Is that lambda that bad? Compared to code in other languages it doesn't feel so problematic...
01:09:35 <EvanR> funfunctor: realToFrac converts between fractional types. fromIntegral converts between integral types. floor and ceil go from fractional to integral in different ways
01:09:45 <EvanR> s/ceil/ceiling/
01:09:48 <edwardk> dimap g (. h) f
01:09:58 <cimon> it's not like I have to accomplish a certain task and refuse to use a lambda. I just was curious how all kinds of compositions could be done in pointless style
01:10:01 <edwardk> still messy with the (. h) in there but its not too bad.
01:10:03 <cimon> and got stuck at this one
01:11:04 <Procian> probifunctors?
01:11:31 <Hijiri> looks like just profunctor
01:13:01 <Procian> Hijiri: But you want to map two functions across two places in negative position.
01:13:39 <funfunctor> should the monad type parameter or primitive type parameters come first for something like runMyState samplerate m = evalStateT m (HwState samplerate,..)
01:13:57 <cimon> hm, dimap isn
01:14:05 <cimon> 't in the standard library?
01:14:15 <EvanR> funfunctor: does samplerate need to be modifiable?
01:14:20 <Lokathor> can one make haddock print out what things are missing documentation?
01:15:06 <funfunctor> EvanR: at the beginning of the state it needs to be initiated in a configurable way
01:15:39 <EvanR> funfunctor: if it needs to be initialized, and is never set again, thats not a good case for State or StateT or IORef or anything
01:15:54 <EvanR> thats a case for a function parameter or Reader
01:16:14 <funfunctor> EvanR: well HwState contains for more than samplerate
01:16:51 <Lokathor> funfunctor, the argument that changes least often from call to call should go sooner in the list if you plan to curry it
01:17:21 <EvanR> funfunctor: doesnt change what i said ;)
01:17:33 * mjrosenb is having issues with the new haskell mode in emacs
01:18:31 <funfunctor> EvanR: well StateT is pretty flexable, i'm just going with that at the moment for modelling a fake radio's state
01:18:37 <mjrosenb> I hit C-c C-l to get it to load the library that I'm working on, and told it to use the correct cabal directory, but it just started a repl without loading anything
01:18:47 <funfunctor> Lokathor: thx
01:18:53 <mjrosenb> and typing import My.Library told me that it didn't exist.
01:19:04 <EvanR> funfunctor: so be it. but you might find writing the entire program as a StateT over IO is not as convenient as you thought
01:19:21 <EvanR> at least in haskell
01:21:06 <funfunctor> EvanR: I don't think it is but I think its all I can handle at the moment complexity vs. brain power
01:21:36 <funfunctor> EvanR: i'm almost finished the module, i'll paste it when i'm done
01:21:49 <EvanR> funfunctor: transformers may be sapping your brainpower ;)
01:22:31 <funfunctor> damm those robot people..
01:45:00 <rieper> hello, maybe somebody could assist me with a little math and how to write it in haskell? i have the function z = ax + by and dont now how to get that into a haskell programm which eventually calculates x, y for given z, a, b - thanks a lot (seems like i totally lost track of math last couple of years  :/)
01:45:33 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/120957
01:45:49 <funfunctor> EvanR: what do you think of that?
01:46:36 <EvanR> no sir i dont like it
01:46:59 <EvanR> your have basically some C global variables
01:47:06 <mr-> rieper: if a != 0, then x = (z-by)/a, if b != 0, analogously
01:47:06 <EvanR> including underrun Bool
01:48:00 <LordBrain> i think he means he wants a ternary function f a b z → (x,y)
01:48:21 <LordBrain> well
01:48:36 <rieper> that's the problem, i also forgot how to describe the problem :/
01:49:10 <rieper> but yes, ternary function looks like what I want
01:49:42 <LordBrain> well, you'd need two points
01:49:57 <EvanR> funfunctor: are you translating some c++ code?
01:50:12 <LordBrain> so actually something like f (a1,b1,z1) (a2,b2,z2) → Maybe (x,y)
01:50:18 <funfunctor> EvanR: well I am using some C++ code as a reference yes
01:50:45 <EvanR> this is overly complex for what it is
01:50:57 <funfunctor> EvanR: because reading 1,000 pdf's ranging from 600-9,000 pages is not my idea of a good time
01:51:27 <EvanR> yes im currently doing the same thing, only without the option of a 9000 page pdf to tell me the answers, but thats another story
01:51:38 <funfunctor> EvanR: well its a stub driver to meet the interface of real hardware
01:52:02 <EvanR> i gathered that from the name NullDriver. but i think you need to rethink the interface
01:52:08 <rieper> LordBrain: eventually I need all combinations of the integers x, y which are true for a given a, b, z
01:52:11 <funfunctor> EvanR: this is  implementation of a GSM stack in Haskell
01:52:26 <LordBrain> ohh
01:52:48 <funfunctor> EvanR: i'm all ears
01:52:58 <EvanR> funfunctor: wheres the rest of the code
01:53:13 <LordBrain> rieper, well, we have a nice cheat for you :) comprehension syntax:  f a b z = [ (x,y) | a*x+b*y == z ]
01:53:19 <funfunctor> EvanR: oh, most of it is local at the moment. I am trying to work out licensing
01:53:25 <LordBrain> might need parenthesis, i forget the precedence
01:53:30 <EvanR> grumble
01:53:39 <funfunctor> I hope for it to be GPL2'ed
01:54:02 <EvanR> funfunctor: what are you using the communicate with the device, FFI?
01:54:03 <funfunctor> EvanR: its not worth putting it on github at the moment..
01:54:14 <lf94> Is Vector apart of ghc or do i need to install via cabal
01:54:15 <funfunctor> EvanR: oh yes, that is opensource
01:54:18 <funfunctor> EvanR: 1sec
01:54:33 <funfunctor> EvanR: https://github.com/victoredwardocallaghan/hlibBladeRF
01:54:54 <funfunctor> EvanR: there was some updates I have not pushed yet because I want that to go on hackage rather soon
01:54:58 <thebnq>  lf94: you do need to install it
01:55:15 <lf94> how do I know how to import it?
01:55:17 <lf94> import Vector?
01:55:40 <EvanR> malloc :: IO (Ptr (Ptr C'bladerf))
01:55:48 <EvanR> have you tested this?
01:56:10 <rieper> LordBrain: thanks! that looks about right ;) how would I work with that in ghci, the interactive thing?
01:56:34 <funfunctor> EvanR: yes, it all works
01:56:45 <EvanR> that type seems really suspicious but ok
01:56:49 <funfunctor> EvanR: I can run the radio, set gpio's and so on
01:57:01 <funfunctor> EvanR: yea, because C programmers............
01:57:03 <thebnq> lf94: Data.Vector ?
01:57:26 <LordBrain> rieper, that wont be efficient, what is this for?
01:57:39 <lf94> thebnq, yea that worked :)
01:57:43 <funfunctor> EvanR: the init function expects a double indirection because it allocates memory internally
01:57:54 <funfunctor> EvanR: but don't worry about that, it works ;)
01:58:02 <LordBrain> rieper, are x and y limited to elements from finite lists?
01:58:40 <lf94> Would anyone have a moment to help me figure out why this is not working? http://lpaste.net/120960 (Error: Illegal instance declaration for `FromNamedRecord Centi')
01:58:54 <wagle> what would you use for a Data.map with no values?
01:59:24 <EvanR> funfunctor: alright so in the end, you have a single pointer which is the handle to this device. and you communicate to it with very low level commands that take basically integers to read and write locations on this thing
01:59:29 * hackagebot call 0.1.4 - The call game engine  http://hackage.haskell.org/package/call-0.1.4 (FumiakiKinoshita)
01:59:38 <rieper> LordBrain: yep, roughly it is about i have like 450l liquid and 30l and 50l barrels...
01:59:51 <funfunctor> EvanR: yea basically
01:59:58 <EvanR> and youre writing the higher level wrapper
02:00:26 <hiptobecubic> Can anyone explain why this happens? http://lpaste.net/120962  I have an IO action that is supposed to happen once up front, but unless i force it to go to WHNF it gets delayed until the middle of a loop, where it happens 1000 times
02:00:27 <rieper> LordBrain: so, basicly y = [1..9] and x = [1..15]
02:00:28 <funfunctor> EvanR: thats just the binding for that particular hw. Now I am writing layer0 for the GSM stack (think OSI model)
02:00:33 <ski> @type Data.Map.empty  -- wagle ?
02:00:34 <lambdabot> M.Map k a
02:00:59 <wagle> just keys
02:01:13 <EvanR> funfunctor: im assuming layer0 is stateful. but is that just because its like, incrementally processing a stream?
02:01:17 <LordBrain> to make my solution work, you'd need them to be, because really you'd have to right let f a b z = [ (x,y) | x <- [minBound .. maxBound], y <- [minBound .. maxBound],  a*x+b*y == z ]::[(Word8,Word8)]
02:01:23 <hiptobecubic> Based on my previous understanding of how the IO monad works, this seem lke a bug to me
02:02:23 <LordBrain> rieper, just replace minBound for y with 1 and maxBound with 9, etc... you see how it works
02:02:37 <EvanR> funfunctor: in any case whats the high level interface supposed to look like?
02:04:50 <thebnq> hiptobecubic: not sure, would have to see the rest of the code, but oneRound is inside of the replicateM_
02:05:05 <deMoivre> Does anyone here know Java and feel like they can port any of their Java programs to Haskell?
02:05:53 <xkb> deMoivre: probably not all...
02:05:53 <hiptobecubic> thebnq, yes, but oneRound doesn't call buildSets. i'll paste the rest
02:06:20 <deMoivre> xkb: Why not all?
02:06:28 <hiptobecubic> thebnq, http://lpaste.net/120962
02:07:03 <wagle> deMoivre: its just denotational semantics..  8) 8)
02:07:35 <xkb> deMoivre: limitation on my side... Knowledge of libs etc
02:08:39 <EvanR> deMoivre: or drive them from haskell, using java-bridge ;)
02:10:24 <xkb> Anyway. The language itself should not be the limiting factor
02:10:41 <EvanR> deMoivre: if your java program is using one or more huge java-only libraries, youd also have to port that, if there wasnt an equivalent.
02:11:03 <EvanR> but then theres java bridge
02:11:56 <hiptobecubic> Well I need to sleep. thebnq thanks for taking a look
02:11:59 <xkb> I noticed that most things I take for granted in java world require a bit of searching in Haskell. Connection pooling and transaction demarcation come to mind
02:12:24 <thebnq> hiptobecubic: not sure what you meant by unless you force it, did you have "m <- ..." before?
02:12:29 <hiptobecubic> thebnq, yes
02:12:55 <thebnq> could be lazy io kicking in somehow but i'm not sure
02:13:19 <thebnq> it worked for a small case :)
02:14:05 <YaRly> How do you install a package to your Haskell project so that it's included in the project?
02:14:06 <hiptobecubic> i'm trying right now with about t = 1000
02:14:28 <hiptobecubic> even a small case does it on my machine
02:14:30 * hackagebot elevator 0.2.2 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.2.2 (FumiakiKinoshita)
02:14:32 <hiptobecubic> t = 5
02:14:39 <xkb> YaRly: included as in statically linked?
02:15:36 <YaRly> xkb: I mean that I want it to be in a subdirectory in my project, so the import points to that subdirectory. (I suppose that's what statically linked means)
02:23:37 <xkb> The binary or the source
02:25:22 <gauthier> can haddock depend on ghc-api or it should not depend on it?
02:27:38 <aavogt> gauthier: as far as I know, haddock only uses ghc-api to get the comments/inferred types out of hs files
02:28:53 <gauthier> aavogt: I'm looking at this nifty hack: https://github.com/ranjitjhala/haddock-annot/tree/master/haddock-2.9.3
02:29:14 <gauthier> somehow it seems to import types that I can't import in current haddock, FastString etc.
02:29:22 <YaRly> xkb: I just copy paste it?
02:35:49 <gauthier> sorry, I got misled by errors in flycheck which don't show up when I cabal build the thing
03:11:09 <lpaste> tomphreek pasted “Is an easier way, for input n, to run function f, if return is Nothing then return Nothing else keep n” at http://lpaste.net/120966
03:12:23 <mauke> n <$ decompose size n
03:17:54 <funfunctor> EvanR: funfunctor: im assuming layer0 is stateful. but is that just because its like, incrementally processing a stream? correct! sorry for the delay
03:18:18 <YaRly> I have a bunch of packages that I want installed locally, is it a good idea to use a sandbox?
03:18:24 <funfunctor> EvanR: the highlevel interface is two main UDP sockets, one for control the other for data
03:19:18 <tomphreek> mauke: thank you
03:19:29 <EvanR> funfunctor: so ... sendControl :: ByteString -> IO (), sendData :: ByteString -> IO ()
03:20:05 <funfunctor> EvanR: more or less something like that
03:20:09 <EvanR> relatively speaking, UDP sockets doesnt sound much higher level
03:20:20 <EvanR> and neither does what i just wrote
03:20:27 <funfunctor> EvanR: well I only plan on implementing the first two layers
03:21:03 <funfunctor> EvanR: actually its very high level if you think I start off with IQ QAM signals
03:21:21 <EvanR> yes but its not high level by normal programmer on the pc standards
03:21:29 <EvanR> well haskell programmer
03:21:49 <EvanR> anyway the above doesnt need StateT is all
03:21:59 <funfunctor> EvanR: well no, but come on dude.. I am going from magic in the air to packets flowing though a UDP socket
03:22:59 <EvanR> IO already lets you have mutable state
03:23:02 <funfunctor> EvanR: how do you reason the hw does not need state?
03:23:24 <funfunctor> EvanR: yea but real hw buffers RF data
03:23:46 <jophish> Yo yo yo
03:23:53 <funfunctor> EvanR: we deal with data in blocks
03:24:11 <funfunctor> EvanR: we have to demodulate until we have a full block
03:24:22 <EvanR> you dont need StateT for that
03:24:49 <jophish> Using DataKinds does there exist a family: index :: '[a::*] -> Nat -> *
03:25:06 <jophish> as in, is it possible to index into a type level list using a Nat
03:25:11 <funfunctor> EvanR: alright so how should what I pasted look like?
03:25:48 <EvanR> most of what you pasted was managing a StateT so im not even sure what the point was
03:27:07 <funfunctor> EvanR: because its only a shim of a 'real' driver which is more complex
03:27:07 <EvanR> so in IO you have IORefs, MVars, TVars, and other stuff to use mutable state
03:27:25 <funfunctor> let me paste a partially done driver
03:27:52 <EvanR> you can hide mutable state inside of other IO actions, which may have a simpler interface, by closing over the environment, basically use partial evaluation in the construction
03:28:30 <lpaste> funfunctor pasted “NOT COMPLETE!!!” at http://lpaste.net/120969
03:29:07 <funfunctor> EvanR: something like that, still WIP. I want to get the stub driver going first before I touch that again.
03:29:15 <EvanR> since what you need is available as parameters you dont need wrappers, unwrappers, runners, getters and setters. or if you do want getters or setter functions they are an order of magnitude less code
03:31:15 <EvanR> for instance instead of a logger taking up the ReaderT position, it could just be one of many things in the environment
03:31:23 <EvanR> but i think you already had that conversation
03:31:30 <EvanR> i need to go to sleep
03:31:54 <funfunctor> ok night night EvanR
03:32:01 <funfunctor> i'll be working on this tomorrow some also
03:32:56 <nshepperd> jophish: I think you can
03:33:34 <jophish> nshepperd: yeah, I don't think it should be too hard to write, but I couldn't find one already exiting
03:35:31 <lpaste> nshepperd pasted “Type Level List” at http://lpaste.net/120970
03:35:46 <nshepperd> ^^ seems to run
03:36:21 <jophish> that was fast!
03:36:33 <jophish> thanks, nshepperd
03:38:18 <nshepperd> i wanted to write 'type family Index :: [*] -> Nat -> *' but that doesn't work for some reason
03:40:07 <jophish> nshepperd: yeah, I've noticed how type level computation seems to have syntax of its own
03:40:12 <jophish> still, better than c++!
03:41:52 <merijn> nshepperd: You need to specify all variables as names for some obscure reason I forgot
03:42:10 <merijn> nshepperd: i.e. "type family Index (xs :: [*]) (n :: Nat) :: *"
03:42:28 <merijn> nshepperd: i.e. the signature specifies the return type of the entire family, so you're initial version has no arguments
03:43:21 <lf94> Why can't I import Control.Type?
03:43:51 <lf94> This is actually madness
03:44:05 <lf94>     Could not find module `Control.Type'\n    Locations searched:\n     Control/Type.hs
03:44:36 * hackagebot hakyll 4.6.6.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.6.0 (JasperVanDerJeugt)
03:45:14 <merijn> lf94: Which package is that from?
03:46:28 <lf94> Control.Type
03:46:47 <lf94> I want to use 'mzero'
03:46:51 <lf94> But it's in Control.Type
03:46:55 <lf94> but haskell can't find it
03:46:59 <lf94> haskell -> ghc
03:47:34 <merijn> I've never heard of Control.Type and am about 90% certain mzero is not from there
03:47:53 <merijn> mzero comes from Control.Monad
03:47:56 <CindyLinz> lf94: why not import Control.Monad and use MonadPlus?
03:48:04 <mauke> lf94: did you write Control.Type?
03:49:09 <mniip> is there really not a way to embed your own state in the IO monad
03:49:24 <mniip> without stuff like 'unsafePerformIO newIORef'
03:49:32 <mniip> and without lifting everything like in StateT
03:49:42 <merijn> mniip: Just closures?
03:49:55 <mniip> ?
03:50:15 <merijn> use IORef as function argument
03:50:30 <mniip> that works but
03:50:44 <mniip> dragging it around everywhere
03:50:55 <mniip> (this is what I'm currently doing though)
03:56:35 <naevathecat> ddellacosta: Hey there. Yesterday you recommended the haskell-exercises github. After installing QuickTest for it I get an ambigious reference running the testfile. Did you run into that?
03:57:23 <ddellacosta> naevathecat: hmm, to be honest it's been a while since I tried it, and I think it's been updated since then.  Maybe ping opqdonut about it?  Or post an issue on github?
03:58:48 <naevathecat> Fair enough, wondered if there was a quick fix. The file is literally just "import Impl.Test". Which is apparently named in Impl.Test and Test.QuickCheck
03:59:38 * hackagebot descriptive 0.9.0 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.9.0 (ChrisDone)
04:04:46 * hackagebot Cabal 1.22.1.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.22.1.0 (JohanTibell)
04:04:48 * hackagebot hi 1.2.0.0 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-1.2.0.0 (DaisukeFujimura)
04:10:10 <huckleberry78> anybody on?
04:10:56 <huckleberry78> trying to understand a swift function written by a Haskell developer
04:11:15 <Xe> what do you mean?
04:11:16 <mauke> heh
04:11:39 <xkb> hmm where in attoparsec is <? defined (if so)
04:11:47 <merijn> Hah, my prediction that Swift will be the best thing to happen to haskell is coming true ;)
04:12:10 <merijn> xkb: If you go to the haddock pages there's an Index link on the top right listing all exported functions/datatypes alphabetically
04:12:21 <xkb> ah nice
04:12:28 <merijn> xkb: Alternativelly, ":i" in ghci should list where it's imported from
04:12:42 <xkb> I guess it was a typo
04:12:49 <xkb> only <?> is dfined
04:12:50 <merijn> Yeah, probably should be <?>
04:13:26 <merijn> huckleberry78: Might wanna put it on lpaste if you expect anyone to help ;) Psychically explaining functions is hard :p
04:15:48 <huckleberry78> the code is for JSON decoding, located at https://robots.thoughtbot.com/efficient-json-in-swift-with-functional-concepts-and-generics
04:17:06 <huckleberry78> I'm just learning swift and went to a dev meeting, where they were talking about functional programming, monads, haskell, and how we can utilize these ideas in swift
04:17:10 <merijn> Looking at this code I'm betting it'll be less than 2 years before Swift users demand monads :>
04:17:36 <merijn> oh, actually
04:17:41 <merijn> That's what this article is doing
04:18:22 <huckleberry78> yeah, it really shows some excellent techniques to make parsing JSON easier
04:18:52 <huckleberry78> but I can't figure out how to actually get the performRequest to work
04:20:20 <rui> From the wiki "real roots of live values hierarchy are live in the stack".
04:20:42 <rui> What are "real roots of live values hierarchy"?
04:20:51 <huckleberry78> performRequest(request: NSURLRequest, callback: (Result<A>) -> ()), what do I put into the result<A> part if I want to just check for a returned JSON object that can be decoded into a user
04:21:02 <merijn> rui: Which wiki page is that?
04:21:25 <rui> I am trying to have a simple model of when is memory allocated in heap vs stack and when it is GC
04:21:28 <rui> merijn, https://wiki.haskell.org/GHC/Memory_Management
04:21:34 <mauke> huckleberry78: I haven't read the code but that looks like you'd write your callback to take Result<User>
04:21:43 <merijn> huckleberry78: Basically what's going on is that performRequest decodes it into a Result<A> and your callback gets that
04:22:02 <merijn> huckleberry78: So if you want to decode a User you should provide a function of type "Result<User> -> ()"
04:23:13 <merijn> rui: That's a very confusing sentence, tbh
04:23:32 <merijn> rui: I think I have an ok grasp of GHC's GC and even I don't understand what they mean
04:24:06 <merijn> rui: There's no real heap vs stack distinction in the same way you are used to from imperative languages
04:24:23 <merijn> rui: The GHC stack is for "pattern matches", not for allocations
04:24:48 <merijn> rui: So basically, all values are on the heap (and the stack may have pointers to heap values)
04:25:36 <merijn> rui: If you're interested in the details I have a better link for you
04:28:36 <init> does anyone know a better way to move http://lpaste.net/120971 to use GHC.TypeLits other than enabling overlappinginstances and something like this http://lpaste.net/120972 ?
04:29:49 * hackagebot cabal-install 1.22.0.1 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.22.0.1 (JohanTibell)
04:30:26 <merijn> init: Moving to TypeLits' Nat probably won't do what you want
04:30:51 <merijn> init: The current solver for TypeLits constraints is rather dumb and unable to solve lots of cases that it CAN solve for your own Nat type
04:31:06 <merijn> Until we have a new solver defining a custom Peano Nat is probably the way to go
04:31:29 <merijn> FYI there's already a polykind proxy so you don't need to define it
04:31:42 <lf94> what's the best way to read in a number of the format "-xxx,xxx,xxx.yy" ?
04:31:59 <mniip> lf94, read . filter (',' /=)
04:32:01 <lf94> google isnt being helpful
04:33:11 <init> merijn: oh, well, will use the old code then, and yes, this is just a random sandbox.hs :P
04:34:49 * hackagebot streaming-commons 0.1.10.0 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.10.0 (MichaelSnoyman)
04:36:37 <TheLemonMan> do you suggest to scrap all the monad tutorials and just read the Typeclassopedia to dive into the monadic world ?
04:39:06 <merijn> TheLemonMan: Yes
04:39:14 <mniip> my understanding of monads from LYAH was full enough to learn nothing new from the typeclassopedia
04:39:25 <merijn> TheLemonMan: Also, make sure to invest plenty of time into understanding type signatures and typeclasses in general
04:39:27 <mniip> (the monad section)
04:39:36 <merijn> TheLemonMan: IMO most confusion comes from not understanding those two sufficiently
04:40:46 <merijn> TheLemonMan: My recommended recipe is 1) learn type signatures and reasoning about types 2) learn typeclasses and play with them 3) look at functor/applicative/monad typeclasses and learn what instances do for specific types and 4) repeat for new types until subconciously you connect the dots
04:40:57 <merijn> TheLemonMan: 4 can be combined with reading typeclassopedia
04:46:21 <wacco> why can't you have an '<-' in an if expression?
04:46:44 <xkb> in mysql-simple, do I have to create an instance of QueryResults if I want to retrieve just a collection of VarChar records?
04:47:10 <ski> `<-' are for list comprehensions, `do'-expressions (and pattern gaurds)
04:47:13 <mniip> wacco, you mean check if a value matches a pattern?
04:47:17 <xkb> Im trying to mapM the results now, but somehow the typechecker has no idea that its varchar/string
04:47:29 <wacco> yeah, just practicing. wanted to rewrite a pattern guard to an if
04:47:37 <mniip> you can do it with case
04:47:49 <wacco> that's what I started out with :)
04:49:27 <YaRly> I can't get the network package to load in windows (in neither the 32 or 64-bit version of the haskell platform), does anyone know what the problem could be?
04:49:32 <wacco> it's not so much the 'how', but the 'why' this suddenly isn't valid syntax
04:49:57 <mauke> wacco: what do you mean, "suddenly"?
04:50:11 <mauke> <- is never valid syntax ... unless you're in a do block or list comprehension
04:50:39 <mniip> it is actually with some extensions
04:51:00 <wacco> reason optional | (x:_) <- optional = " (" ++ x ++ ")" | otherwise = []
04:51:01 <CindyLinz> wacco: pattern guard can be used in a multi-way-if
04:51:01 <mauke> yes, there are some other special cases, like pattern guards or pattern synonyms
04:51:12 <wacco> that's fine.. not to my knowledge doing anything special extension-wise
04:51:17 <wacco> reason optional = if (x:_) <- optional then " (" ++ x ++ ")" else []
04:51:19 <mauke> but it's still only valid in some specific contexts
04:51:28 <mauke> wacco: that's a pattern guard
04:51:32 <wacco> that gives a parse error.. and I wasn't expecting any
04:51:38 <mniip> you're combining 'if-then-else' with a variable binding here
04:51:42 <mniip> (x)
04:52:14 <mauke> wacco: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#pattern-guards
04:52:48 <wacco> that's an extension?
04:53:14 <ski> yes
04:53:53 <wacco> ok.. I guess that answers my question, but didn't see that coming
04:53:55 <mauke> wacco: apparently it got merged in Haskell 2010
04:54:07 <mauke> so it's now a normal part of the language :-)
04:54:35 <merijn> Wait, 2010 did something else beyond deprecating only 1 or 2 useless things? :p
04:55:20 <wacco> well at that point, <- not working in if is "no reason"?
04:55:41 <wacco> why can you do variable binding in a guard, but not in an if -__-
04:55:50 <mauke> because 'if' is just an expression
04:55:55 <merijn> @quote lexical.syntax
04:55:55 <lambdabot> cmccann says: I still kind of expect that the next standard will be haskell2017 or something, and all it will do is a minor change to lexical syntax of comments that fixes nothing but nevertheless breaks 20% of hackage.
04:56:14 <merijn> wacco: <- in do-block is syntactic sugar for >>=
04:56:28 <mauke> this is about pattern guards, though
04:56:28 <wacco> but I'm not in a do-block here
04:56:35 <merijn> wacco: So the reason it doesn't work is simply: "Because that wouldn't make sense"
04:56:43 <merijn> wacco: Right, which is why it doesn't work
04:57:01 <wacco> but it does in the pattern guard (see earlier example)
04:57:07 <wacco> so confused right now xD
04:57:18 <mauke> wacco: you could propose an extension: change the syntax of 'if EXPR then EXPR else EXPR' to 'if GUARDS then EXPR else EXPR'
04:57:18 <merijn> wacco: Pattern guards are wholly different, anyway I think you simply want a case-of
04:57:46 <merijn> wacco: "case optional of (x:_) -> " (" ++ x ++ ")"; [] -> []"
04:57:47 <mauke> wacco: with corresponding desugaring: 'case () of _ | GUARDS -> EXPR1 | otherwise -> EXPR2'
04:57:58 <mauke> so it's not that this makes no sense
04:58:01 <merijn> wacco: We already have that, MultiWayIf
04:58:02 <mauke> more like no one's proposed it yet
04:58:06 <merijn> s/wacco/mauke
04:58:06 <wacco> what I want is to get more comfortable translating one to the other - I already got case and guards working, now just wondering how to do it with an if :)
04:58:21 <merijn> wacco: Use "null
04:58:23 <merijn> :t null
04:58:24 <lambdabot> [a] -> Bool
04:58:27 <merijn> > null []
04:58:29 <lambdabot>  True
04:58:30 <merijn> > null [1]
04:58:32 <lambdabot>  False
04:58:39 <xkb> are there no default instances for QueryResults for String?
04:58:42 <wacco> ohh neat
04:58:50 <mauke> merijn: but not for single-way if
04:59:19 <merijn> wacco: But really null is just "case xs of (_:_) -> True; [] -> False" :p
04:59:30 <merijn> wacco: Just in it's own function
04:59:37 <wacco> hehe
04:59:51 * hackagebot yeller 0.1.0.1 - A Yeller Client For Haskell  http://hackage.haskell.org/package/yeller-0.1.0.1 (TomCrayford)
04:59:59 <wacco> reason optional = if null optional then [] else " (" ++ (head optional) ++ ")"
05:00:03 <wacco> powww
05:00:13 <merijn> wacco: See also this link: http://www.vex.net/~trebla/haskell/crossroad.xhtml
05:00:49 <CindyLinz> wacco: (with multiwayif) if | x:_ <- optional -> " (" ++ [x] ++ ")" | otherwise -> []
05:00:59 <Gurkenglas> http://comonad.com/reader/2015/free-monoids-in-haskell/ <- "(single 1 <>) is a strict function" <- Why?
05:01:08 <merijn> I think this is encouraging the wrong thing as pattern matching is really the right way to go
05:01:39 <wacco> maybe
05:01:45 <CindyLinz> wacco: complete sample.. # http://ideone.com/uNtIY9
05:01:45 <merijn> monochrom: Can I suggest a one line TL;DR to your "how to use reads" post?
05:01:57 <wacco> my c++ mindset thinks this is more readable tho
05:02:19 <merijn> wacco: Hence why I linked the crossroad post, I recommend reading it for reasons to prefer pattern matching :)
05:02:27 <wacco> already on it ;)
05:02:29 <Gurkenglas> Strict functions are those that need to fully evaluate their arguments once evaluated once, right?
05:02:34 <mauke> Gurkenglas: no
05:02:47 <wacco> also looking at the multiwayif @ CindyLinz, but that sounds like a bit overkill
05:02:49 <mauke> Gurkenglas: a function f is strict if f _|_ = _|_
05:03:05 <jophish> Is there an inverse of ~, where two types satisfy the constraint if they are not equal?
05:03:12 <merijn> jophish: No
05:03:14 <YaRly> Reposting: I can't get the network package to load in windows (in neither the 32 or 64-bit version of the haskell platform), does anyone know what the problem could be?
05:03:23 <jophish> merijn: I thought as much
05:03:33 <merijn> jophish: I've proposed that in the past, but I was told "that's not really doable in GHC's internal theory"
05:03:41 <Gurkenglas> Which "fixed point theorem" is that there?
05:03:49 <Gurkenglas> *mauke
05:03:51 <merijn> jophish: But! See this neat trick: https://gist.github.com/merijn/6130082
05:03:51 <CindyLinz> wacco: overkill, truely...  We can "let" some variables in a branch of a multi-way-if, and also using "view patterns" there... :/
05:04:02 <jophish> merijn: It would be uesful here, but perhaps there's a better way of doing that I'm trying to do
05:04:22 <mauke> Gurkenglas: no idea what that is
05:04:52 * hackagebot conduit-extra 1.1.7.0 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.7.0 (MichaelSnoyman)
05:04:55 <wacco> CindyLinz: Do all the things!
05:04:57 <jophish> merijn: very cool!
05:05:04 <Gurkenglas> Hmm, from that sentence it must be something that implies f _|_ = _|_ => fix f = _|_
05:05:04 <hesiod> Is there a nicer (golfier) way to do listA `elem` permutations listB?
05:05:18 <merijn> jophish: There's some ugly cornercases, but other than that :)
05:05:41 <jophish> What I'm trying to do is create a class for type level lists which don't contain duplicates
05:05:51 <merijn> jophish: i.e. "foo 1" doesn't work without explicit type for 1 because it can't prove that 1 won't be an Int or () (which applies to any polymorphic value)
05:05:56 <mauke> Gurkenglas: yeah, if f is strict, then _|_ is a fixed point of f.
05:06:22 <mauke> Gurkenglas: as 'fix f' returns the least defined fixed point of f, it'll always give _|_ on strict functions
05:06:25 <CindyLinz> wacco: XD  I didn't use multi-way-if frequently.. However, it's really convenient sometimes.. @@"
05:06:35 <merijn> jophish: Right, I would use either this trick or just a function that returns a type of kind Bool and then do "Unique xs ~ True" as predicate
05:06:44 <Gurkenglas> "least defined"?
05:07:08 <JonReed> Hi Haskellers. Functions like "myfunc arg1 = f1 $ f2 arg1", get prettier with pointfree style "myfunc = f1 . F2" (e.g. "f = print . show" vs "f str = print $ show str"). But what about two arguments? If I have myfunc arg1 arg2 = f1 $ f2 arg1 arg2", then pointfree version looks like "f = (f1 .) . f2", which is a bit ugly. Is there any way to make more than one argument functions like "replicateList n l = concat $ replicate n l"  even 
05:07:24 <mauke> Gurkenglas: yeah, like [undefined, Just undefined, Just ()] are progressively more defined
05:07:38 <jophish> merijn: I think your gist has a pretty good solution, I'll give it a try!
05:07:42 <jophish> thanks
05:07:47 <merijn> jophish: I would just do "replicateList n = concat . replicate n"
05:07:48 <merijn> eh
05:07:54 <merijn> s/jophish/JonRead
05:08:14 <merijn> JonReed: I think a lot of people are over focused on making everything pointfree
05:08:37 <Gurkenglas> That sounds like "more-defined"ness is not a total relation
05:08:40 <JonReed> merijn: Oh, great. That option skipped my mind.
05:08:45 <merijn> JonReed: :)
05:08:51 <mniip> JonReed, .:
05:08:56 <mniip> or something like that
05:08:56 <mauke> Gurkenglas: right
05:09:02 <merijn> mniip: Isn't actually in Prelude
05:09:05 <mniip> true
05:09:15 <merijn> So you first have to define .: also I find it very confusing to read, tbh
05:09:38 <Gurkenglas> Like, which is less defined, undefined : [] or [] : undefined
05:10:02 <mniip> Gurkenglas, (undefined, ()) vs ((), undefined) is a harder choice
05:10:19 <mauke> same thing, modulo types
05:10:49 <Gurkenglas> Or is there some theorem that if both are fixed points, then they must have a common lesser fixed point?
05:11:00 <Gurkenglas> *lesser defined
05:11:06 <mniip> sounds like a beleivable fact
05:11:16 <mniip> as long as the type is the same of course
05:11:21 <merijn> I believe it's a partial ordering
05:11:43 <Gurkenglas> Yea, that's what I said :P
05:11:46 <mniip> well, given how all values are trees
05:11:55 <mniip> it's not very hard to prove
05:11:57 <Gurkenglas> So then is there such a theorem or am I elsehow confused?
05:12:22 <Saizan> Gurkenglas: every two values have a lub
05:12:32 <mniip> did you know, you can create your own theorems
05:12:51 <Saizan> or is it glb? glb
05:12:58 <Gurkenglas> lub... "least upper bound"?
05:13:05 <Gurkenglas> greatest lower bound :D
05:13:15 <Saizan> anyhow, e.g. between undefined : [] and [] : undefined you have undefined : undefined
05:13:23 <Gurkenglas> but then the question is whether the glb of fixed points is also a fixed point
05:14:53 * hackagebot wai 3.0.2.3 - Web Application Interface.  http://hackage.haskell.org/package/wai-3.0.2.3 (MichaelSnoyman)
05:15:03 <jophish> merijn: I got it working, but the error messages are pretty unhelpful. I'll keep hacking, thank you for the help
05:15:33 <Saizan> Gurkenglas: iirc, yes, you get like a complete partial order of fixed points
05:17:32 <Gurkenglas> Saizan, you mean that the fixed points are always exactly all the ubs of their glb?
05:19:08 <Saizan> Gurkenglas: mh, i'm not sure about that
05:19:18 <joneshf-laptop> Is there any way to get more verbose `-fwarn-incomplete-patterns` ?
05:19:23 <joneshf-laptop> with ghc
05:19:53 * hackagebot wai-extra 3.0.4.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.4.2 (MichaelSnoyman)
05:20:12 <Saizan> Gurkenglas: i've only a cursory knowledge of domain theory :) mostly the stuff in http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
05:20:31 <Gurkenglas> Ooh shiny link.
05:21:49 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/120957
05:22:04 <funfunctor> how am I screwing up this bracket implementation?
05:22:33 <Gurkenglas> Is (f :: Maybe () -> ()) strict?
05:22:48 <mauke> Gurkenglas: depends
05:22:59 <funfunctor> I can't run a simple program with it like main = withNullDevice 0 $ do { writeSamples 3 }
05:23:26 <Gurkenglas> Let's say I implement it via f Just () = () \n f Nothing = ()
05:24:02 <mauke> that looks strict to me
05:24:04 <Saizan> Gurkenglas: that one is strict, because f undefined = undefined
05:24:22 <Saizan> Gurkenglas: however the syntax is f (Just ()) = ()
05:24:39 <Saizan> Gurkenglas: f _ = () would be lazy
05:24:45 <mauke> other versions: f _ = undefined; {- strict -}  f _ = () {- non-strict -}
05:24:49 <Saizan> ehm, non-strict
05:25:00 <Clint> funfunctor: that's a type error
05:25:15 <Clint> funfunctor: oh, i misread
05:25:15 <mauke> the first one is counterintuitive if you think of "strict" as "looks at its argument"
05:26:01 <funfunctor> Clint: its definitely a type error but I am not sure how to fix things properly
05:27:16 <funfunctor> Clint: pretty sure that evalStateT (lift m) .. is the wrong thing to do
05:28:10 <Clint> funfunctor: yeah, why are you doing that
05:28:20 <rui> marijn, I am interested. I just wrote my almost first little module, and for some inputs the stack gets full. Plus, speed isn't great. I don't totally understand the outputs of the profilers, so I think I need at least some better grasp on all the memory management stuff
05:28:30 <funfunctor> Clint: I was chasing type-errors while getting lost thats why
05:28:54 <rui> merijn:
05:28:58 <jophish> Is there a way to attach a constraint to the input to a type family?
05:29:21 <Clint> funfunctor: i think you should try the bracket from lifted-base, and make startNullDevice and stopNullDevice of types MonadIO m => m whatever
05:30:36 <funfunctor> Clint: lifted-base?
05:30:55 <Clint> @hackage lifted-base
05:30:55 <lambdabot> http://hackage.haskell.org/package/lifted-base
05:31:03 <funfunctor> Clint: I replaced lift m with unNullDevice is that right?
05:31:52 <funfunctor> nar too many transformers, must be simpler than this..
05:32:11 <Clint> funfunctor: you don't want m a -> m a; you want NullDevice a -> IO a or something
05:33:01 <funfunctor> Clint: for runNullDevice ?
05:33:05 <funfunctor> sounds right
05:33:06 <Clint> yes
05:34:53 * hackagebot shakespeare 2.0.4.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.4.1 (MichaelSnoyman)
05:35:14 <funfunctor> Clint: and what to put in front of m so it type checks?
05:35:57 <Clint> funfunctor: which m
05:36:51 <funfunctor> Clint: runNullDevice :: Double -> NullDevice a -> IO a
05:36:51 <funfunctor> runNullDevice sr m = evalStateT m (HwState sr, 0, 0, 0, getCurrentTime, False)
05:37:11 <wagle> @hoogle (Int, Int) -> Bool
05:37:11 <lambdabot> Text.Regex.Base.RegexLike extract :: Extract source => (Int, Int) -> source -> source
05:37:11 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
05:37:11 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
05:37:18 <Clint> funfunctor: oh, yes, you want to unwrap the newtype
05:37:44 <funfunctor> Clint: so I tried unNullDevice m but still does not type check
05:38:03 <Clint> funfunctor: what's the error?
05:38:41 <funfunctor> Clint: Couldn't match expected type `HwState' with actual type `(Integer-> Integer -> TimeStamp -> UTCTime -> Bool -> HwState, bla bla bla..
05:39:05 <bennofs> funfunctor: oh, I think you need to write HWSate sr 0 0 0 0 ...
05:39:10 <bennofs> funfunctor: without the ,
05:39:21 <merijn> rui: A space leak like that is most likely due to insufficient laziness, but I have to run so I don't have time to explain that, maybe someone else can go over that. A good thing to google would be foldl vs foldl' which is the classic space leak
05:39:55 <funfunctor> bennofs: ahhhhhhhhhhhhhhhhhhhhhh! wow that was confusing!
05:41:42 <bennofs> runde: also, you will probably need to lift out the getCurrentTime, since you need to bind the value of that IO action via >>= first
05:41:47 <funfunctor> and to handle Couldn't match expected type `UTCTime' with actual type `IO UTCTime' for In the fifth argument of `HwState', namely `getCurrentTime'
05:41:56 <funfunctor> I need the value out of that action
05:42:05 <bennofs> funfunctor: yes, and you can use >>= for that
05:42:16 <bennofs> (>>=) :: IO a -> (a -> IO b) -> IO b
05:42:33 <bennofs> funfunctor: so getCurrentTime >>= \x -> ...   here x is of type UTCTime in ...
05:43:12 <bennofs> funfunctor: (you could also write it using do notation, writing it as do { x <- getCurrentTime; ... })
05:43:47 <funfunctor> bennofs: yea I know the do notation I am just trying to work out how the lambda expression goes with >>=
05:44:47 <funfunctor> :t const
05:44:48 <lambdabot> a -> b -> a
05:45:12 <lf94> Hey, I want to liftA 50 values, what are my options?
05:46:06 <Clint> a whole lotta <*>
05:46:43 <funfunctor> bennofs: yea how would getCurrentTime >>= \x -> ...    work?
05:46:43 <rui> Ok, thanks merijn
05:46:51 <hpc> your best option is to not liftA 50 values
05:47:17 <hpc> write your problem differently
05:47:29 <funfunctor> :t id
05:47:29 <lambdabot> a -> a
05:49:25 <lf94> Clint: how does <*> help?
05:49:31 <lf94> @type Applicative
05:49:31 <lambdabot> Not in scope: data constructor ‘Applicative’
05:49:44 <Clint> lf94: maybe i misunderstood what you meant by "liftA 50 values"
05:50:12 <mniip> foldr (<*>) xD
05:50:14 <funfunctor> there is other liftA3 and so on
05:50:58 <lf94> Clint no you are right, I've seen people using <*> to lift things
05:51:02 <bennofs> lol this GHC error:
05:51:03 <bennofs> <interactive>:25:13:
05:51:05 <bennofs>     My brain just exploded
05:51:45 <bennofs> > let SomeException e = toException ThreadKilled in e
05:51:47 <lambdabot>  My brain just exploded
05:51:47 <lambdabot>  I can't handle pattern bindings for existential or GADT data constructors.
05:51:47 <lambdabot>  Instead, use a case-expression, or do-notation, to unpack the constructor.
05:52:37 <lf94> I have this long data constructor with 50 parameters, and the parameters are filled by a type Parser a
05:52:48 <lf94> I've seen someone do
05:53:09 <lf94> MyLongConstructor <$> thingToGetValue <*> thingToGetValue
05:53:18 <bennofs> lf94: 50 paramters? :O
05:53:22 <hpc> lf94: yeah, you want to not have such a long constructor
05:53:31 <hpc> it's a maintenance nightmare waiting to happen
05:53:44 <lf94> it's not my choice
05:53:48 <mniip> last time I checked there was a limit somewhere
05:53:49 <lf94> it's the will of the universe
05:54:31 <bennofs> :t liftA5
05:54:32 <lambdabot>     Not in scope: ‘liftA5’
05:54:32 <lambdabot>     Perhaps you meant one of these:
05:54:32 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
05:54:34 <bennofs> :t liftA4
05:54:35 <lambdabot>     Not in scope: ‘liftA4’
05:54:35 <lambdabot>     Perhaps you meant one of these:
05:54:35 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
05:54:39 <lf94> rip
05:54:45 <bennofs> :t liftA3
05:54:46 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
05:55:43 <lf94> So how do you implement that with just <$> and <*>
05:56:02 <hpc> @src liftA3
05:56:02 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:56:06 <saep> lf94: TheBigConstructorName <$> parserField1 <*> parserField2 <*> ... <*> parserField50 -- although this will break if the contructor's arguments are changed in order
05:56:55 <lf94> yeah I'm aware
05:57:06 <saep> Also, the input stream must be in the same order as the parsers.
05:57:44 <saep> (i.e. the constructor's fields)
05:58:03 <funfunctor> bennofs: i'm still not completely clear how to get the value out of the io action getCurrentTime using the monadic thingy >>=
05:58:19 <sx> Can anyone explain how I incorporate the ST monad into a monad transformer stack? The rank-2 type confuses me.
05:58:56 <bennofs> > getCurrentTime >>= \t ->    ... do something with t :: CurrentTime here ...
05:58:57 <lambdabot>  <hint>:1:29: parse error on input ‘...’
05:59:07 <bennofs> > getCurrentTime >>= \t -> putStrLn (t + 1)
05:59:08 <lambdabot>  Not in scope: ‘getCurrentTime’
05:59:16 <bennofs> well, you get the idea :)
06:00:23 <funfunctor> bennofs: yea but I just wants its value in  runNullDevice sr m = evalStateT (unNullDevice m) (HwState sr 0 0 0 (getCurrentTime >>= ) False)
06:01:30 <bennofs> funfunctor: ah it doesn't work that way. The whole thing with >>= is of type IO something, so you cannot use it in the field where UTCTime is expected
06:01:34 <funfunctor> bennofs: correct me if i'm wrong but that can't be done
06:01:44 <funfunctor> yea
06:02:08 <bennofs> funfunctor: instead, you use it like this: runNullDevice sr m = getCurrentTime >>= \curTime -> evalStateT (unNullDevice m) (HwState sr 0 0 0 curTime False)
06:02:29 <funfunctor> ahhh
06:02:37 <funfunctor> derr moment..
06:03:48 <lf94> yeaaaa i'm at the 3rd field of 50 and things are looking bad.
06:03:55 <lf94> rip
06:04:24 <phaul> you consturcting shades of grey? :D
06:05:04 <lf94> 50 lifts of a
06:05:10 <mniip> lf94,
06:05:13 <mniip> > let var = take 50 [x:xs | xs <- []:var, x <- ['a'..'z']] in "liftA50 f' " ++ concat (intersperse " " var) ++ " = f' <$> " ++ concat (intersperse " <*> " var)
06:05:14 <lambdabot>  "liftA50 f' a b c d e f g h i j k l m n o p q r s t u v w x y z aa ba ca da ...
06:05:23 <mniip> if that helps :)
06:05:29 <funfunctor> wonderful, thanks bennofs
06:07:20 <wacco> https://github.com/Meeuwisse/IRC/blob/master/client.hs // Line 66 is just.. ignored.
06:07:35 <lf94> yeah i need to take advantage of laziness still
06:07:45 <wacco> How'd you debug such a thing?
06:08:47 <funfunctor> and things work.. good sign
06:08:57 <notdan> wacco: I'dsay use DebugTrace to trace the value of d
06:09:10 <wacco> *googles debugtrace*
06:09:12 <sx> How do I make this work? Am I using ST wrong? http://codepad.org/tJKlRmzZ
06:09:32 <notdan> oops it was supposed to be Debug.Trace
06:09:39 <wacco> no worries, found it ;)
06:10:52 <wacco> not sure what else it'll tell me though
06:10:57 <wacco> I already see the strings after all
06:12:00 <wacco> anyway, can't hurt to try
06:12:16 <mniip> wacco, because it's not ACTION
06:13:02 <mniip> also don't use 'isInfixOf' to parse IRC D:
06:13:08 <mniip> there's an easily parsable syntax there
06:13:16 <mniip> so easy you can do it with pattern matching only
06:13:24 <wacco> I'm up for suggestions
06:13:37 <wacco> biggest frustration so far is the splitOn
06:13:40 <m-r-r> Hello
06:14:33 <wacco> hi m-r-r
06:14:38 <m-r-r> How do I remove new lines caracters from the end of a String ?
06:14:40 <ab9rf> i'd just use parsec/attoparsec :)
06:14:55 * hackagebot yeller 0.1.0.2 - A Yeller Client For Haskell  http://hackage.haskell.org/package/yeller-0.1.0.2 (TomCrayford)
06:15:05 <m-r-r> ab9rf: o_O
06:15:26 <mniip> m-r-r, he's referring to IRC syntax, not newlines lol
06:16:00 <ab9rf> m-r-r: if you're parsing something in haskell, parsec and attoparsec are almost always considerations
06:16:06 <mniip> wacco, I have some code that operates on Bytestrings
06:16:16 <mniip> in String it would look a bit nicer
06:16:22 <ab9rf> mniip: ftr, i'm not a "he" :)
06:16:33 <boj> hello. i am a week old haskell newbie, so given that reference: by adding a system time value to a record to compare later, do i condem that record to being impure?
06:16:49 <ab9rf> the best way to remove newlines from a strng is noit to put them there in the first place :)
06:17:06 <mauke> boj: no, and I don't know what an "impure record" would even be
06:17:09 <mniip> ab9rf, from now on you're a "they" :)
06:17:16 <ab9rf> boj: i don't understand what you mean by an "impure record"
06:17:24 <boj> i am not sure how to phrase it, let me try again
06:18:06 <srhb> boj: You mean you will end up with IO MyRecordWithTime ?
06:18:09 <boj> i have a record with a value to track time, which comes from the IO world.  i want to compare that time to a future time, in my "pure" code.  i am not advanced enough to figure out how, or if i even can, do it
06:18:35 <ab9rf> you just have to "imbed the computation within the IO monad"
06:19:03 <ab9rf> which sounds scary but is actually so easy that you will do it without even thinking about it before long
06:19:22 <boj> let's say that Io comparison compuation updates a different field of the record. that is possible?
06:19:29 <srhb> boj: do { pureRecord <- yourRecord; pureThing pureRecord; morePureThing pureRecord; return pureRecord } -- something like that
06:20:04 <rui> Say I have a recursive list, like fibs = 1:1:(zipWith (+) fibs (tail fibs)). And I want to access its 100th element and then throw it away, or keep its tail. But I don't care any more about the first hundred elements.
06:20:09 <mniip> sigh
06:20:24 <mniip> ext2fsd is broken again
06:20:25 <rui> Can one do that in a way that the memory gets released as you go along the list?
06:20:33 <mniip> wacco, looks like I'll not be getting you the code anytime soon
06:20:51 <wacco> ok..?
06:21:01 <mniip> anyway
06:21:08 <mniip> a CTCP ACTION is actually
06:21:14 <mniip> \1ACTION text\1
06:23:49 <wacco> I'm just waiting 'till one passes by, let's see what trace tells me ;)
06:23:51 <lf94> Why does this cause stack overflow? show (Item a b c) =  Prelude.show a ++ "\n"
06:24:58 <wacco> (meanwhile figuring out how to make a generic function for joined / parted / quit)
06:25:47 <mniip> lf94, what is the type of a
06:26:15 <mniip> also that's a weird way to use show
06:26:38 * mniip does a test action for wacco
06:26:45 <wacco> :D thanks
06:26:57 <wacco> nothing special though.. it should just match
06:27:26 <lf94> mniip: a is String
06:27:31 <lf94> b and c are Centi
06:27:57 <boj> srhb: i think you grasped what i meant.  i can: do {pureRecord <- yourRecord; return pureRecord} where yourRecord might apply an IO value to one of it's fields? i can get it back as foo :: Record -> Record, not foo :: Record -> IO Record?
06:28:36 <mniip> wacco, but yeah, in general irc messages are somthing like
06:28:39 <srhb> boj: If yourRecord is of type IO MyRecordWithSystemTime, then pureRecord is of type MyRecordWithSystemTime
06:29:01 <mniip> data IRCMessage = IRCMessage { source :: Maybe String, arguments :: [String] }
06:29:16 <boj> srhb: i believe i understand now, thanks
06:29:35 <mniip> if the first character is a :, the first word goes into the source, otherwise source is Nothing
06:29:46 <mniip> the other words are split by spaces until you met one beginning with :
06:29:57 <mniip> then you grab the rest of the string into the last word (sans the : itself)
06:29:58 <srhb> boj: Sure thing. Mind, if you've touched upon functors, do { foo <- bar; return (fun foo) } is identical to fmap fun bar -- ignore this if it made no sense.
06:30:24 <srhb> boj: Or in other word, if f works on YourRecord, fmap f works on IO YourRecord
06:30:31 <mniip> a thing to keep in mind is that there can be empty words
06:30:32 <srhb> (or any functor F YourRecord)
06:30:35 <phaul> lf94: Show for String s is just `id'. you don't need to call Show, that aside, the stack overflow is somewhere else I beleive. Is a finite? What's the length of a?
06:30:54 <lf94> a is never that long
06:30:54 <ab9rf> boj: in general you don't want to store values of type IO a in records, instead store the value of a in the record and imbed the entire record in IO
06:30:55 <lf94> but
06:31:16 <lf94> I am using "print (a :: Vector Receipt)"
06:31:24 <ab9rf> phaul: show for String is not id; it adds quotes and escapes certain characters
06:31:44 <phaul> ok. my mistake
06:31:46 <ab9rf> > ("catfood", show "catfood")
06:31:47 <lambdabot>  ("catfood","\"catfood\"")
06:32:06 <wacco> sudden social obligations, gotta go! D:
06:32:22 <hpc> > (text "catfood", "catfood") -- lambdabot has ways around it
06:32:23 <lambdabot>  (catfood,"catfood")
06:32:33 <ab9rf> hpc: heh
06:32:40 <boj> ab9rf: ok, that may have confirmed my suspicion.  at that point, the record has to live in IO?
06:32:55 <ab9rf> boj: no, the computation has to be imbedded in IO
06:33:28 <matt3148> does anyone know how to do this? ((a -> b) -> a -> IO b) -> (a -> b) -> IO (a -> b)
06:33:32 <srhb> boj: What ab9rf is suggesting is this instead: do { pureTime <- ioTime; let pureRecord = makeRecord pureTime; ... many things ... }
06:34:02 <srhb> boj: So for the duration of "... many things ..." the record never has an IO stuck on it.
06:34:04 <ab9rf> something in that nature
06:34:33 <ab9rf> boj: i have a big hunk of code that does gobs of file and database operations, all of which are in IO
06:34:53 <mniip> matt3148, const return
06:34:54 <ab9rf> but you won't see IO on any of the values involved
06:35:00 <mniip> although it probably doesn't do what you want
06:35:06 <ab9rf> because it's all imbedded in the IO monad
06:35:09 <boj> srhb: so in that case, even though my IO time comes back as "IO Int" i can (and this is the part i am struggling with) set the Int value of the record to it?
06:35:27 <matt3148> mniip: I should probably expand on it
06:35:29 <srhb> boj: ioTime :: IO "Int", but pureTime :: "Int"
06:35:37 <srhb> boj: And by "Int" I mean UTCTime or something
06:35:38 <boj> maybe not after the how so much as "it's possible""
06:35:48 <boj> yes, UTCTime is what i am using
06:35:50 <matt3148> I have a function f :: (Read a, Read b, Show a, Show b) => (a -> b) -> a -> IO b
06:35:52 <ab9rf> boj: in 'do { time <- getTime; .... }' time is bound with an Int (assumig getTime is IO Int}
06:36:19 <matt3148> which pretends to serialise the argument to the (a -> b) function and deserialise the result, in IO
06:36:34 <srhb> boj: Basically, this is what <- does. It peels off the Monad part of the right hand side and gives you back the inner type on the left hand side.
06:36:36 <matt3148> what I need a a function g :: (Read a, Read b, Show a, Show b) => (a -> b) -> IO (a -> b)
06:36:37 <ab9rf> matt3148: why does that need to be in IO? serialization is a pure operation.
06:36:51 <matt3148> ab9rf: it'll be sent over the network
06:36:59 <srhb> boj: (In reality it's more like lifting the rest of the functions in your do block to work on an IO type, but this is subtly hidden in do notation)
06:37:03 <ab9rf> matt3148: but it doesn't actually send it, does it?
06:37:09 <ab9rf> don't imbed in IO unnecessarily
06:37:23 <srhb> boj: Perhaps you should consider reading about what do notation is syntax sugar for.
06:37:24 <matt3148> I'll share a code snippet
06:37:24 <ab9rf> srhb: yeah, i wasn't going to bring up lifting
06:37:45 <boj> srhb: (and everyone), thanks.  i believe i get it now.  may be back, but this tired mind seems to have grasped something
06:37:53 <lpaste> matt3148 pasted “Kernel Prototype” at http://lpaste.net/1654409020028485632
06:37:54 <srhb> boj: Cool :) Good luck.
06:38:53 <matt3148> I'm trying to make a way of making function calls over the network in a typesafe way
06:45:52 <matt3148> ab9rf: does that make sense?
06:48:33 <fr33domlover> `cabal install tasty` says that 'darcs-2.8.5' will likely be broken by the installation
06:48:51 <fr33domlover> does it make sense? how to I get them both installed in harmony?
06:52:02 <jophish> What's the procedure for getting a term from a type when using DataKinds?
06:54:04 <bennofs> jophish: use data Proxy (t :: k) = Proxy?
06:54:20 <bennofs> jophish: so Proxy :: Proxy <your type here>    is a term
06:55:25 <jophish> I'm not sure that's exactly what I mean. I'm trying to go from type True with kind Bool to term True with type Bool
06:56:59 <bennofs> jophish: what does that mean? Can you explain what you need it for=
06:58:11 <jophish> bennofs: For example I have a type FixedArray (n :: Nat) (a :: *), and want to implement length :: Array n a -> Int
06:58:39 <bennofs> jophish: for Nat, there is the KnownNat typeclass
06:58:43 <jophish> natVal from GHC.TypeLits does thig
06:59:04 <jophish> exaclty, is there a general way for things promoted with DataKinds?
06:59:45 <bennofs> jophish: iirc singular types can do that
06:59:56 <bennofs> s/singular/singleton
07:00:02 <bennofs> @hackage singletons
07:00:02 <lambdabot> http://hackage.haskell.org/package/singletons
07:00:09 <notdan> Is there a library for parsing arithmetic expressions?
07:00:22 <bennofs> notdan: parsec has a generic expression parser
07:00:37 <bennofs> http://hackage.haskell.org/package/parsec-3.1.8/docs/Text-Parsec-Expr.html
07:00:49 <notdan> Yeah I know, but I don't want to roll my own parser
07:01:05 <jophish> bennofs: exactly what I'm looking for! Thanks!
07:01:45 <matt3148> do you guys get a lot of messages of the form ':r' in here? :)
07:01:49 * matt3148 almost sent one
07:01:55 <bennofs> matt3148: never seen one
07:02:00 <matt3148> hmm
07:02:04 <sx> runReaderT seems to remove the quantification (which is needed for runST), can anyone shed some light on this? http://codepad.org/r26avtbc
07:02:06 <bennofs> matt3148: although i've seen vim commands in other channels :
07:03:11 <bennofs> sx: impredicativetypes is nearly always a bad idea. it doesn't work well
07:03:30 <bennofs> sx: you should instead move the s to another argument for Foo
07:04:02 <bennofs> sx: as in: newtype Foo s a = Foo { unFoo :: ReaderT () (ST s) a }
07:04:26 <bennofs> sx: not quite sure if newtype Foo a = Foo { unFoo :: forall s. ReaderT () (ST s) a } works as ell
07:04:32 <sx> bennofs: I tried that already, with no success. :/
07:04:53 <sx> bennofs: both variants
07:05:41 * bennofs loads his GHCi
07:06:08 <sx> bennofs: I thought I understood rank-n types, but I can't get that code to work. Also I can't find any example where ST ist used as part of a monad transfomer stack.
07:07:42 <bennofs> sx: advice: always eta-expand arguments to runST (don't write runST . <bla>, but runST $ bla ...)
07:07:50 <bennofs> sx: with that change, variant 2 works
07:08:10 <sx> bennofs: Wow, thanks, didn't expect that.
07:08:24 <bennofs> sx: GHC's type checker has some hardcoded hacks to make it work with ($)
07:08:26 <ab9rf> i've uised ST alone
07:09:16 <bennofs> sx: (you also don't need ImpredicativeTypes with variant 2)
07:10:28 <rui> (I got d/c and am unsure if someone spoke to me. Sorry or repeat if that's the case)
07:10:39 <rui> (and no prob if its not :P)
07:11:17 <sx> bennofs: Ok, back to my starting problem I replaced (.) with ($) and it worked, that's everything else than intuitive. Thank you very much.
07:11:57 <matt3148> would someone mind helping me?
07:12:15 <matt3148> I asked a question earlier, but the people talking seemed to disappear
07:12:23 <bennofs> matt3148: what was your question?
07:13:22 <matt3148> bennofs: given functions f :: (Read a, Read b, Show a, Show b) => (a -> b) -> a -> IO b and g :: (Read a, Read b, Show a, Show b) => (a -> b) -> IO (a -> b), how can I create g so that it calls f when the function is evaluated?
07:13:42 <matt3148> I have a code snippet that shows the context, if that would help
07:13:46 <matt3148> (I think it will)
07:14:13 <matt3148> http://lpaste.net/1654409020028485632
07:14:36 <matt3148> it definitely seems like it should be possible, since IO isn't 'escaping' anywhere
07:14:59 * hackagebot descriptive 0.9.1 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.9.1 (ChrisDone)
07:15:32 <funfunctor> alright suppose I have data Foo = Foo { myfunc :: Int } and I want a implementation of this that is mycustomfunc :: MyState Int, how can I fix Foo such that the type-signature is agnostic of the MyState monad?
07:15:45 <bennofs> matt3148: it won't work. remoteF :: a -> IO b, right? and you want to make remoteF' :: IO (a -> b)
07:15:58 <matt3148> yeah
07:16:12 <funfunctor> data Foo = Foo { myfunc :: Monad m => m Int } something like this?
07:16:34 <matt3148> logically, that should be possible shouldn't it?
07:16:38 <bennofs> matt3148: well, assume for a moment it would work. Let's also assume a and b are ints for simplicity
07:16:48 <matt3148> ok
07:17:03 <bennofs> matt3148: then define h :: (Int -> Int) -> Int; h f = f 3 + f 5
07:17:36 <bennofs> matt3148: now: do remoteF'' <- remoteF; putStrLn $ h remoteF''
07:18:01 <bennofs> matt3148: see how the IO actions performed depends on the concrete evaluation order of the pure function h?
07:18:32 <matt3148> bennofs: give me an hour and I might :)
07:18:39 <bennofs> matt3148: that shouldn't be possible, since the evaluation order is really implementation dependent (is f 3 evaluated first or f 5?)
07:18:59 <nshepperd> funfunctor: data Foo m = Foo { myfunc :: m Int }
07:19:11 <bennofs> matt3148: or, even easier example:  do remoteF'' <- remoteF';  print $ remoteF'' 3 + remoteF'' 5
07:19:22 <funfunctor> nshepperd: yea I was thinking about that
07:19:35 <funfunctor> what if you have multiple type variables
07:19:43 <funfunctor> ah actually never mind
07:19:44 <funfunctor> :)
07:27:20 <rui> Is there built-in strict equivalents to zipWith, zipWith4, etc? I mean, that force evaluation of the "previous" elements to the one required
07:29:43 <lpaste> bennofs pasted “unsafePerformIO example” at http://lpaste.net/120974
07:30:05 <bennofs> matt3148: ^^^ look at that paste. run test in GHCi and see what happens
07:30:45 <bennofs> matt3148: but do not do this in real code, ofc. This is only to demonstrate the problems doing this kind of stuff would cause :)
07:31:52 <matt3148> bennofs: thanks, I'll have a think about it
07:33:15 <narendraj9> tryhaskell.org/haskell.json is return a bad gateway 502 error. What should I do?
07:33:18 <narendraj9> *returning
07:34:00 <bennofs> narendraj9: what would that do?
07:35:23 <narendraj9> bennofs: Evaluate haskell expressions. I am using the hubot script haskell.coffee
07:36:20 <matt3148> bennofs: thanks, that was very helpful
07:36:38 <matt3148> I think the nondeterminism is fine, though
07:36:47 <bennofs> matt3148: ew? really?
07:36:55 <bennofs> matt3148: please do not use unsafePerformIO
07:37:06 <matt3148> the name is rather offputting, yes
07:37:18 <narendraj9> http://tryhaskell.org/haskell.json?method=eval&expr=23*52 should return json. It is not. Something is wrong with the site. chrisdone please help!
07:37:20 <bennofs> matt3148: it is not for normal programming, it is a hack for FFI
07:37:34 <matt3148> what I was trying to do was make it possible to call a pure function over the network
07:37:44 <matt3148> and have the compiler reject a program that isn't typesafe
07:38:38 <bennofs> matt3148: just saying you should think really hard if there is no way to redesign your program to not require such an unsafe function
07:39:05 <bennofs> matt3148: but your use case sounds a little bit similar to the FFI case
07:39:25 <bennofs> matt3148: but what do you do if there is a network error?
07:39:42 <danilo2> Hello! What alternative to monad transformers is he most promising / gives the best benefits? We've got extensible-effects and layers packages , but proba ly there could be more such packages. Could anybody tell me "which one could be the future of monad transformers" ? :)
07:39:52 <matt3148> let the application die? :P
07:40:28 <YaRly> Ok, this error is driving me crazy: unknown symbol `_shutdownWinSock' network, unable to load package `network-2.6.0.2'.  I've installed it already, and have been trying to fix it for 3 hours now, I'm using win 8.1
07:42:02 <matt3148> bennofs: I think the proper solution probably involves monads
07:42:09 <matt3148> I should hurry up and learn those
07:42:38 <bennofs> matt3148: the proper solution is to just make things that do IO require IO :)
07:42:52 <matt3148> the thing that inspired me was a quote from a blog post: "The way Haskell separates pure computations from side effects let us build something that isn’t practical with other languages: We built a custom monad that lets us “switch off” side effects in our tests."
07:42:59 <matt3148> that's what I was trying to emulate
07:43:49 <bennofs> matt3148: ah. yes, you can do that with a monad
07:44:08 <bennofs> (often a free monad)
07:44:47 <matt3148> I write Java for a living, and I get sick of firing up an 'integration test runner', which creates a database instance etc. etc. and takes about 3 hours to run all the tests
07:45:05 <matt3148> any solution must be better than that :)
07:46:49 <bennofs> matt3148: to be fair, you can also mock classes in java
07:47:12 <matt3148> indeed
07:55:07 <funfunctor> exciting.. some progress
07:59:26 <rui> It woooorked :). nice
08:02:06 <rui> Now, I wonder if there's some simple way to get a list with the inputs from the mic at real time
08:02:48 <rui> and some way of streaming output given in a list, also real time. Time to google and hope
08:05:08 <benzrf> oy, the spam
08:05:16 <benzrf> ah nvm i had filters off
08:08:27 <danilo2> Hello! What alternative to monad transformers is he most promising / gives the best benefits? We've got extensible-effects and layers packages , but proba ly there could be more such packages. Could anybody tell me "which one could be the future of monad transformers" ? :)
08:08:53 <cfoch> Hello. I have a problem of identation or IDK with this code:  http://fpaste.org/188950/14246210/
08:08:58 <cfoch> could somebody help me please?
08:09:11 <cfoch> line. 182
08:09:34 <Gurkenglas> http://comonad.com/reader/2015/free-monoids-in-haskell/ <- After "Considering some additional equations", it assumes: [1,1..] = [1,1..] <> [1]. But isn't that like asking for the last digit of pi?
08:10:46 <barrucadu> cfoch: That let is indented by one space, but everything before it is indended by two spaces. Is that intentional?
08:11:56 <bennofs> cfoch: btw, I think lpaste has better syntax highlighting for haskell code
08:11:59 <bennofs> @where lpaste
08:11:59 <lambdabot> http://lpaste.net/
08:12:03 <muzzle> why does (cabal configure --enable-executable-profiling) not work for a project of mine ?
08:12:18 <Gurkenglas> (Um, h on both sides.)
08:12:24 <bennofs> muzzle: please describe "not work"
08:12:43 <cfoch> bennofs: this is very confusing, in my computer it has 2 spaces
08:12:43 <muzzle> bennofs: cabal: unrecognized 'configure' option `--enable-executable-profiling'
08:12:45 <cfoch> :S
08:12:48 <Gurkenglas> (Scratch that last line.)
08:13:35 <bennofs> muzzle: oh, right. it seems to be --enable-profiling with newer cabal versions
08:14:10 <cfoch> bennofs: http://i.imgur.com/bQcYWxy.png
08:14:21 <barrucadu> I'm not bennofs :p
08:14:24 <utdemir> Hey. I'm having a hard time writing the transformer of a monad I wrote. Can anyone guide me? http://lpaste.net/1650763413132935168
08:14:32 <utdemir> Just can't get the types right...
08:14:38 <Gurkenglas> Oh, they are equal in the sense that substituting one for the other in any formula changes nothing. I see.
08:14:40 <bennofs> cfoch: do you use tabs?
08:15:00 <cfoch> spaces
08:15:02 * hackagebot yeller 0.1.0.3 - A Yeller Client For Haskell  http://hackage.haskell.org/package/yeller-0.1.0.3 (TomCrayford)
08:15:31 <bennofs> cfoch: I think you need to indent the case past the begin of isInstalled
08:19:38 <wacco> http://paste2.org/_WgVt1dbs the hell
08:21:10 <CindyLinz> wacco: part of IRC client?
08:21:21 <cfoch> bennofs: I put it this way
08:21:21 <cfoch> http://dpaste.com/1C7HXC3
08:21:29 <cfoch> now it compiles
08:22:23 <wacco> yep. but I think I figured it out.. somebody (can't find it back now) earlier mentioned \x01 "quoting" for action messages
08:25:03 * hackagebot SmtLib 0.1.0.0 - Library for parsing SMTLIB2  http://hackage.haskell.org/package/SmtLib-0.1.0.0 (roger62)
08:25:25 <lpaste> karlek pasted “make solve with accumulator ” at http://lpaste.net/120977
08:26:31 <karlek> hi! i've got a function which becomes very slow with high n, how do I make the function solve into an accumulator.
08:27:06 <monochrom> when tibbe wrote "looking for cabal release manager", I thought he was looking for software. in fact, I misread so much as "cabal looking for package manager", and I was like "yes finally!"
08:27:26 <monochrom> alas, he was looking for a human to do releases
08:28:47 <wacco> that outta do it
08:29:23 <monochrom> karlek: I am too lazy to guess what this algorithm computes. what does it compute?
08:29:45 <monochrom> what does it compute, without describing the algorithm?
08:30:35 <karlek> monochrom: it calculates the number of trailing zeroes when it's even in 0!..1! ... n!
08:31:10 <monochrom> "0!...1!...n!"? not "1...n"?
08:31:23 <monochrom> that is, not simply "n!"?
08:31:40 <karlek> monochrom: exactly
08:32:12 <karlek> it calculates the number of even trailing zeroes so 5! = 0 but 10! = 2
08:32:20 <monochrom> so if n=4, you want the trailing zeros of 1*1*2*6*24?
08:33:31 <karlek> monochrom: no. Given the value of n, your job is to find how many of the values 0!,1!,2!,3!,...,(n−1)!,n! has even number of trailing zeroes.
08:38:45 <monochrom> ok, a suboptimal way is to: for each k, don't remember k!, but only to remember how many times the factor 2 and the factor 5 are in k!.
08:39:10 <monochrom> initially, k=0, so 2 happens 0 times, 5 happens 0 times.
08:39:32 <bennofs> monochrom: don't you only need to remember the number of the factor 5? you always have enough 2's in a factorial I think
08:39:42 <ab9rf> sounds like an euler problem
08:39:53 <karlek> it's a kattis problem
08:40:04 <karlek> https://open.kattis.com/problems/oddandevenzeroes
08:40:19 <monochrom> inductively, if you already know the answer for k!, then for (k+1)!, simply use trial division to find out how many times 2 and 5 happen in k+1, then add them to the answer for k!
08:40:44 <benzrf> whats the inverse of factorial
08:40:47 <monochrom> dear bennofs, this is why I claim that it is suboptimal
08:41:25 <ab9rf> benzrf: there's a generalized factorial (defined for all values other than n equal to a negative integer, at which it diverges)
08:41:51 <monochrom> to find out from "how many times 2 and 5 happen in k!" to "how many trailing zeros are in k!", you take min(how many times 2 happens, how many times 5 happens)
08:42:16 <ab9rf> i think uyou have to limit the domain to get a unique inverse
08:42:27 <ab9rf> because 0! = 1! and (1/2)! is less than 1
08:42:34 <Eduard_Munteanu> Yeah, gamma is definitely not invertible.
08:42:36 <monochrom> the optimal way is to remember none of the above, but only "does 5 happen even or odd number of times in k!"
08:43:50 <ab9rf> isn't the number of treailing zeros in k! just floor(k/5)?
08:44:46 <benzrf> ab9rf: no i dont think so
08:44:49 <ab9rf> Eduard_Munteanu: i couldn't remember if gamma was the generalized factorial
08:44:52 <benzrf> theres an extra one for each power of ten, or something
08:45:04 * hackagebot wai-middleware-throttle 0.1.0.0 - WAI Middleware for Request Throttling  http://hackage.haskell.org/package/wai-middleware-throttle-0.1.0.0 (ChristopherReichert)
08:45:05 <ab9rf> benzrf: no, 10! is 3628800
08:45:12 <ab9rf> oh, 100 add two zeros, you're right
08:45:15 <ab9rf> also 50 adds two
08:45:34 <ab9rf> so you have to add + floor(k/50)
08:45:58 <ab9rf> so sum (n <- 1..) floor(k/(5*10^n))
08:46:04 <ab9rf> er, 0..
08:47:47 <ab9rf> not a bad problem
08:48:36 <monochrom> ab9rf: if you have to do this for each k from 1 to n (different n from yours), is it as fast as my incremental strategy? especially the one that only keeps track of "does 5 happen even or odd number of times"?
08:50:04 * hackagebot jose-jwt 0.4.1 - JSON Object Signing and Encryption Library  http://hackage.haskell.org/package/jose-jwt-0.4.1 (LukeTaylor)
08:50:05 <monochrom> or is your k my n, and your n my k?
08:52:30 <Reisen> In ghci, how can I get :sprint to show partly evaluated structures as shown here? http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf
08:52:43 <Reisen> For some reason, :sprint only ever shows _ no matter what I do
08:55:46 <stephenmac7> Hello, I'm doing https://gist.github.com/merijn/098106abd45c940dab09 but am getting a strange error
08:55:56 <stephenmac7>     The second argument of ‘MyState’ should have kind ‘*’,
08:55:56 <stephenmac7>       but ‘m’ has kind ‘* -> *’
08:57:49 <ab9rf> monochrom: the formula i came up with requires log_10 k iterations to compute the value for k
08:58:19 <ab9rf> monochrom: that's probaly faster than an incremental strategy
09:00:15 <ab9rf> monochrom: that formula i gave is a closed form with an infinite sum that converges very quickly :)
09:00:29 <ab9rf> monochrom: i've been mulling how to generalize it to bases other than 10
09:01:48 <ab9rf> like it works for base 6 merely by replacing 5 with 3
09:02:02 <ab9rf> for prime bases, the problem is trivial
09:02:25 <geekosaur> stephenmac7, (MyState s a) is a value type (a fully saturated type). a value type cannot be a Functor. (for example, `Maybe` can have a Functor instance; `Maybe Int` can't.) so (MyState s) can potentially be a Functor, but (MyState s a) can't.
09:02:54 <stephenmac7> geekosaur: That isn't the part I wrote though
09:03:25 <stephenmac7> Changing it to "instance Functor (MyState s) where" works, ofc... but I can't figure out why merijn would write it that why
09:03:27 <stephenmac7> *way
09:03:45 <geekosaur> thinko, I'd guess, since the other ones are correct
09:04:06 <stephenmac7> Or why there's a class constraint Functor m =>
09:04:50 <geekosaur> that is, the Applicative and Monad instances have the correct form, the Functor one doesn't. I also suspect that the Functor constraint belonged on the Applicative instance...
09:04:51 <stephenmac7> Then also on the MyStateT one, there seems to be an issue with the kind... instance Functor (MyStateT s) where doesn't look like it would typecheck
09:05:21 <stephenmac7> Hm. I have yet to figure out what to do for the applicative instance
09:14:21 <hsk4> Anyone here running OS X Yosemite?
09:14:54 <myfreeweb> hsk4: yep. currently inside of a FreeBSD V, but have two Yosemite machines nearby
09:14:58 <myfreeweb> VM*
09:15:54 <geekosaur> not actively running it but I have a (somewhat crashy) VM
09:16:53 <hsk4> Ok can you: Launch Safari, go to https://www.haskell.org/hoogle/ and search for "forever" (or any function really), then click on it
09:17:02 <hsk4> On the resulting page, it doesn't jump to the forever function
09:17:05 <hsk4> it just stays at the top
09:17:14 <hsk4> Whereas on Chrome it does jump to the forever function
09:17:17 <hsk4> annoying as hell
09:17:19 <hsk4> any ways out?
09:17:28 <m-r-r> myfreeweb: I'm curious, what VM do you use to run OS X ?
09:17:30 <hsk4> is this a problem in safari or the hoogle page not doing something right?
09:18:17 <stephenmac7> geekosaur: I can't find the applicative instance of State but don't see why I would need class constraints on the type variables
09:18:26 <myfreeweb> m-r-r: no, I'm running FreeBSD inside of a VirtualBox VM, OS X is the host... but I have an OS X VM there too
09:18:35 <stephenmac7> The definition I came up with was; MyState this <*> MyState on = MyState $ \x -> let (a, s1) = on x in let (abF, s2) = this s1 in (abF a, s2)
09:18:39 <geekosaur> stephenmac7, any Applicative must also be a Functor
09:19:13 <geekosaur> (an applicative functor being a functor + a definition of `pure`)
09:19:26 <stephenmac7> geekosaur: But isn't that in the class definition, not the instance?
09:20:26 <myfreeweb> hsk4: use firefox
09:20:26 <geekosaur> yes. I'm just trying to figure out where the Functor constraint in there came from in the first place... it certainly shouldn't be where it is, and that's abotu the only place that makes *any* sense although even there it dosn't make *much* sense
09:21:14 <hsk4> myfreeweb: hehe
09:21:23 <stephenmac7> I mean, it's not like I'm using fmap on the actual values inside the state (s and a)
09:22:11 <myfreeweb> hsk4: safari eats anchors when a redirect happens
09:22:35 <hsk4> myfreeweb: ok
09:22:36 <hsk4> quite bad
09:22:37 <myfreeweb> hsk4: they're doing a redirect from the latest version to the actual version on hackage
09:23:09 <myfreeweb> hsk4: that safari behavior might be for security reasons I think
09:23:23 <hsk4> hm ok
09:25:53 <cchalmers> hsk4: if you want a working hoogle in safari you can use http://fpcomplete.com/hoogle
09:26:17 <myfreeweb> also, why use hoogle when you can use hayoo
09:26:44 <hsk4> cchalmers: nice is that a mirror they do on a regular basis?
09:26:48 <hsk4> myfreeweb: never heard of hayoo...
09:27:38 <geekosaur> hoogle and hayoo are not equivalent
09:27:54 <myfreeweb> hayoo is much more useful, it searches, like, all of hackage
09:28:09 <geekosaur> but hayoo doesn't handle type-directed searches as well as hoogle
09:28:29 <geekosaur> there is another hoogle instance at fpcomplete that searches Platform or stackage
09:28:45 <myfreeweb> hm, maybe I haven't done very advanced searches :D but hayoo handles stuff like [a] -> Maybe a quite well
09:28:51 <hsk4> same safari problem on hayoo
09:28:52 * osfameron wonders if there is a "hing".  (Or a huck huck go?)
09:28:55 <hsk4> no safari problem on fpcomplete
09:30:06 * hackagebot lambdabot 5.0 - Lambdabot is a development tool and advanced IRC bot  http://hackage.haskell.org/package/lambdabot-5.0 (BertramFelgenhauer)
09:30:08 <cchalmers> hayoo can't handle stuff like Functor f => f a -> f b
09:30:08 * hackagebot lambdabot-core 5.0 - Lambdabot core functionality  http://hackage.haskell.org/package/lambdabot-core-5.0 (BertramFelgenhauer)
09:30:08 <aLostEngineer> osfameron: huck huck ho?
09:30:10 * hackagebot lambdabot-haskell-plugins 5.0 - Lambdabot Haskell plugins  http://hackage.haskell.org/package/lambdabot-haskell-plugins-5.0 (BertramFelgenhauer)
09:30:12 * hackagebot lambdabot-irc-plugins 5.0 - IRC plugins for lambdabot.  http://hackage.haskell.org/package/lambdabot-irc-plugins-5.0 (BertramFelgenhauer)
09:30:14 * hackagebot lambdabot-misc-plugins 5.0 - Lambdabot miscellaneous plugins  http://hackage.haskell.org/package/lambdabot-misc-plugins-5.0 (BertramFelgenhauer)
09:30:20 <geekosaur> as a very rough guideline, hayoo handles fuzzy names better than hoogle and hoogle handles fuzzy types better than hayoo
09:30:23 <osfameron> oh!  I asked about Hing in 2013...
09:30:42 <geekosaur> so if you get your type somewhat wrong, hoogle is more likely to find what you intended
09:31:11 <geekosaur> if you have an exact type, both work about as well
09:31:11 <osfameron> aLostEngineer: possibly just "Duck Duck Ho"
09:31:44 <aLostEngineer> osfameron: I'm not sure how I feel about that
09:33:16 <hsk4> forever :: (Monad m) => m a -> m b
09:33:16 <hsk4> Why are a and b different? Why isn't it m a -> m a? That would make sense to me because it's the argument that is called infinitely often
09:33:22 <hsk4> so the result type should be the same no?
09:33:25 <hsk4> hmz
09:34:07 <bennofs> hsk4: well, the idea is that forever never returns
09:34:18 <earthy> the return type therefore doesn't matter
09:34:21 <bennofs> hsk4: so it can return any type, because will never be able to use the return type
09:34:22 <geekosaur> no, the m b indicates that it runs forever so never produces a value
09:34:38 <osfameron> why not m a -> _|_ then?
09:34:43 <geekosaur> (it is, roughly, "undefined" expressed at the type level
09:35:01 <osfameron> m b doesn't *look* anything like "undefined"...
09:35:11 <geekosaur> :t undefined
09:35:12 <bennofs> osfameron: because there is Void in base
09:35:12 <lambdabot> a
09:35:16 * hackagebot lambdabot-novelty-plugins 5.0 - Novelty plugins for Lambdabot  http://hackage.haskell.org/package/lambdabot-novelty-plugins-5.0 (BertramFelgenhauer)
09:35:18 * hackagebot lambdabot-reference-plugins 5.0 - Lambdabot reference plugins.  http://hackage.haskell.org/package/lambdabot-reference-plugins-5.0 (BertramFelgenhauer)
09:35:20 * hackagebot lambdabot-social-plugins 5.0 - Social plugins for Lambdabot  http://hackage.haskell.org/package/lambdabot-social-plugins-5.0 (BertramFelgenhauer)
09:35:22 <hsk4> geekosaur: Interestingly, haskell is intelligent enough to deduce this. It sees it's infinite recursion somehow and makes it b
09:35:22 * hackagebot lambdabot-trusted 5.0 - Lambdabot trusted code.  http://hackage.haskell.org/package/lambdabot-trusted-5.0 (BertramFelgenhauer)
09:35:24 <bennofs> s/is/is no
09:35:57 <osfameron> ah.  so it's basically the best hack that would work?
09:36:04 <init> > forever []
09:36:05 <lambdabot>  []
09:36:15 <bennofs> osfameron: not a hack, it's also more general. you can just use a ~ Void
09:36:26 <geekosaur> well, it doesn't require language changes
09:36:26 <bennofs> osfameron: so it saves users from having to call absurd all the time
09:36:45 <bennofs> osfameron: but still allows users who need the Void to use the function.
09:36:52 <geekosaur> in theory someone could add some syntactic sugar, but it's not essential when the existing language can describe it
09:41:05 <raek> hmm. was there any HaskellCast #3?
09:44:17 <hvr> raek: http://www.haskellcast.com/episode/003-simon-peyton-jones-on-ghc/ ?
09:45:07 * hackagebot descriptive 0.9.2 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.9.2 (ChrisDone)
09:47:31 <raek> hvr: oh, neat! I have only listened to episodes on youtube so far, and #3 is missing there
09:49:31 <jophish> Monkey face operator (:[])
09:55:08 * hackagebot shelly 1.6.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.1 (GregWeber)
09:56:04 <kmerz1> hey, has anybody here expirences with hscurses? I want to change the color of on char and change back to default afterwards
09:57:27 <heatsink> kmerz1: hscurses is a binding to ncurses, so you might find the answer in the ncurses documentation
09:59:16 <kmerz1> I am already reading the ncurses Header file and docs, and in C i think figured it all out :) But I don't get it done in haskell :/
09:59:29 <SrPx> > (floor 1.7) :: Float
09:59:30 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Float)
09:59:30 <lambdabot>    arising from a use of ‘GHC.Real.floor’
09:59:43 <SrPx> What? Wh isn't Float an instance of Integral?
09:59:57 <HeladoDeBrownie> kmerz1, what's the relevant c procedure you might use for this?
09:59:58 <SrPx> How do I get the floating floor of a float?
10:00:03 <SrPx> other than using fromIntegral
10:00:07 <kmerz1> attr_on
10:00:20 <ChristianS> SrPx: because float is not an integer type?
10:00:23 <Scriptonaut> could someone tell me why I get: Invalid type signature: encode - modified ... Should be of form <variable> :: <type>, with this function? https://gist.github.com/robins35/b0a5f55dfe2777d525bf
10:00:33 <SrPx> ChristianS: float is a superset of integers....
10:00:38 <kmerz1> this accepts a attibute OR a color pair
10:00:42 <hpc> SrPx: what would toInteger be?
10:01:15 <kmerz1> but hscurses doesn't have anything to convert the colorpair to an attribute
10:01:25 <HeladoDeBrownie> kmerz1, okay, so in the haskell binding you use things like setBold and setBlink on attr0 and then pass all that into attrOn
10:01:25 <myfreeweb> SrPx: it's not a superset... real numbers are a superset, but float is a particular representation of them... that can lose precision, because computers
10:01:38 <kmerz1> thats true
10:01:41 <HeladoDeBrownie> kmerz1, that's just from looking at the docs, i've never used it
10:01:42 <SrPx> hpc: the same as "toInteger 7" for integers... returns the same number without decimals?
10:01:51 <SrPx> myfreeweb: but yea, fair point
10:02:06 <HeladoDeBrownie> kmerz1, so, like this: attrOn (setBold attr0 True)
10:02:10 <HeladoDeBrownie> kmerz1, let me know if that works or not
10:02:11 <SrPx> anyway, that doesn't matter... my question is, how do I call the "floating point float" instruction?
10:02:55 <kmerz1> HeladoDeBrownie: I thanks for the help, i'll take look but my problem is that I want to set a colo
10:02:58 <voidzero> you could convert it to a string
10:03:12 <kmerz1> and ColorPair isn't a Attr like attr0
10:03:15 <voidzero> then takeWhile (/= '.')
10:03:32 <voidzero> and then take every char >= 0 and <= 9
10:03:36 <kmerz1> in C attr_on I can pass color_pair or attr
10:03:49 <HeladoDeBrownie> kmerz1, ah, right. lemme take a look for that then…
10:04:44 <kmerz1> HeladoDeBrownie: I sit on the problem for the last 2 hours with reading source code, I think my problem is that I cannot convert Color Pair to Attr
10:05:08 * hackagebot c2hs 0.23.1 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.23.1 (IanRoss)
10:05:22 <HeladoDeBrownie> kmerz1, see how far you get following the instructions here. if you get lost or anything ask for help http://hackage.haskell.org/package/hscurses-1.4.2.0/docs/UI-HSCurses-Curses.html#v:initPair
10:06:00 <HeladoDeBrownie> kmerz1, i don't blame you for having trouble, this documentation is a bit sparse in places
10:06:29 <HeladoDeBrownie> +many
10:07:11 <kmerz1> HeladoDeBrownie: Thanks I will read it again carefully perhaps I missed somthing
10:07:35 <HeladoDeBrownie> kmerz1, it's specifically the initPair notes that i think might be relevant
10:07:45 <HeladoDeBrownie> just in case that was unclear
10:12:40 <kmerz1> HeladoDeBrownie: initPair only initlizeses the background and forground color you want to use, i even managed to use it afterwards with attrSet which sets the color to that pair for the whole screen, but as I read in the ncurses documentation, attrOn and attrOff must be used to switch between to pairs for one character
10:13:45 <kmerz1> i now tried attrOn (Attr (Pair 1)) which was my last hope
10:13:52 <jophish> ocharles_: did you ever get anywhere looking into Regions?
10:14:00 <kmerz1> initPair (Pair 1) red defaultBackground
10:14:07 <ocharles_> jophish: in what sense?
10:14:18 <ocharles_> i mean, i have used them, briefly
10:14:22 <kmerz1> but the result is:  Not in scope: data constructor ‘Attr’
10:14:53 <jophish> ocharles_: regarding this: https://github.com/basvandijk/regions/issues/7
10:15:05 <jophish> I'm hoping to use regions for an opengl wrapper, but it's looking a little unloved
10:15:07 <HeladoDeBrownie> kmerz1, i don't think it mentions anything about an Attr data constructor, but actually taking another look i think i just figured it out
10:15:55 <ocharles_> jophish: ah, right
10:16:05 <ocharles_> ultimately, we decided that the library shouldn't make a decision for users
10:16:16 <ocharles_> if people want to layer regions on top, they can - but we won't be doing it in our library
10:16:52 <geekosaur> urgh. that's a rather raw binding and I expect it behaves annoyingly (and requires you to understand how curses works in C)
10:17:12 <ab9rf> the curses bindings are evil
10:17:25 <jophish> ocharles_: that sounds sensible, although it doesn't prevent users shooting themselves in the foot
10:17:32 <ocharles_> no
10:17:33 <ab9rf> which largely reflects the fact that curses itself is evil
10:17:47 <ocharles_> but users have many guns to shoot themselves in the foot with, so they have to be careful anyway
10:17:57 <ab9rf> the gl bindings probably share the same problem
10:18:06 <ab9rf> gl is a giant steaming hunk of evil :)
10:18:09 <HeladoDeBrownie> kmerz1, making a gist, one sec
10:18:16 <kmerz1> \o/
10:19:27 <HeladoDeBrownie> kmerz1: https://gist.github.com/HeladoDeBrownie/f93a5f6157d41a3c6217
10:19:38 <HeladoDeBrownie> kmerz1, let me know if that works or not
10:20:28 <HeladoDeBrownie> kmerz1, i figured this out just from the types, the rest of the documentation isn't terribly useful. so it's possible something went wrong
10:20:39 <HeladoDeBrownie> kmerz1, oh, i missed the initialization stuff. make sure to add that in.
10:21:02 <kmerz1> unfortunately it will make my whole screen in that color
10:21:17 <kmerz1> as I wrote before :(
10:21:41 <kmerz1> but thanks for your effort..
10:22:30 <HeladoDeBrownie> hmm, all right. hopefully someone who's used hscurses can help you at some point. sorry i was unable
10:22:44 <HeladoDeBrownie> my best advice is to read the types
10:23:01 <kmerz1> HeladoDeBrownie: will do thanks again
10:23:01 <geekosaur> as far as I can tell colorPair is supposed to be the equivalent of the COLOR_PAIR macro in C, but it looks to have the wrong type
10:23:16 <jophish> ocharles_: I'll take a look at how HaskellGame is doing things, thanks for your help
10:23:19 <geekosaur> but I am tempted to say "try vty instead"
10:25:15 <kmerz1> geekosaur: i started with that but found it quite hard to understand.. but then again that was 1 year ago when I started my little project (and haskell itself) .. perhaps it is time to switch libs.. but first i'll give hscurses one last shot
10:25:23 <Lokathor> vty is weird
10:25:34 <Lokathor> and i don't know why they don't let you just write a single character to a single location
10:25:44 <geekosaur> vty may be weird but curses is weirder
10:25:59 <Lokathor> hardly
10:26:28 <geekosaur> (and I think most of the "vty is weird" complaints come down to "you do understand that a terminal is not arbitrarily addressible, but has exactly *one* current position?")
10:26:40 <geekosaur> Lokathor, have you *worked with* curses?
10:27:25 <HeladoDeBrownie> curses is definitely designed from a procedural perspective, but even for that it has tons of implicit state.
10:27:41 <HeladoDeBrownie> and the haskell bindings don't really correct that problem.
10:27:52 <geekosaur> and the interactions in that state are often perverse
10:28:22 <geekosaur> (I will point to wclear() as just one example)
10:28:24 <Lokathor> Define "worked with". I've used curses in both C, Python, a JNI extension, and a Haskell binding (hscurses). I've never tried to develop the curses library itself though, if that's what you're asking
10:28:51 <xplat> my experience with color pairs tells me curses is well-named
10:29:00 <Lokathor> zing
10:29:01 <geekosaur> yep
10:29:14 <xplat> i mean, sure it could be worse, and there's probably a PHP binding that *is* worse, but still.
10:29:15 <geekosaur> (actually IO think that observation goes back to the old BSD curses manpage...)
10:32:53 <nkar> why does cabal disallow specifying -prof in the ghc-options field of a .cabal file?  instead, it requires configuring with --enable-profiling.
10:33:22 <xplat> you'd kind of like to have a library that is light and intuitive enough that you want to make a text box like aptitude to hold multiple lines that could be updating at the same time, rather than hacking something together with printing raw VT100 codes to back up and update a line.
10:33:37 <xplat> curses is amazing in many ways, but for me at least it is *not* that library
10:36:10 <phaul> I just came across this: snail (xs:xss) = xs ++ (snail . reverse . transpose) xss
10:36:13 <Lokathor> it is intended that you build that abstraction yourself, unfortunately
10:36:27 <phaul> ^^ neat. I wouldn't have thought of it myself :)
10:36:38 <Saizan> nkar: because a .cabal file is supposed to be a description of a package, details of a specific build are supposed to go elsewhere
10:38:23 <phaul> ( goes around in 2x2 square matrix clockwise in snailshell pattern )
10:39:38 <HeladoDeBrownie> phaul, what are the preconditions on that?
10:39:43 <HeladoDeBrownie> (it diverges for some input)
10:40:50 <HeladoDeBrownie> phaul, is there a clause you missed?
10:41:18 <phaul> yeah, it's not a full solution and not even mine. I just thought this oneliner was neat nervertheless
10:42:03 <HeladoDeBrownie> seems to work if you add snail [] = []
10:42:18 <HeladoDeBrownie> yeah, pretty neat
10:42:34 <HeladoDeBrownie> now how about its inverse ;)
10:45:59 <funfunctor> hi
10:46:36 <jophish> yo
10:47:32 <funfunctor> I have the type miss-match of Expected type: Int -> IO () Actual type: Int -> IO (Either LibBladeRF.LibBladeRF.BladeRFError ()) with a action being put into a field
10:48:07 <funfunctor> the field has the signature  setVCTCXO             :: Int -> m ()              -- ^ Set the VCTCXO input voltage
10:48:53 <funfunctor> any ideas how I can make m () more loss to accommodate actions with Either embedded
10:50:52 <funfunctor> I hate getting stuck at the type system :|
10:51:25 <funfunctor> even though I love the type system
10:52:46 <fProgrammer> Quick question: How do I make Data.Map preserver insertion order?
10:52:52 <myfreeweb> what's the equivalent of `ghc-pkg dot` for cabal sandboxes?
10:53:54 <funfunctor> fProgrammer: sounds like needing a instance of Ord ? Just a guess
10:54:02 <hexagoxel> myfreeweb: if you are lucky `cabal exec -- ghc-pkg dot`
10:54:08 <bennofs> myfreeweb: cabal sandbox hc-pkg dot perhaps?
10:55:14 <funfunctor> is there any such signature as :: IO (Either SomeErrorType) -> IO () ?
10:55:25 <fProgrammer> funfunctor: Actually somewhere in code I do Data.Map.toList where the order goes haywire, I need the list from toList in the same order of insertion
10:55:34 <ski> funfunctor : kind error
10:55:35 <bennofs> funfunctor: you mean IO (Either SomeErrorType a) -> IO a?
10:55:56 <funfunctor> ski yea
10:55:57 <myfreeweb> hexagoxel: nah, still displays hoogle and ghc-mod instead of my packages
10:55:59 <funfunctor> yes bennofs
10:56:18 <funfunctor> well sort of
10:56:19 <bennofs> funfunctor: either throwIO return ?
10:56:20 <ski> @type (>>= either throwIO return)
10:56:21 <lambdabot> Exception a => IO (Either a b) -> IO b
10:56:27 <funfunctor> bennofs: did you see my question above?
10:57:02 <fProgrammer> any ideas anyone?
10:57:15 <funfunctor> I have the type miss-match of Expected type: Int -> IO () Actual type: Int -> IO (Either LibBladeRF.LibBladeRF.BladeRFError ()) with a action being put into a field, the field has the signature  setVCTCXO             :: Int -> m ()              -- ^ Set the VCTCXO input voltage
10:57:16 <bennofs> funfunctor: well, do you want to ignore the error or what do you want to do?
10:57:37 <funfunctor> bennofs: i'm going to go with ignore the error for the moment
10:57:41 <funfunctor> if that is simpler
10:57:43 <bennofs> :t void
10:57:45 <lambdabot> Functor f => f a -> f ()
10:57:58 <funfunctor> oh wow yes
10:58:11 <funfunctor> how does that work?
10:58:19 <bennofs> funfunctor: (>> return ())
10:58:28 <bennofs> :t \x -> x >> return ()
10:58:28 <lambdabot> Monad m => m a -> m ()
10:58:41 <bennofs> funfunctor: or the functor version would be fmap (const ())
10:58:46 <bennofs> :t fmap (const ())
10:58:47 <lambdabot> Functor f => f a -> f ()
10:59:26 * ski wishes people would only use that `void' in FFI situations ..
10:59:28 <SrPx> Am I the only one who thinks there is something *really* wrong with Haskell numeric typeclasses?
10:59:32 <bennofs> funfunctor: if BladeRFError is an instance of the class Exception, then you can also use (>>= either throwIO return) to throw an IO exception if there is an error
10:59:41 <funfunctor> ski: i'll keep that in mind
10:59:44 <bennofs> ski: why?
11:00:03 <funfunctor> :t (>>= either throwIO return)
11:00:04 <lambdabot> Exception a => IO (Either a b) -> IO b
11:00:08 <ski> because its name is derived from `void' in C,C++,Java,C#,...
11:00:12 <bennofs> SrPx: no, you're not the only one
11:00:21 <bennofs> ski: just as return  :)
11:00:27 <ski> the corresponding concept (in this case) in Haskell is `()', the unit type
11:00:33 <SrPx> bennofs: you too?
11:00:37 <funfunctor> I wish my memory was better at encoding all this so I would not need to keep asking 10 times before I remember things
11:01:06 <bennofs> @hackage numeric-prelude
11:01:06 <lambdabot> http://hackage.haskell.org/package/numeric-prelude
11:01:13 <ski> bennofs : there is already a good name for the haskell type. also i'd want to reserve `void' for the operation having type `forall a. Void -> a'
11:01:39 <bennofs> ski: ? what good name is there for void :: m a -> m () that is in base?
11:01:52 <bennofs> (Functor m constraint)
11:01:55 <ski> bennofs : it could be called `ignore', e.g.
11:02:09 <ski> (i think the corresponding thing in SML is called that)
11:02:12 <lpaste> funfunctor pasted “No title” at http://lpaste.net/120985
11:02:14 <bennofs> ski: ah, so you're not against using void, but would like to see it renamed :)
11:02:36 <funfunctor> bennofs: ^ thats how I am touching the C and how I handle the errors deep down the stack
11:02:42 <bennofs> ski: I've also seen ignore :: m () ub sine library
11:02:43 <funfunctor> advice welcome there
11:02:48 <ski> bennofs : yes. i'm ok with it being named `void' when used in an FFI context, though, since that's mostly used with C
11:06:11 <darkroom> is the asymtotic complexity of the function apply O(nlog(n)) or O(n^2) http://pastebin.com/N1d9p4Lg
11:08:54 <deech> Hi all, the cabal file for my project specifies that >=1.20 is required (https://github.com/deech/fltkhs/blob/master/fltkhs.cabal#L15) but it doesn't seem to warn users with older versions.
11:09:16 <deech> Do I need to specify the Cabal library version in my `build-depends` section as well?
11:09:36 <bennofs> deech: no, you shouldn't need to do that
11:10:22 <fProgrammer> Rephrasing my earlier question, how do I get a list from a Data.Map in order of insertion?
11:10:42 <bennofs> fProgrammer: Data.Map doesn't preserve insertion order
11:11:00 <fProgrammer> bennofs: can you suggest some other data structure?
11:11:04 <deech> bennofs: A user has reported build errors because `Setup.hs` uses a 1.20+ specific API call. ( https://github.com/deech/fltkhs/issues/7)
11:11:25 <bennofs> deech: peti builds without cabal-install
11:11:44 <bennofs> deech: there is no way to specify build-deps for Setup.hs
11:12:03 <bennofs> deech: as it is run via runhaskell ./Setup.hs configure -> no cabal interaction in this step
11:12:39 <funfunctor> :t <<
11:12:40 <lambdabot> parse error on input ‘<<’
11:12:40 <bennofs> deech: nix doesn't use cabal-install for building haskell packages (we use the GHC shipped Cabaĺ lib)
11:12:42 <bennofs> :t (<<)
11:12:43 <lambdabot>     Not in scope: ‘<<’
11:12:43 <lambdabot>     Perhaps you meant one of these:
11:12:43 <lambdabot>       ‘=<<’ (imported from Control.Monad.Writer),
11:12:48 <bennofs> :t (<*)
11:12:49 <lambdabot> Applicative f => f a -> f b -> f a
11:13:04 <deech> bennofs: then how do I use a version of the Cabal that GHC doesn't ship with?
11:13:05 <bennofs> a <* b runs a and then b, and returns the result of a
11:13:06 <funfunctor> :t hehe not look for sided applicatives but they are cool
11:13:07 <lambdabot> Not in scope: ‘hehe’
11:13:07 <lambdabot>     Not in scope: ‘look’
11:13:07 <lambdabot>     Perhaps you meant ‘loop’ (imported from Control.Arrow)
11:13:27 <funfunctor> yea they are cool
11:13:39 <funfunctor> no I was just trying to get void to work
11:13:47 <bennofs> deech: it's impossible to specify dependencies for ./Setup.hs
11:13:57 <funfunctor> :t (=<<)
11:13:58 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:14:06 <funfunctor> :t void
11:14:07 <lambdabot> Functor f => f a -> f ()
11:14:20 <bennofs> deech: Is it really not possible to make it compatible with 1.18 ?
11:14:57 <funfunctor> :t (<<=)
11:14:58 <lambdabot>     Not in scope: ‘<<=’
11:14:58 <lambdabot>     Perhaps you meant one of these:
11:14:58 <lambdabot>       ‘<=’ (imported from Data.Ord), ‘<<<’ (imported from Control.Arrow),
11:15:11 * hackagebot system-canonicalpath 0.3.1.0 - Abstract data type for canonical paths with some utilities  http://hackage.haskell.org/package/system-canonicalpath-0.3.1.0 (d12frosted)
11:15:24 <funfunctor> :t (>>=)
11:15:25 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:15:29 <deech> bennofs: I guess it is. But then every user who upgraded to 1.20 will have issues.
11:15:49 <bennofs> deech: I mean, is there nothing you can do to make it work on all Cabal versions starting with 1.18?
11:16:07 <bennofs> deech: there is still a lot of people using cabal-install 1.18 due to ghc-mod not working with 1.20 and later
11:16:44 <funfunctor> :t <<= \x -> x >> return ()
11:16:45 <lambdabot> parse error on input ‘<<=’
11:16:49 <funfunctor> :p
11:18:12 <myfreeweb> bennofs: ghc-mod broke with 1.22, not 1.20
11:18:30 <nkar> Saizan: but there's the ghc_options field anyway, no?  I don't follow.
11:20:59 <deech> bennofs: No, the problem is  http://haddocks.fpcomplete.com/fp/7.8/20140916-162/Cabal/Distribution-Simple-GHC.html#v:buildExe vs. https://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/Distribution-Simple-GHC.html#v:buildExe.
11:21:09 <Danie|> hola
11:21:14 <funfunctor> bennofs: because of the eta reduction in the field allocation I am a little confused
11:21:51 <deech> The buildExe arguments in 1.20 changed to include the `Flag (Maybe Int)` which you get using `buildNumJobs`.
11:21:55 <funfunctor> I tried , setVCTCXO = void bladeRFSetVCTCXO    but that action takes arguments
11:23:14 <funfunctor> bennofs: bladeRFSetVCTCXO :: Double -> SomeActionMovie ()
11:25:51 <funfunctor> ah lambda expression solved it
11:26:02 <funfunctor> next issue :|
11:27:37 <wacco> https://github.com/Meeuwisse/IRC/blob/master/client.hs -- is there a nice way of getting the joined / nicked / parted / quit functions generalized? I'm mostly stumped on the c vs (_: c)
11:28:33 <wacco> (also note the parse function, which in c++ I'd tackle as a {id, functor} kinda solution)
11:29:16 <deech> Anyone know what CPP constant to use to detect Cabal versions?
11:29:19 <wayne> do you think hardware description languages like verilog offer a "pure" alternative to IO monads?
11:29:29 <wayne> HDLs remind me a lot of FRP
11:30:19 <wacco> wayne: HDLs are more of a "all at once" approach, no?
11:30:48 <wayne> wacco: kind of, but so is function programming, right?
11:30:52 <wayne> functional, rather
11:31:12 <wacco> I'm missing the @clk flank (or something, it's been a while) analogy
11:31:15 <wayne> also, in HDLs you can define signal input and output ports
11:31:28 <wayne> elm reminds me a lot of HDLs
11:31:51 <wayne> besides those input and output ports, HDLs describe true functions i think
11:32:01 <wayne> well, they can if you don't bring in memory :P
11:32:08 <wacco> I get the whole purity, just not how monads fit in the picture
11:32:54 <osa1> any ideas what was the base version introduced with GHC version that introduced MultiWayIf syntax?
11:34:35 <kmerz1> okay before I go off I have yet another question.. a while a go as I started figuring out Object Oriented Programming I read 1 or 3 Books about the subject and could more or less do a good abstraction in my code, is there a resource for functional programming or even better haskell.. My code dosn't look to good and I think I make mistakes as a beginner I could easily avoid
11:35:42 <sx> What is the best way to initialize an MArray indexed by (Int, Int)? Problem is: I get rows initially, but the indices generated by the Ix instance are column wise.
11:36:02 <pavonia> osa1: https://downloads.haskell.org/~ghc/7.6.1/docs/html/users_guide/release-7-6-1.html
11:39:10 <stephenmac7> @unmtl MaybeT (State s) a
11:39:10 <lambdabot> (State s) (Maybe a)
11:44:13 <mleduc> I'm working on the NICTA course (https://github.com/NICTA/course/) and I'm a little bit stuck with the FileIO exercice because it does not contains doctest tests. How can I run it instead ?
11:45:12 * hackagebot buffer-builder 0.2.0.1 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.0.1 (chadaustin)
11:46:05 <jophish> edwardk: I'm toying with the idea of slightly safer opengl bindings than gl, primarily parsing the documentation and replacing GLenum with data types. Have you got any thoughts on this? I notice there is a mention of 'building nicer bindings' on github.
11:46:57 <edwardk> jophish: i'm continuing to build higher level abstractions in Quine.GL, but i'm very very hesitant to take the path you propose, almost to the point of being vehemently against it
11:47:17 <edwardk> ultimately language extensions add new members to what is an acceptable argument to almost any function
11:47:36 <edwardk> the set of GLEnum's you choose will inevitably be too small
11:47:42 <jophish> edwardk: I saw your talk, I thought you might have something to say about this :)
11:47:45 <edwardk> and when it is you'll be stuck, giving escape valves in every data type
11:47:56 <edwardk> or just ruling those cases out (like OpenGL)
11:48:24 <edwardk> so it winds up with a wrapper that doesn't get to effectively isolate you from anything
11:48:38 <funfunctor> round time -> 7am -> do bed
11:48:49 <edwardk> i think newtypes like Shader, etc. that capture intent add value, but i'm very hesitant on the GLenum front.
11:49:38 <edwardk> i'd rather pursue at a higher level better data types that encapsulate good behavior  just happen to use the low level functions than  low level functions rebranded and made less callable
11:50:12 * hackagebot buffer-builder 0.2.0.2 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.0.2 (chadaustin)
11:50:14 <jophish> edwardk: I'd certainly not advocate removing anything from gl as it is
11:50:53 <jophish> however I believe there is value in restricting what can be passed to a function at some level of abstraction.
11:50:56 <stephenmac7> The typeclassopedia links to an article "How to use Monad Transformers" but it seems to be broken.
11:51:17 <jophish> This could be applied quite safely targeting a version of opengl with no extensions
11:51:52 <jophish> of course it's being able to escape this when necessary which is the issue
11:53:20 <edwardk> jophish: my main concern is that every time i tried to use one of these nice opaque wrappers that tried to help me i've gotten stuck somewhere somehow and had to completely stop work and wait for the upstream to accept a patch
11:53:48 <edwardk> so i'm not really in a hurry to adopt a practice whereby users have to block on me unnecessarily, waiting for me to extend a crippled data type
11:54:43 <edwardk> i wrote gl after i had to file a dozen issues all over overly ambitious attempts to do just what you are asking to do
11:54:55 <edwardk> none of those issues have been addressed on the OpenGL side
11:55:21 <jophish> edwardk: As long as there's an escape hatch, is this such a problem? For example exposing the Shader newtype constructor enables users to create their own and use the GLenum
11:55:33 <edwardk> so i went to an opposite extreme. you can capture exactly what the OpenGL API allows with the current approach.
11:55:44 <edwardk> notice in quine that is precisely what i do
11:55:48 <edwardk> note Shader isn't a GLenum its a GLint
11:56:10 <jophish> err, yes my mistake
11:56:13 <edwardk> https://github.com/ekmett/quine/blob/master/src/Quine/GL/Shader.hs#L69
11:56:37 <edwardk> that sort of intermediate level is what i'm building in Quine.GL
11:56:47 <edwardk> and it'll eventually split out into a separate package
11:57:12 <edwardk> but its being very careful not to go into an ADT with made-up ungoogleable names
11:57:54 <edwardk> because the OpenGL package as it stands hides a ton of stuff behind made up abstractions with no documentation where you just have to hope you guessed the convention right and that you don't run into a usecase it doesn't support out of the box
11:58:12 <edwardk> because the moment you do, you're done
11:59:04 <edwardk> there are lots of things an intermediate layer could provide. easier marshaling back and forth for uniforms, generic uniform block management, etc.
11:59:39 <jophish> I agree very much with that, however I'm still not convinced that anything would be lost by typing the enums properly (as long as the raw GLemun function was still exposed)
11:59:56 <edwardk> buffer management: https://github.com/ekmett/quine/blob/master/src/Quine/GL/Buffer.hs etc.
12:00:01 <jophish> For the majority of uses this is very helpful]
12:00:09 <edwardk> in https://github.com/ekmett/quine/blob/master/src/Quine/GL/Block.hs i have GHC.Generics computing STD140 and STD430 layouts for anything Generic, etc.
12:00:49 <jophish> edwardk: that's amazing!
12:01:35 <akegalj_> is there function in Data.List which acts similar to Data.Text.chunksOf ? I would like to do something like chunksOf 3 [1,2,3,4,5] = [[1,2,3],[4,5]]
12:01:44 <edwardk> jophish: my concerns are 1.) there is huge amount of punning in the OpenGL API, so we wind up using the same names in lots of places, so you wind up with haskell specific name mangling, 2.)  going back and forth to the enum-like representation just throws random overhead into the mix, 3.) you have an escape valve anyways, so now comparing these things for
12:01:44 <edwardk> equality becomes messier, you have to rely on conventions that folks won't use the escape valve for something with an explicit representation, or carefully compare them as equal, etc.
12:02:24 <edwardk> given the open nature of all the enums i'm inclined to let it lie and build nice abstractions on top
12:03:20 <edwardk> in 7.10 we get better patterns, so perhaps we could try harder to overload the ones we offer, but there are big technical challenges there
12:04:04 <edwardk> er better view patterns
12:04:04 <edwardk> gotta go
12:07:44 <jophish> edwardk: Thanks for the talk!
12:08:17 <lhx> Hi all: I'm working through Learn you a Haskell, and I'm having trouble understanding stepping and ranges. The book says [2,2..20] should count [2,4,6,8] and so on to 20, but when I run it in ghci it just infinitely prints [2,2,2,2,2,2]
12:08:37 <edwardk> the book should use [2,4..20]
12:08:42 <edwardk> > [2,4..20]
12:08:43 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
12:08:55 <edwardk> the second value is the next one, not the delta
12:09:13 <lhx> edwardk: that makes sense
12:09:19 <lhx> thanks..
12:09:33 <lhx> and the book is correct... I'm just a dummy
12:12:32 <KaneTW> > [2,6..20]
12:12:33 <lambdabot>  [2,6,10,14,18]
12:14:26 <heatsink> > [2,4..19.5]
12:14:27 <lambdabot>  [2.0,4.0,6.0,8.0,10.0,12.0,14.0,16.0,18.0,20.0]
12:19:10 <KaneTW> [2.5, 5.0..20.0]
12:19:15 <KaneTW> > [2.5, 5.0..20.0]
12:19:17 <lambdabot>  [2.5,5.0,7.5,10.0,12.5,15.0,17.5,20.0]
12:20:04 <phaul> I don't like how enum works for floats. It's not really enumerating floats...
12:20:19 <phaul> > > [1.0 .. 5.0]
12:20:21 <lambdabot>  <hint>:1:1: parse error on input ‘>’
12:20:35 <phaul> > [1.0 .. 5.0]
12:20:36 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
12:21:48 <phaul> > succ 1.0
12:21:49 <lambdabot>  2.0
12:22:28 <ReinH> phaul: what do you mean?
12:23:00 <phaul> I would expect succ 1.0 to be the next representable float after 1.0
12:23:22 <ReinH> I guess it could be, but that doesn't seem very useful
12:24:12 <phaul> yeah, It's kind of philosophycal, it's just counter intuitive with what Enum is
12:24:12 <cmccann> > [0.1, 0.3 .. 0.6] -- phaul
12:24:14 <lambdabot>  [0.1,0.3,0.5,0.7]
12:24:17 <cmccann> yay floats!
12:24:31 <cmccann> man, that is such a terrible class instance.
12:24:50 <hpc> i would pin most of the terrible on IEEE
12:25:20 <shachaf> > let x = [1,3..4] in (x :: [Int], x :: [Float])
12:25:22 <lambdabot>  ([1,3],[1.0,3.0,5.0])
12:26:06 <cmccann> hpc: the IEEE spec is an amalgam of carefully considered painful compromises. the Enum instance for floats is a single ill-considered mistake. :P
12:27:04 <cmccann> I will grant that there probably isn't a completely sane Enum instance for floats possible
12:27:29 <cmccann> but I'm not convinced that the current instance is the lesser evil
12:27:36 <ReinH> cmccann: I like the part where Float can't accurately represent the numbers it tries to include in the enum series
12:27:47 <cmccann> that said, it's arguably less stupid than the Enum instance for ()
12:27:55 <ski> how so ?
12:28:12 <cmccann> > succ ()
12:28:13 <heatsink> IIRC, SML does not treat floating-point equality as an instance of its overloaded equality operator.
12:28:14 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
12:28:15 <cmccann> > pred ()
12:28:16 <lambdabot>  *Exception: Prelude.Enum.().pred: bad argument
12:28:18 <cmccann> why
12:28:20 <cmccann> whyyyyyy
12:28:23 <ski> > succ True
12:28:24 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
12:28:26 <ski> > pred False
12:28:27 <ReinH> shachaf: oh yeah, that part is lovely
12:28:28 <lambdabot>  *Exception: Prelude.Enum.Bool.pred: bad argument
12:28:29 <ski> same thing
12:28:34 <heatsink> > minBound :: ()
12:28:35 <lambdabot>  ()
12:28:45 <ski> heatsink : yes
12:28:48 <cmccann> ski: at least that has two different values
12:28:52 <heatsink> cmccann: The predecessor of minBound can be an error
12:28:58 <cmccann> ski: for () both succ and pred are always bottom
12:29:12 <hpc> so?
12:29:28 <ReinH> Would it be saner to just not have an Enum instance?
12:29:34 <cmccann> it's technically correct but completely useless
12:29:42 <ReinH> () is sort of the canonical thing that can't be enumerated
12:29:49 <hpc> sure it can
12:29:50 <hpc> ()
12:29:51 <ski> cmccann : "not having any good use/behaviour" is different from "having bad use/behaviour"
12:29:52 <hpc> enumerated
12:30:00 <ReinH> hpc: I mean the Enum instance
12:30:20 <ReinH> hpc: But you are ofc correct
12:30:24 <ski> `0' is pretty useless for counting things with. yet we still use it
12:30:28 <cmccann> ski: I said the Enum instance for () was stupid, not bad or wrong :]
12:30:54 <cmccann> the float instances are bad and wrong but at least I can understand why they exist in the first place
12:30:55 <hpc> it'd be stupider not to have it
12:31:02 <ski> cmccann : you said (or implied) it's arguable more stupid than the `Enum' instance for floating-points :)
12:31:50 <muzzle1> can someone give me a tip on how i can profile a cabal project ?
12:32:16 * ski is on the defend of the right of trivial things to exist
12:32:48 <hpc> () has a Bounded instance too
12:32:51 <hpc> is that stupid?
12:32:58 <cmccann> well, if I was convinced that Enum itself was sensibly designed I'd be happy to accept trivial instances
12:33:06 * ski obviously doesn't think it's stupid
12:33:19 <heatsink> muzzle1: Is it an executable?
12:33:22 <ski> cmccann : that may be a valid complaint
12:33:58 <heatsink> > enumFromTo () ()
12:33:59 <lambdabot>  [()]
12:34:17 <ski> (for some reason, mathematicians often seem to exclude e.g. the empty set out of definitions or theorems, for no apparent good reason at all)
12:35:20 <ski> (or zero-dimensional vector spaces, for a concrete example i've seen)
12:35:24 * hackagebot warp-tls 3.0.2 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.2 (MichaelSnoyman)
12:35:33 <cmccann> hpc: Bounded is ok so long as it works as expected with an Ord instance. those classes make sense, so trivial instances seem reasonable.
12:36:00 <hpc> so what's the dividing line between Bounded and Enum?
12:36:24 <hpc> because Bounded's instance is similarly useless
12:36:26 <heatsink> I once aksed on a message board about whether matrices could have height or width zero.  People were divided as to whether that was allowed.
12:36:29 <cmccann> that I have a personal grudge against Enum, mostly
12:36:34 <hpc> instance Bounded () where minBound = maxBound = const 0
12:36:43 <muzzle1> :heatsink yes
12:36:51 <hpc> instance Enum () where toEnum _ = (); fromEnum _ = 0
12:36:53 <ski> heatsink : probably the untyped people didn't like them
12:37:08 <muzzle1> :heatsink with cabal sandbox (i aleready have library-profiling enabled in .cabal/conf
12:37:22 <ReinH> muzzle1: http://nikita-volkov.github.io/profiling-cabal-projects/
12:37:24 <ski> (the determinant of the empty square matrix is of course `1', since it's the identity matrix)
12:37:58 <heatsink> muzzle1: Configure with --enable-executable-profiling to compile with profiling.  It's a separate flag from library profiling.
12:38:14 <cmccann> hpc: my annoyance at the Enum instance for () really has more to do with highlighting some of the reasons why I think Enum is stupid, rather than () itself
12:38:37 <heatsink> muzzle1: I don't know if there's a way to run and collect a profile using cabal.
12:38:38 <cmccann> ski: I also hear some people think zero isn't a natural number, which seems very strange to me
12:38:52 <ski> cmccann : aye
12:39:04 <ReinH> 0 is pretty useful for induction.
12:39:20 <muzzle1> :heatsink hmm i just got it working with cabal 1.22.0
12:39:24 <ski> cmccann : if you're mostly focusing on multiplicative structure, there could be more grounds for often ignoring `0'
12:39:32 <muzzle1> :heatsink thx
12:39:43 <hpc> ski: i would probably go with whatever result is produced by these - https://en.wikipedia.org/wiki/Laplace_expansion - https://en.wikipedia.org/wiki/Leibniz_formula_for_determinants
12:41:06 <cmccann> hpc: on the subject of stupid instances of () for stupid type classes, why aren't there numeric instances for ()
12:41:11 <cmccann> that makes about as much sense as Enum
12:41:17 <shachaf> cmccann: To balance it out, some people think that zero is a positive number.
12:41:22 <shachaf> (But not strictly positive.)
12:41:58 <cmccann> shachaf: I'd grant that on the condition that it also be considered a negative number
12:41:59 <ski> hpc : yes. going with the latter, the symmetric group over zero elements has one element, so you have a singleton sum of a null product, `sum [product []]' essentially, so `1'
12:42:34 <hpc> ski: and the former?
12:42:38 <ski> shachaf : french people, i think
12:42:40 <hpc> (i really hope it produces zero)
12:42:53 <ReinH> ski: (also this agrees with 0! = 1! = 1)
12:43:09 <ski> (shachaf : and i think it makes some sense, in the sense of being more consistent)
12:43:22 <hpc> ski: it looks like it is zero, actually
12:43:25 <hpc> it's the empty sum
12:44:24 <hpc> except it's also explicitly not defined for n=0
12:44:34 <ReinH> hpc: what isn't?
12:44:57 <ski> hpc : for the former one, i think you just add as a base case that the determinant of the empty square matrix is `1'. so that the determinant of a singleton matrix will be the scalar times this `1'
12:45:23 <hpc> clearly empty matrices haven't come up much
12:45:24 * hackagebot warp 3.0.9.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.9.1 (MichaelSnoyman)
12:45:30 <ski> (so, a singleton sum : `sum [k*1]')
12:45:47 <ski> (well, times `(-1)^0')
12:46:54 <ski> ReinH : yes
12:47:01 <ReinH> ski: uh
12:47:14 <ReinH> hpc: ‘As far as we know, the literature on the algebra of empty matrices is itself empty. We’re not sure we’ve done it correctly, or even consistently, but we have ound the idea useful.’ ftp://128.105.2.31/debooron/empty.pdf
12:47:20 <ReinH> hpc: on empty matrices in MATLAB
12:47:56 <ReinH> ski: yes what?
12:48:08 * ski idly wonders why matlab doesn't get tensors sensibly
12:48:17 <ski> ReinH : "also this agrees .."
12:48:26 <ReinH> ski: oh right
12:48:31 <ReinH> ski: referents are hart :)
12:48:35 <ReinH> or hard
12:50:34 <ski> (you'd think that a language that is supposed to be able to represent `n'-dimensional arrays / `n'-order tensors, would get the general case right and natural)
12:54:36 <jophish> golf: ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9']
12:55:45 <jophish> perhaps something with isAlphaNum?
12:57:23 <ski> > text (filter isAlphaNum ['\0' ..])
12:57:24 <lambdabot>  0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzª²³µ¹º¼½¾ÀÁÂÃÄ...
12:58:10 <jophish> ski: yeah, just what I was trying
12:58:12 <jophish> filter isAlphaNum ['9
12:58:19 <jophish> filter isAlphaNum ['0'..'z']
12:58:32 <jophish> wrong ordering though
12:58:43 <ski> does the ordering matter ?
12:58:56 <ski> perhaps you need some kind of locale thing
12:59:04 <jophish> not particularly
12:59:24 <jophish> I saw that string in some C and was thinking how I'd write it in haskell
12:59:43 <ski> ok
12:59:46 <zipper> Can I do asynchronous stuff in the do notation?
13:00:04 * ski disappears
13:00:24 <orzo> zipper, forkIO what you want?
13:01:01 <zipper> orzo: I don't know. Let me see.
13:04:06 <heatsink> > [c|a<-"aA0",c<-takeWhile isAlphaNum[a..]]
13:04:08 <lambdabot>  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
13:04:18 <heatsink> it's three characters longer though
13:05:39 <bergmark> zipper: also see the async package
13:09:00 <ReinH> zipper: see also Simon Marlow's book on parallel and concurrent haskell
13:16:58 <hrumph> hi
13:17:13 <hrumph> are free monads generally inefficient?
13:17:26 <hrumph> the bind operator looks inefficient and i don't see how lazy evaluation would apply
13:18:35 <hrumph> for instance if you have computions that could result in arbitarily large free monads it looks like it would not be a good idea. am i right or wrong?
13:18:55 <hrumph> because the'yll never reduce and there won't be any way to process them completely lazily
13:18:59 <orzo> i don't know, but i lean toward your being right
13:22:16 <orzo> is there anyway to multiply NominalDiffTime by a ratio?
13:22:30 <orzo> i'm using it to hold a duration and want to scale that
13:23:47 <orzo> oh nm, it's Num, had a silly type error i didn't read
13:30:26 * hackagebot microformats2-types 0.4.0 - Microformats 2 types (with Aeson instances)  http://hackage.haskell.org/package/microformats2-types-0.4.0 (myfreeweb)
13:33:02 <osa1> any ideas with which version "build-tools" field added to cabal?
13:38:00 <heatsink> osa1: It was in Cabal before version 1.10
13:39:53 <nocturne777> why does "fmap (1+) (Just 21)" works but "fmap (1+) Just 21" does not?
13:40:22 <shachaf> Because it means "((fmap (1+)) Just) 21"
13:40:22 <Clint> because fmap only takes two arguments
13:40:27 * hackagebot language-lua 0.6.3.1 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.6.3.1 (OmerAgacan)
13:40:42 <monochrom> it is the same reason why "(x y) z" is not "x (y z)". furthermore, "x y z" stands for "(x y) z"
13:40:59 <nocturne777> oh, I see
13:41:27 <monochrom> I have only shown an example of 3 things. you have 4 things. if you want to see the 4-things case explicitly, I can do it too.
13:41:44 <nocturne777> so "fmap (1+) Just 21" makes it look like it is taking 3 parameters. but I thought it would evaluate Just 21 first?
13:41:53 <xnil_____> nocturne777: no
13:41:57 <xnil_____> groups left-to-right
13:41:59 <monochrom> parsing happens before evaluation.
13:42:11 <xnil_____> (((fmap (1+)) Just) 21)
13:42:23 <shachaf> "taking 3 parameters" is a convenient fiction. Every function takes one parameter.
13:42:28 <monochrom> therefore, if the parsing result is bad, no one can change it by appealing to evaluation order.
13:42:30 <myfreeweb> if you don't want the parens, write fmap (1+) $ Just 21
13:43:01 <nocturne777> yeah, I am aware of "$"
13:43:32 <monochrom> "x y z t" is parsed as "((x y) z) t". after that is committed, you worry about evaluation. not before.
13:43:33 <shachaf> $ is complicated. Better to understand the simple parts of Haskell syntax before the complicated parts.
13:43:46 <myfreeweb> now you're aware of the reason it exists
13:45:18 <xnil_____> $ is not really very complicated
13:45:21 <nocturne777> overall, I really like the language at this point
13:45:46 <xnil_____> `a b c d' is parsed as `((a b) c) d'
13:45:54 <nocturne777> I have been using "$" already in my "hello world" functions
13:46:14 <xnil_____> `a b $ c d' is parsed as `a b (c d)'
13:46:43 <shachaf> "a b $ c d" means ((($) (a b)) (c d)
13:46:47 <shachaf> That's complicated.
13:47:06 <nocturne777> map ($3) [+1,+2,+3,+4] is valid as well
13:47:40 <nocturne777> oh there needs to be parantheses in those values
13:48:09 <nocturne777> map ($3) [(+1),(+2),(+3),(+4)] is valid
13:49:57 <monochrom> xnil_____: I'll use an analogy to illustrate complication, or perhaps rather, opposing perspectives on complication.
13:50:27 * hackagebot th-lift 0.7.1 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.7.1 (MathieuBoespflug)
13:50:40 <monochrom> once upon a time, people said, "the moon doesn't come crashing down. an apple does. just memorize this, it is not complicated"
13:51:20 <monochrom> but some other people, such as Newton and me (yay great way to compare myself to Newton!), did not like these ad-hoc rote-memorization rules.
13:52:31 <monochrom> eventually, he figured out one single unifying rule, rather than two separate memorization factoids, that covers both how the moon stays up and the apple comes crashing down.
13:52:56 <monochrom> but the first group of people probably said, "that's too much math! complicated!"
13:53:29 <monochrom> to be fair, I don't think I know how to convince the two groups to reconcile. I think they're doomed to be divided forever.
13:55:12 <monochrom> now, if you showed me 10 formulas each of length 100 characters, I would also find it complicated, too. I do not claim that all math is simple.
13:55:39 <monochrom> but Newton's formulas were like 2, and each was pretty short, sensible, and benign.
14:00:03 <heatsink> Is it possible to put hyperlinks in a code block in Haddock?  'foo' in a code block just becomes 'foo' in the output.
14:00:28 * hackagebot buffer-builder 0.2.0.3 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.0.3 (afriesen)
14:01:39 <c_wraith> In a code block?  I don't think haddock supports that.
14:02:05 <heatsink> ok
14:05:38 <ReinH> monochrom: Epicycles also work well here.
14:09:29 <monochrom> let A1, ..., An be objects. an epicycle is a cycle of epic arrows A1->A2, ..., A(n-1)->An, An->A1. similarly monicycle
14:10:07 <monochrom> a unicycle is a cycle of isomorphisms A1<->A2, ..., A(n-1)<->An, An<->A1.
14:12:15 <zipper> So I have this issue. How do I make one package in a sandbox depend on a different package in a different sandbox both packages being local.
14:12:46 <zipper> When I run cabal install inside the package to be depended on it installs only in its sandbox
14:13:02 <zipper> Therefore the other package can't find it.
14:20:28 * hackagebot wai-middleware-throttle 0.1.0.1 - WAI Middleware for Request Throttling  http://hackage.haskell.org/package/wai-middleware-throttle-0.1.0.1 (ChristopherReichert)
14:22:19 <fresheyeball> howdy folks
14:22:20 <creichert> zipper: cabal sandbox add-source? maybe a shared sandbox, cabal sandbox init --sandbox=/path/to/sbx
14:24:35 <zipper> creichert: Well I want the two to have different sandboxes :(
14:24:42 <zipper> Can't it be done?
14:25:00 <zipper> creichert: What do you mean by cabal sandbox add-source?
14:25:16 <zipper> creichert: I can't see it here https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/packages.html
14:26:13 <zipper> creichert: Yeah add-source should work. Thanks.
14:26:19 <creichert> great
14:26:29 <zipper> Just read the --help
14:28:29 <zipper> creichert: Wait, when I'm passing a path to add source. Which dir should I give to add-source?
14:29:00 <zipper> NVM what I did just worked
14:29:25 <zipper> I gave it the dir of the package as a whole and not the dist/ or src/
14:29:41 <RyanGlScott> Does trace write to stdout or a different handle?
14:35:33 <chreekat> RyanGlScott: quick test says it's stderr
14:36:16 <RyanGlScott> chreekat: Ah, that's why I'm not capturing it. Thanks!
14:36:35 <chreekat> RyanGlScott: I just used runghc on a one line "main = trace "Trace" $ return ()" file, incidentally. :)
14:36:46 <chreekat> (ok, two line, with "import Debug.Trace"
14:36:47 <chreekat> )
14:37:19 <RyanGlScott> chreekat: I probably should have thought of that... oh well, too late.
14:37:26 <chreekat> RyanGlScott: I win!
14:50:18 <SrPx> Is there any language/programming model that works based on rewrite rules
14:51:07 <hpc> CPP
14:51:11 <hpc> lisp
14:53:17 <pavonia> How do you convert a String with only characters <= '\255' to a ByteString again?
14:53:56 <SrPx> lisp is not based on rewrite rules
14:54:17 <c_wraith> pavonia: Data.Bytestring.Char8.pack
14:54:35 <shapr> SrPx: lisp macros?
14:54:41 <pavonia> c_wraith: Ah, thanks!
14:54:41 <FireFly> SrPx: on the esolang side there's e.g. Thue
14:55:18 <hpc> lisp macros are lisp code that outputs lisp code, which is then used in-place
14:55:31 <SrPx> yea I'm looking for an esolang (curiosity), I was thinking something on the lines of, you set a few graph rewrite rules (such as S, K, I) - this is your program - and then apply it to a graph
14:56:37 <Qfwfq> SrPx: http://www.ioccc.org/2012/tromp/hint.html
14:57:24 <SrPx> reading, thanks!
14:57:36 <FireFly> SrPx: also, http://esolangs.org/wiki/Eodermdrome and http://esolangs.org/wiki/Category:String-rewriting_paradigm
14:58:11 <SrPx> Qfwfq: ahn that is just tromp's blc ... I don't get it
15:00:08 <Qfwfq> SrPx: IIRC most of the included programs are expressed with CPP macros for lambda terms.
15:00:44 <Qfwfq> The UM performing your graph reduction.
15:03:07 <SrPx> (still reading, thanks guys)
15:34:59 <TheLemonMan> why does (++ "def") <$> (1, "abc") work fine while pure (++ "def") <*> (1, "abc") throws an error ?
15:37:59 <tomphreek> > newtype Dah a = Dah {runDah :: Int -> Maybe a}
15:38:01 <lambdabot>  <hint>:1:1: parse error on input ‘newtype’
15:38:25 <c_wraith> > pure (++ "def") <*> (1, "abc")
15:38:27 <lambdabot>  No instance for (GHC.Show.Show t0)
15:38:27 <lambdabot>    arising from a use of ‘M364972113099263481812613.show_M3649721130992634818...
15:38:27 <lambdabot>  The type variable ‘t0’ is ambiguous
15:38:41 <c_wraith> :t pure (++ "def") <*> (1, "abc")
15:38:43 <lambdabot> (Monoid t, Num t) => (t, [Char])
15:38:58 <TheLemonMan> > pure (++ "def") <*> ("", "abc")
15:39:04 <lambdabot>  ("","abcdef")
15:39:14 <c_wraith> TheLemonMan: because the Applicative instance for (,) a requires a Monoid on a
15:39:30 <c_wraith> TheLemonMan: and <$> only requires Functor, not Applicative
15:39:57 <tomphreek> runDah (Dah (const Just 3)) 22
15:40:13 <tomphreek> why is it Just 22 rather than Just 3?
15:41:12 <Cale> tomphreek: runDah (Dah (const Just 3)) 22 -> (const Just 3) 22 -> Just 22
15:41:25 <Cale> const x y = x
15:41:57 <Cale> You could have just written  Just  there rather than  const Just 3
15:42:10 <Cale> and the program would mean the same thing
15:42:14 <c_wraith> also, you probably meant const (Just 3)
15:42:50 <tomphreek> Cale, c_wraith cheers
15:44:15 <Xe> I'm having trouble installing lambdabot locally. Is there a dockerfile or the like for it?
15:44:39 <TheLemonMan> c_wraith, thanks :) I had overlooked that detail
15:55:32 * hackagebot hjsonpointer 0.1.0.0 - JSON Pointer library for Haskell  http://hackage.haskell.org/package/hjsonpointer-0.1.0.0 (seagreen)
15:55:43 <shelf> sigh, the gsoc ideas page needs a lot of work
15:56:06 <shelf> besides the spam, half the ideas have already been implemented, and the other half are no longer useful
16:00:53 <btcNeverSleeps> Emacs users: can I live without ghc-mod if I'm using haskell-interactive-mode?  For example ghc-mod's ghc-show-type (C-c C-t) can apparently be replaced by haskell-process-do-type.  Is there something important I'd be missing if I were just to ditch ghc-mod?
16:01:39 <btcNeverSleeps> I plan to use haskell-interactive-mode and flycheck/hdevtools btw. Not sure if I also need, in addition to that, ghc-mod.
16:04:45 <shelf> last I checked, you couldn't use flymake and ghc-mod together. not sure if it conflicts with flycheck though
16:05:40 <shelf> I also had problems with sandboxes when using hdevtools but that was a while ago
16:08:14 <btcNeverSleeps> I see, thanks.  What I still don't understand is what ghc-mod would bring if I already have haskell-mode + haskell-interactive-mode + flycheck+hdevtools.
16:09:02 <_ryan> hi everyone want to ask if what is the good test unit for haskell
16:11:18 <_ryan> hi everyone want to ask if what is the good test unit for haskell
16:12:13 <notdan> _ryan: like a unit test library?
16:12:26 <Xe> _ryan: HUnit?
16:12:34 <_ryan> notdan: yes
16:12:51 <_ryan> thank you.... :)
16:13:46 <shelf> btcNeverSleeps: any differences would be rather subtle, hopefully somebody who knows more will speak up! there was almost no difference for my use
16:15:48 <btcNeverSleeps> shelf: I see, thanks!
16:16:53 <notdan> HUnit, Tasty
16:30:34 * hackagebot haxr 3000.10.4 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.10.4 (BrentYorgey)
16:35:34 * hackagebot hjsonpointer 0.1.0.1 - JSON Pointer library for Haskell  http://hackage.haskell.org/package/hjsonpointer-0.1.0.1 (seagreen)
16:43:53 <ReinH> hdevtools uses a client-server setup to reduce start-up time, ghc-mod does not. On the other hand, ghc-mod seems to be more actively maintained.
16:44:32 <phaazon> god, almost 2:00 AM
16:44:37 <phaazon> and I have to work in a few hours
16:44:48 <phaazon> I guess I’ll just write some netwire code for another hour
16:44:51 <phaazon> then go to bed :)
16:45:06 <phaazon> joining my girl-friend to have some damned sleep
16:46:05 <ReinH> shelf: also I believe haskell-mode is now (optionally?) using ghci-ng for type information.
16:46:29 <pavonia> How do you find the corresponding package name for a given module name?
16:47:26 <chreekat> pavonia: I usually use hoogle/hayoo for that
16:47:50 <shelf> ooo
16:48:15 <orzo> there's an extension that lets us specify package name at the import line
16:48:36 <hpc> hoogle doesn't always index deep enough to map modules to packages, but hayoo does
16:48:36 <pavonia> chreekat: Okay, didn't know Hayoo also accepts module names. Thanks
16:50:35 * hackagebot haxr 3000.10.4.1 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.10.4.1 (BrentYorgey)
16:50:37 * hackagebot constrained-categories 0.2.0.0 - Constrained clones of the category-theory type classes, using ConstraintKinds.  http://hackage.haskell.org/package/constrained-categories-0.2.0.0 (leftaroundabout)
16:50:39 * hackagebot manifolds 0.1.0.2 - Working with manifolds in a direct, embedding-free way.  http://hackage.haskell.org/package/manifolds-0.1.0.2 (leftaroundabout)
16:50:42 <pavonia> But is there no way to make ghc/ghci tell you correct package name for your installation?
16:51:42 <pavonia> In my case Network.URI comes from the network package. However, Google's first result is network-uri (which is not installed on my system)
16:55:35 * hackagebot dynamic-plot 0.1.0.1 - Interactive diagram windows  http://hackage.haskell.org/package/dynamic-plot-0.1.0.1 (leftaroundabout)
17:07:58 <lykos_> Anyone have a channel to recommend for asking SQL questions? I'm learning SQL (using Database.PostgreSQL.Simple), but don't want to go off topic here.
17:09:29 <boj> what does the bang sign before a type in a record defintion mean?  data Foo = Foo { Bar :: !Int }
17:10:32 <Cale> boj: It means that's a strict field. Basically, any use of the constructor Foo will be replaced by (\x -> Foo $! x)
17:10:57 <athan> lykos_: The people in #mysql were very helpful for me!
17:11:05 <athan> or ##mysql, idk
17:11:08 <chreekat> pavonia: Good question, I don't know. "grep -rl Network.URI .cabal-sandbox" returned useful information in my case, but that's not a very robust solution
17:11:26 <Cale> boj: In this case, you can more or less regard it as meaning that an unevaluated Int expression will never be stored in the field, only an evaluated Int.
17:11:43 <boj> Cale: that makes sense, thanks
17:12:16 <Cale> (assuming that the Foo value is itself evaluated, of course)
17:12:22 <lykos_> athan: Thanks!
17:12:26 <athan> :)
17:15:09 <jfeltz> lazy question: is it possible to couple a version of the 'ghc' package (the 'ghc' package that is installed with ghc-7.*) with cabal 1.22.* instead of 1.18..?
17:16:20 <jfeltz> if it depends on 1.18 this creates _a_lot_ of cabal hell in downstream lib dependencies right now
17:20:45 <pavonia> chreekat: I don't use sandboxes, but looking at the result of ghc-pkg dump worked fine
17:23:47 <dfeuer> Why doesn't Data.Vector have an ifoldM'_? Seriously.
17:24:20 <benzrf> dfeuer: ayy lmao
17:24:33 <benzrf> indexed strict monadic fold, discarding result?
17:24:41 <dfeuer> benzrf, yes.
17:24:45 <dfeuer> That's actually what I want :-)
17:24:56 <benzrf> probably lens has sth ;)
17:25:30 <dfeuer> benzrf, it doesn't have *any* indexed monadic folds, although it has indexed folds and monadic folds of all different kinds.
17:25:37 <benzrf> hah
17:25:43 <benzrf> seriously though lens probably does have something
17:25:50 <dfeuer> foldM'_ is a real thing!
17:26:13 <dfeuer> benzrf, yeah, but installing lens is not always so much fun.
17:26:16 <benzrf> have you considered using ifold' and then manually doing the monadic stuff
17:26:44 <dfeuer> benzrf, I'm trying it the other way now (passing the index along a monadic fold)
17:27:04 <benzrf> hmm
17:27:14 <dfeuer> I'm not sure which, if either, will end up efficient.
17:30:56 <bgamari> Is it not possible to express the identity at the type level?
17:31:19 <Hijiri> identity function?
17:31:36 <bgamari> yes
17:31:38 <bgamari> but never mind
17:31:44 <bgamari> I was being silly
17:31:46 <Hijiri> you can do it with type families extension
17:31:50 <Hijiri> or functional dependencies
17:31:54 <bgamari> type family Id (b :: *) :: * -> * where Id b a = b
17:31:59 <bgamari> works just fine
17:32:14 <bgamari> or rather, that is Const
17:32:21 <benzrf> uh, yeah
17:32:41 <bgamari> but regardless the point stands
17:33:31 <dfeuer> bgamari, what point?
17:34:42 <bgamari> dfeuer, that it's entirely possible and I was being silly
17:35:33 <bgamari> unfortunately currying doesn't work
17:35:36 <dfeuer> bgamari, isn't Data.Functor.Identity the identity everywhere?
17:35:50 <init> you don't need anything fancy for that
17:35:55 <init> type Id x = x
17:36:24 <bgamari> init, lacks partial application
17:37:12 <init> didn't know you could partially apply type families :P
17:37:21 <bgamari> It seems you can't
17:37:44 <bgamari> init, which may become a bit problematic
17:38:28 <bgamari> dfeuer, in fact I want type-level `const`, not type level `id`
17:38:40 <SrPx> Is there any obvious name for ` f = floor (x / 2) ` ?
17:38:55 <SrPx> Naming variables is the hardest part of it, you know
17:39:00 <bgamari> dfeuer, but these distinctions become rather blurry after a few glasses of wine
17:39:45 <tommd> SrPx: how about (///)?
17:40:18 <dfeuer> bgamari, ahhhh.... wine and types don't mix.
17:40:20 <SrPx> Ah, I was thinking a wordy name but why?
17:40:37 * hackagebot active 0.1.0.18 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.18 (BrentYorgey)
17:40:38 <dfeuer> bgamari, can't you just use Data.Functor.Constant?
17:40:45 <dfeuer> You can partially apply newtypes....
17:41:02 <bgamari> I suppose I can
17:41:59 <bgamari> dfeuer, I was hoping to avoid the tag but that may not be possible
17:42:30 <dfeuer> bgamari, what tag?
17:45:26 <byorgey> SrPx: how about pessimalHalf ;-)
17:46:18 <SrPx> pessimal?
17:47:21 <bgamari> dfeuer, actually correct me if I'm wrong but Data.Functor.Constant won't do here, I just need a mapping from a type to a given type `f T U = T`
17:50:17 <bgamari> dfeuer, I really just need a type level function
17:50:29 <dfeuer> OK.
17:50:37 * hackagebot TypeNat 0.1.0.0 - Some Nat-indexed types for GHC  http://hackage.haskell.org/package/TypeNat-0.1.0.0 (alexvieth)
17:50:56 <dfeuer> bgamari, most of this type level stuff goes over my head.
17:51:12 <bgamari> dfeuer, I'm still working on it myself
17:51:50 <bgamari> I can work with Idris without much trouble but the bastardized dependent typing supported by GHC definitely adds some cognitive overhead
17:52:44 <nkpart> Hi. I'm looking for laws for the typeclasses in mtl (MonadState, MonadError, etc.), do they exist?
17:54:39 <bgamari> dfeuer, my two attempts are
17:54:39 <bgamari> type family Constant (b :: *) :: * -> * where Constant a = b
17:54:39 <bgamari> type family Constant (b :: *) a :: * where Constant b a = b
17:54:50 <athan> bgamari: Tell me about it xD
17:54:58 <bgamari> unfortunately the latter can't be partially applied
17:55:16 <bgamari> and the former doesn't type check as apparently `b` isn't in scope when I define the equation
17:55:50 <athan> bgamari: If i could have partial application, or higher-order type families / type lambdas, I would be satisfied for about 4 hours
17:57:45 <dfeuer> athan, 4 hours? That's it?
17:57:56 <monochrom> give a man type lambda, and he will be satisfied for 4 hours. show him how to build GHC, and he will be warm for life.
17:59:04 <athan> monochrom: ...To the trenches!
17:59:50 <athan> dfeuer: Okay maybe 5
18:00:25 <ttt_fff> anyone having the following problem: on vim + hdevtools, something gets fucked up, so git grep's output does not get sent to quickfix list? appears to be something weird being done by syntastic + hdevtools + ghc-mod
18:01:54 <Cale> nkpart: I don't know if there's a list anywhere, but to get you started,  get >>= put = return (),  put v >> put v' = put v',  do o <- get; put v; x <- get; put o; return x = return v
18:02:56 <Cale> Perhaps get >> x = x should be there, not sure if it's implied by the others.
18:29:53 <jle`> nkpart: I have looked for these myself, but haven't had much luck. there is a MonadState laws package on hackage that resemble the lens laws but not sure if it's official... haven't found much more than that
18:30:02 <jle`> it's actually a real shame
18:30:44 <jle`> it seems to fly in the face of everything typeclasses are supposed to be in Haskell culture
18:31:21 <jle`> and in such a high profile package too
18:31:22 <nkpart> I found this comment by Gabriel, implying they exist but not in the documentation/anywhere - https://groups.google.com/forum/#!msg/haskell-pipes/BTQsITNwflc/Slhu95CadwgJ
18:33:10 <nkpart> Cale: thanks, I'm specifially interested in MonadError, but also the rest. The laws surely most provide the justification for the Monad superclass on things
18:34:45 <nkpart> An old bug :) https://github.com/ekmett/mtl/issues/5
18:40:47 <athan> What's your favorite book?
18:46:08 <dfeuer> carter, you should be proud of me: http://stackoverflow.com/questions/28659049/how-to-insert-a-value-into-a-sorted-vector-in-a-single-pass/28665345#28665345
18:47:40 <carter> dfeuer: hrm
18:47:41 <carter> reading now
18:55:41 * hackagebot webdriver 0.6.1 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.6.1 (AdamCurtis)
19:00:30 <bgamari> ocharles_, ping
19:04:02 <byorgey> what's the state-of-the-art in terms of a replacement for the HTTP package which has support for https?
19:04:38 <byorgey> I need to update haxr to support https, because Wordpress recently started disallowing non-https XMLRPC calls
19:05:28 <hiptobecubic> the tls package adds https support no?
19:05:41 * hackagebot objective 1.0.1 - Extensible objects  http://hackage.haskell.org/package/objective-1.0.1 (FumiakiKinoshita)
19:05:42 <hiptobecubic> I think conduit uses http-client + tls
19:09:43 <dfeuer> carter, any thoughts?
19:10:09 <carter> dfeuer: did you check if unfold would have fused well?
19:10:27 <dfeuer> carter, as far as I could tell, it would not.
19:10:30 <carter> ok
19:10:39 <dfeuer> [but it's a lot of Core to read]
19:11:17 <carter> would writing the insert sorted have fused well if done on a sorted Stream?
19:11:27 <dfeuer> But the wfindIndex_loop thing looks bad.
19:12:27 <byorgey> hiptobecubic: thanks
19:13:02 <dfeuer> carter, you're thinking about the behavior on a stream vs. an actual real vector. I didn't think about that and don't know nearly enough about streams to say.
19:13:54 <byorgey> hiptobecubic: it looks like there is a http-client-tls package which should work for me
19:14:30 <joneshf-laptop> what is it that makes a type signature like: `foo :: Show a => [a] -> String` so bad?
19:14:48 <dfeuer> carter, won't all that indexing in the unfoldr approach cause trouble for stream fusion too? I'm imagining you're thinking of some kind of magical way to do this with streams *instead*?
19:15:09 <carter> isn't theres an indexed unfold?
19:15:25 <jle`> joneshf-laptop: it's bad?
19:15:29 <hiptobecubic> byorgey, that's what I use as well. There's a bug with ssl/tls 1.2 (i think? I'm not very knowledgeable about this) that manifests as a broken pipe on servers that don't handshake properly somehow or another
19:15:42 * hackagebot rhythm-game-tutorial 0.1.1 - Haskell rhythm game tutorial  http://hackage.haskell.org/package/rhythm-game-tutorial-0.1.1 (FumiakiKinoshita)
19:15:45 <hiptobecubic> byorgey, i don't think you'll see it unless you're talking to bing.
19:15:53 <byorgey> haha, ok
19:15:55 <jle`> glad there is a rhyme game tutorial in haskell
19:16:07 <hiptobecubic> byorgey, https://github.com/vincenthz/hs-tls/issues/87
19:17:08 <joneshf-laptop> jle`, I should rephrase, I was just reading a SO answer
19:17:12 <dfeuer> carter, there is not an indexed unfold as far as I can see.
19:19:45 <duuude> hi
19:19:53 <duuude> so I'm new to haskell, I have a question
19:20:19 <duuude> I heard that as a functional programming language, rather than describe steps (except in monads) you describe things you want, like let a = b
19:20:50 <duuude> so is it possible for example to factor a number  through a filter (as a toy exercise)
19:21:00 <duuude> obviously not efficiently
19:21:07 <dfeuer> duuude, what does "factor a number through a filter" mean?
19:21:29 <duuude> dfeuer, I mean (I don't know the notation) -- composite_number = input function receives
19:21:43 <jle`> > let factor x = filter (\y -> x `mod` y == 0) [1..x] in factor 60
19:21:45 <lambdabot>  [1,2,3,4,5,6,10,12,15,20,30,60]
19:21:52 <duuude> let a and b = such that a * b = composite_number, guard a not equal to 1 and b not equal to 1
19:21:53 <jle`> is that what you mean?
19:22:14 <duuude> what does the `mod` notation do?
19:22:28 <jle`> it's not notation, it's a function heh
19:22:34 <jle`> are you aware of modulo in other languages?
19:22:37 <duuude> I mean the backticks
19:22:38 <duuude> yes
19:22:45 <duuude> > let factor x = filter (\y -> x `mod` y == 0) [1..x] in factor 31337
19:22:46 <lambdabot>  [1,31337]
19:22:51 <duuude> wow
19:22:53 <byorgey> backticks turn a function into an infix operator
19:22:53 <jle`> it lets you use a normal function as a prefix function
19:22:53 <athan> @learn duuude
19:22:54 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
19:22:57 <jle`> er, an infix function
19:23:10 <jle`> > let add x y = x + y in 5 `add` 4
19:23:11 <lambdabot>  9
19:23:12 <duuude> okay, last question
19:23:23 <athan> :p
19:23:38 <duuude> how would you read "> let factor x = filter (\y -> x `mod` y == 0) [1..x] in factor 31337" out loud (as psedocode, i.e. what it actually does)
19:23:58 <athan> Well, the `let ... in` statment can be broken up
19:24:12 <duuude> athan, I mean how would you read the sentence
19:24:14 <duuude> it seems simple
19:24:27 <duuude> but I don't get a lot of the notaqtion like \y
19:24:38 <byorgey> duuude: that is an anonymous function
19:24:40 <athan> so you can first state `factor` as "factor takes an arg `x`, and applies a filter over the first `x` arguments"...
19:24:58 <athan> where the filter is the modulo of `x` and the element currently filtered against
19:25:05 <byorgey> \y -> x `mod` y == 0  is the function which takes y as input and produces  x `mod` y == 0  (i.e. a true/false value) as output
19:25:16 <athan> then we apply factor to 31337
19:26:03 <duuude> is this how to read the sentence: "show the result for 31337 of a new function we define such that x = the filter an anonymous y such that x mod y = 0 over all number 1 through x"
19:26:06 <dfeuer> carter, there doesn't seem to be anything like span or break for Streams, which probably means that isn't supported.
19:26:12 <carter> hrm
19:26:24 <athan> duuude: Actually, we don't necessarilly compute immediately :)
19:26:35 <duuude> ?
19:26:54 <duuude> help me with the notation [1..x]  ... did I read it right just now in my 'translation into english'?
19:27:08 <athan> oh, the span of integers from `1` to `x`
19:27:15 <athan> erm enumeration
19:27:29 <duuude> but what does it mean that you follow 1..x in brackets after the filter (condition) ?
19:27:48 <athan> duuude: Juxtaposition is application in Haskell
19:27:56 <athan> so `f x` ~ `f (x)` in math
19:28:07 <athan> (if that's a word even :|)
19:28:20 <duuude> athan are those `s just your personal quote marks?
19:28:44 <athan> duuude: Yes, sorry, I use them for code like markdown
19:28:54 <athan> I'll try to not confuse :\
19:29:05 <athan> Check it:
19:29:08 <duuude> oh, so kinda like Perl when numbers aren't requried - like  >>>  print sort @a<<< is a way of writing >>> print (sort (@)) <<< in Perl
19:29:10 <athan> > [1..]
19:29:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
19:29:17 <athan> > [1..10]
19:29:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:29:22 <duuude> I meant where Parentheses aren't requried, not numbers
19:29:59 <athan> duuude: I don't know perl :\ but probably!
19:30:50 <athan> You could also look at it like: `let (.....) in (.....)` for let statements
19:30:56 <athan> er actually
19:31:12 <athan> `let foo = (.....) in (.....)`
19:31:23 <athan> where `foo` may occour in the right code
19:31:28 <athan> s/right/rightward
19:31:31 <duuude> in a private window wiht lambabot I tried to write this: \y -> 15 `mod` y == 0 [5]       but got an error.  how come?
19:31:49 <duuude> I expected it to call my anonymous function with a value of 5, i.e. return 15 mod 5
19:31:53 <athan> Ahh, there you need parens
19:32:04 <duuude> You just said I didn't!  That juxtaposition was enough :)
19:32:10 <athan> so (\y -> 15 `mod` y == 0) [5]
19:32:25 <athan> duuude: There are still precedence and fixity rules!
19:32:31 <athan> for each operator :x
19:32:38 <duuude> oh okay
19:32:44 <duuude> so what was [5] binding more tightly with?
19:33:03 <athan> actually is was the space that was binding tightly, pretty sure
19:33:12 <duuude> do you think it was interpreted as >>>\y -> 15 `mod` y == (0 [5]) <<< or what?
19:33:19 <athan> it was trying to be part of the function body, basically
19:33:26 <duuude> oh like this:
19:33:26 <athan> yep
19:33:32 <athan> er actually
19:33:33 <duuude> >>>\y -> (15 `mod` y == 0 [5])
19:33:42 <athan> to == probably
19:33:46 <athan> so it would be like
19:34:08 <athan> \y -> (==) (15 `mod` y) 0 [5]
19:34:29 <duuude> okay
19:34:32 <athan> so (==) gets applied `(15 `mod` y)`, `0`, and `[5]`
19:34:38 <athan> (but it can't)
19:34:59 <duuude> makes sense - though the error messsage is cryptic :)
19:35:04 <athan> that can be kinda tricky when diagnosing errors in haskell :\
19:35:12 <athan> Lets see?
19:35:23 <athan> > \y -> 15 `mod` y == 0 [5]
19:35:25 <lambdabot>  Could not deduce (GHC.Num.Num ([t0] -> a))
19:35:25 <lambdabot>    arising from the ambiguity check for ‘e_11505’
19:35:25 <lambdabot>  from the context (GHC.Num.Num ([t] -> a),
19:35:38 <athan> Ahh! So duuude, this is one step higher - typeclasses
19:35:44 <athan> erm
19:35:47 <athan> yeah
19:36:08 <duuude> by the way neither         > \y -> 15 `mod` y == 0 ([5])             nor      > (\y -> 15 `mod` y == 0) [5]                   works either
19:36:12 <athan> okay so, the number system is overloaded - number literals actually belong to classes of conceptual number sets
19:36:39 <duuude> welll how do I fix it so that returns true :)  (becuase 15 mod 5 is 0)
19:37:00 <init> \y -> 15 `mod` y == 0 [5] parses as (\y -> mod 15 (y == (0 [5]))), that's from where the Num instance appears
19:37:01 <athan> It's basically trying to apply `[5]` to the overloaded number literal 0
19:37:14 <duuude> that's fine but how do i fix it
19:37:24 <duuude> I just want it to send 5 to my anonymous function as an argument and print the result
19:37:25 <athan> Oh hmm
19:37:31 <duuude> kind of like  > \y -> 15 `mod` y == 0 (5)
19:37:37 <duuude> or like  > \y -> 15 `mod` y == 0 ([5])
19:37:40 <duuude> or whatever hte notation is
19:37:41 <athan> oh dude your types don't match
19:37:44 <athan> erm duuude
19:37:47 <init> > (\y -> y * 2) 5
19:37:49 <lambdabot>  10
19:37:49 <duuude> dude I'm just using numbers
19:37:53 <init> something like this duuude?
19:38:25 <athan> duuude: When you apply your anon function to [5], `y`s type becomes a list of numbers, not a single number
19:38:28 <duuude> > (\y -> (15 `mod` y == 0)) 5
19:38:29 <lambdabot>  True
19:38:32 <duuude> yay success
19:38:36 <athan> der u go
19:38:45 <duuude> > (\y -> (15 `mod` y == 0)) [5]
19:38:46 <lambdabot>  No instance for (GHC.Num.Num [t0]) arising from the literal ‘15’No instance ...
19:38:47 <lambdabot>    arising from a use of ‘GHC.Real.mod’No instance for (GHC.Classes.Eq t0)
19:38:47 <lambdabot>    arising from a use of ‘GHC.Classes.==’
19:38:51 <duuude> okay
19:38:55 <duuude> > (\y -> (15 `mod` y == 0)) [1.5]
19:38:56 <lambdabot>  No instance for (GHC.Num.Num [t0]) arising from the literal ‘15’No instance ...
19:38:57 <lambdabot>    arising from a use of ‘GHC.Real.mod’No instance for (GHC.Classes.Eq t0)
19:38:57 <lambdabot>    arising from a use of ‘GHC.Classes.==’
19:38:57 <duuude> > (\y -> (15 `mod` y == 0)) [1..5]
19:38:58 <lambdabot>  No instance for (GHC.Num.Num [t0]) arising from the literal ‘15’No instance ...
19:38:58 <lambdabot>    arising from a use of ‘GHC.Real.mod’No instance for (GHC.Classes.Eq t0)
19:38:59 <lambdabot>    arising from a use of ‘GHC.Classes.==’
19:39:06 <athan> duuude: Have you heard of map/reduce?
19:39:09 <duuude> how do I do this part then?
19:39:12 <duuude> athan - not so much
19:39:22 <athan> duuude: so there's a lot of good stuff here
19:39:29 <athan> in maps / folds (or reduce)
19:39:38 <dfeuer> carter, I had an idea. I think it might be possible to do this by digging *deep* down.
19:39:43 <duuude> athan - how do I repeat what worked > (\y -> (15 `mod` y == 0))     over a range of numbers 1..5
19:40:01 <duuude> (\y -> (15 `mod` y == 0)) 5
19:40:08 <duuude> > (\y -> (15 `mod` y == 0)) 5
19:40:09 <athan> > map (\y -> y) [1..5] -- duuude
19:40:09 <lambdabot>  True
19:40:11 <lambdabot>  [1,2,3,4,5]
19:40:17 <duuude> athan - thanks
19:40:19 <athan> sorry I got lazy :P
19:40:39 <init> duuude: map applies a function to every element in a list, and returns a new one with results
19:40:43 * hackagebot call 0.1.4.1 - The call game engine  http://hackage.haskell.org/package/call-0.1.4.1 (FumiakiKinoshita)
19:40:44 <duuude> > map (\y -> (15 `mod` y == 0)) [1..5]
19:40:45 <lambdabot>  [True,False,True,False,True]
19:40:46 <dfeuer> Maybe.
19:40:48 <dfeuer> Maybe not.
19:41:06 <duuude> now how do I go from what I just did, to just printing the values that were True  (i.e. 1, 3, and 5)
19:41:21 <athan> :o call? o_o
19:41:32 <athan> thats filter you want :P
19:41:50 <athan> > filter (\y -> even y) [1..5] -- duuude
19:41:52 <lambdabot>  [2,4]
19:42:02 <athan> :t even
19:42:03 <lambdabot> Integral a => a -> Bool
19:42:10 <duuude> > filter (\y -> (15 `mod` y == 0)) [1..5]
19:42:12 <lambdabot>  [1,3,5]
19:42:14 <athan> duuude: `even` returns a Bool
19:42:14 <duuude> nice
19:42:19 <duuude> yes okay I get this
19:42:43 <duuude> so map and filter are very very close.  it's like filter uses map (and then just takes and true values and prints the values that made it true - right?
19:42:45 <duuude> because look:
19:42:57 <duuude> > map (\y -> (15 `mod` y == 0)) [1..5]
19:42:59 <lambdabot>  [True,False,True,False,True]
19:43:01 <duuude> > filter (\y -> (15 `mod` y == 0)) [1..5]
19:43:03 <lambdabot>  [1,3,5]
19:43:03 <athan> duuude: (:
19:43:04 <duuude> soo?
19:43:07 <duuude> see?
19:43:08 <duuude> I mean
19:43:17 <duuude> athan - very cool
19:43:21 <athan> @src map
19:43:21 <lambdabot> map _ []     = []
19:43:21 <lambdabot> map f (x:xs) = f x : map f xs
19:43:22 <xnil> duuude: s/map/filter/
19:43:23 <ReinH> duuude: have you used foldr?
19:43:25 <athan> @src filter
19:43:26 <lambdabot> filter _ []     = []
19:43:26 <lambdabot> filter p (x:xs)
19:43:26 <lambdabot>     | p x       = x : filter p xs
19:43:26 <lambdabot>     | otherwise = filter p xs
19:43:32 <athan> ^ duuude
19:43:53 <duuude> okay
19:44:07 <duuude> xnil - in which of my statements did you mean to correct me?
19:44:14 <athan> :t filter
19:44:15 <lambdabot> (a -> Bool) -> [a] -> [a]
19:44:22 <xnil> duuude:
19:44:38 <athan> so `p :: a -> Bool`, and (x:xs) :: [a] (and so does xs :: [a])
19:44:42 <athan> (and x :: a)
19:44:59 <duuude> there's just one more part.  so what's reduce do in my example, how would I use it?
19:45:08 <athan> Ahh okay
19:45:13 <athan> I just wanted to make sure you got it so far
19:45:18 <duuude> yes
19:45:29 <athan> so folds / reductions / catamorphisms are like this:
19:45:30 <duuude> though I don't understand the notation lambdabot has been quoting
19:45:32 <athan> :t foldl
19:45:33 <lambdabot> (b -> a -> b) -> b -> [a] -> b
19:45:44 <duuude> I don't really get that notation
19:45:47 <duuude> can we use my example?
19:45:50 <duuude> this is what I get:
19:45:53 <athan> Basically, we have a binding binary function, a starting value, and the list to process
19:45:54 <duuude> > map (\y -> (15 `mod` y == 0)) [1..5]
19:45:55 <lambdabot>  [True,False,True,False,True]
19:45:58 <athan> hmm
19:45:59 <athan> okay
19:46:00 <athan> so
19:46:10 <athan> > foldl (+) 0 [1..5]
19:46:12 <lambdabot>  15
19:46:24 <duuude> what this does is make an anonymous function y that returns whether 15 mod y is exactly 0.  Then it calls that function with values 1..5.  (1, 2, 3, 4, 5) and returns the list of results
19:46:31 <duuude> similarly,
19:46:35 <duuude> > filter (\y -> (15 `mod` y == 0)) [1..5]
19:46:36 <lambdabot>  [1,3,5]
19:47:00 <ReinH> duuude: I can use foldr to copy a list like this:
19:47:04 <duuude> does almost the same thing.  After figuring out (as with map) whether the results are true, for all the true results it returms the list of values that made it true)
19:47:11 <ReinH> > foldr (\x xs -> x : xs) [] [1..10]
19:47:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:47:24 <ReinH> duuude: if I have a function, I can apply that function to x first:
19:47:26 <duuude> ReinH can you read that in English?
19:47:33 <duuude> " > foldr (\x xs -> x : xs) [] [1..10]"
19:47:44 <duuude> the way I read my two examples of map and filter just now
19:47:59 <xnil> > filter (((==) 0) . mode 15) [1..5]
19:48:01 <lambdabot>  Couldn't match expected type ‘a -> b0’
19:48:01 <ReinH> :t foldr
19:48:01 <lambdabot>              with actual type ‘Text.PrettyPrint.HughesPJ.Mode’
19:48:02 <lambdabot> (a -> b -> b) -> b -> [a] -> b
19:48:16 <Cale> duuude: foldr f z replaces each occurrence of (:) in a list with f and the [] at the end (if any) with z
19:48:47 <duuude> what does "and the [] at the end" mean?
19:48:54 <ReinH> fold: in this case, I'm taking a list and folding it by prepending each x onto the rest of the list to be folded, giving back the original list
19:48:59 <ab9rf> a list [a,b,c] is actually a:b:c:[]
19:49:12 <ab9rf> : associates to the left
19:49:16 <ReinH> > foldr f z [1,2,3] :: Expr
19:49:17 <lambdabot>  f 1 (f 2 (f 3 z))
19:49:24 <duuude> this notationj is super confusing
19:49:26 <Cale> yeah and (:) associates to the right, so that's a : (b : (c : []))
19:49:34 <ab9rf> sorry, to the right
19:49:43 <ab9rf> i need more caffeine or more bourbon, not sure which
19:50:02 <duuude> ab9rf - good summary of what it's like to learn a functional language for hte first time!!! :)
19:50:33 <Cale> duuude: Okay, so, a list in Haskell (or in general, I guess) is either the empty list []
19:50:47 <duuude> can you again read in English " foldr (\x xs -> x : xs) [] [1..10]" ?
19:51:01 <Cale> or it is a nonempty list formed by adding an element x to another list xs, written (x:xs)
19:51:42 <Cale> So, foldr (:) [] [1..10] will replace each occurrence of (:) with (:) and each occurrence of [] with [], which does nothing.
19:51:54 <Cale> (\x xs -> x:xs) is the same thing as (:)
19:52:11 <ReinH> duuude: So instead, I can apply a function to each x first
19:52:21 <duuude> how do you read x:xs ?
19:52:48 <duuude> > foldr (:) [] [1..5]
19:52:49 <lambdabot>  [1,2,3,4,5]
19:52:57 <duuude> > foldr (:) [7] [1..5]
19:52:58 <lambdabot>  [1,2,3,4,5,7]
19:53:05 <Cale> "ecks colon eckses" (the xs is "plural", it stands for the remainder of the list)
19:53:11 <duuude> oh so the second argument to foldr just tells you what to put at the end?
19:53:21 <duuude> Cale - thanks
19:53:29 <Cale> > foldr (+) 0 [1,10,100]
19:53:31 <lambdabot>  111
19:53:37 <Cale> > foldr (+) 1000 [1,10,100]
19:53:39 <lambdabot>  1111
19:53:50 <ReinH> duuude: if I apply a function to each x first:
19:54:03 <ReinH> > foldr (\x xs -> x + 1 : xs) [] [1..10]
19:54:05 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
19:54:20 <duuude> Cale - so foldr is like an s// ?  it's like you did s/,/+/   - replace all commas in the expression 1,10,100 with +'s like this  1+10+100?
19:54:30 <Cale> yes, kind of like that
19:54:32 <ReinH> if I check whether each x matches a predicate before deciding to (:) it:
19:54:34 <ReinH> > foldr (
19:54:34 <Cale> > foldr (\x xs -> concat ["(f ",show x," ",xs,")"]) "z" [1,2,3,4,5]
19:54:35 <lambdabot>  <hint>:1:8:
19:54:35 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:54:35 <lambdabot>  can't find file: L.hs
19:54:38 <Cale> ...
19:54:40 <Cale> > foldr (\x xs -> concat ["(f ",show x," ",xs,")"]) "z" [1,2,3,4,5]
19:54:41 <lambdabot>  "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
19:54:46 <ReinH> > foldr (x xs -> if even x then x : xs else xs) [] [1..10]
19:54:47 <lambdabot>  Pattern syntax in expression context:
19:54:47 <lambdabot>      x xs -> if even x then x : xs else xs
19:54:49 <duuude> that is gnarly synttax it's too hard
19:55:05 <ReinH> woops
19:55:17 <duuude> Cale's earlier example was easier
19:55:23 <xnil> lol no
19:55:25 <ReinH> > foldr (\x xs -> if even x then x : xs else xs) [] [1..10]
19:55:27 <lambdabot>  [2,4,6,8,10]
19:55:29 <xnil> Cale: please use spaces pls
19:55:39 <ReinH> duuude: compare
19:55:40 <duuude> foldr (+) 0 [1..1000]
19:55:41 <Cale> xnil: spaces?
19:55:43 <duuude> > foldr (+) 0 [1..1000]
19:55:44 * hackagebot colors 0.3.0.2 - A type for colors  http://hackage.haskell.org/package/colors-0.3.0.2 (FumiakiKinoshita)
19:55:45 <lambdabot>  500500
19:55:48 <ReinH> > foldr (\x xs -> x + 1 : xs) [] [1..10]
19:55:50 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
19:55:56 <ReinH> > map (\x -> x + 1) [1..10]
19:55:57 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
19:56:18 <ReinH> a map is a particular kind of foldr
19:56:21 <ReinH> compare
19:56:25 <ReinH> > foldr (\x xs -> if even x then x : xs else xs) [] [1..10]
19:56:26 <lambdabot>  [2,4,6,8,10]
19:56:31 <ReinH> > filter even [1..10]
19:56:32 <lambdabot>  [2,4,6,8,10]
19:56:35 <ReinH> and so is filter
19:56:37 <duuude> interesitn
19:56:47 <Cale> duuude: anyway, foldr f z (1 : (2 : (3 : (4 : (5 : []))))) = (f 1 (f 2 (f 3 (f 4 (f 5 z)))))
19:57:09 <xnil> > filter ((==) 0 . mode 15) [1..5]
19:57:10 <lambdabot>  Couldn't match expected type ‘a -> b0’
19:57:10 <lambdabot>              with actual type ‘Text.PrettyPrint.HughesPJ.Mode’
19:57:24 <Cale> (that was sort of the idea of the weird example I gave using concat -- to construct a string which shows the expression it would build)
19:57:54 <duuude> Cale - don't use weird examples yet because I don't know all the syntax by heart so I can barely figure out easy examples
19:58:16 <Cale> duuude: Well, okay -- the result was the more interesting thing than the expression :)
19:58:17 <duuude> it was a challenge to figure out how to read the 15 mod 5 examples from earlier
19:58:23 <duuude> Cale - okay
19:58:29 <Cale> (f 1 (f 2 (f 3 (f 4 (f 5 z)))))
19:58:33 <duuude> yes
19:58:46 <duuude> and f 5 z is just f(5,z) right?
19:58:50 <Cale> yeah
19:59:02 <duuude> is 1:2:3 the same as [1,2,3]
19:59:10 <ReinH> f 5 z in Haskell might be f(5,z) in another language.
19:59:14 <Cale> Well, f(5,z) in Haskell would be something different, yes
19:59:15 <ReinH> duuude: 1:2:3:[]
19:59:30 <Cale> > let (x:xs) = [1,2,3,4,5] in x
19:59:31 <lambdabot>  1
19:59:33 <Cale> > let (x:xs) = [1,2,3,4,5] in xs
19:59:35 <lambdabot>  [2,3,4,5]
19:59:37 <duuude> ReinH: but also in Haskell right -- anytime you can write  f 5 z you can also write f(5,Z) right?
19:59:42 <ReinH> duuude: no
19:59:43 <Cale> > 1 : [2,3]
19:59:44 <lambdabot>  [1,2,3]
19:59:45 <duuude> ReinH
19:59:46 <duuude> oh
20:00:05 <Cale> f (5,z) means to apply the function f to the *pair* (5,z)
20:00:08 <duuude> ReinH I don't understand why you're manually putting an empty set at the end of 1:2:3:[]
20:00:16 <kadoban> duuude: You'll be able to follow these a lot better once you study haskell basics a bit. Are you learning from any material in particular? If not https://github.com/bitemyapp/learnhaskell has some good recomendations.
20:00:22 <ReinH> duuude: because (:) prepends an element onto a list
20:00:22 <xnil> duuude: all lists end in an empty list
20:00:29 <Cale> While f 5 z means (f 5) z, which means apply the function f to the number 5, and then apply the resulting function to z
20:00:33 <ReinH> 1:2:3:[] = 1:(2:(3:[]))
20:00:33 <duuude> Yes, I kind of tried reaidng through learn you some haskell for great good
20:00:48 <Cale> duuude: Whenever you see f x y z in Haskell, it really means ((f x) y) z
20:00:57 <duuude> xnil: but to construct a list myself explicitly like 1:2:3  I don't have to manually add a 1:2:3:[] do I?
20:01:00 <ReinH> prepend 1 onto the list created by prepending 2 onto the list created by prepending 3 onto the empty list
20:01:04 <xnil> duuude: you do.
20:01:13 <Cale> i.e. Apply f to x, getting some resulting function, and then apply that function to y, getting yet another function, and apply that to z
20:01:13 <ReinH>  > 1:2:3
20:01:19 <ReinH> > 1:2:3
20:01:20 <lambdabot>  No instance for (GHC.Show.Show a0)
20:01:20 <lambdabot>    arising from a use of ‘M649342209217246658717017.show_M6493422092172466587...
20:01:20 <lambdabot>  The type variable ‘a0’ is ambiguous
20:01:26 <xnil> you can't prepend something with : to something that isnt a list
20:01:31 <ab9rf> 1:2:3 doesn't typecheck
20:01:34 <ReinH> The error isn't helpful
20:01:34 <Cale> lambdabot, your type errors kinda suck lately
20:01:40 <ab9rf> and the message lambdabot gives is unhelpful
20:01:46 <xnil> @type (:)
20:01:46 <ab9rf> > 'a':'b':'c'
20:01:48 <Cale> I wonder when that happened
20:01:48 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
20:01:48 <lambdabot>              with actual type ‘GHC.Types.Char’
20:01:49 <lambdabot> a -> [a] -> [a]
20:01:51 <xnil> oops
20:01:57 <xnil> there
20:02:04 <jle`> the error in ghci isn't much more helpful to a new person
20:02:04 <xnil> a -> [a] -> [a]
20:02:06 <ReinH> Cale: maybe we need to undefine something?
20:02:09 <Cale> Yeah
20:02:16 <xnil> (:) takes a list as a second argument
20:02:44 <duuude> I don't get why I would need ot put a [] manually at the end of - 1:2:3:[]    I mean isn't it implicit?
20:02:49 <Cale> nope
20:02:50 <xnil> duuude: no
20:02:52 <xnil> : is a function
20:02:57 <Cale> Each (:) adds one element to *another list*
20:02:58 <duuude> if 1:2:3 is a syntax error then why wouldn't lambadabot just add the []
20:03:03 <Cale> 3 isn't a list
20:03:07 <Cale> So you can't write 2 : 3
20:03:08 <xnil> it's not a syntax error.
20:03:09 <duuude> ohhhh
20:03:11 <xnil> it's a type error
20:03:15 <duuude> > 1:2:3:[]
20:03:16 <lambdabot>  [1,2,3]
20:03:17 <ab9rf> ^ that
20:03:20 <duuude> > 1:2:3
20:03:21 <Cale> > 1 : [2,3]
20:03:21 <lambdabot>  No instance for (GHC.Show.Show a0)
20:03:21 <lambdabot>    arising from a use of ‘M123183641069046268317132.show_M1231836410690462683...
20:03:21 <lambdabot>  The type variable ‘a0’ is ambiguous
20:03:23 <lambdabot>  [1,2,3]
20:03:24 <duuude> > 1:2:[3]
20:03:26 <lambdabot>  [1,2,3]
20:03:35 <kadoban> duuude: Because languages guessing what you actually meant don't turn out to be a good idea.
20:03:36 <xnil> > 1:[2,3]
20:03:38 <lambdabot>  [1,2,3]
20:03:46 <ab9rf> kadoban: indeed!
20:04:00 <duuude> so why not just put [] around the last element by convention - 1:2:[3]  rther than waste a character and make you write 1:2:3:[]
20:04:00 <kadoban> For proof of that, look at HTML and javascript…
20:04:16 <kadoban> duuude: Because nobody would write it that way anyway.
20:04:18 <duuude> it's hard to argue that JS was a bad idea...
20:04:19 <nshepperd> seems like lambdabot vomits up that message whenever there's a typeclass involved
20:04:20 <ab9rf> duuude: because sometimes you write x:xs
20:04:25 <ab9rf> duuude: where xs is a LIST
20:04:29 <Cale> duuude: The reason we're writing 1 : (2 : (3 : [])) is to show you the real structure of the list
20:04:43 <kadoban> duuude: It's not hard to argue that its "guess where I meant to put semicolons" behavior was a bad choice. Even most JSers agree.
20:04:51 <ab9rf> duuude: it's not hard to argue that javascript is a bad idea, i've done it manyu timnes
20:04:52 <Cale> duuude: This is directly in correspondence with what exists in memory, or how pattern matching will happen
20:04:57 <duuude> walk me through what 'xs' is?  is xs a syntactic thing, like it has a special meaning to end a variable with s?
20:05:05 <kadoban> No
20:05:05 <ab9rf> duuude: no, it's just a convention
20:05:07 <Cale> xs is just another variable name
20:05:10 <duuude> could you call x:xs as x:therestofthelistofx
20:05:13 <Cale> yeah
20:05:14 <ab9rf> duuude: yes
20:05:16 <duuude> okay
20:05:17 <duuude> thanks
20:05:22 <duuude> this clears up a lot
20:05:30 <ab9rf> > let x:otherstuff = [1,2,3,4,5] in otherstuff
20:05:31 <lambdabot>  [2,3,4,5]
20:05:34 <kadoban> You could write it xs:x if you really want to be confusing, but don't.
20:05:59 * hackagebot dbmigrations 0.8.2 - An implementation of relational database "migrations"  http://hackage.haskell.org/package/dbmigrations-0.8.2 (JonathanDaugherty)
20:06:01 <Cale> (because that means the first element of the list will be called xs and the rest of the list will be called x)
20:06:48 <Cale> > foldr (++) [] [[1,2,3],[4,5],[6,7,8]]
20:06:49 <lambdabot>  [1,2,3,4,5,6,7,8]
20:07:01 <Cale> > foldr (*) 1 [1,2,3,4,5]
20:07:03 <lambdabot>  120
20:07:05 <duuude> okay, thanks guys.  you've been super, super-helpful.  especially interesitng was what you said abut f x y z  being a number of functions (.e.g ---  "Whenever you see f x y z in Haskell, it really means ((f x) y) z")
20:07:11 <Cale> Yeah
20:07:16 <dfeuer> Cale, can you get the powers that be to make ScopedTypeVariables (or something at least that good) the default?
20:07:17 <Cale> and correspondingly in the types
20:07:23 <Cale> When you see A -> B -> C -> D
20:07:30 <Cale> it really means A -> (B -> (C -> D))
20:07:45 <Cale> dfeuer: You should ask int-f
20:07:48 <Cale> int-e rather
20:07:53 <dfeuer> It's so bloody useful for tracking down type errors.
20:08:11 <dfeuer> Cale, why int-e?
20:08:23 <Cale> Because he's the one running lambdabot?
20:08:28 <Cale> Or are you not talking about lambdabot?
20:08:30 <duuude> how do you read  let x:otherstuff = [1,2,3,4,5] in otherstuff
20:08:32 <duuude> >  let x:otherstuff = [1,2,3,4,5] in otherstuff
20:08:32 <dfeuer> Oh, I don't mean for lambdabot :-P
20:08:33 <lambdabot>  [2,3,4,5]
20:08:39 <duuude> >  let x:otherstuff = [1,2,3,4,5] in [5,6,7]
20:08:40 <kadoban> I think he may have meant the default for haskell :)
20:08:41 <lambdabot>  [5,6,7]
20:09:03 <Cale> duuude: let <declarations> in <expression>  is a form of expression where the definitions made after the 'let' are available for use in the expression following the 'in'
20:09:14 <Cale> > let x = 5 in x * x
20:09:15 <lambdabot>  25
20:09:51 <Cale> dfeuer: I have as much control as you do over the specification of Haskell :P
20:10:03 <duuude> so it doesn't make sense for me to write let (blah blah blah) in [5]  because there is no variable in 5 right?
20:10:10 <dfeuer> Cale, you are older and wiser, which *should* give you more sway.
20:10:20 <duuude> it would make sense for me to write let (blah blah blah) in 5 * x
20:10:23 <Cale> duuude: Yeah, it wouldn't accomplish much
20:10:29 <Cale> yeah
20:10:43 <Cale> > let x = sum [1..10] in 5 * x
20:10:45 <lambdabot>  275
20:10:55 <Cale> > 5 * sum [1..10]
20:10:56 <lambdabot>  275
20:11:05 <Cale> > let f x = x^2 + x + x in map f [1..10]
20:11:06 <lambdabot>  [3,8,15,24,35,48,63,80,99,120]
20:11:17 <duuude> yes i got that
20:11:50 <Cale> > let ones = 1 : ones in ones
20:11:51 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:11:57 <Cale> ^^ magic :)
20:12:01 <duuude> yes
20:12:20 <duuude> what does this do then - x:otherstuff
20:12:22 <Cale> This just goes to show that the definitions made by let are allowed to be recursive
20:12:39 <Cale> When you're defining something, you're allowed to pattern match it
20:12:51 <duuude> > let x:otherstuff = [1,2,3,4,5] in otherstuff
20:12:53 <lambdabot>  [2,3,4,5]
20:13:20 <Cale> > let x:xs = [1,2,3,4,5] in xs -- same thing of course
20:13:22 <lambdabot>  [2,3,4,5]
20:13:39 <Cale> > let x:xs = [1,2,3,4,5] in (x,xs)
20:13:40 <lambdabot>  (1,[2,3,4,5])
20:14:06 <Cale> > let x:xs = [] in (x,xs) -- this will cause a runtime error though, so be careful
20:14:07 <lambdabot>  (*Exception: <interactive>:3:5-13: Irrefutable pattern failed for pattern x ...
20:14:08 <duuude> well, that's a bit confusing
20:14:23 <Cale> hmm
20:14:27 <jle`> it might make more sense if you write it in non-sugary form
20:14:37 <duuude> > let x = 5 in x*x
20:14:39 <lambdabot>  25
20:14:41 <jle`> > let (x):(xs) = (1):(2:3:4:5[]) in (x, xs)
20:14:42 <duuude> this I get
20:14:42 <lambdabot>  Could not deduce (GHC.Num.Num ([t0] -> [t]))
20:14:42 <lambdabot>    arising from the ambiguity check for ‘x’
20:14:43 <lambdabot>  from the context (GHC.Num.Num ([t1] -> [t]), GHC.Num.Num t)
20:14:47 <jle`> > let (x):(xs) = (1):(2:3:4:5:[]) in (x, xs)
20:14:49 <lambdabot>  (1,[2,3,4,5])
20:14:59 <jle`> you see, the 1 "matches" with the x
20:15:08 <jle`> and the 2:3:4:5:[] "matches" with the xs
20:15:18 <duuude> let's read let x = 5 in x * x in English.  Print/return the value of x*x  when we let x = 5
20:15:51 <duuude> now do the same for let first_element:x = [1,2,3,4,5] in x
20:16:02 <Cale> Or just "the value of x * x when x = 5"
20:16:06 <Cale> would be better
20:16:06 <duuude> can you read it in English the same way?
20:16:08 <duuude> > let first_element:x = [1,2,3,4,5] in x
20:16:10 <lambdabot>  [2,3,4,5]
20:16:15 <kadoban> duuude: It definitely doesn't mean print. It kinda means return, but it's better to think of it as the value of the expression.
20:16:28 <duuude> kadoban I meant for our purposes here, with lambdabot
20:16:35 <jle`> the most clear thing is something like let (x,y) = (1,2) in x
20:16:39 <Cale> The printing part is just something that lambdabot is doing for us
20:16:43 <jle`> > let (x, y) = (1, 2) in x
20:16:44 <lambdabot>  1
20:16:45 <duuude> how can you read what we're doing with lambdabot with "let first_element:x = [1,2,3,4,5] in x"
20:16:54 <jle`> it's called pattern matching
20:17:00 <jle`> (x, y) and (1, 2) have the same "structure"
20:17:02 <Cale> "the value of x when first_element:x is equal to [1,2,3,4,5]
20:17:03 <Cale> "
20:17:10 <xnil__> duuude: let first_element:x = [1,2,3,4,5] in x is the same as doing
20:17:14 <jle`> and it's clear to see that the 1 "matches" with the x, and the 2 "matches" with the y
20:17:26 <xnil__> (\first_element:x -> x) [1,2,3,4,5]
20:17:31 <xnil__> err
20:17:37 <xnil__> (\(first_element:x) -> x) [1,2,3,4,5]
20:17:48 <Cale> duuude: You're okay with the fact that [1,2,3,4,5] is syntax sugar for 1 : (2 : (3 : (4 : (5 : [])))) already, yeah?
20:17:59 <duuude> "The value of x * x when x = 5" is clear... so "the value of x when we let firstelement:x = [1,2,3,4,5]"?
20:18:07 <Cale> yep
20:18:08 <xnil__> `let ... in ...' statements are like lambdas
20:18:11 <xnil__> that get called
20:18:12 <Cale> exactly that
20:18:24 <duuude> okay I get it now.  it's weird because you don't actually need firstelement
20:18:36 <duuude> it's like you're solving a single equation with two variables
20:18:36 <xnil__> duuude: you can do
20:18:44 <duuude> I mean you're not using it
20:18:46 <duuude> I can say
20:18:46 <xnil__> let _:x = [1,2,3,4,5] in x
20:18:47 <xnil__> i think
20:18:49 <Cale> right, you could use the pattern _ to not give a name to that element
20:18:52 <xnil__> yeah
20:19:00 <jle`> duuude: yes, that's exactly it :)
20:19:05 <jle`> it's like solving an equation
20:19:08 <Cale> _ will match anything, without giving it a name
20:19:14 <duuude> yes
20:19:16 <jle`> > let (x, y) = (1, 2) in x + y
20:19:17 <duuude> interesting
20:19:18 <lambdabot>  3
20:19:23 <jle`> you "solve" x to be 1, and y to be 2
20:19:38 <jle`> the same deal with lists, instead of having (,) you have (:)
20:19:50 <duuude> > let _:x = [1,2,3,4,5] in x
20:19:51 <lambdabot>  [2,3,4,5]
20:19:56 <duuude> interesting
20:19:58 <Cale> The thing which makes it always possible to solve these equations is that you're only allowed to pattern match against data constructors and not arbitrary functions
20:20:03 <jle`> > let x : xs = 1 : (2:3:4:5:[]) in xs
20:20:04 <lambdabot>  [2,3,4,5]
20:20:22 <jle`> x is "solved to be" 1 (it's on the left side of the ":")
20:20:28 <jle`> the xs is "solved to be " (2:3:4:5:[])
20:21:30 <Cale> Values that are constructed using data constructors are built up in memory out of integer tags and pointers to the parts, so that when you pattern match, it can bind the variables to the parts directly.
20:21:38 <Cale> (but that's an implementation detail)
20:22:31 <Cale> Like, the empty list [] will consist of an integer tag 0 and no pointers, while (x:xs) will have the tag 1 followed by pointers to x and xs
20:22:33 <dfeuer> carter, I think I got it.
20:22:38 <duuude> jle` thanks
20:22:40 <carter> dfeuer: oh?
20:22:56 <Cale> (not sure if that'll help you any, but depending on what your background is...)
20:22:58 <duuude> I get all this now, thanks.  I do think the syntax is somewhat confusing.  I'm surprised it'll solve a whole equation for you.
20:23:07 <jle`> duuude: yeah, things like "," and ":" are called "constructors"
20:23:10 <Cale> You can't just solve any equation
20:23:16 <duuude> Cale well obviously not
20:23:18 <jle`> and they are simple enough constructs that they can be trivially "matched"
20:23:19 <Cale> > let x^2 = 25 in x
20:23:19 <duuude> but the ones it can solve
20:23:20 <lambdabot>  x
20:23:22 <Cale> heh
20:23:27 <jle`> or "solved"
20:23:49 <jle`> so only constructors, not just any ol' function
20:23:50 <Cale> (that's a lambdabot weirdness, it already has something called x in scope)
20:23:56 <duuude> Does the interpreter ever apply closed formulas when you write an open one?  (i.e. does it recognize that it doesn't have to do things sequentially)
20:24:02 <Cale> > let xx^2 = 25 in xx
20:24:03 <lambdabot>  Not in scope: ‘xx’
20:24:03 <lambdabot>  Perhaps you meant one of these:
20:24:03 <lambdabot>    ‘x’ (imported from Debug.SimpleReflect),
20:24:20 <Cale> ^^ that defined the function ^ locally instead of binding xx to anything
20:24:36 <EvanR> duuude: its kind of like destructuring assignment in other languages, if youve ever done something like [x,y,z] = [1,2,3]
20:24:47 <EvanR> so x = 1, y = 2..
20:24:53 <Cale> duuude: The evaluation order is up to the compiler, but for the most part it proceeds in an outermost-first fashion
20:25:05 <Cale> duuude: i.e. when you see something like f (g (h x))
20:25:06 <jle`> i think when you are starting out with haskell, "," and ":" are the only constructors you learn about for a while
20:25:13 <lpaste> dfeuer pasted “insert into vector” at http://lpaste.net/696593620387495936
20:25:13 <jle`> the nxt one you learn is probably Just/Nothing
20:25:24 <dfeuer> carter, take a look?
20:25:25 <Cale> it'll start by evaluating f, applying it to the (as yet unevaluated) expression (g (h x))
20:25:59 <Cale> If f pattern matches on its argument, it will need to evaluate (g (h x)) until it puts it into a form where one of the patterns matches
20:26:24 <Cale> Pattern matching is ultimately the whole reason why anything ever gets evaluated
20:26:26 <dfeuer> carter, the only obvious potential problem is that if this really *is* applied to a stream, I think it could end up running one of the steps twice.
20:26:28 <jle`> > let (x, (y:ys, z)) = (True, (2:(3:4:[]), "hello") in (x, y, ys, z)
20:26:29 <lambdabot>  <hint>:1:51: parse error on input ‘in’
20:26:37 <duuude> does the Haskell interpreter know any math?  For example if you were to add up a list, would it ever recognize that there's a closed formula for what you're doing and just use that?
20:26:37 <jle`> > let (x, (y:ys, z)) = (True, (2:(3:4:[]), "hello")) in (x, y, ys, z)
20:26:39 <lambdabot>  (True,2,[3,4],"hello")
20:26:43 <carter> how would it happen twice?
20:26:44 <dfeuer> Which hardly seems fatal.
20:26:46 <Cale> duuude: no
20:26:50 <carter> which step?
20:27:00 <gcganley> sorry what are you guys talking about? i just came back
20:27:06 <duuude> Cale: but why not - it would be useful and it's trivial in many cases due to the lack of side effects
20:27:13 <cfoch> do we have a special type for DATEs?
20:27:13 <Cale> duuude: Though you can teach GHC rewriting rules that it will try to apply while optimising the program
20:27:19 <dfeuer> carter, see the bit near the end where it says S.Yield e (s, True) ?
20:27:23 <dfeuer> s instead of s'?
20:28:11 <Cale> duuude: GHC does know, for instance, that  map f (map g xs) is the same thing as map (\x -> f (g x)) xs
20:28:13 <carter> dfeuer: these steps look pure... so theres no effects gettning run onces
20:28:31 <dfeuer> carter, right, no effects. I just mean recomputation.
20:28:34 <athan> cfoch: DATE?
20:28:38 <Cale> duuude: so it can avoid the construction of an intermediate list like that
20:28:40 <duuude> can haskell deal with arbitrary-precision (like bigint)
20:28:47 <Cale> > product [1..1000]
20:28:48 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
20:28:50 <cfoch> athan: datetime
20:28:50 <Cale> yes
20:28:58 <EvanR> bigint isnt arbitrary precision, its exactly precise to the integer
20:29:00 <duuude> interesting
20:29:00 <kadoban> duuude: The Integer type is arbitrary precision
20:29:00 <athan> oh, the old-locale lib helped a lot
20:29:09 <athan> @hackage old-locale cfoch
20:29:09 <lambdabot> http://hackage.haskell.org/package/old-locale cfoch
20:29:19 <EvanR> arbitrary range int
20:29:45 <Cale> I guess it's a kind of "precision" if you're thinking in terms of the 2-adic norm :)
20:29:49 <cfoch> athan: what about Data.Time?
20:29:53 <cfoch> or only for Time=
20:29:55 <cfoch> ?
20:30:38 <athan> cfoch: I know there's something for UTC, one sec
20:30:43 <duuude> so here's a question. earlier we produced a prime test like tihs:      let factor x = filter (\y -> x `mod` y == 0) [1..x] in factor 31337
20:30:45 <athan> it's pretty sophisticated
20:30:50 <peddie> cfoch: data.time.clock
20:30:50 <athan> der, the time library ><
20:30:57 <athan> @hackage time cfoch
20:30:57 <lambdabot> http://hackage.haskell.org/package/time cfoch
20:31:01 <cfoch> I don't care too much about time, hours, minutes
20:31:04 <EvanR> cfoch: the type for dates is Day
20:31:14 <cfoch> I just want Days, months, years
20:31:19 <duuude> but for high arbitrary numbers that is prohibitive.  there are closed-formula probability tests - can we get Haskell to use one 'automatically', like recognize what we're doing?  Or is that waaay too advanced.
20:31:25 <EvanR> you can subtract two Days two get an Integer, and add Integers to Days to get another Day
20:31:34 <EvanR> you can also convert Day to gregorian triple and back
20:31:56 <kadoban> duuude: Naw, it won't automatically figure out better algorithms for you. You have to write them.
20:32:29 <duuude> kadoban - but if you're the one writing the algorithms then why is it so much better to keep everything pure and not imperative?  (Since you're the one ending up writing the steps)
20:33:00 <EvanR> cfoch: https://github.com/evanrinehart/time-diagram
20:33:06 <Cale> Well, to some extent it does figure out better algorithms for you, but only when it can do so very mechanically, and only when they're practically always really better than what you wrote.
20:34:20 <Cale> But there are limits to the practicality of that, and it's hard to do really fancy things without also being somewhat fragile about it.
20:34:40 <kadoban> duuude: Because it's easier to reason about and compose and etc.
20:35:03 <Cale> Like, if people are relying on those simplifications to happen, and they make a small change to their program, and all of a sudden the compiler can no longer figure out that it can simplify the program, that can be very frustrating.
20:35:11 <cfoch> ah... and these modules can tell me given a date, if this date is monday, or saturday, or friday?
20:35:13 <duuude> I understand
20:35:20 <Cale> So there's an extent to which just forcing the programmers to make use of libraries which do what they want to do is better.
20:35:31 <EvanR> cfoch: yes, a given Day is one of seven days of the week
20:35:33 <duuude> so, is Haskell the best match for mathematical algorithms (e.g. from graph theory) you can reason about?
20:36:08 <Cale> "best" is perhaps a bit much, but it does a relatively good job.
20:36:12 <alexclark> huge noob question, but im trying to use pattern matching to define a function based on the last letter?  I know the first letter would be simple like f ('!':_)
20:36:17 <kadoban> duuude: "best" tends to be pretty much impossible to answer objectively. It depends on your criteria.
20:36:23 <alexclark> is there anything like that for last letter?
20:37:03 <davean> alexclark: You could use a guard and last ...
20:37:08 <Cale> alexclark: Matching against the last letter is expensive, because of the way that lists are built. You can use the last function, but note that it takes as many steps to evaluate as the list has elements.
20:37:55 <Cale> Lists are sort of like loops which haven't happened yet, or which you're observing the iterations of as data.
20:38:08 <EvanR> cfoch: well, theres a formating function so you can get a day of the week string, or you can calculate it easily however you want by diffing by any known sunday and modulo 7
20:38:19 <cfoch> EvanR: a Day is a... type? and it is Friday | Saturday | Sunday | Monday... you mean that?
20:38:24 <EvanR> no
20:38:53 <alexclark> Cale: that makes sense because everything is lazy. so you and davean are on the same page I need to use a guard?
20:38:57 <EvanR> Day stands for a particular day in history, this is an abstract concept unrelated to precise physical time keeping
20:39:08 <EvanR> and indepedent of calendar systems
20:39:16 <Cale> alexclark: There are "view patterns" you could use
20:39:30 <Cale> alexclark: But it probably makes more sense just to use a guard.
20:39:56 <alexclark> Cale: davean: cool! thanks!
20:40:02 <duuude> I'm going now. thanks a lot for your help guys.
20:40:18 <Cale> > let isExclamation ('!' <- last) = True; isExclamation _ = False in isExclamation "like this!"
20:40:19 <lambdabot>  <hint>:1:24: parse error on input ‘<-’
20:40:25 <Cale> er
20:40:32 <Cale> > let isExclamation (last -> '!') = True; isExclamation _ = False in isExclamation "like this!"
20:40:33 <lambdabot>  True
20:40:41 <Cale> yeah, forgot which way around it went :)
20:41:04 <Cale> That's not a feature I use a whole lot, as you can probably tell, but it can be convenient
20:41:15 <EvanR> cfoch: yes Day is a type. today is a Day, and tomorrow is today plus one
20:41:34 <Cale> There's also pattern guards for matching against the results of functions
20:42:11 <Cale> > let isExclamation xs | '!' <- last xs = True  | otherwise = False in isExclamation "pattern guards!"
20:42:12 <lambdabot>  True
20:42:35 <Cale> Usually you'd want to use these features more when you're actually binding variables
20:42:55 <EvanR> :t fromGregorian
20:42:56 <lambdabot> Not in scope: ‘fromGregorian’
20:43:20 <lpaste> nocturne777 pasted “Functors” at http://lpaste.net/121003
20:43:21 <Cale> isExclamation xs = last xs == '!' -- this version probably is easier to work with :)
20:44:16 <nocturne777> the author says that Frank replaces j. doesn't the Frank actually replace t ?
20:44:41 <cfoch> http://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Calendar-WeekDate.html
20:44:53 <cfoch> third day of week (1 for Monday to 7 for Sunday)
20:45:06 <nocturne777> ?
20:45:21 <Cale> nocturne777: yes, it's the t
20:45:30 <lpaste> nocturne777 revised “Functors”: “No title” at http://lpaste.net/121003
20:45:30 <Cale> nocturne777: At least, given that definition of the class
20:45:34 <EvanR> cfoch: that module is something else, it pertains to the weeks of a year
20:46:05 <Cale> nocturne777: Taking hlint's advice I see :)
20:46:20 <EvanR> cfoch: but toWeekDate does give you a number 1 to 7 for days of the week, if you are ok with that. its still easy to make a 7-case sum type for days of the week. its just not that useful
20:46:29 <nocturne777> Cale: yes :) it looks better like this
20:46:32 <mulchy> cleamoon_:
20:46:56 <nocturne777> Cale: hlint is part of haskell platform, is it not?
20:47:04 <Cale> nocturne777: I don't actually know
20:47:24 <Cale> I usually just install GHC myself and then grab cabal install off of Hackage
20:47:31 <nocturne777> I should use it on my machine as well
20:49:30 <nocturne777> Cale: why the author has to specify the types explicitly like so:  "tofu (Just 'a') :: Frank Char Maybe" ?
20:49:47 <lpaste> Ryan pasted “Can't get doctests to run :(” at http://lpaste.net/121005
20:50:24 <mulchy> Hey guys, I was wondering if anyone could help me get my tests to run
20:50:48 <Cale> nocturne777: because the type of the result of tofu can't be determined from the type of its argument, perhaps
20:50:50 <nocturne777> is it to inform about the type of the value  the value constructor is taking ?
20:50:53 <mulchy> I think it is a simple configuration issue, but I am very new to Haskell and can't figure it out
20:51:32 <Cale> nocturne777: Note that the t parameter in the Tofu class only occurs in the result type of tofu
20:51:55 <lpaste> Ryan revised “Can't get doctests to run :(”: “No title” at http://lpaste.net/121005
20:52:01 <Cale> nocturne777: So, without knowing which type of result we want from an expression tofu x, we don't know which instance of the class to use.
20:52:36 <Cale> nocturne777: It would also work just to use the result in some way which specified the type further, rather than giving an explicit signature though.
20:52:49 <Cale> A similar thing happens with read
20:52:50 <Cale> :t read
20:52:51 <lambdabot> Read a => String -> a
20:53:00 <Cale> > read "[1,2,3]" :: [Integer]
20:53:02 <lambdabot>  [1,2,3]
20:53:06 <Cale> > read "[1,2,3]" :: Double
20:53:08 <lambdabot>  *Exception: Prelude.read: no parse
20:53:15 <dulla> you forgot
20:53:15 <Cale> > read "3.141592" :: Double
20:53:16 <lambdabot>  3.141592
20:53:18 <dulla> to [a]
20:53:34 <Cale> I didn't forget :)
20:53:39 <dulla> > read "[1..3]" :: [Double]
20:53:40 <lambdabot>  *Exception: Prelude.read: no parse
20:53:46 <dulla> > read "[1,2,3]" :: [Double]
20:53:47 <lambdabot>  [1.0,2.0,3.0]
20:54:04 <Cale> (I just wanted to show what happens when you pick the wrong instance)
20:54:36 <Cale> > read "(1,[2,3],'c')" :: (Integer, [Double], Char)
20:54:37 <lambdabot>  (1,[2.0,3.0],'c')
20:55:33 <Cale> It builds the parser to use based on the structure of the type, via a bunch of instances like  instance (Read a, Read b, Read c) => Read (a,b,c) where ...
20:55:45 <Cale> and  instance Read a => Read [a] where ...
21:03:05 <benzrf> > read "3"
21:03:07 <lambdabot>  *Exception: Prelude.read: no parse
21:03:14 <benzrf> ...because it defaults to ()
21:03:16 <benzrf> beware!
21:03:19 <lpaste> Ryan annotated “Can't get doctests to run :(” with “Can't get doctests to run :( (annotation)” at http://lpaste.net/121005#a121007
21:03:22 <EvanR> @help
21:03:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:03:28 <benzrf> > read "()"
21:03:30 <lambdabot>  ()
21:05:54 <EvanR> how do you import modules into lambdabot
21:06:55 <benzrf> @let -- this adds a line to L.hs
21:06:56 <lambdabot>  Defined.
21:07:07 <benzrf> @let import Data.Functor.Compose -- this is a line
21:07:08 <lambdabot>  Defined.
21:07:19 <EvanR> @let import Data.Time
21:07:20 <lambdabot>  .L.hs:113:1:
21:07:20 <lambdabot>      Data.Time: Can't be safely imported!
21:07:20 <lambdabot>      The package (time-1.4.2) the module resides in isn't trusted.
21:07:34 <EvanR> bollocks
21:07:40 <jle`> @let import System.IO.Unsafe
21:07:41 <lambdabot>  .L.hs:125:1:
21:07:41 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
21:07:41 <lambdabot>      The module itself isn't safe.
21:07:43 <jle`> aw
21:08:03 <EvanR> whats unsafe about time :(
21:08:32 <dibblego> haha lots
21:09:05 <dibblego> my favourite is the consequences of the orphan instances
21:09:27 <EvanR> wut
21:11:06 <dibblego> want the Show instance for UTCTime? You can try importing Data.Time.Clock, but that is not enough. Instead, import System.Directory
21:11:48 * EvanR usually imports Data.Time
21:12:25 <dibblego> that works too
21:12:50 <EvanR> why System.Directory?
21:12:55 <dibblego> because that works too
21:13:00 <EvanR> how :S
21:13:16 <dibblego> because Data.Time is insane
21:14:58 <dibblego> http://lpaste.net/121009
21:18:46 <EvanR> dibblego: wow.
21:20:09 <SrPx> Does anyone have a text/resource on why it is difficult to inline recursive functions and in which cases it leads to problems?
21:20:21 <dibblego> FWIW, that was straw for me wrt Data.Time. I won't use it anymore and I had already written a replacement for a product (just need to rewriet it so I own it).
21:20:24 <funfunctor> hi
21:21:03 * hackagebot buffer-builder-aeson 0.2.0.3 - Serialize Aeson values with Data.BufferBuilder  http://hackage.haskell.org/package/buffer-builder-aeson-0.2.0.3 (afriesen)
21:21:10 <funfunctor> what would be a suitable type for handling streaming binary data out of a data?
21:21:23 <heatsink> out of a data?
21:21:35 <funfunctor> I suspect using Array as a binary stream vector would be a bad choice?
21:21:55 <heatsink> lazy ByteString is good for streaming data
21:22:09 <heatsink> if it is a stream of bytes
21:22:17 <funfunctor> i was thinking ByteString yes
21:23:36 <heatsink> If you are going to make an Array, you need all the data first, which means it won't have streaming behavior.
21:24:26 <funfunctor> heatsink: ah well I fill blocks up
21:24:45 <funfunctor> alright I do think ByteString is the way to go
21:25:08 <pacak> funfunctor: Did you tried using iteratees/conduits/pipes/other stuff?
21:25:41 <funfunctor> pacak: no, any good resource to skim over them without going too deeply?
21:26:11 <funfunctor> complexity is getting the better of me in this project, i've written 14kloc of haskell this last week
21:26:38 <pacak> funfunctor: Well, there's a nice paper by Oleg... But that's probably at the opposide end of "without going too deeply"
21:26:48 <funfunctor> lol
21:26:50 <funfunctor> yes
21:27:19 <funfunctor> I sort of found that reading too deeply made be forget where I was with things
21:29:49 <EvanR> funfunctor: the basic way is to accumulate bytestring chunks in a loop until you realize you need to stop/do something or theres an error
21:30:19 <EvanR> the higher level way is iteratees, pipes, conduits
21:30:30 <EvanR> and other stuff ;)
21:31:38 <funfunctor> EvanR: well its complicated because things come out of order and need to be timestamped and sorted
21:32:02 <EvanR> there is some protocol, its not just random
21:32:16 <EvanR> you accumulate bytes until you realize you need to do something
21:32:42 <funfunctor> EvanR: the ordering is random due to physics of RF and so on..
21:32:49 <pacak> funfunctor: I'm doing reordering and timestamping all the time  with iteratees
21:33:03 <EvanR> funfunctor: the ordering of bits is globally random? ;)
21:34:09 <funfunctor> https://wiki.haskell.org/Iteratee_I/O   oh yea nice
21:34:15 <funfunctor> ok something like this yes
21:34:31 <jle`> SrPx: have you ever tried inlining a recursive function? :)
21:35:00 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121013
21:35:07 <EvanR> when i was a kid, my mother told me never to inline a recursive function. so when i was 8, i did
21:35:17 <funfunctor> pacak: here is the C++ interface used in the reference code
21:35:32 <SrPx> Yes, bad things happen... but I don't remember why right now :( I knew, but I don't remember. Specifically, I remember thinking that it is fine in certain situation if the recursive function has no free variables. Or something.
21:35:33 <jle`> I mean, inline by hand
21:36:04 * hackagebot foldl-incremental 0.2.0.0 - incremental folds  http://hackage.haskell.org/package/foldl-incremental-0.2.0.0 (tonyday)
21:36:13 <jle`> fac n = if n == 0 then 1 else n * fac (n -  1)
21:36:18 <jle`> OK, time to inline
21:36:38 <SrPx> wow I has **exactly** that written here
21:36:51 <pacak> funfunctor: You have a C++ code as a reference. I had a messy manual translated English -> Japanese -> English by different people.
21:37:04 <jle`> fac n = if n == 0 then 1 else n * if (n -  1) == 0 then 1 else (n -  1) * fac (n -  2)
21:37:13 <jle`> we're not done yet
21:37:40 <funfunctor> pacak: well its buggy and incomplete also, its based off literally 1,000's of pdf's that are many 100's of pages long each
21:37:52 <SrPx> jle`: yes, I see the point. But wait, suppose that instead of recursive functions, we are now on the simply typed lambda calculus (where those are forbidden) and you add a "fix" operator.
21:38:10 <funfunctor> but I am sure others have had it worse :p
21:38:11 <jle`> fac n = if n == 0 then 1 else n * if (n - 1) == 0 then 1 else (n - 1) * if (n - 2) == 0 then 1 else (n -  2) * fac (n - 3)
21:38:15 <jle`> still not done
21:38:33 <SrPx> When it is okay to unfold the fix operator on that case? And please STOP lol! jle`
21:38:36 <jle`> it inlines to infinitely laege binary
21:38:40 <SrPx> uh huh
21:39:00 <jle`> what fix operator?
21:39:14 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121014
21:39:30 <funfunctor> pacak: ^ thats why i've been working on as something similar
21:39:44 <jle`> like fix?
21:39:46 <SrPx> fix f x = f (fix f) x
21:39:47 <jle`> :t fix
21:39:47 <lambdabot> (a -> a) -> a
21:39:56 <SrPx> I guess, wait
21:40:45 <SrPx> well, nvm... anyway, as long as that opeartor is the only way to have recursion, 1. can you strongly normalize everything, as long as you don't unfold that operator? And, 2. can you unfold the operator when it has no free vars?
21:40:56 <SrPx> more or less this... I guess yes, right?
21:42:14 <SrPx> after all, if it has no free variables then it probably doesn't loop infinitely (otherwise the user programmed an infinite loop so it is his fault and the program would crash anyway)
21:44:00 <EvanR> SrPx: fix on a function with no free variables can loop
21:44:17 <EvanR> making the inliner freeze
21:44:57 <SrPx> EvanR: but if it loops infinitely then the user's program loops infinitely too... (considering a strict language)
21:44:58 <SrPx> no?
21:45:16 <EvanR> if it gets executed, but the compiler freezing really sucks
21:45:41 <EvanR> (if it gets executed and the looping branch is eventually taken
21:46:03 <SrPx> uh... does it really sucks if your compiler freezes by compiling a program that freezes? o.o it is not like you could do much anyway
21:46:11 <EvanR> yes, it does
21:46:21 <EvanR> especially when your program might not actually freeze
21:46:36 <EvanR> but even if it didnt
21:46:51 <nshepperd> would it ever be useful to inline a recursive function for one step
21:46:57 <SrPx> it would only not freeze if it didn't reach that branch, but then, why would normal person program a hidden singularity on an unreachable branch
21:47:05 <nshepperd> like 'fac n = if n == 0 then 1 else n * if (n -  1) == 0 then 1 else (n -  1) * fac (n -  2)' and then apply some optimizations
21:47:15 <EvanR> a compiler locking up in a 100% cpu usage useless loop, and or also using up unlimited memory until you hit control C
21:47:19 <SrPx> sorry for double negation
21:47:33 <EvanR> you dont know what branches are taken at runtime until you run the program
21:47:43 <EvanR> youre probably thinking inline all branches
21:48:02 <SrPx> yep
21:48:05 <heatsink> nsshepperd: Yes, it's useful somtimes
21:48:57 <heatsink> nsshepperd: One case is when the function is structurally recursive, and the argument's constructor is known
21:49:05 <SrPx> well maybe you are right, but what if you know in advance that there are no infinite loops?
21:49:18 <EvanR> if you know that, then awesome
21:49:36 <EvanR> you cant know that in general, in haskell
21:49:46 <SrPx> uh huh, fair enough
21:50:14 <EvanR> but if its a terminating loop, and you know it terminates after 1000000 cycles, you inline 1000000 things?
21:50:58 <EvanR> seems wreckless
21:51:45 <SrPx> EvanR: I guess that this will never happen at compile time since I'm compiling just the logic of the program, the actual data come from outside
21:51:54 <SrPx> there is nothing really that goes to 10000 on the logic itself
21:52:05 <EvanR> this is a special case of "knowing" stuff
21:52:12 <SrPx> uh huh, fair enough /2
21:52:17 <SrPx> :)
21:52:44 <EvanR> constant numbers go into code all the time
21:53:26 <SrPx> uh huh, I'm going extra miles to avoid having them on my code
21:56:55 <SrPx> (now that I think about it, it was actually kinda healthy so far, i.e., I was forced to write a widget generically in respect to its size instead of hardcoding it)
21:57:01 <xnil> does BONUS still hang out here ever?
21:57:40 <EvanR> SrPx: yep, you can always put constants in if you dont allow it literally. as long as you have zero and a way to get the successor ;)
21:57:56 <dulla> ?
21:58:13 <EvanR> literals are totally unnecessary
21:58:53 <SrPx> some unrelated thought
21:59:32 <bitemyapp> xnil: not for a very long time.
21:59:53 <tommd> xnil: http://ircbrowse.net/browse/haskell?id=15407116&timestamp=1364576793#t1364576793
22:00:15 <bitemyapp> tommd: beat me to it :P
22:00:22 <dulla> so
22:00:25 <bitemyapp> xnil____4: no
22:00:34 <dulla> don't inline recursion, because it'll simply interrupt everything
22:00:46 <dulla> and there are fancy ways to guard for it
22:01:07 <SrPx> suppose that you are programming on the simply typed lambda calculus... you use church numerals to encode nats... you write a simple program that computes the square of a number
22:01:22 <dulla> ok
22:02:39 <dulla> that is a hell of a thing
22:02:46 <dulla> though that terminates
22:02:50 <SrPx> you strongly normalize it... my question is, is it possible to take the result and extract a C program from it? I.e, int square(int a){ return a*a; } -- you would have to somehow analyze the resulting normalized STLC program and identify the multiply function inside it
22:02:54 <SrPx> but I guess that is not possible..
22:03:27 <EvanR> that wouldnt be right, for Nats
22:03:48 <SrPx> I'm asking that because it seems like tekmo's Morte language would require you to somehow identify that kind of thing, church numeras and so on, inside the normalized coc program in order to compile it... but that seems undoable
22:03:53 <dulla> and then everything flies over my head
22:04:20 <dulla> it seems to be limited branch recursive nonesense
22:04:30 <dulla> successor -> additiion -> multi...
22:05:12 <dulla> and all I can guess is strongly normalisation is simply returning all calls/thunks
22:05:46 <EvanR> strongly normalizing is every expression evaluates to some value and it doesnt matter what order of reductions you use to do it, its always the same answer
22:06:21 <dulla> so a spade is a spade at the end of the day
22:06:31 <dulla> otherwise it is just ain't right
22:06:46 <EvanR> haskell is an example of a language without this property
22:06:51 <SrPx> EvanR: which is pretty cool, isn't it? Since then you get no penalty for abstractions at all.
22:06:58 <EvanR> SrPx: yeah, its awesome
22:07:21 <SrPx> I just don't know how I would proceed to extract the church numerals, church lists and so on from the resulting program in order to, say, compile it to scheme (or even haskell)
22:07:25 <EvanR> i dont know about penalties for abstracts or not
22:07:27 <heatsink> Abstractions can still be impractically slow in a strongly normalizing language.
22:07:44 <dulla> that sounds like a be all end all for lazy eval, and stream eval, SrPx EvanR
22:07:46 <dulla> yes?
22:07:59 <SrPx> dulla: I don't know what you mean (my english is terrible)
22:08:19 <dulla> and my phrasing is terrible
22:08:20 <SrPx> heatsink: ?
22:08:21 <EvanR> dulla: eh? in haskell some expressions dont evaluate at all, like 1 `div` 0
22:08:33 <dulla> sound it sounds like it falls out of laziness, and is great for stream eval
22:08:42 <dulla> oh, you mean like that
22:08:49 <EvanR> or length [1..]
22:08:57 <dulla> aight
22:09:24 <SrPx> "Falls out... of lazyness?" What. I'm imagining you falling from a snorlax. Sorry
22:09:25 <dulla> Also, your thoughts on IPFS? Alpha is released
22:10:11 <dulla> as in non-strong normalisation is endemic of lazy evaluation
22:10:20 <dulla> as if you could shake lazy eval
22:10:23 <EvanR> no, youre thinking of non-strict
22:10:29 <dulla> and non-strong normalisation would fall out of it
22:10:41 <SrPx> Well I guess strong normalization kinda implies a strict language so ...
22:10:42 <dulla> I only know non-strict as lazy
22:10:59 <heatsink> SrPx: Strongly normalizing means everything completes eventually.  In practice, it's important for computations to complete quickly.  For example, most practical computations need to complete in less than 10^20 steps.
22:11:09 <EvanR> if your language is strongly normalizing it doesnt matter whether you use eager or lazy or anything else
22:11:15 <EvanR> to the final answer
22:11:19 <SrPx> heatsink: ah that is what you mean. Okay!
22:11:56 <dulla> so more or less, you can have a turing tape machine, but you'd prefer it not to be one
22:12:05 <EvanR> failing to terminate is a special case of "inefficient" ;)
22:12:18 <dulla> well, dropping a bottom is too
22:12:43 <mabino-pyon> heatsink: "in less than 10^20 steps" --> Are we finitists today? :-P
22:12:56 <SrPx> You just bugged my head, btw... 100000000000000000000 steps... brb gonna write a C program and see how much time it takes to count to it
22:13:25 <EvanR> a while
22:14:37 <EvanR> if you can count to a million each second, and theres about a million seconds in a year, then youll need to wait 8 years
22:14:45 <EvanR> er
22:14:49 <EvanR> 10^8 years
22:14:58 <L8D> Is there an idiomatic way to define integers as recursive data structures in Haskell?
22:15:06 <SrPx> Done..
22:15:07 <L8D> in the same vein of peano numerals
22:15:50 <jle`> data N = Z | S N
22:15:58 <SrPx> Here is the actual result: 20 seconds to count to 10^10... so... around 300000 years
22:16:01 <jle`> zero = Z
22:16:06 <L8D> That's peano numerals and only natural numbers
22:16:07 <jle`> one = S Z
22:16:16 <L8D> I mean integers
22:16:19 <jle`> ah
22:16:27 <dulla> > (10^20) `div` (60*60*24*7*52)
22:16:28 <lambdabot>  3179690679690
22:16:47 <dulla> > length . show $ (10^20) `div` (60*60*24*7*52)
22:16:48 <lambdabot>  13
22:16:48 <EvanR> 52 card in a deck?
22:17:00 <SrPx> EvanR: you are off by 99700000 years. How do you feel about the worst overestimation you ever made
22:17:01 <dulla> 52 weeks per year
22:17:04 <EvanR> theres 365.25 days in a year
22:17:11 <L8D> > 365.25 / 52
22:17:12 <lambdabot>  7.024038461538462
22:17:29 <EvanR> SrPx: 10^8 years
22:17:42 <EvanR> off by less than two powers of ten right?
22:17:43 <dulla> 3*10^13 years actually
22:18:39 <SrPx> EvanR: yep. So, about the age of the Earth.
22:18:41 <EvanR> i guess today counting to a million per second is a little slow for a computer
22:18:48 <EvanR> SrPx: the earth is 100 years old?
22:19:03 <dulla> > let a = (10^20) `div` (60*60*24*7*52) in (a, (length . show $ a))
22:19:05 <lambdabot>  (3179690679690,13)
22:19:15 <dulla> > let a = (10^20) `div` (60*60*24*365.25) in (a, (length . show $ a))
22:19:16 <lambdabot>  Could not deduce (GHC.Show.Show s0)
22:19:16 <lambdabot>    arising from a use of ‘GHC.Show.show’
22:19:16 <lambdabot>  from the context (GHC.Real.Integral t, GHC.Real.Fractional t)
22:19:18 <SrPx> why 100?
22:19:35 <dulla> > let a = (10^20) `div` (60*60*24*365.25) in (a, (length . show . ceiling $ a))
22:19:36 <EvanR> dulla: ... 7*52 is a complex and poor estimate for number of days in a year...
22:19:37 <lambdabot>  Could not deduce (GHC.Real.RealFrac s0)
22:19:37 <lambdabot>    arising from a use of ‘GHC.Real.ceiling’
22:19:37 <lambdabot>  from the context (GHC.Real.Integral t, GHC.Real.Fractional t)
22:19:45 <dulla> oh
22:19:53 <EvanR> dulla: 3 million seconds in a year is at least simple
22:19:53 <dulla> > let a = (10^20) / (60*60*24*365.25) in (a, (length . show . ceiling $ a))
22:19:55 <lambdabot>  (3.168808781402895e12,13)
22:20:02 <dulla> there you go
22:20:07 <dulla> off by four
22:21:04 <SrPx> interesting that compiling with -O2 makes the program instant since GCC obviously notices it is stupid. So theorically GCC optimized a program that'd run in 10^6 years all the way to instantaneos.
22:21:09 <L8D> jle`: any clue?
22:21:34 <dulla> that's the power of soft computation, SrPx
22:21:37 <EvanR> SrPx: ghc 7.10 is supposed to include halting problem solution too
22:21:49 <dulla> if you can reasonably interpret, and simplify, you can make things faster
22:22:21 <dulla> or realise that you don't need literals, and approximations are good enough
22:23:31 <SrPx> Now imagine if GCC team made a chart comparing the speed of that program in C vs Java/Python/etc, which obviously don't get that optm. A point on how meaningless benchmarks can be
22:24:47 <L8D> Could you not formally prove that a program will terminate?
22:25:08 <heatsink> People do that
22:25:26 <EvanR> id like to see java count to 10^20, i think it will be about as fast as C
22:25:29 <L8D> So why not do what Idris does and require programmers to do that?
22:25:32 <EvanR> not python
22:25:48 <heatsink> Proving termination requires a lot more work than just writing the program, so people rarely do it
22:26:04 <L8D> programmers shouldn't worry about the halting problem if they proactively prove to their compilers that functions have total termination
22:26:08 <Axman6> > length [1..10^20]
22:26:12 <lambdabot>  mueval-core: Time limit exceeded
22:26:15 <Axman6> :(
22:26:18 <dulla> lol
22:26:19 <L8D> heatsink: proving termination is easy-as-fuck
22:26:20 <dulla> get rekt son
22:26:37 <heatsink> Can you use free monads in Idris?
22:26:41 <SrPx> L8D: I don't want to program in your language
22:26:47 <EvanR> L8D: yes, if your javascript program has survived a year without a customer complain, its callbacks always terminate
22:26:50 <EvanR> proof
22:27:06 <Axman6> L8D: s/is/can be/ ?
22:27:25 <SrPx> > Time limit exceeded ... not memory o.o
22:27:26 <lambdabot>  Not in scope: data constructor ‘Time’Not in scope: ‘limit’Not in scope: ‘exc...
22:27:27 <lambdabot>  Perhaps you meant ‘mempty’ (imported from Data.Monoid)
22:27:28 <jle`> L8D: ever heard of the halting problem?
22:27:56 <L8D> Axman6: sure
22:28:09 <L8D> Proving termination is easy-as-fuck in a language like Idris or Coq
22:28:20 <SrPx> Yes, I meant mempty. Thanks, lambdabot.
22:28:21 <EvanR> not for me it isnt
22:28:30 <EvanR> except trivial cases
22:29:18 <L8D> but that's the thing
22:29:27 <L8D> you would always be working with trivial cases
22:29:41 <EvanR> you would?
22:29:41 <heatsink> Fix is a useful data type, but you can't use it in Coq.  If you allowed Fix in Coq, Coq's termination proofs would be wrong.
22:29:48 <SrPx> Can you cite an algorithm where you really need all the power of full recursion? 99% of Haskell's prelude for example could be done perfectly well without it
22:30:15 <EvanR> the ones that operate on infinite lists
22:30:44 <L8D> EvanR: but to prove that something terminates, you operate on the assumption that the input has already terminated
22:31:03 <EvanR> im not sure thats a general strategy
22:31:12 <SrPx> EvanR: not true, if you define your infinite lists as streams, then you can write a non-recursive map trivially
22:31:27 <L8D> EvanR: the only cases that are non-trivial enough to make it difficult is when you are actually working with infinite data structures and choose lazy evaluation
22:31:28 <EvanR> SrPx: how?
22:31:38 <EvanR> non-recursive map
22:32:06 <shachaf> heatsink: Why?
22:32:06 <L8D> EvanR: and of course, in Idris, instead of doing that you just stick to streams
22:32:39 <SrPx> EvanR: data Stream a = forall s . MkStream { seed :: s , step :: s -> (a, s) }; map f (MkStream s0 k) = MkStream s0 k' where { k' s = (f a, s') where (a, s') = k s }
22:32:44 <SrPx> lazily quoting tekmo
22:33:57 * EvanR rewrites this for readability
22:34:13 <SrPx> EvanR: oh sorry, just read it on http://www.haskellforall.com/2014/09/morte-intermediate-language-for-super.html
22:34:19 <SrPx> I inlined to fit irc :(
22:34:28 <heatsink> shachaf: Why can't Fix be defined?
22:34:41 <shachaf> Yes.
22:34:51 <shachaf> As a least fixed point of a covariant functor.
22:35:04 <EvanR> SrPx: thats recursive
22:35:29 <heatsink> Coq types can only be parameterized over types from a smaller universe
22:35:46 <heatsink> In Fix, you have mkfix : f (Fix f) -> Fix f
22:37:07 <heatsink> So the contents of a Fix f contain a data type applied to Fix f, which is not allowed
22:37:12 <SrPx> EvanR: read it again
22:37:14 <EvanR> SrPx: oh nvm, i was reading the braces and wheres wrong
22:37:28 <heatsink> It's a consequence of the rule that prevents Girard's paradox and similar stuff
22:37:28 <SrPx> :)
22:39:07 <xnil___> woah, i just realized something; due to laziness, will a _ in a lambda ever be evaluated under any circumstance?
22:39:24 <xnil___> as in, in the arguments of a lambda, like (\a _ c -> blah)
22:39:50 <xnil___> even if the action resulting in the value that is passed in as the _
22:39:54 <xnil___> is evaluated
22:40:01 <xnil___> it's instantly discarded
22:40:16 <xnil___> as long as that's the only place it's referenced
22:41:19 <EvanR> xnil___: using seq?
22:41:22 <EvanR> hmm
22:41:42 <EvanR> wouldnt work
22:42:02 <xnil___> i mean, it at least doesn't get passed to the lambda
22:42:26 <Hafydd> xnil___: it could be executed if it were called like this:
22:42:29 <Hafydd> > ((\_ x -> x) $! (unsafePerformIO $ print "hello")) 1
22:42:29 <Hafydd> "hello"
22:42:30 <Hafydd> 1
22:42:31 <lambdabot>  Not in scope: ‘unsafePerformIO’
22:43:16 <funfunctor> EvanR: so I opensourced the radio interface part of the backend here https://github.com/victoredwardocallaghan/hbts
22:43:42 <funfunctor> EvanR: can we continue to talk about RadioDevice and RadioInterface
22:44:04 <EvanR> i see you have created a monad transformer
22:44:25 <funfunctor> yes
22:45:08 <funfunctor> EvanR: I think its at some suitable point for feedback now to tell me how rubbish it is
22:45:25 <EvanR> id keep it simpler by only using IO
22:45:33 <EvanR> since its for talking to devices
22:45:39 <dulla> "Morte is dependently typed in theory, but in practice I have not exercised this feature so I don't understand the implications of this. If this turns out to be a mistake then I will downgrade Morte to System Fw, which has higher-kinds and polymorphism, but no dependent types"
22:45:41 <dulla> ?
22:46:28 <funfunctor> EvanR: look carefully at it, your note parts that are leading on to timestamping and checking for over and under runs
22:46:36 <funfunctor> EvanR: which is why there is state
22:46:40 <EvanR> SrPx: ah ha. so this map function isnt recursive! but how would you get a steam in the first place?
22:47:08 <EvanR> funfunctor: state doesnt need to imply StateT or transformers
22:48:04 <SrPx> EvanR: get a stream on the first place? What do you mean?
22:48:04 <EvanR> funfunctor: , getMaxRxGain          :: m Double                 -- ^ return maximum Rx Gain
22:48:04 <funfunctor> ok.. EvanR can you be more concrete about something there so I can refactor that it to understand
22:48:18 <EvanR> SrPx: you can map a stream, but how do you construct a stream ?
22:48:42 <EvanR> funfunctor: is that a constant value?
22:48:51 <EvanR> the maxRxGain
22:49:35 <funfunctor> EvanR: yes that could be reduced down to first order, I just had that there to avoid lifting everywhere while I was working away on this
22:49:59 <EvanR> hmm
22:50:04 <SrPx> EvanR: what do you mean by construct...? But well, you build the stream as you build any datatype, ex: Stream 1 (\x → x + 1) ...
22:50:13 <funfunctor> EvanR: but yes, I will make that one first order
22:50:22 <EvanR> SrPx: ah right...
22:50:35 <EvanR> funfunctor: whats first order?
22:50:48 <SrPx> If you want to progress through it you just apply "step" n times... since church encoding numbers do just that, you can do something like: "5 (Stream 1 (\x → x + 1))" and this will normalize to Stream 6 (\x → x + 1)
22:51:09 <SrPx> 5 step *
22:51:33 <EvanR> yeah though id guess youd rather not do any of that, and just tream them as streams
22:51:33 <heatsink> funfunctor: Why does each radio device have its own monad?
22:52:10 <Mike-m> http://www.desura.com/games/dragonfly-racer Please buy my game , I have no money, I'm poor, I have no home
22:52:19 <funfunctor> heatsink: because each hardware has its own 'special things'
22:52:22 <heatsink> The two examples you have are newtypes of StateT S IO a, for different choices of S
22:52:55 <ab9rf> funfunctor: "special things"?
22:53:00 <funfunctor> EvanR: sorry I mean make it constant
22:53:13 <EvanR> funfunctor: when you have special behaviors, its better to have special functions rather than special types, in this case
22:53:37 <EvanR> the interface is the type
22:53:39 <heatsink> funfunctor: the only difference that I see is the state type associated with the StateT
22:53:53 <funfunctor> ab9rf: idiosyncrasies
22:54:35 <funfunctor> heatsink: well yea, each hw has its own kind of state
22:54:55 <EvanR> do these idiosyncrasies leak out into the client of the code
22:55:10 <funfunctor> they could without the abstraction
22:55:30 <EvanR> do you want only one interface to all the devices
22:56:10 <EvanR> or is each one operated totally differently by client code
22:56:15 <funfunctor> yes that is what the intent is for RadioDevice to abstract the device away and RadioInterface to abstract the device with packet sorting away into a queue
22:56:30 <EvanR> ok good, then you just need one type for the interface
22:57:10 <funfunctor> correct, RadioInterface is currently top of the stack, under it is RadioDevice and then under that is the particular hw monad
22:57:17 <heatsink> funfunctor: The code you have now advertises that, as a client, you don't know how many times bar will execute in (do {x <- foo; bar})
22:57:43 <heatsink> maybe some radio devices have backtracking, and bar will execute many times
22:58:24 <heatsink> As a user, you won't know until you read the documentation for the RadioDevice
22:58:47 <heatsink> In that sense, I think the API's types are too general
22:59:23 <funfunctor> how do you mean? above layer0 we should not even know what the meaning of hw even is
22:59:56 <funfunctor> all we are interested in is data then
22:59:58 <EvanR> monad transformer levels is not the right abstraction
23:00:14 <funfunctor> alright then what is?
23:00:19 <dulla> so it's too many layered effects?
23:00:46 <funfunctor> these layers are defined as per specification
23:00:48 <EvanR> i dont know the entire picture of your project
23:00:54 <dulla> Man, I feel like saying Oleg infront of a mirror three times in a row
23:01:00 <EvanR> the specification surely doesnt name monad transformers
23:01:05 <funfunctor> EvanR: but you keep saying its wrong wrong wrong
23:01:30 <funfunctor> EvanR: no of course not, but the layers are defined what they should and should not do
23:01:37 <dulla> layered streams are a thing, right?
23:01:38 <funfunctor> naturally, think OSI model
23:01:41 <EvanR> i mentioned different ways to unpack all this into specific parts, one is to use configuration from the initialization as a constant, the behaviors of the drivers are IO actions
23:01:49 <EvanR> the state can be hidden using IO
23:02:27 <dulla> wht if funfunctor doesn't want constant configs
23:02:41 <dulla> and pull some while-running config reloads
23:02:45 <EvanR> i asked yesterday, they do not change after the thing is initialized
23:02:54 <dulla> k
23:02:55 <funfunctor> EvanR: well it absolutely can not be just IO because the binding alone to libbladeRF has to deal with error handling of pointers and so on so we end up with the BladeRF monad
23:03:14 <ab9rf> whee
23:03:22 <EvanR> how does that library do error handling?
23:03:49 <funfunctor> EvanR: checking C error codes and messy stuff
23:03:57 <EvanR> i mean how does it report it to the client of the library
23:04:03 <funfunctor> which is not even complete yet but its wrapped up in the BladeRF monad
23:04:05 <EvanR> exception, either, negative numbers
23:04:13 <funfunctor> Either
23:04:47 <funfunctor> that /could/ change to Exception later, Either was easier to get working initially
23:05:00 <EvanR> right, so since you already made that interface, you could use exceptions or more Either to report errors from that cant-possible-change-or-be-wrong library
23:05:10 <dulla> there are so many ways to throw exceptions....
23:05:26 <EvanR> your library would just throwIO a specific exception type from that library
23:05:41 <EvanR> in short, IO has error handling too
23:05:46 <funfunctor> EvanR: yea but other hw maybe completely different
23:06:06 <EvanR> in what way, as far as error handling goes
23:06:07 <funfunctor> so its binding or whatever will possibly have a different interface
23:06:08 * hackagebot tabular 0.2.2.6 - Two-dimensional data tables with rendering functions  http://hackage.haskell.org/package/tabular-0.2.2.6 (EricKow)
23:06:25 <EvanR> thats fine you can have multiple levels of driver interfaces
23:06:34 <EvanR> its all IO though
23:06:40 <funfunctor> EvanR: well the radio interface of another hw could be *completely* different
23:06:51 <funfunctor> at the hw level
23:07:06 <EvanR> well yeah, thats why you have another driver?
23:07:06 <funfunctor> totally different functions, error handling, ability and so on
23:07:07 <dulla> this library is sounding more and more like a burr puzzle
23:07:16 <dulla> like George's Table
23:07:31 <EvanR> funfunctor: ... so?
23:08:07 <heatsink> Aren't the drivers there to provide a common interface to the different hardware libraries?
23:08:08 <funfunctor> EvanR: the point of the RadioDevice type is to expose a interface to the driver writer to meet
23:08:11 <EvanR> you sounded confident that they can all satisfy the highest level interface
23:08:47 <funfunctor> point is, RadioDevice is a interface the other way, a driver framework if you will
23:09:13 <EvanR> fine, im not sure it needs to be a monad transformer though
23:09:18 <dulla> now it sounds like writing the firmware for a mobile device with parts from 17 different companies
23:09:58 <funfunctor> well shit becomes complex when you try to make it general dulla
23:10:16 <EvanR> monad transformer does not equivilize to oop object or class
23:10:30 <dulla> well, as long as it doesn't go completely OOP, then it should be capable
23:10:38 <funfunctor> EvanR: well I don't really want a OOP design
23:10:46 <EvanR> its what youre doing though
23:11:03 <EvanR> encapsulating some stateful operations behind a common interface
23:11:08 <funfunctor> I realize that though hence me asking about it
23:11:19 <heatsink> funfunctor: Remember yesterday I gave you the example of data CommChannel = CommChannel {send :: String -> IO (), recv :: IO String}
23:11:35 <funfunctor> heatsink: yes, thats in DeviceRadio
23:11:46 <funfunctor> sorry, RadioDevice
23:12:32 <funfunctor> heatsink: except its more like data CommChannel m = CommChannel {send :: String -> m (), recv :: m String}
23:12:44 <heatsink> funfunctor: My example uses IO, your code uses a monad parameter.  EvanR and I think that the monad parameter is not necessary.
23:12:49 <funfunctor> heatsink: because each hw has its own IO monad
23:13:09 <EvanR> its a lot simpler and easier if you can agree on one type, if all the types do the same thing
23:13:23 <EvanR> and IO is that type in this case
23:13:27 <funfunctor> alright so how to eliminate it though in real code terms..
23:14:04 <funfunctor> EvanR: I don't disagree with that
23:14:21 <EvanR> so starting at the beginning, BladeRF would be made unnecessary
23:14:30 <funfunctor> but its easier said than done while working on this
23:14:58 <EvanR> yeah real code terms means no going back and refactoring when you realize you need to, i welcome myself to the real world for a couple seconds ;)
23:15:06 <funfunctor> EvanR: well BladeRF /is/ needed because it holds the state of the device handle pointer
23:15:16 * EvanR goes back to imaginary world, ahhh
23:15:40 <EvanR> funfunctor: yeah, i wouldnt do that
23:15:56 <EvanR> BladeRF monad, just to have a device handle, is not a good idea
23:16:03 <EvanR> just use a device handle instead
23:16:23 <funfunctor> EvanR: https://github.com/victoredwardocallaghan/hlibBladeRF/blob/master/src/LibBladeRF/LibBladeRF.hs
23:16:31 <EvanR> you probably are already half way doing that by having the device handle in these higher level monad transformers, so you can "runBladeRF"
23:16:48 <funfunctor> EvanR: then everyone is passing around device handles for different devices everywhere
23:16:50 <funfunctor> insane
23:17:04 <heatsink> Who is "everyone"?
23:17:07 <EvanR> not everyone
23:17:28 <heatsink> The device handle needs to get passed in when creating the interface, and that's it.
23:17:32 <funfunctor> so what your saying is my binding is poor at best?
23:17:56 <funfunctor> heatsink: no thats not the way it works, see the binding
23:18:01 <EvanR> im saying a monad transformer over IO there is not helping
23:18:30 <funfunctor> see https://github.com/victoredwardocallaghan/hlibBladeRF/blob/master/src/LibBladeRF/Flash.hs#L39
23:18:44 <funfunctor> gives you a idea why I hold the state of the device handle
23:18:58 <EvanR> the device handle isnt a state
23:19:07 <EvanR> its just a pointer right
23:19:29 <rui> How do you divide 2 Ints into a Double?
23:19:34 <ab9rf> that's not state, it doesn't change
23:19:53 <ab9rf> no need to store it in state, it can just be part of the constructor
23:20:00 <heatsink> rui: Do you mean, perform floating-point division on two Ints?
23:20:02 <funfunctor> EvanR: its actually a state because https://github.com/victoredwardocallaghan/hlibBladeRF/blob/master/src/LibBladeRF/LibBladeRF.hs#L102 this allocates space to the double indirection
23:20:16 <jle`> rui: convert them into Double's and divide them using (/)
23:20:19 <jle`> if that's what you mean
23:20:46 <funfunctor> ab9rf: well I was going to convert to ReaderT over StateT later
23:20:50 <jle`> > let divInt :: Int -> Int -> Double; divInt x y = fromIntegral x / fromIntegral y in divInt 5 2
23:20:51 <lambdabot>  2.5
23:21:09 <EvanR> funfunctor: i wouldnt call this a handle then, its some kind of mutable memory region?
23:21:20 <funfunctor> EvanR: yes
23:21:29 <EvanR> whats the mutable memory region being used for
23:21:30 <rui> heatsink yes
23:21:37 <rui> jle` Thanks
23:21:50 <jle`> rui: haskell tries its best to avoid implicit conversions :)
23:22:00 <jle`> all conversions are explicit
23:22:13 <jle`> it's the haskell way (TM)
23:22:21 <ab9rf> especially since theres usually lots of different ones to choose from and haskell isn't willing to guess for you
23:22:48 <jle`> you know what always really freaked me out in c
23:22:51 <EvanR> yes do whatever realToFrac does ;)
23:22:55 <jle`> if x is an int
23:23:00 <funfunctor> EvanR: the C library expects a double pointer to a opaque type struct bladerf; it then allocates memory internally and you use a single indirection later for various functions that do stuff with the hardware
23:23:06 <jle`> and y is a double
23:23:19 <jle`> then if you set y = x...it isn't that y will have the same value as x
23:23:21 <EvanR> funfunctor: wheres this C library
23:23:28 <jle`> in-memory
23:23:29 <funfunctor> EvanR: this is how libbladeRF is designed, other radios could be different also
23:23:35 <jle`> it's that it'll do an implicit conversion from int to double
23:23:43 <jle`> that's the opposite of what i expect heh
23:23:55 <EvanR> funfunctor: better get it right the first time then so you dont have N crazy bindings at the lowest level ;)
23:23:56 <ab9rf> jle`: heh
23:24:30 <funfunctor> EvanR: https://github.com/Nuand/bladeRF/blob/master/host/libraries/libbladeRF/include/libbladeRF.h
23:24:47 <funfunctor> EvanR: I know thats why I am discussing ;)
23:25:16 <funfunctor> EvanR: the line is here https://github.com/Nuand/bladeRF/blob/master/host/libraries/libbladeRF/include/libbladeRF.h#L104
23:25:42 <EvanR> funfunctor: alright. so here we have what you are calling double indirection, but its only to support the C return value mechanism. the two pointers in a row thing isnt something you need to live with forever in haskell, its just something to get a return value (which happens to be a pointer) once
23:25:58 <EvanR> you shouldnt need Ptr (Ptr Foo) as your "state"
23:26:04 <funfunctor> EvanR: and https://github.com/Nuand/bladeRF/blob/master/host/libraries/libbladeRF/include/libbladeRF.h#L236
23:26:53 <funfunctor> EvanR: that isn't my state, its                                  newtype BladeRF a = BladeRF { unBladeRF :: ExceptT BladeRFError (StateT (Ptr C'bladerf) IO) a }
23:26:58 <EvanR> when you use this C function that takes pointer to pointer to whatever, you only need to temporarily malloc memory (alloca) to get the pointer, which is itself just a value, doesnt require dynamically allocated memory
23:27:37 <EvanR> alright! Ptr C'bladerf, this is all you need, just put a newtype around that and call it a device handle
23:27:38 <funfunctor> EvanR: correct, its just a value of the address to whatever libbladeRF happens to allocate
23:28:00 <EvanR> then you have decomplected the device handle from the IO actions that use it
23:28:46 <funfunctor> EvanR: and what about all the error codes https://github.com/victoredwardocallaghan/hlibBladeRF/blob/master/src/LibBladeRF/LibBladeRF.hs#L39
23:28:58 <EvanR> the error codes themselves?
23:29:08 <EvanR> they are just codes, you have them in the bindings already
23:29:13 <funfunctor> no, dealing with them internally in the binding
23:29:29 <EvanR> if an operation may fail, use Either or an exception to throw one of those error codes
23:29:47 <EvanR> Foo -> IO (Either ErrorCode Bar)
23:30:25 <funfunctor> yea I am using ExceptT at the moment
23:30:43 <EvanR> if you use the types im saying, your code will collapse ;)
23:30:54 <EvanR> liftIO will be gone
23:31:03 <EvanR> no gets no whatever
23:31:10 * hackagebot euler 0.2.2 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.2.2 (decomputed)
23:32:01 <heatsink> funfunctor: EvanR mentioned 'alloca'.  It's useful for allocating temporary data in a small code region, instead of malloc/free, because it's less prone to memory leaks like the one in openBladeRF.
23:32:08 <EvanR> because the bindings are low level, you wouldnt wrap them with each other, and you wouldnt even need to use Either monad
23:32:25 <funfunctor> EvanR: but I will have openBladeRF return a DeviceHandle with the pointer value to the allocated region done in C land
23:32:47 <EvanR> you will need to use that at some level to get the handle once
23:33:12 <funfunctor> heatsink: yea I know about that, I was planning on using it.. just trying to get the larger picture sorted out first
23:33:23 <EvanR> also, what allocated region? its gone after alloc or free
23:33:32 <EvanR> alloca
23:34:12 <EvanR> or are you talking about the opaque object in C
23:34:43 <funfunctor> EvanR: well that pointer in the StateT at the moment has a address given to it by the C library that points to some struct somewhere that these libbladeRF functions use
23:34:50 <funfunctor> yes
23:34:58 <EvanR> yeah that is just the newtype DeviceHandle
23:35:04 <EvanR> its a pure value
23:35:39 <funfunctor> alright ah oh............. your saying that gets put on the heap
23:35:54 <EvanR> heap?
23:36:19 <funfunctor> > let x = 0xffff3333
23:36:20 <lambdabot>  not an expression: ‘let x = 0xffff3333’
23:36:26 <funfunctor> and then we use x after that
23:36:32 <funfunctor> rather than putting it in StateT
23:36:50 <EvanR> wrapped in an appropriate newtype so you dont use it as some other pointer yes
23:37:23 <funfunctor> I'm still a little confused, I thought you can't have "global variables" in haskell
23:37:27 <EvanR> take it as an argument to all the low level binding operations
23:37:35 <EvanR> its not global
23:37:55 <funfunctor> sorry can you just me a reduced case of what you mean in code
23:38:06 <heatsink> funfunctor: You would pass it to all the low-level functions when building the interface
23:38:07 <funfunctor> I think it would be easier for my thinking brain
23:38:18 <funfunctor> (its a thing)
23:38:18 <funfunctor> :p
23:38:25 <EvanR> newtype DeviceHandle = DeviceHandle (Ptr X)
23:38:39 <EvanR> openDevice :: IO (Either Error DeviceHandle)
23:38:51 <EvanR> pokeDevice :: DeviceHandle -> Int -> IO ()
23:38:51 <funfunctor> alright
23:39:02 <heatsink> createDevice = do {hdl <- openDevice; return $ RadioDevice { withRadioDevice = withBladeDevice hdl, setVCTCXO = bladeRFSet hdl, ...}}
23:39:05 <EvanR> peekDevice :: DeviceHandle -> Int -> IO Int
23:40:47 <funfunctor> heatsink: right so the point was to get rid of passing around hdl to each function
23:41:03 <EvanR> funfunctor: bad idea, you ended up with even more code in the process
23:41:11 <funfunctor> alright
23:41:16 <EvanR> thats what these interface layers are for
23:41:28 <funfunctor> although I do feel like my arm is being twisted
23:41:37 <funfunctor> but I believe you are right
23:41:56 <funfunctor> oh man, I really don't feel like this refactoring..
23:42:03 * funfunctor holds face
23:43:06 <EvanR> funfunctor: in oop, its common to encourage people to pass around handles to objects everywhere, thats what this is
23:43:13 <funfunctor> I don't suppose anyone has 30-40min to spare to help me refactor the binding in the interest of opensource :p ?
23:43:28 <EvanR> its also common to put such handles in global variables, but thats not on topic here or what you were trying to do
23:43:59 <EvanR> funfunctor: this is a commercial project ?
23:44:46 <funfunctor> EvanR: no, this was is because I think it would be cool to have cell phone coverage in places where people can't afford to get the telco to do it
23:44:54 <funfunctor> I thought it would be a nice project to do in haskell
23:45:36 <EvanR> figured you were at work, with all the moaning about rewriting code ;)
23:45:48 <funfunctor> I sort of wanted something more flexable than openbts that is maintainable and realiable were locals wont have skills to fix null pointers and that crap
23:45:53 <dulla> so you want to use radio in place of wifi
23:45:59 <dulla> neat
23:46:14 <dulla> all it needs now is meshnet
23:46:32 <EvanR> a world where locals can fix haskell code but not C code?
23:46:43 <funfunctor> dulla: well the idea is to have the core network be setup using DHT and stuff for call routing
23:46:44 <EvanR> it must be the future
23:46:57 <funfunctor> the future is now!
23:46:57 <dulla> Hmmm
23:46:58 <ab9rf> heh
23:47:16 <dulla> Look at Ethereum's p2p protocol, and ipfs' p2p protocol too, they seem to be pretty effective
23:47:18 <EvanR> "This is haskell, i know this"
23:47:28 <ab9rf> dihydrotesterone for call routing?
23:47:32 <funfunctor> trust me, openbts barely works. I mean they did a fantastic job reading all those pdf's but I think a rewrite could be a lot better
23:47:48 <ab9rf> er, dihydrotestosterone
23:47:59 <dulla> i wanna prosetylise
23:48:35 <funfunctor> lol, well.. I wanted something flexable enough to experience with new modulation and encoding for possible cell phones of the future also
23:48:53 <funfunctor> although LTE is pretty interesting usage of QAM
23:49:03 * dulla shrugs???
23:49:16 <EvanR> never know if the interface you make now will be agreeable to future unknown technology
23:49:18 <funfunctor> I just started learning about all this staff in this application
23:49:32 <dulla> Anyways
23:49:56 <funfunctor> EvanR: of course not, just as long as I fix the mistakes in this C++ code like writting the completely the wrong gpio's and so on..
23:49:57 <funfunctor> :p
23:49:58 <dulla> look at those things, funfunctor
23:50:15 <funfunctor> dulla: i've seen them
23:50:23 <dulla> are they good things
23:50:44 <funfunctor> all the things are good, only implementations usually suck
23:50:45 <funfunctor> lol
23:51:09 <funfunctor> AES is good, but find me a good implementation :p
23:51:33 <dulla> are they implemented well, then
23:52:01 <dulla> multiplex this or that, or does your webm's of dragons doing unspeakable things to vehicles not resolve fast enough
23:52:11 <dulla> this is the future
23:52:25 <dulla> we must be able to r34 anonymously, and freely
23:52:34 <funfunctor> I'll believe i'm in the future when Firefox stops trying to use 24GB of RAM
23:53:17 <Stratege_> funfunctor but that's how you know you are in the future.
23:53:38 <Stratege_> in the past that would have been impossible, the present is just a transition function, therefor you are in the future
23:53:39 <funfunctor> I had a feeling someone was going to say that
23:53:40 <EvanR> 24G ram should be enough for anybody
23:53:56 <funfunctor> lol
23:54:02 <dulla> funfunctor
23:54:05 <dulla> you mean the past
23:54:10 <dulla> that happened in the past
23:54:20 <dulla> ;_;7
23:54:46 <funfunctor> cry me a causality river
23:55:01 <dulla> I'm not kidding,e verything ran faster in the past
23:55:03 <dulla> the hell
23:55:11 <dulla> Is everyone EUbisoft now?
23:55:23 <EvanR> windows was slow in the past and the present
23:55:30 <funfunctor> I better branch and attempt this refactor
23:56:16 <dulla> ... it's only gotten slower
23:59:56 <dulla> ;;_;;
