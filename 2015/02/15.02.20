00:02:11 <zq> anyone know what ghc -B does
00:09:03 <mniip> damn applicative laws
00:09:28 <mniip> not applicative even
00:10:47 <mniip> is there a backwards equivalent of span?
00:11:08 <Cale> mniip: break?
00:11:25 <mniip> no I mean starting from the other end
00:11:31 <mniip> without reversing the whole thing
00:11:59 <jle`> sorry mabino-pyon :'(
00:12:06 <mabino-pyon> jle`: np
00:15:00 <ocramz> good morning all
00:15:06 <Sergio965> Hi!
00:15:41 <shiona> hello
00:16:00 <lpaste> mniip pasted “spanENd” at http://lpaste.net/120822
00:16:25 <mniip> reasonably lazy
00:16:40 <ocramz> I have a question: what is an idiomatic way to set up a computation that might end after a nondeterministic number of steps?
00:16:50 <ocramz> I'm thinking e.g. of an optimizer routine
00:17:20 <ocramz> Is it a State monad?
00:17:37 <ocramz> with some additional semantics on top?
00:18:40 <steffen> Hi :)  Please point me to the topic on which I have to read up: I want to fold over the fields of a bug Sum-type (not a product of sum) and do somthing for every filed which is of type Foo! the very same function should work when extending the sum-type or changing the type of fields! I started reading about Data.Data, but I saw that Generics is the new way to do it! But all I find about generics is about serializing! 
00:18:58 <steffen> of a bit sum type* ^^
00:19:03 <steffen> big! damn it xD
00:21:03 <frerich> steffen: Hm, does the term 'catamorphism' ring a bell?
00:22:22 <mniip> @let spanEnd f (x:xs) = let (p, s) = spanEnd f xs in if f x && null p then (p, x:s) else (x:p, s); spanEnd f _ = ([], [])
00:22:23 <mpickering> steffen: Can you please paste some example code? I think SYB might be able to help you
00:22:24 <lambdabot>  Defined.
00:22:31 <frerich> steffen: I'm not entirely sure I understood what you're trying to do, but you may find https://github.com/frerich/makemorphism useful -- it's a little TH helper which generates fold-like functions ("catamorphisms") for some given sum type.
00:22:42 <mniip> > fst $ spanEnd (== ' ') ("hello  world  " ++ undefined)
00:22:43 <lambdabot>  "hello  world*Exception: Prelude.undefined
00:24:10 <fread2282> steffen: do you know lens?
00:25:04 <steffen> frerich: Thanks, I'll look into it
00:25:55 <steffen> mpickering: yes SYB is what I looked into, but Generics seems to be 'the new way'
00:26:06 <fread2282> steffen: even if not, http://hackage.haskell.org/package/lens-4.7/docs/Data-Data-Lens.html#v:template dounds like what you're asking for and is really easy to use
00:26:27 <fread2282> s/dounds/sounds/
00:26:28 <steffen> fread2282: Thanks :)
00:30:15 <cryo28> exit
00:31:29 <narendraj9> How can one organize Haskell modules in folders and still be able to import them?
00:32:32 <narendraj9> I just want to be able to import .hs files which are in side some folder that resides in the current working directory which has the Main.hs file.
00:36:58 <jle`> hi all.  I can turn any (s, a -> State s b) into an ([a] -> [b]).  is there any way i can do the reverse?  take an ([a] -> [b]) and turn it into an (s, a -> State s b)
00:37:33 <jle`> forwards _ [] = []
00:37:48 <shachaf> You might be missing quantifiers.
00:38:30 <jle`> forwards (s, f) (x:xs) = let (x', s') = runState (f x) s0 in x' : forwards (s', f) xs
00:39:20 <jle`> hm yes i see how that might be problematic
00:40:02 <jle`> there's a trivial way to do this but it seems inefficient...keep a list of [a]'s as the state s, and then at each point, append to the list and output the last element of running the function
00:40:18 <jle`> but i feel like there should be a way to do this with sharing, without re-computing and re-concating the list at every step
00:40:23 <shachaf> What do you do about a function f :: [a] -> [b] such that f [] isn't []?
00:40:27 <jle`> sharing on the acucmulated [] that is
00:40:58 <jle`> hm
00:41:30 <jle`> it would be bottom if the nth element of [b] could not be computed from the first n elements of [a]
00:41:48 <jle`> but i also see your point there too
00:42:01 <jle`> how about we just presume that the ([a] -> [b]) is gotten from running `forwards` :)
00:42:11 <jle`> is there any way to invert the transformation?
00:42:38 <shachaf> Did you describe a way just above?
00:43:22 <jle`> the way i described works, but i feel like there should be a way that took advantage of sharing to avoid re-concatting the accumualted [a] at every step
00:46:24 <Cale> jle`: I'm a little hazy about what's going on, but it sounds vaguely like the kind of situation in which you might want to accumulate a function [a] -> [a] which adds elements to the beginning of a list, rather than to accumulate an [a] directly?
00:46:41 <Cale> jle`: (so that you can concatenate using composition)
00:47:13 <jle`> backwards f = ([], \x -> modify (++ [x]) *> gets f)
00:47:54 <jle`> um
00:48:01 <jle`> backwards f = ([], \x -> modify (++ [x]) *> gets (last . f))
00:48:19 <jle`> Cale: oh interesting
00:48:26 <Cale> yeah, that looks exactly like the kind of thing where you'd rather accumulate a function
00:48:27 <jle`> is that the difflisty version?
00:48:36 <Cale> Yeah, some people like to call it that
00:48:52 <Cale> So you'd have  modify (. (x:)) there
00:49:06 <jle`> the thing is that at every step you'd have to also recompute every element of the [b]
00:49:09 <Cale> er
00:49:13 <Cale> last
00:49:27 <jle`> in theory this shouldn't be necessary
00:49:27 * hackagebot pagerduty 0.0.1.1 - Client library for PagerDuty Integration and REST APIs.  http://hackage.haskell.org/package/pagerduty-0.0.1.1 (BrendanHay)
00:49:31 <Cale> Maybe I should take the time to actually understand what it is that you're trying to do
00:49:33 <jle`> but perhaps it is unavoidable here
00:49:34 <Cale> :D
00:49:44 <jle`> i'll throw up a paste
00:51:14 <shachaf> I'm pleased with Applicative instances being "monoids in the category of endofunctors [with Day convolution]".
00:51:37 <mpickering> What was the first version which GHC supported MultiWayIf?
00:55:42 <acetoline> Cale: ok I've been going through your expression generator explanation
00:55:44 <acetoline> what does the 'shrink' function do
00:56:00 <acetoline> it has type a -> [a]
00:57:21 <acetoline> and what are the constraints on coarbitrary
01:00:12 <mpickering> Is the debian version of ghc still ghc-7.4?
01:01:39 <acetoline> mpickering: it is on stable
01:01:43 <acetoline> don't know about testing
01:01:58 <acetoline> 7.4.1 to be exact
01:02:01 <sivteck> https://packages.debian.org/wheezy/ghc
01:04:08 <ocramz> what is an idiomatic way to represent a computation that passes state but can end after a nondeterministic number of times?
01:04:28 <ocramz> e.g. finding a stationary point on a surface
01:04:48 <ocramz> or the equilibrium configuration of a markov chain
01:05:59 <ocramz> is it about get'ing and put'ing stuff in a State monad?
01:08:46 <Cale> acetoline: ah, okay
01:09:41 <lpaste> jle` pasted “statey list conversion thing?” at http://lpaste.net/120823
01:09:48 <jle`> Cale: ^^
01:09:59 <dulla> So, more or less the state is a list?
01:09:59 <Cale> shrink is part of how QuickCheck works -- it looks for counterexamples to properties, and when it finds one, it then applies shrink to get a list of "smaller" or "simpler" values to also try, which it does recursively, searching for a minimal counterexample
01:10:37 <jle`> dulla: there might be a better way to do the conversion
01:10:40 <jle`> than using the state as a list
01:10:43 <jle`> maybe it can be two lists?
01:10:46 <jle`> idk heh
01:10:51 <acetoline> Cale: I see, and this has to be defined for a type or can it be derived?
01:10:58 <dulla> use extensible effects, and get the big bucks
01:11:09 <dulla> And not have to deal with tranforms?
01:11:21 <Cale> acetoline: shrink x = [] is always valid if you don't know what to do
01:11:33 <dulla> I once found this oleg site that had a nice stack of papers
01:11:35 <acetoline> ok
01:11:40 <Cale> acetoline: They're always hand-crafted, as far as I know
01:11:51 <acetoline> same with coarbitrary?
01:12:05 <Cale> coarbitrary you can usually build out of other coarbitrary instances
01:12:19 <dulla> Well, one day someone figured out you can zipper anything
01:12:24 <dulla> Maybe
01:12:45 <Cale> http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/src/Test-QuickCheck-Arbitrary.html#CoArbitrary -- if you look at the instances here, you'll get the idea pretty quickly of how to write one
01:12:55 <acetoline> I wanted to ask you for that
01:12:59 <acetoline> you're one step ahead of me
01:13:15 <dulla> the same zipper can be used to deal with a chromosomal data structure where a genotype can be a or [a], and have no real problem crossing them over
01:13:34 <dulla> seems like divine magic
01:14:36 <Saizan> bitrary instances
01:14:36 <Saizan> 10:11      dulla : Well, one day someone figured out you can zipper anything
01:14:36 <Saizan> 10:11      dulla : Maybe
01:14:54 <Saizan> oops, sorry
01:16:18 <acetoline> Cale: that source is quite helpful, thanks
01:16:32 <acetoline> although I might ask you about some of it later if you don't mind
01:16:52 <Cale> no problem
01:18:17 <Cale> I kind of feel like a lot of the stuff in QuickCheck should be pulled out and made into the standard random library
01:18:30 <Cale> Like, maybe you don't need shrinking
01:18:46 <Cale> But Arbitrary/Coarbitrary are nice, and even without them, Gen is a good thing to have around
01:19:19 <Cale> Also, the fact that it's based on tf-random, and so split isn't broken is a good thing.
01:20:17 <Cale> http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-Gen.html#g:2 -- all this stuff is so useful even outside QuickCheck
01:22:58 <dulla> Yeah, some dude, Oleg, or something, Saizan
01:23:16 <dulla> Apparently, it's the derivative of a traverse, not a data structure
01:23:42 <dulla> And then you can pretty much use it on anything you can traverse, with the added benefit of autoderivation
01:24:22 <dulla> Also, the benefit of context sensitive traversal/manipulation, though that goes without saying
01:43:31 <funfunctor> hi
01:46:52 <fractalsea> Is there a nicer way of tupling up Monadic functions than something like: (env, chans, sock) <- liftM3 (,,) (lift ask) askChans askSockId
01:47:25 <mauke\> separate <-
01:48:18 <fractalsea> mauke\: Yeah… I was just trying to avoid that because I have a lot of lines where it is just a single function (no args) on the right of the <-
01:48:31 <fractalsea> And I think it will be neater as a 1 liner
01:49:16 <putis_> hello
01:49:41 <putis_> i have a problem with installing hoogle package; during the install process following error occures: undefined reference to `initWinSock'
01:50:09 <putis_> it might by crucial that i try to do it on Windows
01:50:17 <mpickering> what is your setup putis?
01:50:22 <mpickering> haskell platform? plain ghc?
01:51:20 <putis_> I'm using plain ghc
01:51:44 <mpickering> can you paste the whole log of cabal install -v3?
01:52:58 <phadej> Cale: it is indeed. For my own projects I often have QuickCheck dependency to provide `Arbitrary` instances for my types.
01:53:07 * livexchosenn is waving
01:53:25 <phadej> OTOH it turns out I use them for something which could be considered "testing"
01:53:41 <livendie> Hi
01:54:07 <livendie> hi mehn
01:54:52 <livendie> whats all this?
01:55:16 <stool> Can't understand this simple and lensy type error: http://sprunge.us/XHCi
01:55:53 <quchen2_> stool: _1 isn't in scope so GHC thinks it's a hole
01:56:02 <stool> Oh.
01:56:12 <putis_> of course, here is it http://tny.cz/da7ee3aa
01:56:29 <quchen2_> stool: It's in Control.Lens.Tuple
01:56:32 <quchen2_> (Or in Control.Lens)
01:57:08 <Cale> livendie: This channel is for discussion of Haskell, the functional programming language.
01:57:17 <stool> quchen2_, Thanks, very surprising.
01:57:23 <Cale> (if that's what you were asking)
01:57:36 <ocramz> @lpaste
01:57:36 <lambdabot> Haskell pastebin: http://lpaste.net/
01:57:51 <livendie> Cale... How about hacking?
01:58:15 <mniip> sure, hacking in haskell, whatever
01:58:30 <mauke\> if by "hacking" you mean "access someone else's facebook account", no
01:58:30 <quchen2_> augur: One more point for your complaint/proposal. _1 is a valid identifier, but as a hole it doesn't need to be one.
01:58:51 <quchen2_> augur: That leads to error like stool's. (On the other hand, it enables using -fdefer-type-errors.)
01:59:26 <livendie> mauke no... Extreme... Like a bank
01:59:27 <mniip> mauke\, what about accessing facebook accounts in haskell though
01:59:56 <mauke\> livendie: too many movies?
02:00:08 <mniip> livendie, I'm pretty sure that lies within illegal activities and is prohibited on freenode overall
02:01:46 <livendie> mauke real funny. Can you hack like... Someone's IP?
02:02:00 --- mode: ChanServ set +o Cale
02:02:44 <lpaste> ocramz pasted “Monad.State/Random” at http://lpaste.net/120826
02:03:00 <ocramz> can I have a little help on that paste please?
02:03:24 <funfunctor> Does anyone have a recommendation on an existing package or a nice way to represent this C++ time interface? http://lpaste.net/120825
02:03:27 <ocramz> I don't get what "get" and "put" are supposed to be doing
02:03:41 <Cale> livendie: If you're interested in learning about functional programming, then feel free to stick around and learn Haskell, but if you're going to keep on that line, I'll have to ask you to leave.
02:03:49 <mauke\> livendie: yes, this is me: http://i.imgur.com/5c9H6DO.gif
02:03:54 * frerich imagines Cale taking off his shirt to show off his tattoos
02:04:07 <Cale> frerich: lol
02:04:20 <jle`> ocramz: line 12 binds `g` to the value of the state at that point
02:04:31 <jle`> ocramz: line 14 changes the state to be g'
02:04:39 <artrmbd> @undo cores <- readProcess "sysctl" ["-n", "hw.ncpu"] "" ;
02:04:39 <lambdabot> <unknown>.hs: 1: 7:Parse error: <-
02:04:39 <artrmbd>   return (read $ trimnl cores :: Int)
02:04:46 <livendie> Cale... OK... But can I program a virus with Haskell?
02:05:08 <artrmbd> @undo cores <- readProcess "sysctl" ["-n", "hw.ncpu"] "" ; return (read $ trimnl cores :: Int)
02:05:08 <lambdabot> <unknown>.hs: 1: 7:Parse error: <-
02:05:20 <jle`> artrmbd: you can play around with lambdabot by pm, btw :)
02:05:25 <jle`> aw
02:05:35 <jle`> i wonder why people do this...
02:05:45 <jle`> just show up to #haskell to try out a few lambdabot queries and then leave
02:06:13 <ocramz> jle` : so is this why we can get a sequence of random numbers rather than the same one repeated over and over?
02:06:50 <frerich> jle`: In this particular case, it almost looks as if somebody wanted to query some information about the system on which lambdabot is running.
02:06:51 <jle`> ocramz: yes...if you expand out (>>), for example, you see that randR >> randR is just literally the do block twice in a row
02:06:53 <funfunctor> anyone? I realize my question is a little vague
02:07:07 <jle`> so the first time you "get" is different from the second time oyu "get"
02:07:14 <jle`> becasue there's a "put" in between
02:07:32 <Fusebox> "livendie> Cale... OK... But can I program a virus with Haskell?" If you go down this route, I recommend not releasing it, but analysing other peoples viruses instead and working for a security firm to help patch those exploits the viruses would exploit
02:07:45 <Fusebox> it's just as fun
02:07:49 <funfunctor> I was thinking perhaps StateT to keep time?
02:07:52 <jle`> ocramz: btw if you haven't implemented the Monad instance for State before, i suggest maybe looking into it...it's a nice exercise and would help oyu understand State and its usage a lot more
02:07:52 <dulla> Just make sure you label the folder that has viruses
02:07:57 <dulla> as the virus folder
02:08:12 <dulla> and appedn "-VIRUS" to all file names
02:08:13 <jle`> and make sure your virus executables are `virus.exe` of course
02:08:15 <dulla> because
02:08:34 <dulla> a) keeps filenames distinct
02:08:41 <dulla> b) I wonder if it's a virus
02:09:00 <dulla> this goes for the ones you are trying to re
02:09:15 <frerich> funfunctor: You could first transform that C++ code to object-oriented C (i.e. make all members functions free functions so that the 'this' argument becomes explicit). Translating that into a set of types in Haskell plus functions operating on values of those types is quite straightforward.
02:09:26 <livendie> Fusebox asin an android virus?
02:09:26 <mniip> Fusebox, reverse engineering is a whole different sort of fun than forward engineering
02:09:28 <jle`> ocramz: if you want to test your understanding, try to tell me why using `runState` instead of `evalState` will never terminate/give you any items in your list
02:09:38 <jle`> :)
02:09:57 <dulla> what is forward engineering, mniip
02:10:10 <dulla> does it involve not learning what a solution is
02:10:11 <mniip> the reverse of reverse engineering obviously
02:10:12 <funfunctor> frerich: well I know how to write Haskell (actually better than C++ tbh) but i'm not sure of the design of a reasonable Haskell interface
02:10:18 <dulla> well, a predefined one is
02:10:32 <putis_> mpickering: you asked for a log; have you seen my link? http://tny.cz/da7ee3aa
02:10:39 <frerich> funfunctor: e.g. instead of having 'bool Z100Timer::expired() const' you have 'bool z100timer_expired( Z100Timer *that );'. From there, you could device a 'data Z100Timer = ...' and 'z100timer_expired :: Z100Timer -> Bool'
02:10:42 <ocramz> jle`: thank you :) I'm interested in implementing a deterministic but pragmatically unbounded computation (an optimizer, of which we don't know how many iterations will be needed to reach numerical convergence)
02:10:56 <livexchosenn> jle`:  what about an android virus
02:11:16 <frerich> funfunctor: I can't easily tell whether those 289 lines of code make for a nice interface, so I'd first try a somewhat mechanical translation to Haskell (to get more type safety) and then refactor.
02:11:23 <jle`> ocramz: by the way, there's actually a "shorthand" to your randR function
02:11:30 <jle`> did you get that from somewhere?
02:11:33 <funfunctor> frerich: I mean I can get the helper functions for free using the syntax sugar data FOO = FOO { bla :: Int } deriving (..) for example
02:11:47 <jle`> randR = state random
02:11:48 <ocramz> I did, yes, I'm just tinkering with it
02:11:50 <jle`> should be identical to what you have already
02:12:03 <frerich> funfunctor: That just gives you the getters actually. Chances are you don't actually need getter for everything.
02:12:07 <dulla> sounds... monte carlo, ocramz
02:12:22 <ocramz> dulla : yes, indeed, that's part of the picture
02:12:30 <dulla> there is a monte carlo monad :^)
02:12:31 <jle`> ocramz: if you want, you can "think" of `state` as wrapping together a get, puts, modify, etc. all in a row
02:12:50 <jle`> ocramz: state :: (s -> (a, s)) -> State s a
02:13:06 <funfunctor> frerich: hmm, I can't tell if the interface is reasonable either..
02:13:09 <jle`> give a function that takes the current state, and a tuple of (1) the result you want and (2) the modified state, gives you a State s a
02:13:09 <frerich> funfunctor: I'd suggest to start without that 'record syntax'. In the places where you need to access the fields by descriptive names you could always use pattern matching, e.g. use 'data Z100Timer = Z100Timer Timeval Word32 Bool' but later you can do 'f (Z100Timer endTime timeout active) = ...'
02:13:31 <jle`> ocramz: which is btw exactly what you are doing here...`state` abstracts over it :)  (at least, that's one way to look at it)
02:13:34 <jle`> :t random
02:13:35 <lambdabot> (Random a, RandomGen g) => g -> (a, g)
02:13:43 <jle`> random fits exactly the same that you need for that function, conveniently
02:13:45 <funfunctor> the main class of interest is Time
02:14:07 <utdemir> Hey. I remember reading a document about typechecking example code documentation(Haddock), but can't find it. Can anyone remember it? Or anyone have a suggestion that how can I typecheck example codes in Haddock markup?
02:14:11 <funfunctor> frerich: seems like StateT would be needed for Time unless I am mistaken?
02:14:11 <jle`> if you want, you can say state (\g -> let (r, g') = random g in (r, g')) if it's more clear
02:14:28 <frerich> funfunctor: Really? Why?
02:14:50 <mpickering> putis_: so the network package is traditionally very difficult to install on windows so that might your problem
02:15:07 <ocramz> jle` : and this in fact binds the next computation with the results of the previous one, doesn't it?
02:15:21 <mpickering> putis_: I can't comment further than that though, maybe try https://github.com/fpco/minghc ?
02:15:40 <funfunctor> frerich: because there are methods that act on internal states like decTN for example, line 65
02:15:51 <jle`> ocramz: the next >>'d or *>'d or >>='d thing will see the new modified s
02:15:58 <jle`> when it `get`s and stuff
02:16:30 <ocramz> jle` : awesome, thanks :)
02:16:58 <jle`> > runState (state (\s -> (10, s+1) >> state (\s -> ("hello", 2*2))) 3
02:17:00 <lambdabot>  <hint>:1:68:
02:17:00 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
02:17:00 <ocramz> jle`: this gives us more fine-grained control than just daisy chaining >>= and >>
02:17:10 <jle`> > runState (state (\s -> (10, s+1)) >> state (\s -> ("hello", 2*2))) 3
02:17:12 <lambdabot>  ("hello",4)
02:17:21 <frerich> funfunctor: Those 'internal states' are just member variables. The equivalent of that would be something like 'data Time = Time Int Int', the 'decTN' method would be something like 'decTN :: Word32 -> Time -> Time' and 'decTN step (Time mFN mTN) = Time mFN' mTN'
02:17:38 <frerich> funfunctor: Where mFN' and mTN' are the new values of mFN and mTN
02:17:54 <jle`> ocramz: using state here and using your get/put/return cocktail are semantically the same...yet state is actaully more efficient from the way StateT is implemented
02:18:07 <frerich> funfunctor: I.e. don't modify the given object in Haskell - return a new value of the sam type.
02:18:26 <funfunctor> frerich: yep I see that but mFN, mTN don't carry state on object enumeration?
02:18:41 <jle`> ocramz: btw, you might want to look at `replicateM`
02:18:43 <jle`> :t replicateM
02:18:44 <lambdabot> Monad m => Int -> m a -> m [a]
02:18:51 <frerich> funfunctor: Not sure I understand - what does "don't carry state on object enumeration" mean?
02:18:57 <jle`> instead of someUniforms using lift and mapM
02:19:10 <ocramz> jle`: yes but this constrains explicitly the number of repetitions
02:19:11 <funfunctor> frerich: sure but I think the point of the interface is to hold ticks over time unless I misundertand it
02:19:23 <jle`> ocramz: yes, but so does someUniforms :)
02:19:50 <jle`> ocramz: there's actaully a problem you might run into when using mapM and repeat
02:20:01 <jle`> btw uniforms = sequence (repeat randR)
02:20:32 <jle`> the problem is that if you ever try to *>, >>, >>=, etc. from someUniforms...you'll never get to the second action
02:20:57 <frerich> funfunctor: Right, the C++ version uses a lot of methods for modifying the current object. You wouldn't necessarily do that in Haskell -- at least I wouldn't start like that. Instead, I'd adjust the methods such that instead of modifying the current object they return a new (updated) object and leave it to the caller to overwrite the original object or not.
02:20:59 <jle`> do xs <- someUniforms 10; ys <- someUniforms 10; return (zipWith (+) xs ys)
02:21:11 <jle`> you'd expect that to return a list of 10 items that are each sums of pairs of random numbers, yes?
02:21:35 <ocramz> jle` ; I'm following
02:21:47 <frerich> funfunctor: I.e. as if the signature of 'decTN' was 'Time Time::decTN(unsigned step=1) const;' (it returns an updated 'Time' value) and the caller would do 't = t.decTN();' instead of just 't.decTN();'.
02:21:53 <jle`> ocramz: that is what you'd hope, right? or expect
02:22:12 <jle`> from your understanding of how State works
02:22:53 <funfunctor> frerich: ok thanks
02:23:03 <ocramz> jle` : ugh, my understanding is still pretty sketched
02:23:08 <funfunctor> frerich: lots of this C++ is pretty horrible
02:23:14 <ocramz> I was trying out your code snippets
02:23:20 <nkar> ezyang: thanks for this post: http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/  I've just found a thunk leak in my program
02:23:24 <jle`> you'll see that it doesn't work :O
02:23:41 <funfunctor> frerich: its from OpenBTS, i've re-implemented a large amount of it in Haskell
02:23:42 <jle`> even though your list's results are generated lazily
02:24:03 <frerich> funfunctor: Sounds like a nice project!
02:24:11 <jle`> if you're running examples, try do xs <- replicateM 10 randR; ys <- replicaeM 10 randR; return (zipWith (+) xs ys)
02:24:22 <funfunctor> frerich: thx
02:24:28 <jle`> ocramz: *that* should work when you runRandom it
02:24:34 <jle`> see if you can understand how that works
02:24:45 <frerich> funfunctor: Do you have some code online yet, on github or so? :-)
02:24:51 <jle`> and then see that you sort of "expect" it to work the same way as the earlier version with someUniforms
02:25:04 <funfunctor> frerich: I can upload it sure if you give me a hour or so?
02:25:08 <jle`> but then note that the someUniforms version doesn't terminate
02:25:14 <jle`> (i'm giving away spoilers)
02:25:23 <funfunctor> frerich: I only have the bladeRF bindings uploaded
02:25:31 <frerich> funfunctor: Ah, it's not urgent (I'm at work anyway, so cannot really look closely). I was just curious.
02:25:37 <funfunctor> frerich: https://github.com/victoredwardocallaghan/hlibBladeRF
02:25:43 <frerich> *click*
02:26:02 <ocramz> jle` : yes, it doesn't terminate
02:26:08 <funfunctor> frerich: i'll upload the rest soonish, I want it to be "somewhere" first ideally
02:26:09 <jle`> ocramz: oh also btw, you can use `fmap` instead of `liftM`
02:26:09 <ocramz> now I'm seriously puzzled
02:26:19 <jle`> ocramz: do you undersatnd the two snippets, though?  or at least the replicateM 10 randR one?
02:27:34 <jle`> remember that `someUniforms` needs to know the "current state", or...the final state of the command before (or command sup to that point)
02:27:50 <jle`> this isn't a problem with your first line, xs <- someUniformis 10
02:28:02 <jle`> but the second line, ys <- someUniforms 10 .... there's the problem
02:28:16 <jle`> what is the "current state"?
02:28:47 <jle`> your definition of uniforms is basically randR >> randR >> randR >> randR >> randR >> ... forever
02:29:05 <jle`> now, you don't need to actually run it forever to get the first ten *results*
02:29:11 <ocramz> jle` : uhmmmm
02:29:18 <jle`> you only need the first ten randR's to get the first ten results
02:29:28 <jle`> which is why your example that you pasted works
02:29:42 <jle`> but...how do you get the "final state" at the end of your randR >> randR >> randR >> ... chain?
02:30:09 <jle`> you need the final state, because the line ys <- someUniforms 10 needs the final state of xs <- someUniforms 10 to start chugging
02:30:13 <arj> could anyone give me a small hint how to enable bang patterns inside ghci?
02:30:22 <jle`> but you'll never get the final state after xs <- someUniforms 10
02:30:33 <jle`> because the final state is the resulting state after an infinite amount of randR's
02:31:31 <jle`> anyways the lesson here is to use replicateM...or...if you ever want to have an infinite list of random numbers, you aren't allowed to "need" the final generator at the end of it all.
02:31:37 <ocramz> jle`: yes apparently I still don't understand how binding works
02:32:37 <jle`> you know how the do notation desugars, right? :)
02:32:47 <ocramz> jle`: I don't get why a computation that's prepended by (take n) should be non-terminating
02:33:03 <jle`> ocramz: every line in the do block produces both a result and a modified state
02:33:15 <ocramz> jle`: yes, do desugars to a chain of >>= or >>
02:33:24 <jle`> your `take n` will yield a finite result
02:34:06 <mniip> woohoo I've successfully devised an IORef lens
02:34:12 <jle`> so remember, xs <- someUniforms 10 is actually xs <- fmap (take 10) $ randR >> randR >> randR >> randR >> ... (forever)
02:34:39 <jle`> um...that's weird notation, but you sort of get what i mean
02:34:50 <mniip> ioLens = lens (>>= readIORef) $ \i v -> i >>= \i -> v >>= writeIORef i >> return i
02:35:02 <mniip> :: Simple Lens (IO (IORef a)) (IO a)
02:35:16 <jle`> ocramz: that line has to have both a result and a "final state" after it
02:35:24 <jle`> so the result you can get...it's finite, because of take 10
02:35:38 <jle`> but the final state...you need to calcuate he final state after all infinite randR's
02:35:50 <jle`> if you don't ever need the final state, then that's cool.
02:36:09 <jle`> but the very next line, ys <- someUniforms 10, needs the final state of the previous line to begin its work
02:36:22 <jle`> and it'll just wait for it forever
02:36:29 <jle`> while your computer heats up :)
02:36:39 <ocramz> jle` : damn
02:36:50 <mniip> summarizing,
02:36:59 <ocramz> jle`: like, seriously
02:37:04 <jle`> but if you look at the definition of `replicateM`, it actually only >>'s *as much as you need*
02:37:12 <mniip> you only use the values produced by the first 10 calls
02:37:13 <jle`> so it doesn't >> an infinite amount of items and then takes it at the end
02:37:17 <jle`> @src replicateM
02:37:17 <lambdabot> replicateM n x = sequence (replicate n x)
02:37:20 <mniip> however you use the state produced by the infinite chain
02:37:29 <jle`> i was hoping for a more insightful @src
02:37:32 <mniip> which isn't computable
02:37:46 <jle`> congrats on the lens mniip
02:37:47 <jle`> :)
02:37:50 <mniip> what's wrong with this src
02:38:09 <jle`> arj: have you tried :set -XBangPatterns or whatever extension you need?
02:38:13 <ocramz> jle`: ok, so let me get the rationale right: it's not a good idea to perform finite sets of monadic actions as I was trying to, but rather define a single "module" and replicateM it
02:38:32 <jle`> it's not quite about monads, it's about StateT in particular
02:38:38 <arj> jle`: thanks! this was what I was searching for, but I somehow couldn't find it.
02:39:12 <jle`> because the way (>>=) is implemented for State, in `x >> y`, y requires the "final state" of x to continue
02:39:29 <jle`> it all boils down to State itself, and you can't really say anything in general about Monads
02:40:05 <mniip> I'm somewhat certain that for any monad,
02:40:06 <ocramz> jle`: ok, I'm starting to see the light
02:40:26 <ocramz> jle`: thanks a lot! :)
02:40:32 <mniip> fix (return >>) >> error "not executed"
02:40:45 <mniip> er
02:41:13 <mniip> fix (x >>) >> error "not executed"
02:41:20 <ocramz> jle`: but damnit haskell, I just wanted a list of random numbers to train my machines with, and now you show me how deep the rabbit hole goes
02:41:26 <jle`> > runIdentiy $ do xs <- fmap (take 10) (mapM (const (return 1)) [1..]); ys <- fmap (take 10) (mapM (const (reutrn 1)) [1..]); return (zipWith (+) xs ys)
02:41:27 <lambdabot>  Not in scope: ‘runIdentiy’
02:41:27 <lambdabot>  Perhaps you meant ‘runIdentity’ (imported from Control.Monad.Identity)Not in...
02:41:27 <lambdabot>  Perhaps you meant one of these:
02:41:37 <jle`> > runIdentity $ do xs <- fmap (take 10) (mapM (const (return 1)) [1..]); ys <- fmap (take 10) (mapM (const (reutrn 1)) [1..]); return (zipWith (+) xs ys)
02:41:38 <lambdabot>  Not in scope: ‘reutrn’
02:41:39 <lambdabot>  Perhaps you meant one of these:
02:41:39 <lambdabot>    ‘return’ (imported from Control.Monad.Writer),
02:41:50 <jle`> ocramz: heh, actually, your whole thing works with just replicateM :P
02:42:03 <jle`> > runIdentity $ do xs <- fmap (take 10) (mapM (const (return 1)) [1..]); ys <- fmap (take 10) (mapM (const (return 1)) [1..]); return (zipWith (+) xs ys)
02:42:04 <lambdabot>  [2,2,2,2,2,2,2,2,2,2]
02:42:31 <jle`> that works because the way (>>=) is implemented for Identity, you only need the *result* to continue...not some "final state"
02:43:27 <jle`> > (do xs <- fmap (take 10) (mapM (const (return 1)) [1..]); ys <- fmap (take 10) (mapM (const (return 1)) [1..]); return (zipWith (+) xs ys)) :: Maybe [Int]
02:43:28 <lambdabot>  *Exception: stack overflow
02:43:45 <mniip> jle`, actually
02:43:55 <jle`> that doesn't work because the way that (>>=) is implemented for Maybe, for x >> y, y needs to know if x "ended on" a Just or a Nothing
02:44:08 <mniip> fix (return () >>) >> error "hello"
02:44:20 <mniip> try it on different types of monad, it never halts
02:44:32 <jle`> mniip: we're talking about cases where the *result* is computable
02:44:42 <jle`> oh
02:44:54 <jle`> yeah the reuslt there isn't computable
02:45:05 <mniip> oh
02:45:08 <mniip> Identity
02:45:15 <mniip> @src Identity
02:45:16 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
02:45:18 <jle`> it shouldn't work for Identity either
02:45:22 <mniip> ಠ_ಠ newtype
02:45:29 <mniip> irrefutable patterns
02:45:37 <mniip> bug!!!!!!
02:45:47 <jle`> > runIdentity $ fix (return 1 >>)
02:45:51 <lambdabot>  mueval-core: Time limit exceeded
02:46:00 <jle`> you need to go all the way down the >>'s to get the result
02:46:36 <mniip> > runIdentity $ fix (return () >>) >> return "hello"
02:46:38 <lambdabot>  "hello"
02:46:39 <jle`> ocramz: don't worry, this is just a really tricky diversion...in truth, working with State is pretty simple.  just be careful about working with infinitely chained stateful actions
02:47:00 <putis_> mpickering: hoogle has installed with minghc sucessfully; for now I have to figure out how to apply it to my ghc build; I can't use minghc in my own project because it uses DisfunctionalDependecies extension witch is not included in main ghc build; thanks for advice
02:47:19 <jle`> mniip: ah yes :)  well the the second thing doesn't ever ask for the result actually, so that's fine.
02:47:39 <jle`> it's the same deal in State if your second thing doesn't ever ask for the state
02:47:46 <ocramz> jle`: ok, so within a State action the dependencies must be explicit
02:48:06 <jle`> within a State action, you must make sure that every line leaves it off with a "final state" that makes sense
02:48:31 <jle`> sequencing an infinite amount of stateful computations doesn't leave a meaningful final state, even though you might get a finite result
02:48:58 <jle`> it's actaully not a problem people run into that often
02:49:10 <jle`> but when it happens it always leads to "wait what's going on" stuf
02:49:46 <jle`> ocramz: anyways, cheers --- it looks like you know how things are supposed to work with `replicateM`, and your intuition in things-that-aren't-infinite is good :)
02:50:47 <funfunctor> frerich: any tips on fixing line 378 http://lpaste.net/120831
02:51:07 <ocramz> jle`: thank you so much, you're a good internet person. I'll dig into the examples you provided and hopefully one day I'll be able to actually use haskell for something other than toy examples
02:51:11 <jle`> haskell is about working with what you do understand and not being happy/not intimidated by things you don't.  and just poking at them until they become things you do :)
02:51:43 <jle`> ocramz: btw my first ever haskell project was a metropolis-hastings monte carlo simulation using StateT (actaully RandomT) w/ Reader and ST, if you wanted to check it out
02:51:47 <funfunctor> frerich: its a little messy while I was just straight translating the C++, i think there function is a little buggy?
02:51:50 <jle`> or maybe it was my second ever...
02:52:03 <jle`> it was around 2nd or 3rd.  i can't guaruntee that it's clean or readable or has good style...but it runs :P
02:52:16 <ocramz> jle`: by all means, I'd be very interested in seeing it
02:52:36 <mniip> jle`, I'm pretty sure there's a rule that says '⊥ >> x = ⊥'
02:52:45 <mniip> all Monads follow it
02:52:45 <jle`> https://github.com/mstksg/pi-monte-carlo
02:52:51 <mniip> except Identity
02:53:16 <jle`> mniip: i don't recall any such rule, but if you find it, i'd be happy to check it out :)
02:53:40 <jle`> > runReader (undefined >> return 10) "hello"
02:53:42 <lambdabot>  10
02:53:57 <mniip> hmm
02:54:12 <mniip> okay then
02:54:35 <ocramz> jle`: do you know hasty-hamiltonian by @jtobin ?
02:54:38 <jle`> > fst . runWriter $ undefined >> return 10
02:54:40 <lambdabot>  Could not deduce (Data.Monoid.Monoid b0)
02:54:40 <lambdabot>    arising from a use of ‘GHC.Base.>>’
02:54:40 <lambdabot>  from the context (GHC.Num.Num c)
02:55:02 <jle`> > (fst :: (Int, ()) -> Int) . runWriter $ undefined >> return 10
02:55:03 <lambdabot>  10
02:55:22 <jle`> ocramz: i don't :)
02:55:45 <jle`> mniip: that last one was probably cheating though because i didn't evaluate the entire result
02:55:50 <ocramz> jle`: it uses PrimMonad, so it's a bit beyond my current level, but the code is quite short so I get the gist of it
02:56:25 <frerich> funfunctor: I don't know whether that function is correct but I think you could almost translate that verbatim, something like http://lpaste.net/120832 plus some fromInteger/toInteger I guess
02:56:31 <jle`> > runState (undefined >> put "hey" >> return 10) ""
02:56:33 <lambdabot>  (10,"hey")
02:56:39 <jle`> oh hey :)
02:56:55 <jle`> it works 'cause put "hey" doesn't require the "final state" of `undefined` to do its job.
02:57:07 <danilo2> Hello! Is it possible to decode binary data from haskell in C++ in any sensible way? I mean, I would like to use Binary haskell library to serialize data and unserialize and understand it in C++. Currently we are using protobufs, but they are too slow for our purposes and binary is much faster
02:57:10 <mniip> jle`, if it were ⊥, it would be 'runState ⊥ 10'
02:57:13 <mniip> but it isn't
02:57:26 <mniip> so my thoery is wrong
02:57:37 <mniip> I should write a paper
02:57:45 <jle`> do i :)
02:57:46 <jle`> it
02:58:36 <thomassgn> Hi, trying to follow https://wiki.haskell.org/How_to_write_a_Haskell_program#HSpec and have come to this part about hspec. Problem is I am getting ' cannot satisfy -package-id haq-0.1.0.0-inplace' from running 'cabal install --enable-tests' and 'cabal test'. Both after adding the test code and test-suite to the project... Any pointers?
02:58:51 <funfunctor> frerich: thx
03:00:28 <mpickering> thomassgn: try "cabal configure"
03:01:04 <mpickering> you probably want "cabal install --only-dependencies --enable-tests" "cabal test" as well
03:04:44 <caper> Any one familiar with Bandwidth
03:05:38 <thomassgn> mpickering: 'cabal configure' finishes w/o problems, so does 'cabal configure --enable-tests'. 'cabal install --only-dependencies --enable-tests' tells me all packages are installed, and last 'cabal test' gives me the error from above: '<command line>: cannot satisfy -package-id haq-0.1.0.0-inplace'
03:06:08 <caper> I want to buy the number but api not work
03:06:48 <mpickering> thomassgn: maybe try clearing dist/ ?
03:06:59 <thomassgn> will do
03:07:22 <mpickering> I would expect "cabal install --only-dependences --enable-tests; cabal configure --enable-tests; cabal test" to work
03:14:58 <thomassgn> I removed all of dist/ and .cabal-sandbox/. Reinitialized the sandbox and ran 'cabal install --only-deps... --enable-tests' which gave me the same error about not being able to satisfy package haq. Same for cabal {build,test}. Removing dist and .cabal-sandbox again and trying your expression...
03:15:31 <workerbeetwo> Hi. I got a hackage and cabal install package failed to resolve dependencies. how aviod that situation for those who download?
03:15:31 <danilo2> Hello! Is it possible to decode binary data from haskell in C++ in any sensible way? I mean, I would like to use Binary haskell library to serialize data and unserialize and understand it in C++. Currently we are using protobufs, but they are too slow for our purposes and binary is much faster
03:15:34 <danilo2> :)
03:17:31 <caper> Bandwidth is DID management  know something
03:19:08 <merijn> danilo2: binary is the way to go, but don't use the Serialize class
03:19:24 <merijn> danilo2: The Serialize class adds binary specific markers. Just use plain Get/Put operations
03:19:25 <danilo2> merijn: ok, so how should we do it ?
03:19:44 <danilo2> merijn: hmmm, so we should implement our own way of putting bits and getting the m out ?
03:20:08 <danilo2> *them
03:20:55 <merijn> danilo2: No, binary has those, you should just use Data.Binary.Get and Data.Binary.Put directly, instead of using the encode/decode typeclass functions
03:21:59 <merijn> like "runPut $ do { putWord8 5; putByteString "blah" }"
03:22:19 <merijn> Same with runGet/runGetIncremental
03:26:21 <workerbeetwo> cannot resolve dependency  base ==4.5.*cabal
03:27:47 <dramforever> workerbeetwo: IIRC somebody told me that base is tied to the compiler
03:28:12 <workerbeetwo> dramforever: ok. so an compiler update would perhaps do?
03:28:34 <workerbeetwo> dramforever: its ghc 7.6.3 not that old.
03:28:45 <dramforever> workerbeetwo: actually...base 4.5 is old
03:29:00 <dramforever> yeah I have 7.6.3 and base is 4.6.0.1
03:29:22 <dramforever> workerbeetwo: what package are you trying to install? Maybe it's too old
03:30:06 <dramforever> a compiler *downgrade* might do, but I'm sure you don't want to do that
03:30:21 <workerbeetwo> dramforever: arguedit . but it would be awsome if old packages could be installed even if compile and stuff do progress.
03:31:19 <flan3002> Hey, what might lots of "There are files missing in the ‘stm-2.4.4’ package" errors mean (different packages)? It works when invoking "cabal install as root.
03:31:32 <dramforever> workerbeetwo: yeah, but it's up to the authors (and perhaps maintainers) to upgrade
03:31:39 <HeladoDeBrownie> flan3002, why are you invoking cabal-install as root?
03:31:56 <flan3002> HeladoDeBrownie - To see if that changes anything. It did.
03:32:11 <HeladoDeBrownie> flan3002, i don't understand.
03:32:56 <workerbeetwo> dramforever: I am the author. first project there and did not have much time. so I would compile the source and put up a new version to hackage? and on a regular basis? how combersom.
03:33:44 <dramforever> workerbeetwo: not very regular. I believe that ghc doesn't release very often
03:34:12 <flan3002> HeladoDeBrownie - It doesn't work without root, and I suspected installed packages (arch) might conflict with it.
03:34:17 <dramforever> you can change (relax) the dependency on base, recompile to see if it works, and re-push to hakage
03:35:33 <flan3002> Oh, and I wiped .cabal... that helped before. D:
03:35:39 <dramforever> workerbeetwo: yeah very "combersom" (did you mean cubersome?)
03:35:47 <HeladoDeBrownie> flan3002, i doubt it's running as root per se that makes it work (unless one or more of the packages you're installing is doing something weird); as you suggest it might have to do with different sets of packages.
03:35:56 <HeladoDeBrownie> flan3002, are you familiar with sandboxes?
03:36:07 <flan3002> HeladoDeBrownie - Not really. *googles*
03:36:12 <workerbeetwo> dramforever: cumbersome.
03:36:25 <HeladoDeBrownie> flan3002, what does `cabal -V` output?
03:36:37 <flan3002> cabal-install version 1.22.0.0
03:36:39 <flan3002> using version 1.22.0.0 of the Cabal library
03:37:22 <thomassgn> mpickering: Same result as above... but if this should work I could search around for the error message. I have also put the repo on https://github.com/thomassigurdsen/haq.
03:37:30 <HeladoDeBrownie> flan3002, sounds good then. `cabal sandbox init` creates a sandbox in the current directory, which makes several cabal commands work with the sandbox rather than the user package database. `caball install foo`, for example, installs to a local sandbox if one is available.
03:37:43 <flan3002> HeladoDeBrownie - Sounds like what I want. Thank you.
03:38:00 <dramforever> workerbeetwo: oh yeah. double-fault
03:38:44 <HeladoDeBrownie> flan3002, and in case this wasn't clear: you probably shouldn't run cabal-install as root.
03:39:32 <flan3002> HeladoDeBrownie - Of course, but it was the quickest way to test if it was a problem with my normal users .cabal, without knowing about sandboxes. :)
03:39:40 <flan3002> Or... so I thought.
03:39:41 <HeladoDeBrownie> okay, fair enough
03:39:53 <HeladoDeBrownie> you could also use another user for that probably
03:39:59 <dramforever> flan3002: quickest way to break the whole system's cabal too
03:40:46 <dramforever> if you just broke your own you can always rm -rf ~/.ghc (at least I do this)
03:41:08 <flan3002> Well... I can do that for the root user too, can't I? D:
03:41:25 <dramforever> (breaking also includes running into cabal hell)
03:42:12 <merijn> You should never run cabal install as root as it will install packages in the root users home dir
03:42:33 <flan3002> That was my intention though.
03:42:37 <merijn> Why?
03:42:46 <merijn> The root user home dir is not global...
03:42:54 <dramforever> oh yeah
03:43:00 <merijn> It means they're only available for root...
03:43:07 <dramforever> but are you sure running cabal as root isn't special?
03:43:20 <dramforever> I mean, a special case to install globally
03:43:26 <flan3002> Sure, but I just needed another clean user to test installing it...
03:43:34 <danilo2> merijn: hmm interesting. But then I'm not able to use automatic instance deriving of Binary, am I ?
03:43:36 <flan3002> And abusing root was the fastest thing to do.
03:43:52 <merijn> danilo2: Right, but the derived instance is wrong when interacting with foreign code anyway
03:43:54 <dramforever> danilo2: if you do you won't know what it does
03:44:01 <danilo2> merijn: Would you be so nicee and tell  me few words more about the difference between encode and put ? What does encode puts in the metadata?
03:44:03 <merijn> danilo2: Because it doesn't match the C++ layout
03:44:14 <flan3002> Anyways... it doesn't matter. Asked, learnt about sandboxes, going to use sandboxes, everyone happy. ^^
03:44:24 <merijn> danilo2: encode tags values with their types, I think
03:44:40 <dramforever> danilo2: writing your instance Binary by hand is also good
03:45:08 <danilo2> merijn, dramforever: Ok, Ive got it. We've got yet another idea - to make encodeing and decoding in haskell and link the haskell to C++ code and use FFI to transfer the structures. What do you think about it ?
03:45:22 <danilo2> dramforever: why? :)
03:45:41 <dramforever> danilo2: why about what?
03:46:20 <danilo2> dramforever: why writing Binary instances by hand is a good idea. It takes time and you need to update it when strucutre changes , which is harder than using the FFI idea, isnt it ?
03:46:26 <Eremox`> grep for ">"
03:46:47 <Eremox`> How do i grep the logs?
03:46:55 <dramforever> danilo2: you have to update the FFI when structure changes, too
03:47:16 <dramforever> how do you want to FFI?
03:47:41 <danilo2> dramforever: Of course, but it is simplier than updatign put function isnt it? You know - you dont have to thinkaaabout the layout and everything - it is just more stable - or am I wrong?
03:48:10 <dramforever> danilo2: stable, but how do you know what format is it doing?
03:48:18 <Cale> danilo2: Storable instances require you to think about layout as well
03:48:19 <danilo2> dramforever: FFI is able to transfer data types to C structs, right? If its true than its straightforward and of course you need to keep that in sync with haskell structs
03:48:21 <dramforever> is it working in
03:48:29 <dramforever> danilo2: no
03:48:45 <dramforever> it isn't able to, unless you have instance Storable
03:49:09 <dramforever> and that's no less, if not more, complicated to do
03:49:25 <danilo2> dramforever, Cale: oh ok
03:49:51 <dramforever> danilo2: how much data are you dealing with?
03:50:19 <danilo2> dramforever: much. about few hundred AST nodes, but sent frequently
03:50:32 <dramforever> oh
03:50:37 <dramforever> hey idea: \
03:50:51 <dramforever> are most of your code in C++ or haskell?
03:51:05 <danilo2> dramforever: backend - haskell, gui - c++.
03:51:22 <danilo2> dramforever: so all the core logic (which is the majority) is in haskell
03:51:36 <merijn> danilo2: C structs are the most annoying bit the FFI
03:52:04 <merijn> danilo2: Transferring structs from haskell to C/C++ via the FFI is MUCH more work than writing binary serialisation by hand
03:52:41 <dramforever> danilo2: is it like an interactive AST editor?
03:52:48 <danilo2> merijn: ok, thank you. I think its good idea.
03:52:54 <danilo2> dramforever: exactly
03:54:57 <augur> quchen2_: interesting. perhaps itd be best then if edwardk sent the email
04:05:02 <danilo2> merijn, dramforever: thank you for your help :) I'm going eat something, so brb :) thank you once again!
04:05:16 <dramforever> danilo2: you're welcome
04:09:36 <funfunctor> frerich: still happen to be around?
04:19:37 * hackagebot api-builder 0.4.0.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.4.0.0 (Intolerable)
04:20:44 <thomassgn> mpickering: Thought I'd let you know that I found a sort of answer to my problem: https://stackoverflow.com/questions/23803725/error-while-creating-test-suites-cannot-satisfy-package-id
04:26:45 <funfunctor> can someone help me with this custom Ord instance I am trying to do
04:27:21 <lpaste> funfunctor pasted “No title” at http://lpaste.net/120836
04:28:24 <dramforever> funfunctor: 1. why '<' with quotes?
04:28:53 <merijn> funfunctor: 2. you're matching the constructor and then 1 argument which is wrong for record syntax
04:29:35 <dramforever> 3. it seems that replacing the LHS with t < t' should make more sence
04:29:39 <dramforever> s/sence/sense
04:30:04 <merijn> Also equality comparison is ==
04:31:11 <merijn> See my annotation: http://lpaste.net/120836
04:31:52 <dramforever> merijn: isn't that "if" version...shorter?
04:32:11 <merijn> Who says I'm going for shorter?
04:32:35 <merijn> I prefer guards over ift-then-else
04:33:00 <lpaste> merijn revised “No title (annotation)”: “No title” at http://lpaste.net/120838
04:33:02 <dramforever> merijn: it seems to me that in this case, "if" is cleaner
04:33:09 <merijn> Actually I like that one better
04:33:50 <dramforever> okay
04:33:57 <dramforever> funfunctor: it's up to you
04:36:25 <dramforever> New thought: there's nothing too magical with lens. it's just a church encoded setter/getter pair that composes with (Prelude..) (or with new syntax, Prelude.(.))
04:37:54 <funfunctor> merijn: thx! yea I can never get if and guards to behave right whenever I touch them.. compiler needs better diagnostics, my eyes are shit
04:38:32 <dramforever> funfunctor: ghc produces pretty good diagnostics when a type error happens
04:38:41 <dramforever> but not when a parse error happens
04:39:12 <funfunctor> dramforever: yea I was referring to purely lexical syntax here.
04:39:15 <init> I'd use more pattern matching
04:42:05 <merijn> It's the price we pay for haskell's flexible layout/syntax
04:42:51 <funfunctor> merijn: indeed
04:44:57 <mabino-pyon> Is it possible to use Template Haskell to embed (parts of) the syntax of a different programming language into Haskell? (e.g., the syntax of a programming language I am implementing in Haskell)
04:44:57 <mabino-pyon>  
04:44:58 <mabino-pyon>  
04:48:02 <mabino-pyon> e.g., when typechecking this other language, I would much rather generate <type>Foo Bar</type>, rather than "Type.Apply (Type.Identifier "Foo") (Type.Identifier "Bar")
04:48:11 <merijn> mabino-pyon: QuasiQuoter can run arbitrary parsers at compile time and return haskell
04:48:23 <merijn> So, yes
04:48:29 <mabino-pyon> Cool!
04:49:21 <lpaste> funfunctor pasted “No title” at http://lpaste.net/120840
04:49:55 <funfunctor> merijn: can you think of a typeclass lines 414.. could be a instance of?
04:49:58 <merijn> funfunctor: Why aren't you deriving Enum for TypeOfNumber?
04:50:25 <funfunctor> merijn: ah, because the values will be custom..
04:50:52 <merijn> I don't think Time should be an instance of Num
04:51:02 <merijn> What would "time * time" be?
04:51:11 <dramforever> funfunctor: I'm actually not very sure that you should have instance Enum TypeOfNumber
04:51:50 <dramforever> are you going to be using stuff like "succ", "pred"?
04:52:02 <ab9rf> ineed, why make that an enum?
04:52:03 <funfunctor> possibly
04:52:31 <funfunctor> not overly concerned with that at the moment..
04:52:44 <ab9rf> merijn: you need to be able to multiple time, otherwise you won't be able to derive timecube and understand the fourfold truth of the universe
04:52:53 <merijn> funfunctor: Also why not: http://lpaste.net/120841 ?
04:53:06 <funfunctor> this code just supports something much larger so I am just trying to rush though it a bit otherwise none of this project will be done
04:53:32 <duga> hi, is there any simple way to trace particular function args -> result with minimum code changes?
04:53:41 <funfunctor> merijn: sure it could be a case instead of a guard yea
04:53:42 <merijn> duga: For debugging, you mean?
04:53:47 <duga> merijn: sure
04:54:01 <duga> in order prints entering -> leaving
04:54:13 <dramforever> funfunctor: did you know you could to func1, func2, func3 :: SameType at the top level?
04:54:16 <merijn> duga: Look at Debug.Trace (insert "horrifically unsafe for production code" warning here)
04:54:28 <ab9rf> duga: lazy evaluation makes that a bit strange :)
04:54:29 <funfunctor> dramforever: I do yes
04:54:48 <ab9rf> debug.trace will print things but understanding what is going on may prove challenging :)
04:54:54 <duga> merijn: yes I use it currently but for entering only
04:55:03 <duga> but I cannot hook trace to the function exiting
04:55:08 <merijn> duga: Ah, I see the problem :)
04:55:11 <dramforever> funfunctor: it seems that you could merge those type sigs of "Standard derivations"
04:55:15 <funfunctor> dramforever: some stuff is written like that to remind me to revist the types..
04:55:22 <merijn> duga: That's because there's not really a notion of "exiting a function" in haskell
04:55:27 <dramforever> duga: I function exit?
04:55:32 <dramforever> A function exit?
04:55:33 <merijn> duga: When would a function be exited?
04:55:45 <duga> merijn: when  the function returns a result
04:55:48 <merijn> dramforever: Like in C/python when you return and pop a stack frame
04:55:50 <ab9rf> duga: what's a result?
04:56:04 <dramforever> duga: We mean, what's *a* result
04:56:13 <izohask> I'm reading the definition for traverse_ in Foldable
04:56:14 <merijn> duga: But due laziness there's no guarantee when that is and it could be that only part of the result is ever forced
04:56:21 <izohask> it says "Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results."
04:56:23 <duga> hmm
04:56:26 <dramforever> what's the "a result" of (repeat 1)?
04:56:32 <izohask> what is example of applicative action ?
04:56:53 <dramforever> izohask: IO is an applicative
04:57:05 <izohask> ok , but out of IO ?
04:57:19 <izohask> is there any other action widely used, except IO action ?
04:57:23 <dramforever> Parser? e.g. from parsec
04:57:28 <drewbert> Hello!  I am trying to cabal install a package, and it is saying "Could not resolve dependencies... next goal: ghc"  I used the ghc download from the ghc website and compiled it on this machine, but I am not using the haskell platform.
04:57:30 <merijn> > let apply f (x, y) = (f x, f y) in snd (apply (+1) (1, 2))
04:57:32 <lambdabot>  3
04:57:33 <duga> merijn: ok, currently i make horrible tons of codes and for every func definition
04:57:39 <merijn> duga: When does apply/f return?
04:57:43 <dramforever> every monad is an applicative
04:57:46 <duga> I do wrap let comp in trace result
04:57:54 <duga> but it is insane
04:57:55 <izohask> or I can consider "evaluate action" == "invoke IO action" , usually ?
04:57:59 <dramforever> merijn: ha idea: \
04:58:19 <dramforever> trace "blah" () `seq` thisIsTheSoCalledAResult
04:58:49 <merijn> izohask: Either is an Applicative, so are: some tuples, Identity, parsers, binary decoders, functions and Maybe, none of those involve IO
04:58:53 <dramforever> oh maybe that's no better
04:58:56 <shiona> what was the syntax for functions to "unpack" all fields from a record?
04:59:11 <dramforever> Constructor{..}, but IIRC you need an extension
04:59:12 <phaazon> oh, I think I've found a way to represent events in netwire merijn
04:59:19 <phaazon> instead of passing them as input to the main wire
04:59:25 <izohask> merijn: OK, but what is the benefit of invoking Maybe action, and ignoring it's result ?
04:59:27 <dramforever> shiona: ^ Constructor{..}
04:59:31 <phaazon> I poll them before, and inject them in a Reader
04:59:32 <shiona> dramforever: thanks, linter will tell me which extension it is
04:59:39 <merijn> izohask: Short-circuiting if it's Nothing
04:59:41 <phaazon> so that all wires can access the event streamç
04:59:50 <dramforever> shiona: ghc itself might
04:59:56 <phaazon> and writing wires like leftPressed is then straight-forward :)
05:00:04 <shiona> RecordWildCards it seems
05:00:17 <phaazon> since my application pools all events, renders, and loops that way
05:00:19 <HeladoDeBrownie> shiona, in general you can just use a feature and ghc gives you an error telling you what you need to enable
05:00:19 <dramforever> izohask: no use
05:00:21 <phaazon> I think it's convenient
05:00:32 <drewbert> I have definitely spend more time fighting cabal than I have writing haskell at this point.
05:00:40 <shiona> HeladoDeBrownie: seems that's what I've been using
05:00:58 <izohask> so why traverse_ invokes all the actions , ignoring the result ? Where can this be used, beside with  IO actions ?
05:01:02 <HeladoDeBrownie> shiona, yes, RecordWildCards sounds like what you were asking for
05:01:17 <dramforever> izohask: Writer
05:01:22 <HeladoDeBrownie> izohask, State
05:01:31 <dramforever> BlahT IO
05:01:41 <merijn> Parser
05:01:44 <merijn> Maybe
05:01:47 <merijn> etc.
05:01:52 <dramforever> oh
05:01:56 <HeladoDeBrownie> many examples :)
05:01:58 <dramforever> Just () is different from Nothing
05:02:11 <init> Just () is True, Nothing is False
05:02:14 <dcoutts> drewbert: did you post the log of the solver error? if not, do so with -v3 --max-backjumps=-1
05:02:15 <dramforever> but that's...hardly useful, actually
05:02:23 <izohask> dramforever: Writer, you mean like "tell" - changing Monoid at not touching the other one ?
05:02:27 <dramforever> I mean, much less than the rest
05:02:40 <dramforever> merijn: traverse with Parser? no way
05:02:46 <HeladoDeBrownie> "execute all actions and ignore the result" sounds useful for Maybe to me, it sounds like you're saying it isn't
05:02:58 <dramforever> HeladoDeBrownie: it's less useful
05:03:04 <HeladoDeBrownie> dramforever, granted
05:03:06 <izohask> HeladoDeBrownie: I do not understand why it is usefull ?
05:03:07 <dramforever> than IO, obviously
05:03:21 <dramforever> izohask: basically, anything that has sequencing
05:03:21 <izohask> (other then IO, this is obviuously, I agree)
05:03:23 <HeladoDeBrownie> izohask, say you just wanted to know everything was Just
05:04:00 <dramforever> HeladoDeBrownie: hey, it's *traverse*, okay?
05:04:30 <dramforever> I don't really think that you *just* want to know everything was Just
05:05:18 <init> a silly example, you've a list of data from the user, [Just ("name", "someone"), Nothing, ...] where Nothing represents that it didn't pass validation or some check, so you use traverse_ to find if _all_ values passed it
05:05:32 <frerich> If I wanted to know whether all elements in a list are 'Just', I'd probably prefer 'all isJust'.
05:06:13 <funfunctor> :t succ
05:06:14 <lambdabot> Enum a => a -> a
05:06:40 <HeladoDeBrownie> dramforever, *shrug* we've established it's less useful, but it still contains information.
05:06:58 <funfunctor> hi frerich
05:07:04 <dramforever> okay
05:07:08 <frerich> funfunctor : elleuh
05:07:15 * dramforever almost typed "play"
05:07:27 <funfunctor> frerich: that bladerf binding btw is out of date, there is more code locally to push if you are interested?
05:08:06 <frerich> funfunctor: I don't really have time right now to browse the code, sorry - but if you have some specific question I can have a look.
05:08:11 <drewbert>  dcoutts: ... is this command going to run forever with those flags? It's going to be megabytes at least at this point.
05:08:51 <funfunctor> sure, thx
05:21:33 <wz1000> Can ghci infer types of rank > 1?
05:21:47 <merijn> No
05:21:51 <merijn> Neither can GHC
05:22:02 <merijn> Because RankNType inference is undecidable
05:22:26 <merijn> (and we like our type checker to terminate :p)
05:22:43 <ab9rf> how silly, insisting that your compiler actually terminate
05:23:36 <init> it can infer some rankntypes with the help of a few type signatures or so, can't it?
05:24:06 <ab9rf> init: there's a paper from SPJ and others on the topic :)
05:24:19 <ab9rf> probablyu more than one, knowing SPJ
05:24:32 <bennofs> ab9rf: you can actually make GHC's inliner loop in rare cases
05:24:40 <ab9rf> bennofs: i'd heard that
05:25:44 <wz1000> Would type would x have to be for 'x x' to typecheck? It works for (x :: forall a. a -> a).
05:27:30 <merijn> That produces an infinite type, which are not allowed in Haskell. You can fake them using newtypes
05:28:03 <ab9rf> you never get to the turtles
05:29:02 <wz1000> merijn: It works for some types, like (forall a. a -> a). I would like to know what other types would it typecheck for.
05:29:37 <dcoutts> drewbert: the tail end may be enough. It's likely something simple like the package needs a different version of ghc than the one you've got, or alternatively that you've broken the ghc api library package that you've got installed.
05:29:43 <wz1000> :t fmap fmap
05:29:44 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
05:29:50 <dcoutts> drewbert: but we'd need to look at something to work out what's up
05:29:50 <wz1000> :t id id
05:29:52 <lambdabot> a -> a
05:31:36 <drewbert> dcoutts: http://dpaste.com/06A980R
05:32:25 <ab9rf> is there a value of forall a. a -> a that isn't id?
05:33:48 <wz1000> ab9rf: No non _|_ value
05:34:59 <xnil____3> is there a way to make a function run when your program exits?
05:35:03 <HeladoDeBrownie> parametricity! do you speak it??
05:35:10 <xnil____3> say my function has type :: IO ()
05:35:10 <HeladoDeBrownie> extra question mark was unintentional but works
05:36:35 <wz1000> xnil____3: main = stuff_you_want_to_do >> exit_function
05:36:53 <xnil____3> wz1000: but does it work when you ctrl-c out?
05:37:15 <HeladoDeBrownie> xnil____3, finally
05:37:17 <HeladoDeBrownie> @type finally
05:37:18 <lambdabot> IO a -> IO b -> IO a
05:37:31 <HeladoDeBrownie> http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Exception-Base.html#v:finally
05:37:57 <ab9rf> does finally catch sigint?
05:38:09 <HeladoDeBrownie> not sure, easy to check
05:38:23 <ab9rf> i have no idea how haskell interacts with the signal system
05:38:55 <merijn> ab9rf: You can register handlers just like in C
05:38:55 <wz1000> xnil____3: https://downloads.haskell.org/~ghc/7.0.3/docs/html/libraries/unix-2.4.2.0/System-Posix-Signals.html
05:39:24 <merijn> ab9rf: And there's only 3 possible implementations of "forall a. a -> a", so there's 2 non "id" ones
05:39:40 <merijn> ab9rf: "undefined" and "const undefined" to be exact
05:39:40 * hackagebot html5-entity 0.1.0.2 - A library for looking up and validating HTML5 entities.  http://hackage.haskell.org/package/html5-entity-0.1.0.2 (zudov)
05:39:54 <ab9rf> sigint should raise UserInterrupt
05:40:03 <ab9rf> merijn: ah
05:40:16 <merijn> See also "Fast and Loose Reasoning is Morally Correct"
05:40:44 <wz1000> merijn: "undefined" and "const undefined" differ only under seq, right?
05:44:30 <funfunctor> is there a short syntax for updating one of the fields of data ?
05:45:00 <merijn> wz1000: Yes
05:45:07 <merijn> wz1000: Well...
05:45:18 <funfunctor> i.e. data Time = Time { foo :: Int, bar :: Int }   with a function inc :: Time -> Time which increments only the first field foo
05:46:02 <merijn> wz1000: The Fast and Loose paper I just mentioned argues that "it's essentially ok to pretend haskell is a total language when reasoning about parametricity"
05:46:53 <uberwach> does somebody have a recommendation of a purescript project that is "worth being read and understood"?
05:47:07 <frerich> funfunctor: 'inc (Time foo bar) = Time (f foo) bar' wouldn't be too bad, I guess?
05:47:46 <frerich> funfunctor: FWIW, if you find that you often have to access record fields I can recommend having a look at 'fclabels' (I like to call it 'lenses for the rest of us' ;-).
05:49:41 * hackagebot cpphs 1.18.9 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.18.9 (MalcolmWallace)
05:50:13 <funfunctor> frerich: well I know the accessors for data but I don't know all this lens stuff is for exactly?
05:52:54 <ab9rf> merijn: i won't even pretend to understand that paper
05:54:52 <merijn> ab9rf: The basic argument is: "Any reasoning that applies to a total subset of haskell applies to all haskell functions that don't explicitly involve bottoms, and since people expect bottoms to behave weird anyway it still provides you useful accurate reasoning for most of your program"
05:55:18 <ab9rf> merijn: i got that from the abstract.  the paper itself is way over my head.
05:55:29 <merijn> I can't honestly say I've read it anyway :p
05:55:45 <ab9rf> there were a few lines in the abstract that caused brainlash
05:56:08 <ab9rf> specifically, "It is also shown that the PER gives rise to a bicartesian closed category which can be used to reason about values in the domain of the relation."
06:00:04 <xnil____3> is there an equivalent of racket's `cond' in Haskell?
06:00:16 <xnil____3> essentially a multi-clause if-then-else
06:00:35 <etandel> ? like case?
06:00:40 <bennofs> xnil____3: you can write that with guards
06:01:11 <xnil____3> :s
06:01:18 <bennofs> > let f x | x == 3 = 4 | x == 4 = 5 | x == 6 = 2 | otherwise = 3 in f 3
06:01:20 <lambdabot>  4
06:01:23 <xnil____3> can i do guards in a ...
06:01:35 <xnil____3> hrm
06:01:42 <xnil____3> alrighty then
06:01:43 <mauke\> xnil____3: case () of _ | cond1 -> stuff | cond2 -> otherstuff
06:01:54 <bennofs> mauke\: ... of is core
06:01:57 <xnil____3> mauke\: guards suit my need better
06:02:00 <bennofs> mauke\: ah, oops
06:02:03 <mauke\> those are guards
06:02:11 <xnil____3> oof
06:02:25 <xnil____3> that's ugly
06:02:57 <bennofs> xnil____3: you can also define a variable using guards in a where clause
06:03:15 <xnil____3> > let cond = case () of _ in cond | True -> "poop" | other -> "crap"
06:03:16 <lambdabot>  <hint>:1:25: parse error on input ‘in’
06:03:29 <xnil____3> > let cond = (case () of _) in cond | True -> "poop" | other -> "crap"
06:03:31 <lambdabot>  <hint>:1:25: parse error on input ‘)’
06:03:32 <bennofs> > let y = 4; x | y == 3 = 4 | y == 4 = 5 | y == 6 = 2 | otherwise = 3 in x
06:03:33 <lambdabot>  5
06:03:40 <bennofs> (also works in where)
06:03:56 <xnil____3> yeah
06:04:12 <xnil____3> i like the let version better
06:04:21 <mauke\> :t find fst
06:04:22 <lambdabot> [(Bool, b)] -> Maybe (Bool, b)
06:04:42 * hackagebot wl-pprint-ansiterm 0.1.0.0 - ANSI Terminal support with wl-pprint-extras  http://hackage.haskell.org/package/wl-pprint-ansiterm-0.1.0.0 (seagull)
06:04:44 <mauke\> :t fmap snd . find fst
06:04:45 <lambdabot> [(Bool, b)] -> Maybe b
06:05:08 <xnil____3> :t (\x -> fromMaybe x $ find fst x)
06:05:09 <lambdabot>     Couldn't match expected type ‘[(Bool, b)]’
06:05:09 <lambdabot>                 with actual type ‘(Bool, b)’
06:05:09 <lambdabot>     Relevant bindings include
06:05:34 <xnil____3> :t (\x -> fromMaybe x $ [find fst x])
06:05:35 <lambdabot>     Couldn't match expected type ‘Maybe [(Bool, b)]’
06:05:35 <lambdabot>                 with actual type ‘[Maybe (Bool, b)]’
06:05:35 <lambdabot>     Relevant bindings include
06:05:48 <xnil____3> lolk
06:05:58 <xnil____3> :t (\x -> fromMaybe x $ find [fst x])
06:05:59 <lambdabot>     Couldn't match expected type ‘Maybe (t, b)’
06:05:59 <lambdabot>                 with actual type ‘[a0] -> Maybe a0’
06:05:59 <lambdabot>     Relevant bindings include x :: (t, b) (bound at <interactive>:1:3)
06:06:19 <init> xnil____3: x has type [(Bool,a)] and find Maybe (Bool,a), fromMaybe tries to unify (Bool,a) (from the maybe) with [(Bool,a)]
06:06:25 <xnil____3> ik
06:06:55 <init> @type (\x -> fromMaybe x . fmap (:[]) . find fst $ x)
06:06:56 <lambdabot> [(Bool, b)] -> [(Bool, b)]
06:07:49 <xnil____3> @type (\x -> fromMaybe x . fmap (:[]) . find fst . x)
06:07:50 <lambdabot>     Couldn't match expected type ‘a -> [(Bool, b)]’
06:07:50 <lambdabot>                 with actual type ‘[(Bool, b)]’
06:07:50 <lambdabot>     Relevant bindings include
06:12:20 <bitonic> is there a way to link to a section in Haddock?
06:13:54 <lpaste> funfunctor pasted “No title” at http://lpaste.net/120845
06:14:34 <funfunctor> how have I screwed up the syntax of this if stmt? why do these bloody if stmt's never work for me
06:15:14 <mauke\> haskell has no if statements
06:15:21 <EvanR> funfunctor: then and else have to be intended more than the if
06:15:35 <mauke\> no, they don't
06:15:56 <funfunctor> I believe the indent is fine
06:16:08 <EvanR> rrro, well you dont have an else in one of them
06:16:16 <ab9rf> else is required
06:16:29 <clrnd> otherwise it returns null
06:16:30 <ab9rf> and the values in the then and else have to be of the same type :)
06:16:45 <EvanR> :t null
06:16:46 <lambdabot> [a] -> Bool
06:16:56 <clrnd> undefined then
06:16:59 <clrnd> :t undefined
06:17:00 <lambdabot> a
06:17:05 <EvanR> otherwise it doesnt compile
06:17:07 <clrnd> what is this, #js ?
06:17:58 * EvanR adds "doesnt compile" to the semantic domain of all types
06:18:08 <funfunctor> ab9rf: well I commented out the second if and it still complains
06:18:19 <ab9rf> heh
06:18:28 <funfunctor> how can I rewrite this to be not so imperative
06:18:32 <EvanR> funfunctor: theres two places, at least, where you didnt use an else
06:18:54 <funfunctor> EvanR: I know
06:19:09 <funfunctor> EvanR: I commented out line 20
06:19:14 <Procian> Ohh..."The function 'k' is applied to two arguments, but its type 'Ctx -> Ctx -> r" has only two."
06:19:16 <EvanR> so you need to decide what the value will be
06:19:34 <nshepperd_> you can't define variables conditionally like that
06:20:33 <lpaste> mauke annotated “No title” with “No title (annotation)” at http://lpaste.net/120845#a120848
06:20:55 <mauke\> funfunctor: ^ untested, not very pretty
06:21:55 <funfunctor> mauke\: looks much better thx!
06:32:54 <lpaste> narendraj9 pasted “No title” at http://lpaste.net/120850
06:49:44 * hackagebot wl-pprint-ansiterm 0.1.0.1 - ANSI Terminal support with wl-pprint-extras  http://hackage.haskell.org/package/wl-pprint-ansiterm-0.1.0.1 (seagull)
06:54:44 * hackagebot hemokit 0.6.5 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.6.5 (NiklasHambuechen)
07:05:45 <cko> Hey - question: in LYAH they define a function (-:) :: a -> (a -> b) -> b
07:05:53 <cko> where x -: f = f x
07:06:07 <mpickering> :t (&)
07:06:08 <lambdabot> a -> (a -> b) -> b
07:06:09 <cko> that almost seems like (.) backwards
07:06:20 <xnil___> :t (.)
07:06:20 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:06:22 <mauke\> no, ($)
07:06:26 <xnil___> :t ($)
07:06:26 <lambdabot> (a -> b) -> a -> b
07:06:30 <xnil___> wowee
07:06:41 <mauke\> :t flip id
07:06:42 <lambdabot> b -> (b -> c) -> c
07:06:46 <mauke\> :3
07:07:05 <cko> ah
07:07:36 <mauke\> @djinn a -> (a -> b) -> b
07:07:36 <lambdabot> f a b = b a
07:09:23 <ab9rf> flip id
07:09:35 <ab9rf> should just call that flid
07:10:02 <cko> flip id is sexier, i guess
07:10:11 <cko> i mean x -: f = f x looks clearer
07:10:19 <cko> than (-:) = flip id
07:10:27 <ab9rf> besides, it looks like a smiley
07:10:29 <cko> at least, to a beginner
07:10:59 <ab9rf> pointfree code is often harder to understand
07:11:43 <cko> in Clojure there's this ->> macro
07:11:50 <cko> so i'm trying to find a similar one in haskell
07:12:00 <cko> where you chain things from left to right
07:12:13 <cko> it seems like (.) is chaining from right to left
07:12:31 <xnil___> :t -:
07:12:32 <lambdabot> parse error on input ‘-:’
07:12:37 <xnil___> :t (-:)
07:12:38 <lambdabot>     Not in scope: ‘-:’
07:12:38 <lambdabot>     Perhaps you meant one of these:
07:12:38 <lambdabot>       ‘-’ (imported from Prelude), ‘>:’ (line 159),
07:12:42 <mauke\> :t (>>>)
07:12:43 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
07:13:00 <cko> where do i import the (>>>)
07:13:07 <ab9rf> @hoogle (>>>)
07:13:09 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
07:13:09 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
07:13:12 <mauke\> > (sqrt >>> show) 2
07:13:14 <lambdabot>  "1.4142135623730951"
07:13:32 <mauke\> > 2 & show.sqrt
07:13:34 <lambdabot>  "1.4142135623730951"
07:13:49 <jml> oh huh
07:13:55 <jml> I ended up finding http://hackage.haskell.org/package/parallel-3.2.0.6/docs/Control-Parallel-Strategies.html#v:-45--124-
07:13:57 <ab9rf> show the squirt!
07:13:59 <jml> but not (>>>)
07:14:03 <cko> @hoogle (&)
07:14:03 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
07:14:03 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
07:14:03 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
07:14:24 <mauke\> it's in lens
07:14:42 <ab9rf> everything is in lens
07:15:02 <cko> yeah.. lens... didn't get there yet :)
07:15:03 <bennofs> and soon in Data.Function
07:16:06 <jml> problem is then you need a flipped <$> and <*>
07:17:02 <mauke\> :t (<&>)
07:17:04 <lambdabot> Functor f => f a -> (a -> b) -> f b
07:17:12 <mauke\> :t (<**>)
07:17:13 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
07:17:24 <ab9rf> heh
07:17:53 <ab9rf> before long eevery conceivable sequence of punctutation 5 characeters or shorter will be a standard haskell opreator
07:17:59 <cko> @hoogle (<&>)
07:18:00 <lambdabot> No results found
07:18:17 <bennofs> cko: Control.Lens :
07:18:22 <bennofs> :)
07:18:27 <ab9rf> hoogle doesn't have lens, iirc
07:18:39 <cko> do i have to cabal install it
07:19:13 <cko> eh i'll figure it out
07:20:10 <mpickering> although I wouldn't install lens just for that operator
07:20:27 <mpickering> you're better off just defining it yourself for a toy project
07:20:41 <cko> yea
07:29:46 <foozer> hi
07:30:02 <foozer> I'm looking for a version of replicate that would give me an infinite list
07:30:09 <bennofs> :t iterate
07:30:09 <foozer> e.g. replicate 2 [1,2]
07:30:10 <lambdabot> (a -> a) -> a -> [a]
07:30:18 <bennofs> :t cycle
07:30:19 <lambdabot> [a] -> [a]
07:30:28 <bennofs> > cycle [1,2]
07:30:29 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
07:30:47 <foozer> cycle!
07:30:51 <ab9rf> i used cycle to implement fizzbuzz the other day :)
07:30:51 <foozer> thank you!
07:31:20 <bennofs> > repeat [1,2]
07:31:22 <lambdabot>  [[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,...
07:33:07 <foozer> what's the difference between repeat and cycle?
07:33:13 <foozer> they seem to be doing the same
07:33:16 <hannes__> hi, was there some kind of way to have 'multi kinded classes'?
07:33:19 <bennofs> > repeat [1,2]
07:33:20 <lambdabot>  [[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,...
07:33:22 <bennofs> > cycle [1,2]
07:33:24 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
07:33:38 <bennofs> see the difference? repeat x = cycle [x]
07:33:46 <bennofs> > cycle [[1,2]]
07:33:48 <lambdabot>  [[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,2],[1,...
07:34:08 <gcganley> i go away for 2 seconds and this is what happens to lambdabot
07:34:27 <foozer> yes, I saw that
07:34:27 <ab9rf> haha
07:34:42 <foozer> so they are 'more or less' the same function
07:34:44 <ab9rf> you can;'t quickcheck that repeat x == cycle [x] :)
07:34:50 <hannes__> foozer: Well no... they're not
07:34:53 <foozer> i.e. one can trivially be defined in terms of the other
07:34:57 <ab9rf> foozer: yes
07:34:58 <bennofs> foozer: yes, I think repeat can be made more efficient
07:35:00 <ab9rf> @src repeat
07:35:00 <lambdabot> repeat x = xs where xs = x : xs
07:35:02 <ab9rf> @src cycle
07:35:02 <lambdabot> cycle [] = undefined
07:35:02 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
07:35:16 <foozer> oh, so repeat is lazy while cycle is not?
07:35:24 <merijn> foozer: They're both lazy
07:35:30 <ab9rf> both are lazy
07:35:38 <merijn> Everything is lazy, unless otherwise specified...
07:35:40 <Fusebox> do you guys generally choose $ or brackets for function composition?
07:35:45 <hannes__> foozer: - can be trivially defined in terms of +. Does that you don't want - anymore?
07:35:45 <ab9rf> Fusebox: yes
07:35:51 <merijn> Fusebox: Neither, I use .
07:35:54 <bennofs> Fusebox: I use f . g . y $ x
07:36:04 <ab9rf> Fusebox: i am not consistent.
07:36:14 <ab9rf> Fusebox: i use whichever seems to most clearly express narrative intent
07:36:26 <merijn> . has the advantage that any subexpression can be split off into a local definition without issue
07:36:36 <merijn> Whereas with $ this is not always possible
07:36:36 <xnil___> yeah, bennofs' solution looks best to me
07:36:47 <merijn> At least not without rewriting part of the original composition
07:36:50 <Fusebox> how could i write this to use dot notation: printPicture (beside horsePicture (reverse horsePicture)))
07:36:58 <merijn> Therefore . should be prefered where possible
07:37:14 <xnil___> printPicture . beside horsePicture . reverse $ horsePicture
07:37:16 <bennofs> Fusebox: printPicture . beside horsePicture . reverse $ horsePicture
07:37:22 <merijn> "printPicture . beside horsePicture . reverse $ horsePicture
07:37:24 <Fusebox> thanks!
07:37:37 <xnil___> why no lambda tho
07:37:39 <Rotaerk> reverse $ cowgirl?
07:37:40 <merijn> At least everyone agrees :>
07:37:49 <ab9rf> you could use a lambda to deal with the duplication of horsePicture
07:37:56 <ab9rf> or some ugly pointfree thing
07:37:59 <Fusebox> can you provide an example?
07:38:06 <xnil___> (\pic -> printPicture . beside x . reverse $ x) horsePicture
07:38:09 <xnil___> err
07:38:15 <xnil___> (\pic -> printPicture . beside pic . reverse $ pic) horsePicture
07:38:16 <bennofs> "fmap printPicture . beside <*> reverse"
07:38:25 <xnil___> that works too
07:38:35 <mauke\> (printPicture . beside pic . reverse) horsePicture
07:38:45 <ab9rf> mauke\: free pic
07:38:46 <hannes__> hm... printPicture . reverse >>= beside $ horsePicture?
07:38:50 <hannes__> didn't check though
07:38:59 <bennofs> hannes__: "fmap printPicture . beside <*> reverse"
07:39:10 <mauke\> :-(
07:39:19 * xnil___ is confused by all the not-his solutions
07:39:20 <merijn> xnil___: How is that any better?
07:39:27 <xnil___> i don't think mauke\'s works
07:39:32 <xnil___> merijn: you can use different pictures with it
07:39:40 <Fusebox> how is using an anonymous function better?
07:39:51 <merijn> xnil___: So then put it in a local definition
07:39:54 <xnil___> abstraction
07:39:57 <xnil___> yes
07:40:11 <Fusebox> ok, one reference to the pic instead of duplicate references you'd need to find and change
07:40:13 <merijn> xnil___: An anonymous function isn't better because you can't reuse those out of context
07:40:23 <mauke\> printPicture . ap beside reverse?
07:40:28 <xnil___> right but i'm just giving an example of something he could do
07:40:30 <merijn> So it's the worst of both worlds...
07:40:34 <xnil___> sure, he could say
07:40:44 <ab9rf> i tend to use <$> instead of fmap
07:40:58 <Fusebox> is <$> a synonym for fmap?
07:41:01 <merijn> "let compare pic = printPicture . beside pic . reverse $ pic in compare horsePicture"
07:41:02 <hannes__> Fusebox: yes
07:41:04 <merijn> Fusebox: Yes
07:41:10 <xnil___> printBesideReverse pic = printPicture . beside pic . reverse $ pic
07:41:12 <merijn> :t (<$>)
07:41:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:41:13 <ab9rf> <$> and `fmap` are exactly the same
07:41:17 <merijn> :t fmap
07:41:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:41:19 <xnil___> printBesideReverse horsePicture
07:41:25 <hannes__> It's from Control.Applicative though, not in prelude
07:41:32 <Fusebox> ta
07:41:33 <hannes__> it might be in GHC 7.10 though... let me check
07:41:35 <xnil___> :t fmap
07:41:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:41:45 <ab9rf> xnil___: just eta-reduce that and remove piuc
07:41:46 <ab9rf> pic
07:41:56 <xnil___> eta-reduce?
07:42:09 <ab9rf> that's where the <*> and <$>/fmap come in
07:42:17 <xnil___> :t (<*>)
07:42:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:43:05 <Fusebox> This is a bit to absorb. I'll copy this chat to a test file and re-read later.
07:43:08 <hannes__> :t (>>=) :: (a -> a) -> (a -> a -> a) -> a -> a
07:43:09 <lambdabot> (a -> a) -> (a -> a -> a) -> a -> a
07:43:16 <ab9rf> Fusebox: abstraction rocks
07:43:19 <merijn> ab9rf: You can't
07:43:37 <ab9rf> merijn: not as he ahd it, no
07:43:53 <merijn> ab9rf: The fmap examples are all worse
07:43:53 <Fusebox> what is <*> synonymous for?
07:43:59 <xnil___> ^
07:44:02 <merijn> Fusebox: Nothing, it's a function in Applicative
07:44:02 <ab9rf> hlint constantly yells at me to eta-reduce stuff :)
07:44:03 <hannes__> Fusebox: Nothing, that's the actual thing
07:44:19 <hannes__> NotImplemented: Though it behaves like `ap`, except it doesn't require monad
07:44:28 <ab9rf> :t ap
07:44:29 <lambdabot> Monad m => m (a -> b) -> m a -> m b
07:44:37 <hannes__> ohps, didn't mean to write that to NotImplemented
07:44:54 <Fusebox> :t <*>
07:44:55 <lambdabot> parse error on input ‘<*>’
07:44:58 <ab9rf> it's annoying that ap is not in Applicative
07:45:12 <Fusebox> :t (<*>)
07:45:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:45:28 <ab9rf> those are obviously the same signature except for typeclass
07:45:38 <bennofs> Is there some package that implements fusion for some kind of tree?
07:46:38 <hannes__> huh... I just had a funny idea, and it turns out I pretty much implemented EffectT
07:47:49 <xnil___> do any of you ever get the feeling that haskell's typesystem has just created a game of ridiculous productivity loss
07:47:57 <merijn> bennofs: Did you mean "where can I learn more about condensity"?
07:48:13 <merijn> xnil___: No, haskell's typesystem is the biggest contributing factor to my productivity
07:48:26 <ab9rf> xnil___: i spend less time figuring out why my code does stupid things
07:48:28 <merijn> xnil___: To be fair, it took me several months to learn how to get that far :)
07:48:29 <bennofs> merijn: ha, let me lookup codensity
07:48:30 <xnil___> alrighty then, i feel the same way but i can see how one might think the other way
07:48:35 <Fusebox> xnil___, I'm new, but Haskell's type system has opened up my eyes on how to write half of my computations in the type system alone
07:48:37 <ab9rf> xnil___: because haskell's type system doesn't let me write code that does stupid things
07:48:39 <Fusebox> that's crazy powerful
07:48:51 <xnil___> mfw idris
07:48:53 <ab9rf> i still write code that does the wrong things
07:49:01 <ab9rf> but they just wrong, not stupid wrong
07:49:12 <merijn> xnil___: My favourite summary of things was the following
07:49:15 <Fusebox> One day I'll examine Agda, Idris, Coq
07:49:21 <merijn> xnil___: 1) Writing correct programs is hard in all languages
07:49:29 <merijn> 2) Writing incorrect programs is hard in Haskell
07:49:36 <xnil___> lol
07:49:37 <merijn> Therefore everything is hard in Haskell
07:49:40 <ab9rf> heh
07:49:44 <ab9rf> ain't that the truth
07:49:52 <merijn> But, in other languages all the non-hard things are wrong
07:50:02 <xnil___> except python
07:50:07 <ozgura> hi all! does anyone know if there is a way to tell which version of libgmp is installed on a computer, if any?
07:50:11 <ProofTechnique> This might be my new favorite part of the wiki. https://wiki.haskell.org/Category:Idioms
07:50:12 <xnil___> but you're always right on the edge of doing everything wrong
07:50:19 <ab9rf> merijn: i get into that argument with peope who insist that " doing IO in haskell is hard"
07:50:34 <ozgura> I'd like to write a script yo install the correct ghc binary depending on that
07:50:37 <bennofs> merijn: oh right, so if I have a Codensity instead of a Tree, I'll avoid repeated traversal of the tree when using >>= ?
07:50:40 <xnil___> yeah after actually learning how Haskell IO works it's uh
07:50:44 <ab9rf> and i come back with "as opposed to the crazy nonsense you have with exceptions threaded all over your code?"
07:50:48 <xnil___> pretty much the best thing ever
07:50:56 <merijn> bennofs: Codensity is basically generalised CPS transform
07:51:19 <ab9rf> merijn: ok, now i need to look at codensity
07:51:29 <merijn> ab9rf: Lemme see if I can find my "easy" paper
07:51:42 <bennofs> Implemented here: http://hackage.haskell.org/package/kan-extensions-4.2/docs/Control-Monad-Codensity.html
07:51:42 <ab9rf> merijn: it might solve a problem i've been banging my head aagainst for a while
07:52:13 <merijn> http://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf
07:52:18 <ab9rf> the hackage documentation is, shall i say, unhelpful
07:52:34 <merijn> The C newtype introduced in that paper is basically Codensity
07:52:51 <ab9rf> will read later
07:52:55 <merijn> ab9rf: Be prepared to read that paper like 4-5 times before anything makes sense :)
07:52:56 <ab9rf> too tired & cold now
07:53:07 <ab9rf> merijn: i'll print it out and put it in the bathroom :)
07:53:21 <xnil___> hrm, i think haskell has become my favorite general-purpose language, especially for prototyping
07:53:47 <merijn> xnil___: The way I work I tend to write types, etc. first before I start even coding. Using them sort of as my skeleton/handhold when coding, which is why I feel they are more useful than getting in the way
07:53:55 <bennofs> merijn: I assume Church-Encoded free monad from free also works?
07:54:08 <merijn> bennofs: Maybe? I dunno? :D
07:54:15 <ab9rf> i'm using a CPS approach to implement a stateful lexer but i'm not entirely happy with it right nwo
07:54:33 <merijn> ab9rf: The whole kan-extension things is still one big confusion to me, though
07:54:38 <ab9rf> it works ok but it feels clunky
07:54:43 <Fusebox> is there a function to concatenate the contents of a tuple into a list?
07:54:48 <ab9rf> and i think i'm missing a key insight that woud make it less clunky
07:54:56 <Fusebox> for pairs at least
07:54:58 <bennofs> ab9rf: maybe http://comonad.com/reader/2011/free-monads-for-less/ is also helpful
07:55:10 <Fusebox> otherwise i can code one, no biggie
07:55:12 <ab9rf> bennofs: noted
07:55:18 <merijn> Fusebox: That sound's like it's below the Fairbairn threshold :)
07:55:18 <ab9rf> Fusebox: just write it :)
07:55:34 <ab9rf> Fusebox: no harm in reinventiung the wheel
07:56:19 <ab9rf> merijn: i saw "Kan extension" and Ran in the hackage docs and it's "well, more stuff i have no concept of"
07:56:28 <ab9rf> i still don't get kleisi
07:56:34 <ab9rf> er, kleisli
07:56:36 <ab9rf> can't even spell it
07:56:48 <merijn> Kleisli is easy! :)
07:57:02 <merijn> "newtype Kleisli m a b = Kleisli (a -> m b)" <- done
07:57:06 <ab9rf> i'm sure it is
07:57:12 <dulla> damn arrows
07:57:17 <ab9rf> but it has yet to osmose into my brainstem yet
07:57:27 <merijn> ab9rf: Do you know the Arrow instance of functions?
07:57:51 <merijn> Like
07:57:53 <merijn> :t (>>>)
07:57:53 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
07:57:55 <ab9rf> merijn: i'm really not looking for a tutorial right now, i'm still decaffeineated.
07:58:09 <merijn> :t (>>>) `asAppliedTo` id
07:58:10 <lambdabot> (a -> a) -> (a -> c) -> a -> c
07:58:37 <merijn> ab9rf: Kleisli is just the Arrow instance of functions where you use >=> (or is it <=<) instead of .
07:58:42 <merijn> :t (>=>)
07:58:42 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:58:50 <merijn> :t (<=<)
07:58:51 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
07:58:52 <merijn> :t (.)
07:58:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:59:10 <ab9rf> merijn: see, that's touching on concepts that still haven't solidified for me internally
07:59:23 <ab9rf> i figure after another couple years of this i might start to understand them :)
07:59:33 <merijn> ab9rf: Don't overthink it :
07:59:35 <merijn> :p
07:59:54 <ab9rf> merijn: i've found that these things are best just poked at repeatedly until they click
08:00:00 <ab9rf> and until they do, just fake it till you make it
08:00:22 <merijn> Type tetris ;)
08:00:35 <ab9rf> some of my early haskell code was like that
08:00:46 <ab9rf> "No, that doesn't compile.  Let's rearrange this a bit."
08:00:55 <ab9rf> "Hm, now THAT is a weird error.  Hm."
08:01:01 <merijn> My modern code is still like that, except my types now have more variables ;)
08:01:10 <merijn> A few more years and I'll end up like edwardk
08:01:34 <ab9rf> it's always fun when you get one of those where it spews three screenfuls of error message for one type inference failure
08:01:51 <merijn> ab9rf: I'm doing C++ template programming now >.>
08:01:55 <ab9rf> merijn: hah
08:01:59 <merijn> I *wish* I got three screenfuls...
08:02:08 <merijn> I get three scrollbackfuls...
08:02:12 <ab9rf> my early adventures in monads were like that
08:02:29 <ab9rf> lots of code that i stole from other places that i did not understand
08:02:38 <ab9rf> but it worked, or seemed to :)
08:02:48 <bennofs> merijn: I think I'll go with encoding my tree as (a -> [(a,e)]) -> a   (where l is leaf type, and a is the node annotation)
08:03:05 <ab9rf> what'e e?
08:03:09 <bennofs> eh, e is the edge type I meant to say
08:03:12 <ab9rf> ah
08:03:13 <bennofs> and l doesn't exist :D
08:03:17 <ab9rf> poor l
08:03:21 <ab9rf> lost in the shuffle
08:03:30 <ab9rf> refactored into oblivion
08:03:58 <ab9rf> bennofs: out-edges?
08:04:20 <ab9rf> i'm not seeing how that gets a tree
08:04:47 * hackagebot th-alpha 0.2.0.2 - Alpha equivalence for TH Exp  http://hackage.haskell.org/package/th-alpha-0.2.0.2 (jkarni)
08:05:08 <dulla> edwardk  ? merijn
08:05:32 <bennofs> ab9rf: You have a root node with annotation a. Now for each member (a',e) of the list f a (where f :: a -> [(a,e)]), there is a child reachable through edge e with annotation a'
08:05:47 <bennofs> ab9rf: I think my original notation was confusing, it was written as function arguments
08:06:03 <bennofs> ab9rf: So a function that takes such a tree would have the type (a -> [(a,e)]) -> a -> ...
08:06:15 <ab9rf> bennofs: i get it now, i think
08:16:12 <ab9rf> merijn: is this a generalization of difference lists?
08:16:40 <ab9rf> the computation-over-free-monad paper you sent me
08:19:49 <aomm> Hello! Looking for a specific monad function, but not sure it exists. I want something like "iterateUntil" (which runs a monadic action indefinitely, until its result satisfies a predicate). However, I want it to send the value to the next execution of itself (rather like concatM). Any tips appreciated!
08:20:32 <aomm> send the value to the next execution of itself, provided that the predicate returns false and it is executed again*, I should say
08:21:11 <bennofs> @hackage monad-loops
08:21:11 <lambdabot> http://hackage.haskell.org/package/monad-loops
08:21:20 <RchrdB> aomm: so something with a signature like ((Monad m) => m a -> (a -> Bool) -> m a) ?
08:21:54 <bennofs> iterateUntilM :: Monad m => (a -> Bool) -> (a -> m a) -> a -> m a
08:21:55 <RchrdB> wait no, more like ((Monad m) => (a -> m a) -> (a -> Bool) -> a -> m a)
08:21:59 <bennofs> @hoogle interateUntilM
08:22:01 <lambdabot> No results found
08:22:06 <bennofs> @hoogle iterateUntilM
08:22:07 <lambdabot> No results found
08:22:19 <bennofs> it is in Control.Monad.Loops from the monad-loops package
08:22:19 <aomm> @hoogle iterateUntil
08:22:20 <lambdabot> No results found
08:22:22 <ab9rf> heh
08:22:52 <aomm> Yes, @RchrdB
08:23:27 <ab9rf> RchrdB: that is essentially the type of iterateUtilM
08:23:37 <RchrdB> Hoogle doesn't find anything because there's nothing fitting that in the standard library.
08:23:39 <ab9rf> you've swapped the first two arguments, but otherwise the same
08:23:46 <RchrdB> but monad-loops, as bennofs points out, has http://hackage.haskell.org/package/monad-loops-0.4.2.1/docs/Control-Monad-Loops.html#v:iterateUntilM
08:23:52 <ab9rf> iterateUntilM :: Monad m => (a -> Bool) -> (a -> m a) -> a -> m a
08:25:22 <aomm> oh, right! haha, I have read the documentation on "iterateUntil" but somehow missed "iterateUntilM". Thanks a lot!
08:39:50 <shock_one> How would I define a custom Show instance for my [SuperClass]. I know I can use newtype, but then I wouldn't be able to, say, map it. Also, orphan instances won't do because instance Show [a] is in prelude.
08:41:15 <ab9rf> why wouldn't you be able to map it?
08:42:46 <ab9rf> use a newtype and make it a Traversable or Foldable instance?
08:45:53 <wz1000> ab9rf: You can use generalised newtype deriving to derive instances of whatever typeclass you want.
08:47:03 <danilo2> Hello All! :) I've got a funny small question here :) Is there ANY possible performance difference between using tuples and nested tuples? I mean (1,2,3) and (1,(2,(3,()))) ?
08:47:49 <bennofs> danilo2: the strictness behaviour is different
08:48:03 <danilo2> bennofs: Hmm, what do you mean ?
08:48:21 <bennofs> danilo2: there are more possible values of the (1,(2,(3,()))) type than of the (1,2,3) type if you include undefined
08:48:47 <bennofs> danilo2: consider (1, undefined). There is no corresponding value for that in the (1,2,3) style
08:49:13 <danilo2> bennofs: right, but If I'm not using undefineds and I know always the types in tuples than is there any difference?
08:49:14 <bennofs> danilo2: so functions working with the second style can possibily be more lazy
08:50:13 <ab9rf> which may either improve or impair performance :)
08:50:15 <danilo2> bennofs: ah, yes - now I understand what you meant. But lets assume I'm generating haskell ode and instead of tupels I'm generating nested tuples and start using them just like tuples before. Should I expect any performance difference? I assume no, but I know I can be siupriised in a moment
08:50:56 <ab9rf> danilo2: you may see differences in performance but predicting what they would be is nontrivial
08:51:02 <bennofs> danilo2: I don't think that there should be performance differences. Maybe you could use tuples that are strict in their second argument, then the types behave exactly the same
08:51:15 <xnil___> how do you call a function with type `String -> IO ()' on each element of a list with type `[String]' and get back a `IO ()'?
08:51:23 <bennofs> xnil___: mapM_
08:51:25 <bennofs> :t mapM_
08:51:26 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
08:51:27 <ab9rf> xnil___: mapM_
08:51:30 <danilo2> bennofs: I was exactly about asking this question!
08:51:53 <bennofs> :t mapM_ `asAppliedTo` putStrLn
08:51:54 <lambdabot> (String -> IO ()) -> [String] -> IO ()
08:52:01 <danilo2> bennofs, ab9rf: ok so there is another one - Why haskell has limit of tuple to 62 elements, when it could under the hood keep everything as nested tuple with second strict arg?
08:52:13 <bennofs> danilo2:
08:52:24 <bennofs> danilo2: probably because nobody bothered to implement it
08:52:34 <bennofs> danilo2: idk
08:52:38 <danilo2> bennofs: hah! :D ok, thank you! :)
08:52:57 <bennofs> danilo2: another idea might be to use boxed vectors
08:53:13 <bennofs> danilo2: that way, you also get O(1) indexing like an n-ary tuple would have
08:53:49 <danilo2> bennofs: yep,. but I need different types here
08:54:01 <bennofs> ah right, tuples can do different types, forgot that
08:54:01 <hannes__> danilo2: And to keep people from writing 63+ tuples
08:54:07 <hannes__> danilo2: Seriously, don't do that
08:54:11 <ab9rf> haskell really would prefer that you not use large tuples :)
08:54:21 <bennofs> hannes__: I think he is not going to write them by hand
08:54:52 <hannes__> bennofs: I don't know if generating them is any better. At some point someone will have to inspect the generated code
08:56:03 <danilo2> hannes__: hehe :D I won't - i'm generating haskell code and that could be strange, but we just hit the limit with one of the very complex usages
08:56:37 <danilo2> ab9rf: hmm, why haskell would not prefer to use large tuples?
08:57:00 <ab9rf> danilo2: they're awkward mostly
08:57:12 <danilo2> ab9rf: I dont care in generated code, should I?
08:57:13 <ab9rf> i don't know how well the compiler copes with them
08:57:19 <ab9rf> but they're ugly and difficult to work with in code
08:57:37 <danilo2> ab9rf: of course :) Don't worry - nobody ever touches the generated one :)
08:58:11 <hannes__> danilo2: Hah, that's what you say _now_. Anyway: Why not just wrap the tuples in more tuples when you hit the limit?
08:58:25 <ab9rf> you can use wrapped tuples indefinitely
08:58:41 <danilo2> hannes__: I told it before your first message :)
08:58:53 <ab9rf> although eventually the compiler will run out of memory representing the type in the type inference engine :)
08:59:00 <danilo2> ab9rf: Yep, I'm moving onto this solution :)
08:59:23 <danilo2> hannes__: I do exactly this. I was just asking about possible performance differences :)
08:59:36 <ab9rf> danilo2: i suspect it'll suck about the same either way :)
09:00:00 <danilo2> oh, I didnt watch the watch. I've got gto go. ab9rf, hannes__, bennofs : thank you very much for the help!! :)
09:00:09 <hannes__> hannes__: Well, you'll have O(n) access now... but with pretty preferable constant factors, so probably not an issue
09:00:14 <ab9rf> still don't understand why youd want to use such large tuples
09:00:39 <hannes__> danilo2: what I wrote before. My brain shortcuts for replies
09:01:32 <ab9rf> if you are slicing the tuples and only using some of the values in the tuple and discarding the rest
09:01:56 <ab9rf> there might be a performance penalty for getting to the ones wrapped further down, but i'm not sure of that actually
09:02:23 <ab9rf> the compiler ought to discard the unused values entirely
09:05:01 <hannes__> ab9rf: I don't think it's likely that it's doing that
09:05:19 <hannes__> depending on what you mean by 'use'
09:06:37 <hannes__> a tuple always has to compile to the same structure, otherwise there will be linking problems with other modules
09:07:07 <benzrf> where is Mu
09:07:20 <benzrf> hmm nvm
09:07:21 <ab9rf> hannes__: even if it's not exported?
09:14:24 <Ainieco> hello
09:14:49 <ab9rf> olleh
09:14:58 <Clint> reverse >>= (==)
09:15:23 <Ainieco> why "f x y = g . h $ Constructor x y" and "f = g . h . Constructor" are not equivalent?
09:15:50 <benzrf> in template haskell is it possible to generate a data decl
09:15:51 <ab9rf> monomorphism restriction?
09:16:03 <bennofs> benzrf: I think it is
09:16:30 <benzrf> ah good
09:16:31 <ReinH> Ainieco: composition works on functions of a single argument.
09:16:45 <ab9rf> ah, yeah
09:17:04 <Ainieco> ReinH: ahh, thanks
09:18:14 <ReinH> You can compose the composition operator with itself to work on two arguments, but I don't think it's worth it
09:18:15 <ab9rf> you need more dots
09:18:20 <ReinH> :t (.).(.)
09:18:21 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:18:29 <Ainieco> ReinH: hm, it doesn't makes sense actually, all functions in haskell are one argument functions
09:18:56 <ab9rf> f = ((g . h) .) . Constructor
09:18:58 <ab9rf> i think
09:19:25 <ReinH> Some people call this (.:) iirc
09:19:46 <bergmark> yep
09:19:49 <ReinH> Ainieco: It's still reasonable to think of a function (a -> b -> c) as taking two arguments.
09:20:18 <bergmark> and yep :)
09:20:21 <Ainieco> ReinH: no, it's not, it's a function of one arg which returns another function of one arg
09:20:22 <bergmark> preach it ReinH
09:20:26 <ReinH> Yes, it is.
09:20:40 <ReinH> It's reasonable to *think of it that way*.
09:21:03 <Ainieco> ReinH: your thinking is wrong
09:21:08 * ReinH sighs
09:21:13 <bergmark> :-D
09:21:37 <ReinH> I disagree.
09:21:47 <ab9rf> i disagree with disagreeing
09:22:23 <ReinH> Ainieco: Are you always this rude to people who are trying to help you?
09:22:29 * bergmark gives ReinH a drink
09:22:51 <ReinH> bergmark: :)
09:23:21 <monochrom> GHC certainly thinks of it that way. its optimizer generates "pass two arguments at once, now call the function" code, not "let's just pass one argument and see what happens" code.
09:23:30 <ReinH> Indeed.
09:23:33 <Ainieco> let f x y = x + y;let g = id.id.f;g 1 2; -- composition works fine on "two arg" functions
09:23:41 <monochrom> it has a full notion of "saturated application"
09:24:04 <Ainieco> so i think it's probably a monomorphism thing, need to check it tho
09:24:14 <ReinH> monochrom: Yes, because id . f = f for all f
09:24:17 <ReinH> er Ainieco ^
09:24:42 <ReinH> It works in that case.
09:25:18 <ReinH> Ainieco: Are you just trying to find ways to prove me wrong for some reason? That's not nice.
09:25:32 <bergmark> wow 1584 people in here, last time i checked it was 1200 i think
09:25:37 <ReinH> bergmark: wow
09:26:35 <ChristianS> we all just came to hear Ainieco troll ReinH !
09:26:50 <ReinH> monochrom: It also applies functions differently depending on whether the application is fully saturated.
09:27:07 <monochrom> yeah
09:27:15 <xnil___> is there a builtin function to find the location of a char inside a string?
09:28:13 <bergmark> :t elemIndex
09:28:15 <lambdabot> Eq a => a -> [a] -> Maybe Int
09:28:21 <lpaste> narendraj9 pasted “No title” at http://lpaste.net/120855
09:29:11 <xnil___> eggcelent
09:40:13 <orion> I have a non-Monadic function which needs to call a function which returns an Either Blah. Does that mean that every single parent function needs to be wrapped in Either as well?
09:40:49 <benzrf> orion: what makes a function monadic...
09:40:59 <benzrf> er, rather
09:41:04 <benzrf> what do you mean by 'non monadic function'
09:43:09 <orion> benzrf: I mean to say a function which returns, say, a ByteString as opposed to a Either ByteString Int, Maybe ByteString, IO ByteString, etc.
09:44:35 <orion> benzrf: I was mistaken in my question: It's a Maybe, not an Either.
09:45:12 <Ainieco> orion: you can unwrap your whatever
09:45:21 <silver> orion, you can deconstruct Either value by pattern matching and "return" value of type Blah
09:45:27 <orion> Ainieco: Using a case expression?
09:45:56 <silver> IO is a special snowflake
09:47:14 <benzrf> orion: how is that fundamentally different
09:47:27 <benzrf> orion: does that mean that "replicate 3" is somehow monadic
09:47:42 <orion> benzrf: I don't understand.
09:47:48 <orion> How is what fundamentally different?
09:47:52 <Ainieco> orion: yup
09:48:18 <Ainieco> orion: using case or something else, just unwrap it and return what's inside
09:49:33 <orion> Ainieco: Ok, that makes sense. Thank you.
09:51:01 <narendraj9> Can I make lpaste.net post the link to a channel different from #haskell?
09:51:23 <silver> by hand, yes, I don't think creators would mind
09:51:43 <narendraj9> silver: I mean automatically. :-D
09:51:52 <silver> :)
09:52:59 <glguy> narendraj9: http://lpaste.net/new/haskell <- change haskell to your channel's name without the hash mark
09:53:15 <glguy> (as long as its one of the supported ones)
09:53:34 <narendraj9> glguy: Oh. It's not. I had checked it.
09:54:07 <NemesisD> i've got a ghci session going and one of the calls I make opens up a file in write mode. if I have to reload my source files, that file stays open and subsequent calls get an error that the file is locked, forcing me to have to restart the session. is there any way around this?
10:02:09 <ab9rf> close the handle?
10:04:26 <ab9rf> i don't think there's any way to force ghci to drop all loose biondings or close any open IO handles
10:08:24 <jedai42> ab9rf: I think ":load" would do the trick
10:09:11 <jedai> ab9rf: Of course you would have to rely on the GC to close handles but that should work in a reasonable amount of time
10:09:16 <ab9rf> jedai: yeah, :load and :reload should do that, but mighjt not
10:09:34 <ab9rf> and he said that he was "reloading source files" so i assumed :reload was being used
10:10:33 <geekosaur> I'd expect :reload to drop all bindings and render the bound values subject to garbage collection; since it does the former, if it isn't also doing the latter, that sounds like a bug
10:10:58 <ab9rf> it might just be that the GC hasn't happened yet for some reason
10:11:47 <geekosaur> System.Mem.performGC ?
10:11:58 <ab9rf> you could try to force a GC
10:13:13 <wayne> what's it called when you're trying to do Z
10:13:15 <jedai> ok, that works
10:13:17 <wayne> but you ask how to do Y
10:13:19 <wayne> because you think Y -> Z?
10:13:31 <jedai> wayne: XYZ problem ?
10:13:40 <jedai> ab9rf: that seems to work
10:13:43 <mwc> Was looking for a solution to a problem I was having and found fingertrees. These are my new favourite Haskell things.
10:13:51 <lachenmayer> X/Y problem is what I've heard it as, wayne
10:14:04 <wayne> okay thanks
10:15:06 <ab9rf> i've seen X/Y problem nentioned in blogs before
10:15:39 <lachenmayer> http://xyproblem.info/ ;)
10:15:41 <jedai> ab9rf: performGC is a consistent way to unlock files. You also can do some allocations, that triggers a GC sooner or later but that's less consistent and convenient
10:16:42 <jedai> geekosaur: It seems it do that but GC isn't triggered immediately which can let some files in a locked statez
10:18:27 <wrengr_away> edwardk: woah woah, what's this about shapr?
10:18:47 <edwardk> wrengr_away: hop on #haskell-ops
10:18:54 <wrengr_away> edwardk: fwiw, that post had nothing to do with haskell, programming, etc...
10:19:24 <jedai> NemesisD: So it appears that :reloading your files should open your handle to garbage collection, in which case they'll be closed automatically. But the GC pass may not happen immediately, so you can force the issue with System.Mem.performGC
10:19:26 <edwardk> wrengr_away: sure. it was being leveraged in that way, but it was taken as intended.
10:20:05 <Ainieco> edwardk: what post?
10:20:21 <wrengr> Ainieco: http://winterkoninkje.dreamwidth.org/101276.html
10:20:26 <Ainieco> wrengr: thanks
10:21:44 <NemesisD> jedai: thanks!
10:22:01 <edwardk> ok, airing this in public: basically we asked a number of folks to stop dragging drama into the channel here, vanila among them, and he kept trying to post links to that post by wren to make it seem like we're silencing the will of the community.
10:22:15 <jedai> NemesisD: geekosaur was the one who spoke of performGC, I merely tested the solution :)
10:22:18 <edwardk> shapr has a fairly no-nonsense approach to things, and kicked him after he did it again after he was asked to stop
10:22:23 <shapr> yup
10:22:26 <edwardk> he did it a couple more times and i kicked him.
10:22:28 <edwardk> nuff said
10:22:30 <NemesisD> geekosaur: thanks as well!
10:22:44 <edwardk> anything further can move to #haskell-ops
10:22:50 <shapr> yes please
10:23:12 <ab9rf> my irc drama quota for the day has been satisfied
10:23:18 <silver> hehe
10:23:26 <shapr> ab9rf: my irc drama quote for the month...
10:23:56 <silver> at least it's not twitter drama this time
10:24:55 * hackagebot handsy 0.0.11 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.11 (utdemir)
10:29:40 <ReinH> edwardk: (vanila is a she)
10:29:52 * shapr shrugs
10:30:16 <edwardk> k
10:30:55 <fredsir> quit
10:31:44 <jfischoff> if I pass both -O0 and -O2 to ghc, does the last flag win?
10:32:23 <Ainieco> i'd like to complain about TH and GHC language(for some reason still known as haskell) everyone and their dog use 3-4 or more GHC extensions basically making their own haskell dialect
10:32:30 <Ainieco> alright, i feel better now
10:32:42 <shapr> haha
10:32:57 <shapr> Ainieco: That's a good point, is Haskell now the same as GHC?
10:33:17 <shapr> I've recently wondered how much of Hackage will work on Haskell implementations other than GHC
10:33:21 <josephle> hmm, is there an alternative Haskell compiler that is still in active maintenance?
10:33:30 <silver> no?
10:33:46 <Ainieco> shapr: it seems so, ghc defacto standard kind of thing
10:33:52 <ab9rf> is the utretch compiler still alive?
10:33:56 <ab9rf> er utretch
10:34:02 <ab9rf> whatever, i can't type
10:34:16 <jedai> there's some but they're not very active and they don't try to cover the insane amount of GHC extension actually out there
10:34:30 <jedai> ajhc ?
10:34:30 <shapr> ab9rf: Yeah, I think UHC is still alive, and Hugs, and a bunch of others, but I wonder how much of Hackage requires GHC extensions?
10:34:40 <ab9rf> do people still use HUGS?
10:34:48 <ab9rf> i thought tht was mostly bitrotted by now
10:34:54 <shapr> Sure, Hugs is written in C and runs in a tiny amount of memory.
10:34:57 <johnw> shapr: is JHC alive?
10:35:05 <shapr> johnw: I don't remember, but I can find out.
10:35:06 <koomi> johnw: ajhc was merged back into jhc
10:35:08 <johnw> and there are several in-house Haskell compilers out there, like Lennart's
10:35:11 <jedai> Hugs is pretty much a zombie at this point (though I think there were talks of taking it over at one point ?)
10:35:21 <nadirs> One curious thing, to me, is some large companies using Haskell have their own compilers (hello all, btw)
10:35:27 <shapr> johnw: Lennart has written a number of Haskell compilers
10:35:40 <shapr> and not quite Haskell things like Cayenne and several others
10:35:42 <shapr> Lennart is prolific
10:35:52 <shapr> Hi nadirs
10:35:58 <jedai> There was ihc or ... something. The intel haskell compiler
10:36:07 <shapr> I've only heard of that one, never saw it.
10:36:17 <josephle> there's a paper referencing it, iirc
10:36:23 <josephle> an intel white paper
10:37:45 <josephle> but I can't imagine it being a good alternative
10:37:45 <mwc> Ghcjs uses the STG from the GHC frontend, I suppose that's half a haskell compiler
10:38:03 <josephle> since even the intel C compiler draws too much from internal intel processor implementation
10:38:19 <shapr> Would be interesting to see a list of Haskell implementations on the haskell.org wiki
10:38:28 <shapr> along with which libraries do or don't work with them.
10:39:25 <mwc> josephle: yeah, but nowadays isn't icc mostly used for people targetting intel HPC platforms like Phi? Same with xlcc does anybody use that if they're not targetting Cell?
10:39:42 <shapr> mwc: There was a Haskell compiler specific to the Cell?!
10:40:00 <mwc> @shapr, no, that's xlcc, ibm's in-house compiler
10:40:00 <lambdabot> Unknown command, try @list
10:40:25 <josephle> well, there may be a haskell compiler internal to intel that might be good for HPC on intel platforms
10:40:43 <shapr> mwc: oh, I see... man, I'd love to have a copy of that
10:40:49 <shapr> I have a whole bunch of Cell hardware
10:42:20 <mwc> maybe, but HPC performance-intensive parts are mostly the kind of code that's well suited to things like fortran, c, and vectorization.
10:42:21 <josephle> http://www.leafpetersen.com/leaf/publications/hs2013/hrc-paper.pdf
10:42:44 <hodapp> another thing I'm curious on: If one were aiming to implement something for scripting (like sivteck was talking about) in more lightweight environments, how much of a compiler is actually required?
10:42:49 <josephle> it looks like the intel haskell compiler only has performance parity with GHC at best
10:43:08 <orion> Ainieco: Would you consider it sloppy if a large majority of the functions within an application returned a Maybe (...)?
10:46:45 <shapr> mwc: I have some fun problems that would be suited to the eight QS20 blades I have lying around.
10:47:37 <mauke> shapr: is there a specific reason you're wearing your @ hat?
10:48:03 <shapr> mauke: yes
10:50:27 <wrengr> josephle: iirc, the main thing with Intel's compiler is focusing on numerically heavy computations, while being decent enough in other stuff
10:50:39 <mwc> shapr: you ever thought about how map the stg machine onto SPMD processors?
10:50:48 <wrengr> so, it has a rather different focus than ghc
10:51:05 <josephle> seems reasonable
10:51:14 <shapr> mwc: hadn't thought about it at all, these days I'm more interested in getting the reduceron working on my soon to arrive novena
10:51:26 <shapr> mwc: Is the Cell still a real arch? I thought it was being abandoned?
10:51:29 <mwc> a more interesting comparison would be between ghc, ihc, and accelerate and repa
10:51:49 <josephle> a brief glance at the paper tells me they also opted to add some whole-program optimization that they claim ghc does not do
10:51:57 <mwc> shapr: maybe it is, I thought it was still in the Power line
10:53:18 <shapr> mwc: I don't know, would like to know more if you happen to find out
10:53:26 <dajsid> What are 'fixed points' for example in the description of MonadFix?
10:53:40 <shapr> mwc: but the idea of graph reduction on FPGAs has me excited
10:54:18 <mwc> shapr: that sounds more practical than targetting SPMD/SIMD archs
10:55:02 <shapr> I don't know which one is more practical, but FPGAs are probably more accessible
10:59:45 <johnw> dajsid: if a function is recursively called with its own output, a fixed point is a value that causes the recursion to stop
11:00:36 <johnw> i.e., where f x = x
11:00:38 <johnw> dajsid: http://en.wikipedia.org/wiki/Fixed_point_(mathematics)
11:00:53 <ReinH> http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion is also nice
11:01:02 <dajsid> johnw: ah ok ;)
11:01:04 <ReinH> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics goes a bit deeper as well
11:02:01 <johnw> so, "fixed" here means that it's a stable point
11:02:16 <ReinH> johnw: So recently I learned that applicatives are (lax) closed functors, and (<*>) is a statement that f preserves internal homs :)
11:02:18 <johnw> anything else requires iteration
11:02:37 <johnw> ReinH: what is a closed functor again?
11:03:32 <ReinH> johnw: a functor C -> D between closed categories is closed if it preserves internal homs (F[X,Y]) = [F(X),F(Y)] and the unit object
11:04:00 <johnw> the unit object?  so is it between closed monoidal categories?
11:04:42 <ReinH> johnw: Hmm, good question. I'm going by nlab here :/
11:05:00 <johnw> i'm just wondering how the notion of a unit comes into play
11:05:00 <ReinH> I'm not actually sure where they get a unit object
11:05:12 <ReinH> Ignoring that, the internal homs part is what I want to talk about anyway :)
11:05:29 <ReinH> johnw: internal homs in Hask are carried by (->)
11:05:40 <johnw> haha
11:05:48 <ReinH> so that's f (x -> y) -> f x -> f y :)
11:06:04 <ReinH> this must be natural, but that's implied by parametricity
11:06:11 <johnw> right
11:06:46 <ReinH> I really like this view. edwardk mentioned it.
11:07:06 <edwardk> sclv and dolio brought it to my attention and i ignored it for a long time
11:07:08 <ReinH> Maybe he can explain why nlab talks about a unit object.
11:07:12 <edwardk> but now i can't see applicatives any other way
11:07:18 <ReinH> edwardk: me neither :)
11:07:38 <monochrom> dajsid: I think you need https://wiki.haskell.org/MonadFix
11:07:51 <ReinH> "apply preserves internal homs" is really nice.
11:07:56 <edwardk> basically applicatives describe how it maps the closed structure, and then because the category is monoidal closed, the behavior w.r.t the monoidal tensor is just determined for you
11:08:10 <ReinH> right
11:08:26 <ReinH> edwardk: Are all closed categories self-enriched?
11:08:44 <ReinH> Since the internal hom is an object in the category
11:09:15 <dajsid> monochrom: thanks
11:10:17 <edwardk> the internal hom is [-,=] :: C^op * C -> C   -- so it has the right "shape", but now you need to be careful about the notion of enrichment you use, because we usually enrich in a monoidal category
11:10:19 <Ainieco> orion: if yor problem domain requires a lot of Maybe then it's not sloppy
11:10:34 <ReinH> edwardk: so closed *monoidal* categories
11:10:50 <edwardk> there is a notion of enrichment in a closed category you can use
11:11:10 <ReinH> edwardk: I'm wondering if strength is free in closed categories.
11:12:00 <ReinH> closed monoidal categories, perhaps?
11:12:49 <edwardk> http://ncatlab.org/nlab/show/enriched+category talks about a bunch of the notions of enrichment but leaves off the discussion of enrichment in a closed category. http://ncatlab.org/nlab/show/closed+category picks that up a bit
11:12:58 <ReinH> kk
11:14:47 <lifter> Anyone know of example code that uses conduit to read a file and print the context on the screen w/ exception safety?
11:15:31 <lifter> I'm aware of the tutorial on FP Complete, but would like to see more code if possible
11:15:32 <ReinH> lifter: content?
11:15:47 <lifter> ReinH: Ah yes, sorry
11:17:49 <hsk5> Can you spend 2 minutes or so watching this? https://www.youtube.com/watch?v=JBjjnqG0BP8#t=2m36s (starting at 2:36)
11:17:50 <hsk5> It's Stroustrup explaining how C++ has to be stable for decades.
11:17:50 <hsk5> Can we expect the same with Haskell? In other words, will code that works on GHC today also work on GHC after 20 years?
11:18:11 <zebr> hi all. if i have a monoid A and a monoid B and then i have a mapping f from A to B such that f(a+b) == f(a)+f(b), is there a particular name for that? i'm tempted to say a monoid-functor, but i have no idea if that's accurate.
11:18:24 <init> monoid homomorphism
11:18:26 <hodapp> I guess that's more important when no one wants to touch C++ code once it's written.
11:18:31 <init> is it preserving the identity, too?
11:18:37 <zebr> init: yes
11:18:54 <zebr> right, so f is a monoid homomorphism?
11:19:07 <sclv> ReinH: buried on the nlab is the theorem that a monoidal functor between closed monoidal categories is automatically closed monoidal
11:19:18 <ReinH> sclv: Thanks :)
11:19:19 <sclv> ditto a closed functor between closed monoidal categories
11:19:42 <sclv> so thats what i mean i say that "in CCCs lots of things coincide"
11:20:02 <init> zebr: yes
11:20:08 <zebr> init: great, thanks :)
11:20:23 <init> zebr: http://en.wikipedia.org/wiki/Monoid#Monoid_homomorphisms has more info about them
11:20:30 <ReinH> sclv: right. I believe that intuitively, but it's nice to see examples :)
11:20:39 <sclv> and yes, all closed monoidal categories admit a strength iirc
11:21:02 <ReinH> sclv: cool thanks :) If you happen on a source for that I'd be interested in reading it, but no worries.
11:21:04 <sclv> this was all part of the motivation for me to finally begin to understand why a "topos" is such a great general construction
11:21:17 <dolio> sclv: That's not entirely true.
11:21:21 <ReinH> yay!
11:21:39 <ReinH> nerf fight
11:21:46 <ReinH> or nerd, but I actually like that
11:21:47 <dolio> It's only lax monoidal functors that are automatically lax closed.
11:22:01 <ReinH> dolio: Oh.
11:22:22 <ReinH> dolio: that's what I assumed he meant anyway
11:22:50 <NemesisD> i've got a library and I wanted to add an optional executable example that uses the library. is the best way to do that add a cabal flag and put the whole executable section of the .cabal file under the flag?
11:22:51 <dolio> Right, but there are also strong and strict monoidal functors.
11:23:00 <dolio> And those aren't automatically strong and strict closed.
11:23:03 <ReinH> Noted.
11:23:05 <sclv> ah, and another caveat -- they're not the same, but rather one "gives rise" to the other -- the examples section here spells it out http://ncatlab.org/nlab/show/closed+functor#examples_2
11:23:08 <dolio> You only get lax closed for free.
11:23:41 <dolio> It's easy to give the lax closed operation, but I don't think you automatically get that it's an isomorphism or 'on the nose'.
11:23:43 <sclv> right -- i'm being sloppy with "lax" since that's the default these days :-)
11:24:08 <sclv> the proper statement from that page is "lax monoidal and lax closed functors between closed monoidal categories are in bijective correspondence"
11:24:17 <monochrom> one may say, you're being lax with "lax"
11:24:40 <ReinH> Your lax laxness will not stand
11:24:42 <dolio> Applicatives are lax anyway, though, so it applies to them.
11:24:53 <sclv> dolio pointed out where my definition lax precision
11:25:01 <monochrom> :)
11:25:06 * ReinH groans
11:25:20 <dolio> ReinH: Also, I think you wouldn't get strength automatically.
11:25:33 <dolio> Because the strength in Haskell relies on the tensor being a product.
11:25:35 * ParmesanCaesar salad
11:25:38 <dolio> So you can deconstruct it.
11:25:47 <ReinH> dolio: ah
11:26:07 <dolio> If you have an arbitrary tensor I don't think you'd have enough to make a strong functor.
11:26:16 <ReinH> gotcha
11:26:23 <dolio> Because you'd only know that it's functorial.
11:26:35 <dolio> Maybe the closed structure would give it to you, though. I'm not sure.
11:26:38 <sclv> "In contrast to this, a strong monoidal functor may also be called a weak monoidal functor"
11:26:41 <sclv> *headdesk*
11:26:52 <dolio> sclv: Yeah, they're great, aren't they.
11:26:55 <ReinH> hahaha
11:28:04 <dolio> sclv: Gives some perspective to Martin complaining that practical type theorists can't agree on what a 'product' is in relation to dependent type theory.
11:29:02 <dolio> They should use mathematical terminology, which is perfectly clear.
11:30:01 <mabino-pyon> dolio: "tensor being a product" --> is it really okay to say haskell tuples are tensors? afaik, tensors are positive, nonpointed types... does haskell even have nonpointed types?
11:30:29 <wrengr> mabino-pyon: The various Foo# types aren't (in general) pointed
11:30:45 <dolio> mabino-pyon: "Tensor" in this context refers to the tensor product of a monoidal category.
11:31:40 <dolio> Which is just a functor C (x) C -> C with a unit object I of C, such that I (x) A ~= A ~= A (x) I for all object A of C.
11:32:00 <mabino-pyon> dolio: yea that's the tensor i'm thinking about... normally in my mind i also add a condition that there has to be a tensor-hom adjunction
11:32:04 <stolaruk> Can anyone recommend conduit learning materials other than the tutorial on FP Complete?
11:32:05 <TallerGhostWalt> what is the type called that is a list which must contain an element?
11:32:08 <dolio> Oh, and A (x) (B (x) C) ~= (A (x) B) (x) C
11:32:44 <dolio> In a closed monoidal category, there is such an adjunction.
11:32:57 <dolio> And product-exponential works for that.
11:33:18 <mabino-pyon> does this adjunction exist even in the presence of bottom? :-O
11:33:28 <dolio> Yes.
11:33:40 <dolio> Although, if we're being technical, Haskell's tuples aren't products in this sense.
11:33:53 <dolio> Unlifted tuples are products.
11:34:02 <darkroom> if you have two IntMaps and you want to union them without lossing information is there a efficent way of doing it (assume you can change the key values)
11:34:14 <dolio> Where _|_ = (_|_, _|_)
11:34:53 <monochrom> TallerGhostWalt: you may like http://hackage.haskell.org/package/NonEmpty
11:35:25 <TallerGhostWalt> monochrom: thx
11:35:29 <TallerGhostWalt> couldn't remember
11:35:45 <Clint> TallerGhostWalt: http://hackage.haskell.org/package/semigroups-0.16.1/docs/Data-List-NonEmpty.html might be a better choice
11:35:51 <mabino-pyon> dolio: the product should technically be the smash product, right?
11:36:07 <dolio> I'm not sure what "smash product" is.
11:36:17 <mabino-pyon> https://en.wikipedia.org/wiki/Smash_product
11:36:43 <wrengr> mabino-pyon: yes, the smash product is the categorical product for Haskell
11:36:53 <mabino-pyon> anything that has "something bottom-y" inside is itself "bottom-y"
11:36:56 <wrengr> alas, tuples aren't that
11:37:16 <mabino-pyon> right
11:37:17 <wrengr> though, there're historical reasons why we ended up with tuples being the way they are
11:37:22 <TallerGhostWalt> Clint: yeah I always have semi-groups anyway
11:37:38 <wrengr> in terms of beginner friendliness, Haskell's tuples are a good compromise
11:38:23 <dolio> If you change the way seq works, tuples could be unlifted.
11:38:33 <dolio> Well, also the way pattern matching works.
11:38:43 <dolio> Miranda had irrefutable tuple matching.
11:38:56 <dolio> But it then also had seq which could tell _|_ from (_|_, _|_).
11:39:00 <dolio> So it almost had real products.
11:39:06 <mabino-pyon> :-O
11:39:06 <wrengr> iirc, that was dropped in Haskell for performance reasons
11:39:09 <dajsid> should my module names and source file names match as a general good practise rule? ie ModName for ModName.hs?
11:39:34 <chrisdone> dolio: what's irrefutable tuple matching?
11:39:37 <wrengr> though really the issue is, at different times we want both lifted products and smash products
11:39:59 * hackagebot trifecta 1.5.1.3 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.5.1.3 (EdwardKmett)
11:40:02 <dolio> chrisdone: case undefined of (x, y) -> 5 ==> 5
11:40:12 <mabino-pyon> so lifted products are tensors, or just "closer to tensors"?
11:40:15 <dolio> Similar to putting ~ in front of all your (,) matches today.
11:40:17 <dolio> Or newtypes.
11:40:39 <chrisdone> ah, ok
11:40:55 <mabino-pyon> dolio: whoa, that one looks really unintuitive
11:41:03 <mabino-pyon> i mean, the code example you gave
11:41:17 <dolio> Since tuples only have one constructor, matching doesn't really demand that you evaluate them.
11:41:52 <dolio> And if you don't, then you can't tell the difference between a bottom and a pair of bottoms.
11:42:03 <dolio> Except if seq can.
11:42:19 <chrisdone> did that apply to all single-constructor types?
11:42:24 <dolio> I think so.
11:42:39 <dolio> It would be pretty weird if it didn't.
11:43:13 <myfreeweb> hey! I'm trying to run tests via ghci. Using `cabal repl tests` works and allows me to :reload... but only the tests are reloaded! The library is not reloaded :( Is it possible to force ghci to use the library as interpreted too?
11:43:14 <dajsid> guys should I name my modules the same as my hs files?
11:43:24 <chrisdone> dajsid: generally, yes
11:43:46 <dajsid> chrisdone: okay thanks - could there be clashes if I have a module with the same name as a library module?
11:44:55 <chrisdone> sure
11:45:24 <chrisdone> myfreeweb: i don't know whether cabal repl supports loading multiple targets at once
11:45:29 <dolio> mabino-pyon: I don't know if it's much more intuitive than 'case undefined of Identity x -> 5 ==> 5', which we have today.
11:45:44 <dolio> It's something you'd have to get used to.
11:45:53 <dolio> More unintuitive, even.
11:45:59 <chrisdone> myfreeweb: i tend to just load the library and then have a .ghci file that adds the necessary source path and packages
11:46:36 <chrisdone> myfreeweb: e.g. cabal repl; :set -itest/ -package package-needed-by-test and then you can load both library and tests together without the context switch
11:46:46 <quchen> Is there a way to write NULL to a (Ptr a)?
11:46:58 <chrisdone> there's nullPtr
11:47:00 <quchen> There's nullPtr, but there' no "makeNullPtr"
11:47:36 <quchen> poke ptr nullPtr is the equivalent of *p = NULL, but I want p = NULL
11:47:37 <Hijiri> it wouldn't be the same pointer if you did that
11:47:37 <hannes__> quchen: Type signature? What would you need that for?
11:47:38 <ReinH> dajsid: Only if you want them to work.
11:48:02 <myfreeweb> chrisdone: thanks!
11:48:05 <hannes__> pointers are immutable in haskell, just like everything else
11:48:08 <Hijiri> quchen: that is destructive mutation
11:48:13 <quchen> Oh yes it is.
11:48:30 <quchen> hannes__: Ptr a -> IO (), the C equivalent would be p=NULL.
11:48:46 <hannes__> quchen: Yeah but that can't change the pointer
11:48:58 <chrisdone> i'm not aware of such a function in the standard lib
11:49:02 <quchen> I want to change the memory location the pointer points to
11:49:09 <Hijiri> quchen: you can't do that
11:49:09 <quchen> Eh
11:49:15 <hannes__> quchen: That's impossible
11:49:27 <hannes__> quchen: And you can't do that in C either
11:49:28 <Hijiri> p=NULL is like x=5
11:49:33 <ParmesanCaesar> it's necessary
11:49:36 <Hijiri> (when 5 is already bound)
11:49:41 <geekosaur> you're thinking about this wrong on some level...
11:49:41 <Hijiri> x I mean
11:49:42 <chrisdone> quchen: you could make one with the ffi, but i presume you were just asking if there is one
11:50:04 <hannes__> quchen: a function with the signature void(int*) can't make the passed pointer point to something else either
11:50:07 * hackagebot ghc-make 0.3.2 - Accelerated version of ghc --make  http://hackage.haskell.org/package/ghc-make-0.3.2 (NeilMitchell)
11:50:07 * geekosaur suspects what's really wanted is a Ptr (Ptr ...), similar to C's type **thing
11:50:29 <geekosaur> which is likewise what C wants if you want to change the pointer and not the thing
11:50:37 <Hijiri> IORef (Ptr a) might work too, depending on what is being done
11:51:09 <quchen> So the thing is I have a C callback that receives 1) a C array (foo *arr) and 2) an error code. These are the only things available, and I'd like to communicate to the outside whether an error has occurred by overwriting the garbage with something meaningful, such as 0.
11:51:12 <chrisdone> <quchen> I want to change the memory location the pointer points to -- is *p = NULL; this isn't clear
11:51:16 <quchen> I guess a null pointer wasn't the right thing there.
11:51:58 <quchen> I'm neck deep in FFI-binding a strange library if that's not obvious.
11:52:09 <chrisdone> like e.g. void (foo *arr) { /* oh noes */ *arr = NULL; } ?
11:52:24 <quchen> Right
11:52:40 <hannes__> quchen: yeah... a function with that signature couldn't change the passed pointer in C either
11:52:47 <Hijiri> *arr would just be the first thing in the array wouldn't it?
11:52:54 <quchen> Hmm yeah
11:52:57 <moghedrin> Hijiri: Yup.
11:53:01 <Hijiri> so it would set the memory there to NULL like what you said you didn't want
11:53:22 <chrisdone> oh so a double pointer sounds appropriate
11:53:29 <quchen> I'd just like to be able to look at the array from outside and say "this is valid data" or "no this is garbage"
11:53:59 <moghedrin> Or, in c-world, using memcpy or something similar to set ALL the memory to 0.
11:54:15 <moghedrin> Don't know how you'd do that here with Ptr, though.
11:54:18 <chrisdone> quchen: and you can't have a separate success/fail value?
11:54:21 <hannes__> quchen: You'll probably have to put that data elsewhere. You can't really encode that in the pointer
11:54:34 <hannes__> quchen: At least not in a sensible manner
11:54:51 <quchen> This is what I have: void (*callback)(t handle, const void *myArray, int errorCode, const response *providedByTheLib);
11:54:53 <hannes__> *and you really really wouldn't want to even if you could
11:55:16 <quchen> That callback is invoked with data put into providedByTheLib, and knows the error code of the operation that put it there.
11:55:28 <geekosaur> well, if you know the size of the array then you can do it
11:55:30 <quchen> myArray is my only way to the outside.
11:56:06 <chrisdone> so you can't change the const void *myArray to a void **myArray?
11:56:15 <quchen> Nope, third party lib
11:56:22 <chrisdone> ah, ok
11:56:31 <quchen> Asynchronous C. Fun times
11:56:36 <geekosaur> I think you lose given that const
11:56:42 <mauke> that's more or less the same thing, though
11:56:48 <mauke> you can tunnel anything through void *
11:57:04 <mauke> const can be defeated by a level of indirection
11:57:07 * mauke disappears again
11:57:10 <Javran> any one familar with the core language? I'm reading "safe zero-coercion for Haskell" but it doesn't seem to include a syntax for let-expressions.
11:57:59 <chrisdone> it has lets
11:58:28 <chrisdone> https://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/CoreSyn.html
11:59:23 <Javran> chrisdone: I see, thanks!
12:02:28 <chrisdone> quchen: yeah, like mauke said, you could put in the myArray pointer to a void** =p
12:03:02 <dajsid> when a type is declared to be an instance of a typeclass but only some of the type parameters are specified for the type - does that mean that it is also an instance for all types of the other type parameters?
12:03:02 <quchen> chrisdone: You mean simply use `poke p nullPtr`?
12:03:04 <chrisdone> void foo (const void *myArray) { void **x = *myArray; if (success) { *x = malloc(…); … } else { *x = NULL } }
12:03:09 <chrisdone> or the equivalent of in haskell
12:03:27 <quchen> Might be worth a shot.
12:03:42 <geekosaur> I think you meant &myArray and I am not sure it's defined to work there since you're taking a pointer to a stack location
12:04:03 <chrisdone> not &myArray, no
12:04:24 <chrisdone> we're considering it to be const void ***myArray
12:04:28 <chrisdone> probably need a cast in there
12:04:38 <quchen> castPtr
12:04:41 <quchen> No problem
12:04:46 <hannes__> dajsid: Depends... how do you understand that?
12:04:49 <geekosaur> oh, I se what you are up to. still not hopeful... might as well give it the good old C try, with a debugger on standby :p
12:05:00 <hannes__> dajsid: If you have something like instance Foo (Bar a)
12:05:07 <dajsid> this is what im talking about: http://lpaste.net/120861
12:05:15 <enthropy> chrisdone: it makes sense why that iIwith blah Ii is not really practical (in my opinion)?
12:05:16 <hannes__> then (Bar a) is an instance of Foo for any a
12:05:18 <dajsid> the 'a' parameter for Writer is not specified
12:06:08 <chrisdone> enthropy: which is that, a question or a statement?
12:06:31 <hannes__> dajsid: Yeah, that's because monad is a class for types with kind * -> *
12:06:33 <enthropy> question. Add "does" at the beginning
12:06:33 <dajsid> so is 'instance (Monoid w) => Monad (Writer w) where' the same as 'instance (Monoid w) => Monad (Writer w a) where' ?
12:07:00 <hannes__> dajsid: No, that wouldn't compile
12:07:05 <hannes__> dajsid: You can try it
12:07:06 <chrisdone> enthropy: it's just a hack?
12:07:08 <dajsid> hannes__: ah i see
12:07:33 <dajsid> hannes__: does that mean you would have a partial type or something like that?
12:07:33 <chrisdone> i'm not sure that anyone is considering it seriously
12:08:11 <hannes__> dajsid: Yeah, that's probably the best way to think of it right now. Basically, you define monads on things that take a type and produce a type
12:08:53 <dajsid> hannes__: so the thing that takes a type in this case is 'Writer w' ?
12:08:58 <hannes__> yes
12:09:05 <dajsid> okay thanks
12:09:47 <chrisdone> enthropy: oh, i misread adam vogt's post. i thought he was saying 'infix' syntax is a half-solution and then proposing the iwith stuff as a better solution
12:09:52 <enthropy> well I would use it if it didn't have those two problems (related to how ghc-7.8 / 7.6 have changes that are not so friendly to HList)
12:09:58 <enthropy> I am adam vogt
12:10:22 <chrisdone> ok. never can tell in this irc world of super heroes
12:10:44 <dajsid> :k Monad
12:10:45 <lambdabot> (* -> *) -> Constraint
12:10:46 <mauke> maybe you should go by your account name :-)
12:10:50 <chrisdone> yeah, generally type-trickery that has drawbacks like that aren't attractive to me
12:10:55 <dajsid> what is this 'Constraint' some sort of meta-type?
12:11:13 <mauke> dajsid: I guess kinds are meta-types
12:11:22 <mauke> (the types of types)
12:11:25 <dajsid> mauke: Constraint is a kind?
12:11:27 <mauke> yes
12:11:32 <dajsid> okay i see
12:11:36 <mauke> the kind of things that go before =>
12:11:38 <Hijiri> what would keep haskell from having Agda's hole fixity stuff?
12:12:06 <chrisdone> enthropy: another thing i'm not clear on is whether it handles associativity properly
12:12:26 <khyperia> I'm trying to make an IRC bot, and I'm having trouble coming up with an abstraction for the message stream. How I see it is that I need a type that takes an irc message, then returns a list of responses to that message (could be zero), as well as a new function that takes the next message. I tried "newtype Processor msg result = Processor (msg -> (result, Processor msg result))" but while I could make
12:12:27 <chrisdone> enthropy: i mean, infixr/infixl -- which does it choose?
12:12:28 <aavogt> it's infixl
12:12:28 <khyperia> Functor and Applicative instances, I don't think that's actually a Monad. Any advice?
12:12:45 <chrisdone> right
12:13:09 <fread2282> khyperia: maybe consider pipes or conduit?
12:13:17 <dajsid> so '*' is a placeholder for 'any kind'  or 'any type'?
12:13:42 <chrisdone> * is for boxed types aiui
12:13:47 <scott> dajsid: it's not a placeholder, it's just the name for the kind of types
12:13:54 <chrisdone> # is for unboxed types
12:14:01 <dajsid> oh
12:14:08 <khyperia> fread2282, oh, I forgot about those two. I just looked into how reactive-banana works, and that just seems like it hacked together a solution based on timestamps. I'll go see how they implement things
12:14:17 <dajsid> is there some article that goes over these things?
12:14:45 <Procian> khyperia: I think you want result to be a bag of results (not a list).
12:15:08 <dajsid> nvm seems there's not much too it..
12:15:10 <khyperia> what do you mean, Procian? They need to be oredered.
12:16:01 <chrisdone> dajsid: https://www.haskell.org/report/mono/2010#x10-640004.1.1
12:16:08 <Procian> khyperia: You've basically got a continuation there. And you've got the ordering of results implied by that continuation. But I think at each thunk, the results have to be unordered to meet the monad laws.
12:16:43 <dajsid> thanks chrisdone
12:17:05 <shachaf> khyperia: https://hackage.haskell.org/package/machines-0.4.1/docs/Data-Machine-Mealy.html
12:17:47 <khyperia> shachaf, okay, that's useful, thanks for pointing that out, that looks like (almost?) exactly what I have... actually I think that is exactly
12:17:49 <monochrom> what does "slow diagonalization" mean? :)
12:22:33 <khyperia> Huh. Turns out my attempt at the implementation of Monad is actually the exact same as that one. The "fst" in there is what threw me off, that made me think it's not a valid implementation.
12:23:12 <Javran> I couldn't find the operational semantics for let-expressions in core language, it there some paper / core interpreter that I can refer to?
12:23:47 <Procian> khyperia: Curious. It's been a while since I tried this one, but I found it broke associativity if I tried implementing it like that. But I trust ekmett more than me.
12:24:41 <khyperia> Procian, if we go with the Mealy example, it just means that "b" here is actually "[IrcResponse]"
12:25:06 <khyperia> not that the actual whole thing is a list or something
12:25:54 <xnil___> is there a builtin function to swap the first two elements of a list?
12:26:37 <Javran> xnil___: I don't think so, but it's easy to write one.
12:26:46 <xnil___> other than doing something like (\ls -> reverse . take 2 $ ls ++ drop 2 ls)
12:27:16 <Procian> khyperia: Hang on. Maybe the problem is that I'm not sure what is meant by "diagonalisation."
12:27:17 <Javran> how about "f (a:b:xs) = b:a:xs; f xs = xs"
12:27:26 <khyperia> ah, yeah, Procian
12:27:32 <xnil___> Javran: yeah
12:27:33 <khyperia> I don't either :P
12:28:14 <Procian> When people refer to the stream monad, they seem to mean diagonalisation as in running down the diagonal of an infinite large matrix, which means throwing out most of the matrix.
12:28:29 <Procian> I don't think that's what I wanted for my bots.
12:29:11 <chrisdone> just going to add some perspective
12:29:16 <chrisdone> *it's a bot*
12:29:28 <chrisdone> who cares how you write it? =p
12:29:30 <xnil___> aha. that solves my issue
12:29:45 <chrisdone> only you will be maintaining it
12:29:45 <khyperia> chrisdone, everyone cares if it doesn't work!
12:29:49 <supki> > [1..] & partsOf (taking 2 traverse) %~ reverse
12:29:51 <lambdabot>  [2,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:30:51 <Procian> chrisdone: Well, I was obviously ambitiously writing the bot DSL to end all bot DSLs.
12:31:47 <Procian> There must be a parallel universe somewhere in which it happened.
12:33:16 <albeit> In attoparsec using parseWith, is it possible to keep or recall the entire ByteString that was parsed in the successful parse?
12:33:31 <Javran> supki: wow
12:41:54 <phaazon> hm
12:42:17 <phaazon> what is the best thing to deal with event within netwire: turn them into intervals, or fold / map them?
12:45:22 <ryantrinkle> how would I find out exactly what -O0 and -O1 are expanding to?
12:45:44 <chrisdone> you mean core-wise?
12:46:07 <ryantrinkle> chrisdone: well, more at the flag level
12:46:14 <ryantrinkle> like, what exact optimizations are enabled in each case
12:46:56 <chrisdone> oh, dunno. perhaps the manual
12:47:24 <ryantrinkle> chrisdone: i looked, but it wasn't very obvious to me; some of the -f flags say they're part of O0 or O1 or O2, but i didn't see a comprehensive list
12:48:28 <mniip> is there a function for composing a function with itself a given number of times
12:48:59 <ryantrinkle> mniip: the 'iterate' function is close to that
12:49:15 <mniip> it takes an argument before generating the list though
12:49:34 <phaazon> I don’t like people using the m of Wire to perform some inputs stuff
12:49:34 <init> and it's also O(n) when it could be O(logn)
12:49:37 <phaazon> that sounds wrong
12:50:12 <ryantrinkle> mniip: true, but you can switch it around pretty easily: \n f x -> iterate f x !! n
12:50:33 <ryantrinkle> init: yeah, that's also not ideal
12:50:42 <josephle> O(log n)?
12:51:07 <ryantrinkle> josephle: yeah, because you can exploit the fact that f . f . f . f == (f . f) . (f . f)
12:51:54 <init> josephle: the same trick as with ^, and any associative operation (fast ^ can be generalized to monoids)
12:52:09 <ryantrinkle> although it's not necessarily the case that you'll escape O(n) in the end, since f itself will likely still need to run n times
12:52:14 <josephle> that's not O(log n)...
12:52:26 <init> n over the exponent
12:52:58 <ryantrinkle> it's only if you can actually get all the work done in the composition operator itself, rather than the function application, that you get O(log n)
12:53:17 <init> yeah, it'd be a nice "generalized" operator
12:53:48 <chrisdone> > foldr ($) x (replicate 10 f)
12:53:49 <lambdabot>  f (f (f (f (f (f (f (f (f (f x)))))))))
12:54:12 <josephle> ah, you mean you're grouping (f . f)'s and memoizing their computations
12:54:14 <josephle> ok
12:54:28 <dajsid> is haskell a viable language for developing performant opengl games with high-end graphics?
12:54:50 <ryantrinkle> dajsid: yes; you might need to be a bit careful in dealing with GC pauses, but other than that, you're fine
12:54:58 <chrisdone> couldn't say, have never developed high-end graphics
12:55:53 <myfreeweb> dajsid: haskell is garbage-collected.. but minecraft is written in java and performs quite well. some people modded it with epic shaders and huge textures, still worked fine I think
12:56:38 <wayne> dajsid: it is!
12:56:42 <dajsid> okay cool
12:56:47 <wayne> http://functionaltalks.org/2013/08/26/john-carmack-thoughts-on-haskell/
12:57:04 <wayne> john carmack talks about how if you make sure your functional code finishes up in one frame cycle
12:57:12 <wayne> it might make for a much cleaner architecture
12:58:01 <dajsid> sounds very... vague..
12:58:27 <wayne> dajsid: here's a language similar to haskell that has implemented mario: http://elm-lang.org/edit/examples/Intermediate/Mario.elm
12:58:27 <tdammers> sounds like a very indirect connection to me
12:58:40 <wayne> or at least parts of mario
12:58:47 <chrisdone> lol
12:58:51 <chrisdone> there was Frag written in haskell
12:58:53 <wayne> but a lot of it comes together beautifully
12:58:56 <chrisdone> i ran it and it worked
12:58:57 <wayne> e.g.   jump keys >> gravity dt >> walk keys >> physics dt
12:59:08 <wayne> you literally function compose all the parts affecting game state
12:59:14 <chrisdone> but it wasn't made by a game company so it wasn't exactly flawless
12:59:16 <dajsid> wayne: lol
12:59:33 <tdammers> chrisdone: as if stuff made by game companies were ever flawless
12:59:43 <dajsid> i played around with elm and from what i remember there is no way to get Signal a from Signal (Signal a)
12:59:48 <chrisdone> hur hur game companies r stoopd
12:59:54 <tdammers> nah
13:00:02 <tdammers> just under a lot of commercial pressure
13:00:35 <chrisdone> that's okay, internet
13:01:02 <wayne> dajsid: i also think functional programming paradigms are a good fit for entity/component game design
13:01:50 <dajsid> wayne: that sounds like something that should sit on top of the game engine
13:02:10 <myfreeweb> dajsid: check out Rust too, it has functional features including ADTs, traits (~= typeclasses) and pattern matching, but it's closer to the metal, not garbage collected
13:02:49 <chrisdone> it depends what the game engine is doing i suppose
13:02:55 <wayne> dajsid: entity/component is a valid game engine architecture
13:02:55 <chrisdone> rendering is a whole thing in and of itself
13:03:31 <dajsid> chrisdone: yea i was wondering specifically about rendering
13:04:33 <chrisdone> i don't anything about rendering. but general game logic doesn't seem as affected by the fine-point latencies that break the rendering experience
13:05:05 <wayne> i don't know much about running haskell on GPUs
13:05:11 * hackagebot mainland-pretty 0.2.7.1 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.2.7.1 (GeoffreyMainland)
13:05:18 <wayne> i'm sure people have tried it though, but it's probably nowhere near as robust as C++ and opengl
13:05:52 <dajsid> chrisdone: yeah game logic isnt really very resource intensive usually... you can use lua, javascript, or w/e and usually it will be fine
13:06:05 <myfreeweb> wayne: opengl isn't running your regular code on the gpu, it runs shaders which are written in a special language
13:06:11 <chrisdone> there's also ATS which has a linear type system for managing memory and some support for writing constraint-based proofs
13:06:26 <myfreeweb> wayne: I think there are haskell DSLs for generating GLSL...
13:06:33 <dajsid> wayne: the main concern is efficiently managing the memory for the resources and communicating with gpu
13:06:34 <chrisdone> ast = C + ml syntax + depdendent types
13:06:37 <chrisdone> er, ats
13:07:07 <josephle> chrisdone, ats = C + ml syntax + dependent types + linear types :)
13:07:15 <dajsid> okay sounds like theres a lot of stuff done in this area, i should do some research
13:07:18 <chrisdone> i already said linear =p
13:07:25 <chrisdone> stop making me type more
13:07:25 <josephle> oh, you did!
13:07:27 <josephle> :P
13:07:33 <chrisdone> :3
13:07:44 <wayne> myfreeweb: i meant that the C++ bindings to opengl are well-known and stable
13:08:36 <josephle> well, Rust's greatest strength when it comes to game design is that someone has written a game engine for it already https://github.com/PistonDevelopers/piston
13:09:40 <myfreeweb> lol, just wrote --ghc-options="-fno-ghc" instead of no-hpc
13:11:16 <tdammers> myfreeweb: "ghc, please stop being ghc, kthx!"
13:11:31 <josephle> ghc no ghc'ing!
13:13:32 <mniip> [00:08:32] <myfreeweb> lol, just wrote --ghc-options="-fno-ghc" instead of no-hpc
13:13:39 <mniip> they should add an option that turns ghc into cat
13:14:03 <mniip> ghc -fno-ghc input -o output
13:14:42 <myfreeweb> mniip: into lolcat https://github.com/busyloop/lolcat
13:18:17 <phaazon> fuck it
13:18:30 <phaazon> it’s not really great representing events as a list
13:20:11 * hackagebot vcache 0.2.0 - large, persistent, memcached values and structure sharing for Haskell  http://hackage.haskell.org/package/vcache-0.2.0 (dmbarbour)
13:28:48 <ayrie> myfreeweb: thanks for bringing up lolcat :D
13:29:07 <hannes__> josephle: Does that still compile with rust 1.0?
13:29:22 <josephle> I believe it's in active development
13:29:27 <orion> What does this error usually indicate?: Couldn't match expected type ‘ByteString’ with actual type ‘[GHC.Word.Word8]’
13:29:28 <josephle> so it should
13:29:44 <hannes__> josephle: src is 16 days old, probably doesn't compile anymore
13:30:00 <josephle> might have to wait for the next update then
13:31:12 <joelteon> can someone familiar with the cabal source point me to where it gets the data that it puts into setup-config?
13:33:06 <bennofs> joelteon: setup-config is just a dump of the LocalBuildInfo
13:33:11 <geekosaur> orion, mames me think there is a pacl or unpack missing or in the wrong place
13:33:16 <geekosaur> *pack or unpack
13:33:19 <bennofs> joelteon: which is determined during configure phase
13:33:19 <joelteon> okay
13:33:23 <joelteon> okay
13:34:08 <joelteon> so I'm trying to figure out why Cabal is thinking that conduit depends on exceptions-0.6.1
13:34:51 <orion> geekosaur: I am doing the following: blah = byteString bs1 <> byteString bs2
13:35:25 <joelteon> does Setup configure allow debugging the dependency solver?
13:35:40 <bennofs> joelteon: ./Setup configure -v3 should give you plenty of information
13:35:43 <bennofs> joelteon: maybe already -v2
13:35:51 <joelteon> okay
13:35:58 <joelteon> i will try that
13:36:48 <joelteon> I should probably remove setup-config for that
13:36:51 <joelteon> unless configure ignores it?
13:36:59 <bennofs> joelteon: hmm, just checked, -v2 doesn't give you more than the versions it's using for each ep
13:37:02 <bennofs> s/ep/dep
13:37:09 <bennofs> joelteon: neither does -v3
13:37:11 <joelteon> v3 doesn't either
13:37:13 <joelteon> heh
13:37:14 <phaazon> it’s not really great representing events as a list
13:37:17 <phaazon> oops
13:38:04 <orion> geekosaur: Boom. Adding pack worked. Thanks!
13:38:39 <bennofs> joelteon: so you are compiling conduit and it chooses exceptions-0.6.1 or have you already compiled conduit and you wonder why it now depends on exceptions-0.6.1?
13:39:10 <joelteon> bennofs: i've already compiled conduit and I wonder why it depends on exceptions-0.6.1
13:39:19 <joelteon> also this is in nix, where there *is* no exceptions-0.6.1
13:40:51 <joelteon> however, the more confusing part is that the conduit it is convinced it depends on doesn't exist on my filesystem
13:40:51 <bennofs> joelteon: are you using haskellng or haskell?
13:40:54 <joelteon> haskellng
13:41:23 <bennofs> joelteon: in a .env nix-shell or nix-shell on a package directly?
13:41:33 <joelteon> on a package directly
13:41:47 <joelteon> originally so that I could invoke configure and then repl in the shellHook
13:41:57 <joelteon> since there's really never anything else i want to do in the shell
13:42:11 <bennofs> joelteon: so I assume you use --pure? :~)
13:42:14 <joelteon> yes
13:42:35 <joelteon> the string "exceptions-0.6.1" is in one place on my filesystem: dist/setup-config in my project
13:42:43 <bennofs> joelteon: in haskellng, there should be /tmp/package.conf.d
13:42:52 <bennofs> (or $TMPDIR/package.conf.d)
13:42:52 <joelteon> yes there is
13:43:03 <bennofs> joelteon: and there is no exceptions 0.6 in there?
13:43:07 <joelteon> no
13:43:17 <joelteon> only 0.8
13:43:21 <joelteon> the one i would expect to exist
13:43:49 <bennofs> joelteon: so it happens also when you rm -rf dist and reconfigure with --package-db /tmp/package.conf.d ?
13:44:04 <bennofs> (eh s@/tmp@$TMPDIR)
13:44:18 <joelteon> i'll try that
13:44:36 <bennofs> cabal is sometimes really good in caching stuff you don't want to have cached :)
13:44:54 <joelteon> okay, now it is upset about package shadowing
13:45:17 <joelteon> oh
13:45:26 <joelteon> okay so I have /tmp/package.conf.d and $TMPDIR/package.conf.d and they're not the same thing
13:45:31 <joelteon> and the latter does have an exceptions configuration in it
13:45:36 <bennofs> ah
13:45:39 <joelteon> seriously why
13:45:58 <monochrom> hmm, that's interesting
13:46:03 <bennofs> joelteon: $TMPDIR is some /run .. dir in nix-shell (at least in linux)
13:46:11 <joelteon> okay and if I rm -rf $TMPDIR/package.conf.d now I can use nix-shell
13:46:30 <joelteon> bizarre
13:46:37 <bennofs> joelteon: so maybe you once ran forgot --pure and nix-shell inherits TMPDIR or something (idk)
13:46:50 <bennofs> joelteon: ah yes, nix-shell uses TMPDIR if set in the surrounding environment even with --pure iirc
13:46:57 <joelteon> yeah tmpdir is inherited
13:47:19 <joelteon> so if I set TMPDIR to something other than that folder, maybe that'll do it
13:47:20 <bennofs> but if TMPDIR is unset, it doesn't use tmp but /run/user/<uid>/ or smth
13:48:00 <bennofs> joelteon: I think it would be a good idea to explictly set TMPDIR for haskell shells anyway, since otherwise all your projects will share a pkgdb :)
13:48:09 <joelteon> yeah clearly that is now a real problem
13:48:28 <joelteon> ok i don't like that much at all
13:48:44 * bennofs thinks nix-shell should set TMPDIR to mktemp -d  and rm that after
13:48:58 <moghedrin> Productivity for the day: alias cat='lolcat'. Thanks, guys.
13:49:04 <bennofs> But some other people want to have persistent TMPDIR :|
13:49:17 <joelteon> but why
13:49:26 <joelteon> the builder will just re-symlink all the package confs won't it
13:49:48 <bennofs> joelteon: yes, and it won't delete any existing symlinks
13:49:54 <bennofs> joelteon: so it will override some, but leave others
13:50:11 <joelteon> not if you set TMPDIR to something specific for every shell invocation
13:50:15 <bennofs> yes
13:50:33 <bennofs> TMPDIR handling of nix-shell: https://github.com/NixOS/nix/issues/395
13:50:37 <joelteon> which clearly is what I should have been doing
13:50:47 <startling> Do any of you do android?
13:51:30 <hannes__> argh... ghc mod doesn't work with cabal sandboxes anymore?
13:51:44 <bennofs> hannes__: cabal 1.22?
13:52:01 <hannes__> yeah
13:52:09 <myfreeweb> hannes__: downgrade cabal, rm -r dist, run cabal configure with your options again
13:52:18 <bennofs> hannes__: if yes, you either need to downgrade cabal or upgrade to the yet unreleased GHC 7.10
13:52:38 <joelteon> ok thanks bennofs, that did the trick
13:52:38 <myfreeweb> hannes__: 1.22's format will only be supported with ghc 7.10 but I think that's broken currently
13:52:40 <monochrom> "welcome to the future"
13:53:15 <hannes__> seeing that upgrading ghc is nearly certain to break at least some of the packages I want... if not all, downgrading it is
13:54:00 <matt3148> hi
13:54:18 <monochrom> "the future is already here. it just needs some beta software and someone to finish the to-do list"
13:54:28 <startling> :)
13:55:03 <hannes__> cabal install --reinstal cabal-install-1.20.0.6 KRAKATHOOOM
13:56:04 <ab9rf> i'm not familiar with the KRAKATHOOOM option to cabal install
13:56:16 <zebr> have you not read the manpage?
13:56:37 <ab9rf> what's a manpage?
13:57:14 <kaidelong> cabal install cabal-install can create problems on windows, you need to make a copy of cabal and install cabal-install using that copy
13:57:27 <kaidelong> not sure if other platforms have the same issue
13:57:55 <matt3148> may I ask a noob question?
13:58:11 <wayne> matt3148: don't ask to ask!
13:58:15 <hannes__> kaidelong: nah, it's just windows
13:58:24 <matt3148> ok wayne
13:58:56 <hannes__> kaidelong: Because windows doesn't let you overwrite executables that are currently in use
13:59:12 <hannes__> kaidelong: Which doesn't maky any sense because they should be in memory anyway
13:59:53 <matt3148> I've defined a function: type OperationProcessor = State -> Command -> CommandResult
13:59:54 <S11001001> hannes__: the pages are backed by the disk pages; page out of an exe page doesn't write to swap
13:59:58 <kaidelong> eeeh I don't know, especially in light of JVM and .NET which may incrementally compile parts of the bytecode as the user uses new features the user never used before
14:00:10 <kaidelong> no reason to load the entire bytecode into RAM
14:00:12 <matt3148> how can I constrain the output type based on the input type?
14:00:41 <matt3148> i.e. I know that a 'GetStringCount' command must yield a 'StringCount' response
14:00:47 <kaidelong> although it looks like JIT has lost out to AOT
14:00:55 <monochrom> to be pedantic, linux doesn't either. what happens is: linux lets you work around it: unlink the exe, create a new file with the same path, now you can "overwrite", which is not overwrite, but rather write-new.
14:01:23 <matt3148> and I'd like the compiler to enforce those command-to-response mappings
14:01:33 <S11001001> matt3148: if you add a type parameter to Command, you can put that parameter on CommandResult too
14:01:43 <kaidelong> you know
14:01:57 <kaidelong> it probably would make sense anyway for cabal to make a copy of itself and invoke it
14:02:07 <matt3148> S11001001: thanks, I'll try that out
14:02:11 <kaidelong> because then you have a backup to roll back to if the new cabal doesn't work
14:02:40 <tzaeru> this channel is so academic, that I get flashbacks from the time when we used to crash to the university student group room at 6 AM after a night spent in experimental hallucinogenics.
14:03:48 <cjenkin2> Is there a nice Haskell library meant to be run in the interpreter as a calculator for low-level bit operations (as you might use when developing C)?
14:03:57 <S11001001> matt3148: you will probably want to define Command with GADTs at that point.  https://en.wikibooks.org/wiki/Haskell/GADT#Understanding_GADTs
14:04:11 <dmwit> cjenkin2: Data.Bits?
14:04:13 <mauke> cjenkin2: well, there are the usual bit operations
14:04:49 <S11001001> matt3148: since "interpreting" is kind of what you're doing, that example should be directly relevant to your case.
14:05:19 <monochrom> cjenkin2: my http://www.vex.net/~trebla/haskell/calculator/Calculator.html doesn't have bitwise operations, but it has "print hex". and it has source code so you just need to copy and add your own stuff.
14:05:34 <cjenkin2> dmwit, mauke: And if I wanted to see a bit-array of a value, given a certain architecture (MS bit/byte)?
14:05:58 <cjenkin2> monochrom, Hex printing is definitely a must. Thanks
14:06:21 <mauke> I've never needed that when writing C
14:06:49 <cjenkin2> mauke, You've never written slave / master code where the two devices communicate with different endians :)
14:06:50 <ab9rf> i have but only when doing things relating to hardware or network stuff
14:07:01 <tdammers> hm, what's the most straightforward way of interpolating UTCTimes?
14:07:14 <cjenkin2> ab9rf, Hardware for sure
14:07:22 <tdammers> as in, I have a factor and two UTCTime values...
14:07:23 <mauke> cjenkin2: htonl?
14:07:33 <mauke> cjenkin2: but generally I just write endianness-agnostic code
14:07:36 <tdammers> and I want the equivalent of t1 + (t2 - t1) * f
14:07:41 <tzaeru> somehow it sounds very weird to me that you'd like to run haskell as the math side for C...
14:07:56 <tzaeru> equally as it sounds weird that you'd want to run haskell as the low level code for a c (or c++) master
14:08:11 <cjenkin2> mauke, I don't know if my platform has that function. Would be easy to write I suppose, if not
14:08:17 <dmwit> cjenkin2: Numeric.showInt
14:08:48 <dmwit> cjenkin2: Sorry, showIntAtBase
14:08:58 <cjenkin2> mauke, Impossible if  your master requires bit flags.
14:09:04 <dmwit> I can never remember which of the read/show ones have AtBase at the end.
14:09:22 <tdammers> oh wait, NominalDiffTime is Num
14:09:22 <Arjuna> Trying to install ghc 7.6.3 on linux Mint 17 I did './configure --prefix ~/ghc'
14:09:23 <Arjuna> and got : 'checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory'
14:09:23 <Arjuna>  
14:09:23 <mauke> cjenkin2: how so?
14:09:53 <Arjuna> I then did sudo ln -fs /usr/lib/x86_64-linux-gnu/libgmp.so.10.1.2 /usr/lib/libgmp.so.3
14:09:57 <levi> cjenkin2: Any POSIX system should have htonl
14:10:00 <monochrom> cjenkin2: if you have an iOS device, http://appshopper.com/utilities/calculatorbox
14:10:04 <Arjuna> I could install with that but now things dont work
14:10:09 <levi> If they don't, they should have an equivalent of some sort.
14:10:18 <Arjuna> ghci
14:10:18 <Arjuna> GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
14:10:18 <Arjuna> Loading package ghc-prim ... linking ... done.
14:10:18 <Arjuna> Loading package integer-gmp ... <command line>: can't load .so/.DLL for: libgmp.so (libgmp.so: cannot open shared object file: No such file or directory)
14:10:32 <Arjuna> can someone help me?
14:10:53 <cjenkin2> mauke, Say, "Bit 0 indicates that option X is enabled", you need to remember that that's MSB, e.g. 0x80
14:10:57 <myfreeweb> Arjuna: do you have libgmp installed?
14:11:19 <geekosaur> they do, just not that version
14:11:38 <cjenkin2> levi, I don't know if F9 is POSIX complient
14:11:42 <cjenkin2> *compliant
14:11:46 <geekosaur> why is that loading the dev library anyway
14:12:03 <levi> What's F9?
14:12:14 <geekosaur> I suppose they assume you have the dev library installed if you've got the compiler installed....
14:12:16 <dmwit> Arjuna: Download the one that depends on libgmp.so.10 instead of the one that depends on libgmp.so.3...
14:12:18 <cjenkin2> levi, It's an L4 implementation for certain ARM devices (Cortex-M)
14:12:41 <Arjuna> dmwit: How can I find that one? I need ghc 7.6.3
14:12:41 <cjenkin2> But it's not fully L4 compliant either. It's a "good enough" implementation
14:12:44 <dmwit> Arjuna: Don't symlink .10 to .3, that's... just dirty.
14:12:56 <Arjuna> dmwit: yes your right
14:13:28 <Arjuna> dmwit: got it
14:13:30 <dmwit> Arjuna: If you need 7.6.3, and the 7.6.3 download page does not mention a download that works with .so.10, then you will need to build it yourself.
14:13:32 <quchen> I don't think there's an official 7.6.3 with .10
14:13:41 <dmwit> Arjuna: Or install the older libgmp.
14:13:51 <Arjuna> dmwit: thanks :)
14:14:11 <quchen> My advice is to do the dirty softlink thing to get GHC going temporarily, and then compile your own version with it.
14:14:15 <monochrom> it is dirty but I did it
14:14:16 <quchen> That's what I did.
14:14:32 <quchen> And the selfcompiled is then linked against .10.
14:14:43 <dmwit> If you're just bootstrapping, why not bootstrap from your distro's GHC package?
14:14:47 <quchen> (I don't know why, but it worked and I didn't want to think more about it.)
14:14:50 <dmwit> (Are there actually distros that don't have one?)
14:18:49 <cjenkin2> Looks like there's a bunch of different pieces lying around I could use, so it could be fun to use those as a reference to build my own library / calculator from. Thanks for the pointers :)
14:19:04 <cjenkin2> (C pun intended)
14:20:10 <dmwit> cjenkin2: Sounds like fun. =)
14:20:22 <monochrom> I do not know why loading integer-gmp leads to loading libgmp.so, but I know why you will eventually need libgmp.so when you compile haskell code
14:20:25 <Arjuna> Ha! The version that can be installed from Mint 17 is 7.6.3!!
14:20:34 <Arjuna> :))
14:21:05 <cjenkin2> dmwit, I may be a C programmer by day, but I dream in Haskell at night
14:23:19 <koala_man> is there a name for when values (3) and expressions producing them (1+2) are interchangable?  as opposed to single-pass macro processors or limited-depth evaluators
14:24:24 <dmwit> What is an example of such a system?
14:24:37 <dmwit> Would you say Coq has that property?
14:24:56 <EvanR> koala_man: referential transparency?
14:24:59 <monochrom> the name is "mathematics" :)
14:25:44 <cjenkin2> koala_man, It depends on what you mean by "interchangable" :)
14:26:11 <cjenkin2> Equality is one of the more controversial topics in logic
14:26:50 <tzaeru> it's much less controversial in practical coding, thou.
14:26:56 <worldsayshi> When I run ‘cabal init’ on a folder already containing source files cabal infers what dependencies I need for the .cabal file. 1. Is it possible to recalculate dependencies without recreating the cabal file?
14:27:17 <jophish> edwardk: How long does gl usually take to build for you?
14:27:43 <koala_man> EvanR: it's definitely close.
14:29:54 <fr33domlover> ibid, hello
14:30:13 <fr33domlover> I have a question about the Planet
14:31:16 <acowley> worldsayshi: That's a common request, but I'm not aware of an easy way to do it.
14:32:02 <worldsayshi> acowley: Oh, I see that it’s not a complete calculation. It failed to realice that I needed a certain package
14:33:25 <acowley> worldsayshi: It would be nice to improve that mechanism. There is some unfortunately unavoidable ambiguity, though.
14:33:44 <acowley> worldsayshi: Namely, that different packages can expose modules with the same name.
14:34:24 <dmwit> worldsayshi: Of course, it will only know about dependencies that it can already satisfy. So nice for moving your working project to somebody else's machine, but won't realize you need to install a new package just because you imported one of its modules.
14:34:49 <RickyC> Does anyone here work with matrices? I have a small project I am working on and have hit a brick wall with the matrix portion.
14:35:24 <acowley> RickyC: Are you using hmatrix or linear or something else?
14:35:27 <hannes__> wooot I managed to express what I wanted... granted, with godawful type signatures, but hey it's a start
14:36:09 <athan> acowley: I'm trying to make a `cabal-utils` executable that will hopefully be integrated into cabal after it's made - it should do this, and I also want to data mine hackage for the correct version / api dictionary pairs, that way we can also constrain versions correctly for existing packages, to better adhere to the PVP also. But, the tool will also include `add, rm, mv` commands for modules (and maybe types and terms, too, with HaRe (if it
14:36:09 <athan> does that)) too :)
14:36:09 <worldsayshi> acowley: I discussed in the channel the possibility to create some kind of dependency suggestion tool that for example checks if dependency version constrains could be expanded or should be given additinoal constraints. Would be interesting to know where similar mechanisms could be found
14:36:34 <Lokathor> that sounds like the perfect sort of tool
14:36:47 <worldsayshi> oh :)
14:37:02 <athan> I want the cli to be nice, so it would look like `cabal-utils add Data.Foo`
14:37:14 <athan> or `cabal-utils mv Data.Foo Data.Bar`
14:37:31 <athan> and it will work throughout the (immediately nested) cabal package
14:37:33 <IYI> What do you think, guys? Could this be real http://VisitsToMoney.com/index.php?refId=648714 or it is just another crap?
14:37:35 <RickyC> acowley: http://lpaste.net/5995892418161934336   here are the two files I am starting with. I pretty much ditched my previous failed attempts. I have other files dependent on this so I can't change what I have so far
14:37:35 <hannes__> athan: So, how far along are you?
14:37:41 <athan> (so you could be `cd`' inside)
14:37:42 <dajsid> reading LYAH is like reading a novel.... -_-  whats a good concise article on applicative?
14:37:54 <acowley> athan: That sounds great. Do you something for the version/API pairs part already?
14:37:55 <athan> hannes__: I'm thinking about making my own `options-nested` package
14:37:58 --- mode: ChanServ set +o monochrom
14:37:59 <worldsayshi> athan: Do you have that project hosted somewhere?
14:38:00 --- mode: monochrom set +b IYI!*@*
14:38:01 <athan> and just plans, but that's about it
14:38:01 <geekosaur> ah, idoru already there...
14:38:09 <acowley> athan: With re-exports, it seems like there are rather a lot of possibilities
14:38:14 --- mode: monochrom set -b IYI!*@*
14:38:18 <athan> don't have the file substitutor implemented yet, but I don't expect it to be horrible
14:38:19 <hannes__> dajsid: Applicative is just Functor + pure and <*>
14:38:23 <monochrom> idoru is faster than me
14:38:34 <athan> acowley: I'm working on that now :)
14:38:35 --- mode: monochrom set -o monochrom
14:38:45 <dajsid> hannes__: what about why we need it and in what situations to use it - that kind of thing?
14:38:52 <mpickering> dajsid: You could just read the original paper "applicative programming with effects" http://staff.city.ac.uk/~ross/papers/Applicative.pdf
14:39:06 <athan> worldsayhi: There's a github repo, but I'm not doing tremendous headway on it yet: https://github.com/athanclark/cabal-utils
14:39:09 <drewbert> How do I get the ghc package?
14:39:16 <dajsid> thunderrd: mpickering looks good
14:39:19 <acowley> athan: It's a funny problem because I'm not sure it's worth solving in full generality.
14:39:24 <dajsid> thanks* mpickering looks good
14:39:43 <acowley> athan: My cabbage tool, for instance, keeps track of package provenance to support multiple instances of a single version of a package, but it does this on an as-needed basis.
14:39:47 <hannes__> dajsid: It's an abstraction that's sometimes useful. I could give you examples of where it's useful if that helps I guess
14:39:48 <athan> acowley: Hmm, re-exports?
14:39:53 <acowley> athan: So the benefits of caching are ad hoc
14:39:58 <worldsayshi> athan: Ah :)
14:40:01 <athan> oh wait
14:40:02 <ttt_fff> wtf is https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/ ? someone please tell me if this is serious so I don't have to spend time thinking myself
14:40:31 <dmwit> ttt_fff: As with all things Conor, it is a delightful mix of serious and playful.
14:40:40 <acowley> athan: Suppose A re-exports parts of B, then you build A against a new version of B without changing A's version.
14:40:53 <hannes__> nways I'm gone, gotta prepare for concert
14:40:55 <athan> yeah I forgot :P I use it all the time
14:41:08 <athan> hmm
14:41:11 <acowley> athan: The point in something like cabbage is that each of those insances of A are treated differently
14:41:48 <acowley> athan: A way to pare down the combinatorial aspects of this is to just pick particular versions of things a la Stackage snapshots.
14:42:00 <athan> hmm, one second let me look up cabbage!
14:42:23 <acowley> athan: https://github.com/acowley/cabbage
14:42:29 <athan> Yeah, that might be a good idea, I want to at least process the newest first
14:42:30 <athan> :)
14:42:34 <acowley> athan: It's something I put together while thinking about Cabal and Nix
14:42:46 <athan> oh wow!
14:42:50 <acowley> athan: It does what I feel like a combination of those two things should do
14:43:30 <athan> acowley: I can't wait to try it out :) I've weeded out nix from my workflow from the difficulties, maybe this can bring me back :)
14:43:48 <acowley> athan: It's still new, so expect growing pains
14:43:59 <athan> haha will do
14:44:10 <acowley> athan: It also reveals just how much variation you get with build plans
14:44:32 <acowley> athan: Lots of combinations of transformers, mtl, and transformers-compat lead to lots of variations of downstream packages
14:44:52 <acowley> I didn't appreciate how wild that situation was until using cabbage
14:44:59 <Ricky_C> acowley: My browser crashed,  does this help explain what I am trying to do? http://lpaste.net/5995892418161934336
14:45:13 <_di> why this may not compile http://ideone.com/zB89Yi but work in repl?
14:45:19 <acowley> Cabal sandboxes had shielded my innocence behind a shield eternal recompilation
14:46:39 <acowley> Ricky_C: where are you getting stuck?
14:46:47 <athan> hmm, thank you acowley I'll tread carefully :)
14:47:08 <tommd> _di: Your quantification is wrong.  Class constraints are a 'forall' not 'there exists'.
14:47:42 <_di> oh
14:47:51 <_di> that makes sense, but why it worked in repl? :)
14:48:02 <Ricky_C> acowley: Mainly trying to fill it and check the row count but I am having a hard time debugging those with the 'at' function getting in the way. I tried something like fillWith (x,y) a = Mat ((x,y), (\(i,j) -> a))
14:48:05 <acowley> athan: Be bold! But careful, too. :P
14:48:15 <tommd> _di: In otherwords, the caller, not the callee, decides which instance of a class to use.  However, your callee 'redisKey' uses 'namespace' as a String instead of any old 'Show a'.
14:48:17 <athan> :x
14:48:17 <_di> ah.. because in repl i didnt specify type
14:49:46 <acowley> Ricky_C: Have you tried implementing those type signatures?
14:50:01 <_di> tommd: actually I pasted incorrect code, this is what I used http://ideone.com/zB89Yi (updated)
14:50:15 * hackagebot th-orphans 0.9.1 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.9.1 (MichaelSloan)
14:50:17 * hackagebot lexer-applicative 1.0 - Simple lexer based on applicative regular expressions  http://hackage.haskell.org/package/lexer-applicative-1.0 (RomanCheplyaka)
14:50:36 <_di> tommd: so its redisKey :: Show a => String -> a -> ByteString
14:50:47 <tommd> _di: Try `C8.putStrLn` in main.
14:51:19 <Ricky_C> acowley: First I tried commenting them out to get the others working first but they all rely on each other so I have having a problem with that. I'm not sure where to go with the 'at' function and when I run fillWith I get the error No instance for (Show (Matrix [Char]))
14:51:32 <_di> tommd: worked
14:52:37 <acowley> Ricky_C: Did you try writing a Show instance for your Matrix type?
14:52:46 <_di> tommd: thanks for that. I updated code in main =, but error was about redisKey =, how does that work?
14:53:49 <tommd> redisKey was returning a ByteString and main was expecting a String. You can change main to expect a ByteString (by using the ByteString putStrLn or unpacking the bytestring first) or you can unpack and return a string form redisKey.
14:54:57 <tommd> While it might be uglier to think about, each type error has two places it can blame.  In your case you can either blame redis for returning the wrong type or you can blame main for expecting the wrong type.
14:55:08 <nh2> does anybody remember what that tool was called that does what haddocks --hyperlink-source does, but with clickable code (jumps to definition)?
14:55:30 <Ricky_C> acowley: it is in my MatrixInstances http://lpaste.net/5995892418161934336
14:55:37 <sindikat> I'm trying to install djinn with `cabal install djinn` and it says: /usr/bin/ld: cannot find -ltinfo
14:56:13 <sindikat> I'm on Ubuntu 14.10, installed Haskell packages from this PPA: http://launchpad.net/%7Ehvr/+archive/ghc
14:56:41 <acowley> Ricky_C: What are you doing to get the error message saying that there is no Show instance? Have you imported MatrixInstances into the REPL (if that's where you're getting the error)?
14:56:44 <_di> tommd: thank you for this explanation.. so, I have to go through all callers in err log to find&decide where error is :)
14:58:13 <monochrom> every type error is a contradiction. it takes two hands to oppose each other.
14:58:59 <_di> never thought that way before :)
14:59:03 <monochrom> and it takes two feet to dance and step on each other's toes
14:59:06 <tommd> _di: Usually it is obvious.  Notice this is more verbose than, but not conceptually different from, any imperative language.  Consider C - if I have `void *f()` and `uint32_t x = f(); uint64_t y = f();`  - it's pretty immediate where to blame.  Same for Haskell but you need to learn to read the compiler error messages.
14:59:59 <Ricky_C> acowley: the show is in MatrixInstances. MatrixInstances imports Matrix. But Matrix is complaining about not having show. Does that make sense? I can't import MatrixInstance into Matrix because it creates a circular import. I'm not sure what to do
15:00:35 <acowley> Ricky_C: Usually, you'd put the contents of MatrixInstances in the Matrix module.
15:00:59 <acowley> Ricky_C: But you haven't said what you're doing to produce the error message
15:01:20 <acowley> Ricky_C: Is there another module you're compiling? Are you using GHCi?
15:02:38 <Ricky_C> if I load Matrix it loads fine but then calling fillWith (2,2) "a"   produces      No instance for (Show (Matrix [Char]) arising from a use of `print'      Possible fix: add an instance declaration for (Show (Matrix [Char]))
15:03:19 <Ricky_C> Yes I am using GHCi and it is just those two modules kicking my butt
15:03:44 <monochrom> do you, really, want to see the matrix in your own naked eyes?
15:04:08 <acowley> Ricky_C: Have you said "import MatrixInstances" in GHCi?
15:04:40 <acowley> monochrome: I'm willing to chaperone the Show instance. No funny business!
15:06:45 <Ricky_C> acowley:  when I import that it says  Could not find module `MatrixInstances'   but I can load it?
15:07:23 <acowley> Ricky_C: Are you doing this in emacs? At a terminal? Via cabal repl or ghci?
15:08:42 <Ricky_C> I'm using a SSH to a linux server and using ghci
15:10:03 <acowley> Are you starting GHCi in the same directory as your source files? Are they both in the same directory?
15:10:16 <acowley> If not, you will want to add an include path
15:10:29 <ReinH> _di: I feel obligated to mention that ByteString.Char8 is a lying liar and you should probably not be using it.
15:10:38 <acowley> In GHCi, I think it's :set -iSomeOtherPath
15:10:41 <acowley> but I'm not sure
15:10:59 <Ricky_C> Yes and yes, should I copy the show instance to the Matrix file also? Will it work having it in both places?
15:12:18 <acowley> Ricky_C: You only want it in one place. But if you're running ghci in a directory with both those files, the fact that import isn't working is concerning
15:12:41 <acowley> I thought . was on GHCi's path by default
15:13:04 <monochrom> eh? if you wrote the file, it's :load not import
15:13:22 <monochrom> and if it's multiple files, there is :add
15:14:11 <dajsid> > (repeat . repeat) []
15:14:13 <lambdabot>  [[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
15:14:26 <Ricky_C> monochrom: yes :load works
15:15:25 <acowley> monochrom: Why wouldn't import work?
15:15:45 <monochrom> -iSomeOtherPath is for :load and :add, not import or :module
15:15:59 <acowley> I've tried to ween myself off of GHCi-isms
15:16:15 <drewbert> Where do global contraints come from?
15:16:17 <acowley> Really? I could have sworn I'd used that
15:16:33 <monochrom> import and :module is for changing namespaces, and requires the code to be either in a library or already brought in by :load or :add
15:17:07 <rui1> nc2 Is there such a thing? Remind me to ask you if you found it when I get back home :)
15:17:43 <JoeyLambda> I'm so stuck on something.
15:17:53 <acowley> Hm, I must be too used to cabal repl by now!
15:18:08 <monochrom> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/interactive-evaluation.html#ghci-scope is required reading
15:18:27 <JoeyLambda> I have: order :: (Ord a) => [a] -> [(Int, a)]
15:18:29 <JoeyLambda> order list = map (\l -> (length l, head l)) (group (sort list))
15:18:43 <JoeyLambda> Input: order ["five","four","four"]                Output: [(2,"four"),(1,"five")]                            Desired: [(1,"four"),(1,"four"),(3,"five")]
15:18:53 <JoeyLambda> Any ideas? I believe my use of "length" is silly.
15:18:54 <monochrom> I don't think cabal repl changes much other than adding more -i's and adding more libraries
15:19:04 <jophish> How does cabal search for libraries
15:19:16 <monochrom> cabal asks ghc to search for libraries
15:19:33 <jophish> I'm passing --extra-lib-dirs with the directory containing sdl2.lib, however cabal isn't picking up the library
15:19:41 <monochrom> and ghc searches for libraries in my http://www.vex.net/~trebla/haskell/sicp.xhtml
15:19:56 <jophish> monochrom: thanks!, quick!
15:20:18 <jophish> although I mean a foreign library, rather than a haskell package
15:20:24 <monochrom> then I don't know
15:20:38 <monochrom> --extra-lib-dirs should be enough
15:20:56 <acowley> Yuck, so Ricky_C needs to use the old :module +MatrixInstances syntax?
15:21:26 <monochrom> it may not come down to that.
15:21:35 <mwc> Wow, when did :load *M become a thing?
15:21:39 <acowley> monochrom: Cabal repl lets you use import more freely
15:21:44 <dulla> > repeat . repeat $ "ding dong, bannu"
15:21:45 <lambdabot>  [["ding dong, bannu","ding dong, bannu","ding dong, bannu","ding dong, bannu...
15:21:45 <monochrom> but it certainly needs :load or :add MatrixInstances before "import" makes sense
15:21:49 <dulla> hehe
15:22:06 <dulla> :t const
15:22:06 <lambdabot> a -> b -> a
15:22:19 <dulla> > map const 3 [1,2,3]
15:22:20 <lambdabot>  Couldn't match expected type ‘[t0] -> t’
15:22:20 <lambdabot>              with actual type ‘[b0 -> a0]’
15:22:39 <dulla> :t map
15:22:40 <lambdabot> (a -> b) -> [a] -> [b]
15:22:53 <dulla> shit
15:23:36 <geekosaur> did you mean (const 3)?
15:24:00 <geekosaur> JoeyLambda, I think you did not mean to use group there
15:24:01 <monochrom> map (const 3) [1,2,3]
15:24:06 <GaryTL> JoeyLambda: "JoeyLambda" Please come see during office hours on Tuesday or Thursday after 2 in HEC437D. Send me an email what time you think you can make it. This is not for homework.
15:24:07 <dulla> > map (const 3) [1,2,3]
15:24:09 <lambdabot>  [3,3,3]
15:24:18 <dulla> damn precedence
15:24:22 <geekosaur> gyg
15:24:36 <acowley> My goodness GHCi's loading rules are complicated
15:24:46 <dulla> > sum . map (const 1) $ [1,2,3]
15:24:48 <lambdabot>  3
15:25:08 <dulla> :t scanl
15:25:09 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
15:25:24 <GaryTL> Dulla: Please do not help Joey with his homework. this is against our school policy
15:25:25 * monochrom wonders why "this is not for homework"
15:25:33 <dulla> > scanl (+) 0 . map (const 1) $ [1,2,3]
15:25:34 <lambdabot>  [0,1,2,3]
15:25:36 <monochrom> oh, "this" refers to #haskell
15:25:45 <monochrom> we need to ban all pronouns
15:25:55 <dajsid> :t foldl fmap repeat (repeat repeat)
15:25:55 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ [a]
15:25:55 <lambdabot>     Expected type: a -> a
15:25:55 <lambdabot>       Actual type: a -> [a]
15:26:00 <JoeyLambda> Didn't realize. Say no more!
15:26:06 <Ricky_C> acowley: any clue how my 'at' function should look like?
15:26:08 <monochrom> ok, humanity needs to ban all pronouns. there!
15:26:10 <geekosaur> huh
15:26:26 <dmwit> monochrom: where...?
15:26:32 <monochrom> :)
15:26:38 <dulla> > scanl (+) 0 . map (const 1) $ [0..12]
15:26:40 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13]
15:26:42 <quchen> monochrom: 'm not letting dictate what can say!
15:27:01 <dajsid> is there a way to construct an 'infinite type' with haskell?
15:27:03 <geekosaur> (and I guess we have confirmation that #haskell is indeed monitored for homework...)
15:27:21 <bennofs> monochrom: cabal repl also adds the object files of c-sources specified in the cabal file
15:27:34 <quchen> dajsid: Depening on what you mean with an "infinite type".
15:27:36 <bennofs> He left, now we can finally help! :)
15:27:42 <dulla> dajsid  you just had a type error, skip the infinite list crap
15:27:46 <Ricky_C> geekosaur: That is pretty funny!
15:27:47 <quchen> dajsid: When GHC complains about an "infinite type" then that's something you can't do.
15:27:48 <JoeyLambda> lol
15:27:52 <JoeyLambda> nah don't worry
15:27:58 <JoeyLambda> i thought it was just a minor question
15:27:59 <acowley> Ricky_C: You need to take a crack at it! If you pattern match on the Matrix value, what can you do with it?
15:28:00 <JoeyLambda> guess not.
15:28:42 <monochrom> bennofs: not that easy. notice how GaryTL entered *after* the question was asked. someone is monitoring without GaryTL joining.
15:28:57 <GaryTL> bennofs: Please don't...
15:28:57 <bennofs> monochrom: o.O right
15:29:00 <dulla> > let funk = 2:7: zipWith (*) funk (tail funk) in take 10 funk
15:29:02 <lambdabot>  [2,7,14,98,1372,134456,184473632,24803586664192,4575607718570262585344,11349...
15:29:19 <monochrom> see? :)
15:29:21 <bennofs> Guess I'll have to switch to private msg then ... just jk'ing
15:29:22 <geekosaur> reminder: the channel is publicly logged
15:29:30 <dulla> > let funk = 2:0.7: zipWith (**) funk (tail funk) in take 10 funk
15:29:31 <lambdabot>  [2.0,0.7,1.624504792712471,0.5602231144897448,1.3123533167941537,0.467477545...
15:29:32 <geekosaur> someone might not even be doing the monitoring *from* IRC
15:29:48 <geekosaur> (see /topic for details)
15:30:13 <monochrom> at this point, the working hypothesis is that Flying Spagetti Monster exists :)
15:30:13 <dajsid> sneaky haskell profs?
15:30:21 * quchen thinks it's a bit awkward that we're being told not to answer certain ontopic questions here because of some school policy
15:30:24 <geekosaur> I doubt it's just haskell, even
15:30:38 <geekosaur> we used to have a homework policy in here...
15:30:45 <bennofs> lol I wonder if he just has a highlight on the homework word
15:30:58 <quchen-homework> Enjoy ♥
15:30:59 <dajsid> how would u know if something is homework or not?
15:31:13 <EvanR> you just know
15:31:18 <monochrom> an intelligent person or machine knows
15:31:26 <bennofs> hmm right, homework wasn't mentioned in the original question
15:31:44 <GaryTL> dajsid: I have my ways...
15:31:45 <geekosaur> ah, right, https://wiki.haskell.org/Homework_help
15:31:55 <init> that's scary
15:31:58 <dajsid> okay
15:32:06 <dajsid> it is the 'homework' word
15:32:16 <wolf_mozart> haskell is for application development or just to define a function?
15:32:19 <bennofs> dajsid: it wasn't there in there original question though, was it?
15:32:28 <jophish> Is it at all possible to use cl.exe on windows, rather than gcc, or am I crazy for thinking this?
15:32:30 <bennofs> wolf_mozart: haskell can be used for application development
15:32:30 <dajsid> bennofs: i just said 'homework' again and he popped up
15:32:31 <geekosaur> no, it wasn't
15:32:37 <quchen-homework> wolf_mozart: It's a general purpose programming language.
15:32:41 <monochrom> the answer is yes. the two are one.
15:32:45 <wolf_mozart> ok
15:33:32 <monochrom> dajsid: you haven't showed that other words won't trigger. in fact, the original question, without the substring, triggered just fine.
15:33:35 <wolf_mozart> like python and c++ and java is a general programming langauge? (for developing applications mostly)
15:33:38 <dmwit> dajsid: The smart scientist searches for ways to negate a hypothesis, not ways to confirm it.
15:33:41 <dulla> it does whatever you can model mathematically, which turns out to be everything
15:33:41 <geekosaur> jophish, at the moment a C compiler is used only for FFI calls and CPP; the latter shares difficulties with clang, the former requires someone to contribute code to ghc
15:33:42 <bennofs> I wonder if the people on hanging out on #haskell are really the ones that need to be protected from cheating homework though :D
15:33:45 <ReinH> It is used to define a function that describes an application.
15:33:45 <dajsid> maybe they're working with the nsa
15:33:56 <ReinH> Or at least a value that does so.
15:34:15 <monochrom> dajsid: to find out what triggers and what doesn't, you need to enumerate all strings. all of them.
15:34:17 <dulla> python is for bulk computation
15:34:22 <dulla> c++ usually for engines
15:34:27 <dajsid> monochrom: will i be bannarated?
15:34:33 <dulla> java for not really caring about anything but interop
15:34:34 <monochrom> I don't know.
15:34:37 <mniip> I don't feel comfortable not helping someone just because someone said not to...
15:34:52 <mniip> I mean it's their problem that their school doesn't allow this kind of cheating
15:34:57 <dmwit> dajsid: Depends what order your enumeration uses, I guess.
15:34:58 <dulla> java c++ for leaks erryday
15:35:06 <dmwit> dajsid: I haven't been banned for the order I've chosen, yet.
15:35:50 <geekosaur> jophish, note that ghc's windows support has historically lagged behind unix support, mostly because of lack of knowledgeable contributors. win64 support didn't happen until the haskell in industry consortium funded a windows developer to work on it.
15:36:32 <wolf_mozart> dulla i've a 50% perspicasity into your analysis
15:36:34 <ReinH> Out of all the possible IO () values, one of them is exactly the application you are trying to design.
15:36:45 <ReinH> The one you choose, however, will be slightly different in ways you won't ever fully understand.
15:36:52 <jophish> geekosaur: yeah, I usually develop on a Mac, but it was commandeered this weekend so I'm trying to get things up and running on a windows box, it's a lot more painful
15:36:59 <dulla> is there a dictionary command in this channel
15:37:15 <mniip> dulla, @src :)
15:37:31 <monochrom> ReinH: why is the one I choose slightly, subtly different?
15:37:35 <dulla> for human words, mniip
15:37:36 <quchen-homework> ReinH: I don't remember who said it, but "Haskell is a proof assistant for creating interesting proofs for very boring theorems"
15:37:44 <quchen-homework> … namely IO ()
15:37:52 <monochrom> @quote boring.theo
15:37:53 <lambdabot> No quotes match. My mind is going. I can feel it.
15:37:53 <dulla> @src perspicasity
15:37:53 <lambdabot> Source not found. Are you on drugs?
15:37:57 <ReinH> monochrom: because I've never seen a perfect program.
15:37:59 <Hijiri> @src perspicasity
15:37:59 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:38:04 <geekosaur> jophish: it is. there's a windows task force to address the bootstrapping issue of getting a ghc environment going. last I heard they were considering providing a packaged environment supporting the Platform rather than making people dig up the right versions of the right  pieces themselves
15:38:12 <ReinH> monochrom: well, for anything of sufficient complexity
15:38:21 <JoeyLambda> g'nite
15:38:24 <geekosaur> you might want to ask on the glasgow-haskell-users list about that
15:38:29 <wolf_mozart> dulla i didn't quite understand what you said
15:38:30 <jophish> geekosaur: ghc wasn't actually a problem at all
15:38:42 <geekosaur> ghc itself, no. the right supporting pieces, yes
15:38:44 <jophish> it's linking to foreign libraries on windows I struggle with every time
15:38:47 <monochrom> ah alright! I have a perfect one at http://lpaste.net/52480
15:38:51 <dulla> ?
15:38:57 <monochrom> but you're right, it is small
15:38:57 <geekosaur> someone here spent several days finding the right ncurses and getting it to link
15:39:09 <dulla> it's mostly what I see the languages used for, wolf_mozart
15:39:16 <ReinH> monochrom: I'm not trying to commit a true scotsman here, but maybe you know what I mean :)
15:39:23 <geekosaur> that's what they're trying to fix, provide an msys with all the right libraries in places where ghc will find them without screwing with paths
15:39:42 <wolf_mozart> but well,  haskell sounds like more of a language that's devoted to computer science analysis and comprehension, rather than focusing on code effeciency, because ultimately haskell code turns into dirty assembly code
15:39:58 <monochrom> but let's get crazy. I have a few perfect ones at http://lpaste.net/77374 , they use unsafeInterleaveIO
15:40:13 * geekosaur does not understand the logic behind that last "statement"
15:40:16 <dulla> low Haskell is comparable and sometimes faster than C, wolf_mozart
15:40:16 <mniip> how come there isn't inline assembly in haskell yet
15:40:32 <EvanR> wolf_mozart: everybody likes dirt, dont you see whats on sale in the checkout line
15:40:34 <bennofs> and sometimes at least 2x slower
15:40:36 <ReinH> wolf_mozart: All higher level languages turn into assembly, most of which I would classify as "dirty".
15:40:42 <wolf_mozart> so all this level of sophistication, at exuction time doesn't really make any difference from any other language
15:40:47 <jophish> mniip: a quasiquoter for inline asm!
15:40:58 <geekosaur> I thought there was an EDSL aimed at that somewhere on hackage, using ghc-api to hook it in. maybe it never got finished
15:41:05 <monochrom> mniip: I have just heard of https://github.com/PkmX/acme-shellcode/ recently from someone in #haskell-tw
15:41:07 <dulla> regardless, the interesting thing is that due to the language itself, you can usually choose your level
15:41:10 <geekosaur> since ghc-api didn't quite have all the pieces needed until relatively recently
15:41:19 <ReinH> wolf_mozart: Ok, go write your program in brainfuck then. Not all turing complete languages are equally easy to work with or provide similar tools for abstraction.
15:41:20 <bennofs> It would probably be CMM then, not asm, I guess
15:41:23 <quchen-homework> wolf_mozart: And dirty assembly code turns into solving differential equations for current in semiconductors and current in semiconductors turns into electrodynamics and electrodynamics turn into quantum electrodynamics and that tells us that that sort of reductionism is not very fruitful.
15:41:25 <mabino-pyon> wolf_mozart: it makes a difference for engineering and maintaining large programs -- most gains in runtime efficiency are obtained from using superior data structures and algorithms anyway
15:41:52 <wolf_mozart> we should all be writting code in Assembly and nevermind all this bs, but yarr
15:42:02 <ReinH> If your argument implies that brainfuck is an acceptable choice of programming language, your argument is suspect.
15:42:10 <Hijiri> quchen-homework: It means we should be configuring our computers with quantum brainwaves
15:42:24 <dajsid> haskell is just jelly of brainfuck
15:42:42 <dulla> well, we have java for that, dajsid
15:42:51 <wolf_mozart> mabino-pyon: ok
15:43:04 <ReinH> We don't need to disparage other languages to make Haskell look good.
15:43:21 <dulla> We can optimise fpga's better than competitors :^)
15:43:43 <dulla> found a late 2014 paper on it when browsing the wiki for arrows
15:44:10 <dajsid> ReinH: if you can say that haskell is better than some language with respect to X then that language is worse in that respect.. so you are implicitly disparaging that language
15:44:15 --- mode: ChanServ set +o monochrom
15:44:20 --- mode: monochrom set +b *!*@gateway/shell/panicbnc/x-mkhxjdijpjaalbta
15:44:34 --- kick: wolf_mozart was kicked by monochrom (wolf_mozart)
15:44:44 <ReinH> I'm not talking about objective statements, I'm talking about treating other languages with respect.
15:45:03 <dajsid> ah okay
15:45:12 <geekosaur> repeat troller, for the record
15:45:16 <ReinH> kk
15:45:49 * EvanR pours one out for wolf_mozart
15:45:53 <EvanR> RIP
15:45:55 <dulla> stahp
15:45:59 * dulla corks the bottle
15:46:17 --- mode: monochrom set -b+b *!*@gateway/shell/panicbnc/x-mkhxjdijpjaalbta wolf_mozart!*@*
15:47:22 <dulla> People die when they are dead
15:47:37 <Hijiri> people can't die when they are dead
15:47:42 <dajsid> ^
15:47:51 <dulla> It get harder to revive them as time goes on
15:47:52 <dajsid> unless u can meta-die
15:48:04 <dulla> besides, clinical definition is a god of the gaps scenario
15:48:28 <ReinH> dajsid: (because by doing so we treat the users of those languages with respect as well. I don't care about hurting a language's feelings)
15:48:37 <dulla> you sometimes can't unkill someone after they've been dead for a while
15:49:17 <dajsid> yeah you're right ReinH
15:49:37 <dmj`> how do you kill that which has no life
15:49:38 <dajsid> g2g
15:49:53 <ttt_fff> what's a good read on outer/inenr monad transformers? I have the intuition that when I do "OuterT (Inner)", it means taht I do a computation in a OuterT, and instead of returning a "pure a", it returns a "InnerMonad a"
15:49:58 <ttt_fff> however, I'd like more insight on this
15:50:03 <ttt_fff> if there is any more insight
15:51:08 <quchen-homework> ttt_fff: Inner is not a transformer, it's an ordinary monad (that can be created by a transformer as well of course).
15:51:20 <ttt_fff> yes, InnerMonad, and OuterMOnadT
15:51:24 <ttt_fff> InnerMonad = regular O Monad
15:51:29 <ttt_fff> OuterMonadT = MonadTransformer
15:51:56 <bennofs> ttt_fff: it's actual the other way around
15:52:33 <bennofs> ttt_fff: the computation takes place in InnerMonad (OuterMonad a)
15:52:45 <ttt_fff> what
15:52:48 <ttt_fff> why is the notation so confusing?
15:53:12 <bennofs> ttt_fff: well, take maybet for example. data MaybeT m a = MaybeT (m (Maybe a))
15:53:16 <ttt_fff> why the fuck does OuterMonadT InnerMonad a --- end up returning a computation that is like InnerMonad (OuterMOnad a) ?
15:53:28 <bennofs> ttt_fff: because there is no other way
15:53:52 <ReinH> @unmtl MaybeT IO ()
15:53:53 <lambdabot> IO (Maybe ())
15:53:58 <ttt_fff> MaybeT IO String --> IO (Maybe STring) ?
15:54:08 <ReinH> Yes.
15:54:12 <EvanR> ttt_fff: if you want a transformer over IO, doesnt it need to be an IO action ultimately?
15:54:15 <bennofs> ttt_fff: try implementing bind for Maybe (IO String). You will find it is impposible
15:54:20 <monochrom> can you design a better notation?
15:54:27 <lpaste> a revised “HW 6 (Revised) EDIT”: “No title” at http://lpaste.net/83959
15:54:28 <ttt_fff> fuck
15:54:31 <mniip> in lens, what is reponsible for something that cannot be read, but can be set
15:54:33 <mniip> Setter?
15:54:37 <ReinH> data MaybeT m a = m (Maybe a)
15:54:39 <ttt_fff> now I need to write my own monad transformer instead of just using ReaderT
15:54:40 <bennofs> mniip: yes
15:54:49 <bennofs> ttt_fff: ReaderT is the exception
15:54:51 <ReinH> newtype, actually
15:54:54 <mniip> https://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Setter.html#t:Setter
15:54:57 <ttt_fff> damn it, what'sa  good tutorial on how to write my own monad transformers ?
15:55:01 <mniip> this suggests that you can 'over' a Setter
15:55:04 <mniip> how would that work
15:55:05 <EvanR> and ExceptionT is the rule
15:55:10 <lpaste> a revised “HW 6 (Revised)”: “No title” at http://lpaste.net/83958
15:55:12 <monochrom> haha EvanR
15:55:24 <stelleg> is there some way to enforce positive KnownNats other than creating a unary Nat representation?
15:55:45 <bennofs> ttt_fff: ReaderT is actually ddefined as data ReaderT r m a = ReaderT (r -> m a), so the ((->) r) is on the outside
15:56:12 <ttt_fff> bennofs: waht does that mean?
15:56:21 <ttt_fff> oh, so I don't ahve to write my own
15:56:30 <ttt_fff> wtf, so ReaderT is on the outside, but MaybeT is on the inside?
15:56:34 <ttt_fff> now I'm really confused
15:56:37 <bennofs> ttt_fff: in fact, you can easily write a function to turn f (a -> b) into a -> f b for any Functor f
15:56:51 <ttt_fff> do monad transformers are just like "yo, I'm going to pick if I'm outside or inside ... and if you're trying to learn how moand transformers work, then fuck you" ?
15:56:58 <bennofs> ttt_fff: I think ReaderT is the only monad transformer that can live on the outside
15:57:33 <bennofs> ttt_fff: all others need to be inside
15:57:44 <ttt_fff> bennofs: cool, thanks for clarifyingthis
15:58:06 <mpickering> stelleg: Can you explain a bit more what you mean?
15:58:13 <lpaste> matt3148 pasted “Kernel Prototype” at http://lpaste.net/3956877804150194176
15:58:28 <bennofs> ttt_fff: the reason is this. consider your base monad is IO. if Maybe for example would live on the outsie, it would mean that you can decide whether some MaybeT IO a action will return Nothing or Just without even running the IO!
15:58:28 * matt3148 didn't realise that would happen
15:58:45 <stelleg> mpickering: sure, I want n to be a nat >= 1
15:58:55 <stelleg> mpickering: I tried KnownNat (n - 1)
15:59:00 <stelleg> did not work
15:59:05 <nschoe> Hi! I feel stupid, but I can't seem to rewrite this function '\(x, y) -> y - x' just with fmap, fst, and snd. I want to apply that function to a [(Int, Int)] with "map", and I wanted to use point-free style. Am I missing something obvious?
15:59:12 <ttt_fff> well
15:59:21 <ttt_fff> I thought it would just return (Just IO action) or Nothing
15:59:29 <mpickering> Can you not have n ~ Succ m ?
15:59:37 <mpickering> something like that
15:59:41 <ttt_fff> bennofs: I (incorrectly) thought MaybeT IO a would return either (Just IO action) or Nothing
15:59:53 <ttt_fff> so I run a computation, which may or may not return an IO action to be executed at a later point
15:59:55 <bennofs> ttt_fff: so consider liftIO getLine >>= \x -> if x == "yes" then return 3 else mzero
15:59:55 <mpickering> I've not played around much with the GHC.TypeLiterals stuff
15:59:57 <geekosaur> nschoe, I think because you need the parameter in two places you are going to land in the function applicative/monad
16:00:08 <Eduard_Munteanu> > uncurry (flip (-)) (1, 3)
16:00:09 <lambdabot>  2
16:00:16 <bennofs> ttt_fff: how could that be of type Maybe (IO Int) ?
16:00:31 <mpickering> then type Positive n = n ~ m + 1? something like that anyway
16:00:49 <Eduard_Munteanu> nschoe, does the above help? Or do you really want fst and snd?
16:00:54 <ttt_fff> bennofs: that would be of bype IO (Maybe Int)
16:00:59 <syntaxide> How does one denote that a type constructor take a parameter from a type class? ie MyType Num
16:01:00 <ttt_fff> it's an IO action that returns a Maybe Int
16:01:04 <nschoe> Eduard_Munteanu, OMG this is even better that fst and snd, indeed. Thanks
16:01:13 <stelleg> mpickering: hmm not sure
16:01:23 <bennofs> ttt_fff: yes :) and that's the only way monad transformers make sense
16:01:52 <init> @type uncurry subtract (1,3) -- this could work too, because subtract is flip (-)
16:01:53 <lambdabot> Num c => c
16:02:05 <init> > uncurry subtract (1,3) -- this could work too, because subtract is flip (-)
16:02:07 <lambdabot>  2
16:02:20 <ttt_fff> bennofs: I will think more about this; thanks for all your time / help
16:02:21 <nschoe> Eduard_Munteanu, But then...I don't even understand why that works... (-) is of type : Num a => a -> a -> a
16:02:28 <nschoe> Then why i it working on a pair?
16:02:38 <geekosaur> :t uncurry
16:02:39 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:03:01 <Eduard_Munteanu> syntaxide, you can't
16:03:20 <nschoe> Ah! Okay. Well very interesting. Thanks!
16:03:52 <Eduard_Munteanu> syntaxide, there used to be syntax like   data Num a => MyType a = ...   but it didn't perform as you'd expect.
16:04:17 <Eduard_Munteanu> syntaxide, type functions must be total, for rather obvious reasons if you think about it.
16:04:42 <init> > ((-) <$> snd <*> fst) (1,3) -- this is another way, using functor/applicative
16:04:42 <ReinH> syntaxide: It's better to keep those constraints at the use site anyway, like describeMyType :: Num a => MyType a -> String
16:04:43 <lambdabot>  2
16:04:57 <syntaxide> Okay, thanks.
16:05:00 <quchen-homework> syntaxide: This might be of interest: https://github.com/quchen/articles/blob/master/fbut.md#imposing-constraints-on-data-types
16:05:10 <dulla> geekosaur  (a -> b -> c) -> ((a,b) -> c) is a bit more descriptive
16:05:28 <drewbert> I installed ghc and cabal using the downloads on their websites, but for some reason now cabal does not realize that it or ghc are installed?
16:05:43 <geekosaur> sure, as map :: (a -> b) -> ([a] -> [b]) is. try getting ghc to output that :p
16:06:03 <dulla> it's descriptive, not valid
16:06:07 <drewbert> http://dpaste.com/1MPYBAZ
16:06:42 <mniip> [03:04:45] <dulla> it's descriptive, not valid
16:06:46 <mniip> pretty sure it is valid
16:06:53 <dulla> 2 bade
16:07:05 <dulla> haskell is not lisp
16:07:22 <geekosaur> I think they meant the opposite, it was valid but not sufficiently descriptive
16:07:48 <dulla> it's valid, but it makes the associativity more explicit, iirc
16:08:43 <nschoe> init, ah! I think this is what I first had in mind, indeed. I was a bit confused. Thank you
16:09:05 <geekosaur> drewbert, it's looking for ghc-as-a-library. not that that helps since it should be installed with the compiler... I think we need to know more
16:10:32 <drewbert> geekosaur: Here's a more detailed solver error. http://dpaste.com/1V86Y85 It's linux mint 16 petra on a 64 bit system.
16:11:43 <mpickering> stelleg: https://gist.github.com/mpickering/5189ef57d156b31e92dc
16:11:50 <mpickering> something like that works
16:12:58 <stelleg> mpickering: oh nice, thanks!
16:14:56 <mpickering> stelleg: I just updated it with a nicer version
16:16:47 <stelleg> mpickering: oh nice
16:16:49 <drewbert> geekosaur: Here are my ghc settings from http://dpaste.com/2AKHFW4
16:19:46 <geekosaur> drewbert: I think the output of `cabal sandbox hc-pkg list` might be more helpful here
16:19:58 <stelleg> mpickering: thanks for the help
16:20:39 <drewbert> geekosaur: http://dpaste.com/3157EBD
16:22:23 <funfunctor> hi
16:23:17 <geekosaur> huh. it's certainly there, might need to run that cabal install with -v3 and then hope someone who knows cabal-install internals better can help with diagnosis
16:23:20 <geekosaur> sorry :(
16:24:29 <drewbert> geekosaur: I reinstalled ghc with "make install" before sending you that, and I just tried reinstalling yesod-bin and it worked.
16:24:49 <drewbert> geekosaur: so my problem is solved, but I'm not sure what the problem was... just that it was there.
16:24:51 <geekosaur> odd
16:25:00 <drewbert> geekosaur: sorry to ruin your debugging help
16:26:14 <drewbert> geekosaur: Thank you a bunch though.  I've had a lot of frustrations with cabal lately.  I'm new to haskell, and I mostly love the language, but cabal has been a constant nightmare.  It's nice to not have to face it alone.
16:26:29 <geekosaur> sadly, cabal is not the real problem
16:26:37 <drewbert> Haha, it's me.
16:26:49 <geekosaur> cabal is actually hiding most of the nightmare; things go south when it fails. ghc is ... rather odd
16:27:27 <funfunctor> anyone got any recommendations on a priority queue implementation? My software is GPL so can't use a BSD package
16:27:27 <geekosaur> basically it does some things with libraries that make them a lot faster, but mean that if you don't have things exactly correct then it all blows up in your face
16:27:57 <bennofs> funfunctor: you cannot use BSD in GPL? o.O didn't know that
16:28:12 <geekosaur> and then it will encourage you to do things that lead to your package database not being exactly correct to ghc's own standard
16:28:25 <geekosaur> cabal tries to prevent this, not always successfully
16:28:29 <funfunctor> I only really need to raw basics, push/pop and isempty
16:28:54 <funfunctor> bennofs: I can't link BSD symbols with GPL symbols
16:29:02 <geekosaur> wat
16:29:11 <funfunctor> thats what the LGPL is for
16:29:14 <geekosaur> usually it's the other way around, linking GPL libs to a BSD program is bad
16:29:42 <funfunctor> well whatever, point is I need a  priority queue implementation
16:29:50 <mpickering> psqueues is good
16:29:52 <geekosaur> GPL programs can use BSD libs fine; GPL libs may have to be careful with how they themselves are licensed
16:30:16 <funfunctor> geekosaur: this is a GPL *library* ;)
16:30:18 <geekosaur> (i.e. "GPL but includes such and such BSD-licensed code")
16:31:21 <geekosaur> also if you "can't use BSD" then you can't use most of the libs that come with ghc
16:31:41 <geekosaur> I mean, what's the difference between psqueues and containers that you can use the latter but not the former?
16:31:52 <geekosaur> or, even more to the point, base?
16:32:23 <funfunctor> how can anyone write a GPL library in Haskell if what your saying is true?
16:32:26 <kaidelong> IIRC for the purposes of the GPL, BSD is compatible
16:32:31 <geekosaur> ^
16:32:43 <kaidelong> you only have to worry if your liscense if "less free" than the GPL
16:32:49 <funfunctor> god I hate this legal shit..
16:33:00 <kaidelong> so people can't reliscense it to something other than BSD
16:33:05 <kaidelong> unless it's the GPL
16:33:10 <geekosaur> there are some corner cases to watch out for in some cases, but broadly speaking BSD libraries are compatible for use with GPL software. The reverse is what's often problematic
16:33:13 <kaidelong> or some other non-conflicting license
16:33:26 <kaidelong> geekosaur: why is the reverse problematic?
16:33:39 <hpc> kaidelong: BSD is more permissive
16:33:43 <kaidelong> BSD licenses allow you to reliscense to the GPL if you want, so there should be no conflict
16:33:49 <funfunctor> yes but don't I have the reverse case since I am writing a library
16:33:50 <kaidelong> hpc: exactly
16:33:54 <hpc> if you relicense a GPL library as BSD, people can do more things with it
16:34:00 <geekosaur> only if it's your library that you are relicensing
16:34:02 <hpc> notably, they can now do things that violate GPL
16:34:13 <kaidelong> hpc: but that's not what you're doing if you license *your* code as BSD and it links to GPL code
16:34:20 <kaidelong> I'm pretty sure this does not violate the GPL
16:34:39 <bennofs> kaidelong: but the whole thing would have to be licensed under GPL, no?
16:34:40 <funfunctor> then whats the point of LGPL
16:34:48 <kaidelong> if someone relicensed your code as something not GPL compliant, they would be violating the GPL
16:34:58 <EvanR> you can do whatever you want with your own code
16:35:14 <kaidelong> but it's okay to license your own code BSD
16:35:20 <kaidelong> in fact I think GHC does just this
16:35:31 <funfunctor> EvanR: I know that but I want to publish it for general use in other components
16:35:55 <kaidelong> funfunctor: the GPL dependency still means someone can't make your BSD code propietary without removing the dependency on GPL code
16:36:05 <EvanR> funfunctor: then use LGPL?
16:36:09 <EvanR> or BSD or MIT
16:36:25 <funfunctor> I don't want to, I want the terms of the GPL
16:36:43 <kaidelong> well you could do what Trolltech etc do
16:36:44 <EvanR> by choosing that, you are making a decision to try to make all software richard stallman's version of free software
16:36:58 <kaidelong> release under the GPL and charge a ransom if they want rights to a less restrictive liscense
16:36:58 <EvanR> you just need to come to terms with it
16:36:59 <funfunctor> my question was about a  priority queue implementation not how I should re-license my project
16:37:27 <geekosaur> I don't see that you need to relicense, or even worry about the license
16:37:40 <bennofs> funfunctor: anyway, I think you should be fine using BSD licensed code in a GPL licensed product
16:38:22 <funfunctor> project is going into a domain were folks like to sue and steal like no other
16:38:25 <funfunctor> telco's
16:39:15 <bennofs> funfunctor: if you want to make sure, ask a lawyer
16:39:19 <bennofs> :)
16:39:31 <funfunctor> bennofs: I did!
16:40:01 <drewbert> glguy: I finally got around to installing your GhcPkgUtils.  You are a saint.  Thank you!
16:41:46 <funfunctor> so psqueue does not really fit my needs any way.. I think a heap would be a better implementation for O time
16:42:47 <bennofs> @hackage psqueues -- claims to be more efficient
16:42:47 <lambdabot> http://hackage.haskell.org/package/psqueues -- claims to be more efficient
16:43:02 <monochrom> yes, psqueue does a few more things (and so a bit slower) than just priority queue
16:43:53 <funfunctor> I think it would perhaps be easier to have my own custom implementation that is minimal
16:43:57 <funfunctor> I don't really need much
16:44:34 <monochrom> there are several "just priority queue" packages on hackage. but I don't know which one is the fastest
16:45:20 <ansible1> hey all; trying to compile persistent-sqlite on ARM.  I guess this linkage error:
16:45:28 <ansible1> Loading package persistent-sqlite-2.1.1.2 ... linking ... ghc: /home/bananapi/code/persistent/persistent-sqlite/dist/build/libHSpersistent-sqlite-2.1.1.2.a: unknown symbol `_GLOBAL_OFFSET_TABLE_'
16:45:31 <monochrom> it is interesting that I have never needed just priority queue for my own use but I need the full priority search queue
16:45:59 <monochrom> (it is why I paid attention to psqueue and predecessors)
16:46:01 <ansible1> I guess that indicates the lib didn't get linked correctly?  not sure.  there's a C file in the project.
16:46:14 <funfunctor> monochrom: maybe Data.Heap ?
16:46:33 <bennofs> ansible1: this sounds like you somehow mixed static / dynamic libs in the wrong way
16:46:41 <geekosaur> ansible1, if I had to guess it wants position independent code. but then I do not understand why it is a .a instead of a .so. unfortunately I am not familiar with ARM
16:46:53 <monochrom> to be fair, my use doesn't need the absolutely highest efficiency. I just have maybe 1 operation per 20 seconds.
16:47:08 <geekosaur> (which is what bennofs said, somewhat expanded)
16:47:19 <funfunctor> monochrom: this is for frames coming in from a software defined radio
16:47:28 <funfunctor> I expect lots of data
16:47:32 <ansible1> I wonder if the flag for PIC isn't working for llvm
16:47:40 <monochrom> yeah, but I don't know which heap is fastest
16:48:07 <funfunctor> ok thx, I guess ill go have a coffee and run some tests..
16:48:08 <bennofs> http://stackoverflow.com/questions/6976559/comparison-of-priority-queue-implementations-in-haskell might be interesting
16:48:18 <funfunctor> bennofs: thx
16:48:25 <monochrom> nice
16:48:46 <mseeks> any idea why ghci sometimes prints a `"` and hangs after a command? this is specifically after trying to DER-encode an `[ASN1]`
16:49:00 <sebastian_> hi all, I'm facing this error while trying to install ghc-mod: https://github.com/kazu-yamamoto/ghc-mod/issues/437 . I just need any version. how do I install ghc-mod?
16:49:20 <funfunctor> be back later..
16:49:25 <ab9rf> mseeks: whatever code you are using to generate a string is bottoming
16:51:04 <lpaste> matt1 pasted “Strange types” at http://lpaste.net/120869
16:51:05 <mseeks> ab9rf: you're right, it's actually bottoming while evaluating the [ASN1]
16:51:17 <geekosaur> sebastian_, as I read that you need to install an older Cabal library to build ghc-mod. I suggest you build ghc-mod in a sandbox and use --constraint='Cabal == 1.22.*'
16:51:43 <matt1> Ok i just pasted an error I got with yesod, can anyone explain why I get the error at the end if I remove the type signature for renderComments'?
16:52:24 <atomiccc> hey guys, any suggestions on a starting project that will give me a real idea of haskell's power?  something to strive to build through reading tutorials
16:52:28 <matt1> I feel like ghc should be able to figure out that the 0 is an Int
16:53:03 <geekosaur> matt1, oddly enough, no. nothing there lets it figure out it's not, say, Integer
16:53:37 <geekosaur> there is defaulting but that only applies when you stick to some basic typeclasses from Prelude. include any others and it won't fire and ghc can't tell what type to use
16:54:44 <geekosaur> (pedantic: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4 shows the circumstances when defaulting will work)
16:55:25 <geekosaur> since you have a non-"standard Haskell" class there, specifically ToMarkup, it won't use defaulting
16:55:33 <athan> atomiccc: Check out the scotty / blaze / persistent web server tutorial
16:55:39 <monochrom> matt1: sometimes, GHC figures out that 0 is an Integer
16:55:49 <athan> but FP is way beyond the web lol
16:55:49 <geekosaur> there has been discussion of how to teach ghc to support other typeclasses but nothing currently exists
16:56:28 <matt1> geekosaur: oh well, it's not really that big a deal but I was wondering what was going on
16:56:30 <matt1> thanks
16:56:32 <atomiccc> athan, excellent thank you.  i'm doing the tryhaskell.org tutorial now and will play with making this webserver next
16:56:51 <matt1> atomiccc: I suggest learn you a haskell
16:57:03 <athan> atomiccc: It's pretty much the best language
16:57:40 <atomiccc> thanks, i've come across that tutorial also matt1, i'll check it out
16:57:52 <geekosaur> defaulting is quite convenient for simple stuff, but is prone to cause this kind of confusion. it's rather annoying that way
16:58:17 <atomiccc> athan, seems very cool... i had thought it was some esoteric language from the past and came across reference too it recently, seems it is a lot cooler than i thought
16:58:27 <atomiccc> to it
16:58:39 <athan> Yeah it's insane lol
16:58:51 <athan> I've never seen anything like this community or the knowledge made, before
16:59:17 <athan> atomiccc: It's even easy to make compilers
16:59:49 <atomiccc> nice :-) the syntax is like nothing i've ever used so i'm intimidated
17:00:10 <athan> you'll get it :) It's way more symbolic than other languages
17:00:17 <athan> and "virtual"
17:00:50 <atomiccc> thanks :-)
17:01:38 <athan> :) ping us if you get stuck / want to learn more!
17:04:22 <cfoch> hello
17:04:30 <cfoch> here -> https://github.com/haskell/cabal/blob/master/cabal-install/Main.hs#L864
17:04:40 <cfoch> where is configPackageDBs imported from?
17:06:56 <cfoch> I am trying to find it... but I cannot find what line it uses to import it
17:07:14 <cfoch> I think it is related to Cabal/Distribution/Simple/Setup.hs
17:07:21 <bennofs> cfoch: https://github.com/haskell/cabal/search?utf8=%E2%9C%93&q=configPackageDBs
17:07:33 <bennofs> cfoch: Cabal/Distribution/Simple/Setup.hs
17:07:36 <sebastian_> geekosaur: unfortunately no. I did exactly that and got the same compile error. do you have another idea?
17:08:38 <geekosaur> no, sorry
17:08:51 <geekosaur> I think you'll have to wait for the ghc-mod devs to fix the bug
17:08:57 <bennofs> cfoch: it is imported by the first import statement
17:09:25 <bennofs> cfoch: it's a field member of GlobalFlags I think, so GlobalFlags(..) imports ot
17:09:29 <bennofs> s/ot/it
17:12:02 <cfoch> I am importing it in cabal/cabal-install/Distribution/Client/Init.hs
17:12:09 <cfoch> and I get
17:12:12 <cfoch> "configPackageDBs' is not a (visible) constructor field name"
17:13:07 <cfoch> wait... something more interesting "Not in scope: `configPackageDBs'"
17:14:19 <cfoch> so I copypasted all the first import statement and I get
17:14:25 <cfoch> "Not in scope: `configPackageDBs'"
17:14:58 <cfoch> bennofs: isn't this statement importing it?
17:15:08 <bennofs> cfoch: oh, probably the second
17:15:22 * hackagebot shelly 1.6.0.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.0.1 (GregWeber)
17:15:24 * hackagebot network-attoparsec 0.10.0 - Utility functions for running a parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.10.0 (solatis)
17:15:51 <cfoch> the same behavior :S Not in scope
17:15:53 <bennofs> cfoch: hmm, no. it should really be the first
17:16:02 <bennofs> cfoch:
17:16:10 <bennofs> cfoch: import Distribution.Client.Setup (ConfigFlags(..))
17:18:12 <cfoch> bennofs: http://fpaste.org/188446/14244814/
17:18:26 <cfoch> the same problem..., actually I tried that first
17:18:43 <bennofs> cfoch: you forgot the s at the end
17:18:50 <bennofs> Not in scope: configPackageDB'
17:18:56 <bennofs> Perhaps you meant `configPackageDBs'
17:22:47 <mseeks> any idea how to "lift" a value of type `Either Err a` into the `Either String` monad?
17:23:00 <bennofs> @hoogle mapEitherT
17:23:01 <lambdabot> No results found
17:23:08 <mseeks> besides doing `case of`
17:23:10 <cfoch> bennofs: and what about infoPackageDBs
17:23:11 <cfoch>  ?
17:23:29 <mseeks> not a big deal, i'll just use case
17:23:39 <cfoch> it says "Not in scope: `infoPackageDBs'"
17:23:53 <bennofs> mseeks: you can use bimapEitherT
17:24:10 <bennofs> @let import Control.Monad.Trans.Either
17:24:11 <lambdabot>  .L.hs:61:1:
17:24:11 <lambdabot>      Failed to load interface for ‘Control.Monad.Trans.Either’
17:24:11 <lambdabot>      Perhaps you meant
17:24:15 <bennofs> :|
17:24:31 <mseeks> bennofs: cool, thanks!
17:24:38 <mseeks> saw it
17:25:15 <bennofs> cfoch: import Distribution.Client.Setup (InfoFlags(..))
17:30:22 * hackagebot network-attoparsec 0.10.1 - Utility functions for running a parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.10.1 (solatis)
17:36:24 <cfoch> bennofs: sorry, bother you again, and how can I import https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/Setup.hs#L1069 ?
17:37:32 <bennofs> cfoch: you can write import ModuleName ( whateverYouWantFromThatModule )
17:37:38 <bennofs> cfoch: that should always work
17:38:30 <bennofs> cfoch: so import Distribution.Client.Setup (defaultInfoFlags)
17:38:33 <cfoch> http://fpaste.org/188452/48264814/
17:38:43 <cfoch> bennofs: ^
17:39:03 <cfoch> I was doing what you were saying
17:39:10 <MrFlibble> the toolbar of v3.0 of my IRC client is coming along nicely: http://i42.io/toolbar.png
17:39:20 <bennofs> cfoch: I think you just can't import it then
17:39:30 <bennofs> cfoch: if something is not exported, there is no way around that
17:40:47 <shapr> MrFlibble: Is that done in Haskell?
17:41:00 <Gurkenglas> This combination of lines:
17:41:10 <Gurkenglas>      parse :: ClockTime -> String -> [Player]
17:41:10 <Gurkenglas> 	 parse file = map ([name, points] -> Player name (read points + offset)) $ tail $ lines file
17:41:17 <MrFlibble> shapr: would you be impressed if it was?
17:41:25 <shapr> MrFlibble: yeah, that would be cool
17:41:50 <Gurkenglas> (With the parses on the same height) says I am using the illegal type signature "ClockTime -> String -> [Player] parse file"
17:41:53 <shapr> MrFlibble: is that built with Haskell?
17:42:16 <Gurkenglas> Nevermind, I used a tab on the second line *hangs head in shame*
17:42:35 <MrFlibble> shapr: nah, it is written using a pragmatic programming language.
17:42:45 <shapr> MrFlibble: oh, Agda or Ivory?
17:43:23 <MrFlibble> pragmatic. :)
17:43:27 <shapr> MrFlibble: Would you like to write an irc client in Haskell? :-)
17:43:36 <shapr> I can point you to introductory documentation.
17:43:44 <MrFlibble> shapr: no as doing so with give me a stroke.
17:43:53 <MrFlibble> would*
17:43:56 <shapr> MrFlibble: Ah, so why are you here on #haskell?
17:44:07 <MrFlibble> I plan on learning Haskell soon
17:44:16 <MrFlibble> when I can find the time
17:45:01 <shapr> MrFlibble: I've seen several IRC clients written in Haskell, I can point you to them when you have time to learn ...
17:45:39 <MrFlibble> shapr: nah, my IRC client is quite mature and doesn't need rewriting in another language; an unsuitable langauge at that
17:46:12 <shapr> MrFlibble: sounds like you already have strong opinions about Haskell without having learned Haskell.
17:46:45 <shapr> MrFlibble: I think that's unsuitable :-P
17:47:01 <mniip> I'm writing an irc client in haskell right now
17:47:05 <mniip> or rather, an irc bot
17:47:12 <shapr> mniip: Is the source for your IRC client online?
17:47:12 <MrFlibble> first I need to be convinced that Haskell isn't snake oil.
17:47:16 <ReinH> Haskell is actually a highly suitable language for networking.
17:47:42 <refefer> MrFlibble: what leads you to believe it might be?
17:47:42 <bitemyapp> Haskell runs the gamut (IMO) of what you'd use: Java, Go, Ruby, Python, Node.js, JS, Prolog, and OCaml for.
17:47:48 <shapr> MrFlibble: It's been my experience that most people have to either convince themselves, or have an open mind in order to be convinced.
17:47:57 <bitemyapp> Ivory et al. stretch that a bit depending on how you feel about doing embedded at arms length.
17:48:15 <shapr> MrFlibble: You've already characterized Haskell as unsuitable, and not pragmatic. It doesn't sound like you want to be convinced.
17:48:53 <mseeks> MrFlibble: it's a little presumptuous to do this and expect people to stumble over themselves explaining why you should learn haskell
17:48:58 <MrFlibble> refefer: the claim is that Haskell is pure, I am unconvinced because as far as I can tell the mutable reference feature of its IO monad effectively renders it impure.
17:49:16 <mniip> shapr, not yet
17:49:22 <shapr> mniip: ah, too bad, would be nice to see
17:49:32 <ReinH> MrFlibble: what does "pure" mean to you?
17:49:40 <mniip> shapr, it's not elegant at all
17:49:43 <MrFlibble> not mutable state.
17:49:45 <MrFlibble> no*
17:50:14 <mniip> I'm writing it for non-academic purposes
17:50:35 <shapr> mniip: shocking :-P all of my Haskell has been written for non-academic purposes
17:50:53 <shapr> Well, except for one word count demo algorithm I did last year.
17:51:01 <mniip> what if I told you
17:51:04 <shapr> I got points in class for writing that one.
17:51:05 <mniip> it uses Data.Dynamic
17:51:07 <ReinH> That's not what "pure" means.
17:51:08 <MrFlibble> the claim is that Haskell separates the pure and impure parts but as far as I am concerned that makes the language impure.
17:51:09 <shapr> mniip: oh no!
17:51:22 <shapr> mniip: I must shield my eyes!
17:51:28 <MrFlibble> and there are far better impure langauges than Haskell
17:51:35 <shapr> mniip: ok, I'm just joking, I still want to see it when you have it online.
17:51:53 <ReinH> MrFlibble: I'm not sure how you can make that claim without knowing Haskell.
17:51:53 <shapr> MrFlibble: Well, you have your conclusion.
17:51:53 <orzo> what's a far better one
17:51:57 <koala_man> MrFlibble: would you say that any language that can read and write files is necessarily impure?
17:51:58 <shachaf> MrFlibble: OK. Fortunately "pure" is pretty meaningless.
17:52:02 <bennofs> MrFlibble: while it is possible to do unsafe stuff in haskell or write all of your code in IO, this is not ideomatic use. The fact that the language encourages separation of impure/pure parts of your code is much more important that it rigorously enforcing it (and you really have to explicitly tell the compiler if you want to do unsafe stuff)
17:52:08 <ReinH> MrFlibble: But now that you've made your mind up, we can stop talking about it.
17:52:15 <shapr> ReinH: Yeah, I'm with you :-)
17:52:23 <shapr> I'm more interested in learning more Haskell, or teaching what I know...
17:52:35 <shachaf> MrFlibble: Fortunately you're free to use better languages as you see fit.
17:52:55 <orzo> i think haskell is pretty good for impure code
17:53:00 <MrFlibble> bennofs: there are far better langauges that let me mix pure and impure.
17:53:03 <orzo> it provides excelent concurency features
17:53:18 <bennofs> MrFlibble: the point is, haskell doesn't let you *mix* pure and impute
17:53:22 <shapr> Yeah, software transactional memory is amazing
17:53:29 <MrFlibble> bennofs: semantics
17:53:36 <bennofs> MrFlibble: it teaches you how to *separate* pure and impute
17:53:41 <shapr> MrFlibble: wait, so you do actually want to learn, or are you trolling?
17:54:06 <hodapp> MrFlibble: I'm not sure if you're aware of this, but in the land of programming, dismissing "semantics" is throwing out about 95% of what is relevant.
17:54:16 <ReinH> shapr: I think that ship has already sailed.
17:54:48 <shapr> ReinH: I think so too, but I'll give it another few lines...
17:54:55 <shapr> I already have my funny hat on...
17:54:58 <MrFlibble> bennofs: you are claming that pure haskell code can't do I/O? nonsense mate.
17:55:06 <bennofs> MrFlibble: I didn't say that
17:55:15 <bennofs> MrFlibble: I just said that haskell doesn't make it easy to do that
17:55:17 <orzo> what languages have STM in as nice a form as haskell?  i'm not doubting it's existence, just nothing's comming to mind
17:55:23 <bennofs> MrFlibble: it's opt-in, rather than opt-out
17:55:24 <ReinH> shapr: My "bad actor" bingo sheet is now full.
17:55:27 <shapr> orzo: I don't know of any
17:55:38 <shapr> ReinH: yeah
17:55:46 <refefer> orzo: I know scala has one
17:55:51 <shapr> MrFlibble: Ok, so... if you want to learn about Haskell, people are happy to teach you...
17:55:52 <refefer> no idea on if it's any good, of course
17:55:56 <nshepperd_> grump. why would Text.Parsec export a broken Stream Bytestring m Char instance by default
17:56:00 <MrFlibble> C++11 introduced constexpr .. terrific addition to a practical, pragmatic, sensible, real world language.
17:56:07 <orzo> MrFlibble: Ignore matters of "purity" and learn about haskell's STM support.
17:56:15 <shapr> MrFlibble: but if you wish to hold forth on how Haskell cannot do what it claims to do, I shall escort you out of this community.
17:56:30 <bennofs> MrFlibble: you basically have to put a big warning sign saying "Hey I really really know what I'm doing and I want this" before you can do impure things from pure code
17:56:38 <fread2282> is there an efficient way to parse mifix operators?
17:56:47 <MrFlibble> bennofs: kool aid mate.
17:56:50 <hodapp> MrFlibble: Sorry, which language would that be?
17:56:51 <Cale> orzo: None. The only languages which have a shot at that are those who control effects in a similar way that Haskell does, and the number of such languages is already low.
17:56:57 <shapr> MrFlibble: ok, that's it... be nice ...
17:57:14 <Cale> orzo: Probably Idris will eventually do something similar.
17:57:37 * hodapp looks at the yellowing post-it on his wall that says "Learn Idris"
17:57:40 <bennofs> MrFlibble: ok, so how would you do impure things from pure code without using functions that have a big "unsafe" in their name or are generally discouraged? (like error)
17:58:00 <mniip> shapr, why though
17:58:05 <mniip> it's not going to be interesting
17:58:29 <shapr> MrFlibble: the rules here are, 'be nice, or else' and you've dismissed others attempts to give you helpful insights
17:58:30 <MrFlibble> the point is that allowing I/O to memory (rather than to say a file) whilst equivalent does encourage impure designs.
17:58:48 <hodapp> MrFlibble: What is "I/O to memory"?
17:58:52 <shapr> yeah, what?
17:59:13 <MrFlibble> mutable reference feature of IO monad
17:59:25 <bennofs> MrFlibble: you don't write your whole program in IO
17:59:31 <MrFlibble> the point is that allowing I/O to memory (rather than to say a file) whilst equivalent does encourage impure designs.
17:59:39 <bennofs> MrFlibble: ?
17:59:42 <shapr> We saw that line before, I still don't understand it.
18:00:08 <shapr> MrFlibble: It still sounds like you have strong opinions on Haskell, without having learned much about the language.
18:00:12 <ReinH> You don't get to make up your own definition of "pure" and then use it to claim that Haskell is not pure.
18:00:22 <ReinH> That's not how that works.
18:00:23 <MrFlibble> Haskell is not pure.
18:00:23 * hackagebot fltkhs 0.1.0.0 - FLTK bindings  http://hackage.haskell.org/package/fltkhs-0.1.0.0 (deech)
18:00:28 --- kick: MrFlibble was kicked by shapr (Kicked by shapr)
18:00:29 <ReinH> What did I just say.
18:00:30 --- mode: ChanServ set +o geekosaur
18:00:32 <ReinH> Thanks.
18:00:34 --- mode: geekosaur set -o geekosaur
18:00:36 <shapr> be nice...
18:00:37 <shapr> or else
18:00:47 * shapr sighs
18:00:47 <silver> trolling is so 2008
18:00:49 <dulla> Haskell is pretty damn pure
18:00:52 <nshepperd_> thank god
18:00:54 <shachaf> ReinH: Making up a meaning for "pure" is what everyone else does...
18:00:58 <hodapp> silver: I'll have you know I was trolling in 2004 and I was good at it.
18:01:07 <ReinH> shachaf: but I didn't like his...
18:01:08 <shapr> nshepperd_: sorry, was hoping this person would start to listen
18:01:09 <geekosaur> last I checked eve/up
18:01:10 <shapr> MrFlibble: Hi, that's a warning
18:01:12 --- mode: ChanServ set +o geekosaur
18:01:24 <shapr> MrFlibble: being removed from this channel by me was a hint
18:01:28 <dulla> The unspoken rule of trolling, do it to a deserving audience
18:01:38 <MrFlibble> shapr: Je Suis Charlie mate. Haskell is not pure.
18:01:44 <shapr> hahah
18:01:45 <geekosaur> lastI checked even gcc used a definition of "pure" similar to Haskell's, as an attribute you could decorate functions with
18:01:48 <shapr> geekosaur: go for it
18:02:10 <dulla> So it fits the definition of purity to the nines
18:02:12 --- mode: geekosaur set +b *!*@05415a00.skybroadband.com
18:02:12 --- kick: MrFlibble was kicked by geekosaur (MrFlibble)
18:02:17 <dulla> Ding Dong Bannu
18:02:19 --- mode: ChanServ set +q $a:LunarJetman
18:02:35 * shapr shrugs
18:02:41 --- mode: geekosaur set -o geekosaur
18:02:41 <hodapp> Someone tells another IRC channel that #haskell is full of idiots in 5...4...3...
18:02:46 <dulla> Everyone loves a little stanry roo
18:02:47 <shapr> hodapp: hahaha
18:03:05 <evenex> ...he really just equated getting kicked from an irc channel with the charlie hebdo massacre
18:03:06 <geekosaur> sometimes tempting
18:03:08 <evenex> oh, internet
18:03:18 <shapr> evenex: yeah, that's pretty desperate
18:03:19 <hodapp> evenex: yeah, that was pretty awful.
18:03:27 <dulla> Someone dispalaging the glate modurraturship? you better breef that is a bannu
18:03:56 <shapr> so anyone else trying to use Haskell with Arduinos?
18:04:11 <dulla> can haskell get that low?
18:04:17 <hodapp> just you, shapr. No one cares about embedded Haskell. NO ONE.
18:04:24 * shapr cries quietly
18:04:36 <dolio> I heard someone was doing ATS on arduino.
18:04:39 <shapr> No, I will CODE THE WORLD DIFFERENTLY!
18:04:48 <dulla> You could probably make an efficient parallel processing farm, or something, shapr
18:04:49 <nshepperd_> I thought cross compiling was a horrifying minefield
18:04:57 <dulla> it is
18:05:09 <dulla> I hear horror stories about what goes into a phone
18:05:21 <fryguybob> orzo: Haskell's STM is unique in its flexible composibility, but its performance is very behind the start of the art in transactional memory.
18:05:26 <shapr> dulla: Does Haskell run on android?
18:05:29 <dulla> the manual to connect the pieces could kill a man
18:05:31 <hodapp> I don't think you'll find a Haskell runtime tight enough to run on a microcontroller anytime soon.
18:05:36 <shapr> dulla: What do you write with Haskell?
18:05:42 <hodapp> Idris is sort of there.
18:05:43 <dulla> someone was able to put haskell games on android, shapr
18:06:20 <shapr> dulla: do you have any Haskell code up on github?
18:06:20 <peddie> fryguybob: what is the state of the art in software transactional memory?  or are you referring to systems with hardware support for transactional memory?
18:06:22 <dulla> I write > main = do putStrLn "Hellow World!"
18:06:24 <shapr> I want to see new Haskell code!
18:06:34 <shapr> dulla: ooh, is that literate Haskell?
18:06:54 <orzo> i'd like ghc to have improved support for cross compiling
18:06:56 <dulla> ...
18:07:07 <dulla> I can only read!
18:07:12 <nshepperd_> oh yeah, orzo as I recall the pypy folks were working on a pretty nice stm interface for python
18:07:12 <dulla> the hell can i write
18:07:17 <shapr> orzo: me too
18:07:25 <fryguybob> peddie: Different algorithms and compiler techniques.
18:07:49 <dulla> all I hear are zippers that manipulate spacetime, peddie
18:07:50 <nshepperd_> so you can just start a "with atomic:" block and all access to python objects within that block occurs as one transaction
18:07:51 <orzo> is it on trac anywere?
18:07:54 <fryguybob> peddie: Hardware transactions are certainly a part of that.
18:08:05 <shapr> The more I use threads and processes in other languages, the more I like software transactional memory.
18:08:08 <hodapp> nshepperd_: ooh, CPython too?
18:08:14 <peddie> fryguybob: I'm interested to read about better software techniques if you know about something specific :)
18:08:33 <nshepperd_> orzo, hodapp: http://pypy.readthedocs.org/en/latest/stm.html#atomic-sections
18:08:35 <dulla> esolang has the darnedest concurrency esolangs
18:08:37 <hodapp> nshepperd_: thanks
18:09:03 <dulla> I recall one of them simply doesn't try to handle queuing at all
18:09:25 <dulla> god that is a hilarious experiment
18:09:37 <nshepperd_> hodapp: it's not likely to come to cpython, I think, since it would require a rewrite of the object space as i understand it
18:09:40 <shapr> dulla: so, you don't write any Haskell? :-(
18:09:49 <peddie> dulla: you might want to get your hearing checked?
18:09:51 <fryguybob> peddie: An example of some compiler techiques: https://www.cs.rochester.edu/u/scott/papers/2015_PPoPP_ParT.pdf
18:10:18 <peddie> fryguybob: cool, cheers
18:10:23 <fryguybob> peddie: Hardware transactions: http://anon.cs.rochester.edu/u/scott/papers/2011_asplos.pdf
18:11:04 <SrPx> Is type inference possible on the stlc?
18:11:15 <dolio> Yes.
18:11:23 <SrPx> Thanks!
18:11:25 <peddie> fryguybob: the first one seems to rely on hardware transactions as well?  or at least it talks a lot about it
18:12:16 <dolio> Hindley-Milner is effectively inferring type schemas for the simply typed lambda calculus.
18:12:29 <fryguybob> peddie: Yes.  For low thread count (up to about 8 or so) NOrec is the best software only for current architectures.
18:12:33 <dolio> Or, it is more than a lambda calculus, but STLC is a sublanguage.
18:12:52 <fryguybob> peddie: https://anon.cs.rochester.edu/u/scott/papers/2010_ppopp_NOrec.pdf
18:12:59 <peddie> fryguybob: interesting, thanks -- I'll check it out
18:13:02 <Saizan> dolio: amen!
18:13:19 <peddie> fryguybob: I am in love with STM, but I wouldn't complain if there were a faster way :)
18:13:32 <fryguybob> peddie: That's what I'm working on :D
18:13:55 <peddie> oh, no kidding?  are you developing better software algorithms or doing the hybrid/hardware stuff?
18:14:21 <peddie> and, obligatory: will I be able to use it from my haskell code?  :P
18:14:51 <fryguybob> peddie: I'm doing a hybrid in GHC and identifying what advantages and disadvantages Haskell has for TM.
18:15:20 <peddie> cool, maybe I will have to upgrade to a computer with Haswell to use it then :)
18:16:12 <fryguybob> peddie: Well, they found a hardware bug in Haswell's TSX, so they turn it off now, but the next round will have the bug fixed.
18:16:22 <peddie> fryguybob: are you a graduate student?
18:16:27 <fryguybob> Yes
18:16:27 <peddie> fryguybob: uh-oh, too bad
18:16:49 <peddie> (about the Haswell bug, not grad school :)
18:17:08 <fryguybob> Ha, I read that the right way :D.  It is quite rare to trigger, but not something you want in production
18:17:15 <fryguybob> (bugs, not grad students)
18:17:21 <silver> :D
18:17:24 <peddie> haha
18:18:30 <fryguybob> But the exciting thing is that some big systems are coming out with TSX and it can very nicely extend scaling performance with little programmer effort.
18:18:52 <peddie> fryguybob: how's it looking for getting a speedy hybrid into GHC?
18:19:22 <peddie> fryguybob: are there a lot of engineering obstacles?  theoretical obstacles?
18:19:50 <fryguybob> peddie: I'll let you know when they actually hand me a PhD.
18:20:01 <peddie> fryguybob: haha, OK :)
18:20:18 <fryguybob> :D  Last night I got my hybrid to beet out the fine grain locking STM that comes with GHC.
18:20:25 * hackagebot purescript 0.6.8 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.8 (PhilFreeman)
18:20:28 <peddie> NICE
18:20:46 <shapr> fryguybob: You have a different approach to STM?
18:21:07 <lpaste> nurupo pasted “Errors while porting a simple for-loop from C to Haskell code” at http://lpaste.net/6480211935689179136
18:21:38 <fryguybob> There are some engineering obstacles that prevent us from doing much better at the moment, but we should be able to get around that and then we will gain quite a lot over STM.
18:22:17 <nurupo> can someone help me with the paste ^ ?
18:22:18 <shapr> fryguybob: does your hybrid use intel's TSX ?
18:22:21 <fryguybob> Right now there is too much indirection in the system and we need to touch less memory in transactions.
18:22:32 <SrPx> Interesting, thanks guys
18:22:50 <peddie> fryguybob: what do you mean by indirection here?
18:22:53 <fryguybob> shapr: Yes.  It isn't a different approach to STM, just speeding up the STM by doing some or all of the work in hardware when we can.
18:23:23 <shapr> fryguybob: that sounds wonderful
18:23:25 <fryguybob> peddie: Each TVar points to a heap object that holds the value.  We would like to be able to have values "unboxed" in the TVars
18:23:34 <dulla> so, actually utilising your machine
18:23:35 <peddie> ah I see
18:23:42 <geekosaur> nurupo, it's generally a good idea to include full error messages in a paste like that
18:23:43 <peddie> too many pointers
18:23:59 <nurupo> geekosaur: will add in a sec
18:24:22 <fryguybob> We would also like to vary the amount of meta data assoicated with particular data, so a good TArray implementation will allow users to express data sturctures in sizes that match how the hardware will handle the structure.
18:24:39 <fryguybob> We can sacrafice some STM performance to get better HTM performance doing this.
18:24:56 <peddie> I see, so you could use a structure that the runtime will size to match hardware transaction capabilities
18:25:01 <geekosaur> in any case I don't see a definition of `len` and if you meant `length` then it is Int, not Integer
18:25:04 <peddie> seems like that would be nice for cache things as well
18:25:21 <fryguybob> peddie: Right.  HTM is built on a small change to the cache.
18:25:33 <fryguybob> (at least TSX is)
18:25:56 <peddie> I'd love to be able to make e.g. a rope structure where the array sizes are automatically matched to cache lines or something like that
18:26:11 <peddie> (even leaving transactions aside)
18:26:20 --- mode: ChanServ set +o dibblego
18:26:26 --- mode: dibblego set -b wolf_mozart!*@*
18:26:40 --- mode: dibblego set -o dibblego
18:26:47 <wolf_mozart> hey!
18:27:04 <fryguybob> peddie: Yeah, getting all those details right is very tedious but criticle to performance.
18:28:03 <peddie> I guess I want a type that's an unboxed vector that's guaranteed to be 1) aligned properly and 2) sized properly so that I can assume that searching within it or whatnot is going to be all in cache
18:28:54 <peddie> fryguybob: anyway, it sounds like you are up to some cool stuff -- I look forward to using it :)
18:29:22 <fryguybob> peddie: Thanks, it is exciting to get things working :D
18:29:29 <lpaste> nurupo pasted “Errors while porting a simple for-loop from C to Haskell code” at http://lpaste.net/1985291608295211008
18:30:22 <geekosaur> :t (!!)
18:30:23 <lambdabot> [a] -> Int -> a
18:30:25 * hackagebot milena 0.2.0.0 - A Kafka client for Haskell.  http://hackage.haskell.org/package/milena-0.2.0.0 (tylerholien)
18:30:39 <mniip> :t fromInteger
18:30:40 <lambdabot> Num a => Integer -> a
18:30:42 <geekosaur> you will need to use fromIntegral to make your Integer indexes compatible with Int
18:30:50 <geekosaur> or fromInteger
18:31:05 <nurupo> oh, i see
18:31:11 <nurupo> !! takes an Int, not Integer
18:31:15 <geekosaur> yes
18:31:40 <Fusebox> so !! is not lazy? doesn't handle lists above a certain length?
18:31:49 <mniip> it is lazy
18:31:57 <Fusebox> Int will overflow?
18:32:04 <mniip> what do you mean
18:32:40 <mniip> I don't see how the 3 questions overlap
18:32:58 <nurupo> geekosaur: thanks :)
18:33:02 <Fusebox> Can you correct my understanding of Int vs Integer: I understood that Integer can handle integers of any length, while Int is constricted to however many bits are assigned to it (32?)
18:33:10 <Fusebox> and yeah, I was wrong to state it isn't lazy
18:33:17 <geekosaur> the Int vs. Integer thing is something we argue about a lot (elsewhere, generally). the original notion was apparently to use the faster type because lists "obviously" can't be larger than what the machine can address
18:33:28 <geekosaur> which argument has several flaws when examined closely
18:33:49 <Fusebox> cheers :)
18:34:03 <nurupo> i think Int is 30 bit
18:34:24 <nurupo> the remaining 2 bits are used for GC or something
18:34:25 <geekosaur> the report allows it to be as small as 30 bits. ghc uses larger Int-s, the machine word size
18:34:40 <Fusebox> mniip: my point was essentially that the function is not truly lazy if it can't work with infinitely large values (which it can't, due to Int overflow)
18:34:43 <dulla> there are other ints
18:35:11 <geekosaur> the report basically allows some bits to be stolen for implementation defined uses (gc, constructor tagging, whatever).
18:35:22 <geekosaur> ghc does it a different way so it doesn't have to restrict the range of Int
18:36:03 <dulla> it can convert to Integer, Unbounded Integers
18:36:14 <dulla> Would prefer to run it all on Int8
18:36:22 <mniip> Fusebox, ...
18:36:26 <mniip> tha'ts nothing to do with laziness
18:37:25 <mseeks> i have a float p in [0, 1) and I want to "convert" it to a bytestring of n bytes such that the bytestring value = p * 2^(8 * n), if that makes sense
18:38:06 <mseeks> let's say p = 0.25, and n = 32, then I want to convert p to a bytestring with a value of 2^127
18:38:08 <dulla> what
18:38:14 <mniip> mseeks, given the Float datatype I'm afraid n>3 doesn't make much sense
18:38:35 <dulla> try double :^)
18:38:36 <mseeks> what do you mean?
18:38:45 <dulla> float is single precision
18:38:47 <mniip> mseeks, Float can store finite amount of information
18:38:50 <dulla> double is double
18:38:56 <ab9rf> mseeks: float only has like 10 bits of mantissa
18:38:58 <Fusebox> mniip: not in the technical sense of the term, but definitely in the spirit of it
18:39:01 <mniip> something like 25 bits in mantissa I think
18:39:07 <mniip> Fusebox, not at all?
18:39:10 <mseeks> it actually doesn't matter
18:39:22 <ab9rf> double has 24 or 25, i'd have to look up
18:39:31 <mseeks> let me describe the point of this
18:39:47 <ab9rf> does haskell allow 64-bit long doubles?
18:40:10 <geekosaur> I don't think ghc implements them as yet
18:40:22 <geekosaur> although wait. 64 bits is a Double
18:40:25 <geekosaur> 32 bits is a Float
18:40:38 <ab9rf> huh, i thought a float was 16
18:40:39 <mseeks> basically I begin with a value V and a number 0 <= p < 1, then I calculate H = sha256(V). Then I want to calculate whether H lies below p * 2^256
18:40:43 <ab9rf> but yeah, you're right
18:40:46 <geekosaur> 128-bit (C's (long double)) is not implemented in ghc currently
18:41:30 <mseeks> so just like normal probability but all 256-bit numbers
18:41:40 <geekosaur> I mostly remember this because 4.2BSD had a 16-bit floating point implementation in the kernel to calculate load averages. (It's done differently these days)
18:42:39 <mseeks> can I just do this math with Integers?
18:42:39 <ab9rf> ok, H float is 128 bit
18:42:44 <ab9rf> it's been a long time :)
18:42:45 <geekosaur> well, maybe that wasn't actually used in the kernel, it was there for load average foo but that's always been a dumb way to do it. then again some grad students can come up with the weirdest ways to do things
18:43:19 <mniip> mseeks, what do you mean
18:43:24 <geekosaur> (my day job is support for another piece of software that was originally written by grad students. sometimes we are just baffled by trying to figure out what they were thinking :)
18:44:09 <shapr> geekosaur: sounds terrifying
18:44:30 <mseeks> would it be OK to literally convert a 256-bit hash into an Integer and test if it's less than 0.013 * 2^256 for example?
18:44:39 <Saizan> geekosaur: they were thinking "shit i need to do stuff that can be published"
18:44:47 <geekosaur> likely
18:44:53 <mniip> mseeks, 2^256 * 13 / 1000
18:45:00 <mniip> other than that yes, easily
18:45:04 <mseeks> I guess I was just concerned because 2^256 is pretty big
18:45:14 <nurupo> :t (mod)
18:45:14 <ab9rf> really?
18:45:14 <lambdabot> Integral a => a -> a -> a
18:45:20 <ab9rf> it's not that big
18:45:26 * hackagebot growler 0.6.0 - A revised version of the scotty library that attempts to be simpler and more performant.  http://hackage.haskell.org/package/growler-0.6.0 (IanDuncan)
18:45:34 <dulla> hah, yeah, mod
18:45:34 <geekosaur> then again one of my spare-time things involves C++ code written by a legal student who infamously stopped reading his C++ book when he hit the chapter on pointers :) maybe I'm just a masochist
18:45:37 <mseeks> well it's 10^77
18:45:45 <mseeks> i guess it just seems big
18:45:48 <ab9rf> 115792089237316195423570985008687907853269984665640564039457584007913129639936
18:45:53 <ab9rf> it fits on a single screen
18:45:57 <ab9rf> it can't be that big
18:46:08 <mseeks> fair enough
18:46:13 <ab9rf> geekosaur: heh
18:46:41 <ab9rf> geekosaur: i was a law student once, and i don't remember if my C++ book even had a section on pointers :)
18:46:51 <hae> @karma+ ab9rf
18:46:51 <lambdabot> ab9rf's karma raised to 4.
18:47:10 <ab9rf> i've only read one C++ book.  it was written by thius guy with a weird name.
18:47:50 <heatsink> Bjarne Stoustrop?
18:47:57 <heatsink> *Stroustrup
18:47:59 <ab9rf> yeah, that's it
18:48:12 <hae> I have a book on my shelf right now, "Teach Yourself C++ in 24 Hours" by Jess Liberty.
18:48:13 <geekosaur> Stroustrup may well not have bothered with it since C++ inherits that part from C for the most part
18:48:31 <ab9rf> geekosaur: i suspect you're correct in that regard
18:48:49 <geekosaur> so K&R is kinda included by reference
18:49:08 <geekosaur> (not that I recommend trying to learn pointers from that either :)
18:49:13 <ab9rf> something i found back in the late 1980s
18:49:19 <shachaf> Modern C++ probably uses pointers pretty differently from C.
18:49:26 <shachaf> i,i But C doesn't even have references...
18:49:34 <shachaf> Anyway this is a bit off-topic here at this point.
18:49:38 <hae> The majority of C++ projects were probably written by people who learned it in 24 hours or less to be honest...
18:49:45 <ab9rf> probably The C++ Programming Language, 1986
18:50:10 <acetoline> why are we talking about C++ pointers in a haskell channel
18:50:16 <ab9rf> acetoline: because we can
18:50:20 <SrPx> Is there such a thing in Haskell? http://www-ps.informatik.uni-kiel.de/smap/smap.cgi?browser/31
18:50:43 <geekosaur> we kinda drifted off topic. probably belongs elsewhere
18:50:55 <ab9rf> SrPx: such as thing as what?
18:50:58 <KaneTW> :t (<$>)
18:51:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:51:37 <geekosaur> SrPx, there is a unification algorithm written in Haskell but it's not quite that short. Unification is more of a logic thing and Curry is a logic language, so it can do it not *quite* as compactly as Prolog
18:52:30 <ab9rf> i would think that unification would be fairly easy but not entirely trivial in haskell
18:52:45 <geekosaur> the Haskell one isn't huge but still has to do extra work that languages like Prolog and Curry have built in
18:52:58 <ab9rf> unification is a fundamental operation in prolog
18:53:02 <geekosaur> yep
18:53:29 <geekosaur> as it is in Curry (note reference to the =:= operator in the paste)
18:54:33 <SrPx> ab9rf: okay, but is there a short/pedagogic implementation of a STLC type inferencer ?
18:54:48 <geekosaur> logic languages are still a different world and can twist your head as badly as Haskell does to newcomers. perhaps worse :)
18:54:53 <nurupo> is there a quadruple in haskell?
18:54:54 <ab9rf> SrPx: ugh. if someone's done that, i'm not aware of it
18:55:03 <SrPx> I see, no problems... thanks!
18:55:22 <geekosaur> nurupo, I'm not sure what you're asking?
18:55:38 <nurupo> (x, y, z, w)
18:55:58 <ab9rf> nurupo: haskell has generic tuples
18:56:13 <nurupo> hm
18:56:17 <geekosaur> well, n-tuples are built in, if you are looking for specific operations on them then there are libraries on Hackage for e.g. quaternions
18:56:32 <ab9rf> if you want quaternions i'm sure those are defined somewhere too
18:56:45 <geekosaur> in general we don't use things much beyond 2-tuples because actual data types are ultimately more convenient
18:56:57 <nurupo> i'm restricted to prelude, pretty much
18:57:05 <ab9rf> why restricted to prelude?
18:57:33 <SrPx> Linear's quaternions are great
18:57:34 <nurupo> well, will just try to use a list then
18:58:24 <geekosaur> it might help if you could say what exactly you're trying to accomplish
18:59:38 <ab9rf> nurupo: just define them
19:00:04 <ab9rf> data (Num a) => Q a = Q a a a a
19:00:38 <ab9rf> then make them a Num instance and define the appropriate operations
19:00:49 <ab9rf> nice learning exercise :)
19:01:44 <dulla> > instance Num Quat (+)
19:01:45 <lambdabot>  <hint>:1:1: parse error on input ‘instance’
19:01:49 <dulla> neat
19:02:08 <nurupo> geekosaur: trying to port the part that starts with "m0[] =" now http://stackoverflow.com/a/12231878
19:02:37 <nurupo> all other functions are ported :)
19:05:55 <mseeks> what's the best way to convert an Integer to a bytestring?
19:06:12 <shachaf> Which ByteString?
19:06:24 <mseeks> strict
19:06:29 <mseeks> is that what you mean?
19:06:32 <shachaf> Which strict ByteString?
19:06:34 <Clint> mseeks: i dunno, but i do B.pack . reverse . unfoldr (\x -> if x == 0 then Nothing else Just ((fromIntegral x :: Word8) .&. 0xff, x `shiftR` 8))
19:07:01 <shachaf> I can think of at least three common meanings for that.
19:07:19 <mseeks> Clint: thanks!
19:08:03 <Clint> that's big-endian, of course
19:08:38 <Scriptonaut> could someone tell me why this doesn't work: https://gist.github.com/robins35/aa5835b543efd4524afb
19:08:58 <Scriptonaut> says that it couldn't match type "NestedList aq" with actual type "[NestedList t0]"
19:09:04 <Clint> you have a type error
19:09:10 <Scriptonaut> ya
19:09:12 <geekosaur> for starters, (List (x:xs))
19:09:14 <Scriptonaut> I can't figure out why
19:09:23 <edwardk> mniip: we have nothing in lens that can _only_ be set.
19:09:25 <funfunctor> hi
19:09:27 <edwardk> mniip: they don't compose.
19:09:31 <shachaf> Scriptonaut: You're saying that for any types a,b, you can convert a NestedList a to a [b]
19:09:42 <geekosaur> for another, what is b?
19:09:47 <geekosaur> (on line 2)
19:09:48 <funfunctor> I forgot this syntax, can someone remind me of how to properly read  data Widget = forall a. IsWidget a => Widget a  again
19:09:48 <edwardk> mniip: a setter is analogous to a functor, you can modify the value there but you can't 'read' it out
19:09:53 <edwardk> mniip: this lets setters compose
19:09:59 <Scriptonaut> b is whatever type nestedlist holds
19:10:12 <Scriptonaut> oh
19:10:14 <geekosaur> but you told it that a is that type
19:10:16 <Scriptonaut> so that would be [a]
19:10:19 <Scriptonaut> aha
19:10:19 <mniip> <edwardk> mniip: they don't compose.
19:10:21 <mniip> sure they do
19:10:24 <mniip> but only on one side
19:10:39 <shachaf> funfunctor: It's an existential type. That means that for any type a which is an instance of IsWidget, if x :: a, then Widget x :: Widget
19:10:45 <funfunctor> IsWidget is the type-class here
19:10:56 <edwardk> mniip: 'only on one side' is the problem. everything in lens fits into a nice pattern. a pure 'write a value by abusing .~ notation' combinator doesn't fit that pattern
19:11:02 <shachaf> funfunctor: In particular it means that if I give you one of these things, you won't actually know what particular type a I chose.
19:11:03 <funfunctor> shachaf: ah yea ok thanks
19:11:11 <funfunctor> perfect thx
19:11:21 <edwardk> mniip: nothing stops you from going off and writing whatever you want, lens doesn't give it to you though, because it has no good laws
19:11:36 <mniip> edwardk, ok, then, can I write something that only typechecks when being set
19:11:38 <edwardk> mniip: and doesn't let us overload it in a way that makes it fit in with all the other things
19:11:57 <mniip> and can be composed
19:12:00 <mniip> on one side
19:12:23 <Scriptonaut> hmm, so it's still giving me a very similar error, line 5: https://gist.github.com/robins35/aa5835b543efd4524afb
19:12:37 <Scriptonaut> expects a NestedList a, but it says I'm giving it a [NestedList a]
19:12:59 <edwardk> mniip: yes and no. you probably can make something that typechecks. to do so you have to basically do unspeakable things that ignore every law and every assumption made by the entire package. this is a commonly requested thing, we thought we could offer it early on, and we stopped, because it doesn't lead to any nice theory
19:13:28 <mniip> damn
19:13:59 <edwardk> mniip: making up a combinator to do what you want is probably not as dire as you fear ;)
19:14:06 <edwardk> what is it you want to set
19:14:08 <shachaf> edwardk: It's not exactly unspeakable with pure profunctor lenses at least.
19:14:13 <edwardk> shachaf: =P
19:14:15 <shachaf> But it just doesn't work well.
19:14:20 <shachaf> For the reasons you mentioned.
19:14:34 <edwardk> its still unspeakable from the standpoint of not being a proper optic
19:14:57 <edwardk> we give a few dozen types in lens, that all obey the same couple of laws
19:15:21 <edwardk> laws that are admittedly even easier to state in the pure profunctor form
19:15:27 * hackagebot hwsl2 0.2.0.0 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.2.0.0 (srijs)
19:18:04 <mniip> edwardk, prepending a head to a list
19:18:10 <mniip> for instance
19:18:26 <mniip> you can't exactly read that, but you can set it
19:19:22 <mniip> I understand that this can be done with 'over l (x:)' but still
19:19:23 <edwardk> mniip: yes, and it even violates the only law we'd have left
19:19:34 <edwardk> set l a . set l b = set l a
19:19:46 <edwardk> its just not anything _like_ an optic
19:19:59 <mniip> ah
19:20:07 <stelleg> anyone know how to import type operators manually, e.g Ghc.TypeLits ((<=))
19:20:11 <mniip> ok
19:20:17 <edwardk> mniip: just because it syntactically works doesn't mean it has the right semantics
19:21:11 <edwardk> there are lots and lots of useful combinators out there that aren't lenses, setters, traversals, etc. they are just other things
19:21:24 <edwardk> jquery is many useful things, its just not a monad =)
19:21:33 <edwardk> same deal
19:21:51 <mniip> also
19:22:06 <mniip> all tutorials introduce lens in a really weird way
19:22:19 <edwardk> then write another one. ;)
19:22:28 <mniip> I don't think I'm competent enough for that yet
19:22:29 <geekosaur> stelleg, is https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#type-operators helpful?
19:22:32 <mniip> but yeah
19:22:37 <EvanR> mniip: doesnt stop most tutorials ;)
19:22:48 <edwardk> EvanR: =)
19:22:55 <mniip> I think Lens, Traversal, Prism, and most importantly, Iso, should be introduced at the same time
19:23:15 <edwardk> possibly. its just a lot of moving parts to keep in mind
19:23:36 <edwardk> Lens, Traversal, Prism, Iso make a nice 4 lattice
19:23:42 <edwardk> but then so do Lens, Getter, Fold and Traversal
19:23:43 <mniip> yes
19:23:50 <shachaf> Equality is the only important optic.
19:23:51 <mniip> what
19:24:02 <stelleg> geekosaur: yep, thanks!
19:24:03 <mniip> it took me a while to get from the existing tutorials
19:24:12 <edwardk> every Lens is a Getter, every Getter is a Fold, every Traversal is a Fold, every Lens is a Traversal.
19:24:27 <stelleg> geekosaur: looks like its import GHC.TypeLits (type (<=))
19:24:30 <mniip> I don't think I've formed an understanding of Getters and Folds yet
19:24:44 <shachaf> Are there any other monoidal structures for the category of Functors other than the obvious five?
19:25:04 <edwardk> every Iso is a Lens, every Iso is a Traversal, every Prism is a Traversal, every Iso is a Prism, etc.
19:25:51 <edwardk> shachaf: Day gives 4, Composition, product, coproduct, so there are 7 easy ones by my count
19:25:54 <mniip> that sounds like
19:25:57 <mniip> an 8 shape
19:26:09 <mniip> hmm no
19:26:32 <shachaf> edwardk: 7?
19:26:33 <edwardk> mniip: my point was there is a lattice with a top and a bottom and two points in the middle, for each of those sets of 4 points.
19:26:50 <shachaf> edwardk: I was thinking of composition, lifted product/coproduct, Day convolution with product/coproduct.
19:26:57 <edwardk> shachaf: we tend to use day convolution to map products or coproducts to products but we could take them to coproducts as well
19:27:12 <mniip> I should figure out what Fold and Getter is...
19:27:13 <mseeks> is it typical to have a line `parseJSON _ = mzero` in ToJSON instances? this leads to a GHC warning of overlapping pattern matches
19:27:30 <edwardk> Hask is a monoidal category when equipped with products or coproducts
19:27:39 <edwardk> so you could use Day convolution to go to either
19:27:47 <mniip> also, I meant something like 🁣
19:27:51 <edwardk> mniip: a Getter is a CPS'd function made in lens form
19:27:58 <edwardk> > "hello"^.to length
19:27:59 <lambdabot>  5
19:28:20 <edwardk> you can't write back to it with .~ and the like, but you can read from it, run it through combinators like those that work with Foldable, etc.
19:28:21 <mniip> edwardk, I got lost at 'CPS'd'
19:28:29 <EvanR> mniip: wth is that character there
19:28:46 <mniip> EvanR, U+1F063 DOMINO TILE VERTICAL-00-00
19:28:47 <shachaf> edwardk: What do you mean?
19:28:47 <rola> continuation passing style?
19:29:00 <edwardk> mniip: to :: (s -> a) -> Getter s a
19:29:17 <mniip> edwardk, still doesn't tell me anything
19:29:19 <shachaf> Something like exists c d. (f c + g d + c⊗d -> a)?
19:29:27 <EvanR> mniip: i cant copy it with iterm2 :(
19:29:37 <edwardk> mniip: Getter s a is like a Lens' s a   that you can only run through ^. and the functions that read from it, none of the functions that write to it
19:30:07 <mniip> hold on, ^. is view, right?
19:30:11 <edwardk> yes
19:30:24 <mniip> hmm
19:30:30 <edwardk> to takes a function and makes it compose 'lens style' but the resulting composition becomes 'read only'
19:30:32 <SrPx> Suppose that "data A = A" and (f :: (A → A) → A → A). Is the set of possible implementations of "f" countable?
19:30:41 <edwardk> because this works for any function you want
19:30:44 <edwardk> thats it
19:31:19 <mniip> edwardk, so something that zooms in, but irreversibly loses information in process
19:31:40 <SrPx> I can see: "f a b = b", "f a b = a b", "f a b = a (a b)", "f a b = a (a (a b))" and so on... I can't find other way to write it... is there any?
19:32:47 <edwardk> mniip: yes, or since its any function can drag anything else you have in the environment in in the process
19:33:06 <edwardk> mniip: a Fold is this same sort of read only thing but now with multiple targets like a traversal
19:33:14 <mniip> ahhh
19:33:15 <edwardk> you give me any function (s -> [a])  and i can give you a Fold s a
19:33:37 <mniip> that last comment was more confusing than the explanation tbf
19:33:42 <edwardk> you can compose folds with lenses and traversals, etc. and the result becomes read only and 'traversal' like =)
19:34:10 <edwardk> > ("hello","world")^..both.traverse
19:34:11 <lambdabot>  "helloworld"
19:34:17 <edwardk> > ("hello","world")^..both.traverse.to fromEnum
19:34:18 <lambdabot>  [104,101,108,108,111,119,111,114,108,100]
19:34:34 <edwardk> > ("hello","world")^.._1.traverse.to fromEnum
19:34:36 <lambdabot>  [104,101,108,108,111]
19:34:58 <edwardk> _1 is a lens, traverse is a traversal, so _1.traverse is a traversal,   to fromEnum is a getter, so when we compose it with a traversal we get a fold.
19:35:18 <edwardk> basically if 'anything in the chain is read-only, then the result is read-only'
19:35:52 <mniip> edwardk, that tells me nothing :)
19:36:01 <edwardk> and we have setters, which can be modified with .~ ,  %~ , +~, etc. but which don't permit you to use the ^. ^.. ^? etc. like combinators to read from them.
19:36:47 <mniip> but yeah, lens.traversal is a traversal, because it needs both context to reverse, and produces N values
19:36:50 <edwardk> there is a big pretty picture on the front page of the lens docs, it has a lattice, when you compose things you move up to their least common upper bound in the lattice
19:37:09 <edwardk> getter is up above lens, folds are up above getters and traversals both
19:37:15 <khyperia> Hey all, I'm (still) trying to write an irc bot, and I'm wondering if there's an already-thought-out solution to my problem: I have a stream of input events, a set of functions 'f::Stream a -> Stream b", and I want to combine the resulting streams into a single output stream, *in order that they were produced by the input*. I'm stuck on the last bit, and I'd like to not take the way that, say,
19:37:17 <khyperia> reactive-banana took and use physical time as a combination order.
19:37:22 <mniip> well maybe it's just me, but I find all explanations of lens quite misleading anf confusing
19:37:25 <edwardk> you can use anything below you in that chart as anything above it
19:37:36 <mniip> including that chart
19:38:15 <edwardk> mniip: *shrug* i don't know how to encapsulate the information in a more digestible form, or i'd have done so by now
19:38:28 <edwardk> the chart is useful for folks who want to see what can be used as what
19:38:28 <mniip> sec
19:38:41 <mniip> I will draw the chart that I have in my mind
19:38:42 <edwardk> it shows you can walk an Equality all the way up the diagram to anything you want
19:39:26 <edwardk> and the lack of anything above Fold and Setter shows why folded.mapped  doesn't get you to anything
19:40:25 <edwardk> gotta run for a bit
19:43:07 <nshepperd_> it goes from most polymorphic at the bottom of the chart to least polymorphic at the top, right?
19:43:35 <edwardk> nshepperd_: yeah anything below can be used as everything above it
19:43:46 <funfunctor> does anyone else think when writing Haskell "what the hell does copyright/license/whatever.. even mean, i'm hardly writing any symbols for so much.." ?
19:43:58 <nshepperd_> an Equality is extremely polymorphic so it has strong laws
19:44:27 <EvanR> funfunctor: yes nobody even can recognize how valuable it is anyway, its too abstract
19:45:06 <EvanR> sometimes haskell code has a "this is really the only way anyone would ever do it" quality to it
19:46:18 <funfunctor> EvanR: yea exactly, I mean sure f = +5 can be written as f = +(4+1) or infinite other ways but seriously, it proves the point that copyright, license and legal shit does not apply to maths/software
19:47:09 <mniip> edwardk, http://i.imgur.com/qPjSqHk.png
19:47:23 <nshepperd_> neat, I've never really looked at the lens lattice this way before
19:47:38 <EvanR> funfunctor: software is still in its infancy, big picture-wise, its only starting to show the inconsistencies in previous legal thought
19:48:05 <mniip> not only it makes a nice graph pattern but you can actually see that it's a 2x3 matrix
19:48:08 <shachaf> We have a lattice right on https://github.com/ekmett/lens
19:48:27 <shachaf> Of course it has more than six points.
19:48:41 <funfunctor> abstract question; would you think that if every software eng took a week out of work as a protest against patents and let the world grind to a halt it may get the message though? Just your personal thoughts..
19:49:03 <mniip> 1 value vs N values, and 3 types of reversiblity
19:49:06 <shachaf> My impersonal thought is that that is off-topic.
19:50:05 <funfunctor> shachaf: yea I know sorry, i've been working on this code all morning.. just wanted a 5min discourse with someone who could understand me :/
19:50:26 * EvanR gives funfunctor a ticket to galt's gulch
19:51:20 * funfunctor duckduckgo's galt's gulch
19:52:05 <edwardk> mniip: your prism is wrong, its 0 or 1
19:52:19 <mniip> oh?
19:52:24 <funfunctor> lol http://www.galtsgulchchile.com/  "..... for you to stay on-site at GGC. Pl...." <- I misread that as GCC, EvanR
19:53:06 <edwardk> mniip: prisms match one case out of a sum,  lenses match one field out of a product
19:53:09 <mniip> edwardk, well I guess it makes sense that with a reversible prism N < 2
19:53:15 <edwardk> every prism can be used as a traversal of 0 or 1 element
19:53:37 <edwardk> but it can also construct the structure, you can use (#) or review to build with it
19:53:47 <edwardk> > _Left # 2
19:53:47 <edwardk> > _Left . _Right . _Just # 2
19:53:49 <lambdabot>  mueval-core: L.hs: removeLink: does not exist (No such file or directory)
19:53:49 <lambdabot>  Left 2
19:53:57 * funfunctor cracks wip, alright back to work..
19:54:03 * edwardk wakes lambdabot
19:54:03 <edwardk> > _Left . _Right . _Just # 2
19:54:04 <lambdabot>  Left (Right (Just 2))
19:54:51 <edwardk> Equality is like Iso, but where the types much actually match exactly, no funny business, every equality is a trivial isomorphism
19:55:25 <funfunctor> Is using type class with existential types to do dynamic dispatch "bad design" in Haskell? i.e. Am I thinking "too OOP"?
19:55:31 <edwardk> Setter dangles off to the right from Traversal, it can have potentially an uncountable infinite number of targets, traversals can only hit a countably infinite number.
19:55:38 <edwardk> funfunctor: yes
19:56:15 <edwardk> every traversal can be used as a setter. most of the %~, +~, etc. combinators work on them
19:56:39 <dmwit> We have uncountably infinite data structures now?
19:56:57 <edwardk> dmwit: an arbitrary function space anyways
19:57:02 <dmwit> Sure, why not. Integer -> Bool
19:57:10 <funfunctor> edwardk: Suppose I have a number of hw radio backends and I want to abstract them away with a common interface for the above layers, is there a better design pattern I could go with instead of a type-class of functions that setTxFreq, setRxFreq and so on?
19:57:17 <edwardk> dmwit: where from the 'internal' perspective it is uncountable
19:57:27 <Rotaerk> your mom's an uncountably infinite data structure
19:57:31 <Rotaerk> hmm..
19:57:37 <edwardk> funfunctor: take the functions you were putting in the typeclass, put them in a record, make that record your data type. done
19:57:40 <EvanR> funfunctor: yes, the interface pattern is easier to pull off and more flexible using a record type with functions
19:58:19 <Rotaerk> you can do inheritance and whatnot too
19:58:41 <mniip> edwardk, http://i.imgur.com/92OWC66.png
19:59:09 <mniip> also examples are pretty useless when trying to understand fundamental concepts like these
20:00:00 <funfunctor> but wont I have to call a constructor for each hw radio backend?
20:00:25 <funfunctor> instead of just having instances
20:00:35 <edwardk> mnilp: well, i'd argue with some of your choice of vocabulary there, but you are at least getting the gist of what the things are
20:00:54 <EvanR> funfunctor: you have to implement the interface for each backend, which amounts to building one of the records
20:00:58 <edwardk> funfunctor: lets consider a simple simple example
20:00:59 <funfunctor> i.e. why is the type-class driven dynamic dispatch "bad" ?
20:01:21 <funfunctor> edwardk: I know how to write both
20:01:27 <edwardk> newtype Comparison a = Comparison { getComparison :: a -> a -> Ordering }   -- vs. compare :: Ord a => a -> a -> Ordering
20:01:47 <edwardk> Comparison can be an instance of lots of different classes in its own right.
20:01:54 <edwardk> you can take that data type and map 'backwards' over the 'a's
20:02:20 <edwardk> you can build one given the class Ord,   Comparison compare :: Ord a => Comparison a
20:02:42 <mniip> it's an i ಠ_ಠ
20:03:04 <funfunctor> well the C++ code I am reading has virtual functions for things like setting the VCO, Frequencies and so on of the hardware, these are used in the above layers (think TCP/IP sort of thing here)
20:03:13 <edwardk> he benefit of this approach is that you can make 'non-canonical' instances that use 'a' internally. that use contexts from the surrounding program to make up the functions involved
20:03:20 <funfunctor> there are multiple possible radio hw backends at Layer 0
20:03:47 <EvanR> funfunctor: yeah, c++ virtual functions are (conceptually) like fields with a function value
20:03:48 <funfunctor> I don't know if this helps give the bigger picture of what I am attempt to design
20:03:58 <funfunctor> EvanR: exactly yes
20:04:11 <edwardk> sure, but if you have a hardware backend that needs to use effects in some monad m, you can make your data type provide all the actions needed to manipulate the backend, and the monad can carry context for you, etc. you can often build combinators that will bolt together multiple backends or multiple implementations into larger things
20:04:20 <cmccann> funfunctor: in most cases, a record of functions with smart constructors is the right translation for that sort of thing if you actually want an OOP-y sort of design
20:04:46 <nurupo> my program crashes with "Main: Prelude.(!!): index too large"
20:05:02 <cmccann> nurupo: use a smaller index. also, don't use (!!).
20:05:05 <nurupo> any way to make it tell a specific function/line it does so?
20:05:14 <Rotaerk> (!!) is too excited
20:05:16 <edwardk> in general when you move from the 'existential pattern with a dictionary' to the 'set of functions that were implied by the dictionary' you gain the ability to write a lot more combinators on the resulting data structure. you gain more members, but you can say slightly less about the space of possible members, but since we're in an open world, its not a
20:05:17 <edwardk> -lot- less
20:05:19 <EvanR> one of the lines with !!
20:05:29 <nurupo> lol
20:05:30 <cmccann> multiple exclamation points is a sure sign of a diseased mind
20:05:39 <funfunctor> cmccann: I sort of don't wont a OOP design hence me slowing down and making sure I 'design' things right by making informed choices
20:06:18 <nurupo> so there is no way to tell where it crashes?
20:06:24 <nurupo> :\
20:06:27 <funfunctor> edwardk: that makes sense with the combinators although I am not sure how that would be done? can you show me a trivial example of such a combinator
20:06:32 <EvanR> nurupo: how many places did you use !!?
20:06:32 <cfoch> hello... is there a command to "skip/pass/continue"?
20:06:36 <cfoch> a function
20:06:42 <edwardk> funfunctor another option is to do this, rather than work existentially quantified over the backend and pass a record that happens to know the backend that way just make data types for ypur backends that carry whatever parameters or metainfo you need, then make instances for each of those types
20:06:52 <funfunctor> edwardk: do you mean like a instance of Applicative?
20:07:15 <mniip> edwardk, for a non-CT person, what you're saying is basically; * is an associative operator that is distributive over the abelian group of natural numbers over addition, for example 2 * 3 = 6
20:07:19 <Rotaerk> cfoch, do you mean like the continue keyword of C++ or C#?
20:07:25 <cfoch> yes
20:07:29 <Rotaerk> to abort this particular iteration of a loop and proceed to the next
20:07:38 <cfoch> I want to avoid repating things in a if...then...else
20:07:42 <cfoch> *repeating
20:07:43 <EvanR> nurupo: !! is an example of a partial function (also an inefficient one for what its doing), when you make the choice to use these, you are signing up for a possibly difficult job of figuring out wtf happened after it crashes, with haskells debugging what it is
20:07:50 <geekosaur> this is not an especially meaningful concept when if is an expression
20:07:52 <cmccann> nurupo: you really shouldn't be using (!!) at all, it's bad for multiple reasons
20:07:52 <mniip> optics have much simpler explanations
20:07:56 <cfoch> more something like "pass" of Python
20:07:58 <Rotaerk> cfoch, can you pastebin the existing code?
20:08:23 <edwardk> mniip: except your explanations are the same sort of lie you complain about all the other explanations being ;)
20:08:23 <cfoch> sure
20:08:38 * cmccann really wishes (!!) was not in the Prelude. can we make that happen after the FTP thing is resolved?
20:08:40 <cfoch> http://fpaste.org/188465/44916591/
20:08:48 <cfoch> Rotaerk
20:08:54 <funfunctor> "edwardk: funfunctor another option is to do this, rather than work existentially quantified over the backend and pass a record that happens to know the backend that way just make data types for ypur backends that carry whatever parameters or metainfo you need, then make instances for each of those types" <- let data Backend = Backend { setRx :: BladeRF () , ... } and then what do you mean by instances?
20:09:04 <edwardk> mniip: this is the monad transformer problem. the third explanation you get is the one you take to heart and becomes the truth to you until you play with them a lot longer.
20:09:34 <Rotaerk> cfoch, where are you wanting to skip?
20:09:34 <mniip> I haven't touched monad transformers yet .-.
20:09:35 <funfunctor> edwardk: sorry, that was very information dense I don't think I fully got that
20:09:47 <cfoch> look from line 27
20:10:09 <edwardk> funfunctor: i can make an opaque Backend data type, but now I can do nothing with it that isn't god blessed by the designer of Backend. I can't use the extra information available to me in my data type. I can only use the intersection of functionality in a backend in any combinator that takes a Backend
20:10:18 <cfoch> I just would like to change the pkgName'
20:10:23 <edwardk> data Backend where Backend :: Whatever a => a -> Backend -- is a pretty black box
20:10:26 <dolio> cmccann: Doubt it.
20:10:47 <wayne> what does the implementation of liftM look like?
20:10:53 <cmccann> dolio: but i can dream :(
20:10:58 <mniip> @stc liftM
20:10:58 <edwardk> on the other hand I could just write the combinator that took Backend, e.g. foo :: Backend -> x    as a combinator foo :: Whatever a => a -> x
20:10:59 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:11:05 <cfoch> and outside the if statement, call to retIntFlags PkgName' (with the new value=
20:11:06 <cfoch> )
20:11:06 <mniip> what
20:11:12 <Zekka> wayne: You can also express it in terms of ap if you want
20:11:14 <wayne> thanks mniip
20:11:18 <edwardk> funfunctor: now i have the power to add more constraints about 'a' i can talk about it
20:11:19 <mniip> it corrects typos now?
20:11:20 <Zekka> or just fmap
20:11:31 <edwardk> Backend was limiting your design space severely
20:11:34 <funfunctor> edwardk: right, so I would want something like a Java interface, in that the backend /must/ fulfill the requirements of the Backend interface
20:11:43 <edwardk> It added no real value in its own right
20:11:49 <Rotaerk> cfoch, is your goal here to eliminate the repetition of "retInitFlags pkgName'" ?
20:12:01 <cfoch> yes, only that
20:12:15 <mniip> edwardk, what do you mean it is a lie
20:12:30 <mniip> I never said the other explanations are a lie
20:12:35 <mniip> they are merely confusing
20:12:42 <Rotaerk> cfoch, why is retInitFlags a function?  it's local, and you only ever apply it to one value (pkgName')
20:12:47 <funfunctor> edwardk: I better write some code then i'll paste it in a hour and we can carry on from there? since I am losings myself a little. Is that ok?
20:13:11 <wayne> liftM1 f a = (f fst a, snd a)
20:13:16 <Rotaerk> cfoch, so why not eliminate the parameter, embed pkgName' into it directly, and then what you're repeating is just one word
20:13:19 <funfunctor> thx for helping me understand this stuff!
20:13:19 <wayne> what about that? is there anything wrong with it?
20:13:30 <edwardk> mniip: i mean that your explanations are equally confusing unless you come in with your set of preconceptions. the notion of what 'reversible' means to you is a bit weird, etc. the laws that govern prisms aren't just 'hey i can turn this around', the laws that govern lenses give you a lot of what they can and can't do as well
20:13:45 <Zekka> wayne: Yeah, it has the wrong type
20:14:00 <Zekka> @let liftM1' f a = (f fst a, snd a)
20:14:01 <lambdabot>  Defined.
20:14:04 <Zekka> :t liftM1'
20:14:04 <lambdabot> (((a, b) -> a) -> (a1, t1) -> t) -> (a1, t1) -> (t, t1)
20:14:05 <edwardk> funfunctor: i'm going to go watch a movie with my wife, since i've been kind of a ghost around her for the last couple of weeks
20:14:07 <Rotaerk> cfoch, now, that said, you can eliminate the repetition of that one word, as well, just by structuring things differently
20:14:09 <Zekka> :t liftM
20:14:10 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
20:14:40 <funfunctor> edwardk: oh good idea, do that ! thx for your help
20:14:50 <mniip> wayne, precedence mistake here
20:14:56 <mniip> (f $ fst a, snd a)
20:15:09 <edwardk> funfunctor: anyways, if we instead of taking in an opaque Backend data type, took in an actual data type that we just had a constraint on, then you've lost no power, but now can put different constraints in different positions.
20:15:10 <Zekka> mniip: Pretty sure it's still not liftM if he corrects that though
20:15:20 <Zekka> @let liftM1'' f a = (f $ fst a, snd a)
20:15:21 <lambdabot>  Defined.
20:15:23 <Zekka> :t liftM1''
20:15:24 <lambdabot> (a -> t) -> (a, t1) -> (t, t1)
20:15:33 <mniip> looks liftM'ish to me
20:15:39 <hae> Ah, the eternal question... To use "rem" or "mod"...
20:15:40 <edwardk> on the other hand if instead of an opaque Backend data type that holds an existential it holds member fields, we can write combinators that swap out some of those fields for others, or that might combine two backend objects
20:15:48 <Zekka> mniip: Yeah, it's not sufficiently general though
20:15:56 <edwardk> or that builds a backend out of values that just happen to be lying around in scope
20:15:59 <mniip> m ~ (,t1)
20:16:14 <Zekka> and there's the minor issue that because of the order (,) takes its arguments in, it's usually a monad over the second value, not the first
20:16:42 <edwardk> funfunctor: the existential design is largely viewed as an antipattern because it ties your hands but gives you nothing in exchange compared to the other two approaches
20:17:05 <edwardk> the longer you can delay putting on the existential wrapper the better. in the limit, you never put it on at all
20:17:08 <ansible1> when there are C files in a cabal project, does ghc use gcc for that?  I'm on ARM, so as I understand it ghc relies on llvm.
20:17:23 <ansible1> but maybe its llvm for haskell code and gcc for C?
20:17:53 <edwardk> ok, going, lest she start to resent IRC =P
20:18:26 <mniip> Zekka, with flexible instances, type Flip f a b = f b a
20:18:37 <mniip> then 'instance Monad (Flip (,) a)'
20:18:47 <Zekka> mniip: Sure, that works
20:18:58 <Zekka> Aren't instances for type synonyms a separate extension though?
20:19:05 <Rotaerk> cfoch, http://fpaste.org/188469/14244922/
20:19:10 <Zekka> I don't remember right offhand, I don't usually write type synonym instances
20:19:12 <cmccann> mniip: I don't think that's going to work
20:19:14 <mniip> that would conflict with the existing instance of (,) though
20:19:37 <Rotaerk> cfoch, I moved the "retInitFlags pkgName'" outside of the whole if-else structure, since you seemed to be returned it in every branch
20:19:37 <cmccann> mniip: type synonyms need to be fully applied
20:19:45 <Rotaerk> returning*
20:19:51 <Zekka> Oh yeah, cmccann's right
20:20:10 <Zekka> Just using a newtype would probably work fine
20:20:11 <Rotaerk> cfoch, additionally, since you didn't have any action for the else case, I switched to using the "when" function
20:20:54 <Rotaerk> cfoch, additionally, I screwed up your indentation :P fix it
20:22:12 <mniip> yeah
20:22:18 <mniip> newtype will do
20:22:39 <mniip> but at that point, data Pair a b = Pair b a
20:23:04 <mniip> unless you want to do more typehacks
20:23:40 <cfoch> Rotaerk: that code looks sexier... thanks :p
20:23:42 <hiptobecubic> So I'm looking at https://www.hackerrank.com/challenges/cavity-map, and it would be very easy to solve with the typical double for loop approach, but what's an appropriate haskelly way to look at this?
20:24:39 <hiptobecubic> doing a bunch of zipping and whatever to try to get a map over (center, up, right, down, left) seems ok, but it ends up being a pretty big mess of zips and maps in the end
20:25:17 <Cale> hiptobecubic: It's probably worthwhile constructing an Array of the map
20:25:41 <Cale> hiptobecubic: So that when printing the result, you can easily index into it
20:25:59 <hiptobecubic> Just make a 2D Vector and index around to check the neighbors?
20:26:08 <Cale> yeah
20:26:20 <Cale> You could use Vector I guess. I'd probably just use Array
20:26:28 <hiptobecubic> Why?
20:26:38 <Cale> The fact that you can use pairs to index an Array is convenient
20:26:56 <cmccann> you could always use Ix to index into the Vector
20:27:01 <cmccann> if you wanted to
20:27:10 <Cale> sure
20:27:45 <ReinH> Sounds comonadic.
20:28:11 <ReinH> A point in a map with its neighborhood
20:28:13 <cfoch> I am writing an enhancement for https://github.com/haskell/cabal/issues/2372
20:28:15 <Cale> yeah, it's vaguely comonadic, apart from the treatment of the edges
20:28:49 <ReinH> Cale: what about the treatment of edges?
20:29:09 <hiptobecubic> you can just fake infinity at the edges i would think
20:29:17 <ReinH> maxBound
20:29:22 <Cale> Well, hmm, I suppose with just the right choice of comonad, you could detect that you're at the edge
20:29:22 <hiptobecubic> sure
20:29:23 <cfoch> it is almost ready... how is the process? I just have to create my git repo with its respective branch?
20:29:26 <fread2282> what data structure should I use for fast mappend? I don't need ordering, but do need fold
20:29:51 <cfoch> Rotaerk ^
20:29:58 <ReinH> Or, in fact, minBound, since you have a monoid structure with max and minBound
20:30:04 <fread2282> wait nvm
20:30:19 <ReinH> fread2282: Endo?
20:30:43 <Rotaerk> cfoch, never really messed with github; sorry
20:31:02 <Rotaerk> I'm sure plenty in here have though
20:31:33 <ReinH> cfoch: I suppose you would want to fork it, yes
20:31:34 <cfoch> well... I hope finishing it by tomorrow and uploading it to ask someone to review it
20:31:40 <ReinH> then submit a pull request
20:31:43 <ReinH> for your branch
20:32:05 <mseeks> my haskell programs tend to be a lot less nested than those in other languages -- pretty awesome
20:33:06 <hiptobecubic> ok well off to bed. thanks for the help
20:33:20 <mniip> mseeks, not if you inline all one-shot functions :)
20:33:25 <ReinH> Oh, wait, no, you want edges of the map to *not* be "cavities".
20:33:25 <mniip> or rather, one-use
20:33:42 <ReinH> so you want a zero element, which is maxBound
20:34:02 <mniip> ReinH, pretty sure it's minBound
20:34:16 <ReinH> mniip: "zero" meaning annihilating
20:34:17 <mniip> you can't have a cavity next to minBound
20:34:20 <ReinH> i.e. 0 * x = 0
20:34:32 <ReinH> Yes you can.
20:34:38 <mniip> how so
20:34:41 <ReinH> cavity is max
20:34:45 <mniip> oh right
20:34:46 <mniip> depth
20:34:48 <ReinH> minBound is identity for max
20:34:48 <mniip> positive values
20:34:50 <mniip> maxBound yes
20:34:54 <ReinH> yeah, a bit weird that
20:35:00 <ReinH> but anyway you want a zero
20:35:27 <ReinH> so that it absorbs any elements on the edge and prevents them from being cavities
20:35:28 <mniip> given the input format, even 10 would do
20:35:34 <ReinH> true enough
20:36:11 <standyro> any favorite intro to haskell resources? a few have recommended learn you a haskell...
20:36:14 <standyro> any other recs in the channel?
20:36:24 <ReinH> mniip: you basically have a very simple cellular automata
20:36:46 <ReinH> standyro: https://github.com/bitemyapp/learnhaskell
20:37:46 <standyro> ReinH: thanks!
20:37:58 <ReinH> standyro: np
20:38:03 <zq> why does cabal insist on installing unrelated packages
20:38:16 <mniip> "If you use ACCEPT_KEYWORDS=arch (as opposed to ACCEPT_KEYWORDS=~arch), Portage will install ancient versions of the various Haskell things."
20:38:21 <mniip> ghc 7.6.3 isn't ancient is it
20:38:40 <mniip> oh right
20:38:49 <mniip> cabal-install has no non-~ version
20:39:43 <ReinH> mniip: distro package managers tend to be at minimum 6 months out of date
20:39:57 <ReinH> GHC itself ships packages for some distros though
20:41:16 <lifter> I'm experimenting w/ conduit. How should ResourceT fit into an existing monad transformer stack?
20:41:28 <lifter> I want to do file I/O w/ conduit.
20:42:11 <lifter> Does my monad stack have to have ResourceT in it?
20:42:44 <ReinH> lifter: You can runResourceT everywhere instead.
20:43:18 <ReinH> In fact, since runResourceT runs the release actions, that may be preferable in some cases.
20:43:21 <lifter> ReinH: ok hmm
20:43:51 <mniip> ReinH, as of right now, gentoo has
20:44:00 <mniip> 7.6.3-r1 and ~7.8.4
20:44:23 <mniip> which is far from 6 months behind
20:45:43 <dramforever> Whoa! The 'impossible' happened! What should I do?
20:46:37 <dramforever> I mean, besides reporting a bug
20:46:48 <dolio> Look for a bug report that already exists.
20:46:50 <dramforever> or maybe what should I do before reporting a bug?
20:47:22 <lifter> ReinH: Should I be able to use any function in my monad stack within my conduit functions? Or do the conduit functions need to be in ResourceT IO ?
20:47:31 <dramforever> dolio: oh...of course
20:47:37 <dramforever> just...got so excited
20:48:23 <fread2282> is there some way to get a `Map (STRef s whatever) thing`?
20:48:43 <dramforever> dolio: hmm...should I try ghc HEAD?
20:48:59 <dolio> You could.
20:49:23 <dolio> Trying the 7.10 release candidate might be good, too.
20:50:43 <dramforever> okay
20:51:08 <dolio> Knowing if it's in 7.10 might be better, since maybe it could be fixed before release, depending on how simple it is.
20:51:09 <NemesisD> am I correct in thinking that there's only one valid definition for (<$) :: Functor f => a -> f b -> f a ?
20:51:41 <dolio> HEAD will only tell you if it will be fixed in a year.
20:51:50 <shachaf> NemesisD: Yes.
20:53:23 <NemesisD> shachaf: thanks!
20:53:55 <dramforever> dolio: it seems that the latest rc is 7.10.1 rc 2, right?
20:54:07 <mniip> NemesisD, fmap . const
20:54:09 <dolio> Yes, I think so.
21:02:15 <dot_asp> Can someone help me with this new-if implementation from LISP? http://lpaste.net/3710796334370914304
21:03:11 <dramforever> dot_asp: in the guard on line 18, you need a Bool, and f has type a -> Bool
21:03:17 <fread2282> @hoogle IORef a -> Int
21:03:18 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
21:03:18 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
21:03:18 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
21:03:19 <dramforever> you need to apply f to...
21:03:43 <lpaste> solatis pasted “MonadIO ~ IO deduction error” at http://lpaste.net/120876
21:03:51 <solatis> hi everyone
21:04:04 <solatis> i need some help with some type deduction error
21:04:27 <solatis> the strange thing is: when i compile my module using ghc Protocol.hs, no error is being generated
21:04:58 <solatis> however, when building it as part of a library using cabal build, I get a "Could not deduce (m ~ IO)
21:04:58 <solatis>  from the context (MonadIO m, MonadMask m)" error
21:05:09 <solatis> can anyone help me to find out what is going on?
21:05:49 <dramforever> dolio: How do I run that without installing?
21:05:50 <dramforever> "This is a binary distribution of GHC", according to README
21:06:12 <dolio> I don't know if there are binaries for the RC.
21:06:20 <aavogt> solatis: you could look at what flags cabal is calling ghc with (probably by configuring with -v or -v2 etc.)
21:06:39 <solatis> i already did that, and tried using as many of the flags as possible
21:07:08 <solatis> "C:\Program Files\Haskell Platform\2014.2.0.0\bin\ghc.exe --make -fbuilding-cabal-package -O -outputdir dist\build -odir dist\build -hidir dist\build -stubdir dist\build -i -idist\build -isrc -idist\build\autogen -Idist\build\autogen -Idist\build -optP-include -optPdist\build\autogen\cabal_macros.h -package-name network-anonymous-i2p-0.0.1 -hide-all-packages -no-user-package-db -package-db C:\Users\leon\Documents\GitHub\haskell-network-anonymous-i2p\.cab
21:07:08 <solatis> al-sandbox\x86_64-windows-ghc-7.8.3-packages.conf.d -package-db dist\package.conf.inplace -package-id attoparsec-0.10.4.0-e5e7629398fb0c66d58f89c4a8d38a88 -package-id base-4.7.0.1-7c4827d45272c6220486aa798a981cbc -package-id bytestring-0.10.4.0-0168d7fce99b3d6589c7684c734053d4 -package-id exceptions-0.8-c717140d6c363ff09276c00aac8b01ac -package-id lifted-base-0.2.3.6-7b3e0a4fc1f61e170d9f820e4d97d3e2 -package-id mtl-2.2.1-0db3f4af3aa7d4f65cd93cb12a76659c
21:07:08 <solatis> -package-id network-2.4.2.2-abe8c1542476062034ec5fdc90ac1a25 -package-id network-attoparsec-0.10.1-fb319f11b4a1070dff5685b84ef9eda5 -package-id network-simple-0.2.1.0-47ba656009dc77a7222fc12d98f9b4de -package-id resourcet-1.1.4.1-b0270ac1df2dde7185bfebbdde0fec59 -package-id text-1.1.0.0-1ba76b4f9f9528508a58bb9d9558efa3 -package-id transformers-0.4.2.0-1aa9c4b3c344429da090575a739292ad -XHaskell2010 Network.Anonymous.I2P Network.Anonymous.I2P.Types
21:07:13 <solatis> Network.Anonymous.I2P.Internal.Network.Protocol Network.Anonymous.I2P.Internal.Network.Protocol.Parser Network.Anonymous.I2P.Internal.Debug -rtsopts"
21:07:14 <EvanR> bawaw
21:07:16 <solatis> wow
21:07:18 <solatis> sorry
21:07:47 <solatis> anyway, i could see nothing suspicious there ?
21:07:49 <aavogt> is there any LANGUAGE CPP in that file?
21:08:01 <solatis> no, only OverloadedStrings
21:08:11 <dramforever> whoa whoa whoa
21:08:15 <solatis> but there *is* a language CPP in another module
21:09:02 <solatis> so i assume that the c preprocessor is loaded somewhere
21:10:09 <aavogt> so then it's possible that the -optPdist\build\autogen\cabal_macros.h is making a difference
21:10:56 <solatis> let me test that
21:11:30 <aavogt> maybe there is an #ifdef in one of the imported modules that changes the code you're actually compiling
21:13:12 <solatis> hmmm doesn't seem like it
21:13:52 <dot_asp> thanks dramforever, I think I fixed it
21:14:12 <dramforever> dolio: never mind. I installed to `pwd`/installation
21:14:13 <fread2282> how can I use (someLens.ix i) as a Getter s (Maybe a) ?
21:15:50 <dramforever> dolio: yes, still happening in 7.10.1 rc 2
21:18:13 <cfoch> Rotaerk: I don't have "when function". Where is it?
21:18:19 <cfoch> in what module
21:18:42 <wayne> what's the prettiest way to implement map with foldl?
21:18:57 <shachaf> It's impossible.
21:19:47 <aavogt> sounds like you're allowed to use two foldls
21:20:32 <aavogt> :t \f -> foldl (flip (:)) [] . foldl (\xs x -> f x : xs) []
21:20:33 <lambdabot> (a1 -> a) -> [a1] -> [a]
21:20:51 <shachaf> Well, that's still not map.
21:21:07 <shachaf> Except for finite lists.
21:21:16 <wayne> yeah i guess so
21:21:58 <cmccann> shachaf: and statistically speaking, roughly 0% of lists are finite, so I think we can safely ignore that as an unlikely corner case
21:22:19 <shachaf> Exactly.
21:22:31 <wayne> haha
21:23:58 <shachaf> One of the reasons infinite cases are useful to think about is that termination in an infinite case is related to (asymptotic) efficiency in a finite case.
21:24:14 <Rotaerk> cfoch, use hayoo to find it
21:26:41 <cfoch> ok, thanks Rotaerk
21:26:42 <cfoch> I found it
21:26:47 <cfoch> I need some sleep
21:26:50 <cfoch> o/
21:26:54 <cfoch> thanks again
21:27:15 <wayne> intuition would suggest that foldl could work on infinite lists, but that's not the case
21:31:09 <SrPx> Please am I understanding this correctly? When applying type inference to the STLC expression (λ a . (λ b . b a)), you end up with a single constraints: [x == (y → z)], which is solved with `z <- T, y <- T, x <- T → T`. Does this make sense or am I too far off?
21:32:23 * SrPx is trying to decipher cryptic mathy paper mumbo jumbo atm 
21:39:14 <dramforever> Hi, I've just posted a ghc bug, https://ghc.haskell.org/trac/ghc/ticket/10105
21:39:16 <wayne> @stc foldl'
21:39:16 <lambdabot> foldl' f a []     = a
21:39:16 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:39:20 <dramforever> It's my first report
21:39:28 <dramforever> Let me know if I can improve it
21:39:42 <acetoline> you can improve it.
21:39:53 <dramforever> acetoline: oh lol
21:39:56 <dramforever> s/if/how
21:44:11 <ddellacosta> is this paper roughly the origin of current idiomatic usage of Applicative Functors (over Monads?) in Haskell? http://staff.city.ac.uk/~ross/papers/Applicative.html
21:46:03 <ddellacosta> is it fair to say that the use of Arrows was obviated by Applicative Functors becoming more prevalent in idiomatic Haskell usage, or should I avoid making those kinds of generalizations?
21:47:58 <Javran> I'm trying to clone ghc repo and build the latest version.  I got the following error: http://lpaste.net/981517932578209792 any idea?
21:48:35 <heatsink> dramforever: There's a list of related bugs at https://ghc.haskell.org/trac/ghc/wiki/Status/SLPJ-Tickets
21:48:49 <heatsink> dramforever: see the entry "contravariant data type loop in simplifier"
21:48:59 <heatsink> dramforever: You could add a reference to that
21:49:58 <dramforever> heatsink: Actually...I'm wondering if I'm pushing ghc too hard
21:50:56 <heatsink> No, that's a simple piece of code
21:51:02 <EvanR> ddellacosta: all generalizations are bad
21:51:11 <dramforever> heatsink: ouch
21:51:14 <dramforever> https://ghc.haskell.org/trac/ghc/ticket/8833
21:51:26 <BMeph> ddellacosta: Arrows were always more of a thought experiment/exercise; Applicatives have always been more popular in use.
21:51:44 <ddellacosta> BMeph: ah, okay, thanks--I wasn't sure of their respective histories/lineages
21:51:52 <dramforever> heatsink: Turned out I'm not the first one: https://ghc.haskell.org/trac/ghc/ticket/8833
21:51:52 <BMeph> ddellacosta: That's my impression, anyway.
21:52:52 <dramforever> heatsink: but why would it use the inliner?
21:54:23 <heatsink> dramforever: The code has function calls where both the function and argument expression are small expressions, so they get inlined
21:54:57 <dramforever> heatsink: so...still not the first
21:56:12 <heatsink> Right.  As you can see, #8833 has 6 related tickets.
21:57:35 <heatsink> Thank you for taking the time to make a bug report, though
21:57:59 <dramforever> good
21:58:53 <dramforever> your welcome
22:03:06 <adel> Newbie here. "mymaximum = foldl1 max" does not compile. Why?
22:04:54 <shachaf> You tell us.
22:05:15 <shachaf> You're the one who just put it in a file and got a compilation error.
22:05:24 <shachaf> We didn't see the file or the error.
22:07:26 <adel> Yes, the file is as simple as this one line. The top-most error: "No instance for (Ord a0) arising from a use of ‘max’"
22:08:13 <adel> "let mymaximum = foldl1 max" works just fine.
22:09:08 <adel> ghci version is 7.8.3
22:10:31 <Javran> try putting "{-# LANGUAGE NoMonomorphismRestriction #-}" on the first line
22:10:49 <mikeplus64> adel: or just write mymaximum :: Ord a => [a] -> a, before that
22:12:18 <lifter> I'm using conduit; I have a "sink" function of type "Sink T.Text (ResourceT (StateT MyState IO)) ()"; in the body of this "state" function I have a call to a function "f :: StateT MyState IO ()" and to get everything to typecheck I found had to lift "f" twice as in "lift . lift"... can anyone explain why?
22:12:54 <johnw> you're lifting once to go from Sink to ResourceT
22:12:56 <lifter> sorry "state" function should be "sink" function bah
22:12:59 <johnw> twice to go from ResourceT to StatetT
22:13:03 <adel> mikeplus64: With type annotation it compiles. Weird that it works without type annotation in ghci.
22:13:19 <johnw> if you lifted a third time, you'd be in IO
22:13:44 <Javran> adel: related https://wiki.haskell.org/Monomorphism_restriction
22:14:20 <lifter> johnw: oh wow, ok I didn't realize I was lifting once to get from Sink to ResourceT
22:14:22 <lifter> thanks
22:14:24 <johnw> lifter: also, note that both Sink and ResourceT support MonadState
22:14:38 <johnw> so if you import Control.Monad.State.Class, you can just use "get" and "put" without any lifting at all
22:14:51 <adel> Javran: thanks for the link!
22:15:32 <lifter> johnw: what about a function that does some IO? That would still need to be lifted, right?
22:15:35 <johnw> and since lenses use MonadState, you can make State even *more* painless...
22:15:40 <johnw> use liftIO
22:15:48 <johnw> from Control.Monad.IO.Class
22:16:26 <Javran> bump: I'm trying to clone ghc repo and build the latest version.  I got the following error: http://lpaste.net/981517932578209792 any idea?
22:16:38 <lifter> johnw: Ok, I don't think I can get around the lifting twice I have to do for the function I mentioned tho...?
22:16:50 <johnw> lifter: depends on what you need to do in StateT
22:17:05 <johnw> to use another StateT action, you'll need to lift . lift
22:17:13 <lifter> ok
22:19:07 <Sornaensis> does anyone here know of any resources on dyanmic linking with haskell
22:22:20 <heatsink> What do you want to dynamically link and when?
22:22:30 <Sornaensis> a module at runtime
22:23:10 <heatsink> Do you want it to be linked to a program when the program is loaded?
22:24:19 <Sornaensis> I want to be able to dynamically load and unload and reload a module, at runtime
22:27:23 <ddellacosta> anyone know of a good, up-to-date survey paper on functional graph algorithms/data structures?
22:27:30 <mjrosenb> morning all, I'm trying to use reactive.banana, and I cannot think of a scenario where one of the event handlers gets registered multiple times
22:28:34 <ddellacosta> looking at this now: https://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf  which appears to be the basis for http://hackage.haskell.org/package/fgl, but it's from 2001
22:41:45 <naevathecat> Hey all, I'm learning Haskell atm, currently working my way through LYAHFGG. Are there any compilations of fun problems to solve that teach good Haskell habbits floating around?
22:42:21 <heatsink> Sornaensis: That is not easy to do.  You probably would have to use the API of GHC.
22:43:43 <ddellacosta> naevathecat: I enjoyed this set of exercises: https://github.com/opqdonut/haskell-exercises
22:44:19 <Abelardo> if i put  this in cabal config
22:44:21 <Abelardo> Don't allow global install of packages. require-sandbox: True
22:44:34 <Abelardo> and  i havent installed alex or happy
22:44:41 <Abelardo> there is no problem ?
22:45:55 <naevathecat> Thanks ddellacosta! I'm taking a look at it now. From what I've seen so far it's a pretty cool language but coming from C/C#/Python it's a very different way of working
22:46:13 <ddellacosta> naevathecat: yes indeed. :-)
22:46:51 <mjrosenb> actually, I have a bunch of questions about reactive.banana, although a bunch of them are probably general FRP questions
22:47:00 <mjrosenb> anyone familiar with them?
22:49:14 <jle`> mjrosenb: don't ask to ask, just ask :D
22:49:22 <lfairy> mjrosenb: no need to ask for permission to ask -- just ask ;)
22:49:24 <Procian> khyperia: I played around a bit with a breadth-first search monad (as opposed to lists depth first). The idea is that can collapse [[a]] even when each element is infinite. I basically had tried the same thing for an IRC bot, where the streams where parameterised by an event stream.
22:52:10 <johnw> Procian: have you looked at LogicT?
22:53:18 <Procian> johnw: I had. But at the time, I believe it didn't give very strong guarantees on the order in which elements were generated.
22:53:25 <Procian> I went instead with stuff done by Spivey.
22:54:31 <mjrosenb> jle`: I did ask, then nobody responded :-p
22:54:51 <mjrosenb> jle`: more relevantly, I don't want to flood the channel with questions if nobody is going to bother answering.
22:55:15 <jle`> mjrosenb: if nobody responds, then htat's because nobody knows the answer
22:55:19 <jle`> at that time
22:55:29 <johnw> or wants to answer
22:55:29 <jle`> so asking if anyone knows the answer is only going to get you the same response ;)
22:55:40 <jle`> there is no difference in the result
22:56:16 <mjrosenb> jle`: fair enough.
22:57:12 <mjrosenb> anyhow, I am trying to hook sdl2 up to reactive-banana, and it looks like sdl was hooked up by just putting all events from the main sdl input into a single reactive event
22:57:15 <jle`> better to just ask your question again at a later time
22:58:30 <mjrosenb> then filtering that out and routing it to individual places, this seems less efficient than routing every type of sdl event to a single reactive event
23:05:38 * hackagebot network-attoparsec 0.11.0 - Utility functions for running a parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.11.0 (solatis)
23:06:24 <lfairy> mjrosenb: given the rate of events that come through, I don't think there's a performance problem here
23:09:53 <lfairy> mjrosenb: most of the processing would be in graphics and physics and other game logic, not initial routing
23:10:13 <lfairy> mjrosenb: but you'll need to ask someone who's actually implemented this stuff to get a firm answer
23:20:57 <nerium> I'm trying to implement this method https://gist.github.com/oleander/bf03a2a459002ed8600c
23:21:07 <nerium> But is getting Not in scope: ‘Map.empty’
23:21:11 <nerium> Why is that?
23:23:03 <ezrios> nerium: what's your version of containers
23:23:53 <nerium> ezrios: I solved it, but now I'm getting https://gist.github.com/oleander/d11ee86c30a9d64d1825
23:24:10 <nurupo> how can i rewrite "(f x) `mod` n" without the infix and parens?
23:24:44 <ezrios> mod (f x) n
23:25:10 <nerium> ezrios: Any idea?
23:25:20 <nurupo> still have parens :)
23:25:43 <xkb> Does anyone here know how to do | in attoparsec?
23:26:15 <Cale> nerium: You've defined the data type Block as having a single data constructor called Map which has two fields String and Int
23:26:28 <xkb> I have a Command parser, where Command is a datatype. but the input is Command | String
23:26:29 <jle`> nurupo: let k = f x in mod k n
23:26:34 <Cale> nerium: perhaps you meant  type Block = Map String Int
23:27:33 <nerium> @Cale Aha, that worked. Thanks!
23:27:34 <lambdabot> Unknown command, try @list
23:28:07 <Cale> xkb: <|>
23:28:09 <nurupo> jle`: that's going too far
23:28:37 <Cale> xkb: From the Alternative class defined in Control.Applicative, of which Attoparsec's Parser type is an instance.
23:28:46 <nurupo> well, will leave it like that then
23:29:54 <xkb> Cale: thanks
23:31:56 <lpaste> nurupo pasted “How to remove this warning from ^ operation” at http://lpaste.net/3507931671632543744
23:32:06 <mniip> wait
23:32:26 <mniip> isn't hypothetically from Acme.RealWorld basically unsafeDupableInterleaveIO?
23:32:34 <nurupo> do i need a cast somewhere?
23:32:52 <mniip> :t (^)
23:32:53 <lambdabot> (Num a, Integral b) => a -> b -> a
23:33:04 <Cale> nurupo: Do you have -Wall turned on?
23:33:09 <nurupo> yes, i do
23:33:11 <mniip> the return type is an Integer, so it knows that 10 is an Integer
23:33:17 <mniip> it can't however deduce b, aka 100
23:33:22 <Cale> Yeah, that kind of thing is why I don't usually turn on -Wall :P
23:33:30 <Cale> The warning is harmless
23:33:46 <Cale> You could get rid of it by giving an explicit type signature to your exponent
23:33:53 <Cale> like  10^(100 :: Integer)
23:33:57 <Cale> but that's ugly
23:36:19 <jle`> yeah it really bugs me
23:36:55 <Cale> There needs to be -Wuseful or something
23:37:04 <Cale> Or just better default warnings
23:37:33 <jle`> (^^) :: Num a => a -> Int -> a
23:37:39 <jle`> (^^) = (^)
23:38:14 <nurupo> -Wall -Wextra -pedantic -Werror ? :)
23:38:25 <Cale> :t (^^)
23:38:26 <lambdabot> (Integral b, Fractional a) => a -> b -> a
23:38:38 <nurupo> it's not gcc though
23:38:49 <nurupo> only has so much warning options
23:38:56 <Cale> nurupo: The problem isn't that -Wall doesn't do enough, it's that it does too much :)
23:39:41 <Cale> There are a lot of warnings that -Wall enables that I think are silly
23:40:03 <Cale> and then people "fix" these warnings and end up with weird looking code
23:41:09 <nurupo> well, i just have a habit of always enabling warnings in my projects and fixing them
23:42:04 <nurupo> but some of them are silly indeed
23:42:13 <jle`> -Wallexceptforsomethings
23:42:28 * nurupo talks mainly about gcc
23:42:29 <jle`> i still maintain it is a good habit to -Wall and treat warnings as errors
23:48:51 <johnw> jle`: I agree
23:49:01 <johnw> although, maybe not put -Wall in your .cabal that gets pushed to Hackage
23:50:15 <jle`> oops
23:50:40 <johnw> or if you do, don't also use -Werror
23:51:08 <johnw> point-release changes in GHC could add a new, harmless warning and now your code doesn't even build (like the AMP warning)
23:53:44 <johnw> EvanR: ping
23:57:07 <jle`> good, it punishes them for being too edge
