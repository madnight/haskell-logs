00:08:50 * hackagebot hunt-server 0.3.0.0 - A search and indexing engine server.  http://hackage.haskell.org/package/hunt-server-0.3.0.0 (alexbiehl)
00:08:50 * hackagebot hunt-server-cli 0.2.0.0 - A Command line Interface for the Hunt server.  http://hackage.haskell.org/package/hunt-server-cli-0.2.0.0 (alexbiehl)
00:26:54 <HeladoDeBrownie> re: lens, what type can i give something so it's unifiable with both ASetter s t a (Maybe b) and Getting a s a?
00:27:34 <HeladoDeBrownie> erm, a is two distinct variables in those, sorry, i just copied from the docs
00:31:18 <HeladoDeBrownie> also i don't need a fully specified type, just pointing at the right place in the hierarchy is fine
00:31:35 <HeladoDeBrownie> i think it's Lens but i might be wrong
00:32:16 <HeladoDeBrownie> ah yep, it was Lens. i was just being silly and applying it to the wrong things.
00:40:18 <mrkkrp> What if I need something like guards in do block (evaluate some expression and perform some actions if it's true and stop evaluating other alternatives)? Which construction should I use?
00:40:54 <keko-2> make a separate function and use guards in that?
00:41:01 <ski> what are the "other alternatives" ?
00:41:19 <ski> if you have a `case' inside the `do', then you can have guards in the `case' (as you always can)
00:41:23 <Zemyla> You know, there should be a RandomT that's different from a StateT because it ises a forall over the state type, making it go over all RandomGen.
00:42:01 <Zemyla> newtype RandomT m a = RandomT { runRandomT :: (RandomGen g) => forall g. g -> (a, g) }
00:42:07 <ski> Zemyla : did you try `hoist' ?
00:42:07 <mrkkrp> ski, I didn't know that I can put guards in `case'. I will try it.
00:42:19 <Zemyla> :t hoist
00:42:20 <lambdabot> Not in scope: ‘hoist’
00:42:28 <Zemyla> @hoogle hoist
00:42:29 <lambdabot> No results found
00:42:47 <ski> <Zemyla> If I have a function (Monad m) => m a -> m a, how do I turn it into a function (MonadTrans t, Monad m) => t m a -> t m a?
00:42:50 <ski> <ski> Zemyla : try `hoist' in `mmorph' ?
00:42:55 <ski> @hackage mmorph
00:42:55 <lambdabot> http://hackage.haskell.org/package/mmorph
00:44:55 <mrkkrp> ski, how can I put guards in `case'? Note that I don't need pattern matching at all, I need to use expressions that return Boolean values.
00:47:14 <Zemyla> ski: That only works on natural transformations.
00:47:32 <Zemyla> The functions I want to hoist aren't natural.
00:47:40 <Zemyla> And they aren't changing monads.
00:49:40 <Zemyla> In fact, it's pretty much the opposite of what I want.
00:50:02 <ski> Zemyla : yes, you'd need `forall a. Monad m => m a -> m a' for your input, there
00:50:19 <Zemyla> There's no function in general that's (m a -> m b) -> (t m a -> t m b)?
00:50:29 <ski> mrkkrp : try `case () of () | blah -> ... | bleh -> ... | bloh -> ...'
00:51:04 <jle`> Zemyla: if that's the type signature of your function, then it should work, shouldn't it
00:51:15 <ski> mrkkrp : or try <http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#multi-way-if>
00:51:17 <jle`> unless you mean you have a Monad m => m Int -> m Int
00:51:29 <jle`> or something like that
00:51:42 <mrkkrp> ski, heh, interesting thing
00:51:55 <jle`> hoist will still work when the source and target functor are the same
00:52:05 <ski> Zemyla : certainly now for any `a',`b',`m',`t' at all
00:52:19 <ski> er
00:52:22 <ski> s/now/not/
00:57:45 <sgronblo> http://code.haskell.org/~dons/talks/dons-google-2015-01-27.pdf wonder why this one suddenly became inaccessible...
00:58:06 <jle`> welp time to pick bounds on my package dependencies for my library
00:58:11 <jle`> is there a guide somewhere that details best practices?
00:58:24 <jle`> or should i just make the upperbound the next major version bump
00:59:47 <rhaps0dy> jle`: No bounds!
01:00:14 <rhaps0dy> na i guess leave it at the api no breaking
01:00:27 <rhaps0dy> as in, pick thr version you're in now
01:00:37 <rhaps0dy> and force the first number to be the same
01:00:43 <rhaps0dy> but leave all the others be
01:01:05 <jle`> there's been a lot of controversy about this recently...wanted to know if there was some consensus that came about heh
01:01:24 <jle`> if not then i'll just probably limit to the current major version
01:02:14 <rhaps0dy> oh.
01:02:14 <Zemyla> Hmm. Is there an instance (m a -> m b) -> WriterT w m a -> WriterT w m b?
01:02:37 <rhaps0dy> jle`: ask again in a few minutes then
01:03:28 <jle`> :)
01:04:05 <jle`> Zemyla: are you really getting an (m a -> m b)?
01:04:29 <jle`> and not like an (a -> m b) that you are binding or an (a -> b) that you are fmapping
01:05:05 <ski> Zemyla : hm, i think there can't be (for any `a',`b',`m', even if you add `Monad m')
01:05:33 <ReinH> @unmtl WriterT w m a
01:05:33 <lambdabot> m (a, w)
01:05:41 <jle`> it does sound possible
01:05:57 <jle`> (m a -> m b) -> (m (a, w) -> m (b, w))
01:06:12 <jle`> hm
01:06:15 <jle`> maybe my intuition is off here
01:06:24 <ski> @type mapWriterT
01:06:25 <lambdabot> (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
01:06:30 <ski> @type mapWriterT . liftM
01:06:32 <lambdabot> Monad n => ((a, w) -> (b, w')) -> WriterT w n a -> WriterT w' n b
01:06:33 <ski> @type mapWriterT . liftM . first
01:06:34 <lambdabot> Monad n => (a -> b) -> WriterT w' n a -> WriterT w' n b
01:06:37 <ski> doesn't really help
01:06:44 <jle`> yeah, i see
01:07:07 <ski> (the problem is to preserve the `w' over, while keeping the `m' around)
01:07:10 <ReinH> You can't do anything with an m a -> m b except for apply it to an m a
01:07:14 <jle`> (m a -> m b)'s are actually really opaque kinda boxes anyway...they are rare in practice too for most monads you want to do monadey things with
01:07:35 <jle`> i don't thinky ou really can do any monadey thing with it, yeah
01:07:38 <bitemyapp> (a -> b) is an opaque box too
01:07:49 * ski isn't quite sure what jle` means here
01:07:53 <jle`> hm
01:07:56 <jle`> i'm not sure what i mean either
01:08:06 <bitemyapp> jle`: words are bad
01:08:20 <ski> let's take a vow of silence
01:08:37 <bitemyapp> vow of monadic silence
01:08:44 <jle`> :t censor
01:08:46 <lambdabot> MonadWriter w m => (w -> w) -> m a -> m a
01:09:17 <jle`> censor (const mempty)
01:09:33 <ReinH> m a -> m b might as well be a -> b for all we can tell
01:09:35 <bitemyapp> :t censor (const mempty)
01:09:36 <lambdabot> MonadWriter w m => m a -> m a
01:09:47 <bitemyapp> ReinH: that was my point
01:09:53 <ski> it all depends on who gets to pick the `a',`b',`m' ...
01:09:54 <bitemyapp> 09:06 < bitemyapp> (a -> b) is an opaque box too
01:10:05 <bitemyapp> Also see: 09:08 < bitemyapp> 09:06 < bitemyapp> (a -> b) is an opaque box too
01:10:14 <bitemyapp> you can also reference: 09:08 < bitemyapp> Also see: 09:08 < bitemyapp> 09:06 < bitemyapp> (a -> b) is an opaque box too
01:10:19 <jle`> yeah...i guess what i'm trying to say is that `m a -> m b`, the fact that the m is there is meaningless, it might as well be `c -> d`
01:10:29 <ReinH> bitemyapp: lol
01:10:29 <jle`> nice references bitemyapp
01:10:33 * ski invites bitemyapp to make a cyclic reference
01:10:38 * bitemyapp gesticulates wildly at the computer
01:10:44 * jle` is tempted to `fix bitemyapp`
01:10:47 <bitemyapp> I need to be less subtle.
01:11:16 * ReinH has no comment on that
01:11:42 <bitemyapp> good, so that one wasn't lost to the void
01:12:24 <ReinH> ski: does it? I'll let you pick who picks. How does that let you write the function?
01:12:25 <jle`> is there another haskellcast coming soon
01:12:37 <Zemyla> What I actually want to do is lift a function nbind :: Int -> m a -> ([a] -> m b) -> m b to Int -> WriterT w m a -> ([a] -> WriterT w m b) -> WriterT w m b.
01:12:39 <ReinH> jle`: Nothing scheduled. I should talk to Chris about it.
01:13:03 <ReinH> Zemyla: Ah, so something completely different. Got it.
01:13:16 <jle`> that sounds like it makes more sense
01:13:48 * hackagebot hpqtypes 1.4.0 - Haskell bindings to libpqtypes  http://hackage.haskell.org/package/hpqtypes-1.4.0 (GracjanPolak)
01:13:55 <ski> ReinH : i meant wrt whether `m a -> m b' is opaque or not
01:14:05 <ReinH> ski: it's still a function
01:14:15 <ski> sure
01:14:43 <jle`> how do you define types in djinn again
01:14:56 <ReinH> I guess if you can show that there's only one defined inhabitant, like if you pick m ~ Identity, a ~ b
01:14:58 <Zemyla> Okay, so \m -> nbind n m f has the signature m a -> m b, but opening it up makes it more tractable, I guess?
01:15:05 <ski> @djinn-add type NotNot = Not (Not a)
01:15:05 <lambdabot> Error: Undefined type variable a
01:15:11 <ski> hm
01:15:37 <ReinH> type NotNot a perhaps
01:16:29 <jle`> does nbind have an implementation or are you trying to find something that works for all functions of that type signature
01:16:36 <ski> @djinn-add type NotNot a = Not (Not a)
01:16:38 <ski> (silly me)
01:16:49 <ski> @djinn-env
01:16:50 <lambdabot> data () = ()
01:16:50 <lambdabot> data Either a b = Left a | Right b
01:16:50 <lambdabot> data Maybe a = Nothing | Just a
01:16:50 <lambdabot> data Bool = False | True
01:16:50 <lambdabot> data Void
01:16:52 <lambdabot> type Not x = x -> Void
01:16:54 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
01:16:56 <lambdabot> class Eq a where (==) :: a -> a -> Bool
01:16:58 <lambdabot> type NotNot a = Not (Not a)
01:17:07 <jle`> since when did djinn have Monad
01:17:16 <ski> jle` : similarly for `data' (and probably also `newtype')
01:17:29 <ski> since forever, i think ?
01:17:34 <ski> also, it's broken
01:17:35 <jle`> interesting
01:17:47 <ski> (because Djinn doesn't handle higher-rank)
01:17:56 <jle`> @djinn Monad m => m a -> (a -> m b) -> m b
01:17:56 <lambdabot> f = (>>=)
01:18:08 <ski> @djinn Monad m => a -> m a
01:18:09 <lambdabot> f = return
01:18:10 <ski> @djinn Monad m => b -> m b
01:18:10 <lambdabot> -- f cannot be realized.
01:18:14 <ski> see ^ ?
01:18:17 <jle`> ah i see
01:18:42 <jle`> @djinn Monad m => (a -> b -> m c) -> m a -> m b -> m c
01:18:42 <lambdabot> -- f cannot be realized.
01:18:48 * hackagebot OpenGL 2.11.0.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.11.0.0 (SvenPanne)
01:18:49 <phaazon> (Djinn sounds a bit like Jean, which makes me laugh)
01:19:22 <ski> it doesn't understand how to instantiate the polymorphic operations inside `Monad m', in the context `Monad m =>' there
01:19:39 <ski> @djinn Monad m => Bool -> m Bool
01:19:39 <lambdabot> -- f cannot be realized.
01:20:31 <jle`> it cannot even
01:20:44 <ReinH> It is currently experiencing some difficulty while attempting to even
01:32:18 <nocturne777> why does this produce "Nothing" : (Just 3) >>= \x -> Nothing >>= \y -> return (x+y)
01:32:39 <phaazon> nocturne777: do you know Maybe?
01:32:44 <nocturne777> oh I get it now
01:32:44 <phaazon> and Monad?
01:32:48 <nocturne777> the coin drops
01:32:55 <jle`> the parentheses might help
01:33:00 <nocturne777> it's because of this  Nothing  >>= k = Nothing
01:33:04 <nocturne777> ahaha
01:33:07 <phaazon> yes
01:33:08 <bjornars1> nocturne777: Maybe is like a burrito
01:33:11 <jle`> Just 3 >>= (\x -> (Nothing >>= (\y -> Just (x+y))))
01:33:14 <phaazon> bind discards on Nothing
01:33:25 <nocturne777> yes, I know all that stuff
01:33:28 <nocturne777> I am learning Monads
01:33:34 <jle`> nocturne777: if you think about it, it's the only thing that makes sense
01:33:43 <jle`> even if you didn't know about the implementation
01:33:46 <jle`> of Maybe's instance
01:33:56 <jle`> because...why would "y" be?
01:34:06 <jle`> what value could "y" possibly be, in that example?
01:34:16 <phaazon> > Just 3 >>= \x -> Nothing >>= \y -> return x + y
01:34:16 <Zemyla> 0? :P
01:34:17 <lambdabot>  No instance for (GHC.Show.Show b0)
01:34:17 <lambdabot>    arising from a use of ‘M620937802511598386715584.show_M6209378025115983867...
01:34:17 <lambdabot>  The type variable ‘b0’ is ambiguous
01:34:22 <jle`> it sorta makes sense from looking at it that x should be 3
01:34:28 <jle`> but what would y even be
01:34:31 <phaazon> > Just 3 >>= \x -> Nothing >>= \y -> return x + y :: Maybe Int
01:34:31 <merijn> bjornars1: Please let that jokes die, it's not very funny and not at all helpful for beginners
01:34:32 <lambdabot>  No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
01:34:32 <lambdabot>    arising from a use of ‘GHC.Num.+’
01:34:39 <phaazon> > Just 3 >>= \x -> Nothing >>= \y -> return (x + y) :: Maybe Int
01:34:40 <lambdabot>  Nothing
01:34:53 <jle`> where are you going to pull a value from thin air that you can use for "y"?
01:35:11 <merijn> nocturne777: My advice: don't "learn monads", learn individual monad instances, occasionally meditate on the type signature, repeat until your intuition starts to make sense
01:35:13 <phaazon> > getAny $ (Any $ Just 3) >>= \x -> Nothing >>= \y -> return (x + y) :: Maybe Int
01:35:15 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Any’
01:35:15 <lambdabot>              with actual type ‘Data.Maybe.Maybe GHC.Types.Int’Couldn't match ...
01:35:15 <lambdabot>              with actual type ‘Data.Monoid.Any’Couldn't match expected type ‘...
01:35:23 <tero-> simple calculator happy grammar at http://lpaste.net/121277 . I'm trying to parse "apply expressions" with the rule "Exp : Exp Exp %prec EXP" so that "a 1 2" would parse to '(Apply ((Apply (Var "a") (Int 1)) (Int 2)' and not to 'Apply (Var "a") (Apply (Int 1) (Int 2))'. any tips?
01:35:26 <nocturne777> jle`: yes, it does not make sense
01:35:30 <merijn> nocturne777: Additionally, try to implement monad instance for types you invent and prove they obey the laws
01:35:33 <phaazon> > getAny $ (Any $ Just 3) >>= \x -> (Any Nothing) >>= \y -> return (x + y) :: Maybe Int
01:35:34 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Any’
01:35:34 <lambdabot>              with actual type ‘Data.Maybe.Maybe GHC.Types.Int’Couldn't match ...
01:35:34 <lambdabot>              with actual type ‘Data.Monoid.Any’Couldn't match expected type ‘...
01:35:37 <phaazon> yeah, whatever.
01:35:45 <nocturne777> merijn: that is the plan
01:36:17 <merijn> nocturne777: A simple exercise along that line is "data Foo a = Foo (a -> Bool)" a Functor? If not, why not?
01:36:18 <jle`> phaazon: Any doesn't even have the right kind to be a Monad :P
01:36:36 <phaazon> jle`: I think it's also because it's not what I'm looking for
01:36:40 <phaazon> Any works on Bool
01:36:44 <jle`> mhm
01:36:59 <nocturne777> merijn: Foo is not an instance of Functor, so it is not a functor yet
01:37:07 <jle`> hehe
01:37:16 <merijn> nocturne777: I mean, "could you make it one?" :p
01:37:17 <jle`> A+
01:37:23 <nocturne777> yeah
01:37:26 <nocturne777> ahahaa
01:37:50 <nocturne777> I've made couple of functors already that works with fmap
01:38:02 <nocturne777> yay! :)
01:38:10 <jle`> so...can it?
01:38:15 <jle`> write one for that type :)
01:38:33 <jle`> (i dare you)
01:38:59 * hackagebot postgresql-query 1.0.0 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  http://hackage.haskell.org/package/postgresql-query-1.0.0 (AlekseyUymanov)
01:39:02 <ski> nocturne777 : if it is a functor, then it is one before you make a `Functor' instance for it
01:44:16 <nocturne777> merijn: that cannot be a Functor, actually
01:44:27 <ski> why ?
01:44:32 <nocturne777> how can one map over a function
01:44:33 <nocturne777> ?
01:44:38 <nocturne777> that's why I think
01:45:37 <merijn> Ah, but you can map over functions, but you are correct that THIS can't be a functor :)
01:45:53 <ski> > [f 1 | f <- map (fmap (^2)) [(2 *),(3 *)]]  -- `fmap' over function values
01:45:55 <lambdabot>  [4,9]
01:46:26 <merijn> nocturne777: For example, THIS can be a functor: "data Bar a = Bar (Bool -> a)", can you figure out how to implement that? :)
01:46:52 <idetuxs> Hi!
01:46:56 <nocturne777> merijn: let's continue tomorrow, I gotta turn in
01:46:58 <nocturne777> :)
01:59:59 <mpickering> Is there a reason that if I want to depend on a library as a dependency, all the dependencies for the bundles executables are built as well?
02:00:10 <mpickering> is there a way in the cabal file to stop this happening?
02:04:07 * hackagebot amazonka-core 0.3.1 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.3.1 (BrendanHay)
02:04:09 * hackagebot amazonka 0.3.1 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.3.1 (BrendanHay)
02:04:11 * hackagebot amazonka-autoscaling 0.3.1 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.3.1 (BrendanHay)
02:04:13 * hackagebot amazonka-cloudformation 0.3.1 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.3.1 (BrendanHay)
02:04:15 * hackagebot amazonka-cloudfront 0.3.1 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.3.1 (BrendanHay)
02:09:17 * hackagebot amazonka-cloudhsm 0.3.1 - Amazon CloudHSM SDK.  http://hackage.haskell.org/package/amazonka-cloudhsm-0.3.1 (BrendanHay)
02:09:19 * hackagebot amazonka-cloudsearch 0.3.1 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.3.1 (BrendanHay)
02:09:21 * hackagebot amazonka-cloudsearch-domains 0.3.1 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.3.1 (BrendanHay)
02:09:23 * hackagebot amazonka-cognito-identity 0.3.1 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.3.1 (BrendanHay)
02:09:25 * hackagebot amazonka-cognito-sync 0.3.1 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.3.1 (BrendanHay)
02:10:11 <KaneTW> Anyone have an idea why www.haskell.org isn't loading for me? Everything else works but haskell.org gives a timeout.
02:10:36 <shiona> works for me (tm)
02:10:52 <KaneTW> yeah it's really weird
02:10:52 <phaul> is https blocked on your end?
02:10:57 <KaneTW> nope
02:11:19 <ibid> traceroute?
02:11:44 <KaneTW> traceroute looked fine too yesterday, lemme rerun it again
02:11:48 <jophish> Who is the maintainer for Hackage. I requested a username, but haven't recieved an email yet
02:12:00 <sLite> tried wget/curl or something?
02:13:32 <KaneTW> lemme try that
02:13:34 <KaneTW> good idea
02:14:19 <KaneTW> https://a.pomf.se/afsoaf.png times out again
02:14:27 * hackagebot amazonka-config 0.3.1 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.3.1 (BrendanHay)
02:14:29 * hackagebot amazonka-datapipeline 0.3.1 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.3.1 (BrendanHay)
02:14:31 * hackagebot amazonka-directconnect 0.3.1 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.3.1 (BrendanHay)
02:14:33 * hackagebot amazonka-dynamodb 0.3.1 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.3.1 (BrendanHay)
02:14:35 * hackagebot amazonka-ec2 0.3.1 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.3.1 (BrendanHay)
02:15:01 <KaneTW> actually i haven't tracerouted www.haskell.org, gonna do that
02:15:59 <KaneTW> looks fine too
02:19:37 * hackagebot amazonka-ecs 0.3.1 - Amazon EC2 Container Service SDK.  http://hackage.haskell.org/package/amazonka-ecs-0.3.1 (BrendanHay)
02:19:39 * hackagebot amazonka-elasticache 0.3.1 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.3.1 (BrendanHay)
02:19:41 <ibid> KaneTW: is it going to the same IP as the timeouting HTTP request?
02:19:41 * hackagebot amazonka-elasticbeanstalk 0.3.1 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.3.1 (BrendanHay)
02:19:43 * hackagebot amazonka-elastictranscoder 0.3.1 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.3.1 (BrendanHay)
02:19:45 * hackagebot amazonka-elb 0.3.1 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.3.1 (BrendanHay)
02:21:08 <KaneTW> haskell.org goes to 23.253.242.70, then redirects to www.haskell.org goes to 108.162.204.60 both using tracert and wget
02:21:22 <KaneTW> which*
02:21:44 <KaneTW> sentence got a bit weird since i inline edited it, whoops
02:23:59 <ibid> ok
02:24:39 <ibid> possible there's a firewall rule that's considering you an attacker, perhaps.  maybe ask on the infra channel?
02:24:47 * hackagebot amazonka-emr 0.3.1 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.3.1 (BrendanHay)
02:24:49 * hackagebot amazonka-glacier 0.3.1 - Amazon Glacier SDK.  http://hackage.haskell.org/package/amazonka-glacier-0.3.1 (BrendanHay)
02:24:51 * hackagebot amazonka-iam 0.3.1 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.3.1 (BrendanHay)
02:24:53 * hackagebot amazonka-importexport 0.3.1 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.3.1 (BrendanHay)
02:24:55 * hackagebot amazonka-kinesis 0.3.1 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.3.1 (BrendanHay)
02:24:59 <KaneTW> okay
02:29:57 * hackagebot amazonka-kms 0.3.1 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.3.1 (BrendanHay)
02:29:59 * hackagebot amazonka-lambda 0.3.1 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.3.1 (BrendanHay)
02:30:01 * hackagebot amazonka-opsworks 0.3.1 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.3.1 (BrendanHay)
02:30:03 * hackagebot amazonka-rds 0.3.1 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.3.1 (BrendanHay)
02:30:05 * hackagebot amazonka-redshift 0.3.1 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.3.1 (BrendanHay)
02:31:38 <dulla> plssss
02:35:07 * hackagebot amazonka-route53 0.3.1 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.3.1 (BrendanHay)
02:35:09 * hackagebot amazonka-route53-domains 0.3.1 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.3.1 (BrendanHay)
02:35:11 * hackagebot amazonka-s3 0.3.1 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.3.1 (BrendanHay)
02:35:13 * hackagebot amazonka-sdb 0.3.1 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.3.1 (BrendanHay)
02:35:15 * hackagebot amazonka-ses 0.3.1 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.3.1 (BrendanHay)
02:40:17 * hackagebot amazonka-sns 0.3.1 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.3.1 (BrendanHay)
02:40:19 * hackagebot amazonka-sqs 0.3.1 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.3.1 (BrendanHay)
02:40:21 * hackagebot amazonka-ssm 0.3.1 - Amazon Simple Systems Management Service SDK.  http://hackage.haskell.org/package/amazonka-ssm-0.3.1 (BrendanHay)
02:40:23 * hackagebot amazonka-storagegateway 0.3.1 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.3.1 (BrendanHay)
02:40:25 * hackagebot amazonka-sts 0.3.1 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.3.1 (BrendanHay)
02:44:02 <tomjaguarpaw> Is there some extension that allows `type Foo = (*, *)` or similar?
02:44:17 <tomjaguarpaw> I want a synonym to a type level tuple
02:45:27 * hackagebot amazonka-support 0.3.1 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.3.1 (BrendanHay)
02:45:29 * hackagebot amazonka-swf 0.3.1 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.3.1 (BrendanHay)
02:45:31 * hackagebot postgresql-query 1.0.1 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  http://hackage.haskell.org/package/postgresql-query-1.0.1 (AlekseyUymanov)
02:45:33 * hackagebot postgresql-config 0.0.1 - Types for easy adding postgresql configuration to your program  http://hackage.haskell.org/package/postgresql-config-0.0.1 (AlekseyUymanov)
02:45:35 * hackagebot hunt-server 0.3.0.1 - A search and indexing engine server.  http://hackage.haskell.org/package/hunt-server-0.3.0.1 (alexbiehl)
02:49:10 <Zoetrope> tomjaguarpaw: As in "Foo a b = (a, b)" ?
02:49:24 <Zoetrope> type Foo that should be
02:49:56 <merijn> Zoetrope: That'd be a value level tuple
02:50:05 <merijn> He wanted a type level tuple
02:50:27 <exio4> I can only think of DataKinds' tuples, but I don't know how useful they are
02:50:31 <merijn> tomjaguarpaw: It hink that should just work, if you enable DataKinds plus maybe KindSignatures?
02:53:18 <fizruk> merijn: it yields  ‘T’ of kind ‘* -> *’ is not promotable
02:53:27 <merijn> Ah, bummer :\
03:03:05 <hexagoxel> :exf "Monad m => (a -> b -> m c) -> m a -> m b -> m c"
03:03:05 <exferenceBot> \ b c d -> c >>= (\ h -> d >>= b h)
03:03:05 <exferenceBot> \ b c d -> d >>= (\ h -> c >>= (\ l -> b l h))
03:03:12 <hexagoxel> jle`, ski: ^
03:04:56 <ski> :exf "Monad m => m (a -> m b) -> (m a -> m b)"
03:04:56 <exferenceBot> \ b c -> b >>= (>>=) c
03:06:06 <ski> :exf "Monad m => (forall o. (a -> m o) -> m o) -> m a"
03:06:06 <exferenceBot> could not parse input type: ParseFailed (SrcLoc "<unknown>.hs" 1 48) "ExplicitForAll or TypeOperators is not enabled"
03:06:21 <ski> hmpf
03:07:07 <ski> hexagoxel : cool
03:07:16 <hexagoxel> yep, rankn is still on the todo-list..
03:21:54 <mniip> can someone explain me why a Fold is a subclass of Getter and not the other way around
03:22:11 <EvanR> subtype*
03:23:39 <EvanR> id also like to know
03:24:45 <mniip> I bet merijn would like to know too :P
03:25:57 <thebnq> my stab at explaining would be that it adds the monoid constraint
03:27:04 <mniip> type Fold s a = forall f. (Contravariant f, Applicative f) => (a -> f a) -> s -> f s
03:27:04 <mniip> type Getter s a = forall f. (Contravariant f, Functor f) => (a -> f a) -> s -> f s
03:27:17 <mniip> I for one see no monoid constraints
03:27:37 <dramforever> whoa lens
03:27:45 <thebnq> well it does add the applicative constraint to be precise ..
03:27:52 <mniip> yeah
03:27:59 <mniip> but adding constraints means more specific right?
03:28:20 <thebnq> yea in a sense
03:28:30 <thebnq> but remember, "Every Getter is a valid Fold that simply doesn't use the Monoid it is passed."
03:28:34 <mniip> so Getter is more general than Fold
03:29:21 <thebnq> yea
03:29:53 <mniip> the lens chart states otherwise though
03:30:36 <thebnq> more general is further down
03:30:46 <mniip> more general is following the arrows
03:32:16 <thebnq> no more specific is following the arrows
03:32:22 <dramforever> wait a sec
03:32:33 <dramforever> every getter is a fold
03:32:33 <mniip> are we talking about the same chart
03:32:43 <EvanR> every fold is a getter?
03:32:46 <dramforever> means that getter is more *specific* than fold
03:32:56 <dramforever> "Every Getter is a valid Fold that simply doesn't use
03:32:56 <dramforever> 	 the Monoid it is passed."
03:33:19 <EvanR> that would explain a few things
03:33:22 <mniip> which monoid though
03:33:30 <EvanR> stuff at the top of the chart can be used anywhere stuff at the bottom can be used
03:33:46 <dramforever> getters ⊂ fold
03:33:58 <mniip> yeah
03:34:02 <mniip> that's what the chart says
03:34:21 <mniip> I can't figure out that relationship from the types of Fold and Getter
03:34:28 <mniip> in fact from the types I figure out the opposite
03:36:01 <mniip> a Getter uses only Functor functions to turn 'f a' into 'f s'
03:36:13 <mniip> a Fold uses Functor and Applicative functions to turn 'f a' into 'f s'
03:36:15 <dramforever> actually...I think that the lens package is not good, and data-lens is better
03:36:24 <thebnq> mniip: the Monoid is introduced in the individual combinators
03:36:28 <dramforever> the "costate comonad coalgebra" thing
03:36:37 <mniip> ohhh
03:36:41 <mniip> I think I see now
03:37:18 <mniip> A Getter uses only Functor functions to turn 'f a' into 'f s'. A Fold uses Functor and Applicative functions to turn 'f a' into 'f s'. Hence every Getter is a Fold
03:37:45 <mniip> forall has confusing semantics
03:38:00 <merijn> mniip: How so?
03:38:31 <dramforever> merijn: haskell has confusing semantics, so do lens
03:38:50 <EvanR> i cannot understand it correctly, therefore the language is confusing
03:38:53 <merijn> Haskell has really simple and well defined semantics
03:38:55 <mniip> merijn, it flips constraint relationships
03:39:02 <EvanR> its the languages fault
03:39:20 <merijn> mniip: No it doesn't? It changes who gets to pick the value of a type variable
03:39:29 <EvanR> i dont think it flips constraint relationships, its just that subtype relationships in oop are backwards
03:39:32 <dramforever> merijn: features like lazy evaluation are well defined but confusing
03:39:39 <EvanR> so people are surprised when it makes sense
03:39:54 <mniip> EvanR, every 'Functor f => f' is an 'Applicative f => f'
03:39:59 <merijn> dramforever: More confusing than the semantics of "f(a++, ++a);" in c
03:40:07 <merijn> ?
03:40:11 <EvanR> mniip: not every functor is an applicative
03:40:22 <mniip> oops
03:40:23 <mniip> backwards
03:40:37 <dramforever> merijn: 1. I didn't say that other languages are not confusing,
03:40:40 <mniip> EvanR, every 'Applicative f => f' is an 'Functor f => f'
03:40:57 <EvanR> i think its important to stand back and recognize that sometimes we as humans are confused, we are easily confused by things that might be really simple
03:41:00 <mniip> EvanR, now, every 'Functor f => f a -> f b' is an 'Applicative f => f a -> f b'
03:41:02 <mniip> see, backwards
03:41:03 <dramforever> 2. lazy evaluation is not something you can escape from easily, while ++i+i++ is
03:41:07 <EvanR> its not the the ideas are confusing in of themselves, to all people
03:41:14 <dramforever> yeah
03:41:16 <EvanR> we just have to get past your bio cruft
03:41:24 <dramforever> ye[
03:41:25 <dramforever> yep
03:41:39 <EvanR> s/your/our/
03:41:50 <mniip> hmm
03:41:56 <mniip> ah
03:42:06 <mniip> it's not forall that is contravariant-ish
03:42:11 <EvanR> mniip: thats not true either, the functor function, applicative function
03:42:13 <mniip> it's the (->)
03:42:42 <mniip> every applicative is a functor, every function operating on functors can operate on applicatives
03:43:21 <EvanR> the argument to a function is contravariant with respective to subtypes
03:43:35 <EvanR> but functors arent subtypes of applicatives
03:43:39 <dramforever> aww aww crap
03:43:54 <EvanR> they are a super typeclass
03:44:01 * dramforever keeps typing : instead of :: to mean type annotation
03:44:48 <mniip> applicatives are subtypes of functors
03:45:11 <EvanR> the applicative types are a subset of the functor types
03:45:13 <mniip> functions operating on functors are a subtype of functions operationg on applicatives
03:45:43 <merijn> mniip: Lemme give a more illustrative example
03:47:02 <merijn> mniip: Suppose we have "foo :: Functor f => f a -> (a -> b) -> f b" <- here the CALLER gets to pick the type for 'f', as long as you call foo with an 'f' that is a functor, it works
03:47:31 <mniip> I know how forall works
03:48:16 <mniip> hmm
03:48:27 <EvanR> then by all means dont listen to this explanation, i will
03:48:35 <mniip> ok sure
03:48:46 <mniip> an important thing to note is that (->) is covariant in the arguments and contravariant in the result
03:48:54 <EvanR> other way around
03:49:21 * hackagebot pocket-dns 0.1.1 - Multi-backend (zookeeper and sqlite) DNS Server using persistent-library  http://hackage.haskell.org/package/pocket-dns-0.1.1 (junjihashimoto)
03:50:04 <EvanR> if (a -> b) < (c -> d) then b < d, where < is the subtype relation
03:50:11 <EvanR> and c < a
03:50:44 <EvanR> but i dont think that applies here
03:51:12 <dramforever> Hi I have a question: What should I do if I want a (Data.Map.Map String a) but have the type indexed by the keys?
03:51:38 * mniip rereads the wikipedia page
03:51:44 <dramforever> like oneMap :: MapType ["key1", "key2"] Int
03:54:52 <EvanR> if the interface says give me a function Int -> Real, and you give it a function that is Unsigned -> Real, then things will break when a negative number shows up
03:55:08 <EvanR> but a Real -> Real will work because it can handle Ints as well as non Ints
03:55:18 <EvanR> thats why the argument type is contravariant
03:56:14 <mniip> well
03:56:21 <mniip> in the case of Getter/Fold
03:56:26 <EvanR> how relevant is this, i dont think very
03:57:16 <mniip> Fold turns 'f a' into 'f s' using only functor and applicative operations (as it doesn't know what f is)
03:57:32 <mniip> similarly, Getter turns 'f a' into 'f s' using only functor operations
03:57:38 <mniip> hence, any Getter is a Fold
04:01:00 <EvanR> yeah that makes sense now
04:01:45 <EvanR> and its not specific to function types
04:02:32 <EvanR> a place where an applicative is expected will admit any functor
04:02:53 <mniip> well it just hit me that Fold can create 'f s' out of 's' because 'f' is applicative
04:03:05 <mniip> but Getter cannot do that anyway so it doesn't change anything
04:03:31 <mniip> <EvanR> a place where an applicative is expected will admit any functor
04:03:33 <mniip> huh
04:03:56 <dramforever> that's the opposite...
04:04:01 <EvanR> uhg...
04:04:06 <dramforever> <*> won't accept a functor
04:04:09 <mniip> hehe
04:04:29 <EvanR> nevermind im confused again
04:05:30 <EvanR> the lens documentation, when read in isolation, IS confusing because its referencing a monoid without a monoid being present in any types
04:06:08 <EvanR> so its kind of engimatic there
04:06:30 <thebnq> it is, yea
04:06:47 <thebnq> but its like how lens is defined without telling you what functor to use :)
04:07:15 <mniip> maybe the 'r' in Getting is supposed to be a monoid?
04:07:20 <EvanR> at least Functor is in that type
04:07:21 <mniip> no constraints on it though
04:07:25 <mniip> oh right
04:07:28 <mniip> ohhhh
04:07:42 <EvanR> there are constraints on the various operations you can do on lens
04:08:08 <mniip> (^.) :: Monoid m => s -> Fold s m       -> m
04:08:23 <EvanR> so thats the summary operation
04:09:30 <EvanR> it makes sense that you can use a Getter there
04:09:50 <EvanR> its just foldMap
04:10:36 <mniip> If a function accepts a Getting r s a, then when r is a Monoid, then you can pass a Fold (or Traversal), otherwise you can only pass this a Getter or Lens.
04:13:39 <mniip> so all Getters are Folds
04:13:47 <mniip> but only Folds returnings Monoids are Getters
04:13:57 <mniip> too many esses
04:14:22 <EvanR> maybe tomorrow i will just fuckin learn lens
04:14:29 <EvanR> and get it over with
04:15:11 <EvanR> because what you just said sounds like random
04:15:12 <EvanR> lol
04:15:30 <mniip> heh
04:15:36 <mniip> I'm trying to learn lens too
04:15:41 <mniip> like
04:15:50 <mniip> I already more or less know how to use it
04:16:03 <mniip> now I'm trying to comprehend the implementation
04:16:37 <Cale> You know, a reasonable way to learn lens would just be to learn older versions of the package first
04:16:56 <Cale> Lens 1.0 is so much easier to follow :)
04:18:37 <hpc> perhaps someone can fork it as lens-simple
04:23:02 <dramforever> perhaps make something that's exactly as shown in the presentation?
04:23:13 <dramforever> the talk in new york
04:23:57 <Cale> hpc: I was thinking it would be interesting to have a lens-essential, that just has the major ideas, and tries to minimise the number of things which it provides without really giving up much in terms of expressivity
04:25:08 <dramforever> Question: consider a library of various string searching algorithms. It has a StringLike class.
04:25:44 <dramforever> and another custom string library like VeryFastString
04:26:03 <dramforever> it's possible to write instance StringLike VeryFastString, but where should I put it?
04:26:29 <dramforever> putting into either package creates a dependency on the other
04:26:41 <dramforever> putting into a new package makes it an orphan instance
04:28:18 <Cale> dramforever: That's like *the* problem :)
04:28:34 <dramforever> Cale: yeah *the* number two cabal problem
04:28:42 <Cale> dramforever: I think usually you just accept the dependency
04:29:47 <dramforever> Cale: I guess currently the widely accepted solution is to put it into the less popular one
04:30:18 <dramforever> like instance StringLike Data.Text.Text should be put into the same package as StringLike
04:33:09 <zipper> Yesod testing question http://stackoverflow.com/questions/28764807/performing-authentication-during-testing-browserid
04:37:15 <rui1> "Let" makes the type of stuff less general
04:37:34 <rui1> (*) is for Nums but "let m=(*)" is for Integers.
04:38:01 <rui1> Why is that, what's a keyword for that (so I can Google)
04:38:05 <EvanR> > let m=(*) in 1.3 * 3.1
04:38:07 <lambdabot>  4.03
04:38:31 <rui1> EvanR Hummm
04:38:58 <rui1> But in ghci if I do :t m I get Integer->Integer->Integer
04:39:16 <exio4> that's the monomorphism restriction
04:39:18 <mniip> let-in is different from ghci let
04:39:27 <exio4> rui1: which ghc version?
04:39:35 <rola> > let m = (*)
04:39:35 <rola> > :t m
04:39:36 <rola> m :: Num a => a -> a -> a
04:39:37 <lambdabot>  not an expression: ‘let m = (*)’
04:39:38 <lambdabot>  can't find file: L.hs
04:39:52 <EvanR> @let m = (*)
04:39:54 <lambdabot>  Defined.
04:39:54 <rola> that's on 7.8.3
04:39:58 <EvanR> :t m
04:39:58 <rui1> exio4 7.6.3
04:39:59 <lambdabot>     Ambiguous occurrence ‘m’
04:39:59 <lambdabot>     It could refer to either ‘L.m’,
04:39:59 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:163:1
04:40:05 <EvanR> uh oh
04:44:29 <EvanR> mniip: where did you get that type for ^. which had a Monoid constraint in it
04:45:54 <mniip> https://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Getter.html#v:-94-.
04:46:38 <EvanR> im already on that page
04:46:51 <EvanR> you mean in the haddock comment?
04:46:59 <EvanR> "you can think of the type like this"
04:50:34 <mniip> EvanR, that exact section
04:50:39 <mniip> about ^.
04:51:07 <EvanR> mniip: yeah the link didnt send me to any particular place on the page, but anyway, it doesnt explain where the Monoid is coming from
04:51:34 <mniip> below the declaration of ^. you see it being restricted to some types
04:51:47 <EvanR> yeah, "imagine this"
04:52:21 <EvanR> i guess its Monoid if you use it with a Monoid type
04:52:42 <EvanR> but the library has to use the monoid instance somewhere for it to matter
04:52:49 <EvanR> ill just trawl through the source
04:59:33 <poi_> category theory, it it is need to understand some library such as lens, comonad ... etc.
05:00:42 <tnks> poi_: do you really think so?
05:01:48 <tnks> there may be a pleasant depth of understanding with CT, but I think there's /some/ understanding to be had without CT.
05:02:48 <tnks> for instance, the interface for Profunctor isn't so crazy to understand.
05:02:53 <poi_> I ask because, such library very related the theory.  I don't familiar co-monad ,  adjoints, linear,,,  such like math word.
05:03:27 <tnks> yeah, the terms are that way.
05:04:22 <tnks> but ultimately, this is applied math.
05:04:46 <tnks> and you can get some intuition by following the types.
05:05:07 <Cale> poi_: Learning category theory just to understand how the ideas there have been squished down to fit into Haskell is a big sidetrack if all you want to do is write programs.
05:05:18 <Cale> poi_: If you're interested in mathematics, it might be fun
05:10:00 <poi_> when I look hakkage, because I want to find a easy way , those library are like mysteriusly atractive. I could not understand but seems those are compact and if I understand may be useful.
05:11:42 <idetuxs> Hi, I'm failing to understand something about data types and their constructs
05:12:13 <idetuxs> well, sort of
05:13:18 <idetuxs> having allready a data type, and a statement like foo = construct arg1 construct2 arg2 ..etc
05:13:45 <idetuxs> how can I extract from there some specific constructs so I could change their arg?
05:14:02 <idetuxs> I'm a mess, right? :P
05:15:00 <Cale> idetuxs: Perhaps you're looking to pattern match using case?
05:15:50 <idetuxs> well, yes, I tried as that is what I first thougt, but It didn't help me if I have several "construct1"
05:16:07 <Cale> Several in which sense?
05:16:34 <idetuxs> like "foo = construct1 arg1 construct1 arg2
05:16:40 <idetuxs> "
05:16:41 <Cale> You're allowed to match against more than one constructor in a single pattern
05:16:53 <Cale> Constructors will always start with an uppercase letter, by the way
05:17:04 <idetuxs> yes! my bad
05:17:10 <Cale> (which is how you can tell them apart from variables in a pattern match)
05:17:19 <idetuxs> how does it match against several?
05:17:39 <Cale> @let data Tree a = Tip | Branch a (Tree a) (Tree a)
05:17:40 <lambdabot>  .L.hs:166:25:
05:17:40 <lambdabot>      Ambiguous occurrence ‘Tree’
05:17:40 <lambdabot>      It could refer to either ‘L.Tree’, defined at .L.hs:165:1
05:17:46 <Cale> oh, already defined :P
05:17:54 <Cale> :t Tip
05:17:55 <lambdabot> Not in scope: data constructor ‘Tip’
05:17:57 <Cale> hm
05:18:08 <Cale> @let data BinTree a = Tip | Branch a (Tree a) (Tree a)
05:18:10 <lambdabot>  Defined.
05:18:10 <Cale> oops
05:18:14 <Cale> @undefine
05:18:14 <lambdabot> Undefined.
05:18:19 <Cale> @let data BinTree a = Tip | Branch a (BinTree a) (BinTree a)
05:18:21 <lambdabot>  Defined.
05:18:23 <Cale> there we go
05:18:34 <idetuxs> Oh, I remember looking to Tree data in the wiki I think
05:19:14 <Cale> > case Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip) of Branch x (Branch y t1 t2) t3 -> Branch y t3 (Branch x t1 t2)
05:19:16 <lambdabot>  No instance for (GHC.Show.Show (L.BinTree a0))
05:19:16 <lambdabot>    arising from a use of ‘M454142789749910521919113.show_M4541427897499105219...
05:19:16 <lambdabot>    arising from a use of ‘e_1123123312’
05:19:23 <Cale> tsk, forgot to derive show :)
05:19:40 <idetuxs> oh yes
05:19:41 <Cale> @let deriving instance Show a => Show (BinTree a)
05:19:42 <lambdabot>  Defined.
05:19:44 <Cale> > case Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip) of Branch x (Branch y t1 t2) t3 -> Branch y t3 (Branch x t1 t2)
05:19:46 <lambdabot>  Branch 2 (Branch 3 Tip Tip) (Branch 1 Tip Tip)
05:20:01 <Cale> of course, you probably want to match against more patterns than just one
05:20:34 <idetuxs> against probably infinit
05:20:52 <Cale> nah, just against enough patterns to cover all the possible cases
05:21:45 <idetuxs> ok, I'm going to try understand all this :P thanks very much Cale
05:22:11 <Cale> Every value of this BinTree a datatype that I defined is either of the form Tip, or it's Branch x l r where l and r are other values of type BinTree a
05:22:21 <Cale> and x is of type a
05:23:02 <Cale> So, because I matched a pattern which had the left subtree being a Branch there, I'd also probably want to cover the case where it was a Tip instead
05:23:18 <Cale> and I'd also need to cover the case where the entire tree was a Tip
05:24:05 <Cale> Of course, I supplied the value explicitly, so I knew ahead of time which pattern would match in that example, but in a real program, you'd probably get the tree from somewhere and wouldn't know for sure which pattern would match
05:32:32 <idetuxs> so in this case could the right tree also be branch?
05:32:50 <idetuxs> right subtree
05:41:15 <idetuxs> oh, Leaf and Branch functions like constructs for list
05:41:16 <idetuxs> s
05:41:19 <idetuxs> cool
05:43:08 <mauke\> @oeis 1,5,21,85,341,1365,5461,21845,87381,349525,1398101
05:43:09 <lambdabot>  (4^n - 1)/3.[0,1,5,21,85,341,1365,5461,21845,87381,349525,1398101,5592405,22...
05:54:31 <clrnd> huh, can't get lambdabot to join a specific channel
05:55:01 <remdezx> Hello! What a beautiful day we have today, havent we? :D I've got a small ugly question to you guys! :)  Is there a method that cancels Async task or gets information that is already finished? I'm lokking for something like Async a -> IO Bool which resultr True if task was already done
05:58:08 <clrnd> remdezx, like poll maybe?
05:58:20 <merijn> remdezx: cancel + waitCatch/poll ?
05:58:24 <clrnd> "to cancel" and "to get info" are separate things also
05:58:29 <merijn> cancel has no effect on finished tasks
05:59:45 <remdezx> poll and cancel is good, but what if task will end between poll and cancel?
06:00:29 <merijn> remdezx: cancel first, poll after?
06:00:53 <merijn> cancel is a no-op for finished tasks
06:01:10 <remdezx> merijn: oh, that's great idea. Don't know why I was thinking todo poll first!
06:01:21 <remdezx> Thanks!
06:10:08 <narendraj9> clrnd: Has anyone tried to deploy lambdabot on PaaS, e.g. heroku? I have been trying to do it. Because lambdabot cannot be made to join a channel.
06:10:18 <narendraj9> clrnd: I mean have you tried?
06:11:11 <clrnd> narendraj9, no, I just want it for my work server so I compiled in a vagrant VM
06:11:34 <clrnd> narendraj9, what do you mean by 'cannot be made to join'?
06:11:53 <clrnd> I mean, well I'm having that problem, but it must work for some people, since lambdabot is here
06:12:02 <clrnd> @botsnack
06:12:02 <lambdabot> :)
06:12:05 <narendraj9> clrnd: Can you please make it join a channel? :-D Our college's functional programming group.
06:12:25 <narendraj9> clrnd: Now, we are using hubot. With tryhaskell.org to evaluate expressions.
06:13:27 <narendraj9> clrnd: And I noticed that lambdabot is always present in #haskell-books and there is no one there.
06:13:56 <clrnd> narendraj9, what is that channel you want me to join?
06:14:47 <narendraj9> clrnd: #fp@nith. It would be great to have your lambdabot in our channgel. You are always welcome. :)
06:15:09 <narendraj9> clrnd: Right now, there isn't much happening in the channel though. But I expect more dicussions there.
06:15:52 <clrnd> narendraj9, if I can get it to join, let me try
06:21:38 <t4nk263> Hi
06:22:28 <rui1> Hello
06:22:35 <t4nk263> I'm following RWH tut until I reached the GUI programming chapter
06:23:02 <t4nk263> where I got the follwing error: PodMainGUI.hs:47:9:     No instance for (gtk-0.12.5.7:Graphics.UI.Gtk.Types.WidgetClass                        Window)       arising from a use of ‘xmlGetWidget’
06:23:37 <t4nk263> can any one help please?
06:27:12 <julianleviston> t4nk263: what’s the RWH tute?
06:27:25 <mauke\> tut tut
06:28:03 <julianleviston> mauke\: link?
06:28:42 <mauke\> google.com
06:29:04 <silver> @where rwh
06:29:04 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:29:30 <julianleviston> oh… haha RWH = real world haskell of course…
06:29:36 <julianleviston> soz. I should have known that.
06:31:49 <t4nk263> sorry julianleviston, it's real world haskell. I though it was obvious, sorry :)
06:32:02 <julianleviston> t4nk263: it should have been! my bad.
06:32:46 <mauke\> it's also the first five hits for "rwh haskell" on google
06:34:26 <rui1> what's google
06:34:40 <t4nk263> it's alright sir :)
06:35:12 <mauke\> rui1: bing it on altavista
06:35:21 <julianleviston> ask jeeves.
06:35:23 <zipper> Testing question here http://stackoverflow.com/questions/28764807/performing-authentication-during-testing-browserid
06:40:30 <Grisha> hi
06:40:51 <Grisha> what's the overhead of a where-clause in terms of the memory footprint?
06:41:11 <merijn> Grisha: Why would they have memory overhead?
06:41:29 <Grisha> merijn, that's exactly the nature of my Q ;-)
06:41:49 <merijn> The answer is: Yes, no, maybe, depends on what you're doing
06:41:55 <merijn> Was that helpful? :)
06:42:10 <mauke\> a where clause is a syntactic construct
06:42:16 <mauke\> memory footprint is a runtime thing
06:42:23 <merijn> ^^^
06:42:31 <Grisha> wait a sec, I'll post my code
06:42:48 <mauke\> what's the overhead of a while loop in terms of memory footprint?
06:43:01 <Grisha> http://lpaste.net/121288
06:43:13 <Grisha> ok, I'm creating a HMM-type variable
06:43:24 <Grisha> the fourth argument is a function
06:43:58 <Grisha> if I move it into something in the next where-clause, it somehow screws up its mapping on large lists
06:45:57 <Grisha> it seems to play a role whether I pass a lambda function to the constructor or a function name which I define below in the where clause
06:47:25 <merijn> Did you try profiling?
06:47:38 <Grisha> i'm not that advanced yet :-(
06:47:52 <Grisha> looks I have to re-install a lot of cabal packages with the profiling options for that
06:48:40 <merijn> It's kinda hard from this description to figure out what the problem is
06:50:11 <mauke\> my bet is on simple user error
06:50:11 <Grisha> I see
06:50:33 <Grisha> it shows up only on list of size of 1 mio
06:50:42 <Grisha> judging from running in ghic
06:50:44 <Grisha> ghci
06:51:52 <putis> hi
06:52:54 <Grisha> now
06:53:00 <Grisha> i've got my profiled libraries
06:53:57 <putis> when using Data.Map is there a better way to update key for specified value than delleting and inserting an updated pair?
06:54:45 <phaul> isn't that using the map backwards ?
06:55:04 <osfameron> insertWith and a const?
06:55:22 <phaul> why not swap keys become data and data become keys?
06:55:30 <osfameron> oh!  I see
06:55:54 <osfameron> that is an interesting use-case :D
06:55:57 <mniip> I wonder if there's a more efficient function for that than fromList . map swap . toList
07:03:53 <putis> I am using two maps, because I have to search keys, but values are searched too; I can't believe that haskell laziness is that efficient that it could be better to swap keys and values each time, is it?
07:04:14 <exio4> putis: you mean you need a Bimap?
07:05:02 <Cale> putis: I'm not sure what you mean
07:05:07 <osa1> so I'm calling killThread on some threads and I have a finally block wrapping those thread IO actions... that `finally` code is never run because threads somehow don't respond to async exception. any ideas why that might be happening?
07:05:19 <osa1> I guess I have something that 1) blocks 2) masks async exceptions, right?
07:06:09 <Cale> putis: But lazy evaluation isn't magic, it just means that expressions are evaluated outermost-first, and that any variable bound to an expression is evaluated at most once so long as it remains in scope.
07:06:19 <putis> exio4: oh, I haven't thought about such obvious solution; probably it is thing I was looking for
07:06:33 <Cale> A Bimap is the same thing as two maps
07:06:44 <Cale> But just packaged together nicely
07:09:22 <Yuras> osa1: other (unlikely) possibility: the thread is killed before entering the `finally`
07:09:48 <putis> Cale: yes, I know that, but after phaul message, idea of using one swapped several time map came to my mind; but bimap is a lot better in that case
07:10:17 <christiansen> hi folks, I'm terrible with Cabal. Trying to get Travis to test Idris with GHC 7.10, and the uniplate dependency won't install due to wanting an older version of base
07:10:31 <osa1> Yuras: !!! is this really possible?
07:10:39 <christiansen> it seems that it's got a flag separate_syb enabled, and that puts an upper bound on base
07:10:39 <clrnd> @tell narendraj9 I got it working :P
07:10:39 <lambdabot> Consider it noted.
07:11:01 <osa1> Yuras: btw, is my assumption about Haskell IO actions correct: an IO action either blocks or masks, but never does both because that may cause your program to hang forever
07:11:05 <Yuras> osa1: yes, you should use `forkFinally` instead of `finally`
07:11:06 <christiansen> does anyone here know how to disable that flag, or if i need to solve it in some other way?
07:11:36 <merijn> osa1: You can do both
07:12:06 <merijn> osa1: blocking within uninterruptibleMask works
07:12:13 <osa1> amazing
07:12:48 <anieuwland> Hi guys! I'm trying to upload a file with Yesod using the Cookbook recipe (https://github.com/yesodweb/yesod/wiki/Cookbook-file-upload-saving-files-to-server). Unfortunately compiling fails saying FilePath isn't a String / [Char], but hackage says it is... (http://lpaste.net/121289)
07:13:04 <mniip> where can I read about CPS?
07:13:12 <anieuwland> How do I make it accept FilePath / String / [Char]?
07:14:00 <Yuras> osa1: async exceptions are broken :)
07:14:49 <osa1> Yuras: forkFinally didn't help, which means my threads are blocking in masked state
07:14:56 <osa1> Yuras: they're not responding to the exception at all
07:15:14 <osa1> which is horrible. do you know if `network`'s socket operations mask?
07:16:15 <Yuras> osa1: I'm not sure what "mask" means here. socket operations can block, but they are interruptible
07:16:41 <narendraj9|afk> clrnd: You got it working on heroku?
07:16:42 <osa1> by mask I mean "suppressing async exceptions"
07:17:05 <clrnd> narendraj9|afk, no lol, on my server, I made it disconnect from #general THEN join what Iw anted
07:17:33 <narendraj9|afk> clrnd: Oh. Okay. And can it join multiple networks? :-D
07:17:40 <clrnd> narendraj9|afk, if management doesn't lent me a server for lambdabot I'm will have to try heroku
07:17:49 <clrnd> narendraj9|afk, let me try
07:17:49 <Yuras> osa1: then no, async exceptions are not suppressed by socket operations
07:18:19 <narendraj9> clrnd: Okay.
07:18:37 <Yuras> osa1: killThread should be able to interrupt all ops because the socket is configured as nonblocking
07:18:38 <clrnd> .join #fp@nith
07:18:56 <Yuras> osa1: not sure about Windows though
07:18:59 <clrnd> narendraj9, it can it seems
07:19:13 <narendraj9> clrnd: Nice. Great.
07:19:59 <osa1> Yuras: all I'm doing in my threads are socket operations and some vector read. I don't understand why they're not responding to async exceptions ...
07:20:24 <Yuras> osa1: then share the code
07:21:09 <Yuras> osa1: btw, are you sure than the `killThread` is actually called?
07:22:42 <Yuras> osa1: ah, I remember one more trap: a busy loop that doesn't allocate anything. it sometimes occurs with vectors
07:23:33 <Yuras> osa1: in that case the RTS doesn't get chance to throw the async exception
07:25:43 <Yuras> osa1: try `-fno-omit-yields` option: https://ghc.haskell.org/trac/ghc/ticket/367
07:27:17 <t4nk589> can anyone help with gtk2hs please?
07:29:46 <osa1> Yuras: I believe it hangs at Network.Socket.ByteString.recv
07:30:09 <osa1> Yuras: yeah I'm sure that killThread is really called. I hvae a print statement before and after and they work
07:31:31 <Yuras> osa1: oh, Network.Socket.ByteString is low level and unsafe
07:32:03 <zipper> What could be the issue when everyone in the mailing list seems to be ignoring your question?
07:32:20 <mauke\> http://en.wikipedia.org/wiki/Warnock%27s_dilemma
07:32:29 <osa1> Yuras: you mean it may mask and block at the same time?
07:32:59 <zipper> I hate it how all my questions in yesod web mailing list get ignored. I wish someone could tell me if I am unclear or asking the questions in the wrong way.
07:33:15 <Yuras> osa1: I'm reading the sources right now. it seems to call C functions directly
07:33:22 <osa1> Yuras: do you mean if FFI calls mask?
07:33:27 <osa1> do you think*
07:33:43 <osa1> do you know* I can't type and think today
07:33:53 <osa1> (collegue keeps me talking at the same time :p)
07:33:55 <Yuras> osa1: foreign import CALLCONV unsafe "recv"
07:33:55 <Yuras>   c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt
07:34:35 <Yuras> osa1: it uses unsafe ccall that blocks :)
07:34:39 <osa1> !!!!!!!!!!!
07:34:44 <Yuras> osa1: just don't use it
07:34:47 <osa1> !!!!
07:35:03 <osa1> Yuras: what happens if I replace that part with "safe"?
07:35:09 <osa1> Yuras: do I have any other alternatives?
07:35:59 <zipper> mauke\: I think I'm in situation 2-5 but I don't know where I lie exactly.
07:36:22 <Yuras> osa1: I don't think `safe` will change anything... you need to figure out whether the socket is configured as nonblocking
07:37:02 <Yuras> osa1: you can't interrupt FFI call
07:38:04 <Yuras> osa1: except the modern interruptible calling convention, but never used it
07:41:29 <Yuras> osa1: after inspecting the code: the socket here should be nonblocking, and the code actually handles it correctly
07:41:42 <Yuras> osa1: so it should be interruptible
07:42:59 <Yuras> osa1: it uses throwSocketErrorWaitRead to register the socket in event manager, so the `recv` call can't block. I was wrong here.
07:45:34 <benneh> I've constructed a cyclic linked list (as in this code example: https://wiki.haskell.org/Tying_the_Knot#Migrated_from_the_old_wiki); is there any way to make DList a functor in such a way that applying fmap to a cyclic linked list returns a list that's still genuinely cyclic?
07:46:14 <johnw> DList is a functor
07:46:20 <johnw> uh, no
07:46:22 <johnw> sorry
07:46:30 <johnw> one sec
07:47:18 <johnw> ah, ok, the problem is that a DList has the type variable in contravariant position
07:47:28 <johnw> you could make it a Functor if you're willing to flatten it out during the fmap though
07:47:34 <johnw> or, you could make it a functor using Yoneda
07:47:46 <johnw> (or rather, Coyoneda in this case)
07:48:13 <benneh> it has the type variable in contravariant position? how's that?
07:48:19 <johnw> DList is Endo ([a] -> [a])
07:48:27 <mauke\> johnw: no, it's not
07:48:34 <johnw> ugh
07:48:39 <mauke\> or rather, it is if you ignore the first sentence of the question
07:48:47 <mauke\> and the end
07:50:27 <mauke\> benneh: I can't think of a way
07:50:45 <mauke\> you can't really tell it's cyclic by looking at it
07:51:31 <mauke\> or rather, you can't tell where it starts to repeat
07:51:51 <mauke\> it might be a cycle of [1,2,3], or it might be 10000 copies of [1,2,3] and then something else
07:53:32 <benneh> true... but is there no way of saying "I know f applied to this node is the same as f applied to that node, because this node and that node are the same node"?
07:54:00 <mauke\> you can't observe sharing
08:01:01 <johnw> benneh: anyway, although I misunderstood the question as mauke\ pointed out, here is what I was thinking of: https://gist.github.com/c91597ebf50fb10ddb3b
08:01:38 <johnw> where Coyoneda is used simply to avoid "flattening" the DList at each fmap
08:02:38 <t4nk589> hi
08:04:39 <benneh> johnw: I think I'm missing something; what's this got to do with doubly linked lists?
08:04:41 <johnw> but of course that doesn't help with cyclic structures
08:04:53 <johnw> it doesn't, you said DList and that sent my brain off the rails
08:05:05 <benneh> oh, right :P
08:05:21 <johnw> I thought you meant *difference* list, not *double-linked* list :)
08:05:46 <johnw> which the whole knot-tying thing should have made obvious, but it's very early here for me...
08:06:26 <benneh> DLList would have been a more sensible name, really
08:06:37 <johnw> or DblList...
08:07:08 <johnw> {- Named such so that early-morning people get the right idea -}
08:13:01 <saep> A list of Doubles? :p
08:16:45 <wcaleb> i'm trying to "cabal build" the latest pandoc source within a sandbox; it tells me a dependency (filemanip) is missing, even though cabal info filemanip shows the required version is installed in the sandbox. thoughts?
08:25:20 <mpickering> wcaleb: what commands are you running?
08:25:53 <wcaleb> mpickering: first cabal install --only-dependencies and then cabal build
08:26:23 <wcaleb> mpickering: trying to build 1.13.3
08:26:39 <mpickering> you might need a "cabal configure" in there
08:31:27 <bobfang> hi just wondering if there is any good tutorial on GADT?
08:32:04 <wedens>  can somebody help me with neco-ghc vim plugin? i don't have completion for functions defined in the same file
08:32:41 <c_wraith> bobfang: there's the same tutorial everyone uses, where you use GADTs to build a typed AST
08:32:44 <sritchie> hey all - qq on emacs + haskell
08:32:57 <sritchie> I’ve got cabal-repl all set up, but every couple of times I load a file the repl gets jammed
08:33:03 <bobfang> where can I find it?
08:33:05 <bobfang> thanks :)
08:33:06 <sritchie> won’t let me type or anything
08:33:07 <c_wraith> bobfang: by which I mean there must be about 10 tutorials that cover that.
08:33:19 <bobfang> cool thanks :)
08:33:33 <sritchie> The only way to restart the repl seems to be to kill the thing
08:33:37 <c_wraith> bobfang: https://en.wikibooks.org/wiki/Haskell/GADT is one of the millions
08:33:41 <sritchie> which asks me if I want to take out associated buffers
08:34:56 <xnull_> hiptobecubic: i like your nick
08:35:13 <ParmesanCaesar> q.q
08:36:02 <wcaleb> mpickering: thanks; i'm also running into problems with install texmath-0.8.0.1 (now a dependency); the compiler crashes on Text.TeXMath.Unicode.ToTeX
08:36:07 <sritchie> anyone seen this repl issue?
08:36:13 <sritchie> where the emacs repl won’t take any input?
08:36:38 <mpickering> what is the error wcaleb?
08:37:18 <wcaleb> it just never finishes compiling; have to use keyboard interrupt; maybe i just need to wait longer?
08:38:38 <mpickering> wcaleb: ah yes... you just need to wait longer
08:38:50 <mpickering> if you have a peak at the source, there's some not very nice things
08:49:46 <KaneTW> isn't the haskell compiler guaranteed to terminate?
08:51:23 <bergmark> KaneTW: there are extensions such as UndecidableInstances that may make it loop
08:52:00 <KaneTW> i thought even then it had a max stack depth
08:52:10 <KaneTW> " Implementations ensure termination by making context reduction fail if it exceeds some depth limit."
08:52:19 <bergmark> hmm ok you are probably correct
08:52:38 <EvanR> everything is guaranteed to terminate in the sense that the computer will break down at some point, or youll get tired and hit control C
08:52:44 <EvanR> or it hits maximum stack depth
08:53:14 <EvanR> but all of those are usually not as nice as some more natural termination condition
08:54:03 <EvanR> unless the natural termination condition means "terminates in exponential time" or something inconvenient
08:55:02 <Cale> It should terminate if you don't have certain extensions turned on, but yeah, in the worst case it may take time which is multiply exponential in the length of your program.
08:55:16 <Cale> So, termination is a bit of a funny guarantee :)
08:56:53 <EvanR> when does Cale sleep?
08:56:57 <Cale> try asking ghci for the type of let f x = (x,x); f1 x = f (f (f x)); f2 x = f1 (f1 (f1 x)); f3 x = f2 (f2 (f2 x)) in f3
08:57:26 <Cale> EvanR: approximately whenever
08:59:37 <KaneTW> zsh: killed     ghci
08:59:43 <exio4> Cale: that let is evil
08:59:46 <KaneTW> termination ensured, indeed
09:01:37 <Cale> If you've ever wanted to fill up your computer's memory with just types, that sort of thing is a good way to do it :)
09:02:18 <wcaleb> mpickering: wow, you weren't kidding; it finally finished about 20 minutes later
09:03:01 <KaneTW> that's what, 2^19682 tuples?
09:03:22 <mpickering> wcaleb: What is your system out of interest?
09:04:01 <wcaleb> mpickering: embarrassingly old Mac OS (Lion)
09:05:38 <mpickering> I admit it was me who did that.. I was doing it on an old Asus EEE pc though so I reasoned that surely not many people would have less powerful machines than that
09:05:48 <mpickering> but there certainly should be something better.
09:07:32 * geekosaur is using one of those as a small server >.>
09:17:50 <Big_G> Doesn't Haskell have tail call optimization?
09:18:47 <geekosaur> in one sense all calls are tail calls. in another sense it's not meaningful at all
09:19:25 <josephle> if you're referring to the traditional optimization of saving stack space when making tail calls
09:19:44 <josephle> this is not a meaningful optimization in ghc iirc
09:19:49 <Big_G> josephle, Then can you explain why my fibboncci function had a stack overflow?
09:19:59 <geekosaur> pattern stack, not execution stack
09:20:13 <FofG> Is there no function in base for like isLeft :: Either a b -> Bool ?
09:20:23 <geekosaur> it means your code is too lazy and built up too many unevaluated expressions
09:20:25 <Big_G> geekosaur, What is the difference?
09:20:49 <xnull_> FofG: you mean
09:21:00 <mpickering> FofG: no
09:21:00 <xnull_> isLeft :: Either -> a -> Bool
09:21:11 <xnull_> or rather
09:21:35 <FofG> isLeft :: (Either a b) -> Bool ?
09:21:51 <xnull_> isLeft :: Eq l => Either l r -> l -> Bool
09:22:03 <FofG> no
09:22:14 <FofG> i just wanna know is the either a left or a right
09:22:22 <geekosaur> xnull_, you don't need Eq
09:22:26 <FofG> don't care about the value
09:22:28 <xnull_> what do you mean by is it a left or a right
09:22:37 <xnull_> ohhhh
09:22:40 <mpickering> FofG: There is no function in prelude which does that
09:22:41 <xnull_> never mind, sorry
09:22:55 <xnull_> isLeft (Left _) = True
09:23:01 <xnull_> isLeft (Right _) = False
09:23:32 <FofG> right
09:23:34 <Big_G> geekosaur, I think I understand the difference but that difference seems minimal at best. Most of the recursive functions I can think of don't evaluate untill the execution stack resolves to that point
09:23:35 <xnull_> left
09:23:36 <geekosaur> Big_G: non-strict evaluation works nothing like what you are used to, which is why tail calls are not relevant. any function immediately returns an unevaluated lazy expression, so there is no execution stack to speak of.
09:23:40 <FofG> i know its trivial, just wondering if it was in there already
09:23:57 <geekosaur> that unevaluated expression goes onto a pattern stack which is reduced when something requires a value
09:23:59 <xnull_> FofG: where are you wanting to use this? i think a case expression would be best for most situations
09:24:19 <geekosaur> which may happen at a different point in the program, and if your code is too lazy may not happen until you do I/O with it
09:24:21 <Big_G> geekosaur, So is there a way I can get around the stack overflow?
09:24:21 <FofG> i have some doctests right now for parsers
09:24:31 <FofG> right now im testing the exact output of the parser
09:24:40 <FofG> but i now want to just test whether its a failure
09:24:42 <geekosaur> I'd have to see what your code looks like to suggest places where you can add strictness
09:24:59 <FofG> perhaps parsec has a built in isErrorResult or something like that?
09:25:26 <Big_G> geekosaur, Just something from a tutorial. fac n = if n == 0 then 1 else n * fac (n-1)
09:25:31 <FofG> so i wanted to just be like >> isFailure parse parser input - True
09:25:33 <FofG> that kind thing
09:26:19 <geekosaur> FofG, in general we just use pattern matching rather than e.g. isLeft. there are exceptions to that, but they're not recommended (in fact there's a discussion on the libraries list about deprecating isJust along wth its cousin fromJust)
09:26:32 <FofG> right
09:26:34 <FofG> makes sense
09:26:39 <FofG> its a strange thing to have i a gree
09:26:46 <FofG> on sum types you should just be matching
09:26:53 <FofG> instead of creating endless functions
09:27:10 <xnull_> i can see where isLeft might be useful
09:28:14 <xnull_> it can be used much more concisely, so if he's using it a ton in the midst of a lot of over logic (composite operations) it could be useful for composition
09:28:24 <xnull_> other logic*
09:30:00 <Big_G> How does Haskell deal with integer overflow?
09:30:20 <Big_G> > [0,100..]!!43432784236423423
09:30:24 <lambdabot>  mueval-core: Time limit exceeded
09:30:27 <EvanR> > (maxBound :: Int) + 1
09:30:28 <lambdabot>  -9223372036854775808
09:30:46 <Big_G> So it just auto wraps around? Is there an easy way to prevent that?
09:30:54 <EvanR> > maxBound :: Integer
09:30:55 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
09:30:55 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
09:30:55 <saep> Big_G: Use Integer
09:30:57 <saep> :p
09:31:12 <EvanR> > 9223372036854775807 + 1
09:31:13 <lambdabot>  9223372036854775808
09:31:36 <Big_G> In the example I gave, how would I use Integer
09:31:42 <EvanR> it defaults to Integer
09:32:02 <Big_G> Then why did I get a negative index error
09:32:15 <EvanR> oh, !! uses Int
09:32:15 <saep> @type (!!)
09:32:16 <lambdabot> [a] -> Int -> a
09:32:37 <Big_G> EvanR, Can I tell it to use Integer?
09:32:39 <EvanR> :t genericIndex
09:32:40 <lambdabot> Integral i => [a] -> i -> a
09:33:09 <EvanR> your computation will never complete though, just because of the size of the index
09:33:10 <scopedTV> Does Haskell have dependent types yet?
09:33:28 <Big_G> EvanR, That's fine. I just want to learn
09:33:44 <Big_G> It says Integral isn't in scop
09:34:59 <saep> > genericIndex [1,100,..] 8127398127391837198376478312462384324
09:35:00 <lambdabot>  <hint>:1:21: parse error on input ‘..’
09:35:32 <geekosaur> Integral is not Integer, and Integral is not a type
09:35:42 <Big_G> How would I use it then?
09:36:06 <geekosaur> use a type that has an Integral instance
09:36:17 <geekosaur> @instances Integral
09:36:18 <lambdabot> Int, Integer
09:36:23 <EvanR> wow so many
09:36:33 <geekosaur> (that's withut any imported modules)
09:37:01 <geekosaur> @instances-importing Foreign.C.Types Data.Time Integral
09:37:02 <lambdabot> CChar, CInt, CIntMax, CIntPtr, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort, CWchar, Int, Integer
09:37:07 <Big_G> What would I type int the example I gave
09:37:47 <geekosaur> I think I got one of those imports wrong
09:38:09 <geekosaur> (also it took me far too long to fix that last before sending it, perhaps I should not be trying to type today...)
09:38:21 <Clint> @instances-importing Data.Word Integral
09:38:21 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
09:38:36 <geekosaur> as EvanR said, it defaults to Integer if you don't specify
09:39:34 <geekosaur> if you do something that causes it to infer Int (e.g. call length) then you'd need to use fromInteger (or, ironically, fromIntegral) to "escape" the Int constraint
09:39:50 <putis> \help
09:40:00 <geekosaur> :t genericIndex [1,100..] 812739812739183719837647831246238
09:40:01 <lambdabot> (Num a, Enum a) => a
09:40:17 <geekosaur> it will infer Integer for that
09:40:52 <Big_G> Thanks all. I got that working
09:41:17 <Big_G> Need to take of for class. have a great day
09:42:33 <EvanR> > 2^62 * 3 * 5009 * 104789 * 111919
09:42:34 <lambdabot>  812739812739183681713505596080128
09:42:45 <Welkin> > Infinity * Infinity
09:42:46 <lambdabot>  Not in scope: data constructor ‘Infinity’Not in scope: data constructor ‘Inf...
09:42:57 <Welkin> > (1/0 * (1/0)
09:42:58 <lambdabot>  <hint>:1:13:
09:42:58 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:43:00 <Welkin> > (1/0) * (1/0)
09:43:02 <lambdabot>  Infinity
09:43:06 <EvanR> what this random prime factorization calculator is off
09:43:33 <EvanR> must be based on doubles
09:44:02 <cite-reader> In what universe does /prime factorization/ make sense to do in floating point?
09:44:10 <EvanR> javascript universe
09:44:14 <kadoban> javascript? Yeah, heh.
09:44:20 <cite-reader> Oh, yeah that would do it.
09:47:24 <aidecoe> i have some expression in a normal function which is called from recursive function:
09:47:27 <aidecoe>  (zipWith (++) branchLeft branchRight) ++ trace ("trunk'=" ++ show trunk) trunk ++ ["@@@dupa@@@"]
09:47:39 <aidecoe> and
09:47:59 <aidecoe> at first time the expression is evaluated fully
09:48:27 <aidecoe> in next recursion level 'trunk' is not appended
09:48:39 <aidecoe> how's that possible?
09:49:34 <aidecoe> 'trace' displays 'trunk' list, but it's not appended
09:50:30 <aidecoe> this is a huge WTF for me. Does such strange things happen?
09:50:32 <HeladoDeBrownie> aidecoe, maybe if you could show a complete working example? nothing obvious occurs to me just from that snippet
09:50:49 <HeladoDeBrownie> aidecoe, whenever something strange is happening, it's most likely a problem in your understanding
09:50:56 <aidecoe> HeladoDeBrownie: i can give a whole code, but it's not really eyes friendly (-:
09:51:04 <aidecoe> HeladoDeBrownie: probably (-:
09:51:36 <aidecoe> HeladoDeBrownie: http://wklej.org/hash/b784d147d53/
09:51:55 <aidecoe> HeladoDeBrownie: this is in drawTree function
09:52:20 <aidecoe> HeladoDeBrownie: if you call drawTreeFractal with n>=3 then strange things happen
09:52:23 <aidecoe> for n=2 it's ok
09:53:08 <aidecoe> but drawTree does not depend on 'n' in any way
09:53:09 <HeladoDeBrownie> so, you're using drawTree, but its output is unexpected. what input are you using (for both params)?
09:54:16 <aidecoe> w8 a moment, maybe i'll clean up that code back to be something more readable and usable (-:
09:54:39 <HeladoDeBrownie> okay, that might help anyway :)
09:57:41 <zaphix__> Can someone familiar with building reactive webapps w/ Haste suggest the latest state of the art project/packges for doing so? There's hplayground, shade, react-haskell, and so on, but I'm not sure if I've missed any and I'm not sure which (if any) are considered the most mature.
09:59:37 <aidecoe> HeladoDeBrownie: http://wklej.org/hash/2fbfea56718/ - if you load this into ghci and call "dtf 2 16" then it works fine - 3 trees (or Ys) are displayed
10:00:08 <aidecoe> HeladoDeBrownie: but for "dtf 3 16" trunk of the tree is cut off
10:01:49 <aidecoe> HeladoDeBrownie: it looks that spooky things happend at line 49
10:02:16 <aidecoe> somehow 'trunk' is not appended to zipped branches
10:03:05 <HeladoDeBrownie> aidecoe, are you sure you're not confusing the printing of the output of the function with the trace output?
10:03:20 <HeladoDeBrownie> aidecoe, or, is it still misbehaving without the trace?
10:03:32 <aidecoe> HeladoDeBrownie: it's still misbehaving
10:03:53 <HeladoDeBrownie> okay, one moment while i fiddle with this
10:04:01 <aidecoe> HeladoDeBrownie: well it was misbehaving in the first place, so i've just learnt that trace thing (-:
10:04:59 <HeladoDeBrownie> oh, okay.
10:05:21 <HeladoDeBrownie> aidecoe, so, can you give an erroneous output and the input that led to it?
10:05:36 <HeladoDeBrownie> (preferably without the trace output interspersed)
10:06:16 <aidecoe> HeladoDeBrownie: http://wklej.org/hash/cbc94ee7679/
10:06:38 <HeladoDeBrownie> okay, what was expected instead?
10:07:02 <aidecoe> HeladoDeBrownie: dtf 2 16 is ok, dtf 3 16 is incorrect
10:07:21 <HeladoDeBrownie> sure, but i don't know what's incorrect about it
10:08:15 <aidecoe> HeladoDeBrownie: dtf 3 16 should look like this: http://wklej.org/hash/7887ea0808d/
10:08:34 <aidecoe> HeladoDeBrownie: missing vertical lines in 10-13
10:08:39 <HeladoDeBrownie> ah, i see
10:08:55 <aidecoe> i call this 'trunk' in the code
10:09:12 <HeladoDeBrownie> and you checked to see that trunk was what you expected?
10:09:33 <aidecoe> HeladoDeBrownie: what do you mean that i checked?
10:09:41 <HeladoDeBrownie> with trace
10:09:46 <aidecoe> HeladoDeBrownie: yes
10:10:47 <aidecoe> HeladoDeBrownie: trace displays exactly what should be appended but it's not appended
10:11:15 <HeladoDeBrownie> hmm, i notice that the higher up in number you go the more trunks are missing
10:11:33 <HeladoDeBrownie> this sounds like *something* isn't being used where it ought to be in one of the recursive definitions
10:12:23 <HeladoDeBrownie> in the first argument, i mean
10:13:13 <lpaste> dr_diagoras pasted “obvious function” at http://lpaste.net/121293
10:13:27 <aidecoe> HeladoDeBrownie: yes
10:13:38 <dr_diagoras> can anyone help me on pasted?
10:17:20 <HeladoDeBrownie> aidecoe, i'm a bit stumped as well. my best guess is that trunk must be empty there, but the trace seems to show otherwise.
10:17:26 <dukerutledge> Is anyone aware of the haskell cafe email verification process? Is it done manually?
10:18:22 <HeladoDeBrownie> aidecoe, try this: verify that every single definition used by dtf works as expected, on its own.
10:18:49 <ChristianS> dukerutledge: probably its automatic, you get a confirmation email and then click on the link
10:19:23 <HeladoDeBrownie> aidecoe, when it makes sense, pull out more parts into their own separate definitions so you can easily test those as well.
10:19:42 <dukerutledge> :( I haven't gotten anything after half a day.
10:20:11 <ChristianS> dukerutledge: maybe you mistyped your email address?
10:20:20 <dukerutledge> hmm, I'll give it another try.
10:20:36 <dukerutledge> Does anyone know who at galois oversees that mailing list?
10:20:52 <aidecoe> HeladoDeBrownie: ok, i'll try, although i have already tested some already
10:22:15 <HeladoDeBrownie> aidecoe, i just noticed something: only the biggest trunk is affected by that snippet. is there somewhere else you draw trunks?
10:22:42 <HeladoDeBrownie> aidecoe, here is what i did: throw more (++ trace)'s on there, compare the old output to the new, notice that only the biggest trunk has been affected.
10:22:58 <HeladoDeBrownie> err
10:23:00 <HeladoDeBrownie> (++ trunk)
10:23:01 <dukerutledge> ChristianS I must have fat fingered. Thanks.
10:23:32 <aidecoe> HeladoDeBrownie: affected by?
10:24:02 <bitonic> edwardk: hey, I'd like to do this with trifecta: fail providing a `Span' to indicate where the error is, and without outputting any "expecting XXX" message
10:24:19 <HeladoDeBrownie> aidecoe, changing the expression on line 49 to zipWith (++) branchLeft branchRight ++ trunk ++ trunk ++ trunk *only* causes the bottommost trunk to become longer. this says to me you're drawing trunks elsewhere and *that's* where the problem is.
10:24:28 <bitonic> edwardk: possibly I'd like to provide a `Doc' directly.  am I missing some function in parsers/trifecta?
10:25:30 <aidecoe> HeladoDeBrownie: i tried that,too. Try to add something before the zipWith, like ["fdfads"] ++ zipWith...
10:26:25 <HeladoDeBrownie> aidecoe, could the conclusion i'm drawing from that be true? what are all the other parts where you're drawing a vertical line of 1's?
10:26:42 <HeladoDeBrownie> aidecoe, something is not recursive where it ought to be, i'm thinking
10:29:48 <aidecoe> HeladoDeBrownie: i am only drawing vertical line for trunk
10:30:57 <tim0> Hi all!   I'm using cabal 1.22.0.0 and ghcformacosx (ghc 7.8.4)  and I can't seem to install anything with 'cabal install'.  I create a sandbox and run 'cabal install hashable' and my build.log file says that the install outcome was ConfigureFailed.  Are there any known workarounds?
10:33:04 <toblerone> anyone think they can point out to me why this doesn't type check? : ) Or alternatively point to a better way of handling this? http://lpaste.net/8524511799016423424
10:33:31 <tim0> I have been able to download libraries from hackage and 'runhaskell Setup.hs {configure,build,install} them
10:33:45 <toblerone> I'm trying to make a function to parse an arbitrarily nested json field, ignoring the other data
10:35:50 <toblerone> o
10:36:08 <toblerone> it appears that i needed to add a "FromJSON" constraint to the type on line 31
10:37:35 <toblerone> hmm, maybe not
10:37:40 <toblerone> still doesnt work
10:37:54 <toblerone> I thought the ScopedTypeVariables extension would handle this..
10:44:07 <geekosaur> toblerone, you do know that ScopedTypeVariables by itself is not enough? you need to declare the type variables to have extended scope, using forall
10:44:19 <ChristianS> i want to "memoize" a function in the IO monad, so that it's never executed when never called, and exactly once when called once or more. how do i do that?
10:45:11 <toblerone> geekosaur: actually I just figured out my problem was that I used a variable in the incorrect place : )
10:45:17 <toblerone> But no, I didn't know that
10:45:38 <bergmark> ChristianS: how about Either (IO a) a
10:46:05 <toblerone> tim0: So all cabal install attempts fail?
10:47:40 <tim0> toblerone: Thanks.  Every one I've tried so far.
10:48:51 <toblerone> any more information on the error? I'm no cabal expert, but that seems pretty frustrating...
10:49:01 <toblerone> it just says ConfigureFailed?
10:49:34 <bergmark> install with -v3 to get more info
10:49:39 <lpaste> tim0 pasted “Example error” at http://lpaste.net/121295
10:50:08 <ChristianS> bergmark: i'll check it out, thanks
10:50:12 <tim0> toblerone: that's an excerpt from my build.log file
10:50:51 <tim0> the cabal command output ends with: This may be due to an out-of-memory condition.
10:51:11 <toblerone> you should try bergmark's suggestion
10:51:32 <tim0> will do.  THanks bergmark and toblerone!
10:53:26 <hexagoxel> tim0: try the `-j1` flag to reduce build parallelism (and thus, memory usage). just a guess, though.
11:00:45 <lpaste> tim0 pasted “verbose cabal output” at http://lpaste.net/121296
11:02:20 <tim0> hexagoxel: with -j1 I was able to install hashable....  now trying purescript.  Thank you very much!
11:03:59 <xnull> Where can I acquire wx_gtk2u_webview-3.0 on Arch Linux (x86_64)? I am trying to get `wx' to build with cabal install.
11:05:23 <xnull> I get the following message: http://lpaste.net/121298
11:11:57 <dhinojosa> > (+1) == (+1)
11:11:58 <lambdabot>  No instance for (GHC.Num.Num a0) arising from a use of ‘GHC.Num.+’
11:11:58 <lambdabot>  The type variable ‘a0’ is ambiguous
11:11:58 <lambdabot>  Note: there are several potential instances:
11:12:11 <dhinojosa> Can you test the equality of functions?
11:12:29 <geekosaur> not in general, no
11:14:00 <geekosaur> the universe package provides some limited support for it, but in general you can't determine equality of functions
11:14:02 <xnull> you can't? i would think you could do
11:14:28 <geekosaur> > take 3 [1..]
11:14:29 <lambdabot>  [1,2,3]
11:14:40 <xnull> instance Eq (a -> b) where (==) x y = blah blah blah
11:14:53 <geekosaur> > take 3 ([1..] ++ [0,-1,..])
11:14:55 <lambdabot>  <hint>:1:24: parse error on input ‘..’
11:14:58 <geekosaur> whoops
11:15:01 <geekosaur> > take 3 ([1..] ++ [0,-1..])
11:15:02 <lambdabot>  [1,2,3]
11:15:07 <geekosaur> are those equal?
11:16:11 <dhinojosa> geekasaur: I think you are testing the results of the functions, and not the functions themselves.
11:16:32 <dhinojosa> > (*2) == (*2)
11:16:34 <lambdabot>  No instance for (GHC.Num.Num a0) arising from a use of ‘GHC.Num.*’
11:16:34 <lambdabot>  The type variable ‘a0’ is ambiguous
11:16:34 <lambdabot>  Note: there are several potential instances:
11:16:46 <geekosaur> dhinojosa, there's a sting in the tail. those two are actually equal in all cases because the second list can never be reached.
11:17:06 <dhinojosa> geekosaur ok
11:20:20 <geekosaur> several points: (1) you cannot in Haskell prove equality of a function *except* by comparing results; (2) you can't prove that some change makes no difference (the second list in that example, which will never be seen because the first is infinite); (3) you can't, for example, prove that a lambda that has the same code as a top level function is in fact "the same" function
11:23:50 <geekosaur> also details like, are you thinking it will compare the addresses of functions? (not reliable in the case of e.g. lambdas) are you thinking it compares the AST? (not available at runtime, and if the function was a parameter from a call in a different module then you usually can't do it at compile time)
11:24:22 <geekosaur> also the halting problem rears its head in the general case...
11:27:13 <chrisdone_osx> i suppose you could make a derivable Data-like reflection class that the compiler would provide for reflecting the AST of functions
11:28:47 <geekosaur> there's also weird corners like, they may be the same or different depending on some typeclass instance imported by a completely unrelated module (since that's global in effect)
11:29:01 <geekosaur> (...I think that can come up, at least)
11:30:04 <dhinojosa> I was thinking AST
11:30:16 <dhinojosa> so you answered that question, thanks
11:47:51 <phaazon> hey, we don’t have a binding to fmod yet?!
11:49:27 <dhinojosa> question: Why is it when I try to use function applicatives it says cannot construct infinite type?
11:49:37 <dhinojosa> > (+1) <*> (*10)
11:49:38 <lambdabot>  Occurs check: cannot construct the infinite type: a ~ a -> b
11:49:38 <lambdabot>  Expected type: (a -> b) -> a
11:49:38 <lambdabot>    Actual type: (a -> b) -> a -> b
11:50:00 <dhinojosa> seems that haskell should at least let me assign it, so I can do something about it later
11:50:27 <dhinojosa> (+) <$> (+1) <*> (*10)
11:50:32 <dhinojosa> > (+) <$> (+1) <*> (*10)
11:50:34 <lambdabot>  <Integer -> Integer>
11:50:37 <igniting> Data.ByteString.Lazy.hGetContents closes the handle if EOF is encountered. I don't want to close the handle as I'm reusing it later. Is there a way?
11:50:52 <dhinojosa> > (+) <$> (+1) <*> (*10) $ 5
11:50:53 <mauke> > (+) <*> (*10)
11:50:53 <lambdabot>  56
11:50:54 <geekosaur> don't use hGetContents?
11:50:54 <lambdabot>  <Integer -> Integer>
11:51:20 <mauke> dhinojosa: (+) <*> (*10) works fine. (+1) <*> (*10) is a type error
11:51:25 <geekosaur> actually the handle is "closed" immediately, because you have explicitly transfered control of it to hGetContents
11:52:31 <igniting> geekosaur: what alternative do I have if I want to read content from a handle, without closing it?
11:52:50 <igniting> I want to keep it open as I'm doing multiple reads
11:53:19 <geekosaur> hGet
11:53:46 <geekosaur> if you're using hGetContents then you are doing lazy I/O and you *cannot* reuse the handle afterward
11:54:15 <dmj`> why doesn't haskell allow you partially apply type synonyms
11:54:38 <ReinH> dmj`: to annoy me, I believe.
11:55:15 <mauke> dmj`: that would lead to full-blown type level lambda
11:55:43 <geekosaur> http://programmers.stackexchange.com/questions/177967/why-doesnt-haskell-have-type-level-lambda-abstractions
11:56:13 <pdefql> is a function 'foo :: (a -> t b) -> a -> t b' valid? Would 't' signify a type that has kind '* -> *' and takes one type parameter?
11:56:37 <igniting> geekosaur: I have to actually use Data.Binary.Get to parse the content and suppose I don't know how many bytes would be required in the parse
11:56:45 <mauke> pdefql: yes
11:56:58 <mauke> :t id :: (a -> t b) -> a -> t b
11:56:58 <lambdabot> (a -> t b) -> a -> t b
11:57:07 <pdefql> ah cool
11:57:26 <pdefql> didnt know you could use a placeholder for a partial type
11:57:39 <igniting> I was currently using runGetLazy
11:58:26 <EvanR> igniting: theres a library, attoparsec-iteratees which combines the binary parser combinators with iteratees
11:58:57 <EvanR> might work
11:59:57 <aidecoe> HeladoDeBrownie: it's not a matter of "trunk" only, but it's append which doesn't work there. If I put "trunk" a the beginning and try to append some list to that it's not appended.
12:00:14 <aidecoe> HeladoDeBrownie: this is crazy
12:01:09 <ReinH> aidecoe: what's this about?
12:02:32 <aidecoe> ReinH: have you logged my discussion with HeladoDeBrownie from 18:00 UTC?
12:02:56 <ReinH> aidecoe: ah
12:03:18 <aidecoe> ReinH: there's some spooky things happening around ++ operator
12:03:32 <EvanR> @src (++)
12:03:32 <lambdabot> []     ++ ys = ys
12:03:32 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:03:32 <lambdabot> -- OR
12:03:32 <lambdabot> xs ++ ys = foldr (:) ys xs
12:03:59 <dmj`> ReinH, mauke, geekosaur: thanks
12:04:52 * hackagebot stripe-haskell 0.1.1.2 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.1.2 (DavidJohnson)
12:07:35 <aidecoe> maybe there's something obvious about Haskell I have missed in my code?
12:08:44 <EvanR> make sure youre considering ++ as if it was implemented above, with lazy evaluation
12:09:53 * hackagebot hspec-snap 0.3.2.3 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.2.3 (DanielPatterson)
12:09:53 <aidecoe> EvanR: i am aware how ++ is implemented, but i don't see anything suspicious about this
12:10:08 <aidecoe> EvanR: is there something?
12:10:32 <EvanR> i havent been following, do you have a minimal example of the phenomenon
12:10:41 <dmj`> running tests in parallel is so nice
12:11:47 <pdefql> http://lpaste.net/121300 - how can 'the latter forall be moved up' ?
12:12:26 <aidecoe> EvanR: it's hard to get it minimal, because function in question works perfectly fine if it's separated, but here's the code: http://wklej.org/hash/2fbfea56718/ - problem is in line 49
12:12:38 <aidecoe> EvanR: 'trunk' doesn't get appended
12:13:27 <aidecoe> EvanR: and it's not about 'trunk' but it's about rhs operand
12:14:07 <aidecoe> EvanR: i can put anything there in place of 'trunk', or swap operands. Always the rhs operand is not getting appended to the left
12:15:10 <EvanR> aidecoe: drawTree 3 4 ["Abc", "Xyz"], for instance?
12:15:33 <EvanR> oops
12:15:37 <EvanR> drawTree 3 4 ...
12:15:39 <aidecoe> EvanR: wait. Not always! In first call from drawTreeFractal it gets appended, in second - not, in third and later - it's not.
12:16:30 <aidecoe> EvanR: drawTree 3 4 is fine
12:16:46 <aidecoe> EvanR: i couldn't reproduce the issue when calling drawTree alone
12:16:47 <EvanR> whats an example that gives answers you dont expect
12:17:13 <aidecoe> EvanR: if i call "dtf 2 16" - it's ok
12:17:22 <aidecoe> EvanR: if i call "dtf 3 16" - it's not ok
12:17:34 <aidecoe> EvanR: expected output: http://wklej.org/hash/7887ea0808d/
12:18:01 <aidecoe> EvanR: and here actual outputs: http://wklej.org/hash/cbc94ee7679/
12:18:46 <EvanR> i see
12:21:02 <EvanR> aidecoe: so in general it seems like the middle layers are wrong
12:23:58 <phaazon> I can’t find c2hs documentation about enum generation anymore
12:24:01 <phaazon> does it still do that?
12:24:11 <phaazon> {#enum
12:24:14 <phaazon> or something like that
12:24:23 <phaazon> #{enum
12:25:58 <aidecoe> EvanR: but i don't get how it happens that sometimes this works and sometimes not. If it were C i wouldn't be surprised.
12:26:10 <EvanR> im checking in ghci
12:27:48 <EvanR> aidecoe: well, i determined that line 49 is acting the way you think it should
12:28:05 <EvanR> the result of that expression includes the vertical stem, it just isnt getting printed out
12:28:11 <maurer> I'm trying to use deriving Generic, but I'm getting "Not in scope: type constructor or class ‘Generic’"
12:28:16 <maurer> I'm passing -XDeriveGenerics
12:28:28 <mauke> you also need to import the module that defines the class
12:28:50 <maurer> Which is?
12:29:03 <maurer> (the example code I can find doesn't import anything...)
12:29:05 <mauke> don't remember
12:29:08 <mauke> check the documentation
12:29:10 <aidecoe> EvanR: yes, i've checked that with trace, too, that 'trunk' has content i want
12:29:49 <EvanR> yeah but the trunk is never evaluated under normal circumstances
12:29:56 <EvanR> (for the inner layers)
12:30:04 <raek> I once saw a web page that explained space and time complexity in haskell with some pretty diagrams. now I can't find that page...
12:30:19 <EvanR> the trunk thunk is there, but drawFractal is somehow not bothering to go that far
12:30:28 <EvanR> still checking
12:30:30 <raek> I think it used the "average" function as an example. does anyone have any idea which one it could be?
12:31:17 <monochrom> it's my http://www.vex.net/~trebla/haskell/lazy.xhtml
12:32:04 <raek> monochrom: it is! thank you!
12:34:45 <HeladoDeBrownie> aidecoe, EvanR, i bet it's the zip
12:34:57 <HeladoDeBrownie> or… i might be confused looking at this XD
12:35:04 <EvanR> the zipWith on 49 is working fine
12:35:27 <HeladoDeBrownie> i actually meant 66
12:35:34 <HeladoDeBrownie> but never mind, i don't think that's it
12:36:16 <EvanR> the result of drawTreeFractal also looks right
12:46:01 <aidecoe> i'm going sleep now, but if you would find something wrong, i'd be grateful (-:
12:46:06 <EvanR> hahaha
12:46:42 <aidecoe> EvanR: no chance? (-:
12:47:10 <EvanR> this code is quite convolved
12:47:42 <EvanR> you might want to spend your time rewriting it in a more straightforward way
12:48:04 <aidecoe> EvanR: that's my plan for tomorrow
12:48:06 <aidecoe> maybe it will help
12:48:17 <aidecoe> but it's strange what's happenning anyway
12:48:24 <EvanR> anything is better than three people taking three hours to fail to understand the issue
12:48:30 <aidecoe> :-)
12:49:02 <aidecoe> i hoped maybe someone would find out some explanation to such a behaviour
12:49:15 <EvanR> i narrowed it down
12:49:29 <aidecoe> if it happened once, i/anybody can get the issue in the future
12:49:42 <EvanR> its completely reproducible, its a pure fuction :S
12:50:01 <EvanR> it occurs on any layers between the highest and lowest
12:50:57 <aidecoe> i see. Thank you. I'll work on it tomorrow to get it more simple and maybe even working. (-:
12:51:00 <aidecoe> goodnight
12:54:03 <EvanR> aidecoe: its caused by the childTreesSpace being shorter than the childTree
12:54:22 <EvanR> so the last bits of childTree do not get zipped in the zipWith3
12:54:38 <EvanR> so just fix that, im sure it has to do with how you are creating the childTreesSpace list
12:55:38 <EvanR> zipWith (++) ["abc", "def", "ghi"] ["123", "456"]
12:55:40 <EvanR> > zipWith (++) ["abc", "def", "ghi"] ["123", "456"]
12:55:41 <lambdabot>  ["abc123","def456"]
12:55:46 <EvanR> no ghi
12:57:31 <EvanR> HeladoDeBrownie: ^
12:58:10 <HeladoDeBrownie> EvanR, huh, so i was on the right track after all, i just lost the thread :P
12:59:39 <EvanR> yeah 66 didnt have a zip on it
12:59:42 <EvanR> for me
12:59:52 <EvanR> but thats what it was
13:01:22 <HeladoDeBrownie> maybe memo aidecoe in case they're already afk for the night
13:02:26 <imag_> So I'm trying to make a function operate on vectors of arbitrary length - is there a good way to do that?
13:02:36 <imag_> (say if I wanted to sum two vectors)
13:02:47 <imag_> Should I just use lists as vectors?
13:03:04 <mmachenry> imag_: Maybe a Foldable instance?
13:03:19 <HeladoDeBrownie> imag_, what type are you referring to as vectors?
13:03:58 <imag_> Uh I'm trying to simulate vectors over the reals for example, so Integral I guess
13:04:01 <imag_> not integral
13:04:02 <imag_> Num*
13:04:27 <imag_> but for example I want to write a function that would be general enough that it doesn't matter if the vector is 5 elements long
13:04:28 <imag_> or 10
13:04:29 <HeladoDeBrownie> imag_, ah, are you trying to design a vector type as well? or do you have one already?
13:04:34 <imag_> I don't
13:04:36 <HeladoDeBrownie> or are you looking for one?
13:04:36 <imag_> I'm trying to design one
13:04:38 <HeladoDeBrownie> okay
13:04:42 <imag_> or looking for one I'm not sure
13:04:43 <imag_> I'm still learning
13:04:49 <noteventime> Is CUIntPtr to correct Foreign.C.Types type for uintptr_t?
13:04:50 <imag_> I'm reading the foldable instance page now
13:05:23 <HeladoDeBrownie> imag_, well, as you say, you could implement them using list, perhaps
13:05:38 <HeladoDeBrownie> imag_, although, what do you want the output of <1, 2, 3> + <1, 2> to be?
13:05:54 <HeladoDeBrownie> is it a type error? or does it give an output?
13:06:01 <imag_> type error
13:06:03 <HeladoDeBrownie> okay
13:06:07 <HeladoDeBrownie> sounds like tuples then
13:06:16 <imag_> But aren't tuples a set length?
13:06:17 <HeladoDeBrownie> or Vec
13:06:20 <HeladoDeBrownie> yes they are
13:06:42 <HeladoDeBrownie> there's a type commonly called Vec of length-indexed lists
13:06:46 <HeladoDeBrownie> that should serve actually
13:06:47 <imag_> so if I wanted to write <1, 2> vAdd <3,4>, but at the same time do <1, 2, 3> vAdd <4,5,6>
13:06:50 <imag_> would that be allowed?
13:06:53 <imag_> hm
13:06:56 <HeladoDeBrownie> yes, it would
13:07:11 <HeladoDeBrownie> in fact i do recommend Vec for this, forget tuples or lists
13:07:23 <imag_> hm okay
13:07:25 <imag_> awesome thanks
13:07:37 <HeladoDeBrownie> i'm not sure what packages it may be in but it's easy to write
13:07:45 <HeladoDeBrownie> is this a learning exercise?
13:09:06 <imag_> yeah, I'm still finishing up LYAH
13:09:18 <imag_> so I figure that actually doing something with haskell is going to help me learn better
13:09:25 <HeladoDeBrownie> okay. i warn you though that this uses a feature not covered there
13:09:27 <noteventime> I wouldn't exactly call it easy to write, considering you have to do a fair amount of type level trickery to define some of the operations you'll probably want to define
13:09:38 <HeladoDeBrownie> imag_, that in mind, do you want to go ahead and try implementing this with some help?
13:09:50 <imag_> What feature do you mean?
13:09:51 <HeladoDeBrownie> noteventime, yeah, that's fair
13:09:53 <imag_> and yeah that'd be great
13:09:59 <HeladoDeBrownie> imag_, generalized algebraic datatypes (gadts)
13:10:05 <imag_> I'm looking around to install Data.Vec
13:10:29 <imag_> I'm not sure if I have cabal
13:10:48 <HeladoDeBrownie> noteventime, i think i was thinking "i can write it off the top of my head", and said that as "easy", which was not really correct.
13:11:08 <HeladoDeBrownie> imag_, cabal is pretty good to have, do you need help getting it?
13:12:05 <noteventime> HeladoDeBrownie: Ahh, the mathematician's "easy" :)
13:12:19 <pdefql> Is there a way to pass type parameters in reverse order?
13:12:20 <imag_> uhm I'm looking at the page now and the cabal installer seems to be for mavericks but I'm running a newer mac OS
13:12:33 <imag_> I'll try to .tar
13:12:38 <imag_> the .tar*
13:13:04 <HeladoDeBrownie> imag_, i can't help with installing on os x unfortunately, but it's possible someone else is around who can if you have problems
13:13:09 <pdefql> like 'instance Monad (`State` a) where..' ?
13:13:09 <noteventime> Isn't this what the Haskell Platform is for?
13:13:14 <imag_> I think I should be able to manage
13:13:42 <HeladoDeBrownie> pdefql, there is no syntactic means of doing that, you'd need to define a type like newtype Flip f a b = Flip (f b a)
13:14:26 <pdefql> ah okay HeladoDeBrownie
13:14:37 <HeladoDeBrownie> (incidentally i think Flip as i just wrote it exists in base, but am not sure)
13:15:43 <noteventime> imag_: How did you install GHC?
13:16:28 <noteventime> imag_: In case you didn't know there's https://www.haskell.org/platform/ which includes cabal et al.
13:17:48 <Hijiri> there is also https://ghcformacosx.github.io/
13:18:04 <imag_> I'm not sure noteventime, it was a while ago
13:18:06 <imag_> thanks
13:18:08 <imag_> that should be useful
13:18:25 <imag_> I don't think I installed it like that
13:18:27 <Hijiri> which includes cabal and has a more up-tod-ate ghc
13:19:18 <imag_> awesome
13:19:22 <imag_> I think I do have cabal now though
13:19:50 <imag_> cabal-install version 1.16.0.2 using version 1.16.0 of the Cabal library
13:20:13 <imag_> might be a bit outdated though?
13:20:21 <Hijiri> newest cabal is 1.22.x I think
13:20:31 <imag_> ok yeah I'm updatin
13:20:36 <imag_> updating
13:23:43 <imag_> is it just me or does cabal take forever to update/install?
13:24:46 <Hijiri> if you have multiple cores you could run it with the -j flag to use them
13:25:19 <imag_> its already running though so I'm sorta scared to ctl-c in the middle of it
13:25:40 <imag_> unless it'll close safely
13:26:35 <Hijiri> it hasn't caused any issues in my experience, but if you're already part-way through it might be faster to wait it out
13:26:47 <imag_> ok all set
13:26:56 <imag_> hm
13:31:46 <QF-MichaelK> I tried to redefine +: let + = 3 in + - 1  Why won't this work?
13:32:39 <Hijiri> when using operators not infix, you need to give them parens
13:32:46 <Hijiri> >let (+) = 3 in (+) - 1
13:32:51 <Hijiri> > let (+) = 3 in (+) - 1
13:32:53 <lambdabot>  2
13:33:27 <QF-MichaelK> Ah, fair enough, doesn't feel like overloading as much
13:33:37 <raek> huh, I'm surprised that infix operators don't actually need to be functions of two arguments... :-)
13:33:48 <Hijiri> it's not overloading, it just shadows the other +
13:34:13 <QF-MichaelK> How would you redefine + to mean -?
13:34:25 <raek> > let a + b = a - b in 3 + 4
13:34:27 <lambdabot>  -1
13:34:37 <Hijiri> or just > let (+) = (-) in 3 + 4
13:35:17 <QF-MichaelK> Ah, alright, that's what I was after, thanks.
13:38:31 <imag_> agh
13:38:33 <imag_> anybody good with unix?
13:38:42 <geekosaur> occasionally...
13:38:47 <imag_> I have cabal 1.22 in a folder
13:38:49 <imag_> so that if I do
13:38:52 <imag_> ./cabal --version
13:38:53 <imag_> I get 1.22
13:39:00 <imag_> but when I call cabal --version from anywhere else
13:39:01 <imag_> I get 1.16
13:39:09 <imag_> how do I make it so that the 1.22 gets called instead?
13:40:01 <acowley> imag_ Put it on your PATH
13:40:24 <acowley> export PATH=Foo:$PATH
13:40:37 <acowley> Where Foo is the directory you put 1.22
13:40:58 <imag_> So I already have an export PATH
13:41:07 <imag_> that I use to export my python directory for example
13:41:30 <imag_> is there any way to essentially append the new path to it?
13:41:43 <acowley> imag_: Yes, exactly what I showed
13:41:52 <imag_> ah
13:41:55 <acowley> imag_: Except that you want to prepend, rathe than append
13:41:57 <MP2E|Work> export $PATH:~/.cabal/bin
13:42:06 <imag_> I didn't know : appended to it
13:42:17 <acowley> You want your new directory to be before wherever your old cabal is
13:42:29 <dmwit> : is not special in any way
13:42:34 <dmwit> in this context
13:43:42 <geekosaur> don't use ~ in a PATH spec
13:43:50 <dmwit> I mean, it's just a string. It's not, like, something special the shell knows about or a command or anything like that. It is special in that it is treated as a separator by programs that parse $PATH.
13:44:06 <geekosaur> whether bash will expand it or not depends on the bash version and various shopt-s
13:44:18 <geekosaur> and if it's not expanded before it gets put into the environment, it will not work
13:44:45 <geekosaur> (and this is annoying to debug because most ways to test it go through the shell and bash will sometimes expand it and sometimes not...)
13:48:34 <imag_> adding it to my path is still giving me 1.16 for some reason
13:48:39 <imag_> is there a way to find where 1.16 is so I can uninstall it?
13:49:40 <acowley> which cabal
13:49:42 <geekosaur> did you do it in the current shell, or in a dotfile?
13:50:48 <randir> I'm trying to write a webscraper, what would be the best package for it? I don't need something super complicated, just trying to strip out certain tags (e.g., removing all </script> blocks) and follow relative links.
13:51:08 <imag_> dotfile
13:51:17 <HeladoDeBrownie> imag_, you may need to source the file
13:51:21 <geekosaur> then it will only take effect in the next shell you open
13:51:32 <imag_> gotcha
13:51:33 <imag_> yeah
13:51:36 <imag_> I opened a new one and it was all set
13:51:37 <imag_> thanks
13:52:08 <imag_> okay I'm all set with Cabal!
13:52:17 <imag_> I'm ready to do the vector thing HeladoDeBrownie
13:52:43 <HeladoDeBrownie> imag_, okay. now, did you want to go off of somebody else's Vec or implement your own? the latter will require several different features to come together
13:52:51 <HeladoDeBrownie> some of which you haven't learned yet
13:53:10 <imag_> I can possibly learn them along the way/read up on them later?
13:53:14 <HeladoDeBrownie> okay
13:53:18 <acowley> randir: taggy is a new-ish entrant in that scene
13:53:21 <HeladoDeBrownie> well i mentioned gadts as somehting that would be used
13:53:24 <imag_> so maybe implementing my own might be a better option if I'm doing this to learn
13:53:33 <HeladoDeBrownie> that's not part of the language by default, you need an extension to enable it
13:53:37 <acowley> randir: tagsoup is an old standby
13:53:48 <HeladoDeBrownie> you can enable it by putting {-# LANGUAGE GADTs #-} at the very top of your source file
13:54:14 <HeladoDeBrownie> imag_, so, what are all the operations you want to support on these vectors?
13:54:55 <imag_> ok perfect
13:55:01 <imag_> I want to support subtraction
13:55:06 <imag_> addition
13:55:15 <imag_> and finding a norm
13:55:27 <HeladoDeBrownie> what is vector norm again? i forget
13:55:36 <randir> acowley: thanks
13:55:38 <imag_> distance from the origin
13:55:43 <HeladoDeBrownie> okay
13:55:58 <imag_> so like ||<x, y>|| = sqrt(x^2 + y^2)
13:56:11 <imag_> sorry
13:56:11 <HeladoDeBrownie> so, let's use Vec 3 Int as shorthand for a vector of three Ints
13:56:13 <imag_> yeah
13:56:17 <imag_> ok
13:56:17 <HeladoDeBrownie> this is close to how it's going to end up looking
13:56:21 <imag_> do I need to download anything?
13:56:26 <HeladoDeBrownie> not afaik
13:56:30 <imag_> ok great
13:56:30 <HeladoDeBrownie> since you're gonna implement it
13:56:53 <imag_> okay
13:57:01 <HeladoDeBrownie> do you know how to write out the types of your operations if we write vectors that way?
13:57:55 <imag_> vecPlus :: (Num a, Num b) => Vec a -> b
13:57:56 <imag_> sorry
13:57:57 <imag_> thats norm
13:58:06 <faux___> i am learning how to use hspec with cabal. i have a simple Spec.hs file with tests that should fail. I have this file described in a 'Test-Suite' section of my .cabal file. if the first line of Spec.hs reads 'module Main where', then `cabal test` shows the failing tests. if the first line instead says 'module Spec where', then `cabal test` will always give the result when it was 'module Main', regardless of how i change Spec.hs. How
13:58:12 <imag_> vecPlus :: (Num a) => Vec a -> Vec a -> Vec a
13:58:14 <monochrom> naw. since you're implementing it, you will write it, upload to github, then download from github. :)
13:58:30 <imag_> :)
13:58:41 <HeladoDeBrownie> imag_, you're missing a parameter
13:59:02 <HeladoDeBrownie> imag_, oh, i'm going to pre-empt the requests to move this to #haskell-overflow and suggest we go there. that okay?
13:59:02 <imag_> oh whoops
13:59:10 <imag_> yep
13:59:13 <monochrom> I think it's better as "norm :: Num a => Vec a -> a"
13:59:30 <imag_> monochrom - what if a is an Int then
13:59:34 <imag_> wouldn't the norm also have to be an Int?
13:59:40 <monochrom> yes
13:59:40 <geekosaur> faux___, Test-Suite expects a main program, which must be module Main where ... main = ...
14:00:04 <monochrom> Vec Int -> Int, Vec Double -> Double, Vec Quaternion -> Quaternion, etc.
14:00:17 <imag_> if I want the norm to be just a general num when a isn't?
14:00:26 <HeladoDeBrownie> monochrom, we've moved this discussion to #haskell-overflow if you're interested in contributing there
14:02:18 <faux___> geekosaur: okay. i've been seeing a lot of blog posts with other module names, but i guess cabal requires you to start from a module main
14:02:46 <geekosaur> ghc does, actually. cabal allows you to specify otherwise for main programs but I don't think that extends to test suites?
14:02:58 <faux___> geekosaur: i guess it's common practice to have 2 'Main' modules in a haskell project, one for code and one for tests?
14:03:03 * geekosaur checks
14:04:36 <geekosaur> oh, hm, for exitcode-stdio-1.0 you need a main program and it must be module Main, for detailed-0.9 you need a module Tests instead.
14:05:10 <geekosaur> note that multiple source files may have module Main, as long as only one of them is linked into a given program (which is what you want for a test program anyway)
14:05:40 <ale__> hey guys I’m trying to install ‘hdevtools’ but cabal doesn’t find it. Do I have to manually add remotes to cabal or something? Thanks
14:05:59 <faux___> geekosaur: i see, thanks for checking on that. so if you're making an executable, it makes sense to have a very small 'Main' module, in order to allow maximum test coverage?
14:06:02 <geekosaur> ale__, cabal update?
14:06:26 <geekosaur> faux___, things you want to test should not be in the main executable's Main module, certainly
14:06:48 <geekosaur> proper modularity suggests that anyway, module Main should be a minimal driver and all the logic should be in modules
14:06:53 <faux___> geekosaur: okay great. we're on the same wavelength. thank you!
14:06:59 <ale__> Hey geekosaur. It doesn’t update, it says the list is 83 days old but then it skips the download saying that local and remote files match
14:07:31 <geekosaur> ale___, um, the module index has certainly changed within the past 83 days
14:07:43 <ale__> Im on Mac OS X btw
14:07:57 <geekosaur> check ~/.cabal/config for repo definitions
14:08:04 <ale__> Ok will do now
14:09:09 <ale__> @geekosaur: Is this meaningful enough? remote-repo: stackage-2014-12-04-ghc78hp-exc:http://www.stackage.org/snapshot/2014-12-04-ghc78hp-exc
14:09:09 <lambdabot> Unknown command, try @list
14:09:09 <ale__> remote-repo-cache: /Users/ale/.cabal/packages
14:09:13 <geekosaur> right, most recent change to the module index was about 2 hours ago in fact
14:09:32 <geekosaur> ale___, yes, you're using stackage instead of hackage
14:09:40 <ale__> what’s the difference?
14:10:06 <geekosaur> stackage is mostly packages / versions curated to work with (or dependencies of) yesod
14:10:47 <geekosaur> it is NOT a full package repo, and if the author of hdevtools has not submitted their package to stackage then it won't be there
14:10:57 <ale__> Ohhhh ok. I must have read some random post and changed it and forgot about it. Thanks!
14:11:07 <ale__> Gotcha ;)
14:21:18 <phaazon> oh god
14:21:22 <phaazon> c2hs rocks so hard \o
14:28:40 <Zemyla> Hmm. Is the list monad faster or slower than the list monad done in CPS?
14:31:55 <ReinH> Zemyla: Yes.
14:33:02 <Zemyla> :V
14:37:15 <monochrom> I think ReinH only saw "faster than" and answered yes
14:37:31 <hpc> or "faster or slower"
14:37:36 <hpc> ;)
14:38:01 <shachaf> It's faster to type "the list monad" than "the list monad done in CPS".
14:38:12 * geekosaur took that to mean "can't answer without knowing what you're doing with it"
14:38:43 <`^_^v> surely in  the years to come philosophers will be debating this cryptic message
14:39:14 <raek> do seq, ($!) and bang patterns all use the same underlying mechanism?
14:39:30 <geekosaur> raek, yes
14:39:37 <raek> is it just a matter of style which one I use?
14:39:39 <monochrom> I don't know about philosophers. but common users of reddit, twitter, tumblr, and imgur --- absolutely
14:39:43 <hpc> yes
14:39:47 <geekosaur> raek, pretty much, yes
14:39:52 <raek> okay! thanks
14:40:34 <raek> are there any more "eagerness annotations" I should know about?
14:41:14 <ReinH> monochrom: It is faster or slower.
14:41:19 <monochrom> darn
14:41:55 * geekosaur pedantically notes that that means it can't be the same for some uses >.>
14:42:27 <ReinH> geekosaur: I'll pedantically note that that would be XOR.
14:42:34 <Ferdirand> well he didn't say strictly faster or strictly slower
14:43:03 <randir> What's a simple way to convert from Data.ByteString.Lazy.Internal.ByteString to Text?
14:43:06 <ReinH> geekosaur: which is usually phrased as "either X or Y" ;)
14:43:24 <hpc> randir: what's the encoding?
14:43:29 <Welkin> encodeUtf8
14:43:31 <geekosaur> doesnt that only work if they're exclusive? (< vs. >=?)
14:43:33 <Welkin> :t encodeUtf8
14:43:34 <lambdabot> Not in scope: ‘encodeUtf8’
14:43:39 <Welkin> :t Data.Text.encodeUtf8
14:43:40 <lambdabot> Not in scope: ‘Data.Text.encodeUtf8’
14:43:46 <bennofs> randir: you need to pick an encoding for that first. is your bytestring utf8?
14:43:50 <glguy> encode would go from text to bytestring
14:44:00 <Welkin> oh, that is Text -> BytString
14:44:04 <bennofs> :t Data.Text.Encoding.decodeUtf8
14:44:04 <lambdabot> BSC.ByteString -> Data.Text.Internal.Text
14:44:44 <randir> I've gotten the bytestring from simpleHttp from here: https://hackage.haskell.org/package/http-conduit-1.2.1/docs/Network-HTTP-Conduit.html
14:45:07 <randir> How do I determine the encoding?
14:46:33 <hpc> how indeed
14:46:48 <glguy> randir: You'd guess and then start parsing the HTML and find this "<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />"
14:47:09 <geekosaur> also look for normal content-type: http header
14:47:14 <geekosaur> loads of fun...
14:47:17 <randir> that what I was thinking-- is there any other way besides guessing?
14:47:39 <glguy> You can ask the person who posted it. In this case the encoding isn't sent as an HTTP response header
14:47:44 <bennofs> yeah, using the `http` function gives you back a Response which contains responseHeaders which you can search for the Content-Type
14:48:07 <geekosaur> if there were, the lives of web designers and web framework developers would be much easier
14:48:59 <randir> bennofs: thanks. I don't have to use Network.HTTP.Conduit, is there another one you'd recommend?
14:49:35 <randir> I'm simply trying to parse some html, and the taggy library want's to take a Text, I'm open to using a different tool
14:50:01 * hackagebot buffer-builder 0.2.1.0 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.1.0 (chadaustin)
14:50:02 <randir> wants*
14:50:20 <bennofs> randir: well, if you want it to work for any website, you somehow have to guess / detect the encoding. There is no way around that
14:50:21 <dulla> buffers?
14:50:37 <glguy> randir: It's normal that you'd get a ByteString from an HTTP request, and normal that other libraries want a Text. It's your job to guess the encoding
14:50:47 <randir> bennofs: Okay, thanks bennofs.
14:50:53 <Lokathor> yeah if you can arrange with the server to always send a particular type of encoding that's best, if it's an option
14:51:08 <glguy> UTF-8 is a pretty safe default guess
14:51:18 <bennofs> randir: from a quick search, you might want to take a look at charsetdetect
14:51:19 <randir> I'm making a web-crawler, so it has to be generic
14:51:31 <Lokathor> ah, you might be stuck guessing then
14:51:49 <dulla> ooh, webcrawler
14:51:58 <bennofs> s/charsetdetect/charsetdetect-ae
14:52:38 <Lokathor> Say I want a function that takes two ordered collections of elements, and outputs a third ordered collection of elements. Normally I'd use zipWith and lists or vectors, but is there perhaps a way to encode at the type level that both inputs should be of the same size? and that the output will be of that size as well?
14:53:30 <Lokathor> in this case the size might range from 10 up to 1000 or so, so tuples are kinda out
14:53:52 <Hijiri> they're discussing length-indexed lists in overflow
14:54:11 <Lokathor> oh i'll try to follow that
14:55:07 <dulla> what? Hijiri ?
14:55:38 <geekosaur> #haskell-overflow
14:55:44 <dulla> no no
14:55:53 <dulla> length-indexed lists being a solve for this :v
14:56:49 <nerium> How would you run this code? I'm trying to use the currentClass function, but can't b/c of "case"
14:56:49 <nerium> https://gist.github.com/oleander/58753e2c19465f79bca9
14:57:05 <Hijiri> (a -> b -> c) -> Indexed n a -> Indexed n b -> Indexed n c
14:57:20 <Hijiri> where n is some type-level length index
14:57:32 <ReinH> nerium: does that code compile?
14:57:45 <nerium> ReinH: No, so "run" is the wrong word
14:57:54 <ReinH> nerium: edit your gist to include the error.
14:57:57 <nerium> I need to access the ioref in some way
14:58:32 <ReinH> readIORef gives an IO value
14:58:43 <ReinH> Your code acts like it gives a String
14:58:59 <nerium> ReinH: I've updated the code
14:59:19 <nerium> ReinH: Exactly, so how do I use the case together with the io?
14:59:22 <_di>  /j #scotty
14:59:25 <_di> oops :)
15:00:11 <ReinH> nerium: you can use bind with readIORef, but somehow you need to deal with the inconsistency
15:00:14 <monochrom> what is Exp? is it a synonym for String?
15:00:29 <nerium> monochrom: In this case it's just a string
15:00:49 <Lokathor> Hijiri, that sounds perhaps a little more daunting than i care for in this particular situation :/
15:00:54 <nerium> ReinH: Do you by any chance have an example?
15:01:11 <ReinH> s <- readIORef currentClass
15:01:12 <akurilin> Has anybody figured out how to generate tags for vim with GHC?
15:01:38 <nerium> ReinH: Yes, but how do I pick between that value and "Runtime"?
15:01:40 <monochrom> nerium: it looks like you need to read my http://www.vex.net/~trebla/haskell.IO.xhtml
15:01:44 <ReinH> nerium: in a case statement
15:01:51 <ahammel> akurilin: ghci's :ctags command works for me
15:01:52 <ReinH> s is a String then
15:01:54 <Hijiri> Lokathor: There is another way, specialized to two lists of the same length
15:02:00 <nerium> ReinH: Can you use that outside "where"?
15:02:01 <akurilin> I was reading http://www.stephendiehl.com/posts/vim_haskell.html and I actually can't find the function that diehl uses there
15:02:10 <akurilin> ahammel: have you integrated it with vim?
15:02:11 <Hijiri> actually nevermind
15:02:13 <monochrom> err, typo. http://www.vex.net/~trebla/haskell/IO.xhtml
15:02:20 <ReinH> nerium: you'll need to use a let instead of a where, but you should read monochrom's link
15:02:23 <Hijiri> what I was going to suggest is equivalent to a list of tuples
15:02:49 <nerium> I know about monads, but I'm not sure how to combine it with the where clause
15:03:14 <ReinH> nerium: you can't, you'll need to use a let binding instead
15:03:30 <ReinH> you should read monochrom's link
15:03:52 <ahammel> akurilin: no, but you don't need it for tagbar
15:03:56 <monochrom> I won't argue over whether you know or don't know something.
15:04:07 <ahammel> here's my tagbar config:
15:04:08 <Lokathor> It's alright if perfect type safety can't be attained in this situation.
15:04:08 <ahammel> https://github.com/ahammel/dotconfig/blob/dnb/vim/vimrc#L74-L104
15:04:24 <ahammel> needs hasktags installed somewhere in your path
15:04:26 <monochrom> but I will argue over it anyway. my opinion is "the proof of the pudding is in the eating". end of arguing.
15:05:34 <bitemyapp> nerium: monad is an interface for working with IO, but knowing that particular interface doesn't mean you understand the semantics of IO.
15:05:42 <bitemyapp> nerium: jle` wrote about this not too long ago.
15:05:51 <bitemyapp> nerium: I agree with ReinH - you should read monochrom's article.
15:05:53 <Hijiri> Lokathor: Well it could, with the earlier solution, but depending on what you're doing it might not be worth the extra plumbing
15:06:22 <nerium> Shouldn't this work?
15:06:23 <nerium> let x = "hello" in do; print x
15:06:31 <monochrom> it works.
15:06:39 <geekosaur> nerium, actually not as written
15:06:51 <monochrom> except for the semicolon
15:06:56 <geekosaur> hm, actually, do after in should work
15:07:13 <geekosaur> but if the let is *inside* a do then you get surprises because let introduces its own layout
15:07:13 <monochrom> actually let me ask lambdabot
15:07:23 <monochrom> @type let x = "hello" in do; print x
15:07:24 <lambdabot> IO ()
15:07:26 <Lokathor> Hijiri I'm writing a chip library, and gates and or gates and stuff like that. I was wondering if I could make the "combinarion" chips such as and16 be fancily type safe instead of just list operators
15:08:13 <Hijiri> Lokathor: and the list would be like a tape of inputs?
15:08:27 <Hijiri> like a multi wire bundle thing
15:09:13 <Lokathor> yeah each list would be one "side" of the gate being replicated, and then each element would get paired up and the output is the pairs modified by the gate
15:09:22 <geekosaur> nerium, can you provide a little more context?
15:09:22 <Lokathor> so it's basically exactly zipWith
15:10:47 <mmachenry> I'm trying to use code coverage with -fhpc. When I build my tests with that, I get a .hpc directory when I run cabal test. But I don't know how to look at the results. hpc report <something here>
15:11:02 <mmachenry> Also it complains it can't find .tx files when I have .mix files
15:11:34 <Hijiri> Lokathor: I think the main issue with using length-indexed lists here would be when you want to take some signals out of a bundle of signals and put it in with another one
15:12:00 <Hijiri> but that is a gut feeling I'm not sure why
15:12:06 <ReinH> :t do;;;; print "test"
15:12:07 <lambdabot> IO ()
15:12:08 <ReinH> huh
15:13:19 <monochrom> it probably becomes do{ ; ; ; ; ; ; ; print "test" }
15:13:26 <Hijiri> I think I'm thinking of subscripting operations
15:13:47 <Hijiri> since it's a list
15:13:48 <monochrom> note that extraneous semicolons are allowed because it is a necessity
15:14:16 <Hijiri> but if you're indexing the list by length then you could extend type safety to subscripting too, but I'm not sure how exactkly that would go
15:14:21 <Hijiri> probably involving singleton types
15:14:45 <Hijiri> you would need some way to express that the index you are trying to get is smaller than the list's length
15:15:01 <Lokathor> that sounds quite a bit beyond the scope of the project
15:15:42 <Lokathor> i think that i saw a presentation on how to do that in Coq one time, the guy presented a way to declare that two trees were the same shape at the type level
15:16:08 <Hijiri> it involves more ceremony in haskell since haskell doesn't have more general dependent typing
15:16:32 <Hijiri> so you can't just stick values in the types, you need types, and then value-level ambassadors for those types
15:22:54 <nerium> ReinH: Shouldn't this work? https://gist.github.com/oleander/58753e2c19465f79bca9
15:23:09 <nerium> return "A" should be of type IO String
15:23:16 <nerium> and readIORef currentClass of the same type
15:23:16 <Hijiri> Lokathor: actually you don't need the value-level stuff for tree shapes
15:23:58 <ReinH> nerium: Sure. The do isn't necessary.
15:24:01 <nerium> Hmm, just removing the "do" worked
15:24:08 <nerium> ReinH: Yeah, why is that?
15:24:30 <nerium> Does return understand that it should wrap it in an IO?
15:24:31 <ReinH> Because you aren't using any do notation
15:24:41 <ReinH> do is just syntactic sugar
15:24:46 <geekosaur> nerium, do notation odesn't affect types at all
15:24:48 <ReinH> It is never necessary
15:24:53 <geekosaur> :t return
15:24:53 <lambdabot> Monad m => a -> m a
15:25:01 <geekosaur> :t do 5
15:25:02 <lambdabot> Num a => a
15:25:02 <shachaf> "should be of type" sounds like a handwaving judgment as in http://www.cs.cmu.edu/~rjsimmon/random/bovik2007.pdf
15:25:56 <ReinH> shachaf: I think I'm going to like this paper.
15:26:13 <geekosaur> the only thing `do` does is act as shorthand for uses of the (>>) and (>>=) operators (and incidental pattern matching in the latter case)
15:26:45 <c74d> Using WAI, can I get the hostname that a request was made to (or the requested URL, whence to extract the hostname)? If so, how? (Or, would another channel be more appropriate for this question? If so, which?)
15:27:02 <nerium> aha, thanks
15:27:15 <geekosaur> ...bovik. I have some idea of what's going on there without even opening it...
15:27:23 <ReinH> geekosaur: do notation does require that the return type be a monadic action, I suppose.
15:27:47 <geekosaur> :t do 5
15:27:48 <lambdabot> Num a => a
15:27:53 <geekosaur> look ma, no monads!
15:27:54 <ReinH> geekosaur: Or not.
15:27:56 <Lokathor> when i run "cabal haddock", haddock tells me some coverage stats. Is there a way to make it tell me which specific things are the things not yet covered?
15:28:41 <lpaste> Hijiri pasted “Lokathor” at http://lpaste.net/121305
15:28:51 <monochrom> "chemically assisted reasoning"  speechless
15:28:52 <Hijiri> tree shape at type level
15:29:53 <ReinH> monochrom: "alcohol in computer science" I'm dying
15:30:18 <Lokathor> Hijiri, that is all way above my skill level, but I will totally trust you that it works.
15:30:55 <Hijiri> Lokathor: you can try it in ghci
15:31:11 <Hijiri> this is an example session http://lpaste.net/121306
15:32:03 <Lokathor> hmm, yes it all vaguely looks correct, but I've no idea what's particularly going on
15:32:20 <Hijiri> this isn't much different than length-indexed lists
15:32:34 <Hijiri> instead of "Nat", you could call it "ListShape"
15:32:45 <Lokathor> I'm still back at the "hmm, maybe functor does this thing? how does functor work again?" proficiency level
15:32:53 <Hijiri> since nat is basically a list skellington, like this tree skeleton
15:34:01 <zipper> Anyone know how I can call a JS function from haskell?
15:34:27 <phaazon> is there a way to flag a package I maintain as “unsafe”?
15:34:43 <phaazon> or “dangerous”
15:34:47 <bennofs> phaazon: what do you mean by unsafe?
15:34:54 <phaazon> bennofs: like OpenGLRaw
15:35:00 <phaazon> it’s not really “haskellish”,
15:35:07 <phaazon> you could hit a wall very quickly
15:35:10 <monochrom> I think it's already the default
15:35:30 <phaazon> I also put “experimental”
15:35:36 <phaazon> for the Stability field
15:35:50 <phaazon> put it’s not really what I want
15:35:54 <mpickering> phaazon: I think everyone puts that :)
15:36:01 <ReinH> phaazon: "likely to set your hair on fire"?
15:36:05 <phaazon> I want to warn users and advise them to write wrappers
15:36:09 <phaazon> ReinH: well
15:36:17 <phaazon> instead of having true and nice data haskell types
15:36:32 <phaazon> I just re-export #define as value
15:36:35 <phaazon> with the same type
15:36:41 <phaazon> which is truely horrible
15:36:49 <monochrom> write your warning in the package description. that one paragraph that appears under the package name on hackage
15:36:50 <mpickering> maybe you should write a low level wrapper yourself
15:36:59 <ReinH> monochrom: omg that paper has tiny little hand symbols in the proof tables
15:37:06 <phaazon> mpickering: I am
15:37:11 <phaazon> monochrom: yeah, I guess that’s the way to go
15:37:12 <phaazon> thank you
15:37:19 <phaazon> I’m writing the al low package
15:37:21 <phaazon> since it’s missing
15:37:25 <monochrom> it also has the shotglass symbol and the shotglass monad, ReinH
15:37:59 <ReinH> monochrom: wait what
15:38:16 <phaazon> c2hs is a pure beauty :)
15:38:19 <phaazon> I love that tool!
15:38:51 <zipper> Anyone know how I can call a JS function from haskell?
15:39:08 <phaazon> GHCJS zipper
15:39:33 <zipper> phaazon: Sounds scary
15:39:51 <geekosaur> phaazon, that's common for low level bindings. one might borrow a trick used for haskell low level stuff: module <whatever>.Internal where...
15:40:26 <geekosaur> zipper, um, call how / in what context?
15:40:27 <mmachenry> Does anyone know about getting code coverage from cabal test? I have followed a tutorial and it makes a .hpc director… also a dist/hpc directory. But nothing I do to view it works.
15:40:36 <Welkin> zipper: why on earth would you want to call js from haskell?
15:40:57 <Welkin> just use purescript or ghcjs
15:41:24 <zipper> geekosaur: I am using BrowserID for authorization and authentication. It seems that all this auth plugin takes is JS
15:41:42 <igniting> If I have have opened a handle in WriteMode, and do a hSeek to a position which is greater than the file size, the file size increases!
15:41:46 <Welkin> I used browserID with yesod
15:41:50 <Welkin> there is no js necessary
15:41:51 <zipper> I'm totally unable to write a test for this with my limited knowledge
15:42:06 <zipper> Welkin: How can I test for auth?
15:42:46 <monochrom> igniting: I think this is intended, at least on linux and likely all unix
15:42:51 <zipper> Welkin: I am also using browserID with yesod. But in cases where the handler needs auth in order to test it I am completely lost.
15:43:05 <mpickering> mmachenry: I think you just use the -hpc flag and then a html report will be generated?
15:43:11 <mpickering> mmachenry: what are you currently doing?
15:43:20 <geekosaur> if it's looking for javascript then it's the client side, I can't see you caring about it in haskell unless using ghcjs to write client side / browser libraries in haskell
15:43:40 <geekosaur> monochrom, most unix filesystems support holes / sparse files. windows doesn't
15:43:49 <geekosaur> also igniting ^^
15:43:50 <mmachenry> mpickering: I have -fhpc in the ghc-options for my library, test, and executable in my cabal file
15:43:50 <monochrom> yeah
15:43:58 <mmachenry> Then I run cabal test
15:44:05 <geekosaur> merely seeking won't extend the file but writing will
15:44:13 <mmachenry> Then dist/hpc gets created but there's only directories in it, no files
15:44:13 <zipper> Welkin: or how can I cheat the handler that a user us logged in?
15:44:31 <zipper> geekosaur: I'm thinking of using a different auth plugin all together.
15:44:37 <geekosaur> and how it extends it varies depending on whether the filesystem supports sparse files, and whether you're writing in a new filesystem block
15:44:54 <Welkin> I would assume that it is just an http api call to authenticate with browserID
15:45:28 <phaazon> geekosaur: hm
15:45:47 <phaazon> Internal sounds weird
15:45:54 <phaazon> Raw is straightforward though
15:45:56 <geekosaur> (what happens on Windows under those circumstances, I couldn't say)
15:46:13 <phaazon> anyway, that’s not really important
15:46:15 <geekosaur> Internal makes perfect sense to me for this kind of thing, tbh
15:46:31 <geekosaur> and it's an existing convention
15:57:45 <ab9rf> geekosaur: windows supports sparse files since Windows XP
15:58:01 <ab9rf> geekosaur: you're a decade out of date
15:59:20 <ab9rf> actually windows 2000, it seems (NTFS5.0 and later)
16:02:30 <zipper> Welkin: I don't think so since it seems that browserID is about various people donating servers for this purpose.
16:02:42 <zipper> Therefore no single server to aim for.
16:03:04 <Welkin> well, it's not called browserID any more
16:03:06 <Welkin> it is Persona
16:11:02 <zipper> Welkin: Whichever way. I was just reading. https://developer.mozilla.org/en-US/Persona/The_navigator.id_API
16:11:55 <zipper> Welkin: This assertion thing is also very confusing.
16:13:04 <geekosaur> that page talks about the client side, running in the browser
16:13:22 <xandaros> I made a shared library of which I load some values with moduleOpen and moduleSymbol (going to be a plugin system). I can put it wherever I like, but if I put it in a directory called "bin", it can't find the symbols anymore - wat?
16:13:50 <zipper> geekosaur: I was looking for some url I could call using wreq
16:13:54 <zipper> or curl
16:14:09 <xandaros> tried it in my root project folder, root/src and root/plugin. All work fine, but root/bin not so much
16:14:21 <zipper> geekosaur: They don't seem to have any way of sending them data outside of JS
16:14:58 <geekosaur> yes, I noticed the project page said the client side is currently only js
16:15:15 <geekosaur> if you're implementing a client in haskell you won't be able to use that api at all
16:15:33 <geekosaur> unless you want to write (and contribute to them) a haskell client implementation
16:15:47 <zipper> geekosaur: I can't. My knowldge right now is limited.
16:16:06 <zipper> geekosaur: I think I have to move away from persona. What's in their api reference can't work for me.
16:16:30 <zipper> geekosaur: Which alternative do you recommend? What about HashDB as an alternative?
16:16:50 <geekosaur> I'm not really the right person to ask about that, sorry
16:18:35 <zipper> geekosaur: Seriously I have no idea what to try next. If you have any idea I'l take it.
16:55:37 <athan> Is there a widely used module syntax parser? I can see some work in Language.Haskell.Extensions from the Cabal library, just wondering if there's something more mainstream
16:56:35 <Cale> I'd use haskell-src-exts, I'm pretty sure
16:56:45 <Cale> http://hackage.haskell.org/package/haskell-src-exts
16:57:14 <athan> Cale: Ahh, sorry. Thank you!!
16:57:33 <Cale> You don't have to apologise :D
16:58:09 <athan> :)
17:02:18 <julianleviston> Is implementing memoization a trivial thing in Haskell? or is it automatically done by GHC when it compiles and notices you’re making repetitive calls to the same code?
17:05:12 <bergmark> julianleviston: knowing what to memoize in general needs solving the halting problem
17:05:28 <julianleviston> bergmark: for the compiler?
17:05:51 <julianleviston> bergmark: I don’t mind marking things I’d like memoized.
17:06:08 <julianleviston> bergmark: is that trivial?
17:06:38 <bergmark> julianleviston: you may be interested in https://hackage.haskell.org/package/data-memocombinators
17:06:50 <julianleviston> I guess this cache would indicate it’s not trivial : http://jaspervdj.be/posts/2015-02-24-lru-cache.html
17:07:43 <julianleviston> bergmark: haha love the utter lack of documentation on the github repo or the page you linked to.
17:07:56 <julianleviston> bergmark: short answer is “yes, but learn more” :) cool…
17:08:28 <julianleviston> bergmark: thankyou.
17:11:45 <MP2E|Work> hey guys, random question for you. I have an irc bot I'm working on and it works as intended in Linux, but in Windows, the stdout messages are not being output until the program is exited. I suspect this is because I set set buffering to NoBuffering.
17:12:25 <MP2E|Work> Is this because putStrLn isn't using DOS line endings?
17:12:32 <MP2E|Work> I'm pretty confused
17:13:37 <HeladoDeBrownie> MP2E|Work, NoBuffering should make it print immediately. show an erroneous example
17:13:45 <MP2E|Work> Ok
17:18:59 <cfoch> I am not sure if it this is a bug in Hayoo when I try to search ".+^" I get
17:19:05 <cfoch> "Internal Error: (line 1, column 4): unexpected end of input expecting digit"
17:19:09 <cfoch> just warning
17:19:56 <Lokathor> maybe it thinks you're trying a regex search?
17:19:56 <cfoch> BTW, does someone know what does this operator mean .+^
17:20:14 <cfoch> no this is an operator in Diagrams, I think
17:20:44 <Lokathor> right but Hayoo searching might be trying to interpret it as being a regex
17:21:02 <cfoch> maybe, I just was saying
17:21:37 <Clint> Data.AffineSpace (.+^) :: AffineSpace p => p -> Diff p -> p
17:22:35 <xnull> Where can I acquire wx_gtk2u_webview-3.0 on Arch Linux (x86_64)? I am trying to get `wx' to build with cabal install.
17:22:38 <xnull> I get the following message: http://lpaste.net/121298
17:23:16 <xnull> wait, i should probably go to a wxwidgets channel instead. never mind.
17:23:17 <MP2E|Work> aha !
17:23:29 <geekosaur> or an arch linux channe;
17:23:30 <MP2E|Work> HeladoDeBrownie, figured it out, it was actually a lack of NoBuffering set on stdout
17:23:39 <MP2E|Work> heh
17:23:46 <xnull> geekosaur: that too
17:23:56 <MP2E|Work> NoBuffering was actually set on the handle I got from connecting to a server
17:24:40 <MP2E|Work> So my question moves to this, what's the difference in the default buffering mode in Linux and Windows?
17:25:03 <MP2E|Work> @stdout
17:25:03 <lambdabot> Unknown command, try @list
17:25:10 <MP2E|Work> @botsnack -- whoops :P
17:25:10 <lambdabot> :)
17:25:36 <geekosaur> unixes default to line buffering on things that look like terminals. I don't know what windows does offhand
17:32:57 <randir> What do you think the most efficient way to check if a string is alphabetic?
17:33:32 <randir> Is there a way to roll out my own function that would be as efficient as a RE, but without using a RE library?
17:34:48 <julianleviston> randir: isn’t Haskell’s pattern matching more efficient than RE? Define what you mean by efficiency!
17:35:05 <julianleviston> randir: more efficient for the computer? or more concise for human expression?
17:35:55 <randir> I meant more efficient for the computer, but nevermind-- found the isAlpha function
17:36:31 <sx> randir: hand-written parsers in general are always faster than RE
17:37:57 <sx> I am actually annoyed by the disproportionate use of REs in most scripted languages.
17:40:20 <hiptobecubic> yes
17:40:27 <hiptobecubic> everyone reaches for re and it's always a mess
17:41:07 <julianleviston> something to do with our current languages being optimized for the pleasure of everyman
17:41:27 <hiptobecubic> well to be fair, writing a parser is usually terrible
17:41:37 <dramforever> yeah
17:41:41 <dramforever> any parser
17:41:45 <hiptobecubic> python does have string functions like startswith and endswith and __contains__ that help
17:42:21 <dramforever> hiptobecubic: I once wrote a takeWhile/isPrefixOf based parser
17:42:25 <dramforever> now it totally crap
17:43:06 <julianleviston> dramforever: ironically your last message is hard to parse. ;-)
17:43:16 <dramforever> here: https://github.com/dramforever/drambot/blob/master/Main.hs
17:43:25 <dramforever> julianleviston: oh hehe
17:43:29 <hiptobecubic> julianleviston, what's so hard? It crap.
17:43:44 <dramforever> it's not hard to understand
17:43:58 <dramforever> but if I gave it to a program it might not parse it
17:43:58 <hiptobecubic> dramforever, that happens after parsing
17:44:20 <julianleviston> dramforever: are you assuming I’m not a program?
17:44:34 <julianleviston> dramforever: lol… just being silly.
17:44:46 <dramforever> julianleviston: I didn't say anything about you
17:44:57 <dramforever> but I am assuming hiptobecubic is not a program
17:45:12 <lpaste> solatis pasted “Can this be simplified?” at http://lpaste.net/8493117177220562944
17:45:16 <solatis> ^^
17:45:17 <solatis> hi all
17:45:19 <julianleviston> dramforever: I had a problem working out if you meant “in today’s context, it’s totally crap”, or you just missed a couple words and were going for “now (let me tell you)… this program is/was totally crap”
17:45:44 <hiptobecubic> julianleviston, i think he meant "it crap" like "It crap on the floor"
17:45:52 <dramforever> julianleviston: why not check it out https://github.com/dramforever/drambot/blob/master/Main.hs
17:45:56 <solatis> i'm working through some function that walks through a list of Tokens, in which a Token can be a Key or a KeyValue
17:46:00 <julianleviston> hiptobecubic: haha, well I just auto-excluded that possiblity.
17:46:32 <solatis> I want to write a function that only considers KeyValue objects, and returns the value if a certain key is found
17:46:44 <solatis> the code i came up with is, while quite generic, still a lot of bloat
17:46:53 <solatis> is there a more elegant / dense way to do this ?
17:47:02 <dramforever> solatis: 1. why KeyValue (BS,BS) rather than KeyValue BS BS
17:47:21 <solatis> dramforever, no specific reason
17:47:39 <solatis> i figured that in haskell style a key/value combination is often defined as (key,value)
17:48:33 <dramforever> solatis: hey, maybe you can do data Token = Token ByteString (Maybe ByteString)
17:49:10 <solatis> hmm!
17:49:15 <solatis> that is actually quite clever
17:49:29 <solatis> and then i can just return the second parameter
17:49:34 <dramforever> solatis: Are you trying to parse get requests?
17:49:39 <solatis> nah
17:49:47 <solatis> but yes, it is part of a parser
17:49:51 <dramforever> solatis: are keys guaranteed to be unique?
17:49:55 <solatis> yes
17:50:36 <dramforever> join . lookup . (\(Token k v) -> (k, v))
17:51:12 <dramforever> solatis: and by the way, Data.Map is much faster
17:51:20 <solatis> performance is not really an issue
17:51:47 <solatis> let me first refactor my Token :)
17:51:52 <dramforever> okay
17:52:03 <dramforever> are tokens being passed alone?
17:52:08 <dramforever> I mean, being used
17:52:23 <dramforever> like you pass a single Token around, except when parsing
17:52:36 <solatis> nah
17:52:40 <solatis> it is a very basic ascii protocol
17:52:58 <solatis> STATUS OK FOO=BAR ID="abcd"
17:52:59 <solatis> like that
17:53:12 <solatis> [Token] is passed around, not individual tokens
17:53:29 <dramforever> solatis: oh in this case it seems that Map isn't faster
17:53:39 <dramforever> [Token]s are short, right?
17:53:42 <solatis> yes
17:53:46 <dramforever> okay
17:54:01 <solatis> and length [Token] is always smaller than 5
17:54:10 <dramforever> Yeah I guess data Token = Token (Maybe BS) is fine, go for it
17:54:21 <solatis> it even allows me to pattern match, right
17:54:34 <dramforever> solatis: ?
17:54:37 <solatis> well
17:54:41 <solatis> what i would ideally want
17:54:43 <dramforever> either way you can pattern match
17:54:43 <solatis> is something like this:
17:54:49 <solatis> tokens = parse input
17:54:51 <solatis> case tokens of
17:55:01 <solatis> ["STATUS", "OK", xs] -> doStuff
17:55:38 <Axman6> ("STATUS":"OK:xs) surely?
17:55:46 <solatis> ehr, yes
17:55:49 <dramforever> Axman6: tokens
17:55:52 <dramforever> oh yep
17:56:00 <dramforever> you are right
17:56:03 <solatis> anyway, seems ike this would work
17:57:29 <dramforever> (Token "STATUS" Nothing : Token "OK" Nothing : xs)
17:58:18 <dramforever> haddock question: which of the following is correct? \
17:58:22 <dramforever> 1:
17:58:31 <dramforever> -- | foo foo foo
17:58:35 <dramforever> -- bar bar bar
17:58:38 <dramforever> 2:
17:58:44 <dramforever> -- | foo foo foo
17:58:49 <dramforever> --   bar bar bar
17:59:45 <solatis> dramforever, they both work
17:59:56 <solatis> but i prefer to keep the indentation on the same level..
18:00:11 * Axman6 prefers 2
18:00:23 <solatis> many projects do 1
18:00:48 <dramforever> okay I get it. I do 1 because I see many others do this
18:02:34 <redactyl> In code, is there a generally accepted style for indentation?
18:02:42 <solatis> hah!
18:02:56 <solatis> if only there was such a thing
18:03:12 <solatis> in code, we cannot even agree upon whether to use tabs or spaces
18:03:15 <redactyl> I usually use 2 spaces, but I noticed that I had a problem with multiple let bindings
18:03:44 <dramforever> redactyl: my rule of thumb: just line things up
18:03:51 <dramforever> let a = b
18:03:53 <dramforever>     c = d
18:03:55 <dramforever>     e = f
18:03:58 <dramforever> in blah
18:04:13 <solatis> aha
18:04:19 <dramforever> because that's how haskell compilers are supposed to parse our code
18:04:20 <redactyl> solatis: spaces are the obvious correct answer
18:04:23 <solatis> and if you want to haddock these functions
18:04:33 <solatis> how would you do that?
18:04:39 <solatis> -- | foo bar
18:04:42 <solatis> let a = b
18:04:46 <solatis>     -- baz wombat
18:04:49 <solatis>     c = d
18:04:50 <solatis> ?
18:05:15 <solatis> or would you do this
18:05:16 <pavonia> You can use -- ^ ...
18:05:20 <solatis> that is try
18:05:22 <solatis> true
18:05:41 <dramforever> let (s1, s2) = break (/= '#') s -- a.html#b -> a.html, b
18:06:03 <dramforever> or sometimes:
18:06:07 <dramforever> let f =
18:06:13 <dramforever>         -- blah blah blah
18:06:21 <dramforever>         function body here
18:06:38 <dramforever> ouch I messed it up
18:06:40 <dramforever> never mind
18:06:46 <hpc> i always thought haddock was meant to be done as
18:06:49 <hpc> -- | foo foo foo
18:06:53 <hpc> -- | bar bar bar
18:07:00 <dramforever> hpc: some do that
18:07:09 <dramforever> but you get a | in the middle of your code
18:07:17 <dramforever> {-| actually this
18:07:24 <dramforever>     also works -}
18:07:43 <dramforever> I sometimes see this in GHC modules
18:09:00 <redactyl> so if I have
18:09:07 <redactyl> let a = b
18:09:13 <redactyl>   c = d
18:09:20 <redactyl>   e = f
18:09:28 <redactyl> that should work, right?
18:09:39 <redactyl> the compiler is wrong, and I'm right!
18:09:41 <hpc> the let bindings layout starts at the 'a'
18:10:16 <randir> How would you recommend finding all relative and absolute links in html?
18:10:43 <randir> assuming that I have a string "foo" of unparsed HTML
18:11:20 <pavonia> randir: You could use tagsoup for parsing and filtering all <a> elements
18:11:21 <redactyl> hpc: that makes sense, I'm just used to writing C++ where I always indent exactly 3 spaces
18:11:42 <hpc> heh, the only language where 3 spaces is idiomatic is ada
18:12:27 <redactyl> oh? am I doing C++ the wrong way? it's quite possible
18:12:29 <Axman6> and Ben Lippmeier's code iirc
18:14:29 <Lokathor> mux4wayZip :: [Signal] -> [Signal] -> [Signal] -> [Signal] -> [Signal] -> [Signal]
18:14:33 <Lokathor> what a gross type signature
18:16:10 <redactyl> Lokathor: why are there 6 of them?
18:16:53 <Lokathor> it produces an output list from among 4 input lists, based on a 2 element selection list
18:17:12 <Lokathor> mux4wayZip al bl cl dl selects = ...
18:17:15 <HeladoDeBrownie> "2-element list" sounds like a tuple to me
18:17:51 <Lokathor> Yes, but the idea is that I'll be able to move to a recursive version later on instead of specializing on 4way and 8way versions
18:18:21 <Axman6> is this is hardware, that's probably what you want anyway
18:18:31 <Lokathor> I don't know why you'd want a mux32way, but might as well make it possible
18:20:58 <redactyl> What's the context for all this muxing? muxxing?
18:21:16 <Lokathor> just simulating some logic gates
18:22:51 <Lokathor> Axman6, I've tried to read your sentence several times and I'm not sure which version is the version you're saying I'd probably want.
18:23:03 <xnull_> didn't this channel have 500 nicks a few weeks ago?
18:23:34 <Lokathor> Unlikely, there were 1000+ when I started sitting here in decemberish
18:23:40 <xnull_> ah, ok.
18:24:43 <xnull_> what would be the best way for me to rally and advertise haskell as a practical language in an effort to break the stigma of impracticality associated with it and maybe attract more programmers?
18:25:24 <shachaf> No need.
18:25:36 <shachaf> Alternatively: If you want to show that Haskell is a practical language, do practical things with it.
18:25:39 <Lokathor> produce programs that do useful things. lots of them. and do so using clean code that's easy(ish) to show to beginners
18:25:44 <dulla> ^
18:25:56 <dulla> Also, make better learning materials
18:26:13 <dulla> Learn the Aristotle teaching of "No bullshit, just cool shit"
18:26:17 <redactyl> more monad tutorials!
18:26:19 <dulla> I learned that from Dugan Ashley
18:26:34 <dulla> Can your Haskell operate?
18:26:37 <xnull_> redactyl: "a typeclass that implements return and bind"
18:26:47 <dulla> Does it have Spongebob Tape? And Skittles?
18:27:22 <Lokathor> Real World Haskell has 4ish example program outlines within it, Practical Common Lisp has 9ish
18:27:28 <dulla> so something can be encapsulated in the type, though, not sure what to say about bind
18:29:00 <Lokathor> "bind lets you modify the something inside the type using a funciton normally intended for somethings only, in an instance-sensitive way"
18:29:37 <dulla> all I know is that it lets you take in a value, and do a function
18:30:21 <redactyl> you know, it's taken me embarassingly long to figure out how to use monads
18:30:34 <xnull_> yeah, i think lots of learning materials are needlessly obtuse and maybe we could benefit from a "Haskell For Teens"
18:30:55 <Lokathor> I know that you *can* do it, but don't much do so for things other than IO
18:32:03 <Lokathor> xnull_, i would assert that learning Haskell without knowing other languages is probably easier than learning haskell if you do know an imperative language
18:32:21 <redactyl> xnull_: one of those cheesy-looking "Head First" books would be great
18:32:23 <xnull_> dulla: bind is sort of somewhat conceptually similar to fmap, but i think all the differences can be understood by looking at fmap and bind's type signatures
18:32:32 <xnull_> :t fmap
18:32:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:32:35 <xnull_> :t (>>=)
18:32:36 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:32:54 <xnull_> :t (=<<)
18:32:55 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:33:01 <dulla> and a -> m b has a return?
18:33:01 <xnull_> that last one is what i meant, (=<<)
18:33:39 <xnull_> dulla:
18:33:40 <xnull_> :t return
18:33:41 <lambdabot> Monad m => a -> m a
18:33:49 <barrucadu> Not necessarily a return
18:34:14 <Axman6> > Just 7 >>= Just
18:34:16 <lambdabot>  Just 7
18:34:30 <xnull_> ahem
18:34:31 <Lokathor> having worked with do-notation more than fmap, i'm almost more confident with (>>=) than with fmap
18:34:33 <Axman6> though, rwally that's just inlining the definition of return
18:34:38 <xnull_> i think this might be fairly helpful
18:34:50 <xnull_> > (+2) =<< Just 3
18:34:51 <lambdabot>  No instance for (GHC.Show.Show b0)
18:34:51 <lambdabot>    arising from a use of ‘M404602991733625154131145.show_M4046029917336251541...
18:34:51 <lambdabot>  The type variable ‘b0’ is ambiguous
18:35:03 <xnull_> see why that doesn't work? it doesn't return a Maybe Int
18:35:28 <xnull_> > (Just . (+2)) =<< Just 3
18:35:29 <lambdabot>  Just 5
18:35:38 <xnull_> > (return . (+2)) =<< Just 3
18:35:39 <lambdabot>  Just 5
18:36:05 <Lokathor> how often does it even come up to use "reverse bind"?
18:36:06 <xnull_> refer back to (=<<) and return's type signatures as needed
18:36:16 <xnull_> Lokathor: i use it almost all the time
18:36:19 <xnull_> it's more applicative
18:36:33 <xnull_> it fits better with other things IMO
18:36:39 <Lokathor> uhmmm
18:36:41 <Lokathor> hmm
18:37:13 <xnull_> sometimes (>>=) makes more sense, but (=<<) allows you to do things the normal way, but signal that you are in fact binding a monad (without changing organization of an expression)
18:37:40 <Lokathor> I think i'd have to be using monads more to understand what you're saying
18:38:43 <xnull_> Lokathor: say you have an IO String
18:39:04 <Lokathor> alright
18:39:47 <xnull_> you want to reverse that String, then pass it into another function that prints it (the other function has type String -> IO ())
18:39:57 <xnull_> i'll use putStrLn
18:40:37 <xnull_> myIOString >>= putStrLn . reverse
18:40:39 <xnull_> vs
18:40:54 <xnull_> putStrLn . reverse =<< myIOString
18:41:02 <Lokathor> hmmmm
18:41:09 <xnull_> it resembles the following better
18:41:16 <xnull_> putStrLn . reverse $ myString
18:41:30 <Lokathor> I'm not won over by the . operator myself yet
18:41:40 <xnull_> fair enough
18:41:54 <Lokathor> i'd proabbly do myString <- myIOString; putStrLn (reverse myString)
18:42:12 <dulla> so more or less it exposes a to a function that eventually returns
18:42:51 <xnull_> dulla: it doesn't have to use return
18:43:08 <dulla> but I'm using the term return for a reason
18:43:14 <dulla> because encapsulates is longer
18:43:42 <xnull_> a function passed to bind can call another function that returns a monad, and just return that directly
18:44:13 <Lokathor> for those interested in the chip simulation stuff I was talking about earlier: https://github.com/Lokathor/HaskChip/blob/master/src/LogicGate/Constructed.hs
18:44:21 <xnull_> the function passed to bind just has to return (not necessarily with the function named `return') a monad of the same type as the monad being passed into the bind
18:44:57 <dulla> so m is parametric
18:45:02 <xnull_> yes
18:45:05 <dulla> neat
18:45:13 <xnull_> monads are
18:45:33 <dulla> so the monad itself has those two operations, guaranteed
18:45:47 <dulla> but each at least introduces some kind of effect
18:46:05 <Lokathor> well, probably introduces.
18:46:28 <dulla> Well, I haven't seen one that doesn't do one yet
18:46:34 <dulla> So
18:46:36 <dulla> I guess?
18:47:04 <Lokathor> there is an Identity monad that makes no effect on the contents
18:47:12 <Lokathor> but it is the only one
18:47:24 <dulla> neat
18:47:26 <xnull_> dulla: i'm not sure what you mean by introducing some kind of effect
18:47:41 <xnull_> Maybe is also a monad
18:47:49 <dulla> Maybe with a bottom
18:48:11 <xnull_> bottom?
18:48:24 <dulla> nothing
18:48:28 <dulla> nothing?
18:48:32 <xnull_> Nothing
18:48:41 <dulla> huh, that was a freeze
18:48:59 <xnull_> Maybe doesn't have side effects as far as i'm aware
18:49:03 <Lokathor> Well, "effect on how the output works" might be a better way to phrase things
18:49:05 <xnull_> it still implements bind and return though
18:49:49 <Lokathor> a Nothing doesn't actually get modified by a bind, does it? it stays as Nothing
18:50:13 <xnull_> nothing gets modified
18:50:15 <xnull_> ever
18:50:38 <xnull_> `Maybe a' is an immutable value
18:50:42 <Lokathor> well, right, modified is a bad choice there
18:50:51 <hcore> no one is on haskell-beginner so i figure i'll ask here, i'm having a lot of trouble figuring this out: http://lpaste.net/121320
18:51:11 <xnull_> a bind can take a `Maybe a' and can return a `Maybe a'
18:51:12 <hcore> it's actually cis194-hw5 with some variables renamed for ease
18:51:20 <xnull_> it can never return a `Maybe b'
18:51:34 <Lokathor> :t (>>=)
18:51:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:51:38 <xnull_> oh, wow
18:51:40 <xnull_> i'm wrong sorry
18:51:41 <glguy> hcore: The only methods you can put in an instance declaration of Expr are mul, add, and lit
18:51:42 <xnull_> :^)
18:51:55 <hcore> yeah forgot to rename those
18:51:57 <glguy> hcore: Not min or max. In this case you'd use min/max to implement mul/add
18:52:00 <xnull_> Lokathor: yeah, but bind takes a monad and returns a new one
18:52:28 <hcore> updated, but my problem stays the same here
18:52:29 <Lokathor> xnull_, seems to return a value, possibly of a differnt type, within the same monad
18:52:34 <xnull_> Lokathor: indeed
18:52:56 <hcore> i get an issue when interpreting, it compiles just fine
18:52:58 <glguy> hcore: For your example expression you'd want to use your "lit" function to make literals
18:53:06 <xnull_> a bind cannot take an IO String and return a Maybe String
18:54:23 <hcore> glguy: returning "lit a" instead of "a" doesn't seem to work either
18:54:23 <Lokathor> hcore, perhaps try (1::Integer) instead of 1 when you're in the interpreter?
18:54:46 <hcore> ohhh
18:54:48 <hcore> ohhhhhhhhhhhhhhhhh
18:55:24 <Lokathor> yeah it was getting hung up on trying to convert a literal into an actual value I think, but the compiler is smarter about that than ghci is, i think
18:55:38 <hcore> thanks guys!
18:56:42 <imag_> Suppose I had a list of tuples: [(a, b)], and I want to go through it, and for the minimum a value (for some comparison function), I want to do something to b
18:56:44 <imag_> how could I do that?
18:57:14 <dulla> m-monoid?
18:57:14 <glguy> You'd compute the minimum a value and then go and modify the associated b value
18:57:36 <imag_> ok
18:57:41 <imag_> I wasn't sure if there was an easier way
18:57:45 <Lokathor> yeah you need to do two passes though the list, one to figure the min a, then another to go find it again and then modify that b.
18:58:09 <xnull_> you don't /need/ to do two passes. if performance is a concern, you can do it in one pass with a more complex implementation
18:58:39 <Lokathor> until you've gotten to the end of the list, how do you know what the minimum really is?
18:58:52 <imag_> lokathor -you can keep track of which is the latest minimum
18:58:56 <imag_> and then just change it
18:58:58 <xnull_> imag_++
18:59:09 <imag_> at least thats how I'd do it in a different language
18:59:12 <imag_> just learning haskell now
18:59:19 <xnull_> you store the index of the latest minimum
18:59:27 <xnull_> imag_: you can do that with haskell as well.
18:59:48 <Lokathor> i guess it depends on if you need the modified b to be in a new list, of if you'll drop the list and just use the modified b at the end of the process
18:59:50 <xnull_> if you're operating on a small-ish dataset then i would go with the naive implementation however
18:59:50 <imag_> How do you store the index of the minimum?
19:00:04 <imag_> is that simple?
19:00:15 <imag_> if its not I'll just go with the naive version
19:00:37 <dulla> the naive version would be to make the minimum a go the the left end of the list
19:00:43 <dulla> and then patternmatch it
19:01:21 <Lokathor> case (sorted l) of min:rest -> ...
19:01:25 <dulla> with this, one could easily drop the list, replace said element from the list with the modified value, or push it into the list
19:01:33 <xnull_> imag_: you keep a counter that increments every time you progress to the next element, and if it's a minimum, you update the latest minimum index with the current index.
19:01:43 <imag_> hm ok
19:01:49 <Lokathor> sort, not sorted, sorry
19:01:54 <xnull_> just like you would in any other language
19:02:49 <Lokathor> imag_, do you just want the modified b at the end, or do you want a new modified list with the modified b at the correct place inside it?
19:03:22 <imag_> the second
19:03:33 <imag_> I wanted a new modified list with the modified b at the correct place
19:03:34 <imag_> although
19:03:38 <xnull_> (i did not actually pay any attention to your overall problem, i was just letting you know how to iterate over a list and modify it in a single pass)
19:03:47 <imag_> if you move the (a, b) to the end then thats just as good
19:03:53 <imag_> I just need the (a, b) to stay together
19:04:32 <xnull_> imag_: you could sort the list when you construct it by making your own instance of Ord
19:04:38 <Lokathor> well, i guess it comes down to what the default sorting for a tuple is?
19:04:51 <xnull_> then move the modified element within the list when you modify it
19:05:07 <imag_> essentially what I'm doing
19:05:13 <xnull_> that way it is never unsorted and you don't have to run an expensive sort over it with every modification
19:05:17 <imag_> I mean I might as well say as this might change something
19:05:23 <redactyl> aren't tuples of Ords sorted lexicographically?
19:05:25 <xnull_> and you always know the minimum is at the beginning of the list
19:05:25 <imag_> I have a bunch of vectors
19:05:38 <imag_> and I want to find the one that is the closest
19:05:38 <xnull_> redactyl: i have no idea how they're sorted.
19:05:50 <imag_> to a different one
19:05:54 <imag_> and then do something there
19:06:00 <imag_> so I can't really sort once search twice
19:06:05 <imag_> as the different one changes
19:06:18 <Lokathor> I imagine that Ord a, Ord b implies Ord (a,b)... but don't know if it sorts by a or by first
19:06:42 <xnull_> imag_: two that are closest to one another will be adjacent in the list
19:07:22 <imag_> not quite - I have a norm function
19:07:34 <imag_> and
19:07:45 <imag_> I'm comparing to a vector not in the list
19:07:54 <xnull_> oh, sorry
19:07:54 <Lokathor> So, given a vector and a list of other vectors... find the other vector that's closest to the given one, and then do a thing with it?
19:08:40 <imag_> essentially
19:08:41 <imag_> except
19:08:46 <imag_> instead of a list of other vectors
19:08:55 <imag_> I have a list of tuples, where the first element is the list of other vectors
19:09:06 <imag_> and the second element is a list of vectors that I want to add to
19:09:09 <imag_> (they're zipped)
19:09:17 <imag_> I'm trying to do a grouping
19:09:41 <Lokathor> wow I think I'm lost
19:10:07 <imag_> yeah
19:10:11 <Lokathor> so what's the concrete type of the whole thing?
19:10:13 <imag_> I'm essentially trying to implement the k-means
19:10:16 <imag_> algorithm
19:10:22 <imag_> uh
19:10:29 <Lokathor> [([Vector],[Vector])] ?
19:10:39 <imag_> Yeah
19:10:44 <imag_> and then I compare a vector to that
19:10:52 <Lokathor> ho boy
19:10:52 <imag_> and whichever has the closest fast vector
19:10:56 <imag_> first
19:11:00 <imag_> hahaha
19:11:04 <imag_> it might be easier another way
19:11:08 <imag_> I'm exploring different options now
19:11:21 <Lokathor> well
19:11:30 <Lokathor> the simplistic way
19:11:33 <Lokathor> is to make an intermediate list
19:12:10 <imag_> intermediate list of?
19:12:11 * xnull_ is too distracted to know what's going on anymore
19:12:15 <imag_> hahaha
19:12:18 <imag_> sorry *
19:12:19 <imag_> ([a], [[a]])]
19:12:22 <imag_> this is what the type is
19:12:24 <imag_> [([a], [[a]])]
19:12:28 <imag_> with a being Num
19:12:33 <imag_> so I have Vector
19:12:37 <imag_> and list of vector
19:12:39 <imag_> and I have a list of that
19:12:57 <Lokathor> well, assuming i'm undersanting right, something like: map (\(a,b) -> (distance a c),(a,b)) myList
19:13:11 <Lokathor> assuming "distance" is an easily sortable type, like Double
19:13:19 <imag_> yeah
19:13:25 <imag_> hm something along those lines might work
19:13:28 <Lokathor> then you sort that, and the 0th element will have the lowest distance
19:13:42 <Lokathor> and that lowest distance will be paired up with the right tuple
19:13:59 <imag_> I'm just worried
19:14:01 <imag_> that if I modify it
19:14:08 <Lokathor> big "however" here: once you do all that, putting it back into the original list will be a nightmare
19:14:12 <imag_> then how do I get back to the original points
19:14:12 <imag_> yeah
19:14:17 <imag_> agh
19:14:56 <Lokathor> so what you need is something like minVectorDistanceThing :: MyWeirdList -> Vector -> Int
19:15:10 <Lokathor> so that you can deal in terms of an index
19:15:51 <imag_> I think my main problem here
19:15:56 <imag_> at least my main understanding problem is this
19:16:03 <imag_> if I have (x, [])
19:16:11 <imag_> how do I return (x, [y])
19:16:20 <imag_> like I just want to concatenate y to the empty list
19:16:24 <Axman6> what is y?
19:16:26 <imag_> what is the 'right' way to do that
19:16:28 <imag_> an element
19:16:30 <imag_> so like
19:16:32 <imag_> 3
19:16:34 <imag_> whatever it is
19:16:52 <Axman6> foo (x,xss) = (x,y:xss)
19:16:56 <Lokathor> catMe (a,b) y = (a,b++[y])
19:17:14 <Lokathor> but concating a single element onto the end of a list is not a good plan in haskell
19:17:25 <Lokathor> once the list gets long
19:17:35 <imag_> I mean prepending it is fine
19:17:44 <imag_> ok that might be useful to write then
19:17:45 <imag_> thanks
19:17:52 <Lokathor> preMe (a,b) y = (a,y:b)
19:18:42 <Axman6> (or second . (:))
19:18:43 <Axman6> >_>
19:18:58 <Lokathor> Data.List doesn't seem to have a "modify" type function in the library
19:19:21 <Axman6> what do you mean?
19:19:29 <imag_> maybe I'm thinking about this too imperatively
19:19:38 <imag_> and should revisit my approach
19:19:46 <Lokathor> I'm imagining something like, modifyWith :: [a] -> Int -> (a->a) -> [a]
19:20:26 <Axman6> pretty easily done with lenses
19:20:43 <Axman6> :t ix
19:20:44 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
19:21:23 <Lokathor> well, yes, but it's also something i would have assumed within the standard library. I guess haskellers are used to using map too much
19:21:44 <imag_> theres no way this has to be this complicated
19:21:48 <Axman6> well, that can't be done using map
19:21:57 <imag_> I'm thinking of it wrong
19:21:59 <Axman6> imag_: what're you trying to do?
19:22:09 <imag_> I'm trying to implement the k-means algorithm
19:22:15 <imag_> the step I'm stuck on now
19:22:18 <imag_> is if I have a list of vectors
19:22:31 <imag_> how do I group them by which point (out of a different list) they're closest to
19:22:40 <imag_> I might just make several iterations
19:22:41 <imag_> hm
19:22:44 <imag_> that might be a good way to go about it
19:22:48 <Lokathor> Axman6, right, but I'm saying that most haskell folks probably don't usually think "i want this same list back but slightly changed", that's a fairly imperative thing to do.
19:23:04 <Axman6> Lokathor: yeah, it usually is
19:23:15 <imag_> yeah
19:23:19 <imag_> so I feel like I'm doing it wrong
19:23:40 <Lokathor> imag_, my advice to you is that you should start by writing down the type signature you think the operation will have
19:23:58 <imag_> hm ok
19:24:03 <Lokathor> then seeing if you can do that, or if you need to think of a different type signature
19:29:56 <tippenein> I'm having troubles structuring this project to build a binary. I made the Main.hs to separate logic but it doesn't seem to get the functions from Data.Hasken: https://github.com/tippenein/hasken/blob/master/Main.hs#L30
19:30:29 <Lokathor> hmm, what does ghc say?
19:31:24 <tippenein> hasken: This method is required but not available: "Main.AddDocument". Did you perhaps remove it before creating a checkpoint?
19:31:40 <tippenein> I made sure that Data.Hasken exports all those functions
19:32:13 <tippenein> https://github.com/tippenein/hasken/blob/master/Data/Hasken.hs#L11
19:32:32 <tippenein> I'm thinking I'm missing something about how modules work
19:35:08 <Lokathor> oh so it compiles
19:35:21 <Lokathor> you're just getting an error from Data.ACID.Core
19:35:37 <Lokathor> http://hackage.haskell.org/package/acid-state-0.4/docs/src/Data-Acid-Core.html seems to be calling the missingMethod function
19:35:46 <xnull_> tippenein: why are you explicitly exporting everything?
19:35:56 <xnull_> if you don't export anything, everything gets exported automagically
19:36:13 <tippenein> ohhhh, lol. didn't know that
19:36:16 <xnull_> :P
19:39:12 <tippenein> I took out the explicit exports, but problem persists
19:39:41 <tippenein> This wasn't a problem when I had all the logic in Data.Hasken but I wanted the System.Environment stuff in a different module
20:10:22 <benbangert> Lokathor: I sorta thought that, but knowing what functions are, and types, actually does help
20:10:46 <benbangert> Lokathor: and yes, my scrollback buffer is old
20:10:59 <Lokathor> benbangert, uhm, what are you referring to?
20:11:19 <benbangert> Lokathor: about learning haskell coming from imperative langs, :)
20:11:33 <Lokathor> ahhh
20:11:38 <Lokathor> hmmm
20:11:54 <Lokathor> but I think that it's easy enough to explain what a type is to a person who doesn't understand any programming language at all
20:12:02 <benbangert> if you don't know what a variable is, or what 'types' of variables are, or interfaces, it'll be harder to learn haskell than nothing at all
20:12:11 <xnull_> Lokathor: to a person doing math
20:12:18 <xnull_> err
20:12:22 <xnull_> sorry i read your message wrong
20:12:46 <xnull_> yeah, coming from a certain math background i think haskell would be quite easy to pick up
20:13:08 <Lokathor> benbangert, the thing is that if you know what a java variable is, you actually know very little about a haskell variable compared to anyone who's taken just highschool math
20:13:08 <benbangert> yea, some math backgrounds, that makes sense
20:13:32 <benbangert> Lokathor: I have yet to compare someone that is a java programmer, with someone that just took highschool math...
20:14:02 <benbangert> I understand the conceptual theory, but to find two people of similar age in this world, and assert those equivilances.... is weird
20:14:16 <Lokathor> didn't you take AP Comp Sci in highschool?
20:14:18 <benbangert> or maybe you know more Java programmers in high school, I dunno
20:14:29 <benbangert> sure, and they taught turbo pascall back then
20:14:38 <Lokathor> ha, well then
20:14:54 <xnull_> he's saying of the knowledge relevant to knowing java types and the knowledge relevant to knowing high school math, haskell would be easier to transition to from the latter
20:15:18 <benbangert> I think such a comparison ignores the tolerance of pain
20:15:33 <xnull_> he's not saying to literally find a person who uses java and didn't take high school math (though i know of truckloads of people who are exactly this type of person)
20:15:41 <benbangert> someone that has learned a programming language has learned a certain tolerance for computer things not working
20:15:55 <benbangert> someone that has never learned a language at all, its hard to convince them to stick with it
20:16:35 <xnull_> benbangert: it's deliberately ignoring that tolerance
20:16:37 <Lokathor> by that argument, no one can learn any programming language, because what you say is not restricted to Java
20:16:52 <xnull_> Lokathor: no, that's not a reasonable conclusion
20:16:53 <Lokathor> er, is not restricted to Haskell, i mean
20:16:57 <benbangert> Lokathor: agreed, the only thing that makes it tolerable is that its easier to find a community of fellow sufferers
20:17:06 <benbangert> ie, there are more ppl suffering
20:17:07 <xnull_> ???
20:17:10 * xnull_ leaves
20:17:29 <benbangert> xnull_: I know, programming is pain.
20:17:42 <xnull_> [COGNITIVE DISSONANCE INTENSIFIES]
20:18:09 <benbangert> if you don't think computers and programming lead to pain, try and program a distributed system
20:18:14 <Lokathor> xnull_, I'm saying that the argument "you can't learn haskell first because learning a language is hard" also implies "you can't learn java first because learning a language is hard"
20:18:41 <Lokathor> benbangert, a distributed system is far from beginner level work
20:18:43 <xnull_> Lokathor: AFAIK he didn't say "can't"
20:18:59 <xnull_> and AFAIK that wasn't what he was saying
20:19:03 <xnull_> whether he thinks so or not
20:19:06 <benbangert> Lokathor: oh, sorry, I didn't mean to compare those. I was just saying someone that had suffered Java first, would be able to learn haskell faster than someone who had never suffered Java
20:19:15 <xnull_> ^
20:19:20 <Lokathor> well, "can't" "shouldn't", all the fuzzy sort of same
20:19:32 <xnull_> Lokathor: except none of that was at all what he was saying
20:20:05 <benbangert> if you have already suffered some to learn one language, you realize that you might learn something truly delightful for your suffering, it makes it easier to continue
20:20:48 <benbangert> so someone that already knows Java, even if you think none of the concepts are useful to Haskell (I think some are), the person that did learn Java would still have an easier time learning Haskell than someone that had never learned any programming language
20:21:12 <xnull_> benbangert: i think all concepts from Java are useful knowledge for a Haskell programmer
20:21:20 <benbangert> xnull_: agreed
20:21:38 <benbangert> type classes are awfully similar in many respects to interfaces, types translate pretty cleanly, etc.
20:21:39 <xnull_> though i disagree
20:21:43 <xnull_> with what you are saying
20:22:10 <xnull_> i think someone with experience in certain math disciplines and no experience in java would have an easier time with haskell than someone who only knows java
20:22:23 <benbangert> it'd be lovely to find some of these theoretical audiences
20:22:34 <xnull_> go out and find them. they exist all over the place
20:22:39 <Rotaerk> benbangert, interfaces are more like records of functions than like typeclasses
20:22:49 <Lokathor> gotta talk to kids that write minecraft mods or whatever but are barely in highschool
20:22:51 <benbangert> I tried telling some ppl learning haskell this exact thing, and the ppl with no prior programming experience got excited they might catch up or learn haskell faster than the already experienced programmer
20:22:56 <solatis> i know a friend of mine who is a major in math, currently works for a research institute
20:22:59 <xnull_> how many Java programmers do you know that know category theory?
20:23:01 <solatis> they only do python and node.js there
20:23:07 <benbangert> but every time, the experience imperative programmer took up haskell much more easily than the newb to programming
20:23:36 <solatis> for me, the key was slow steps
20:23:41 <solatis> c++ -> scala -> haskell
20:23:43 <xnull_> benbangert: what was the background of the newb to programming?
20:23:53 <solatis> c++ -> haskell as too big a "my brain hurts"-phase
20:23:55 <Lokathor> it is true that, as with natural language, the 2nd and more language learned has a big boost over the first
20:23:56 <xnull_> solatis: for me it was more Rust to Haskell
20:24:12 <benbangert> xnull_: background was same high school and college experience, just different work experience
20:24:23 <solatis> scala allowed me to be productive and slowly learn FP concepts
20:24:28 <xnull_> Lokathor: yes but mathematics may be considered a language
20:24:38 <frawgie> i would say that it depends more on the person itself than if he knows java or math
20:24:39 <solatis> and when i finally grasped the FP concepts, i realised scala was crap
20:24:39 <xnull_> benbangert: but what college experience exactly?
20:24:45 <benbangert> lets be honest though, no one 8 years out of high school (short of science degrees) actually remembers any math
20:24:48 <xnull_> i'm talking specifically about types, for a high school math student.
20:24:51 <benbangert> (I'm old)
20:25:01 <Lokathor> xnull_, i would assert that most people really have only a "hello world" sort of understanding of math
20:25:15 <solatis> benbangert, quick, f(x) = x^2, what is f'(x) ?!
20:25:21 <Lokathor> 2x
20:25:29 <xnull_> for learning haskell as a whole, i'm talking about a java programmer vs an academic mathematician
20:25:37 <benbangert> solatis: lol
20:25:43 <solatis> Lokathor, you must be a math major
20:25:50 <Lokathor> I am no such thing
20:25:51 <xnull_> lol sal
20:25:52 <xnull_> solatis:
20:25:59 <Lokathor> I have attempted to complete a calc book three times, and never have
20:25:59 <platz> benbangert: I took a course on differential equations in college.  I have no idea what I studied above the most basic concept
20:26:06 <Lokathor> but i do remember the power rule
20:26:15 <frawgie> xnull_: isnt the average academic mathematician a lot brighter than the average java programmer? :)
20:26:17 <platz> but still got a decent grade
20:26:23 <xnull_> frawgie: no
20:26:23 <solatis> Lokathor, yeah, and i know a^2 + b^2 = c^2
20:26:28 <xnull_> err
20:26:29 <xnull_> yes
20:26:31 <Rotaerk> I don't remember much of what I learned from college math
20:26:34 <solatis> but other than that, i forgot most of it
20:26:37 <benbangert> frawgie: that depends if the average JAva programmer has a degree in math.... ;)
20:26:39 <Rotaerk> most of it wasn't applicable to anything I do, so it was forgotten
20:26:41 <xnull_> but take two twins who grew up in the same environment
20:26:46 <xnull_> one was pushed into academic math
20:26:54 <xnull_> one was pushed into java programming and no college
20:26:56 <frawgie> benbangert: i have only met 1 so far :)
20:27:02 <shachaf> This conversation is pretty off-topic at this point.
20:27:18 <xnull_> shachaf: it's just getting to the first stage of isolation on the stack
20:27:22 <benbangert> shachaf: my topic of interest lately is https://github.com/bos/wreq/issues/57
20:27:26 <xnull_> we'll pop back up shortly
20:27:43 <dolio> Maybe you should pop now.
20:28:31 <xnull_> i can't pop
20:28:34 <Lokathor> how the flip does HUnit even work
20:28:45 <xnull_> push pop flip and shove it
20:28:59 <Lokathor> they have an example: test1 = TestCase (assertEqual for (foo 3), (1,2) (foo 3)), but the package index doesn't have a "for" function anywhere
20:29:39 <dolio> Is Control.Applicative imported?
20:29:43 <benbangert> platz: if you can remember the basic concept, thats more than what I remember of some of the college math that I learned :)
20:29:44 <xnull_> yes
20:29:46 <xnull_> dolio:
20:29:54 <xnull_> for lambdabot, not for Prelude
20:30:06 <Lokathor> dolio, uhm maybe? https://hackage.haskell.org/package/HUnit-1.2.5.2/docs/Test-HUnit.html
20:30:17 <xnull_> oh, i didn't see context
20:30:38 <Lokathor> they only list one import, they should list them all if there's secret extra imports
20:30:50 <shachaf> Lokathor: Look at the source.
20:30:52 <shachaf> https://hackage.haskell.org/package/HUnit-1.2.5.2/docs/src/Test-HUnit.html
20:30:59 <shachaf> Probably would be good to fix that documentation.
20:32:31 <Lokathor> ohhhh
20:32:35 <Lokathor> haddock is parsing it wrong
20:32:37 <Lokathor> okay
20:32:41 <dolio> Oh.
20:32:46 <benbangert> I sometimes get the impression no one writes concurrent code
20:32:54 <shachaf> benbangert: I concur.
20:33:01 * Lokathor snickers
20:33:14 <benbangert> shachaf: Nice! :)
20:33:21 <Lokathor> benbangert, how do you mean? I've got a program that uses MVars... >_>
20:33:44 <benbangert> Lokathor: yea, so does that ticket. too bad the mvar locked up the underlying connection pool
20:34:02 <benbangert> anyways, enough whining about that
20:34:33 <benbangert> Lokathor: I meant more about the issue of gauging how many things are in flight at once
20:34:56 <benbangert> Lokathor: mvar's make things safe concurrently, but not necessarilly performant
20:35:01 <Lokathor> the MVar docs fairly clearly state that you should stick to modify and not the get/set stuff if you want to use an mvar to control concurrency
20:35:18 <benbangert> sure, but there's more to it than that
20:35:37 <benbangert> btw, this is one of the areas where imperative knowledge of concurrency applies 100% in haskell
20:35:40 <narendraj9> go #fp
20:36:07 <benbangert> if you know how to think concurrently, and the various tools for concurrency. you are *way* ahead of the newb that knows only math
20:36:19 <Lokathor> well, i'm not familiar with wreq other than glancing at the readme just now
20:36:29 <benbangert> its just a wrapper on http-client for the most part
20:36:37 <benbangert> a nice one btw, I like it
20:37:13 <Lokathor> my server thing uses websockets
20:37:16 <benbangert> it just did some inefficient things with the underlying HTTP.Client Manager
20:37:23 <benbangert> yup, my server thing does too, lots and lots of websockets
20:37:40 <benbangert> hundreds of thousands of websockets
20:37:44 <Lokathor> which is kinda like just the second T in HTTP
20:37:50 <benbangert> millions shortly
20:38:07 <Lokathor> mine uses uhm... like probably 10
20:38:18 <benbangert> yea, efficiency doesn't matter much at that scale
20:38:20 <Lokathor> i mean one per user, but the userbase is expected to be small
20:38:28 <benbangert> I got one per user too
20:39:03 <Lokathor> i perhaps need to add postgreSQL support soon
20:39:45 <benbangert> Lokathor: I do wish there was something for haskell to talk to db's as nice as SQLAlchemy is for Python
20:40:14 <benbangert> some of the tooling I have for python webapps and API's is so damn nice.... there's just nothing similar for haskell :(
20:40:20 <Lokathor> right now it's just a json value stored in a file... but now i need to add a way to track users... maybe i'll be lazy and just add a second file
20:40:37 <HeladoDeBrownie> benbangert, new libraries to fill holes in functionality are usually appreciated
20:40:49 <Lokathor> HeladoDeBrownie, easier said than done :P
20:40:59 <benbangert> HeladoDeBrownie: yea, I already made those libs for the python world before I got bored ;)
20:41:02 <frawgie> benbangert: e.g.? :)
20:41:30 <HeladoDeBrownie> Lokathor, everything is easier said than done :P i said "i'd like to make a mud", and then i tried and tried and tried and i'm still working on it :P
20:42:09 <Lokathor> so it turns out "/exit" disconnects from the server instead of leaving just 1 room
20:42:10 <benbangert> frawgie: so, the tough one, and even popular frameworks/libs in many languages don't do this. but using Python + Pyramid + SQLAlchemy, its trivial to tie a HTTP request together with the database requests, in a database transaction, such that if the entire HTTP request fails for any reason, all the db activity is rolled back
20:42:13 <Lokathor> fun
20:42:39 <HeladoDeBrownie> Lokathor, for one channel it's usually /part and/or /leave
20:42:43 <benbangert> frawgie: that is a hugely powerful thing, to avoid messed up database state when the website/framework barfs halfway through rendering the page
20:42:50 <EvanR> forall a. or forall a .
20:43:26 <Lokathor> HeladoDeBrownie, here's the beginning of a MUD, https://github.com/jaspervdj/websockets/blob/master/example/server.lhs
20:43:31 <Lokathor> now just add the game
20:43:57 <frawgie> banyudu: ah, i never used pyramid though. but i see your point on this after using flask :)
20:44:04 <frawgie> benbangert: *
20:44:09 <HeladoDeBrownie> Lokathor, that's kinda neat
20:44:15 <benbangert> frawgie: most web frameworks perform each action (outside a db transaction), then start rendering the page.... if the page render throws an exception... BOOM. user hits refresh, db already got new stuff.... ugh
20:45:09 <Lokathor> HeladoDeBrownie, for my very initial testing I actually connected into my server using MUSHclient, so I know folks would be able to use a normal MUD client and all
20:45:15 <benbangert> frawgie: yea, the lib that allows it is actually independent of pyramid, it can be tied to other frameworks, but for some reason its hard to convince ppl of the need to tie the db transaction to the success of the http request/response
20:46:08 <benbangert> I could write a haskell lib that does the same thing, and it'd be a lot simpler
20:46:19 <frawgie> do it! :)
20:46:47 <benbangert> Lokathor: I tried to use that lib for a server, it had issues...
20:46:58 <HeladoDeBrownie> Lokathor, i'm currently writing one designed to work with conventional mud clients, though i had to rule out being nice to netcat because i wanted to use some telnet codes netcat doesn't render
20:47:05 <HeladoDeBrownie> render properly*
20:47:26 <Lokathor> benbangert, oh? What sort of issues? I'm attempting to build an online tabletop battle thing with said lib, akin to openRPG or Roll20
20:47:51 <benbangert> Lokathor: https://github.com/jaspervdj/websockets/issues/72, I got a warp version using snoyberg's branch with a websocket impl working without a leak though
20:48:10 <benbangert> Lokathor: I doubt that issue will be a problem unless you get really swamped though
20:48:15 <HeladoDeBrownie> come to think of it, i've yet to test it out on mushclient, but that can come later once i'm further in
20:48:29 * HeladoDeBrownie goes back to implementing registration and login
20:49:29 <Lokathor> Aardwolf has an "official" MUSHclient distribution that comes prepacked with some aardwolf specific plugins, so that's what I use
20:49:30 <benbangert> Lokathor: btw, that tweak mentioned there, to increase initial stack size per thread.... very handy
20:49:57 <benbangert> especially when you find out that ghc will grow your stack per thread in 32kb increments (by default)
20:50:38 <Lokathor> so uh, huh
20:51:35 <Lokathor> there's a cache of the server data somewhere in memory, and then that's in an MVar that all connection threads share... so how big should threads be?
20:51:45 <Lokathor> I'm confused
20:52:35 <benbangert> Lokathor: huh?
20:53:12 <Lokathor> how big should i set each thread to be initially?
20:53:27 <benbangert> Lokathor: oh, ideally large enough to handle what you're going to do in the thread
20:53:42 <benbangert> Lokathor: if you average thread takes 10kb, set initial thread size to be slightly larger
20:53:52 <benbangert> that was you avoid having ghc automatically bump it by 32kb
20:54:05 <Lokathor> well, i suppose i would need to profile that once the program becomes more stable
20:54:19 <benbangert> make a good load tester, thats the best way to check
20:54:29 <benbangert> then tweak the value a few times, see what keeps overall ram usage the lowest
20:55:12 <Lokathor> I can't really imagine us having even 100 concurrent connections any time soon, possibly any time ever
20:55:20 <benbangert> then it doesn't matter :)
20:55:33 <Lokathor> but I will keep this in mind if our userbase suddenly explodes
20:55:35 <benbangert> even if your high case was 1k connections, it doesn't matter
20:55:43 <benbangert> if it was 10k, you might start to care
20:56:09 <benbangert> my load tester is in haskell, and they start with 20k connections to open
20:57:27 <Lokathor> Roll20 had 300k users at some point in the past, but probably a fraction of that concurrently, and i'm sure not all within one server
20:58:07 <benbangert> that would be tough on one server
20:58:14 <benbangert> we can't manage more than about 160k on one server
20:58:27 <benbangert> but that server only has 7.5 GB of ram
20:58:35 <benbangert> its mainly ram constrained, unless the connections are busy
20:59:04 <benbangert> most of that per-connection cost comes from kernel tcp stack overheads too btw
20:59:33 <Lokathor> what database connection library do you use?
20:59:42 <Lokathor> there seems to be like 5 of them
21:00:02 <benbangert> none, I was hoping frawgie had a good candidate ;)
21:00:19 <benbangert> the server doesn't talk to a database at the moment, its purely a broadcast system
21:00:54 <benbangert> also, the server is written in Go, my load-test for it is written in Haskell
21:01:11 <Lokathor> ...we do oauth in Go >_>
21:01:45 <benbangert> Lokathor: https://github.com/bbangert/push-tester/ is my load-tester, if you want to see a bunch of newbish haskell. ;)
21:02:08 <Lokathor> you couldn't outnewb me I'm sure
21:02:12 <benbangert> 20k connections under load eat about 1.8GB of memory, which is ok I guess
21:02:23 <benbangert> the server has a harder time dealing with it :)
21:03:24 <benbangert> Lokathor: well, the brunt of it is under spTester
21:03:26 <Lokathor> https://github.com/Strifepad/StrifeServer
21:03:55 <Lokathor> very "I planned to fix that later probably" at the moment
21:05:13 <benbangert> Lokathor: ah, yea... there's some obvious.... wah's in there
21:05:34 <Lokathor> but it compiles!
22:46:51 <isomorphismes> What do permissions need to be for ./.ghci ?
22:47:38 <isomorphismes> I'm trying to colour the prompt and get yelled at for "./.ghci is writable by someone else, IGNORING!"
22:56:41 <glguy> isomorphismes: Try setting it to 644, user:rw, group:r, other:r
22:57:13 <hnfmr> Hi, can anyone recommend me a good Haskell FFI tutorial on the web, or book, or articles?
23:00:18 <Zemyla> @quote cmccann
23:00:19 <lambdabot> cmccann says: laziness by default is a shortcoming. eagerness by default is a bigger shortcoming.
23:18:54 <c_wraith> hnfmr: the FFI chapter of Real World Haskell is a nice start, iirc
23:20:01 <hnfmr> c_wraith: thanks
23:30:32 * hackagebot HaTeX-qq 0.0.1.0 - Quasiquoters for HaTeX  http://hackage.haskell.org/package/HaTeX-qq-0.0.1.0 (HiromiIshii)
23:34:11 <Zemyla> Why does Backwards run Applicative backwards, but not Alternative?
23:35:24 <HeladoDeBrownie> why would it?
23:35:54 <HeladoDeBrownie> often designs aren't a question of "why not" but of "why"
23:36:49 <Zemyla> So what do you need to do if you want to run Alternative backwards, like Dual does for Monoid?
23:37:49 <HeladoDeBrownie> you could write the chain of (<|>) backwards
23:37:52 <HeladoDeBrownie> you could define another newtype
23:38:37 <HeladoDeBrownie> you could compile the chain from a list that either gets reversed or is accumulated in the desired order
23:38:43 <HeladoDeBrownie> it depends on what you're trying to do really
23:38:55 <HeladoDeBrownie> do you have a use case?
23:43:44 <epichero> What would a good dev environment for someone just learning be?
23:44:27 <HeladoDeBrownie> epichero, what os do you run?
23:44:52 <epichero> osx
23:45:14 <HeladoDeBrownie> i can't give you the exact details for os x but you'll want to get ghc and cabal. you might try just installing the haskell platform
23:45:41 <HeladoDeBrownie> this is given on haskell.org https://www.haskell.org/downloads/osx
23:50:33 * hackagebot HaTeX-qq 0.0.1.1 - Quasiquoters for HaTeX  http://hackage.haskell.org/package/HaTeX-qq-0.0.1.1 (HiromiIshii)
23:55:18 <epichero> Oh, yeah I've all of that done. It looks like Emacs and EclipseFP are the options where I can have my vim keybindings but get interactive support and handholding Vim has a harder time with
23:55:36 <epichero> i guess i'll try at least those two out
23:57:54 <epichero> unless, does Leksah have vim keybinding support?
23:58:01 <HeladoDeBrownie> ah yeah, the question of which editor to use is somewhat more open
23:58:33 <HeladoDeBrownie> no idea, i decided i didn't like leksah before i could find out after i tried it
23:58:49 <HeladoDeBrownie> my favorite editor with vim keybindings is vim
23:59:28 <wolfcore> epichero: are you looking for a better haskell editor with Vim bindings?
