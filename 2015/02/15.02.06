00:00:16 <augur> actually there's a second parse path that can be tried now that i think about it, but it does very quickly
00:02:02 <augur> the way the algorithm is designed, itll try either to make the first lambda the root, or to make the + the root. the + will fail as soon as it reaches the x and discovers that that would leave a residue to the left that isn't accounted for in the parse
00:02:46 <augur> the same thing is re-tried in the lambda-first path, tho, so i guess that's a third parse path, tho that also doesn't produce a result, just an attempt
00:03:31 <augur> ive been trying to think of ways to incorporate a kind of chart into this so that that sort of redundancy isn't present in the system at all. im not sure if its possible, but if it is, it would speed it up substantially
00:04:14 <augur> EvanR_: one interesting thing about this parser tho is that its easy to let it parse "bad" inputs
00:04:58 <EvanR_> let it parse forth, and be bad
00:05:05 <augur> that is to say, you can get "best guess" parses of a certain sort
00:05:37 <augur> for instance, if you put in   `x + y z`  leaving out an op, it'll parse it as x + y with a residue of z that it doesnt know what to do with
00:06:13 <EvanR_> augur: ok and what would you tell a programmer who wrote it
00:06:41 <augur> depends on what kind of errors you want to give
00:07:13 <augur> there are also places where you can knit in some kind of "did you mean X?" recovery system
00:07:50 <EvanR_> yes what is one example of such a message
00:09:03 <augur> like, with the `x + y z` parse, because of the residue that shows up, as soon as the residue is detected, you can trigger some kind of heuristics to guess at what word is missing
00:10:19 <augur> and then you could insert a special "error" node that says this would parse if you had this word, and then you can turn that into an error message
00:10:33 <EvanR_> which would be
00:11:21 <augur> something like   "Failed to parsed: ... >>> this stuff <<< ...   ;   possible solution: ... >>> that stuff with the extra word <<< ..."
00:11:55 <EvanR_> cool
00:12:08 <augur> so like, for the `x + y z` error, maybe you return like...    "Failed to parse: ... >>> y z <<< ...   ;   Possible solution: ... >>> y + z <<< ..."
00:13:26 <augur> that could be triggered easily -- when you pick + as the root of the tree, you get a right subgoal   e   with the input string   y z   and there's no parse for y z that lacks residue
00:14:26 <augur> so you can immediately say "sorry, i couldn't find an `e` that spans all of `y z`, but maybe if you insert + or - it would work?"
00:14:42 <lf94> How would I go about creating a type, that can only be created if it meets some constraints? Example: my new type is a String, but it HAS to contain a "_" to be a valid new type
00:15:18 <barrucadu> You don't export the constructors of your type, instead requiring people to use a function :: String -> Maybe YourString
00:15:29 <augur> lf94: you cant, not without some gnarly (and frankly ugly) extensions. the best option is to use "smart constructors"
00:15:45 <augur> a smart constructor is what barrucadu is describing
00:15:55 <augur> in particular, a partial smart constructor. partial because it might fair
00:15:56 <augur> fail*
00:16:56 <augur> notice tho that there's no enforcement here, just a bunch of runtime tests. you'd need a dependently typed language to actually enforce this sort of stuff
00:18:09 <lf94> oh cool, ok
00:18:18 <xandaros> Is there a simple, platform independent way of playing a sound? Every solution I found so far either depends on the platform or is incredibly low-level
00:18:47 <xandaros> By sound I mean a sound file
00:21:38 <gamegoblin> How does Vector handle "safe destructive updates" ? What does that even mean?
00:21:42 <gamegoblin> It uses some ST voodoo
00:22:03 <gamegoblin> It says it‚Äôll do it in place if it‚Äôs safe to do so ‚Äî how does it know what‚Äôs safe?
00:22:44 <nshepperd> lf94: in the specific example of 'string containing at least one _', you could instead use (String, String) representing the part before the _ and the part after
00:23:05 <nshepperd> this method is safe, but maybe not convenient
00:23:34 <augur> nshepperd: as inputs, you mean
00:23:44 <augur> nshepperd: smartConstructor pre_ post_
00:24:14 <lf94> nshepperd, I'm writing a program that converts between cheat code formats. I'm trying to differentiate between formats by creating my own types with those restrictions
00:24:43 <lf94> For example, I have PJ64Cheat
00:24:51 <lf94> But it is really just a string
00:25:11 <lf94> hm
00:26:04 <nshepperd> augur: well, as a general representation of such a type. (String,String) is isomorphic to 'strings containing at least one _'
00:26:34 <nshepperd> but yeah I think in general the way to handle what lf94 is doing is just to create lots of newtypes of String
00:26:55 <nshepperd> if it's just "different categories of things"
00:26:58 <augur> nshepperd: yes :)
00:27:09 <lf94> yeah
00:27:16 <lf94> it's just different categories
00:27:32 <lf94> why newtype? why not just type? or data?
00:27:43 <lf94> i know newtype is not lazy vs data is lazy
00:28:01 <lf94> but if i just want categories isnt type sufficient
00:28:04 <shachaf> You can use data. No big difference here.
00:28:25 <shachaf> type defines a synonym, not a new type. It's like #define, not something the type checker will catch.
00:28:36 <lf94> oh
00:28:40 <lf94> ok gotchya
00:29:02 <Cale> I just got confused by the non-technical use of the word "categories"
00:29:04 <Cale> lol
00:29:25 <shachaf> Eh, they're just discrete categories.
00:30:01 <lf94> so what would my data statements look like? I was thinking just: data PJ64Cheat = String
00:30:06 <Cale> You can think of data types as better than discrete categories -- they're preorder categories using the definedness relation :)
00:30:12 <Cale> and computable functions are functors
00:30:39 <lf94> But how would I convert say, an array of strings to a list of PJ64Cheats?
00:30:46 <shachaf> Hah, fair enough.
00:30:58 <lf94> toPJ64Cheat :: String -> PJ64Cheat ?
00:31:12 <lf94> toPJ64Cheat a = PJ64Cheat a
00:31:23 <lf94> or is it way more than that
00:31:48 <nshepperd> lf94: data PJ64Cheat = PJ64Cheat String
00:32:51 <lf94> nshepperd, ah, i wasn't sure if that was valid.
00:32:57 <lf94> thanks for all the help!
00:50:59 * hackagebot tellbot 0.4.0.4 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.4.0.4 (DimitriSabadie)
00:59:41 <mjrosenb> does anyone know where ghc-pkg looks for installed packages?
01:00:01 * mjrosenb is not feeling up to stracing tonight.
01:00:24 <shachaf> Doesn't `ghc-pkg list` tell you the paths?
01:02:48 <mjrosenb> shachaf: derp, so it does.
01:03:18 <mjrosenb> so haskell-gtk has been installed on my system via arch, but it appears as if it never registered itself?
01:16:01 * hackagebot tidal-midi 0.0.1 - MIDI support for tidal  http://hackage.haskell.org/package/tidal-midi-0.0.1 (AlexMcLean)
01:16:05 <lf94> hoogle is awesome
01:34:51 <bqjpin> !ciao
01:34:53 <bqjpin> !list
01:34:53 <monochrom> bqjpin: http://hackage.haskell.org/packages/archive/pkg-list.html
01:41:25 <phaazon> is there a 4b Int?
01:41:37 <phaazon> Word16 is an unsigned int on 2b
01:41:44 <phaazon> 2B*
01:41:50 <phaazon> and I need an Int on 4B
01:42:32 <ClaudiusMaximus> Int32 ?
01:42:57 <ClaudiusMaximus> Word32 for unsigned
01:43:32 <phaazon> thank you :)
01:51:12 <augur> EvanR_: ive almost got a chart-based version designed :)
01:51:55 <mniip> why is [0,0.. -1] an empty list, and [0,0..1] is not?
01:52:43 <augur> EvanR_: ive almost got a chart-based version designed :)
01:52:45 <augur> ((in case that didnt go through before -- i got kicked off irc for some weird reason))
01:53:51 <augur> EvanR_: i suspect im very nearly designing a lexicalized earley parser
01:57:19 <jameseb> mniip: I guess it just checks if it's greater than or equal to the last value
01:57:31 <mniip> that's signist :/
01:57:52 <jameseb> -1 < 0 anyway so it doesn't bother computing the next value
01:58:24 <jameseb> whereas it keeps adding 0 and never reaches 1 in the second case
01:58:44 <mniip> well, as x->-0, [0,x.. -1] -> [0,0..]
01:59:38 <jameseb> > [0,1.. -1]
01:59:40 <lambdabot>  []
01:59:51 <mniip> x->-0
01:59:52 <mniip> not +0
02:00:05 <jameseb> ah, okay
02:00:17 <jameseb> > [0,-1.. -1]
02:00:18 <lambdabot>  [0,-1]
02:00:39 <jameseb> hmm..
02:00:44 <jameseb> > [0,-1.. -2]
02:00:45 <lambdabot>  [0,-1,-2]
02:00:56 <jameseb> okay, that doesn't make sense
02:01:03 <mniip> more generally speaking, enumFromThenTo returns an empty list if then>from>to or then<from<to
02:01:06 <ClaudiusMaximus> > [0, negate 0 .. -1] :: [Double]
02:01:07 <lambdabot>  []
02:01:26 <mniip> > 0 <= negate 0
02:01:28 <lambdabot>  True
02:01:32 <mniip> there's your problem
02:11:06 * hackagebot amqp-conduit 0.1.0.1 - Conduit bindings for AMQP (see amqp package)  http://hackage.haskell.org/package/amqp-conduit-0.1.0.1 (toru_tomita)
02:12:09 <zipper> Doesn't Data.Map come with Base? Emacs tells me that it comes from Containers?
02:12:28 <zipper> Could the two be exporting a module with the same name?
02:12:31 <bergmark> zipper: it's in containers
02:12:49 <bergmark> zipper: they could, but they're not :)
02:12:50 <zipper> bergmark: Wow I really thought otherwise. :<
02:12:58 <zipper> bergmark: haha yeah
02:14:44 <bartavelle> if someone has a quick answer for errors like "can't load .so/.DLL for: libHSprimitive-0.5.4.0." before I start digging, I would be grateful
02:15:17 <merijn> bartavelle: Compiled on the same machine you're running?
02:15:31 <bartavelle> yeah
02:15:35 <bartavelle> just upgraded ghc
02:15:43 <merijn> bartavelle: There's not really any quick answer beyond "it's can't find the library you build stuff with"
02:15:56 <merijn> bartavelle: upgraded? how?
02:16:01 <bartavelle> I build with --disable-shared, so it's annoying
02:16:23 <bartavelle> downloaded new version, rm -rf ~/.ghc ~/.cabal, installing the packages I always want available in ghci
02:16:59 <merijn> Is the ghci you're running the right version?
02:17:16 <bartavelle> well I'm not running it yet, those are cabal install errors
02:17:22 <merijn> I have no clue where you installed it. If you're running the old version it obviously can't find the library
02:17:30 <bergmark> bartavelle: things like that pop up for me every now and then seemingly by random, cleaning dist folders usually solves it for me
02:17:53 <merijn> bartavelle: oh, wait, so you nuked ".ghc" and ".cabal" and running cabal gets those errors?
02:18:06 <bartavelle> merijn, only for some packages
02:18:11 <bartavelle> most of them build fine
02:18:14 <bartavelle> bergmark, did that twice :(
02:18:59 <merijn> "ldd path/to/cabal" ?
02:19:04 <Runner> wo At who like this game ? https://www.youtube.com/watch?v=rSAAdKE84Ts
02:19:15 <bartavelle> my current guess is that it believes it should build with shared libs whereas none of them are built that way
02:19:43 <bartavelle> merijn : I have no native linking problem, cabal runs fine
02:19:59 <bartavelle> it's when ghc is linking that it fails
02:20:05 <augur> EvanR_: got it! :D
02:20:31 <ironChicken> i'm trying to get started with Gtk2Hs and I've found mention of "window `on` deleteEvent $ ..." in place of onDestroy
02:20:34 <merijn> bartavelle: Is the cabal file of that package maybe overriding the settings for shared libs?
02:20:34 <ironChicken> but I can't find where that "on" function is defined
02:20:42 <merijn> @hoogle on
02:20:49 <ironChicken> merijn: tried that
02:20:49 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
02:20:49 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
02:20:49 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
02:20:59 <bartavelle> perhaps, although I don't think this should be possible for this particular setting :( I'll start digging
02:21:02 <merijn> ironChicken: Not hard enough ;) It's the first one ;)
02:21:06 <ironChicken> oh ok. i was assuming it was something from Gtk2Hs
02:21:26 <ironChicken> thanks
02:21:28 <ironChicken> and sorry
02:21:33 <merijn> bartavelle: Also, what is your cabal config for shared?
02:21:45 <merijn> ironChicken: You should remember on, it's a great function :)
02:21:54 <bartavelle> shared: False
02:22:07 <ironChicken> merijn: i'll write it on my desk ;-)
02:22:18 <bartavelle> seems like it happens during template haskell
02:22:27 <bartavelle> humm
02:22:49 <merijn> bartavelle: Oh!
02:22:58 <merijn> Pretty sure TH require dynamic linking
02:23:12 <merijn> So, uh, sux to be you? >.>
02:23:13 <bartavelle> ok then
02:23:22 <bartavelle> I'll just reenable shared and pray for the best
02:23:23 <bartavelle> thanks
02:23:41 <merijn> bartavelle: Is there any reason you didn't just leave it with the default settings?
02:23:52 <tomphreek> @hoogle [t] -> [[t]]
02:23:55 <bartavelle> I like new things, but I fear them too
02:23:57 <lambdabot> Data.List inits :: [a] -> [[a]]
02:23:57 <lambdabot> Data.List permutations :: [a] -> [[a]]
02:23:57 <lambdabot> Data.List subsequences :: [a] -> [[a]]
02:24:36 <merijn> bartavelle: GHC still defaults to static by default, afaik
02:24:51 <bartavelle> how could anything work then ?
02:25:18 <merijn> bartavelle: But ghci/TH need it (this is all work aimed at using the system linker instead of GHC's own linker to eliminate a bunch of longstanding bugs)
02:25:26 <merijn> bartavelle: tbh, I'm not TOO aware of the details
02:25:48 <merijn> I just know ghci doesn't work on systems without dynamic linking. But unless you build GHC yourself you probably got a dynamic ghci anyway?
02:26:09 <bartavelle> I downloaded the binary distribution of ghc yes
02:26:22 <augur> this algorithm is interestingly similar to the merge sort algorithm..
02:26:28 <merijn> Right, that's already build dynamically (or both dynamic and static)
02:26:31 <merijn> augur: Which one?
02:26:33 <augur> how strange!
02:26:44 <augur> merijn: i invented a new parsing algorithm :)
02:27:51 <bartavelle> that sounds strange indeed
02:27:56 <zipper> When I run an import like `import qualified Data.Map as M` and when I do it like `import qualified Data.Map ()`
02:28:35 <zipper> When I import the latter HLint says I import only instances. Isn't this what I was doing even with a qualified import?
02:28:42 <merijn> zipper: No
02:28:57 <zipper> Also how will I call functions imported in `().lookup`
02:28:58 <merijn> zipper: The former imports everything, but using "M" as a prefix
02:29:09 <merijn> zipper: The latter doesn't have an "as"
02:29:13 <phaazon> what‚Äôs the runtime cost of pokeByteOff?
02:29:24 <bartavelle> zipper, notice you didn't use "as" in the second case
02:29:28 <merijn> zipper: The former is aliasing "Data.Map" to M and importing everything with that prefix
02:29:38 <zipper> s/`().lookup`/`import qualified Data.Map ()`/
02:29:51 <merijn> zipper: The latter is importing an empty import list with the "Data.Map" prefix
02:29:51 <bartavelle> merijn, this works well when I don't try to be smart and mess with the defaults
02:30:02 <bartavelle> so I should not disable shared
02:30:31 <mniip> guys I have a few questions
02:30:35 <augur> bartavelle: :) yes, very strange!
02:30:41 <zipper> merijn: Can't I have a one letter prefix in the latter case?
02:30:42 <mniip> 'minBound' is ambiguous
02:30:59 <mniip> 'fix id minBound' is ambiguous
02:31:05 <bartavelle> augur, in case I didn't hint hard enough, you owe use some explanation now you made such a claim !
02:31:08 <mniip> why the hell is 'show minBound' not ambiguous
02:31:15 <merijn> bartavelle: The only defaults I usually mess with is "optimization: 2",  "library-profiling: True" and "documentation: True"
02:31:24 <merijn> mniip: Extended defaulting
02:31:24 <jle`> mniip: built-in defaulting rules
02:31:34 <augur> bartavelle, merijn: the structure of the algorithm abstractly is like this:   pick a word from the input word list, split the list by that word, and recursively sort the two halves, then combine these into a tree
02:31:35 <merijn> mniip: Use -Wall and it'll complain about "show minBound" too
02:31:38 <bartavelle> oh god I didn't enable documentation ... I knew I missed something
02:31:56 <merijn> No docs is such a stupid default...
02:32:07 <merijn> Why haven't I yelled at Duncan to changed that yet?
02:32:11 <zipper> merijn: I think I see what you mean. This way it's able to inline my imports at compile time.
02:32:14 <merijn> Hell, why is profiling disabled by default
02:32:26 <merijn> zipper: This has nothing to do with inlining, etc.
02:32:37 <merijn> zipper: Also, you totally can have a one letter prefix in the latter case
02:32:47 <zipper> merijn: Then why are we doing it?
02:32:48 <augur> bartavelle, merijn: both algos are very similar then. both are "split in half, recurse, combine"
02:32:59 <jle`> import qualified Data.Map (blah, bah) as M
02:33:01 <bartavelle> how do you parse like that ?
02:33:09 <bartavelle> it's not a generic parser I recon
02:33:19 <merijn> "import qualified Data.Map as M ()"
02:33:24 <jle`> oops
02:33:26 <jle`> :)
02:33:27 <augur> bartavelle: like this: https://twitter.com/psygnisfive/status/563481614051966977
02:33:30 <merijn> zipper: Doing what? The naming?
02:33:38 <merijn> jle`: I had to google the report for that :p
02:33:59 <zipper> merijn: importing only instances of it i.e using brackets.
02:34:12 <jle`> i just do it until my syntax highlighter is happy haha
02:34:29 <Runner> 6d ur At who like this game ? Is a shit game this https://www.youtube.com/watch?v=rSAAdKE84Ts
02:34:30 <bartavelle> augur, I guess I am not knowledgeable enough to understand this ! I'll try to avoid this rabbit hole today as I still have much on my plate
02:34:38 <dcoutts_> merijn: until we can automatically add prof or docs later, we're have an unfortunate tension on those options, there's costs both ways
02:34:38 <augur> bartavelle: :)
02:34:50 <merijn> zipper: Well, GHC has to know a typeclass exists before you can use it :)
02:34:55 <augur> bartavelle: suffice it to say, im happy :)
02:35:06 <bartavelle> hÈhÈ
02:35:16 <merijn> dcoutts_: I'd say having the off by default is most harmful to those least likely to know it's a problem (i.e. newcomers)
02:35:26 <merijn> dcoutts_: Whereas people who complain it's too slow can easily turn it off
02:35:30 <Runner> 3n ur At who like this game ? Is a shit game this https://www.youtube.com/watch?v=rSAAdKE84Ts
02:35:59 <zipper> merijn: I mean what are the advantages of `import Data.Map ()` over `import Data.Map`
02:36:11 <dcoutts_> merijn: it's not just a decision for me btw, given that it's a tradeoff for many many users it's something that should be discussed and decided more collectively
02:36:21 <merijn> zipper: It doesn't import the functions inside "Data.Map", so you don't get name clashes
02:36:45 <merijn> dcoutts_: ezyang's work should help with adding profiled versions later, right?
02:36:49 <mjrosenb> question: is there a FRP library based on push-pull?
02:37:07 <dcoutts_> merijn: only very indirectly
02:37:15 <zipper> merijn: Now that you say it seems so obvious. Thanks
02:37:25 <jle`> mjrosenb: the modern torch bearers of push-pull are sodium and reactive-banana
02:37:37 <merijn> mjrosenb: I think reactive is based on it? There's still some performance issues with it, afaik
02:37:54 <mjrosenb> jle`: ok, so I'll need to get reactive-banana working!
02:37:57 <merijn> mjrosenb: reactive-banane is more practically usable, but slightly more complex interface to use
02:38:19 <merijn> mjrosenb: It depends, reactive-banana is very heavily focussed on some use cases (i.e. working with external callback based systems)
02:38:33 <jle`> i think the sodium people are putting a lot of effort into making it a usable api for real world stuff
02:38:39 <merijn> netwire is more focussed on FRP (not sure it implements push-pull atm) where you control all primitives
02:38:40 <jle`> the have ported the library to many languages
02:39:06 <mjrosenb> jle`: yeah, I think I installed it, then couldn't get the examples to compile.
02:39:13 <jle`> and it doesn't requier everything to "exit" in a single type at the end...i just know luite has used it to some nice effects with ghcjs
02:39:26 <jle`> netwire is FRP but it is distinctly non push-pull
02:40:11 <jle`> mjrosenb: ah, unfortunate
02:40:52 <mjrosenb> Ideally, I'm looking for something I can bolt onto sdl + a nice rendering library, possibly cairo?
02:41:16 <mjrosenb> iirc, there is a reactive-banana-sdl package, but last I had some issues building it.
02:41:19 <jle`> things like GUI are best with ppfrp
02:41:31 <jle`> hm
02:41:52 <jle`> is it the SDL part,or the reactive-banana part?
02:42:07 <jle`> btw, are you on #haskell-game? :)
02:42:21 <mjrosenb> jle`: not yet.
02:43:22 <mercwithamouth> .
02:45:54 <jle`> mjrosenb: you might be able to get some help there for questions like this :)
02:45:57 <jle`> in the future
02:47:13 <mjrosenb> jle`: noted.
03:06:46 <zipper> Having a small issue. With `import qualified Data.Map as M ()` I can't e.g M.lookup
03:07:01 <mniip> remove ()
03:07:50 <pjdelport> zipper: The "qualified" already prevents importing the names unqualified.
03:08:32 <zipper> mniip: If I do that Hlint implies that it's bad practise and I should import it with ().
03:08:36 <zipper> pjdelport: ^
03:08:41 <mniip> import qualified Data.Map as M (lookup)
03:09:21 <Cale> zipper: I think I'd call that a bug in hlint
03:09:41 <Cale> zipper: Suggesting that you import nothing at all from the module seems dumb
03:09:54 <Cale> (well, nothing apart from instances)
03:10:43 <mpickering> it probably means you have a duplicate import? zipper
03:13:08 <In-Runner> 3n Is true that Bill Gates is gay ?
03:16:12 * hackagebot amqp 0.12 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.12 (HolgerReinhardt)
03:26:50 <mjrosenb> uh-oh, wxc seems to want wxgtk-2.9
03:26:58 <mjrosenb> but this doesn't exist?
03:43:05 <HugoDaniel> hi
03:45:11 <HugoDaniel> what is "the best way" to split a text like "asdf;bsdf;csdf;dsdf" into MyData Text Text Text Text like MyData asdf bsdf csdf dsdf ?
03:47:21 <chrisdone> Data.Text.split?
03:48:04 <bennofs> HugoDaniel: case (splitOn ";" "<...>") of [a,b,c,d] -> MyData a b c d;  _ -> <what to do if wrong number of elements>
03:49:10 <HugoDaniel> yes that is my solution, using split and the pattern match, i was hoping there might be some magic hidden haskell stuff i might be forgetting
03:49:28 <HugoDaniel> or something like a "UnBuilder" super data type that avoids the creation of a intermediate list
03:49:31 <HugoDaniel> or whatever
03:49:33 <HugoDaniel> :/
03:51:14 <HugoDaniel> thanks
03:52:17 <MP2E> well if the list only exists intermediately GHC will probably fuse it out
03:59:58 <EvanR_> types dont exist at runtime, often lists dont exist at runtime, cant wait until 7.10 when nothing will exist at runtime ;)
04:00:53 <EvanR_> my least favorite time
04:03:28 <jameseb> on a related note, is there a simple way to do Array (Int,Int) a -> [[a]]?
04:06:17 * hackagebot hindent 4.3.8 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.8 (ChrisDone)
04:08:06 <merijn> jameseb: assocs + clever use of groupBy?
04:08:50 * ski was pondering `bounds',`range',`(!)'
04:10:34 <mniip> is there some typeclass like Enum but with Integer?
04:10:51 <merijn> Eh, what do you mean by that?
04:11:05 <jameseb> merijn: that might work if I use equality on the second index, thanks!
04:11:28 <mniip> :t fromEnum
04:11:29 <lambdabot> Enum a => a -> Int
04:11:34 <mniip> what if my enum doesn't fit in an Int
04:12:57 <mniip> it's an infinite but enumerable datatype, and values larger than 'toEnum maxBound' are not uncommon
04:13:00 <mcjohnalds> When I run `error "oops!"` it prefixes my error message with "myprogramname: ", e.g `error "oops!"` prints "myprogramname: oops!". What's the best way to stop this behaviour?
04:13:24 <merijn> mcjohnalds: You really shouldn't use "error" for error reporting :\
04:13:32 <merijn> mcjohnalds: They're hard to catch later on
04:13:33 <mniip> mcjohnalds, what other behavior do you propose
04:14:11 <mcjohnalds> merijn: I am a terrible person and I know it. But I just want `error "oops!"` to print "oops!" not "myprogramname: oops!"
04:14:21 <merijn> mcjohnalds: There's a global handler, but the right thing to do would be to handle errors more appropriately, that is, either using Maybe/Either or using exceptions
04:15:04 <angerman> Say data B = B  { _key :: Int, _value :: String }, data A  = A { _items :: [B] }. Assume an instance of A with a non empty set of items. Can I use lenses to extract the first matching items value for say the key: 4?
04:15:19 <Procian> merijn: I still use it for buggy paths that I don't intend to catch, because the path is supposed to be impossible.
04:15:25 <merijn> HugoDaniel: Eh, you mean like attoparsec? :p
04:15:42 <mcjohnalds> global handler? Like, just use a catch in my main function
04:15:54 <angerman> Something similar to: select value from A.items as B where B.key = 4.
04:16:07 <merijn> HugoDaniel: Attoparsec has combinators for "takeWhile :: (Char -> Bool) -> Parser Text" (i.e., it splits of large chunks of Text in one go
04:16:12 <mniip> mcjohnalds, consider switching to Either
04:16:46 <merijn> Procian: You're actually better of not using error, since a missing case will trigger GHC to also print the file/line where it failed
04:17:19 <mcjohnalds> mniip: I will, but I need this for debugging purposes before I can set up nicer error handling
04:17:55 <merijn> mcjohnalds: No, there is a global handler outside main (not a function, incidentally) that gets run if errors are uncaught
04:18:05 <merijn> But "error" is hard to catch even when using a a handler
04:18:28 <Procian> merijn: Yeah, but I like to insert rude and belittling messages to myself (plus possibly constructive criticism if I'm feeling kind)>
04:18:36 <mcjohnalds> is there a way to access this global hander?
04:18:56 <merijn> mcjohnalds: Yeah, but I forget how, look in Control.Exception or some of the GHC base libraries
04:19:37 <mcjohnalds> merijn: Ok thanks! I promise I won't pollute hackage with use of `error`
04:22:43 <merijn> Actually, for debugging 7.10 will have a nice improvement for these type of error reports
04:22:52 <lpaste> gregnwosu pasted ‚Äúcabal trouble‚Äù at http://lpaste.net/120075
04:23:07 <merijn> Just use typed holes together with -fdefer-typed-holes for low effort, easy to find debug errors :>
04:23:09 <gregnwosu> can anyone help
04:23:30 <gregnwosu> im getting a weird error when im trying to install a dependency from cabal
04:23:42 <merijn> gregnwosu: Looks like the author of wreq has a dependency error
04:24:04 <merijn> i.e. it's trying to use an incompatible version of lens due to the author messing up the dependency bounds
04:24:25 <gregnwosu> merijn: eek , i didnt specifiy the version of lens
04:24:35 <gregnwosu> perhaps if im stricter it may work
04:26:04 <merijn> 4.7 doesn't export defaultRules but wreq specifies lens >=4.1
04:26:13 <merijn> So if cabal selects 4.7 it will fail
04:27:15 <merijn> It appears to have been removed in lens-4.4
04:27:27 <merijn> So try constraining to lens <= 4.4
04:27:29 <merijn> eh
04:27:33 <merijn> < not <=
04:27:41 <gregnwosu> lol yeah thanks
04:28:22 <gregnwosu> merijn: how do you figure that out so quick
04:28:26 <gregnwosu> where did you look?
04:29:25 <merijn> gregnwosu: Well, the error right there says it can't find defaultRules in Control.Lens.TH, so go to wreq hackage page, look at dependency bounds, click through to lens, open lens docs for 4.1, check that it's there
04:29:34 <merijn> Click on 4.7 lens docs, see that it's not there
04:29:37 <merijn> Problem found :p
04:30:00 <gregnwosu> thanks
04:30:11 <mniip> mcjohnalds, uh
04:30:17 <mniip> what are you using to catch the error
04:30:25 <gregnwosu> i know its a stupid question , but im not familiar with diagnosing those kind of problems
04:30:39 <mcjohnalds> Just, catch it works fine now as a quick n dirty solution
04:30:46 <mniip> I've tried
04:30:48 <mniip> catch (error "hi") (print :: SomeException -> IO ())
04:30:52 <mniip> it just prints "hi"
04:30:56 <mniip> no extra information
04:32:47 <mcjohnalds> Yea, I wanted to use `error` for debugging purposes to propogate an error to main and crash the program. I didn't realise I could just catch all the errors!
04:33:01 <mcjohnalds> So thanks!
04:33:39 <merijn> mcjohnalds: Except...you can't catch all of them like that.
04:34:08 <merijn> mcjohnalds: error is lazy, so it only throws when forced, so they can escape the catch
04:34:49 <mcjohnalds> Oh yea I really should have mentioned I'm calling from within IO
04:35:08 <merijn> Then use throwIO
04:35:11 <merijn> :t throwIO
04:35:12 <lambdabot> Exception e => e -> IO a
04:35:35 <merijn> throwIO will *force* the error to be thrown right when you call it, making it impossible to leak accidentally
04:35:57 <merijn> Then you can reliably use catch and friends from Control.Exception to handle them
04:37:20 <mcjohnalds> Oh yea I'm just using `error` as a quick and dirty solution, like `when foo (error "oops!")`
04:37:49 <mniip> when suggests a monadic context
04:38:19 <mniip> perfect place for throwIO
04:39:37 <mcjohnalds> Yea `error` is just a nice solution b.c throwIO forces you to make an `instance Exception MyException`
04:40:41 <mniip> you can use one of the existing exceptions
04:40:53 <mniip> like ErrorCall
04:42:12 <mcjohnalds> Oh, I didn't notice Exception already has some handy instances
04:44:18 <mcjohnalds> "This is thrown when the user calls error." I guess using `throw (ErrorCall ...)` would be effectively equivalent to just calling error
04:45:09 <mniip> one is IO and one is not
04:47:38 <mcjohnalds> If you just do something like `do {someBool <- hasFailed; when hasFailed (error "oops!")}` wouldn't that be just like calling throwIO b.c error "oops!" would have the type IO ()
04:48:56 <merijn> You want "throwIO (ErrorCall ...)" which is different from error
04:50:19 <mjrosenb> Is it possible to ask cabal install foo to use a particular set of CXXFLAGS?
04:52:04 <dcoutts_> mjrosenb: worth a go with the --gcc-options and perhaps --ghc-options=-optc
04:52:18 <mcjohnalds> I'm not sure what you mean, error can have any type, including IO (), which would be evaluated just like throwIO
04:52:37 <merijn> mjrosenb: Doesn't make a lot of sense, because cabal doesn't build C++ code
04:54:11 <dcoutts_> merijn: actually it will if you list c++ files in the c-files section
04:54:32 <mjrosenb> merijn: https://gist.github.com/e3b8d0adfc9fea0beb33
04:55:04 <bartavelle> you can even change the options with the "cc-options" parameter
04:55:20 <bartavelle> not sure how it handles c++ though, only worked with plain c
04:56:02 <merijn> dcoutts_: I remember trying that and it not working
04:56:15 <merijn> dcoutts_: Does it only work for specific extensions?
04:56:35 <dcoutts_> merijn: ghc used not to accept cpp files, but now it does
04:56:39 <dcoutts_> so some things work apparently
05:04:53 <thomas_athorne> \quit
05:08:13 <chaii> ...
05:20:20 <muzzle> hi,i have a question: what is the most efficient solution to find the start and stop position of a pattern (attoparsec/some regex) in a very long unicode text ?
05:21:13 <mpickering> what's the overall problem you are trying to solve
05:22:17 <muzzle> i want to write a module for highlighting syntax
05:22:30 <muzzle> and for that i have to find region delimiters
05:22:37 <merijn> muzzle: Using attoparsec's skipWhile is really efficient
05:22:39 <muzzle> that can be some form of pattern
05:23:08 <muzzle> but that does not really give me positional information
05:23:22 <muzzle> i could probably get that from the result lengths somehow
05:23:29 <muzzle> but doesn't this hog memory ?
05:24:11 <pacak> muzzle: It can work incrementally
05:24:15 <merijn> How big a unicode text do you plan to scan?
05:24:35 <merijn> kilobytes, megabytes, gigabytes, terabytes?
05:24:54 <muzzle> up to a few 100 megabytes would be best
05:24:55 <pacak> I'm using it to process gigabytes of data on a daily basis, works in constant memory.
05:25:36 <merijn> muzzle: I really wouldn't worry about the memory hogging then
05:26:18 <muzzle> ok, then i'll try that. Because i played around with doing it in some sort of fold and that was just *awful* memory and time wise
05:26:55 <merijn> muzzle: foldl by any chance?
05:27:04 <muzzle> Text.foldl'
05:27:40 <merijn> Ah, although foldl is still likely the wrong kind of fold, anyway skipWhile is basically a tight for loop over an array
05:31:22 * hackagebot wrap 0.0.0 - Wrap a function's return value with another function  http://hackage.haskell.org/package/wrap-0.0.0 (ChrisDone)
05:32:07 <muzzle> hmm skip while would probably not really solve my problem either, if i want to have delimiters that are longer than one char, right ? wouldn't that require manyTill ?
05:34:10 <pacak> muzzle:  p = (delim *> stuffParser) <|> (anyWord  *> p)
05:37:33 <bananagram> @pl \f x -> (x, f x)
05:37:33 <lambdabot> ap (,)
05:37:40 <bananagram> @pl \x f -> (x, f x)
05:37:40 <lambdabot> liftM2 (.) (,) (flip id)
05:40:06 <bananagram> `flip id` is extremely confusing
05:42:09 <cmtptr> flippid
05:43:47 <mniip> `flip id` is just flip ($)
05:43:59 <mniip> because $ is id
05:44:08 <kranius> @type flip id
05:44:08 <lambdabot> b -> (b -> c) -> c
05:44:11 <chpatrick> bananagram: it unifies a -> a with b -> (c -> d), so a == (c -> d), so it's flip (id :: (c -> d) -> c -> d), which is :: c -> (c -> d) -> d
05:44:22 <Zoetrope> That's amazing haha
05:46:41 <jtanguy> bananagram: there is also (&&&) from Control.Arrow
05:47:01 <Zoetrope> yeah that's what I was thinking, flip (id &&&)
05:47:02 <bananagram> :t (&&&)
05:47:03 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
05:47:15 <arw_> mniip: $ really is id?
05:47:20 <mniip> :t ($)
05:47:21 <lambdabot> (a -> b) -> a -> b
05:47:23 <mniip> :t id
05:47:24 <lambdabot> a -> a
05:47:32 <mniip> see the resemblance
05:48:01 <arw_> yes, its similar. but not the same, is it?
05:48:16 <blueonyx> :t flip id
05:48:17 <mniip> well, you can't use infix `id`
05:48:17 <lambdabot> b -> (b -> c) -> c
05:48:28 <mniip> I think
05:48:44 <arw_> yes, but thats only syntax. why are the types different/
05:48:49 <Zoetrope> $ is a subtype of id
05:48:51 <mniip> and you can't use $ in place of id
05:48:52 <chpatrick> > show `id` 3
05:48:54 <lambdabot>  "3"
05:48:55 <chpatrick> :D
05:48:57 <mniip> oh you can
05:49:10 <chpatrick> it shouldn't work the other way around though, $ is less general
05:49:16 <mniip> yeah
05:49:19 <Zoetrope> $ is just a specialization of id
05:49:26 <mniip> precisely
05:49:38 <arw_> okay, that I understand
05:50:02 <jtanguy> > (id &&& (+3)) 4 -- bananagram
05:50:04 <lambdabot>  (4,7)
05:57:52 <zq> what no
05:58:04 <zq> Zoetrope: no, ($) is defintie not a specialization of id
05:58:07 <zq> definitely
05:59:33 <zq> never mind, it is!
06:03:13 <kqr> hey awesome people! i'd like a "flip Control.Foldl.fold"... does anyone know if that already exists?
06:08:00 <cmtptr> how does one debug a haskell program?
06:08:39 <Taneb> cmtptr, divide it into small functional units
06:08:40 <cmtptr> I clearly don't have a good understanding of how this thing evaluates, so in an imperative message I'd add some print statements to trace the program flow
06:08:52 <Taneb> Also Debug.Trace if you're careful
06:08:53 <cmtptr> s/message/language
06:08:57 <mniip> @hoogle Debug.Trace.trace
06:08:59 <lambdabot> Debug.Trace trace :: String -> a -> a
06:08:59 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
06:08:59 <lambdabot> package trace-call
06:09:28 <mniip> 'join traceShow' is also useful at times
06:10:09 <kqr> cmtptr, I usually don't care about how something evaluates. all I care about are if the results are correct
06:10:21 <kqr> cmtptr, if they aren't, I look at which of the sub-expressions generate an incorrect result
06:10:23 <mniip> kqr, but complexity
06:10:30 <mniip> but memory
06:10:36 <kqr> yes, for optimisation I care about how something evaluates
06:10:37 <mniip> butt stuff
06:10:39 <kqr> not for correctness
06:11:14 <cmtptr> well when you're still learning this shit it's kind of important to understand how things like fold evaluate
06:12:29 <kqr> I disagree
06:12:31 <kqr> but to each their own
06:12:56 <agocorona> nobody know how fold* evaluates  ;)
06:12:59 <mniip> well as for foldr, the top level thunk is a null-check
06:13:04 <cmtptr> okay, so I'm getting the wrong result from my function
06:13:08 <cmtptr> what do I do next?
06:13:35 <kqr> check each sub-expression
06:13:48 <kqr> if your function is composed of three other functions, check that the first one gives the correct result
06:13:56 <kqr> then the second one, then the third one
06:13:59 <kqr> one of them is bound to be wrong
06:14:03 <kqr> then do the same thing for that one
06:14:05 <mniip> cmtptr, what are you doing
06:14:13 <cmtptr> I know the sub expressions are correct because I had this working in a slightly more verbose but fold-less version
06:14:24 <cmtptr> the problem is that I obviously don't understand fold
06:15:19 <mniip> if we discard the empty list case, fold returns your function applied to the head of the list, and to the foldr over the tail of the list
06:15:33 <mniip> the definition isn't erally that complex http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Base.html#foldr
06:16:05 <mniip> the commented out one is equivalent to the used one sans optimizations
06:17:35 <cmtptr> well obviously I thought I understood it because I went and wrote some code with it
06:17:47 <cmtptr> the problem is that it doesn't produce the result I expected
06:17:52 <mniip> code?
06:21:39 <cmtptr> there we go, I was using the wrong fold
06:28:49 <danilo2_> Hello! Is there anybody who nows Cloud Haskell ? I've got a small example and its not working. I'm fighting it for last few days and I woudl be very, very, very thankful for any hints and help. Here is the detailed question: http://stackoverflow.com/questions/28366736/cloud-haskell-hanging-forever-when-sending-messages-to-managedprocess
06:31:31 <kqr> is there an abstraction for things that might not apply? what I'm looking for is basically the equivalent of `when` for functions (whenf p f = if p then f else id)
06:32:27 <ddellacosta_> kqr, my understanding is that folks tend to encode that kind of logic in the type system in Haskell, generally speaking
06:32:43 <kqr> ddellacosta_, how do I interpret that?
06:32:48 <clrnd> kqr, isn't that (-> b) as a Monad, perhaps?
06:33:13 <kqr> clrnd, possible.. I've never heard of (-> b) as a monad
06:33:41 <kqr> clrnd, my first instinct was that it sounds monad-y but (r ->) has return = const so that's not it
06:33:51 <xplat> ((->) b) is a monad, (-> b) can't by (it's contravariant)
06:33:57 <xplat> *can't be
06:34:01 <kqr> ah
06:34:08 <bennofs> clrnd:: even then, when would not work as when :: Bool -> m () -> m (), and kqr wants whenf :: Bool -> (a -> b) -> (a -> b)
06:34:10 <kqr> and (b ->) has the wrong return
06:34:29 <kqr> bennofs, that type signature sounds sorta impossible
06:34:45 <bennofs> kqr: oops, yes, replace b with a :)
06:34:51 <kqr> yeah that's more like it
06:35:07 <kqr> it feels like such an abstraction would fit in with when :: Bool -> m () -> m () but I have no idea really
06:35:33 <kqr> as in those two (at least) forms a typeclass
06:35:33 <mjrosenb> kqr: well, id does not have type m().
06:35:34 <clrnd> oh, no idea then
06:36:00 <bennofs> :t let g b f = appEndo $ mconcat [Endo f | b] in g -- Way to write it using monoids
06:36:01 <lambdabot> Bool -> (a -> a) -> a -> a
06:36:21 <angerman> what's the best approach to extract N[0-9]+ for a Text? e.g. multiple time with anything around it?
06:36:32 <xplat> you'd actually want whenf :: Bool -> (a -> a) -> (a -> a)
06:36:40 <bennofs> but that is not any less noisy than the if version :|
06:36:43 <clrnd> I wish I knew what contravariant even means
06:38:15 <xplat> besides getting it from Endo you could also use execState, when, and modify
06:38:44 <bananu7> squee got `gl` package to work
06:39:00 <Yuras> osa1: did you solve the issue with seq?
06:39:10 <bennofs> kqr: you can use 'bool id f p' from Data.Bool
06:39:22 <kqr> bennofs, that's probably the nicest so far
06:39:26 <benzrf> kqr: that would fit in for a State
06:39:33 <benzrf> :t when
06:39:34 <lambdabot> Monad m => Bool -> m () -> m ()
06:39:35 <xplat> clrnd: you could try playing with the contravariant package
06:39:40 <Yuras> osa1: because it ruined my understating of haskell and I can't sleep anymore :)
06:40:01 <benzrf> when :: Bool -> (s -> ((), s) -> (s -> ((), s)
06:40:10 <clrnd> xplat, I'll try it after all this Django boilerplate I have to write :D
06:40:10 <benzrf> kqr: not particularly convenient though
06:40:15 <benzrf> er wait i left off parens
06:40:16 <xplat> benzrf: ))
06:40:18 <benzrf> when :: Bool -> (s -> ((), s)) -> (s -> ((), s))
06:40:49 <bennofs> :t let g b f = execState $ when b (modify f) in g
06:40:50 <lambdabot> Bool -> (s -> s) -> s -> s
06:41:24 <xplat> @pl \b f -> execState $ when b (modify f)
06:41:24 <lambdabot> (execState .) . (. modify) . when
06:41:31 <bennofs> :|
06:41:54 <xplat> :t liftA2 execState ((. modify) . when)
06:41:55 <lambdabot>     Couldn't match type ‚ÄòState c a0‚Äô with ‚Äò(s0 -> s0) -> m0 ()‚Äô
06:41:55 <lambdabot>     Expected type: Bool -> State c a0
06:41:55 <lambdabot>       Actual type: Bool -> (s0 -> s0) -> m0 ()
06:42:26 <bennofs> :t \b -> execState . when b . modify
06:42:27 <lambdabot> Bool -> (s -> s) -> s -> s
06:42:52 <xplat> i guess that's a good half-pointless version
06:43:45 <xplat> i kind of want an Iso between State s () and s -> s now
06:43:55 <mniip> better than one written using just const and <*>
06:44:11 <kqr> does monadplus bear any relation to this?
06:44:22 <kqr> or am I very far out
06:44:25 <bennofs> :t when
06:44:26 <lambdabot> Monad m => Bool -> m () -> m ()
06:44:57 <xplat> you don't need MonadPlus to have when
06:45:20 <kqr> nah and it doesn't satisfy the laws either I don't think
06:45:33 <kqr> I'm just looking for anything that has an identity/zero-looking thing
06:45:38 <kqr> to see if anything fits
06:46:35 <xplat> you could have things like perhaps :: Monad m => Maybe a -> m a -> m a
06:47:01 <xplat> that does an action on Nothing, returns the included value on Just
06:49:07 <mniip> sounds like
06:49:19 <mniip> \m a -> maybe a return m
06:49:35 <mniip> @pl \m a -> maybe a return m
06:49:35 <lambdabot> flip (flip maybe return)
06:49:40 <mniip> oh, not as bad
06:50:04 <mniip> :t \m a -> maybe a return m
06:50:05 <lambdabot> Monad m => Maybe a -> m a -> m a
06:50:09 <mniip> xplat
06:50:13 <fractalsea> I have a string that contains JSON, but escape. Like this: "{
06:50:14 <fractalsea>     \"channel\": \"presence-example-channel\",
06:50:14 <fractalsea>     \"auth\": \‚Äùxyz\‚Äù
06:50:21 <fractalsea> How do I unescape it?
06:50:29 <mniip> that's not a json also use a pastebin
06:50:32 <fractalsea> Can‚Äôt figure it out from Aeson
06:50:45 <fractalsea> OK, sorry
06:51:49 <Procian> When GHC occasionally defaults an ambiguous type variable in code, such as defaulting 1 to Integer in uses of [1..], is there something principled going on there in the type inference algorithm? Something that could potentially be extended by users, say?
06:52:18 <mniip> fractalsea, use the 'decode' function
06:52:22 <mniip> what can be simpler
06:53:13 <fractalsea> It doesn‚Äôt seem to be working. I thought it was just assuming that the whole thing is a single JSON string value
06:53:27 <mniip> is it something else?
06:53:28 <osa1> Yuras: no
06:53:55 <Yuras> osa1: :(
06:54:26 <fractalsea> well it‚Äôs a JSON string value that contains an escaped json object in it. I want to parse that object
06:54:36 <mniip> oh
06:54:40 <mniip> you can call decode twice
06:54:48 <fractalsea> hmm
06:55:01 <fractalsea> Would decode work on a Aeson Value?
06:55:13 <fractalsea> Oh I guess if I apply show to it...
06:56:59 <kqr> @pl \f g a -> f a (g a)
06:57:00 <lambdabot> ap
06:57:35 <Iceland_jack> :t \f g a -> (f <*> g) a
06:57:36 <lambdabot> (t -> a -> b) -> (t -> a) -> t -> b
06:57:57 <osa1> any ideas what is this key http://hackage.haskell.org/package/hscurses-1.4.1.2/docs/UI-HSCurses-Curses.html#v:KeyResize ?
07:00:44 <mniip> by the name it sounds like it's a side-effect of SIGWINCH
07:01:14 <mniip> yep
07:01:16 <mniip> that's what it is
07:02:59 <kqr> :info ap
07:03:08 <kqr> > :info ap
07:03:10 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
07:03:12 <kqr> meh
07:03:15 <mniip> @src ap
07:03:15 <lambdabot> ap = liftM2 id
07:03:24 <kqr> ah control.monad
07:03:49 <ClaudiusMaximus> Procian: you can use the 'default' keyword to get some control, but it's quite limited (at least in Haskell98 - https://www.haskell.org/onlinereport/decls.html#sect4.3.4 )
07:03:57 <mniip> also if you want (\f g a -> f (g a) a) there's =<<
07:04:27 <Yuras> osa1: #define KEY_RESIZE      0632            /* Terminal resize event */
07:04:51 <Yuras> osa1: btw, where Data.Compact come from?
07:05:06 <Yuras> osa1: and Options.Applicative
07:05:14 <osa1> Yuras: just remove that line, it's a library we've been developing
07:05:18 <osa1> that's optparse-applicative
07:06:41 <hexagoxel> Procian: see https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4 and https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/interactive-evaluation.html#extended-default-rules
07:08:40 <Procian> hexagoxel: Cheers!
07:15:37 <voidzero> fractalsea, did you paste that example directly? because I noticed that the second quotes here - \"auth\": \‚Äùxyz\‚Äù - are stylized
07:16:13 <fractalsea> No, I pasted from docs on a site that specifies the API I‚Äôm working against
07:17:16 <fractalsea> I think I‚Äôve figured out the problem though. I‚Äôm going to just do a double decode, but it is not actually valid JSON on it‚Äôs own because it is just a string and is not surrounded by {}. It is part of a larger JSON datastructure
07:20:05 <chpatrick> anyone happen to know how I can link against a thin .a archive?
07:26:26 <Yuras> osa1: argh! `threadDelay 10000000`
07:26:40 <osa1> Yuras: ?
07:26:46 <Yuras> osa1: with deepseq it simply does less work
07:27:09 <Yuras> osa1: because the whole process it time limited
07:27:37 <Yuras> osa1: deepseq is slower, and it can't build big Seq in 10 sec
07:27:55 <osa1> Yuras: but that doesn't explain why I'm having 15% productivity without deepseq, right?
07:28:38 <Yuras> osa1: I have 99.9%  with deepseq
07:28:39 <osa1> I'm wondering if I run this program `main = threadDelay 10000000` do I still get that bad productivity?
07:28:53 <osa1> Yuras: are you running it with +RTS -N ?
07:29:05 <Yuras> osa1: hm, no
07:29:15 <osa1> if you do that you'll probably have much lower productivity
07:31:30 * hackagebot hxt-charproperties 9.2.0.1 - Character properties and classes for XML and Unicode  http://hackage.haskell.org/package/hxt-charproperties-9.2.0.1 (UweSchmidt)
07:31:32 * hackagebot hxt-regex-xmlschema 9.2.0.1 - A regular expression library for W3C XML Schema regular expressions  http://hackage.haskell.org/package/hxt-regex-xmlschema-9.2.0.1 (UweSchmidt)
07:31:34 * hackagebot hxt-unicode 9.0.2.4 - Unicode en-/decoding functions for utf8, iso-latin-* and other encodings  http://hackage.haskell.org/package/hxt-unicode-9.0.2.4 (UweSchmidt)
07:31:36 * hackagebot hxt 9.3.1.14 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.14 (UweSchmidt)
07:31:38 * hackagebot hxt-curl 9.1.1.1 - LibCurl interface for HXT  http://hackage.haskell.org/package/hxt-curl-9.1.1.1 (UweSchmidt)
07:31:59 <Yuras> osa1: I consistently get 99.x% with deepseq, and 50% with seq (using -N)
07:32:46 <xplat> fractalsea: if you're sure the other escaping is json-compatible you can just enclose the whole thing in [] first and then decode, and then decode the one list element again
07:33:55 <osa1> Yuras: ok so we were expecting that simple seq would be enough
07:34:07 <voidzero> when is it normal to use ' in a name?
07:34:30 <osa1> voidzero: when it's not followed by another '
07:34:37 <Yuras> osa1: it is enough to eliminate the unevaluated thunks
07:34:39 <osa1> like i'''''
07:35:15 <Yuras> osa1: and it increased performance IIRC
07:35:16 <voidzero> well i mean, when do you guys decide to use the ' when declaring a new thing
07:35:35 <merijn> voidzero: Same time mathematicians do, when we're too lazy/incapable of coming up with a better name
07:35:45 <osa1> voidzero: stdlib sometimes used it to indicate "same thing without ', but strict"
07:35:48 <merijn> voidzero: Usually x and x' indicate that they are related in some way
07:36:06 <merijn> voidzero: As opposed to x and newX or something
07:36:12 <voidzero> alright.. so there's no strict rule?
07:36:34 <merijn> voidzero: Like osa1 says it's sometimes used to indicate a strict alternative, i.e. foldl vs foldl'
07:36:40 * hackagebot hxt-http 9.1.5.1 - Interface to native Haskell HTTP package HTTP  http://hackage.haskell.org/package/hxt-http-9.1.5.1 (UweSchmidt)
07:36:42 * hackagebot hxt-xpath 9.1.2.2 - The XPath modules for HXT.  http://hackage.haskell.org/package/hxt-xpath-9.1.2.2 (UweSchmidt)
07:36:44 * hackagebot hxt-relaxng 9.1.5.4 - The HXT RelaxNG validator  http://hackage.haskell.org/package/hxt-relaxng-9.1.5.4 (UweSchmidt)
07:36:46 * hackagebot hxt-xslt 9.1.1.1 - The XSLT modules for HXT.  http://hackage.haskell.org/package/hxt-xslt-9.1.1.1 (UweSchmidt)
07:36:52 <merijn> voidzero: But generally I would interpret it as "an alternative of some sorts"
07:37:03 <voidzero> alright, works for me, thank yous :)
07:37:16 <merijn> Or!
07:37:33 <merijn> Grammatical correctness, like my "let can'tHappen = someError" :p
07:37:45 <voidzero> haha
07:37:54 <voidzero> I will try to stay clear from those ;)
07:38:05 <Yuras> osa1: I think the low productivity is a result of huge Set living in the old generation. that is still an issue, but a bit different from seq vs deepseq
07:38:36 <arw_> or math: f and f' as function and derivative. or x as 'something' and x' as 'another something that I do not want to call y'
07:39:02 <arw_> (and maybe has something to do with x)
07:39:22 <osa1> Yuras: also single thread with +RTS -N is way worse than single thread with +RTS -N1 which I think is another problem
07:40:36 <merijn> osa1: A problem in what way?
07:40:46 <merijn> I would expect that, tbh
07:40:47 <Yuras> osa1: yes. and now I can sleep at night because deepseq doesn't actually help here :)
07:40:53 <merijn> GC is more expensive with -N
07:41:31 * hackagebot Stream 0.4.7.2 - A library for manipulating infinite lists.  http://hackage.haskell.org/package/Stream-0.4.7.2 (WouterSwierstra)
07:41:43 <osa1> merijn: see second file here https://gist.github.com/osa1/3b100e11e464f3cd7142 I'm having 15% productivity
07:43:07 <Yuras> osa1: here you build a thunk with S.insert, and `seq` helps here. I'm missing something?
07:44:29 <osa1> I need to move to another place, will be back in 15
07:45:22 <Yuras> merijn: here is the beginning: https://phabricator.haskell.org/chatlog/channel/3/?at=794296
07:48:29 <xplat> i keep trying to make a monad version of hxt, but i keep losing momentum before i'm done, and before i know it there's a new release
07:48:49 <xplat> maybe i should try doing it as a project at a hackathon
07:51:32 * hackagebot hxt-cache 9.1.0.1 - Cache for HXT XML Documents and other binary data  http://hackage.haskell.org/package/hxt-cache-9.1.0.1 (UweSchmidt)
07:57:55 <merijn> Ah, he left...I was gonna suggest trying strict Set...
07:58:31 <Yuras> merijn: strict Set?
07:59:51 <Yuras> merijn: one that forces the value, not only the key?
08:00:56 <Yuras> oops, sorry, I messed things up :)
08:01:32 * hackagebot pgdl 7.0 - pgdownloader  http://hackage.haskell.org/package/pgdl-7.0 (sifmelcara)
08:16:33 * hackagebot fingertree 0.1.0.1 - Generic finger-tree structure, with example instances  http://hackage.haskell.org/package/fingertree-0.1.0.1 (RossPaterson)
08:19:17 <osa1> seq on an Int has same effect as forcing that Int, right? (force as in NFData.force)
08:19:40 <awesomo4000> can't for the life of me track down why i'm getting a parse error . is there an easy way to tell what's wrong
08:19:51 <geekosaur> @paste
08:19:51 <lambdabot> Haskell pastebin: http://lpaste.net/
08:20:13 <geekosaur> (sadly, parse errors don't get anything near as helpful as type errors, so "not usually")
08:21:17 <Yuras> osa1: IIRC `force` is a `deepseq`, not `seq`
08:21:32 <awesomo4000> http://lpaste.net/120088
08:21:42 <Yuras> osa1: but the effect should be the same I think
08:21:49 <osa1> Yuras: that's true, I was wondering what effect would `seq` have on "primitive" types.
08:21:53 <osa1> Yuras: yes that's what I mean
08:22:18 <osa1> awesomo4000: try indenting lin e09
08:22:21 <osa1> line 9
08:22:54 <hodapp> what is a standard-ish way to represent multiple non-exclusive options, like one might use bitfields/bitmasks for in C?
08:23:39 <osa1> hodapp: you can do the same, I generally use a `Set Flag`
08:23:48 <Yuras> @hackage these
08:23:48 <lambdabot> http://hackage.haskell.org/package/these
08:24:03 <hodapp> osa1: is Flag here a specific type?
08:24:19 <hodapp> Yuras: is that to me?
08:24:20 <osa1> hodapp: no, it's your sum type that represents your options/flags.
08:24:34 <awesomo4000> that worked thanks !   . i don't know why i need 2 levels of indent there .
08:24:44 <hodapp> osa1: oh, okay!
08:25:10 <Yuras> hodapp: well, I thought it is more general, but now see it is works only with two options
08:25:22 <geekosaur> awesomo4000, because the indentation puts it inside the "where", not inside the "step (p,c) = do"
08:25:25 <osa1> awesomo4000: the letter `s` in line 8 is where your block starts, with do you need extra indentation starting from the column of that `s`
08:25:40 <hodapp> Yuras: also, it's called "these" so it's really not very search-engine optimized
08:25:43 <MrMetric> Is NoMonomorphismRestriction bad for performance? My code is rather slow
08:25:55 <geekosaur> the indentation for "do" is somewhat loosened compared to other things, but it still needs to be able to tell when you're back inside the "where"
08:26:49 <awesomo4000> i see. thanks.   Also,  what does   </>   do ?
08:27:31 <geekosaur> MrMetric, it can be, depends on what you are doing. (specifically, if something is polymorphic then it can't be shared, so the program may end up doing more work)
08:27:40 <merijn> MrMetric: It can lead to needless recomputation, yes
08:28:03 <MrMetric> Also, how expensive are function calls? They appear to be making my code much slower than it should be
08:28:11 <merijn> MrMetric: Highly doubtful
08:28:16 <geekosaur> function calls themselves are essentially free
08:28:24 <merijn> MrMetric: Haskell function calls cost as much as jumps
08:28:26 <geekosaur> they don't work the way you are likely imagining them
08:28:29 <MrMetric> I inlined a function call, and the code ran noticeable faster
08:28:48 <merijn> MrMetric: That's likely due to triggering further optimisation than actual inlining
08:28:53 <geekosaur> that usually means that there's an opportunity for fusion being missed
08:29:04 <merijn> MrMetric: Haskell's execution model is rather different from, say, C or Java
08:29:05 * geekosaur slow, should just back out...
08:29:42 <breadmonster> Hello, everyone.
08:29:50 <osa1> MrMetric: you probably allowed some further optimizations by inlining the code
08:30:14 <awesomo4000> this </> is surprisingly hard to google for
08:30:30 <MrMetric> If I paste my code, can I get feedback on what I'm doing wrong?
08:30:42 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/filepath-1.3.0.1/System-FilePath-Posix.html#v:-60--47--62-
08:30:48 <bennofs> awesomo4000: try using hayoo
08:30:51 <geekosaur> @hoogle (</>)
08:30:51 <bennofs> @where hayoo
08:30:53 <harovali> hi, I'm trying to choose a language to use a soap based http webservice. The language that more naturally I'd choose is python, but the suds library there is old and unmantained. Is in haskell the situation better ? I'd go haskell instead, before having to go java or ...
08:30:54 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
08:30:54 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
08:30:54 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
08:30:55 <osa1> awesomo4000: it's from filepath
08:31:18 <geekosaur> @paste --- MrMetric
08:31:18 <lambdabot> Haskell pastebin: http://lpaste.net/
08:31:19 <dmwit> The best joke I have read in a while:
08:31:23 <dmwit> ?quote pigworker pat ourselves
08:31:23 <lambdabot> pigworker says: The usual style is to write as if everything is inductive, and if it still works on infinite data, to pat ourselves on the back for using Haskell rather than ML.
08:31:46 <MrMetric> geekosaur: Is that a yes?
08:31:54 <geekosaur> yes
08:32:05 <geekosaur> although I don't think anyone can guarantee havibg useful feedback
08:32:31 <breadmonster> geekosaur: Do you use emacs?
08:32:40 <breadmonster> I'm trying to figure out how to get it to autoindent Haskell.
08:33:19 <geekosaur> autoindentation is surprisingly hard, because indentation has semantic meaning (what "block" a line belongs to)
08:33:36 <geekosaur> to do it absolutely correctly, the editor has to actually understand what the code is doing
08:33:37 <Luke> breadmonster: try #haskell-emacs
08:33:37 <Luke> its really helpful
08:33:39 <geekosaur> which, no
08:33:49 <breadmonster> Luke: Will comply.
08:33:53 <Luke> geekosaur: fully automatic auto-indent is done with hindent. I use hi2 for partial indentation support
08:33:59 <Luke> oops breadmonster^
08:34:37 <breadmonster> Luke: Why would you use hi2 if you have hindent?
08:35:10 <lpaste> MrMetric pasted ‚Äúmandelbrot.hs‚Äù at http://lpaste.net/120090
08:35:27 <MrMetric> Please tell me how I can improve this, if you have any suggestions
08:35:27 <Luke> breadmonster: but yeah, geekosaur is right that the editor (or process) has to know the AST to correctly auto-indent, which is what hindent does
08:35:48 <Luke> breadmonster: because I don't like any of the auto-indentation styles hindent has
08:36:06 <merijn> MrMetric: Eliminate all numeric polymorphism
08:36:11 <Luke> breadmonster: i want to make my own but haven't taken the time so hi2 is a good intermediate
08:36:15 <kuribas> haskell-indentation.el does some rough parsing of the haskell syntax.
08:36:27 <kuribas> and hi2
08:36:29 <MrMetric> merijn: ._.
08:36:30 <merijn> MrMetric: i.e. use Int/Integer and Double instead of Integral/RealFrac
08:36:38 <geekosaur> it's not just the AST, you have to actually understand the code's *intent* to know for certain which block a given line belongs to, so you can assign it appropriate indentation
08:36:40 <MrMetric> Does it really matter that much?
08:36:48 <kuribas> hi2 should be merged into haskell-indentation.el
08:36:51 <dmwit> Luke: do { proc <- forkIO $ do { blah; baz }; bluff }
08:36:53 <MrMetric> I'll try it
08:37:00 <merijn> MrMetric: Actually
08:37:08 <geekosaur> yes, because (a) it can't share computations (b) it can't optimize as well
08:37:10 <merijn> MrMetric: You're doing "max_iterations = read (args !! 0) :: Integer" and then passing that into functions
08:37:19 <merijn> MrMetric: So basically it's treating everything as Integer
08:37:26 <dmwit> Luke: How should your automatic indenter know whether I want baz to be in the forkIO block or the enclosing block?
08:37:31 <MrMetric> Okay then
08:37:32 <Luke> dmwit: ?
08:37:32 <redactyl> I've seen a "reader" used in several places which looks like ((->) t). What does it do?
08:37:37 <geekosaur> polymorphic code will *always* have to make extra calls instead of inlining based on knowing that it's all e.g. Integer
08:37:38 <merijn> MrMetric: If you use Int you can probably get the strictness analyser to kick in and inline/specialise half of that code
08:37:57 <merijn> MrMetric: I would try both specialising to Integer and Int and seeing what the difference are
08:38:06 <MrMetric> merijn: I'll try Integer first
08:38:13 <Luke> dmwit: there are still ambiguous cases for sure. I'm not sure what it would do there. You would have to ask Chris Done, the author
08:38:21 <MrMetric> merijn: What do you mean by 'specialize'?
08:38:41 <dmwit> Luke: The point being, "fully automatic" is a lie, and knowing the AST isn't enough.
08:38:42 <merijn> MrMetric: Replacing "Integral a => a -> a" with "Int -> Int"
08:38:49 <ClaudiusMaximus> MrMetric: or add pragmas like  {-# SPECIALIZE foo :: Int -> Double -> Double #-}
08:38:54 <geekosaur> MrMetric, if you're interested in the gory details, install the ghc-core package and use it to inspect the generated code for (a) the polymorphic version (b) Integer (c) Int
08:39:13 <merijn> MrMetric: The idea is that "Int -> Int" is a "more specific" (i.e. specialised) version of "Num a => a -> a"
08:39:28 <dmwit> s/knowing/understanding/ perhaps
08:39:35 <merijn> MrMetric: This lets the compiler generate more specific/efficient code
08:40:02 <geekosaur> ("Core" is a sort of austere version of Haskell used internally by the compiler, and includes the optimizations it was able to figure out and the "translated" form of typeclasses and do notation and such)
08:40:17 <hodapp> I need to read about GHC internals.
08:40:21 <hodapp> one of these days.
08:40:44 <Luke> dmwit: I don't think solving that corner case is what he had in mind
08:40:44 <Luke> dmwit: you're taking his meaning of "fully automatic" too literally
08:40:56 <merijn> hodapp: I've got a good paper on the underlying language for you ;)
08:41:00 <Luke> he just means it will do the best it can which clearly some indent-modes don't do
08:41:11 * merijn is like a crack dealer, but dealing in STG papers
08:41:40 <dmwit> Luke: You were the one to talk about fully automatic. I have no complaint about your suggestion, just your description of it. =)
08:41:50 <merijn> hodapp: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
08:42:30 <init> merijn: how much is the second paper? (because the first is free, right?)
08:42:31 <merijn> hodapp: It's a fairly easy read if you know some basic asm/C (and I mean *really* basic), it explains how to map STG to asm/C. (Mapping haskell to STG is not that hard)
08:43:03 <merijn> The next costs as much as a fast curry
08:43:08 <Luke> dmwit: that's called being pedantic ;-P
08:43:16 * dmwit nods agreeably
08:43:20 <Luke> dmwit: but you're right, fully automatic isn't technically correct
08:43:43 <Luke> i should have qualified with "within the scope of possible"
08:43:48 <Hijiri> would be pretty neat to have a fully-automatic mahjong table
08:43:57 <merijn> init: This is a neat (but for more specific and detailed) continuation http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.9317&rep=rep1&type=pdf
08:44:21 <init> thanks!
08:44:31 <merijn> init: I think the first one is a very good read when you've always wanted to know "how the hell does one compile a lazy language to machine code"
08:44:32 <geekosaur> as for emacs, there are last I checked three indentation modes available for haskell-mode, ranging from esentially manual to as close to automatic as emacs is capable of getting (it's not actually all that smart)
08:44:54 <merijn> init: The second is far less general and useful to read (unless you plan to actually implement a lazy language ;)
08:44:59 <Luke> dmwit: are you still at u penn?
08:45:06 <Luke> dmwit: I don't remember seeing you there this summer
08:45:21 <kuribas> geekosaur: haskell-indentation has a builtin parser, but I can fail on extensions.
08:45:21 <dmwit> I graduated, and I'm working at Galois now.
08:45:23 <breadmonster> merijn: What's STG?
08:45:26 <geekosaur> also check your version of haskell-mode; many linux distributions still include a very old one where the indentation is particularly dumb
08:45:26 <Luke> dmwit: oh awesome
08:45:30 <merijn> init: STG basically has: functions, function application, constructors, case statements, allocation and that's about it :p
08:45:36 <breadmonster> Luke: You're visiting Penn?
08:45:46 <merijn> breadmonster: A language and a machine model, the Spineless Tagless G-machine
08:45:51 <kuribas> geekosaur: The best way is to send bug reports, but I admit I don't read them very often...
08:45:53 <Luke> breadmonster: every year for hacphi
08:45:58 * geekosaur has more or less stopped using distribution versions of haskell-mode because so many of them are years out of date
08:46:21 <Hijiri> man, JFFP charges 45 dollars for an article?
08:46:24 <Hijiri> JFP*
08:46:28 <Luke> geekosaur: melpa does a fairly good job
08:46:35 <Hijiri> are most journals like this?
08:46:36 * hackagebot hxt 9.3.1.15 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.15 (UweSchmidt)
08:46:38 * hackagebot hxt-http 9.1.5.2 - Interface to native Haskell HTTP package HTTP  http://hackage.haskell.org/package/hxt-http-9.1.5.2 (UweSchmidt)
08:46:38 <Luke> geekosaur: i think it snapshots from git
08:46:40 * hackagebot hxt-relaxng 9.1.5.5 - The HXT RelaxNG validator  http://hackage.haskell.org/package/hxt-relaxng-9.1.5.5 (UweSchmidt)
08:46:42 <geekosaur> Hijiri, sadly yes
08:46:44 <merijn> breadmonster: It's the base model/language that Haskell is converted to before generating machine code. GHC has diverged a lot in tons of details, but it still provides a good high-level overview/intuition that applies to GHC haskell
08:47:02 <geekosaur> and not just FP journals
08:47:19 <geekosaur> there's something of a row going on in the scientific communities over "open access"
08:47:44 <breadmonster> geekosaur: What's the row?
08:47:58 <breadmonster> I was under the impression that everyone just wants open access.
08:48:04 <breadmonster> Apart from Elsevier of course.
08:48:12 <ClaudiusMaximus> MrMetric: you might be interested in my (pre-alpha, unreleased) https://gitorious.org/mandelbrot (though the image rendering is only in C so far, I plan to make a Haskell implementation too for comparison, and also C implementations of some of the symbolic algorithms that are Haskell only so far)
08:48:21 <merijn> breadmonster: I can strongly recommend reading that paper for beginner/intermediate haskellers, anyway time to go! :)
08:48:30 <kuribas> except ACM
08:48:47 <geekosaur> wveryone wants open access, nobody has practical ideas for making sure the folks who publish and disseminate the material can afford to do so...
08:49:16 <zeiris> Afford in what way?
08:49:17 <breadmonster> merijn: which one?
08:49:29 <merijn> breadmonster: The first (MSR) link
08:49:34 <geekosaur> unfortunately, the folks who do so are businesses and will not accept merely "sufficient", they want "highest profit"
08:49:40 <geekosaur> (see Elsevier)
08:49:43 <merijn> breadmonster: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
08:50:18 <dmwit> zeiris: afford financially
08:50:28 <hodapp> merijn: I think I've bookmarked that already, I'm just swamped with other stuff to read
08:50:35 <awesomo4000> darn. i wanted to read about the m$ breadmaker
08:50:39 <RaceCondition> if I want a list of values whose type is a Show, I can use `data Obj a = forall a. (Show a) => Obj a`; but is there also a way to declare such list without the Obj wrapping?
08:50:53 <breadmonster> merijn: Okay, I can't seem to find a pdf on that page...
08:51:10 <awesomo4000> Surface Warmer Pro 3
08:51:16 <dmwit> RaceCondition: [Int -> ShowS] -- ;-)
08:51:21 <dmwit> :t showsPrec
08:51:22 <lambdabot> Show a => Int -> a -> ShowS
08:51:30 <dmwit> closures over the shown values
08:52:50 <RaceCondition> dmwit: does that allow me to do [1, "hello", True] without getting a compilation error?
08:53:07 <dmwit> No. Nothing does.
08:53:24 <RaceCondition> dmwit: ok, so [Obj 1, Obj "hello", Obj True] is the only way
08:53:32 <breadmonster> merijn: Oh wait I forgot ps is also a document type :P
08:53:35 <ClaudiusMaximus> RaceCondition: if all you can do is show, why not [show 1, show "hello", show True] (dmwit's suggestion also handles precedence and appending, while essentially being the same idea)
08:53:56 <RaceCondition> ClaudiusMaximus: with Show, that would work, but I'm only using Show as an example
08:54:00 <geekosaur> also not everyone "wants" open access. there are fields where open access is looked on with deep suspicion because they think journals add value through editorial review (notwithstanding that even the big "trusted" journals let an astounding amount of junk through)
08:54:00 <ChristianS> geekosaur: that's a strange argument as scientific review is practically alway done by unpaid "peers", not by paid editors
08:54:00 <geekosaur> http://pipeline.corante.com/archives/the_scientific_literature/ Derek Lowe (better known for "Things I Won't Work With") does a decent job of summarizing these, with pointers to others who do so
08:54:00 <ChristianS> geekosaur: and of course the serious open access journals are peer-reviewed too
08:54:00 <geekosaur> ChristianS, sadly that is not how it is *perceived*
08:54:00 <geekosaur> often the folks writing the papers have no idea how the system works...
08:54:00 <dmwit> RaceCondition: See also "the existential antipattern".
08:54:10 <RaceCondition> it's actually a polymorphic list of events from a queue whose handlers are defined as type class instances
08:54:14 <dmwit> ?google existential antipattern
08:54:16 <lambdabot> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
08:54:28 <RaceCondition> dmwit: thanks, I'll read that
08:56:29 <RaceCondition> dmwit: awesome, seems very useful and relevant, thanks again
08:56:40 <sssilver> dmwit: haha that's awesome
08:57:03 <RaceCondition> dmwit: although, that doesn't mean that approach is always an antipattern, does it?
08:58:38 <RaceCondition> like, when you can't model all Widgets with the same ADT
08:58:59 <MrMetric> I changed everything to say Integer and Double, but it's not any faster
08:59:19 <MrMetric> Oh, except for roundPixel, which returns Word8
09:00:45 <xplat> RaceCondition: best case i can think of is when you have a preexisting typeclass with all the methods you want, and it's big
09:01:26 <RaceCondition> xplat: ok, I see; I'll try to wrap my head around it in the context of the code base I'm dealing with
09:01:27 <xplat> RaceCondition: otherwise you're best off with just a record of disaggregated methods and represent the data with whatever and close over it
09:02:22 <xplat> anyone have a good intro to haskell stuff on nix?
09:02:44 <RaceCondition> so the antipattern then is really about overuse of type classes, not existential types -- the need for the latter just arises from the former
09:02:52 <MrMetric> I also deleted the NoMonomorphismRestriction line
09:03:28 <MrMetric> Oh
09:05:05 <xplat> RaceCondition: well, the antipattern is 'using a typeclass-qualified existential'
09:05:07 <MrMetric> It's faster now; I compiled the wrong file after changing the code
09:05:43 <xplat> or rather 'a typeclass-qualified bare-variable existential'
09:06:21 <xplat> so the antipattern is a thing including both typeclass and existential use, it's not about either one separately
09:06:37 * hackagebot atomic-write 0.1.0.0 - Atomically write to a file  http://hackage.haskell.org/package/atomic-write-0.1.0.0 (jsl)
09:07:53 <sssilver> Any good resource to read about how a function returning a random number can fit into the Haskell concept?
09:08:41 <RaceCondition> xplat: but isn't it the case that using a typeclass for Widgets leads to the existential antipattern?
09:09:42 <ClaudiusMaximus> MrMetric: Int is a lot faster than Integer in inner loops, and if you're using 64bit ghc then Int has plenty enough range for iteration counts - but personally i'd have left everything polymorphic and added {-# SPECIALIZE ... #-} pragmas for everything, then constrain to Int/Double in main
09:10:29 <MrMetric> ClaudiusMaximus: I'm guessing SPECIALIZE generates 2 versions of a function?
09:10:41 <geekosaur> RaceCondition, sometimes it's necessary --- usually because the widgets are hidden behind the FFI and all you *get* for them is the antipattern, and you have to rely on the stuff on the other side of the FFI, usuing some unknown-to-Haskell object system, doing the right thing
09:11:09 <ClaudiusMaximus> MrMetric: which allows you to later add a call in main using Int + Compensated Double for deeper zooms (when compensated gets RealFloat instances, if ever..)
09:11:37 * hackagebot atomic-write 0.1.0.1 - Atomically write to a file  http://hackage.haskell.org/package/atomic-write-0.1.0.1 (jsl)
09:12:08 <ClaudiusMaximus> MrMetric: you can have multiple specialize pragmas, each generates a new version with less polymorphism - increases code size and compilation time, but they're usually much faster than fully polymorphic versions
09:12:16 <geekosaur> note that the existential antipattern is an antipattern because it attempts to reproduce OOP in Haskell and fails. if on the other hand you are doing FFI to an OOP language, it may well be appropriate to let the other language do its OOP-style type resolution on the other side of the FFI "wall"
09:12:27 <MrMetric> ClaudiusMaximus: I started learning Haskell a few days ago; I don't know all of this fancy stuff! What is Compensated Double?
09:13:38 <ClaudiusMaximus> MrMetric: it uses two Double (x,y) scaled to represent the value x + y with higher precision, but actually performing that addition in Double will give x (because y is much smaller, containing the trailing bits)
09:14:51 <MrMetric> ClaudiusMaximus: Neat
09:19:53 <ClaudiusMaximus> MrMetric: ok - if you're so new to haskell, maybe skip some of the optimization techniques for now - using monomorphic types is fine for mandelbrot if you're sticking to haskell platform or so (afaik the only RealFloat in the platform are Float, Double, CFloat, CDouble, and the last 2 are usually the same as the first 2, and Float is only really useful for saving space in bulk storage of unboxed arrays)
09:20:49 <MrMetric> ClaudiusMaximus: I'm not doing just Mandelbrot :]
09:21:02 <Cale> sssilver: Well, a function which takes a pseudorandom number generator state, and produces a pseudorandom number along with a new state is possible.
09:21:13 <MrMetric> ClaudiusMaximus: My code made this pic yesterday: https://i.imgur.com/lrtxi7e.png
09:21:16 <Cale> sssilver: But *functions* can't produce random results in Haskell.
09:21:41 <sssilver> Cale: where can I read about it? I've been with Haskell for a few weeks, but I'm not too advanced yet.
09:21:46 <Cale> sssilver: Indeed, the result of evaluating any expression at all can't be random.
09:21:55 <ClaudiusMaximus> MrMetric: cool!
09:21:58 <Cale> But the result of executing an I/O action can be random
09:22:02 <t4nk814> whats the site to copy paste code?
09:22:17 <Cale> sssilver: So, perhaps look at how IO actions work
09:22:21 <MrMetric> ClaudiusMaximus: That picture is actually the result of a mistake :]
09:22:23 <RaceCondition> geekosaur: yeah, I know, but I meant in that particular example where the Widgets are defined in Haskell
09:22:28 <MrMetric> I got a formula wrong
09:22:42 <sssilver> Cale: oh no.... is it gonna be the M thing? *in awe*
09:22:55 <ClaudiusMaximus> MrMetric: keep it, say you discovered an amazing new formula ;)
09:23:08 <Cale> sssilver: A value x of type IO t is a description of some stuff which could be done in order to produce a result of type t, and have any effect whatsoever (that your computer is capable of) in the meantime.
09:23:46 <MrMetric> ClaudiusMaximus: Actually, the formula I was trying to do is another one I found while doing fractals with C++
09:24:02 <Cale> sssilver: IO happens to be a monad, but people get too hung up on this, the important thing is that it's a data type at all, not so much that it supports the monad interface (but that certainly helps to know)
09:24:25 <MrMetric> ClaudiusMaximus: https://iloveportalz0r.deviantart.com/art/Neuron-Fractal-e3c1-346385488 (warning: code at the link is terrible crap)
09:24:44 <t4nk814> Is this the correct way to pattern match on the data type?
09:24:45 <t4nk814> http://lpaste.net/120091
09:24:52 <Cale> sssilver: So, execution of IO actions isn't something that evaluation can make happen, but in a compiled Haskell program, the action called main will be executed, and in turn, its execution can involve executing other IO actions.
09:25:26 <sssilver> Cale: but doesn't that make everything potentially side-effectful?
09:25:40 <Cale> sssilver: Well, evaluating expressions won't have side effects
09:25:49 <Cale> sssilver: Only executing IO actions will
09:26:03 <Cale> So if you have some function Integer -> String
09:26:23 <Cale> and you apply it to some Integer, you know that the only thing that will happen is that some String will be the result of the evaluation
09:26:34 <Cale> It won't go talking over the network or anything like that
09:27:50 <Cale> Now, if you have a function f :: Integer -> IO String  -- again, evaluating f 5 won't actually cause anything to happen, but the result won't be a String, it will be an IO String, that is a description of some potentially-effectful action that could be carried out to produce a String if executed
09:28:04 <Cale> Executing that action of type IO String multiple times could produce many different results
09:29:25 <ClaudiusMaximus> MrMetric: nice pic, though i prefer the "mistake"..  here's my latest experiment http://mathr.co.uk/blog/2015-02-06_interpolating_moebius_transformations.html (video link near the bottom)
09:30:20 <Cale> sssilver: As part of defining an IO action, you might make use of functions and other values of all sorts, which might have nothing to do with causing effects to occur, and might not involve IO in any way.
09:31:14 <Cale> sssilver: For example, we have  getLine :: IO String  which gets a line of text from the user, and  putStrLn :: String -> IO ()  which is a function that given some string, produces an IO action for printing that string to the terminal. We can write:
09:31:29 <Cale> main = do x <- getLine; putStrLn (reverse x)
09:31:52 <Cale> Here, the do-block lets us combine multiple IO actions into a larger one
09:32:08 <sssilver> so Cale, would you say that IO String is in fact a function that returns a string, and is not a "usual" function, because inside it can do arbitrary (potentially side effectful) stuff?
09:32:08 <Cale> x <- getLine means "execute the action getLine, and call its result x", so x :: String
09:32:41 <Cale> and then  reverse :: [a] -> [a]  need not know or care that the String it's getting as an argument came from user input
09:33:00 <Cale> it does its work, and the action putStrLn (reverse x)  prints the resulting String to the terminal
09:33:12 <Cale> A value of type IO String isn't a function
09:33:21 <Cale> because it has no parameter
09:33:24 <sssilver> well, what is it? it doesn't seem to be a value either
09:33:36 <Cale> It's a program which if executed will produce a String
09:33:47 <Cale> Functions are values of type A -> B
09:33:59 <sssilver> well a function can be void right
09:34:06 <Cale> They take some argument of type A, and produce some result of type B
09:34:08 <Cale> always
09:34:32 <sssilver> OK so it's a void function, which is a special kind of a function
09:34:37 <sssilver> ...in Haskell
09:34:37 <Cale> (In some other programming languages, people are more lax about what the term "function" means, but not here :)
09:34:42 <sssilver> OK OK
09:34:52 <Cale> In Haskell, functions may not have any side effects
09:34:55 <Iceland_jack> sssilver: You can call it an action
09:34:57 <sssilver> so we call these particular functions "actions"
09:34:59 <sssilver> cool cool
09:35:14 <Cale> Yeah, get out of the habit of calling IO actions functions quickly :)
09:35:22 <sssilver> that's easy
09:35:26 <Iceland_jack> sssilver: And it is a value (or term/expression), since actions are first-class in Haskell
09:35:27 <Cale> Because functions are much nicer and more controlled things :)
09:35:42 <sssilver> and these actions somehow contain imperative logic?
09:35:43 <Cale> But yeah, IO actions are values, just as functions are
09:35:46 <Cale> yeah
09:35:53 <sssilver> written in... Haskell?
09:35:53 <Iceland_jack>     putStrLn :: String -> IO ()
09:35:53 <Iceland_jack> is a function (note the '->') that returns an action
09:36:08 <sssilver> this is awesome, I'm totally getting this so far
09:36:10 <Cale> They do so in a way which is abstract -- we unfortunately can't peek inside an IO action value to see what it will do before executing it
09:36:39 * hackagebot MonadCompose 0.1.0.0 - An IO monad transformer  http://hackage.haskell.org/package/MonadCompose-0.1.0.0 (JamesCandy)
09:36:40 <Cale> But that's sort of just for ease of getting good performance out of them through compiler hackery
09:36:47 <sssilver> when you say "peek inside an IO action" what do you mean?
09:37:08 <Cale> You could imagine an IO data type which allowed us to pattern match and see what the action was without carrying it out
09:37:58 <Cale> I mean that, for example, if I give you an IO String, there's no way to compare and check if it happens to be getLine
09:38:00 <sssilver> OK, so I imagine an IO action that connects to the internet and gets the current time. What language would this action be written on?
09:38:07 <Cale> Haskell of course
09:38:21 <Cale> IO actions are Haskell values
09:38:39 <ta`> hehe... willThisDestroyTheWorld :: IO a -> Bool
09:38:41 <breadmonster> Cale: So how do you compare if two things wrapped inside a monad are equal?
09:38:52 <init> ta`: = const False ;)
09:38:53 <breadmonster> liftM2 (==) ?
09:39:04 <Cale> Evaluating an IO action doesn't do much which is visible aside from making your computer slightly hotter, but you can imagine that it does some internal processing to simplify the representation of what needs to be done
09:39:04 <breadmonster> > 2 + @
09:39:05 <lambdabot>  <hint>:1:5: parse error on input ‚Äò@‚Äô
09:39:08 <Iceland_jack> breadmonster: Sure
09:39:24 <Cale> breadmonster: You can't compare IO actions for equality
09:39:26 <breadmonster> :t liftM2 (==) getLine getLine
09:39:27 <lambdabot> IO Bool
09:39:34 <Cale> breadmonster: You can compare their results for equality, sometimes
09:40:00 <Cale> breadmonster: Don't think of an IO String value as a "String wrapped in an IO", that's a terrible way to think of it
09:40:14 <Cale> That's like saying that /bin/ls is a list of files wrapped in a program
09:40:14 <sssilver> Cale: can't you ask if "these two actions are the same action"?
09:40:17 <breadmonster> Cale: Except that's what it is, yeah?
09:40:22 <Iceland_jack> breadmonster:
09:40:22 <Iceland_jack> @quote /bin/ls
09:40:22 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:40:40 <hiptobecubic> It's a `tring` for apple devices.
09:40:41 <Scriptonaut> sorry to interrupt guys, but is the type: [a] syntactic sugar for anything?
09:40:42 <Cale> sssilver: You can't, because the IO type is abstract
09:41:18 <Cale> sssilver: But one could imagine a variant of Haskell wherein IO was just an ordinary data type with exposed data constructors
09:41:20 <breadmonster> Scriptonaut: [] a
09:41:25 <xplat> Scriptonaut: ([] a), which is a list of as
09:41:29 <Cale> sssilver: Rather than something built in
09:41:31 <Scriptonaut> ah, thanks
09:41:33 <Iceland_jack> sssilver: You *can* define your own data type:
09:41:33 <Iceland_jack>     data ACTION = PRINT String | BEEP
09:41:33 <Iceland_jack> where you have an interpretation function:
09:41:33 <Iceland_jack>     run :: ACTION -> IO ()
09:41:40 * hackagebot MonadCompose 0.2.0.0 - Methods for composing monads.  http://hackage.haskell.org/package/MonadCompose-0.2.0.0 (JamesCandy)
09:41:41 <sssilver> Cale: you have a talent for explaining my friend
09:41:41 <breadmonster> :t IO $ "aaa"
09:41:42 <lambdabot>     Not in scope: data constructor ‚ÄòIO‚Äô
09:41:42 <lambdabot>     Perhaps you meant ‚ÄòIn‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
09:41:57 <Iceland_jack> sssilver: Then you can compare them, but you can't compare IO actions for equality
09:41:57 <breadmonster> Cale: How on earth did they do that?
09:42:02 <breadmonster> @src IO
09:42:02 <lambdabot> Source not found. Just try something else.
09:42:14 <Cale> breadmonster: hm?
09:42:24 <breadmonster> How is the IO monad implemented?
09:42:30 <benzrf> breadmonster: why do you care
09:42:31 <sssilver> Cale: but wouldn't code that talks to a network server be inherently imperative? and as such, how would it be implemented in Haskell?
09:42:53 <breadmonster> benzrf: I'd like to learn how to start hacking on ghc
09:42:55 <xplat> @quote list of files
09:42:55 <lambdabot> No quotes for this person. Do you think like you type?
09:43:00 <Cale> breadmonster: Well, in GHC, it's implemented with lots of ugly hackery -- it uses impure functions that take 0-byte wide arguments...
09:43:09 <benzrf> breadmonster: it's a state monad with a fake state type that wraps around impure functoins
09:43:09 <xplat> @quote list.of.files
09:43:09 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:43:11 <Cale> breadmonster: But that's not a very good mental model
09:43:17 <davean> breadmonster: IO is an interesting stack to trace for runtime stuff
09:43:29 <xplat> breadmonster: ^
09:43:37 <benzrf> sssilver: its inherently imperative in the same way that iterating over a list and adding each value to a tally is inherently imperative
09:43:42 <Cale> breadmonster: A better mental model of IO would be something like a GADT that looks like:
09:43:46 <Cale> data IO a where
09:43:50 <IP92> how should I define a function, that takes [Integer] (contains only values 0-9) and kinda expands it with -1s, e.g fun [1,3,4,8] == [-1, 1, -1, 3, 4, -1, -1, -1, 8, -1]
09:43:51 <Cale>   ReturnIO :: a -> IO a
09:43:58 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
09:44:03 <Cale>   GetChar :: IO Char
09:44:10 <Iceland_jack> IP92: concatMap (\a -> [-1,a])
09:44:10 <Cale>   PutChar :: Char -> IO ()
09:44:13 <breadmonster> > (return "3") :: IO Int
09:44:14 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
09:44:14 <lambdabot>              with actual type ‚Äò[GHC.Types.Char]‚Äô
09:44:16 <Cale>   ... etc, etc...
09:44:17 <benzrf> Cale: 12:40 < breadmonster> benzrf: I'd like to learn how to start hacking on ghc
09:44:25 <Iceland_jack> > concatMap (\a -> [-1,a]) [1,3,4,8]
09:44:26 <lambdabot>  [-1,1,-1,3,-1,4,-1,8]
09:44:32 <benzrf> [#haskell]
09:44:35 <benzrf> oops
09:44:38 <Iceland_jack> no, intersperse...
09:44:44 <breadmonster> benzrf: ?
09:44:53 <Iceland_jack> IP92:
09:44:53 <Iceland_jack> > intersperse (-1) [1,3,4,8]
09:44:54 <lambdabot>  [1,-1,3,-1,4,-1,8]
09:45:09 <IP92> that's not exactly what I need as output
09:45:14 <Iceland_jack> Yeah my bad IP92
09:45:16 <guampa> Cale: re "Don't think of an IO String value as a "String wrapped in an IO"", it's better instead to just think "a String is returned when this IO is performed" ?
09:45:16 <Scriptonaut> guys, I'm learning about functors right now. Is a list a functor?
09:45:22 <Scriptonaut> the list type**
09:45:29 <Scriptonaut> and is Maybe a functor?
09:45:39 <newsham> ?instance Functor []
09:45:39 <lambdabot> Maybe you meant: instances instances-importing
09:45:48 <Cale> guampa: yes
09:45:57 <Scriptonaut> I did :info [], and ya it looks like an instance of functor
09:45:59 <newsham> > fmap (+5) [1,2,3]
09:46:00 <lambdabot>  [6,7,8]
09:46:04 <Cale> guampa: an IO String value is a description of something which could be done in order to produce a String result
09:46:06 <newsham> > fmap (+5) (Just 1)
09:46:08 <lambdabot>  Just 6
09:46:14 <IP92> Iceland_jack: have you got any other ideas?
09:46:22 <newsham> ?src fmap Maybe
09:46:22 <lambdabot> Source not found. Are you on drugs?
09:46:25 <newsham> :(
09:46:28 <Cale> guampa: and which in the meantime, can have arbitrary effects on the world
09:46:28 <guampa> thx Cale
09:46:36 <Scriptonaut> so fmap is taking a function to convert ([] a) to ([] b)
09:46:45 <Scriptonaut> where [] is the functor
09:46:57 <Scriptonaut> or the type constructor
09:47:23 <newsham> ?src Maybe fmap
09:47:23 <lambdabot> fmap _ Nothing  = Nothing
09:47:23 <lambdabot> fmap f (Just a) = Just (f a)
09:47:27 <Scriptonaut> and in this case ([] b) just so happens to be the same as ([] a)
09:47:29 <newsham> ?src [] fmap
09:47:29 <lambdabot> fmap = map
09:47:51 <newsham> if you want an example with diff types, "fmap show"
09:47:54 <Cale> We actually probably could make a practical IO data type which had some primitive means of representing FFI calls
09:48:05 <Cale> Actually, didn't hugs do that?
09:48:16 <Taneb> Any how idea how to make something that works like how I imagine "class (Eq (f a)) => Foo f" works work?
09:48:20 <Cale> I forget, I'm pretty sure at least some implementation of Haskell has done something like that :)
09:49:16 <Cale> sssilver: Anyway, the idea is that you can imagine that there's some interpreter for IO actions in the runtime system that is taking apart the IO action called main, pattern matching on it, and carrying out the effects that are described.
09:49:23 <GuglielmoS> :r
09:49:44 <Scriptonaut> thanks newsham
09:51:29 <Yuras> Taneb: (Eq b, b ~ f a) => Foo f
09:51:41 * hackagebot Unixutils 1.52.4 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.52.4 (DavidFox)
09:52:01 <Taneb> Yuras, "Not in scope, typevariable b"
09:52:07 <Taneb> Or a, for that matter
09:53:02 <IP92> anyone got any ideas how to define such a function that fun [1,3,4,8] == [-1, 1, -1, 3, 4, -1, -1, -1, 8, -1], basically replicate 10 (-1) and replaces at indices provided in the original list?
09:53:03 <Scriptonaut> guys, I'm looking at the definition of class Functor, this is fmap's type: fmap :: (a -> b) -> f a -> f b  . Is there pattern matching going on here? Because when you actually use fmap, you are passing it something like (Just "blah"), and it takes out the functor (Just), and changes the value ("blah") to something else
09:53:18 <Iceland_jack> IP92: You can cons (-1) to the front, sorry for late reply:
09:53:18 <Iceland_jack> > (-1) : concatMap (\a -> [a,-1]) [1,3,4,8]
09:53:20 <lambdabot>  [-1,1,-1,3,-1,4,-1,8,-1]
09:53:41 <IP92> it's still not the same
09:53:52 <marchelzo_> Does anyone know of any good resources for learning to write a programming language interpreter in Haskell?
09:54:08 <Scriptonaut> interpreter or compiler?
09:54:18 <Scriptonaut> I know there's a good guide to learn how to write a scheme interpreter in haskell
09:54:31 <Scriptonaut> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
09:54:36 <Iceland_jack> Ooh I need to run IP92, I wish I'd been more helpful
09:54:45 <IP92> Np
09:54:48 <xauth> IP92: map (\x -> if (x `elem` [1,3,4,8]) then x else (-1)) [0..9]
09:55:33 <IP92> thanks xauth
09:55:33 <tommd> marchelzo_: http://dev.stephendiehl.com/fun/
09:56:03 <xauth> I suppose a list comprehension would be clearer...
09:56:25 <newsham> clarity prob not needed for his homework problem, xauth
09:56:27 <marchelzo_> Scriptonaut, tommd, thanks. I'll check these out.
09:56:41 * hackagebot encoding 0.8 - A library for various character encodings  http://hackage.haskell.org/package/encoding-0.8 (DanielWagner)
09:57:40 <xauth> newsham: anything but a list comprehension is probably an indication of not having done the work yourself. :)
09:58:55 <newsham> > let fun xs = [if n `elem` xs then Just x else Nothing | n <- [1..10]] in fun [1,3,4,8]
09:58:57 <lambdabot>  [Just x,Nothing,Just x,Just x,Nothing,Nothing,Nothing,Just x,Nothing,Nothing]
09:59:06 <newsham> > let fun xs = [if n `elem` xs then Just n else Nothing | n <- [1..10]] in fun [1,3,4,8]
09:59:07 <lambdabot>  [Just 1,Nothing,Just 3,Just 4,Nothing,Nothing,Nothing,Just 8,Nothing,Nothing]
10:00:28 <xauth> Ew. Lambdabot is printing free variables?
10:01:23 <xauth> > [1,x,2]
10:01:24 <Scriptonaut> could someone please confirm if pattern matching can occur in a function type?
10:01:25 <lambdabot>  [1,x,2]
10:01:33 <Scriptonaut> specifically this: fmap :: (a -> b) -> f a -> f b
10:01:52 <kadoban> Scriptonaut: What do you mean?
10:02:03 <newsham> do you mean "do the a's all have to be the same?"
10:02:07 <xauth> Scriptonaut: the f comes from the class declaration.
10:02:23 <Scriptonaut> kadoban: the f a and f b parts. Lets say we're using Maybe. Maybe is f, and a is whatever type it takes
10:02:31 <Scriptonaut> so in the function implementation, they can be split up that way
10:02:46 <newsham> your question isnt very clear :(
10:02:54 <Scriptonaut> my bad, I just started haskell a few days ago
10:03:00 <Scriptonaut> I'll try to gather my thoughts
10:03:11 <kadoban> Scriptonaut: Yeah, I'm not sure I'm understanding. Can you show an example of what you're wondering if you can do? I'm thinking yes, but‚Ä¶
10:03:27 <newsham> ?type fmap
10:03:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:03:59 <newsham> fmap can take on any type that fills in a type "a" and another type "b" (could be the same type) and any "f" that is a Functor instance.
10:04:11 <newsham> so, for example:   (Int -> Char) -> Maybe Int -> Maybe Char
10:04:27 <xauth> > (x + y)
10:04:29 <lambdabot>  x + y
10:04:33 <Scriptonaut> ok, ya so in the implementation of fmap, does it take advantage of the fact that in the type definition, you have f a, and fb, so that it might be implemented like: f ((a -> b) a)
10:04:53 <newsham> oh, you're asking how the implementation works?
10:04:58 <Zekka> The assumption is that you somehow use the function to apply the operation to the first value you get
10:04:59 <Scriptonaut> ya
10:05:20 <Scriptonaut> ok, but the function is only being applied to the a right
10:05:25 <newsham> so there are different impls of haskell, and they can and do things differently, and for your question I dont know the ansewr :)
10:05:28 <Zekka> i.e., if the function is succ and f a is SomeConstructor 'x', then you're expected to get (SomeConstructor 'y')
10:05:29 <Scriptonaut> and then returning a b, and that b is passed to f
10:06:03 <Zekka> Scriptonaut: You can write very bad Functor instances which still compile, but generally if there are any 'a's in the structor the function is replied to them and the result has the same shape as the start point
10:06:10 <Zekka> (same shape meaning that fmap id x == x)
10:06:19 <Zekka> in the structure*
10:06:23 <Zekka> is applied*
10:06:24 <Scriptonaut> ah
10:06:27 <Zekka> god I can't talk today
10:06:46 <xauth> Scriptonaut: perhaps you're confused about what f is? It is not a function but a type constructor.
10:06:53 <Zekka> fmap f (Just _) = f (error "Screw you, losers!")
10:06:54 <Scriptonaut> no that part I understand
10:07:19 <Zekka> er, Just (f (error "Screw you, losers!"))
10:07:34 <Zekka> That's an example of an fmap definition that will compile but isn't lawful
10:07:47 <Scriptonaut> does "f a" mean (a functor and a parameter), or does it mean the results of passing a parameter 'a' to functor 'f'
10:08:13 <Zekka> Scriptonaut: "f a" means -- for f as some type taking another type, and a a type, the type gotten by passing a to f
10:08:24 <Zekka> In this case f is a functor type
10:08:36 <newsham> some types are parameterized.  like you dont just have "Lists" you have "Lists of _____"
10:08:56 <Scriptonaut> ah, ok I think I geti t
10:08:58 <Zekka> So [] is an example of a potential type that wants another type if it's going to be a type
10:09:12 <Zekka> and [Int] is [] once it's been given a type
10:09:25 <newsham> "Functor f => f a" is a type where you have a parameterized type "f" which is a functor, and parameter "a"
10:09:32 <newsham> such as "List of Int"
10:09:34 <tomphreek> analogies with generics not welcomed here?
10:09:54 <Scriptonaut> ah, alright
10:10:04 <Zekka> f is a lot like a constructor -- Just :: a -> Maybe a, so Just isn't a Maybe but if you feed it something you get one
10:10:18 <Zekka> f isn't quite a concrete type but if you feed it a concrete type you get one
10:10:42 <Zekka> (f :: * -> * in kindspeak)
10:10:57 <kadoban> Scriptonaut: An example matching f and a is Maybe and Int. So Maybe is a Functor instance, it matches the f, Int is the type that's kind of, contained in the Maybe. f a <===> Maybe Int
10:11:14 <Scriptonaut> ah, ok yes, that's what I was wondering about
10:11:17 <Scriptonaut> the matching
10:11:42 * hackagebot mbox 0.3 - Read and write standard mailbox files.  http://hackage.haskell.org/package/mbox-0.3 (GershomBazerman)
10:11:55 <Zekka> Yeah, minding that the rules aren't quite the same as value-level pattern matching even though you can draw the analogy
10:12:13 <newsham> ?data MyType a = OK a | BadError String deriving Show
10:12:13 <lambdabot> Unknown command, try @list
10:12:16 <newsham> ?let data MyType a = OK a | BadError String deriving Show
10:12:19 <Scriptonaut> I was curious if that matching was used later in the implementation. Like perhaps: fmap fun (f a) = (f (fun a))
10:12:20 <lambdabot>  Defined.
10:12:36 <newsham> ?type OK 'c'
10:12:37 <Zekka> isDoubled [] = False; isDoubled (x:x:xs) = True; isDoubled (x:xs) = isDoubled xs
10:12:37 <lambdabot> MyType Char
10:12:45 <Zekka> you can't do that prologuey stuff on the value level
10:12:56 <newsham> ?type OK
10:12:58 <lambdabot> a -> MyType a
10:13:05 <Zekka> But if you say a function is (a -> a -> b), Haskell will specialize all the 'a's to the same thing for you
10:13:28 <Zekka> Scriptonaut: Well, it's used to check that the implementation is type correct
10:13:38 <Zekka> I don't know what else you think it could reasonably be expected to do
10:13:39 <Scriptonaut> ah, alright
10:13:42 <newsham> script:  in:   (a -> b) -> f a -> f b         both the f's will have to be the same thing
10:13:46 <kadoban> Scriptonaut: That pattern matching is on a different level. So, only if there are value constructors that help. You can't directly use the 'f' from the type as a constructor to pattern match
10:14:15 <Zekka> For a lot of types it's pretty hard to write a type-correct wrong implementation of Functor without introducing nontermination
10:14:16 <Scriptonaut> ya, that part makes sense. It's onlhy for checking the types are right
10:14:31 <Zekka> So don't get despondent if that sounds like a pretty weak check
10:14:54 <Scriptonaut> thanks guys
10:15:20 <newsham> ?let instance Functor MyType where fmap f (OK x) = OK (f x); fmap f (BadError e) = (BadError e)
10:15:21 <lambdabot>  Defined.
10:15:39 <newsham> > fmap show (OK 25)
10:15:41 <lambdabot>  OK "25"
10:15:49 <Scriptonaut> can you not curry fmap?
10:15:52 <Scriptonaut> I thought you could
10:15:53 <newsham> ?type fmap show
10:15:55 <Scriptonaut> since you can curry  map
10:15:55 <lambdabot> (Show a, Functor f) => f a -> f String
10:16:02 <Zekka> Scriptonaut: It's just as curried as any function
10:16:10 <Zekka> Are you asking why you can't write fmap show OK 25?
10:16:23 <Zekka> Because you can write that but it means something different and probably won't typecheck
10:16:29 <Scriptonaut> o0h nvm I misread newsham's code
10:16:34 <Scriptonaut> I haven't gotten to errors yet
10:16:53 <Zekka> Scriptonaut: Things to note -- a functor isn't obligated to do anything with the function
10:16:56 <hyPiRion> > let f = fmap show in f (OK 35)
10:16:58 <lambdabot>  OK "35"
10:17:15 <Zekka> @let data Nope a = Nope
10:17:16 <lambdabot>  Defined.
10:17:28 <Zekka> @let instance Functor Nope where fmap f Nope = Nope
10:17:29 <lambdabot>  Defined.
10:17:39 <Zekka> @let nope x = Nope
10:17:41 <lambdabot>  Defined.
10:17:43 <Scriptonaut> oh cool, I understand that
10:17:47 <Zekka> > fmap (+20) (nope 42)
10:17:50 <lambdabot>  No instance for (GHC.Show.Show (L.Nope b0))
10:17:50 <lambdabot>    arising from a use of ‚ÄòM533161673508562792321887.show_M5331616735085627923...
10:17:50 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
10:17:59 <Zekka> > fmap (+20) (nope 42) :: Nope Int
10:18:00 <lambdabot>  No instance for (GHC.Show.Show (L.Nope GHC.Types.Int))
10:18:00 <lambdabot>    arising from a use of ‚ÄòM437063058354553213421899.show_M4370630583545532134...
10:18:02 <MrMetric> ClaudiusMaximus: That Moebius thingy looks neat
10:18:07 <Zekka> whoops, forgot to derive show
10:18:25 <Zekka> uh, but anyway, Nope is the zero-effort Functor that never does anything useful
10:18:27 <newsham> ?let instance show (Nope a) where show _ = "Nope"
10:18:27 <lambdabot>  Parse failed: Illegal instance declaration
10:18:35 <newsham> ?let instance Show (Nope a) where show _ = "Nope"
10:18:36 <lambdabot>  Defined.
10:18:40 <shachaf> It's very useful (by the name Proxy).
10:18:55 <Zekka> I was just being goofy, it's totally useful
10:18:58 <Zekka> just like Const is useful
10:19:14 <Zekka> > fmap (+20) (nope 42) :: Nope Int
10:19:17 <lambdabot>  Nope
10:19:20 <mniip> is there some sort of Monad ((,) a)
10:19:33 <jle`> mniip: there is, but it's not in base for some reason
10:19:35 <jle`> (for monoid a)
10:19:40 <Zekka> mniip: I think it takes a monoid constraint but yeah
10:19:45 <jle`> the corresponding Applicative instance is in base
10:19:47 * jle` shrugs
10:19:57 <Zekka> You need to be able to pull an a out of thin air and associatively join two of the a
10:20:03 <mniip> dang
10:20:11 <mniip> having something similar in Prelude would be nice
10:20:16 <jle`> ikr
10:20:23 <jle`> there's one in the Platform
10:20:28 <jle`> but it has a newtype wrapper
10:20:39 <Zekka> @let data WouldntYouRather b a = WouldntYouRather b deriving (Show, Eq, Functor)
10:20:41 <lambdabot>  Defined.
10:20:42 <jle`> but, why?
10:20:57 <jle`> i'm just kidding, the one in the platform is more general
10:21:11 <Zekka> > fmap (+20) (WouldntYouRather "take a cruise in Jamaica instead?") :: WouldntYouRather String Int
10:21:13 <lambdabot>  WouldntYouRather "take a cruise in Jamaica instead?"
10:21:40 <Zekka> Scriptonaut: This is the Const functor, which similarly never uses your mapping function other than for its type
10:22:21 <Scriptonaut> ahh
10:25:39 <Scriptonaut> I just did :t [] and :t Just. Shouldn't :t [] be [] :: a -> [a]
10:25:57 <Scriptonaut> :t Just seems to make sense, it's a constructor, ready to take a concrete type
10:25:58 <lambdabot> parse error on input ‚Äò,‚Äô
10:26:01 <Scriptonaut> I figured [] was the same
10:26:33 <jle`> Scriptonaut: have you ever done [] 5?
10:26:44 <jle`> [] is a constructor on the type level
10:26:53 <jle`> but it's just a value on the value level
10:27:05 <jle`> er, it's a constructor too
10:27:08 <jle`> but it doesn't take any arguments
10:27:10 <jle`> > []
10:27:11 <lambdabot>  []
10:27:13 <Scriptonaut> oh
10:27:20 <jle`> you are probably thinking of `Maybe`
10:27:25 <jle`> which is a type constructor on the type level
10:27:26 <Scriptonaut> I forgot that [] is also an empty list
10:27:32 <jle`> mhm
10:28:22 <Scriptonaut> is there a way to check the type of the constructor
10:28:31 <newsham> ?type Just
10:28:32 <lambdabot> a -> Maybe a
10:28:33 <jle`> there's a sort of analogous concept of "type signatures" on the type constructor level, they use kinds...so Int is *, Maybe is * -> *, [] (the type constructor) is  * -> *
10:28:37 <newsham> ?type Nothing
10:28:38 <lambdabot> Maybe a
10:28:53 <jle`> Maybe Bool is *
10:29:04 <jle`> if you're looking for that, then the ghci command is `:k`
10:29:20 <newsham> ?kind Maybe
10:29:21 <lambdabot> * -> *
10:29:21 <Scriptonaut> ah thanks
10:29:25 <newsham> ?kind Maybe Int
10:29:26 <lambdabot> *
10:29:35 <ClaudiusMaximus> MrMetric: thanks :)
10:29:46 <jle`> it does trip you up a bit when you start with haskell...the fact that there are two "worlds"/"levels"/namespaces
10:29:50 <jle`> (at least two)
10:30:01 <jle`> there's teh value world, of Just, Nothing, True, [1,2,3]
10:30:11 <jle`> and the type world of Maybe, Bool, [Int], []
10:30:27 <newsham> wouldnt everything be simpler if we just allowed types and values to share the same space? ;-)
10:30:35 <newsham> then we could put values in our types and types in our values!
10:30:37 <jle`> what's confusing is when people create two identifiers of the same "name" in two different worlds
10:30:46 <jle`> data MyType a = MyType Bool a
10:30:56 <newsham> jle: (), [], etc.. :)
10:31:01 <Scriptonaut> that is seriously confusing, heh
10:31:13 <Scriptonaut> jle`'s last line
10:31:15 <jle`> you made MyType a * -> * type constructor in the type world, and MyType :: Bool -> a -> MyType a in the value world
10:31:17 <scott> newsham: dependently typed languages actually do that and it actually does simplify everything
10:31:22 <jle`> yet people do that all the time :O
10:31:24 <newsham> scriptonaut: there are some languages that allow values and types to be intermixed.
10:31:40 <newsham> scott: simple like a post graduate fellowship
10:31:59 <newsham> simple like undecidability
10:32:00 <scott> newsham: I find idris simpler than haskell with extensions like datakinds and type families
10:32:04 <jle`> people name their value (or data) constructors the same as their type constructors all the time.  like who does this
10:32:24 <newsham> thats true, the ad-hoc movement towards dep types is definitely not simple.
10:41:19 <osa1> true, working with a real dependently typed language often feels simpler than managing a dozen type system extensions in Haskell.
10:42:41 <orzo> do you guys speak from much experience?  i'm interested in dependent types but i'm very novice at this point
10:43:38 <osa1> I'm doing Coq occasionally, I don't have any running programs, I formalize stuff and write proofs.
10:44:29 <ReinH> osa1: is that because dependent types are simpler or because languages without dozens of extensions are simpler?
10:44:41 <ReinH> I think you're comparing unalike things
10:44:58 <johnw> orzo: I'm using dependent types heavily in one project
10:45:04 <ReinH> johnw: o/
10:45:11 <johnw> it makes some things simple, and some things really much harder
10:45:34 <johnw> if you design your types wrong, you can build yourself into puzzles that are incredibly difficult to solve
10:45:40 <scott> I find the dependent types collapse a lot of special cases in haskell into the same thing. there's just fewer special cases in idris, which is all I mean by simpler
10:45:53 <scott> closed type families and type aliases are all just plain old functions
10:46:05 <scott> err, type aliases are just normal definitions
10:46:08 <johnw> for exampel, I'm using n : nat, Fin n types in several places, and I sure wish I'd never done that
10:46:54 <orzo> regarding dependent types, it seems to me that idris is to haskell as haskell is to c++
10:47:16 <scott> I'm not sure what haskell is to c++
10:48:01 <ReinH> I can't make sense of that analogy
10:48:08 <orzo> c++ started with a simple language and added lots of type extensions until it had a very powerful macro language with a very awkward syntax
10:48:09 <johnw> yeah, I really can't either
10:50:43 <orzo> haskell one-upped c++ by comming fresh with a powerful type system and very elegant syntax
10:50:54 <orzo> now idris is doing that to haskell
10:51:38 <orzo> does the analogy make sense now?
10:51:47 <johnw> not really
10:51:57 <josephle> but idris has practically the same syntax as haskell...?
10:52:06 <johnw> Idris lacks laziness by default, which is a great source of Haskell's elegance to me
10:52:49 <orzo> disputing the analogy and claiming it makes no sense are different things
10:53:09 <johnw> orzo: what is the purpose of this discussion?  If you want to use Idris, there is #idris
10:53:25 <orzo> i tried for a bit
10:53:28 <davean> orzo: It doesn't make full sense as a lot of C++'s problems come from refusing to break code. Haskell has gotten back about that but can still sorta manage it.
10:53:36 <davean> *has gotten bad
10:54:14 <orzo> idris is not ready for me and idunno if it ever will be
10:54:22 <orzo> i need better error messages like ghc gives me
10:54:55 <mniip> hmm
10:55:12 <mniip> is there any way to collapse (Fractional a) => a into a Double or a Float
10:55:16 <mniip> without explicit constraints
10:55:50 <davean> mniip: A) why would you want to do that, B) how do you define "explicit constraints"
10:55:58 <mniip> ::Float
10:56:23 <davean> mniip: well, is a monomorphic function an explicit constraint?
10:56:28 <davean> I mean, it is
10:56:42 <davean> Thats exactly what unification is
10:56:46 <newsham> heheh
10:56:56 <newsham> "I need better error msgs ... like ghc"
10:57:00 <lambdafan> wait, say that again. I came in in the middle.
10:57:00 <newsham> never thought i'd see the day
10:57:07 <davean> The only thing that might make the code compile and NOT be an explicite constraint is a defaulting rule?
10:57:15 <lambdafan> davean: about unification, what were you saying?
10:57:34 <davean> lambdafan: That a monomorphic function is ~= to a type constraint.
10:57:45 <mniip> a similar thing for int is toEnum
10:57:54 * lambdafan nods
10:58:00 <davean> lambdafan: Its just another way to attach the type
10:58:05 <mniip> I think
11:00:36 <MrMetric> @src head
11:00:36 <lambdabot> head (x:_) = x
11:00:36 <lambdabot> head []    = undefined
11:00:56 <MrMetric> Is head faster than using !! 0?
11:00:56 <davean> mniip: I mean, one COULD say "I need something that ..." and then the compiler's optimizer could pick the one it thinks is best, but we don't have anything like that.
11:02:17 <davean> MrMetric: without some notable optimization, yes, clearly.
11:02:49 <MrMetric> @src (!!)
11:02:49 <lambdabot> xs     !! n | n < 0 = undefined
11:02:49 <lambdabot> []     !! _         = undefined
11:02:49 <lambdabot> (x:_)  !! 0         = x
11:02:49 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:04:15 <davean> MrMetric: in theory, one could optimize that at compile time.
11:04:44 <MrMetric> davean: Does GHC do that?
11:04:51 <davean> MrMetric: Why would you ever use (!!) if head made sense though?
11:05:20 <MrMetric> davean: I think head makes less sense than !! 0 in my case
11:05:34 <MrMetric> I suppose it doesn't really matter
11:05:43 <byorgey> MrMetric: then use !! 0.  The difference (if there is any) is almost certainly not worth worrying about.
11:06:12 <orzo> both can be annoying, if take 1 also can make sense, you're better off
11:06:22 <MrMetric> byorgey: Well, hlint is bugging me about it
11:06:29 <davean> if you can just replace !! 0 with head ... well, you'd never want to check for the 0 case seperately and thus this would only make sense to talk about in the 0-only case ...
11:06:40 <byorgey> MrMetric: haha, I see
11:06:55 <shachaf> GHC probably doesn't inline (!! 0)
11:07:08 <shachaf> It doesn't optimize (reverse []) to [].
11:07:24 <davean> MrMetric: put it this way, if we're having this discussion, something smells about the code to me
11:07:27 <byorgey> MrMetric: the real answer is that you should reorganize your program so that you need neither head nor !! 0.  Both can crash when given an empty list.
11:07:29 <ReinH> MrMetric: or consider using a safe version like listToMaybe or headMaybe
11:07:41 <ReinH> Unless you are managing that invariant elsewhere
11:07:49 <MrMetric> What I actually want to do is read command-line arguments
11:07:59 <ReinH> MrMetric: yeah, then you definitely don't want either head or !!
11:08:04 <MrMetric> Right now, this consists of:
11:08:04 <MrMetric> read (args !! 0) :: Integer
11:08:08 <shachaf> byorgey: How would you organize e.g. map (\x -> (head x, length x)) . group?
11:08:15 <ReinH> MrMetric: That can blow up in two different ways
11:08:17 <byorgey> MrMetric: then you should pattern-match on the list of arguments, and do something sensible in the case of the empty list
11:08:24 <shachaf> byorgey: I suppose your answer might be to use NonEmpty.
11:08:24 <davean> MrMetric: oh god
11:08:28 <davean> MrMetric: NO NO NO NO NO
11:08:36 <orzo> heh
11:08:43 <MrMetric> :[
11:08:48 <byorgey> shachaf: no, that is one of the few cases where I condone the use of head
11:08:58 <MrMetric> I looked at some GetOpt examples, but it looks too complicated
11:09:01 <shachaf> byorgey: Hmm, a good name for a function :: Eq a => [a] -> [NonEmpty a] might be semigroup
11:09:10 <byorgey> shachaf: hehehe
11:09:18 <ReinH> getArgs >>= \case { [] ->  handleEmpty; [x] -> handleOneArg; [x,y] -> handleTwoArgs }
11:09:53 <ReinH> (with another case for n args)
11:10:18 <orzo> \case { [arg] -> handleOneARg; _ -> outputUsage }
11:10:25 <ReinH> right
11:10:28 <MrMetric> I want to be able to do this: -c 10 -e 3 -i 9999 -r 512
11:10:32 <MrMetric> I got it pretty easily in C++
11:10:42 <ReinH> MrMetric: use optparse-applicative
11:10:43 <geekosaur> optparse-applicative?
11:10:59 <davean> MrMetric: ... you did something pretty easily in C++. I think you might have found you didn't really do what you think you did :)
11:11:04 <MrMetric> I'm guessing it's an applicative option parser
11:11:08 <MrMetric> What does applicative mean?
11:11:16 <MrMetric> davean: Relatively easily
11:11:30 <byorgey> MrMetric: optparse-applicative is nice, there's also  http://community.haskell.org/~ndm/cmdargs/
11:11:39 <MrMetric> I did argument parsing with a some nested loops :P
11:11:51 <MrMetric> Wait, no
11:11:59 <byorgey> MrMetric: don't worry what applicative means yet
11:12:01 <MrMetric> It's just 1 loop for my latest thing, with lots of if/else
11:12:57 <MrMetric> byorgey, ReinH: The optparse-applicative example has syntax that I don't know :[
11:13:10 <MrMetric> <$> and <*>?
11:13:25 <orzo> those are good to learn
11:13:27 <voidzero> :t (<$>)
11:13:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:13:30 <MrMetric> I don't think I can Google‚Ñ¢ those
11:13:33 <davean> MrMetric: you can just do the case-statement approch: its not deeply broken (just inflexable and bad) and its trivial
11:13:41 <orzo> MrMetric: google Control.Applicative
11:13:42 <davean> MrMetric: you'll probably be happier learning optparse-applicative though
11:14:01 <voidzero> applicative is also a subject covered in learn you a haskell
11:14:18 <MrMetric> voidzero: I found that book to be too boring to read much of
11:14:41 <vkldf> what are a few must-know libraries for general haskell development?
11:14:50 <MrMetric> vkldf: base
11:15:01 <C-Keen> does anyone know how to work around this error: http://paste.call-cc.org/paste?id=260eacc577347ac437daeec6cb8fb118634efa71 ?
11:15:03 <ski> MrMetric : `(<$>)' is another name for `fmap'
11:15:15 <MrMetric> ski: Okay, I'll search fmap
11:15:19 <ski> > (10 *) <$> [0,1,2,3]
11:15:21 <lambdabot>  [0,10,20,30]
11:15:26 <ski> > (10 *) <$> Just 5
11:15:27 <lambdabot>  Just 50
11:15:28 <Hijiri> MrMetric: have you tried the guides in https://github.com/bitemyapp/learnhaskell ?
11:15:32 <ski> > (10 *) <$> (3,4)
11:15:33 <lambdabot>  (3,40)
11:15:37 <vkldf> MrMetric: other than base :p
11:15:43 <ski> > (10 *) <$> Left 3
11:15:44 <tomphreek> I found learn you a haskell amasing. I wasn't plannig on using haskell - I just had a book in my library so I started reading it. It made me try haskell :)
11:15:44 <lambdabot>  Left 3
11:15:45 <Clint> vkldf: containers
11:15:46 <chrisdone> hey ski =)
11:15:46 <vkldf> thats a given
11:15:48 <ski> > (10 *) <$> Right 4
11:15:49 <lambdabot>  Right 40
11:15:59 <ski> hiya, chrisdone
11:16:02 <vkldf> ok containers, what else? I need like 3 - 5
11:16:06 <Clint> transformers
11:16:13 <vkldf> ok
11:16:18 <voidzero> robots in the sky
11:16:23 <Hijiri> acme-php
11:16:30 <vkldf> Clint: lens?
11:16:45 <ski> MrMetric : `fmap' roughly means : apply this given function to all the elements of a "container", returning a new one with all the results
11:16:57 <ReinH> vkldf: text, bytestring, containers
11:16:59 <Clint> vkldf: i'd hardly call lens must-know
11:17:02 <ClaudiusMaximus> vkldf: maybe see what comes with haskell-platform
11:17:06 <MrMetric> ski: Oh, okay
11:17:07 <voidzero> lens is convenient though
11:17:13 <MrMetric> Hijiri: I'll hav a look
11:17:16 <Hijiri> lens is nice
11:17:26 <ski> MrMetric : for a parser, `fmap' "appends" a post-processing step to the parser, to apply to the returned value when (if) the parser has succeeded
11:17:28 <davean> MrMetric: http://lpaste.net/8595343227135983616 I in no way recomend that style, but it should be something you udnerstand already and it probably does what you tried to approximate in C++ better.
11:17:28 <Hijiri> on a related note, what useful things can I do with IndexedLens?
11:17:39 <voidzero> http://blog.jakubarnold.cz/2014/07/14/lens-tutorial-introduction-part-1.html
11:17:40 <davean> MrMetric: I strongly recomend you learn a proper option parser though
11:17:48 <vkldf> what about some io libraries like pipes, threading libraries?
11:17:58 <Clint> split is pretty useful
11:18:12 <ski> MrMetric : so if you have `"12"' as input, and a parser that can parse this into a number `12', then if you `fmap (10 *)' on this parser before parsing the input, then you'll get `120' as answer instead
11:18:23 <vkldf> i heard 'conduit' mentioned a lot is that an important library?
11:18:26 <MrMetric> davean: Does that work with the args in a different order?
11:18:57 <Hijiri> conduit fills a similar role to pipes, but I think with more utilities for resource safety?
11:19:07 <ski> MrMetric : makes any sense ?
11:19:12 <glguy> Hijiri: You can get the "index" of the value a lens is focusing on
11:19:21 <davean> MrMetric: No, but it could easily.
11:19:28 <Hijiri> glguy: what are some neat things I can do with index info?
11:19:31 <davean> MrMetric: You'll really want a proper parser though
11:19:37 <vkldf> okay - containers, transformers, split, conduit, pipes - thanks
11:19:41 <Hijiri> I have an i -> IndexedLens i s a
11:19:54 <MrMetric> davean: I wish I could just use inline C++ :P
11:19:55 <Hijiri> that sticks the index with the Indexable
11:20:26 <glguy> Hijiri: it just threads the index around for you. You can use an index with things like itoListOf, ifoldrOf, asIndex, withIndex
11:20:34 <orzo> MrMetric: you could do a Data.Map.fromList args
11:20:36 <orzo> heh
11:20:46 <Hijiri> glguy: ah, ok
11:20:48 <Hijiri> thanks
11:21:18 <MrMetric> orzo: I'll check it out (although some of my arguments are supposed to be flags)
11:21:27 <ReinH> Hijiri: well, you can do obvious index-related things
11:21:31 <ReinH> > [1,2,3] & ix 0 +~ 1
11:21:32 <lambdabot>  [2,2,3]
11:21:41 <Hijiri> :t ix
11:21:42 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
11:21:59 <glguy> ix isn't "indexed" in the same way
11:22:02 <Hijiri> focuses on the element of that index?
11:22:03 <ReinH> glguy: ah
11:22:46 <ReinH> glguy: I guess I don't understand the difference between at and ix
11:22:58 <glguy> ix is a traversal and at is a lens
11:23:42 <glguy> ix doesn't focus on things that don't exist, at does and allows you to add things that don't exist or remove things that do
11:23:46 <orzo> MrMetric: use groupBy to spearate the list into groups matching arguments and then turn that into a Map
11:24:03 <ReinH> glguy: ah
11:24:23 <glguy> > set (at 'a') Nothing (M.singleton 'a' 'b')
11:24:25 <lambdabot>  fromList []
11:24:31 <ReinH> Right.
11:24:31 <glguy> > view (at 'c') Nothing (M.singleton 'a' 'b')
11:24:33 <lambdabot>  Couldn't match type ‚ÄòData.Map.Base.Map
11:24:33 <lambdabot>                         GHC.Types.Char GHC.Types.Char
11:24:33 <lambdabot>                       -> t‚Äô
11:24:38 <glguy> > view (at 'c') (M.singleton 'a' 'b')
11:24:41 <lambdabot>  Nothing
11:31:38 <sssilver> Hey guys, what's the idiomatic way to avoid the redundancy on #2 and #3? https://dpaste.de/zbwZ
11:31:57 <lpaste> orzo pasted ‚Äúquicky argument parsing‚Äù at http://lpaste.net/120098
11:32:17 <glguy> sssilver: Add a fallthrough case at the end: myLast _ = error ...
11:32:47 <sssilver> perfect -- thanks glguy!
11:33:49 <orzo> MrMetric: does my paste appeal?
11:34:09 <MrMetric> orzo: Neat
11:34:52 <MrMetric> orzo: I can't really read it, but I'll paste it in and use it anyway
11:34:54 <MrMetric> Thankies
11:35:42 <glguy> orzo: Just be careful, different versions of base can produce different results when you use groupBy like that
11:37:09 <MrMetric> I'm using ghc version 7.11.20150204
11:37:21 <orzo> glguy: can or do?  because i'm pretty doubtful of do
11:38:06 <glguy> orzo: The argument order to some of the by functions has changed in the past
11:39:29 <Zoetrope> Has anyone been following Rust closely? Does anyone have an opinion on how not implementing HKTs yet has affected the language? I'm specifically looking at things like the try macro
11:40:22 <c_wraith> Zoetrope: mostly, it hasn't been too bad.  There is just some code that less-generic than possible.  Just about everything that would be a functor/monad/whatever has all the functions available already
11:42:09 <c_wraith> Zoetrope: though it does mean tricks like those derived from Essence of the Iterator Pattern (ie, lens) can't exist yet.
11:42:16 <Zoetrope> Oh okay that's reassuring
11:42:52 <Zoetrope> I could live with that for now, as long as the APIs are there
11:43:30 <vkldf> whats a simple way to apply a function of type [a] -> b to a list [T a] ?
11:43:43 <vanila> is T a functor?
11:43:50 <vkldf> no
11:43:58 <c_wraith> then good luck!
11:44:02 <vanila> i dont think you can apply it
11:44:11 <Clint> what is T?
11:44:11 <glguy> vkldf: In general there's no reason for a "T a" to have any "a"s
11:44:13 <Zoetrope> What is T?
11:44:14 <vkldf> should it be a functor? (this is my type)
11:44:25 <vkldf> its a tree
11:44:32 <Zoetrope> Yeah it's a Functor probably
11:44:41 <vkldf> okay ill look into that
11:44:42 <josephle> can you write a map for your tree? :)
11:44:51 <josephle> that preserves the structure
11:44:53 <vkldf> the thing is
11:45:01 <vkldf> im not trying to walk over each T in the list
11:45:28 <Cale> vkldf: What would be the type of the result of the operation you're interested in?
11:45:29 <vkldf> I have a list of T a - where T is a constructor
11:45:29 <shachaf> You don't have [a], so you can't use a function :: [a] -> b
11:45:32 <Cale> Or the complete type?
11:45:42 <shachaf> So if you want to use that function, you'll need to get [a] somewhere.
11:45:59 <josephle> one possiblity is getting yourself a (T a -> a) function
11:46:05 <vkldf> well what i can do is create a new list by extracting the value
11:46:15 <vkldf> T a - is a constructor with parameter a
11:46:20 <aisqwe> if Applicative is a superclass of Monad why is IO instance of Applicative has its pure defined as return? isnt this a cycle?
11:46:41 <shachaf> aisqwe: Applicative isn't a superclass of Monad, and whether it is or isn't, that isn't a cycle.
11:46:49 <shachaf> A cycle would be return = pure; pure = return
11:47:08 <vkldf> data BT a = T a (BT a) (BT a) | E - thats my data structure
11:47:34 <shachaf> And how do you want your function to work?
11:47:44 <johnw> cstrahan_: ping
11:47:45 <josephle> hmm, I beginning to understand what you want
11:47:57 <shachaf> You have a list of trees, but your function takes a list of "a"s. What do you want to happen?
11:48:05 <vkldf> yes
11:48:08 <vkldf> exactly
11:48:18 <aisqwe> what is the advantage of Monad over Applicative?
11:48:27 <shachaf> That's a question about desired behavior, not about Haskell.
11:48:29 <vkldf> its a general function that applies another function to the root of each tree
11:48:37 <shachaf> The best way to start is to give at least one example.
11:48:40 <c_wraith> aisqwe: the difference between the types of (<*>) and (>>=)
11:48:47 <Hijiri> what type do you want the result to be?
11:49:15 <vkldf> [BT a] -> b any type
11:49:15 <c_wraith> aisqwe: (>>=) is strictly more powerful as an operation.  Therefore, it imposes more restrictions.
11:49:30 <josephle> vkldf, the root?
11:49:39 <vkldf> yea josephle
11:50:00 <josephle> so you want to extract the root from each tree into a list?
11:50:08 <shachaf> vkldf: Give an example. Values, not types.
11:50:25 <vkldf> josephle: that is one way that i currently have it - but im wondering if i can do this without creating a new list
11:50:27 <shachaf> I have this list: [...], and this function: ..., and I want this result: ...
11:50:52 <vkldf> okay ill make an example 1 sec
11:51:21 <Zoetrope> vkldf: I wouldn't so much be worried about creating new lists in Haskell, generally
11:52:17 <shachaf> Oh, if you already have an existing correct implementation, that's even better than an example.
11:53:56 <vkldf> http://lpaste.net/120101
11:54:53 <vkldf> so I want to go through a list of trees and execute a function for the root of every tree
11:55:32 <vkldf> the function prints the value of the roots for example
11:55:35 <x77686d> Anybody know of any good documents with practical tips for beginners on understanding Haskell type errors?  I'm looking for something to pass along to my class.  Things like "Add/remove a function's type specification." and "Try clauses one at a time." come to mind.
11:56:17 <LordBrain> why not have the second parameter of traverse just be a->b ?
11:56:24 <Hijiri> inline type signatures on terms that aren't type-checking?
11:56:28 <LordBrain> ^ for vkldf
11:57:09 <vkldf> LordBrain: because the function needs the whole list (i have a list of lists and the function is specific to each list)
11:57:11 <LordBrain> hmmm wait
11:59:41 <MrMetric> Holy shit
12:00:22 <MrMetric> I changed something to use Vector (Vector Integer) instead of [[Integer]] (using fromList), and that function goes from 34.6% of the program's run time to 0.3%
12:00:33 <MrMetric> Much faster!
12:00:43 <c_wraith> were you using (!!)?
12:00:49 <MrMetric> Yes
12:00:52 <MrMetric> Twice, actually
12:00:53 <MrMetric> It's a 2D list
12:00:55 <c_wraith> That'd be the problem
12:00:59 <clrnd> well there you go
12:00:59 <MrMetric> I guessed as much
12:01:21 <MrMetric> I looked at info about list. It says it's a linked list, so I guessed that it was causing the speed issue
12:01:30 <c_wraith> That's correct
12:01:51 <vkldf> can I pattern match in a labmda? - \(Cons a b) -> ... ?
12:01:57 <c_wraith> vkldf: yes
12:02:00 <vkldf> kewl
12:02:03 <glguy> What happened when you tried?
12:02:05 <MrMetric> Now more of the program's run time is spent doing useful calculations :]
12:02:07 <c_wraith> vkldf: but you can't provide multiple options
12:02:16 <vkldf> okay
12:02:24 <orzo> vkldf: see also LambdaCase for when you want to handle multiple patterns
12:03:59 <sssilver> Hey guys, does this look like a pretty good solution for 1-based list index access? https://dpaste.de/X4kh
12:04:20 <vkldf> ok cool orzo
12:04:27 <sssilver> (disregard the $ sign at the end pls)
12:05:09 <vkldf> so if the lambda pattern is not matched its a runtime error?
12:05:20 <c_wraith> yep
12:05:24 <vkldf> ok
12:05:35 <djbeau> anyone know of a library that has a data type of the form newtype B b f g a = B (b (f a) (g a)) where B b f g is a functor if f and g are functors and b is a bifunctor?  I tried bifunctors of course, but I did not see anything there that matched
12:05:57 <djbeau> and I would be open to using a couple of nested types, of course
12:06:13 <djbeau> it almost looks like a "product transformer" of sorts
12:14:07 <MrMetric> Haskell has surprised me
12:14:23 <orzo> how so
12:14:25 <MrMetric> My Mandelbrot set renderer is 13√ó faster in Haskell than C++
12:14:49 <MrMetric> 6 seconds instead of 78 seconds!
12:14:51 <sssilver> MrMetric: Can we see the C++ source?
12:14:55 <MrMetric> Noooo
12:15:00 <orzo> heh
12:15:01 <MrMetric> I made the C++ code in 2013
12:15:06 <MrMetric> It is likely that I just screwed up horribly
12:15:14 <sssilver> That's probably what happened
12:15:26 <MrMetric> I just wasn't expecting it to be _that_ bad
12:15:47 <MrMetric> If you really want to see what 2013-me came up with: https://github.com/MrMetric/Fractal/blob/master/main.cpp
12:15:53 <sssilver> it's pretty easy to screw up as bad as you can imagine with C++
12:16:00 <sssilver> if you have a horribly inefficient algorithm
12:16:16 <MrMetric> I'll make a new C++ implementation right now for a better comparison
12:16:19 <wayne> i think it's more about algorithms than language
12:16:35 <wayne> especially if you pick an O(n^2) over an O(n^3) or something
12:17:03 <MrMetric> I will note that the output images are slightly different. My guess: floating-point inaccuracy
12:18:24 <darthdeus_> what do people use these days as a REST client talking to a JSON api?
12:18:50 <vkldf> i heard wreq is good darthdeus_
12:19:04 <darthdeus_> vkldf: I'll check that out, thanks!
12:24:45 <bigs> darthdeus_: seconding wreq
12:25:55 <hsk3> https://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-2000
12:25:55 <hsk3> Quote: "Haskell 2010 is the first revision to be created in this way, and new revisions are expected once per year."
12:25:56 <hsk3> So what happened?
12:25:57 <hsk3> Why were there no Haskell 2011, Haskell 2012, Haskell 2013, Haskell 2014?
12:26:24 <orzo> haskell prime died
12:26:44 <orzo> haskell is now controlled by ghc devs
12:26:46 <orzo> heh
12:27:56 <orzo> the reports were probably a thin veneer over the underlying anarchy anyway
12:28:33 <hsk3> Ok..
12:28:38 <orzo> i think hardly anyone holds themselves to the standard over using ghc extensions
12:29:23 <hsk3> orzo: Does anyone even use any other compiler than GHC?
12:29:24 <orzo> when 2010 came out it was too late to retrain all the people who stopped paying attention to the standard maybe
12:29:45 <orzo> i believe so
12:29:59 <orzo> jhc is notable for making small efficient binaries
12:30:28 <orzo> i believe a fork of it is being used for that purpose by a japanese company
12:30:42 <LordBrain> they stopped using it, switched to ATS
12:30:54 <LordBrain> but jhc is still around sure
12:31:15 <hsk3> ok
12:31:52 <LordBrain> jhc doesnt have a native code gen, it generates c
12:32:11 <LordBrain> as far as i know
12:32:11 <hsk3> Is Haskell a relatively small language? The 2010 report is just 300 pages or so
12:32:19 <hsk3> C++ standard is 1500 pages
12:32:38 <Hijiri> c++ isn't a good comparison for language size
12:33:08 <sssilver> damn Haskell error messages are horrible for newbies :(((((
12:33:15 <LordBrain> is that so?
12:33:18 <LordBrain> what's the error?
12:33:32 <dlowe> I found them horrible until I really tried to read them without skimming.
12:33:46 <LordBrain> are the just too verbose?
12:34:10 <sssilver> https://dpaste.de/rcGX
12:34:32 <sssilver> they're like "(Bool -> Bool -> Bool) -> Bool -> Bool' with actual type `Bool'"
12:34:42 <sssilver> that doesn't even resemble anything I ever wrote!
12:34:55 <orzo> The function `x == last xs' is applied to two arguments,
12:34:56 <orzo>     but its type `Bool' has none
12:35:06 <Hijiri> It says that 'x == last xs' is not a function
12:35:07 <orzo> you tried to use that as a function
12:35:39 <sssilver> which part of it is not a function? the ==? or the last?
12:35:41 <clrnd> sssilver, (&&) -> &&
12:35:56 <orzo> :t (&&)
12:35:57 <lambdabot> Bool -> Bool -> Bool
12:36:09 <orzo> :t (x == last xs)
12:36:10 <lambdabot>     Not in scope: ‚Äòxs‚Äô
12:36:10 <lambdabot>     Perhaps you meant one of these:
12:36:10 <lambdabot>       ‚Äòx‚Äô (imported from Debug.SimpleReflect),
12:36:29 <scott> it'd be nice if the error started with that statement. "Tried to use (x == last xs) as a function, but it is a Bool" and then go into the details
12:36:44 <Hijiri> sssilver: the entire thing together is not a function
12:36:52 <LordBrain> i have sometimes thought they might be better made to stick out with curse language, like "Type Mismatch: \n Expected type: bla bla \n type: bla" you know skip complete sentences.
12:36:53 <Hijiri> you tried to use (x == last xs) as a function
12:37:03 <orzo> scott: maybe, but in general it sometimes gets that hint wrong
12:37:27 <scott> LordBrain: yeah, it could be a lot less wordy
12:37:27 <sssilver> Hijiri: how so? is (a == b) a "use as a function"?
12:37:41 <osa1> mask function is weird. it masks exceptions except when it doesn't.
12:37:50 <orzo> sssilver: you passed (&&) as an argument to it
12:37:54 <Hijiri> sssilver: You have (x == last xs) (&&)
12:38:11 <Hijiri> Thas says "Apply ('x == last xs)' to '(&&)'
12:38:27 <sssilver> but then how do I do logical AND?
12:38:34 <orzo> remove the () around &&
12:38:35 <Hijiri> don't put parentheses around it
12:38:38 <sssilver> oh
12:38:41 <sssilver> lol
12:38:53 <Hijiri> putting parens around an operator turns it into a normal prefix function
12:38:56 <sssilver> I was going by the "when in doubt, enclose it in parentheses" tune
12:39:38 <sssilver> cool, my error message changed
12:39:48 <LordBrain> the errors are really informative, but you have to take the time to read them... we could make more cryptic looking errors that are only useful to the initiated but give a quicker gloss, and that might actually be better.
12:40:16 <clrnd> ghc errors assume the reader has read the entire 2010 report
12:40:27 <LordBrain> haskell errors beat c++ template errors any day
12:40:38 <lush> sssilver: what's your error msg now?
12:40:54 <osa1> so is Socket's recv interruptable?
12:41:12 <clrnd> well yeah, and python's no errors philosophy
12:41:33 <fmapE> Does anyone have a handy Haskell/sed/perl/* script to escape '/'s in paths in Haddock comments that Haddock tries to parse as italics?
12:41:44 <orzo> pa (x:xs) =  x == last xs  &&  pa (init xs)  -- Order of precidence: application, ==, &&
12:43:41 <sssilver> OK it says "No instance for (Eq x) arising from a use of `=='", which is I guess a weird way to phrase that my list items need to implement the == function.
12:44:26 <orzo> you should write a blog entry detailing your learning attempt and reactions to error messages as they come
12:45:02 <vkldf> okay guys here as breadth-first traversal of a binary tree i wrote - http://lpaste.net/120103 - any comments? How can I improve?
12:45:09 <dxld_> sssilver: you need to add an (Eq x => ...) constraint to your function's type
12:45:12 <sssilver> haha perhaps orzo
12:45:23 <sssilver> yeah dxld_ figured already :)) thanks!
12:46:06 <orzo> sssilver: like this, https://news.ycombinator.com/item?id=7595098
12:46:10 <Hijiri> :k (=>)
12:46:11 <lambdabot> parse error on input ‚Äò=>‚Äô
12:46:25 <Hijiri> Constraint -> * -> *?
12:47:37 <orzo> :k ->
12:47:38 <lambdabot> parse error on input ‚Äò->‚Äô
12:47:42 <orzo> :k (->)
12:47:43 <lambdabot> * -> * -> *
12:47:44 <monochrom> no, => still stays as syntax punctuation and not a function name
12:47:59 <monochrom> or a type name
12:48:06 <LordBrain> i don't know, i think our messages are potentially overly newbie friendly in the sense that i mentioned earlier... complete sentences do actually convey something in english, where as we might be better served to have more codes that make for quicker glosses by the initiated, as i think there's only so far the other approach can go. :/
12:48:11 <sssilver> orzo: totally, actually there have been peculiarities worth sharing.
12:49:12 <sssilver> LordBrain: they are actual sentences, but somehow they use words before most haskell books introduce them.
12:49:28 <sssilver> like linguistically at this point "No instance for * arising from use" makes little sense to me
12:49:48 <sssilver> because I don't understand what's an instance, and what it's like to "arise from use".
12:50:04 <sssilver> an instance of a variable? probably not
12:50:09 <scott> I think ghc errors could remove a lot of the words from their sentences without losing readability (in fact, gaining a lot by making errors more concise)
12:50:16 <LordBrain> sssilver, its an instance of a type class
12:51:00 <scott> I like rust's approach with relatively concise errors followed by an [E0042] error code which can be googled and `rustc --explain E0042` gives more detail as well
12:51:09 <vkldf> sssilver: i think its a perfectly clear message if you know the terminology.. you cant expect haskell to use the same terminology as java or c++
12:51:19 <scott> you only need the verbose --explain error when you're learning, and then once you know you'd rather have short errors
12:51:35 <LordBrain> makes sense scott
12:51:55 * hackagebot process-streaming 0.6.6.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.6.6.0 (DanielDiazCarrete)
12:52:27 <monochrom> as long as (+), say, has type involving some type class, an error message caused by misusing (+) cannot avoid talking about type classes or instances.
12:52:50 <sssilver|> vkldf: actually it feels like it's the other way round. I'm a C++/Python programmer, and I feel like if I wasn't used to their messages, it would have been easier for me
12:52:57 <sssilver|> I do find Rust messages awesome, I don't remember ever misunderstanding what they meant.
12:52:59 <orzo> i forget what language it was,  but i used a compiler once that would output source text and put a ^ underneath where the problem occured
12:53:09 <sssilver|> although my mileage with Rust is minor (just implemented a Tetris clone)
12:53:29 <monochrom> my solution would be to provide beginners no general Num (+), but rather one (!+!) for specifically Int, one (.+.)  for specifically Double, etc. then the error messages will talk about Int and Double specifically.
12:53:44 <vkldf> sssilver|:  thats what im talking about - other languages use the same terms as in haskell but for difference concepts
12:53:46 <scott> orzo: clang and rust will both underline the entire expression in question with ^ and ~
12:53:59 <Cale> monochrom: My solution would be to tell beginners about type classes sooner
12:54:04 <sssilver|> orzo: Rust does that
12:54:08 <orzo> scott: well it wasn't one of those
12:54:16 <sssilver|> Cale: I know about type classes actually
12:54:50 <sssilver|> Cale: the problem is, nowhere in that message there's a mention of the term "type class"
12:54:58 <sssilver|> which is the term that you read in the book
12:55:07 <LordBrain> well Eq is a type class
12:55:17 <monochrom> a book chapter on type classes surely mentions instances, too
12:55:21 <vkldf> sssilver|: i think 'instance' always refers to 'instance of a type class' in haskell
12:55:24 <monochrom> and conversely.
12:55:27 <hodapp> hrmph. I'm in the awkward position of having a record, but sort of kind of wanting to be able to iterate over its fields
12:55:32 <LordBrain> but okay, i wont talk, because of course the errors make a lot more sense to the people who already know haskell
12:55:35 <Cale> sssilver|: Oh, which message?
12:56:00 <orzo> it could say that == is provided by class Eq but it could not deduce Eq x from [x] -> Bool
12:56:02 <Hijiri> hodapp: if the fields are the same type you could make a traversal over them
12:56:04 <sssilver|> "No instance for (Eq x) arising from a use of `=='"
12:56:18 <hodapp> Hijiri: they're not all the same type, just a lot of them
12:56:38 <LordBrain> orzo, see what happens tho in this process of newbie-fying the errors, they get even more verbose...
12:56:40 <Cale> sssilver|: ah, okay, but Eq is a type class, and instances always refer to type class instances
12:56:50 <Hijiri> would it make sense to group the ones of the same type together?
12:56:56 <Hijiri> meaning-wise
12:57:15 <Cale> But yeah, maybe it should say "No type class instance (Eq x) ..."
12:57:40 <monochrom> I think this is an unreasonable comlaint.
12:57:47 <sssilver|> http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101 -- Not a single use of the word "instance" in the meaning used by the error message
12:58:07 <hodapp> Hijiri: in some sense. I'm already grouping some together but likely I'd have several groupings
12:58:12 <sssilver|> I'm not complaining by the way. I'm just sharing my experience.
12:58:28 <sssilver|> I understand it may totally be because I lack the brainpower the average person posesses.
12:58:34 <Hijiri> hodapp: you could have several Traversals that each focus on a different grouping of members
12:58:38 <sssilver|> in fact I probably do
12:58:40 <Cale> sssilver|: Yep, that's a good point about the book :)
12:58:45 <hodapp> Hijiri: I'll check this out
12:59:09 <hodapp> Hijiri: where is Traversal?
12:59:11 <vkldf> sssilver|: haskell literally has a keyword 'instance' which you use to make a type an instance of a type class
12:59:42 <monochrom> oh well
12:59:44 <vkldf> its strange that that page doesnt mention it :S
12:59:55 <sssilver|> perhaps I should pick another book, but I really enjoy reading this one so far :))
12:59:59 <Cale> sssilver|: You do kind of need to know the basics of how type classes and instances work on Day 1 or 2 of programming in Haskell in order to understand the error messages you'll likely run into, and a lot of books save those details for later.
13:00:14 <vkldf> sssilver|: i found this the most simple and straightforward intro to haskell: https://www.haskell.org/tutorial/index.html
13:00:19 <lush> sssilver: it will be mentioned a couple of chapters later: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
13:00:30 <sssilver|> aha!
13:00:33 <Cale> Yeah, the Gentle Tutorial isn't very gentle
13:00:37 <orzo> we could take all of ghc's error messages and then write an intro to the language built around giving the reader the ability to understand the messages
13:00:46 <Cale> But it does get you exposed to a lot of ideas quickly
13:00:51 <Cale> which is probably good
13:00:58 <hodapp> Hijiri: Control.Lens.Traversal?
13:01:24 <Hijiri> hodapp: yes
13:01:43 <hodapp> Hijiri: would I have to convert to a Lens then?
13:02:13 <Hijiri> if you're focusing on multiple elements at the same time you would need a Traversal
13:02:14 <lush> sssilver: I really like LearnYouAHaskell ;) I'm no Pro-Haskeller as well, but I think it's a good starting point to dive into haskell
13:02:16 <Cale> sssilver|: A lot of people really like LYAH, so if you're enjoying it, feel free to stick with it, but yeah, all the presentations have their flaws
13:02:49 <Cale> It's actually really nontrivial coming up with a good order in which to explain everything that needs explaining
13:02:55 <hodapp> Hijiri: yes, but does that mean I require a Lens?
13:02:58 <LordBrain> an error message focussed presentation is a pretty good idea actually
13:03:20 <Hijiri> hodapp: a Traversal is less powerful than a lens - all Lens are Traversals, but not the other way around
13:03:21 <lush> sssilver: I guess learning from several resources will be the most benefiacial approach of learning haskell^^
13:03:23 <chrisdone> most of the experienced people here learned with comparatively awful, dry books
13:03:35 <chrisdone> it doesn't matter too much if you're tenacious
13:03:38 <Hijiri> a Lens has to focus on one thing only
13:03:42 <shachaf> I liked Hutton's _Programming in Haskell_
13:03:47 <Cale> Right, there was almost nothing available when I started out
13:03:48 <Cale> heh
13:04:07 <bennofs> Does (a -> Maybe a) -> a -> [a] exist somewhere?
13:04:09 <sssilver|> fair enough!
13:04:11 <Cale> I think the Gentle tutorial existed :)
13:04:17 <Cale> yeah, it did
13:04:23 <LordBrain> same here.. the gentle introduction
13:04:26 <bitemyapp> Cale: the Gentle tutorial definitely existed.
13:04:29 <chrisdone> i started on YAHT and Gentle in combination
13:04:30 <vkldf> I actually find technical papers like http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf to be very helpful to learning haskell in general
13:04:32 <lush> sssilver|: And understanding haskell just can be quite tough at the beginning, I bet you're not lacking of brain, but of patience :)
13:04:33 <bitemyapp> that came out super-duper early.
13:04:43 <Cale> Yeah, it was written in 2000, and I started in 2001 or so
13:04:48 <LordBrain> some other things too i think, they were just popping up, new, still working out the kinks i think
13:05:01 <chrisdone> the main useful thing YAHT had was exercises
13:05:13 <chrisdone> at the time i started, that was what everyone in here recommended
13:05:32 <Cale> YAHT came along once I already had a pretty okay grasp of the language
13:06:00 <Cale> But I found it useful at the time nonetheless
13:06:15 <sssilver|> lush: I have plenty of patience/grit. I actually think I lack the brain, and it's my patience that helps me stay afloat. Most of you guys are probably just way smarter than me. It's a very probable reality that I accept and have no problem with.
13:06:37 <lush> sssilver|: However... keep going :P
13:06:45 <LordBrain> the best tutorials are written by people who are willing to basically expose all their goofs and go over them... if you have the experience in the public eye, it sort of gives the benefit of experience to the reader, so you need a beginner to write that.
13:06:48 <lush> sssilver|: .. and stay patient
13:06:49 <vkldf> sssilver|: what are you talking about... genetics? lol
13:06:51 <lush> ^^
13:06:55 <lush> vkldf: +1 :D
13:07:20 <sssilver|> vkldf: idk, childhood experiences, education, other circumstances that shaped ability.
13:07:33 <chrisdone> sssilver|: you can make yourself feel better by looking in the old irc logs of experienced haskellers asking dumb questions
13:07:40 <vkldf> sssilver|: so 'more experienced in these things' rather than 'just smarter'
13:07:47 <LordBrain> however, for the beginner to write such a thing doubles or quadruples his workload in learning
13:08:08 <Cale> sssilver|: Eh, I disagree. How good people are at things is directly related to how much time they spend working on them, and the physical differences between people are for the most part almost inconsequential compared to what experience they have.
13:08:26 <vkldf> ^ yup
13:08:45 <Cale> sssilver|: For what it's worth, it took me about 2 months to get to the point where I felt like I could start doing useful stuff in Haskell, and about a year to be comfortable.
13:09:03 <Cale> sssilver|: (I've been programming in Haskell since around 2001 or so)
13:09:12 <monochrom> I used hugs at the beginning
13:09:14 <lush> sssilver|: what's your programming experiences before haskell?
13:09:27 <vkldf> you could take a baby from a hunter-gatherer tribe somewhere in the jungle and with the right environment it would become a phd in math
13:09:33 <chrisdone> 2001-12-02 09:00:23 <Cale> how do i monad web?
13:09:39 <sssilver|> lush: C++/Python for about 12 years, mostly IO-bound scalable network services
13:09:42 <voidzero> vkldf, not really, genetics do somewhat matter
13:09:43 * chrisdone grins slyly
13:09:51 <monochrom> hahaha chrisdone
13:09:52 <vkldf> voidzero: nope, no evidence that they matter
13:09:56 <voidzero> ok
13:09:59 <voidzero> then you and i disagree :)
13:10:00 <vkldf> voidzero: even if they matter we dont know how
13:10:02 <lush> sssilver|: so nothing purely-functional? (nice experiences btw ^^)
13:10:15 * chrisdone watches Cale think "did I really say that?"
13:10:21 <Cale> heh
13:10:55 <zipper> Yo people who write yesod what do you do when you run into errors because I'm not into stack overflow and the yesod channel seems dead.
13:11:09 <sssilver|> lush: nah, nothing. Actually after 12 years of programming I hate to admit that I still struggle coming up with moderately complex recursive algorithms. Which is one of the big reasons I decide to pick up Haskell. Another one being that OOP never felt too good to my taste.
13:11:09 <MrMetric> Make it less dead!
13:11:18 <Cale> zipper: Have you asked about them here?
13:11:28 <voidzero> sssilver|, just give yourself time
13:11:56 * hackagebot base-prelude 0.1.16 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.16 (NikitaVolkov)
13:12:00 <voidzero> and I don't know what use it is to compare yourself to be less than the 1500+ people in this channel
13:12:03 <chrisdone> zipper: you mean when there're errors in template-haskellg enerated code?
13:12:40 <lush> sssilver|: so I think it's completey "natural" that you struggle learning haskell
13:12:41 <lush> :>
13:12:48 <Cale> My respect for OOP has increased as I figured out what the really essential part of what it was by encoding it in Haskell. Of course, at the same time, my respect for the design of "OO" programming languages went down.
13:12:55 <sssilver|> voidzero: I never said I was less. I said most of the 1500 guys are probably overall "smarter" as programmers. And, you're right, there's no use in saying that.
13:13:10 <lush> sssilver|: It's just rly hard to stop thinking imperative, and start thinking functional I guess
13:13:15 <voidzero> yeah, that is what i meant, indeed. ;)
13:13:16 <hodapp> Cale: that's what happened for me as I read some of Alan Kay's work.
13:13:19 <Cale> I think most of the typed OO languages are really bad at OOP
13:13:22 <zipper> chrisdone: All I know is just that my browser is pulling a 404 on `/static/css/bootstrap.css.map`
13:13:37 <zipper> I'm getting feedback in #yesod thanks
13:13:40 <scott> Cale: what do you feel is the essential part, if you can put it into a small amount of words?
13:13:56 <sssilver|> lush: well some Javascript experience helps, so I'm not struggling THAT bad. My struggles are mostly fears of "OK this whole thing makes sense, but how am I gonna sit down and practically write a TCP server?"
13:14:18 <Cale> scott: Values defined by the manner in which they respond to messages (or implement methods, to say the same thing using different words)
13:14:43 <hodapp> "OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things."
13:14:46 <chrisdone> zipper: oh, you can ignore that. it's a sourcemap thing. mapping generated code back to the original
13:14:48 <hodapp> that's Alan Kay's definition, when asked.
13:14:58 <sssilver|> with most languages, after reading the fundamentals, you can kinda sit down and write a Tetris. I still feel like I'm miles away from implementing Tetris in Haskell :)
13:15:32 <chrisdone> hodapp: i've thought that erlang satisfies that definition well. it's all message passing and process isolation
13:15:41 <Cale> scott: The problem I have with most typed OO languages is that they tie method implementations to the types of objects, which creates irrelevant distinctions that subtyping then helps out with, but you end up with all the problems which subtyping has in general.
13:15:41 <lush> sssilver|: haha well I rly understand what you mean lol
13:15:54 <lush> sssilver|: +1 for me btw
13:15:55 <hodapp> chrisdone: I suspect it does.
13:15:56 <zipper> chrisdone: The generated code is trying to map to the original code?
13:16:02 <hodapp> Cale: and then "don't subtype! compose!"
13:16:02 <catsup> sssilver|: read this https://github.com/ekmett/lens/blob/master/examples/Pong.hs
13:16:22 <Cale> scott: The type of an object should essentially tell you which methods it has, and what their types are, but not how they're implemented.
13:16:27 <zipper> I thought erlang was functional. You guys are talking about OO things in Erlang?
13:16:29 <Cale> (at least in my opinion)
13:16:38 <chrisdone> zipper: .map is a file that contains a source map from minified code to the original code. i'm not sure what's triggering the browser to request it, though
13:16:42 <voidzero> sssilver|, you know what's funny? My English is pretty good, but if I'm surrounded in a (chat)room by people who are clearly able to speak more fluently, my English tends to become worse than it normally is.
13:16:52 <zipper> chrisdone: So erlang can do both functional and OO like scala?
13:16:53 <Cale> zipper: I'm not sure anyone mentioned Erlang
13:17:04 <hodapp> chrisdone mentioned Erlang.
13:17:07 <hodapp> http://www.smashcompany.com/technology/object-oriented-programming-is-an-expensive-disaster-which-must-end
13:17:13 <Cale> oh, okay
13:17:13 <zipper> Cale: What hodapp said
13:17:20 <chrisdone> zipper: by the alan kay definition of OO, erlang seems pretty comparable, because it's a matter of sending messages to processes which have their own process state. there isn't any shared memory
13:17:46 <sssilver|> voidzero: omg, same!!!! since I moved to USA, I have the same problem!
13:17:47 <scott> Cale: how does the type tell you how they're implemented in the kinds of languages you'r referring to?
13:17:56 <Cale> You can encode OO pretty well in any language with first class functions and record types.
13:18:02 <voidzero> sssilver|, <grin>
13:18:04 <sssilver|> voidzero: it's so awesome that you said that, now I'm gonna analyze it and tell my wife!
13:18:07 <hodapp> Alan Kay has also talked about how he somewhat regretted calling it "object oriented" because he felt that people then just focused on the "object" part and completely ignored the "messaging" part, which was more central to him than objects.
13:18:08 <sssilver|> good insight my friend!
13:18:11 <Cale> scott: In Java, for example
13:18:18 <zipper> chrisdone: In the #yesod channel I've been told that some browsers request that file. I'm using chromium. Thanks.
13:18:24 <Cale> scott: When you define a class, you define how the methods of that class operate
13:18:27 <zipper> chrisdone: That was a great explanation.
13:18:35 <Cale> scott: and if you want them to behave differently, you make subclasses
13:18:38 <voidzero> sssilver|, yes maybe we can use this as a tool!
13:18:54 <Cale> scott: At the same time, classes are the types of objects in Java
13:19:16 <chrisdone> hodapp: indeed. and at this point OO no longer means his version and the qualification becomes "Alan Kay OO". not that his OO seems like an awesome idea anyway, but definitely orthogonal to the data-behaviour coupling of popular OO lore
13:19:22 <voidzero> or in my case, I just tend to shut up quicker. :)
13:19:35 <chrisdone> zipper: thanks =3
13:19:40 <hodapp> chrisdone: I believe that's called "actor model" now.
13:19:54 <lush> sssilver|: What's your current chapter in LYAH?
13:20:12 <Cale> scott: If I were designing a typed OO language, when you defined a new type of object, you would only give method signatures (like what Java calls an interface), and there would be a primitive way to construct objects of that type by specifying the method implementations.
13:20:24 <sssilver|> lush: I finished "Thinking recursively"
13:20:31 <hodapp> chrisdone: But in general he treated his own 'objects' like they were meant for large components of a system, not for every damn data type ever. An object for him was something large enough that it might meaningfully have its own URL.
13:20:32 <chrisdone> smalltalk also does reflection like that. instead of calling a function you sent it a message that it may interpret literally or evaluate, aiui
13:20:34 <scott> Cale: ah, I see
13:20:39 <Cale> scott: Of course, you can already do this in Haskell by making a record data type, so I don't really need another language. :)
13:20:44 <sssilver|> lush: so, I'm at the beginning of chapter 6
13:20:49 <scott> Cale: that sounds a lot like Rust with traits and trait objects to me
13:21:11 <chrisdone> hodapp: right
13:21:14 <lush> sssilver|: alright, did you get the recursions of chap5 ?
13:21:25 <sssilver|> I think so
13:21:32 <sssilver|> I even did a few exercises
13:21:49 <hodapp> chrisdone: but I found a lot of the early work with Smalltalk and Self to be fascinating in general.
13:21:54 <sssilver|> of course I found out that my solutions were not optimal, but well they were recursive, and they did the job, maybe someday I'll learn the better ways.
13:22:08 <lush> sssilver|: so enjoy reading about higher-order concepts :))
13:22:08 <sssilver|> because right now glancing at the better ways doesn't help much
13:22:14 <Cale> scott: Subtyping makes type inference really terrible, and greatly complicates parametric polymorphism and many other type system features
13:22:22 <chrisdone> hodapp: image-based persistence is pretty interesting =)
13:22:24 <scott> Cale: you mentioned values defined by how they respond to messages... is this equivalent to saying the essential thing OOP gives you is runtime polymorphism / late binding?
13:22:51 <chrisdone> hodapp: comparatively lisp compilers bootstrap from a fresh setup, but i like the idea that there're smalltalk images you can get that someone started running in the 90s
13:23:04 <hodapp> chrisdone: also, the notion that using a system and developing on it interactively can be the same activity is also quite interesting.
13:23:18 <chrisdone> it's like awakening some old demon indiana jones style
13:23:21 <Cale> scott: I guess you could say that. I wouldn't likely use those words, as I don't even think of it as polymorphism.
13:23:53 <chrisdone> hodapp: i feel that is an unexplored area in the static typing world
13:24:14 <chrisdone> hodapp: specifically the problem of migrating live running code from the old type to the new type
13:24:46 <lush> sssilver|: so far LYAH didn't even tell you how to write Hello-World, so I think it's not that surprising that you think you're not able to write a tcp srv :)
13:24:48 <scott> Cale: it's what was called polymorphism in my OOP class, but not to be confused with parametric polymorphism
13:24:57 <voidzero> heh
13:25:04 <Cale> scott: You have a bunch of objects of a single type (i.e. they support the same methods), so there's nothing in the way of polymorphism to talk about then -- they behave differently because they carry around different method implementations.
13:25:09 <voidzero> for me at this point, learning Haskell is 90% reading and 10% 'trying stuff out'
13:25:11 <chrisdone> in emacs lisp i hack on the program i'm using while it's running, but if i change a type i have to be sure i migrated everything
13:25:15 <voidzero> the reading is fun though
13:25:16 <hodapp> chrisdone: Erlang made use of some similar stuff, but yeah, I've yet to see it in the static typing world
13:25:28 <sssilver|> lush: epic -- after your message I've realized that you're right, I can't write "Hello world" in Haskell at this point.
13:25:28 <scott> Cale: right, the type isn't polymorphic at all
13:25:36 <hodapp> Armstrong's thesis on Erlang is a nice read
13:25:38 <Cale> scott: It's not polymorphism just because our type system has changed so that it doesn't need to be :)
13:25:39 <lush> sssilver|: :p
13:25:53 <chrisdone> voidzero: if i had it my way it'd be 90% trying 10% reading
13:25:56 <sssilver|> lush: I did write a nice palindrome checker though ^.^
13:26:09 <dmwit> sssilver|: main = putStrLn "Hello, world!"
13:26:17 <Cale> scott: Whereas before you were forced into introducing new types when all you wanted was new method implementations.
13:26:17 <dmwit> sssilver|: Now you can check that one off your list. =)
13:26:20 <lush> dmwit: pfft <.< :)
13:26:29 <chrisdone> sssilver: hopefully not liftM (==) reverse id
13:26:30 <sssilver|> dmwit: omg, spoilers
13:26:37 <voidzero> chrisdone, still, my experience with other languages is close to none
13:26:38 <dmwit> oooooops
13:26:44 <lush> chrisdone: hehe
13:26:51 <voidzero> i can write you some mad zsh scripts, but that's about it
13:26:52 <sssilver|> chrisdone: https://dpaste.de/0JrR
13:27:02 <chrisdone> voidzero: interesting, so you're learning fresh
13:27:26 <lush> sssilver|: what about sth. like this: pa xs = xs == reverse xs where reverse = ...
13:27:44 <chrisdone> sssilver|: what does pa [1,1] say?
13:28:05 <voidzero> chrisdone, yeah. Tried some Python before, didn't really enjoy it though. I'm a sysadmin of a small project, I have 15 years of Linux and BSD experience, but never really went into programming
13:28:21 <sssilver|> chrisdone: I'm still debugging this, give me a few minutes :) this is what sparked the entire conversation above
13:28:37 <Cale> scott: When you do OO in Haskell, you write functions which construct values of your object type. The arguments to these functions effectively become the "private" data of your objects.
13:28:40 <scott> Cale: it seems like you could achieve this style of OOP in java by using only interface types and using anonymous classes to make the concrete implementations, and forget about defining named class types ever
13:28:46 <scooty-puff> anyone who has used bound: at one point to you call abstract?  on the body of a lambda just after parsing, or when transitioning from a parsed data type to a data type containing Scopes?
13:28:47 <voidzero> so now that my latest sysadmin project is working as it should, I took this challenge
13:28:51 <scooty-puff> *at what
13:29:50 <Cale> scott: Yeah, quite possibly.
13:30:12 <Cale> scott: Of course, living in Java's ecosystem while trying to tie your hands like that might be tough
13:30:27 <scott> Cale: yeah, I'm only considering it theoretically
13:31:36 <Hijiri> doesn't dependency injection do that partially?
13:31:49 <Hijiri> just you would be dependency injecting every method
13:32:06 <Cale> Dependency injection is a fancy term for functions
13:32:23 <eulerfx> is there a name for a function of type [ Either a b ] -> ([a],[b]) (or generalized to any functor)? i was looking at cozip but it doesn't quite fit since it returns a sum rather than product
13:32:41 <chrisdone> well, dependency injection is a fancy term for parametrizing functions
13:32:52 <dmwit> :t partitionEithers
13:32:53 <lambdabot> [Either a b] -> ([a], [b])
13:32:56 <Hijiri> eulerfx: it would have to be generalized to Foldable, if it was
13:33:05 <monochrom> someone should write a paper for "dependency injection by importing a different module" :)
13:33:05 <Hijiri> functor on its own isn't powerful enough
13:33:09 <chrisdone> instead of
13:33:09 <chrisdone> foo = do db <- connectToDB
13:33:09 <chrisdone>          query db ‚Ä¶
13:33:09 <chrisdone> you write
13:33:09 <chrisdone> foo db = query db ‚Ä¶
13:33:15 <chrisdone> therefore the dependency is now provided by the caller
13:33:22 <monochrom> (now all the ML people are going to be all over me...)
13:33:30 <chrisdone> i call this "good abstraction"
13:33:35 <dmwit> :t foldMap (\x -> case x of Left x -> ([x], []); Right x -> ([], [x]))
13:33:35 <chrisdone> but in the java world it has a specific name
13:33:36 <lambdabot> Foldable t => t (Either t1 t2) -> ([t1], [t2])
13:34:08 <hodapp> It is interesting how many things have flashy names in other domains
13:34:26 <hodapp> but in the world of functional languages are so common they hardly even need names
13:34:27 <eulerfx> thx, i've the implementation, but no name
13:34:46 <Cale> Well, we are being a bit glib here
13:35:17 <Cale> In other settings, you can't just write functions because the language doesn't quite let you.
13:35:46 <eulerfx> it seems like cozip, but cozip is: t (Either a b) -> Either (t a) (t b)
13:36:01 <chrisdone> it's a bit sad that one is confronted with a design decision often due to the OO style
13:36:04 <dmwit> You don't like the name partitionEithers?
13:36:14 <chrisdone> rather than just writing a simple function that takes an argument and returns a value and sticking it in a module
13:36:26 <scott> is there a name for something like [Eq x => x]? existential use of a typeclass?
13:36:39 <chrisdone> otoh haskellers are faced with whether to make something monadic or not, so we don't entirely escape that problem
13:36:47 <Cale> I don't know whether it's really the OO style, or again the fact that method implementations have been needlessly tied to the types of the objects.
13:36:48 <dmwit> scott: [()] is a good name for that
13:36:53 <hodapp> chrisdone: that's one criticism in that link I pasted 10-15 minutes ago from smashwords
13:37:03 <chrisdone> scott: impredicative types?
13:37:04 <dmwit> ?google haskell existential anti-pattern
13:37:05 <lambdabot> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
13:37:07 <eulerfx> i haven't seen the name partitionsEither, but it sounds good! (im new to haskell, coding this in f#)
13:37:09 <scott> dmwit: why is that?
13:37:44 <scott> lte me change my example to [Show x => x] since it seems more useful
13:37:49 <scott> let*
13:37:52 <lush> cya guys, bb sssilver| have fun learning haskell ;)
13:37:54 <dmwit> scott: Suppose you have a value, and all you know about it is that its type implements Eq. What can you do with it? Answer: nothing.
13:38:00 <eulerfx> dmwit: thx!
13:38:02 <chrisdone> hodapp: missed it
13:38:03 <sssilver|> take care lush thansk for everything
13:38:03 <tnks> chrisdone: if one can define a law-abiding instance of a monad, why not just do it?
13:38:09 <dmwit> scott: For that one, [Int -> ShowS] is a good choice. =)
13:38:09 <mauke> scott: that's just [String]
13:38:11 <Cale> chrisdone: Making higher order functions monadic isn't trivial :)
13:38:19 <dmwit> scott: And see the link I sent you for a more general answer.
13:38:34 <Cale> Or even not higher order functions
13:38:43 <dmwit> eulerfx: You should have seen it! It was the very first reply to the channel after you asked your question. =)
13:38:58 <chrisdone> tnks: it's more a question of "i have some function to write. should i make it regular old pure haskell and it'll be nice, or should i make it monadic, which is a bit more overhead, but might pay off in the future if i want to have some additional context available"
13:38:59 <Cale> For any given pure function, there will be multiple ways to make it monadic, even after you figure out what the type should be
13:39:05 <scott> would it be less of an antipattern without laziness? [Show x => x] seems distinct from [String] if show were strict
13:39:21 <Cale> Consider for instance map
13:39:27 <eulerfx> dmwit: ahh yes, ooops missed that
13:39:28 <Cale> There's mapM
13:39:29 <tnks> chrisdone: okay, I think I can see this design perspective.
13:39:38 <hodapp> chrisdone: http://www.smashcompany.com/technology/object-oriented-programming-is-an-expensive-disaster-which-must-end
13:39:47 <Cale> But there's also a version which we don't have a name for which puts the effects in reverse order
13:39:55 <chrisdone> i think every haskeller has written out a non-trivial function before and realised they need it to be monadic and cursed a bit
13:39:55 <hodapp> sorry, smashcompany, not smashwords
13:40:18 <Cale> chrisdone: I somehow have stopped running into this problem
13:40:34 <chrisdone> Cale: i've got better at anticipating it ahead of time, yeah
13:40:39 <EvanR> scott: actually, [Show x => x] is not distinct from [String] practically
13:40:45 <EvanR> just use the [String]
13:40:55 <Cale> Well, not just that, I just find I don't need to make things monadic as much?
13:40:55 <EvanR> if they take cpu to compute and they arent used, they wont get computed
13:40:57 <vanila> is lazy by default worth all the trouble?
13:41:06 <Cale> I don't use monad transformers very much any more
13:41:10 <Enigmagic> is strict by default worth all the trouble?
13:41:12 <Enigmagic> :P
13:41:19 <Cale> vanila: YES
13:41:25 <EvanR> strict by default is trouble for the programmer
13:41:32 <EvanR> rather than the compiler implementor
13:41:32 <chrisdone> hodapp: oh, i didn't like that article last time i read it. it's one of those cases where i agree with the guy, he's preaching to the choir at me, but his arguments are not very good and a bit embrassing, and i doubt that people not already in this camp will find it cogent
13:41:42 <Cale> vanila: imo, lazy by default is the only way to really get most of the benefit of laziness
13:42:17 <hodapp> chrisdone: without the flamebait title I quite liked that article
13:42:42 <Cale> vanila: Because whenever it doesn't appear to matter, people will do what is easiest. Most of the benefit of lazy evaluation comes from being able to compose programs from parts more effectively.
13:42:52 <EvanR> hodapp: thats for the link, im actually thinking about making an "oop in haskell" video ;)
13:42:54 <scott> EvanR: I'm not really thinking about practical for haskell. for context I'm trying to relate this to Rust trait objects which seem to me like existential typeclass thingys (a typeclass dictionary for type T + a value of type T)
13:43:00 <chrisdone> hodapp: like this example: multThree :: (Num a) => a -> a -> a -> a; multThree x y z = x * y * z
13:43:00 <chrisdone> hodapp: he just dumps that and then explains currying. and then is like "tada! use non-OOP languages". nothing follows
13:43:03 <vanila> intersting!!!
13:43:03 <Cale> vanila: and if lazy is the default, you have more parts to work with, because people didn't accidentally make things too strict for you
13:43:05 <scott> EvanR: I'm wonder if Rust being strict is what makes this useful now
13:43:09 <scott> wondering*
13:43:14 <toors> is there any way to write this mappend more concisely? http://pastebin.com/sNmULuwi
13:43:14 <EvanR> scott: ah well if were not being practical, then by all means go ahead ;)
13:43:30 <EvanR> scott: yes strict changes a lot of things
13:43:46 <chrisdone> hodapp: which was like a lost opportunity for me, because from that example you could go into why it's nice to have numbers abstracted over a class, which many languages instead do by ad-hoc built-in overloading
13:44:00 <cdx> toors: derive Ord for Status and use mappend = max?
13:44:02 <scott> EvanR: [Show x => x] really is a different thing than [String] if show was strict, isn't it?
13:44:09 <Cale> vanila: As a silly example (silly because this still isn't really a good algorithm, but it's tricky to come up with one-liner examples to explain why architectural things are good, so let's ignore that)
13:44:25 <Cale> vanila: Consider the problem of checking to see if one string is a substring of another
13:44:25 <EvanR> scott: yes, you can make this easier to grok by rewriting [Show x => x] as [x -> String]
13:44:40 <toors> thank you cdx just what i was looking for
13:44:41 <chrisdone> hodapp: if a skeptical reader reads his article and sees that and thinks "well, that's bunk. this haskell buzz is rubbish. i'm going back to c++" i wouldn't blame them
13:44:41 <Cale> vanila: In Haskell, I can write  any (isPrefixOf xs) (tails ys)
13:44:52 <scott> EvanR: or rather [(x, x -> String)]
13:45:04 <EvanR> scott: or rather [(x, x -> String)] right, where x is existential
13:45:06 <scott> EvanR: that makes it really clear to me the strictness of the function matters
13:45:08 <Cubicle> EvanR: rather () -> String
13:45:09 <scott> EvanR: thanks!
13:45:13 <chrisdone> http://augustss.blogspot.co.uk/2011/05/more-points-for-lazy-evaluation-in.html
13:45:17 <Cubicle> [() -> String]
13:45:20 <Cale> vanila: In a strict language, that's awful. If any of those library functions are too strict, then I'll do more computation than the nested-loops-with-early-breaks algorithm would do
13:45:30 <EvanR> () -> String would make more sense in haskell
13:45:43 <monochrom> @quote monochrom boat
13:45:44 <EvanR> if it were strict
13:45:51 <vanila> I see, beacuse this stops when it can
13:45:53 <chrisdone> Cale: the comparison i tend to make is with the Common Lisp LOOP macro
13:46:03 <scott> EvanR: right, you just hide x away in a closure?
13:46:10 <tomphreek> @kind Num
13:46:11 <Cale> vanila: But because they're lazy enough, I can put them together, and have something which is "efficient" (not really as efficient as the best algorithms for this problem, but there are many other cases like this where you can't really do better)
13:46:18 <EvanR> scott: yeah, that makes the types work. can you do that in rust?
13:46:30 <scott> EvanR: I think so
13:46:33 <monochrom> onoes, lambdabot is stuck
13:46:42 * chrisdone glances around nervously
13:46:50 <monochrom> dear int-e, lambdabot is stuck. thanks. ‚ô•
13:46:50 <mauke> tomphreek: * -> Constraint
13:46:53 <hodapp> not sure if I need lenses.
13:46:56 <hodapp> hmmm.
13:47:27 <scott> EvanR: I guess switching from trait objects to collections of closure would be kind of like reifying the vtable manually or something
13:47:35 <Cale> Yeah, CL solves a bunch of problems of this sort by having a gigantic monolithic macro with lots and lots of features, but you really don't want to have to extend that macro.
13:47:38 <tomphreek> mauke: I was hoping to see what I need to implement to make my type instasnce of Num
13:47:47 <EvanR> scott: well youd be simulating haskell thunks ;)
13:48:01 <scott> EvanR: good point
13:48:05 <hodapp> Cale: what macro's this?
13:48:07 <mauke> tomphreek: http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#t:Num
13:48:11 <Cale> hodapp: LOOP
13:48:11 <johnw> LOOP is like an old, comfortable blanket; it's nothing you'd ever show your guests, but it's enjoyable to use
13:48:24 <mauke> I didn't find LOOP enjoyable to use :-(
13:48:32 <johnw> i like it
13:48:35 <johnw> i use it in elisp
13:48:39 <hodapp> huh
13:48:41 <tomphreek> way too much :/ I just want (+) to work
13:48:50 <mauke> tomphreek: then you don't want Num
13:49:05 <monochrom> tomphreek: you can also use ghci. ask it ":info Num"
13:49:08 <eulerfx> what is the name of a function of type: (a -> x) -> (b -> y) -> (a,b) -> (x,y)
13:49:23 <hiptobecubic> tomphreek, sounds like maybe you'd want Monoid?
13:49:25 <lambdabot> No quotes match. stty: unknown mode: doofus
13:49:25 <bitemyapp> eulerfx: that looks bifunctor-y
13:49:26 <lambdabot> * -> Constraint
13:49:28 <mauke> :t (&&&)
13:49:29 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
13:49:30 <bitemyapp> eulerfx: or arrow-y
13:49:35 <chrisdone> i have a log of arguing why i thin haskell's laziness is better than CL's LOOP
13:49:38 <tomphreek> actually I want my Binary tree to be a ring. with + to be node-wise + and I should be able to scale tree over integers
13:49:40 * chrisdone looks for it
13:49:40 <mauke> :t (***)
13:49:41 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:49:48 <bitemyapp> chrisdone: please link
13:49:56 <monochrom> oh good, lambdabot is back
13:49:56 <dmwit> :t bimap
13:49:57 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
13:50:00 <Cale> While if we want new loop features in Haskell, we just write another list function -- moreover, we're not constrained to just loops/lists, but we can have lazy trees and other structures of all different sorts
13:50:06 <monochrom> @quote monochrom river
13:50:06 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
13:50:06 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
13:50:13 <EvanR> tomphreek: sounds like you want a Functor instead
13:50:21 <scott> is (***) the same as bimap?
13:50:25 <Cale> monochrom: haha
13:50:30 <scott> they just seem to abstract opposite parts
13:50:31 <EvanR> tomphreek: you can lift (+) (*) and any other function not num related to the level of tree with Functor
13:50:47 <mauke> :t [(***), bimap]
13:50:48 <lambdabot> [(a -> b) -> (b' -> c') -> (a, b') -> (b, c')]
13:51:09 <eulerfx> thanks a lot, that was fast! :)
13:51:27 <dmwit> ?hoogle (a -> x) -> (b -> y) -> (a, b) -> (x, y)
13:51:29 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:51:30 <tomphreek> EvanR: I made it a functor but this simple lifting didn't occur to me, even though it's obvious now.
13:51:44 <dmwit> Excellent answer, lambdabot!
13:51:51 <dmwit> Now I know I need to import fgl for this function.
13:51:59 <dmwit> s/import/depend on/
13:52:02 <EvanR> tomphreek: and to get + to work on two trees, you need Applicative
13:52:41 <mauke> ouch, that means pure x = infinite tree
13:53:01 <EvanR> good thing haskell can do that !
13:53:13 <dmwit> You can also lift (+) with align.
13:53:38 <dmwit> http://hackage.haskell.org/package/these-0.4.2/docs/Data-Align.html
13:53:59 <chrisdone> Cale: bitemyapp: vanila: my feelings on macros vs laziness http://lpaste.net/raw/2991077768248164352
13:54:52 <scott> would it make sense for strictness to be shown in function types?
13:54:58 <chrisdone> (context: mishoo's big on Lisp and is very skeptical of Haskell to say the least, but is one of my buddies)
13:55:04 <scott> idris shows laziness in the types
13:55:14 <chrisdone> scott: that'd be neat
13:55:21 <chrisdone> boxedness is shown in the types
13:55:55 <EvanR> chrisdone: find p . map f    does not like the way it looks ? :(
13:56:11 <sssilver|> chrisdone: https://dpaste.de/XSH0 -- works for len(2) lists as well
13:56:22 <Cale> scott: I don't really like that approach
13:56:47 <EvanR> the idris Lazy annotation doesnt tell you anything about the type at all
13:56:49 <Cale> scott: oh, showing strictness instead? Well, we have types with strict parts in Haskell
13:56:53 <chrisdone> EvanR: i think he was responding to something else
13:57:15 <chrisdone> EvanR: some lisp code we were talking about earlier
13:57:19 <EvanR> in idris (ideally) it doesnt matter whether you evaluate it now or later or not
13:57:32 <EvanR> the Lazy annotation is completely a performance issue
13:57:32 <dmwit> Cale: Might be interesting to have a strict arrow, though. -> vs !->
13:57:34 <scott> Cale: I mean something like (a !-> b) if the function is strict
13:57:34 <dmwit> or something
13:57:37 <chrisdone> sssilver|: now what about [1,1,1]? =p
13:57:57 <dmwit> vs !!-> for call-by-value ;-)
13:57:59 <scott> Cale: just so you can tell at a glance at the type
13:58:06 <Cale> Yeah, maybe... do you have subtyping there though?
13:58:17 <Cale> Or explicit coercion?
13:58:18 <dmwit> Let's say no and see where that takes us.
13:58:23 <dmwit> explicit coercion
13:58:37 <scott> even if this was docs only and not understood by ghc I think I'd be happy :P
13:58:44 <sssilver|> chrisdone: uh
13:58:45 <Cale> That's going to be really fun to use
13:58:47 <Cale> lol
13:58:54 <scott> but that's kind of why I questioned if it made sense
13:59:04 <EvanR> scott: how about documentation of totality
13:59:19 <scott> I'd be down with that
13:59:33 <scott> or rather, documentation of partiality
13:59:35 <EvanR> documentation of important stuff is important ;)
13:59:48 <scott> head :: [a] -bad> a
13:59:51 <dmwit> How about our documentation just links to the source and then we can figure out the answers to all of these questions at once.
13:59:54 <dmwit> Oh wait.
14:00:21 <chrisdone> dmwit: that's what they do in javascript
14:00:26 <scott> but then, ghc can't know in general when something is total or partial
14:00:37 <chrisdone> if you want to know what types something has you read the code
14:00:40 <dmwit> Everything is total by the time GHC is done with it.
14:00:49 <EvanR> scott: thats why its documentation, not a type. ideally you dont have partial functions
14:01:02 <EvanR> and you dont need a type
14:01:40 <EvanR> head :: [a] -> Maybe a
14:01:51 <EvanR> head :: NonEmpty a -> a
14:02:16 <EvanR> head :: NonEmpty a => [a] -> a
14:02:20 <EvanR> oops
14:02:26 <vanila> <scott> head :: [a] -bad> a
14:02:30 <vanila> That is how eff works I think
14:02:39 <vanila> it lists all the effects in the arrows themselves
14:02:46 <chrisdone> or head :: List (Succ n) a -> a
14:02:48 <sssilver|> chrisdone: actually it does work for [1,1,1]
14:02:53 <vanila> so it lets you write everything in direct style, rather than using monads
14:03:18 <scott> I've seen a bit of the effects system in idris
14:03:25 <Hijiri> vanila: Eff is still a monad, just parameterized by all the effects it can have
14:03:26 <EvanR> vanila: whats an effect with no argument? () -bad> X ?
14:03:28 <scott> as far as I understood it: monad stacks without any lifting
14:03:30 <scott> or something like that
14:03:37 <Hijiri> but you don't need transformers
14:03:38 <vanila> Hijiri, eff-lang.org this? I don't think it's a monad
14:03:49 <monochrom> yeah, different Eff
14:03:50 <Hijiri> oh, I thought you meant the Eff monad
14:03:52 <Hijiri> sorry
14:04:17 <vanila> EvanR, that is fine - im not sure the question
14:04:26 <vanila> it can throw an exception
14:05:19 <EvanR> vanila: im saying, its nice in haskell monads that "just the effect you want" is just a value, not a function. i was taking "direct style" to mean "call functions" to get effects
14:05:40 <EvanR> getc :: () -> Char
14:06:27 <EvanR> so i was wondering if thats what it was in eff
14:07:00 * hackagebot lockfree-queue 0.2.3.1 - Michael and Scott lock-free queues.  http://hackage.haskell.org/package/lockfree-queue-0.2.3.1 (RyanNewton)
14:07:04 <vanila> getc :: () -> Char  would be a pure function
14:07:12 <vanila> getc :: () -io> Char  would be able to read input
14:07:17 <tomphreek> @src pure :: a -> [a]
14:07:17 <lambdabot> Source not found. That's something I cannot allow to happen.
14:07:40 <Hijiri> does eff and the eff monad have the same theoretical base?
14:08:11 <vanila> hmm well they are definitely simlar, but  dont think they are based on the same thing
14:08:49 <scott> tomphreek: try it like this:
14:08:51 <scott> @src [] pure
14:08:52 <lambdabot> pure = return
14:08:56 <scott> @src [] return
14:08:57 <lambdabot> return x = [x]
14:09:17 <scott> when you're dealing with typeclass methods
14:09:45 <tomphreek> scott: cheers
14:10:14 <Hijiri> I see that in eff you can be polymorphic in the effects in functions, which you don't get with the monad
14:10:32 <Hijiri> so you can just drop in an effectful function and have it unify nicely
14:10:33 <MrMetric> Hey guys, I'm back from university. I've translated my Mandelbrot set renderer to C++. It runs 2√ó as fast as my Haskell implementation, and 26√ó as fast as my C++ implementation from 2013 :[
14:11:32 <voidzero> so.. you must have been happy with your haskell implementation, for a short while at least :-)
14:12:25 <MrMetric> voidzero: Well, now I know that I need to learn more Haskell to improve its speed. The code is shorter than the C++ translation, which I like :]
14:12:26 <benzrf> MrMetric: wow u got 1/2 C++ perf out of haskell, nice :-)
14:12:32 <josephle> do you think haskell helped you design better c++ the second time around?
14:12:38 <MrMetric> josephle: Eeeyup
14:12:47 <MrMetric> I'm pretty sure
14:13:10 <MrMetric> I can try doing it the way I would've done before starting Haskell and compare speed
14:13:15 <MrMetric> But first, I must have a shower!
14:13:22 <NemesisD> is it ever better to use data over a newtype for a single-field record?
14:14:09 <hodapp> whew. I almost reinvented lenses, very badly.
14:14:30 <dmwit> NemesisD: It can be, if you need an extra layer of laziness for some reason.
14:15:34 <dmwit> I can't think of why that might be off the top of my head.
14:16:18 <chrisdone> probably never better
14:16:24 <monochrom> when you are passing data to an overly eager function
14:16:49 <Cale> Which can happen because of seq
14:17:23 * mjrosenb is looking at Control.Event.Handler, and I don't get something.
14:17:24 <monochrom> for example when company policy forces you to use Data.Map.Strict but you need to circumvent it
14:17:25 <Cale> Otherwise, it would need to actually match, so it couldn't be polymorphic to give you the option of passing the other datatype :P
14:17:27 <chrisdone> put another way: if you need it you'll know it
14:17:31 <dmwit> Well, OneTuple exists. So somebody must have wanted it at some point.
14:17:37 <chrisdone> otherwise it's not worth caring about
14:17:54 <scott> "Foo undefined `seq` x" is undefined if Foo is a newtype but not if  Foo is a data? am I understanding correctly?
14:17:54 <Cale> dmwit: I wonder whether that was just written because someone noticed that there was no OneTuples though
14:18:13 <Cale> scott: that's right
14:18:15 <monochrom> correct
14:18:49 <dmwit> scott: Additionally, case undefined of Foo x -> 3 is defined if Foo is a newtype but not if Foo is a data.
14:18:50 <mjrosenb> oh, I think the extra layer of AddHandler is confusing me
14:19:10 <mjrosenb> because if MapIO took a Handler rather than an AddHandler, it would make no sense
14:19:19 <scott> dmwit: anywhere that evaluates to WHNF, right?
14:19:34 <dmwit> scott: Read my example again. =)
14:19:40 <chrisdone> > seq (return undefined :: Identity) () -- Identity is defined as a newtype
14:19:41 <lambdabot>  Expecting one more argument to ‚ÄòData.Functor.Identity.Identity‚Äô
14:19:41 <lambdabot>  Expected a type,
14:19:41 <lambdabot>    but ‚ÄòData.Functor.Identity.Identity‚Äô has kind ‚Äò* -> *‚Äô
14:19:45 <chrisdone> > seq (return undefined :: Identity ()) () -- Identity is defined as a newtype
14:19:46 <lambdabot>  *Exception: Prelude.undefined
14:19:56 <dmwit> scott: Yours is more defined for data. Mine is less.
14:20:05 <chrisdone> @data Identity' a = Identity' a
14:20:05 <lambdabot> Unknown command, try @list
14:20:08 <mauke> > seq (Identity undefined) ()
14:20:09 <lambdabot>  *Exception: Prelude.undefined
14:20:16 <dmwit> scott: (And yours is about constructing values, mine is about destructing them.)
14:20:17 <shachaf> chrisdone: You'd get the same behavior with a strict data type, though.
14:20:20 <mauke> > case undefined of Identity _ -> ()
14:20:21 <lambdabot>  ()
14:20:25 <scott> dmwit: oh weird
14:20:27 <chrisdone> shachaf: sure
14:21:11 <scott> dmwit: so a case always evaluates the thing it's matching for a `data` type even if there is only one constructor?
14:21:18 <chrisdone> although mauke demonstrates a difference with strict types to newtypes ^
14:21:33 <dmwit> scott: Well, unless the pattern doesn't mention a constructor, of course.
14:21:35 <chrisdone> @let data IdentityLazy a = IdentityLazy a
14:21:37 <mauke> I'm just repeating what dmwit said
14:21:38 <lambdabot>  Defined.
14:21:41 <chrisdone> @let data IdentityStrict a = IdentityStrict !a
14:21:42 <lambdabot>  Defined.
14:22:03 <monochrom> evaluates enough for the pattern matching. not completely.
14:22:15 <scott> yeah, that's what I meant
14:22:59 <chrisdone> > case undefined of IdentityStrict _ -> ()
14:22:59 <chrisdone> > case IdentityStrict undefined of IdentityStrict _ -> ()
14:23:00 <chrisdone> > case IdentityLazy undefined of IdentityLazy _ -> ()
14:23:01 <lambdabot>  *Exception: Prelude.undefined
14:23:01 <lambdabot>  can't find file: L.hs
14:23:02 <lambdabot>  ()
14:23:10 * chrisdone scowls at lambdabot
14:23:13 <scott> race condition!
14:23:26 <chrisdone> i had the same race condition in tryhaskell
14:23:35 <chrisdone> darn mueval
14:24:04 <EvanR> thats awful
14:24:34 <chrisdone> > case IdentityStrict undefined of IdentityStrict _ -> () -- anyway
14:24:36 <lambdabot>  *Exception: Prelude.undefined
14:25:10 <mjrosenb> huh, foo -> IO (IO())
14:25:12 <voidzero> vely lude
14:25:31 <EvanR> err on the side of lazy
14:25:37 <dmwit> mjrosenb: IO (IO a) is a nice way to hide some implementation details.
14:25:48 <dmwit> mjrosenb: As opposed to IO Token + Token -> IO a
14:25:54 <shachaf> i,i Fix IO
14:26:02 <EvanR> i agree
14:26:36 <EvanR> IO all the way down
14:27:03 <mjrosenb> dmwit: the constructor AddHandler takes a value of type Handler a -> IO (IO ()), I can write something with that type, but I suspect it isn't going to do what I want?
14:27:27 <dmwit> Well, I can't speak about what you want. =P
14:27:41 * mjrosenb is not entirely sure what should go there either.
14:27:45 <Cale> I rather like how if you want to defer part of an IO action until later, you can simply chop that part out and put it into a do-block which you return at the end (which leads to a type similar to that)
14:27:46 <EvanR> IO (IO ()) could be, set something up and return an action that will shutdown it down
14:28:09 <EvanR> a real life callback
14:28:32 <Cale> right, that's another nice use case
14:28:38 <mauke> but what if I want to shutdown it up?
14:28:49 <mjrosenb> ahh, it looks like that is in fact what they want me to do!
14:28:50 <EvanR> shutdown up us the bomb
14:29:42 <voidzero> take off every zig!
14:30:39 <EvanR> IO Foo isn't the most descriptive type but its so much better than the usual
14:32:59 <tomphreek> is there a connection between applicative functor and an algebraic ring
14:34:14 <chrisdone> what's an algebraic ring in haskell?
14:34:37 <tomphreek> http://en.wikipedia.org/wiki/Ring_%28mathematics%29
14:35:28 <c_wraith> tomphreek: not by itself, but there's the argument that the Alternative class should form a right near-semiring
14:35:37 <chrisdone> lol
14:35:48 <chrisdone> "what's an algebraic ring in haskell?" "here's a ring in mathematics"
14:35:57 <mjrosenb> c_wraith: "near semiring"?
14:36:01 <byorgey> tomphreek: an applicative functor is a generalized monoid, which is much simpler than a ring
14:36:11 <c_wraith> That was the terminology used by the article!
14:36:13 <byorgey> i.e. there's only one operation, not two
14:36:32 <mjrosenb> byorgey: that's called a group.
14:36:47 <byorgey> mjrosenb: what is?
14:36:51 <shachaf> Alternative is a little odd.
14:37:03 <mjrosenb> byorgey: a ring with only one operations.
14:37:13 <mjrosenb> (in math at least)
14:37:23 <byorgey> mjrosenb: a group is a monoid with inverses.
14:37:31 <shachaf> "a ring with only one operation" is a contradiction, because a ring has two operations by definition.
14:37:53 <shachaf> But if you look at what byorgey was saying, "monoid" makes sense. :-)
14:38:35 <EvanR> is that the same thing as a seminearring
14:38:49 <tomphreek> chrisdone: I did quite understand what you mean by haskell, apologies
14:39:14 <byorgey> EvanR: no, a seminearring has two operations, but neither is required to have inverses, and one of them distributes over the other only from one side
14:39:21 <byorgey> as opposed to a semiring where it distributes both ways
14:39:25 <shachaf> I think tomphreek's question was reasonable. Does Applicative (the Haskell class) have something to do with a ring (the algebraic concept)?
14:39:34 <byorgey> I mean from both sides
14:39:40 <shachaf> By itself, not really.
14:39:41 <monochrom> chrisdone: http://hackage.haskell.org/package/algebra is probably as close to "a Haskell answer" as practically feasible.
14:40:20 <EvanR> byorgey: so whats a near semiring
14:40:29 <byorgey> probably the same thing
14:40:39 <byorgey> it probably depends on who you ask ;-)
14:40:40 <monochrom> Haskell is not a good way to express rings, really.
14:41:30 <EvanR> ring is some instance of Algebra f => f a -> a
14:41:32 <byorgey> EvanR: http://www.reddit.com/r/haskell/comments/1ka4q6/a_great_series_of_posts_on_the_power_of_monoids/  for a cool application in Haskell
14:41:49 <mseeks> any super lightweight key-value store recommendations? i'm thinking just a step above a serialized Data.Map
14:43:12 <EvanR> mseeks: acid-state?
14:44:04 <EvanR> you can log modifications to the store to disk, and it will survive reasonable catastrophes
14:44:21 <deech> How do I `cabal install` a package candidate?
14:44:21 <EvanR> and it doesnt serialize the whole Map each time
14:44:27 <monochrom> applicative functor provides no "inverse", not even partial ones. it cannot be related to rings.
14:44:40 <monochrom> or even groups
14:45:16 <mseeks> EvanR: this is pretty cool; i'll check it out
14:45:17 <mseeks> thanks!
14:45:30 <mjrosenb> what is the name of the comments at the top of a .hs file that list compiler flags?
14:45:39 * mjrosenb never remembers what to google
14:45:40 <monochrom> most things in computer science are not going to be analogous to groups, rings, and fields. since the whole point is to have non-invertible operations such as string concatenation.
14:45:44 <Hijiri> pragmas?
14:45:45 <byorgey> mjrosenb: pragmas
14:46:22 <MrMetric> I am back from my shower
14:46:29 <Hijiri> wb
14:47:37 <vanila> monochrom, isn't string concatenation invertible? oh i guess it has a left inverse but not right inverse
14:48:12 <mjrosenb> vanila: that doesn't sound right.
14:48:28 <monochrom> there are more non-invertible examples, for example projection (e.g. (a,b) -> a)
14:48:38 <mjrosenb> x ++ "a" ++ "b" ++ y
14:48:38 <tomphreek> ok say I have a Binary Tree over Double. Then by making pure = treeFromList . repeat (i.e. same value a in every node). and <*> :: BinTree (a->b) -> BinTree a -> BinTree b to just apply a->b in each node. Then I get to add my BinTree's (node-wise) and scale them over doubles. This forms a ring.
14:48:40 <vanila> ++"foo" i can undo by taking "foo" off the end of a string
14:48:46 <scott> vanila: invertible means you could do "foo" ++ "bar" ++ (inverse bar) == "foo"
14:48:55 <scott> (inverse "bar")*
14:48:57 <EvanR> a b = ab. a^-1 ab = b. b^-1 ab = ?
14:49:00 <mjrosenb> vanila: I'm pretty sure there is no value of x nor y that will yeild "a" or "b"
14:49:45 <scott> EvanR: can't be reduced any further
14:51:22 <EvanR> or c^-1 abcde = ? that one really makes no sense
14:51:48 <vanila> oh it's a wording thing: I don't think it's the operation that's not invertible, but the elements
14:52:25 <vanila> i can write a function that is the left inverse of ("foo"++) e.g. drop 3
14:52:39 <vanila> but you can't invert the string "foo" wrt (++)
14:52:40 <tomphreek> monochrom: applicative alone is not enough, but say applicative is f a and a is a ring
14:52:47 <scott> vanila: right, but in a monoid/group you only have (++)
14:53:08 <EvanR> vanila: maybe if ++ were also allowed to remove things instead of just add ;)
14:53:33 <EvanR> scott: in a group that would imply ++ were invertible
14:54:22 <scott> right, but you still wouldn't be able to express (drop 3) if we had a list-like group
14:54:42 <EvanR> im not sure list-like group makes sense
14:54:57 <scott> I'm trying to come up with one :)
14:58:07 <scott> type InvertibleString = [(Bool, Char)] could collapse (True, c) and (False, c) whenever they are adjacent
14:58:34 <scott> inverse [(True, 'h'), (True, 'i')] == [(False, 'i'), (False, 'h')]
14:59:14 <EvanR> seems like just a language for describing group expressions to be evaluateed
14:59:39 <scott> it does look like that
14:59:52 <byorgey> that's exactly what it is.  it's the free group on the set of all Chars.
15:00:25 <Sornaensis> so ghc-mod doesn't seem to work anymore does anyone know what the deal is
15:02:03 * hackagebot liquid-fixpoint 0.2.2.0 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  http://hackage.haskell.org/package/liquid-fixpoint-0.2.2.0 (EricSeidel)
15:03:33 <tomphreek> one of the laws of applicatives is: u <*> pure y = pure ($ y) <*> u. how to read this law with a $
15:03:57 <afp1b> Hello. I have some background in math and extensive experience in programming. I want to learn Haskell because it's quite high level. What is best example of a construction in Haskell that is so abstract, complex, that it does things in a semi-automated way, and connects various areas like file operations and math (that's the only surprising connection I can think of because I don't know the language).
15:04:15 <scott> tomphreek: ($ y) is (\f -> f $ y) which is (\f -> f y)
15:04:24 <tomphreek> scott: thanks!
15:04:35 <vanila> afp1b, http://okmij.org/ftp/continuations/zipper.html#zipper-fs
15:05:34 <MrMetric> With my C++ translation of my Haskell code, I've found that I can add const in front of most vars and constexpr for many functions
15:05:59 <chrisdone> MrMetric: translate your c++ to ATS! =p
15:06:00 <Sornaensis> does anyone here use ghc-mod
15:06:15 <chrisdone> Sornaensis: possibly someone in #haskell-emacs
15:06:21 <EvanR> afp1b: pipes
15:06:57 <MrMetric> chrisdone: I'd rather not :|
15:07:16 <chrisdone> MrMetric: perch√® no? D:
15:07:36 <tomphreek> I worked through applicative functor axioms and it seems that pure [] could have been repeat a rather than [a]. am I right
15:07:37 <MrMetric> @translate perch√® no?
15:07:38 <lambdabot> Unknown command, try @list
15:07:40 <MrMetric> Aww :[
15:08:00 <MrMetric> Google Translate says: why not?
15:08:52 <tomphreek> oh that's what ziplist is for! dah :/
15:10:29 <dmwit> afp1b: http://research.microsoft.com/en-us/um/people/simonpj/Papers/financial-contracts/contracts-icfp.htm
15:13:48 <dmwit> afp1b: There's also that one report detailing a language competition in which the competition judges thought the Haskell entry was pseudocode and didn't realize it was fully executable. ^_^
15:14:45 <EvanR> oh it is isn't it
15:16:35 <Torkable> monochrom: THUNK
15:16:54 <monochrom> thunk : expression :: dependency injection : first-class functions
15:17:11 * EvanR forces Torkable's remark and hopes it isn't bottom
15:18:06 <sebastianrkg> I'm trying to further understand "IO," and I've come to a conceptual gap that I think might exist for me
15:18:24 <monochrom> ooohhh, so HWN is going to stop for a while, until a new editor shows up
15:18:36 <vanila> sebastianrkg, what is it you're not getting?
15:18:56 <sebastianrkg> see, in C++, the way input and output work is relatively the same as it would be in the corresponding assembly code, or at least similiar enough for me to understand what is happening
15:19:08 <sebastianrkg> however, I think the compilation of IO may be very abstract in Haskell
15:19:12 <sebastianrkg> so tell me if I'm right:
15:19:45 <sebastianrkg> Haskell just looks at all functions that are of return type IO a and then comes up with substantially different assembly code that fulfills the semantics of what IO means
15:20:03 <vanila> that's not really true
15:20:19 <EvanR> cout << "hello world" vs syscall after moving location of "hello world" into a register
15:20:43 <EvanR> two misunderstandings
15:20:47 <vanila> sebastianrkg, a way to think about how  haskell works is that the code you write isn't just compiled to assembly
15:21:07 <vanila> sebastianrkg, but that it's compiled to assembly that fits inside some runtime system
15:21:22 <vanila> that runtime includes things that haskell does 'for you' like garbage collection and many others
15:21:58 <sebastianrkg> hmm okay so there is a shell of haskell platform apis that handle that stuff for me?
15:22:03 <vanila> another thing the runtime does is handle IO:  When you write have IO code in  haskell it emits instructions which the runtime will perform and hand results back to your code
15:22:07 <chrisdone> monochrom: new editor: http://haskellnews.org/grouped
15:22:44 <monochrom> but where are the "this week's quotes"?!
15:23:00 <chrisdone> at the bottom
15:23:02 <monochrom> oh damn, that is covered too, just at the end
15:23:03 <sebastianrkg> okay, but there is no part of "putStrLn" where it defines OS components that will then be used for IO?
15:23:12 <chrisdone> haha
15:23:15 <chrisdone> "damn, he's thorough!"
15:23:26 <sebastianrkg> sorry I should be using your name in my posts, vanila
15:23:28 <vanila> sebastianrkg, yeah that's all inside the runtime, all putStrLn does it produce an instruction to print something out
15:23:30 <Cale> btw, what vanila is describing is a good mental model. If you care about how things are actually compiled, it's a little more involved -- there's actually no obvious runtime interpretation of IO action values, but if you want to think of it that way, that does give a good intuition.
15:23:49 <monochrom> god, the Church-Turing thesis has much far-reaching consequences...
15:23:57 <bitemyapp> I'll ask here, is there a way to abort a getLine that won't break an application?
15:24:10 <bitemyapp> actually wait
15:24:13 <chrisdone> catch?
15:24:16 <bitemyapp> I could clear and reprint the prompt
15:24:19 <bitemyapp> n/m
15:24:31 <EvanR> sebastianrkg: getChar is a good example of a primitive IO action because its not a function, which simplifies the situation
15:24:33 <bitemyapp> I needed output occurring asynchronously to appear "above" a getLine prompt.
15:24:34 <EvanR> :t getChar
15:24:36 <lambdabot> IO Char
15:24:48 <EvanR> sebastianrkg: you can think of this as an "assembly instruction" to get a char
15:24:52 <sebastianrkg> vanila & Cale, so is the IO type the endpoint of this interaction with the runtime?
15:25:02 <sebastianrkg> ah, seems like it from that
15:25:03 <chrisdone> bitemyapp: oh, like repl output while retaining the prompt or something
15:25:09 <vanila> the type is just a thing to make sure your program fits together right
15:25:13 <bitemyapp> chrisdone: yes
15:25:20 <bitemyapp> chrisdone: precisely! Do you know the proper way to do this off-hand?
15:25:37 <chrisdone> bitemyapp: i don't, sadly. but would be interested in the answer
15:25:39 <dmwit> ?hackage vty
15:25:39 <lambdabot> http://hackage.haskell.org/package/vty
15:25:45 <dmwit> ?hackage vty-ui perhaps
15:25:45 <lambdabot> http://hackage.haskell.org/package/vty-ui perhaps
15:25:46 <sebastianrkg> vanila: are there other parts of Haskell that operate this way?
15:25:50 <bitemyapp> dmwit: I am trying desperately to avoid vty and vty-ui.
15:25:56 <Cale> sebastianrkg: If you look at GHC's implementation, it's much more hacky than what vanila is describing, it uses impure functions that cause effects to occur during evaluation, with fake 0-byte arguments and results to create dependencies that keep effects in the right order.
15:25:59 <chrisdone> well, yeah, apart from using "full" terminal library
15:26:00 <bitemyapp> dmwit: they're very nice libraries, but hard to use relative to stdout/stdin.
15:26:07 <dmwit> bitemyapp: Oh, good. Then you get to reimplement it yourself. =)
15:26:12 <Sornaensis> vty is good
15:26:18 <bitemyapp> vty is very good
15:26:25 <bitemyapp> dmwit: my needs are spare.
15:26:26 <sebastianrkg> vanila: and is interacting with the runtime that IO interacts with something that one could define their own datatype to do?
15:26:46 <vanila> sebastianrkg, you couldn't implement this yourself in haskell - it has to come as part of the language
15:26:56 <Cale> sebastianrkg: But you could just as well imagine an implementation of Haskell in which IO actions had a bunch of constructors, and the runtime system contained an interpreter which would pattern match against those constructors and carry out the actions they describe.
15:26:57 <chrisdone> the curses package wants to take over the whole window
15:26:59 <dmwit> sebastianrkg: There is an FFI to C.
15:27:00 <chrisdone> is the vty package similar?
15:27:02 <bitemyapp> chrisdone: yes.
15:27:03 <EvanR> sebastianrkg: you can use the FFI to call produces in another language
15:27:08 <EvanR> procedures
15:27:21 <chrisdone> yeah, that's sucky if you just want to output in within the user's regular shell
15:27:24 <sebastianrkg> ah, yeah I heard about that. Is that defined as IO?
15:27:25 <bitemyapp> chrisdone: It should respect screen/tmux though.
15:27:29 <sebastianrkg> just really complex IO?
15:27:36 <bitemyapp> chrisdone: but it doesn't work in Emacs IIRC
15:27:52 <bitemyapp> fuzzleonard: hi!
15:28:47 <chrisdone> bitemyapp: throwing this out there: haskeline
15:28:56 <EvanR> sebastianrkg: you seem preoccupied with stuff ghc's runtime will do that you wont need to worry about ;)
15:29:07 <Cale> sebastianrkg: Yeah, almost always when you do some FFI to C, the result is an IO action, because C procedures tend to have effects beyond just producing their result.
15:29:09 <chrisdone>  ¬Ø\_(„ÉÑ)_/¬Ø
15:29:19 <bitemyapp> chrisdone: what I'm making isn't a literal REPL, but the modality here lines up nicely I think
15:29:29 <bitemyapp> chrisdone: this could end up being very nice for what I'm doing, thank you!
15:29:34 <bitemyapp> I'd forgotten about haskeline.
15:29:49 <monochrom> sebastianrkg: I think my http://www.vex.net/~trebla/haskell/IO.xhtml helps. but it does not talk about what you ask, how things look like in assembly. I do not believe that it is fruitful to imagine assembly 24/7
15:29:53 <bitemyapp> chrisdone: I'll have to test and see if it works with asynchronous output though.
15:29:54 <chrisdone> bitemyapp: like, *maybe* you could clear the line and then re-render it such that haskeline retains the user's current position and such
15:30:01 <chrisdone> right
15:30:02 * bitemyapp nods
15:30:13 <Cale> sebastianrkg: Evaluation of expressions in Haskell has no visible effect apart from making your CPU warm, and just rewrites things into a form where you case expressions can pattern match against them.
15:30:21 <bitemyapp> chrisdone: trying to replace this impossible-to-install Ruby app:? https://github.com/jugyo/earthquake
15:30:22 <Cale> -you
15:30:29 <EvanR> even assembly code does not explain "the whole story" its an arbitrary place to stop asking "how"
15:30:37 <sebastianrkg> monochrom, EvanR: I only ask because I may be doing some optimization work on this subject soon
15:30:37 <Cale> sebastianrkg: While execution of IO actions is where all the effects occur.
15:30:57 <Cale> sebastianrkg: (are you already familiar with this distinction?)
15:31:06 <chrisdone> bitemyapp: interesting. so you can compose your tweet at the bottom while new tweets are coming in i take it
15:31:24 <bitemyapp> chrisdone: yep
15:31:28 <sebastianrkg> yes, I am Cale, even more now
15:31:32 <bitemyapp> chrisdone: and it just so happens there's a fantastic twitter conduit library.
15:31:46 <bitemyapp> chrisdone: so there's no reason a thread can't sit there squirreling data into stdout
15:31:50 <monochrom> sebastianrkg: oh ok then I'll swing to the other extreme and suggest https://github.com/takenobu-hs/haskell-ghc-illustrated
15:32:25 <sebastianrkg> monochrom: That is super awesome, thanks! I will check that out
15:32:28 <chrisdone> bitemyapp: saucy
15:32:35 <Cale> sebastianrkg: So when you have a function f :: A -> IO B, say, and say x :: A, then *evaluating*  f x  won't do much that's visible, it'll just cause some IO action value to be computed, which is a description of some stuff that could be done in order to produce a value of type B. Executing that action will carry out the effects, and produce the result of type B, assuming it terminates normally.
15:32:39 <ahammel> @djinn Maybe a -> e -> Either e a
15:32:40 <lambdabot> f a b =
15:32:40 <lambdabot>     case a of
15:32:40 <lambdabot>     Nothing -> Left b
15:32:40 <lambdabot>     Just c -> Right c
15:33:30 <sebastianrkg> Cale: okay, but to me it seems like the IO type itself does not contain enough information for that IO action
15:33:45 <Cale> sebastianrkg: In a compiled Haskell program, the action called main gets executed to kick things off, and in turn, it may execute further actions, but evaluation on its own never causes execution.
15:33:47 <EvanR> you cant see the values of type IO X
15:33:52 <EvanR> you dont know what it contains
15:34:06 <Cale> sebastianrkg: The IO type is abstract, so you have no idea how much it contains
15:34:13 <Cale> sebastianrkg: But you could imagine something like:
15:34:16 <Cale> data IO a where
15:34:17 <sebastianrkg> How can one define an abstract type?
15:34:22 <Cale>   ReturnIO :: a -> IO a
15:34:30 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
15:34:37 <sebastianrkg> oh like that, I see
15:34:39 <EvanR> sebastianrkg: use a module and dont export the implementation guts
15:34:49 <Cale> and then lots of primitive IO actions
15:34:59 <sebastianrkg> so is the file that defines this available somewhere?
15:35:00 <Cale> maybe something for making general FFI calls
15:35:23 <Cale> That's not how GHC implements IO, but just a mental model that I'm giving you which is prettier than the real story.
15:36:03 <Stratege> sebastianrkg to my knowledge all of the GHC modules are available on hackage.haskell.org, can pm you some links
15:36:11 <EvanR> sebastianrkg: just like Char isnt really an abstract type with all 1114111 characters listed... its still semantically the same to the programmer
15:36:12 <sebastianrkg> ah, okay. So in fact GHC looks at the AST  or something and comes up with the correct information to maintain that model
15:36:14 <Hijiri> sebastianrkg: abstract type just means you don't export the constructors
15:37:00 <Hijiri> oh, EvanR already said things that are more accurate
15:37:21 <shachaf> A function :: forall a. Typeable a => F a -> G a should be called a supernatural transformation.
15:37:22 <sebastianrkg> okay, well it looks like looking at the implementation probably wouldn't help too much, I'll just keep that mental model
15:38:13 <sebastianrkg> Cale, EvanR: is there a name for or list of all the parts of Haskell that are not directly implemented in the way that other Haskell functions are?
15:38:17 <monochrom> haha shachaf
15:38:19 <EvanR> sebastianrkg: in order to write haskell code, this is all you need to understand. in order to hack ghc's optimizations... its not enough. but seems like A comes before B ;)
15:41:15 <sebastianrkg> Thanks so much Stratege, EvarR, Hijiri, Cale, vanila, monochrom & dmwit
15:41:21 <sebastianrkg> you've all been lots of help
15:42:16 <deech> How do I install a package candidate from Hackage with Cabal?
15:44:17 <bitemyapp> deech: what are you installing and for what purpose?
15:44:36 <bitemyapp> deech: I demonstrate some Cabal basics, including how to use sandboxes with projects in this tutorial: howistart.org/posts/haskell/1
15:44:49 <bitemyapp> deech: I recommend always installing into sandboxes.
15:45:04 <deech> bitemyapp:I have a package candidate up http://hackage.haskell.org/package/fltkhs-0.1.0.0/candidate and it would be nice to have people test it if they want.
15:45:31 <deech> bitemyapp: But I can't figure out how to 'cabal install ..' it.
15:45:33 <osa1_> is there a way to see if a function is interruptable?
15:45:51 <bitemyapp> deech: I don't think package candidates can be installed
15:45:55 <bitemyapp> has to be a full package
15:45:59 <HeladoDeBrownie> osa1_, what do you mean by that?
15:46:08 <osa1_> HeladoDeBrownie: async exceptions
15:46:34 <HeladoDeBrownie> you need more than mere functions to observe exceptions, you need IO
15:46:45 <deech> The package candidate page  https://hackage.haskell.org/upload says you are supposed to be able to. Maybe that functionality is not in yet ...
15:46:57 <bitemyapp> [callen@atlantis ~/Work]$ cabal unpack fltkhs
15:46:57 <bitemyapp> cabal: There is no package named 'fltkhs'.
15:47:01 <EvanR> osa1_: no, you need to go read the code to see if something is blocking async exceptions and when
15:47:50 <deech> bitemyapp: Thanks for your help!
15:47:55 <bitemyapp> deech: np
15:48:11 <Yuras> osa1_: everything is interruptible unless explicitly stated in docs
15:48:44 <EvanR> unless the docs are incomplete
15:48:50 <osa1_> Yuras: unless it's not interruptable and that's not documented
15:49:11 <monochrom> don't forget "unless there are bugs"
15:49:25 <Yuras> EvanR: in that case it may become interruptible in the next release :)
15:49:29 <EvanR> unless a cosmic ray interrupts the interruption
15:49:31 <HeladoDeBrownie> well, if it's a test you want you might be able to spawn the io in a thread and throw an exception to that thread
15:49:48 <HeladoDeBrownie> and then have the handling of the exception indicate whether it went through
15:49:54 <osa1_> state of exceptions in Haskell makes me sad
15:50:06 <EvanR> why?
15:50:29 <monochrom> it makes me happy
15:50:35 <Yuras> EvanR: probably because it is broken?
15:50:45 <osa1_> monochrom: why?
15:51:04 <monochrom> it does what I want
15:51:13 <EvanR> Yuras: why?
15:51:42 <Yuras> EvanR: double throw issue mostly
15:51:54 <EvanR> how does that go
15:52:20 <sebastianrkg> what is the time complexity of "read" or "readMaybe"?
15:52:55 <monochrom> it depends on which type you use it for. most cases are linear
15:53:05 <osa1_> sebastianrkg: depends on the implementation, read is a typeclass method
15:53:49 <sebastianrkg> okay, how about reading in the default record-syntax-derived way?
15:54:03 <sebastianrkg> or basically anything more complex than a number or string
15:54:54 <monochrom> I think it's still linear. the derived parser does little or no backtracking
16:05:33 <Zemyla> How do I derive a Typeable instance for FixPoint (res :: Nat)?
16:05:58 <Yuras> EvanR: sorry, network issue. I mean when your cleanup action throws while already processing other exception
16:06:48 <shachaf> That depends on what that is.
16:07:15 <glguy> For code using large records and especially operators the default Read implementation is exceedingly inefficient
16:08:40 <Zemyla> shachaf: newtype FixPoint res = FixPoint Double
16:08:47 <MrMetric> I've changed my C++ translation of my Haskell Mandelbrot set renderer to be more imperative instead of functional. It is even faster now (1.9 s) compared to the Haskell thingy (6 s)
16:08:57 <Zemyla> It doesn't let me manually derive a Typeable instance.
16:09:17 <glguy> You don't write manual Typeable instances, you have to derive them
16:09:20 <shachaf> Zemyla: What's "manually derive"?
16:09:42 <shachaf> Is FixPoint a type you defined yourself or a type you got from Hackage?
16:11:19 <Zemyla> It's a type I defined myself.
16:11:57 <Zemyla> I get an error when I try to use it: No instance for (Typeable 128).
16:12:28 <glguy> This package exists to deal with the exponential runtimes that derived Read can have: http://hackage.haskell.org/package/ChristmasTree-0.2.1.1/docs/Text-GRead.html
16:13:12 <shachaf> Zemyla: Yes, that's a problem.
16:13:44 <shachaf> I don't know if you can get a Typeable instance for that. :-(
16:14:23 <zq> MrMetric: let's see that functional c++
16:14:34 <MrMetric> zq: wut
16:14:49 <EvanR> uwot
16:14:54 <zq> MrMetric: on se peut voir ton c++ maintenant?
16:15:19 <MrMetric> zq: Je ne parler pas le French
16:15:44 <zq> zq: you said you translated hs to cpp. then you cpped your cpp even more. so let's see your pre-cpped cpp.
16:16:34 <zq> MrMetric: ^
16:16:49 <MrMetric> zq: Oh
16:16:59 <MrMetric> Well, it's less functional than Haskell (I had to use for loops), but I tried!
16:17:02 <MrMetric> I will paste it k
16:17:07 * hackagebot jespresso 1.0.1 - Extract all JavaScript from an HTML page and consolidate it in one script.  http://hackage.haskell.org/package/jespresso-1.0.1 (AndreyChudnov)
16:17:10 <josephle> really, with the new cpp standard, cpp should look more functional than before
16:18:51 <lpaste> MrMetric pasted ‚Äúmandelbrot.cpp‚Äù at http://lpaste.net/120106
16:18:56 <MrMetric> There you go
16:19:14 <MrMetric> Note: I've noticed that std::complex is kinda slow
16:19:23 <MrMetric> My optimized version has my own complex struct instead
16:19:59 <Arahael> MrMetric: If such a simple struct is far faster... One wonders what the native version is optimised for.
16:20:10 <Arahael> MrMetric: You might be missing out on optimisations elsewhere.
16:20:34 <MrMetric> Arahael: I dunno, but using its norm function instead of calculating it myself makes it take 4 extra seconds (> 2√ó slower!)
16:20:59 <MrMetric> norm(x) = x.real^2 + x.imag^2
16:21:04 <Arahael> MrMetric: Your version wouldn't happen to be inlined, would it?
16:21:22 <MrMetric> Arahael: Yep, but it still shouldn't be that much of a difference
16:21:33 <MrMetric> I checked the code it uses for norm
16:21:33 <josephle> Arahael: that's what constexpr does
16:21:42 <MrMetric> It has a helper function!
16:21:44 <MrMetric> >.>
16:22:05 <Arahael> josephle: Could you elaborate?
16:22:48 <josephle> constexpr tells the compiler it is possible to evaluate the function at compile time when given constant arguments
16:22:52 <MrMetric> Arahael: I don't know anything about constexpr causing inlining (I think the compiler'd do it anyway for such a simple function); it just tells the compiler that the function returns the same output for the same input
16:23:12 <josephle> http://en.cppreference.com/w/cpp/language/constexpr
16:23:23 <Arahael> MrMetric: But you're talking about a calculation done _after_ constexpr, right?
16:23:27 <josephle> constexpr is much fancier than you think, MrMetric :)
16:23:35 <MrMetric> Unfortunately, constexpr does not work with anything more than a simple expression
16:25:01 <MrMetric> If I modify the code a bit and make max_iterations constant at compile time, I think the compiler will calculate the set itself
16:25:19 <MrMetric> The result: the executable just outputs an image from stored data
16:25:30 <scott> josephle: actually constexpr is more like asking the compiler to tell you if that's _not_ possible. the compiler already knows how to figure that out for arbitrary functions
16:25:54 <scott> it just adds the guarantee so you can use it in constant expression contexts like array sizes
16:26:03 <josephle> scott: ah, that makes sense
16:26:10 <scott> MrMetric: if you can go up to C++14 constexpr gets a lot more powerful
16:26:30 <scott> oh I'm in #haskell :)
16:26:34 <MrMetric> scott: I dunno if my version of GCC supports that. I'll hafta check
16:26:40 <shachaf> S11001001: What can you say about the duality between (,) and (->)? In what sense are they dual?
16:27:41 <josephle> are they dual in a nondependent setting?
16:28:22 <shachaf> Any setting is fine. There are certainly all sorts of interesting connections between them.
16:28:38 <MrMetric> Well, I've definitely identified one of the problems with my Mandelbrot set C++ from 2013. It uses std::complex's norm, which is horribly slow
16:29:02 <josephle> I guess even in a dependent setting (->) and (,) are still nondependent type constructors
16:29:48 <Welkin> C++ seems to have a lot of issue with its standard library
16:29:52 <josephle> dependent products (i.e. dependent functions) and dependent sums (i.e. dependent pairs) do make this duality more apparent :)
16:30:28 <shachaf> What duality?
16:30:41 <MrMetric> Welkin: I'm thinking I should modify the complex include file to avoid it screwing up any more programs that I compile
16:30:49 <shachaf> (e,) and (e->) are adjoint, but presumably people mean more than that.
16:31:44 <byorgey> also, dependent product and dependent sum are the left and right (or maybe right and left) adjoints of the diagonal functor
16:32:27 <shachaf> Sure, (,) and (+) are certainly dual in the obvious way.
16:34:08 <shachaf> byorgey: Saying that they're adjoint to a diagonal functor is just saying that they're a limit and a colimit respectively. :-)
16:34:31 <shachaf> I don't know why I put the word "respectively" at the end there.
16:36:05 <benzrf> hm wait
16:36:11 <benzrf> hold on....
16:36:20 <benzrf> is dependent sum
16:36:22 <monochrom> it is a correct use. A and B are the first and second letters, respectively
16:36:23 <benzrf> œÉ tyes
16:36:35 <josephle> large sigma
16:36:42 <benzrf> ooh
16:36:44 <josephle> \Sigma types
16:36:46 <benzrf> Œ£ types
16:36:47 <josephle> erm
16:36:49 <josephle> yeah
16:36:53 <benzrf> dependent apri?
16:36:54 <benzrf> *pair
16:37:00 <benzrf> shouldnt pairs be dependent /products/?
16:37:08 <josephle> heh, that's the fun part
16:37:10 <shachaf> monochrom: Oh, I was referring to my previous sentence. What I said makes sense.
16:37:11 <scott> benzrf: nope. it's confusing
16:37:21 <benzrf> oy
16:39:00 <scott> "exists n: Nat. List n Int" is like a sum: List 0 Int + List 1 Int + List 2 Int + ...
16:39:13 <scott> it can be any length of list
16:39:13 <benzrf> .
16:39:22 <benzrf> uh huh
16:39:28 <shachaf> OK, I guess that's what josephle was getting at.
16:39:31 <S11001001> shachaf: I mean a colloquial duality as has already been discussed, rather than a categorical duality
16:39:31 <benzrf> sure -_-
16:40:10 <josephle> shachaf: to get the categorical duality for dependent products and sums would be more nlab than I am willing to read tonight
16:40:11 <benzrf> scott: so basically what you're saying is
16:40:23 <shachaf> S11001001: OK, that's what I'd like to know more about.
16:40:26 <benzrf> scott: you add the types, one for each member of the first type
16:40:39 <scott> benzrf: yeah
16:40:39 <benzrf> kind of like how 3 * 5 means adding up the 5s, one for each member of 3 >:[
16:40:54 <benzrf> hmm well
16:41:01 <benzrf> tbh i guess /Œ£/ works for that
16:41:08 <benzrf> if not +
16:41:14 <benzrf> interesting.
16:41:26 <benzrf> whereas...
16:41:39 <benzrf> forall n : Nat. List n Int
16:42:11 <benzrf> is List 0 Int * List 1 Int * List 2 Int ...
16:42:11 <m4farrel> @djinn Maybe a -> e -> Either e a
16:42:12 <lambdabot> f a b =
16:42:12 <lambdabot>     case a of
16:42:12 <lambdabot>     Nothing -> Left b
16:42:12 <lambdabot>     Just c -> Right c
16:42:16 <benzrf> ooooooooooooooooooooooooooooooooooooh
16:42:19 <benzrf> as in Œ†
16:42:19 <m4farrel> Maybe a -> e -> Either e a
16:42:22 <benzrf> niiiiice
16:42:31 <benzrf> it... it makes sense
16:42:45 <m4farrel> @ Maybe a -> e -> Either e a
16:42:46 <scott> "exists _:Bool. Bool" == sum from 1 to 2 of 2 == 2 + 2 == 4 == 2 * 2 == (Bool, Bool) and guess how "exists _:Bool. Bool" is represented as a value
16:43:24 <benzrf> soo
16:43:30 <scott> "forall _:a. b" == "a -> b" and "exists _:a. b" == "(a, b)"
16:43:41 <benzrf> you call then exponentials and products in non dependent type systems cause
16:43:58 <benzrf> product and summation act like exponent and product when each term is the same
16:44:01 <scott> because you do sums and products that don't use the index
16:44:07 <benzrf> daaaang
16:44:39 <monochrom> that's interesting
16:45:23 <shachaf> Yes, it's all straightforward by analogy to ordinary numbers.
16:49:23 <josephle> benzrf: nicely put :)
16:53:14 <xenocons> what do you name a type which represents boolean functions of arbritary combinations over a set
16:54:05 <josephle> a filter?
16:54:09 <xenocons> true x and true y and true x or (true x and true y and false z) as a trivial non optimised example
16:54:12 <xenocons> hmm
16:54:16 <xenocons> ok yes that is right ;p
16:54:19 <xenocons> heh
16:54:39 <xenocons> i suppose it is exactly that
17:00:41 <worldsayshi> Cabal-hell: I‚Äôm trying to install the latest version of package bloodhoud (0.5.0.1) in a sandbox. I get ‚ÄúDependency tree exhaustively searched‚Äù error. It seems like there are conflicts with default global packages. How can I tell cabal to simply install new versions of these packages? What is the way to do this? It seems to me that there are almost *no* cabal use case that ‚Äújust works‚Äù. It‚Äôs always
17:00:42 <worldsayshi> such pain to use.
17:01:21 <Marlin> why is behavior o this different in ghci and ghc? in ghci thread is not killed, but when running executable from ghc it is.  main = do t <- forkIO (getLine >> return ()); killThread t
17:02:07 <creichert> worldsayshi: there is a --allow-newer flag for cabal-install. any idea exactly which dep is failing?
17:02:40 <proopsle> is there a general purpose graph algo library for haskell? (search, sort, transform, etc)
17:02:56 <Cale> Marlin: uhhh, seems like the thread gets killed in both cases for me
17:03:07 <Cale> Marlin: Which version of GHC?
17:03:10 <Marlin> Cale hmm
17:03:17 <Marlin> 7.6.3
17:03:23 <Cale> I'm on 7.8.3
17:03:42 <Cale> (which itself is kind of old... I should update)
17:04:21 <Marlin> ghc for windows could be culprit too
17:04:45 <Cale> Marlin: Also, see if compiling with -threaded makes a difference?
17:04:58 <Marlin> Cale ghci doesn't compile :)
17:05:15 <Cale> I know
17:05:34 <Cale> Well, it can load your compiled .o files, but that's beside the point. GHCi uses the threaded runtime.
17:05:34 <Marlin> in ghc it works without -threaded even without -threaded flag
17:05:39 <proopsle> why doesnt hackage say the release date of the last version of a library?
17:05:43 <Marlin> err
17:05:50 <Marlin> in ghc it works as expected even without -threaded flag
17:06:01 <Welkin> proopsle: it does
17:06:05 <proopsle> or is that the 'Uploaded' field?
17:06:06 <Cale> Marlin: -threaded isn't the default, try it with -threaded and see if it breaks
17:06:09 <Welkin> "Last Uploaded"
17:06:46 <Marlin> Cale I am not really following what you mean.. "ghci -threaded"' or "runhaskell -threaded"?
17:07:00 <Cale> ghc -threaded
17:07:07 <proopsle> ah ok Welkin
17:08:22 <worldsayshi> creichert: This is the error I get. Conflicts with template haskell and containers. http://lpaste.net/120109
17:08:57 <Marlin> Cale same thing. it does not effect ghci or runhaskell
17:09:05 <Marlin> affect*
17:09:40 <Cale> Same thing compiling with and without -threaded?
17:09:42 <Cale> Okay
17:09:46 <creichert> worldsayshi: you can try cabal install --allow-newer=template-haskell --allow-newer=containers, but I am not certain it will fix your issue
17:10:08 <Marlin> yes, when running in interpreter. when compiling and running the resulting executable thread is killed (regardless if I use -threaded flag or not)
17:10:13 <Cale> Yeah, ghci and runhaskell use the threaded runtime, that's why I wanted you to try compiling against the threaded runtime.
17:10:27 <Cale> okay
17:11:14 <Marlin> should -threaded flag even matter? I mean shouldn't this work even on a single thread, since forkIO uses haskell threads?
17:11:17 <Cale> Probably what's going on has something to do with blocking in an FFI call, but the problem doesn't seem to exist in 7.8
17:11:38 <Cale> The threaded runtime can have different bugs from the unthreaded one
17:12:03 <Marlin> yeah true
17:12:11 <Cale> It's definitely a bug that the thread isn't being killed, but it's one which appears to be fixed in the new GHC
17:12:21 <worldsayshi> creichert: Hum, It‚Äôs going to break ghc
17:12:30 <worldsayshi> I√§ll try and see
17:12:32 <Marlin> are you testing this on windows?
17:12:37 <Cale> no
17:12:54 <worldsayshi> *I‚Äôll try and see
17:12:56 <Cale> I suppose it might have something to do with the treatment of line buffering.
17:13:15 <creichert> worldsayshi: sure, possibly. That is the first step I would take on a package which has strict upper bounds. After that, I would probably go in and start tweaking manually
17:13:35 <Cale> Try adding  hSetBuffering stdin NoBuffering  to the start of main (and importing System.IO), and see if that makes a difference
17:14:20 <Cale> (like, maybe the thread gets killed, but the windows terminal is still in some sort of mode where it's reading a line buffered line of input...)
17:14:37 <worldsayshi> creichert: ‚ÄúJust works‚Äù is apparently not a thing with cabal‚Ä¶ :/
17:15:18 <Cale> worldsayshi: Which version of ghc are you using?
17:15:18 <Marlin> that didn't change anything
17:15:38 <Cale> worldsayshi: Those look like the sort of errors I'd expect if my GHC were too old.
17:15:54 <Cale> (The base package version is tied to GHC's version)
17:16:03 <Cale> Marlin: All right, I have no idea :)
17:16:17 <worldsayshi> 7.4.2 - I‚Äôm using the fp complete vagrant box
17:16:20 <creichert> worldsayshi: Honestly, it does get better with a little familiarity on the compilation process. I almost never have issues now but I've been there. What version of ghc?
17:16:21 <Marlin> Cale by the way did you mean that ghci can read .o files if they exists?
17:16:33 <Cale> Marlin: It can
17:17:22 <worldsayshi> creichert: So not very new
17:17:52 <creichert> worldsayshi: indeed. what OS are you on? Maybe you have the patience to try a different install method :)
17:18:14 <worldsayshi> ubuntu precise
17:18:23 <hexagoxel_> i can confirm that bloodhound-0.5.0.1 gives dependency errors with ghc-7.4.2, and not with 7.8.4
17:18:30 <worldsayshi> huh
17:19:02 <hexagoxel_> 7.6.3 neither gives dependency problems
17:19:13 <Cale> Yeah, it's just some dependency of bloodhound needs a newer version of base
17:19:26 <Cale> and you can't upgrade the base package without upgrading ghc
17:20:11 <Cale> Well, in particular, it appears that aeson depends on a newer version of template haskell
17:20:22 <Cale> and that's also tied to the GHC version
17:20:24 <Marlin> Cale thanks for trying. I'll check if this is a known issue or not
17:20:59 <creichert> worldsayshi: can you access a newer ghc vagrant box? I'm not sure what FPC offers, there
17:21:48 <worldsayshi> I can always put together my own I guess. I‚Äôl look
17:22:04 <monochrom> FP Complete is probably at 7.6.something
17:22:35 <worldsayshi> Fp complete was at 7.4?
17:22:36 <creichert> If that's where you are comfortable that would be great to get started
17:23:03 <worldsayshi> So newer ghc -> less likely to get problems?
17:23:24 <monochrom> no, that is not true either
17:23:30 <Javran> can someone explain when would Data.Void be useful? In my understand it's just like rewriting " f x | {impossible condition} = undefined"  into "f x | {impossible condition} = absurd x".
17:23:41 <worldsayshi> no, I wouldn‚Äôt think so
17:23:47 <monochrom> let's just say the graph of "happiness vs GHC version" is a bell curve.
17:23:48 <Cale> worldsayshi: Unless it's a GHC that came out less than a month ago or something, generally that's reasonably true
17:24:02 <worldsayshi> okok
17:24:09 <MrMetric> Should I use https://www.haskell.org/hoogle or http://hoogle.haskell.org?
17:24:31 <chrisdone> fp complete's on 7.8
17:24:42 <Cale> It can't actually be a bell curve though, because you can't be using GHCs from the future
17:25:39 <chrisdone> MrMetric: there's also the hoogle on http://www.stackage.org/
17:25:59 <chrisdone> not all of hackage, about 800 packages
17:26:04 <Cale> Maybe some kind of Gamma distribution :D
17:26:45 <worldsayshi> chrisdone: https://www.fpcomplete.com/page/haskell-eval-vm - Not this one I just downloaded it and got ghc 7.4? Or am I missing something
17:26:55 <Cale> or a chi-squared distribution
17:27:16 <chrisdone> worldsayshi: honestly i have no idea where that page came from =P
17:27:27 <Cale> (with like k = 6 or something)
17:27:41 <worldsayshi> googled fp complete vagrant :P
17:27:41 <chrisdone> worldsayshi: how did you find it? must be super old if it's ghc 7.4
17:28:37 <hexagoxel_> ghc HEAD = ghc from future ?
17:29:54 <pharaun> ghc head is just the most current development version of ghc, they do do regular releases which would then become 7.10 or what you have not
17:30:04 <worldsayshi> chrisdone: And it‚Äôs the only one I can find
17:30:05 <Cale> hexagoxel_: Perhaps if you can work out the right git commandline flags, it'll let you clone the repo from 2050
17:30:17 <pharaun> lol
17:30:30 <scott> unfortunately git commits only point to their parents
17:32:23 <monochrom> if 40 monkeys keep banging on keyboards producing random checksums, one of them is bound to hit an existing git commit
17:32:37 <worldsayshi> creichert, chrisdone: Thanks fo the help, I‚Äôll try with another box and/or newer ghc
17:32:54 <monochrom> and perhaps given enough time, all of them are bound to be git commits in the future
17:32:59 <scott> monochrom: generating the commit from the checksum is left as an exercise to the reader
17:35:06 <Marlin> Cale a little update, this issue does not happen with runhaskell (I guess because main thread does not wait for other threads to complete. so killThread can even be ommitted and it will still be killed). the issue is when I run this code directly in ghci.
17:35:17 <Marlin> do you mind copy/pasting this in ghci and see what happens?   do t <- Control.Concurrent.forkIO (getLine >> return ()); Control.Concurrent.killThread t
17:36:26 <Marlin> (or if anyone else reading this can try!)
17:37:11 * hackagebot handsy 0.0.8 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.8 (utdemir)
17:39:41 <thsig> I'm trying to get started with the NICTA course, followed the instructions here: https://github.com/NICTA/course#running-the-tests, but I'm getting this error when I run cabal test:
17:39:46 <thsig> doctests: <command line>: cannot satisfy -package doctest-0.9.11.1
17:39:46 <thsig>     (use -v for more information)
17:40:06 <scott> Marlin: nothing visible happens. I'm just immediately back at the next ghci prompt
17:40:14 <thsig> whereas I saw that version of that package installed above... maybe I'm missing something here
17:40:20 <thsig> I'm using Stackage
17:40:20 <scott> Marlin: GHC 7.6.3 on linux 64-bit here
17:40:39 <thsig> and GHC 7.8.3
17:40:43 <thsig> on OSX
17:41:03 <digia> What am i doing wrong? With Yosemite, when i rotate a external display, everything rotates.
17:41:24 <ReinH> digia: Sorry, is this a Haskell question?
17:41:31 <digia> Whoops wrong channel
17:41:33 <digia> My bad
17:41:35 <ReinH> heh np
17:41:44 <digia> Oh god it's gonna be one them nights
17:41:55 <ReinH> digia: well it was one of those days for me so
17:42:03 <digia> Well high-five ReinH
17:42:06 <ReinH> o/
17:42:14 <Marlin> scott, thsig thanks
17:42:44 <JimmyJohn> Is there a non-silly way for me to achieve this? rotate Zero (w,x,y,z) = (w,x,z,y)
17:42:45 <JimmyJohn> rotate Two (w,x,y,z) = (y,z,w,x) rotate Three (w,x,y,z) = (x,y,z,w)
17:42:47 <JimmyJohn> etc.
17:42:51 <Ally> haha
17:43:10 <JimmyJohn> instead of just writing out each case
17:43:26 <Ally> with rotate :: Amount -> (a,a,a,a) -> (a,a,a,a), I imagine, of course
17:43:34 <ReinH> JimmyJohn: Well, it's probably some sort of group action
17:43:45 <Ally> and data Amount = Zero | One | Two | Three
17:43:53 <ReinH> Not sure if that helps make it less silly
17:43:59 <JimmyJohn> I take it you've seen this, Ally. :P
17:45:07 <thsig> Marlin: Same here. Nothing seems to happen when I paste that in.
17:45:31 <JimmyJohn> ReinH: Group actions, hmm. That's new to me (most of this is). I'll check into that, thanks.
17:45:45 <ReinH> JimmyJohn:  what's the rule for rotating? Is rotate Zero not supposed to be id?
17:45:56 <JimmyJohn> Rotate Zero returns the original 4-tuple.
17:46:02 <JimmyJohn> with no rotations
17:46:04 <ReinH> JimmyJohn: Ah, then you have a typo :)
17:46:10 <JimmyJohn> yes i do!
17:46:15 <Ally> yeah
17:46:15 <ReinH> Ok that helps
17:46:20 <Ally> rotate Zero (w,x,y,z) = (w,x,y,z)*
17:46:33 <JimmyJohn> Thanks
17:46:48 <ReinH> JimmyJohn: you can define rotate :: Int -> (a,a,a,a) -> (a,a,a,a) inductively
17:46:55 <JimmyJohn> That was a typo left-over from a horrible experiment
17:47:00 <ReinH> since rotate 2 = rotate 1 . rotate 1
17:47:08 <ReinH> that's a group homomorphism
17:47:54 <ReinH> and rotate 5 = rotate 1
17:48:41 <ReinH> You have the symmetry group C_4, in fact
17:48:53 <Javran> I usually prefer ((x,x),(x,x)) over (x,x,x,x), just for utilities like fst, snd, first, second etc.
17:49:20 <JimmyJohn> I see.
17:49:28 <JimmyJohn> I'm not allowed to change the rotate :: definition however
17:49:43 <JimmyJohn> I think it would certainly be a bit easier with Ints
17:49:54 <ReinH> JimmyJohn: ok, but you can map from Amount to Int mod 4
17:50:12 <ReinH> and vice versa
17:50:26 <ReinH> You are taking advantage of the fact that your group is isomorphic to the integers mod 4
17:50:49 <ReinH> You could even do something fancy with a Num typeclass if you wanted to
17:50:57 <JimmyJohn> So that would be a helper function to convert my Amount into an equivalent Int, basically?
17:51:09 <ReinH> JimmyJohn: you can do it this way: convert Amount into Int, rotate by Int
17:51:43 <ReinH> where rotating by int just has the two definitions: rotate 0 (x,y,z,w) = ... and rotate n (x,y,z,w) = ...
17:51:51 <dibblego> thsig: cabal install doctest, also there is a#nicta-course channel if you are interested, where others are also doing it
17:51:59 <Ally> how would you convert an amount to an int, though?
17:52:18 <ReinH> Ally: you could make it an Enum
17:52:38 <ReinH> or just write the obvious thing with 4 cases
17:52:39 <Ally> there are enums in haskell?
17:52:41 <Ally> oh, the data thing
17:52:45 <ReinH> Ally: there is an Enum class
17:52:46 <ReinH> @info Enum
17:52:47 <lambdabot> Enum
17:52:50 <ReinH> well thanks lambdabot
17:52:50 <Ally> not just
17:52:51 <Ally> rotate Three (w,x,y,z) = (x,y,z,w)
17:52:51 <Ally> rotate Two (w,x,y,z) = (y,z,w,x)
17:52:51 <Ally> rotate One (w,x,y,z) = (z,w,x,y)
17:52:51 <Ally> rotate Zero (w,x,y,z) = (w,x,y,z)
17:52:52 <Ally> ?
17:53:00 <scott> :t fromEnum
17:53:01 <lambdabot> Enum a => a -> Int
17:53:14 <ReinH> Ally: My concern is that we've already had one bug from a simple typo in the tuple
17:53:19 <scott> you just `deriving Enum` if the constructors are in the right order
17:53:20 <ReinH> Now we have the chance for 8 of them
17:53:34 <ReinH> but  yes, you could write that thing explicitly and totally ad hoc
17:53:36 <Ally> I'm pretty sure my version doesn't have a typo
17:53:53 <JimmyJohn> lol my test cases would have caught that if I tried to compile. :)
17:54:14 <ReinH> Anyway, the group action approach is rather elegant imo but ofc you can just write this one out
17:54:26 <ReinH> The nice thing about the group theory approach is that it scales
17:54:37 <ReinH> to rotating arbitrarily large tuples
17:54:39 <ReinH> with only two definitions
17:54:42 <thsig> dibblego: Didn't solve the problem, but thanks! I'll go check the NICTA channel.
17:54:55 <JimmyJohn> yeah i see
17:55:12 <ReinH> since a cyclic group is isomorphic to the integers, and you can do induction on integers
17:55:18 <ReinH> you can define this with induction as well
17:55:46 <ReinH> If you wanted to, say, model a rubix cube, you would definitely not want to write everything out explicitly.
17:55:57 <ReinH> Rubik's cube, sry
17:56:40 <augur> are there any good, efficient packages for prolog-like programming in haskell?
17:56:55 <JimmyJohn> right
17:57:03 <JimmyJohn> that'd be a lot of cases, ha
17:57:07 <exio4> exploiting isomorphism is a lovely approach
17:57:10 <ReinH> JimmyJohn: I used this approach for the 2048 game as well and it was rather nice
17:57:25 <JimmyJohn> that's cool
17:57:32 <JimmyJohn> ok, thanks for the tips Rein.
17:57:36 <ReinH> You write the function for sliding a piece in a single direction
17:57:43 <exio4> uh, add a s :P
17:57:50 <ReinH> Then you model the board as a group so that you can rotate it and unrotate it
17:58:01 <JimmyJohn> I see.
17:58:07 <ReinH> then movement is a direction is group conjugation.
17:58:14 <vanila> augur, There is molog but it abuses STT
17:58:25 <ReinH> rotate R1 . slide . rotate (inv R1)
17:58:26 <augur> vanila: ?
17:58:32 <bubano> Which IDEs/Editors/Environments are you guys using?
17:58:40 <ReinH> And you can even use an Iso from lens for this
17:58:48 <scott> vanila: STT?
17:58:59 <vanila> ST monad transformer
17:59:04 <scott> ah
17:59:11 <augur> ah. thats ok i guess
17:59:29 <vanila> it's explicitly disallowed in the docs to use it the way they do
17:59:32 <ReinH> e.g., over (iso' R1) slide where iso' g = iso' g (inv g)
17:59:38 <ReinH> er = iso g (inv g)
17:59:40 <augur> o
17:59:45 <ReinH> not supposed to be a non-terminating recursion...
18:00:20 <ReinH> JimmyJohn: Anyway viewing it as a group is nice but not strictly necessary to rotate 4 things. )
18:00:24 <ReinH> er, ;)
18:00:45 <ReinH> JimmyJohn: on the other hand, you can sort of take advantage of the group properties anyway:
18:02:21 <zipper> Hey uh can someone give an example how to add FieldSettings in Yesod forms?
18:02:52 <zipper> I want to add a class to my css form in Yesod
18:02:57 <ReinH> JimmyJohn: like http://lpaste.net/6344596011150737408
18:03:00 <JimmyJohn> right. i think group functions would be more elegant
18:03:20 <JimmyJohn> oh interesting
18:05:44 <ReinH> JimmyJohn: if you write everything in terms of rotate One, you can start to see the group structure emerge in the definitions
18:05:55 <ReinH> rotate Two = rotate One . rotate One -- two rotations
18:06:05 <ReinH> rotate Three = rotate One . rotate One . rotate One -- three rotations
18:06:07 <ReinH> and etc
18:06:50 <JimmyJohn> Would rotate Four   = rotate Two . rotate Two also work?
18:07:01 <ReinH> Yep, because Two + Two = Four :)
18:07:35 <scott> also rotate Four = rotate Zero because 4 = 0 in the integers mod 4
18:08:12 <ReinH> JimmyJohn: Elements of cyclic group are constructed from a single generator and can be represented using a power notation. In this case, g = rotate One is your generator.
18:08:19 <ReinH> and g . g . g . g = rotate Four
18:08:55 <unknownloner> This might not be entirely haskell related, but what'd be a easy way to graph the output of a function (its a simple math function, takes in X values and returns Y values)
18:09:14 <shachaf> What are X values and Y values?
18:09:31 <unknownloner> like on a graph
18:09:34 <ReinH> If Haskell notation allowed it, you could even say g‚Å¥ :)
18:09:36 <vanila> unknownloner, you could compute a bunch of points and feed it to GNUplot
18:10:13 <unknownloner> that might work for me
18:10:34 <JimmyJohn> That'd be nice. :)
18:11:03 <ReinH> scott: with powers of functions (a -> a) being defined as f‚Å∞ = id; f^{n + 1} = f . f^n :)
18:11:06 <ReinH> er, JimmyJohn ^
18:11:18 <ReinH> You could do this right now with (^) if you really wanted to ;)
18:11:36 <JimmyJohn> I think I recall programming something like that in C once.
18:11:49 <LordBrain> when i was first learning haskell, i think ghc came with a graphics lib
18:11:51 <unknownloner> happend to know a good place to learn how to actually use gnuplot
18:12:06 <LordBrain> they must have decided to get rid of it?
18:12:13 * hackagebot linkedhashmap 0.4.0.0 - Persistent LinkedHashMap data structure  http://hackage.haskell.org/package/linkedhashmap-0.4.0.0 (abasko)
18:12:54 <LordBrain> maybe it was hugs...
18:13:00 <LordBrain> oh well
18:13:20 <ReinH> > let f ^^^ 0 = id; f ^^^ n = f . (f ^^^ (n - 1)) in (succ ^^^ 4) 0 -- JimmyJohn
18:13:22 <lambdabot>  4
18:14:01 <LordBrain> unknownloner, you know what, you could probably use a webkit window...
18:14:11 <JimmyJohn> Nice. :)
18:14:58 <ReinH> ofc Endo is a monoid, not a group, but in this case we aren't making use of the identity ayway
18:15:09 <vanila> unknownloner, just look at the demos http://www.gnuplot.info/screenshots/index.html#demos
18:15:25 <vanila> you can change the code a bit to do what you need
18:17:50 <ReinH> er, aren't making use of the inverses anyway
18:19:11 <LordBrain> hmm that webkit stuff would be pretty fun if it were only more documented
18:37:14 * hackagebot indentation 0.2.0.3 - Indentation sensitive parsing combinators for Parsec and Trifecta  http://hackage.haskell.org/package/indentation-0.2.0.3 (AlekseyKliger)
18:41:55 <acomar> hey all, lens question -- anyone know why lens offers scanr1Of but not scanrOf?
18:42:30 <acomar> would allow it to take a function of type (c -> d -> d) instead of (c -> c -> c)
18:47:49 <joseph_> .
18:49:43 <Sornaensis> woo, compiling ghc
18:49:47 <Sornaensis> for 12 hours
18:50:41 <shachaf> acomar: How do you do scanr for an arbitrary Traversable?
18:50:51 <shachaf> > scanr (+) 0 [1,2,3]
18:50:53 <lambdabot>  [6,5,3,0]
18:50:57 <shachaf> Those lists aren't the same length.
18:51:29 <shachaf> The name is misleading because it resembles foldl1 etc., but scanr1 et al. aren't partial.
18:54:44 <acomar> shachaf: I'm trying to get something like a traversal over a list that gives me each (:) case in the list. So [1, 2, 3, 4] ->> [[1, 2, 3, 4], [2, 3, 4], [3, 4], [4]]
18:56:05 <shachaf> Like tails?
18:56:56 <acomar> yea, exactly
18:57:11 <acomar> (thanks for the pointer to tails, wasn't aware that existed)
18:57:31 <shachaf> tails also gives you the [] at the end.
18:58:22 <acomar> yea, I can deal with that
18:58:33 <acomar> I just need a way to lift tails to a traversal I guess
18:59:13 <shachaf> I'm not sure what that would mean.
19:00:44 <acomar> part of the problem is that I don't know either :)
19:01:31 <shachaf> Can you give an example for something that isn't a list?
19:01:37 <acomar> I'm trying to work with the zippers package, and need to view the focus as (:) a [a]
19:02:44 <acomar> on a tree, it would be something that visited each node of the tree as a Node constructor instead of the direct data held by the tree
19:03:19 <acomar> something like Traversal' (Tree a) (Tree a)
19:03:47 <acomar> effectively, I don't want to strip off the constructor while still traversing the data structure
19:03:50 <shachaf> There might be some things in .Plated that do what you want.
19:04:48 <gdsimoes> Hi. I  am learning following Learn You a Haskell and I have a question. When I define the simple function:
19:04:50 <gdsimoes> lucky 7 = "LUCKY NUMBER SEVEN!"
19:04:51 <gdsimoes> lucky x = "Sorry, you're out of luck, pal!"
19:05:03 <gdsimoes> Why do I get an error when I try: lucky 'a'
19:05:05 <gdsimoes> ?
19:05:17 <shachaf> Normally it would be nice to say what the error is.
19:05:25 <acomar> gdsimoes: 7 is an Int, so the inferred type is lucky :: Int -> String
19:05:32 <shachaf> In this case it's a type error -- roughly, lucky expects a number, and 'a' isn't a number.
19:05:50 <shachaf> You would clear things up for both yourself and the compiler if you wrote a type signature at the top -- e.g. the one acomar gave.
19:06:02 <gdsimoes> Is there a way to create this function where I can use any type as input?
19:06:20 <shachaf> The short answer is "no".
19:06:49 <shachaf> If the function is inspecting its input to see whether it's 7, it needs to constrain the type of its input to things that can reasonably be 7.
19:07:09 <gdsimoes> Can I use number or char?
19:07:12 <ReinH> acomar: is 7 an Int?
19:07:41 <shachaf> ReinH: acomar's explanation isn't perfectly precise but not in a way that's harmful in this context.
19:08:17 <gdsimoes> Is something like this possible: lucky :: Int -> String ?
19:08:20 <ReinH> shachaf: True, although Num makes the explanation more complex than it would otherwise be.
19:08:31 <shachaf> gdsimoes: The longer answer is "yes, but before you do it you should know these various caveats".
19:09:01 <shachaf> ReinH: Yes. It makes the errors worse, it's not nice in all sorts of ways. This is why I said "roughly" and "a number" above.
19:09:11 <ReinH> shachaf: fair enough
19:09:19 <shachaf> But I don't think being picky about Int is helpful.
19:10:13 <acomar> ReinH: just simplifying
19:10:22 <ReinH> gdsimoes: Generally speaking, we don't want functions to take "any type" unless they don't need to know anything about whatever type is used. For instance, a function that could take "any type" wouldn't be able to know if that type was a number, let alone whether the particular number given is 7.
19:10:37 <ReinH> acomar: fair enough
19:11:57 <ReinH> gdsimoes: so if you want lucky to be a function from "any type" to String, it would have type lucky :: a -> Int, but then you couldn't pattern match on 7.
19:12:50 <gdsimoes> ReinH: Should be lucky :: a -> Int, isn‚Äôt it?
19:13:02 <ReinH> gdsimoes: Sorry, I mean lucky :: a -> String
19:13:11 <ReinH> Too much Int on the brain
19:13:12 <gdsimoes> Also, why couldn‚Äôt pattern match on 7?
19:13:12 <HeladoDeBrownie> the return type in the example was String i believe
19:13:20 <HeladoDeBrownie> woop, too late :P
19:13:22 <ReinH> gdsimoes: because 7 is a number, and "any type" isn't necessarily a number.
19:13:28 <Hijiri> Another way to think about it is that a function taking 'any type' is actually a definition for a lot of functions, namely one for each type
19:13:43 <narens> TypeFamilies question: i have an instance Something a where I have data Samples a = MySamples stuff. How do I export this data constructor MySamples? I can't seem to do that
19:13:50 <Hijiri> But you need the same definition for all these functions, that's why you're definig it together
19:14:00 <Hijiri> so you can't do anything type-specific
19:14:09 <ReinH> gdsimoes: Since you don't know anything about `a' when you are defining the function, you can't assume that it is a number.
19:14:38 <ReinH> If you want it to be a number, you give it a more specific type like lucky :: Int -> String, but then you can't use it with non-numbers.
19:15:11 <gdsimoes> This seems to be a little limiting‚Ä¶
19:15:14 <scott> gdsimoes: basically that can't ever work because different types may represent different values with the same number or bit pattern at runtime. if you could pattern match on 97 and 'a' how would it tell the difference? so you aren't allowed to do that
19:15:17 <benzrf> gdsimoes: it seems that way at first
19:15:27 <ReinH> gdsimoes: Yes, it absolutely is. It limits you from, e.g., asking if "foo" is a lucky number. :)
19:15:34 <ReinH> In Haskell we think of this as a feature.
19:15:36 <benzrf> gdsimoes: but actually it is very helpful
19:15:43 <benzrf> gdsimoes: it allows you to see what a function does from its type
19:15:48 <benzrf> gdsimoes: for example
19:16:02 <benzrf> gdsimoes: the ONLY function that has the type "a -> a" is id
19:16:18 <benzrf> gdsimoes: if you were allowed to write special cases for different types, something of type "a -> a" could do almost literally anything
19:16:28 <ReinH> gdsimoes: It also prevents you from, e.g., adding a number to a string. In some languages this would be a runtime error. In others, you just get a surprising result that is probably not what you wanted.
19:16:36 <benzrf> but because of the rules of how polymorphism works, you can look at the type and have a good ide aof how it owrks
19:16:47 <ReinH> In type safe languages, you are prevented from doing such nonsensical things by the compiler.
19:16:49 <benzrf> ReinH: i dont think that that's gdsimoes's question
19:17:16 <ReinH> benzrf: I don't think they're asking about parametricity either.
19:17:19 <Hijiri> maybe it would help to think of specific situations where it might seem limiting, but there are better solutions
19:17:27 <Hijiri> of course I have to leave so other people will have to do it
19:17:33 <benzrf> gdsimoes: do you mean, like "why cant i write this function to work like so on Ints and like this on everything else, and get out a -> a"
19:17:54 <gdsimoes> benzrf: Yes!
19:17:58 <benzrf> see
19:18:00 <benzrf> reasonable question :)
19:18:24 <benzrf> gdsimoes: but yes, there is no fundamental limitation to making a language whose type system works like that
19:18:33 <gdsimoes> benzrf: Also I am having some trouble understanding the id example.
19:18:35 <benzrf> gdsimoes: although as scott pointed out, it requires keeping types around at runtime
19:18:53 <ReinH> gdsimoes: Don't worry about the id example.
19:18:58 <ReinH> It's not relevant right now.
19:19:01 <benzrf> gdsimoes: well, basically
19:19:05 <benzrf> gdsimoes: id is defined like this:
19:19:07 <benzrf> id x = x
19:19:10 <benzrf> id :: a -> a
19:19:12 <ReinH> benzrf: this is not the right time to explain parametricity.
19:19:46 <benzrf> ReinH: im just gonna point out that you can tell what a function does better if you're restrained from doing per-type cases
19:19:53 <benzrf> *from its type
19:20:15 <ReinH> gdsimoes: With Haskell, if you want to implement a function for more than one type, you create what is called a typeclass.
19:20:19 <gdsimoes> benzrf: The only function a -> a is id because that‚Äôs the only function I can create without knowing anything about a?
19:20:25 <benzrf> gdsimoes: right :)
19:20:37 <enthropy> type class instances are the way we do per-type cases
19:20:53 <benzrf> gdsimoes: if you could say "f 3 = 4; f x = x" and have that be a -> a (that is, it does nothing to types besides Int)
19:20:54 <gdsimoes> I think I understood now :)
19:21:06 <benzrf> gdsimoes: then the type "a -> a" tells you almost nothing
19:21:06 <ReinH> gdsimoes: In this case, you might say class Lucky a where lucky :: a -> String. Then for each type that you want to implement this for, you create an instance
19:21:22 <ReinH> like instance Lucky Int where lucky 7 = "lucky number"; lucky _ = "not a lucky number"
19:21:30 <benzrf> gdsimoes: as it is, if you look at a function and it has the type "(a -> b -> c) -> (b -> a -> c)"
19:21:38 <benzrf> gdsimoes: you *know* it must flip the arguments of the function
19:21:38 <ReinH> gdsimoes: You would write an instance for each type
19:21:42 <benzrf> gdsimoes: nothing else has that type
19:21:45 <benzrf> gdsimoes: you dont need to look at the docu
19:21:51 <ReinH> benzrf: seriously, stop
19:21:52 <Iceland_jack> gdsimoes: Another (view which is more operational and intuitional) is the function receiving some 'a : A' and then being asked to hand over anything of type 'A'
19:21:56 <benzrf> ReinH: ok :(
19:22:13 <Iceland_jack> But I'll stop as well
19:22:48 <nshepperd> 'lucky :: (Typeable a) => a -> String' would work but be pretty horrible to write I think
19:22:56 <ReinH> gdsimoes: For instance, you want to compare things of various types for equality
19:22:58 <benzrf> gdsimoes: probably the most cut and dry answer is just "it allows you to erase types at compile time"
19:23:10 <ReinH> gdsimoes: so Haskell has a built-in typeclass called Eq that lets you use == for a lot of different things.
19:23:12 <ReinH> :t (==)
19:23:13 <lambdabot> Eq a => a -> a -> Bool
19:23:14 <nshepperd> (Typeable is using run time type information)
19:23:17 <ReinH> > 1 == 1
19:23:19 <lambdabot>  True
19:23:21 <ReinH> > "foo" == "bar"
19:23:23 <lambdabot>  False
19:23:31 <shachaf> 15:34 <shachaf> A function :: forall a. Typeable a => F a -> G a should be called a supernatural transformation.
19:23:34 <ReinH> gdsimoes: But notice that both sides must be the same. This is a type error:
19:23:36 <ReinH> > 1 == "foo"
19:23:37 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
19:23:37 <lambdabot>    arising from the literal ‚Äò1‚Äô
19:23:49 <ReinH> (with a confusing error that we will ignore for right now)
19:23:52 <lfairy> gdsimoes, where are you getting the input to lucky from? that could help us shape the solution
19:24:01 <ReinH> > 'a' == "a" -- you can't compare characters with strings
19:24:02 <lfairy> all this typeable and class stuff seems like overkill...
19:24:02 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Char‚Äô
19:24:02 <lambdabot>              with actual type ‚Äò[GHC.Types.Char]‚Äô
19:24:04 <ReinH> this one is better.
19:24:08 <ReinH> ... slightly.
19:24:31 <acomar> shachaf: thanks, looks like I can use plate to do what I'm looking for
19:24:36 <gdsimoes> lfairy: I was just curious.
19:24:42 <lfairy> guys I think this is too much
19:25:07 <acomar> fromWithin plate works to give me the next descendant
19:25:24 <lfairy> gdsimoes: oh if you're interested then that's cool :)
19:25:28 <ReinH> gdsimoes: anyway the point is that for "overloading" functions in Haskell we use typeclasses.
19:25:51 <ReinH> Which is now a thing that you can look up on the internets for more information :)
19:25:57 <gdsimoes> I will try to learn more about Haskell before trying to do things like these. Thank you very much.
19:27:15 <vanila> How is the id thing parametricity?
19:29:44 <ReinH> vanila: parametricity is that notion that polymorphic types have this "uniformity property" that intuitively says inhabitants of a polymorphic type must act in the same way.
19:29:55 <ReinH> vanila: http://en.wikipedia.org/wiki/Parametricity
19:30:45 <ReinH> vanila: Parametricity is what, e.g., Wadler expoits with free theorems.
19:41:16 <vanila> I think that's just parametric polymorphism
19:42:43 <nshepperd> @free f :: a -> a
19:42:43 <lambdabot> g . f = f . g
19:42:55 <nshepperd> hmm
19:43:34 <scott> vanilla: parametic polymorphism lets you write forall a. a -> a. parametricity tells you what the value of such a type has to be
19:45:22 <nshepperd> can you prove f = id from g . f = f . g?
19:45:30 <dolio> Yes.
19:48:11 <Saizan> take g = const x, then forall x, x = f x
19:50:28 <nshepperd> ahh
19:50:40 <nshepperd> sweet
19:52:03 <Zemyla> Why can't I export pattern synonyms?
19:54:19 <cmccann> Zemyla: use the pattern keyword in the export list
19:54:20 <cmccann> I think
19:54:25 <Yuras> I'm looking for good name for a package/type. Am I right that "erect" in English means also building something? Does it applies to building ADT from JSON or BSON?
19:54:56 <Yuras> (english is not my native language)
19:55:04 <cmccann> Yuras: ...yeeees but you probably don't want to use that name
19:56:02 <Yuras> cmccann: I understand that it has other meanings, but is it really so bad? :)
19:58:19 <creichert> it's mainly used to describe building towers, buildings (At least from what I've heard)
19:58:57 <cmccann> yeah, it more means to raise something into an upright or standing position, so as far as construction goes it would imply a vertical structure
19:59:19 <cmccann> but the anatomical sense is probably the first thing that will come to mind for a lot of people :P
20:00:11 <cmccann> used in context as a verb it'd be fine, with no context in an adjectival form is gonna lead to juvenile snickering
20:00:26 <Yuras> :)
20:00:51 <Yuras> ok, I see. Thank you.
20:00:55 <creichert> so, yes it would work but would have to be a very accurate description
20:06:47 <benzrf> Yuras: im not sure i'd really describe building a data structure as 'erecting' it
20:07:05 <benzrf> Yuras: jokes aside its not the most fitting word
20:11:40 <Yuras> benzrf: well, json is some kind of tree, and ADT too. I imaging a tree growing upright. Also library name not necessary should be related to functionality
20:12:13 <Fuuzetsu> if you want to use the word then use it, no need to convince others
20:13:32 <Yuras> I just want to ensure it is not tooooo bad, so they will not ban me from github and hackage :)
20:32:20 * hackagebot saltine-quickcheck 0.1.0.1 - Quickcheck implementations for some NaCl data  http://hackage.haskell.org/package/saltine-quickcheck-0.1.0.1 (tsuraan)
20:37:20 * hackagebot haroonga 0.1.7.0 - Low level bindings for Groonga.  http://hackage.haskell.org/package/haroonga-0.1.7.0 (cosmo0920)
20:38:19 <ReinH> Computer science has caused me to think of trees as growing downwards...
20:38:54 <vanila> https://www.youtube.com/watch?v=sIRjxQIYOj4
20:39:22 <HeladoDeBrownie> doesn't seem to me like trees the data structure have any inherent directionality in that sense
20:41:47 <nshepperd> trees grow from the root toward the leaves :p
20:42:35 <init> I am still trying to pattern match on trees
20:44:53 <benzrf> for that matter i always envisioned the call stack as pushing down and popping up
20:45:05 <benzrf> er, like
20:45:25 <sdegutis> Is there a statically typed, type-safe language with similar concepts to Haskell besides OCaml?
20:45:31 <benzrf> list of nodes remains still as another one appears beneath them = push
20:45:38 <benzrf> bottom one disappears w/ no movement = pop
20:46:21 <HeladoDeBrownie> sdegutis, any other dialect of ml, agda, idris, coq... depends on what concepts you mean
20:46:35 <bitemyapp> sdegutis: Standard ML
20:46:53 <sdegutis> Thanks.
20:46:58 <HeladoDeBrownie> also, arguably, haskell is not type-safe :)
20:47:01 <init> if by similar you mean a 'powerful typesystem' but not dependantly typed, more than SML / ML dialects I don't think you can find so many?
20:47:39 <HeladoDeBrownie> (although on second reading you didn't actually say it was :P)
20:57:21 * hackagebot paypal-adaptive-hoops 0.7.0.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.7.0.0 (fanjam)
21:05:32 <jonsterling> HeladoDeBrownie: In what way does haskell lack type safety? I assume you're referring to unsafeCoerce and its ilk?
21:06:22 <mniip> unsafeCoerce = const $ fix id
21:06:26 <mniip> type safety fixed
21:06:54 <sdegutis> yay
21:06:56 <jonsterling> mniip: That'd serve anybody right who tried to use it!
21:07:00 <sdegutis> mniip: rescues the day
21:08:06 <cjenkin2> mniip, lol
21:08:35 <HeladoDeBrownie> mniip, that's not part of the haskell language per se, but also it depends on what you mean by "type safety". primarily i had in mind bottom and operations that return it, which are thus not obligated to give an actual useful value of the desired type.
21:09:20 <mniip> unsafePerformIO = (unsafeCoerce :: IO a -> a)
21:09:23 <mniip> purity fixed!
21:09:33 <mniip> haskell is now usable!
21:09:38 <HeladoDeBrownie> woops, i meant jonsterling
21:11:14 <sdegutis> I know two people from #haskell who I first met as regulars in another IRC channel on freenode.
21:11:16 <sdegutis> That's cool.
21:11:44 <benzrf> :t const $ fix id
21:11:46 <lambdabot> b -> s
21:11:49 <benzrf> noice
21:13:05 <sdegutis> TIL bitemyapp = /u/Mob_Of_One on /r/Haskell
21:13:45 <mniip> sdegutis, I know 3
21:14:13 <mniip> actually more
21:14:16 <mniip> I should grep
21:16:59 <sdegutis> I know mniip from #lua and bitemyapp from #clojure
21:20:59 <ezrios> how would one convert a Char to a Word?
21:22:46 <glguy> fromIntegral . ord :: Char -> Word
21:23:02 <jle`> not much of a mob
21:25:07 <ezrios> glguy: thanks!
21:26:43 <sdegutis> jle`: agreed
21:27:37 <wagle> does the haskell-platform live?  its been a year
21:28:14 <mniip> sdegutis, I counted 12 so far
21:28:26 <sdegutis> wowsers
21:28:31 <sdegutis> mniip: am I one?
21:28:55 <mniip> counted you
21:30:03 <jonsterling> HeladoDeBrownie: Ah, I see.. Type safety, from my perspective, is not the same as soundness (which is what breaks in the presence of non-termination), or induction (which is what breaks in the presence of bottoms as values).
21:30:24 <jle`> mniip: your unsafeCoerce definition is identical to `unsafeCoerce = fix id`
21:30:26 <mniip> 15...
21:30:30 <mniip> jle`, no
21:30:35 <jle`> it's not? ;_;
21:30:41 <mniip> yours is too general
21:30:53 <jle`> how abuot i add a type signature ;D
21:31:28 <jonsterling> jle`: "fix id" inhabits every type. "unsafeCoerce" inhabits "a -> b" for every "a" and "b"
21:31:41 <jle`> ah yes.
21:32:04 <HeladoDeBrownie> jonsterling, okay, fair enough. what do you call type safety?
21:32:10 <cmccann> "fix id" is inferior to "fix error" anyway
21:32:31 <cmccann> "fix error" is universally applicable, because fixing errors is always useful!
21:32:32 <mniip> lmao
21:32:37 <jle`> unsafeCoerce = fix id :: a -> b
21:32:38 <mniip> fix error
21:32:39 <jle`> better? :)
21:32:45 <mniip> yeah but
21:33:01 <cmccann> > fix error -- for anyone who hasn't seen this before
21:33:03 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
21:33:04 <jle`> fix error does exactly what it sounds like.  it fixes all the errors.
21:33:16 <wagle> :t fix id
21:33:17 <lambdabot> a
21:33:25 <cmccann> jle`: it's also the primary use case for "fix" I think
21:33:38 <cmccann> certainly I've seen it used that way more often than for other purposes in real code
21:33:57 <jonsterling> HeladoDeBrownie: Type safety, at least as I learnt it, is the idea that a well-typed program either diverges, or is a value of the purported type.
21:33:59 <jle`> have i ever used fix in real code
21:34:03 <jle`> the answer is yes
21:34:14 <jle`> albeit it's tucked away in a typeclass definition heh
21:34:27 <jle`> *instance definition
21:34:28 <jonsterling> cmccann: That's beautiful.
21:34:38 <scott> head (x:_) = x; head [] = fix error -- this would make pattern match failures more exciting
21:34:49 <HeladoDeBrownie> jonsterling, ah, okay. in that case i can't think offhand of anything in the haskell report that is unsafe in that sense, although i wouldn't be terribly surprised if it existed.
21:34:52 <cmccann> scott: agreed
21:35:03 <HeladoDeBrownie> jonsterling, but as you correctly pointed out, ghc haskell *is* unsafe
21:35:07 <mniip> jle`, I found a better definition
21:35:12 <mniip>  fix (const . ($ fix id))
21:35:21 <jle`> ha
21:35:23 <cmccann> isn't unsafeCoerce in the report these days? as part of the FFI.
21:35:29 <jonsterling> HeladoDeBrownie: :) Yes, I think the intention was for Haskell to be type-safe, though it is telling that not a single person has yet mechanized its metatheory to the point where that's believable.
21:35:37 <jle`> :t fix ($)
21:35:39 <lambdabot> a -> b
21:35:46 <mniip> o
21:35:58 <mniip> damn
21:36:09 <Sornaensis> so using the latest ghc seems to break a lot of packages
21:36:09 <jle`> ikr
21:36:13 <HeladoDeBrownie> cmccann, is it? i'll check
21:36:20 <jle`> Sornaensis: you mean HEAD?
21:36:25 <Sornaensis> yea
21:36:32 <mniip> jle`, xD if you think about it
21:36:34 <jle`> you could say...some bridges were burned
21:36:50 <mniip> 'why can't I pass 3 to ++, $ is broken'
21:36:56 <mniip> 'I shold fix ($)'
21:37:09 <sdegutis> What do yall think of PureScript?
21:37:13 <HeladoDeBrownie> cmccann, on a quick scan i don't notice it, although i'm not sure of an efficient way of checking the whole report
21:37:45 <jle`> sdegutis: it's great
21:37:49 <Sornaensis> how do you down grade a package with cabal
21:37:54 <sdegutis> jle`: for real?
21:37:58 <jle`> mniip: yes that's definitely a good idea
21:38:02 <jle`> sdegutis: yeah i like it a lot :)
21:38:05 <jle`> i haven't used it in erla life though
21:38:07 <sdegutis> cool
21:38:14 <jle`> but sometimes i feel like if i were to make a language it'd be similar to that
21:38:20 <jonsterling> HeladoDeBrownie: But as far as GHC haskell is concerned, even in the absence of unsafeCoerce, I should be very surprised if Haskell *were* type safe. For instance, consider the host of problems over the course of the past several years with respect to type classes, generalized newtype deriving, type families, GADTs etc. These things interact in strange ways,
21:38:21 <jonsterling> and we keep on papering over the problems (e.g. Roles) and fixing known issues, but it seems likely to me that there are more gremlins to worry about.
21:38:21 <jle`> i really like the ideas it follows
21:38:26 <jle`> and what it stands for
21:38:56 <sdegutis> "Unlike Haskell, PureScript is strictly evaluated." --- yay!!!
21:39:14 <jle`> strictness kills the performance of most of my programs ><
21:39:50 <mniip> jle`, actually you can apply 3 to ++ if you derive 'instance Num [a]', if you thing about it
21:39:52 <jle`> but i guess i can live with it
21:40:01 <mniip> think*
21:40:14 <jonsterling> jle`: Strictness means I don't need Haskell's tortured, intensional, syntactic treatment of effects, yay! But yeah, laziness is pretty awesome for a lot of stuff, and it would suck to lose it entirely.
21:40:16 <jle`> purescript has javascript's operational semantics, i believe, so in that sense it all makes sense
21:40:26 <HeladoDeBrownie> jonsterling, supposedly languages like idris are practically as safe as you want them to be, although none seems to have as well developed a community as haskell
21:40:36 <jle`> tortured, intensional, syntactic treatment of effects?
21:40:40 <jle`> what does strictness have to do with effects?
21:41:00 <cmccann> HeladoDeBrownie: well there's this: https://www.haskell.org/onlinereport/haskell2010/haskellch30.html
21:41:04 <jonsterling> jle`: Real effects don't play well with laziness. SPJ says rightly that laziness is what kept haskell pure...
21:41:20 <HeladoDeBrownie> cmccann, ah, yep, sounds right
21:41:29 <jle`> laziness is what necessitated the pureness of haskell
21:41:35 <jle`> but a strict haskell could be just as pure
21:41:42 <jonsterling> HeladoDeBrownie: Yeah... Idris is pretty cool!
21:41:46 <jle`> if i had a strict haskell, i would hope it stayed pure
21:42:02 <HeladoDeBrownie> isn't ghc core strict?
21:42:19 <HeladoDeBrownie> or is it just certain constructs that are stricter than the haskell counterparts?
21:42:51 <cmccann> HeladoDeBrownie: though looking at base, unsafeLocalState isn't actually implemented as unsafePerformIO!
21:43:06 <HeladoDeBrownie> cmccann, according to the report, it has additional restrictions
21:43:14 <jle`> man my statements haven't been so strong today with conveying my categorical logic
21:43:37 <HeladoDeBrownie> cmccann, oh, undefined behavior. i guess it *could* be implemented as unsafePerformIO
21:43:42 <jonsterling> jle`: Sure, a strict haskell could/would be pure; for instance, Idris is pure in the same sense as Haskell is, but it is strict. I just want to interrogate the idea that this is what we want; we need purity in order to make laziness tractable, but that doesn't automatically make purity a good thing. In my opinion, effects are often *implementation details*,
21:43:42 <jonsterling> and forcing them into the types totally beats the purpose of types, at least from a type theoretic perspective.
21:44:19 <cmccann> HeladoDeBrownie: the reality is more horrifying still
21:44:24 <cmccann> HeladoDeBrownie: it's implemented as unsafeDupablePerformIO :D
21:44:36 <jonsterling> jle`: The purpose of types is not to classify expressions and algorithms, it is to classify *values* and *functions*. Based on the standard meaning explanations, it is inevitable to consider Haskell's style of effects as an unfortunate accident of history.
21:44:53 <bitemyapp> jonsterling: it is not inevitable
21:45:27 <jle`> i retreat to ponder
21:45:36 <bitemyapp> jonsterling: holding an opinion is one thing, framing it as an inevitable conclusion does a disservice to the topic at hand.
21:45:48 <jonsterling> bitemyapp: Well, it is inevitable *if you believe in the standard meaning explanations of the judgements*. You can propose new ones if you like that validate the way syntactic effect systems work; I've been working really hard this past week on formulating such meaning explanations, and they are very complicated and not so convincing.
21:46:20 <bitemyapp> jonsterling: I don't really have to do any of that.
21:46:50 <jonsterling> bitemyapp: So yeah, there's definitely room for a lot of different views on effects. And I have some pretty strong views. All I'm saying is that the notion of syntactic effects like in Haskell and Idris is not really in the spirit of the meaning explanations for type theory. That's totally fine! Just not what I'm into.
21:46:56 <bitemyapp> I'm not universalizing my preferences and cost-function parameters.
21:47:02 <cmccann> bitemyapp: my opinions are all inevitable conclusions, because the universe is deterministic therefore it was inevitable that I would eventually hold said opinions, QED
21:48:03 <jonsterling> bitemyapp: Sure. I'm just trying to be honest about which sets of views may be held simultaneously. Anyone is free to disagree with me about effects, but they should be aware that they are also adopting a theory of the meaning of types as classifying expressions and algorithms.
21:49:03 <bitemyapp> jonsterling: I've spent too much time getting my sanity annihilated by implicit effects to go back.
21:49:41 <_um> Mightn't there be other ways of making it obvious when a mistake is being made than trapping all effects in the type system?
21:49:42 <bitemyapp> jonsterling: I'm comfortable leaving the delineation of effects relatively coarse-grained for now, until we get better ways of describing and managing that structure - but going back? lol no.
21:50:30 <bitemyapp> jonsterling: if we come up with a less intensional way to describe effects that still makes things explicit, that would be intriguing to me
21:50:41 <jonsterling> bitemyapp: I feel the pain too... I don't think there's any tooling presently around Real Effects that would make me want to use it (i.e. the cost is too high reliability, and I'll sooner just use the crippled strange thing that Haskell gives me). But in the future, I'm thinking that keeping effects out of the *syntactic* types and moving them into the
21:50:41 <jonsterling> semantic layer (i.e. behavioral/refinement typing) would be really great.
21:50:43 <bitemyapp> jonsterling: but something that looks like SML or OCaml is not. Not to me.
21:52:03 <HeladoDeBrownie> _um, so, basically, is the question "can we have type safety even in the presence of certain effects?"? because if so, we have an example even in haskell: ST. it allows limited mutation but none that's observable from outside the ST computation.
21:52:24 <bitemyapp> jonsterling: speaking practically, most of the pain with effects involves over-specific descriptions of monad transformer stacks because the author didn't know mtl / layers / et al. worked
21:53:08 <jonsterling> bitemyapp: Even MTL has serious problems IMO, though it often makes things hurt less... I'm not familiar enough with layers to comment on that though.
21:53:08 <bitemyapp> jonsterling: causing churn when something gets changed / refactored. I think somebody linked Edward's zoomy trick for referring to effects within a stack without needing to care about their place in the stack.
21:53:20 <bitemyapp> jonsterling: oh no doubt, but there's a lot more than mtl these days.
21:53:24 <bitemyapp> elevator is kinda like layers as well.
21:53:59 <bitemyapp> I mostly try to keep my code as simple/dumb as possible and wait for a refactor/actual problem to trigger fanciness so that the fanciness can be guided by a real design problem rather than an anticipated design problem which may never occur.
21:54:02 <jonsterling> bitemyapp: Definitely... I think all these various effects things that are coming out in haskell are pretty cool, and may go a long way to making this stuff a bit less painful to compose. Foundationally, though, I'm skeptical that these can give a believable basis for effects.
21:54:12 <bitemyapp> Designing upfront for anticipated design problems that never hit you can just spawn their own ugly.
21:54:16 <_um> HeladoDeBrownie: I'm mainly just thinking (in my barely understanding way) of some remarks by John Shutt at the very end of this post: http://fexpr.blogspot.com/2011/12/trouble-with-monads.html
21:54:43 <bitemyapp> jonsterling: one thing that strikes me about the various post-mtl libraries is that they're pushing towards "more final" encodings rather than initial ones like EE.
21:55:01 <_um> The point being: "The most "purity" one can then ascribe to a function f, looking at the definition of f without the definitions of other functions it calls, is that f uses other functions as if they were pure, and doesn't itself introduce any impurities."
21:55:13 <bitemyapp> jonsterling: which is really, IMO, what you want since you want representantional independence from your transformer stack.
21:55:15 <jonsterling> bitemyapp: Interesting. I haven't really thought about it from that angle...
21:55:59 <bitemyapp> jonsterling: EE solves the problem through an initial encoding that is order independent, but that only solves one problem, whereas final-encodings-done-right can free you more completely. As an ML user, I think you can appreciate how powerful that can be :)
21:56:04 <jonsterling> bitemyapp: Well, what *I* want is for my types to not know about whatever particular effects I use to implement an algorithm... But maybe I'm alone on that these days...
21:56:11 <bitemyapp> not alone.
21:56:14 <bitemyapp> quite mainstream really :)
21:56:17 <bitemyapp> cf. Rust
21:56:26 <sdegutis> bitemyapp: are you into Rust now?
21:56:30 <bitemyapp> sdegutis: no
21:56:32 <jonsterling> heheh, I never thought it would turn out that my views are mainstream... But yeah.
21:56:36 <sdegutis> I was starting to get into Rust.
21:56:40 <bitemyapp> but mainstream isn't sold on types period, let alone explicitly typed effects.
21:56:57 <jonsterling> They're waiting for us to come up with something better than "typed effects".
21:57:05 <bitemyapp> jonsterling: the only real replacement I see in the future for intensionally typed effects
21:57:16 <LordBrain> separating effect-implementation from effect-algorithm is going to be the real pay off, eventually.. and i see forcing effects into walled-off monads as helpful toward that end.
21:57:22 <bitemyapp> jonsterling: at least for what I care about, would be stuff like TLA+ where it enforces the intent rather than structure of what I'm doing
21:57:52 <bitemyapp> jonsterling: but that is a long way off. TLA+ only covers temporal stuff - ie, concurrency.
21:57:53 * jonsterling Jon's great delusion is that the mainstream rejects Haskell because "We would prefer to have a behaviorally typed logical framework lying over a structurally typed impure functional language"
21:58:27 <bitemyapp> jonsterling: expanding that to cover all effects would be v. difficult. Overlaps in mutex ownership are relatively simple to model compared to the vast universe of effects possible.
21:58:34 <LordBrain> if effects weren't in the type system, it would complicate things later if we ever wanted to 're-implement' effects of legacy code.
21:58:38 * cmccann doesn't trust structural typing
21:58:48 <bitemyapp> you'd end up with a micro-language for each "kind" of effect.
21:58:55 <bitemyapp> maybe LVars'ish? Dunno.
21:59:12 <jonsterling> cmccann: (To be clear, by structural typing I mean the kind of typing in Haskell and ML and Agda, as opposed to behavioral typing, which is what you'd find in something like Nuprl)
21:59:13 <bitemyapp> I don't know that anybody is even working on that. Probably not.
21:59:25 <bitemyapp> Maybe after people are done plumbing homotopy :)
21:59:28 <cmccann> jonsterling: ah
21:59:40 <bitemyapp> cmccann: ext vs. int
21:59:40 <heatsink> What is behavioral typing?
21:59:50 <bitemyapp> heatsink: I think jonsterling means extensional type theory
21:59:53 <jonsterling> cmccann: Maybe "syntactic" is a better word to use. I never know what to say, so I just cycle through the words...
22:00:22 <jonsterling> Well, by "behavioral typing" I mean typing which classifies only *observable/extensional* behavior.
22:00:37 <heatsink> ok
22:00:43 <cmccann> jonsterling: well there's glory for you!
22:01:13 <bitemyapp> jonsterling: have you ever done anything with TLA+? Do you find dist-sys/concurrency interesting?
22:01:17 <LordBrain> maybe we should actually have 2 different type signatures
22:01:36 <bitemyapp> jonsterling: if the answer is no / yes - you should check it out.
22:01:37 <jonsterling> bitemyapp: No, I haven't... I'm not too interested in distributed systems or concurrency, but I may find myself looking into the former at some point...
22:01:41 <LordBrain> one for structural , one for behavioral
22:01:49 <jonsterling> LordBrain: Ding ding ding!
22:02:09 <jonsterling> LordBrain: This is why I kind of like liquid haskell. I'm not so into the fact that I can't write my own proofs, but I think they've got the right idea otherwise.
22:02:22 <LordBrain> sorry i was away when this started, so if i am repeating old ideas...
22:02:32 <HeladoDeBrownie> _um, i'm not sure i'll be able to grasp what that's talking about just now, since it's actually about time for me to go to bed, but it sort of makes me nervous that it commits certain intuition errors about monads and IO. e.g., monads are about impurity, types forming a monad look similar to IO, IO can be seen as functions taking the real world as an argument and returning a new one.
22:02:48 <HeladoDeBrownie> granted, these are common errors, but errors nonetheless
22:02:55 <bitemyapp> jonsterling: I miss the ability to write proofs in LH as well, but it has very nice UX for what it does.
22:03:02 <jonsterling> HeladoDeBrownie: I don't think that I have made any of those errors yet, though maybe I shall before the night is through!
22:03:08 <mniip> in other news I've defined instance (Eq a, Bounded a, Enum a) => Enum [a]
22:03:09 <LordBrain> Liquid haskell is totally new to me
22:03:13 <mniip> now gotta figure out why is it useful
22:03:14 <LordBrain> just hearing about it
22:03:20 <bitemyapp> LordBrain: it's pretty sweet. It has a web demo
22:03:26 <bitemyapp> LordBrain: you can go poke at it in 15 seconds flat.
22:03:41 <bitemyapp> LordBrain: it's the best demo for, "lets bolt an SMT solver onto GHC" I've seen :)
22:03:46 <jle`> also ranjit jhala is literally the man
22:04:21 <_um> HeladoDeBrownie: Those concerns are well received and noted! I haven't reread that stuff since spending serious time with Haskell.  I'll have to revisit it.
22:04:25 <bitemyapp> jle`: lmao
22:04:53 <LordBrain> oh
22:05:28 <jonsterling> Oh HeladoDeBrownie, sorry for butting in. I didn't realize that _um was a username ;-)
22:05:38 <LordBrain> if it has an SMT solver bolted in, why do you say you can't do your own proofs? is it incompatible with proof-assistant style operation?
22:05:45 <HeladoDeBrownie> jonsterling, haha, no worries
22:06:18 <LordBrain> or is just something that's not implemented
22:06:36 <bitemyapp> LordBrain: uh, that's not what SMT solvers are for
22:06:41 <jonsterling> LordBrain: I think that it is compatible with it, in theory. But just not currently in practice. If I were to integrate a solver into a real proof assistant, I'd need to be sure that the theorems the solver is realizing do not have any computational content (so that it does not destroy computational content).
22:07:00 <HeladoDeBrownie> anyway, as i alluded to, i'm off to bed. good night~
22:07:30 <bitemyapp> LordBrain: SMT solvers are tuned to a particular domain and kind of problem, proof assistants like Coq/Agda are generic proof checkers.
22:07:43 <LordBrain> yeah but they come with SMT solvers
22:07:52 <jonsterling> One of the big ideas of Intuitionism is that you do not a priori place any constraints on the particular form an effective realizer/witness might take, and as such, it's perfectly fine to say that a proposition is verified by a solver, so long as the artifact from the solver can cash the checks it writes.
22:07:58 <LordBrain> at least isabelle does
22:08:06 <bitemyapp> LordBrain: but the SMT solver is just the search part
22:08:49 <bitemyapp> LordBrain: expanding LH beyond what it currently does is tantamount to "design dependently typed Haskell", since that's really what people would want if they could construct proofs.
22:09:11 <LordBrain> oh well yes, i would have figured as much really
22:09:14 <monochrom> adding an SMT solver does not automatically add a way to input your own proof. no more than buying a microwave oven adds a way to warm up food by your body.
22:09:19 <LordBrain> but remember, i have no idea what LH is at this point
22:09:33 <jonsterling> bitemyapp: I think there's room for a different version of that idea, which would be keep going with Liquid Haskell, but just expand it into full-on Nuprl, but built around Haskell.
22:10:00 <jonsterling> So you wouldn't really need "dependent haskell"; you could continue doing all your reasoning in the external logical framework, except you'd be freed to have proofs that come from sources other than a solver.
22:10:07 <bitemyapp> jonsterling: that's what I was dancing around in my words, but I danced around it because I can't even imagine what that would look like.
22:10:18 <bitemyapp> jonsterling: Haskabelle'ish?
22:10:21 <jonsterling> :) It would look pretty cool is what it would look like
22:10:37 <LordBrain> i think "dependent haskell" is really just a matter of time....
22:10:42 <jonsterling> *ugh*
22:10:54 <LordBrain> not looking forward to that huh?
22:11:16 <bitemyapp> LordBrain: jonsterling isn't a fan of CoC'ish DTPLs.
22:11:47 <jonsterling> yeah....... impredicativity is kind of a turn off.
22:12:44 <jonsterling> Anyway, I've spent too much time antagonizing people on IRC tonight, so I'll be off watching Deep Space Nine. Good night!
22:14:11 <bitemyapp> jonsterling: it was a pleasure anyway :)
22:14:24 <sdegutis> Is there a language almost just like Haskell that has strict evaluation?
22:15:04 <bitemyapp> sdegutis: Haskell with the strict pragma
22:15:11 <jle`> with strict evaluation, almost the entire ecosystem and idioms are going to be different
22:15:12 <bitemyapp> sdegutis: poke Tibell about it.
22:15:24 <bitemyapp> sdegutis: Not really sure why you want strictness so badly.
22:15:32 <Hijiri> call of cthulu?
22:15:36 <Hijiri> oh
22:15:39 <Hijiri> calc of constructions?
22:15:45 <mseeks> do RecordWildCards work "normally" even if all the accessors are namespaced?
22:15:49 * jonsterling promised to leave, but is having trouble keeping his mouth shut about the strictness pragma (fyi, no no no)
22:16:10 <jle`> see ocaml for an example of a language that's sorta-similar but with strictness, and how drastically all of the idioms and ecosystem style has diverged
22:16:10 <mseeks> e.g., say module M exports a type Thing {a :: Int}. then in another module which imports M qualified could I do `f M.Thing{..} = M.a`?
22:16:11 <LordBrain> sdegutis, ! makes it strict...
22:16:24 <sdegutis> bitemyapp: mostly because I don't care too much about purity, but I like static typing and type inference and have grown fond of Haskell's tpye notation
22:16:26 <LordBrain> but if you mean by default...
22:16:41 <LordBrain> there are some haskellish languages that are strict
22:16:56 <jle`> a lot of things that you take for granted in every day haskell programming become meaningless/really weird in a strict language
22:16:59 <bitemyapp> sdegutis: turning on strictness won't make purity go away.
22:17:14 <bitemyapp> sdegutis: if you don't want purity, you definitely want OCaml/SML/Yeti/Rust et al.
22:17:23 <jle`> so in a sense "a strict haskell", in practice, would look nothing like practical haskell
22:17:45 <bitemyapp> sdegutis: it takes time and practice to get used to working with explicit effects. I think it's worth it, but I've got a lot of scars that make me averse to going back to implicit effects ever again.
22:17:46 <mseeks> I feel like RecordWildCards don't work with qualified modules
22:18:04 * jle` imagines those movies where someone travels back in time to change one small thing and upon coming back literally everything is different
22:18:32 <jle`> mseeks: i know one way to find out :)
22:18:36 <scott> likewise some things that seem natural in a strict language are weird and pointless in haskell
22:18:37 <sdegutis> Whoa. Sometime within the last hour, #rust on irc.mozilla.org decided to disallow unregistered users from joining.
22:18:50 <mseeks> jle`: yeah I know but I thought asking here would be faster
22:18:54 <scott> sdegutis: just now, it was getting spammed
22:19:09 <scott> sdegutis: and, er, still is
22:19:16 <sdegutis> bitemyapp: my main concern is that you really never know when something will be executed
22:19:33 <bitemyapp> sdegutis: nonsense.
22:19:42 <LordBrain> sdegutis, so its not purity you dislike but laziness...
22:19:53 <sdegutis> bitemyapp: it came as a huge surprise to me in the "echo" example when you found out that getContents actually continued to receive contents more than once, like a pipe!
22:20:05 <sdegutis> LordBrain: ah yes right, laziness is what I wanna get ridda
22:20:47 <LordBrain> i suppose you could try idris
22:21:00 <LordBrain> its strict by default
22:21:26 <LordBrain> and nearish haskell, but the differences are in the type system, so maybe htat's not hte kind of nearness you wanted
22:21:39 <jle`> sdegutis: what sort of execution do you mean?
22:21:46 <jle`> haskell makes sequencing execution pretty clear
22:21:54 <jle`> (if you avoid lazy IO that is)
22:22:09 <jle`> understanding when things are evaluated might take a little more work
22:22:17 <sdegutis> jle`: the typical example of getContents >>= (\x putStrLn x) is scary to me
22:22:17 <gfixler> sdegutis: what echo example?
22:22:18 <bitemyapp> if you can't handle reasoning about outside-in evaluation, jumping into idris won't be much help.
22:22:27 <sdegutis> gfixler: that one 3 lines above
22:22:34 <jle`> sdegutis: ah.  that's more lazy IO than laziness
22:22:39 <dmwit> Laziness and lazy IO are very different. Plenty of people would endorse laziness but not lazy IO.
22:22:46 <jle`> i am not a fan of lazy IO
22:22:50 <Hijiri> I agree that lazy IO is in general not that great
22:22:51 <jle`> let the record show
22:22:53 <sdegutis> jle`: because it *looks* like getContents is being called once and getting the results put into x, but it's getting called many times
22:22:54 <bitemyapp> I adore non-strict eval. I avoid lazy IO.
22:23:09 <jle`> sdegutis: yeah, that's not the laziness we typically talk about when we talk about haskell
22:23:10 <platz> I'd just be happy with StrictPragma
22:23:12 <jle`> er, laziness in haskell
22:23:15 <dmwit> getContents... is not getting called many times.
22:23:22 <sdegutis> So it's simply the IO monad I hate?
22:23:27 <bitemyapp> sdegutis: nope.
22:23:29 <Hijiri> it's specifically lazy IO you hate
22:23:33 <sdegutis> dmwit: and that's what confuses the heck out of me
22:23:44 <dmwit> uh?
22:23:45 <bitemyapp> sdegutis: learn it before you reject it.
22:23:49 <bitemyapp> sdegutis: make an informed decision.
22:23:49 <jle`> so you like laziness, you just don't lazy io :)
22:23:52 <sdegutis> dmwit: if I see something happening more than once on screen, then it's happening more than once somewhere, somehow
22:23:59 <jle`> it's not the IO type that you hate
22:24:04 <bitemyapp> @karma+ jle`
22:24:04 <lambdabot> jle`'s karma raised to 15.
22:24:07 <sdegutis> bitemyapp: my informed decision can rightfully be "I don't understand this even though I should be able to"
22:24:10 <bitemyapp> jle`: :)
22:24:14 <bitemyapp> sdegutis: should?
22:24:19 <bitemyapp> sdegutis: why should you understand it?
22:24:45 <dmwit> sdegutis: I think what you actually hate is potentially the default behavior of stdin?
22:24:50 <dmwit> Which really has nothing to do with Haskell.
22:24:51 <sdegutis> bitemyapp: meaning, given my understanding of the language, which I thought was sound, that should have made sense
22:25:08 <gfixler> sdegutis: isn't that just echoing?
22:25:09 <jle`> by the way, a strict evaluation language can still make the bad decision to have lazy io
22:25:14 <dmwit> I mean. It does. But Haskell copies most other languages in that regard.
22:25:15 <sdegutis> dmwit: but in other languages, this kind of thing happens in a loop
22:25:22 <dmwit> no
22:25:26 <sdegutis> dmwit: in Haskell, you see the same looping behavior, but there's no loop
22:25:34 <Hijiri> sdegutis: you don't have to use getContents
22:25:35 <bitemyapp> sdegutis: assume you know less and you'll be unpleasantly surprised less often.
22:25:37 <Hijiri> I wouldn't either
22:25:40 <dmwit> ?src getContents
22:25:40 <lambdabot> getContents = hGetContents stdin
22:25:45 <dmwit> ?src hGetContents
22:25:45 <lambdabot> Source not found. It can only be attributed to human error.
22:25:46 <Hijiri> you can get the input line by line if you want
22:26:00 <Hijiri> and that would be strict IO, I think
22:26:12 <Hijiri> (or you could do something fancy like pipes if you need more complicated processing)
22:26:12 <gfixler> sdegutis: are we talking about each typed letter appearing twice?
22:26:38 <dmwit> sdegutis: If you look into the source of hGetContents you will see a loop.
22:26:45 <dmwit> sdegutis: So I don't really know what you're on about.
22:26:47 <sdegutis> gfixler: no
22:26:51 <Hijiri> hGetContents uses unsafeInterleaveIO doesn't it?
22:26:57 <sdegutis> gfixler: more like, if you type "a" and press enter, then type "b" and press enter
22:27:25 <sdegutis> dmwit: I'm talking about how "x" is bound more than once in that monad, even though there is no explicit loop in the monad
22:27:35 <sdegutis> Using the example of getContents >>= (\x putStrLn x)
22:27:43 <mauke> it's not bound more than once
22:27:48 <Hijiri> what makes you think it's bound more than once?
22:28:02 <dmwit> sdegutis: It's not bound more than once. Also your syntax is wrong (you're missing a "->").
22:28:15 <sdegutis> Because each time you press enter, you get to type more and press enter again, and see each thing each time.
22:28:25 <sdegutis> dmwit: I'm using bind notation instead of do-notation.
22:28:32 <dmwit> sdegutis: Are you just wishing you had used getLine instead of getContents...??
22:28:45 <dmwit> sdegutis: I'm familiar with the notation of Haskell, thanks.
22:28:47 <Hijiri> sdegutis: it's not being bound more than once, it's just lazily getting parts of the list
22:28:48 <sdegutis> Maybe I'm totally and completely wrong.
22:28:52 <sdegutis> And probably so.
22:28:52 <Hijiri> ie the lazy IO we are talking about
22:28:53 <glguy> sdegutis: x isn't changing, it's just continuing to get longer
22:28:56 <dmwit> You are totally and completely wrong.
22:29:03 <sdegutis> Ooooh.
22:29:04 <Hijiri> x here is a list
22:29:08 <Hijiri> not the characters being printed
22:29:23 <Hijiri> it's a list of all the stdin, when you ask for more parts of the list it gets more input
22:29:26 <sdegutis> So putStrLn is actually asking for the rest of the list, and printing it each time it gets more.
22:29:32 <sdegutis> That's a lot less terrifying.
22:29:34 <mauke> right
22:29:46 <mauke> (and putStr contains a loop)
22:29:51 <sdegutis> I assumed, because of the list monad, that it was executing the whole chunk of things for each input line.
22:29:55 <mauke> putStr = mapM_ putChar or something like that
22:29:59 <gfixler> are things ever bound twice in haskell? I thought graph reduction took care of that
22:30:02 <mauke> nope, no list monad here
22:30:08 <Hijiri> this doesn't have to do anything with list's monad instance
22:30:10 <sdegutis> I guess the list monad confused me also then, because it's not actually doing that either.
22:30:47 <sdegutis> I assumed that in the list monad, the body of the monad is run over multiple times, since a variable would be bound to multiple values, as in the list comprehension.
22:31:00 <sdegutis> And maybe it actually is. In which case, I'm terrified of it once again.
22:31:08 <Hijiri> I don't think putStrLn uses the list monad
22:31:10 <mauke> sdegutis: that sounds right!
22:31:11 <Hijiri> just a list
22:31:32 <Hijiri> or getContents if you were talking about that
22:31:40 <shachaf> Everything is a monad these days.
22:31:45 <mauke> sdegutis: in the list monad, >>= is basically concatMap
22:31:46 <sdegutis> Unless the value of a bound variable in a list monad is actually just bound to another monad. In that case it's not so scary. But I doubt it.
22:31:48 <jle`> what about the monad monad
22:32:11 <scott> mauke: s/basically//
22:32:19 <mauke> scott: wrong argument order
22:32:22 <sdegutis> mauke: That I get. The problem is how a do-block that appears sequential in a monad is actually not sequential per se, and has a bound variable called multiple times.
22:32:25 <scott> ah fair enough
22:32:32 <sdegutis> mauke: And that just made me scared of the IO monad, especially in light of getContents.
22:32:37 <sdegutis> mauke: but apparently wrongfully.
22:33:05 <mauke> sdegutis: well, it's just a callback (and a do-block a bunch of nested lambdas)
22:33:11 <sdegutis> jle`: lol you mean monad transformers?
22:33:20 <mauke> so yeah, sequentiality is not guaranteed
22:33:21 <Hijiri> do blocks for IO I'm pretty sure sequential, since bind is sequential
22:33:24 <sdegutis> mauke: right
22:33:37 <sdegutis> Hijiri: bind isn't sequential
22:33:43 <Hijiri> IO's bind is
22:33:46 <jle`> monad transformers aren't really monads :) not in general at least
22:33:56 <sdegutis> jle`: you shoudl write one for it
22:33:56 <jle`> i was just making a joke heh
22:34:02 <dmwit> sdegutis: If you're scared of [], wait until you discover Cont.
22:34:19 <shachaf> The type "m a" isn't a monad, and a value of type "m a" isn't a monad. Neither is a function of type "a -> m b".
22:34:30 <mauke> yeah, at least [] is just nested loops :-)
22:36:09 <sdegutis> dmwit: I am already quite afraid of call/cc
22:36:33 <shachaf> Cont is great.
22:36:34 <glguy> sdegutis: these arguments aren't magically changing any more than any functions' arguments "change" each time you call them
22:36:59 <sdegutis> That said, call/cc seems a lot less scary in a language where you basically just concatenate a bunch of callbacks to create "sequential operations", since it's then trivial to unwind them, just like the Maybe monad easily shows
22:37:03 <shachaf> I thought people were talking about getContents, in which case this thing isn't true at all.
22:37:24 <shachaf> But for [] it's true, the same way that x is magically changing in "map (\x -> x + 1) [1,2,3]", as glguy points out.
22:37:38 <sdegutis> shachaf: fair enough
22:37:45 <jle`> f x = x + 3.  if i do f 5 and f 7, x is two different things :O
22:37:57 <shachaf> That's why x is called a variable.
22:38:05 <sdegutis> I think I just convinced myself that Cont is actually extremely reasonable.
22:38:11 <mauke> shachaf taking the words right out of my keyboard
22:38:25 <sdegutis> And I can see some legitimate use-cases for it, e.g. bailing out early from a failed operation and trying something else.
22:38:41 <sdegutis> Does that sound righT?
22:38:47 <sdegutis> (typo, not pun)
22:39:09 <shachaf> Many uses of Cont are overkill and would be better served with a simpler monad.
22:39:18 <mauke> that sounds right, but also what shachaf said
22:39:22 <sdegutis> Like what?
22:39:30 <dmwit> Either
22:39:31 <sdegutis> (for either use-case or the simpler monad)
22:39:35 <glguy> If you just want to bail out early you can use Maybe
22:39:41 <sdegutis> Reasonable also.
22:39:42 <mauke> dmwit: less efficient, no?
22:39:48 <sdegutis> So far I'm re-sold on Haskell.
22:40:00 <jle`> yeah i'm unsold and resold every day
22:40:02 <sdegutis> But the thing that was bothering me before was the tooling.
22:40:06 <dmwit> mauke: Oh, I dunno. Thus far I have somehow managed to avoid efficiency problems.
22:40:20 <shachaf> Is Either less efficient?
22:40:22 <dmwit> ?quote Maybe.*something
22:40:22 <lambdabot> cmccann says: the Either monad is like the Maybe monad, except with something instead of Nothing.
22:40:35 <shachaf> What about CPSified Either?
22:40:51 <dmwit> I think Ed has a package with a CPS'd Either.
22:40:58 <sdegutis> Btw what do yall think of Idris?
22:42:09 <scott> sdegutis: the strictness is controversial with experienced haskellers
22:42:33 <shachaf> @let every l = cont (\k -> all k l)
22:42:36 <lambdabot>  Defined.
22:43:04 <scott> :t cont
22:43:05 <lambdabot> ((a -> r) -> r) -> Cont r a
22:43:08 <shachaf> > (`runCont` even) $ do { every [1,2,3]; every [4,5,6] }
22:43:10 <lambdabot>  False
22:43:17 <shachaf> > (`runCont` even) $ do { every [2,4]; every [6,8] }
22:43:19 <lambdabot>  True
22:45:49 <shachaf> What a terrible example.
22:46:14 <glguy> Go easy on shachaf , he's trying
22:46:16 <shachaf> I don't even know what I was thinking. Oh well.
22:47:52 <sdegutis> What do you think of Idris?
22:47:59 <shachaf> You already asked that.
22:48:07 <dmwit> "neat!"
22:48:19 <shachaf> "what do you think of $otherlanguage?" questions often lead to no good
22:48:19 <bitemyapp> "fun!"
22:48:43 <sdegutis> It often is very informative for me, especially considering I ask both sides and consider their biases.
22:48:46 <anastas> hey, relative (complete) newbie to the haskell ecosystem here: would be interested to hear from doctoral students in mathematics that have managed to find directly applicable benefit from intimate knowledge of haskell to their doctoral studies
22:48:49 <sdegutis> It paints a really beautiful picture.
22:49:06 <shachaf> #haskell isn't a side.
22:49:12 <mniip> "intimate knowledge of haskell"
22:49:18 <mauke> both sides! country *and* western!
22:49:25 <dmwit> sdegutis: Do feel free to ask more questions about Haskell, though!
22:49:30 <anastas> mniip: yes, as opposed to following a couple tutorials off the internet
22:50:42 <anastas> mniip: is that off topic for this channel? again, this guy  <--- is new
22:50:55 <mniip> mmmm#, yeah#, unbox your data into me
22:51:17 <shachaf> mniip: Your behavior is inappropriate for this channel.
22:51:22 <dmwit> It's not off-topic. But it is pretty targeted and specific, so it may be tricky to find somebody who is willing to answer and around at the right moment to see the question.
22:51:34 * mniip flees >.>
22:51:35 <shachaf> anastas: It's not off-topic, but I don't know how likely you are to get useful answers.
22:52:01 <anastas> shachaf: any recommendations for a better place to ask?
22:52:15 <johnw> I wonder if ##categorytheory might have some opinions...
22:52:22 <shachaf> Maybe a mailing list like haskell-cafe@?
22:52:29 <johnw> although the overlap with this channel is pretty large
22:52:31 <shachaf> For the reasons dmwit mentioned.
22:52:35 <shachaf> Not that anyone reads -cafe anymore.
22:52:41 <johnw> I read -cafe!
22:52:54 <glguy> Yeah -cafe is too busy, no one goes there
22:53:43 <anastas> hmm.
22:53:45 <dmwit> Also, this question has a few of the same red flags that made us uneasy about answering the Idris question. =)
22:53:59 <anastas> was not here for the idris question
22:54:32 <dmwit> I just mean that language choice debates are rarely productive.
22:54:41 <dmwit> And this sounds like the start of a language choice debate.
22:54:45 <anastas> language choice in the sense of programming language choice?
22:54:48 <dmwit> yes
22:54:57 <anastas> ohhh I understand that apprehension
22:55:06 <anastas> if anyone cares, I'll briefly expand on why I'm asking
22:55:22 <dmwit> That might help!
22:55:27 <shachaf> Better to expand first and see if anyone cares after.
22:55:37 <shachaf> That way people don't have to commit to caring without knowing what you're going to say.
22:55:48 <anastas> I'm a grad student in math and I've taken algebraic topology, where we learned homology and cohomology and such
22:56:02 <anastas> for example we learned the steelrod-eilenberg exioms (sp?)
22:56:25 <anastas> I know from having gone past the assigned studies that there's a lot of the historical development of these studies that was intertwined with category theory
22:56:49 <anastas> as someone with an undergrad in CS that also tries to keep up, I know that there's a lot of formal study into the language desig of haskell
22:57:26 <anastas> however, the particular combinations of what I've studied in the courses is obviously catered towards specializing in, say, algebraic topology, for example, and it (quite understandably) does not account for CS interests
22:58:02 <anastas> so, I was curious as to how someone with a reasonably solid beginning in algebraic topology and such could break into haskell proper and the theoreticall underpinning of design discussions
22:58:06 <anastas>  - but -
22:58:17 <anastas> without being directed to Learn You a Haskell or whatever
22:58:18 <anastas> make sense?
22:58:47 <anastas> (/rant)
22:59:33 <anastas> err - not "break into discussions" as if I'd have anything to contribute, more like "start to listen in and learn something"
23:01:10 <shachaf> Makes sense, and seems like a reasonable question.
23:01:19 <shachaf> I'm not sure that I know the best answer.
23:02:28 <dmwit> anastas: I think TAPL + the Gentle Intro would be a great way to break into the discussions.
23:02:40 <bitemyapp> anastas: Haskell doesn't have a formal semantics
23:02:51 <dmwit> That's the route I took, though admittedly I had a CS background.
23:02:56 <bitemyapp> not to my knowledge anyway
23:03:07 <bitemyapp> anastas: so if you mean to talk about Haskell specifically, you won't be able to do so cogently without learning to use it.
23:03:25 <dmwit> bitemyapp: It's sufficiently close to the standard PL theory that learning about the standard set of semantics will be a pretty darn good start.
23:03:43 <dmwit> bitemyapp: I think Haskell doesn't have a semantics more because it's a big project than because it's necessarily unusually hard.
23:04:05 <bitemyapp> dmwit: I don't disagree.
23:04:23 <dmwit> e.g. Tackling the Awkward Squad includes a semantics for IO, which looks very standard compared to other operational semanticses
23:05:27 <dmwit> anastas: Anyway TAPL is focused pretty heavily on type theory, which is a close cousin to category theory.
23:06:56 <dmwit> ...it's also written in the no-nonsense academic style that LYAH very much lacks. =P
23:06:59 <anastas> bitemyapp: yes of course, and I've been using what I've been finding online to try to get there, but it's a tad frustrating to keep finding tutorials aimed at novices in programming
23:07:32 <bitemyapp> anastas: hum, I have a guide for learning Haskell.
23:07:35 <anastas> dmwit: I am not familiar with the acronym TAPL, but I can say that what you're talking about is exactly what I'm wondering how to get into
23:07:37 <bitemyapp> anastas: it's well suited to accelerated learners.
23:07:41 <dmwit> ?where TAPL
23:07:41 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
23:07:43 <anastas> I mean, I have the HoTT book on my bookshelf
23:07:57 <bitemyapp> anastas: http://www.amazon.com/gp/product/0262162091/ref=as_li_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0262162091&linkCode=as2&tag=bitemyapp-20&linkId=4EPPD3AJHQVPSCYV
23:08:16 <bitemyapp> anastas: that's TAPL, here's my guide: https://github.com/bitemyapp/learnhaskell
23:08:18 <dmwit> anastas: HoTT is a great recommendation for that area as well.
23:08:39 <bitemyapp> anastas: if you know topology, what books in that field would you recommend?
23:09:13 <anastas> bitemyapp, dmwit: thank you for the links
23:09:35 <dmwit> ?where gentle
23:09:35 <lambdabot> http://www.haskell.org/tutorial/
23:09:42 <bitemyapp> anastas: cheers. the guide is basically telling you to run through exercises. You can proceed at whatever pace is comfortable.
23:09:43 <anastas> bitemyapp: well, at what level? undergrad, grad? and do you mean general topology, or including algebraic?
23:09:56 <Cookieman> hey guys, i was trying to build hlint and it's complaining stating "Setup: At least the following dependencies are missing: extra >=0.5", i've scoured google for the package but i can't seem to find anyone else with that problem
23:09:57 <bitemyapp> anastas: assume I'm a total moron with only remedial high-school level mathematics.
23:10:08 <bitemyapp> anastas: make that assumption...and you'll be right :)
23:10:46 <dmwit> Cookieman: Just "cabal install extra"?
23:10:48 <anastas> bitemyapp: well, if that's the prompt, then we can't assume that there's any serious algebraic background, so algebraic topology is out, so we're talking about general topology
23:10:57 <dmwit> Cookieman: For that matter, why not just "cabal install hlint"?
23:11:09 <dmwit> Cookieman: It'll track down dependencies for you, assuming they're on Hackage. Which that one is.
23:11:29 <anastas> bitemyapp: the canonical text is munkres. personally, I did not like munkres (or hatcher, for that matter), for algebraic topology, but I do have to say that munkres does do a rather solid job for basic general topology
23:11:34 <bitemyapp> anastas: wfm. If you have the time, a progression would be lovely.
23:12:43 <anastas> bitemyapp: I definitely have the time, I need more of a prompt though
23:13:37 <bitemyapp> anastas: hrm, sorry.
23:13:42 <bitemyapp> anastas: I have no university education.
23:13:53 <Cookieman> dmwit: I was trying to use the AUR from arch linux to install hlint
23:14:03 <anastas> bitemyapp: maybe take it to PM? this sounds off topic for this channel
23:14:08 <bitemyapp> anastas: it is
23:14:09 <Cookieman> dmwit: really hate going through cabal hell
23:14:18 <dmwit> Cookieman: ...and there's no dependency handling on AUR stuff? I don't remember that detail.
23:14:24 <dmwit> Cookieman: There must be tools out there.
23:14:44 <dmwit> I'm pretty sure yaourt used to handle dependencies for me, no idea if that thing is still around.
23:15:12 <Cookieman> dmwit: there is dependency handling, i'm using aura
23:15:16 <dmwit> anastas: Book recommendations on any topic are welcome in #haskell-blah, for sure.
23:15:26 <Cookieman> dmwit: it's just it didn't download that one for some reason..
23:15:56 <dmwit> anastas: Though on second thought you might want to continue in PM anyway. =P
23:17:57 <anastas> dmwit: yeah, that convo is going to PM, but I'd be more than happy to help out with pure math studies in return for mentorship with haskell etc :D
23:19:18 <jle`> math is power
23:19:48 <jle`> i'm curious as to exactly what parts of haskell are required for understanding how category theory etc. are applied to it
23:20:16 <jle`> certainly things that are necessary for programming in it (mastery of syntax) aren't as necesasry for those trying to understand where cat theo is applied
23:20:19 <evenex> i'm doing my senior project on cat theory and frankly the haskell wiki has been the most helpful resource in actually figuring out wtf is going on
23:20:55 <jle`> from the perspective of a category theorist that is
23:20:58 <jle`> evenex: nice :)
23:21:04 <jle`> is it gonna be published :O
23:21:39 <evenex> i doubt it, but we'll see. i'm still learning the ropes, haven't decided on a direction to take it. i'm thinking something along the lines of lifetime management functors
23:21:44 <evenex> refcounted RAII, etc
23:22:55 <evenex> but i'm still at the stage where i'm trying to wrap my head around yoneda
23:23:36 <evenex> i lurk on this channel a lot too but most of the theoretical discussion is still going way over my head. but i figure, to the extent that its like learning a language, immersion should help
23:30:05 <mniip> is there some place where can I read abut the usual directory layout of a haskell project?
23:30:24 <mniip> my messings with haskell haven't been larger than one file yet heh
23:30:48 <jle`> i usually don't go more than `cabal init`, heh
23:30:52 <jle`> and src/
