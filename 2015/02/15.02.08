00:06:26 * hackagebot yesod-bin 1.4.3.6 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.6 (MichaelSnoyman)
00:15:11 <ddellacosta> would anyone take a look at my super basic Queue implementation, and give me feedback on how idiomatic it is, and how I may be able to structure it more intelligently, in terms of more appropriate types (i.e., seems like there could be a monad pattern used where I'm using the tuple)
00:15:12 <ddellacosta> https://gist.github.com/ddellacosta/bbca6ce6ad0e52eda2a3
00:16:43 <mjrosenb> ddellacosta: I would not use a pattern guard to detect q_out being empty.
00:17:04 <ddellacosta> mjrosenb: can you tell me why not?
00:17:59 <mjrosenb> ddellacosta: because it is much simpler to just check for an empty queue in your pattern
00:18:21 <ddellacosta> mjrosenb: sorry, how are you envisioning that?  I have to admit I don't see it
00:19:32 <mjrosenb> e.g. dequeue (Q _in []) = (last q_out, Q q_in = [], q_out = tail (reverse in_})
00:19:45 <ddellacosta> mjrosenb: ah, I see!  I didn't realize you could do that
00:19:54 <ddellacosta> mjrosenb: thanks, that is definitely nicer
00:19:59 <mjrosenb> that is why patterns are so amazing.
00:20:07 <ddellacosta> yeah, seriously
00:20:25 <mjrosenb> also, I'd probably have dequeue return the extracted element second, rather than first.
00:21:05 <ddellacosta> mjrosenb: I guess that's slightly more efficient?
00:21:35 <mjrosenb> it looks more like State :-)
00:21:41 <pjdelport> ddellacosta: [] is probably not that idiomatic for a queue, since you need to traverse the whole thing every time.
00:21:47 <pjdelport> ddellacosta: [] is probably not idiomatic for a queue, since you'll have to traverse the whole thing every time.
00:22:05 <ddellacosta> mjrosenb: ah okay, I'm still not super familiar with State--thanks
00:22:08 <mjrosenb> pjdelport: huh?
00:22:32 <ddellacosta> pjdelport: isn't getting the head O(1)?  Or maybe I'm misunderstanding your point
00:22:45 <dibblego> ddellacosta: last is O(n)
00:23:01 <ddellacosta> pjdelport: the one part I was concerned about was reverse
00:23:07 <mjrosenb> ddellacosta: you only do that when the first part is empty
00:23:15 <mjrosenb> which shouldn't happen frequently.
00:23:20 <mjrosenb> err
00:23:23 <mjrosenb> dibblego: ^
00:23:26 <ddellacosta> mjrosenb: yah, seems like it should be minimized and relatively efficient
00:23:54 <ddellacosta> (otherwise I mean)
00:24:06 <mjrosenb> dibblego: that is the standard way to implement a queue in a functional language, unless you want to use a finger tree, or something crazy like that.
00:24:26 * mjrosenb finally learned how finger trees got their name!
00:24:30 <dibblego> mjrosenb: nuh uh
00:24:30 <mjrosenb> that was an exciting day.
00:24:37 <nocturne777> I am having difficulty installing haskell-mode for emacs
00:24:39 <dibblego> data Queue a = Queue ([a] -> [a])
00:24:54 * ddellacosta goes to poke around and read up on finger trees
00:25:00 <nocturne777> I am just copy-pasting the contents of haskell-mode.el into ~/.emacs
00:25:03 <nocturne777> it does not work
00:25:45 <mjrosenb> dibblego: ok, I am intrugued by this type.
00:26:45 <glguy> Dibblego: that seems like it'd be rather inefficient for a queue
00:27:34 <pjdelport> Darn, sorry about the double post. IRCCloud is being wonky again.
00:27:50 <pjdelport> ddellacosta: The reverse is what has to traverse the list every time, yeah.
00:28:05 <pjdelport> ddellacosta: What you'll rather want is something like Data.Sequence, which has O(1) access from both ends.
00:28:43 <dibblego> I don't understand why it is inefficient, since it has O(1) each end (ala queue), where what is proposed is not even reasonably a queue
00:28:48 <ddellacosta> pjdelport: okay, I'll look into that, thanks--that's helpful
00:29:09 <mjrosenb> pjdelport: that should be amortized O(1),
00:29:31 <pjdelport> Right.
00:29:45 <pjdelport> ddellacosta: Data.Sequence uses finger trees under the hood, for what it's worth.
00:29:54 <ddellacosta> pjdelport: oh cool, didn't know that.
00:30:08 <dibblego> actually, I neglected dequeue, sorry
00:30:13 <nshepperd> I'm not sure that difference lists work as queues
00:30:16 <ddellacosta> yeah, I guess some of this depends on the usage pattern of the queue too--if the q_in is always small doesn't matter so much, I suppose
00:30:20 <dibblego> no, take back
00:30:25 <pjdelport> But you can just use it directly as a queue, without any additional code.
00:30:50 <ddellacosta> where as if it accumulates the point at which the lists "flip" could be quite slow 'cause of that reverse
00:31:09 <mjrosenb> ddellacosta: yeah, but then you don't have to filp for a /very/long time
00:31:28 * hackagebot classy-prelude-conduit 0.10.3 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.10.3 (MichaelSnoyman)
00:31:29 <dibblego> s/(->)/(,)
00:31:30 * hackagebot classy-prelude-yesod 0.10.3 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.10.3 (MichaelSnoyman)
00:31:32 * hackagebot classy-prelude 0.10.3 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.10.3 (MichaelSnoyman)
00:31:34 <ddellacosta> mjrosenb: right, good point, so still amortized O(1) I guess
00:31:41 <ddellacosta> well, thanks everyone for the feedback, very helpful
00:32:21 <mjrosenb> yeah, since you will end up reversing each elemt *exactly* once.
00:33:34 <dibblego> there is also data End a = End Int a; data Queue a = Queue (End a) (End a)
00:34:55 <mjrosenb> dibblego: how is that a queue? it hold two elements.
00:35:03 <mjrosenb> *holds
00:35:17 <dibblego> sorry, I am doing this from scratchy memory — I think it is Okasaki's queue, I will check, sorry
00:35:32 <dibblego> data End a = End Int [a] -- correction
00:36:10 <mjrosenb> ok, that looks like what he currently has, but it also has a length included?
00:36:43 <Hijiri> the length is to move elements when the frong is shorter than the back
00:36:47 <dibblego> yes, includes length
00:37:48 <mjrosenb> that sounds like it'll be less efficient than ignoring the lengths.
00:38:35 <Hijiri> I think it's required to keep amortized O(1) under the system used in okasaki's
00:38:57 <Hijiri> so that the bounds work out correctly
00:39:41 <mjrosenb> so what does this offer? the dual-queue method already has amortized O(1) runtime.
00:39:53 <dibblego> I just found it on hackage
00:40:01 <dibblego> http://hackage.haskell.org/package/dequeue-0.1/docs/src/Data-Dequeue.html#BankersDequeue
00:40:28 <Hijiri> I think it's supposed to improve it under persistence
00:40:50 <mjrosenb> ahh, it offers more than enqueue and dequeue.
00:41:46 <XPilot> I have a question about cabal behavior: cabal claims that a package is not installed, but also claims it is a dependency of an installed package
00:42:11 <Hijiri> oh, I don't think I've read far enough, I was thinking of the queue and not tyhe dequeue
00:42:18 <XPilot> I am trying to to figure out the version of the supposedly not installed package
00:42:33 <ddellacosta> oh you guys are talking about Okasaki's queue, I thought what I had was more or less the same (referring to the one in "Purely Functional Data Structures")
00:43:03 <ddellacosta> but I see now in Google he has an earlier paper called "Simple and Efficient Purely Functional Queues and Deques" which I'll have to check out
00:43:04 <mjrosenb> ok, does anyone know how I'd get the current time in reactive-banana? I feel like since one of the parameters is a time-like value, I should be able to just use that.
00:45:08 <nshepperd> I'm reading the thesis, and it sounds like it's to do with laziness in some manner
00:50:56 <nshepperd> ah, yes it is due to persistence
00:53:17 <nshepperd> if you only reverse the back when the front runs out of elements, depending on how you use the queue you can end up in a situation where you pass the queue to many different 'consumers' just before the back would be reversed
00:54:42 <nshepperd> and then all the consumers have to seperately do the expensive reverse operation before they can even get at the first item, which messes up the bounds
00:55:03 <ddellacosta> nshepperd: oooh, interesting
00:55:35 <ddellacosta> nshepperd: thanks.  What I'm writing is more just for an exercise in learning Haskell, but nice to consider these things
01:01:47 <profil> I am having trouble understanding why I cant use liftIO in a IO in a StateT. I have my monad "MyMonad a = MyMonad CMS.StateT (...) IO a" and when I get the error "Cannot deduce (CMS.MonadIO (MyMonad)) arising from a use of 'liftIO'". Why is this?
01:02:12 <profil> CMS being Control.Monad.State
01:02:43 <ddellacosta> mjrosenb: updated to reflect your suggestions: https://gist.github.com/ddellacosta/bbca6ce6ad0e52eda2a3  Thanks again for the help, much appreciated.
01:04:59 <Zemyla> profil: Does MyMonad instantiate MonadIO?
01:05:32 <profil> Zemyla: no
01:06:15 <mauke> you're not using liftIO in a StateT, you're using liftIO in a MyMonad
01:10:09 <profil> mauke: oh yeah of course.. if I had "MyMonad a = MyMonad CMS.StateT (Something IO) Identity a" then I could have used liftIO in a StateT right?
01:10:41 <mauke> what?
01:10:52 <mauke> also, you're missing a crucial bit there. is this 'type' or 'data'?
01:10:58 <profil> newtype
01:11:24 <mauke> ok, so MyMonad is a separate type, and it's not an instance of MonadIO, so you can't use liftIO
01:11:32 <mauke> doesn't matter how it's defined inside
01:12:02 <profil> alright
01:27:41 <XPilot> profil: one use of newtypes is to throw away old instances and define new ones. For example, the Sum and Product newtypes define the two ways to make a Num into a Monoid
01:38:33 <ddellacosta> what approach do folks take when they want to install something for system-wide usage?  For example, I just installed ghci-pretty so I could get better formatted output in ghci, but it seems to have a ton of dependencies and generally I try to sandbox everything.  But installing it every time I create a sandbox seems like a pain...
02:17:53 <favetelinguis> Trying to make a generic type that can represent any class in a class diagram, i should contain a name, any number of arguments,  any number of functions. The problem i have is how to allow the arguments to have different types. For example an argument could be speed :: Int, and another name :: String which i dont know until execution time
02:19:05 <mniip> favetelinguis, Data.Dynamic?
02:19:34 <favetelinguis> for example data Class = C Name String Int will only allow on type of class
02:23:48 <tiki> Is there a standard function equivalent to "maybe mzero return :: MonadPlus m => Maybe a -> m a"?
02:24:22 <mniip> @hoogle MonadPlus m => Maybe a -> m a
02:24:30 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
02:24:30 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
02:24:30 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
02:24:42 <mniip> yeah that's not it
02:32:59 <tiki> oh, hmm, perhaps "msum . fmap return" (using Data.Foldable's msum). not any more concise though :/
02:33:39 <rasen> :t msum . fmap return
02:33:40 <lambdabot> MonadPlus m => [a] -> m a
02:36:44 <jedai> :t F.msum . fmap return
02:36:45 <lambdabot> (Foldable t, MonadPlus m, Functor t) => t a -> m a
02:36:52 <ab9rf> too much lambdabot
02:39:07 <athan> continuing continuations automatically ~ co-metacircular?
02:39:43 <athan> ~~> Monad? Did I get it yet?
02:42:12 <athan> note the automatically part, though.
02:42:28 <athan> (emphasisze quotes)
02:59:52 <arianvp___> My teacher told me dynamic programming in haskell is useless as in recursive definitions (say fib)  fib(5) never gets calculated twice due to memoization
02:59:56 <arianvp___> is that true?
03:00:06 <arianvp___> so the compiler already does "Dynamic" programming for you
03:01:52 <bennofs> Is there a way to only compile tests as shared executables, while leaving the other executables static?
03:01:59 <bennofs> (with cabal)
03:02:00 <opqdonut> arianvp___: no, that's not true
03:02:25 <opqdonut> arianvp___: the naive definition "fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2)" is exponential in haskell
03:02:34 <arianvp___> that's what I thought
03:03:03 <opqdonut> however memoization is often simpler than dynamic programming
03:03:38 <opqdonut> (or rather, dynamic programming is hand-crafted memoization, which can be better than normal memoisation in terms of space usage)
03:15:58 <ab9rf> is there a straightforward way to, given a module, identify what package it's from?
03:17:46 <ab9rf> ah, nevermind, found it
03:18:22 <bergmark> ab9rf: something like this? http://www.stackage.org/lts/docs
03:18:58 * bennofs uses hayoo for that
03:19:02 <bennofs> @where hayoo
03:19:02 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
03:19:46 <ab9rf> ghc-pkg find-module :)
03:41:59 <Procian> Can I generalise (ContT r IO a) to MonadIO m => (ContT r m a) ?
03:42:54 <adimit> probably.
03:49:59 <tomphreek>  /lastlog
03:50:19 <Kaidelong> Procian: yes, you can do that
03:50:24 <Kaidelong> @type liftIO
03:50:26 <lambdabot> MonadIO m => IO a -> m a
03:50:30 <Kaidelong> and you should do that
03:51:03 <Kaidelong> @instances-importing MonadIO
03:51:04 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
03:51:32 <Kaidelong> so here's an upside
03:51:34 <Procian> I'm not sure that's what I want.
03:52:03 <Kaidelong> if you don't need anything ContT specific
03:52:19 <Kaidelong> you can even just work on MonadIO m => m
03:52:35 <Kaidelong> anyway
03:52:44 <adimit> Procian: you really don't lose anything by using MonadIO.
03:53:17 <Kaidelong> it's probably good advice to always put up with the extra boilerplat liftIO calls and just use MonadIO
03:53:39 <Kaidelong> IO is an instance of MonadIO and liftIO lets you lift any IO action anyway
03:53:53 <Procian> I know, but that's not what I'm trying to do.
03:54:05 <Cale> Unless you're like me and think that transforming the IO monad is usually bad style.
03:54:11 <Procian> I'm trying to take a "ContT r IO a" and replace the IO with a more general m.
03:54:36 <Cale> (Though in the case of ContT, I suppose that's okay)
03:54:40 <adimit> Procian: maybe you should explain what your intentions are, and not how you want to do it. Why do you want the "more general m."
03:55:06 <Cale> Procian: If you're using IO actions in your definition, then you likely can't
03:55:21 <Kaidelong> Cale: what about adding error handling to foreign libraries?
03:55:45 <Cale> Kaidelong: If you're in IO, you have an exception system already.
03:55:47 <Procian> I want to use alloca, which is a callback (Ptr a -> IO r) -> IO r. I'm not in IO, I'm in a more general monad.
03:55:56 <Kaidelong> well you have IO exceptions
03:56:17 <Kaidelong> which you may or may not actually want to use, how expensive are Haskell throws?
03:56:28 <Cale> not expensive
03:56:37 <Cale> and there's the other option, which is to simply produce results which indicate the failures
03:56:39 <Kaidelong> no building a stack trace or anything then?
03:56:48 <Kaidelong> well that's what ErrorT is about
03:56:49 <Cale> There's no stack to trace
03:57:15 <Cale> Well, rather than ErrorT, just  IO (Maybe a) or  IO (Either ErrorInfo a)
03:59:06 <Cale> Monad transformers are a nice way to construct specific monads in which you're interested, but I tend not to like leaving them out in the open without newtypes around them, and lots of library support. If you're using lift/liftIO a lot in application code, then I think there's usually a better option.
04:00:09 <Cale> But that's just my preference about what looks nice, I guess.
04:00:20 <Kaidelong> monad transformer stacks never look nice
04:00:50 <Kaidelong> the point of them seemed to be more that you get generic operations like throwE etc, so that you don't overconstrain your design and later find out things don't compose with another library
04:00:51 <Cale> I would much rather pass around additional arguments than to use a bunch of explicit lifting most of the time.
04:02:10 <Kaidelong> mmm that is probably a better approach, I wonder why it isn't more standard
04:02:21 <Kaidelong> perhaps if module imports could take parameters
04:02:41 <Cale> Well, I don't really see it as nonstandard. It's an older standard that people still use :)
04:03:02 <Cale> I think it's really easy to learn about monad transformers and then overuse the heck out of them
04:03:06 <Kaidelong> the "older standard" seems to have been to just assume some functionality as the default
04:03:25 <Kaidelong> rather than parameterize it
04:03:38 <Cale> Well, it's good old functional programming
04:03:56 <Kaidelong> which is fair enough because the extra parameters are worse boilerplate than even monad transformers are
04:04:10 <Cale> I disagree, they're usually not as bad boilerplate
04:04:12 <Kaidelong> especially in light of top level function typing being expected
04:04:23 <adimit> When people ask (say, on reddit) what's an example of good Haskell code, most recommendations are for reading XMonad â€” which is centered around a big Monad stack. Maybe that's (part of the reason) why Monad stacks are so damned popular.
04:04:32 <Cale> The lifts usually add up to worse than the extra function parameter
04:04:35 <adimit> And in XMonad, the stack is actually well done.
04:04:37 <Kaidelong> well
04:04:46 <Kaidelong> "the extra function parameter" would be alright
04:04:47 <Cale> and the types change in the case of monad transformers as well
04:04:51 <Kaidelong> I was thinking you'd be talking like
04:04:56 <Kaidelong> 6-7 extra function parameters
04:05:07 <Cale> Well, you can always bundle things into data types
04:05:16 <Cale> in whatever way makes the most sense
04:05:39 <Kaidelong> being able to give a parameter to a module would actually be a pretty good solution
04:05:56 <Cale> Which you'd probably be doing anyway, since nobody does ReaderT over ReaderT over ...
04:06:52 <Kaidelong> mmmm, ReaderT would probably be a monad transformer that would make me hesitate
04:07:07 <dibblego> why?
04:07:24 <Kaidelong> ReaderT overspecifies what it reads
04:07:38 <Kaidelong> because Haskell doesn't have the best approach to subtyping short of going full on typeclasses
04:07:42 <Cale> hm?
04:07:47 <dibblego> how does it do this?
04:07:59 <Kaidelong> let's say you have two functions like
04:08:10 <dibblego> let's just state ReaderT
04:08:16 <dibblego> newtype ReaderT a f b = ReaderT (a -> f b)
04:08:23 <takumf> hello
04:08:34 <Kaidelong> ReaderT Int Foo and ReaderT String Foo. It'd be nice if you could compose them, and Haskell can automatically figure out that you're working with something like (Int,String)
04:08:39 <dibblego> type Reader a b = ReaderT a Identity b
04:08:45 <Kaidelong> which you could do with structurally typed records
04:08:57 <dibblego> turns out haskell has the best solution to that problem
04:09:05 <dibblego> c.f. lens
04:09:16 <Cale> :t mapReader fst
04:09:17 <lambdabot> Reader r (b, b1) -> Reader r b
04:09:57 <Cale> oh, no, that's not what I thought it'd be
04:09:58 <Kaidelong> I'm not sure lenses are really a solution, it doesn't overload "ask"
04:10:06 <Cale> withReaderT fst
04:10:07 <Kaidelong> I'm not sure you could achieve that without some kind of structural subtyping
04:10:08 <Cale> > withReaderT fst
04:10:08 <dibblego> I am.
04:10:09 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
04:10:09 <lambdabot>                     Control.Monad.Trans.Reader.ReaderT)
04:10:09 <lambdabot>    arising from a use of â€˜M566191101055030745731534.show_M5661911010550307457...
04:10:10 <Cale> :t withReaderT fst
04:10:11 <lambdabot> ReaderT r m a -> ReaderT (r, b) m a
04:10:17 <Cale> there you go
04:10:20 <Cale> :t withReaderT snd
04:10:21 <lambdabot> ReaderT r m a -> ReaderT (a1, r) m a
04:11:17 <Kaidelong> it'd be nice if you could specify like
04:11:21 <Cale> That's just local with a more general type
04:11:58 <dibblego> Cale: although that is indeed superior to structural subtyping, it is not obvious why it only "just wins" — I prefer the answer, "lens", where second-place is not even visible on the horizon
04:12:11 <bennofs> Kaidelong: with classy lenses, you can keep the reader environment abstract and do something like (HasA r, HasB r) => ReaderT r m a; and then use view a :: HasA r => ReaderT r m A and view b :: HasB r => ReaderT r m B
04:12:34 <Kaidelong> bennofs: that's more what I meant, yes
04:12:41 <Kaidelong> I was not aware lenses could do that
04:12:50 <Cale> dibblego: hm? I'm not sure what you mean by "just wins"?
04:13:06 <Cale> dibblego: I was just suggesting it because it's simple and seems to be what Kaidelong wants?
04:13:08 <Kaidelong> although
04:13:18 <Kaidelong> wouldn't you need a new HasX typeclass for every X?
04:13:20 <dibblego> Cale: it's not important
04:13:23 <Kaidelong> I guess
04:13:44 <Cale> You can use withReaderT in conjunction with lenses as well
04:13:45 <bennofs> Kaidelong: yes, lens has TH to autogenerate those classes
04:14:13 <Kaidelong> GHC cross compiler getting template Haskell support is like the last thing stopping me from using lens
04:14:22 <dibblego> fwiw, there exist type systems that do have structural subtyping and even make it easier to use structural subtyping and not even then is it used to solve this problem, because better libraries (such as lens) are superior
04:14:59 <Kaidelong> well
04:15:07 <Kaidelong> with TypeLits
04:15:14 <Kaidelong> I guess Haskell has structural subtyping now anyway
04:15:18 <Kaidelong> you just use type level strings
04:15:22 <Cale> I do rather like Ermine's approach to row polymorphism though.
04:15:39 <Kaidelong> and type level lists
04:16:03 <mpickering> what are the best papers to get a background on different generic programming techniques?
04:16:11 <mpickering> Is SYB still relevant?
04:16:42 <Cale> I think SYB is still fairly relevant? People seem to be enjoying the new GHC generics though.
04:17:41 <mpickering> does uniplate sit in the same design space as SYB?
04:18:32 <Cale> Yeah, and it has an SYB compatibility module even :)
04:18:59 <Cale> https://hackage.haskell.org/package/uniplate-1.6.12/docs/src/Data-Generics-SYB.html
04:22:03 <Hafydd> I'm sitting a course that involves some cryptography, and I have to suppress laughter each time the lecturer says "nonce".
04:22:20 <Hafydd> Er... wrong channel.
04:25:27 <petercommand> tring to install idris via cabal, http://pastebin.com/QjkBx555
04:25:55 <petercommand> the cabal message didn't mention why unix-compat failed to install...
04:26:13 <hughfdjackson> :) morning all
04:26:34 <petercommand> it seems to be installed successfully
04:28:12 <petercommand> hughfdjackson: hi, mate :)
04:28:22 <mpickering> Is it possible to write a "generic fmap function" using generics libraries?
04:29:14 <hughfdjackson> petercommand: ^^ heyup
04:29:25 <hughfdjackson> I'm going to attempt some very, very crude OCR
04:29:25 <mpickering> petercommand: What about line 24/25?
04:29:45 <hughfdjackson> my source images are scans of old typewritten documents (a draft of my grandma's book)
04:29:55 <jedai> mpickering: I guess you could write an instance of Functor for Generic instances ?
04:29:58 <petercommand> oh...i see..
04:30:18 <hughfdjackson> are there any defacto image loading + manipulation libraries? there seems quite a few choices - not sure what's trusted
04:30:24 <hughfdjackson> (the ol' hackage problem ;D)
04:30:31 <jedai> mpickering: but you can derive it anyway so....
04:31:52 <petercommand> mpickering: thx :)
04:32:28 <petercommand> don't know why it happened..
04:32:59 <mpickering> nope neither
04:33:04 <mpickering> try installing again?
04:34:21 <petercommand> the same error again
04:35:11 <bennofs> petercommand: are your locale settings correct? (environment variables LANG etc)
04:36:36 <petercommand> bennofs: yes, it's the locale problem... fixed it after changing LANG and LC_ALL to en_US.UTF8
04:36:50 <petercommand> thx ^^
04:40:09 <darthdeus_> how can I add additional libraries to the linker list?
04:40:22 <darthdeus_> when doing cabal install that is
04:42:11 <calavoow> @help
04:42:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:46:16 <calavoow> @pl \x y -> (cos x) + (sin y)
04:46:16 <lambdabot> (. sin) . (+) . cos
04:48:57 <Hafydd> <Hafydd> @pl \x -> (cos x)^2 + (sin x)^2
04:48:57 <Hafydd> <lambdabot> const 1
04:51:09 <sx> I used free monads to implement an interpreter. Now I've tried writing a compiler with it, which seems impossible when I have to compile constructors like in: data Event next = ReadE (Word8 -> next). Is there any way arround this or is it simply impossible?
04:53:04 <hughfdjackson> is there a known issue with ghc < 7.10 not playing nice with cabal 1.22 ?
04:53:31 <hughfdjackson> https://github.com/carymrobbins/intellij-haskforce/issues/118 <- seems to be the suggestion here
04:55:59 <bennofs> hughfdjackson: maybe something related to the recent backpack changes (something about package hashes/ids, idk much about that)
04:56:14 <hughfdjackson> hrm, okay :)
04:56:32 <hughfdjackson> will have a look around !
04:56:35 <bennofs> hughfdjackson: ah no, that looks more like it's caused by the switch to a binary setup-config with Cabal 1.22
04:56:59 <bennofs> hughfdjackson: dist/setup-config used to be a plain text file, but with Cabal 1.22 it is now binary
04:57:10 <hughfdjackson> oh - *that* sounds a likely culprit
04:58:31 <bennofs> hughfdjackson: the reason it only works with GHC 7.10 is that 7.10 is the first version of GHC which don't depend on the Cabal library
04:58:53 <hughfdjackson> hrm - well
04:59:23 <hughfdjackson> i'm seeing if just installing the latest ghc-mod will let me still run GHC 7.8 for the regular dev part, but still have my haskforce IDE plugin work
04:59:42 <bennofs> hughfdjackson: prior to GHC 7.10, the ghc package (which provides the GHC API) depended on Cabal (always <= version 1.18). So if ghc-mod, which needs to depend on both Cabal and ghc, wants to depend on Cabal 1.22 (to read the binary format), it needs GHC 7.10
05:00:28 <hughfdjackson> :/ that doesn't sound encouraging - i'd prefer to run GHC 7.8 (current stable version, as i understand it)
05:00:34 <hughfdjackson> perhaps this will call for a cabal downgrade
05:00:49 <bennofs> hughfdjackson: yeah, it should work if you stick to cabal 1.20
05:01:48 * hackagebot liquidhaskell 0.3.0.0 - Liquid Types for Haskell  http://hackage.haskell.org/package/liquidhaskell-0.3.0.0 (EricSeidel)
05:06:48 * hackagebot system-filepath 0.4.13.2 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.13.2 (MichaelSnoyman)
05:09:48 <hughfdjackson> bennofs: that was really helpful - thankyou!
05:09:58 <hughfdjackson> :-) now not only do my tools work, but I understand why
05:11:29 <a3gis> hello! is there a way to loosen the restrictions on infix function/constructors names in GHC, e.g. to allow "&" as a valid infix op?
05:12:12 <a3gis> they use such syntax in a paper, so either it is purely for readability's sake or there is an actual way to run it
05:12:45 <ab9rf> (&) is an operator already
05:12:49 <ClaudiusMaximus> > 4 & id
05:12:51 <lambdabot>  ()
05:13:14 <ab9rf> :t (&)
05:13:15 <lambdabot> a -> (a -> b) -> b
05:13:23 <a3gis> :i (&)
05:13:30 <a3gis> in which module?
05:13:32 <ClaudiusMaximus> did someone Num () ?
05:13:51 <ClaudiusMaximus> > () + () * ()
05:13:53 <lambdabot>  ()
05:13:55 <a3gis> so if I don't import it I should be able to declare a constructor with &, no?
05:14:35 <ClaudiusMaximus> a3gis: constructors have to start with a capital, ':' is the capital symbol
05:14:48 <ab9rf> ClaudiusMaximus: i think someone added a Num instance for () to lambdabot last night'
05:15:02 <a3gis> oh ok, so the code in the paper was problably just meant to be readable, not executed (http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf)
05:15:45 <bennofs> What do double #-signs do when using CPP? (This file contains cpp like this: ##if defined(...) or ##define USE_CP)
05:15:52 <ab9rf> ClaudiusMaximus: which is vaguely silly, but it's true that the trivial group does satisfy the Num predicates
05:16:06 <ClaudiusMaximus> ab9rf: it's really unhelpful with defaulting, though
05:16:16 <tomphreek> is it possible to make this lazy:     print (head dah)
05:16:16 <ab9rf> ClaudiusMaximus: no argument here
05:16:22 <tomphreek> is it possible to make this lazy:         dah <- mapM sample (repeat stdUniform :: [RVar Double])
05:16:30 <ab9rf> tomphreek: homework?
05:16:40 <a3gis> another question: would anyone have an answer to this: https://twitter.com/hdgarrood/status/563676242160148480?
05:16:46 <bennofs> @undef
05:16:47 <lambdabot> Undefined.
05:17:01 <Phillemann> I have written a program in haskell which creates (via forkIO) a separate thread which reads on a socket while the main application loop does something else. I would like for the main loop to exit when the read thread throws an exception. I'm not sure what currently happens, though. The main loops seems to continue.
05:17:05 <tomphreek> ab9rf: no, I am not a CS student. Doing phd in maths actually.
05:17:32 <ab9rf> tomphreek: what's stdUniform?
05:18:27 <Phillemann> Do I have to catch the exception in the read thread and use throwTo to the main thread?
05:19:18 <ab9rf> i hate threads
05:19:26 <tomphreek> ab9rf: stdUniform :: Distribution StdUniform a => RVar a
05:19:59 <ab9rf> and what's RVar?
05:20:02 <a3gis> Phillemann: what about forkFinally?
05:20:09 <a3gis> :t forkFinally
05:20:10 <lambdabot> Not in scope: â€˜forkFinallyâ€™
05:20:13 <ClaudiusMaximus> a3gis: i've used mulitplicative matrix groups to do things like this: http://mathr.co.uk/blog/2009-10-15_reflex_preview.html
05:20:14 <a3gis> http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Concurrent.html
05:20:18 <bennofs> a3gis: I like to use Monoids for options (for example, optparse-applicative uses them for flag definitions)
05:20:36 <bennofs> oh, it said group, not structure
05:20:51 <McManiaC> hey guys, i keep getting "does not exist" errors when installing libs with cabal on windows (i think during the configuration) http://puu.sh/fDAq9/aab7da7fea.png
05:20:54 <a3gis> ClaudiusMaximus: oh cool; thanks!
05:20:54 <McManiaC> any idea why?
05:21:04 <tomphreek> type RVar = RVarT Identity, RVarT = A random variable with access to operations in an underlying monad
05:21:17 <ab9rf> tomphreek: is your goal to generate a stream of uniform random variables?
05:21:22 <McManiaC> i just tried reinstalling haskell platform, but it doesnt seem to help
05:21:36 <ab9rf> tomphreek: that likely will involve some sort of lifting.
05:21:39 <tomphreek> ab9rf, I need samples
05:22:50 <tomphreek> so I have code which works on infinite list of [Double], now trying to use this code to work on infinite list of [IO Double] after I manage to make an infinite list of [IO Double]...
05:23:07 <ClaudiusMaximus> a3gis: code link on the blog post is obsolete, i need to update it to https://gitorious.org/polytopiary/reflex
05:23:47 <ab9rf> so you need to go from [IO double] to IO [Double]?
05:24:09 <McManiaC> :t sequence
05:24:10 <lambdabot> Monad m => [m a] -> m [a]
05:24:23 <tomphreek> ab9rf: no
05:24:24 <ab9rf> that is, indeed, just sequence
05:24:46 <tomphreek> [RVar Double] to [IO Double]
05:24:50 <ab9rf> if you have code that works on [a], and you have [IO a], you first go to IO [a], then fmap
05:25:05 <ab9rf> RVar looks to be a monad
05:25:14 <a3gis> Phillemann: is that what you were looking for?
05:25:35 <ClaudiusMaximus> tomphreek: sequence for IO needs to perform all the actions before it can return the output, performing an infinite number of actions will take some time - maybe a different Monad will be less problematic
05:26:01 <bennofs> McManiaC: can you try installing like network-uri directly, like cabal install network-uri-2.6.0.1 ?
05:26:13 <Phillemann> a3gis: It sounds adequate, I'll try that. Thanks :)
05:26:25 <ab9rf> ClaudiusMaximus: sequence doesn't generate the list lazily?
05:26:34 <McManiaC> bennofs: i even tried unpacking and calling cabal configure manually, and i got the same error
05:27:03 <ClaudiusMaximus> tomphreek: lazy IO (like getContents) uses unsafeInterleaveIO or similar, but then IO execution gets intermingled unpredictably with evaluation, causing confusing problems
05:27:12 <bennofs> McManiaC: hmm, even with cabal install -j1? That should not create a log file at all iirc
05:33:02 <McManiaC> bennofs: http://puu.sh/fDDgb/0f315c0ca6.png
05:33:14 <McManiaC> idk what is even going on there
05:33:32 <bennofs> McManiaC: ah, I meant installing network-uri (not cabal install)
05:33:36 <bennofs> McManiaC: also add -v2
05:33:50 <McManiaC> i'm trying to update cabal for now
05:34:15 <tomphreek> ClaudiusMaximus: ok I have an infinite list [Rvar Double] and now I want to sample each RVar to make a list of [m Double], for some monad m so that the sampling is lazily evaluated. mapM sample blocks within IO monad because it tries to sample all of them. So I should switch to different monad, is that right?
05:34:24 <McManiaC> -v2 does not give any additional info i think http://puu.sh/fDDp9/b6a1613572.png
05:34:26 <McManiaC> bennofs: ^
05:35:24 <bennofs> McManiaC: and -v3?
05:38:18 <ClaudiusMaximus> tomphreek: yeah - but i don't know which monads would support that (eg: possibly State StdGen or similar might appear to work, as long as you don't try to read the final state...)
05:39:31 <a3gis> McManiaC: lol.
05:39:43 <McManiaC> a3gis: ?
05:40:10 <a3gis> better to laugh at cabal then cry
05:40:23 <ClaudiusMaximus> tomphreek: so something like   sequence' xs = do{ g <- get ; let (g1, g2) = split g ; put g1 ; rs <- sequence xs ; put g2 ; return rs }  -- might work, untested
05:40:26 <a3gis> than*
05:41:53 <McManiaC> bennofs: i'm trying to directly run the Setup.hs for now
05:42:01 <McManiaC> not sure if this will work
05:42:37 <bennofs> I vaguely remember having the same error once, but not how I solved it :|
06:08:59 <McManiaC> bennofs: with -j1 it seems to work
06:09:37 <dreams> Anyone knows what a star (*) means in the type heap profile?
06:15:03 <bennofs> McManiaC: does the directory C:\Users\Nils\AppData\Roaming\cabal\logs exist?
06:15:22 <bennofs> McManiaC: maybe you need to create it
06:21:34 <a3gis> is there a way for a ViewPattern to fail matching some input? (except using a non-exhaustive pattern or throw an error in the function)
06:21:53 <McManiaC> bennofs: yes that exists
06:21:54 * hackagebot lucid 2.9.0 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.9.0 (ChrisDone)
06:23:08 <a3gis> basically I would like to do something like this: https://gist.github.com/a3gis/672ce8eedba62e8a89bf
06:23:16 <wz1000> Why are recursive types forbidden?
06:23:33 <wz1000> s/types/type aliases/g
06:25:25 <ClaudiusMaximus> a3gis: works for me like this:
06:25:25 <ClaudiusMaximus> f :: Int -> String
06:25:25 <ClaudiusMaximus> f (even -> True) = "x is Even"
06:25:25 <ClaudiusMaximus> f (odd -> True) = "x is Odd"
06:26:12 <a3gis> oh right that makes sense, of course the pattern were overlapping
06:26:33 <a3gis> my question still stands though; is there no way for the function used in the pattern (e.g. even) to decide whether it should match or not?
06:26:55 <a3gis> I would basically like to have     g :: Int -> Maybe Int
06:26:58 <a3gis> f (g -> x)
06:27:08 <a3gis> should match if g returns Just _
06:27:15 <a3gis> and fail is g returns Nothing
06:27:27 <a3gis> I know I could do that by writing f (g -> Just x)
06:27:35 <a3gis> but I think in F# activepatterns work differently
06:33:32 <tomphreek> @src mapM
06:33:32 <lambdabot> mapM f as = sequence (map f as)
06:35:01 <Kaidelong> a3gis: I think ViewPatterns can do most of hte things active patterns can
06:40:50 <Hi-Angel> I noticed a data record like Â«â€¦ = XConfig{â€¦, keys :: 'XConfig Layout -> containers-0.5.0.0:Data.Map.Base.Map (ButtonMask, KeySym) (X ()), â€¦}Â» Does anybody know, what's going on after the Â«::Â» symbol?
06:41:49 <bennofs> Hi-Angel: is this from an error message?
06:42:32 <Hi-Angel> bennofs, no, that is declaration of the Â«keysÂ» in the Â«XMonadÂ» package. That is, the on I got with Â«:i keysÂ» in GHCI.
06:42:53 <Hi-Angel> s/the on/the one
06:43:14 <bennofs> Hi-Angel: the containers-0.5.0.0 prefix just means that it's the Map datatype from the containers-0.5.0.0 package
06:44:17 <Hi-Angel> Okayâ€¦ But what is the Â«â€¦ Layout -> â€¦Â»?
06:44:32 <Hi-Angel> Ah
06:44:34 <Hi-Angel> Wait
06:45:03 <Hi-Angel> Is that means that the keys have a constructor Â«'XConfigÂ» with these arguments?
06:45:36 <Hi-Angel> With argument Â«LayoutÂ», and returning the Â«MapÂ»
06:45:48 <bennofs> Hi-Angel: it means that XConfig has a field keys which is a function from 'XConfig Layout to a Map from key specifications to X () actions
06:46:26 <bennofs> I'm unsure what the ' in 'XConfig means
06:49:36 <Hi-Angel> Okay, thank you bennofs, I think I got  it
06:51:56 * hackagebot handsy 0.0.9 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.9 (utdemir)
07:06:50 <adam_hardkey_shi> Does someone has a comprehensive explanation of how session works in netwire 5?
07:10:21 <wz1000> adam_hardkey_shi: I do believe this is the wrong channel for that question.
07:11:01 <adam_hardkey_shi> wz1000: yeah, I know, but I am a little desperate ^^
07:12:49 <wz1000> adam_hardkey_shi: Oh, sorry I didn't know of the haskell library by that name.
07:13:04 <adam_hardkey_shi> No problem. ^^
07:13:23 <darthdeus_> anyone knows how should windows paths with spaces be specified in the cabal file?
07:31:01 <darthdeus_> please :(
07:31:06 <darthdeus_> it's not in the manual
07:31:17 <darthdeus_> not even windows paths, just any paths
07:31:20 <darthdeus_> it only says "directory-list"
07:31:32 <darthdeus_> and by manual i mean this (https://www.haskell.org/cabal/users-guide/developing-packages.html)
07:38:23 <bennofs> darthdeus_: have you tried surrounding them with quotes (idk if that works)
07:40:18 <darthdeus_> bennofs: that splits them on spaces :\
07:44:30 <geekosaur> the other thing that comes to mind is backslash. but I don't know if cabal-install actually handles that in any sane way
07:45:35 <geekosaur> (or maybe the Haskell string escapes, \32 or \SPC possibly followed by \&)
07:46:49 <darthdeus_> geekosaur: well the path already contains backslashes, and it seems to work on the command line if I do --extra-include-dirs="C:\Program Files\...", but if I add include-dirs: C:\Program Files\... or even with " ", it just splits it on spaces
07:59:42 <darthdeus_> I've created a cabal issue for this https://github.com/haskell/cabal/issues/2407, seems that it's either a bug, or missing docs :\
07:59:47 <darthdeus_> or i'm just incredibly dumb :P
08:03:15 <geekosaur> most likely they didn't think about it originally (the whole ghc ecosystem originated on unix, notwithstanding being maintained for a long time under the aegis of MSR) anf they don't know how to fix it now without breaking existing cabal files
08:03:42 <bennofs> Seems cabal uses reads to read filepath
08:03:56 <bennofs> (after splitting on spaces)
08:03:57 <darthdeus_> geekosaur: but i cant be the only person who has ever tried this?
08:04:11 <darthdeus_> every time i asked people told me haskell on windows works fine :P
08:04:34 <geekosaur> I think most pople assume anything originating on unix will be dumb about spaces in paths...
08:05:56 <hexagoxel> as if unix did not support spaces in directories..
08:06:38 <arw_> for added fun: newlines in directories :)
08:06:51 <darthdeus_> geekosaur: i understand that there aren't that many people who don't work on unix, but there are already existing tons of windows packages on hackage
08:07:15 <geekosaur> not to mention cute stuff like you get cabal to support it and then try to build a package using a Makefile and found out the Makefile mishandles spaces in paths (all too common)
08:07:59 <geekosaur> ...and the Makefile is actually from an embedded upstream library, ostensibly included "to make it easier to install on Windows"
08:08:14 <geekosaur> it's all kinda terrible :(
08:11:14 <tasker> has anyone got a workflow setup to compile binaries on docker, and then use them on another system?
08:12:26 <mseeks> has anyone used TCache and DBRef?
08:12:48 <mseeks> when I tried `newDBRef` it hung and ate up all my disk space
08:16:33 <tomphreek> why foldable restriction on traversable?
08:18:58 <tomphreek> class (Functor t, Foldable t) => Traversable t where
08:18:59 <enthropy> tomphreek: you can write foldMap using traversable's methods
08:20:06 <enthropy> see foldMapDefault
08:22:02 * hackagebot Rasterific 0.5.0.1 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.5.0.1 (VincentBerthoux)
08:22:04 * hackagebot sdnv 0.1.0.0 - Self-delimiting numeric values encoding library  http://hackage.haskell.org/package/sdnv-0.1.0.0 (sickmind)
08:22:15 <tomphreek> enthropy: didn't realise one can promise to be Foldable when creating instance of Traversable and use traverse to make Foldable. but it did feel like I am doing extra work. Thank you!
08:27:28 <carter> tomphreek: yeah, i love using a child class to write a parent sometimes
08:27:34 <carter> its mindle boggling the first 1-2 times
08:27:37 <carter> but its kinda nice
08:28:39 <favetelinguis> are sandboxes supported by haskell emacs haskell mode? It says it cant find the package when trying to import
08:31:58 <cryzed> I'm probably being obtuse, but is there something like the (:) operator that allows me to simply append an element to the end of a list, instead of using list ++ [element]?
08:33:12 <mauke> no
08:33:15 <cryzed> Ok
08:33:45 <mauke> and you shouldn't do that a lot anyway because it's slow
08:33:58 <cryzed> mauke, which of the two?
08:34:12 <carter> cryzed: its \Theta(n) slow
08:34:15 <csd_> Does there exist a predefined function f where for example `f 2 "some-list" = ["so", "om", "me", "e ", " l", "l i", "i s", "s t"], etc.
08:34:15 <geekosaur> a list is not an array
08:34:16 <mauke> two what?
08:34:27 <carter> cons and snoc
08:34:36 <carter> (snoc == cons to the back)
08:34:36 <cryzed> mauke, ah you meant joining lists that way. Yes, I figured that it is slow, but for what I'm doing completely irrelevant
08:34:38 <geekosaur> when you have a list, you have a thing containing the head of a list and a pointer to the rest of it
08:34:43 <cryzed> Meaning the speed of the execution
08:34:46 <carter> snoc ls x  = ls ++ [x]
08:34:52 <carter> is linear time
08:34:53 <carter> always
08:34:55 <geekosaur> so adding to the end of it will traverse the whole list
08:35:17 <mauke> > (map (take 2) . tails) "some-list"
08:35:18 <lambdabot>  ["so","om","me","e-","-l","li","is","st","t",""]
08:35:19 <geekosaur> (nonempty list of course)
08:35:58 <csd_> ke: i just want something that lets me give a list, and produces all adjacent items of size n
08:36:06 <csd_> mauke
08:36:38 <csd_> (map (take 3) . tails) "some-list"
08:37:01 <wz1000> cryzed: If you are doing a lot of that as well as (:) then maybe you should consider using a different data structure
08:37:47 <cryzed> wz1000, yes I figured. I don't do a lot of it, I'm doing Haskell purely for academical reasons (read: University), nontheless I'll keep that in mind if speed becomes important
08:38:37 <carter> Data.Sequence for exmaple
08:38:52 <csd_> -- that should work though, thanks
08:40:16 <wz1000> Is it a good idea to use typeclasses to make something polymorphic over different implementations?
08:40:56 <geekosaur> sometimes
08:42:55 <danilo2> Hello! :) I've got a small problem in Haskell. I'm getting ocmpilation error "Couldn't match kind â€˜*â€™ with â€˜* -> *â€™ In the expression: call2' (Proxy :: Proxy 4) m'" and the question is - how can I investigate where the error comes from? I've got all explicitly typed and there are some overlapping instances involved - is there any tool to trace the origin of the error ?
08:44:21 <mauke> danilo2: what's the complete error message?
08:44:30 <danilo2> mauke: that is the complete error message
08:44:36 <mauke> unlikely
08:44:44 <danilo2> mauke: oh in ghci
08:44:50 <danilo2> mauke in ghc its a little longer, brb
08:45:15 <danilo2> mauke: http://lpaste.net/120155
08:45:56 <mauke> that's still not complete
08:46:41 <mauke> but the message confuses me a bit
08:46:54 <mauke> it's a kind error, so logically it should be complaining about a type signature
08:47:00 <danilo2> mauke: hmm it is - after that I see only "[Finished in 1s with exit code 1]" - from my running script
08:47:04 * hackagebot rasterific-svg 0.1.0.1 - SVG renderer based on Rasterific.  http://hackage.haskell.org/package/rasterific-svg-0.1.0.1 (VincentBerthoux)
08:47:15 <mauke> (Proxy :: Proxy 2) (member (Proxy :: Proxy "asTuple") _v)
08:47:39 <mauke> there are two type annotations there, and neither looks wrong at first glance
08:47:45 <danilo2> mauke: call2 (Proxy :: Proxy 2) (member (Proxy :: Proxy "asTuple") _v)
08:47:46 <mauke> danilo2: it doesn't contain a filename or line number
08:48:08 <danilo2> mauke: yep, the filename and line number I just deleted - its not important is it ?
08:49:02 <mauke> probably not
08:49:14 <danilo2> mauke: interesting thing is, that in some cases it works, in some cases it throws this error and I'm alittle confused right now
08:50:03 <danilo2> mauke: I mean - this is generated code and I've got some examples that just work (very simmilar to these) and some not - both using the same constructs
08:50:19 <mauke> this is bizarre
08:52:17 <hsk3> Why is the monomorphic restriction applied within   foo = 5 == 5    to make it compile? (Without it it wouldn't compile because 5's type is Num a => a and Num does not inherit from Eq.)
08:52:32 <hsk3> I don't see from the rules how the monomorphic restriction would apply here
08:52:33 <hsk3> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-930004.5.5
08:53:44 <enthropy> even if you had "class Eq a => Num a", it still needs to pick an instance of Num
08:54:02 <danilo2> mauke: Ok, I've got an idea! I've got type class that takes as an argument something like this "Handler (obj :: k) (name :: Symbol)" - and when I pass it through 2 such type class methods, GHC assumes in one moment, that the k is just * - I'm checking this further
08:54:03 <Welkin> the first 5 could be Int and the second Integer
08:54:05 <zq> in the expression, "a > b", how could i strictify (>) on both arguments?
08:54:24 <enthropy> there's defaulting to make both Integer
08:54:30 <hpc> hsk3: suppose some jerk wrote data Foo = Foo; instance Eq Foo where (==) _ _ = False; instance Num Foo where fromInteger _ = Foo
08:54:42 <Welkin> yes, enthropy
08:54:45 <hpc> your obviously true definition of foo is suddenly false
08:56:45 <hsk3> enthropy: okay, but my question is
08:56:58 <hsk3> According to which passage in the Haskell Report does this happen?
08:57:01 <hsk3> I don't see it
08:57:15 <hsk3> under monomorphic restriction
08:57:29 <shapr> good morning!
08:58:58 <enthropy> hsk3: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4
09:01:43 <hsk3> enthropy: Aha!! So in order to call a function (in this case ==) on 5, 5 must be turned into an actual value. In this case this is ambiguous! Right?!
09:01:57 <hsk3> "actual value": value of a particular type
09:02:05 * hackagebot subnet 0.0.1 -   http://hackage.haskell.org/package/subnet-0.0.1 (gcganley)
09:04:56 <geekosaur> haskell always needs to be able to assign a specific type to a value
09:05:23 <hsk3> geekosaur: yeah that's what i'm saying
09:05:32 <enthropy> @type \x -> x + 5
09:05:33 <lambdabot> Num a => a -> a
09:05:47 <hsk3> enthropy: So it has nothing to do with monomorphic restriction. It's just plain old resolving of ambiguousness
09:05:54 <hsk3> in this case
09:06:25 <enthropy> well the monomorphism restriction applies to that binding but Bool is monomorphic
09:06:42 <enthropy> and would be even if MR didn't exist
09:06:59 <hsk3> yeah
09:07:41 <danilo2> enthropy: ugh I cannot find the error (with these kinds). It made my mind blown - everything is just as it should. I even make ghci checks and everything is well-typed, but still I get the error and it deos not tell anything sensible :<
09:08:13 <enthropy> danilo2: I'd add type/kind annotations until it works
09:09:09 <danilo2> enthropy: I added it on the top level of used functions - they compile, but this example still complains about umatched kinds ... (while every used function is explicitly typed including kinds)
09:10:43 <enthropy> danilo2: I mean inside the expression _a <- call2 ...
09:10:46 <danilo2> enthropy: Of course you cannot help me right now without having the code. Anyway, thank you for al lthe info :)
09:10:57 <danilo2> enthropy: hmm, ok, I will try
09:11:51 <Buttons840> I've been having some trouble installing the gloss package, because the underlying OpenGL and GLUT packages wont compile. I fixed (on my system) by changing the gloss.config file(s) to use the latest OpenGL and GLUT packages, and was able to install gloss. Is there a way to run unit tests to ensure the install is working well?
09:12:37 <Buttons840> if so, I will report to the gloss maintainer that he should consider updating to the latest OpenGL and GLUT packages, since apparently the newer versions are backwards compatible
09:17:14 <worldsayshi> Cabal sandbox - is there an api for that? I canâ€™t find any references to sandbox in the cabal api.
09:17:33 <c_wraith> worldsayshi: sandboxes are part of cabal-install, not Cabal
09:17:47 <worldsayshi> ah, of course
09:20:24 <jmcarthur> shapr: hi!
09:21:04 <shapr> jmcarthur: howdy! How's code treating you? Any Haskell?
09:21:19 <shapr> jmcarthur: I went to a fun talk on doing pure FP in Python yesterday at PyTN
09:21:46 <Welkin> shapr: pure FP in python?
09:21:51 <Welkin> surely you're joking
09:22:16 <shapr> Welkin: seriously! https://www.pytennessee.org/schedule/presentation/79/
09:22:38 <shapr> radix wrote a sort of monad Python library called effect
09:23:04 <jmcarthur> shapr: i've not been coding much lately outside of work. little experiments here and there, little more.
09:24:55 <shapr> aw, okay
09:25:20 <worldsayshi> There doesnâ€™t seem to be any api documentation for the cabal-install package? Going to http://hackage.haskell.org/package/cabal-install-1.22.0.0/docs gives me â€œThere is no documentation for cabal-install-1.22.0.0â€ â€¦ ?
09:26:43 <worldsayshi> sorry, gtg.. :/
09:26:44 <enthropy> @hackage Cabal
09:26:44 <lambdabot> http://hackage.haskell.org/package/Cabal
09:26:57 <worldsayshi> Yeah, Iâ€™m aware of cabal
09:27:07 <jmcarthur> worldsayshi: cabal-install is not a library
09:27:12 <enthropy> that's the library, cabal-install is the binary called cabal (so it has no api)
09:27:14 <shapr> jmcarthur: I've been investigating atom, started figuring out how to generate Arduino code from Haskell
09:27:24 <jmcarthur> shapr: nice!
09:27:36 <shapr> when my novena desktop arrives, I'll attempt to build the Reduceron for the on-board FPGA
09:27:50 <jmcarthur> shapr: i've been (slowly) learning how to derive abstract machines from interpreters. i keep getting hung up on making more interesting interpreters instead, though
09:27:54 <shapr> jmcarthur: I'm trying to bootstrap a #haskell-embedded community
09:28:04 <shapr> jmcarthur: ooh, that sounds interesting... any blog posts?
09:28:12 <jmcarthur> not a one
09:28:35 <shapr> jmcarthur: write one?
09:28:48 <jmcarthur> i haven't done anything interesting enough yet
09:29:10 <shapr> I would disagree ;-P
09:29:15 <jmcarthur> also, deriving abstract machines is nothing new. maybe some particular machine i create will be interesting someday though
09:29:23 <shapr> are there existing papers on that topic?
09:29:27 <jmcarthur> yeah, h/o
09:30:27 <jmcarthur> shapr: here's a pretty easy one to follow:  http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.4314
09:30:54 <shapr> hm
09:30:56 <Scriptonaut> can anyone tell me why this doesn't work: https://gist.github.com/robins35/803d7c0fffc34b6a5b49
09:31:12 <jmcarthur> shapr: here's one where the authors derive a variation on the STG machine http://dalila.sip.ucm.es/~ricardo/ppdp03.pdf
09:31:19 <Scriptonaut> also man I hate ghc errors
09:31:41 <geekosaur> Scriptonaut, precedence
09:31:55 <jmcarthur> Scriptonaut:   putStrLn "Hello " ++ line ++ ", you are so cool!"   is a type error. it parses like this:    (putStrLn "Hello ") ++ line ++ ", you are so cool!"
09:32:07 * hackagebot yesod-purescript 0.0.4.4 - PureScript integration for Yesod  http://hackage.haskell.org/package/yesod-purescript-0.0.4.4 (mp)
09:32:25 <Scriptonaut> then why is ghc telling me there are problems with my line 6
09:32:28 <Welkin> Scriptonaut: you will love ghc errors and warnings very soon
09:32:31 <geekosaur> yes, that, which I was about to type. you need parentheses around the String expression (or $ which is often more convenient: putStrLn $ ...)
09:32:45 <Scriptonaut> so far ghc errors seem to never tell me what's wrong
09:32:51 <Scriptonaut> like other interpreters/compilers I've used
09:32:55 <Welkin> they do, it just takes some time to understand
09:33:06 <Welkin> it is far better than other compilers
09:33:07 <jmcarthur> shapr: sorry, i should stop describing things as "easy" to people who have never seen the material before. it is just going to make it seem less easy
09:33:26 <jmcarthur> shapr: or, rather, more frustrating
09:33:29 <geekosaur> Scriptonaut, the problem is that things that would unambiguously be error in other languages are not necessarily in Haskell
09:33:34 <Welkin> Scriptonaut: be sure to include type delcaratins in your code as well
09:33:45 <Welkin> especially for top-level functions
09:34:00 <Welkin> it helps you to understand what you are writing
09:34:12 <Welkin> declarations*
09:34:16 <Scriptonaut> Welkin, I didn't have any functions though did I?
09:34:22 <geekosaur> there is a simplified Haksell out there (Helium) which can behave more like you want, but it can't do a lot of things that Haskell can
09:34:35 <Scriptonaut> I normally do do type decs
09:34:42 <shapr> jmcarthur: this is why I think you may have learned or done something interesting and blog worthy already
09:36:06 <jmcarthur> shapr: but i don't think i understand it well enough to present it more clearly than the paper
09:37:15 <Welkin> jmcarthur: writing is a great way to organize your thoughts
09:37:29 <Welkin> it will help you undertsand it better by writing about it
09:37:39 <shapr> that's a good point
09:39:05 <jmcarthur> Welkin: my current method of understanding it better is by implementing it
09:40:52 <shapr> jmcarthur: What about walking readers through the implementation, and how you got to what you have?
09:41:02 <shapr> man, sounds like I'm recruiting for The Monad.Reader again :-)
09:41:45 <shapr> Ah, wouter is still running TMR
09:43:20 <shapr> oh wait, ezyang is running TMR now
09:46:13 <worldsayshi> jmcarthur: Sorry for dropping out. Iâ€™m looking for ways to â€œknow what cabal sandbox knowsâ€.
09:47:54 <worldsayshi> And since sandbox lives in cabal-install..?
09:55:34 <Luke> guys what's the haskell foundation or governing body or whatever it's called that runs the website etc?
10:04:53 <jmcarthur> huh, yminsky was in here
10:05:01 <ab9rf> that question has multiple answers
10:05:20 <ab9rf> i'm fairly certain that the group that decides on language proposals is not the same as the person who runs the website
10:05:47 <monochrom> I think the question is about the group that funds the website and directs the admin
10:06:08 <monochrom> and the same group who receives donation from all of us
10:07:11 <monochrom> the group is, interesting, called Haskell.org again. but you can also say the Haskell.org committee
10:07:20 <monochrom> https://wiki.haskell.org/Haskell.org_committee
10:07:37 <ab9rf> page needs to be updated too
10:09:29 <NightRa> How to get out of global cabal hell?
10:09:46 <ab9rf> dump your global package store
10:09:48 <ab9rf> and start over
10:09:55 <ab9rf> and use sandboxes
10:09:57 <ab9rf> henceforth
10:10:11 <NightRa> ab9rf: How to drop it?
10:10:29 <ab9rf> delete everything in $HOME/.cabal (or whatever the windows equivalent is)
10:10:35 <jmcarthur> no
10:10:37 <jmcarthur> not that
10:10:42 <jmcarthur> $HOME/.ghc
10:10:53 <ab9rf> yeah, that one
10:11:05 <NightRa> ab9rf: What should be done about installed applications, not libraries, such as the purescript compiler and idris?
10:11:08 <ab9rf> jmcarthur: i think you need to bort .cabal too
10:11:15 <jmcarthur> no you don't
10:11:18 <NightRa> How should they be installed?
10:11:25 <dreams> Anyone knows what a star (*) means in the type (-hy) heap profile?
10:11:28 <jmcarthur> and if you do, you lose your cabal config and such, too, which stinks
10:11:32 <ab9rf> jmcarthur: ah
10:11:42 <ab9rf> wanyway, do what he says :)
10:11:52 <jmcarthur> and it's also nice to keep around whatever executables you had installed into ~/.cabal/bin
10:11:54 <ab9rf> NightRa: i don't use those so i have no suggestion
10:12:03 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove . in fact, read the whole thing
10:12:12 <jmcarthur> monochrom++
10:12:59 <monochrom> it turns out that there is no escape from consciously knowing and choosing what to delete and what to keep on a case-by-case basis, i.e., there is no rule of thumb, no royal road.
10:13:35 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
10:13:59 <NightRa> Anyone can answer my previous questions? How to deal with application installs, not library installs?
10:14:07 <NightRa> (Also, GHC-mod)
10:15:54 <monochrom> even $HOME/.ghc is not to be lightly erased wholesale, if you keep your ghci.conf there, or if you use multiple GHC versions concurrently
10:15:59 <tomphreek> myexp :: (Distribution StdUniform a) => RVar a
10:16:18 <tomphreek> Non type-variable argument in the constraint: Distribution StdUniform a
10:20:17 <tomphreek> @src Data.Random.Distribution.Exponential.exponential
10:20:17 <lambdabot> Source not found. It can only be attributed to human error.
10:21:27 <nocturne777> how do I import "â†" in haskell?
10:21:50 <nocturne777> I've enabled haskell-mode in emacs and it keeps turning these characters into their UTF-8 version I think
10:22:07 <nocturne777> alsa `elem` becomes `E`
10:23:07 <enthropy> that arrow is probably the same as <- if you -XUnicodeSyntax
10:23:27 <geekosaur> but I don't know where you get elem from...
10:23:48 <nocturne777> enthropy: yes, it is the same
10:24:03 <nocturne777> but is haskell supposed to not work with these characters
10:24:57 <enthropy> http://hackage.haskell.org/package/base-unicode-symbols
10:25:01 <geekosaur> nothing stops someone from defining â† as their own operator, so it's a backward compatibility thing; you need to opt in to having that syntax stolen
10:25:17 <geekosaur> also emacs haskell-mode does not default to doing that substitution, last I checked
10:25:20 <geekosaur> it's an option
10:27:08 <NightRa> Are Stackage nightlies exclusive?
10:27:10 * hackagebot gps 1.2 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-1.2 (ThomasDuBuisson)
10:27:32 <nocturne777> enthropy: how I find out if I have this package installed?
10:27:38 <NightRa> They say on the website that all snapshots are now inclusive, but it doesn't appeat to be so
10:27:56 <enthropy> you could try to import one of the modules it defines
10:29:13 <geekosaur> ghc-pkg list?
10:29:31 <geekosaur> (then use cabal install to install it if desired)
10:29:39 <nocturne777> geekosaur: is this practice of replacing characters with their unicode version actually recommended?
10:29:48 <nocturne777> if it is not recommended, I will turn this off in emacs
10:29:56 <geekosaur> I don't use it and am not convinced it's a great idea
10:30:38 <nkar> how can I download all the text databases from hackage, so I could feed them to hoogle? has anyone tried that?
10:32:57 <geekosaur> it's confusing (as you have found), it can cause problems if someone not on a fully utf8-enabled system (stall far too common) tries to look at the source, etc.
10:33:20 <geekosaur> it's "neat" but that isn't sufficient justification imo
10:33:40 <geekosaur> (that said, many of the people who do it also use agda, where it's normal and expected)
10:46:16 <Buttons840> what is the (.~) operator? hoogle didn't help
10:46:31 <Buttons840> :t (.~)
10:46:32 <lambdabot> ASetter s t a b -> b -> s -> t
10:46:50 <breadmonster> Buttons840: Is this from lens?
10:47:27 * Buttons840 sees lens and despairs
10:47:32 <Buttons840> i think so
10:48:07 <breadmonster> @src ASetter
10:48:07 <lambdabot> Source not found.
10:48:18 <Cale> Buttons840: It's another way to write set
10:48:59 <Cale> > set _1 "hello" (1,2)
10:49:01 <lambdabot>  ("hello",2)
10:49:12 <Cale> > _1 .~ "hello" $ (1,2)
10:49:14 <lambdabot>  ("hello",2)
10:49:43 <breadmonster> Cale: What on earth does lens do?
10:49:59 <bananagram> :t set
10:50:00 <lambdabot> ASetter s t a b -> b -> s -> t
10:51:49 <Cale> breadmonster: It gives you values that let you focus on parts of data structures, extracting the part, or replacing it with another.
10:51:56 <Cale> i.e. lenses
10:51:57 <HeladoDeBrownie> nocturne777, i don't understand the question, if you have a binding in some module by that name, you should be able to just write that in the imports list
10:52:03 <HeladoDeBrownie> woops, was scrolled up >_<
10:52:04 <breadmonster> Cale: Like imperative programming?
10:52:23 <Cale> Uh, not mutation
10:52:29 <Cale> Just rebuilding a new structure
10:53:13 <jmcarthur> also a bit more interesting transformations than plain mutation.
10:53:31 <breadmonster> Oh hi jmcarthur (:
10:53:49 <Cale> A simpler sort of lens than the ones that the lens library provides (but in the same sort of vein) would be:
10:53:59 <jmcarthur> breadmonster: hi!
10:54:26 <breadmonster> Interesting, go on.
10:54:27 <Cale> data Lens a b = L { view :: b -> a, set :: a -> b -> b }
10:54:46 <edwardk> alas that version doesn't have as nice performance when heavily composed
10:54:56 <dmwit> ?google gunctional references twanvl
10:54:59 <lambdabot> http://bartoszmilewski.com/2013/10/
10:54:59 <lambdabot> Title: October | 2013 | Bartosz Milewski's Programming Cafe
10:55:00 <edwardk> but it is a good conceptual model
10:55:05 <dmwit> uh
10:55:16 <dmwit> ?google functional references twanvl
10:55:18 <lambdabot> http://www.twanvl.nl/blog/haskell/cps-functional-references
10:55:18 <lambdabot> Title: CPS based functional references
10:55:29 <edwardk> dmwit:  http://www.twanvl.nl/blog/haskell/cps-functional-references
10:55:30 <Cale> lol, everything but the one you want
10:55:31 <edwardk> yeah
10:55:48 <Cale> http://twanvl.nl/blog/haskell/overloading-functional-references
10:55:59 <Cale> ^^ there's the basic one
10:56:05 <dmwit> Cale++
10:56:21 <dmwit> lambdabot--
10:56:31 <edwardk> the one i linked was the one that supplied the representation of lenses as we use them today
10:56:50 <breadmonster> Cale: How is that remotely a lens?
10:57:15 <edwardk> breadmonster: a lens is a getter/setter pair that are compatible in the obvious ways
10:57:15 <Cale> breadmonster: You mean, how does this definition of lens correspond to the one that the lens library defines?
10:57:22 <breadmonster> edwardk: The Milewski article?
10:57:37 <voidzero> Hmm.. I have a list of ["foo", "bar", "baz"], and I need to get a string of "foo,bar,baz"
10:57:41 <breadmonster> Cale: I mean how does that definition of lens have anything to do with getting or setting?
10:57:43 <edwardk> the milewski article was lambdabot giving the wrong link =)
10:57:45 <dmwit> breadmonster: the milewski article was a typo
10:58:19 <dmwit> breadmonster: typing on a phone sucks, sorry
10:58:39 <edwardk> milewski there was showing how you get from the `lens` encoding of a lens back to the old data-lens formulation of a lens using the Yoneda lemma. It was a very nice insight.
10:58:44 <voidzero> is there an existing function for what I want to do?
10:58:47 <dmwit> "gunctional"
10:58:51 <breadmonster> edwardk: So what's the article you wanted to link?
10:59:08 <HeladoDeBrownie> @type intersperse
10:59:09 <lambdabot> a -> [a] -> [a]
10:59:11 <HeladoDeBrownie> voidzero, that one?
10:59:13 <Cale> breadmonster: Well, the idea is to provide a way to get some value of type a from a structure of type b, and to be able to take a new value of type a, and replace it in a structure of type b to get a new structure of type b.
10:59:13 <dmwit> voidzero: intercalate
10:59:31 <HeladoDeBrownie> oops, yeah, not intersperse
10:59:39 <voidzero> HeladoDeBrownie, yeah, I tried intersperse, combined with unwords :)
10:59:47 <HeladoDeBrownie> dmwit has it
10:59:49 <voidzero> @type intercalate
10:59:50 <lambdabot> [a] -> [[a]] -> [a]
10:59:54 <edwardk> well, dmwit was the one trying to link to stuff, the two twanvl links are interesting. one gives the old data-lens notion of a lens more or less, which is what cale is describing, the other gives the new `lens`-style notion of a lens.
10:59:59 <voidzero> cool! thanks.
11:00:28 <breadmonster> edwardk: what about this? https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
11:00:35 <edwardk> 2007 and 2009 respectively, so rather prophetic ;)
11:00:53 <edwardk> breadmonster: that was when simon got around to understanding them =)
11:01:08 <dmwit> edwardk steals from the best
11:01:30 <edwardk> yep, roconnor showed me we could just rip off the type signatures and then they supported changing assignment
11:01:43 <Cale> I like how Simon gives Edward 100% of the credit :D
11:01:57 <edwardk> and of course benjamin pierce gave us a bunch of laws in the first place for very well behaved lenses, before going off to play with ones that are less well behaved
11:02:26 <edwardk> or rather getting dmwit to do so =P
11:02:29 <breadmonster> Interesting.
11:02:47 <dmwit> those laws predate even us, i think
11:03:01 <dmwit> we steal from the best, too
11:03:43 <edwardk> dmwit: once you go far enough down the profunctor path those laws wind up just being the functor laws
11:03:50 <tomphreek> is it possible to write "(+) <$> a <*> b" in an infix notation
11:04:10 <edwardk> the categories involved are weird, but it means we're just repeating functor laws over and over
11:04:48 <dmwit> edwardk: well, the trick is identifying the right category
11:05:09 <tomphreek> so that (+) is in between a and b.
11:05:45 <opqdonut> tomphreek: see http://hackage.haskell.org/package/InfixApplicative
11:05:45 <dmwit> edwardk: and i'm safing people played with things that would lead you to that same category befor bcp/njf started working on lenses
11:06:08 <opqdonut> tomphreek: that lets you type that as "a <^ (+) ^> b"
11:06:42 <edwardk> sure
11:07:02 <opqdonut> tomphreek: the docs of the package are a bit mangled for some reason, but see http://hackage.haskell.org/package/InfixApplicative-1.1/docs/src/Control-Applicative-Infix.html
11:07:10 <edwardk> you can build up lenses as algebras of a particular monad in a slice category, but that encoding cuts you off before you get to prisms or rather, you have to construct it all backwards to get prisms
11:07:31 <tomphreek> opqdonut: awesome, cheers
11:07:35 <edwardk> you can build up lenses in terms of tambara modules, which is probably the most satisfying encoding
11:07:50 <edwardk> because then you can see prisms _as_ lenses for a suitable notion of a choice of underlying monoidal category
11:07:58 <HeladoDeBrownie> what does "algebra of X" mean for some X?
11:08:33 <dmwit> HeladoDeBrownie: wikipedia has a nuce discussion of algebras
11:08:46 <HeladoDeBrownie> in the "algebra" article?
11:08:49 <HeladoDeBrownie> i thought it might be a different sense
11:08:58 <Welkin> a system of composable things?
11:08:59 <breadmonster> HeladoDeBrownie: It's a group that supports multiplication.
11:09:06 <Welkin> there is an algebra of shapes
11:09:12 <Welkin> Minkowski algebra
11:09:36 <dmwit> HeladoDeBrownie: f-algebra
11:09:55 <HeladoDeBrownie> dmwit, thanks
11:10:13 <lush> hi everybody
11:10:20 <breadmonster> HeladoDeBrownie: Sorry, my bad, it's a little more general than that. An algebra is basically a vector space that supports multiplication.
11:10:59 <dmwit> hi, lush
11:11:03 <tomphreek> src/Control/Applicative/Infix.hs:1:1: Ambiguous module name â€˜Preludeâ€™: it was found in multiple packages: base haskell98-2.0.0.3 ... hm I might stay out of it :/
11:11:27 <geekosaur> that would be an outdated package
11:11:48 <dmwit> tomphreek: perhaps the cabal file specifies the wrong default-language
11:11:54 <geekosaur> it hasn't been able to use both base and haskell98 for several years, because the standard changed in incompatible ways
11:13:59 <breadmonster> Alright, night guys.
11:14:27 <tomphreek> dmwit: my cabal config file or the package's I am trying to install cabal file?
11:14:37 <lush> may somebody explain me 2 of the 4 applicative laws? I re-read the applicative chapter in LearnYouAHaskell but I don't rly get what the snd and the fourth law exactly say..
11:14:38 <lush> http://susepaste.org/40238950
11:14:49 <dmwit> tomphreek: the failing package
11:15:14 <lush> I'm not even able to replace all that a's and b's with the appropriate parts by partially applying: pure (.) <*> u <*> v <*> w
11:15:30 <lush> It would be rly nice if somebody would explain to me how that works..
11:15:34 <dmwit> tomphreek: it is probably easy to fix by changing dependencies or defaultt language or both
11:16:29 <tomphreek> I'll live with polish notation for now
11:21:59 <HeladoDeBrownie> lush, that law essentially says that Applicative preserves function composition. i'm not sure what you meant about replacing a's and b's though.
11:23:03 <lush> HeladoDeBrownie: <*> :: f (a -> b) -> f a -> f b. Assuming that I've got this one: pure (.) <*>, what's it's type, and I don't rly understand what's the type of u,v,w as well
11:23:07 <lush> HeladoDeBrownie: ty for the tip
11:23:09 <lush> though
11:23:47 <HeladoDeBrownie> lush, you can't isolate just "pure (.) <*>" from that expression, it's not a complete expression by itself in that context.
11:24:25 <lush> HeladoDeBrownie: shouldn't (pure (.)) take that ( f (a -> b) ) part in <*> ?
11:24:28 <hpc> :t (pure (.) <*>)
11:24:29 <lambdabot> Applicative f => f (b -> c) -> f ((a -> b) -> a -> c)
11:24:29 <lush> *replace
11:25:07 <dmwit> :t \u v w -> pure (.) <*> u <*> v <*> w
11:25:08 <lambdabot> Applicative f => f (b1 -> b) -> f (a -> b1) -> f a -> f b
11:25:27 <dmwit> so u :: f (b1 -> b), v :: f (a -> b1), w :: f a
11:25:42 <dmwit> example:
11:26:23 <dmwit> > pure (.) <*> [(+100), (+10)] <*> [(*100), (*10)] <*> [10, 1]
11:26:25 <lambdabot>  [1100,200,200,110,1010,110,110,20]
11:26:55 <dmwit> > pure (.) <*> [(+100), (+10)] <*> [(*100), (*10)] <*> [2, 1] -- might be a more transparent example
11:26:57 <lambdabot>  [300,200,120,110,210,110,30,20]
11:27:25 <HeladoDeBrownie> sorry, got distracted for a moment :P but looks like dmwit is explaining
11:27:59 <dmwit> lush: Yes, (pure (.)) unifies with the (f (a -> b)) in the type of (<*>).
11:28:03 <dmwit> :t pure (.)
11:28:04 <lambdabot> Applicative f => f ((b -> c) -> (a -> b) -> a -> c)
11:28:20 <dmwit> Or, to avoid so many name clashes:
11:28:46 <dmwit> pure (.) :: Applicative f => f ((e -> f) -> (d -> e) -> (d -> f))
11:29:16 <dmwit> This unifies with f (a -> b) by setting a ~ (e -> f) and b ~ (d -> e) -> (d -> f)
11:29:29 <lush> dmwit: So in f (a -> b)   a :: (e -> f),  b :: (
11:29:31 <lush> ah
11:29:36 <lush> well you was more fast lol
11:29:37 <lush> ty
11:29:43 <dmwit> yw
11:31:04 <lush> dmwit: so this law is all about Functions wrapped in Applicatives, and how they should behave if I lift (.) to the applicative lvl?
11:31:44 <dmwit> okay
11:31:52 <dmwit> I'm fine with that description.
11:33:38 <lush> ty again dmwit, now I at least understand what the snd law tries to say, I think I'll be able to understand it tomorrow in school (there I've got enough time... ^^)
11:34:00 <lush> dmwit: and what about the fourth one, I don't understand that one as well..
11:34:21 <lush> I guess u is a wrapped function
11:34:42 <dmwit> lush: right
11:34:48 <dmwit> :t \u y -> u <*> pure y
11:34:50 <lambdabot> Applicative f => f (a -> b) -> a -> f b
11:34:56 <dmwit> so u :: f (a -> b) and y :: a
11:35:06 <lush> and y a wrapped value, and then (pure ($ y)) tries to apply y to a function?
11:35:16 <lush> while u is that function
11:35:31 <dmwit> Well, y is an unwrapped value.
11:35:42 <dmwit> pure ($ y) applies the wrapped function(s) to the value y.
11:35:51 <dmwit> pure ($ y) <*> u does, anyway
11:36:09 <lush> aah, so that's why there's an additional $
11:36:30 <lush> ok, so this law is quite ovious as well
11:36:42 <lush> ty dmwit I think I understood that one "fully" now ^^
11:36:47 <dmwit> One of these laws ought to mention fmap.
11:36:57 <dmwit> Like, pure f <*> u = fmap f u, or something.
11:37:45 <lush> dmwit: yeah, but that I understood that one too
11:37:50 <lush> ty though
11:41:00 <kritzcreek> Hello, im looking for a way to split the dataflow in a Conduit from the Conduit library
11:41:14 <kritzcreek> is anyone accustomed with the problem?
11:44:35 <lush> dmwit: did I understand it correctly, that applicatives are useful, when I have for example a Function, that takes 3 "normal" values, but I want to apply 3 wrapped values, so pure f <*> a <*> b is sth. like f a b, while in the first case a and b are Wrappers like Maybe or so, and in the snd one a and b are usual values?
11:46:21 <dmwit> lush: The first part sounds good. Your characterization of "f", "a", and "b" in the second part sounds a bit imprecise.
11:46:38 <dmwit> In `pure f <*> a <*> b`, `a` and `b` would be wrapped values.
11:46:57 <dmwit> But `f` will be applied to unwrapped values, if anything.
11:47:46 <lush> dmwit: yeah, but I directly can use the wrapped a's and b's, and (<*>) will take care of their contexts right?
11:48:13 <lush> So I don't have to "extract" all those values, becase every Instance makes that for me
11:48:46 <lush> And I just use it like wrapped a and b would be "normal" a's and b's
11:49:05 <dmwit> A bit like that, yes.
11:50:49 <lush> dmwit: so it's mostly about lifting a function, and then applying that directly to wrapped-values, while the context gets handled by the concrete instantiation of that type?
11:51:14 <dmwit> lush: Well, I don't know about *mostly*. Sometimes you have functions with contexts, too, which is not the result of a lift!
11:51:41 <dmwit> lush: Though I will agree that probably 90% of uses of Applicative are covered by liftA{,2,3,4,...}
11:52:26 <lush> dmwit: you mean like that pure (.) <*> ... ?
11:52:27 <lush> @1
11:52:27 <lambdabot> Say again?
11:52:33 <lush> dmwit: @1
11:52:37 <Cale> Well, you can get everything in Applicative from pure () and liftA2 (,)
11:52:44 <Cale> (and fmap)
11:53:31 <dmwit> lush: I don't think I mean that. I would classify "pure" as a kind of lifting.
11:53:51 <dmwit> lush: Though your question was too short for me to be sure I'm interpreting it the way you meant it.
11:54:09 <Cale> It's reasonable to call it lifting, but lifting isn't the most precise technical term
11:54:27 <Cale> We use lifting to refer to almost any injective map :D
11:54:51 <lush> dmwit: you said that sometimes you have functions with contexts as well
11:55:02 <lush> dmwit: Is that pure (.) <*> ... an example of that?
11:55:15 <lush> I'm not sure whether I understood you right, that's why I'm asking.
11:55:25 <Cale> I do think that referring to "wrapped values" will often give the wrong impression though
11:55:37 <lush> Cale: what would you call it then? ;)
11:55:51 <dmwit> lush: No, "pure (.)" is not a good example of a function with context. But [(*10), (*100)] would be.
11:55:56 <Cale> Often the values of type f a are not really wrapped up values of type a, but rather computations whose results have type a.
11:56:05 <dmwit> lush: [(*10), (*100)] is not the result of any call to "pure".
11:57:02 <lush> dmwit: ah, so (Just (+3)) would also fall into that category, as it has the added "failure"-context?
11:57:22 <dmwit> lush: Well, `Just (+3)` is `pure (+3)`.
11:57:31 <lush> Cale: so youd just propose "added context" or how would you call it?
11:57:48 <Cale> I also don't use the word context like that
11:57:59 <Cale> Contexts are the things which come before => in type declarations :)
11:58:07 <dmwit> lush: Your original question was, "is this all about lifting functions". My answer is "no, sometimes you have something that's not a lifted function".
11:58:07 <lush> dmwit: But it is a function with added context or not? I think I get the term "function with context" that you wrong..
11:58:26 <dmwit> lush: `Just (+3)` is just a lifted function. But e.g. `Nothing` is not.
11:58:32 <Cale> I don't understand what dmwit means by "function with added context".
11:58:35 <lush> Cale: well I thought you'd call that class constraints
11:58:54 <voidzero> isn't "asks" a way to add context to a function?
11:58:57 <Cale> lush: Yeah, a context of class constraints :)
11:59:01 <dmwit> Cale: I mean anything that is not beta-eta equivalent to `pure f` for some `f`. =)
11:59:10 <Cale> dmwit: uhhh, okay
11:59:23 <Cale> I don't understand the use of the term "context" or "function" then :D
11:59:39 <dmwit> Okay, *and* has a type that unifies with Applicative f => f (a -> b).
11:59:50 <Axew> wrong button
11:59:53 <Cale> Oh, okay, well, why not just say that? :D
11:59:58 <lush> dmwit: you said 90% yes, but sometimes there are functions with added context, and as I thought of (Just (+3)) as a lifted function that falls under category 90%, I wondered what you think of by saying "functions with context" =)
12:00:47 <lush> dmwit: so [(+3)] is just a lifted func, while [(+3), (*3)] is a func with context in your terms?
12:00:51 <dmwit> lush: I gave Cale a precise answer just now; and I've given you a couple examples as well. How else can I help clarify? (Serious, not attacking, question.)
12:00:56 <dmwit> lush: right
12:01:03 <Cale> dmwit, lush: I would just say "value of type f (a -> b)"
12:01:42 <dmwit> lush: Well. I would say `[(+3)]` is a function with context, too. But the original wording was "function with context which is not the result of a lift".
12:01:43 <lush> dmwit: aaah, I think now I understand what you mean
12:02:04 <lush> dmwit: so it's just that pure takes it in a somewhat minimal context
12:02:10 <dmwit> right
12:02:10 <Cale> dmwit is using "function with context" to indicate that the functor f has been applied to a function type
12:02:16 <dmwit> yes
12:02:30 <lush> dmwit: I got it, ty for your patience :)
12:02:35 <dmwit> phew, and thank you for yours
12:02:45 <lush> hehe
12:03:07 <lush> Wait until I reread about Monads haha
12:05:17 <Cale> If you have unit :: f () and pair :: f a -> f b -> f (a,b) (satisfying some appropriate analogous laws), you can write  pure v = fmap (const v) unit, and  f <*> x = fmap (uncurry ($)) (pair f x)
12:05:28 <Cale> So that gives another way of looking at Applicative
12:05:50 <Cale> pair here being the same as liftM2 (,) and unit being the same as pure ()
12:06:04 <Cale> er, liftA2 (,) rather
12:06:04 <Cale> hehe
12:06:18 <lush> Cale: what's that const?
12:06:35 <lush> ah
12:06:37 <lush> ok
12:07:02 <Zemyla> What is the precedence of (:)?
12:07:14 <dmwit> ?src const
12:07:15 <lambdabot> const x _ = x
12:07:30 <lush> Zemyla:
12:07:30 <kadoban> Zemyla: Pretty low
12:07:31 <dmwit> Zemyla: Try :i : in ghci
12:07:32 <geekosaur> Zemyla, you can use :info in ghci
12:07:33 <lush> :info (:)
12:07:38 <Cale> infixr 5 :
12:07:42 <geekosaur> *lambdabot does not have :info)
12:08:21 <lush> ?src id
12:08:21 <lambdabot> id x = x
12:08:37 <lush> ?src Applicative
12:08:38 <lambdabot> class Functor f => Applicative f where
12:08:38 <lambdabot>     pure  :: a -> f a
12:08:38 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
12:08:41 <lush> whow
12:08:45 <lush> pretty nice
12:09:22 <geekosaur> be warned the @src database is fairly small, and sometimes shows what's in the Report Prelude instead of the ghc one
12:09:34 <lush> ah ok, ty ^^
12:09:37 <geekosaur> (the ghc implementations sometimes have different strictness proeprties)
12:09:41 <Cale> Yeah, it's just a handcrafted text file
12:09:56 <Cale> @src sequence
12:09:56 <lambdabot> sequence []     = return []
12:09:56 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:09:56 <lambdabot> --OR
12:09:56 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:10:08 <Cale> Sometimes it has more than one possible definition :)
12:22:30 <mjrosenb> ok, I have a question about fusion and its rules.
12:23:32 <geekosaur> "good luck"
12:23:42 <mjrosenb> https://gist.github.com/037c2fc3f3a09c3da016 -- I want to use this like filter oneTrans (seqs 40)
12:24:56 <mjrosenb> I know it is possible to do this quickly by ust marking individual lists on length < 40 as being filtered out
12:25:24 <mjrosenb> but is this a thing that I can convince ghc to do for me?
12:29:25 <dmwit> mjrosenb: That seems like a terrible way to generate this list.
12:29:33 <dmwit> mjrosenb: Since it's pretty easy to construct it without a filter at all.
12:29:55 <mjrosenb> dmwit: yes, I want to do this to learn abut ghc, not to actually get the lists.
12:30:02 <dmwit> ok
12:30:31 <dmwit> Then what does this comment about "individual lists on length < 40 as being filtered out" mean?
12:31:53 <mjrosenb> the filter function is monotonic in the right hand side of the list, so (f l) => False, then f (x:l) => false
12:32:05 <Big_G> Hey all. I was just wondering what you all use Haskell for
12:32:12 <dmwit> Okay. This can't really be done with fusion; it must be done by changing the algorithm.
12:32:19 <dmwit> (unfortunately)
12:33:17 <dmwit> mjrosenb: e.g. by generating a Tree Bool instead of a [[Bool]], and pruning then flattening
12:33:42 <dmwit> Big_G: programming
12:33:51 <mjrosenb> I guess what I wanted it to do was to insert the return value of oneTrans' into each element seq foo, as it is built up
12:34:11 <Big_G> dmwit, I guess that is all I can expect for a vague question like that
12:34:30 <obb> uni Big_G
12:34:36 <mjrosenb> and just removing the element from seqs n as soon as it would evaluate to false.
12:35:56 <mjrosenb> reactive-banana questoin: is t a type that I can actually use? I haven't really seen anything that *produces* a t.
12:35:58 <kadoban> Big_G: It's a general purpose, high-level language. It's good for just about anything. The only things I definitely wouldn't use it for are like, work on embedded systems where C is pretty close to the only option.
12:37:17 <dmwit> mjrosenb: Every term that type-checks at all matches the type `t`...
12:37:21 <Cale> Big_G: I've done paid work in Haskell on a compiler for a special purpose programming language for signal processing applications, on an action RPG for iPhones, and on a web application backend for a scheduling/appointment service.
12:37:44 <dmwit> ?wiki Haskell in Industry
12:37:45 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_Industry
12:37:55 <Big_G> Cale, How did you manage those last two?
12:37:56 <Cale> Big_G: It's also just the language which I'm most likely to use for most things.
12:38:06 <dmwit> lower-case i
12:38:13 <dmwit> ?wiki Haskell in industry
12:38:13 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
12:38:22 <Big_G> I know what Haskell is. I was wondering what you all specifically use it for
12:38:29 <dmwit> "yes"
12:38:56 <mjrosenb> dmwit: I thought it was supposed to be a time-like parameter?
12:40:06 <dmwit> mjrosenb: Maybe I shouldn't answer. I know next to nothing about reactive-banana, so it's possible there's some context that makes your question more sensible.
12:40:12 <Cale> Big_G: Well, for the game, one of the people working with us, Stephen Blackheath, extended the ARM backend support in GHC to get Haskell code to run on iPhones. That's all been contributed back to GHC proper (and tidied up a bunch since).
12:40:54 <Cale> Big_G: For the web application backend, we used Snap. There are a lot of well-developed frameworks for web applications in Haskell.
12:41:02 <mjrosenb> http://hackage.haskell.org/package/reactive-banana-0.8.0.4/docs/Reactive-Banana-Combinators.html -- Event t a represents a stream of events as they occur in time. Semantically, you can think of Event t a as an infinite list of values that are tagged with their corresponding time of occurence,
12:41:15 <Big_G> Cale, Beyond having who I'm assuming is a Haskell powerhouse, why did you choose it for the iOS app?
12:41:20 <dmwit> mjrosenb: Possibly http://packdeps.haskellers.com/reverse/reactive-banana will give you some ideas.
12:41:29 <adimit> there's probably no way to tell the compiler to use C.M.State.Lazy from mtl instead of transformers without a cabal sandbox, and/or hiding transformers globally, right?
12:41:38 <Big_G> Cale, Why not any other language with solid libraries?
12:41:39 * mjrosenb would very much like to read that tag, I think?
12:42:03 * mjrosenb reads
12:42:17 * hackagebot th-expand-syns 0.3.0.5 - Expands type synonyms in Template Haskell ASTs  http://hackage.haskell.org/package/th-expand-syns-0.3.0.5 (DanielSchuessler)
12:42:18 <dmwit> adimit: package-qualified imports, if there's really a module name clash
12:42:28 <dmwit> adimit: But I thought mtl and transformers were pretty careful not to export the same module names
12:43:51 <dmwit> adimit: I don't see a C.M.State.Lazy in transformers...
12:43:54 <Cale> Big_G: Well, I didn't make the language decision (ultimately I believe that was Ryan Trinkle's decision), but I think just because Haskell is well-positioned to eliminate a lot of the bugs that come up in game development. We spent quite a lot of effort on our FRP library though. It was halfway a research project.
12:44:24 <adimit> dmwit: maybe I'm being dumb. I'm import Control.Monad.State.Class (mtl). My signature reads MonadState s m, and I import Control.Monad.State.Lazy. GHC complains it can't unify my monad type with transformers:Control.Monad.Trans.State.Lazy.StateT
12:44:51 <Big_G> Cale, Glad to hear it worked. Sounds like a good project to play with
12:45:06 <adimit> (upon using evalState, which I imported from C.M.State.Lazy)
12:45:11 <dmwit> ?paste some minimal code and the exact error, adimit
12:45:11 <lambdabot> Haskell pastebin: http://lpaste.net/
12:45:23 <geekosaur> adimit, I think that's reexports confusing you
12:45:45 <dmwit> adimit: Does the error mention a version number on transformers?
12:45:47 <geekosaur> mtl re-exports some transformers things under different names, and ghc is showing you the original not the re-exported name for some reason
12:45:58 <adimit> dmwit: thanks I'll try to fiddle around with it first, then paste, since I'd have to rip out a few spcefic things to cook up a MWE.
12:45:58 <geekosaur> and the real error is strict vs. lazy
12:46:07 <adimit> geekosaur: that might be it.
12:46:07 <geekosaur> (this is a guess; show full scource and full error)
12:46:16 <dmwit> adimit: Just paste the exact error to begin with.
12:46:43 <Cale> Big_G: Yeah, well, the game engine worked pretty well. We didn't manage to get the game itself done before running out of funding, sadly (we had a big open world, and combat vs. AIs, but there wasn't a whole lot to do yet).
12:47:01 <Sornaensis> how long do lpaste pastes last
12:47:38 <dmwit> indeterminate, but "a long time"
12:47:40 <Big_G> Cale, I haven't worked on a project that big but I can only imagine how that must have felt. What are you wokring on now?
12:47:50 <Cale> Big_G: But it was a fun project to work on, for sure, and at least *I'm* convinced that Haskell's not a bad language for game dev :)
12:48:04 <Big_G> Make it a new industry tred
12:48:04 <dmwit> Sornaensis: I don't know when the last cleanup was, but I've referenced years-old pastes in the past.
12:48:06 <Big_G> trend
12:48:55 <Cale> I've just been sitting on the money I got doing work on the web application and studying various things on my own.
12:49:25 <Welkin> Cale: what game/web application is this?
12:49:27 <Cale> At some point I'll have to go back to work, but I'll probably have to move.
12:49:48 <lpaste> adimit pasted â€œCMState errorâ€ at http://lpaste.net/120165
12:49:51 <adimit> dmwit, geekosaur: thanks a lot for your help. I haven't done an MWE yet. Maybe you will know what's up from looking at this mess, but if you can't (or don't want to, I'll just fiddle around some more.)
12:49:56 <Big_G> Cale, What are your thoughts on the new lisp from MIT. I think it was called url or something similar
12:49:57 <Cale> Welkin: It was an action RPG called Blood Knight (never got released, but we got quite a ways along in development)
12:50:08 <Cale> Welkin: and for the web application, that was skedge.me
12:50:23 <Cale> Big_G: Haven't heard of it.
12:50:30 <dmwit> adimit: You probably have two versions of transformers installed; mtl depends on one version, and your package depends on another. Or something like that.
12:50:55 <nkar> which packages does hoogle data all default download?
12:51:06 <adimit> dmwit: indeed. GHC came with its own version (0.3.x) and cabal installed (0.4.1) I hide one?
12:51:45 <dmwit> adimit: Oh, wait, there's another problem.
12:52:10 <dmwit> adimit: You claim to work with any instance of MonadState, but actually call evalState.
12:52:18 <dmwit> adimit: Which only works with a single specific instance of MonadState.
12:52:18 <adimit> dmwit: yes, I just saw it.
12:52:31 <adimit> I need evalStateTâ€¦
12:52:36 <dmwit> adimit: No...
12:52:41 <dmwit> adimit: You need to change your type signature.
12:53:03 <dmwit> adimit: Either make it rank-2, or specialize it to State.
12:53:24 <adimit> hm. OK. I had it with specialization to State before, but thought the added flexibility might be a good idea in general.
12:53:47 <dmwit> adimit: Think about this function: foo :: Num n => n -> Int; foo n = n
12:53:51 <dmwit> adimit: Do you see why this is wrong?
12:54:07 <dmwit> adimit: And why it is not a correct "added flexibility" compared to `foo :: Int -> Int`?
12:54:23 <adimit> yes, that is clear to me.
12:54:40 <Buttons840> Cale: i have some interest in haskell game development, and from my research (mostly just collecting random opinions from the internet) it seems like GHC's stop-the-world GC would be the only deal breaker?
12:54:58 <adimit> It was just hidden away behind all the other tyvars in that type signature :-) (and that transformers-library-version-thing didn't help.)
12:55:04 <dmwit> yeah
12:55:05 <Buttons840> but the GC probably wouldn't matter in practice?
12:56:11 <dmwit> One may have to be careful to GC at "opportune" moments.
12:56:47 <Buttons840> dmwit: oh? how much control do you have over the GC in Haskell? it sounds like you can delay it from running until you're ready?
12:56:58 <Cale> Buttons840: Yeah, there are ways to sidestep that if it's an issue though. Minor collections were no problem, but major collections (about once every 5 minutes) on the oldest iPhones we wanted to develop for at the time (iPhone 3, if I recall correctly) took something like 250ms. On a desktop machine, they weren't really noticeable.
12:57:13 <Buttons840> dmwit: can you do anything like say "run for 3 milliseconds, that's all you get for now"?  I noticed the new Nim language has that in their GC
12:58:04 <Cale> Buttons840: Our original plan was to have a small loop written in C++ that would provide an abstraction over drawing animations, and smooth over the time that the Haskell bits would be garbage collecting.
12:58:37 <Buttons840> Cale: did you describe some of your experiences on StackOverflow already? I think I have read them
12:58:49 <Cale> I don't have an SO account, so probably not.
12:58:59 <dmwit> Buttons840: You can't delay, but you can do it early. I don't know of a way to halt a GC early, either.
12:59:04 <Cale> But maybe one of the other people working with us did :)
12:59:07 <davean> There are also ways to make the GC look at less things
12:59:16 <davean> But that goes to your coding style
12:59:26 <davean> things like vectors require less walking
12:59:47 <Buttons840> Cale: they described a iPhone game where the animation was written in C++, sounds very familiar
13:00:18 <Cale> The newer iPhones are much faster of course, I wonder how things would be now.
13:00:48 <Welkin> I am amazed by the capabilities of recent iphones/ipads
13:00:57 <Cale> The desktop version we'd use for testing didn't need the C++ bits, we just used a Haskell version, and it was fine.
13:01:29 <Buttons840> of course, I can think of a certain game that has become very popular despite frequent GC pauses... ;)
13:01:38 <Welkin> especially rendering high-end 3D graphics on a retina display
13:01:43 <Buttons840> it's a game about mining, and crafting
13:01:59 <mauke> minesweeper
13:02:02 <voidzero> bitcoiner
13:02:08 <Welkin> of course, it's hard to find any decent games on the damn thing
13:02:12 <Cale> Well, there are all sorts of things which can cause frame drops in games, not just GC
13:02:24 <Welkin> the controls scheme is garbage
13:02:27 <Cale> It's just the extent to which it gets in the way of the game being enjoyable
13:02:51 <voidzero> ...obviously
13:02:52 <Sonarpulse> ghc rts is quite tunable no?
13:02:53 <voidzero> :-)
13:03:00 <davean> Sonarpulse: eh
13:03:00 <Welkin> if I could hook up a proper controller to an ipad, it would be great
13:03:18 <davean> Sonarpulse: I mean, you can recompile it ;)
13:04:58 <Sonarpulse> there was some stack overflow about getting < 10 ms gc latency
13:05:12 <Sonarpulse> anyways i am trying to build my program
13:05:17 <Sonarpulse> and i am gettinga link error
13:05:21 <Sonarpulse> missing symbol:
13:05:21 <Buttons840> On wednesday I'll be giving a 20 to 30 minutes presentation about haskell to a bunch of ruby developers at my workplace (I don't work with ruby though) -- any suggestions for a curriculum to follow?
13:05:26 <Sonarpulse> clashzmverilogzm0zi4_CLaSHziBackendziVerilogziBore_declaration_closure
13:06:13 <Sonarpulse> do i just chuck my sandbox?!
13:06:24 <Welkin> Buttons840: you could try showing them Scotty as an example of a web framework, since it is a Haskell version of sinatra
13:06:35 <voidzero> missing symbols make for great passwords
13:06:36 <voidzero> lol
13:07:22 <Buttons840> Welkin: good suggestion, I might put that towards to end, but I want to cover the language features well, and then a library if I have the time
13:08:23 <Buttons840> I'll also mention "haskell on a horse" just because of the name ;)  even though the project is abandon
13:08:24 <Welkin> Buttons840: the type system, partial application, composition, folds vs loops, typeclasses, ADTs
13:08:47 <Cale> Buttons840: I think they were longer, but you might look at SPJ's intro to Haskell presentations for some inspiration :)
13:09:06 <sdfoij> Hi, I want to generate a list of random numbers from x to y - which package should I look into? Data.Random, System.Random, something else?
13:09:14 <Cale> I think they were called "A Taste of Haskell"
13:09:34 <Bor0> I'd also mention execution/control flow. for instance when compared my Python web apps to Haskell web apps I felt much safer with Haskell's IO rather than Python's
13:09:41 <Bor0> I don't know how that's done in Ruby tho
13:09:43 <sdfoij> l
13:09:59 <Cale> sdfoij: Well, starting with System.Random won't be too bad
13:10:03 <Welkin> I never felt safe with python -- it was always a tangled mess
13:10:06 <Buttons840> Ruby and Python are exactly the same (I know python well) relative to haskell
13:10:11 <ReinH> sdfoij: randomR from System.Random would work, for instance.
13:10:19 <Sonarpulse> use continuation monad to do rubys return out of lambda thing?
13:10:26 <Cale> You can just do something like  replicateM 10 (randomRIO (x,y))
13:10:39 <sdfoij> okay ill look into System.Random
13:10:41 <Welkin> yeah, all of the algol-style languages are essentially the same
13:10:59 <Welkin> after learning haskell, I look at ruby, python, java, C, C++, swift, etc. as all the same thing
13:11:13 <ReinH> I think that's a bit reductionist
13:11:37 <Cale> sdfoij: There's a function  randomRs  which will take an initial PRNG state (which you can get by executing  newStdGen), and produce an infinite list of values in a given range.
13:12:01 <Cale> :t randomRs
13:12:01 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
13:12:17 <Cale> > randomRs (1,6) (mkStdGen 42)
13:12:18 <lambdabot>  [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,3...
13:12:52 <Big_G> Cale, Would you please explain to me how that function works?
13:13:15 <Cale> :t randomR
13:13:16 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:13:23 <Cale> ^^ it uses that function recursively
13:13:41 <Cale> > randomR (1,6) (mkStdGen 42)
13:13:43 <lambdabot>  (6,1720602 40692)
13:14:04 <Cale> So we get 6 as our first roll (just like in the list), and a new PRNG state
13:14:05 <voidzero> :t mkStdGen
13:14:06 <lambdabot> Int -> StdGen
13:14:17 <lpaste> adimit pasted â€œRank-2â€ at http://lpaste.net/120169
13:14:18 <adimit> dmwit: may I ask you one more question: by "making it rank-2" you meant rewriting my function to something like this?
13:14:19 <Cale> mkStdGen creates a PRNG state from an initial seed.
13:14:43 <Zemyla> :t \r -> unfoldr (Just . randomR t)
13:14:44 <Welkin> > randomRs (1,6) (newStdGen 42)
13:14:44 <lambdabot>     Couldn't match expected type â€˜(a, a)â€™ with actual type â€˜Exprâ€™
13:14:44 <lambdabot>     In the first argument of â€˜randomRâ€™, namely â€˜tâ€™
13:14:44 <lambdabot>     In the second argument of â€˜(.)â€™, namely â€˜randomR tâ€™
13:14:45 <lambdabot>  Couldn't match expected type â€˜a0 -> g0â€™
13:14:45 <lambdabot>              with actual type â€˜GHC.Types.IO System.Random.StdGenâ€™
13:14:46 <Big_G> I haven't written much Haskell so I'm a bit slow
13:15:00 <Welkin> > randomRs (1,6) =<< newStdGen
13:15:02 <lambdabot>  Couldn't match type â€˜GHC.Types.IOâ€™ with â€˜[]â€™
13:15:02 <lambdabot>  Expected type: [System.Random.StdGen]
13:15:02 <lambdabot>    Actual type: GHC.Types.IO System.Random.StdGen
13:15:05 <Big_G> Cale, Are Random and RandomGen types?
13:15:12 <voidzero> Welkin, you mean 'randomR' ?
13:15:12 <Welkin> :t newStdGen
13:15:13 <lambdabot> IO StdGen
13:15:14 <Cale> Big_G: They're type classes
13:15:25 <Welkin> > randomR (1,6) =<< newStdGen
13:15:26 <lambdabot>  Couldn't match type â€˜GHC.Types.IOâ€™ with â€˜(,) aâ€™
13:15:26 <lambdabot>  Expected type: (a, System.Random.StdGen)
13:15:27 <lambdabot>    Actual type: GHC.Types.IO System.Random.StdGen
13:15:42 <Welkin> :r randomR
13:15:45 <Welkin> :t randomR
13:15:46 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
13:16:05 <mniip> newStdGen is pure
13:16:07 <Big_G> Cale, Is a type class like a set of types and it works as long as the data is of a type in the set?
13:16:08 <mniip> iirc
13:16:13 <Cale> Big_G: Random is a type class for things which can be generated using the pseudorandom number generator. RandomGen is a type class for types that serve as PRNG states (and its operations are the PRNG itself)
13:16:15 <Welkin> > randomR (1,6) newStdGen
13:16:16 <Zemyla> :t \r -> unfoldr (Just . (randomR r))
13:16:17 <lambdabot> (Random a, RandomGen b) => (a, a) -> b -> [a]
13:16:17 <lambdabot>  Could not deduce (System.Random.RandomGen
13:16:17 <lambdabot>                      (GHC.Types.IO System.Random.StdGen))
13:16:17 <lambdabot>    arising from a use of â€˜System.Random.randomRâ€™
13:16:21 <Cale> Big_G: That's right
13:16:25 <mniip> wait no
13:16:25 <Zemyla> :t randomRs
13:16:26 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
13:16:33 <Big_G> Cale, What is a PRNG?
13:16:36 <mniip> that's mkStdGen
13:16:40 <Zemyla> That's basically how randomRs works.
13:16:41 <Cale> Pseudorandom number generator
13:16:52 <Welkin> > newStdGen
13:16:53 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
13:16:53 <lambdabot>                     System.Random.StdGen)
13:16:53 <lambdabot>    arising from a use of â€˜M32198889989697597766954.show_M32198889989697597766...
13:17:07 <voidzero> to generate a random number, you need an initial seed, and a generator
13:17:11 <voidzero> if i got that correct
13:18:03 <Welkin> > do { a <- newStdGen; return a }
13:18:04 <Cale> voidzero: Well, the StdGen more or less is your seed, and it's all you really need to get started
13:18:04 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
13:18:04 <lambdabot>                     System.Random.StdGen)
13:18:04 <lambdabot>    arising from a use of â€˜M89505171539675428216979.show_M89505171539675428216...
13:18:07 <Welkin> hm
13:18:11 <Welkin> what's wrong here?
13:18:38 <Welkin> must be some lambdabot issue
13:18:38 <Cale> Welkin: The Show instance for IO actions is broken.
13:18:45 <Cale> (because of imports)
13:19:05 <Cale> oh, no... it wants to show which type of IO action you have, and it uses Typeable for that
13:19:11 <Cale> But the Typeable instance for StdGen is missing
13:19:15 <Big_G> Cale, Can you explain the last half of that function then?
13:19:25 <Cale> Big_G: which one?
13:19:38 <Cale> Big_G: If you want, I can write randomRs using randomR
13:20:14 <Big_G> Cale, I don't know what that is so I don't know if it'd help much
13:20:26 <Big_G> (Random a, RandomGen g) => (a, a) -> g -> [a]
13:20:50 <Big_G> So a is something like a number, g is something that can generate a random number
13:21:09 <Big_G> Cale, The last part of  => (a, a) -> g -> [a]
13:21:09 <Cale> yeah
13:21:17 <voidzero> http://learnyouahaskell.com/input-and-output#randomness
13:21:24 <Cale> okay, so it takes a pair of values of type a, the lower and upper bound
13:21:30 <voidzero> LYAH to the rescue again... :)
13:21:35 <Cale> Like (1,6) if you want to roll a standard die :)
13:22:04 <Cale> and then a generator state
13:22:14 <Cale> and it produces a list of values in the given range
13:22:18 <Welkin> > return . randomR (1,6) =<< newStdGen
13:22:19 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
13:22:19 <lambdabot>                     System.Random.StdGen)
13:22:19 <lambdabot>    arising from a use of â€˜M44786532285184557427045.show_M44786532285184557427...
13:22:27 <Welkin> oh well
13:22:29 <Welkin> that works in ghci
13:22:32 <init> Welkin: getStdGen?
13:22:37 <Cale> Welkin: lambdabot won't execute IO
13:22:39 <mniip> mkStdGen?
13:22:45 <init> @type return . randomR (1,6) =<< getStdGen
13:22:47 <lambdabot> (Random a, Num a) => IO (a, StdGen)
13:22:52 <Big_G> Cale, That kind of makes sense. I just need to play around with it a lot more
13:22:54 <Welkin> I was trying to see if lambdabot would generate a new seed every time
13:23:12 <voidzero> Miran LipovaÄa deserves a statue, btw.
13:23:23 <Cale> :t mkStdGen
13:23:24 <lambdabot> Int -> StdGen
13:23:26 <Big_G> Cale, Thanks for the help
13:23:52 <Cale> Big_G: StdGen is an instance of RandomGen, and can serve as the 'g' type in the signatures we've been looking at
13:24:07 <Cale> mkStdGen makes a StdGen from an initial Int seed value
13:24:32 <Cale> Given the same seed, you'll always get the same sequence of pseudorandom numbers
13:24:35 <Welkin> System.Random is fun to play with
13:24:42 <Cale> > randomR (1,6) (mkStdGen 42)
13:24:44 <lambdabot>  (6,1720602 40692)
13:24:45 <Cale> > randomR (1,6) (mkStdGen 42)
13:24:47 <lambdabot>  (6,1720602 40692)
13:24:51 <Welkin> monte carlo simulations
13:24:53 <Cale> > randomRs (1,6) (mkStdGen 42)
13:24:54 <lambdabot>  [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,3...
13:24:56 <Cale> > randomRs (1,6) (mkStdGen 42)
13:24:56 <voidzero> one of the most useful tips I got, when just starting out, is when I heard spj say, you can read x:xs as "an x of exxes"
13:24:57 <lambdabot>  [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,3...
13:25:52 <Welkin> you should use newStdGen in a real program though
13:25:53 <Cale> voidzero: "of" is weird there
13:25:58 <voidzero> well yeah
13:26:12 <voidzero> but it made me realise that "xs" was just meant as the plural of x
13:26:16 <Cale> oh, yeah
13:26:23 <Welkin> voidzero: then xss as well
13:26:24 <Big_G> voidzero, That made no sense. What would an "int of ints" even mean?
13:26:43 <Clint> who said anything about ints
13:26:45 <Welkin> Big_G: x is an element of the set xs
13:26:45 <voidzero> my point was the plural
13:26:50 <Cale> "ex colon exxes" is a better way to pronounce it
13:27:03 <Welkin> well, the first element, with xs being the rest
13:27:07 <Cale> Or "ex cons exxes"
13:27:16 <Big_G> Ah, so it'd be an int in a set of ints?
13:27:19 <Welkin> I always think "x cons xs"
13:27:36 <voidzero> I'm not a native English speaker. I used to read its pronounciation as "x colon x.s." i.e. spelling out x and s
13:27:39 <Cale> Big_G: a list, but the way voidzero first said it is strange, because x isn't an element of xs there
13:27:46 <voidzero> not "x in a list of exxes"
13:28:04 <sx> voidzero: but what should a list of exxes be?
13:28:17 <voidzero> anything in the same type as x
13:28:18 <Cale> Big_G: (x:xs) means the nonempty list whose first element is x, and where the remainder of the list is xs
13:28:29 <Cale> > 1 : [2,3,4,5]
13:28:31 <lambdabot>  [1,2,3,4,5]
13:28:50 <Cale> > let (x:xs) = [1,2,3,4,5] in x
13:28:52 <lambdabot>  1
13:28:53 <Cale> > let (x:xs) = [1,2,3,4,5] in xs
13:28:54 <lambdabot>  [2,3,4,5]
13:28:59 <Big_G> Oh, so car and cdr in lisp?
13:29:03 <Cale> yes
13:29:13 <Big_G> That makes more sense
13:29:15 <mniip> car and cdr would be head and tail
13:29:22 <voidzero> he said it of the cuff, and maybe he said "list of", as in "by the way, you can just read x:xs as ex in a list of exxes"
13:29:29 <mniip> that thing is called a pattern match
13:29:35 <mniip> more like reverse constuctor
13:29:49 <sx> That nasty pattern match, I would really love to see more streamy things in the Prelude.
13:29:50 <voidzero> but to me and a few friends, that was a revelation to the untrained mind. :)
13:30:12 <Cale> voidzero: How about "x and then a list of xs"
13:30:14 <voidzero> "oh. So that is why they chose x and xs"
13:30:34 <mniip> voidzero, jsut hit me too
13:30:54 <voidzero> yeah sure, whatever floats your boat, i'm not trying to start a semantic debate
13:31:16 <Big_G> Does that "in x" or "in xs" just return those values?
13:31:24 <mniip> should have gone with de-bruijn indices :D
13:31:24 <voidzero> i'm just saying, that a simple off the cuff remark turned out to be a good way to remember what x:xs means
13:31:45 <mniip> Big_G, that's a "let ... in ..." construct
13:31:49 <Cale> Big_G: which values? :)
13:31:55 <Cale> oh
13:31:58 <Cale> I see what you mean
13:32:04 <dmwit> Big_G: `let FOO in BAR` creates the bindings `FOO`, then results in the expression `BAR`.
13:32:08 <Cale> Yeah,  let <declarations> in <expression>
13:32:29 <Cale> is an expression form that allows you to make local definitions
13:32:53 <Big_G> Wouldn't that be swapped because you have the expression first and then the varaible name?
13:33:04 <Cale> So I defined (x:xs) to be the list [1,2,3,4,5], and it pattern matched, binding the variable x to 1, and the variable xs to [2,3,4,5]
13:33:07 <mniip> variable name?
13:33:47 <voidzero> yes, local scope word, because of let
13:33:57 <Big_G> I understand that but if you look at the last few words, you have "in x" and "in xs" afterwards
13:34:23 <mniip> and?
13:34:46 <Cale> Big_G: Yeah, the result of evaluating the expression  let <decls> in e  is the result of evaluating e, with the given declarations in scope.
13:35:07 <Cale> Big_G: More examples:
13:35:14 <Cale> > let x = 10 * 10 in x
13:35:16 <lambdabot>  100
13:35:17 <Welkin> let x in f is equivalent to f where x
13:35:18 <Cale> > let x = 10 * 10 in x + 5
13:35:19 <lambdabot>  105
13:35:30 <Cale> Welkin: Except that where isn't an expression form
13:35:35 <Big_G> Oh
13:35:37 <Cale> It's part of the syntax of declaration
13:35:38 <Cale> s
13:35:49 <Welkin> the where clause is in scope for the entire block
13:36:01 <Welkin> let is in scope only for the expression after "in"
13:36:02 <Big_G> The let statement merely binds x to that straing but the in evaluates the string, correct?
13:36:07 <Welkin> unless it is inside a do-block
13:36:13 <Cale> Big_G: What string? :)
13:36:13 <mniip> string?
13:36:22 <Cale> Big_G: x got bound to a number there
13:36:26 <Big_G> The "10 * 10" string
13:36:29 <Cale> Big_G: The number 10 * 10
13:36:39 <mniip> :t "10 * 10"
13:36:40 <lambdabot> [Char]
13:36:42 <mniip> you are correct
13:36:45 <Cale> (Specifically, it'd be an Integer, due to numeric defaulting)
13:36:46 <Big_G> Is Haskell lazilu evaluated?
13:36:53 <Big_G> lazily
13:36:55 <Cale> Yes, it's lazily evaluated
13:36:59 <voidzero> it's infamous for being lazy
13:37:05 <voidzero> or famous, whichever you prefer :)
13:37:09 <mauke> but it's not a string rewriting system
13:37:18 <mniip> it can be one though
13:37:21 <Big_G> I prefer lazy.
13:37:22 <Sonarpulse> Ok, I just rebuild my sandbox
13:37:27 <Sonarpulse> and hit the probblem again
13:37:36 <Cale> Big_G: So, rather than string, you might want to say "expression"
13:37:43 <Sonarpulse> so odd. no ffi or fancy build scripts or anything like that
13:38:01 <Big_G> Of course. My brain just went to string first
13:38:06 <Sonarpulse> I know what library that symbol is define in, and I know i rebuilt it
13:38:17 <Big_G> It just parses it and has it in the IR
13:38:50 <Cale> Big_G: It'll bind x to the expression 10 * 10 there, without doing any evaluation. Only if the value of x is used (pattern matched on) will the expression get evaluated. But for any given variable, the evaluation will happen at most once.
13:39:32 <Big_G> That was what I figured. Just to clarify, what counts as pattern matching?
13:39:52 <voidzero> any expression
13:39:57 <Cale> At some level, all the pattern matching is case expressions
13:39:58 <Welkin> case x of ...
13:39:59 <voidzero> i guess
13:40:05 <Cale> Not any expression
13:40:21 <voidzero> oh, right. 1 + 1 is not pattern matching. But is an expression. :)
13:40:28 <Big_G> So if I said y is 2 * x but don't eval y, do I eval x at that point or still wait?
13:40:30 <Welkin> pattern matching on function arguments is converted to case expressions by ghc
13:40:37 <Cale> The definition of (+) will use pattern matching though
13:40:51 <Cale> > const 5 (product [1..1000000000])
13:40:52 <lambdabot>  5
13:41:05 <Cale> ^ this did not evaluate 1000000000 factorial
13:41:37 <Cale> Big_G: Still wait
13:41:59 <Cale> Big_G: Evaluating y will cause x to be evaluated, because (*) will need to know the value of its second argument in order to produce anything
13:42:05 <Welkin> > head 1 : 2 : undefined
13:42:06 <lambdabot>  No instance for (GHC.Show.Show a0)
13:42:06 <lambdabot>    arising from a use of â€˜M25338831144945855557469.show_M25338831144945855557...
13:42:06 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
13:42:24 <Big_G> Cale, Just wanted to check. I forgot how much fun learning a language is
13:42:26 <Welkin> > head (1:2:undefined:[])
13:42:27 <lambdabot>  1
13:42:54 <Welkin> Big_G: only 1 was evaluated
13:42:59 <Welkin> > head (undefined:[])
13:43:00 <lambdabot>  *Exception: Prelude.undefined
13:43:36 <Cale> Yeah, you can use undefined to observe things about what does and doesn't get evaluated in various cases, because evaluating undefined will produce an exception
13:44:01 <Big_G> What happens if the bot gets something computationally heavy?
13:44:06 <dmwit> Big_G: Try it!
13:44:16 <Cale> > product [1..]
13:44:25 <Cale> hehe
13:44:29 <lambdabot>  mueval: signalProcess: permission denied (Operation not permitted)
13:44:29 <lambdabot>  mueval-core: Time limit exceeded
13:44:33 <mniip> product is written in a lazy way so that it eats memory
13:44:42 <Big_G> head(product[1..10000])
13:44:45 <Cale> That took longer than expected
13:44:46 <Welkin> > [1..]
13:44:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:44:58 <mniip> pfft
13:45:22 <Sornaensis> what does lambdabot use
13:45:26 <Sornaensis> some kind of limited Prelude?
13:45:27 <Welkin> mueval
13:45:29 <Big_G> Can I take the head of a product?
13:45:35 <mauke> Big_G: no, it's not a list
13:45:35 <Clint> :t product
13:45:36 <lambdabot> Num a => [a] -> a
13:46:00 <Big_G> Why wouldn't it produce an error then for what I entered?
13:46:05 <mauke> it would
13:46:09 <Big_G> head([3, 4,5])
13:46:18 <Hugehead> You have to put a >
13:46:23 <Big_G> Oh
13:46:28 <Big_G> > head(product[1..10000])
13:46:29 <lambdabot>  No instance for (GHC.Show.Show a0)
13:46:29 <lambdabot>    arising from a use of â€˜M25355773732802242207592.show_M25355773732802242207...
13:46:29 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
13:46:36 <Welkin> Big_G: you don't need the parens
13:46:42 <Welkin> Big_G: a space is function application
13:46:44 <mauke> you do need those
13:47:07 <Big_G> head [1, 2, 3]
13:47:10 <Big_G> > head [1, 2, 3]
13:47:11 <lambdabot>  1
13:47:26 <Cale> Some of the error messages from lambdabot have been really suboptimal lately. I'm not sure if they're getting worse, or if they've always been that bad.
13:47:44 <Big_G> > product[1..4321]
13:47:47 <lambdabot>  9773471927362900570306875701416353991712346054387709212875634599621343192887...
13:47:54 <voidzero> lo
13:47:56 <voidzero> lol
13:48:05 <Big_G> This is so cool
13:48:20 <voidzero> it works via private messages, too! ;-)
13:49:04 <Big_G> Now I don't have to spam you all
13:49:17 <Cale> Like, why didn't it complain about no instance of Num [a0] there rather than complaining about an ambiguous type?
13:49:24 <Cale> Weird.
13:49:33 <Welkin> Big_G: it's better to just install haskell platform so you can actually run your programs
13:49:39 <Cale> > [1,2,3] + [4,5]
13:49:40 <lambdabot>  No instance for (GHC.Show.Show t0)
13:49:40 <lambdabot>    arising from a use of â€˜M85888395080104061437670.show_M85888395080104061437...
13:49:40 <lambdabot>  The type variable â€˜t0â€™ is ambiguous
13:49:54 <Cale> > [1,2,3] + [4,5 :: Integer]
13:49:55 <lambdabot>  No instance for (GHC.Num.Num [GHC.Integer.Type.Integer])
13:49:56 <lambdabot>    arising from a use of â€˜GHC.Num.+â€™
13:49:58 <Cale> okay
13:50:03 <Cale> So the instance really isn't there.
13:50:20 <Big_G> Welkin, I know it is but I'm on a Windows box right now because my Linux partition is having sound issues
13:50:33 <Welkin> you can use minGW
13:50:58 <Big_G> Good point
13:53:11 <dmwit> The Haskell Platform has a Windows installer.
13:54:16 <quchen> Compiling Haskell doesn't need sound.
13:56:35 <quchen> (It does offer sound though, check the -B flag) ;-)
13:57:04 <Big_G> I was just thinking about how I can modify the build process to add sound
13:57:55 <Big_G> What are your thoughts on development time in Haskell compared to other languages?
13:58:18 <quchen> I enjoy development time much more, that's all I can say objectively.
13:59:14 <quchen> Entering the gut-feeling-area, when writing/fixing tests in other languages I'd say at least 50% of them would be redundant given Haskell's type system.
14:00:11 <Big_G> quchen, Is that true for all languages or do languages like Java check some of that whereas languages like Python wouldn't?
14:00:39 <mauke> my gut feeling is that java's type system gets in the way more than it helps
14:01:17 <Big_G> I've defintiely had pains with it but why doesn't Haskell fall to the same things?
14:01:34 <benzrf> Big_G: because it has a much better type system
14:01:41 <quchen> There's an informal hierarchy of type system "strength". Python (and other languages like PHP, Ruby, Scheme) are typed, but readily convert between the types internally as they see fit. Java does more type checking, but to a *much* smaller extent than Haskell.
14:01:53 <mauke> because haskell doesn't have downcasts. or casts.
14:02:08 <mauke> so the type system really has to work, or you couldn't do anything
14:02:18 <benzrf> Big_G: two reasons Haskell isnt painful like java:
14:02:28 <benzrf> 1. type inference means you dont have to write nearly as much obvious stuff
14:02:35 <platz> I think it depends on the complexity of the problem you're trying to solve.  If you're staying in very well-trodden territory (i.e. crud, use existing libs), any type system will probably do.  It's when you want to build bigger and better things
14:02:45 <benzrf> 2. types are more powerful & prevent bugs more so they feel more worthwhile
14:02:45 <Big_G> mauke, What do I do if I have an int and want to make it decimal then?
14:02:52 <platz> at a higher level of abstraction and re-use
14:03:00 <mauke> Big_G: what do you mean by "decimal"?
14:03:04 <quchen> Java's optional is painful to use because of how generics work. A Java equivalent to Haskell's Either is unbearably verbose to the point it's not a very useful abstraction.
14:03:18 <mauke> Big_G: (I can think of 3 different meanings off the top of my head)
14:03:19 <platz> look at go - absolutely horrible type system.  they just give up on re-use and re-implement everything
14:03:20 <quchen> (Reason for the most part: no type inference)
14:03:23 <Big_G> mauke, I was thinking of floats or doubles in most languages
14:03:35 <mauke> Big_G: you use a function like fromIntegral
14:03:37 <voidzero> :t 1.2
14:03:37 <platz> i guess for some they don't see any problem with re-implementation
14:03:38 <lambdabot> Fractional a => a
14:03:56 <mauke> > fromIntegral (42 :: Int) :: Double
14:03:57 <lambdabot>  42.0
14:04:02 <voidzero> :t fromIntegral
14:04:03 <lambdabot> (Num b, Integral a) => a -> b
14:04:09 <Big_G> mauke, So there is a way to cast but not in the way most languages do it?
14:04:16 <mauke> Big_G: it's not a cast
14:04:28 <mauke> it's a normal library function
14:04:52 <quchen> Haskell's `fromIntegral` is a cast as much as C's `atoi` is one.
14:04:53 <Big_G> mauke, I didn't mean that it was a cast. It seems to have the same effect though, doesn't it?
14:05:18 <Big_G> quchen, That makes sense
14:06:23 <aisqwe> why does let gg= (++) <$> Just [1] work but let gg= fmap (++) Just [1,2] doesnt?
14:06:32 <quchen> You can view casts as special cases of conversion functions if you want. But casts usually require more information about your data, e.g. that they fit in the same memory.
14:07:02 <quchen> aisqwe: Parentheses.
14:07:03 <mauke> aisqwe: because (++) <$> Just [1] means (<$>) (++) (Just [1])
14:07:14 <quchen> fmap (++) Just [1,2] = (fmap (++) Just) [1,2]
14:08:00 <aisqwe> lol,right, thanks
14:12:21 * hackagebot gitson 0.5.0 - A document store library for Git + JSON.  http://hackage.haskell.org/package/gitson-0.5.0 (myfreeweb)
14:13:48 <Big_G> How are you able to use pm to play with the bot?
14:14:08 <pharaun>  /privmsg lambdabot <insert stuff here> ?
14:14:23 <Zoetrope_> Big_G: Just PM him stuff like @pl \f x -> f x x
14:14:35 <Big_G> @pl 2+2
14:14:35 <lambdabot> 4
14:14:37 <pharaun> ^ same
14:14:47 <Zoetrope_> @pl \f x -> f x x
14:14:47 <lambdabot> join
14:14:48 <Big_G> Does that come up in all of your feeds?
14:14:53 <pharaun> Big_G: now do /privmsg lambdabot @pl 2+2
14:15:07 <pharaun> Big_G: yes it does you're in channel, do what is said ^
14:15:14 <pharaun> to private message the bot
14:15:22 <Big_G> Awesome. Thanks all
14:22:22 * hackagebot acme-year 2015 - Get the current year  http://hackage.haskell.org/package/acme-year-2015 (JoeyAdams)
14:29:09 <Sonarpulse> ok busting out nm, ghc is making a lib with an undefined symbol for a function defined in the same module
14:29:11 <Sonarpulse> that seems bad
14:29:32 <Axman6> Someone's quite committed to this joke: http://hackage.haskell.org/package/acme-year-2015
14:30:01 <Sonarpulse> *defined in a module in the package being compiled, not a dependency
14:32:56 <apo_> nb4 kiwi crashes and burns
14:33:01 <apo_> ergh
14:34:18 <Sonarpulse> hmm might have been that I forgot to list some other-modules in cabal file
14:34:32 <Sonarpulse> is this intended?!?!?!
14:41:11 <agocorona> As a sign of the times, acme-year-2015 has no documentation generated in hackage.
14:54:21 <udevd> any alternatives to hmatrix? I think I've found a bug in passing arguments to LAPACK...
14:55:41 <peddie> udevd: the hmatrix maintainer has been super responsive when I've had questions or patches in the past; I suggest you contact him
14:55:51 <Rotaerk> there's the "linear" package
14:56:10 <Rotaerk> https://hackage.haskell.org/package/linear
14:56:23 <udevd> peddie: well okay, in the long term, but I want the code to work _right now_ :P
14:56:58 <peddie> aha, not sure there's an exact equivalent then :)  there is the numerical haskell project, but I'm not sure it's ready _right now_
14:57:14 <udevd> well ,_,
14:57:20 <Big_G> How is Haskell or machine learning and data science in terms of packages?
14:57:20 <peddie> what is the bug?
14:57:53 <udevd> well I'm doing random matrices stuff, and out of nowhere wild
14:57:53 <udevd>  ** On entry to ZGEHRD parameter number  2 had an illegal value
14:57:53 <udevd>  ** On entry to ZHSEQR parameter number  4 had an illegal value
14:57:55 <udevd> appears
14:58:00 <peddie> whuh-oh
14:58:06 <udevd> (these are fortran LAPACK functions)
14:58:15 <peddie> yeah
15:00:20 <peddie> udevd: sorry, I don't have time to go back into the hmatrix bindings right now . . . :/
15:00:46 <tomphreek> @src guard
15:00:46 <lambdabot> guard True  = return ()
15:00:47 <lambdabot> guard False = mzero
15:02:24 * hackagebot process-extras 0.3.1 - Process extras  http://hackage.haskell.org/package/process-extras-0.3.1 (DavidFox)
15:02:28 <udevd> or perhaps when i'm thinking of it
15:02:40 <udevd> it miiiiiiiight be 64bit contra 32 bit problem
15:02:45 <udevd> lapack is known of these
15:03:26 <peddie> udevd: what hmatrix function does this error occur in?
15:03:43 <udevd> peddie: eigenvalues
15:04:16 <udevd> i can try to extract exact matrix, but it's complicated and matrix is itself 16x16
15:05:41 <peddie> looks like both those errors are the same parameter mathematically
15:06:47 <udevd> yes, the upper triangular matrix
15:06:58 <udevd> it's nothing to do with haskell i guess
15:10:54 <wolftune> is there any reason to run "cabal install cabal-install" vs "cabal install cabal" ever? Like if I'm instructing someone, is there any reason for one of those versus the other?
15:11:39 <jedai> wolftune: Those are not the same
15:11:42 <toblerone> Anyone here know how I would go about running a new process with its stdin, and stdout set to a unix domain socket? I see that CreateProcess has a stdin and stdout field, but they have the type Handle. I've looked at socketToHandle, but it seems like using that prevents me from using the socket as a socket.
15:11:47 <wolftune> jedai: what's the difference?
15:11:50 <ClaudiusMaximus> wolftune: cabal-install is the program, Cabal is the library
15:11:56 <sdlfjsd> do where clauses in functions always get evaluated or only if they are used in the branch of the pattern match that is matched?
15:12:13 <jedai> wolftune: Cabal is the library that handles .cabal parsing
15:12:22 <wolftune> well, so if someone has an older 1.18 and we want to update, is it wrong to run the second?
15:12:30 <wolftune> we should have only run the first command?
15:12:57 <jedai> wolftune: cabal-install is an executable that manage installation of new packages (and building and so on), it uses Cabal the library
15:13:11 <jedai> wolftune: the first is the one you want
15:13:35 <wolftune> ok thanks
15:13:53 <jedai> wolftune: cabal-install will often pull a new version of Cabal but cabal-install (the installed one) will take care of this dependancy
15:14:12 <wolftune> hmm
15:14:30 <wolftune> so, running cabal install cabal-install will *include* building the cabal library?
15:14:39 <jedai> if needed yes
15:14:53 <wolftune> hmm ok
15:15:17 <jedai> note that cabal (the executable) comes with cabal-install (the package) not cabal (the package) which only contains Cabal (the library)
15:16:56 <hexagoxel> (the package containing the Cabal library is called "Cabal")
15:16:59 <jedai> wolftune: also note that cabal may install an executable in a directory that is not on the PATH (or too late) so check that you're seeing the new version of cabal after installing cabal-install
15:17:17 <wolftune> jedai: ok thanks
15:18:01 <jedai> hexagoxel: really ? That's a bit better I guess... Still a bit confusing (I know it's for historical reasons, I just think some renaming/reorganisation wouldn't go amiss)
15:18:08 <hexagoxel> and all this stuff gets asked so often, it really should be documented somewhere so we can just forward some link...
15:18:31 <jedai> hexagoxel: I'm sure it is, now we should document where it is documented
15:19:12 <jedai> @where Cabal
15:19:12 <lambdabot> http://www.haskell.org/cabal
15:19:31 <hexagoxel> https://hackage.haskell.org/package/cabal does 404, semantically
15:21:12 <jedai> Well the "How to install a cabal package" on the wiki linked in this cabal page tells one to use cabal-install but it's not extremely clear
15:21:29 <hexagoxel> indeed, i consider the lack of any mention of cabal vs Cabal vs cabal-install right on https://www.haskell.org/cabal/ a severe documentation bug.
15:21:53 <hexagoxel> faq does not mention it either..
15:21:54 <hexagoxel> grr
15:21:56 <wolftune> wait "cabal" is different from "Cabal" even??
15:22:24 <hpc> Cabal is the library, cabal is the utility
15:22:33 <Axman6> "cabal" is cabal-install, "Cabal" is the library
15:22:37 <creichert> cabal info Cabal | head
15:22:40 * Enigmagic sighs
15:22:42 <creichert> cabal info cabal-install | head
15:22:45 <creichert> might help clear it up
15:22:46 <hexagoxel> i think when you `cabal install cabal`, it will magically choose Cabal instead
15:23:01 <creichert> cabal install cabal-install will install Cabal as a dependency
15:23:20 <hexagoxel> creichert: "cabal: 'require-sandbox' is set to True, but no sandbox is present."
15:23:20 <creichert> cabal-install is the command line interface to cabal (i know that was just stated :))
15:23:51 <hexagoxel> clears up everything
15:24:23 <jedai> Nobody use Cabal to manually install packages anymore ? Right ? After all cabal-install now does all of that in a more sensible manner ?
15:25:05 <jedai> So would it really hurt to rename cabal-install to cabal and include the library ?
15:25:26 <creichert> yes, other programs use the CCabal library to interface with cabal files and haskell projects
15:25:27 <jedai> (keeping cabal-install as a dummy package for now I guess)
15:25:35 <creichert> cabal-install is a command line interface to Cabal, the library
15:25:56 <creichert> lots of different packages will use it, documentation, source code tagging, cabal-install
15:25:56 <jedai> creichert: ah true, so let's rename the package to cabal-library
15:26:29 <creichert> right. I will say that in haskell it is very common for the execeutable to be a very small program wrapping library calls
15:26:33 <creichert> idiomatic, really
15:26:48 <jedai> creichert: the main problem to me is that searching for cabal may bring you to Cabal when you're probably searching for cabal-install (if you're a gbeginner at least)
15:27:02 <matt2> i'm trying to create a form with yesod, and one of the type signatures in the book is Html -> MForm Handler (FormResult Car, Widget)
15:27:23 <matt2> where do i import HTML from? i can't get it to compile
15:28:17 <matt2> http://www.yesodweb.com/book/forms#forms_create_literal_aform_literal_s this is the particular example I'm following
15:28:42 <creichert> jedai: I can understand that, for sure
15:29:24 <creichert> matt2: try Text.Hamlet (shakespeare)
15:29:37 <matt2> alright i'll give it a shot
15:30:22 <creichert> np, there is also #yesod if you dive in :)))
15:31:02 <matt2> creichert: I tried that and got "Module Text.Hamlet does not export HTML"
15:31:14 <creichert> are you capitalizing all letters?
15:31:16 <creichert> it's Html
15:31:26 <matt2> creichert: derp
15:32:00 <matt2> creichert: turns out I pulled it in from Import the whole time, thanks
15:32:17 <creichert> nice, np
15:37:26 * hackagebot haskell-mpi 1.4.0 - Distributed parallel programming in Haskell using MPI.  http://hackage.haskell.org/package/haskell-mpi-1.4.0 (BerniePope)
15:37:56 <rom1504> > product [1..10000]
15:37:58 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
15:39:25 <Sornaensis> > [100..]
15:39:27 <lambdabot>  [100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118...
15:49:37 <ttt_fff> anyone here got vim + tagbar working for haskell? I am having problems finding a program to generate haskell tags
15:51:53 <Sornaensis> > [x^y | x <- [1..100], y <- [1..100]]
15:51:54 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:52:41 <unknownloner> wait what
15:52:43 <creichert> ttt_fff: I use codex. It inspects a cabal file and generates tags based on the dependencies and sources listed there
15:53:07 <creichert> ttt_fff: https://github.com/aloiscochard/codex
15:53:10 <ttt_fff> creichert: https://hackage.haskell.org/package/codex ?
15:53:14 <creichert> I don't use vim or tagbar though, sorry
15:53:17 <creichert> yea!
15:53:19 <ttt_fff> creichert: and this is hooked into vim?
15:53:20 <ttt_fff> oh
15:53:25 <creichert> you generate ctags
15:53:29 <ttt_fff> creichert: what do you use in emacs as an tagar algernative?
15:53:40 <ttt_fff> *tagbar alternative*
15:53:47 <benzrf> unknownloner
15:53:48 <creichert> autocomplete with Etags
15:54:12 <benzrf> unknownloner: the order is, all of y for first x, then all of y for second x, etc
15:54:20 <unknownloner> oh right
15:54:40 <benzrf> :t (**)
15:54:41 <lambdabot> Floating a => a -> a -> a
15:54:45 <benzrf> :t ^)
15:54:45 <lambdabot> parse error on input â€˜^â€™
15:54:46 <benzrf> :t (^)
15:54:48 <lambdabot> (Num a, Integral b) => a -> b -> a
15:54:50 <unknownloner> yeah I know what ^ does
15:54:55 <benzrf> no i was checking for myself
15:55:00 <unknownloner> oh :P
16:00:31 <augur> benzrf: ping
16:00:46 <benzrf> augur: pong
16:00:53 <augur> benzrf: want to forever understand yoneda? :)
16:01:12 <benzrf> augur do you follow me on twitter o.-
16:01:16 <augur> benzrf: of course!
16:01:21 <benzrf> wait, who are you
16:01:30 <augur> @psygnisfive
16:01:30 <lambdabot> Unknown command, try @list
16:01:32 <benzrf> oh
16:02:02 <augur> so, wanna grok yoneda? :)
16:03:25 <evenex> yes
16:04:39 <augur> evenex: ok, so you're up for some yoneda goodness. how bout you, benzrf?
16:11:58 <augur> noyo for benzrf :(
16:13:48 <evenex> augur: so, how to grok yoneda?
16:14:14 <augur> i want to wait until benzrf replies one way or the other :x
16:14:23 <evenex> fair enough
16:14:37 <augur> evenex: but ill teach you too, no fear! i just dont want to lose benzrf
16:14:52 <gfixler> I want to learn, too, but I need to go get a haircut
16:15:51 <augur> maybe i should write a tutorial then
16:17:59 <Hijiri> I want to yoneda with everyone
16:18:19 <Cale> Yoneda's lemma is really a sort of completion theorem for categories. Given any category C, even a possibly not very well-behaved one, you can embed it in a category which has all (small) limits, colimits, is Cartesian closed and locally Cartesian closed, is a topos, and lots of other nice stuff.
16:19:00 <Cale> and you do it in such a way that if there's an arrow in this new category between the images of two of the objects from your original category, then it must have come from an arrow in the original category
16:19:00 <augur> Cale: awful :x
16:19:18 <gfixler> well, now I understand yoneda
16:21:05 <johnw> Cale: was that meant as a joke?
16:21:22 <Cale> So it's like you can take any category, and fit it inside a category with all the widgets you could ever want, and you're free to use those widgets to prove things about the original category.
16:21:38 <Cale> johnw: hm?
16:21:45 <Cale> Did I mess something up? :)
16:21:51 <johnw> anyone who could understand that answer, wouldn't have the question
16:21:57 <evenex> wikipedia says if C is cartesian closed, any 2 objects X,Y in C have a product XxY in C; does that imply that C has infinitely many objects?
16:22:14 <Cale> johnw: I'm giving a way of thinking about Yoneda's lemma
16:22:30 <Cale> I haven't actually stated Yoneda's lemma, anyone can look that up :)
16:22:54 <Cale> evenex: Not necessarily. X x Y needn't be distinct from X and Y.
16:22:55 <johnw> well, I really couldn't follow you at all, and I think about Yoneda quite often
16:23:09 <Cale> johnw: Sets^(C^op) has a lot of nice properties
16:23:27 <augur> Cale: you're the reason the "what's the problem?" joke about monads exists. :|
16:23:46 <Cale> johnw: Yoneda's lemma as stated doesn't talk about all the nice properties that Sets^(C^op) has, but once you start looking into them, you begin to realise how nice a category it is.
16:25:21 <Cale> augur: I'd read the statement and proof of Yoneda's lemma several times in different places before I really got what it was *for*.
16:25:40 <augur> im sure you did.
16:26:08 <Cale> The information I'm providing is the not-obvious-from-most-presentations bit, though I think Awodey does an okay job of conveying this.
16:26:30 <mjrosenb> does anyone know about reactive-banana? I would like to get the current time, does this require hooking the time up as an input, or something more basic?
16:26:39 <benzrf> mjrosenb: i think so
16:26:44 <benzrf> mjrosenb: there may be lib functions for that
16:26:52 <sqed> I have a "cabal can't resolve dependencies" issue, but i'm in a clean sandbox and rm -rf'ed ~/.cabal and ~/.ghc
16:27:14 <benzrf> mjrosenb: but im like 90% sure that there is some package somewhere that supplies such a Behavior if the main package doesnt
16:27:17 <johnw> Cale: I will say, your perspective is quite nice, and I'll keep it in mind
16:27:26 <benzrf> mjrosenb: in the remaining 10% there /is/ poll
16:27:41 <johnw> Cale: but I think that while a category theorist would find it valuable, it doesn't really motavite why a Haskell programmer would be interested in learning Yoneda's lemma as it applies to Haskell functors
16:27:43 <mjrosenb> benzrf: ok, since it is like 3 lines to wripe my own
16:27:44 <geekosaur> sqed: but did you remove the sandbox's installed packages?
16:27:54 <mjrosenb> but it isn't a behavior, it is an event
16:28:01 <benzrf> mjrosenb: uh, what
16:28:02 <Cale> Oh, well, Yoneda's lemma doesn't do much for Haskell programmers, at least as far as I'm concerned.
16:28:09 <lpaste> glguy pasted â€œUsing Yonedaâ€ at http://lpaste.net/120171
16:28:10 <benzrf> mjrosenb: 90% sure that time is a behavior
16:28:16 <johnw> Yoneda's lemma has a few really useful properties for Haskell programmers
16:28:26 <benzrf> mjrosenb: unless you mean, like, a recurring event
16:28:31 <mjrosenb> benzrf: it is a timer that fires once a second, so I can update a clock
16:28:36 <Cale> Though I guess if you really formalised Hask and wanted to prove things about it, it might come in handy.
16:28:39 <johnw> one is using contravariant Yoneda to turn nearly anything that looks like it could have been a functor (say, a TVar) into a Functor
16:28:53 <glguy> Yoneda is nice for fusing fmaps for performance benefits
16:29:00 <johnw> fmap fusion is the main one, yes
16:29:06 <Cale> Yeah, but I think all of that stuff is easier to understand directly in terms of Haskell instead of in terms of Yoneda's lemma.
16:29:10 <johnw> also, proving CPS-transformation equivalence
16:29:24 <Cale> Like, you can call that thing the Yoneda embedding, but it's really not...
16:30:01 * mjrosenb currently understands events a whole lot better than behaviors
16:30:07 <mjrosenb> but they seem equally important.
16:30:15 <benzrf> mjrosenb: 1 sec
16:31:16 <sqed> geekosaur: yeah, I did cabal sandbox delete and init
16:31:31 <Cale> mjrosenb: An important thing about behaviours is that you can't tell when they change, so they can be computed on demand only, which allows you to do interesting things like having them effectively vary continuously.
16:31:42 <benzrf> mjrosenb: https://github.com/HeinrichApfelmus/reactive-banana/blob/07f3e9bf44ec8c227442daef723f7e9682c5a342/reactive-banana/doc/tutorial-2012-07-en.pdf?raw=true
16:32:03 <geekosaur> then more detail is needed. note that installing packages that shadow system-level packages may cause problems
16:32:03 <benzrf> ^v helpful
16:32:22 <mjrosenb> aargh, github, why do you not let pdf.js do its thing...
16:32:30 * hackagebot dotenv 0.1.0.3 - Loads environment variables from dotenv files  http://hackage.haskell.org/package/dotenv-0.1.0.3 (jsl)
16:32:35 <mjrosenb> Cale: right, which is why I currently have it as an event.
16:33:04 <Cale> Behaviours are the things which always have a value whenever you look at them, and may change infinitely often.
16:33:51 <zipper`> I am trying to run tests in my test/ with `cabal test` however the output is "Package has no test suite"
16:33:55 <Cale> (or even if they don't change infinitely often, the important thing is that there's no way for their user to tell)
16:34:16 <zipper`> Could someone help me show cabal where my test suite is?
16:34:21 <sqed> geekosaur: the package it's having trouble with is transformers (which my own package depends on but doesn't specify any version constraints for) -- wouldn't wiping ~/.cabal and ~/.ghc and using a fresh sandbox take care of it?
16:34:52 <Cale> I actually think that behaviours that actually vary continuously might not always be the greatest idea in real world cases, because such behaviours are always invalid as far as any mechanism of caching is concerned.
16:35:13 <geekosaur> sqed, no, transformers is bundled with ghc and in the system package directory
16:35:13 <zipper`> I had my tests import the modules in src/ I am not sure how it's supposed to do this.
16:35:31 <Cale> (so they're the really expensive ones which will show up in your profiles as using up all your CPU time)
16:35:34 <geekosaur> (there is ongoing discussion about whether this bundling can go away somehow in the future)
16:35:50 <gfixler> I hate to get all practical here, but what's the practical upshot of learning yoneda?
16:35:53 <geekosaur> ~/.ghc is the user package directory. the system one depends on where you got your ghc and how it was built
16:36:32 <sqed> I see
16:36:35 <gfixler> I'm trying not to dive too far down the academic rabbit hole - I've been trapped in it for quite some time now
16:36:36 <Cale> gfixler: Do you mean for nonmathematicians?
16:36:38 <geekosaur> sandboxes slot in place of the user package directory but at least currently there is no way to hide or avoid the system one
16:36:40 <gfixler> Cale: yes
16:36:46 <mjrosenb> so the mouse position is a behavior, but if you want to have a 90's JS-style mouse tail, you need to have /some/ sort of event to force the network to update itself, presumably a timer that fires on every bsync, or something like that?
16:36:47 <Cale> gfixler: Not a heck of a lot.
16:36:59 <gfixler> Cale: okay - I'll backlog it - thanks!
16:37:05 <Cale> gfixler: I think even the applications to Haskell are more easily understood directly.
16:37:06 <sqed> geekosaur: how can i get more information on/fix this issue?
16:37:18 <gfixler> Cale: I want to know everything, and that's my problem :)
16:37:30 * hackagebot origami 0.0.1 - An un-SYB framework for transforming heterogenous  data through folds  http://hackage.haskell.org/package/origami-0.0.1 (nedervold)
16:37:40 <Cale> gfixler: Like, you don't really need to understand Yoneda's lemma generally in order to understand the thing which came from stomping hard on it until it fit inside Haskell.
16:38:08 <Cale> The latter thing is easy enough to understand just by reading some code.
16:38:28 <gfixler> Cale: and probably easier to understand with some code under my belt?
16:38:30 <mpickering> it seems like there's a close connection between yoneda and plain ol' cps
16:38:57 <Cale> gfixler: Sure, if you're new to Haskell or functional programming, don't even bother with it.
16:39:33 <geekosaur> http://www.vex.net/~trebla/haskell/sicp.xhtml for more information. as to fixing it, not sure. I generally add "constraint: installed" for system packages so that other versions can't be installed and cabal will be forced to use versions of other things compatible with that global package
16:39:51 <zipper`> Is this cabal file enough for cabal to know where the tests are? If not what am I doing wrong?
16:39:53 <zipper`> https://gist.github.com/urbanslug/f058fae923eff5f53267
16:40:10 <gfixler> Cale: new enough - been playing in Haskell for about a year, but not aggressively, and I move slowly
16:40:33 <Cale> So here's the Haskell definition: newtype Yoneda f a = Yoneda { runYoneda :: forall b. (a -> b) -> f b }
16:41:10 <lpaste> geekosaur pasted â€œcabal-lock-global.shâ€ at http://lpaste.net/120173
16:41:14 <gfixler> all bs come fromo as through f?
16:41:21 <mpickering> zipper`: You need a seperate test section
16:41:23 <Cale> For any type constructor f, this thing is a functor, because you can always compose another function with the argument of the one that's being wrapped up.
16:41:26 <mpickering> https://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
16:41:28 <mpickering> there are examples there
16:41:48 <geekosaur> sqed: see above paste for a script that can "lock" your global packages to avoid reinstalls that cause conflicts
16:42:04 <sqed> geekosaur: I'll take a look at those; thanks!
16:42:06 <Cale> gfixler: So you get this super cheesy way of defining fmap
16:42:16 <gfixler> yeah, looks like fmap, sorta
16:42:31 * hackagebot iso8601-time 0.1.3 - Convert to/from the ISO 8601 time format  http://hackage.haskell.org/package/iso8601-time-0.1.3 (NiklasHambuechen)
16:42:51 <gfixler> alright - haircut time, bbl
16:43:45 <zipper`> mpickering: Thanks on it.
16:44:04 <geekosaur> (I should add a -u/--unlock option to that and publish it...)
16:45:02 <evenex> i still don't understand yoneda. i was promised to understand yoneda :(
16:45:54 <Cale> evenex: Did you want to understand the one in category theory, or just the highly-specialised-to-the-point-it's-almost-unrecognisable version in Haskell?
16:45:59 <evenex> category theory
16:46:10 <zipper`> mpickering: Shouldn't it automatically find modules in test/ ? In this case it can't find my main test module.
16:46:24 <Cale> evenex: Okay, so you're familiar with natural transformations?
16:46:30 <Cale> and functors?
16:46:39 <mpickering> zipper`: What command are you running?
16:46:47 <zipper`> mpickering: cabal test
16:46:56 <mjrosenb> benzrf: (<@) :: Behavior b -> Event a -> Event b, shouldn't that be Event (a,b), or something similar?
16:46:57 <dfogi> does a type have to be an instance of some typeclass in order to be used in HashSet?
16:47:03 <evenex> i think so. i'm not totally confident, but i would say a tentative yes
16:47:31 <mjrosenb> oh, I guess it just completely discards the value of the event, and just uses the time of it?
16:47:32 <Axman6> dfogi: what does the type of insert for HashSet say?
16:47:35 <evenex> a natural transformation is a functor of functors, unless there's an extra piece i'm missing
16:47:43 <zipper`> mjrosenb: I have edited my cabal file https://gist.github.com/urbanslug/f058fae923eff5f53267
16:47:47 <Cale> uh, sort of
16:47:52 <zipper`> mpickering: I have edited my cabal file https://gist.github.com/urbanslug/f058fae923eff5f53267
16:47:54 <Axman6> @hoogle HashSet
16:47:56 <lambdabot> No results found
16:48:02 <benzrf> mjrosenb: that's (<@>)
16:48:14 <benzrf> mjrosenb: (<*) vs (<*>)
16:48:27 <Cale> dfogi: Hashable
16:48:39 <dfogi> ah ok
16:48:51 <Cale> evenex: So, let's do something a little simpler than what Yoneda does, but not entirely unrelated
16:48:54 <dfogi> is there a way to specify a class restriction for a type parameter?
16:49:12 <Axman6> what do you mean?
16:49:15 <mjrosenb> benzrf: ok, so (<@) just ignores the actual value from the event.
16:49:27 <dfogi> like data :: Hashable a => HashSet a
16:49:28 <Cale> evenex: You can turn every category into a concrete category, i.e. one whose objects correspond to sets, and whose arrows correspond to functions between those sets
16:49:29 <dfogi> or seomthing
16:49:42 <Axman6> foo :: (Hashable a) => a -> HashSet a
16:49:51 <Axman6> the a must be Hashable
16:50:03 <dfogi> cause for HashSet type the paramter is just a - but insert has to be Hashable
16:50:30 <Axman6> dfogi: that says that data can be a HashSet of _any_ type a, is that really what you want?
16:50:49 <sqed> geekosaur: i'm getting "mktemp: too few X's in template â€˜cfgâ€™" when I run your script
16:50:53 <dfogi> Axman6: can I restrict a type parameter by a TypeClass
16:50:59 <evenex> Cale: ok, with you so far
16:51:14 <Cale> evenex: Sorry, I should say small category. The way you do this is to associate to each object X, the set of arrows {f | T in C, f : T -> X}
16:51:19 <sqed> I also tried adding constraint "transformers installed" but still get the same error. here's the cabal error: http://lpaste.net/120174
16:51:22 <geekosaur> sigh, figures. probably need a different number on different OSes/distributions
16:51:34 <Cale> i.e. all the arrows which end up in X, from all the various other objects in the category
16:51:41 <geekosaur> oh, yes, that's right, BSD doesn't want any, Linux requires them :/
16:51:41 <dfogi> Axman6: something like 'data T a = '...' - where a must be an instance of 'Show'
16:52:02 <glguy> sqed: You need to use transformers-compat-0.3.3.3 with transformers-0.3
16:52:07 <geekosaur> so you'll need to edit to change mktemp -t cfg to mktemp -t cfgXXXXXXXX
16:52:20 <geekosaur> and I'll have to deal with that too before making a public release
16:52:21 <glguy> sqed: If that's what you're trying to use, install transformers-compat manually and try again
16:52:26 <Cale> and then you associate the arrow g: X -> Y with the function that sends an arrow T -> X to an arrow T -> Y by composition with g.
16:52:36 <Cale> Make sense?
16:52:42 <sqed> glguy: i'll try that
16:53:16 <Cale> So that defines a function from the set we associated to X to the set we associated to Y.
16:53:36 <Axman6> dfogi: you can do that, but you don't want to, it;s always a bad idea
16:53:40 <dfogi> is there a way to specify a type parameter must be an instance of some typeclass when using the 'data' keyword?
16:53:43 <evenex> Cale: so, this is just ordinary function composition, so far?
16:53:59 <Cale> evenex: it's composition in our abstract category
16:54:02 <dfogi> Axman6: whats the syntax for it?
16:54:29 <Cale> evenex: The composition in our category might not be function composition, it could be any old operation so long as it satisfies the category axioms
16:54:34 <Axman6> dfogi: it;s data T a = Foo a => T a a, for example, but you really don't want to do that
16:54:37 <Cale> evenex: and the arrows might not be functions
16:55:03 <Cale> evenex: But what we're doing here is associating a collection of sets with the objects of our category, and functions between those sets with the arrows
16:55:26 * geekosaur has commented his copy so he knows what needs fixing,,,
16:55:48 <Cale> evenex: So as to basically show that even if the category wasn't originally made up of sets and functions, we can find one which is isomorphic to it, and which is.
16:56:02 <Axman6> the reason is that the type class infects all your code, even when the constraint isn't relevant to the function
16:56:03 <sqed> glguy: so I'm getting this now: http://lpaste.net/120175 -- does this mean mtl needs transformers 0.3 but i have transformers 0.4 because i've installed transformers-compat 0.4?
16:56:11 <Cale> (I haven't said anything about this new category we've defined really being isomorphic, but it is)
16:56:30 <evenex> Cale: ok, so we start with the set of all arrows f to X (calling the codomain of any the arrows T), and we compose it with an arrow g: X -> Y, and all of the composed f.g form all of the arrows T -> Y?
16:56:34 <glguy> sqed: You'll need to use mtl-2.1.3.1 with transformers-0.3
16:56:47 <Cale> the domain of the arrows being T
16:57:03 <Cale> and it might only give some of the arrows T -> Y
16:57:28 <Cale> but that's okay, because we're just defining a function from (the set of arrows to X) to (the set of arrows to Y)
16:57:37 <evenex> Cale: sorry, yes, i misspoke. domain, not codomain
16:57:53 <evenex> Cale: oh, i see. so we're taking the arrows T -> Y which go through X
16:58:04 <Cale> yeah
16:58:07 <glguy> sqed: What're you trying to install?
16:58:41 <sqed> glguy: just the dependencies for a program i'm writing
16:59:02 <cmccann> so I've been awake for like 30 hours and I just spent about four hours straight refactoring some Haskell code, between horrific sleep-deprivation typos and generally making major changes the code was nowhere close to building the whole time
16:59:10 <Cale> So, while it can be shown that this construction gives us a concrete category, this all isn't terribly useful, because while sure, it lets us technically work with sets, there are many other functions between those sets which don't correspond to arrows in our original category
16:59:12 <sqed> it worked before, but then i tried to use a local copy of network-bitcoin (`cabal sandbox add-source /path/to/network-bitcoin`)
16:59:17 <cmccann> after finishing and getting it to build successfully, it works exactly like it did four hours ago
16:59:55 <cmccann> this is why I like Haskell, if I did this sort of thing in C# it would have just made a gigantic mess
17:00:10 <sqed> and installing with that hasn't worked. It's the same version as the one on hackage with some small changes
17:01:03 <Cale> evenex: What Yoneda does is to refine this construction, partitioning the sets we used to represent each object
17:01:17 <evenex> Cale: when you say that this construction gives us a concrete category, you mean all the T with X and Y and the arrows from T through X to Y form a category?
17:01:18 <Cale> We sort of lumped all the arrows T -> X together into one set
17:02:07 <Cale> Oh, I mean, what we're doing is finding a subcategory of the category of sets and functions which is isomorphic to our chosen category
17:03:05 <Cale> Or to say the same thing another way: finding a faithful functor C -> Set
17:04:23 <zipper`> I am getting a weird error from HUnit. It seems HUnit itself has an issue. https://gist.github.com/urbanslug/8ff3b7a7926a0a41f05d
17:04:35 <Cale> We send each object X to the set |X| of arrows with codomain X, and we send each arrow f: X -> Y to a function |X| -> |Y| which acts by composition with f
17:04:51 <zipper`> The error is "Could not find module â€˜Distribution.Simple.Test.LibV09â€™"
17:04:59 <Cale> evenex: good?
17:05:48 <zipper`> Has Hunit been broken for a while now? and if so what have you people been using?
17:06:22 <Cale> evenex: No two distinct arrows f,g: X -> Y will be sent to the same function, because they have to act differently on, e.g. id: X -> X, which is an element of |X|
17:08:26 <Cale> evenex: and we can show that this really is a functor if you like, i.e. that |id_X| = id_|X| and that |f . g| = |f| . |g|, where I'm using |f| as notation for the function |X| -> |Y| that we defined by composition
17:09:26 <sqed> glguy: i think i just got it to work; I had to install my local package first
17:09:58 <sqed> I guess cabal didn't backtrack far enough
17:10:01 <Cale> evenex: In any case, once you understand this, Yoneda's embedding is a sort of refinement of this. It's sort of ugly that we've gone and lumped all the arrows from different domains T into the same set, and we can do better to preserve more structure of what's going on.
17:10:40 <evenex> Cale: "partitioning the sets that we use to represent each object" - each object X is associated with a set, being the set of arrows with codomain X... and each arrow f:X -> Y is associated with the function that maps from the set of arrows with codomain X to the set of arrows with codomain Y?
17:11:34 <Cale> Yeah, the comment about partitioning has to do with the next step toward Yoneda's lemma
17:12:33 <Cale> Instead of associating each object X in C with a set |X|, it associates it with a functor yX: C^op -> Set
17:13:23 <Cale> You can picture a functor C^op -> Set as being a sort of fancy array of sets, one for each object of C
17:14:40 <Cale> But it has even more information than that, because it tells you how to turn arrows T -> U in C, into arrows in the opposite direction between the corresponding sets.
17:16:33 <evenex> Cale: why opposite?
17:17:51 <Cale> and where that information comes from is that, say, (yX)T will be the set of arrows T -> X in C, and so if we have a function g: T -> U, then we get a function (yX)U -> (yX)T, because we can turn an arrow f: U -> X into the arrow f . g: T -> X
17:18:03 <Cale> So this is composition on the other side now
17:21:17 <sqed> haskell builds take sooo long
17:22:34 * hackagebot dotenv 0.1.0.4 - Loads environment variables from dotenv files  http://hackage.haskell.org/package/dotenv-0.1.0.4 (jsl)
17:22:47 <Cale> evenex: and what's more y is also a functor, so we get to turn arrows X -> Y in C, into natural transformations yX -> yY in C^op -> Set (rather similarly to how we turned them into functions between sets in the original easy construction)
17:23:09 <Cale> It's just now we're preserving all the information about what the domains of the arrows are
17:24:56 <Cale> rather than lumping all the arrows together into a set, we're using Set-valued functors to keep the arrows with different domains separate, and instead of functions between sets, we now have natural transformations between Set valued functors (which are effectively families of functions, one for each choice of domain object T of C)
17:27:44 <evenex> Cale: getting a little lost. trying to follow, here's where i'm at so far: https://drive.google.com/file/d/0B_jkaR__TvcCZTZMaG5wZHVTWWc/view?usp=sharing
17:28:35 <evenex> still in the concrete category
17:31:11 <Cale> evenex: Yeah, so for that h, if we have one of those, and we have a map U -> X (which isn't in your diagram yet), then we could get a map T -> X, by composing, yeah?
17:31:37 <evenex> yes
17:32:27 <Cale> So we'll have turned an arrow h: T -> U, into a way of mapping arrows U -> X to arrows T -> X, i.e. from (yX)U to (yX)T
17:36:41 <augur> benzrf, evenex, gfixler: here, i wrote you a blog post. lemme know if you have any questions http://languagengine.co/blog/grokking-yoneda
17:37:09 <evenex> so I'm using T -> U as a way for getting from U -> X to T -> X? sort of like composition but... indirect?
17:37:16 <benzrf> oh geez
17:37:23 <augur> gotta fix that stupid tweet embed :x
17:37:55 <Cale> evenex: It's exactly composition, it's just composition on the other side
17:38:29 <benzrf> oh augur
17:38:30 <benzrf> no
17:38:36 <benzrf> i meant
17:38:52 <benzrf> grok generally the categorical yoneda lemma
17:39:02 <augur> same thing tho :)
17:39:10 <benzrf> like i understand why it's true, i just havent fully internalized its 'meaning'
17:39:25 <augur> benzrf: yes, the meaning is basically what i talk about!
17:40:14 <Cale> evenex: So, what Yoneda's lemma says is that this embedding of C into the category of functors C^op -> Sets, is full and faithful, i.e. that any natural transformation between yX and yY corresponds to some arrow f: X -> Y, and that no two distinct arrows f,g: X -> Y get sent to the same natural transformation.
17:41:35 <evenex> Cale: i see what you're saying i just can't quite form it explicitly... instead of composition A -> B . B -> C => A -> C, i've got B -> C * A -> B => A -> C??
17:41:51 <evenex> is that more like it?
17:42:02 <Cale> yeah, actually that latter one is the usual order of composition
17:42:17 <Cale> But it's just two ways of thinking of the same composition really
17:42:50 <Cale> If you have f: B -> C and g: A -> B, you can compose them to get f . g: A -> C, but you can think of this as something you've done to g
17:42:56 <Cale> or you can think of it as something you've done to f
17:45:35 <evenex> oh i see. so if i think of it as something i've done to f, and turn that into a little machine, i can apply it to any h: B -> C and get an A -> C... its like... a unary function composition template
17:45:52 <Cale> evenex: yeah
17:46:48 <zq> do people use machines?
17:47:00 <zq> the hackage package, not the generic noun
17:47:07 <Cale> evenex: Or Haskell section notation: (f .) g and (. g) f are the same thing, but understood differently :)
17:49:00 <evenex> gotcha. ok. so, the function (yX)U -> (yX)T is exactly this transformation
17:49:22 <evenex> the compositor
17:49:30 <orzo> what's an appropriate type class for "can be compared with an integer" ?
17:53:04 <mpickering> orzo: maybe you just want a function which casts your value to an integer and then compares it?
17:56:58 <orzo> i'm going with Fractional + Ord, an integer can be promoted to the type using fromRational (x % 1)
17:57:36 * hackagebot dotenv 0.1.0.5 - Loads environment variables from dotenv files  http://hackage.haskell.org/package/dotenv-0.1.0.5 (jsl)
17:57:56 <orzo> % is a bizarre operagtor for consgtrucgting a Ratio
17:58:02 <EvanR> orzo: makes sense
17:58:04 <orzo> it's usually modulo
17:58:22 <EvanR> anything that can be compared and an integer can be embedded into
18:00:43 <EvanR> :t fromIntegral
18:00:44 <lambdabot> (Num b, Integral a) => a -> b
18:01:03 <EvanR> orzo: so maybe Integral
18:01:36 <EvanR> actually, Num
18:01:47 <EvanR> :t fromInteger
18:01:48 <lambdabot> Num a => Integer -> a
18:01:52 <EvanR> orzo: NUm ;)
18:01:56 <orzo> ah
18:02:08 <orzo> well since asking i've realized i actually want fractions
18:02:16 <Cale> orzo: % sort of looks like a fraction
18:02:38 <Cale> So I don't think it's too inappropriate
18:02:49 <julianleviston> how are fractions semantically different from ratios?
18:03:02 <Cale> julianleviston: they are not
18:03:39 <orzo> well i disagree about %
18:03:42 <EvanR> well maybe youd call sqrt 2 a fractional number because it isnt whole, but its not rational
18:03:45 <orzo> i'm very likely to think modulo
18:03:52 <orzo> and forget about the less common Ratio use
18:03:58 <glguy> That'll pass
18:04:20 <orzo> i've been doing haskell for years now
18:04:21 <EvanR> when i see % in another language i think "i wish i had divMod"
18:04:25 <orzo> i haven't used Ratio much at all
18:04:32 <orzo> so it's debatable that it'll pass
18:04:45 <EvanR> Rational is a little weird in practice
18:05:24 <Big_G> Is there a prefered Haskell editor?
18:05:33 <glguy> no
18:05:56 <orzo> vim or emacs is probably typical
18:06:06 <bananagram> sublime is good too
18:06:56 <Big_G> Thanks. I use vim but it can definitely be unwieldy at times. Especially if it doesn't predict errors properly
18:07:14 <orzo> i used vim
18:07:24 <augur> is there a way to use parsec to parse ambiguous grammars?
18:07:51 <Cale> augur: try
18:08:23 <orzo> hard to imagine a vim user switching for haskell
18:08:25 <augur> Cale: no no i mean i want to get all the possible parses, not just one
18:09:30 <orzo> do you have the source to the parec parser?
18:09:32 <Cale> augur: hmm, sadly I don't think so
18:09:39 <orzo> maybe redifine <|>
18:10:15 <enthropy> uu-parsinglib can do it (look for amb)
18:10:17 <augur> Cale: shame :(
18:10:24 <augur> enthropy: ill give it a look, thanks :)
18:11:39 <Cale> ReadP can as well, though if you're doing something really serious, might not have everything you want.
18:12:17 <Cale> (it's quite good for quick parsers on the small end of things -- I often use it over Parsec just because it has a fair choice operator)
18:15:58 <EvanR> hmm so i cant make an instance for [Float] or [Char] without flexible instances. is there some downside to using flexible instances?
18:17:37 * hackagebot ports-tools 0.0.1 - Library to interact with port tools on FreeBSD  http://hackage.haskell.org/package/ports-tools-0.0.1 (ppenzin)
18:17:58 <jle`> flexible instances is considered one of the less harmful extensions
18:18:10 <jle`> almost all typeclass-based abstractions in modern haskell requires it
18:18:36 <enthropy> people take some kind of pride in avoiding extensions
18:18:47 <jle`> when i started haskell i was a bit weird about using extensions too
18:18:52 <jle`> i felt like i wasn't writing real haskell
18:19:41 <jle`> nowadays i don't really mind using tuple sections etc. because there isn't really a conceivable practical situation i could think of where it would bite me
18:19:47 <EvanR> neither of these things is true in my case, i have two other issues. one is that i have a hard time understanding exactly what the extension even does, and the other is i dont know if im missing some obvious way to do something without the extension, or just a better way to look at the whole thing
18:19:55 <jle`> ah i see
18:20:24 <afp1a>   /j #freebsd
18:21:06 <EvanR> instances for type String for instance might seem like an obvious thing you want to do, but i bet a lot of new programmers would miss an opporunity to implement it for any list
18:21:21 <EvanR> because it doesnt actually depend on Chars
18:21:27 * EvanR waves hands about examples
18:21:44 <orzo> i don't think there's much downside to flexible instances or flexible contexts
18:22:35 <EvanR> how flexible are flexible instances?
18:22:45 <orzo> overlapping instances and UndecidableInstances have down sides
18:23:00 <orzo> and
18:23:01 <orzo> IncoherentInstances
18:23:41 <EvanR> all i know is what the ghc error says, that you can avoid the rule that the instance be defined for A b c d etc
18:23:54 <EvanR> but to what extent
18:24:16 <orzo> well it lets you do things like declare an instance for (f a)
18:24:32 <EvanR> f a?
18:24:56 <dolio> It's possible (in GHC, at least) to write things that will be inferred to have types that would require flexible contexts if you wrote them down.
18:25:07 <orzo> dolio: that's going to break
18:25:14 <orzo> next ghc will not do that
18:25:17 <dolio> Right.
18:25:28 <dolio> Well, it will infer them, and then give you errors.
18:26:09 <EvanR> whats an example of that?
18:26:18 <orzo> itll probably break a bunch of code
18:26:19 <orzo> heh
18:27:00 <dolio> :t put (5 :: Int)
18:27:01 <lambdabot> MonadState Int m => m ()
18:27:03 <orzo> EvanR: a typically ghc infers something requiring forall
18:27:29 <orzo> and pasting the infered type into the file wil cause you to have to add a language pragma
18:27:37 * hackagebot midi-util 0.1 - Utility functions for processing MIDI files  http://hackage.haskell.org/package/midi-util-0.1 (mtolly)
18:28:19 <orzo> that used to happen to me all the time
18:28:28 <orzo> that's why i suspect it will break a bunch of code
18:28:49 <EvanR> flexible contexts
18:33:33 <brandon`> what would be the easiest way to 1) load jpeg to memory 2) get access to each pixel's RGB value?
18:33:58 <EvanR> maybe juicy pixels
18:34:21 <jle`> juicy pixels is my go-to solution for that stuff
18:34:37 <jle`> the interface is straightforward too
18:34:48 <brandon`> cool thanks.. I'll install it
18:40:36 <pacak> Suppose I have an ADT with
18:44:05 <pacak> I have an ADT with a whole bunch of fields, one of them being defined with ExistentialQuantification:
18:44:06 <pacak> data A => forall f. (Typeable f) => A f
18:44:06 <pacak> this field is not used at all, and this datatype is sitting inside a MonadReader, though it gets updated every once in a while. If I remove this field that loop it's updated in starts running about 10% slower. Any suggestions where to look at at?
18:44:17 <pacak> (there are more fields after f)
18:44:41 <nSaibawt> scrape it all, and build a regex for html
18:47:20 <hae> So if the point-free version of id is id, how do you define the point-free version of id?
18:47:34 <jle`> hae: you mean define id in point-free style?
18:48:09 <hae> Yes.
18:48:17 <mjrosenb> sanity check for reactive-banana (may be more general):
18:48:23 <EvanR> pacak: if you remove a field thats getting updating in a loop, im surprised it runs at all
18:48:29 <hae> I used "version" one too many times.
18:48:54 <mjrosenb> If I want to do something based on one of N inputs, I need to merge the N events into one, then possibly pull them apart later, yes?
18:49:17 <pacak> EvanR: That field is not used, others - are.
18:49:17 <jle`> :t ap const ()
18:49:18 <lambdabot>     Couldn't match expected type â€˜a -> b0â€™ with actual type â€˜()â€™
18:49:18 <lambdabot>     In the second argument of â€˜apâ€™, namely â€˜()â€™
18:49:18 <lambdabot>     In the expression: ap const ()
18:49:32 <jle`> er
18:49:34 <jle`> :t ap const const
18:49:35 <lambdabot> a -> a
18:49:36 <EvanR> pacak: put the unused field back
18:49:45 <EvanR> should fix it
18:49:47 <jle`> > let id = ap const const in map id [1..10]
18:49:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
18:50:36 <hae> Ah, interesting.
18:50:47 <jle`> hae: http://en.wikipedia.org/wiki/SKI_combinator_calculus
18:51:38 <jle`> mjrosenb: that sounds sane when talking about the general case, but if you had a specific example you might be able to do things differently
18:51:40 <pacak> EvanR: Indeed it fixes it (there are about 1000 times less stack overflows when it's in), but it seems like a bug in ghc to me and  it would be nice to have it fixed.
18:51:51 <hae> So the only two fundamental functions are ap and const?
18:52:16 <EvanR> pacak: if youre worry about 10% performance you might not want to be updating fields of a huge record in a loop
18:52:38 <mjrosenb> jle`: you mean turning one of the events into a behavior, then polling that behavior?
18:53:56 <csd_> Hi -- do any of you know whether the exercism.io problems get into monads?
18:53:57 <pacak> EvanR: Actually I worry even about 1% performance, and yes, I'd like to keep updating all the fields.
18:54:40 <Welkin> csd_: try building a real applicatio rather than doing exercises
18:55:01 <Welkin> it's more fun and helpful
18:55:01 <csd_> i dont feel like my base is strong enough yet
18:55:01 <brandon`> trying to use Juicy Pixels for the first time. I loaded image into memory with BS.readFile. I decoded it with decodeJpeg function. now I have DynamicImage, am I suppose to convert that to Image (if I want to inspect it) and MutableImage (if I want to change the pixels as well) somehow?
18:55:10 <Welkin> like writing an irc bot or a small web app
18:58:12 <sccrstud92> hi everyone
18:58:44 <biscarch> csd_: I just started doing those. Haven't come across something which is specifically about monads yet
18:59:44 <EvanR> brandon`: well, you dont necessarily need a mutable image in order to operation on an image
19:00:56 <hiptobecubic> Anyone around that has worked with the HDF5 file format? I've used it quite a bit, but never from Haskell.
19:01:43 <hiptobecubic> It looks like no one has made anything higher level than just a direct wrapping of the C api
19:02:04 <Welkin> hiptobecubic: that's usually best
19:02:17 <hiptobecubic> "usually" how?
19:02:35 <brandon`> EvanR yeah if I just want to inspect the pixels without changing them I should convert it to Image?
19:02:35 <Welkin> you can use the C API docs for it
19:02:42 <EvanR> brandon`: it seems to be structured such that you create a new image from an old one
19:02:49 <hiptobecubic> Python has two pretty solid libraries on top of hdf5 that are beautiful to use, for example.
19:02:54 <Welkin> if it changes, it is easy to update the bindings
19:03:15 <EvanR> brandon`: yeah if you want to read the image you need to know the pixel format, thats what the process of Dynamic -> Not Dynamic is supposed to prove
19:03:51 <Rotaerk> http://lpaste.net/120181  could anyone help with this HXT error?
19:04:16 <Rotaerk> it's giving an error suggesting that <attribute> doesn't exist, but it does ...
19:05:29 <seafood> Anyone know anything about ARM aarch64 support for GHC on iOS?
19:05:39 <seafood> Iâ€™m wondering which version of LLVM people have used.
19:05:50 <Rotaerk> I also tried replacing line 31 with:  xpElemNS meshNamespace "" "attribute" $
19:06:03 <Rotaerk> it still didn't find it...
19:07:40 * hackagebot up-grade 0.0.1 - Software management tool  http://hackage.haskell.org/package/up-grade-0.0.1 (ppenzin)
19:08:59 <refefer> this a good place to ask beginner questions?
19:09:23 <Welkin> refefer: yes, but there is also #haskell-beginners
19:09:33 <refefer> lovely, I'll head over there first then
19:09:34 <refefer> thanks
19:09:35 <Welkin> this is a more general channel
19:09:54 <gfixler> this is a no-limits channel
19:10:14 <Scriptonaut> oh cool I didn't know about #haskell-beginners
19:10:22 <Scriptonaut> that's probably where I should be
19:10:38 <EvanR> the unattainable is unknown
19:10:40 <EvanR> at #haskell
19:11:17 <peddie> @faq can #haskell know the unattainable?
19:11:17 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:11:20 <peddie> damn
19:11:37 <peddie> the faq changed
19:13:22 <orbisvicis> I want to use a complicated sorting function ((a -> a -> Ordering) -> D a -> D a) inside an M do-block, unfortunately the comparison function has side effects, it is (a -> a -> M Ordering). I was suggested to flatten to list then use mapM to extract the items/keys(<-sideeffect), but that means I can no longer use the sorting function anymore
19:15:03 <orbisvicis> is there any other approach ?
19:16:05 <Clint> that's pretty weird
19:16:25 <brandon`> orbisvicis can you describe what side effects does the comparison function perform?
19:16:48 <brandon`> perhaps you can do them before you start sorting
19:17:07 <Rotaerk> hmm... ah; I think the whitespace was throwing it off
19:17:13 <Rotaerk> had to add withRemoveWS to my config list
19:18:26 <orbisvicis> brandon`: the data is from xmonad, a zipper of windows, the sideeffect is getting the window name (sorting key) which queries X11 environment, the sorting function is sortByZ
19:19:42 <brandon`> orbisvicis something like this would work: names <- mapM getWindowName windows; sort cmp (zip names windows)
19:20:17 <sdegutis> As for Haskell-ish -> JS languages, what do you think of Purescript?
19:20:17 <EvanR> yeah get all the names then sort them
19:20:30 <Welkin> sdegutis: it's nice
19:20:50 <Welkin> purescript is a direct mapping to human-readable javascript
19:21:43 <sdegutis> That's what I mostly like about it -- no runtime dependence on Haskell, in fact no runtime
19:23:27 <orbisvicis> brandon`: unless I'm misunderstanding, that's what I was trying to avoid, deconstructing/reconstructing the zipper
19:25:50 <Scriptonaut> hey guys I have: let (Just action) = lookup cmd dispatch. How can I pattern match to catch anything that doesn't fit that?
19:25:52 <brandon`> orbisvicis sorry I missed that part. but I am not sure I t quite get why you want to avoid doing that, and why you would need to flatten the list first.
19:26:27 <geekosaur> Scriptonaut, don't use let, use case
19:26:45 <geekosaur> case lookup cmd dispatch of { Just action -> ...; Nothing -> ... }
19:26:51 <Scriptonaut> ah, that's a good idea
19:26:57 <Scriptonaut> out of curiosity, is there any other way?
19:27:08 <Clint> :t maybe
19:27:08 <Scriptonaut> I'll do it the case way, but I want to learn every place that pattern matching can happen
19:27:09 <lambdabot> b -> (a -> b) -> Maybe a -> b
19:27:09 <Welkin> Scriptonaut: all pattern matching is coverted to case ... of ...
19:27:16 <Scriptonaut> oh that's right
19:27:19 <Welkin> converted*
19:27:41 * hackagebot purescript 0.6.6 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.6 (PhilFreeman)
19:30:13 <orbisvicis> brandon`: heh, actually just found mapZM, which maps across a zipper
19:31:01 <Welkin> @hoogle mapZM
19:31:03 <lambdabot> No results found
19:33:39 <Scriptonaut> does anyone know why this case isn't working: https://gist.github.com/robins35/0b43d71403781d180a76
19:33:45 <EvanR> the package spool contains the necessary leet hax to convert from ByteString to storable Vector of Word8 and back without copying the data. thats great. but what if i want to convert them in a more acceptable way even if it involves copying
19:34:15 <Scriptonaut> the error is: Couldn't match expected type '[String] -> IO ())' with actual type 'Maybe ([String] -> IO ())'
19:34:24 <Scriptonaut> on lin e4
19:34:36 <kadoban> EvanR: "more acceptable" in what way?
19:34:44 <Welkin> :t lookup
19:34:46 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
19:34:51 <Axman6> Scriptonaut: you're going to need to share more code and types for anyone to be able to help you
19:34:57 <Welkin> lookup produces Maybe b
19:35:07 <Scriptonaut> hey Axman6 you're always in #rubyonrails arne't you
19:35:13 <Scriptonaut> or was that #macosx
19:35:14 <Axman6> no, never
19:35:19 <Welkin> oh
19:35:20 <Axman6> #MacOSX yes
19:35:24 <Scriptonaut> that's where I've seen you
19:35:27 <EvanR> kadoban: something that doesnt say in its documentation "this is a hack, it might not work next week" ?
19:35:35 <Welkin> data Maybe a = Nothing | Just a
19:35:38 <Welkin> you have to match on Nothing
19:35:49 <Scriptonaut> can't I just match on a variable x?
19:35:52 <Scriptonaut> where x == Nothing
19:35:55 <Welkin> no
19:36:01 <Scriptonaut> I would do _, but I want to be able to reference the value
19:36:05 <Scriptonaut> I guess I could hardcode Nothing
19:36:12 <Scriptonaut> or maybe id works here
19:36:12 <Welkin> x is not a constructor
19:36:15 <EvanR> neither package references the other, i guess that makes sense. but it seems a little awkward to go from one to the other
19:36:29 <Welkin> you must match on the constructors
19:36:44 <Axman6> in that case statement, , the final x is definitely Nothing
19:37:02 <Axman6> > case 1 of x -> x
19:37:03 <lambdabot>  1
19:37:07 <brandon`> orbisvicis if you're just looking to not keep repeating mapM/zipping/unzipping each time you sort something you could write something like this: sortByIO :: (a -> a -> IO Ordering) -> [a] -> IO [a]
19:37:28 <Scriptonaut> Axman6: so why does it work there? I thought I was doing the same thing
19:37:36 <Axman6> Welkin: you don't need to match on Nothing there, but it is all that it possibly could be
19:37:54 <Axman6> > case Just 1 of Just x -> x; x -> x
19:37:55 <lambdabot>  Occurs check: cannot construct the infinite type:
19:37:56 <lambdabot>    a ~ Data.Maybe.Maybe a
19:37:56 <lambdabot>  Relevant bindings include
19:38:03 <Axman6> > case Just 1 of Just x -> x; y -> y
19:38:05 <lambdabot>  Occurs check: cannot construct the infinite type:
19:38:05 <lambdabot>    a ~ Data.Maybe.Maybe a
19:38:05 <lambdabot>  Relevant bindings include
19:38:22 <Axman6> ok, so, x in the first case has type Int. but y in the second type has type Maybe Int
19:38:47 <Axman6> if lookup fails, you need to provide something else of type [String] -> IO ()
19:39:10 <Scriptonaut> ah, ok
19:39:42 <toblerone> If I daemonize a process created with System.Process, and System.Posix.Process, is there a way to have some action be performed when that newly spawned process terminates?
19:41:16 <geekosaur> how are you daemonizing it?
19:41:22 <EvanR> toblerone: the thread that spawned it can wait for it to end. if your dont intend to wait around for this, that other process itself can define an at_exit or whatever finalization action of its own
19:41:50 <orbisvicis> brandon`: no the problem was mapM not working for zippers, so I would have to flatten the zipper to a list, sort then restore, but mapZM takes care of that
19:41:59 <geekosaur> but, if you're not doing waitForProcess then do a 2-stage spawn: fork a child in the background which forks the daemon, wait()s for it, and does cleanup
19:42:20 <toblerone> one sec. i'll put up a paste giving you the basic idea
19:42:21 <geekosaur> (welcome to POSIX process management; enjoy your stay)
19:42:38 <EvanR> yes fork exec
19:43:33 <EvanR> dont let the semaphores get stuck on your way out
19:44:51 <toblerone> okay, here is how I'm creating the new process
19:44:51 <toblerone> http://lpaste.net/120185
19:46:38 <toblerone> so in the daemonize function, i could include the cleanup code there which will be executed on process termination?
19:46:40 <geekosaur> ok, you can't do anything about that one; it's owned by init
19:47:17 <Rotaerk> is there a standard alternative to the Read typeclass that supports failing to read?
19:47:20 <geekosaur> you could still fork another process in the initial daemon process and have it waitForProcess that
19:47:28 <geekosaur> Rotaerk: ReadS
19:47:38 <glguy> Rotaerk: The Read typeclass supports failure to read, it's only the read method that does not
19:48:00 <Rotaerk> hmm k
19:48:16 <glguy> Text.Read.readMaybe wraps reads to give you the functionality you probably wanted
19:49:09 <toblerone> geekosaur: well here is my situation. I have a long running program that I want to have run in the background, and I want an interface to that process that will take some arguments, hand it off to the daemon, and terminate
19:49:32 <toblerone> also, if the daemon isn
19:49:54 <toblerone> t running, it will initialize it.
19:50:16 <geekosaur> daemonize may not be what you want
19:50:29 <geekosaur> daemonize is used for persistent system daemons, normally
19:50:42 <geekosaur> you may just want a normal background process
19:50:57 <Rotaerk> glguy, thanks; hoogle doesn't turn up anything for readMaybe
19:51:03 <Rotaerk> also I was initially querying for maybeRead
19:51:21 <geekosaur> standard hoogle doesn't index much; try the one on fpcomplete, or hayoo
19:51:52 <zachstone> Is it possible to define 'pure' for a type with 2 values? e.g. (Complex 4 4)?
19:52:19 <orzo> you mean Control.Applicative.pure?
19:52:23 <Welkin> :t pure
19:52:23 <zachstone> Yep
19:52:24 <lambdabot> Applicative f => a -> f a
19:52:26 <Rotaerk> geekosaur, worked; thanks
19:53:01 <Big_G> Is there a syntatic sugar to all any number of arguments and assuming they're the same type, put them into an array?
19:53:03 <geekosaur> (more precisely the standard one does index things like that *but* you have to know which package it's in and tell it to include that database explicitly)
19:53:08 <orzo> i'm not sure i understand the question regarding pure
19:53:26 <geekosaur> (which makes it kinda useless when what you're looking for is either whether it exists somewhere, or what package it comes from...)
19:53:41 <orzo> how do you want your Applicative to behave?
19:53:52 <zachstone> I have a type "Complex a b" and I want it to be an applicative
19:54:13 <zachstone> What do you mean by that?
19:54:19 <orzo> well, what would fmap do?
19:54:48 <zachstone> I have fmap as "fmap f (Complex x y) = Complex (f x) (f y)
19:55:08 <EvanR> Big_G: no but it sounds like you want a list
19:55:50 <orzo> then probably you want pure x = Complix x x
19:56:00 <orzo> excuse typo
19:56:10 <EvanR> Applicative types take 1 type argument not two
19:56:37 <orzo> i don't think he has two type arguments
19:56:39 <EvanR> you cant do instance Applicative Complex
19:56:51 <zachstone> orzo: Wow, I've been trying to get that work for like an hour, and I think I've tried every permutation but that.. Thanks!
19:56:54 <EvanR> orzo: Complex a b
19:56:59 <Welkin> data Complex a = Complex a a
19:57:03 <Welkin> that would make sense
19:57:10 <Welkin> Complex a b does not
19:57:27 <zachstone> That's what I have
19:57:32 <orzo> well you guys should infer something from his fmap definition, fmap f (Complex x y) = Complex (f x) (f y)
19:57:36 <zachstone> data Complex a = Complex a a
19:57:40 <orzo> how could that have worked if he had multiple type variables?
19:57:56 <EvanR> nvm
19:58:12 <EvanR> use :+ as the ctor instead ;0
19:58:47 <Welkin> :t (:+)
19:58:48 <lambdabot> a -> a -> Complex a
19:59:00 <sccrstud92> do all infix constructors have to start with a colon?
19:59:08 <Welkin> > 3.0 :+ 1.0
19:59:09 <lambdabot>  3.0 :+ 1.0
19:59:20 <orzo> zachstone: if you're not being sarcastic, then i'm curious what the other permutations that you tried were
19:59:25 <zachstone> Is that a built in Complex?
19:59:26 <EvanR> i love it when computations result in exactly what you started with
19:59:31 <Welkin> zachstone: yes
19:59:36 <zachstone> Wow.. haha.
19:59:38 <raymondtay> iâ€™m starting out to learn haskell and itâ€™s been enjoyable but i was wondering about â€œkindsâ€ in haskellâ€¦.can anyone point me to any papers or books i can read up to understand this subject? i think thatâ€™s the core of the haskell type system and it would be important
19:59:59 <Welkin> raymondtay: kinds are the types of types
20:00:11 <Welkin> they refer to type arguments
20:00:26 <Welkin> Maybe a has kind * -> *
20:00:34 <Welkin> it takes one type argument
20:00:54 <zachstone> orzo: I initially had "pure = Complex", then "pure a b = Complex a b", "pure a a = Complex a a", and tried changing the "instance .. where" line also.
20:00:55 <Welkin> Either a b :: * -> * -> *
20:01:19 <raymondtay> @Welkin iâ€™m beginning to see â€¦. and what is the last * ?
20:01:19 <lambdabot> Unknown command, try @list
20:01:21 <Welkin> zachstone: pure only takes one argument
20:01:21 <orzo> oh
20:01:46 <Welkin> raymondtay: the last * is the concrete (fully applied) type
20:01:51 <Welkin> Maybe Int :: *
20:01:54 <zachstone> Yeah, I know that
20:02:03 <glguy> * is the kind of types that have values
20:02:10 <raymondtay> Welkin: ohhhhhhh i see :)
20:02:35 <zachstone> Welkin: I was just clueless as to how I could make it work, so I tried everything
20:02:55 <raymondtay> Welkin: iâ€™m working thru LYHFGG and i was playing around the typesystem but wasnâ€™t sure what the last * meant
20:03:20 <raymondtay> Welkin: thanks a lot for that explanation, very much appreciate it.
20:04:51 <Rotaerk> hmm... could've sworn there was something like Maybe a -> b -> Either b a
20:05:06 <Rotaerk> i.e. add some error info to the failure of a Maybe
20:05:27 <Welkin> I believe there is some way to convert between Either and Maybe
20:06:00 <glguy> \x y -> maybe (Left y) Right x :: Maybe b -> a -> Either a b -- is one such way
20:06:01 <sccrstud92> there are probably mutliple ways
20:06:21 <Rotaerk> there's some (?!) operator in Data.API.Utils
20:06:31 <Rotaerk> the "oh noes" operator, it says
20:08:17 <brandon`> :t (<&>)
20:08:17 <lambdabot> Functor f => f a -> (a -> b) -> f b
20:08:25 <brandon`> can lambdabot check fixity?
20:08:33 <Rotaerk> ah, it's maybeToEither ... didn't turn up because the signature is more generic
20:08:35 <Rotaerk> :t maybeToEither
20:08:36 <lambdabot> Not in scope: â€˜maybeToEitherâ€™
20:09:00 <Hijiri> brandon`: If it's an operator, it's infix
20:09:15 <Hijiri> (if you surround it in parentheses it becomes prefix though)
20:09:22 <Hijiri> wait actually
20:09:24 <Hijiri> I don't know
20:09:31 <Hijiri> you can have infix and postfix operators, I'm dumb
20:09:45 <Welkin> > (+) 3 4
20:09:47 <lambdabot>  7
20:09:48 <Welkin> yes
20:10:01 <Hijiri> Welkin: I mean normal non parenthesized operators
20:10:14 <Hijiri> I know ghci will tell you fixity if you do :info on an operator
20:10:15 <sccrstud92> how can you ahve postfix?
20:10:20 <Welkin> > 3 4 & (+)
20:10:21 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a))
20:10:21 <lambdabot>    arising from the ambiguity check for â€˜e_134â€™
20:10:21 <lambdabot>  from the context (GHC.Num.Num (a1 -> a),
20:10:25 <Clint> Rotaerk: there's `note' too
20:10:34 <Hijiri> sccrstud92: fixity declaration
20:10:46 <Hijiri> I've never actually tried it so I don't know if it works, but maybe you can specify postfix
20:11:03 <brandon`> yeah I thought fixity = infixr thingy? anyway, wondering if lambdabot can check that
20:11:08 <Rotaerk> Clint, ahh that's the one I was thinking of.  thanks
20:11:16 <Welkin> > 4 & (+3)
20:11:18 <lambdabot>  7
20:11:18 <Rotaerk> why didn't it turn up with hayoo... hmm
20:11:20 <brandon`> infixr/infixl
20:11:27 <Welkin> > 4 3 & (+)
20:11:29 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a))
20:11:29 <lambdabot>    arising from the ambiguity check for â€˜e_143â€™
20:11:29 <lambdabot>  from the context (GHC.Num.Num (a1 -> a),
20:11:45 <Welkin> > 4 & 3 & (+)
20:11:46 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a))
20:11:46 <lambdabot>    arising from the ambiguity check for â€˜e_143â€™
20:11:46 <lambdabot>  from the context (GHC.Num.Num (a1 -> a),
20:12:03 <EvanR> i couldnt get & to work like that
20:12:04 <Rotaerk> ah, it's because I had to get the order of the arguments just right
20:12:26 <EvanR> > 3 & (4 & (+))
20:12:27 <lambdabot>  7
20:12:41 <sccrstud92> thats still not postfix
20:13:00 <EvanR> why not?
20:13:11 <brandon`> > 4 & (+3) & show
20:13:12 <lambdabot>  "7"
20:13:18 <sccrstud92> because the operator is & and (+) is the operand
20:13:28 <Hijiri> actually, I'm not sure if you can declare operators to be non-infix
20:13:34 <sccrstud92> you cant
20:13:38 <sccrstud92> not that i have seen
20:13:43 <EvanR> yawn
20:13:55 <Hijiri> I guess - is a special case
20:13:57 <orzo> & should be declared with infixr for right-associativity
20:14:23 <Welkin> Hijiri: using (-) as a unary operator must be enclosed in parens (-7)
20:14:35 <sccrstud92> i like it better left associative
20:14:38 <Welkin> > -7
20:14:40 <lambdabot>  -7
20:14:47 <Welkin> > 3 + -7
20:14:48 <lambdabot>  Precedence parsing error
20:14:49 <lambdabot>      cannot mix â€˜GHC.Num.+â€™ [infixl 6] and prefix `-' [infixl 6] in the same ...
20:14:50 <Welkin> > 3 + (-7)
20:14:52 <lambdabot>  -4
20:14:55 <EvanR> well if you are trying to do "OOP" chaining, it needs to be left assoc. ((obj & getFoo) & getBar)
20:15:13 <orzo> i see
20:15:15 <EvanR> which also doesnt work
20:15:26 <orzo> what module exports & ?
20:15:33 <Welkin> orzo: lens
20:15:43 <EvanR> > [1,2,3] & sum & (+1)
20:15:44 <lambdabot>  7
20:15:52 <EvanR> that is, it didnt work when i tried it locally
20:15:52 <Hijiri> Welkin: that's only when there could be ambiguity in operators
20:15:53 <brandon`> & will be included in ghc 7.10
20:15:54 <Welkin> (&) = flip ($)
20:15:57 <brandon`> IIRC
20:16:47 <Hijiri> > (-7 + 3, -5 == 42, - 56^2)
20:16:49 <lambdabot>  (-4,False,-3136)
20:17:39 <orzo> whats the cannonical name for flip fmap ?
20:17:46 <sccrstud92> <$>
20:17:49 <EvanR> <&>
20:17:54 <jmcarthur> not <$>
20:17:55 <brandon`> yes <&>
20:18:03 <brandon`> <$> is fmap
20:18:04 <sccrstud92> oh oops
20:18:07 <sccrstud92> yeah
20:18:24 <orzo> does lens also define a non-operator name for it?
20:18:34 <sccrstud92> i think so
20:18:35 <brandon`> I doubt it :)
20:18:43 <EvanR> pamf
20:18:46 <sccrstud92> he tried to do that with all his operators
20:18:59 <orzo> EvanR: lens defines pamf?
20:19:06 <sccrstud92> i think he made it up
20:19:07 <Welkin> :t pamf
20:19:07 <lambdabot> Not in scope: â€˜pamfâ€™
20:19:09 <EvanR> hope not sounds silly
20:19:15 <Welkin> :t (<&>)
20:19:15 <orzo> heh
20:19:15 <lambdabot> Functor f => f a -> (a -> b) -> f b
20:19:18 <orzo> i use pamf personally
20:19:23 <Welkin> there is also <**>
20:19:36 <Hijiri> what are we going to do on the functor?
20:19:39 <jmcarthur> surely it should just be pam, so as not to further propagate historical cruft ;)
20:19:42 <benzrf> Hijiri: no
20:19:47 <benzrf> Hijiri: shh
20:19:47 <orzo> i'd rather we had some cannonical name, i guess <&> is closest thing if it's the lensy way
20:19:49 <EvanR> after enough operator shenanigas youre likely to use !@#$
20:20:12 <Welkin> EvanR: I think we can avoid looking like perl
20:20:37 <EvanR> watch your mouth
20:21:07 <ruukasu> Hijiri: well done
20:21:08 <ruukasu> 10/10
20:21:23 <brandon`> @hoogle FilePath -> Int
20:21:25 <lambdabot> Test.HUnit.Base Label :: String -> Node
20:21:25 <lambdabot> Prelude error :: [Char] -> a
20:21:25 <lambdabot> Prelude length :: [a] -> Int
20:21:26 <brandon`> @hoogle FilePath -> IO Int
20:21:26 <lambdabot> Network.Socket send :: Socket -> String -> IO Int
20:21:26 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
20:21:27 <lambdabot> Language.Haskell.TH.Syntax badIO :: String -> IO a
20:21:29 <glguy> > fmap ?? [1,2,3] $ \x -> x*2   -- operator version of flip
20:21:31 <lambdabot>  [2,4,6]
20:21:40 <milli> `bps:
20:21:42 <benzrf> glguy: its more general than flip atually
20:21:45 <benzrf> :t (??)
20:21:46 <lambdabot> Functor f => f (a -> b) -> a -> f b
20:22:20 <orzo> there's unicode points for any parenthesized english letter or encircled english letter and haskell accepts them all as infix operators
20:22:27 <glguy> benzrf: Nonetheless it gets used as an operator flip
20:22:29 <benzrf> orzo: damn
20:22:36 <brandon`> I can't seem to find a function that returns size of the file in System.Directory.
20:22:36 <benzrf> *actually
20:23:02 <glguy> brandon`: You'll probably need to dive into something like the unix package for that
20:23:09 <glguy> or unix-compat if you want it to work on Windows
20:23:51 <EvanR> whats the operator for cofmap from cofunctor
20:23:56 <orzo> an operator lover should resort to unicode rather than making ugly !@#$ nonsense
20:24:10 <t4nk432> Hey guys I got a q
20:24:35 <Axman6> rule #1 of IRC: Don't ask to ask, just ask =)
20:24:52 <t4nk432> Alright. Say I got a list of points [(2,1),(3,0),(4,1),(5,2)]
20:25:12 <t4nk432> I am trying to sort it by the slope of a point relative to a fixed point
20:25:33 <t4nk432> so for instance I want to sort the points relative to point (3,0)
20:25:40 <orzo> sortBy
20:25:53 <johnw> Axman6: I have a question about rule #1 of IRC, is that ok?
20:26:14 <t4nk432> I tried doing that but can I pass in the relative point?
20:26:16 <Axman6> no
20:26:18 <orzo> what's rule #2 of IRC?
20:26:24 <EvanR> fixed point of having a question about
20:26:33 <geekosaur> heh
20:26:41 <Axman6> orzo: congratulations, you've successfully learned all rules of IRC!
20:26:42 <orzo> t4nk432: of course?
20:27:11 <Axman6> sortBy (comparing (slope (3,0)))
20:28:25 <t4nk432> Ah. I will try that thank you.
20:28:38 <johnw> Axman6: that should be more efficient in 7.10 with sortOn
20:29:02 <dmwit> johnw: We got sortOn?? Did we get the other ones?
20:29:12 <johnw> what other ones?
20:29:21 <dmwit> maximumOn, and other *By functions
20:29:33 <johnw> I only know about sortOn
20:30:01 <Axman6>  :t sortOn?
20:30:07 <dmwit> http://hoogle.haskell.org/?hoogle=By&scope=package%3Abase
20:30:17 <dmwit> Axman6: Ord b => (a -> b) -> [a] -> [a]
20:30:23 <johnw> Axman6: https://ghc.haskell.org/trac/ghc/ticket/9337
20:30:31 <dmwit> Axman6: But uses decorate-sort-undecorate semantics.
20:30:45 <johnw> heh, sortOn was suggested back in https://ghc.haskell.org/trac/ghc/ticket/2659, but was closed as wontfix
20:30:48 <Axman6> does it do a schwartzian (?) transform?
20:30:52 <glguy> What about sortOnBy?
20:30:53 <johnw> I guess after 5 years minds changed
20:30:55 <johnw> Axman6: yes
20:30:58 <Axman6> right. glad to hear it, I've been wanting that for ages!
20:31:54 <Axman6> glguy: yeah that's coming with the new walkOnBy
20:32:31 <johnw> walkDontRun
20:32:47 <glguy> Then lens will have sortOnByOf
20:32:51 <dmwit> walkStateT
20:32:59 <johnw> lol
20:33:38 <Axman6> walkDon'tRun :: (Not IO m, Trasversable f) => f (m a) -> m (f t)
20:33:49 * Clint shakes his head.
20:34:06 <Axman6> walkDon'tRun :: (Not IO m ~ 'True, Trasversable f) => f (m a) -> m (f t) -- probably closer?
20:35:19 <yiati> Following Learn You a Haskell I keep getting "parse error on input `|' trying to load http://lpaste.net/120186
20:35:21 <brandon`> what will be sortOn's counterpart for sortBy (comparing foo <> comparing bar)?
20:35:35 <brandon`> is it even possible to express it like that
20:35:39 <dmwit> sortOn (\x -> (foo x, bar x))
20:35:48 <dmwit> sortOn (foo &&& bar)
20:35:50 <jmcarthur> sortOn (foo &&& bar)
20:35:59 <brandon`> ah yes
20:36:19 <t4nk432> @Axman6: for the comparing function I supply the function from b->a and the sortBy takes care of the b->b part?
20:36:19 <lambdabot> Unknown command, try @list
20:37:18 <Axman6> t4nk432: not sure i follow the question, but sortBy (comparing f) runs f on each element and uses the results in comparisons
20:37:59 <MaxOr> first time here sup
20:38:03 <t4nk432> I gotcha. I just saw the type signature for comparison
20:38:14 <t4nk432> and theres a Ord a => (b -> a) -> b -> b -> Ordering
20:38:20 <t4nk432> b->b
20:38:31 <Hijiri> hi MaxOr
20:38:34 <t4nk432> im trying to see where that is satisfied in the expression
20:38:48 <dmwit> :t comparing
20:38:49 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
20:38:57 <brandon`> :t sortBy
20:38:58 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
20:39:38 <bergmark> yiati: parses fine for me, are you using tabs?
20:40:16 <yiati> bergmark: nope spaces in vim
20:40:33 <dmwit> there's not even any multi-line blocks, so tabs wouldn't matter
20:40:40 <dmwit> yiati: The problem is probably elsewhere in your file.
20:40:45 <brandon`> "b" type variable in comparing  signature above == "a" type variable in sortBy's signature
20:40:56 <yiati> dmwit: That's the entire file
20:41:06 <bergmark> yiati: how are you loading it?
20:41:27 <dmwit> yiati: Are you sure that's the exact contents of the file? (Is it possible your editor has a stale view of the file, or you haven't saved?)
20:41:29 <Axman6> MaxOr: G'day. what can we help you with?
20:41:52 <yiati> in ghci I am loading with ":l lesson4.hs" in the directory with the file
20:43:08 <ttt_fff> what do you guys use to generate tags for haskell?
20:43:18 <yiati> dmwit: Don't think so, I'm in vim, and have done ":w"
20:43:24 <dmwit> ttt_fff: hasktags -R .
20:43:47 <dmwit> yiati: Are you sure you're writing to the same lesson4.hs that ghci is reading?
20:43:51 <dmwit> Exact same name, same directory?
20:44:00 <ttt_fff> dmwit: nice, thanks
20:44:07 <Hijiri> ttt_fff: one of the emacs scripts I've installed does it automatically when I save, but I have no idea which one it is
20:44:18 <ttt_fff> dmwit: for some reason, I always mis-read your nick as dimwit, and have to do a retake on your nick before seeing it as dmwit
20:44:29 <dmwit> ttt_fff: definitely intentional =)
20:44:43 <kadoban> dmwit: Do you play on DGS by any chance?
20:45:00 <yiati> dmwit: Ah I'm silly. Copying the file to clipboard didn't work so the version I showed you guys is the online one. I just put it in a separate file and did a diff. I put an = before the guards :P
20:45:15 <yiati> dmwit, bergmark, thanks
20:45:16 <ttt_fff> Hijiri: well, I guess we now know that there exists, somewhere in the universe, a elisp script which generates ahskell tags
20:45:35 <dmwit> kadoban: I am dmwit on DGS.
20:45:49 <kadoban> dmwit: Hah, nice. I thought your name looked familiar
20:47:32 <brandon`> I can't figure out how to use juicy pixels. I have DynamicImage, how to I use pixelAt or the equivalent? or how to convert DynamicImage to Image? no DynamicImage -> Image functions that I can see
20:48:32 <brandon`> I can't figure out how to use juicy pixels. I have DynamicImage, what would be its pixelAt equivalent? or alternatively how would I convert DynamicImage to Image? no DynamicImage -> Image functions that I can see
20:48:37 <MaxOr> any one use kali linux pentesters want to chat pm me
20:49:19 <Axman6> this is not the right channel MaxOr. this is a channel for discussion of the Haskell programming language
20:49:38 <poindontcare> quick question, is there any ,shell like environment  for haskell which is recomended ?
20:49:46 <poindontcare> some kind of replacement for bash
20:50:28 <kadoban> Like a shell that's specifically nice for haskell? Hmm, I don't think so.
20:50:30 <Axman6> there's shelly and turtle poindontcare, but afaik they aren't bash replacements for shells (ie, they aren'r repls but a way to write shell scripts)
20:50:31 <MaxOr> must be dont even know what haskell is lol
20:51:35 <poindontcare> i dont know , i remember reading something about scheme shell by olin shivers  wondering if there was something similar here
20:52:05 <poindontcare>  something like this : http://scsh.net/docu/html/man.html
20:52:42 <poindontcare> Axman6: they dont have some kind of mini dsl based repl ?
20:53:22 <bananagram> brandon`: you can use pattern matching on a DynamicImage to extract an Image from it. something like: let (ImageRGB8 img) = <DynamicImage> in ...
20:53:47 <bananagram> here are all the type constructors https://hackage.haskell.org/package/JuicyPixels-3.2.2/docs/Codec-Picture.html#t:DynamicImage
20:57:54 <augur> the bananagram was the predecessor to the bananaphone, invented by bananamorse
20:58:14 <brandon`> bananagram thanks, that works. but what if I want to write a generic function that works with any image, regardless of the color depth?
20:58:24 <Axman6> I though it was a movement to abolish the use of anagrams
20:59:17 <augur> Axman6: people who send bananagrams are notorious haters of anagrams
21:00:21 <bananagram> brandon`, I'm pretty sure it translates it to the color depth you specify
21:00:23 <brandon`> seems like I should use dynamicMap somehow, but I can't get the types to match
21:00:33 <brandon`> bananagram oh it does?
21:01:02 <bananagram> yeah
21:01:42 <brandon`> no I am afraid, I am getting pattern match failure. which is expected I guess
21:01:57 <Axman6> uh, no, pattern matching can't change what constructor is used
21:02:02 <brandon`> yeah
21:02:27 <EvanR> brandon`: you have to ask yourself what a generic function that works with any pixel format would do
21:02:29 <Axman6> you'll need to use a case statement and match on the constructor you want, and handle the case where it's the wrong type otherwise
21:02:44 <EvanR> and then make it so
21:02:55 <t4nk432> My sort function doesn't seem to be behaving correctly
21:02:57 <t4nk432> here it is
21:02:58 <t4nk432> http://lpaste.net/120187
21:03:03 <EvanR> i.e. it might not be very generic at all
21:03:21 <t4nk432> any help is appreciated.
21:04:13 <brandon`> EvanR that is true.. pixelAt could return different things depending if it is ImageRGB8  or ImageRGB16
21:04:20 <brandon`> would*
21:05:10 <EvanR> brandon`: could, rather it would
21:05:28 <brandon`> I am not sure how to handle this. image is expected to be ImageRGB8 , but if it isn't then I guess the easiest way to do would be to just convert whatever to ImageRGBA8
21:05:55 <EvanR> brandon`: what you can do, which might make a lot of sense, it write a function that reads the dynamic image at that location and converts to a standard pixel somehow, one you think would work in all cases
21:06:15 <EvanR> brandon`: if you expect it to be RGB8, and it isnt, could be an error
21:06:56 <EvanR> the type system is forcing you to figure this out
21:07:03 <bananagram> you can't pattern match an ImageRGBA8 from the DynamicImage?
21:07:18 <EvanR> you can, an inexhaustic pattern match
21:07:22 <EvanR> ive*
21:07:47 * hackagebot scc 0.8.2.1 - Streaming component combinators  http://hackage.haskell.org/package/scc-0.8.2.1 (MarioBlazevic)
21:08:23 <EvanR> the doc specifically says use Image Foo when you want a concrete format, which sounds like brandon` does
21:08:44 <EvanR> you get that by checking the dynamic image and bailing if its the wrong format
21:09:02 <EvanR> or converting if that makes sense
21:11:11 <LordBrain> t4nk432, you have a NaN do to division by zero with the points (3,0) (3,0), slope = (0-0)/(3-3) = 0/0
21:11:24 <unknownloner> yeah
21:11:30 <unknownloner> the NaN is messing up the sort
21:11:54 <unknownloner> the results of mapping slope over your input data, when sorted, is [-1.5,-1.0,1.0,1.0,5.0,NaN,1.5]
21:13:07 <t4nk432> oh. okay if I remove that point
21:13:17 <t4nk432> it should be a-okay?
21:13:23 <unknownloner> it should work yeah
21:13:34 <unknownloner> as long as you have no points with an X value of 3
21:16:55 * dmwit . o O ( slope :: Point -> Point -> Maybe Slope )
21:17:18 <t4nk432> Huzzah! thx brodies.
21:18:12 <Rotaerk> anyone know of something along the lines of: [(a, b)] -> (a -> Maybe b, b -> Maybe a) ?
21:18:27 <ttt_fff> yo
21:18:29 <ttt_fff> how do I install https://github.com/eagletmt/ghcmod-vim ?
21:18:33 <ttt_fff> there's like no installation instructions?
21:18:38 <ttt_fff> I have installed vimproc via pathogen
21:18:44 <ttt_fff> but now I'm looking at this, and I'm like wtf, how do I install ghcmod-vim ?
21:19:47 <johnw> Rotaerk: \xs  -> (\x -> lookup x xs, \y -> lookup y (map swap xs))?
21:20:28 <Rotaerk> johnw, I could implement it myself, but I prefer to use preexisting options when possible
21:20:44 <Rotaerk> and this seems like something that might already exist somewhere; haven't found one yet, though
21:20:58 <Rotaerk> (probably because it exists in some abstracted form)
21:22:12 <johnw> Rotaerk: https://hackage.haskell.org/package/bimap-0.2.4/docs/Data-Bimap.html
21:22:57 <Rotaerk> hmm thanks
21:23:01 <EvanR> dmwit: . o O (Point -> Point -> NormalVector)
21:24:04 <EvanR> sort by angle from vertical
21:24:11 <EvanR> or something! slope is horrible
21:24:19 <unknownloner> what'd be a good library to use to decode images, if all I need is the pixel data itself (I don't need the library to have any code to modify the pixels)
21:24:33 <EvanR> juicy pixels
21:24:36 <brandon`> juicypixels, apparently :)
21:24:45 <unknownloner> thanks
21:27:39 <brandon`> is there a built in "Any Image with 8-bit color depth -> ImageRGBA8" function  in juicypixels btw?
21:27:48 * hackagebot warp 3.0.9 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.9 (MichaelSnoyman)
21:30:36 <EvanR> brandon`: no but you can make one by composing a couple of the functions
21:31:29 <EvanR> brandon`: well... you want it to end up gray?
21:33:01 <EvanR> brandon`: try promoteImage and see if that does it
21:33:25 <joobus> so are snap and yesod the hasell web servers now?  they have the most active repos.
21:33:39 <joobus> this information is seriously out of date: https://wiki.haskell.org/Web/Servers
21:34:01 <brandon`> no I want to keep it gray if it is already gray, or keep all the color pixels otherwise. I'll take a look at promoteImage
21:34:20 <EvanR> i guess i misunderstood what you meant by 8-bit color
21:34:23 <joobus> hyena hasn't been touched since 2010 according to github.
21:34:36 <EvanR> brandon`: its using indexed color? or its a grayscale image
21:34:38 <brandon`> I meant 8-bit per channel
21:34:42 <EvanR> >_>
21:35:55 <brandon`> ImageY8 ImageYA8  ImageYCbCr8 ImageCMYK8 can all be converted to ImageRGBA8 without loss in data, no?
21:36:04 <EvanR> brandon`: so theres only two kinds of image that are like that, ImageRGB8 and ImageRGBA8, one is already what you want, and the other is promoteImage
21:36:47 <EvanR> the instances listed for ColorConvertible are supposed to convert without loss
21:37:07 <EvanR> Y8 is not listed
21:37:25 <EvanR> YA8 is
21:40:00 <EvanR> brandon`: oops. need to stop looking at the ctors for DynamicImage. Pixel8 (Y8) can be obviously upgraded to RGBA8
21:42:35 <brandon`> yeah. I am trying to write DynamicImage -> Image PixelRGBA8, and I am not sure if I am suppose to pattern match on all DynamicImage constructors, or if I can do something clever like:
21:42:49 * hackagebot yesod-form 1.4.4 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.4 (MichaelSnoyman)
21:42:51 * hackagebot yesod-core 1.4.8 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.8 (MichaelSnoyman)
21:42:53 * hackagebot yesod-test 1.4.3.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.3.1 (MichaelSnoyman)
21:42:55 <brandon`> dynamicMap (promoteImage :: Image a -> (Image PixelRGBA8)) dynamicImage   {- Doesn't work -}
21:44:38 <EvanR> you dont need dynamicMap
21:45:20 <EvanR> use promoteImage on the wrapped Image on the cases that make sense to do that
21:46:18 <brandon`> can I use dynamicMap, though? I don't mind failure if it doesn't work
21:46:25 <brandon`> (failure = error)
21:46:38 <EvanR> just use a case
21:46:52 <EvanR> what you had doesnt type check, or make sense
21:47:09 <brandon`> it seems like dynamicMap exists to avoid pattern matching on DynamicImage constructors just to apply a function
21:47:22 <EvanR> itll work if you can apply it to all the cases
21:47:25 <EvanR> which you cant
21:47:56 <brandon`> oh. it would compile for some Image types but not other?
21:48:21 <EvanR> it says "forall" so it wont compile since it wont work for some ;)
21:48:29 <brandon`> yes
21:48:40 <EvanR> its just the wrong type to do what youre saying
21:49:01 <EvanR> the example shows that you can use it to do something that doesnt depend on the pixel type
21:50:28 <EvanR> brandon`: more over, look at the source code for dynamicMap, youll see why promoteImage cant work
21:51:37 <EvanR> you need to basically write your own more selective version of dynamicMap
21:51:41 <brandon`> I understand
21:52:30 <brandon`> the code wouldn't compile with all the Image types that DynamicImage has constructors for, because some don't have ColorConvertible instance
21:52:44 <andkore> There was a post recently on /r/haskell or /r/programming about languages that compile to JavaScript. I can't seem to find it now. Anyone know what I'm talking about?
21:52:49 * hackagebot duplo 1.8.0 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.8.0 (kenhkan)
21:52:58 <andkore> The author decided to go with Elm, but mentioned GHCJS and PureScript.
21:53:59 <EvanR> brandon`: yeah. im not sure what the actual error would be but that reasoning trumps whatever ghc would say
21:54:40 <brandon`> errors are quite nice
21:54:44 <brandon`> No instance for (ColorConvertible PixelRGB16 PixelRGBA8)
21:54:54 <orzo> I need to adjust my pseudorandom generator with a given salt.  I'm not finding an interface to do that with StdGen, is there another RandomGen instance i should use?
21:55:05 <EvanR> brandon`: nice
21:56:20 <bergmark> andkore: http://blog.jenkster.com/2015/02/a-brief-and-partial-review-of-haskell-in-the-browser.html
21:57:23 <orzo> when i say show stdgen, i see two integers, i suppose i could modify them in some way and then read a StdGen back from the modified integers, but all that seems like i'm breaking the abstraction barrier
21:57:29 <andkore> bergmark: Thank you very much! I scrolled down, but not far enough it seems.
21:57:38 <orzo> besides, it's not clear how to modify the integers safely
21:59:14 <andkore> WebSharper was recently released for free under a permissive license. I'm probably going to get to use that at work (everything there is .NET).
22:00:05 <andkore> I couldn't get GHCJS installed on Windows. WebSharper requires little to no setup. GHCJS is obviously the long-term solution.
22:05:31 <bergmark> orzo: what benefit does salting it have?
22:07:18 <bergmark> but something like myGen = mkStdGen . salt . next $ intSalt ?
22:07:33 <bergmark> s/salt . next/salt . fst . next/
22:08:24 <ReinH> Why would you "salt" a prng?
22:12:05 <ab9rf> keeps it from spoiling
22:16:07 <benzrf> hue
22:17:59 <orzo> bergmark: I'm implementing an algorithm gives a bunch of random permitations indexed by Int.  The spec said that I could optimize away storing the data if i simply regenerate from a saved random seed as I need it.  But that means I need my input Int to perterb my saved random seed in a repeatable way.
22:18:10 <ttt_fff> how do I put the following into cabal? "PTIONS_GHC -fno-warn-orphans"
22:18:26 <ttt_fff> how do I put the following into cabal? "{-# OPTIONS_GHC -fno-warn-orphans #-}" <-- how do I put this inside a cabal file?
22:19:06 <reem> I've used Haskell a bit in the paste, enough that introductory things like LYAH bore me, and I'm wondering what the best path forward is if I want to become more proficient in Haskell in a conceptually rigorous way
22:19:23 <pacak> ttt_fff: Are you sure that's a good idea?
22:19:30 <ttt_fff> pacak: yes
22:19:55 <EvanR> reem: https://github.com/bitemyapp/learnhaskell
22:19:59 <pacak> ghc_options: -fno-warn-orphans
22:20:06 <pacak> ttt_fff: But it's a bad idea.
22:20:55 <mjrosenb> pacak: has that ever stopped anyone in the history of everything?
22:21:43 <pacak> mjrosenb: At least I want to try...
22:32:54 <mjrosenb> oh, wait, this is a Moment t (Event t a), not an Event t a...
22:33:36 <brandon`> No instance for (ColorConvertible PixelYCbCr8 PixelRGBA8) <- can't this be written without data loss?  data PixelYCbCr8  Pixel type storing 8bit luminance, blue difference and red difference (YCbCr) information
22:34:20 <brandon`> just checking, since I am wondering if I should expect instances for all the conversions that can be written without a loss in data
22:34:25 <EvanR> i dont know, but if you think you can, just write the computation yourself and use map
22:35:12 <EvanR> the doc for that class lists losslessness as a property of that class
22:38:20 <brandon`> weird.. getting RGB 254 0 0 in gimp, while pixel at gives me PixelYCbCr8 76 85 255
22:38:41 <EvanR> brandon`: looking at wikipedia, looks like interpretation of YCbCr is rather complex
22:39:00 <brandon`> (and I expected full luminance for red channel too, so perhaps this conversion can't actually be done without loss in data, which my photo editor seems to be doing anyway)
22:41:23 <EvanR> brandon`: "When representing the signals in digital form, the results are scaled and rounded, and offsets are typically added."
22:41:41 <mjrosenb> ugh, stupid types.
22:42:35 <mjrosenb> there is a varuable that was quantified with forall t., now I want to have another one, and I want them to be the same
22:42:42 <mjrosenb> is this something that is possible?
22:43:04 <EvanR> "there are some points within the YCbCr color cube that cannot be represented in the corresponding RGB domain (at least not within the nominal RGB range)"
22:43:39 <EvanR> mjrosenb: use t?
22:44:07 <mjrosenb> test.hs:42:52-57: Could not deduce (t ~ t1) â€¦
22:44:09 <ttt_fff> i'm on osx; I ahve homebrew installed; how do I get ghc 7.10? (I have haskell platform with 7.8.3 atm)
22:44:42 <EvanR> ttt_fff: https://ghcformacosx.github.io/
22:44:48 <pacak> ttt_fff: 7.10 is not out yet.
22:44:56 <ttt_fff> https://github.com/kazu-yamamoto/ghc-mod/issues/417#issuecomment-68819938
22:45:03 <ttt_fff> seems to suggest if I wnat to use ghc-mod, I'm fucked unless I'm on 7.10
22:46:14 <EvanR> brandon`: theres this thing headroom and toeroom which might also be confusing your intuition of the Yrb values
22:47:01 <orzo> hmm, haddock apparently doesn't recognize DEPRECATED annotations
22:47:30 <orzo> that's a bug imo
22:49:12 <EvanR> brandon`: http://stackoverflow.com/questions/4041840/function-to-convert-ycbcr-to-rgb
22:49:35 <brandon`> EvanR actually values I am getting in juicypixels werent confusing, values I was getting in photo editor were. this are plasma breakin slides, that I just checked for fun (to learn how to use juicypixel) and luminance for color slide should be maxed out, and it is
22:49:45 <EvanR> you can use the linear package to do the matrix computation detailed in that page (if its really right)
22:50:42 <EvanR> which begins by subtracting 16 from Y
22:50:55 <brandon`> I was frustrated with juicypixel at first, but now I am quite impressed how it can tell me "you can't do this conversion without loss of data (which I thought I could)" at compile time
22:51:05 <EvanR> and assumes Y is less than or equal to 235
22:51:53 <EvanR> ah for "SDTV" theres another one which uses the whole range
22:53:02 <EvanR> brandon`: yeah type classes are good for asserting certain properties of the types
22:56:03 <ttt_fff> how do I get around https://github.com/kazu-yamamoto/ghc-mod/issues/417#issuecomment-68819938 ?
22:59:49 <ab9rf> color representation is an exceedingly complex issue
23:06:01 <kadoban> ttt_fff: I just downgraded to cabal-install 1.18.0.8, personallyâ€¦which is just what was in stackage
23:06:21 <ttt_fff> hmm
23:06:34 <ttt_fff> with 1.18 from ghc-platform, I can't build hoogle + ghc-mod + hdevtools + text-format
23:06:48 <ttt_fff> i am clearly pissed :-)
23:07:56 <kadoban> ttt_fff: Apparently stackage has all of those. I don't use platform, so I can't say how you'd go from thereâ€¦
23:08:16 <ttt_fff> hmm
23:08:19 <ttt_fff> stackage
23:08:21 <ttt_fff> this sounds interesting
23:08:43 <ttt_fff> how od I use this this stackage?
23:08:47 <ttt_fff> http://www.stackage.org/ is it?
23:08:50 <ttt_fff> so it's guaranteed no cabal hell?
23:08:54 <ttt_fff> becuase everything plays nice with each other?
23:08:59 <ttt_fff> why the fuck did no one invent this before?
23:11:13 <kadoban> ttt_fff: That's the general idea. I can't say I have the ideal way to use it, and I'm about to head to bed anyway :-/ If you want the short version: I just install GHC from binary, cabal from source, and then use cabal sandboxes for everything. I have stackage set up globally too, but I don't know that that really matters because I only use it to build certain global tools like hlint and stuff.
23:11:26 <ttt_fff> wait wait wait
23:11:39 <ttt_fff> kadoban: how do I tell cabal: "don't fucking use hackage, use stackage" ?
23:12:05 <ttt_fff> oh
23:12:08 <ttt_fff> the section labeled 'quick start'
23:12:10 <kadoban> ttt_fff: Iâ€¦don't know from haskell platform. Doing what I did I think would break stuff, soâ€¦I'm not sure.
23:12:20 <ttt_fff> i removed hkaskell platform
23:12:24 <ttt_fff> and reinstaed ghc from the stackage page
23:13:36 <kadoban> ttt_fff: Oh huh, I didn't know there were actually instructions for that part, nice. I never saw them there before.
23:13:46 <ttt_fff> where do I put: ttp://www.stackage.org/lts/cabal.config ?
23:13:54 <ttt_fff> where do I put that file?
23:15:02 <kadoban> ttt_fff: In each project directory, in the root with the sandbox config. I have the global one in my user ~/.cabal/config as well
23:15:18 <ttt_fff> so it's in ~/.cabal/config/cabal.config
23:15:22 <ttt_fff> or it overrides ~/.cabal/config ?
23:15:25 <ttt_fff> (for the global one)
23:15:53 <kadoban> ttt_fff: You have to look at the global one on the site for global. You paste it into the end of your ~/.cabal/config
23:16:23 <ttt_fff> kadoban: this makes sense now
23:16:26 <ttt_fff> you may go to sleep now :-)
23:16:30 <ttt_fff> thanks for your help :-)
23:16:58 <kadoban> Heh, you're welcome. Have fun
23:27:57 * hackagebot cabal-debian 4.23.1 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.23.1 (DavidFox)
23:55:56 <mjrosenb> fun, hssdl2 isn't on hackage?
23:57:09 <mjrosenb> ahh, it has been deprecated.
23:57:18 <mjrosenb> it should probably be removed from the wiki.
