00:00:35 <betaceti> hi all, how do you control how ghci prints real numbers? for instance 0.06 prints as 6.0e-2, can i change it to just print with leading zeros?
00:01:15 <geekosaur> you can't control the Show instance. you can use the custom show functions in the Numeric module, or Text,Printf.printf
00:01:18 <julianleviston> if you write sin(2*theta) = 2 * sin theta * cos theta does that = mean == ?
00:05:30 <EvanR> is there a way to hide an internal class or class method
00:06:38 * hackagebot hscurses 1.4.2.0 - NCurses bindings for Haskell  http://hackage.haskell.org/package/hscurses-1.4.2.0 (StefanWehr)
00:06:40 * hackagebot gl 0.7.2.3 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.2.3 (Polarina)
00:08:54 <srid> julianleviston: yup. already liking it
00:09:16 <julianleviston> srid: I’m looking at a preview of it at the moment… so far it seem a little imprecise for my liking...
00:09:21 <julianleviston> srid:  in places.
00:10:04 <julianleviston> srid: like “In a text a word is identified by being surrounded by blank characters, so “Thelma and Louise” contains 3 words. By that definition, however, it contains one word.
00:11:49 <Big_G> Is there a split function like there is in Python?
00:11:52 <julianleviston> …but worse, the ideas don’t seem to be COMPOSED… they’re kind of shotgunned out, scattermeal.  What of applying the beautiful ideas within the language to the text one is writing?
00:12:22 <julianleviston> Big_G: https://www.haskell.org/hoogle/?hoogle=split
00:13:07 <julianleviston> srid: it doesn’t matter tho… I should be quiet until I can offer a better alternative :)
00:13:30 <betaceti> Big_G: splitAt?
00:13:47 <betaceti> splitAt :: Int -> [a] -> ([a], [a])
00:14:43 <srid> julianleviston: i like the concise style of writing. and mathematical bent as well. LYHG put me off as it seemed quite 'softer'. above all, this book has good exercises (most books don't).
00:15:06 <betaceti> srid: which book?
00:15:10 <julianleviston> srid: yes. point taken. i agree. it looks very good.
00:15:16 <srid> Thinking Functionally with Haskell by Richard Bird
00:15:21 <julianleviston> betaceti: http://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643
00:15:22 <srid> released christmas
00:15:31 <srid> i'm learning haskell using it
00:16:19 <julianleviston> srid: also it provides an insight into how to think about programs functionally and use functional design which is quite often skipped… all too often
00:17:57 <srid> yea, and it is quite evident from chapter 1. i read most of SICP some years ago, but this one is more rigorous (makes you compose functions from the get go)
00:18:40 <srid> eg:  commonWords n = concat . map showRun . take n . sortRuns . countRuns . sortWords . words . map toLower
00:19:05 <srid> hurt my brain in the beginning, but i decided that it is worth to learn to 'think functionally' anyway
00:20:20 <srid> what is ‘a0 -> [Char]’?
00:20:39 <srid> https://www.irccloud.com/pastebin/BtrZm1Dk
00:22:06 <srid> ... solved by wrapping appropriately: (map toLower . nMenLyric) (n-1)
00:22:19 <srid> which seems strange coming from other languages.
00:22:30 <srid> e.g.: map(toLower, nMenLyric(n-1))
00:26:40 * hackagebot takahashi 0.2.0.0 - library for takahashi method.  http://hackage.haskell.org/package/takahashi-0.2.0.0 (outoftune)
00:42:15 <clinton> Is there a way of doing what is discussed in https://wiki.haskell.org/GHC/AdvancedOverlap without copying all the instances of show?
00:42:45 <clinton> for example, a method "unique" which has a specialised method if the container it is operating on is ordered?
00:43:01 <clinton> *errr, function "unique"
00:43:42 <clinton> this can be done in C++ using "std::is_base_of" in the function signature, so presume it can be done in Haskell, I'm just trying to work out how
00:49:14 <bennofs> clinton: typeclasses and "classes" in the OOP sense are qwi
00:49:21 <bennofs> clinton: are quite different.
00:50:33 <clinton> bennofs: yes, but how I do what I'm asking. Considering I could do so just by copying all the instances, surely there's a quicker way?
00:52:16 <tdammers> clinton: if you want runtime polymorphism and reflection, there are ways, but they are rather different from what C++ has to offer
00:52:52 <bennofs> clinton: not really. The problem is the "open universe". In Haskell, anyone can later add an instance for a given type. This means that there is no way to "list" all instances of a given class. (if you could make that work, the answer would depend on all imports, recursively because instances are always reexported, which I'd consider quite fragile)
00:53:15 <tdammers> ah, yes
00:53:50 <tdammers> you can have superclasses, but the constraint works both ways (i.e., it means "is an instance if and only if", not "is an instance if")
00:53:57 <bennofs> clinton: so when you copy all instances manually, you're using information that the compiler does not have access to, that is you know *all* instancees of a given class
00:54:20 <tdammers> bennofs: except when code outside your control adds more instances
00:54:54 <tdammers> that's the open universe problem in a nutshell - the compiler doesn't have the information, but you can't really guarantee it yourself, you can only *assume*
00:55:51 <clinton> surely the compiler "knows" what instances it knows about. I don't mind if it picks the default method when there's a hidden Ord instance somewhere.
00:57:13 <bennofs> clinton: the problem appears when you mix different modules. In different modules, a different set of instances would be available. It's really hard to predict all instances which are available, because that also depends on the *imports of your imports*, which is an implementation detail IMO
01:06:42 * hackagebot clac 0.2.0 - Simple CLI RPN calculator  http://hackage.haskell.org/package/clac-0.2.0 (alexander)
01:20:35 <joris__> Hi, from a data type (for ex. data Data = A | B | C), do you know if I can get automatically derive a list of its members without having to write explicitly each value (for ex. not like that: members = [A, B, C]) ?
01:22:42 <joris__> I think I found something here http://stackoverflow.com/questions/4299319/getting-a-list-of-all-possible-data-type-values-in-haskell
01:23:01 <tdammers> data Foo = A | B | C deriving (Enum, Bounded, Show)
01:23:11 <tdammers> [minBound..maxBound] :: [Foo]
01:23:15 <tdammers> does that help?
01:23:23 <joris__> yeah thanks :)
01:28:45 <nkar> c_wraith: I think I figured it out.  basically, I need to pass an ExpQ not a function.  for example, idE = varE 'id :: ExpQ; derivePersistField make unmake name = do ... [d| ... toPersistValue $(conP vcon [varP x]) = PersistText $(appE unmake (varE x)) ... |] :: ExpQ -> ExpQ -> Name -> Q [Dec]
01:31:23 <nkar> c_wraith: I tried to use Names instead of ExpQ but it wasn't polymorphic enough.  I couldn't use 'id and 'Markdown in the same place because the former needs to be passed to varE while the latter to conE.  so I "lifted" it up a bit.
01:31:46 <nkar> c_wraith: thanks for trying to help, though.  I appreciate!
01:33:48 <jle`> joris__: you can even do [minBound..] if you want
01:35:49 <joris__> jle` yes, that it even more concise. I used this notation with numbers but I didn't know I could use that too with my own types.
01:36:22 <jle`> joris__: mhm, [x..] is actually just syntactic sugar
01:36:27 <jle`> for `enumFrom x`
01:36:29 <jle`> :t enumFrom
01:36:30 <lambdabot> Enum a => a -> [a]
01:36:45 <jle`> which is a part of the Enum typeclass, if you know what typeclasses are
01:37:04 <jle`> so for any type, you cna define an `enumFrom` function for that type, and it'll work with the [x..] literal
01:39:31 <merijn> joris__: Yeah, .. is just syntactic sugar for the Enum typeclass
01:39:52 <merijn> It has some ugly bits concerning when to stop, but other than that it's pretty neat :)
01:40:11 <merijn> (i.e. "succ maxBound" is specified to produce an error which is dreadful...)
01:41:28 <nkar> jle`: you can't define it for any type, right?
01:41:49 <jle`> you can't always define a meaningful one, but you technically syntactically can
01:42:00 <nkar> jle`: only for those having nullary constructors
01:42:03 <jle`> data MyType = Blah | Stuff Int | Quail
01:42:16 <jle`> instance Enum MyType where enumFRom x = Blah
01:42:20 <nkar> hm, will this typecheck?
01:42:23 <jle`> er, enumFrom _ = [Blah]
01:42:44 <jle`> it'll typecheck but it won't be very meaningful or behave expectedly, heh
01:43:14 <jle`> enter :i Enum into ghci to see what functions need to be implemented
01:43:26 <jle`> but you can implement them all manually, and it then works with your .. syntax
01:43:35 <merijn> nkar: That type will work, but "succ Blah" will be "Stuff minBound"
01:43:59 <merijn> nkar: It will then go through all values of Int until maxBound Int, at which point "succ (Stuff maxBound)" will produce Quail
01:44:02 <jle`> does ghc derive Enum instances like that?
01:44:08 <nkar> hm, last time I tried, I got an error from the typechecker.  maybe I did it wrong, dunno
01:44:09 <merijn> jle`: Yes
01:44:22 <jle`> since when?
01:44:26 <merijn> @define data MyType = Blah | Stuff Int | Quail deriving (Enum, Bounded)
01:44:27 <lambdabot>  .L.hs:155:23:
01:44:28 <lambdabot>      Can't make a derived instance of ‘Enum MyType’:
01:44:28 <lambdabot>        ‘MyType’ must be an enumeration type
01:44:48 <nkar> will it work for data T = Foo | Bar | Baz Text?
01:45:12 <jle`> the only non-nullary constructor it will work with is for newtypes and GeneralizedNewtypeDeriving i think
01:45:20 <merijn> oh, I must be confused
01:45:31 <merijn> It only works for parameterised types
01:45:31 <jle`> and it can't even derive that without an extension, ho ho
01:45:42 <merijn> @define data MyType a = Blah | Stuff a | Quail deriving (Enum, Bounded)
01:45:43 <lambdabot>  .L.hs:155:25:
01:45:43 <lambdabot>      Can't make a derived instance of ‘Enum (MyType a)’:
01:45:43 <lambdabot>        ‘MyType’ must be an enumeration type
01:46:02 <merijn> hmmm, not even then? I was sure that worked in the past...
01:46:07 <merijn> Maybe I'm confused
01:46:48 <jle`> btw merijn i was looking at the #haskell logs and i noticed that you were the first person that helped me with my first question here on #haskell
01:46:57 <jle`> so thanks
01:47:02 <merijn> jle`: Because I procrastinate on here too much :p
01:47:34 <jle`> it was basically a why-am-i-overflowing-the-stack-oh-add-more-strictness question
01:47:39 <jle`> may 2013
01:47:55 <jle`> ocharles_ was there too
01:48:02 <merijn> I wonder what my first question here was...
01:48:34 <jle`> and then johnw after .... wow, basically everyone who still hangs out here and i correspond with, heh.
01:48:57 <johnw> :)
01:50:17 <jle`> ty all :)
01:50:18 <merijn> hah, my first question was such a silly parse problem :p
01:50:44 <merijn> "<merijn> Maybe I'm missing something obvious but, while I'm trying to play around with GHCi I run into trouble writing some of the example code. "let {fib 1 = 1; fib 2 =1; fib n = fib (n-1) + fib n-2)}" returns a stack overflow for n > 2 which hardly seems right."
01:51:21 <jle`> ha
01:51:28 <mauke> syntax error :-)
01:51:42 <joris__> :)
01:51:44 <merijn> mauke: Syntax is just fine
01:51:50 <merijn> It's just bottom :p
01:51:55 <mauke> > let {fib 1 = 1; fib 2 =1; fib n = fib (n-1) + fib n-2)} in ()
01:51:56 <lambdabot>  <hint>:1:54: parse error on input ‘)’
01:51:57 <init> fib n-2 /= fib (n-2)
01:52:48 <merijn> init: Well, obviously I know that 6 years later ;)
01:52:54 <init> merijn: it happens! because normally the types don't match, but sometimes!
01:53:09 <init> I know I know :p
01:53:18 <jle`> i'm glad you've learned, merijn
01:53:29 <mauke> it's not fib n-2, though; it's fib n-2)
01:54:16 <merijn> hah, Peaker was around to answer my questions too :p
01:56:11 <merijn> mauke: I probably typo'ed my typo while asking, because apparently I got it to run in ghci back then :p
02:01:50 * hackagebot extensible 0.2.9 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.2.9 (FumiakiKinoshita)
02:03:58 <EvanR> does 16-bit color image format help a lot with render performance vs 32-bit color
02:04:06 <EvanR> wrong channel
02:11:50 * hackagebot blaze-builder 0.4.0.0 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.4.0.0 (LeonSmith)
02:15:12 <mjrosenb> oh, I am so confused.
02:15:28 <mjrosenb> I'm looking at the haskell sdl2 tutorial
02:15:33 <lpsmith> Well, blaze-builder-0.4.0.0 going to cause a little bit of pain, probably.   Hopefully not _too_ much though.
02:15:35 <mjrosenb> and it seems to use functions that don't exist
02:15:37 <mjrosenb> moreover
02:15:41 <mjrosenb> they have never existed.
02:15:43 <lpsmith> It should save a lot of pain in the long run,  in any case.
02:15:46 <EvanR> haha
02:16:24 <Polarina> mjrosenb, what functions are you looking at?
02:17:04 <mjrosenb> Image.load
02:17:34 <Polarina> mjrosenb, mind if I ask where you are seeing that function being used? I don't recognize it.
02:17:52 <mjrosenb> there is an Image.loadTexture, but that returns a texture, not a surface
02:18:22 <mjrosenb> uhh, how do I ask git to show me where I cloned a repository from?
02:18:33 <Polarina> mjrosenb, git remote -v
02:18:33 <bennofs> mjrosenb: git remote -v
02:18:35 <bennofs> :)
02:18:56 <mjrosenb> Polarina: https://github.com/palf/haskellSDL2Examples
02:19:34 <mjrosenb> more specifically, https://github.com/palf/haskellSDL2Examples/blob/master/src/lesson06.hs#L84
02:20:10 <Polarina> mjrosenb, that's sdl2-image mentioned in the README.
02:20:48 <mjrosenb> there's more than one sdl2-image :-(
02:21:03 <Polarina> I know. :(
02:21:48 * mjrosenb notices polarina on the sdl2 repository mentioned
02:21:58 * Polarina hides!
02:22:19 <mjrosenb> is that the "canonical" sdl2 repository?
02:22:52 <mjrosenb> moreover, why is only one of them on hackage?
02:22:55 <merijn> mjrosenb: Take a look at the repo link on hackage?
02:23:11 <Polarina> http://hackage.haskell.org/package/sdl2
02:24:41 <mjrosenb> oh, great; that tutorial doesn't even link to the sdl2 that is on hackage!
02:25:12 <mjrosenb> ahh, this sdl2_image is a lot lower level, but way more feature complete.
02:27:22 <mjrosenb> Polarina: and yours isn't forked from the one in hackage
02:27:34 <Polarina> mjrosenb, no, it's the other way around.
02:27:48 <mjrosenb> Polarina: theirs is forked from yours?
02:27:48 <Polarina> mjrosenb, the haskell-game one is forked from mine.
02:28:10 <michaelis> Hi. Maybe I'm in the wrong channel but I want to know if anyone knows about a algorithm for determining if graphical object, line, circle etc is within a selection with a mouse pointer.
02:28:20 <mjrosenb> interesting, that doesn't show up in the forks section on github
02:28:26 <michaelis> an algorithm
02:28:33 <mjrosenb> Polarina: I guess they forked it with raw git commands?
02:28:38 <Polarina> mjrosenb, yes.
02:30:51 <mjrosenb> ok, well at least they should be mostly compatible with each ither*other
02:32:00 * mjrosenb guesses it is a better use of my time to add features to the hackage variant of sdl2_image, rather than ods94065's?
02:36:13 <guibou> "data Stuff = Stuff Float Float" "type Stuff2 = Stuff" << Why Stuff doesn't have a type constructor ?
02:36:47 <merijn> What do you mean "Stuff doesn't have a type constructor"?
02:36:55 <fractalsea> I have set of typeclasses that that define a various fields that a record should have. When I define a record type that should be an instance of some of these, I have to add a lot of boilerplate where I just say the field in the record type = the field in the typclass (they all have the same names). Is there any way I can do this automatically?
02:37:04 <guibou> merijn: Stuff2, sorry
02:37:27 <guibou> merijn: I can create Stuff using "Stuff 1.0 2.0", but Not Stuff2 using "Stuff2 1.0 2.0"
02:37:36 <merijn> Stuff2 is a a type alias
02:37:49 <merijn> "type Foo = Bar" just says "Foo is an alias for the type Bar"
02:38:07 <guibou> merijn: yes, but If I cannot use it to create object, what is the point of it ?
02:38:22 <merijn> fractalsea: Sounds like you shouldn't be using typeclasses for that...
02:38:36 <merijn> guibou: To simplify complicated type signatures
02:38:45 <fractalsea> merjin: what would be your solution?
02:38:58 <mjrosenb> guibou: and to make types work for classes.
02:39:04 <merijn> fractalsea: This sounds a lot like trying to do OO interfaces or something
02:39:11 <merijn> fractalsea: What exactly are you trying to do?
02:39:16 <fractalsea> merjin: yes, it is
02:39:38 <guibou> merijn: ok.
02:39:50 <guibou> mjrosenb: I'm not sure I understand you answer.
02:42:11 <solatis> hmm if i can get away with using non-monadic code, should I do so?
02:42:18 <mjrosenb> guibou: if a class Foo a asks for type Bar, you can satisfy Bar with a type alias. (as far as I know)
02:42:25 <tdammers> solatis: define "get away with"
02:42:26 <merijn> solatis: Maybe, maybe not, it depends.
02:42:30 <merijn> solatis: Does that help? ;)
02:42:35 <solatis> no :)
02:42:50 <solatis> in my case, i'm writing some networking library
02:42:53 <solatis> it needs a context
02:42:55 <merijn> solatis: What cost are you worried about?
02:42:59 <guibou> Other naive question, I defined a type "data Vector = Vector Float Float Float" and I tried to define a (+) function such as (+) :: Vector -> Vector -> Vector      (Vector a b c) + (Vector a' b' c') = Vector (a + a') (b + b') (c + c') and it complains about an ambiguity in (+)
02:43:03 <tdammers> if the non-monadic code is equally elegant, then I'd go without monads
02:44:03 <mjrosenb> guibou: are you also implementing and instance for Num?
02:44:08 <solatis> ok, the non-monadic code would likely need the user of the library to always provide a "context" variable
02:44:31 <merijn> solatis: You mean user supplied context vs implicit context via IO?
02:44:36 <solatis> right
02:44:38 <guibou> mjrosenb: I finally implemented an instance for Num which works, But I don't understand why it does not work in the first version
02:44:51 <merijn> solatis: I would say go with explicit context. What if your library is used by multiple libraries in the same program?
02:45:00 <tdammers> merijn: what I'm making of it is Reader vs. an extra argument
02:45:01 <merijn> solatis: The implicit context might conflict
02:45:11 <fractalsea> merjin: I am writing some integration tests, and each one is made out of smaller “test components”, that you can compose together to create a test. The problem is these test components require different types of initialiseation to be done before they can be run. i.e. setting up a websocket connection, or require credentials. i.e. they have dependencies that the test component accesses in the reader monad. When the test components are glued togeth
02:45:12 <fractalsea> they may get more dependencies than they require (because another test they are glued to required them), so my solution was to use typeclasses: have a generic environment type that just needs to contain at least the fields it requires. Then a test is defined as a series of test components, and an environment that is an instance of all typeclasses required by the test components.
02:45:23 <tdammers> foo :: Context -> Thing -> Output vs. foo :: Thing -> Reader Context Output
02:45:42 <fractalsea> merjin: I’m new to Haskell, so if there’s a better way of doing this, I’d love to know
02:45:49 <solatis> merijn, you would have everything wrapped in a MyMonad type, and a runMyMonad function would execute everything
02:45:53 <guibou> mjrosenb: I have the "feeling" that a Num and a Vector are two different thing, so (+) :: Num -> Num -> Num and (+) :: Vector -> Vector -> Vector are unambiguous ?
02:46:02 <solatis> merijn, you are familiar with the haskell zeromq library i remember
02:46:15 <solatis> it is a great example that provides both a monadic and a non-monadic interface
02:46:47 <solatis> http://hackage.haskell.org/package/zeromq4-haskell
02:47:31 <solatis> the non-monadic code provides a withContext function, the monadic code wraps the context
02:47:36 <solatis> what should I do in my case?
02:47:41 <solatis> make the context explicit?
02:47:45 <merijn> fractalsea: That sounds rather more work, can't you do something along the lines of define a single setup type "Config -> IO MyTestSetup" now if you MyTestSetup can be made a monoid you could just have every test provide it's own "Config -> IO MyTestSetup", run them independently and mappend the resulting Setup to get the "right" setup value
02:48:06 <solatis> provide both a non-monadic and a monadic interface?
02:48:27 <merijn> solatis: Also an option, but please do account for the possibility of multiple initialisations
02:48:28 <solatis> (i could always start out with a non-monadic interface, and in a later stage write a monadic interface)
02:48:50 <solatis> merijn, how is that a risk?
02:48:51 <merijn> solatis: i.e., if my program uses two libraries that both use your code and they both call initialise things should work
02:49:09 <solatis> oh you mean global shared state/context?
02:49:18 <merijn> solatis: Depends on what your initialisation does :)
02:49:41 <solatis> well basically it would do nothing, but it would keep track of open sockets and close them
02:50:17 <EvanR> no managers!
02:50:33 <solatis> EvanR, don't worry, ResourceT to the rescue!
02:51:03 <solatis> (that's an idea, i could always just use ResourceT instead of writing my own monad)
02:52:16 <merijn> fractalsea: Basically, I have a similar thing in my own tests where I have a single Config record and all my setup functions for tests are just "Config -> IO Config" and then I can combine them by just piping my config through all of them and updating the record as it goes
02:52:22 <merijn> fractalsea: Does that make sense?
02:52:51 * merijn mumbles something about "there ain't no party, like a Kleisli party, because a Kleisli party composes"
02:52:59 <fractalsea> merjin: Thank you. I’m just trying to get my head around what you said, and how it would work in my case. I’ll let you know if I have further questions.
02:53:45 <solatis> or... maybe i should use Pipes
02:53:47 <solatis> or Conduit
02:53:49 <solatis> argh
02:53:58 <solatis> so many ways to do the same thing in haskell!
02:56:54 <lpaste> merijn pasted “sample test setup” at http://lpaste.net/120372
02:56:59 <tomphreek> > break ((/=) 2) (reverse [0, 1, 2, 3])
02:57:01 <lambdabot>  ([],[3,2,1,0])
02:57:14 <merijn> fractalsea: It might be a bit to complicated, but that is a (hastily stripped down) version of some of my tests
02:57:57 <tomphreek> break ((/=) 2) [3, 2, 1, 0]
02:58:04 <tomphreek> > break ((/=) 2) [3, 2, 1, 0]
02:58:05 <lambdabot>  ([],[3,2,1,0])
02:58:13 <merijn> fractalsea: "Endo Config" is basically the Monoid version of "Config -> Config" so my commandline parsers are returning a bunch of "Config -> Config" versions and composing them together
02:58:23 <merijn> fractalsea: Then I run my default config through all of those and run the result
02:58:53 <tomphreek> > break ((==) 2) [3, 2, 1, 0]
02:58:54 <lambdabot>  ([3],[2,1,0])
02:59:25 <merijn> fractalsea: If you need to do some IO setup you can use something like that but using "Config -> IO Config" to also compose the effects
02:59:41 <merijn> (Incidentally, do we have an EndoKleisli newtype somewhere? :>)
02:59:57 <fractalsea> merjin: So do you mean that the Config type would be something like { useWebsockets :: Bool } and then the MyTestConfig would contain { websocketConn = Just WebSocket.Connection } ? So all the test would have the same concrete environment type?
03:00:05 <bennofs> merijn: i've wanted that a couple of times
03:00:23 <fractalsea> merjin: I’ll check out the link now
03:00:53 <merijn> fractalsea: Yeah, define one environment for everything, marking optional things as "Maybe blah" and just have "Config -> IO Config" set the relevant fields to "Just"
03:03:36 <fractalsea> merjin: hmm OK. So would I need fromMaybes all over the place I guess?
03:06:54 * hackagebot sized-types 0.3.5.1 - Sized types in Haskell.  http://hackage.haskell.org/package/sized-types-0.3.5.1 (GergoErdi)
03:06:56 * hackagebot netlist-to-vhdl 0.3.2 - Convert a Netlist AST to VHDL  http://hackage.haskell.org/package/netlist-to-vhdl-0.3.2 (GergoErdi)
03:29:24 <simg> Hi, would anyone be willing to take a look at a relatively simple? postgres-simple problem I have. (It's to do with handling relations between database entities) https://github.com/lpsmith/postgresql-simple/issues/139
03:31:41 <alpounet> simg: i'm not sure i understand what you mean by: "but I wouldn't want postgres-simple to try to save (or load) the order items field", can you expand?
03:38:47 <simg> alpounet: the order items field wouldn't be an actual column in the db. it would be "implied" by a contraint on the order items table.
03:39:43 <alpounet> simg: yeah, i got that part. but does what you wrote mean that you don't want to retrieve the associated orders in the FromRow instance, or to store them in the ToRow instance?
03:39:59 <merijn> fractalsea: fromMaybe or maybe, yeah. You might be able to do it nicer, but it'd probably be more complicated to come up with, so might just wanna stick to the "simple" solutio for now
03:40:07 <merijn> fractalsea: Can always improve it later
03:40:08 <ab9rf> so it's a so-called computed field?  are you letting the db engine compute it, or are you computing it in the database shim?
03:40:42 <fractalsea> merjin: Yeah I think simple is probably the way to go. It’s already looking much nicer.
03:40:51 <ab9rf> oh, i understand
03:41:18 <fractalsea> merjin: Out of curiosity, what are typeclasses good for if they’re not meant to be used like OO interfaces? I naively thought that’s what they were for.
03:41:22 <ab9rf> you want the shim to expand the one-to-many relationship
03:41:40 <simg> alpounet: actually, if pg-simple were able to automatically save / retrieve associated order items when reading "orders", that would be very interesting (though I don't see that being possible?)
03:42:11 <ab9rf> simg: it would be possible to retrieve "automatically" but you might not want to because of the expense
03:42:23 <ab9rf> simg: autromatically saving is much harder
03:42:55 <alpounet> simg: you probably can do it with PG arrays
03:43:04 <ab9rf> the main problem is that a naive strategy requires deleting all the order_item records and recreating them, which is mean to the database engine
03:43:14 <alpounet> using array_agg with group by on your order id
03:43:20 <ab9rf> you need a more complicated data structure if you want to be more reasonable.
03:43:29 <alpounet> you'll need to change the order items field to a Vector or something like that though
03:43:51 <ab9rf> something that tracks changes and does a minimum necessary change
03:44:50 <merijn> fractalsea: There's a common sort of development everyone goes through learning haskell: 1) I don't understand typeclasses 2) Oh, they're like interfaces, I should use them everywhere 3) oh, actually, that's kinda messy and less flexible than I'd like
03:45:01 <alpounet> simg: also, you'll have to write a FromField/ToField instance for your order item type, like in https://github.com/lpsmith/postgresql-simple/issues/116
03:45:48 <fractalsea> merjin: haha, OK, well thanks for the advice :)
03:45:56 <merijn> fractalsea: Basically, typeclasses are incredible useful tools, but in practice I use them A LOT less than you'd use interfaces in OO
03:46:43 <merijn> fractalsea: One common (but not universal) opinion is that typeclasses should come with laws about what their instances do (because, otherwise it becomes hard to reason about them)
03:46:59 <bergmark> that's also because you usually don't use "upcasting" with type classes
03:47:00 * hackagebot data-filepath 2.2.0.0 - A type safe file path data structure  http://hackage.haskell.org/package/data-filepath-2.2.0.0 (domdere)
03:47:06 <bergmark> which is a good thing :-)
03:47:35 <merijn> fractalsea: For example, Functor has the law that "fmap id" must be the same as "id", Monoid has that "mappend x (mappend y z)" must be the same as "mappend (mappend x y) z" and that mempty is the identity, etc.
03:47:51 <merijn> fractalsea: Note that everything you can do with typeclasses can be done without them too
03:48:01 <merijn> @google Gabriel Gonzalez scrap your typeclasses
03:48:03 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
03:48:03 <lambdabot> Title: Haskell for all: Scrap your type classes
03:48:25 <merijn> fractalsea: See that blog post as an example of how, I've found it a useful pattern to use instead of defining ad hoc typeclasses
03:48:53 <fractalsea> merjin: hmm, OK sounds interesting
03:49:07 <merijn> The "Scrap Your Typeclasses" approach is a pretty decent way to do "OO Haskell"
03:50:17 <merijn> Although it'd benefit from indexed and extensible records and rowtyping (can't someone add those as a GSoC project? ;)
03:50:26 <fractalsea> merjin: I’ll check out that blog post. It would be good to learn what to reach for when I would initially think of using a typeclass
03:51:10 <merijn> fractalsea: Gabriel has a bunch more interesting blogpost on "haskell design patterns" on that blog too, like: http://www.haskellforall.com/2014/04/model-view-controller-haskell-style.html
03:51:38 <fractalsea> merjin: awesome
03:52:52 <chpatrick> wtf
03:52:58 <chpatrick> why doesn't mono-traversable have length?
03:53:19 <simg> isn't my problem an "ultra-common" pattern (ie persisting nested data structures to a db). I'm not wedded to pg-simple. I wonder how you guys would approach this?
03:54:25 <merijn> simg: How much data?
03:54:45 <alpounet> simg: either you take the approach i've outlined above, or you just "split" an order into an order + the associated order items, separately, and persist those separately, each to the appropriate table
03:54:49 <merijn> Like millions of records or like 100s/1000s of records?
03:55:09 <simg> mostly 100's to 1000s. but it would be nice if there wasn't an arbitrary limit
03:55:17 <merijn> simg: Look into acid-state?
03:55:31 <merijn> simg: It's a library for persisting haskell heap data structures with ACID guarantees
03:55:57 <merijn> simg: There's no real limit, but since it's in-memory and normal haskell data structures it doesn't really scale to "millions" of records
03:56:25 <simg> I am kind of wedded to postgres. If I can't get haskell to talk to relation db's then I'm stuck ...
03:56:40 <merijn> (by in-memory I meant he data is always in memory, it uses disk for persistance, otherwise it wouldn't be ACID :p)
03:57:11 <merijn> tbh I haven't used databases in ages and not from haskell, so I'm not really great at that :p
03:57:25 <merijn> You could try asking in #yesod too, presumably all the web people have database experience :)
03:57:36 <ab9rf> my experience is that there's no one way to persist data to a database
03:57:55 <ab9rf> there are, rather , many different strategies and the one that's right depends on your data use patterns etc.
03:58:18 <simg> alpounet: this suggests I need a Haskell data type that contains the items field and then another almost identical type that doesn't contain it just to enable saving with pg-simple?
03:58:45 <ab9rf> why would you need that?
03:59:18 <ab9rf> oh, because types determine ToField / FromField instances
03:59:31 <simg> yes :)
03:59:57 <arw_> is there a haskell library that not only does shell scripting but also does so with certain safety features?
04:00:05 <arw_> like using fchown, fexec, etc
04:00:09 <esimp> I'd like to use QuickCheck for testing "Matrix" operations.  How can I go about writing generating pairs of matrices with quickcheck?
04:00:13 <alpounet> simg: not necessarily, you can use tuples and things like that
04:01:03 <alpounet> simg: you can make Order's ToRow instance ignore the order items, and have a function that does Order -> (Order, [OrderItems]), and then you persist these two things separately
04:01:08 <alpounet> it's far from ideal though, I admit
04:04:41 <simg> I get the impression that the author of posgres-simple really means it when he describes it as "experimental" (like he seems to not be happy with the whole FromRow / ToRow approach. Is there a better postgres option? (all the other libraries I've looked at either seem very immature or very verbose or both!)
04:06:59 <mjrosenb> Polarina: you up for a couple of sdl2 questions?
04:07:26 <mjrosenb> actually, I think my question is related to modules, the modules I've implemented/used have always been quite basic.
04:08:53 <simg> also, I've tried changing my FromRow instance but I couldn't work out what to put in place of the appropriate "field"
04:11:07 <Polarina> mjrosenb, go ahead.
04:14:58 <mjrosenb> ok, so the .cabal file makes it sound like Graphics.UI.SDL.Raw should exist, and have things, like Surface in it.
04:15:36 * mjrosenb has not figured out how to access this from ghci, nor from sdl2_image.
04:15:49 <hop> hello all, would you know how to change the "build" directory with cabal i.e. the location of "dist"?
04:15:53 * mjrosenb wasn't really sure what it was called, until I inspected the .cabal file.
04:15:56 <alpounet> simg: postgresql-simple is great for the very common scenarios, less so for more custom things where you have to roll up your sleeves and deal with internal & ugly things
04:15:57 <lpsmith> simg, when retreiving a row,  you can always either avoid making a custom FromRow instance,  or you can write fromRow = Order <$> field <*> field <*> pure []
04:16:32 <Polarina> mjrosenb, have you run `cabal install` yet?
04:16:37 <bernalex> I have a stack like ["1", "1", "+"] -- what pretty printing library would be useful for printing this as a tree (with "+" as the root) ?
04:16:43 <Polarina> mjrosenb, after that, ghci should be able to import the modules.
04:17:05 <simg> lpsmith: ah, pure [] is the answer.  curious: how can I avoid making a custom FromRow instance?
04:17:49 <mjrosenb> Polarina: yeah, I can see most other things
04:17:54 <mjrosenb> just not Raw.
04:18:11 * mjrosenb is also like 99% sure he's looking at sdl2 and not SDL.
04:18:27 <Polarina> mjrosenb, did you install the package from Hackage or the one from Github?
04:18:57 <mjrosenb> from hackage.
04:19:00 <mjrosenb> riiight
04:19:00 <bernalex> I think maybe prettytree would work well.
04:19:10 <lpsmith> just something like    (x, y) <- query ...;   return $! Order x y []
04:19:12 <mjrosenb> someone already tod me to use it from github, not from hackage
04:19:20 <Polarina> mjrosenb, the one on Github is in development -- it's quite different.
04:19:22 <mjrosenb> uhhh, so I can't uninstall it with cabal.
04:19:35 <mjrosenb> Can I?
04:19:42 <lpsmith> simg, I find I tend to write most of my sql in a usually straightforward-ish helper function
04:19:54 <Polarina> mjrosenb, you can unregister it from ghc, but you can also just install the one from Github if you want to use that.
04:20:11 <simg> lpsmith: any pointers would be appreciated :)
04:20:56 <lpsmith> simg, well,  to be honest I haven't really written anything resembling a standard CRUD app using postgresql-simple yet =)
04:21:43 <simg> lpsmith: ha, that explains a lot :)
04:21:51 <mjrosenb> Polarina: any idea on the timeframe of getting an updated package in hackage?
04:22:48 <mjrosenb> *jesus*, sdl2 now pulls in a large number of packages.
04:23:17 <Polarina> mjrosenb, none, unfortunately. The one one Github is radically different, and somewhat incomplete too (but easily usable).
04:24:08 <mjrosenb> Polarina: but the one in hackage is an older revision of the github one we've been talking about, right?
04:24:35 <simg> lpsmith: does the approach of using "pure []" to "hide" the items field from pg-simple seem like a reasonable approach?
04:24:36 <Polarina> mjrosenb, yes, but it's still maintained.
04:25:14 <Polarina> mjrosenb, the Hackage version (the 1.x series) are very low-level bindings.
04:25:38 <Polarina> mjrosenb, the Github version is an attempt to a much higher-level abstraction on top of the lower-level bindings.
04:25:44 <mjrosenb> *nod*
04:26:20 <mjrosenb> this makes sense why the haskell wiki page on sdl makes references to both sdl2 and hssdl2
04:26:34 <Polarina> hssdl2 is a whole another thing. :)
04:26:35 <mjrosenb> where hssdl2 says it has been deprecated in favor of sdl2
04:26:54 <ab9rf> i've never had any luck with sdl in haskell
04:26:57 <ab9rf> maybe i should try again
04:27:11 <mjrosenb> ab9rf: it's the wild west, man
04:27:16 <alpounet> http://github.com/haskell-game/sdl2 works well for me
04:27:18 <mjrosenb> ab9rf: make sure you bring your git with you.
04:29:12 <ab9rf> my git's a bit tired these days
04:41:35 <Yuras> how to suppress hpc output? it writes one line per file when generating report, it is too much for my 90 modules
04:44:51 <Polarina> Yuras, you can use the --exclude argument to hpc. https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/hpc.html#idp21300768
04:45:27 <hexagoxel> how do i show the currently used package databases from within ghci?
04:45:48 <hexagoxel> `:show paths` does not seem to do the trick
04:45:53 <Polarina> hexagoxel, $(ghc-pkg list)
04:46:08 <Yuras> Polarina: hmm, I don't want to exclude modules, I want hpc to write reposts silently
04:46:39 <mauke> redirect to /dev/null?
04:47:17 <Yuras> mauke: well, I run it via cabal, so not sure it is possible...
04:48:53 <Yuras> hmm, I just realized that I'm not sure, who generates this output, hpc or cabal...
04:49:26 <mauke> >/dev/null 2>&1  # sweet silence
04:50:30 <Yuras> mauke: it will silent all cabal output, not just hpc
04:50:56 <hexagoxel> Polarina: you mean i should install ghc-pkg-libs, enable template haskell, then use that?
04:51:09 * Polarina writes to /dev/stdin, guaranteeing errno safe shelter within the cores.
04:51:26 <Polarina> hexagoxel, no. It's a command you can run from your terminal.
04:51:58 <hexagoxel> Polarina: in that case, you did not answer my question
04:52:04 * hackagebot darkplaces-text 0.1 - Parser for darkplaces colorful text  http://hackage.haskell.org/package/darkplaces-text-0.1 (slava)
04:52:20 <Polarina> hexagoxel, then what was the question?
04:52:30 <mauke> <hexagoxel> how do i show the currently used package databases from within ghci?
04:53:58 <Zemyla> Hmm. ContT can't be implemented any more efficiently than it already is, can it? Because its implementation is just a newtype wrapper around a function and that function is written pretty much exactly how Djinn says to?
04:54:05 <Polarina> ghc-pkg can list this package database, which ghci uses.
04:54:28 <bennofs> hexagoxel: maybe :show packages ?
04:54:35 <mauke> Polarina: so how do you run ghc-pkg from within ghci?
04:55:04 <bennofs> mauke: :!ghc-pkg
04:56:06 <Polarina> mauke, :! ghc-pkg list
04:56:22 <hexagoxel> yeah, i am aware of `:!`, but that does not get me anywhere, because i want to know the database that _ghci_ actually uses, not the ones listed when i ghc-pkg or cabal sandbox hc-pkg
04:56:56 <Polarina> I'm not sure what it is you want. ghci uses that database.
04:56:59 <hexagoxel> (++ " list) <$>
04:57:13 <dcoutts_> hexagoxel: :show packages  gives you something
04:58:08 <lpsmith> simg, probably, but I don't know enough about what you are doing
04:58:26 <bennofs> dcoutts_: doesn't seem to work. I just did ghc-pkg init /tmp/foo and the ghci -package-db /tmp/foo, and ghci :show packages doesn't list /tmp/foo
04:58:58 <dcoutts_> bennofs: oh, hmm, I would have expected that it did.
04:59:14 <bernalex> is there no 'a -> [(a, b)] -> Maybe a'?
04:59:26 <dcoutts_> bennofs: perhaps it only shows -package flags
04:59:29 <mauke> :t lookup
04:59:30 <dcoutts_> and not dbs
04:59:30 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
04:59:50 <mauke> bernalex: why Maybe a?
05:00:00 <bernalex> mauke: because I want the a not the b?
05:00:05 <mauke> what a?
05:00:16 <bernalex> the a in [(a, b)]
05:00:27 <mauke> bernalex: that contains 0 or more a's
05:00:31 <tdammers> (`elem` . map fst) ?
05:00:36 <tdammers> uhm no
05:00:50 <bernalex> mauke: not in this case.
05:00:52 <tdammers> nm, ignore me
05:00:58 <bernalex> mauke: well, it contains 1 or 0
05:01:01 <mauke> then why do you have a list?
05:01:09 <mauke> and what is the first argument for?
05:01:20 <bernalex> mauke: oh right. it has several 'a's, sorry, but they are unique.
05:01:39 <mauke> foo x _ = Just x
05:01:42 <hexagoxel> bennofs, dcoutts_: yeah, exactly. thanks for your suggestions though :)
05:01:47 <bernalex> tdammers: presently using filter & pattern matching on [a], heh.
05:02:03 <bernalex> mauke: I'm asking if this actually exists somewhere.
05:02:10 <mauke> what is "this"?
05:02:17 <tdammers> :t solveMyProblemKThx
05:02:18 <lambdabot> Not in scope: ‘solveMyProblemKThx’
05:02:20 <tdammers> dammit
05:02:45 <bernalex> mauke: 'a -> [(a, b)] -> Maybe a' like lookup but returning Just a or Nothing.
05:03:05 <mauke> so you want it to return the argument you passed in in the first place? why?
05:03:09 <bernalex> tdammers: I have already solved it in multiple ways. it would be nice if someone else already had it.
05:03:44 <mniip> bernalex, what part does b play
05:03:46 <bernalex> mauke: no I don't actually. it's part of a bigger expression that I'm too busy to explain now, since this didn't really lead anywhere quickly enough. :) thanks tho.
05:04:01 <mauke> what
05:04:17 <bernalex> lol
05:04:18 <mniip> 'map fst' sounds like a good first step
05:04:21 <tdammers> mniip: I'm guessing none at all except that [(a,b)] happens to be what you have
05:04:22 <bernalex> sorry for being bad at explaining - got to go
05:04:33 <tdammers> so yeah, map fst and then a -> [a] -> Maybe a
05:04:46 <bernalex> ^ is what I'm basically doing atm fwiw
05:04:52 <bennofs> bernalex: find (== a) . map fst ?
05:05:06 <bernalex> bennofs: where is find from?
05:05:07 <tdammers> :t find
05:05:08 <lambdabot> (a -> Bool) -> [a] -> Maybe a
05:05:11 <bernalex> oh List
05:05:21 <tdammers> how did I not know this one?
05:05:23 <bernalex> bennofs: that'll do better than filter or elem or whatever -- thanks!
05:05:44 <tdammers> headMay . filter (== a) . map fst -- was what I had in mind
05:06:07 <bernalex> tdammers: I had that but pattern matching instead of headMay
05:07:26 <tdammers> hehe... that's haskell culture for you... not, "guys, I have this code but it's not working", but "guys, I have this code, and it does exactly what I want, but I feel it's not quite elegant enough"
05:07:57 <bernalex> :-P
05:09:08 <mniip> (. map fst) . find . (==)
05:09:29 <bernalex> actually I have the lovely expression
05:09:31 <bernalex> p m = (Sop <$> find ((== m) . desc) (fst <$> os)) <|> Snum <$> (readMay m :: Maybe Double)
05:09:33 <bennofs> mniip: I'd go for \a -> find (== a) . map fst
05:09:33 <bernalex> LOL
05:09:41 <mniip> :t (. map fst) . find . (==)
05:09:42 <lambdabot> Eq b => b -> [(b, b1)] -> Maybe b
05:11:27 <tdammers> oh, still side-tracked on that calculator thingie?
05:11:59 <phaazon> is there a function deleteAt :: [a] -> Int -> [a] ?
05:12:06 <phaazon> @hoogle [a] -> Int -> [a]
05:12:10 <lambdabot> Prelude drop :: Int -> [a] -> [a]
05:12:10 <lambdabot> Data.List drop :: Int -> [a] -> [a]
05:12:10 <lambdabot> Prelude take :: Int -> [a] -> [a]
05:12:25 <bennofs> phaazon: i don't think there is.
05:12:36 <phaazon> I guess it's a take / drop work around
05:12:43 <mauke> :t \n -> uncurry (++) . fmap (drop 1) . splitAt n
05:12:44 <lambdabot> Int -> [a] -> [a]
05:13:03 <bennofs> :t \n -> map snd . filter ((/= n) . snd) . zip [0..]
05:13:04 <lambdabot> Eq b => b -> [b] -> [b]
05:13:11 <bennofs> :t \n -> map snd . filter ((/= n) . fst) . zip [0..]
05:13:12 <lambdabot> (Num b1, Eq b1, Enum b1) => b1 -> [b] -> [b]
05:13:23 <mniip> phaazon, ap (ap . ((++) .) . take) (drop . (1 +))
05:13:24 <tdammers> let deleteAt p xs = take p xs ++ drop (succ p) xs in deleteAt 5 [1..10]
05:13:28 <tdammers> > let deleteAt p xs = take p xs ++ drop (succ p) xs in deleteAt 5 [1..10]
05:13:30 <lambdabot>  [1,2,3,4,5,7,8,9,10]
05:13:41 <bennofs> :t splitAt
05:13:42 <tdammers> almost
05:13:42 <lambdabot> Int -> [a] -> ([a], [a])
05:14:41 <mniip> (uncurry ((. tail) . (++)) .) . splitAt
05:14:44 <mniip> sounds pretty sane
05:15:03 <bennofs> > uncurry (++) . second (drop 1) . splitAt 0 [1.10]
05:15:04 <lambdabot>  Couldn't match expected type ‘a -> ([a1], [a1])’
05:15:04 <lambdabot>              with actual type ‘([a0], [a0])’
05:15:05 <tdammers> wait what, are you a human @pl?
05:15:11 <bennofs> > uncurry (++) . second (drop 1) . splitAt 0 $ [1.10]
05:15:11 <mniip> needs more $
05:15:12 <lambdabot>  []
05:15:15 <bennofs> ops
05:15:32 <bennofs> > uncurry (++) . second (drop 1) . splitAt 3 $ [1..10]
05:15:34 <lambdabot>  [1,2,3,5,6,7,8,9,10]
05:15:44 <mniip> > (uncurry ((. tail) . (++)) .) . splitAt $ 3 $ [1..10]
05:15:45 <lambdabot>  No instance for (GHC.Num.Num ([t0] -> GHC.Types.Int))
05:15:45 <lambdabot>    arising from the literal ‘3’No instance for (GHC.Enum.Enum t0)
05:15:45 <lambdabot>    arising from the arithmetic sequence ‘1 .. 10’
05:16:03 <chpatrick> https://gist.github.com/chpatrick/572954198bb9e1c8b1cc
05:16:09 <chpatrick> is this useful for anyone?
05:16:14 <mniip> works over here...
05:16:27 <mauke> mniip: 3 $ ...? I doubt it
05:16:39 <mniip> associativity
05:16:40 <bennofs> > ((uncurry ((. tail) . (++)) .) . splitAt) 3 [1..]
05:16:42 <mniip> dang
05:16:42 <lambdabot>  [1,2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
05:16:57 <mniip> but yes I am human pl, why
05:17:06 <mauke> > ((uncurry ((. tail) . (++)) .) . splitAt) 3 [1,2]
05:17:07 <lambdabot>  [1,2*Exception: Prelude.tail: empty list
05:17:17 <tdammers> mauke: I knew that
05:17:17 <mauke> > (\n -> uncurry (++) . fmap (drop 1) . splitAt n) 3 [1,2]
05:17:18 <lambdabot>  [1,2]
05:17:37 <mniip> ooh dang
05:17:57 <tdammers> hmmm how about something Arrowy
05:17:59 * bennofs wisely used drop 1 instead of tail  :)
05:18:09 <mniip> ((uncurry (++) . fmap (drop 1)) .) . splitAt
05:18:39 <mniip> I should make a tool to do it for me :/
05:18:52 <mniip> but without the ap/>>=/liftM17 nonsense
05:19:14 <tdammers> > ((uncurry (<>) . (<$> drop 1)) .) . splitAt -- why not applicative and monoid? :D
05:19:16 <lambdabot>  Couldn't match expected type ‘(c, a0)’
05:19:16 <lambdabot>              with actual type ‘[a1] -> [a1]’Couldn't match type ‘([a], [a])’ ...
05:19:16 <lambdabot>  Expected type: GHC.Types.Int -> [a] -> a0 -> c
05:19:39 <bennofs> > (fmap (uncurry (++) . second (drop 1)) . splitAt) 3 [1..10]
05:19:40 <lambdabot>  [1,2,3,5,6,7,8,9,10]
05:20:39 <bennofs> > (fmap (uncurry (++) . fmap (drop 1)) . splitAt) 3 [1..10]
05:20:40 <lambdabot>  [1,2,3,5,6,7,8,9,10]
05:22:06 * hackagebot Hoed 0.2.0 - Lighweight algorithmic debugging based on observing intermediate values and the cost centre stack.  http://hackage.haskell.org/package/Hoed-0.2.0 (faddegon)
05:22:08 * hackagebot monad-logger 0.3.12 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.12 (MichaelSnoyman)
05:32:52 <meretrix> My application ran for weeks and then crashed when sending a email via SMTP (which normally works) with the message "getAddrInfo: does not exist (Name or service not known)".  Is this something that can be caught?
05:33:02 <meretrix> I assume it's an error from a C library.
05:33:20 <mniip> > let da = (map snd .) . (. scanl ((,) . (1 +) . fst) (0, undefined)) . filter . (. fst) . (/=) in da 3 "helloworld"
05:33:21 <lambdabot>  "*Exception: Prelude.undefined
05:34:04 <julianleviston> meretrix: domain name lookup failed
05:34:44 <mniip> oop forgot a tail
05:34:51 <mauke> meretrix: you'd have to catch the exception
05:35:00 <mniip> > let da=(map snd .) . (. (tail . scanl ((,) . (1 +) . fst) (0, undefined))) . filter . (. fst) . (/=) in da 3 "helloworld"
05:35:01 <lambdabot>  "heloworld"
05:35:24 <meretrix> mauke: How do I figure what the exception is called?  It doesn't look like a Haskell exception..
05:35:34 <meretrix> Just use "catchAny"?
05:35:38 <mauke> it looks exactly like a haskell exception
05:36:08 <mauke> http://hackage.haskell.org/package/base-4.7.0.2/docs/System-IO-Error.html#v:doesNotExistErrorType <- this one
05:36:29 <mauke> so catchIOError
05:36:51 <meretrix> mauke: Ah thanks.  How did you know it was that type?
05:37:17 <mauke> I've seen a few haskell exceptions before, so I just hoogled for doesnotexist
05:39:04 <gregnwosu> how can i return the left value from within the either monad?
05:39:05 <hodapp> hmm, I am in the situation in which I'm needing to sort of simultaneously have things in two monads because in some cases it's expressing dependencies
05:39:25 <hodapp> but I've no idea if there's a clean way to abstract this in a way that I can avoid having to explicitly do it in both
05:39:44 <c_wraith> gregnwosu: however you want.
05:40:13 <hodapp> would this be some variety of monad transformer?
05:41:14 <tdammers> hodapp: how would something "be in two monads simultaneously"?
05:41:14 <gregnwosu> c_wraith: I have EitherT PhantomTypeA (StateT stateType IO) PhantomTypeB
05:42:46 <c_wraith> gregnwosu: What type would you like an operation to have?
05:43:32 <gregnwosu> c_wraith: i want an stateful io operation with a possibility of failure
05:44:29 <c_wraith> gregnwosu: you've got one. What do you want to do with it?
05:45:40 <hodapp> tdammers: well, loosely, I have N different monad types and in various cases the only sensible construct involves also having N things based on the same term bound into each monad.
05:45:53 <ab9rf> heh
05:45:56 <gregnwosu> c_wraith: i inspect the type of io operation result (a http call) if its not 200 then i want to return the left side of the either
05:46:16 <c_wraith> gregnwosu: what do you mean by "return the left side of the either"?
05:46:25 <c_wraith> gregnwosu: do you want to produce a failing value?
05:46:33 <gregnwosu> c_wraith: yes
05:46:50 <ab9rf> hoist away maties!
05:47:08 * hackagebot casadi-bindings 2.2.0.4 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.2.0.4 (GregHorn)
05:47:10 <mauke> gregnwosu: http://hackage.haskell.org/package/EitherT-0.2.0/docs/Control-Monad-Trans-Either.html
05:47:34 <tdammers> EitherT is nice
05:47:42 <hodapp> tdammers: for instance, I get this with the Ivory library in which one monad expresses a C procedure, and the other expresses a C module. If the procedure references a (C) function, the module needs to declare that function.
05:48:13 <tdammers> ah
05:48:15 <gregnwosu> mauke: ah looks like left is what i need
05:48:26 <tdammers> isn't that like the textbook use case for typeclasses?
05:48:35 <mauke> ~the magic of rtfm~
05:49:03 <hodapp> tdammers: 'function' here is in the sense of a specific monad that expresses what is turned into a C procedure at runtime.
05:49:15 <gregnwosu> mauke: its awesome!! rtfm works every time!
05:49:16 <tdammers> yes, sure...
05:49:27 <tdammers> but said monad can still implement a typeclass, right?
05:49:33 <ab9rf> rtfm is only as good as tfm
05:49:46 <tdammers> tfm is by definition fine
05:49:52 <tdammers> otherwise it'd be called tsm
05:50:06 <tinchos> Hi everyone! Are there any way to lift Instances or generalize the concept of Instances? Suppose I have a type like Id (data Id a = I a), can I write something like "instance (SomeInstance a) => SomeInstance (Id a) where f1 id1 = f1 =<< id1" ???
05:50:13 <hodapp> tdammers: for a Module to declare that function just means that it has bound within it some call to 'incl'.
05:50:14 <ab9rf> i think you're using an alternative expansion of the 'f' there :)
05:50:37 <hodapp> tdammers: so typeclasses might be the answer but I'm struggling to see how.
05:50:58 <tdammers> well, I don't think I'm deep enough in the trenches of your project to see an obvious answer ;D
05:51:32 <hodapp> I'll see if I can turn it into a test case
05:51:42 <hodapp> I don't think the specifics much matter
05:52:33 <hodapp> hmm... perhaps StateT with a Set inside, and the Set collects unique definitions of procedures I reference
05:53:07 <hodapp> and then the other monad can get a list of unique reference from that, and use that information to declare dependencies.
05:54:14 <hodapp> of course then I'd have to lift a bunch of EDSL definitions too
05:55:29 <AzureVani> lambdabot:
05:55:44 <meretrix> Is there really no "takeLastN :: Int -> [a] -> [a]" defined in a standard library?
05:55:59 <meretrix> It seems like such a common requirement.
05:56:08 <bennofs> meretrix: no, but you can write reverse . take n . reverse
05:56:41 <meretrix> heaumer: Yeah, but that's not the most efficient way, and better versions are longer and a pain to write or redefine everytime I want it.
05:57:25 <hodapp> I guess 'track stuff in one monad while working within another' is sort of the textbook case for StateT...
06:02:09 * hackagebot mono-traversable 0.8.0 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.8.0 (MichaelSnoyman)
06:03:34 <Procian> > (last . getZipList . T.sequenceA . map ZipList) $ take 5 (tails [1..1000])
06:03:36 <lambdabot>  [996,997,998,999,1000]
06:04:28 <jtanguy> huh. I tried to find a way to implement the dropAt with lens, but lambdabot seems to fail
06:04:32 <benzrf> :t ala ZipList traverse
06:04:33 <lambdabot> Traversable t => t [b] -> Unwrapped (ZipList (t b))
06:04:52 <benzrf> > (last . ala ZipList traverse) take 5 [tails [1..1000])
06:04:54 <lambdabot>  <hint>:1:54: parse error on input ‘)’
06:04:57 <benzrf> > (last . ala ZipList traverse) (take 5 [tails [1..1000])
06:04:59 <lambdabot>  <hint>:1:55: parse error on input ‘)’
06:05:07 <benzrf> > (last . ala ZipList traverse) (take 5 (tails [1..1000]))
06:05:09 <lambdabot>  [996,997,998,999,1000]
06:05:12 <Procian> :t ala
06:05:13 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
06:05:18 <Procian> Ohhhh...
06:06:33 <jtanguy>  [1..10]^..traversed.indices (/= 3) should work, but I get an error (only with lambdabot)
06:07:14 <Procian> Since Lens came out, my knowledge of Haskell has dropped to single digit percentages in relative terms.
06:07:44 <benzrf> Procian: ala's type is incomprehensible to me
06:08:27 <Procian> Not sure if that's reassuring or not :)
06:08:40 <jtanguy> me too. for me ala is like a Data.Function.on on steroids
06:08:53 <benzrf> i just know how to use it with traverse and foldMap
06:08:54 <benzrf> :)
06:12:09 * hackagebot mono-traversable 0.8.0.1 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.8.0.1 (MichaelSnoyman)
06:18:44 <Yuu-chan> Procian: do you like Anathem?
06:19:44 <Procian> Yuu-chan: I thought it was pretty good, yeah. But I have to admit that I sided with the Procians against the platonists.
06:27:10 * hackagebot network-simple 0.4.0.3 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.4.0.3 (RenzoCarbonara)
06:28:33 <julianleviston> hm… just found a bug in Thinking Functionally with Haskell… huzzah
06:28:38 <julianleviston> sure I’m not the only one.
06:29:47 <jibi> I was wandering if it is possible to write something like ((+) . (+1)) 1 2 using the dollar notation
06:29:52 <julianleviston> not terribly inspiring, tho.
06:30:00 <jibi> the best I can get is ((+) . (+1) $ 1) 2
06:31:01 <chpatrick> anonymous foreign imports: https://gist.github.com/chpatrick/9803687aaf1b3def85d4
06:31:54 <jtanguy> jibi: (+1) $ (+) 1 2 ?
06:35:02 <jibi> jtanguy, yes, but in this way I discard the . operator
06:35:12 <jibi> (I was trying to resolv by hand an expression)
06:42:47 <thebnq> > ((.).(.)) (+1) (+) 2 3
06:42:49 <lambdabot>  6
06:42:52 <thebnq> jibi: ^?
06:43:42 <jtanguy> I don't think so. His example evaluates to 4
06:44:08 <jibi> I think I will keep the ((+) . (+1)) 1 2 form
06:44:34 <thebnq> > ((.).(.)) (+1) (+) 1 2
06:44:35 <lambdabot>  4
06:44:49 <jibi> or (fmap (+) (+1)) 1 2
06:44:59 <jtanguy> oh my bad, I didn't see that you used 2 3
06:45:06 <jibi> *or fmap )(+) (+1)) 1 2
06:45:47 <simg> lpsmith: that makes two of us :) ! - thx for help so far, I suspect adding "pure []" to my FromRow will get me quite a bit further
06:47:12 * hackagebot heroku-persistent 0.1.0 - Parse DATABASE_URL into configuration types for Persistent  http://hackage.haskell.org/package/heroku-persistent-0.1.0 (PatrickBrisbin)
06:47:14 * hackagebot process 1.2.2.0 - Process libraries  http://hackage.haskell.org/package/process-1.2.2.0 (HerbertValerioRiedel)
06:47:16 * hackagebot file-location 0.4.7 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.7 (GregWeber)
06:51:08 <julianleviston> is / a function?
06:51:21 <tdammers> :t (/)
06:51:22 <lambdabot> Fractional a => a -> a -> a
06:51:37 <merijn> julianleviston: All operators are functions in haskell
06:51:57 <merijn> julianleviston: The only difference between "operators" and "functions" is the characters allowed in the name
06:51:58 <julianleviston> oh… the parens! THAT was why I couldn’t look up its type in hgci
06:52:12 * hackagebot tzdata 0.1.20150129.0 - Time zone database (as files and as a module)  http://hackage.haskell.org/package/tzdata-0.1.20150129.0 (MihalyBarasz)
06:52:15 <merijn> julianleviston: Right, parenthesis turn operators into "prefix notation"
06:52:23 <bergmark> julianleviston: it's actually a type class method, so it has one implementation for each fractional type
06:52:26 <merijn> Similarly backticks turn functions into infix notation
06:52:37 <merijn> > 3 `elem` [1..10] -- see this example
06:52:38 <lambdabot>  True
06:53:01 <julianleviston> merijn: oh yeah I knew the backtick notation, and had seen the parens, but I’d forgotten it
06:53:05 <Procian> julianleviston: And then you have sections:
06:53:07 <Procian> :t (/ 3)
06:53:08 <lambdabot> Fractional a => a -> a
06:53:14 <Procian> :t (3 /)
06:53:15 <lambdabot> Fractional a => a -> a
06:53:24 <julianleviston> Procian: yeah I know that… it’s like partial application, right?
06:53:46 <julianleviston> Procian: ratnir O
06:53:49 <Yuu-chan> Procian: me too :) Though, I think it should be common in programmers, especially those dealing with PL theory
06:53:52 <julianleviston> Procian: rather I’ve seen that.
06:53:52 <Procian> julianleviston: Yep. Except slightly cooler, because you can partially apply on the right-hand side.
06:54:17 <julianleviston> Procian: !cooler slightly is that
06:54:35 <julianleviston> Procian: excuse the associativity joke ;-)
06:55:18 <julianleviston> reverse ["cooler", "slightly", "is", "that"]
06:55:36 <julianleviston> > reverse ["cooler", "slightly", "is", "that"]
06:55:38 <lambdabot>  ["that","is","slightly","cooler"]
06:56:46 <Procian> julianleviston: Associative+commutative?
06:57:48 <julianleviston> Procian: hehe… I spent my morning re-reading about associativity and commutativity… I need to re-read. I like that it’s com-MUTATIVITY. ;-)
06:57:56 <Procian> Yuu-chan: I spent most of my time on my PhD bashing at a theorem prover, thinking more in mindless syntax than the geometry I was supposed to be formalising. I used to say I was very much a formalist during the week.
06:58:24 <julianleviston> Procian: I didn’t realise it’d be so prevalent in Haskell…
06:58:57 <merijn> It's because we like to *understand* our code :p
07:00:07 <julianleviston> merijn: we do.
07:00:21 <julianleviston> merijn: probably the most I’ve yet seen :)
07:00:30 <tdammers> personally, I like to think of it as the difference between *thinking* our code is correct, and *knowing* that it is
07:00:56 <tdammers> (where "correct" is obviously not a boolean, but a complex multi-faceted multi-level beast in its own right)
07:01:29 <tdammers> and I prefer making my types more strict over adding more unit tests
07:03:14 <julianleviston> is . a function?
07:03:25 <bergmark> @src (.)
07:03:25 <lambdabot> (f . g) x = f (g x)
07:03:27 <julianleviston> I wish the syntax was a little clearer, though. It’s not exactly simple.
07:03:27 <Procian> Try it the same way you did for /
07:03:44 <cmtptr> do you guys tend to prefer >>= or =<<?
07:03:53 <julianleviston> ooh thanks.
07:04:00 <julianleviston> Procian: sorry!
07:04:01 <bergmark> cmtptr: =<< for me
07:04:13 <merijn> cmtptr: >=> ! :p
07:04:16 <bergmark> it reads the same way as (.) and (<$>)
07:04:35 <init> I'd say it depends
07:04:38 <bergmark> as well as <- in do notation
07:04:41 <julianleviston> bergmark:  what did you do there ? what does @src do? get the source? does that work in ghci?
07:04:43 <cmtptr> yeah, at first I was inclined to use >>= because it flows like sh, but then I noticed how weird it is that the right hand side is backwards if it's a bunch of functions composed
07:04:45 <julianleviston> bergmark: I’ll try
07:04:51 <bergmark> julianleviston: that's a lambdabot thing
07:04:55 <merijn> julianleviston: @src just looks up strings in a text database
07:04:58 <julianleviston> bergmark: just worked that out :)
07:05:01 <julianleviston> ah...
07:05:13 <merijn> julianleviston: Hackage has links to source in the docs of everything, though
07:05:16 <julianleviston> merijn: can one find the source or doc at ghci?
07:05:39 <julianleviston> merijn: I kind of which docs were built in to the language.
07:05:49 <julianleviston> which = wish*
07:05:58 <merijn> julianleviston: No, but if you edit "~/.cabal/config" and set "Documentation: True" it will build local HTML docs for all installed packages
07:06:07 <merijn> Which include source links
07:06:12 <julianleviston> merijn: that’s a pity
07:06:32 <Procian> I thought you could hook lambdabot into GHCi.
07:06:41 <merijn> You can probably add a function that brings up the source from HTML from within ghci
07:06:48 <merijn> But it's not always that useful :)
07:07:27 <julianleviston> merijn: it’s very pedagogically useful to have the source at a REPL
07:07:59 <julianleviston> merijn: and the docs.
07:08:01 <merijn> Except when that source is highly optimised or just a call to another local function :)
07:08:07 <julianleviston> merijn: having the types mitigates that a bit.
07:08:36 <merijn> julianleviston: You can run Hoogle locally and I think you can query it for docs?
07:08:42 <merijn> (from the commandline)
07:08:46 <cmtptr> is there are (.) analog to (=<<)?
07:08:51 <cmtptr> s/are/a
07:08:58 <julianleviston> merijn: erm…. your previous comment: “It's because we like to *understand* our code”
07:09:09 <julianleviston> merijn: cool :)
07:10:05 <merijn> julianleviston: Understand as in what it does by being able to reason about it. Optimised code is not always trivial to read, but the type system and good abstractions let you reason about code without having to understand every small part
07:10:14 <merijn> cmtptr: I just mentioned it :p
07:10:17 <merijn> :t (>=>)
07:10:18 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:10:27 <cmtptr> that's monady though
07:10:27 <julianleviston> merijn: I was really just poking fun :)
07:10:40 <Procian> cmtptr: Are you thinking of a flip ($) ?
07:10:42 <merijn> :t (=<<)
07:10:43 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:10:46 <cmtptr> I just mean a (.) with the arguments flipped
07:10:57 <merijn> :t (>>>)
07:10:58 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
07:11:06 <tdammers> it's interesting how a haskeller's first reflex is to sort out the types rather than read the documentation :D
07:11:08 <merijn> :t (>>>) `asAppliedTo` even
07:11:09 <lambdabot> Integral a => (a -> Bool) -> (Bool -> c) -> a -> c
07:11:18 <julianleviston> merijn: having said that, I’ve learnt a lot from reading source…:)
07:11:28 <julianleviston> merijn: it’s often very educational
07:11:48 <thebnq> yeah, often i read descriptions and think "wat" and then click source :p
07:13:15 <merijn> I think part of the problem is that "advanced haskellers" approach problems very different from beginner haskellers and I don't know of any good books to cross the gap yet. Maybe it's just a matter of repeated exposure and hitting your head against things...
07:13:44 <ab9rf> check head for lumps
07:13:48 <julianleviston> merijn: thinking functinoally with haskell?
07:13:52 <tdammers> merijn: I think a lot depends on previous background
07:13:54 <julianleviston> merijn: functionally *
07:14:11 <tdammers> I bet someone with no programming experience at all will hit different road bumps than someone coming from, say, Python
07:14:18 <merijn> I mean, I remember being thoroughly confused and now like several years later a beginner asks a question and I think things like "oh, that's easy, just use an EndoKleisli monoid"
07:14:21 <merijn> tdammers: Sure
07:14:48 <merijn> tdammers: But I'm assuming beginner with "1 or 2 conventional languages" as experience
07:14:50 <ab9rf> merijn: i cringe at stuff like that, in part because i don't understand such things :)
07:14:58 <julianleviston> merijn: how about 10? lol
07:14:58 <merijn> ab9rf: It's really easy!
07:15:26 <julianleviston> merijn: wait, smalltalk, Lisp and Clojure are conventional, right?
07:15:28 <tdammers> I still suspect that most of the CT mumbo jumbo that I don't understand is for 98% a matter of knowing the right names for things
07:15:41 <merijn> ab9rf: "newtype Kleisli m a b = Kleisli (a -> m b)" with "instance Monad m => Arrow (Kleisli m)", etc. does that definition make sense?
07:15:58 <merijn> ab9rf: i.e. "Kleisli arrow == function with monadic result"
07:15:59 <ab9rf> merijn: no :)
07:16:04 <merijn> :t (.)
07:16:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:16:08 <merijn> :t (>=>)
07:16:09 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:16:27 <ab9rf> merijn: but i'm sleepy and right now "would you like a bagel" likely would not make sense to me
07:16:32 <merijn> See how those are the same, but in the first the Arrow is "->"
07:17:02 <merijn> In the second it's "Kleisli m" (i.e. will result in "a -> m b")
07:17:10 <hyPiRion> merijn: where does the monoid part come in?
07:17:17 * hackagebot profiteur 0.1.2.2 - Treemap visualiser for GHC prof files  http://hackage.haskell.org/package/profiteur-0.1.2.2 (JasperVanDerJeugt)
07:17:18 <merijn> hyPiRion: I don't cover Endo yet!
07:17:22 <hyPiRion> oh
07:17:32 <merijn> "newtype Endo a = Endo (a -> a)"
07:17:54 <ab9rf> not to be confused with enzo
07:17:58 <merijn> It's a monoid for functions (mempty = id, mappend = (.))
07:18:00 <julianleviston> merijn: how long were you confused for, if you don’t mind me asking?
07:18:29 <ab9rf> merijn: can i just have a bagel instead :)
07:18:30 <merijn> So EndoKleisli "newtype EndoKleisli m a = EndoKleisli (a -> m a)"
07:18:44 <merijn> With mempty = return and mappend = (>=>)
07:19:02 <merijn> julianleviston: Better part of like 2 years at least
07:19:11 <merijn> julianleviston: Hell, I'm STILL confused :p
07:19:15 <S11001001> merijn: (<=<), no?
07:19:16 <julianleviston> lol
07:19:19 <merijn> I'm just confused at a more advanced level
07:19:23 <ab9rf> heh
07:19:27 <merijn> S11001001: Both work, actually
07:19:34 <ab9rf> that's where i am too, although at a somewhat lower level
07:19:36 <merijn> S11001001: But >=> has a more sensible order of effects
07:19:48 <S11001001> merijn: they look different to me
07:19:48 <merijn> :t (>=>)
07:19:49 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:19:53 <merijn> :t (<=<)
07:19:54 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
07:19:56 <ab9rf> there are things i'm not confused about as much but that has just opened up the possibility to be confused about all new things
07:20:01 <init> S11001001: this why categories are so cool
07:20:04 <S11001001> merijn: that is, (.) = (<=<) for Category Kleisli
07:20:14 <thebnq> ab9rf: thats how learning works :D
07:20:27 <merijn> S11001001: I was saying EndoKleisli so you can have a monoid ala Endo
07:20:35 <uwap> I just thought, how is this endokleisli a monoid? It is not even a magma.
07:20:48 <init> S11001001: newtype EndoKleisli m a = EndoKleisli (a -> m a)
07:20:51 <merijn> uwap: Why wouldn't it be a Monoid?
07:20:59 <S11001001> merijn: if you're going to make Endo the category-implied monoid, it seems inconsistent to use the Dual for one of them.
07:21:51 <merijn> julianleviston: I would say it took me maybe 6 months to 1 year to be able to write "real code", 2 years to feel comfortable doing my shell scripting in haskell, and the rest just learning all kinds of tricks and abstractions
07:21:58 <mjrosenb> I have 4 different versions of sdl2 installed, how can I tell which one is currently being loaded when I look at a module?
07:22:02 <merijn> julianleviston: Haskell has a higher "skill cap" than many other languages :)
07:22:02 <S11001001> merijn: not to say unlawful, just, odd.
07:22:11 <uwap> merijn, I just thought, how is this endokleisli a monoid? It is not even a magma. because types differ. then I realized that monoids are just mappings too.
07:22:19 <julianleviston> merijn: so it might not be reasonable to expect myself to learn it in a month or two then? :)
07:22:23 <uwap> *monads are just mappings too
07:22:30 <merijn> S11001001: I would expect "mconcat [f,g,h]" to first have the effects of f, then g, then h
07:22:41 <merijn> S11001001: mappend = (<=<) would be in reverse order
07:22:46 <julianleviston> merijn: the basics, obviously.
07:23:03 <julianleviston> merijn: I was actually thinking 6 weeks. haha :)
07:23:24 <hyPiRion> julianleviston: I started using Haskell because of work, and I'd guess I was doing "useful" stuff after about a month..
07:23:37 <merijn> julianleviston: Well, one problem is that haskell is flexible enough to define lots of abstractions in libraries. So learning haskell the language is a small part of being able write real world code
07:23:59 <julianleviston> merijn: yeah, I noticed that…
07:24:34 <S11001001> merijn: Yes.  But that's the order you get when you generalize the newtype+monoid instance http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-Monoid.html#Endo for all Category.
07:24:44 <merijn> julianleviston: First you tackle the language, then common typeclasses from base (i.e., Functor, Applicative, Monad, Monoid), then common libraries (transformers, plus the domain specific ones, i.e. pipes/conduits for streaming, parsec for parsing, etc.)
07:24:47 <julianleviston> merijn: I’d probably expect huge amounts of whatever I need to actually already have abstractions for somewhere…
07:25:28 <julianleviston> merijn: yeah  I’m really looking forward to typeclasses
07:25:30 <merijn> S11001001: oh, hah...
07:25:41 <nshepperd_> I assume that with Endo you read mconcat [f,g,h] as f . g . h
07:25:49 <merijn> S11001001: It's working differently from what I understood then :)
07:25:51 <S11001001> nshepperd_: yes.
07:25:53 <merijn> I stand corrects
07:25:56 <merijn> *corrected
07:26:05 <merijn> julianleviston: Typeclassopedia is a decent resource
07:26:14 <merijn> For after LYAH/whatever you're reading
07:26:16 <S11001001> nshepperd_: Well, however you read it, that's how it's defined :)
07:27:15 <merijn> julianleviston: In a lot of cases it's also just a matter of learning the jargon/names of things
07:28:00 <merijn> julianleviston: Stuff like knowing "Endo a" == "a -> a" is not hard to understand, just something to learn. People have argued that the community should use "friendlier names", but imo, that's overrated
07:28:00 <julianleviston> merijn: yeah, I noticed that, too… it’s mostly mapping things I already know really well and amusingly have wanted for years into my brain with a “new" name.
07:28:14 <merijn> "visitor pattern" is also not particularlu understandable if you don't know it
07:28:14 <arw_> @djinn [(a, Either b c)] -> ([(a, b)], [(a, c)])
07:28:15 <lambdabot> Error: Undefined type []
07:28:17 <tdammers> "endo" is fine
07:28:38 <julianleviston> merijn: neither is english
07:28:52 <merijn> Similarly "Kleisli m a b" == "a -> m b"
07:29:01 <julianleviston> merijn: making a set of conceps understandable is a different problem than solving things.
07:29:12 <arw_> @djinn (a -> b) -> [a] -> [b]
07:29:12 <lambdabot> Error: Undefined type []
07:29:14 <merijn> But knowing the names does let you express some new abstractions that can be useful :)
07:29:43 <tdammers> julianleviston: many of these things aren't really much to understand - more a matter of knowing some arbitrary names for things and what patterns they belong to
07:29:58 <merijn> Patterns + laws ;)
07:30:08 <chpatrick> https://gist.github.com/chpatrick/966eb34d9bcd30eb685f
07:30:10 <julianleviston> tdammers: it reminds me of trying to explain map to a junior dev in one of my previous jobs...
07:30:19 <julianleviston> tdammers: it’s such a simple concept…
07:30:35 <mauke> map f [x1, x2, x3, ...] = [f(x1), f(x2), f(x3), ...]
07:30:41 <merijn> chpatrick: I might have a neat trick stowed away for you somewhere :)
07:30:48 <julianleviston> tdammers: but it confused the hell out of him coz he had no maths
07:30:57 <tdammers> the beauty of haskell's type system, IMO, shows in how map's type almost completely describes what it does
07:30:58 <tdammers> :t map
07:30:59 <lambdabot> (a -> b) -> [a] -> [b]
07:31:10 <mauke> map _ _ = []
07:31:13 <merijn> chpatrick: I defined a statically checked "generic" apply that would apply a foreign function to the appropriate number of arguments :)
07:31:19 <tdammers> turn a bunch of a's into b's, using the mapping provided as the first argument
07:31:26 <init> tdammers: I'd say the problem is that people normally google and open the first wikipedia link, not the concepts themselves :P
07:31:32 <tdammers> hum, yeah
07:31:40 <mauke> map f xs@(x : _) = [ f x | _ <- xs ]
07:32:00 <init> mauke: add map id = id
07:32:03 <merijn> chpatrick: Not sure if it's very understandable: https://github.com/merijn/SNet2.0/blob/master/SNet/Task.hs#L73-L79
07:32:21 <mauke> init: type error
07:32:51 <merijn> mauke: I think he intended to specify the fmap law
07:33:02 <init> was talking about the fmap/functor law, yeah :P
07:33:05 <julianleviston> merijn: mind you, a lot of people seem to glaze over if you start talking about predicates, too, which is bothering.
07:33:13 <merijn> julianleviston: Sure
07:33:24 <mauke> oh, I see
07:33:39 <merijn> julianleviston: Incidentally, not entirely related to learning haskell, but if you like a mathematical approach to programmig
07:33:42 <merijn> @where sf
07:33:42 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
07:33:42 <lambdabot> assistant."
07:34:11 <merijn> julianleviston: Starts with FP in Coq and teaches you to prove properties about your programs than slowly works up to proofs for imperative programs
07:34:20 <bernalex> how do I make optparse-applicative ignore any option it doesn't recognise?
07:35:30 <bernalex> I want optparse-applicative to look for any of the options I have defined, and if it doesn't find any, just leave me be so I can getArgs and be happy.
07:35:44 <bergmark> bernalex: will that work? if someone passes --foo bar, should it ignore bar along with foo or not? it doesn't know whether foo takes arguments
07:36:02 <bernalex> bergmark: I only have boolean flags handled by optparse
07:36:17 <bernalex> bergmark: if someone does ./program lol lol -h lol lol lol, it should catch the -h and do what I want
07:36:28 <julianleviston> merijn: thanks. I’ll finish these 3 haskell books I’m reading, finish the web app I’m trying to build and get right on to that :-)
07:36:28 <bernalex> bergmark: if there is no -h, just leave the program alone.
07:36:38 <julianleviston> merijn: actually thanks, tho.
07:36:48 <bernalex> bergmark: or, really, I'd be just as happy for it to act on the -h, and then just let my program be.
07:36:48 <merijn> "many strArgument" ?
07:37:02 <bernalex> I just don't want to implement option handling myself now that I implemented optparse-applicative. :p
07:37:04 <merijn> bernalex: Are the remaining arguments ever flag like?
07:37:09 <bernalex> merijn: nope
07:37:17 <merijn> If not then strArgument is what you were looking for
07:37:36 <bernalex> merijn: so just catch all the others with strArgument then?
07:38:03 <merijn> I peeked at my example code and I seem to use "many strArgument" as catch all for any non-flag arguments
07:38:10 <bernalex> merijn: note that they can be ./program 1 2 3 -- or they can be ./program '1 2 3' depending on how people use it.
07:38:12 <bernalex> hmm
07:38:30 <bernalex> <*> many StrArgument
07:38:31 <julianleviston> This sentence threw me a bit… “In Hakell, function application takes precedence over every other operator”… is  3 + 4 not function application??
07:38:32 <bernalex> and then what?
07:38:36 <merijn> Actually
07:38:43 <merijn> I use "many (strArgument mempty)"
07:38:44 <bernalex> could you paste the relevant portion?
07:39:08 <keko-2> julianleviston: not in the sense meant there
07:39:22 <merijn> bernalex: http://lpaste.net/120381
07:39:22 <bernalex> merijn: does that just leave them be, or do you "save" them and refer to them in your Parser a thingy?
07:39:26 <julianleviston> keko-2: what’s an operator if it’s not a function?
07:39:29 <bernalex> merijn: thanks!
07:39:31 <keko-2> in the sense meant there, "add 1 2" is function application and "1 + 2" is not
07:39:37 <julianleviston> It’d be nice if operators were defined.
07:39:45 <keko-2> and "(+) 1 2" is also function application
07:39:51 <init> julianleviston: it means f x + g x will always parse as (f x) + (g x) , for any "operator" +
07:39:54 <keko-2> (in the sense meant in that sentence you pasted)
07:39:59 <merijn> bernalex: See my new annotation
07:40:00 <albr> hi all, I'm trying to interface Haskell with OCaml: so far I've built a little wrapper that is able to call OCaml functions using the C interface, serializing the Haskell data types and deserializing them back once the function return. I was able to use a type class to register functions of arbitrary types, and now I would like to serialize/deserialize algebraic data types in a generic way. Do you have an idea of what I should look into
07:40:01 <albr> for that?
07:40:05 <julianleviston> init:  how do I know what’s an operator?
07:40:08 <bernalex> merijn: yeah I figured from my error message -- thanks
07:40:32 <julianleviston> I really dislike irregular syntax.
07:40:33 <keko-2> also, "1 `add` 2" would not be "function application" in that sense
07:40:36 <kadoban> julianleviston: it's made up of non-letters, mostly. Or `foo` is an operator for any function foo
07:40:43 <merijn> albr: I don't think you can serialise them in a generic way
07:40:52 <julianleviston> kadoban: ok…
07:40:53 <merijn> albr: Not all valid haskell ADT can be represented in ocaml and vice versa
07:41:02 <keko-2> but what the sentence actually _means_ is that if you type "f x + 1", that's parsed as "(f x) + 1" instead of "f (x + 1)"
07:41:02 <bernalex> merijn: wait what -- "expected Parser Char" ??
07:41:15 <merijn> julianleviston: You should read the report
07:41:23 <albr> merijn: I head of Generic and SYB, couldn't they serve my purpose?
07:41:26 <merijn> julianleviston: It specified rather clearly what is an operator and what is not
07:41:32 <bernalex> merijn: oh nvm I'm being stupid I think
07:41:47 <merijn> albr: Sure, but what happens if a haskell ADT can't have an ocaml version?
07:42:10 <NightRa> Finally!!! After 2 weeks, I have successfully installed the hscurses library!!!
07:42:23 <julianleviston> merijn: ok thanks (https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4)
07:42:29 <albr> I would like a compiler error or a runtime exception
07:42:30 <Kaidelong> now you can write applications that don't work on windows!!
07:42:37 <merijn> julianleviston: Yeah, that one
07:42:38 <bernalex> merijn: works great -- thanks !
07:42:52 <NightRa> Installed it on windows!
07:43:02 <Kaidelong> oh? Curses supports windows now?
07:43:08 <merijn> julianleviston: Basically, a subset of ASCII and everything in the unicode Symbol category can only be used in operator names and are thus parsed as operators
07:43:09 <Kaidelong> that's great news actually
07:43:20 <NightRa> Kaidelong: It took me 2 weeks to install the library
07:43:24 <geekosaur> document what you did, please.
07:43:44 <merijn> julianleviston: variables/functions CANNOT contain those characters and is thus parsed that way
07:44:01 <julianleviston> is : an operator?
07:44:16 <julianleviston> all this says is it’s special
07:44:21 <merijn> NightRa: This is the point where I tell you that we have vty + vty-ui which is a pure haskell replacement for curses? :>
07:44:25 <Procian> julianleviston: :t (:)
07:44:43 <NightRa> merijn: No support for windows (only cygwin)
07:44:45 <albr> merijn: at least the intersection of the two languages should be automatically transformed back and forth, while the rest should produce some kind of error (compile time or run time)
07:44:48 <julianleviston> Procian: I didn’t think that helped me know if something was an operator or not!?
07:45:01 <merijn> julianleviston: : is treated as "uppercase" symbol and can thus be used in constructors (so :+ is an infix constructor), : and :: are special cased
07:45:08 <geekosaur> merijn: vty doesn't have a backend for the somewhat odd way Windows console works
07:45:16 <Procian> julianleviston: Ah, apologies.
07:45:28 <merijn> geekosaur: Ah, I just tell people to PuTTy into a unix machine to use my console UIs ;)
07:45:33 <Kaidelong> you know
07:45:37 <merijn> putty is better than the windows console anyway :p
07:45:39 <Kaidelong> windows exposes a POSIX api right?
07:45:41 <NightRa> Actually, I don't think it matters if it took 2 weeks for an alternative. Easier to require all users of the application to install cygwin
07:46:02 <geekosaur> (Unix uses escape sequences; Windows uses the equivalent of ioctl() and it's often not directly comparable in how some piece of fucntionality works, although in general the functionality is there somewhere)
07:46:11 <Kaidelong> does this not specify anything about consoles? or does it, and is it just totally undocumented and unmaintained wilderness?
07:46:25 <merijn> Kaidelong: There is a mistaken assumption in your question :)
07:46:32 <merijn> Kaidelong: There is no "one" posix standard
07:46:38 <merijn> There are several tens of POSIX standards
07:46:46 <merijn> And Windows implements some of them
07:46:51 <merijn> Not all
07:47:03 <Kaidelong> probably the minimum amount forced on them by the court injunction
07:47:03 <mauke> julianleviston: yes, : is an operator
07:47:15 <julianleviston> mauke: the report was unclear.
07:47:18 <julianleviston> mauke: thanks
07:47:24 <merijn> julianleviston: An example of an infix constructor:
07:47:26 <merijn> > 1 :+ 2
07:47:28 <lambdabot>  1 :+ 2
07:47:36 <merijn> :t 1 :+ 2
07:47:37 <lambdabot> Num a => Complex a
07:47:42 <julianleviston> mauke: it did say this tho : reservedop	→	.. | : | :: | = | \ | | | <- | -> | @ | ~ | =>
07:47:44 <mauke> @src Complex
07:47:44 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
07:47:49 <geekosaur> I don't think curses is covered by POSIX, anyway. the same org now controls the X/Open XTI standard but I don't think it's been folded into POSIX as yet.
07:48:00 <julianleviston> mauke: so I guess that means it’s an operator. Cool. Thanks.
07:48:03 <merijn> geekosaur: Like posix will ever update now
07:48:05 <mauke> julianleviston: yeah, it's special cased, but it behaves like an operator
07:48:15 <mauke> unlike the other symbols in that list
07:48:20 <geekosaur> and I'm not sure Microsoft gives a flying leap about console user interfaces, to be honest :)
07:48:23 <julianleviston> I dislike irregular syntax.
07:48:29 <albr> So any suggestion on the way to go? What is the most effective way to traverse a data type? I would need to knwo when I encounter a value what is index of the constructor, the number of arguments and the types of arguments..
07:48:31 <merijn> @define data MyList a = a :+: MyList a
07:48:32 <Kaidelong> the fact that linux implementors don't care about POSIX means that the standard has little chance of being important again
07:48:32 <lambdabot>  Defined.
07:48:51 <geekosaur> Kaidelong, it's not just Linux, it's their own stupid actions
07:48:52 <Kaidelong> which is a shame because otherwise Microsoft would be forced by court injunction to keep windows more compatible
07:49:10 <merijn> julianleviston: Actually, I find haskell syntax surprisingly consistent. It just takes awhile to get used to it and some libraries operators are really just DSLs that are not generically readable
07:49:16 <merijn> *cough* lens *cough*
07:49:18 <geekosaur> like making most of the Korn shell part of the POSIX shell standard for most of the existence of that standard and then suddenly deciding to remove it
07:49:27 <mauke> julianleviston: cool story, bro
07:49:30 <Kaidelong> yes, that was bizzare
07:49:31 <julianleviston> merijn: sorry, I should have said “complex syntax”.
07:49:44 <Kaidelong> microsoft even balked at that enough to provide the C-shell as an alternative to the korn shell
07:49:54 <merijn> julianleviston: It's surprisingly simple too, albeit a bit intimidatingly flexible in the beginning
07:50:48 <julianleviston> merijn: it’s not simple.
07:51:00 <julianleviston> merijn: it’s consistent, and regular, and predictable.
07:51:33 <merijn> That's what simple means to me :)
07:51:41 <julianleviston> merijn: and it seems BETTER. But it’s not simple.
07:51:47 <Kaidelong> the reason : is special is because [] is special, IIRC
07:51:50 <Kaidelong> and that was all
07:51:56 <merijn> julianleviston: You get used to it rather quickly, though
07:52:17 <julianleviston> merijn: sure. I’m pretty much already used to it. Operator confused me, but now I know, thanks to you. :)
07:52:20 <Kaidelong> : and [] can still be overloaded by RebindableSyntax
07:52:54 <julianleviston> merijn: and I have to say it’s about 500 times simpler than a lot of other languages
07:52:56 <Kaidelong> and to be fair, it probably should be, if the compiler has to actually build the list that's probably a bug
07:53:28 <tdammers> : and [], without RebindableSyntax, are special in that they are constructors that use operator syntax instead of the usual constructor syntax
07:53:51 <tdammers> so you can pattern-match on them, while you can't pattern-match on other, non-constructor, operators
07:54:01 <julianleviston> sorry for the whining.
07:54:28 <tdammers> julianleviston: IMO, it's still not complex, just different from what you're used to,
07:54:38 <tdammers> so you're operating far outside your comfort zone
07:54:39 <Kaidelong> eh I think whining about haskell is a good idea because a lot of people genuinely seem to believe that Haskell is perfect
07:54:47 <julianleviston> tdammers: I’m not uncomfortable.
07:54:55 <init> Kaidelong: Haskell is far from perfect
07:55:06 <MP2E> I don't know if you could find many who would assert that Haskell is perfect
07:55:19 <MP2E> it occupies a great tradeoff between pragmatism and theory
07:55:31 <MP2E> but uhh. not perfect :P
07:55:31 <init> Kaidelong: where are the dependent types?
07:55:43 <Kaidelong> I'm not sure dependent types are even the right approachc
07:55:55 <julianleviston> tdammers: if there was one rule to understand forms, that’d be simple… or maybe two… but this has quite a few.
07:56:17 <Kaidelong> it unifies the syntax and semantics between value level and type level but this may not be what you actually want
07:56:30 <julianleviston> tdammers:  for example, I can teach you LISP syntax in a few minutes, assuming the particular lisp hasn’t got too many reader literals or such
07:57:00 <julianleviston> tdammers:  (not that you don’t already know LISP, I just mean teach “one”)
07:57:04 <mauke> julianleviston: I choose Common Lisp. go!
07:57:19 <geekosaur> heh
07:57:26 * hackagebot unbound-generics 0.0.2.1 - Reimplementation of Unbound using GHC Generics  http://hackage.haskell.org/package/unbound-generics-0.0.2.1 (AlekseyKliger)
07:57:54 <mauke> lisp syntax is fun in general because it has two of them
07:58:24 <mauke> (the text syntax understood by the reader, and the graph syntax understood by the compiler)
07:58:38 <tdammers> I was about to ask if that was what you meant
07:58:45 <julianleviston> and smalltalk syntax is pretty simple, too… :)
07:59:06 <tdammers> and the "two syntax levels" thing causes a lot of confusion when lispers discuss lisp with non-lispers
07:59:16 <julianleviston> tdammers:  hehe :)
07:59:24 <mauke> especially when they claim lisp has no syntax
07:59:31 <julianleviston> mauke: that’s just silly
07:59:36 <julianleviston> mauke: why do they say that
07:59:42 <julianleviston> mauke: it quite obviously does
07:59:45 <Procian> It has read-syntax.
07:59:59 <tdammers> in my experience, the opposite is true
08:00:07 <Kaidelong> I don't think "lisp has no syntax" is meant as a compliment
08:00:09 <julianleviston> tdammers: syntax has lisp?
08:00:26 <Kaidelong> it's meant to gripe about how lisp developers invent their own syntax for everything
08:00:31 <Kaidelong> which can make lisp hard to read
08:00:35 <dlowe> Since the text tokens are disconnected from the graph structure, then any sequence of text tokens may be converted into a lisp form
08:00:39 <tdammers> you say "lisp has very little syntax" (referring to the text part), and they insist that it actually has infinitely much syntax (referring to the graph part)
08:00:40 <dlowe> I think that's what they mean
08:01:06 <Kaidelong> with something like Java
08:01:14 <tdammers> as long as the parentheses match up, this might actually be true :x
08:01:15 <Kaidelong> you can at least learn Java syntax, and understand a lot about Java code
08:01:22 <Kaidelong> learning lisp syntax does not help as much
08:01:44 <dlowe> Common lisp style these days is much more restrained than the style used pre-2000
08:01:44 <tdammers> Kaidelong: on the bright side, learning lisp syntax takes maybe one afternoon :D
08:01:49 <mauke> tdammers: ((x)) is a syntax error in CL, I think
08:01:56 <tdammers> really?
08:01:57 <init> Kaidelong: I'd argue the same applies to brainfuck
08:01:58 <tdammers> why?
08:02:09 <julianleviston> tdammers: depends what x is.
08:02:11 <dlowe> ((lambda (x) x)) is not
08:02:19 <julianleviston> tdammers: if x is a function producing function it shouldn’t be.
08:02:26 <dlowe> julianleviston: it is.
08:02:33 <mauke> tdammers: can't have a list as the first element of a list
08:02:33 <tdammers> julianleviston: that's what I thought
08:02:37 <julianleviston> dlowe:  really?
08:02:45 <tdammers> mauke: that doesn't seem right
08:02:45 <dlowe> julianleviston: see lisp-2 vs lisp-1
08:02:49 <Procian> You might prefer scheme.
08:02:52 <tdammers> oh right, lisp-2
08:02:57 <mauke> tdammers: the first element is basically the "tag"
08:02:57 <Procian> CL is populated by funcall.
08:03:06 <tdammers> my main exposure to lisp is in the lisp-1 realm
08:03:21 <hyPiRion> ((x)) is certainly not a syntax errror
08:03:34 <hyPiRion> '((x)) works fine in any lisp
08:04:21 <mauke> EVAL: (X) is not a function name; try using a symbol instead
08:04:41 <dlowe> sure, and it works fine with (let ((x)) x), but I don't think that's what was being proposed
08:04:56 <mauke> ;((x)) also works fine in any lisp
08:04:59 <mauke> as does "((x))"
08:05:00 <Procian> And with "((x))" to get particularly silly :)
08:05:06 <Procian> Oh, you went there.
08:07:15 <Kaidelong> init: it does, but just because Java resembles Brainfuck in that way doesn't mean that it's a mistake for it to resemble Brainfuck in that way
08:07:31 <julianleviston> dlowe:  I didn’t realise that was one of the ramifications of LISP-1s… interesting.
08:07:44 <mjrosenb> when importing names from a module, how do I distinguish a constructor from a type?
08:08:08 <mjrosenb> better yet, I don't want to distinguish them, I want to import them both.
08:08:15 <mauke> import Module (Herp(Derp))
08:08:19 <geekosaur> Type(..) or Type(constructor list)
08:08:29 <Kaidelong> or Type() for the type only
08:08:31 <geekosaur> the (..) form imports all constructors
08:08:58 <geekosaur> wait, that's export syntax, not sure you can use it for import although it would make sense...
08:08:59 <Kaidelong> you cannot import only the constructors, but this wouldn't make much sense anyway
08:09:17 <Kaidelong> geekosaur: it works
08:10:44 <tdammers> julianleviston: I'm not 100% that it has to be, but I have a gut feeling
08:12:00 <julianleviston> tdammers: I think the original paper had that limitation in it… does symbol lookup in an env on the car of a list, from memory.
08:12:09 <julianleviston> tdammers: I’d have to go read the paper again tho
08:13:14 <Procian> tdammers: I'm not 100% there isn't a way round it either, but IIRC, you have to "funcall" all function objects.
08:13:33 <RyanGlScott> lpsmith: What exactly changed from blaze-builder-0.3.3.4 to 0.4.0.0? I'm having a surprisingly difficult time adapting a package to use the new blaze-builder?
08:13:58 * tdammers wonders if there is anything to gain from lisp-2
08:14:11 <bergmark> RyanGlScott: seems they forgot to update the changelog :-(
08:14:33 <Procian> Dick Gabriel co-authored a paper with Peter Siebel (?) laying out both cases, and seeming to side on lisp-2.
08:15:11 <phaazon> hm
08:15:14 <phaazon> I feel stupid
08:15:23 <phaazon> is there a function (a -> Bool) -> [a] -> Bool?
08:15:39 <phaazon> I guess I can map my predicate with Any, and getAny . mconcat
08:15:47 <mauke> @hoogle (a -> Bool) -> [a] -> Bool
08:15:48 <bergmark> RyanGlScott: thank you for releasing mtl-compat by the way, it's very useful :-)
08:15:49 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
08:15:49 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
08:15:49 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
08:15:57 <phaazon> oh, any
08:16:06 <mauke> any, are you ok
08:16:08 <phaazon> that was indeed stupid :D
08:16:13 <phaazon> are you ok any
08:16:34 <RyanGlScott> bergmark: Sure, although I personally hope that we don't need too many more *-compat packages.
08:16:52 <bergmark> RyanGlScott: https://github.com/fpco/stackage/issues/439
08:17:06 <julianleviston> phaazon: lol
08:18:50 <RyanGlScott> bergmark: Yeah, using ExceptT instances with GHC 7.8 is a mess right now. Thanks for taking care of the pull request drudgery.
08:19:55 <mjrosenb> is export Foo equivalent to export Foo()?
08:21:53 <geekosaur> mjrosenb, yes, to the annoyance of many who assume it's the same as exporting Foo(..)
08:31:43 <mjrosenb> geekosaur: haha, that is awful.
08:32:30 * hackagebot clac 0.3.0 - Simple CLI RPN calculator  http://hackage.haskell.org/package/clac-0.3.0 (alexander)
08:33:15 <orbisvicis> I have a problem adding a line to do-notation, not sure why
08:33:18 <lpaste> orbisvicis pasted “No title” at http://lpaste.net/120383
08:35:30 <clrnd> orbisvicis, what is `io` type?
08:35:42 <geekosaur> io is short for liftIO
08:36:23 <geekosaur> the problem looks to me like you replaced an apply ($) with an fmap (<$>). prev's type isn't a Functor so you get that error
08:36:59 <clrnd> the error mentions  `previousSwap' too
08:37:57 <geekosaur> yes, thsat's on line 9
08:38:33 <geekosaur> and I imagine that's what's making it infer the MasterSource type and then causing it to become confused when it's used in a place that requires an (f0 a0), that is, a Functor
08:39:24 <orbisvicis> geekosaur: that makes sense, however: data MasterSource = MasterSource (Maybe Window) deriving (Typeable)
08:40:02 <geekosaur> and the Functor instance for that is what?
08:40:06 <clrnd> that doesn't look functory
08:41:15 <orbisvicis> right, not a type synonym. first have to extract the maybe window
08:43:01 <julianleviston> how do I write a thunk?
08:43:42 <geekosaur> um, they're an impleentation detail. since *most* things become thunks internally, you're always writing them :)
08:44:19 <dlowe> julianleviston: I think lazy evaluation means that every value works like a thunk
08:44:52 <julianleviston> sorry what I mean is… how do I write a function that just returns a value and takes no arguments?
08:44:59 <arw_> I need Data.Either isLeft for something, but on the system only an old version is installed. is it harmless to define it somewhere if a library update introduces it later on, or will this lead to problems/error messages because of the redefition?
08:45:05 <dlowe> julianleviston: you don't. just use the value
08:45:07 <orbisvicis> geekosaur: thanks, that did the trick
08:45:09 <yznof> ciao
08:45:13 <julianleviston> so I can pass that function into a function that takes a function. Or is this a silly question?
08:45:21 <yznof> !list
08:45:21 <monochrom> yznof: http://okmij.org/ftp
08:45:30 <bergmark> julianleviston: you can and you very often do in haskell
08:45:33 <kadoban> julianleviston: Are you looking for 'const'? Otherwise, I think the answer is: you don't.
08:45:58 <dlowe> julianleviston: if something requires a function, that function will have an argument, even if it's ignored
08:46:11 <kadoban> Actually, no that wouldn't really fit what you're saying…so I dunno.
08:46:13 <julianleviston> dlowe:  ah ok...
08:46:32 <geekosaur> could you show an example of what you're trying to do here? a bit of example code is much clearer than trying to describe it in multivalued English
08:46:48 <mpickering> arw_: If you define it with the same name then yes it would
08:46:57 <mpickering> arw_: Unless you use some ugly cpp
08:47:01 <dlowe> julianleviston: there simply aren't any functions without arguments in Haskell, since a function is a computational mapping from one value to another
08:47:22 <arw_> mpickering: okay, thanks. then i'll use some other name
08:47:31 * hackagebot propellor 2.1.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-2.1.0 (JoeyHess)
08:47:58 <julianleviston> well I was trying to work out what this means:
08:48:00 <julianleviston> > ((+ 5) . (- 3))
08:48:01 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
08:48:01 <lambdabot>    arising from a use of ‘M596667223226208452231183.show_M5966672232262084522...
08:48:01 <lambdabot>  The type variable ‘a0’ is ambiguous
08:48:03 <julianleviston> > :t ((+ 5) . (- 3))
08:48:04 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:48:29 <julianleviston> in ghci it says ((+ 5) . (- 3)) :: (Num (a -> c), Num c) => a -> c
08:48:45 <bergmark> arw_: you can also use this package http://hackage.haskell.org/package/base-compat
08:48:46 <init> (-3) is a number, not a function
08:48:48 <julianleviston> and I was wondering if that meant it requires a function
08:49:00 <julianleviston> oooh
08:49:04 <init> @type (+5) . (+(-3))
08:49:04 <lambdabot> Num c => c -> c
08:49:12 <init> @type (+5) . (-3)
08:49:13 <lambdabot> (Num (a -> c), Num c) => a -> c
08:49:29 <c_wraith> :t (+5) . (-3+)
08:49:31 <lambdabot> Num c => c -> c
08:49:52 <julianleviston> I was trying to work out why function composition is associative
08:50:09 <kadoban> julianleviston: - is kind of awful in haskell, unfortunately. There it's negative 3, not an operator section. (subtract 3) is probably what you meant, maybe.
08:50:16 <hexagoxel> julianleviston: it means `(- 3)` is not parsed as a section, but as the integer `-3`
08:50:17 <julianleviston> and in the process, wondered if it was possible to compose a partial application of (+) with one of (-)
08:50:26 <arw_> bergmark: oh, cool. thats even better
08:50:33 <julianleviston> kadoban: yeah
08:50:37 <hexagoxel> well, technically, still a `Num a => a`
08:50:43 <kadoban> julianleviston: In short, when you need to do anything interesting with subtraction, just use 'subtract' instead :-/
08:51:34 <hexagoxel> (woah, ping spike)
08:51:40 <julianleviston> seeing as subtract isn’t associative, but *is* a function, I was wondering how that reconciled with function composition being associative.
08:52:01 <julianleviston> it’s probably something obvious I’m not seeing (and the fact that ti’s 4am)
08:52:45 <McManiaC> lens question, can i combine a Lens with a Prism? I have "Lens' a (Maybe b)" and want something like "Prism' a b" and tried to simply do "myLens . _Just", but then i keep getting the error message
08:52:45 <McManiaC>     Could not deduce (Applicative f) arising from a use of ‘_Just’
08:52:45 <McManiaC>     from the context (Functor f)
08:53:11 <McManiaC> ehh, wrong error message
08:53:13 <McManiaC> i get:
08:53:15 <john__> haha
08:53:16 <McManiaC>     Could not deduce (p ~ (->))
08:53:16 <McManiaC>     from the context (Choice p, Applicative f)
08:53:17 <julianleviston> but yeah, nevermind my silly question. :)
08:53:18 <john__> really? haskell?
08:53:30 <john__> haskell sucks, is just for begginers
08:54:01 <arw_> julianleviston: function composition is not the same as picking the parameters for a function.
08:54:10 <john__> you niggers
08:54:13 <julianleviston> arw_: yeah, I know.
08:54:14 <cjenkin2> john__, That's a pretty unsuccessful troll. Haskell is unfairly criticized for the opposite - being too difficult
08:54:17 <cjenkin2> Oh, well then
08:54:38 --- mode: ChanServ set +o glguy
08:54:46 <julianleviston> hehe :)
08:54:55 --- mode: glguy set +b *!*@186.56.223.28
08:54:56 <jedai> john__: so what's a realy grown up language ?
08:54:58 --- kick: john__ was kicked by glguy (Your behavior is not conducive to the desired environment.)
08:55:01 <julianleviston> LOL
08:55:01 <SrPx> Hello, does anyone know if there is any fast, industrial-strength lambda calculator that will reduce terms to its normal form, even inside abstractions?
08:55:02 <julianleviston> nice.
08:55:30 <SrPx> john got kicked...?!
08:55:30 <cjenkin2> jedai, As soon as they said the n word, you know there's no need to talk to them
08:55:35 <SrPx> what happened
08:56:04 <julianleviston> SrPx: he was a bit too off topic.
08:56:05 <SrPx> oh he is not the same john
08:56:18 <cjenkin2> SrPx, This was an obvious (and bad) troll
08:56:27 <SrPx> I wasn't on the chan cjenkin2
08:56:30 <hodapp> that was not a very creative troll
08:56:32 <hodapp> I'd give it 2/10
08:56:42 <cjenkin2> There's a real art to trolling. You need to maximize the rage-time you produce
08:56:53 <glguy> moderation discussion is welcome in #haskell-ops, let's keep this channel on haskell ^_^
08:56:53 <hodapp> you don't just launch right in with the nonsensical racial slur
08:57:00 <bananagram> :t (-3+)
08:57:00 <lambdabot> Num a => a -> a
08:57:03 <hodapp> fiiiiiiine
08:57:10 <cjenkin2> glguy, Apologies
08:57:17 --- mode: glguy set -o glguy
08:57:26 <bananagram> that's better than (\x->x-3)
08:57:33 * hackagebot threads-supervisor 1.0.0.0 - Simple, IO-based library for Erlang-style thread supervision  http://hackage.haskell.org/package/threads-supervisor-1.0.0.0 (AlfredoDiNapoli)
08:57:59 <jedai> bananagram: subtract 3
08:58:06 <jedai> :t subtract 3
08:58:07 <lambdabot> Num a => a -> a
08:58:14 <McManiaC> bananagram: i'd disagree
08:58:40 <kadoban> (-3+) is horribly unreadable to me. I understand it, but actually seeing it in code would require more thought than usual
08:58:59 <bananagram> hm, yeah I agree
08:59:09 <bananagram> subtract 3 is best though
08:59:14 <kadoban> Yeah
08:59:19 <geekosaur> haskell usually forces you to parenthesize, but negative numbers are an awful hack :(
08:59:37 <SrPx> I guess there is probably nothing like what I'm looking for since it is very inefficient to beta-reduce terms by doing actual substitutions, right? Which would be needed for that, I guess...
08:59:41 <geekosaur> (granted, there aren't any good solutions to it)
09:00:07 <arw_> geekosaur: there should be different unicode operators for subtraction and negation...
09:00:18 <cjenkin2> geekosaur, I know a language that uses underscore for negative literals, fwiw. Not sure if I'd pick that over Haskell's compromise though
09:00:29 <hodapp> cjenkin2: what's that, J?>
09:00:35 <cjenkin2> hodapp, :D
09:00:45 <hodapp> never got into J much
09:00:52 <cjenkin2> hodapp, Never do
09:00:56 <hodapp> or any concatenative language for that matter
09:01:02 <geekosaur> yes, I've used such languages. they have their own pains (and edwardk will probably eviscerate you if you take away the _1 lens mechanic :p)
09:01:09 <hexagoxel> i vote for implementing and using (`(-)` 3)
09:01:38 <hodapp> hmm, sometimes I ponder how many GHC extensions I'm using
09:01:41 <NightRa> A blog about how I finally installed the `hscurses` library on Windows:
09:01:42 <NightRa> https://medium.com/@NightRa/installing-hscurses-on-windows-830532d3268a
09:01:49 <hodapp> one of these days I need to dust off Hugs or JHC
09:02:45 <NightRa> It's equally hard to install any other Haskell GUI library on Windows.
09:03:32 <cjenkin2> So, I'm coming from Agda, and the biggest difficulty in learning Haskell has been laziness / partiality. In particular, I've been trying to understand fix
09:04:03 <cjenkin2> Am I right to say it recursively replaces the argument of the lambda with the lambda itself, more or less?
09:05:00 <cjenkin2> fix $ (\xs -> map (+1) $ 1 : xs)
09:08:55 <ReinH> @src fix
09:08:55 <lambdabot> fix f = let x = f x in x
09:09:33 <ChristianS> cjenkin2: laziness just meas that the arguments of a function are evaluated only when needed, rather than always before the function body is executed.
09:09:54 <cjenkin2> ChristianS, I understand the principle. It's the practice that throws me off xD
09:10:12 <ReinH> cjenkin2: this might be helpful http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
09:10:37 <cjenkin2> ReinH, Ah thanks, will give it a read
09:10:38 <ReinH> And, in a more general way, http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
09:12:19 <cjenkin2> fix $ (\x -> "\'" ++ x ++ "\'" ++ " considered harmful")
09:13:25 <Big_G> Can someone please explain why I'd use $?
09:13:45 <cjenkin2> I tend to use the $ to denote lazy function application, but I don't know if that's good style
09:13:56 <NightRa> Big_G: If you don't like putting parens on the right
09:14:05 <FireFly> ($) can be quite useful when partially applied
09:14:17 <bergmark> Big_G: it's stylistic, but i usually find it more readable to use $ rather than lots of parens
09:14:31 <Big_G> NightRa, So I cna acheive the exact same functionality with parens?
09:14:31 <bergmark> and i especially like `f . g . h $ x'
09:14:39 <NightRa> Big_G: Yes.
09:14:46 <FireFly> map ($ x) fs  or  zipWith ($) fs gs  , e.g.
09:14:48 <NightRa> for example, instead of "print (f(x))" you can do  "print $ f $ x" or "print . f $ x"
09:14:50 <bergmark> = f (g (h x))
09:15:07 <Big_G> NightRa, Is there one that is considered more common? I imagine I'll default to parens unless I have a good reason not to
09:15:08 <NightRa> It's defined by:
09:15:15 <NightRa> f $ x = f x
09:15:39 <NightRa> Big_G: It's stylistic. I see $ used more than parens
09:15:44 <init> NightRa: that only needs to be print (f x)
09:15:47 <Big_G> NightRa, Thanks
09:15:52 <bergmark> Big_G: they are both common and people mix and match within the same module
09:15:58 <NightRa> init: Yeah, right
09:16:10 <bergmark> there's little reason to "pick one"
09:16:19 <geekosaur> a common use is with something like forM_ where you iterate a do block over a list. instead of forM_ myList (do ...) you can write forM_ myList $ do ...
09:16:34 <ReinH> cjenkin2: What is "lazy function application"?
09:16:55 <cjenkin2> ReinH, Well in Haskell, basically anything
09:17:04 <phaazon> hey
09:17:09 <ReinH> So "function application" :)
09:17:17 <cjenkin2> I just use it when the behavior depends on laziness, like with fix
09:17:19 <phaazon> aside lens, is there a way to modify an indexed element in a vector?
09:17:24 <Big_G> ReinH, Not evaluating the term until the last possible momeny
09:17:30 <phaazon> Vector a -> Int -> (a -> a) -> Vector an
09:17:35 <ReinH> Big_G: I know what lazy evaluation is.
09:17:38 <phaazon> accum is awful to use :(
09:17:43 <ReinH> cjenkin2: I've never heard of anyone using it that way.
09:18:11 <cjenkin2> ReinH, Like I said, I'm coming from Agda. The compile time normalization of terms isn't lazy
09:18:26 <cjenkin2> Yeah, I figured it wasn't idiomatic Haskell
09:18:52 <cjenkin2> *of terms in Agda
09:19:50 <phaazon> no way to do that?
09:19:54 <phaazon> that’s surprising…
09:21:31 <julianleviston> ahhhh that was what was confusing me before…. (.) is right-associative.
09:22:34 <julianleviston> I wonder why that isn’t a bit clearer. I guess there must be a good reason.
09:22:59 <phaazon> :t accum
09:23:00 <lambdabot> Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
09:23:08 <phaazon> :t Data.Vector.accum
09:23:09 <lambdabot> (a -> b -> a) -> Data.Vector.Vector a -> [(Int, b)] -> Data.Vector.Vector a
09:23:32 <julianleviston> sorry I meant ->
09:23:58 <phaazon> @let modv v i f = Data.Vector.accum (\x g -> g x) v [(i,f)]
09:23:59 <lambdabot>  .L.hs:158:14: Not in scope: ‘Data.Vector.accum’
09:24:06 <phaazon> what…
09:24:12 <NightRa> How can I copy a global cabal package to a sandbox?
09:24:19 <phaazon> @let modv v i f = V.accum (\x g -> g x) v [(i,f)]
09:24:20 <lambdabot>  .L.hs:158:14: Not in scope: ‘V.accum’
09:24:35 <phaazon> @let modv v i f = Data.Vector.accum (\x g -> g x) v [(i,f)]
09:24:36 <lambdabot>  .L.hs:158:14: Not in scope: ‘Data.Vector.accum’
09:24:38 <NightRa> - A package which was built from source in another directory
09:24:38 <phaazon> oh come on
09:24:43 <phaazon> @let import Data.Vector
09:24:44 <lambdabot>  .L.hs:118:1:
09:24:44 <lambdabot>      Data.Vector: Can't be safely imported!
09:24:44 <lambdabot>      The module itself isn't safe.
09:24:47 <phaazon> fuck it.
09:25:38 <NightRa> Again: How can I include in a cabal sandbox a package which is built from source locally from a different directory?
09:25:55 <geekosaur> julianleviston, (->) right-associates because of partial application. a -> b -> c as (a -> (b -> c)) lets you "peel off" and apply the a, leaving the (b -> c)
09:26:03 <glguy> cabal sandbox help -- and read about add-source
09:26:04 <glguy> NightRa: ^
09:26:04 <geekosaur> NightRa, cabal sandbox add-source
09:26:11 <hodapp> well, my current idea to shoehorn some run-time-generated documentation into Haddock docs is to have a Haskell file generated at runtime, and have Haddock pick up on it... this seems a little kludgey but it should work
09:26:26 <julianleviston> geekosaur: thanks…
09:26:27 <glguy> errr... cabal help sandbox :)
09:27:04 <hexagoxel> or --help :D
09:27:48 <julianleviston> thanks for all your help everyone :) night <3
09:28:02 <NightRa> I'm not sure it will be able to rebuild it...
09:37:41 * hackagebot pcre-heavy 0.2.0 - A regexp library on top of pcre-light you can actually use.  http://hackage.haskell.org/package/pcre-heavy-0.2.0 (myfreeweb)
09:38:34 <xplat> gah.  so many packages on hackage that fail tests on 32-bit machines
09:38:38 <xplat> even c2hs
09:40:13 <Yuras> xplat: hmm, interesting. what are the most common reasons/symptoms?
09:42:55 <xplat> Yuras: sometimes it's too-large integer literals (e.g. bloom-filters).  sometimes it's assumptions that integers or pointers are exactly 8 bytes (c2hs).  sometimes it's something with dates (asn1-encoding).
09:43:29 <xplat> the biggest commonality is 'nobody bothered to test on a 32-bit machine before releasing'
09:44:11 <xplat> i'd say that was kind of excusable, except, travis
09:45:27 <Yuras> well, it is normal to test only on platforms you care about or has access to. also FFI is platform specific anyway. but the issue with integers is a really bad sign
09:45:30 <Yuras> IMO
09:47:13 <Yuras> someone said few weeks ago that we should switch to Integer in base package
09:47:21 <mauke> oh man. haskell should have something like perl's testing infrastructure/culture
09:48:13 <Yuras> it should, but it is a technical issue
09:48:36 <mauke> what's the issue?
09:48:50 <Yuras> testing infrastructure
09:48:59 <Yuras> (if you mean CI services)
09:49:07 <mauke> perl doesn't have that
09:49:24 <Yuras> then I'd like to know about that more :)
09:49:50 <mauke> 1) every serious upload to CPAN includes tests
09:50:17 <mauke> 2) the common module installers (cpan, cpanm) run tests by default
09:50:46 <mauke> 3) you can install stuff to make cpan report test results back to cpantesters.org
09:50:55 <xplat> yeah.  nix runs tests by default, but cabal does not.
09:50:59 <bergmark> stackage runs test suites
09:51:06 <mauke> 4) there are people who have set up "smokers" to test every uploaded module
09:51:38 <mauke> and again, results are collected on cpantesters.org, and failing tests trigger an email to the module author
09:52:04 <Yuras> oh, I see now. yes, that makes a lot of sense. but you can't catch ARM-related bug if you run tests on x86-64 linux
09:52:15 <mauke> http://www.cpantesters.org/distro/L/libwww-perl.html?oncpan=1&distmat=1&version=6.09
09:52:49 <xplat> oh, also c2hs has a test that expects strcmp to return -3 when comparing "abc" and "def" !
09:53:00 <mauke> xplat: terrible :-(
09:53:19 <Yuras> mauke: so that is a user's reports?
09:54:00 <mpickering> nix's build farm builds every haskell package and also runs the tests
09:54:03 <mauke> that's all reports for version 6.09 of libwww-perl
09:54:46 <mauke> you can see there's a variety of perl versions, operating systems, and architectures
09:55:23 <mauke> e.g. this one is linux on arm: http://www.cpantesters.org/cpan/report/4e31f8b4-b10e-11e4-8503-173bbf9d5952
09:56:11 <Yuras> mauke: that it amazing, really
09:56:40 <xplat> mpickering: is anyone looking at the results though?
09:56:54 <theorbtwo> The idea is that running the tests on install is fairly low overhead for any individual user, and something that benifits them directly.  Aggragating all that data is some drain on the community in terms of sysadmin and servers, but not an insurmountable amount, and adds tremendous value.
09:57:18 <theorbtwo> xplat: In most cases, failing test reports (black smoke) will cause an email to the author of the module being tested.
09:57:44 <arw_> xplat: not always, but many module authors do care about the usual architectures.
09:57:58 <theorbtwo> (Black smoke and white smoke, after papal election protocol.)
09:58:01 <mauke> Yuras: conversely, some people run this kind of stuff with development versions of perl, so if a core perl change breaks a popular module, the perl maintainers are notified
09:58:30 <arw_> xplat: and it reduces the effort considerably to have those reports automatically collected instead of having the author run them by hand on all archs and OSs.
09:58:53 <mauke> xplat: it's also visible on https://metacpan.org/pod/LWP%3A%3AUserAgent (the "Testers" link)
09:58:56 <theorbtwo> "blead breaks cpan", which is normally taken quite seriously, though about half of the reports end up as bugs against the cpan module failing it's tests.
09:59:02 <xplat> theorbtwo: i meant on nix
09:59:08 <mauke> oh
09:59:12 <theorbtwo> xplat: Aha, sorry.
09:59:44 * Yuras wonders what is easer -- build the same infrastructure for haskell or switch to perl
09:59:53 <xplat> (which is why i directed at mpickering)
10:01:31 <Yuras> someone should start pestering the community, otherwise it will never be done
10:01:43 <mauke> well volunteered
10:01:51 <cfoch> hello
10:02:13 <cfoch> does someone has a simple example of a library in Haskell built with Cabal ?
10:02:34 <mauke> cfoch: uh. everything on hackage?
10:03:04 <hexagoxel> cfoch: clarify "simple".. no dependencies? no lagnauge extensions?
10:03:06 <mniip> cfoch, hnop
10:04:00 <cfoch> "simple" just a few functions, no dependencies...
10:04:20 <aisqwe> can someone pls explain what  (+) <$> (+3) <*> (*100)   does? i dont understand learnyouhaskell explanations.
10:04:56 <sivteck> cfoch, PSQueue
10:05:37 <mpickering> xplat: there's nothing automatic yet but I've had two github issues reported from broken package builds
10:05:46 <mniip> > ((+) <$> (+3) <*> (*100)) a  -- aisqwe
10:05:47 <lambdabot>  a + 3 + a * 100
10:05:56 <mpickering> There's no reason why here couldn't be something automatic..
10:06:56 <aisqwe> mniip: i dont understand how the substitutions work
10:07:03 <sivteck> cfoch, or see "split"
10:08:16 <aisqwe> how does the (+) get between <*> results?
10:09:07 <_ryan> hi everyon, does anyone knows if ther is a channel for haskell db?
10:09:10 <cfoch> sitvteck: thanks, I was looking for something similar
10:10:28 <LnL> Wait what, ghc is using 16gb ram?
10:10:49 <thetallguy> #haskell, I hope you are all enjoying @HaskellCEO as much as I am.
10:11:11 <init> thetallguy: we're enjoying it over #haskell-blah!
10:11:14 <S11001001> > (f <$> (+3) <*> (*100)) a
10:11:15 <lambdabot>  No instance for (GHC.Show.Show a0)
10:11:15 <lambdabot>    arising from a use of ‘M429385566968568015932717.show_M4293855669685680159...
10:11:15 <lambdabot>  The type variable ‘a0’ is ambiguous
10:11:20 <S11001001> hmm
10:11:51 <mauke> aisqwe: <$> is . in this case
10:12:20 <mniip> (<$>) is fmap aka (.)
10:12:21 <aisqwe> mauke: but how does <*> return two values?
10:12:32 <mniip> and (<*>) is S aka \f g x -> f x (g x)
10:12:54 <mauke> aisqwe: it doesn't
10:13:16 <aisqwe> mniip: isn't (g x) the second argument of f ?
10:13:23 <mniip> it is
10:13:47 <mniip> f x (g x) = (f x) (g x)
10:16:16 <mniip> ((+) . (+3)) <*> (*100) --> (\x-> (+ (x + 3))) <*> (*100) --> \x -> (x + 3) + (x * 100)
10:16:24 <hsk3> If your stack grows to over 200 MB, isn't this most of the time a sign you're doing something wrong?
10:16:33 <hsk3> using foldl where you should use foldl', for instance
10:17:33 <hsk3> (assuming that the same program written in other langs uses way less than 200 MB)
10:18:04 <mniip> stack growing means you're messing up recursion somewhere
10:18:14 <mniip> heap growing means you have too many thunks somewhere
10:18:45 <tromp__> what were you thunking?!
10:19:11 <mniip> why isn't `sum` a strict fold anyway
10:19:15 <mauke> mniip: that sounds wrong
10:19:24 <init> mniip: compile with -O2
10:19:25 <mniip> mauke, which part
10:19:33 <init> or just -O
10:19:47 <mauke> mniip: hmm, both
10:19:54 <mniip> both is good
10:19:59 <mauke> you can run out of heap without thunks
10:20:27 <mauke> the stack grows for nested thunks
10:20:39 <mniip> init, I prefer writing programs whose time complexity doesn't explode without -O
10:20:44 <mauke> I'm not sure if it's always recursion
10:20:49 <mniip> or memory complexity
10:21:47 <_ryan> hi everyon, does anyone knows if ther is a channel for haskell db?
10:22:58 <bergmark> _ryan: haskelldb is not very active i think so i don't think there's a channel for it
10:23:19 <lseppala> _ryan: do you have a question about it?
10:23:39 <_ryan> yes
10:24:41 <NightRa> Is there cross-compiling for Haskell?
10:24:52 <NightRa> (Compile for Mac/Linux from Windows)
10:25:26 <geekosaur> not generally
10:32:47 * hackagebot pgdl 7.4 - pgdownloader  http://hackage.haskell.org/package/pgdl-7.4 (sifmelcara)
10:32:47 <jle`> server2
10:32:56 <jle`> oh sorry
11:01:28 <bennofs> NightRa: I heard some people having success to use Wine to crosscompile Linux -> Windows, but aside from that, I don
11:01:36 <bennofs> NightRa: 't think that currently works
11:02:51 * hackagebot yet-another-logger 0.0.1 - Yet Another Logger  http://hackage.haskell.org/package/yet-another-logger-0.0.1 (larsk)
11:09:39 <Hi-Angel> Does hoogle have a capability to show a docs? I.e. suppose I wanted to look at the documentation of the «map» function.
11:10:11 <Hi-Angel> I didn't found any mention about a docs in haskell wiki article of hoogle
11:10:16 <ChristianS> Hi-Angel: that's what hoogle is for!
11:10:21 <josephle> Hi-Angel: click the link?
11:10:26 <josephle> works just like google!
11:11:01 <Hi-Angel> Actually it shows a types of a function, but not a description
11:11:05 <josephle> ah
11:11:11 <josephle> you should click the name of the function
11:11:25 <josephle> it sends you to the documentation
11:11:35 <josephle> or at least what the library maintainer considers the documentation :P
11:11:53 <ChristianS> Hi-Angel: personally i prefer http://hayoo.fh-wedel.de/ , it has a better index
11:12:25 <Hi-Angel> josephle, Ah, are you telling about a online hoogle? I mean the one installed locally.
11:12:35 <josephle> oooh
11:12:41 <josephle> yeah there's an online hoogle
11:12:48 <josephle> I keep forgetting about the offline hoogle
11:12:52 * hackagebot darkplaces-demo 0.1 - Utility and parser for DarkPlaces demo files  http://hackage.haskell.org/package/darkplaces-demo-0.1 (slava)
11:13:29 <athan> does persistent automatically encrypt sqlite databases? For some reason, I can't load mine as a `sqlite` client
11:22:03 <fragamus> howdy... I am making a function  foo :: (a->[a]->b) -> [a] -> [b]      My wish is to have the first parameter take one of the as and the remaining as as parameters. In other words, it is called repeatedly on all of the as with one of the as as a kind of focus. This screams comonad, but I am asking: does lens or something do this? edwardk?
11:23:17 <mauke> this wants select :: [a] -> [(a, [a])]
11:23:41 <fragamus> oh nice
11:24:04 <bennofs> :t select
11:24:05 <lambdabot> Not in scope: ‘select’
11:24:22 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
11:24:25 <lambdabot>  Defined.
11:24:27 <Cale> :t select
11:24:28 <lambdabot> [t] -> [(t, [t])]
11:24:39 <Cale> > select [1..4]
11:24:40 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
11:24:59 <fragamus> what library has select
11:25:03 <Cale> none
11:25:26 <Cale> Well, I dunno, there might be something :)
11:25:34 <Cale> I always just end up writing it again
11:26:06 <Cale> tbh, it deserves to be in Data.List
11:27:53 * hackagebot octohat 0.1 - A tested, minimal wrapper around GitHub's API. Very incomplete at the moment  http://hackage.haskell.org/package/octohat-0.1 (stackbuilders)
11:28:19 <fragamus> seems like a comonad would be good here
11:28:23 <dmwit> imho select :: [a] -> [Zipper a]
11:29:02 <dmwit> which is available in at least one zipper library
11:30:36 <fragamus> what library
11:35:57 <dmwit> at least conal's one, probably, if it hasn't been copied by all the others
11:36:40 <cschneid> zipper libraries... a quick google for them shows a bunch - is there a good easy-to-understand one?
11:40:51 <Hi-Angel> ChristianS, ⁺¹ for hλyoo, hoogle didn't found «launchApp», but hayoo does.
11:42:51 <juanpablo_> ^^^ jvilla
11:46:40 <josephle> Hi-Angel, Hayoo's index includes all of hackage, iirc. hoogle's index is much more limited
11:47:21 <tiger717> I am looking for a concurrency pattern that fits my problem: One thread does a CPU-intensive calculation (in an infinite loop). Another thread should read the latest valid result (not necessarily the one being written by the producer thread at the same time) without any delay.
11:47:44 <EvanR> use a TVar
11:48:16 <bennofs> EvanR: why a TVar? An IORef just works fine for this case
11:48:17 <tiger717> EvanR: that delays the read in the consumer thread
11:48:42 <bennofs> tiger717: note however, that all threads can be blocked if there is a GC running
11:49:09 <bennofs> tiger717: so you might still get delays even with threads
11:49:39 <bennofs> (but you should fine as long your CPU intensive process does not allocates lots of memory)
11:50:09 <tiger717> bennofs: but the result shouldn't be corrupted, so you have to use atomicWriteIORef. This leads to a problem in my code, since the consumer thread basically never gets to read the variable
11:50:35 <EvanR> you wont corrupt anything
11:50:36 <bennofs> tiger717: in haskell, IORef's never contain corrupted results
11:50:46 <bennofs> tiger717: they are implemented using atomic pointer swap iirc
11:50:50 <EvanR> bennofs: so would you use atomicWrite? or just write
11:51:14 <bennofs> just write is enough in this case I think. Problems only start to appear when you have multiple IO
11:51:26 <bennofs> ... IORefs, but you that is not the case here
11:51:46 <EvanR> somehow TVar makes me feel better, but i guess IORef works
11:51:54 <bennofs> EvanR: TVar block though
11:51:56 <EvanR> tiger717: i dont think there would be any delay, thats MVars
11:52:01 <lykos_> Hello all-- I'm having a serious problem with Cabal.
11:52:09 <dmj`> lykos_: what's the problem
11:52:12 <EvanR> bennofs: would it block in this case?
11:52:14 <tiger717> really? then haskell is even cooler than I thought :D
11:52:17 <lykos_> I'm getting "premature end of compressed stream" when running cabal update.
11:52:28 <lykos_> I've seen some references to it online, but haven't been able to fix it yet.
11:52:38 <EvanR> bennofs: its only reading, seems like it should never block
11:52:40 <lykos_> And I need cabal ASAP for work.
11:52:56 * hackagebot monad-control 1.0.0.3 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-1.0.0.3 (BasVanDijk)
11:52:56 <bennofs> tiger717: just be sure to deepseq your value before you put it into the IORef, otherwise you could put a thunk into the IORef
11:52:58 * hackagebot groundhog 0.7.0.2 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.7.0.2 (BorisLykah)
11:53:00 * hackagebot groundhog-postgresql 0.7.0.2 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.7.0.2 (BorisLykah)
11:53:01 <dcoutts_> lykos_: it's getting a truncated download. You can try again.
11:53:24 <bennofs> which would delegate the CPU intensive computition to the read thread, and you don't want that
11:53:36 <lykos_> I've tried many times, including reinstalling cabal, and deleting ~./cabal/
11:53:42 <dcoutts_> lykos_: if it happens repeatedly, then perhaps there's something borked with your network setup, e.g. misbehaving proxies
11:53:51 <bennofs> EvanR: I assume if the write STM transaction is faster than the read, the read transaction would be retried
11:53:58 <dcoutts_> lykos_: you can see, look at the size of the file it's downloaded
11:53:58 <EvanR> why?
11:54:18 <dcoutts_> lykos_: as a quick workaround you can wget the file and gunzip it
11:54:20 <lykos_> That's what I think the issue is, as I'm behind my university's network. But I'm doing work here while at school, so need to get it to work.
11:54:21 <bennofs> hmm, maybe not. ikd
11:54:31 <dcoutts_> lykos_: do you need to use a proxy?
11:54:50 <lykos_> I'm not using a proxy myself, but I think my university's network might be acting like one.
11:55:11 <lykos_> by the way, here's my SO question on this problem: http://stackoverflow.com/questions/28485981/cabal-update-premature-end-of-compressed-stream-error
11:55:15 <dcoutts_> lykos_: sometimes using cabal update -v3 can give some hints if there are proxies doing odd things
11:55:24 <dcoutts_> lykos_: or just looking at the file it downloads
11:55:45 <tiger717> the problem stays: If I don't include a threadDelay (even if it's only 10 µs or so), the consumer doesn't get to read the variable
11:55:59 <lykos_> -v3 is posted in the SO, and the file size is only a few kbs
11:56:05 <mauke> tiger717: define "doesn't get to"
11:56:11 <dcoutts_> lykos_: which btw, lives at ~/.cabal/packages/hackage.haskell.org/00-index.tar{.gz}
11:56:12 <lykos_> (by the way, thanks a lot for the help! This problem has been driving me crazy.)
11:56:18 <EvanR> tiger717: the runtime should interleave threads activity
11:56:28 <lykos_> yep, only 5.1kb.
11:56:38 <EvanR> no cooperation necessary (unless hugs)
11:56:50 <bennofs> or FFI
11:56:58 <EvanR> even FFI should work
11:56:58 <tiger717> mauke: I'm not really sure myself, but the consumer thread *appears* to endlessly block on reading
11:57:08 <mauke> tiger717: are you compiling with -threaded?
11:57:09 <bennofs> tiger717: you can use yield in the CPU intensive thried
11:57:13 <tiger717> mauke: yes
11:57:32 <bennofs> tiger717: another problem is that GHC RTS only yields on allocation, so if your CPU thread does no allocation it never yields
11:57:54 <bennofs> tiger717: if this is the cause, compiling with -fno-omit-yields should also fix the problem
11:57:56 <EvanR> how does it write a value to an IORef without allocating >_>
11:57:57 * hackagebot lifted-base 0.2.3.4 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2.3.4 (BasVanDijk)
11:58:00 <dcoutts_> lykos_: you might also look at this: https://github.com/haskell/hackage-server/issues/302
11:58:12 <dcoutts_> lykos_: and try bypassing our CDN
11:58:43 <bennofs> EvanR: idk, GHC magic
11:58:51 <EvanR> aliens
11:59:44 <bennofs> lykos_: at my school, we have a proxy that provides some sort of "web interface" to download a big file. Instead of downloading it directly, you get served some HTML site with a download link. Maybe that's also your problem?
12:00:17 <bennofs> lykos_: you could also try to download it manually
12:01:29 <tiger717> no change even with -fno-omit-yields...
12:01:38 <tiger717> guess I will just show you the code
12:01:45 <bennofs> good idea, was about to ask that :)
12:02:58 <lykos_> dcoutts_: I tried changing my config to remote-repo: hackage.haskell.org:http://104.130.241.19/packages/archive, but the problem is still present. How would I try bypassing the CDN?
12:03:13 <dcoutts_> lykos_: that IP is bypassing the CDN
12:03:20 <lykos_> hmm
12:03:26 <dcoutts_> lykos_: which indicates it's more likely a local issue.
12:03:30 <hexagoxel> lykos_: the file size (for me) is 8826032 bytes atm, your so mentions 8825306 bytes. that does not look like an interrupted download to me..
12:03:59 <juanpablo_> I'm trying to generate documentation with haddock for HAckage but it keeps generating docs with links to local files in my machine
12:04:08 <dcoutts_> lykos_: you can workaround it temporarily by downloading the index manually and gunzipping it
12:04:29 <lykos_> hexagoxel: That's the content size of the 200 response, but it doesn't come all the way through. My local file is only a few kbs
12:04:48 <juanpablo_> I'm just doing `cabal haddock`. I used the neil tool as well, but it's doing the same
12:04:57 <juanpablo_> what's the standard way to generate docs?
12:05:04 <lykos_> dcoutts_: Would I have to do that for every time I install something with cabal?
12:05:09 <clrnd> Pipes: say I have a `Producer' ByteString m ()` and a `f :: L.ByteString -> L.ByteString`, how can I map f over that?
12:06:28 <clrnd> oh I need a pipe, that consumes and produces
12:06:39 <dcoutts_> lykos_: I said "temporary" workaround. Better is to work out what's going on.
12:07:00 <bennofs> clrnd: is f (a `B.append` b) = f a `B.append` f b  forall a b?
12:07:08 <lykos_> dcoutts_: Yeah, I want to get to the bottom of it.
12:07:24 <clrnd> bennofs, no, it's `replace` from Bytestring.Search
12:07:37 <dcoutts_> lykos_: in that case, compare what cabal downloads with what wget or curl gets
12:07:46 <lykos_> dcoutts_: After the first time I run "cabal update" and get the "premature end of compressed stream" error, I then get the error "Downloading the latest package list from hackage.haskell.org
12:07:47 <lykos_> Skipping download: Local and remote files match.
12:07:47 <lykos_> " when I run "cabal update" again.
12:08:09 <bennofs> clrnd: in that case, if you want to use the function, you would loose the piping behaviour
12:08:16 <dcoutts_> lykos_: oh, remove the .etag file
12:08:18 <clrnd> bennofs, oh, why?
12:08:25 <bennofs> clrnd: you'd need to pull all the chunks, put them into a bytestring and then do replace
12:08:42 <clrnd> bennofs, I don't know if iw ant pipes, I just want my program to read all stdin and stream
12:08:55 <dcoutts_> lykos_: and compare the size reported by the -v3 output of the http conversation with the actual downloaded size.
12:09:01 <lykos_> dcoutts_: if I do that, I get the original error.
12:09:13 <lykos_> (removing the .etag, that is)
12:09:20 <lykos_> where do I point wget at?
12:09:23 <dcoutts_> lykos_: sure, as expected.
12:09:24 <lykos_> simply http://104.130.241.19/packages/archive?
12:09:38 <dcoutts_> lykos_: the URL cabal is downloading, the index.tar.gz file
12:09:45 <dcoutts_> as you can see from the -v3 output
12:09:48 <lykos_> okay
12:10:03 <bennofs> clrnd: I guess replace :: ByteString -> ByteString -> ByteString -> ByteString or similar?
12:10:04 <jkhu> how do i find instance definitions for standard types such as (->), [], (,) ?
12:10:22 <clrnd> bennofs, let me try if this works first, Pipes.Prelude has `map`
12:10:45 <lykos_> it seems like wget is sucessfully downloading it.
12:10:59 <jkhu> How do I find the Monad definition of [] for example?
12:11:01 <bennofs> clrnd: the problem is this: if you get [abc def ghi] as input "chunks" (separate bytestrings), what do you want to happen on replace "cde" "xxx" ?
12:11:57 <raek> jkhu: one way could be looking up the type class on hoogle and check the source
12:12:09 <raek> search for "instance Monad"
12:12:16 <lykos_> dcoutts_: Yep, wget downloads to 8.8mbs
12:12:24 <clrnd> bennofs, that makes sense ofc, it seems like I don't want chunks
12:12:26 <raek> there might be a more convenient way I don't know about
12:12:33 <dcoutts_> lykos_: if you can capture the detailed http log from wget and cabal update -v3 that'd be useful
12:12:39 <dcoutts_> lykos_: to file in a ticket
12:12:45 <tiger717> Link to code: https://github.com/hesiod/xenocrat/tree/test-concurrency
12:12:51 <tiger717> Relevant lines: https://github.com/hesiod/xenocrat/blob/test-concurrency/src-exec/GL.hs#L29
12:12:53 <bennofs> clrnd: so it means you have to read in all chunks before you can run replace, which means you give up streaming
12:12:53 <dmj`> jkhu: https://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Base.html#%2B%2B
12:13:45 <tiger717> Be careful when running, the program *really* hogs one core. You might want to apply a nice level, e.g. 'nice -n 19 cabal run'
12:14:06 <bennofs> tiger717: im running at 100% all time anyway, so that won't change much heh
12:14:30 <EvanR> bennofs is CPU mining btc
12:14:46 <tiger717> interesting :D
12:14:54 <lykos_> How would I go about manually unzipping it/getting cabal to recognize it, for the time being?
12:14:59 <bennofs> no, building haskell packages or GHC :) sadly you don't get money for that
12:15:34 <EvanR> you should ;)
12:15:39 <tiger717> My system always gets unresponsive when something hogs the CPU, even though I have 8 cores...
12:15:49 <dcoutts_> lykos_: gunzip
12:15:49 * bennofs only has 2
12:15:55 <EvanR> tiger717: doesnt seem right
12:16:02 <dlowe> Memory bus contention, I imagine
12:16:03 <bennofs> (and I'm not even sure that 2nd one is a "real" one ...)
12:16:05 <EvanR> memory issue
12:16:12 <dcoutts_> lykos_: cabal normally reads the 00-index.tar
12:16:27 <lykos_> okay
12:16:37 <clrnd> bennofs, are you sure you can't stream and replace?
12:16:54 <tiger717> EvanR: I don't know why either, but I'm not really in the mood to investigate
12:17:41 <lykos_> Here's the wget dump: http://lpaste.net/120392
12:17:56 <lykos_> and I already have the -v3 for cabal install on the SO question
12:17:58 <bennofs> clrnd: consider what happens if you want to replace a bytestring as big as the input string. without implementing the replacement behaviour yourself, you cannot distinguish this case from the normal case
12:18:24 <bennofs> clrnd: you can get streaming replacing for short strings, but you'd need to implement it yourself in a streaming way I guess
12:18:37 <bennofs> tiger717: what GHC version
12:18:51 <clrnd> bennofs, yeah that's what I was thinking, keeping some kind previoues state as long as the replacement
12:18:52 * bennofs will test woth 7.4
12:18:54 <clrnd> ugh
12:19:09 <dcoutts_> lykos_: if you could get a detailed/verbose wget log with all the headers, and put that and the cabal one into a ticket on https://github.com/haskell/hackage-server/issues
12:19:20 <dcoutts_> lykos_: that'd be great, then we'll have all the details in one place
12:19:34 <dcoutts_> lykos_: along with the actual file sizes downloaded (in bytes exactly)
12:20:03 <lykos_> Seems like there might already been an issue for it: https://github.com/haskell/cabal/issues/2001
12:20:13 <tiger717> bennofs: I use 7.8.4, but I don't know of anything too fancy for 7.4 in the code
12:20:38 <dcoutts_> lykos_: it may or may not be the same cause. There's multiple causes to failed downloads.
12:20:49 <lykos_> HMm
12:20:52 <lykos_> Hmm*
12:21:01 <lykos_> Well, thank you for the work-around.
12:21:06 <dcoutts_> lykos_: any truncated download currently gets reported as a zlib premature end of stream. (which is not ideal)
12:21:28 <lykos_> Until I get this fixed, I'll just make a script cabal-update-fix that downloads it and unzips it.
12:21:50 <lykos_> If I run that daily, then things should work fine for developing, yes?
12:22:00 <lykos_> It seems like downloading packages is still working, fortunately.
12:22:15 <bmuk> Hey everyone. I want to set up my project so that when I run cabal build, it will compile every Main file in a directory structure. I'm going through cryptopals exercises, and I would like to use this as not only an opportunity to learn more about crypto, but also to learn more about cabal. I want it to build several executables, and run a series of tests. How can I do this, or better, where can I go to find how to do this?
12:24:47 <hexagoxel> lykos_: daily is not even necessary, imho. sometimes you may want to get in the latest bugfix for some package, but you normally survive a long time without updating
12:26:50 <bmuk> The directory structure I am envisioning is (because the exercises are divided into sets) Set1/ .. SetN/, where inside each set is a folder corresponding to an exercise (i.e. Set1/hexToBase64/), which will contain its own Main.lhs file. Should each of these exercises be their own cabal project? I also don't really know where I should put tests (in a Test/ directory or in the exercise directory itself)
12:27:23 <spaz> Does anybody know, on a high level, if I want to do HTTP over a SOCKS proxy, how to combine stuff from say the http package (HStream) and socks package (Socket)?
12:28:03 <XniX23> is cabal sandbox what virtualenv is in python?
12:28:34 <hiptobecubic> basically mostly yes
12:28:39 <lykos_> hexagoxel: Okay, great, thanks. This is definitely an annoying bug, but it's nice that the workaround is simple.
12:29:08 <bmuk> XniX23: sort of. As I understand it a sandbox is tied to your global version of ghc, but I may be wrong. IIRC python's virtualenv can use a different version of python in each env?
12:29:20 <jkhu> instance Monad [] - 'return x            = [x]'
12:29:37 <jkhu> > return [2]
12:29:38 <lambdabot>  No instance for (GHC.Show.Show (m0 [t0]))
12:29:38 <lambdabot>    arising from a use of ‘M3347329168352564302387.show_M3347329168352564302387’
12:29:38 <lambdabot>  The type variables ‘m0’, ‘t0’ are ambiguous
12:29:44 <mizu_no_oto> What's the best way to handle JSON?  AESON and Lens?
12:30:09 <bennofs> mizu_no_oto: you don't even need lens, but yes aeson
12:30:41 <jkhu> when i do 'return [2]' in ghci i get [2] - shouldnt it be [[2]] ?
12:30:42 <geekosaur> > return 2 :: [Int]
12:30:43 <bennofs> (lens is useful if you don't require all/most information, only some small bits)
12:30:43 <lambdabot>  [2]
12:30:51 <bmuk> anyone know how to do what I want to do with cabal? or at least where to find out how to do what I want to do?
12:30:58 <mauke> jkhu: ghci assumes you meant IO's return
12:31:06 <jkhu> oh
12:31:37 <jkhu> mauke: how do i specify which return
12:31:45 <mauke> > return [2] :: [[Int]]
12:31:46 <lambdabot>  [[2]]
12:32:01 <mauke> type annotation on the result
12:32:13 <mauke> > length (return [2])  -- or implicitly
12:32:15 <lambdabot>  1
12:32:27 <mauke> > return [2] ++ []
12:32:29 <lambdabot>  [[2]]
12:32:45 <jkhu> buttt 'return [2] :: [Int]' - which return does that use?
12:33:01 <jkhu> IO ?
12:33:11 <jkhu> > return [2] :: [Int]
12:33:11 <mauke> that looks like a type error
12:33:12 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
12:33:12 <lambdabot>              with actual type ‘[t0]’
12:33:13 <geekosaur> none since it doesn't typecheck
12:33:23 <jkhu> oh right
12:33:28 <jkhu> okay
12:34:34 <jkhu> is there some way to specify which monad to use on just the fuction something like - (return :: Monad []) [2] ?
12:34:40 <XniX23> bmuk, yes you can specify which python to use. ty for answering
12:35:09 <jkhu> or just in general which instance to use for a typeclass function
12:36:27 <ab9rf> > (return :: a -> [a]) [2] -- you can do this, but it's a touch awkward
12:36:29 <lambdabot>  [[2]]
12:38:06 <hexagoxel> bmuk, XniX23: sandbox contains a separate package-db for each ghc-version you use. by default the system ghc is used, but you can choose via -w
12:38:13 <ajcoppa> > return 2 :: Num a => Maybe a
12:38:15 <lambdabot>  Just 2
12:38:15 <lpaste> tomphreek pasted “is there a shorter way?” at http://lpaste.net/120395
12:38:17 <ajcoppa> > return 2 :: Num a => [a]
12:38:20 <lambdabot>  [2]
12:38:27 <mauke> @define type ReturnOfMonad m = forall a. a -> m a
12:38:29 <lambdabot>  Defined.
12:38:30 <ajcoppa> that's kind of awkward too, but it works. less awkward with non-number types
12:38:38 <mauke> > (return :: ReturnOfMonad []) [2]
12:38:39 <lambdabot>  [[2]]
12:39:09 <mauke> > (return :: ReturnOfMonad Maybe) [2]
12:39:11 <lambdabot>  Just [2]
12:39:46 <bmuk> hexagoxel++
12:39:49 <EvanR> jkhu: top level type signatures help disambiguate a lot
12:40:09 <bmuk> hexagoxel: sorry to ask again, but do you know how to do what I asked earlier in regards to cabal?
12:40:17 <tomphreek> is there a one-liner to keep lists of shortests length in the list of lists, i.e. http://lpaste.net/120395
12:40:51 <jkhu> EvanR: im doing this mainly to try and understand how an expression is evaluated
12:40:54 <mauke> minLength = minimum . map length
12:41:11 <EvanR> jkhu: right then you need explicit annotations and it can be annoying
12:42:16 <mauke> :t \xs -> filter ((==) (minimum (map length xs)) . length) xs
12:42:17 <lambdabot> [[a]] -> [[a]]
12:42:44 <jkhu> For example this is the definition of bind for []: 'm >>= k             = foldr ((++) . k) [] m'
12:42:50 <tomphreek> mauke: cheers
12:43:03 <jkhu> if i have k = (return [1]) the type is not [[Int]]
12:43:38 <mauke> jkhu: yeah, that wouldn't use []'s return
12:43:40 <hexagoxel> tomphreek: exercise: write a version that only traverses the the list once, by abusing lazyness :D
12:43:59 <mauke> jkhu: also, m >>= k = concatMap k m
12:44:03 <mauke> much clearer
12:44:03 <jkhu> mauke: which one would it use and how do i figure that out
12:44:29 <mauke> jkhu: well, k would have the type a -> [b]
12:44:34 <mauke> because of the type of >>=
12:44:50 <mauke> so we have return [1] :: a -> [b] for some types a and b
12:45:01 <tiger717> I added deepseq to the mix, but it didn't improve anything (updated code again on github)
12:45:15 <mauke> we also know return :: c -> m c for some types c, m
12:45:38 <mauke> [1] :: [Integer]
12:45:39 <jkhu> okay
12:45:44 <mauke> this means c = [Integer]
12:45:59 <mauke> thus our return :: [Integer] -> m [Integer] for some m
12:46:12 <tiger717> bennofs: have you taken a look already, or are you still compiling GHC? :D
12:46:25 <mauke> ok, so return [1] :: m [Integer], which must be the same as a -> [b]
12:46:47 <mauke> a -> [b] is just another way to write (->) a [b], which is just another way to write ((->) a) [b]
12:47:03 <mauke> m [Integer] = ((->) a) [b]
12:47:16 <mauke> therefore m = ((->) a) and b = Integer
12:47:19 <bennofs> tiger717: hah, sorry, i don't know what could be wrong here (sadly the program fails to run on my system with a X errpr (BadWindow)
12:47:32 <jkhu> mauke: function monad?
12:47:34 <mauke> and ((->) a) is indeed a monad, so things check out
12:47:37 <sssilver|> People of Haskell, I come from imperative languages, and I have pretty OK understanding of what function calls actually translate to on the lowest level. But I'm having a trouble understanding how "partial application" works.
12:47:39 <mauke> yeah
12:47:57 <ReinH> tomphreek: you could do it in a single pass with a fold.
12:47:57 <sssilver|> Or should I stop trying to think about that, as it's just a weird abstract machine that just happens to somehow work
12:48:03 * hackagebot file-location 0.4.7.1 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.7.1 (GregWeber)
12:48:10 <mauke> sssilver|: every function takes exactly one argument
12:48:39 <mauke> sssilver|: f x y parses as (f x) y
12:48:54 <mauke> i.e. the result of f x is another function, which is then applied to y
12:49:05 <tiger717> bennofs: oh
12:49:08 <bennofs> sssilver|: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects mentions PAP (Partial Application)
12:49:11 <sssilver|> mauke: that seems horribly inefficient
12:49:24 <mauke> sssilver|: it's not actually implemented that way
12:49:38 <sssilver|> mauke: you're basically saying that every full function call is actually called number_of_functions_arguments times
12:49:41 <bennofs> mauke: I think sssilver| is looking for actual implementation
12:49:43 <mauke> but you can't tell as a Haskell programmer
12:49:55 <ab9rf> sssilver|: implementationally, it doesn't necessarily work that way, but you typically don't need to concern yourself ith that
12:50:07 <mauke> bennofs: I'm doubtful
12:50:22 <sssilver|> I'm looking to understand the implementation, yeah
12:50:35 <sssilver|> not necessarily see its source code
12:50:45 <bennofs> sssilver|: you don't need to know that to program in haskell, but if you're interested how it works anyway, I think the link explains it partly
12:50:57 <hexagoxel> bmuk: i'd say different directory for tests. the other question depends on whether users will want to build/test everything at once, or grouped by sets. sharing modules might be harder if you create many cabal projects.
12:51:14 <ab9rf> note also that that's GHC's implementation.  a different haskell implementation might choose a different strategy.
12:51:37 <sssilver|> crazy stuff
12:52:21 <kyclark> bye
12:52:48 <n4x> sssilver|: you could check Core and STG ( http://research.microsoft.com/apps/pubs/default.aspx?id=67083 )
12:52:53 <bmuk> hexagoxel: I'm really going to be the only user. I kind of want to get something set up where it will generate all the binaries I need and run the tests to I can iteratively develop
12:52:56 <sssilver|> I'm starting to think that implementing a Haskell compiler is probably the most horrendous programming effort ever
12:53:09 <tomphreek> ReinH: something like everytime I have a list with even smaller length discregard the accumulant? Same idea as a single pass min I guess. Not too woried about performance here, but thanks for pointing it out
12:53:10 <Kaidelong> o
12:53:17 <ReinH> > let go ys (l,xs) | l < length ys = (l,xs) | l == length ys = (l,ys:xs) | l > length ys = (length ys, [ys]) in foldr go (maxBound,[]) ["foo", "bar", "hello", "abc"]
12:53:18 <lambdabot>  (3,["foo","bar","abc"])
12:53:20 <n4x> sssilver|: this stuff would be useless if you want to understand partial application, though
12:53:22 <ab9rf> sssilver|: it is a fairly complicated bit of code
12:53:26 <Kaidelong> I've heard UHC is not as bad, sssilver|
12:53:31 <Kaidelong> so maybe see how they do it
12:53:33 <mauke> sssilver|: only if you want it to be efficient
12:53:40 <MP2E> ^
12:53:44 <ReinH> tomphreek: ^
12:53:46 <mauke> writing dumb compilers is easier, generally :-)
12:54:03 <bennofs> I'd say writing a fast C compiler isn't easy either
12:54:09 <bennofs> :)
12:54:30 <sssilver|> bennofs: but it's a different kind of hard. C still translates idiomatically OK to the machine language
12:54:37 <hexagoxel> bmuk: cabal is not as powerful as makefiles, as in you cannot recurse into subdirectories or use wildcards
12:54:37 <ab9rf> there is a difference between "correct code" and "good code" :)
12:54:37 <rhaps0dy> in fact they were quite bad for a lot of time
12:54:44 <ReinH> tomphreek: would probably be nicer with compare and a case statement as well
12:55:11 <jkhu> :t (return [1] :: ((->) [Int]))
12:55:12 <lambdabot>     Expecting one more argument to ‘(->) [Int]’
12:55:12 <bennofs> sssilver|: high-level optimizations are probably easier to implement in GHC, as you don't always have to deal with mutation
12:55:12 <lambdabot>     Expected a type, but ‘(->) [Int]’ has kind ‘* -> *’
12:55:12 <lambdabot>     In an expression type signature: (->) [Int]
12:55:18 <bmuk> hexagoxel: I could always just write something in bash, but that would defeat the purpose of learning cabal :) lol
12:55:19 <n4x> writing a dumb compiler is ''easy'', the problem isn't generating naive code, but optimalish :P
12:55:28 <bmuk> maybe cabal can't do what I'm trying to do?
12:55:29 <bennofs> (but idk, never worked on a compiler, just a guess)
12:55:43 <mauke> > (return :: ReturnOfMonad ((->) a)) [2]
12:55:44 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
12:55:44 <lambdabot>    arising from a use of ‘M40702116263467188363113.show_M40702116263467188363...
12:55:44 <lambdabot>  The type variable ‘a0’ is ambiguous
12:55:47 <mauke> > :t (return :: ReturnOfMonad ((->) a)) [2]
12:55:48 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:55:48 <hexagoxel> bmuk: task0: write a haskell script that prints a .cabal file containing an executable and a test section for each subdirectory in current dir :D
12:55:55 <mauke> :t (return :: ReturnOfMonad ((->) a))
12:55:56 <lambdabot> a1 -> a -> a1
12:55:59 <mauke> there we go
12:56:25 <sssilver|> so I have an important conceptual question. Does this mean that if one is working on an app where every processor instruction matters (like John Carmack writing Doom), Haskell is pretty much useless?
12:56:31 <bmuk> hexagoxel: good idea!
12:56:44 <tomphreek> @hoogle a -> [a] -> [[a]]
12:56:45 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
12:56:45 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
12:56:45 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
12:56:46 <rhaps0dy> sssilver|: it depends on your processor's architecture
12:56:48 <ab9rf> sssilver|: i wouldn't say that it's useless.
12:56:56 <rhaps0dy> but for pretty much the entirety of computers, it's not a good choice
12:57:04 <jkhu_> mauke: what was that my irc crashed?
12:57:06 <ab9rf> sssilver|: or that Doom requires "every last processor cycle" :)
12:57:17 <bennofs> sssilver|: it's probably not easy. But haskell has a pretty cheap FFI, so you can write the really critical parts in C
12:57:19 <mauke> :t (return :: ReturnOfMonad ((->) a))
12:57:20 <lambdabot> a1 -> a -> a1
12:57:43 <jkhu_> ReturnOfMonad :o
12:57:53 <mauke> I defined that above
12:57:59 <valdyn> sssilver|: of course, but 99% of all code at least is not like that
12:58:03 <mauke> <mauke> @define type ReturnOfMonad m = forall a. a -> m a
12:58:28 <valdyn> sssilver|: doom probably has assembler parts for that anyway
12:58:29 <sssilver|> valdyn: 99,999% more like
12:58:36 <valdyn> sssilver|: yea
12:58:45 <bennofs> sssilver|: also, IME, in haskell you can use much higher abstraction while being reasonably efficient (Passing lambdas to functions can quickly become slow in C++ IME)
12:58:58 <sssilver|> valdyn: I think it was purely C with Carmack proofreading the object code the compiler generated
12:59:04 <rhaps0dy> what bennofs said earlier about the FFI
12:59:13 <n4x> sssilver|: you can write low-level-ish code that exploits certain features, like unboxed datatypes, and other stuff, so you _can_ optimize code within haskell
12:59:14 <rhaps0dy> seems to be a very good approach :)
12:59:16 <rhaps0dy> profile your program
12:59:25 <hexagoxel> bmuk: well i am not entirely sure; risk of getting discouraged before even starting the excercises. you certainly should start by creating a single package and adding executable + test for one excercise manually
12:59:31 <ab9rf> don't be caught in premature optimization errors
12:59:46 <bennofs> sssilver|: you can also look at assembly generated by GHC. IN fact, I think some people even do this
13:00:05 <bennofs> sssilver|: Core is a nice intermediate form that can be read ok-ish
13:00:30 <jkhu_> :t (return :: a -> ((->) b) a)
13:00:31 <lambdabot> a -> b -> a
13:00:33 <bmuk> hexagoxel: I think I'm just going to do it manually. They may require different dependencies, etc. I'm just going to have Set1/hexToBase64/ as its own cabal project, etc.
13:01:36 <jkhu_> :t (return [1] :: ((->) b) [Int])
13:01:36 <lambdabot> b -> [Int]
13:01:41 <jkhu_> :o
13:01:46 <EvanR> im getting Warning: This package indirectly depends on multiple versions of the same
13:01:47 <hexagoxel> bmuk: you can define dependencies per-executable/test in the package
13:01:49 <EvanR> package. This is highly likely to cause a compile failure.
13:01:59 <EvanR> but build does not fail, and im not sure what its talking about
13:02:14 <mauke> jkhu_: return x = \_ -> x
13:02:24 <hexagoxel> bmuk: but only one library per package; that's why i mentioned the code-sharing aspect
13:02:30 <jkhu_> oh right mauke return for function monad is defined as 'const'
13:02:32 <mniip> return = const
13:02:37 <jkhu_> it all makes sense now
13:02:44 <EvanR> package hxt-9.3.1.10 requires mtl-2.1.3.1, package lens-4.7 requires mtl-2.2.1
13:02:46 <EvanR> i guess this
13:02:47 <bennofs> EvanR: say you have packages A B C. A depends on B-1. C depends on B-2. Now depending on A,C or A,B-2 will cause it
13:03:06 * hackagebot hslogger 1.2.7 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.2.7 (JohnGoerzen)
13:03:21 <jkhu_> i think the function monad (and maybe other instances) is the most confusing thing in haskell
13:03:29 <EvanR> bennofs: possible fix?
13:03:49 <mauke> jkhu_: are you familiar with Reader?
13:03:51 <bennofs> EvanR: recompile hxt against mtl-2.2 if possible or lens against mtl-2.1.3.1
13:04:12 <tasker> I'm getting an error about streaming-commons failing to install, with a specific error regarding blaze.bytestring.builder.intenal. Has anyone come across something similar ?
13:04:13 <jkhu_> mauke: yeah its the same as function with slightly different names
13:04:16 <bennofs> yes, (->) r as a monad is much easier to understand if you recognize that it's just Reader
13:04:27 <mauke> bennofs: assuming you know Reader first :-)
13:04:34 <jkhu_> ^
13:04:50 <EvanR> bennofs: right but what would i change in the cabal file
13:05:00 <bmuk> hexagoxel: I'll just try this and extend it as I go :)
13:05:02 <EvanR> so it doesnt happen when installing the package
13:05:06 <bennofs> EvanR: nothing, it has to do with your installation
13:05:10 <bmuk> hexagoxel: thank you for your help!
13:05:14 <EvanR> oh so maybe i should just reinstall everything
13:05:29 <bennofs> that would probably work
13:07:03 <bmuk> is there a way to specify a type so that it has certain constraints? I would like to make a Hexidecimal type and a Base64 type that are ByteStrings which must be encoded that way
13:07:22 <bmuk> all I know to do right now is type Hexidecimal = ByteString
13:07:53 <lpaste> tomphreek pasted “clunky code. checks if first is a subsequence of another” at http://lpaste.net/120397
13:08:03 <EvanR> yuk why is hexadecimal = bytestring?
13:08:16 <EvanR> oh encoding
13:08:26 <bmuk> but that doesn't give me any assurance that it is in fact a Hexidecimal ByteString. I would like to use QuickCheck to verify that my functions are correct, but as I understand it, it would just throw random ByteStrings at me, which is not what I want
13:08:29 <EvanR> bmuk: you can use phantom types to show what the encoding of a bytestring is
13:08:36 <EvanR> in the type
13:08:42 <bmuk> EvanR: how
13:08:53 <bmuk> I mean could you give me an example
13:08:57 <bennofs> bmuk: do newtype Hexadecimal = Hexadecimal ByteStromg
13:08:58 <EvanR> make a newtype wrapper for ByteString which is parameterized by the encoding type
13:09:07 <bennofs> bmuk: and don't expose the constructor
13:09:10 <EvanR> or that
13:09:30 <ReinH> @google haskell smart constructor
13:09:30 <lambdabot> https://wiki.haskell.org/Smart_constructors
13:09:32 <bmuk> bennofs: That will still take any ByteString, no?
13:09:43 <tomphreek> perhaps I could ask for one more suggestion on the code which checks whether a is a subsequence of b, e.g. http://lpaste.net/120397. Mine is looks ok, but may be there's something I don't know
13:10:00 <EvanR> bmuk: nope
13:10:16 <EvanR> er, functions that take Hexadecimal wont accept a ByteString
13:10:30 <bmuk> I will look at the link, thank you ReinH++
13:10:46 <bmuk> EvanR: yes, but the contructor will take any ByteString
13:11:04 <EvanR> yes thats the smart ctor pattern, your module that is allowed to create the type must verify its right
13:11:37 <EvanR> or you must verify that module is right, but not all modules ever
13:11:37 <n4x> bmuk: you don't export the constructor, you'd have a "smart" function that'd have a type like ByteString -> Maybe Hexadecimal
13:12:24 <bennofs> or just make a smart function that does ByteString -> Hexadecimal, encoding the bytestring
13:13:00 <bmuk> bennofs: that would work, but the exercise is to take a hex encoded string from STDIN and output it in base64
13:13:10 <EvanR> and another function Hexadecimal -> String so you can actually see it
13:14:45 <bmuk> EvanR: Wouldn't I be able to see it anyway? At least in STDOUT?
13:15:41 <EvanR> well first step is to go from String -> Hexadecimal, which may fail so you need a Maybe, then go from Hexadecimal to Base64, which cant fail. then you might want to see the Base64 so you need a function Base64 -> String to see that
13:17:09 <EvanR> bmuk: stdout functions wont work on your newtype, thats why you need a shower
13:17:14 <bmuk> EvanR: you mean see it from ghci, correcct?
13:17:24 <bmuk> oh
13:17:26 <bmuk> I see.
13:17:52 <bmuk> I'm using the getArgs that gives me the raw bytes anyway so I believe it would be ByteString -> Hexidecimal
13:18:12 <EvanR> yeah theres ByteString versions of the whole stdio
13:22:01 <cfoch> hello. I am following this tutorial ( https://wiki.haskell.org/How_to_write_a_Haskell_program ) but I get this error.
13:23:07 * hackagebot hlibgit2 0.18.0.14 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.18.0.14 (JohnWiegley)
13:23:17 <cfoch> wait...
13:23:35 <akegalj> cfoch: you can paste the error into paste bin http://pastebin.com/ and copy link back here
13:23:42 <cfoch> yep :)
13:25:07 <cfoch> http://fpaste.org/184945/37761121/
13:25:17 <cfoch> ^ that error
13:26:54 <akegalj> cfoch: did you do cabal update?
13:27:21 <cfoch> no I didn't... I will try it
13:27:37 <n4x> cfoch: cabal clean and try again?
13:31:06 <darthdeus__> any idea why I'm getting "f\NULi\NULr\NULs\NULt\NUL" instead of "first"?
13:31:16 <darthdeus__> (when reading from a database)
13:31:20 <Enigmagic> unicode..
13:31:29 <EvanR> utf16
13:31:31 <Enigmagic> looks like it's utf-16
13:31:35 <Enigmagic> yep
13:31:43 <darthdeus__> so the db is in utf16 but I'm not reading it as such?
13:31:52 <darthdeus__> or the other way around?
13:31:58 <EvanR> youre reading it as utf8
13:32:06 <tiger717> I just realized that tm19980602
13:32:30 <darthdeus__> hmm, interesting
13:32:43 <Enigmagic> darthdeus: hard to say without seeing the code but it's definately an encoding issue
13:32:49 <EvanR> if youre getting bytestrings, use utf16 decode or something that is aware of the databases encoding settings
13:33:06 <EvanR> if its the database lib giving you that, its busted
13:33:08 <darthdeus__> Enigmagic: well I'm using persistent-odbc and connecting to a mysql database, reading out Text
13:33:13 <cfoch> Is this a good signal for "cabal update" ?
13:33:21 <cfoch> """Downloading the latest package list from hackage.haskell.org
13:33:21 <cfoch> Skipping download: Local and remote files match.""" ?
13:33:41 <cfoch> it seems it didn't upload
13:33:53 <Enigmagic> darthdeus: poke around and see if you can specify the encoding? i haven't used persistent or mysql..
13:33:54 <cfoch> update
13:33:59 <cfoch> sorry...
13:34:07 <ab9rf> that message means that there was nothing to update
13:34:15 <darthdeus__> Enigmagic: actually it seems the database specifies utf8 on the columns
13:34:25 <darthdeus__> so I guess the driver is reading it as utf16 for some reason
13:34:47 <EvanR> darthdeus__: well, mysql utf8 charset means something totally different from utf8. in any case it shouldnt matter to your connection
13:35:12 <EvanR> darthdeus__: reading it as utf16 would make no sense
13:35:17 <EvanR> give the example
13:35:19 <darthdeus__> EvanR: but I do need to read it using the same encoding as its in the database, no?
13:35:20 <EvanR> given*
13:35:20 <ab9rf> EvanR: what does mysql mean by utf8, if not utf8?
13:35:27 <darthdeus__> I'm confused
13:36:06 <EvanR> ab9rf: a fixed-length 3-byte sequence which has the utf8 encoding of characters in the BMP embedded
13:36:17 <ab9rf> EvanR: uh. wow.
13:36:20 <EvanR> ab9rf: a vector of those 3bytes
13:37:01 <ab9rf> EvanR: how is that better than utf16? :)
13:37:03 <darthdeus__> uhm
13:37:11 <ab9rf> well, actually, ucs2
13:37:28 <EvanR> ab9rf: well, you dont have to do a utf8 encode. but no its awful
13:37:43 <ab9rf> since it doesn't handle extended plane characters (those have UTF8 encodings longer than 3 octets) and uses more storage than UCS2 for the same data range
13:37:50 <cfoch> so why could I be getting this error http://fpaste.org/184951/77683614/
13:37:52 <cfoch> ?
13:38:27 <EvanR> ab9rf: it combines two optimizations, its fast to encode into utf8, and its fast to do the all-important index into the character sequence. in all other ways its horrible
13:38:30 <darthdeus__> but if I read the data form the database where it says utf8, will it be in utf8 as I'm reading it?
13:38:45 <EvanR> darthdeus__: it has to do with your connection encoding
13:38:51 <EvanR> the db encoding is unrelated
13:38:55 <ab9rf> EvanR: if you're going to 3 octets you might as well just go to 4 octets and do straight-up UCS32
13:39:14 <darthdeus__> EvanR: but what should I set my connection encoding to?
13:39:21 <EvanR> ab9rf: that would take 1.333 times as much space!! realistically, space is a concern for databases
13:39:35 <ab9rf> EvanR: but ucs2 would be better for space
13:39:37 <EvanR> darthdeus__: utf8, your db lib should be doing this for you
13:39:43 <ab9rf> EvanR: and provide the same functionality.
13:39:47 <cfoch> akegalj: I did cabal update and nothing happens. The same error.
13:39:48 <EvanR> ab9rf: thats an option, darthdeus__ doesnt have that set
13:39:52 <tiger717> really? forever leaks space... yet another problem
13:39:59 <ab9rf> forever leaks space?
13:40:23 <darthdeus__> EvanR: so this means that by default my driver is using utf16, even though the db expects to return utf8
13:40:28 <darthdeus__> sorry for asking dumb questions :(
13:40:59 <EvanR> darthdeus__: yes, your connection is giving you utf16 bytes, and your library is decoding it as if it was utf8
13:41:01 <tiger717> ab9rf: in my program, look here https://github.com/hesiod/xenocrat/blob/test-concurrency/src-exec/GL.hs#L26 if you want to help me find the reason :D
13:41:35 <ab9rf> i have to run
13:41:48 <EvanR> darthdeus__: encoding of the data (as i said was way off anyones expectations) and encoding of the communication channel are two separate things
13:42:19 <darthdeus__> EvanR: but if I change mysql to encode the communication in utf16 it should work as well, right?
13:42:30 <darthdeus__> in case I don't find a way to tell the driver to use utf8
13:42:31 <EvanR> darthdeus__: no, its already doing that!
13:42:41 <EvanR> your driver is buggy
13:42:51 <darthdeus__> hmm
13:42:59 <EvanR> or you misconfigured it
13:43:37 <darthdeus__> there doesn't seem to be a parameter to specify the encoding in the connection string
13:43:44 <darthdeus__> at least not in the docs
13:44:02 <EvanR> its supposed to be automatic
13:44:52 <darthdeus__> I'll try a newer version of the odbc library, maybe that'll help
13:46:20 <EvanR> also try a different db library to make sure the server itself isnt the problem
13:46:41 <EvanR> for example if the data is literally "f i r s t " ;)
13:47:23 <darthdeus__> hmm, actually I changed to ODBC after I created this data, so maybe that's what caused this issue
13:48:11 * hackagebot lowgl 0.1.0.0 - Basic gl wrapper and reference  http://hackage.haskell.org/package/lowgl-0.1.0.0 (evanrinehart)
13:53:15 <darthdeus__> aaaand no, still the same issue
13:53:22 <darthdeus__> something is definitely wrong
13:53:34 <ril> hi, beginner question here
13:53:39 <darthdeus__> god I hate ODBC
13:53:46 <darthdeus__> everything was working so perfectly, until this windows thing came
13:54:08 <akegalj> cfoch: sry i wasn't here. Did you try cabal clean?
13:54:10 <ril> why does Haskell go to such lengths to box nil values inside Maybe types, but return NaN from so many of its built-in numerical functions?
13:54:25 <cfoch> akegalj: yes I tried with cabal clean, too
13:55:18 <akegalj> cfoch: wait, i'll take a look
13:56:17 <akegalj> cfoch: so you whant to install hlibgit2 ?
13:58:51 <tasker> I'm getting this error when trying to install on ghc7.8.3 http://lpaste.net/120400
13:58:56 <tasker> any idea what I can do to fix this ?
13:59:13 <gregnwosu> which data structure is best for temporal data?
14:00:30 <cfoch> akegalj: why do you say that? I was just following the tutorial to create my own program/library
14:02:49 <akegalj> cfoch: oh sorry, i was looking at wrong question :/
14:02:57 <jkhu_> is there an official haskell language spec somewhere?
14:03:25 <mauke> @where report
14:03:25 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
14:03:26 <EvanR> @where report
14:03:26 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
14:03:35 <ab9rf> heh
14:03:37 <jkhu_> :D
14:04:10 <ab9rf> "Note that these documents are intended to define Haskell and are not appropriate for learning Haskell."
14:04:11 <akegalj> cfoch: have you put the code from tutorial into git ?
14:04:46 <lykos_> Does anyone here work for Standard Chartered, by chance?
14:04:57 <cfoch> no I didn't try using git because I was not pretending make a repository for it
14:05:28 <irn4l> hi
14:05:40 <akegalj> cfoch: ok, we could colaborate more easily if i could clone your repo
14:05:42 <irn4l> what is haskell?
14:05:52 <akegalj> cfoch: onto my machine and try the code you wrote
14:06:04 <dmj`> irn41: haskell is a programming language
14:06:10 <irn4l> thank you
14:06:17 <EvanR> lol
14:06:25 <akegalj> this made me laugh
14:06:28 * sssilver| blinks
14:06:34 <EvanR> that has happened before
14:07:24 <ab9rf> heh
14:07:27 <jkhu_> what does this mean - 'class Add a b ab | a b -> ab, a ab -> b' ?
14:07:48 <ab9rf> i always wonder what people like that were expecting
14:08:03 <pjdelport> jkhu_: The things to the right of the | are functional dependencies (also known as fundeps)
14:08:04 <`^_^v> https://wiki.haskell.org/Functional_dependencies
14:08:54 <pjdelport> jkhu_: The short version of it is that in that case, the types a and b will uniquely determine the type ab, and the types a and ab will uniquely determine b
14:08:55 <jkhu_> are multi-parameter type classes standard or do they need an extension to use?
14:09:11 <ab9rf> extension is needed
14:09:40 <jkhu_> okay
14:09:46 <ab9rf> MultiParamTypeClasses
14:09:47 <pjdelport> You need MultiParamTypeClasses for them, but it's a relatively uncontroversial extension.
14:09:51 <akegalj> cfoch: on which step did you stop?
14:09:52 <EvanR> you need a standard extension
14:10:03 <ab9rf> nobody is really put out by that one
14:10:10 <cfoch> akegalj: I am creating the repo, wait
14:10:31 <jkhu_> every time i think im starting to understand haskell i get punched in the face by the next piece of code i read
14:10:31 <EvanR> LANGUAGE AllUncontroversialExtentions
14:11:09 <ab9rf> jkhu_: you get used to that
14:11:22 <jkhu_> :)
14:12:40 <akegalj> cfoch: ok
14:13:00 <akegalj> cfoch: if you don't know how, i'll retype and try
14:13:57 <cfoch> akegalj: https://github.com/cfoch/hskll
14:14:12 <cfoch> :)
14:15:38 <akegalj> cfoch: ok, i cloned it
14:15:50 <akegalj> cfoch: so the error message comes when you "cabal install" ?
14:15:51 <cfoch> I get stuck in 2.5 "Build your project" because i get the error I showed you.
14:15:57 <cfoch> yes
14:20:00 <akegalj> cfoch: wait
14:23:34 <jkhu_> im having a hard time understanding the purpose of functional dependencies - is it just to make sure more than one instance of a typeclass 'class C a b c | a b -> c' with the same 'a' and 'b' are not declared? And whenever you have such a typeclass c will be inferred from the 'class' pattern?
14:24:29 <pjdelport> jkhu_: Yeah, that's the purpose.
14:24:43 <jkhu_> okay cool
14:27:36 <bergmark> jkhu_: http://www.reddit.com/r/haskell/comments/2pal4v/24_days_of_ghc_extensions_functional_dependencies/cmvaaqq
14:30:19 <cfoch> akegalj: do you get the same error?
14:30:46 <cfoch> I am using cabal 1.23.0.0 , btw
14:31:23 <jkhu_> thanks bergmark thats a nice explanation
14:32:43 <akegalj> cfoch: yes, im getting the same error
14:32:50 <akegalj> cfoch: cant figure out why
14:36:18 <akegalj> cfoch: i guess it's something with cabal, but i don't have any expariance with it
14:38:07 <akegalj> hey guys. I have created Main.hs with 'main = print "hello"'. Did "cabal init", pressed enter on everything (for executable), did "cabal sandbox init && cabal install". And it fails
14:38:16 <akegalj> am i doing something wrong?
14:38:18 * hackagebot MonadCompose 0.3.0.0 - Methods for composing monads.  http://hackage.haskell.org/package/MonadCompose-0.3.0.0 (JamesCandy)
14:38:59 <mpickering> akegalj: and what is the error message?
14:40:14 <akegalj> mpickering: http://pastebin.com/eYNAxhes
14:40:56 <cfoch> akegalj: well... not problem
14:41:01 <cfoch> thanks
14:41:09 <ReinH> akegalj: did you read the error message?
14:41:33 <Cale> akegalj: Maybe either remove the license-file field from the .cabal or create the LICENSE file it refers to?
14:41:34 <ReinH> cabal could be a bit more clear but it does tell you what the problem is.
14:41:55 <akegalj> ReinH: licence?
14:42:12 <ReinH> akegalj: right, as Cale says you can either add the file or remove the line referencing it from the cabal file.
14:42:24 <ReinH> If you select one of the OSS licenses it will add it as LICENSE iirc
14:43:07 <akegalj> ReinH: oh, ok. There was a "warning" so i thought thats not the main issue
14:43:54 <ReinH> akegalj: Yeah. I wish cabal told you it was an error specifically.
14:44:06 <akegalj> cfoch: so, ReinH and Cale answered, you need to add licence file
14:44:33 <akegalj> cfoch: during cabal init, choose some licence
14:44:55 <akegalj> ReinH: yes, that cought me
14:45:45 <hexagoxel> regarding init/license, see https://github.com/haskell/cabal/issues/2217#issuecomment-62974089
14:45:51 <cfoch> akegalj: this one? https://github.com/cfoch/hskll/blob/master/haq/LICENSE ?
14:47:33 <akegalj> cfoch: hm i don't know why it's not working with that licence. I'll check. But if you remove licence line from hoq.cabal file it'l compile ok
14:50:11 <akegalj> cfoch: oh, you are building it like a library?
14:50:19 <cfoch> yes
14:50:57 <akegalj> cfoch: oh
14:51:15 <akegalj> cfoch: then you need to add "module Hoq where" at the top of Hoq.hs
14:51:36 <akegalj> cfoch: Haq.hs "module Haq where" *
14:51:46 <darthdeus__> hmm, so it looks like the same version of the same ODBC driver on windows doesn't have these encoding issues
14:52:10 <darthdeus__> which means the OS X one is broken
14:52:12 <darthdeus__> (facepalm)
14:52:15 <cfoch> \o/
14:52:23 <cfoch> so that was the problem
14:52:41 <akegalj> cfoch: so cabal is trying to buld a library, and if you look in haq.cabal there is exposed-modules
14:52:55 <akegalj> cfoch: and cabal is looking for Hoq module, but can't find one
14:53:53 <jkhu> is there a way to print the type of an expression from the main function in a haskell source file?
14:55:46 <cfoch> akegalj: so the tutorial was building it as an executable ?
14:57:26 <darthdeus__> probably a dumb question, but can I load a 32bit library into a 64bit program?
14:58:31 <mpickering> jkhu: you need to use Typeable
14:58:55 <akegalj> cfoch: yes, i think it was
14:58:57 <phaazon> moghedrin: ahah!
14:59:17 <moghedrin> phaazon: o/
14:59:39 <phaazon> moghedrin: I’d love to see us in the top 3
15:00:21 <moghedrin> Obviously, I'm fond of that idea as well ;D I'd be content with < 100 though.
15:00:23 <phaazon> I think it’s impossible
15:00:28 <phaazon> yeah :D
15:01:14 <phaazon> my AI can be improved in a lot of ways I guess
15:01:40 <phaazon> there are two major issues: the GC taking too much time while doing shortest paths searchs
15:01:46 <phaazon> and a case I don’t test
15:01:55 <phaazon> that make the other player wins at like turns 4
15:01:57 <phaazon> :D
15:02:31 <moghedrin> I'm honestly just following my shortest path if I'm already winning, and placing a wall in the opponents shortest path if I'm not, so hard to get more simple than mine at the moment.
15:02:51 <phaazon> mine is a bit more complex
15:03:02 <phaazon> I use prediction
15:03:12 <phaazon> so that I know when I’m in danger
15:03:19 <phaazon> but that creates a “snail” pattern
15:03:21 * hackagebot purescript 0.6.7 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.7 (PhilFreeman)
15:03:24 <phaazon> which is sometimes broken :(
15:06:40 * moghedrin grabs phaazon's agent and starts playing with it
15:07:21 <phaazon> AHAH
15:07:28 <phaazon> 265/845
15:07:37 <phaazon> I’m getting very close to you :D
15:08:36 <moghedrin> Well, hello 227 ;D
15:09:07 <phaazon> 209
15:09:10 <phaazon> sorry
15:09:11 <phaazon> :D
15:09:14 <moghedrin> NOOOOO!
15:09:15 <Luke> can anyone tell why this is a partial match? http://lpaste.net/6563979096634687488
15:09:19 <phaazon> still getting up in the ranking
15:09:31 <phaazon> moghedrin: the first haskeller is something like 30
15:09:32 <phaazon> :(
15:09:53 <moghedrin> phaazon: Yeah :L
15:10:02 <moghedrin> We're 6, 7 on Haskellers.
15:10:15 <phaazon> yep
15:10:22 <phaazon> moghedrin: it’s very uncommon that
15:10:32 <phaazon> on single challenges, there are like
15:10:34 <phaazon> 9 haskellers
15:10:41 <phaazon> among them, two or three are very good
15:10:44 <phaazon> and the other very weak .D
15:10:46 <phaazon> :D *
15:11:01 <phaazon> very common*
15:12:11 <EvanR_> very weak haskeller? impastable. the type system augments you like iron man
15:12:22 <phaazon> yeah well
15:12:26 <phaazon> not really :P
15:12:31 <EvanR_> hahaha
15:12:43 <phaazon> I’ve been first in Haskell a few times
15:12:44 <mauke> Luke: because it could consume more
15:12:48 <phaazon> I won a raspberry pi
15:12:51 <phaazon> and three t shirts
15:12:52 <phaazon> :D
15:13:35 <Luke> mauke: how specifically? i figured that was the case but can't see it
15:13:50 <mauke> Luke: ?
15:14:05 <Luke> mauke: "because it can consume more" is just the definition of "Partial" ;-)
15:14:19 <Luke> I can't see why it can consume more
15:14:26 <mauke> Luke: look at your parser. literally any character would be a longer parse
15:14:42 <Luke> mauke: what do you mean a longer parse?
15:14:57 <mauke> a successful run of the parser consuming more input
15:15:17 <Luke> mauke: you just mean it could run forever?
15:15:21 <mauke> "hey thereXXX" where XXX could be anything would be accepted by your parser
15:15:30 <Jseph> What competition are ya'll reffering to?
15:15:43 <Luke> mauke: how do I make it stop parsing then?
15:15:55 <mauke> "To indicate that you have no more input, supply the Partial continuation with an empty bytestring."
15:15:57 <moghedrin> Jseph: http://www.codingame.com/home
15:16:13 <Jseph> thank you!
15:16:24 <Luke> mauke: so this is just the behavior of the test printer?
15:17:23 <mauke> Luke: yeah, parseTest is weird
15:17:46 <Luke> mauke: I think what you're trying to say is "this parser is defined to accept infinite input" and "you can't end the stream because of the behavior of parseTest"
15:18:03 <mauke> I'd use something like myParseTest p s = print (feed (parse p s) "")
15:18:11 <Luke> ok thanks
15:18:23 <phaazon> Jseph: you can still enter it
15:18:32 <phaazon> it’s begun a few days ago
15:18:33 <mauke> (disclaimer: I've never used attoparsec)
15:18:37 <phaazon> but you have seven days left
15:18:41 <phaazon> to write your AI
15:18:42 <mauke> Luke: yes!
15:18:45 <phaazon> and have fun! :)
15:18:51 <phaazon> let haskellers invade codingame!
15:18:57 <phaazon> :D
15:19:07 <Zemyla> mauke: What parser are you talking about?
15:19:17 <mauke> Zemyla: http://lpaste.net/6563979096634687488
15:20:26 <Luke> mauke: yeah perfect. Thanks. Everything was working as expected except the parserTest which I expected to have the definition you gave and it doesnt. thanks a lot
15:21:06 <Zemyla> mauke: Attoparsec is almost exactly the parser I was trying to write.
15:21:45 <mauke> Luke: might be worth a bug report / feature request
15:22:14 <Luke> mauke: I remember running into this like 2 years ago too... I just couldn't remember what I was missing
15:22:30 <Luke> I think it's technically correct though
15:22:41 <Luke> just unexpected when you want a complete parse
15:23:02 <mauke> I remembered the issue from https://metacpan.org/pod/HTML%3A%3AParser :-)
15:23:14 <mauke> where you have to call $p->eof to signal end of input
15:23:23 * hackagebot lowgl 0.1.0.1 - Basic gl wrapper and reference  http://hackage.haskell.org/package/lowgl-0.1.0.1 (evanrinehart)
15:23:25 * hackagebot static-canvas 0.1.0.0 - DSL to generate HTML5 Canvas javascript.  http://hackage.haskell.org/package/static-canvas-0.1.0.0 (jeffreyrosenbluth)
15:23:47 --- mode: ChanServ set +o monochrom
15:24:17 --- mode: monochrom set -bb *!*@S0106306023d60d12.lb.shawcable.net *!*@146-193.dsl.iskon.hr
15:24:30 --- mode: monochrom set -o monochrom
15:52:21 <hexagoxel> before i dive deeper into cabal api.. does anyone have a build-counter Setup.hs thingy around (via userhooks, probably) (i.e. i want a cpp macro constant BUILD_NUMBER :: Int)
15:53:32 <hexagoxel> (or is there anything of the sort already provided somewhere?)
15:55:05 <hodapp> 'egrep -R "foldr" | wc -l' returns 2. I am a horrible Haskeller.
15:56:05 <ChristianS> hodapp: doesn't matter as long as you use foldl' often enough :)
15:56:24 <hodapp> ChristianS: so far it's only foldr.
15:56:41 <Big_G> Any idea why same languages call a function reduce and others call it fold?
15:58:05 <hodapp> Big_G: I suspect it might relate to Lisps not really having fold as an operation?
15:59:04 <EvanR_> Big_G: or both, like in clojure
15:59:12 <Welkin> Big_G: imperative languages typically call it "reduce" (which is implemented as foldl)
15:59:32 <Welkin> ruby uses `select` instead of `filter`, which is annoying
15:59:42 <scott> select and reject
15:59:44 <EvanR_> ruby renamed all of them, its stupid
15:59:51 <EvanR_> map and collect
16:00:04 <EvanR_> inject
16:00:04 <scott> the name filter is ambiguous until you learn the convention
16:00:18 <scott> those names are all from smalltalk, not ruby, iirc
16:00:45 <mauke> perl uses map and grep (and reduce)
16:01:27 <EvanR_> scott: ah
16:01:38 <cmccann> Welkin: and .Select() in C# is map, not filter
16:02:14 <scott> they have a certain consistency (select/reject/inject/collect), but I hate the names inject and collect for reduce and map
16:02:28 <mauke> #rekt
16:02:49 <EvanR_> consistency? they rhyme? why does it need to rhyme
16:02:52 <cmccann> Welkin: this is why I can't take seriously the complaints about Haskell's mathematical terminology being "unintuitive" when other languages struggle with the concept that words should mean things
16:05:21 <nuser> Why doesn't Haskell have numeric range types?
16:05:30 <orbisvicis> heh. on that note..
16:05:40 <scott> cmccann: I thought it was the haskellers who thought names shouldn't mean things
16:05:49 <scott> cmccann: with specific enough types you don't need names
16:05:54 <scott> :)
16:05:55 <hodapp> cmccann: This is why somewhere out there is an empty cubicle with my name on it, and a group of devs who all now think twice before ever dismissing something as "just semantics".
16:06:26 <jonsterling> scott: Scala programmers who wish they were doing Haskell believe that all identifiers should be called "!@#$%^%$@", since parametrically makes the intent self-evident
16:06:45 <EvanR_> yeah the dual interpretation of "semantics" as "unimportant details" and "important details"
16:06:46 <cmccann> scott: that doesn't apply to top-level definitions anyway :P
16:07:11 <jonsterling> This is why I program only in de bruin indices
16:07:24 <hodapp> jonsterling: funny, that's what I wanted to call all my identifiers in C++
16:08:04 <hodapp> EvanR_: I had very, very, very little tolerance for people dismissing concepts from functional programming, and then reinventing them, badly, and trying to take credit for this "cool innovation" they thought of.
16:09:11 <EvanR_> hodapp: java?
16:09:27 <hodapp> EvanR_: I didn't work at Sun Microsystems, sir.
16:09:31 <benzrf> scott: ruby's names are from smalltalk
16:09:34 <benzrf> blame alan kay
16:09:35 <cmccann> hodapp: I'm not sure if that's better or worse than coworkers who aren't clever or competent enough to reinvent anything at all
16:09:42 <scott> benzrf: this is what I said
16:09:57 <benzrf> ah
16:09:59 <benzrf> sorry i misesd that :L
16:11:27 <hodapp> cmccann: people who actively ignore relevant ideas repeatedly don't tend to invent anything great
16:11:46 <nuser> Hmm no answer, I probably wouldn't understand it anyways. :)
16:12:16 <cmccann> nuser: oh, sorry. I don't think there's any deep reason, tbh.
16:12:51 <nuser> cmccann: Thanks :)
16:13:33 <Welkin> cmccann: I just saw an amusing easter egg in swift. In xcode, when you type `map`, the IDE will suggest several versions, one of which has the description "Haskell's fmap for optionals"
16:13:48 <xnil> what would attract one to haskell over idris besides, say, maturity and ecosystem development?
16:13:51 <EvanR_> Welkin: wow
16:14:00 <cmccann> nuser: basically it wasn't in the original core library and it's not hard to implement as a regular library, so it was left at that
16:14:19 <cmccann> Welkin: ahahahaha
16:15:39 <hodapp> xnil: the fact that SPJ is a rock-star.
16:16:19 <xnil> he reminds me of bill nye
16:16:19 <EvanR_> xnil: any reasons like language aspects might be just lumped into maturity so
16:16:28 <nuser> got it.
16:16:41 <xnil> EvanR_: i mean more of non-core things in maturity, just on the language level
16:16:49 <EvanR_> xnil: for example idris doesn't have a type class deriving mechanism, but will it when its "mature" ?
16:16:49 <xnil> as in, not in implementation
16:16:52 <xnil> not in libraries
16:17:03 <hodapp> :t [minBounds .. maxBounds]
16:17:04 <lambdabot>     Not in scope: ‘minBounds’
16:17:04 <lambdabot>     Perhaps you meant ‘minBound’ (imported from Prelude)
16:17:04 <lambdabot>     Not in scope: ‘maxBounds’
16:17:11 <hodapp> :t [minBound .. maxBound]
16:17:12 <lambdabot> (Enum t, Bounded t) => [t]
16:17:16 <hodapp> That's sort of a range type >_>
16:17:26 <xnil> that sort of thing is ok, i didnt mean to exclude that with 'maturity'
16:17:46 <Hijiri> is there template idris?
16:17:50 <EvanR_> no
16:18:24 <jonsterling> Hijiri: There is something called "type providers", which is not the same as template haskell IIRC, but it is pretty cool...
16:18:29 * hackagebot subnet 0.0.1.2 - subnetting calculator  http://hackage.haskell.org/package/subnet-0.0.1.2 (gcganley)
16:19:16 <hodapp> Idris' code generation looks to be pretty interesting
16:24:47 <cmccann> bitemyapp: was that REALLY necessary :P
16:25:08 <bitemyapp> cmccann: guess how I voted on the survey
16:26:59 <bitemyapp> cmccann: don't squash it please
16:27:05 <bitemyapp> cmccann: I will be very upset if you do.
16:28:05 <cmccann> nah
16:28:13 <bitemyapp> cmccann: thank you :)
16:28:19 <cmccann> I mean, it's kinda pushing it in terms of being almost outright trolling
16:28:35 <cmccann> but on the other hand, it's not really any worse an argument than the one "FTP is bad" post :P
16:29:24 <bitemyapp> cmccann: your open-mindedness to this is appreciated.
16:30:55 <MP2E> amazing
16:30:56 <MP2E> haha
16:31:03 <MP2E> i'm guessing this is in reply to Mono Haskell? :P
16:31:20 <MP2E> er MonoHaskell* :P
16:31:31 <cmccann> MP2E: yes
16:32:57 <Axman6> is MonoHaskell haskell on .Net on Linux?
16:33:32 <cmccann> Axman6: no, that might actually be useful
16:34:20 <Axman6> heh
16:35:55 <Axman6> "Having trouble installing MonoHaskell? Check out the OCaml at https://ocaml.org/." wut
16:36:35 <hodapp> wut
16:37:16 <mauke> "The Ruby community done a great job"
16:38:04 <glguy> Axman6: It means "if you can't deal with type classes, maybe you should be programming in O'Caml' and then it has an invisible trollface at the end
16:38:45 <hodapp> 9_9
16:39:13 <Axman6> =)
16:39:48 <Welkin> oh
16:39:51 <Welkin> an FTP joke
16:42:42 <aupiff> hey all, wondering about defining a finite list type in haskell. is this easily done?
16:43:29 <cmccann> aupiff: not exactly. why do you want one?
16:44:17 <aupiff> cmccann: just wondering about how to define some tricky types. intellectual curiosity.
16:44:26 <aupiff> maybe you can point me to some reading material?
16:45:15 <cmccann> aupiff: not off the top of my head
16:46:16 <Axman6> it's not too hard to define vectors whose length is part of their type, it's sort of the canonical example of using depenedently typedish stuff in haskell
16:46:31 <cmccann> aupiff: I mean, you can make a strict list, but nothing stops you from constructing an "infinite" one, you just get the program to hang instead of having a lazy infinite list.
16:46:48 <Axman6> and it's also possible to define vectors whose length is no more than a certain length in similar ways
16:47:04 <cmccann> aupiff: if you also define fixed-length lists in various ways, including the type-level stuff Axman6 mentions
16:47:07 <aupiff> Axman6: in the dependent type way?
16:47:09 <EvanR_> a regular list which is definitely not infinite
16:47:17 <EvanR_> seems hard in haskell
16:47:33 <hodapp> aupiff: you can check out the Hasochism paper.
16:47:57 <aupiff> hodapp: cool, checking that out now
16:48:10 <hodapp> aupiff: do be aware it is called "Hasochism" for a reason :)
16:48:12 <cmccann> EvanR_: well, just force the spine of the whole list. if the program doesn't hang, the list is definitely not infinite :P
16:48:25 <EvanR_> you just solved the halting problem!
16:48:37 <Axman6> aupiff: there's a difference between something which is non-infinite and something which has bounded size, the latter is pretty easy to do
16:48:42 <hodapp> partial functions don't halt Turing machines, I HALT TURING MACHINES!
16:48:47 * hodapp kicks computer
16:50:02 <hsk3> In the function
16:50:03 <hsk3> findKey :: (Eq k) => k -> [(k,v)] -> Maybe v
16:50:04 <hsk3> findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
16:50:06 <hsk3> Is it true that there is no risk of a stack overflow here during this foldr?
16:50:07 <hsk3> Unlike for this foldr:
16:50:07 <hsk3> foldr (+) 0 (replicate 10000000 1)
16:50:26 <Axman6> let's see if I can do this off the top of my head...: data MaxVec (n :: Nat) a where Nil :: MaxVec (S n); Cons :: a -> MaxVec n a -> MaxVec (S n) a
16:50:39 <hsk3> Since the + expression needs to store the old result around. But not the other expression
16:50:47 <Axman6> then MaxVec 7 Int chas length less than 7
16:50:51 <Axman6> has*
16:51:16 <bennofs> Axman6: Nil :: MaxVec 0 I think
16:51:33 <Axman6> bennofs: no, that would give vectors of exactly length n
16:51:52 <Axman6> mine gives vector with length < n
16:52:59 <Axman6> aupiff: you might want to have a look at https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
17:08:10 <ttt_fff> anyone else feel, as a matter of principle, that error handling in Haskell is completely broken? Consider the following: f :: a -> b isn't really a pure function, since f can use "error" --- but then, I'm only allosed to pass error "string" ... so I'm not allowed to do "error MY-COOL-DATA-TYPE" ... yes sure, I can stick this in an error monad, but then it's like f :: a -> ErrorMonadTransformerFun b
17:08:32 <vanila> ttt_fff, 'error' is broken, the monad way is good
17:08:36 <EvanR_> :t throw
17:08:37 <lambdabot> Exception e => e -> a
17:08:55 <ttt_fff> EvanR_: which package in throw in?
17:08:56 <ttt_fff> I will go read docs
17:09:03 <EvanR_> Control.Exception
17:09:30 <EvanR_> its the same as error for the most part, just you can catch the exception in IO
17:09:45 <mauke> error is not supposed to be handled
17:09:46 <ttt_fff> EvanR: why can I only catch it in the IO monad?
17:09:57 <mauke> it's like assert() (or rather abort()) in C
17:10:00 <Axman6> because exceptions are a side effect
17:10:02 <ttt_fff> why can't I do shirt like "inside this pure function; I'm goign to setup a error handler ... which will acatch all throws from other pure functions"
17:10:15 <ttt_fff> why is "changing control flow"  a side effect?
17:10:28 <ttt_fff> I didn't understand that when I saw it in the docs
17:10:30 <EvanR_> stuff like that should be listed in the type, in which case you can use Maybe or Either
17:10:42 <Axman6> because, for one, it's not represented in the type system and can't be type checked in haskell
17:10:57 <vanila> use an error monad if you want to throw and catch errors
17:11:42 <EvanR_> ttt_fff: i think its not right to sasy "f :: a -> b is not a pure function"
17:11:45 <EvanR_> for a few reasons
17:12:14 <vanila> wel a -> b should be a pure function, but haskell is sadly not as pure as it claims
17:12:26 <EvanR_> more like a -> b may be a pure function
17:12:34 <EvanR_> and it may be a total function
17:12:50 <ReinH> ttt_fff: error "string" is a bottom, so it is an inhabitant of every type.
17:12:53 <Axman6> well, no, using error in f :: a -> b is still pure, the type says, if I return a result, it will be of type b
17:13:01 <ReinH> The Haskell type system explicitly allows this.
17:13:09 <chrisdotcode> guys, is there any arg parsing utility that gives you back a Data.Map? Or do I get to implement it?
17:13:16 <ReinH> Axman6: no, the type system says "I will return a result of type b" :)
17:13:33 <ReinH> error "string" is a value of type b for all b
17:13:44 <ReinH> :t error "string" :: Int
17:13:45 <lambdabot> Int
17:13:57 <Axman6> I guess
17:14:57 <ReinH> :t error "string"
17:14:58 <lambdabot> a
17:15:12 <ReinH> You don't have to guess. ;)
17:15:36 <chrisdotcode> ReinH: Off the top of your head, do you know if there's a arg parsing library that gives you back a Data.Map? Or do I get to be cool and implement it? :D
17:15:50 <EvanR_> :t getArgs
17:15:50 <lambdabot> Not in scope: ‘getArgs’
17:16:02 <chrisdotcode> getArgs gives you a list
17:16:13 <EvanR_> chrisdotcode: how would a Map work?
17:16:14 <ReinH> chrisdotcode: I don't.
17:16:24 <Axman6> chrisdotcode: why do you want a map when you can much nicer interfaces using things like optparse-applicative
17:16:25 <EvanR_> in the case that you dont have flags for some options
17:16:32 <chrisdotcode> ^
17:16:46 <chrisdotcode> --name=chrisdotcode gets you Just chrisdotcode, or nothing
17:16:54 <chrisdotcode> So you can work with arbitrary arguments
17:16:59 <EvanR_> chrisdotcode: not arbitrary
17:17:06 <EvanR_> foo --name=bar baz
17:17:14 <betaveros> hi, is cabal install supposed to get old versions of packages under some circumstances?
17:17:32 <ReinH> betaveros: with version constraints or an out-of-date index, sure
17:17:35 <chrisdotcode> Sure, that would give something like, (Just True), (Just "bar"), (Just True) , EvanR_
17:17:49 <chrisdotcode> Still haven't figured it out 100%, but if it doesn't exist, I'd love to get on it.
17:17:52 <EvanR_> chrisdotcode: eh... hows that map
17:18:03 <chrisdotcode> er, because you'd have to query it
17:18:06 <chrisdotcode> I shortcutted it
17:18:11 <ReinH> chrisdotcode: Maps are not heterogenous.
17:18:12 <EvanR_> chrisdotcode: make a type for the possible configuration options then use optparse-applicative to build it
17:18:19 <Axman6> chrisdotcode: check out optparse-applicative, you get things like: optional ( strOption (long "host"<> short 'H'<> metavar "HOST"<> help "PostgreSQL hostname")) which gives you both -H and --host flags, with --host=foo and --host foo syntax, and nice, neat documentation
17:18:20 <chrisdotcode> ReinH: OH, yeah. True.
17:18:22 <chrisdotcode> Forgot about that
17:18:27 <ReinH> You'd be restricted to a stringly typed map or something equivalent
17:18:41 <chrisdotcode> ReinH: Yeah, shoot. Existential types are looking like the solution here.
17:18:47 <chrisdotcode> Or some wrapper parser type.
17:18:48 <Axman6> :(
17:18:52 <EvanR_> no
17:19:01 <chrisdotcode> Axman6: I'm looking for something where you don't have to specific it all upfront.
17:19:07 <ReinH> chrisdotcode: I think this is a "Doctor it hurts when I try to do this" moment.
17:19:08 <Axman6> @hackage optparse-applicative
17:19:09 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
17:19:34 <Axman6> I'm sure there's ways to get all the remaining flags and handle them too
17:19:45 <EvanR_> chrisdotcode: if you dont know what the arguments are going to be like, then all you have is a list of strings, and you already have it ;)
17:19:50 <chrisdotcode> ReinH: I'm not privy to the evils of existentials as yet, but are they so evil for hetrogeneous lists?
17:20:02 <ReinH> chrisdotcode: heterogeneous lists are the evil, generally.
17:20:04 <EvanR_> its not heterogenous
17:20:04 <benzrf> chrisdotcode: hetero listst are evil
17:20:10 <ReinH> @google existential antipattern
17:20:11 <lambdabot> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
17:20:12 <benzrf> gay lists only
17:20:17 <ReinH> benzrf: please :(
17:20:17 <chrisdotcode> hahaha
17:20:41 <chrisdotcode> EvanR_: Well, the point is as you've said - the ability to query for non-existent elements or not
17:20:48 <Axman6> homolists4lyf
17:20:52 <EvanR_> chrisdotcode: you dont want to specify, yet you want various types to represent your arguments... what types? ;)
17:21:10 <chrisdotcode> EvanR_: Yup. The problem ReinH just alerted me too...
17:21:31 <EvanR_> turns out you often do want to specify stuff
17:21:35 <EvanR_> and it is good
17:21:50 <ReinH> chrisdotcode: to be fair, we use heterogeneous lists in places, but we have Reasons[TM]. Also they are pretty annoying to work with so I wish we didn't.
17:21:54 <Hijiri> EvanR_: Read a => a
17:21:56 <EvanR_> theres no such thing as "anything programming" as often advertised in dynamic languages
17:22:03 <betaveros> is `cabal install foo bar` equivalent to `cabal install foo; cabal install bar`?
17:22:09 <EvanR_> Hijiri: yeah you specified the Read interface
17:22:34 <ReinH> betaveros: iinm the former will attempt to find compatible versions of foo and bar
17:22:44 <chrisdotcode> ReinH: Yeah, for this use case, I might not mind existentials, considering I want a Map String magical_anything
17:22:46 <Axman6> betaveros: not necessarilly because the decisions about which versions of packages are installed may differ
17:22:50 <chrisdotcode> Or, I might just go with String String
17:22:57 <betaveros> which is better?
17:23:08 <Axman6> the former will try to find bestions of deps what are sompatible with both foo and bar is they share any
17:23:11 <Axman6> the former
17:23:31 <ReinH> chrisdotcode: So, the issue isn't that you can't create this map. It's that it's very hard to *use* it.
17:23:39 <ReinH> chrisdotcode: You can't pattern match, for instance.
17:23:44 <betaveros> yesterday I tried to `cabal install classy-prelude hoogle` and cabal tried to install `hoogle-4.0.0.5` and it failed
17:24:02 <betaveros> but classy-prelude succeeded, and then I ran `cabal install hoogle` and it succeeded too
17:24:08 <betaveros> so i’m really confused right now
17:24:10 <chrisdotcode> ReinH: Right. Map String String is looking like the solution, and the user will have to convert. It seems like a fun project if it doesn't already exist :)
17:24:28 <EvanR_> chrisdotcode: how does gcc -o out code.c go into that map?
17:24:41 <Axman6> what if you want Map String [String] so you can do --file foo bar baz
17:26:04 <chrisdotcode> Oh, yeah, Axman6 is right
17:26:14 <chrisdotcode> EvanR_:
17:26:17 * Axman6 is always right, except when he isn't
17:26:33 <chrisdotcode> Woud look like: Map [("-o", "code.c")]
17:26:37 <chrisdotcode> er
17:26:41 <chrisdotcode> Woud look like: Map [("-o", ["code.c"])]
17:27:19 <ttt_fff> does ghc have a "-W-really-fucking-paranoid" flag? where it checks that (1) "error" is not used anywhere, and (2) there are no pattern match fails, and (3) there is nothing of the form "Just x = ( :: Maybe)"
17:27:23 <Axman6> what if the last argument is special, like the output file, or a list of input files?
17:27:45 <ttt_fff> basically something where, in pure code, the only thing that can kill me is a division by 0
17:27:54 <solatis> is it generally considered worth the effort to use SafeHaskell ?
17:27:55 <ReinH> ttt_fff: that's impossible
17:28:03 <ttt_fff> ReinH: halting problem?
17:28:06 <ReinH> ttt_fff: that's equivalent to solving the halting problem, yes
17:28:07 <ttt_fff> ReinH: I accept infinite loops too
17:28:10 <solatis> or rather, are there any reasons to *not* try to use SafeHaskell ?
17:28:10 <ReinH> since non-termination is also bottom
17:28:19 <ttt_fff> ReinH: I accept infinite loops + division by 0
17:28:22 <shachaf> GHC doesn't have that mode, but it could.
17:28:30 <ReinH> ttt_fff: It sounds like you want a total language. Haskell isn't one of those.
17:28:32 <vanila> it's nothing to do with halting problem
17:28:32 <chrisdotcode> Axman6: Maybe a special "arguments"? Map [("arguments", ["arg1", "arg2"])]
17:28:34 <shachaf> What you're asking for is mostly just syntactic.
17:28:52 <ttt_fff> vanila: are you referring to Rice's Lemma ? where any non-trivial property of prog is undecidable?
17:28:58 <ttt_fff> shachaf: yeah, thats what I was thinking
17:29:03 <vanila> you can check that error is not used easily just look at each free variable
17:29:05 <ttt_fff> shachaf: but ReinH sounded confident
17:29:16 <ReinH> ttt_fff: I thought you wanted to avoid bottoms.
17:29:17 <vanila> you can check that pattern matches have full coverage
17:29:21 <Axman6> chrisdotcode: how do you handle --files in1 in2 out?
17:29:34 <ttt_fff> ReinH: how do I check for full coverage?
17:29:55 <Axman6> chrisdotcode: you may not want these interfaces btw, just thought it would be good to point out that this is easier said than done =)
17:30:06 <chrisdotcode> No, I'm glad you're asking me these :)
17:30:11 <chrisdotcode> Axman6: that seems like '--' to me, e.g.: "foo --files in1 in2 -- out
17:30:18 <chrisdotcode> You know, standard unix
17:30:34 <chrisdotcode> *POSIX, I guess?
17:31:02 <Axman6> well, it's _a_ convention that's often used anyway
17:31:02 <Clint> that's a GNUism
17:31:26 <Axman6> there are worse conventions
17:31:32 <chrisdotcode> So I think it'll be fine, if documented.
17:31:38 <geekosaur> which? the bare -- is POSIX from SVID
17:31:49 <geekosaur> long options prefixed by -- is GNU
17:31:58 <chrisdotcode> The former, geekosaur
17:32:04 <Axman6> SVID?
17:32:14 <geekosaur> AT&T's System V Interface Definition
17:32:27 <Axman6> right
17:32:33 <geekosaur> ...possibly older than you are, come to think of it
17:32:48 <bitemyapp> cmccann: see me in #haskell-ops?
17:33:31 <cmccann> bitemyapp: ? is that a request to join the channel or a question
17:33:39 <bitemyapp> cmccann: please join the channel so I can ask something of you.
17:34:08 <Axman6> "see me in my office please"
17:37:08 <EvanR_> ttt_fff: i think its funny you wanted ghc to solve the halting problem but allow division by zero to go through undetected
17:37:26 <ttt_fff> EvanR_: I did not require it go solve the halting problem
17:37:36 <ttt_fff> I just wanted no pattern match errors and no "error 'blah'" to occur
17:37:49 <ttt_fff> i'm not requiring it zhow my prog is correct; I just want to limit the type of errors I can have
17:37:59 <ttt_fff> and division by 0s is rarely the cause of my problems
17:38:18 <EvanR_> you can do -Wall to get warnings about some of those low hanging fruit problems
17:39:36 <EvanR_> chrisdotcode: going from list of strings to Map String String is at best not doing much of a favor to someone who wants to get meaningful information out of the argument language they invented. its only parsing half way at best. better to make a language to go from list of strings to meaningful types
17:39:58 <platz> "I'd call compiler optimization an endless chasm of eternal darkness, except that it's pretty fun." - yegge
17:40:12 <chrisdotcode> EvanR_: It's for quick-and-dirty parsing
17:40:13 <the_other_cat> Hi, i have a list A and a subset of this list B. B is to be sorted as as A is, but may misses some elements of A. i can do this recursivly, but is there a more elegant way?
17:40:19 <mniip> platz, depends on the compiler
17:40:25 <EvanR_> chrisdotcode: quick and dirty can be done on the list of strings ;)
17:40:36 <chrisdotcode> EvanR_: And that's what I'm doing ;)
17:40:40 <chrisdotcode> Besides, I need more haskell projects to do.
17:40:49 <platz> mniip: I have not experienced these things yet.. maybe someday
17:41:18 <mniip> a friend of mine has been deveoping some GPU LLVM backends, says he's pretty sick of this stuff
17:41:59 <EvanR_> also theres quick and clean
17:42:28 <platz> someone in here said compared to front-end dev mess, compilers weren't so bad.
17:42:52 <platz> I think in any domain there are idioms, you get familiar with them, it seems less scary
17:42:54 <Hafydd> > let (listA, listB) = (['a'..'z'], "hello") in filter (`elem` listB) listA -- the_other_cat: what do you mean by "recursively"?
17:42:56 <lambdabot>  "ehlo"
17:43:13 <Hafydd> Note: the above can repeat elements of listA.
17:43:15 <cmccann> bitemyapp: http://i.imgur.com/wYxgcuX.png
17:43:30 <bitemyapp> cmccann: <3
17:43:45 <betaveros> after a fresh install of the haskell platform, is it a good idea to cabal (re)install some of the packages that come with it?
17:44:36 <the_other_cat> Hafydd: perfect, thanks
17:45:07 <Hafydd> But in fact the problem becomes ill-defined if listA contains non-distinct elements which are not contiguous; and if they are contiguous, you use "nub" to remove the duplicates.
17:45:40 <Hafydd> However... if listB does contain repeated elements, those will be lost.
17:45:55 <the_other_cat> thanks, both lists don't contain muliples
17:47:58 <Hijiri> betaveros: If you don't want some of the haskell platform packages, or newer versions, just install ghc and cabal separately
17:48:49 <Hijiri> reinstalls often break things due to how ghc inlines lots of things
17:49:02 <Hijiri> and you can't remove global packages or hide them with cabal
17:49:18 <betaveros> so start https://www.haskell.org/ghc/download_ghc_7_8_4 ?
17:50:24 <Hijiri> betaveros: yes
17:50:28 <Hijiri> well
17:50:31 <Hijiri> what OS?
17:51:02 <Hijiri> it's the easiest way on ganoo/Linux
17:51:25 <betaveros> OS X :-/
17:51:39 <ab9rf> ganoo?  what's ganoo?
17:52:05 <betaveros> 10.9.4
17:52:12 <Hijiri> https://ghcformacosx.github.io/ (linked to on https://github.com/bitemyapp/learnhaskell) is a bit easier for OS X
17:52:19 <Hijiri> but it's one minor version behind
17:52:31 <vanila> so much stupid meme talk in here
17:52:55 <ab9rf> i thinks "stupid meme" might be redundant
17:53:06 <Hijiri> stupid meme is a meme
17:53:25 <ab9rf> it shoul dbe noted that i don't believe in memes
17:53:27 <vanila> Hijiri, aren't you embarassed with yourself?
17:53:44 <mniip> > permutations "adeekmmns" !! 26217
17:53:46 <lambdabot>  "dankmemes"
17:53:52 <bitemyapp> cmccann: I just saw the Semiring thread, lmao
17:54:16 <ab9rf> mniip: i find it a bit scary that you know that
17:54:42 <ReinH> ab9rf: elemIndex
17:54:55 <cmccann> bitemyapp: which one is that again
17:55:01 <ab9rf> ReinH: true
17:55:57 <ab9rf> > let f a = elemIndex a (permutations a) in f "dankmeme"
17:55:58 <lambdabot>  Just 0
17:56:03 <ab9rf> bah
17:56:11 <ab9rf> > let f a = elemIndex a (permutations (sort a)) in f "dankmeme"
17:56:13 <lambdabot>  Just 26217
17:56:14 <bitemyapp> cmccann: anti-Num
17:56:44 <Zemyla> How donI prevent cabal from running out of memory when doing "cabal update"?
17:56:51 <ab9rf> Zemyla: give it more memory
17:56:59 <Zemyla> ab9rf: How?
17:57:05 <cmccann> bitemyapp: oh yeah. I have a long-standing grudge against Num.
17:57:12 <benzrf> Zemyla: does this look like ##linux
17:57:14 <benzrf> or, uh
17:57:17 <benzrf> whichever OS youre on
17:57:18 <ab9rf> Zemyla: that's an OS quesiton
17:57:58 <Zemyla> Well, it probably means I'm fucked, since I can't give it any more memory.
17:58:08 <ab9rf> Zemyla: what are you trying to run cabal on?
17:58:09 <Hijiri> a couple times I ran out of memory compiling something with a lens dep
17:58:17 <ab9rf> what hardware?
17:58:19 <Hijiri> usually because I was doing it with 8 jobs
17:58:25 <Zemyla> ab9rf: An Amazon EC2 Linux box.
17:58:45 <mniip> > elemIndices <*> (permutations <$> sort) $ "dank memes" -- ab9rf
17:58:48 <lambdabot>  [286242,287810,326562,328130]
17:58:58 <ab9rf> Zemyla: you probably either have the machine underprovisioned, you have a ulimit set, or some other fun thing
17:59:04 <ab9rf> mniip: cute
17:59:20 <ab9rf> Zemyla: go ask in the amazon EC2 support forum :)
17:59:28 <bitemyapp> Zemyla: make a swap
17:59:35 <bitemyapp> Zemyla: swapon, then set swappiness to 100
17:59:39 <bitemyapp> Zemyla: been there, fixed that.
17:59:51 <bitemyapp> Zemyla: do that first before accepting that HTTP 301 you just got
18:00:13 <bitemyapp> I do recommend not compiling software on slow EC2 machines tho
18:00:16 <Hijiri> I'm having a problem where my swap is never filled past 1%, will setting swap to max fix that too?
18:00:21 <Hijiri> on my laptop
18:00:29 <Hijiri> it's set to 30 or something right now, not sure
18:00:58 <Zemyla> bitemyapp: My laptop died. I'm sshing to it from an Android tablet. Should I compile my programs on that?
18:01:47 <mniip> rats
18:01:51 <mniip> it doesn't fit in an irc line
18:04:43 <Zemyla> bitemyapp: And should I never update anything?
18:05:01 <vanila> is a transpiler is just a lense between programming languages?
18:07:34 <Zemyla> Why does GHC use so much damn memory? Is it strictness problems?
18:07:50 <betaveros> so it’s best practice right now to make one sandbox for almost every library/executable?
18:08:11 <betaveros> i’ve nuked my haskell installation for like the fourth time in two days and i want to do things right this time
18:08:43 <betaveros> one box for ghc-mod, one box for idris, one box for wreq…
18:09:21 <pingu> betaveros: try stackage if you want stability
18:09:33 <darkroom> I just used applicatives for the first time in a real life application. It was beautiful
18:09:59 <betaveros> pingu: stackage doesn’t have idris :(
18:10:42 <betaveros> (or will it still work and I’m misunderstanding?)
18:10:53 <vanila> maybe you could install idris' deps, then build idris from git manually
18:10:56 <vanila> that's what I do
18:11:53 <bmuk> Hey guys, I'm trying to work with STDIN as a raw ByteString. System.Posix.Env.ByteString (getArgs) gives me a Data.ByteString.Internal.ByteString, which I can't print with Data.ByteString.putStrLn
18:12:32 <bmuk> I should include that I'm trying to use lazy ByteStrings, maybe I have to use Strict?
18:12:47 <ab9rf> what happens when you try to print it?
18:12:55 <betaveros> vanila: is your idris sandboxed?
18:12:55 <yyyyy> betaveros: i used to keep a sandbox for idris and symlink it to a separate bin directory, but i'm finding it easier to use a homebrew build nowadays. I don't mind if it's a little bit behind HEAD.
18:13:01 <ab9rf> does it not typecheck, or does it behave weirdly?
18:13:16 <vanila> betaveros, no, probaly should be -  i didnt work out how to doany of that stuff
18:13:35 <vanila> I just erase ~/.ghc and ~/.cabal every time I want to use haskell, because it's the only way to do anything wit this broken infrastructure
18:13:38 <bmuk> ab9rf: I'm getting a type error
18:13:56 <ab9rf> bmuk: can you put the code and the type error in a pastebin (lpaste.net), perhoops?
18:13:56 <bmuk> but I just tried with vanilla ByteString.putStrLn
18:14:01 <Hijiri> I group some things together
18:14:08 <Hijiri> xmobar and xmonad are in the same sandbox
18:14:20 <ab9rf> idris always makes me think of darkskinned asgardians
18:14:24 <betaveros> what’s installed globally?
18:14:35 <bmuk> strict bytestring worked, but I'm getting a warning about ByteString.putStrLn being deprecated,
18:14:51 <Hijiri> I have the things that come with ghc installed globally
18:14:58 <bmuk> what is the blessed way to write and read raw binary data from STDIN and STDOUT?
18:15:21 <betaveros> bmuk: I think putStr
18:15:47 <betaveros> non-deprecated putStrLn is from ByteString.Char8 because it rests on a char-ish interpretation of newline
18:17:15 <bmuk> betaveros: true; I want my program to not screw up the command line when it's run by itself (that's why I'm using putStrLn instead of putStr), but will this mess things up when I use it in a pipe? I.e. cat binaryfile | myprogram | whatever else
18:18:12 <cmccann> bmuk: there are conversion functions in Data.ByteString.Lazy to and from strict bytestrings btw
18:18:59 <ab9rf> yeah, there's a toStrict
18:19:52 <bmuk> I don't necessarily need lazy for this - I'm just converting hex data to base64
18:20:11 <bmuk> I was just thinking lazy would perform better with super large files
18:20:19 <ab9rf> bmuk: no, probably not
18:20:30 <mniip> *crosses fingers*
18:20:32 <mniip> > let h=head;t=tail;f=flip;b=f f;d=(.);e=d.d;g=b h;i=b t;a=ap;c=(:)in a((f a t).(.h).i.(a.).g.(d.).i.((f.(a.)).).g.((f.(d.)).).i.((f.((f.(a.)).)).).g.((f.((f.(d.)).)).).i.((f.((f.((f.(a.)).)).)).).g.((f.((f.((f.(d.)).)).)).).i.((f.((f.((f.((f.(a.)).)).)).)).).g.((f.((f.((f.((f.((d.(const.)).)).)).)).)).).f(e.e.d.c).(.(((f(d.c).).).f(e.c).liftM2 d c.ap(e.c)(f(d.c).(.(:[])).c))).e.e.c.h)t "adekmns"
18:20:32 <ab9rf> bmuk: lazy is mainly useful when you expect not to use all of the data
18:20:33 <lambdabot>  "dankmemes"
18:20:40 * ab9rf thwaps mniip 
18:20:41 <cmccann> mniip: whyyyyyyy
18:20:57 <bmuk> ab9rf: true; I should stick with strict then
18:21:22 <bmuk> am I going to run into issues with the new line when my program is used in a pipe?
18:21:32 <ab9rf> bmuk: why would you?
18:22:04 <bmuk> ab9rf: I don't know. I was just thinking there could be an edge case there. I realize now that that's probably stupid
18:22:13 <ab9rf> bmuk: if you're just doing Base64, then use the nondeprecated putStrLn in Data.ByteString.Char8
18:22:39 <ab9rf> base64 output is going to be in 7-bit ASCII so you don't have to worry about unicode issues
18:22:55 <betaveros> ok, i’m trying to install idris yet again and there are a lot of “Unrecognized field data-dir on line 32” and “Unrecognized field key on line 4”
18:23:08 <yyyyy> mniip: how do you even come up with that...?
18:23:08 <bmuk> so I need to import Data.ByteString.Char8 as well?
18:23:11 <betaveros> anybody recognize that?
18:23:23 <mniip> well I started with output of `pointfree`
18:23:23 <ab9rf> betaveros: it means you're using the wrong version of cabal
18:23:42 <bmuk> or does Data.ByteString.Char8 provide all the ByteString functions as well?
18:24:02 <ab9rf> bmuk: i won't guarantee it, but i think .Char8 is a full implementation, yes
18:24:20 <betaveros> should i not have run cabal install cabal-install after installing ghc from the OS X .app?
18:24:23 <betaveros> aggh
18:24:31 <bmuk> ab9rf++ thank you
18:24:50 <ab9rf> bmuk: check hackage docs if you're not sure
18:24:54 <ab9rf> http://hackage.haskell.org/package/bytestring-0.10.4.1/docs/Data-ByteString-Char8.html
18:24:55 <mniip> do you mean
18:24:58 <mniip> modify (+1)
18:25:00 <mniip> :P
18:26:17 <ab9rf> mniip: that "liftM2" in the middle is a bit hugly
18:27:11 <Axman6> hugly = ugly haskell?
18:27:52 <ab9rf> mniip: nice job proving that haskell can be made quite thorouhgly obfuscated
18:28:37 * hackagebot http2 0.8.0 - HTTP/2.0 library including frames and HPACK  http://hackage.haskell.org/package/http2-0.8.0 (KazuYamamoto)
18:28:45 <betaveros> oh i didn’t restart my terminal :(
18:28:59 <hpc> that was quick
18:29:14 <hpc> didn't the spec just come out a week ago?
18:45:20 <bmuk> Is there a succinct way to represent if '0' <= foo and foo <= '9' in a guard?
18:45:52 <mauke> inRange ('0', '9') foo
18:45:53 <mniip> ab9rf, everything becomes so simple if we define functors over strings
18:46:51 <bmuk> mauke++
18:47:37 <betaveros> ok i think i’ve gotten idris to fail to build in three different ways since yesterday :)
18:47:55 <mniip> > let join (x:xs) = x:x:xs; flip (x:x':xs) = x':x:xs; lift f (x:xs) = x:f xs in flip . lift (lift (lift (lift (lift (lift flip . join . flip) . join . flip) . flip) . flip)) $ "adenkms"
18:47:56 <lambdabot>  "dankmemes"
18:48:11 <betaveros> luckily there’s a github issue with a solution so i guess it’ll be ok
18:48:13 <mniip> er
18:48:23 <mniip> functor is a wrong word, I think combinator is more fitting
18:48:33 <bmuk> Is there a way I can add and subtract chars?
18:48:38 * hackagebot objective 0.6.5.1 - Extensible objects  http://hackage.haskell.org/package/objective-0.6.5.1 (FumiakiKinoshita)
18:48:42 <ab9rf> bmuk: ord
18:48:47 <Axman6> :t ord
18:48:49 <lambdabot> Char -> Int
18:49:00 <ab9rf> > (ord 'k' - ord 'a')
18:49:01 <lambdabot>  10
18:49:12 <Axman6> and chr to go back... if that's really what you want
18:49:19 <mniip> :t on (+) ord
18:49:20 <lambdabot> Char -> Char -> Int
18:49:26 <ab9rf> > chr (ord 'A' + ord 'k' - ord 'a')
18:49:27 <lambdabot>  'K'
18:49:30 <bmuk> Axman6: should I not be doing that?
18:49:35 <ab9rf> note: do not attempt to implement toUpper that way :)
18:49:53 <bmuk> I'm trying to implement this http://cryptopals.com/sets/1/challenges/1/cpp/
18:49:59 <Axman6> > map (chr . subtract (ord '-')) "ABC"
18:50:01 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘GHC.Types.Int’
18:50:01 <lambdabot>  Expected type: [GHC.Types.Int]
18:50:01 <lambdabot>    Actual type: [GHC.Types.Char]
18:50:13 <Axman6> > map (chr . subtract (ord '-') . ord) "ABC"
18:50:14 <lambdabot>  "\DC4\NAK\SYN"
18:50:26 <mniip> bmuk, that says C++ :P
18:50:36 * geekosaur secretly replaces ab9rf's encoding with EBCDIC... where is your uppercase now? :p
18:51:00 <mauke> > digitToInt 'Z'
18:51:01 <lambdabot>  *Exception: Char.digitToInt: not a digit 'Z'
18:51:08 <mauke> well, that's dumb
18:51:09 <mniip> also I don't see how the title corellates with the code provided
18:51:45 <bmuk> mniip: lol I know. That is the functionality I am trying to implement
18:52:29 <bmuk> I figured since hex is base 16 I could somehow squash four characters of the hex stream into a single character of base64
18:52:43 <bmuk> not sure how I'd go about doing that though
18:53:28 <benzrf> hey edwardk
18:54:01 <benzrf> would there be anything for my knows-enough-haskell-to-write-factorial friend at the monthly meetup
18:54:07 <benzrf> should i drag him there :3
18:54:15 <mauke> bmuk: to decode a single hex char you can use digitToInt
18:54:19 <ab9rf> geekosaur: there's a reason i said not to atempt to inplement toUpper that way :)
18:54:49 <geekosaur> no, ebcdic is worse :)
18:55:01 <scott> Char -> Char isn't even the right type for toUpper
18:55:08 <scott> the uppercase of ß is SS
18:55:46 <bmuk> mauke: I could map that over the input, I would just need to convert the int into base64 then
18:55:51 <bitemyapp> Zemyla: usually large amounts of memory use while compiling is the linker, rather than GHC itself.
18:55:52 <ab9rf> scott: details :)
18:56:19 <ab9rf> geekosaur: ebcdic has gaps in the alphabetic encoding, doesn't it?
18:56:20 <mauke> scott: ẞ
18:57:28 <geekosaur> it does but for simpleminded uc/lc it's still a fixed shift. just a different one
18:57:36 <dfeuer> carter, after much head-pounding and time-wasting, I think the thing to do is probably something like   newtype STE s e a = STE (State# s -> e -> (# State# s, e, a #))
18:57:44 <ab9rf> that's riught, the alphabt is in three segments of 9 each, with the letter ~ between r and s
18:57:55 <scott> mauke: apparently ẞ vs SS is contested, but there are other examples and Char -> Char is still the wrong type
18:58:09 <pacak> > map toUpper "你好"
18:58:10 <lambdabot>  "\20320\22909"
18:58:15 <carter> dfeuer: oh?
18:58:29 <ab9rf> scott: i think the formal posiution of the unicode peopele is that ß has no upper case
18:58:44 <benzrf> > text $ map toUpper "你好"
18:58:45 <lambdabot>  你好
18:58:50 <ab9rf> but in general, yes, there are fails
18:58:51 <dfeuer> carter, the problem with StateT v (ST s) a   is that converting the strict version to a lazy one seems to be impossible :-(
18:59:05 <carter> when do you want the lazy one?
18:59:11 <benzrf> pacak: 你好
18:59:30 <dfeuer> carter, when you need to tie recursive knots, most particularly.
18:59:33 <pacak> text? Oh noes, ghc cannot into unicode!
18:59:34 <carter> ah
18:59:35 <benzrf> pacak: 你喜欢haskell吗？
18:59:42 <betaveros> ok what `cabal install idris` failed and `cabal install idris —allow-newer` failed but then when it’s followed by `cabal install idris` again it works
19:00:22 <pacak> benzrf: Весьма. И я пользуюсь им каждый день.
19:00:24 <betaveros> oops I forgot to init the sandbox
19:00:26 <dfeuer> The trouble is that you can't get to the ST until you've gotten through the StateT, and so if your laziness is the wrong way around, you're screwed. Or at least I think that's what's going on.
19:00:35 <benzrf> i dont know russian :?
19:00:47 <ab9rf> betaveros: i get that quite a bit, not sure why
19:00:49 <carter> betaveros: sanboxes and building compilers is nasty busiennss
19:01:40 <betaveros> ok so now despite trying again and again to preempt cabal hell, i went and accidentally installed idris globally anyway
19:01:52 <carter> betaveros: its really hard to get cabal hell
19:02:06 <carter> unless you're using things that dont have upper bounds :)
19:02:12 <betaveros> do I just go about the rest of my business and hope it doesn’t break
19:02:19 <betaveros> or should i reinstall again
19:02:32 <dfeuer> betaveros, yes. And then when it breaks, wipe .ghc and start over.
19:02:50 <dfeuer> No point preemptively wasting[ time.
19:02:56 <carter> yeah
19:02:58 <carter> seriously
19:03:19 <carter> only use sandboxes for projects that have a LONG dev lifecycle that you're working on
19:03:23 <carter> or doing archaology on
19:03:26 <carter> or yesod
19:03:29 <dfeuer> ?
19:03:36 <carter> otoh, yesod folks should probably just use stackage
19:03:42 <dfeuer> carter does not believe in sandboxes?
19:03:49 <carter> i think they're useful
19:03:52 <carter> i use them seomtimes
19:04:00 <carter> i just only use them when normal installs get crazy
19:04:07 <carter> or if i'm working on a long lived complicated app like thingy
19:04:18 <cmccann> carter dreams big and makes the world his sandbox
19:04:22 <carter> yes
19:04:30 <carter> cmccann: expldoing the univers is fun
19:04:32 <dfeuer> Your computer must be faster at rebuilding everything than mine is.
19:04:48 <carter> dfeuer: i dont have to build the universe that often because i dont use things with bad bounds
19:05:20 <Buttons840> is there a more concise way of writting \a b -> take 3 (iterate a b)   ?
19:05:28 <carter> take 3 . iterate
19:05:32 <carter> errr
19:05:39 <Buttons840> carter: yeah, that's what I thought, but
19:05:45 <carter> not quiet
19:05:48 <dfeuer> So carter, what I was thinking were that adding an extra thingum to make STE instead of ST would give a relatively simple slide back and forth between "strict ST with extra state" and "lazy ST with extra state". Is that sane, or insane?
19:05:55 <enthropy> @pl  \a b -> take 3 (iterate a b)
19:05:55 <lambdabot> (take 3 .) . iterate
19:06:05 <vanila> \a -> take 3 . iterate a
19:06:16 <Buttons840> vanila: nice :)
19:06:23 <carter> uncurry $ take 3 . curry iterate
19:06:30 <ab9rf> now i want curry
19:06:39 <carter> errr
19:06:41 <dfeuer> ab9rf, that's exactly what I was thinking.
19:06:42 <carter> i mena
19:06:48 <carter> curry $ take 3 . uncurry iterate
19:07:04 <carter> :t 	curry $ take 3 . uncurry iterate
19:07:05 <lambdabot> (a -> a) -> a -> [a]
19:07:37 <betaveros> alas, right away I realize ghc-mod threatens to break idris and wreq
19:07:57 <dfeuer> Sorry, betaveros.
19:08:07 <carter> betaveros: oh
19:08:12 <carter> whys that
19:09:06 <cmccann> > (take 3 .: iterate) (* 2) 2
19:09:08 <lambdabot>  [2,4,8]
19:09:26 <carter> cmccann: i appreciate the education work you've been doing on reddit :)
19:09:33 <carter> cmccann: as always, nice to see you active agian !
19:09:39 <cmccann> heh, thanks
19:09:43 <ab9rf> i can't bring myself to use reddit
19:13:01 <cmccann> ab9rf: /r/haskell is fine, most of reddit is a crapfest tbh
19:15:22 <MP2E> yeah
19:21:08 <mniip> bmuk--- oh they left
19:21:53 <ReinH> carter: o/
19:21:57 <carter> yo
19:21:57 <mniip> > map (((['A'..'Z']++['a'..'z']++['0'..'9']++"+/") !!) . foldl setBit 0 . findIndices id) . filter ((6 ==) . length) . scanl (flip (:) . (filter =<< const . (6 /=) . length)) [] . concatMap (flip map [3,2..0] . testBit . digitToInt) "49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d"
19:21:59 <lambdabot>  Couldn't match expected type ‘a -> [GHC.Types.Bool]’
19:21:59 <lambdabot>              with actual type ‘[GHC.Types.Bool]’
19:22:06 <mniip> damn you
19:22:24 <mniip> > map (((['A'..'Z']++['a'..'z']++['0'..'9']++"+/") !!) . foldl setBit 0 . findIndices id) . filter ((6 ==) . length) . scanl (flip (:) . (filter =<< const . (6 /=) . length)) [] . concatMap (flip map [3,2..0] . testBit . digitToInt) $ "49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d"
19:22:25 <lambdabot>  "SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t"
19:24:03 <mniip> 'filter ((6 ==) . length) . scanl (flip (:) . (filter =<< const . (6 /=) . length)) []' is like a genealized chunksOf \o/
19:25:02 <carter> ReinH: when does privmail or whtever launch?
19:25:12 <ReinH> carter: who can say
19:28:22 <akurilin3> question: what's the correct way to fail parsing with Aeson without actually throwing an exception? Is "fail" the right fn to use there? http://lpaste.net/8624637146067632128
19:29:42 <akurilin3> it seems like returning mzero gives me what I was as opposed to doing a fail within a Parser
19:31:35 <fresheyeball> hey folks
19:31:40 <fresheyeball> I am reaching for a specific function
19:31:47 <fresheyeball> and am unsure if it already exists
19:31:55 <fresheyeball> I want to take a monoid
19:32:10 <fresheyeball> or a value of a monoid
19:32:16 <fresheyeball> and if that value is id
19:32:17 <blueonyx> akurilin3: mzero is what the introductory example at http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html suggests
19:32:32 <fresheyeball> then replace it with a value
19:32:34 <fresheyeball> so like
19:32:34 <akurilin3> blueonyx: yes, however I have no idea how to throw it from WITHIN Parser
19:32:42 <fresheyeball> let foo = []
19:32:48 <fresheyeball> let bar = [1,2,3]
19:32:49 <akurilin3> blueonyx: I tried to return it from the outside, but I can't pattern match on Parser
19:32:56 <akurilin3> blueonyx: so I'm stumped :|
19:33:02 <fresheyeball> defaultMonoid [1] foo = [1]
19:33:08 <johnw> fresheyeball: if you multiple your value with id, and the answer is id, then the value was id
19:33:25 <fresheyeball> defaultMonoid [1] bar = [1,2,3]
19:33:29 <johnw> s/id/mempty*
19:33:52 <fresheyeball> sure I can find id
19:34:03 <fresheyeball> just wondering if there is something already out there for this
19:34:11 <fresheyeball> Monoid a => a -> a
19:34:15 <fresheyeball> not helpful for hoogle
19:34:16 <blueonyx> akurilin3: how you call fail? care to share some code?
19:34:46 <akurilin3> blueonyx: http://lpaste.net/8624637146067632128
19:34:54 <Rotaerk> ghci seems to crash a lot when I'm doing stuff with HXT
19:36:49 <akurilin3> if I do "<*> mzero" instead of that fmap line then it works perfectly
19:37:00 <akurilin3> so I want to recreate whatever mzero is doing
19:37:24 <akurilin3> I think if I were able to somehow match the result of o.:"responses" that'd get me what I want
19:38:31 <scott> fresheyeball: your function would have to also constrain the type with Eq to check if the input is mempty
19:38:49 <fresheyeball> yes
19:39:13 <scott> fresheyeball: I doubt it already exists, at least not as a well known thing. easy enough to write yourself, though
19:39:32 <fresheyeball> mdefault :: Monoid a, Eq a => a -> a -> a
19:39:37 <fresheyeball> I wrote it sure
19:39:47 <fresheyeball> it just seems alternativeish to me
19:39:53 <fresheyeball> so I wondered if it was already out there
19:42:42 <blueonyx> :t catMaybes
19:42:43 <lambdabot> [Maybe a] -> [a]
19:43:23 <blueonyx> akurilin3: ^ is that what you need? you want all elements for which NE.nonEmpty returns not Nothing?
19:45:50 <meretrix> Is it possible to compile a static Haskell library that can be loaded into in ghci?
19:46:17 <meretrix> I want to be able to deploy a library on a system without having to install all of the Haskell dependencies.
19:46:52 <meretrix> *loaded in ghci
19:52:07 <betaveros> Is there an easy way to list all the direct and indirect dependencies of a cabal package?
19:53:42 * hackagebot takahashi 0.2.0.1 - library for takahashi method.  http://hackage.haskell.org/package/takahashi-0.2.0.1 (outoftune)
19:54:49 <athan> betaveros: I think --dry-run might do that :)
19:55:27 <betaveros> thanks, that works
19:55:55 <vanila> Bryan O'Sullivan ‏@bos31337 1h1 hour ago
19:55:55 <vanila> I'm saddened to see how @bitemyapp continues to be such a negative presence near the Haskell community. Wish he would grow up or move on.
19:55:56 <vanila> too right !
19:56:06 <athan> :|
19:56:12 <vanila> people need to stop putting up with bullying, toxic people
19:58:54 <benzrf> hmm
19:58:59 <benzrf> what did he say now
19:59:03 <athan> vanila: Might bring this to -blah, but me personally, I experience a weird prejudice - people think I'm an offensive person simply by how my face looks (I look mean). Idk, I don't think he's a bad person by any means
20:00:15 <Fusebox> I'd like to build a simple 2d game in Haskell, like Tetris or Pong. The aim is to introduce my girlfriend to programming, and games motivate her. I know the basics of Haskell, and have built 2D games in Python. Can anybody point me to tutorials and somewhat standardised libraries?
20:00:16 <vanila> athan, you look perfectly nice to me!  No one is a bad person but some people do nasty things (reminders: boom boom in your codey codes, "cupcake", hounding zedshaw, various other patronization and harassment ...)
20:00:17 <athan> \me is gonna dodge the subject entirely - nothing worse than being outcast!
20:00:29 <athan> goddangit :(
20:00:45 <johnw> I think this is more of a -blah topic
20:02:09 <zachstone> You plan to start her on Haskell?
20:02:15 <bitemyapp> vanila: I did not hound zed shaw
20:02:30 <bitemyapp> vanila: the dude harassed me because I said Haskell was safer than some languages (not directly to him)
20:02:43 <bitemyapp> vanila: was repeatedly abusive, doing the twitter equivalent of screaming at me after I calmed asked him to stop
20:02:58 <bitemyapp> vanila: I eventually had to block him. Don't get yer victim status flipped around
20:03:16 <Fusebox> zachstone: I'd rather not introduce her to impure nonsense if I can help it. My university started all of us on Haskell, and it was fine
20:03:20 <bitemyapp> vanila: I used to be friendly with Zed, before that.
20:03:27 <Fusebox> she can do multivariate calculus
20:03:45 <pnielsen> zed's always been an ass
20:03:56 <bitemyapp> calmly*
20:05:28 <zachstone> Fusebox: Impure nonsense, haha. It's just been my experience that there's a bit more upfront learning you have to to before making things.
20:06:24 <Moggle> Fusebox: Haskell's game development libraries are a little bit less than stellar. I'd recommend starting with python and the pygame library for the easiest way to get her feet wet.
20:06:53 <Fusebox> Yeah, I agree. I'm currently teaching her how to do Breakout in PyGame, but she complained that she preferred Haskell
20:07:22 <Fusebox> I think her mind is just better suited to it. So if I can sort through the cruft and get a good game or graphics library and teach myself then teach her...
20:07:24 <Moggle> You can definitely do Haskell, but I've spent hours pulling my hair out trying to get basic GUI applications up and running (in no small part due to the fact I'm running on Windows).
20:07:45 <Moggle> If you're running on Linux, you'll likely have way fewer issues.
20:08:01 <Moggle> I do all my Haskell development on a Linux box now anyhow because of how annoying it is installing things on Windows.
20:08:04 <Hugehead_> You might want to try Elm, graphics stuff in it is a lot easier http://elm-lang.org/
20:08:22 <Fusebox> I noticed it doesn't have a lot of the higher-level type stuff though
20:08:29 <Hugehead_> And the really easy to use time traveling debugger is a very nice feature
20:08:56 <Fusebox> OK, I'll have a fiddle with Elm. Hopefully it adds stuff as it matures
20:12:05 <dfeuer> @pl \r a -> r $! a+1
20:12:05 <lambdabot> (. (1 +)) . ($!)
20:12:49 <dfeuer> Ew ...
20:13:31 <athan> is that a strict apply, dfeuer?
20:13:57 <dfeuer> @Athan, yes.
20:13:57 <lambdabot> Unknown command, try @list
20:13:59 <wolf_mozart> A scripting language or script language is a programming language that supports scripts, programs written for a special run-time environment that can interpret (rather than compile) and automate the execution of tasks that could alternatively be executed one-by-one by a human operator. http://en.wikipedia.org/wiki/Scripting_language
20:14:00 <dfeuer> er....
20:14:03 <dfeuer> athan, yes.
20:14:27 <wolf_mozart> can i one say that haskell is a script according to the above defination?
20:14:37 <wolf_mozart> given it's level of abstraction
20:15:13 <athan> :o!
20:15:31 <johnw> wolf_mozart: I don't really see it fitting that description; or least, a subset of what Haskell can do can fit that description
20:15:57 <athan> I suppose interpreted mode / hugs would see haskell as a script :s
20:16:44 <wolf_mozart> well can we say haskell is in the family of very high level programming languages?
20:16:45 <athan> It's also difficult to see the step-by-step nature of a haskell program wolf_mozart
20:17:10 <athan> Yes
20:17:55 <dfeuer> athan, lambdabot tells me that length = flip (foldr (const (. (1 +))) id) 0, or to be explicitly strict, length = flip (foldr (const ((. (1 +)) . ($!))) id) 0
20:17:58 <athan> Conceptually, in my opinion, higher level than traditional OO languages, like C++ Java and Ruby
20:18:03 <athan> JavaScript pales in comparison to the almighty, the valient, type-theoretically influenced languages!
20:18:18 <vanila> JavaScript is terrible D:
20:18:20 <ab9rf> ui thiing as to you 're coming dangerously close to arguing as to how many angls fit on the head of a pin.
20:18:25 <athan> :o!!
20:18:39 <athan> That's wonderful dfeuer
20:18:52 <athan> I've never looked at things like this yet :)
20:19:01 <ab9rf> obsessive-compulsives who don't actually program are the ones who want everything divided into "scripting" and "compiled" languages, or whatever categories they like
20:19:14 <athan> vanila: We need to get rid of it :(
20:19:18 <ab9rf> which ignores that most scripting languages are "compiled" (or at least compiled to some degree)
20:19:32 <vanila> athan, I think that it will be improved a little bit soon & then you can compile any langauge you want to it
20:19:38 <athan> It helps them organize the words, ab9rf
20:19:55 <dfeuer> Modern CPUs JIT everything anyway.
20:19:58 <ab9rf> athan: yes, but it's a nearly useless distinction
20:20:00 <dfeuer> So says carter.
20:20:02 <athan> :P
20:20:04 <athan> :D
20:20:29 <athan> it's definitely useless ab9rf, don't misunderstand me, it's just how they think about it
20:20:34 <ab9rf> at best it's poles of a spectrum
20:20:44 <ab9rf> and it's a multipolar spectrum at that
20:20:45 <athan> the daughnting number of terms, walking into the IT field, can be scary
20:21:11 <athan> So people frantically pack things into... segregated ideas :\
20:22:01 <ab9rf> i'm a bit zen on this particular issue
20:22:24 <ab9rf> i don't like trying to shove things into boxes that they don't fit in very well
20:24:43 <ab9rf> why does buildwrapper blow p to 2 gigswhen building this project?
20:25:14 <sgronblo_> Haskell community drama going on?
20:25:43 <johnw> sgronblo_: let's not encourage further discussion here
20:26:45 <sgronblo_> Hehe ok...
20:29:46 <Sonarpulse> Is there any way to derive functor for each type parameter?
20:29:58 <Sonarpulse> I want this soooo bad
20:30:20 <vanila> Sonarpulse, you would have to make newtypes, you can't partialy apply in the way you need to do pick the params out
20:30:43 <Sonarpulse> new types do not work as of ~ 9 mounths ago
20:30:51 <vanila> wow what happened?
20:31:10 <Sonarpulse> I tried to see if that would do the trick
20:31:13 <vanila> how does haskell keep getting worse haha
20:31:26 <Sonarpulse> perhaps generalized new types or something got in the way
20:31:33 <Sonarpulse> and it would have worked otherwise
20:31:36 <vanila> what about trying standalone deriving?
20:31:53 <vanila> oh im not sure
20:31:55 <Sonarpulse> havne't tried
20:32:39 <ReinH> Sonarpulse: what do you mean "new types do not work"?
20:33:43 <Sonarpulse> I was hoping new types would allow be to derive, let's say, Functor Pair, and Functor (Pair left)
20:33:48 <Sonarpulse> (where left is free var)
20:34:01 <Sonarpulse> by wrapping one in the a new type to rearrange parameter order
20:34:12 <Sonarpulse> since IIRC deriving woudl only work on the last parameter
20:35:45 <Cale> Sonarpulse: uh, at most one of those types is the right kind to be an instance of Functor
20:36:00 <Cale> Sonarpulse: If Functor (Pair left) kind checks, then Functor Pair won't.
20:36:05 <Cale> and vice versa
20:36:11 <Sonarpulse> err sorry
20:36:17 <Cale> But maybe I totally don't understand what it is that you mean
20:36:22 <vanila> if you have data F x y z, you have to make  newtype Fx y z x = ...,  newtype Fy x z y = ...
20:36:44 <Cale> FSVO "have to"
20:36:54 <vanila> lol Cale
20:37:01 <Sonarpulse> newtype PairPrime a b = PairPrime (Prime b a)
20:38:07 <Cale> Sonarpulse: okay, so... that *might* have a Functor instance, but I'm not sure I'd expect GHC to be able to derive it
20:38:13 <Sonarpulse> "Functor (Pair left)" was half me forgetting syntax + half me pretending functor worked on '* -> k' not * -> *
20:38:33 <Cale> The ability to derive a Functor instance there depends on the definition of the Prime data type
20:38:54 <Sonarpulse> oh sorry meant newtype PairPrime a b = PairPrime (Pair b a)
20:39:19 <Cale> Okay, similarly, but for Pair
20:39:24 <Sonarpulse> data Pair = Pair a b
20:40:46 <Cale> The reason GHC likely won't derive a Functor instance for you is that it expects to derive the instance without having to look into the definitions of the other types that get used -- if they have a Functor instance, then that's one thing, but if they don't, then I think it just throws up its hands at that point rather than trying to break things apart to more levels.
20:41:01 <Sonarpulse> yeah makes totally sense
20:42:01 <Sonarpulse> The original email on deriving hand a bunch of helper classes
20:42:27 <Cale> vanila: Also, what do you mean about Haskell getting worse? Has Haskell even changed all that much? There have been a few new extensions...
20:43:17 <Sonarpulse> e.g. class (Functor f a) => Functor2 f where { fmap :: (x -> y) f x t -> f y t }
20:43:53 <Sonarpulse> * class (Functor (f a)) => Functor2 f where { fmap :: (x -> y) -> f x t -> f y t }
20:43:53 <vanila>     Can't make a derived instance of `Functor (Left b)'
20:43:53 <vanila>       (even with cunning newtype deriving):
20:43:57 <vanila> it can't do it
20:44:08 <vanila> you would have to implement the functor instances by hand
20:44:09 <Cale> vanila: It was never able to do it?
20:44:15 <vanila> Cale, oh okay
20:44:23 <Cale> Being able to derive Functor at all is pretty new
20:44:23 <Axman6> Sonarpulse: you'd need Functor f => ...
20:44:56 <Axman6> wait
20:44:58 <Axman6> hmm
20:45:01 <Sonarpulse> Axman6: even though f is * -> * -> * ?
20:45:13 <Cale> anyway, for types like this, you're better off with:
20:45:38 <Cale> class Bifunctor f where bimap :: (a -> b) -> (c -> d) -> f a c -> f b d
20:45:52 * Axman6 was just typing @hoogle Bifunctor
20:46:05 <Sonarpulse> ah yes, that is totally superior to Functor2
20:46:44 <shachaf> You might want to be able to express "covariant in the first of two arguments", though.
20:47:02 <Sonarpulse> BiFunctor implies that no?
20:47:17 <shachaf> Yes, it's stronger than that.
20:47:28 <vanila>  Sonarpulse so you can do it like this: http://lpaste.net/120415
20:47:45 <vanila> there are two functors there, so you define a newtype for each one to let you 'select' that functor
20:48:04 <vanila> then you can use this pattern: unPLeft . fmap (*100) . PLeft  to use the functor you want
20:48:14 <Sonarpulse> vanila: no deriving though
20:48:21 <vanila> realy?
20:48:40 <Sonarpulse> with a big 10-case AST doing that is less fun
20:49:09 <vanila> could you show the data type?
20:49:17 <Sonarpulse> sure
20:49:34 <Sonarpulse> the project i am doing right now might be a bit less than that
20:49:54 <Sonarpulse> but the compiler I was doing a year ago was probably 10-15
20:50:26 <vanila> alright
20:50:40 <Sonarpulse> https://github.com/Ericson2314/clash2/blob/master/clash-verilog/src/CLaSH/Backend/Verilog/BoringTypes.hs
20:51:45 <Sonarpulse> In a dependant future, would "forall b. Functor \a -> Functor b a)" cause cannonicity problems?
20:51:55 <Sonarpulse> because while bifunctor is the right place to derive it
20:52:10 <Sonarpulse> still nice to get at functor instances for using stuff
20:52:34 <shachaf> Type classes and type lambdas don't work very will together.
20:52:37 <shachaf> well
20:52:51 <Sonarpulse> i feared
20:53:17 <Sonarpulse> i guess baring that bifunctor could have some wrapper new types
20:53:56 <Sonarpulse> https://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor-Flip.html
20:53:58 <Sonarpulse> and it does!
20:54:45 <Sonarpulse> https://github.com/ekmett/bifunctors/issues/17
20:56:08 <zq> @hoogle (a -> a) -> Int -> a -> a
20:56:10 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
20:56:10 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
20:56:10 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
21:05:48 <yukko> are there non-low-level Haskell bindings to SDL2?
21:05:58 <yukko> there is the sdl2 package but it is very low level and difficult to use
21:16:22 <blueonyx> :t length
21:16:23 <lambdabot> [a] -> Int
21:16:53 <blueonyx> :t length
21:16:54 <lambdabot> [a] -> Int
21:17:16 <pacak> blueonyx: It's still [a] -> Int
21:18:18 <blueonyx> how come length doesnt return Integer?
21:18:33 <pacak> :t genericLength
21:18:34 <lambdabot> Num i => [a] -> i
21:18:49 <Hijiri> if you are taking the length of a list bigger than the maxBound of an Int, you probably have other problems
21:18:55 <blueonyx> :i Num
21:21:37 <EvanR_> blueonyx: you can also do fromIntegral . length, which will be higher performance on lists of realistic length than genericLength
21:21:49 <EvanR_> or toInteger . length
21:21:52 <mniip> is there a prelude alternative to liftA for the function monad?
21:22:47 <pacak> EvanR_: I think his problem is to make something work at all rather than to make it work fast.
21:22:48 <mniip> wait
21:22:56 <mniip> that's .
21:23:04 <EvanR_> pacak: well both work ;)
21:23:13 <bms1> mniip: or fmap!
21:23:25 <mniip> I'll go for .
21:24:46 <mniip> well well well
21:25:56 <mniip> I think I just came up with a better alternative to pointfree in context of reordering function arguments
21:27:05 <EvanR_> mniip: use pointful? ;)
21:27:18 <mniip> yeah it
21:27:23 <mniip> yeah it's full of points
21:27:30 <EvanR_> my god
21:27:52 <mniip> hmm weird
21:28:06 <mniip> ccab shouldn't be more complex than ccba
21:28:12 <mniip> and totally shouldn't contain 2 joins
21:36:50 <fread2282> is there a description of type checking in the presence of metavariables that is easier to grok than the type checking in the presence of metavariables paper?
21:37:09 <t4nk741> Hi guys, I have a [Maybe a]
21:37:27 <t4nk741> can I do something like takeWhile (\x -> Just x) xs
21:37:45 <shachaf> With what example input and output?
21:37:50 <t4nk741> where I just take all the elements that are Just's
21:37:54 <Buttons840> Why do i get a default constraing warning on this: snap = (+ (1 :: Int)) . max (-1) . min 1 . fromIntegral . floor . (/100) . (+50)
21:38:06 <fread2282> > takeWhile isJust [Just 1,Just 2, Nothing, Just 3]
21:38:07 <lambdabot>  [Just 1,Just 2]
21:38:13 <pacak> :t catMaybes
21:38:14 <lambdabot> [Maybe a] -> [a]
21:38:21 <Buttons840> :t fromIntegral
21:38:22 <lambdabot> (Num b, Integral a) => a -> b
21:38:29 <t4nk741> [Just 1, Just 2, Nothing, Just 3] -> [1,2,3]  something like that
21:38:41 <t4nk741> ah isJust
21:38:46 <pacak> > catMaybes  [Just 1, Just 2, Nothing, Just 3]
21:38:48 <lambdabot>  [1,2,3]
21:38:48 * hackagebot either 4.3.3.1 - An either monad transformer  http://hackage.haskell.org/package/either-4.3.3.1 (EdwardKmett)
21:39:13 <EvanR_> > takeWhile isJust [Just 1, Just 2, Nothing, Just 4] --wrong
21:39:15 <lambdabot>  [Just 1,Just 2]
21:39:42 <EvanR_> ah fread2282 said that
21:39:52 <t4nk741> ooh i like that better thanks pacak
21:40:23 <Buttons840> I know fromIntegral returns a Num, and is polymorphic, but in my snap function I (+ (1 :: Int)) to the result of fromIntegral?
21:40:41 <Buttons840> :t (+1) . fromIntegral . 1
21:40:42 <lambdabot> (Num (a -> b), Num c, Integral b) => a -> c
21:41:08 <EvanR_> 1 is some function
21:41:11 <nkar> how is the [a] syntactic sugar implemented (at the type level)?
21:41:57 <Axman6> what do you mean?
21:42:13 <Axman6> how does [a] work in foo :: [a] -> [b]?
21:42:17 <nkar> no
21:42:27 <Buttons840> EvanR_: a digit is a function?
21:42:28 <fread2282> nkar: [1,2,3] = 1 : 2 : 3 : []
21:42:33 <nkar> ugh
21:42:36 <EvanR_> Buttons840: it can be.
21:42:39 <EvanR_> :t 1
21:42:40 <lambdabot> Num a => a
21:42:57 <fread2282> :t [] a
21:42:58 <lambdabot>     Couldn't match expected type ‘Expr -> t’ with actual type ‘[t0]’
21:42:58 <lambdabot>     The function ‘[]’ is applied to one argument,
21:42:58 <lambdabot>     but its type ‘[t0]’ has none
21:43:09 <EvanR_> Buttons840: if you dont want it to be a function dont use it with .
21:43:16 <nkar> fread2282: I know how [] works
21:43:21 <Buttons840> :t (+1) . (fromIntegral :: Float -> Int) . 1
21:43:23 <lambdabot>     Could not deduce (Integral Float)
21:43:23 <lambdabot>       arising from a use of ‘fromIntegral’
21:43:23 <lambdabot>     from the context (Num (a -> Float))
21:43:24 <Axman6> nkar: can you explain what you mean?
21:43:40 <vanila> nkar, data [] a = [] | a : [a]
21:43:45 <Buttons840> EvanR_: oh, right
21:43:56 <EvanR_> Buttons840: to convert a float to something like Int, use floor or ceil or something
21:45:07 <nkar> Axman6: I started explaining, but then I realized that I need to try something before asking further questions.
21:45:21 <Axman6> heh, fair enough =)
21:45:29 <Fusebox> does this channel have logs? i had to go do something and my client only stores 500 lines of history
21:45:41 <nkar> Fusebox: ircbrowse.net
21:45:45 <Fusebox> ty
21:46:08 <Axman6> just remember that [a] is syntactic sugar and as such is syntax, not something you can replicate in the language (afaik anyway)
21:46:15 <shachaf> The logs are in the topic.
21:46:23 <fread2282> > let {foo :: [] a -> [] a; foo = id} in foo []
21:46:24 <lambdabot>  []
21:46:32 <shachaf> (As far as I know the ones in the topic are up-to-date and ircbrowse.net isn't.)
21:48:01 <Fusebox> shachaf: if it isn't, it's only by a few minutes. it has what i needed. cheers all.
21:49:50 <Buttons840> EvanR_: yes, I was doing fromIntegral . floor which is overkill i guess
21:50:07 <rcl__> @work there's a web app that makes DB calls, makes web service calls (REST), calculates some things, and then renders a view of that to the user.  Very basic stuff. I want to rewrite in haskell and collect metrics on how it does to consider if we use it for anything else. What webapp stack should I use for this?
21:50:53 <rcl__> Success or failure with this could certainly influence the future of haskell viability at the company (and it's a big place where it'd be great to have it in use) so experience in real world is highly valued by anyone that can offer it
21:52:22 <Fusebox> rcl: Might I suggest asking on the Haskell subreddit in addition to here?
21:52:27 <Buttons840> rcl__: how big are the calculations it does?  the language isn't going to matter much compared to all the slow IO your doing like DB and REST
21:52:50 <Buttons840> unless your doing some big calculations
21:53:13 <fread2282> is there a better channel to ask questions about dependent types in?
21:53:26 <nkar> Axman6: okay, here's why I asked about sugar.  in yesod's config/models file, which uses persistent, I have a field of the type [Foo].  if I change it to 'Foo NonEmpty' (the same as haskell's 'NonEmpty Foo') it fails to compile because Foo is not yet defined when instances are being derived (at expansion time).  I wonder whether it happens due to the special treatment of [] or not.
21:53:29 <vanila> fread2282, #coq
21:53:35 <t4nk741> hey guys,
21:53:41 <t4nk741> lets say I got a list of lists
21:53:46 <t4nk741> and I need to take the head from each list
21:53:49 * hackagebot fastedit 0.1.0.0 - find nearest neighbours by edit-distance  http://hackage.haskell.org/package/fastedit-0.1.0.0 (MarkWotton)
21:53:58 <t4nk741> concatenate them together with a \n character
21:54:00 <rcl__> Buttons840: The calculations are small - the point is just to get haskell in to production and see how it does over time and to see how straightfowrard it is to do the DB and REST intreface
21:54:11 <t4nk741> and recursively do that for the reaminder of the lists.
21:54:38 <vanila> t4nk741, map unlines . transpose  maybe?
21:55:14 <Fusebox> t4nk741, so what's your function's type?
21:55:47 <t4nk741> [[a]] -> [a]
21:55:47 <nkar> Axman6: Foo is defined like this: data Foo = Foo Bar | OtherFoo where Bar is the name of the table.
21:55:48 <t4nk741> i guess
21:56:20 <Axman6> sorry, nkar, I was working on something else. will read now
21:56:57 <EvanR_> rcl__: try setting this up on your own before committing a whole project to it, as a trial
21:57:05 <nkar> Axman6: np
21:57:23 <Fusebox> t4nk741, but didn't you say you wanted to concatenate the newline char?
21:57:33 <t4nk741> oh it can be any character
21:57:40 <EvanR_> rcl__: ive used mysql-simple and postgres-simple for database stuff, very easy
21:57:46 <nkar> Axman6: I'll paste a simplified config/models file
21:57:49 <Fusebox> but the type isn't a, it's Char?
21:58:12 <Axman6> nkar: yeah, that seems like a question for #yesod, since the models file is a file that gets interpreted by by a template haskell splice; it has its own syntax
21:58:48 <nkar> Axman6: ok, I'll try there
22:00:01 <qz> is that just me or deb.haskell.org is down?
22:00:06 <t4nk741> I think transpose could do it, thanks vanila!
22:02:56 <rcl__> EvanR_: that's exactly what I'm doing, just found something @ work that I can reimplement and set up as an alternate site in the load balancer. It's a non critical app and the point is basically it's a real example and the site gets a decent amount of traffic etc. Thanks for the mysql-simple tip
22:03:34 <rcl__> Is yesod what people are mostly using? I don't want to start a holy war. I had read about haskapp but it seemed like it had less mileage on it. I'm just looking for the road most traveled at this point
22:23:53 <bmuk> why aren't trees in the prelude?
22:24:51 <EvanR_> many core operations arent in prelude, List, Maybe, etc
22:25:11 <EvanR_> including just Tree would be odd since its used way less
22:26:06 <shachaf> What sort of trees?
22:26:13 <shachaf> It has unary trees at least.
22:26:14 <bmuk> true. I've just been realizing how useful trees are, and I couldn't think of any language that included it as a "first class" data type.
22:26:38 <bmuk> (I mean that you don't have to import anything to get one)
22:27:10 <shachaf> It's very easy to make your own tree type.
22:27:16 <bmuk> shachaf: I mean binary trees
22:27:24 <bmuk> isn't a unary tree just a list?
22:27:30 <bmuk> lol
22:27:40 <EvanR_> data Tree a = Tree a [Tree a]
22:27:54 <shachaf> Yes.
22:27:59 <bmuk> It's easy to make the data type, but an efficient balanced binary tree implementation isn't very easy
22:28:16 <shachaf> Oh, sure, but that's much more than a tree now.
22:28:25 <shachaf> It's more like Data.Set or something.
22:28:32 <monochrom> Prelude content is decided by a committee in theory, democracy in practice. Every question of the form "why is ___ in Prelude" and "why is ___ not in Prelude" can be answered thusly.
22:29:09 <bmuk> monochrom: I understand that; I was just curious as to the general attitude towards trees
22:29:42 <EvanR_> they are cool
22:29:48 <vanila> Prelude is terrible, it shouldn't exist
22:29:58 <vanila> is it really that hard for people to just import the libraries they use
22:30:06 <johnw> vanila: do you know how many imports Prelude is saving you from?
22:30:14 <vanila> one per file ?
22:30:16 <johnw> I bet you your first import would be "import Prelude" if that were the case
22:30:29 <johnw> Data.Bool, Data.Int, Data.Enum, Data.Ord, etc., etc.
22:30:32 <johnw> it gets tedious fast
22:30:41 <EvanR_> editor macro!
22:31:09 <vanila> oh I think there was a miscommunication
22:31:18 <bmuk> what are Foldable and Traversable?
22:31:41 <vanila> I meant that the probems stem from it being implictly imported, since that means you don't have choice about it
22:31:48 <bmuk> > :k Foldable
22:31:49 <lambdabot>  <hint>:1:1: parse error on input ‘:’
22:31:58 <bmuk> :k Foldable
22:31:58 <lambdabot> (* -> *) -> Constraint
22:32:01 <vanila> you get forced on you whatever random set of functions the committe put in there this week
22:32:05 <EvanR_> bmuk: type classes
22:32:14 <johnw> vanila: ahh
22:32:27 <johnw> i'm pretty much with you there
22:32:34 <bmuk> EvanR_: I know they are type classes :p I'm asking how they are used, what is their abstraction, etc.
22:32:40 <johnw> even Coq imports things implicitly, which I wish it didn't
22:33:01 <EvanR_> bmuk: Foldable lets you "sum" a structure to get a single value
22:33:16 <bmuk> like concat?
22:33:17 <fread2282> bmuk: Foldable is foldMap, Traversable is traverse. both have more members for performance
22:33:20 <fread2282> :t foldMap
22:33:21 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
22:33:31 <EvanR_> bmuk: Traversable lets you execute an action at each part of the structure
22:33:48 <bmuk> :t concat
22:33:49 <lambdabot> [[a]] -> [a]
22:33:50 <vanila> the complexity of the coq library is a complete nightmare :|
22:34:03 <bmuk> :t concatMap
22:34:04 <lambdabot> (a -> [b]) -> [a] -> [b]
22:34:13 <fread2282> :t traverse
22:34:14 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:34:27 <vanila> it's great that it all exists but it's so hard to navigate
22:34:33 <bmuk> so foldMap is a more general concatMap
22:35:10 <EvanR_> more general mconcat
22:35:20 <bmuk> :t mconcat
22:35:21 <lambdabot> Monoid a => [a] -> a
22:35:31 <EvanR_> oh youre right
22:35:43 <bmuk> if both t and m are []
22:35:46 <EvanR_> in concatMap t = m = []
22:35:59 <EvanR_> [b]
22:36:06 <bmuk> :t foldMap
22:36:07 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
22:36:24 <EvanR_> t = [], m = [b]
22:36:27 <rcl__> Has anyone consumed REST with haskell? I'm seeing some various sparse info on it on the net, isn't covered in real world haskell, and a big question I have is do things start to break when the REST provider adds fields to the JSON?
22:36:48 <johnw> rcl__: depends on what information you want from the REST API
22:37:02 <johnw> if you consume all the fields, then probably it should break your program, since the semantics may have changed
22:37:08 <EvanR_> if you just add fields, your parser probably will ignore them
22:37:10 <rcl__> johnw: let's say the data I care about doesn't change but new things are added
22:37:13 <johnw> if you only care about one field, you can use lens-aeson and then it won't matter
22:37:23 <rcl__> ah OK cool that wasn't entirely clear from what I was reading
22:37:28 <johnw> rcl__: you can write your own FromJSON parser
22:37:36 <johnw> in which case you specify what to do if there are fields you don't care about
22:37:46 <johnw> I can see how it wouldn't be clear, yeah
22:37:47 <bmuk> is Maybe a monoid?
22:37:49 <johnw> but aeson is very capable
22:38:04 <fread2282> bmuk: yes
22:38:27 <fread2282> bmuk: Monoid a => Monoid (Maybe a)
22:38:45 <fread2282> so Just a <> Just b = Just (a <> b)
22:39:00 <bmuk> But you can't apply Maybe to foldMap directly can you?
22:39:07 <bmuk> :t foldMap
22:39:08 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
22:39:29 <bmuk> (a -> Maybe) -> Maybe a -> Maybe doesn't make sense
22:39:40 <EvanR_> kind mismatch
22:40:01 <johnw> bmuk: in other words, Maybe a isn't a monoid, but Monoid a => Maybe a is
22:40:06 <bmuk> so monoid here isn't * -> *
22:40:12 <EvanR_> m :: *, Maybe :: * -> *
22:40:15 <johnw> no, a Monoid is *
22:40:34 <johnw> i mean, the typeclass itself is * -> *, but any Monoid a :: *
22:40:46 <bmuk> :k Monoid
22:40:47 <lambdabot> * -> Constraint
22:40:50 <bmuk> :k Monad
22:40:51 <lambdabot> (* -> *) -> Constraint
22:40:53 <rcl__> johnw: your information led me to https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json which appears to be a fantastic resource. Thank you
22:40:54 <bmuk> ahh okay
22:40:58 <fread2282> Monoid q => (a -> Maybe q) -> t a -> Maybe q
22:41:07 <fread2282> would work
22:41:19 <bmuk> why q?
22:41:20 <johnw> rcl__: come back if you have questions; many of us have toiled in the REST mines
22:41:43 <fread2282> i dunno
22:41:46 <bmuk> I've always wondered where the one letter type constructors come from
22:41:54 <bmuk> like s t a b in lens
22:42:01 <EvanR_> m = Maybe m would be confusing
22:42:12 <bmuk> true
22:42:31 <fread2282> bmuk: s t a b is: s is the structure, t is the 'new' s
22:42:59 <bmuk> but foldMap :: (Monoid m, Foldable f) => (a -> m) -> f a -> m a isn't confusing
22:43:07 <rcl__> johnw: earlier I was asking; my goal here is to rewrite an app @ work from (something) to haskell, basic webapp with REST calls, SQL interface (i'm good on that), etc. I am trying to run it and watch traffic over time and get data on how things run in prod. I'm seeking direction on what webapp stack to use, prefer the most used in the wild one, suggestions?
22:43:57 <EvanR_> bmuk: thats wrong
22:43:59 <glguy> bmuk: I believe that the s t a b in lens are due to shachaf , (hopefully he's listening to correct me if I'm wrong )
22:44:10 <chrisdotcode> @src (<*>)
22:44:10 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:44:10 <johnw> rcl__: are you wanting to build a full "enterprisy" scale webapp, or do you want to build a lean and mean service?
22:44:12 <fread2282> and iirc having the two parts not next to each other in the alphabet makes ghc give nicer variable renamings in error messages
22:44:14 <shachaf> Yes.
22:44:25 <shachaf> There are many retroactive justifications for s t a b
22:44:27 <bmuk> EvanR_: extra a?\
22:44:34 <EvanR_> :t foldMap
22:44:35 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
22:44:47 <glguy> bmuk: but it's handy. They are used fairly consistently and once you're used to them it makes it easier to make sense of things
22:44:47 <EvanR_> so it should be less confusing now that its right ;)
22:44:48 <shachaf> s stands for "structure" or "state" or "source"; t stands for "target" or "the letter after s".
22:45:06 <bmuk> ah
22:45:25 <bmuk> but in foldMap why is it Foldable t and not Foldable f
22:45:27 <rcl__> johnw: something that's straightforward to set up, easy for someone to understand how it's working, can handle basic performance like a few thousand hits a day, most important is to be stable; will be monitoring performance over time just to help decide if it is a viable thing to use in general
22:45:27 <monochrom> "la, a note to follow so; t, a letter after s"
22:45:47 <edwardk> bmuk: because when you write down Traversable you wind up with two things folks would name 'f'
22:45:51 <shachaf> bmuk: t for Traversable
22:45:51 <johnw> rcl__: scotty is as raw as you want to go; perhaps check out snap as a larger scale alternative
22:46:05 <fread2282> bmuk: f usually stands for Functor, t for Traversable, closer to Foldable than Functor
22:46:21 <johnw> I hesitate to suggest yesod, because it will require a lot more familiarity with Template Haskell, monad transformers, and pretty wicked error messages, in order to make quick progress
22:46:31 <rcl__> johnw: are these the more commonly used ones? I have seen stuff about yesod and hackstapp
22:46:33 <bmuk> :k Traversable
22:46:33 <lambdabot> (* -> *) -> Constraint
22:46:51 <johnw> I'd be surprised if Happstack is used a lot in production, but I've never taken a survey
22:46:55 <bmuk> :t traverse
22:46:55 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:46:57 <johnw> I hear snap recommended the most often
22:47:09 <johnw> or scotty if you don't need any "frameworkiness"
22:47:19 <monochrom> (Foldable ft, Traversable ft) => ... is the best of both worlds :)
22:47:20 * glguy likes using snap-core and snap-server directly
22:47:34 <qz> i think its even harder with scotty. for example its very common to have some global state/environment in web apps, and doing that in scotty by reading its haddoc files is not trivial. while in yesod you already have it
22:47:36 <bmuk> edwardk: do you mean in the definition of traverse?
22:47:43 <rcl__> johnw: ah ok cool.  I'll check out snap then. Glad to hear.  Scotty sounds maybe the fastest to set up, but having this be more than a "toy example" would be a lot better. Very cool
22:47:52 <edwardk> bmuk: yes, and if you compare 'traverse' to 'foldMap' the 't's wind up in the same place
22:47:56 <edwardk> :t foldMap
22:47:58 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
22:48:00 <edwardk> :t traverse
22:48:01 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:48:18 <edwardk> and Foldable is a superclass of Traversable
22:48:34 <bmuk> I was about to ask if they were related somehow
22:48:51 * hackagebot classy-prelude-conduit 0.10.4 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.10.4 (MichaelSnoyman)
22:48:53 * hackagebot classy-prelude-yesod 0.10.4 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.10.4 (MichaelSnoyman)
22:48:54 <edwardk> :t traverse_
22:48:55 * hackagebot classy-prelude 0.10.4 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.10.4 (MichaelSnoyman)
22:48:55 <lambdabot>     Not in scope: ‘traverse_’
22:48:56 <lambdabot>     Perhaps you meant one of these:
22:48:56 <lambdabot>       ‘F.traverse_’ (imported from Data.Foldable),
22:48:57 * hackagebot authenticate-oauth 1.5.1 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.5.1 (MichaelSnoyman)
22:48:59 <edwardk> :t F.traverse_
22:49:00 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
22:49:04 <edwardk> :t traverse
22:49:05 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:49:21 <edwardk> traverse_ is traverse discarding the result, notice how it can be done with a mere Foldable constraint
22:49:59 <bmuk> I see why it has the underscore then, just like mapM_
22:50:53 <EvanR_> its the state of the art in for loops ;)
22:50:56 <johnw> bmuk: for example, consider why Data.Set.Set is Foldable but not Traversable, to see more of the connection
22:53:23 <bmuk> johnw: because they are unordered!
22:53:25 <bmuk> ah
22:54:08 <EvanR_> Set (paradoxically) *is* ordered
22:54:22 <EvanR_> is the issue
23:08:34 <scott> does EvanR_ discard results, too?
23:09:04 <EvanR_> rofl
23:09:26 <EvanR_> ()
23:33:54 * hackagebot transformers-compat 0.4.0.4 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.4.0.4 (EdwardKmett)
23:33:56 * hackagebot transformers-compat 0.4.0.2 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.4.0.2 (EdwardKmett)
23:35:24 <L8D> Is there some way to run GHCi expressions in a monad?
23:35:52 <L8D> Like how it auto-runs IO
23:36:40 <Cale> I'm not sure what that even means :D
23:37:02 <Cale> You want to be able to provide some way to turn values of another type into IO actions, and have it automatically use that?
23:37:10 <L8D> Cale: sort of
23:37:16 <Cale> In that case, no, that feature doesn't exist.
23:37:21 <jle`> anyone here from the southern california area intereted in joining an orange county haskell user group
23:37:27 <L8D> like I have a monad for everything in my app that runs in a context
23:37:36 <jle`> i am thinking of starting one
23:37:56 <L8D> well... yeah I guess it wouldn’t be in ghci
23:38:40 <Hijiri> is orange county about half an hour from san diego?
23:38:42 <Hijiri> or was it an hour
23:38:53 <L8D> jle`: You’d have better luck driving down to san fran
23:38:55 * hackagebot transformers-compat 0.4.0.3 - A small compatibility shim exposing the new types from transformers 0.3 and 0.4 to older Haskell platforms.  http://hackage.haskell.org/package/transformers-compat-0.4.0.3 (EdwardKmett)
23:39:02 <jle`> depending on where you are, it is between an hour to an hour and a half
23:39:07 <jle`> depending on which two points in OC/Sd that is
23:39:44 <L8D> er... driving up to*
23:39:51 <jle`> there is a decently active UG in SD i think
23:40:04 <L8D> well nvm that’s like a 6 hour drive
23:40:05 <jle`> but surely there aer some people in the OC area :|
23:40:23 <Hijiri> there's one with a meetup page that has a lot of people from my school
23:40:42 <Hijiri> I joined in on there but there haven't been any meetings, not really sure how much activity there is
23:40:47 <jle`> the one on meetup.com?  i think that was by computionist but he has since left oc
23:40:56 <jle`> maybe i could commandeer that
23:41:20 <Hijiri> I meant the SD UG, but maybe there's an OC one too
23:41:37 <jle`> yeah back when i was at UCSD i remember the SD UG was pretty active
23:41:43 <EvanR_> L8D: think of ghci being an interactive invisibl do block with an IO type
23:42:07 <EvanR_> L8D: then it might not obviously make sense to do what youre saying anymore
23:42:28 <L8D> EvanR_: I mean... I want it to be an interactive invisible do block with an X type
23:42:38 <jle`> what school do you go to, Hijiri ?
23:42:42 <Hijiri> UCSD
23:42:46 <EvanR_> L8D: and execute IO?
23:42:51 <jle`> oh nice.
23:42:58 <jle`> what college?
23:43:06 <jle`> why don't you drop by #ucsd once in a while :)
23:43:33 <Hijiri> Revelle, but luckily the GEs were dampened by credit
23:43:48 <L8D> EvanR_: Where X is a transformer over IO, yes
23:44:14 <L8D> EvanR_: I have a monad for my app’s context including db connections and configuration
23:44:55 <funfunctor> hi
23:44:57 <L8D> EvanR_: I want to be able to provide a run function, and then use ghci with that context
23:45:08 <L8D> EvanR_: like I would with normal IO
23:45:15 <L8D> EvanR_: instead of running each command
23:45:31 <adas> does knowing the difference between sum and product types help in anyway, while writing haskell code?
23:45:36 <EvanR_> i almost understood, but then you lost me, its getting late here
23:45:38 <L8D> adas: yes
23:45:58 <L8D> EvanR_: I know that what I’m talking about would be incredibly hard to implement so I’m guessing it’s impossible
23:46:08 <EvanR_> it might not be
23:46:19 <jle`> adas: do you know the difference between Either and (,) ?
23:46:21 <jle`> Either and tuples?
23:46:23 <jle`> if so, congrats
23:46:33 <jle`> i think Haskell might be tough if you confuse Either with tuples
23:46:55 <adas> L8D: could you please elaborate? I just read about sum types and product types and I understand them individually but i don't see how they might help in writing "better" haskell code?
23:46:56 <L8D> EvanR_: but let’s say I have newtype P a = P { unP :: StateT Int IO a } deriving (Monad, Functor, ...)
23:47:02 <adas> jle`: Either .. canonical sum type.
23:47:05 <funfunctor> I'm having a little bit of a issue translating my mental view point from writing monadically to applicatively: http://pastebin.com/DLCu8t0E
23:47:12 <adas> jle`: (,) cananonical product type
23:47:26 <jle`> yeah...i think even C programmers use tuples all the time
23:47:38 <jle`> a struct is a product type
23:47:45 <L8D> adas: the concept/difference between the two is also seen in different monads, and understanding which can do what and which is used to solve which kind of problem
23:47:45 <funfunctor> is lines 79-83 the correct thought process?
23:47:46 <jle`> most classes can be thought of as product types
23:48:05 <jle`> sum types are less commonly used, but that's not because they aren't as useful
23:48:05 <adas> jle`: you mean typeclasses?
23:48:11 <L8D> EvanR_: now I want to run commands in GHCi like: modify (+1)
23:48:14 <jle`> adas: i mean classes in object oriented programming
23:48:25 <adas> jle`: thats what i thought..yea
23:48:48 <adas> jle`: sum types, not only less commonly used, but seems like it doesn't exist in a lot of other languages.
23:48:52 <jle`> sum types are less commonly used in mainstream programing, but not because tehy aren't as useful...just because they are slightly awkward with their language facilities
23:48:59 <EvanR_> L8D: yeah (after initializing this transformer)
23:49:03 <jle`> but you can think of subtyping in OOP as an eaxmple of sum types in a way
23:49:13 <jle`> at least, the way people use them
23:49:20 <jle`> just minus the compiler being able to enforce totality
23:49:24 <L8D> EvanR_: so I want to provide something like 'runStateT x 0`
23:49:41 <L8D> EvanR_: and then be able to use expressions like 'modify (+1)' and then use 'get'
23:49:45 <funfunctor> i.e. am I using liftA correctly there?
23:49:49 <L8D> EvanR_: but that’s the simple example
23:49:55 <jle`> adas: Maybe is pretty commonly used to great effect in Haskell
23:49:58 <EvanR_> L8D: as for the actual use case, you can embed a command prompt server in your IO-based stack
23:50:00 <L8D> EvanR_: but the essence of what I’d like to do
23:50:12 <jle`> and a lot of modern programming languages now have option types like Maybe
23:50:16 <Cale> funfunctor: liftA is the same thing as fmap, which is the same thing as liftM
23:50:25 <jle`> so they have "a sum type", although it is a sum with ()
23:50:25 <L8D> EvanR_: would this "command prompt" allow me to evaluate Haskell expressions?
23:50:41 <L8D> EvanR_: I want to use this for debugging/development purposes
23:50:49 <funfunctor> Cale: I know but I mean the conceptual transition from monadic to applicative control
23:50:59 <Cale> funfunctor: But you're using liftA here with the function instance of Applicative? liftA f g x = f x (g x)
23:51:01 <funfunctor> I just need a little bit of a hand
23:51:02 <EvanR_> L8D: i dont know of something already made that does that, but it should be possible
23:51:14 <Hijiri> java has case expressions in the form of try-catch blocks
23:51:32 <Cale> funfunctor: Not every Applicative functor is a Monad in general, so you won't be able to translate everything.
23:51:46 <EvanR_> L8D: theres a lot of libs involving evaluating haskell expressions
23:51:49 <funfunctor> Cale: of course, Applicative is less structured
23:52:08 <L8D> EvanR_: I’d just want to use it in GHCi
23:52:16 <Cale> funfunctor: The easiest way if you understand liftM2, liftM3 etc, is just to figure out how to write it in terms of liftMn, and then change the M's to A's.
23:52:18 <funfunctor> I believe I can come up with a Applicative control interface here though
23:52:25 <adas> jle`: thanks for the clarification. perhaps by writing more haskell code, i can see the relevance of understanding sum and product types
23:52:26 <L8D> EvanR_: or I mean, I’d only need to.
23:52:27 <Cale> funfunctor: (and return to pure)
23:52:37 <EvanR_> L8D: yeah that seems like a bad way to go. if youre going to hack somethig into ghci might as well hack it into the real program for real debugging
23:52:38 <funfunctor> Cale: yep I saw that on the haskell wiki
23:53:00 <jle`> adas: yeah :)  you don't ahve to understrand them as sums and products
23:53:05 <jle`> adas: just know tuples are useful
23:53:07 <L8D> EvanR_: but if I hack something into the real program for real debugging it means I can’t use the debugging tools from GHCi
23:53:09 <jle`> and Either is useful too.
23:53:23 <funfunctor> Cale: so I made closeBTSLogger = sel s1 >>= liftIO . close  into closeBTSLogger = liftA close $ sel s1
23:53:24 <jle`> or just your own arbitrary data type
23:53:56 <L8D> EvanR_: and the said thing I’d hack into real programs would bring a hell of a lot of overhead
23:54:03 <EvanR_> L8D: ah well, theres a lot of requirements here ;)
23:54:11 <EvanR_> overhead? eh
23:54:16 <Cale> funfunctor: That can't be right, you were using liftIO before...
23:54:24 <Cale> funfunctor: liftA is not analogous to liftIO
23:54:36 <L8D> EvanR_: I’m looking for the exact same functionality as GHCi has with IO
23:54:36 <EvanR_> there shouldnt be overhead of a thread that usually doesnt exist
23:54:46 <Cale> funfunctor: We use the word "lift" for perhaps a few too many things...
23:54:58 <jle`> yes, we do even lift
23:55:06 <EvanR_> L8D: seeming more like a brute force way to solve something, maybe less transformer stacks would make more sense
23:55:24 <funfunctor> Cale: well I think my usage of liftIO is excessive here
23:55:32 <L8D> EvanR_: putting it into a real program actually seems kind of useless
23:55:33 <Cale> funfunctor: The purpose of liftIO is to convert an IO action into a value of some more structured other type.
23:55:36 <L8D> now that I think about it
23:55:42 <Cale> (something usually built from IO somehow)
23:55:49 <EvanR_> L8D: its useful to be able to interact with a running server
23:55:57 <funfunctor> Cale: yea IO action inside a larger monad
23:55:59 <funfunctor> I get that
23:56:00 <L8D> EvanR_: and how would that be useful?
23:56:16 <L8D> EvanR_: I can’t interact with the actual running monad of the server
23:56:39 <EvanR_> i guess im automatically assuming a server has many threads to it
23:56:48 <funfunctor> Cale: but can't you have applicative functors defined on monadic categories
23:56:50 <EvanR_> you are one of the threads
23:56:51 <L8D> EvanR_: yeah it would have many threas
23:57:02 <L8D> EvanR_: but how would I interact/change/view the other threads?
23:57:05 <Cale> funfunctor: I'm not sure what a monadic category is.
23:57:12 <EvanR_> however threads normally do it
23:57:13 <funfunctor> so in theory I could come up with a applicative control interface for this logging thing I am trying to write here
23:57:29 <funfunctor> Cale: category with one element
23:57:34 <L8D> EvanR_: they don’t
23:57:35 <Cale> funfunctor: uh...
23:57:40 <EvanR_> L8D: threads often interact
23:57:41 <L8D> EvanR_: at least not in my servers
23:57:52 <Cale> That would be a very confusing choice of terminology, if you were going that route :)
23:57:52 <funfunctor> Cale: I should use the term "object" rather
23:58:02 <EvanR_> i guess im assuming there are interacting threads ;)
23:58:05 <funfunctor> yea sorry
23:58:20 <Cale> A category with one object is sometimes called a monoid, because the set of arrows from that single object to itself form a monoid under composition.
23:58:23 <L8D> EvanR_: I’m just building web servers. So a new thread gets spawned for every connection but after it’s spawned it doesn’t talk to anything but the database
23:58:39 <L8D> EvanR_: and the socket
23:58:42 <EvanR_> L8D: and the log
23:58:43 <Cale> (but "monoidal category" means something quite different)
23:58:49 <L8D> EvanR_: yeah
23:59:17 <funfunctor> Cale: I mean the category of endofunctors where there is only one
23:59:23 <EvanR_> L8D: thats fine. so webservers that are supposed to response instantly may be a bad case for injecting an interactive debugger.
23:59:26 <L8D> EvanR_: I’m just looking to do some quick tests on various functions in a module
23:59:27 <Cale> funfunctor: But that's also beside the point -- the only category in use with these abstractions in Haskell is the category of types and functions.
23:59:35 <L8D> EvanR_: and see the outcome
23:59:36 <funfunctor> yes
23:59:51 <L8D> EvanR_: like DB queries and state-changes
23:59:52 <EvanR_> L8D: right, you can do that with a suitable test bench program which does your runFoo
