00:13:33 <mniip> is there a way to see whether a type falls within some constraint in ghci?
00:14:09 <ChristianS> mniip: try whether it compiles?
00:14:32 <mniip> whether /what/ compiles
00:15:46 <mniip> hmm
00:15:55 <mniip> I guess I can do something like
00:16:10 <mniip> (undefined :: (Foo a) -> a -> ()) (undefined :: Bar)
00:16:39 <mniip> er
00:16:43 <mniip> (Foo a) =>
00:17:30 <shachaf> Dict :: Dict (Foo A)
00:17:37 <shachaf> s/A/Bar/
00:18:40 <shachaf> Where data Dict k = k => Dict
00:20:43 <mniip> shachaf, the hell is that
00:37:20 <mniip> hmm, how does one parse -ddump-tc-trace :/
00:45:03 <augur> Cale: you interested in parsing at all? or know anyone who is?
00:45:47 <bitemyapp> augur: what are you looking for?
00:46:28 <augur> someone to mull over some things with
00:55:22 <mniip> can I somehow tell haskell to do constraint checking /before/ whining about overlapping instances?
00:58:48 <mjrosenb> ugh, why are hackage packages constantly caught in dependency hell :-(
01:01:01 <merijn> mjrosenb: Because you're trying to use bleeding edge package of authors who aren't careful enough to specify proper bounds
01:01:15 <merijn> mjrosenb: In other words, because you're trying to use stuff that doesn't have enough testers
01:01:27 <mniip> ahh I see
01:01:56 <mjrosenb> merijn: in this case, reactive, and yeah, that sounds about right.
01:04:15 <merijn> Conal's library?
01:04:32 <mjrosenb> yup.
01:04:42 <merijn> More widely used FRP libraries these days are probably netwire, reactive-banana and sodium
01:05:20 <merijn> I don't think reactive is being super actively maintained, so I can see that leading to dependency conflicts
01:05:28 <mjrosenb> yeah, I just got reactive-banana-sdl to build (that was fun!), but I'd like to compare them
01:05:44 <mjrosenb> since it seems to be the only push-pull frp implementation out there.
01:06:57 <merijn> Yeah, making push-pull efficient is still somewhat of an open question :)
01:07:21 <merijn> Or generally just avoiding time leaks in FRP
01:16:54 <funfunctor> hi folks
02:06:25 <awesomo4000> does anyone have an example of a complete application using the filesystem search library from RWH Ch. 9 ?
02:08:45 <steffen> Hi, what is the 'TypeConstructor {..}' syntax and where can I read about it?
02:08:59 <bergmark> steffen: RecordWildCards
02:09:11 <steffen> bergmark: thanks
02:09:22 <bergmark> steffen: the ghc manual is probably your most comprehensive resource
02:14:32 <gfixler> this is fun http://hyperpolyglot.org/ml
02:15:33 <merijn> gfixler: I was expecting something like: https://github.com/mauke/poly.poly/blob/master/poly.poly :p
02:16:45 <gfixler> my god it's full of escapes
02:17:50 <merijn> gfixler: afaik it's valid perl, C, C++, haskell, html, JS+html and a couple of others
02:17:54 <merijn> Make too, I think
02:18:01 <merijn> Ask mauke for details :p
02:18:07 <gfixler> Vim is having a hard time syntax highlighting it
02:18:20 <gfixler> it also appears to be valid BF
02:20:00 <mjrosenb> gfixler: valid BF isn't hard.
02:20:10 <merijn> I forgot bash, zsh and ruby
02:20:25 <merijn> mjrosenb: It is if the exact same file has to parse as all of the aforementioned languages :p
02:20:30 <gfixler> ln -s poly.poly poly.lhs; runhaskel poly.lhs => I'm a Literate Haskell program.
02:21:01 <mjrosenb> it appears to mostly be cleverly hiding things in comments for most languages c.c
02:21:11 <gfixler> l
02:21:19 <merijn> mjrosenb: So? That's the point of valid polyglot files :p
02:22:02 <haasn> shachaf: When I see ‚Äúk‚Äù my first thought is ‚Äúkind variable‚Äù. :-(
02:22:29 <shachaf> it's a klass konstraint
02:22:41 <shachaf> But that's fair, maybe I should use another letter.
02:23:40 <haasn> At least ‚ÄúMap k v‚Äù no longer looks like ‚ÄúMap v with a polymorphic kind‚Äù
02:25:36 <mjrosenb> merijn: I think this is my favorite, but as far as I can tell, it doesn't hide much in comments: http://perl.plover.com/obfuscated/bestever.pl
02:26:50 <mauke> https://raw.githubusercontent.com/mauke/poly.poly/master/yes.c
02:26:51 <lieven> is that perl or postscript?
02:28:12 <mjrosenb> lieven: yes.
02:28:44 <haasn> shachaf: So What's wrong with ‚Äòc‚Äô?
02:28:54 <shachaf> I don't remember.
02:29:05 <shachaf> It comes after a and b?
02:29:24 <haasn> http://hackage.haskell.org/package/constraints-0.4.1.3/docs/src/Data-Constraint.html#Dict
02:29:32 <haasn> Then clearly the solution is to just use ‚Äòa‚Äô
02:29:49 <haasn> It doesn't come after *anything*
02:30:30 <augur> some people have a real bias against some letters
02:30:51 <augur> theres a huge problem with lettrism in the world
02:31:22 <mjrosenb> ooh, can we use √•?
02:31:27 <haasn> mjrosenb: Yes.
02:31:38 <haasn> Well, it depends on your locale. I think.
02:31:51 <mjrosenb> > "√•"
02:31:53 <lambdabot>  "\229"
02:32:19 <edwardk> augur: its almost like we assign them meaning or something. pshh.
02:32:38 <haasn> Somebody should figure out whether or not GHC's decision of what constitutes a legal variable name depends on your locale settings or not.
02:32:49 <edwardk> haasn: it shouldn't
02:33:13 <augur> edwardk: *cough* https://en.wikipedia.org/wiki/Lettrism :x
02:33:17 <edwardk> haasn: it is pretty much a basic upper-case vs. lower-case check and some fancy logic that i think we added to make japanese count as lowercase
02:33:40 <haasn> edwardk: I meant for distinguishing letters from non-letters
02:33:49 <edwardk> augur: fair =)
02:34:03 <augur> edwardk: i enjoy a good pun :)
02:34:04 <edwardk> haasn: the logic is pretty simple. i've seen the statements
02:34:11 <shachaf> haasn: It doesn't.
02:34:32 <shachaf> haasn: It depends on the generalCategory, which is specified in Unicode.
02:34:34 <edwardk> it diverges from the report to enable things like that japanese situation
02:34:35 <mjrosenb> edwardk: ok, now I need to ask, why the exception for japanese?
02:35:01 <edwardk> mjrosenb: its more an exception for things that don't fall into LowercaseLetter or UppercaseLetter to be used as LowercaseLetter if they are in Letter and not explictily UppercaseLetter
02:35:18 <edwardk> japanese was just where the first counter-example folks wanted came up
02:36:09 <edwardk> with this you can write beautiful code like http://lpaste.net/raw/75725
02:36:54 <edwardk> https://ghc.haskell.org/trac/ghc/ticket/1103 is the concrete ticket as i recall
02:37:06 <edwardk> it came up as an issue a while back as it is technically a divergence from the report
02:37:47 <edwardk> speaking of which i should flag it as such
02:37:52 <edwardk> thanks this was useful =)
02:38:16 <haasn> That's an unusual do block.
02:39:37 <edwardk> > 3 * do 4 + 5
02:39:38 <lambdabot>  27
02:39:52 <edwardk> do is a very useful pair of magic parenthesis
02:40:25 <haasn> Except here it's using (>>) from the Monad [] instance, which isn't the most useful thing in the world
02:40:40 <mniip> it isn
02:40:45 <mniip> 't
02:40:54 <edwardk> oh yeah
02:40:55 <mniip> @undo 4 + 5
02:40:55 <lambdabot> 4 + 5
02:41:09 <edwardk> that script is pretty much just a way to print a pile of messy letters
02:41:14 <merijn> haasn: The report's definition of legal characters is based on unicode character classes
02:41:55 <haasn> Fair enough
02:42:04 <haasn> Incidentally, why don't we have text-icu-lens?
02:42:07 <merijn> Although there's still some bugs/wiggle rooms
02:42:15 <edwardk> i think it just says 'ow!' a few hundred times
02:42:20 <haasn> I want a family of folds and (improper) traversals based around text-icu iterators
02:42:24 <edwardk> haasn: because you haven't written it
02:42:41 <merijn> For example there was this Kanada letter which was neither upper/lower case and thus (technically) not a legal identifier character according to the report even though GHC accepts it
02:42:41 <mniip> oh that code
02:42:57 <merijn> haasn: Never tells edwardk something's missing from his libraries
02:43:04 <edwardk> merijn: ghc's behavior doesn't follow the report, it takes Letter - UppercaseLetter and treats it as LowercaseLetter report-style
02:43:09 <merijn> haasn: before you know it you wake up with commit rights on github :)
02:43:28 <edwardk> haasn has commit rights to many of my projects already =)
02:43:30 <tdammers> do people actually use Kannada for identifiers?
02:43:36 <merijn> tdammers: Probably not
02:43:39 <edwardk> oh kannada
02:43:51 <merijn> Well, there's acme-lookofdisapproval
02:44:08 <merijn> http://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
02:44:31 <haasn> At least ‚òÉ is a valid identifier characters.
02:45:48 <edwardk> Yes, but so is üí©.
02:46:12 <tdammers> except that . is already claimed by Prelude
02:46:33 <edwardk> (there was an emoji there that may not have shown up for you)
02:46:42 <tdammers> it did
02:47:04 <merijn> edwardk: It does for me, because Monaco is the one true terminal font ;)
02:47:11 <edwardk> üôàüôâüôä
02:47:15 * tdammers uses gnu unifont
02:47:36 <merijn> edwardk: That works too, but overlaps oddly due to emoji not being monospace in my monospace font >.>
02:49:12 <haasn> I don't see those, but I also disabled unifont due to aforementioned monospace compatibility issues.
02:49:34 <merijn> You could also use Adobe Source Mono for a decent looking font with good unicode coverage :p
02:49:59 <merijn> It's even free-as-in-speech and free-as-in-beer for the GNU hippies :p
02:50:33 <haasn> But who will adapt my X font line for me?
02:51:08 <merijn> Simple solution, install something sensible like OSX and be done with it ;)
02:52:14 <augur> i think i just designed a combinator-based Unger parser...
02:53:35 * gfixler is afraid to run bestever.pl
02:53:42 <augur> gfixler: dont do it!
02:53:44 <augur> run away!
02:54:22 <gfixler> dup dup pop pop!
02:55:45 <calavoow> @pl \x,y,z -> (sin x) + (cos y) - (tan z)
02:55:45 <lambdabot> (line 1, column 6):
02:55:45 <lambdabot> unexpected "z"
02:55:45 <lambdabot> ambiguous use of a non associative operator
02:55:54 <calavoow> @pl \x,y,z -> (sin x) + (cos y) (- (tan z))
02:55:54 <lambdabot> (line 1, column 6):
02:55:54 <lambdabot> unexpected "z"
02:55:54 <lambdabot> ambiguous use of a non associative operator
02:56:03 <gfixler> so, did we decide that digits below 5 are lowercase?
02:56:12 <calavoow> @pl \x,y,a -> (sin x) + (cos y) (- (tan a))
02:56:12 <lambdabot> (line 1, column 6):
02:56:12 <lambdabot> unexpected "a"
02:56:12 <lambdabot> ambiguous use of a non associative operator
02:58:06 <jtanguy> @pl \x y a -> (sin x) + (cos y) - (tan z)
02:58:06 <lambdabot> (const .) . flip flip (tan z) . ((-) .) . (. cos) . (+) . sin
02:58:48 <hyPiRion> yes, how readable.
02:59:39 <calavoow> ah yes
02:59:49 <calavoow> no need for comma delimiter
03:00:35 <hyPiRion> there are times I seriously consider doing (f .) . g as it's getting a bit familiar, but eh
03:00:47 <bernalex> hyPiRion: f .: g
03:01:07 <gfixler> is flip flip a noop?
03:01:22 <mniip> jtanguy, foldr1 (+) . flip map [sin, cos, negate . tan] . flip id
03:01:23 <hyPiRion> :t flip flip
03:01:24 <lambdabot> b -> (a -> b -> c) -> a -> c
03:01:30 <gfixler> oh, sheesh
03:01:49 <hyPiRion> bernalex: I'm heading out for lunch, but where are those operators defined?
03:01:52 <mniip> or
03:02:00 <bernalex> @hoogle (.:)
03:02:03 <lambdabot> No results found
03:02:11 <mniip> foldr1 (+) . (`map` [sin, cos, negate . tan]) . flip ($)
03:02:14 <mniip> more or less makes sense
03:02:19 <gfixler> :t flip flip flip
03:02:20 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
03:02:35 <mniip> gfixler, flip.flip is a noop
03:02:36 <bernalex> hyPiRion: various places, I guess. we use it in our internal prelude. it's also in the composition package afair.
03:02:41 <mniip> flip flip is something much worse
03:03:03 <gfixler> mniip: now I get it
03:03:15 <hyPiRion> bernalex: alright, thanks. I "need" it every once and then these days
03:03:39 <bernalex> hyPiRion: there are legitimately nice ways to use them.
03:03:55 <bernalex> hyPiRion: as an example, from our code
03:03:57 <bernalex> hmsToDiffTime = (secondsToDiffTime . timeVal) .:. asSeconds
03:04:09 <bernalex> hmsToDiffTime :: Hour h -> Minute m -> Second s -> DiffTime
03:04:23 <bernalex> typesig makes it obvious.
03:05:34 <gfixler> so flip flip flips flip, whereas flip . flip unflips what's flipped
03:07:06 <calavoow> bernalex what is (.:) and how would i find info on it? its kind of hard to look up
03:07:34 <bernalex> calavoow: here's how we implement it at work: https://github.com/plaimi/plailude/blob/master/src/Plailude/Function/Compose.hs
03:09:21 <haasn> shachaf: If you're using weechat: /filter add pl_spam irc.freenode.#haskell irc_privmsg ^@pl
03:09:26 <haasn> hth
03:13:13 <exio4> beautiful
03:14:30 <exio4> wrong chan sorry :P
03:19:41 <phaazon> is there any feedback about resourcet performance?
03:24:44 <awestroke> :t flip
03:24:45 <lambdabot> (a -> b -> c) -> b -> a -> c
03:25:07 <ab9rf> feem
03:25:14 <mniip> in other news
03:25:29 <mniip> with MultiParamTypeClasses, FunctionalDependencies, FlexibleInstances, UndecidableInstances; the haskell type system turns into prolog
03:25:54 <haasn> now turn it into agda
03:25:56 <tdammers> throw in six more extensions and you have python
03:26:08 <ab9rf> heh
03:29:29 <mniip> I just type-list sorting to work
03:29:32 <mniip> and nubbing
03:29:50 <haasn> mniip: What about that doesn't work?
03:30:02 <mniip> doesn't work? on the contrary, it works now
03:30:17 <haasn> Ah, yes; that's what I was suggesting :)
03:30:33 <mniip> cons (succ zero) $ cons zero empty :: Cons (Succ Zero) (Cons Zero Empty)
03:30:37 <mniip> sorted $ cons (succ zero) $ cons zero empty :: Cons Zero (Cons (Succ Zero) Empty)
03:30:45 <haasn> Why not use [] ?
03:31:02 <mniip> because [] is a value and not a type?
03:31:07 <haasn> '[]
03:31:40 <haasn> Haskell+DataKinds has built-in type-level lists
03:31:50 <haasn> '[0, 1]
03:31:56 <haasn> It has built-in type-level nats as well
03:32:20 <mniip> :|
03:32:30 <haasn> (It even has a built-in arithmetic solver)
03:32:46 <mniip> well I have implemented Add, Subtract, Multiply
03:32:48 <haasn> But I'm not sure if that one works in practice yet
03:34:18 <haasn> let x = Proxy :: 12 ~ (4*x) => Proxy x in x :: Proxy 3
03:34:20 <haasn> ^- seems to work
03:34:41 <haasn> (That was the output of :t, in case it wasn't clear)
03:35:35 * haasn still wants type-level integers and rationals
03:36:01 <mcjohnalds> When is the reader monad useful? I'm not sure of an example when something like `f :: Reader r a` is better than `f :: r -> a`
03:36:24 <haasn> mcjohnalds: (Reader r a) and (r -> a) are virtually identical
03:36:34 <haasn> The latter even has the same Monad instance
03:36:54 <mcjohnalds> So what's Reader for?
03:37:05 <thebnq> it helps if a bunch of intermediate functions don't need the content
03:37:12 <haasn> mcjohnalds: There are two common scenarios: 1. you have a deeply nested computation and don't want to pass around the parameter manually all the time, 2. you want to combine it with other monad transformers
03:37:42 <mniip> ooh
03:37:55 <mniip> an IfThenElse typeclass lets you get rid of overlapping instances
03:38:13 <mcjohnalds> haasn: Ok thanks I'll play around with it abit
03:40:12 <mniip> I'll just leave this here
03:40:14 <mniip> https://gist.github.com/mniip/bb1352bc87e42b667257
03:40:47 <haasn> mniip: Do you know about type families?
03:42:04 <mniip> not erally no
03:42:50 <mcjohnalds> mniip: What am I looking at? Extremely generalised versions of prelude functions?
03:42:52 <haasn> That entire file would be much, much cleaner and easier to read and reason about using type families instead of awkward MPTCs+FunDeps
03:42:59 <mniip> mcjohnalds, functions?
03:43:06 <mniip> no those are types and typeclasses
03:43:18 <haasn> mcjohnalds: You're looking at computation in the type system
03:43:20 <mniip> the functions provided are just for easier type creation
03:43:33 <mniip> zero is just as good as (undefined :: Zero)
03:43:59 <mcjohnalds> Like using a type system as a whole language, interesting, why?
03:44:18 <haasn> ‚Äúbecause we can‚Äù, mostly
03:44:31 <haasn> There are legitimate uses for type-level computation, though. Like checking certain types of static properties
03:44:31 <mcjohnalds> Heh, good enough
03:44:32 <mniip> for the glory of satan, of course
03:44:46 <haasn> In my own favorite use case, for checking units
03:45:04 <haasn> (or automatically converting units, for that matter)
03:45:43 <mniip> can't stop admiring my Insert typeclass instances
03:46:19 <haasn> mniip: For example, your class Add can be written as: ‚Äútype family Add a b where Add Zero b = b; Add (Succ a) b = Succ (Add a b)‚Äù
03:46:42 <mniip> that's not so fun
03:47:02 <haasn> That one is also a closed type family, which means you can't add (conflicting) instances in another file.
03:47:08 <haasn> And you can also do overlapping things. For example:
03:47:27 <haasn> type family IsEq a b where IsEq a a = 'True; IsEq a b = 'False
03:47:30 <mniip> having overlappings is extra not fun :P
03:47:40 <haasn> Try doing that with MPTCs+FunDeps+OverlappingInstances :)
03:47:42 <mniip> you miss the fun of fixing overlapping instances
03:49:08 <haasn> You're missing out on all the TypeOperators+PolyKinds fun, too
03:49:16 <haasn> type family (*) (a :: k) (b :: k) :: k
03:49:29 <haasn> type family (+) (a :: k) (b :: k) :: k -- etc
03:49:33 <init> :: k in both sides?
03:49:49 <merijn> Takes two kinds and returns a new kind
03:49:53 <haasn> https://github.com/haasn/units/blob/master/src/Units/Internal/Types.hs#L21
03:49:55 <haasn> Here's a practical example
03:50:22 <init> oh, thought the type(kind?) system would try to 'unify' the kinds
03:50:39 <haasn> init: If you left the :: k annotation on ‚Äòb‚Äô it would end up as (+) :: k -> k1 -> k
03:50:43 <haasn> Or whatever
03:50:47 <haasn> With two kind parameters
03:51:18 <haasn> It's like the difference between f (a :: k) (b :: k) = (undefined :: k) and f (a :: k) b = (undefined :: k)
03:52:29 <haasn> mniip: DataKinds has built-in type-level strings, too, by the way
03:52:55 <mniip> nah that's no fun
04:01:16 <haasn> merijn: That description is also way off
04:01:32 <haasn> It takes two types and returns a new type. All of the types just have to have the same kind
04:02:03 <haasn> (And, indeed, the behavior is parametrized by the kind)
04:09:52 <merijn> haasn: oh, yes, brain fart
04:21:47 * hackagebot type-eq 0.5 - Type equality evidence you can carry around  http://hackage.haskell.org/package/type-eq-0.5 (GaborLehel)
04:39:59 <awesomo4000> what is the best way to print a IO [FilePath]  to stdout
04:40:51 <tdammers> awesomo4000: what do you mean - print the file paths, or file contents?
04:40:54 <bennofs> awesomo4000: how do you want to print it? separate lines?
04:41:11 <awesomo4000> just the filenames in the list
04:41:14 <tdammers> ah
04:41:37 <tdammers> mapM_ putStrLn filepaths --
04:41:38 <mauke> that's not a list, though
04:41:49 <tdammers> oh wait, IO [FilePath]
04:42:01 <tdammers> in that case: >>= mapM_ putStrLn
04:42:40 <EvanR> or mapM_ putStrLn =<< foo
04:46:48 * hackagebot Rasterific 0.5.0.2 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.5.0.2 (VincentBerthoux)
04:47:09 <awesomo4000> what is >>=  called
04:47:15 <init> bind
04:47:39 <EvanR> join fmap
04:48:16 <init> it's what do-notation desugars to, the equivalent using do-notation would be do { x <- foo; mapM_ putStrLn x }
04:48:20 <tdammers> :t (>>=) -- awesomo4000
04:48:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:48:35 <tdammers> :t mapM_
04:48:36 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
04:48:40 <EvanR> what its called is unimportant, what is its type! ah!
04:49:04 <awesomo4000> googling for those symbols is difficult
04:49:06 <tdammers> now use "IO" for "m"
04:49:18 <mniip> awesomo4000, https://www.haskell.org/hoogle/
04:49:18 <tdammers> awesomo4000: that's why we have hoogle and hayoo
04:49:32 <awesomo4000> which one of those is better
04:49:33 <tdammers> duckduckgo has bang patterns for both, fwiw
04:49:48 <tdammers> hoogle is better at parsing Haskell syntax, but hayoo covers more librarie
04:49:51 <tdammers> s
04:51:01 <awesomo4000> i'm using System.FilePath.Find . is this idiomatic Haskell :
04:51:15 <awesomo4000> find always always directory >>= mapM_ putStrLn
04:51:27 <mniip> I should switch to ddg
04:52:05 <tdammers> looks decent enough to me
04:52:12 <calavoow> @pl \x y z -> sin x + cos y + sin z
04:52:13 <lambdabot> flip flip sin . (((.) . (+)) .) . (. cos) . (+) . sin
04:52:57 <tdammers> ah, haskell, where "point-free" means "use lots of '.'s"
04:52:58 <mniip> stuff like that doesn't pointfree well
04:53:17 <mniip> tdammers, everything can be rewritten in only const and <*>
04:53:31 <tdammers> mniip: do it
04:53:33 <awesomo4000> how long before simple things are simple again
04:53:45 <mniip> tdammers, I'm too lazy
04:53:54 <calavoow> im just looking for some complicated examples of pointfree style for my compiler :p
04:53:59 <tdammers> mniip: you've come to the right place :D
04:54:32 <mniip> oh and indeed you can rewrite everything in terms of just u where u f = f (<*>) const
04:55:12 <tdammers> awesomo4000: https://github.com/Dobiasd/articles/blob/master/programming_language_learning_curves.md
04:55:24 <mniip> because <*> = u $ u $ u u; const = u $ u $ u $ u u
04:55:50 <calavoow> as if each language has only one feature
04:55:57 <mauke> @pl \x y z -> sin x * y + cos y * z + sin z + x
04:55:57 <lambdabot> flip =<< ((flip . ((+) .)) .) . flip flip sin . (liftM2 (+) .) . (`ap` ((*) . cos)) . (((.) . (+)) .) . (*) . sin
04:56:36 <mniip> mauke, please tell me you aren't plugging that expression into something
04:56:36 <SwashBuckla> oh god
04:57:03 <calavoow> `ap`?
04:57:09 <jmcarthur> :t ap
04:57:10 <lambdabot> Monad m => m (a -> b) -> m a -> m b
04:57:12 <mauke> @. unpl pl \x y z -> sin x * y + cos y * z + sin z + x
04:57:12 <init> <*> implemented using Monad
04:57:12 <lambdabot> (\ k c -> (\ ab bg e f -> (((return ((\ bp w x -> ((sin ab) * bp) + (w x)) bg ((\ ar -> (*) (cos ar)) bg)) bg) >>= \ p -> sin >>= \ o -> return (p + o)) f) + e) k c k)
04:57:19 <EvanR> it looks slightly better than normal lisp code
04:57:52 <calavoow> my brain hurst
04:57:59 <mauke> my work here is done
04:58:06 <mniip> SwashBuckla, if you think that's horrible, try PM'ing lambdabot with @pl z a b c d e f g h i j k l = l k j i h g f e d c b a
04:58:20 <tdammers> https://github.com/Dobiasd/articles/blob/master/programming_language_learning_curves/haskell.png
04:58:27 <tdammers> "my brain hurts"
04:59:28 <jmcarthur> you can verbosely encode messages with  @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> y o u r m e s s a g e h e r e
05:00:05 <mniip> how do you decode them
05:00:10 <bennofs> mniip: @unpl
05:00:19 <mniip> I don't think...
05:00:22 <jmcarthur>  @unpl will get you some of the way there at least
05:00:23 <awesomo4000> i'm still at the brain hurt phase.
05:00:28 <mauke> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> d e b r u i j n
05:00:34 <lambdabot> const (const . (((const . const . const . (((const . const) .) .) . ((const .) .)) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . ((
05:00:36 <lambdabot> (((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((flip .) .) . (((flip .) .) .) . flip flip)
05:00:38 <lambdabot> optimization suspended, use @pl-resume to continue.
05:00:40 <jmcarthur> i don't think @unpl is enough
05:00:43 <mniip> @unpl ((((const .) .) .) .) . (flip =<< ((flip . ((flip . (flip .)) .)) .) . flip . (flip .))
05:00:43 <lambdabot> (\ ad at aw az bc _ -> (\ ag bi j k n q -> ag k n bi q j) ad at ad aw az bc)
05:00:52 <mniip> that was only 6 letters
05:00:59 <bennofs> right, won't get you back the variable names
05:01:25 <mniip> bennofs, good luck recovering what I said above
05:01:37 <jmcarthur> mniip: we need to know your alphabet first
05:01:43 <mniip> \a b c d e f ->
05:01:44 <tdammers> maybe if you try to feed it character literals, the message appears in the compiler error in a somewhat readable form
05:01:52 <clrnd> lol
05:02:09 <jmcarthur> > (((((const .) .) .) .) . (flip =<< ((flip . ((flip . (flip .)) .)) .) . flip . (flip .))) a b c d e f
05:02:13 <lambdabot>  Couldn't match type ‚ÄòDebug.SimpleReflect.Expr.Expr
05:02:15 <lambdabot>                       -> Debug.SimpleReflect.Expr.Expr
05:02:17 <lambdabot>                       -> Debug.SimpleReflect.Expr.Expr
05:02:26 <bennofs> just pass it ('a':) ('b':) ('c':) ... and run it
05:02:32 <jmcarthur> heh
05:02:42 <jmcarthur> :t (((((const .) .) .) .) . (flip =<< ((flip . ((flip . (flip .)) .)) .) . flip . (flip .)))
05:02:43 <lambdabot>     Occurs check: cannot construct the infinite type:
05:02:44 <lambdabot>       b1 ~ a1 -> a2 -> a -> a3 -> b1 -> c
05:02:44 <lambdabot>     Expected type: (a1 -> a2 -> a -> a3 -> b1 -> c)
05:02:47 <jmcarthur> ah
05:02:51 <EvanR> its too early in the morning for all this
05:02:52 <mniip> you can't run it
05:03:02 <bennofs> @pl \h e l l o -> h e l l o
05:03:02 <lambdabot> ((const . const) .) . flip flip id . (ap .) . flip flip id . (ap .)
05:03:03 <jmcarthur> mniip: one should be able to
05:03:09 <jmcarthur> > a b
05:03:10 <bennofs> > ((const . const) .) . flip flip id . (ap .) . flip flip id . (ap .)
05:03:11 <lambdabot>  Couldn't match expected type ‚ÄòDebug.SimpleReflect.Expr.Expr -> t‚Äô
05:03:11 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
05:03:12 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a1)
05:03:12 <lambdabot>    arising from a use of ‚ÄòM31304665550581189411436.show_M31304665550581189411...
05:03:12 <lambdabot>  The type variable ‚Äòa1‚Äô is ambiguous
05:03:25 <init> bennofs: "l l"?
05:03:28 <bennofs> > (((const . const) .) . flip flip id . (ap .) . flip flip id . (ap .)) ('h':) ('e':) ('l')
05:03:29 <lambdabot>  Couldn't match type ‚Äò[a1]‚Äô with ‚Äòa0 -> a0‚Äô
05:03:29 <lambdabot>  Expected type: [a1 -> b1] -> (a0 -> a0) -> [b1]
05:03:29 <lambdabot>    Actual type: [a1 -> b1] -> [a1] -> [b1]Couldn't match type ‚Äò[a3]‚Äô with ‚Äòa2...
05:03:32 <jmcarthur> aw man, am i forgetting something important about simplereflect?
05:03:34 <bennofs> init: ha
05:03:45 <bennofs> @pl \h e l o -> h e l l o
05:03:45 <lambdabot> flip flip id . (ap .)
05:03:49 <mauke> jmcarthur: no, about @pl
05:03:50 <merijn> jmcarthur: Yes, you forgot to annotate the type
05:04:02 <merijn> > f a :: Expr
05:04:03 <lambdabot>  f a
05:04:21 <merijn> But can we stop with the noise @pl spam?
05:06:13 <mniip> I wonder how will pointfree optimize the u combinator
05:06:42 <mauke> @pl (\x -> x x) (\x -> x x)
05:06:45 <lambdabot> ap id id (ap id id)
05:06:45 <lambdabot> optimization suspended, use @pl-resume to continue.
05:06:47 <bernalex> not having written haskell for a month has made me useless apparently
05:07:56 <bernalex> how do I data Foo = MkFoo 'either a, where a is an instance of Num -- or Bar'?
05:07:58 <mniip> flip ($ const (join ap)) const
05:07:59 <mniip> fancy
05:08:36 <mniip> wait what
05:08:53 <mauke> data Foo = forall a. (Num a) => A a | B Bar
05:09:07 <bernalex> mauke: can you not do that without explicit forall? hmm
05:09:39 <init> bernalex: GADT syntax plays well with this
05:09:56 <bernalex> init: examples? :-] I'm not very good with GADTs yet
05:10:05 <mauke> bernalex: well, where are you going to get 'a' without forall?
05:10:26 <bernalex> mauke: IDK; that's why I'm asking! :)
05:13:23 <bernalex> also, semi-related, how do I data Fu = MkFu (any function (Num a) => a -> a -> a)?
05:13:33 <bernalex> so that I can e.g. MkFu (+) or MkFu (-)
05:14:08 <bergmark> mniip: you summarized a lot of my haskell programming very well there!
05:15:01 <Eduard_Munteanu> Why is there no process conduit in Data.Conduit.Process?
05:15:20 <init> bernalex: something like this http://lpaste.net/5347217610456956928
05:15:34 <bernalex> init: thanks heaps! I'll give it a go
05:15:36 <init> data Foo where Bar :: Num a => a -> a -> Foo
05:19:13 <bernalex> init: thanks!
05:20:09 <mniip> u = flip ($ ap) const
05:20:11 <mniip> there it is
05:20:31 <mniip> ‡≤†_‡≤† ambiguous
05:21:07 <bernalex> init: wait what
05:21:30 <bernalex> init: giving an 'a -> a -> Op' an 'a -> a -> a' won't work, right?
05:21:43 <bernalex> init: s/Op/Foo/ but yeah
05:22:11 <bernalex> init: Bar (+) would result in (a -> a -> a) -> Foo -- right?
05:24:07 <bernalex> init: OK I just don't understand GADTs probably hah
05:25:34 <merijn> bernalex: GADTs supercede several other extensions
05:25:46 <merijn> bernalex: For one, they come with an implicit ExistentialQuantification
05:26:23 <bernalex> merijn: I know this. I'm not sure how that helps.
05:26:50 <bernalex> data Foo where Bar :: Num a => a -> a -> Foo -- this won't let do Bar (+) and get a Foo, as far as I can tell
05:26:52 <merijn> bernalex: Wait
05:27:03 <merijn> Your initial question doesn't even need existential quantification...
05:27:10 <merijn> You just want RankNTypes
05:27:28 <merijn> "(forall a . Num a => a -> a -> a) -> Foo"
05:27:35 <bernalex> the data Foo = forall a. (Num a) => A a | B Bar?
05:28:09 <bernalex> oh the other one
05:28:18 <merijn> Ok, hold on what exactly do you want?
05:28:43 <bernalex> there were two different ones which confusingly both were dubbed Foo when init refererred to the second one as Foo too. :]
05:28:48 <merijn> "data Foo a where { A :: Num a => a -> Foo; B :: Bar -> Foo }"
05:28:53 <bernalex> data Foo = forall a. (Num a) => A a | B Bar
05:28:55 <bernalex> this works
05:28:57 <bernalex> then I want a Fu
05:29:11 <bernalex> data Fu = any Num a => a -> a -> a function
05:29:20 <bernalex> so MkFu (+) should give me a Fu
05:30:00 <merijn> data Fu where { MkFu :: (forall a . Num a => a -> a -> a) -> Fu }"
05:31:25 <bernalex> merijn: ah! I forgot the parens when I was trying to make it work with rank2
05:31:27 <bernalex> merijn: thanks!
05:32:14 <merijn> bernalex: Without the parens that type parses as a completely different rank1 type
05:32:22 <bernalex> yeah I see
05:44:06 <mjrosenb> is there a way of getting cabal/setup.l?hs to be super-verbose?
05:44:27 <mjrosenb> currently, I'm getting a mysterious error, and I'd like to find out /why/ it is wrong.
05:57:02 <bennofs> mjrosenb: -v3 is not verbose enough?
05:57:59 * mjrosenb tries with -v3
06:04:03 <bernalex> IDR how I'm supposed to do http://lpaste.net/5110186465699037184 but I figure it's ca not like this?
06:04:30 <bernalex> i.e. getArgs -- oh ok no args, getContents instead
06:04:55 <mauke> you can't start with putStrLn $ ...
06:05:02 <mauke> putStrLn takes a String
06:05:07 <mauke> no change to getContents in there
06:05:18 <bernalex> oh derp
06:05:36 <mauke> er
06:05:39 <mauke> *no chance
06:06:57 <bernalex> is there some super neat way to do it though?
06:07:10 <bernalex> like xs <- getArgs `magicInfix` getContents?
06:07:58 <bernalex> (semi-related: wish IO were a monoid already)
06:07:58 <mjrosenb> is there a way to get runhaskell ./Setup.hs to use a sandbox? runhaskell Setup.hs | grep -i sandbox doesn't return anything
06:08:24 <mjrosenb> bennofs: you can write magicInfix if you want.  I don't know of anything that will do that as is.
06:11:30 <bernalex> uh ok I uh solved it
06:11:34 <bernalex> instance Monoid a => Monoid (IO a) where
06:11:36 <bernalex>     mempty  = pure mempty
06:11:38 <bernalex>     mappend = liftA2 mappend
06:11:40 <bernalex> main = putStrLn . p =<< getArgs <> (words <$> getContents)
06:11:42 <bernalex> lol?
06:13:11 <bennofs> bernalex: liftA2 (<>) getArgs (words <$> getContents) directly is not too bad IMO
06:13:44 <tdammers> everything should be a monoid instance
06:14:02 <bernalex> tdammers: most things should be several
06:14:33 <mniip> can parsec parse arbitrary lists?
06:14:55 <mniip> I mean [a] and not [Char]
06:15:12 <tdammers> think so, yes
06:15:20 <mniip> ah
06:15:30 <tdammers> not all combinators and atomic parsers will work though
06:15:31 <mniip> ParsecT takes many arguments
06:15:39 <mniip> of course
06:17:19 <mniip> I see 'type Parsec s u = ParsecT s u Identity'
06:17:33 <mniip> what other monads does it make sense to use parsec with?
06:18:17 <tdammers> anything, pretty much, but ST and IO are probably the most common ones
06:18:26 <tdammers> that, or a transformer stack on top of either
06:18:48 <mauke> ParsecT Parsec
06:18:55 <tdammers> that, too
06:18:58 <tdammers> :P
06:19:06 <mauke> xzibit.jpg
06:19:27 <tdammers> but one use case would be if you need some sort of include feature, where you need to load more source files to parse as you encounter the includes
06:19:37 <tdammers> ParsecT over IO is useful in that case
06:20:30 <mjrosenb> PROGRESS!
06:21:05 <mjrosenb> it appears as if *someone* believes that sdl2 is linked via -lsdl2
06:21:08 <mjrosenb> they are wrong.
06:21:13 <mjrosenb> very wrong.
06:21:48 <bennofs> mjrosenb: it should be -lSDL2, no?
06:21:53 <mniip> ParsecT () () (ParsecT () () () ()) ()
06:21:59 <mniip> wait no
06:22:01 <mniip> ParsecT () () (ParsecT () () ()) ()
06:22:18 <mjrosenb> bennofs: yup.
06:22:24 <mjrosenb> bennofs: funny thing is.
06:22:42 <mjrosenb> "-lsdl2","-lSDL2_image","-lSDL2","-lpthread"
06:22:45 <mjrosenb> it already knows this.
06:24:40 <bennofs> mjrosenb: that second -lSDL2 probably comes from a dependency
06:24:48 <bennofs> mjrosenb: ze
06:24:59 <bennofs> mjrosenb: the firsz -lsdl2 from the package itself
06:25:08 <mjrosenb> bennofs: which package?
06:25:22 <bennofs> mjrosenb: what are you installing?
06:25:29 <mjrosenb> sdl2-image
06:25:57 <bennofs> I think sdl2-image says sdl2 in extra-libraries, while the sdl2 package says SDL2 (so that's where -lSDL2 comes from)
06:26:55 * hackagebot haskell-names 0.5.2 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.5.2 (PhilippSchuster)
06:27:14 <mjrosenb> ¬øque?
06:27:18 <mjrosenb> Setup: At least the following dependencies are missing:
06:27:18 <mjrosenb> sdl2 >=1.0 && <1.2
06:27:46 <mjrosenb> so, cabal install doesn't have that problem, but running setup.hs does.
06:28:04 <mjrosenb> ok, cabal configure worked.
06:28:10 <bennofs> mjrosenb: maybe because Setup.hs doesn't look for pkgconfig? idk
06:28:39 <mjrosenb> bennofs: that is the haskell package that it is missing (as far as I can tell)
06:29:13 <mjrosenb> oh, even better, cabal build completed successfully, cabal install failed.
06:29:18 <bennofs> lol
06:29:24 <bennofs> that sounds weird
06:29:38 <mjrosenb> and it failed during the building phase.
06:29:50 <bennofs> mjrosenb: do you have cabal sandboxes in this project?
06:30:20 <mjrosenb> bennofs: yeah, I'm trying without a sandbox
06:30:27 <mjrosenb> because I have no clue how to use them
06:30:31 <mjrosenb> someone said it was easy.
06:30:59 <mjrosenb> setup-Simple-Cabal-1.18.1.5-x86_64-linux-ghc-7.8.4: dist/package.conf.inplace:
06:30:59 <mjrosenb> inappropriate type
06:31:10 <bennofs> mjrosenb: ok, so you are in the project directory, and runhaskell ./Setup.hs configure failed while cabal configure worked?
06:31:58 <mjrosenb> bennofs: yes, and now, I am outside of any sandboxes (that I know of)
06:32:09 <mjrosenb> and cabal install still fails.
06:32:33 <bennofs> mjrosenb: hmm, check ghc-pkg list Cabal and cabal --version. Is the Cabal library version different between the two?
06:34:29 <mjrosenb> ghc-pkg list Cabal says Cabal-1.18.1.5, and cabal --version says 1.22.0
06:34:36 <mjrosenb> that's only off by 4!
06:34:56 <bennofs> mjrosenb: ah, then you might need to cabal install Cabal ? (where did you get that cabal-install from???)
06:35:06 * mjrosenb got it from pacman
06:36:24 <sedcf> i think i get frp. instead of functions you have stream transformers
06:36:37 <bennofs> mjrosenb: ok, then you can probably install Cabal from pacman too
06:37:10 <mjrosenb> bennofs: hahaha... arch is not that sane.
06:37:15 <hexagoxel> woah woah why install Cabal? is that even a dependency of the particular project?
06:37:32 <hexagoxel> also, it should not matter if the versions of Cabal are different
06:38:36 <speak> There are decent instructions on how to get Haskell running with sandboxes in the Arch Linux wiki, bennofs
06:38:43 <bennofs> hexagoxel: yes it does. Cabal 1.22 uses binary setup-config, so you get all sorts of issues of cabal-install was compiled against different Cabal than is available on the system
06:40:40 * mjrosenb thought that Cabal was shipped with, and tied at the hip with ghc?
06:41:17 <bennofs> mjrosenb: there is no problem with installing a new version of Cabal I think (it's only shipped with ghc, it's not special cased in ghc itself)
06:42:30 <mjrosenb> that may have been a quirk of gentoo.
06:45:33 <mjrosenb> bennofs: whoo, that enabled it to install!
06:45:38 <gregnwosu> hi i want to implement modify for my state monad using lenses
06:45:48 <gregnwosu> can anyone give me a quick example?
06:45:56 <gregnwosu> im using the evil Control.Lens
06:46:16 <bennofs> gregnwosu: what exactly do you want to do?
06:47:33 <gregnwosu> bennofs: i want to use modify from StateT
06:47:47 <gregnwosu> so I have to implement (s -> s)
06:48:17 <gregnwosu> bennoffs my State has getters already because I used record syntax to create the data type
06:48:25 <bennofs> gregnwosu: and you have a lens to some field in s you want to modify ?
06:48:33 <gregnwosu> and I only want to modify one field
06:48:37 <bennofs> ah ok
06:49:11 <bennofs> > execStateT (1,2) $ _2 %= (+3)
06:49:12 <lambdabot>  Couldn't match expected type ‚ÄòControl.Monad.Trans.State.Lazy.StateT
06:49:12 <lambdabot>                                  (m1 ()) m a0‚Äô
06:49:12 <lambdabot>              with actual type ‚Äò(t0, t1)‚Äô
06:49:18 <bennofs> > flip execStateT (1,2) $ _2 %= (+3)
06:49:19 <lambdabot>  No instance for (GHC.Show.Show (m0 (t0, t1)))
06:49:19 <lambdabot>    arising from a use of ‚ÄòM59803573217048769513696.show_M59803573217048769513...
06:49:19 <lambdabot>  The type variables ‚Äòm0‚Äô, ‚Äòt0‚Äô, ‚Äòt1‚Äô are ambiguous
06:49:28 <gregnwosu> i tried to do ( & (getterField1 .~ "newValue"))
06:49:59 <bennofs> > flip execState (1,2) $ _2 %= (+3)
06:50:00 <lambdabot>  (1,5)
06:50:03 <bennofs> > flip execState (1,2) $ _2 .= (+3)
06:50:05 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
06:50:05 <lambdabot>    arising from a use of ‚ÄòM115460254649174652213726.show_M1154602546491746522...
06:50:05 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
06:50:06 <bennofs> > flip execState (1,2) $ _2 .= 3
06:50:08 <lambdabot>  (1,3)
06:50:25 <bennofs> gregnwosu: basically, you can use most of the operators you're used to, just substitute ~ with =
06:50:29 <gregnwosu> bennofs: what is _2 a getter?
06:50:35 <bennofs> gregnwosu: it's a lens
06:50:58 <bennofs> gregnwosu: so you can do yourLens .= 3 to set the yourLens field to 3, or yourLens += 5, ...
06:51:03 <bennofs> > flip execState (1,2) $ _2 += 3
06:51:04 <gregnwosu> bennofs: ok thank you, i have to make the lens then first
06:51:05 <lambdabot>  (1,5)
06:51:16 <gregnwosu> i thougt there was a way to make a lens from the getter on the fly
06:51:24 <gregnwosu> yup
06:51:44 <bennofs> gregnwosu: not really, there is a very hacky way but I don't recommend that (using 'upon')
06:51:54 <bennofs> > flip execState (1,2) $ upon snd += 4
06:51:55 <lambdabot>  (1,6)
06:52:13 <gregnwosu> bennofs: ok, thanks
06:52:13 <bennofs> but that uses exceptions to figure out which field to modify. really magic
06:52:31 <bennofs> (and doesn't work for strict fields, for example)
06:52:45 <mjrosenb> yay, the sdl2 tutorial has lessons that fail to compile!
06:52:51 <dmwit> :t upon
06:52:53 <lambdabot> (Indexable [Int] p, Applicative f, Data a, Data s) => (s -> a) -> p a (f a) -> s -> f s
06:52:58 <osa1> is it possible for a socket to stay alive after the process opened it terminates?
06:54:14 <dmwit> > flip execState (1, 2) $ upon (\(x, y) -> (x, x)) .= (3, 4)
06:54:16 <lambdabot>  (1,2)
06:54:42 <bennofs> dmwit: as I said, it's really hacky magic that I don't recommend
06:55:32 <dmwit> > flip execState (1, 2, 3) $ upon (\(x, y, z) -> (x, y)) .= (4, 5)
06:55:34 <lambdabot>  (1,2,3)
06:56:01 <dmwit> Well, it seems to be merely magic rather than very magic.
06:56:28 <dmwit> osa1: I'm pretty sure most OS's clean that kind of thing up for you.
06:56:36 <mjrosenb> i,i magic/more magic
06:56:39 <dmwit> osa1: Why would you want it to?
06:56:57 <mjrosenb> dmwit: presumably, you could have a child that continues to listen to the socket
06:57:15 <mjrosenb> and if you have a named socket, then /anyone/ can pick it up (as I understand named sockets)
06:57:16 <dmwit> mjrosenb: Why would you want to hide the fact that the parent stopped talking from the child?
06:57:59 <mjrosenb> dmwit: services do this all the time, listen on a socket, then as soon as someone picks up the other end, fork off a child, and let them handle it
06:58:09 <mjrosenb> at which point the parent can die, and it doesn't much matter.
06:58:34 <dmwit> sure
06:58:43 <osa1> dmwit: I don't want to do that, I'm just debugging a program. my situation is really complicated but in short I'm having some non-deterministic problem where I can sometimes spawn a process in remote machine and connect to it but sometimes it's just failing with "connect: does not exist (Connection refused)"
07:01:24 <cem__> beginner haskell channel ?
07:01:37 <merijn> cem__: Beginner questions are ok here
07:02:09 <dmwit> You can ask here. If there's too much traffic to hold a beginner conversation, you may be asked to move to #haskell-overflow, but that's pretty rare unless you're chatting with Cale.
07:03:06 <mjrosenb> setup-Simple-Cabal-1.18.1.5-x86_64-linux-ghc-7.8.4: dist/package.conf.inplace:
07:03:06 <mjrosenb> inappropriate type
07:03:15 <mjrosenb> err, wrong buffer :-(
07:03:19 <mjrosenb> initializeSDL :: [Word32] -> IO (Risky ())
07:03:21 <mjrosenb> there we go!
07:03:36 <mjrosenb> that fills me with confidence
07:03:52 <dmwit> osa1: Confusing! I don't know how to help.
07:03:57 <sedcf> i was thinking of writing a city builder game for fun. but i realised what i really want is a civil engineering simulator
07:04:44 <sedcf> well that's going to take awhile
07:04:57 <cem__> Œª not false Not in scope: `false'
07:05:04 <dmwit> > not False
07:05:05 <cem__> what this means scope ?
07:05:06 <lambdabot>  True
07:05:18 <cem__> what is scope ?
07:05:31 <cem__> trying to get the error
07:05:32 <dmwit> The collection of variables that is known.
07:05:36 <mjrosenb> cem__: lexical scope, you can think of it as the list of variables that are defined.
07:06:16 <sedcf> it'd be a cool way to learn calculus
07:06:31 <sedcf> here build a bridge
07:06:55 <dmwit> sedcf: Perhaps you would like Beseiged (sp?).
07:07:17 <wolf_mozart> is it true that haskell programmers like go?
07:07:17 <dmwit> or like... KSP
07:07:21 <wolf_mozart> most of them?
07:07:27 <dmwit> red flag, red flag
07:07:30 <dmwit> language debate alert
07:07:48 <init> no, we all dream about writing Adga
07:07:55 <wolf_mozart> it's early in the morning but it had to happen
07:07:55 <pjdelport> wolf_mozart: Go the board game or Go the programming language?
07:07:58 <pjdelport> I like the former.
07:08:07 <wolf_mozart> go the board game
07:08:27 <pjdelport> I know several Haskell programmers who like go. :)
07:08:30 <wolf_mozart> I've been watching these haskell videos and most programmers talk about go
07:08:35 <pjdelport> We have a group on OGS.
07:08:42 <wolf_mozart> yeah that's weird lol
07:09:00 <sedcf> dmwit: that looks cool. thanks
07:09:07 <wolf_mozart> go is been said is far superiour to chess, but yeah
07:09:31 <wolf_mozart> now another question, are most haskell programmers gay?
07:09:48 <mniip> I think not
07:10:26 <mniip> what makes you think so
07:10:32 <wolf_mozart> i know one that plays go, knows haskell and is gay and the videos i saw old men without wedding rings
07:10:35 <dmwit> What makes you think that question is appropriate?
07:11:12 <wolf_mozart> we are supposed to be liberal scientists, there is no shame in inquiring about the correlation about such things
07:11:16 <mniip> one example is not enough to construct a relation
07:11:37 <dmwit> wolf_mozart: If you went to a job interview, and the interviewer asked you who you liked to have sex with, you wouldn't find that a bit odd?
07:11:52 <dmwit> I would. That would be the end of the interview for me.
07:11:54 <evenex> dmwit: depends on the job
07:11:58 <mjrosenb> dmwit: depends how attractive they were.
07:13:35 <wolf_mozart> no, i would just say it as it was, and we would have a laugh about it, but i get your point, nvm, it's just that in the videos the experts in haskell move weirdly, and they are above 40 and have no wedding ring, and the one haskell programmer likes the same thing they like and is gay, and as a person who deals with research i inquired this to rest my
07:13:39 <wolf_mozart> curiosity
07:14:18 <dmwit> Let's move on to questions about Haskell instead of questions about Haskellers.
07:14:32 <merijn> I feel dumber for having read any of this...
07:14:36 * mjrosenb has one
07:14:45 <mjrosenb> is Risky something that exists outside of sdl2?
07:14:53 <merijn> And I just came back from a emacs discussion on gcc vs clang
07:15:06 <merijn> mjrosenb: I've never heard of that type, so no :p
07:15:19 <mjrosenb> cool, now I need to figure out wtf that is.
07:15:31 <mjrosenb> ahh it is not even sdl,
07:15:34 <mjrosenb> it is this test
07:15:38 <mjrosenb> type Risky a = Either String a
07:16:42 <merijn> mjrosenb: I was about to say, isn't that a matter of clicking on the documentation link?
07:17:11 <sedcf> i think i will attempt something like beseiged but much simpler. like scorched earth remake
07:17:12 <wolf_mozart> to be honest with you i am kinda scared that if i learn haskell as I'm doing now, I will stop liking chess and instead i would go and play go and i will stop liking women
07:17:36 <merijn> @where ops
07:17:36 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
07:17:37 <dmwit> sedcf: sounds fun
07:17:48 <sedcf> tanks shoot at each other in a hilly 3d world
07:17:53 <merijn> Can we do something about this trolling? >.>
07:18:21 <Stratege> wolf_mozart in that case I'd suggest not learning Haskell but rather learning Java.
07:18:29 <Gx00-> lol 1500 users and no ops?
07:18:45 <merijn> Gx00-: As matter of policy all ops in #haskell are unopped
07:18:56 <rhllor> the users are the ops
07:18:56 <merijn> Gx00-: They are only opped when kicking/banning
07:19:05 <Gx00-> then how do you know who they are?
07:19:12 <dmwit> Gx00-: lambdabot just summoned them
07:19:14 <rhllor> make a mistake in their presence, I dare you
07:19:15 <sedcf> if i'm she say so. i'm not even sure i'm not a bot so what can i say about being a troll?
07:19:15 <haasn> Why do you need to know who they are?
07:19:15 <tdammers> lambdabot knows :D
07:19:17 <merijn> Gx00-: That's why the command highlights all of them
07:19:38 <Gx00-> i didnt see a command issued lol
07:19:50 <tdammers> Gx00-: <merijn> @where ops
07:19:50 <Gx00-> ah i see it now
07:20:22 <merijn> Gx00-: It used to be in the topic, but newcomers stopped spamming and there's almost always someone who knows that around so it was removed from the topic, until it becomes a problem
07:20:33 <Gx00-> well, i see the response. thought the where ops was a question lol
07:21:43 <sedcf> ok guys i was recently introduced to a new word; amotivation
07:21:58 <mniip> is there a simple way to use Data.Dynamic with my own types?
07:22:14 <dmwit> mniip: You can derive all the appropriate classes.
07:22:24 <dmwit> mniip: GHC will tell you which extensions to turn on.
07:22:35 <merijn> mniip: You need to make the Typeable instances (and maybe Data?), GHC can derive those
07:22:48 <mniip> aww
07:22:52 <mniip> using extensions
07:23:09 <merijn> mniip: What does that matter?
07:23:14 <sedcf> at first i was skeptical but then my whole life was pointed out to me. so if im back soon summon the devil to get ky homework
07:23:16 <chpatrick1> you're not a real haskell programmer unless you use 15 extensions
07:23:29 <sedcf> i actually think h
07:24:01 <merijn> chpatrick1: -XKitchenSink ;)
07:24:05 <dmwit> mniip: You can still used sum types in Haskell2010.
07:24:08 <sedcf> askell should be a family of languages
07:24:32 <dmwit> mniip: data AllTheTypesICareAbout = Int Int | String String | MyFancyType MyFancyType
07:24:32 <haasn> Haskell already is a family of languages
07:24:34 <sedcf> i don't like this tablet
07:24:39 <haasn> It currently includes Haskell 98 and Haskell 2010
07:24:46 <chpatrick1> looking at the list in ghci
07:24:47 <chpatrick1> -XJavaScriptFFI, what
07:24:49 <haasn> And arguably also Haskell Prime
07:24:54 <mjrosenb> are sum types anything other than Either, and similar types?
07:24:55 <merijn> chpatrick1: ghcjs
07:24:57 <haasn> Personally, I consider GHC Haskell its own dialect of Haskell
07:25:03 <dmwit> haasn: And the 2^n languages coming from turning on or off the n extensions GHC has. ;-)
07:25:07 <rhllor> what other commonly used languages are functional and lazy
07:25:18 <mniip> so I added {-# LANGUAGE DeriveDataTypeable #-}
07:25:20 <dmwit> rhllor:
07:25:20 <haasn> Where I define ‚ÄúGHC Haskell‚Äù as ‚Äúall the useful extensions‚Äù :)
07:25:26 <mniip> and it's still asking me to enable the extension
07:25:26 <merijn> rhllor: I know plenty of functional ones, not a lot of lazy ones
07:25:26 <dmwit> rhllor: (That was my answer. Not a typo.)
07:25:40 <hodapp> as much as I normally avoid extensions, that's sort of impossible when using Ivory.
07:25:41 <merijn> dmwit: Hey! There's Lazy ML :p
07:25:42 <hodapp> oh well!
07:25:55 <haasn> Or perhaps ‚ÄúGHC Haskell‚Äù is the powerset generated by GHC extensions
07:25:59 <mjrosenb> there's also lazy k
07:26:04 <haasn> (Which is itself a subset of the Haskell family)
07:26:08 <mjrosenb> but you probably don't want to use lazy k.
07:26:23 <merijn> If we go for "purely functional" (but not lazy) there's also Clean (and a few others, but not really mainstream)
07:26:29 <rhllor> so Haskell is pretty much one of a kind?
07:26:43 <haasn> rhllor: Pick two: Commonly used, lazy, functional
07:26:46 <merijn> If we just go functional without purity we get ocaml/F#/swift, etc.
07:26:59 <dmwit> haasn: commonly used, lazy
07:27:11 <mniip> guys?
07:27:18 <haasn> dmwit: Java because the developers are too lazy to add anything useful to the language
07:27:20 <haasn> (That's how it works, right?)
07:27:22 <merijn> rhllor: Basically, if you wanna do research in a lazy functional language, what's less effort, hack GHC or implement something new from scratch? :)
07:27:22 <mniip> {-# LANGUAGE DeriveDataTypeable #-} doesn't seem to work
07:27:28 <dmwit> mniip: Did you definitely save your file?
07:27:36 <merijn> mniip: You need to add "deriving (Typeable)" to you type :)
07:27:38 <mniip> yeah
07:27:44 <mniip> yeah
07:27:47 <merijn> Like Show/Eq
07:27:50 <dmwit> ?paste the file, mniip
07:27:50 <lambdabot> Haskell pastebin: http://lpaste.net/
07:28:15 <merijn> rhllor: There's not really that much interest in creating a new language from scratch just as a lazy alternative to haskell. Too much work, too little gain
07:28:23 <mjrosenb> don't forget about C++, that has a pure, functional language.
07:28:24 <merijn> rhllor: Until someone finally starts making lazy Idris :p
07:28:49 <lpaste> mniip pasted ‚ÄúDeriveDataTypeable‚Äù at http://lpaste.net/120265
07:28:49 <haasn> Ah yes, C++ templates are *the* archetype of pure functional programming in industry :)
07:29:00 <tdammers> javascript has a lazy subset, albeit with grotesque syntax
07:29:10 <rhllor> you mean elm?
07:29:16 <haasn> mniip: I'm pretty sure the LANGUAGE pragma needs to be the first thing in your file
07:29:20 * hodapp vomits a little in haasn's direction
07:29:23 <mniip> oh?
07:29:30 <haasn> But I could be terribly mistaken.
07:29:42 <hodapp> mjrosenb: for a pure, functional language, it's decidedly dirty and dysfunctional-feeling.
07:29:51 <hodapp> tdammers: lazy subset whaa?
07:30:00 <tdammers> hodapp: callbacks
07:30:10 <merijn> rhllor: Did who mean Elm?
07:30:11 <mniip> ooh
07:30:11 <haasn> mniip: Yep, moving it to the beginning makes the file compile for me
07:30:13 <mniip> you are correct
07:30:19 <hodapp> tdammers: oh, true
07:30:26 <haasn> This should have a better error message.
07:30:32 <rhllor> merijn: tdammers
07:30:36 <haasn> Can you open a ticket on the GHC trac asking for a better error message? :)
07:30:43 <rhllor> the js language he was talking about
07:30:47 <merijn> mniip, haasn: Yes pragmas always have to be the first stuff in the file
07:30:53 <tdammers> no, I meant js itself
07:31:16 <mniip> haasn, too lazy :P
07:31:18 <tdammers> callbacks aren't technically a core language feature, but they are so idiomatic that they might as well be
07:31:21 <haasn> mniip: Same here :/
07:31:36 <mniip> got deepSeq?
07:31:41 <merijn> haasn: What was the error? Parse error?
07:31:45 <haasn> deepSeq me, baby
07:31:51 <hodapp> If I define something in a 'where', must that something have a concrete type?
07:31:59 <haasn> merijn:       You need DeriveDataTypeable to derive an instance for this class
07:32:07 <dmwit> hodapp: No, but see also MonoLocalBinds
07:32:18 <haasn> merijn: It's as if the LANGUAGE pragma gets silently ignored
07:32:22 <merijn> haasn: It is
07:32:24 <dmwit> hodapp: Which is implied by several other extensions, notably GADTs.
07:32:30 <hodapp> I'm just observing some places in which 'where f = ...' causes errors due to ambiguous types, but the same definition put outside is fine
07:32:41 <merijn> haasn: pragma's after the end of file are just comments
07:32:50 <merijn> eh, beginning
07:32:55 <haasn> merijn: It should at least be a warning
07:33:03 <merijn> I think it is with -Wall
07:33:04 <gilligan_> % ghc-mod check src/Account.hs                                                                          ‚ú≠
07:33:04 <gilligan_> /home/tpflug/Development/haskell/account/dist/setup-config: hGetContents: invalid argument (invalid byte sequence)
07:33:10 <gilligan_> has anyone see this before by any chance ?
07:33:23 <haasn> merijn: Not on my end
07:33:32 <dmwit> glguy: No, but it sounds like your system locale's encoding and the file's encoding don't match.
07:33:32 <gilligan_> fresh haskell setup - just installed ghc-mod from hackage
07:33:34 <merijn> haasn: Ah, you're right
07:33:44 <dmwit> gilligan_: That was supposed to be for you, not glguy (sorry glguy!).
07:33:54 <hodapp> dmwit: Well, if not, why would it complain about an ambiguous type signature inside that 'where', but not outside of it?
07:33:59 <merijn> gilligan_: Is your locale utf-8? If not, you have to change that, most likely
07:34:46 <dmwit> hodapp: ...perhaps one of your extensions implies MonoLocalBinds.
07:35:45 <dmwit> hodapp: But without seeing a MWE, it's always tough to diagnose this stuff.
07:35:48 <hodapp> dmwit: The code has no extensions, and only imports Data.Maybe and Control.Applicative. One of those?
07:35:57 <dmwit> imports should not turn on extensions.
07:36:48 <dmwit> hodapp: I dunno. Perhaps MonomorphismRestriction is on (by default) and defaulting is kicking in outside of the where clause or... something. I haven't seen this issue before, so I'm just taking potshots.
07:36:56 <dmwit> Can you show us an example?
07:38:05 <hodapp> dmwit: http://lpaste.net/120234 - derived from an example yesterday, so it's not perhaps *minimal* but is hopefully comprehensible.
07:38:26 <hodapp> dmwit: note particularly f2.
07:39:57 <gilligan_> merijn, hm. looking at the output of `locale` i would say that looks alright
07:40:08 <dmwit> hodapp: NoMonomorphismRestriction fixes it.
07:40:11 <mniip>     Couldn't match expected type `BS.ByteString' with actual type `bytestring-0.10.0.2:Data.ByteString.Internal.ByteString'
07:40:13 <mniip> what's that
07:40:21 <dmwit> hodapp: Or putting the type signature in the same way you did for f1.
07:40:30 <dmwit> hodapp: (i.e. on the binding, not on the bound expression)
07:40:50 <dmwit> hodapp: I note that if you float f2 to the top-level without changing anything, you get the same error.
07:41:08 <gilligan_> merijn, https://gist.github.com/gilligan/cab835230dadd766fc26  -- LANG is set to en_US-UTF8 - which I guess should be correct
07:41:09 <hodapp> dmwit: somehow I'd forgotten I could give type signatures thus in a where/let...
07:41:42 <sedcf> this looks cool: https://hal.inria.fr/hal-00694525/document
07:41:43 <hodapp> dmwit: thanks for the help there
07:42:33 <gilligan_> merijn, https://github.com/kazu-yamamoto/ghc-mod/issues/417
07:42:59 <sedcf> it seems really challenging.
07:43:38 <gilligan_> merijn, eh, well d'oh -- the file is in binary format and ghc-mod is trying to read it as text
07:44:00 <dmwit> sedcf: Do your homework!
07:44:01 <merijn> gilligan_: oh, hah
07:44:27 <sedcf> you don't consider translating that into haskell homework?
07:44:37 <merijn> gilligan_: I'm hoping ghci-ng is going to quickly replace ghc-mod/hsdevtools and we'll avoid all these issues
07:44:38 <sedcf> jeez if i could do that someone would hire me
07:45:22 <sedcf> am going to start with generating smooth hilly terrain
07:45:26 <haasn> +1 on that probably being more interesting than whatever sedcf's homework assignment is
07:45:33 <sedcf> but first to see what a clothoid is
07:45:52 <hodapp> bahahaha. The larger code I had yesterday that was stumping me, from which I made a minimal example and got help, only needed to replace a $ that was already there with a <$> to be correct, and wrapped with one outside 'catMaybes'... I just missed that somehow.
07:45:53 <gilligan_> merijn, right.. trying to figure out what my easiest route to a somehow working setup is right now
07:46:34 <gilligan_> merijn, ah never mind.. there seems to be some help here : https://github.com/kazu-yamamoto/ghc-mod/wiki/InconsistentCabalVersions
07:52:09 <sedcf> ok here's my idea. pick a bunch of points on a 2d surface and assign a random height. then draw "slopes" between the "neighbors"
07:52:22 <sedcf> so nearest neighor kind of algorithm?
07:53:00 <sedcf> this is k-clustering? time to go reading
07:53:55 <awesomo4000> does anyone have an example of using fold from System.FilePath.Find
07:54:24 <sedcf> oh cool. post-office problem
07:56:06 <sedcf> wow i own the book. i feel proud of myself somehow. now to actually read part of it
07:56:11 <RchrdB> sedcf: a Voronoi tesselation would give you decent shapes out of random points.
07:56:28 <RchrdB> *tessellation
07:56:47 <mjrosenb> sedcf: what is your ultimate goal?
07:56:57 <mjrosenb> oh, a terrain
07:57:06 <hvr> https://www.haskell.org/pipermail/haskell-cafe/2015-February/118095.html
07:57:18 <mjrosenb> sedcf: don't you want the terrain to be grid-like to some extent?
07:57:36 <RchrdB> sedcf: given a set of points in 2D, the Voronoi tessellaiton gives you a set of polygons, one polygon per point, where each polygon covers the area that is closest to one point. :)
07:58:47 <sedcf> you've played scorched earth right? the land is a curve
07:58:49 <tdammers> isn't voronoi for 2D?
07:59:13 <sedcf> i would like to do the same in 3d. so to generate a smooth plane
07:59:19 <tdammers> or rather, wouldn't voronoi tesselation over a rectangular grid just produce squares?
07:59:36 <sedcf> be warned guys, i'm taking notes
07:59:58 <tdammers> so well, anyway... the thing with SE is obviously that the terrain is dynamic
08:00:05 <hodapp> sedcf: the original Scorched Earth by Wendell Hicken?
08:00:08 <hodapp> the Mother of All Games?
08:00:08 <sedcf> it'd be cool to make it a clay-like game
08:00:14 <tdammers> you can blow holes in it, and some weapons add dirt, and all that
08:00:15 <sedcf> but simplicity first
08:00:33 <sedcf> hodapp: yeah, special place in my heart
08:00:39 <tdammers> which means that running an expensive terrain generator and then baking that into a static mesh won't be an option
08:00:47 <hodapp> sedcf: as it should be!
08:00:57 <hodapp> sedcf: the 3D version is alright though. Definitely trickier
08:01:02 <mjrosenb> sedcf: 10 to 1 says that scorched earth is just a list of heights.
08:01:20 <sedcf> right and then some bezier curves or something?
08:01:27 <sedcf> the points are the control points
08:01:38 <tdammers> sedcf: no, simpler
08:01:48 <tdammers> one height per pixel-side column
08:02:07 <hodapp> mjrosenb: it'd be slightly more complicated, because in the course of a move, the land can be split up multiple times along a vertical line, though at the end of the move, gravity forces it all back down
08:02:08 <tdammers> and then a relatively simple terrain generator algo
08:02:19 <sedcf> oh right, discrete but seems smooth because of resolution
08:02:24 <tdammers> yes
08:02:29 <hodapp> and there are cavern levels, which have terrain both above and below.
08:02:31 <tdammers> I think it's not a list of heights though
08:02:48 <tdammers> more like a bitmap
08:02:55 <sedcf> so generate some "powder" and have it settle?
08:03:02 <tdammers> yep
08:03:08 <tdammers> basically move pixels individually
08:03:17 <sedcf> sweet so a noise function of some sort?
08:03:20 <tdammers> tanks are 1 pixel wide for the purpose of falling
08:03:31 <sedcf> over a 3d space
08:03:47 <tdammers> well, the problem with 3D is that you're looking at voxels
08:04:03 <sedcf> troublesome yes
08:04:06 <tdammers> even just a 256x256x256 pixel map is going to be relatively large
08:04:06 <hodapp> <3 voxels
08:04:20 <tdammers> so you'll definitely need some optimizations there
08:04:23 <sedcf> maybe a binding to some prewritten voxel libary? maybe haskell already has one
08:04:44 <sedcf> wheels are useful but i buy them at the store right?
08:05:06 <EvanR> reuse code? NEVAR!
08:05:39 <tdammers> much more fun carving them out of stone yourself
08:06:18 <hodapp> you should use OOP, I heard it's good with code reuse
08:06:20 <EvanR> more like growing them in the garden or brewing them in your closet
08:06:44 <sedcf> oh sweet. what do people think of lambdacube?
08:07:37 <jtanguy> sedcf: if you're looking into terrain generation, I would suggest the diamond-square algorithm http://www.playfuljs.com/realistic-terrain-in-130-lines/
08:08:15 <hodapp> Is it normal to use Haddock to document things that the module doesn't export?
08:08:37 <EvanR> for your own sanity its probably a good idea
08:09:02 <EvanR> and you get the nice 100% completion!
08:09:15 <hodapp> but does Haddock check for completion over things that aren't exported?
08:09:51 <EvanR> i think so because i got very low scores even though i documented everything exported
08:10:16 <EvanR> but it might be counting all function arguments
08:10:25 <hodapp> well, it complains when I reference (from inside that module) things that are documented, but not exported
08:10:39 <EvanR> yeah that would be annoying
08:10:56 <hodapp> but I'm doing haddock --internal --executables now
08:11:12 <sedcf> it's only a little old
08:11:40 <rhllor> is there a haskell function equivalent to   :t    in ghci?
08:12:31 <EvanR> a function that does what?
08:13:04 <rhllor> that return as a string the type signature of a function
08:13:19 <hodapp> I have to wonder why you need this inside your program
08:13:33 <tdammers> type signatures live in the compiler, they don't generally make it into the binary
08:14:02 <EvanR> types should not exist at runtime!
08:14:24 <EvanR> except dynamic types
08:14:24 <tdammers> conceptually, they don't
08:14:30 <mauke> :t show . typeOf
08:14:31 <lambdabot> Typeable a => a -> String
08:15:01 <EvanR> > show . typeOf $ ord
08:15:02 <lambdabot>  "Char -> Int"
08:15:11 <EvanR> d-d-dang
08:15:50 <tdammers> except that typeOf resolves at compile time
08:15:53 <mjrosenb> > show . typeOf $ 20
08:15:55 <lambdabot>  "Integer"
08:16:07 <mjrosenb> > show . typeOf $ []
08:16:09 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
08:16:09 <lambdabot>    arising from a use of ‚ÄòData.Typeable.Internal.typeOf‚Äô
08:16:09 <lambdabot>  The type variable ‚Äòt0‚Äô is ambiguous
08:16:17 <mjrosenb> ahh, there we go!
08:16:23 <tdammers> at least that's how I understand it
08:16:23 <EvanR> > show . typeOf $ id
08:16:24 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
08:16:25 <lambdabot>    arising from a use of ‚ÄòData.Typeable.Internal.typeOf‚Äô
08:16:25 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
08:16:51 <hodapp> :t typeOf
08:16:53 <lambdabot> Typeable a => a -> TypeRep
08:16:54 <hodapp> DAMMIT
08:16:57 <hodapp> I was hoping for an explosion
08:17:03 <tdammers> nope
08:17:08 <geekosaur> no boom today
08:17:09 <tdammers> it's not even magic
08:17:18 <EvanR> the type of all types
08:17:24 <mauke> *
08:17:59 <Welkin> the type of types of types, even
08:18:05 <Welkin> haskell doesn't have Sorts, though
08:18:19 <tdammers> just another typeclass; the value you pass is only really needed so that the compiler has something to infer the type from
08:18:39 <tdammers> > typeOf (undefined :: Int)
08:18:41 <lambdabot>  Int
08:18:43 <EvanR> Welkin: or does it
08:18:50 <tdammers> > show $ typeOf (undefined :: Int)
08:18:52 <lambdabot>  "Int"
08:19:04 <EvanR> Welkin: the sort of all kinds is BOX
08:19:33 <init> even #?
08:19:46 <EvanR> hrm
08:20:31 <hodapp> I forget what sorts mean.
08:20:38 <awesomo4000> is filemanip the best library to use for filesystem traversal
08:20:56 <scott> hodapp: values have types, types have kinds, kinds have sorts
08:21:05 <hodapp> pfffft
08:21:20 <EvanR> hodapp: exactly
08:21:26 <Welkin> it's turtles all the way down
08:21:37 <EvanR> just make types first class and be done with it
08:21:52 <hodapp> let's just do away with types altogether
08:21:53 <sedcf> there's data.octree. i think i like that. let's me focus on the algorithm. nice and abstract
08:21:55 <HeladoDeBrownie> it actually is turtles all the way down in idris
08:22:01 <EvanR> hodapp: impastable!
08:22:32 <sedcf> then i use my abstract model to control the changes in graphics
08:23:17 <Welkin> sedcf: you mean an intermediate representation
08:23:22 <sedcf> so i want to stick frp in here somewhere. i like thinking of it a stream transformers
08:23:31 <sedcf> right
08:24:07 <EvanR> streams in disguise
08:24:30 <sedcf> i'm convinced i'm starting to understand something. there's like a billion ideas coming at me all at once and i can't put them together
08:24:47 <sedcf> this is where i start to get distracted. my mind likes to ruminate
08:25:00 <sedcf> this is something useful i have been taught
08:25:28 <hodapp> I don't see any use for FRP in this embedded stuff I am doing right now but I found the bit that I'd listened to/read from Conal about FRP and denotational design to be very interesting
08:25:30 <sedcf> by being aware of it i can not respond to it. i hope you guys don't mind me sharing this
08:25:30 * geekosaur points hodapp to Omega
08:25:34 <hodapp> geekosaur: wut
08:25:42 <hodapp> geekosaur: the Halting Probability of Chaitin?
08:25:45 <geekosaur> re the types-kinds-sorts thing
08:25:48 <hodapp> geekosaur: but that number is undecidable!
08:26:00 <sedcf> i have struggled for so long and finally i find someone who can explain my mind to me
08:26:09 <geekosaur> it's a language which uses the same notation for values, types, kinds, sorts, ...
08:26:37 <hodapp> geekosaur: I thought once once got into dependent types that was how most languages behaved
08:26:41 <hodapp> s/once once/once one/
08:26:45 <sedcf> before ai comes motivation. i must implement my motivation
08:26:55 <sedcf> nuts but it has to happen somehow
08:26:55 <conal> hodapp: glad to hear.
08:27:03 <hodapp> conal: sorry, didn't mean to ping you :P
08:27:11 <conal> hodapp: np. :)
08:27:21 <luigiinred> Hello 372
08:27:22 <geekosaur> hodapp, only for a small handful of levels. Omega's so named because it has an infinite number of such levels
08:27:46 <tdammers> hmm, I think this is actually the holy grail of FP - lisp's "first-class anything" combined with Haskell's type safety
08:28:08 <hodapp> geekosaur: well, I thought Coq for instance had basically this with type universes
08:28:10 <scott> geekosaur: depdendently typed languages like agda and idris have infinite levels, no?
08:28:47 <sedcf> i never expected to become a constructive mathematician when i picked up haskell
08:28:48 <MP2E> agda does, not sure about idris
08:28:54 <sedcf> like how did that happen?
08:29:01 <hodapp> sedcf: peer pressure
08:29:07 <geekosaur> hm. agda at least does not 100% manipulate types the same way as values. omega is ... a bit weird
08:29:11 <HeladoDeBrownie> i thought idris had something like Set 0, Set 1, Set 2, ‚Ä¶ as types
08:29:12 <conal> sedcf: in a sense FRP is like stream transformation *but more so*. while streams are infinitely long, FRP behaviors are infinitely dense as well, which is very important for modularity.
08:29:16 <HeladoDeBrownie> types/kinds/‚Ä¶
08:29:24 <geekosaur> (I do not *recommend* it except for brain explosion...)
08:29:59 <EvanR> HeladoDeBrownie: scott idris advertises the infinite hierarchy of types, but its not accessible to the programmer, and may even be a trick to satisfy pedants. the type of Type is "Type 1" but Type 1 is not valid syntax and you cant ever get Type 2
08:30:16 <HeladoDeBrownie> oh, weird
08:30:31 <EvanR> if its still sound somehow, its handled automatically by the compiler
08:30:34 <scott> EvanR: I read a discussion about this the other day. I think the idea is that you can't talk about the levels but idris won't let you do bad things
08:30:36 <sedcf> conal: infinitely dense?
08:30:49 <EvanR> scott: right, that would be good ;)
08:30:52 <sedcf> like numbers between numbers?
08:30:57 <conal> sedcf: yes. continuous time, not discrete.
08:31:19 <HeladoDeBrownie> i never quite understood how we could talk about continuous time using discrete entities
08:31:27 <conal> sedcf: though sadly, much of what people call "FRP" these days discards this fundamental principles
08:31:36 <sedcf> ok i can handle it. i'm using the discrete as an analogy for now. i still need to work on my calculus
08:31:46 <Welkin> HeladoDeBrownie: the universe is quantized, not continuous
08:31:56 <HeladoDeBrownie> Welkin, what does that mean?
08:32:04 <EvanR> the universe is continuous thx
08:32:04 <Welkin> time is quantized
08:32:09 <sedcf> metaphysics is not part of the haskell standard
08:32:13 <Welkin> matter/energy is quantized
08:32:23 <sedcf> it is sort of "presupposed" by the standard
08:32:23 <Hijiri> means we should simulate our FRP in time steps of planck units
08:32:31 <hodapp> Welkin: That's just an implementation detail of the universe.
08:32:49 <conal> We've been describing continuous things for hundreds of years, at least, in spite of finite & discrete vocabularies and inference systems.
08:33:08 <Saizan> geekosaur: you mean that in Omega you can pattern match on types?
08:33:11 <sedcf> well alright in haskell prime should we have a quantized universe or a continuous one? </troll>
08:33:47 <conal> Moreover, discrete computation is an abstraction, implemented on a continuous-time substate (electricity).
08:33:49 <geekosaur> if you're simulating at a high enough level, continuous is an approximation that produces correct results
08:33:53 <EvanR> HeladoDeBrownie: if an implementation of frp is "faithful" then it will converge to the true value as the sampling rate increases
08:34:15 <sedcf> ok. so we have a description of a continuously-defined "animation"
08:34:26 <sedcf> how do we turn that into efficient code?
08:34:37 <sedcf> so we have some kind of approximator?
08:34:54 <conal> sedcf: i've written several papers on those questions. http://conal.net/papers
08:35:02 <sedcf> ok right sorry :)
08:35:14 <conal> in fact, it's critical for efficiency that we use a continuous not discrete time model.
08:35:25 <bergmark> mjrosenb: fwiw i managed to install reactive on ghc 7.8, with --reorder-goals --max-backjumps=-1
08:36:23 <conal> continuous time was crucial to my getting thousands of frames per second in an early FRP implementation in the late 90s.
08:37:34 <sedcf> hmm. i'm like the donkey trying to pick which bale of hay to eat from
08:37:40 <conal> i'm always surprised when haskellers balk at continuous time as unrealizable, considering how we casually toss around infinite data.
08:37:59 <sedcf> indeed, they've yet to cross the singularity
08:38:08 <sedcf> we must be patient with them
08:38:10 <mjrosenb> bergmark: that's cool, I'll try it.
08:38:13 <EvanR> lol
08:38:21 <conal> BTW, see https://github.com/conal/talk-2014-bayhac-denotational-design#why-continuous-time-matters
08:39:23 <conal> It's largely the same advantages as continuous space: simple & precise semantics (and thus tractable correct & useful reasoning), and modularity/composability.
08:40:26 <conal> Premature sampling (finitization and/or discretization) in time or space breaks composability pretty badly.
08:40:39 <mjrosenb> bergmark: how long did the Resolving dependencies... step take?
08:40:51 <mjrosenb> so far, it has been running for a while.
08:41:21 <mjrosenb> bergmark: perhaps I should try that in a new sandbox?
08:47:05 * hackagebot diagrams-rasterific 0.1.0.7 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-0.1.0.7 (jeffreyrosenbluth)
08:49:08 <yac> how can I compile a 32b executable on x86-64 system?
08:49:59 <opqdonut> yac: by installing a suitable ghc, see https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling
08:50:43 <Big_G> Is there an easy way to prevent looping through an infite list?
08:50:58 <mniip> Big_G, not per halting problem
08:51:12 <mniip> not generally, per halting problem
08:51:13 <opqdonut> yac: in practice I think it will be easiest to install a 32bit env in a chroot/virtual machine/docker
08:51:20 <opqdonut> Big_G: yes, don't do it
08:51:31 <opqdonut> Big_G: do you have a concrete situation in mind?
08:51:41 <EvanR> Big_G: have evidence that your traversal will be productive
08:51:51 <EvanR> and or terminate
08:52:04 <Hijiri> Big_G: you could limit the number of elements you go through
08:52:18 <Big_G> opqdonut, Not really but I can make one. Let's say you loop through each element of [1..]. That loop will never terminate and I as a human can see that.
08:52:42 <EvanR> Big_G: it wont terminate but it might be productive
08:52:51 <EvanR> map (+1) [1..]
08:53:17 <ruler501> What would be the best way to get this code to thread out better? Currently it only uses one core http://pastebin.com/Ean4nN72
08:53:41 <mjrosenb> bergmark: yup, pretty sure that isn't terminating
08:53:43 <haasn> filter isPrime [1..]
08:53:43 <Big_G> EvanR, I was thinkin of a more traditional loop but I can see how that would be very nice
08:53:53 <EvanR> Big_G: in haskell "looping through" something often needs to be reimagined, since theres no simple for loop just incrementing counters
08:53:58 <Hijiri> I think both those examples can be thought of as terminating
08:54:00 <nerium> I'm getting this value when trying to evaluate a function.
08:54:01 <nerium> Expected type: Err ()
08:54:01 <nerium> Actual type: Err [Char]
08:54:10 <opqdonut> ruler501: you already seem to have a parMap there, maybe you're not running it on multiple cores?
08:54:10 <Hijiri> you do get a value, just an infinitely long one
08:54:19 <mjrosenb> conal: if anyone knows how to build reactive with modern packages, it'd be you :-p
08:54:21 <Hijiri> but printing it out is productive but nonterminating
08:54:24 <opqdonut> ruler501: run the program with e.g. +RTS -N2
08:54:31 <nerium> Why is that? I tried using "return", but that didn't work
08:54:34 <bergmark> mjrosenb: it took longer than usual... i did it in a clean sandbox
08:54:54 <opqdonut> ruler501: see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html
08:55:01 <bergmark> mjrosenb: this is the first time i've had to increase the backjump limit with --reorder-goals
08:55:01 <mjrosenb> bergmark: I just made this sandbox
08:55:10 <mjrosenb> bergmark: and it has been running for 14 minutes now.
08:55:23 <bergmark> mjrosenb: it probably took me a minute
08:55:55 <mjrosenb> assuming that all I need to do is cabal sandbox init; cabal install reactive --reorder-goals --max-backjumps=1
08:56:16 <ruler501> opqdonut: I run it with +RTS -N8 and it only uses 102% of processor time same with -N2
08:56:42 <bergmark> mjrosenb: yeah that's all i did
08:57:49 <mjrosenb> bergmark: can you give me the list of versions/packages it ended up installing?
08:57:59 <mjrosenb> that should make this trivial for me :-p
08:58:07 <ruler501> opqdonut: it appears that the lower the Q I give it the more it runs in parallel any way to fix this  that you see?
08:59:07 <mniip> [19:49:20] <Big_G> opqdonut, Not really but I can make one. Let's say you loop through each element of [1..]. That loop will never terminate and I as a human can see that.
08:59:12 <mniip> as a human, can you tell me
08:59:24 <mniip> let x = if isFinite x then repeat () else [] in isFinite x
09:00:16 <Big_G> mniip, Good point. I guess I was trying to make it a lot simpler than it should have been
09:00:26 <haasn> takeWhile (unprovedHypothesis) [1..]
09:00:36 <bergmark> mjrosenb: oh, it actually installed an old version of reactive, 0.5.0.1
09:00:52 <mjrosenb> bergmark: hahaha, great.
09:00:54 <haasn> Does this ever stop? If you can figure it out, you've proved a hypothesis! \o/
09:01:22 <chpatrick> why can't we just have BPP and make a VintagePrelude for beginners and people with 1m loc?
09:01:37 <johnw> chpatrick++
09:01:44 <chpatrick> or better yet NoobPrelude and EnterprisePrelude
09:01:44 <johnw> chpatrick: fill out the survey
09:01:44 <Big_G> haasn, Yeah, I forgot about the halting problem
09:01:47 <chpatrick> I have
09:01:49 <monochrom> mniip: that is not a perfect diagonalization argument because until we see the code for isFinite, no one is obliged to answer that question. what you need is this: can a human tell whether themself is sane?
09:01:53 <mjrosenb> bergmark: yup, reactive-0.5.0.1 installed just fine
09:02:06 <MP2E> I filled out the survey in favor of FTP/BBP. To a more generalized Prelude!
09:02:14 * mjrosenb is amused that the 'newer' version of it from several years ago doesn't install.
09:02:26 <bergmark> mjrosenb: seems to find an install plan for the newest one too though, testing it
09:02:27 <mniip> monochrom, Big_G implied that he has an implementation of isFinite in his mind
09:03:01 <wacco> hi!
09:03:14 <Hijiri> HaskellEE
09:03:18 <Big_G> monochrom, I lost that battle long ago
09:03:41 <chpatrick> simon still works for microsoft right? HaskellProfessionalCloudEditionProPlus
09:03:50 <chpatrick> MilleniumEdition
09:04:04 <chpatrick> '15
09:04:17 <hiptobecubic> i thought facebook?
09:04:22 <chpatrick> peyton jones
09:04:26 <hiptobecubic> Or is that the other simon
09:04:37 <bergmark> mjrosenb: http://lpaste.net/120276
09:04:59 <opqdonut> ruler501: right the problem is probably that the "last" generateRationals dominates the runtime
09:05:24 <bergmark> mjrosenb: but category-extras failed to build
09:05:32 <zipper> Could i have an example of the way to write tests using detailed-0.9 instead of exitcode-stdio-1.0. The one in the cabal docs is really vague. It would help if you used Tasty as the test framework.
09:05:36 <mjrosenb> bergmark: is 0.11.5 the newest?
09:06:07 <opqdonut> ruler501: you could try parallelising at the generateRationals level
09:06:08 <wacco2> I have no idea what I'm doingg
09:06:26 <wacco> ok wicket. stuff works.
09:06:49 <hiptobecubic> The "noobs don't understand generalized functions" argument never made sense to me. I feel like *every single time* I get far enough along to show someone 'fmap' they immediately ask what the point of 'map' was.
09:06:55 <mjrosenb> bergmark: yup, I can confirm that category-extras fails to build
09:06:59 <opqdonut> ruler501: e.g. parMap testCantor and then count the Trues
09:06:59 <wacco> can't get irssi to compile, but can get the irc bot tutorial going online
09:07:15 * mjrosenb wonders if there is a simple change to the cabal file to fix this
09:07:58 <wacco> this warrants a screenshot tho
09:08:39 <bergmark> mjrosenb: probably your best bet is to try to use the latest version of all dependencies (--allow-newer)
09:09:06 <monochrom> hiptobecubic: can you reliably skip map and go straight to fmap? I think not. Piaget's theory: concrete before abstract, specific before general. if there were no map, there would be no concrete examples to learn and prepare for fmap.
09:09:34 <mjrosenb> bergmark: but cabal doesn't finish with just the first two options, will a third really fix that?
09:10:08 <hiptobecubic> Just say that the tool for mapping over lists is 'fmap'. We don't introduce addition with `integerPlus`.
09:10:24 <kadoban> monochrom: Does the concrete have to have a different name though? The Functor instance for [] still exists either way.
09:10:24 <monochrom> it is similar to: every single time you get far enough to teach abstract Peano numbers, what was the point of counting apples in kindergarten again?
09:10:35 <ski> hiptobecubic : the question is whether they'd understand `fmap' without first having seen `map'
09:10:56 <chpatrick> I don't think it makes sense to degrade a language to make it a bit easier
09:10:59 <hiptobecubic> ski, so call it 'listmap'
09:11:00 <MonrealRyan> hello there... Can i ask if there's anyone uses FPComplete IDE?
09:11:07 <chpatrick> Num a => a is something you want as a developer but is confusing if you're totally new
09:11:16 <ski> kadoban : it could perhaps help if one could reexport an operation with a more restricted type signature
09:11:25 <bergmark> mjrosenb: probably, it removes the need for backtracking since it can pick the latest of everything
09:11:59 <monochrom> it needs a different name and a specific type so you don't have to talk about the generalization first
09:12:12 <hiptobecubic> There are a lot of things to get used to in Haskell, if polymorphism blows your mind you probably shouldn't be worrying about higher order functions at all yet
09:12:16 <chpatrick> there's no obstacle in making a specialized prelude for people who don't understand haskell that well yet
09:12:29 <mniip> "We don't introduce addition with `integerPlus`."
09:12:31 <chpatrick> and everyone else can use the real one
09:12:33 <mniip> b-but +#
09:13:04 <enthropy> ocaml does that
09:13:23 <Welkin> there is classyPrelude
09:13:34 <monochrom> actually I want to introduce addition with `integerPlus`. in the past, I told white lies to work around that.
09:13:50 <wacco> http://i.imgur.com/U2DwmEV.jpg
09:13:59 <EvanR> ocamlPlus
09:14:01 <mniip> monochrom, there is a sort of integerPlus but uh
09:14:26 <hiptobecubic> I've had plenty of success just saying "lists are things we can map functions over. The function for mapping functions over stuff is fmap"
09:14:29 <ski> monochrom : the concept of language levels in Racket is interesting
09:14:30 <Welkin> OcamlPlusPlus
09:14:38 <hiptobecubic> "+ is for adding things that can be added"
09:15:17 <MonrealRyan> hello there... Can i ask if there's anyone uses FPComplete IDE?
09:15:35 <EvanR> <> is for ?ing things that can be ?ed
09:15:39 <conal> hiptobecubic: reminds me of the classic book "A Hole is to Dig".
09:16:02 <hiptobecubic> When someone gets confused and says "Woah woah woah... 'things that can be added!?' Other than integers!?" I'll stop. Until then I don't see why an extra layer of wrong explanation should be put in the middle.
09:16:04 <Welkin> mappending
09:16:18 <EvanR> lie to children
09:16:23 <Welkin> I would say "combined" instead of added
09:16:25 <Welkin> for a monoid
09:16:29 <hiptobecubic> conal, haven't read it, but i like the title :)
09:16:36 <Welkin> actually, start with a semigroup
09:16:44 <conal> hiptobecubic: it's delightful!
09:16:58 <EvanR> Welkin: right but the actual name of the class isnt even an issue yet
09:17:13 <EvanR> hiptobecubic's examples have avoided naming any classes
09:17:29 <Welkin> you can exaplin a semigroup/monoid without mentioning the name
09:17:31 <EvanR> things that can be mapped
09:17:32 <Welkin> it is a simple concept
09:17:37 <EvanR> things that can be combined...
09:17:51 <dhrosa> Welkin: think of the children1
09:17:52 <dhrosa> !
09:17:55 <Welkin> things that have a rule for being combined
09:18:00 <MP2E> things that can be combined associately, and have a concept of nothing
09:18:02 <EvanR> things that can be thinged
09:18:03 <hiptobecubic> conal, it looks great :)  I'm a big fan of sendak as well
09:18:05 <MP2E> associatively*
09:18:15 <conal> hiptobecubic: :) !
09:22:30 <ski> Welkin : a monoid is where you can combine a finite sequence of things to a single thing, satisfying associativity (and identity-on-singleton, or what you want to call it)
09:23:29 <ski>   combine :: [Thing] -> Thing  -- defined for finite lists
09:23:54 <dhrosa> couldn't you do Traversable t => t Thing -> t?
09:24:12 <dhrosa> wee
09:24:16 <dhrosa> err, thing at the end*
09:24:18 <EvanR> foldMap
09:24:23 <Welkin> traversable only traverses the structure but leaves it unchanged
09:24:30 <Welkin> foldable traverses and modifies the structure
09:24:32 <dhrosa> oh
09:25:46 <ski> dhrosa : i suppose you could, but then you'd probably need more laws (not sure), to avoid using the extra information
09:26:17 <dhrosa> having a foldable is less information, not more :)
09:26:56 <ski> oh, i suppose you meant `forall t.' there, then
09:28:17 <ski>   combine [combine [a0,...,alast],...,combine [z0,...,zlast]]  =  combine [a0,...,alast,...,z0,...,zlast]  -- associativity
09:28:38 <ski>   combine [a]  =  a  -- the "identity-on-singleton" law i mentioned
09:29:09 <Big_G> Is there a way to make sure that all inputs to your function have a corresponding pattern match?
09:29:48 <Welkin> Big_G: the compiler will warn you
09:29:55 <Welkin> compile using cabal
09:30:01 <Welkin> or use the flag -Wall
09:30:11 <Big_G> Welkin, Is cabal the only one that does that?
09:30:24 <ski> dhrosa : hmm .. a monoid is only supposed to require finite sequence combinations. i'm thinking such a `Traversable' might also require working for infinite things (assuming one can make a valid instance for it)
09:30:39 <Welkin> Big_G: cabal just adds the compiler flags automatically
09:30:55 <Welkin> as far as I know
09:31:14 <ski> exercise : reformulate the two laws above in a pointless way
09:31:31 <ski> (you may define `singleton a = [a]', if you want to)
09:31:36 <Big_G> Welkin, Thanks. Do you know how it does that?
09:32:25 <monochrom> hiptobecubic: my students (other courses, not a Haskell course) already know how to work at the handwaving level of "things that can be added". namely, they work at the level of "things that are empty". therefore, they are unable to distinguish the following three things: 0, the empty set, the empty string. they are incapable of grasping {0}, {{}}, { empty_string }. this is why we need to give explicit, different types to 0, the empty set, and the empt
09:32:25 <monochrom> y string.
09:32:27 <mniip> uhhh, it looks like I have multiple versions of a package, how do I fix this?
09:32:49 <ski> next exercise : if you squint enough, can you recognize some other math concept in the (pointless) laws
09:33:26 <EvanR> mniip: you can remove them with ghc-pkg unregister
09:33:39 <mniip> it says it would break some packages
09:33:48 <monochrom> then remove them, too
09:34:09 <mniip> I don't think removing ghc is a good idea
09:34:47 <bergmark> mniip: that does sound like a bad idea
09:34:49 <monochrom> remove only new versions, not old versions. then you will not be asked to remove ghc.
09:34:53 <hiptobecubic> monochrom, I don't doubt your experience, but that seems pretty strange to me. People intuitively understand that things can be empty and not be the same thing regardless of programming background. The train is empty and the backpack is empty doesn't imply that the train and backpack are the same. I wonder why people mentally abandon that.
09:34:58 <dmwit> what if there is nothing to fix
09:35:14 <bergmark> mniip: also, is it actually a problem for you two have multiple versions?
09:35:27 <mniip> yes
09:35:49 <ski> hiptobecubic : "intuitively understand" is not the same as "explicitly understand"
09:35:51 <mniip> network depends on the old one whereas ghc imports the new one I think
09:36:13 <EvanR> hiptobecubic: maybe they are php and js refugees
09:36:37 <ski> and the presumably only understand it intuitively in familiar enough contexts
09:36:40 <ski> s/the/they/
09:38:27 <monochrom> hiptobecubic: I think it's because train vs backpack is tangible in real life, {} vs empty_string is theoretical imaginary stuff on paper. indeed, a Scheme program would use the same untyped nil for both. one cannot make such a slippery-slope mistake when typed.
09:39:46 <lpaste> breadmonster pasted ‚Äúminiparser‚Äù at http://lpaste.net/120290
09:40:00 <breadmonster> Guys, can anyone just eyeball my code and tell me if it's in good style?
09:40:10 <monochrom> people are quite rightly free to be imaginative when you talk about imaginative fictional (theoretical) things, limited by only the rules you yourself stated.
09:41:02 <monochrom> therefore, if your stated rule is at the level of "things that are empty", "things that can be added", they will exploit that freedom to its fullness.
09:41:06 <ski> (in Scheme, the false boolean value, the empty list, the empty string, are all distinct, neither of them is a symbol (such as the symbol `nil'))
09:41:30 <EvanR> common lisp
09:41:44 <breadmonster> Interestingly enough, it's also a Scheme parser.
09:42:27 <mniip> is there some function that makes a thread wait indefinitely
09:42:34 <mniip> like C pause
09:42:47 <johnw> you mean, wait until it receives a signal to wake it up?
09:42:55 <mniip> something like that yes
09:42:59 <Welkin> breadmonster: looks fine to me
09:43:02 <johnw> you'd block on an MVar, normally
09:43:14 <mniip> the runtime is too smart
09:43:14 <EvanR> dont threadDelay maxBound, this will cause an error on some systems
09:43:24 <breadmonster> Welkin: Thanks (:
09:43:47 <EvanR> mniip: if theres no way for anything to ever write to that mvar, the thread might as well not exist ;)
09:44:16 <ski> (iow, it could potentially be GCed)
09:44:30 <monochrom> it is more fruitful to ask: after wake-up, what will it do, and what will that depend on. then the code should simply block on what it depends on.
09:45:03 <mniip> Main.hs: thread blocked indefinitely in an MVar operation
09:45:26 <mniip> EvanR, this is supposed to be a stub
09:46:10 <monochrom> example. suppose you want thread X to wait for a signal, then print "hello!", then go back to waiting again, ad infinitum.
09:46:31 <EvanR> mniip: stubs often dont do anything
09:46:41 <mniip> I want to make the main thread wait indefinitely as a stub
09:46:52 <monochrom> so why don't you create an MVar, have thread X block on takeMVar, and every other thread who wants to wake up X do a putMVar?
09:47:12 <mniip> thread X?
09:47:14 <monochrom> in fact, why don't you simply have all other threads print "hello!" directly and skip thread X?
09:47:33 <mniip> "hello"?
09:47:33 <monochrom> X is a name for the thread so I can refer to it multiple times
09:47:34 <mniip> what
09:47:58 <monochrom> ok I will learn to never answer your questions agian.
09:48:04 <mniip> ...
09:48:23 <monochrom> yes, same sentiment here
09:48:24 <EvanR> oO mniip just pass that mvar to another thread
09:48:52 <EvanR> or if you never want to wake up, use a threadDelay loop
09:49:00 <ChristianS> what do people here think of the GHC 7.10 Foldable/Traversable Survey <http://goo.gl/forms/XP1W2JdfpX> ?
09:49:19 <mniip> isn't there anything that emulates a pause syscall?
09:49:29 <EvanR> threadDelay?
09:49:50 <mniip> that's a sleep/usleep/sertalrm
09:50:00 <geekosaur> yield?
09:50:15 <EvanR> you want to wait for a signal?
09:50:20 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Control-Concurrent.html#v:yield
09:50:27 <MP2E> ChristianS: fully in favor, I'm using GHC 7.10.1-RC2 as my main compiler for about a week now, and the new Prelude is nice. Library breakages are not as bad as they sound, either. Everything I've run in to has been trivial to fix
09:50:42 <MP2E> in favor of FTP/BBP getting in to Prelude*
09:50:53 <monochrom> what is BBP?
09:50:58 <EvanR> yield wont stop the main thread from ending
09:51:00 <MP2E> burning bridges propsal
09:51:04 <MP2E> FTP is the nicer name
09:51:08 <geekosaur> "burning bridges proposal" aka foldable/traversable in prelude
09:51:09 <monochrom> oh heh
09:51:22 <mniip> EvanR, why reinvent the wheel
09:51:43 <ChristianS> MP2E: interesting, i'm inclined to agree (but with less experience)
09:52:01 <mniip> I mean I'm fine with forever $ threadDelay 1000
09:52:02 <geekosaur> afaik there's nothing basic that will block for every other thread to complete, but async may have such a thing?
09:52:04 <mniip> but ugh
09:52:09 * hackagebot hindent 4.3.9 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.9 (ChrisDone)
09:52:22 <geekosaur> otherwise you get to implement yourself somehow
09:52:25 <EvanR> mniip: forever (threadDelay 100000)
09:52:26 <mniip> wait microseconds
09:52:30 <mniip> 100000- then
09:52:34 <mniip> 1000000
09:52:43 <EvanR> maxBound :: Int has trouble iirc
09:52:52 <Scheriderm> hi, why is my name in grey if i have alredy registered in freenode??
09:53:00 <EvanR> 2^24 to reduce cpu usage
09:53:06 <Welkin> Scheriderm: this is specific to your client
09:53:07 <MP2E> ChristianS: even if it gets voted no, it will just delay when FTP hits. It will probably end up landing in GHC 7.12.1 instead.. and I just don't see the sense in that. Why slow language growth arbitrarily? But really, you should read about the proposal on the GHC Wiki and look at the ghc-dev mailing list to form your own opinion :)
09:53:14 <mniip> Scheriderm, looks blue from here
09:53:16 <kadoban> Scheriderm: Ask your IRC client?
09:53:21 <jle`> it looks pink to me
09:53:26 <Scheriderm> jajaja thks
09:54:20 <ChristianS> MP2E: i just hope there will be a "haskell 2015 report" or something to prevent "report haskell" and "ghc haskell" from diverging...
09:55:01 <monochrom> ah, the Haskell Report is a good question
09:55:55 <geekosaur> they're already diverged (Num superclasses)
09:56:33 <hannes__> geekosaur: But that doesn't mean you can't converge them
09:56:40 <monochrom> well, I guess the Haskell 2015 Report can be simply the Haskell 2010 Report with the library part updated.
09:57:20 <hannes__> Although I guess it does feel kinda odd to have the haskell report just be documentation for what ghc does
09:57:26 <monochrom> (and the section on Num)
09:58:07 <glguy> It's pretty normal for implementation to lead ahead of the report
09:58:12 <monochrom> naw, libraries@haskell.org approved the Num change, and is now deliberating on the Prelude change. this is not GHC-only.
09:59:05 <monochrom> in fact SPJ dared put the Num change in GHC only after libraries@haskell.org agreed
09:59:57 <Scheriderm> other question, has anyone use Netwire ?? i don't undertand why exist the function clocksession  (from Control.Wire.Session.)
10:00:21 <monochrom> and he's now also asking, in good faith, should GHC 7.10 go ahead or retract with FTP? there is certainly a possible scenerio where we turn down FTP and so GHC won't do it. all is going to be well again
10:00:28 <Scheriderm> when should i need it instead clocksession_
10:03:00 <breadmonster> Okay, umm Haskell platform question.
10:03:12 <breadmonster> Can I remove the Haskell platform from my PC?
10:03:37 <breadmonster> Or rather, can I remove the ghc component of the platform, replace it with updated ghc, and still expect everything to work?
10:03:57 <zipper> breadmonster: Uninstall the haskell platform completely
10:04:05 <breadmonster> zipper: And then what?
10:04:11 <zipper> breadmonster: Then install GHC itself from your OS package manager.
10:04:27 <breadmonster> zipper: My OS package manager supports an outdated version of GHC.
10:04:34 <breadmonster> I just installed the latest version.
10:04:49 <zipper> breadmonster: Wait before uninstalling it might do you good to copy cabal to ~/.cabal/bin
10:05:05 <Welkin> breadmonster: install the latest Haskell Platform instead
10:05:06 <breadmonster> cabal?
10:05:20 <Welkin> you can't just update ghc and have everything work
10:05:23 <zipper> breadmonster: Yeah the cabal binary
10:05:29 <Welkin> each version of ghc relies on specific versions of libraries
10:05:37 <zipper> Welkin: The haskell platform doesn't work well for me.
10:05:40 <breadmonster> Okay, interesting.
10:05:47 <breadmonster> Welkin: I'll just update the Haskell platform.
10:05:52 <zipper> Okay I'll say what I do.
10:06:36 <zipper> I install only ghc from my package manager. I would compile it from source but my distro is always using new packages.
10:06:52 <dhrosa> what are finite structures that can be travsered but not folded?
10:06:53 <EvanR> compiling ghc would be a big deal
10:07:08 <zipper> EvanR: Would it? I didn't know.
10:07:21 <EvanR> yeah use a binary distro
10:07:42 <zipper> Anyway I install stuff in sandboxes. I don't like stuff from the haskell platform.
10:08:00 <zipper> It has stuff that will get you into cabal hell.
10:08:15 <dhrosa> i get cabal hell even in a sandbox
10:08:40 <breadmonster> What is cabal hell?
10:08:49 <enthropy> dhrosa: there's a foldMapDefault that says there aren't any
10:09:24 <dhrosa> enthropy: so the only traversable structures that aren't foldable are infinite ones?
10:09:42 <zipper> breadmonster: It's when you want to install a package but it depends on a package that conflicts with something you already have.
10:09:54 <breadmonster> Oh yeah, I've seen that :P
10:09:56 <zipper> breadmonster: It's an issue of versions.
10:10:08 <breadmonster> How do you deal with it?
10:10:12 <dhrosa> it's great when a package has two dependencies, and they each depend on a different version of a subdependency...
10:10:21 <dhrosa> then you can get into hell even in a sandbox
10:10:25 <breadmonster> I think installing leksah broke my cpphs :P
10:10:48 <zipper> breadmonster: So yeah which distro do you use? My solution is to use sandboxes.
10:11:01 <breadmonster> zipper: Ubuntu 14.04 LTS.
10:11:06 <breadmonster> I was thinking of moving to Fedora.
10:11:18 <breadmonster> Things are far more up to date.
10:11:27 <johnw> doesn't Traversable imply Foldable using foldMap f . runWriter . traverse (tell . (:[]))?
10:11:30 <breadmonster> But I'm really worried about losing non-free software that I use on a daily basis.
10:11:36 <enthropy> dhrosa: I don't get the infinite/non-infinite distinction here
10:11:47 <johnw> although, that does require termination
10:11:48 <zipper> breadmonster: Yeah fedora is rolling release. That would do you well. So yeah with sandboxes I never get issues or they're easier to deal with.
10:12:24 <dhrosa> enthropy: i'm asking if there's any distinction between foldable and traversable
10:12:31 <breadmonster> Except, I have no idea how to install fedora, is it as easy as Ubuntu?
10:12:35 <zipper> breadmonster: You can still install non free software on fedora but you have to tweak with your source list.
10:12:36 <dhrosa> enthropy: you're telling me there doesn't seem to be
10:12:42 <glguy> dhrosa:  some foldables aren't traversable
10:12:53 <dhrosa> like what?
10:12:56 <zipper> breadmonster: Let's go to PM this is offtopic.
10:12:56 <glguy> Set is one
10:13:02 <breadmonster> Sure.
10:14:44 <dhrosa> glguy: is it because during traversable, you might map two values in the input set to the same value in the output set, thus modifying the structure?
10:15:18 <dhrosa> traversal*
10:15:20 <glguy> or you might reorder them breaking the internal invariant that SEt has
10:15:31 <dhrosa> I see
10:15:59 <Welkin> Set is just a binary tree, though
10:16:01 <dhrosa> is Set weird because its structure depends on the values of the items in it?
10:16:14 <Welkin> binary search tree
10:16:28 <dhrosa> I mean, is this the reason Sets don't allow for a lot of things other containers do?
10:16:44 <Welkin> Set k is Map k ()
10:16:54 <osa1> wouldn't that be awesome if we could define lambdas using holes for arguments, like Clojure's % ?
10:17:05 <sdegutis> Is it true that the use of monads can replace exceptions for the vast majority of the application code that I write?
10:17:11 * hackagebot mp 0.1.3 - Music player for linux.  http://hackage.haskell.org/package/mp-0.1.3 (piotrborek)
10:17:13 <osa1> e.g. f a b %1 c %2 => \arg1 arg2 -> f a b arg1 c arg2
10:17:23 <Welkin> sdegutis: if you mean Either/Maybe, then yes
10:17:24 <dhrosa> sdegutis: yes
10:17:29 <sdegutis> great
10:17:31 <sdegutis> thanks
10:17:35 <dhrosa> sdegutis: using Either/Maybe, or MaybeT/EitherT transformers
10:17:45 <Welkin> exceptions shouldn't be used
10:17:56 <dhrosa> or perhaps other error-like monads that I can't remember
10:18:02 <hyPiRion> osa1: I feel the need for it every once in a while, but not that often really.
10:18:05 <hyPiRion> dhrosa: ExceptT
10:20:07 <osa1> hyPiRion: we surely use flip sometimes, right
10:20:36 <osa1> I sometimes think about "which argument do I really want to pass last" while defining functions
10:20:48 <osa1> I wouldn't be thinking that if we had %
10:22:39 <osa1> instead of writing this `(\sock -> hClose output >> close sock)` I could just write `(hClose output >> close %)`
10:23:22 <mseeks> someone mind helping me with To/FromJSON instances for a structure like `data S = S {a :: Int, b :: String}` which corresponds to a JSON value of `[{"a": 4}, {"b":"asdf"}]`?
10:25:33 <dhrosa> reminds me of scala's _
10:25:44 <dhrosa> except I think that had some strange scoping fun
10:31:07 <breadmonster> Welkin: Okay, slight issue.
10:31:19 <breadmonster> So I uninstalled haskell-platform and installed the binary.
10:31:27 <breadmonster> Now ghc is refusing to show up.
10:31:31 <breadmonster> as installed.
10:31:34 <breadmonster> Do you have any tips?
10:32:58 <geekosaur> define "show up as installed"
10:33:15 <geekosaur> if this is in the same shell and it's saying it can;t find the ghc program, then you may need: hash -r
10:33:29 <phaazon> @hoogle Bool -> a -> Maybe a
10:33:31 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
10:33:31 <lambdabot> Control.Exception assert :: Bool -> a -> a
10:33:31 <lambdabot> Control.OldException assert :: Bool -> a -> a
10:33:39 <phaazon> @hoogle a -> Bool -> Maybe a
10:33:40 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
10:33:40 <lambdabot> Control.Exception assert :: Bool -> a -> a
10:33:40 <lambdabot> Control.OldException assert :: Bool -> a -> a
10:33:57 <phaazon> hm
10:33:58 <Cale> :t \b x -> guard b >> return x
10:33:59 <lambdabot> MonadPlus m => Bool -> b -> m b
10:34:07 <phaazon> I thought such a function would exist
10:35:02 <benzrf> hi
10:35:07 <benzrf> when i use hdevtools installed from nix
10:35:12 <benzrf> it seems not to know about pakckages i've loaded
10:35:23 <hannes__> benzrf: from where?
10:35:35 <benzrf> also it complains about attempting to use a module which is not loaded
10:35:40 <benzrf> hannes__: also nix
10:38:13 <phaazon> :t bool
10:38:14 <lambdabot> a -> a -> Bool -> a
10:39:23 <mjrosenb> great, representable-functors isn't building because Data.Functor.Contravariant.Day doesn't exist.
10:40:21 <glguy> representable-functors is old tech, Deprecated in favor of adjunctions
10:41:03 <mjrosenb> glguy: yes, well, I'd like to build reactive, but have run into issues.
10:45:49 <breadmonster> geekosaur: Okay, thanks.
10:45:53 <breadmonster> I just reinstalled everything.
10:46:04 <breadmonster> Like copied a list of libraries that I needed and reinstalled.
10:47:11 <breadmonster> Also semigroupoids-4.2 has some warning about clashing with ghc 7.10, is that the latest package?
10:47:58 <mseeks> do Aeson (.:), (.=) bind weaker than (<*>), (<$>)?
10:48:02 <mseeks> couldn't find the infix declarations for them
10:48:08 <mseeks> sorry i meant stronger
10:48:40 <enthropy> the default fixity is infixl 9
10:49:36 <enthropy> ghci tells you fixity with :info, if there was one actually specified
10:50:05 <mseeks> cool, thanks
10:50:22 <sinelaw> why can't I derive Traversable when my type has a Set inside?
10:50:46 <sinelaw> oh wait, Set isn't a traversable
10:51:05 <sinelaw> O_o
10:51:22 <hannes__> sinelaw: I think we had the discussion on why that is just a bit earlier
10:51:35 <hannes__> :i Traversable
10:52:11 <sinelaw> It also isn't a Functor
10:52:19 <sinelaw> am I missing something?
10:52:32 <hannes__> sinelaw: Yes. The fact that it can't reasonably be
10:52:33 <Hijiri> fmap (f . g) might not equal fmap f . fmap g
10:53:01 <sinelaw> ah. yes.
10:53:09 <Hijiri> or was it that is required ord
10:53:38 <breadmonster> Is there a way I can get cabal to list all installed libraries?
10:53:44 <Hijiri> oh right, if g maps things to the same element then it's not preserving structure
10:53:45 <hannes__> Hijiri: I would have said that - I think Data.Set is just an ordered tree of soe description
10:53:49 <bergmark> breadmonster: not cabal, but ghc-pkg list
10:53:59 <breadmonster> bergmark: Does that come with ghc?
10:54:03 <bergmark> breadmonster: yes
10:54:08 <breadmonster> Awesome.
10:54:11 <bergmark> breadmonster: or in a sandbox, cabal sandbox hc-pkg list
10:54:16 <dcoutts> breadmonster: there's also cabal list --installed, but you probably want ghc-pkg list
10:54:23 <breadmonster> I'm not using a sandbox.
10:54:25 <breadmonster> But thanks ):
10:54:26 <breadmonster> (:
10:54:40 <breadmonster> Haven't figured out how those work yet.
10:54:45 <Hijiri> actually I'm not sure about the thing with fmap now, maybe it would work if it didn't require constraints
10:54:47 <hannes__> Hijiri: Yeah that too.
10:54:51 <{AS}> edwardk: Hi, I have a smaller question regarding Trifecta if you have a second
10:55:07 <breadmonster> I don't get what it means by compiling code when I cabal install something.
10:55:14 <breadmonster> Is it actually compiling something?
10:55:19 <sinelaw> breadmonster, yes.
10:55:24 <Welkin> breadmonster: it has to compile the libraries
10:55:26 <breadmonster> sinelaw: Wow it's really, really fast.
10:55:34 <sinelaw> breadmonster, no, it isn't
10:55:36 <breadmonster> Considering that ghc does so many optimizations.
10:55:42 <sinelaw> ghc is slow
10:55:43 <Hijiri> because if g maps things to the same elements, then f . g would do it similarly, even if f was injective, because g already mapped them to the same thing
10:55:50 <breadmonster> sinelaw: I've installed like fifty libraries in the past six minutes.
10:55:50 <Welkin> breadmonster: if you install yesod or hakyll it might take 30-45 minutes to compile/install everything
10:56:18 <breadmonster> Because I didn't have the Haskell platform, so I ran cabal install hindent parsec mtl
10:56:19 <Welkin> those frameworks are massive though
10:56:23 <sinelaw> Hijiri, I was just thinking that too. so why not again?
10:56:27 <sivteck> you can disable things (snap-server?) in hakyll to get it compiled fast.
10:56:28 <breadmonster> ...and it downloaded and installed like half a million libraries.
10:56:37 <Hijiri> sinelaw: what again?
10:56:43 <sinelaw> why not a functor
10:56:48 <{AS}> edwardk: If I use buildExpressionParser to build a table, but I have an unspecified binary operator not in the table. Would it be possible to print a nice error message instead of listing all the binary operators that could have been?
10:56:49 <Hijiri> because of Ord constraint
10:56:55 <Hijiri> on the elements
10:56:59 <breadmonster> Welkin: Though hxt is taking some time, I'm not sure what that is.
10:57:04 <{AS}> I am unsure where to put the error message specifically
10:57:07 <sinelaw> Hijiri, ah
10:57:08 <sinelaw> ok
10:57:22 <Hijiri> if we could magically tell when things are in a set like in math it would be functor
10:58:20 <EvanR> well list is a functor, does that mean we can magically tell when things are in a list? ;)
10:58:21 <sinelaw> this sucks, in an interesting way
10:58:29 <hannes__> Hijiri: Your earlier example actually also works. fmap f . fmap g != fmap (f . g) if f . g == id
10:58:45 <Welkin> != ?
10:58:51 <Welkin> don'y you mean /= ?
10:59:06 <hannes__> Welkin: That's not haskell anyway, so I don't see how it matters
10:59:08 <EvanR> but not <>
11:00:07 <wacco> awww yesss http://i.imgur.com/9ez5RFy.jpg
11:00:10 <hannes__> but ok let (!=) = (/=) in fmap f . fmap g != fmap (f . g) if f . g == id
11:00:14 <wacco> screw irssi
11:00:25 <Hijiri> hannes__: If g is not injective then f . g /= id
11:00:51 <hannes__> hannes__: hmm
11:00:56 <hannes__> Hijiri: hmm
11:01:02 <Clint> wacco: now make it pretty
11:01:06 <sinelaw> hmmm
11:01:11 <hannes__> true
11:01:26 <sinelaw> Hijiri, g can be injective and it will still be /=
11:01:26 <hannes__> Ord constraint point still stands tho
11:01:27 <wacco> Clint: I'm already glad I got rid of the raw irc messages :P
11:01:39 <wacco> missing tab completion on nicks tho, might be a priority
11:01:49 <Hijiri> sinelaw: g being injective is necessary but not sufficient for f . g == id
11:02:15 <sinelaw> bijective
11:02:19 <sinelaw> one-to-one
11:02:23 <sinelaw> whatever the correct term is.
11:02:27 <Hijiri> doesn't have to be bijective
11:02:30 <Hijiri> one-to-one is injective
11:02:47 <Hijiri> f has to be surjective though, and also respect g's lifestyle choices
11:02:55 <Hijiri> is if g(x) = y, f(y) = x
11:03:12 <Hijiri> but if g maps to a bigger space than x is in, it doesn't need to be bijective
11:03:18 <sinelaw> Hijiri, I see
11:03:19 <Hijiri> because f shrinks it back down
11:03:24 <hannes__> Basically, sets aren't functors in haskell because we don't implement sets based on lists
11:03:48 <hannes__> although thinking about it
11:03:50 <EvanR> but you couldnt really, anyway
11:03:59 <josephle> I'm pretty sure it doesn't matter what implementation Set has
11:04:02 <Hijiri> sets based on lists wouldn't work, since you could have multiples
11:04:04 <josephle> Set still isn't a functor
11:04:06 <sinelaw> but anyway, g could map to distinct values that "collapse" under the Ord instance
11:04:08 <Hijiri> you could have multiset based on list
11:04:28 <sinelaw> or whatever method you choose to decide if values are "the same" in a set
11:04:33 <hannes__> Hijiri: no they're right, multiset would still need Eq for bagging
11:04:52 <Hijiri> isn't bagging an implementation detail?
11:04:57 <sinelaw> so Set is fundamentally not a functor
11:05:02 <EvanR> again lists are functors and have all kinds of constraints depending on what you do with them
11:05:16 <Hijiri> sinelaw: If g collapses things, f . g collapses things too
11:05:24 <Hijiri> so fmap f . fmap g would still come out as fmap (f . g)
11:05:29 <hannes__> EvanR: But lists don't need to be able to tell their elements apart. Set implementations do.
11:05:37 <EvanR> hannes__: why?
11:05:44 <sinelaw> Hijiri, g could not collapse things, but they could still be "the same" in terms of the Ord / Eq instance for the target of g
11:05:53 <Hijiri> sinelaw: oh, right
11:06:08 <Scriptonaut> this is a bit of a stretch, but I was hoping someone here could help me understand the algorithm used in this tutorial. http://learnyouahaskell.com/functionally-solving-problems    I'm talking about the heathrow to london one (just ctrl-f if you want). To me it seems like his algorithm could possibly make up a shortest path, or it could be wrong about the shortest path, due to its greedy nature
11:06:09 <Hijiri> that would break things
11:06:10 <ski> Hijiri : "fmap (f . g) might not equal fmap f . fmap g" .. are you thinking of an `f' that doesn't respect `(==)' ? (which can be argued to be evil)
11:06:10 <sinelaw> so no implementation of Set would be a functor
11:06:22 <sinelaw> unless it had some magic notion of distinct values being always distinct
11:06:24 <Hijiri> ski: f that respects == ?
11:06:37 <Hijiri> also I noted that I was wrong
11:06:46 <hannes__> Hijiri: Presumably he means f x = f y if x == y
11:06:47 <Hijiri> and justified my claim that I was wrong about that
11:06:55 <EvanR> doesnt this all depend on what operations the set can do
11:07:17 <ski> Hijiri : `forall x,y. (x == y) = True => (f x == f y) = True'
11:07:24 <hannes__> EvanR: If you want to ask if some x is in the set then you need at least eq
11:07:34 <EvanR> hannes__: list does not have this problem
11:07:43 <EvanR> it uses a bool function instead
11:07:47 <Hijiri> well, f doesn't have to be injective for the law to work out
11:07:55 <Hijiri> so thinking about such functions wouldn't help me
11:08:11 <Hijiri> I said earlier that I was wrong and sets would be functors if not for implementation problems
11:08:21 <EvanR> hannes__: neither set nor list have any constraints on the data structure itself, just the operations
11:08:22 <hannes__> EvanR: But that would lead to consistency problems with sets. A set isn't a set without a consistent notion of equality
11:08:35 <sinelaw> Hijiri, but you also agreed that 'g' could map to distinct values that happen to be the same under Eq / Ord
11:08:50 <EvanR> hannes__: equality between sets?
11:08:53 <Hijiri> yes, I did
11:08:58 <sinelaw> so fmap breaks
11:09:01 <hannes__> EvanR: equality between elements
11:09:08 <ski> sinelaw : imho, exporting operations that can tell the difference is evil
11:09:20 <Hijiri> but my earlier argument wasn't considering constraints or typeclasses
11:09:24 <benzrf> whats the best way to cryptographically generate some bytes of gibberish
11:09:27 <EvanR> hannes__: ah well, that definitely could be an assumption. its not for lists
11:09:28 <Hijiri> just what if you had a math set
11:09:35 <benzrf> for use as a cjdns password to be precise
11:09:52 <ski> (it like the Mercury design here better than the Haskell one)
11:09:57 <ski> (s/it like/i like/)
11:10:00 <hannes__> EvanR: A set isn't a set if there's no way to ask it if it contains some x
11:10:08 <sinelaw> ski, reference?
11:10:15 <hannes__> EvanR: And that requires equality of some description
11:10:20 <EvanR> hannes__: well depends on what kind of sets you are dealing with. but again, you can easily just use a bool function
11:10:43 <Hijiri> bool function seems fine to me
11:10:45 <hannes__> EvanR: Yeah, but then it becomes type Set a = (a -> Bool, [a])
11:10:52 <hannes__> EvanR: Yeah, but then it becomes type Set a = (a -> a -> Bool, [a])
11:10:56 <Hijiri> why do you need [a]
11:10:58 <EvanR> hannes__: no, why are you putting it in the data structure?
11:11:13 <EvanR> like oop
11:11:23 <Hijiri> a set is defined by what members it has, so a -> Bool is just a function that tells you if it's in the set
11:11:35 <hannes__> EvanR: Because the equality is a property of the set. It's not something separate
11:11:40 <sinelaw> I've seen implementations of set that are just that, without the list (there is no "map")
11:11:48 <EvanR> hannes__: were not talking about equality yet, just elementhood
11:12:08 <sinelaw> union = .
11:12:13 <hannes__> EvanR: Something that is a set constructed with equality functions of f isn't the same set with equality function g
11:12:14 <sinelaw> rer
11:12:27 <sinelaw> nope. union is &&
11:12:27 <Hijiri> why do we need equality functions
11:12:31 <hannes__> hannes__: So you're not talking about a set if you don't couple it with a notion of equality
11:12:33 <sinelaw> ||. darn it.
11:12:34 <Hijiri> we don't need equality functions
11:12:43 <EvanR> hannes__: you realize this is a debate over stylism
11:12:44 <Hijiri> sets are defined by memberhood, not equality
11:12:56 <sinelaw> I agree, membership
11:13:07 <sinelaw> equality is an implementation detail
11:13:08 <hannes__> Hijiri: how do you define membership without equality?
11:13:15 <sinelaw> hannes__,  a -> Bool
11:13:15 <Hijiri> have a function a -> Bool
11:13:19 <Hijiri> that tells you if it's in the set
11:13:31 <hannes__> Hijiri: that _is_ a set
11:13:37 <Hijiri> yes, it is
11:13:41 <EvanR> equality is a -> a -> Bool, not a -> Bool
11:14:12 <EvanR> bool predicate is a set in classical math
11:14:19 <sedcf> much of my mind is nonsense. strange thing to say no?
11:14:21 <hannes__> Hijiri: Ok then, write fmap for that.
11:14:28 <Hijiri> hannes__: you can't
11:14:34 <sedcf> haskell has worked it's magic on me
11:14:35 <hannes__> Hijiri: That's the point.
11:14:35 <sinelaw> type Set a = a -> Bool;  union s1 s2 = (s1 x) || (s2 x) ; member s = s ; ....
11:14:43 <Hijiri> hannes__: In math you could write fmap for it
11:14:47 <sinelaw> union s1 s2 x = ..
11:14:52 <Hijiri> it's still a set though
11:14:54 <sedcf> i've become posessed by the idea of ai. to fix me...
11:14:54 <Hijiri> just not a functor
11:15:01 <EvanR> Hijiri: hmm. how?
11:15:12 <sedcf> i require augumentation
11:15:23 <sinelaw> fmap = .
11:15:23 <Hijiri> EvanR: for all x in X, f(x) is in Y
11:15:24 <sinelaw> no?
11:15:40 <sinelaw> fmap f s = s . f
11:15:42 <sedcf> i require glasses to see, hearing aids to hear, and maybe just something help me think
11:15:54 <sedcf> should i take this somewhere else?
11:15:57 <glguy> sedcf: Yes please
11:16:02 <rom1504> but you can't loop through the value of that set sinelaw
11:16:03 <Hijiri> sinelaw: f would need to be (b -> a)
11:16:04 <sedcf> k sorry guys
11:16:06 <EvanR> Hijiri: ok but then its not implemented as a Bool function anymore
11:16:07 <sedcf> no one to talk to
11:16:07 <rom1504> *go
11:16:08 <ski> sinelaw : <https://www.mercurylang.org/information/doc-latest/mercury_ref/User_002ddefined-equality-and-comparison.html> -- this is related to how one can implement subtypes and quotient/factor types, via abstract type boundaries
11:16:08 <Hijiri> that is contravariant functor
11:16:19 <sinelaw> ski, thanks!
11:16:22 <Hijiri> EvanR: I said that you could write fmap in math
11:16:53 <EvanR> Hijiri: yes i think im challenging that, but its getting set theoretical
11:17:01 <ski> sinelaw : istr there was some Fergus Henderson post on one of the (Haskell, i think) mailing lists, on this topic, too, but i can't seem to find it atm :/
11:17:17 <Hijiri> EvanR: I guess it isn't a bool function anymore though
11:17:52 <sinelaw> rom1504, right, this kind of set is not enumerable
11:17:57 <Hijiri> although you could make a cheating bool function that wraps around the set
11:17:58 <EvanR> right, all of the things we were naming including bool functions are implementations of a set
11:18:12 <EvanR> rather than the ideal object, whatever that is
11:18:39 <sinelaw> EvanR, the bool function shows that sets don't need a notion of equality
11:18:53 <EvanR> equality?
11:18:56 <Hijiri> EvanR was arguing that you couldn't write an fmap for it
11:18:59 <Hijiri> I think
11:18:59 <sinelaw> between elements
11:19:05 <sinelaw> without which fmap can hold
11:19:08 <hannes__> Which doesn't answer the question of 'can set be a functor (in haskell)'. I assert not.
11:19:12 <EvanR> i was wondering how you justify that "some fmap exists" for "math sets"
11:19:44 <EvanR> hannes__: it cant
11:19:54 <drojas> is there any way to dispatch based on a variable number of arguments (without wrapping them in a list or array)?
11:19:56 <ahihi> http://hackage.haskell.org/package/set-monad
11:19:56 <Hijiri> sinelaw: if you are fmapping (a -> b), you'd need to somehow get b -> Bool with (a -> b) and (a -> Bool)
11:20:01 <ski> sinelaw : one relevant point here is that in Haskell, there's no formal connection between the function `(==)', and the notation `=' used in definitions, and also in semantics. (except maybe people would like to assert some such informal laws like `forall x,y. x == y = True => x = y' and `forall x,y. x == y == False => x =/= y' on `Eq', but that's presumably not well-accepted)
11:20:44 <EvanR> hannes__: not if you want to support certain performance implications of checking membership
11:20:52 <sinelaw> ski, that's a subtle point worth remembering
11:21:03 <Cale> ski: Well, we'd like to have forall x y. (x = y) => ((x == y) = True), but even that isn't the case :)
11:21:06 <hannes__> EvanR: I'm not talking about performance.
11:21:27 <EvanR> hannes__: well, a list would work then. it supports the member ship operation, its just slow
11:21:40 <sinelaw> Hijiri, that exactly sums it up
11:21:43 <Hijiri> EvanR: you can't check membership without equality if you use a list
11:21:46 <hannes__> EvanR: My intial point was that a list is not a set
11:21:49 <Cale> EvanR: Uh, are you asking about how the powerset functor works in the category of sets?
11:21:52 <sedcf> i've spent my whole life struggling and being stupid. and still i try. but all i get is scorn and derision. well fuck you all. goodbye
11:22:02 <EvanR> Cale: i might be
11:22:24 <hannes__> EvanR: A list + an equality function (supplied by Eq) is.
11:22:27 <ski> sinelaw : otoh, in Mercury, the `(=)/2', which you can define on your own for user-defined types is required to be the least equivalence relation. iow, you're not allowed to disclose implementation/representation detail that (=)/2 can't detect. (if you do => undefined behavior, more or less. the compiler is allowed to assume that you follow the rule here)
11:22:38 <EvanR> hannes__: seems orthogonal
11:22:42 <ski> Cale : yes, infinite data and such :)
11:22:50 <mniip> how would I go about connecting a socket to a given stringic host (either IP or domainname) and a numeric port
11:22:56 <mniip> getAddrInfo seems a bit complex to use
11:23:05 <EvanR> use the Network module, see function connect
11:23:07 <Hijiri> oh, I guess you could do lists as sets
11:23:10 <ski> sinelaw : "If equalitypred is not an equivalence relation, then the program is inconsistent: its declarative semantics contains a contradiction, because the additional axioms for the user-defined equality contradict the standard equality axioms. That implies that the implementation may compute any answer at all (see Semantics), i.e. the behaviour of the program is undefined."
11:23:14 <Hijiri> just you wouldn't be able to check membership
11:23:16 <hannes__> EvanR: How is a list by itself a set?
11:23:33 <Hijiri> hannes__: you can put stuff in, you just can't test what's in there
11:23:37 <Hijiri> but that doesn't mean nothing's in there
11:23:45 <sinelaw> ski, is there any way for the compiler to see you're doing that?
11:23:45 <Cale> EvanR: So, given some f: A -> B, we can turn it into Pf: PA -> PB where for each S in PA, we have (Pf)(S) = {b in B : b = f(a) for some a in S}, i.e. the image of the set S under f.
11:23:48 <sinelaw> by mistake, for example.
11:23:49 <EvanR> hannes__: not by itself, by itself nothing is anything. you have to have operations, and for the sake of argument we will have one operation, membership testing
11:24:14 <EvanR> a bool function
11:24:16 <hannes__> EvanR: How do you have membership testing (for a list) without equality?
11:24:23 <ski> sinelaw : see you're doing what ?
11:24:45 <sinelaw> ski, defining your = in an inconsistent way
11:24:52 <Hijiri> you can have a set without operations
11:25:06 <Hijiri> there's the membership function, you just don't know what it is
11:25:24 <phaul> not very useful then :)
11:25:25 <EvanR> Hijiri: uh... a tree falls in the woods?
11:25:30 <sinelaw> Hijiri, as you said, that alone is not enough to implement fmap
11:25:33 <darkroom> does anyone know why there is no instance of arrow choice for yampa signal functions?
11:25:35 <ski> sinelaw : not in general i think (though the compiler is allowed to abort if it detects any such). it is to be treated as a "promise" operation, with a proof obligation on the programmer
11:25:39 <hannes__> Hijiri: If you just have a list there's not 'a' membership function
11:25:58 <hannes__> Hijiri: There's as many membership functions as there are equality functions
11:26:02 <Cale> EvanR: To check that this is a functor, we have to see that P(id_X) = id_(PX), and that P(g . f) = Pg . Pf
11:26:07 <EvanR> hannes__: choose one possible bool function as "THE" membership test, now?
11:26:23 <hannes__> EvanR: Yes. Glad we finally agree
11:26:33 <sinelaw> ski, I assumed so - I guess Haskell with the implicitly assumed typeclass laws is not much better
11:26:46 <EvanR> Cale: alright
11:27:02 <EvanR> hannes__: and.. throw map in
11:27:18 <hannes__> EvanR: Now your membership test doesn't work anymore
11:27:26 <EvanR> Cale: and this is all justified in whatever background set theory?
11:27:29 <EvanR> hannes__: why?
11:27:41 <hannes__> EvanR: Because it worked on a's, not b's.
11:27:49 <hannes__> EvanR: and map can't translate.
11:27:50 <EvanR> use "THE" membership bool test for b
11:27:51 <hannes__> it
11:27:53 <Cale> EvanR: yeah.
11:27:56 <Hijiri> you need a new equality function for b
11:27:57 <ski> sinelaw : if we declare `newtype Abstract = Wrap Representation', then `Wrap' is in itself an injective function. with the corresponding Mercury definition, with an added user-defined equality, the data constructor is no longer injective (and the system checks this, so that pattern-matching isn't (conceptually) guaranteed to yield a determinate result)
11:28:06 <Hijiri> which you need to construct somehow
11:28:37 <EvanR> Cale: ok, and its a functor. end of ;)
11:29:17 <ski> sinelaw : so, to be able to build any deterministic operation on such pattern-matching, you must at some point use a `promise_equivalent_solutions' construct to assert that you claim that at a certain point in the program, you can no longer tell the difference between different representations of the same abstract ideal value
11:29:18 <EvanR> Hijiri: bool test
11:29:22 <hannes__> EvanR: So you're saying... sets are functors if there's exactly one unique representation of equality for all types?
11:29:28 <Hijiri> EvanR: how do you get that bool test
11:29:30 --- mode: ChanServ set +o monochrom
11:29:44 --- mode: monochrom set +b *!*@146-193.dsl.iskon.hr
11:29:44 --- kick: domepro was kicked by monochrom (domepro)
11:29:44 <EvanR> i was just saying that we were only dealing in bool tests
11:29:59 <sdegutis> Do some of you hate Bool?
11:30:03 <ski> sinelaw : so, e.g. if you implement rationals (without normalizing), you'd need to use `promise_equivalent_solutions' on (=)/2,(+)/2,(*)/2 and so on ..
11:30:06 <Hijiri> I have a -> a -> Bool, and a -> b, how would we get b -> b -> Bool?
11:30:14 <ski> @where boolean-blindness
11:30:14 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
11:30:23 --- mode: monochrom set -o monochrom
11:30:57 <Cale> It's arguable that sets in set theory are closer in nature to the type (a -> Bool) than they are to (Set a)
11:31:09 <sedcf> i'm sorry to continue my tirade. i won't do it this time, make another of my embarrassing suicide attempts that are nothing more than some kind of grief
11:31:18 <EvanR> Hijiri: for the sake of the earlier argument, we started with a and picked one special Bool function from all possibilities before hannes__ agreed to call it a set, so the assumption is thats possible, so just do the same thing for b. but then i guess the functor law is messed up in the process
11:31:19 <sedcf> but i will tell you i hate you all
11:31:23 <sedcf> go ahead ban me
11:31:29 <Cale> sedcf: Why do you hate us?
11:31:31 <sedcf> i can't take being me anymore
11:31:36 <sedcf> i belong nowhere
11:31:38 <sinelaw> turing test?
11:31:40 --- mode: ChanServ set +o monochrom
11:31:43 --- mode: monochrom set +b *!*@S0106306023d60d12.lb.shawcable.net
11:31:44 --- kick: sedcf was kicked by monochrom (sedcf)
11:31:45 <Hijiri> EvanR: you need your fmap to mechanize finding the new boolean test
11:31:52 <Hijiri> if you want to implement this
11:32:00 <monochrom> I declare that I am not responsible for their suicide.
11:32:14 <sinelaw> monochrom, all 26 of them
11:32:15 <EvanR> you have to call that before kicking
11:32:33 <Cale> #suicide-soapbox
11:32:49 <monochrom> no, I am only responsible for telling you, not telling them.
11:32:54 <ski> Cale : ZF sets ?
11:33:00 <EvanR> Hijiri: well im lost at this point in the goal post forest so ill drop it ;)
11:33:01 <Cale> ski: Yeah
11:33:14 <Hijiri> I thought we were talking about things we could write
11:33:32 <sinelaw> we could do it by construction
11:33:40 <Hijiri> in haskell?
11:33:41 <EvanR> theres a lot of arbitrary requirements going around
11:33:46 <sinelaw> singleton x = const True
11:33:49 <sinelaw> oops.
11:34:09 <Cale> ski: Though I guess that doesn't help at all :)
11:34:11 <sinelaw> that's not what I meant.
11:34:14 <Hijiri> I thought the requirement is that you need to be able to write fmap
11:34:24 <Cale> ski: Because a -> Bool isn't easy to write a Functor instance for either.
11:34:30 <hannes__> And it also should be a set.
11:34:45 <EvanR> Hijiri: for a data type that supports membership test, or is it equality between elements? or that it doesnt reduce in size or
11:34:59 <EvanR> that we can
11:35:01 <Hijiri> I can't see how fmap would be written for either
11:35:05 <EvanR> know what the test is or not
11:35:15 <ski> Cale : i suppose that's what replacement is for
11:35:24 <EvanR> the biggest one here is "that its a set"
11:35:29 <EvanR> so im just annoyed
11:36:08 <Hijiri> well a membership test is enough for a set, I'm not disputing that
11:36:15 <sinelaw> I guess the question could be "what's a small interface commonly accepted to represent a Set, and is it a Functor?"
11:37:10 <hannes__> Anything that allows us to construct a function a -> Bool is a set of a, I thought we all agreed on that
11:37:18 <EvanR> so something that satisfies the membership testing, and can compute a new test for a new type, and that is satisfies the functor laws
11:37:24 <sinelaw> hannes__, to construct it from what?
11:37:26 <Hijiri> yes
11:37:46 <Hijiri> the compute a new test is what I'm having trouble seeing
11:38:11 <sinelaw> hannes__, can I add a value to the set?
11:38:21 <EvanR> const True and const False are always available but they dont satisfy the functor laws
11:38:24 <sinelaw> if so, I already need equality
11:38:37 <EvanR> unless the set always has all things in the set
11:38:43 <EvanR> or is always empty
11:38:48 <sinelaw> EvanR, right
11:38:50 <EvanR> since we didnt add the ability to insert anything
11:39:05 <Hijiri> insertion would require Eq, probably
11:39:05 <sinelaw> so the always empty and full sets are trivial sets that are also functors.
11:39:16 <EvanR> insertion doesnt require eq for lists
11:39:29 <sinelaw> insertion in a way that alters the membership function does
11:39:38 <Hijiri> I meant for just a -> Bool
11:39:58 <Hijiri> also, full set wouldn't necessarily work that way
11:40:04 <sinelaw> the always full set could work
11:40:06 <Hijiri> for example, if I wanted to map (const 1)
11:40:10 <sinelaw> insert anything and it's still always full
11:40:25 <Hijiri> oh, just insertion
11:40:43 <sinelaw> Hijiri, the fmap law would  hold.
11:40:46 <EvanR> Hijiri: well i dont see internal duplicates as automatically making something not a set, thats implementation stuff, and brings discussion basically back to Data.Set
11:41:00 <wacco> quick question; what's the identity function of foldl?
11:41:05 <Hijiri> if you map const 1, then not everything is in the set anymore
11:41:12 <Hijiri> for example, 2
11:41:12 <sinelaw> Hijiri, why not?
11:41:26 <sinelaw> fmap laws don't say I need to actually do anything
11:41:37 <Hijiri> I thought we were still talking about sets
11:41:39 <sinelaw> map const 1, and still be always full
11:41:59 <Hijiri> it's not really mapping in the sense of mapping sets, if we're talking about it like this
11:42:05 <sinelaw> a very useless set, for sure
11:42:16 <EvanR> a set of all the 1s in the universe
11:42:17 <hannes__> sinelaw: It's also just 2 sets you can model that way
11:42:29 <wacco> wikibooks gives the id of foldr with "you should start keeping an eye out for these things!" and continues talking about foldl.. without telling hoe to figure out its identity -__-
11:42:38 <sinelaw> hannes__, why 2? the empty set doesn't work, you need insertion
11:42:49 <hannes__> sinelaw: for fmap?
11:43:00 <Hijiri> you could fmap the empty set
11:43:05 <sinelaw> hannes__, arbitrarily for calling it a set at all
11:43:05 <Hijiri> because there is nothing to map
11:43:24 <hannes__> sinelaw: Oh did we say you need insert now? I think membership is enough.
11:43:28 <Hijiri> I don't see why you need to insert into a set
11:43:31 <EvanR> this has the flavor of the circle ellipse problem
11:43:48 <sinelaw> oh well
11:43:50 <Hijiri> either way, "always full set" is a specific set, not a type
11:44:07 <Hijiri> so if I fmap it, there's no reason the result needs to be always full
11:44:14 <hannes__> it's also not a sets of a's
11:44:18 <sinelaw> Hijiri, it could be always full, for any a
11:44:33 <Hijiri> sinelaw: sure, but I could map a function that is not surjective
11:44:33 <sinelaw> Russel awakens
11:44:49 <sinelaw> it boils down to definitions
11:45:06 <monochrom> wacco: foldr for list has a nice generalization to other types. foldl doesn't enjoy quite the same status. foldl is somewhat less interesting, and is just as easy to spot without explicit advice to look for it.
11:45:06 <Hijiri> I'm assuming fmap f set means roughly
11:45:11 <sinelaw> what's the definition of 'map' for set, does it require 'insert', etc..
11:45:17 <Hijiri> If x is in the set, f(x) is in the new set
11:45:26 <Hijiri> (and only things of the form f(x))
11:45:36 <Hijiri> So if f is const 1, then the only thing in the new set is 1
11:46:39 <sinelaw> Hijiri, so: member . map f == member ?
11:46:53 <sinelaw> for any f
11:46:54 <Hijiri> not quite
11:47:14 <wacco> monochrom: I was totally expecting foldl (:) [] ["a", "b"] to work, but no. And now.. ehm.. no idea how to continue fiddling with it
11:47:17 --- mode: monochrom set -o monochrom
11:47:27 <Hijiri> is the right hand side the new member?
11:47:54 <sinelaw> Hijiri, the lhs is the new, the rhs is the old
11:48:06 <sinelaw> member :: a -> Bool
11:48:31 <monochrom> wacco: GHC 7.8 has "type holes". it means that if you enter "foldl _ [] ["a", "b"]", it can tell you what should be the type for the underscore position. you may get some inspiration from its answer.
11:48:36 <Hijiri> lhs should be member . f, I think
11:48:53 <sinelaw> map :: (a -> b) -> Set a -> Set b
11:49:12 <wacco> ooh nifty
11:49:28 <sinelaw> Set a = a -> Bool
11:49:36 <Hijiri> what's member?
11:49:42 <sinelaw> member = Set really
11:50:00 <Hijiri> map f takes a Set a
11:50:05 <Hijiri> member takes an a
11:50:13 <sinelaw> yes, I noticed. hmm
11:50:34 <EvanR> member . f = member
11:50:35 <sinelaw> member :: a -> Set a -> Bool
11:50:59 <sinelaw> EvanR, that also works, but then you have the same "member" value on both sides
11:51:10 <Hijiri> member on the left is the new member
11:51:11 <sinelaw> doesn't make much sense
11:51:19 <Hijiri> member' . f = member
11:51:25 <sinelaw> ok
11:51:25 <EvanR> sinelaw: yes thats what equality of functions means here?
11:51:34 <Hijiri> a -> Set a -> Bool is just function application backwards
11:51:36 <EvanR> sinelaw: if you apply lhs or rhs to the same thing the result is the same
11:51:42 <sinelaw> right.
11:51:52 <EvanR> so makes sense
11:52:12 <Hijiri> don't think you could derive a implementable definition for this though
11:52:40 <ski> > foldl (flip (:)) [] ["a","b","c"]  -- wacco ?
11:52:41 <lambdabot>  ["c","b","a"]
11:52:50 <sinelaw> anyhow, so sets cannot be functors in haskell, and generally, i'm not sure.
11:53:47 <vlkm> Hi, anyone from Czech Rep. here interested in meetup(s) learning Haskell together in the following year? I'm going to invest lot of time and wanted some friends on the journey.
11:53:53 <wacco> ski: that makes sense from the -what's it called, type signature?- (b -> a -> b) instead of foldr's
11:54:16 <ski> wacco : yes
11:54:37 <ski> > foldr f z [a,b,c,d]
11:54:37 <wacco> with the hole suggestion I kinda expected (++) to work now. but nope. is (flip (:)) really the answer? that's.. anticlimatic
11:54:38 <lambdabot>  f a (f b (f c (f d z)))
11:54:39 <ski> > foldl f z [a,b,c,d]
11:54:40 <lambdabot>  f (f (f (f z a) b) c) d
11:55:07 <monochrom> (++) works too. just does a different thing.
11:55:18 <wacco> I know it works :P
11:55:22 <ski> wacco : so for `foldr's function argument, the element comes as the first/left argument, while for `foldl's function argument, the element comes as the second/right argument
11:55:33 <wacco> I just tried it, but didn't get the expected answer (i.e. the identity)
11:55:42 <wacco> right
11:55:44 <wacco> any reason?
11:55:46 <ski> wacco : answer to which question ?
11:55:49 * sinelaw climbs back into his type checker
11:56:05 <EvanR> 1.21 JW
11:56:11 <ski> > foldr (+) z [a,b,c,d]
11:56:12 <ski> > foldl (**) z [a,b,c,d]
11:56:13 <lambdabot>  a + (b + (c + (d + z)))
11:56:13 <wacco> ski: wikibooks tutorial suggests you start looking for identity functions *right before* it starts talking about foldl
11:56:13 <lambdabot>  (((z**a)**b)**c)**d
11:56:15 <sinelaw> EvanR, heh
11:56:42 <ski> wacco : `foldr' "associates to the right" the calls to the callback. `foldl' "associates to the left"
11:57:24 <wacco> I was just expecting something super-elegant-and-enlighting
11:57:51 <ski> if the given operation is associative, it doesn't matter which way you associate the brackets (except possibly for performance)
11:57:51 <wacco> oh well! onwards~!
11:57:55 <drojas> is there any way to dispatch based on a variable number of arguments (without wrapping them in a list or array)?
11:58:37 <ski> wacco : for `foldr', the other argument is commonly a *right* neutral element. for `foldl', a left
11:58:57 <hannes__> drojas: At runtime?
11:59:28 <drojas> hannes__: at any time :)
11:59:57 <ski> drojas : you don't commonly want to do that .. there are ways of getting the effect
12:00:10 <drojas> I want to dispatch different implementations depending on the type of a variable number of arguments
12:00:10 <monochrom> wacco: actually "foldl (flip (:)) []" doesn't behave like id either. you may have to "foldl (\x y -> x ++ [y]) []"
12:00:11 <ski> (also, every function takes exactly one argument, always, no exception)
12:00:21 <hannes__> drojas: Not dispatch per se, but you can simulate variable number of arguments at compile time
12:00:45 <hannes__> drojas: At runtime, well you can also put them in a set or a map if you prefer.
12:01:19 <wacco> reverse $ foldl (flip (:)) [] ["a", "b"]
12:01:21 <ski> > let x = 2 in printf "x = %d" x :: String
12:01:22 <lambdabot>  "x = 2"
12:02:03 <monochrom> yeah, or reverse
12:02:07 <hannes__> printf "%d = %d" 2 3 :: String
12:02:13 <hannes__> > printf "%d = %d" 2 3 :: String
12:02:15 <lambdabot>  "2 = 3"
12:03:00 <drojas> hannes__: I saw there is a way to do that at compile time but it's recursive. I want to dispatch different implementations depending on the type of a variable number of arguments. Ideally without putting them in a data structure as pointed by ski
12:03:05 <wacco> monochrom: was still playing with it, yes ;)
12:03:42 <EvanR> drojas: haskell just doesnt have that
12:04:31 <drojas> EvanR: what functional language would be good at that?
12:04:39 <EvanR> C++
12:05:35 <hannes__> drojas: D
12:07:13 <monochrom> I fail to see a difference between "dispatch at compile time" and "dispatch on type and number of arguments". since types and numbers of arguments are known at compile time, this is dispatch at compile time already.
12:07:17 <wacco> (never mind me just wondering what happens if I type PRIVMSG #haskell : here )
12:07:34 <monochrom> at any rate, Text.Printf already dispatches on both types and numbers of arguments.
12:07:48 <EvanR> wacco: your normal chats are already PRIVMSG
12:08:18 <drojas> EvanR, hannes__: thanks
12:08:29 <monochrom> "PRIVMSG #haskell" is the implementation of speaking normally in #haskell
12:08:44 <wacco> EvanR: I wanted to ask that identity question somewhere this afternoon and realised I still hadn't installed an IRC client
12:08:59 <geekosaur> (dont try to understand the irc protocol. it is ancient and based loosely on something even more ancient and incomprehensible)
12:09:07 <wacco> so hacked something together, but it does `inInfixOf` & splitOn that string
12:09:24 <monochrom> naw, my conclusion is simply "don't trust meaningful names"
12:10:28 <sdegutis> My conclusion of Haskell: http://sdegutis.github.io/
12:10:51 <wacco> > printf "PRIVMSG #haskell :I will probably certainly not see this remainder"
12:10:52 <lambdabot>  No instance for (GHC.Show.Show a0)
12:10:52 <lambdabot>    arising from a use of ‚ÄòM417702072208087236018646.show_M4177020722080872360...
12:10:52 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
12:11:03 <wacco> okayy
12:11:11 <wacco> that. I didn't expect.
12:11:11 <monochrom> lambdabot doesn't do IO for you
12:11:24 <monochrom> but you can try: putStrLn "<IO>"
12:12:13 <wacco> I thought I saw hannes__ do it
12:12:14 <shachaf> GHC will kindly correct your kind error if you do that.
12:12:32 <Welkin> lambdabot only collects IOUs, but never executes them
12:12:47 <hannes__> > printf "PRIVMSG #haskell :I will probably certainly not see this remainder"
12:12:48 <lambdabot>  No instance for (GHC.Show.Show a0)
12:12:48 <lambdabot>    arising from a use of ‚ÄòM423902407735186001318697.show_M4239024077351860013...
12:12:48 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
12:12:49 <monochrom> oh oops, it's <IO ()>
12:12:52 <hannes__> > printf "PRIVMSG #haskell :I will probably certainly not see this remainder" :: String
12:12:53 <lambdabot>  "PRIVMSG #haskell :I will probably certainly not see this remainder"
12:13:10 <jedai> sdegutis: interesting :)
12:13:21 <jedai> sdegutis: did you try Yesod ?
12:13:30 <sdegutis> jedai: I don't like it.
12:13:43 <jedai> sdegutis: too much TH ?
12:13:52 <sdegutis> That's a big part of it yes.
12:13:54 <hannes__> wacco: the result of printf is polymorphic, you have to fix the type somehow,  like here with a type annotation
12:15:26 <Welkin> :t printf
12:15:27 <lambdabot> PrintfType r => String -> r
12:15:41 <Welkin> ah, the output type
12:16:16 <wacco> hannes__: did you just.. use earlier mentioned string or something?
12:16:56 <jedai> Welkin: it's a clever trick to get variable number of argument but it also means that printf can be used to produce a String or to print a String (IO ()
12:17:25 <Welkin> > let str = "green eggs" in printf "%s and ham" str
12:17:26 <lambdabot>  No instance for (GHC.Show.Show a0)
12:17:26 <lambdabot>    arising from a use of ‚ÄòM830531455152817343818832.show_M8305314551528173438...
12:17:26 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
12:17:41 <Welkin> > let str = ("green eggs" :: String) in printf "%s and ham" str
12:17:41 <jedai> > let str = "green eggs" in printf "%s and ham" str :: String
12:17:42 <lambdabot>  No instance for (GHC.Show.Show a0)
12:17:42 <lambdabot>    arising from a use of ‚ÄòM791099973445929709818844.show_M7910999734459297098...
12:17:42 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
12:17:42 <lambdabot>  can't find file: L.hs
12:17:51 <jedai> > let str = "green eggs" in (printf "%s and ham" str :: String)
12:17:52 <lambdabot>  "green eggs and ham"
12:18:18 <jedai> > let str = "green eggs" in (printf "%s and ham" str ::
12:18:19 <lambdabot>  <hint>:1:54:
12:18:19 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:20:00 <wacco> hannes__: http://i.imgur.com/uQK1E09.jpg I suspect you did.
12:20:27 <wacco> anyway, I gotta run an errand, back in a few
12:21:47 <phaul> sdegutis: good write up. keep at it as you go along :)
12:22:13 <sdegutis> phaul: well I don't really have any web app to write, in other words I don't have a use-case for Haskell
12:22:42 <sdegutis> phaul: I am only writing a single app right now, which is a budget app, and I'm using node-webkit (aka NW.js), livescript, reactjs, and preludels for that
12:22:47 <Welkin> I got tired of web apps
12:22:54 <phaul> I did a personal website as a hobby project
12:23:00 <sdegutis> I really wanted to use Haskell to write some desktop apps, but I can't find a good GUI for it.
12:23:03 <phaul> though it was in yesod
12:23:18 <jedai> sdegutis: There's a cool twist on this if you're interested in reactive and gui in Haskell, you can use threepenny to write your gui in html and css
12:23:19 <sdegutis> The only GUI toolkit I'm happy with these days is React.JS, which limits me to node-webkit
12:23:31 <sdegutis> jedai: I'm nervous about threepenny
12:23:33 <sdegutis> very nervous
12:23:37 <jedai> sdegutis: why ?
12:24:00 <Welkin> you can always just use the FFI to access the native GUI API of the OS
12:24:03 <jedai> sdegutis: it actually works pretty nicely, even on Windows (without a lot of C dependancies
12:24:08 <sdegutis> jedai: first of all I try to avoid using tools that aren't somewhat popular and clearly gaining traction, since they might not be around in a few short years
12:24:47 <jedai> sdegutis: Well if you're writing something serious you wish to maintain for a long time that may make sense
12:25:09 <sdegutis> jedai: right, and I'm no longer interested in writing any software that may not compile in 10 years
12:25:25 <sdegutis> jedai: also, the more a project gets popular and matures, the more alternatives to it come out which often "fix things" about the original, and then we have a better version of it, or at least the changes are merged back into the main project
12:25:37 <sdegutis> jedai: in other words, I'm worried threepenny is not actually the best we can do.
12:26:24 <jedai> sdegutis: assuredly, but I don't think anything in the reactive, functional gui field can really claim that currently...
12:26:26 <sdegutis> jedai: if it's truly a good idea, then there will be more community around it growing rapidly, and more people will help month after month to improve it and build/improve tooling around it and make it very easy to work with and possible build competitors that work much better, etc
12:26:32 <sdegutis> jedai: react.js can
12:26:34 <hannes__> sdegutis: Are you worried about something being optimally good or are you worried about still maintaining it in 10 years?
12:27:09 <steffen> I am confuesd: 'The name deepseq is used to illustrate the relationship to seq: where seq is shallow in the sense that it only evaluates the top level of its argument, deepseq traverses the entire data structure evaluating it completely.'. But in the docu of seq it says seq already evaluates to NF (Fully evaluated). How can NF be shallow? how what is the difference between seq and deepseq? Or what does it mean to 'evaluate only the top
12:27:09 <steffen> level'?
12:27:18 <hannes__> sdegutis: Because in the next 10 years, no matter what you're doing, there's probably going to be something new that does something better than what's around now
12:27:21 <sdegutis> hannes__: I only write software that I plan to use every day. Thus I want to make sure it compiles in 10 years if need be.
12:27:38 <jedai> steffen: no, seq only evaluates up to WHNF
12:27:51 <sdegutis> hannes__: true, but I do think we'll start to plateau on the ideal soon
12:28:38 <steffen> jedai: ahh your right, it says 'head normal form' which is similar to WHNF
12:30:38 * ski thinks `deepseq' isn't fully "deep" ..
12:32:37 <bennofs> ski: why not?
12:33:24 <ski> iirc, it doesn't try to apply functions to every conceivable argument, `deepseq'ing the results
12:33:46 <bennofs> ski: ah right, NF should go under lambdas too
12:34:23 <ski> interestingly, with staged computation, you can in some sense go under (quoted) lambdas
12:35:01 <steffen> There is a way in ghci to see how far something is evaluated! What was the command?
12:35:03 <ski> istr there was some paper that explained how to translate away (some notion of) staged computation into just lifting out the relevant computations outside the lambdas
12:35:37 <sdfbjk> what are the best practises for testing haskell code?
12:36:30 <S11001001> sdfbjk: https://github.com/joshcough/HaskellStarter/#tests
12:37:35 <ReinH> S11001001: doesn't mention tasty, hspec, or smallcheck :(
12:38:52 <sdfbjk> ReinH: are those better or something?
12:39:07 <S11001001> @tell ReinH not best practice to use every available test framework in your tests :)
12:39:07 <steffen> How can I see how far something is evaluated?
12:39:07 <lambdabot> Consider it noted.
12:39:12 <steffen> in ghci
12:39:23 <bennofs> steffen: :sprint iirc
12:39:40 <steffen> bennofs: thank you :)
12:40:15 <sdfbjk> is there a way to print a typeclass definition in ghci?
12:40:43 <bennofs> S11001001: test-framework is no longer actively maintained AFAIK and was replaced by tasty     (or hspec, but that is a little bit more different)
12:40:49 <bennofs> sdfbjk: ^^^
12:41:14 <myfreeweb> sdfbjk: hspec implements rspec's hipster style (describe/context/it) which might be what you want
12:42:00 <sdfbjk> mecalopolis: bennofs so should I use hspec along with hunit and quickcheck?
12:42:13 <S11001001> bennofs: that doesn't sound right; I'll stick with test-framework as long as edwardk does.
12:42:24 <raek> sdfbjk: :i
12:42:39 <sdfbjk> raek: that prints the instances of a type
12:42:46 <edwardk> tasty stepped up and said 'hey you should all be using me instead'.
12:42:57 <edwardk> test-framework has passed into maintainership by other hands
12:43:09 <S11001001> edwardk: yeah that's what I thought.
12:43:13 <raek> sdfbjk: do you mean the "class ..." part or the "instance ..." part?
12:43:19 <S11001001> bennofs: ^^
12:43:21 <sdfbjk> raek: class part
12:43:31 <bennofs> edwardk: ah, I only remember test-framework not building anymore. didn't know that got fixed
12:43:40 <bennofs> thanks for clearing that up
12:43:43 <edwardk> bos took over test-framework at some point because he was using it widely
12:43:53 <raek> ":i Functor" prints the class part for mee
12:44:15 <raek> as well as a list of the instances
12:44:27 <sdfbjk> oh right raek my bad
12:44:41 <sdfbjk> edwardk: so do you recommend  test-framework?
12:45:03 <myfreeweb> is there really no library on hackage that implements regex replacement (gsub) on top of pcre-light?
12:46:51 <steffen> Well, 'let p = SomeType (Just 'a') 5' then :sprint p => _ so far so good! But why does 'p `seq` ()' and then ':sprint p' => SomeType (Just 'a') 5 and not 'SomeType _ _' ?
12:47:23 <steffen> I would have thought WHNF is only up to the first constructor which is SomeType _ _
12:47:31 <monochrom> what is SomeType?
12:47:58 <steffen> data SomeType = SomeType (Maybe Char) Int
12:48:29 <steffen> ahh, so it would be a difference if dara SomeType a b = SomeType a b ?
12:49:28 <sdfbjk> S11001001: about testing... should i look at test-framework + hunit + quickcheck...?
12:49:33 <monochrom> I don't know yet. let me try.
12:49:44 <steffen> mhm no, the generic version fully evaluates even without seq
12:49:50 <sinelaw> is there a package for normalizing (DNF) boolean expressions?
12:50:00 <sinelaw> this one has appropriate types, but no algorithms: boolean-normal-forms
12:50:11 <myfreeweb> sdfbjk: depends on what style you prefer, if you like rspec, use hspec instead of test-framework + hunit
12:50:19 <S11001001> sdfbjk: "best practices" and "what you should do" are separate dimensions :)
12:50:39 <sdfbjk> -_-
12:50:56 <S11001001> sdfbjk: the page I linked gives you a pretty good superset of what you should use; pick what you like, what fits
12:51:28 <monochrom> oh, I think I recall that if you begin with literals like "p = SomeType (Just 'a') 5", sprint is very likely to be able to see through more than you expect. since the literals are already there, no real evaluation needed.
12:51:58 <sinelaw> ok, this one does it: http://hackage.haskell.org/package/hatt-1.5.0.3/docs/Data-Logic-Propositional-NormalForms.html
12:53:16 <S11001001> sdfbjk: I'd say, knowing nothing about your project, start with one, quickcheck, on top of test-framework.  You can just use the haskell-starter boilerplate to get going; that's what it's there for.  Then you can add on other test thingies later if you want to use them
12:53:22 <monochrom> in fact, on GHC 7.8, the output I get is "p = <Ghci1.S> (Just 'a') 5" right away, I didn't even seq. (I replaced SomeType by S.)
12:53:37 <sdfbjk> S11001001: ok thanks
12:53:44 <steffen> monochrom: Ahh okay
12:53:47 <monochrom> (I also wrote "data S = ..." right inside ghci, not in a file)
12:54:07 <steffen> monochrom: I see, I have to play a little bit more with it for a while :)
12:56:01 <monochrom> oh what fun. now I put "data S = ..." and also "q = S (Just 'b') 6" in a file. then load in ghci. :sprint q gets me "q = _" at first. after one seq, it's "q = S _ 6"
12:56:27 <monochrom> at this point I'll just say that if you have a literal to begin with, things can be a little bit inconsistent :)
12:57:32 <steffen> monochrom: I see :)
12:59:22 <scott> I've managed to get :sprint to print both "x = _ : _" and "x = : _ _"
12:59:54 <sdfbjk> what is QuickCheck vs QuickCheck2 ?
12:59:59 <monochrom> haha, that's a whole new dimension
13:03:23 <coltfred> How would I go about using foldMap to sum a list of [Map k Int]? I want to add the Maps by adding together the values at matching keys. Is there some specific newtype I should use to get the correct monoid instance?
13:03:44 <scott> "let x = cycle [undefined, 1]" with 1 seq gives the former and "let x = cycle [undefined]" with 1 seq gives the later
13:03:54 <scott> sprint sure is interesting
13:04:27 <Cale> coltfred: Does it have to be foldMap?
13:04:55 <Cale> coltfred: I think if your maps were Map k (Sum Int), then the existing Monoid instance would do
13:05:07 <coltfred> Cale: No, I basically have Map("a" -> 1, "b" -> 2) and I want to add that together with other maps summing the values at corresponding keys.
13:05:26 <Cale> coltfred: But since they're not, you might be better off just using foldl'
13:05:27 <coltfred> Cale: I'll try it
13:05:40 <coltfred> Cale: Ya, that's where I'm at I think.
13:06:10 <johnw> or getSum . foldMap Sum
13:06:19 <Cale> foldl' (M.unionWith (+)) (M.empty)
13:06:33 <johnw> oh, right, two maps
13:06:46 <hannes__> Cale: No it wouldn't. The standard monoid instance for map simply overrides with a left bias
13:07:03 <Cale> hannes__: oh, it's not a lifting instance, okay
13:07:09 <Cale> That's a bit sad...
13:07:14 <Cale> But understandable
13:07:22 * hackagebot remote-debugger 0.2.1 - Interface to ghci debugger  http://hackage.haskell.org/package/remote-debugger-0.2.1 (atsky)
13:07:23 <bennofs> :t mappend `asAppliedTo` Data.Map.empty
13:07:25 <lambdabot> Ord k => M.Map k a -> M.Map k a -> M.Map k a
13:08:06 <S11001001> @remember dolio cabal is more mysterious than I thought.
13:08:07 <lambdabot> Nice!
13:08:43 <sdfbjk> tasty vs test-framework?
13:09:02 <Clint> tasty
13:09:14 <sdfbjk> Clint: why?
13:09:22 <S11001001> oh god
13:09:36 <Clint> sdfbjk: because tasty is a fork of test-framework and test-framework is bitrotting
13:10:01 <sdfbjk> S11001001: do u disagree?
13:10:42 <S11001001> sdfbjk: it's like asking the Doctor Who fans what the best serial is
13:10:59 <quchen> Right, because there's a definitive answer.
13:11:02 <quchen> Tasty, in this case. :-)
13:11:09 <Clint> unlike "tasty vs. hspec"
13:11:42 <sdfbjk> im confused about tast vs hspec because i see hspec-tasty module... so i assume they can be used together?
13:12:04 <creichert> Also: https://github.com/sol/hspec-test-framework
13:12:10 <creichert> which is quite useful
13:12:12 <sdfbjk> S11001001: but can u give a technical reason to use test-framework over tasty?
13:12:23 <S11001001> sdfbjk: no
13:12:40 <sdfbjk> i dont understand :S
13:13:02 <sdfbjk> quchen: can u give a technical reason to use tasty over test-framework?
13:13:33 <myfreeweb> pretty much everything can be used together, but hspec does not require any frameworks above it
13:13:44 <quchen> I've never used test-framework. All I can say is that tasty is an excellent unification of quickcheck/smallcheck/hunit and I like the output.
13:14:06 <sdfbjk> okay i see
13:15:16 <sdfbjk> myfreeweb: i tried hspec and its very similar to jasmine/mocha which i use for js so thats nice
13:15:34 <myfreeweb> yeaah I've said you might like the rspec style
13:15:34 <xplat> can anyone on 32-bit try and see if they can build bloomfilter-2.0.0.0?
13:15:50 <myfreeweb> you don't need anything else then
13:15:53 <creichert> i'm a big fan of hspec and use hspec-test-framework when integration is needed
13:16:06 <myfreeweb> quickcheck can be used from hspec easily
13:16:46 <Clint> xplat: are you referring to https://github.com/bos/bloomfilter/issues/7
13:18:04 <sdfbjk> myfreeweb: ok cool am i possibly missing something that tasty does which hspec doesnt?
13:18:27 <myfreeweb> I've never used tasty or test-framework or hunit
13:18:33 <sdfbjk> the whole hspec + tasty combo seems pointless...
13:18:34 <xplat> Clint: ah, looks like
13:19:00 <quchen> sdfbjk: HSpec has nice syntax to specify tests. They're almost human-readable.
13:19:18 <myfreeweb> I think you might need tasty if you already have a lot of hunit tests and want to use both hunit and hspec
13:19:32 <sdfbjk> okay ill stick with hspec then, thanks all
13:20:50 <creichert> hspec-test-framework can do the integration with hunit
13:21:30 <shapr> bitemyapp: Yes, I like writing webapps in Haskell, it's fun!
13:21:31 <creichert> I've used it to retrofit a few projects with bunches of HUnit and test-framework tests.
13:22:12 <bitemyapp> shapr: what do you usually use?
13:22:38 <bitemyapp> shapr: my current side project is writing a twitter terminal client.
13:23:03 <cschneid> I've been enjoying using Spock recently for webapps, although I think for my use scotty is identical.
13:23:12 <bitemyapp> Yesod's kinda won my heart.
13:23:22 <bitemyapp> the scaffold is awesome and classy-prelude is <3
13:23:30 <bitemyapp> and I really liked yesod-test, even if it confused me sometimes.
13:23:34 <creichert> Yesod is really great once you realize how much manual work it is to acheive the same effect
13:23:35 <johnw> I  never liked classy-prelude
13:23:41 <johnw> it's just different enough to be too different
13:23:43 <creichert> but I really like snap
13:23:48 <cschneid> I like the lack of "magic" in scotty/spock. I define what routes exist, how they map to functions, etc.
13:24:04 <bitemyapp> cschneid: Yesod routing didn't feel magical to me.
13:24:12 <creichert> cschneid: I agree, but that magic does end up being very helpful maintenance-wise
13:24:20 <cschneid> bitemyapp: "magic" is wrong. More like rails - it is cool but it does a lot for you that you should know is happening
13:24:27 <cschneid> just a large startup cost to load all of it into your head.
13:24:31 <creichert> for sure
13:24:56 <bitemyapp> the type-safe routing/URLs caught more than one error in just a 2k LOC project
13:25:23 <cschneid> that's pretty cool. I should look into it. Although for my current use, I'm doing a straight up api / json server.
13:25:29 <cschneid> "is the type json"... "yes."
13:25:35 <creichert> I;ve found yesod to be _fantastic_ for that
13:25:36 <cschneid> "did aeson parse it" ... "yes"
13:26:10 <cschneid> cool, I'll have to go look into it.  I'm also feeling the pain of using hasql (just lower level than I'm used to , lots of parsing the results of a query back into my data types)
13:26:19 <cschneid> persistent and friends would make that easier I think
13:26:48 <creichert> cschneid: _precisely_. db migrations, etc are huge time cost and persistent solves a lot of that (even if a bit less efficient)
13:27:23 * hackagebot svg-tree 0.1.0.1 - SVG file loader and serializer  http://hackage.haskell.org/package/svg-tree-0.1.0.1 (VincentBerthoux)
13:28:04 <bergmark> cschneid: for an api server i recommend taking a look at rest
13:28:18 <hannes__> @Hoogle [Word8] -> ByteString
13:28:19 <lambdabot> Maybe you meant: hoogle google
13:28:26 <hannes__> @hoogle [Word8] -> ByteString
13:28:27 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
13:28:27 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
13:28:27 <lambdabot> Data.ByteString.Lazy repeat :: Word8 -> ByteString
13:29:00 <creichert> bergmark: I've actually been interested in that lately, especially when it comes to content versioning. A BIG component of Yesod I like specifically for API is the way to handle media type versions (albeit, somewhat manually)
13:30:00 <shapr> bitemyapp: yeah, I got lost in the magic of snap/yesod, so I'm a fan of scotty
13:30:24 <shapr> mind you, I haven't tried snap or yesod recently, maybe it's improved?
13:30:52 <creichert> imo, yes. It does all depend on the use-case though
13:31:27 <bitemyapp> shapr: IMO yes as well. I had a harder time with Yesod a year ago than I did this time
13:31:35 <bitemyapp> shapr: but, my recommendation with Yesod is to use the scaffold.
13:31:39 <bitemyapp> shapr: it helps a lot.
13:31:44 <bitemyapp> and gives you good patterns
13:31:55 <creichert> I agree with bitemyapp . There is a mini scaffold also which I use for a "lean" yesod app
13:32:17 <shapr> at the moment I'm all about Haskell for arduino, but next time I get around to building Haskell websites, I'll ask for the current status of all the Haskell webdev libs.
13:32:27 <creichert> I would also highly recommend looking into Wai middlewares for some functionality as it can be shared between way, scotty, yesod
13:32:37 <creichert> s/way/wai
13:33:35 <bitemyapp> ($) is impredicatively typed
13:33:36 <bitemyapp> what
13:33:56 <monochrom> yes, the compiler has a hardcoded special type rule for it
13:33:57 <geekosaur> typechecker hack so runST $ thing works
13:34:03 <shapr> creichert: when I get back to haskell web stuff, I will
13:34:27 <shapr> creichert: though at the moment... I'm all about #haskell-embedded where we talk about Atom/Copilot/Ivory and Haskell -> FPGA
13:34:32 <bitemyapp> geekosaur: because of the phantom type?
13:34:35 <cschneid> creichert: wai middlewares are pretty slick for sure. I should figure out how to write them.  And to do stuff like parsing auth tokens / sessions / etc.
13:34:42 <cschneid> but I'll have to look into how Wai works.
13:34:47 <geekosaur> because of a rank-2 phantom type, yes
13:34:49 <S11001001> bitemyapp: prob because runST is rank-2
13:35:01 <geekosaur> it'd be fine with a normal phantom type but it's an existential
13:36:06 <bitemyapp> geekosaur: hrm, cool.
13:36:08 <bitemyapp> Thanks everybody :)
13:36:33 <wolf_mozart> i m learning haskell i still don't see why the extra brain expense is better
13:36:58 <bergmark> wolf_mozart: pretty quickly it becomes less brain expense
13:37:01 <monochrom> indeed, it is not better for everyone, every career.
13:37:17 <bitemyapp> wolf_mozart: using Haskell for my work means thinking less.
13:37:18 <wolf_mozart> i don't see how writing something shorter is better than writting it longer, it's not like you have to rewrite a function over and over again
13:37:23 <bitemyapp> wolf_mozart: it's like a mutual fund for your brain.
13:37:32 <bitemyapp> wolf_mozart: you invest effort now, so you can do things with less effort later.
13:37:41 <wolf_mozart> hmm
13:37:43 <monochrom> you need to know your future in order to be sure what is your return of investment
13:38:04 <ski> wolf_mozart : less space for bugs to hide in
13:38:15 <bitemyapp> wolf_mozart: for example, if you plan to quit programming in the next few weeks, learning Haskell may not be high value.
13:38:23 <bitemyapp> However if you plan to be doing this for a long time, it's worth considering.
13:38:36 <wolf_mozart> but if you make your own function, it's like you have more degrees of control
13:38:48 <shapr> wolf_mozart: what do you mean?
13:39:53 <shapr> wolf_mozart: I don't understand, can you expand on that?
13:40:00 <monochrom> here is a scenerio where you will have pretty much 0 return of investment. next year you'll be promoted to a managerial position. from that point to your retirement, you will be managerial, you won't write much code ever again. so learning haskell (or learning python, for that matter) will not gain you much anything.
13:40:03 <wolf_mozart> well being able to write buggy or unbuggy code gives you more degrees of freedom and conrol over your functions(C++) then writting haskell code where you seem somehow restrained
13:40:04 <davidfetter> hi
13:40:36 <EvanR> ah did not know that you can just leave instances undefined
13:40:42 <EvanR> and it compiles with a warning
13:40:47 <init> the freedom to write bugs when you don't want them?
13:41:12 <monochrom> yes haskell is very restraining (agda more so) and I want it that way
13:41:39 <cschneid> the cool part of haskell is that you define your own constraints as you go, in an explicit way
13:41:46 <shapr> wolf_mozart: from one viewpoint, Haskell is more restrictive than C++, but from another viewpoint, Haskell prevents you from making mistakes that are common in C++
13:41:53 <quchen> wolf_mozart: That's a general issue. Adding more axioms greatly reduces the number of representable programs. Most people here would say that the number of valid-but-not-typechecking programs are the *vast* minority.
13:41:55 <ski> wolf_mozart : there's generally a trade-off between expressivity and "reasonability" (how easily you can reason about and refactor code)
13:42:07 <Cale> wolf_mozart: You're free to write programs which generate those buggy behaviours in Haskell, it's just going to require more effort, because you'll have to explicitly sidestep some things.
13:42:23 <monochrom> extremely smart people do not need that restraint. they are better off given full access to hardware and write self-modifying machine code. I agree. but I am not extremely smart. I want restraints, they benefit me.
13:42:26 <dmead> ?yow
13:42:26 <lambdabot> Are we on STRIKE yet?
13:42:43 <monochrom> the question is how about you? are you with the extremely smart people, or are you with me?
13:42:43 <Cale> wolf_mozart: The FFI even gives you direct control over allocation, so if you really wanted to, you could fuck up with malloc/free :)
13:42:44 <ski> wolf_mozart : if you increase expressivity, but have low reasonability, then (generalizing) you can't find your bugs, or can't refactor your code
13:42:55 <Denommus> monochrom: I would dare to say that no one is sufficiently smart
13:42:58 <ChristianS> i want to check if all elements of a non-empty list are equal.  all (== head l) (tail l)  works but i wonder it there is a better solution?
13:43:00 <wolf_mozart> I'm not far gone into it, but it seems like they restrain it for you, and then with the little tools you've you have to go and figure out many ways and combinations on how to do something within he constraints set, while in like c++ you can just hack something however you feel like, and if and only if it crashes or has a bug you can fix for that
13:43:06 <EvanR> good point, you can write really buggy code in haskell if you know the magic words
13:43:14 <shapr> Denommus: except Mel
13:43:16 <sinelaw> Question: I have a pair of boolean expressions (logical predicates on a set of variables). I want to unify them. 1. Is this a standard problem? 2. What is it usually called? 3. Suggested packages?
13:43:21 <shapr> Denommus: http://www.catb.org/jargon/html/story-of-mel.html
13:43:23 <cschneid> its trivial to write buggy code in haskell. Where bug == acts differently than you wanted it to
13:43:25 <quchen> monochrom: It's not just about the classical humble "I'm not smart", it's also a matter of scaling. Abstraction save you a lot of time compared to doing it the "rough and smart" way.
13:43:44 <quchen> ChristianS: Use pattern matching and the "all" function
13:43:48 <EvanR> wolf_mozart: if and only when it crashes
13:44:07 <quchen> ChristianS: In particular, you should avoid head/tail whenever you can. See https://github.com/quchen/articles/blob/master/fbut.md#head-tail-isjust-isnothing-fromjust-
13:44:10 <Cale> wolf_mozart: That's not a very productive way to write programs though.
13:44:21 <ski> ChristianS : `and (zipWith (==) l (tail l))'
13:44:29 <dmead> sinelaw, other than unification?
13:44:34 <Denommus> ChristianS: I think your definition is good enough
13:44:35 <sinelaw> example: (a = A and b= B) or (a = C)    unify with:    (a = A)        =>   (a = A and b= B)
13:44:39 <Cale> wolf_mozart: Like, sure you can stumble blindly around in the dark with no machine support and maybe eventually you end up with something that works.
13:45:02 <shapr> wolf_mozart: As Cale says, it takes longer to get a working program out of C++ than to get the same program working from Haskell.
13:45:03 <sinelaw> dmead, the unification I know doesn't deal with disjunction
13:45:12 <Cale> wolf_mozart: But it's really nice to have tools which tell you what's wrong with your program before you even run it, pointing out precisely where you'll have to change things in most cases.
13:45:25 <quchen> ski: Clever, but not all too intuitive. I prefer \(x:xs) -> all (== x) xs.
13:45:26 <dmead> sinelaw, it would be helpful if you posted an example
13:45:36 <DataHead> I know this is rather rude to join and ask, but is there anyone here whom can effectively and efficiently port c++ to c# or python?
13:45:50 <ski> quchen : *nod*
13:45:53 <sinelaw> dmead,  I just did. Here it is simplified: (A & B) | C  unify with  A  should be = A & B
13:46:01 <EvanR> DataHead: maybe check #python or #csharp?
13:46:06 <wolf_mozart> haskell is certainly a programming achievement i guess
13:46:17 <ChristianS> quchen, ski, Denommus: thanks, i guess i'll stick with what a have (at that point in the code i already know that the list cannot be empty)
13:46:30 <DataHead> Thank you EvanR
13:46:38 <quchen> ChristianS: Do all of the potential code readers know that too?
13:46:39 <shapr> wolf_mozart: well, use what you like if it fits the way you think... no matter what language that may be.
13:46:40 <Cale> wolf_mozart: and if you decide that it's really a case of "no, type system, I'm right and you're wrong", you can use unsafeCoerce and bear the risk of arbitrary code execution or whatever if you're wrong.
13:46:45 <tdammers> DataHead: there is no trivial approach to doing this, so probably no
13:47:10 <ChristianS> quchen: hopefully
13:47:16 <wolf_mozart> but the flexibility c++ gives a programmer to do everything he wants using whatever method, unorthodox, and sane, is way more interesting
13:47:17 <Cale> wolf_mozart: But it's almost never the case that you need that
13:47:19 <ski> Cale : type error slicing would be nice :)
13:47:27 <quchen> "hopefully" is not "yes". There is only "yes" and "not yes".
13:47:30 <EvanR> Cale: of all the ways to screw yourself in haskell, unsafeCoerce has gotta be harder to get right than even normal c++
13:47:37 <wolf_mozart> im going to learn haskell though
13:47:39 <quchen> Really, avoid head/tail at all cost
13:47:46 <Cale> wolf_mozart: In my 14 years of programming in Haskell, I can count the number of times I've needed unsafeCoerce on one hand.
13:48:05 <EvanR> wolf_mozart: about the flexible and unorthodox c++... I'm guessing you have never had to do this stuff for a job ;)
13:48:12 <tdammers> wolf_mozart: doing sweeping GC in C++ is really really painful, fwiw, so "everything he wants etc." is somewhat exaggerated
13:48:12 <quchen> Cale: 14 years? That's long. I bet you even found a valid use case for foldl!
13:48:16 <shapr> wolf_mozart: It's worth learning C++ as well, and Prolog, and a bunch of other languages. You'll be a better programmer everytime you learn a new language.
13:48:19 <Cale> quchen: heh
13:48:35 <tdammers> (totally not hating on C++ though, btw)
13:48:37 <quchen> Cale: I wasn't joking. I'm still looking for a use case (that I understand).
13:48:42 <davidfetter> hi
13:48:46 <haskell-beginner> I am trying the 99 haskell problems and trying to implement 'flatten'. this what I have written http://pastebin.com/2ryENp3w . Can anybody help me what the error is
13:48:47 <Cale> quchen: reverse is the canonical one
13:48:54 <shapr> davidfetter: HI!
13:49:02 <Denommus> ChristianS: you could have let allEqual x:xs = all (==x) xs
13:49:04 <shapr> davidfetter: How are you doing today? Written any Haskell code lately?
13:49:13 <quchen> Cale: ‚Ä¶ if you could see my face now haha. Well, thanks! :-D
13:49:28 <davidfetter> so i was hoping to get some mathematical insight here into a problem. i'll eventually have to get it coded in C because that's what the PostgreSQL backend is written in
13:49:32 <Cale> quchen: But really the reason that foldl exists is that it's supposed to compile to foldl' whenever that would be a good thing
13:49:38 <shapr> wolf_mozart: How will you be starting with Haskell? Perhaps by reading "Learn You a Haskell" ?
13:49:43 <Denommus> ChristianS: sorry, allEqual (x:xs) = all (==x) xs
13:49:51 <davidfetter> shapr, working my way through lyah
13:50:02 <Cale> quchen: It's just that it's taken quite a long time for the strictness analysis to get good enough to make that happen.
13:50:02 <davidfetter> or r'lyeh, or something
13:50:06 <dmead> sinelaw, maaaybe? the unification i know operates only disjunction iirc
13:50:08 <shapr> davidfetter: I like to prototype problems in Haskell, even when I'll be reimplementing them in Python or other languages.
13:50:18 <shapr> davidfetter: oh r'lyeh?
13:50:20 <dmead> sinelaw, what are you implementing?
13:50:21 <Cale> quchen: If you turn on optimisations it's pretty reliable now, but not perfectly so.
13:50:22 <quchen> Cale: I didn't know it was there.
13:50:23 <wolf_mozart> im reading learning you a haskell
13:50:23 <wolf_mozart> chapt 4
13:50:27 <sinelaw> dmead, type constraints
13:50:28 <davidfetter> iaaa
13:50:33 <shapr> fthagn?
13:50:48 <quchen> Cale: There's a lot of heroic hidden stuff being worked on in GHC. I usually only see the changes that make it onto the lists.
13:50:52 <davidfetter> i believe it's fhtagn
13:51:01 <shapr> davidfetter: so, what's the problem?
13:51:01 <ChristianS> Denommus: yes, i'm already ending up with samething like that
13:52:01 <davidfetter> anyhow, the idea here is to get a precise mathematical idea of what partitions are without the mathematical details. aiui, one needs to set up an equivalence relation that's very cheap to check, and a way to enumerate the equivalence classes that relation defines
13:52:17 <wolf_mozart> it's indeed a great feat, a system that aids programmers programmer better, but thats why we have scripts and specific languages like R and matlab for simplicity, C and C++ just gives you the ability to write bugs/viruses, and everything you want that's under the sun
13:52:54 <shapr> wolf_mozart: So, how's chapter 4 treating you? Got any questions about Haskell?
13:52:54 <davidfetter> ideally, there would be a way to test whether there's an injective mapping from that equivalence relation to a "finer-grained" equivalence relation (i.e. one which produces more equivalence classes over the domain)
13:52:56 <EvanR> id like some type safety when writing a virus
13:53:01 <Cale> wolf_mozart: Another thing I can say with regard to C++ is that I think if all the C++ specifications and implementations were to vanish overnight, we would never again be able to reconstruct the C++ spec. We might come close, but nobody really understands C++ well enough, and even collectively, I think we'd have a hard time coming to the right consensus on what language C++ is.
13:53:01 <phaazon> hey
13:53:05 <phaazon> in a profile trace
13:53:15 <phaazon> at the very top, under cost centre
13:53:25 <phaazon> there‚Äôre a few expressions that consume the most %time / %alloc
13:53:32 <phaazon> and I have an expresssion called:
13:53:35 * davidfetter hopes he is making some sense in the abstract, but is happy to give an example
13:53:40 <Cale> wolf_mozart: Whereas Haskell is a language that I'd be reasonably confident that one or two experienced Haskellers could reproduce at least what's in the Haskell Report, if not most of the extensions.
13:53:41 <phaazon> createMorePaths.neighbors.\
13:53:44 <phaazon> what is the \ for?
13:53:45 <phaazon> lambda?
13:54:13 <shachaf> phaazon: In profiling results?
13:54:19 <phaazon> yeah, wait
13:54:22 <phaazon> I‚Äôll show you :)
13:54:25 <shachaf> Oh, wait, you said so.
13:54:29 <shachaf> Yes, it's a lambda.
13:54:32 <davidfetter> let's imagine we have an equivalence relation over timestamps which states that timestamps (i,j) are "equivalent" if they have the same UTC year
13:54:40 <phaazon> http://lpaste.net/120302
13:54:42 <phaazon> ok
13:54:45 <phaazon> thanks :)
13:54:49 <gregnwosu> hi ive defined a setter function for my record as ``` emptyField2 recordVal = recordVal{field2=()}```
13:54:54 <davidfetter> it'd be nice to be able to generate all the partitions that implies, given a start and end
13:55:01 <gregnwosu> is there a way to make this point free?
13:55:26 <shapr> davidfetter: example?
13:55:29 <davidfetter> then later, it'd be nice to be able to check that UTC month sub-partitions the space without moving any partitions
13:55:30 <Cale> wolf_mozart: Nobody actually knows C++, including the people who have worked on the spec and implementation, it's just too big and complicated to commit to memory reliably.
13:55:46 <mniip> gregnwosu, not really
13:55:57 <phaazon> oh‚Ä¶
13:56:05 <phaazon> I‚Äôm using expressions like
13:56:10 <phaazon> north = (x,pred y)
13:56:11 <S11001001> gregnwosu: only with lens
13:56:16 <phaazon> I guess it creates thunks
13:56:18 <Cale> I would be seriously impressed if someone could write down a correct context free grammar for C++ alone.
13:56:22 <davidfetter> now i happen to *know* both of those things, but i'm looking for ways to shape a more general case. for simplicity, we can assume ordered sets, but it'd be nice to have a more general result
13:56:23 <sdegutis> raek: knowing both languages, would you agree with my conclusion article?
13:56:23 <Cale> Let alone the semantics.
13:56:24 <xplat> davidfetter: have you seen fritz henglein's work on discriminators?
13:56:25 <phaazon> and I¬†call that function for each cell to be added to a path
13:56:34 <davidfetter> xplat, first i've heard of it
13:56:36 * davidfetter googles
13:56:49 <mniip> Cale, oh that is pretty simple
13:57:02 <Cale> mniip: Have you seen the context free grammar for C++?
13:57:07 <haskell-beginner> i am trying to implement 'flatten'. this what I have written http://pastebin.com/2ryENp3w . Can anybody help me what the error is expected output 'flatten (1,(2,(3,4),5)) = (1,2,3,4,5)'
13:57:18 <Cale> It's like 10 times the complexity of Haskell's grammar.
13:57:24 * hackagebot rasterific-svg 0.1.0.2 - SVG renderer based on Rasterific.  http://hackage.haskell.org/package/rasterific-svg-0.1.0.2 (VincentBerthoux)
13:57:32 <mniip> ok actually it's not that simple
13:57:38 <mniip> http://www.nongnu.org/hcb/
13:58:28 <davidfetter> xplat, http://www.diku.dk/hjemmesider/ansatte/henglein/papers/henglein2009d.pdf , e.g.?
13:58:29 <mniip> haskell-beginner, that function doesn't typecheck
13:58:37 <xplat> and the context-free grammar for C++ doesn't get at the *really* hard stuff, like the scoping and namespacing rules, which you need to know just in order to parse correctly
13:58:41 <xplat> davidfetter: yeah
13:58:57 <davidfetter> any other particular cites i should look at?
13:59:21 <mniip> haskell-beginner, you can't, generally, write a function that does that
13:59:37 <ski> haskell-beginner : the first defining equation overlaps the second. the first would always be used, the second ignored (assuming the code passed the type checker)
14:00:33 <mniip> the second definition creates an infinite type
14:02:27 <Cale> haskell-beginner: You *can* write this:  f (a,(b,(c,d),e)) = (a,b,c,d,e)
14:02:39 <Cale> haskell-beginner: But it will only work on tuples of *exactly* that shape
14:02:44 <mniip> that would only work for that specific shape of tuple
14:02:56 <Cale> haskell-beginner: Because nested tuples of other shapes are separate types
14:03:21 <Cale> haskell-beginner: If you want to work with trees in a uniform way, then you need to have a tree data type
14:03:29 <mniip> I wonder if you can typefoo a tuple flattening function
14:03:40 <Cale> Haskell lists and tuples are not the same thing as trees, like they are in lisps.
14:04:03 <Cale> (this is where the 99 problems thing shows its heritage)
14:04:26 <Cale> Oh, you could use lots of type class hackery...
14:04:27 <mniip> yep
14:04:28 <davidfetter> ugh. boy, oh, boy do i not care about in-memory-only. i'll see if i can extract something useful despite that warning. thanks, xplat :)
14:04:29 <mniip> it's possible
14:04:35 <mniip> I just thought it through
14:05:18 <haskell-beginner> So for solving any general list of lists what should be done?
14:05:36 <ski> haskell-beginner : list of lists, or list of lists of lists, or ... ?
14:05:53 <mniip> haskell-beginner, you need a tree data structure
14:05:57 <ski> you either have to decide how many levels you want, or you build a dedicated tree type that encodes what you want
14:06:06 <ski> such as possibly `data SExpr a = Atom a | List [SExpr a]'
14:06:54 <haskell-beginner> ok, thank you I will try with dedicated tree type
14:06:56 <ski> @let data SExpr a = Atom a | List [SExpr a]   deriving Show
14:06:58 <lambdabot>  Defined.
14:07:19 <mniip> flatten (Atom a) = a; flatten (List a) = concatMap flatten a
14:07:23 <ski> > List [Atom 1,List [Atom 2,List [Atom 3,Atom 4],Atom 5]]
14:07:25 <lambdabot>  List [Atom 1,List [Atom 2,List [Atom 3,Atom 4],Atom 5]]
14:07:25 * hackagebot network-bitcoin 1.7.1 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.7.1 (ClarkGaebel)
14:07:26 <Cale> haskell-beginner: For just a list of lists, you should can write  concat :: [[a]] -> [a]
14:07:34 <Cale> er, s/should//
14:07:55 <Cale> haskell-beginner: The Prelude contains such a function:
14:07:58 <ski> @let flatten (Atom a) = a; flatten (List a) = concatMap flatten a
14:07:59 <lambdabot>  .L.hs:171:30:
14:07:59 <lambdabot>      Ambiguous occurrence ‚Äòflatten‚Äô
14:07:59 <lambdabot>      It could refer to either ‚ÄòL.flatten‚Äô, defined at .L.hs:170:1
14:08:00 <Cale> > concat [[1,2,3],[4,5],[6,7,8]]
14:08:02 <lambdabot>  [1,2,3,4,5,6,7,8]
14:08:08 <mniip> no wait flatten (Atom a) = [a]
14:08:52 <ski> @let mniipFlatten (Atom a) = [a]; mniipFlatten (List a) = concatMap mniipFlatten a
14:08:53 <lambdabot>  Defined.
14:08:58 <ski> @type mniipFlatten
14:08:59 <lambdabot> SExpr t -> [t]
14:09:08 <ski> > mniipFlatten (List [Atom 1,List [Atom 2,List [Atom 3,Atom 4],Atom 5]])
14:09:08 <mniip> ‡≤†_‡≤†
14:09:09 <lambdabot>  [1,2,3,4,5]
14:09:16 <ski> haskell-beginner ^
14:10:11 <shachaf> mniipFlatten is just a free monad monad monad algebra.
14:10:25 <mniip> > mniipFlatten $ List [Atom 1, undefined]
14:10:26 <lambdabot>  [1*Exception: Prelude.undefined
14:10:31 <mniip> neat
14:10:33 <romildo> Does anybody knows if there is a printable version of the pandoc user's guide?
14:16:44 <phaazon> huh
14:16:59 <phaazon> I can‚Äôt open my PostScript file after a hp2ps -c :(
14:17:13 <phaazon> it‚Äôs only 51KB though
14:17:35 <phaazon> it‚Äôs ‚Äúloading‚Äù
14:17:49 <phaazon> (in evince, windows)
14:23:29 <lpaste> bramgg pasted ‚ÄúIO [String] instead of [IO String]‚Äù at http://lpaste.net/120304
14:23:41 <bramgg> ^ can anyone look at that and see if they can help?
14:23:51 <Cale> sure
14:23:56 <bramgg> ty
14:24:03 <Cale> The function you're looking for is called sequence
14:24:28 <Cale> It takes a list of IO actions, and combines them together into a single IO action which produces a list of results when executed
14:24:46 <Cale> :t sequence
14:24:48 <lambdabot> Monad m => [m a] -> m [a]
14:24:55 <bramgg> Thanks, I'll check that out!
14:24:55 <Cale> (you can substitute IO for m there)
14:25:02 <Cale> We can write it by hand as follows:
14:25:25 <Cale> sequence [] = return []  -- when the list of actions is empty, we produce the action which does nothing but to produce the empty list as its result
14:25:44 <mniip> sequence (x:xs) = do x' <- x; xs' <- sequence xs; return (x:xs)
14:26:00 <mniip> -- simple enough induction step
14:26:00 <Cale> sequence (x:xs) = do v <- x; ...  -- if the list is nonempty, we give the action which first executes the first element of the list, getting some result v
14:26:14 <mniip> er
14:26:16 <mniip> (x':xs')
14:26:19 <phaazon> need your help guys
14:26:31 <phaazon> http://lpaste.net/4751507441798086656
14:26:32 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...  -- and then runs the rest of the list (recursively), getting a list of the results vs
14:26:37 <phaazon> that function is getting a LOT of allocations
14:26:43 <phaazon> I just know that it‚Äôs not isHBlocked
14:26:48 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)  -- and finally, returns the completed list of results
14:26:53 <phaazon> what could generate thunks in that?
14:27:10 <phaazon> Grid is a simple Vector
14:27:19 <phaazon> Vector (Vector Int)
14:27:31 <mniip> phaazon, everything is a thunk
14:27:48 <phaazon> not everything, no
14:27:59 <bramgg> thanks a bunch
14:28:04 <phaazon> in my case, Coord has no thunk at all
14:28:06 <mniip> you could swap that . and $ with a $!
14:28:36 <Cale> Well, not is strict
14:28:46 <Cale> How is isHBlocked implemented?
14:28:50 <haskell-beginner> any suggestion on the editor? I often get parsing errors
14:28:54 <Cale> It sounds like something which would be strict
14:28:56 <mniip> Cale, application is still lazy
14:28:59 <phaazon> Cale: the profile trace tells the problem is not that
14:29:10 <Cale> mniip: $! doesn't help with that
14:29:17 <phaazon> but I can provide the implementation of isHBlocked, yeah
14:29:18 <phaazon> wait
14:29:31 <Cale> mniip: If f is already going to pattern match its argument, writing f $! x isn't any better than writing f x
14:30:05 <mniip> ah right
14:30:18 <ski> haskell-beginner : layout-related or other ?
14:30:52 <haskell-beginner> ski, layout-related
14:31:10 <phaazon> Cale: http://lpaste.net/4751507441798086656
14:31:21 <Cale> Right, so it's strict
14:31:37 <haskell-beginner> ski:layout-related
14:31:51 <phaazon> Coord is also strict
14:31:59 <phaazon> data Coord = Coord !Int !Int
14:32:06 <phaazon> and I compile with -funbox-strict-fields
14:32:14 <Cale> So if (canGoNorth grid coords) is evaluated, then you have a Bool result, it can't go halfway and retain unevaluated expressions.
14:32:36 <ski> haskell-beginner : ok. after a while, the layout rules sets in, and you rarely get such errors
14:32:40 <phaazon> Cale:
14:33:10 <phaazon> Cale: http://lpaste.net/8165222455967744
14:33:14 <phaazon> the profiling trace
14:33:28 <phaazon> as you can see, canGoNorth / South / East / West are bottlenecks
14:33:39 <Cale> Well, you must be allocating a lot of Bools :)
14:34:10 <haskell-beginner> ski : thanks
14:34:20 <phaazon> hm
14:34:30 <phaazon> I‚Äôd like to dig further
14:34:40 <phaazon> but the -hc doesn‚Äôt show up :(
14:34:52 <phaazon> maybe you can see it with your ps viewer?
14:34:54 <ski> haskell-beginner : i tend to use emacs. people also use different editing environments
14:35:16 <Cale> What do you mean it doesn't show up?
14:35:19 <phaazon> Cale: http://lpaste.net/8165222455967744
14:35:22 <phaazon> oops, wrong link
14:35:31 <phaazon> http://phaazon.net/pub/tge.ps Cale
14:35:41 <phaazon> Cale: my ps viewer keeps ‚Äúloading‚Äù it
14:35:42 <phaazon> :(
14:36:12 <Cale> My ps viewer just displays it as blank and not loading
14:36:14 <haskell-beginner> ski : ok
14:36:27 <Cale> Did your program run to completion, or did you kill it?
14:36:42 <Cale> What does the .hp file look like?
14:37:20 <phaazon> it ran to completion
14:37:39 <phaazon> wait, I‚Äôll tell you
14:38:15 <phaazon> it has nothing :(
14:38:18 <phaazon> it‚Äôs empty
14:38:22 <phaazon> ah nevermind
14:38:32 <phaazon> it has 244¬†BK
14:38:35 <phaazon> KB=
14:38:50 * shapr hops randomly
14:38:50 <shapr> YOW
14:39:16 <phaazon> dammit what‚Äôs the heck
14:39:29 <phaazon> why can‚Äôt have a profile of my heap DAMMIT :D
14:39:52 <shapr> @yow
14:39:52 <lambdabot> Everybody is going somewhere!!  It's probably a garage sale or a
14:39:52 <lambdabot> disaster Movie!!
14:40:07 <lf94> uys what does Point() mean? It takes a hash as an argument and returns a number.
14:40:11 <lf94> Guys
14:40:43 <sdegutis> Is it possible to discover namespaces at runtime?
14:40:52 <sdegutis> Or do they literally not exist at runtime?
14:41:21 <Cale> sdegutis: The resulting assembly code doesn't know about names
14:41:38 <phaazon> ah Cale
14:41:43 <phaazon> I have something with -hy
14:41:44 <geekosaur> lf94, there's quite a few different "Point" types defined on hackage. am I supposed to guess?
14:42:06 <phaazon> what‚Äôs the switch to pass to hp2ps to have a landscape graph?
14:42:52 <lf94> geekosaur: yes please
14:42:55 <phaazon> ah, -g
14:43:04 <sdegutis> Is that why tricks like this exist?  {-# OPTIONS_GHC -F -pgmF hspec-discover -optF --module-name=Spec #-}
14:43:10 <lf94> geekosaur, I was reading a paper and the paper mentioned running a hash through a Point function
14:43:16 <phaazon> ah no
14:43:18 <phaazon> dammit :D
14:43:21 <mniip> sdegutis, there are reflection and dynamic loading magics
14:43:25 <lf94> It turns the hash into a number
14:43:32 <lf94> (for cryptography)
14:43:33 <mniip> but you don't wanna mess with it
14:43:39 <geekosaur> so I need to guess what paper and what they are doing with this type.
14:43:47 <phaazon> the moste allocated type is []
14:43:58 <geekosaur> this is not some standard Point type that every Haskell installation automatically has
14:43:58 <phaazon> that sounds terribly obvious‚Ä¶
14:43:59 <lf94> geekosaur: no not the former B) i'll get you the paper.
14:44:29 <sdegutis> mniip: scary
14:44:30 <lf94> geekosaur, https://eprint.iacr.org/2005/434.pdf
14:44:44 <mniip> sdegutis, I tried that once
14:44:47 <lf94> you might enjoy it actually :) very cool password mechanism.
14:44:49 <sdegutis> mniip: "reflection and dynamic loading [features]" is cool. "reflection and dynamic loading [magic]" is scary.
14:45:16 <mniip> didn't get to the part with segfaults and rainbows
14:45:22 <EvanR> phaazon: but [] shouldnt be the most allocated value
14:45:25 <mniip> but rather got uninformative Prelude.undefined and no docs
14:45:41 <EvanR> since all [] can be shared
14:45:48 <phaazon> EvanR: well, I use that for my paths each time I launch a BFS
14:45:54 <phaazon> so I guess it makes sences
14:45:55 <phaazon> sense*
14:47:04 <mniip> sdegutis, I'll get back to it eventually though
14:47:13 <mniip> sdegutis, what do you need reflection for?
14:47:21 <sdegutis> mniip: nooooooooooooooo.com
14:47:43 <sdegutis> mniip: for an rspec clone that uses less magic than hspec and is also more convenient to use
14:47:53 <sdegutis> (its annoying that every spec file must export both 'main' and 'spec')
14:47:59 <orzo> is there a ready to use Proxy type in base?
14:48:01 <sdegutis> (and that both *must* exist)
14:48:15 <alpounet> orzo: yes, in 7.8 at least
14:48:22 <alpounet> it's in Data.Proxy
14:48:39 <geekosaur> lf94, the answer is that those "functions" are part of elliptic curve cryptography
14:48:49 <lf94> geekosaur, thanks!
14:49:02 <lf94> geekosaur: so what is usually a Point function in ECC?
14:49:13 <alpounet> sdegutis: you can avoid that if you don't use the automatic discovery machinery from hspec though
14:49:31 <sdegutis> alpounet: thats even more boilerplate i have to write!
14:50:11 <alpounet> sdegutis: you could also patch the existing discovery program
14:50:13 <sdegutis> my biggest fear about haskell right now is that i dont quite know when some IO code will execute due to the nature of composed lazy functions
14:50:19 <alpounet> or write your own without rewriting hspec :p
14:50:35 <sdegutis> alpounet: id still have to export something tho
14:50:42 <sdegutis> alpounet: so its still tedious/boilerplate
14:50:46 <mniip> sdegutis, IO is strict
14:50:50 <alpounet> sdegutis: i'm not sure i see what you mean
14:50:54 <mniip> >>= enforces order
14:51:00 <sdegutis> mniip: right order, but not timing
14:51:01 <alpounet> i've been using hspec for a while without any boilerplate
14:51:04 <mniip> unless you do unsafePerform/InterleaveIO
14:51:08 <orzo> iit's pretty easy to avoid lazy io
14:51:09 <Cale> Er, the order of execution of IO actions has nothing to do with evaluation order.
14:51:33 <lf94> geekosaur help please D:
14:51:49 <Cale> Well, that's a little strong, they are interconnected because you can't evaluate inside the body of an unapplied lambda, but they're not directly related.
14:51:50 <bennofs> except if you use getContents, etc which use lazy IO :|
14:52:15 <geekosaur> lf94, this is a question for a cryptography channel, not a haskell channel
14:52:20 <orzo> maybe we should propose strict versions to thoase be in the prelude
14:52:26 <orzo> or, in base anyway
14:52:50 <Cale> Yeah, there are some magical primitives which allow you to tie the execution of I/O to the evaluation of the resulting expressions.
14:53:06 <alpounet> sdegutis: you have nothing to be afraid of unless you use lazy IO
14:53:06 <mniip> some of those functions do use lazy IO but it's very well hidden and doesn't affect strictness of the function using it
14:53:07 <Cale> But that's not normal, and regardless *evaluating* getContents doesn't do much
14:53:17 <Cale> Only evaluating its result performs magic.
14:53:17 <geekosaur> (I am not an ECC expert, or even an ECC beginner. I sort-of understand the basic idea, but not the implementation)
14:53:21 <sdegutis> alpounet: deal
14:53:32 <geekosaur> (I suspect nobody active in this channel is)
14:53:37 <alpounet> sdegutis: and even then, the fact that it's in a test or in a normal program doesn't matter
14:53:46 <Cale> It's not that >>= *enforces* order
14:53:52 <Cale> It's that it *expresses* order
14:53:55 <EvanR> mniip: is that true?
14:54:00 <orzo> elliptic curve cryptography?
14:54:10 <Cale> IO action values describe which order things are supposed to be executed in
14:54:17 <mniip> EvanR, what is
14:54:19 <orzo> guessing what ECC is
14:54:21 <Cale> It doesn't matter in which order you evaluate those descriptions
14:54:23 <geekosaur> orzo, yes
14:54:28 <geekosaur> see lf94's question
14:54:47 <geekosaur> so I can see it's about ECC, but that's approximately all I know about it
14:54:50 <EvanR> mniip: f using the result of getContents doesnt affect strictness of f?
14:55:10 <orzo> in ecc, i believe point means complex number
14:56:00 <Cale> I guess one analogy would be that if you were writing a program, it doesn't matter which order you actually type the parts of program in to your text editor originally, that has nothing to do with what order the instructions run in.
14:56:28 <mniip> hmm
14:56:56 <bthom> I believe that a point is a (X,Y) where X and Y are in extension of GF(q) which satisfies an equation of the form Y^2=aX^3 +B
14:57:00 <EvanR> mniip: i guess so
14:57:14 <bthom> -s
14:57:42 <mniip> hGetContents seems to do the reading at time of the returned value evaluation, yes
14:57:43 <bthom> (I don't know if it can help)
14:58:19 <orzo> i'm working on a serialization library for IKEv2 packets.
14:58:46 <Cale> mniip: Yeah, hGetContents is magical and atypical like that. Its execution immediately returns an expression whose evaluation will cause effects.
14:59:28 <Cale> (It uses unsafeInterleaveIO to do that)
14:59:31 <mniip> I'm too interleaved to figure out what wantReadableHandle does, but lazyRead, which is the thunk the returned value leads to, is a lazy IO operation
14:59:49 <EvanR> so in the case of getContents which returns a lazy list of Chars, if you pass this to a strict function, one that will bomb if the first char does not compute, it will still bomb if the first char causes an io error
15:00:19 <EvanR> but if the second char bombs, you can still the first char, so no problem
15:00:24 <EvanR> non strict
15:01:30 <Cale> Lazy I/O isn't the most reliable and structurally sound thing, but it's certainly extremely convenient for small programs which act on a small number of (possibly large) files.
15:01:35 <phaazon> hm
15:01:39 <mniip> it can be thought as of a function returning "hello" ++ undefined
15:01:47 <mniip> which isn't a nice thing to do
15:01:59 <phaazon> does using function guards can lead to GC getting brutalized? :(
15:02:13 <sdegutis> what type is undefined?
15:02:14 <phaazon> I don‚Äôt undertand why I‚Äôm getting so much GC activity from that function
15:02:22 <Cale> Actually, if an I/O error occurs, doesn't the string just end?
15:02:29 <Cale> Or did they change that?
15:02:39 <Cale> It's good if they did :)
15:02:50 <Cale> :t undefined
15:02:52 <lambdabot> a
15:02:55 <Cale> ^^ every type
15:03:16 <EvanR> sdegutis: any type you want it to be, including Void the type with no values*
15:03:24 <EvanR> *except undefined
15:03:29 <sdegutis> EvanR: so it's kind of like an Any type?
15:03:30 <Cale> sdegutis: in the example there though, it was being used at type String
15:03:39 <EvanR> sdegutis: i wish Any was like undefined
15:03:41 <sdegutis> Cale: oh so undefined is type string?
15:03:47 <sdegutis> EvanR: there's a type Any?
15:04:05 <Cale> sdegutis: In the expression ("hello" ++ undefined) specifically, it had type String, because that's what was required.
15:04:16 <sdegutis> Cale: oh so undefined is always string?
15:04:19 <Cale> no
15:04:22 <sdegutis> Cale: btw im joking
15:04:22 <init> undefined is anything
15:04:23 <sdegutis> sorry
15:04:26 <init> @type undefined
15:04:26 <lambdabot> a
15:04:29 <EvanR> :|
15:04:30 <geekosaur> sdegutis: the value of undefined is _|_, which inhabits every type
15:04:36 <Cale> sdegutis: You can think of it as an infinite loop which instead of looping forever, kills your program.
15:04:41 <geekosaur> (because it's not really a value)
15:04:47 <init> @type undefined :: Int -> (a -> b) -> c -> Bool -> [Int]
15:04:48 <lambdabot> Int -> (a -> b) -> c -> Bool -> [Int]
15:05:21 <Cale> sdegutis: But the recursive definition  undefined = undefined  would also work to define a value of an arbitrary type, and since that works, we might as well have one which finishes more quickly.
15:05:41 <geekosaur> crucial to this is that it never produces a value, because thats the only way it can be any possible type
15:06:17 <sdegutis> Cale: ahhh
15:06:19 <Cale> Well, depending on what your notion of value is
15:06:25 <sdegutis> hi
15:06:29 <Cale> _|_ is a perfectly good *value* most of the time
15:06:56 <Cale> It's just the least defined value, for any given type.
15:20:27 <phaazon> Cale: I have more info
15:20:37 <phaazon>   | otherwise = {-# SCC "otherwise" #-} not . isHBlocked $ grid ! x ! y
15:20:46 <phaazon> that‚Äôs that line that causes the more allocations
15:21:12 <phaazon> how could I dig in that?
15:22:17 <phaazon> OMG
15:22:17 <Cale> I honestly don't know how you can make that do any fewer allocations than it's already doing. You might want to look at the generated core code to see if it looks sensible...
15:22:19 <phaazon> it was the (.)
15:22:24 <Cale> uhhhh
15:22:28 <phaazon> I removed that
15:22:30 <phaazon> for:
15:22:32 <Cale> are you at least building with -O ?
15:22:44 <phaazon>   | otherwise = {-# SCC "otherwise" #-} not $ isHBlocked (grid ! x ! y)
15:22:55 <phaazon> the function now consumes 0% alloc
15:22:56 <Cale> How are you compiling this program?
15:22:57 <phaazon> Cale: -O2
15:23:00 <phaazon> wait:
15:23:03 <Cale> wow, that's... odd
15:23:11 <Hijiri> what's SCC?
15:23:28 <Cale> Hijiri: It's a cost centre annotation for profiling
15:23:37 <phaazon> ghc -O2 -funbox-strict-fields -fprof-auto -rtsopts --make Main.hs -o tge -fforce-recomp
15:23:53 <phaazon> god that‚Äôs impressive that the issue is caused by (.)
15:24:00 <phaazon> I should look at its implementation
15:24:02 <Cale> Hijiri: It gives a name to an expression so that work done evaluating that expression will show up in profiles.
15:24:07 <scott> seems like the pragma must be interfering. surely "a . b $ c" is always compiled as "a (b c)"
15:24:09 <Cale> @src (.)
15:24:10 <lambdabot> (f . g) x = f (g x)
15:24:22 <Hijiri> Cale: thanks
15:24:30 <phaazon> Cale: the true one
15:24:35 <Cale> Yeah, a . b $ c should always compile to the same code as a (b c)
15:24:44 <Cale> If it's not, that's pretty screwy
15:24:57 <phaazon> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Base.html#.
15:25:01 <phaazon> it introduces a lambda.
15:25:09 <Cale> phaazon: That is the true one, and the lambda means the same thing
15:25:18 <scott> but it would normally be optimized out
15:25:27 <phaazon> maybe it gets optimized out with -O3?
15:25:39 <Cale> -O3 doesn't mean anything more than -O2
15:26:01 <phaazon> hm
15:26:04 <Cale> (and for a while, GHC would just silently ignore -O3 rather than clipping it to -O2, which was pretty funny)
15:26:21 <Hijiri> it's so fast it wraps around
15:26:28 <Cale> build with -ddump-simpl
15:26:39 <Cale> and -ddump-to-file
15:26:49 <phaazon> I don‚Äôt know how to read GHC Core yet
15:26:53 <Cale> do it for both versions and let's see what the difference is
15:27:01 <Cale> Ot
15:27:21 <Cale> It's really strange that you're not seeing identical behaviour, and indeed it might just be the profiler getting in the way
15:28:02 <phaazon> oh god
15:28:11 <phaazon> the dump is 10k lines long
15:28:12 <phaazon> :D
15:28:25 <scott> diff to the rescue
15:28:45 <phaazon> oh god
15:28:45 <Cale> diff won't help, because the names will likely be different
15:28:51 <phaazon> I‚Äôm gonna remove the -prof
15:28:59 <phaazon> it‚Äôs poluting everything
15:29:21 <phaazon> AHAH
15:29:26 <phaazon> 12K lines now
15:29:31 <phaazon> but at least is readable
15:29:39 <phaazon> ok, let‚Äôs see canGoNorth
15:29:48 <phaazon> it doesn‚Äôt exist
15:29:57 <phaazon> I guess it‚Äôs gotten inlined then
15:30:03 <Cale> yeah, probably
15:30:16 <phaazon> oh god, freeNearbyCells as well?
15:30:18 <phaazon> :‚Äì‚Äô
15:30:29 <Cale> The inliner is very aggressive with such things
15:30:45 <Cale> which is why it's bizarre if you're seeing different behaviour with and without (.)
15:31:20 <phaazon> yeah I‚Äôm going to diff that
15:31:24 <phaazon> I really can‚Äôt read core :(
15:31:28 <phaazon> I‚Äôd love to learn though
15:31:29 <phaazon> but hm
15:31:41 <phaazon>                                                           case ww1_s7Lj of wild4_a44z {
15:31:44 <phaazon>                                                             [] -> $sbfs1_s8YQ ww2_s7Lk sc1_s8YE;
15:31:47 <phaazon>                                                             : ds4_a5RW ds5_a5RX ->
15:31:50 <phaazon>                                                               $sbfs1_s8YQ
15:31:52 <phaazon> that looks like ASM to me :D
15:32:12 <scott> gosh
15:32:43 <shachaf> It looks more like Haskell than assembly to me.
15:32:57 <phaazon> yeah but
15:32:59 <phaazon> it‚Äôs ugly
15:33:14 <shachaf> case l of { [] -> f a b; (x:xs) ->
15:33:18 <Cale> there's stuff you can do to make it less ugly and more ambiguous
15:33:19 <shachaf> Sure, it's generated code.
15:33:21 <Hijiri> looks like just super mangled names
15:33:32 <phaazon> ok, I‚Äôd love to diff the two files
15:33:36 <phaazon> but I‚Äôm on windows
15:33:44 <phaazon> but I‚Äôm using atom
15:33:48 <phaazon> it might have some diff stuff
15:33:49 <Cale> try -dsuppress-all
15:33:52 <shachaf> diff probably won't help you for the reason Cale said
15:33:55 <Hijiri> ww = world war?
15:34:12 <phaazon> or nvm, msys.
15:34:29 <phaazon> OH
15:34:30 <phaazon> MY
15:34:30 <phaazon> GOD
15:34:34 <Cale> You'll get cleaner output (but sometimes ambiguous)
15:34:48 <phaazon> the diff is something like 10k long as well :D
15:34:52 <shachaf> ww is worker-wrapper
15:34:58 <Cale> Yeah, because all the generated names will be different
15:35:04 <Cale> every time you compile
15:35:09 <phaazon> ah
15:35:11 <phaazon> ok
15:35:20 <phaazon> -dsuppress-all then
15:35:36 <bel3atar> what is the problem with filter (`elem` [0,2..]) [1,2,3,4,5,6,7,8,10] ?
15:35:56 <phaazon> 5k linses long
15:36:01 <vapidness> Hello everyone. I have a haskell Question. I have the lambda (\e acc -> acc + 1) . I've tried a few things to reduce it to something like ( + 1 ) but I need a function that takes 2 arguments and this only takes one.
15:36:02 <Cale> bel3atar: (`elem` [0,2..]) doesn't terminate for odd values
15:36:17 <Cale> bel3atar: Because it has an infinite list of values to check against
15:36:32 <Hijiri> vapidness: const (+1) ?
15:36:41 <Hijiri> if you are ignoring e
15:36:42 <pacak> vapidness: const (\e acc -> acc + 1) ?
15:36:47 <bel3atar> too bad
15:36:47 <phaazon> Cale: main = main1 `cast` ...
15:36:51 <phaazon> what is ...?
15:36:55 <Cale> 1 `elem` [0,2..] will basically do "Is 1 == 0? No. Is 1 == 2? No. Is 1 == 4? No. ..."
15:37:00 <phaazon> is it because of -dsuppress-all?
15:37:03 <Hijiri> > const (+1) "foobar" 42
15:37:05 <Cale> phaazon: uh, yeah
15:37:05 <lambdabot>  43
15:37:24 <phaazon> oh god
15:37:25 <Cale> phaazon: -dsuppress-coercions, I think
15:37:26 <vapidness> Hijiri: That is exactly what I was looking for. Thank you so much :)
15:37:37 <phaazon> two sequenced hSetBuffering
15:37:38 <phaazon> in core
15:37:38 <Cale> I have to go to dinner, be back shortly
15:37:39 <phaazon> that‚Äôs‚Ä¶
15:37:43 <phaazon> weird.
15:37:48 <phaazon> case EVERYWHERE
15:37:51 <vapidness> pacak: Thank you :)
15:37:54 <phaazon> have a good meal Cale :)
15:39:17 <phaazon> case ww2_s7MR of _ {
15:39:18 <phaazon> SURE
15:39:19 <phaazon> :D
15:39:39 <phaazon> seriously, can you really read that :D
15:39:47 <monochrom> I can really read that.
15:39:56 <johnw> variable names don't mean anything anyway
15:40:00 <phaazon> http://lpaste.net/
15:40:08 <phaazon> have fun :D
15:40:11 <monochrom> it took some effort to learn and guess, yes. I spent some time training myself.
15:40:12 <phaazon> Cale: http://lpaste.net/
15:40:17 <init> ??
15:40:20 <phaazon> I should try that as well
15:40:28 <phaazon> to enhance performance of my Haskell
15:40:42 <phaazon> oh
15:40:43 <monochrom> but nothing a scientist cannot discover. the haskell-to-core translation is reproducible.
15:41:09 <monochrom> not only that. it is also known to be an Intelligent Design.
15:41:55 <monochrom> see, if scientists can discover the ways of nature which are possibly not intelligently designed, surely they can discover the laws of a compiler
15:42:21 <phaazon> yeah well
15:42:32 <phaazon> I won‚Äôt learn something to master an ‚ÄúIntelligent Design‚Äù
15:42:39 <phaazon> I‚Äôll learn it if it can help me improve stuff
15:42:45 <phaazon> and the case of GHC Core, it can
15:42:51 <phaazon> so I‚Äôll learn it for sure
15:43:04 <phaazon> so
15:43:16 <phaazon> how could I find back my canGoNorth function in that mud? :D
15:43:34 <monochrom> so, some reading material that actually helps: https://github.com/takenobu-hs/haskell-ghc-illustrated
15:44:22 <shachaf> Another thing that helps in reading Core is compiling small Haskell programs and reading the Core they turn into.
15:44:38 <phaazon> thanks monochrom
15:44:43 <phaazon> shachaf: yeah, definitely
15:44:43 <shachaf> And also reading some documentation on the GHC wiki (and maybe in a few papers) that tells you what the syntax means.
15:44:58 <phaazon> I‚Äôm still very suprised about the result of the profiling
15:45:06 <phaazon> that (.) is the cause of the GC stress
15:45:12 <monochrom> yes, this is why it is easy for scientists. people who know how to set up controlled experiments.
15:46:00 <shachaf> Core is actually very simple. Much simpler than Haskell.
15:46:24 <hpc> you wouldn't compile from a simple language to a complicated one ;)
15:46:59 <shachaf> I would say Core is simpler than C (which GHC used to compile into) and probably simpler than x86.
15:47:01 <phaazon> shachaf: two simple that it‚Äôs harder to read
15:47:04 <phaazon> too*
15:47:04 <shachaf> Maybe it's simpler than STG, too.
15:47:31 <phaazon> ok, but why those variable names :D
15:47:32 * hackagebot gl 0.7.2.1 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.2.1 (EdwardKmett)
15:47:33 <phaazon>     case w_s7JM of _ { I# ww1_s7JQ -> $wa ww1_s7JQ w1_s7JN }
15:47:39 <phaazon> barely readable
15:47:41 <cmccann> hpc: counterexample - compiling to javascript
15:47:50 <pacak> hpc: Why not? There are a bunch of languages compiling into JavaScript. Brainfuck -> JavaScript compiler breaks your rule.
15:47:59 <hpc> i like to pretend that doesn't exist
15:48:08 <hpc> javascript is a great language to write in
15:49:00 <cmccann> hpc: says the guy who wrote acme-php
15:49:16 <pacak> hpc: So you are one of those strange people...
15:49:24 <shachaf> phaazon: What part of it is the problem?
15:49:55 <hpc> cmccann: bad example, i had to try really hard with that package ;)
15:50:00 <shachaf> I'll rename it a bit for you: case n of { I x -> wa x y }
15:50:03 <hpc> try acme-microwave :D
15:50:13 <johnw> case x of _ { I# y -> $wa y z }, does that solve your issue?
15:50:21 <monochrom> if you use dsuppress-uniques, you will get "case w of _ { I# ww1 -> $wa ww1 w1 }". however, you will have a slight chance of name clash, but I haven't seen a scenerio that really hurts.
15:50:38 <hpc> but seriously, javascript is basically lisp with... differently terrible syntax
15:50:40 * hpc ducks
15:50:48 <shachaf> hpc: No language bashing in here, please.
15:51:00 <cmccann> hpc: acme-microwave is beautiful, that is true
15:51:20 <hpc> shachaf: not bashing; they're both good languages but syntax isn't their strength
15:51:28 <coltfred> I see people saying that the FTP proposal for 7.10 is the way to go, but I don't see anyone arguing on the other side. Is there actually significant opposition?
15:51:34 <phaazon> hm
15:51:36 <shachaf> The only language that can be bashed is the Bourne shell, and that's already been done.
15:51:45 <hpc> they're strict functional languages with expensive anonymous function syntax
15:51:53 <monochrom> haha
15:51:53 <hpc> (expensive in characters)
15:52:06 <hpc> perl is similar, but with loads more string manipulation and loads of semantic issues as well
15:52:32 * hackagebot snappy-conduit 0.1.0.0 - Conduit bindings for Snappy (see snappy package)  http://hackage.haskell.org/package/snappy-conduit-0.1.0.0 (toru_tomita)
15:52:40 <hpc> read perlreguts sometime, if you want to learn about a totally different form of compiler than most people ever deal with
15:56:49 <phaazon> hm
15:56:56 <phaazon> ok, it‚Äôs catMaybes that eat all the time
15:57:09 <phaazon> that eats all the GC %time*
15:57:23 <phaazon> I should use something else than catMaybes then‚Ä¶
15:57:56 <monochrom> phaazon: one thing to note. in Haskell, "case expr of { variable_here -> ...}" we do not expect expr to be evaluated to WHNF just because of the case. however, in Core, if you see that, expr is evaluated to WHNF. Core's "case" always does.
15:58:52 <monochrom> for example, "sean :: Maybe a -> (); sean x = seq x ()" will give you "case x of { __DEFAULT -> () }"
15:59:49 <monochrom> compare to "bean x = case x of v -> ()" of the same type
16:01:40 <shachaf> Core makes this so explicit that it writes case e of x { ... }
16:01:59 <Scriptonaut> hey guys, how would you represent a super basic Node or Graph type. I started making it, basically the same way I made a Tree type earlier, but I ran into a problem. Lets say I have node A, and it points t B, but B points back to A. I would get caught in a loop creating the graph because I would create A, with a node B, and then node B, and create A, and create B, etc. How would you guys make a Graph type
16:02:01 <phaazon> monochrom: I see
16:02:03 <shachaf> x is the name of what you get when you force e.
16:02:09 <phaazon> it doesn‚Äôt solve my catMaybes issue though
16:02:20 <shachaf> This is documented in https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
16:02:23 <phaazon> I‚Äôll rewrite that with a strict fold
16:02:24 <vapidness> Why can't I reduce (#+) s1 s2 = foldSet insert s1 s2 to (#+) = foldSet insert ?
16:03:02 <Scriptonaut> I was considering using a Map type, so then I wouldn't make duplicates
16:03:18 <shachaf> vapidness: I don't know, why can't you?
16:04:01 <cmccann> Scriptonaut: well, you can use laziness to make data structures that contain cycles
16:04:41 <ReinH> Scriptonaut: Well, a graph can be represented as a list or map of [(node, [key])] where nodes are uniquely identified by keys.
16:04:44 <cmccann> Scriptonaut: the downside is that you have to rebuild everything to make a modified version
16:05:28 <cmccann> Scriptonaut: if you intend to do anything that involves creating modified graphs rather than just walking between nodes in a static graph, a Map is a good choice
16:05:32 <ReinH> Scriptonaut: This is the approach that Data.Graph uses http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Graph.html
16:07:19 <cmccann> Scriptonaut: basically, you need to take into account what you plan to do with the graphs before deciding
16:08:34 <vapidness> shachaf: I can reduce it to (#+) s1 = foldSer insert s1 but if I get rid of s1 ghc tells me that no instance of Eq arises from use of insert and that the type variable is ambiguous. Success I just put in my type definition and it worked :) Thank you
16:08:35 <csd_> What replaces Control.Monad.Instances? I see that it's deprecated.
16:09:00 <shachaf> vapidness: OK. Posting your full code and full error usually helps with questions like these.
16:09:19 <shachaf> vapidness: What you ran into is called the monomorphism restriction. Writing an explicit type signature is probably the best way to fix it.
16:09:25 <shachaf> @where mr
16:09:25 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:09:40 <Scriptonaut> cmccann, ReinH, I'm just going to be doing a shortest path search over it
16:10:06 <vapidness> shachaf: Thank you :)
16:10:09 <geekosaur> csd_, I believe the things in it were moved to their proper places. so most of it will be in Data.Functor
16:10:26 <Scriptonaut> here's the problem I'm having, I'm defining fromList :: [(NodeId, [Int, NodeId])] -> Node
16:10:46 <Scriptonaut> you pass it a list of "nodes", where NodeId is a string, and each node has a list of neighbors
16:10:51 <csd_> geekosaur: ok thanks
16:11:41 <Scriptonaut> ah I just realized I'm doing it wrong anyways
16:11:47 <Scriptonaut> I think I'll go the map route
16:12:45 <csd_> geekosaur: LYAH treats the "function monad" located in that library as being equivalent to the Reader monad. this doesn't seem correct though. do you know anything about this?
16:13:00 <hpc> @src Reader
16:13:00 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:13:02 <geekosaur> Reader is just a newtype
16:13:15 <hpc> newtype Reader r a = Reader {runReader :: r -> a}
16:13:17 <geekosaur> well, in mtl2 Reader is a type alias for ReaderT Identity
16:13:19 <hpc> they're exactly the same
16:13:45 <geekosaur> but it's still just a newtype over ((->) r)
16:14:28 <csd_> oh i see, the reader monad can return basically after the 'a' is supplied
16:17:37 * hackagebot Win32-notify 0.3.0.1 - A binding to part of the Win32 library for file notification  http://hackage.haskell.org/package/Win32-notify-0.3.0.1 (GregWeber)
16:17:40 * hackagebot pgdl 7.3 - pgdownloader  http://hackage.haskell.org/package/pgdl-7.3 (sifmelcara)
16:18:29 <ski> csd_ : please consider referring to it as "environment monad" or "reader monad" instead of "function monad"
16:18:48 <csd_> ski: i'm just using the language from LYAH
16:18:57 <ski> ok
16:19:32 <ski> (i still think that term is more bad than good)
16:21:21 <Hafydd> What is wrong with it?
16:22:54 <ski> the point is to emphasize the `(rho ->)' part of `rho -> a', not all of it (or only the `(->)' part)
16:24:15 <ski> (also, mathematically, `\a. (s -> a * s)' and `\a. ((a -> o) -> o)' are also monads, why wouldn't they also be "function monads" ?)
16:24:40 <glguy> Those are the function tuple and function function monads
16:25:08 <ski> the environment monad is specifically related to what in math is called "pointwise" .. there's many other ways to combine functions than this
16:25:10 * glguy goes back to not responding
16:25:30 <geekosaur> nice sneaking Cont in there :p
16:26:15 <hpc> haskell 2016 proposal: rename ContT to SneakingThingsInThereT
16:26:34 <ski> (`x * y' is said to have been defined in a pointwise way if `(x * y)_i' is defined to mean `x_i * y_i', for any `i'. here `i' is the environment value that is distributed)
16:27:54 <ski> (another potential way to define a combination `x * y' is e.g. composition, or `(x * y)_i' defined as `sum_{j + k = i} x_j * y_k')
16:28:15 <zipper> I'm trying to get the current year but the only way I can get it it's in the IO monad. This is what I have...
16:28:17 <zipper> getCurrentTime >>= return. show . utctDay >>= return . takeWhile (/='-')
16:28:25 <zipper> > getCurrentTime >>= return. show . utctDay >>= return . takeWhile (/='-')
16:28:26 <lambdabot>  Not in scope: ‚ÄògetCurrentTime‚ÄôNot in scope: ‚ÄòutctDay‚Äô
16:28:33 <Lokathor> well, i think the biggest point in the favor of Reader Monad over Environment Monad is that the newtype is called Reader
16:28:53 <ski>   liftM (takeWhile (/='-') . show . utctDay) getCurrentTime
16:29:21 <kadoban> acme-year to the rescue?
16:29:30 <ski> Lokathor : as you please. it's acceptable
16:29:51 * ski prefers the other, since it's the term used in many of the original papers
16:29:59 <cmccann> zipper: just look at a calendar and hardcode it, that's how you get the current date outside IO :P
16:31:04 <Lokathor> zipper: there's no way to check the current date without using IO that would make much sense, but you could check the date in IO and then pass that to something that isn't IO
16:31:36 <zipper> Lokathor: Yeah I want to use it in a yesod function that takes text
16:32:38 * hackagebot atlassian-connect-core 0.5.0.0 - Atlassian Connect snaplet for the Snap Framework and helper code.  http://hackage.haskell.org/package/atlassian-connect-core-0.5.0.0 (RobertMassaioli)
16:33:07 <Lokathor> zipper: showGregorian might be what you want? It turns a Day into a String, which you can then use Data.Text.pack on
16:34:23 <yukko> are actions in the STM monad atomic?
16:34:45 <yukko> or do i have to do things that i need to be atomic inside of atomically
16:34:59 <Lokathor> you can't do atomic inside of an atomic block, i know that
16:35:10 <yukko> hmm
16:35:33 <Lokathor> atomically :: STM a -> IO a
16:35:40 <zipper> Lokathor: The only way I can get a value of type day AFAIK is from the IO monad. With getCurrentTime
16:37:02 <Lokathor> zipper, yes, you can't really check the current time from anywhere except the IO monad, it wouldn't quite make sense within haskell's model of the universe. IO is for anything that talks to the system, so you can't ask the system what time it is without it.
16:37:21 <yukko> it seems like STM actions arent atomic unless theyre in an atomically block
16:37:47 <yukko> oh but then you need atomically anyway to run them in the io monad, so i think they are atomic, since the only way you can run them is atomically
16:37:48 <orbisvicis> the lint tool on lpaste, what is it ?
16:37:53 <glguy> hlint
16:38:12 <Lokathor> yukko, i'm not totally familiar with things, but that sounds right.
16:38:45 <Lokathor> you just can't do a transaction within another transaction, if you for some reason think that you'd need to do that
16:39:23 <orbisvicis> glguy: awesome, thanks
16:40:04 <yukko> Lokathor yeah, thats true, thank you for your help :)
16:43:50 <zipper> cmccann: LOL you were right
16:45:21 <vapidness> I'm on a reduction quest tonight. -- (#?) x = foldSet (\e isMember -> x == e || isMember) False. I'm trying to remove the lambda so far I can get  (#?) x = foldSet (flip(const(==x))) False which will take care of the first predicate but I cannot figure out how to add the or. I have been messing around with composition on paper but still not sure.
16:46:49 <cmccann> yukko: yes, atomically is the only way to run an STM transaction
16:57:40 * hackagebot lucid-svg 0.4.0.2 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.4.0.2 (jeffreyrosenbluth)
17:03:34 <acowley> Does anyone know how the package db names like "x86_64-osx-ghc-7.8.3" are produced?
17:03:42 <acowley> Or how I could figure out what name it will be?
17:03:56 <tommd> $ARCH-$OS-$COMPILER?
17:04:13 <acowley> Is that what it always is?
17:04:27 <hpc> not always, but there's some sort of convention and it's easy to figure out
17:04:32 <tommd> acowley: No promises from me, but that's what I've always seen.
17:04:34 <hpc> or maybe always
17:04:41 <acowley> Could I get cabal-install to tell me what it would use?
17:04:41 <hpc> who knows with packaging
17:04:50 <tommd> ... or ghc-pkg.
17:04:58 <hpc> if you don't know which to use, compile it yourself
17:05:01 <acowley> "maybe always" is right every time, 70% of the time when it comes to packaging
17:05:14 <hpc> but... you should know what to use because it's just whatever your system is
17:05:26 <hpc> oh, WOULD use
17:06:19 <acowley> I'm writing some nasty scripting that roots around in package databases
17:06:33 <acowley> and I'd like to be able to predict the path I'll need to check
17:06:48 <Cale> phaazon: Did you get anything sorted out? You linked me to lpaste.net, but not to your paste.
17:07:24 <geekosaur> acowley, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/Cabal-1.16.0/Distribution-System.html and ghc -e?
17:08:41 <Javran> one GADTs question here: taking eval :: Exp a -> a as an example, now I want to add variables to the interpreter, what would the environment become? something like "env :: [(String, ?)]" doesn't seem to be right.
17:09:18 <hpc> environment as in an OS environment?
17:09:19 <tommd> Javran: Can you not enumerate your embedded languages types to produce a sum type in Haskell?
17:09:28 <hpc> because that's Map String String
17:10:09 <tommd> Javran: data Value = IntVal Int32 | StringVal String | FloatVal Double ...
17:10:22 <acowley> geekosaur: That's a good idea!
17:10:31 <Javran> tommd: but that goes back to the version without GADTs
17:10:38 <ttt_fff> what is a good way to handle exceptions in haskell? when something goes wrong, I don't want to just throw an error message; I want to throw an SvgTree (which can be writen out to file) describing what went wrong
17:10:46 <tommd> Javran: Right, right.
17:11:11 <acowley> geekosaur: It doesn't seem to have anything whose Show instance is that full string
17:11:34 <tommd> So you have a GADT AST where the types of the embedded language are carried by the constructors.  Could we see a paste for clarity?
17:11:44 <hpc> ttt_fff: you can write an exception handler that writes the error string to an svg file
17:12:07 <hpc> which is probably going to be the most generically useful approach, since it catches everything properly
17:12:47 <acowley> I guess this is where the path comes from: http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/Cabal-1.16.0/Distribution-Simple-InstallDirs.html
17:16:58 <Denommus> hm
17:17:05 <ttt_fff> hpc: understood, thanks
17:17:08 <Denommus> how to include a third-party JS library in a GHCJS project?
17:17:43 <Lokathor> does it make sense to have a typeclass for types that aren't polymorphic? Or would a person normally just write out the functions without grouping them into a typeclass?
17:18:04 <Javran> tommd: http://lpaste.net/120310 what about this?
17:18:11 <Denommus> Lokathor: why would you write the typeclass in this case?
17:18:18 <orzo> i'm going to ignore your advise, but i'm curious about the general opinion anyway.  Should ExistentialQuantification be avoided for a serialization library serializing standard binary forms describied in RFCs and the like?
17:18:20 <Denommus> Lokathor: why the mental effort to have an additional concept?
17:18:22 <hpc> Lokathor: perhaps describe the specific types?
17:18:32 <hpc> typeclasses are for API commonalities
17:18:54 <hpc> (to give a simplified description)
17:19:10 <Lokathor> I'm imagining a "Displayable" typeclass that will have charAt :: Int -> Int -> Char and colorAt :: Int -> Int -> Color operations
17:20:08 <hpc> what would be the instance?
17:20:18 <hpc> instances, rather
17:21:05 <Lokathor> generally, some sort of "world" value for normal gameplay, but then screens (such as status and inventory) could also be instances
17:21:18 <Javran> I guess I should distinguish variable of different types, but no idea for its environment, it's possible to do "eval :: Exp a -> [(String, Int)] -> [(String, Bool)] -> a", but it doesn't look cool.
17:22:37 <rjayatilleka> Hello! I'm a Haskell beginner and new to the IRC channel (I hang around on /r/haskell and StackOverflow).
17:22:49 <Cale> rjayatilleka: Welcome!
17:22:58 <Lokathor> it seems my options are either a typeclass that both special screens and the main world have instances of, or an intermediary datatype that they both convert to
17:23:00 <Cale> Feel free to ask any questions you might have :)
17:23:15 <acowley> Yeesh, I still can't figure out how to generate the same path cabal is using
17:23:29 <hpc> Lokathor: you can also write a data type that has enough information for both
17:23:36 <LordBrain> acowley, ghc-pkg will get it to you...
17:23:41 <hpc> Lokathor: if all you need from the screens is their visual data
17:24:18 <acowley> LordBrain: With which command? I looked at its help but didn't spot a likely suspect.
17:25:41 <Lokathor> hpc, that might work. Something like screenToDisplay :: Screen -> (Int -> Int -> (Char,Color)) and worldToDisplay :: World -> (Int -> Int -> (Char,Color))
17:25:47 <rjayatilleka> I've been working on a toy library that exchanges money between currencies. I started out with some currency types (USD/YEN/etc) and `data Money c = Money Int`.
17:26:33 <LordBrain> acowley, there is probably a specific option, but if all else fails ghc-pkg list | head -n 1
17:26:39 <Lokathor> rjayatilleka, you might want to consider Integer over Int if you expect money values to get at all large. I know that yen totals often get pretty hefty
17:26:41 <geekosaur> pyanfar:8654 Z$ ghc-pkg field mtl-2.1.3.1 library-dirs
17:26:41 <geekosaur> library-dirs: /opt/local/lib/x86_64-osx-ghc-7.8.3/mtl-2.1.3.1
17:26:50 <LordBrain> for unix systems
17:27:33 <geekosaur> (also see import-dirs, or `ghc-pkg describe $package` for a full list)
17:27:46 <rjayatilleka> But my problem with the phantom-typed money is that storing multiple money in different currencies is hard. I tried using Typeable, but I just ended up throwing (Typeable c) constraints everywhere. I'm wondering if maybe I should just drop the phantom type as a whole.
17:27:51 <LordBrain> there's actually multiple databases, because there is a user one and a system one separate
17:28:31 <rjayatilleka> Lokathor: It's just something I'm playing with to get to know some advanced type system stuff better.
17:28:47 <Cale> rjayatilleka: yeah, it depends on how you want to use the type, you could make an existential, but in many cases it's more reasonable just to have that be runtime data rather than compile-time checked
17:29:15 <hpc> rjayatilleka: a single data type that has all the info you might need could be
17:29:37 <hpc> data Currency = Currency {Symbol :: Char, value :: Double, conversion :: Double -> Double}
17:29:51 <hpc> conversion being (this -> something standard like euro)
17:30:36 <acowley> LordBrain: Oh, great idea! Any idea how to convince "cabal sandbox hc-pkg" to just show the "user" db? (in this case, sandbox)
17:30:42 <Cale> Probably want some Fixed type rather than Double though. Double is kind of terrible for careful currency representation.
17:30:50 <hpc> yeah
17:30:51 <rjayatilleka> hpc: Is `value` meant to store a given money value?
17:30:58 <hpc> yes
17:31:06 <hpc> so if you had $5
17:31:07 <geekosaur> cabal sandbox -- hc-pkg --user?
17:31:08 <tommd> Javran: So you want something like "A Type Preserving Compiler in Haskell".  Which depending on your needs can be more pain than value.
17:31:09 <acowley> LordBrain: I can fake it by passing list an unknown package and pulling out the second line of output
17:31:18 <acowley> geekosaur: That's what I'd thought, but it doesn't work
17:31:29 <hpc> Currency {Symbol = '$', value = 5, conversion = (* 2.2)} or whatever the rate is atm
17:31:32 <tommd> Javran: There was a more recent (2012?) ICFP or Symposium publication along these lines as well.
17:31:40 <rjayatilleka> Well, that definitely makes sense.
17:32:46 <rjayatilleka> Right now I'm using DataKinds, a type `data Currency = USD | EUR | ...`, and `data Money :: Currency -> * where Money :: Int -> Money c`.
17:33:58 <rjayatilleka> All my problems with this would be solved if there was just a way to say all types of kind `Currency` have derived `Typeable`, and have GHC infer for any `Money c` that `Typeable c`.
17:34:04 <Javran> tommd: thanks for the info, I googled and found this one: http://okmij.org/ftp/tagless-final/course/IntroHOIF.hs seems like the environment is "encoded" like natural numbers.
17:34:11 <rjayatilleka> Is there a way to do that?
17:34:30 <geekosaur> acowley, cabal exec -- ghc-pkg list --user
17:34:37 <rjayatilleka> AutoDeriveTypeable does the first part, but not the second.
17:34:43 <geekosaur> apparently hc-pkg overrides the database selection
17:35:00 <Cale> rjayatilleka: Almost. You can put a Typeable dictionary inside the Money constructor:  Money :: Typeable c => Int -> Money c
17:35:24 <Cale> rjayatilleka: and then pattern matching against the Money data constructor will discharge a Typeable constraint on c.
17:35:45 <Cale> But you have to pattern match
17:35:52 <yac> what is the library to talk to postgresql nowadays?
17:36:04 <yac> hsql says it's unmaintained since 2007
17:36:31 <rjayatilleka> I tried that and hit the problem that it requires pattern matching on that. So if I have a function such as `exchange :: Rate a b -> Money a -> Money b`, I have to put a `Typeable b` on the signature.
17:36:31 <yac> well, https://wiki.haskell.org/HSQL says it
17:36:42 <rjayatilleka> Is there a way to pattern match the return value?
17:36:43 <hpc> hdbc generally
17:36:48 <Cale> Well, no :)
17:37:04 <Javran> seems like I need to read that "finally tagless" paper, not sure how many background is required though.
17:37:07 <Cale> Because that's what you're required to construct there
17:37:31 <rjayatilleka> Yeah. That's what I figured.
17:37:43 <Cale> and when you use the Money data constructor, it's going to implicitly store a Typeable dictionary into the value, so one had better be available
17:38:05 <rjayatilleka> I think I'll just give up on the phantom typed Money and move this to runtime.
17:38:10 <geekosaur> yac, perhaps something like opaleye?
17:38:28 <rjayatilleka> Thanks Cale.
17:38:37 <acowley> geekosaur: Yeah, it seems I'll have to handle sandboxes and non-sandboxes differently
17:38:43 <Cale> rjayatilleka: What you could do if you wanted to press on would be to put Typeable dictionaries into the Rate values as well.
17:39:07 <geekosaur> seems to work for both here?
17:39:10 <rjayatilleka> Oh? Hey I didn't think of that.
17:39:16 <rjayatilleka> I'm gonna try that!
17:39:24 <rjayatilleka> No more hints though. Thanks!
17:41:55 <LordBrain> What is tagging overhead in an interpretter?
17:42:14 <LordBrain> for a DSL
17:42:46 <LordBrain> In terms of haskell, is this performance loss due to extra Constructors ?
17:44:10 <LordBrain> Javran, that paper you mentioned is relevant, as this question is raised in my mind when I read the abstract
17:45:22 <Javran> LordBrain: I guess I should absolutely read that
17:45:33 <bitemyapp> _um: I agree, for whatever it's worth.
17:45:40 <bitemyapp> _um: was it necessary that you leave though?
18:03:30 <Lokathor> does vty actually support a way to directly move the cursor and write characters to the output?
18:04:25 <Lokathor> I can use a DisplayContext to generate Write values, but I don't see where I execute those Write values, since I don't have a  Ptr Word8 to call runWrite with
18:07:44 * hackagebot gl 0.7.2.2 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.2.2 (Polarina)
18:14:32 <Denommus> hm
18:14:53 <Denommus> if I want to use blaze-html with ReactJS I must find some way to convert from Html to the type that React accepts
18:16:32 <nshepperd_> aww, rjayatilleka left
18:16:53 <nshepperd_> I was going to say you can use GADTs to tag your existential box
18:17:02 <nshepperd_> instead of using typeable
18:20:18 <nshepperd_> 'data DynamicMoney = forall (c :: Currency). D (SCurrency c) (Money c)' sort of thing
18:20:59 <shachaf> nshepperd_: I was reading http://arxiv.org/pdf/1502.01852v1.pdf yesterday. Maybe your thing is inspired by some of that.
18:24:56 <nshepperd_> shachaf: wow, this is interesting
18:25:26 <shachaf> OK, maybe not. :-) In that case you might be interested.
18:27:16 <nshepperd_> no, I haven't read this before :)
18:30:23 <Welkin> is there a simple way to transpose a Vector (Vector) ?
18:39:14 <rvxi> anyone use haste?
18:40:07 <Welkin> hm
18:40:41 <Welkin> I just converted it from Vector (Vector a) to [[a]], applied transpose and then converted back
18:43:07 <solatis> hey all, i need some advice / second opinion
18:43:51 <solatis> when starting out a new project, what is generally considered best to do your testing against? all ghc versions i can come up with, or would 7.8+ for a new project be considered enough?
18:46:12 <Welkin> oops
18:46:17 <orzo> solatis: doesn't that depend on what you want to do with your project?  If it's going to be packaged for a linux distro, you might want to test against the version distributed with the distro.  Otherwise, I don't see why you wouldnt use 7.8+
18:46:19 <Welkin> Vector.fromList is strict
18:46:28 <Welkin> can't use it on an infinite list
18:47:45 <solatis> orzo, ok i understand what you're saying
18:48:33 <solatis> it's not intended to be packaged for a specific distro, but i don't want to be too restrictive
18:48:49 <solatis> i'm currently running into some issues with ghc 7.4.2, and i wonder how much i should care..
18:50:20 <orzo> debian has 7.4.1 but will likely release in a few months with 7.6.3
18:50:41 <solatis> i assume that's debian-stable and not sid ?
18:50:46 <orzo> yeah
18:50:55 <solatis> what about RHEL ?
18:51:01 <solatis> does that even have GHC ?
18:51:04 <orzo> dunno
18:51:25 <t4nk021> Hey guys.
18:51:27 <orzo> i just checked the debian stats with ghc --version
18:51:34 <t4nk021> Let's say I got a list of points
18:51:35 <orzo> i don't run red hat
18:51:45 <t4nk021> [(a,a)]
18:51:52 <solatis> right
18:52:13 <t4nk021> and if there are more than 2 points in the same y coordinate
18:52:18 <t4nk021> I just want the top and the bottom one
18:52:28 <t4nk021> Can I create a filter function for that?
18:52:34 <solatis> ah, GHC is in EPEL, not RHEL / CentOS by default
18:53:14 <solatis> ah, great
18:53:21 <solatis> EPEL provides ghc 7.0.4 :/
18:53:37 <KaneTW> "i went too far with abstractions"
18:53:40 <KaneTW> only with haskell.
18:53:48 <solatis> KaneTW, or java...
18:53:58 <orzo> t4nk021: groupby and then map to pairs of minimum and maximum
18:54:08 <KaneTW> i'm just laughing at some of the stuff i did
18:54:29 <solatis> KaneTW, https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
18:54:33 <KaneTW> started out with a typeclass class Reciever c m where receive :: c -> IO m
18:54:55 <solatis> that's going too far with abstractions on a whole other level :)
18:55:13 <KaneTW> haha
18:55:47 <solatis> anyway, you can go too far with abstractions easily in a lot of languages
18:56:01 <KaneTW> thought "what if receive returns something that's not in the IO monad, for testing or something" and went as far as writing the a level type family ReceiveMonad c :: * -> * before i stopped myself and said that
18:56:20 <solatis> what i find important is that a language allows me to *not* go too far with abstractions, but lets me refactor new abstractions into it very easily
18:56:21 <KaneTW> it is nearly 4am to be fair
18:56:36 <KaneTW> yeah
18:56:47 <Cale> solatis: Why link to fake examples, when you could link to real code that people are using in production? https://github.com/gpc/grails-searchable/blob/master/src/groovy/grails/plugin/searchable/internal/compass/mapping/ClosureSearchableGrailsDomainClassCompassClassMapper.groovy
18:57:06 <solatis> Cale, ouch, my eyes
18:57:49 <KaneTW> but now i'm really happy with the solution i went with and it's actually quite satisfying, certainly more so than i remember being in oop languages
18:57:58 <solatis> i believe java even has a "design pattern factory pattern" ... :/
18:58:03 <Cale> actually, it looks like this code has been improved since I was last here...
18:58:16 <Cale> It used to have a bunch of Java code which was *way* more ridiculous
18:58:50 <Cale> yeah, yeah, here we go: https://github.com/gpc/grails-searchable/tree/v0.6.8/src/java/grails/plugin/searchable/internal/compass/mapping
18:59:05 <Cale> SearchableGrailsDomainClassCompassClassMapperFactory.java
18:59:06 <Cale> lol
18:59:41 <Cale> oh, no wait, this stuff is still there in master, I just missed it
19:01:16 <Axman6> does that factory have a factory factory?
19:03:18 <KaneTW> in Data.Configurator, is subscribe called when the config is initially loaded?
19:04:49 <t4nk021> Hi uh orzo, how do I express the groupBy function?
19:05:07 <t4nk021> I am trying to compare the elements in the list to each other
19:06:37 <Cale> t4nk021: Do you know about the span/break functions?
19:06:42 * ski . o O ( "Partial Evaluation of Computation Process - An Approach to a Compiler-Compiler" by Yoshihiko Futamura in 1999 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.10.2747> )
19:06:46 <t4nk021> nope.
19:07:03 <Cale> > span even [2,4,5,6,7,8]
19:07:05 <lambdabot>  ([2,4],[5,6,7,8])
19:07:05 <ski> > break isSpace "This is a dream"
19:07:06 <lambdabot>  ("This"," is a dream")
19:07:30 <Cale> Might be useful :)
19:07:45 <t4nk021> hm.
19:07:51 <gcganley> :t break
19:07:52 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
19:08:03 <gcganley> :t span
19:08:04 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
19:08:26 <Cale> (the only difference between them is that the sense of the condition is inverted)
19:08:38 <t4nk021> it will group the similar y coordinates together.
19:08:40 <t4nk021> that given a list of points [(a,a)]
19:09:10 <Cale> The condition satisfied by the groups in the result of groupBy f xs is that if x is the first element of a group, and y is any other element of that group, then f x y holds.
19:10:01 <Cale> t4nk021: Oh, are you not talking about the groupBy function in Data.List?
19:10:04 <Cale> :t groupBy
19:10:06 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
19:10:09 <Cale> ^^ that one
19:10:11 <solatis> :)
19:10:31 <solatis> i admit to making use of a lot of factories in my c++ code
19:11:21 <solatis> but i think the factory pattern is more of proof that OOP is broken by design
19:11:40 <solatis> in FP you would just solve that problem with a callback
19:12:03 <solatis> in OOP, you have to resort to stupid factories
19:12:30 <t4nk364> how can you write groupby such that it compares against elements inside the list?
19:12:32 <Cale> I think it's actually not a problem with OOP, but a problem with certain typed "OOP" languages.
19:13:08 <Cale> That problem being that the implementation of the methods of an object are tied to its type, while they really have no right to be.
19:14:21 <platz> seems to be a legacy issue with Java.  everyone has lambdas now and 'callbacks' are pervasive even in java
19:14:37 <Cale> Hence, you need a factory to generate your objects just so that you can fail to be specific about how the methods are being implemented.
19:15:41 <gcganley> im thinking of writting a dhcp server in haskell as an excercise, any suggestions on a library that can help me handle network packets?
19:15:48 <ski> ("the implementation of the methods of an object are tied to its type" is not the case in O'Caml)
19:16:31 <ReinH> gcganley: Well, there's http://hackage.haskell.org/package/network-house. I'm not sure if it's any good.
19:17:30 <t4nk364> Hi guys, how can I write a groupBy function that will group a list of points by similar y coordinates?
19:17:40 <benzrf> t4nk364: tricky
19:17:44 <t4nk364> I am trying to do something like groupBy (\x y -> \u v -> y == v) xs
19:17:58 <benzrf> t4nk364: i feel like the easiest thing to do would be to just sort it
19:18:08 <benzrf> oh i see
19:18:13 <benzrf> t4nk364: why not do that?
19:18:20 <t4nk364> its complaining
19:18:25 <ski>   groupBy (equating snd)
19:18:29 <benzrf> :t equating
19:18:31 <lambdabot> Not in scope: ‚Äòequating‚Äô
19:18:36 <benzrf> :?
19:18:52 <Cale> I think the way method implementations are tied to classes is kind of a cargo cult from early typed OO languages, back when closures were a bit of a luxury, so you wouldn't want to have more of them than you could get away with.
19:19:00 <ski> @let equating f = (==) `on` f
19:19:01 <monochrom> \(x,y) -> \(u,v) -> y == v
19:19:03 <lambdabot>  Defined.
19:19:05 <ski> @type comparing
19:19:06 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
19:19:14 <ski> @type equating
19:19:15 <lambdabot> Eq b => (a -> b) -> a -> a -> Bool
19:19:49 <Cale> t4nk364: Did you mean to write (\(x,y) (u,v) -> y == v) ?
19:20:05 <t4nk364> oh the parenthesis worked thanks monochrom
19:20:17 <Cale> t4nk364: You can't write pairs without them :)
19:20:19 <monochrom> not just that, but also the commas
19:20:46 <t4nk364> thanks. Just to be clear
19:20:49 <t4nk364> if I had like 3 of those
19:21:13 <monochrom> "those" = ?  Concrete examples?
19:21:21 <t4nk364> (\(x,y) -> (u,v) -> (a,b) ->  a+x+u == 10)
19:21:33 <t4nk364> would that take consecutive pairs?
19:21:45 <monochrom> no
19:21:48 <t4nk364> so each 3 consecutive pairs if they add up to 10 would be grouped
19:21:56 <gcganley> ReinH: whats house?
19:22:35 <ReinH> gcganley: Dunno.
19:22:47 <ReinH> gcganley: A thing that lead to the development of some networking libraries, including dhcp ;)
19:23:20 <ski> > [(x,y,z) | x:y:z:_ <- tails [2,8,1,7,3],x + y + z >= 10]
19:23:22 <lambdabot>  [(2,8,1),(8,1,7),(1,7,3)]
19:24:10 <ski> > [(x,y,z) | x:y:z:_ <- tails [2,8,1,5,0,7,3],x + y + z >= 10]
19:24:12 <lambdabot>  [(2,8,1),(8,1,5),(5,0,7),(0,7,3)]
19:24:45 <gcganley> ReinH: I've never written a netowrk application. I just wanted something to work on
19:32:50 <ReinH> gcganley: well you should do that then :)
19:57:35 <KaneTW> hmm
20:01:48 <lpaste> KaneTW pasted ‚ÄúThis doesn't compile‚Äù at http://lpaste.net/7816088936752611328
20:02:06 <lpaste> KaneTW pasted ‚ÄúBut this does‚Äù at http://lpaste.net/1369223140034478080
20:02:44 <KaneTW> any ideas what's causing that
20:02:59 <johnw> is this the get from State?
20:03:00 <shachaf> KaneTW: I think you have more clues than the rest of us. :-)
20:03:06 <johnw> oh, duh
20:03:09 <johnw> I have the least clue
20:03:11 <shachaf> (You have the error message.)
20:03:16 <KaneTW> oh
20:03:22 <KaneTW> error message is that types don't match
20:03:25 <ski> KaneTW : looks like DMR
20:03:32 <KaneTW> yeah
20:03:47 <shachaf> I've never had GHC just print "types don't match" as an error.
20:03:47 <KaneTW> but i tried NoMonomorphismRestriction and it still doesn't
20:04:03 <KaneTW>     Couldn't match type ‚ÄòB.ByteString‚Äô with ‚ÄòWord16‚Äô
20:04:23 <shachaf> You're already using hpaste. Just paste the whole thing in, including line numbers, including everything.
20:04:28 <shachaf> It could be the MR, it could be MonoLocalBinds, it could be lots of things.
20:04:47 <shachaf> But it's hard to tell without the error message, and information like the type of get.
20:04:53 <KaneTW> sec
20:05:37 <lpaste> KaneTW pasted ‚ÄúOutput‚Äù at http://lpaste.net/1093653850730004480
20:06:06 <ski> .. and the type of `require' ?
20:06:09 <KaneTW> require is from http://hackage.haskell.org/package/configurator-0.3.0.0/docs/Data-Configurator.html
20:06:15 <KaneTW> require :: Configured a => Config -> Name -> IO a
20:06:21 <shachaf> Er, I meant the type of require.
20:06:27 <funfunctor> hi
20:06:33 <sveit> it seems (like with many things in haskell) there is an embarassment of riches with respect to priority queues. What is a good "default"? (i.e. like some would say Data.Vector is a good default)
20:06:44 <KaneTW> class Configured is at http://hackage.haskell.org/package/configurator-0.3.0.0/docs/Data-Configurator-Types.html#t:Configured
20:06:56 <ski> try adding `get :: Configured a => Name -> IO a'
20:07:10 <funfunctor> can someone help me get my StateT show instance to type-check, i'm having a bit of a issue understanding it
20:07:29 <KaneTW> thanks
20:07:31 <KaneTW> that worked
20:07:41 <ski> funfunctor : i see no code
20:07:52 * hackagebot base-io-access 0.4.0.0 - The IO functions included in base delimited into small, composable classes  http://hackage.haskell.org/package/base-io-access-0.4.0.0 (bheklilr)
20:08:15 <funfunctor> ski: http://pastebin.com/9STxPsUR
20:08:25 <funfunctor> ski: sorry I was just pasting it ;)
20:08:37 <KaneTW> ski: any idea what the cause of that was? no MonoLocalBinds?
20:09:20 <shachaf> Once again, you're in a better position than anyone else here to answer that question. :-)
20:09:24 <funfunctor> ski: line 85 is the place to look
20:09:25 <KaneTW> yeah that wasn't it
20:09:36 <shachaf> (Only you know what extensions you have turned on.)
20:09:54 <KaneTW> oh i figured it out
20:09:58 <funfunctor> ski: the intent is to get line 88's function to work so I can fetch a string out of the state
20:10:31 <KaneTW> i was using GADTs/TypeFamilies and that switches on MonoLocalBinds
20:10:38 <funfunctor> ah oh, now that I am talking about it with someone I think I am thinking along the wrong path
20:11:08 <ski> funfunctor : you can't do that
20:11:31 <ski> `show' doesn't have `IO' in its result type
20:12:16 <ski> funfunctor : why do you want to to `show' `BTSLogger a's ?
20:12:52 <ski> funfunctor : why not define a custom function of type `BTSLogger a -> IO String', or something like that, if you really want to ?
20:13:50 <ski> funfunctor : i don't see `inspectLogName' used anywhere yet, and there's no type signature, so i've no idea what the type of it is supposed to be
20:14:16 <ski> hm, maybe
20:14:29 <ski>   inspectLogName :: Selector a -> IO String
20:14:50 <ttt_fff> i'm on vim, some extension is setting makeprg to 'makeprg=ghc  -e :q %' this makes me unhappy
20:14:57 <ttt_fff> how do I tell this prog to 'don't fucking touch my makeprg' ?
20:15:46 <ski> funfunctor : to clarify, a `BTSLogger a' does not contain any `BTSLog', so there's no `logN :: String' field to extract
20:16:24 <ski> (a `BTSLogger a' is basically a function that operates on `BTSLog's. taking one as input, and returning an `IO'-action that when run will produce another one)
20:18:46 <sdegutis> It'd be cool if there was a decent GUI lib for Haskell for OS X.
20:19:11 <funfunctor> ski: right, so basically see those primitives at the top for various debug logging levels.. the idea is for those to be wrapped up and for them to get logName (logN) /silly name I know/ from the State which is of type String
20:19:31 <funfunctor> ski: let me repaste a revisted version
20:21:24 <funfunctor> ski: alright this is slightly better http://pastebin.com/0HVN0eBx see debugBladeRF
20:23:02 <glguy> ?unmtl StateT BTSLog IO a
20:23:02 <lambdabot> BTSLog -> IO (a, BTSLog)
20:23:41 <glguy> funfunctor: You're never going to have an interesting "Show" instance for that type
20:24:09 <funfunctor> yep I just figured that
20:24:13 <funfunctor> so forget the show idea
20:24:22 <ski> funfunctor : btw, `bracket' looks potentially buggy
20:24:31 <funfunctor> plan now is for line 38 to type-check
20:24:41 <funfunctor> ski: oh?
20:25:54 <ski> that `return action' does nothing
20:25:59 <ski> (by monad law)
20:26:14 <funfunctor> sort of the whole point of this thing is so that I can just do withMyFancyLoger $ do ... and have things logged by the provided primitives
20:26:17 <ski> perhaps you meant `result <- action', and then `return result' at the end ..
20:26:47 <ski> at line 38, you're not passing an `lname' to `withBTSLogger'
20:26:48 <glguy> once you fix braacket it still has the issue that if the action fails that the log won't be "closed" (depending on what close does that could matter)
20:27:03 <funfunctor> ski: ah oh, the return was in there to get a IO action for the type checker when this is lifted into something else
20:27:24 <funfunctor> ski: oh your right!
20:28:02 <ski> @hoogle bracket
20:28:02 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:28:03 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:28:03 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:28:17 <funfunctor> ski: i'm not using that bracket, its custom
20:28:29 <funfunctor> no Control.Exception import
20:28:44 <funfunctor> so now I have a BTSLogger String vs String type-mismatch
20:28:51 <funfunctor> on line 38
20:29:04 <ski> yes. glguy was saying that your one isn't robust in the face of exceptions
20:29:33 <funfunctor> ah ok, yes I know. I am purposefully disregarding exceptions here
20:29:35 <glguy> Ski: OK, looks like I'm redundant. I'll stand back!
20:29:37 <ski> funfunctor : you know .. it would help hunting the errors down if you wrote more type signatures on the relevant operations
20:30:28 <funfunctor> ski: I know, your notice I have been and some are commented out because I was backing this component out of something much larger while attempting to refactor
20:30:41 <ski> perhaps you've commented them out because you're not sure what the correct one should be ?
20:31:01 <ski> mhm
20:31:23 <funfunctor> ski: I guess I hold many in my head while I am hacking away on code
20:31:37 <funfunctor> because its a bit fluid at the moment
20:32:19 <funfunctor> before you say, I realize that's poor use of the type-system
20:32:58 <ski> funfunctor> :t debugM
20:33:31 <funfunctor> ski: so basically what I would like is a interface that allows me to do logging per haskell module prefixed with the module name (a.k.a. logN)
20:33:54 <funfunctor> ah well it does not type check at the moment
20:34:09 <ski> i only need the intended type of it
20:35:59 <funfunctor> it would be, debugBladeRF :: MonadIO m => String -> m ()
20:36:06 <funfunctor> I believe
20:36:41 <ski> that's not `debugM'
20:38:01 <sabraham> hi
20:38:59 <sabraham> A question , can somebody tell me how (W (W 1)) >>= id = (W 1)
20:39:18 <funfunctor> ski: wait no, actually it would be :: String -> BTSLog -> IO ()
20:39:24 <sabraham> id :: a->a
20:39:27 <EvanR> sabraham: check the type of id
20:39:37 <EvanR> what does a=
20:39:44 <sabraham> while  >>= needs a type a -> W b
20:40:28 <EvanR> >>= is W a' -> (a' -> W a') -> W a'
20:41:10 <sabraham> EvanR yes .. but type of id is a-> a .. isn't it?
20:41:56 <EvanR> oops >>= is W a' -> (a' -> W b) -> W b
20:42:05 <EvanR> sabraham: yeah, so solve for a
20:42:22 <EvanR> i renamed the "a" in >>= to avoid mixing them up
20:42:27 <sabraham> a' is (W 1)
20:42:39 <EvanR> a' is some type
20:42:46 <EvanR> 1 is a type ?
20:42:50 <sabraham> so (W Int)
20:42:53 <sabraham> sorry
20:43:04 <sabraham> b is Int
20:43:11 <EvanR> a' is W (W Int)
20:43:44 <sabraham> wait (W a') in (W (W Int))
20:43:50 <sabraham> so a' is W Int
20:44:06 <EvanR> the lhs of >>= needs is a', which you write W (W 1) earlier
20:44:15 <funfunctor> ski: don't worry I made a mess of this.. i'll come back to it later
20:44:18 <EvanR> so thats determines the type of a'
20:44:52 <sabraham> (W (W 1) >>= id = (W 1)
20:45:09 <sabraham> (W a) -> (a -> W b) -> (W b)
20:45:18 <regexer> Hello, people!
20:45:52 <EvanR> sabraham: ah yes. ok so a' is W Int
20:46:02 <sabraham> a is (W Int)   b in Int    (a-> W b)   is (W Int) -> (W (W Int)
20:46:08 <sabraham> but id is a->a
20:46:15 <sabraham> how does that type check
20:46:18 <regexer> let's say I have something like this "data Foo = Bar | Baz | Bum". Is there a way to get a list [Bar, Baz, Bum] :: Foo ?
20:46:19 <EvanR> sabraham: so given that, what is the a in id :: a -> a
20:47:00 <sabraham> a seems to (W Int)
20:47:15 <wz1000> Is compilation with GHC guaranteed to terminate when you use fancy extensions?
20:47:16 <EvanR> yeah because a = a'
20:47:20 <ski> sabraham : if `a = W Int' and `b = Int', then `a -> W b  =  W Int -> W (W Int)' is incorrect
20:47:31 <kadoban> regexer: make them Bounded and Enum (you can derive that automatically), and then [minBound..maxBound] :: Foo
20:48:06 <regexer> kadoban: Thanks! Will try
20:48:21 <sabraham> @ski .. can you elaborate.. I am confused
20:48:21 <lambdabot> Maybe you meant: wiki src ask
20:49:01 <ski> sabraham : if you replace `a' with `W Int' in `a -> W b', you get `W Int -> W b'
20:49:16 <sabraham> ok
20:49:19 <ski> sabraham : if you further replace `b' with `Int' in that, you get .. what do you get ?
20:49:28 <sabraham> W int -> W int
20:49:36 * ski nods
20:49:47 <ski> (modulo s/int/Int/)
20:49:55 <ski> sabraham : all clear ?
20:50:00 <EvanR> yeah so W Int = Int, wrong
20:50:19 <funfunctor> ski: No instance for (Show (BTSLog -> IO ()))  is that a sensible thing to add?
20:50:29 <ski> funfunctor : no
20:53:00 <sabraham> but the function is id
20:53:23 <sabraham> id is always  x -> x .. isn't it .. or am i wrong there ?
20:54:33 <sabraham> ok .. I got it now.
20:54:39 <kadoban> :t id :: Maybe Int -> Maybe Int
20:54:40 <lambdabot> Maybe Int -> Maybe Int
20:55:03 <EvanR> sabraham: when you use id, which is a -> a, some type will be substituted for the a
20:55:13 <EvanR> sabraham: including function types so you need to be careful
20:55:38 <sabraham> EvanR , ski .. i think i get it now... let me think on it .. thanks..
20:55:47 <EvanR> and its obviously not the a in another polymorphic signature
20:55:49 <EvanR> necessarily
20:58:12 <sabraham> yes .. i understand now. . thanks
21:00:30 <sdegutis> I was under the impression that threepenny's GUI was similar to React.JS in the sense that it draws the view for you based on a model you give it.
21:00:36 <sdegutis> I see now this is not true.
21:00:47 <sdegutis> It's very much still an imperative-UI-driven-thingy.
21:01:19 <Big_G> Is it possible to partially apply a function to an argument that isn't the first?
21:01:30 <sdegutis> Big_G: no, just create a closure
21:01:39 <sdegutis> Big_G: unless I'm wrong, of course.
21:02:04 <hiptobecubic> Haven't followed the discussion, but try hsqml if you're looking for a "declarative"-ish GUI
21:02:10 <EvanR> :t (>>= id)
21:02:11 <lambdabot> Monad m => m (m b) -> m b
21:02:15 <Big_G> sdegutis, Thanks. I figured the solution would be something like that but wanted to see if there was a Haskell way to do it
21:02:34 <Big_G> Is there a term for Haskell like Pythonista is for Python?
21:02:36 <sdegutis> Big_G: you can with sections I think
21:02:43 <hiptobecubic> It doesn't derive anything from a model, but at least you don't have to build it by packing widgets imperatively.
21:02:51 <sdegutis> Big_G: (+1) creates a function where the first arg is left open
21:02:51 <EvanR> :t (`elem` [])
21:02:52 <lambdabot> Eq a => a -> Bool
21:03:12 <sdegutis> Big_G: yeah, see EvanR's responses
21:03:24 <sdegutis> Big_G: I assume it's Haskellian btw
21:03:31 <hiptobecubic> @let const False = (`elem` [])
21:03:34 <lambdabot>  Defined.
21:03:34 <EvanR> haskeller i heard
21:03:42 <sdegutis> EvanR: it's Haskellian now
21:03:48 <Big_G> I like Haskellian a lot more
21:03:53 <hiptobecubic> > const False 42
21:03:54 <sdegutis> Big_G: agreed
21:03:54 <lambdabot>  Ambiguous occurrence ‚Äòconst‚Äô
21:03:54 <lambdabot>  It could refer to either ‚ÄòL.const‚Äô, defined at L.hs:170:1
21:03:54 <lambdabot>                        or ‚ÄòGHC.Base.const‚Äô,
21:04:00 <hiptobecubic> awww
21:04:06 <hiptobecubic> > L.const False 42
21:04:07 <lambdabot>  False
21:04:19 <EvanR> haskelless for women haskellers
21:04:34 <Big_G> EvanR, Seriously?
21:04:45 <sdegutis> Big_G: sure why not; common English pattern
21:04:57 <sdegutis> princess, lioness, etc
21:05:00 <EvanR> "language is made up, do whatever"
21:05:04 <Big_G> sdegutis, I agree but I can't imagine having a seperate term for women will go down well
21:05:36 <sdegutis> Big_G: there are always people who will be angry activists about one thing or another; life isn't about trying not to offend them, because that's impossible
21:05:48 <hiptobecubic> people aren't haskells. That's not how 'ess' is used.
21:06:00 <EvanR> as soon as people succeed at removing all linguistic reference to gender, it will be cool to use again
21:06:03 <sdegutis> oh right.. Haskellianess
21:06:06 <EvanR> because itll be retro
21:06:09 <sdegutis> EvanR: LOL
21:06:38 <Hafydd> I don't know why you'd go to so much effort to distinguish between males and females in a context where it isn't important at all.
21:07:06 <EvanR> in the far future the separate mens and womens bathroom will be a draw at the "20s throwback speakeasy" that is, the 2020s
21:07:19 <kadoban> EvanR: Except that doesn't make any sense. The problem with English re gendered words isn't that there's no way to specify gender, it's that there's only very clunky ways /not/ to specify gender. Having the option to be gender-agnostic isn't going to make the gendered stuff go away.
21:07:19 <bananagram> "haskeller" sounds better than "haskellian"
21:07:19 <hiptobecubic> Hafydd, ask all the languages with gendered nouns what they were thinking.
21:07:40 <Hafydd> hiptobecubic: your Argument from Tradition is not valid.
21:08:29 <hiptobecubic> Hafydd, who's arguing? You said you didn't understand, I told you to go find out.
21:08:36 <sdegutis> Hafydd: I have difficulty seeing typing ~10 characters into IRC as "so much effort"
21:08:52 <sdegutis> bananagram: actually Haskellian somehow sounds better
21:09:02 <sdegutis> bananagram: I know, I'm just as surprised as you!
21:09:06 <hiptobecubic> sdegutis, it definitely doesn't :)
21:09:25 <sdegutis> hiptobecubic: but strangely enough it actually kinda does!
21:09:28 <sdegutis> hiptobecubic: weird, amirite?
21:09:37 <nshepperd_> haskeller is already gender neutral though, so you're introducing inelegant assymetry
21:09:38 <Denommus> Hi
21:09:38 <hiptobecubic> Besides. There's this: http://www.haskellers.com/  case closed!
21:09:43 <hiptobecubic> NEXT!
21:09:50 <nshepperd_> unless you want to invent a male suffix too
21:09:54 <sdegutis> nshepperd_: meh, prince is gender neutral too
21:10:24 <EvanR> proof by domain name registration
21:10:40 <kadoban> sdegutis: ? It's‚Ä¶really quite not.
21:10:52 <EvanR> www.haltingproblemsolved.com
21:11:36 <sdegutis> Haskellite, Haskellista, Haskellist, Haskellian, Haskeller, Haskellanite, Haskelliva
21:11:54 <tnks> I've only heard one of those.
21:12:05 <tnks> I think Haskeller has precedence.
21:12:15 <nshepperd_> haskellite sounds like an intriguing rock formation
21:12:24 <nshepperd_> a sediment of folds
21:12:45 <EvanR> geomorphism
21:12:56 <johnw> apparently it's a brand of light bulb: http://www.lighting-gallery.net/gallery/displayimage.php?album=937&pos=268&pid=39197
21:13:20 <EvanR> haskellheavy
21:13:26 <sdegutis> Look, why are we arguing about this? It was Haskellian and there was no problem until people came in and stirred up discontentment among the peoples.
21:13:37 <sdegutis> Let's just let a good thing be.
21:14:18 <EvanR> last week people who just learned scala were named scalars
21:14:36 <srid> anybody using Haskell+Elm for their web app? would love to look at the source.
21:14:37 * EvanR buys the domain name for that one
21:14:48 <sdegutis> This is slightly related?  http://www.eslnewscast.com/2013/05/10/confusion-with-nationality-suffixes-week-in-review/
21:15:26 <srid> hiptobecubic: hmm, haskellers are concentrated in Europe
21:16:02 <Hijiri> I don't have any proof or basis to make this claim but I think US CS education is more enterprisey
21:16:12 <sdegutis> srid: Based on this page's[1] comparison of Elm to PureScript, I think I prefer PureScript, maybe.  [1]:  https://github.com/purescript/purescript/wiki/Related-Projects
21:16:16 <EvanR> it has become that way
21:17:08 <EvanR> change the haskell logo to include a suitcase somehow, and itll be fixed
21:17:18 <srid> sdegutis: Elm, however does FRP (functional reactive programming), much like react.js - so I think it is more suited for writing client-side UIs.
21:17:18 <Hijiri> need an enterprise prelude
21:17:28 <EvanR> enterprise haskell platform
21:17:33 <EvanR> enterprise haskell integration platform
21:18:29 <sdegutis> It is now.
21:18:46 <sdegutis> srid: whoa! did not know!
21:19:20 <sdegutis> srid: I will now investigate more srsly
21:19:20 <sdegutis> (Elm)
21:20:30 <EvanR> lets get srs
21:20:43 <sdegutis> Wow! I like Elm a lot!
21:20:57 <sdegutis> EvanR: I like your sense of humor. Let's be rough-acquaintances.
21:23:04 <Denommus> So
21:23:11 <Denommus> Et
21:23:23 <yiati> phone home?
21:23:58 <Denommus> Let's say I decided to use ReactJS under GHCJS to be able to represent my DOM as a reactive behavior
21:24:06 <Denommus> yiati: the Et was an accident
21:24:18 <yiati> yeah he didn't mean to crash land on earth
21:24:27 <yiati> good thing drew barrymore was there
21:24:41 <Denommus> And I use blaze-html to render html
21:25:26 <Denommus> Would I have to wrap Html under a React object, and that under a Behavior?
21:30:22 <srid> EvanR: same evan, the creator of Elm?
21:31:52 <EvanR> nope
21:39:09 <mmachenry> I have a little DSL I'm making where in I want to express descriptions of my "items" as the way they change a particular data type. I would like to define operators that describe this. Should I use the State monad for this or is there a simpler way?
21:41:04 <sdegutis> This example confuses me so much:  http://elm-lang.org/edit/examples/Reactive/CountClicks.elm
21:41:55 <Axman6> what's confusing about it?
21:42:14 <sdegutis> I don't understand how the code works at all.
21:42:31 <Axman6> do you understand how foldl works?
21:42:33 <sdegutis> I see the behavior: when you click the page body anywhere, the number it shows increases.
21:42:39 <sdegutis> I get how foldl works on lists, sure.
21:42:48 <sdegutis> It combines them into a single value.
21:42:56 <sdegutis> (via a function)
21:42:58 <Axman6> so, I guess foldp is in some ways more like scnal
21:43:14 <sdegutis> > foldl [1,2,3] $ (+) -- 6
21:43:15 <lambdabot>  Couldn't match expected type ‚Äò(a1 -> a1 -> a1)
21:43:15 <lambdabot>                                -> a -> a1 -> a1 -> a1‚Äô
21:43:15 <lambdabot>              with actual type ‚Äò[t0]‚Äô
21:43:28 <Axman6> Mouse.click is a stream of events, which outputs a new event each time the mouse is clicked
21:43:33 <Denommus> sdegutis: now imagine the code is folding a list of events
21:43:36 <sdegutis> scnal sounds like a painful physician's operation
21:44:08 <sdegutis> Axman6, Denommus: but I don't understand.. is it a list of all events? if not, then how does it keep state from previous times?
21:44:46 <Denommus> sdegutis: imagine the type Event as type Event a = [(Time, a)]
21:45:06 <sdegutis> sure
21:45:12 <sdegutis> so it's like a list
21:45:16 <sdegutis> and list-y things work on it
21:45:20 <sdegutis> yes?
21:45:37 <Axman6> so the 0 given to foldp is the initial value, and for each event, it gives the current state to the updating function, and a) outputs the new value and b) keeps track of the new state for the next event it encounters
21:45:41 <Denommus> sdegutis: yes
21:45:52 <Axman6> well, specific listy things.
21:46:22 <Denommus> sdegutis: so, if you have a value for cliks in a button, every time the button is clicked the function increases
21:46:32 <sdegutis> oh
21:47:03 <Denommus> Ops, the list increases
21:47:38 <sdegutis> gtg bbl
21:47:52 <Axman6> > scanl (\e count -> count + 1) 0 ["Hello","world"]
21:47:54 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
21:47:54 <lambdabot>    arising from a use of ‚ÄòGHC.Num.+‚Äô
21:48:04 <Axman6> > scanl (\count e -> count + 1) 0 ["Hello","world"]
21:48:06 <lambdabot>  [0,1,2]
21:48:30 <Axman6> > scanl (\count e -> count + 1) 0 ['a'..]
21:48:31 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
21:49:29 <julianleviston> How come there‚Äôs a pic of Kermit in LYAHFGG re: list compehensions? Is it because you can‚Äôt comprehend why kermit is explaining list comprehensions? or is it a reference to the protocol? I hope neither.
21:49:57 <Axman6> link?
21:50:17 <johnw> kermit is known to do the odd cameo appearance here and there
21:50:32 <julianleviston> oh so no reason?
21:50:37 <johnw> no reason
21:51:07 <julianleviston> Axman6: http://learnyouahaskell.com/starting-out#im-a-list-comprehension
21:51:21 <julianleviston> Good-o.
21:52:08 <Axman6> later on in the page there's plenty of references to kermit/frogs
21:52:49 <julianleviston> I dislike unexplained weirdness when in learning documents. They make things worse. I quite like references, tho.
21:53:43 <mmachenry> Is it over kill to use the State monad just because I want to use the do-notation to chain together functions that manipulate an object? http://lpaste.net/120315
21:54:39 <Axman6> looks like you just reinvented lenses to some extent
21:55:30 <Axman6> @type at
21:55:32 <lambdabot> (At m, Functor f) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
21:56:26 <shachaf> You could use a list rather than do.
21:56:44 <shachaf> [A += 10, C += 30]
21:57:10 <shachaf> Or functions: A += 10 . C += 30
22:02:50 <shachaf> The word "unsafe" is too overloaded: People use it to mean "violates memory safety", "performs IO in unexpected places", "is partial", "violates invariants"
22:03:05 <johnw> and even "not safe"
22:04:54 <pacak> shachaf: "stay away if possible, read documentation for more details"
22:05:35 <johnw> I will say that every time I've used unsafe*, more than half the time it ended up resulting in a very obscure bug and was not the right solution in the end.  They are well named.
22:05:49 <glguy> we need more gradations... leathal, careless, unchecked, inadvisable, accursedUnutterable
22:06:06 <glguy> lethal*
22:06:10 <shachaf> glguy: That last one is just ridiculous. No one would ever put that in front of a function.
22:06:20 <Axman6> shouldn'tBeTypeSafe
22:07:04 <Axman6> stringlyTyped
22:07:21 <caseof> Can someone help me understand https://github.com/acid-state/acid-state/blob/master/src/Data/Acid/Log.hs#L108-L119 ? Looks like the function will be looping even when there is nothing to write to disk. Just wondering why. Thx
22:08:23 <Axman6> caseof: retry means "I can't proceed, so run me again next time one of the variables I've referenced changes"
22:08:32 <shachaf> caseof: You mean the retry?
22:08:56 <levi> shachaf: https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs  <- someone did, although it is a bit ridiculous (and deprecated as well).
22:09:20 <shachaf> levi: Yes, glguy and I have spent a while talking about that function.
22:09:32 * glguy doesn't recall that. shachaf might be making that up
22:09:33 <shachaf> It's not deprecated, only the other name for it is.
22:09:56 <shachaf> glguy: It's possible that I'm making it up.
22:10:38 <caseof> shachaf: Axman6 Oh right it's not looping as I believed. But I don't get line 113.
22:10:47 <levi> Oh, ok.  I wasn't sure if you were joking or not; in any case, other people who missed the earlier conversation can see the source now.
22:11:19 <shachaf> caseof: It reads the TVar, and then, if it's not empty, it empties it and returns the contents.
22:11:20 <caseof> Why write ([],[]) to the TVar - this will just wake up the thread once for nothing
22:11:34 <shachaf> Wake up which thread?
22:11:47 <Axman6> but it needs to write to empty the "queues"
22:12:57 <orzo> hm, haskell almost makes it easy to compare computations on huge numbers, but I have a formula involving multiplying a bignum by pi and then truncating to integer.  How doable is that?
22:13:49 <orzo> is there any package for giving me arbitrary amounts of pi?
22:14:50 <Axman6> you could use Ratio
22:15:00 <Axman6> > pi :: Ratio
22:15:02 <lambdabot>  Expecting one more argument to ‚ÄòGHC.Real.Ratio‚Äô
22:15:02 <lambdabot>  Expected a type, but ‚ÄòGHC.Real.Ratio‚Äô has kind ‚Äò* -> *‚Äô
22:15:07 <Axman6> > pi :: Rational
22:15:09 <lambdabot>  No instance for (GHC.Float.Floating GHC.Real.Rational)
22:15:09 <lambdabot>    arising from a use of ‚ÄòGHC.Float.pi‚Äô
22:15:11 <caseof> Axman6: I thought readTVar was non blocking?
22:15:15 <Axman6> bleh, guess not
22:15:29 <Axman6> > fromRational (pi :: Double) :: Rational
22:15:31 <lambdabot>  Couldn't match type ‚ÄòGHC.Types.Double‚Äô
22:15:31 <lambdabot>                with ‚ÄòGHC.Real.Ratio GHC.Integer.Type.Integer‚Äô
22:15:31 <lambdabot>  Expected type: GHC.Real.Rational
22:15:45 <shachaf> Axman6: Please experiment with that sort of thing in /msg
22:16:01 <Axman6> yeah, I thought that would be a quicker
22:16:44 <shachaf> You can't use Ratio to get an approximation of pi, and the Double will only give you a Double's worth of precision.
22:16:54 <orzo> https://hackage.haskell.org/package/factory-0.2.1.0/docs/Factory-Math-Pi.html
22:16:59 <shachaf> The CReal pi is precise but might not be appropriate for your purpose.
22:17:02 <Axman6> right, but that might be good enough
22:17:13 <orzo> that takes decimaldigits, binary would have been more convenient
22:17:23 <shachaf> It's good enough for some things, but not for "arbitrary amounts of pi".
22:17:30 <Axman6> sure
22:17:45 <glguy> yum, arbitrary amounts of pi
22:17:53 <orzo> i want 2^638 * pi truncated to an integer
22:17:53 <Rotaerk> I wish I could eat arbitrary amounts of pi
22:17:55 <orzo> heh
22:18:09 <shachaf> > pi :: CReal -- this is exactly pi but I don't know if there's an easy way to get its binary representation
22:18:11 <lambdabot>  3.1415926535897932384626433832795028841972
22:18:28 <Adeon> what is CReal
22:18:40 <yiati> You eat it for breakfast
22:18:41 <Axman6> awesomeness
22:18:43 <orzo> cauchy sequence?
22:18:44 <shachaf> Even though it's represented as a function that takes a binary precision
22:18:49 <Axman6> > showCReal 100 pi
22:18:50 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
22:18:53 <Hijiri> > 2^638 * pi :: CReal
22:18:54 <lambdabot>  3583332481690391863943932675449824957781532880725354582427718423562050938964...
22:19:00 <julianleviston> This is so beautiful: Haskell wasn‚Äôt built on great ideas, although it has those. It was built on a culture of how ideas are treated. It was not built on slaying others‚Äô dragons, but on finding our own way; not tearing down rotten ideas (no matter how rotten) but showing by example how we didn‚Äôt need those ideas after all.
22:19:24 <shachaf> http://www.sourcereal.com/
22:19:47 <Axman6> > round (2^638 * pi :: CReal)
22:19:48 <lambdabot>  3583332481690391863943932675449824957781532880725354582427718423562050938964...
22:19:49 <Adeon> I thought it was some weird C type but now that I looked for it it's a rather interesting type
22:19:55 <Axman6> looks like that'll do it
22:20:14 <shachaf> Puzzle: Is pi^pi^pi^pi an integer?
22:20:31 <Axman6> > length . show $  round (2^638 * pi :: CReal)
22:20:32 <lambdabot>  193
22:20:51 <Rotaerk> Solution: No.
22:21:01 <shachaf> (Proof required.)
22:21:04 <Rotaerk> darn
22:21:22 <Axman6> shachaf: no, it's a type error
22:21:42 <shachaf> ^ means exponentiation of real numbers.
22:21:54 <Axman6> not in #haskell >_>
22:22:44 <Rotaerk> :t (^)
22:22:45 <lambdabot> (Num a, Integral b) => a -> b -> a
22:23:06 <jle`> :P
22:23:44 <Axman6> caseof: readTVar is non-blocking, but retry can cause the computation to be retried, and it won't be retried until one of the variables read before the retry has changed
22:23:46 <jle`> Axman6: shachaf basically had a shadowing binding
22:23:49 <shachaf> I almost wrote pi**pi**pi**pi, and then I thought that no one would be that much of a pedant.
22:23:50 <jle`> Axman6: so the statement is correct
22:24:09 <Axman6> you thought wrong
22:24:12 <jle`> pi ^ pi ^ pi ^ pi where (^) = (**)
22:24:19 <jle`> er
22:24:32 <jle`> let (^) = (**) in pi ^ ...
22:24:39 <jle`> by defining (^) he shadowed the definition, so it checks out
22:25:14 <Rotaerk> whoa, thanks haskell!  pi ** pi ** pi ** pi is infinity
22:25:17 <Rotaerk> which isn't an integer
22:25:20 <Rotaerk> QED
22:25:41 <shachaf> Defaulting to Double is the reason I didn't write **
22:25:55 <jle`> ah yes those defaulting rules
22:26:03 <jle`> so pesky ;_;
22:26:24 <Axman6> > let (^) = (**) in pi ^ pi ^ pi ^ pi :: CReal
22:26:27 <lambdabot>  2598761979625197.5214462849737795252351112341681688399567
22:26:53 <shachaf> That's not the right associativity.
22:27:06 <shachaf> (It's the left associativity.)
22:27:26 <Axman6> > let (^) = (**) in pi ^ (pi ^ (pi ^ pi)) :: CReal
22:27:57 <Axman6> R.I.P lambdabot
22:28:09 <Hijiri> 22:24:51 lambdabot |  2598761979625197.5214462849737795252351112341681688399567
22:28:19 <Hijiri> oh, that was the left one
22:28:53 <funfunctor> hi
22:29:27 <julianleviston> funfunctor: hi! :)
22:29:32 <funfunctor> :)
22:30:08 <Adeon> > 1+2
22:30:12 <lambdabot>  3
22:30:17 <Adeon> he lives
22:30:21 <Axman6> she*
22:30:52 <funfunctor> julianleviston: http://pastebin.com/SKsgDhTt
22:30:56 <shachaf> Users are welcome to experiment with lambdabot in /msg.
22:31:01 <funfunctor> trying to get that to work
22:31:02 <shachaf> At any rate no one knows the answer.
22:31:18 <funfunctor> naturally there is no instance of Eq inside the monad
22:31:45 <lpaste> orzo pasted ‚ÄúIs the RFC wrong?‚Äù at http://lpaste.net/120316
22:31:57 <funfunctor> julianleviston: No instance for (Eq (BladeRF BladeRFFPGASize))
22:31:58 <orzo> So where'd i go wrong?
22:32:17 <julianleviston> funfunctor: I‚Äôm sorry, but I‚Äôm not going to be of much help.
22:33:53 <Axman6> orzo:  2^638 * pi + 149686  defaults to Double, which definitely won't work with such large values
22:34:06 <orzo> pi?
22:34:13 <Axman6> > fromInteger (2^638) :: Double
22:34:15 <lambdabot>  1.1406101544055488e192
22:34:31 <orzo> i thought i was importing that from elsehwere
22:34:49 <Axman6> you're not getting anywhere near enough precision when using Double
22:36:07 <orzo> ah, i got it to work, thanks
22:36:10 <orzo> added a cast
22:37:53 <Axman6> "cast"?
22:40:38 <orzo> Axman6: type signature on pi
22:40:44 <orzo> are you gonna be pedantic
22:41:19 <Axman6> well, it's not correct to call it a cast, because that implies you're implictly converting from one type into another, which isn't what's happening
22:41:44 <glguy> "yes"
22:41:56 <orzo> i'm converting from a polymorphic type to a concrete one
22:42:08 <orzo> now can i call it a cast?
22:43:19 <Axman6> jesus, this channel is usually full of people willing to tell me when I've used incorrect terminology
22:43:53 <haasn> Type signatures don't convert types
22:43:54 <kadoban> orzo: Thinking of it as a cast seems totally unhelpful to me, but if it somehow helps you *shrug*
22:43:57 <haasn> Haskell doesn't have type casts
22:44:04 <glguy> orzo: casting usually changes from one representation to another or one interpretation to another or something like that
22:44:08 <haasn> ‚Äúcast‚Äù is not even that well-defined
22:44:13 <glguy> type ascriptions are a little different
22:44:24 <haasn> The closest thing Haskell has to ‚Äúcasting‚Äù is newtype wrappers
22:44:27 <shachaf> "cast" is what the function "cast" does.
22:45:34 <haasn> shachaf: I think the function "cast" is more limited. You can't, for example, cast from a Double to an Integer
22:45:50 <haasn> But in language that have ‚Äúcasting‚Äù, that's a perfectly valid operation
22:45:51 <Axman6> speaking of which, has the work on safe casting been added to GHC? I can't remember what it was actually called, but it was what added the annotations that let you specify roles for type variables in types
22:46:02 <haasn> in some languages*
22:46:19 <orzo> i think you're all being selective about the definition of cast
22:46:34 <orzo> all of c++ _cast operators are casts
22:46:43 <haasn> Axman6: Yes, that's in GHC these daysd
22:46:53 <haasn> It's called ‚Äúcoerce‚Äù
22:47:04 <Axman6> are the optimisations that were supposed to come from it in ghc too?
22:47:10 <haasn> http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Coerce.html#v:coerce
22:47:22 <glguy> orzo: putting a type signature doesn't change the type of something from one thing to another, it just adding information about what it's type actually is, C++ casts are different than that
22:47:37 <haasn> Axman6: Yes, I'm fairly sure it's implemented the same way as unsafeCoerce
22:48:14 <haasn> ‚Äòcoerce‚Äô is just a version of unsafeCoerce that is statically checked to only allow coercions between representationally equal types
22:48:29 <orzo> glguy: i can write a function tghat accepts a more polymorphic type but rejects concrete ones.  What do you make of that?
22:48:35 <ttt_fff> is there some sort hand for "x <- y; f x" (inside a monad) involving "<$>" ?
22:48:43 <haasn> Axman6: The documentation even makes it explicit: ‚Äúwith no run-time overhead‚Äù
22:48:49 <shachaf> ttt_fff: join (f <$> y)
22:48:53 <jle`> ttt_fff: f =<< y
22:48:57 <shachaf> ttt_fff: Or just y >>= f, or f =<< y
22:49:10 <ttt_fff> how does the 'join' and <$> work ?
22:49:31 <jle`> <$> is fmap, if you know about it
22:49:36 <ttt_fff> yes
22:49:36 <orzo> the polymorphic type has a different typeRep than the concrete type.
22:49:37 <glguy> orzo: You'll have to show me what you mean. The point is that casts change a type. adding a type signature adds additional type information
22:49:41 <jle`> if you have an (m a) and an (a -> b), then it turns it into an m b
22:49:41 <julianleviston> This conversation reminds me of the difference between ‚Äúmessage‚Äù and ‚Äúmethod‚Äù in OOP languages. There‚Äôs a massive difference.
22:49:42 <ttt_fff> which is why I thought there is a solution involving <$>
22:50:00 <haasn> orzo: Then all you've done is demonstrated a type error
22:50:07 <haasn> orzo: In (x :: Int), x is already of type Int
22:50:08 <jle`> yeah, fmap doesn't quite work here, because you have an (a -> m b) and an (m a), so if you fmap'd, you'd get an m (m b)
22:50:15 <jle`> but join turns an m (m b) into an m b
22:50:25 <haasn> orzo: The type annotation is just a static way to say that ‚Äòx‚Äô has type Int
22:50:31 <haasn> It doesn't ‚Äúchange‚Äù the type of x
22:50:46 <orzo> static/runtime has nothing to do with it
22:50:51 <jle`> but however, if you have an `m a` and an `a -> m b`, then that's exactly what bind, >>= or =<<, is for
22:51:09 <orzo> c++ reinterpret_cast is not at runtime either
22:51:12 <jle`> (=<<) and (>>=) let you apply an `a -> m b` to an `m a` to get a `m b`
22:51:25 <jle`> in contrest, fmap and (<$>) let you apply an `a -> b` to an `m a` to get an `m b`
22:51:32 <jle`> notice the difference in the shape of the two functions?
22:51:38 <haasn> ttt_fff: (y >>= f) = join (fmap f y) is a Monad law
22:52:02 <jle`> if you have `m a`, then...if you have an `a -> b`, you use fmap; if you have an `a -> m b`, use bind
22:52:20 <haasn> It's a direct consequence of (y >>= id) = join y
22:52:39 <haasn> (I think.)
22:53:38 <orzo> does ghc recognize any way for me to break a bignum literal accross multiple lines?
22:54:44 <johnw> orzo: does the \\ syntax work fro that?
22:54:46 <johnw> 123\
22:54:48 <johnw> \456
22:55:03 <Axman6> I'd be surprised, I think that's only string literals
22:55:04 <johnw> or does that only work inside a string literal?
22:55:45 <orzo> experimentally it does not work
22:55:47 <funfunctor> how does one normally deal with equating Enum's wrapped up in a monad?
22:55:59 <orbisvicis> is it possible, somehow, to compile from stdin? doesnt work -->  ghc <(echo 'main = putStrLn "ASDF"')
22:56:21 <shachaf> ghc -e '...' works (it's like ghci)
22:56:23 <shiona> is there an extension to partial newtypes?
22:56:24 <shachaf> I don't know about stdin.
22:56:36 <orzo> would kind of suck to make a quasiquoter just to format a bignum reasonably
22:56:42 <Polarina> How about `ghc /dev/stdin`?
22:56:47 <LordBrain> you can use the file discripter
22:57:00 <funfunctor> for example I have a function with type bladeRFGetFPGASize :: BladeRF BladeRFFPGASize where BladeRFFPGASize is a Enum
22:57:04 <shachaf> ghc /dev/stdin doesn't work, and it's easy to test.
22:57:09 <haasn> ttt_fff: Oh, it's a consequence of the laws ‚Äúfmap f xs  ==  xs >>= return . f‚Äù and ‚Äúm >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h‚Äù
22:57:13 <haasn> Plus the definition of ‚Äòjoin‚Äô
22:57:20 <funfunctor> I want to equate a value with the result of bladeRFGetFPGASize
22:57:35 <LordBrain> bash has a filediscripter sugar
22:58:06 <orbisvicis> LordBrain: what do you mean?
22:58:06 <haasn> orbisvicis: runhaskell can run programs from STDIN. Does that help?
22:58:11 <Axman6> orzo: read "5646543216845...543\\n\3543543547354354..." =)
22:58:26 <shachaf> Oh, also what haasn said, right.
22:58:54 <Axman6> funfunctor: what're you working on anyway? looks like it's for the BladeRF FPGA board?
22:59:01 <jle`> if a Num instances is well behaving, then i think GHC can optimize  all functions that return any general Num a
22:59:15 <haasn> orbisvicis: Note that runhaskell <(...) does not work
22:59:24 <haasn> (Ironically)
22:59:34 <jle`> for example, foo :: Num a => a -> a; foo x = x + 4 * 7
22:59:45 <jle`> it might be extremely unperformant with a Num instance with expensive + and *
22:59:49 <orbisvicis> haasn: that, I've noticed. what is runhaskell ?
22:59:59 <jle`> but can't GHC just specialize foo to foo :: Integer -> Integer
23:00:03 <jle`> and then run fromInteger at the end?
23:00:09 <haasn> orbisvicis: ‚Äòrunhaskell‚Äô is something like a wrapper around ghc's interpreter
23:00:19 <haasn> So it functions similarly to ghc -e and ghci
23:00:35 <LordBrain> if ghc /dev/stdin doesnt work, then i don't think anything i was thinking of would either
23:00:45 <jle`> if + and * on the type are super expensive, then this will give really large savings
23:00:48 <haasn> (Which also means that the performance characteristics are probably going to be very different from compiled executables)
23:00:54 <jle`> if + and * are less expensive than + and * on INteger though then you have a loss i guess
23:00:58 <LordBrain> there is ghci
23:01:00 <haasn> (Not sure if that's something you were worrying about or not)
23:01:35 <orzo> Axman6: so read will remove whitespace?
23:01:58 <orzo> oh use the \
23:02:01 <Axman6> yeah
23:02:10 <Axman6> (to the latter statement)
23:02:50 * haasn .oO(  cat <(foo) <(bar) <(bat) | runhaskell  )
23:02:57 <orzo> well at least it's not a quasiquoter, thanks
23:03:15 <jle`> alternatively you can use {-# LANGUAGE CPP #-}
23:03:18 <jle`> ;)
23:03:20 <jle`> (don't)
23:04:08 <Axman6> "{-# LANGUAGE CPP #-}\n#include \"$filename\""
23:04:12 <orzo> somebody should file a syntax extension proposal
23:05:14 <jle`> i'm pretty sure there's a multiline literal in haskell though
23:05:33 <haasn> There are multi-line string literals
23:05:33 <orzo> for strings
23:06:04 <funfunctor> Axman6: yea I made a haskell binding for libbladeRF, I am going to publish it soon to hackage
23:06:23 <Axman6> cool
23:06:56 <Hijiri> > "efsefjselifjselfisjefli\            \sfjslefjslefjise"
23:06:57 <lambdabot>  "efsefjselifjselfisjeflisfjslefjslefjise"
23:06:59 <LordBrain> orzo, while we're at it, we should probably allow some meaningless symbols to be inserted for human readability.. in case it is a really huge number.
23:06:59 <Hijiri> just across lines
23:06:59 <funfunctor> Axman6: now I am trying to get Layer 0 working for GSM.. I'm about half way with that in haskell
23:07:04 <orbisvicis> haasn: ok scratch stdin - wanting to compile a full program, not just expressions, and create compiled output. What about compiling from string argument ?
23:07:07 <Axman6> I wish the FPGA platforms were more open so it was possible to avoid using horrible lanuages like Verilog and VHDL
23:07:13 <orzo> LordBrain: yeah
23:07:20 <funfunctor> Axman6: just a few random minor issues I need help with
23:07:27 <orbisvicis> haasn: also what is ghc -e 'expr' for, without producing any results ?
23:07:32 <haasn> orbisvicis: You can allocate a temporary file, write to that, and compile it
23:07:46 <orzo> actually i suppose an integer glue operator can be defined
23:07:57 <orzo> using logBase 10
23:08:02 <orzo> to get the numbger of digits
23:08:05 <LordBrain> well, for floating values too tho orzo
23:08:09 <orbisvicis> haasn: yes, probably will end up doing that
23:08:13 <haasn> orbisvicis: ghc -e and runhaskell are virtually indistinguishable. Both will run the program, including any IO actions.
23:08:31 <orzo> nevermind floating values
23:08:35 <LordBrain> neither , nor . seem like good options
23:09:10 <LordBrain> oh i have an idea
23:09:16 <haasn> I'm quite sure I've opened a ticket for the hFileSize issue at some point
23:09:24 <LordBrain> we can allow ‚ë° to take the place of 2
23:09:41 <LordBrain> that way you can just circle every 8'th digit
23:10:26 <haasn> orbisvicis: Actually, there's a big difference between ghc -e and runhaskell. The former can evaluate naked expressions, similar to GHCi
23:10:35 <haasn> runhaskell can only run full Haskell programs
23:10:48 <haasn> So you could execute ghc -e '1+1' and it will output 2
23:11:15 <funfunctor> Axman6: VHDL is good, but what do you want to be more open? There is code about to get you all the way to netlists
23:12:50 <funfunctor> Axman6: http://lekernel.net/fpga_toolchain_talk.pdf
23:13:44 <Axman6> ideally the binary format written to the FPGA wouldn't be closed
23:15:07 <srid> I found LYAH a little too gentle, so trying out 'Thinking Functionally with Haskell'
23:15:58 <shachaf> You could try the Gentle Introduction to Haskell if you don't like gentle.
23:16:05 <shachaf> @where tutorial
23:16:06 <lambdabot> http://www.haskell.org/tutorial/
23:18:21 <Axman6> funfunctor: interesting talk, lots of good stuff there
23:20:15 <delrik> hi guys
23:20:20 <jle`> hi delrik !
23:20:30 <delrik> I‚Äôm a little confused on how the funciton I wrote is working.
23:20:32 <delrik> http://pastie.org/9938559
23:20:58 <delrik> specifically, i thought that since haskell doesn‚Äôt create stack frames, how am i able to compute an accumulated sum?
23:21:32 <Axman6> by performing a left fold, not a right fold
23:21:42 <shachaf> You're interested in how that code is being evaluated?
23:21:47 <delrik> yes
23:22:08 <Axman6> https://wiki.haskell.org/Foldr_Foldl_Foldl' may be useful to help you understand
23:22:11 <jle`> a good model for evaluation in haskell is evaluation by substitution
23:22:28 <Axman6> it starts with a very similar problem to the one you have
23:22:30 <shachaf> "haskell doesn't create stack frames" isn't really true and probably not helpful either.
23:22:44 <jle`> basically, every time you see a function call, "substitute it" with the definition
23:22:52 <jle`> @src map
23:22:52 <lambdabot> map _ []     = []
23:22:52 <lambdabot> map f (x:xs) = f x : map f xs
23:22:56 <shachaf> But there are a lot of different answers to your question so it depends on what sort of answer you're looking for. :-)
23:23:14 <jle`> yeah, there are probably a lot of levels in which this can be answered v.v
23:23:23 <delrik> my expectation would be my otherwise case would mean that there would be no thunk attached to that expression.
23:23:49 <delrik> unlike the strcnt‚Äô variation where its obvious the evaluation of the sum is deferred.
23:24:36 <delrik> i know I‚Äôm noobing out hard core btw guys, I just don‚Äôt see what I‚Äôm not getting with this.  and I checked outt he link Asman6: it was dead =(
23:24:39 <Axman6> so you understand that 1 + strcnt c cs can't be evaluated until both 1 and strcnt c cs have been fully evaluated right?
23:24:59 <delrik> d‚Äôoh
23:25:01 <shachaf> delrik: If you wrote the first version in the same style as the second, it would be "strcnt c (c':cs) = if c' == c then 1 + strcnt c cs else strcnt c cs"
23:25:07 <Axman6> that link loads fine for me. make sure there's a quote at the end
23:25:23 <Axman6> >>>https://wiki.haskell.org/Foldr_Foldl_Foldl'<<<
23:25:36 <delrik> yeah, I completely forgot about life just now gais. crisis averted =)
23:25:44 <delrik> wtf was i thinking
23:26:17 <funfunctor> Axman6: have you used hslogger before?
23:26:28 <delrik> I‚Äôm reading the Haskell Road to Logic Math and Programming and I guess its fried my brain to the point where not even lazy evaluation is making sense anymore.
23:26:32 <Axman6> nope
23:27:05 <shachaf> delrik: Of course, the function would have the same value with both strict and non-strict evaluation.
23:27:06 <funfunctor> delrik: oh good book!
23:27:34 <delrik> shachaf: touche!
23:27:39 <delrik> good point =)
23:27:56 <funfunctor> delrik: advice for learning would be to write something and build it up to be progressively more complex
23:28:08 <jle`> well
23:28:11 <jle`> it depends on your Num instance
23:28:35 <funfunctor> Axman6: do you have a bit of time on your hands?
23:28:38 <Axman6> yeah it should work quite well for Nat
23:28:52 <Axman6> funfunctor: not really, I'm about to head home
23:28:59 <delrik> funfunctor: I‚Äôm kinda hung up on the type ssytem right now.  Especially in regards to monadic instances with a ton of complex parameterised types (Like a stack of MonadTs)
23:29:06 <jle`> if you have a num instance that does lazy comparisons then you might be able to get away with running it on an infinite list
23:29:24 <delrik> naturally I assumed I didn‚Äôt pay close enough attention to my coursework, so I‚Äôm coming through at a snails pace.
23:29:36 <delrik> combing*
23:29:59 <funfunctor> delrik: do you want to build up something together?
23:30:09 <funfunctor> maybe I can help you out a little?
23:30:24 <delrik> dude, I‚Äôm so down!
23:30:51 <funfunctor> delrik: you want to build a state monad or something? do you know how to do that already?
23:30:57 <delrik> I‚Äôm so serious about learning this stuff i bit the bullet and started using emacs as my daily driver.
23:31:02 <delrik> sec
23:31:28 <funfunctor> haha I use vim myself :flames: <g>
23:31:39 <delrik> https://github.com/elrikdante/Transformers-hs/tree/master/src
23:31:55 <delrik> so I was following along with the MonadTransformers step by step paper for that one.
23:32:43 <delrik> then i tried to apply the stack approach to building an api server in scotty that would log how often an endpoint was accessed.
23:32:43 <delrik> https://github.com/elrikdante/rest-hs
23:32:54 <delrik> but I crashed and burned
23:33:04 <funfunctor> delrik: you probably want to use do blocks there
23:33:22 <funfunctor> delrik: I would advice writing more code than reading
23:33:31 <funfunctor> your quickly become lost just by reading
23:35:20 <funfunctor> delrik: why not build a StateT monad for learning with Exception handling
23:36:19 <delrik> funfunctor: ‚Äúfor learning with Exception handling‚Äù what does that part mean exactly?
23:36:36 <funfunctor> delrik: basically a random project
23:36:44 <funfunctor> delrik: so lets define possible errors
23:40:49 <delrik> sorry disconnected
23:41:09 <delrik> laptop died >_< I set up the repo, you were mention the errorTypes
23:44:35 <delrik> funfunctor: https://github.com/elrikdante/StateT , so whats next?
23:46:29 <funfunctor> delrik: data MyStatesPossibleErrors = BadError1 | BadError2
23:46:57 <funfunctor> delrik: task, make a show instance that assigns fancy strings to each error
23:49:16 <delrik> funfunctor: kk, thats done an pushed
23:52:01 <funfunctor> delrik: nice ok;  newtype MyState a = MyState { unMyState :: ExceptT MyStatesPossibleErrors IO a } deriving (Monad, MonadIO)
23:53:48 <delrik> I‚Äôm not finding ExceptT on hoogle
23:54:10 <delrik> Control.Monad.Trans.Except
23:54:37 <funfunctor> delrik: thats all for you to figure out
23:54:46 <delrik> ahh, ok
23:55:21 <funfunctor> delrik: when your done, make MyState a instance of Functor and Applicative
23:55:32 <delrik> kk
23:55:34 <delrik> thx
23:58:40 <jle`> edwardk: are there any Cochoice instances you've written?
23:58:49 <edwardk> ?
23:59:07 <edwardk> Choice is Strong for a different tensor
23:59:20 <jle`> from here http://hackage.haskell.org/package/profunctors-4.3.2/docs/Data-Profunctor.html
23:59:29 <jle`> i noticed there were no instances listed
