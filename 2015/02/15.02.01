00:00:05 <orbital> hi
00:00:17 <orbital> with optparse-applicative, how does one define a zero-argument command?
00:09:20 * hackagebot leaky 0.3.0.0 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.3.0.0 (AndrewSeniuk)
00:09:20 * hackagebot deepseq-bounded 0.7.0.1 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.7.0.1 (AndrewSeniuk)
00:20:23 <trap_exit> is anyone here fmailiar with purescript?
00:20:38 <trap_exit> it looks similar to haskell in syntax + has type classesr + gadts + do notation
00:20:40 <trap_exit> but is strict
00:20:50 <trap_exit> so it almost seems better than using fay/haste/ghcjs for outputting javascript
00:21:01 <trap_exit> but I would love to hear experiences others have had
00:29:20 <sinelaw> does anyone know of a type system that includes anonymous record/object types with polymorphic methods, and full type inference?
00:30:34 <sinelaw> sincerely, myself
00:35:50 <mjrosenb> finiteBitSize is the same as bitSize from older ghc versions, yes?
00:46:43 <jle`> trap_exit: yeah it's nice
00:46:53 <jle`> it also compiles to idiomatic javascript
00:47:04 <jle`> so it's really closer to coffee script/typescript/flow than ghcjs/fahye
00:47:13 <trap_exit> but i heard it also lacks source maps
00:47:15 <trap_exit> so bitchy to debug
00:47:22 <jle`> in the javascript preprocessor realm
00:47:24 <trap_exit> i.e. is purescript outputted js easier to debug than haste/ghcjs outputted js ?
00:47:26 <jle`> ah is that so
00:47:33 <jle`> purescript outputted is normal javascript
00:47:39 <jle`> it's not calls to a runtime system
00:47:53 <jle`> it's not like compiled calls to a compiled runtime system
00:47:58 <fragamus> how do i message lambdabot
00:48:00 <jle`> the functions map one-to-one basically
00:48:05 <fragamus> privately
00:48:06 <jle`> fragamus:  /q lambdabot blah blah
00:48:09 <trap_exit> oh, so none of this A([0, .. encoded args ...]) BS ?
00:48:14 <fragamus> tenq
00:48:22 <jle`> trap_exit: have you ever used coffeescript, etc.?
00:48:25 <jle`> fragamus: np :)
00:48:46 <trap_exit> jle`: no, I've only dealt with javascript, clojurescript, fay, haste, and ghcjs
00:48:54 <jle`> what about sass?
00:49:26 <jle`> purscript basically tries its best to map one-to-one a function with how you would write it with javascript, i think
00:49:40 * hackagebot deepseq-bounded 0.7.0.1 - Bounded deepseq, including support for generic deriving  http://hackage.haskell.org/package/deepseq-bounded-0.7.0.1 (AndrewSeniuk)
00:49:40 * hackagebot leaky 0.3.0.1 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.3.0.1 (AndrewSeniuk)
00:49:54 <jle`> the approach of ghcjs is to compile the haskell runtime system to javascirpt, with the right semantics, and then compile yor programs into something that runs on taht simulated runtime system
00:50:20 <jle`> purescript is basically another language that lets you write javascrip functions with haskell-like syntax
00:50:31 <jle`> like... a pre-processor
00:51:00 <fragamus> uhm its not working: /q lambdabot blah blah
00:51:04 <luite> the rts is not compiled to js, things like the scheduler have been rewritten in js (might switch to typescript or similar at some point)
00:51:05 <mjrosenb> jle`: I'm guessing you can't compile it to native code?
00:51:27 <jle`> mjrosenb: well. it has javascript semantics
00:51:37 <zomg> fragamus: most likely /msg lambdabot foo should do the trick, and it'll open a new window where the messages would show up
00:51:44 <jle`> so you'd have to compile the javascript runtime or copy the javascript operational semantics
00:51:50 <zomg> /q lambdabot might also work but not sure if all clietns support /q
00:51:54 <jle`> luite: ah is that. thanks :)
00:53:04 <fragamus> lambdabot must think im a stalker
00:53:06 <fragamus> lambdabot left the query by disconnecting from IRC.
00:53:21 <luite> i wonder how purescript is going to scale, ghc relies on some heavy handed rewriting to make pure datastructures performant. purescript on the other hand has a nice and compact translation to js, but things like deforestation would be tricky to do without losing the clear ps <-> js mapping
00:54:13 * mjrosenb may end up using ghcjs at some point or other in the 'near' future...
00:54:14 <luite> ghcjs has scalability problems on the other side, inlining and specialization often blow up code size
00:54:35 <fragamus> > 1+1
00:54:37 <lambdabot>  2
00:54:43 <trap_exit> luite: I dunno, it's ahrd to say, any chance we can get the ghcjs contrib to hack on purescript to fix this issue? he seems compotent
00:54:45 <luite> which will require more work on the simplifier to address
00:54:46 <jle`> javascript has scalability problems.
00:55:56 <luite> jle`: hehe yeah but both the haskell compilers and purescript try to address those :)
00:55:59 <mjrosenb> luite: does that really help?
00:56:01 <jle`> ;)
00:56:15 <mjrosenb> luite: js engines inline everything for performance already.
00:56:55 <luite> mjrosenb: specialization using GHC's rules often helps a lot, but JS engines don't know about those
00:58:20 <mjrosenb> luite: ahh, and I bet you can't get anything particularly useful from making a copy of the callee per specialization
00:58:23 <luite> mjrosenb: on the other hand, inlining/specializing hardly used code only blows up code size and gives the jit compiler more work. some profile guided steering might be useful, but also the ghcjs codegen should do better optimization on the code it generates from stg
00:58:25 <zomg> Could GHCJS build into asm.js?
00:58:48 <zomg> I hear some browsers actually have optimizations specifically for the asm.js syntax
00:58:56 <luite> zomg: not easily, it's a very limited subset of js, and it'd require porting the whole storage manager from native code
00:59:03 <mjrosenb> zomg: well, that /was/ the idea of asm.js
00:59:12 <luite> so it's low on the list of priorities currently
00:59:16 <mjrosenb> zomg: unfortunately, it is designed for things that 'look like C'
00:59:33 <zomg> mjrosenb: yeah just didn't know if the support actually ever materialized but seems like it did at least partially
00:59:34 <mjrosenb> you'd have an easier time taking th cmm output from ghc, and compiling that with emscripten
00:59:49 <trap_exit> i figured out this solutiuon
00:59:51 <mjrosenb> zomg: when it was announced, the support existed.
00:59:51 <trap_exit> here's what you do
00:59:57 <trap_exit> you prototype in purescript
01:00:07 <trap_exit> then when your app gets popular, and it has scability problems, you're at fracebook scale
01:00:11 <luite> zomg: i'm working on some changes of the rts code that make it easier to experiment with alternative heap object representations
01:00:18 <trap_exit> so what you do then is that you hire luite for $1M / year to fix your scability problems
01:00:21 <trap_exit> and everyone is happy
01:02:36 <luite> dunno, can i work from new zealand, and mostly on the rainy days, so i can use the sunny days for mountain biking and hiking?
01:04:24 <luite> trap_exit: it might well be doable adding a rewrite framework to ps, at least strict eval should make it easier to get reasonably usable source maps out of it
01:04:30 <zomg> luite: cool :)
01:04:41 <zomg> yep
01:04:41 <zomg> :P
01:05:12 <zomg> I'd hire him! Too bad we're using GHCJS without the GHC...
01:05:17 <zomg> :p
01:06:27 <luite> zomg: i'll stay in NZ for now then :p
01:09:40 <zomg> :D
01:09:50 <zomg> Are you secretly Kim Dotcom?
01:09:58 <zomg> Do other people live in NZ?
01:10:13 <zomg> Seriously though, the whole company works remotely, so... :)
01:15:24 <luite> zomg: hehe i think some people live here, but where i'm currently at it's all tourists
01:15:30 <u-ou> i'm in nz
01:16:00 <chemuduguntar> is there a predefined operator that does approximate comparisons of floating point number?
01:16:03 <chemuduguntar> +s
01:16:19 <chemuduguntar> given some episalon
01:17:45 <luite> u-ou: near wellington?
01:17:54 <u-ou> nah. way down south.
01:19:04 <luite> oh i might stop in dunedin later this week, or is it more like invercargill?
01:19:49 <u-ou> dunedin
01:20:12 <PatientZero> Hi guys - quick simple question
01:20:22 <PatientZero> I typed this using "int" instead of "Int" by accident:
01:20:30 <PatientZero> mysum :: [int] -> int
01:20:37 <PatientZero> and the thing is, it compiles!
01:20:37 <luite> u-ou: ah i'm in icton now, heading down south tomorrow probably
01:20:40 <luite> picton
01:20:49 <PatientZero> but when I try to get the type of "int" it doesn't know what I'm talking about
01:20:49 <u-ou> picton's nice
01:21:00 <PatientZero> ah never mind - it's assuming a type variable called "int"
01:21:08 <PatientZero> rubber duck debugging
01:22:15 <luite> u-ou: not bad, i ended up staying an extra night and walked around a bit :) at first i thought of it as the place where you get stuck after the ferry drops you off
01:22:33 <u-ou> hehe
01:28:31 <jle`> Reader is pretty neat
01:29:00 <jle`> PatientZero: imagine my surprise when i first tried to use `undefined` as a type :P
01:30:56 <PatientZero> jle`: man that must have been an interesting few hours ;-)
01:34:01 <jle`> :)
02:04:38 * hackagebot trifecta 1.5.1.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.5.1.1 (EdwardKmett)
03:22:28 <kavin> hi all
03:23:28 <miniBill> I'm failing at hoogle. Is there a function with signature (Monad m) => (a -> b) -> m [a] -> m [b] ?
03:24:44 <miniBill> liftM . map
03:24:45 <miniBill> sigh
03:24:48 <exio4> fmap . fmap
03:25:09 <exio4> oh, well, Monad m =>
03:25:13 <miniBill> exio4: would you prefer, in your code, liftM . map or fmap . fmap ?
03:25:28 <miniBill> m in my case is IO, btw
03:27:31 <exio4> if I am using it in the code I'd go with fmap (fmap something), but if I am using it more than once I'd give it a name that gives a rough idea of what it does in my problem, also, maybe "fmap . fmap" or "fmap . map"
03:28:07 <miniBill> exio4: thank you
03:55:59 <pacak> Is it possible to make function declaration using TH quotations? Obvious
03:55:59 <pacak> runQ [d| inc x = x + 1|]
03:55:59 <pacak> leads to stuff like
03:55:59 <pacak> [FunD inc_6 [Clause [VarP x_7] (NormalB (SigE (InfixE (Just (VarE x_7)) (VarE GHC.Num.+) (Just (LitE (IntegerL 1))))[]]]
03:55:59 <pacak> which kind of works, but function name is invalid. All my attemps to set specific function name failed.
04:03:22 <Hafydd> Is there a way to cause GHC (in particular, runghc) to search for imports in the same directory as the importing file, even when this is not the same as the current directory?
04:05:07 <Thule> Is there any way to convert a IO FilePath straight away? E.g. right now I am doing curDir <- getCurrentDirectory and putStrLn "CurDir is " ++ curDir. Can I do that in one line instead?
04:05:37 <notdan_> Thule: putStrLn =<< getCurrentDirectory
04:05:58 <notdan_> Hafydd: do you meann something like the -i flag?
04:06:11 <Thule> ahh thanks
04:06:22 <Thule> notdan_ what is the name for =<< so I can read a bit about it?
04:06:35 <notdan_> hm
04:06:43 <notdan_> It's like (>>=) from Control.Monad
04:06:44 <notdan_> but flipped
04:06:49 <notdan_> @src (=<<)
04:06:50 <lambdabot> f =<< x = x >>= f
04:07:20 <Thule> ok thanks
04:07:54 <Hafydd> notdan: the -i flag is related, but I'd like to not have to specify the path manually.
04:09:43 * hackagebot mwc-random-monad 0.7.3.0 - Monadic interface for mwc-random  http://hackage.haskell.org/package/mwc-random-monad-0.7.3.0 (AlexeyKhudyakov)
04:18:29 * mbrock drinks coffee and skims papers he barely understands looking for inspiration re: modular AST interpretation
04:22:02 <Hafydd> I have the current almost-solution:
04:22:03 <Hafydd> #!/bin/bash
04:22:03 <Hafydd> --; cd `dirname $0`; exec runhaskell ./`basename $0`
04:22:22 <Hafydd> Aside from its ugliness, it also outputs an error message whenever run.
04:22:41 <t4nk231> has anyone used Hat (http://projects.haskell.org/hat/) and had any issues with it?
04:23:36 <Hafydd> If there were a valid bash command starting with "--", I could get rid of that!
04:25:31 <mbrock> Hafydd: what are you trying to do?
04:25:58 <Hafydd> mbrock: I
04:26:23 <Hafydd> mbrock: I'm trying to cause a Haskell program to run as a script and import files in the same directory as itself.
04:27:33 <mbrock> Hafydd: ah, so #!/usr/bin/env runhaskell is not enough because the working directory for imports will be wrong?
04:27:38 <Hafydd> Yes.
04:27:49 <Hafydd> That is the case for runghc, but not runhugs.
04:44:45 * hackagebot hashable-time 0.1.0.0 - Hashable instances for Data.Time types and Fixed  http://hackage.haskell.org/package/hashable-time-0.1.0.0 (alkar)
04:49:45 * hackagebot hmatrix-csv 0.1.0.1 - CSV encoding and decoding for hmatrix.  http://hackage.haskell.org/package/hmatrix-csv-0.1.0.1 (lyzrd)
04:49:47 * hackagebot hadoop-rpc 1.0.0.0 - Use the Hadoop RPC interface from Haskell.  http://hackage.haskell.org/package/hadoop-rpc-1.0.0.0 (JacobStanley)
05:04:46 * hackagebot hadoop-rpc 1.0.0.1 - Use the Hadoop RPC interface from Haskell.  http://hackage.haskell.org/package/hadoop-rpc-1.0.0.1 (JacobStanley)
05:19:46 * hackagebot hub 1.4.0 - For multiplexing GHC installations and providing  development sandboxes  http://hackage.haskell.org/package/hub-1.4.0 (ChrisDornan)
05:19:48 * hackagebot leaky 0.3.0.2 - Robust space leak, and its strictification  http://hackage.haskell.org/package/leaky-0.3.0.2 (AndrewSeniuk)
05:25:41 <Narfinger> hiho, i have a question: i have a function of type ([b],http://en.wikipedia.org/wiki/Special:Search?go=Go&search=b) -> ([b],http://en.wikipedia.org/wiki/Special:Search?go=Go&search=b) but now i wonder if i can make this more generic, for example that it also works if the second part of the tuple is Data.Vector (Data.Vector b)) but i don't know how
05:27:20 <nr2_> hey all, anyone know what kind of systems wikileaks is based on?
05:27:32 <mbrock> Narfinger: your text is a bit garbled -- the types you wrote contain links to Wikipedia :)
05:27:47 <Narfinger> oh... sorry
05:27:49 <Narfinger> weird
05:27:55 <nr2_> would like to know kind of db, programming etc
05:28:06 <Narfinger> types are ([b], http://en.wikipedia.org/wiki/Special:Search?go=Go&search=b) -> ([b],http://en.wikipedia.org/wiki/Special:Search?go=Go&search=b)
05:28:14 <Narfinger> uhhh is there a bot replacing something?
05:28:33 <Narfinger> oh sorry my client
05:28:43 <Narfinger> ([b],[[b]]) -> ([b],[[b]])
05:30:45 <McManiaC> how is the performance/complexity of head vs last/tail vs init ?
05:30:51 <McManiaC> for regular lists
05:31:43 <rasen> head and tail are O(1), last and init are O(n)
05:31:56 <mbrock> Narfinger: ah. well, it depends on what your functions do with the lists. in some cases, Functor could work.
05:32:16 <valdyn> nr2_: mediawiki
05:32:27 <McManiaC> is there a data type in prelude that supports O(1) last/init ?
05:32:31 <McManiaC> or base
05:32:40 <Narfinger> mhhh ok that seems like it is a bit out of my understanding range :)
05:32:46 <Narfinger> so i guess i just decide and specialize it
05:32:49 <rasen> McManiaC: not im prelude
05:32:56 <rasen> in*
05:33:08 <saep> McManiaC: You can reverse the list logic. :p
05:33:34 <rasen> saep: reverse is O(n) itself
05:33:43 <nr2_> valdyn: thx
05:34:44 <mbrock> Narfinger: basically, if your function only uses `map' to transform the [[b]], you can switch to `fmap' and it will work on `f (f b)' for any Functor f, such as `Maybe (Maybe b)', `Vector (Vector b)', and so on
05:34:45 <rasen> saep: sorry. reversing logic is fine
05:35:32 <Dodek> hm, i'm debugging some weird tchan strictness issues
05:35:35 <Narfinger> ok thanks i will look into it
05:36:23 <Dodek> when I try to write an (error "foo") to TChan, it will not actually error out: instead, writeTChan will silently swallow the message, but on the other end nothing will be availbale for reading
05:36:29 <exio4> McManiaC: if you can give up lazyness, and want BOTH head/tail || last/init to be O(1), you could use Data.Sequence, if you only need last/tail, 'reversing the logic' is what you probably want
05:36:31 <mbrock> Narfinger: a more general recommendation is to find the time to read through most of the Typeclassopedia, which is an excellent introduction to some of the fundamental generalizations used in Haskell :)
05:37:02 <Narfinger> thanks, that looks interesting
05:39:11 <McManiaC> exio4: ah cool, sequence looks good
05:39:41 <Dodek> actually it seems that sending (error "foo") through TChan somehow silently breaks it
05:39:47 * hackagebot hadoop-tools 0.6 - Fast command line tools for working with Hadoop.  http://hackage.haskell.org/package/hadoop-tools-0.6 (JacobStanley)
05:42:28 <rasen> exio4: last/init, not last/tail
05:42:46 <exio4> uh, that, sorry, :P
05:46:46 <rasen> McManiaC: you should also know that ++ is O(n) where n is the length of first list
05:46:57 <McManiaC> ye
05:47:52 <rasen> That means reversing list isn't good strategy if you're going to append values to back
06:13:47 <vanila> hello
06:13:55 <vanila> has anyone responded to http://prog21.dadgum.com/54.html
06:14:04 <vanila> he says "After spending a long time in the functional programming world, and using Erlang as my go-to language for tricky problems, I've finally concluded that purely functional programming isn't worth it"
06:15:20 <alpounet> why bother? it's up to that person to embrace purely functional principles or not :)
06:15:50 <vanila> well im worried what if hes right?
06:16:14 <rasen> vanila: you should check and decide it for yourself
06:16:17 <barrucadu> The very first example he gives is odd, because implicit global mutable state is generally regarded as a bad thing in C as well
06:16:41 <vanila> most of the points he raised are different from the things i consider
06:17:55 <alpounet> vanila: if it's thought-provoking to you, you probably haven't lost your time, whatever the outcome is.
06:18:22 <alpounet> don't be worried and see where this leads you
06:19:01 <vanila> ok :)
06:19:19 <darthdeus_> what's the simplest way to have global mutable state these days anyway? I've only ever used http://hackage.haskell.org/package/foreign-store, which seems to work fine for tiny things
06:19:39 <alpounet> darthdeus_: depends on the use cases i'd say
06:19:49 <darthdeus_> alpounet: say storing thread ids
06:19:52 <nh2> anybody knows if anything came out of Roman Cheplyaka's `hasfix` tool he presented on ICFP 2012 to fix API changes?
06:20:11 <darthdeus_> for example, being able to store a specific thread in a global "hash table", and then retrieve it in other part of the app and do something
06:20:18 <alpounet> darthdeus_: you'd have to be more specific. quite often you can do that without having a global mutable container
06:20:50 <rasen> darthdeus_: global TVar or MVar?
06:21:07 <alpounet> and yeah, a quite common solution revolves around TVars and MVars
06:21:10 <rasen> or something like State
06:21:22 <alpounet> if you're sharing things between a bunch of threads
06:21:34 <darthdeus_> well but where do i keep the TVar/MVar?
06:21:50 <barrucadu> You give it to the things which need it
06:21:58 <rasen> you can do a = unsafePerformIO $ newTVar 0
06:22:01 <darthdeus_> but what if i don't want to restructure my whole program?
06:22:13 <rasen> I've read this this perfectly safe
06:22:22 <darthdeus_> I simply want to have 1-2 global mutable MVars that I can access anywhere (within IO monad)
06:22:27 <alpounet> you can do some "dirty" tricks like the one rasen mentions, but most of the time it's really just not worth it
06:22:41 <darthdeus_> alpounet: rasen but that's when I have it in a local binding
06:22:43 <exio4> darthdeus_: you normally want to use Reader/ReaderT to make that explicit
06:22:52 <barrucadu> rasen: Well, you can implement a function a -> IO b if you have global TVars/MVars/IORefs, which breaks type safety
06:23:01 <nh2> rasen: only safe if you put a NOINLINE pragma on it
06:23:20 <rasen> barrucadu: I was meaning that for top-level entries
06:23:23 <darthdeus_> exio4: that only works if I can re-structure the application
06:23:24 <vanila> What is the point of haskell being a pure functional language if everyone does unsafePerformIO and global mutable variables and stuff
06:23:28 <alpounet> darthdeus_: but then most of your logic is entangled with IO and you can't safely reason about anything anymore
06:23:42 <alpounet> and you can't complain to anyone if you get some weird behavior
06:23:44 <darthdeus_> I don't want to avoid IO, I simply want to have one global thread that I can kill any time I want (for development purposes, not production)
06:23:54 <rasen> vanila: nobody does it
06:23:59 <rasen> vanila: it's poor
06:23:59 <barrucadu> darthdeus_: I'd say that this is what abstraction is for. In the past when I've wanted to restructure the shared state my IRC bot uses, it wasn't a big deal, because everything was hidden away
06:24:55 <exio4> darthdeus_: if you only want a 'dirty thing' for development purposes or whatever, maybe the unsafePerformIO trick is what you want
06:25:03 <darthdeus_> barrucadu: in most cases yes, but in some cases it is impossible, let me give you an example... say that you have an application using something like snap/yesod, and you start a new thread during the application startup ... normally you dont care about the thread, since it lives as long as the app lives, but if i run this in GHCI and want to keep kiling the threads, I need a way to store-off the thread id
06:26:01 <darthdeus_> exio4: but even with unsafePerformIO, how do I store the global reference? since if I create a function to build the MVar, it'll simply create a new one every single time
06:26:10 <alpounet> darthdeus_: https://github.com/sol/reserve ? :)
06:26:42 <exio4> darthdeus_: top level definition
06:26:43 <kavin> hi
06:26:56 <darthdeus_> alpounet: does that work? :O looks interesting, though probably more specific than the example I usually encounter
06:27:18 <alpounet> darthdeus_: ask solirc but last time he talked to me about it, it was working fine
06:27:35 <alpounet> it may be a bit rough around the edges though
06:31:00 <darthdeus_> exio4: how? I can't do it like this, since that creates a new mvar every time https://gist.github.com/darthdeus/5590a186a9ab6ac6e60f
06:31:21 <darthdeus_> or will this work with the unsafePerformIO?
06:31:28 <alpounet> darthdeus_: just stick unsafePerformIO in front of newEmptyMVar
06:31:39 <exio4> darthdeus_: unsafePerformIO + NOINLINE
06:31:42 <alpounet> and add a {-# NOINLINE x #-} pragma
06:31:49 <darthdeus_> HA! perfect :)
06:31:50 <darthdeus_> thanks guys
06:32:01 <darthdeus_> I promise I won't abuse the newly gained powers :P
06:32:15 <alpounet> well, you'd be the one to suffer if you abuse them =)
06:33:08 <vanila> I think pure fp might be a mistake!
06:33:23 <vanila> ive never had a problem with it myself though.....
06:33:43 <vanila> im too influced by blogs lol
06:34:27 <alpounet> vanila: just write programs/applications/libraries using both paradigms, and see what suits you best and gives you the most reliable and pleasant programs
06:34:27 <rasen> that blog post was mostly about having implicit global state
06:34:47 <vanila> thats a good idea
06:34:53 <alpounet> i've made my choice, i'll never go back, but some people see things differently
06:35:01 <alpounet> and you really can only make that choice alone
06:35:17 <rasen> vanila: You could read another couple of posts saying it's bad to reverse the effect ;)
06:35:28 <vanila> haha
06:35:29 <alpounet> it's really useless (like in this post) to try to force down people's throat a particular paradigm
06:35:45 <alpounet> some other posts do it for pure fp, too
06:37:46 <darthdeus_> imho pure fp would be better if it was easier to have isolated efficient impure code :P
06:38:20 <_deepfire> what's the status of dynamic backtraces?
06:38:46 <darthdeus_> i'd be so happy if there was an easy way to just "embed C" in some way, like when I need to write a data structure and I know a fast imperative implementation, but doing it in haskell requires either adding 5 libraries, or writing magic evil dark magic code to make it faster
06:38:53 <_deepfire> <- another one slightly daunted by the prospect of installing an entire profiling-enabled toolchain in parallel..
06:39:16 <Trubydoor> it'd be nice to have a purely functional language that had impure {} blocks in the same way that rust has unsafe {} blocks for memory imo
06:39:48 <darthdeus_> yeah
06:39:48 <Axman6> darthdeus_: ST isn't good enough?
06:39:49 * hackagebot handsy 0.0.6 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.6 (utdemir)
06:40:00 <barrucadu> And it'd be up to the programmer to make sure the impurity didn't leak out?
06:40:35 <barrucadu> In that case, what advantage does that have over unsafePerformIO? eg, the Par monad uses that to get out a pure result, even though it's using threading under the hood, because the result is guaranteed to be deterministic
06:40:36 <darthdeus_> Axman6: well, ST makes me feel like I'm having to pray the compiler properly optimizes everything
06:40:43 <Trubydoor> I suppose? I mean the way that STM works is nice but obviously doesn't work in all cases
06:41:04 <Trubydoor> *ST sorry
06:41:27 <darthdeus_> Axman6: also sometimes you already have a C implementation either in your head, or on a paper, or somewhere, and you just want to use it, without spending hours thinking how to re-write it to make haskell happy
06:41:31 <darthdeus_> not saying that i need this often
06:41:40 <Yuras> vanila: IMO he is right. It is too common to write pure code only for purity itself. There is nothing wrong in impure code when it is necessary. I personally tend to pessimistically introduce IO when I'm not 100% sure it is not necessary.
06:41:42 <darthdeus_> but i can imagine a lot of cases where this would be good
06:41:42 <rasen> darthdeus_: use FFI
06:41:56 <Trubydoor> I'm not really talking about haskell here, just in general. Obviously it is basically the same as unsafePerformIO but you could possibly have a more imperitave syntax in there
06:42:02 <vanila> nice point Yuras I feel similar!
06:42:09 <darthdeus_> rasen: FFI is far from "easy"
06:42:55 <darthdeus_> rasen: or maybe I just need to practice using it more
06:42:59 <rasen> darthdeus_: It's not really hard.
06:43:39 <darthdeus_> rasen: you still need like 15 compiler flags to make it work though
06:43:41 <barrucadu> Yuras: You mean you'll write a function which does no IO, but give it an IO type (and `return` the result), just in case you want to add IOy things later?
06:43:56 <Yuras> barrucadu: yes
06:44:02 <rasen> darthdeus_: not a big deal
06:45:14 <Yuras> barrucadu: I'm writing haskell for food, and my customers want features more than they want pure code :)
06:45:18 <barrucadu> Hmm, that seems really weird to me. If nothing else, it makes people do a double-take and need to check the source when reading generated documentation
06:45:31 <barrucadu> Because otherwise they can't be sure it doesn't do anything weird
06:45:51 <alpounet> Yuras: well, let me contrast my experience with mine. I write haskell for a living too and benefit every single day from isolating pure bits from impure bits of my code. I do mean *every single day*.
06:45:57 <alpounet> err, your experience with mine*
06:46:24 <Yuras> alpounet: I don't add IO everywhere
06:46:26 <alpounet> everytime i'm weak and make too a bit too pervasive, it bites me at one point or another
06:46:34 <alpounet> and make IO*
06:46:41 <alpounet> damn, i should get another coffe
06:48:19 <Yuras> alpounet: I agree that localizing effects is a good thing, and I prefer to localize them. But it is just a design decision, it is sometimes wrong, and sometimes right
06:49:00 <alpounet> darthdeus_: the fact it needs a couple of flags/pragmas shouldn't be a reason for dismissing it. that's how we get bindings to a bunch of useful libraries. One example is BLAS for *really* fast linear algebra, the kind of performance we can't get with vanilla haskell. when you need to bind to C code, you can and it takes a couple of minutes once you know your way around the FFI
06:49:19 <Yuras> alpounet: I found myself introducing too often, so I try to be eager with that
06:49:56 <darthdeus_> alpounet: yeah, I'm not really dismissing FFI, I guess it's just hard to get into not having done it before ... maybe I need to learn it and write a tutorial about it :P
06:50:00 <Yuras> err, I found myself introducing too often *in existing code*
06:50:10 <alpounet> Yuras: well, in my experience it's quite simple. if a particular bit of code doesn't need any effect, leave it pure. you can test it and you *know* it doesn't depend on anything but its arguments. that's priceless
06:50:50 <rasen> Is there a way to get the whole UDP packet?
06:50:56 <alpounet> darthdeus_: it's pretty damn simple, sincerely. http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html is quite decent
06:51:11 <darthdeus_> alpounet: I'll check that out, thanks!
06:51:43 <Yuras> alpounet: that is almost always false for generic components
06:52:03 <alpounet> hm? could you expand?
06:53:51 <Yuras> alpounet: if you design a component that can be extended by clients, you should not limit your clients
06:54:22 <alpounet> Yuras: what kind of component?
06:54:23 <Yuras> alpounet: you should not decide for then whether they can use IO or not
06:54:37 <barrucadu> Yuras: And by adding an IO type signature, you are deciding that they must use IO
06:54:39 <Yuras> alpounet: plugin,
06:54:53 <barrucadu> Bu leaving it pure, they can incorporate it into their code as they wish
06:54:58 <barrucadu> *By
06:55:05 <alpounet> Yuras: dynamically loaded plugins you mean? and in what kind of app?
06:56:55 <Yuras> alpounet: I have a parser and render for liquid templates, https://github.com/Shopify/liquid/wiki/Liquid-for-Designers
06:57:26 <Yuras> alpounet: it is written in haskell and used in commercial software
06:57:51 <Yuras> alpounet: and it supports custom filters
06:58:19 <Yuras> alpounet: there are standard: https://github.com/Shopify/liquid/wiki/Liquid-for-Designers#standard-filters
06:58:21 <alpounet> Yuras: and the filters could do anything, like say get today's weather report and display it or something?
06:58:41 <Yuras> alpounet: right now they are pure
06:59:05 <t4nk231> what value is the value that a function has to return, in order for it to be printable
06:59:20 <nshepperd> well, isn't that why many libraries provide monadic versions of central functions
06:59:20 <Yuras> alpounet: but I *know* that one day my customer will come to me and ask for today's weather :)
06:59:32 <nshepperd> foldr vs foldM
06:59:40 <jmcarthur> t4nk231: any value having a type which is an instance of Show  (or at least i *think* this answers your question)
06:59:44 <Yuras> alpounet: so I made the interface impure
06:59:50 * hackagebot fwgl 0.1.0.2 - FRP 2D/3D game engine  http://hackage.haskell.org/package/fwgl-0.1.0.2 (ZioCrocifisso)
07:00:13 <nshepperd> if you don't need IO specifically you can write a version that accepts any monad
07:00:24 <t4nk231> jmcarthur then if a function returns an int should be printable correct?
07:00:32 <t4nk231> it should*
07:00:32 <geekosaur> t4nk231, I'm not sure that question makes sense without context
07:00:42 <geekosaur> (the original one)
07:00:46 <jmcarthur> t4nk231: the Int is printable. if you mean is the function printable, then no, because functions don't have a Show instance
07:01:05 <geekosaur> you'll have to explain what is leading to this "in order to be printable"
07:01:07 <alpounet> Yuras: then yeah, you have to allow IO if they ask, or offer them a custom DSL or something to express transformations and what not. but you obviously can't do that without IO, so you obviously need to offer the two possibilities: pure text transformation & effectful stuffs. i didn't say "IO is never needed", i was just suggesting it should only be used when strictly necessary
07:01:11 <t4nk231> let's say the function takes an int and returns an int
07:02:09 <Yuras> alpounet: and I didn't say "IO is always necessary" :_
07:02:40 <jmcarthur> t4nk231: there is a Show Int instance. there is no Show (Int -> Int) instance. still not sure i'm actually helping.
07:02:46 <alpounet> Yuras: yeah but you seemed to offer your example as a counter example? apologies if this wasn't what you meant, but we then lost 10 minutes talking about something kinda offtopic :p
07:02:57 <nshepperd> you can even write "only" a monadic api, and let the pure version just be the monad api specialised to Identity
07:03:54 <geekosaur> t4nk231, on the one hand, a value's type has to have some interface (Show, a prettyprinter, whatever) to render to a string-like type (String, Text, ...); on the other, you need to get it into IO to output it
07:04:27 <geekosaur> there may be other considerations (e.g. lifting through a monad stack) but I still have no context
07:04:56 <Yuras> alpounet: that the example where code doesn't need IO, but may need it in future
07:05:21 <Yuras> alpounet: it is obvious example, but there are harder cases
07:05:50 <alpounet> Yuras: well given a particular problem you're faced with, it's your call to make. i generally don't have that issue with the problems i'm faced with though.
07:06:12 <alpounet> this doesn't mean those problems don't exist
07:07:38 <nshepperd> Yuras: would your use case work if you made it (Monad m) => m instead of IO?
07:08:13 <nshepperd> or whatever level of polymorphism
07:09:21 <Yuras> nshepperd: the idea is that generic component should not limit it's extensions in any way, and IO is more general then Monad m =>
07:09:38 <nshepperd> ?
07:09:49 <Yuras> nshepperd: it is generic because nobody know how it will be used
07:10:34 <nshepperd> but... IO is an instance of Monad...
07:10:38 <Yuras> nshepperd: so nobody know whether the particulate context will work
07:11:23 <nshepperd> I do not mean you should require polymorphic input (that would be silly, that's equivalent to a pure api)
07:11:48 <jmcarthur> Yuras: i think in the context of an API it makes more sense that you don't know if it will be used with IO. i think the general argument against using IO when unnecessary applies more obviously to code you aren't exposing for others to use.
07:12:46 <jmcarthur> Yuras: however, if you can make your library polymorphic rather than specialized to IO, that is even better
07:12:59 <nshepperd> Yuras: if you do not actually use IO in the *implementation* of the API, then surely you can parameterise the impure api over a monad m
07:14:02 <sdegutis> bitemyapp: sorry, that was rude of me to put you on ignore like that... but please from now on, don't believe every random person you hear on IRC
07:14:05 <Yuras> jmcarthur: well, I don't want to use IO when it is not necessary. but issue is how to distinguish where it is necessary
07:14:15 <nshepperd> so that the IO api will be an instance of the polymorphic api
07:14:16 <sdegutis> Does anyone have a micro example of using the Reader monad?
07:14:28 <sdegutis> I've tried to use it but I can't wrap my head around how.
07:14:31 <Yuras> jmcarthur: take in mind that requirements tend to change
07:14:42 <nshepperd> but the user can still use eg. Reader if they don't need the full power of IO
07:14:47 <jmcarthur> Yuras: i think what nshepperd is saying is the way to go if possible
07:14:49 <Yuras> nshepperd: I don't understand, sorry
07:15:14 <jmcarthur> Yuras: he's saying that if you can just make your code work for an arbitrary monad then that is preferable to specializing it for IO
07:15:57 <darthdeus_> how can I pass -O2 to cabal build?
07:16:17 <rasen> ghc-options:
07:16:24 <Yuras> jmcarthur: yes, but how can I know?
07:16:24 <darthdeus_> rasen: and from the command line?
07:16:52 <Yuras> jmcarthur: for internal code it is more or less easy
07:16:57 <sdegutis> Womp womp, looks like my command line utility won't be able to do what I want, and I'll need to make a Haskell .app file.
07:16:57 <jmcarthur> Yuras: are you actually using any functions that return IO actions?
07:17:21 <jmcarthur> g2g
07:17:37 <tomphree1> what's the best Monad plug I could provide to a person wondering why he/she should bother with it?
07:18:28 <Yuras> jmcarthur: no, I don't use them right now. but I have no idea about future
07:19:05 <ClaudiusMaximus> darthdeus_: maybe  cabal configure -O2
07:19:51 * hackagebot fwgl-glfw 0.1.0.2 - FWGL GLFW backend  http://hackage.haskell.org/package/fwgl-glfw-0.1.0.2 (ZioCrocifisso)
07:20:45 <sdegutis> Is the Haskell plugin for Xcode still up to date?
07:21:45 <sdegutis> hoc seems very old
07:23:01 <darthdeus_> ClaudiusMaximus: thanks
07:24:51 * hackagebot fwgl-javascript 0.1.0.2 - FWGL GHCJS backend  http://hackage.haskell.org/package/fwgl-javascript-0.1.0.2 (ZioCrocifisso)
07:25:02 <tomphreek> anonymous friend: <<< I like lambdas in java, what do these "monad" things add?. Is there a canonical link I could provide?
07:26:23 <_deepfire> is wiki.haskell.org malfunctioning just for me?
07:26:28 <nshepperd> Yuras: I don't think there's such need to worry about the future
07:26:30 <vanila> tomphreek, well you know how ther are different types of side effects in java - like IO (printing things out, reading input from user), staet (editable variables), random number geneartors etc. etc.
07:27:17 <nshepperd> Yuras: polymorphic code that works for any monad can generally be specialised to IO easily, you just change the type signature
07:27:39 <tomphreek> I need a well-written paragraph/page why Monads are worth investigating for my anonymous friend.
07:28:14 <sgronblo> there was a link on hacker news recently to a decent answer on stackoverflow
07:28:33 <sgronblo> though i think most people will not be influenced by just a single simple answer
07:28:35 <mauke> tomphreek: monads are boring
07:28:54 <mauke> I don't think they're worth investigating
07:28:56 <Yuras> nshepperd: hmm, Handle in ghc is generic component, but it is not polimorphic
07:29:21 <Yuras> nshepperd: probably we simply use different terms
07:29:50 <geekosaur> _deepfire, malfunctioning how? but probably better asked in #haskell-infrastructure
07:30:08 <_deepfire> geekosaur, I see, thanks!
07:30:17 <nshepperd> well, Handle is a data structure that is for doing io
07:32:02 <rasen> I have written a torrent client in Haskell. It kind of works and now I want to visualize active blocks/what pieces downloaded etc. Is there a library for simple vizualization?
07:32:05 <nshepperd> Yuras: I can only think of one example right now, and that is something like foldM :: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:32:33 <Yuras> nshepperd: Handle is an IODevice under the hood
07:33:17 <nshepperd> Yuras: it allows for the user to read the weather or something while doing the fold, by specialising to foldIO :: (a -> b -> IO a) -> a -> [b] -> IO a
07:34:03 <Yuras> nshepperd: in your example there is only one side that decides what Monad instance to choose. but often you need more
07:34:34 <Yuras> nshepperd: foldM :: (Monad m1) => (forall m2. Monad m2 => a -> b -> m2 a) -> a -> [b] -> m1 a
07:37:09 <Yuras> nshepperd: in the example I provided, the monad instance is determined by client who what to render template; but there is other client -- author of a custom filter
07:38:26 <Yuras> nshepperd: there is no reason to force both to use the same Monad
07:39:08 <nshepperd> oh, I see
07:39:32 <Yuras> nshepperd: and I can work around any particular issue, but the idea is that I should not even try
07:39:44 <nshepperd> well, it doesn't work unless they use the same monad, does it?
07:40:03 <nshepperd> unless one of them can be lifted into a monad transformer over the other one
07:40:20 <nshepperd> so that they can be made to use the same monad
07:41:23 <Yuras> nshepperd: transformer may work in some case, but I prefer just to use IO
07:42:35 <nshepperd> well, nothing stops you from making you render function polymorphic, like render :: (Monad m) => Environment -> Template m -> m Text
07:43:13 <nshepperd> but Template m will obviously be restricted to using filters that (can be specialised to use) monad m
07:46:14 <nshepperd> filters like 'capitalize' and 'map' that are pure would be polymorphic and therefore always allowed, but you'd only be able to use something that gets today's date in an IO context
07:47:26 <nshepperd> but I can see how it would make sense for most such things to be pure or using IO in a template engine like that
07:48:05 <Yuras> nshepperd: I don't see how that may work. Looks like filters here have to be existential, type Filter = forall m. Monad m => Value -> m Value. But then filter can't use IO
07:48:47 <nshepperd> Yuras: no, you give Filter a type variable for the monad
07:48:59 <nshepperd> Filter m = Value -> m Value
07:49:30 <t4nk231> has anyone had experience with installing hat from cabal?
07:49:32 <Yuras> nshepperd: then it is the same as in render?
07:49:51 <nshepperd> Yuras: and then you have eg. capitalize :: Filter m (polymorphic)
07:50:10 <nshepperd> fetchWeather :: Filter IO
07:50:41 <Yuras> nshepperd: capitalize :: Filter Identity?
07:50:49 <Yuras> that wont work
07:51:22 <nshepperd> Filter Identity is equivalent to forall m. Filter m
07:51:27 <nshepperd> same thing
07:51:41 <hpc> not quite
07:51:50 <nshepperd> er, with (Monad m) restriction obvious
07:51:52 <nshepperd> ly
07:52:11 <hpc> Filter Identity -> Value -> Value -- this exists
07:52:24 <hpc> but the alternative does not exist for (forall m. Filter m)
07:54:13 <lpaste> ericdwhite pasted “Mixing pure code with IO and another Monad” at http://lpaste.net/119742
07:54:24 <nshepperd> generalise :: (Monad m) => Filter Identity -> Filter m; generalise = fmap (return . runIdentity)
07:54:55 <nshepperd> simplify :: (forall m. Filter m) -> Filter Identity; simplify = id
07:56:48 <nshepperd> bah, I keep forgetting to add constraints, but you get the picture
07:56:59 <nshepperd> Yuras: why won't it work
07:57:04 <sgronblo> uuh, how do i call ceiling on a Fractional a?
07:58:09 <sgronblo> ceiling seems to require RealFrac
07:59:52 <Yuras> nshepperd: I don't understand what your are trying to do
08:00:25 <Yuras> nshepperd: more important, I don't see why it is better then using IO
08:02:13 <nshepperd> I dunno, maybe it's not
08:02:27 <ericdwhite> Hi, I'm new to Haskell and have been trying to get a simple JSON rest API working.  However I can't seem to get the right combination of an IO monad to work with a monad defined in Scotty, in addition to a pure function.  I'm looking for some hints
08:03:07 <nshepperd> but letting bits that don't actually need IO be polymorphic allows you to use things in places IO isn't allowed
08:03:26 <Yuras> nshepperd: render function don't have IO in context (it is Monad m =>), so it can't fetch today's weather no mater what you do
08:03:28 <nshepperd> like user-facing code in lambdabot
08:03:34 <ericdwhite> I have pasted some code that does not compile at: http://lpaste.net/119742
08:03:40 <sgronblo> ericdwhite: maybe you need liftIO?
08:04:18 <nshepperd> Yuras: no, the render function itself can't fetch today's weather, which is good
08:04:37 <nshepperd> Yuras: but you can pass it a Filter IO that does fetch the weather
08:04:37 <Yuras> nshepperd: it is trivial to convert capitalize :: Value -> Value to :: Value -> IO Value
08:06:08 <nshepperd> (which then causes the render function to be instantiated as render :: Env -> Template IO -> IO Text)
08:07:17 <ericdwhite> @sgronblo thanks liftIO did the trick.
08:07:17 <lambdabot> Unknown command, try @list
08:07:33 <Yuras> nshepperd: oh, I see now. That is easy to archive by separating code that does actual rendering and applies filters
08:08:08 <Yuras> nshepperd: but your client probably want convenient function, that does both
08:11:00 <nshepperd> well, it's more that there are different kinds of filters, right?
08:11:13 <nshepperd> pure ones like capitalize and impure ones like getting the weather
08:12:33 <nshepperd> with the right kind of polymorphism you can make the same render function work for both kinds at once
08:12:57 <nshepperd> and automagically become a 'pure' render function when you happen to only be using pure filters
08:14:30 <nshepperd> anyway, it's bedtime
08:26:55 <benxyzzy> 4*5+1 evaluates like (4*5)+1 , but 18/3^2 evaluates like 18/(3^2) . How should I reason about (what would normally be called) operator precedence?
08:27:21 <mauke> as usual
08:27:34 <mauke> what's the problem?
08:27:36 <notdan> First ^, then * and /, after that + and -
08:28:12 <geekosaur> haskell (mis)calls it "fixity" since precedence and fixity are set with the same declarations (infix, infixl, infixr). ghci's :info shows this along with other information for operators
08:29:02 <benxyzzy> I understood (^), (+) etc. to be just functions in haskell, therefore I expected consistency in the chaining of function application like this
08:29:40 <notdan> @src (+)
08:29:40 <lambdabot> Source not found. Wrong!  You cheating scum!
08:29:47 <mauke> infix application uses operator precedence
08:29:49 <notdan> @src Num
08:29:50 <lambdabot> class  (Eq a, Show a) => Num a  where
08:29:50 <lambdabot>     (+), (-), (*)       :: a -> a -> a
08:29:50 <lambdabot>     negate, abs, signum :: a -> a
08:29:50 <lambdabot>     fromInteger         :: Integer -> a
08:30:08 <notdan> Uh, well lambdabot doesn't show that, but there is a precedence associated with each operator
08:30:12 <notdan> @src (^)
08:30:13 <lambdabot> x ^ 0            =  1
08:30:13 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
08:30:13 <lambdabot>   where f _ 0 y = y
08:30:13 <lambdabot>         f x n y = g x n
08:30:13 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
08:30:15 <lambdabot>                       | otherwise = f x (n-1) (x*y)
08:30:17 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
08:30:30 <benxyzzy> I am *very* new to haskell and functional programming
08:31:07 <geekosaur> Prelude> :info (+)
08:31:07 <geekosaur> (...) infixl 6 +
08:31:44 <notdan> benxyzzy: check this out, (+) has a precedense of 6: http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#v:-43-
08:31:56 <notdan> and (^) has a precedense of 8: http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#v:-94-
08:32:06 <benxyzzy> So it's because they're used in the infix form, that 'special' rules on order of evaluation can apply? And these rules can simply be defined as part of a function's behaviour?
08:32:16 <mauke> it's not order of evaluation
08:32:23 <notdan> infixr means that it is an infix operator, associating to the right
08:32:29 <mauke> and you can't define new rules, just precedence
08:32:54 <geekosaur> omitting operator precedence would be annoying since you'd need to use parentheses *everywhere*
08:33:00 <notdan> benxyzzy: it's the order of parsing, but you can tweak precedence for your own functions
08:33:38 <benxyzzy> OK that's basically what I meant, parsing /= evaluating
08:33:50 <geekosaur> so math operations are given the precedence they'd normally have, "control"-like operators (think (>>)) get very low precedence so they don't break up other expressions or force extra parens, etc.
08:34:54 * hackagebot calculator 0.1.5.2 - A calculator repl.  http://hackage.haskell.org/package/calculator-0.1.5.2 (sumitsahrawat)
08:36:47 <benxyzzy> Thanks, I will read up on fixity
08:37:25 <a3gis> hello! could someone tell me why this code closes the connection to the client if I send "get"? https://gist.github.com/a3gis/4cdf6fa7a24137dc8ac6
08:37:34 <a3gis> I would expect it to hang if the MVar is empty
08:37:39 <a3gis> or print whatever value is in it
08:37:50 <a3gis> but in both cases it simply closes the connection
08:37:51 <a3gis> silently
08:38:55 <a3gis> oh nevermind, if there is a value in the MVar it seems to print it
08:39:01 <a3gis> but if it is empty, it closes the connexion
08:41:51 <geekosaur> are you seeing the output from this somewhere? as written I think if your first command on a connection is a "get" then you have a deadlock, because the MVar is only reachable from the thread that is doing the takeMVar
08:42:01 <sdegutis> osa1: ping
08:42:07 <geekosaur> which IIRC will trigger an exception
08:42:08 <osa1> sdegutis: hey
08:42:18 <sdegutis> osa1: i see you wrote the only Lua bindings for Haskell
08:42:21 <a3gis> geekosaur: yep I just realised that! fixed it by created the MVar once and for all
08:42:28 <a3gis> in main
08:42:33 <a3gis> and passing it to sockHandler
08:42:44 <sdegutis> osa1: I been trying to write my own as a way to learn Haskell so I've been avoiding peeking at yours
08:42:47 <a3gis> still one question though: my initial code had the MVar at the top level
08:43:07 <a3gis> e.g. msg :: IO (MVar String) ; msg = newEmptyMVar
08:43:14 <a3gis> but it had the same issue as you just described
08:43:28 <a3gis> although in that case I would think it was shared between all threads?
08:43:59 <osa1> sdegutis: sorry, I had a problem with my connection
08:44:06 <sdegutis> osa1: ping
08:44:08 <sdegutis> osa1: i see you wrote the only Lua bindings for Haskell
08:44:09 <sdegutis> osa1: I been trying to write my own as a way to learn Haskell so I've been avoiding peeking at yours
08:44:16 <mauke> a3gis: why are you renaming newEmptyMVar?
08:44:26 <sdegutis> Just Eom
08:44:28 <geekosaur> it would be, yes. the question becomes, what do you expect to be the result if you have an MVar only accessible to a single thread, and that thread is blocked waiting for itself to put something in the MVar?
08:44:29 <osa1> sdegutis: actually I didn't write it, I'm just maintainer (accepting patches, occasionally writing blog posts etc.)
08:44:36 <osa1> sdegutis: cool
08:44:45 <sdegutis> osa1: oh -- well I had a question I was hoping you could answer without me peeking at the source
08:44:56 <geekosaur> or, what were you actually looking to do with this?
08:44:57 <osa1> sdegutis: sure
08:44:57 <a3gis> mauke: well I wanted to make the MVar available to all threads
08:45:01 <a3gis> but I think I get my mistake
08:45:20 <sdegutis> osa1: does this lib use the ref-trick to allow the user to hold "Lua values"?
08:45:40 <a3gis> geekosaur: is it possible to get more informative error than silent exit when there is a deadlock?
08:46:00 <geekosaur> I would have expected an exception to be written to stderr
08:46:17 <sdegutis> osa1: in other words, a regular Lua string can be converted to a Haskell string -- but a Lua function can't be stored as a Haskell value -- so the ref-trick is to just store it in a Haskell value that represents a ref on the Lua registry via luaL_ref, and push it when the user tries to use it
08:46:29 <sdegutis> osa1: is that what yall do?
08:46:30 <osa1> sdegutis: yes
08:46:34 <sdegutis> osa1: aww
08:46:37 <sdegutis> ok then
08:46:40 <osa1> :)
08:46:43 <a3gis> geekosaur: mmh well at least in ghci no exception is displayed
08:46:45 <sdegutis> I was hoping I'd have something unique -- but thats ok :)
08:46:55 <osa1> sdegutis: that's the only way you do it :)
08:46:58 <geekosaur> if one isn't being written, I am out of my depth and you will need to ask someone who knows more about how current runtimes work
08:47:24 <osa1> sdegutis: when you try to get a Lua value out of Lua, you register it in global registry
08:47:32 <sdegutis> osa1: I thought I cleverly invented that trick myself in my Swift bindings, until I realized it's been done before
08:47:36 <osa1> so that Lua can track it and don't garbage collect it
08:47:52 <osa1> then when you decide to let the value go, you unregister it so that Lua can garbage collect
08:47:55 <a3gis> geekosaur: ok; thank you :)
08:48:17 <osa1> sdegutis: sorry for disappointing you :)
08:48:35 <sdegutis> osa1: how do you know when to release it from the registry, given Haskell has no "finalize" thing?
08:48:43 <osa1> sdegutis: so the index of that Lua function in global registry is now like a pointer
08:48:49 <osa1> pointer to Lua land
08:49:00 <osa1> Haskell has finalize thing
08:49:03 <osa1> see ForeignPtr
08:49:07 <geekosaur> hm, ghci may be more complicated since reachability is different and thread scope is different :/
08:49:14 <geekosaur> try it with a compiled program
08:49:26 <sdegutis> ok thanks osa1 -- I may just use your bindings instead of writing my own
08:49:46 <geekosaur> (specifically, the prompt can at least in theory "reach" things that otherwise wouldn't be reachable)
08:49:55 <osa1> sdegutis: mine needs a lot of refactoring and tests, if you want to contribute :-)
08:51:32 <sgronblo> basic math in haskell is so hard
08:51:46 <osa1> sdegutis: see also http://osa1.net/posts/2014-04-27-calling-haskell-lua.html and http://osa1.net/posts/2015-01-16-haskell-so-lua.html
08:52:09 <sgronblo> I'm trying to divide an Int by 5, floor it, then multiply by 5 again and return as Int
08:52:22 <sgronblo> but I'm having no luck converting to and from the typeclasses
08:52:27 <HeladoDeBrownie> @type div
08:52:28 <lambdabot> Integral a => a -> a -> a
08:52:31 <mauke> n `div` 5 * 5
08:53:25 <zachk> > (101 `div` 5) * 5
08:53:26 <lambdabot>  100
08:53:48 <zachk> using mod might be faster then that if you care about speed
08:54:07 <cmccann> if sgronblo wants to floor the result, div is not the right answer
08:54:20 <zachk> > (101 - (mod 101 5))
08:54:22 <lambdabot>  100
08:54:26 <sgronblo> works just fine in ghci
08:54:52 <cmccann> sgronblo: you probably want something like floor (fromIntegral x / 5) * 5
08:55:46 <mauke> cmccann: why?
08:56:03 <HeladoDeBrownie> i assume negatives do the wrong thing
08:56:10 <zachk> is mod a modern CPU instruction?
08:56:38 <HeladoDeBrownie> > -101 `div` 5 * 5 == floor (fromIntegral (-101) / 5) * 5
08:56:39 <lambdabot>  can't find file: L.hs
08:56:43 <HeladoDeBrownie> > -101 `div` 5 * 5 == floor (fromIntegral (-101) / 5) * 5
08:56:45 <lambdabot>  False
08:57:10 <sgronblo> I'm being fancy with composition
08:57:11 <haskell691> how to set paths to dependencies when installing packages with cabal (cabal configure xx=path/to/smth?)
08:57:30 <cmccann> mauke: sgronblo said "divide and integer by 5 and floor it", and you don't need to floor the result of integer division
08:57:47 <mauke> cmccann: ???
08:58:33 <HeladoDeBrownie> i think what matters is whether you get the same result as having floored it, rather than literally using floor. it happens that div does not do that
08:58:48 <cmccann> mauke: ??? what? idk, I'm in the middle of eating lunch so maybe I missed something here
08:59:25 <dcoutts_> haskell691: simplest is to say: cabal install ./foo/ ./bar/
08:59:48 <geekosaur> zachk, most CPUs have some kind of divmod instruction
08:59:57 <dcoutts_> haskell691: or for setting up an env where those others are always known, and rebuilt as needed, use a sandbox and add those source dirs to the sandbox
09:00:37 <sgronblo> I removed my type signature for this one signature and now ghc-mod is suggesting some signature that seems to require rankntypes
09:00:58 <HeladoDeBrownie> sgronblo, what is that signature?
09:01:34 <HeladoDeBrownie> if it just has forall at the front you can omit that
09:01:46 <HeladoDeBrownie> (forall is implicit for all variables occurring free in the type)
09:02:07 <sgronblo> http://pastebin.com/3pLTdMPK here is what I am struggling with
09:02:37 <HeladoDeBrownie> it's as i said. just take out the forall and you're good
09:03:36 <dcoutts_> haskell691: it's best to ask Qs on the main channel
09:03:36 <sgronblo> no because i still have no instance Fractional Int
09:04:20 <HeladoDeBrownie> sgronblo, that probably means you didn't write the function you wanted to write
09:04:36 <HeladoDeBrownie> sgronblo, cmccann's suggestion seemed to be what you wanted
09:05:26 <haskell691> <dcoutts_> ok then.. i've been trying to install the hat package.. after various types of errors and crashes i got it to install but it seems to work in a haphazard manner
09:06:06 <haskell691> it requires happy, haskeline, * which were all acquired
09:06:20 <haskell691> and ofc ghc and cabal
09:07:06 <dcoutts_> oh, I didn't realise hat was being maintained again
09:07:11 <dcoutts_> that's nice
09:07:22 <haskell691> i'm not sure it is..
09:07:32 <haskell691> depending on the kk of errors i got
09:08:06 <tomphreek> there's no binary tree in data. right? I just see a multi-way one.
09:08:23 <dcoutts_> haskell691: well, it was uploaded in 2013, that's more recent than I was expecting
09:08:43 <darthdeus_> what is the currently best haskell indentation mode in emacs? or the one that indents the same way everyone formats their code? ... I'm finding it hard to pick one, since all of them indent a bit differently from what I see elsewhere
09:09:08 <dcoutts_> tomphreek: not in the core libs, no
09:10:22 <sgronblo> now im back to where i started where i had these annoying warnings about ghci guessing a type to be Double
09:11:00 <haskell691> hat-make (some _.hs containing ` main = do print ("qwe") `) after that executing it, after that calling hat-trail _.hat seems to be working fine but it's clearly trivial
09:11:26 <geekosaur> you might just be better off turning off those warnings
09:11:54 <sgronblo> cant i just put some type hint to please ghc-mod instead
09:11:57 <geekosaur> they're sometimes useful but often just noise, since one of the points of defaulting is to make various things work more easily
09:12:07 <HeladoDeBrownie> sgronblo, please post any relevant errors/code
09:12:27 <cmccann> sgronblo: what do you think the type of "peg" should be?
09:15:26 <cmccann> sgronblo: keep in mind that (/) only works on fractional types, and floor/ceiling convert fractional types to integral types
09:15:58 <sgronblo> this is what i have currenty http://pastebin.com/bNFgrBAA
09:17:22 <flounders> I working through an exercise for a Haskell course and I am running into this error with the type signature supplied by the assignment: http://lpaste.net/119745
09:18:08 <sgronblo> feels like if i could just squeeze a :: Double into the right place it would all be fine
09:18:45 <HeladoDeBrownie> sgronblo, floor and ceiling are what's being defaulted, because their input type is not specified.
09:18:57 <HeladoDeBrownie> sgronblo, what type did you want to use for them instead?
09:19:32 <cmccann> sgronblo: if you want to get rid of the warnings, just replace the "b" in peg's type with Double
09:19:39 <cmccann> or some other fractional type
09:20:14 <haskell691> <dcoutts_> the same done with http://lpaste.net/119749 results in http://pastebin.com/MJyUKMDB after calling hat-make
09:21:06 <dcoutts_> haskell691: your original program has the same error
09:21:15 <dcoutts_> haskell691: it's not a hat problem
09:21:28 <sgronblo> cmccann: ok, but wouldnt that tie down the function to require Double then?
09:21:39 <cmccann> sgronblo: yes
09:21:40 <sgronblo> I thought I was supposed to keep my types as open as possible
09:21:53 <dcoutts_> haskell691: try declaring that fib has type Int -> Int
09:22:24 <cmccann> sgronblo: then add a type annotation to floor and ceiling, e.g. (floor :: Double -> Int) or whatever
09:22:25 <dcoutts_> haskell691: or use: main = print (fib 10 :: Int)
09:22:42 <sgronblo> cmccann: Ah, that sounds promising
09:23:49 <cmccann> sgronblo: and anyway, defaulting is there for a reason, I'd just ignore the warnings
09:24:30 <haskell691> <dcoutts_> it worked with Int -> Int
09:24:37 <haskell691> but gave only the end result
09:25:09 <HeladoDeBrownie> sgronblo, ordinarily yes, although this is an interesting case. does peg get exposed on an outside interface?
09:25:24 <sgronblo> Well I use syntastic which pops up a huge extra error buffer with the warnings too
09:25:50 <HeladoDeBrownie> (e.g., exported from a module)
09:25:50 <sgronblo> HeladoDeBrownie: nope. I just thought it would be poor style to define the types too concretely instead of relying on type classes.
09:26:16 <HeladoDeBrownie> sgronblo, ah, well since you only ever use it at Double, you could as well fix it on Double, and then you don't need to specify the types of floor and cel.
09:26:46 <cmccann> flounders: what's the type of getSize? alternately, where is the module Sized coming from?
09:26:48 <HeladoDeBrownie> sgronblo, i'd say it wouldn't be poor style here, especially since you don't plan to export it
09:27:02 <HeladoDeBrownie> s/cel/ceil/
09:27:22 <haskell691> <dcoutts_> how does the type has to change in order for `main = fib 10` to work
09:27:37 <haskell691> it should include IO() along the way probably
09:27:38 <haskell691> or?
09:27:43 <flounders> cmccann: Sorry it's supplied with the assignment.
09:28:04 <HeladoDeBrownie> haskell691, you could write main = print (fib 10)
09:28:06 <sgronblo> HeladoDeBrownie: right, but i wanted to practice doing it the right way
09:28:15 <HeladoDeBrownie> haskell691, but yes, main must have an IO type
09:28:28 <haskell691> i did but that way i get only the end result
09:28:29 <flounders> cmccann: http://www.seas.upenn.edu/%7Ecis194/spring13/extras/07-folds-monoids/Sized.hs
09:28:54 <HeladoDeBrownie> sgronblo, i'd say this is the right way. you're not wrong that it's good to write things generally, but in this case the generality is… i'd say it's in the wrong place, and by fixing that one type variable you actually make things nicer.
09:29:09 <flounders> cmccann: I am working on the Week 7 homework listed here: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:29:21 <a3gis> is there a maximum number of retries on "atomically"? in my tests it seems that it gives up after 3-4 retries
09:29:22 <HeladoDeBrownie> haskell691, what did you want instead?
09:29:37 <dcoutts_> haskell691: main has to be of type IO (), and fib 10 is of type Int
09:29:40 <a3gis> silently returning without performing the atomic block
09:29:53 <dcoutts_> haskell691: so printing is probably what you want, as you were doing before
09:30:02 <haskell691> <dcoutts_> can't IO be incorporated as a resulting type
09:30:03 <cmccann> flounders: ok, getSize expects an argument of type Size. you're applying it to "tag l1" and "tag l2" which have type "b"
09:30:28 <cmccann> flounders: it can't specialize "b" to Size because you explicitly specified that the function be polymorphic, that's what the compiler error is about
09:30:30 <haskell691> Int -> IO[()] ...
09:31:10 <cmccann> flounders: based on the existence of the "size" function, I think you probably want "getSize . size" instead of just "getSize"
09:31:18 <haskell691> excuse the silliness of the question
09:31:47 <cmccann> flounders: plus you have a "Sized b" constraint, which also suggests that conversion
09:31:56 <HeladoDeBrownie> haskell691, you can perfectly well have a function return an IO value, yeah
09:32:16 <HeladoDeBrownie> haskell691, what is it you wanted besides the end result though?
09:32:16 <cmccann> flounders: since that's saying exactly that you expect to be able to apply the function "size" to things of type "b"
09:32:32 <a3gis> My test program is: https://gist.github.com/a3gis/4cdf6fa7a24137dc8ac6. I start 2 clients, then run "add +x" on one and repeatedly run "set a" on the other, within the 5 second delay
09:32:55 <a3gis> If I only do this 2-3 times, it works as expected and retries the block until I stop changing the value of the TVar
09:33:03 <a3gis> at which point it adds +x to the current value
09:33:19 <a3gis> but if I do it more than 2-3 times, it seems to silently skips the block
09:33:34 <flounders> cmccann: Yeah I understand what you are saying. Working through the details right now.
09:33:46 <cmccann> flounders: ok
09:34:08 <a3gis> what might happen is that it sets the TVar to a new value and I override it with my "set a", but since there is a 5s delay I guess this should not happen?
09:34:22 <a3gis> to be clear, I call "set a" with different values for "a" each time
09:34:56 <flounders> cmccann: Thanks for the suggestion that did the trick.
09:35:17 <haskell691> <HeladoDeBrownie> i wanted to trace through the execution step by step
09:35:26 <cmccann> flounders: do you understand why you got the error before and why that fixed it? this is homework, after all :]
09:35:30 <haskell691> every reduction, everything that takes place
09:36:53 <HeladoDeBrownie> haskell691, in what way? what information do you want at each step?
09:37:28 <flounders> cmccann: I know I was imposing specific type requirements. What I am trying to figure out is where my misunderstanding of what its type was took place.
09:37:49 <HeladoDeBrownie> haskell691, here's one idea, depending on what you want
09:37:52 <HeladoDeBrownie> @type scanr
09:37:53 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
09:38:15 <HeladoDeBrownie> haskell691, that's basically a fold except it returns the list of every step of the fold instead of just the final result
09:39:04 <jmcarthur> haskell691: is this for debugging, or will the be the final output of the program?
09:39:10 <jmcarthur> *or will this be
09:39:15 <haskell691> debugging
09:39:40 <jmcarthur> we have a module Debug.Trace that offers some printf style debugging tools
09:39:44 <a3gis> I must be missing something about how "atomically" works; from what I can see it seems that after "waitDelay" is executed, before writeTVar, it realises that the value of the TVar has changed, so it re-executed readTVar, then goes immidiatly to executing writeTVar
09:40:01 <jmcarthur> it's not quite as obvious how to use it as in most languages though, since it works in otherwise pure functions
09:40:24 <cmccann> unsafePerformPrintfDebugging
09:40:42 <flounders> cmccann: I was thinking that m was already of type Size.
09:41:37 <haskell691> <jmcarthur> i came to the same conclusion, that's why i tried an alternative path..
09:41:42 <jmcarthur> haskell691: Debug.Trace is probably what you want for this. just keep in mind it's *really* only meant for temporary debugging, and it is best to remove all traces of it by the time you are done
09:41:56 <haskell691> surely
09:42:05 <halvorg> Hi, could anyone look at this .cabal file for me? I get errors when trying to run the executable that uses the library.
09:42:08 <halvorg> https://github.com/halvorgb/mish/blob/master/mish.cabal
09:42:26 <jmcarthur> haskell691: it's not *that* hard to use, though. it gives you tools to wrap expressions such that a message is printed when the result of the expression is demanded
09:42:34 <haskell691> <jmcarthur> but what's the point in making the hat package at all
09:42:38 <halvorg> link errors of the type: /.../develop/mish/dist/build/libHSmish-0.0.1.0.a(MissionGenerator.o):(.text+0x150): undefined reference to `mishzm0zi0zi1zi0_MishziConnectorGenerator_zdwzdsgo10_info'
09:42:40 <jmcarthur> the hat package?
09:43:00 <haskell691> if the same fuctionality is already there
09:43:06 <zipper> Which haskell type should one use to handle money?
09:43:25 <jmcarthur> haskell691: i have never used the hat package, but it looks like it doesn't something totally different from Debug.Trace
09:43:26 <HeladoDeBrownie> zipper, not Float, not Double. possibly Integer
09:43:34 <HeladoDeBrownie> zipper, for implementing a money type, i mean
09:43:35 <Iceland_jack> zipper: Try Decimal
09:43:44 <Iceland_jack> @hackage Decimal
09:43:44 <lambdabot> http://hackage.haskell.org/package/Decimal
09:43:49 <Lokathor> the ghc documentation assumes that if you install it on windows, you'll have a bash shell. what even.
09:43:52 <jmcarthur> haskell691: Debug.Trace just gives you printf-style tools. it looks like hat writes a trace file for later inspection
09:43:53 <zipper> HeladoDeBrownie: Integer? But what about cents?
09:44:01 <zipper> Iceland_jack: Thanks
09:44:06 <HeladoDeBrownie> zipper, the Integer is the number of cents
09:44:08 <cmccann> flounders: because it is a size value, I suppose? since the issue is "type that is Size" vs. "type that can be converted to Size"
09:44:13 <flounders> cmccann: Obviously the way I was using getSize was infering a different type than the type signature. And it would appear that the size function gives me a polymorphic way of dealing with any implementation of Sized such that I can use getSize on it.
09:44:35 <zipper> Iceland_jack: is HeladoDeBrownie making sense?
09:44:40 <Iceland_jack> zipper: There is also a package called 'currency' but I have not used it
09:44:46 <haskell691> <jmcarthur> it claims that it does.. but seems to give only the end result.. most likely i'm not using it right
09:44:47 <HeladoDeBrownie> zipper, this of course also assumes you don't need a fractional number of cents
09:45:01 <jmcarthur> haskell691: what claims what?
09:45:07 <Iceland_jack> zipper: It depends on your needs really
09:45:43 <HeladoDeBrownie> zipper, what was unclear from what i said?
09:45:53 <haskell691> <jmcarthur> after making the _.sh file and running it you can inspect it whit hat_* (hat_trail, and so on)
09:45:58 <cmccann> flounders: the type of getSize is (Size -> Int), so yes, anything you apply it to will be inferred to have type "Size".
09:46:02 <jmcarthur> ah
09:46:17 <jmcarthur> well, having never used hat (or even remember hearing about it), i don't know that i can you there
09:46:38 <cmccann> flounders: note also the (Sized b) constraint in the type signature, which I believe was given to you as part of the assignment
09:46:42 <haskell691> <jmcarthur> i see ;) thank you for the effort though
09:46:50 <flounders> cmccann: Yes it was.
09:46:51 <jmcarthur> *can help you there
09:47:07 <cmccann> flounders: that means that "b" has an instance of the type class "Sized", which is where the "size" function comes from
09:47:32 <cmccann> flounders: so that part of the type signature is basically saying "this works on all types 'b' such that I can convert them to a Size value"
09:47:37 <flounders> cmccann: I guess I need to look at type classes more closely.
09:47:54 <zipper> HeladoDeBrownie: Uh the only way cents can be held by integer if there was a record type to data Money =  Money {dollar :: Int, cents  :: Int}
09:48:13 <dcoutts_> halvorg: you missed the Mish.Connector module from the library modules
09:48:38 <halvorg> dcoutts_: but I dont want to expose that, im not using it directly.
09:48:48 <dcoutts_> halvorg: list it in other-modules
09:48:59 <HeladoDeBrownie> zipper, Int is not good for money. but no, just erase the "." in the dollar-cent representation. voila, you have a number of cents.
09:49:00 <flounders> cmccann: Learning Haskell is really stretching my mind. My background so far has been in C and Python.
09:49:00 <halvorg> oh, thanks
09:49:52 <HeladoDeBrownie> (again, assuming you're using two digits for cents and not any fractional cents)
09:50:58 <Luke> hvr: is there a reason ghci-ng requires base < 4.7
09:52:10 <cmccann> Iceland_jack: currency appears to be about dealing with multiple currencies and exchange rates. I don't think that's what zipper needs. :] Data.Decimal is the way to go, I think.
09:53:12 <Iceland_jack> cmccann: Thanks for pointing that out!
09:58:30 <HeladoDeBrownie> zipper, i see what you were confused about. when i said "cents", you were taking it to mean "the number of cents left over besides the amount of dollars involved". but really i meant "the total monetary value, represented as cents"
09:59:33 <HeladoDeBrownie> zipper, anyway Decimal does look nice, Integer would mostly be okay if you don't need any operations too complicated
09:59:49 <zipper> HeladoDeBrownie: You want me to represent 2.50 as 250?
10:00:05 <ChristianS> zipper: yes, that's good practice
10:00:08 <HeladoDeBrownie> zipper, yep, that's what i was saying. i just realized i gave no examples, sorry about the confusion
10:00:09 <Iceland_jack> zipper: That's not unreasonable
10:00:22 <ChristianS> zipper: that's what the big webshops do from what i know
10:00:26 <Lokathor> flounders, same
10:00:26 <fread2282> zipper: Rational also works
10:00:36 <ChristianS> zipper: it's easy and works well
10:00:40 <trap_exit_> is https://github.com/dysinger/purescript-mode the best for purescript + emacs usage right now?
10:00:49 <trap_exit_> wrong channel, sorry
10:01:41 <HeladoDeBrownie> yes, depending on your use case, any of Decimal, Rational, or Integer could work. definitely do not use Float, Double, and most likely Int is also bad.
10:01:53 <Haskellfant> Hi, I'm trying to write a typesafe zipWith for n-ary trees. To do that I'm trying to add a TreeShape type parameter to my Tree type, but I'm stuck. I need to somehow make a list like TreeList but only Trees should be allowed to be in there but the type of the shape of the trees needs to vary. MapToShapes should then take this list and return a BranchS of shapes. This is what I got so far
10:01:55 <Haskellfant> http://lpaste.net/119750
10:02:15 <hvr> Luke: yes, because the version on Hackage was only for GHC 7.6
10:02:36 <Luke> ah - any plans to update it?
10:02:37 <hvr> Luke: all its features were merged into GHC 7.8's ghci
10:02:38 <zipper> ChristianS: Big web shops use ints to hold money?
10:02:48 <Luke> hvr: oh nice!
10:02:54 <Luke> great news
10:02:55 <hvr> Luke: otoh, you may want to follow https://github.com/chrisdone/ghci-ng
10:03:03 <Luke> hvr: that's what I'm following
10:03:19 <ChristianS> zipper: long or something, more likely. but yes, integral numbers, not decimal and certainly not float.
10:03:22 <Luke> hvr: er, this: https://github.com/chrisdone/emacs-haskell-config
10:03:41 <AlexStamoose> hello?
10:03:46 <geekosaur> big money shops typically use ints to hold money. big web shops probably use doubles in php, who cares if you lose track?
10:03:51 <hvr> Luke: so chris has taken over ghci-ng for incubating new GHCi features
10:04:15 <Luke> hvr: i'm just trying to get up to date with the latest and greatest haskell emacs stuff
10:04:15 <geekosaur> (most commonly the int holds either cents or tenths of cents, in my experience)
10:04:35 <Luke> hvr: as long as the auto-complete etc stuff works in 7.8 i should be good
10:04:42 <hvr> Luke: /join #haskell-emacs :)
10:04:42 <HeladoDeBrownie> geekosaur, when you say int, do you mean arbitrary-precision integers?
10:04:49 <Luke> oh
10:05:02 <geekosaur> I am not specifying the size at all, but it's usually larger than 32 bits
10:05:11 <Luke> thanks
10:05:35 <HeladoDeBrownie> it seems like you'd have to be really careful to use limited-precision integers to calculate with money
10:06:05 <halvorg> so I have one library in a separate cabal project and a consumer of that library in another project. Is it possible to include said library without uploading to hackage?
10:06:14 <halvorg> SBT allows include from git for example
10:06:33 <geekosaur> (also this is a holdover from COBOL's fixed precision types where PIC 9999V99 is a 6-digit integer type with an implied decimal point. see also SQL's DECIMAL)
10:06:36 <HeladoDeBrownie> halvorg, cabal install path/to/dependency
10:06:56 <HeladoDeBrownie> halvorg, (i also recommend sandboxing in case that wasn't implied)
10:07:17 <halvorg> so download the dependency, then install it?
10:07:18 <mizu_no_oto> I'm trying to install Idris on my mac, and cabal is failing to install haskeline.  It seems that it's failing because "ld: library not found for -lncursesw".  Anyone have any ideas?
10:07:18 <hexagoxel> halvorg: with sandboxes, look at `add-source`
10:07:28 <HeladoDeBrownie> halvorg, yeah
10:07:48 <geekosaur> mizu_no_oto, you have managed to convince it that OS X is Debian
10:08:07 <halvorg> thanks guys, ill look into that
10:08:16 <geekosaur> OS X does not have ncursesw, because ncurses folded the wide version into the main one year ago and only slow-to-update folks like Debian still have a separate ncursesw
10:08:32 <HeladoDeBrownie> wait, did i imagine that feature existing?
10:08:35 <geekosaur> (well, even Debian is faking it for backwards compatibility...)
10:09:01 <mizu_no_oto> geekosaur: any idea how I did that or how I fix it?
10:09:01 <geekosaur> s/one year ago/one many years ago/
10:09:08 <HeladoDeBrownie> oh, never mind, i just used a bad test case
10:09:10 <geekosaur> I would have expected it to figure it out for itself
10:09:21 <MrPopinjay> Hello! Newbie here. What should I do when a library fails to install? I wish to `cabal install hsc3`, but I get a rather alarming error message: "`bitSizeMaybe' is not a (visible) method of class `Bits'", which looks like it might be a little more wrong than just my lack of cabal understanding. (also, is there a must-read introduction to building and package management for Haskell?)
10:09:22 <geekosaur> did you install a separate ncurses from somewhere?
10:09:46 <tomphreek> struggling with breadth first infinite binary tree initialisation from an infinite list :*
10:09:49 <tomphreek> :(
10:09:52 <geekosaur> MrPopinjay, that sounds like an out of date Haskell distribution to me
10:10:16 <geekosaur> hm, no
10:10:20 <MrPopinjay> Possible. I'm on Debian testing. How might one test this geekosaur ? :)
10:10:28 <MrPopinjay> Thank you, by the way
10:10:33 <geekosaur> it's not in current Data.Bits, think it was a transitional thing
10:10:36 <HeladoDeBrownie> ghc -v
10:10:44 <HeladoDeBrownie> MrPopinjay, what version does that ^ give?
10:10:58 <geekosaur> aha, it is in still more recent ones than I looked at
10:11:03 <sdegutis> osa1: I think I'll borrow some ideas from the Lua lib you maintain, but implement a slightly different interface; deal?
10:11:13 <geekosaur> sigh, too many ghc versions floating around
10:11:50 <tomphreek> it should just be a Node list!!i (Node list!!(2i+1) ...) (Node list!!(2i+2) ...)
10:11:52 <HeladoDeBrownie> geekosaur, they should have ghc pop up annoying "do you want to upgrade ghc?" message boxes that don't go away until they upgrade
10:11:54 <geekosaur> 7.8.3 (current platform), 7.8.4 (latest released), 7.10rc2 (unreleased testing version) with different base versions
10:12:05 <sdegutis> When is 7.10 coming out?
10:12:06 <MrPopinjay>  7.6.3, stage 2 booted by GHC version 7.6.3.
10:12:16 <sdegutis> And what are 7.10's awesome features?
10:12:38 <geekosaur> sdegutis, nobody knows yet. original plan was next month but there's some issues that cropped up that may lead io it being delayed
10:12:41 <hexagoxel> `ghc -v` indeed gives slightly more information than `ghc --version`, or `ghc --version -v`. great.
10:12:51 <sdegutis> So far Haskell looks like a reasonable alternative to Rust.
10:12:53 <HeladoDeBrownie> MrPopinjay, well, that's not most current, which may or may not be causing the issue. you can download a more recent version from https://www.haskell.org/ghc/
10:13:17 <HeladoDeBrownie> MrPopinjay, out of curiosity, what does `cabal -V` give?
10:13:18 <geekosaur> (while the one generating the most heat is foldable/traversable, the one most likely to delay it is the bug that allows deriving unsafeCoerce under Safe Haskell)
10:13:20 <MrPopinjay> HeladoDeBrownie: Thank you. I grabbed the "Haskell Platform", is this not correct?
10:13:32 <Clint> MrPopinjay: in general if you install from debian you'll experience a lot less pain
10:13:35 <geekosaur> that is an out of date platform
10:13:36 <HeladoDeBrownie> MrPopinjay, it can be correct. however some latest versions of packages are dependent on latest ghc.
10:13:37 <MrPopinjay> cabal-install version 1.20.0.3
10:13:39 <MrPopinjay> using version 1.20.0.2 of the Cabal library
10:13:42 <geekosaur> the current platform release comes with ghc 7.8.3
10:13:43 <HeladoDeBrownie> MrPopinjay, s/some/many/
10:13:46 <geekosaur> not 7.6.3
10:13:50 <HeladoDeBrownie> oh, didn't know what geekosaur just said
10:14:13 <geekosaur> but if you got your platform from, say, debian apt-get, then you will have an out of date one
10:14:14 <Clint> also you can grab ghc 7.8 out of debian experimental if you really need it
10:14:27 <HeladoDeBrownie> okay, that's a recent (although not the most recent) cabal
10:14:30 <sdegutis> MrPopinjay: you on mac?
10:14:34 <geekosaur> because the current platform just missed the cutoff
10:14:51 <MrPopinjay> I'm going to blame Debian. I'm used to scripting languages such as ruby, there it's common to use a program called rbenv install to handle this stuff. Is there something similar for Haskell?
10:15:05 <MrPopinjay> sdegutis: Debian Linux. Though I also use OSX when I'm on my work machine
10:15:08 <sdegutis> oh nm
10:15:23 <Clint> cabal sandbox
10:15:25 <sdegutis> was gonna recommend http://ghcformacosx.github.io/
10:15:32 <geekosaur> MrPopinjay, fgor multiple ghc releases there is hsenv
10:16:03 <sdegutis> lol, bitemyapp's "community guidelines" says "Be nice above all else!"
10:16:05 <sdegutis> irony
10:16:25 <HeladoDeBrownie> the recommendation i usually give is to download current ghc from haskell.org, install the cabal-install distro package, and use the packaged cabal-install to upgrade to latest cabal-install, then install any other packages you need using cabal-install
10:16:28 <geekosaur> sndboxes answer a somewhat different use case, you can't get a new base simply by tossing it in a sandbox
10:19:40 <HeladoDeBrownie> geekosaur, hmm, is there anything in cabal that lets you specify which ghc to use? say i have ghc installed in multiple directories
10:20:03 <HeladoDeBrownie> i mean, per-sandbox or per-project
10:20:10 <geekosaur> --with-ghc=...
10:20:24 <geekosaur> I think that translates to ghc-program in a config
10:20:31 <geekosaur> (per-user or per-sandbox)
10:20:32 <ClaudiusMaximus> sdegutis: ghc-7.10 brings AMP, BBP, integer-gmp rewrite, and other stuff i haven't been paying attention to - see http://downloads.haskell.org/~ghc/7.10.1-rc2/docs/html/users_guide/release-7-10-1.html
10:20:36 <HeladoDeBrownie> neat
10:22:02 <MrPopinjay> As Debian seems to only have old versions, what's the recommended way for getting Haskell? The Generic linux haskell platform binary from their website?
10:22:12 <MrPopinjay> Thank you.
10:22:24 <geekosaur> yes
10:22:45 <geekosaur> you could look for a debian ppa but those are of variying quality and maintained-ness
10:22:59 <ClaudiusMaximus> HeladoDeBrownie: --with-ghc can be abbreviated to -w , eg cabal install -w ghc-7.8.4  - you can install multiple versions of ghc to the same prefix, the binaries are versioned, the last installed gets symlinks (eg: ghc -> ghc-7.8.4 )
10:23:15 <MrPopinjay> Great, thanks. 200MB, this'll be fun on my near dial-up connection. :P
10:25:02 <HeladoDeBrownie> ClaudiusMaximus, that doesn't seem like a way to decide which ghc to compile a project with, but i think geekosaur gave me basically the info i needed. thanks though
10:25:09 <hodapp> MrPopinjay: where are you that you have near dial-up speeds?
10:25:58 <MrPopinjay> London, UK. My room seems to be a faraday cage though, and the landlord won't let me drill holes through the wall :P
10:27:44 <ggVGc> MrPopinjay: open window, connect to your faraday cage in some way, have your own giant antenna!
10:28:06 <MrPopinjay> It's January, I'd freeze to death
10:28:33 <HeladoDeBrownie> which will it be? freeze to death, or have slow internet?
10:28:44 <MrPopinjay> Though it might not make much difference. This room is already much colder than the rest of the house. I've drawn the short straw here
10:28:52 <hiptobecubic> Does anyone know the reasoning behind the type of Pipes.ByteString.drop? You'd expect it to be a Pipe like PB.take, but instead it's a function from Producers to Producers
10:29:04 <niklaus> i'd prefer to freeze :p
10:29:05 <favetelinguis> I guess there are a few Phd students here so i pop the question here, i have just started my masters thesis, it will be about model based testing in erlang, my question is what sort of research method should i use if i want to develop an artifact and then compare an old artifact with the new one (the old one is the method the company does testing atm). Is this design research, case study or case study?
10:29:46 <HeladoDeBrownie> hiptobecubic, probably because it doesn't need to be as powerful as a Pipe (at least, i think Pipe is more powerful than that type). you can still lift it as needed
10:30:19 <hiptobecubic> I just wanted to compose something like (PB.drop 1000 >-> PB.take 5)
10:31:10 <HeladoDeBrownie> gotta go, have fun everyone
10:31:30 <hiptobecubic> maybe because drop doesn't need to know how to terminate the pipe
10:33:24 * hodapp sits outside with tea and warms himself on his laptop that's compiling eleventy billion packages for $whatever_dependency
10:33:26 <hodapp> cozy.
10:36:06 <Welkin> I used to warm up my room in the winter by letting my pentium 4 tower run all night
10:36:11 <Welkin> or my PS3
10:37:06 <Welkin> programming for the Cell processor would be fun -- there is actually an MIT course for doing just that
10:37:16 <Welkin> on opencourseware
10:37:18 <Apocalisp> I remember the Amiga power brick being particularly handy to put your feet on during cold winter coding nights
10:37:29 <yac> looks like `parse (manyTill (many alphaNum) (char '"')) "" "foo"` consumes all the memory
10:38:38 <danl-ndi> i can't install glib-2.0 from cabal on osx 10.9.5
10:41:04 <danl-ndi> or, cabal only knows about glib <= 0.13
10:41:08 <orion> Hi, does anyone know why this code doesn't compile?: http://lpaste.net/2293588097423638528 I get "Could not deduce (Test s0) arising from a use of `blah'"
10:41:17 <danl-ndi> and I have glib-2.42 installed via brew
10:41:34 <danl-ndi> how do I update cabal's notion of glib versions?
10:41:42 <bergmark_> danl-ndi: the cabal package is different from the c library
10:42:11 <danl-ndi> bergmark_: ah. that explains the huge version difference.
10:46:38 <MrPopinjay> Hello again. If I want to add a dep to my cabal file, do I edit it manually or is there a --save-dep or something with cabal install?
10:49:08 <HeladoDeBrownie> yac, you are trying to consume zero or more things zero or more times. you can always consume zero or more things, therefore you will keep consuming them ad infinitum.
10:49:50 <HeladoDeBrownie> yac, did you perhaps mean this? parse (manyTill alphaNum (char '"')) "" "foo"
10:50:57 <Tekmo_> MrPopinjay: I usually edit it manually
10:51:22 <HeladoDeBrownie> hiptobecubic, you might ask your earlier question to Tekmo_ now that he's here
10:53:00 <hiptobecubic> Oh. thanks.
10:53:19 <hiptobecubic> Tekmo_, what's the reasoning behind the type of Pipes.ByteString.drop? You'd expect it to be a Pipe like PB.take, but instead it's a function from Producers to Producers
10:53:27 <hiptobecubic> I wanted to compose something like (PB.drop 1000 >-> PB.take 5)
10:53:32 <Tekmo_> hiptobecubic: Efficiency
10:53:42 <yac> HeladoDeBrownie: yeah, looks like it. Thanks
10:53:44 <Tekmo_> hiptobecubic: I'll explain the issue
10:54:01 <yac> it just loks a little weird when the subparsers are separated
10:54:05 <Tekmo_> hiptobecubic: So what was happening is that people were writing recursive loops to process a `Producer`
10:54:32 <Tekmo_> hiptobecubic: As part of these recursive loops they would repeatedly call `drop` on the `Producer`
10:55:01 <Tekmo_> hiptobecubic: The old version of `drop` behaved the way you expected, it would drop a fixed number of bytes and then behave like `cat` after that point
10:55:09 <Tekmo_> hiptobecubic: However, the issue was that the `cat` was not free
10:55:33 <Tekmo_> hiptobecubic: So if you kept recursively calling `drop` on a `Producer` over and over again it would keep accumulating a new `cat` on each iteration
10:55:53 <Tekmo_> hiptobecubic: So N iterations of this recursion = your `Producer` now has all values being filtered through N `cat`s
10:56:10 <Tekmo_> hiptobecubic: Writing it as a function fixed this problem, improving the efficiency for this particular use case
10:56:26 <yac> HeladoDeBrownie: https://github.com/yaccz/os-release/commit/f47070a113c38e7c5e84550550544c2fa7fc125e
10:57:02 <hiptobecubic> ah
10:57:23 <hiptobecubic> Tekmo_, and it couldn't be solved with rewriting?
10:57:33 <Tekmo_> hiptobecubic: No, I tried that and it doesn't work
10:57:39 <hiptobecubic> cat >-> cat = cat ?
10:57:41 <Tekmo_> There already is a rewrite rule for `p >-> cat = p`
10:57:46 <Tekmo_> However, it doesn't fire
10:58:01 <Tekmo_> Because by that point you are no longer using the `>->` operator
10:58:21 <Tekmo_> After the bytes are done dropping it's internally using mutual recursion between the `(>>~)` and `(->>)` operators
10:58:33 <hiptobecubic> ah
10:58:44 <Tekmo_> More generally, I don't know of a good way to trigger a rewrite rule after a fixed number of recursion steps
10:58:58 <Tekmo_> You can only fire rewrite rules on the original source code, not on the result after a few steps of evaluation
10:59:24 <Tekmo_> This is one of the reasons I got interested in things like Morte, because I felt like a sufficiently smart compiler could have optimized away that `cat`
10:59:33 <hiptobecubic> but you do get multiple rounds of rewrite-firings,  no?
11:00:21 <Tekmo_> hiptobecubic: Yes, but the `cat` only occurs after you evaluate `p >-> drop n` for a few steps
11:00:40 <hiptobecubic> oh, right. OK i see it.
11:00:47 <Tekmo_> hiptobecubic: In order for the rewrite rules to fire on the `cat` you'd have to evaluate that `p >-> drop n` at compile time, either by using additional rewrite rules or other tricks
11:01:26 <hiptobecubic> right
11:01:31 <hiptobecubic> Ok so the usage of drop then
11:01:59 <hiptobecubic> you need to apply it to the producer, you are out of luck if it's part of a big pipe composed of many things?
11:02:31 <Tekmo_> Not necessarily
11:02:43 <Tekmo_> The only thing you can't do with `drop` is precompose it upstream of something
11:02:54 <Tekmo_> In other words, the new `drop` can't do the equivalent of `drop n >-> p`
11:04:01 <hiptobecubic> right. OK so I just happened to pick the one thing it isn't designed to do :)
11:04:13 <Tekmo_> However, there might be a way to generalize its type so that you could do that
11:04:20 <Tekmo_> The type could be generalized to:
11:04:47 <Tekmo_> drop :: Monad m => Int -> Proxy a' a () ByteString m r -> Proxy a' a () ByteString m r
11:05:01 * hackagebot hannahci 0.1.4.1 - Simple Continuous Integration/Deployment System  http://hackage.haskell.org/package/hannahci-0.1.4.1 (Elzair)
11:05:01 <Tekmo_> If you generalized it like that then you could apply it to `cat` to get back the old `drop` behavior
11:05:06 <Tekmo_> In other words:
11:05:10 <Tekmo_> drop n cat >-> p
11:05:20 <hiptobecubic> ah
11:07:33 <orion> Hi, does anyone know why this code doesn't compile?: http://lpaste.net/2293588097423638528 I get "Could not deduce (Test s0) arising from a use of `blah'"
11:08:59 <HeladoDeBrownie> orion, it doesn't know what type your blah on line 14 is
11:10:01 * hackagebot MoeDict 0.0.1 - Utilities working with MoeDict.tw JSON dataset  http://hackage.haskell.org/package/MoeDict-0.0.1 (AudreyTang)
11:10:17 <Lokathor> is there a way to make cabal tell me where it just put the binaries that it installed?
11:10:17 <orion> HeladoDeBrownie: I think it should know based on the fact that I have a class constraint in place.
11:10:44 <orion> Shouldn't it use the instance based on the type of the function?
11:10:46 <HeladoDeBrownie> orion, you have a constraint on the type a, but it doesn't know that you want that blah to use that type.
11:10:55 <HeladoDeBrownie> orion, notice how x goes unused in the definition
11:11:05 <danl-ndi> ok, now i need to install cairo version >=1.2 but it could not be found. is there a brew installation that'll work?
11:11:09 <orion> Ah, how do I specify such a thing?
11:11:32 <HeladoDeBrownie> orion, one way would be to enable ScopedTypeVariables, write forall a. in the type signature, and write (blah :: Tagged a Int)
11:12:05 <HeladoDeBrownie> orion, you also don't need an a per se, all you need is a Proxy a, but that might not be a vital change
11:12:05 <orion> Is that a bad practice?
11:12:17 <orion> ScopedTypeVariables that is
11:12:17 <ClaudiusMaximus> orion: (blah `asTypeOf` x) is another way
11:12:21 <HeladoDeBrownie> i wouldn't say so, or i wouldn't have suggested it
11:12:29 <HeladoDeBrownie> ClaudiusMaximus, that doesn't type
11:12:41 <ClaudiusMaximus> oh oops
11:12:53 <ClaudiusMaximus> i see
11:13:28 <HeladoDeBrownie> orion, it does mean you'll be tied in to ghc, but most people have little problem with that, as it's the de facto standard anyway
11:16:10 <ClaudiusMaximus> orion: most of the time you can avoid ScopedTypeVariables if you really need to by defining things like   f x = h (g blah x) where  g :: Tagged b Int -> b -> Tagged b Int ; g = const  -- g just used for type inference   but ScopedTypeVariables is sometimes more convenient
11:18:32 <rasen> ncurses vs. vty? which is better?
11:20:01 * hackagebot hannahci 0.1.4.2 - Simple Continuous Integration/Deployment System  http://hackage.haskell.org/package/hannahci-0.1.4.2 (Elzair)
11:22:11 <Lokathor> rasen, consider ansi-terminal, it'll work on windows as well
11:23:24 <MrMetric> I'm very new to Haskell and I don't know how to fix a compile error. Is this the right place to ask for help?
11:23:31 <HeladoDeBrownie> MrMetric, sure
11:23:39 <Lokathor> this is the exact place
11:23:56 <MrMetric> Okay. I'll paste it
11:23:57 <HeladoDeBrownie> MrMetric, include relevant code and the error message in an lpaste (see the topic)
11:24:50 <lpaste> MrMetric pasted “func.hs” at http://lpaste.net/119755
11:25:01 <MrMetric> Neat
11:25:13 <rasen> Lokathor: both vty and ncurses don't support windows?
11:25:43 <HeladoDeBrownie> MrMetric, okay, so you defined your own (-), but the Prelude also contains one. if you don't plan on using the Prelude one, add: import Prelude hiding ((-))
11:25:44 <rasen> MrMetric: make func (-1) = 1
11:25:52 <HeladoDeBrownie> oh, haha
11:25:56 <MrMetric> Oh, I need brackets?
11:25:56 <HeladoDeBrownie> ignore me, rasen got it
11:25:56 <Lokathor> rasen, it's technically possible perhaps to get them setup on windows via pdcurses, but it's a real pain to get the paths right for the compile
11:25:59 <HeladoDeBrownie> i skimmed too much
11:26:00 <orion> HeladoDeBrownie / ClaudiusMaximus: Thank you for your help.
11:26:07 <MrMetric> For negative numbers?
11:26:10 <Lokathor> rasen, whereas, ansi-terminal simply compiles through cabal with no fuss
11:26:18 <HeladoDeBrownie> MrMetric, yeah, very often you must surround negative literals in parens
11:26:40 <rasen> MrMetric: for anything that is not single lexem
11:26:41 <HeladoDeBrownie> not always, just when it would be syntactically ambiguous, like here
11:26:57 <MrMetric> I did that, but it's giving the same error
11:27:14 <rasen> MrMetric: show the updated code
11:27:56 <MrMetric> Wait, I think it's my fault. I renamed the file and forgot to reopen it in Sublime Text
11:28:16 <MrMetric> It works now. Thanks
11:29:39 <MrMetric> Why does it not work without parens around -1?
11:29:53 <dmwit> Because - is an operator.
11:30:02 * hackagebot file-command-qq 0.1.0.5 - Quasiquoter for system commands involving filepaths  http://hackage.haskell.org/package/file-command-qq-0.1.0.5 (JonathanFischoff)
11:30:08 <dmwit> > let a - b = a * b in 3 - 4
11:30:10 <lambdabot>  12
11:30:25 <dmwit> > let f - 1 = f * 3 in 3 - 1
11:30:27 <lambdabot>  9
11:31:09 <MrMetric> That doesn't tell me why :[
11:31:15 <therealfakemoot> wacky
11:31:17 <therealfakemoot> haskell is fun
11:31:20 <dmwit> MrMetric: It doesn't?
11:31:50 <MrMetric> No. I don't see why that matters
11:31:56 <dmwit> MrMetric: "func -1 = blah" is interpreted as trying to define a function named (-), which takes two arguments, with pattern "func" matching the first and pattern "1" matching the second.
11:31:59 <rasen> MrMetric: let func - 1 = 1 in 3 - 1
11:32:07 <rasen> > let func - 1 = 1 in 3 - 1
11:32:09 <lambdabot>  1
11:32:26 <hyPiRion> > let x :+: y = x * y in 10 :+: 3
11:32:28 <lambdabot>  Not in scope: data constructor ‘:+:’
11:32:28 <lambdabot>  Perhaps you meant ‘:+’ (imported from Data.Complex)Not in scope: data constr...
11:32:28 <lambdabot>  Perhaps you meant ‘:+’ (imported from Data.Complex)
11:32:43 <rasen> hyPiRion: : is for constructors
11:32:49 <dmwit> hyPiRion: ":" is an "upper-case" symbol =)
11:32:54 <hyPiRion> rasen: yeah, whoops
11:33:10 <MrMetric> Is that related to why I need to do print (func 9) instead of print func 9?
11:33:11 <hyPiRion> Point being, replace - with any other infix function
11:33:22 <dmwit> MrMetric: Not very related, no.
11:33:26 <Lokathor> MrMetric, yes
11:33:46 <MrMetric> Okay then
11:33:47 <dmwit> They're related in that they're both about the syntax of Haskell, I guess. But they're completely different corners of the syntax.
11:33:56 <rasen> dmwit: it's same
11:34:11 <dmwit> No it's not? Infix function application and prefix function application aren't the same.
11:34:17 <Welkin> expressions are evaluated left to right
11:34:22 <Lokathor> MrMetric, oh i read your question wrong.. you need to do print (func 9) because otherwise it tries to apply print to "func" directly instead of the output of (func 9)
11:34:26 <rasen> dmwit: it's simply in this case not doing so triggers another feature
11:34:30 <dmwit> Welkin: wat
11:34:38 <Welkin> print f 9 would evaluate as (print f) 9
11:35:09 <Welkin> since print only expects one argument
11:35:16 <dmwit> Welkin: That's not what "evaluates from left to right" mean. But yes, function application is left-associative.
11:35:18 <MrMetric> So does func -1 evaluate as (func -) 1?
11:35:31 <dmwit> Welkin: Also it has nothing to do with how many arguments print expects.
11:35:37 <dmwit> Lots of imprecision around here today.
11:35:41 <hyPiRion> MrMetric: No, which is the confusing part. - is infix
11:35:43 <Welkin> how so?
11:35:47 <dmwit> MrMetric: No, it parses as (-) func 1
11:35:53 <kish`> where do i start
11:36:04 <MrMetric> Oh, I think I see
11:36:16 <dmwit> Welkin: isPrefixOf func 9 also parses as (isPrefixOf func) 9, even though it doesn't expect only one argument.
11:36:52 <Welkin> dmwit: of course, but I am ignoring partial application for my explanation
11:36:54 <dmwit> kish`: here:
11:36:56 <dmwit> ?where tutorials
11:36:56 <lambdabot> http://haskell.org/haskellwiki/Tutorials
11:37:04 <Welkin> once it is fully applied it takes 2 arguments
11:37:07 <kish`> yeah, thanks.
11:37:24 <kish`> btw: Your connection is not private
11:37:26 <kish`> Attackers might be trying to steal your information from wiki.haskell.org (for example, passwords, messages, or credit cards).
11:37:47 <dmwit> kish`: I recommend not putting your passwords, messages, or credit cards into any fields on wiki.haskell.org then.
11:37:50 <kish`> i got past it but others pay not
11:38:09 <dmwit> Why would you need a private connection to the wiki?
11:38:30 <kish`> oh, sorryl... i had that ssl everywhere installed
11:38:34 <kish`> i forgot about tht
11:39:13 <glguy> dmwit: Maybe someone doesn't want their employer to know what exactly it was they didn't know about Haskell
11:39:21 <kish`> heh
11:39:24 <HeladoDeBrownie> it's true people should know about it in general, but it seems mostly harmless in this case
11:39:45 <HeladoDeBrownie> (i.e., the difference between http and https and in general unencrypted versus encrypted connections)
11:39:49 <dmwit> hehehe
11:40:24 <dmwit> With some employers, even having SSL is not enough.
11:40:36 <dmwit> (They intentionally install certificates on your machines that let them MITM you.)
11:40:41 <MrMetric> Does Haskell have for loops?
11:40:45 <dmwit> :t for
11:40:46 <lambdabot>     Not in scope: ‘for’
11:40:46 <lambdabot>     Perhaps you meant one of these:
11:40:46 <lambdabot>       ‘T.for’ (imported from Data.Traversable),
11:40:48 <dmwit> :t T.for
11:40:50 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
11:40:52 <dmwit> yes!
11:40:52 <HeladoDeBrownie> MrMetric, not per se, but it has equivalents
11:40:54 <glguy> dmwit: I took delivery of my laptop from the UPS lady ^_^
11:41:09 <dmwit> =)
11:41:14 <HeladoDeBrownie> MrMetric, it's been said that lists in haskell are like loops as values
11:41:41 <HeladoDeBrownie> folding, mapping, filtering lists can be handy (although it's not the end-all of iteration)
11:42:07 <tomphreek>  how to get all haskell docks from haddock in local directory? do I just download the htmls or generate them?
11:42:11 <dmwit> Okay, I admit it: I answered the question as asked instead of the question as intended. Somebody should dmwit--
11:42:20 <Welkin> a fold is like a for-loop
11:42:34 <dmwit> tomphreek: cabal install --enable-documentation
11:42:41 <dmwit> tomphreek: Or put enable-documentation: True in your config.
11:43:18 <dmwit> tomphreek: Sorry, it's documentation: True, not enable-documentation.
11:43:24 <MrMetric> I want to print func 0 to func 7
11:43:28 <dmwit> Dunno about the command-line parameter, it might be --documentation as well.
11:43:30 <HeladoDeBrownie> MrMetric, as you go on learning haskell you'll get an intuition for what iteration tools to use in what situation. for now, did you have a specific appli—
11:43:36 <HeladoDeBrownie> MrMetric, okay, try mapM_
11:43:38 <HeladoDeBrownie> @type mapM_
11:43:39 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
11:43:53 <dmwit> MrMetric: mapM_ (print . func) [0..7], or perhaps print (map func [0..7])
11:44:02 <codygman> HeladoDeBrownie: I think I get your point, but the combination of folds, maps, and filters are pretty general, can you expand on how they are not they "end-all of iteration"? I ask because I personally can't think of iteration that isn't easily replicated with them.
11:44:03 <HeladoDeBrownie> dmwit beat me to it :P
11:44:37 <HeladoDeBrownie> codygman, that's not *exactly* what i said; i more wanted to leave room for dealing with things besides lists, like effectful streams.
11:44:46 <Welkin> recursion can replace all iteration
11:44:54 <MrMetric> The first does what I want. The second gives me a list of the values instead
11:45:02 * hackagebot singletons 1.1 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-1.1 (RichardEisenberg)
11:45:16 <MrMetric> Now I gotta Google™ for what it's doing
11:45:22 <dmwit> codygman: Well, there's scans, iterates, and forever. I bet I could come up with a couple other patterns with time, and many one-off things that don't really fall into any recognizable pattern.
11:45:29 <Welkin> mapM_ = sequence . map
11:45:42 <HeladoDeBrownie> MrMetric, you will probably get more helpfully directed information by asking here first. for example, do you know what a typeclass is?
11:45:52 <Welkin> er
11:45:53 <codygman> HeladoDeBrownie: Alright, just wanted to make sure I wasn't missing out on anything ;)
11:45:56 <Welkin> mapM_ = sequence_ . map
11:45:59 <codygman> dmwit: Thanks for the examples
11:46:00 <MrMetric> Isn't that stuff like Eq and Num?
11:46:03 <HeladoDeBrownie> MrMetric, yeah
11:46:16 <MrMetric> I think I get that idea
11:46:18 <dmwit> codygman: Duff's device would be tough to fit into a fold, too (operationally if not semantically). =)
11:46:34 <tomphreek> dmwit: cheers! where will the html go, I am not running cabal as root...
11:46:43 <dmwit> tomphreek: .cabal/share/doc
11:46:46 <dmwit> tomphreek: by default
11:47:01 <tomphreek> dmwit: awesome, thanks
11:47:05 <dmwit> tomphreek: You can configure where it goes by changing the install-dirs/haddockdir setting in your config.
11:47:18 <HeladoDeBrownie> MrMetric, although as it happens in this case you can essentially substitute m ~ IO. mapM_ :: (a -> IO b) -> [a] -> IO ()
11:47:28 <MrMetric> HeladoDeBrownie: typeclasses remind me of interfaces
11:47:39 <dmwit> MrMetric: That's a pretty good intuition for them.
11:47:42 <HeladoDeBrownie> MrMetric, they sort of give way to similar intuitions, but vary in power
11:47:45 <dmwit> Not perfect, but it will get you a long way.
11:47:49 <HeladoDeBrownie> what dmwit said
11:48:11 <MrMetric> I'm not sure if interfaces or multiple inheritance provides a better understanding
11:48:18 <HeladoDeBrownie> ultimately a typeclass is no better than a datatype whose values are provided automatically by the compiler
11:50:03 * hackagebot haskell-docs 4.2.3 - A program to find and display the docs and type of a name  http://hackage.haskell.org/package/haskell-docs-4.2.3 (ChrisDone)
11:51:47 <MrMetric> Is it okay if I ask short questions here, or is it preferred to Google™ them first?
11:52:24 <tomphreek> has anyone got haskellmode-vim? I am feeling like a moron here, but I can't quite get what _? means from the doc: _? Open the Haddock entry (in |haddock_browser|). What mode is _?, normal one doesn't work
11:53:13 <dmwit> Short questions are fine. Easily-googlable ones are frowned on but generally answered. Easily-hooglable ones are hoogled in-channel.
11:53:26 <ggVGc> I love my hooglers
11:53:27 <HeladoDeBrownie> MrMetric, you can ask here
11:53:40 <HeladoDeBrownie> dmwit, XD
11:54:01 <dmwit> ggVGc: scary nick
11:54:04 <rasen> ggVGc: I like your nick
11:54:26 * dmwit <ESC>u
11:54:26 <rasen> meaningful one
11:54:37 <MrMetric> I am attempting to understand mapM_ (print . func) [0..7]. Is this doing something like print(func(x)) for each x in [0..7]?
11:54:44 <ggVGc> :)
11:54:45 <dmwit> MrMetric: exactly that, yes
11:54:48 <HeladoDeBrownie> oh, that nick is "copy entire file"
11:54:53 <HeladoDeBrownie> no wait
11:54:56 <dmwit> HeladoDeBrownie: change entire file
11:54:58 <ggVGc> ,ctell dmwit ggVGd
11:54:59 <HeladoDeBrownie> yeah, that
11:55:02 <rasen> HeladoDeBrownie: change
11:55:13 <ggVGc> erg, forgot I wasn't in #vim
11:55:21 <MrMetric> So (print . func) is like the (f o g) = f(g()) thing I learned in high school?
11:55:25 <ggVGc> dmwit, rasen, http://tinyurl.com/NickAnswer
11:55:28 <HeladoDeBrownie> MrMetric, yep!
11:55:30 <dmwit> MrMetric: exactly like, yes
11:55:31 <dmwit> ?src (.)
11:55:32 <lambdabot> (f . g) x = f (g x)
11:56:29 <MrMetric> I remember reading someone describe Haskell as programming things as you'd describe them to a mathematician (as opposed to usual programming, which is describing the problem to an idiot)
11:56:47 <HeladoDeBrownie> MrMetric, funny, although haskell is actually pretty far from math ;)
11:57:01 <HeladoDeBrownie> it's closer to math than most languages though, i'd guess
11:57:05 <ggVGc> hey, my computer is no idiot. It's just fairly autistic
11:57:12 <dmwit> ggVGc: very silly =)
11:57:23 <MrMetric> Well, I appreciate that ^ is power instead of xor :]
11:58:21 <MrMetric> Okay, so with mapM_, you pass a function and a list of stuff to call the function with?
11:58:29 <dmwit> :t mapM_
11:58:30 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
11:58:34 <HeladoDeBrownie> MrMetric, basically, although that describes other things too
11:58:39 <dmwit> Sounds like it to me.
11:58:40 <MrMetric> I can't read that very well, sorry
11:58:48 <dmwit> (a -> m b) -- pass me a function
11:58:54 <dmwit> [a] -- pass me a list of stuff to call it with
11:59:14 <HeladoDeBrownie> reading types is important to learn, you will have problems if you don't know the types
11:59:31 <MrMetric> I haven't learned what Monad means yet
11:59:39 <HeladoDeBrownie> Monad is a particular typeclass
11:59:45 <HeladoDeBrownie> it provides (>>=) and return, among other things
11:59:51 <HeladoDeBrownie> @type (>>=)
11:59:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:59:53 <HeladoDeBrownie> @type return
11:59:54 <lambdabot> Monad m => a -> m a
12:00:11 <dmwit> ?google you could have invented monads
12:00:13 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
12:00:13 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
12:00:18 <dmwit> I wonder if there's a "monad tutorials" wiki page yet.
12:00:31 <dmwit> ?google monads for people who just don't care
12:00:33 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
12:00:33 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
12:00:47 <MrMetric> So (print . func) works as a single function that calls func and print, like when I pass a function as an argument in Javascript?
12:01:14 <MrMetric> I'd do function(x){print(func(x))} as an argument
12:01:14 <HeladoDeBrownie> haskell functions are quite different javascript functions, which are more like procedures. haskell functions are closer to math functions
12:01:19 <HeladoDeBrownie> but basically, yeah
12:01:28 <HeladoDeBrownie> +from
12:01:31 <EvanR> mkay, i noticed CLong is a newtype for Int64. and i noticed in the doc for FunPtr CLong isnt listed in the "foreign marshable types" do i have unwrap stuff like CLong and CInt to use them with FunPtr
12:01:41 <MrMetric> Thanks for the help
12:02:14 <HeladoDeBrownie> as such we usually don't say to "call" a function, we say to "apply a function"
12:02:38 <MrMetric> Is that because it's lazy and is not running things immediately?
12:02:56 <HeladoDeBrownie> it's more to do with purity, i think
12:03:11 <dmwit> write more code, ask fewer questions
12:03:14 <HeladoDeBrownie> applying a function has no observable effects outside of the value it returns
12:03:25 <HeladoDeBrownie> yeah, maybe i shouldn't have brought up that tangent
12:03:35 <MrMetric> I'd consider functions to be mappings, then
12:04:01 * dmwit nods agreeably
12:04:05 <EvanR> MrMetric: with a very special domain and codomain...
12:04:09 <MrMetric> dmwit: I know what I want to make, I just don't know how yet
12:04:10 * EvanR throws a _|_ out
12:04:33 <HeladoDeBrownie> EvanR is invoking the words of madness
12:04:50 <dmwit> Yeah, really. "throw"? Come on!
12:04:55 <EvanR> indeed
12:06:05 <izohask> if I have data Calculation a = whatever...
12:06:25 <izohask> and then instance Functor Calculation where fmap ... whatever
12:06:42 <izohask> can I force somehow that "a" in "Calculation a" MUST be Functor  ?
12:06:47 <Rotaerk> I find it odd when people explain monads before IO
12:06:54 <dmwit> izohask: Your question is ill-kinded.
12:07:06 <izohask> *->*
12:07:07 <HeladoDeBrownie> izohask, no, a isn't even mentioned in the head of the instance
12:07:14 <dmwit> izohask: If Calculation is an instance of Functor, then (a :: *), and cannot be an instance of Functor.
12:07:15 <izohask> * -> * -> *
12:07:22 <izohask> hm right
12:07:36 <EvanR> Rotaerk: well its two separate ideas
12:07:59 <EvanR> nevermind found the magic clause "or any renaming of these using newtype
12:08:01 <EvanR> "
12:08:10 <HeladoDeBrownie> Rotaerk, i only explained because MrMetric was going to go look it up, and i thought it'd be less confusing to explain in a more controlled manner :)
12:08:36 * HeladoDeBrownie grumbles about contentless monad tutorials everywhere
12:08:55 <HeladoDeBrownie> (some have good content, many not so much)
12:09:19 <trap_exit> does latest purescript break Data.Array ? due to Data.Foldable and Data.Eq ?
12:09:29 <Rotaerk> EvanR, yea, but IO should be taught as soon as possible
12:09:35 <Rotaerk> so people can start writing *programs*
12:09:47 <Rotaerk> but it seems like people treat it as dependent on the concept of monads
12:09:51 <Rotaerk> so it must come later
12:10:08 <Rotaerk> when really, it could serve as a concrete example that can be generalized to monads
12:10:12 <dyl>  IO is not well behaved or easily explained as a mona.
12:10:14 <HeladoDeBrownie> Rotaerk, i guess that has to do with how we usually use Monad operators to compose IO. i do agree thoough
12:10:16 <dyl> It's a bad concrete example imo.
12:10:33 <MrMetric> I'll treat it as magic right now
12:10:44 <dmwit> dyl: explain
12:10:55 <dyl> Because the IO manager is rather opaque.
12:10:58 <HeladoDeBrownie> welp, gotta go grocery shopping. have fun everyone
12:11:03 <dyl> Trying to give any example of how it works is misleading.
12:11:16 <dyl> Best to just say "The IO manager ensures IO occur in order, and according to these laws"
12:11:22 <dyl> "these laws define what's called a monad"
12:11:26 <dyl> "let's look at some other ones"
12:11:52 <dmwit> dyl: Okay, your complaint then is that IO has both evaluation and execution, unlike most other monads we use in Haskell.
12:12:00 <dmwit> (which only have to deal with evaluation)
12:12:02 <dyl> More or less.
12:12:16 <dmwit> Right, I agree that's a complicated subtlty.
12:12:17 <dyl> It's much easier to explain things with only evaluation.
12:12:21 <dmwit> (subtlety?)
12:12:34 <dyl> You end up saying something like "well you can think of IO as evaluating to a sequence of actions..."
12:12:36 <dyl> except it's not a sequence
12:12:37 <EvanR> Rotaerk: well, you can "write programs" in ghci without needing IO ;)
12:12:40 <dyl> and what are actions anyways?
12:12:48 <EvanR> and some people might find that more interesting
12:12:50 <dyl> it's just a rabbit hole you don't need to go down early I think.
12:12:58 <dyl> If you're interested go for it.
12:13:23 <Rotaerk> EvanR, I wouldn't consider it a program without IO
12:13:32 <dyl> But if I were teaching in a university course, I'd probably suggest taking IO at face value as a monad, exploring them more fully and then posing the question "how would _you_ handle IO monadically?" by building some sort of eval loop for a subset of IO actions.
12:13:33 <EvanR> why not?
12:13:54 <dyl> e.g. "ok let's say we have data Action = Print String | ReadLine | ...
12:13:57 <dyl> etc
12:14:09 <Rotaerk> EvanR, because it doesn't do anything that's visible to the user
12:14:09 <Tekmo_> If you ever need an example of how to encode IO as a free monad, you can always reference this post: http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html
12:14:18 <Rotaerk> heck, it doesn't even RUN
12:14:27 <Tekmo_> It doesn't use the word free monad, nor does it go through the free construction, but it gets the idea across
12:14:30 <Rotaerk> unless you load it up in, say, GHCi and call the functions yourself
12:14:39 <Rotaerk> without a "main", it's just a library
12:14:45 <EvanR> Rotaerk: well if you take a typical haskell program, and remove the thin IO layer that "does something" you can run all the pure code you want through ghci, and... well it does something then too
12:14:47 <dyl> Tekmo_ the last code sample i a good example yeah
12:14:51 <dyl> Go Gabriel :)
12:14:54 <Tekmo_> :)
12:15:04 <dyl> Tekmo_ oh hey it's you!
12:15:06 <dyl> How're pipes :)?
12:15:17 <dyl> You solved the bidirectional problem?
12:15:36 <Tekmo_> Pipes have been bidirectional for a long time
12:15:38 <hiptobecubic> Tekmo_, so pipes have a return value, but also a 'pass downstream' type. Is there a way to gather everything up at the end?
12:15:55 <hiptobecubic> mostly so i can figure out what's going on without dumping it to an IO handle :D
12:16:24 <Tekmo_> You mean to show the flow of information?
12:16:55 <hiptobecubic> for example, I want to stream some binary data down over http. That part is easy. But in ghci it's not very useful because even if you specify a finite amount of data (ex. with PB.take) you can never get your hands on it
12:16:58 <EvanR> Rotaerk: the idea is to minimize the importance of "IO" (which isnt too clear what can/should be IO and would isnt shouldnt) from as much of the software development process as possible
12:17:29 <EvanR> Rotaerk: in haskell many things are in IO that doesnt even I/O just for lack of a better way to do it
12:17:52 <Tekmo_> Generally, factoring out IO falls into three common categories
12:17:54 <hiptobecubic> I think "IO" is a misleading name to people outside of haskell
12:18:09 <dmwit> Rotaerk: Haskell IO actions don't do anything visible to the user, either. Unless you, you know, load it up in, say, GHC, and have it execute the IO for you.
12:18:19 <Tekmo_> Category 1: Write a bunch of pure functions and then IO wrappers to external things
12:18:29 <Tekmo_> Category 1 solves like 80% of use cases
12:18:51 <Tekmo_> Where it commonly fails is streaming things.  Factoring out pure streaming logic typically involves a free monad or pipes-like abstraction
12:18:55 <Tekmo_> So that's category 2:
12:18:55 <rasen> Is there function for putStr . show?
12:19:06 <dmwit> print
12:19:09 <Tekmo_> Category 2: Write a pure pipe and then have it read from or write to IO sink/sources
12:19:09 <dmwit> Oh. No.
12:19:26 <Tekmo_> Category 1 + 2 usually solve 95% of all use cases
12:19:37 <Tekmo_> THe last 5% are usually concurrency related
12:19:38 <rasen> print = putStrLn . show
12:19:38 <dyl> @let extraUnsafePerformIO (unsafePerformIO >> unsafePerformIO)
12:19:38 <lambdabot>  Parse failed: TemplateHaskell is not enabled
12:19:38 <dmwit> "No." meaning "No, there's no common name for putStr . show".
12:19:43 <dyl> = *
12:19:50 <Tekmo_> That's basically what mvc is for: factoring out concurrency logic from your pure logic
12:20:00 <rasen> dmwit: ok. sad
12:20:03 <Tekmo_> Category 3: Use mvc to separate out your pure logic from your ocncurrency
12:20:09 <trap_exit> damn it, tryikng to swith to elm/purescript .... but #haskell is so much more active
12:20:13 <dyl> There should be a package with a version of unsafePerformIO that is as guaranteed as possible to explode when used wrong.
12:20:15 <Lokathor> is there an IRC channel for the emacs haskell-mode? it doesn't seem to be at #hasekll-mode if so
12:20:38 <EvanR> Rotaerk: does a haskell program that uses IO for spawning a bunch of threads that do something but read and write a bunch of IORefs count as a program ;)
12:20:46 <EvanR> that do nothing*
12:21:20 <dyl> EvanR sure it's just reducible to the null problem main = return ()
12:21:21 <EvanR> the user cant see anything
12:21:26 <dyl> In terms of functionality.
12:21:30 <dyl> But it does have a lot of other side effects.
12:22:05 <dyl> Who knows, you might use such a program if you're stress testing some web server to see if another process suddenly hogging a shitton of threads causes problems :p.
12:22:24 <dyl> Every side effect has some conceivable use case, whether it's intelligent or not.
12:22:28 <EvanR> yeah well the act of writing the source code messes with the entropy of the universe
12:22:30 <Rotaerk> EvanR, semantics aside, I just think most people would find a program that has no output ... boring :P
12:22:43 <Rotaerk> and would want to at least learn how to write to the console
12:22:55 <EvanR> Rotaerk: right, and a functional program always has output ;)
12:22:57 <dyl> If the universe is an executing program,
12:22:59 <dyl> does it have output?
12:23:13 <dyl> > black holes = pipes to /dev/stdout
12:23:15 <lambdabot>  <hint>:1:13: parse error on input ‘=’
12:23:19 <dyl> lul
12:23:34 <EvanR> spooky
12:23:37 <dyl> If the universe were a program, it'd be conceivable that singularities might be input/output.
12:23:41 <Rotaerk> maybe we have souls and the qualitative experience we have IS the output of the universe program
12:23:51 <dyl> Maybe the universe is a quine.
12:24:07 <dyl> The big bang was just planned maintenance.
12:24:14 <Tekmo_> lol
12:24:24 <dyl> That ended up breaking the product, losing the company billions...
12:24:31 <EvanR> you could imagine in my no-output concurrent program example that one of the IORefs "experiences" its value, and the effect of modifying it as the program runs matters
12:24:44 <dyl> After ~10 billion years they got back to good uptime.
12:25:12 <Rotaerk> wonder if the universe ever crashes and we just aren't aware of it
12:25:17 <Tekmo_> EvanR: You'd probably like this post: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
12:25:22 <dyl> Why would we be. You'd have to assume they keep good backups.
12:26:12 <dyl> So best use of an Oculus Rift I've yet heard of:
12:26:22 <dyl> simulating an immersive 3d room filled with teletypes.
12:26:28 <dyl> We've come full circle.
12:26:51 <dyl> 3d xmonad would be rather confounding.
12:27:02 <lpaste> ddp pasted “os x - brand new install - 2014.2” at http://lpaste.net/119757
12:27:02 <dyl> "rotate my desk in 4-space to the other side of the room"
12:27:24 <adimit> is it me, or does it seem like the current HaRe is uninstallable with a fresh hackage?
12:27:24 <dyl> if I were capable of moving through a fourth spatial dimension I'd start a business as a packaging/moving company.
12:28:17 <alanz> adimit: HaRe requires GHC <= 7.6.3
12:28:24 <adimit> alanz: oooooh.
12:28:44 <adimit> alanz: I see you have HaRe highlight :-P Yes, I think there wer some changes in the GHC API, right?
12:28:51 <alanz> adimit: and in future will require GHC >= 7.10
12:29:06 <alanz> yes
12:29:15 <adimit> alanz: that's cool :-) I'll upgrade to 7.10 as soon as it hits anyway.
12:29:16 <dmwit> 7.8 is RIGHT OUT
12:29:22 <adimit> indeed!
12:29:37 <alanz> 7.10 has major changes to support HaRe, 7.8 will never be supported (by me)
12:29:50 <adimit> alanz: that's fine. Thanks for all the work you put in :-)
12:30:26 <adimit> I just saw a demo and thought it'd be cool to have (too much Java programming in Intellij made wish for cooler tools in Emacs for Haskell, to.)
12:30:38 <MrMetric> ghc --version says I'm using 7.6.3
12:31:34 <adimit> alas, I can't switch down to 7.6 for my project, I think. So it'll have to wait.
12:33:56 <EvanR> Tekmo_: cool
12:41:36 <jim`> is there some documentation for then openal bindings floating around? Following the types isn't super clear for that library.
12:48:50 <lpaste> ddp pasted “os x - brand new install - 2014.2” at http://lpaste.net/119758
12:48:51 <sdegutis> mniip: hi
12:48:55 <sdegutis> re: <mniip> oh hi sdegutis o/ oh wait they left
12:49:20 <ddp> newbie here - stupid cabal-install question?
12:49:52 <ddp> os x, brand new install - http://lpaste.net/119758
12:50:23 <ddp> why does it keep telling me that there’s a new version of cabal-install?
12:50:40 <sdegutis> ddp: are you using http://ghcformacosx.github.io/ ?
12:50:41 <Tekmo_> jim`: According to this page (https://wiki.haskell.org/OpenAL#Tutorials) you may have to just translate a tutorial in another language to Haskell
12:50:43 <sdegutis> that's what I use
12:50:56 <AHMED_FAROOQ> hey baby baby my name is AHMED baby baby im from dubai baby so give me some lovin baby and flirt with me, give me ur kik and snapchat babys
12:51:09 <Tekmo_> How do we ping the moderators?
12:51:16 <quchen> ?where ops
12:51:16 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
12:51:22 <glguy> ddp: The place that cabal installed the executable probably isn't in your PATH or if it is it's in your PATH afterward
12:51:35 --- mode: ChanServ set +o glguy
12:51:40 <AHMED_FAROOQ> hey baby baby my name is AHMED baby baby im from dubai baby so give me some lovin baby and flirt with me, give me ur kik and snapchat babys
12:51:43 --- mode: glguy set +b *!*@80.77.174.114
12:51:47 --- kick: AHMED_FAROOQ was kicked by glguy (Your behavior is not conducive to the desired environment.)
12:51:47 --- mode: ChanServ set +o geekosaur
12:51:51 --- mode: geekosaur set -o geekosaur
12:52:00 <Tekmo_> Thanks
12:52:21 <zipper> glguy: lol has he/she said anything else?
12:53:15 <jim`> Tekmo_: thanks, I'll look around
12:53:17 <sdegutis> glguy: nice msg
12:53:30 <adimit> zipper: it's a spambot.
12:53:38 <sdegutis> On Mac, is ghcformacosx or homebrew the preferred way of getting GHC/cabal?
12:53:53 <Tekmo_> sdegutis: Yeah, that or the Haskell Platform
12:53:55 <Tekmo_> sdegutis: Both are good
12:54:03 <sdegutis> thanks, you
12:54:08 <Haskellfant> I'm trying to define a list that can contain trees of arbitrary shape, but, I get an error that I can't use it because it is fenide and used in the same recursive group: data TreeList a = NilT | forall s . ConsT (Tree s a) (TreeList a)
12:54:14 <sdegutis> So has anyone written a window manager for OS X in Haskell yet?
12:54:16 <glguy> Any chat or questions about spam/moderation are welcome in #haskell-ops
12:54:16 <Haskellfant> I'm not quite sure why this is the case
12:54:19 <fizbin> sdegutis: I've always used Haskell Platform on mac.
12:54:21 <Tekmo_> sdegutis: XMonad
12:54:22 <adimit> sdegutis: XMonad.
12:54:28 <geekosaur> current HP for mac is broken
12:54:36 <fizbin> Oh, really?
12:54:36 <sdegutis> this?  https://github.com/xmonad/osxmonad
12:54:38 <geekosaur> it has invalid embedded paths
12:54:41 --- mode: glguy set -o glguy
12:54:58 <MrMetric> Hey, isn't ddp's problem the thing where it installs in a user folder instead of a system folder?
12:54:59 <adimit> sdegutis: OS X doesn't allow for anybody to just take over window management. XMonad can only manage X11 windows in OS X.
12:55:11 <Tekmo_> sdegutis: This page might interest you: https://wiki.haskell.org/Xmonad/Using_xmonad_on_Apple_OSX
12:55:14 <adimit> It does so flawlessly, but doesn't integrate at all with Native Cocoa apps.
12:55:15 <sdegutis> adimit: ooooh -- yeah, I meant normal OS X windowd
12:55:29 <sdegutis> I've written about 4 window managers for native windows in OS X by now.
12:55:30 <dmwit> Haskellfant: "fenide"?
12:55:33 <adimit> sdegutis: that's pretty much impossible. Welcome to Apple's walled garden.
12:55:40 <sdegutis> The latest one was in Swift, but I've since become very disappointed in Swift.
12:55:40 <ddp> i installed the 2014.2.0.0 platform from here; cabal built into my directory and ~/Library/Haskell/bin is in the front of my PATH
12:55:42 <adimit> but in Haskell? how?
12:55:55 <geekosaur> the osxmonad fork is little more than a proof of concept --- but then it's not really possible to do much better than it does, because most of the "window management" in OS X is embedded in Core Graphics
12:55:56 <Haskellfant> dmwit: wtf, that should have mean „defined“
12:55:58 <Tekmo_> sdegutis: By the way, if you have issues with Swift, let Maxwell Swadling know
12:56:13 <Tekmo_> sdegutis: He's one of the people working on it and he's also an avid Haskell programmer
12:56:17 <sdegutis> adimit: you just need to use a few C functions
12:56:32 <adimit> sdegutis: admittedly, I ditched OS X around the end of Tiger.
12:56:32 <Haskellfant> that should have mean? wtf is wrong with me
12:56:34 <sdegutis> Tekmo_: I'm a nobody, so nobody listens to my opinions :)
12:56:36 <adimit> So things have changed.
12:56:49 <dmwit> Haskellfant: After adding "data Tree s a", WFM
12:56:51 <sdegutis> adimit: no, it's always been this way -- you can do it, but it's a bit hacky compared to X
12:56:52 <Tekmo_> He's: https://twitter.com/maxpow4h
12:57:02 <Haskellfant> dmwit: well I want the existential there
12:57:02 <sdegutis> adimit: that said, X is quite a bit hacky too
12:57:04 <geekosaur> (suppose it depends on what you're willing to accept as "window management". you can move stuff around, you do not get the control X11 offers)
12:57:17 <Haskellfant> dmwit: the list needs to be able to contain trees of different shapes
12:57:19 <dmwit> Haskellfant: Your code WFM exactly as written.
12:57:22 <sdegutis> geekosaur: you can move stuff around *and* you can do it in response to events (window opened, app launched, etc)
12:57:37 <sdegutis> geekosaur: so you get most of the same benefits.
12:57:39 <Tekmo_> sdegutis: He will listen
12:57:51 <dmwit> Haskellfant: If you have something that doesn't work, post a complete, minimal example.
12:57:54 <sdegutis> Tekmo_: to some random guy who has no idea what he's talking about? not likely, and for good reason ;)
12:57:55 <dmwit> ?paste
12:57:55 <lambdabot> Haskell pastebin: http://lpaste.net/
12:58:02 <Haskellfant> dmwit: my point is: I don't want the s there
12:58:11 <geekosaur> but can you reliably detect what is what, or do you blindly hope some popup didn't appear first? it's hard enough to do that even in X11 and CG doesn't give you as much information as X11 does
12:58:13 <sdegutis> I'm considering ditching OS X for linux, but that's not a small thing
12:58:36 <Tekmo_> sdegutis: I think you have it backwards.  Developers crave useful feedback
12:58:41 <EvanR> how do i write a bytestring to a memory location pointed to by Ptr Whatever
12:58:45 <fizbin> Is there any way to reuse code that's written for a type class with type parameters with a structure that acts mostly like that typeclass but with limited parameters?
12:59:27 <EvanR> its a pointer to a buffer
12:59:44 <dmwit> Haskellfant: Sorry, your problem description doesn't make sense to me.
12:59:45 <sdegutis> Tekmo_: lol
13:00:00 <sdegutis> Dear everyone here:  What OS do you use and love?
13:00:10 <Clint> debian
13:00:11 <adimit> sdegutis: maybe better take it to #haskell-blah
13:00:17 <ddp> problem solved, btw; PATH problem after all
13:00:33 <fizbin> That is, suppose I have some code that's written to use a Data.Graph.Inductive.Graph.Graph. That's a typeclass with two parameters. Now, I want to create something that's like a Graph, but restricted to certain types.
13:00:37 <Haskellfant> dmwit: complete example: http://lpaste.net/119759
13:00:40 <dmwit> fizbin: If I understand you correctly; no, not really. See e.g. mono-traversable for an example of how other people deal with that problem.
13:00:46 <sdegutis> adimit: a different crowd hangs out there; consider this an informal survey of Haskellers
13:00:52 <sdegutis> Feel free to PM me the answer.
13:01:31 <fizbin> (Because I want to restrict all nodes to only having edges out of the left side of an Either, or out of the Right)
13:01:47 <MrMetric> Dear sdegutis: Fedora 20 right now
13:02:06 <sdegutis> MrMetric: awww you called me Dear <3
13:02:21 <fizbin> Is there any concise way to have code that works on my not-quite-a-Graph and also still works on real Data.Inductive.Graph.Graphs?
13:02:34 <dmwit> Haskellfant: Not in scope: TreeShape, LeafS
13:02:46 <Haskellfant> dmwit: sry, updated
13:03:00 <fizbin> dmwit: It isn't clear to me what problem mono-traversable is addressing.
13:03:34 <dmwit> fizbin: Traversable things have to be able to contain any value. mono-traversable things contain a specific type of value.
13:03:47 <dmwit> But otherwise support the same kind of traversal things on that type of value.
13:04:41 <fizbin> Ah.
13:04:44 <fizbin> Hrm.
13:05:29 <naudiz> does someone know how to convert an Id in persistent into an Integer value?
13:05:46 <fizbin> Well, maybe this could work - I create a new typeclass and then an instance for anything that has a Graph instance. Or really, for the only two things that have general Graph instances...
13:09:38 <sdegutis> mniip: what OS do you use.
13:10:05 * hackagebot uhc-light 1.1.8.6 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.8.6 (AtzeDijkstra)
13:10:09 <dmwit> Haskellfant: I suggest data Forest (ss :: [TreeShape]) a where ..., then Branch :: a -> (t :: Forest ss a) -> Tree (BranchS ss) a. Forget MapToShapes entirely.
13:11:13 <Haskellfant> dmwit: that seems like a good idea, I'll try that
13:11:32 <mniip> sdegutis, Gentoo GNU/Linux
13:11:42 <mniip> or Windows for gaming
13:11:45 <sdegutis> mniip: cool cool
13:12:37 <dmwit> Haskellfant: works here, I'll paste in a second
13:12:44 <rasen> brofist, mniip
13:13:29 <lpaste> dmwit pasted “shaped trees” at http://lpaste.net/119763
13:13:58 <mniip> sdegutis, I also use debian on my server if that matters
13:15:34 <gamegoblin> So I know Show isn’t supposed to be used for pretty printing (it should be valid haskell code, or so I’ve been told) — are there typeclasses that should be used for showing a more human readable form?
13:15:51 <dmwit> gamegoblin: I don't think there's a standard one, unfortunately.
13:15:56 <dmwit> gamegoblin: But it's easy to make one. =)
13:15:59 <gamegoblin> dmwit: shame
13:16:01 <gamegoblin> Of course
13:16:43 <Haskellfant> dmwit: awesome, thx!
13:33:27 <gcganley> is there anyway to search by type in ghci(-ng)? i understand hoogle searchs known libraries but im thinking about code i write my self and query by type
13:33:51 <Welkin> install hoogle locally
13:34:02 <gcganley> Welkin: i did, does that just work?
13:34:03 <Welkin> there are plugins that will let you search from your text editor
13:34:10 <gcganley> Welkin: i use emacs
13:34:18 <Welkin> I've never used local hoogle, so I don't know
13:34:30 <Welkin> I would assume it works the same way
13:34:32 <gcganley> Welkin: hmm, calling chrisdone
13:34:53 <gcganley> I guess hes not in right now lol
13:37:03 <hop> Hello,
13:37:12 <gcganley> hop: hi
13:37:44 <hop> Hello, what would be the most concise way to get Num typeclass  (for example) for (Int32,Int32) (for example)?
13:38:00 <hop> Basically, derive typeclass for tuple.
13:38:18 <enthropy> @hackage applicative-numbers
13:38:19 <lambdabot> http://hackage.haskell.org/package/applicative-numbers
13:38:52 <gcganley> hop: do you mean ensure that both sides of the tuple have a num constraint?
13:39:29 <hop> gcganley: No, I want to use '+' on tuple where members of tuple are Num members.
13:39:50 <gcganley> hop: could do arrow if you wanted to or one sec ill write a funciton
13:40:33 <gcganley> hop :: Num a => (a,a) -> (a,a) -> (a,a)
13:40:45 <enthropy> nevermind applicative-numbers doesn't define the right instances
13:40:59 <hop> gcganley: the goal is to not write the + myself obviously. I am looking for automatic way for tuples.
13:41:11 <gcganley> hop (x,y) (xx,yy) = (,) (x + xx) (y + yy)
13:41:24 <gcganley> one sec ill write it better
13:41:34 <gcganley> ill open ghci and work on it
13:41:35 <enthropy>  instance (Num a, Num b) => Num (a,b) where (+) (a,b) (c,d) = (a+c,b+d); ...lots of other methods
13:42:01 <gcganley> yeah is (,) part of Num?
13:42:10 <enthropy> no
13:42:18 <hop> enthropy: I wanted to avoid this basically :-)
13:42:22 <gcganley> you could write it in theory though right?
13:42:23 <johnw> hop: that will work with <> if your tuple has Sum members
13:42:43 <johnw> > getSum $ (Sum 1, Sum 2) <> (Sum 3, Sum 4)
13:42:45 <lambdabot>  Couldn't match expected type ‘Data.Monoid.Sum a’
13:42:45 <lambdabot>              with actual type ‘(Data.Monoid.Sum a0, Data.Monoid.Sum a1)’Could...
13:42:45 <lambdabot>              with actual type ‘(Data.Monoid.Sum a2, Data.Monoid.Sum a3)’
13:42:52 <ezrios> Hello, I am using syntastic vim for Haskell development
13:43:07 <ezrios> and recently whenever I save a file, vim completely hangs and the error/warnings pane does not open
13:43:12 <ezrios> I have to Ctrl-C in order to be able to use vim again
13:43:14 <ezrios> what gives?
13:43:42 <gcganley> :t bimap
13:43:43 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
13:43:49 <gcganley> damn
13:44:22 <johnw> > over both (+5) (1, 3)
13:44:24 <lambdabot>  (6,8)
13:45:13 <enthropy> hop: I think they're on hackage somewhere... but I can't recall where
13:45:59 <KaneTW> ls
13:46:01 <KaneTW> ugh
13:46:12 <Hijiri> @pl uncurry $ \x y -> (x+) *** (y+)
13:46:12 <lambdabot> uncurry ((. (+)) . (***) . (+))
13:47:05 <gcganley> Hijiri: do we need arrows for this? or are we talking about different things lol
13:47:09 <hop> Thanks. I will at Sum. But this is not really a problem anyway. I can make the implementation manually if needed
13:47:19 <Hijiri> I just thought *** would be useful here
13:47:50 <Hijiri> but it only gets you part of the way
13:48:09 <Hijiri> > uncurry ((. (+)) . (***) . (+)) (5,6) (12,3535)
13:48:11 <lambdabot>  (17,3541)
13:48:21 <Hijiri> I don't think anyone would really use this mess though
13:48:33 <gcganley> :t (\f (a,aa) (b,bb) -> (,) (f a b) (f aa bb))
13:48:35 <lambdabot> (t -> t1 -> b) -> (t, t) -> (t1, t1) -> (b, b)
13:48:57 <gcganley> @pl (\f (a,aa) (b,bb) -> (,) (f a b) (f aa bb))
13:48:58 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
13:49:01 <gcganley> OH GOD
13:49:17 <gcganley> what have i done...
13:49:31 <Hijiri> man was never meant to see these runes
13:49:50 <exio4> you'd need bifunctor and biapplicative!
13:50:07 <gcganley> exio4: i thought of bifunctor but ive never used it
13:50:19 <gcganley> :t bimap
13:50:20 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
13:50:24 <92AAAF6YN> Does anyone know how to use websockets from warp? I have the websockets code working fine, but all the examples integrating with warp seem to have bitrotted
13:50:27 <exio4> @type bimap (+) (+)
13:50:28 <lambdabot> (Bifunctor p, Num c, Num a) => p a c -> p (a -> a) (c -> c)
13:51:04 <exio4> @type \x y -> bimap (+) (+) x <<*>> y
13:51:06 <lambdabot> Not in scope: ‘<<*>>’
13:51:08 <exio4> aw :P
13:51:52 <gamegoblin> @pl \(a,b) (c,d) -> (a && c, b && d)
13:51:52 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (&&)) . flip . (((.) . (,)) .) . (&&))
13:51:56 <gamegoblin> lol
13:52:00 <gamegoblin> I love pl
13:52:05 <gcganley> gamegoblin: yeah... i did that too
13:52:22 <gcganley> gamegoblin: its really fun when you add in a function, watch
13:52:27 <gcganley> @pl (\f (a,aa) (b,bb) -> (,) (f a b) (f aa bb))
13:52:28 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
13:52:32 <gcganley> see
13:52:45 <exio4> it's really readable code!
13:52:47 <gamegoblin> Sometimes it comes up with clever little solutions you hadn’t thought of
13:52:48 <hae> Wat.
13:52:50 <gamegoblin> sometimes it does that
13:53:11 <gcganley> gamegoblin: it show'd me lifM2! and also that abismal pile of shit
13:53:28 <hae> @pl id
13:53:28 <lambdabot> id
13:53:33 <hae> Lol.
13:53:40 <gcganley> hop: anywho did that answer your question?
13:53:40 <exio4> @pl \f g -> (f .) . (. g)
13:53:40 <lambdabot> (. flip (.)) . (.) . (.)
13:53:42 <gamegoblin> @pl (\x -> not (not x))
13:53:43 <lambdabot> id
13:53:52 <gamegoblin> Did ~~ reduction!
13:53:55 <gcganley> @pl (.) . (.)
13:53:55 <lambdabot> (.) . (.)
13:54:11 <exio4> gcganley: maybe try to unpl the code lambdabot generated a bit ago
13:54:56 <hae> What does PL stand for again?
13:55:01 <gamegoblin> pointless
13:55:08 * hackagebot units 2.2.1 - A domain-specific type system for dimensional analysis  http://hackage.haskell.org/package/units-2.2.1 (RichardEisenberg)
13:55:10 <gamegoblin> a joke on point-free, IIRC
13:55:16 <raek> :t flip flip
13:55:18 <lambdabot> b -> (a -> b -> c) -> a -> c
13:55:21 <gcganley> exio4: i didnt catch it
13:55:23 <hae> Oh yeah XD.
13:56:16 <gcganley> :t flip flip flip
13:56:17 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
13:56:45 <exio4> @. unpl pl (\f (x1,y1) (x2,y2) -> (f x1 x2, f y1 y2)
13:56:45 <lambdabot> <unknown>.hs: 2: 16:Parse error: of
13:56:47 <exio4> @. unpl pl (\f (x1,y1) (x2,y2) -> (f x1 x2, f y1 y2))
13:56:48 <lambdabot> (\ as f -> (snd >>= \ db -> return ((\ cf k d -> (snd >>= \ bf -> return ((\ y -> (\ ao cx af ag aj am -> ((,)) (ao cx aj) (af ag am)) as (fst cf) as k (fst y)) d bf)) d) f db)) f)
13:56:59 <Rotaerk> hmm, I would like to fold a tree in such a way that the accumulator received by each node is based soley on that node's ancestors, and not all the nodes that have been processed thus-far
13:57:09 <Rotaerk> does something like that exist already?
13:57:27 <Rotaerk> for instance, let t = Node 5 [Node 6 [], Node 7 [Node 8 []]]
13:57:39 <Rotaerk> I can do:  foldlM (\accum nodeVal -> let s = accum + nodeVal in putStrLn (show s) >> return s) 0 t
13:57:58 <Rotaerk> this produces the output: 5 11 18 26
13:58:14 <Rotaerk> but I'd like it to produce:  5 11 12 20
13:58:55 <Rotaerk> I could build the recursion manually to do this, just would like to do it with an abstraction if it exists
13:59:39 <yac> there is no mktemp in haskell, huh
13:59:59 <yac> well, I need a function that will give me a filename that doesn't exists
14:00:12 <Rotaerk> https://hackage.haskell.org/package/temporary-1.1/docs/System-IO-Temp.html
14:00:21 <yac> Rotaerk: that doesn't have mktemp
14:00:50 <Rotaerk> yac, it's not called mktemp here, but isn't that what "withTempFile" does
14:00:52 <rasen> openTempFile?
14:01:09 <yac> Rotaerk: no. mktemp only returns the filename but doesn't create the file
14:01:20 <sdegutis> Yeah you probably want withTempFile
14:01:25 <sdegutis> That said, I know nothing of your requirements at all.
14:01:28 <yac> no, I don't
14:01:46 <yac> hum, looks like it depends. /usr/bin/mktemp creates the file
14:01:54 <Rotaerk> yac, what do you mean it doesn't create the file?
14:02:02 <Rotaerk> the lambda you provide receives a file handle
14:02:11 <yac> I meant https://docs.python.org/2/library/tempfile.html#tempfile.mktemp
14:02:15 <yac> and it's deprecated yay
14:02:30 <yac> Rotaerk: ^ see, it doesnt create the file.
14:02:42 <Rotaerk> oh you mean the non-haskell one doesn't create the file
14:02:54 <yac> I am abusing this in test cases where I need to test of code behaviour when given non-existing file
14:03:33 <yac> Rotaerk: yeah, I assumed it's what all mktemp does (as opposed to mkstemp or mk<whatever>temp)
14:03:43 <sdegutis> The daemons package hasn't been touched for 2 years -- is it still good?
14:03:47 <sdegutis> I wanna make a daemon.
14:04:07 <gamegoblin> You should light some candles and do some satanic rituals
14:04:08 <Rotaerk> yac, I don't think it would be a good idea to have a function produce a non-existent-file name without creating the file
14:04:17 <rasen> Rotaerk: You can go from leaves to top with cata.
14:04:18 <Rotaerk> yac, otherwise something else could call the function and get back the same file name
14:04:26 <yac> Rotaerk: unlikely
14:04:33 <yac> good enough for unit tests
14:04:54 <rasen> Rotaerk: reverse order of what you asked
14:05:10 <yac> also if the tests run in controlled environemnt, it really can't happen
14:05:11 <Rotaerk> rasen, I don't think the order of traversal is the problem, it's the fact that the accumulator is a single value rather than a stack
14:05:18 <Rotaerk> rasen, of course, order ALSO matters but...
14:05:21 <yac> unless you botch the test
14:06:06 <rasen> Rotaerk: if order doesn't matter for you, there is catamorphism
14:06:29 <Rotaerk> rasen, it does matter; my point is just that that's not the core of the problem
14:07:40 <hae> Probably fine. There are tons of packages that aren't regularly updated just because Haskell is so good at that kind of perfection.
14:07:52 <Rotaerk> rasen, I ultimately want it to start at the root, traverse all the way to a leaf, adjusting the accumulator along the way, and for each node, push it to a stack
14:08:05 <hae> In regards to the daemons package.
14:08:13 <Natalina23>   http://tinyurl.com/ozfvxy3
14:08:17 <sdegutis> hae: ok
14:08:24 <Rotaerk> rasen, then, when it gets to a leaf, back up to its parent, pop the accumulator stack, and traverse to a different leaf
14:09:19 <Rotaerk> so that when each leaf is processed, the accumulator is only the accumulation of the ancestors
14:09:27 <Rotaerk> i.e. not the sibling nodes
14:09:52 <rasen> I see. I don't know generalization for that
14:10:01 <Rotaerk> k
14:10:52 <Rotaerk> probably would've been simpler if I'd just written out the code and THEN asked for a way to simplify :P
14:20:15 <rasen> Can somebody help me understand zygohistomorphic prepromorphisms?
14:20:40 <jle`> i only know about zygohistomorphic postpromorphisms, sorry
14:20:58 * hae shuts down brain to prevent category theory overload
14:21:00 <geekosaur> you're not supposed to understand them...
14:21:16 <tomphreek> is there a cli lpaste tool?
14:21:26 <tomphreek> couldn't find it on google :/
14:21:47 <Zemyla> Woo, my memoization library works!
14:21:51 <jle`> :D
14:22:21 <rasen> geekosaur: why not?
14:23:44 <geekosaur> there was a paper many years ago which tried to approach functional data types in terms of morphisms. that was one of the apex morphisms built from smaller ones. unfortunately it did not *add* anything useful to the ecosystem, merely described an increasingly unlikely set of cases
14:24:03 <hae> rasen, if you want to know about cohylomorphic catamonad lens prepositions, I'm your guy.
14:24:04 <geekosaur> and zygohistomorphic prepromorphisms in particular tend to be the butt of jokes
14:24:08 <lpaste> tomphreek pasted “finite binary tree. I d like infinite one to work too” at http://lpaste.net/119766
14:24:19 <geekosaur> because they're pretentious-sounding and largely useless
14:24:23 <rasen> geekosaur: weren't that paper called bananas, lens, etc
14:24:54 <hop> Very newbie question: I am confused about binding visilibities and difference between let and where. Basically, https://gist.github.com/anonymous/86b090efeef56090b981 (with let) compiles while https://gist.github.com/anonymous/2b43d5e14825e30de3b7 (with where) does not because xm,xM... are not visible.
14:24:55 <geekosaur> I don't think so? that one introduced things that were useful. it may have had a shout-out to the morphisms paper though
14:25:06 <tomphreek> could you guys help me figure out how to make my binary tree to work with initialisation from an infinite list?
14:25:20 <rasen> geekosaur: catamorphism, paramorphism, hylomorphism?
14:25:27 <hop> Would you have link or some material so I can understand the diff? Thanks!
14:25:29 <dicioccio1> in short I care about ordering but not nesting direction, is this something possible?
14:26:13 <dicioccio1> damn sorry, ssh lag
14:27:29 <mauke> hop: 'where' attaches to declarations, not expressions
14:27:45 <mauke> in this case the whole clipEdge declaration
14:28:27 <mauke> you could fix this by moving ((xm,ym),(xM,yM)) into 'where', too
14:28:28 <hop> mauke: Sorry, I don't understand :-(
14:28:55 <hae> hop, where is top level only. You cannot have multiple wheres in a top-level function.
14:28:59 <mauke> foo x y = ... where ...
14:29:00 <dmwit> tomphreek: You might like split [] = ([], []); split (x:xs) = let ~(b, e) = split xs in (x:e, b)
14:29:04 <hop> hae: Ah!
14:29:23 <dmwit> > let split [] = ([], []); split (x:xs) = let ~(b,e) = split xs in (x:e, b) in split [1..5]
14:29:25 <lambdabot>  ([1,3,5],[2,4])
14:29:31 <dmwit> > let split [] = ([], []); split (x:xs) = let ~(b,e) = split xs in (x:e, b) in split [1..]
14:29:32 <hop> hae, mauke: I see so. Makes sense. Thansk!
14:29:33 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
14:29:41 <mauke> in the 'where ...' part, x and y (the function parameters)) are visible, but not anything defined inside the function body
14:29:55 <rasen> hae: what is cohylomorphic catamonad lens stuff?
14:31:04 <systemfault> Just when I thought that Haskell terminology couldn't scare me anymore... I read "cohylomorphic catamonad lens" .... FFFFUUUUUU
14:31:34 <rasen> systemfault: sorry about that
14:31:49 <systemfault> :D
14:31:54 <systemfault> I'm a beginner, so it's cool
14:32:02 <mauke> "you're a nut, you're crazy in the coconut"
14:32:29 <exio4> coinsanity
14:32:33 <adimit> systemfault: Google did not encounter it yet.
14:33:24 <hae> A cohylomorphic catamonad lens is another term for a metamorphic eigenfunctor pseudo-arrow.
14:33:39 <adimit> I mean hylomorphism is basically category theory slang for something that usually boils down to something similar to a map/reduce.
14:33:56 <hae> Is that easier to understand?
14:34:00 <adimit> … and that's as far as it goes with me. I have no idea what a catamonad is.
14:34:35 <lpaste> dmwit annotated “finite binary tree. I d like infinite one to work too” with “finite binary tree. I d like infinite one to work too (annotation)” at http://lpaste.net/119766#a119769
14:34:59 <dmwit> tomphreek: spoilers at that link, don't look if you want to try for yourself
14:37:12 <dmwit> :t transpose . chunksOf 2
14:37:13 <lambdabot>     Ambiguous occurrence ‘transpose’
14:37:13 <lambdabot>     It could refer to either ‘BSC.transpose’,
14:37:13 <lambdabot>                              imported from ‘Data.ByteString’ at /home/lambda/.lambdabot/State/L.hs:68:1-22
14:37:36 <dmwit> :t Data.List.transpose . chunksOf 2
14:37:37 <lambdabot> [a] -> [[a]]
14:38:01 <dmwit> > map (take 3) . Data.List.transpose . chunksOf 2 $ [1..]
14:38:03 <lambdabot>  Ambiguous occurrence ‘map’
14:38:03 <lambdabot>  It could refer to either ‘GHC.Base.map’,
14:38:03 <lambdabot>                           imported from ‘Data.List’ at L.hs:95:1-16
14:38:11 <dmwit> wow
14:38:17 <dmwit> > fmap (take 3) . Data.List.transpose . chunksOf 2 $ [1..]
14:38:19 <lambdabot>  Ambiguous occurrence ‘take’
14:38:19 <lambdabot>  It could refer to either ‘GHC.List.take’,
14:38:19 <lambdabot>                           imported from ‘Data.List’ at L.hs:95:1-16
14:38:43 <dmwit> ?undefine
14:38:43 <lambdabot> Undefined.
14:38:58 <dmwit> :t take
14:38:59 <lambdabot> Int -> [a] -> [a]
14:39:02 <dmwit> :t transpose
14:39:03 <lambdabot> [[a]] -> [[a]]
14:39:12 <dmwit> > map (take 3) . transpose . chunksOf 2 $ [1..]
14:39:16 <lambdabot>  mueval-core: Time limit exceeded
14:40:11 * hackagebot os-release 0.2.0 - /etc/os-release helpers  http://hackage.haskell.org/package/os-release-0.2.0 (yac)
14:40:25 <dmwit> Oh, I see. It doesn't know for sure that it's reached the end of the outer list until it's sure *every* sublist has length 2.
14:41:16 <dmwit> > take 16 . show . map (take 3) . transpose . chunksOf 2 $ [1..]
14:41:18 <lambdabot>  "[[1,3,5],[2,4,6]"
14:41:38 <rasen> Finally found paper on prepromorphism
14:42:07 <dmwit> tomphreek: That's an alternate implementation of split, in case you're allergic to explicit recursion.
14:43:06 <dmwit> Just take care to match on the pattern (odds:evens:_) instead of [odds, evens] to avoid the problem I had. =)
14:43:30 <yac> how long does it take for hackage to build docs?
14:43:58 <dmwit> It used to take a day or two. I don't know how long since the changeover to Hackage2, but I doubt it would be longer than old Hackage.
14:44:11 <dmwit> I think there's also a way to ask that it retry building them, and a way to upload your own documentation.
14:48:13 <tomphreek> dmwit: I am reallly distracted at the momement, but your many thanks, I ll attend to soon and will properly appreciate the hints/code
14:48:25 <dmwit> cheers
14:54:03 <bramgg> Is it possible to open GHCi and load a file in it all in one command? (Instead of first starting GHCi and then loading a file)
14:54:16 <geekosaur> ghci foo.hs ?
14:54:48 <Marlin> is there already a function like this?  (a -> Bool) -> [a] -> Int
14:54:59 <bramgg> geekosaur: thanks, guess I should have done a bit more research before asking :/
14:56:30 <hae> Marlin, the type signature doesn't exactly make it clear what you want the function to do.
14:56:43 <Marlin> count :: (a -> Bool) -> [a] -> Int
14:57:00 <Zemyla> :t \f -> length . filter f
14:57:01 <lambdabot> (a -> Bool) -> [a] -> Int
14:57:04 <geekosaur> :t (length .) . filter
14:57:05 <lambdabot> (a -> Bool) -> [a] -> Int
14:57:16 <geekosaur> heh, a bit slow as usual >.>
14:57:18 <dmwit> :t findIndex
14:57:19 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
14:58:36 <Marlin> thanks.. I see why type signature wasn't eough
15:02:29 <hae> Reminds me of what somebody called "pathological functions", where the type signature suggests they do something they actually don't, i.e. by ignoring arguments.
15:03:49 <EvanR> so modifyMVar might get mucked up if an MVar has many writers, it seems like
15:08:33 <glguy> EvanR: As long as everyone's using modifyMVar and withMVar and readMVar functions it's fine
15:09:02 <glguy> EvanR: Manual calls to putMVar will mess up the invariant that the person who took from the mvar has the "lock" until putting it back
15:09:15 <Marlin> @pl (\c -> isUpper c == False && isLower c == False)
15:09:16 <lambdabot> ap ((&&) . (False ==) . isUpper) ((False ==) . isLower)
15:09:19 <Marlin> :-O
15:09:23 <glguy> (not really person)
15:09:56 <EvanR> the entity ;)
15:10:09 <EvanR> great word for the lazy
15:10:55 <betaceti> hi all: what's the mathematical definition of a "data structure"? is it out of symbolic logic?
15:12:25 <betaceti> i was thinking maybe mapping the schema for a data structure to memory would be like an interpretation in model theory, but maybe i'm not thinking about it the right way
15:13:52 <gcganley> is there anyway to customize hoogle for local use? like adding local file functions to the ghci search
15:14:14 <gcganley> I have hoogle set up for the hoogle site but not for local search
15:17:15 <MrMetric> Is it IO() or IO ()?
15:17:24 <adimit> MrMetric: the latter.
15:17:29 <gcganley> MrMetric: IO ()
15:17:41 <Marlin> aren't both valid?
15:17:54 <Hijiri> both are valid I think
15:18:04 <Hijiri> it's convention to write it IO () though
15:18:08 <adimit> MrMetric: IO is not a function in the Java/C sense. It's a type function, and the type application operator is usually ' '. Which makes IO () more consistent with IO Bool.
15:18:10 <Hijiri> because if you used another type it would be wrong
15:18:19 <Hijiri> IOa would be wrong, while IO a is right
15:18:23 <adimit> or just IO a in general.
15:18:32 <Hijiri> so you would just put () where a is and there is a space
15:18:41 <gcganley> Hijiri: thinking IO () is just the better way to write it
15:18:45 <Hijiri> yeah
15:18:48 <adimit> Jes, like Hijiri said it, IO() parses, as does Applicative(), for that matter. Or IO[]. But it's bad style.
15:18:54 <MrMetric> ghci also gives it as IO ()
15:19:01 <MrMetric> Hey, how do I close ghci?
15:19:08 <gcganley> MrMetric: :q
15:19:16 <MrMetric> Thanks
15:19:17 <gcganley> MrMetric: its like vim
15:19:20 <Hijiri> I've been using ^D because I didn't know about :q
15:19:24 <adimit> MrMetric: you can also use Ctrl-D
15:19:37 <gcganley> Hijiri: I used to use a lot of vim
15:19:38 <MrMetric> gcganley: I don't use vim
15:19:46 <MrMetric> Isn't ^D EOF?
15:19:51 <adimit> MrMetric: exactly.
15:19:51 <Hijiri> yeah
15:20:00 <gcganley> MrMetric: no shame in using notepad or something of that ilk
15:20:01 <adimit> ghci quits on EOF (many repls do.)
15:20:21 <adimit> BTW, : is a prefix for lots of commands in ghci. Like :type, which is very useful.
15:20:36 <MrMetric> I usually use Sublime Text. Atom is nice too, but it starts much too slowly and can't open large files
15:20:45 <MrMetric> Is :type like :t?
15:20:57 <gcganley> MrMetric: have I told you of my lord and savior emacs?
15:21:03 <MrMetric> ._.
15:21:07 <adimit> :t \f -> length . concatMap f
15:21:08 <lambdabot> (a1 -> [a]) -> [a1] -> Int
15:21:11 <MrMetric> Try ed!
15:21:22 <exio4> MrMetric: :t is :type, yes
15:21:32 <gcganley> :r is :reload
15:23:44 <tomphreek> dmwit: nice one. I kinda wanted heap like "split" though (node i having 2*i+1, 2*i+2) children though, though I will think a bit more whether I really need it
15:23:47 <athan> MrMetric: FP-Eclipse?
15:24:05 <ezrios> is there a nice way to install profiling libraries in a cabal sandbox?
15:24:07 <Marlin> not that I care about performance in this case, I am just curious if haskell compiler is smart enough to do a single pass on a list in this code?  (length (filter p xs))
15:24:21 <MrMetric> athan: Is that related to Eclipse, my favorite Java IDE?
15:24:25 <athan> :)
15:24:26 <ezrios> I keep getting "Perhaps you haven't installed profiling libraries for 'xxx-1.2.3.4'"
15:24:33 <ezrios> and having to traverse the entire dependency tree
15:24:37 <athan> MrMetric: Have you heard of Scala?
15:24:42 <MrMetric> Yes
15:24:54 <MrMetric> I've never used it
15:25:09 <adimit> Marlin: I think it should fuse. Though you might try length . filter p $ xs instead.
15:25:11 <athan> If you're a Java guy, you might find it an easier transition than raw haskell
15:25:14 <MrMetric> The only time I've touched Scala is when I tried to fix a crash bug in a Minecraft mod
15:25:29 <MrMetric> No, I'm not a Java guy. I just need to use it for university courses
15:25:50 <athan> :)
15:26:07 <athan> I haven't used FP haskell myself productively yet, but it seems legit
15:26:07 <Marlin> adimit was that just a style suggestion or is it relevant for fusing?
15:26:21 <MrMetric> I prefer using Python unless something needs to be fast
15:26:38 <Marlin> how would one even go about checking if something is fused?
15:26:51 <geekosaur> generally by examining the generated "ghc core"
15:27:01 <athan> Anyone wanna see a weird syntax for (...metacircular?) lambdas? http://www.deconfigured.com/blog/atlc4#substitution-model
15:27:02 <geekosaur> (ghc -ddump-simpl, or use the ghc-core package)
15:28:05 <athan> (it's a draft)
15:28:06 <gcganley> MrMetric: what do you like in python that isnt in haskell. i always like asking people from different languages this question
15:28:24 <geekosaur> if the code is fused then you won't see any lists in it, or perhaps only the input list if it couldn't fuse generation of that list with its consumption
15:28:33 <MrMetric> gcganley: I've no idea. I am new to Haskell and as such do not really know what it can do
15:28:46 <MrMetric> Well, there is one thing
15:28:49 <MrMetric> I like for loops! :P
15:28:58 <gcganley> :t forM
15:28:59 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
15:29:04 <gcganley> MrMetric: ;)
15:29:25 <athan> MrMetric: Trust the monad
15:29:36 <MrMetric> I see there's also a forM_
15:29:41 * athan takes a swig of koolaid
15:29:46 <gcganley> MrMetric: do you use recursion much?
15:29:48 <athan> Ahhhhh *dead*
15:30:04 <athan> MrMetric: That's "forgetful"
15:30:05 <MrMetric> gcganley: I rarely use it. It's not usually necessary
15:30:07 <dpn`> easier to hire people, more library variety - for async IO I think there's some nicer ways of being explicit about laziness in python
15:30:07 <athan> er
15:30:17 <athan> ...(anyone have a better word?)
15:30:23 <dpn`> apart from those things... I'd probably rather be writing haskell for my day job :D
15:30:42 <mac10688> anyone know a little bit about javascript? I have a question about functional programming with a javascript library called ramda
15:30:49 <gcganley> MrMetric: I recomend understanding how to use it. It will easily replace any need for loops
15:30:58 <gcganley> :t mapM
15:30:59 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:31:08 <gcganley> @src mapM
15:31:08 <lambdabot> mapM f as = sequence (map f as)
15:31:11 <MrMetric> gcganley: I understand recursion, I just don't usually use it
15:31:29 <gcganley> MrMetric: do you not like it? and just prefer loop structures?
15:31:30 <athan> ...any opinions..? (of the lambda syntax)
15:31:42 <mac10688> and I've never wrapped my head around monads
15:31:49 <athan> mac10688: What's up?
15:31:52 <gcganley> athan: whos that question pointed to
15:31:53 <mac10688> just a second
15:32:02 <MrMetric> gcganley: I don't find myself ever needing to use it unless I want Fibonacci numbers
15:32:05 <athan> gcganley: Whoever clicked my link :P
15:32:07 <mac10688> http://ramdajs.com/docs/#arity
15:32:16 <athan> MrMetric: It's wonderfully useful
15:32:18 <mac10688> the arity function in this javascript library doesn't make sense to me
15:32:21 <tomphreek> dmwit: playing around with your soln, thinking why yours return mine halts
15:32:32 <mac10688> takesOneArg.length; //=> 1
15:32:32 <mac10688> takesOneArg(1, 2); //=> [1, 2]
15:32:45 <athan> This lib looks nice :)
15:32:50 <mac10688> I don't understand if it only takes one argument, why they pass two in the next line
15:32:56 <athan> (I'm still trying to get fantasyland if I had time)
15:33:21 <mac10688> seems like they would just have to pass in one argument at that point
15:33:28 <gcganley> MrMetric: really? I never use loops ever since i started using lisp where it was simply easier to use recursion rather than looping
15:33:33 <athan> ahh so
15:33:41 <athan> this is actually similar to my ATLC :P
15:33:55 <athan> mac10688: This is not strongly typed
15:33:58 <Marlin> in haskell though you can often replace explicit recursion with higher order functions
15:34:03 <athan> if it were, there would be an error
15:34:07 <athan> That's why :P
15:34:17 <athan> :t fix
15:34:17 <mac10688> oh, is there an error in documentation you think?
15:34:18 <lambdabot> (a -> a) -> a
15:34:20 <MrMetric> gcganley: I've never used Lisp. I mostly use C++ and Python, although I often find myself wanting something better
15:34:36 <athan> mac10688: Nope, not even an error, this is the library's intention (which honestly goes against pure FP)
15:35:03 <mac10688> that's very sad, this library was built to be purely FP
15:35:25 <mac10688> I'll mention it on their gitter chat and maybe they can do something about it, because that just seems wrong to me
15:35:25 <athan> :P
15:35:28 <gcganley> MrMetric: I've used C++ when i came from C#. into Clojure then Haskell. I've used a ton of languages... but lisp has a lot of advantages. i find that Lisp is better than haskell at a lot of things
15:35:29 <athan> don't worry yet
15:35:32 <mac10688> but I'm very new to functional programming
15:35:34 <athan> just be strict with oyurself
15:35:46 <athan> add me to it
15:35:47 <mac10688> will do, thanks for looking at that athan
15:35:48 <athan> @athanclark
15:35:48 <lambdabot> Unknown command, try @list
15:35:54 <athan> No worries :)
15:36:24 <osa1> I'm trying to understand output of +RTS -S, any ideas what does each line represent in the output?
15:36:55 <gcganley> osa1: I belive +RTS shows runtime information but i have no clue what -S does.
15:37:16 <MrMetric> gcganley: Most of what I've used is C-based. I think the only one that isn't is Python. Maybe I'm just too used to doing things a certain way to think of recursion as a solution
15:37:49 <MrMetric> I tried asm once… briefly
15:37:56 <osa1> gcganley: +RTS is for passing arguments to RTS, if you don't pass anyting or pass something wrong it prints help message which is probably what you're saying by "runtime information"
15:38:17 <osa1> anyway, I have 50k lines in the output but I have no ideas what each line is.
15:38:35 <gcganley> MrMetric: yeah to use haskell it takes some serious reporgramming of your brain
15:38:46 <geekosaur> I suspect you need to know how the gc is implemented for the detailed gc logging to be meaningful
15:39:19 <osa1> geekosaur: there are some parts that I think would make sense to anyone, for example this output also shows how much time spent on GCing
15:39:21 <gcganley> MrMetric: if you really want to learn about recursion i would suggest Lisp or Haskell and never use a loop. I've never used it in anger but scheme is amazing from what ive used.
15:39:27 <bramgg> Creating processes with System.Process in GHCi can freeze up the program (eg waiting 10 seconds for anything I type to appear), any way to get around this?
15:39:54 <geekosaur> time information you can get from the non-detailed output modes though
15:40:04 <gcganley> bramgg: async possibly?
15:40:15 <osa1> geekosaur: do you know if each line in this output means a GC run?
15:40:44 <MrMetric> I made a new project in EclipseFP. What is this line: module Main where
15:40:53 <Marlin> gcganley what lisp did you use?
15:41:00 <gcganley> Marlin: Clojure
15:41:01 <geekosaur> hm, I giess not unless you want a final summary. -B doesn't include a timestamp :p
15:41:11 <gcganley> MrMetric: its the module name.
15:41:13 <HeladoDeBrownie> MrMetric, it says that that module is named Main, it exports a binding named main, and its contents are to follow.
15:41:23 <bramgg> gcganley: thanks I'll try that. By the way do you know if it's just GHCi that this happens to? I'm assuming and hoping that creating processes won't slow down my actual programs in the same way.
15:41:30 <geekosaur> osa1, I do not, sorry
15:41:37 <MrMetric> What is 'where' for?
15:41:37 <HeladoDeBrownie> MrMetric, wait sorry, header but no export list means it exports *everything*
15:41:47 <HeladoDeBrownie> MrMetric, it introduces the contents of the module, the various top-level bindings
15:42:00 <gcganley> bramgg: I would perscribe simon marlows book, google it
15:42:01 <geekosaur> bramgg, it's not that slow in real programs but ghci's a different environment
15:42:14 <HeladoDeBrownie> MrMetric, normally the "module Foo where" bit, if not provided, is implicit, this is just making it explicit
15:42:19 <Marlin> I find it hard working in dynamically typed language after haskell. before I prefered them
15:42:25 <gcganley> bramgg: big problem is that ghci is bytecode interpreted
15:42:27 <HeladoDeBrownie> MrMetric, if there is no header, it's assumed to be: module Main (main) where
15:42:39 <geekosaur> I dont think bytecod einterpretation is the issue here
15:42:47 <gcganley> Marlin: I havent used it since I started haskell but there is typed clojure so.
15:42:52 <bramgg> geekosaur: thanks
15:42:55 <bramgg> gcganley: ill look that up
15:42:58 <geekosaur> some of the sandboxing it does may be
15:43:08 <geekosaur> depending on ghc version, platform, etc.
15:43:17 <MrMetric> It also made this line: main::IO()
15:43:22 <MrMetric> Isn't that supposed to have spaces?
15:43:27 <HeladoDeBrownie> MrMetric, doesn't need to
15:43:36 <HeladoDeBrownie> > let x::Integer;x=10 in x
15:43:37 <lambdabot>  10
15:43:52 <gcganley> MrMetric: main :: IO ()
15:44:03 * geekosaur bets the space between '0' and 'i' is also optional :p
15:44:07 <MrMetric> Well, which is preferred?
15:44:14 <HeladoDeBrownie> MrMetric, usually, with the spaces
15:44:33 <Marlin> gcganley types annotations are just optional though. and most of the functions in the ecosystem aren't annotated not will they be
15:44:40 <Marlin> nor*
15:46:40 <MrMetric> > let x::Integer;x=10in x
15:46:41 <lambdabot>  10
15:46:48 <MrMetric> Huh
15:47:21 <HeladoDeBrownie> yeah, the syntax is weird in some places, just the usual style doesn't run into the oddness very often :P
15:47:31 <geekosaur> that one is actually pretty common
15:47:44 <geekosaur> works in C, Java, etc.
15:48:09 <gcganley> Marlin: is there a statically typed, infered lisp[
15:48:34 <gcganley> -0
15:48:42 <jle`> > let i = [1,2,3] in take 2i
15:48:43 <lambdabot>  [1,2]
15:49:05 <learner> what do you think of learning haskell as a first language?
15:49:30 <HeladoDeBrownie> learner, i think it would be great to have more data on that :)
15:49:39 <MrMetric> > let i=[1,2,3]in take 2i
15:49:40 <lambdabot>  [1,2]
15:49:47 <jle`> it depends on the eventual goals i think, but i think it's a good idea for a first language.  the main problem might be just lack of materials or courses written for people learning haskell as a first language
15:49:54 <dfeuer> Ugh....
15:49:54 <dfeuer> > traverse (\x -> [x,x*10,x*100]) $ listArray (1::Int, 3) [1..3]
15:49:56 <lambdabot>  [array (1,3) [(1,1),(2,2),(3,3)],array (1,3) [(1,1),(2,2),(3,30)],array (1,3...
15:50:04 <HeladoDeBrownie> jle`, i bet someone has abused that syntax for a computer algebra system
15:50:06 <Marlin> gcganley maybe there is one in Racket?  there was also liskell, haskell with lisp syntax. but it is not supported any longer
15:50:43 <MrMetric> If you learn something like Haskell as your first language, how hard will it be to learn something C-based after?
15:50:49 <dfeuer> Very.
15:51:07 <HeladoDeBrownie> my guess is about as hard as the opposite direction
15:51:08 <learner> I'm going to take CompSci classes starting this year
15:51:13 <dfeuer> You will be banging your head on the table wondering what the heck they were thinking.
15:51:21 <HeladoDeBrownie> well, i guess there's that
15:51:32 <learner> I don't know much about programming, I've dabbled mostly in Javascript and Python
15:51:37 <learner> But I only know basic concepts
15:51:42 <jle`> HeladoDeBrownie: i hope so :)
15:52:17 <HeladoDeBrownie> learner, haskell is unlike those languages in many ways, it will take patience to learn and you have to approach it with a beginner's mind. fortunately, it sounds like you have that :)
15:52:24 <dfeuer> I get the impression that Python is somewhat like Lisp, but less sane than Scheme and less powerful than Common Lisp.
15:52:24 <MrMetric> With Haskell, I think I know what the other students in the Java class feel like
15:52:31 <jle`> if you are very comfortable with Haskell, i want to imagine that you'd be able to pick up C
15:53:00 <jle`> at least easier than the other way around
15:53:02 <jle`> but i have no evidence
15:53:05 <jle`> only wishful thining
15:53:16 <dfeuer> jle`, a Haskell programmer confronted by C's numeric promotion rules may well just give up....
15:53:18 <exio4> I bet you could imagine it as a domain-specific language with an implicit monadic syntax and implicit unsafeCoerce everywhere
15:53:34 <dfeuer> exio4, but it's *worse* than that.
15:53:46 <HeladoDeBrownie> it's already pretty easy to imagine python as a language with only one type once you've got used to static typing
15:53:50 <jle`> it might be difficult to use in practice, but not too difficult to understand
15:54:02 <jle`> as in, the language
15:54:08 <dfeuer> Ah, could bbe.
15:54:21 <MrMetric> With computer science (and programming) being such a (relatively) new thing, I wonder what it'll look like it 128 years
15:54:28 <MrMetric> *in
15:54:29 <dfeuer> A Haskell programmer would have to learn the discipline of manual memory management.
15:54:44 <jle`> hm
15:54:52 <dfeuer> Which is not generally trivial.
15:55:00 <jle`> but so does anyone coming from a language like java or python
15:55:12 <jle`> if that is what we are comparing it to
15:55:15 <dfeuer> And learn to think in terms of arrays instead of reaching for trees for everything.
15:55:25 <jle`> that might be tricky yeah
15:55:36 <dfeuer> Because trees are hellish in C.
15:56:09 <zwer> I think someone who learned haskell first would be more frustrated programming C than having trouble understanding the concepts in it
15:56:42 <MrMetric> Hey, how do I enable syntax highlighting in EclipseFP? It looks like it's not on by default
15:56:44 <HeladoDeBrownie> that's my impression also, but mostly because learning haskell has turned me off of various other languages :P
15:56:50 <jle`> speculating is fun
15:57:04 <HeladoDeBrownie> still, there's not a lot of data on this available, from what i can tell
15:57:32 <learner> HeladoDeBrownie, do you think already having some expectations (like for loops, mutable data) of how programming languages should work would hinder my progress
15:57:34 <HeladoDeBrownie> learner, in short, nobody has good evidence it's a good idea, however if you ask most of us in here, we'll say haskell's a pretty great language.
15:57:40 <jle`> learner: yes
15:57:41 <jle`> :)
15:58:01 <jle`> you will have more trouble than someone without those expectations
15:58:06 <jle`> such is life
15:58:17 <HeladoDeBrownie> learner, it didn't strongly affect me, so i couldn't say; but then i already had functional leanings well before i met haskell.
15:58:18 <learner> I'm thinking since I'm very new to programming
15:58:34 <learner> it would be easier to learn FP now than later
15:58:35 <exio4> loops are hard to though, because you need to care about lots of details :(
15:58:42 * dfeuer is actually planning to convert a tree-based algorithm to an array-based one (all in Haskell) and is not pleased about the fact that he will need to unbox things he doesn't even want to in order to make that work efficiently (there's a silly circular list that will need to be turned into an array because pointers into it can't be  stored in an unboxed array)
15:58:54 <MrMetric> I'm pretty sure I'm thinking too much about how to do stuff than what I want the end result to be
15:59:47 <dfeuer> MrMetric, well, then, stop doing that.
16:00:05 <HeladoDeBrownie> learner, i would say go for it, and if you like haskell, great, but if it's not your cup of tea, then you can always try more languages.
16:01:25 <learner> great :)
16:01:32 <learner> do you have any book suggestions?
16:01:56 <HeladoDeBrownie> @where learnhaskell
16:01:56 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:02:01 <HeladoDeBrownie> check out the recommendations there
16:02:07 <dfeuer> @where pfds
16:02:10 <gcganley> learner: bitemyapp has some really good shit
16:02:10 <gcganley>  
16:02:12 <MrMetric> Hey, what's the Haskell equivalent of this Python code: str(123).rjust(8)
16:02:15 <lambdabot> I know nothing about pfds.
16:02:16 <ab9rf> bitemyapp?
16:02:28 <gcganley> MrMetric: well str == show
16:02:30 <gcganley> :t show
16:02:31 <lambdabot> Show a => a -> String
16:02:38 <ab9rf> MrMetric: it depends
16:02:41 <ab9rf> what's rjust do?
16:02:42 <gcganley> MrMetric: idk what rjust is
16:02:49 <MrMetric> rjust pads a string at the left with spaces
16:03:01 <MrMetric> so "123".rjust(8) == "     123"
16:03:15 <ab9rf> hm
16:03:18 <Eduard_Munteanu> > printf "%8d" 123
16:03:19 <learner> thank you
16:03:20 <lambdabot>  No instance for (GHC.Show.Show a0)
16:03:20 <lambdabot>    arising from a use of ‘M521542583565538708013986.show_M5215425835655387080...
16:03:20 <lambdabot>  The type variable ‘a0’ is ambiguous
16:03:33 <Eduard_Munteanu> > printf "%8d" (123 :: Integer)
16:03:34 <lambdabot>  No instance for (GHC.Show.Show a0)
16:03:34 <lambdabot>    arising from a use of ‘M728517653611598353013999.show_M7285176536115983530...
16:03:35 <lambdabot>  The type variable ‘a0’ is ambiguous
16:03:45 <HeladoDeBrownie> > printf "%8d" 123 :: String
16:03:46 <lambdabot>  "     123"
16:03:47 <ab9rf> that's one way
16:04:05 <dfeuer> @where pfds
16:04:05 <lambdabot> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
16:04:07 <MrMetric> Thanks
16:04:14 <dfeuer> learner, you should read that book.
16:04:21 <ab9rf> > take 8 $ show (123::Int) ++ (repeat ' ')
16:04:23 <lambdabot>  "123     "
16:04:32 <HeladoDeBrownie> ab9rf, well, almost :)
16:04:32 <dfeuer> It's in fake ML, with pretend Haskell in the back, but it's really good.
16:04:34 <ab9rf> oh, you want right just, sorry
16:04:48 <ab9rf> right justify is harder, can't quite cheat that way
16:04:55 <dfeuer> [Actually, real Haskell, but not the real algorithms in Haskell]
16:04:56 <Marlin> >  take 8 $ show 123 ++ (repeat ' ')
16:04:57 <lambdabot>  "123     "
16:05:08 <MrMetric> What is $?
16:05:15 * hackagebot handsy 0.0.7 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.7 (utdemir)
16:05:15 <MrMetric> You're giving me flashbacks of PHP horror
16:05:15 <ab9rf> > reverse $  take 8 $ (reverse $ show (123::Int) ) ++ (repeat ' ')
16:05:16 <gcganley> :t $
16:05:17 <lambdabot>     parse error on input ‘$’
16:05:17 <lambdabot>     Perhaps you intended to use TemplateHaskell
16:05:17 <lambdabot>  "     123"
16:05:26 <Eduard_Munteanu> @src ($)
16:05:26 <lambdabot> f $ x = f x
16:05:27 <HeladoDeBrownie> MrMetric, just function application. it's used because it has very low precedence.
16:05:44 <Eduard_Munteanu> f $ g x  ==  f (g x)
16:05:46 <HeladoDeBrownie> MrMetric, any use of it can be replaced with regular function application and appropriate paren usage
16:05:47 <ab9rf> i know, using reverse twice is kinda cheaty
16:05:48 <learner> dfeuer, thank you, I'll look into it
16:05:55 <HeladoDeBrownie> *almost* any use of it *
16:06:11 <dfeuer> learner, it is *the* intro to purely functional data structures.
16:06:22 <bitemyapp> ab9rf: hi https://github.com/bitemyapp/learnhaskell
16:06:22 <MrMetric> Why use it over parens?
16:06:31 <gcganley> MrMetric: all ($) is it evaluates everything on the left before giving it to the function on the right. haskell is inheritly 'left-associative' meaning m x y = (m x) y but m $ x y = m (x y). you see?
16:06:34 <HeladoDeBrownie> MrMetric, sometimes it looks nicer, subjectively
16:06:38 <bitemyapp> dfeuer: Okasaki isn't doable for most beginners to Haskell/ML.
16:06:44 <gcganley> MrMetric: it just makes it look cleaner lol
16:06:54 <HeladoDeBrownie> MrMetric, i mostly only use it when i want to apply to an expression that spans multiple lines, like a do block: foo $ do …
16:06:58 <bitemyapp> dfeuer: it is the best introduction to PFDS, but it's better for people already comfortable with Haskell and/or ML.
16:07:01 <MrMetric> Does it help to avoid making your code look like Lisp? ;)
16:07:06 <HeladoDeBrownie> MrMetric, often!
16:07:07 <Eduard_Munteanu> Yep.
16:07:08 <lpaste> Yuras pasted “Hangs with -N1” at http://lpaste.net/119771
16:07:10 <dfeuer> bitemyapp, oh. I appreciated it pretty early, even if not understanding all the math in detail.
16:07:31 <Yuras> ^ wtf?
16:07:39 <Yuras> why this hangs?
16:07:51 <ab9rf> bitemyapp: i just found the choice of handle amusing :)
16:07:53 <mniip> is there any ready to use package for parsing haskell code into an AST?
16:08:00 <gcganley> bitemyapp: I love you
16:08:13 <zwer> > let rjust n xs = replicate (n - length xs) ' ' ++ xs in rjust 8 "hello"
16:08:14 <lambdabot>  "   hello"
16:09:00 <ab9rf> i still like mine better :)
16:09:05 <gcganley> mniip: explain? there are lots of parsing libaries but i dont know what you are trying to do
16:09:23 <ab9rf> @pl \k n  -> reverse $ take k $ (reverse n) ++ (repeat ' ')
16:09:24 <lambdabot> (reverse .) . (. ((++ repeat ' ') . reverse)) . take
16:09:25 <mniip> I'm trying to parse an haskell expression into an AST
16:09:28 <mniip> that's all
16:09:51 <ab9rf> it avoids using length and doing math :)
16:09:56 <mniip> I know there's stuff like Parsec, but that's for generic parsing, I need exactly haskell's syntax
16:10:07 <Eduard_Munteanu> mniip, haskell-src or ghc
16:10:07 <ab9rf> mniip: there's a haskell grammar somewhere in hackage
16:10:14 <gcganley> mniip: maybe haskell-source-exts... not sure if it does parsing
16:10:16 <HeladoDeBrownie> ab9rf, @pl :(
16:10:28 <gcganley> @pl :()
16:10:28 <lambdabot> (line 1, column 1):
16:10:29 <lambdabot> unexpected ":"
16:10:29 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:10:35 <gcganley> @pl ()
16:10:35 <lambdabot> ()
16:10:42 <Marlin> :t ($)
16:10:43 <lambdabot> (a -> b) -> a -> b
16:10:55 <jle`> mniip: there's haskell-src and haskell-src-exts
16:10:56 <ab9rf> HeladoDeBrownie: pointfree is often pointless :)
16:10:59 <jle`> oh already posted
16:11:03 <gcganley> Marlin: where you askng about ($)
16:11:03 <kirill_> mniip: haskell-src-exts has parseExp
16:11:04 <gcganley> ?
16:11:05 <Eduard_Munteanu> mniip, if they're compile-time strings, you can simply use TH quoting
16:11:16 <hae> @pl (.)
16:11:16 <lambdabot> (.)
16:11:19 <HeladoDeBrownie> please play with the bot in a pm
16:11:32 <hae> There's a point there though.
16:11:33 <Marlin> gcganley no, MrMetric was
16:11:36 <hae> Get it?
16:11:48 <gcganley> MrMetric: do you understand currying?
16:11:48 <jle`> heh
16:11:58 <ab9rf> i'd love me some curry about now
16:12:12 <MrMetric> Well, I do feel pretty hungry right now
16:12:16 <gcganley> ab9rf: I've never had it before honestly
16:12:28 <gcganley> MrMetric: so thats a no? lol
16:12:38 <MrMetric> To me, curry is food
16:12:48 <Eduard_Munteanu> Currying food isn't reversible though.
16:12:54 <ab9rf> Eduard_Munteanu: heh
16:13:15 <HeladoDeBrownie> i used curry in a haskell program once
16:13:18 <HeladoDeBrownie> i had to get a new laptop
16:13:21 <hae> @pl uncurry
16:13:21 <lambdabot> uncurry
16:13:30 <gcganley> MrMetric: ok... ummm i could explain it poorly or you could google it and get a much better explanation
16:13:40 <hae> Somehow that makes perfect sense.
16:13:43 <HeladoDeBrownie> gcganley, why did you bring it up?
16:13:43 <ab9rf> Eduard_Munteanu: neither is unwrapping a burrito but people talk about that too
16:13:52 <gcganley> HeladoDeBrownie: I dont remember
16:14:53 <ab9rf> hm, i wonder if i can get a burrito with curry
16:14:54 <codygman> What do you guys think good metrics are for finding open source projects that are collapsing under complexity? I tried searching by most issues, but that's too closely correlated to popularity. I suppose I could try something like most issues/lowest project size/most contributors or something, but I bet someone has better ideas on this.
16:14:56 <HeladoDeBrownie> gcganley, i think the problem with looking it up would be the context of why it's necessary to know at this point would be missing
16:15:23 <gcganley> HeladoDeBrownie: true, i always show people fmap and just show that its lifting a function
16:15:27 <ab9rf> codygman: pretty much any open source project that has actually been released is collapsing under complexity, or will be soon.
16:15:41 <HeladoDeBrownie> ab9rf's law
16:15:49 <MrMetric> This works, but I get the feeling I'm doing it wrong:
16:15:50 <MrMetric> rjust :: Show a => a -> Integer -> String
16:15:51 <MrMetric> rjust thing width = printf ("%" ++ (show width) ++ "s") (show thing)
16:15:54 <zwer> This is how newbies get scared away from haskell. MrMetric wondered about rjust equivalent in haskell; he got a definition that used $; now someone wants to explain to him what currying is
16:16:28 <ab9rf> zwer: nobody has mentioned the dreaded M word yet!
16:16:32 <codygman> ab9rf: Ha, but I'd like to find the ones which struggle to implement bugs that hugely affect user interaction and struggle to even add simple features.
16:16:43 <ab9rf> codygman: that would be virtually all of them :)
16:16:43 <shelf> mm ($) is confusing for beginners
16:16:52 <HeladoDeBrownie> MrMetric, it's a little odd-looking but not necessarily wrong
16:17:06 <HeladoDeBrownie> MrMetric, printf itself is odd in haskell, really :P
16:17:12 <MrMetric> What I mean is I get the feeling there's a better way to do it
16:17:18 <ab9rf> i didn't realize haskell _had_ printf :)
16:17:27 <MrMetric> I had to import Text.Printf to use it :]
16:17:27 <HeladoDeBrownie> you might be right, but for a first attempt at implementing that it's not bad
16:17:30 <hae> Well currying is a pretty basic part of learning the language so you have to learn it sometime.
16:17:47 <codygman> ab9rf: I've been using format: http://hackage.haskell.org/package/formatting-6.2.0/docs/Formatting.html
16:17:48 <HeladoDeBrownie> ah, well, you'll end up importing stuff all the time. possibly even dozens of modules at once for more complex things
16:18:10 <MrMetric> Hey, should I be using Int instead of Integer there?
16:18:10 <kirill_> MrMetric: printf accepts star for variable lengths: "%*s\n" 10 "abc"
16:18:19 <geekosaur> > printf "%*d" 4 3 :: String
16:18:20 <lambdabot>  "   3"
16:18:24 <ab9rf> yeah, the last haskell app i was working on has about 30 imports maybe? and it's a small app
16:18:25 <MrMetric> Neat, thanks
16:18:26 <HeladoDeBrownie> MrMetric, they're different types
16:18:38 <MrMetric> HeladoDeBrownie: I know, that's why I asked
16:18:57 <HeladoDeBrownie> MrMetric, i would call writing Int rather than Integer without a specific reason early optimization
16:19:17 <ab9rf> i almost always use Integer unless i am damn certain that it'll stay within the boundaries of INt
16:19:18 <HeladoDeBrownie> in other words, i'd recommend Integer unless there's a good reason to use Int
16:19:20 <MrMetric> What I mean is, who's going to pad a string with billions of spaces?
16:20:10 <MrMetric> With what kirill_ said, I now have this:
16:20:11 <MrMetric> rjust thing width = printf ("%*s") width (show thing)
16:20:13 <HeladoDeBrownie> MrMetric, you might be surprised what violates your visualized use cases. generality is good, because you can't anticipate everything. i'm having trouble imagining it too, but i don't see any harm in using Integer.
16:20:29 <MrMetric> HeladoDeBrownie: I'll leave it alone, then
16:20:30 <ab9rf> MrMetric: haskell programmers routinely genereate extremely large, often infinite, data structures, then throw most of them away
16:20:42 <MrMetric> I'll also add a check for negative integers
16:20:49 <glguy> We're so wasteful
16:20:49 <hae> Dating a programmer who doesn't know your favorite language (Haskell) is like dating someone outside your fandom. It just doesn't work out.
16:20:59 <ab9rf> MrMetric: in the rjust i wrote, i used an infinite string of spaces as padding
16:21:04 <glguy> We also leave the water running ALL DAY even though we only brush our teeth twice a day
16:21:04 <bananagram> it's easy to waste infinity
16:21:21 <mniip> hae, you wanted a point-free implementation of . ?
16:21:26 <HeladoDeBrownie> glguy, fortunately it's lazily evaluated water
16:21:35 <jle`> let (c,d) = f (b,d) in c
16:21:47 <jle`> hm. in what circumstances (with what f) will that terminate?
16:21:51 <glguy> HeladoDeBrownie: That explains why it stops falling when I move my brushaway
16:22:08 <HeladoDeBrownie> glguy, i would say it just raises more questions :)
16:22:13 <hae> mniip, yes. It's a point.
16:22:18 <mniip> ((<*>) (((<*>) (const (<*>))) (((<*>) (const const)) (((<*>) (const (<*>))) (((<*>) (const const)) id))))) (const (((<*>) (((<*>) (const (<*>))) (((<*>) (const const)) id))) (const id)))
16:22:18 <jle`> b is given
16:22:29 <mniip> not sure if there is a shorter one
16:22:33 <jle`> mniip: there's a dot on top of the i
16:22:35 <HeladoDeBrownie> mniip likes to ski down tall mountains
16:22:36 * ab9rf throws something heavy at mniip 
16:22:42 <jle`> doesn't count
16:22:49 <hae> mniip, you make me cri.
16:23:08 <mniip> ((<*>) (((<*>) (const (<*>))) (((<*>) (const const)) (((<*>) (const (<*>))) (((<*>) (const const)) ((<*>) const (<*>))))))) (const (((<*>) (((<*>) (const (<*>))) (((<*>) (const const)) ((<*>) const (<*>))))) (const ((<*>) const (<*>)))))
16:23:10 <mniip> look ma no I
16:23:19 <HeladoDeBrownie> mniip likes to sk down tall mountains
16:23:21 <gcganley> mniip: what is that...
16:23:26 <mniip> wait no I messed it up
16:23:28 <MrMetric> Hey, it actually works fine with negative integers. I don't need to check for that
16:23:37 <gcganley> mniip: is that SKI shit?
16:23:40 <HeladoDeBrownie> MrMetric, yeah, i suspected printf might do that
16:24:00 <gcganley> :t printf
16:24:01 <lambdabot> PrintfType r => String -> r
16:24:12 <gcganley> :info PrintfType
16:24:13 <mniip> ((<*>) (((<*>) (const (<*>))) (((<*>) (const const)) (((<*>) (const (<*>))) (((<*>) (const const)) ((<*>) const const)))))) (const (((<*>) (((<*>) (const (<*>))) (((<*>) (const const)) ((<*>) const const)))) (const ((<*>) const const))))
16:24:21 <gcganley> oh that doesnt work here...
16:24:22 <jle`> better
16:24:24 <HeladoDeBrownie> mniip, okay we get it, you like to ski :P
16:24:31 <mniip> I hate to I though
16:24:35 <gcganley> :t const
16:24:36 <lambdabot> a -> b -> a
16:25:25 <mniip> gcganley, yes that is ski shit
16:25:46 <jle`> it's actually just k but
16:25:57 <HeladoDeBrownie> s = (<*>)
16:26:07 <gcganley> doesnt i = id
16:26:11 <HeladoDeBrownie> yes
16:26:18 <HeladoDeBrownie> i = skk
16:26:20 <gcganley> and k is const right?
16:26:22 <HeladoDeBrownie> yes
16:26:42 <jle`> there's actually a prefix non-operator form of (<*>) in base
16:27:06 <gcganley> jle`: what is it? apply?
16:27:08 <gcganley> :t apply
16:27:09 <lambdabot> Not in scope: ‘apply’
16:27:23 <HeladoDeBrownie> well there's ap, although i think that has a Monad constraint
16:27:26 <HeladoDeBrownie> @type ap
16:27:27 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:27:45 <mniip> ap is monadic
16:27:47 <mniip> not applicative
16:27:48 <Marlin> MrMetric  there is really no need to use prinf for this.. you already got several definitions of rjust without it
16:27:54 <mniip> (r ->) is a monad but yeah
16:28:06 <HeladoDeBrownie> mniip, sure, but for what it does all you need is Applicative
16:28:11 <HeladoDeBrownie> ap = (<*>)
16:28:25 <mniip> actually no I don't think so
16:28:29 <MrMetric> Marlin: feel free to tell me what they are
16:28:31 <HeladoDeBrownie> Marlin, printf is fine, it's one thing to understand rather than the several involved in those :P
16:28:37 <lachenmayer> can someone explain how S = (<*>)?
16:28:44 <gcganley> :t liftA
16:28:45 <lambdabot> Applicative f => (a -> b) -> f a -> f b
16:28:47 <HeladoDeBrownie> well, maybe not one thing… i guess printf is pretty complex :P
16:28:48 <lachenmayer> the other two are obvious, but Sxyz = xz(yz)?
16:28:50 <Marlin> rjust n xs = replicate (n - length xs) ' ' ++ xs
16:28:51 <gcganley> found it! its liftA
16:29:15 <gcganley> fuck thats fmap...
16:29:23 <ab9rf> are you surprised?
16:29:23 <HeladoDeBrownie> lachenmayer, you can specialize (<*>):
16:29:35 <HeladoDeBrownie> (<*>) :: (e -> a -> b) -> (e -> a) -> (e -> b)
16:29:42 <HeladoDeBrownie> that's f ~ (e ->)
16:30:04 <lachenmayer> ahh, of course. thanks!
16:30:12 <gcganley> HeladoDeBrownie: working with the ((->) e) functor really freaks me out for no reason :(
16:30:16 <hae> What is the minimal set of functions again? Like in System F?
16:30:22 <mniip> instance Applicative ((->) a) where (<*>) f g x = f x (g x)
16:30:30 <mniip> which is more or less the definition of S
16:30:36 <HeladoDeBrownie> hae, you can get away with one, and then you can describe programs with just an unlabeled binary tree :)
16:30:45 <gcganley> :t fix
16:30:46 <lambdabot> (a -> a) -> a
16:30:51 <gcganley> @src fix
16:30:51 <lambdabot> fix f = let x = f x in x
16:31:10 <gcganley> fix id
16:31:14 <gcganley> > fix id
16:31:18 <mniip> that's bottom
16:31:18 <lambdabot>  mueval-core: Time limit exceeded
16:31:24 <gcganley> oh lol
16:31:24 <jle`> mniip: i mean, for the uses of ski
16:31:31 <mniip> yeah maybe
16:31:38 <jle`> ap works for ski the same as (<*>)
16:31:49 <jle`> with the `(->) a` instance
16:32:28 <HeladoDeBrownie> gah, i can't find it. i thought it was linked from the ski page on wikipedia
16:32:30 <raek> I remember when I first read the section on ((->) e) in the Applicative Programming with Effects paper... S and K! why do you guys show up everywhere! :-P
16:32:30 <mniip> > fix $ (1:) . map (2*)
16:32:31 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:32:45 <hae> HeladoDeBrownie, can you write an example?
16:32:57 <mniip> it was
16:33:03 <gcganley> map (2^) [0..]
16:33:07 <mniip> http://en.wikipedia.org/wiki/Iota_and_Jot
16:33:32 <gcganley> > map (2^) [0..]
16:33:33 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:34:03 <raek> then I remembered something from logic class... two of the axioms of the Hilbert system are S and K!
16:34:20 <gcganley> raek: they are kinda prolific
16:34:25 <mniip> U = ($const) . ($(<*>))
16:34:27 <mniip> or something
16:34:57 <HeladoDeBrownie> hae, i don't have the available brain power to actually write a program using iota or jot, but you can read a bit about them on  the page mniip linked
16:35:00 <gcganley> :t (($) const) . (($) (<*>))
16:35:01 <lambdabot> Applicative f => f (a -> b1) -> b -> f a -> f b1
16:35:03 <mniip> I've tried djinn and it can't come up with a cleaner definition of it
16:35:16 <raek> is all of abstract mathematics like this? :-)
16:35:27 <hae> Oh I see.
16:35:27 <HeladoDeBrownie> raek, not at all :P
16:35:28 <mniip> raek, what is the number one
16:35:37 <raek> http://en.wikipedia.org/wiki/Hilbert_system#Logical_axioms
16:35:38 <gcganley> raek: some of it involves bannans. I wish i was kidding
16:35:41 <hae> Reminds me of binary lambda calculus.
16:35:51 <raek> P1 looks like I
16:36:01 <hae> What about cobananas? Any research into those?
16:36:10 <mniip> endobananas?
16:36:24 <gcganley> exobananas
16:36:34 <mniip> monanas
16:36:52 <hae> ^
16:37:03 <HeladoDeBrownie> naturally grown transformations
16:37:22 <bitemyapp> gcganley: <3
16:37:34 <gcganley> bitemyapp: that was delayed lol
16:37:37 <bitemyapp> dfeuer: not just math
16:37:46 <HeladoDeBrownie> gcganley, love waits
16:37:57 <bitemyapp> gcganley: dog was doing a potty dance so intense that I thought we was trying to evoke the rain
16:39:18 <gcganley> where is that paper on bananas? i cant find it
16:40:12 <bitemyapp> gcganley: recursion schemes paper: https://synrc.com/publications/cat/Temp/FP_BananasLenses.pdf
16:40:27 <bitemyapp> alternate link: http://www.eliza.ch/doc/meijer91functional.pdf
16:42:07 <mniip> lol
16:42:15 <mniip> trying to read the type signature of U
16:43:08 <HeladoDeBrownie> mniip, hmm? where?
16:43:31 <mniip> :t \f -> f (<*>) const
16:43:31 <lambdabot> Applicative f => ((f (a -> b) -> f a -> f b) -> (a1 -> b1 -> a1) -> t) -> t
16:43:35 <hae> Did you read that /r/haskell post about DAGs? Seemed to me like that guy went way overboard.
16:43:39 <gcganley> :t (($) const) . (($) (<*>))
16:43:40 <lambdabot> Applicative f => f (a -> b1) -> b -> f a -> f b1
16:43:59 <mniip> wait what
16:44:04 <mniip> why are the two different
16:44:10 <gcganley> mine is wrong
16:44:11 <sdegutis> I think I totally get monads now.
16:44:22 <HeladoDeBrownie> mniip, oh, that's not a type, that's a value
16:44:34 <sdegutis> The problem now is just that, to understand a specific monad, I need to think in types of types, not in types of values.
16:44:35 <MrMetric> How can I print a string without quotation marks?
16:44:40 <sdegutis> And that's hard.
16:44:41 <HeladoDeBrownie> sdegutis, just don't go writing a tutorial about it just yet :)
16:44:44 <sdegutis> haha HeladoDeBrownie
16:44:48 <mniip> MrMetric, putStrLn
16:45:00 <mniip> or without the Ln part
16:45:05 <MrMetric> Oh
16:45:12 <HeladoDeBrownie> sdegutis, types have been important all along even if you didn't recognize it; you need to learn them and be able to work with them
16:45:14 <gcganley> sdegutis: types of types are called kinds. and please dont go and write a tutorial
16:45:17 <MrMetric> Thanks
16:45:25 <sdegutis> gcganley: right
16:45:33 <mniip> are there types of kinds
16:45:40 <gcganley> mniip: not yet
16:45:46 <gcganley> mniip: YET
16:45:46 <sdegutis> Is that a fair assessment of why specific monads are commonly hard to grasp, btw?
16:45:48 <HeladoDeBrownie> i think so, but there's just one
16:45:49 <mniip> probably not because there can't be an inconcrete kind
16:46:07 <sdegutis> "kind of" and "sort of" implies that kinds are also called sorts
16:46:12 <sdegutis> well, sort of
16:46:54 <HeladoDeBrownie> value :: type :: kind :: sort :: ???
16:46:57 <gcganley> sdegutis: monad transformers deal with kind but monads deal with types lol
16:47:03 <mniip> let's call types of kinds sorts
16:47:04 <sdegutis> Ooooh.
16:47:15 <mniip> and sort of every kind is...
16:47:23 <HeladoDeBrownie> gcganley, sdegutis, sounds a bit misleading to me. they both deal with both, in some sense
16:47:26 <mniip> let's say...
16:47:29 <mniip> .
16:47:34 <sdegutis> class?
16:47:36 <sdegutis> category?
16:47:39 <sdegutis> genus?
16:47:46 <HeladoDeBrownie> sdegutis, class and category are taken :P
16:48:02 <exio4> HeladoDeBrownie: value :: type :: kind :: sort :: value' :: type' :: kind' :: sort' :: value'' :: type'' :: kind'' :: ...
16:48:09 <exio4> just keep adding '!
16:48:12 <HeladoDeBrownie> exio4, :P
16:48:16 <sdegutis> sort, type, variety, style, form, class, category, genre; genus, species, race, breed; flavor
16:48:24 <ab9rf> flavor, i like that
16:48:25 <sdegutis> character, nature, essence, quality, disposition, makeup; type, style, stamp, manner, description, mold, cast, temperament, ilk, stripe.
16:48:32 <ab9rf> ilk is good
16:48:35 <HeladoDeBrownie> x :: RockyRoad
16:48:36 <sdegutis> Just copying the proprietary thesaurus for "kind"
16:48:39 <sdegutis> LOOK, YOU
16:48:40 <hae> Why don't we just define a "category" for kinds/types that works for anything, even itself?
16:48:48 <sdegutis> hae: what is this, Ruby?
16:48:50 <HeladoDeBrownie> hae, WELL ACTUALLY
16:48:54 <HeladoDeBrownie> hae, try agda
16:49:00 <ab9rf> hae: russell's paradox
16:49:03 <mniip> so wait
16:49:04 <HeladoDeBrownie> or idris
16:49:06 <mniip> if there are typeclasses
16:49:21 <sdegutis> When should I use fmap vs liftM ?
16:49:23 <mniip> where are the typephyla
16:49:37 <mniip> no wiat
16:49:39 <mniip> kindphyla
16:49:51 <HeladoDeBrownie> sdegutis, generally, use fmap. there are only a few circumstances you should use liftM
16:49:58 <sdegutis> HeladoDeBrownie: oh
16:50:15 <homovitruvius> anybody familiar with hflags? in all my trials, it looks like the last flag definition is not having effect. For instance in the first example https://hackage.haskell.org/package/hflags-0.4/docs/HFlags.html the second flag is not usable unless one adds a third one.
16:50:16 <sdegutis> How do you know when your API should use monads or not?
16:50:17 <HeladoDeBrownie> sdegutis, a semi-common one: you have written a Monad instance, and want to write a Functor instance in terms of it. set fmap = liftM. that's perfectly fine
16:50:23 <sdegutis> i.e. when designing a new API
16:50:28 <hae> I mean really how many type levels do you need? At some point we'll need a type system for the type system!
16:50:49 <HeladoDeBrownie> sdegutis, i guess, if you need to compose things in a specific way, the way monads compose. kind of a really general question
16:50:55 <ab9rf> hae: and then a type system for the type system of the type system
16:51:00 <ab9rf> hae: and before long it's turtles all the way down
16:51:17 <HeladoDeBrownie> hae, at least idris has a system of types parameterized on natural numbers, so it's really like value :: type 0 :: type 1 :: type 2 :: …
16:51:17 <mniip> so we have an infinite number of type system orders
16:51:19 <sdegutis> I know Haskell perfectly, yet I feel I have no idea how to use it.
16:51:21 <mniip> that needs a typesystem
16:51:26 <ab9rf> sdegutis: you should use the least restrictive typeclass that provides what you need
16:51:35 <mniip> also known as aleph-aleph-null
16:51:44 <HeladoDeBrownie> sdegutis, i would re-examine the first half of that sentence then
16:52:01 <ab9rf> sdegutis: i barelyt know haskell at all, yet i manage to use it just fine :)
16:52:04 <sdegutis> Ha.
16:52:09 <hae> Let's just finish Dependent Haskell already so we can get on with our lives.
16:52:13 <mniip> sdegutis, man I've been doing haskell for a year and I am certain I know shit about haskell
16:52:18 <sdegutis> ab9rf: least restrictive in what way?
16:52:22 <sdegutis> mniip: oh I remember you from #lua
16:52:28 <mniip> OH REALLY?
16:52:33 <mniip> no way
16:52:34 <ab9rf> sdegutis: you would ask that :)
16:52:58 <hae> ^ sdegutis, just now remembered about Ruby XD
16:53:11 <ab9rf> sdegutis: if you're writing code that only needs the requirements of, say, Functor, don't force it to use Monad because that's more restrictive
16:53:19 <MrMetric> I tried to read someone's Perl script once
16:53:25 * HeladoDeBrownie is slightly giddy about AMP going through soon
16:53:26 <hae> Reading Learn You A Ruby... I'm getting psychedelic flashbacks.
16:53:32 <gcganley> sdegutis: dont take a mile when you only need an inch
16:53:32 <mniip> I tried to read my perl script once
16:53:55 <MrMetric> Hue?
16:54:02 <ab9rf> sdegutis: if you're defining a type and that type follows MOnad rules, yhou should make it a Monad instance, rather than just a Functor instance, because that means it will piggyback onto more stuff already there and be more useful generally
16:54:06 <mniip> gave up separating the third token
16:54:25 <ab9rf> MrMetric: i find perl far more readable than, say, php.  php makes my eyes bleed.
16:54:26 <hae> HeladoDeBrownie, zero isn't a natural number.
16:54:44 * geekosaur would rather dissect someone else's Perl script than someone else's C program
16:54:55 <ab9rf> geekosaur: or worse C++
16:54:55 <Axman6> sure it is
16:55:04 <MrMetric> ab9rf: I refuse to use PHP, but it's more readable to me than Perl. Maybe I just got a bad first impression
16:55:05 <geekosaur> (...so naturally, my day job involves quite a lot of the latter :/ )
16:55:27 <jle`> hae: it depends on the domain ;)
16:55:32 <sdegutis> mniip: yes way
16:55:33 <jle`> the definition
16:55:36 <mniip> I see none of you have ever seen APL programs?
16:55:39 <HeladoDeBrownie> hae, well, fortunately it doesn't matter here, so just assume by 0 i mean "the first natural number" and by each successive number, the natural after that.
16:55:40 <ab9rf> well, iu've been using perl since 1990, while i've never written any significant amoutn of PHP
16:55:43 <jle`> different fields use different definitions
16:55:51 <ab9rf> mniip: APL was like my fourth language.  i love APL.
16:55:57 <ab9rf> mniip: such a bizarre little language.
16:56:04 <MrMetric> Admittedly, the first and only Perl script I've read is in German and is poorly-made
16:56:05 <sdegutis> are Functors often used instead of Monads?
16:56:15 <sdegutis> I totally get Functors way easily.
16:56:16 <MrMetric> Tons of unused and longer-than-it-needs-to-be code
16:56:18 <HeladoDeBrownie> sdegutis, there are several things that satsify Functor but not Monad
16:56:27 <hae> Well if you want the natural numbers to form a monoid with addition you need zero, admittedly.
16:56:27 <HeladoDeBrownie> sdegutis, e.g., data Const a b = Const a
16:56:30 <Axman6> sdegutis: they serve different purposes, and more things are Functors than are Monads
16:56:31 <ab9rf> sdegutis: Functor is a weaker commitment than Monad
16:56:38 <sdegutis> Oh.
16:56:49 <Axman6> Functor => Applicative => Monad
16:56:49 <sdegutis> HeladoDeBrownie: uhhh what is that
16:56:50 <jle`> sdegutis: it's not really "instead"
16:56:54 <sdegutis> jle`: oh
16:56:57 <zipper> While trying to install cabal by compiling from source it has generated a library and not an executable.
16:57:03 <HeladoDeBrownie> sdegutis, it's a rather simple type. it has a Functor instance. exercise: write it
16:57:04 <sdegutis> So in 7.10, all Monads will have to be Functors?
16:57:08 <jle`> that's like saying, are iterators used instead of containers?
16:57:11 <ab9rf> if something is a Monad, it's also an Applicative and a Functor (and severeal other things too)
16:57:14 <zipper> In this case what can I do to run cabal or add it in my PATH?
16:57:18 <jle`> different interfaces have different purposes/uses :)
16:57:24 <sdegutis> I really do feel like Haskell is too hard for me.
16:57:27 <zipper> Since I have no ~/.bin
16:57:29 <mniip> MrMetric, perl is supposed to be concise
16:57:37 <sdegutis> But I'll try writing a website in it.
16:57:37 <hae> I wonder if there are such things as mutually incompatible typeclasses. Can't you make instances for all of them?
16:57:37 <mniip> {s;.*;++($==$&);e;(!((eval join q;+;,split m;;)%3)&&print"Fizz")+(m;([02468]|^)[048]$|[13579][26]$;&&print"Buzz")||print;print$/;m;100;||redo}
16:57:38 <jle`> sdegutis: nah :)
16:57:41 <Axman6> sdegutis: all monads are functors (but currently not all Monads are Functors in Haskell)
16:57:44 <zipper> Or how could I tell it to compile to an executable and not a library?
16:57:46 <ab9rf> yeah, actually i think techmnically Functor => Applicative => Monad isn't official yet
16:57:51 <HeladoDeBrownie> sdegutis, it does take patience, but i think you can do it. you're here, and that's a good step :)
16:57:51 <ab9rf> but it should be :)
16:57:53 <jle`> writing a website might be a tricky first project in haskell
16:57:54 <MrMetric> mniip: Please no
16:57:56 <Rotaerk> hmm, is it valid to call it fold if the accumulator doesn't account for all previously traversed elements?
16:57:58 <sdegutis> jle`: why?
16:58:02 <mniip> *laughs maniacally*
16:58:06 <sdegutis> mniip: har har
16:58:12 <jle`> it's a lot of concepts all at once
16:58:19 <jle`> easy to get discouraged
16:58:25 <ab9rf> if you make something a Monad instance, yuou should make it a Functor instance (or an Applicative instance) as well just for completeness.
16:58:31 <Rotaerk> I would like to define something foldy but where I fold each *path* of a tree
16:58:34 <jle`> it's like those people who go to learn programming and their first project is an MMORPG
16:58:51 <ab9rf> jle`: everyone knows the first project is supposed to be an IRC client.
16:58:55 <Rotaerk> and the accumulator for a node of the tree only accounts for that node's ancestors
16:58:57 <HeladoDeBrownie> i had ambitions of mmos when i was first learning my first language, c++
16:59:04 <hexagoxel> zipper: which package did you try exactly?
16:59:05 <mac10688> Is haskell capable of reading memory streams?
16:59:06 <jle`> it's not an uncommon dream actaully
16:59:13 <ab9rf> mac10688: what's a memory stream?
16:59:22 <mac10688> like ram memory
16:59:24 <HeladoDeBrownie> long story short: i ended up hating it, moved on and never touched c++ again
16:59:27 <MrMetric> mniip: Is that FizzBuzz?
16:59:29 <mac10688> memory addresses I should say
16:59:37 <mniip> yes
16:59:39 <ab9rf> mac10688: there are ways to directly access memory in haskell, yes
16:59:50 <ab9rf> mac10688: what are you trying to do?
16:59:56 <mac10688> anyone know where I can find that documentation?
16:59:59 <jmcarthur> mac10688: do you mean you literally want to access raw memory or do you mean you just want to be able to allocate a simple buffer of bytes and use it?
17:00:01 <MrMetric> mniip: https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
17:00:01 <mac10688> Create a bot for a game :)
17:00:07 <mniip> MrMetric, seen tht
17:00:09 <zipper> hexagoxel: I installed cabal from source as explained here https://wiki.haskell.org/Cabal-Install 2.2 unix
17:00:11 <MrMetric> :]
17:00:12 <mac10688> I want to access raw memory
17:00:12 <Axman6> mac10688: Haskell has a Ptr type which allows you to work with memory addresses, but afaik you can't (without using the FFI) read a specified address
17:00:25 <sdegutis> jle`: I've written a website in Clojure, and the equivalent Haskell libraries look extremely similar.
17:00:27 <jmcarthur> mac10688: why do you need to access raw memory to write a bot?
17:00:31 <sdegutis> Axman6!!!
17:00:31 <Axman6> mac10688: you probably want to use the FFI. why do you need to access raw memory?
17:00:37 <zipper> hexagoxel: So cabal install
17:00:37 <mac10688> what is FFI?
17:00:38 <sdegutis> Axman6: I remember you from *years* ago!
17:00:39 <Axman6> yes?
17:00:46 <mac10688> so I can read the values stored in memory
17:00:46 <Axman6> where from?
17:00:47 <jle`> sdegutis: that's the thing, you know?  it's deceptive like that
17:00:50 <geekosaur> foreign function interface
17:00:55 <mac10688> like a character's health or something
17:00:58 <jmcarthur> mac10688: that is a pretty non-specific answer
17:01:01 <mac10688> thanks geekosaur
17:01:03 <sdegutis> Axman6: I dunno, some channel in IRC...
17:01:05 <jle`> a lot of haskell things look familiar but end up working very differently than you'd think when you approach them in a real project
17:01:06 <sdegutis> Axman6: Maybe #macdev?
17:01:07 <jmcarthur> mac10688: why not just use normal haskell data types?
17:01:09 <Marlin> sdegutis haskell has a steeper initial learning curve than most other languages.. but once you're past it it is a very productive language
17:01:22 <Axman6> possibly. #macosxdev perhaps? Or just #macosx?
17:01:27 <ab9rf> mac10688: you want a haskell program to do memhacking?  in-process or cross-process?
17:01:42 <jmcarthur> oh, i see. you're wanting to hijack a game's memory or somesuch
17:01:52 <mac10688> More specifically, I want to write a program that interops with ffxiv. So when I log into the game, I can read values
17:01:53 <mac10688> yeah
17:01:54 <jle`> in haskell you have a lot of chances to accidentally bring your intuition from other languages like clojure etc. into your writing
17:01:57 <jmcarthur> sounds difficult, but it's doable
17:02:00 <jle`> and that's when you really run into trouble
17:02:01 <sdegutis> Marlin: I feel like I'm at that point where I understand all of Haskell in theory, and am comfortable doing everything except creating my own Monads.
17:02:03 <ab9rf> mac10688: it'll be really hrd to make haskell work as an in-process memhack program because of haskell's garbage collector
17:02:05 <geekosaur> and, while related to the FFI, intPtrToPtr gives you a random Ptr
17:02:08 <pacak> Is it possible to make function declaration using TH quotations? Obvious
17:02:09 <pacak> runQ [d| inc x = x + 1|]
17:02:09 <pacak> leads to stuff like
17:02:09 <pacak> [FunD inc_6 [Clause [VarP x_7] (NormalB (SigE (InfixE (Just (VarE x_7)) (VarE GHC.Num.+) (Just (LitE (IntegerL 1))))[]]]
17:02:09 <pacak> which kind of works, but function name is invalid. All my attemps to set specific function name failed.
17:02:12 <sdegutis> Marlin: so I dunno how to get started with that
17:02:13 <geekosaur> without diving into C
17:02:16 <jle`> sdegutis: why would yo want to create your own monad?
17:02:26 <ab9rf> mac10688: it is almost guaranteed to interact badly with the heap manager of the other app with whom it's sharing memory
17:02:30 <sdegutis> jle`: because I thought a Lua virtual machine would be easier to use as a Monad.
17:02:41 <mac10688> oh thanks ab9rf
17:02:44 <hexagoxel> zipper: you said you have no ~/.bin, but what about ~/.cabal/bin ?
17:03:01 <mac10688> I guess I still haven't found a good use case for functional programming yet :(
17:03:08 <jmcarthur> mac10688: i think i'd be more inclined to do the memory hacking in C and perhaps use some protocol to communicate with an external haskell process. at least it seems like that would be easier
17:03:09 <zipper> hexagoxel: I meant I have no ~/.cabal/bin
17:03:13 <jle`> sdegutis: so, you want to build a dsl?
17:03:21 <zipper> hexagoxel: It compiled to a library not an executable.
17:03:24 <ab9rf> mac10688: if you want to do cross-process memory hacking, there's probably a way to do this but i don't know if anyone has written a FFI for the ptrace libs or however you do that
17:03:26 <jle`> which can be interpreted into instructions to a lua vm?
17:03:29 <zipper> hexagoxel: There is no binary called cabal here.
17:04:25 <jle`> "writing a monad" might not really be a good goal in and of itself.  that's like saying that you want to store data and you want to "write an iterator"
17:04:44 <jle`> monad is really just a high level interface
17:04:47 <ab9rf> mac10688: i work on dfhack (dwarf fortress memhacking thingy) and we run in-process by hijacking the SDL library, and it would be a Real Challenge to write a dfhack plugin in haskell, partially beasse of the garbage collector, but also because GHC can't compile to a DLL
17:04:49 <jle`> it doesn't make your thing work
17:04:58 <jle`> an iterator interface on C++ is just a high level interface
17:05:01 <jle`> it doesn't make a vector work
17:05:07 <MrMetric> What if you were hired to write Minecraft in Haskell?
17:05:16 <jle`> write the actual type, then --- if a monad is a nice interface for it --- write the Monad instance
17:05:23 <jle`> at that point, it'll be simple :)
17:05:27 <jle`> if your type works
17:05:57 <hexagoxel> zipper: hmm let me try
17:06:22 <jle`> write your actual type and an API for working with that type and its operations, that is
17:06:29 <jle`> at that point it's already useful
17:06:31 <ab9rf> mac10688: if you're doing out-of-process memhacking, though, that you could do with haskell, although it would be tedious.  it's tedious in any lanbguage, though.
17:06:48 <jle`> and being able to write a Monad instance for it will, incidentally, make it slightly more useful, because you can use functions defined for generic monads
17:07:06 <jle`> but giving something a Monad instance first and foremost doesn't make it magically work
17:07:10 <ab9rf> maneric gonads
17:08:29 <jle`> which is why saying that one wants to "write a monad" seems a little questionable.  focus on making a type that does what you want, first.  if it happens to admit a monad instance, and you realize that after you make it work, then cool :)
17:10:28 <zipper> hexagoxel: I think that wiki article points to the wrong source file.
17:10:28 <mac10688> thanks for the assistance ab9rf and jmcarthur
17:10:35 <zipper> hexagoxel: Source files
17:11:41 <hexagoxel> zipper: are you sure you downloaded the cabal-install and not the Cabal tarball?
17:11:57 <hexagoxel> also, that bootstrap takes ages :D
17:12:03 <zipper> hexagoxel: I believe I downloaded the cabal tarball
17:12:23 <hexagoxel> well, Cabal is the library :D
17:12:33 <hexagoxel> cabal-install the executable
17:12:38 <zipper> hexagoxel: I see that now :(
17:13:16 <sdegutis> jle`: yes
17:13:20 <sdegutis> jle`: EDSL
17:13:24 <sdegutis> haaalp
17:13:38 <sdegutis> mniip: im suprized ur not in #haskell-blah
17:14:17 <mniip> what's that even
17:15:01 <jle`> sdegutis: what sort of edsl are you writing?
17:15:25 <sdegutis> jle`: an interface to Lua
17:15:36 <sdegutis> mniip: general discussion channel for haskellers
17:15:42 <sdegutis> mniip: kind of like #lua is for Lua
17:15:47 <mniip> well I have about enough channels
17:15:58 <sdegutis> do as you see fit, young person
17:15:59 <mniip> oh
17:16:02 <mniip> like haskell circlejerk?
17:16:02 <sdegutis> I'm way older than you.
17:16:05 <sdegutis> mniip: no
17:16:56 <ab9rf> be careful about assuming ages on this channel :)
17:17:07 <mniip> ab9rf, oh he knows my age very well
17:17:19 <mniip> I try to keep my channel list small enough to fit in one vertical screen
17:17:24 <ab9rf> just saying :)
17:17:39 <ab9rf> this is one of the places on freenode where being over 30 isn't unusual
17:18:12 <hexagoxel> zipper: with cabal-install, bootstrap will tell you where it puts the executable, once it finishes (which took like 10min..)
17:18:14 <mniip> hah
17:18:19 <mniip> I'm far from being over 30
17:18:44 <MrMetric> Did someone say circlejerk?
17:18:59 <zipper> hexagoxel: Well it seems I'll need the cabal library to install cabal-install.
17:19:01 <MrMetric> I'll have you know I'm friends with Dan K. Meme, PhD
17:19:12 <benzrf> MrMetric: ( ͡° ͜ʖ ͡°)
17:19:16 <benzrf> MrMetric: This is bullshit - you're oversimplifying a complex situation to the point of no longer adding anything useful to the discussion.
17:19:30 <MrMetric> benzrf: Get jackdaw'd
17:19:35 <mniip^> pls
17:19:50 <benzrf> MrMetric: I'd just like to interject for a moment
17:20:10 <benzrf> MrMetric: What you're referring to as jackdaw is in fact crow, or as i've recently taken to calling it, unidan
17:20:16 <hexagoxel> zipper: which will be installed automatically with the bootstrap script. or does it not, for you?
17:20:29 * mniip^ points at hostname
17:20:55 <benzrf> MrMetric: http://blazeti.me/
17:21:04 <MrMetric> benzrf: https://niceme.me/
17:21:18 <zipper> hexagoxel: It doesn't
17:21:23 <benzrf> MrMetric: im a creative consultant for http://blazeti.me/ =)
17:21:33 <zipper> hexagoxel: It claims to not find Distribution.Simple
17:22:07 <zipper> hexagoxel: So I'm compiling Cabal library and I will install it into ~/.cabal then try building cabal-install
17:22:16 <zipper> hexagoxel: via bootstrap.sh
17:22:16 <kevin1024> Hi!  Is there any way I can tell what all the superclasses of a type are in ghci?
17:22:37 <benzrf> kevin1024: do you mean superclasses of a class?
17:22:40 <kevin1024> yeah
17:23:44 <benzrf> kevin1024: i think :i tells you
17:24:25 <kevin1024> :i seems to tell me everything that belongs to a class, but I want to know the opposite.
17:25:46 <kevin1024> Maybe it is telling me that....
17:27:17 <benzrf> Prelude Control.Applicative> :i Applicative
17:27:17 <benzrf> class Functor f => Applicative (f :: * -> *) where
17:27:23 <benzrf> that looks like listing superclasses to me
17:27:34 <EvanR> can i just foreign import a variadic function two with the two signatures it supports
17:27:36 <kevin1024> Yup I think you're right.  I'm just confused :)
17:27:51 <EvanR> import it twice*
17:30:00 <EvanR> hmm
17:33:12 <yac> What are your mbti types?
17:33:50 <yac> .. wondering if there is some correlation between haskell and mbti
17:33:52 <benzrf> yac: thats off topic
17:33:59 <benzrf> yac: take it to -blah
17:34:08 <yac> ah, thanks
17:36:16 <kuribas> What's a good FP language for the java vm?  So far I found scala, clojure and kawa.  Scala seems the most haskell like...
17:38:28 <rasen> kuribas: I've heard of frege
17:38:49 <rasen> Never tried it myself though
17:39:42 <EvanR> frege is the most haskell like, scala isn't haskell like at all
17:41:01 <kuribas> thanks, I hadn't heard of frege.
17:41:38 <kuribas> scala has no algebraic types?
17:42:46 <rasen> kuribas: scala is OO
17:43:02 <sgronblo> you can approximate adts in scala
17:43:35 <rasen> That's what I mean. You can build your own
17:44:08 <sgronblo> frege definitely must be considered the most haskell like, but it also has like 1000 (add more zeroes as necessary) times less adoption than scala
17:47:32 <kuribas> frege seems to be very recent...
17:48:12 <rasen> anyway, that won't change with time. scale will be more popular
17:48:17 <rasen> scala*
17:51:02 <kuribas> Scala looks like a slightly better java, but not a great language.
17:51:29 <rasen> It's enough for most people
17:52:18 <kuribas> I'll probably go with kawa then...
17:53:05 <dino-> Does anyone know offhand if it's possible to make cabal install make do with very little ram than it normally wants? I'm trying to build something on something kind of small.
17:53:06 <rasen> In reality, scala is not slightly better, it's whole lot better
17:53:35 <dino-> I can only get it maybe 500M but it really wants more like 2G
17:54:15 <rasen> dino-: do you really have to build on that small thing? Can you cross-build?
17:54:24 <dino-> rasen: I will probably have to do that, yeah
17:54:51 <HeladoDeBrownie> dino-, using more swap may be another option, though it will be slow
17:55:03 <kuribas> rasen: yeah, java is pretty awful.
17:55:30 <benzrf> kevin1024: its not awful
17:55:33 <benzrf> * kuribas
17:55:35 <benzrf> it just fails to be good
17:56:06 <rasen> dino-: are you sure it's cabal who eats all memory, not ghc?
17:56:15 <dino-> btw, I've used Scala for real work-work for several years. It's ok. I'm very glad it's not Java. But there area a lot of warts.
17:56:32 <HeladoDeBrownie> java actually has some good ideas in it. overall, we must move past it at some point. similar can be said of haskell, one difference being haskell is more willing to make breaking changes. this is a good thing from some perspectives and bad from others.
17:56:37 <darthdeus_> hey guys, is anyone here using persistent with mysql? I'm just totally unable to put together anything with the withMySQLConn (https://hackage.haskell.org/package/persistent-mysql-2.1.2.1/docs/Database-Persist-MySQL.html)
17:56:40 <Marlin> is there a nicer way of writing this?
17:56:43 <Marlin> (\c -> isUpper c == False && isLower c == False)
17:56:44 <darthdeus_> it seems that the types just don't align at all
17:57:08 <dino-> rasen: Not exactly sure, but cabal does say things like "cabal: out of memory (requested 1048576 bytes)" when it quits.
17:57:29 <jle`> Marlin: `liftA2 (&&) isUpper isLower` i guess.  or and . sequence [isUpper, isLower]
17:57:36 <HeladoDeBrownie> Marlin, well one step would be to use not instead of comparing with False. (\c -> not (isUpper c) && not (isLower c))
17:57:50 <HeladoDeBrownie> Marlin, next, we can factor out not. not . (\c -> isUpper c || isLower c)
17:58:02 <rasen> de morgan
17:58:02 <jle`> ah yeah, of course, (== False) is always *slightly* silly :)
17:58:08 <HeladoDeBrownie> and then there was a certain function, i forget what it was called
17:58:11 <HeladoDeBrownie> @type (&&&)
17:58:12 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
17:58:13 <Marlin> I know I have no idea why I used it
17:58:21 <HeladoDeBrownie> hmm, not that one, lemme look it up
17:58:26 <jle`> i've used (== True) on more than one occasion :)
17:58:34 <Marlin> so that would be liftA2 (||) isUpper isLower, yes?
17:58:41 <dino-> Thank you all. I just need to build on a real machine is the thing.
17:58:44 <jle`> yes that'd work
17:58:51 <HeladoDeBrownie> Marlin, well there you go
17:58:51 <jle`> also
17:59:00 <jle`> > let f = or . sequence [isUpper, isLower] in f 'a'
17:59:01 <lambdabot>  True
17:59:07 <HeladoDeBrownie> @type not . liftA2 (||) isUpper isLower
17:59:08 <lambdabot> Char -> Bool
17:59:10 <jle`> then you can do an arbitrary amount of things
17:59:14 <HeladoDeBrownie> seems to check out
17:59:31 <kuribas> benzrf: nah, it's awful...  I think c# is a much better language.  Java is overly verbose, has no higher order functions.  Convoluted classes.
17:59:38 <jle`> > let f = not . or . sequence [isUpper, isLower, isLetter, isAlpha] in f 'a'
17:59:39 <lambdabot>  False
18:00:03 <benzrf> kuribas: yeah
18:00:08 <benzrf> kuribas: none of those are positively /bad/
18:00:13 <benzrf> kuribas: they just. lack good
18:00:18 <benzrf> kuribas: java is 0, not negative
18:00:31 <zwer> kuribas java 8 has higher order functions.. it even has lambda since version 8 ;)
18:00:35 <hiptobecubic> kuribas, doesn't java8 have them now?
18:00:41 <rasen> zwer: it's not functions
18:00:49 <hiptobecubic> now we just have to wait 10 years for enterprise to migrate
18:01:14 <zwer> rasen what are they, classes?
18:01:26 <rasen> java's lambda is just a fancy way to create anonymous classes
18:01:26 <zwer> callable classes, or whatever is the proper term for them
18:01:42 <kuribas> benzrf: The good thing is that java introduced garbage collection to the mainstream.
18:03:21 <kuribas> The claim was that java would be a good cross-platform language.
18:03:33 <kuribas> But C already is cross-platform.
18:03:51 <zwer> rasen by the way isn't the same true for C#? C# does not have stand-alone functions, only methods
18:03:52 <rasen> just different levels of cross-platformness
18:04:03 <rasen> zwer: actually, yes
18:04:25 <rasen> zwer: but having first-class methods is slightly better than not having them
18:05:48 <rasen> zwer: but methods and function is the same stuff
18:06:42 <rasen> zwer: in C++ methods are called member functions
18:08:14 <Marlin> wait, you can't pass a function/method to a function in java?
18:08:23 <rasen> Marlin: nope
18:08:39 <rasen> Marlin: you can pass an object that has method you'll call
18:10:00 <rasen> Java 8's labmdas is a syntatic sugar to instantiate classes that has one abstract method. So the body of lambda goes as body of that method
18:11:05 <Marlin> how do you make a lambda call?
18:11:39 <rasen> you can't call lambda directly. It's object.
18:11:46 <rasen> You can invoke it's method
18:12:03 <Marlin> how? just curious about the syntax
18:12:05 <rasen> If your lambda is Runnable, it'll be run
18:13:20 <rasen> Runnable r = () -> System.out.println("Hello"); r.run();
18:17:26 <Marlin> thanks.. a bit weird but I guess you get used to it :)
18:19:36 <rasen> Indeed java programmers does that long before. With a slightly more verbose syntax
18:19:46 <hiptobecubic> So is it normal to just have most of your program in RWST ?
18:19:48 <rasen> So lambdas go as shortcut
18:20:27 <benzrf> Runnble r = new Runnable(){void run(){System.out.println("Hello");}}; r.run()
18:20:32 <benzrf> "slightly" more verboes
18:20:57 <exio4> it's just syntax that the IDE can add anyway
18:21:02 <rasen> benzrf: you forgot public
18:21:02 <exio4> let eclipse do its job!
18:21:21 <hiptobecubic> I want to be able to log when things happen, but it seems ugly to make the entire program a stack of monad transformers
18:22:24 <rasen> exio4: it's ok to generate it, but eventually you should read it
18:23:42 <exio4> rasen: it's a bit of uh, 'sarcasm', as most of the 'blog posts' I read about Java's "good things" are half about "this class is boilerplate, but can be generated by the IDE" ;P
18:24:40 <rasen> oh.. didn't get it
18:27:06 <Marlin> is there a function like this?
18:27:16 <benzrf> Marlin: like hat
18:27:17 <benzrf> *what
18:27:28 <Marlin> :t (\f x -> f x >> return x)
18:27:29 <lambdabot> Monad m => (b -> m a) -> b -> m b
18:27:31 <aRISCfan> Anyone recommend an article or paper on how Haskell performs when written procedural?
18:27:57 <Marlin> I am not sure how to call it if there isn't
18:28:07 <benzrf> Marlin: ah yes, THAT function
18:28:24 <benzrf> Marlin: not that i know of ;-;
18:28:32 <benzrf> tho i have desired it
18:28:46 <benzrf> FYI (>> return x) = (x $>)
18:28:49 <benzrf> :t ($>)
18:28:50 <lambdabot>     Not in scope: ‘$>’
18:28:50 <lambdabot>     Perhaps you meant one of these:
18:28:50 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
18:28:53 <benzrf> wer
18:28:58 <benzrf> :t (<$)
18:28:59 <lambdabot> Functor f => a -> f b -> f a
18:29:01 <benzrf> ^that, i mean
18:30:21 * hackagebot monad-levels 0.1.0.0 - Specific levels of monad transformers  http://hackage.haskell.org/package/monad-levels-0.1.0.0 (IvanMiljenovic)
18:30:38 <rasen> (<$) = fmap . const ?
18:30:52 <rasen> @src (<$)
18:30:52 <lambdabot> (<$) = (<$>) . const
18:30:57 <rasen> yep
18:31:34 <Marlin> benzrf cool. is there no flip version?
18:31:46 <benzrf> Marlin: of what, sorry?
18:31:52 <Marlin> <$
18:31:55 <rasen> of (<$)
18:32:05 <exio4> heh, I'd guess you can make a shiny looking point-free version or so
18:32:17 <exio4> @type (<*>) (<$)
18:32:17 <lambdabot> Functor f => (a -> f b) -> a -> f a
18:32:43 <Marlin> exio4 :)
18:32:46 <exio4> woah, I got the types right
18:33:13 <Marlin> how would you call that function? no good name comes to mind
18:33:58 <rasen> applyThenReturn
18:34:36 <rasen> f `applyThenReturn` x
18:34:45 <jle`> > 4 <$ Just "hello"
18:34:46 <lambdabot>  Just 4
18:35:09 <MrMetric> Is there something special about Z? When I try to use it as a function argument name, ghc says: Not in scope: data constructor `Z'
18:35:09 <jle`> oh, hm
18:35:32 <Marlin> good name, maybe I will just shorten it a bit
18:35:34 <jle`> MrMetric: identifiers that begin with capital letters are considered to be constructors in this case
18:35:45 <MrMetric> :[
18:35:47 <jle`> ie, f (Just x) = x
18:35:50 <rasen> > 5 <$ [1,2,3]
18:35:51 <lambdabot>  [5,5,5]
18:35:53 <jle`> f Nothing = 5
18:35:57 <jle`> > let f Nothing = 5 in f 100
18:35:58 <lambdabot>  Could not deduce (GHC.Num.Num (Data.Maybe.Maybe t0))
18:35:59 <lambdabot>    arising from the literal ‘100’
18:35:59 <lambdabot>  from the context (GHC.Num.Num a)
18:35:59 <jle`> er
18:36:02 <jle`> > let f Nothing = 5 in f Nothing
18:36:03 <lambdabot>  5
18:36:18 <jle`> the compiler needs to be able to know what is a constructor, and what isn't :)
18:36:27 <jle`> the convention is capital letters = constructor
18:37:05 <rasen> Marlin: f `atr` x ;)
18:37:18 <jle`> MrMetric: `x <$ f x` is probably as clean and readable as it'll get :)
18:37:44 <MrMetric> jlebacktick: wut
18:37:51 <jle`> oh sorry, Marlin
18:37:53 <jle`> heh
18:38:15 <jle`> i am a littel tab-happy today
18:38:48 <Marlin> I am confused how is this is doable with functor, when there is no return/pure?
18:39:11 <Axman6> fmap (const x)?
18:39:30 <jle`> > fmap (\_ -> 5) [1..10]
18:39:31 <lambdabot>  [5,5,5,5,5,5,5,5,5,5]
18:39:45 <jle`> > fmap (\_ -> 5) (Just 10)
18:39:47 <lambdabot>  Just 5
18:39:51 <rasen> not really return, but close to it (in some cases)
18:40:02 * Marlin blinks
18:40:23 <MrMetric> How can I define a function that takes 2 Complex arguments and returns a Complex?
18:40:29 <rasen> stop. Does it behave as original function?
18:40:38 <jle`> Marlin: what do you want the function to do?
18:40:44 <MrMetric> If I use Complex -> Complex -> Complex, ghc says Expecting one more argument to `Complex'
18:40:56 <jle`> ah because Complex is not a type of a complex number
18:41:03 <jle`> `Complex Double` is
18:41:07 <MrMetric> Oh
18:41:07 <jle`> for example
18:41:15 <MrMetric> How about Complex a?
18:41:16 <jle`> which is an ordered pair of Doubles
18:41:31 <jle`> `Complex a` works, but you can't do things like add two Complex a's unless a is a Num
18:41:40 <MrMetric> Num a => Complex a -> etc
18:41:41 <MrMetric> Like that?
18:41:43 <jle`> so f :: Num a => Complex a -> Complex a -> Complex a, yeah
18:41:49 <jle`> but then you can only add and multiply them :)
18:42:01 <MrMetric> I want to use addition and power
18:42:17 <MrMetric> I mean I want to square a complex number and add one to another
18:42:24 <MrMetric> By 'one' I mean another complex number, not the number 1
18:42:34 <jle`> you can use :info Complex in ghci to see how much power in `a` you need to be able to do something with the `Complex a`
18:42:46 <jle`> exponentiation by something with its own type is (**)
18:42:48 <jle`> :t (**)
18:42:49 <Marlin> jle` I want to chain IO actions while reusing the same argument. f print 10 >>= f print >>= print should print 10 three times. so yes, Functor can't do this. good I thought I was completely losing it
18:42:49 <lambdabot> Floating a => a -> a -> a
18:42:58 <jle`> so you can only ** Floating's
18:43:19 <jle`> and according to ghci, you need a  `RealFloat a` in order for `Complex a` to be Floating
18:43:22 <jle`> huh. go figure
18:43:26 <MrMetric> How about I just multiply the number by itself instead of using ^2?
18:43:38 <jle`> oh, ^2 literally is multiplying the number by itself
18:43:40 <jle`> @src(^)
18:43:40 <lambdabot> Unknown command, try @list
18:43:43 <jle`> @src (^)
18:43:43 <lambdabot> x ^ 0            =  1
18:43:43 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
18:43:43 <lambdabot>   where f _ 0 y = y
18:43:43 <lambdabot>         f x n y = g x n
18:43:43 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
18:43:45 <lambdabot>                       | otherwise = f x (n-1) (x*y)
18:43:47 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
18:43:54 <MrMetric> Nice downside-up face
18:44:02 <jle`> > x^2
18:44:03 <lambdabot>  x * x
18:44:07 <jle`> > x^5
18:44:08 <lambdabot>  x * x * (x * x) * x
18:44:15 <MrMetric> > x^1.5
18:44:17 <lambdabot>  No instance for (GHC.Real.Integral b0)
18:44:17 <lambdabot>    arising from a use of ‘GHC.Real.^’
18:44:17 <lambdabot>  The type variable ‘b0’ is ambiguous
18:44:20 <Marlin> :t (^)
18:44:21 <lambdabot> (Num a, Integral b) => a -> b -> a
18:44:25 <MrMetric> What if I want to use a fractional power later?
18:44:31 <rasen> x ** 5
18:44:33 <jle`> (^) literally represents iterated multiplication
18:44:39 <MrMetric> > x**1.5
18:44:40 <jle`> you can use ** to exponentiate something by its own type
18:44:40 <lambdabot>  x**1.5
18:44:43 <jle`> :t (**)
18:44:44 <lambdabot> Floating a => a -> a -> a
18:44:45 <MrMetric> Oh
18:44:48 <jle`> and that is an actual "function"
18:44:52 <jle`> its own function that has to be defined
18:45:01 <jle`> (^) is just a function for literally iterated multiplication
18:45:08 <jle`> but (**) is a function you ahve to define for your type
18:45:19 <MrMetric> Haskell's typiness is a bit confuzzling
18:45:27 <jle`> you get used to it :)
18:45:38 <scott> why does (^^) exist?
18:45:38 <jle`> the good news it that you can use (^) for things that don't define their own exponentiation
18:45:41 <scott> :t (^^)
18:45:42 <lambdabot> (Integral b, Fractional a) => a -> b -> a
18:45:44 <jle`> ^ is just exponentiation
18:45:44 <rasen> jle`: can't ^ be derived?
18:45:48 <jle`> er, iterated mutliplcation
18:45:57 <jle`> rasen: (^) is just a normal function...using (*)
18:46:10 <jle`> pow x 0 = 1
18:46:17 <jle`> pow x n = x * pow x (n-1)
18:46:23 <rasen> omg. missed not in your sentence
18:46:27 <jle`> (except slightly more efficient)
18:46:49 <Marlin> no, Functor can do it.. how in the hell
18:47:12 <jle`> Marlin: you can "overwrite" values in contexts with functor
18:47:19 <Marlin> > let f = ((<*>) (<$)) in f print 10 >>= f print >>= f print
18:47:20 <lambdabot>  <IO Integer>
18:47:36 <jle`> `x >> return y` is just overwriting the value in the context of x with y
18:47:48 <jle`> > Just 4 >> return 1
18:47:50 <lambdabot>  Just 1
18:48:34 <Marlin> yeah I see
18:48:36 <jle`> look at the type of what you want to do:
18:48:51 <jle`> f :: (a -> f b) -> a -> f a
18:48:59 <Marlin> sort of see it, but not quite
18:49:28 <jle`> you only need monad if, for example, you have an (f b) and you want to do (b -> f c), for example
18:49:34 <jle`> you want to "use" the b inside the f, alone
18:49:41 <jle`> and make another f thing
18:49:48 <jle`> but in this case, you never even "use" the b
18:54:16 <Marlin> > fmap (> fmap (const 4) (print "foo")const 4) (print "foo")
18:54:17 <lambdabot>  Couldn't match expected type ‘(a0 -> b1 -> a0) -> a1 -> ()’
18:54:17 <lambdabot>              with actual type ‘GHC.Types.IO b0’
18:54:19 <Marlin> wooo
18:54:21 <Marlin> fmap (const 4) (print "foo")
18:54:28 <Marlin> > fmap (const 4) (print "foo")
18:54:29 <lambdabot>  <IO Integer>
18:55:11 <jle`> yup.  `\x m -> fmap (const x) m` is in base as `(<$)`
18:55:16 <Marlin> so we are taking (), and replacing it with 4
18:55:31 <jle`> "kinda"
18:55:43 <jle`> what's happening is different for every Functor instance
18:56:12 <jle`> in IO, we're taking a program that returns a () into a program that does the exact same thing but returns 4 after it all
18:56:53 <Marlin> yes. I meant within the function passed to fmap, it does () -> 4
18:56:58 <jle`> yes
18:57:00 <Marlin> I get it now
18:57:05 <Marlin> thanks
18:57:13 <rasen> @src const
18:57:13 <lambdabot> const x _ = x
19:01:40 <MrMetric> I'm having trouble defining a function
19:01:44 <Marlin> so now apRet is a bit of a odd name, when it is implementing with a Functor. what would be a better name for this?
19:02:05 <MrMetric> I'll paste stuff
19:02:31 <gcganley> MrMetric: so do you like haskell? i never bothered to ask lol
19:03:16 <MrMetric> gcganley: It's interesting, but annoying to use so far, since I'm so new to it
19:04:53 <lpaste> MrMetric pasted “thingy.hs” at http://lpaste.net/119777
19:05:06 <MrMetric> Someone please tell me why that doesn't work :[
19:05:33 <rasen> :t (*)
19:05:33 <lambdabot> Num a => a -> a -> a
19:05:50 <rasen> it multiplies same types
19:06:07 <rasen> change + px * to + fromIntegral *
19:06:16 <MrMetric> Can't it automatically change Integer to Double?
19:06:36 <rasen> No. Haskell is strongly typed
19:06:42 <geekosaur> numeric literals in haskell are polymorphic. otherwise, haskell does not autopromote types
19:06:43 <zwer> haskell doesn't do implicit conversions like that
19:06:46 <geekosaur> you must tell it to do so
19:07:21 <lispy> > fromInteger 2 :: Double
19:07:23 <lambdabot>  2.0
19:07:56 <MrMetric> I don't suppose it's as simple as doing (Double)px or Double(px)
19:08:05 <valdyn> > 2 :: Double
19:08:06 <lambdabot>  2.0
19:08:07 <gcganley> MrMetric: NEIN
19:08:13 <geekosaur> you were just shown how
19:08:17 <Marlin> valdyn lol don't confuse him
19:08:18 <geekosaur> see what lispy did above
19:08:36 <lpaste> Rotaerk pasted “foldM for trees” at http://lpaste.net/119778
19:08:47 <rasen>  change + px * to + fromIntegral px *
19:08:50 <gcganley> MrMetric: we talk mostly in typeclasses not in static types
19:08:50 <Rotaerk> could someone offer suggestions on that?
19:08:59 <Rotaerk> ways to improve it, or perhaps alternatives that obviate the need for it
19:09:05 <dmwit> tomphreek: Okay. That's doable, too, though perhaps not as pretty.
19:09:26 <MrMetric> rasen: Oh, I misinterpreted what you said as weird code at first
19:09:40 <rasen> I missed px first time(
19:09:45 <MrMetric> I was wondering what change is equal to
19:09:53 <randomclown> is it even possible to make hdevtools work with hsc files
19:09:55 <Marlin> :t fromInteger
19:09:56 <lambdabot> Num a => Integer -> a
19:09:59 <Marlin> or a more generic:
19:10:02 <Marlin> :t fromIntegral
19:10:02 <lambdabot> (Num b, Integral a) => a -> b
19:10:29 <MrMetric> rasen: I did that and it works, but I don't get why. lbound is still an integer, so why isn't + giving an error too?
19:10:41 <gcganley> :t (+)
19:10:42 <lambdabot> Num a => a -> a -> a
19:11:12 <geekosaur> lbound is not an integer. load it in ghci
19:11:14 <geekosaur> and check
19:11:29 <dmwit> tomphreek: Instead of having "split" put odd elements in one list and even in another, have it put increasingly large "chunks" in one list and the remainder in the other.
19:11:30 <MrMetric> :t -2
19:11:31 <lambdabot> Num a => a
19:11:32 <MrMetric> wut
19:11:37 <MrMetric> Do I need parens?
19:11:41 <geekosaur> as i said earlier, *literals* are polymorphic. so it looked at how you used it, and inferred Double for it
19:12:20 <gcganley> > (-1)
19:12:22 <lambdabot>  -1
19:12:28 <gcganley> > (1-)
19:12:30 <lambdabot>  <Integer -> Integer>
19:12:44 <zwer> :t 2
19:12:45 <lambdabot> Num a => a
19:12:49 <zwer> :t 2 :: Int
19:12:50 <lambdabot> Int
19:12:51 <MrMetric> I'll just pretend it's magic for now
19:12:51 <zwer> :t 2 :: Double
19:12:52 <lambdabot> Double
19:13:04 <Rotaerk> > (`subtract` 1)
19:13:05 <lambdabot>  <Integer -> Integer>
19:13:33 <geekosaur> seriously, load your thingy.hs in ghci and :t lbound
19:13:50 <geekosaur> type inference is a very useful part of Haskell
19:13:59 <Rotaerk> hmm actually, that usage of subtract is bad.
19:14:02 <Rotaerk> deceptive
19:14:14 <geekosaur> although it can be confusing at times, especially if someone brings a weird Num instance into scope Haskell can infer some unexpected types
19:14:20 <MrMetric> I'm assuming it's the same as :t -2
19:14:21 <hiptobecubic> > (`subtract` 1) 4
19:14:22 <lambdabot>  -3
19:14:23 <MrMetric> :t -2
19:14:24 <lambdabot> Num a => a
19:14:33 <Rotaerk> > (subtract 1) 4
19:14:34 <lambdabot>  3
19:14:46 <MrMetric> Okay, what
19:14:54 <MrMetric> Someone please explain what (subtract 1) 4 is
19:15:04 <gcganley> :t (subtract 1)
19:15:05 <Rotaerk> (subtract 1) means "subtract 1 from"
19:15:05 <lambdabot> Num a => a -> a
19:15:13 <rasen> it's subtract 1 4
19:15:14 <shachaf> It is 4 - 1
19:15:25 <MrMetric> I get that it's doing 4 - 1, but the syntax looks really weird
19:15:29 <zwer> it is something completely irrelevant to your problem at hand :)
19:15:36 <hiptobecubic> MrMetric, it applies a function to a value. The function "subtract"s 1.
19:15:45 <hiptobecubic> > (+1) 4
19:15:46 <rasen> MrMetric: it called partial application
19:15:46 <lambdabot>  5
19:15:53 <monochrom> "f x y" is the same as "(f x) y".
19:15:58 <Rotaerk> anyone looking at http://lpaste.net/119778 ?  I'd like to know if there's something i should be using instead to accomplish the same thing
19:16:24 <monochrom> in fact "(f x) y" is more canonical. "f x y" is convenient syntax for "(f x) y"
19:16:26 <Rotaerk> though, the return value is less interesting than the accumulator value that's passed in to each lambda call
19:20:41 <gcganley> @pl (\(n:ns) (m:ms) -> (n == '1') && (m == '1'))
19:20:41 <lambdabot> (`ap` tail) . (. head) . (const .) . (. ('1' ==)) . (&&) . ('1' ==) . head
19:20:46 <dmwit> Rotaerk: http://hackage.haskell.org/package/dual-tree perhaps
19:22:40 * Rotaerk takes a look
19:22:57 <athan> What's a good typesetting tool that exports to Html & can use unicode?
19:23:16 <athan> I can't seem to get pandoc to see unicode symbols, and don't really want to mess with texlive :\
19:23:22 <rasen> All zippers are comonads, aren't they?
19:23:48 <dmwit> ?let split n [] = ([], []); split n xs = let (b1, xs') = splitAt n xs; (b2, xs'') = splitAt n xs'; ~(e1, e2) = split (2*n) xs'' in (b1 ++ e1, b2 ++ e2) in split [1..]
19:23:49 <lambdabot>  Parse failed: Parse error: in
19:23:54 <mseeks> is `instance X Y Z` the same as `instance X (Y Z)`?
19:24:07 <LordBrain> i'm surprised pandoc doesnt support unicode
19:24:07 <athan> mseeks: No, they are different
19:24:15 <athan> in the second example, Z is applied to Y
19:24:33 <athan> LordBrian: Yeah, it fails to parse markdown with unicode in it for some reason
19:24:36 <dmwit> ?let {split n [] = ([], []); split n xs = let {(b1, xs') = splitAt n xs; (b2, xs'') = splitAt n xs'; ~(e1, e2) = split (2*n) xs''} in (b1 ++ e1, b2 ++ e2)} in split [1..]
19:24:37 <lambdabot>  Parse failed: Parse error: in
19:24:44 <dmwit> whoops!
19:24:49 <dmwit> > let {split n [] = ([], []); split n xs = let {(b1, xs') = splitAt n xs; (b2, xs'') = splitAt n xs'; ~(e1, e2) = split (2*n) xs''} in (b1 ++ e1, b2 ++ e2)} in split [1..]
19:24:51 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
19:24:51 <lambdabot>              with actual type ‘[t0]’
19:24:53 <mseeks> athan: so it's `instance (X Y) Z`?
19:25:05 <athan> mseeks: Nope they are all different :)
19:25:10 <athan> er wait
19:25:17 <athan> if `X` is your typeclass
19:25:30 <athan> than `instance X Y Z` would assume your typeclass has 2 arguments
19:25:44 <mseeks> athan: i'm reading some code and saw `instance X Y Z` and can't tell what the typeclass is
19:25:44 <athan> (with {-# LANGUAGE MultiParamTypeClasses #-})
19:25:55 <athan> It should be the leftmost term
19:26:10 <mseeks> that pragma's not on though
19:26:15 <MrMetric> This language makes me want to hit something
19:26:24 <dmwit> mseeks: X is the typeclass; instances do not require the pragma (only class declarations)
19:26:26 <athan> if you had `instance X (Y Z)`, then `(Y Z)` would be an instance of `X`'s 1-ary typeclass
19:26:34 <athan> oh
19:26:40 <athan> did not knowt hat, thanks dmwit
19:26:42 <Marlin> MrMetric what part confuses you?
19:26:52 <dmwit> MrMetric: That's a good sign.
19:27:12 <dmwit> athan: Also, as a terminology thing, I think most people say "func applied to arg", not "arg applied to func".
19:27:15 <MrMetric> Marlin: The part where it gives me a new error every time I add something to my code after fixing the last error
19:27:22 <athan> dmwit: I am sorry
19:27:23 <Marlin> MrMetric -2 (or 2, minus is irrelevant here) has the type of Num a => a. it can be used anywhere Num is expected. and since you used /, haskell inferred it should be Double (because if it was an Int your code wouldn't compile)
19:27:23 <mseeks> athan: so in this case, `X` is the typeclass?
19:27:26 <athan> I am sticking with it
19:27:29 <athan> xD
19:27:41 <athan> that's correct mseeks :P
19:27:59 <Marlin> MrMetric this is why it is useful to write top-level type signatures, since inferred type isn't always what you expect
19:28:03 <Marlin> MrMetric repaste?
19:28:10 <LordBrain> athan, was the unicode unusual, perhaps making use of lots of combining characters?
19:28:30 <MrMetric> Marlin: I've been making the type signature before each function, yes
19:28:39 <mseeks> athan: thanks! why is that though? does it take the first term as the typeclass always?
19:28:58 <LordBrain> i am not too familiar with pandoc, but i see in its cabal file that it does link against unicode text library
19:29:03 <athan> LordBrain: Nope, just a lambda :\
19:29:05 <athan> it's weird
19:29:10 <athan> it might be with upstart, too
19:29:15 <dmwit> mseeks: No, not always; instances may also have contexts.
19:29:23 <athan> hmm
19:29:25 <dmwit> mseeks: The context is always separated from the instance head by =>
19:29:27 <darthdeus_> what's the easiest way to dump installed package versions in a sandbox?
19:29:32 <darthdeus_> and by that i mean names and versions
19:29:34 <rasen> Does any zipper is comonad?
19:29:38 <dmwit> mseeks: The first thing in the instance head is always the class that's being instantiated.
19:29:50 <athan> rasen: I think you are correct, what is a zipper?
19:29:53 <mseeks> dmwit: I see, thanks
19:29:54 <athan> or what does it look like?
19:30:00 <athan> :i Comonad
19:30:04 <athan> mer
19:30:09 <LordBrain> athan, i think you found a bug, and should report it
19:30:27 <athan> LordBrain: I'll get around to it, I want to find where the bug is specifically
19:30:34 <athan> I'll make something reproducible :)
19:30:49 <darthdeus_> or just a way to find out which version of a specific package is installed
19:31:01 <lpaste> MrMetric pasted “thingy.hs” at http://lpaste.net/119779
19:31:09 <mniip> I might have accidentally the lambdabot
19:31:50 <MrMetric> I'm going about this by making bits of Python code and then trying to make the Haskell equivalent
19:32:10 <mniip> is lambdabot threaded?
19:32:27 <LordBrain> athan, you could try re-encoding your unicode text file to utf-16 if it is utf-8.... shouldn't need to but it would be interesting if that works
19:32:31 <rasen> mniip: it has a concurrency problem, so I believe, yes
19:32:42 <mniip> hmm
19:32:42 <athan> I will :)
19:32:51 <mniip> then I might have started a pretty long-running thread on it :S
19:32:59 <mniip> or it's just failing silently
19:33:00 <dmwit> ?botsnack
19:33:00 <lambdabot> :)
19:33:06 <dmwit> bot seems ok to me
19:33:09 <rasen> mniip: failing silently
19:33:13 <mniip> ok
19:33:34 <MrMetric> Can someone please tell me what's wrong with this: http://lpaste.net/119779
19:33:35 <rasen> Comonad is not in standard library
19:33:36 <athan> @i Comonad
19:33:36 <dmwit> ?paste
19:33:36 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password v @ ? .
19:33:36 <lambdabot> Haskell pastebin: http://lpaste.net/
19:33:40 <teoma> I just searched several introductions to Haskell syntax for operators >> and <+> that are found in example xmonad code but can't find them; could you recommend an introduction to the language that covers those operators?
19:33:44 <athan> erm
19:33:47 <athan> @info Comonad
19:33:47 <lambdabot> Comonad
19:33:52 <dmwit> teoma: hoogle it
19:33:52 <athan> wow
19:33:54 <dmwit> ?where hoogle
19:33:55 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
19:33:55 <athan> that was great
19:34:19 <mniip> I was experimenting with time complexity of pointfree (sans optimisations)
19:34:20 <geekosaur> teoma: <+> is xmonad-specific although the standard libraries have adopted <> as the same thing since xmonad started defining <+>
19:34:23 <dmwit> teoma: Add +xmonad +xmonad-contrib to search through those packages, but I think those operators are from elsewhere anyway.
19:34:23 <rasen> @hoogle comonad
19:34:25 <lambdabot> package comonad
19:34:25 <lambdabot> package comonad-extras
19:34:25 <lambdabot> package comonad-random
19:34:26 <geekosaur> >> is a standard operator
19:34:39 <mniip> crafted a function aaand it didn't reply
19:34:44 <Clint> MrMetric: do you understand the error message
19:34:52 <geekosaur> http://xmonad.org/xmonad-docs/xmonad/XMonad-ManageHook.html#v:-60--43--62-
19:35:00 <MrMetric> Clint: Nope
19:35:14 <MrMetric> If I did, I wouldn't be asking for help
19:35:41 <athan> MrMetric: The english system works better :\
19:35:50 <Clint> MrMetric: it's telling you that you can't run realPart on a Complex Integer because Integer has no RealFloat instance
19:35:51 <geekosaur> the error message is actually a bit unfortunate since it's not immediately clear that you can't have a Complex Integer
19:36:05 <athan> (kidding :P)
19:36:33 <Marlin> geekosaur why can't you?
19:36:35 <dmwit> realPart's type is stupid.
19:36:38 * MrMetric stares vacantly
19:36:38 <dmwit> :t realPart
19:36:39 <lambdabot> RealFloat a => Complex a -> a
19:36:49 <dmwit> implementation is realPart (x :+ _) = x
19:36:51 <geekosaur> it doesn't reject Complex Integer outright, it just complains when you try to use it because Integer doesn't support the operations
19:36:55 <dmwit> why the heck did they add a RealFloat a constraint
19:37:07 <Marlin> I a wodering too why it isn't realPart :: Num a => Complex a -> a
19:37:20 <dmwit> just realPart :: Complex a -> a would be fine
19:37:23 <geekosaur> I asked that on -cafe once and got an answer which I don't recall offhand...
19:37:41 * athan gives MrMetric defibrillation
19:37:47 <geekosaur> Gaussian integers are a thing but you can't have them in Haskell
19:37:58 <glguy> dmwit: in HEAD: ./Data/Complex.hs:realPart :: Complex a -> a
19:37:58 <jfischoff_> why not?
19:38:01 <Marlin> poor MrMetric, just starting to learn haskell and runs into this :)
19:38:04 <dmwit> glguy: outstanding
19:38:18 <dmwit> MrMetric: fixed in HEAD, kthxbai
19:38:23 <teoma> Thanks, dmwit and geekosaur.
19:38:26 <MrMetric> wait what
19:38:37 <MrMetric> I feel like I missed something
19:38:52 <Marlin> (I may be wrong though, and there might be a good reason for that RealFloat constraint)
19:39:03 <dmwit> MrMetric: Somebody did something dumb when writing Data.Complex. The newest version of it fixes the dumb thing, but it's not released yet.
19:39:13 <dmwit> MrMetric: So this one isn't really your fault.
19:39:27 <MrMetric> :[
19:39:30 <dmwit> MrMetric: You could write your own version of realPart that doesn't have the stupid typeclass constraint, if you wanted.
19:39:46 <LordBrain> or grab the code from head...
19:39:54 <geekosaur> ah, so it is being fixed. good.
19:39:54 <sdegutis> How do you know when your API would benefit from being Monadic?
19:39:55 <MrMetric> Can't I grab it from foot instead?
19:40:14 <LordBrain> haha
19:40:18 <glguy> SPJ implemented a redundant constraint check in ghc and then cleaned up the redundant constraints
19:40:24 * hackagebot modulespection 0.1.2.2 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.2.2 (JonathanFischoff)
19:40:37 <jfischoff_> hmm
19:40:50 <jfischoff_> I am surprised that happened automatically
19:40:53 <dmwit> glguy: That's a great idea. Does it also detect when something is overly monomorphic?
19:41:18 <dmwit> glguy: ...and can you turn it off on a per-declaration basis if so. =P
19:42:08 <lpaste> dmwit pasted “heap-style splitting” at http://lpaste.net/119780
19:42:14 <dmwit> tomphreek: ^^
19:42:18 <MrMetric> I made my own real and imag functions
19:42:19 <MrMetric> It works now
19:42:25 <dmwit> MrMetric: nice work
19:42:35 <sdegutis> What's the main point of a Monad in general?
19:42:37 <MrMetric> I used this for the type: Num a => Complex a -> a
19:42:44 <MrMetric> That's what I expected realPart and imagPart to use, actually
19:42:49 <Clint> sdegutis: >>=
19:42:57 <dmwit> MrMetric: Why not just Complex a -> a?
19:43:11 <sdegutis> I get that the Maybe and IO monads are for saying "do these things in sequence and retain your state along the way".
19:43:12 <sdegutis> Is that what Monads are for? To do things in sequence and retain context along the way?
19:43:15 <dmwit> MrMetric: In case someday you use Complex Char or something. =P
19:43:16 <Marlin> MrMetric it is a bug in library that is being fixed
19:43:19 <glguy> dmwit: so that it could be: realPart (x :+ _) =  x+0  ?
19:43:22 <MrMetric> dmwit: Because I don't even lift
19:44:04 <dmwit> glguy: realPart (x:+_) = x+1e-10 -- debug this, suckers!
19:44:27 <MrMetric> Now I need to find out how to make a loop for the next part
19:44:45 <LordBrain> lol dmwit
19:44:49 <MrMetric> Does Haskell support inline Python (like inline asm in C)?
19:45:01 <dyelift> i'm working through a dependent types tutorial, and wondering if anyone could help me with a couple of sticking points
19:45:35 <dmwit> MrMetric: ...no
19:45:45 <sdegutis> I'm getting more help in #haskell-blah about Haskell than in here, ha!
19:45:48 <MrMetric> dmwit: :[
19:45:48 <dmwit> MrMetric: Is there part of you that thinks that Haskell gets compiled to Python...?
19:45:50 <LordBrain> MrMetric, i havent heard of that, but there might be something out there using idiom brackets and  template haskell
19:45:52 <glguy> This exists, though : https://hackage.haskell.org/package/language-c-inline
19:45:54 <Marlin> MrMetric what kind of loop are you trying to write?
19:46:09 <MrMetric> dmwit: Nah, I was joking
19:46:18 * dmwit failed
19:46:23 <MrMetric> Marlin: I dunno. It's a loop that does stuff?
19:46:25 <dyelift> in particular, i'm working through the fpcomplete tutorial available here: https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
19:46:42 <MrMetric> I tell you what it is in Python
19:46:48 <MrMetric> ^ +can
19:47:12 <Marlin> go on
19:47:23 <LordBrain> there is a package which lets you embed any DSL for which you have a parser inside idiom brackets
19:47:24 <MrMetric> Is pasting a short bit of Python code here socially acceptable?
19:47:36 <Clint> @hackage MissingPy
19:47:36 <lambdabot> http://hackage.haskell.org/package/MissingPy
19:47:45 <glguy> MrMetric: Paste it to
19:47:47 <glguy> ?paste
19:47:47 <lambdabot> Haskell pastebin: http://lpaste.net/
19:47:52 <MrMetric> Okay then
19:48:31 <davidthomas> anyone have much experience with gui libs in Haskell?
19:48:32 <lpaste> MrMetric pasted “my magical code” at http://lpaste.net/119781
19:48:36 <LordBrain> MrMetric, check this out if you haven't seen it : https://hackage.haskell.org/package/BNFC-meta <-- not python, but pretty cool
19:48:42 <athan> If I'm the sole author to a white paper, can I still use "we"? I feel like "I" is distracting
19:48:58 <dmwit> athan: The royal "we" is common in academic papers.
19:49:07 <scott> athan: I probably would
19:49:07 <athan> perfect, thank you dmwit
19:49:13 <MrMetric> LordBrain: I'm sure it'd be exciting if I understood more of those acronyms
19:49:13 <scott> I do that in comments in personal projects
19:49:20 <dyelift> http://lpaste.net/119782
19:49:26 <MrMetric> Also, it says 'gramwmar'
19:49:42 <dyelift> i'm trying to get the fromList function working
19:50:02 <dyelift> but i'm getting a kind error that i'm having difficulty resolving
19:50:02 <athan> scott: Thanks :) I feel like I'm taking crazy pills
19:50:17 <dmwit> MrMetric: putStr . unlines . map unwords $ [[scalec (px :+ py) | px <- [1..width]] | py <- [1..height]]
19:50:22 <MrMetric> ...
19:50:23 <MrMetric> what
19:50:34 <MrMetric> umm
19:50:53 <dmwit> Python stole list comprehensions straight from Haskell. ;-)
19:51:04 <sdegutis> Are there good up-to-date ObjC bindings for Haskell somehow?
19:51:17 <dmwit> MrMetric: (putStr . unlines . map unwords) <- this part formats and prints
19:51:31 <MrMetric> I think I get the second half
19:51:31 <dmwit> MrMetric: [ ... ] <- this part does the pure part of the computation
19:51:41 <LordBrain> MrGwen, BNF is a standard way of defining syntax, you've probably seen it say the haskell report, or teh standard for your favorite language, LBNF is a specific extension to that, and bnfc is a compiler which converts that to a parser for you, and bnfc-meta makes it so you can simply embed that arbitrary language directly in your haskell.
19:51:58 <MrMetric> It's like a list comprehension in Python, but with 2 vars instead of 1
19:52:15 <MrMetric> And double brackets
19:52:39 <LordBrain> there is such a parser that will let you embed java directly
19:52:40 <Marlin> > [(x,y) | x <- [1,2,3], y <- [10,20]
19:52:41 <lambdabot>  <hint>:1:36:
19:52:41 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:52:48 <Marlin> > [(x,y) | x <- [1,2,3], y <- [10,20]]
19:52:51 <lambdabot>  [(1,10),(1,20),(2,10),(2,20),(3,10),(3,20)]
19:53:07 <dmwit> dyelift: Nat is a kind whose type-level inhabitants have no term-level inhabitants.
19:53:22 <dmwit> dyelift: Z :: Nat, but there is no term "foo" which has "foo :: Z".
19:53:44 <dmwit> dyelift: You will instead need to make an existential box.
19:54:06 <jfischoff_> Does anyone know how to fix this error for travis ci with GHC head: https://travis-ci.org/jfischoff/modulespection/jobs/49139111#L378
19:54:07 <dmwit> dyelift: e.g. data VectorOfSomeLength a where ThrowAwayLength :: Vector n a -> VectorOfSomeLength a
19:54:10 <athan> references are for plebs, right?
19:54:26 <MrMetric> dmwit: Unfortunately, it doesn't compile
19:54:48 <dmwit> MrMetric: Paste your exact code, and the error message.
19:54:53 <dmwit> ?paste
19:54:53 <lambdabot> Haskell pastebin: http://lpaste.net/
19:54:55 <MrMetric> I also don't think it's what I want anyway
19:55:09 <MrMetric> The print stuff in the Python code is just there to verify that it's working
19:55:16 <MrMetric> I'll be putting other code there to do stuff with c
19:55:24 <Marlin> MrMetric your width, height are Double, while scalex expects Integer
19:55:24 <dmwit> MrMetric: That's why I separated the formatting and printing from the interesting computation bit.
19:55:46 <Marlin> MrMetric so either change the type or height and width, or the type of scalex
19:56:06 <MrMetric> But width and height are both 8, which is an integer
19:56:15 <Marlin> no it isn't
19:56:19 <Marlin> :t 8
19:56:20 <lambdabot> Num a => a
19:56:22 <MrMetric> Also, one of the errors is: Couldn't match type `Complex Double' with `[Char]`
19:56:38 <dmwit> Paste your exact code, and the errors.
19:57:32 <dmwit> Otherwise you're going to get confusing guesses about what's wrong instead of helpful information.
19:57:33 <Marlin> that was an error in the code you were given. unwords works with [String], which isn't what you have
19:57:36 <lpaste> MrMetric pasted “thingy.hs” at http://lpaste.net/119783
19:57:36 <dyelift> dmwit: thanks, but i'm not quite sure i understand. let me parse for a couple minutes. i appreciate the response though
19:58:22 <dmwit> MrMetric: Ah, yes, I'm sorry.
19:58:27 <dmwit> MrMetric: I forgot to call "show".
19:58:57 <enthropy> in some sense we can have an "IsInstance" https://gist.github.com/aavogt/3d9d2b468fb51ec5d3ca
19:59:03 <lpaste> mbuf pasted “How to connect to MySQL using mysql-simple?” at http://lpaste.net/119784
19:59:08 <dmwit> MrMetric: e.g. ... map unwords . map (map show) $ [ ... ]
19:59:39 <dmwit> dyelift: Feel free to ask more questions once you've had a second to parse.
19:59:41 <MrMetric> That fixes the first error, thanks
19:59:43 <enthropy> definitely seems better to do that, than writing an overlapping instance for Show
19:59:46 <MrMetric> I get the feeling you love map
20:00:25 <Marlin> this works too
20:00:27 <Marlin> putStr . unlines . map unwords $ [[show $ scalec (px :+ py) | px <- [1..width]] | py <- [1..height]]
20:00:34 <dmwit> MrMetric: Turn on NoMonomorphismRestriction, or add a type signature for width and height making them polymorphic.
20:00:45 <dmwit> Marlin: Yes, but it mixes the formatting and computation phases.
20:00:53 <athan> Is it tradition to name the actual pdf something strange and obscure, like a bunch of numbers? (:P)
20:00:57 <dmwit> Marlin: Which is going to bite in the next step when you're doing something interesting instead of just printing. =)
20:01:09 <dmwit> Marlin: Otherwise I would have put the unwords inside the comprehension as well.
20:01:23 <MrMetric> dmwit: I've just figured out that doing width = 8 defines a function, not a constant
20:01:25 <MrMetric> ._.
20:01:34 <dmwit> MrMetric: ...no, that's not correct
20:01:38 <zwer> no it doesn't
20:01:51 <dmwit> MrMetric: What makes you say that?
20:02:24 <MrMetric> Well, it has a type, you said I can add a type signature, and it looks like a function definition with no arguments
20:02:35 <Marlin> you can add type signature to variables as well
20:03:16 <dmwit> MrMetric: Every term has a type, function or not. You can add a type signature to any binding, function or not. And it only looks like a function definition to you. =)
20:03:25 <dmwit> (Things are not always what they appear.)
20:03:31 <scott> MrMetric: it's not a function type if it doesn't have ->
20:03:32 <MrMetric> It makes sense, doesn't it?
20:03:38 <Marlin> MrMetric do you know why width and height were inferred to be Double?
20:03:46 <MrMetric> Nope
20:03:59 <Marlin> because of this: xinterval = (rbound - lbound) / width
20:04:04 <Marlin> :t (/)
20:04:05 <lambdabot> Fractional a => a -> a -> a
20:04:15 <dmwit> MrMetric: "A function with no arguments" can be a sensible, helpful way of describing things in some instances. But not here, I don't think.
20:04:32 <Marlin>  / does not work with Integer. if ghc inferred them as Integer your could would not work
20:04:40 <Marlin> it wouldn't compile
20:04:46 <dmwit> To be precise: because of using (/) *and* because we have some rules for making CAFs monomorphic.
20:04:47 <MrMetric> But if I say width = 8, why can't that just be a function with no arguments, like def width(): return 8
20:05:00 <MrMetric> Then, when I put it in the code somewhere, it is like calling that function with no arguments
20:05:04 <MrMetric> Since I didn't put anything after it
20:05:13 <dmwit> MrMetric: Turn on NoMonomorphismRestriction.
20:05:14 <dmwit> Really
20:05:15 <Marlin> MrMetric anyway, this fixed your code, even without type declarations
20:05:18 <Marlin> xinterval = (rbound - lbound) / fromIntegral width
20:05:20 <Marlin> yinterval = (ubound - bbound)/ fromIntegral height
20:05:46 <Marlin> dwit why would he turn on that?
20:05:48 <MrMetric> dmwit: I don't know what that is
20:06:01 <MrMetric> Marlin: So if it's Double in that place, it has to be Double everywhere else it's used too?
20:06:02 <kadoban> MrMetric: Well, because haskell defines what a function is, and there is no such thing as a function with no arguments. Your thinking isn't that uncommon, but it's still incorrect. It's probably not the most harmful thinking around, but it's also not helpful as far as I know.
20:06:06 <Marlin> there is no need for extensions to ake that work
20:06:11 <dmwit> Marlin: So that width has type Num a => a instead of Double. =)
20:06:13 <Marlin> MrMetric yes
20:06:24 <dmwit> Marlin: Which is obviously what he's expecting to happen.
20:07:04 <Marlin> he expected it to be Integer actually
20:07:29 <MrMetric> I never expected Num a => a anywhere until you mentioned it :|
20:07:48 <kadoban> MrMetric: http://conal.net/blog/posts/everything-is-a-function-in-haskell might be interesting reading
20:08:00 <dmwit> Marlin: He'll be sad if it's Integer, since he's using (/)...
20:08:21 <dmwit> (But note that not everybody agrees with conal.)
20:08:24 <MrMetric> I expected it to complain or warn about integer division if it wouldn't work
20:08:25 <Marlin> dmwit I know, fromInteger fixes that
20:08:48 <dmwit> MrMetric: And so it did complain. Just not in the way you expected, perhaps. =)
20:08:53 <Marlin> MrMetric it would if you gave width type, which you didn't. so you gave haskell free hands to infer any type that makes your code compile
20:09:40 <MrMetric> I was about to say that I didn't expect to need to specify types, then I remembered that most languages I use need that
20:09:46 * MrMetric palmfaces
20:10:17 <dmwit> Add {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file.
20:10:24 <dmwit> Suddenly you don't have to specify a type for width, and everything works.
20:10:25 <MrMetric> What does that do?
20:10:27 <Marlin> you usually don't for variables. but 8 is polymorphic. and you would get better compile errors if you did something like this: width = 8 :: Integer
20:10:43 <dmwit> MrMetric: It relaxes the constraint that if width is inferred to be Double somewhere, then it has to be Double everywhere.
20:10:47 <Marlin> (or width :: Integer; width = 8)
20:10:57 <dmwit> Which is a constraint made for efficiency reasons instead of semantic reasons.
20:11:04 <kadoban> Especialy when you're starting out, specifying types explicitly is a /great/ idea. If nothing else, yeah it gives you /much/ better compiler error messages.
20:11:24 <MrMetric> Specifying that each thingy is Integer makes it get errors
20:11:35 <MrMetric> Oh, right
20:11:39 <Marlin> yes. now fix them :)
20:11:42 <MrMetric> It's still inferring each one to be Double
20:12:00 <MrMetric> How about I just declare each one twice?
20:12:26 <MrMetric> Like this:
20:12:27 <Marlin> or just put {-# Language NoMonomorphismRestriction #-} on top of your file as dmwit suggested. then width will be generic Num a => a, instead of a specific type
20:12:28 <MrMetric> width = 8 :: Integer
20:12:28 <MrMetric> widthD = width :: Double
20:12:36 <MrMetric> I'll try that, then
20:12:48 <MrMetric> Is that before or after the import statement?
20:13:00 <Marlin> at the very top
20:13:01 <Marlin> before
20:13:45 <MrMetric> I did that, and now it works without the fromIntegral thingy
20:14:15 <MrMetric> I'll look at that "Everything is a function" thing now
20:14:44 <kadoban> MrMetric: It's not terribly important unless you're interested, IMO. But you may be *shrug*
20:15:19 <sdegutis> How can I say that Number points to an Int type?  data Value = Number a deriving (Show, Eq)
20:15:51 <sabreman> can someone tell me, why "fromAbsolute" is being applied to 3 arguments here?
20:15:52 <geekosaur> if it'll only be an Int, data Value = Number Int
20:15:53 <sabreman> [(fromAbsolute $ fuck d) acc en []]
20:15:56 <sabreman> I'm really confused
20:16:11 <dmwit> sdegutis: data Value = Number Int
20:16:14 <Marlin> it isn't
20:16:15 <geekosaur> without context, no
20:16:29 <sabreman> Here I'll pastebin the whole thing
20:16:30 <geekosaur> arity is a flexible concept in Haskell given partial application
20:16:34 <Marlin> sabreman  f $ x y  is the same as  f (x y)
20:16:41 <dmwit> sabreman: It's actually being applied to four things. =)
20:17:07 <sabreman> ok
20:17:11 <sabreman> how do i fix this?
20:17:17 <sabreman> I'm sorry im still a total scrub
20:17:18 <Marlin> huh.. right.. I copletely misread that
20:17:36 <Marlin> (or rather, I stopped after the parens)
20:17:48 <sabreman> I just want fromAbsolute to aply to the result of  fuck d
20:17:59 <sabreman> and the rest of the crap to be seperate
20:18:17 <geekosaur> it can't be completely separate; we need more context
20:18:19 <sabreman> http://pastebin.com/RPiw1g8y <- is the rest of the code
20:18:29 <sabreman> Using haskore-vintage lib to make music
20:18:42 <sabreman> basically building a binary tree from a string, and assingning arbitrary notes to each leaf
20:18:47 <sabreman> silly but w/e
20:18:51 <MrMetric> I'm going to go watch Spongebob now. Maybe I'll understand Haskell better after I've had some sleep
20:19:05 <sabreman> Right now im trying to generate a note from the nodes data value
20:19:10 <MrMetric> It's taken quite a while to get a tiny bit of code :|
20:19:14 <sabreman> Which is what this statement is *suposed* to do
20:19:30 <geekosaur> the qyestion is what [thing acc en []] is supposed to be
20:19:34 <exio4> MrMetric: don't worry, that's pretty normal! :P
20:19:39 <sabreman> That's the haskore construction for a note
20:20:06 <sabreman> http://pastebin.com/nFT49iyU
20:20:16 <sabreman> Heres a simple example of what i mean by notes
20:20:27 <sabreman> That makes an MIDI file that plays "row row your boat"
20:20:57 <sabreman> God I wish i understood this language better
20:21:06 <sabreman> it seems so awesome but it's causing me nothing but headaches
20:21:17 <kranius> ^
20:21:18 <sabreman> I have no idea wtf im doing
20:21:19 <geekosaur> fromAbsolute is returning a tuple. if I assume that the "note" part is a constructor that is supposed to take parameters, then you either need to deconstruct the tuple to apply the constructor or you need to apply the parameters to the constructor inside the tuple
20:21:26 <geekosaur> context suggests you don't actually want the tuple
20:22:15 <geekosaur> fromAbsolute x is returning (note,a) where note is a constructor and a is ... probably an octave?
20:22:29 <geekosaur> I am not particularly familiar with Haskore
20:22:51 <sabreman> yeah
20:23:08 <LordBrain> sabreman, this language being haskell, or the midi lib?
20:23:32 <sabreman> LordBrain: both :p
20:23:40 <sabreman> more on haskell though
20:23:49 <sabreman> if i can understand haskell well, then I can read libs
20:24:04 <sabreman> Coming form "normal" languages haskell is a bitch and a half to figure out
20:24:20 <geekosaur> (oh g_d it's Henning "T" types all over...)
20:24:32 <geekosaur> most libraries aren't quite that antisocial
20:24:39 <glguy> How else would you know it was a type?
20:25:25 <LordBrain> well, tell us what you find surprising in an unpleasant way, then maybe we can tell you how it is all nice and cozy after all :)
20:27:04 * geekosaur looks at the midi interface, gets a headache from all the random Ts...
20:29:46 <dmwit> LordBrain: There's nothing nice and cozy about the haddocks for a Henning library.
20:34:37 <LordBrain> this is a tutorial for haskore,  http://haskell.cs.yale.edu/wp-content/uploads/2011/02/HaskoreMusicTutorial-Springer.pdf
20:34:51 <kranius> @type (<-)
20:34:52 <lambdabot> parse error on input ‘<-’
20:35:07 <kranius> @type (<~)
20:35:08 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
20:35:08 <LordBrain> also, the types are more clear in that pdf
20:36:30 <dmwit> LordBrain++ for being helpful
20:39:26 <benzrf> so have yall seen orc
20:39:31 <benzrf> it has some interesting concepts
20:43:43 <exio4> is there a way to "help" the typechecker to unify things? (something like ((a :.: b) :.: c) ~ (a :.: (b :.: c)), given that that I make a proof that this holds?)
20:44:13 <dmwit> Well, you can't teach it to unify things that don't unify.
20:44:37 <dmwit> But perhaps you can write a function that converts values of the one type into values of the other.
20:44:39 <Cale> Yeah, if you're going to use Haskore, I would recommend digging up Hudak's original source, since Henning has kind of ruined it :(
20:45:16 <Cale> Henning has added lots of cool features, but the naming convention makes everything kind of unusable.
20:45:45 <exio4> dmwit: I'll check what I can do, thanks
20:49:06 <LordBrain> i have been actually thinking about a similar issue to what exio4 brought up
20:50:28 * hackagebot monoid-subclasses 0.4.0.4 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.4.0.4 (MarioBlazevic)
20:51:08 <LordBrain> basically an extension where y0ou could write a function to convert, and then have the function be called implicitly, like an implicit cast.
20:51:37 * benzrf should learn how to properly use mvars n stuff
20:53:56 <EvanR> benzrf: i have a good idea for a fun "improper" way to use mvars and stuff
20:54:04 <EvanR> could make a good youtube video
20:55:00 <EvanR> if i create two ForeignPtrs to the same Ptr, are they independent?
20:56:01 <enthropy> sounds like a bad idea since you probably don't want to free twice
20:56:08 <EvanR> right.....
20:59:00 <EvanR> memory management is hard
20:59:05 <enthropy> I guess it could be possible ghc could make a second call to newForeignPointer return the first ForeignPtr, but I don't think the documentation says so
20:59:08 * geekosaur thinks it would be nice if Haddock could recognize unusable type names and fully qualify them
20:59:30 <geekosaur> because when I find myself looking at a (T, T) and can't tell if they're the same T without following links...
20:59:46 <geekosaur> (or at least expanding said links)
20:59:47 <EvanR> enthropy: still, that would raise questions about what the finalizers mean
21:00:06 <enthropy> it's been done at some point (if you look in haddock's bug tracker), but never merged afaik
21:00:12 <geekosaur> (that being exactly when I gave up on the Haskore MIDI module)
21:01:02 <EvanR> the next stage in haskell evolution (beyond naming all types T and classes C) is to name all modules M
21:01:21 <EvanR> after that all variables x
21:01:30 <EvanR> prepare yourself
21:01:44 * geekosaur should probably not be commenting since too tired -> both grumpy and not very social-able...
21:03:23 <EvanR> the fact that the library is letting the user get a new reference to stuff (that they were already given before) is making this foreign pointer thing not work very well
21:04:18 <EvanR> if they get a new distinct foreign ptr to the same object, and lose the old one later, the new references will break
21:06:18 <dmwit> geekosaur: "Detect" might be hard. But "have an option for" would be fun.
21:06:22 <enthropy> so why would you call newForeignPointer twice?
21:06:29 <dmwit> haddock --qualify-names
21:06:46 <dmwit> Set it in your foo.cabal. =)
21:07:15 <EvanR> enthropy: its called when the object is created, then i threw it in again where the api allows user to query "current" object
21:07:31 <EvanR> which breaks everything
21:08:03 <EvanR> seems like the only way is to not use foreignptr
21:10:26 <enthropy> dmwit: seems like haddock has a -q (--qual) option now
21:10:40 <sabreman> LordBrain: Thanks for that link
21:10:43 <sabreman> Appreciate it
21:11:06 <LordBrain> yw
21:11:21 <geekosaur> I thought the point of ForeignPtr was for dealing with stuff from C that has to be cleaned up because C manual memory management
21:11:37 <EvanR> thats what im doing
21:11:56 <geekosaur> then you get to deal with C's manual memory management and it's going to be the PITA it always is :/
21:12:04 <EvanR> only this library is making ForeignPtr not applicable
21:14:53 <enthropy> EvanR: I would not bind to a function that gets you a Ptr to something you've already got
21:15:25 <joness> is there a fixed size Vector? with size being encoded in type
21:16:36 <enthropy> http://i.imgur.com/4Dv1HUI.png that --qual flag does work
21:17:04 <geekosaur> yay
21:17:05 <enthropy> @hackage vector-static
21:17:05 <lambdabot> http://hackage.haskell.org/package/vector-static
21:19:01 <EvanR> enthropy: i could emulate the behavior of that call, by remembering in a "global" the value that it should return, which is derived from the correct foreignptr
21:19:33 <EvanR> id feel asenine for that because thats exactly what the C lib is already doing
21:21:33 <enthropy> I think you'll end up with that ForeignPtr not going out of scope until the end of your program then
21:21:52 <EvanR> well its mutable
21:22:06 <EvanR> calls could have the effect of clearing that
21:23:08 <dmwit> enthropy: awesome, now we just need to tell henning :)
21:23:48 <enthropy> you'd think the person that implemented it got to him first
21:37:58 <EvanR> nice documentation
21:38:07 <EvanR> sample.length "Length of the sample, in samples. The length of a sample is 8 bits (1 byte) for a 8 bit sample, and 16 bits (2 bytes) for a 16 bit sample."
21:39:47 <Kaidelong> is there any idiom for including a consistent bunch of pragmas in all source files?
21:39:58 <Kaidelong> I would think projName.cabal would be a logical place for it
21:40:16 <geekosaur> you can specify LANGUAGE pragmas in the cabal file
21:40:36 <geekosaur> not others though, since they tend to be applicable at a particular point in the source rather than the entire file
21:40:50 <Kaidelong> GHC-OPTS
21:41:15 <geekosaur> ghc-options: ...
21:41:21 <Kaidelong> cool
21:41:23 <Kaidelong> thanks
21:41:54 <Kaidelong> so how do you specify them in the cabal file, the language pragmas I mean?
21:42:00 <Kaidelong> I guess I can just look it up
21:43:17 <geekosaur> extensions: ...
21:50:53 <gamegoblin> Is anyone else having https issues with wiki.haskell.org ?
21:51:03 <gamegoblin> My browser is telling me it can’t verify the certificate
21:55:44 <glguy> The answer I got earlier in #haskell-infrastructure earlier was "[08:26:32] <sclv> Btw we think the CA thing is just a transient glitch upstream w the globalsign cert."
22:08:21 <gamegoblin> @pl \f -> g (f x)
22:08:21 <lambdabot> g . ($ x)
22:18:28 <solrize> https://www.destroyallsoftware.com/talks/wat   this is great, you all must watch it  (about type shenanigans in ruby and javascript)
22:20:09 <cosmik> For an internal webapp, I am thinking of using Yesod. I am a Ruby/Javascript dev (10+ year experience in web development) and this gives me an excuse to learn Haskell. Is Yesod a good choice of framework for me?
22:20:32 * hackagebot jobqueue 0.1.5 - A job queue library  http://hackage.haskell.org/package/jobqueue-0.1.5 (yjkmy)
22:20:34 <jle`> it might be, but a web app might not be the best "first haskell project"
22:20:57 <jle`> your 10+ year experience in web development might end up not helping as much as you think...and in some aspects, it might hurt :)
22:21:01 <cosmik> It's a trivial app actually. Takes a JSON as input and produces JSON as output.
22:21:09 <jle`> ah
22:21:19 <jle`> so you could basically write it as a pure function JSON -> JSON
22:21:33 <jle`> and throw it onto an HTTP socket?
22:21:39 <cosmik> Yes
22:21:46 <jle`> simple receive-reply server?
22:21:49 <jle`> ah, okay
22:21:51 <jle`> then yesod is definitely overkill
22:22:24 <luite> but yesod doesn't necessarily make it complicated. it does make the instalation take longer :)
22:22:42 <jle`> haha indeed.  and dealing with installing it isn't always fun either ;)
22:22:55 <jle`> yesod attempts to fill a similar role as rails does for ruby, if that gives you perspective
22:23:01 <luite> hmm, i should go to the beach to continue coding
22:41:29 <Lokathor> how does one get haskell-mode in emacs to insert 4 spaces per tab, nothing else?
22:41:48 <Lokathor> I've got it setup like that in other modes, but haskell-mode seems to override it even with no special indent mode set
22:45:32 * hackagebot extensible 0.2.7 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.2.7 (FumiakiKinoshita)
22:50:38 <stephen_> carter: how's your numerical project coming?
23:05:33 * hackagebot sequence 0.9.5 - A type class for sequences and various sequence data structures.  http://hackage.haskell.org/package/sequence-0.9.5 (AtzeVanDerPloeg)
23:09:50 <startling> I have a "body :: (TokenParsing m, Monad m, MonadPlus m, Alternative m) => m X"; "body = execWriter $ someParser". "someParser :: (MonadWriter X m, TokenParsing m) => m ()". I'm getting Could not deduce (TokenParsing (WriterT (Deck String Integer) m)) … arising from a use of ‘deckItem’
23:10:02 <startling> s/deckItem/X, sorry.
23:10:29 <startling> blegh, let me rewrite that whole thing.
23:10:49 <EvanR> constraint oriented programming ;)
23:11:51 <startling> I have a "body :: (TokenParsing m, Monad m, MonadPlus m, Alternative m) => m X"; "body = execWriter $ someParser". "someParser :: (MonadWriter X m, TokenParsing m) => m ()". I'm getting Could not deduce (TokenParsing (WriterT X m)) … arising from a use of ‘someParser’. The thing is there's an instance (TokenParsing m, MonadPlus m, Monoid w) => TokenParsing (WriterT w m) in parsers. What am I missing?
23:12:34 <startling> sorry, "body = execWriterT someParser". :(
23:25:34 * hackagebot case-insensitive 1.2.0.4 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.2.0.4 (BasVanDijk)
23:30:34 * hackagebot sequence 0.9.6 - A type class for sequences and various sequence data structures.  http://hackage.haskell.org/package/sequence-0.9.6 (AtzeVanDerPloeg)
23:50:39 <showboz> hello
23:54:04 <steffen> Having Defined an Iso Bool MyBool by defining from and to and then unsafeMakeIso from to, how to I apply that to a MyBool to get a bool?
23:55:03 <steffen> It says... is applied to one argument but its type 'Iso Bool MyBool' has none
23:55:21 <supki> steffen: what's Iso?
