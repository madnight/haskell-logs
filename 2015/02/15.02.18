00:00:52 <HeladoDeBrownie> i will probably end up using parsec at least for now since i'm already using it but may switch over later
00:01:16 <HeladoDeBrownie> this seems like a case where importing Data.ByteString.Char8 is forgiveable
00:01:20 <Axman6> attoparsec is very similar to parsec when it comes to writing your parsers
00:01:29 <Axman6> :(
00:01:56 <HeladoDeBrownie> don't worry, i'll give it due consideration. i'm just making a quick change and it's actually kinda late :P
00:01:59 <dramforever> I'm trying to write a RFC2616 parser, but got messed up
00:02:17 <dramforever> since network-uri is string-based
00:02:19 <HeladoDeBrownie> as far as i can tell i'm not compromising correctness
00:03:12 <dramforever> but I used ByteString, no Char8
00:05:34 <HeladoDeBrownie> attoparsec looks pretty nice
00:07:54 <dramforever> I'm (trying to start) writing an HTTP proxy. I with I could have a function http :: HTTPRequest -> IO HTTPResponse, and runProxy :: (HTTPRequest -> IO HTTPResponse) -> IO ()
00:49:04 <EvanR> ezrios: http://postimg.org/image/do5lgiusb/
00:52:00 <EvanR> looks kind of like a sadistic board game ;)
00:56:40 <EvanR> corrected version , Integer is of course not Fractional. http://postimg.org/image/ps98ik9of/
00:59:38 <EvanR> you can infer from this diagram that start from posix time, absolute time, or utc time, there is no way to "freely" get a Day. the only paths require a TimeZone to pass
01:00:02 <tdammers> makes sense
01:00:10 <EvanR> likewise if you start at Day or LocalTime you cant get to UTCTime or POSIXTime without a TimeZone
01:00:22 <tdammers> also makes sense
01:00:26 <EvanR> and in Data.Time timezone is the very non-scary simple offset in hours and minutes
01:00:36 <EvanR> no history timezone series nonsense
01:00:59 <EvanR> historic*
01:02:03 <EvanR> with a javascript hack you can get the offset of a visit to your site
01:02:10 <EvanR> with reasonable accuracy
01:02:19 <EvanR> conquering complexity through types!
01:02:41 <EvanR> offset of a visitor!
01:04:25 <tdammers> I guess rounding to 30-minute granularity should be good enough
01:04:37 <tdammers> or are there any 15-minute timezone offsets?
01:04:45 <EvanR> there are
01:04:48 <EvanR> fuckem
01:05:23 <acetoline> there are 15 minute timezone offsets?
01:05:27 <acetoline> wtf is wrong with people
01:05:46 <EvanR> at one time they were off by minutes
01:05:53 <EvanR> its all in the olsen database
01:06:12 <acetoline> they seriously couldn't stand losing 15 minutes of daylight?
01:06:28 <EvanR> before the current time system, each city would have its own time standard
01:06:28 <tdammers> acetoline: political choices, I bet
01:06:36 <acetoline> tdammers: hrm, maybe
01:06:37 <tdammers> oh right, the historic thing
01:06:40 <EvanR> so it naturally wasnt lined up by the hour
01:06:58 <tdammers> every village had a clock on their church tower or town hall, and whatever that clock said was the local time
01:07:06 <acetoline> well at some point there weren't even time zones
01:07:07 <acetoline> yeah
01:07:19 <tdammers> it took a bunch of railroad disasters to get things moving towards standardized timezones
01:07:25 <acetoline> but that doesn't mean you should ride your horse to work
01:07:26 <EvanR> the olsen database not only has these offsets in history for current time zones, but for cities
01:10:52 <acetoline> in the future there will be no timezones
01:11:38 <EvanR> and your poor calendar app will look very foolish
01:35:38 <cryo28> !help
01:37:32 <mrkkrp> Do you know of some efficient pure random numbers generator, like mersenne random pure 64, but with `split' implemented?
01:39:29 <edwardk> @remember SPJ I have made several forays into the impredicative swamp, and barely made it back to the shore alive.
01:39:29 <lambdabot> I will remember.
01:39:50 <johnw> edwardk: you guys on the phone? :)
01:40:13 <edwardk> nah it was on the libraries list a couple days ago, and herbert just reminded me of it
01:41:39 <nullremains> ur/web wow
01:45:02 <Guest28137> let f a = a * 3;
01:45:12 <Guest28137> let g a = a * 4
01:45:25 <Guest28137> :t f <> g
01:45:26 <lambdabot> (FromExpr m, Monoid m) => m
01:46:28 <Guest28137> is there a monoid instance for functions?
01:46:44 <EvanR> theres one for functions of the form a -> a
01:47:55 <EvanR> > (Endo (+1) <> Endo (*2)) 5
01:47:56 <lambdabot>  Couldn't match expected type ‘a1 -> t’
01:47:56 <lambdabot>              with actual type ‘Data.Monoid.Endo a0’
01:48:57 <EvanR> > (Endo (+1) <> Endo (*2)) `appEndo` 5
01:48:58 <lambdabot>  11
01:49:03 <Guest28137> > let f a = pure :: Maybe Int
01:49:04 <lambdabot>  not an expression: ‘let f a = pure :: Maybe Int’
01:49:13 <Guest28137> let f a = pure :: Maybe Int
01:49:21 <Guest28137> let g a = pure :: Maybe Int
01:49:29 <Guest28137> :t f <> g
01:49:30 <lambdabot> (FromExpr m, Monoid m) => m
01:49:57 <EvanR> your lets were not saved
01:50:16 <Guest28137> :t f
01:50:17 <lambdabot> FromExpr a => a
01:50:18 <Guest28137> :t g
01:50:19 <lambdabot> FromExpr a => a
01:50:25 <Guest28137> ah
01:50:53 <EvanR> f :: Int -> Maybe Int, so it wont work with the Endo monoid
01:51:07 <Guest28137> pure :: Maybe Int <> pure Maybe Int
01:51:13 <Guest28137> f = pure :: Maybe Int <> pure Maybe Int
01:51:17 <Guest28137> :t f
01:51:18 <lambdabot> FromExpr a => a
01:51:32 <EvanR> pure isnt a function
01:51:36 <EvanR> er wait
01:51:38 <Guest28137> :t pure
01:51:39 <EvanR> :t pure
01:51:39 <lambdabot> Applicative f => a -> f a
01:51:39 <lambdabot> Applicative f => a -> f a
01:51:46 <EvanR> still not of the form a -> a
01:51:56 <Guest28137> exactly, still it works
01:52:09 <EvanR> not as a monoid
01:52:54 <Guest28137> umm, so do you mean `f` is not a monoid anymore
01:53:14 * ski isn't sure what Guest28137 wants to do ..
01:53:45 <ski> why are you using `pure' above ?
01:54:13 <Guest28137> just to demonstrate (<>) is working over functions other than 1 -> 1
01:54:19 <Guest28137> just to demonstrate (<>) is working over functions other than a -> a
01:54:20 <Guest28137> sorry
01:54:27 <EvanR> :t pure <> pure
01:54:28 <lambdabot> (Monoid (f a), Applicative f) => a -> f a
01:54:31 <ski> "working" how ?
01:54:51 <Guest28137> it's typechecking :P
01:54:51 <EvanR> i guess it could work...
01:56:17 <Guest28137> what it does when I apply (<>) on functions
01:56:47 <EvanR> oO
02:00:13 <ski> Guest28137 : which functions ?
02:00:24 <ski> (.. iow, of which type ?)
02:01:39 <Guest28137> ski: lets take a specific case Integer -> Maybe String
02:02:39 <gavilancomun> @pl (reverse (map addEnd (transpose (map histCol l))))
02:02:39 <lambdabot> reverse (map addEnd (transpose (map histCol l)))
02:03:20 <gavilancomun> @pl \f g x y -> f (x ++ g x) (g y)
02:03:21 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
02:04:43 <Guest28137> ski: here is an example
02:04:53 <Guest28137> f = Just . show
02:05:01 <Guest28137> f = g = Just . show
02:05:10 <Guest28137> (f <> g) 1
02:05:20 <EvanR> :t (Just . show) <> (Just . show)
02:05:20 <Guest28137> :t (f <> g)
02:05:20 <lambdabot> Show a => a -> Maybe String
02:05:21 <lambdabot> (FromExpr m, Monoid m) => m
02:06:12 <EvanR> im not sure what monoid hat is
02:06:36 <ski> > (Just . reverse . show <> (Just . show . (^ 2))) (12 :: Integer)
02:06:38 <lambdabot>  Just "21144"
02:07:10 <tdammers> hum, I guess that's what Endo is for
02:07:19 <ski> this is not `Endo'
02:07:25 <tdammers> no, exactly my point
02:07:43 <tdammers> I assumed that the monoid instance for functions would be composition
02:07:47 <ski> this is operating pointwise. iow "environment" or "reader" if you prefer
02:07:51 <tdammers> yeah
02:08:02 <EvanR> funky
02:08:45 <tdammers> because Reader s a is really mostly just a newtype around s -> a, right?
02:08:46 <ski> it's using the instances `forall a. Monoid [a]',`forall a. Monoid a => Monoid (Maybe a)',`forall rho a. Monoid a => Monoid (rho -> a)' to derive `Monoid (Integer -> Maybe String)'
02:09:11 <ski> Guest28137 : ok ?
02:09:13 <Guest28137> okay
02:09:20 <Guest28137> ski: yup makes sense
02:10:00 <Guest28137> ski: EvanR: thanks
02:10:39 <mrkkrp> I want to write a function that generates infinite list of numbers. To generate a number in the list, I need to know previously computed numbers. Also, I need one random number. Now, if I use monad here, keeping some sort of history (if I build history with (:), it should be reversed at the end, but it's hard to reverse infinite list), I cannot generate infinite list (I will never get the history or I must choose how many elements to
02:10:40 <mrkkrp> calculate). How should I approach the problem? I'm sure it's possible to solve.
02:11:15 <EvanR> dont try to generate an infinite starting from the end
02:12:08 <EvanR> list
02:12:23 <jle`> mrkkrp: what kind of list do yuo want?
02:12:31 <jle`> one random number...and then a list of 0's?
02:12:36 <jle`> > 4 : repeat 0
02:12:37 <lambdabot>  [4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
02:12:51 <mrkkrp> list of Ints
02:13:00 <jle`> where does the random number go?
02:13:11 <jle`> by the way, you can inspect "the list so far" by using a recursive call
02:13:24 <mrkkrp> every element needs one random number to be calculated
02:13:27 <ocharles_> morning all
02:13:37 <jle`> > let foo = 1:2:(map (+1) foo) in take 20 foo
02:13:38 <lambdabot>  [1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]
02:13:39 <jle`> ocharles_: morning!
02:13:47 <ocharles_> does anyone know if there exists a tool for formatting haskell source code as html, with syntax highlighting, and hyperlinking each function to its respective haddock documentation?
02:14:12 <jle`> > let foo = 1:2:(map (*10) foo) in take 20 foo
02:14:14 <lambdabot>  [1,2,10,20,100,200,1000,2000,10000,20000,100000,200000,1000000,2000000,10000...
02:14:17 <ski> mrkkrp : something like `foo :: RandomGen g => g -> [Integer]; foo = bar [] where bar old g0 = let (rnd,g1) = random g0; n = ..old..rnd.. in n : bar (n : old) g1' ?
02:14:38 <jle`> mrkkrp: do you just want an infinite list of random numbers?
02:14:48 <mrkkrp> of course not
02:14:50 <jle`> or, a random number used at each step, plus the list so far
02:14:50 <pepegar> ocharles_: probably pygments can help you
02:14:59 <ski> mrkkrp : an alternative is to pass in an infinite list of random numbers
02:15:03 <ocharles_> pepegar: only with the highlighting I would think, which hscolour also does
02:15:28 <jle`> it's a little hard to understand exactly what you ar doing...can you give us the algorithm you are trying to implement?
02:15:35 <mrkkrp> yes, random number on each step and list so far
02:15:57 <ski> mrkkrp : a variation is to use the final list instead of `old' -- but you need to make sure you don't make an infinite dependency then
02:16:42 <mrkkrp> ski, jle`, I will think about simplified version of the algorithm itself and post it here later
02:16:48 <ski> .. getting the random number would perhaps look nicer with a view pattern
02:16:58 <pepegar> ocharles_: dunno then, if it were Literate Haskell instead, you can use something like lhs2tex and then tex to html... but is a bit weird :)
02:17:11 <jle`> yeah, it's really hard to prototype/show anything without an actual example
02:17:15 <ski> mrkkrp : any comment on my suggestion(s) above ?
02:17:38 <ocharles_> pepegar: indeed, literate haskell is ultimately my goal
02:17:48 <ocharles_> but still, that doesn't do the hyperlinking
02:17:50 <ocharles_> I think this tool doesn't exist
02:18:01 <ocharles_> I've got Agda envy :)
02:18:22 <pepegar> hahaha dependent types...
02:19:30 <ocharles_> well, that's another story ;)
02:19:38 <ocharles_> but agda source code htmlises as I'd like
02:19:40 <mrkkrp> ski, I used to solve it like this: foo = zipWith f (0:foo) inf_list_of_rands
02:20:06 <mrkkrp> ski, but later I understood that I need arbitrary number of previous numbers, not only one
02:20:07 <ocharles_> e.g., see https://agda.github.io/agda-stdlib/Data.Nat.html#1 - all of the definitions there can be clicked
02:21:10 <apo_> mrkkrp: so define a recursive function, then map f [0..]?
02:21:11 * vhictour01 has quit (Quit: Connection closed for inactivity)
02:22:55 <apo_> oh, but then you get different random numbers
02:23:03 <EvanR> ocharles_: im now inspired to learn agda ;)
02:23:19 <EvanR> gotta love a good presentation
02:23:26 <ocharles_> EvanR: it's a really nice way to explore the libraryp
02:23:30 <apo_> mrkkrp: make the random number a function of some seed and the index in the list :p
02:24:01 <ocharles_> what I'm hoping to have is that, but with a literate haskell formatter too. Comments formatted in a serif font, bird tracks and leading --'s are removed from presentation - everything hyperlinked
02:24:13 <ocharles_> I think this could be really accessible for tutorial material
02:24:19 <EvanR> ocharles_: really, the source that you get when click source on hackage should just do this
02:24:23 <dramforever> yeah
02:24:25 <ocharles_> sure
02:24:37 <EvanR> someone (tm) needs to do it!
02:24:42 <dramforever> I always hoped linked sources in haddock
02:24:46 <ocharles_> i want it, I should probably do it then
02:24:53 <ocharles_> that's how itch scratching works, right?
02:25:04 <ocharles_> i just don't know where it belongs. perhaps hscolour
02:25:08 <ocharles_> will open a cafe thread
02:37:25 <ski> mrkkrp : consider this (non-random) example :
02:37:32 <ski> @let infinitelyManyPrimes :: [Integer]; infinitelyManyPrimes = [leastPrimeFactor (1 + product (take n infinitelyManyPrimes)) | n <- [0 ..]]
02:37:36 <lambdabot>  Defined.
02:37:44 <ski> > take 7 infinitelyManyPrimes
02:37:46 <lambdabot>  [2,3,7,43,13,53,5]
02:39:14 <ski> each number in this list is computed from all the preceding ones (by taking their product, adding one, and then finding the least prime factor of that)
02:39:54 <Yuras> hey, does anyone use DI and/or IoC in Haskell?
02:40:55 <ski> if you want to, you could define a general `cov :: ([a] -> a) -> [a]' (for "course of values" recursion/induction, aka "strong/complete induction")
02:41:16 * ski has no idea what "DI" or "IoC" would be in this context
02:41:46 <ocharles_> ski: dependency injection and inversion of control
02:42:39 * ski has seen the latter mentioned in connection to continuations
02:43:10 <ocharles_> Does anyone know if quasiquoters can be nested?
02:43:36 <ocharles_> I'm curious about idiom brackets for something like [i| Foo x y [i| bar z |] |]
02:43:37 <tdammers> Yuras: those are somewhat OOP-biased terms, but yes, people do it in Haskell all the time
02:44:03 <Haskellfant> isn't parametrizing a function over some other function already inversion of control?
02:44:07 <tdammers> Haskellfant: yes
02:44:10 <tdammers> pretty much
02:44:18 <Haskellfant> not quite sure how people define dependency injection
02:44:24 <pacak> ocharles_: You are providing paarser for stuff inside [i| |], so yes, it might be nested.
02:44:32 <ocharles_> but it's up to the parser, then
02:44:48 <Yuras> tdammers: the question is how to do it right :)
02:45:02 <tdammers> Haskellfant: dependency injection means that whatever your code depends on gets passed in at construction time, rather than the code itself creating it
02:45:26 <tdammers> Yuras: well, DI in the OOP sense is a solution to a problem that doesn't really exist in Haskell
02:45:46 <Haskellfant> tdammers: hm that doesn't sound like it makes sense in haskell
02:46:00 * ski thinks ocharles_ wants modular/composable language extensions
02:46:11 <tdammers> Haskellfant: not really, no, because we're not "creating" first-class behavior/state bundles like you would in OOP
02:46:17 <Haskellfant> yeah exactly
02:46:20 <ocharles_> ski: well, I actually just want decent idiom brackets... but I'm opening a thread about that on the ML later today
02:46:21 <ocharles_> :)
02:46:34 <tdammers> but the goal of decoupling dependent sections of a codebase stands
02:46:45 <Haskellfant> sure
02:47:15 <tdammers> but in Haskell, we don't need an intricate pattern for this, usually, because we can just close over things and pass functions around
02:48:18 <tdammers> if you want to go fancy, make a record type where the fields are functions themselves, add a smart constructor that closes over the initial state (including dependencies as needed) - there you go, OOP in Haskell
02:49:10 <Arahael> You could even do that bastardisation of "OO" many aspiring Java programmers use, just by using lens, I believe.
02:49:19 <Haskellfant> what do you mean by “closing over the initial state”?
02:49:28 <Arahael> (And by that, I mean, you can achieve what they do with getters/setters, and calling that 'OO programming")
02:49:45 <Haskellfant> Arahael: lens has uml diagrams so it definitly qualifies as oop :P
02:50:12 <Arahael> Haskellfant: URL please! (So that I may learn...  I"ve honestly not covered lens properly yet)
02:50:17 <tdammers> Haskellfant: the smart constructor takes all the values you need to construct the "object"; the object itself is just a record containing a bunch of functions that close over that state
02:50:20 * Arahael declines to mention "if at all".
02:50:20 <Yuras> tdammers: so I actually don't have any issue :) OK
02:50:34 <tdammers> Yuras: probably not :D
02:51:11 <Yuras> tdammers: now I need to find out how to solve unresisting issue :)
02:51:35 <Haskellfant> tdammers: I don't quite get what your smart constructor does that the standard record constructor doesn't
02:51:55 <tdammers> data Shape = Shape { shapeName :: String }; square :: Double -> Shape; square size = Shape ("A square of size " ++ show size)
02:51:56 <Haskellfant> Arahael: https://hackage.haskell.org/package/lens-4.7/docs/Control-Lens.html
02:51:58 <tdammers> like this
02:52:21 <Haskellfant> ah ok, thx
02:52:23 <tdammers> and then you can make another smart constructor to produce other shapes
02:52:23 <ski> Haskellfant : maybe `smart :: Config -> IO Stuff' or something ..
02:52:40 <tdammers> ('square' being the smart ctor in the example)
02:53:04 <tdammers> or you can add more methods, e.g. shapeSize :: Double
02:53:05 <Arahael>  Haskellfant Now I feel foolish!
02:53:13 * ski thinks `square' here is a constructor (in the OO sense)
02:53:25 <tdammers> ski: yes, pretty much
02:53:36 <tdammers> ski: but it's also a "smart constructor" in the Haskell sense
02:53:45 <Haskellfant> Arahael: I remember ekmett saying something like “in haskell we are so object oriented that even our accessors have accessors” :)
02:54:05 <ski> tdammers : arguable (in more complicated examples)
02:54:15 <tdammers> ski: sure
02:54:41 <tdammers> another way to look at it is that 'square' is an explicit casting function
02:54:43 <ski> anyway, "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> talks some about this topic
02:59:26 <Yuras> OK, I'll elaborate a bit. Everything is easy when you have 1-2 dependencies. But I have more dependencies, often they are nested. I need a way to manage them. The goal is to make code testable, so if anyone uses other from DI approaches, then I'd like to hear that too.
02:59:59 <Yuras> I'm mostly interested in real world experience with big code base and complex design
03:02:30 <tdammers> Yuras: there are plenty of powerful tools available
03:02:52 <tdammers> a very straightforward approach is to split your code into modules
03:03:04 <tdammers> and decouple dependencies through typeclasses
03:03:35 <tdammers> e.g., depend on the MonadIO typeclass instead of IO directly
03:04:41 <Yuras> tdammers: That is what I have right now. It is not easy to do it right
03:05:00 <Yuras> I'm planing refactoring, and looking for other possible approaches
03:06:32 <Yuras> I have a number of typeclasses, one per dependency, so each module has something like (HttpMonad m, DBMonad m, LogMonad m) =>
03:07:29 <Yuras> it becomes a pain too quickly
03:08:01 <Yuras> so I'm thinking of something like IoC container
03:09:32 <bennofs> Yuras: you could use constraint kinds to group related constraints, like type HttpHandler m = (HttpMonad m, DBMonad m, LogMonad m)
03:11:04 <Arahael> How do I learn how to use Regex.TDFA?
03:11:31 <Arahael> I'm struggling to use code like: content =~ pat :: [String], where content and pat are both of type String.
03:11:54 <Yuras> bennofs: it saves keystrokes at best
03:12:31 <Arahael> So I want to know how to interpret6 this line in the documentation:
03:12:40 <Arahael>  already inversion of control?
03:12:40 <Arahael> 21:44 < tdammers> Haskellfant: yes
03:12:40 <Arahael> 21:44 < tdammers> pretty much
03:12:40 <Arahael> 21:44 < Haskellfant> not quite sure how people define dependency injection
03:12:47 <bennofs> Yuras: ah, just read the backlog. Sorry, I don't know what an IoC container is :|
03:13:04 <Arahael> Oops.  Wrong clipboard. :(   (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
03:14:14 <Arahael> As for an IoC container, it is basically a repository of implementations.  So if a module requires say, an implementation of HttpMonad, it can say: "Yo!  Get me an instance of HttpMonad"
03:14:22 <ZachK> I am having trouble with my cabal build on CI (I am trying to install Elm)
03:14:28 <ZachK> I have these 3 lines
03:14:32 <ZachK>     - sudo cabal update
03:14:32 <ZachK>     - sudo cabal install cabal-install
03:14:32 <ZachK>     - sudo cabal install elm-compiler-0.14.1 elm-package-0.4 elm-make-0.1.1 elm-repl-0.4 elm-reactor-0.3
03:14:53 <ZachK> but it seems that the 3rd line does not work right
03:19:25 * hackagebot apiary 1.3.0 - Simple and type safe web framework that generate web API documentation.  http://hackage.haskell.org/package/apiary-1.3.0 (HirotomoMoriwaki)
03:19:27 * hackagebot apiary-logger 1.3.0 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-1.3.0 (HirotomoMoriwaki)
03:19:29 * hackagebot apiary-persistent 1.3.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-1.3.0 (HirotomoMoriwaki)
03:19:31 * hackagebot apiary-websockets 1.3.0 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-1.3.0 (HirotomoMoriwaki)
03:19:33 * hackagebot apiary-cookie 1.3.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-1.3.0 (HirotomoMoriwaki)
03:20:00 <luite> ZachK: i'd generally try to avoid sudo doing cabal install. also i'd use hvr's repository for a recent cabal build rather than instsalling cabal-install from source
03:20:19 <jle`> `right` is `fmap`
03:21:17 <luite> ZachK: here's how we get cabal-install 1.22 for ghcjs: https://github.com/ghcjs/ghcjs/blob/master/.travis.yml#L10-L15
03:22:32 <luite> ZachK: other than that i can't help without more info about the error
03:22:50 <ZachK> this is the last few lines of the output
03:22:51 <ZachK> elm-reactor-0.3 (new package)
03:22:51 <ZachK> cabal: The following packages are likely to be broken by the reinstalls:
03:22:51 <ZachK> regex-posix-0.95.1
03:22:51 <ZachK> regex-compat-0.95.1
03:22:51 <ZachK> sudo cabal install elm-compiler-0.14.1 elm-package-0.4 elm-make-0.1.1 elm-repl-0.4 elm-reactor-0.3 returned exit code 1
03:22:51 <ZachK> Use --force-reinstalls if you want to install anyway.
03:22:51 <ZachK> action sudo cabal install elm-compiler-0.14.1 elm-package-0.4 elm-make-0.1.1 elm-repl-0.4 elm-reactor-0.3 failed
03:24:25 * hackagebot apiary-session 1.3.0 - session support for apiary web framework.  http://hackage.haskell.org/package/apiary-session-1.3.0 (HirotomoMoriwaki)
03:24:27 * hackagebot apiary-clientsession 1.3.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-1.3.0 (HirotomoMoriwaki)
03:24:29 * hackagebot apiary-authenticate 1.3.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-1.3.0 (HirotomoMoriwaki)
03:24:31 * hackagebot apiary-eventsource 1.3.0 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-1.3.0 (HirotomoMoriwaki)
03:24:33 * hackagebot apiary-purescript 1.3.0 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-1.3.0 (HirotomoMoriwaki)
03:29:35 * hackagebot apiary-mongoDB 1.3.0 - mongoDB support for apiary web framework.  http://hackage.haskell.org/package/apiary-mongoDB-1.3.0 (HirotomoMoriwaki)
03:29:37 * hackagebot apiary-memcached 1.3.0 - memcached client for apiary web framework.  http://hackage.haskell.org/package/apiary-memcached-1.3.0 (HirotomoMoriwaki)
03:29:39 * hackagebot apiary-helics 1.3.0 - helics support for apiary web framework.  http://hackage.haskell.org/package/apiary-helics-1.3.0 (HirotomoMoriwaki)
03:32:59 <tempay> Is there a function in Base that acts like a stateful takeWhile? Like a foldl that can terminate early
03:36:50 <luite> ZachK: yeah you can add --force-reinstalls, but installing cabal-install through a different means will probably also fix this and be a good deal faster too
03:43:27 <zipper> Just saw an exciting haskell email in the yesod mailing list about taking yesod to the people \o/
03:44:49 <gfixler> I wish I could make more interesting number sequences with [m..n] notation
03:45:08 <gfixler> like [1,2,4..128]
03:45:28 <arw_> > map (2^) [1..10]
03:45:30 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
03:45:42 <gfixler> I also want backwards
03:45:55 <arw_> > reverse $ map (2^) [1..10]
03:45:57 <lambdabot>  [1024,512,256,128,64,32,16,8,4,2]
03:46:00 <gfixler> nah, already too big
03:46:12 <gfixler> [128,64..1]
03:46:22 <dramforever> that's undecidable
03:46:26 <gfixler> yeah :(
03:46:45 <phaazon> > take 10 $ [x^2 | x <- [0..]]
03:46:47 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
03:47:01 <phaazon> > take 10 $ [x^2 | x <- [1..]]
03:47:02 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
03:47:20 <arw_> there are languages that do that. but your example [128,64..1] would result in [128,64,1] because the difference is used as simple in/decrement
03:47:24 <jle`> yeah, it's not obvious what [1,2,4..128] would be
03:47:37 <gfixler> arw_: that was part of the wish - that it wasn't just simple increments
03:47:43 <jle`> there are several patterns that match 1,2,4...
03:47:57 <jle`> so any choice would be pretty arbitrary
03:47:58 <dramforever> maybe 1 2 4 5 7 8 10 11
03:48:01 <KaneTW> it's undecidable anyway so
03:48:03 <dramforever> +1, +2, +1, +3,...
03:48:10 <dramforever> ouch, s/+3/+2/
03:48:19 <dramforever> ouch, s/\+3/\+2/
03:48:23 <dramforever> stupid regex
03:48:23 <jle`> it doesn't have to be "undecidable"
03:48:35 <jle`> you can just set the spec to arbitrarily be powers
03:48:41 <gfixler> [1,^2..]
03:48:44 <jle`> the same way we already have [1,2..100]
03:48:49 <arw_> its an instance of "do what I wish"-programming, which might work as soon as computers can read minds...
03:48:51 <gfixler> jle`: yes, thank you
03:49:01 <gfixler> arw_: no, we can just make it make sense
03:49:05 <jle`> [1,2..100] is also "undecideable" if you want to look at it that way
03:49:05 <gfixler> language is about design
03:49:18 <jle`> gfixler: you mean like an iterate syntax
03:49:19 <gfixler> [1,(^2)..] would be fun
03:49:21 <gfixler> yes
03:49:26 <jle`> > iterate (^2) 1
03:49:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:49:32 <hyPiRion> hehe
03:49:33 <jle`> er
03:49:39 <KaneTW> [1,(^2)..] looks nice
03:50:01 <jle`> how would you desugar [1,f..]... map f [1..] ?
03:50:16 <KaneTW> probably
03:50:18 <jle`> [1,(*2),..] desguaring to iterate (*2) 1 makes more sense to me
03:50:25 <jle`> > iterate (*2) 1
03:50:27 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
03:50:34 <gfixler> jle`: yeah, sorry, (*2)
03:51:09 <KaneTW> maybe [^2, 1..] for map
03:51:10 <gfixler> [(*2),1..8]
03:51:17 <jle`> yeah, [x,f...] makes sense as iterate f x
03:51:29 <gfixler> great, when can we have this in the Prelude?
03:51:31 <phaazon> hey, which FRP framework is both the simplest and fastest right now?
03:51:34 <gfixler> good meeting
03:51:35 <phaazon> I have my own
03:51:39 <jle`> it's more like a language extension
03:51:40 <phaazon> which is very simple
03:51:47 <jle`> phaazon: it depends on the approach you are talking about
03:51:48 <gfixler> jle`: is anything not a language extension?
03:51:50 <phaazon> but I guess I should use one from hackagedb
03:51:53 <arw_> why not just an operator as an alias for iterate?
03:51:58 <jle`> gfixler: yes...FTP etc.
03:52:08 <phaazon> jle`: I don't want complex things like « network » of signals and so
03:52:08 <jle`> arw_: that is nice :O
03:52:11 <arw_> like 2 ¤ (*2) or something
03:52:19 <gfixler> as a relative newb, I feel like there's about a decade of language extensions bolted on to haskell
03:52:27 <jle`> phaazon: different approaches are faster in different situations
03:52:37 <gfixler> arw_: containment
03:52:40 <gfixler> whatever that's called in math
03:52:41 <phaazon> I think I like classical FRP
03:52:43 <jle`> push-pull would be bad for real-time games...but arrowized frp would be bad for gui's
03:52:46 <phaazon> with first class value
03:52:53 <phaazon> yeah
03:52:53 <gfixler> grouping
03:52:57 <phaazon> it's for a realtime animation
03:53:00 <phaazon> with my 3D engine
03:53:01 <arw_> gfixler: parentheses :)
03:53:06 <gfixler> arw_: gross
03:53:09 <arw_> gfixler: you would need [] anyways...
03:53:11 <phaazon> I'll be mostly do switching
03:53:14 <gfixler> if I want parens, I have lisp
03:53:16 <jle`> netwire is probably the most modern thing at this point
03:53:27 <jle`> it's fairly tuned too i think
03:53:28 <phaazon> since I want to be able to represent behaviors in a « timetable »
03:53:31 <KaneTW> > let (><) = iterate; take 10 $ *2 >< 2
03:53:32 <lambdabot>  <hint>:1:31: parse error on input ‘*’
03:53:39 <KaneTW> > let (><) = iterate; take 10 $ (*2) >< 2
03:53:39 <phaazon> netwire, ok
03:53:40 <lambdabot>  <hint>:1:40:
03:53:40 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:53:41 <phaazon> thanks
03:53:51 <KaneTW> well something along those lines
03:53:51 <gfixler> there's probably a library full of useful sequences
03:53:56 <KaneTW> not sure how to get lambdabot to print it
03:54:10 <jle`> phaazon: np...netwire is the current king in pull-frp
03:54:12 <gfixler> import Number.Sequences; pows2
03:54:26 <jle`> along the lineage of fran, yampa, etc.
03:54:36 <arw_> > let (¤) = iterate ; take 10 $ (*2) ¤ 2
03:54:37 <jle`> by king i mean the main modern implementation
03:54:37 <lambdabot>  <hint>:1:39:
03:54:37 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:54:50 <arw_> hm, not the angulare brackets...
03:54:52 <phaazon> pull?
03:54:54 <phaazon> like
03:54:56 <phaazon> rendering
03:54:56 <jle`> you need "in" arw_
03:54:59 <phaazon> pulling events
03:55:00 <phaazon> rendering
03:55:01 <phaazon> pulling events
03:55:04 <phaazon> and so on?
03:55:16 <jle`> it's not quite pull in that sense
03:55:19 <gfixler> arw_: using that in other expressions, suddenly I'm well past 160 characters
03:55:25 <jle`> it's that the results are demand-driven
03:55:27 <KaneTW> > let (><) = iterate in take 10 $ (*2) >< 2
03:55:28 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
03:55:33 <gfixler> arw_: and I do realize I'm treading dangerously close to reinventing Perl
03:55:35 <KaneTW> there we go, thanks jle`
03:55:53 <jle`> phaazon: the entire system is updated/re-outputted at every timestep
03:56:01 <arw_> gfixler: google an ancient language called APL. then try to figure out why people had to have special keyboards for that one...
03:56:02 <jle`> re-calculated
03:56:18 <jle`> which is kind of silly for GUI's, but makes sense for things like physics engines
03:56:18 <gfixler> KaneTW: not bad, but [(*2),1..10] is much smaller
03:56:21 <KaneTW> yeah
03:56:31 <KaneTW> i like [(*2), 1..10] more
03:56:45 <jle`> > (*2) <$> [1..10] -- ..?
03:56:46 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
03:56:52 <arw_> gfixler: and haskell is already well past the perl-level with respect to unreadable obtuse operators.
03:56:56 <gfixler> jle`: but then I need to import applicative
03:57:04 <gfixler> arw_: tell me about it
03:57:29 <arw_> gfixler: i won't, lunchtime :)
03:57:30 <jle`> i don't know any haskell file i've written that doesn't import applicative
03:57:50 <gfixler> jle`: I'm working on my golf game here
03:58:15 <jle`> and you're counting your imports?
03:58:19 <jle`> as your golf score?
03:58:25 <KaneTW> exactly
03:58:28 <gfixler> characters
03:58:37 <jle`> characters spent on imports count?
03:58:41 <gfixler> I love the expressiveness of Haskell, but often feel like I'm adding 10 lines of imports for little things
03:58:49 <jle`> that's not really a big deal
03:58:52 <gfixler> so I have a 30 line file
03:59:46 <gfixler> I'm coming from about 6 years of Python
03:59:48 <jle`> can't really see why that's a bad thing
03:59:55 <gfixler> I feel like I rarely imported anything over there
04:00:15 <jle`> so you are trying to fit your python style/intuition into haskell style/intuition?
04:00:19 <jle`> that can't go wrong :)
04:00:30 <gfixler> jle`: e.g. watching jekor's videos, he's constantly going "Oh, right... I need to import... what was it? System... hmmm."
04:00:35 <gfixler> it's just a speed bump
04:00:50 <gfixler> jle`: no, I just feel like any Haskell work is always a big import party
04:00:53 <gfixler> even little things
04:00:55 <gfixler> even 1-liners
04:00:58 <jle`> having to import it, or pretending as if it's not offered?
04:01:09 <gfixler> jle`: you're being an apologist, I think
04:01:12 <jle`> i don't really see why that's a bad thing
04:01:15 <TheLemonMan> silly question here, I've stumbled across the (<$) operator while reading the Functor typeclass, is there something special about that ?
04:01:25 <gfixler> I don't think it's wrong to note that Haskell seems to constantly require a few imports to do anything
04:01:27 <jle`> TheLemonMan: it's mostly there to allow for optimized implementations
04:01:44 <jle`> gfixler: it's not wrong, but i'm not sure why it's a bad thing
04:01:58 <gfixler> bad may be too strong a word
04:02:03 <gfixler> mildly unpleasant
04:02:18 <jle`> in the case of not importing Applicative...it's probably more of a speed bump to re-write your own (<$>) than it is to import Control.Applicative
04:02:28 <KaneTW> i honestly don't mind imports
04:02:39 <jle`> i don't really find anything unpleasant about it actually :|
04:02:50 <jle`> it might just be a culture clash
04:02:51 <gfixler> that's fine
04:02:59 <gfixler> annoyances are subjective
04:03:29 <gfixler> I just feel the nagging of always trying to run a line of code and going "What? Oh, right... I need to import foo"
04:03:30 <jle`> but to avoid writing cleaner code because you don't want to import something?
04:03:47 <jle`> or is this more a comment on the design of base
04:03:49 <gfixler> jle`: who said anything about that?
04:04:09 <jle`> i mentioned using (<$>), but you said you'd avoid it because you don't want to import Control.Applicative
04:04:10 <TheLemonMan> https://hackage.haskell.org/package/base-4.7.0.2/docs/GHC-Base.html greets me with a 404, is that intended? :)
04:04:18 <gfixler> jle`: oh, I'm playing golf atm
04:04:31 <gfixler> of course I don't want to add 40 more characters for <$>
04:04:33 <roelof> someone who can help me with this problem : http://mail.haskell.org/pipermail/beginners/2015-February/014722.html
04:04:36 <jle`> ah ok, we might have been talking about different things
04:04:57 <gfixler> jle`: there's another aspect here - live coding
04:05:13 <gfixler> I have a window of literally 5-10 seconds with producers, managers, artists, etc
04:05:21 <gfixler> if I type for longer than about 8 seconds, they excuse themselves and run away
04:05:47 <gfixler> when I got uber fast with Python and Vim, I could actually hold people's interest indefinitely
04:05:56 <tasker> Is there a way to turn of specific warning flags with ghc? E.g. I use -Wall, but one of the flags enabled by it I would like to disable.
04:05:57 <gfixler> because I could make almost everything happen in about 5-10 seconds
04:06:05 <gfixler> it radically changed things at work
04:06:18 <gfixler> I had one impatient person spend the entire day standing next to my chair, designing things with me
04:06:21 <gfixler> because we could work 'live'
04:06:39 <gfixler> one "Oh, whoops, I need to import... hang on," and they would have left, and the dynamic would have been gone
04:06:50 <gfixler> (it's absurd - they're so impatient in my industry)
04:07:13 <jle`> there is probably a lot to talk about in that aspect :)
04:07:28 <gfixler> jle`: it's something I didn't know existed for 10 years in the industry, and then I made it happen
04:07:32 <jle`> in any case i probably have to sleep now, waking up in some small amount of hours ><
04:07:34 <gfixler> and I sang that "What's this?" song
04:07:39 <gfixler> yeah, me too
04:07:45 <hyPiRion> gfixler: I feel Haskell values thinking about the problem instead of just "hack on it until it works"
04:07:46 <jle`> night!
04:08:02 <gfixler> hyPiRion: true, but my industry doesn't even know what that means
04:08:09 <gfixler> it's 3 minutes later, why haven't we shipped?!
04:08:26 <RchrdB> gfixler: get a jar on your desk, fill it with confectionary with REALLY difficult wrappers. When you need someone to stand by for 30 seconds, hand them a candy, type for a bit while they're busy wrestling with it, then grab them again? ;)
04:08:43 <gfixler> RchrdB: I like it - now we're thinking outside the box
04:08:54 <gfixler> we could also drug the candy to slow them down
04:09:40 <RchrdB> More serious suggestion, use a "standard" preamble for your modules with all the modules in creation imported (often qualified with short names)?
04:09:53 <RchrdB> (and maybe clean up the excess imports later)
04:10:29 <gfixler> RchrdB: I've thought about that - do imported but unused things do anything bad, like increase file size?
04:10:43 <tdammers> hehe yeah... managing imports is one of my biggest pain points with Haskell
04:10:49 <gfixler> blerg
04:11:00 <gfixler> is this normal? I come from a very dynamic world
04:11:10 <tdammers> but, anyway, you could just have hlint tell you which imports are redundant
04:11:14 <RchrdB> I wouldn't be surprised if they did but I would be surprised if they did *prohibitively*
04:11:14 <tdammers> or maybe even -W
04:11:29 <hyPiRion> tdammers: -Wall does it
04:11:41 <roelof> I think it not normal that you cannnot do your work properly
04:11:42 <gfixler> -Wall throws out all the excess?
04:11:43 <tdammers> hyPiRion: ah, yes, right, that's  the one
04:11:47 <tdammers> no
04:11:53 <tdammers> -Wall tells you which imports are redundant
04:11:58 <gfixler> oh
04:12:03 <tdammers> "Warning: the import of Foobar.Baz is redundant"
04:12:24 <gfixler> and I'm guessing that unused *sections* of an import are never trimmed
04:12:28 <gfixler> i.e. functions that never get called
04:12:33 <tdammers> -Wall -Werror, slap a makefile around cabal, then in vim do :make and then step through errors with :cc / :cn
04:12:33 <RchrdB> gfixler: it's not normal but I wouldn't claim it's bad. AIUI there are studies linking the length of the change-test-look-at-it cycle with developer productivity, so any pressure on that is indirect pressure to do better. :)
04:13:18 <gfixler> RchrdB: I feel my ability to understand and go deeper into my code improved along with my speedups, and test-speed improvements
04:13:24 <gfixler> but it was Python, and all crap, so who knows?
04:13:48 <gfixler> I have a handful of libraries where I religiously followed TDD, and none of those has ever broken
04:14:04 <gfixler> or I should say, they've broken before every change, and then I've fixed the breaks
04:14:21 <gfixler> I've been wrong occasionally about something, but then the tests were passing with wrong info, which is still correct
04:14:25 <roelof> someone who can help me with this problem : http://mail.haskell.org/pipermail/beginners/2015-February/014722.html
04:14:37 <hyPiRion> tdammers: I'm very pleasant with the Haskell mode in emacs with flymake, which highlights all errors and recompiles on save. Not sure if that's available with same goodness in vim, but it has certainly helped me a lot writing haskell quickly
04:14:42 <hyPiRion> that and type holes
04:17:13 <RchrdB> gfixler: cool. :)
04:17:18 <tdammers> haha, recompile-on-save would totally destroy my performance
04:17:28 <tdammers> I go :w all the time
04:17:51 <RchrdB> tdammers: I think flymake's asynchronous (and compilation is pretty quick with -O0)
04:18:19 <hyPiRion> yeah, it's async and pretty fast from my experience
04:18:26 <RchrdB> though asynchronicity is a bit of a difficult story in vim plugins, apparently (which is one of the motivations for neovim)
04:18:35 <hyPiRion> (at least on a 5-6kloc project)
04:19:00 <tdammers> I like my vim vanilla
04:19:05 <thebnq> especially with TH :s
04:19:25 <tdammers> almost all of the integration with external tools that I use goes through built-in mechanisms like :!
04:20:18 <RchrdB> :! cuts out a region, pipes it into the stdin of a command, and then puts the command's stdout back in its place, right?
04:21:44 <orion> Hi. This code does not do what I expect: http://lpaste.net/4660709080086609920
04:22:24 <orion> It's supposed to split a ByteString in to an array of smaller ByteStrings whose length is dictated by an array of Ints.
04:22:33 <orion> I get the following in GHCi:
04:22:34 <orion> Prelude B> split [3, 3, 3] "1234567890"
04:22:34 <orion> ["123","456","789"*** Exception: <interactive>:11:5-85: Non-exhaustive patterns in function split
04:22:44 <orion> Does anyone know where I might have messed up?
04:23:16 <thebnq> orion: you missed the case for when theres one thing left in the list
04:23:52 <thebnq> wait nevermind i'm an idiot
04:28:11 <xkb> where does cabal dump a package on "cabal get" on mac?
04:28:18 <xkb> using halycon btw
04:29:08 <roelof> no one who can help me on the tower of hanoi problem  ?
04:29:37 <mrkkrp> ski, OK, here is some stuff about that infinite list of integers: https://gist.github.com/mrkkrp/e859d185abef1a7b776d#file-mida-simplified-md
04:30:23 <thebnq> orion: are you using OverloadedStrings
04:30:29 <orion> thebnq: Yes.
04:30:46 <absence> i was reading about basic image processing using a "pointer" comonad (array/vector + coordinate) and wondered if it would be feasible to do more advanced operations like image resizing. it would require that the type also has a "target width,height" and some kind of filter function that can be used by extract to combine multiple lookups. it's starting to feel like the comonad abstraction is just in the way (artificial wrapper type with extra state
04:30:59 <thebnq> orion: it works for me (but i did change ByteString to B.ByteString since its a qualified import)
04:31:53 <orion> thebnq: In GHCi?
04:32:08 <hpc> absence: you should look for abstractions over matrix math
04:32:53 <thebnq> orion: no, it complains that the string isn't a byteString, weird
04:33:05 <jstolarek> http://lpaste.net/120693
04:33:14 <jstolarek> any idea why this does not work?
04:33:16 <absence> hpc: hm, some keywords to search for?
04:33:23 <jstolarek> code copied from https://wiki.haskell.org/Type_arithmetic
04:33:47 <jstolarek> when I replace empty data types with data kinds it works
04:33:47 <hpc> absence: not particularly, that part of math isn't one i know very well
04:34:14 <thebnq> orion: but it does if i set it in ghci too so not sure :(
04:34:37 <orion> thebnq: Can you paste your entire GHCi session?
04:34:43 <absence> hpc: ok, thanks for pointing in a direction anyway :)
04:34:59 <thebnq> there are other splits in scope though so i also did Main.split
04:35:03 <EvanR> absence: repa, linear, juicypixels
04:37:13 <absence> EvanR: ah cool, was already using juicypixels for this :) i know of, but am not familiar with, the otherws. will check them out, thanks
04:37:57 <RchrdB> "linear algebra" is what pretty much all matrix libraries are labelled as. :)
04:39:20 <thebnq> orion: http://lpaste.net/120694
04:39:55 <orion> thebnq: Wow, strange that it's not working for me.
04:40:10 <orion> Although, I am typing the function in directly. I am not loading it from a file.
04:40:29 <thebnq> oo
04:41:28 <divVerent> what is the proper way to multiply a Ratio Int by an Int?
04:41:40 <divVerent> my current code uses r * (i % 1), but that can't be the proper way, or is it?
04:41:45 <EvanR> upgrade the Int to a Ratio Int
04:42:04 <divVerent> right, but how? It comes from another module.
04:42:18 <EvanR> :t fromIntegral
04:42:19 <lambdabot> (Num b, Integral a) => a -> b
04:42:21 <absence> how does linear compare to vector-spaces?
04:42:21 <chaosmasttter> orion: do you have multiline mode enabled?
04:42:33 <divVerent> OH, fromIntegral also works for Ratio Int
04:42:37 <jedai> divVerent: Why would it not be proper ?
04:42:41 <orion> chaosmasttter: Ah, no.
04:42:58 <EvanR> divVerent: (% 1) also works
04:43:01 <thebnq> oh!!! tricky i see
04:43:06 <divVerent> jedai: I confused the type classes, that's why
04:43:13 <thebnq> yeah, that would lose the first case ..
04:43:26 <divVerent> I was thinking of toRational when trying to find the way
04:43:31 <divVerent> but that only works for Rational == Ratio Integer
04:43:33 <chaosmasttter> and you don't use brackets instead of layout? so you are just overwritting the first definition
04:43:37 <divVerent> while I have another integral type
04:44:09 <orion> chaosmasttter: Oh! Interesting.
04:44:40 <orion> I totally overlooked that. Thank you!
04:44:58 <divVerent> thanks!
04:45:14 <thebnq> nicely spotted
04:47:51 <vin-ivar> quick question
04:47:55 <vin-ivar> installing a package from cabal
04:48:01 <vin-ivar> a particular package
04:48:13 <vin-ivar> says "Could not find module Network.URI"
04:48:26 <vin-ivar> and "add network-uri" to your .cabal file
04:48:40 <vin-ivar> any suggestions?
04:50:35 <absence> ah, linear is polymorphic, vector-spaces is monomorphic
04:51:46 <jedai> vin-ivar: which package ?
04:51:53 <vin-ivar> gf
04:52:02 <vin-ivar> (grammatical framework)
04:52:19 <vin-ivar> i think it might be a problem with the package, but it looks like 50 odd people have installed it this last month
04:53:08 <jedai> vin-ivar: it's network that was recently split into network and network-uri
04:53:55 <vin-ivar> I see
04:54:02 <vin-ivar> is there anything I can do?
04:54:05 <jedai> vin-ivar: gf will have to update its cabal file
04:54:11 <vin-ivar> I think i'll download the tarball and modify the .cabal file
04:54:14 <jedai> in the meantime, you can do it yourself
04:54:30 <vin-ivar> that way?^
04:54:36 <jedai> right, note that cabal can do the download and untar for you
04:55:02 <vin-ivar> ah, I already downloaded it
04:55:02 <jedai> vin-ivar: cabal fetch gf
04:55:08 <vin-ivar> thanks, i'll do that
04:55:09 <jedai> ok then :)
04:55:19 <vin-ivar> cheers :)
04:55:36 <jedai> or maybe cabal get gf ?
04:55:48 <gavilancomun> @pl sindPerm n = cartProd [1.. (sindj n)] [1 .. (sindj n)]
04:55:48 <lambdabot> sindPerm = ap (cartProd . enumFromTo 1 . sindj) (enumFromTo 1 . sindj)
04:55:54 <vin-ivar> get
04:55:55 <vin-ivar> yes
05:02:49 <phaazon> how does clock handle time?
05:03:08 <phaazon> is it accurate enough for microseconds?
05:06:06 <edwardk> absence: a comonad will never 'change the shape' of the structure during 'extend. If you have 500 'a's in it before, you'll have 500 'b's in it after.
05:07:11 <phaazon> I love how a comonad focus on a part of the structure
05:07:17 <phaazon> but see the whole thing at the same time
05:07:18 <phaazon> :)
05:07:28 <phaazon> it's like a zoomin with perspective
05:07:35 <edwardk> yep
05:07:46 <phaazon> focuses*
05:07:50 <phaazon> sees*
05:09:53 <phaazon> > extend Data.List.NonEmpty.length $ "hey" :| ["I","just","met","you"]
05:09:54 <lambdabot>  Not in scope: ‘extend’Not in scope: ‘Data.List.NonEmpty.length’Not in scope:...
05:09:54 <lambdabot>  Perhaps you meant one of these:
05:09:54 <lambdabot>    ‘:+’ (imported from Data.Complex),
05:10:07 <phaazon> @let import Control.Comonad
05:10:08 <lambdabot>  <no location info>:
05:10:08 <lambdabot>      The package (tagged-0.7.2) is required to be trusted but it isn't!
05:10:16 <phaazon> what a pity :)
05:11:12 <phaazon> howevery
05:11:19 <phaazon> I've never used a comonad in my codebase
05:12:06 <edwardk> i tend to use lots of little comonads
05:12:26 <edwardk> but they aren't the all encompassing thing that the top level monad you often use to organize your code is
05:12:40 <phaazon> what for?
05:12:43 <edwardk> it is 'easy to get out of a comonad'
05:13:02 <edwardk> well, say names with metadata in a compiler.
05:13:17 <edwardk> data Name a = Name String a -- is a comonad
05:13:28 <phaazon> yeah
05:13:30 <edwardk> now we can use that for bound variables
05:13:31 <phaazon> extract is trivial
05:13:35 <phaazon> duplicate as wel
05:13:37 <phaazon> well*
05:13:51 <phaazon> oh I see
05:13:52 <edwardk> so you can now remember the original name when showing it
05:13:57 <phaazon> you use extend to lookup the names?
05:14:00 <merijn> A comonad is like a burrito
05:14:06 <merijn> It's hard to keep things inside...
05:14:14 <phaazon> ahah merijn :D
05:14:55 <edwardk> phaazon: extract gives you whatever you are going to use for the locally nameless representation, the String gives you the original variable name as a string to show as a hint
05:15:08 <edwardk> other comonads that come up for me a lot:
05:15:36 <phaazon> edwardk: I mean
05:15:45 <edwardk> data Fold a b = forall r. Fold (r -> b) (r -> a -> r) r -- is a Comonad, Profunctor, etc.
05:15:56 <edwardk> its Applicative, even a Monad (badly)
05:16:11 <phaazon> you could extend a Name to change it's meta-data without forgetting its original name and metadata
05:16:22 <edwardk> phaazon: yeah
05:16:23 <phaazon> its*
05:16:42 <edwardk> that kind of thing happens a lot while pretty printing and the like
05:17:00 <phaazon> yeah
05:17:09 <phaazon> interesting abstraction
05:17:13 <phaazon> those comonads :)
05:18:11 <phaazon> oh god
05:18:17 <edwardk> we also use them for binders in ermine
05:18:19 <phaazon> netwire sounds gorgeous
05:18:53 <edwardk> https://github.com/ermine-language/ermine/blob/master/src/Ermine/Builtin/Pattern.hs#L52
05:19:04 <phaazon> is there a day we'll lose specific instances for very abstract operators and functions? like (.), id, mapM and so on?
05:19:16 <edwardk> ?
05:19:31 <lush> hi everybody
05:19:31 <edwardk> you mean the concrete definitions and just be dealing with classes?
05:20:22 <edwardk> anyways lots of the comonads i have are simple 'pair of x with a' kinds of comonads, Spanned, Careted, Rendered, etc. in trifecta
05:20:35 <edwardk> the 'It r' type in trifecta is a Comonad as well as a Monad.
05:20:59 <edwardk> by LOUDS encoding in my succinct package has a comonadic zipper for walking it
05:21:02 <edwardk> er my
05:21:06 <merijn> edwardk: I'd be interested in a "how trifecta works" blogpost if you have time to write one in your copious spare time ;)
05:21:26 <edwardk> merijn: part of why i haven't written it is the looming impending rewrite of the internals
05:21:29 <merijn> I see all sorts of ropes, and what nots in the API and I have no idea how any of it works >.>
05:22:08 <phaazon> edwardk: yeah
05:22:18 <phaazon> (.), in Prelude, should be usingthe Category typeclass
05:22:20 <phaazon> not (->)
05:22:25 <phaazon> same thing for id
05:22:32 <phaazon> and mapM should be traverse, from Traversable
05:22:40 <phaazon> mapM_ should be traverse_, from Foldable
05:22:43 <phaazon> and so on
05:22:44 <edwardk> phaazon: another fun thing is that i actually make a fair bit of use of comonads in the category of profunctors: http://hackage.haskell.org/package/profunctors-4.3.2/docs/Data-Profunctor-Monad.html
05:22:53 <edwardk> and the associated monads
05:23:14 <phaazon> yeah but
05:23:18 <phaazon> you're an UFO
05:23:21 <phaazon> :D
05:23:25 <lush> Ehm the All About Monads-Tutorial said, that do-notation is a built-in feature of haskell as a language.. is that true although Monads itself aren't built-in but are just a normal typeclass etc.?
05:23:43 <edwardk> =P
05:23:49 <jedai> lush: it's syntactic sugar
05:24:08 <phaazon> lush: it's a standard typeclass
05:24:09 <jedai> lush: for the usage of >>, >>= nd so on
05:24:24 <phaazon> do notation just gets reduced to (>>) and (>>=)
05:24:32 <lush> I mean is do-syntax built in the compiler or is it just sth like a special library or so?
05:24:35 <lush> I know what do does
05:24:38 <jedai> lush: so strictly speaking, it can be used for things that aren't monad but use the same operators name
05:24:40 <lush> I just wonder how it is implemented
05:24:51 <edwardk> Tambara is a very fun little comonad. it takes any profunctor and upgrades it with the ability to be an instance of "Strong"
05:25:06 <phaazon> edwardk: you said Rendered
05:25:11 <phaazon> is that a first class value?
05:25:12 <jedai> lush: as I said, it's just syntactic sugar, it's desugared by the compiler, the report has a specification of how
05:25:15 <phaazon> my Rendered is not
05:25:20 <phaazon> it's an opaque type
05:25:21 <phaazon> like
05:25:24 <phaazon> data Rendered = ..
05:25:29 <edwardk> phaazon: er.. dev branch =)
05:25:35 <lush> jedai: so while Monads are just library defined, do syntax which kinda depends on monads is built in the compiler? :O
05:25:38 <phaazon> :)
05:25:39 <edwardk> i did a quick grep on my working dir
05:25:57 <phaazon> however, my Rendered is a Monoid
05:26:00 <phaazon> which is pretty neat :)
05:26:03 <jedai> lush: basically do { x <- stuff; other x } is desugared to "stuff >>= \x -> other x"
05:26:14 <ski> lush : do you know any lisp ?
05:26:17 <phaazon> jedai: that's not the question they asked about
05:26:26 <phaazon> they wanted to do whether that's hardcoded in GHC
05:26:27 <lush> ski: nope
05:26:33 <jedai> lush: then it just use the >> and >>= operators in the current namespace
05:26:34 <phaazon> or by a library
05:26:36 <phaazon> like base
05:26:38 <lush> jedai: I know how it's desugared ;)
05:26:45 <merijn> u-ou: Do syntax is syntactic sugar built into the compiler, yes
05:26:47 <phaazon> lush: I asked for that a few days ago
05:26:47 <merijn> eh
05:26:50 <merijn> s/u-ou/lush
05:26:55 <lush> ok ty merijn
05:27:02 <edwardk> other comonads i use a lot, moore machines (which are equivalent to the folds i mentioned), Cofree, the 'Bazaar' from lens.
05:27:02 <ski> lush : the desugaring rules are built-in to the language
05:27:05 <jedai> lush: so it's usually defined as the operator of the Monad typeclass (which is not hardcoded)
05:27:10 <merijn> lush: Same way that : and [] are built-in too
05:27:16 <lush> Seemed weird to me because Monads weren't built-in the langauge
05:27:32 <merijn> lush: Why? The first few versions of haskell didn't have monads
05:27:33 <edwardk> i use it in little things like the Token type i use in my LZ78 monad in 'compressed', but that is another simple environment comonad like Name above.
05:27:52 <merijn> Monads were introduced like 5-8 years after the first haskell version, I think?
05:28:12 <lush> merijn: Well I don't know.. I just wondered whether it would be possible to implement do just through standard haskell
05:28:18 <merijn> lush: Applicative is even younger, I think no one thought of it until 2004 :)
05:28:28 <jedai> lush: they're in the Report so they're kinda "built-in" the _language_, they just do not require special hardcoding in the compiler (as so many things in Haskell, most basic types are just defined in the Prelude)
05:28:55 <phaazon> edwardk: i SEE
05:28:58 <phaazon> I see*
05:28:59 <phaazon> thanks
05:28:59 <merijn> lush: You can arbitrarily make up new syntax, no. (Well actually, you kinda can, using quasiquoters)
05:29:00 <edwardk> a ton of stream comonads, all the weird kan-extension uses as such, memoized functions, etc
05:29:19 <lush> jedai: that's it! As most things were basic types and so on I thought maybe do would also be "normal" haskell and nothing compiler specific
05:29:21 <edwardk> i get a fair bit of mileage out of asking 'is this a comonad'? when i write a new data type
05:29:31 <edwardk> oh yeah and the snaplet config stuff
05:29:33 <jedai> lush: you can't implement do directly in the language, though you can use Template Haskell and quasiquoter to simulate it
05:29:35 <lush> merijn: ok ty
05:29:44 <lush> jedai: ok ty too
05:30:04 <merijn> In fact, quasiquoters let you implement arbitrary custom syntax (if you can live with a few extra brackets)
05:30:10 <edwardk> extend f w@(Snaplet c _) = Snaplet c (f w) -- is obviously the same as the simple environment comonads i mentioned
05:31:07 <edwardk> i have a bunch of indexed comonads as well, indexed either a la atkey or a la mcbride
05:31:24 <edwardk> i'm still on the fence which of those two styles i prefer
05:31:52 <edwardk> the atkey ones are intuitive for folks, the mcbride ones are more powerful, but require a couple extra boxes to float around at runtime
05:31:55 <ski> lush : in the lisps, macros can be used (by a programmer) to extend the language with new syntactic forms (implemented in terms of translating them to preexisting syntactic forms). `do' in Haskell is like such a macro, except there's no way for a programmer to define new such macros (except via TH, and then you're not as free in the concrete syntax)
05:33:09 <lush> ski: wow that's cool ^^
05:33:40 <phaazon> edwardk: mcbride?
05:34:59 <Procian> As in Conor McBride, and atkey as in Bob Atkey.
05:37:15 <Procian> Atkey seems like a good name to have for someone who indexes things.
05:46:16 <edwardk> phaazon: https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf
05:46:27 <edwardk> Procian: i turned his name into a newtype
05:48:37 <edwardk> i called him 'At' in https://github.com/ekmett/indexed/blob/master/src/Indexed/Types.hs#L107 but in the first version of 'hask' before i released it to hackage there as an Atkey data type that converted McBride style monads into Atkey ones
05:49:17 <edwardk> and there is a Coatkey construction that you can use to take a "Kleisli arrows of outrageous fortune" encoded comonad, and construct a 2 parameter indexed comonad
05:49:23 <edwardk> that thing took me _forever_ to find
05:49:54 <edwardk> and in the indexed package its called 'Coat'. So when I walked up to Bob at ICFP a couple of years ago and told him I turned him inside out and made him into a 'Coat' it made for a very awkward moment.
05:50:49 <edwardk> (it had sounded far less stalkerish in my head when i was saying it at the time)
05:50:59 <nshepperd> haha
05:53:19 <edwardk> Mind you Bob Atkey works with Conor McBride regularly, so it can't be the weirdest thing that man has heard in his day. ;)
05:53:53 <nshepperd> co-at
05:56:48 <gavilancomun> @pl  n = 2 * n + 1
05:56:48 <lambdabot> n = fix ((1 +) . (2 *))
05:58:59 <TheUNKNOWNawaits> >
05:59:24 <gavilancomun> @pl a + b + 2 * a * b
05:59:25 <lambdabot> a + b + 2 * a * b
05:59:42 <gavilancomun> @pl n = a + b + 2 * a * b
05:59:42 <lambdabot> n = a + b + 2 * a * b
06:02:35 <mrkkrp> Here is more detailed description of that problem with infinite lists of integers, that I posted a few hours ago https://gist.github.com/mrkkrp/e859d185abef1a7b776d#file-mida-simplified-md
06:04:24 <Procian> edwardk: Do you manage to use most of this stuff in your Scala coding as well, despite the abstractions costing more over there?
06:04:45 <edwardk> Procian: yes, i actually use comonads more often in scala
06:05:20 <edwardk> working with monad transformers is hard in scala, but working with a comonad is easy. and since every comonad gives rise to a monad transformer i often bundle up the extra behavior i want into a comonad i carry around manually in my code
06:05:54 <edwardk> its easier for me to pass around an object with an extra bit of state and all the ComonadApply baggage as members than it is to slip into a transformer
06:06:21 <Procian> Ah that's interesting. Can all monad transformer stacks be expressed in this way?
06:06:50 <edwardk> e.g. https://github.com/ermine-language/ermine-legacy/blob/master/src/main/scala/com/clarifi/reporting/ermine/parsing/Localized.scala#L10
06:06:55 <edwardk> not all
06:06:56 <benzrf> objects???
06:07:14 <edwardk> but state, reader, writer, and a few others
06:07:47 <edwardk> Localized there is a comonad i use while parsing to deal with names and effects on the current state to unbind them all
06:08:55 <edwardk> we use it in a bunch of code for dealing with patterns: https://github.com/ermine-language/ermine-legacy/blob/master/src/main/scala/com/clarifi/reporting/ermine/parsing/PatternParsers.scala#L75
06:09:20 <edwardk> Parser[Localized[A]] is often easier to work with than Localized[Parser,A]
06:09:27 <edwardk> where the latter would be a transformer
06:10:46 <edwardk> benzrf: it is scala, there objects exist. ;)
06:11:11 <Procian> Cool! I've got some reading to do there. I'm feeling quite silly at the moment with transformers in Scala.
06:11:38 <edwardk> there isn't much written in the topic, just some ramblings by me describing how i work
06:12:36 <Procian> At least the code's there.
06:13:11 <phaazon> hm
06:13:21 <edwardk> also note that that code predates the modern wave of Unapply tricks
06:13:29 <phaazon> I don't get the difference between « at 3 » and « asSoonAs . at 3 » with netwire
06:13:31 <edwardk> so you may be able to get by with just transformers now
06:13:33 <phaazon> anyone ?
06:13:36 <edwardk> at the time it was pretty terrible
06:14:12 <gavilancomun> @pl sieveSundaram n = map sundCalc (sundDrop (sundDelete (sundPerm n)) [1 .. n])
06:14:12 <lambdabot> sieveSundaram = map sundCalc . ap (sundDrop . sundDelete . sundPerm) (enumFromTo 1)
06:17:18 <merijn> phaazon: at is a wire the fires an Event at some point in the future
06:17:50 <merijn> phaazon: asSoonAs is a wire that inhibits UNTIL some event fires and then keeps producing the value by the last fired event
06:18:13 <merijn> phaazon: Remember that Event's are discrete things, they happen AT some point in time
06:18:24 <merijn> Wire's have time continuous behaviour
06:18:33 <merijn> These are fundamentally different
06:18:43 <merijn> For details I would read Conal's FRP papers
06:23:17 <iasoon> Hey all, I was wondering whether it is possible to implement branch and bound algorithms using a list monad
06:24:44 <iasoon> The branching part is quite obvious, but in order to prune you'd need the 'previous' optimal solution
06:24:45 <benzrf> i dunno, maybe
06:24:47 <phaazon> merijn: nope :(
06:24:49 <phaazon> on my machine
06:24:50 <iasoon> Of which I'm not sure how to access it
06:25:12 <phaazon> testWire clockSession_ (at 3 . 100) will generate 100 after 3
06:25:18 <phaazon> it fires up at 3
06:25:24 <benzrf> iasoon: perhaps you can do some sort of fold
06:25:26 <phaazon> and continuously fires up afterwhile
06:25:54 <benzrf> iasoon: er, dont listen to me, i dont know branch + prune
06:26:50 <phaazon> merijn: I thought that at 3 . 100 would inhibit every time but at 3
06:26:59 <Profpatsch> What is the general consenus about programming with Lists/Foldables/Traversables?
06:27:00 <phaazon> like (), (), (), (), (), 100, (), (), (), ()...
06:27:26 <Profpatsch> Use Lists if you don’t need any more internally?
06:27:34 <Profpatsch> Always user Foldable/Traversable?
06:27:37 <Profpatsch> *use
06:28:19 <Profpatsch> What about functions that call []-returning functions internally? Should they cast to Foldable/Traversable?
06:28:56 <Profpatsch> Same with numbers: Use Int or Integer?
06:29:12 <iasoon> benzrf: Well, I have been thinking about that as well
06:29:15 <Profpatsch> Although with the number stack it’s harder.
06:29:24 <iasoon> Quite similar to how you can define the fibonacci list in terms of itself
06:29:35 <Procian> Profpatsch: Do you mean whether to use Int of some a where Integral a?
06:30:17 <Profpatsch> Procian: The number stack was a bad example, it’s mainly the question of general vs. specific and when.
06:30:41 <Profpatsch> With []/Foldable/Traversable in particular.
06:34:02 <Profpatsch> I think that’s a good question for SO.
06:34:04 <Procian> Profpatsch: Not really sure about Foldable anymore, since it was discussed on reddit and here as not really satisfying any strong laws.
06:34:23 <Procian> I'm happy to write against traversable though.
06:36:54 <merijn> phaazon: I have no idea what the "fromInteger" instance of wires is
06:38:03 <phaazon> I guess it defaults to pure
06:39:37 <merijn> phaazon: Can you try "testWire clockSession_ (at 3 . now)"?
06:39:46 <merijn> oh, uh, wait
06:39:51 <merijn> now doesn't do what I thought
06:40:21 <merijn> "testWire clockSession_ (at 3 . time)" ?
06:40:52 <merijn> I would expect that to basically print the time "at 3"
06:40:59 <merijn> Is that right?
06:41:15 <phaazon> merijn: I think I got it
06:41:24 <phaazon> at is a wire that outputs an event
06:41:43 <phaazon> while asSoonAs is used to turn that into a behavior
06:41:46 <merijn> And that event contains the value of it's input at the time it fired
06:41:53 <merijn> Right
06:42:02 <phaazon> there might be something like
06:42:08 <phaazon> onlyWhen
06:42:09 <merijn> That's what my initial explanation was, btw ;)
06:42:16 <phaazon> so
06:42:24 <phaazon> asSoonAs . at 3 . pure "hey"
06:42:34 <phaazon> will inhibit till 3
06:42:43 <phaazon> afterwhile it will say "hey" forever
06:43:03 <merijn> Right
06:43:25 <phaazon> and I guess an Event has a Show instance
06:43:29 <phaazon> that's why I can see events
06:43:46 <phaazon> so testing the wire at 3 . "hey" produces "hey" only at 3
06:43:51 <phaazon> well, it should, I guess
06:43:53 <merijn> I would expect "asSoonAs . periodic 3 . time" to change the output time every 3 seconds
06:44:36 * hackagebot apiary-purescript 1.3.1 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-1.3.1 (HirotomoMoriwaki)
06:44:37 <phaazon> hm
06:44:39 <phaazon> so
06:44:50 <merijn> And I would expect "asSoonAs . dropE 1 . periodic 3 . time" to start inhibiting and after 3 seconds update the output time every 3 seconds
06:44:52 <phaazon> switch in netwire is a way to override inhibition
06:45:01 <phaazon> by providing a new wire to take place
06:45:17 <merijn> Right
06:45:23 <phaazon> for 3 . "hey" produces "hey" for 3 seconds
06:45:28 <phaazon> then inhibits
06:45:29 <phaazon> but...
06:45:46 <phaazon> for 3 . "hey" ---> "oh!" produces "hey" for 3 seconds, then outputs "oh!"
06:45:48 <phaazon> forever
06:45:52 <merijn> Yeah
06:45:54 <phaazon> that's pretty awesome
06:46:00 <merijn> Well
06:46:01 <phaazon> I think I'm gonna love that lib :D
06:46:10 <merijn> Depends on precedence of --->, but yeah ;)
06:46:12 <ab9rf> that's one i need to spend some time with
06:46:15 <phaazon> --> *
06:46:19 <phaazon> only one bend :D
06:46:27 <phaazon> hm
06:46:35 <ab9rf> no pun intended :)
06:46:35 <phaazon> for 3 . ("hey" --> "oh")
06:46:46 <phaazon> it will output "hey"
06:46:49 <phaazon> and never "oh"
06:46:56 <phaazon> because "hey" won't ever inhibit
06:46:57 <phaazon> right?
06:46:59 <merijn> netwire's pretty neat, the first few releases didn't really do "proper' FRP, but I think that's fixed now (I haven't really looked at the newest one)
06:47:02 <merijn> phaazon: Yeah
06:47:11 <ab9rf> phaazon: right
06:47:13 <phaazon> aj ofakj
06:47:16 <phaazon> oops
06:47:18 <phaazon> at least*
06:47:20 <phaazon> it's ultra sexy
06:47:36 <phaazon> I hope my 3D application can handle that
06:47:41 <phaazon> because it's really elegant :)
06:49:33 <phaazon> oh god that works
06:49:38 <phaazon> for 3 . 15 --> 314
06:49:45 <phaazon> that's ultra cute!
06:54:29 <phaazon> I wonder how I could implement special events for netwire
06:54:34 <phaazon> like keypresses
06:54:50 <phaazon> btw
06:54:57 <phaazon> Wire s e m a b
06:55:00 <phaazon> s is the global state
06:55:04 <phaazon> m the inner monad
06:55:08 <phaazon> a the input and b the output
06:55:12 <phaazon> what is e?
06:55:17 <phaazon> the event type?
06:56:27 <merijn> Inhibition type
06:56:52 <merijn> You can inhibit with types other than ()
06:57:06 <phaazon> oh yeah
06:57:07 <phaazon> the monoid
06:57:31 <merijn> 's' isn't state, it appears to be time
06:57:38 <phaazon> merijn: well
06:57:41 <phaazon> HasTime t s
06:57:42 <phaazon> for me
06:57:43 <phaazon> it's a state
06:57:48 <phaazon> it could have other things in there
06:58:30 <phaazon> hm, I guess I could write my own Session so that I produce time with clock's Monotonic clock
07:03:59 <nanomad> Hi, I've got a question/
07:05:34 <heatsink> Hi, I've got a question *leaves*
07:05:41 <phaazon> ahah
07:05:43 <phaazon> made me laugh
07:34:39 * hackagebot OpenGLRaw 2.1.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-2.1.0.0 (SvenPanne)
07:34:41 * hackagebot OpenGL 2.10.0.2 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.10.0.2 (SvenPanne)
07:37:42 <augur> for anyone who works on GHC: can you please make holes and undefined equivalent? thank you
07:38:17 <augur> i mean, equivalent for the type checker
07:40:40 <merijn> augur: You mean the ability to compile and run and only crash when trying to evaluate the hole?
07:40:51 <augur> merijn: no
07:41:02 <merijn> augur: Then what?
07:41:25 <augur> i mean the ability to actually type properly in spite of the presence of holes. for some reason there are lots of type errors that dont get detected if you have _ but replace it with undefined and they emerge
07:41:39 <merijn> heh
07:41:43 <merijn> That sounds like a bug
07:41:46 <merijn> Example?
07:42:46 <geekosaur> as I understand it, it *is* equivalent to undefined, just noisy about it. so that does sound like a bug
07:43:52 <merijn> geekosaur: Optionally noisy in 7.10 :>
07:45:06 <geekosaur> (moreover I'd wonder if such a bug means it sometimes reports the wrong type...)
07:45:29 <bergmark> augur, geekosaur: it doesn't sound like a bug to me, it just sounds like the type hole produces an error earlier than other errors?
07:45:46 <geekosaur> it's not an error
07:46:04 <geekosaur> it's a warning, it's basically undefined that outputs its inferred type as a warning at compile time
07:46:14 <geekosaur> no magic
07:46:14 <merijn> Actually, no
07:46:17 <merijn> It's an error
07:46:21 <geekosaur> huh
07:46:27 <augur> that would explain it then
07:46:43 <enthropy> then -fdefer-type-errors
07:46:46 <geekosaur> in that case I think 7.10 lets you defer the error to runtome
07:47:03 <enthropy> that flag is in earlier ghcs (7.6 I think)
07:47:07 <augur> somehow its hitting that error and just killing the other errors, which isnt good at all
07:47:08 <merijn> geekosaur: It does, I added that :D
07:47:19 <ab9rf> i have a perverse love for the monkeyface (:[])
07:47:20 <merijn> enthropy: 7.10 has -defer-typed-holes for holes only :)
07:47:32 <merijn> eh, -fdefer-typed-holes that is
07:47:39 <bergmark> so i'm right? :P anyway, it would make sense to defer those errors until everything else type checks at least
07:47:46 <merijn> enthropy: Which is basically -fdefer-type-errors for holes only :)
07:47:58 <geekosaur> I suppose it'd be difficult to treat it as a warning but then throw an error when it reaches the codegen?
07:48:15 <geekosaur> so typechecking can complete?
07:48:26 <merijn> geekosaur: It does complete typechecking, afaik
07:48:35 <merijn> GHC doesn't stop type checking when it encounters a hole
07:48:36 <bergmark> sounds like it could infer the type and just store it somewhere until after typechecking, then give an error
07:48:43 <merijn> bergmark: That's what it does
07:48:47 <geekosaur> but augur's report implies not
07:48:56 <geekosaur> I think I'd like to see an example
07:48:56 <merijn> Hence why I said that's a bug
07:49:02 <merijn> And asked for an example :)
07:49:38 <geekosaur> also what ghc version?
07:49:41 <bergmark> ok yeah, it def sounds like a bug if that's the intended behavior
07:49:46 <augur> geekosaur: yeah, ill try to find an example asap
07:50:33 <enthropy> http://lpaste.net/2462639307274321920 doesn't seem to be the case here
07:52:00 <enthropy> oh you get one less error when I turn off -fdefer-type-errors
07:53:28 <ab9rf> yay
07:54:41 * hackagebot casadi-bindings 2.2.0.5 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.2.0.5 (GregHorn)
08:04:47 <nitrix> Hi, I apply a function to a list of urls using mapM to fetch images online, which gives me something of the type `IO [Image]`.
08:05:50 <nitrix> There's two questions, if I were to change the function to IO (Maybe Image), how would I stop this computation to the first successful image downloaded? (Just value)
08:06:03 <merijn> @hackage monad-loops
08:06:03 <lambdabot> http://hackage.haskell.org/package/monad-loops
08:06:43 <nitrix> Second question, indirectly, I suppose I'm asking for lazy I/O, since I'd like to stop at the first successful.
08:06:54 <nitrix> (without computing the other ones)
08:07:26 <heatsink> It doesn't have to be lazy if there's code to check after each operation
08:08:09 <heatsink> It's lazy if something returns a value of type Image before the download is completed.
08:08:11 <nitrix> I have multiple links that are mirrors of the same image.
08:08:37 <merijn> nitrix: This doesn't really have anything to do with lazy IO, you're just wanting a short-circuiting loop, no?
08:08:44 <merijn> nitrix: Or did you wanna try all links in parallel?
08:09:03 <nitrix> merijn: Ah, I think you're right, it's short-circuiting
08:09:24 <nitrix> merijn: But I don't want to download all those links just to short-circuit the first one.
08:09:36 <heatsink> 'untilJust' checks the result of each action to decide whether to begin the next.
08:10:30 <geekosaur> shouldn't this be some MaybeT thing?
08:11:06 <Clint> yes
08:11:11 <nitrix> I guess to real goal is :: [Link] -> IO (Maybe Image)
08:11:38 <nitrix> Maybe my mapM is becoming stupid here.
08:11:43 <geekosaur> actually I guess MaybeT would try all of them and fail the whole thing if any is Nothing. MonadPlus?
08:11:57 <Clint> EitherR
08:12:28 <nitrix> EitherT?
08:12:49 <nitrix> Do I really need monad transformers for this :( ?
08:12:58 <heatsink> You could just write a loop
08:13:14 <merijn> nitrix: You can't use mapM because it can't shortcut
08:13:25 <merijn> Hence why I linked monad-loops like 5 minutes ago :>
08:13:35 <geekosaur> well, you could write what amounts to a specific monad transformer yourself, or use one that already exists
08:13:44 <heatsink> :t let go f (x:xs) = f >>= \case of {Just y -> return (Just y); Nothing -> go f xs}; go _ [] = return Nothing in go
08:13:45 <lambdabot> parse error on input ‘case’
08:14:05 <heatsink> :t let go f (x:xs) = f >>= \case -> {Just y -> return (Just y); Nothing -> go f xs}; go _ [] = return Nothing in go
08:14:06 <lambdabot> parse error on input ‘case’
08:14:13 <nitrix> How come monad-loops can short-circuit though? I'm trying to find how Haskell would let you do that at the same time to reason about it.
08:14:25 <geekosaur> I don't think lb does lambdacase
08:14:30 <heatsink> ok
08:14:37 <merijn> nitrix: monad-loops just wrote short-circuiting recursive functions?!
08:14:45 <merijn> I don't see what the problem is?
08:14:46 <nitrix> Doesn't it requires lazy IO? A list of IOs that are grabbing images, and computing only the first one or something?
08:14:57 <geekosaur> that's not lazy IO
08:15:03 <merijn> That's what I asked, whether you wanted to try them in parallel...
08:15:10 <geekosaur> lazy IO opens all of them and pulls data from one only when requested
08:15:11 <merijn> If you want to do parallel you need async
08:15:12 <heatsink> nitrix: It can run one action, check the result, and decide whether to run the next action
08:15:24 <geekosaur> you don't want to do the next IO open unless the last one "failed"
08:15:25 <nitrix> Oh because the function is recursive. Make sense.
08:15:28 <heatsink> nitrix: That is not lazy as long as it waits until the result is available before checking
08:16:14 <nitrix> merijn: Thanks.
08:16:18 <geekosaur> s/when requested/when a lazy computation elsewhere needs data from it/
08:17:05 <nitrix> Almost all my applications are intense with IOs. I swear, when I can master this, I'll love haskell like a thousand times more x.x
08:17:16 <nitrix> Right now it just feels like I'm relearning the same thing every 2 months x]
08:18:07 <heatsink> I want to make a type class of monad constructors, class (forall b. Monad (f b)) => HasEnvironment f
08:18:10 <merijn> I think async + pipes cover half of my IO needs
08:18:41 <heatsink> But I can't write a polymorphic constraint like that
08:20:40 <heatsink> HasEnvironment is supposed to be like a Reader monad where it's possible to map over the environment type
08:20:59 <merijn> heatsink: What's the higher level goal?
08:21:11 <heatsink> transformEnvironment :: HasEnvironment f => (a -> b) -> f b r -> f a r
08:22:31 <merijn> For more than just reader?
08:22:37 <heatsink> yes
08:23:03 <heatsink> I started out defining 'f' as a monad class (class Monad m => HasEnvironment f where ...)
08:23:21 <heatsink> then I tried to add the transformEnvironment method and realized it didn't fit that form
08:23:43 <heatsink> because it needs to be polymorphic in a and b, while still knowing that f a and f b are monads
08:23:54 <merijn> I doubt this will go very far, because I don't think it's a very generic class?
08:24:06 <merijn> But I might be wrong
08:25:23 <heatsink> I'm following a monad stack design
08:25:46 <nitrix> merijn: firstM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
08:25:50 <nitrix> merijn: I think this is what I want?
08:26:53 <heatsink> where instead of writing my side-effecting code for a particular monad, I write classes for the side effecting features I need
08:27:02 <heatsink> and then implement the classes
08:27:12 <heatsink> which makes it easier to extend later.
08:28:08 <merijn> nitrix: That tries all of them in sequence and stops at the first, not all of them in parallel
08:28:38 <merijn> heatsink: I'm not sure I believe in the "easier to extend" sounds similar to mtl and that already has a "quadratic instances" problem
08:28:55 <nitrix> merijn: That's fine, I need sequential.
08:29:21 <nitrix> merijn: Although, I would prefer obtaining the result of the function, not just which one was successful, otherwise, I have to re-download the image again
08:29:23 <merijn> Right, then that's what you want, yeah
08:29:36 <nitrix> (a -> IO (Maybe b)) -> [a] -> IO (Maybe b)
08:29:57 <heatsink> merijn: What is the quadratic instances problem?
08:30:58 <heatsink> nitrix: You can write your own loop with that type.
08:31:49 <vanila> hello
08:32:01 <vanila> what are some good examples of using pattern matching?
08:32:13 <vanila> like something with a lot fo complex patterns
08:32:29 <nitrix> heatsink: Maybe I should, I'm using that pattern a lot and monad-loops is an extra dependency
08:32:34 <mauke\> wouldn't simple patterns make better examples?
08:32:45 <orion> vanila: http://stackoverflow.com/questions/9066026/about-pattern-matching-of-record-type
08:32:54 <merijn> heatsink: That you have to write a quadratic number of instances for every type
08:34:25 <heatsink> merijn: Monads x classes?
08:35:39 <merijn> datatypes * classes
08:39:13 <heatsink> Well, certainly not all datatypes.  Sure, if I have 5 monad type constructors that are instances of 5 monad classes, I'll have to write 25 instance declarations.
08:41:52 <bergmark> It's O(m*c), but I think much less in practice
08:42:21 <heatsink> But I don't see an alternative way of decoupling the shared effectful functionality from the needs of code that hasn't been designed yet.
08:47:18 <merijn> I've seen multiple attempts at that and I'm not very impressed by them so far
08:47:56 <merijn> My solution is usually to just define a type alias for my transformer stack and updating that/changing affected code as I go
08:48:24 <merijn> Anyhoo, time to go
08:48:28 <heatsink> That is what I do.
08:48:53 <heatsink> But I can't do that if I don't have a monad transformer stack.
08:53:05 <heatsink> If you had two modules that use the same monad, and you need to specialize the monad in one of the modules, you end up changing a lot of code
08:54:11 <heatsink> A lot of the changes are renaming from the monadA versions of a function to the monadB version of the same function
08:54:36 <heatsink> Monad classes avoid that kind of renaming.
08:54:45 <gregnwosu> when i use aeson to extract a value i get "[\"stringIwant\"]"
08:55:11 <gregnwosu> how can i coerce aeson to give me the yummy bit in the middle and drop the escaped quotes
08:55:39 <digitalmentat> gregnwosu, showing us code would help
08:55:56 <digitalmentat> also, there really is no such thing as "coerce" in Haskell
08:56:15 <digitalmentat> but you can ask Aeson to give you something specific
08:56:17 <heatsink> Not coerce :: a -> b
08:57:00 <heatsink> coerce as in compel
08:57:31 <gregnwosu> looking at the nth lens , and yeah ill put something in lpaste
08:58:26 <dickermensch> I don't get FRP. Why would you want behaviours if you already have functions? Don't functions already encode "values that change over time"?
09:06:58 <steamboat> dickermensch:  most functions do not range over time
09:06:58 <lpaste> gregnwosu pasted “aeson” at http://lpaste.net/120706
09:07:18 <HeladoDeBrownie> dickermensch, behaviors can be implemented as specific types of functions
09:07:31 <gregnwosu> there... if anyone can help, hopefully thats enough code_pod
09:07:42 <dickermensch> HeladoDeBrownie: coroutines?
09:08:10 <HeladoDeBrownie> dickermensch, i meant it more literally than that; a coroutine can be implemented as a function with a restricted type.
09:08:14 <HeladoDeBrownie> errr
09:08:20 <HeladoDeBrownie> s/coroutine/behavior/
09:08:46 <gregnwosu> why not just make the behaviour an argument?
09:08:54 <gregnwosu> or am i thinking too simply
09:09:08 <HeladoDeBrownie> well, it often is used in an argument position, to whatever operations there are over behaviors.
09:09:19 <HeladoDeBrownie> i'm not quite sure i get your train of thought.
09:09:41 <code_pod> gregnwosu: : )
09:09:52 <HeladoDeBrownie> oh, different nick, woops.
09:09:54 <dickermensch> steamboat: I don't understand your point.
09:10:22 <gregnwosu> code_pod: i didnt do it , autocomplete did
09:10:44 <code_pod> gregnwosu: Yes, btw : )
09:11:21 <dickermensch> HeladoDeBrownie: ok but whats the benefit there? do behaviours give me more interesting combinators? combinators I can't have for more general function?
09:16:19 <HeladoDeBrownie> dickermensch, yes, for example you can delay them in time
09:17:03 <HeladoDeBrownie> (warning, i'm still getting into frp, i may not know some of the big ideas yet)
09:17:25 <gregnwosu> can anyone point me to a good reference for learning about the concurrency monad?
09:17:51 <HeladoDeBrownie> gregnwosu, what is "the" concurrency monad?
09:17:51 <bjornars1> gregnwosu: its basically like a burrito
09:18:15 <hannes__> dickermensch: Depends on what frp library you're talking about, but you need _some_ sort of framework to implement switches and such
09:18:40 <gregnwosu> HeladoDeBrownie: not sure , i remember reading that there were some exercises on it in FP101 by Eric M.
09:19:36 <HeladoDeBrownie> gregnwosu, maybe it was just something implemented in an exercise? i don't know of anything called Concurrency, but you can obtain concurrency in IO using forkIO and such
09:20:11 <HeladoDeBrownie> gregnwosu, and for that i would recommend the book parallel and concurrent programming in haskell
09:20:19 <gregnwosu> cool thanks
09:20:33 <dickermensch> hannes__:  I probably don't understand switches, but as a replacement couldn't you have a function that chooses, depending on some input maybe time, which function to run? is that considered a switch of behaviour?
09:23:17 <NightRa> mtl or transformers? - For a new project
09:23:49 <dickermensch> Please know that I'm not trying to argue that functions can do everything behaviours can do. they can, I guess. I'm just wondering if switches really are a more pleasing design.
09:24:35 <glguy> NightRa: mtl is transformers + some auto-lifting classes, so you'll be using transformers either way
09:24:57 <haasn> gregnwosu: +1 on that book, you can read it online at http://chimera.labs.oreilly.com/books/1230000000929/index.html
09:25:29 <NightRa> glguy: Ok, thanks.
09:26:18 <dickermensch> HeladoDeBrownie: Delay is a nice example I think. I can't imagine doing that without boilerplate when just using plain functions
09:29:52 <dickermensch> I'm reading into using coroutines for FRP right now and I like it. Any reason I shouldn't? And is there any up to date comparsion of FRP libraries? There's quite a lot to choose from.
09:33:08 <nitrix> Okay so, I ended up with http://ideone.com/QLJcP6.
09:33:15 <nitrix> Is there a way I can simplify this function?
09:33:26 <nitrix> Or more idiomatic way to achieve this?
09:34:26 <mniip> you can probably get rid of func
09:34:42 <vanila> :t \f -> liftM listToMaybe . map f
09:34:43 <lambdabot> (a1 -> [a]) -> [a1] -> [Maybe a]
09:34:53 <vanila> not quite.....
09:35:12 <breadmonster> What's the GHC dev channel?
09:35:18 <vanila> :t \f -> liftM listToMaybe . mapM f
09:35:19 <mniip> #ghc
09:35:19 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m (Maybe a)
09:36:02 <vanila> oh wait a sec, this runs them all before taking the first one
09:36:04 <hiptobecubic> dickermensch, i think the main problem with FRP right now is that there isn't a mostly agreed upon good way to do it. Pipes and conduit are converging more or less to handle streaming IO and have a lot of traction, I don't think there is a similar argument to made for FRP. I'm not any kind of expert though, this is just what i gather from reading discussions of more experienced users.
09:36:13 <vanila> you really need listToMaybeM . map f
09:36:33 <hiptobecubic> dickermensch, the answer is probably to try it out with a few of the different libraries and wee what you like. Maybe also try out Elm for comparison.
09:36:37 <hiptobecubic> see*
09:36:41 <hiptobecubic> Don't wee anything.
09:37:10 <mniip> nitrix, start by rewriting your function for '[IO (Maybe a)] -> IO (Maybe a)'
09:37:54 <nitrix> http://lpaste.net/120712
09:37:58 <nitrix> I currently have that.
09:38:07 <haasn> ocharles_: “explosion = decay 2 . gate . (rateReduce &&& 0.4) . (quantize &&& 500) . (noise &&& 0.2)” if I'm reading this correctly, the 0.2 in (noise &&& 0.2) is fed as the input for “quantize”?
09:38:30 <nitrix> mniip: Where would this leads to? I'd have to use sequence or whatever everytime I call that function :/ ?
09:38:40 <mniip> no?
09:38:49 <mniip> you'd just use map
09:39:16 <haasn> ocharles_: If so: this seems hilariously misleading to me. Can't we fix that, so it's something like “explosion = decay 2 . (gate `op` 0.4) . (rateReduce `op` 500) . (quantize `op` 0.2) . noise”?
09:39:47 <dickermensch> hiptobecubic: I didn't use Elm, but I've contributed crappy code to Helm! ;) But I don't think I like it. Probably because I don't understand Elerea :(
09:40:33 <tboww> hello, i'm seeking postgres high-level library. is there any good
09:40:33 <tboww>         library?
09:40:51 <HeladoDeBrownie> that gives me an idea, you know how there's send glitter to your enemies? introducing: contribute bad code to your enemies!
09:41:03 <mniip> amazing [] = return Nothing; amazing (x:xs) = x >>= maybe (amazing xs) (return . Just)
09:41:04 <mniip> sounds good
09:41:07 <HeladoDeBrownie> (anyone feel free to steal this idea)
09:41:29 <haasn> ocharles_: (x &&& y) = (id &&& y) . x -- right? So we could define (w `op` i) = w . (id &&& i) to fix this
09:41:41 <haasn> (Or whatever convenient alias exists for (&&&) id)
09:41:57 <cow_2001> HeladoDeBrownie: you think that's not already happening?
09:42:22 <HeladoDeBrownie> cow_2001, i believe it happens, but i haven't ever seen a site advertising it as a service.
09:42:27 <dickermensch> HeladoDeBrownie: I didn't do it on purpose! I really thought I could make a worthwhile contribution, but turns out I can't
09:42:35 <cow_2001> HeladoDeBrownie: oh.
09:42:38 <HeladoDeBrownie> dickermensch, oh i figured, i was just joking around :)
09:42:52 <haasn> Perhaps “arr (\x -> (x, w))”
09:44:46 * hackagebot dbmigrations 0.8.1 - An implementation of relational database "migrations"  http://hackage.haskell.org/package/dbmigrations-0.8.1 (JonathanDaugherty)
09:49:02 <L8D> haasn: arr (,w)
09:49:06 <L8D> tuple sections ftw
09:54:48 * hackagebot paypal-adaptive-hoops 0.9.0.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.9.0.0 (fanjam)
10:04:48 * hackagebot octohat 0.1.1 - A tested, minimal wrapper around GitHub's API.  http://hackage.haskell.org/package/octohat-0.1.1 (stackbuilders)
10:17:00 <orion> Hi.
10:17:33 <orion> The following fails lint checking: http://lpaste.net/6843191591947993088
10:17:56 <orion> "parse error on input ‘->’"
10:18:00 <orion> However, the code compiles.
10:18:17 <orion> Does anyone know what I can do to make it pass?
10:18:58 <geekosaur> probably indent them. layout's not applicable but it sounds like whatever linter you're using thinks it is
10:19:03 <kadoban> orion: Which '->' ? The first one?
10:19:14 <geekosaur> (if it's hlint then maybe it's out of date? because lpaste uses hlint and didn't complaint0
10:19:31 <kadoban> orion: And yeah, which linter? Hlint seems to think it's okay on my end, unless I'm missing something.
10:19:36 <orion> kadoban: Line 6 of the paste.
10:20:10 <orion> kadoban: hlint >= 1.7
10:20:32 <orion> Language.Haskell.HLint
10:21:33 <orion> Will indenting prevent haddock from working properly?
10:21:49 <geekosaur> 1.9.16 is current. I don't know what version lpaste is using
10:23:19 <geekosaur> I doubt it will break haddock because haddock uses ghc for parsing and ghc accepts it
10:23:20 <orion> hlint-1.9.16 is what I'm using.
10:23:54 <geekosaur> h, I think you have a bug to report on hlint, then :)
10:24:17 <orion> geekosaur: Cool! Where do I file it?
10:24:36 <geekosaur> https://github.com/ndmitchell/hlint/issues per http://hackage.haskell.org/package/hlint
10:24:46 <NightRa> GHCI via `cabal repl` is complaining it can't find an FFI function, even though ghci says it loaded the appropriate dynamic library just above the error. Also, `cabal run` works correctly (it can find the FFI function). Any help?
10:24:47 <orion> Thank you.
10:24:48 <kadoban> orion: I'm using the same version of hlint and all it says is "No suggestions". Are you sure there's no differences?
10:25:27 <orion> kadoban: Ah, I am not using command line.
10:25:48 <orion> hints <- hlint $ ["src", "benchmarks", "tests", "examples", "--cpp-define=HLINT"] `mappend` args
10:26:31 <kadoban> Oh.
10:30:20 <SrPx> If negative and fractional types allow for computation without gain/loss of information (and, theoretically, without energy use), how can it be useful at all?
10:31:12 <SrPx> I understood what the guys did on that paper and kinda see how we can compute things using it... but still, that is weird. So that would mean we could mine bitcoins without using energy, theorically?
10:31:14 <SrPx> Makes no sense
10:31:51 <vanila> Hi SrPx :)
10:31:57 <SrPx> Hi :)
10:32:35 <SrPx> btw I should move this to haskell-blah ... and we need a channel for non-haskell fp topics
10:32:36 <vanila> reversible computation has the potential to reduce energy consumption a lot, because there is no thermodynamic energy less that you need to account for - but in practice it is very hard to design a CPU for it
10:32:44 <vanila> loss*
10:34:04 <vanila> which paper are you referring to? Sabrys?
10:34:22 <SrPx> vanila: even a stupidly inefficient computer using pendulums or something would be really interesting if it actually did energyless computations... but my question is if we can *theoretically* play games and mine bitcoins with it? Because that would mean we are actually wasting a lot of energy in our computers
10:34:33 <SrPx> yes
10:35:05 <vanila> in fact a real reversible CPU/instruction set is called pendulum! :)
10:35:23 <vanila> http://www.cise.ufl.edu/research/revcomp/
10:35:43 <vanila> It's not energyless, but it has the potential to drastically lower energy use
10:35:54 <SrPx> Wow!!!!!!!!!!!!
10:36:08 <SrPx> Eh sorry.
10:36:15 <vanila> Even though these languages are in a strong sense reversibly turing complete - you can't really play games on it and mining bitcoins would not work well.
10:36:36 <SrPx> Why not?
10:36:53 <vanila> There are two types of computation: Reversible and non-reversible. To implement a non-reversible computation in a reversible language or instruction set requires generating an execution history -- basically you have to store a load of garbage to 'reversfy' the computation
10:37:01 <vanila> A simple example of this is sorting a list
10:37:13 <vanila> you can't sort a list, since there are a lot of options for unsorting.
10:37:31 <vanila> What you can do is take an unsorted list & the identity permutation and produce a sorted list paired with a new permutation that tells how to undo the calculation
10:39:46 <SrPx> vanila: but why is that so bad? Theoretically this already happens on our computers since our universe is reversible... we just ignore it, right?
10:39:56 <SrPx> If you mean it in a performance sense
10:41:52 <vanila> yes that's a good question, I suppose the thing to ask is: do you want to emit heat to allow you to destroy information or carry it around as garbage to get the benefit of reversiblity. It's a trade-off, a reversible computer will only really shine on (at least mostly) reversible computations though
10:42:05 <geekosaur> our universe is reversible? ever try to unscramble an egg?
10:42:24 <mniip> the universe isn't reversible
10:42:28 <vanila> yes I think that all the laws of physics are reversible
10:42:29 <mniip> thermodynamic arrow and such
10:42:40 <vanila> that time has a 'direction' only arises statistically
10:42:54 <hannes__> vanila: Black holes
10:42:55 <HeladoDeBrownie> vanila, that doesn't sound meaningful to me
10:43:07 <HeladoDeBrownie> it doesn't *explain* anything
10:43:23 <mniip> vanila, basic mechanics are of course T-symmetric
10:43:47 <zerokarmaleft> geekosaur: apparently you can unboil a boiled egg now
10:44:03 <mniip> any kind of collision falls outside of the model though
10:45:13 <geekosaur> you can decoagulate the albumin, yes. you can't stuff it back in the shell and some of the components aren't proteins so the protein-renaturer stuff doesn't work on them
10:45:18 <vanila> HeladoDeBrownie, have you seen Feynmans lecture on this?
10:45:32 <geekosaur> s/stuff it back in the shell/put the shell back in pristine form/
10:46:17 <geekosaur> vanila, as with many things, behavior at quantum level is different. thermodynamics still has a component that is not merely statistical though; that's a major unsolved problem in physics
10:46:24 <HeladoDeBrownie> vanila, no, but i bet it goes into more detail than "it only arises statistically"
10:46:38 <vanila> uh yeah... .feyman goes into more detail than I did in one line of IRC..
10:46:47 <HeladoDeBrownie> well, i put that wrong
10:46:59 <mniip> geekosaur, unscrambling an egg isn't as hard as having a golf ball jump out of a hole, fly over the entire field and land on the tee
10:47:16 <HeladoDeBrownie> "it only arises statistically", by itself, doesn't tell me anything i don't already know, although it's possible i just don't quite understand what is meant by that
10:47:21 <geekosaur> iirc the disconnect between thermodynamics and quantum theory has three components and things that answer one usually mess up the others even worse...
10:47:38 <rui> mniip the forward version of that isn't easy either
10:48:05 <subleq> What do most haskell people use for frontend web programming? Elm?
10:48:11 <mniip> rui, hmm, imagine that the field is a downward pointing hole :P
10:48:20 <mniip> er
10:48:23 <mniip> rui, hmm, imagine that the field is a downward pointing cone :P
10:48:44 <geekosaur> HeladoDeBrownie, afaik it's just the usual reason for the disconnect between quantum and macrocosmic behavior (we see the statistical mean of the quantum behaviors)
10:49:32 <hannes__> subleq: Probably straight html/js (with various templating languages) I'd say. Elm doesn't really make sense for many kinds of applications, and even if it does you still have to like it.
10:49:40 <HeladoDeBrownie> geekosaur, maybe this would help: given that statement, what can i now infer about the directionality of time that i didn't already have observing time is directional?
10:50:02 <subleq> hannes__: what kind of application is elm not suited for (i've never used it)
10:50:57 <rui> What's the elm workflow? You write code, compile to javascript, and put it in your site?
10:50:58 <hannes__> subleq: 'unsuited for' is a harsh word. I'm not aware of anything you couldn't do in Elm that you could with html/css
10:51:34 <vanila> hannes__, Perhaps we can use black holes to cool CPUs then :)
10:51:35 <hannes__> subleq: It's just that the whole reactive frontend shenanigans doesn't make a whole lot of sense if you just want a form
10:51:50 <HeladoDeBrownie> hrm, actually i need to go. later~
10:52:22 <geekosaur> well, with that phrasing it's hard to answer because the answers are fairly unobservable at the macro level >.>
10:52:36 <geekosaur> in short we're all speaking the wrong anguage
10:52:40 <geekosaur> *language
10:52:51 <rui> HeladoDeBrownie leaving in fear you get used to cool down CPUs
10:53:48 <vanila> SrPx, also quantum computation is necessarily reversible, with the rise of quantum computation reversible computation has become a lot more important
10:54:09 <hannes__> hm... what's the name of the 'contrareader' data ContraR b a = ContraR (a -> b)?
10:54:51 * hackagebot configuration-tools 0.2.12 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.12 (larsk)
10:55:16 <Tekmo> hannes__: Edwards call this "Op"
10:55:32 <Tekmo> http://hackage.haskell.org/package/contravariant-1.2.0.1/docs/Data-Functor-Contravariant.html#t:Op
10:55:46 <Tekmo> *Edward
10:56:04 <hannes__> why Op? That sounds contraintuitive to me
10:56:27 <Tekmo> Probably a reference to the use of "Op" to denote the opposite category in category theory
10:58:52 <jle`> instance (Arbitrary a, Eq b) => Eq (a -> b)
11:00:19 <Tekmo> Are you sure `Arbitrary` is the right constraint?
11:03:23 <dulla> you lied to me vanila , you are strawberry
11:04:05 <jle`> Tekmo: it's a joke :)
11:04:23 <jle`> its QuickCheck-equality
11:04:33 <Tekmo> :)
11:05:06 <geekosaur> surely that'd be "strawbery"?
11:06:31 <SrPx> vanila: makes sense...
11:07:02 <SrPx> sorry for taking long to answer, though, someone distracted me
11:07:15 <vanila> it's ok, this is IRC :)
11:07:57 <cimon> Hello, I have been playing around with frp a bit for the last few days and I was trying to make a stop watch with threepenny-gui. However I'm sort of stuck and I'm wondering what would be the proper/idiomatic solution. I have made a timer that ticks every second and that is stoppable and resumable. The problem is that the resume may not exactly coincide with a tick, so the first tick after the resume may happen after less than a full secon
11:07:57 <cimon> d. Can anyone give me a hint how to solve this without using unsafeMapIO or simply increasing the frequency of the timer until the error becomes unnoticable?
11:09:41 <rui> Interesting question
11:10:04 <dulla> vanila  you are arguing what seems to be referential transparency for computations
11:16:22 <xkb> Im playing around with MySql simple. I need it to connect to the port of mysql instead of the socket. Any idea how?
11:16:41 <xkb> I tried connectOptions=[UseRemoteConnection]
11:16:45 <xkb> without success
11:17:48 <HeladoDeBrownie> rui, i failed to parse your message. anyway i said that because i really needed to get to work on a project :P
11:20:13 <rui> HeladoDeBrownie, it was just a stupid comment. People were talking about using black holes to cool CPUs, and you (brownie icecream) suddenly had to go
11:20:29 <geekosaur> xkb, show code?
11:20:32 <geekosaur> @paste
11:20:32 <lambdabot> Haskell pastebin: http://lpaste.net/
11:20:39 <rui> Don't mind me. I am using this chat (and other things) to avoid doing what I should
11:20:47 <rui> so I'll say anything
11:20:54 <geekosaur> (also your phrasing is atrocious. both are sockets. one is a local socket, one is a network socket)
11:20:54 <HeladoDeBrownie> rui, ah XD okay, now i see how it parses, thanks
11:21:19 <HeladoDeBrownie> rui, i misread "get used to" as "get accustomed to" rather than "get used in order to"
11:21:46 <rui> HeladoDeBrownie, let's blame the English language :)
11:22:07 <HeladoDeBrownie> rui, yes, sometimes you just stumble into some of its faults by accident
11:22:11 <HeladoDeBrownie> anyway, back to project!
11:24:36 <michaelt> oh hi Tekmo
11:25:00 <xkb> geekosaur: solved it already, localhost forces socket connection
11:25:06 <xkb> geekosaur: 127.0.0.1 does not
11:25:50 <geekosaur> guess you're going to keep using the wrong terms then and confuse people
11:26:00 <HeladoDeBrownie> Tekmo, oh by the way, thanks for the email reply, i haven't yet taken the time to fully comprehend it but i appreciate it :)
11:26:17 <geekosaur> (hint: what mechanism do you think you use to connect to a "port"?)
11:26:22 <xkb> geekosaur: hehe
11:27:23 <xkb> geekosaur: should I use "network socket" to make it more clear?
11:27:52 <geekosaur> well, saying that the non=-network one is *the* socket is less clear
11:29:12 <xkb> I understand
11:29:53 * hackagebot types-compat 0.1.0 - ghc-7.6/7.8 compatible GHC.TypeLits, Data.Typeable and Data.Proxy.  http://hackage.haskell.org/package/types-compat-0.1.0 (HirotomoMoriwaki)
11:29:55 * hackagebot generic-trie 0.3 - A map, where the keys may be complex structured data.  http://hackage.haskell.org/package/generic-trie-0.3 (EricMertens)
11:33:16 <Tekmo> HeladoDeBrownie: You're welcome! :)
11:39:53 * hackagebot web-routing 0.5.0 - simple routing library  http://hackage.haskell.org/package/web-routing-0.5.0 (HirotomoMoriwaki)
11:54:55 * hackagebot generic-trie 0.3.0.1 - A map, where the keys may be complex structured data.  http://hackage.haskell.org/package/generic-trie-0.3.0.1 (EricMertens)
11:57:16 <csd_> Hi -- would someone be able to give me code review? https://www.refheap.com/97503
12:00:02 <michaelt> csd_: it might be a better idea to derive Show and Read as usual and then write 'pretty :: Company -> Text' or something ?
12:00:47 <csd_> michaelt: what would it mean to derive Show as usual?
12:00:55 <glguy> deriving (Read,Show)
12:01:11 <csd_> what would the advantage of doing it that way be
12:01:26 <glguy> Your read and show functions would work correctly
12:01:34 <glguy> and wouldn't be hijacked for pretty-printing
12:01:59 <csd_> youll have to excuse me, this is the first haskell program ive ever written. how are they currently broken?
12:02:40 <glguy> Read should be able to parse the output of Show, and the output of Show should be Haskell syntax
12:02:42 <Tekmo> csd_: For parsing you should probably use `parsec` or `attoparsec`
12:03:03 <csd_> glguy: got it
12:08:17 <michaelt> csd_: btw, for a first haskell program this is pleasantly up-to-date and sophisticated
12:08:31 <csd_> thanks
12:08:49 <csd_> someone showed me the trick using applicatives to construct Company
12:15:16 <michaelt> csd_: you might write deriving (Show, Read, Eq, Ord) the latter will let you write a Map Company XYZ and a Set Map and so on
12:16:50 <aidecoe> is this some standard Haskell style to omit space after ','? E.g. [1,2,3,4] instead of [1, 2, 3, 4]
12:17:05 <aidecoe> or it's just GHC?
12:17:13 <Tekmo> Just GHC
12:17:15 <michaelt> > [1,2,3,4]
12:17:17 <lambdabot>  [1,2,3,4]
12:17:31 <shachaf> aidecoe: It isn't uncommon.
12:17:40 <hannes__> aidecoe: I wouldn't worry too much about it. Take what looks better. I prefer omitting spaces in some cases. In others I separate each item with a newline.
12:17:47 <csd_> michaelt what's the easiest way to repurpose the existing Show function into some form of prettyprint?
12:17:59 <geekosaur> not doing so
12:18:01 <hannes__> csd_: Don't?
12:18:08 <Tekmo> csd_: You're probably better off using a proper pretty-printing library
12:18:13 <geekosaur> csd_, prettyprint is not what Show is about
12:18:37 <geekosaur> you will taknk yourself later when you're trying to debugf and your prettyprinter isn't making it harder to understand what's really going on
12:18:41 <aidecoe> hannes__: i have some habits, but i also like conform to standard
12:18:50 <Tekmo> You can try the `wl-pprint` library
12:18:57 <geekosaur> aidecoe, there's not a lot in the way of standards
12:19:37 <aidecoe> but what bothers me most is ',' on the new line
12:19:40 <aidecoe> something like:
12:19:43 <aidecoe> [1
12:19:47 <aidecoe> ,2]
12:20:49 <hannes__> aidecoe: Some people prefer that because apparently it makes adding items later on slightly easier. I'm not a huge fan of it, but...
12:20:54 <geekosaur> that is a common but by no means universal style. it makes inserting new elements in the middle or at the end easier, at the price that inserting one at the beginning is a little harder
12:21:58 <Tekmo> I'd also prefer the `]` on its own line so that inserting at the end is easier
12:22:03 <arw_> > [1, 2, 3, 4, ]
12:22:04 <lambdabot>  <hint>:1:14: parse error on input ‘]’
12:22:23 <arw_> thats why this is necessary. reordering breaks if you don't start lines with ,
12:22:51 <Tekmo> If you really want a style that is easy to insert anywhere, you'd need to do something awkward like `[]\n ++ [1]\n ++[2]
12:22:58 <arw_> if the syntax were a little more tolerant and [, 1, 2, 3, 4, ] would be fine, then this wouldn't be necessary.
12:23:23 <arw_> Tekmo: yes, thats true.
12:23:51 <nitrix> What is more idiomatic,    a . b . c $ d     or   a . b $ c d
12:23:52 <aidecoe> i don't get that arguments "easy to insert"
12:24:03 <Tekmo> I kind of prefer (a . b . c) d
12:24:03 <johnw> nitrix: whatever you like
12:24:04 <vanila> a . b . c $ d
12:24:13 <johnw> I personally would use what vanila said
12:24:19 <haBuu_> aidecoe that is the ONLY acceptable way
12:24:23 <nitrix> Appreciated.
12:24:24 <johnw> but I doubt that my use of Haskell constitutes the common idiom
12:24:31 <haBuu_> i want to murder anyone who is following that
12:25:13 <aidecoe> haBuu_: are you talking about which case, exactly?
12:25:23 <haBuu_> comma-first style
12:26:11 <hannes__> haBuu_: It is the only acceptable way and you want to murder everyone following it? So, only inadequate people may live?
12:26:19 <arw_> agreed, comma first is ugly. but its unfortunately necessary in languages with overly picky parsers that can't live with ,]
12:26:53 <aidecoe> haBuu_: i see some conflicting statements in what you say (-:
12:26:54 <haBuu_> yeah it ugly but is way more convenient
12:26:54 <Tekmo> I like commas-first just because it keeps the commas aligned
12:27:02 <haBuu_> *s
12:27:02 <Tekmo> It's more visually pleasing for me
12:27:42 <arw_> hrm, I wonder. could one make something like perls qw-operator in haskell?
12:27:46 <hannes__> awestroke: I wouldn't say necessity. Saving a couple of keystrokes every couple of minutes doesn't seem to be worth any kind of tradeoff.
12:27:55 <johnw> arw_: with quasi-quoting, sure
12:28:04 <johnw> there's pretty much nothing you can do with that
12:28:06 <johnw> can't
12:28:46 <hannes__> johnw: You can't write easy to digest library code with it
12:28:58 <sinelaw> if only commas were a bit smaller
12:28:58 <johnw> I meant technically possible
12:29:01 <sinelaw> maybe there's a font for that
12:29:05 <johnw> you involve humans, then I can't help you
12:30:26 <michaelt> This 'reflection' library is pleasantly wild.
12:30:27 <vanila> tail [ undefined, a, b, c, d ]
12:30:35 <vanila> do this, then you wont have a problem with first ,
12:31:44 <arw_> hm, cool, something similar has already been implemented: http://hackage.haskell.org/package/interpolatedstring-perl6
12:32:18 <orion> geekosaur: Bah, it's a problem with doctest, not hlint.
12:32:50 <orion> I misread my cabal test output.
12:35:00 <Profpatsch> How to check in O(1) if a list is empty?
12:35:14 <Tekmo> Profpatsch: null
12:35:24 <Tekmo> Profpatsch: It's defined like this: null [] = True; null _ = False
12:35:30 <Profpatsch> Tekmo: Okay.
12:38:20 <marchelzo_> @pl \a b -> 2^a * b
12:38:20 <lambdabot> (*) . (2 ^)
12:42:48 <phaazon> hi
12:42:57 <phaazon> can someone explain me the stepWire function?
12:43:01 <phaazon> the documentation is pretty poor
12:43:12 <phaazon> it takes a Wire s e m a b and s
12:43:16 <phaazon> that sounds ok to me
12:43:21 <phaazon> we need s as delta
12:43:25 <phaazon> but it also takes Either e a
12:43:32 <phaazon> testWire uses Right ()
12:43:35 <phaazon> what is that?
12:43:49 <phaazon> is that the « last value »?
12:43:56 <phaazon> passed as input?
12:44:18 <phaazon> I see it outputs m (Either e b,Wire s e m a b)
12:44:23 <phaazon> the Either is there for inhibition, I guess
12:44:32 <phaazon> Left e would be « inhibiting »
12:45:19 <Tekmo> `Right (x :: a)` would indicate a new value incoming from upstream
12:45:36 <phaazon> I see
12:45:41 <phaazon> thanks :)
12:45:44 <Tekmo> You're welcome!
12:45:52 <phaazon> I’m gonna try to write a little reactive program with netwire
12:46:03 <phaazon> I think I’m gonna fall in love with that library! :)
12:50:31 <hannes__> phaazon: Netwire is a lot of fun, but you can really get yourself in 'fun' trouble with switch vs dSwitch
12:51:44 <phaazon> dSwitch?
12:52:19 <orion> https://github.com/sol/doctest/issues/101
12:55:55 <hannes__> phaazon: switch switches immediately, dSwitch switches in the next instant
12:56:39 <hannes__> phaazon: So if you want to toggle state based on a keypress, and then use switch instead of dSwitch you'll run into an infinite loop
12:57:19 <hannes__> phaazon: It's usually not so hard to figure out which one to use, but it's also not always obvious, especially if you're just figuring things out
13:01:04 <asampal> Anyone have some opinions on the various JetBrains plugins for Haskell? I see there are a few available so it would help to know which is viewed as the best at this point.
13:02:08 <Tekmo> I've heard good things about this one: http://carymrobbins.github.io/intellij-haskforce/
13:02:13 <Tekmo> I haven't tried it out myself, though
13:03:22 <phaazon> hannes__: I see
13:03:37 <phaazon> dSwitch stands for deferred switch?
13:04:20 <jle`> delayed
13:07:14 <augur> anyone know why postgresql would product this error:
13:07:15 <asampal> Tekmo: thanks - I'll check it out - seems to have been updated recently. It would help to hear from anyone who has used Haskell in any of the JetBrains IDEs, though.
13:07:26 <augur> cabal: Error: some packages failed to install:
13:07:26 <augur>        postgresql-libpq-0.9.0.2 failed during the configure step. The exception was: ExitFailure 1
13:07:27 <augur>        postgresql-simple-0.4.9.0 depends on postgresql-libpq-0.9.0.2 which failed to install.
13:07:54 <augur> what is postgresql-libpq and what is that error code supposed to be
13:08:10 <hannes__> augur: That error code means 'something failed somehow'
13:08:17 <augur> :(
13:08:27 <hannes__> augur: Probably missing native libraries
13:08:32 <bennofs> augur: the full log of cabal should include the exact message
13:08:39 <augur> bennofs: wheres that?
13:08:45 <bennofs> augur: or it should at least be in ~/.cabal/logs
13:08:50 <augur> ok
13:09:01 <bennofs> AFAIK
13:09:05 <hannes__> augur: There's a verbosity switch for cabal, but I keep forgetting what it is
13:09:17 <augur> probably -v
13:09:25 <bennofs> augur: also, sometimes the exact error is further up in the output of cabal, not at the end
13:09:42 <bennofs> -j1 also works sometimes
13:10:11 <augur> ahh it says pg_config is required
13:10:11 <phaazon> dammit
13:10:15 <phaazon> on Windows:
13:10:16 <phaazon>    the 'stdcall' calling convention is unsupported on this platform,
13:10:30 <bennofs> :O
13:10:39 <phaazon> what is that
13:10:51 <geekosaur> 64 bit by any chance?
13:10:56 <phaazon> yeah
13:10:58 <augur> ok i think i know what this means then
13:11:05 <geekosaur> stdcall is the classic windows calling convention. I think 64-bit doesn't use it
13:11:25 <phaazon> ah
13:11:26 <geekosaur> (it's pascal-based, as distinct from ccall which is the one that other platforms and win64 use)
13:11:48 <bennofs> I just found
13:11:50 <bennofs> ##if defined(i386_HOST_ARCH)
13:11:53 <bennofs> ## define WINDOWS_CCONV stdcall
13:11:55 <bennofs> ##elif defined(x86_64_HOST_ARCH)
13:11:57 <bennofs> ## define WINDOWS_CCONV ccall
13:11:59 <bennofs> ##else
13:12:01 <bennofs> ## error Unknown mingw32 arch
13:12:03 <bennofs> ##endif
13:12:05 <bennofs> In my code
13:14:24 <hannes__> huh... why do quasiquoters for different contexts the same name? Seems hacky to me.
13:14:31 <hannes__> *type not name
13:14:35 <phaazon> bennofs: ok
13:16:19 <augur> bennofs hannes__: bingo, the commandline tools for postgresql werent visible in the shell :)
13:17:00 <Tekmo> hannes__: Yeah, I agree
13:18:53 <hannes__> And it's a product type rather than a sum type... what would that ever be used for? Just for sharing the same name for effectively different quoters? Doesn't seem worth it.
13:19:43 <xplat> well, you'd really want to use the same name for, e.g., pattern and expression quoters if you supported two that go together
13:20:10 <xplat> not sure it's worthwhile to support the FULL spectrum of punning though.
13:21:36 <Trollinator> so I can apply a function in an applicative context with f <$> a <*> b <*> c. But what if one of the values, say b, is actually a pure value? Then I'd have to write f <$> a <*> pure b <*> c. Is there maybe a convenient operator for that?
13:22:14 <EvanR> pure is the convenient operator for that
13:22:29 <EvanR> but also <*
13:22:50 <mauke> <$> ($ b)
13:22:55 <mauke> hmm, no
13:23:12 <hannes__> EvanR: <*? How so? That doesn't lift pure values
13:23:21 <EvanR> :t (<*)
13:23:22 <lambdabot> Applicative f => f a -> f b -> f a
13:23:29 <EvanR> nevermind then
13:23:43 <hannes__> : (<$)
13:23:46 <hannes__> :t (<$)
13:23:48 <lambdabot> Functor f => a -> f b -> f a
13:24:06 <hannes__> but that's not massively helpful either
13:24:09 <mauke> <&> ($ b)
13:24:23 <EvanR> a big mix of operators might be harder to read than a uniform array of <*>
13:24:38 <Trollinator> I'm looking for something of type Applicative f => f (a -> b) -> a -> f b
13:24:44 <Trollinator> with the obvious implementation.
13:25:03 <EvanR> :t ($>)
13:25:04 <lambdabot>     Not in scope: ‘$>’
13:25:04 <lambdabot>     Perhaps you meant one of these:
13:25:04 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
13:25:11 <EvanR> :t (&>)
13:25:12 <lambdabot>     Not in scope: ‘&>’
13:25:12 <lambdabot>     Perhaps you meant one of these:
13:25:12 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
13:25:19 * EvanR quits
13:25:38 <mauke> :t \f b -> f <&> ($ b)
13:25:38 <lambdabot> Functor f => f (a -> b) -> a -> f b
13:25:52 <xplat> @hoogle f (a -> b) -> a -> f b
13:25:55 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:25:55 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
13:25:55 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
13:26:19 <xplat> ... thanks for nothing, hoogle
13:26:58 <Trollinator> :t (<&>)
13:26:59 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:27:13 <ezrios> EvanR: thanks for the Data.Time diagram btw
13:27:18 <ezrios> still using it ._.
13:27:21 <Trollinator> isn't that just flip fmap?
13:27:28 <EvanR> ezrios: did you get the new one?
13:27:35 <lightstep> :t <*>.pure
13:27:35 <ezrios> EvanR: yes indeed
13:27:36 <lambdabot> parse error on input ‘<*>.’
13:27:40 <lightstep> :t <*> . pure
13:27:41 <lambdabot> parse error on input ‘<*>’
13:27:43 <ezrios> :t flip fmap
13:27:44 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:27:54 <hannes__> I still don't think any of this is worth not typing pure
13:27:54 <ezrios> :t (<*>) . pure
13:27:55 <lambdabot> Applicative f => (a -> b) -> f a -> f b
13:28:01 <Trollinator> I mean <&>
13:28:17 <ezrios> `class (Real a, Enum a) => Integral a where`
13:28:25 <ezrios> this means any a that is both Real and Enum is an Integral, yes?
13:28:49 <Trollinator> ah, whatever, I just thought it seemed like something one might need more often.
13:29:20 <quchen> What does hsc2hs pass to C by default? I feel like it takes a long time to compile the auto-generated c file, and since it's only a long bunch of print statements it should be really quick.
13:29:30 <quchen> Could it be that the output is optimized a lot?
13:29:32 <lightstep> ezrios: yes, it does
13:29:44 <hannes__> Trollinator: I haven't had much use for it. If you define something like that, I'd recommend to keep it local
13:29:57 <Tekmo> ezrios: It means that `Real` and `Enum` are necessary requirements to be an `Integral` but are not sufficient
13:30:04 <ezrios> Tekmo: ah ok
13:30:10 <ezrios> that explains a lot
13:30:53 <hannes__> ezrios, lightstep No it doesn't. It means any a that is Integral is also Real and Enum
13:32:12 <lightstep> yes, my bad, i got confused reading the direction of the implication
13:32:25 <ezrios> argh
13:32:46 <ezrios> I just want an Integral representation of a NominalDiffTime
13:32:59 <EvanR> ezrios: thats a fractional type, what do you want?
13:33:05 <EvanR> the seconds?
13:33:05 <Tekmo> ezrios: Use `truncate`
13:33:32 <EvanR> :t floor
13:33:32 <lambdabot> (RealFrac a, Integral b) => a -> b
13:33:37 <ezrios> :t truncate
13:33:38 <lambdabot> (RealFrac a, Integral b) => a -> b
13:33:42 <ezrios> NominalDiffTime is not Integral
13:33:49 <ezrios> maybe I will just take it to UTCTime and that will suffice
13:33:58 <EvanR> ezrios: you read it wrong... the function outputs a b
13:33:59 <ezrios> wait, that's only for POSIXTimes
13:33:59 <Tekmo> ezrios: `truncate` only requires that the argument is a `RealFrac`
13:34:01 <ezrios> ._.
13:34:08 <ezrios> ah
13:34:15 <ezrios> I should read more careflly, thanks
13:34:19 <Tekmo> You're welcome
13:34:32 <EvanR> floor ceil truncate and round are the toolkit for going from fractional types to integral types
13:34:36 <EvanR> ceiling*
13:34:52 <ezrios> yeah I'm still not too familiar with all the numerical typeclasses yet
13:35:23 <mauke> numeric types generally fall in two classes, fractional and integral
13:35:52 <ezrios> ah, it was GHC confusing me with a missing Integral instance
13:35:57 <ezrios> I thought it was talking about the NominalDiffTime
13:36:01 <ezrios> it's some shit to do with Aeson :/
13:36:17 <EvanR> i believe Aeson has some weirdness as far as instances for time types go
13:36:26 <EvanR> unfortunately
13:37:44 <hannes__> ezrios: Eh, the num class hierarchy is rather confusing.
13:38:09 <EvanR> yeah, someone should make a diagram
13:38:12 <hannes__> ezrios: People have been complaining about it for a long time, but I don't know if anyone actually made a concrete proposal for a fix
13:38:14 <ezrios> there, explicit type annotation fixed it
13:38:19 <quchen> Tekmo: ping?
13:38:23 <Tekmo> quchen: Hi
13:38:34 <ezrios> hannes__: yeah it's a bit convoluted
13:38:40 <ezrios> lots of conversion between different types ._.
13:38:55 <tvdien> hey everyone; can someone help me with a pandoc issue?
13:39:00 <quchen> Tekmo: Check your /q :-)
13:39:00 <EvanR> hannes__: a cheat sheet for the basic things you need to know to use it would be good. namely fromIntegral, realToFrac, and floor
13:39:05 <Tekmo> ezrios: Just remember that the purpose is to avoid unintentional mistakes
13:39:19 <ezrios> Tekmo: yeah, that's what I like about Haskell
13:39:28 <ezrios> it's frustrating as hell but at least it prevents you from doing something stupid
13:39:49 <hannes__> tvdien: That greatly depends. I don't know if anyone here is working on pandoc, and if it's 'issue' as in 'bug' you should probably take it to the devs
13:39:51 <ezrios> nice how the types guide you along a correct way of doing things
13:40:23 <Tekmo> quchen: I'm not sure how.  Give me just a second
13:40:30 <tvdien> hannes__: I don't think it's a bug really; probably it can be solved with some template fix or so, but I'm just a beginner
13:41:13 <quchen> Tekmo: Well there should be a window open *somewhere*. Frantically hit Alt+numbers or something, depending on your client.
13:41:16 <michaelt> tvdien: what template?
13:41:38 <quchen> No hurries though.
13:42:02 <hexagoxel> EvanR: haskell report has a diagram, iirc. Show constraint might be non-up-to-date, though..
13:42:06 <Tekmo> quchen: The problem is that I'm on OS X at the moment and it seems to be swallowing the usual IRSSI window commands
13:42:17 <tvdien> michaelt: I'm converting markdown to PDF, and pandoc wrongly interprets some code block in Python
13:42:21 <Tekmo> Let me switch to a browser IRC
13:42:24 <EvanR> hexagoxel: yeah, its not up to date, and its still a little confusingly laid out, and incomplete
13:42:32 <Tekmo> I'll be right back
13:42:38 <quchen> Tekmo: I can also email or jabber you if that's better
13:42:41 <EvanR> hexagoxel: it surely doesnt help with the question of how to convert
13:42:45 <tvdien> michaelt: I thought maybe customizing the template would fix it, but I don't know where to start
13:42:56 <Tekmo> quchen: Okay, try now
13:43:03 <michaelt> tvdien: is pandoc not seeing that it is a code block? or what
13:43:12 <EvanR> Tekmo: btw you can use ESC then key to do alt+key in irssi
13:43:22 <EvanR> in case alt is not working
13:43:37 <L8D> anyone know how this gif was made? http://danmidwood.com/assets/animated-paredit/paredit-slurp-barf.gif
13:43:45 <michaelt> tvdien: I mean, do you  see the same problem if you do e.g. -o html -s
13:44:15 <L8D> wrong channel :P
13:44:16 <EvanR> L8D: the overlay looks like screenflow.
13:44:25 <michaelt> tvdien: sorry I meant -t html -s
13:44:59 <tvdien> michaelt: yes, the problem is the same
13:45:05 <tvdien> michaelt: putting it in lpaste
13:45:20 <michaelt> tvdien: hm, but that suggests that there is a problem with the markdown syntax
13:46:22 <lpaste> tvdien pasted “Markdown that is wrongly interpreted; every line of the dict expression after the first is  wrongly considered a comment” at http://lpaste.net/120727
13:46:28 <Arahael> Why do we use exceptions in Haskell? Isn't it sufficient to use Either?
13:46:41 <tvdien> michaelt: lpaste is up
13:47:31 <dulla> there are about 4 methods of error handling
13:47:45 <EvanR> Arahael: the entire IO system would be a giant Either, mainly for no gain
13:47:46 <dulla> it's weird, but sometimes you want something that is very cross compatible
13:48:04 <EvanR> some IO actions almost never fail
13:48:11 <EvanR> when they do its exceptional
13:48:41 <hannes__> Arahael: to be fair, you don't use exceptions very often in haskell
13:48:44 <Arahael> EvanR: In other words, an exception in haskell should be regarded as truely exceptional, and only raised in rare cases?
13:48:53 <EvanR> i would limit exceptions to that yeah
13:49:05 <EvanR> when the impossible happened
13:49:06 <michaelt> tvdien: is it that the syntax highlighting is wrong?
13:49:14 <hannes__> EvanR: Oh god I hate when that happens
13:49:16 <EvanR> which is how youd probably want to deal with a Left in most IO actions anyway
13:49:22 <Arahael> EvanR: This contrasts with mainstream langauges, where exceptions are practically common.
13:49:39 <EvanR> in some languages exceptions are the only way to do convenient control flow
13:49:46 <EvanR> like ruby
13:49:46 <tvdien> michaelt: yes, it shows the second line in the { } differently than the first, as if it were a comment
13:50:26 <hannes__> You normally don't want to use exceptions because they're opaque and don't compose. Like EvanR said, you pretty much only use it for stuff that you genuinely don't expect to go wrong
13:50:45 <EvanR> Arahael: have you ever tried to use a Maybe function or Either, and didnt know wtf the do with the error case? perhaps use... error? its an exception ;)
13:50:47 <Arahael> EvanR: I'm not completely sure about how Ruby does exceptions; but in python an exception is raised to stop iterating.
13:51:02 <EvanR> Arahael: that sounds awful
13:51:04 <Tekmo> Yeah, using an exception to stop iterating is a no-no in Haskell
13:51:09 <michaelt> tvdien: yes i noticed that, is there a syntax problem?  I got rid of the second comma, but it didn't help
13:51:12 <hannes__> Arahael: That sounds wrong by any reasonable standard
13:51:19 <hannes__> Arahael: Even for python.
13:51:19 <Arahael> EvanR: It's teh StopIteration exception. ;)
13:51:36 <Arahael> hannes__: Python uses exceptions more than any other language i've ever seen.
13:52:00 <tvdien> michaelt: it is valid Python but perhaps whatever parses it doesn't know dict expressions - it's not that those are terribly new though
13:52:00 <Arahael> hannes__: (But it hides them from you so you don't realise how frequently they're being used.)
13:52:05 <hannes__> I don't know what about the word 'Exception' screams 'use this for normal control flow' to people
13:52:42 <c_wraith> hannes__: sometimes it's the only "sane" option for particular control patterns in some languages.  like breaking out of nested recursion, for instance
13:52:42 <hpc> hannes__: seriously
13:52:53 <Arahael> hannes__: Now, in the case of Wreq, I'm seeing that it returns HTTP error codes as exceptions.
13:53:14 <Arahael> hannes__: And I'm wondering why it doens't use Either there.  Either HttpError HttpResponse (or something like that)
13:53:29 <Trollinator> It doesn't really matter in Python. The big problem with exceptions is that they don't show up in your return types, and Python doesn't have those.
13:53:46 <EvanR> Arahael: HttpResult as its own type, probably
13:54:07 <Arahael> EvanR: It does return an HttpResult, yes. (Or similar)
13:54:09 <c_wraith> Arahael: err.  what in wreq results in an exception?
13:54:09 <EvanR> and an Either version
13:55:22 <c_wraith> Arahael: or do you mean failures at the network level result in exceptions?
13:55:40 <c_wraith> Arahael: because http error responses certainly fit into the HttpResponse structure
13:55:42 <michaelt> tvdien: this seems to be a highlighting-kate problem, maybe you should make an issue.  https://github.com/jgm/highlighting-kate/
13:56:45 <Arahael> c_wraith: See the tutorial: http://www.serpentine.com/wreq/tutorial.html
13:56:51 <tvdien> michaelt: can you suggest any way to circumvent the issue for now?
13:58:06 <c_wraith> Arahael: huh.  It has no reason to do that - the HttpResponse object can handle those cases in-line
13:58:59 <Arahael> c_wraith: Good to know, so I shoudl look in Hackage or something for an alternative api?
13:59:13 <Arahael> c_wraith: Presumably there is a getWithEither or something?
14:00:33 <michaelt> tvdien: no, I can't see how to get around highlighting kate
14:01:57 <michaelt> tvdien: if I put them on the same line   'bandage_order', 'blood_test_order' , it works ... not sure what I'm doing though ...
14:06:32 <michaelt> tvdien: see if you can figure out https://github.com/esc/pandoc-with-pygments ; pygments isn't too likely to have bad python parsing....
14:07:32 <tvdien> michaelt: that's a good suggestion, thanks
14:08:03 <tvdien> michaelt: not that beginner friendly though :/
14:10:12 <mpickering> tvdien: is that valid python though?
14:10:25 <tvdien> mpickering: yes, it is
14:10:27 <unsymbol> evening
14:10:40 <Arahael> tvdien: No it isn't.
14:10:59 <Welkin> mpickering: slapping your keyboard is valid python
14:11:08 <tvdien> Arahael: what makes you think so? it runs fine
14:11:29 <Arahael> tvdien: Interesting, because {} doesn't specify any keys/values.  It should be a list.
14:11:35 <EvanR> cant we bash python in the python channel?
14:11:44 <Arahael> tvdien: Gah, I'm looking at the wrong link...
14:11:50 <hpc> EvanR: no, that's for pythoning bash
14:11:52 <Arahael> tvdien: http://lpaste.net/120727 :)
14:12:07 <tvdien> Arahael: oh I was inaccurate - my example is a set expression
14:12:17 <cow_2001> you can use pythonpy for pythoning while bashing
14:12:24 <tvdien> Arahael: the same issue happens with lists and dicts however
14:12:24 <EvanR> do the p-p-python bash
14:12:53 <tvdien> Arahael: set expressions are a bit more recent
14:13:02 <cow_2001> pip install pythonpy and you get a nice command called py
14:13:21 <Arahael> tvdien: Yeah, I haven't made much use of set expressions yet. (We're still stuck on 2.5, blegh...)
14:13:36 <tvdien> Arahael: 2.5? :|
14:13:54 <Arahael> tvdien: Insane, isn't it?  I just hope that they're using the point release where they fixed the generator memory leaks.
14:14:29 <tvdien> Arahael: I thought leaving 2.7 for 3.4 was tough :p
14:15:05 <Arahael> tvdien: I'm going to go for a bit, please excuse me while I mutter.
14:15:10 <Arahael> ;)
14:16:46 <tvdien> Arahael: anything more you can say about your work setting?
14:16:59 <tvdien> Arahael: I wonder what kind of environment could cause that
14:17:09 <EvanR> tvdien is actually your boss
14:17:13 <EvanR> beware
14:17:26 <tvdien> EvanR: haha
14:18:33 <Arahael> tvdien: No, but suffice to say that it's a highly controlled build environment, and it would require massive revalidation to change key components.
14:18:42 <Welkin> I have to wonder who makes the decisions about which languages/tools to use for a project
14:18:50 <Welkin> most companies seem to choose the worst possible ones
14:19:21 <EvanR> you know, it might have to do with what programmers want to use
14:19:23 <Welkin> "let's build our mission critical software in ruby on rails and angular js"
14:19:23 <ezrios> so I'm working with acid-state
14:19:25 <EvanR> it has a big effect on hiring
14:19:31 <ezrios> suppose I have some monadic computation Update Foo Bar
14:19:47 <ezrios> and I have an UpdateEvent Quux
14:19:53 <tvdien> Arahael: alright then, hang in there ;)
14:20:03 <Arahael> tvdien: I don't work in that team, at least. :)
14:20:05 <ezrios> is (EventResult Quux) -> Bar?
14:20:10 <monochrom> my theory is that people have great intuition. but then people also have a not-gate placed right after their intuition output.
14:20:11 <ezrios> er
14:20:16 <mniip> 'delete x' is basically 'filter (x /=)' right?
14:20:16 <ezrios> is (EvenrResult Quux) a Bar?
14:20:30 <hpc> ezrios: no
14:20:36 <mniip> ah wait, delete removes the first occurence
14:20:38 <EvanR> @src delete
14:20:38 <lambdabot> delete = deleteBy (==)
14:20:42 <ezrios> hpc: what is an EventResult then
14:20:53 <monochrom> so people reliably tell the good from the bad, and consistently choose the bad.
14:20:57 <mpickering> tvdien: I was more talking about how the comma is followed by a comment
14:21:24 <ezrios> say if quux :: Update Foo Bar
14:21:38 <tvdien> mpickering: any line starting with # can be ignored - python is fine with having a comment for the last element in a list/dict/set
14:21:39 <ezrios> ugh fuck
14:21:43 <ezrios> I don't understand all this TH magic
14:21:44 <hpc> ezrios: oh wait, forgot that's a type family
14:21:48 <tvdien> mpickering: that's actually encouraged
14:22:01 <hpc> it could potentially be
14:22:03 <tvdien> mpickering: anyway, the issue remains without the trailing comma and without the comment
14:22:30 <monochrom> hmm, are you parsing python syntax?
14:22:34 <ezrios> hpc: the way I see it, (Update st a) is like (State s a) yes?
14:22:37 <mpickering> tvdien: ok, open a issue on the issue tracker and we'll look at it then :)
14:22:44 <ezrios> I'm just wondering how to get at the value of type "a" in the Update monad
14:23:00 <ezrios> and it looks like this will be returned as an EventResult a by the update and query functions?
14:23:15 <hpc> ezrios: it's similar
14:23:16 <tvdien> mpickering: it's already there in github :)
14:23:24 <hpc> ezrios: specifically, they're both instances of MonadState
14:23:43 <EvanR> ezrios: so acid state keeps a log of updates. it records which Update action is done in the log, what the update does is up to your code. but it must be a pure update to work, no outside state or IO
14:24:06 <hpc> basically, each query or update you can perform is a pair
14:24:06 <EvanR> Query is just like Reader
14:24:13 <ezrios> what's the purpose of the second parameter in (Update st a) then
14:24:19 <hpc> of your action doTheThing :: Update whatevers
14:24:22 <ezrios> is that the "result" of the "Stateful" update computation?
14:24:25 <hpc> and a constructor DoTheThing
14:24:49 <EvanR> ezrios: yeah its the result of doing the update. think of a RNG
14:25:06 <EvanR> no such thing as command-query separation ;)
14:25:21 <ezrios> EvanR: so if I were to return a value of type a in an Update computation
14:25:35 <hpc> basically, everything's a pain in the ass with acid-state because of transactional guarantees
14:25:37 <ezrios> would a be the type of (EventResult MyUpdate)?
14:25:51 <hpc> a particular query or update could run more than once
14:25:52 <EvanR> a is any type you want, so no
14:26:00 <ezrios> EvanR: ok, specialize it to int
14:26:11 <EvanR> ok, Int is not EventResult MyUpdate
14:26:12 <ezrios> suppose I return something of type Int in myUpdate :: Update Foo Int
14:26:20 <ezrios> hnnng
14:26:36 <ReinH> johnw: So I wanted to show you a cool idea I had for a quasiquoter: I think I can write a quasiquoter for bit vectors that works as both an expression and a pattern, and where the pattern captures bits or runs of bits and binds them to variables.
14:27:02 <ezrios> so is there a way to get the Int result of myUpdate?
14:27:14 <ezrios> I thought there would be something like evalState from StateT or whatever
14:27:17 <EvanR> yes, you have to have some acid state though
14:27:24 <EvanR> to operate on
14:27:33 <EvanR> Foo in this case
14:27:54 <ReinH> johnw: e.g., interpret [bv|11sssddd] = mov (reg sss) (reg ddd) binds sss and ddd and the pattern only matches if the value matches v .&. 0xC0 == 0xC0
14:28:19 <ezrios> so if myUpdate :: Update Foo Bar
14:28:25 <ezrios> and I have some constructor MyUpdate
14:28:25 <dpwright> has anyone here got much experience with netwire? (preferably netwire 5, since I gather it's changed quite a lot).  I'm trying it out, but there's a couple of things about the way I'm using it that make me feel a bit uneasy that I might be "doing it wrong"
14:28:30 <ezrios> what is (EventResult MyUpdate)
14:29:07 <platz> dpwright: i found this thing once: http://todayincode.tumblr.com/post/96914679355/almost-a-netwire-5-tutorial
14:29:27 <EvanR> ezrios: i can figure this out if you want, but its not really important to using acid state ;)
14:29:30 <dpwright> platz: Thanks -- that's exactly the tutorial I went through yesterday!
14:29:48 <dpwright> it did a good job of getting me to a basic "something up and running" state
14:29:59 <ezrios> the reason I ask is because I have an AcidState of an IntMap
14:30:07 <ezrios> and I want to return the ID of a newly created record
14:30:12 <EvanR> makes sense
14:30:13 <ezrios> after the Update transaction is complete
14:30:21 <dpwright> the difficulty I'm having stems, in two cases, from Netwire's use of Either (ish)
14:30:26 <EvanR> the IDs are coming from a generator in the state too?
14:30:35 <Profpatsch> Okay, decoding error with UTF-8
14:30:37 <Profpatsch> https://bigmac.caelum.uberspace.de/paste/utf8-decoding.hs.html
14:30:38 <ezrios> EvanR: some maxKey function or whatever in Data.IntMap
14:30:43 <EvanR> ok
14:30:44 <Profpatsch> Can someone take a look?
14:30:48 <dpwright> in the first case, I find that I end up passing "Right ()" or "Right undefined" to nearly every call to "stepWire" that I make
14:30:52 <ezrios> so I figure
14:31:02 <EvanR> ezrios: right. so in your action, just return that id
14:31:05 <ezrios> "ok, just `put` the new IntMap into the AcidState and return th eid"
14:31:08 <ezrios> ok
14:31:14 <ezrios> so I am on the right track it seems
14:31:30 <Profpatsch> readProcess gives me Strings, I use ByteString.Lazy.UTF8 to convert them to BSs, then throw that into aeson’s decode.
14:31:50 <ezrios> thanks muchly EvanR :>
14:31:54 <Profpatsch> And thet throws: Left "Error(s) in JSON decoding:\nFailed reading: Cannot decode byte '\\xfc': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream"
14:31:59 <Profpatsch> *that
14:32:03 <dpwright> the wires are fairly simple and don't respond to events (if that's how you put it), so they never make use of that value, so "Right undefined" is "safe" I think... but it feels nasty having undefined littered all over my code.  Seems pretty common in code I've seen here and there though.
14:32:42 <hpc> > '\xfc'
14:32:43 <dpwright> Maybe there's another "stepWire"-like function for wires that ignore that argument?  But I didn't spot one on hackage
14:32:44 <lambdabot>  '\252'
14:32:48 <EvanR> ezrios: figured it out, EventResult MyUpdate would be Int, i was wrong earlier because theres some funny type families going on
14:33:26 <dpwright> similarly, I have a simple wire that just increments a number, but it returns an Either which I think represents whether or not the signal inhibits
14:33:34 <ezrios> EvanR: ok, so I should be able to just rip off the type wrapper and get at the result of my Update computation?
14:33:43 <ezrios> (type families are horrifying, I tried learning about them last month and gave up)
14:33:51 <EvanR> ezrios: there wont be a wrapper
14:33:57 <ezrios> even better
14:34:09 <ezrios> ah right because EventResult is a type function
14:34:15 <wolf_mozart> what's the usefullness of haskell other than writting nice oderly code?
14:34:27 <wolf_mozart> or code that doesn't have {}
14:34:37 <Profpatsch> hpc: Could that be an error in ByteString.UTF8?
14:34:42 <geekosaur> > text "\xfc"
14:34:43 <EvanR> ezrios: update :: AcidState (IntMap X) -> MyUpdate -> IO Int
14:34:43 <lambdabot>  ü
14:34:44 <Profpatsch> * a bug
14:34:46 <geekosaur> I doubt it
14:35:03 <dpwright> but I know it never inhibits.  It makes me feel uneasy just always pattern matching to "(Right x) <- stepWire ...", but on the other hand sticking in a case to say "if it's Left, drop out and kill my application" all over the place seems excessive, too.  I don't really know what it would "mean" for that signal to inhibit, so I find it difficult to put something meaningful in the case
14:35:07 <hpc> are you sure the process returns UTF8?
14:35:10 <ezrios> EvanR: woo, it works! I has an acid-state
14:35:14 <ezrios> thanks a bunch
14:35:29 <EvanR> ezrios: congrats. just dont change the structure of the state ;)
14:35:36 <hpc> heh
14:35:39 <geekosaur> \fc would in utf8 encoding refer to a code point well beyond U+10FFF
14:35:50 <ezrios> yeah, something something migrations
14:35:53 <ezrios> D;
14:36:09 <EvanR> postgres, you are the only via option for anything ever
14:36:10 <Profpatsch> hpc: readProcess returns String; is Char noch valid Unicode always?
14:36:47 <hpc> just guessing :P
14:36:56 <geekosaur> Profpatsch, that sounds like the wrong question to me
14:37:04 <Profpatsch> geekosaur: Yeah, I’ve got ü and ä and ö in the output.
14:37:09 <geekosaur> you seem to be assuming that \xfe is valid and the bug is in haskell
14:37:16 <geekosaur> but \xfe is not valid utf8
14:37:24 <geekosaur> er, \xfc
14:37:32 <EvanR> acid state could be really cool, if you have a GUI application whose state is in acid state, you could just kill it and reboot it and you will pick up exactly where you left off
14:37:39 <geekosaur> (\xfe would be easier to understand, start of a byte order mark)
14:37:46 <EvanR> but that is a lot of state not to change
14:37:51 <geekosaur> (except not really...)
14:37:55 <Profpatsch> geekosaur: You mean the process throws out malformed UTF-8?
14:38:08 <hpc> EvanR: nah, just store a JSON string
14:38:14 <geekosaur> or not throwing out utf8 at all
14:38:16 <Profpatsch> My locale is UTF-8.
14:38:17 <hpc> json is webscale
14:38:18 <orion> grr
14:38:19 <EvanR> hpc: on uncaught exception?
14:38:23 <EvanR> oh joking
14:38:24 <geekosaur> I'd suspect an iso8859
14:38:30 <orion> Is there a way to make test suites optional in cabal 1.22.0?
14:38:36 <geekosaur> except that I can't see json starting with ü
14:38:47 <shachaf> \xfc sounds like a character, anyway. Are you talking about the byte 0xfc?
14:39:12 <Profpatsch> geekosaur: But the strings in that json have üs.
14:40:28 <geekosaur> shachaf: [18 22:31] <Profpatsch> And thet throws: Left "Error(s) in JSON decoding:\nFailed reading: Cannot decode byte '\\xfc': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream"
14:40:37 <merijn> EvanR: Don't forget about daemons...
14:40:46 <merijn> EvanR: (for acid-state)
14:40:52 <geekosaur> Profpatsch, then I suspect you have not utf8 but iso8859-1
14:40:54 <merijn> EvanR: There the crash-resume paradigm is even nicer
14:41:08 <EvanR> yeah daemons which can take a beating and keep on going
14:41:25 <EvanR> assuming the crash issue isnt also corrupting your state
14:41:30 <merijn> Profpatsch: Your locale doesn't mean the data you have matches your locale
14:41:33 <EvanR> because of a bug in your update
14:41:38 <geekosaur> because ü is \xfc in iso8850-1 and \xc3\xbc in utf8
14:41:39 <monochrom> where can we obtain the input so that we can really decide whether the input is corrupted beyond repair or the parser has a bug?
14:42:04 <merijn> monochrom: If it reports an invalid value it doesn't sound like a parser bug to me
14:42:38 <Profpatsch> geekosaur: So readProcess just pipes the data in [Char] and doesn’t check the encoding at all?
14:42:50 <monochrom> yes, I have more faith in the parser, actually, and less faith in human beliefs
14:42:51 <Profpatsch> geekosaur: Will those be valid Chars then?
14:42:51 <merijn> Profpatsch: Check the encoding in what way?
14:43:28 <merijn> Profpatsch: It should use your locale
14:43:29 <Profpatsch> merijn: There is a hGetEncoding
14:43:34 <monochrom> one thing I learned from the movie Jupiter Ascending yesterday: "bees don't lie" :)
14:43:41 <merijn> Which doesn't help you at all if your data doesn't match your locale
14:43:45 <geekosaur> Profpatsch, readProcess probably does utf8 decoding. so maybe you are double-decoding
14:43:56 <geekosaur> ghc has had an encoding layer since 6.12
14:44:10 <wolf_mozart> what's the usefullness of haskell other than writting nice oderly code?
14:44:11 <merijn> geekosaur: Are you sure? I'd expect it to use locale dependent decoding
14:44:24 <merijn> wolf_mozart: Writing nice orderly code isn't useful by itself?
14:44:31 <geekosaur> it does but they said they're in utf8 locale
14:44:36 <tvdien> oh dear all the stuff that cabal needs to grab for pandoc to work :p
14:44:39 <geekosaur> should I have written 50 lines of explanation instead?
14:44:42 <wolf_mozart> well it is
14:44:58 <merijn> geekosaur: oh, right, nevermind >.>
14:44:58 <wolf_mozart> are you merijn from the haskell videos?
14:44:59 <Profpatsch> geekosaur: So how do I convert the Strings I get to the Lazy.ByteStrings aeson wants?
14:45:07 <geekosaur> anyway json decoding expects to be fed data from a socket, which is raw bytes
14:45:17 <merijn> wolf_mozart: AFAIK I'm not in a video, so presumably not? :)
14:45:30 <wolf_mozart> lol i thought
14:45:34 <geekosaur> if you're reading from a file or a process then ghc has already done the locale decoding unless you have told ghc not to
14:46:27 <Profpatsch> geekosaur: So I need to use createProcess and throw in the Handle instead of readProcess?
14:46:41 <monochrom> openBinaryFile will give you faithful raw bytes, or at least can.
14:47:01 <geekosaur> possibly yes, since readProcess gives you no control over or access to the handle
14:47:01 <wolf_mozart> but i don't get it, if c++ or python is more intuitive, and straight forward whats the purpose or advantage of functional language or is it just another way to do things other than convention
14:47:41 <hiptobecubic> wolf_mozart, i don't think everyone would agree that those languages are more intuitive
14:47:47 <Profpatsch> geekosaur: Yet, the Handle functions all return String, too …
14:48:02 <L8D> wolf_mozart: there are many benefits
14:48:11 <monochrom> intuitive ways are seldom effective, efficient ways
14:48:15 <L8D> wolf_mozart: fewer maintainence issues, shorter code, safer runtimes
14:48:45 <L8D> wolf_mozart: cleaner libraries, reasonable code, higher level optimizations
14:48:50 <monochrom> what you need is rational, calculated ways
14:48:50 <Profpatsch> wolf_mozart: Haskell is more intuitive. I held an “intro to programming”-course a week ago and used a haskell library.
14:48:51 <merijn> wolf_mozart: You're assuming that those languages are more intuitive, I, for one, disagree :)
14:49:05 <merijn> Also, what monochrom said
14:49:05 <wolf_mozart> safer runtimes, like arrays wont overflow? doesn't python have those gaurds?
14:49:22 <merijn> wolf_mozart: Ever try contributing to a major python project?
14:49:31 <Profpatsch> wolf_mozart: The types help incredibly to describe what functions to, even to bloody beginners.
14:49:32 <hiptobecubic> wolf_mozart, that is a very very low standard for 'safe'.
14:49:37 <L8D> wolf_mozart: safer runtimes as in fewer unintentional bugs
14:49:46 <mniip> I ended up with 2 versions of bytestring on my system, what do I do
14:49:57 <merijn> I have when I ran into a bug in mercurial, I couldn't figure out what anything was doing. No clue what the various variables where and which functions updated what
14:50:08 <wolf_mozart> hmm
14:50:15 <L8D> mniip: use cabal sandboxes
14:50:28 <monochrom> http://www.vex.net/~trebla/weblog/intuitive.html
14:50:35 <L8D> wolf_mozart: a far more expressive type systems
14:50:37 <merijn> wolf_mozart: I've also tried (well, succeeded) contributing to pandoc and GHC, but are substantially larger projects. I don't know anything about the design of either, but I managed to contribute non-trivial patches
14:51:03 <monochrom> to some old people, intuition says that the CDROM drive on your computer is a cup holder
14:51:10 <dpwright> wolf_mozart: For me the biggest thing is ease of refactoring/bug fixing.  I work with C++ in my day job, and there are some parts of the codebase that when bugs are reported, you literally have to make a judgement call of, "is it even worth trying to fix this bug or will I break too much other stuff by doing so?"
14:51:11 <merijn> wolf_mozart: Why? Because I had type for all variables, explicit inputs and no mutable state and thus everything was more tractable to reason about
14:51:57 <geekosaur> Profpatsch, I think you end up using something like read in raw mode and then use Data,ByteString.Lazy.Char8.pack. unless there's a version of the process primitives that give you ByteString directly instead
14:52:15 <dpwright> with haskell you can make vast sweeping changes, and by the time you've got it compiling again you can feel fairly confident that you won't have introduced any unanticipated behaviour... a lot more confident than you can be with C++ at any rate
14:52:28 <geekosaur> (that Char8 is kinda evil, but this situation is why it exists...)
14:53:07 <geekosaur> (and trying this *without* disabling input encoding handling will cause you to learn why it's evil...)
14:53:12 <merijn> geekosaur: ByteString already has functions for interacting with files directly
14:53:19 <ezrios> EvanR: I don't quite have a GUI application, but I do have a web application
14:53:20 <geekosaur> files yes, processes?
14:53:21 <mniip> L8D, what's that
14:53:22 <ezrios> with the frontend in Elm
14:53:23 <L8D> Haskell can be much more multi-purpose than C++ or Python too. It is great at writer parsers and compilers, as well as web servers and databases, as well as scripting jobs and declarative interface programming too
14:53:29 <geekosaur> I see no readProcess equivalent in there
14:53:38 <ezrios> more of a little toy learning project than anything
14:53:42 <Profpatsch> geekosaur: Ah, so I probably can use Lazy.Char8, because the encoding should already be okay.
14:53:51 <merijn> geekosaur: Processes are just handles, although that might be a problem too >.>
14:54:00 <L8D> mniip: it’s keeps packages installed on a per-project basis
14:54:03 <L8D> it*
14:54:03 <merijn> posix I think let's you do that using ByteString
14:54:04 <geekosaur> Profpatsch, you must disable ghc's encoding handling
14:54:13 <mniip> sounds counterproductive
14:54:18 <merijn> The portable process, maybe not
14:54:26 <geekosaur> Profpatsch, if you use Char8 without doing so then ghc will produce unicode codepoints and Char8 will lop off their heads
14:54:30 <L8D> mniip: have you worked with npm before?
14:54:36 <mniip> no
14:54:43 <mniip> well barely
14:54:51 <L8D> ah, then you probably would’t understand initially.
14:54:59 <wolf_mozart> if you make an object and it's as atomic as possible, and the interface stayed the same, if there is a bug, it can be easily fixed by going to the affected object and finding the problem, and there, i mean i could say object oriented coding is more intuitive because you're trying to model real world objects etc, i've been learning haskell but I don't quite understand how this type of coding helps
14:55:04 <wolf_mozart> with safe coding
14:55:17 <L8D> sandboxing allows you to keep versions of dependencies seperate from each project
14:55:22 <merijn> wolf_mozart: Have you ever, in your life, seen an object that was "as atomic as possible"?
14:55:32 <dpwright> the "real world object" model of OO falls down quite quickly in the real world though
14:55:33 <merijn> wolf_mozart: In my work working with projects in OO languages I never have
14:55:34 <geekosaur> and the utf8 decode following will give you garbage
14:55:36 <L8D> so if one project needs text 2.0 and another needs text 1.3 you don’t need to worry
14:56:05 <EvanR> wolf_mozart: having done exactly what youre talking about, that is not what i would say is a pleasant state of affairs
14:56:13 <EvanR> its not intuitive or easy, to me
14:56:33 <L8D> wolf_mozart: have you written a Haskell program that didn’t run correctly once the types checked?
14:56:33 <Profpatsch> geekosaur: Ah! http://hackage.haskell.org/package/bytestring-0.10.4.1/docs/Data-ByteString-Char8.html#v:hGetContents
14:56:36 <merijn> So...I once accidentally questioned whether "OO was intuitive for humans to think" in when the guy who invented Self was giving a talk to a room of smalltalk programmers >.>
14:56:39 <EvanR> in fact its frustrating after spending 3 hours investigating that kind of system to find out that the cause is something completely messed up and unfixable due to a design flaw
14:56:41 <Profpatsch> I think that’s it.
14:56:54 <geekosaur> I thought you wanted readProcess?
14:56:58 <merijn> They were not able to give a satisfactory answer to my questions >.>
14:57:05 <wolf_mozart> well i turned to haskell because my coding is becoming a clutter to me, but as far as i can see(im still learning) all what haskell is telling you is to think long and hard before you write a line of code and you'll be good
14:57:07 <monochrom> "an object as atomic as possible" --- that's just a primitive type, no need to talk objects.
14:57:19 <L8D> wait wait wait guys
14:57:21 <L8D> hold on
14:57:22 <L8D> calm down
14:57:28 <Profpatsch> geekosaur: And then not the Char8-Version, but the ByteString one.
14:57:28 <monochrom> :)
14:57:32 <mniip> L8D, reading about it
14:57:33 <L8D> First, OOP is not a direct counterpart to FP
14:57:44 <merijn> L8D: Who said it was?
14:57:45 <mniip> L8D, it claims to solve the "multiple instances of the same package" problem
14:57:52 <mniip> but not "multiple versions of the same package"
14:58:02 <L8D> we don’t need to argue over whether OOP is intuitive or not
14:58:02 <Profpatsch> geekosaur: Well, I’m happy with createProcess, too, if I can directly read that whole Handle into aeson
14:58:17 <Profpatsch> L8D: true that.
14:58:23 <merijn> wolf_mozart: I would say the main advantage of haskell is "it's easier to reason about code" and that's one of the prime ways to reduce bugs
14:58:29 <Profpatsch> CLOS is an object system in CL.
14:58:40 <L8D> wolf_mozart just wants to understand why FP is useful, not why OOP or C++ sucks
14:58:41 <Profpatsch> And Common Lisp is as functional as you get. :P
14:58:56 <monochrom> I don't oppose OOP. but I do oppose: using either advaned OO theory or advanced category theory to talk about merely primitive types. so there.
14:59:03 <merijn> wolf_mozart: And the ease of reasoning comes from: purity and parametricity
14:59:22 <dpwright> wolf_mozart: I think part of the reason you're being asked to "think long and hard" about things is because it's all new though.  I remember feeling similarly when I was first being taught OO -- why do I have to spend all this time thinking long and hard about class hierarchies and writing UML diagrams and the like, wouldn't it be easier just to write C?
14:59:27 <Rotaerk> I strongly oppose OOP
14:59:32 <Rotaerk> and FP
14:59:38 <wolf_mozart> L8D i don't want to be told where to put indentation
14:59:41 <merijn> wolf_mozart: Purity means: I always know exactly where state comes from and which bit of it can be mutated
14:59:43 <hsk3> How can I create my own IO monad, capable of reading from keyboard and writing to screen?
14:59:45 <Rotaerk> mostly because they're vague umbrella terms
14:59:46 <ReinH> merijn: I think another big advantage (which also comes in large part from purity and parametricity) is actual modularity and code reuse.
14:59:46 <dpwright> but after a bit of experience with C++ I found that that thought process didn't take so long any more
14:59:54 <merijn> hsk3: newtype
15:00:06 <dpwright> similarly, after a bit of experience with Haskell a lot of the decisions will seem like an obvious consequence of the types
15:00:14 <merijn> ReinH: Those come from being able to reason about your code, imo
15:00:23 <EvanR> wolf_mozart: dont be crippled by concerns of syntax, or you will miss out
15:00:24 <hsk3> merijn: No i mean, writing my own one from scratch. Is that possible?
15:00:36 <monochrom> oh, you're just fed up with Haskell layout rules? :)
15:00:49 <merijn> hsk3: Define "from scratch"
15:00:57 <ReinH> merijn: reasoning isn't sufficient though, it also needs to be composable, etc
15:00:57 <wolf_mozart> ok
15:00:58 <Rotaerk> wolf_mozart, also, you're told where to put indentation anyway, by convention
15:01:06 <hiptobecubic> wolf_mozart, that is a really terrible reason to avoid a language regardless.
15:01:07 <Rotaerk> e.g. you should indent things that are of nested scope
15:01:26 <hsk3> merijn: Create my own InputOutput monad that can write to screen. Without using the built-in IO monad
15:01:27 <ezrios> wolf_mozart: are you also opposed to Python then?
15:01:32 <monochrom> merijn, ReinH: I go with "compositional reasoning" :)
15:01:35 <wolf_mozart> what if i didn't feel like it and wanted things to be cryptic lol, but alright
15:01:37 <ReinH> merijn: perhaps it's not possible to get one without the other, though.
15:01:38 <Rotaerk> it's just that haskell, python, F#, etc, take advantage of the formatting you should already be doing, and infer scope based on it
15:01:46 <EvanR> if i told you that you were free to use braces and semicolons to format code in any oddball fashion you wanted, would that appeal to you?
15:01:55 <Rotaerk> which is what a reader of the code does anyway
15:01:56 <ReinH> merijn: But I think they both come from somewhere else ;)
15:02:01 <hsk3> merijn: I'm assuming this is not possible. The point of my question is really: Is IO, in this sense, a special kind of monad that is hardcoded into Haskell but one that we cannot write ourselves using just Haskell?
15:02:23 <ReinH> hsk3: Basically, yes.
15:02:32 <Rotaerk> when I'm reading C#, I don't determine scope by looking for braces, but by looking at indentation... at least until I find that they've formatted things wrong, and then I have to go hunting for braces
15:02:41 <merijn> hsk3: IO is actually a newtype around a special version of state
15:02:43 <orzo> we should have a standard idiom for distinguishing lazy and strict varients of imports
15:02:51 <geekosaur> hsk3, IO /per se/ is trivial. however the actual primitive operations it refers to must be implemented in a runtime
15:02:56 <L8D> hsk3: IO could be thought of as FFI calls though, so you could build something reminiscent of it
15:03:03 <orzo> inconsistency irks me
15:03:13 <hiptobecubic> there was a good blog post about this (kind of) by snoyman recently
15:03:28 <hsk3> Hmm
15:03:36 <ReinH> hsk3: Or, at least, the IO type is tied to GHC's implementation. It's possible that *other* runtimes would let you build and run a different representation of IO yourself.
15:03:36 <wolf_mozart> i mean i like the syntax and the precision of haskell, but i don't understand how it's actually better or faster, maybe i need to use it more, C++ is a very cumbersome langauge though with runtime errors i admit
15:03:39 <Profpatsch> EvanR: No, just no. :)
15:03:42 <hiptobecubic> hsk3, search on reddit for 'primitive haskell'
15:03:47 <hpc> hsk3: incidentally, you could write programs without IO as we know it today
15:04:08 <hpc> hsk3: before it was a Monad, IO was done as a list of side-effects, and it was... odd
15:04:19 <merijn> hsk3: So, depending on what you're trying to figure out/learn and how deep you wanna go, there's several avenues of exploration
15:04:28 <geekosaur> main :: [Response] => [Request], wheee
15:04:35 <EvanR> wolf_mozart: grab a book and get started
15:04:37 <hsk3> merijn: which avenues?
15:04:37 <geekosaur> er, ->
15:04:48 <wolf_mozart> i'm in the middle
15:04:48 <geekosaur> I retyped that 3 times and still got it wrong :(
15:05:00 <ReinH> hsk3: There's some history of IO in Haskell in http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
15:05:00 <valdyn> wolf_mozart: you can read about which class of errors haskell prevents in various books or online
15:05:01 <bennofs> geekosaur: => is the same as -> in GHC anyway
15:05:01 <monochrom> I am more confident when using Haskell, less confident when using C++. C++'s level of details is a DoS on my brain.
15:05:10 <merijn> hsk3: IO in GHC is: "IO (State# RealWorld -> (#State# RealWorld, a#))" i.e., like I said it's a special form of the State monad, you can create your own "IO" operations using internal primitives exposed by GHC
15:05:11 <Rotaerk> wolf_mozart, understanding how it's better is not something you'll understand until you understand haskell :P
15:05:38 <monochrom> however, this is only because I care about preventing bugs
15:05:43 <merijn> hsk3: Well, there's the "Lazy Functional State Threads" paper, which described the trick underlying both the ST and IO monads in GHC
15:06:00 <merijn> hsk3: Basically IO and ST are specialised version of a single underlying monad in GHC.
15:06:03 <init> hsk3: one approach would be something like this ttp://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html ; and then have a function "runIO : MyIO a -> IO a"
15:06:04 <monochrom> understandably, people who don't care about preventing bugs will find C++ less effort than Haskell.
15:06:10 <hsk3> Do 99% of Haskell programmers need to worry about this stuff, or can they just say for simplicity that IO is a special monad?
15:06:17 <wolf_mozart> i might aswell use python or R or php if i was concerned with bugs and such
15:06:26 <ReinH>  hsk3 And a bit more in http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
15:06:26 <merijn> hsk3: Well, I would phrase if differently
15:06:33 <valdyn> hsk3: you dont need to think of it as being special either
15:06:37 <merijn> hsk3: You can 95-98% of haskell coding without needing to think about this
15:06:48 <ReinH> hsk3: IO is an abstract type that can only be used via its exported interface.
15:07:04 <merijn> ReinH: Except that's not really true :)
15:07:17 <ReinH> merijn: Can I just pretend that it is? :p
15:07:24 <hpc> merijn: you can be pedantic and say the exported interface is FFI + RTS
15:07:29 <merijn> You can create your own IO values easily enough :)
15:07:29 <ReinH> 99% of the time that's how it's used anyway
15:07:40 <monochrom> no, I would not use python either. I saw a trivial runtime type error bug in Duplicity. one easily caught by the most trivial static type system in the world.
15:07:50 <wolf_mozart> in cpp for example when you want to print to screen you just do cout<<"Something"; //send string to c-output what's the haskell equivalent?
15:07:57 <ReinH> hsk3: Part of that interface is the monad interface, but It's better to think of "IO the type" than "IO the monad"
15:08:06 <wolf_mozart> i mean that's certainly straightforward
15:08:07 <hpc> wolf_mozart: putStrLn "something"
15:08:13 <hsk3> ReinH: but IO is a type constructor..
15:08:15 <hsk3> not type
15:08:23 <merijn> hpc: No, the exported interface is functions returning unboxed tuples
15:08:25 <Welkin> IO a is a type
15:08:26 <init> "the \forallx. IO x type"
15:08:26 <wolf_mozart> ok
15:08:26 <Rotaerk> the fact that IO is a monad seems to me to get way too much focus
15:08:30 <ReinH> The practical benefit of the monad interface is mostly that it behaves nicely with do notation
15:08:34 <merijn> hpc: Which you can completely type safely create
15:08:43 <Rotaerk> the fact that it's a monad allows you to chain IO operations together... it's not what allows IO to magically "work"
15:08:45 <merijn> hpc: The FFI is an ugly unsafe way to create IO values
15:08:48 <wolf_mozart> "monad" lol
15:09:15 <bob_twinkles> wolf_mozart: or just 'print thing' if you just want 'putStrLn $ show thing'
15:09:30 <ReinH> hsk3: "type" is usually used to refer to types of all kinds.
15:09:35 <hiptobecubic> Rotaerk, the problem is that it *is* essentially special because everyone assumes you can always do anything from anywhere. Then they come to haskell and are told, "No. You can only do that in IO." and IO becomes the sacred cow monad with all the magic powers.
15:09:36 <ReinH> So it is both a type and a type constructor.
15:09:36 <hsk3> Ah ok
15:09:38 <hsk3> Ok
15:09:39 <jle`> hsk3: is a list a type?
15:10:00 <jle`> it's a type in the sense that it is a data type
15:10:05 * hackagebot cabal-bounds 0.9.1 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.9.1 (DanielTrstenjak)
15:10:08 <hsk3> ok
15:10:13 <jle`> but it's a "type constructor" in type signature land
15:10:13 <hiptobecubic> jle`, you mean data structure?
15:10:25 <jle`> yeah, data structure heh
15:10:27 <merijn> jle`: It's still also a type...
15:10:29 <ReinH> hsk3: Types of kind * are sometimes called "concrete types" to distinguish them.
15:10:38 <ReinH> They are the ones that are inhabited by values.
15:10:44 <merijn> ReinH: No, concrete types are a poor term
15:10:47 <ReinH> merijn: Ok.
15:10:51 <jle`> merijn: what's that in response to?
15:10:55 <ReinH> types of kind * are not called "concrete types" because that is a poor term.
15:11:02 <ReinH> merijn: what's the proper term?
15:11:03 <Rotaerk> hiptobecubic, it should be thought of as the sacred cow *type*, not monad :P  I'm just saying that a lot of newcomers seem to think that IO can do I/O *because* it's a monad
15:11:08 <jle`> concrete type is also used to say non-polymorphic types too
15:11:11 <merijn> ReinH: No one ever knows whether concrete type is: 1) monomorphic 2) type of kind * or 3) both
15:11:13 <jle`> concrete is just weird
15:11:17 <ReinH> merijn: fair enough
15:11:22 <merijn> ReinH: monomorphic and/or type of kind *
15:11:26 <Welkin> concrete just means it has kind *
15:11:30 <Welkin> to me, at least
15:11:36 <merijn> Welkin: So, is "Maybe a" a concrete type?
15:11:38 <jle`> Welkin: not to everyone :)
15:11:42 <merijn> Some people argue it's not
15:11:45 <ReinH> I'm happy to avoid confusing terminology.
15:11:50 <jle`> it's ambiguous enough to be a confusing term
15:11:55 <Welkin> merijn: good point
15:11:58 <merijn> They'll say "Maybe Int" is concrete, but "Maybe a" is not
15:11:59 <jle`> I'll call Maybe Int a cement type
15:12:04 <Welkin> hm
15:12:17 <merijn> Therefore I prefer monomorphic/polymorphic and explicit kind signatures which are both unambiguous
15:12:32 <dulla> Maybe a is * -> *
15:12:36 <merijn> dulla: No
15:12:37 <jle`> :O
15:12:42 <dulla> afaik
15:12:43 <merijn> dulla: "Maybe a" is kind *
15:12:44 <hpc> ask a mathematician sometime if zero is an integer
15:12:46 <Welkin> :kind Maybe a
15:12:49 <init> @kind forall a. Maybe a
15:12:50 <lambdabot> *
15:12:51 <Welkin> @kind Maybe a
15:12:52 <lambdabot> Not in scope: type variable ‘a’
15:12:54 <merijn> dulla: "Maybe" is kind "* -> *"
15:12:57 <init> doesn't seem to be of kind * -> *
15:12:58 <dulla> ah
15:13:11 <init> (fix my english, too)
15:13:12 <Rotaerk> hpc, isn't it absolutely "yes"?
15:13:14 <merijn> dulla: "Maybe a" is "Maybe" applied to a type variable of kind * :)
15:13:16 <monochrom> hpc: wait, do you mean "if zero is a natural number"?
15:13:18 <dulla> how about invent a stand in notation for the term
15:13:24 <dulla> polyconcrete
15:13:29 <cmccann> merijn: and then some people use "polymorphic" to mean types with class constraints and/or un-unified type variables, not parametric types like Nothing :: Maybe a
15:13:30 <jle`> polycrete
15:13:43 <dulla> sounds like that frozen sawdust, jle
15:13:51 <hpc> er yeah, i was thinking Z+
15:13:55 <hpc> vs N
15:14:05 <monochrom> :)
15:14:11 <dulla> :^)
15:14:23 <jle`> kind-* term sort of requires your audience to understand kinds though
15:14:29 <monochrom> the nice thing about standards is that there are so many to choose from
15:14:36 <merijn> Incidentally, to go back to types vs type constructors: Maybe is 1) a type constructor and 2) a type of kind * -> *
15:14:38 <Rotaerk> is 0 a natural number?  or is it processed?
15:14:40 <Welkin> jle`: but not sorts
15:14:41 <jle`> which depending on your situation, might be more or less of a problem
15:14:51 <dulla> when you are competent, at least
15:14:56 <jle`> what about all kinds of sorts
15:14:56 <merijn> jle`: I've found that most people grok kinds easily enough :)
15:15:29 <Welkin> "Dr. Seuss explains Category Theory"
15:15:35 <dulla> to be, or not to be
15:15:35 <merijn> "Did you ever wonder what the type of a type was?" 'yeah...' *show Maybe example with kind signatures* 'ooooh....'
15:15:35 <monochrom> the two kinds "*" and "* -> *" are not hard to explain.
15:16:21 <EvanR> did you ever wonder what the type of all types was
15:16:44 <init> it's just Type 1
15:16:46 <merijn> EvanR: The set of all possible kinds :p
15:17:08 <EvanR> the type of all types including itself
15:17:14 <monochrom> did you ever wonder who shaves those who don't shave themselves? :)
15:17:20 <hsk3> Thanks all. Useful info
15:17:24 <merijn> monochrom: No one, going by my beard :D
15:17:30 <dulla> what is a bottom?
15:17:49 <monochrom> bottom stands for "this program does not have an answer"
15:18:05 <merijn> dulla: Bottom often symbolised as _|_ is the name of "non-existent" values
15:18:12 <merijn> dulla: i.e. non-terminating/crashing programs
15:18:15 <Rotaerk> it even looks sort of like someone's bottom
15:18:25 <Welkin> it is the perpendicular symbol
15:18:29 <dulla> What kind of world do you live in, Rotaerk
15:18:32 <Welkin> a contradiction
15:18:34 <merijn> In haskell, if you think of types (of kind *) as sets of values, then bottom is the value that inhabits every set
15:18:43 <Rotaerk> heh
15:18:51 <hyPiRion> :t undefined
15:18:52 <lambdabot> a
15:18:58 <dulla> because everything can be wrong
15:18:59 <EvanR> Rotaerk: ash wednesday calm down
15:19:00 <merijn> dulla: i.e. the set of values for the type Bool would be True, False and bottom (this sounds like a daily wtf post ;))
15:19:22 <merijn> dulla: Because ruling out bottom means proving that an expression terminates, which runs head first into the halting problem ;)
15:19:36 <EvanR> dulla: well, a total function on integers cant "be wrong"
15:19:41 <cmccann> merijn: so bottom = FILE_NOT_FOUND? amazing!
15:19:55 <dulla> bottom, you've hit rock bottom, qq more
15:20:00 <EvanR> dulla: but in haskell theres no way to express this
15:20:01 <merijn> dulla: Suppose I claim that "f x" returns a Bool and "f x" in fact never terminates, does that mean it returns a Bool or not?
15:20:01 <hyPiRion> EvanR: That entirely depends on the execution of said function, doesn't it?
15:20:02 <hpc> cmccann: i hate to break it to you...
15:20:18 <EvanR> hyPiRion: no?
15:20:56 <dulla> if it runs into a loop then it's not hard to peg it as "not a Bool"
15:21:01 <dulla> in effect
15:21:11 <merijn> dulla: There are languages where bottoms are forbidden, such as Coq and Agda. They achieve this by sacrificing Turing completeness (in the absence of that you can guarantee all expressions are total, i.e., terminate) and therefore proof that it WILL eventually returna  Bool
15:21:30 <merijn> dulla: Right, but you can't always prove that it loops, due to the halting problem :)
15:21:54 <dulla> Eh, freeze frames are a close cousin
15:21:56 <monochrom> it is very hard to me
15:22:22 <dulla> so, what's the point of turing completeness, in that regards, what is gained by having a bootom
15:22:23 <EvanR> your javascript callback "must" complete
15:22:24 <monochrom> or rather, the way you phrase it is easy, but it is also beside the point
15:22:30 <dulla> probably error handling
15:22:34 <dulla> ech
15:22:35 <EvanR> turing complete is overkill ;)
15:22:40 <merijn> dulla: I'm becoming more and more convinced Turing completeness is overrated
15:23:04 <dulla> Ethereum starves on halting problems, so it's good enough
15:23:09 <merijn> dulla: The problem is building languages that are expressive enough to let us write all programs we want, without accidentally making them Turing complete
15:23:18 <merijn> dulla: Which is an open field of research :)
15:23:31 <dulla> Neat
15:23:50 <EvanR> my life program goes from one step to the next, always completes. my rendering subprogram always finishes the current frame.
15:23:57 <EvanR> or something is very wrong
15:24:02 <monochrom> Turing completeness gives me money. I get the money by TAing a course that includes computability.
15:24:09 <dulla> sounds like the same issue with Monads, and Arrows, you don't necessarily need to have all the laws
15:24:12 <monochrom> or rather, incomputability.
15:24:13 <dulla> but they be ok
15:24:47 <EvanR> monochrom: turing completeness is a conspiracy! imposed on us from the top down to keep us in poverty! free you mind sheeple
15:24:54 <merijn> dulla: Not entirely related, you might be interested in Software Foundations, it's a book on proving properties about programs, it starts with proving things for simple pure functions and slowly moves onto imperative languages
15:25:11 <merijn> dulla: This quickly illustrates how hard it can become to prove simple properties like termination :)
15:25:19 <merijn> Free book + exercises are here
15:25:21 <merijn> @where sf
15:25:21 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
15:25:21 <lambdabot> assistant."
15:25:41 * merijn is slowly corrupting more people into formal methods :>
15:25:45 <dulla> I feel like making a lesbian joke
15:25:54 <dulla> Eh, I'm a shill for math anyways
15:26:20 <merijn> dulla: Then this should be especially up your alley :p
15:26:32 <dulla> no coqs allowed, though
15:26:34 <arw_> ah. i'm from an operating systems chair. turing completeness doesn't matter as long as there is a timer interrupt or a watchdog :>
15:27:05 <monochrom> sometimes I pull the power plug, too
15:27:16 <dulla> how about a fuel
15:27:24 <EvanR> yeah your cpu instructions better damn well terminate
15:27:47 <arw_> usually they do, except on intel.
15:27:54 <EvanR> the need for infinite loops gets farther and farther away from application programming, god of the gaps!
15:28:08 <arw_> on intel the MMU is turing-complete, so a memory access may take forever.
15:28:21 <monochrom> that must be fun
15:28:24 <EvanR> oh god
15:28:48 <dulla> Can you feel it?
15:29:10 <drewr> hiya, I'm trying to use mappend (<>) with optparse-applicative, but the module in which I've imported Options.Applicative claims that Options.Applicative.Builder doesn't export (<>), which it clearly does (using ghc 7.8.3)
15:29:20 <monochrom> the answer to "why is Turing completeness everywhere" is "it's so hard to notice that you have crossed the line"
15:29:30 <merijn> drewr: Are you looking at the right docs?
15:29:42 <L8D> drewr: you should import (<>) from Data.Monoid
15:29:43 <peddie> arw_: the MMU doesn't have unbounded memory, thankfully :)
15:29:51 <monochrom> in fact, the question "have you crossed the line" is equivalent to the halting problem.
15:29:54 <drewr> merijn: I did a `cabal unpack` to make sure
15:29:55 <EvanR> its like the event horizon to a big black hole
15:30:17 <arw_> peddie: you don't need unbounded memory for endless loops unfortunately
15:30:21 <merijn> Anyway, yeah, just importing Data.Monoid is the best way to do it
15:30:33 <monochrom> an example of "what a computer can't solve, a human is only even worse"
15:30:33 <merijn> arw_: You do need unbounded memory for Turing completeness, though :)
15:30:35 <arw_> peddie: but yes, its not a real turing machine.
15:30:46 <peddie> arw_: good point
15:30:47 <drewr> L8D: if I import Data.Monoid I get type errors from mappend not having the right instance
15:30:55 <merijn> Which is why C is not Turing complete but haskell is :p
15:30:59 <Saizan> monochrom: strong normalization proofs are such a mess
15:31:03 <arw_> peddie: just as real as you can get with the available address space, like all computers one might really use.
15:31:05 <drewr> ...which makes sense, because that's in O.A.Builder I think
15:31:13 <merijn> (The language, none of the implementations can be Turing complete, assuming a finite universe)
15:32:23 <arw_> merijn: what you say sounds like haskell couldn't be implemented in c. i wouldn't really believe that.
15:33:00 <EvanR> the language being the limit of better implementations
15:33:10 <monochrom> he just means: theoretical Haskell can't be implemented in theoretical C
15:33:40 <Rotaerk> haskell can't be implemented on computers
15:33:41 <monochrom> theoretical Haskell's "pointer" is unlimited, but theoretical C's "pointer" is.
15:34:00 <monochrom> however, this says nothing about practical Haskell and practical C
15:34:06 <merijn> arw_: The Haskell report doesn't specify a maximum pointer/heap size
15:34:12 <shachaf> C with POSIX can be Turing complete.
15:34:13 <lightstep> in what sense are C pointers limited?
15:34:19 <merijn> arw_: Therefore the haskell language is not bounded in its memory consumption
15:34:39 <merijn> lightstep: The C spec mandates that void pointers can 1) address the entire address space and 2) are finite in size
15:34:53 <arw_> nope and irrelevant.
15:34:58 <merijn> lightstep: Therefore the available memory in C is finite, making it not Turing complete
15:35:13 <arw_> you can use pageswapping mechanisms to address more memory. like you do when mmaping files.
15:35:35 <merijn> arw_: Those are not part of the C spec and thus not the C language
15:35:55 <merijn> And therefore do not invalidate my claim that C, the language, is not Turing complete
15:36:04 <merijn> If you add filesystems you can make it Turing complete
15:36:05 <EvanR> haha
15:36:23 <shachaf> arw_: mmap doesn't help, everything goes in the same address space.
15:36:29 <merijn> Well, filesystem/unbounded storage APIs
15:36:43 <shachaf> Oh, unless you mean unmapping and remapping files, which I guess you do.
15:36:56 <lightstep> merijn: i'm not an expert on this, but recall that you can't convert a pointer to a number, and are not allowed to alias pointers of different types. so the standard might allow the parts of memory containing pointers to be non-boolean (or even with an infinite alphabet)
15:37:02 <arw_> shachaf: yes. or swapping memory segments.
15:37:04 <hpc> shachaf: but then you also need a filesystem with unbounded filename size
15:37:10 <merijn> lightstep: Anyway, since the haskell doesn't specify HOW haskell memory is managed/implemented the language spec doesn't limit the possible memory, rendering it Turing complete
15:37:17 <shachaf> But then your problem is that according to the C spec, you can get a position inside a file, which fits in some finite value.
15:37:35 <merijn> lightstep: You can convert pointers to a number
15:37:38 <lightstep> (just throwing a crazy idea in the air, the standard probably forbids this)
15:37:42 <merijn> lightstep: The spec explicitly allows that
15:37:52 <merijn> That's why pointer arithmetic works
15:38:04 <shachaf> hpc: open() takes a path anyway, which is in memory and therefore finite.
15:38:16 <hpc> doh
15:38:21 <shachaf> Your only hope is a file that supports relative seeks.
15:38:34 <merijn> shachaf++
15:38:35 <arw_> lightstep: the c-spec allows for code and data pointers to be different and not mutually convertible (in a certain way)
15:38:58 <shachaf> The C spec doesn't allow for that (ftell tells you your position in a file) but I think POSIX does.
15:38:59 <merijn> arw_: Right, but code pointers aren't writable and thus not usable as memory :)
15:39:19 <tromp_> c specifies that pointers have a sizeof(), wihch limits their range
15:39:26 <hpc> all you need is an infinite amount of code
15:39:52 <merijn> arw_: Incidentally, fun fact everyone always forgets: Casting function pointers to void* is not allowed by the spec :) (It is mandated by POSIX, though)
15:40:01 <dulla> needs more infinite context zippers that can travel through time
15:40:05 <tvdien> I can't get pandoc to work with pygments for pdf output :/
15:40:23 <geekosaur> fgetpos/fsetpos are opaque, per C90
15:40:42 <arw_> shachaf: fseek can seek relative to current and is c89.
15:41:29 <merijn> Anyway I should get ready for bed, I'll leave this trolling question here while I brush my teeth and I'll take answers in #haskell-blah when I get back: https://gist.github.com/merijn/0392ae239b9a091986ae <- Is this standard defined, implementaton defined or udnefined behaviour? And wht is the result?
15:41:41 <arw_> shachaf: so one could build an infinite tape with that. which still doesn't give you an arbitrarily large state that a TM requires, but its a start
15:41:45 <monochrom> yikes, Haskell FFI relies on casting function pointers to void* all the time
15:41:53 <geekosaur> the only thing you can do with a value returned by fgetpos is pass it to fsetpos, and fsetpos can only accept things returned by fgetpos. fseek is covered by ANSI C but deprecated and I think explicitly "may not be supported on all platforms" which is why fgetpos/fsetpos
15:42:00 <merijn> monochrom: Well, like I said, it's mandated by POSIX
15:42:10 <merijn> monochrom: So it's fine on any platform we care about
15:42:33 <arw_> monochrom: the limitation is only relevant on weird harvard archictures. atmel or vax or something...
15:42:57 <geekosaur> (and in fact ANSI C fseek/ftell does the wrong thing on any platform which does newline translation)
15:42:59 <merijn> monochrom: The reason is that code may be in different, for example, read-only memory and thus have a memory space that doesn't overlap with the storage memory space
15:43:14 <shachaf> arw_: As I remember ftell can't fail due to the file being too big in C89. But I'm not completely sure about that.
15:43:21 <shachaf> arw_: At any rate POSIX explicitly allows it.
15:43:34 <merijn> monochrom: And hypothetically the code memory space might be bigger than RAM, thus overflowing void* if it's silly small
15:44:18 <monochrom> true that
15:44:18 <merijn> monochrom: The nice and proper way to do it would be to cast to intptr_t which is guaranteed to be big enough to hold any pointer AND any function pointer
15:45:43 <phaazon> hm
15:45:45 <phaazon> I don’t get it
15:45:57 <phaazon> in netwire, how am I supposed to create my own events?
15:46:05 <phaazon> like “KeyPressed”
15:50:18 <dpwright> phaazon: It's in Control.Wire.Unsafe.Event (https://hackage.haskell.org/package/netwire-5.0.1/docs/Control-Wire-Unsafe-Event.html), but might not be necessary as often as you might think, from what I can gather
15:50:44 <dpwright> I've been using netwire-input for that specific case: https://hackage.haskell.org/package/netwire-input
15:51:13 <dpwright> (I've only been using netwire since yesterday, so there might be someone more knowledgeable than me around...)
15:54:33 <darthdeus> hey guys, if I'm getting rejecting: lucid-2.9.1 (global constraint requires ==2.5) ... how can I see where the global constraint is coming from? I'm in a sandbox
15:54:50 <darthdeus> I've tried running cabal with -v3 but no info
15:56:16 <dcoutts_> darthdeus: do you have constraints listed in your local cabal.config? Or is lucid one of the local source packages in your sandbox?
15:56:49 <darthdeus> dcoutts_: oh nice, it's in cabal.config from stackage LTS config :)
15:57:34 <darthdeus> thanks, I guess i can just remove that one constraint from there
15:59:20 <orzo> i haven't done a rigorous measurement, but I am getting some counter-intuitive experience regarding quickcheck behavior.  I refactored some code that would filter 'arbitrary' calls using suchThat to instead fmap a sanitizer over the arbitrary.  It seems to go slower rather than faster, contrary to my expectation.
16:14:33 <dulla> must be caching
16:14:38 <bennofs> orzo: suchThat will discard the current test case if the condition fails
16:14:51 <bennofs> orzo: so if you're discarding a lot of test cases, it will be slower
16:17:13 <bennofs> @check forAll (arbitrary `suchThat` (== 124124132)) $ \x -> (x :: Int) == 124124132
16:17:16 <lambdabot>  (0 tests)mueval-core: Time limit exceeded
16:17:47 <bennofs> This will essentially do a brute force search of arbitrary int values searching for one that matches == 124124132
16:24:21 <nisstyre> So for some reason I've never needed this, but how do you make cabal install log all errors to an actual file? (rather than hackishly redirecting it)
16:25:02 <bennofs> nisstyre: --build-log maybe?
16:25:06 <solatis> hmmm, is there a way in applicative / attoparsec combinators to return the "previous" result?
16:25:10 <solatis> to illustrate:
16:25:19 <bennofs> nisstyre: see cabal install --help
16:25:22 <solatis>    result <- string "HELLO REPLY RESULT=" *> parseResult
16:25:25 <solatis>    _      <- endOfLine
16:25:28 <solatis>    return result
16:25:36 <solatis> can i onelineify that ? :)
16:25:49 <bennofs> solatis: string "HELLO REPLAY RESULT=" *> parseResult <* endOfLine
16:26:00 <solatis> ah, geez, that was simple
16:26:23 <nisstyre> bennofs: --build-log=errors.log worked
16:26:25 <nisstyre> thanks
16:26:38 <nisstyre> 270 lines of errors ^_^
16:40:20 <ryantrinkle> is it possible to import modules when using ghc -e ?
16:40:46 <shachaf> ghc -e 'import Foo' -e '...'
16:40:55 <shachaf> Or -e ':m + Foo' -- each -e argument is a ghci command.
16:41:04 <ryantrinkle> ah, perfect; thanks!
16:46:04 <solatis> hmmm, i'm sorry if i'm asking too many noobish questions, but i'm having trouble wrapping my head around the docs
16:46:16 <solatis> is there any way to rewrite this into a one-line:
16:46:20 <solatis>         version <- string "OK VERSION=" *> decimal `sepBy` char '.'
16:46:21 <solatis>         return (VersionResultOk version)
16:46:38 <solatis> as in, is there an applicative operator i can use?
16:46:49 <solatis> or can this be achieved with function composition?
16:48:08 <bananagram> you could do `liftM VersionResultOk $ string ...`
16:48:18 <bananagram> :t liftM
16:48:19 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
16:48:35 <bob_twinkles> VersionResultOK <$> (string "OK.... would also work I believe
16:48:44 <solatis> let me see
16:49:09 <solatis> <$> works!
16:49:18 <solatis> i just had to wrap the statement in parenthesis
16:49:28 <bob_twinkles> hlint can help you with this sort of thing in the future
16:49:40 <solatis> i'm using hlint, but it didn't help me in this case
16:49:46 <bob_twinkles> ah, ok
16:49:58 <solatis> but yeah, it helped me find out about the Control.Monad.void function, yes :)
16:51:23 <solatis> what about this one?
16:51:36 <solatis>         _ <- string "NOVERSION"
16:51:37 <solatis>         return VersionResultNone
16:54:52 <solatis> what would i even have to search for in google to find the answer to this ?
16:55:19 <c_wraith> solatis: better to use hoogle and search for the type
16:55:26 <c_wraith> @hoogle m a -> m ()
16:55:29 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
16:55:29 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
16:55:29 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
16:55:49 <solatis> @hoogle m a -> m
16:55:49 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:55:49 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:55:49 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
16:56:07 <c_wraith> solatis: that's a kind error, which hoogle seems not to care about. :)
16:56:20 <solatis> hmz
16:56:35 <solatis> the problem is that void returns ()
16:56:42 <solatis> i do not want anything to be returned
16:56:52 <solatis> void is the same as saying 'return VersionResultNone ()'
16:56:58 <solatis> i want 'return VersionResultNone'
16:57:02 <davean> I think you don't understand "return"
16:57:16 <solatis> return lifts, right?
16:57:20 <davean> no
16:57:38 <solatis> return :: a -> m a i thought?
16:57:45 <ezrios> :t return
16:57:46 <lambdabot> Monad m => a -> m a
16:57:51 <davean> yes, sure
16:57:54 <ezrios> :t lift
16:57:55 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
16:58:05 <ezrios> :t liftM
16:58:06 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
16:58:11 <init> solatis: about "string "NOVERSION" >> return ..";    string "NOVERSION" $> VersionResultNone
16:58:22 <ezrios> liftM is fmap
16:58:36 <solatis> oh geez, that makes so much sense
16:58:41 <ezrios> lift takes a monadic operation in a Transformer stack
16:58:50 <ezrios> and turns it into a monadic operation for the next monad down in the stack
16:59:11 <ezrios> return is Applicative pure
16:59:15 <ezrios> if that makes sense to you
16:59:25 <jamshid> @pointfree f (x:_:rest) = x:f rest
16:59:25 <lambdabot> Unknown command, try @list
16:59:31 <jamshid> @list
16:59:31 <lambdabot> What module?  Try @listmodules for some ideas.
17:00:09 <jamshid> @pl f (x:_:rest) = x:f rest
17:00:10 <lambdabot> f = fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . const) .) . flip ((.) . (:)))
17:00:17 <jamshid> ugh....
17:00:59 <augur> whats the standard postgresql lib?
17:02:12 <hpc> the closest there is to standard is the odbc driver
17:02:15 <jle`> to be fair, lift is a pretty vague word even in haskell
17:02:20 <hpc> but that's a lot like asking what the standard webserver is
17:03:43 <Profpatsch> Is there something like until :: (a -> Bool) -> (a -> a) -> a -> a for Monads?
17:03:59 <hpc> @hoogle while
17:04:00 <Profpatsch> I’ve got hIsEof :: Handle -> IO Bool
17:04:02 <lambdabot> package while-lang-parser
17:04:02 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
17:04:02 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
17:04:05 <hpc> hmm
17:04:34 <Profpatsch> And I have no idea apart from recursing.
17:04:50 <hpc> i guess write it yourself
17:07:42 <augur> hpc: ill put it another way
17:08:04 <augur> i see hdbc mentioned in some places, and postgresql-simple comes up occassionally
17:08:34 <augur> and im not sure if there are others
17:10:14 <jle`> Profpatsch: what is the non-monadic one supposed to do?
17:10:48 <hpc> ah, i can't think of any different ones
17:11:12 <hpc> there's query-building apis but i don't think they have actual backends to them
17:11:19 <hpc> and i can't remember the names of those even
17:11:47 <augur> hpc: ok, thank you
17:13:13 <Ring0`> if I want a function to take unknown type as a paramters, should I use pointers? Like in C, for example, you can use (void *) - void pointers if you don't know what type of data you'll get
17:13:27 <shachaf> Probably not.
17:13:33 <hpc> if you don't know the type, how would you do anything with the value?
17:13:35 <shachaf> But it depends on what you want to accomplish.
17:13:47 <Ring0`> hpc: well later you may pass function that already knows that :)
17:14:02 <Hijiri> Ring0`: but you won't know that the value is the correct input type
17:14:04 <Ring0`> basically I'm trying to build an array that'll hold values but they can be strings, numbers or anything else
17:14:10 <Hijiri> so how do you know that you are allowed to pass it in?
17:14:11 <Ring0`> nope I wont Hijiri
17:14:22 <jle`> Ring0`: you can parameterize the type, right?
17:14:24 <jle`> Array a
17:14:49 <jle`> add :: a -> Array a -> Array a
17:15:04 <Ring0`> hm
17:15:11 <Hijiri> Ring0`: If you don't know that you can pass it in, how would you pass it in
17:15:22 <jle`> the benefit over void pointers is that every `a` is guarunteed to be the same
17:15:29 <reem> Is there a form of type erasure for heterogenous collections though?
17:15:34 <jle`> also i can never spell guarantee
17:15:55 <reem> i.e. if I wanted a list of different types, all of which have instances of some typeclass
17:16:02 <Hijiri> reem: you can have higher ranked data types
17:16:09 <jle`> reem: yes, you can...but it's a lot less useful than you'd think
17:16:30 <jle`> for example, if you have a list of anything as long as it's Showable...then the only thing you can do with it is Show it
17:16:32 <jle`> *show
17:16:37 <reem> of course
17:16:40 <jle`> so it's more or less identical to store a list of strings
17:16:40 <reem> but you *can* do that?
17:16:47 <reem> hmm interesting
17:16:57 <reem> laziness is neat :)
17:17:02 <jle`> you can, but in many circles it is considered an antipattern because of things like that
17:17:04 <Ring0`> Hijiri: I'm creating list ADT (for now), I don't know what values will be stored in it, it can be numbers, strings, chars, anything
17:17:08 <Ring0`> jle`: I'll check this out, thx
17:17:09 <Hijiri> reem: you can have data Banana = forall a. Show a => BasicallyString a
17:17:30 <Hijiri> Ring0`: But if you don't know what it is, you can not pass it into a function that takes something specific
17:17:42 <jle`> if you have a typeclass that's like Renderable where you have one method render :: a -> IO ()....then having a list of things that "all of them are Renderable" is identical to just having a list of IO ()
17:17:58 <jle`> usually when people ask for this it is a remnant of subtyping intuition from OOP
17:18:12 <orzo> bennofs: when it says it passed 100 tests, does that include generations that were discarded or not?
17:18:15 <hpc> it's generally considered an anti-pattern and you should encode the class as a data type instead
17:18:17 <monochrom> @quote monochrom river
17:18:17 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
17:18:17 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
17:18:25 <hpc> data Foo = Foo {render :: IO ()}
17:18:26 <Ring0`> Hijiri: That's why I asked about pointer, since pointer points to address, it's the same "type" for anything you pass. Later on you should treat it as string if you passed string, of course
17:18:39 <jle`> Ring0`: something like data List a = Nil | Cons a (List a)
17:18:47 <jle`> Ring0`: that way you get a list of Strings: List String
17:18:50 <jle`> a list of Ints: List Int
17:18:52 <Hijiri> Ring0`: haskell doesn't have pointers
17:18:56 <jle`> a list of bools: List Bool
17:18:59 <Hijiri> you have  C pointers, for interaction with C
17:19:11 <Hijiri> but you don't have pointers to haskell values
17:19:20 <Hijiri> unless you are doing something very hacky and/or low level
17:19:28 <Ring0`> not at all.
17:19:38 <Ring0`> I have to check it up jle` :-)
17:19:51 <jle`> actually it makes sense to use pointers if you are working with an algorithm that involves pointers
17:20:07 <jle`> i wouldn't call it hacky to use pointers when writing a memory manager in haskell
17:20:37 <Hijiri> I guess so, but you would have to implement pointers
17:20:40 <jle`> but you use them for a different purpose than you'd use them in C, etc. of course
17:23:27 <ricardo82> hi
17:23:34 <solirc> orion: I think this is not a bug in Doctest but rather a limitation in GHC/Haddock
17:24:27 <Zemyla> Hmm. filterM f m = m >>= (\p -> guard (f p) >> return p) is like filter, but for a generic MonadPlus.
17:25:01 <jle`> you mean like mfilter but with a monadic predicate?
17:25:07 <orion> solirc: Could you elaborate?
17:25:09 <jle`> :t mfilter
17:25:10 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
17:25:11 <Zemyla> :t mfilter
17:25:12 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
17:25:18 <Zemyla> Huh. That exists.
17:25:28 <monochrom> @type filterM
17:25:29 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
17:25:38 <solirc> orion: Does the reason I gave on the ticket make sense?
17:26:05 <jle`> filterM, mfilter, don't forget fmiltmer
17:26:18 <jle`> fmilter, filMter
17:26:22 <orion> solirc: Ah, I hasn't received notification that you replied yet. I'm looking now.
17:26:26 <Zemyla> :t \f m -> m >>= (\p -> f p >>= (\b -> guard b >> return p))
17:26:27 <lambdabot> MonadPlus m => (b -> m Bool) -> m b -> m b
17:26:44 <hpc> if someone ever writes a mail filter in haskell, i really hope it's called fmilter
17:27:09 <jle`> mMmfiltermMm
17:27:11 <cmccann> > permutations "mfilter"
17:27:12 <lambdabot>  ["mfilter","fmilter","ifmlter","fimlter","imflter","miflter","lifmter","ilfm...
17:27:25 <hpc> hey look, liftm
17:27:46 <Zemyla> reliftM?
17:28:01 <Zemyla> @hoogle mfilter
17:28:03 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
17:28:03 <lambdabot> package bloomfilter
17:28:04 <jle`> > replicateM 7 "mfilter"
17:28:05 <lambdabot>  ["mmmmmmm","mmmmmmf","mmmmmmi","mmmmmml","mmmmmmt","mmmmmme","mmmmmmr","mmmm...
17:29:14 <Zemyla> :t (=<<) . liftM2 (flip (>>)) return . (guard .)
17:29:15 <lambdabot> MonadPlus m => (b -> Bool) -> m b -> m b
17:29:24 <Zemyla> :t mfilter
17:29:25 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
17:30:56 <Thedarkb> I need some help with this code
17:30:58 <Thedarkb> http://bit.ly/IKXgTf
17:31:09 <jle`> um, mods
17:31:12 <Thedarkb> I'm kinda nooby
17:31:14 <jle`> nobody click
17:31:26 <jle`> not a link you'd want to click
17:32:08 <jle`> @where mods
17:32:08 <lambdabot> I know nothing about mods.
17:32:14 <jle`> hm
17:32:14 <Hijiri> @where ops
17:32:14 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
17:32:17 <orion> solirc: Yes you're right. Sorry to bother you.
17:32:21 <jle`> yeah i always mess this up
17:32:22 --- mode: ChanServ set +o monochrom
17:32:27 --- mode: monochrom set +b *!*@86-43-192-3-dynamic.b-ras1.wtd.waterford.eircom.net
17:32:28 --- kick: Thedarkb was kicked by monochrom (Thedarkb)
17:32:37 <monochrom> is that the right guy to kick?
17:32:39 <Zemyla> jle`: What was that link?
17:32:41 <jle`> mhm
17:32:49 <jle`> it's a classic shock site from the early 2000's
17:32:56 --- mode: ChanServ set +o shapr
17:32:59 <jle`> browser blocked it but i recognized the url
17:33:01 <shapr> Dang, I missed it
17:33:31 <Zemyla> Oh, is that all? I was worried it was a malware site/
17:34:57 <hpc> it's probably that too
17:40:12 <shachaf> You can put + at the end of bit.ly URLs to see where they point.
17:40:33 <jle`> ...this will change my world
17:42:47 <lykos_> I'm having a really weird type/compilation error with Database.PostgrsSQL.Simple
17:45:54 <Zemyla> Why doesn't isInfixOf use the KMP algorithm?
17:46:02 <lpaste> lykos_ pasted “Postgresql Simple” at http://lpaste.net/120739
17:46:22 <shachaf> Zemyla: Not so great on linked lists.
17:46:37 <lykos_> Can you take a look at this? I *know* that a and b are of type :: [Only Int] (tested in GHCI), but when I try to unpack it there's a really weird error.
17:47:40 <Hijiri> lykos_: what's the error?
17:49:26 <lykos_> Hijiri: No instance for (ToRow (a0 -> a0)) arising from a use of query
17:49:50 <lykos_> wheras, if I try (fromOnly (head a)) in ghci, it resolves
17:49:51 <Zemyla> shachaf: Why not? It's certainly better than checking every single prefix.
17:51:15 <Hijiri> lykos_: can you post the full error?'
17:51:18 <lykos_> sure
17:51:22 <Hijiri> probably in another lpaste
17:52:46 <Hijiri> it looks like it's because id doesn't have a ToRow instance?
17:53:53 <Hijiri> query's type signature says the third argument needs a ToRow instance, but id, which you passed in, doesn't
17:54:07 <lykos_> (I had initally changed some variable names in the first lpaste, the full thing is included here)
17:54:14 <lpaste> lykos_ pasted “Error” at http://lpaste.net/120740
17:54:16 <Hijiri> ok
17:54:57 <Zemyla> shachaf: The table could be represented by a doubly linked list.
17:55:19 <Hijiri> lykos_: yeah, it's because (a -> a) has no ToRow instance
17:55:22 <Hijiri> you are passing in id
17:56:03 <Hijiri> lykos_: You probably don't want to send any info in your query, right?
17:56:10 <Hijiri> use query_ or pass in () instead of id
17:56:15 <Hijiri> that is what I am guessing the solution is
17:56:22 <lykos_> actually, I do want to send in info to the query
17:56:33 <lykos_> but thanks for pointing it out, I forgot to resolve id
17:56:33 <Hijiri> I mean, in the slot where you have id
17:57:03 <lykos_> (id) is an Int, which resolves to fill the ? in the "countAdvocates" query
17:57:15 <Hijiri> id is the identity function
17:57:29 <Hijiri> also the parentheses are unnecessary
17:57:52 <lykos_> I changed it to (cID c) which pulls an integer from c
17:58:09 <Hijiri> is it still getting you errors?
17:58:24 <lykos_> yes, a different one though:  No instance for (ToRow Integer) arising from a use of query
17:58:33 <Hijiri> oh, Int has no ToRow instance, you need Only Integer
17:58:40 <lykos_> ah, of course, makes sense
17:59:11 <lykos_> clean compile, thanks so much for the help!
17:59:15 <Hijiri> np
17:59:21 <lykos_> I'm getting back into haskell, it's been awhile.
17:59:25 <lykos_> Love this language though.
17:59:35 <lykos_> and the people on this IRC are super helpful
17:59:46 <Hijiri> yeah, the types are so expressive that I didn't even need to know how to use this library
18:00:10 <Hijiri> to help
18:13:23 <orzo> Is it better to unpack a bytestring and then reverse it, or is it better to reverse it and then unpack it, or is there an unpackReversed defined for me somewhere?
18:13:54 <shachaf> You can use foldl.
18:15:24 <orzo> i need the bytes in reverse order, and maybe i'm missing smoething but i expecgt foldl to visit them from the front
18:16:48 <shachaf> foldl is left-associative, same as for lists.
18:17:34 <shachaf> B.foldl (*) z (B.pack [a,b,c]) = ((z * a) * b) * c
18:18:16 <orzo> i don't see how that helps me when i want ((z * c) * b) * a)
18:18:35 <zipper> dev ops-ish question here...
18:18:37 <zipper> So I have a package in my local file system. I've written a web interface for it in yesod. How do I make yesod depend on it and therefore pull it when I add it to the yesod app's build depends?
18:18:54 <zipper> The yesod app is also in my local file system
18:19:39 <orzo> is this specific to yesod, or are you asking about cabal?
18:19:49 <zipper> orzo: About cabal
18:20:09 <orzo> for cabal, you install the dependency
18:20:10 <shachaf> z = [], (*) x y = y : x
18:20:24 <zipper> orzo: How will cabal know where this dependency is?
18:20:37 <zipper> Note that this dependency is local and within my computer
18:20:46 <zipper> s/and/that is/
18:21:08 <orzo> installing it moves the information somewhere predictable
18:22:14 <zipper> Maybe I'm not clear
18:22:17 <zipper> There are two packages. ~/src/haskell/foo-core and another ~/src/haskell/foo-web
18:22:28 <zipper> I want foo-web to depend on foo-core
18:22:50 <orzo> is foo-core something that foo-web must import to build?
18:22:58 <zipper> orzo: Yes
18:23:06 <orzo> then it is just as i imagined
18:23:08 <zipper> orzo: I want this to be the case
18:23:26 <orzo> cd foo-core; cabal install; cd ../foo-web; cabal build
18:24:52 <orzo> when you install it copies the built lib somewhere, like .ghc or something, and then it's available like other packages
18:25:54 <zipper> orzo: Oh I was about to ask how this would be affected by the fact that foo-core is in a sandbox. Luckily you cleared that up.
18:26:43 <orzo> it's some standard locagtion in yoru home directory, i forget the specifics
18:27:05 <zipper> orzo: and me updating and building foo-core all the time and calling cabal install on it won't make it blow up in a cabal hell situation, right?
18:27:24 <orzo> yes and no
18:27:55 <orzo> is foo-web the only thing that depends on it?
18:28:03 <zipper> orzo: Yes
18:28:16 <zipper> orzo: I think that last question depends on whether the packages that foo-core depends on change in a way that causes issues with other packages. Am I right?
18:28:27 <orzo> it may make some noise that foo-web might break, so you rebuild that too
18:28:57 <zipper> orzo: Maybe other things will depend on foo-core later but I'll cross that bridge when I get there.
18:29:36 <zipper> orzo: Thanks
18:29:40 <orzo> itll just warn you that things might break and maybe ask if you want to continue
18:29:46 <orzo> something like that
18:30:09 <orzo> if the depenency graph gets big, then you may end up in hell
18:30:28 <zipper> orzo: Hopefully that won't happen. Thanks
18:30:33 <zipper> I have to sleep now :)
18:30:45 <zipper> orzo: Good night/mornig. It's 5:26 am
18:30:51 <orzo> goodnight
18:33:19 <cfoch> hello. how can I know if some package name is already installed?
18:33:31 <cfoch> is there a function?
18:33:41 <geekosaur> ghc-pkg list?
18:34:18 <cfoch> geekosaur: I am looking for a function
18:35:07 <cfoch> I know "ghc-pkg list --installed" tells me what packages are installed, but I want a function
18:35:31 <cfoch> "ghc-pkg list"
18:35:32 <ilyagetready> cfoch, look at your initial question
18:36:01 <cfoch> well... I am looking for a function as I said
18:36:29 <Fusebox> then consider using Hoogle or Hayoo or something to find the package the function is in
18:36:34 <Fusebox> from there, use what was mentioned above
18:37:13 <ilyagetready> No, he means finding out if the package is available runtime
18:37:15 <geekosaur> I am sure there is, somewhere in ghc-api
18:37:39 <geekosaur> hm, actuakly the cabal library should have it...
18:38:22 <hsk3> monochrom: hi
18:38:24 <cfoch> I would like to add a functionality to Cabal. But I need to know if there is a function which "returns" if the package name is installed or not.
18:38:50 <geekosaur> https://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/Distribution-Simple-PackageIndex.html
18:40:09 <geekosaur> presumably lookupPackageByName or searchByName
18:40:32 <geekosaur> er, lookupPackageName
18:41:57 <hsk3> In this code: http://lpaste.net/8855658922908844032
18:41:58 <hsk3> Why is "else" not at the same indentation as "if"?
18:42:51 <geekosaur> hm, not sure where you get the PackageIndex from though...
18:43:23 <geekosaur> hsk3, because of layout. if it were at the level of the `if` then layout would insert a (>>) operator, which would break it
18:44:10 <orzo> geekosaur, hsk3: we have DoAndIfThenElse for that now
18:44:39 <EvanR> down with bools
18:44:48 <orzo> heh
18:45:18 <EvanR> next thing is gonna be a Goto extension for do notation
18:45:19 <orzo> i don't like the standard layout rule for if
18:45:33 <orzo> ghc does DoAndIfThenElse by default you know
18:45:49 <hsk3> geekosaur: you mean >>= ?
18:45:54 <geekosaur> right, but there is a historical reason
18:46:00 <geekosaur> hsk3, no.
18:46:12 <geekosaur> it actually inserts a semicolon, which becomes (>>)
18:46:46 <geekosaur> @undo do { a; b }
18:46:47 <lambdabot> a >> b
18:47:27 <orzo> speaking of ghc default langauge, is there a cabal name for that?  setting default-language to Haskell2010 changes the behavior, so i either cope with cabal nags or write conforming code, but i'd like a way to explicitly tell it to shut up
18:47:40 <geekosaur> ask yourself this: on lines 9 and 10 of your paste, what is the putStrLn supposed to pass to get_email?
18:48:41 <geekosaur> it would need to pass something for (>>=) to be meaningful there. (in fact it does pass something, but something useless and something that get_email does not expect to have as a parameter. (>>) is specifically for that case)
18:50:20 * hackagebot halma 0.1.0.1 - Library implementing Halma rules  http://hackage.haskell.org/package/halma-0.1.0.1 (TimBaumann)
18:50:22 * hackagebot http-date 0.0.5 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.5 (KazuYamamoto)
18:50:32 <Hijiri> What do viewpatterns get desugared to? case viewFunction thing of ... ?
18:50:58 <orzo> hmmm, is there a haskell-src-exts based tool that will rewrite my do syntax to applicative for me?
18:51:07 <orzo> when it can
18:51:46 <hsk3> geekosaur: thanks, makes sense
18:51:55 <orzo> i need that tool as i just mindlessly wrote a flip-ton of do
18:52:26 <EvanR> abuse of do notation ;)
18:54:27 <EvanR> orzo: theres rebindable syntax
18:54:57 <geekosaur> ApplicativeDo is planned but not yet there :p
18:57:10 <dmwit> Hijiri: something like that, though i think there is some ophisticatiot to share views
18:58:16 <EvanR> dmwit: some what?
19:00:28 <Hijiri> sophistication?
19:00:53 <EvanR> oh
19:01:15 <EvanR> i didnt win that one time i was on wheel of fortune
19:03:44 <dmwit> sorry for my atrocious spelling
19:05:31 <xenocons> hmm
19:05:40 <xenocons> nope i started to write out a question and realised it was silly
19:06:04 <dmwit> \o/
19:06:13 <ReinH> Cale: ping
19:06:17 <mniip> is there any parsec-lens sort of stuff?
19:06:42 <mniip> for disassembling a string into a bunch of lenses
19:06:57 <mniip> "referencing" the original string
19:07:02 <mniip> or parts of it rather
19:08:40 <dmwit> there is that one library based on partial isomorphisms for doing parsitg and pretty printing from the same code
19:09:15 <Cale> ReinH: hi
19:09:29 <ReinH> Cale: Mind if I ask a few Hask-related CT questions?
19:09:41 <Cale> go right ahead
19:10:00 <ReinH> Cale: Thanks! Hask is self-enriched, which means that homsets are replaced by (->), right?
19:10:21 <mniip> dmwit, there are aeson lenses, but I'm not sure whether aeson is flexible enough for me
19:10:23 <mniip> er
19:10:28 <mniip> whether json is flexible enough
19:12:08 <Cale> ReinH: I don't know how well the actual details go through, but yeah, at least roughly, you ought to be able to think of Hask(A,B) as being the type (A -> B)
19:12:45 <dmwit> ?hackage invertible-syntax
19:12:45 <lambdabot> http://hackage.haskell.org/package/invertible-syntax
19:12:59 <Cale> ReinH: There's always the problem of what Hask *is* being slightly unclear.
19:13:16 <ReinH> Cale: I'm using the nice version wherein Hask is a CCC
19:13:38 <ReinH> Cale: then enrichment on f just implies that (a -> b) -> (f a ->f b) exists, right? Which means all functors in Haskell are enriched?
19:13:50 <shachaf> If you ask precise questions about an approximate topic, you'll run into trouble.
19:15:02 <ReinH> shachaf: understood.
19:15:58 <EvanR> objects in Hask are types? there is one object for each type? including function types?
19:16:27 <Cale> EvanR: yeah
19:16:34 <Cale> ReinH: uh, I think so
19:17:01 <ReinH> Cale: you need naturality but you get the for free from parametricity, I think
19:17:06 <ReinH> s/the/that
19:17:39 <Cale> ReinH: It feels like enriched category theory isn't really the right tool to apply, if you're going to assume that Hask is a CCC anyway
19:18:15 <Cale> Because you're introducing a lot of generality that shouldn't really do much for you.
19:18:22 <ReinH> Cale: Fair point. I'm trying to work up to "All Functors in Haskell have tensorial strength", which I can do from here via the tensor-hom adjunction.
19:18:43 <ReinH> But maybe I'm missing a more direct route.
19:19:48 <Cale> That's just, can you write a polymorphic function  (a, f b) -> f (a,b) ?
19:20:10 <ReinH> Right.
19:20:19 <ReinH> I think it's a bit more obvious as "can you write fmap" though :)
19:20:32 <ReinH> Well, more obvious in one way
19:20:58 <Cale> :t let strength (x, s) = fmap (\y -> (x,y)) s in strength
19:20:59 <lambdabot> Functor f => (t, f t1) -> f (t, t1)
19:21:12 <ReinH> :)
19:22:33 <kevinmeredith> hi - could someone please tell me why this doesn’t terminate:
19:22:38 <kevinmeredith> parseStringJValue :: Parser JValue
19:22:38 <kevinmeredith> parseStringJValue = (S . concat) <$> ((char '"') *> (oneOrMore (alt parseEscapedQuotes (zeroOrMore (notChar '"')))) <* (char '"'))
19:22:58 <kevinmeredith> *JsonParser> runParser parseStringJValue "\"foobar\""
19:22:58 <kevinmeredith> ^CInterrupted.
19:24:03 <ReinH> Cale: That is pretty direct. ;)
19:24:29 <dmwit> kevinmeredith: In the future, use lpaste.org if you have more than a line or so of code/errors.
19:24:37 <kevinmeredith> sure, I’ll make sure to - thanks
19:24:44 <bitemyapp> dmwit: lpaste.net
19:24:48 <dmwit> ?paste
19:24:48 <lambdabot> Haskell pastebin: http://lpaste.net/
19:24:52 <dmwit> yes
19:25:17 <mniip> does lens-aeson decode the entire thing and then reencode the entire thing?
19:25:22 * hackagebot growler 0.5.0.1 - A revised version of the scotty library that attempts to be simpler and more performant.  http://hackage.haskell.org/package/growler-0.5.0.1 (IanDuncan)
19:25:57 <mniip> because it looks like that's what it's doing
19:26:03 <dmwit> kevinmeredith: It looks like there are several pieces there that are only locally defined. Can you post a complete but minimal example that shows the problem?
19:27:12 <kevinmeredith> @dmwit - sure. thanks - doing that now
19:27:12 <lambdabot> Unknown command, try @list
19:27:18 <geekosaur> given just what's there, it looks to me like you have oneOrMore (zeroOrMore ...) which will match an infinite number of empty strings
19:27:50 <kevinmeredith> could you say a bit more, geekosaur, please? I only partly understood it
19:28:25 <geekosaur> I'm afraid to ask which part you did not get
19:30:09 <kevinmeredith> it’s not entirely clear to me why oneOrMore (zeroOrMore …) would match an infinite number of empty strings
19:30:25 <geekosaur> hm, actually if I assume you wrote parseEscapedQuotes properly, that looks like it might be okay. it's not zero or more of zero or more and the one or more shouldn't trigger the sxcew case
19:30:39 <geekosaur> so I think I will second dmwit and ask to see more
19:31:04 <kevinmeredith> here’s an example (https://gist.github.com/kevinmeredith/5e5ed473a4598d19138e)
19:32:39 <geekosaur> ok, so you are matching an embedded " without an escape, is that right?
19:33:10 <geekosaur> (line 38)
19:33:25 <kevinmeredith> valid JSON string: “ \”foobar\” “      — starts with double quote, then it should read up until the final, closing quote
19:33:43 <geekosaur> I think my point was missed.
19:34:00 <kevinmeredith> runParser parseEscapedQuotes "\"blah" === Just ("\"","blah")
19:34:20 <geekosaur> although maybe you did intend what's going on there, which might work for this case but will lead to trouble later I suspect
19:34:53 <kevinmeredith> because of oneOrMore (zeroOrMore …) leading to a non-terminating program?
19:34:58 <geekosaur> no, actually this will fail.
19:35:36 <geekosaur> think of it. think about what happens when your parser, as written (again, look at line 38), hits the closing quote. where does it recognize it?
19:36:11 <geekosaur> mm, wait, I am looking at this slightly wrong
19:36:34 <geekosaur> right, sorry, sigh
19:36:51 <kevinmeredith> b/c a closing quote ‘“‘ isn’t the same as “\””, if I understand
19:36:55 <geekosaur> probably ought to go to bed at this point, I normally don't confuse levels this badly
19:37:17 <kevinmeredith> I appreciate your looking at it
19:37:30 <kevinmeredith> thanks
19:38:08 <geekosaur> there's still some pieces missing given that you are defining your own parser, though
19:38:26 <geekosaur> (char, alt, notChar)
19:38:56 <kevinmeredith> hmm, I dont follow
19:39:15 <geekosaur> if I assume those have the obvious definitions then I'm not seeing the problem offhand
19:39:50 <kevinmeredith> I got some help on SO - http://stackoverflow.com/a/28588528/409976. but this answer doesn’t help me entirely - I’m likely not reading it thoroughly or not understanding it
19:43:36 <sssilver> Hey guys, just out of curiosity — please enter + if you feel like you totally understand monads and they’re a part of your Haskell arsenal, or - if you use Haskell but the whole monad business is in fact a mystery to you, although you use things like IO monads without understanding what they actually are.
19:44:14 <jmcarthur> sssilver: i think you are unlikely to get much response. this isn't a great place to survey
19:44:36 <jmcarthur> sssilver: do you have an actual question about haskell? :)
19:45:37 <sssilver> jmcarthur: well I made it to the monads chapter, read it, vaguely understood that I didn’t understand anything, then talked to some folks, they said it’s OK to not understand that and a lot of people don’t, and that struck me that a lot of people may program in Haskell without really understanding them
19:46:12 <jmcarthur> sssilver: i think it depends on what you mean by "understand"
19:46:28 <monochrom> how do I enter + ?
19:46:46 <geekosaur> isn't reddit a better place for such things?
19:46:55 <silasm> sssilver: The point people usually try to make is that people often get bogged down in "understanding monads" as a general concept when just using a couple of relatively easy examples usually gets them a working intuition.
19:47:28 <shachaf> monochrom: Your options are push/enter and eval/apply.
19:47:28 <jmcarthur> sssilver: i think most experience haskell programmers will have a very good mental model of what monads are good and bad for, how to spot one when there isn't yet a Monad instance, and perhaps, *perhaps* vaguely have some notion of how they might explain it in category theory terminology if they felt like that had to (but they are probably wrong, on that point)
19:47:32 <gfixler> I found Writer pretty easy to work through, Reader not so much.
19:47:35 <monochrom> haha shachaf
19:47:53 <jmcarthur> *experienced
19:48:06 <monochrom> I am an axiomatic kind of guy. so monad is easy to me. and other type classes too.
19:48:51 <shachaf> I think category theory terminology isn't that far from Haskell terminology.
19:48:59 <jmcarthur> sssilver: really there isn't much to "understand" other than the types and laws. anything else is unsharable "aha" moments, which probably most of us have experienced on other topics and can relate to
19:49:11 <monochrom> in fact, once you start describing intuitions to me, I tune out, since experience shows that they teach me nothing right
19:49:19 <shachaf> @quote formalist
19:49:20 <lambdabot> SaulGorn says: A formalist is one who cannot understand a theory unless it is meaningless.
19:50:03 <monochrom> whereas if you just cut to the mustard and tell me the axioms and some examples, I'll do my own playing and discover, validate, debunk my own ideas.
19:50:30 <silasm> it's not as though people using Monads need to grok category theory to know how their code works any more than you need to understand how your hard drive works to do file I/O.
19:50:35 <sssilver> well jmcarthur see the problem is, if I Google “monad tutorial” or “understand monads”, I have a constant feeling like I’m being explained bullcrap for the most part that still makes no sense. Whereas if I google “understand polymorphism”, stuff is pretty well explained.
19:50:45 <monochrom> if you tell me the exact rules of Chess, I will eventually play enough actual games to appreciate various strategies
19:50:57 <jmcarthur> sssilver: that's because most monad tutorials are bullcrap. :)
19:50:57 <shachaf> You should read the FAQ. It has a good answer to the question.
19:50:59 <shachaf> @faq
19:50:59 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:51:19 <monochrom> if you tell me intuitions without exact rules, I will just be making looks-nice but wrong moves left right and centre
19:51:22 <geekosaur> sssilver, mostly you are, because people think monads are scary things and post nonsense about them that they call a monad tutorial when they get a usually incorrect understanding
19:51:36 <gfixler> I have a little list of things that confused me for extended periods of time while learning monads
19:51:43 <geekosaur> it's not like people here have some magic ability to not make google index such noise
19:51:49 <gfixler> extended being anywhere from a few months to most of a year
19:51:54 <jmcarthur> sssilver: or rather, the topic of monads and why they are relevant is mostly bullcrap. they aren't so important. monad is just a name for a common interface.
19:52:42 <sssilver> but what is it about them that makes them so much more difficult to explain than the concept of say abstract virtual classes
19:52:51 <sssilver> OK bullshit question, sorry
19:52:55 <sssilver> I’m just confused
19:53:03 <jmcarthur> sssilver: nothing other than the false level of importance people give them
19:53:03 <monochrom> I don't think anyone seriously believes that one can learn Chess by reading intuitions and omitting the rules. Yet they believe it for programming and monads.
19:53:18 <jmcarthur> sssilver: i think people only feel confused about monads because they feel like they are missing out on something.
19:53:24 <jmcarthur> sssilver: but it's just not true.
19:54:25 <jmcarthur> sssilver: monads are nice, don't get me wrong, but they are mostly a subtle "aha" realization, and it mostly comes in little incremental improvements in understanding. you won't really get it from any particular introductory material.
19:55:01 <jmcarthur> sssilver: and they way they are "nice" is only in a "that's neat" sort of way, not in a "this changes everything" sort of way.
19:55:08 <bob_twinkles> it probably doesn't help that the first thing people read is "in order to do IO in haskell, it must be performed in the IO monad"
19:55:16 <gfixler> for the list monad, return x == [x] and m >>= f == concat . fmap f m, right?
19:55:22 <jmcarthur> ugh. "the IO monad" is a terrible thing
19:55:27 <bob_twinkles> so it's like "holy crap what's a monad oh god I can't get strings out"
19:56:21 <monochrom> learning is not a spectator sport. there is no amount of reading tutorials, even the right ones, that can complete your learning.
19:57:33 <sssilver> jmcarthur: the problem is, there are two kinds of programmers. Kind 1 uses something, doesn’t care how it works. Kind 2, uses something, and it’s important for them to understand what’s actually happening and why. In my understanding, when I output something, I use a monad. So naturally I wanna understand — what’s going on? You’re telling (perhaps wisely so) to not care and be more like the Kind 1, and with tim
19:57:34 <sssilver> it’ll come to me. Fair enough. Am I getting it right?
19:57:54 <jmcarthur> sssilver: the nice thing for both kinds of programmers is that there is no "how it works" with monads
19:58:02 <jmcarthur> sssilver: it's literally just an interface
19:58:10 <sssilver> jmcarthur: there’s ‘how it works’ with output though ;)
19:58:11 <jmcarthur> sssilver: so there is no mystery
19:58:19 <jmcarthur> sssilver: you mean IO?
19:58:20 <sssilver> and the answer in my understanding it — ‘it works using monads’
19:58:26 <sssilver> yeah jmcarthur
19:58:37 <jmcarthur> sssilver: yeah, basically forget that IO is this thing called a "monad"
19:58:52 <sssilver> :t doesn’t let me!!!!
19:58:53 <lambdabot> lexical error at character '\8217'
19:58:59 <sssilver> (shut up)
19:59:26 <jmcarthur> sssilver: it has these return and bind functions. they form the spine of a big imperative program that you can define in pure haskell.
20:00:12 <jmcarthur> sssilver: if you have an imperative program A and you say  A >>= f  you are replacing every occurrence of  return  in that program with  f
20:00:57 <sssilver> jmcarthur: that makes sense
20:03:05 <jmcarthur> sssilver: if you have any further questions about IO, i think just trying to figure out how to phrase them will produce reasonable, partial answers :)
20:03:18 <jmcarthur> sssilver: if you try to phrase them using the terminology i just used
20:04:23 <jmcarthur> sssilver: also, notably, i didn't explicitly explain monads
20:10:25 * hackagebot dependent-map 0.1.1.3 - Dependent finite maps (partial dependent products)  http://hackage.haskell.org/package/dependent-map-0.1.1.3 (JamesCook)
20:11:43 <gfixler> Any time I've heard anyone try to explain monads over the last year, it's always been completely new and different
20:12:00 <gfixler> jmcarthur: I've never heard anyone before say that A >>= f is like replacing all returns in A with f
20:12:51 <jmcarthur> gfixler: it's actually one of my more recent (as in last year or so) realizations
20:13:03 <gfixler> I don't think it helps a beginner
20:13:06 <shachaf> Free monads are a good example to look at if you want to learn about monads in general (rather than a particular one).
20:13:11 <gfixler> you had that realization after a very long time with monads
20:13:31 --- mode: monochrom set -b *!*@86-43-192-3-dynamic.b-ras1.wtd.waterford.eircom.net
20:13:32 <shachaf> This is true for just about any algebraic structure, not just monads. If you want to learn about monoids, lists should be one of your examples.
20:13:35 --- mode: monochrom set -o monochrom
20:14:00 <gfixler> shachaf: I mentioned that earlier, and asked a question, but no one replied
20:14:29 <gfixler> I asked if return x == [x] and m >>= f == concat $ fmap f m for the list monad
20:14:53 <shachaf> Free structures are good because there's no extra "wrong" intuition to get from it. If your example of a monoid is natural numbers and addition, you might come to the conclusion that monoids are commutative.
20:15:02 <jmcarthur> gfixler: perhaps not. i kind of feel like it's very appropriate for beginners because it's very easy to explain, there is an obvious way to visualize it, and doesn't suffer from the imprecision of teaching by analogy
20:15:07 <shachaf> (Not explicitly, but explicitly isn't how intuition works.)
20:15:26 <shachaf> jmcarthur: That explanation is also good when you want to teach people about Codensity. :-)
20:15:29 <mniip> gfixler, for list, return = (:[]) and (>>=) = concatMap
20:15:52 <shachaf> "Codensity m a" is like "m a" except parameterized on a return function.
20:16:00 <Cale> gfixler: yes
20:16:08 <shachaf> I.e. (forall r. (a -> m r) -> m r)
20:16:23 <gfixler> Cale: thanks - mniip is saying the same thing with more concise commands
20:16:25 <shachaf> This is exactly like difference lists are lists, except parameterized on what to use instead of []
20:17:06 <mniip> I wonder if pl can infer types
20:17:12 <mniip> @pl \f m -> concat $ fmap f m
20:17:12 <lambdabot> (=<<)
20:17:16 <shachaf> pl is untyped
20:17:21 <mniip> ಠ_ಠ
20:17:25 <gfixler> anyway, my point was that bind==(:[]) and return==concatMap (thanks mniip) for lists is one expression of a monad
20:17:37 <mniip> gfixler, you mixed up the two
20:17:40 <gfixler> and all the others are the same thing, with bind and return specialized for other, different containers and computational contexts
20:17:51 <gfixler> mniip: whoops!
20:18:05 <monochrom> there is no contradiction between "thought up after centuries of studies" and "suitable for telling beginners"
20:18:08 <gfixler> return=(:[]) and bind==concatMap
20:18:26 <gfixler> monochrom: fair enough; I'll keep my mind open
20:18:35 <gfixler> monads hold the distinction of being able to be explained in dozens of ways
20:18:51 <monochrom> most things you were told in kindergarten were thought up after millenia of studies
20:18:53 <gfixler> and every time a chat on monads comes up, and I've seen dozens now, everyone says new words that are unlike all the old ones
20:19:05 <gfixler> it's super confusing
20:19:20 <Cale> In fact, it's usually the most recent mathematics which is in the form which is least suitable to show beginners. After a long time of being polished and reworked is when it finally in a form
20:19:28 <Cale> it's finally in a form where that's appropriate
20:22:05 <gcganley> Cale: where did you get your category theory education? on your own or from uni?
20:23:06 <mniip> I wonder which is easier, to learn haskell and then use the knowledge to learn CT, or the opposite
20:23:38 <gfixler> mniip: I think the former
20:23:56 <gfixler> but then, I'm a kinaesthetic learner
20:24:18 <gfixler> learning some haskell and CT has made swaths of wikipedia make a lot more sense
20:24:25 <mniip> same
20:24:33 <kaidelong> haskell embeds assumptions into you that CT regularly does not have
20:24:52 <monochrom> I learned Haskell first.
20:24:57 <Cale> gcganley: On my own
20:25:04 <glguy> Wow, the original learner
20:25:13 <kaidelong> if you are wanting to learn category theory, I don't think haskell will help you that much
20:25:16 <gcganley> I'd be interested in who learned category theory first
20:25:16 <Cale> Well, I have a BMath in pure mathematics
20:25:17 <mniip> I can say that I'm pretty decent at haskell, and I don't have a slightest about CT
20:25:18 <kadoban> mniip: I know very little about CT, but…as far as I know, the only thing CT and haskell specifically have to do with each other is that haskell copied some terms and they…kinda sorta fit.
20:25:28 <kaidelong> it did not for me
20:25:35 <kaidelong> learning some more about algebra did, though
20:25:35 <Cale> So it's a bit less of a stretch for me than for some people
20:25:39 <gcganley> kaidelong: i think people are exposed to it in haskell and go out and learn it
20:25:51 <kaidelong> gcganley: absolutely, haskell is a motivator
20:26:41 <kaidelong> mniip: have you taken a look at "The Catsters'" youtube channel?
20:26:49 <mniip> no
20:27:03 <kaidelong> if you're trying to get started with category theory, go take a look
20:27:05 <kaidelong> it's helpful
20:27:13 <mniip> hmm, is lens one of those "must-have" packages?
20:27:18 <jmcarthur> i think the catsters is a bit too fast paces for the casual beginner
20:27:21 <jmcarthur> *paced
20:27:29 <mniip> i.e is there any point in trying to avoid using lens
20:27:40 <kaidelong> jmcarthur: definitely, they're also a bit too slow paced in some other ways because the beginning material is so simple
20:28:00 <kaidelong> however the advantage of youtube as a medium is that you can repeat the lectures and work through them until you understand
20:28:18 <kadoban> mniip: I've never used it and I get by. I've only done a couple of actual projects though.
20:28:29 <kaidelong> which unfortunately seems to be the only approach that works for learning CT
20:28:34 <kaidelong> repetition, and persistence
20:28:38 <jmcarthur> mniip: i think it's fine to avoid lens or to treat it using the "simple" model:   data Lens a b = Len { get :: a -> b; set :: a -> b -> a }
20:28:50 <jmcarthur> mniip: but really, just ignore it until you find something about it tantalizing enough
20:29:06 <mniip> jmcarthur, I'm thinking of reimplementing a subset of lens
20:29:23 <gfixler> kaidelong: for me, I feel that mathematicians don't realize how foreign they sound to the rest of us
20:29:24 <mniip> not the combinators but the getter-setter logic
20:29:40 <kaidelong> mniip: lens requires template haskell, which destroys GHC's already fragile cross compilation abilities
20:29:41 <jmcarthur> mniip: i think that is a great beginner exercise, but actually not a huge step toward understanding the lens package unless it's the same style of lens (not the one i just wrote above)
20:29:42 <gfixler> they casually say things that hold a lot of meaning, and that goes right over our heads
20:30:02 <glguy> Kaidelong: no, not really
20:30:12 <mniip> jmcarthur, I don't think this counts as an excersize
20:30:15 <kaidelong> well, using lens does
20:30:21 <kaidelong> supporting lens is drop dead simple
20:30:28 <kaidelong> you don't even need it as a dependency
20:30:36 <glguy> Kaidelong, using lens doesn't require any th
20:30:37 <gfixler> kaidelong: non-mathematicians here "set of numbers" and think it means "a bunch of numbers"
20:30:42 <mniip> also I don't think you're interpreting the word "avoid" correctly
20:30:43 <gfixler> s/here/hear/
20:30:44 <glguy> Completely optional
20:30:55 <linman16> hi, cabal repl can't find packages that are installed in sandbox
20:31:02 <kaidelong> glguy: oh? Mmm, is it a separate package, or a compile flag?
20:31:02 <gcganley> how is (>>=) implemented using join, fmap and return?
20:31:05 <linman16> any one able to help?
20:31:09 <jmcarthur> mniip: i interpreted it as "ignore the presence of" more than "actively stay away from"
20:31:13 <glguy> Lens is worth learning even if you don't use it. Open your mind about mapM
20:31:34 <kaidelong> @type join
20:31:35 <lambdabot> Monad m => m (m a) -> m a
20:31:39 <mniip> gcganley, m >>= f = join (fmap f m)
20:31:40 <kaidelong> @type fmap
20:31:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:31:45 <nocturne777> does ghci do some optimizations for things like ===> findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
20:31:50 <jmcarthur> glguy: agreed, but i think it's more of an intermediate-advanced endeavor
20:31:59 <glguy> Kaidelong: it merely depends on the package but doesn't use the template haskell extension itself so it is suitable for cross compiled
20:32:04 <glguy> Compilers
20:32:09 <geekosaur> ghci does no optimizations
20:32:11 <gcganley> @type (\f m -> join (fmap f m))
20:32:12 <lambdabot> (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
20:32:26 <monochrom> gcganley: m >>= k  =  join (fmap k m)
20:32:29 <nocturne777> the author keeps showing similiar examples with foldr, which intrigued me given that it is not very efficient
20:32:40 <mniip> :t liftM join . liftM
20:32:41 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
20:32:51 <gcganley> :t join . fmap
20:32:51 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a)
20:32:51 <lambdabot>     Expected type: (a -> b) -> f a -> f a -> b
20:32:52 <lambdabot>       Actual type: (a -> b) -> f a -> f b
20:33:00 <mniip> :t flip (liftM join . liftM)
20:33:01 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
20:33:02 <mniip> there is your bind
20:33:08 <gcganley> :t fmap join . fmap
20:33:09 <lambdabot> (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
20:33:18 <gcganley> thats funky
20:33:28 <c_wraith> nocturne777: foldr is pretty much as efficient as possible for that
20:33:32 <mniip> liftM is the fmap of Monads
20:33:54 <jmcarthur> nocturne777: maybe it appears unnaturally fast to you because you don't realize how laziness is helping to short-circuit it?
20:33:55 <nocturne777> geekosaur: then foldr might end up traversing the entire list even if it found the elemen early?
20:34:13 <c_wraith> nocturne777: foldr won't traverse the whole list if it doesn't need to
20:34:16 <mniip> flip (liftM join . liftM) -- one of these liftM's is specialized to the function monad though
20:34:23 <geekosaur> nocturne777, ghci is still call-by-need
20:34:58 <gcganley> :t join . join
20:34:58 <mniip> jmcarthur, I come from a primarily lua background, where you try avoid dependencies like hell
20:34:59 <lambdabot> Monad m => m (m (m a)) -> m a
20:35:06 <jmcarthur> > let findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing in findKey "foo" ("foo", 5) : undefined   -- nocturne777
20:35:07 <lambdabot>  Couldn't match expected type ‘[([GHC.Types.Char], a)]’
20:35:07 <lambdabot>              with actual type ‘([GHC.Types.Char], t0)’
20:35:10 <jmcarthur> meh
20:35:27 <mniip> which is what I meant by "avoid lens"
20:35:41 <nocturne777> findKey :: (Eq k) => k -> [(k,v)] -> Maybe v
20:36:00 <nocturne777> that is the type signature
20:36:02 <mniip> that's called `lookup`
20:36:07 <mniip> :t lookup
20:36:08 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
20:36:20 <platz> tmate is pretty cool; shares a tmux session - could use it to share a ghci session
20:36:30 <jmcarthur> mniip: ah. well, my personal policy on dependencies is to avoid them when writing libraries and embrace them with writing executables. also, it "happens" you can support lens without depending on it.
20:36:48 <mniip> I don't support lens though
20:36:50 <mniip> I make use of it
20:36:59 <mniip> but only a small subset
20:37:01 <jmcarthur> > let findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing in findKey "foo" (("foo", 5) : undefined)   -- nocturne777, i just fail at parens
20:37:01 <gcganley> mniip: i never realized lookup was so general
20:37:02 <lambdabot>  Just 5
20:37:09 <mniip> to implement a really handy parser-prettyprinter
20:37:19 <jmcarthur> nocturne777: ^^ the point of that is to show that it isn't evaluating the tail of the list because it doesn't need to
20:37:46 <mniip> > lookup "foo" (("foo", 5) : undefined)
20:37:47 <lambdabot>  Just 5
20:38:06 <jmcarthur> mniip: maybe look at something like lens-family, which has a much smaller dependency list (and less power)?
20:38:37 <mniip> jmcarthur, is that the PG-rated version of lens? :P
20:38:41 <nocturne777> jmcarthur: I still do not get it
20:38:46 <jmcarthur> mniip: perhaps...
20:38:50 <nocturne777> foldr is supposed to return one result
20:39:02 <mniip> nocturne777, do you see multiple results?
20:39:13 <nocturne777> mniip: that is not the point
20:39:14 <jmcarthur> nocturne777: the acc in findKey is not evaluated until it is known to be needed
20:39:35 <nocturne777> what I am trying to say is that we could have been building a new list and in that case it would end up traversing the entire list
20:39:46 <gcganley> :t concatMap
20:39:46 <lambdabot> (a -> [b]) -> [a] -> [b]
20:39:54 <gcganley> :t (>>=)
20:39:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:39:59 <jmcarthur> nocturne777: why would it traverse the entire list if the key it's looking for is not at the very end?
20:40:00 <mniip> m ~ []
20:40:01 <gcganley> :t flip (>>=)
20:40:02 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:40:10 <mniip> rats
20:40:16 <c_wraith> nocturne777: foldr is as efficient as possible for what the function passed in to it does.
20:40:18 <mniip> (>>=) = flip concatMap, after all
20:40:54 <c_wraith> nocturne777: in fact, foldr should always be as efficient (or better in some cases, due to optimization magic) as explicit pattern matching
20:41:12 <dulla> so a not-lens thing, a prism?
20:41:21 <dulla> or extensible effects
20:41:22 <nocturne777> jmcarthur: so some optimization is going on ?
20:41:25 <gcganley> mniip: or you can say bind = concatMap
20:41:27 <gcganley> :t bind
20:41:28 <lambdabot>     Not in scope: ‘bind’
20:41:28 <lambdabot>     Perhaps you meant one of these:
20:41:28 <lambdabot>       ‘BS.find’ (imported from Data.ByteString),
20:41:28 <mniip> dulla, a glass xD
20:41:36 <c_wraith> nocturne777: laziness is not optimization in haskell
20:41:48 <nocturne777> how does it know not to search further once it find the value?
20:41:50 <jmcarthur> c_wraith: well... that's not totally true. sometimes you want a paramorphism instead of a catamorphism, even if only for efficiency.
20:41:53 <gcganley> edwardk: is bind (flip (>>=)) ever going to be in base?
20:41:54 <nocturne777> finds*
20:42:00 <mniip> nocturne777, because further values are not demanded
20:42:00 <jmcarthur> nocturne777: no optimization at all! it's just that haskell is non-strict
20:42:18 <jmcarthur> nocturne777: if it were strict, the example i showed you would have failed
20:42:50 <jmcarthur> s/strict/eager/
20:43:19 <c_wraith> jmcarthur: ok, true.  For paramorphisms explicit recursion can be better.
20:43:20 <nocturne777> jmcarthur: so that lamda does not get invoked for each element on that list?
20:43:21 <jmcarthur> (strict:non-strict::eager:?)
20:43:36 <c_wraith> nocturne777: it only gets invoked for the first element on the list.
20:43:41 <mniip> jmcarthur, non-eager
20:43:45 <mniip> ;)
20:44:30 <nocturne777> I understand the laziness
20:44:46 <nocturne777> I am confused about the contract of foldr
20:44:48 <c_wraith> nocturne777: I suspect you don't understand the details
20:45:07 <mniip> > foldr f [a, b, c]
20:45:09 <lambdabot>  Could not deduce (Debug.SimpleReflect.Expr.FromExpr
20:45:09 <lambdabot>                      [Debug.SimpleReflect.Expr.Expr])
20:45:09 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
20:45:12 <mniip> oh come on
20:45:23 <c_wraith> > foldr f 0 [1,2,3] :: Exp
20:45:24 <nocturne777> the way I see it, it is supposed to execute the lamda for each element of the provided list
20:45:25 <lambdabot>  Not in scope: type constructor or class ‘Exp’
20:45:25 <lambdabot>  Perhaps you meant ‘Expr’ (imported from Debug.SimpleReflect)
20:45:30 <c_wraith> > foldr f 0 [1,2,3] :: Expr
20:45:35 <lambdabot>  f 1 (f 2 (f 3 0))
20:45:47 <mniip> oh right
20:45:49 <mniip> I messed up
20:45:58 <c_wraith> nocturne777: it invokes f with two arguments.  The first element of the list, and a thunk representing the rest of the fold
20:46:15 <c_wraith> nocturne777: if the function never causes the thunk to be forces, the rest of the fold never happens.
20:46:31 <c_wraith> *forced
20:50:11 <cfoch> is there something like PackageInfo in Cabal?
20:50:24 <cfoch> or the "PackageInfo" is the .cabal file itself?
20:50:25 <cfoch> https://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo
21:00:54 <platz> c_wraith: in the findkey example, the entire list is still traversed and a chain of thunks are built up (even though only the head was forced/returned), right?
21:02:25 <c_wraith> platz: no.  It reduces something like..  foldr f z [x, y] -> f x (foldr f z [y])
21:02:27 <platz> hrm, acutally I think not now that I think about it, the evaluation order is not explicit
21:02:48 <c_wraith> platz: the recursive call isn't evaluated unless needed
21:03:08 <platz> ah, yes that makes sense
21:04:41 <platz> i was trying to figure out what made foldr 'more special' aside from being able to process infinite lists, this seems to be the property I was looking for
21:05:01 <c_wraith> platz: this property is why it can process infinite lists
21:05:27 * hackagebot avr-shake 0.0.1.1 - AVR Crosspack actions for shake build systems.  http://hackage.haskell.org/package/avr-shake-0.0.1.1 (JamesCook)
21:05:53 <platz> yes i didn't quite generalize that to other cases of early termination though, with a nice choice of accumulator
21:06:23 <platz> err, accumulating function
21:06:47 <c_wraith> yep
21:08:04 <monochrom> foldr1 (||) [True, False, False, <infinitely more stuff>
21:08:40 <monochrom> you get: True || <stuff that no longer matters>
21:09:04 <octopuscabbage> does anyone have an updated tutorial on persistent? it appears that the library has changed drastically and i'm unsure of how to use it now
21:09:07 <cfoch>  am confused. Why we have different definitions for PackageIndex? And how do I know which PackageIndex to use?
21:09:18 <cfoch> https://github.com/haskell/cabal/blob/master/cabal-install/Distribution/Client/PackageIndex.hs#L82
21:09:27 <cfoch> definition 1 ^
21:09:50 <cfoch> https://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/Distribution-Simple-PackageIndex.html#t:PackageIndex
21:09:54 <cfoch> definition 2 ^
21:11:05 <monochrom> how do you know that there are distinct? note: "different modules" is not a reason, unless you have ruled out re-exports
21:11:55 <monochrom> the claim is particularly suspicious because the second evidence is not source code
21:13:48 <cfoch> well but it is in the source code...
21:14:08 <monochrom> ok, "different packages" is enough evidence
21:14:48 <cfoch> https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/PackageIndex.hs#L169
21:15:48 <monochrom> they do fairly different things. I conclude that it is just a name clash.
21:16:05 <cfoch> so what would be the differences (usecases) between both?
21:16:07 <monochrom> people are tired of inventing new, distinct names
21:16:49 <monochrom> I don't know.
21:19:08 <monochrom> there are further apart things with identical names.
21:19:58 <monochrom> for example, close to home: "functor" rings a bell in haskell and in sml. and very different, almost unrelated bells. (any relation left is a stretch)
21:20:16 <monochrom> and I haven't even included c++
21:21:32 <monochrom> compared to that, two similar, but still a bit different, things both called PackageIndex is pretty tame, as long as their author takes the care to not mix them
21:26:28 <cfoch> monochrom: Can I 'import' both types and use them in the sale file without some conflict?
21:28:22 <c_wraith> cfoch: sure.  you can import the modules qualified
21:28:28 <kadoban> cfoch: At least one would have to be imported in a qualified module if you want to use both.
21:30:00 <octopuscabbage> is there something you have to do to enable cabal to work with template haskell? additionally is there something you have to do to get persistent to work with cabal? i can't seem to figure out why it won't read the quasi quote as a quasi quote
21:30:03 <mniip> break _ xs@[]           =  (xs, xs)
21:30:11 <mniip> is this actually any optimization?
21:30:26 <pacak> octopuscabbage: You need to add LANGUAGE QuasiQuote
21:30:31 <pacak> s
21:30:39 <octopuscabbage> to the souce files or the cabal file?
21:30:46 <pacak> octopuscabbage: Either
21:30:54 <octopuscabbage> well i haev it in the source file
21:31:18 <pacak> And TemplateHaskell
21:31:25 <octopuscabbage> yeah, i have that too
21:31:44 <octopuscabbage> i have everything listed on the yesod tutorial for persistent
21:32:01 <pacak> octopuscabbage: Magic. Any error messages?
21:33:11 <octopuscabbage> http://lpaste.net/120742
21:33:16 <glguy> mniip: Not in this case. You can see for yourself looking at the resulting simplifier output
21:33:36 <mniip> glguy, found this in prelude
21:33:46 <pacak> octopuscabbage: Anything below that?
21:33:54 <octopuscabbage> nope, just a new terminal line
21:35:08 <kadoban> mniip: Doesn't seem like there's particularly anything wrong with it, even it if's not an optimization. Seems pretty much exactly as readable as without that, and it's…well it'd be pretty hard for it to perform worse.
21:35:11 <pacak> octopuscabbage: Are you using recent ghc?
21:35:30 <octopuscabbage> 7.6.3
21:37:35 <pacak> octopuscabbage: Try increasing verbosity. Can you show few lines around line 18?
21:38:40 <octopuscabbage> http://lpaste.net/120743 here's the entire file
21:40:22 <pacak> octopuscabbage: Try moving lines 19-22 to the right of | on line 18
21:41:26 <octopuscabbage> what do you mean? increase indentation on those lines
21:41:46 <pacak> octopuscabbage: Yep
21:42:36 <octopuscabbage> http://lpaste.net/120744 i have this now
21:42:47 <octopuscabbage> oh actually hte last line is to the right of the |
21:43:15 <octopuscabbage> it has changed the parse error to the last line though
21:43:58 <pacak> opening | should be to the left of closing |
21:44:24 <octopuscabbage> i changed that and it is
21:44:31 <octopuscabbage> err it's still throwing an error on that line
21:45:50 <octopuscabbage> oh i figured it out
21:45:57 <octopuscabbage> the module declaration should be below the pragmas
21:45:58 <octopuscabbage> oops
21:46:33 <pacak> Yea, that as well.
21:46:45 <pacak> I've been bitten by this once as well.
21:49:25 <octopuscabbage> thanks though
21:57:24 <mniip> 'let (a, b) = ... in' is an irrefutable pattern isn't it
21:58:01 <pacak> mniip: Depends on ... ?
21:58:19 <monochrom> yes
21:58:31 <mniip> does 'let (a, b) = f in a `seq` ()' evaluate f
21:58:42 <monochrom> yes
21:58:47 <mniip> oh?
21:58:59 <mniip> wait I messed something up
21:59:11 <Cale> Yeah, pattern bindings are implicitly irrefutable
21:59:34 <mniip> yeah I meant
21:59:41 <mniip> does 'let (a, b) = f in ()' evaluate f
21:59:47 <Cale> no
22:00:06 <mniip> compare 'let (a, b) = undefined in ()' with 'case undefined of (a, b) -> ()'
22:00:07 <Cale> > let (a,b) = undefined in ()
22:00:08 <lambdabot>  ()
22:00:27 * mniip rewrites some code
22:00:57 <Cale> Weirdly, bang patterns can effectively turn let into case
22:01:01 <Cale> > let !(a,b) = undefined in ()
22:01:03 <lambdabot>  *Exception: Prelude.undefined
22:01:23 <mniip> I don't see anything weird
22:01:26 <Cale> It makes a certain amount of sense of course
22:01:45 <Cale> But if you think about how that needs to get desugared, it's much more complicated than it would otherwise be
22:01:48 <mniip> behavior of ! is pretty consistent across let/case/function
22:02:49 <Cale> Because you can't just stick a seq in on the right hand side of the equation and call it a day, like with function bindings.
22:02:55 <monochrom> ! and ~ are opposites
22:04:02 <mniip> let is like implicit ~
22:04:10 <Cale> It's not quite true in Haskell proper, but I tend to want to think of let as managing the heap (making definitions), and case as managing the stack (forcing evaluation through pattern matching)
22:04:21 <Cale> So bang patterns of that sort mess with that intuition a bit
22:04:45 <Cale> (of course, irrefutable patterns in case also do)
22:05:02 <mniip> given how they share the syntax more or less entirely, I prefer to keep in mind that they're the same thing
22:05:27 <mniip> I mean they all can desugar to case
22:05:28 <Cale> In core, let and case basically serve the roles I mentioned though
22:06:05 <monochrom> case creates bindings too, so case also make definitions and manages the heap
22:06:13 <mniip> interesting how a simple let-case change can change the strictness of a function entirely
22:06:52 <monochrom> (case 1+1 of v -> f v) = (let v = 1+1 in f v)
22:07:56 <mniip> f `also` g = \s -> case f s of (p, s) -> case g s of (p', s') -> (p ++ p', s')
22:08:36 <EvanR> it makes sense because let and case are almost the only things the core language uses at all
22:15:58 <bmankala> Hi, I was trying to run ghc-mod on my project and I encounter the following error
22:16:18 <bmankala> — /Users/bmankala/pr/personal/haskell/course/dist/setup-config: hGetContents: invalid argument (invalid byte sequence) —
22:16:38 <bmankala> I reinstalled cabal and generated a new sandbox.
22:16:51 <bmankala> still encountering the same problem.
22:16:54 <bmankala> any ideas?
22:19:00 <lightandlight> What's the best way to manage and change program state?
22:19:18 <lightandlight> Currently I'm using a custom data type in a State Transformer
22:19:37 <lightandlight> But it seems... bad
22:20:12 <johnw> lightandlight: why does it seem bad?
22:20:14 <Cale> lightandlight: StateT over what?
22:20:37 <kadoban> bmankala: Something about recent cabal versions not working with ghc-mod, which is apparently impossible to fix until GHC 7.10. So you have to downgrade cabal, then cabal clean, and then it'll work fine. I'm using cabal-install 1.18.0.8 and Cabal 1.18.1.5, if that helps.
22:20:57 <lightandlight> eg. data ProgramData = ProgramData Bool [String] String
22:21:03 <bmankala>  Ah! Thanks! Will try that.
22:21:11 <lightandlight> type ProgramState = StateT ProgramData IO ()
22:21:11 <Cale> lightandlight: You could probably at least use record syntax
22:21:36 <kadoban> bmankala: There's an issue about it in…I think the ghc-mod thing on github, but I don't see it immediately, but that's the gist I remember.
22:22:21 <lightandlight> I've been debating whether to use record syntax; either way I think it decreases readability
22:22:35 <bmankala> Found it. https://github.com/kazu-yamamoto/ghc-mod/issues/417. Thanks kadoban .
22:22:36 <Cale> lightandlight: StateT over IO isn't great
22:22:46 <lightandlight> Why not?
22:23:53 <Cale> Just because IO already has lots of features for managing state, and unless you're *really* concerned about restricting certain actions so they can't do general IO and only manipulate your state, it's probably not worth all the liftIOs that you'll have to do
22:24:23 <EvanR> lightandlight: you might not need all the state variables you think you do
22:24:27 <lightandlight> Wait a sec, I'll make a paste
22:25:37 <Cale> You can always make an IORef and pass that around. Often you don't even need it to be an IORef, for instance if your program is a recursive loop, you can have an ordinary function parameter act as the state, and just pass the updated state along when you recurse.
22:27:57 <cfoch> could somebody please explain me how can I make difference between both PackageIndex when I have these lines -> http://fpaste.org/187380/43271771/ ?
22:28:15 <lpaste> lightandlight pasted “Program State” at http://lpaste.net/120745
22:28:16 <Cale> You can also pass around functions that are built using an IORef, like, r <- newIORef initialState, and then pass around readIORef r and writeIORef r to the places which need to read or write the state. This sort of design lets you easily do things like logging all the changes to your state.
22:28:32 <mniip> hmm
22:28:39 <mniip> is there a better way to say
22:28:54 <lightandlight> See the paste
22:29:05 <mniip> case val of _ | pred -> foo; _ -> bar
22:29:09 <lightandlight> I don't think I used the right terminology in my question
22:29:23 <Cale> lightandlight: You're using the StateT data constructor a whole lot more than I'd usually expect anyone to use it.
22:29:28 <mniip> oh right, that's an if-then-else
22:29:45 <Cale> lightandlight: That sort of sacrifices the entire point of StateT
22:30:04 <kadoban> cfoch: Don't do that…call the second one something else, like PI. I mean the part after the 'as'.
22:30:13 <Cale> lightandlight: If you're going to write things like that, you might as well just not use StateT and instead write functions of type  s -> IO (s,a)
22:30:22 <kadoban> cfoch: Then one is PI.PackageIndex and the other one is just PackageIndex
22:30:31 <lightandlight> I mean, I could do it all in the StateT monad and just lift the IO operations, but it seems like the same thing in the end
22:32:06 <Cale> lightandlight: But if you're sticking with StateT, then you can at least write:  addItem = modify (\(ProgramData _ l fp) -> ProgramData False (x:l) fp)
22:32:45 <Cale> and  invalidChoice = liftIO . putStrLn $ append cmd " is an invalid command."
22:32:48 <cfoch> kadoban: Cabal is written so
22:33:33 <cfoch> kadoban: I didn't understand tha part of "calling it as PI"
22:33:46 <lightandlight> I don't really mind what tools I use, but I'd like the final product to have the same structure as 'program'
22:33:51 <cfoch> do you mean... "import ... as PI" ?
22:33:58 <kadoban> cfoch: Yes, of course.
22:34:28 <Cale> lightandlight: Why wouldn't parseChoice have a result?
22:34:43 <kadoban> cfoch: The part after the 'as' is arbitrary, you get to pick. So…don't make it something that's so ambiguous/overloaded. Kind of defeats the purpose.
22:35:04 <Cale> lightandlight: I think if you're just slightly more explicit about what data different parts of your program are working with, you don't need any fancy machinery at all here
22:35:41 <enthropy> Cale: doesn't that fail if you have async exceptions? Say you're writing a repl and it's not supposed to die / forget everything if you ^C
22:35:57 <Cale> enthropy: hm?
22:36:06 <Cale> enthropy: Doesn't what fail?
22:36:38 <enthropy> using StateT / StateT without the newtype wrapper
22:36:45 <lpaste> lightandlight revised “Program State”: “No title” at http://lpaste.net/120745
22:37:14 <Cale> enthropy: I'm not actually advocating the use of StateT here, but if your program is supposed to write its state to disk all the time, you'd better actually do that?
22:38:06 <Cale> lightandlight: Oh, I see, parseChoice not only parses the choice, but decides what to do with the command it got.
22:38:28 <lightandlight> @Cale yeah, it's not informatively named
22:38:28 <lambdabot> Unknown command, try @list
22:38:36 <monochrom> I fail to see how newtyping makes a difference to data loss and what happens to ctrl-c
22:39:00 <cfoch> I don't know why Cabal put it so. It is confusing.
22:39:04 <enthropy> monochrom: I'm not proposing that it does. IORefs are better in that regard
22:39:09 <Cale> enthropy: In any case, StateT s IO a behaves exactly like s -> IO (s,a)
22:39:36 <Cale> with respect to async exceptions, or any other aspect of actual I/O
22:39:48 <Cale> Of course, it makes it much more difficult to use catch, of course.
22:39:56 <mniip> woohoo implemented my first Zoom
22:40:24 <Cale> (you basically need to catch from outside the runStateT)
22:40:32 * hackagebot conduit 1.2.4 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.4 (MichaelSnoyman)
22:40:34 * hackagebot yesod-auth 1.4.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.3 (MichaelSnoyman)
22:40:59 <Cale> (or from inside a liftIO)
22:41:29 <lightandlight> To give some context: It's an interactive todo-list, and through each loop I need to know whether the list has been saved, the contents of the list, and the filename
22:41:41 <lightandlight> But it also has to perform IO
22:41:51 <lightandlight> Is StateT really inappropriate?
22:42:08 <Cale> lightandlight: I wouldn't use it. It's hard to say it's outright inappropriate
22:42:15 <Cale> But I think there are perhaps better options.
22:42:42 <Cale> The usual lightweight way to do this is just to have your program state be a function parameter.
22:42:46 <lightandlight> Cale: What are you suggestions?
22:43:05 <lightandlight> Right, I considered that
22:43:11 <EvanR> lightandlight: you could say the program as a whole must do the union of all the things that all the parts do separately, and so justify combining anything
22:43:32 <Cale> If the accesses get really non-local, you can always turn bits of it into IORefs.
22:44:53 <lightandlight> I figured passing the program state as a parameter was just a step down from using the State monad
22:45:30 <EvanR> State and StateT have different implications
22:45:32 * hackagebot mono-traversable 0.9.0 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.9.0 (MichaelSnoyman)
22:45:34 * hackagebot extensible 0.3 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.3 (FumiakiKinoshita)
22:45:38 <Cale> It's a step down in terms of amount of fancy machinery used, but that's not the same thing as "worse"
22:45:52 <ttt_fff> is there a way to do macros without template haskell ?
22:46:03 <Cale> IO already has a lot of machinery in it which you could put to use instead
22:46:10 <ttt_fff> does haskell have a simple C/C++ like amcro system, with special symbols to access things like (1) function nam e and (2) args to function ?
22:46:29 <EvanR> ttt_fff: template haskell
22:46:41 <Cale> ttt_fff: Uh, function name? C's macro system doesn't have that
22:46:42 <monochrom> you have the option of CPP macros. to the point there is {-# LANGUAGE CPP #-} for it.
22:46:44 <ttt_fff> EvanR: did you see the part where it says "without template haskell" ? :-)
22:46:52 <Cale> You can use CPP with Haskell
22:46:54 <EvanR> ttt_fff: i took the second part in isolation ;)
22:47:07 <ttt_fff> ttt_fff : or are you suggesting nothing interesting can be done without template haskell :-) ?
22:47:11 <Cale> ttt_fff: Maybe I don't understand what it is that you want...
22:47:22 <ttt_fff> Cale: maybe we have X Y problem
22:47:25 <Cale> ttt_fff: If you want to use C's macro system, you can use it
22:47:25 <ttt_fff> Cale: let me clarify
22:47:35 <Cale> (and some people do)
22:47:35 <ttt_fff> let me go write a little mini haskell essay on my setup
22:47:59 <mauke> the C/C++ macro system doesn't provide access to things like function name / args
22:49:05 <lightandlight> Cale: But if I used less machinery, wouldn't the main method end up more complex
22:49:55 <Cale> lightandlight: I don't think it would get much worse.
22:50:18 <Cale> lightandlight: printList would need to take the current list as a parameter
22:50:43 <lightandlight> It would just be function composition instead of binds
22:51:33 <Cale> lightandlight: Did you paste your whole program anywhere? If you have a version which compiles, I can show you what I mean
22:52:16 <lightandlight> https://github.com/LightAndLight/haskell-todo
22:52:28 <lightandlight> Just clone it and use cabal install
22:53:17 <Cale> heh, that MVC :)
22:53:20 <ttt_fff> http://lpaste.net/120747 <-- GENTLEMEN, pls help :-) I allmost have my idea error logging setup; basically, I'm impelemtnign trace/stack frames via a monad
22:53:25 <monochrom> you may like my game: http://lpaste.net/52480
22:53:26 <lightandlight> I didn't really want to point people straight to the full source for fear of being too demanding
22:53:39 <ttt_fff> I jsut want a macro to simplfy my life ... I wnat the macro to dump out (1) the func name, and (2) do "map _SvgTree args"
22:53:48 <ttt_fff> (I have _SvgTree declared on all data types I care about)
22:53:51 <monochrom> it uses parameter passing. you could put IORef or StateT on it and compare
22:53:59 <ttt_fff> err, I have an typeclass ToSvgTree, which most of my data types have instances of
22:54:00 <Cale> One thing I'd complain about immediately is that your Model has IO in it.
22:54:21 <Cale> Like, the whole point of MVC is that the model is a declarative specification of program behaviour
22:54:46 <lightandlight> Cale: Cursory research suggested IO should be there
22:55:17 <lightandlight> http://programmers.stackexchange.com/questions/175185/model-view-controller-mvc-which-component-handles-save-load-operations
22:55:50 <mauke> ttt_fff: that description contains a few type errors
22:55:55 <Cale> :)
22:56:05 <Cale> Well, people have different opinions I suppose
22:56:34 <monochrom> in MVC, the M part is pure functional to me, too
22:56:36 <ttt_fff> mauke: it does
22:56:43 <ttt_fff> mauke: parts of it is summaries, and not literal code
22:56:44 <lightandlight> That's alright. I need the opinions on the overlying architecture rather than MVC semantics
22:56:49 <ttt_fff> muake: do you get the gist of what I am doing though?
22:57:08 <Cale> I would consider all the *actual* reading and writing that the program does either as part of the controller, or part of the view, depending on which sort of reading and writing that is (the lines between view and controller are much blurrier than between model and everything else)
22:57:27 <monochrom> sometimes I still use mutable data for M just because it's faster or it's Java. that is an implementation detail.
22:58:59 <lightandlight> Fair enough
22:59:07 <Cale> If you have the "right" opinions about how MVC works, then the questions about which part of the program uses IO and which part of the program should be "pure" are somewhat clarified by keeping IO out of the model.
22:59:20 <Cale> Which is the only reason I mentioned it :)
22:59:27 <mauke> ttt_fff: yeah, but you're using types like LoggedMaybe a b that don't exist
23:00:27 <mauke> ttt_fff: what you're looking for isn't well defined
23:00:46 <mauke> and I don't know any system that provides the specific example you give
23:01:38 <lightandlight> So maybe when I load the list, I shouldn't use any IO to indicate errors, but instead return some kind of error along with the previous program state?
23:02:05 <lightandlight> Then interpret the error using the controller, which does IO?
23:02:37 <lightandlight> Or the view, whatever
23:02:57 <Cale> Well, hmm... actually this MVC thing is going to maybe be distracting. I still want to show you what I might do here if I'm not overengineering things.
23:05:08 <monochrom> when I load a list: I use an IO action to get the file content. I use a pure parser to get me "Left parse_error" or "Right the_fine_list". then I use an IO action to say "parse error", if it is a parse error.
23:05:21 <monochrom> the parser part needs not dabble in IO
23:05:29 <Cale> right
23:05:40 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml#organization
23:05:52 <monochrom> a guiding principle so simple people cannot stick to it
23:06:59 <Hijiri> just noticed new sexy haskell.org
23:07:05 <Hijiri> how late am I
23:07:20 <StoneCypher> just a few days
23:10:53 <lightandlight> I'll make a fork and try to implement some of these concepts
23:12:58 <Guest96> hey .. would anyone be up for a cabal question
23:15:58 <Guest96> i downloaded ghc-7.8.4.app on OS X mavericks .. it comes with a bunch of packages in the lib directory.  for example transformers 0.3.0.0 ... now I'm trying to build something that is conflicting with a different version of transformers.     am I screwed ?
23:16:25 <Guest96> trying: hint-0.4.2.2 (dependency of Moodler-0.1.0.0)
23:16:26 <Guest96> next goal: ghc (dependency of hint-0.4.2.2)
23:16:27 <Guest96> rejecting: ghc-7.8.4/installed-436... (conflict: free =>
23:16:27 <Guest96> transformers==0.4.2.0/installed-686..., ghc =>
23:16:29 <Guest96> transformers==0.3.0.0/installed-645...)
23:17:07 <HeladoDeBrownie> Guest96, is that part of the haskell platform distribution or something?
23:17:28 <Guest96> not the haskell platform .. just the download linked to on the haskell.org page
23:18:14 <HeladoDeBrownie> hmm, odd that it should include transformers installed by default. no idea, sorry.
23:18:53 <Guest96> i guess it would be bad if I just wiped out that lib directory in the app ? ... well let's just try ...
23:19:06 <HeladoDeBrownie> well, worst comes to worst, you can always reinstall, right?
23:19:17 <Guest96> yeah
23:19:21 <HeladoDeBrownie> though deleting part of a distribution seems error-prone
23:19:47 <Guest96> haha .. yeah .. if this works it will be a miracle
23:24:11 <Guest96> yeah that did not work ... oh well I guess I'll just download a more minimal ghc install that doesn't have so much stuff in the library ....
23:27:17 <shock_one> Does anybody know how would I tell if a string is concatenation of a list of string in a better time than exponential?
23:27:23 <shock_one> Exponential solution is
23:27:27 <shock_one> isConcatenation _ [] = True
23:27:28 <shock_one> isConcatenation dict str = any (isConcatenation dict) $ mapMaybe (`stripPrefix` str) dict
23:27:53 <mniip> shock_one, what do you mean "if a string is a concatenation of a list of strings"
23:28:35 <shock_one> isConcatenation ["a", "b"] "aabbbbbaba" => True
23:28:40 <mniip> ah
23:28:59 <shock_one> Combination with repetitions, if you prefer.
23:30:34 <mniip> that doesn't seem exponential
23:30:43 <mniip> ah right
23:30:47 <mniip> exponential worst case
23:31:12 <mniip> I don't think you can, exactly
23:31:44 <mniip> your problem is equivalent to matching a regex "(foo|bar|...)*" which is generally exponential
23:31:53 <shachaf> Yes, you can do better than exponential.
23:32:04 <mniip> oh?
23:32:09 <shock_one> shachaf: please continue.
23:32:36 <mniip> shachaf, even if the dict contains strings of different lengths?
23:33:24 <shachaf> This is sounding a bit like homework or something.
23:33:33 <mniip> something about polynomial hashes is whirling in my head
23:34:12 <shachaf> Maybe I misunderstood the problem. You could give another example.
23:34:12 <shock_one> shachaf: you're right. Or something.
23:34:54 <shock_one> isConcatenation ["hell", "hello"] "hellhellohell" => True
23:35:16 <mniip> yep I was just thinking about common prefixes
23:35:30 <shock_one> Or, as mniip said, (foo|bar|...)* in better time.
23:36:05 <orzo> is there any interface similar to that for arrays where i can use the ST monad to allocate and mutate a bytestring and freeze it when i'm done?
23:39:36 <shock_one> So, my best guess was to build a nondeterministic finite automata, convert it into a DFA, minimize, and we'll get linear time. However, building a DFA will take exponential time.
23:40:11 <monochrom> I am too lazy to detail an algorithm, but this problem is no harder than context-free parsing, which is cubic time even if you use a very old algorithm.
23:40:48 <monochrom> one trick in that old algorithm is dynamic programming
23:43:26 <steffen> I am struggeling hard to write a read instance for 'data Var = Var Text' which should read "var(val!with)" to Var "val!with" (assume overloaded Strings :)) It is easy for "var(\"val!with\")" but without the \" I can not recursively call readsPrec to read the Text! Please help
23:44:04 <shachaf> steffen: What if there is a ) inside the var?
23:45:19 <steffen> shachaf: Your right! is there a way to tell lex to allow special characters? I only want alphaNum + ['!', '/']
23:45:28 <steffen> for lexemes
23:46:04 <shachaf> Then don't bother with recursive calls readsPrec
23:46:10 <mniip> oh right
23:46:12 <mniip> dynamic
23:46:24 <shachaf> Just takeWhile (/= ')') or something.
23:46:43 <mniip> not sure how to represent a dynamic in haskell though
23:47:05 <steffen> shachaf: good idea, I'll try that :)
23:47:24 <shachaf> Data.Dynamic allows for Dynamic programming
23:48:27 <EvanR> mniip: Dynamic wraps any typeable. but on a saner scale you can make a custom sum type which tags which kind of value a value is at runtime
23:48:42 <mniip> EvanR, :|
23:48:52 <mniip> EvanR, http://en.wikipedia.org/wiki/Dynamic_programming
23:49:07 <EvanR> going full dynamic in haskell is normally not that pleasant. much like in any language
23:49:12 <shachaf> I think this is easier to express in a context other than Haskell code with linked lists.
23:49:28 <shachaf> You can keep track of indices or something.
23:49:39 <mniip> that works
23:49:44 <shachaf> But it's not unreasonable in Haskell.
23:50:05 <EvanR> "Dynamic programming" nevermind thats something else
23:50:49 <mniip> EvanR, wrt full dynamic, GHC.Prim.Any is your friend ;)
23:50:58 <EvanR> no
23:51:06 <EvanR> never
23:51:09 <mniip> heh
23:52:51 <wz1000> The loeb function would be usefull for dynamic programming I imagine.
23:58:26 <mniip> so yeah I'm making lens-like things for parsing and modifying json in-place https://gist.github.com/mniip/1a836b295c9063a3bd87
