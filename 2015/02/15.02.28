00:00:13 <epichero> sure
00:01:15 <wolfcore> have you tried evil-mode for emacs?
00:01:24 <wolfcore> it's really great
00:01:30 <epichero> https://github.com/syl20bnr/spacemacs
00:01:34 <epichero> if you use evil use this
00:02:23 <epichero> i've written ... far too much elisp to get emacs to act like vim, but I am just starting haskell and haven't taken the time to get it setup yet
00:04:03 <wolfcore> ah
00:04:04 <wolfcore> I see
00:06:17 <epichero> seriously though, it's worth it to invest the time it takes to switch over to spacemacs if you use evil-mode. I'd been working on my own setup that does a tenth of what spacemacs does ever since i started to learn clojure a couple years ago
00:06:38 <epichero> and i ended up copying just a little bit of my personal setup over and using spacemacs the day i tried it
00:08:24 <wolfcore> Not sure how I feel about a premade setup....I've been using emacs for a couple months and have it set up pretty well for c, js, ocaml, haskell, clojure, and scheme...I don't really write any other langs currently. But I definitely might steal parts of it for my config
00:10:03 <Zemyla> Huh. You can unwrap a Kleisli arrow inside a monad.
00:10:14 <Zemyla> :t \f x -> f >>= ($ x)
00:10:15 <lambdabot> Monad m => m (a -> m b) -> a -> m b
00:17:20 <epichero> wolfcore, it's really worth it to port over your config to spacemacs instead. I'm never this zealous, but having written so much emacs lisp working on getting everything just right I can say i haven't looked back
00:20:03 <wolfcore> epichero: cool, I'll try it out :)
00:21:11 <Lokathor> epichero, http://www.stackage.org/install#mac-os-x has some install advice as well
00:23:24 <dulla> yeah...
00:23:42 <dulla> there's a defined syntactic sugar for arrows and monads
00:23:52 <dulla> x <- fun -<< something
00:23:59 <dulla> can you guess
00:31:05 <Lokathor> ghc says it can't find some required C files while building
00:31:08 <Lokathor> but they're clearly right there
00:32:07 <EvanR> maybe you need -Ifoo/bar/baz/
00:32:26 <Lokathor> is -I different from --extra-include-dirs ?
00:33:00 <EvanR> probably not
00:33:12 <EvanR> include-dirs is for .h files i think
00:33:31 <Lokathor> i also have some --extra-lib-dirs
00:34:31 <Lokathor> it's troublesome when the guides always say "just cabal install it"
00:34:39 <Lokathor> when that's always a nightmare on windows
00:35:02 <EvanR> youre doing gtk on windows
00:35:33 <Lokathor> well i want something on windows, i'd accept other options if there are better options
00:35:49 <EvanR> good, you can fix all the windows problems ;)
00:36:23 <Lokathor> i got the same sort of problem last time i tried to install SDL2 as well
00:36:32 <Lokathor> it never finds the libraries that are clearly right there
00:36:37 <Lokathor> i must be passing the wrong options somehow
00:39:29 <lpaste> Lokathor pasted “failed build output” at http://lpaste.net/121327
00:40:34 <EvanR> Lokathor: it says you dont have zlib and cairo installed
00:40:44 <EvanR> C libraries
00:41:17 <Lokathor> zlib.h is in the include directory
00:41:34 <Lokathor> cairo.hs is also in include/cairo
00:41:37 <Lokathor> er, .h
00:41:50 <EvanR> what about the library
00:42:18 <dramforever> IIWY I would go online and find a sample cairo c program and compile+run ir
00:42:21 <dramforever> s/ir/it
00:42:24 <dramforever> same for zlib
00:42:47 <Lokathor> cairo.def, cairo.lib, zlib.def, and zdll.lib
00:42:51 <Lokathor> that last one seems misnamed
00:43:02 <EvanR> (whats a def file...)
00:43:24 <Lokathor> (dunno, they just came in the 'complete' package)
00:45:34 <aidecoe> EvanR: thank you a lot! (-:
00:45:38 <aidecoe> goodmorning
00:51:23 <Lokathor> well, trying the c files with gcc, i'm getting a lot of undefined references
00:51:48 <EvanR> you have to link those libs
00:51:55 <EvanR> -lz
00:51:57 <EvanR> -lcairo
00:52:06 <Lokathor> oh
00:52:08 <Lokathor> hmm
00:52:53 <Lokathor> i was using -L
00:53:14 <EvanR> -L is like -I, the path following is additional places to look for libs
00:53:49 <EvanR> -lwhatToLinkto
00:53:54 <Lokathor> well now with -I, -L, and -l... it tells me that it skipped incompatible versions
00:54:11 <EvanR> incompatible versions
00:54:49 <Lokathor> skipping incompatible D:\Dropbox\dev\gtk2hs-build\lib\cairo.lib when searching for -lcairo
00:55:14 <EvanR> incompatible with windows?
00:55:46 <Lokathor> i think it means that the .h files and the .lib files don't match versions
00:55:59 <Lokathor> i don't know why that would be
00:56:00 <dramforever> Lokathor: no way
00:56:12 <dramforever> the linker doesn't even know about headers
00:56:53 <lpaste> Lokathor pasted “linker error” at http://lpaste.net/121328
01:01:26 <dramforever> Whoa I just discovered a lens-y (no pun intended) thing that can be composed with (.) from Prelude
01:03:15 <lpaste> dramforever pasted “lens-y blah” at http://lpaste.net/121329
01:05:27 <dramforever> oh wait the setter is wrong
01:10:37 <socumbersome> Hi. Why is continuation monad the mother of all monads?
01:10:46 <shachaf> It isn't.
01:10:53 <shachaf> Codensity is the real mother of all monads.
01:11:16 <EvanR> i thought Free was the mother of all monads
01:11:24 <socumbersome> Well, I came across such article on the net saying so.
01:11:34 <dramforever> I thought Identity was the mother of all monads
01:12:39 <dramforever> what's this pakchoi2 guy doing?
01:12:55 <EvanR> spammin
01:13:03 <socumbersome> And about Codensity or Free - are there some articles on it why it's so powerful?
01:13:05 <dramforever> pakchoi2: are you okay?
01:13:26 <shachaf> There probably are.
01:13:29 <dramforever> (Sorry if it sounds insulting)
01:13:54 <EvanR> hes having an IRCeisure
01:14:17 <shachaf> @google improvement free monad
01:14:18 <lambdabot> http://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf
01:14:18 <lambdabot> Title: Asymptotic Improvement of Computations over Free Monads
01:14:26 <shachaf> Maybe that one.
01:14:47 <dramforever> EvanR: does Max SendQ exceeded means the client cannot recieve fast enough or the client is sending too much?
01:15:20 <dramforever> shachaf: Actually Cont is also used to improve performance, right?
01:16:13 <dramforever> I mean, sometimes, when used correctly
01:18:46 <socumbersome> Hmm, thanks for the link. But I'm still baffled about the claim in - http://blog.sigfpe.com/2008/12/mother-of-all-monads.html . How then one could say a precise claim about exceptionality of Cont monad, based on that article?
01:20:17 <shachaf> That article thinks it's talking about Cont but it's really talking about Codensity.
01:22:57 <dramforever> I just saw this post about codensity, but I'm not sure it's easy to understand: http://comonad.com/reader/2012/unnatural-transformations-and-quantifiers/
01:23:19 <dramforever> no...it's too theoretical
01:24:11 <shachaf> Codensity is easy as monoids.
01:24:18 <shachaf> (>>=) :: Monad m => m a -> forall b. (a -> m b) -> m b
01:24:25 <shachaf> Codensity m a =            forall b. (a -> m b) -> m b
01:24:35 <dramforever> shachaf: I mean the post
01:25:44 <socumbersome> hmmm, the type for codensity looks as if it's specialized Cont, i.e. in which we enforce r (as in (a -> r) -> r) to be m b.
01:25:58 <shachaf> Codensity is more general than Cont.
01:26:11 <shachaf> You can always get Cont by using m = Const r
01:26:15 <shachaf> You can't get Codensity from Cont.
01:27:11 <johnw> that's the answer you should have started with: Codensity is the mother of all monads because Codensity (Const r) a = Cont a
01:27:21 <johnw> Cont r a
01:27:32 <socumbersome> I'm a bad theorist but why that simple substitution r to m b doesn't work?
01:27:52 <dramforever> socumbersome: that's right, but your intuition is backwards
01:27:53 <shachaf> That's not an answer at all.
01:27:59 <shachaf> socumbersome: Because of the forall.
01:28:06 <dramforever> shachaf: right?
01:28:13 <johnw> it's the answer that would have made it clear to me
01:28:16 <dramforever> oh okay okay
01:28:25 <johnw> I feel like we danced all around just to get to that
01:28:46 <shachaf> All around what?
01:28:51 <dramforever> johnw: why is Cont the Mother of Wll Monads?
01:28:51 <johnw> never mind
01:28:54 <dramforever> s/Wll/All
01:29:07 <johnw> Cont is but a child of the Mother of All Monads
01:29:24 <shachaf> You can define ContT r m a = (a -> m r) -> m r
01:29:33 <shachaf> And now Cont r a = ContT r Id a
01:29:40 <shachaf> But ContT is not the mother of all monads.
01:29:58 <socumbersome> schachaf - because of the lakc of quantifier?
01:30:00 <shachaf> In fact "mother" is not even a well-defined relationship. Codensity is special.
01:30:26 <shachaf> (Not well-defined when talking about monads or other algebraic structures, at least.)
01:31:22 <socumbersome> And having any monad t, is it possible to derive an appropriate substitution to get t out of Codensity?
01:31:38 <shachaf> No.
01:32:37 <socumbersome> And how about "simulating" any t?
01:32:59 <shachaf> Yes.
01:35:33 <boothead_> Can anyone tell me where the s t a b nomeclature for Lens came from? I seem to remember something explaining why they were so called, but I can't find it
01:36:05 <dramforever> boothead_: 1. Lens (Foo a) (Foo b) a b
01:36:09 <shachaf> boothead_: It used to be a b c d but that was confusing because it doesn't unify well with e.g. the type for traverse.
01:36:22 <dramforever> ignore that "1."
01:36:25 <socumbersome> schachaf: hmmm, and could you show how to simulate, for instance, State monad using Codensity?
01:36:31 <shachaf> boothead_: So wanted the last two letters to be a b, and there was a lot of arguing over what the first two letters should be.
01:36:59 <dramforever> actually x y, p q, etc. are all pretty okay
01:37:05 <dramforever> right?
01:37:08 <shachaf> boothead_: You can say that s stands for "source" or "structure" or "state", and t stands for "target" or "the letter after s".
01:37:22 <dramforever> u v
01:37:28 <boothead_> shachaf, that's a good one thanks!
01:37:32 <shachaf> socumbersome: The same way he shows in that post.
01:38:23 <shachaf> socumbersome: Or the way I half-hinted at above.
01:39:59 <socumbersome> Are the definitions of "i" and "run" the key?
01:43:23 <ahg> is spacemacs ready for haskell development? It seems promising, but at unpredictable moments (e.g. on adding a newline) it splits my window into two frames, one of which describes some feature (e.g. haskell-mode-hook). I can't tell if this is because I've missed a configuration step, or if I should just wait a few months and try again.
01:43:37 <ahg> forgive me if I've confused windows and frames--I'm coming from vim.
01:43:56 <dramforever> ahg: yes you are
01:44:02 <dramforever> I mean, you are confused
01:44:12 <ahg> well, yes, that's for certain
01:44:51 <ahg> dramforever: so what happened is that my frame was split into two windows?
01:45:03 <dramforever> yep
01:45:09 <shachaf> socumbersome: You could say that.
01:45:18 <shachaf> socumbersome: It's reasonable to work it out yourself from the types.
01:45:22 <shachaf> lift :: m a -> Codensity m a
01:45:28 <shachaf> lower :: Codensity m a -> m a
01:45:30 <ahg> dramforever: duly noted.
01:53:01 <ahg> so is anyone using spacemacs for haskell development?
02:15:45 <L8D> ahg: yes
02:15:57 <L8D> ahg: not me but I've heard several other people mention spacemacs
02:16:18 <L8D> ahg: christiansen I believe
02:16:47 <L8D> Is there a monad you couldn't emulate through ContT?
02:22:37 <L8D> it doesn't have Alternative/MonadPlus instances :/
02:29:23 <lpaste> dramforever pasted “My thoughts on lens. Is this correct?” at http://lpaste.net/121330
02:29:45 <dramforever> Hi I just came up with this ^
02:30:28 <shachaf> Is what correct?
02:40:22 <dramforever> shachaf: ping
02:40:28 <dramforever> http://lpaste.net/121330
02:40:32 <jle`> it seems like you know the answer to your question dramforever :)
02:40:41 <dramforever> jle`: I
02:40:46 <dramforever> I'm asking for advices
02:40:50 <shachaf> ?
02:41:11 <jle`> do you want an actual working type?
02:41:12 <dramforever> How is that piece of code?
02:41:33 <dramforever> jle`: I'm asking for approval/suggestions/corrections/etc.
02:41:48 * jle` pats dramforever on the head :)
02:41:55 <jle`> it's a nice attempt and i like that you recognize what is impossible
02:41:58 <bennofs> dramforever: that lens type looks like it would be isomarphic to (a -> b) -> (s -> t)
02:42:19 <shachaf> I don't think (r ->) is very useful as a choice of functor.
02:42:32 <dramforever> shachaf: but Const
02:42:49 <bennofs> dramforever: all that a function f g s r implementing  that signature can do is to apply g with r
02:44:00 <dramforever> jle`: thanks
02:44:24 <dramforever> bennofs: oh of course
02:44:35 <bennofs> dramforever: so your Lens
02:44:47 <bennofs> dramforever: is isomorphic to a Setter from 'lens'
02:47:28 <dramforever> I used to have something like ((p -> s), (q -> a -> b)) -> ((p -> a), (q -> s -> t)) or something like that
02:47:37 <dramforever> so it's like a difference lens
02:48:10 <dramforever> then I thought: hey! there's a get call in the set part already, why can't I use it?
02:50:09 <bennofs> dramforever: you might want to try type Lens s t a b = s -> (a, b -> t)
02:50:51 <dramforever> bennofs: already tried that
02:51:09 <dramforever> I was trying to do the same thing as E. Kmett: make lenses compose with Prelude.(.)
02:51:19 <dramforever> foo.bar.baz.quux
02:51:34 <bennofs> ah
02:52:01 <dramforever> so I keep trying to make the two parts around the (->) similar
02:52:32 <shachaf> I have a bunch of old lens representations somewhere that did that sort of thing.
02:53:14 <jle`> the current representation is credited to van laarhoven i believe
02:53:17 <bennofs> dramforever: also, why do you need q in there?
02:53:29 <dramforever> p and q are independent
02:53:32 <shachaf> I never get credit for the profunctor representation. :-(
02:53:41 <jle`> is that you shachaf
02:53:46 * jle` claps
02:53:50 <bennofs> shachaf: I was about to say that prisms aren't really var laarhove-style :)
02:54:03 <jle`> should i call the profunctor representation shachaf lenses
02:54:13 <dramforever> actually...I find this quite useful:
02:54:17 <shachaf> If you want "difference lenses" you can always define "type DLens s t a b = forall x y. Lens a b x y -> Lens s t x y"
02:54:17 <aloiscochard> hi all, I'm writing a c binding with c2hs, and I'm looking for an other library that use it and that would be a good example? any recommendations?
02:54:27 <shachaf> Where Lens s t a b = s -> (a, b -> t) or whatever you want.
02:54:37 <dramforever> > (Nothing ^. _Just, Just "hello" ^. _Just)
02:54:39 <lambdabot>  ((),"hello")
02:54:46 <dramforever> ouch
02:54:51 <bennofs> dramforever: I mean wouldn't (s, (a -> b)) -> (a, (s -> t)) also work?
02:54:54 <dramforever> > (Nothing ^. _Just, Just "hello" ^. _Just) :: (String, String)
02:54:55 <lambdabot>  ("","hello")
02:55:06 <dramforever> bennofs: yeah it is
02:55:21 <dramforever> that one is just not as elegant, right?
02:56:26 <bennofs> dramforever: why not? I find it more elegant, because it is simpler :=) (and what do the extra p -> and q -> actually gain you?)
02:56:40 <dramforever> bennofs: yeah I mean mine is not elegant
02:57:06 <dramforever> I'm thinking if I have a getter from p to s, we can have a getter from p to a
02:57:20 <dramforever> same for the setter
02:58:58 <dramforever> I also tried something like but not exactly the same as:
02:58:59 <dramforever> type Lens s t a b = forall r. (a -> (b -> t) -> r) -> s -> r
02:59:34 <dramforever> they composes, but the result is like (a -> (b1 -> t1) -> (b1 -> t2) -> r) -> s -> r
03:01:46 <shachaf> That is also in my old strange lens representations file.
03:02:05 <dramforever> shachaf: should I keep my lenses?
03:02:09 <dramforever> old lenses
03:02:13 <shachaf> If you like them.
03:02:37 <shachaf> The nice thing about Functor f => (a -> f b) -> s -> f t is that the type is just the right size.
03:02:54 <dramforever> shachaf: actually I once wrote this: forall r. Monoid r => ( a -> r ) -> ((b -> t) -> r) -> s -> r
03:03:02 <shachaf> "type DLens s t a b = forall x y. Lens a b x y -> Lens s t x y" composes with (.), but it has a lot of inhabitants that aren't lenses.
03:03:09 <dramforever> the lens is supposed to monoid the two r's together
03:03:13 <dramforever> shachaf: yep
03:03:20 <dramforever> s/monoid/mappend/
03:51:57 <meditans> hi all, how do you include haddock coverage for the lenses generated by makeLenses?
03:52:41 <meditans> if I write a haddock comment before makeLenses, only the first generated lens gets a comment.
03:55:30 <dramforever> Um...most bizarre idea today:
03:56:04 <dramforever> type NotLens s t a b = forall arr. Arrow arr => arr a b -> arr s t
03:57:30 <YaRly> I have an abstract type and want to allow users to instantiate an empty instance of any type, how do I do this? Right now I'm using    empty :: a -> MyAbstractType a   which forces users to input a value of the type (like 1::Int) instead of just the type (Int)
03:57:44 <dramforever> Identity is a monad, so you can use the Kleisli arrow and do set
03:58:03 <dramforever> YaRly: that's not possible in haskell
03:58:15 <dramforever> it's not possible to pass a type as a value
03:58:33 <dramforever> but how about emptyFoo?
03:58:48 <YaRly> ok, so users can instead do   empty :: MyAbstractType Int   ?
03:58:56 <supki> meditans: you'd need a type signature to attach the haddock comment to
03:58:59 <dramforever> yeah
03:59:09 <YaRly> dramforever: Was that a reply to me?
03:59:12 <dramforever> YaRly: yeah
03:59:15 <supki> meditans: lens generates them itself, but you can tell it not to (see Control.Lens.TH.generateSignatures)
03:59:23 <YaRly> dramforever: Ok, thanks. That works :)
03:59:36 <dramforever> YaRly: also what's empty?
03:59:41 <dramforever> where did you get it
03:59:53 <YaRly> it's an abstract type, so I choose myself what empty is
03:59:56 <supki> meditans: then you can write them yourself, so it's possible to attach haddock comments to something
04:00:04 <YaRly> It's just two empty lists in a tuple
04:00:11 <dramforever> YaRly: Data.Map, Data.Set all have empty in them
04:00:25 <dramforever> I guess you can do it like that
04:00:35 <YaRly> dramforever: Yes I know, but I don't think it will collide since I'll import it as a namespace
04:00:55 <YaRly> dramforever: Oh, do you mean why I chose the name "empty" instead of "getNewEmpty" or something?
04:00:56 <dramforever> YaRly: did you know? usually the type annotation is not required
04:01:22 <dramforever> I mean, when used with a context
04:01:22 <dramforever> s/with/within/
04:01:36 <YaRly> dramforever: You mean I don't need to do   empty :: MyAbstractType Int   It'll figure it out by itself?
04:02:32 <supki> meditans: here's an example https://github.com/biegunka/biegunka/blob/develop/src/Control/Biegunka/Settings.hs#L101
04:12:36 <bennofs> dramforever: that looks a lot like profunctor lenses
04:12:53 <bennofs> oh, dramforever left
04:20:47 * hackagebot GLUtil 0.8.4 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.8.4 (AnthonyCowley)
04:25:01 <meditans> supki: thanks, that was what I needed! :)
04:38:34 <phaazon> hey, how can I pass options to c2hs in the .cabal file?
04:38:39 <phaazon> can I?
04:40:01 <phaazon> hm I guess I can use the extra-lib-dirs and include stuff
04:40:48 * hackagebot order-maintenance 0.0.0.0 - Algorithms for the order maintenance problem with a safe  interface  http://hackage.haskell.org/package/order-maintenance-0.0.0.0 (WolfgangJeltsch)
04:45:49 * hackagebot incremental-computing 0.0.0.0 - Incremental computing  http://hackage.haskell.org/package/incremental-computing-0.0.0.0 (WolfgangJeltsch)
05:15:27 <bennofs> is there a way to tell gloss not to rerender always? I'm writing an application that will have long static parts, and I'd like to disable rerendering for that part
05:26:00 <mniip> EvanR, ahhh
05:26:06 <mniip> I found where monoid comes from
05:26:19 <mniip> instance Monoid m => Applicative (Const m)
05:26:29 <EvanR> hah
05:26:42 <mniip> and Getting, the argument type of view, uses Const
05:27:02 <EvanR> where is Const defined
05:27:16 <bennofs> EvanR: Control.Applicative
05:27:16 <EvanR> which module do i import
05:27:18 <mniip> Control.Applicative
05:27:30 <EvanR> sneaky
05:28:05 <EvanR> instance Monoid m => Applicative (Const m)
05:28:05 <crocket> Is it much easier to read and reason about a haskell program than a ruby program?
05:28:09 <crocket> How about writing?
05:28:32 <EvanR> its much easier to write a haskell program than to understand typical ruby libraries you find on github
05:28:38 <EvanR> i say
05:28:48 <mniip> crocket, haskell is very different from ruby
05:29:09 <EvanR> probably reading too
05:29:09 <crocket> EvanR, You answered a different question than I asked.
05:29:15 <mniip> for someone with no experience with fnuctional/lazy programming haskell might appear very complex
05:29:25 <EvanR> crocket: well your question is about all ruby programs
05:29:43 <crocket> EvanR, Ruby is an example of a powerful dynamic language.
05:29:52 <mniip> whereas for someone with no experience with perl heuristics ruby might appear very complex
05:30:30 <EvanR> crocket: its an example of a language where the culture of the community is to make use of features which make it difficult to reason about code
05:30:38 <EvanR> extensively
05:31:15 <EvanR> self modifying code is something haskell doesnt embrace
05:31:25 <crocket> EvanR, I guess haskell is advantegeous when reading takes 10 times the time it takes to write.
05:31:44 <crocket> self-modifying code?
05:31:46 <mniip> it's possible to write complicated haskell
05:31:59 <EvanR> theres a comparison to be made between writing haskell, and writing correctly working ruby
05:32:00 <mniip> well
05:32:05 <EvanR> and how long that takes
05:32:40 <exio4> @pl (\y g z x f w -> (f <$> g y x <*> z) =<< w)
05:32:40 <lambdabot> (((((((=<<) .) . flip (<$>)) .) .) . flip . ((<*>) .)) .) . flip id
05:32:46 <crocket> My coworker said writing in haskell was very difficult while writing in ruby was easy and powerful.
05:32:48 <exio4> there, complicated code that nobody will read
05:33:04 <mauke> crocket: I find haskell much easier than ruby
05:33:07 <crocket> He recommended rust over haskell.
05:33:08 <mauke> crocket: also, I don't know any ruby
05:33:11 <mniip> @pl f x y z t = f t z y x
05:33:12 <lambdabot> f = fix (flip . ((flip . (flip .)) .) . flip . (flip .) . flip)
05:33:24 <crocket> He said rust is focused on not crashing.
05:33:42 <EvanR> ruby has nothing in the way of types to help you decide what to write
05:33:44 <mauke> crocket: k
05:33:56 <crocket> I'm definitely going to learn haskell...
05:34:46 <EvanR> the amount of information from a type signature can be aquired in ruby only by checking most of the source files of the target library
05:34:57 <mniip>  yeah
05:35:02 <mniip> type singatures are bos
05:35:02 <mniip> s
05:35:19 <EvanR> even then that might not be enough
05:35:21 <mauke> EvanR: but haskell doesn't even have exception signatures like java
05:35:43 <EvanR> yeah, exceptions in haskell is in the same shape as ruby's string operations
05:35:49 <EvanR> or anything
05:37:28 <crocket> EvanR, That's why dynamic language libraries have documentations attached.
05:37:40 <crocket> You know python community is serious about documentation.
05:37:46 <EvanR> its rare for the ruby documentation to really help
05:37:58 <fro_ozen> is there a reason why there is no MonadExcept typeclass?
05:38:00 <EvanR> in the stdlib, its even wrong
05:38:03 <crocket> What about haskell documentations?
05:38:09 <EvanR> its better
05:38:26 <mauke> crocket: sometimes good, sometimes just a list of symbols and types
05:38:35 <mniip> man, in haskell it's not only possible to deduce what a function does from the type signature
05:39:02 <mniip> but there are also so-called free theorems, that say that such a function cannot do something else
05:39:04 <mauke> there's no common documentation structure or layout
05:39:30 <crocket> Is it possible to write web programs on the client side in haskell?
05:39:34 <mauke> haddock strongly encourages the "long list of exports" style of "documentation"
05:39:42 <crocket> Is it a good idea to do so?
05:39:47 <mauke> crocket: I don't see why not
05:39:51 <mauke> heck, people even do it in C
05:39:59 <crocket> That's not a good idea.
05:40:00 <EvanR> C on the browser?
05:40:07 <exio4> EvanR: emscripten
05:40:20 <mauke> EvanR: no, browsers
05:40:34 <EvanR> ah
05:41:20 <cjeon> Does anyone here recommend Haskell to what level of programming experience?
05:41:34 <mauke> I recommend learning Haskell with 0 experience
05:41:40 <mauke> anything else only makes it unnecessarily hard
05:41:41 <mniip> ^
05:41:55 <callumacrae> Hey! I have a list like [[1], [1,1], [2,2,2], [3], [2,2]] and I'm trying to turn it into [[1,1], [2,2,2], [3]], effectively getting the biggest list of each number
05:41:59 <callumacrae> I have no idea where to start :(
05:42:22 <phaazon> here we go!
05:42:26 <callumacrae> getting I want a filter, but then I don't know what to do about duplicates (e.g. [[3],[3]] -> [[3]])
05:42:27 <phaazon> al released! :)
05:42:37 <phaazon> I hope I’ll have plenty of feedback
05:42:37 <callumacrae> guessing, not getting
05:42:45 <EvanR> callumacrae: you can remove duplicates with nub
05:42:59 <EvanR> > nub [[1], [1], [2,2], [1,1]]
05:43:00 <lambdabot>  [[1],[2,2],[1,1]]
05:43:11 <mauke> I'd probably start by transforming into [(1,1), (1,2), (2,3), (3,1), (2,2)]
05:43:15 <callumacrae> oooh I'm stuck in JS land, [2] == [2] in haskell! wonderful
05:43:25 <mniip> callumacrae, a naive solution would be to length-encode the lists
05:43:40 <mniip> then nub them keeping the longest
05:43:51 <mauke> > sort [(1,1), (1,2), (2,3), (3,1), (2,2)]
05:43:53 <lambdabot>  [(1,1),(1,2),(2,2),(2,3),(3,1)]
05:43:59 <mniip> oh yeah
05:44:07 <mauke> > sort (flip compare) [(1,1), (1,2), (2,3), (3,1), (2,2)]
05:44:09 <lambdabot>  Couldn't match expected type ‘[(t0, t1)] -> t’
05:44:09 <lambdabot>              with actual type ‘[a0]’Couldn't match expected type ‘[a0]’
05:44:09 <lambdabot>              with actual type ‘b0 -> b0 -> GHC.Types.Ordering’
05:44:19 <mauke> :t groupBy
05:44:21 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
05:44:51 <mauke> > (groupBy ((==) `on` fst) . sortBy (flip compare)) [(1,1), (1,2), (2,3), (3,1), (2,2)]
05:44:52 <lambdabot>  [[(3,1)],[(2,3),(2,2)],[(1,2),(1,1)]]
05:45:12 <mauke> > (map head . groupBy ((==) `on` fst) . sortBy (flip compare)) [(1,1), (1,2), (2,3), (3,1), (2,2)]
05:45:13 <lambdabot>  [(3,1),(2,3),(1,2)]
05:45:48 <mauke> > (map head . groupBy ((==) `on` fst) . sortBy (flip compare) . map (fst &&& length)) [[1], [1,1], [2,2,2], [3], [2,2]]
05:45:49 <lambdabot>  Couldn't match type ‘[t0]’ with ‘(b, b0)’
05:45:49 <lambdabot>  Expected type: [t0] -> b
05:45:50 <lambdabot>    Actual type: (b, b0) -> b
05:45:52 * hackagebot al 0.1.0.0 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.0.0 (DimitriSabadie)
05:45:56 <callumacrae> I can turn it into [(1, 2), (1, 1), (3, 1)], then couldn't I just sort it and turn it into a map?
05:46:17 <mauke> if you're using a map, you don't need to sort
05:46:28 <callumacrae> I meant Map.fromList, sorry
05:46:44 <callumacrae> I'm very new to haskell, only just got to that bit in Learn You a Haskell, and I'm working my way through Project Euler
05:47:06 <mauke> > (map (uncurry (flip replicate) . head) . groupBy ((==) `on` fst) . sortBy (flip compare) . map (head &&& length)) [[1], [1,1], [2,2,2], [3], [2,2]]
05:47:08 <lambdabot>  [[3],[2,2,2],[1,1]]
05:47:25 <mniip> I have
05:47:27 <mniip> > map (uncurry replicate) . nubBy (on (==) snd) . sortBy (flip compare) . map ((,) <$> length <*> head) $ [[1], [1,1], [2,2,2], [3], [2,2]]
05:47:28 <lambdabot>  [[2,2,2],[1,1],[3]]
05:47:40 <kristikodare> Anyone knows a beginner friendly tutorial on TypeFamilies/Data families? RWS does not mention them and I don't understand much of haskell.org/GHC/Type_families once they reach GMapKey
05:48:26 <kristikodare> oops Real World Haskell*
05:49:21 <crocket> Am I at a big advantage if my startup uses haskell?
05:49:33 <mauke> > foldl' (\z x -> M.insertWith max (head x) (length x) z) M.empty [[1], [1,1], [2,2,2], [3], [2,2]]
05:49:35 <lambdabot>  fromList [(1,2),(2,3),(3,1)]
05:49:36 <crocket> For web server backends.
05:49:40 <hodapp> crocket: Do you know Haskell?
05:49:44 <EvanR> haskell will make you rich quick
05:49:44 <crocket> hodapp, not yet
05:49:53 <notdan> then no
05:49:59 <mauke> callumacrae: ^ like that?
05:50:01 <btcNeverSleeps> re all... Now I've got a kinda great Emacs + Haskell setup running and I begin to understand sandboxes better etc.  I'm wondering about something else: if I want to install Haskell from scratch, without needing to be root, what do I need to install? (continued)
05:50:02 <crocket> EvanR, You know even the best intelligent man can fail a startup.
05:50:15 <callumacrae> like that! that's great. now I just need to read a million docs so I understand how it works :D
05:50:15 <EvanR> business is largely luck
05:50:17 <hodapp> crocket: *they* might be at a big advantage
05:50:31 <mauke> callumacrae: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Strict.html#v:insertWith
05:50:40 <btcNeverSleeps> I'm asking because to install cabal, I did install Debian's cabal (0.14 ?) and then I used cabal to install a newer cabal.  What if I want to install Cabal from scratch (or from sources)?  What do I need?  GHC?
05:50:45 <crocket> EvanR, Every business strikes a luck once or twice.
05:51:04 <EvanR> even a busted clock is right twice a day
05:51:36 <callumacrae> mauke: ta!
05:51:37 <crocket> It's how to utilize the luck.
05:51:59 <rola> EvanR, how often is a fast or slow clock right everyday?
05:52:10 <EvanR> depends
05:52:43 <Guest34301> crocket, I would say that haskell may help your business scale. But you can create a good product in just about any language or toolset just a matter of time dedication and experience
05:53:19 <hodapp> Guest34301: Does that include the cases where the only way you make a good product is by using a shitty language to implement a real language?
05:53:33 <Guest34301> crocket, what are your specific requirements and most likely use cases?
05:53:49 <crocket> Guest34301, I don't have any specific requirement yet.
05:53:56 <EvanR> its possible to use php for something if you have the discipline
05:54:02 <crocket> Guest34301, But, I want to make a web platform.
05:54:04 <EvanR> without implementing haskell in it
05:54:18 <hodapp> EvanR: That's sort of a truism though. It's possible to use *anything* for something... if you have the discipline.
05:54:27 <hodapp> EvanR: Because if you didn't, then obviously you didn't have the discipline.
05:54:46 <crocket> PHP welcomes bad programming.
05:55:08 <EvanR> hodapp: ok, in a reasonable time span
05:55:20 <EvanR> C webapps and brainfuck as counterexamples
05:55:33 <hodapp> EvanR: If you couldn't do it in a reasonable timespan, then obviously you just didn't have the discipline.
05:55:51 <arw_> all programming languages are roughly the same in that you can implement all possible programs in them
05:55:54 <EvanR> hodapp: no i can imagine having the discpline it just takes too long
05:55:59 <rola> i think a point of the discipline remark is the discipline is not there often. so you get hard to understand, manage, and refactor codebases
05:56:07 <hodapp> arw_: That's not "roughly the same".
05:56:32 <EvanR> rola: or totally derail an entire project
05:56:36 <Guest34301> So my limited experience is as follows. You can have a look at Yesod, or Snap if you want to build a web app
05:56:40 <EvanR> which you can do in haskell
05:56:43 <arw_> the real question is about efficiency, how much effort does programming and maintenance take vs. how much do I get out of it when its done.
05:57:06 <crocket> Haskell encourages you to write easy-to-reason programs.
05:57:07 <u-ou> which language was the matrix written in?
05:57:11 <Guest34301> Scotty is ok but it is intented for small projects
05:57:22 <arw_> hodapp: i meant roughly in the sense that of course there are other differences between languages besides the "i can implement a turing machine"-isomorphism.
05:57:32 <btcNeverSleeps> I wrote an entire Java desktop app + a corresponding Java server / webapp + some JavaScript.  The verboseness of Java is killing me.  I decided "never again": I'd rather go work as a plumber (a friend of mine is a plumber) or as a truck driver (always loved the thought) then do full-time Java development again.  So I learned Clojure and now Haskell :-)
05:57:38 <crocket> For complex programs such as AIs, haskell will be helpful.
05:57:41 <hodapp> arw_: The point is that that 'roughly the same' is damn near useless of a comparison.
05:57:53 <EvanR> btcNeverSleeps: i had the same epiphany
05:57:56 <arw_> hodapp: thats my point.
05:58:04 <CaveJohnson> u-ou: brainfuck
05:58:13 <u-ou> ._____.
05:58:16 <CaveJohnson> :D
05:58:16 <crocket> Fuck brainfuck fuck.
05:58:17 <hodapp> Perl.
05:58:43 <mauke> http://xkcd.com/224/
05:58:45 <EvanR> i have 3+ years experience in brainfuck/perl
05:58:50 <Guest34301> btcNeverSleeps, funny the verbose nature of Java drove me to ruby first. Then I realized that ruby is not all that scalable or efficient
05:58:58 <mniip> brainfuck is meh
05:59:00 <mniip> malbolge
05:59:06 <hodapp> Guest34301: a lot of folks seem to swear by Ruby but I've not touched it since 2003.
05:59:44 <exio4> u-ou: probably some Lisp
05:59:45 <hodapp> I try not to laugh at them when they say it's top-notch for DSLs.
05:59:54 <EvanR> ruby is difficult to write by virtue of nothing being documented in a meaningful way
06:00:01 <EvanR> not to mention reading
06:00:03 <Guest34301> Its ok, it bends over backward to seem friendly. But it scarifies efficiency to do it
06:00:08 <hodapp> EvanR: hrm? I found it quite easy to write in in 2003
06:00:29 <EvanR> hodapp: me too, before i realized how to pay attention to what i was doing i.e. static types
06:00:43 <EvanR> i found it easy to screw up
06:00:45 <epichero_> it all depends on what you are trying to do
06:01:04 <btcNeverSleeps> what is the name of the Haskell webserver / library which has types which enforces escaping on the output that is going to be sent to the client, hence preventing injection-type exploits?
06:01:20 <dredozubov> EvanR: after writing in haskell for a few month(i was writing ruby previously) i started to dislike
06:01:25 <arw_> i've found ruby easy to write for small short-lived stuff. i've found it hell for system administration and maintenance programming because of the frequent incompatible breaking changes in everything.
06:01:36 <dredozubov> it occured to me that it's actually very hard to write and validate correctness
06:01:54 <dredozubov> test-driven culture is god-awful for a lack of better word
06:02:17 <EvanR> i guess i took a "professional hit" in that i couldnt tell a client with a straight face that i guarantee something is correct
06:02:18 <epichero_> closer to a religion than a culture
06:02:18 <dredozubov> you have to write tests that mimics type signatures and such
06:02:21 <EvanR> or will work, or has no problems
06:02:31 <EvanR> ignorance is bliss
06:03:01 <hodapp> dredozubov: Dr. Hickey of Clojure, I believe, said that unit testing is an admission of how completely intractible the underlying code is.
06:03:18 <EvanR> one client described code as "coming loose"
06:03:23 <epichero_> Rich Hickey is insufferable to listen to though
06:03:28 <dredozubov> clojure is having the same problems afaik
06:03:39 <epichero_> he's a smart man who i can't listen to for more than five minutes without wanting to slap his smug face
06:03:47 <EvanR> dredozubov: indeed
06:04:00 <btcNeverSleeps> epichero_: Why? I think the man is great, you have to give hime some credit.
06:04:05 <EvanR> epichero_: you just need to decomplect
06:04:11 <Guest34301> Clojure runs on top of JVM, hence it was not my 1st choice for functional languages
06:04:22 <hodapp> maybe you'll like... SCALA!
06:04:23 <hodapp> oh. wait.
06:04:25 <epichero_> EvanR, you made my slap list
06:04:52 <epichero_> his command of english and ability to communicate is trash and his ability to write documentation is non existent
06:04:56 <dredozubov> oh, now i really want my own slap list
06:05:01 <EvanR> lol
06:05:02 <Clint> see the violence inherent in the system
06:05:11 <arw_> my dictionary doesn't contain 'decomplect'...
06:05:25 <EvanR> its an archaic word, it used to exist
06:05:27 <hodapp> epichero_: I've never found him a particularly bad communicator...
06:05:31 <EvanR> hickey resurrected it, like herbrew
06:05:33 <EvanR> hebrew
06:05:45 <epichero_> because modern hebrew is so close to ancient hebrew
06:06:11 <epichero_> not to mention his usage of complect is stretching it in the first place
06:06:17 <deMoivre> It's a lot closer than modern English is to older forms
06:06:22 <EvanR> class MonadDecomplect
06:06:23 <epichero_> it's not
06:06:32 <btcNeverSleeps> Rich Hickey wrote Clojure and then Datomic, in Clojure.  That is wild.  Datomic seems to be the nuts: for those who don't know, it's an "append-only" DB which you can back with many storage (Riak, SQL, what have you).
06:06:40 <deMoivre> Because they pretty much took ancient Hebrew and imposed some modern vocabulary on top of it
06:06:55 <EvanR> datomic is difficult to use for many reasons
06:07:11 <EvanR> and scales badly in several situations
06:07:12 <hodapp> epichero_: I found his communication in "Simple Made Easy" and "The Value of Values" to be pretty clear and concise, really.
06:07:14 <epichero_> deMoivre, no that's... it's too late for me to get into an internet argument over ancient hebrew
06:07:22 <btcNeverSleeps> And then using macros made ClojureScript + core.async possible: yeak, fake "concurrency" in JavaScript for free.  That is pretty sweet too.
06:08:01 <EvanR> clojure is making the most it can with java heavy weight threads
06:08:18 <epichero_> I like his code i guess, and i do like clojure a good deal i just don't like him
06:08:31 <EvanR> when people mention concurrent clojure, they are thinking you can run like 3 threads
06:08:38 <EvanR> any more is too many
06:08:53 <EvanR> you need a pool to make sure you dont use more than 3 threads
06:09:18 <deMoivre> epichero_: Do you think Hickey is wrong in his philosophy?
06:09:22 <deMoivre> Or what he advocates
06:09:31 <epichero_> not in the large at all
06:09:51 <deMoivre> I've probably listened to 4 or 5 of his talks by this point
06:09:55 <deMoivre> He's arrogant, yeah
06:10:02 <EvanR> so haskell
06:10:02 <deMoivre> but it strikes me as the kind of arrogance that is earned
06:10:18 <epichero_> i don't respect him as a person despite respecting his programming work
06:10:18 <deMoivre> or has been earned, rather
06:10:59 <deMoivre> Most of what he says applies more to functional vs. imperative paradigms than it does to Clojure vs. anything else
06:11:21 <deMoivre> I've had more success understanding Haskell and coding things that work correctly in it than I have with Clojure
06:11:22 <EvanR> clojure has its own brand of functional though
06:11:31 <deMoivre> but I got the functional programming bug largely from Hickey
06:11:59 <epichero_> I'm just starting out with haskell, i've done a bit of ocaml before but nothing complicated.
06:12:02 <Guest34301> What is the best way to search using persistence-mongodb using a query as a JSON object? Basically I would like to use a JS frontend framework and treat Haskell server as a JSON api.
06:12:13 <deMoivre> epichero_: I haven't done anything complicated in any of these
06:12:34 <deMoivre> I've done some basic stuff in (Chicken) Scheme, Clojure, Haskell, and OCaml
06:12:45 <btcNeverSleeps> I don't think Rich Hickey is arrogant: he's an ex- professional Java dev who has seen all that was wrong with traditional "enterprisey" Java development and wanted something better.  To me Datomic is the nuts: I can't count the number of times I couldn't "recreate the state the application was in" and had to ask the DB guy to dump me in dev the DB "as of that date".
06:13:34 <deMoivre> I've had a difficult and strange career, trying to specialize in core Java
06:13:36 <btcNeverSleeps> just to recreate a freakin' bug a user had.  With Datomic it comes for free: you can query (on the prod DB if you wish) "as of" a specific time.  As if the DB was precisely at that point in time.  This is huge.
06:13:44 <deMoivre> I.e., REFUSING to touch anything made with J2EE
06:13:54 <epichero_> ah yeah
06:14:00 <deMoivre> btcNeverSleeps: I can imagine.
06:14:04 <EvanR> btcNeverSleeps: you can, but you have to write an entire program to do that
06:14:11 <deMoivre> btcNeverSleeps: It's exactly that sort of thing that attracts me to all this functional stuff =)
06:14:17 <EvanR> theres nothing like postgresql console
06:14:20 <deMoivre> That and the fact that I'm trained in classical mathematics
06:14:28 <deMoivre> or classically trained in mathematics?
06:14:28 <EvanR> and the web front end is awful
06:14:32 <deMoivre> something like that
06:14:34 <btcNeverSleeps> EvanR: you can back Datomic with PostgreSQL
06:14:57 <EvanR> ... but then you are looking at an alien artifact instead of a relational database
06:15:05 <arw_> btcNeverSleeps: yes, but database frontends are often more trouble.
06:15:06 <EvanR> thats not a serious strategy
06:15:17 <deMoivre> Sounds like Datomic:PostgreSQL::Clojure:Java, sort of
06:15:27 <deMoivre> or ::ChickenScheme:C
06:15:38 <EvanR> bad comparison
06:15:47 <deMoivre> EvanR: I don't think so.
06:15:56 <EvanR> just no
06:16:07 <btcNeverSleeps> At a guesstimate: 99.9% of the DB out there could be replaced by "append-only" DBs, and then you effectively get "The Database as a value".  What is the point in coding in Haskell if you then have irreproducible state in your DB?
06:16:11 <deMoivre> They're both instances of implementing something correct through a pragmatic mechanism that wasn't built for that
06:16:23 <EvanR> datomic is difficult to use, postgres is easy to use, clojure is hard to use, java is hard to use
06:16:27 <deMoivre> PostgreSQL and C both allow you to shoot yourself in the foot, re: time
06:16:31 <EvanR> its not adding up
06:16:37 <deMoivre> I'm not talking about experience of using these things
06:16:41 <deMoivre> I'm talking about abstract concepts
06:16:47 <epichero_> TitanDB is my current favorite DB
06:16:55 <EvanR> with databases, your experience using the thing is a huge part of it
06:17:11 <EvanR> it doesnt matter how perfect a model is if you cant easily interact with it
06:17:21 <deMoivre> Yet here you are, in #haskell
06:17:29 <EvanR> ?
06:18:04 <deMoivre> Haskell is generally regarded as a hardcore purist's language
06:18:05 <EvanR> you dont interact with haskell through a poorly documented set of 5 api calls through lisp
06:18:25 <deMoivre> (Funny...I was just reading this: http://clemens.endorphin.org/ILC07-Liskell-draft.pdf )
06:18:46 <btcNeverSleeps> EvanR: that Datomic is written in Clojure is not the point.
06:19:15 <EvanR> the point is it has no good dba interface
06:19:17 <benneh> can someone please explain to me the difference between these two: http://lpaste.net/121334 http://lpaste.net/121335; the first works as intended, but the second causes an infinite <<loop>>, and don't understand why they aren't exactly the same
06:19:28 <btcNeverSleeps> it's the concept of an "append-only" DB, which you can query "as-of", which makes sense from a "functional" point of view
06:19:43 <EvanR> thats fine, the issues with that are an independent conversation
06:20:01 <EvanR> if datomic had nice tools, that would be a different story
06:20:11 <EvanR> then all its other issues could be discussed
06:20:23 <btcNeverSleeps> EvanR: how I'd love the Haskell equivalent of Datomic ^ ^
06:20:27 <btcNeverSleeps> /s/how/oh/
06:20:33 <epichero_> then create it
06:20:43 <EvanR> uh, you mean datomic but it happens to be implemented in haskell?
06:20:47 <epichero_> you seem to have all these opinions on it
06:20:48 <EvanR> it would suck just as much
06:20:56 <btcNeverSleeps> epichero_: my Java is good, my Clojure is ok, my Haskell is... "beginner" : )
06:21:34 <btcNeverSleeps> epichero_: it's not an opinion that a DB which you can query "as of" a certain in time is a godsend to devs worldwide.
06:21:40 <epichero_> you keep saying all these things like you actually know exactly what you want
06:21:54 <epichero_> and if you really know what you want in such detail you can create it
06:21:58 <funfunctor> hi
06:22:00 <nshepperd> well, if pseudoglobal mutable state has a place, databases has got to be it
06:22:01 <mauke> benneh: does anything change if you make swap lazy?
06:22:12 <mauke> benneh: swap ~(a, b) = (b, a)
06:22:16 <btcNeverSleeps> epichero_: me?  My Haskell is not good enough to undertake such a project.
06:22:35 <funfunctor> has anyone used cereal or similar that can give advice on parsing binary data?
06:23:10 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121338
06:23:11 <dredozubov> funfunctor: you probably want binary library
06:23:30 <funfunctor> dredozubov: for a test I want to try and parse that?
06:23:44 <benneh> mauke: yes, that fixes it, thanks!
06:24:11 <benneh> why is swap not lazy by default? I thought all haskell functions were, unless you specifically make them strict
06:24:11 <btcNeverSleeps> nshepperd: what does a CRUD DB offer that a CRA (Create Read Append-only) couldn't? (for the 99.9% of DB which have no space issue)
06:24:14 <dredozubov> funfunctor: https://hackage.haskell.org/package/binary-0.7.4.0/docs/Data-Binary.html it's documented pretty well
06:24:27 <epichero_> btcNeverSleeps http://pagesperso-systeme.lip6.fr/Marc.Shapiro/papers/RR-6956.pdf was a good read
06:24:31 <EvanR> first you have your nice theoretical data, which is kind of hard in datomic since they have an interested choice of primitive data types, then you need to have high performance, which despite all the work put into database, its still lacking, and then you need a nice way for the programmer or administrator to interactive with the data and the database management system, which doesnt exist in datomic
06:24:34 <epichero_> it's a narrower concept
06:24:59 <EvanR> btcNeverSleeps: a much easier to use interface
06:25:00 <btcNeverSleeps> EvanR: I'm not talking about Datomic specifically, I'm talking about the concept of a Create Read Append-only DB.
06:25:39 <epichero_> and for clojure there is distributed CRDT displayed in https://github.com/maxcountryman/quanta
06:25:40 <EvanR> btcNeverSleeps: if you want to talk about the practicality of that sort of database in general, then you have to consider that accumulating all history ever takes a toll on space and time costs
06:25:52 <btcNeverSleeps> But you still end up with my scenario, which is the daily life of an insane number of devs: "Helpdesk: dev, user contacted us reporting bug XXX at time YYY, here's the screenshot"... (continued)
06:26:00 <funfunctor> dredozubov: do you happen to have some example code to kick start me?
06:26:01 <epichero_> it's small enough you could try porting something like that to haskell
06:26:12 <mauke> benneh: https://www.haskell.org/tutorial/patterns.html#sect4.4
06:26:24 <btcNeverSleeps> "dev (me): contacting DB team: DB admin, I cannot reproduce bug YYY, can you dump me in DEV the DB at time XXX"
06:26:33 <EvanR> btcNeverSleeps: yeah, setting it up in postgres to give you want to you need to debug it is also pretty easy
06:26:48 <EvanR> btcNeverSleeps: with the upshot that you are using postgres
06:27:19 <arw_> btcNeverSleeps: the general concept is kind of nice except where it isn't. you want a database that retains some history, but you don't want a history on everything in certain cases.
06:27:22 <dredozubov> funfunctor: https://wiki.haskell.org/Dealing_with_binary_data first link in google result page
06:27:55 <funfunctor> dredozubov: yea I saw that but still a little overwhelmed
06:28:03 <btcNeverSleeps> arw_: you mean confidential data accidentely commited to the DB which must be, due to legal requests, expurged?
06:28:08 <arw_> btcNeverSleeps: e.g. imagine a system maintaing bank accounts. of course you want to retain the transaction history of all accounts, but only up to a certain point.
06:28:12 <funfunctor> can one encapsulate the structure into a type?
06:28:14 <arw_> btcNeverSleeps: exactly
06:28:53 <EvanR> arw_: datomic explains this away by saying its rare and gives you the option of totally deleting records on a case by case basis, strongly discourages you from doing this
06:28:59 <btcNeverSleeps> arw_: well, in Datomic you can expurge old data when really needed.  And I didn't say a CRA DB could replace a CRUD DB in every single case.  I still think it's a godsend in many many cases.
06:29:12 <dredozubov> funfunctor: have you tried reading documentation?
06:29:49 <dredozubov> you have to define Binary instances for your types and here you go
06:30:43 <funfunctor> dredozubov: yes I can see how it does it for a expression parser but not how bit/byte level fields would be done
06:30:47 <arw_> EvanR: maybe its less of a problem in the US. but over here in germany, there are strict regulations like "keep the history of this dataset for 5 years. delete the history that is older than 5 years.".
06:30:59 <nshepperd> anyway, I used the haskell foreign function interface today. I'm kind of in awe at how nice and usable it is
06:31:17 <arw_> EvanR: so you have to go over your application with a lawyer and assign data lifetimes and stuff.
06:31:38 <btcNeverSleeps> functional languages, Git, Nix OS / package / manager, CRA DB... To me the idea of always being able to reproduce the exact state of "things" is something that is going to stay.  And even if they're not perfect, I do hope there's going to be more on CRA DBs.
06:31:39 <arw_> EvanR: thats neither rare nor as simple as 'just delete the whole object'
06:31:48 <epichero_> arw_ if you ever want to have a mental breakdown go over the data policies for medical data in the united states
06:31:52 <dredozubov> funfunctor: look in Data.Binary.Put and Data.Binary.Get modules
06:31:58 <benneh> mauke: thanks, that makes sense; do you know what the reasoning is behind the decision to not just make all patterns lazy?
06:32:40 <epichero_> reversion control, functional languages, CRA DB, none of these are at all new ideas
06:32:46 <EvanR> arw_: accumulating everything by default now only takes up a ridiculous amount of space, for a real workload, but it also makes it difficult to take subsets for offline work
06:32:51 <EvanR> like testing
06:33:02 <btcNeverSleeps> epichero_: no, certainly not new, but they're only really catching up since recently.
06:33:12 <mauke> benneh: because then they would be useless: "Lazy patterns are irrefutable: matching a value v against ~pat always succeeds, regardless of pat."
06:33:25 <mauke> benneh: normally we use patterns to decide between several alternatives
06:33:29 <btcNeverSleeps> (btw last big gig the VCS was still... Wait for it: CVS)  fml :(
06:33:45 <EvanR> btcNeverSleeps: the reason is that its difficult to make this kind of super accumulating database efficient, and datomic is no exception
06:34:23 <EvanR> each new database that comes out claims to be more efficient than the last
06:34:41 <EvanR> and then real projects use it, and have annecdotal evidence at best
06:34:49 <epichero_> CVS is still better than "oh yeah drop the files in ftp when ur done for the day"
06:35:06 <btcNeverSleeps> EvanR: well yes but Moore's law... Most DBs out there are tiny, really tiny compared to today's machine. You can, say, serve insane trafic with a very modest architecture nowadays (like StackOverflow: it's really small hardware they have compared to what they do).
06:35:54 * hackagebot al 0.1.0.1 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.0.1 (DimitriSabadie)
06:35:58 <funfunctor> ah thx!
06:36:41 <EvanR> btcNeverSleeps: yes, postgres ;)
06:38:37 <benneh> mauke: oh yeah, good point; but surely, in this case, everything will match the pattern "(a, b)" anyway, so what is actually happening differently here?
06:38:58 <mauke> benneh: not everything
06:39:04 <mauke> for example, _|_
06:39:16 <arw_> btcNeverSleeps: you can serve insane amounts of traffic, yes. but often people will just have those performance advantages eaten up by more layers and less efficient querying.
06:40:39 <EvanR> relational databases are popular to dismiss as old tech
06:40:41 <btcNeverSleeps> arw_: sure but today there are a lot of DBs which have zero performance issue due to their size being already tiny compared to today's hardware.  And tomorrow more than that, because for many use cases, the user base and user needs grow way slower than hardware.
06:41:20 <EvanR> people think newer stuff is faster, it isnt, and then in the process transactions and data modeling get thrown under the bus
06:41:52 <epichero_> EvanR, it depends what you are trying to do. Almost all of the people thinking that are working on things that will never see improvements
06:42:00 <epichero_> and likely get less performance
06:42:03 <epichero_> or equal
06:42:15 <benneh> mauke: ok, I think I get it now; thanks for the help
06:42:22 <EvanR> btcNeverSleeps: concentrating on situations where you dont have a huge amount of data, this means you really want to concentrating it being easy to use and hard to screw up
06:42:28 <hpc> not to mention the stuff people get to replace it is sometimes not even meant for data storage
06:42:41 <hpc> like redis, which is primarily a ram-based string store
06:42:44 <epichero_> redis
06:42:45 <epichero_> yeah
06:42:59 <hpc> just because you /can/ dump it to memory, doesn't mean you always should
06:43:04 <epichero_> exactly
06:43:11 <EvanR> memcache
06:43:33 <hpc> memcache can't be dumped that i know of
06:43:37 <epichero_> they are great when used properly but when you start just dumping everything there and going far beyond good practices
06:43:45 <epichero_> someone has found a way hpc
06:43:49 <hpc> redis is fairly popular in the email world because who cares if you lose the last 5 minutes of training
06:44:16 <hpc> which i can get behind, because they actually know what they're getting into
06:44:49 <btcNeverSleeps> EvanR: anyway... So you're an ex-Java dev: how long did it take you before becoming proficient in Haskell?  (I'm already quite ok with Clojure, using Clojure daily since quite a while: obviously Haskell and Clojure are not related but I'm familiar with lazyness/non-strictness and functional programming, for example)
06:46:08 <EvanR> btcNeverSleeps: haskell took years of practice. clojure took a few weeks of getting vim to work, but my ability to do anything in clojure quickly plateaued
06:46:33 <EvanR> that is to say i wasnt happy with what i could achieve with it
06:47:09 <EvanR> a lot of it is java's fault, the rest is lisps fault
06:49:53 <EvanR> btcNeverSleeps: you should be warned that haskell lazy evaluation is very different from clojures "lazy sequence" implementation detail / source of problems
06:50:58 <btcNeverSleeps> EvanR: thankfully I'm not starting Haskell from scratch (geez, a few years to get proficient is kinda a lot) : )
06:51:43 <EvanR> its very deep
06:52:02 <EvanR> but you dont have to go very deep to be proficient enough to use it for common stuff
06:52:26 <btcNeverSleeps> but is it possible to do useful things in Haskell (write small utilities, write a simple webapp) without going very deep into the rabbit hole?
06:52:27 <btcNeverSleeps> erf
06:52:39 <EvanR> yes
06:53:15 <EvanR> you can use haskell to replace shell scripts for example
06:53:26 <shourya> Anyone willing to help in design?
06:53:32 <btcNeverSleeps> if anyone knows the nick of the #haskell person here who wrote in Haskell a webapp for runners / people organizing runners events in the U.S., could you PM me its nick or the name of its site? (I lost it)
06:53:40 <btcNeverSleeps> EV
06:53:49 <btcNeverSleeps> EvanR: turtle or conduit?
06:54:17 <EvanR> just writing the steps youd do in the shell directly is often much more pleasant than doing it in a shell language
06:54:19 <btcNeverSleeps> My Bash shell script have been getting bigger and bigger lately and I'm considering trying to write one in Haskell
06:54:39 <EvanR> you dont even have to get into DSLs
06:54:43 <shourya> Where do you learn Haskell from?
06:55:25 <btcNeverSleeps> also: if I write a "shell script" in Haskell, can I then create an executable that I could put on a Raspberry? (to avoid having to install the whole GHC / Cabal thing on the Raspberry)
06:55:36 <EvanR> probably not
06:56:19 <epichero_> btcNeverSleeps, not easily or in a way that would be worth it
06:57:05 <btcNeverSleeps> shourya: this one really "talked" to me, but YMMV: http://www.seas.upenn.edu/~cis194/lectures.html
06:57:26 <shourya> Thanks!
06:58:40 <rola> btcNeverSleeps, if you are referring to brent yorgey's lectures, they are now here http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
06:58:44 <EvanR> an interesting avenue for haskell, agda, idris ... for embedded systems is to write the program in a library which is designed to output programs that can run on the system with alternate cpu and limited resources, in a type safe way
06:59:07 <EvanR> rather than run haskell directly
06:59:12 <btcNeverSleeps> rola: I guess so, it was a while ago
06:59:42 <exio4> btcNeverSleeps: about learning Haskell, and depending on your background, you may start "feeling productive" (compared to other languages) in "just" 6 or 9 months :P
06:59:58 <EvanR> for only 6 easy payments of 19.95
07:00:25 <exio4> shourya: you may find https://github.com/bitemyapp/learnhaskell useful (it also recommends that course)
07:00:39 <shourya> Thanks!
07:00:51 <shourya> You guys are really helpful!
07:01:02 <shourya> exio4: thanks!
07:01:18 <shourya> btcNeverSleeps: Thanks!
07:01:49 <btcNeverSleeps> shourya: see user rola's updated link: www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
07:02:57 <btcNeverSleeps> exio4: "6 to 9 months" is ok, plus I've already started with Haskell some time ago, so a few things already "sank" in.
07:03:19 <btcNeverSleeps> I haven't done much yet but, hey, I've already written a (Texas Hold'em) poker-hand evaluator in Haskell ^ ^
07:03:38 <EvanR> to tell you what move to make?
07:03:40 <shourya> btcNeverSleeps: What can you use Haskell for?
07:04:31 <exio4> for everything! it's a general purpose language
07:06:01 <btcNeverSleeps> shourya: I'm just a beginner, don't ask me ;)
07:06:15 <shourya> exio4: Could you give me a few examples?
07:06:23 <shourya> btcNeverSleeps: oh wow!
07:06:30 <EvanR> shourya: im writing a midi sequencer
07:06:49 <shourya> EvanR: Oh! Cool!
07:08:15 <shourya> All of ya'll here are really helpful and friendly. All the other channels are utter BS.
07:08:25 <EvanR> lol
07:09:49 <exio4> shourya: there are lots of people who are writing web apps with Haskell, there are lots of good frameworks for that, you can also interact with databases relatively easy (HaskellDB, persistent/esqueleto), you can write compilers with it, there is/are also window managers for X11 written in Haskell! :P
07:10:40 <EvanR> shourya: 3d graphics, audio stuff
07:10:45 <shourya> exio4: Cool! How long did it take you to learn Haskell?
07:10:50 <EvanR> #haskell-game is a channel about game programming
07:12:57 <exio4> shourya: still learning it! and I think I've been writing Haskell for 8~10 months from now? not so much
07:13:27 <nerium> I'm trying to run the "system" function inside a function with returns IO () and I'm getting this error
07:13:27 <nerium>   Expected type: IO ()
07:13:28 <nerium>    Actual type: IO GHC.IO.Exception.ExitCode
07:13:29 <nerium> What could I do?
07:14:46 <mauke> nerium: what do you want to do with the exit code?
07:14:55 <nerium> mauke: Nothing
07:15:01 <nerium> Just throw it away
07:15:06 <mauke> do ... system "blah"; return ()
07:15:19 <exio4> you could (also) use void from Control.Monad
07:15:30 <nerium> mauke: Super! Thanks
07:15:34 <EvanR> i wish void was called something else
07:15:51 <nerium> exio4: How?
07:15:59 <exio4> EvanR: I tend to use (() <$) or ($> ()) :P
07:16:07 <EvanR> void :: Void -> a
07:16:34 <exio4> nerium: void something :P
07:16:38 <exio4> @type void
07:16:39 <cariveri> Hi. do you know a simple way to create a haskell based webserver? I just need to produce a simple html from it that can also include js/css .
07:16:39 <lambdabot> Functor f => f a -> f ()
07:16:41 <EvanR> nerium: void :: IO a -> IO ()
07:17:04 <exio4> it's the same as "void x = do { x; return () }"
07:17:33 <dropp> hello
07:18:26 <dropp> could anyone help me with type system question?
07:18:42 <nerium> aha
07:18:48 <nerium> That i didin't know
07:18:49 <nerium> Thanks
07:19:16 <geekosaur> dropp, it works better to just ask your question
07:20:02 <dropp> :-) thanks, i'll post a gist for more clarity.
07:20:12 <nshepperd> 'absurd' isn't an acceptable name for Void eliminator?
07:20:57 <EvanR> yeah
07:21:05 <EvanR> in idris though absurd is something else
07:22:15 <EvanR> absurd :: Uninhabited t => t -> a
07:22:21 <dropp> https://gist.github.com/drippdropp/06efe7e3a3680c605f40
07:22:45 <dropp> first of all, be gentle, i'm a beginner, it's probably bad haskell code, but i'm learning
07:22:57 <dropp> i'm having problems with the applyToPacked function
07:23:02 <dropp> the type check fails
07:23:17 <dropp> because of the `f` function
07:23:32 <mauke> dropp: what's the error message?
07:24:29 <nshepperd> EvanR: oh, that seems reasonable
07:24:56 <dropp> mauke: i updated the gist with the error message
07:25:33 <nshepperd> so it still works as a Void eliminator, but generalized?
07:25:35 <geekosaur> so one thing that occurs to me is you declare applyToPacked to return `a` but your code produces `[Maybe a]` via packList
07:25:59 <EvanR> nshepperd: yeah, https://github.com/idris-lang/Idris-dev/blob/master/libs/prelude/Prelude/Uninhabited.idr
07:26:15 <dropp> oh, that was a recent update, yes, you're totally right. let me fix and update and see how that fairs
07:26:27 <geekosaur> and packList says it produces `Maybe a` but it computes a `[Maybe a]`
07:27:09 <dropp> geekosaur: should that be :: a -> Maybe a -> [Maybe a]?
07:27:26 <dropp> or :: [Maybe a] -> [Maybe a]
07:27:38 <geekosaur> which?
07:27:54 <dropp> yes, if not neither
07:28:04 <geekosaur> ...
07:28:22 <geekosaur> were you talking about the wrong type in applyToPacked or the one in packList?
07:28:29 <dropp> [a] -> [Maybe a]
07:29:16 <dropp> i'm being confusing. i apologize! i was originally having issues with applyToPacked and then I added packList after the fact, and generated more issues, so ultimately both. sorry about that.
07:29:37 <dropp> i'm trying to learn about interacting with Maybe values
07:29:48 <dropp> extracting, manipulating, and re-packing them
07:29:55 <geekosaur> your problem isn't interacting with Maybe. it's interacting with lists :)
07:29:59 <dropp> lol
07:30:09 <mniip> instance Functor List where fmap _ _ = Empty
07:30:12 <mniip> well played djinn
07:30:12 <geekosaur> applied produces a list. you then send that to packList which claims to operate on values
07:30:51 <dropp> packList should be:: [a] -> [Maybe a]
07:30:52 <dropp> correct?
07:31:12 <geekosaur> yes
07:31:39 <geekosaur> and then there is one more obvious issue, with the result type of applyToPacked
07:32:16 <dropp> geek: I updated https://gist.github.com/drippdropp/06efe7e3a3680c605f40
07:32:39 <dropp> this is my original problem
07:33:09 <geekosaur> ok, so look at the type of the function you pass to applyToPacked
07:33:19 <geekosaur> you have (f -> a) with no indication of what f is
07:33:42 <geekosaur> the actual code really wants something of type (a -> a)
07:33:50 <dropp> ooooooh
07:34:05 <dropp> so, the _ -> _ is the function
07:34:08 <dropp> the pattern itself
07:34:22 <dropp> i don't need to have a different "type", a la `f` for the function
07:34:26 <dropp> but a -> a would express that
07:34:28 <dropp> ?
07:34:34 <geekosaur> -> is the function arrow
07:34:50 <geekosaur> so (_ -> _) is the type of a function
07:34:54 <dropp> i've been thinking of the -> as "becomes"
07:34:55 <fr33domlover> Is there a restriction on the license of software uploaded to Hackage?
07:35:05 <fr33domlover> e.g. is proprietary software allowed?
07:35:06 <geekosaur> well, it is "becomes"
07:35:10 <geekosaur> a becomes a
07:35:16 <dropp> gotcha
07:35:19 <geekosaur> or "takes an a, produces an a"
07:35:22 <dropp> thank you very much!!
07:35:34 <dropp> voila! works
07:35:42 <geekosaur> likewise a -> a -> a takes two a-s and produces an a
07:35:48 <dropp> well, so
07:35:59 <dropp> i understand that
07:36:07 <dropp> but i was gettign confused with passing a function as a param
07:36:48 <dropp> let func a b = a + b would be:: func :: (Num a) => a -> a -> a
07:36:52 <dropp> but if i did it with a function
07:36:55 <dropp> as a param
07:37:01 <geekosaur> :t map
07:37:02 <lambdabot> (a -> b) -> [a] -> [b]
07:37:08 <dropp> like func f a = f a, i'm not sure of that
07:37:27 <mauke> :t let func f a = f a in func
07:37:28 <lambdabot> (t1 -> t) -> t1 -> t
07:37:28 <dropp> func :: (Num a) => (a -> a) -> a -> a ?
07:37:29 <geekosaur> "given a function from a to b and a list of a, produce a list of b"
07:37:40 <mauke> dropp: you don't need the Num constraint here
07:37:47 <mauke> and the return type can be different
07:38:35 <dropp> let doTwice f a = f a
07:38:39 <dropp> what's that type?
07:38:58 <dropp> doTwice :: (t1 -> t) -> t1 -> t
07:39:06 <dropp> i don't understand why the t1 is needed?
07:39:14 <dropp> ? = .
07:39:16 <mauke> ... needed?
07:39:20 <geekosaur> because you haven't said what f does
07:39:31 <geekosaur> f is allowed to take some type and produce some other type
07:39:34 <geekosaur> :t fromInteger
07:39:36 <lambdabot> Num a => Integer -> a
07:39:36 <dropp> gotcha
07:39:43 <dropp> could be Int, could be Integer, could be Double
07:39:50 <dropp> could be Char
07:39:54 <dropp> could be anything
07:39:55 <dropp> gotcha
07:40:07 <EvanR> could be Int -> Bool
07:40:17 <dropp> i follow
07:41:38 <dropp> nice, so my applyToPacked works great:::  applyToPacked (+1) [Just 1, Just 2, Just 3]  ->  [Just 2, Just 3, Just 4]
07:42:05 <dropp> one more question if you guys don't mind :-)
07:42:17 <dropp> if you look at what i just wrote above, with the applyToPacked input and output
07:42:31 <dropp> that's the same as a functor?
07:42:36 <dropp> or applicative
07:42:44 <dropp> did i re-invent the wheel?
07:42:51 <mauke> > fmap (fmap (+1)) [Just 1, Just 2, Just 3]
07:42:53 <lambdabot>  [Just 2,Just 3,Just 4]
07:43:01 <mauke> [] is a Functor, and so is Maybe
07:43:26 <dropp> :t fmap
07:43:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:43:34 <mauke> > (fmap . fmap) (+1) [Just 1, Just 2, Just 3]
07:43:36 <lambdabot>  [Just 2,Just 3,Just 4]
07:43:51 <dropp> why do you need to compose fmap with itself?
07:43:54 <mauke> ((->) e) is also a Functor
07:44:00 <mauke> > fmap fmap fmap (+1) [Just 1, Just 2, Just 3]
07:44:02 <lambdabot>  [Just 2,Just 3,Just 4]
07:44:08 <mauke> now the code is perfectly obfuscated
07:44:13 <geekosaur> heh
07:44:13 <dropp> fmap (+1) [Just 1]
07:44:18 <mauke> dropp: because I need to "map" 2 layers deep
07:44:33 <dropp> (fmap . fmap) (+1) [Just 1]
07:44:41 <geekosaur> the first fmap goes inside the list to the Maybe, the second goes inside the Maybe
07:44:42 <EvanR> fix (fmap .)
07:44:50 <mauke> dropp: 1 <- normal data. Just 1 <- wrapped data. [Just 1] <- double wrapped data
07:45:07 <dropp> ooooh okay
07:45:09 <dropp> gotcha
07:45:09 <mniip> let me guess
07:45:24 <mniip> djinn cannot not only into recursive types, but also into recursive functions
07:46:17 <geekosaur> mniip, djinn manipulates types, so the only way it could use a recursive function is with a recursive type
07:46:45 <dropp> what is djinn?
07:46:54 <geekosaur> @help djinn
07:46:55 <lambdabot> djinn <type>.
07:46:55 <lambdabot> Generates Haskell code from a type.
07:46:55 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
07:47:08 <dropp> lambdabot is so cool
07:47:18 <mauke> @djinn (a -> b) -> Maybe a -> b -> b
07:47:18 <lambdabot> f a b c =
07:47:18 <lambdabot>     case b of
07:47:18 <lambdabot>     Nothing -> c
07:47:18 <lambdabot>     Just d -> a d
07:47:20 <geekosaur> dropp: given a type, you can often infer the simplest code that expresses that type
07:47:23 <geekosaur> see for example:
07:47:26 <geekosaur> :t map
07:47:27 <lambdabot> (a -> b) -> [a] -> [b]
07:47:42 <mauke> map _ _ = []  -- simplest code
07:47:56 <geekosaur> given that type, there is an obvious implementation that uses all elements of the type
07:48:04 <EvanR> @djinn Int -> Bool
07:48:04 <lambdabot> Error: Undefined type Int
07:48:17 <dropp> ok
07:48:24 <mniip> geekosaur, I just made djinn undestand the recursion in the list type
07:48:44 <dropp> :t fmap
07:48:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:48:45 <mniip> it turns out djinn doesn't understand how to use recursion to generate the values of the list type
07:48:45 <dropp> :t map
07:48:46 <lambdabot> (a -> b) -> [a] -> [b]
07:48:51 <breadmonster> Hey, guys, what exactly does --| indicate in a comment?
07:48:57 <breadmonster> At the start of a comment that is.
07:48:58 <dropp> :t (<$>)
07:48:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:49:02 <mauke> > (--|)
07:49:04 <lambdabot>  Not in scope: ‘--|’
07:49:08 <mauke> breadmonster: that it's not a comment
07:49:11 <EvanR> breadmonster: haddock
07:49:12 <geekosaur> breadmonster, `-- |` is Haddock markup
07:49:14 <mauke> it's an operator
07:49:16 <geekosaur> (with the space)
07:49:29 <geekosaur> thinkdoxygen / javadoc
07:49:47 <breadmonster> Oh okay, cool.
07:50:03 <EvanR> haddoxyjavadoc
07:50:33 <dropp> (Just (+1)) <*> Just 3
07:50:42 <dropp> if I wanted to change Just 3 to [Just 3]
07:50:51 <dropp> and i want to iterate over it
07:50:55 <dropp> with Just (+1)
07:51:00 <dropp> how?
07:51:33 <geekosaur> `Just (+1)` seems somewhat confused
07:51:42 <mauke> > map (Just (+1) <*>) [Just 3]
07:51:44 <lambdabot>  [Just 4]
07:51:51 <dropp> nice!
07:52:09 <EvanR> pure (+1)
07:52:10 <dropp> it wrapping a function in a Maybe seem unnecessary?
07:52:14 <EvanR> or (+1) <$>
07:52:32 <ReinH> > map (map (+1) [Just 3]
07:52:33 <lambdabot>  <hint>:1:23:
07:52:33 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:52:35 <geekosaur> (not saying it isn't doable but I feel like you were reaching for Just . (+1), which is what the Applicative gives you unless you actually intended the function to be optional there
07:52:36 <ReinH> > map (map (+1)) [Just 3]
07:52:37 <lambdabot>  Couldn't match expected type ‘[b]’
07:52:37 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
07:52:50 <ReinH> > fmap (fmap (+1)) [Just 3]
07:52:51 <lambdabot>  [Just 4]
07:52:58 <ReinH> I wish map = fmap :(
07:53:01 <dropp> "reaching for" ? intending to?
07:53:26 <EvanR> right after FTL is over ;)
07:53:53 <geekosaur> sort of?
07:54:39 * geekosaur is now failing at a non-circular explanaton of what he meant... sigh
07:55:31 <ReinH> geekosaur: heh
07:55:36 <geekosaur> `Just (+1)` means the function (+1) is optional (that is, you may pass Nothing if there is no function instead of Just (+1)).
07:55:58 <geekosaur> but I feel like you intended to wrap the *result* in a Just, not the function itself; that would be (Just . (+1))
07:55:59 <dropp> i see, so it's rather a pointless thing to do :-)
07:56:07 <ReinH> If it's never Nothing, there's no point in making it a Just
07:56:12 <dropp> lol
07:56:13 <EvanR> dropp: Just (+1) <*> Just 3 is the same as (+1) <$> Just 3 which is the same as fmap (+1) (Just 3)
07:56:25 <geekosaur> so you were groping for a concept (function composition) but got something else instead
07:56:28 <dropp> oh my, i love haskell. so cool!
07:56:43 <dropp> it is so powerful
07:56:50 <dropp> and hidden in mysterious notation :-)
07:57:04 <EvanR> dark secrets waiting to be unlocked
07:57:08 <dropp> indeed!
07:57:51 <dropp> i have been coding with c++, java, ruby, etc. for almost 15 years, and when i started learninng haskell, i felt like i was in coding kindergarten
07:58:05 <EvanR> because it was so easy?
07:58:16 <dropp> no, because i needed to relearn many concepts
07:58:23 <EvanR> or because it was difficult
07:58:26 <EvanR> oh
07:58:33 <dropp> not particularly easy or difficult, just different
07:58:42 <Hafydd> Mysterious notation, such as f :: a -> b?
07:59:20 <dropp> but while i mastered ruby, for example, in about 2-3 months, i've been toying with haskell for 2-3 months nad haven[t really scratched the surface i feel like, but time is not as plentiful as it once was
07:59:30 <dropp> Hafydd: it was a joke, but sure.
07:59:46 <dropp> i was referring more so to the beautiful <*> and <$> and .: and .:?
07:59:50 <dropp> and other awesomeness
08:00:47 <dropp> it's definitely a very different sort of mindset solving problems in a functional language
08:01:15 <dropp> but in all honest, i do feel like my exposure to functional programming has improved my work with oo and imperative languages
08:01:34 <phaazon> https://www.reddit.com/r/haskell/comments/2xgvtw/al_01_released/
08:01:39 <phaazon> :)
08:02:26 <dropp> i really like how go, rust, and others are making values immutable by default. the industry seems to be figuring out that state shouldn't be abused as it has been for decades
08:02:34 <ReinH> phaazon: oh cool :)
08:02:36 <geekosaur> applicative syntax is "interesting". there's some push for idiom brackets, which were the original applicative concept (`foo <*> a <$> b` becomes `(| foo a b |)`)
08:02:49 <phaazon> ReinH: :)
08:03:01 <ReinH> phaazon: This explains your recent love of c2hs :)
08:03:18 <dropp> hrm.. (| foo a b |) seems pretty straightforward, but i don't think it's very clear compared to the previous
08:03:27 <ReinH> geekosaur: What do you think of ocharles_'s proposal?
08:03:50 <geekosaur> dropp: actually I agree, it's cleaner but somewhat confusing
08:04:08 <ReinH> I would love idiom brackets
08:04:13 <dropp> ocaml's [|1;2|] for arrays vs [1;2] for lists is very uncomfortable and awkward to type, so i would rather not start using (| |) either
08:04:24 <dropp> the [| |]
08:04:26 <dropp> ugh
08:04:32 <ReinH> dropp: I prefer (| |) to <$> <*> <*> <*> <*>
08:04:41 <geekosaur> ReinH, kinda divided? I disliked a number of things about the original presentation of applicative functors, including the original name `idioms` and the fact that idiom brackets don't seem to "stand out enough" to indicate that normal application is not going on
08:05:03 <geekosaur> but the current syntax is, to be quite honest, ugly
08:05:06 <ReinH> geekosaur: syntax highlighting could help with the last bit
08:05:18 <geekosaur> and heavyweight
08:05:18 <dropp> why is haskell changing so much?
08:05:26 <dropp> it seems like it's very fast paced recently
08:05:36 <dropp> or these are just proposals?
08:05:38 <geekosaur> dropp, haskell is trying to balance between being a research language and a practical programming language
08:05:44 <EvanR> adapt or perish
08:05:50 <dropp> ahh
08:05:55 <EvanR> unless youre C
08:05:56 <geekosaur> it's *always* changed this fast, in my experience (granted that goes back only to 2007)
08:06:11 <ReinH> geekosaur: it waxes and wanes :)
08:06:27 <dropp> at my work we mostly use ruby and then C/C++ for heavy lifting, but i've been trying to learn haskell so i can benefit from haskell's awesome parallelism and concurrecy capabilities
08:06:38 <ReinH> dropp: seems good
08:07:00 <EvanR> also benefit from a type system
08:07:25 <dropp> yah man, don't get me started on that. i love ruby, but the dynamic types aspect pisses me off to no end
08:07:39 <phaazon> ReinH: yeah
08:07:43 <phaazon> c2hs rocks!
08:07:54 <dropp> i feel naked working with dynamic, let alone interpreted languages. like i could fall off a cliff at any time
08:08:19 <dropp> my co-workers think it's funny how i annotate the intended types for all my methods in the comments
08:08:34 <ReinH> phaazon: nice :)
08:08:44 <dropp> but they are all "rockstar/ninja/rails" types and don't understand what real engineers have been doing for decades :-)
08:09:02 <EvanR> dropp: practically ruby is used as if it had types. first its Fixnum is treated as integer, and then theres floats. then theres array, which probably have a single kind of value in them. then you have objects which have a duck type. all of the above are in your head, no help from the tools
08:09:22 <EvanR> also ignoring dynamically modifying code at runtime
08:09:41 <ReinH> phaazon: you should write more about your experience using c2hs :)
08:10:04 <dropp> for the most part, it's very abusive though, from a C perspective, every value is a struct and all numbers are LONG LONG, except for their big integers, which take even more space up
08:10:49 * geekosaur is somewhat interested in that perl 6 is playing with gradual typing and haskell is playing (on a meta level, perhaps) with what you might call gradual dependent typing
08:10:57 <EvanR> dropp: i almot forgot about when int was 32bit...
08:11:00 <dropp> if i am working with a value which will only be from 0-100, why would i want to use a *signed* LONG LONG
08:11:35 <EvanR> dropp: signed 64bit numbers are common machine native word now
08:11:37 <dropp> i do really appreciated how easy it is to incorporate C and C++ code into ruby though
08:11:43 <dropp> yeah
08:11:46 <phaazon> ReinH: do you think so?
08:11:55 <dropp> everything has so much space, lets just use it all coz we're lazy
08:12:07 <EvanR> dropp: or just ignore it because its the fastest choice
08:12:20 <dropp> it only takes another 25 orders of magnitude to complete a basic algorithm
08:12:27 <dropp> :-)
08:12:39 <dropp> yeah, i do mostly just try and ignore it, otherwise i'd cry everyday hah
08:12:43 <EvanR> we dont need to be worrying about how many CHAR columns someones name may have in 2015, i say
08:12:44 <ReinH> phaazon: absolutely
08:13:01 <geekosaur> phaazon, C compilers still generally treat (int) as 32 bit, but the CPU word is 64 bits. there's actually been an argument recently on the freebsd-stable list about whether C's (int) will follow machine words upward in the nearish future or not...
08:13:26 <dropp> i want a quantum processor
08:13:31 <dropp> qubits FTW
08:13:35 <EvanR> dropp: using 64bit ints when a 32bit would work is the least of your concerns in rubys implementation
08:13:41 <Welkin> 32-bit integers are preferred for SIMD operations because you often don't need anything larger than 4 billion
08:14:00 <Welkin> so you can execute more operations in parallel
08:14:04 <geekosaur> I suspect we're in a lacuna similar to "huge memory model" in the early days of 16/32-bit CPUs
08:14:24 <phaazon> I need to upload the documentation on my own because it fails on hackagedb
08:14:29 <phaazon> it might not have OpenAL installed :P
08:14:54 <dropp> i remember when i was 8, i wrote my first computer program. it was a choose your own adventure text game in BASIC. i stored it on a 5.25" floppy because my computer only has 512K of ROM (not RAM, ROM)
08:15:12 <dropp> QBASIC, actually
08:15:15 <geekosaur> it had to have some RAM somewhere or you cou;ldn
08:15:17 <geekosaur> t program it :)
08:15:28 <dropp> oh it has RAM, but i am refering to the ROM
08:15:29 <dropp> so little
08:15:41 <dropp> i think it had like 128K of RAM
08:15:47 <Welkin> I will be glad to never again touch a "dynamically typed" or OOP language ever again
08:15:49 <dropp> and that was a lot at the time
08:15:57 <geekosaur> my first computer was 8KB RAM, and an unstable cassette drive interface such that it was usually easier to just rekey the program again
08:16:05 <dropp> lol
08:16:07 <dropp> nice
08:16:12 <dropp> good memories
08:16:15 <mr-> Welkin: is that time soon?
08:16:20 <geekosaur> (the cassette interface was also a 300 baud modem and a tone generator....)
08:16:28 <phaazon> ReinH: I’ll write a bit about c2hs then
08:16:32 <phaazon> because it’s very convenient
08:16:32 <ReinH> good!
08:16:35 <phaazon> and pretty simple
08:16:46 <Welkin> mr-: except for javascript, that time is now
08:16:54 <dropp> c2hs is the scanner, right?
08:16:59 <dropp> that's freaaaaaking amazing
08:17:03 <dropp> under 6 minutes
08:17:05 <phaazon> c2hs is a compiler
08:17:07 <dropp> ooh
08:17:12 <geekosaur> c2hs reads C include files and generates Haskell FFI declarations
08:17:14 <ocharles_> ReinH: thanks for reminding me to follow up on that
08:17:24 <phaazon> it compiles .chs files into .hs / .chi
08:17:25 <EvanR> js doesnt count, its the asm of the web, you cant help but use it, but you dont have to know it ;)
08:17:41 <dropp> im thinking of C10M
08:17:42 <ReinH> ocharles_: you should follow up on that :)
08:17:43 <dropp> https://github.com/robertdavidgraham/masscan
08:17:48 <dropp> this is super super cool
08:18:03 <ocharles_> ReinH: no one seems to be really be for or against it.. so I dunno what to do :/
08:18:08 <dropp> nmap for the internet. scans every subnet asynchronously in under 6 minutes
08:18:21 <ReinH> ocharles_: :/ well I'm tentatively for it
08:18:30 <ocharles_> I wonder if I should just do it
08:19:13 <ReinH> ocharles_: do what?
08:19:23 <ocharles_> implement it
08:20:02 <dropp> the dude re-wrote a bunch of the TCP/IP stack to avoid kernel tasks when necessary, so it's fast as balls
08:20:21 <dropp> when *un*necessary i meant
08:20:35 <dropp> better word is maybe 'possible'
08:20:36 <EvanR> isnt the internet the bottleneck rather than the os
08:20:48 <Welkin> the network is always the bottleneck
08:20:58 * hackagebot network-simple 0.4.0.4 - Simple network sockets usage patterns.  http://hackage.haskell.org/package/network-simple-0.4.0.4 (RenzoCarbonara)
08:21:05 <dropp> well, the code is there, read up if you so choose
08:21:24 <dropp> okay, back to my learning haskell awesomeness. thanks for answering my questions guys! i will be back later
08:25:23 <breadmonster> EvanR: What's the simplest haskell library to use if I want to pull RSS feeds?
08:25:35 <EvanR> i dont know
08:26:00 <EvanR> go ask mr owl
08:34:28 <adamse> breadmonster_: i use http-conduit: simpleHttp "http://www.haskell.org/"
08:35:04 <breadmonster_> adamse: http://hackage.haskell.org/package/http-conduit This one?
08:37:29 <adamse> yes
08:37:35 <breadmonster_> Awesome.
08:43:12 <ReinH> adamse: I wouldn't call that the simplest haskell library
08:43:43 <adamse> ReinH: perhaps not in implementation, but in use I believe it is
08:43:58 <ReinH> adamse: Compared to wreq? There's a lot of overhead just in using conduit.
08:44:16 <ReinH> breadmonster: I'd recommend wreq for the http bits and feed for the RSS bits
08:44:37 <adamse> huh, had not seen wreq before!
08:44:39 <aawe> ReinH: cognitive overhead or performance overhead? conduit is great for constant-space performance
08:44:46 <ReinH> aawe: cognitive overhead
08:44:59 <ReinH> aawe: Yes, but that's not super relevant to handling rss reeds
08:45:26 <ReinH> Unless you intend to do stream-based parsing as well
08:45:52 <ReinH> And the criteria was "simplest"
08:46:14 <ReinH> I think most modern computers can fit an RSS payload in memory ;)
08:48:17 <ReinH> Bit of a shame that feed uses String, but it does have the advantage of actually existing, as opposed to the RSS parsers which use Text or ByteString
08:49:06 <ReinH> Then again, RSS isn't exactly a complex format
09:03:13 <showman> hey hey
09:04:00 <efm> hello showman
09:04:17 <showman> just trying out irc on emcas, pretty decent
09:08:39 <xnull> is yi worth looking into over vim+ghci?
09:12:15 <isomorphismes> 3
09:20:51 <Big_G> When I compose two functions, are they stored as two functions or one?
09:21:03 <mauke> what does that mean?
09:21:46 <valdyn> Big_G: why do you care?
09:24:31 <Big_G> valdyn, Just curious. Seems like it might be fast to have \x = x + 5 than \x = x + 2 and \x = x + 3
09:24:38 <Big_G> composed together
09:25:56 <rasen> Big_G: It depends on what optimization will compiler do
09:26:01 <valdyn> Big_G: of course you are right in theory, but this hardly ever matters
09:26:43 <valdyn> Big_G: the compiler will optmise probably, but even if not the cpu will probably take care of it
09:27:15 <rasen> valdyn: I believe, CPU won't
09:28:23 <Big_G> valdyn, Would that happen for more complex cases? I was thinking of having mutliple functions to update a map
09:29:00 <rasen> Big_G: today compilers are really smart in optimization
09:29:15 <rasen> they could do thing you can't even imagine
09:29:39 <Big_G> That's what I figured but wasn't sure
09:29:46 <Cale> uh
09:29:58 <Cale> Actually, I wouldn't expect it to combine the additions usually
09:30:59 <Cale> Sure, if the lambdas are directly written in the code, you might expect (\x -> x + 2) . (\x -> x + 3) to become (\x -> (x + 2) + 3)
09:31:05 <Cale> er
09:31:15 <Cale> (\x -> (x + 3) + 2) rather
09:31:51 <Cale> That's reasonable, but if the functions are computed in different locations and composed together, the compiler isn't guaranteed to see that
09:31:51 <rola> Lambducks.
09:33:09 <Cale> Big_G: It's possible to end up with large unevaluated expressions in your Map elements if you're not careful
09:33:33 <joelneely> @pl \ns -> zipWith (-) ns (0:ns)
09:33:33 <lambdabot> ap (zipWith (-)) (0 :)
09:33:35 <Big_G> How would I be careful?
09:34:45 <Cale> Big_G: e.g. if you modify a Map by doing  adjust (+1) on the same key a million times without ever looking at the value, you can end up with ((...((0 + 1) + 1) + ...) + 1) + 1
09:35:05 <Cale> which can take up a lot more space than an evaluated number would
09:35:17 <Big_G> Would I just want to occasionally look at it then?
09:35:36 <bergmark> just a tiiny peek
09:35:40 <Cale> Yeah, or use operations from Data.Map.Strict to force the element to be evaluated as you put it back
09:36:52 <MasterGeek> Hello there, i'm struggling with cabal, trying to install leksah. i'm using archlinux(netrunner) and can't figure out how to install gtksourceview3.
09:37:24 <Cale> (Data.Map.Strict uses the same datatype, but the functions force the evaluation of the elements)
09:38:56 <Cale> MasterGeek: What problem are you running into? Did you manage to get the gtk3 package installed?
09:39:33 <MasterGeek> It is installed, thanks for answering.
09:40:17 <MasterGeek> I'm trying to install leksah, but gtksourceview3 (dependency) will not install.
09:40:48 <Cale> Yeah, are there any error messages?
09:41:11 <Cale> Is the development package for the corresponding C library installed?
09:42:43 <Cale> I don't know what it's called on arch, but on Mint, there's a libgtksourceview-3.0-dev package which you'd want to install before installing the cabal package for the Haskell binding.
09:43:14 <tomberek> is there a way to desugar Arrow proc-do notation and then manipulate it using Template Haskell?
09:43:28 <tomberek> I tend to get errors like this:     Expression form not (yet) handled by Template Haskell       proc n -> id -< n
09:43:59 <tomberek> is there some way to perform the desugar step first, then capture the result with TH?
09:47:28 <dulla> then you'd have to drop out of do notation, or something
09:48:42 <tomberek> dulla: ?
09:49:10 <dulla> last I recall, proc is inside do
09:49:16 <MasterGeek> Sorry for delay. I'm installing now a package called gtksourceview3 from the AUR (hope is the one i need), i did not know that i needed the C package too.
09:49:47 <dulla> and do and proc are sugar
09:50:18 <MasterGeek> Now i see and the cabal installation of gtksourceview3 went pretty well, thanks for that. I'll install leksah to see what happens.
09:52:07 <tomberek> dulla:  that is correct, I'd like to manipulate arrow (proc-do) notation, but it seems template haskell can't handle it
09:52:24 <dulla> then get out of that
09:52:37 <dulla> there are repsective functions for the sugar notations
09:53:19 <tomberek> dulla: yes, i'd like to manipulate the desuggared version with TH
09:53:35 <tomberek> dulla: So my next thought is, can I desugar the notation using GHC API or something, then feed that into a quasiquote?
09:54:00 <dulla> or you could simply write desugared
09:54:05 <dulla> and I know jack and all
10:00:25 <sdgrecv> Where can I find the implementation of (>>) for the State monad?
10:00:33 <sdgrecv> Can't seem to find it using hoogle
10:01:22 <dulla> you could derive it from the bind instance
10:01:27 <dulla> try, anyways
10:02:28 <tomberek> sdfrecv:https://hackage.haskell.org/package/mtl-1.1.0.2/docs/src/Control-Monad-State-Lazy.html#State
10:02:39 <tomberek> er.. sdgrecv
10:02:57 <sdgrecv> thanks tomberek
10:02:57 <dulla> slow down there
10:03:23 <sdgrecv> this seems to use monad transformers which i didnt learn yet
10:03:24 <MasterGeek> Cale: I have successfully installed leksah, thanks a lot. There's some kind of like button or something similar here ?
10:04:19 <sdgrecv> actually the real world haskell book starts the monad transformers chapter by referencing the State monad so I thought I would learn that before continuing -_-
10:04:29 <geekosaur> sdgrecv, that version of mtl has a standalone State type. newer ones (mtl2) make it a type alias for StateT Identity
10:04:57 <sdgrecv> oh
10:05:17 <Forkk> Is there an IRC channel for Cloud Haskell? Or should I just ask about it in here?
10:05:48 <geekosaur> meanwhile, I note it inherits the default implementation of (>>) which is: a >> b = a >>= \_ -> b
10:06:28 <sdgrecv> geekosaur: where did you get this default implementation? I didn't see it in Prelude or Monad modules :S
10:07:00 <sdgrecv> that makes sense though
10:07:02 <dulla> >> is bind without the binding
10:07:04 <geekosaur> http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Monad-Instances.html#v:-62--62-
10:07:13 <dulla> >> is not natively defined, but derived
10:07:30 <geekosaur> click the "Source" link on the right of the description of (>>)
10:07:51 <sdgrecv> oh right
10:07:56 <geekosaur> ...oh, ugh, haddock why? that source is trashed...
10:08:07 <sdgrecv> i missed it because first it defines the type for (>>) and the definition is later
10:08:35 <sdgrecv> is there a reason for the forall in '(>>)        :: forall a b. m a -> m b -> m b' ?
10:09:10 <ned> is that quantification standard in haskell98 or is that an extension
10:09:27 <geekosaur> it's not in haskell98. I don't recall if it's in h'2010
10:09:43 <dulla> quantification started some time around '10
10:09:45 <geekosaur> and, it shouldn't be doing anything since it's at the top level and there's no scope
10:09:51 <dulla> it's if you really want to write it all out
10:11:03 * hackagebot apiary-purescript 1.3.2 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-1.3.2 (HirotomoMoriwaki)
10:11:05 <Cale> MasterGeek: cool, good to hear it :)
10:11:18 <geekosaur> quantification existed before haskell2010
10:11:43 <monochrom> . o O ( existential quantification exists :) )
10:12:03 <geekosaur> and I think it's not in h'2010 either but an extension. I don't know why they chose to write it there since it's not actually doing anything
10:12:18 <sdgrecv> are the actions in do notation composed using (>>) if there are no (<-) bindings?
10:12:37 <dulla> yes
10:12:54 <sdgrecv> thats wierd'
10:12:59 <dulla> well
10:13:08 <dulla> people got tired of spamming >> at the end of lines
10:13:08 <monochrom> Haskell 2010 doesn't have "forall" in either sense, either.
10:13:13 <dulla> and lambdas for days
10:13:16 <sdgrecv> let me paste some code from LYAH im talking about 1 sec
10:14:14 <sdgrecv> http://lpaste.net/121343
10:14:37 <sdgrecv> wouldnt the results of pop and push be lost between actions if (>>) is used?
10:14:39 <ned> apparently UQ has some sql usages but i dont see it :o(
10:15:02 <sdgrecv> and whats the point of the (a <-) if a is not used?
10:15:14 <Cale> sdgrecv: That's a weird example
10:15:23 <sdgrecv> Cale: its from LYAH
10:15:26 <hakujin> to save me half an hour of testing: is there a performance benefit for manually compiling regex-tdfa regular expressions for repeated comparisons? i.e. will ghc memoize using (=~)?
10:15:31 <Cale> sdgrecv: You're right, there's no point in capturing the result of the pop unless you're going to use it
10:15:38 <geekosaur> sdgrecv, the effect remains, the value returned by pop is lost. if you're not using a in that example then it's not going to affect anything and they could have left it out
10:15:50 <Cale> sdgrecv: That will be equivalent to  do push 3; pop; pop
10:16:04 <Cale> which in turn will be the same as just pop on its own
10:16:08 <sdgrecv> does the state of the stack change?
10:16:16 * hackagebot types-compat 0.1.1 - ghc-7.6/7.8 compatible GHC.TypeLits, Data.Typeable and Data.Proxy.  http://hackage.haskell.org/package/types-compat-0.1.1 (HirotomoMoriwaki)
10:16:17 <geekosaur> yes
10:16:30 <sdgrecv> so does it use (>>=) implicitly?
10:16:51 <Cale> x >> y is the same as x >>= (\k -> y)
10:16:54 <sdgrecv> if it uses (>>) i dont see how the state of the stack gets passed?
10:17:06 <geekosaur> take a look at what >>= does
10:17:32 <dulla> ma -> (a -> m b) -> m b
10:17:34 <Cale> sdgrecv: both (>>) and (>>=) carry the state along
10:17:45 <sdgrecv> but isnt the result of the first action discarded with (>>)
10:17:47 <geekosaur> given State s a = (a,s), the only part you're seeing is a; s is managed by the definition of (>>=) for State
10:18:01 <dulla> if a = _ in (a -> m b)
10:18:03 <sdgrecv> based on the default definition of (>>) it seems so
10:18:04 <dulla> then
10:18:04 <Cale> sdgrecv: The difference is that with (>>), the *result* of the first action is discarded (not the effect it had on the state)
10:18:15 <dulla> ma -> mb -> mb
10:18:17 <monochrom> sdgrecv: I recommend testing that code (evalState will help) to see the actual state change before you theorize.
10:18:37 <dulla> so
10:18:42 <dulla> the state, s passes through >>?
10:18:57 <geekosaur> because it uses >>=, yes
10:19:05 <Welkin> look at the definition of (>>=) for State
10:19:09 <Cale> Perhaps I should go over how State is implemented here
10:19:12 <Welkin> try to implement it yourself
10:19:25 <Welkin> building your own monads is the quickest way to learn how they work
10:19:33 <geekosaur> in `m >>= \k -> a`, k is only the `a` part of State s a
10:19:48 <geekosaur> s is plumbed internally by >>=
10:20:15 <sdgrecv> oh right
10:20:19 <sdgrecv> i think i understand
10:20:20 <Cale> The idea is that we're representing computations which act on a state of type s while producing a result of type a. In order to do so, we just use functions which take the initial state, and produce a pair consisting of the result and final state.
10:20:41 <Welkin> which is the purpose of the state monad
10:20:52 <Welkin> otherwise, you would just thread the state explicitly
10:20:54 <geekosaur> hm, that was confusing because I used `a` in two different ways :/
10:20:55 <Welkin> and would not be using a monad
10:24:12 <c74d> How should I massage <https://bpaste.net/show/65d4793db821> to make the `getFile` calls in `renderPage` type-check?
10:24:55 <Cale> c74d: Assuming that ActionM is an instance of MonadIO, you can apply liftIO to them
10:24:59 <Cale> :t liftIO
10:25:00 <lambdabot> MonadIO m => IO a -> m a
10:25:13 <Cale> i.e. turning the IO actions into ActionM actions
10:33:23 <c74d> Cale: like this: <https://bpaste.net/show/12f247660e4b>?
10:33:54 <Cale> c74d: yeah, or you could even put it in the definition of getFile
10:34:06 <Cale> (so long as you don't need to use that from other IO actions)
10:36:36 <c74d> Cale: that still doesn't type-check: <https://bpaste.net/show/742c3ae9758e>
10:38:24 <Cale> Oh, your problem is that the last line, (T.replace ...)  isn't an action at all
10:38:28 <Cale> It's just a Text
10:38:41 <Cale> perhaps you wanted to return that?
10:40:29 <JoshieAS> quick question, what's another resource similar to 99 Problems in Haskell that I can use to do exercises?
10:41:47 <Haskellfant> JoshieAS: depending on your skilllevel the nicta course is quite good https://github.com/NICTA/course
10:41:47 <cbarrett> Typeclassopedia
10:41:59 <c74d> Cale: it's being passed to (html :: Text -> ActionM ())
10:42:21 <JoshieAS> Haskellfant: thankee!
10:42:22 <Cale> c74d: Well, that's another type error then
10:43:01 <Cale> c74d: perhaps you just want to move the html in, and use it in place of return
10:43:21 <c74d> I changed it to `html $ T.replace [...]` and it works. Thanks for helping (and making me think of that)!
10:45:07 <jophish> Is it 'data type' or 'datatype'?
10:48:34 <sdgrecv> hey going back to this code: http://lpaste.net/121343 how does it know to place just the result portion of the state into a and not (result, stack) ?
10:49:35 <sdgrecv> this is a better example actually: http://lpaste.net/121343
10:49:53 <sdgrecv> shouldnt a be (Int, Stack)
10:50:05 <sdgrecv> but it gets compared to 5 ?
10:50:50 <sdgrecv> :S
10:51:52 <geekosaur> no, a is just Int
10:52:14 <geekosaur> the whole point of >>= is you only get the result part (Int) while the rest (Stack, here) is handled internally
10:52:51 <sdgrecv> but when using State you always get (a,b) as a result
10:53:04 <geekosaur> so, thinking about it one way, it can enforce invariants on Stack (in this case just carrying it through); another way, you don't have to carry it manually, it "just happens"
10:53:19 <geekosaur> if you look at a State s a directly, yes
10:53:23 <sdgrecv> I understand that part
10:53:27 <geekosaur> but you are not looking at it directly
10:53:35 <geekosaur> you are looking at the part that >>= gives you
10:54:06 <tomberek> Cale: is there a way to run proc-do arrow desuggarring on a QuasiQuote? any way to access the GHC internal dsArrow?
10:54:35 <monochrom> jophish: it is "data type" in Haskell, "datatype" in SML :)
10:54:35 <Cale> tomberek: We did our desugaring as a preprocessor using haskell-src-exts
10:54:52 <sdgrecv> geekosaur: i still dont understand how haskel decides to take out the result only?
10:54:53 <Cale> tomberek: I don't know much about quasiquoters
10:55:05 <tomberek> can haskell-src-exts process arrow notation?
10:55:09 <geekosaur> "haskell" doesn't. the definition of (>>=) does
10:55:10 <Cale> tomberek: yes
10:55:22 <Cale> sdgrecv: If you'd like I can give you a tutorial on constructing the state monad
10:55:22 <geekosaur> @src (>>=) State
10:55:22 <lambdabot> Source not found. :(
10:55:24 <tomberek> great, thanks!
10:55:25 <geekosaur> is this... nope
10:55:28 <sdgrecv> geekosaur: but the result of >>= is a State?
10:55:38 <geekosaur> the ultimate result, yes
10:55:45 <geekosaur> note that you are giving it a function
10:55:51 <geekosaur> and that function is being passed a parameter
10:55:52 <sdgrecv> okay
10:55:58 <sdgrecv> yes
10:55:58 <geekosaur> that parameter is NOT the reuslt of (>>=)!
10:56:06 <Cale> sdgrecv: We should probably join #haskell-overflow or something to keep the code from scrolling away too quickly :)
10:56:42 <sdgrecv> Cale: I already implemented a State monad I just dont understand this thing
10:56:53 <Cale> Okay, well, let's do it step by step :)
10:57:16 <sdgrecv> geekosaur: the parameter to the function in State is the initial state
10:57:26 <sdgrecv> Cale: okay
10:57:49 <geekosaur> well, current state. which at the start is the initial state, but that state can be modified (see `put`, `modify`)
10:58:02 <geekosaur> but in any case no it is not the state
10:58:16 <geekosaur> the state is the s part of (a,s)
10:58:24 <geekosaur> the a part is what's passed on
10:58:28 <sdgrecv> oh i see geekosaur
10:58:41 <sdgrecv> the function _in_ State takes the state
10:58:51 <geekosaur> the s part >>= keeps to itself, and passes on as part of the ultmate result
10:58:59 <sdgrecv> but the function that is the second param ofr (>>=) takes the result of the previous state
10:59:37 <sdgrecv> and (<-) takes the value that will be passed to the second param of (>>=) and binds it to a name
10:59:41 <sdgrecv> right?
10:59:46 <monochrom> the result of the previous state? the state of the previous result? what is "result"?
10:59:53 <geekosaur> ^
11:00:01 <geekosaur> I think this may be the core of your confusion, even...
11:00:07 <monochrom> yeah
11:00:07 <sdgrecv> well the function in State is (state -> (result, state))
11:00:08 <sdgrecv> right
11:00:28 <Welkin> sdgrecv: https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Instantiating_the_Monad
11:00:49 <monochrom> there are about 3 conflicting things that could be called "result" and if you equate them you will not get far
11:00:50 <jophish> monochrom: ah, that explains things, thanks!
11:00:55 <Welkin> that's how (>>=) works in State
11:01:10 <geekosaur> sdgrecv, but >>= is not just runState
11:01:20 <sdgrecv> geekosaur: yeah i get that now
11:02:08 <sdgrecv> the  (<-) in 'do' intercepts the value that will be passed to the second param of (>>=) and binds it to a name
11:02:10 <sdgrecv> right?
11:02:33 <geekosaur> m >> k = State $ \s -> let (a,s') = runState m s in runState (k a) s'
11:03:59 <geekosaur> so first process the left side using the initial state and get the a and s' (current state) from it, then process the right on the result of calling your function on a, propagating the current state s' which may result in a new state
11:04:49 <sdgrecv> geekosaur: I understand how >>= and >> work for State already
11:05:08 <sdgrecv> My last question was about how haskell does the bindings in do
11:05:27 <geekosaur> @undo do { v <- a; b v }
11:05:27 <lambdabot> a >>= \ v -> b v
11:05:38 <geekosaur> it's a mechanical translation
11:05:40 <monochrom> do { x<-m; morestuff } = m >>= \x -> morestuff
11:05:46 <Welkin> do is just sugar for bind
11:06:21 <monochrom> actually, do { x<-m; morestuff } = m >>= \x -> do {morestuff}, recursively
11:06:44 <sdgrecv> yeah but im wondering what the process is to figure out which value to bind to
11:07:00 <geekosaur> I think if you are asking that themn you still dont understand >>=
11:07:10 <sdgrecv> because the value that gets passed to the right side of (>>=) is computed within the definition of >>= for State
11:07:11 <geekosaur> because >>= controls what it gets
11:08:24 <sdgrecv> is it just a pattern-like transformation that finds where the right side of (>>=) gets used and retrieves the parameter?
11:08:41 <geekosaur> ?
11:08:47 <geekosaur> there is no magic going on here
11:09:01 <sdgrecv> okay i know there is no magic
11:09:06 <Welkin> sdgrecv: try implementing a Monad instance for State yourself
11:09:11 <geekosaur> but you asked me just now what magic it's doing
11:09:12 <sdgrecv> Welkin: I did
11:09:13 <Welkin> that is the easiest way to understand it
11:09:15 <hpc> there's no transformations or anything
11:09:19 <hpc> there is only function application
11:09:25 <hpc> and whatever the definition of (>>=) is
11:09:40 <sdgrecv> okay look, hasklell needs to determine what to bind to 'a' right?
11:09:49 <hpc> no
11:09:50 <geekosaur> no
11:10:00 <monochrom> I don't understand the question.
11:10:03 <geekosaur> the definition of (>>=) determines it
11:10:07 <rola> a bunch of the nicta course on github is writing various instances, which i think is a great way of learning
11:10:07 <sdgrecv> you're looking at my last code right?
11:10:15 <sdgrecv> lemme give the link again
11:10:23 <sdgrecv> http://lpaste.net/121343
11:10:25 <sdgrecv> line 11
11:10:37 <sdgrecv> thats the a im talking about
11:10:45 <sdgrecv> not a - the result in State
11:11:25 <Clint> you're asking how it knows what "a <- pop" means?
11:11:35 <sdgrecv> yesss
11:11:45 <sdgrecv> how does it know what value to bind a to?
11:12:00 <hpc> @src State (>>=)
11:12:01 <lambdabot> Source not found. Whoa.
11:12:03 <Clint> by.. popping it?
11:12:36 <monochrom> first, your code gets translated to "pop >>= \a -> do { the rest of the stuff }"
11:12:42 <geekosaur> sdgrecv, `a <- pop` is exactly `pop >>= \a ->`. >>= decides what parameter to call it with
11:12:54 <monochrom> then, the code for (>>=) is used. that is how.
11:12:54 <michaelt> sdgrecv: 'a' is just being used to define the function \a -> if a == 5 then etc
11:13:15 <sdgrecv> oh right michaelt
11:13:19 <geekosaur> for State, it does so by the `runState (k a) s'` in the definition of (>>=)
11:13:19 <sdgrecv> okay that makes sense now
11:14:20 <sdgrecv> thanks guys i get it now
11:14:27 * hpc is beginning to see where "do notation considered harmful" came from
11:14:36 <geekosaur> yep
11:14:42 <lpaste> Lokathor pasted “cabal probelm” at http://lpaste.net/121346
11:14:44 <michaelt> sdgrecv: so its the same as this http://lpaste.net/raw/4664065983575490560
11:15:00 <Lokathor> how does one make cabal pull in the proper dependencies to perform tests?
11:15:02 <hpc> (the way it splits up lambdas)
11:15:18 <sdgrecv> michaelt: thats the same code i pasted
11:15:37 <michaelt> sdgrecv: no i changed two lines ...
11:16:00 <michaelt> sdgrecv: just to eliminate the problem about 'knowing what 'a' is'
11:16:02 <hexagoxel> Lokathor: `cabal install --dep --enable-tests`
11:16:07 <sdgrecv> oh right michaelt
11:16:29 <monochrom> it is possible to ask the same question on "m >>= \a -> b".
11:16:57 <Lokathor> oh all at once like that, okay
11:25:41 <joelneely> @pl \t ns -> f $ map (g t $ h ns) $ p ns
11:25:41 <lambdabot> (f .) . (`ap` p) . (map .) . (. h) . g
11:31:19 * hackagebot shelly 1.6.1.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.1.2 (GregWeber)
11:37:38 <Lokathor> cabal test doesn't seem to run my tests most of the time :/
11:38:07 <tomberek> Cale: do you have a stub for that parser around?  I'm getting this for a result:   Language.Haskell.Meta.Syntax.Translate.toExp: not implemented: Proc
11:38:28 <Lokathor> i get no output normally, but if i put an assertFailure in my main method at the end it'll print the output i expect with the failure at the end
11:38:52 <Cubic> h come on... stupid windows
11:39:00 <tomberek> Cale: it seems the haskell-src-exts doesn't desugar it for you, just keeps the AST in proc format?
11:39:38 <Cale> tomberek: Oh, did you expect it to?
11:40:05 <Cale> We had our own desugaring of the proc/do notation, that's what the preprocessor was for
11:40:17 <Cale> (which was different from GHC's desugaring)
11:40:19 <tomberek> Cale: i'd like to recover the AST that the proc notation desugars to (and then optimize it at compile time)
11:40:29 <Cale> ah
11:40:43 <Cale> Yeah, that's a bit different
11:42:10 <Twernmilt> I'm trying to write a cabal preprocessor, but it's refusing to find the file that's mean to be preprocessed. Here's a Gist with the relevant information: https://gist.github.com/MichaelBaker/d6c38fe57c06db68ee7c
11:42:35 <tomberek> Cale: i guess the AST is a good start, though I was hoping to get the AST after desugarring, not before
11:42:48 <Twernmilt> If I convert it to processing .hs files, it will process Main, but none of the other files in the tree. Is there something I need to do to get it to search the entire source tree for files to process?
11:46:20 <tomberek> Cale: when you say "we", what project and whom are you referring to?
11:46:49 <Cale> tomberek: Oh, I thought you asked me because you knew, haha :)
11:47:15 <Cale> That was for iPwn Studios, we were working on a game called Blood Knight
11:47:33 <tomberek> hehe, nope! I just know you're knowledgeable
11:47:54 <Cale> We had an arrowy FRP system, and our own version of Arrow
11:48:00 <tomberek> you wrote an arrow preprocessor?
11:48:15 <tomberek> is any of that open source?
11:48:24 <Cale> The arrow preprocessor made our game run something like 7 to 10 times faster :)
11:48:28 <Cale> Sadly no
11:49:05 <tomberek> i've become interested in Arrows, and it seems that they never took off because the "killer app" of static analysis and optimization wasn't realized
11:49:20 <tomberek> is that pretty much what you guys did?
11:49:48 <Cale> yeah
11:50:01 <tomberek> I'm trying to improve on the result of the "Casual Commutative Arrows" paper
11:50:12 <Cale> The problem with Arrow is that it's missing most of the things you'd need to do runtime analysis of the graph
11:50:33 <Cale> instead, you wire all the results around with arr applied to lambdas which are black boxes
11:51:37 <tomberek> Cale: I tried using GHC Rules to capture those tuple shuffling lambdas into constructors like Fst, Raise, Assoc, Shuffle, etc.. then optimize them with more rules or an optimization function.
11:51:40 <Cale> If you add in:
11:52:45 <Cale> assocL :: (a,(b,c)) ~> ((a,b),c); assocR :: ((a,b),c) ~> (a,(b,c); swap :: (a,b) ~> (b,a); unitL :: a ~> ((),a); retractL :: ((),a) ~> a; unitR :: a ~> (a,()); retractR :: (a,()) ~> a
11:52:52 <tomberek> my other attempt is along the lines of the CCA paper, but using their preprocessor/makefile is tedious
11:53:11 <Cale> i.e. the other stuff you'd have as part of the definition of a symmetric monoidal category
11:53:12 <arjanb> that looks like a variation on 'generalized arrows'
11:53:28 <Cale> then you get something much more usable for runtime optimisation
11:53:48 <Cale> Of course, the GHC translation of proc/do notation will still stick arr in between every pair of computations
11:53:58 <Cale> So, that's why we had the preprocessor
11:53:58 <tomberek> Cale, that's pretty much what I did, but the standard proc-do notation uses 'arr' with some very whacky stuff.... yep, what you just said
11:54:45 <tomberek> exactly why i'm trying to parse it myself in a quasiquote, replace those "arr"s with the versions you just listed
11:55:55 <Cale> Eventually, you can get it down to where arr is just used for matching patterns to the left of <- which involve something other than pairs, and where expressions that aren't just nested pairs to the right of -<
11:56:04 <Cale> occur*
11:56:08 <tomberek> arjanb: i think so, though i've not yet played around with GArrow, it needs some GHC hacking that I'm not sure still works
11:59:01 <tomberek> It seems that this would be one of the first things to make after Arrows is produced as an extension.
12:01:23 <tomberek> Cale: what do you think would be the right approach to bring that sort of optimization and arrow usage to Haskell at large? GArrows? QuasiQuoting? preprocessor?
12:02:08 <Lokathor> i cannot get "cabal test" to make my obviously failing tests actually fail
12:02:32 <Cale> Well, we should fix the Arrow class, adding the stuff I mentioned (while possibly splitting the class up into more usable pieces), and ideally, make GHC use that stuff when translating the proc/do notation.
12:02:34 <Lokathor> it always reports a success, even then the log clearly shows a failure took place
12:02:57 <Clint> Lokathor: are you using tasty or hspec?
12:03:24 <Lokathor> Clint, I'm using QuickCheck
12:03:31 <Lokathor> do i need to wrap quickcheck in something else?
12:03:37 <enthropy> what's the testsuite type?
12:03:39 <Clint> you don't need to but i think you're going to be happier
12:04:33 <enthropy> maybe it's exitcode-stdio-1.0, and your failing tests don't make an exitcode be nonzero
12:04:39 <tomberek> Cale: this seems like an attempt in 2011 to do something along those lines: http://www.megacz.com/berkeley/garrows/
12:04:57 * enthropy reads Lokathor's mind
12:05:01 <Lokathor> it is exitcode-stdio-1.0, both when i was using HUnit and when i switched to QuickCheck
12:05:34 <Cale> Yeah, apart from the fact that the choice of names sucks, that's the right idea :)
12:07:07 <Cale> I'm also not certain how necessary it is to generalise over (,) and ()
12:07:14 <Cale> but it might be useful to some
12:08:08 <Cale> tomberek: You should also talk to Ryan Trinkle about this stuff
12:08:17 <Lokathor> enthropy, i can't seem to get detailed-0.9 to work :/
12:08:40 <Cale> (he was the one who actually wrote the preprocessor)
12:09:18 <Lokathor> I just want it to run every test and/or property appropriately and print every single result listing
12:09:55 <rasen> What library should I choose for plotting?
12:10:53 <tomberek> Cale: thanks
12:10:57 <apo> libworlddomination
12:12:15 <rasen> Can it draw colorful plots?
12:13:16 <xnull> :t repeat
12:13:17 <lambdabot> a -> [a]
12:13:37 <Lokathor> any color of blood that you want
12:13:41 <xnull> > take 4 . repeat $ "yes"
12:13:42 <lambdabot>  ["yes","yes","yes","yes"]
12:13:45 <xnull> ohneat.
12:13:59 <rasen> Lokathor: nice
12:17:43 <heatsink> Clint: What makes tasty or hspec more useful than hunit and quickcheck?
12:18:43 <Lokathor> it seems that cabal isn't actually aware of how any particular test suite runs, so you have to manage your own suite yourself
12:18:52 <Lokathor> i'm guessing that's where tasty or HSpec come in
12:20:05 <heatsink> I've used HUnit to group tests into test suites and run them
12:20:34 <Lokathor> using "cabal test"? or using something like "runhaskell myTests.hs"?
12:20:51 <heatsink> Using cabal test with exitcode-stdio
12:21:07 <Lokathor> i've spent the last two hours having that not work at all for me, please do tell
12:22:40 <heatsink> HUnit has a function to run a test and return the results as a Counts value
12:22:49 <heatsink> runTestTT
12:22:56 <Lokathor> right, i was using that
12:23:07 <Lokathor> and i guess you need to manually check that Counts value each time?
12:23:18 <heatsink> Since Cabal expects an exit code, you can check whether the Counts contains failures or errors
12:23:24 <heatsink> and call exitSuccess or exitFailure
12:23:51 <heatsink> to terminate with an exit code that tells cabal whether the test suite passed
12:24:12 <Lokathor> well i know that exitSuccess is unnecessary
12:24:27 <Lokathor> by default a haskell program always does that when it gets to the end of the program
12:24:52 <heatsink> yes
12:25:03 <Lokathor> i suppose I'll have to wrap runTestTT in some extra code and try again
12:25:12 <heatsink> right
12:25:59 <Lokathor> how bothersome that HUnit doesn't have a thing that works with cabal's expectations out of the box
12:26:22 * hackagebot diagrams-hsqml 0.0.0.0 - HsQML (Qt5) backend for Diagrams  http://hackage.haskell.org/package/diagrams-hsqml-0.0.0.0 (mjmrotek)
12:30:21 <Lokathor> does QuickCheck have a way to check a property *without* printing the results to stdout?
12:30:49 <Lokathor> it seems like every single function prints to stdout regardless of if it returns Result or () or whatever else
12:37:44 <heatsink> Lokathor: I don't think so.  It does mess with readability when quickheck is used with HUnit
12:38:18 <Lokathor> yes, i'd rather that quickCheck just do it's things and give me the results for me to print in my own format.
12:39:53 <heatsink> Some test frameworks are designed to work with hunit and quickcheck
12:40:14 <heatsink> Maybe you could try them and see if they filter quickcheck's output
12:40:34 <JoshieAS> what is the proper way to use "less than" in a case expression?
12:40:47 <JoshieAS> like, if I have "case x of..." how should I write "x < 0"?
12:41:19 <heatsink> if x < 0 then ... else ...
12:41:23 * hackagebot diagrams-hsqml 0.0.0.1 - HsQML (Qt5) backend for Diagrams  http://hackage.haskell.org/package/diagrams-hsqml-0.0.0.1 (mjmrotek)
12:41:51 <tdammers> case x < 0 of { True -> ... } -- :P
12:42:27 <JoshieAS> thankee
12:42:29 <fizbin> JoshieAS: Haskell's "case" isn't a generic matcher the way similar structures are in ruby or scala
12:42:40 <JoshieAS> yeah?
12:44:14 <fizbin> Yeah, you can only pattern match to constructors in a case statement; you can't create a generic object that matches "all integers less than 0". So you can't begin with just "case x of", you need to use "case x < 0 of...", but at that point, why aren't you using an if statement?
12:45:01 <JoshieAS> that's true, thanks for pointing that out
12:46:27 <fizbin> (Whereas in ruby you can override === to provide fanciness in case matching, and in Scala you can implement an unapply method to provide fancy things in a match statement)
12:48:53 <Scriptonaut> can anyone tell me why it doesn't like line 7? https://gist.github.com/robins35/f5a89ee750dae3eb2091
12:49:16 <Scriptonaut> it just tells me: parse error on input '='
12:49:24 <geekosaur> yes, because you can't do that there
12:49:24 <bergmark> Scriptonaut: let goes at the start of the line
12:49:36 <Scriptonaut> I don't get it
12:49:45 <geekosaur> you are not at the file's top level
12:49:50 <fizbin> Well, you can do it there, but forgot the "in" keyword.
12:49:52 <geekosaur> you cannot simply drop `foo = ...` there
12:49:55 <jle`> let scrambledList = ....
12:50:03 <geekosaur> in a do, you can say: let scrambledList = ...
12:50:14 <geekosaur> (without the `in`, like you're in ghci)
12:50:31 <Scriptonaut> I want to store the result of the in though
12:50:34 <Scriptonaut> in scrambledList
12:50:34 <geekosaur> or in this case, let scrambledList = let ...
12:51:23 <Scriptonaut> so I gotta do let scrambledList = let?
12:51:40 <geekosaur> let scrambledList = let ... in ...
12:51:44 <jle`> or you can just let your thing on the outside
12:51:56 <Scriptonaut> jle`: what do ya mean?
12:51:59 <jle`> let (xs, y:ys) = splitAt (fst $ randomR (0, length l - 1) g) l
12:52:16 <Scriptonaut> ah
12:52:19 <jle`> scrambledTail <- randPermu (xs ++ ys)
12:52:20 <bergmark> also, indentation for do let is pretty unforgiving ;(
12:52:32 <Scriptonaut> I didn't think you needed let inside a do
12:52:34 <jle`> let scrambledList = y : scrambledTail
12:52:43 <jle`> that should cover it
12:53:01 <danilo2> Hello! I've got 2 question regarding haskell type system. 1) Is it possible to convert type name to Symbol? 2) Is it possible to compare Symbol's just like Strings (using < and >) ?
12:53:03 <fizbin> Scriptonaut: There are a few different ways to do what you wanted.
12:53:03 <jle`> Scriptonaut: you use let to assign "aliases"/names to values in a do that are in scope for the rest of the block
12:53:24 <jle`> the three lines i put should cover what you are trying to doing
12:54:00 <fizbin> Scriptonaut: The way that makes the smallest change, I've added as a comment to that gist
12:54:39 <Scriptonaut> oh that's cool, I didn't know you could do that
12:55:23 <fizbin> Scriptonaut: Ugh. My spacing got screwed up. Stupid tabs.
12:56:25 <heatsink> danilo2: You can convert type names to TypeRep values using typeOf from Data.Typeable
12:56:39 <heatsink> > typeOf True
12:56:41 <lambdabot>  Bool
12:56:41 <Scriptonaut> I'm still confused why sometimes you gotta prepend with let and sometimse you don't have to
12:57:03 <Scriptonaut> you did: scrambledList <- let, but earlier you guys said I had to do: let scrambledList = let...
12:57:05 <danilo2> heatsink: I'm asking about conversion on differen level. I want to convert type names to Symbols, not a common type, like TypeRep
12:57:14 <heatsink> What is a Symbol?
12:57:17 <jle`> Scriptonaut: added my suggestion to the gist as well
12:57:25 <danilo2> heatsink: GHC.TypeLits
12:57:38 <danilo2> heatsink: DataKind
12:57:54 <jle`> fizbin: you might be missing a return or something in your comments
12:58:00 <jle`> :t (:)
12:58:01 <lambdabot> a -> [a] -> [a]
12:58:12 <fizbin> jle`: Yeah, I saw that and just edited it in.
12:58:15 <Scriptonaut> wait, I think I get it
12:58:22 <Scriptonaut> why do you have to use let for =, but not for <-
12:58:35 <Scriptonaut> cuz it's in a do block?
12:58:42 <jle`> they do different things
12:58:47 <jle`> if you have iox :: IO a
12:58:49 <fizbin> jle`: Looks like Scriptonaut's tabs bit you too
12:59:02 <jle`> x <- mx,  the x will be type `a`
12:59:04 <Scriptonaut> how should I have my tabs?
12:59:10 <jle`> let x = mx, the x will also be type `IO apo
12:59:18 <jle`> let is just for aliases
12:59:20 <apo> jle`: okay
12:59:23 <jle`> <- is to bind the result
12:59:25 <geekosaur> @undo do { a <- m; let b = p a; c b }
12:59:25 <jle`> apo: sorry :)
12:59:25 <lambdabot> <unknown>.hs: 1: 31:Parse error: }
12:59:33 <geekosaur> @undo do { a <- m; let {b = p a}; c b }
12:59:33 <lambdabot> m >>= \ a -> let { b = p a} in c b
12:59:45 <Cale> Scriptonaut: let begins an entire block of declarations
12:59:57 <apo> jle`: I'm in #ksp, I'm used to highlights that don't concern me :p
13:00:10 <jle`> i'm nto sure how a ` turned into an o
13:00:23 <jle`> oh, it must have turned into a tab
13:00:24 <Cale> Scriptonaut: So you can have one let followed by arbitrarily many definitions (so long as they start in the same column)
13:00:43 <fizbin> jle`: I think what bit you is that the original gist uses tabs.
13:00:51 <jle`> yeah, fixed it :)
13:01:17 <Scriptonaut> Cale, but you have to have an in if you do a block like that right?
13:01:18 <Cale> Scriptonaut: You should configure your text editor to convert tabs to spaces.
13:01:37 <Cale> nope, not if it's inside a do-block
13:01:59 <Cale> let <declarations> in <expression>  is an expression form
13:02:18 <Scriptonaut> oh
13:02:23 <Cale> let <declarations>  is a statement
13:02:41 <Scriptonaut> ah, so I could just have let, with like 5 assignments
13:02:42 <Cale> (i.e. one of the things making up the lines of a do-block)
13:02:56 * heatsink reads about Symbol
13:02:59 <heatsink> danilo2: The point of symbols is to turn literals into types.  Types are already types, so it shouldn't be necessary to turn them into symbols.
13:03:16 <Cale> yeah
13:03:40 <Cale> Scriptonaut: Which text editor are you using?
13:03:43 <Scriptonaut> vim
13:03:52 <Scriptonaut> let me show you my tab setup
13:03:59 <Cale> You should add "set expandtab" to your .vimrc
13:04:06 <Scriptonaut> https://gist.github.com/robins35/be064c84cfce8781b983
13:04:28 <Cale> Yeah, you want expandtab turned on for Haskell at least
13:04:38 <Scriptonaut> that just turns them to spaces?
13:04:40 <Cale> yeah
13:04:46 <Scriptonaut> oh, thanks
13:05:02 <fizbin> It's weird how the whole spaces vs. tabs thing has changed over my time in programming.
13:05:19 <danilo2> heatsink: You're wrong. Let's consider following use case - I want to create something like a "set on types", so I want to add or remove types to a type level list and I want to sort them according to their names. (Of course we can do this different way around, but lets stick with this simple idea). We need to convert them to type-level "strings" (or Symbols) in order to do that
13:05:43 <Scriptonaut> jle`: thanks for the gist suggestion
13:06:50 <fizbin> I remember way back around 2000 or so, some company was going to donate a whole bunch of code as open source to Debian and first posted their C formatting guidelines for contributors. Their guidelines specified using no tabs, and two (or 4? Can't remember) spaces for indenting.
13:07:39 <fizbin> This was a point of contention - the very strong opinion of Debian at the time was that to work well with the open source community, one should always indent with tabs only and let everyone set their own editor to their own preference.
13:07:42 <heatsink> danilo2, would the "set of types" you're talking about exist at the value level or the type level?
13:07:47 <Cale> ahead of their time, lol
13:08:00 <danilo2> heatsink: type level
13:08:26 <fizbin> I think it might have been Borland who wanted to do that. Can't remember that either.
13:08:40 <geekosaur> fizbin, I think python had a lot to do with that, for the same reason tabs tend to be bad news with haskell
13:08:57 <danilo2> heatsink: for example: Proxy :: Proxy '[Int,String]
13:09:02 <fizbin> Sure, tabs in a layout-sensitive language are a disaster.
13:09:29 <fizbin> But there are still some tab-only folks. E.g., the go language.
13:10:12 <fizbin> (Which accepts spaces of course, and isn't even layout-sensitive, but the gofmt tool uses tabs exclusively for indents, IIRC)
13:10:28 <heatsink> danilo2: I think you would have to set that up as a relation between types and some type-level data structures that you define
13:10:53 <heatsink> danilo2: I don't think that's doable for _all_ types, which is why the relation would be needed
13:11:25 <danilo2> heatsink: sure, I can create a simple type family, like type family NameOf (a::*) :: Symbol and generate with TH instances for each datatype defined locally, but I'm looking for more general way to do it
13:11:59 <danilo2> heatsink: of course its doable, look : data Something = ....  ; type instance NameOf Something = "Something"
13:12:01 <fizbin> geekosaur: Thing is, it isn't as though python didn't exist back then. Granted, it hadn't really blossomed yet. In 2000 it was still, what, 1.5.2?
13:12:37 <geekosaur> yes, I know, I recall perl3 and I think the first public python release coming out the same week in the 80s
13:13:13 <fizbin> 1991, actually. So almost the 80s.
13:13:19 <geekosaur> but python was not very widely used back then (and I think the main user was Red Hat, which would not have been an encouragement to Debian...)
13:14:23 <fizbin> Right. Debian was (and still is) mostly a perl shop, in the sense that it's a "shop" and not a loose confederation of true linux believers.
13:14:27 <rola> what's a free vector space? is this analogous to a free module?
13:14:45 <Cale> rola: assuming the axiom of choice, all vector spaces are free
13:14:54 <Cale> i.e. they have a basis
13:14:58 <rola> that's it?
13:15:02 <rola> well that nice
13:15:42 <fizbin> I assume that the free vector space over a set is the vector space you get if you take the set as an orthonormal basis.
13:15:55 <Cale> Not even orthonormal
13:16:09 <heatsink> danilo2: It's doable if you limit your attention to type constructors, but how would you ensure that NameOf (forall a b. a -> b -> a) ~ NameOf (forall b a. a -> b -> a) ?
13:16:20 <Cale> Just basis, you don't have the inner product operation to say what it means to be orthonormal
13:16:33 <rola> (context: the description of linear "Types and combinators for linear algebra on free vector spaces")
13:17:47 <danilo2> heatsink: right, I did not thought about it. I was thinking about something like "base name" , so for Maybe a the base name is "Maybe", for function it is "->". Anyway in general solution we could use de broglie notation to unify your example ! :D
13:17:56 <Cale> But yeah, given a set X, you can construct the free vector space on X which is simply the space of functions from X to your field of scalars F that have finite support (i.e. f(x) is nonzero for only finitely many x in X)
13:18:12 <rola> do all finite dimensional vector spaces have a basis w/o the axiom of choice?
13:18:23 <lisbeth> I am having some trouble with my script: http://arin.ga/836sGN
13:18:27 <Cale> yes
13:18:52 <danilo2> lisbeth: change putStrLn to print
13:18:58 <fizbin> rola: Isn't that how one knows that a space is finite dimensional?
13:19:07 <heatsink> danilo2: de Bruijn notation?
13:19:10 <rola> :)
13:19:13 <danilo2> lisbeth: you cannot putStrLn on non-Strings, where args is list
13:19:25 <fizbin> That is, isn't the definition of "finite dimensional" "has a finite basis"?
13:19:49 <rola> i think so
13:19:59 <danilo2> heatsink: errrr, right, sorry
13:20:16 <danilo2> heatsink: I have to be tired I think -.-
13:20:18 <heatsink> danilo2: I don't understand why the kind has to be Symbol, though.  A different kind should be okay, as long as you have NameOf and (<) for that kind
13:20:21 <Cale> I suppose you can still consider whether there are vector spaces in ZFC which are finite dimensional, but which are not free without AC.
13:21:01 <danilo2> heatsink: because you want to make the operations duroing compilation time instead of runtime
13:21:09 <Cale> But I'm fairly sure the answer is no.
13:21:31 <heatsink> No type-level stuff happens at run time
13:22:38 <Cale> Even in ZF if you only have a finite family of nonempty sets, you can build a function which selects one element of each set.
13:23:19 <heatsink> danilo2: You can define your own data types and promote them with the DataKinds extension.  They won't require computation at run time.
13:23:44 <fizbin> Cale: On a space with a finite basis, you can also use induction to show that it has a minimal basis (and is free in that minimal basis)
13:24:05 <danilo2> heatsink: I know :) I think we just went to an offtopic. I just wanted to convert types to their type name Symbol representation in the most general way :)
13:24:59 <fizbin> danilo2: *You* went offtopic? There's this conversation around you about ZF and AC with relation to vector spaces.
13:25:56 <heatsink> danilo2: I don't think there is any predefined ordering on type constructors
13:26:11 <heatsink> so you would have to use TH, or write instances for each constructor
13:27:48 <danilo2> fizbin: Oh I did not noticed that these discusions about ZF and AC are related to my question! I just thought it is different topic
13:28:08 <danilo2> fizbin: or I missunderstand something?
13:28:22 <geekosaur> that discussion isn't even about haskell much less your questio
13:28:35 <geekosaur> so offtopic :)
13:28:49 <fizbin> danilo2: My point was that the rest of the channel had swerved into much more offtopicness than you had even considered.
13:29:41 <danilo2> fizbin: heh, that's interesting! Thank you for this notice, I did not noticed that. I'm reading it right now because it seems interesting! :D
13:43:44 <Zemyla> Why does the term "skolem" make me think of skeleton golems?
13:44:23 <Hafydd> Heh.
13:45:39 <Zemyla> They're giant monsters which you don't want to have escape.
14:16:40 <erisco> there has to be something better than hunting through generated haddock docs for the function you care about
14:17:09 <erisco> oh, I guess you just ctrl+f the index?
14:17:51 <c74d> What's the normal way to match a Text value against a pattern such as a regex?
14:20:44 <ChristianS> c74d: there are several regex packages, don't know which is most popular. generally, regexes are much rarer needed in haskell than in other languages.
14:22:44 <c74d> Okay, how should I check whether a Text value is a valid hostname?
14:23:34 <bananagram> :t (id >>=)
14:23:35 <lambdabot> (a -> a -> b) -> a -> b
14:23:59 <bananagram> :t (>>= id)
14:24:00 <lambdabot> Monad m => m (m b) -> m b
14:24:48 <c_wraith> c74d: the best approach is to do an nslookup
14:24:55 <tippenein> c74d: might be helpful http://hackage.haskell.org/package/hostname-validate-1.0.0/docs/src/Text-Hostname.html
14:25:22 <c_wraith> just like the best way to check an email address for validity is to send an email.
14:26:15 <apo> c_wraith: Nonsense, you can do it without any I/O with a regex. Unless you count a bit of swapping caused by the huge regex as I/O.
14:26:56 <c_wraith> apo: I'm not sure you can validate email addresses (in their full unused complex glory) with a regex at all. :)
14:26:59 <glguy> The point is that rather than validating and hoping your validation matches reality you can actually use the value and handle the error case when it's invalid
14:27:21 <c74d> c_wraith: I mean syntactically valid, not "is it registered".
14:27:26 <c74d> tippenein: thanks!
14:28:11 <pavonia> Is there a short version of "do { x <- get; put (f x); return x }" in mtl?
14:28:17 <c_wraith> c74d: crazy things are syntactically valid, like dotless quads.
14:30:11 <erisco> pavonia, modify f >> get
14:30:27 <pavonia> That's different
14:30:40 <erisco> it is?
14:30:57 <pavonia> I want the old state, not the new one
14:31:05 <erisco> oh right, I see
14:31:13 <pavonia> I vaguely recall a modify' but I can't find any
14:31:33 <erisco> that is just a strict version
14:32:17 <glguy> pavonia: If you're using the lens package and its State operators, the << versions of the operators give back the old value
14:32:23 <erisco> :t get <* modify f
14:32:24 <lambdabot> (FromExpr a, MonadState a f, Applicative f, Show a) => f a
14:33:06 <erisco> pavonia, does that work?
14:33:28 <pavonia> Ah, that should work, thanks
14:41:07 <Zemyla> :t f
14:41:08 <lambdabot> FromExpr a => a
14:42:29 <Zemyla> Also, huh. I had opportunity the other day, while writing a parser, to make an AST GADT tagged with type information.
14:43:01 <Zemyla> Because my earlier one wasn't so tagged, and I was trying to figure out the type of parse :: AST -> ???
14:48:32 <Zemyla> :t (^)
14:48:33 <lambdabot> (Num a, Integral b) => a -> b -> a
14:56:59 <c74d> What's the proper way to apply a function to the contents of a Maybe if it's not Nothing?
14:57:45 <exio4> c74d: fmap?
14:58:55 <c74d> exio4: thanks!
15:08:52 <fresheyeball> hello folks
15:09:51 <fresheyeball> Does anyone have any experience linking haskell and C++?
15:10:08 <pharaun> a bit here yes
15:10:32 <pharaun> fresheyeball: https://github.com/pharaun/MegaHAL
15:10:33 <fresheyeball> so unfortunately I'm building on windows
15:10:53 <pharaun> i do not know bout windows but i was able to get some c++ stuff to link to a c wrapper to haskell
15:10:59 <pharaun> and got cabal to build it
15:11:11 <fresheyeball> nice
15:11:26 <fresheyeball> I need it the other way around
15:11:32 <pharaun> oh?
15:11:37 <fresheyeball> I am trying to integrate haskell into an existing C++ application
15:11:39 <pharaun> haskell into c++ ?
15:11:40 <pharaun> ahh
15:11:47 <pharaun> i have not done that yet so i am not familiar
15:11:55 <pharaun> but haskell *does* have C integration
15:12:08 <pharaun> and you should be able to use RAII with c++ for the ghc-init, do your thing, ghc-de-init
15:12:15 <fresheyeball> I did some reading on this
15:12:18 <fresheyeball> it looks doable
15:12:44 <fresheyeball> but I've not alot of experience compiling things yet
15:12:49 <pharaun> i had the same impression when i read up on that, but most of my experience is the other way (c/c++ into haskell) so i probably won't be able to help lots.
15:12:50 <fresheyeball> (just period in my career)
15:12:54 <pharaun> oh compiling?
15:12:54 <pharaun> hm
15:12:58 <pharaun> probably can try to assist
15:13:03 <pharaun> (i'm not a windows user tho)
15:13:06 <fresheyeball> that would be amazing
15:13:15 <fresheyeball> I'm trashing like crazy
15:13:18 <fresheyeball> haha
15:13:20 <pharaun> kk, what have you done so far?
15:13:31 <fresheyeball> so my goal is simple
15:13:46 <fresheyeball> so it minimal right now
15:13:50 <fresheyeball> I have one haskell file
15:13:58 <fresheyeball> CarouselReversalSpray.hs
15:14:20 <fresheyeball> and its in the same directory as the .cpp files
15:14:48 <fresheyeball> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/win32-dlls.html#win32-dlls-foreign
15:14:56 <fresheyeball> I'm trying to use these instructions
15:15:38 <fresheyeball> so I've run
15:15:51 <fresheyeball> ghc -c CarouselReversalSpray.hs
15:15:56 <fresheyeball> and it spit out some files
15:16:48 <fresheyeball> a .h a .o and a .hi
15:16:59 <fresheyeball> CarouselReversalSpray.h CarouselReversalSpray.o CarouselReversalSpray.hi
15:17:17 <pharaun> seems ok to me so far
15:17:30 <fresheyeball> the next line in the instructions has a _stub.o file
15:17:41 <fresheyeball> I don't have one of those
15:17:53 <pharaun> ghc -shared -o Adder.dll Adder.o Adder_stub.o StartEnd.o
15:17:55 <pharaun> this line? ^
15:18:00 <fresheyeball> yes
15:18:21 <pharaun> did you build the "StartEnd.c" ?
15:18:31 <fresheyeball> no
15:18:47 <fresheyeball> I want to start and stop the RTS in a different place
15:18:50 <pharaun> k
15:18:56 <fresheyeball> in the startup and shutdown of the existing application
15:19:13 <fresheyeball> for now I will be happy to see C++ and Haskell compile together
15:19:30 <fresheyeball> unless you think without the StartEnd.c file I can't get _stub
15:19:37 <pharaun> hmm nah
15:19:43 <fresheyeball> that's what I thought to
15:20:05 <fresheyeball> I also tried this
15:20:08 <pharaun> lemme poke a bit, i unfort don't have c compiler/haskell/etc on windows
15:20:28 <pharaun> i wonder where the stub is coming from
15:20:47 <fresheyeball> oh wait a sec
15:20:52 <fresheyeball> I have a CarouselReversalSpray_stub.h
15:20:57 <fresheyeball> but its a header
15:21:21 <pharaun> hmm
15:21:26 <pharaun> http://flxldn.tumblr.com/post/163596541/calling-haskell-from-excel
15:21:42 <pharaun> *seems* to indicate that "stub" is being created by the dllMain but i'm unclear on that
15:22:22 <pharaun> that makes no sense
15:23:20 <pharaun> fresheyeball: yeah the docs i'm finding seems to indicate that "ghc -c adder.hs" should generate the adder.o and adder_stub.o
15:23:29 <fresheyeball> hmm
15:23:43 <pharaun> https://github.com/conklech/haskell-xll-example
15:23:43 <fresheyeball> I'm going to blow everything away and start over
15:23:48 <pharaun> i did find a example project ^
15:24:04 <pharaun> yeah seems like they did just "ghc -c Adder.hs"
15:24:09 <pharaun> oh
15:24:12 <pharaun> they have no stub here
15:24:26 <fresheyeball> ??
15:24:27 <pharaun> fresheyeball: yeah try again
15:24:33 <pharaun> https://github.com/conklech/haskell-xll-example/blob/master/build.bat
15:24:39 <pharaun> i don't see a ref to the stub.o here
15:25:44 <pharaun> fresheyeball: ok just going to have to iterate here, sorry i'm not much more help, i just haven't gone down this routine yet
15:25:47 <pharaun> *route
15:25:58 <fresheyeball> np
15:26:03 <fresheyeball> obviously, me niehter
15:27:05 <fresheyeball> https://github.com/conklech/haskell-xll-example/blob/master/StartEnd.c#L6
15:27:40 <pharaun> fresheyeball: hmm
15:27:54 <pharaun> i guess it doesn't compile unless something needs it
15:28:08 <pharaun> so just make a simple start/end and then call the hs_start hs_end in your c++ init/deinit stuff
15:29:22 <fresheyeball> actually I just got another suspicion
15:29:43 <fresheyeball> I'm going to see if I can link directly into the .o file
15:33:30 <xnull> :t Data.Aeson.decode
15:33:32 <lambdabot> aeson-0.7.0.3:Data.Aeson.Types.Class.FromJSON a => BSLC.ByteString -> Maybe a
15:36:44 <c74d> Is there a standard function to the effect of `f p x y = if p x then x else y`?
15:37:58 <heatsink> :t bool
15:37:59 <lambdabot> a -> a -> Bool -> a
15:38:10 <danilo2> Hello! Is there any general type class that would allow me to do something like: m (n a) -> n (m a) ? for m and n being some monads in my particular example?
15:38:26 <heatsink> > bool 8 9 True
15:38:28 <lambdabot>  9
15:39:54 <jophish> danilo2: distributive
15:40:12 <bennofs> danilo2: Distributive or Traversable
15:40:13 <c_wraith> danilo2: Traversable is sort of like that
15:40:26 <bennofs> it's also a bit similar to monad transformers IIRC
15:40:27 <sdgrecv> is cloudhaskell an active project?
15:40:32 <jophish> http://hackage.haskell.org/package/distributive-0.1.2/docs/Data-Distributive.html danilo2
15:40:48 <c_wraith> sdgrecv: yes.  It really only started pretty recently
15:40:54 <bennofs> :t Data.Traversable.sequenceA
15:40:55 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:41:01 <glguy> danilo2: The answer is no, but there are other things like that that might be relevant if you had more information
15:41:18 <sdgrecv> c_wraith: yeah but their website 'recent activity' section has the last activity at august 2014
15:41:18 <jophish> :t Data.Distributive.distribute
15:41:19 <lambdabot> (Data.Distributive.Distributive g, Functor f) => f (g a) -> g (f a)
15:41:35 <danilo2> john_not_jenny, bennofs, c_wraith: hmmm I didn't know about distributive and didnt thought that Traversable is somthing like that, I'll check it out. Thank you very much!
15:41:56 <jophish> np, danilo2
15:42:55 <danilo2> glguy: ok, but it seems that sequenceA makes the job here. Strange, I should have thought about it, heh :) Thank you!
15:43:41 <glguy> Yeah, that's one of the possibly relevant ones I was talking about. What doesn't exist is the ability to do that for two arbitrary types with monad instances
15:49:04 <fresheyeball> I may be onto somethihng!
15:49:10 <fresheyeball> new compiler error
15:49:15 <fresheyeball> cannot find HsFFI.h
15:49:58 <heatsink> Are you using ghc?
15:52:05 <enthropy> even hugs supplies one of those
15:56:01 <callumacrae> either I'm tired or I just can't find a good explanation of pocklington's theorem
15:56:14 <callumacrae> is there a maths channel on freenode or will here do?
15:56:16 <callumacrae> http://mathworld.wolfram.com/PocklingtonsTheorem.html
15:56:27 <callumacrae> I just don't understand this
15:57:42 <callumacrae> and I understand the wikipedia explanation even less http://en.wikipedia.org/wiki/Pocklington_primality_test
15:59:48 <callumacrae> Right now I'm just brute forcing my isPrime function, finding the lowest prime factor and comparing it to the number https://github.com/callumacrae/learning-haskell/blob/master/src/Primes.hs#L5-L10
16:00:03 <callumacrae> it's really inefficient
16:12:09 <heatsink> callumacrae: You could try asking on mathoverflow
16:12:30 <callumacrae> i decided to go to sleep and try again when i've slept enough
16:12:34 <callumacrae> but if I still don't get it, I will
16:12:35 <callumacrae> cheers!
16:14:58 <pharaun> fresheyeball: got any further luck? :) sorry got distracted, going to be busy for a while, but feel free to ping if you need more specific help :)
16:17:33 <fredsir> I have been thinking a bit about haskell and simplicity and usefulness. I have been playing with haskell for about a year now. I really like the type system, pattern matching, syntax and the idea of the simplicity in a functional language. I like it so much I want to explore it and use it for real stuff. On the other hand, I have been doing a few things in golang the last couple of years, and although I d
16:17:39 <fredsir> on't like the language itself, their is a ...
16:17:42 <fredsir> ... simplicity and productivness in golang – both using it, but also the ecosystem and tools – that im not sure there is in haskell. But it might just be because i dont know everything about haskell, or it might be because its a right assumption. Haskells tools and ecosystem is not as simple as they should be. Any merit to this?
16:17:57 <fredsir> Am I way off?
16:19:20 <fredsir> In my mind im just feeling a utopia of usefulness and simplicity when I think of golang – aspects that I love. But are these in haskells tools and ecosystem too?
16:19:45 <fresheyeball> hmm ok
16:21:33 <fredsir> i feel its hard to tell - it might be because im just not familiar enough with haskell to experience it
16:27:30 <mr-> fredsir: You could try to check your feeling by looking at examples. Try to come up with stuff that you found useful in Go, that were not available in Haskell
16:27:44 <erisco> fredsir, I recommend you concretise your thoughts by considering exactly what it is you are trying to create
16:28:06 <fredsir> It might also be because the internet is filled with golang success-stories and there rarely is a haskell one.
16:28:46 <erisco> no language is supreme, that is a foolish thing to search for
16:28:51 <hexagoxel> is there a way to apply a function (A -> A) over a T, given `instance Data T` and T is some nested ADT containing A's at different nodes?
16:29:49 <fredsir> mr-, erisco: well, thing is, I know haskell is capable. I have written some haskell. Not as much as many, but a fair but, and I have read about what others are doing with it. But I just think there is a disconnect between haskell the really great language and what are actually being created with it and with people in its ecosystem are doing of cool stuff
16:30:37 <bennofs> Haskell's syntax is quite complex, which makes tooling more difficult
16:30:54 <erisco> why do you feel there is a disconnect? I do not know what you mean by this
16:31:12 <toblerone> whats an XML parsing library thats good? I'd like to avoid using HXT, and I've found Text.XML.Light to be pretty awkward to use. I like how small XML.Light is, but the fact that there is very little in the way of combinators makes using it tedious.
16:31:27 <fredsir> erisco: im not talking about haskell as the only language there should be. But I know its a great language, but i have mixed feeling about it, because it just doesnt have many success-stories that you hear about, and, maybe because im only a year in, but, i find that there is more friction in using the tools of haskell
16:31:35 <bennofs> But that complexity is also what allows to write code that looks nice
16:32:34 <johnw> bennofs: what is complex about Haskell syntax compared to so many other languages?
16:32:54 <exio4> I'd say it's relatively simple for being such a complex language
16:33:00 <johnw> C++ is virtually unparsable without writing what is necessary to build a real compiler
16:33:15 <bennofs> johnw: ok, you picked another language that is really complicated :=)
16:33:30 <johnw> what are you thinking of, then, Lisp or Lua?
16:33:36 <bennofs> johnw: at the other end of the spectrum would be something like Lisp or maybe Java?
16:33:38 <doomlord_1> haskell syntax isn't complicated, its' just alien compared to what most people are familiar with
16:34:04 <bennofs> johnw: just look at how difficult it is to build an indenter for haskell code
16:34:08 <doomlord_1> c++ syntax is familiar but complicated.
16:34:09 <fresheyeball> does anyone know where HsFFI.h lives on windows?
16:34:22 <erisco> fredsir, well it is unfortunate that Haskell hasn't managed to impress you more, but without more context to why you are perceiving these deficiencies I can't really say much more can I?
16:34:23 <johnw> bennofs: that's because one has several choices for what the next line means
16:34:32 <bennofs> fresheyeball: i'd guess somewhere in an include subdirectory where ghc is installed
16:34:37 <johnw> Python should be just as hard for the same reason
16:35:37 <erisco> fredsir, what tools have you tried that did not work well for you? what have you tried to build that felt too difficult? maybe we can offer help or, at the least, draw attention to what is neglected
16:35:52 <bennofs> johnw: ok, but then haskell also has quite a lot of redundancy in it's syntax. There are a lot of ways to express the same thing (let vs where, case vs multiple clauses). those just make the number of cases a tool has to deal with bigger
16:36:11 <bennofs> johnw: and then there are extensions like LambdaCase or GADTs
16:36:43 <johnw> So, I think that with the exception of a few very simple languages, all languages have this problems
16:36:59 <fredsir> erisco: just to make it clear – haskell the language have me impressed. Its everything else. But for one, cabal. Way too much problems installings stuff. Then there's the documentation. I find it concise but maybe to a fault. And then there is the lag of success stories – or showcases of really cool haskell stuff which you can learn from and be inspired from
16:37:14 <fredsir> erisco: that was a couple of examples
16:37:51 <bennofs> johnw: Well, some languages are designed with parser simplicity in mind, no? Wasn't that also part of the design goals of Java, to allow very simple parsers?
16:38:09 <johnw> ok, I just don't see why you characterize Haskell as "complex"
16:38:20 <johnw> I'd say "no harder than most languages, except those designed for simplicity of parsing"
16:38:40 <erisco> fredsir, what were you trying to install with cabal? I've had problems too but I've had similar problems with every other package manager out there, not that cabal shouldn't be perfect if it could be
16:38:49 <bennofs> I'd probably consider most languages that aren't designed for simplicty of parsing complex :)
16:38:51 <fresheyeball> found it, thank you
16:40:14 <bennofs> johnw: TBH I haven't really written a haskell parser, I just know that haskell-src-exts still has problems (or at least had when I last tried it) with some haskell code with GHC extensions
16:40:33 <johnw> there is always the GHC API
16:41:00 <erisco> fredsir, I am not sure what you are expecting with regards to success stories. Are you just interested in knowing what companies use Haskell?
16:41:25 <fredsir> erisco: oh, there have been a couple of things, but the most recent that comes to mind is lushtags. It was something with some dependencies where, well, i didn't understand why it couldnt install what it needed. Maybe it was unable to because the requirements were unsatisfiable, but it failed to communicate why it couldnt so that i could understand it
16:41:59 <dolio> Doesn't haskell-src-exts have to be able to flip on and off dozens of switches in the parser?
16:42:20 <erisco> fredsir, "cabal hell" happens, and I too wish it didn't, but I don't know much about cabal so I wouldn't be the person to talk to about it
16:42:34 <johnw> for those suffering from cabal, consider the Nix package manager
16:42:45 <dolio> That aspect seems harder than getting any fixed set of those switch settings right.
16:42:49 <johnw> it has its own learning curve issues, but at least it resolves the cabal problem
16:43:17 <erisco> for comparison though, I've had nightmares with apt, brew, npm, composer ...
16:44:04 <fredsir> erisco: its not as simple. Lets just take golang as an example again; there is every couple of weeks new articles about something cool like docker or something and, well, it just seems that people in the golang community likes to tell others about cool stuff they do and with haskell its much less. If its because people just dont want to tell about what they use haskell for, or they cant because of contrac
16:44:05 <epichero> i haven't had any issues with brew in a long time, somehow
16:44:10 <fredsir> ts or they simply not do cool stuff with ...
16:44:12 <fredsir> ... haskell, i dunno, but its much more visible in the golang community which is awesome
16:44:36 <hexagoxel> `dataMorph f o = case cast o >>= cast . f of Nothing -> gmapT (dataMorph f) o; Just x  -> x`
16:44:41 <epichero> i don't see the appeal of go
16:44:42 <hexagoxel> :t dataMorph
16:44:43 <lambdabot> (Typeable a, Data d) => (a -> a) -> d -> d
16:44:45 <erisco> okay... well can anyone help fredsir out with Haskell news channels? I am not a media kind of person
16:44:45 <bergmark> fredsir: how about haxl?
16:44:51 <hexagoxel> well.. let's see if it does what i want :D
16:45:05 <bergmark> i've seen lots of cool stuff popping up in the last year
16:45:26 <fredsir> erisco: i dont think that was cabal hell. To my understanding, cabal hell is if you have two things that require some dependency of different version and a second thing that was compiled with the first one installed, which then invalidates when the second is installed, then cabal hell occurs. That is not what happened here, im sure
16:45:26 <mr-> fredsir: have you been following the haskell reddit?
16:45:31 <johnw> fredsir: subscribe to https://new-www.haskell.org/news and  https://planet.haskell.org
16:45:38 <johnw> we tell each other about awesome stuff *all the time*
16:45:41 <fredsir> mr-: I have
16:45:47 <johnw> just beacuse you aren't seeing it, doesn't mean it isn't happening
16:45:54 <fredsir> bergmark: i dont know about, will check it out
16:45:58 <fredsir> johnw: thanks
16:47:27 <fredsir> mr-: about r/haskell, theres lots of stuff, but it just seems more like "cool haskell" things instead of cool things that are using haskell as an implementation detail. The former is cool but the latter is always cooler, imo
16:47:54 <erisco> fredsir, well, maybe "cabal hell" is that precise, but I just took it to mean "cabal aint working and Google doesn't know why"
16:48:07 <fredsir> erisco: ah, yes, indeed!
16:49:04 <epichero> cabal ain't working and google doesn't know why... I thought I'd grab Yesod and get some instant gratification to help me learn haskell... then cabal was all NOOOOOOOOOPPEEEE
16:49:06 <bennofs> fredsir: maybe https://github.com/ekmett/quine is interresting too?
16:49:38 <hexagoxel> oh, it _does_ work. neat.
16:49:45 <fredsir> bennofs: that sure looks awesome
16:50:28 <fredsir> bennofs: not to be negative, but it would have been pure bliss if it had been an article about a real game using quine – thats my whole point
16:50:39 <fredsir> bennofs: it looks neat none the less
16:50:47 <bennofs> fredsir: I think it is still WIP :)
16:50:56 <drewbert> is there anything with the compile safety of haskell, but the iteration speed of yesod?
16:50:57 <fredsir> :P
16:51:13 <drewbert> lol
16:51:18 <drewbert> sorry I brainfarted on that
16:51:23 <drewbert> is there anything with the compile safety of haskell, but the iteration speed of python**?
16:51:27 <epichero> http://elm-lang.org/ a programming language written in haskell, and derived from haskell
16:51:45 <epichero> it's a pretty "cool" project created in haskell
16:51:49 <bennofs> fredsir: there is also a breakout game in haskell, haskanoid (and it even has blog posts! and works on android)
16:52:24 <fredsir> bennofs: cool!
16:53:13 <epichero> another "cool" project https://github.com/gibiansky/IHaskell
16:53:23 <mr-> drewbert: what is iteration speed?
16:54:35 <bennofs> there are also the "standard" (because they're mentioned almost always :) examples of haskell projects: xmonad, pandoc, hoodle
16:54:48 <drewbert> mr-: I mostly do web dev, when I think of iteration speed, I think of the time between me making a change in the code, and seeing the change in the browser.  For django it's about 4 seconds.  For yesod it's about 25 seconds to 2 minutes.
16:55:01 <epichero> Boyd's law of iteration mr-?
16:55:53 <epichero> drewbert, i'm not sure how but i'm positive you can speed that up
16:56:45 <drewbert> I like to bind refresh key to my code editor and update the page pretty much update the page as I type.  I've worked on projects that had to compile for about 10 minutes before they could serve a single page (it was a huge asp.net project) and it really killed my productivity and enjoyment of programming.
16:57:04 <epichero> https://github.com/yesodweb/yesod/issues/754 is it this?
16:57:14 <bennofs> drewbert: don't know much about yesod, but do you use yesod devel?
16:57:36 <drewbert> bennofs: yes, that's the 25 seconds-ish of which I am speaking, depending on the change made.
16:57:55 <epichero> check that issue
16:58:00 <epichero> it has some tips
16:58:19 <drewbert> There are times where I would have relished 25 seconds, but I just got off a django project, and it was so fast from change to refresh that now I'm wanting more.
16:58:31 <mr-> drewbert: for me, webdev is a Rest-backend and some client code. Stuff you on the backend won't be visible anyway, and the client stuff has some watcher anyway.
16:58:45 <drewbert> epichero: I'm going to try some of the things in that.
16:59:07 <epichero> django is a sundial compared to nodejs or livecoding clojurescript
16:59:37 <drewbert> epichero: I was using nodejs to serve the django app.
17:00:43 <drewbert> epichero: would you recommend nodejs over yesod?  I've run into a few architectural issues that are going to require a rewrite and I'm thinking of just moving off of haskell.
17:04:26 <erisco> site.hs:0:0:Error:<command line>: cannot satisfy -package-id hakyll-4.6.6.0-5acd30fa38095069020245899a1d2c6d
17:04:38 <erisco> this is from ghc-mod
17:09:02 <erisco> speaking of Haskell tool friction... heh
17:10:28 <alexclark> if I have a string with escaped unicode like this "\xdcML\xe4\xdcTS!"
17:11:11 <alexclark> how can I parse that into it's letters for I can use 'all isAsciiUpper' on it?
17:11:59 <glguy> > all isAsciiUpper "\xdcML\xe4\xdcTS!"
17:12:00 <lambdabot>  False
17:12:01 <Zemyla> Woo, I think I've figured out circular programming.
17:12:22 <luite> drewbert: use nodejs with ghcjs and you get the best of both worlds ;)
17:12:29 <Zemyla> I can find and delete the maximum of a list in one pass :D
17:12:55 <drewbert> luite: is that charted territory, or would I be a pioneer?
17:13:23 <erisco> alexclark, maybe decodeString from here? http://hackage.haskell.org/package/utf8-string-0.3.6/docs/Codec-Binary-UTF8-String.html
17:13:52 <drewbert> Apparently ghcjs uses nodejs, so it's not even all that crazy an idea.
17:13:55 <luite> drewbert: ghcjs with node.js for cli apps is charted territory, for a web server not so much
17:14:26 <luite> yeah it uses node.js to run cabal scripts and template haskell
17:15:06 <alexclark> erisco: thanks, that looks like it will work!  question though, what module is that in? Sorry it's like my first day of haskell haha
17:15:27 <erisco> alexclark, utf8-string
17:16:31 <erisco> if you are reading UTF8 encoded data then you want to either read it into a ByteString or you want to decode it before it is stored as a String
17:17:10 <rpr> is there a deleteAll function?
17:17:25 <rpr> deleteAll 1 [1,1,2,1] -> [2]
17:18:18 <tromp__> > let deletAll x = filter (/= x) in deleteAll 1 [1,1,2,1]
17:18:19 <lambdabot>  Not in scope: ‘deleteAll’
17:18:19 <lambdabot>  Perhaps you meant one of these:
17:18:19 <lambdabot>    ‘deletAll’ (line 1), ‘M.deleteAt’ (imported from Data.Map),
17:18:29 <erisco> rpr, a good place to look is on Hoogle
17:18:31 <tromp__> > let deleteAll x = filter (/= x) in deleteAll 1 [1,1,2,1]
17:18:33 <lambdabot>  [2]
17:19:24 <alexclark> erisco: thanks, I'm just trying to make a test pass for exercism.io
17:19:26 <tromp__> > let deleteAll = filter . (/=) in deleteAll 1 [1,1,2,1]
17:19:27 <lambdabot>  [2]
17:19:39 <rpr> yeh i forgot about filter
17:20:21 <alexclark> https://gist.github.com/alexclarkofficial/d4058cefd055d0defc03
17:21:25 <rui1> This may be a stupid question, but your thoughts on this might help me think more clearly
17:21:36 * hackagebot persistent 2.1.1.7 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.1.7 (GregWeber)
17:22:52 <rui1> I can make a type A with a few constructors, and overload a function f with each constructor. Or make a typeclass A with a function f with a few instances
17:23:24 <rui1> Any thoughts about what to think about in choosing one option over the other?
17:23:49 <bergmark> rui1: i'd say that depends mostly if external modules/libraries should be able to extend it
17:24:20 <danilo2> Hello! Does anybody knows if there is any library allowing the creation and checking status of symlinks on windows?
17:24:34 <KaneTW> rui1: if you give a concrete example we might be able to help, it's a bit too abstract right now
17:24:36 <rasen> rui1: if you don't need ad-hoc polimorphism, there is no need in typeclasses
17:25:12 <KaneTW> if the amount of constructors/instances is known ahead of time and unlikely to change, you should use the type method
17:25:38 <KaneTW> if it's going to change or you'd want to change datatypes, use the typeclass method
17:25:39 <zauser> danilo2: you'd probably be better of using powershell for Windows sepcific symlink checks
17:25:44 <KaneTW> but that's a pretty generic answer
17:25:50 <rasen> rui1: on the other hand, if you want to squash unrelated entities in one type, that's wrong
17:26:09 <danilo2> zauser: do you mean to call powershell fro mhaskell? :(
17:26:11 <rui1> KaneTW: Well, my concrete application, I am implementing adaptive filters. Other update functions may be added in the future. But I am using it as an excuse to think about these stuff
17:26:30 <zauser> I mean, that haskell is probably not the right tool for the job ...
17:26:45 <rui1> You all seem to agreee that if it could be extended, then typeclasses is the only way
17:26:58 <KaneTW> i think you might be fine with plain functions with that
17:27:01 <rui1> Say it doesn't need to be. Why is the type option better?
17:27:02 <rasen> not only, just a better one
17:27:12 <KaneTW> less complexity
17:27:25 <rui1> Makes sense
17:27:34 <danilo2> zauser: ekhm, so Haskell is not the right tool to write multi-platform application? Should I use powershell instead?
17:28:08 <rui1> rasen, why the overloading with different constructors is not ad-hoc polymorphism
17:28:10 <rui1> ?
17:28:20 <zauser> danilo2: you said 'symlinks on windows' ...
17:28:35 <fsodi> :t fmap
17:28:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:28:53 <danilo2> zauser: yeah, because I've got no problem in checking them on Linux. The problem I've got right now is to how to handle them on Windows in the same app
17:29:07 <rasen> rui1: You can't add new constructor from other module and rewriting most functions that depend on pattern matching constructor
17:29:31 <rasen> and without rewriting*
17:30:02 <KaneTW> yeah pretty much
17:30:04 <rui1> rasen: when people talk ad-hoc polymorphism it implies it being extendable from another module?
17:30:09 <KaneTW> yes
17:30:18 <KaneTW> as long as it's exported anyway
17:30:30 <KaneTW> you can just do an instance A B where ... and have an instance that matches
17:30:43 <KaneTW> with pattern-matching you can't do that
17:31:05 <nocturne777> I have this example type: data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
17:31:07 <zauser> danilo2: I wish you good luck with that one... I would invoke the specialised symlink scripts for each platform... I don't know how closely haskell is integrated on Windows.
17:31:38 <rui1> Thanks people!
17:31:44 <danilo2> zauser: Ouch :( Ok, I'll be fighting. thank you :)
17:31:49 <rasen> rui1: no problem
17:31:50 <nocturne777> [[21]] is possible with type "[]" but "List(List 21)" is not possible with this example type
17:32:04 <nocturne777> I understand that List is a type constructor
17:32:22 <rui1> By the way, if you know of good resources about how to make best use of the type system andhigh level design tips, I'd be interested
17:32:23 <jle`> nocturne777: [[21]] is actualy (21:[]):[]
17:32:25 <nocturne777> Empty and ":-:" are value contstructor
17:32:48 <jle`> oh carry on
17:32:57 <rasen> (21 :-: Empty) :-: Empty
17:33:31 <jle`> [] is actaully also a value constructor for List
17:33:35 <jle`> er, for []
17:33:41 <jle`> confusing, isn't it?
17:33:42 <zauser> danilo2: multi-platform is always a b*tch! I do java t my day job, which makes it easier, but integrating back into the platform is always painful. Why use symlinks at all though? It's not as though the NTFS filesystem makes their management very easy?
17:34:01 <nocturne777> jle`: how does "[2]" work as syntactic sugar for 2:[] ?
17:34:36 <jle`> are you askinga bout teh compiler implementation?
17:34:52 <nocturne777> yes
17:35:04 <nocturne777> like what makes that work ?
17:35:05 <danilo2> zauser: I know your pain. I dont know why an user want to create them in windows and I dont know why user wants to use windows, but the app has to handle them.
17:35:10 <jle`> presumably it'd parse it as list syntax, as a list just containing 2
17:35:18 <jle`> and it would see that a just just containing 2 is (2:[])
17:35:20 <rasen> nocturne777: ehm.... compiler makes that work
17:35:36 <nocturne777> rasen: it's built into the compiler then
17:35:40 <rasen> yep
17:36:05 <nocturne777> I see
17:37:22 <erisco> that isn't how bash would do it ;)
17:46:02 <crvs> hi!
17:46:55 <rasen> hello
17:46:59 <crvs> just a quick question: I am fairly new into haskell (or at least in trying to use it in any serious way)
17:47:06 <rasen> go ahead
17:47:14 <crvs> and would like to know if any on has tried using Nix
17:47:22 <crvs> and what your oppinion on the matter is
17:47:47 <crvs> cabal just seems way too painful for package management
17:50:59 <zipper> crvs: It's not a package manager though.
17:51:11 <zipper> I've heard of many people here using Nix though
17:51:11 <KaneTW> i haven't had any issues with cabal with proper sandboxing, and that's pretty much how it is with other languags like python, ruby or whatever
17:51:34 <zipper> KaneTW: Same for me. I sandbox EVERYTHING!!
17:52:09 <crvs> don't you have to have a full instance of your haskell environment in each sandbox?
17:52:14 <KaneTW> no
17:52:56 <KaneTW> it can get fairly large if you have a large amount of packages but the instance is minimal
17:53:22 <crvs> guess I should actually read some more on how cabal is supposed to be used...
17:53:43 <crvs> do you have any suggestion on reading that might be interesting?
17:54:01 <drewbert> epichero: lol https://github.com/charettes/django-sundial
17:54:16 <jle`> crvs: just read up on how sandboxing works :)
17:54:31 <KaneTW> you could browse around https://wiki.haskell.org/Cabal probably
17:54:33 <zipper> crvs: I guess you can look at cabal sandboxes.
17:54:51 <crvs> I have been successfully managing to use xmonad for the past two years or so, but now I would like to go deeper into the rabit hole
17:54:56 <KaneTW> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html etc
17:54:57 <drewbert> sandboxing is so crucial.
17:56:31 <crvs> very well, I will look those up
17:57:35 <crvs> aha, the summary sums it up pretty nicely :|
17:57:41 * crvs is feeling stupid
17:59:05 <zipper> HashDB users in the house?
18:00:00 <zipper> I can't log a user in after I sign them up. Here is my SignUp.hs https://github.com/urbanslug/payroll-web/blob/auth/Handler/SignUp.hs
18:00:20 <zipper> Here is my Foundation.hs https://github.com/urbanslug/payroll-web/blob/auth/Foundation.hs
18:07:44 <erisco> I could shoot this thing...
18:08:02 <erisco> ghc-pkg list | grep Cabal  this shows version 1.18 but  cabal --version  shows 1.20
18:08:14 <erisco> how do I fix this?
18:08:39 <erisco> I just want version 1.18
18:08:47 <Lokathor> fredsir, i know this conversatoin was a while back, but in terms of haskell tooling vs haskell the language, haskell on windows is not particularly friendly
18:09:40 <rui1> erisco: "which cabal" probably shows the path to the cabal you want removed perhaps?
18:10:28 <Lokathor> erisco, note that cabal the program and Cabal the library are differnet
18:10:57 <Lokathor> and that, as i understand it, each particular version of GHC relies closely on particular versions of the Cabal library
18:11:17 <erisco> which I have probably messed up somehow
18:11:26 <erisco> this is all incredibly confusing...
18:11:31 <erisco> anyways, Cabal the library is 1.20
18:11:42 <erisco> according to cabal --version
18:11:51 <Lokathor> which means you have cabal the program 1.20 somewhere as well most likely
18:11:55 <nocturne777> jle`: how come this is legal based on the definition of above List type? "(21:-:Empty):-:Empty"
18:12:28 <nocturne777> left side of ":-:"  is supposed to be simply a value
18:12:49 <shachaf> It is a value.
18:12:55 <Lokathor> fredsir, in fact, i'd say that java and haskell give almost polar opposite experiences on windows. One is a good language with poor tools, and one is a poor language with good tools.
18:13:25 <nocturne777> I meant value as in 3::Int
18:14:50 <nocturne777> shachaf: what I am trying to say is that left side of :-: is not (List a)
18:14:59 <Lokathor> erisco, what you might do is delete all verions of cabal from your system and then just get a binary package of the newest ones from the website
18:15:05 <shachaf> Lokathor: In this case it is.
18:15:08 <shachaf> Er, nocturne777:
18:15:22 <shachaf> You have a list of lists.
18:15:45 <Lokathor> https://www.haskell.org/cabal/download.html
18:15:53 <nocturne777> shachaf: yes, I am aware of that
18:16:21 <shachaf> Instead of saying a, say Int.
18:16:27 <Lokathor> nocturne777, 21:-:Empty is a normal value just like 3 is
18:16:33 <shachaf> (21 :-: Empty) :: List Int
18:16:45 <shachaf> ((21 :-: Empty) :-: Empty) :: List (List Int)
18:16:48 <erisco> Lokathor, that sounds like a not-so-great idea
18:17:06 <erisco> I got ghc from the Ubuntu repos, and I don't want to mess with anything else
18:17:10 <erisco> in fear I break everything oO
18:17:53 <erisco> my ghc version is 7.8.3, so whatever Cabal version corresponds to that is what I need
18:17:55 <Lokathor> erisco, oh, well then i'd uninstall using your package manager, delete any other versions left over, and the reinstall from the package manager
18:18:00 <erisco> but I don't know how to figure that out
18:18:52 <Lokathor> though, i'll say that, with debian the repos are always quite a bit behind, so i chose to just unpack some .tar.gz files on my linux computer. Not sure if Unbuntu is the same or not
18:19:42 <Hijiri> if you're using debian testing, ubuntu is more behind
18:25:34 <erisco> uhh I guess I was not using Ubuntu's GHC because Ubuntu doesn't have 7.8.3 in its repo
18:25:49 <erisco> but I did have 7.6 something installed from Ubuntu, which I uninstalled and now ghc-mod feels happier
18:25:59 <syndarion> Hi all! I have a list with tuples representing numbers and their power, and I would like to get the product of these numbers, so I wrote a little foldl, which works for a small list, but when the list gets bigger, it return a negative number, what could be the cause of this?
18:26:45 <syndarion> *returns
18:26:46 <max3> why doesn't this work [x*2 | x <- [1,2..], x<=10]
18:27:25 <syndarion> max3: because it goes on infinitely. You should use takeWhile (<=10) [1..].
18:27:49 <syndarion> Your list comprehension checks for every number of the infinite list.
18:27:50 <max3> i don't understand why the predicate doesn't select from the infinite list
18:28:00 <max3> ah
18:28:14 <max3> good answer
18:28:31 <max3> thank you
18:28:55 <Zer000> Hey guys how do I write the main function here http://dpaste.com/1GAF3HT to run both of the quickcheck tests?
18:29:21 <syndarion> Glad I could help.
18:30:11 <erisco> because it was picking up the ghc-mod for the wrong ghc...
18:30:14 <erisco> herpy derpy
18:31:30 <max3> syndarion: so the predicate is run on the bound x in x<-[1,2..]
18:31:32 <max3> is that correct
18:31:39 <max3> and then the 2*x is applied?
18:32:04 <mac10688> Can someone tell me why this function doesn't compile?
18:32:05 <mac10688> Collatz :: (Integral a) => a -> [a]
18:32:05 <mac10688> Collatz | x == 1 = []
18:32:05 <mac10688> Collatz | even x = x:Collatz (x / 2)
18:32:05 <mac10688> Collatz | odd x = x:Collatz ((x * 3)  + 1)
18:32:12 <KaneTW> please use a pastebin
18:32:16 <mac10688> ok
18:32:57 <KaneTW> first of all, x is not defined anywhere
18:33:28 <mac10688> http://pastebin.com/wQSAKDqV
18:33:35 <KaneTW> second, functions are lowercase in haskell
18:33:41 <mac10688> oh
18:34:04 <KaneTW> types are uppercase like that and case matters
18:34:26 <mac10688> gotcha
18:35:27 <nocturne777> Lokathor: if it is so what's the difference betwen "a" and "List a" in :-:  ?
18:36:06 <nocturne777> does "a" mean it the value could be anything?
18:36:12 <Lokathor> yes
18:36:36 <nocturne777> which includes 2:-:Empty
18:36:39 <Lokathor> 'a' in this situation is not a concrete type, it's a paramater
18:36:47 <Lokathor> yes
18:36:52 <nocturne777> ok, makes sense now
18:36:57 <Lokathor> you can have [Char] or [[Char]]
18:41:54 <jle`> nocturne777: whatever is on the left side of the (:-:), the right side has to be a list of them
18:42:04 <jle`> a :-: List a
18:42:08 <jle`> Char :-: List Char
18:42:18 <jle`> Bool :-: List Char
18:42:22 <shachaf> "Char :-: List Char" isn't a thing that makes sense. :-(
18:42:26 <jle`> er, List Bool >_>
18:42:34 <shachaf> "x :-: xs", where x :: Char and xs :: List Char
18:42:41 <jle`> sorry, yeah :) must be slow today
18:43:02 <jle`> x :-: xs;   x can be Bool and xs can be List Bool
18:43:12 <jle`> x can be (List Char), and xs can be List (List Char)
18:43:20 <nocturne777> I see
18:43:30 <jle`> x can be List (List a), and xs can be List (List (List a))
18:43:31 <nocturne777> thanks for the thorough explanation, jle` :)
18:44:13 <jmcarthur> this seems to have been going on long enough that i can't find where (:-:) was defined
18:44:17 <jmcarthur> what is it?
18:44:20 <jle`> np, sorry for the error. credit to others too here
18:44:56 <nocturne777> jmcarthur: data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
18:46:12 <Zer000>  anyone?
18:47:37 <jmcarthur> Zer000: http://dpaste.com/1VTMRR4
18:52:05 <Zer000> jmcarthur, hey thanks!
19:01:43 <fresheyeball> hey folks
19:01:48 <dami0> hey
19:01:49 <fresheyeball> Question
19:02:10 <fresheyeball> I am trying to call haskell code from C++
19:02:17 <dami0> oh, i only started with haskell a few hour ago
19:02:20 <fresheyeball> catch is
19:03:02 <fresheyeball> its visual C++
19:03:10 <fresheyeball> and so I have to go through a dll
19:03:37 <dami0> oh, i don't even use windows
19:03:46 <fresheyeball> drats
19:07:38 <dami0> fresheyeball: does visual C++ not allow you to just compile binaries?
19:07:55 <dami0> fresheyeball: iirc .dll stands for dynmically loaded library
19:08:12 <fresheyeball> gcc .o files are incompatible
19:08:27 <dami0> those are object files
19:08:37 <fresheyeball> yes
19:08:50 <fresheyeball> according to the documentation
19:08:54 <fresheyeball> there are 2 ways to do this
19:09:04 <dami0> i've never used object files directly. i used the compiled binaries
19:09:10 <fresheyeball> one is to compile to .c as an intermidiate step
19:09:20 <fresheyeball> or to make a .dll
19:10:51 <rpr> what is throwIO equivalent that accepts a string?
19:13:33 <rpr> I just want to kill the progrmam with error  message without thinking much about it.. and for some reason I am suppose to use throwIO instead of error, right?
19:13:41 <rpr> (why?)
19:14:15 <enthropy> calling error doesn't make the program quit in your case?
19:15:07 <rpr> let me try
19:15:23 <enthropy> error "something is wrong" :: IO () -- is an async exception
19:15:35 <rpr> async exception?
19:15:50 <enthropy> as in it gets thrown when the result gets forced
19:16:11 <rpr> and when does it get forced
19:16:14 <fresheyeball> ok so the error I have is weird
19:16:17 <enthropy> so that's one reason to prefer throwIO... but I don't think it matters
19:16:19 <rpr> when we evaluate it?
19:16:21 <fresheyeball> 1>c:\program files\haskell platform\2014.2.0.0\lib\include\Stg.h(463): error C2143: syntax error : missing ')' before ':'
19:16:41 <fresheyeball> its telling me Stg.h has a syntax error
19:16:44 <fresheyeball> is that possible?
19:16:59 <enthropy> rpr: in the Control.Exception docs the explanation around "evaluate" might be helpful
19:17:22 <rpr> is there throwIO equivalent that acepts a string, when I don't want to search for a suitable Exception type?
19:17:47 <bitemyapp> @ty error
19:17:48 <lambdabot> [Char] -> a
19:17:59 <bitemyapp> rpr: not a great idea.
19:18:14 <rpr> why not?
19:18:15 <enthropy> well error makes an exception that's ErrorCall
19:18:23 <bitemyapp> s/not a great/bad/g
19:18:28 <bitemyapp> no litoting this one.
19:18:52 <rpr> wht is bad about quiting with an error message?
19:23:05 <rpr> > throwIO (ErrorCall "bye")
19:23:06 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
19:23:06 <lambdabot>    arising from a use of ‘M551494758604722296822053.show_M5514947586047222968...
19:23:06 <lambdabot>  The type variable ‘a0’ is ambiguous
19:23:23 <rpr> ok I'll use that
19:29:36 <fresheyeball> anyone else seen a syntax error in stg.h ?
19:29:41 <fresheyeball> I'm stumped
19:30:50 <alexclark> Not in scope: `main'
19:30:50 <alexclark>     Perhaps you meant `min' (imported from Prelude)
19:31:05 <alexclark> has anyone seen this error?  why am I getting this?
19:31:20 <shachaf> You're in a better position than anyone else here to answer that.
19:31:33 <alexclark> i guess the code helps
19:32:02 <mac10688> Is it easy to find haskell shops?
19:32:21 <rpr> ioMaybeCrash :: IO (Maybe a) -> String -> IO a   <- so I also need maybeCrsh, and eitherCrash, and ioEitherCrash? or is there a better way to handle this? (maybe with typeclasses?)
19:32:24 <alexclark> https://gist.github.com/alexclarkofficial/bf898ca60708f252f359
19:34:05 <shachaf> alexclark: OK. You're trying to run accumulate.hs, but accumulate.hs doesn't define "main".
19:34:12 <shachaf> So you get a "main is not in scope" error.
19:34:37 <alexclark> shachaf: wow im dumb haha, thanks!
19:34:59 <alexclark> runhaskell -Wall accumulate_test.hs works way better
19:39:18 <dami0> might as well just alias any compiler that supports -Wall to `comp -Wall`
19:40:51 <mac10688> https://gist.github.com/mac10688/653953f1b1c11f39dcb0
19:41:23 <Zemyla> Woo, it works!
19:41:26 <Zemyla> > (fix . flip ((`foldr` ([], empty)) . (uncurry .) . (`ap` ap (flip . ((<|>) .) . fmap . max) Just) . ((flip . (((.) . (,)) .)) .) . flip (maybe id . ap ((.) . (`maybe` const id) . (:)) ((guard .) . (==))) . snd)) [4, 1, 3, 9, 2, 5, 8]
19:41:28 <lambdabot>  ([4,1,3,2,5,8],Just 9)
19:41:39 <mac10688> I have a function that returns a list like this [(0*),(1*)(2*)]
19:42:00 <mac10688> what is an easy way to iterate over each entry and apply a number
19:42:28 <Zemyla> mac10688: fmap ($ 5) [(0*), (1*), (2*)]
19:42:35 <mac10688> oh
19:42:47 <Zemyla> > fmap ($ 5) [(0*), (1*), (2*)]
19:42:48 <lambdabot>  [0,5,10]
19:43:09 <mac10688> COOOL! thanks guys
19:43:21 <mac10688> glad I asked, I was afraid it would be something I had seen before
19:43:40 <enthropy> rpr: yes you can write a class FlipFromJust x y | x -> y where flipFromJust :: x -> String -> y, and have instances that give those three functions the same name
19:44:18 <enthropy> (but that's a bad name, so please pick another)
19:46:42 * hackagebot glib 0.13.1.0 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.13.1.0 (HamishMackenzie)
19:47:32 <seafood> Where is the appropriate place to file  a ticket about a GHC standard library (unix in this case). Is it GHC Trac? Or elsewhere?
19:47:49 <seafood> This bug prevents me from building GHC.
19:51:42 * hackagebot cairo 0.13.1.0 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.13.1.0 (HamishMackenzie)
19:58:05 <rpr> I have two actions that return IO (Maybe String). is there  a neat way to chain them, so that the second is executed if the first one returned Nothing?
19:58:29 <rpr> if the first one returned something that should be returned, without executing second action
19:59:52 <Scriptonaut> is there anything in haskell that will accomplish this? (3, _) `elem` [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]
20:00:15 <Scriptonaut> I want to see if (3, _) is an element of the list, where _ can be anything
20:01:09 <rpr> > 3 `elem` map fst [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]
20:01:10 <lambdabot>  True
20:01:32 <Scriptonaut> ooh smarty pants
20:01:58 <gfixler> > any ((== 3) . fst) [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]
20:02:00 <lambdabot>  True
20:02:16 <rpr> a lot of ways to do it
20:02:30 <gfixler> `elem` may be faster - not sure
20:02:48 <erisco> with Hakyll how can I coalesce multiple CSS files into one?
20:03:12 <Scriptonaut> basically, I have a list of elements. I check if x is an elem of the list, if so I want that index
20:03:18 <erisco> it seems that Hakyll only lets you do one-to-one mappings with files -- at least that is the extent of what I can find examples for
20:03:29 <Scriptonaut> actually, I just thought of a way easier way to do this
20:04:51 <rpr> > findIndex ((==3) . fst) [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]
20:04:52 <lambdabot>  Just 2
20:04:53 <erisco> ah, it looks like you use "create" which is actually demonstrated in the default site
20:04:54 <erisco> my bad
20:05:15 <Scriptonaut> this is probably really simple, but my minds having a hard time
20:05:24 <Scriptonaut> If I gave you, [2, 3, 8, 9]
20:05:31 <Scriptonaut> and you have a list full of stuff
20:05:52 <Scriptonaut> how would you return [l !! 2, l !! 3, l !! 8, l !! 9]
20:06:06 <Scriptonaut> because the length of both the index list and the list itself will be different each time I call it
20:06:24 <rpr> map should do it
20:06:28 <solatis> hmmm i'm trying to debug a socket/network error in my application, and i need to be "in between" two applications and monitor all the traffic
20:06:34 <solatis> does anyone know a good windows tool to do this?
20:06:36 <solatis> (i'm on windows)
20:06:56 <gfixler> Scriptonaut: map (l !!) [2, 3, 8, 9]
20:07:07 <Scriptonaut> nice, thanks
20:07:54 <gfixler> > let l = "Scriptonaut" in map (l !!) [2,3,8,9]
20:07:55 <lambdabot>  "riau"
20:10:07 <michaelt> rpr: you should be able to do this with e.g. liftM2 mplus or (<|>) the like   ; if the IO (Maybe x) 's were wrapped as MaybeT, it would just be mplus or <|>
20:11:37 <nisstyre> I apologize if the answer to this is obvious, but what's the pattern for writing to a variable with STM but blocking until the current value is consumed?
20:11:54 <nisstyre> Not sure how to google for it, I want something like Racket's mailboxes I think
20:12:03 <rpr> > liftM2 mplus (return Nothing) (return (Just 10))
20:12:05 <lambdabot>  No instance for (GHC.Show.Show (m0 (Data.Maybe.Maybe a0)))
20:12:05 <lambdabot>    arising from a use of ‘M381315641312458361723124.show_M3813156413124583617...
20:12:05 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
20:12:26 <rpr> nice thnks.. (works in ghci)
20:12:32 <rpr> thanks
20:12:58 <dami0> lambdabot: i've had that when i tried to divide mod 0 2 by 2
20:14:15 <nisstyre> er actually channels, not mailboxes
20:16:21 <nisstyre> I guess transactional channels are probably what I want, derp
20:30:11 <xnull_> > (0 % 2) / 2
20:30:12 <lambdabot>  0 % 1
20:31:04 <xnull_> :t %
20:31:05 <lambdabot> parse error on input ‘%’
20:31:10 <xnull_> :t (%)
20:31:11 <lambdabot> Integral a => a -> a -> Ratio a
20:31:25 <xnull_> @src (%)
20:31:25 <lambdabot> x % y = reduce (x * signum y) (abs y)
20:32:24 <LordBrain> @src reduce
20:32:24 <lambdabot> reduce _ 0 = undefined
20:32:24 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
20:32:24 <lambdabot>     where d = gcd x y
20:32:41 <michaelt_> @src reduce
20:32:42 <lambdabot> reduce _ 0 = undefined
20:32:42 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
20:32:42 <lambdabot>     where d = gcd x y
20:32:50 <Hafydd> @src gcd
20:32:50 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
20:32:50 <lambdabot> gcd x y = gcd' (abs x) (abs y)
20:32:50 <lambdabot>    where gcd' a 0 = a
20:32:50 <lambdabot>          gcd' a b = gcd' b (a `rem` b)
20:33:22 <Hafydd> That gets Euclid's seal of approval.
20:33:22 <michaelt_> whoops, sorry LordBrain that was beneath the fold here ...
20:33:36 <xnull_> L8D: i heard your nick being referred to elsewhere today
20:35:26 <xnull_> :t Data.Aeson.decode
20:35:27 <lambdabot> aeson-0.7.0.3:Data.Aeson.Types.Class.FromJSON a => BSLC.ByteString -> Maybe a
20:42:23 <Scriptonaut> can anyone tell me why it says on line 6 that it's expecting a 't -> [t]', but I'm giving it a [t]: https://gist.github.com/robins35/bdf7224bee425588ca54
20:44:09 <Rotaerk> Scriptonaut, why are you passing "init" two parameters in line 6?
20:44:51 <Scriptonaut> I'm not
20:44:55 <Scriptonaut> I'm passing it one, indices
20:45:03 <Scriptonaut> (n-1) is a param for nextIndices
20:45:22 <Scriptonaut> I don't want nextIndices to think init is the param I'm passing, the param I want to pass to it is (init indices)
20:46:05 <Rotaerk> Scriptonaut, that's not what's happening.  f $ g a b == f (g a b) != f (g a) b
20:46:33 <Scriptonaut> so how would you write it?
20:47:02 <Rotaerk> partIndices = nextIndices (init indices) (n - 1)
20:47:06 <Scriptonaut> I thought $ just evaluated things to the right before things to the left
20:47:06 <Rotaerk> is that your intent?
20:47:16 <erisco> I am trying to figure out why my Hakyll Rule simply generates an empty style.css file http://lpaste.net/121354
20:47:28 <Scriptonaut> so f $ g a b would be f $ (g a) b, if g only took one param
20:48:01 <Scriptonaut> yes
20:48:03 <Rotaerk> Scriptonaut, $ causes the entirety of the expression to the right to be considered a parameter to the function on the left
20:48:12 <Scriptonaut> I tend to use $ a lot becuase it's easier
20:48:12 <monochrom> no, the parser doesn't count arity. the parser simply looks at precedences and parenthesis. so know your precedences. no shortcut.
20:48:44 <monochrom> for example $ gets a low precedence. know this.
20:49:19 <Scriptonaut> ah, alright, good to know
20:49:58 <dolio> f $ g a b is the same as f $ (g a) b. Just not the same as f (g a) b.
20:55:27 <Scriptonaut> got another problem, says line 10 it expects a [Int] -> [t], but I'm giving it [[a]]. https://gist.github.com/robins35/bdf7224bee425588ca54
20:55:47 <Scriptonaut> I'll gist entire error
20:55:59 <dolio> $ is lower precedence than :
20:56:08 <Scriptonaut> https://gist.github.com/robins35/3ed81b3a0730fb707dc5
20:56:21 <dolio> So that's parsing as: (combi indices : getCombis) $ (nextIndices indices n)
20:56:46 <Rotaerk> haskell can be quite the rabbit hole...
20:57:40 <tommd> Yes, but it ends at GHC core.  Don't try to understand the assembly, instead only try to realize the truth.
20:58:04 <Scriptonaut> thanks guys
20:58:26 <Scriptonaut> so far the majority of my errors occur do to the damn precedence of expressions
20:58:31 <Scriptonaut> or, operators
20:58:58 <Scriptonaut> I don't want to have to remember the precedence level of several dozen operators, but at the same time I don't want the code to look like lisp with a million parens
20:59:15 <michaelt_> Scriptonaut: I think that's typical, it goes away after a couple of weeks.
20:59:18 <Rotaerk> tommd, I suppose it's more of a reverse rabbit hole, in the sense that I was thinking of
20:59:34 <Scriptonaut> I've been doing haskell for maybe 3 weeks, but only like 20 minutes a day
20:59:42 <Rotaerk> the abstractions upon abstractions
20:59:56 <Scriptonaut> trying to get more comfortable with it before learning monads, on 26 right now: https://wiki.haskell.org/99_questions/21_to_28
20:59:57 <Rotaerk> learning about data kinds and, at the moment, vinyl
21:00:06 <fayy> Scriptonaut: try using an IDE that will tell you your mistakes as you type :)  I was using Atom + Haskell IDE
21:00:23 <Scriptonaut> I use vim, I'm sure there's a plugin
21:00:37 <michaelt_> michaelt_: I remember just using both operators and parentheses a lot, and then hlint would tell me what parens I could do without.
21:01:05 <michaelt_> Scriptonaut: somehow I addressed that remark to myself not you .
21:01:40 <Scriptonaut> haha
21:02:15 <fayy> michaelt_: enabling hlint on existing software can be a huge productivity loss :D
21:05:20 <michaelt_> I wonder if there's some convenient hlint integration with vim
21:05:43 <rpr> is there timeout function for a thread? launch a thread with some IO action, wait until timeout expires, and if it does kill the thread and return Nothing (otherwise return whatever the function returned)
21:13:00 <michaelt_> rpr: maybe it'll be easier to define one if you use the async library. consider waitEitherCancel :: Async a -> Async b -> IO (Either a b) and similar functions ; here the second Async thing would just be a timer, or am I confused?
21:13:43 <rpr> I don't know.. I haven't used Async. I'll check it out
21:16:44 <rpr> with forkIO I would need to use something like MVars?
21:19:06 <michaelt_> rpr: I was wondering if that might not be the most convenient way to express it with Control.Concurrent.  The action is supposed to put ; the timer then tries to take; if it fails then you get nothing. But that wouidn't end early
21:22:00 <michaelt_> rpr: but I think race (threadDelay mytimout >> return Nothing) (fmap Just myio)  would give the desired result without explicit thread forking
21:24:59 <rpr> is race an actual function, or? I can't find it on hoogle
21:25:46 <michaelt_> its in Control.Concurrent.Async  from `async` .  This is a maximally reputable library.
21:25:55 <rpr> ah
21:26:03 <rpr> that is a neat solution
21:33:48 <michaelt_> rpr: oh that should have been race (threadDelay mydelay) myio :: IO (Either () a)  -- with the obvious conversion to IO (Maybe a)
21:36:49 <fresheyeball> I figured out the thing
21:36:50 * hackagebot hpc-coveralls 0.9.0 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.9.0 (killy971)
21:36:53 <fresheyeball> https://github.com/Fresheyeball/haskell-from-visual-cpp-minimal-
21:37:00 <fresheyeball> if that helps anyone
21:40:14 <rpr> :t race (threadDelay (timeout * 1000)) act <&> either (const Nothing) Just
21:40:16 <lambdabot> Not in scope: ‘race’
21:40:16 <lambdabot> Not in scope: ‘threadDelay’
21:40:16 <lambdabot> Not in scope: ‘timeout’
21:42:12 <mariothemad> Has anyone used the Haskell webDriver for Selenium RC?
21:42:24 <mariothemad> I'm having issues with XPaths
21:42:42 <rpr> funny how I automatically used <&>, without even thinking about using <$>. probably because I use >>= a lot
21:43:02 <rpr> but <$> would work just as well
21:43:16 <rpr> readability wise
21:48:02 <michaelt_> rpr: right, that's what I was thinking
21:48:11 <fayy> mariothemad: in my experience every selenium client & driver is mildly buggy
21:48:17 <statusbot> Status update: www.haskell.org going down for maintenance. we should be back shortly. -- http://status.haskell.org
21:48:31 <fayy> mariothemad: post a gist so we can at least look at it!
21:48:32 <mariothemad> fayy: ughh
21:48:35 <discus> what drugs were Graphics.Win32 developers on when they thought wM_SHOW is a good naming convention?
21:48:43 <mariothemad> fayy: ok! Good idea.
21:48:57 <fayy> I've been doing a lot of xpath lately, I actually like it @_@
21:49:34 <fayy> I've opened selenium bugs on chrome driver, node.js clients, & python clients :(
21:49:47 <statusbot> Status update: www system reboot complete. -- http://status.haskell.org
21:50:36 <enthropy> discus: probably it follows C as close as possible (which has a WM_SHOW?)?
21:51:44 <discus> enthropy: it looks like WM_SHOWs retarded step child
21:52:20 <discus> what is wrong with wm_show? or wmShow.
21:53:15 <discus> or even cWM_SHOW
21:53:16 <mariothemad> fayy: i'm just going to spit out the CSS path and XPath that chrome gives me
21:53:47 <mariothemad> "#waitinglistprofileGridRow1 > td:nth-child(1) > a"
21:53:48 <discus> I cant think of an uglier convention than wM_SHOW
21:53:51 <michaelt_> rpr: this looks okay, http://hackage.haskell.org/package/unbounded-delays-0.1.0.9/docs/Control-Concurrent-Timeout.html a bit elaborate
21:54:06 <mariothemad> "//*[@id="waitinglistprofileGridRow1"]/td[1]/a"
21:54:29 <mariothemad> ignore outermost quotes
21:54:54 <michaelt_> rpr: oh wait, there's System.Timeout, I kept thinking, "what is this timeout I'm thinking of '
21:55:17 <michaelt_> rpr https://hackage.haskell.org/package/base-4.7.0.2/docs/System-Timeout.html
21:56:05 <rpr> oh well.. wasted time writing a function that already exists. but at least i found out about async
21:56:31 <rpr> thanks again
21:56:52 * hackagebot MonadCompose 0.8.0.0 - Methods for composing monads.  http://hackage.haskell.org/package/MonadCompose-0.8.0.0 (JamesCandy)
21:57:35 <michaelt_> rpr: yes, async is certainly good. Sorry, I first looked for 'timeout' in Control.Concurrent then other ideas set in.
21:58:00 <fayy> mariothemad:  what's the error?  paste it to gist.github.com -- also I generally avoid [n] and :nth-child(n) because they break easy when the layout changes
22:01:58 <mariothemad> fay: ok...this is weird...I can't find the relevant element in the page source...
22:04:07 <michaelt_> rpr: race and concurrently are immediately intelligible and desirable even before you think throught that Async a business
22:04:15 <mariothemad> fay: the reason why I'm going to have to do nth child is because I need to click on the first cell of a table...
22:04:24 <michaelt_> *think through*, rather
22:04:26 <mariothemad> fay: if it breaks it breaks
22:05:29 <rpr> I did look in Control.Concurrent. kind of odd that timeout sits in its own module
22:11:30 <michaelt_> rpr: yes, the documents make the relationship clear, but I guess it made sense to separate it out.
22:21:53 * hackagebot hwsl2 0.3.0.1 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.3.0.1 (srijs)
22:25:06 <ttt_fff> data Loc = Loc Int Int ; data Magic = Magic Text Loc Loc -- it's basically a piece of text, from a file, with its start-end/location tagged; what's a good name for such Text? TaggedText? LocatedText? ... ?
22:25:09 <ttt_fff> I can't think of a good name.
22:25:33 <ttt_fff> I want some name to describe what it is.
22:25:35 <L8D> does anyone know an idiomatic way to represent integers as recursive data structures?
22:25:45 <L8D> like peano numerals
22:29:36 <ttt_fff> yeah
22:29:45 <ttt_fff> Nat = Zero | S Nat
22:30:09 <L8D> that's peano numerals
22:30:15 <L8D> natural numbers
22:30:19 <ttt_fff> yeah
22:30:19 <L8D> not integers
22:30:30 <ttt_fff> Nat' = One | S Nat
22:30:37 <ttt_fff> Int = Zero | Pos Nat' | Neg Nat'
22:30:39 <L8D> ?
22:30:42 <L8D> that's not idiomatic
22:30:51 <L8D> since
22:30:55 <L8D> well
22:31:02 <L8D> One | S Nat
22:31:02 <ttt_fff> Checkmate.
22:31:06 <L8D> that's a bit cheating
22:31:11 <L8D> it's still not idiomatic
22:31:18 <ttt_fff> Cheaters never win, unless they cheat big.
22:31:22 <L8D> since pattern matching becomes complicated as hell
22:31:24 <ttt_fff> Then they're too big to fail.
22:32:36 <L8D> plus Zero x = x
22:32:50 <L8D> plus (Pos x) (Pos x) = x + x
22:33:00 <L8D> plus (Neg x) (Neg x) = Neg (x + x)
22:33:13 <L8D> plus (Pos x) (Neg x) = ???
22:33:50 <ttt_fff> plus (Pos x) (Neg y) = case cmp x y of Eq => Zero, Lt => Neg(y-x), Gt => Pos(x-y)
22:34:02 <ttt_fff> where +- is assumed to be defined on Nat'
22:34:04 <glguy> L8D: The "idiomatic" thing would not be to represent integers as an ADT, but for an example of how to tackle this you can look at how it's done in the agda standard lib
22:34:05 <glguy> https://github.com/agda/agda-stdlib/blob/master/src/Data/Integer.agda
22:34:14 <gcganley> L8D: Eq on the arg type?
22:34:29 <gcganley> maybe Ord actually...
22:35:04 <ttt_fff> cmp returns one of Eq, Lt, Gt
22:35:12 <ttt_fff> representing ==, < , >
22:37:23 <L8D> plus (Pos x) (Neg y) = ord Zero (Neg (y - x)) (Pos (x - y)) (compare x y)
22:37:42 <gcganley> :t ord
22:37:43 <lambdabot> Char -> Int
22:37:45 <gcganley> wat
22:37:50 <L8D> wait
22:38:03 <L8D> there's a function that is to Ord as maybe is to Maybe
22:38:31 <L8D> @h a -> a -> a -> Ord -> a
22:38:31 <lambdabot> Maybe you meant: hackage haskellers help hitchcock hoogle hoogle+ v @ ? .
22:38:40 <L8D> @hoogle a -> a -> a -> Ord -> a
22:38:44 <lambdabot> Warning: Unknown type Ord
22:38:44 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex4 :: a -> a -> a -> a -> Vertex4 a
22:38:44 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector4 :: a -> a -> a -> a -> Vector4 a
22:38:49 <mniip> @hoogle a -> a -> a -> Ordering -> a
22:38:49 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex4 :: a -> a -> a -> a -> Vertex4 a
22:38:49 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector4 :: a -> a -> a -> a -> Vector4 a
22:38:49 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord4 :: a -> a -> a -> a -> TexCoord4 a
22:39:04 <L8D> -.-
22:39:08 <L8D> maybe it's in idris
22:39:26 <gcganley> could yhis work
22:39:33 <mniip> pattern matching on Ordering isn't as bad
22:39:37 <L8D> @hoogle Ord b => a -> a -> a -> b -> b -> a
22:39:38 <lambdabot> GHC.IO.Buffer Buffer :: RawBuffer e -> BufferState -> Int -> Int -> Int -> Buffer e
22:39:38 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec vertexAttrib4 :: VertexAttribComponent a => AttribLocation -> a -> a -> a -> a -> IO ()
22:39:38 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec vertexAttrib4I :: VertexAttribComponent a => AttribLocation -> a -> a -> a -> a -> IO ()
22:39:42 <gcganley> @hoogle Ord a => b -> b -> Ord a -> b
22:39:43 <lambdabot> Warning: Unknown type Ord
22:39:43 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
22:39:43 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
22:40:06 <gcganley> nope
22:42:14 <mniip> wouldn't having Nat start at 0 be better?
22:43:39 <darkshadow> any recommanded books for begineer
22:45:57 <Zemyla> > take 10 $ filter (/= 2) $ fmap (fmap (+1) length) $ group $ fix show
22:45:58 <lambdabot>  [4,8,16,32,64,128,256,512,1024,2048]
22:47:52 --- mode: ChanServ set +o glguy
22:48:14 <dulla> whatever #haskell-beginners plugs in their topic message
22:48:19 <dulla> Zemyla
22:48:34 <dulla> after that, I guess whatever the hell Oleg Writes
22:48:35 --- mode: glguy set +b-o *!*@79.133.211.75$#haskell-ops glguy
22:49:21 <dulla> Or, rather, whatever the hell Oleg hosts on their site
22:49:21 <mniip> shouldn't that say ##fix_your_connection ?
22:49:38 <glguy> nope. moderation questions are welcome in #haskell-ops
22:49:52 <mniip> ok whatever
22:53:32 --- mode: ChanServ set +o glguy
22:53:35 --- mode: glguy set -bo *!*@79.133.211.75$#haskell-ops glguy
22:58:50 <L8D> glguy: btw, it seems as though agda still defines it as an ADT
22:59:12 <glguy> That's why I linked you to that example, you wanted to see it as an ADT
22:59:26 <L8D> but it uses dependent types to assert that Neg never has zero
22:59:37 <glguy> no
22:59:38 <L8D> I see
22:59:40 <L8D> ?
22:59:44 <glguy> ?
23:00:00 <L8D> -[1+_] : (n : N) -> Z
23:00:08 <L8D> -[1+_] : (n : Nat) -> Int
23:00:30 <L8D> is an assertion that the value is greater than 0
23:00:31 <glguy> Yeah, that's the constructor, but its nothing to do with dependent types
23:00:42 <L8D> I mean... it's impossible to do in Haskell
23:00:45 <glguy> the name is just:  -[1+_]
23:00:50 <L8D> but easy to do in Idris/Agda
23:00:58 <L8D>  /Coq
23:01:03 <glguy> It might as well be:   NegativeBracketOnePlusUnderscoreBracket
23:01:18 <glguy> Agda is extremely flexible in what you can name things
23:01:25 <L8D> oh wtf that is terrible
23:01:51 <L8D> (in my opinion)
23:01:59 <glguy> ok :)
23:09:37 <ttt_fff> if I go and use Elm for 3 days; what will I learn about Haskell through th eprocess?
23:09:45 <ttt_fff> is there some pattern that will become obvious to me?
23:10:15 <shachaf> Go find out.
23:10:31 <L8D> ttt_fff: not really
23:10:46 <L8D> you might learn more about FRP
23:11:16 <ttt_fff> yeah;
23:11:19 <ttt_fff> I was thinking about frp
23:11:27 <L8D> but Elm has no typeclasses :(
23:11:33 <L8D> so no Monads or Functors
23:13:08 <ttt_fff> yeah
23:13:10 <ttt_fff> that made me sad too
23:13:23 <ttt_fff> but I was wondering if the fact you can do so much without monads would be enlightening
23:13:32 <ttt_fff> like some dude whose sword technique worked with a sheathed sword
23:13:48 <ttt_fff> and you're like whoa .... there's all this other stuff to sword technique besides slicing people apart
23:14:15 <ttt_fff> my alternative is to say fuck it, no new langs until I master haskell
23:15:36 <geekosaur> Elm is Haskell-like but in a number of ways closer to F# than Haskell. notably, Elm isn't lazy
23:15:49 <wei2912> is there any function that is defined as follows:
23:16:03 <wei2912> zipMap f xs = zip (map f xs) xs
23:16:13 <fayy> wei2912: tried hoogle?
23:16:37 <shachaf> wei2912: Isn't that the same as map (\x -> (f x, x)) xs?
23:16:54 <wei2912> shachaf: thanks, i just realized that :P
23:17:08 <wei2912> fayy: i'm not sure how to search hoogle with a definition
23:18:12 <fayy> :: (a -> b) -> [a] -> [(a, b)] ?  nothing comes up ;_;
23:19:30 <shachaf> You can say map (f &&& id) or something.
23:19:57 <wei2912> shachaf: i think i'll touch arrows another time
23:20:13 <wei2912> fayy: now that i think of it, that's what i should have searched for
23:20:33 <shachaf> Arrows aren't a particularly good abstraction. But (&&&) :: (a -> b) -> (a -> c) -> a -> (b,c)i
23:21:33 <wei2912> thanks shachaf fayy
23:26:12 <glguy> Thanchaf
23:26:29 <shachaf> Correct.
23:29:52 <dolio> Crack open the sulphagne.
23:51:19 <dulla> fthang?
23:51:57 * hackagebot hnetcdf 0.3.0.0 - Haskell NetCDF library  http://hackage.haskell.org/package/hnetcdf-0.3.0.0 (IanRoss)
23:54:01 <ReinH> wei2912: I think Richard Bird calls it fanout. It's a very useful function, arrows aside.
23:55:05 <codygman> I haven't the slightest clue what this type should look like for the result of using `uncurryN 5 (+)`, any pointers? code: http://lpaste.net/121359
23:56:13 <shachaf> You're the one bringing that function up. You know more about your situation than anyone else here.
23:56:15 <codygman> oh... duh
23:56:37 <codygman> shachaf: Yeah, you're right... I'm doing the wrong thing totally.
23:57:26 <codygman> I'm actually trying to sum a 5 tuple
23:58:17 <dashster18> Hi, if I wanted to get back into Haskell after taking a break from a while, what's the best approach? I've worked through LYAH, RWH, and Write You a Schem in 48 Hours. I was thinking of a two-pronged approach, one of refreshing myself on syntax and another on learning the math. I've been learning linear algebra and was wondering if I could jump straight to category theory or would it be worth to learn abstract/modern algebra first?
23:58:54 <shachaf> If you want to learn category theory, it's a fun thing to do, but it's not too related to learning Haskell.
23:59:44 <dashster18> shachaf: My understanding was that it helps in Haskell, but do you think it's not necessary?
