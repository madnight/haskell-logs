00:00:04 <anastas> jle`: re: "i'm curious as to what parts of haskell are required for understanding how category theory etc. are applied to it"
00:00:45 <anastas> jle`: I'm not sure that that's the right question to ask. it's not that cat theo "is applied to" haskell, it's more that the design of haskell is made based on cat theo concepts
00:01:18 <anastas> and to "apply catgeory theory to a programming language" doesn't make sense
00:01:22 <anastas> you can't apply a theory to a language
00:01:30 <jle`> i think it's safer to say that the design decisions of haskell library API's are modeled after category theory concepts
00:01:39 <anastas> that's what I was getting at yeah
00:01:52 <jle`> so like, the theory is applied in the design of the api's
00:02:19 <anastas> I wouldn't say that it's applied to the APIs (caveat: absolute newbite talking)
00:03:26 <anastas> many design decisions in haskell are motivated by category theoretical concepts
00:03:33 <jle`> hm.  api's and libraries are designed in such a way that their api and things they offer can be treated as algebraic structures, obeying all of the laws and implications/theorems that are implied by that
00:03:34 <anastas> any APIs get wrapped around that
00:04:01 <anastas> I feel like we're getting pedantic here, but if we're going to get pedantic, let's get pedantic, right? haha
00:04:47 <jle`> :)
00:05:16 <jle`> the transformations we are allowed to do on our haskell code comes from the laws they obey
00:05:30 <anastas> actually, I'm a complete newbie here, so what I am saying is what I imagine to be correct, and I have zero knowledge experience or authority to say that i's correct, so I'm hesitant to keep talking
00:05:41 <jle`> and because the laws they obey are well-studied in mathematics, the non-obvious conclusions that mathematics derives at translate to non-obvious program transformations
00:06:15 <jle`> we have all of group theory at our disposal when we work with groups in haskell, and we can make program translations based on discoveries and findings in group theory
00:06:28 <anastas> well, the phrase "the transformations we are allowed to do on our haskell code... etc" sounds like a misunderstanding to me
00:07:07 <anastas> and we don't really "work with groups in haskell", and "program translationsbased on discoveries and finding in group theory" doesn't really make sense to me either
00:08:27 <jle`> hm. to be more specific, i mean things like, "how do we know that X behaves exactly like Y?"  ==> because the objects we use in both have operations that form a group, and so using equivalency relationships we can derive from their group structure, these two programs are equal, but not obviously so."
00:09:34 <anastas> I think that you are conflating language constructs with programs
00:09:54 * hackagebot haroonga 0.1.7.0 - Low level bindings for Groonga.  http://hackage.haskell.org/package/haroonga-0.1.7.0 (cosmo0920)
00:09:54 * hackagebot paypal-adaptive-hoops 0.7.0.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.7.0.0 (fanjam)
00:10:06 <anastas> there are constructs that abide by algebraic properties, yes, and that is one of the focuses and strengths of haskell
00:10:07 <jle`> in what way?
00:10:21 <jle`> it's not the language constructs, it is the library and api's that we use
00:11:24 <jle`> for example, many data structures in haskell offer an interface called Functor.  it's not built into the language; it's a consciously written interface you can give to your data type
00:12:05 <jle`> the interface's methods behave in a way that allows us to use identities and associated properties from the definition of Functor to be able to refactor our usage of that interface/api
00:13:02 <jle`> i dont' believe there are actually any language concepts in haskell that are related to category theory inherently.  we imbue meaning into all data structures and concepts through the interfaces that we ourselves write
00:13:08 <anastas> at this point, I recognize that I do not know enough to speak confidently or authoritatively
00:13:27 <anastas> so, without either agreeing or disagreeing, I am going to just duck out of the argument
00:13:30 <anastas> sorry
00:13:33 <jle`> okay :) no worries
00:14:50 <LordBrain> well main is at least forced to be of type IO a
00:15:23 <dibblego> IO ()
00:15:28 <LordBrain> so you can't get away from that one
00:15:30 <jle`> i don't really think that that design decision was related to category theory
00:15:40 <LordBrain> :)
00:15:54 <Arahael> Why can't I implement this function with 'show'? toString :: Clock.UtcDay -> String (Where "Clock" is Date.Time.Clock as Clock)
00:16:05 <jle`> you can interpret it in a way that gives it some meaning in reference to some mathematical structure, but that is your own meaning that you imbue :)
00:16:35 <jle`> Arahael: have you tried? :)  what happened?
00:16:42 <LordBrain> Arahael, do you mean why shouldn't you or do you mean why cant you? because i don't see what would get in your way...
00:16:52 <Arahael> jle`: I got the following error:     Not in scope: type constructor or class ‘Clock.UtcDay’
00:16:52 <dibblego> Arahael: where is the type Clock.UtcDay defined?
00:16:58 <jle`> did you try giving it a definition?
00:17:07 <Arahael> dibblego: It's defined in Date.Time.Clock, as per the time module.
00:17:08 <jle`> if you just have a type signature, usually ghc can't infer the definition
00:17:18 <jle`> it can infer the type signature from the definition though, normally
00:17:24 <Arahael> Well, I've implemented as follows: toString = show
00:17:26 <jle`> ah
00:17:28 <dibblego> Arahael: I don't see that data type defined there. Can you link it?
00:18:01 <Arahael> dibblego: Eh? Hmm.
00:19:01 <Arahael> dibblego: Seems I meant to use UTCTime.
00:19:16 <dibblego> % curl -s https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock.html | grep UtcDay | wc -l
00:19:17 <dibblego> 0
00:19:19 <dibblego> ah ok
00:19:35 <Arahael> dibblego: So I get a similar, but different error now.
00:19:54 <Arahael> dibblego: (Obviously I'm still learning how to interpret Haskell's errors)
00:20:06 <Lokathor> Arahael, toString = show might give you a monomorphism restriction as well, without a type signature on it.
00:20:20 <jle`> :)
00:20:25 <Arahael> Lokathor: I'm using the above type signature. The full code is now:
00:20:28 <jle`> yeah, haskell's errors is definitely a whole third language to learn >_>
00:20:30 <Arahael> > toString :: Clock.UTCTime -> String
00:20:32 <lambdabot>  Not in scope: type constructor or class ‘Clock.UTCTime’Not in scope: ‘toString’
00:20:32 <lambdabot>  Perhaps you meant ‘BSLC.toStrict’ (imported from Data.ByteString.Lazy.Char8)
00:20:34 <Arahael> > toString = show
00:20:36 <lambdabot>  <hint>:1:10: parse error on input ‘=’
00:20:58 <Lokathor> poor lambdabot
00:20:58 <Arahael> jle`: Thanks for not suggesting that I also need to learn to read. ;)
00:20:59 <Lokathor> so confused
00:21:32 <jle`> ;)
00:21:32 <Lokathor> Arahael, can you make an lpaste of the whole file?
00:21:46 <Arahael> Lokathor: Sure, I'll strip out the commentary though.
00:21:52 <jle`> i consider errors the third language of haskell
00:22:01 <Lokathor> third?
00:22:24 <jle`> the first is the type level language
00:22:26 <jle`> er
00:22:30 <jle`> the value level language
00:22:33 <jle`> the second is the type level language
00:22:37 <jle`> the third is the language of errors >_>
00:22:53 <Arahael> http://lpaste.net/4305592426615013376
00:22:58 <Lokathor> edward taught me that i didn't understand the type level language in about 30 seconds of one of his presentations :P
00:23:28 <jle`> haha
00:23:47 <jle`> also in modern haskell we have the kind level language growing too.
00:24:14 <jle`> each layer with completely different semantics, rules, syntax, concepts, etc.
00:24:21 <Arahael> jle`: If you can find 9 languages, you might be able to relate it to 9 circles of hell. ;)
00:24:28 <Arahael> jle`: As a joke, naturally.
00:24:38 <Lokathor> Arahael, this is quite puzzling indeed. Are you sure that you have the 1.2.0.3 version of Data.Time.Clock installed? perhaps it's compiling against a different version?
00:25:36 <Arahael> lambdabot: How do I find out? My cabal file indicates that I should be using version between 1.4 and 1.5
00:26:00 <Arahael> Lokathor: That is, *time* between 1.4 and 1.5
00:26:01 <LordBrain> i tried it, it's same here, no instance for show
00:26:59 <dibblego> That is not the problem. The data type is found with the source file you gave. It just doesn't have a Show instance.
00:27:01 <LordBrain> is Data.Time.Clock in base? i have base 4.7.0.1
00:27:06 <dibblego> UTCTime exists for both versions 1.4 and 1.5
00:27:24 <dibblego> ghc-pkg list | grep time # will tell you what version you are using
00:27:33 <Lokathor> https://hackage.haskell.org/package/time-1.4.2 might be closer to what you're compiling against, but the constructor you want is there even in 1.4
00:27:57 <Arahael> dibblego: I have 'old-time', and 'time', it seems. THe latter is version 1.4.2
00:28:11 <LordBrain> same here
00:28:59 <Lokathor> well, i'm not sure how to solve your problem right now, but could you just use "show" instead of "toString"?
00:29:00 <dibblego> Arahael: right. The source file you provided gives a compile error about the absence of a Show instance for UTCTime.
00:29:23 <Arahael> Lokathor: I tried, but had an error I couldn't read.  So I factored it out.
00:29:27 <Arahael> Lokathor: This is the result.
00:29:40 <Lokathor> ah, well
00:29:59 <Lokathor> yes there should be a Show instance according to the docs, but if your compiler says there is not that would be a problem for sure
00:30:00 <Arahael> dibblego: Yet the website clearly shows that there is a Show UTCTime instance.
00:30:02 <LordBrain> hoogle does show an intsance for show in 1.4.2, so what gives?
00:32:14 <glguy> Import Data.Time
00:32:14 <Arahael> So, as a haskell novice, how do I interpret this?
00:32:22 <LordBrain> I got funny characters on the ends of lines from using a cut and paste
00:32:23 <glguy> It's an orphan
00:32:50 <Arahael> glguy: I don't understand how that works. (Yet it does)
00:33:00 <dibblego> oh good ol' orphan instances
00:33:15 <jle`> oh my gosh
00:33:15 <Arahael> What's an orphan instance?
00:33:36 <LordBrain> not defined in the same module as the type
00:33:46 <Arahael> Yikes.  Even if I do a qualified import, and *never use it*, it makes a big difference to the compilation(!)
00:33:46 <Lokathor> orphan_instances :: Recipe Disaster
00:33:48 <Lokathor> :P
00:34:00 <pacak> LordBrain: Or class
00:34:09 <jle`> i feel so much sympathy pain right now
00:34:46 <jle`> the instance is defined in Data.Time, so if you don't import it, there's no way ghc can know it
00:34:51 <Arahael> jle`: I must've done something bad in a past life.  The last time I tried to do something in Haskell, I used the download links. (Which directed me to the platform)
00:34:59 <LordBrain> a workaround for now would be to find the show instance, and copy it to your module...
00:35:20 <Arahael> LordBrain: Seems I can just do: "import qualified Data.Time as NeverMentionThis"
00:35:24 <Arahael> And it works.
00:35:33 <Arahael> I don't understand why.
00:35:36 <LordBrain> yeha, probably better
00:35:37 <jle`> yeah, if ghc loads the module, it "sees" the instance
00:35:49 <jle`> cause instances are global and stuff
00:36:05 <LordBrain> that way your code gets fixed sort of silently, except for the unnecessary import
00:36:38 <Arahael> jle`: A 5th language of Haskell? "Language of instance scope"
00:36:41 <jle`> you can also import nothing --- import Data.Time as ()
00:36:53 <LordBrain> i think at this point in time tho, orphan instances would be considered bugs, so probably report it too
00:37:10 <Arahael> LordBrain: I don't know how.
00:37:27 <Lokathor> Arahael, I'll note that the Haskell Platform is certainly not the best option on windows...
00:37:44 <Arahael> Lokathor: Nor is it on Debian 7, despite it's claims.
00:37:53 <Arahael> Lokathor: I'll note that the "new" haskell website is far, far better.
00:38:12 <Arahael> Lokathor: (The platform doesn't work *at all* on debian, it seems)
00:38:24 <Lokathor> if you're on debian, try installing ghc and cabal-install from jessie, and going from there
00:38:41 <Arahael> Lokathor: I have no inclination to run a mixed system. That's always a source of pain.
00:38:47 <Lokathor> oh the platform will generally work, it's just horrrrrribly out of date
00:39:07 <Arahael> Lokathor: No, it doesn't work.  "cabal" is incompatible with the GLIBC.
00:39:25 <lfairy> Arahael: bootstrap it yourself! :D
00:39:34 <ReinH> Or from http://deb.haskell.org/stable
00:39:36 <Arahael> lfairy: I have, now.  The GHC binaries work fine.
00:39:37 <Lokathor> that is strange, because i have installed the haskell-platform on wheezy before and had it work
00:39:52 <Arahael> ReinH: Yes, that is mentioned on the "new" website, but I didn't know of hte new one before.
00:39:55 <Arahael> Lokathor: Odd.
00:40:09 <Arahael> Lokathor: I'm on 64-bit, btw.  Were you?
00:40:22 <Lokathor> hmm, no, when i was using wheezy that was an ARM machine
00:40:49 <Arahael> Well, not so strange, then.
00:41:06 <Arahael> I'd best get some dinner.  Guess today;'s haskell taught me about orphan instances.
00:41:31 <Arahael> Thanks everyone! :)
00:41:58 <Lokathor> Arahael, http://www.stackage.org/install might also provide you with an install method that works for you
00:42:03 <Arahael> jle`: And thanks for the sympathy. :)
00:42:15 <Lokathor> though i've not tried it on wheezy
00:42:16 <nshepperd> the 6th language of haskell must be Control.Lens
00:42:31 <Arahael> Lokathor: The pain I had earlier, was that the default path didn't work.  I have it working now so I'm over it.
00:42:39 <Lokathor> ah-ha
00:42:59 <jle`> yw :)
00:43:15 <jle`> glad it got sorted out :P
00:43:23 <Arahael> nshepperd: And the 7th must be unboxed types, and the 8th must be quasi-quatation? (I don't know either, I just know they exist!)
00:43:47 <Lokathor> nshepperd, did you know that you can use a lens to magically look into a nested aeson value that's arbitrarily deep? (as long as each level is an object and not an array)
00:43:53 <Lokathor> i certainly did not
00:44:14 <Lokathor> but apparently it's: foldr (.) id . fmap (key . T.pack) . Data.List.Split.splitOn "."
00:44:25 <LordBrain> they have it already marked as an orphan instance in the source...
00:44:27 <Lokathor> 6th language indeed
00:44:38 <LordBrain> so someone knows about it but didnt fix it
00:45:45 <LordBrain> Lokathor, there's already a bug report here: https://github.com/haskell/time/issues/7
00:46:24 <Lokathor> interesting
00:46:46 <Lokathor> i suppose that perhaps "core" packages like that get updates a little less often?
00:47:02 <LordBrain> you can add a comment saying you were also bitten, might add motivation
00:47:28 <Lokathor> well, Ara was the one that got bit, but maybe
00:47:39 <LordBrain> it sounds like they're going to fix it by just documenting the current status.... not sure why not just move the instance to the other module
00:47:52 <breadmonster> What kind of parsers can you build with parsec?
00:48:00 <LordBrain> oops i meant to be addressing Arahael
00:48:01 <breadmonster> LL or LR?
00:49:19 <LordBrain> LL
00:49:32 <LordBrain> according to this blog: https://mikeburrell.wordpress.com/2007/02/25/combinator-parsing/
00:49:34 <LordBrain> just googled
00:50:28 <LordBrain> didnt read it all, so i may have misrepresented
00:50:58 <jle`> playing with the monad instance for fixed length vectors.  things are interesting i guess, i don't erally know how to interpret what i'm getting
00:51:27 <breadmonster> So how do I do LR parsing in Haskell?
00:51:58 <jle`> oh, i kind of get it.  it's interesting
00:52:14 <jle`> it's basically identical to the monad instance for ((->) a)
00:53:51 <Lokathor> man I kinda read that section in LYAH
00:54:15 <Lokathor> but (->) as an operating part of the language and not just as a fancy syntax thing wasn't even covered that well
00:54:23 <Lokathor> and it kinda blew my mind too much to focus
01:02:19 <nshepperd> hmm, would that be a zippy sort of instance?
01:07:44 <nshepperd> a fixed length vector is basically (Index -> a), so... a fixed length vector is like Reader Index?
01:09:45 <newb> anybody?
01:09:50 <mniip> hi
01:09:51 * hackagebot configuration-tools 0.2.10 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.10 (larsk)
01:10:41 <newb> just snooping around... don't really have anything in specific
01:11:20 <newb> I am trying to understand haskell
01:11:27 <Hijiri> nshepperd: basically, as far as I can tell
01:11:30 <mniip> glhf
01:11:44 <Hijiri> you can get all the same functor/applicative/monad instances too
01:26:39 <johnw> nshepperd: that doesn't really make sense
01:27:07 <johnw> for example,what would join applied to Vector (Vector Int 20) 10 be?
01:27:54 <jle`> nshepperd: yup, exactly.
01:28:10 <scott> johnw: that wouldn't type check
01:28:17 <nshepperd> johnw: you can't mix vectors of different lengths
01:28:37 <johnw> ok, then what is join of Vector (Vector Int 20) 20?
01:29:02 <scott> is there a monad instance for ZipList?
01:29:09 <johnw> no, there isn't
01:29:47 <scott> I wonder if the length restrictions make it work somehow
01:30:08 <nshepperd> johnw: that would give you the diagonal of the matrix
01:30:11 <xenocons> nlpers, how many features is enough? heh
01:30:16 <jle`> johnw: is that a type?
01:30:19 <jle`> or a valur?
01:30:23 <jle`> *value
01:30:30 <scott> ooh, the diagonal. hmm.
01:30:32 <nshepperd> assuming you mean Vector 20 (Vector 20 Int)
01:30:32 <johnw> jle`: hmm?
01:30:38 <jle`> your question
01:30:50 <johnw> ah, right, Haskell needs the type variable in final position
01:31:17 <jle`> join on a fixed length vector type is the diagonal of the matrix
01:31:35 <jle`> so it is identical to Reader Index
01:32:25 <johnw> have you implemented it?
01:32:46 <jle`> um i did a little toy implementation of a three-vec
01:32:52 <johnw> i mean, proven the laws
01:33:05 <jle`> well I made the isomorphism to Reader
01:33:17 <johnw> I'm still wondering if that's valid
01:33:40 <jle`> if the isomorphism is valid then it has to be valid right?
01:33:42 <johnw> (Index -> a) is not bounded by the type.  Fin n -> a would be
01:33:48 <johnw> have you proven the isomorphism?
01:34:07 <nshepperd> Reader (Index n) is certainly a valid monad, and there's a pretty clean isomorphism between that and Vector n
01:35:43 <jle`> for a three-vec, you can use data OTwTh = O | Tw | Th
01:35:52 <jle`> and it's isomprhic to (Reader OTwTh)
01:36:31 <jle`> what is involved in proving the isomorphism?
01:36:39 <johnw> show that to . from = id, and from . to = id
01:36:45 <Hijiri> do a proof denotational semantics style?
01:37:03 <jle`> sounds like fun
01:37:40 <Hijiri> it doesn't seem like it would take that much work, conal's Denotational design with type class morphisms
01:37:53 <Hijiri> does it for Map
01:38:02 <Hijiri> as one of the example
01:38:19 <scott> (>>=) for Vector n is weird
01:40:22 <nshepperd> well, to = generate n, from = (!)
01:40:27 <Hijiri> vna >>= k replaces each element x_i with the ith element of k x_i?
01:40:36 <Hijiri> or just fmap and join, I guess
01:41:30 <scott> Hijiri: yeah
01:43:06 <nshepperd> I think the thing that stops Monad ZipList from working is that the lengths are variable so there isn't always a diagonal
01:43:39 <jle`> you can actaully think about the instance where you go "as far as you can" in the diagonal
01:43:53 <jle`> but shachaf's quickcheck skills proved that it isn't valid
01:45:27 <lpaste> jle` pasted “ThreeVec” at http://lpaste.net/120112
01:45:33 <jle`> um
01:45:36 <jle`> that's me playing around with it
01:45:52 <jle`> i defined the isomorphism and then put down two do blocks where i pulled the iso in/out
01:46:09 <nshepperd> although 'MaybeT (Reader Integer)' does contain ZipList
01:51:25 <ab9rf> i'm trying to get eclipsefp working again on my system, and am running into cabal-hell issues (ha).  is there any reason why i shouldn't compile each of the various helper executables eclipsefp uses in its own cabal sandbox and plop the resulting final executables in Some Place, and tell eclipseFP that they're there?
01:52:07 <ab9rf> obviously i'll spend extra cpu cycles compiling some libraries more than once, but i'm willing to live with that if this is the best way to get everything working
01:54:03 <Haskellfant> ab9rf: sounds like the way to go
01:54:05 <jle`> ok i proved from . to = id
01:54:09 <jle`> now to do to . from
01:54:22 <Hijiri> http://lpaste.net/120113
01:56:04 <ab9rf> heh, how many times can one compile aeson in 24 hours?
01:56:37 <Haskellfant> I don't remember aeson being particularly bad
01:56:45 <ab9rf> it's not, but it's used by a lot of stuff
01:56:58 <ab9rf> and when you compile everything in its own sandbox, aeson gets compiled a lot
02:01:06 <lpaste> jle` annotated “ThreeVec” with “ThreeVec (annotation)” at http://lpaste.net/120112#a120114
02:01:15 <jle`> there's the iso proof :)
02:01:36 <johnw> very good
02:01:47 <jle`> woo hoo
02:01:58 <jle`> you have successfully nerdsniped me
02:02:02 <johnw> haha
02:02:13 <johnw> you sniped me back; I'm doing the proof in Coq to see where it becomes impossible
02:02:52 <johnw> ah, it does work under diagonalization, as suggested above
02:02:53 <johnw> http://stackoverflow.com/questions/5802628/monad-instance-of-a-number-parameterised-vector
02:03:13 <johnw> also see https://patternsinfp.wordpress.com/2010/12/31/stream-monad/
02:05:12 <jle`> :P
02:05:55 <jle`> diagonalization i had known for a while but i wanted to see if i could find a sort of intuitive understanding when using it with do blocks
02:06:28 <jle`> it clicked when i noted that to find the 3rd item of the final result, i just substituted all the bound variables with the 3rd item of the vectors i was binding
02:10:52 <ab9rf> i just love it when ghc makes my mouse pointer disappear
02:10:54 <johnw> ugh, these proofs are getting unfun, and the blog post answers my query :)
02:11:25 <jle`> is there a way to define this instance inductively
02:11:35 <johnw> what instance?
02:11:41 <jle`> the functor/applicative/monad instance
02:11:49 <jle`> on vectors parameterized by a type giving the size
02:11:54 <johnw> what do you mean by defining it inductively
02:12:14 <jle`> um, a vector with a type nat parameter that gives it the size
02:12:26 <jle`> and defining the instance by relying on the instance of the one-size-less vector
02:12:41 <jle`> and giving the base case of an instance of a 0 (or 1?) size vector
02:12:44 <johnw> isn't your instance generalized over the bound?
02:12:53 <jle`> no i only wrote it for 3-vectors hehe
02:12:56 <johnw> instance Functor (Vec n) where
02:13:13 <jle`> without loss of generality of course :D
02:13:54 <jle`> is your Vec n there a vector type that is enforced to only ever have n elements by its type?
02:14:02 <johnw> yes
02:14:08 <jle`> how does that work?
02:14:15 <johnw> https://gist.github.com/6736fa9a10a660f092e7
02:14:20 <jle`> thanks :)
02:14:31 <johnw> it's not the best way of defining vectors, but it was simple for this problem
02:15:00 <jle`> mhm it seems natural for this problem too
02:15:51 <johnw> another way is: Definition Vec (A : Type) : forall n : nat, { xs : list A | size xs == n }.
02:16:04 <johnw> which has the benefit of degrading to a list quite readily
02:16:18 <jle`> yes but that feels a little ilke cheating ;)
02:16:38 <johnw> isomorphism is a cheating I can live with
02:18:03 <jle`> i guess it's different than in the closest haskell analogy
02:18:23 <jle`> where you have a smart constructor that only allows lists of the given size
02:18:26 <jle`> heh
02:20:02 <johnw> g'night!
02:20:49 <jle`> night!
02:26:41 <ab9rf> grrr
02:27:09 <ab9rf> pandoc failed to build.  now to go find a version that will build....
02:27:13 <jle`> ;_;
02:28:09 <ab9rf> it's failing in setup.hs.  that's weeerd.
02:28:37 <mpickering> ab9rf: What is the error?
02:28:39 <jle`> are you building the library?
02:28:50 <mpickering> which version are you trying to build
02:28:52 <ab9rf> jle`: i'm attemting a sandboxed build of sourcegraph
02:29:09 <ab9rf> pandoc-1.12.4.2
02:29:57 <ab9rf> i'll pastebin the error in a mo
02:31:26 <ab9rf> jle`: pandoc is a dependency for sourcegraph, so, yes, the library
02:37:11 <ab9rf> http://lpaste.net/120115
02:38:35 <ab9rf> ah, there's a bug report on pandoc for this
02:39:01 <mpickering> what is your version of cabal?
02:39:08 <ab9rf> 1.22
02:39:15 <mpickering> that's also an old version of pandoc
02:39:23 <ab9rf> yeah, it's what cabal selected
02:39:35 <mpickering> try installing with --allow-newer
02:40:06 <mpickering> I'm pretty sure that bug is fixed in the latest release
02:40:43 <ab9rf> i added --upgrade-dependencies and --force-reinstalls
02:41:06 <ab9rf> i suppose i should just dump the sandbox, but feh
02:41:18 <ab9rf> kitty litter
02:41:39 <mpickering> and --allow-newer?
02:41:52 <ab9rf> yes
02:42:05 <ab9rf> it still tried for 1.12.4.2
02:42:15 <mpickering> ok can you run with -v3 and paste the output?
02:42:18 <ab9rf> all that did was push HTTP to 4000
02:48:39 <ab9rf> http://lpaste.net/120116
02:48:47 <ab9rf> rather large :)
02:49:13 <mpickering> let's just say that there's no -v4 :p
02:49:51 <ab9rf> heh
02:50:01 <ab9rf> i'm going to unregister texmath and try again
02:50:32 <mpickering> ok the problem is texmath
02:50:40 <mpickering> the current version of texmath is 0.8.x
02:51:10 <ab9rf> and it's now pulling texmath-0.8.0.1
02:51:28 <ab9rf> i'll remember that for next time i get stuck, that output is quite useful
02:51:39 <mpickering> -v2 might be enough
02:52:01 <jle`> will liftM be redefined to fmap in 7.10?
02:55:12 <mpickering> jle`: https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Base.hs#L549
02:55:15 <ab9rf> mpickering: -v2 is not enough
02:55:42 <ab9rf> mpickering: rmoving texmath still left it pulling 1.12.4.2, so there's something else blocking, but i'll just bang it until it coopoerates.  thanks.
02:56:01 <mpickering> right
02:56:18 <mpickering> maybe try with --constraint="pandoc >= 1.13"
02:56:24 <mpickering> then you might get a better error message
02:56:54 <ab9rf> mpickering: -v3 + --dry-run works well
03:01:32 <ab9rf> mpickering: i also undertsand why it did what it did, it was pinning to the older packages inthe platform install
03:01:54 <ab9rf> which are in the global package directory
03:03:12 <McManiaC> are there any recommandable event-driven-io libraries?
03:04:20 <ab9rf> i suppose now is a good time to learn how to set profile options on cabal :)
03:27:40 <ab9rf> i think i finally have a working build solution.  i would like not to have to do that again :)
03:28:25 <mpickering> having a global package db complicates things
03:28:33 <mpickering> but I guess on windows you have no choice?
03:28:43 <ab9rf> it's probably possibnle to remove it
03:29:07 <ab9rf> and since i don't have the full msys toolchain installed i can't rebuild old-time or network
03:29:21 <ab9rf> so i pinned those with constraints and let it rebuild everything else
03:30:01 <ab9rf> ah, need to pin time too
03:31:45 <ab9rf> in the long term it owuld be easier to install the full msys/cygwin toolchain and build ghc from source
03:31:54 <ab9rf> rather than using the prebuilt platform
03:32:43 <mpickering> would probably be easier to set up a build vm no?
03:33:05 <ab9rf> mpickering: maybe.
03:34:45 <mpickering> there were some people trying to improve the situation for windows users I think
03:35:04 <ab9rf> mpickering: i may put some effort into it down the rod
03:35:27 <ab9rf> road
03:35:40 <ab9rf> porting to VC is not likely though
03:40:14 <tomphreek> @src :
03:40:15 <lambdabot> Source not found.
03:40:19 <tomphreek> @src (:)
03:40:20 <lambdabot> Source not found. There are some things that I just don't know.
03:41:02 <bitonic> tomphreek: `data [a] = [] | a : [a]'.  if that syntax was legal.
03:41:14 <bitonic> in any case, `:' is a constructor for `[]'
03:42:04 <tomphreek> bitonic: that's exactly what I was after. thank you
03:46:25 <angerman> I seem to continously fail to understand cabal properly :( Do I need to relist all the dependencies of the "library" section in the "executable" sections again? Or can I somehow make cabal infer them from the library section?
03:50:46 <mpickering> angerman: no
03:50:56 <mpickering> you can just say the library name
03:51:11 <mpickering> from cabal 1.18 anyway I think
03:51:47 <angerman> mpickering: ohh. That's how it's supposed to work :D
03:53:07 <mpickering> well.. you still have to list some deps in the build-depends there usually
03:53:17 <mpickering> but only stuff you use in the executable
03:53:21 <mpickering> if that's your question
03:55:21 <angerman> mpickering: yep, that's been basically the issue I had :)
04:02:16 <drewbert> #yesod is an echo chamber
04:07:33 <ab9rf> meh
04:07:39 <ab9rf> i had to blort the sandbox once again
04:07:53 <ab9rf> i'm hoping that that's the last of the necessary pins
04:10:44 <darthdeus_> hey guys, is there an easy way to do Text.Printf.printf, but to a String and not stdout?
04:11:25 <darthdeus_> oh nvm, i'm dumb, it already can return strings :)
04:25:24 <KaneTW> yeah, it's return type (forgot what it was) is polymorphic
04:26:54 <mniip> :t printf
04:26:55 <lambdabot> PrintfType r => String -> r
04:27:14 <mniip> interesting example of polymorphism
04:36:31 <ab9rf> printf has a fairly unusual type
04:36:47 <mniip> @info PrintfType
04:36:47 <lambdabot> PrintfType
04:37:00 <mniip> thanks
04:37:12 <mniip> I wouldn't have thought of that myself
04:37:23 <ab9rf> hehe
04:39:22 <hyPiRion> Is there any editline library that supports base 4.7 ? editline itself requires base to be lower than 4.7 :(
04:41:40 <Ainieco> hello, is there anything like Int -> Int -> Char -> [String] -> [String]?
04:42:02 <Ainieco> need to replace char in string in list
04:42:21 <agocorona> join #haskell-blah
04:45:48 <Ainieco> or at least Int -> Char -> String -> String?
04:46:00 <ab9rf> Ainieco: try hoogling that?
04:46:11 <Ainieco> ab9rf: nothing there
04:46:17 <ab9rf> @hoogle Int -> a -> [a] -> [a]
04:46:17 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
04:46:17 <lambdabot> Data.IntMap.Strict findWithDefault :: a -> Key -> IntMap a -> a
04:46:17 <lambdabot> Data.IntMap.Lazy findWithDefault :: a -> Key -> IntMap a -> a
04:46:47 <ab9rf> :t splitAt
04:46:48 <lambdabot> Int -> [a] -> ([a], [a])
04:47:07 <Ainieco> oh, i searched wrong type i guess
04:47:41 <Ainieco> but still nothing
04:47:54 <ab9rf> replaceAt n c s = let (hd,_:tl) = splitAt n s in hd ++ c:tl
04:47:57 <ab9rf> that's not quite right
04:48:07 <ab9rf> but it's close
04:48:15 <Ainieco> thanks
04:48:20 <ab9rf> and i probably forgot some parens :)
04:48:44 <ab9rf> that'll barf if n >= lenght s
04:49:02 <ab9rf> you might look at Data.List
05:41:32 <byorgey> shachaf: re: limits and colimits being adjoint to a diagonal functor, of course, I had forgotten about that.
05:41:50 <breadmonster> How long should it take for me to build GHC?
05:41:58 <byorgey> so sum and product are just degenerate colimits and limits, respectively, where the index category happens to be discrete
05:42:24 <byorgey> breadmonster: a few hours at most.  Why are you building GHC?
05:42:46 <breadmonster> I'm running Ubuntu 14.04 with an 8 thread Intel i7 and 8 gigs of RAM.
05:43:07 <breadmonster> byorgey: Oh for fun, I wanted to start hacking GHC
05:43:23 <breadmonster> Will it be done in two hours or so
05:43:25 <breadmonster> ?
05:43:29 <byorgey> cool, that is a good reason to build GHC
05:43:43 <breadmonster> Or is it going to take all night?
05:43:59 <byorgey> breadmonster: it will probably be done a lot faster than 2 hours on 8 cores, be sure to make -j8
05:44:10 <breadmonster> Oh wow, okay, that's awesome.
05:44:18 <breadmonster> I hope my laptop doesn't overheat :P
05:44:19 <byorgey> breadmonster: also be sure to set your build.mk file or config.mk file or whatever it is to the fastest build setting
05:44:27 <breadmonster> byorgey: How do I do that?
05:44:38 <breadmonster> I want a full build btw, with all the optimization passes.
05:44:49 <init> breadmonster: it took 3~ hours in a single core VPS with 512mb of ram (and 2gb of swap, or it OOM'd), so I think it is going to be really fast
05:45:04 <byorgey> there are instructions on the GHC wiki, https://ghc.haskell.org/trac/ghc/wiki/Building/Hacking
05:45:05 <breadmonster> init: For the whole thing?
05:45:25 <byorgey> breadmonster: why do you want a full build?  if you are just hacking, best to do a quick build first so it will fail quickly
05:45:47 <byorgey> you can do a full build later when testing & benchmarking
05:45:52 <breadmonster> byorgey: I'm going to do a full build so that ghc is fast, so that the small builds are faster.
05:46:01 <breadmonster> If you get what I mean?
05:46:27 <byorgey> breadmonster: the small builds will be built with your installed version of GHC, not with the version you are hacking on
05:46:46 <breadmonster> byorgey: Yeah, Ubuntu doesn't happen to have the latest version.
05:46:50 <breadmonster> I was trying to fix that too.
05:47:01 <breadmonster> Can I build the latest and use that to replace the build I have?
05:47:16 <byorgey> oh, in that case, I suggest first installing the latest from a binary package, rather than building from source
05:47:29 <mpickering> sure.. but you can also use hvr's ppa to get the latest (and GHC 7.10 RC2)
05:47:38 <breadmonster> byorgey: Can't, only 7.6.2 is up.
05:47:45 <breadmonster> That's why I'm building 7.8.4
05:47:52 <breadmonster> mpickering: Yeah, I just saw the mail.
05:47:58 <byorgey> ? https://www.haskell.org/ghc/download_ghc_7_8_4#x86_64linux
05:48:14 <Bubblyworld> Hey guys, is this the right channel for newbie questions?
05:48:20 <byorgey> Bubblyworld: yep, ask away
05:48:26 <ab9rf> no, but it is the left channel for them :)
05:48:41 <mpickering> breadmonster: also note that there was a performance regression 7.8.4 -> 7.10 RC2 which only just got fixed in HEAD
05:49:01 <breadmonster> mpickering: So should I compile 7.10?
05:49:19 <ab9rf> Bubblyworld: ask your question, don't wait for clear air
05:49:45 <mpickering> well it depends what you want breadmonster
05:49:48 <byorgey> breadmonster: also, the latest HEAD should build fine with 7.6.2, so you can just install that and use it to build
05:50:14 <breadmonster> byorgey: Yeah, I already have it installed.
05:50:22 <breadmonster> So I think I'll run a full build for now of the RC2.
05:50:25 <byorgey> breadmonster: OK, so what's the problem? =)
05:50:42 <breadmonster> byorgey: Nothing, just wanted to know if it'll take an insane amount of time.
05:50:54 <mpickering> breadmonster: there are binarys of the RC2 availible as well
05:50:57 <breadmonster> which is what the website says, but then again ghc docs are slightly dated at times.
05:51:21 <byorgey> breadmonster: right, it doesn't take too long these days, especially on multiple cores
05:51:37 <Bubblyworld> So I'm playing around with SDL in GHCi, and have three vars:  pixel :: IO Pixel,  rect :: IO Maybe Rect,  screen :: IO Surface.   What's the standard way to "lift" fillRect:: Surface -> Maybe Rect -> Pixel -> IO Bool so I can use these vars?
05:52:11 <byorgey> breadmonster: note that sometimes with make -jN the build dependencies are not specified precisely enough and something will happen in the wrong order.  So if you get a build error, just try running make again and see if the problem goes away
05:52:31 <breadmonster> Oh okay, that's interesting.
05:52:49 <ab9rf> heh
05:53:10 <byorgey> at least that used to be the case as of a year or two ago
05:53:38 <breadmonster> What's the point of the GHCProfiled flag?
05:54:51 <breadmonster> byorgey mpickering: Alright thanks, I'll have a look and see if I can set up my builds.
05:54:59 <breadmonster> And I'll get back if I have any questions.
05:55:01 <breadmonster> Thanks guys (:
06:02:30 <ab9rf> grrr
06:02:49 <ab9rf> after all that i find that i have to use haskell-src-exts < 1.16
06:03:02 <mpickering> hmm?
06:03:13 <ab9rf> SourceGraph uses GuardedAlt, which was rmeoved in 1.16
06:03:29 <ab9rf> SourceGraph has incorrect dependency constraints
06:04:49 <mpickering> GuardedAlt is still there?
06:05:24 <ab9rf> mpickering: not in 1.16
06:05:38 <mpickering> I think it's called GuardedRhs instead
06:05:46 <ab9rf> it's used in SourceGraph though so i had to constrain it to <1.16
06:06:06 <mpickering> well you can fork SourceGraph and change the necessary bits :P
06:06:12 <ab9rf> meh
06:06:26 <mpickering> "GuardedAlt and GuardedAlts types are replaced with the isomorphic GuardedRhs and Rhs types
06:07:50 <mpickering> in fact it looks like SourceGraph actually has the right constraints on it?
06:08:35 <ab9rf> mmm
06:09:28 <ab9rf> now i have a different error :)
06:11:41 <ab9rf> apparently cabal 1.22 doesn't work here either
06:11:58 <mpickering> lol this sounds quite painful ab9rf I'm sorry for you :(
06:12:08 <mpickering> cabal 1.22 doesn't work with what?
06:12:23 <ab9rf> mpickering: i got a type mismatch on a type that is in cabal
06:17:44 <mpickering> ab9rf: fwiw the nix build bot also fails to build it
06:17:45 <mpickering> http://ns3.cryp.to/build/534341/nixlog/2/raw
06:19:33 <ab9rf> mpickering: i'm trying with an older cabal library now :)
06:20:02 <ab9rf> probably 1.18, if that doesn't work i'll try something between 1.18 and 1.22
06:21:05 <ab9rf> blurgh!
06:21:10 <ab9rf> weird-ass loader error
06:23:29 <snizzo> ghorn: tdm stop
06:23:29 <snizzo> gholightstop
06:23:29 <snizzo> gholightstop
06:23:29 <snizzo> gholightstop
06:23:29 <snizzo> gholightstop
06:23:29 <snizzo> gholightstop
06:23:30 <snizzo> gholightstop
06:23:30 <snizzo> gholightstop
06:23:31 <snizzo> gholightstart
06:23:31 <snizzo> dkms
06:23:32 <snizzo> dkms
06:23:33 <snizzo> dkms
06:23:33 <snizzo> man dkms
06:23:55 <mniip> this is not a shell
06:24:01 <snizzo> ghorn: tdm stopqdkms status
06:24:10 <snizzo> ghorn: tdm stopqdkms status nvidia
06:24:11 <snizzo> ghorn: tdm stopqdkms status nv
06:24:14 <snizzo> ghorn: tdm stopqdkms status
06:24:20 <mniip> !ops
06:24:23 <snizzo> sudo reboot
06:24:28 <mniip> what
06:25:40 <tremon> salvaging a machine with a broken display driver can be quite tricky :)
06:25:58 <mniip> .-.
06:26:36 <ab9rf> somebody confused this channel with the one he uses to run his botnet
06:26:43 <snizzo> mniip: oh lol sorry
06:26:59 <snizzo> mniip: I was having real troubles with x and nvidia closed drivers
06:27:01 <snizzo> sorry
06:27:55 <ab9rf> you can go back to sleep, ghorn :)
06:28:10 <snizzo> tremon: thank you for understanding ;)
06:29:41 <snizzo> ab9rf: my display driver is pure black with closed nvidia drivers but to ubuntu 346 bug
06:30:00 <snizzo> but quassel still starts and receive input. I was typing on tty
06:31:50 <snizzo> am I muted?
06:32:40 <mniip> no
06:32:57 <snizzo> ok, thank you for understanding, I won't flood again
06:39:46 <icewing> Is there a list datatype where head, tail, init and last are all O(1) (and conversion from [a] in O(n))?
06:40:13 <Cale> icewing: Data.Sequence
06:40:51 <icewing> Thanks!
06:41:25 <Cale> http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Sequence.html
06:43:52 <augur> anyone know of a good discussion of permissions models in the abstract?
06:52:22 <mniip> is there a way I could join two State# RealWorld#'s together? seq and seq# only take *s
06:58:07 <worldsayshi> Is there some module for programmatically (or through command line) manipulating a cabal file?
06:58:18 <worldsayshi> Adding deps and such
06:58:32 <worldsayshi> Or exctracting deps
06:59:44 <dcoutts_> worldsayshi: the Cabal lib has a parser and pretty-printer, but it does not preserve formatting, comments etc
07:00:46 <worldsayshi> dcoutts_: Ah thanks
07:08:51 <worldsayshi> Idle idea: would it be useful to have a service similar to hoogle - integrated into cabal - with the addition of being able to suggest improvements to your dependency list in your cabal file. Improvements would be things like widening the version restrictions or removing version restrictions that wouldn’t work. How it would know this: Have a central index of all functions with types for each version of all
07:08:52 <worldsayshi> hackage modules. Match this index against function types being imported into the current project.
07:09:44 <dcoutts_> worldsayshi: yes, it's a good idea, and been talked about many times but it's quite a bit of work to do
07:09:53 <worldsayshi> okok
07:09:58 <dcoutts_> a few people have started, but not finished yet
07:10:12 <worldsayshi> ah, I see
07:10:22 <dcoutts_> step 1 is writing a tool to extract the interface of a package
07:10:27 <dcoutts_> using the ghc api
07:11:02 <worldsayshi> Heh, interesting. Would it be helpful to write small POCs for doing things like that?
07:11:07 <ab9rf> yeah, it shoudl be possible to programmtically test for api compatibility
07:11:45 <dcoutts_> worldsayshi: I think we know the idea would work, that's not the problem. It's doing it properly that's just quite a bit of work.
07:12:02 <worldsayshi> yeah, I can see that
07:12:13 <dcoutts_> right, once you have an interface, then you can do interface comparisons
07:12:22 <dcoutts_> things like PVP checking, or package compat checking
07:13:03 <worldsayshi> dcoutts_: I guess before doing it properly though, it would be nice to have small code examples for the various parts involved?
07:14:12 <worldsayshi> Like building interface, building search db, querying search db
07:15:32 <worldsayshi> dcoutts_: Is there a wikipage summarizing efforts on this?
07:18:29 <dcoutts_> worldsayshi: I don't think so, though there's a GSoC proposal somewhere that didn't make the cut
07:18:36 <worldsayshi> ok
07:18:39 <mniip> is there a way I could join two State# RealWorld#'s together? seq and seq# only take *s
07:18:52 <dcoutts_> worldsayshi: I think the main place to start is with the interface extraction
07:19:03 <worldsayshi> yeah
07:19:09 <dcoutts_> worldsayshi: and for that, it might make sense to start with some of the haddock code
07:21:12 <dcoutts_> worldsayshi: indeed one of the suggested designs is to split haddock into two phases, one phase that extracts an interface (with docs) and another that reads that interface and produces html
07:21:25 <worldsayshi> ah
07:21:34 <dcoutts_> worldsayshi: but then other tools could also start from that interface
07:21:48 <dcoutts_> worldsayshi: but that is an even more ambitious design
07:22:09 <dcoutts_> but it'd save time for users, since they usually want to run haddock anyway
07:22:10 <worldsayshi> yeah, that sounds like a bit of work.
07:23:36 <worldsayshi> I’m thinking that using such interfaces could vastly simplify version control in the long run. But perhaps there are other pitfalls of version control that makes such approach a half miss
07:26:10 <dcoutts_> worldsayshi: no you're quite right, it would solve a class of problems
07:26:12 <dcoutts_> see...
07:26:48 <dcoutts_> worldsayshi: http://www.well-typed.com/blog/2014/09/how-we-might-abolish-cabal-hell-part-1/
07:27:16 <dcoutts_> worldsayshi: see the bit about package interface compatibility tools
07:27:20 <worldsayshi> dcoutts_: Perhaps such interfaces in the long run could be used as the primary dependency specification method instead
07:27:22 <worldsayshi> okok
07:28:03 <dcoutts_> worldsayshi: my opinion is that it does not replace versions, but it does tell you which versions are right/wrong (mostly)
07:28:49 <dcoutts_> worldsayshi: versions are still useful for translation into other package systems (think .deb, .rpm), and for covering semantic changes not covered by names/types
07:29:01 <dcoutts_> but it's a great approximation
07:29:33 <dcoutts_> worldsayshi: but note also the class of problems it solves, it's one amongst several
07:30:34 <worldsayshi> dcoutts_: Yeah, it wouldn’t cover everything
07:30:35 <dcoutts_> worldsayshi: in my view, it's the 3rd most important solution
07:31:05 <dcoutts_> so yes, it's important
07:32:06 <dcoutts_> worldsayshi: so if you have time to hack on this, that'd be great
07:32:22 <worldsayshi> Seems like hoogle should have mechanisms for many of the involved problems.
07:32:25 <dcoutts_> start with the interface extraction, and think about the format of the interface
07:32:38 <dcoutts_> yes, hoogle has some similar things, like haddock
07:33:33 <dcoutts_> worldsayshi: note that hoogle's intermediate text output also uses haddock as a frontend
07:44:47 <worldsayshi_> dcoutts_: Yeah, I’ll see if I ever get to it. I work on somewhat related stuff, searching within sets of abs syntax trees for example.
07:46:23 <worldsayshi> I use Solr (search engine) for it (searching for sub-patterns in abstract syntax trees) and I wonder if there is a simpler/better way.
07:46:46 <worldsayshi> Solr seems to work quite well so far though
08:00:37 * hackagebot configuration-tools 0.2.10 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.10 (larsk)
08:00:37 * hackagebot scion-browser 0.5.0 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.5.0 (JeanPhilippeMoresmau)
08:09:20 <Profpatsch> I’ve got a problem with Network.Socket.ByteString’s `recv`
08:09:53 <Profpatsch> It blocks and doesn’t return.
08:16:49 <HeladoDeBrownie> Profpatsch, the docs state that "This function may block until a message arrives", and as such it may be best to perform it in a separate thread from anything else you may want to do
08:17:37 <HeladoDeBrownie> then you can even do things like implement a timeout wherein an exception is thrown to that thread after n seconds if it hasn't succeeded yet
08:18:01 <HeladoDeBrownie> race_ from the async package would be one way of doing that
08:18:22 <HeladoDeBrownie> or race even
08:18:31 <Profpatsch> HeladoDeBrownie: My problem is even more basic3
08:18:43 <HeladoDeBrownie> explain
08:18:43 <Profpatsch> I should get something back, but I don’t
08:19:03 <HeladoDeBrownie> what do you know that makes you think you should get something back?
08:19:18 <Profpatsch> When I do it in telnet, I type in „help\n“ and the server sends back some help string.
08:19:18 <HeladoDeBrownie> i'm not saying you're wrong, but the information you've provided is incomplete
08:19:46 <Profpatsch> Oh, maybe the buffer is not flushed and the data not actually sent.
08:20:30 <Profpatsch> To test it out I did something like sendAll "help" >> recv 1024 >>= print . Char8.unpack
08:22:04 <HeladoDeBrownie> showing code may help
08:22:48 <jedai> "help" or "help\n" ?
08:23:12 <Profpatsch> jedai: hm, "help" I think.
08:23:26 <jedai> buffering is to be suspected then
08:23:26 <Profpatsch> Maybe I should read into how BSD sockets are buffered.
08:23:34 <Profpatsch> okay.
08:24:19 <jedai> why not try to flush the handle ?
08:25:27 <rasen> btw, does somebody know how to read full udp packet?
08:25:43 <Profpatsch> jedai: As it seems, Sockets are no Handles.
08:26:07 <Profpatsch> jedai: There is a socketToHandle function.
08:26:16 <jedai> Profpatsch: ok, but can't you flush them ?
08:26:39 <jedai> Profpatsch: also try using "help\n" instead
08:27:50 <Profpatsch> jedai: you where RIGHT!
08:27:55 <Profpatsch> \n does the trick.
08:28:02 <Profpatsch> Thanks!
08:30:11 <Profpatsch> https://stackoverflow.com/questions/855544/is-there-a-way-to-flush-a-posix-socket
08:30:47 <Profpatsch> TCP has no concept of flushing …
08:30:53 <hhhasdau> How do I randomly shuffle an array with Haskell?
08:31:07 <Profpatsch> The problem was that the server on the other end of course waits for the string help\n and not help
08:31:07 <hhhasdau> array/list
08:31:32 <Profpatsch> hhhasdau: randomIO
08:32:16 <Profpatsch> hhhasdau: Wait, [] is not an instance of Random
08:32:41 <hhhasdau> I have an array of chars that I want to shuffle
08:32:46 <Profpatsch> hhhasdau: http://hackage.haskell.org/package/random-shuffle
08:32:52 <Profpatsch> There’s a package for that™
08:33:42 <Profpatsch> hhhasdau: Also in http://hackage.haskell.org/package/random-extras-0.19/docs/Data-Random-Extras.html
08:34:09 <hhhasdau> okay thanks
08:36:55 <jedai> Profpatsch: Thank you, that's interesting, I myself was never in a situation where I needed to flush a socket but thought it would be possible
08:37:03 <angerman> mpickering: any plans to integrate the web api as well? Where would/could that go in the namespace?
08:43:12 <parallels1> join #xkcd
08:44:47 <cmtptr> make me
08:45:00 <hpc> haha
08:47:03 <mpickering> angerman: I don't have any personal plans to do so but it would be nice to have :)
08:47:16 <mseeks> if I have a type T with a FromJSON instance, and a value of type (FromJSON a => a), why does (a :: T) cause a fromJust exception?
08:47:38 <angerman> mpickering: this "can't have attachments with messages for the RTM api is driving me nuts."
08:47:53 <mpickering> angerman: I tried to do that as well.. it's annoying
08:49:18 <mpickering> can you use the same API token for the web API as well as the RTM API?
08:49:20 <angerman> mpickering: well, I think I know how to do it with curln now properly. But having to flatten the first level of arguments into what Wreq calls FormParam
08:49:42 <angerman> mpickering: does work. But you get a stupid "name (bot)" lable. Though you always get that.
08:50:25 <mpickering> I'm not sure where in the namespace would be best either
08:50:53 <angerman> mpickering: I have my hack in Web.Slack.WebAPI, but that feel's a littel wrong.
08:51:35 <kangkang> > take 5 [1..]
08:51:36 <lambdabot>  [1,2,3,4,5]
08:51:55 <kangkang> @hoogle [a] -> [a]
08:51:58 <lambdabot> Prelude cycle :: [a] -> [a]
08:51:58 <lambdabot> Data.List cycle :: [a] -> [a]
08:51:58 <lambdabot> Prelude init :: [a] -> [a]
08:53:00 <kangkang> @pl \xs n -> take n xs
08:53:00 <lambdabot> flip take
08:53:25 <kangkang> @pl  \x y z -> y
08:53:25 <lambdabot> const const
08:53:31 <kangkang> @pl  \x y z -> z
08:53:31 <lambdabot> const (const id)
08:53:43 <mpickering> angerman: There are quite a few methods so maybe something like Web.Slack.API.Group
08:53:48 <kangkang> @pl  \x y z -> x
08:53:48 <lambdabot> const . const
08:53:51 <mpickering> or even a seperate package which depends on slack-api
08:53:57 <kangkang> @pl  \x y z t -> t
08:53:57 <lambdabot> const (const (const id))
08:54:00 <kangkang> @pl  \x y z t -> z
08:54:00 <lambdabot> const (const const)
08:54:13 <toblerone> Anyone else find ghc-mod (at least with vim) to be unusably slow? Running GhcModCheck and GhcModType regularly block for ~20 seconds. How do people put up with that?
08:54:19 <angerman> mpickering: could probably do without depending on slack-api, I guess.
08:54:43 <mpickering> I assume that you would want to use the FromJSON instances tho?
08:55:06 <angerman> mpickering: will see, I guess :) I'm just experimenting right now.
08:55:20 <mpickering> I figured that they might be the most useful thing for anyone else trying to use the api heh as they were definitely painful to write
08:55:42 <angerman> I think I'll open an issue on their page, separate to the tweet i sent them about attachments missing.
08:57:49 <mpickering> hopefully they respond, I don;t think they use strong typing internally which might explain why their API has different types floating around everywhere
08:57:54 <angerman> mpickering: they certainly are.
08:58:07 <angerman> mpickering: helpful that is.
08:58:28 <angerman> mpickering: and no, they probably don't I still don't get why they apparently randomly quote elements.
08:58:51 <angerman> mpickering: maybe they use JS internally, and it's confused about it's types as well :D
08:59:00 <mpickering> I think they use php
08:59:23 <angerman> for the websocket stuff as well?
08:59:26 <angerman> ahh well.
08:59:35 <mpickering> and I get the impression that the rtm api is what they use internally to power slack
09:01:28 <angerman> mpickering: I agree.  It does feel like reinventing the wheel kinda though.  Like we didn't have irc already.
09:02:27 <angerman> mpickering: makes you wonder, if you reimplement the RTM api, could you trick the slack app into using the reimplemented system? :D
09:04:04 <sternenseemann> hey you guys!
09:04:34 <sternenseemann> what is in you opinion the proper™ way of getting from ByteString to String with correct UTF-8 encoding?
09:04:48 <sternenseemann> or even Data.ByteString.Char8.ByteString
09:05:21 <mpickering> how did you get this ByteString
09:05:35 * hackagebot IPv6Addr 0.6.0.0 - Library to deal with IPv6 address text representations.  http://hackage.haskell.org/package/IPv6Addr-0.6.0.0 (MichelBoucey)
09:05:35 <sternenseemann> mpickering: Network
09:05:44 <jedai> @where utf8-string
09:05:44 <lambdabot> I know nothing about utf8-string.
09:06:15 <sternenseemann> jedai: okay, utf8-string sounds reasonable
09:06:33 <mpickering> you can use Data.Text.Encoding if you want Text
09:07:19 <jedai> sternenseemann: except if you really want String, Text is better though :)
09:07:56 <sternenseemann> jedai: I know, I know but I find using Text pretty inconvinient
09:08:27 <sternenseemann> jedai: because the function names obviously clash and then you've got this T.cons, T.map, T.anything stuff
09:08:28 <jedai> sternenseemann: Really, in what context ? even with the OverloadedStrings ?
09:08:54 <jedai> True, except if you use one of the alternative Prelude I guess
09:08:56 <sternenseemann> jedai: OverloadedStrings means operator overloading for Strings? :O
09:09:28 <jedai> sternenseemann: It just allows you to write your Text directly as literal strings, no T.pack needed
09:09:30 <sternenseemann> also as a annoyance I often find myself reimplementing elem for Text using findIndex
09:09:36 <kadoban> sternenseemann: It makes string literals behave like number literals, that's about it. (You don't have to explicitly convert literals to Text)
09:09:44 <Welkin> sternenseemann: you can hide PRelude
09:09:52 <sternenseemann> Welkin: I see
09:10:05 <sternenseemann> well I have to do further considering
09:10:39 <Welkin> you can also just import qualified Prelude
09:10:48 <sternenseemann> since I am writing a small irc library with a friend for fun, I will consider this
09:11:19 <sternenseemann> we decided it would be the simplest option to go with String in the beginning
09:11:28 <Welkin> I'm a fan of String
09:11:54 <sternenseemann> Welkin: of course, it let's you do all the fancy list manipulation stuff
09:12:09 <sternenseemann> does pattern matching on Text work with OverloadedStrings?
09:12:30 <Welkin> I don't think there is a way to pattern match on Text
09:12:39 <Welkin> since it is an array
09:12:40 <Iceland_jack> PatternSynonyms
09:12:43 <Welkin> you can use ViewPAtterns
09:13:26 <Iceland_jack>     pattern Nil      <- (uncons -> Nothing)
09:13:26 <Iceland_jack>     pattern a ::: as <- (uncons -> Just (a, as))
09:13:56 <Welkin> oh, is PatternSynonyms just another way to use ViewPatterns?
09:14:32 <Iceland_jack> You can use view patterns in (unidirectional) pattern synonyms in GHC 7.8+, but they are distinct
09:14:43 <jedai> Welkin: No, it's more than that, especially if you have bidirectional patterns
09:15:19 <Welkin> I find myself using ViewPatterns with Sequence all the time
09:15:20 <Iceland_jack> You can then make the Nil/(::) patterns bidirectional in 7.10
09:15:53 <Iceland_jack> Welkin: using pattern synonyms you could write:
09:15:53 <Iceland_jack>     firstAndLast (x :<: _ :>: y) = (x, y)
09:16:31 <jedai> PatternSynonims are very interesting, they have nice potential to make abstract types usage more idiomatic in Haskell
09:16:49 <Iceland_jack> @google Iceland_jack pattern synonyms
09:16:50 <lambdabot> https://ghc.haskell.org/trac/ghc/ticket/9226
09:16:56 <Iceland_jack> meh
09:17:01 <Iceland_jack> @google Iceland_jack pattern synonyms IRC
09:17:02 <lambdabot> https://www.fpcomplete.com/user/icelandj/Pattern%20synonyms
09:17:05 <Iceland_jack> has some examples
09:17:45 <Iceland_jack> (correction, explicitly bidirectional pattern synonyms are slated for 7.12)
09:24:33 <ReinH> Iceland_jack: I should use things like pattern synonyms and view patterns more...
09:24:51 <ReinH> Maybe I'll use view patterns and pattern guards at the same time.
09:24:53 <lush> hi everyone
09:24:56 <cmccann> ReinH: use ALL the things!
09:25:11 <byorgey> hi lush
09:25:17 <ReinH> lush: o/
09:25:18 <mpickering> Iceland_jack: are they not in ghc 7.10?
09:25:22 <cmccann> ReinH: if your list of LANGUAGE pragmas isn't longer than the module itself, you're not trying hard enough
09:25:46 <ReinH> cmccann: Hmmm... I need to try about 50% harder then.
09:26:24 <Iceland_jack> They are very powerful, the current implemention is limited in several ways though
09:27:08 <Iceland_jack> mpickering: PatternSynonyms appeared in 7.8 with some features and fixes in 7.10, the explicitely bidirectional pattern synonyms were slated for 7.10 but got pushed back
09:28:58 <voidzero> Sometimes people seem to recommend using Text over String. What's the difference?
09:29:18 <cmccann> voidzero: Text is what you expect a string to be in other languages. String is a linked list of unicode characters.
09:29:34 <ChristianS> voidzero: and practically, text is much faster
09:29:49 <ChristianS> voidzero: also more memory-efficient
09:30:04 <cmccann> in many cases it doesn't really matter, and sometimes you actually want a list of characters
09:30:35 <cmccann> but for text strings you intend to keep around Text is probably much better
09:31:04 <voidzero> Right. So does your first comment cmccann mean that Text is considered as a unit rather than a list of chars?
09:31:29 <Welkin> Text is an array of characters
09:31:30 <voidzero> "foo" being 'f':'o':'o':[] if I understand it right
09:31:36 <lush> voidzero: y
09:31:42 <jedai> besides the text API is more... "text" oriented rather than being a list API that sometimes provides the right tools for text manipulation
09:32:30 <voidzero> Alright. That makes things clearer, thank yous :-)
09:32:42 <ReinH> Strict text is. Lazy text is a list of arrays of characters.
09:33:27 <voidzero> Strict text is considered a unit, you mean?
09:33:29 <ReinH> voidzero: Text is more time and space efficient, properly handles unicode semantics (i.e. toUpper, toLower)
09:34:46 <voidzero> ah, godo ok
09:34:48 <voidzero> good*
09:36:23 <lush> ReinH: "Strict text is. Lazy text is a list of arrays of characters." << like Lazy-Byte-Strings?
09:36:27 <lush> at least kinda
09:36:57 <ReinH> lush: pretty much
09:37:30 <lush> ok ty ReinH
09:37:35 <mniip> wait
09:37:39 <mniip> lazy text is a list of chunks?
09:38:30 <ReinH> lush: In fact they use exactly the same representation.
09:39:08 <ReinH> mniip: Yes, data Text = Empty | Chunk {-# UNPACPK -#} !Strict.Text Text
09:39:27 <ReinH> substitute ByteString and you get Lazy.ByteString
09:39:40 <lush> ReinH: aaah ok
09:40:28 <Profpatsch> Huh, ghci unloads all my local definitions on a :reload
09:40:35 <geekosaur> yes
09:40:37 <Profpatsch> Something like let x = id
09:40:39 <geekosaur> fixing that is hard
09:40:41 <Profpatsch> :reload
09:40:48 <Profpatsch> :t x
09:40:49 <lambdabot> Expr
09:40:57 <ReinH> Profpatsch: recommend sticking them into a module and importing it.
09:40:59 <Profpatsch> -> x not in scope.
09:41:10 <Profpatsch> ReinH: So I can’t keep them?
09:41:12 <glguy> Like geekosaur already mentioned "yes"
09:41:13 <ReinH> Right.
09:41:24 <Profpatsch> mh, okay.
09:41:30 <glguy> If you have something worth keeping it goes in a file
09:41:54 <Profpatsch> well, it’s just a simple alias for a connection string.
09:42:12 <Profpatsch> let run = withConnection "server" "port"
09:49:38 <bananagram> :t x
09:49:40 <lambdabot> Expr
09:49:41 <bananagram> > x
09:49:43 <lambdabot>  x
09:49:47 <bananagram> :t y
09:49:48 <lambdabot> Expr
09:49:52 <bananagram> ???
09:50:08 <geekosaur> lambdabot has the simple-reflect package loaded
09:50:19 <bananagram> hm, okay
09:50:29 <geekosaur> > foldr (+1) 0 [a,b,c]
09:50:31 <lambdabot>  Couldn't match expected type ‘b -> b’
09:50:31 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
09:50:31 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
09:50:38 <geekosaur> whoops, no :p
09:50:43 <geekosaur> > foldr (+) 0 [a,b,c]
09:50:44 <lambdabot>  a + (b + (c + 0))
09:51:19 <geekosaur> a cheap way to visualize simple things like folds, at the price that the single-character alphabetic names are all "in use"
09:51:29 <mniip> > fix (+a)
09:51:35 <lambdabot>  mueval: signalProcess: permission denied (Operation not permitted)
09:51:35 <lambdabot>  mueval-core: Time limit exceeded
09:51:59 <jedai> bananagram: see http://twanvl.nl/blog/haskell/simple-reflection-of-expressions for an explanation
09:52:03 <mniip> > fix (a+)
09:52:05 <lambdabot>  a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a...
09:53:48 <Feuerbach> > fix (+a)
09:53:54 <lambdabot>  mueval: signalProcess: permission denied (Operation not permitted)
09:53:55 <lambdabot>  mueval-core: Time limit exceeded
09:54:18 <Feuerbach> oh, you already ran it above
09:54:36 * Feuerbach felt clever for a second
09:54:58 <Rotaerk> > fix (a .)
09:54:59 <lambdabot>  Couldn't match expected type ‘b -> b’
09:54:59 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
09:55:05 <hpc> > fix (f .)
09:55:07 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
09:55:07 <lambdabot>    arising from a use of ‘M343057341437073259011503.show_M3430573414370732590...
09:55:07 <lambdabot>  The type variable ‘a0’ is ambiguous
09:55:16 <hpc> blech
09:55:29 <jedai> :t (.)
09:55:30 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:55:58 <jedai> So it couldn't work, the operator has to be overloaded to get it to work with simple-reflect after all
09:56:20 <jedai> it could be different if this was the (.) from Category, maybe
09:57:10 <Feuerbach> > f . f
09:57:11 <lambdabot>  Could not deduce (GHC.Show.Show b0)
09:57:11 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
09:57:11 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr c,
09:57:15 <Feuerbach> > (f . f) a
09:57:17 <lambdabot>  Could not deduce (GHC.Show.Show b0)
09:57:17 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
09:57:17 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr c)
09:58:53 <Feuerbach> > f a
09:58:54 <lambdabot>  No instance for (GHC.Show.Show a0)
09:58:54 <lambdabot>    arising from a use of ‘M156858266320227268311623.show_M1568582663202272683...
09:58:54 <lambdabot>  The type variable ‘a0’ is ambiguous
09:58:58 <Feuerbach> I think it's broken
09:59:32 <Iceland_jack> > f a :: Expr
09:59:35 <lambdabot>  f a
09:59:36 <geekosaur> no, it just has no idea what an "f" is
09:59:51 <Iceland_jack> > fun "somefunction" a :: Expr
09:59:52 <lambdabot>  somefunction a
10:00:01 <geekosaur> and because it's implicitly using Show, it's being forced to fix a type for it but can't. explicitly forcing :: Expr resolves that
10:00:02 <Rotaerk> > \x -> fix (x .)
10:00:04 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
10:00:04 <lambdabot>    arising from a use of ‘M560118099783392417111766.show_M5601180997833924171...
10:00:04 <lambdabot>  The type variable ‘a0’ is ambiguous
10:00:30 <jedai> > f . f :: Expr
10:00:37 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
10:00:45 <lambdabot>              with actual type ‘a0 -> c0’
10:00:54 <jedai> This still won't work since (.) couldn't be overloaded for Expr
10:01:23 <mniip> > (\a b x -> a (b x)) f f :: Expr
10:01:25 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
10:01:25 <lambdabot>              with actual type ‘t2 -> t0’
10:01:37 <mniip> oh of course
10:02:01 <byorgey> try getting rid of the x to the left of the ->
10:04:21 <mniip> guys guys I figured it out
10:04:27 <mniip> @let (.) = Debug.SimpleReflect.op Debug.SimpleReflect.InfixR 9 " . "
10:04:28 <lambdabot>  .L.hs:153:12:
10:04:28 <lambdabot>      Ambiguous occurrence ‘.’
10:04:28 <lambdabot>      It could refer to either ‘L..’, defined at .L.hs:150:1
10:04:37 <mniip> aw
10:04:43 <mniip> > let (.) = Debug.SimpleReflect.op Debug.SimpleReflect.InfixR 9 " . " in a . b
10:04:44 <lambdabot>  a . b
10:04:45 <geekosaur> someone already grabbed (.)
10:04:53 <cmccann> a dozen people all trying to figure out how to make lambdabot do something basically useless: the official passtime of #haskell
10:04:54 <mniip> oh?
10:05:30 <HeladoDeBrownie> letting people know that they can test lambdabot in pms: the official pastime of shachaf
10:05:37 <mniip> cmccann, don't worry, it's the same in other language channels
10:05:51 <cmccann> HeladoDeBrownie: hahaha (it's true though)
10:06:20 <geekosaur> all too true, but still tends to discourage people popping in lookbg for help and finding a bunch of "kids" playing with their pet bot...
10:06:30 <geekosaur> *looking for
10:06:45 * geekosaur kant tipe todya
10:07:28 <mniip> I see no people popping in looking for help right now
10:07:40 <glguy> That doesn't mean it's OK to spam the channel
10:07:43 <ReinH> HeladoDeBrownie: it's a noble pursuit.
10:07:46 <mniip> true
10:08:00 <ReinH> mniip: How would you, though, with the chat scrolling off every few seconds? ;)
10:08:21 <mniip> ReinH, please
10:08:33 <mniip> I come from channels where text can scroll at 20 lines per second
10:09:00 <tapuu> Why is the reverse composition operator in control.category infixr 1 while normal composition is infixr 9?
10:09:11 <monochrom> this channel sometimes scroll at 20 lines per second, too. but not by spam.
10:10:21 <cmccann> tapuu: well, >>> and <<< are both infixr 1
10:10:52 <tapuu> . is infixr 9 though
10:10:54 <mniip> monochrom, ooh, do you have fancy events too?
10:10:54 <monochrom> probably historical accident. Prelude's (.) is at 9 for whatever reasons. then you want Category's (.) to be compatible
10:11:35 <hpc> you shouldn't be relying on fixity except in the absolute most obvious cases anyway
10:12:09 <tapuu> I had a load of functions .'d together, and I wanted to reverse the order to make it more readable, but I cant do it without putting in extra brackets because of precedence problems
10:12:29 <tapuu> I'm just confused about why it isn't just infixr 9 to match (.)
10:12:52 <ReinH> tapuu: Who knows? Maybe they pulled a number out of a hat. It's a reasonable complaint.
10:13:49 <monochrom> operator precedence is a lot of historical precedence
10:13:51 <ReinH> Or maybe they intended >>> and <<< for a different use case but no one can remember what.
10:14:04 <cmccann> tapuu: presumably based on expectation of use. low fixity helps for things like constructing complicated arrows that you chain together using >>> or <<<. high fixity helps with things like dense one-liners involving <$> or >>=
10:14:18 <monochrom> <<< and >>> originally came from Arrow. people may be thinking other angles back then
10:14:22 <ReinH> cmccann: That makes the most sense.
10:14:24 <HeladoDeBrownie> lots of answers locked away in dried fruit asylums...
10:14:26 <tapuu> cmccann: that makes sense
10:14:56 <tapuu> I hear reverse $ is being added to prelude
10:15:14 <cmccann> arguably >>> and <<< make more sense for the idiom of long function pipelines where each composition operator starts a new line
10:15:19 <geekosaur> (context of the Arrow remark is that Control.Category gre out of Control.Arrow)
10:15:21 <ReinH> tapuu: You can ofc define your own reverse composition operator with the correct fixity, but a lot of Haskellers seem to prefer the ordering of (.).
10:15:21 <tapuu> A reverse . with the same precedence would be nice too
10:15:27 <ReinH> Except for Richard Bird, at least.
10:15:29 <merijn> tapuu: Not to Prelude, but in base, yes
10:15:29 <geekosaur> *grew out of
10:15:39 <merijn> tapuu: & will be in Data.Function, I believe
10:15:50 <ReinH> Who would probably argue that (.) is the one that is reversed.
10:16:00 <tapuu> merijn: oh ok
10:16:08 <tapuu> ReinH: I agree with that
10:16:35 <geekosaur> (basically Arrow ttuned out to be a rather limited-use abstraction, but could be generalized in at least two ways: one was Category, another became Applicative)
10:16:42 <merijn> I like (.) it reads like the normal function applications without . would read
10:17:07 <geekosaur> (so Category has some Arrow holdovers)
10:17:24 <Welkin> the only time I ever used Arrows was with netwire
10:17:27 <ReinH> But the weird thing is that he reverses composition but *also* reverses type arrows, so he writes f :: b <- a, g :: c <- b, but still writes f . g = \x -> g (f x)
10:17:32 <tapuu> My code has a load of things chained together with (.), and they are on different lines because each part is quite long, and reading it from bottom to top is quite annoying
10:17:59 <tapuu> And to get around the fixity of >>>, I'll have to put parens around the whole thing, which is also annoying
10:18:01 <ReinH> At least, that's the convention he used in Algebra of Programming. It's weird.
10:18:30 <cmccann> tapuu: you could also factor out an expression that's just the composition stuff and give it a name
10:18:38 <ReinH> tapuu: You might use (|>) = flip (.)
10:18:43 <ReinH> It reads reasonably well.
10:18:53 <tapuu> ReinH: I've been meaning to read that book for a while
10:18:56 <ReinH> And has some precedent.
10:19:03 <ReinH> tapuu: It's very good, but expensive :(
10:19:10 <merijn> tapuu: Why not split them off into smaller where definitions?
10:19:24 <ReinH> But spoiler alert, there's actually a fair amount of category theory in it ;)
10:19:27 <cmccann> ReinH: I think the precedent for (|>) is mostly flip ($)
10:19:34 <merijn> tapuu: i.e. "foo . blah where foo = bar . baz; blah = quux . xyzzy"
10:19:36 <breadmonster> ReinH: What's the Algebra of Programming?
10:19:44 <ReinH> cmccann: I thnk |> is flip (.) in F# and Elixir, at least?
10:19:55 <merijn> ReinH: No, it's flip $
10:20:00 <merijn> i.e.
10:20:00 <cmccann> ReinH: pretty sure it's flipped application in F# at least
10:20:03 <ReinH> Hmm.
10:20:04 <merijn> :t (&)
10:20:05 <lambdabot> a -> (a -> b) -> b
10:20:11 <ReinH> Well then.
10:20:11 <merijn> :t flip ($)
10:20:12 <lambdabot> b -> (b -> c) -> c
10:20:13 <Procian> And in Ocaml too.
10:20:15 <merijn> :t flip (.)
10:20:16 <lambdabot> (a -> b) -> (b -> c) -> a -> c
10:20:33 <ReinH> breadmonster: A book by Richard Bird.
10:20:36 <merijn> Needs more Kleisli
10:20:46 <tapuu> merijn, ReinH: I could do that, but I really think a reverse composition operator would look nicer
10:21:05 <tapuu> Wait, maybe I could do this with reverse kleisli
10:21:05 <ReinH> tapuu: That *would* be a reverse composition operator. I guess you mean some other symbol?
10:21:53 <tapuu> ReinH: I'm confused. what would be a reverse composition operator?
10:22:11 <ReinH> tapuu: (|>) = flip (.)
10:22:50 <tapuu> ReinH: That could work, but it might confuse people because in F# its reverse application
10:23:06 <tapuu> I think
10:23:15 <ReinH> Procian: Wait, OCaml has a composition operator?
10:23:19 <ReinH> Oh right, it doesn't
10:23:25 <cmccann> tapuu: making up your own operator for function composition is going to confuse people anyway tbh
10:23:25 <ReinH> Batteries included adds -| and |-
10:23:47 <cmccann> tapuu: so just pick one that looks nice, define it in an obvious place, and move on
10:25:20 <tapuu> ReinH: What is batteries included?
10:25:56 <ReinH> tapuu: A sort of missing Prelude for OCaml http://batteries.forge.ocamlcore.org/
10:27:31 <ReinH> tapuu: personally I suggest retraining your brain to prefer (.) ;)
10:27:38 <jedai> ReinH: It's a bit more than the Prelude though
10:27:41 <KaneTW> :t $
10:27:42 <lambdabot>     parse error on input ‘$’
10:27:42 <lambdabot>     Perhaps you intended to use TemplateHaskell
10:27:43 <ReinH> jedai: true enough
10:27:57 <KaneTW> :t ($)
10:27:58 <lambdabot> (a -> b) -> a -> b
10:29:12 <tapuu> Is there an infix flip?
10:29:40 <ChristianS> tapuu: `flip` ?
10:29:42 <ReinH> `flip` ;)
10:29:48 <ReinH> :t (??)
10:29:49 <lambdabot> Functor f => f (a -> b) -> a -> f b
10:30:03 <tapuu> lol
10:30:05 <ReinH> Nope.
10:33:24 <monochrom> > map `flip` [1, 2, 3] $ negate
10:33:25 <lambdabot>  [-1,-2,-3]
10:33:32 <monochrom> \∩/
10:44:28 <pjdelport> > [1,2,3] <**> pure negate
10:44:29 <lambdabot>  [-1,-2,-3]
10:45:44 <monochrom> nice
10:51:23 <Welkin> :t (<**>)
10:51:25 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
10:51:34 <Welkin> flip <*>
10:51:36 <kqr> :t (<*>)
10:51:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:51:44 <tapuu> I tried to use .., but then I realised its part of list comprehensions
10:51:44 <kqr> ah yeah thought it looked similar
10:52:32 <byorgey> Welkin: <**> and  flip <*>  differ in the order in which the effects happen
10:53:21 <byorgey> > [1,2] <**> [(^2), (+10)]
10:53:23 <lambdabot>  [1,11,4,12]
10:53:35 <byorgey> > flip (<*>) [1,2] [(^2), (+10)]
10:53:37 <lambdabot>  can't find file: L.hs
10:53:42 <byorgey> > flip (<*>) [1,2] [(^2), (+10)]
10:53:44 <lambdabot>  [1,4,11,12]
10:54:55 <Welkin> I see
11:05:42 * hackagebot jammittools 0.4 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.4 (mtolly)
11:31:43 <Procian> ReinH: Of course.
11:32:09 <Procian> But (|>) is of type a -> (a -> b) -> b
11:34:16 <Procian> But yeah, it's in Batteries, which I now take to be de facto standard Ocaml.
11:35:24 <ReinH> Procian: fair enough :)
11:36:15 <tapuu> I really think a standardized reverse composition operator needs to exist
11:36:47 <quchen> (&) is pretty standard now due to Lens
11:36:56 <quchen> It's reverse application, not composition, though.
11:37:01 <Welkin> it does (>>>) and (<<<)
11:37:19 <Saizan> :t (&)
11:37:20 <lambdabot> a -> (a -> b) -> b
11:37:26 <tapuu> quchen: that operator is being added to Data.Function, so it will be even more standard
11:38:02 <shachaf> What a mess.
11:38:10 <tapuu> Welkin: Those functions have a strange precedence
11:40:51 <Patient0> Hi guys - newbie Haskeller here
11:40:55 <sinelaw> When building an AST, would you rather add another primitive, or parameterize an existing one? I have non-curried function application, but now I need partial application. Should I add a boolean (isPartial) to the existing AST node, or should I extend the AST?
11:41:00 <Patient0> I have written a Haskell program to play tic tac toe
11:41:03 <Patient0> https://github.com/Patient0/TicTacToe/blob/master/game.hs
11:41:27 <sinelaw> I assume it's a question of taste, but would like to hear
11:41:29 <Patient0> to improve performance, I added a "BoardCache" to remember board situations that have been seen before
11:41:54 <Patient0> For a lot of the logic I could use the State monad to transparently pass the board cache around
11:42:25 <cmccann> Patient0: that's a reasonable use of State if that's what you're wondering
11:42:26 <Patient0> but then for the interactive part, the only way I have figured out to do it in combination with the IO monad is to pass it explicitly, which is quite cumbersome as you can see
11:42:58 <cmccann> Patient0: you can use the StateT monad transformer for that if you want
11:43:07 <tapuu> Patient0: Have you considered using  amemoized function instead of passing a cache around explicitly?
11:43:39 <Patient0> tapuu: How would a memoized function look?
11:43:40 <cmccann> Patient0: but I'd be more inclined to consider refactoring so that your game logic isn't mixed in with IO stuff
11:44:31 <tapuu> Patient0: depends, there are a lot of ways to do it
11:45:01 <tapuu> Patient0: basically, you end up with a function that has the logic for caching built in. The function remembers the results of its previous calls
11:45:02 <cmccann> Patient0: the basic idea is like pre-constructing a cache of every possible value, and rely on laziness to ensure that only the states you inspect are evaluated
11:45:07 <Patient0> cmccann: the stuff in the IO monad is where it's actually reading/writing, validating the move they typed in etc. -> how could I refactor it to use less IO monad?
11:45:39 <Welkin> Patient0: put all of your IO code inside of main
11:45:44 * hackagebot adblock2privoxy 1.3.2 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.3.2 (zubr)
11:46:05 <Welkin> so all of those functions that produce IO something will now produce something
11:46:27 <Welkin> you can lift it into IO in main
11:46:58 <cmccann> Patient0: I dunno, I'd have to examine the code a bit more thoroughly to say and I'm busy atm. just something to think about; the way you're doing it now is fine, just possibly not the best.
11:47:46 <Patient0> cmccann: yes I am quite sure that the way I am currently doing it is not the best -> it's way too ugly ;-)
11:47:50 <ReinH> Patient0: Mostly, just try to think about having a separation between parts of your code that use IO and parts that don't need to, and try to make the IO parts as few and as small as possible. Think about it like you are writing an interface between the IO code and the "pure" code.
11:48:20 <ReinH> And try to make that boundary nice and small and easy to reason about.
11:48:56 <ansible1> hey all; trying to compile a yesod proj on ARM - fails with "symbol _GLOBAL_OFFSET_TABLE_' ghc: unable to load packagepersistent-sqlite-2.1.1.2'"
11:49:43 <ReinH> For example, if you have an algorithm for a computer player, makeMove could be of type IO Board -> IO Board (ignoring your board cache) but really it only needs to be of type Board -> Board.
11:50:11 <ansible1> according to my internet research that GOT is pretty essential for a lib...  this ring any bells as to what might be the trouble?
11:51:46 <cmccann> Patient0: as a fairly simple example, you could make them polymorphic in the monad used and pass in the explicit IO actions. that would make it easy to, e.g., test it by swapping out IO for something that will feed in a fixed sequence of inputs.
11:52:33 <Patient0> ReinH, Welkin, cmccann, tapuu: thanks ok I will see if I can abstract out the IO stuff as much as possible
11:52:38 <ReinH> cmccann: Flipping that around, you could also use a free monad and "evaluate it" using IO :)
11:52:46 <ReinH> But that's maybe best saved for later
11:52:48 <tapuu> Patient0: from what I can see, the board cache is only being used in checkScoreM
11:53:05 <tapuu> Patient0: you could memoize the checkScoreM function
11:53:37 <Patient0> tapuu: yes - that's the the bit that is "memoizing" the score as a function of the board, as you say
11:53:44 <ReinH> I actually don't understand why you would cache or memoize a tic-tac-toe board. Positions never repeat.
11:53:50 <ReinH> I guess if you play multiple games.
11:54:12 <ReinH> But then you could easily pre-compute the entire decision tree.
11:54:15 <Patient0> ReinH: it's because there's lots of different ways to get to the same board position when searching
11:54:18 <cmccann> isn't it doing a game tree search? that would hit duplicates.
11:54:32 <cmccann> quite often, I expect
11:54:35 <ReinH> cmccann: Good point.
11:54:51 <ReinH> Still, the entire decision tree for tic-tac-toe is relatively small.
11:55:09 <Patient0> ReinH: yes it could just precompute - my eventual goal is to generalize it to play any sort of game using a minimax algorithm (I also have to figure out how to add alpha-beta pruning)
11:55:17 <ReinH> Then again, if you're doing this as a learning exercise, it's reasonable to want to learn about caching game states.
11:55:20 <cmccann> yes, and pre-computing it without forcing evaluation is basically back to the memoization
11:55:21 <ReinH> So I will be quiet.
11:55:33 <Patient0> so I just picked tic tac toe as a toy example
11:55:34 <tapuu> Patient0: I think what you need to do is, make scoreM into a Board -> Int, and then memoize that
11:55:47 <tapuu> so scoreM will remember the results of its previous calls
11:56:11 <Patient0> "and the memoize that" -> is there some explicit step there?
11:56:36 <tapuu> Patient0: There are various libraries that give you 'memoize' function
11:56:50 <ReinH> Patient0: You can use, e.g., https://hackage.haskell.org/package/data-memocombinators
11:56:50 <tapuu> :t memo
11:56:51 <lambdabot> Not in scope: ‘memo’
11:56:57 <tapuu> :t memoize
11:56:58 <lambdabot> Not in scope: ‘memoize’
11:57:07 <tapuu> lol
11:57:59 <Welkin> https://wiki.haskell.org/Memoization
11:58:21 <Patient0> tapuu: lambdabot appears to be having difficulty remembering (I'll get my coat)
11:58:55 <tapuu> https://hackage.haskell.org/package/memoize/docs/Data-Function-Memoize.html#v:memoize
11:59:01 <tapuu> https://hackage.haskell.org/package/MemoTrie/docs/Data-MemoTrie.html#v:memo
11:59:08 <tapuu> There you go
11:59:28 <shiona> is it possible to define that a nested functor is a functor?
11:59:37 <Zekka> Patient0: You might have an interesting time with Quarto, which has a lot of boards which are basically equivalent
11:59:40 <cmccann> Patient0: you could do something like "scoreM = let cache = { build a cache for every possible board state } in (cache Map.!)"
11:59:47 <Zekka> Not that that's relevant to your problem but you might have fun with it
12:00:07 <Zekka> (It's basically a variant of Tic-Tac-Toe with a 4x4 board)
12:00:18 <cmccann> needs more quantum tic-tac-toe
12:00:24 <Zekka> (oh, and four binary qualities instead of just one)
12:01:03 <sinelaw> gobblet gobblers is also a nice variant
12:01:46 <tapuu> Patient0: Your code actually has more recursion than I thought, you may have to use memofix
12:10:03 <favetelinguis> what am i missing, trying to sample from this instance of arbitrary http://lpaste.net/120141
12:15:30 <favetelinguis> newer mind i foud the error: Gen MyEnum
12:16:19 <athan> orzo: There's also some complexity that is really difficult to capture
12:16:23 <athan> for instance, making a type family / function that has instances with (type level) constraints
12:16:26 <athan> (for many reason's it's not "possible" / practical)
12:16:30 <athan> oh shoot
12:16:34 <athan> sorry
12:16:38 <athan> osa1 ^
12:16:39 <athan> (or both)
12:16:51 <athan> @hackage dag orzo, osa1, check out the code in this one
12:16:51 <lambdabot> http://hackage.haskell.org/package/dag orzo, osa1, check out the code in this one
12:17:18 <athan> I did it wrong, but it tries to go very _far_, I suppose
12:17:28 <athan> in how much can be programmed at the type level
12:18:03 <athan> I make conclusions, inductively on the whole structure of the `EdgeSchema`, in each step of it's value - inductive structure
12:18:32 <athan> (and thus, it only goes _one-direction_ - you can't pattern match on an `EdgeSchema`)
12:19:06 <athan> I might be able to build more out, but I'm not that good either - like maybe mid-novice
12:19:34 <EvanR> followed by expert-novice
12:21:01 <athan> EvanR: Then, you have expert-novice-(mid-novice)
12:21:15 <athan> aaand we have arbitrary precision in a trie!
12:27:33 <lush> hi everyone
12:27:55 <begriffs> Does optparse-applicative provide a way to tell users which required arguments are missing if they forget to pass one? It seems like it just prints out the basic usage message listing all the options, but I'd like to add a little customization to highlight what went wrong.
12:28:58 <sinelaw> hi lush
12:33:11 <glguy> begriffs: is this relevant?  noArgError :: ParseError -> Mod OptionFields a Source
12:33:11 <glguy> Specify the error to display when no argument is provided to this option
12:34:15 <csd_> Would someone please take a look at this error message and give me an idea of what the problem is? http://pastebin.com/NVzXJuQp
12:34:19 <begriffs> glguy: the weird thing is that I actually have to say "program --arg" to get the message about arg if arg is supposed to take a value. Doing "program" alone won't do it.
12:34:52 <begriffs> So noArgError is really argSpecifiedButBlankError
12:35:47 * hackagebot indentation 0.2.1 - Indentation sensitive parsing combinators for Parsec and Trifecta  http://hackage.haskell.org/package/indentation-0.2.1 (AlekseyKliger)
12:36:15 <glguy> begriffs: Oh, I dont' know, then. I typically prefer using GetOpt, so it might be possible and I just don't know. One way you can do it is to set a default value for the option (so that it will be set if the user doesn't) and then check at the end for the default values and report an error
12:36:54 <begriffs> glguy: oh clever, I can try that
12:38:55 <friedbrice> I have a question about a Haskell sudoku solver I found that I've been annotating. Here is the source with my annotations: https://github.com/friedbrice/Haskell/blob/master/sudoku.hs
12:40:53 <sbrg> friedbrice: shoot
12:41:12 <friedbrice> So, on line 33, mark has two arguments.
12:41:22 <friedbrice> Then on line 34, it looks like mark is getting fed three arguments.
12:41:40 <sbrg> yes, see the type definition for T
12:42:09 <sbrg> T is a type synonym meaning (Int, Int) -> Int. Every place you see T, you can replace it with that type in your mind
12:42:13 <friedbrice> but then shouldn't it be "mark p (s q)"?
12:43:05 <sbrg> so mark is really mark :: ((Int, Int), Int) -> (Int, Int) -> Int -> T
12:43:20 <sbrg> friedbrice: not sure what you mean
12:44:09 <glguy> The result of  mark x y    is a function
12:44:20 <friedbrice> ah!
12:44:31 <friedbrice> so q is the argument for that function
12:44:41 <friedbrice> i got it, thanks very much.
12:44:42 <glguy> Functions in Haskell all take one argument
12:44:59 <glguy> Some functions return functions
12:45:53 <friedbrice> right, so since mark returns a function, the definition of mark should tell you what that function should to with a representative argument, and q is that representative argument.
12:46:33 <friedbrice> thanks glguy, sbrg
12:51:38 <csd_> How do I type signature a function that I want to behave identically for both Char and [Char]?
12:52:26 <shiona> csd_: you need to make a typeclass that has instances for both Char and [Char]
12:52:33 <shiona> I assume
12:52:37 <hpc> or don't do that, and reconsider what your function is going to do
12:52:49 <Hijiri> csd_: what does your function do?
12:52:53 <shiona> that's also a good idea
12:53:07 <Hijiri> if you use a typeclass it's not behaving identically
12:53:13 <hpc> unless it's id, it can't possibly be doing the same thing to Char and [Char]
12:53:14 <csd_> its one of the toy problems on exercism.io; it converts DNA coding to RNA
12:53:26 <ReinH> Ooh, heres a new GHC error for me https://gist.github.com/reinh/89017cb646d732bd5ae6
12:53:34 <ReinH> Any ideas? I'm stumped.
12:53:44 <csd_> i think they want me to do a class
12:53:51 <hpc> ReinH: have you tried turning it off and on again?
12:53:56 <Hijiri> I don't think I used a class for that exercism
12:54:07 <lush> hpc: IT crowd fan eh?
12:54:10 <afarmer> ReinH: tried a cabal clean first?
12:54:23 <csd_>  what was your approach?
12:54:27 <hpc> ReinH: doesn't ghc still have a ton of issues with clang?
12:54:28 <csd_> @ Hijiri
12:54:43 <ReinH> afarmer: Yep, no luck.
12:54:50 <ReinH> hpc: This is the first one I've encountered.
12:54:57 <afarmer> or possibly you've got packages in .cabal that were compiled by another machine?
12:54:59 <Hijiri> I think I just mapped a nucleotide-changing function
12:55:02 <Hijiri> I don't remember
12:55:33 <ReinH> hpc: I'll try to switch compilers though.
12:56:37 <hpc> csd_: describe how to convert a DNA base pair to an RNA base pair
12:57:00 <hpc> csd_: then describe how to convert a whole chain
12:57:06 <hpc> see what's similar and factor it out
12:57:06 <csd_> http://pastebin.com/KeHGYkcF
12:57:21 <csd_> i'm stumped on how to generalize to either type though
12:57:33 <hpc> write two functions
12:57:56 <csd_> but the tests are prewritten, and they only test one function
12:58:08 <Hijiri> you can write another function and use it in the tested function
12:58:18 <Hijiri> you probably shouldn't use explicit recursion here
12:58:27 <csd_> if i write a helper function though, its still going to either take a char or [char] as input, so i dont see where that gets me
12:58:31 <Hijiri> you can map a nucleotide mapping function onto the dna string
12:58:45 <Hijiri> csd_: do you know what map is?
12:58:48 <csd_> yes
12:59:16 <Hijiri> Lets say I wanted to convert one DNA character to an RNA character, what type would that have?
12:59:33 <csd_> char -> char
12:59:48 <Hijiri> how could I apply that to an entire string?]
13:00:09 <csd_> (char -> char) [char] -> [char]
13:00:23 <Hijiri> no, what function(s) could I use
13:00:23 <CorkExaminer> cabal-1.22.0.0 is giving me an error message that I can make sense of: “With current ghc versions the global package db is always used and must be listed first.”
13:00:26 <Rotaerk> where am I supposed to get the package documentation if the page is like:  http://hackage.haskell.org/package/hxt
13:00:29 <csd_> map, or reduce
13:00:38 <Hijiri> why not use that then?
13:00:41 <Rotaerk> the modules within the package don't have links to the documentation ...
13:00:55 <Hijiri> map should work, reduce is more powerful than you need
13:01:08 <csd_> because the function that is going to call map will still need to take either [char] or char, which seems not to be possible
13:01:10 <hpc> Rotaerk: earlier version, unfortunately
13:01:12 <hpc> http://hackage.haskell.org/package/hxt-9.3.1.3
13:01:18 <Hijiri> The function only takes String
13:01:28 <Rotaerk> hmm thanks
13:01:31 <hpc> "Status	Docs pending
13:01:33 <hpc> Build status unknown
13:01:34 <hpc> "
13:02:02 <csd_> ohh i see my problem
13:02:08 <hpc> it's been an issue for a while, and very few people actually know when haddock is built
13:02:14 <csd_> in the `case` statement, i was returning chars instead of string characters
13:02:42 <CorkExaminer> the cabal error message refernces this ticket: http://hackage.haskell.org/trac/ghc/ticket/5977, fixed 3 years ago
13:02:55 <Hijiri> csd_: you'll still have a problem in the cons case
13:03:04 <csd_> whys that?
13:03:26 <Hijiri> you are calling toRNA x, which wouldn't typecheck because toRNA takes a String
13:03:39 <Hijiri> also, you should use explicit type signatures for all top-level definitions
13:03:43 <csd_> oh right, i'm calling it inconsistently again
13:03:45 <Hijiri> so the compiler can help you when you make a mistake
13:04:00 <Hijiri> this problem is definitely easier with map than explicit recursion
13:04:28 <CorkExaminer> anybody tried to exclude the global package db from their builds?
13:04:51 <Hijiri> CorkExaminer: Do you mean the OS-wide one or the user db?
13:05:08 <Hijiri> because you can't exclude it if it's super global
13:05:09 <CorkExaminer> ecluding the system one
13:05:15 <Hijiri> you can't
13:05:42 <Hijiri> if you have haskell packages installed through your OS's package manager, you will probably have to uninstall them if you want to exclude them from your builds
13:05:48 * hackagebot adblock2privoxy 1.3.3 - Convert adblock config files to privoxy format  http://hackage.haskell.org/package/adblock2privoxy-1.3.3 (zubr)
13:06:03 <Hijiri> This hasn't been a problem for me because I can just install it through cabal
13:06:16 <csd_> @hijiri http://pastebin.com/43mL1VM2
13:06:16 <lambdabot> Unknown command, try @list
13:06:30 <Hijiri> even if you delete the user package db the binaries are statically-linked so you can still use them if they're in your path
13:06:35 <csd_> thanks
13:06:42 <Hijiri> if it's something like xmonad it's a bit more complicated though
13:06:55 <CorkExaminer> I am building a sandboxed environment  and have been told that it is possible to build a sandbox that excludes the global db
13:06:58 <hpc> csd_: when you quote someone, do it like this
13:07:05 <hpc> it's irc, not twitter ;)
13:07:21 <Hijiri> csd_: that looks good, you might want to add an explicit error case to toRNA' though
13:07:29 <csd_> sometimes my ERC screws up and omits the name when I do it that way :-/
13:07:35 <hpc> oh, weird
13:07:38 <Hijiri> just have _ -> error "Descriptive Error Message" or something
13:07:56 <glguy> Corkexaminer: sandbox excludes user db. Global db sticks around, which is good since it includes base
13:07:59 <Hijiri> CorkExaminer: oh, I didn't know it was possible
13:08:52 <csd_>  I'm actually still not clear on why the explicit recursive case wasn't working though, after I changed the single character case to String also
13:09:04 <csd_> the types were all in agreement then
13:09:06 <Hijiri> toRNA is String -> String, right?
13:09:13 <csd_> yeah
13:09:21 <Hijiri> x in toRNA (x:xs) toRNA x : toRNA xs was the bad term
13:09:23 <CorkExaminer> I really need to build from scratch — getting horrible conflicts between the gloabl packages and the version I need
13:09:24 <Hijiri> specifically toRNA x
13:09:26 <Hijiri> because x :: Char
13:09:30 <csd_> ohh
13:09:34 <csd_> tricky
13:09:53 <csd_> how hard do these exercism problems get
13:10:06 <Hijiri> CorkExaminer: what I did is just uninstall any OS packages with global haskell packages and reinstall them through cabal
13:10:08 <CorkExaminer> think I need cabal ninjas for this
13:10:12 <Hijiri> csd_: I don't know, I only did the first few problems
13:10:26 <hhhasdau> I see a lot of texts say stuff like .. 'remove element from list = log(1) operation' - shouldnt it be log(n) because a new list needs to be created?
13:11:07 <shachaf> What says that?
13:11:20 <hpc> they just don't know what big-O notation is lol
13:11:20 <hhhasdau> isnt 'f x:xs = xs' log(n)
13:11:22 <shachaf> log(1) is an odd way of saying 0.
13:11:23 <Hijiri> If you remove the first element you don't need to make a new list
13:11:34 <Hijiri> because the tail is already the list you want
13:11:35 <Rotaerk> hxt is really complicated..
13:11:59 <hhhasdau> Hijiri: what if I remove the i'th element?
13:12:15 <Hijiri> then it's O(n), where n is the index of that element
13:12:21 <Hijiri> for example, lets say the third element
13:12:36 <Hijiri> x:y:z:stuff is now x:y:stuff
13:12:57 <Hijiri> I had to walk from the beginning to z, while keeping track of x and y, then cons them onto stuff
13:13:03 <hhhasdau> are lists in haskell implemented as linked lists?
13:13:06 <Hijiri> yes
13:13:11 <hhhasdau> okay
13:13:17 <hhhasdau> what about lazy evaluation?
13:13:17 <greg`> what is a category?
13:13:24 <greg`> , category
13:13:26 <CorkExaminer> Hijiri: thanks — I am not using one of the distros — have put together the stack myself — just trying to get cabal to forget the global package db and just build from scratch (with rts, etc.)
13:13:28 <hhhasdau> could that be used somehow to combine operations on lists?
13:13:45 <Hijiri> yes, often it does result in combining operations
13:13:48 <Hijiri> I have to go eat though
13:14:02 <Hijiri> an example is map f . map g $ (x:xs)
13:14:11 <greg`> , category
13:14:16 <hhhasdau> Hijiri: do you know of an article that describes this for haskell?
13:14:19 <Hijiri> this because (f . g) x : ((map f . map g) $ xs)
13:14:28 <Hijiri> I could probably find one, but I really do have to go now
13:14:35 <hhhasdau> okay thanks
13:14:50 <Hijiri> probably cis194 in https://github.com/bitemyapp/learnhaskell goes over it, but I really have no idea I am just guessing
13:16:03 <darthdeus> is haskell platform recommended on windows? or is there a better way to install?
13:16:31 <Rotaerk> it's what I used
13:16:48 <EvanR> greg`: a collection of objects and arrows satisfying some laws, the category laws
13:16:59 <greg`> k
13:17:40 <Cale> lol
13:18:02 <Cale> That guy just connected to ask what a category was, and that was apparently enough of an answer for him
13:18:24 <EvanR> heh
13:18:27 <hpc> haha
13:18:58 <hpc> if only that happened more often with "what is a monad?"
13:19:03 <MP2E> I was just thinking that lol
13:19:10 <EvanR> hahaha
13:19:51 <xauth> > x + head []
13:19:52 <lambdabot>  x + *Exception: Prelude.head: empty list
13:22:00 <darthdeus> hmm, the haskell platform download link seems to be broken
13:22:14 <darthdeus> it keeps dying after like 10 seconds
13:22:30 <darthdeus> then fails with unknown network error
13:23:44 <michaelt> Cale: I think he asked what a comma category is
13:29:13 <quchen> darthdeus: Works for me (generic x64 linux download)
13:29:29 <glguy> CorkExaminer: If you want help with your install problem you'll have to paste a bunch of details about it to lpaste.net Disabling the global package db isn't an option
13:29:32 <ReinH> hpc: Now that I've switched to gcc 4.9 I can confirm that it isn't a clang problem :)
13:29:38 <hhhasdau> http://lpaste.net/120145 is the running time of this function log(n) ? can the function be improved?
13:29:52 <hpc> ReinH: well, im confuzzled
13:31:44 <ReinH> hpc: Me too.
13:32:08 <glguy> hhhasdau: No, that function will be O(i), linear in the first argument
13:32:36 <hhhasdau> yeah thats what i mean - n being the length of the list
13:32:48 <hhhasdau> glguy: can this function be written in a more elegant way?
13:34:08 <ReinH> hpc: Well, it's something in the way the test suite is configured, but I don't know whaat
13:34:17 <ReinH> hpc: Solution: stop testing
13:34:22 <CorkExaminer> giguy: question seems pretty striaghtforward to me — and you have given a straightfroward answer, but it conflicts with other information I have from reliable sources — have reported the confusing error to the cabal-devel mailing list
13:34:44 <glguy> OK, sounds good, then.
13:35:50 * hackagebot FontyFruity 0.5 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.5 (VincentBerthoux)
13:37:48 <raniere> given one function in a haskell source code (e.g. from Pandoc) how can I find which library it belongs?
13:37:48 <CorkExaminer> glguy: I have an idea about what is going on — will try and get it confirmed with the cabal devs
13:38:43 <glguy> hhhasdau: any implementation of that function will generally look like what you've written there. If you're doing that operation very often you might not want to use a list
13:39:08 <Hijiri> darthdeus: I recommend http://neilmitchell.blogspot.com/2014/12/beta-testing-windows-minimal-ghc.html
13:39:30 <glguy> hhhasdau: Depending on what you're doing it might be good to handle the case where the list was too short
13:39:44 <hhhasdau> oh right glguy
13:40:50 * hackagebot acme-microwave 0.1.0.2 - The eighth wonder of the world, kitchen math!  http://hackage.haskell.org/package/acme-microwave-0.1.0.2 (JoeQuinn)
13:42:28 <drewbert> Is there a way to ask cabal to render template haskell
13:42:57 <hpc> render as in show you the intermediate output?
13:43:09 <drewbert> yeah
13:43:43 <ReinH> hpc: Attempting to nuke everything from space now... see you in a few hours.
13:43:45 <drewbert> -ddump-splices is ghc options?
13:43:49 <Hijiri> yes
13:50:51 * hackagebot Rasterific 0.5 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.5 (VincentBerthoux)
13:55:51 * hackagebot dotenv 0.1.0.0 - Loads environment variables dotenv files  http://hackage.haskell.org/package/dotenv-0.1.0.0 (jsl)
13:56:01 <lpaste> glguy annotated “No title” with “making extract faster with a continuation for hhhasdau” at http://lpaste.net/120145#a120146
13:57:19 <glguy> hhhasdau: That second version as pasted is significantly faster than the first one if you're doing it with Maybe.    with an index of 10,000   it got   227us runtimes vs   621us
13:57:58 <glguy> It avoids having to do a bunch of casing
13:58:06 <MrMetric> I've found that using a combination of list and Vector is faster than using either one exclusively
13:58:33 <Cale> MrMetric: makes sense, they're better at quite different tasks
13:58:42 <hhhasdau> glguy: hmm seems complicated
13:58:49 <Cale> MrMetric: (though I have no idea what it is that your program does ;)
13:59:19 <MrMetric> Cale: I'm experimenting with rendering the Mandelbrot set using a method other than escape time
13:59:46 <MrMetric> Cale: The relevant part uses elemIndex and :
13:59:58 <glguy> hhhasdau: Whether or not you use that, it's probably worth looking at it a bit. It's a fairly common transformation
14:00:08 <glguy> and would be good to think about
14:00:40 <hhhasdau> glguy: are you comparing the speed of extract vs extractC in your code?
14:00:48 <glguy> extract vs extract'
14:00:51 * hackagebot atomic-write 0.2.0.0 - Atomically write to a file  http://hackage.haskell.org/package/atomic-write-0.2.0.0 (jsl)
14:00:53 * hackagebot yesod-purescript 0.0.4.3 - PureScript integration for Yesod  http://hackage.haskell.org/package/yesod-purescript-0.0.4.3 (mp)
14:00:53 <hhhasdau> oh okay
14:00:56 <glguy> extractC was the helper
14:01:30 <hhhasdau> glguy: what is the 'continuation' you're talking about?
14:02:00 <glguy> last argument to extractC 'k'
14:02:53 <hhhasdau> why is it faster?
14:03:34 <glguy> It doesn't have to repeatedly case through the Maybe (a,[a]) to add the leading elements to the result list
14:04:49 <hhhasdau> okay i have to take a closer look i dont even understand how you're using fmap with maybe
14:05:29 <glguy> ?src Maybe fmap
14:05:30 <lambdabot> fmap _ Nothing  = Nothing
14:05:30 <lambdabot> fmap f (Just a) = Just (f a)
14:05:52 * hackagebot svg-tree 0.1 - SVG file loader and serializer  http://hackage.haskell.org/package/svg-tree-0.1 (VincentBerthoux)
14:05:53 <glguy> and for tuples:   fmap f (x,y) = (x,f y)
14:06:22 <hhhasdau> ah
14:06:23 <glguy> so... (fmap.fmap) f (Just (x,y)) = Just (x, f y) ---- and   (fmap.fmap) _ Nothing = Nothing
14:06:40 <hhhasdau> thats a neat way to avoid that let
14:07:21 --- mode: asimov.freenode.net set +o ChanServ
14:07:36 <hhhasdau> glguy: for some reason when i search 'Maybe fmap' on hoogle i get no results
14:07:50 <hhhasdau> how can I check typeclass implementations for types?
14:08:40 <glguy> I use the "source" links on the haddock pages on hackage
14:09:44 <hhhasdau> ah okay
14:10:17 <hhhasdau> glguy: how did you test the speed?
14:10:28 <glguy> ?hackage criterion
14:10:29 <lambdabot> http://hackage.haskell.org/package/criterion
14:10:51 <hhhasdau> oh ok
14:15:01 <hhhasdau> glguy: the ineffience in the first one comes from the fmap on Maybe right?
14:15:52 * hackagebot dotenv 0.1.0.1 - Loads environment variables from dotenv files  http://hackage.haskell.org/package/dotenv-0.1.0.1 (jsl)
14:15:54 * hackagebot ip6addr 0.5.0.0 - Commandline tool to generate IPv6 address text representations  http://hackage.haskell.org/package/ip6addr-0.5.0.0 (MichelBoucey)
14:16:44 <bramgg> Does my custom data type need to be deriving something to use "snd"/"fst" on it? (If so, what?)
14:17:20 <darthdeus_> did anyone manage to get the mysql package working on windowS?
14:17:36 <hhhasdau> bramgg: snd and fst are just functions on tuples iirc
14:17:42 <darthdeus_> i keep running into this https://github.com/bos/mysql/issues/3
14:17:43 <hhhasdau> not part of a typeclass
14:17:47 <geekosaur> bramgg, fst and snd are not typeclass methods, they are functions on 2-tuples
14:18:40 <glguy> hhhasdau: Comparing to a version that doesn't have a Maybe at all (just undefined if the list is too short) and casing on the tuple runs in 293us compared to 618us with matching on Maybe and 227us with the continuation
14:18:49 <glguy> so it's faster but still not as fast
14:19:34 <hhhasdau> glguy: but the ifficiency in your second version comes from not using fmap right? Trying to understand it properly
14:19:44 <glguy> the fmap itself is irrelevant
14:19:51 <bramgg> Okay, well how can I do something like this? http://lpaste.net/6590446085271977984
14:20:01 <hhhasdau> glguy: i mean the pattern match in the fmap for Maybe
14:20:02 <glguy> it's about if you have to case on the tuple or Maybe _.
14:20:17 <geekosaur> bramgg, you cannot
14:20:49 <hhhasdau> glguy: where is the extra 'case' in the first version?
14:21:03 <bramgg> geekosaur: What would one do instead to acheive the same result?
14:21:04 <glguy> hhhasdau: On the tuple :: (a,[a])
14:21:52 <hhhasdau> glguy: but exctract and extractC both have 3 patterns on the left?
14:22:33 <glguy> extractC doesn't add any cases other than the ones on the index and the list (which every implementation will have)
14:23:15 <hhhasdau> glguy: when you say 'case' what do you mean?
14:24:09 <glguy> destructuring a value of an algebraic data type
14:24:28 <hhhasdau> where does that happen (what line)
14:24:42 <glguy> using the fields of a tuple or maybe, potentially branching when there are more than one constructor
14:25:04 <hhhasdau> glguy: and that happens in the fmap call right?
14:25:24 <glguy> hhhasdau: In this case
14:25:43 <hhhasdau> okay cool now I get it i think
14:26:10 <geekosaur> bramgg, you might define your own functions for it. you can't use fst and snd on that type at all. or you could switch from a `data` to a `type` (that is, a type alias making Test represent a 2-tuple of String-s)
14:26:43 <hhhasdau> glguy: fmap on the 2-tuple doesnt have an extra case cause it applies the function straight to the second element right?
14:26:58 <glguy> No, it has to case on the tuple to get the first and second fields of it
14:27:23 <glguy> and then it makes a new tuple with a modified second element
14:28:14 <hhhasdau> Oh right
14:28:29 <hhhasdau> for some reason im thinking of 'case' as a case in a pattern match
14:29:29 <hhhasdau> glguy: http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Tuple.html is this the right type for the tuple? I dont see it as instance of Functor..
14:29:52 <Profpatsch> I don’t get why this doesn’t work:
14:29:57 <Profpatsch> https://bigmac.caelum.uberspace.de/paste/randomIO.html
14:30:36 <hpc> what's the error?
14:30:41 <glguy> hhhasdau: In GHCi you can type: :i (,) or   :i Functor and you'll see it on either list
14:31:09 <Profpatsch> I get „Couldn’t match expected type Pixelflut Word8 with type a0 -> m0 a1
14:31:13 <bramgg> geekosaur: thanks
14:31:17 <glguy> hhhasdau: Or look at the Functor class directly to see all its instances in base http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#g:9
14:31:21 <chrisdone> liftIO.randomIO
14:31:30 <drewbert> How do you cabal?
14:31:31 <chrisdone> ^ consider that
14:31:40 <chrisdone> how do i cabal'd package?
14:31:48 <hpc> :t randomIO
14:31:49 <hhhasdau> ah thanks glguy
14:31:50 <lambdabot> Random a => IO a
14:31:59 <drewbert> just cabal hell every day all the time
14:32:07 <hpc> hmm
14:32:09 <chrisdone> Profpatsch: see from the type of randomIO?
14:32:13 <benzrf> :t random
14:32:14 <lambdabot> (Random a, RandomGen g) => g -> (a, g)
14:32:15 <johnw> drewbert: Nix is one path to salvation
14:32:18 <Profpatsch> :t liftIO
14:32:19 <lambdabot> MonadIO m => IO a -> m a
14:32:21 <chrisdone> NO SPOILERS
14:32:31 <benzrf> :t liftIO randomIO
14:32:32 <lambdabot> (Random a, MonadIO m) => m a
14:32:40 <chrisdone> benzrf: I SAID NO SPOILERS
14:32:42 <hpc> there's a (.) in the middle
14:32:42 <benzrf> chrisdone: huh?
14:32:43 <drewbert> johnw: does it have new-ish packages?
14:32:44 * chrisdone banishes benzrf  back to PHP
14:32:48 <johnw> drewbert: yes it does
14:32:48 <benzrf> chrisdone: fuck
14:32:52 <chrisdone> =p
14:32:57 <benzrf> chrisdone: i didnt realize what constituted a spoiler from context
14:32:59 <johnw> drewbert: we import new package sets from Hackage every couple of days
14:33:01 <benzrf> i was looking at that for myself
14:33:02 <Profpatsch> Oh, I just need normal function application …
14:33:03 <chrisdone> no biggie
14:33:04 <Profpatsch> Guh
14:33:23 <Profpatsch> chrisdone: That was so obvious.
14:33:27 <Profpatsch> Thx.
14:33:42 <chrisdone> welcome!
14:33:45 <drewbert> johnw: well that's tempting, it seems silly that cabal is so bad I have to change my os to work with it, but idk how else to handle this
14:33:55 <johnw> you don't need to change your OS to run Nix
14:34:00 <johnw> I'm not talking about NixOS
14:34:10 <johnw> just the Nix package manager, which works in parallel with other package managers even
14:34:15 <chrisdone> i sooo need to install nixos
14:34:18 <johnw> (it just can't manage services)
14:34:25 <drewbert> Oh, well then for sure I'm going to check it out.
14:34:37 <johnw> I've been using only that on OS X for about 6 months now, and LOVE it
14:35:00 <chrisdone> drewbert: are you using a sandbox?
14:35:27 <drewbert> chrisdone: yes
14:36:06 <chrisdone> drewbert: you could use stackage if it has the packages you need
14:36:17 <drewbert> chrisdone: it does not
14:36:38 <chrisdone> drewbert: it still might help though
14:36:47 <chrisdone> the packages that aren't in it might not build, but at least everything else will
14:36:49 <drewbert> chrisdone: I'm occasionally finding packages that need a little tweaking, so I download and tweak them, "cabal sandbox add-source" and reinstall.  Explosions.
14:37:04 <chrisdone> asplode
14:37:28 <johnw> It should be fairly easy now for next to make this package package set and install target, for example: nix-env -i stackagePackages_<date>.lens
14:37:37 <johnw>  I think it's just that nobody has done the work to make that happen yet
14:37:44 <zq> how would i strictify the elements of a list literal?
14:38:04 <johnw> zq: the same way you've force any list
14:38:18 <johnw> evaluate its length in IO, or deepseq it, or by other means
14:38:30 <chrisdone> @pl \xs -> seq (length xs) xs
14:38:30 <lambdabot> seq =<< length
14:41:08 <zq> i'm not sure i understand
14:41:21 <chrisdone> zq: what do you want to force of the list? the spine or all the elements?
14:41:38 <zq> chrisdone: force each element as it comes, but not the spine, if that makes sense
14:41:40 <chrisdone> > length [1..] -- this does not terminate because it forces the spine, which is endless
14:41:44 <lambdabot>  mueval-core: Time limit exceeded
14:41:45 <chrisdone> ahhh
14:41:51 <johnw> and should the elements just be forced to weak head normal form?
14:41:53 <chrisdone> yeah, that depends on the consumer
14:42:24 <zq> see, i've got "putStrLn $ unwords output" where output = [show something, unwords . map show $ something_else, ...]
14:42:49 <chrisdone> looks  ok
14:42:52 <zq> and it's building up thunks for each of the appls inside the list
14:42:52 <chrisdone> what's wrong?
14:43:08 <johnw> zq: how do you know that?
14:43:15 <chrisdone> so what's wrong with that?
14:43:41 <zq> chrisdone: why don't you think that it's suboptimal?
14:43:52 <chrisdone> zq: how big is your list?
14:43:57 <johnw> zq: it should be only building one thunk at a time in your scenario
14:44:09 <johnw> one thunk for the list, and then when it's forced, a thunk for the remainder, etc., all the way until the end
14:44:35 <johnw> but I doubt it's making a "whole bunch of thunks" right away, as I think you're implying
14:45:10 <benzrf> linked lists~
14:45:21 <chrisdone> benzrf: such consing and O(n)
14:45:21 <benzrf> whod've thunk it
14:45:35 <chrisdone> wow, lack of cache locality
14:45:40 <chrisdone> much indirection
14:45:54 * hackagebot rasterific-svg 0.1 - SVG renderer based on Rasterific.  http://hackage.haskell.org/package/rasterific-svg-0.1 (VincentBerthoux)
14:45:55 <hpc> benzrf: terrible pun
14:45:57 <benzrf> shhhh
14:45:59 <benzrf> doge is a dead meme
14:46:05 <benzrf> dont keep beating a dead doge
14:46:22 <benzrf> hpc: thx
14:46:38 <hpc> @let pun = "whod've thunk it" ++ undefined -- :D
14:46:39 <chrisdone> benzrf: hey man, i'm a meme veteran. i was there back in the caturdays before the "lolcats" abominations
14:46:41 <lambdabot>  Defined.
14:46:52 <chrisdone> benzrf: i need this
14:47:07 <chrisdone> hpc: who'd
14:47:14 <benzrf> who'd've
14:47:18 * chrisdone gesticulates drammatically at the typo
14:47:20 <hpc> haha
14:47:27 <benzrf> chrisdone: i'll have you know i'm a professional memer
14:47:50 * chrisdone inspects benzrf's meme card
14:48:02 <chrisdone> oh my god, it even has a watermark
14:48:05 <EvanR> after 10 memes the 11th is free
14:49:01 <chrisdone> zq: is the problem that you're using the list a bunch of times? it's not clear what the issue is at the moment =)
14:49:56 <chrisdone> and jesus looked upon the disciples and said "i can turn haskell into core"
14:50:19 <EvanR> ghcsus
14:50:27 <hpc> all of the disciples were named simon
14:50:28 <chrisdone> hahaha
14:50:33 <chrisdone> hahahaha
14:50:54 <benzrf> are there any simons besides spj and marlow
14:51:02 <chrisdone> lambdabot: give karma to everyone
14:51:04 <johnw> and thus simony is allowed
14:51:10 <benzrf> johnw: ay
14:51:19 <benzrf> johnw: ayyy
14:51:36 * chrisdone glances around nervously
14:51:46 <chrisdone> simon_: is this real life?
14:51:57 <johnw> i think it's memorex
14:52:13 <scott> i have a question is memes a monad
14:52:36 <johnw> scott: define how a meme that references a meme resolves to a single meme
14:52:42 <chrisdone> what are the equational laws of a meme
14:52:51 <geekosaur> more that monads are a meme :p
14:53:02 <hpc> johnw: yo dawg, obviously
14:53:05 <johnw> there is always the burrito meme
14:56:57 <drewbert> you can model memes as arrows, some memes are monadic arrows
14:58:03 <benzrf> burrito memes http://www.memecenter.com/search/burrito
14:58:29 <Shockk> hello, I have a cabal project and in the ghc-options field of the executable section in its cabal file, I've specified -rtsopts
14:59:02 <Shockk> however, when attempting to run my program with a specified RTS options on the command line
14:59:08 <Shockk> "cabal: Most RTS options are disabled. Link with -rtsopts to enable them. "
14:59:33 <Shockk> (if it makes a difference, I'm running this with cabal exec)
14:59:45 <geekosaur> it matters, yes
14:59:55 <geekosaur> cabal exec -- program +RTS -rtsopts
15:00:03 <geekosaur> (hopefully)
15:00:22 <Shockk> ooh right
15:00:36 <geekosaur> or possibly needs to be something evil like cabal --RTS exec program +RTS ...
15:00:42 <Shockk> so it was actually being specified to cabal itself then?
15:00:49 <geekosaur> (the --RTS stops the cabal program from eating the other +RTS)
15:00:50 <Shockk> it does work with --
15:00:51 <geekosaur> yes
15:01:05 <Shockk> great, thanks
15:01:10 <danilo2> Hello! I would like to ask you how to use type holes in top level haskell expressions? I've got for example a function: foo = ... and I want to get information about its type from compiler. I tried writing "foo :: _" but it reports sntax error
15:02:02 <johnw> if you omit the type altogether and compile with -Wall
15:02:05 <johnw> it should report it to you
15:03:16 <pavonia> Can you use holes in types too?
15:03:25 <johnw> not yet
15:03:29 <Shockk> danilo2: if you just want the compiler to deduce the type of foo based on what it =, you can omit the type signature
15:03:34 <johnw> but () works there, to forcibly mismatch
15:03:59 <benzrf> danilo2 you use type hooles as expressions:
15:04:01 <benzrf> > 3 + _num
15:04:03 <lambdabot>  Found hole ‘_num’ with type: a
15:04:03 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
15:04:03 <lambdabot>             the inferred type of it :: a at Top level
15:04:12 <danilo2> Shockk: I know that :) pavonia, johnw: Of course -Wall will work - I was just trying to use type holes there
15:04:36 <danilo2> benzrf: yep, I was just thinking if we can use them as signatures :)
15:05:08 <geekosaur> they may be planning to use that for partial type signatures, which would be a conflict
15:09:24 <mpickering> Is there a good way to debug generic traversals?
15:11:03 <chrisdone> mpickering: Debug.Trace comes in handy for that
15:11:23 <chrisdone> mpickering: what kind of generic traversals?
15:12:48 <mpickering> It's a SYB traversal, mkQ and everything
15:13:02 <mpickering> the function given to mkQ never seems to get fired
15:14:09 <enthropy> probably are looking for a type that's not in the data you've given
15:15:10 <chrisdone> enthropy: r u jedi
15:15:24 <enthropy> that's what happens to me when syb doesn't work
15:15:40 <chrisdone> yeah, trace . show . typeOf
15:21:05 <shachaf> That sounds like the main reason mkQ would fail.
15:21:08 <drewbert> chrisdone: could you run me through how the handle the situation i described earlier using nix?  the situation where I need to tweak an installed package and rebuild?
15:22:53 <chrisdone> drewbert: i don't know nix. ping johnw
15:23:38 <mpickering> enthropy: My expected type shows up in the log, hmmm
15:24:30 <enthropy> mpickering: what are you giving mkQ to?
15:26:17 <mpickering> enthropy: everything
15:27:37 <enthropy> and you're not doing something like "everything const"
15:28:46 <mpickering> everything (.), I'm trying a simpler example with everything (++) now
15:29:14 <mpickering> could putting type class constraints on my traversal function cause problems?
15:34:16 <mpickering> in fact.. I think the problem is that ghc fails to infer to type of `transform` so I specified it but made it overly specific
15:34:31 <mpickering> and I'm not sure how to properly specify the type to get it to typecheck
15:36:30 <enthropy> you'll have to show a bit more of what you're doing to get some help at this point
15:37:51 <mseeks> does AcidState support concurrent access?
15:38:02 <mseeks> i.e., could I use AcidState basically as a drop-in replacement for TVar?
15:40:57 * hackagebot postgrest 0.2.5.3 - REST API for any Postgres database  http://hackage.haskell.org/package/postgrest-0.2.5.3 (begriffs)
15:40:59 * hackagebot readable 0.3.1 - Reading from Text and ByteString  http://hackage.haskell.org/package/readable-0.3.1 (DougBeardsley)
15:44:04 <agocorona> mseeks:  DBRefs are TVars that persist. in the package TCache
15:45:10 <lpaste> mpickering pasted “SYB type sigs” at http://lpaste.net/120148
15:45:29 <lpaste> mpickering revised “SYB type sigs”: “No title” at http://lpaste.net/120148
15:45:46 <mpickering> enthropy: ^ if you have a spare minute
15:46:36 <mseeks> agocorona: what does TVar have that AcidStates don't?
15:47:56 <agocorona> a TVar uses STM. acidState don´t
15:48:29 <agocorona> acidState is persistent, TVars don´t
15:49:59 <agocorona> mseeks what do you want  to do?
15:51:02 <mseeks> agocorona: I just want to persist some data structures that are accessed concurrently
15:51:28 <mseeks> I have no particular preference for STM outside of its atomicity which AcidState seems to provide
15:51:28 <enthropy> mpickering: transform :: GenericQ (Anns -> Anns)
15:51:31 <agocorona> where they persist?
15:52:07 <mseeks> agocorona: what do you mean?
15:52:16 <agocorona> in a database? in files?
15:52:26 <mseeks> doesn't really matter, just want to persist somehow
15:52:41 <mseeks> serializing to disk would have been fine too
15:52:45 <enthropy> you do need a rank 2 type, and those aliases in Data.Generics.Aliases make them relatively easy to write
15:54:26 <agocorona> I don´t know very well acid-state sorry. Probably it could do it
15:56:42 <agocorona> But it is not optimized for concurrency. basically the state block the whole data when one thread is accessing the state
15:57:24 <agocorona> if optimizing performance is not your concern, you can use it
15:58:18 <agocorona> STM is more optimal on that, and easier to program
15:59:04 <mseeks> doesn't STM block TVar access when one thread is accessing the TVar as well though?
15:59:21 <Shockk> I think acid-state does work well with concurrency
15:59:22 <agocorona> STM does not block
15:59:49 <mseeks> does it just retry?
16:00:04 <Shockk> it's a bit unclear but the website suggests that using from multiple threads only increases performance
16:00:13 <agocorona> yes. That is the reason why it is easy
16:02:20 <agocorona> Shockk:  I don´t know . I only have seen very simple examples with a single kind of data.
16:02:42 <mseeks> Shockk: how would using it from multiple threads increase performance?
16:03:01 <enthropy> acid-state depends on stm
16:03:08 <mpickering> enthropy: Thanks, that helped.. now I need to specify the type of `setCol f`, any ideas?
16:03:18 <agocorona> I think that  it block everithing when a thread access the state
16:03:21 <Hijiri> acid-state doesn't block for queries, at least
16:03:40 <agocorona> for updates, of course
16:03:47 <drewbert> noooo
16:03:50 <agocorona> I mean
16:03:54 <drewbert> I got disconnected.
16:03:55 <Hijiri> you can still do queries when an update is being one
16:04:01 <Hijiri> done
16:04:11 <Hijiri> I guess you can't do multiple updates at the same time
16:04:16 <Shockk> mseeks: idk, it just says that word-for-word on the website, but I've seen this on the hackage page for it:
16:04:17 <Shockk> "When using a local AcidState, an update event in one thread does not block query events taking place in other threads."
16:04:19 <xpilot> has anyone ever seen this cabal error message? cabal: InstallPlan: internal error: configured package depends on a non-library package
16:05:01 <Shockk> xpilot: I don't think cabal packages can depend on cabal packages that are only an executable
16:05:04 <Hijiri> xpilot: probably one of the listed dependencies isn't a library?
16:05:17 <Shockk> like, packages that depend on happy for example require the user to cabal install happy
16:05:39 <mseeks> Hijiri: what happens when you try to do multiple updates concurrently?
16:05:57 <agocorona> Shockk: right. but  only one thread can update the state at the same time. That is what I meant.  Queries does`nt have to block , of course.
16:06:21 <mseeks> hm I think this is a dealbreaker for AcidState: "If you have two acid-state resources, there is no way to update both of them atomically. "
16:06:24 <Shockk> oh, I thought you were referring to queries when you said accessing, sorry
16:06:32 <xpilot> Shockk: this happens when I try to cabal install accelerate-examples
16:07:13 <agocorona> mseeks:   that is the reason : you need to have all the register in a single acid-state resource  to have atomicity
16:07:32 <agocorona> so only one thread can update anything
16:08:00 <mseeks> agocorona: thanks, now it makes sense
16:08:12 <agocorona> all the registers in a single acid state resource
16:08:20 <mseeks> I forgot to consider composability of atomic transactions
16:08:46 <agocorona> with STM you can have an arbitrary number ot TVars that can be updated independently
16:09:02 <drewbert> why does cabal only look for a specific hash of a given package?  why can't it just use the other package with the same version?
16:09:02 <enthropy> mpickering: I think the second argument to everything should be transform, not setcol f
16:09:14 <mpickering> yes, that was a mistake in the original paste sorry
16:09:20 <agocorona> and DBRefs share the same semantics than TVars, but are persisntent
16:09:57 <Shockk> I also have sort of a weird question (entirely unrelated); I have a program that uses the ghc api to dynamically load haskell modules and retrieve one of their exposed names with an import decl and dynCompileExpr -- this increases my program's resident memory usage, of course, significantly;
16:10:14 <mpickering> The type error is now something like "  Could not deduce (SYB.Typeable a0) arising from a use of ‘SYB.mkQ’"
16:10:39 <Shockk> I wondered if there is any possible way (safe or unsafe) to 'unload' the ghc api code that's been linked in and is sitting in memory, after I know I no longer need it
16:10:53 <mseeks> agocorona: thanks, I'll take a look at those
16:10:54 <drewbert> chrisdone: could you run me through how the handle the situation i described earlier using nix?  the situation where I need to tweak an installed package and rebuild?
16:11:18 <drewbert> chrisdone: I dot disconnected, so I didn't see it if you responded earlier.
16:11:30 <xpilot> Shockk: I see now, accelerate-examples has only executables
16:11:46 <danilo2> Hello! I think I see a bug in Haskell's type inferencer. Namely - I've got function foo with an explicit signature. One element is a Maybe omething. And I've got a function bar, wrapping foo and providing Nothing as the argument. there are other functions using function bar, but type inferencer blows up when I do not provide explicit signature for bar, which is strange, isnt it ?
16:11:58 <zq> if i have an action :: IO [Int] and i would like to take the length of the list inside, is there any way around building up and storing the entire list?
16:12:12 <zipper> Which is the best way to allow only certain whitelisted email addresses to view certain routes in Yesod?
16:12:16 <zipper> My code is here: https://gist.github.com/urbanslug/5724a5be6d3bd7bc8263
16:12:30 <HeladoDeBrownie> danilo2, please show the code and error message
16:12:34 <zipper> Currently I am trying to print the email address of the currently logged in user so that I can at least see who is logged in but I am unable to pull this from the DB despite the yesod book said this info is tied into AuthID when using browserID aka mozilla persona.
16:12:56 <HeladoDeBrownie> danilo2, but there are some situations, not bugs, where providing an explicit type signature will change whether a program types
16:13:17 <enthropy> mpickering: I have a feeling you can only have concrete types with setCol  (like setCol :: (Int -> Int) -> GHC.Located Int -> Anns -> Anns)
16:13:36 <HeladoDeBrownie> or, more specifically, will change a program that doesn't type into one that does
16:13:42 <enthropy> @hackage syb-with-class
16:13:42 <lambdabot> http://hackage.haskell.org/package/syb-with-class
16:13:43 <zipper> None of the tutorials assume one is using the scaffolded site
16:13:58 <Shockk> because, well, without the ghc api stuff in my program, its total resident memory usage is around 10M; with it, it's 145M
16:14:33 <danilo2> HeladoDeBrownie: I know, I know, but not in this situation. The code is complex and I've got no minimal example, but I will show you (i think) ennough to judge, look: http://lpaste.net/120150 - If I do not provide explicit signature for genFuncNoBody the program does not compile, otherwise it does
16:15:32 <HeladoDeBrownie> danilo2, i can't make any useful judgments from that
16:16:08 <ph88> how can i uninstall a package installed with cabal ?
16:16:14 <danilo2> HeladoDeBrownie: Why not? Haskell is able to infer exactly this type signature out of the definition of  genFuncNoBody and the signatrue of genFunc isnt it?
16:16:35 <mpickering> enthropy: ok thanks
16:16:38 <drewbert> ph88: :-(
16:17:05 <enthropy> danilo2: you don't use RankN types here?
16:18:01 <drewbert> ph88: ghc-pkg unregister --force example-package-0.0.1
16:18:13 <ph88> eh o_O
16:18:22 <ph88> kind of a difficult command !
16:18:25 <danilo2> enthropy: nope
16:18:34 <ph88> what about cabal remove example-package-0.0.1  ??
16:19:14 <drewbert> ph88: see the discussion on http://stackoverflow.com/questions/10576868/how-can-i-uninstall-a-version-of-a-cabal-package
16:19:36 <ph88> ok TY TY
16:19:36 <drewbert> ph88: cabal-install is kind of a giant pile, though many people will disagree with me there
16:20:24 <ph88> oh that's funny cabal has a package to uninstall ^^
16:20:25 <glguy> force unregistering packages is a good way to pollute your package db with a bunch of broken packages
16:20:43 <rasen> What frp library I should choose for network application? (BitTorrent client if that matters)
16:20:48 <danilo2> enthropy, HeladoDeBrownie: I do not use RankNTypes and the only think to make the ocde compile is to provide this (commented out) type sinature by hand. Is there any possible reason for that or this is just a bug, that shoudl be reported in some nicer form ?
16:20:51 <glguy> and then you'll be coming back to #haskell Q_Q'ing your broken environment again and complaining about cabal
16:22:18 <HeladoDeBrownie> danilo2, i think you should go ahead and do what you would normally do for a bug report: come up with a minimal case and include code and error. your snippet above is missing too much information on the types and expressions involved.
16:22:42 <HeladoDeBrownie> danilo2, if necessary, just start cutting away code until you have something still erroring but which can't be cut down anymore.
16:23:31 <enthropy> danilo2: can you try with a different ghc?
16:23:43 <drewbert> glguy: What do you recommend?
16:23:44 <danilo2> HeladoDeBrownie: I will, but it will take time. Anyway I prefer just asking what could theoreticqlly cause such behaviour. You have told that a lot of elements are missing. Could you just imagine and tell me only one possible reason for that? Even the most crazy? I just cannot understand it and do not see anything that can cause it
16:23:53 <HeladoDeBrownie> it's possible i'm just not clever enough to notice the problem yet, but fortunately that problem can be solved by not requiring me to be clever
16:24:18 <HeladoDeBrownie> danilo2, well, the monomorphism restriction is one way. as someone suggested, rank n types are not in general inferrable. then there are also interactions with gadts related to that.
16:24:25 <glguy> drewbert: Unregistering the stuff that depends on the package you want to unregister so that you don't have anything depending on it after which you can unregister it without forcing
16:24:48 <glguy> drewbert: I got tired of doing that manually so I use this now: https://github.com/glguy/GhcPkgUtils
16:25:43 <HeladoDeBrownie> i'm not sure if there are any other ways, there could be. depends on what extensions you use and would be easier to do a search of the possibilities with some testable code.
16:25:54 <glguy> That tool helps finding outdated stuff, unregistering its, and detecting when you have more than one version of a package installed (which generally leads to eventual trouble)
16:26:29 <danilo2> enthropy: that would not be straightforward unfortunatelly :( I will try to make a minimal example out of it in the following days. But moving over other ghc would be hard for the entirle project because it depends on some ghc - estensions written by us. Not exactly this part of project, but still I've got to extract it, so it will take time
16:26:54 <danilo2> HeladoDeBrownie: Ok, I see - still this is so mysterious for me I would love to understand it. I will try to make minimal example
16:28:05 <sdegutis> A large aspect of what makes programming in Clojure enjoyable is that you work with collections using transformative functions, which is significantly more concise than the imperative, mutable counterpart. Is this largely the same experience when using Haskell?
16:28:36 <HeladoDeBrownie> sdegutis, i wouldn't call it a large aspect, but it's certainly a nice part of the language
16:28:44 <HeladoDeBrownie> some might call it a large aspect
16:29:39 <sdegutis> Another big portion of what makes programming in Clojure enjoyable is the removal of boilerplate by the use of destructuring into symbol bindings, which I already perceive is a large part of Haskell.
16:29:52 <Axman6> you just said that...
16:30:02 <darthdeus_> guys, if cabal fails to build a package with a missing C header file, how can I tell it where to look if I know the path?
16:30:05 <sdegutis> Axman6: No, that's a separate thing.
16:30:08 <zipper> Which is the best way to allow only admin (certain whitelisted) email addresses to view certain routes in Yesod?
16:30:08 <Axman6> oh no you didn't
16:30:56 <Axman6> darthdeus_: --extra-include-dirs and --extra-lib-dirs
16:31:01 <sdegutis> And another great fun thing about Clojure programming is that you just have functions and data, no other nonsense, which makes any kind of component similarly conceptually very simple. It seems this is partially true in Haskell as well.
16:31:18 <HeladoDeBrownie> what "other nonsense" might there be?
16:31:54 <HeladoDeBrownie> though haskell doesn't separate functions and data as much as many other languages do. functions and data are both representable as values.
16:32:15 <sdegutis> And finally, static type safety makes finding errors quicker and easier to fix, which is just a positive way of saying it is less unpleasant than other languages.
16:32:17 <sdegutis> So I'm trying to figure out, besides these things, what else makes writing Haskell enjoyable?
16:32:18 <darthdeus_> Axman6: unrecognized option --extra-include-dirs :\
16:32:35 <sdegutis> HeladoDeBrownie: sure, but I meant in the sense that you have data and operations
16:32:44 <HeladoDeBrownie> i like not having to hold much in my head at once, and what i do is mostly explicitly mentioned somewhere
16:33:12 <enthropy> danilo2: for example I recently ran into a case where ghc7.8 doesn't infer a type that 7.10RC1 does: https://github.com/aavogt/IsInstance/blob/master/test/test.hs#L32
16:33:16 <Axman6> darthdeus_: maybe without the s on the end. check cabal --help ;)
16:33:16 <HeladoDeBrownie> and even when it is explicitly mentioned, it can be hidden away if necessary
16:33:17 <platz> sdegutis: there are issues though with trying to understand how much of your 'graph' to pass into functions and where the true dependancies are
16:33:30 <sdegutis> I've personally found that operator precedence and associativity is difficult to get used to, at least at first (it still is for me, but I'm a beginner).
16:33:48 <darthdeus_> Axman6: no you're right, --extra-include-dirs is in the docs, but for some reason it doesn't work :\
16:33:51 <sdegutis> platz: that sounds like a general programming problem, not specific to Haskell, for I ask myself the same question in Clojure
16:33:52 <platz> they've had to somewhat refine the naive approach to this, see Stuart Sierra's talk on the challenges they faced wit that they're currently considering as a way to go forward... https://www.youtube.com/watch?v=13cmHf_kt-Q
16:34:08 <danilo2> enthropy: interesting. Thank you for the info. We are thinking about moving to 7.10, but slowly :)
16:35:04 <enthropy> danilo2: is your extension just the dysfunctional FDs?
16:36:01 <sdegutis> Any other thoughts anyone'd like'o sha'?
16:37:56 <tomphreek> is it possible to convert BinTree (IO Int) into IO (BinTree Int)
16:38:10 <sdegutis> Also, in idiomatic Clojure, you generally try to approach nearly all problems in terms of sequence processing. Is this similar in Haskell?
16:38:15 <shachaf> That depends on what BinTree is, but probably.
16:38:15 <Axman6> sounds like Traversable tomphreek
16:38:22 <Axman6> :t traverse
16:38:23 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:38:30 <tomphreek> thanks!
16:38:34 <Axman6> hmm, not traversable
16:38:37 <Axman6> maybe sequence
16:38:40 <Axman6> :t sequence
16:38:43 <lambdabot> Monad m => [m a] -> m [a]
16:38:49 <Axman6> :t sequenceA
16:38:50 <lambdabot>     Not in scope: ‘sequenceA’
16:38:50 <lambdabot>     Perhaps you meant one of these:
16:38:50 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
16:38:56 <Axman6> :t T.sequenceA
16:38:57 <shachaf> sequenceA is traverse id
16:38:58 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
16:39:08 <Axman6> ah right. not something I've used often
16:39:21 <danilo2> enthropy: Yes, I think this is the only "non-built-in" extension we are using here
16:39:56 <shachaf> Anyway, it still depends on what BinTree is.
16:40:17 <tomphreek> BinTree is an applicative functor if that helps
16:40:21 <enthropy> danilo2: are you looking to get it merged? It seems rather useful to me
16:42:30 <danilo2> enthropy: it is, it allows for one very interesting feature. Namely it allowed us to create type class instances, which result in polymorphic functions based on the type of passed argument. And it works like a dream for a long time now. The only problem is with my time - we are just before the firt release of the product and I'm almost not sleeping
16:43:32 <danilo2> enthropy: anyway -yes I'm looking for it - the only problem was - tht someone asked me to make regression tests. And if anyone could help me with them - just guide me - what tests to write and where put them, I will do it. Otherwise I will have to find a little time more during some weekend and look for it by myself
16:44:57 <enthropy> I think it's mostly "this file should compile" "this file should not"
16:46:02 <enthropy> danilo2: https://ghc.haskell.org/trac/ghc/wiki/Building/RunningTests/Adding
16:46:10 <tomphreek> I believe it's just sequence, I just need to make my binary tree traversable
16:46:49 <shachaf> Yes.
16:47:13 <shachaf> But "how do I write aa Traversable instance for my type" is approximately equivalent to your original question.
16:47:26 <Axman6> tomphreek: the implementation should generally be pretty mechanical
16:47:40 <shachaf> So if you had trouble with writing that function before, you don't solve much this way. :-)
16:47:46 <tomphreek> I haven't heard of traversable before, so I am off to read the docs
16:47:48 <shachaf> (It's true that GhC can autoderive Traversable instances, though.)
16:48:31 <shachaf> I wonder what happened with my shift key there.
16:48:34 <Profpatsch> Is there a way to derive Random automatically?
16:48:54 <lfairy> there's probably a Generic adapter somewhere
16:49:00 <jmcarthur> Profpatsch: that seems problematic for recursive structures and such
16:49:30 <jmcarthur> Profpatsch: s/problematic/arbitrary/
16:49:38 <Profpatsch> jmcarthur: I’ve got a data Color = RGBA Word8 Word8 Word8 Word8.
16:49:51 <jmcarthur> Profpatsch: yeah, that seems a bit more straightforward
16:50:18 <Profpatsch> And it’s kind of more verbose that I think it could be.
16:51:05 <mseeks> have you guys encountered a problem where you're in some app monad (say a Reader AppState monad) and you want to fork a thread which runs in the monad?
16:52:10 <geekosaur> ask and runReaderT?
16:53:46 <mseeks> yeah I guess
16:54:30 <hsk3> A lot of the Haskell report is really convoluted. Has someone written a Haskell Report + Friendly explanations?
16:54:56 <Profpatsch> It’s hard to work with functions that return tuples. Can I somehow use them directly w/o pattern matching?
16:55:07 <Cubicle> So, I've taken a quick look at ghc 7.10
16:55:12 <jmcarthur> Profpatsch: random g = let a:b:c:d:_ = unfoldr (Just . random) g in RGBA a b c d
16:55:18 <Cubicle> specifically, the prelude changes
16:55:46 <Cubicle> so, why is it ok to generalize foldl and foldr to the Foldable version, but not map to fmap?
16:55:47 <jmcarthur> Profpatsch: the functions in Control.Arrow and Data.Tuple are very helpful for dealing with tuples
16:55:57 <hhhasdau> http://lpaste.net/120151 <- couldnt there be a call to extract with the first parameters being larger than the length of the second?
16:56:09 <Profpatsch> jmcarthur: wow, unfoldr is a cool function.
16:56:16 <jmcarthur> Profpatsch: actually the only function in Data.Tuple you don't already have in scope is swap, i guess
16:56:30 <Profpatsch> Never thought there exists something like that.
16:57:10 <tomphreek> hard to tell whether I really need to bother making my tree tranversable. I am going to operate on my BinTree (IO a) (IO becase each node is a sample from a random varible). Operations include: Node-wise summing trees, scaling each node in a tree. I have pure functions which operate on (BinTree Int). I figured having IO (BinTree Int) allows me to: do t :: BinTree Int <- ... and then call my pure code. A
16:57:16 <tomphreek> m I on the right track, so confusing :(
16:57:22 <Axman6> hsk3: what do you find convoluted?
16:58:11 <geekosaur> hhhasdau, there could and it'll append a bunch of empty lists (which is a no-op, not an error)
16:58:15 <hsk3> Axman6: take chapter 3
16:58:16 <hsk3> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003
16:58:32 <hsk3> qvarid, conid, qconid
16:58:33 <hsk3> wtf?
16:58:50 <hsk3> hm
16:59:03 <hhhasdau> geekosaur: wouldnt it throw a 'non-exchaustive patterns' error if you try to match (x:xs) to []
16:59:07 <Axman6> the explanations directly after their definitions don't help?
16:59:11 <Cubicle> hsk3: Qualified
16:59:28 <hsk3> ok
16:59:30 <geekosaur> hm, looking again, yes
16:59:34 <Axman6> qcon→qconid | ( gconsym )    (qualified constructor)
17:00:15 <geekosaur> they did say it was naïve...
17:00:29 <hhhasdau> geekosaur: by naive they mean performance wise
17:00:38 <jmcarthur> Profpatsch: here's a way to make it easier:
17:00:43 <jmcarthur> data Color a = RGBA a a a a deriving (Show, Functor, Foldable, Traversable)
17:00:47 <jmcarthur> Profpatsch: and then...
17:01:01 <jmcarthur> Profpatsch: random = runState . traverse state $ RGBA random random random random
17:01:08 <darthdeus_> if I have package A depend on B, and I install B separately, is there a reason why installing A would try to install B again?
17:01:20 <geekosaur> in any case I don't think they intend extract to be exported; if shuffle will never pass a larger number to extract than the size of the list, which seems reasonably likely, then it's not an issue
17:01:27 <hsk3> Axman6: you're right...
17:01:33 <hsk3> I guess it just takes some patience to read this
17:01:43 <jmcarthur> Profpatsch: in fact, you could define an Applicative instance for Color, then it just becomes:
17:01:44 <hsk3> more patience than LYAH
17:01:56 <jmcarthur> Profpatsch: random = runState . traverse state $ pure random
17:02:03 <Axman6> hsk3: language definitions are rarely a pleasure to read if they're anything more complex than lisp
17:02:07 <hhhasdau> geekosaur: yeah, but I think it will pass such a value - if you remove one element from the list and then call extract with value (n- 1)
17:02:13 <hhhasdau> in shuffle
17:02:16 <Cubicle> jmcarthur: I don't know about making color traversable just for that situation - seems kinda frivolous to me
17:02:48 <hsk3> ok
17:02:50 <jmcarthur> Cubicle: i don't think it is. it also gives you polymorphism and makes reasoning about some things easier via parametricity
17:03:10 <shachaf> If you can make a Traversable instance for your type, it's not an unreasonable thing to do.
17:03:14 <jmcarthur> Cubicle: if the *only* reason was for this one function, i'd agree
17:03:20 <shachaf> It's a pretty good class.
17:03:58 <shachaf> It's true that there are 24 possible instances, but this is pretty obviously the right one. :-)
17:04:44 <hhhasdau> geekosaur: specifically i think 'shuffle ['a', 'b', 'c'] [1, 2, 0]' would break
17:04:52 <Cubicle> jmcarthur: I guess the thing that kind of bugs me about that is that it means you have to canonicalize colors then before they mean anything (i.e. what is a Color Float vs a Color Int?)
17:05:50 <shachaf> Oh, the original version of the code wasn't parameterized.
17:05:53 <shachaf> I missed that.
17:05:56 <geekosaur> i,i Color (Complex Float)
17:06:21 <shachaf> Making your type parameterized to make it Traversable is also often a reasonable thing to do, but it might not be appropriate in this case.
17:06:35 <jmcarthur> Cubicle: i'd consider turning it into  data V4 a = ...  and  newtype Color = Color (V4 ColorComponent)
17:06:36 <shachaf> lens has a bunch of functions to deal with things that are like Traversable except not parameterized.
17:06:43 <jmcarthur> i agree it's not always appropriate
17:07:05 <Cubicle> jmcarthur: Ok yeah I can see that
17:07:16 <hhhasdau> yeah geekosaur shuffle does break with those values
17:07:20 <danilo2> enthropy: ok, thank you for the link. I think its the time to do it. I will try to find time in this week
17:08:15 <jmcarthur> Profpatsch: it occurs to me that my unfoldr version is no good
17:08:31 <jmcarthur> Profpatsch: it doesn't return a new generator. it's just consumed for the infinite list
17:08:34 <Cubicle> wait
17:08:51 <mrb_bk> Anyone here ever mess with SBV and have an idea how to derive a Data instance for things? Weird combo, need a Data instance for SInteger
17:14:01 <jmcarthur> Cubicle: everybody is waiting
17:14:47 <Cubicle> jmcarthur: I'm sorry. I was gonna follow that up with 'what's DeriveAnyClass do?' but then I figured I might as well stare at the little information I could find before actually asking that.
17:15:29 <jmcarthur> Cubicle: i've never heard of DeriveAnyClass...
17:15:46 <Cubicle> jmcarthur: Apparently a GHC 7.10 extension
17:16:16 <jmcarthur> oh is it the generics thing?
17:16:25 <Cubicle> I think so
17:16:47 <jmcarthur> just a more convenient way to create instances using the default implementation using generics, i think
17:16:58 <shachaf> Seems like a fishy extension.
17:17:11 <jmcarthur> basically just syntax, is my guess
17:17:41 <jmcarthur> data Foo = ... deriving (Generic, MyClass)   ==>   data Foo = ... deriving (Generic); instance MyClass Foo
17:22:08 <mseeks> if I have a `TVar [Int]`, how do I atomically modify the TVar to remove a random element from the list?
17:23:09 <mseeks> is there a way to do it without unsafeIOToSTM to get a random index inside STM?
17:26:03 * hackagebot timeplot 1.0.28 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.28 (EugeneKirpichov)
17:26:55 <benzrf> you could do RandT STM or some crap
17:28:00 <Iceland_jack> mseeks: Simplest way is to pass the seed into the transaction
17:28:14 <Iceland_jack> Using a transformer won't suffice
17:29:08 <bitemyapp> Does something like https://agda.github.io/agda-stdlib/README.html exist for Haskell?
17:29:18 <bitemyapp> the clickable references to types in source code is really nice.
17:29:22 <mseeks> Iceland_jack: so use randomR and then just throw out the resulting RandomGen?
17:29:33 <fresheyeball> @pl (\a b -> Match (Sequence [a]) [b])
17:29:33 <lambdabot> (. return) . Match . Sequence . return
17:29:43 <jmcarthur> mseeks: pass the seed into the transaction, or store the seed in another TVar, or store the seed along with the [Int] in the same TVar
17:30:00 <Iceland_jack> mseeks: What you do with the resulting seed depends on what you're doing
17:30:07 <jmcarthur> mseeks: if you pass it in, you would have to take the resulting generator to use for next time
17:30:21 <jmcarthur> mseeks: if that's what you want, at least...
17:30:30 <mseeks> right
17:31:07 <mseeks> I could return it from the transaction alongside the removed element and do setStdGen
17:31:25 <jmcarthur> yeah, that's one place to put it
17:31:28 <Iceland_jack> mseeks: You can also generate a fresh seed or split your current one
17:31:52 <Iceland_jack> along with the usual considerations of splitting RNGs
17:32:21 <mseeks> should I prefer not splitting if it's not that much more difficult?
17:32:26 <fresheyeball> @pl (\rs (p:ps) (s:ss) -> go ( (rs ++ [buildMatch p s] )) ss ps)
17:32:28 <lambdabot> (`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .) . flip . ((flip . go) .)) .) . (. flip (flip . ((:) .) . buildMatch) []) . (.) . (++)
17:32:31 <Iceland_jack> Basically ye
17:32:32 <Iceland_jack> s
17:32:39 <mseeks> cool, thanks
17:32:43 <Iceland_jack> mseeks: If you're doing this often, create a 'TVar StdGen' or what ever generator you prefer
17:33:17 <Iceland_jack> Then you can readTVar it, do your random stuff and writeTVar the new generator back
17:33:19 <fresheyeball> sorry guys, local lambdabot is compiling
17:33:36 <Iceland_jack> Hope that helped
17:33:45 <HeladoDeBrownie> fresheyeball, lambabot is also available from pm. /query lambdabot
17:33:55 <mseeks> Iceland_jack: I only do it in one place
17:35:04 <shachaf> You don't need lambdabot for pointfree. It's its own package on Hackage.
17:35:25 <Iceland_jack> fresheyeball: You can PM lambdabot
17:39:09 <ab9rf> i'm giving up on sourcegraph for now.  eclipsefp doesn't absolutely require it and i've spent too much time on this problem.
17:41:57 <haasn> If we can't remove lambdabot from this channel, can we at least remove @pl?
17:46:04 <Adeon> is there something wrong with @pl
17:46:11 <Adeon> spamming?
17:47:01 <HeladoDeBrownie> that and the code it outputs is entirely too clever to actually use, i'd say
17:47:26 <geekosaur> sometimes clever, more often stupid...
17:48:10 <HeladoDeBrownie> when i say "clever" i mean that it takes a certain high amount of brainpower to understand, which is usually directly opposed to readability
17:49:30 <ttt_fff> anyone here find it'suseful to program _unplugged_ ? i.e. sketch things out on paper for 10-20 minutes before firing up an editor + ghc compile errors?
17:49:55 <HeladoDeBrownie> for me it's not unplugged per se but in a word processor
17:50:08 <HeladoDeBrownie> but rolling with the general sense of it, sure, i find that pretty useful
17:50:10 <ttt_fff> in a word processor?
17:50:13 <ttt_fff> not vim/emacs ?
17:50:20 <ttt_fff> heresy
17:50:26 <HeladoDeBrownie> nah, i like being able to visualize headings and other semantic styling
17:50:36 <HeladoDeBrownie> vim has markdown highlighting but sometimes that's too noisy
17:51:06 <ttt_fff> that's borderline silly
17:51:13 <HeladoDeBrownie> how so?
17:55:41 * HeladoDeBrownie hovers in a limbo of listening to suggestions and feeling insulted
17:59:23 <EvanR> ttt_fff: yes i use a lot of paper
17:59:56 <EvanR> theres still no good way to easily put down diagrams on the computer
18:00:13 <HeladoDeBrownie> EvanR, it's not great, but i sometimes use dia for that
18:00:22 <EvanR> ive used that
18:00:58 <EvanR> a few orders of magnitude slower for sketching though
18:01:54 <ab9rf> i often do roughing on paper before writing code
18:02:05 <evenex> i keep a pair of whiteboards on either side of my machine. its useful to make a design on one, annotate it till its almost unreadable, then make a clean updated copy on the other, and keep double-buffering like that until a sensible design emerges
18:02:22 <ab9rf> evenex: sounds like a good strategy
18:02:42 <ab9rf> evenex: encourages you to use the "it's not done until there's nothing else you can take away" strategy to design, too, i would htink
18:03:34 <evenex> ab9rf: that, and sometimes just redrawing with a different geometry helps spot abstractable patterns sometimes
18:04:19 <evenex> haha accidental double emphasis on sometimes
18:39:59 <awpr> hi -- is there a canonical package for length-{indexed,observed} lists / (Idris-style) Vects in Haskell?  Google turns up tons of examples but nothing I can just import.
18:43:33 <sternenseemann> awpr: https://www.haskell.org/tutorial/arrays.html
18:43:40 <sternenseemann> awpr: http://hackage.haskell.org/package/array
18:43:54 <sternenseemann> awpr: https://wiki.haskell.org/Arrays
18:46:06 <awpr> sternenseemann: those aren't what I'm looking for.  that's contiguous chunks of memory with no type-level length.  I'm looking for the equivalent of https://github.com/idris-lang/Idris-dev/blob/master/libs/base/Data/Vect.idr
18:46:43 <sternenseemann> awpr: I see
18:46:46 <Gurkenglas> Convince me that Data.List or some other standard library shouldn't implement (histogram :: Ord a => [a] -> [(a, Int)]) = M.toList . M.fromListWith (+) (or maybe instead using M.toAscList)
18:47:16 <Gurkenglas> * . map (,1)
18:47:28 <sternenseemann> I don't know wether it is possible to have type level length without dependend types
18:48:32 <scott> you can do it without dependent types but there are less things you can do with them
18:48:33 <HeladoDeBrownie> sternenseemann, you don't need full dependent types for certain applications of it, you just need types representing nats, which haskell can do. in other words, the thing requested does exist, the question is where best to get it
18:48:47 <awpr> sternenseemann: we have type-level data with the DataKinds extension, which is good enough -- Vec(t) is even one of the examples on the extension's documentation https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
18:48:57 <Gurkenglas> (Or tell me how you would rationalize that they don't)
18:49:58 <awpr> Gurkenglas: that would require List to import Map, or Map to have a function that's not really map-related, or a new module that basically only has that function.
18:51:34 <Gurkenglas> Hmk if that's bad. How inconvenient, this sort of cause of boiler plate code might arise in other places...
18:52:22 <geekosaur> Data.List already is the cause of many horrid dependency loops when building the base package
18:59:24 <Gurkenglas> What makes dependency loops horrid?
19:00:14 <Meleagant> hi
19:03:54 <srhb> Meleagant: Hi.
19:06:54 <ab9rf> haskell definitely needs a better packaging system.
19:09:01 <ab9rf> i say this after spending a full day struggling to find a combination of constraints that will lead to a successful build of SourceGraph, and eventually giving up
19:10:28 <_um> ab9rf: in my brief experience so far, there's pretty much a consensus agreement on that view.
19:11:18 <ab9rf> i can only assume that somewhere a group of eggheads are coming up with a theoretical model that will solve the problem, but it will be so complicated that nobody except them will understand it
19:12:04 <srhb> That's not a nice thing to say.
19:12:48 <_um> http://plv.mpi-sws.org/backpack/
19:13:20 <srhb> That's slightly orthogonal, but yes, it helps in some aspects.
19:13:21 <_um> Not to say that will be unintelligible...
19:13:27 <_um> Is it?
19:13:43 <_um> Oh yeah, it's not a package manager.
19:13:58 <_um> But it's aimed directly at the dependency issue, right?
19:14:23 <srhb> Oh don't get me wrong, having a proper module system would help a lot in actually making a package manager for Haskell
19:15:02 <_um> Or maybe—likely—I am just basically misinformed about the source of the trouble. That's likely. (what is the embarrassed face emoticon?)
19:15:05 <srhb> But said module system should also encompass type classes and instances.
19:15:16 <_um> Ah, I see.
19:15:42 <sdegutis> What makes Haskell particularly good at writing parsers?
19:15:42 <srhb> Anyway, this discussion has probably ran 100000 times in this channel, so I'll be silent on it now. :-)
19:15:53 <srhb> sdegutis: Composability, imo.
19:16:13 <ab9rf> srhb: no, it's not at all un-nice.  it's just saying that the problem is Hard.
19:16:27 <c74d3> ab9rf: Have you tried Nix?
19:16:54 <ab9rf> c74d3: not yet, but the problem i had is apparently not solved by nix, according to someone who was helping me with it last night :)
19:17:02 <c74d3> _um: " <_< " is a common one.
19:17:20 <srhb> I think the problem is that sourcegraph desperately needs an update. The easy solution is probably to cabal unpack it and fix it
19:17:31 <ab9rf> is there a standard definition for (<_<)? :)
19:17:32 <srhb> With fresh dependencies (ie. all versions bumped to newest stable)
19:17:51 <ab9rf> srhb: quite likely.
19:18:14 <ab9rf> hm, _ isn't allowed in an operator, is it?
19:18:15 <srhb> With a package no older than that, it's probably a matter of 30 minutes and following the error messages.
19:18:41 <ab9rf> srhb: i don't yet have enough cabal-fu to do that
19:19:12 <srhb> ab9rf: If you look in the cabal file, the matter of updating the dependencies should be fairly trivial.
19:19:23 <srhb> The rest is just cabal build and fix until it sticks. :-)
19:19:43 <ab9rf> srhb: i don't doubt that.  i'll put it on my "things to do" list at a low priority
19:19:57 <srhb> OK :)
19:19:59 <ab9rf> srhb: i have other projects that i am more interested in :)
19:20:09 <_um> (thanks, c74d3!)
19:22:01 <HeladoDeBrownie> ab9rf, it's presumptuous to label someone an egghead without their consent
19:22:35 <nshepperd> hmm, according to hackage, graphviz depends on graphviz
19:22:45 <nshepperd> how mysterious
19:26:09 * hackagebot dotenv 0.1.0.2 - Loads environment variables from dotenv files  http://hackage.haskell.org/package/dotenv-0.1.0.2 (jsl)
19:27:31 <ab9rf> HeladoDeBrownie: egghead is a term of endearment in this case, but if you insist on taking offense, i apologize.
19:28:33 <HeladoDeBrownie> ab9rf, i was explaining why what you said was not nice, regardless of your intentions. i was not asking for an insincere apology.
19:37:48 <srhb> How does one actually pass force to cabal sandbox hc-pkg unregister?
19:39:27 <dmwit> srhb: -- --whatever-argument-you-like
19:39:37 <srhb> dmwit: Ah, thanks.
19:40:42 <dmwit> nshepperd: The graphviz executable depends on the graphviz library.
19:42:09 <Scriptonaut> I'm learning about IO, could someone tell me why you can't: putStrLn "Hello, my name is " ++ (<- getLine)
19:42:25 <ab9rf> Scriptonaut: because you can't :)
19:42:34 <HeladoDeBrownie> Scriptonaut, because that's invalid syntax. <- means something specific within do expressions but not in general expressions.
19:42:54 <srhb> Scriptonaut: foo <- bar is only available as the (non-last) lines in do expressions
19:43:08 <Scriptonaut> hmm
19:43:19 <ab9rf> in do, <- is syntactic sugar for variable binding.  you're not binding anything there
19:43:31 <ab9rf> it might be nice if there was a shortcut syntax to do that, but there isn't
19:43:32 <Scriptonaut> ya, but wouldn't it curry it
19:43:32 <srhb> Scriptonaut: The equivalent that you want is getLine >>= \n -> putStrLn ("Hello, my name is " ++ n)
19:43:37 <srhb> No.
19:43:41 <Scriptonaut> lik you can do 1 (+3)
19:43:43 <HeladoDeBrownie> Scriptonaut, additionally, the precedence of juxtaposition is higher than infix application, so you need parens around the String expression being joined together.
19:43:49 <srhb> You can't do that either.
19:43:50 <ab9rf> it's not an operator, which is why you can't curry it
19:43:55 <srhb> Applying 1 to (+3) is a type error.
19:44:01 <ab9rf> and it would be (+3) 1
19:44:04 <ab9rf> not 1 (+3)
19:44:09 <Scriptonaut> sorry I meant (+3) 1
19:44:45 <ab9rf> the <- in do is not an operator, it's syntactic sugar.  it gets translated by the parser into something else entirely
19:45:00 <Scriptonaut> do you know what it gets translated to
19:45:09 <ab9rf> i can never remember, but someone else will be able to tell you
19:45:18 <HeladoDeBrownie> Scriptonaut, a full translation can be found here: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
19:45:19 <srhb> do { foo <- bar; ... } becomes bar >>= \foo -> ...
19:45:20 <dmwit> ?undo do { n <- getLine; putStrLn ("Hello, my name is " ++ n }
19:45:20 <lambdabot> <unknown>.hs: 1: 56:Parse error: }
19:45:27 <dmwit> ?undo do { n <- getLine; putStrLn ("Hello, my name is " ++ n) }
19:45:27 <lambdabot> getLine >>= \ n -> putStrLn ("Hello, my name is " ++ n)
19:46:00 <ab9rf> @unpl \ n -> putStrLn ("Hello, my name is " ++ n
19:46:01 <lambdabot> <unknown>.hs: 1: 43:Parse error: EOF
19:46:06 <ab9rf> @unpl \ n -> putStrLn ("Hello, my name is " ++ n)
19:46:06 <lambdabot> \ n -> putStrLn ("Hello, my name is " ++ n)
19:46:09 <ab9rf> bah
19:46:17 <ab9rf> @pl \ n -> putStrLn ("Hello, my name is " ++ n)
19:46:17 <lambdabot> putStrLn . ("Hello, my name is " ++)
19:46:21 <ab9rf> sorry
19:46:51 <HeladoDeBrownie> we don't really need a demonstration of pointless here
19:46:57 <ab9rf> so you could do getLIne >>= (putStrln . ("Hello, my name is " ++))
19:47:04 <ab9rf> but that's not very comprehensible.
19:47:05 <Scriptonaut> I haven't learned the >>= operator yet, I must not be at that point in the tutorial
19:47:26 <ab9rf> Scriptonaut: >>= is what <- uses
19:47:39 <Scriptonaut> ah, thanks
19:47:41 <srhb> And then we get: putStrLn . ("Hello, my name is " ++) <$> getLine
19:47:45 <HeladoDeBrownie> Scriptonaut, as a brief explanation, say you have getLine :: IO String. then getLine >>= \s -> ... will have s :: String, whatever the resulting String was.
19:48:14 <srhb> Wait, no we don't.
19:48:16 <srhb> :P
19:48:26 <HeladoDeBrownie> Scriptonaut, in other words, for IO, (>>=) lets you use the result of a computation in a larger one.
19:49:05 <HeladoDeBrownie> Scriptonaut, for now you can feel free to keep using do (and in fact you can almost always use do instead of (>>=)), but if interested you can play with (>>=) as well
19:49:09 <dmwit> (>>=) teaches a function that accepts pure values how to accept IO values, instead.
19:49:34 <Scriptonaut> ah, thanks
19:49:41 <Scriptonaut> I get it
19:51:26 <ab9rf> "("Hello my name is " ++) <$> getLine >>= putStrLn" has some appeal
19:51:52 <HeladoDeBrownie> sure, but that's another step beyond understanding how to use (>>=)
19:52:14 <srhb> =<< might be more natural in that case.
19:52:18 <ab9rf> i think most tutorials wait far too long in introducing <$>
19:52:20 <ab9rf> srhb: agreed
19:52:21 <Scriptonaut> ok, so if you do: foo <- some_io_action, foo will contain the result of the IO action?
19:52:34 <HeladoDeBrownie> Scriptonaut, basically
19:52:36 <Scriptonaut> which is a type?
19:52:39 <Scriptonaut> or a value
19:52:40 <ab9rf> no, it's a value
19:52:41 <HeladoDeBrownie> no, it's a value, which has a type
19:52:42 <Scriptonaut> ah
19:52:51 <Scriptonaut> it's hard to tell with (), since () is also a type right?
19:52:55 <HeladoDeBrownie> s :: String means "s is a value of type String"
19:52:58 <ab9rf> () is a type which is also a value
19:53:04 <srhb> in foo <- bar -- you can consider bar :: m a and foo :: a
19:53:05 <ab9rf> whjich is confusing
19:53:08 <HeladoDeBrownie> Scriptonaut, correct, () stands for both the unit type and its value
19:53:14 <srhb> In your case, bar is IO String and foo is String
19:53:18 <cmccann> no, () is a value whose type is also called ()
19:53:19 <dmwit> () is a type, and () is a value. Saying "() is a type which is also a value" doesn't strike me as precise.
19:53:47 <srhb> We could have called it () :: Unit instead
19:53:51 <cmccann> yeah, () and () are totally different things and this isn't confusing at all
19:53:55 <srhb> :D
19:54:03 <ab9rf> heh
19:54:12 <shachaf> [] and [] is more confusing
19:54:14 <cmccann> yes
19:54:15 <shachaf> Not to mention []
19:54:20 <cmccann> especially that one
19:54:26 <dmwit> :t let f(((()))) = [[[[]]]] in f
19:54:27 <srhb> Empty list, constructor, and...?
19:54:27 <lambdabot> () -> [[[[t]]]]
19:54:36 <shachaf> [] and [] are both types, actually.
19:54:37 <srhb> I don't get the third one
19:54:39 <shachaf> It's great.
19:54:39 <ab9rf> [] is a value of [a] for any a :)
19:54:39 <srhb> Oh
19:54:42 <srhb> Yeah ok
19:55:04 <srhb> This was a nice derailment. :-)
19:55:27 <shachaf> It's true both that (([] is a value of [a]) for any a) and that ([] is a value of ([a] for any a))
19:55:46 <srhb> Don't we have associativity rules?! :-)
19:55:47 <dmwit> How come the type does not mention all the units I mentioned in the pattern match. (((()))) -> [[[[t]]]] please
19:56:00 <srhb> dmwit: There's only one.
19:56:05 <srhb> (a) does not exist
19:56:05 <scott> the outer parens are just grouping
19:56:09 <cmccann> dmwit: must be a bug. better file a ticket.
19:56:10 <srhb> Since, unit.
19:56:16 <dmwit> i break GHC
19:56:25 <dmwit> master hacker
19:56:43 <srhb> Or I guess we can say one-tuple a is just a
19:56:43 <shachaf> dmwit: One-tuple support isn't implemented yet.
19:56:45 <srhb> :P
19:56:55 <cmccann> there's a one-tuple package, though.
19:56:56 <Hijiri> @let instance Num () where { (+) = const $ const (); (*) = (+); fromInteger = const (); abs = const (); signum = const () }
19:56:57 <lambdabot>  .L.hs:152:10: Warning:
19:56:57 <lambdabot>      No explicit implementation for
19:56:57 <lambdabot>        either ‘negate’ or ‘-’
19:56:59 <scott> and if you go python-style, (1,) is actually a function
19:57:10 <shachaf> dmwit: You'd think that it'd break a lot of programs, but it actually only breaks in that it makes some invalid programs compile.
19:57:12 <srhb> scott: -XTupleSections
19:57:16 <Hijiri> > 5 + 6 * 54 :: ()
19:57:17 <lambdabot>  No instance for (GHC.Num.Num ()) arising from a use of ‘GHC.Num.+’
19:57:46 <dmwit> shachaf: ?
19:57:55 <Hijiri> > 5 + 6 * 54 :: ()
19:57:57 <lambdabot>  ()
19:58:03 <ab9rf> shachaf: what is [] as a type?  that has me confused.
19:58:18 <dmwit> ab9rf: [] is a type of kind * -> *
19:58:29 <gcganley> :t []
19:58:30 <lambdabot> [t]
19:58:33 <ab9rf> dmwit: ghci told me as much, but that did not enlighten me
19:58:46 <shachaf> dmwit: Only nonsense. Imagining one-tuples in the language.
19:58:48 <dmwit> ab9rf: [a] and [] a are just different spellings of the same thing.
19:58:55 <gcganley> ab9rf: its a type construtor for type [a]
19:58:56 <shachaf> I guess it's not actually true, though, because of type class resolution.
19:59:02 <ab9rf> oh, it's a type constructor.  d'oh.
19:59:10 <srhb> ab9rf: It's a type that given a type argument a produces a concrete type [a] (if I remember the terminology correctly)
19:59:15 <gcganley> ab9rf: its all good baby
19:59:26 <ab9rf> i had forgotten about that usage, is all
19:59:29 <ab9rf> carry on :)
19:59:31 <Hijiri> does Core or STG have one tuples?
19:59:35 <shachaf> Anyway, [] is a type csontructor of kind * -> *. And '[] is a type-level empty list of kind [k]
19:59:36 <dmwit> shachaf: I would be shocked if making parentheses into the way of specifying one-tuple types did not break some programs. Does nobody ever write more parentheses than absolutely needed at the type level?
19:59:41 <Hijiri> oh, I guess Identity is a one tuple
19:59:57 <cmccann> Identity is probably a newtype, so no
19:59:57 <shachaf> dmwit: I mean, imagine that the Report specified one-tuples and GHC just neglected to implement them.
20:00:12 <cmccann> a proper 1-tuple would need to introduce an extra thunk, for symmetry
20:00:13 <dmwit> shachaf: ...oh
20:00:26 <dmwit> shachaf: I don't know how I was supposed to imagine that given the prompts from before. =P
20:00:49 <dmwit> ...but now that I have imagined it, I enjoyed myself.
20:00:59 <shachaf> dmwit: I was continuing your nonsense with some of my own. But not too successfully.
20:01:10 <srhb> I laughed out loud. This channel is sick in a very particular way. :-)
20:01:16 <cmccann> dmwit: it helps if you assume that everything shachaf says is true in some parallel universe almost but not exactly the same as ours
20:01:36 <gcganley> whats the difference between boxed and unboxed data-type?
20:01:49 <srhb> gcganley: Overhead. :)
20:01:53 <hhhasdau> what are curly braces in a pattern match - 'l@T{}' ?
20:01:53 <gcganley> s/data-type/data-types
20:01:54 <dmwit> gcganley: The difference is between storing a pointer to some data and storing the data itself.
20:02:04 <shachaf> The box.
20:02:06 <dmwit> Well, a thunk and the data itself, I guess.
20:02:23 <dmwit> hhhasdau: record syntax
20:02:35 <gcganley> dmwit: wait. so you could say that a c-array is an unboxed array?
20:02:38 <dmwit> hhhasdau: which, amusingly, is allowed even for constructors that are not records
20:02:50 <ab9rf> what's a c-array?
20:02:51 <gcganley> dmwit: because all you do is pass around a ref
20:02:52 <dmwit> gcganley: Yes, C arrays are unboxed mutable arrays.
20:02:59 <hhhasdau> dwmit whats the point if the curly braces are empty?
20:03:07 <gcganley> ab9rf: an array in C, nothing fancy lol
20:03:17 <geekosaur> hhhasdau, as a hack if all you care about is the constructor you can use {} with any ADT, not just those defined as records
20:03:34 <gcganley> dmwit: is something like String in C# boxed or unboxed?
20:03:36 <shachaf> If you search on the Google you can find useful documentation: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/primitives.html
20:03:37 <dmwit> hhhasdau: The pattern "T{}" matches any data constructed with "T", and continues to work even when changes to the number of fields in the "T" constructor are made.
20:03:45 <gcganley> s/String/System.String
20:03:45 <geekosaur> in this case the whole ADT is being captured as l, but it needs to be the T constructor
20:03:49 <hooligan> ?
20:03:57 <dmwit> gcganley: I don't know C#.
20:04:04 <srhb> hhhasdau: Compare with T _
20:04:05 <hhhasdau> geekosaur, dmwit:  cant you just do l@T then?
20:04:07 <geekosaur> for the constructor match all we need is the constructor itself, don't care about the rest of the type, so T {}
20:04:09 <geekosaur> no
20:04:10 <cmccann> gcganley: in C#, String is a reference type, so equivalent to a boxed type
20:04:21 <geekosaur> it would have to be l@(T _ _) or whatever
20:04:24 <ab9rf> C# is redmond-flavored java.
20:04:27 <dmwit> hhhasdau: Not unless the "T" constructor has no fields. You would need like "T _ _ _", with the right number of underscores.
20:04:31 <geekosaur> as many underscores as ignored fields
20:04:34 <hhhasdau> okay I see
20:04:44 <gcganley> cmccann: i thought ref types were unboxed... now im confused
20:04:53 <cmccann> gcganley: reference types vs. value types in C# is a very similar idea, except that C# does automatic boxing/unboxing for you
20:05:04 <cmccann> gcganley: other way around
20:05:04 <gcganley> ab9rf: i've written in both java and C# and i MUCH prefer C#
20:05:59 <Scriptonaut> bleh, I'm having trouble with precedence here. Why doesn't this work: map reverse . words "hello"
20:06:00 <cmccann> gcganley: note that C# even uses the "box" terminology: https://msdn.microsoft.com/en-us/library/yz2be5wk.aspx
20:06:17 <srhb> Scriptonaut: because words "hello" is not a function
20:06:19 <geekosaur> Scriptonaut, (.) combines functions (a -> b)
20:06:25 <srhb> Scriptonaut: (map reverse . words) "hello"
20:06:32 <geekosaur> `wordss "hello"` is not a (a -> b), it's an (a)
20:06:39 <cmccann> gcganley: the main difference here in Haskell land is that a "box" can also be a thunk, i.e. something that hasn't been evaluated yet
20:06:40 <Scriptonaut> oh
20:06:48 <srhb> Scriptonaut: Or map reverse . words $ "hello"
20:07:08 <Scriptonaut> I thought precedence went from left to right automatically for composition
20:07:19 <srhb> Scriptonaut: Function application always binds tightest, rule of thumb.
20:07:29 <dmwit> Record syntax is tightest, then function application.
20:07:44 <srhb> gee. :-)
20:07:49 <dmwit> (Language lawyers, yay!)
20:07:50 <Scriptonaut> I thought: map reverse  words "blah" == (((map reverse) words) "hello")
20:08:01 <cmccann> @quote Int.->
20:08:01 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
20:08:04 <dmwit> Scriptonaut: correct
20:08:07 <cmccann> ^ haskell syntax is great
20:09:02 <dmwit> Scriptonaut: ...though I don't really see how that's relevant to your question. =)
20:09:26 <hhhasdau> can Data.Vector be implemented in regular haskell with the same running complexity or does it use some special non-haskell code to work with arrays?
20:09:27 <Scriptonaut> sorry. Why doesn't this work: (map (reverse . words)) "hello"
20:09:28 <srhb> Scriptonaut: What you wanted was map reverse (words "hello) not the other way around
20:09:39 <dmwit> > (map (reverse . words)) "hello"
20:09:41 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
20:09:41 <lambdabot>  Expected type: [GHC.Base.String]
20:09:41 <lambdabot>    Actual type: [GHC.Types.Char]
20:09:45 <srhb> because "hello" is not a list of lists.
20:09:48 <ab9rf> :t reverse. words
20:09:49 <lambdabot> String -> [String]
20:10:30 <dmwit> Scriptonaut: Because you are asking to call (reverse . words) on each element of "hello". But the elements of "hello" are characters, not strings, so "words" doesn't know what to do.
20:11:20 <Scriptonaut> oh, so map (reverse . words) "hello" is causing an error because map is like, "Hey, my function needs a list of lists, not a list of chars"
20:11:23 <dmwit> Perhaps I should use markdown syntax instead of this weird mix of () and "" to demarcate code from English.
20:11:30 <srhb> Scriptonaut: Yes.
20:11:39 <Scriptonaut> ah, ok thatnks that clears it up
20:11:52 <srhb> > map (reverse . words) ["foo bar", "baz"]
20:11:53 <lambdabot>  [["bar","foo"],["baz"]]
20:11:59 <shachaf> dmwit: You could use «fancy quotes».
20:12:04 <dmwit> > map reverse . words $ "hello"
20:12:05 <lambdabot>  ["olleh"]
20:12:12 <nitrix> Hi, I'm looking for a term but I forgot the word. It's a property that both head and tail share, that explains that they cannot work on an empty array.
20:12:18 <dmwit> partial
20:12:19 <ab9rf> nitrix: partial
20:12:27 <dmwit> antonym: total
20:12:33 <ab9rf> who's antonym?
20:12:36 <srhb> :P
20:12:44 <dmwit> ;-)
20:12:54 <nitrix> Also, is there a type safe alternative? Would it require the length of the list to be encoded into the type?
20:13:04 <nitrix> Some [Char:42] or something?
20:13:04 <dmwit> ?hackage safe
20:13:05 <lambdabot> http://hackage.haskell.org/package/safe
20:13:07 <ab9rf> nitrix: that is one approach
20:13:08 <srhb> nitrix: safeHead :: [a] -> Maybe a
20:13:18 <ab9rf> nitrix: another is what srhb just beat me to
20:13:26 <dmwit> dmwit beat you both
20:13:38 <ab9rf> yeah, but i ignore you :)
20:13:41 <srhb> ah, but indirection counts as... browser load time.
20:13:45 <nitrix> Any reason why Haskell still has the "non-safe" versions/
20:13:50 <dmwit> hysterical raisins
20:13:53 <ab9rf> nitrix: insane dried fruit
20:13:58 <init> sometimes that is what you want, too
20:14:07 <init> @type map head . group
20:14:08 <lambdabot> Eq b => [b] -> [b]
20:14:20 <srhb> If you can prove (sadly, not by type, easily) that head will never fail, it's convenient.
20:14:34 <srhb> Of course NonEmptyList is a better fit for that.
20:14:39 <cmccann> init: yeah, I'd expect someone named "init" to say that >_>
20:14:45 <cmccann> > init []
20:14:47 <lambdabot>  *Exception: Prelude.init: empty list
20:15:09 <init> cmccann: :D
20:15:24 <srhb> > inits []
20:15:25 <lambdabot>  [[]]
20:15:31 <srhb> add an s and you're safe.
20:15:53 <ab9rf> that wasn't something they taught in grade school about adding 's'
20:16:18 <dmwit> Quick, name a function other than group that could have NonEmptyList in its return type!
20:16:33 <srhb> uuh...
20:16:42 <cmccann> dmwit: replicate
20:16:49 <dmwit> > replicate 0 3
20:16:51 <lambdabot>  []
20:16:53 <ab9rf> haha
20:16:54 <dmwit> bzzzzt
20:17:04 <benzrf> > replicate -1 3
20:17:05 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> GHC.Types.Int -> a -> [a]))
20:17:05 <lambdabot>    arising from the ambiguity check for ‘e_113’
20:17:05 <lambdabot>  from the context (GHC.Num.Num (GHC.Types.Int -> a -> [a]),
20:17:06 <benzrf> > replicate (-1) 3
20:17:08 <lambdabot>  []
20:17:09 <nitrix> Last question, not flaming and the reason doesn't matter to me, but is there a language that you used before and you'd like more than Haskell?
20:17:10 <srhb> repeat!
20:17:11 <ab9rf> cycle doesn't work either
20:17:24 <srhb> nitrix: Nope.
20:17:32 <cmccann> oh yeah, I was thinking of repeat
20:17:39 <cmccann> why did I say replicate instead dur
20:17:49 <dmwit> Combining head and repeat seems a bit silly.
20:18:00 <dmwit> Though it is true that is an answer to the question as asked.
20:18:18 <cmccann> there's also iterate!
20:18:23 <ab9rf> @check \a -> head (repeat a) == a
20:18:24 <cmccann> totally useful there too.
20:18:24 <lambdabot>  +++ OK, passed 100 tests.
20:18:43 <srhb> safeHead fallback xs = head (xs ++ repeat fallback) -- obviously.
20:18:54 <nitrix> I tried other functional languages and they all seem to mimick Haskell features or trying but not quite there. I like minimalism and a very pedantic person, so, there are things with haskell that certainly bothers me, but I haven't found anything so far.
20:18:56 * srhb imagines volomunous puking all around the world now
20:19:06 <nitrix> I thought there'd be names popping up.
20:19:16 <ab9rf> nitrix: there are languages that are "more functional" than haskell but people usually don't discover them until they've already found haskell
20:19:31 <srhb> Yeah, Idris, Agda, ... would all be contenders I imagine.
20:19:39 <cmccann> nitrix: keep in mind that most people are in this channel precisely because haskell is the language they like most
20:19:40 <ab9rf> idris, agda, coq
20:19:41 <srhb> Where Haskell programmers go when they become truly insane. :-)
20:20:03 <nitrix> So that's what is waiting for me :P
20:20:05 <ab9rf> i actually heard of coq before haskell, but i didn't understand coq when i first discovered it and just ignored it
20:20:29 <srhb> nitrix: "But I want my function to only work on POSITIVE integers, in a type safe way!" <-- that road leads to dependent FP. :P
20:20:44 <ab9rf> and then you get into heated arguments over dependent types.
20:20:48 <nitrix> I have a friend working on a language and he keeps trying to avoid dependent types in his design.
20:20:53 <ab9rf> which i don't understand, so i just ignore them
20:20:56 <benzrf> nitrix: why?
20:21:10 <ab9rf> all i know is that some people have strong opinions about dependent types
20:21:10 <EvanR> dependent types would be a cool addition
20:21:28 <nitrix> No idea, I was kind of looking for answers. What's are the pros and cons?
20:21:35 <dmwit> srhb: And then you go, "How do I sell dependent types to other programmers?" and the best you can come up with is, like, "What if you wanted strings at the prime positions in your list and integers everywhere else and you wanted the compiler to check that for you...?".
20:21:39 <ab9rf> and i'm sure they ahve good reasons for having those opinions, and someday i'll care enough to actually understand those opinions :)
20:21:48 <srhb> dmwit: Yes, what if!!!
20:21:51 <srhb> :-)
20:21:58 <shachaf> dmwit: You don't need dependent types for that.
20:22:12 <dmwit> shachaf: Nope. YOu could add it as a primitive type, for example.
20:22:23 <shachaf> You could do it in GHC.
20:22:30 <dmwit> I know. And there's a blog post about how to do it.
20:23:05 <EvanR> seems like dependent types would simplify a lot of the shenanigans in type level haskell
20:23:10 <shachaf> Where?
20:23:10 <srhb> nitrix: I think the short story is: Pros: You get a stronger type system, able to express MUCH more. Cons: You lose a lot, including some type inference
20:23:29 <srhb> Perhaps only that(?)
20:23:30 <dmwit> https://cdsmith.wordpress.com/2010/03/15/type-level-programming-example/
20:23:32 <nitrix> How does haskell's forall works?
20:23:45 <srhb> nitrix: Depends on the extension
20:23:53 <srhb> It's very overloaded.
20:24:00 <nitrix> Ah :/
20:24:05 <shachaf> I wouldn't say "overloaded".
20:24:11 <srhb> shachaf: Okay?
20:24:22 <dmwit> shachaf: Okay, the type hacked together there is slightly different than what I remembered.
20:24:23 <shachaf> It has one meaning, pretty much, but different extensions let you use it in different places.
20:24:29 <dmwit> shachaf: And equally silly. =)
20:24:36 <srhb> Hmm, what about scopedtypevariables
20:24:49 <srhb> Isn't that quite different from other use cases?
20:24:54 <dmwit> That and the one that lets you put it in front of data constructors.
20:25:11 <shachaf> Sure, but the forall doesn't mean something else there.
20:25:16 <shachaf> It's just being more explicit about your scoping.
20:25:22 <shachaf> dmwit: That's also the usual meaning of forall.
20:25:28 <dmwit> uh
20:25:30 <EvanR> the question was about how forall works, rather than the meaning of it
20:25:35 <cmccann> srhb: it still means the same thing in that case. it just happens that adding a (redundant) forall to a universally quantified type makes the variables magically be in scope elsewhere
20:25:38 <shachaf> You're talking about ExistentialQuantification?
20:25:57 <dmwit> No, it's not the usual meaning of forall. The usual meaning of forall is to bind a type variable in a type. In front of a type variable, it is binding a type variable, but then the thing you get afterwards is not a type.
20:26:14 <dmwit> s/In front of a type variable/In front of a data constructor/
20:26:51 <shachaf> If you say data T = A Int, that means that if x :: Int, then A x :: T. If you say data T = forall a. A a, that means that for all a, if x :: a, then A x :: T
20:27:01 <dmwit> I'm skeptical of your classification of "means the same thing" when talking about STV, too.
20:27:05 <shachaf> Would you also say that => is different in front of data constructors?
20:27:17 <dmwit> If it causes things to behave differently than without that extension, it doesn't "mean the same thing"!
20:27:24 <shachaf> ScopedTypeVariables is probably the best argument you can make.
20:27:32 <srhb> nitrix: OK, so it's not overloaded, but see above discussion ^^^ :-)
20:27:35 <shachaf> But it still means binding universally in the usual sense.
20:27:45 <shachaf> It's just that ScopedTypeVariables only works with things you bind explicitly.
20:27:46 <cmccann> dmwit: I prefer to blame that one on bizarre scoping rules. the forall is innocent.
20:27:51 <srhb> nitrix: The GHC manual will tell you what it does with which extensions.
20:28:01 <cmccann> dmwit: they could have picked any other innocuous but optional bit of syntax to make that magically work
20:28:05 <srhb> (Which is all the same, in different places)
20:28:20 <shachaf> i,i (a ~ a) => ... to turn on ScopedTypeVariables
20:28:22 <dmwit> cmccann: I'm well aware. But they didn't.
20:28:27 <shachaf> whoa, you could have a class for it. Scoped a => ...
20:28:36 <shachaf> That would be a great abuse of something.
20:28:53 <cmccann> shachaf: arguably less abusive than the current behavior
20:29:00 * cmccann really doesn't like how ScopedTypeVariables works
20:29:03 <dmwit> shachaf: I would indeed say that => in front of data constructors is different than => in the usual places.
20:29:25 <shachaf> dmwit: OK. At least it's very closely related, then.
20:29:27 <dmwit> It's a different syntactic class, FFS!
20:29:43 <shachaf> It's different syntactically but the meaning is very similar.
20:30:12 <gcganley> I remeber seeing an article saying that lens was unidiomatic haskell. does that mean i shouldnt learn it or does that mean it wasnt 'haskelly' enought for him/her
20:30:20 <srhb> nitrix: For instance, with ScopedTypeVariables, it allows you to refer back to a type variable in a signature foo :: forall a. a -> ... in the body of foo. Normally, saying bar :: a would implicitly mean forall a. a --again! But with scopedtypevariables you are referring to the a already in scope
20:30:21 <dmwit> The names for both kinds of forall are inspired by the mathematical meaning of forall.
20:30:56 <dmwit> gcganley: opinions, assholes, etc.
20:31:30 <shachaf> Note that even if you don't use forall in your program, ScopedTypeVariables can change its meaning.
20:31:48 <dmwit> yep
20:31:54 <srhb> gcganley: If you haven't gone "aaargh, nested records!" or something similar that lens solves, you don't _need_ to learn it, obviously.
20:32:06 <gcganley> dmwit: im using really janky record syntax isomorphisms and i want to use lens i just cant wrap my head around the types.
20:32:09 <shachaf> lens isn't really primarily about nested records.
20:32:18 <srhb> No, but it's a problem that it solves.
20:32:21 <srhb> Quite nicely, too.
20:32:26 <shachaf> That's a big part of what lenses are about, but lens is about a lot more than lenses.
20:32:27 <gcganley> srhb: many tmies have i made that sentiment
20:32:33 <cmccann> lens is about making your code so clever you need shachaf to explain it to you after you write it
20:33:15 <gcganley> cmccann: or you could ask edward, you know, the guy that wrote the damn thing lol
20:33:26 <shachaf> dmwit: You're OK with forall in GADT syntax, at least, I hope.
20:33:45 <cmccann> gcganley: no, that would distract him from working on his libraries. shachaf doesn't really have anything better to do.
20:33:47 <srhb> shachaf: That's probably the most unambiguous place for it.
20:34:06 <shachaf> gcganley: I wrote a big part of lens.
20:34:26 <gcganley> shachaf: oh... is stand corrected. Good for you
20:34:28 <gcganley> !
20:34:56 <gcganley> cmccann: idk edward has answered some of my really dumb questions. like what a monad is
20:35:16 <dmwit> shachaf: I'm OK with it everywhere. Sometimes I wear foralls in my hair!
20:35:16 <gcganley> cmccann: keep in mind this is when i first started haskell and had no idea who edward was
20:35:43 <cmccann> gcganley: yeah, he enjoys explaining things to anyone who'll listen, it's true :P
20:35:51 <dmwit> So... what's a monad?
20:35:56 <srhb> Don't...!
20:36:01 <gcganley> NO!
20:36:37 <shachaf> A monad is a free monad monad monad algebra.
20:36:45 <srhb> That's a new one. :P
20:36:49 <cmccann> @quote endospacesuit
20:36:49 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
20:37:07 <gcganley> shachaf: if there is a bug in a forall could you say its having an exsitential crisis?
20:37:23 <Buttons840> I can't get the OpenGL package to install into a cabal sandbox -- any suggestions on where to start debugging this from?
20:37:34 <dmwit> ?paste the error
20:37:35 <lambdabot> Haskell pastebin: http://lpaste.net/
20:37:35 <srhb> Buttons840: With logs, on lpaste, then here. :)
20:37:36 <shachaf> gcganley: forall is a universal quantifier, not existential.
20:37:50 <EvanR> Buttons840: i suggest using a different library, gl
20:37:53 <dmwit> shachaf: You're the one going on about foralls in GADTs. ;-)
20:38:01 <gcganley> shachaf: well i've been grossly missinformed...
20:38:06 <shachaf> dmwit: forall is a universal quantifier in GADTs too.
20:38:26 <Buttons840> EvanR: I'm trying to install gloss, and OpenGL is a dep
20:38:26 <shachaf> (You know that but I'm just clarifying things for gcganley.)
20:38:32 <EvanR> ok
20:38:41 <EvanR> paste the error
20:38:53 <shachaf> It's such a bizarre misconception. Everyone seems to develop it independently.
20:38:56 <cmccann> forall is only existential if you're approaching it with a negative attitude
20:39:01 <Buttons840> srhb: where are the cabal logs, all I have is "X failed, the exception was: ExitFailure 1"
20:39:15 <dmwit> Buttons840: Look higher.
20:39:27 <srhb> Buttons840: Tell it to log explicitly to a file, if you don't see it
20:39:28 <shachaf> Maybe one of those Haskell books I never read has a secret chapter where it just hammers it in.
20:39:31 <Buttons840> dmwit: like, try praying?
20:39:39 <dmwit> Buttons840: No, I mean like, read earlier in cabal's output.
20:39:40 <Buttons840> ;)
20:39:58 <Buttons840> "look higher, pray to the cabal gods"
20:40:02 <dmwit> It's not really cabal's fault, sort of, but the placement of the true error message is obnoxiously related to the end report.
20:40:11 <gcganley> shachaf: then why if i google 'exsitential type haskell' it brings up the 'forall' keyword?
20:40:14 <cmccann> shachaf: is that the same chapter that explains how to spam dozens of lines fiddling with lambdabot in-channel?
20:40:24 <srhb> Well doesn't it actually suppress previous errors if you're building with more than one job?
20:41:02 <dmwit> Oh, yeah, if you're building with -j or something things might be different, too.
20:41:14 <shachaf> gcganley: Because existentials are related to universals, and in GHC you use forall (in a universal position) to make an existential type.
20:41:16 <gcganley> could i just tag all my posts with 'i make spelling mistakes and im very much sorry'
20:41:18 <shachaf> But it's still a universal quantifier.
20:42:02 <Buttons840> http://lpaste.net/120153  looks like a compile error
20:42:07 <srhb> So E is a universal quantifier, and forall is too?
20:42:32 <shachaf> E? You mean ∃?
20:42:47 <srhb> shachaf: Yes, sorry.
20:42:55 <srhb> "There exists" vs "for all"
20:43:00 <shachaf> ∃ (exists) is an existential quantifier. ∀ (forall) is a universal quantifier.
20:43:12 <srhb> Right... That's what I used to think, but now I'm confued.
20:43:14 <gcganley> shachaf: so is there an overlap between existential types and universal qualifiers or is an existential type ∈ unversial qualifiers or vis-versa
20:43:14 <srhb> confused*
20:43:19 <gcganley> im really confiused
20:43:38 <EvanR> very confucius
20:43:44 <cmccann> gcganley: it's the same as the relationship between logical and/or
20:43:44 <Buttons840> perhaps I have an incompatible version of OpenGL on my system?
20:43:48 <gcganley> i need to go learn math before i start making bold statements and dumb questions
20:43:49 <shachaf> There isn't an overlap, there's a duality. It's a good topic to take the time to figure out.
20:43:58 <srhb> Buttons840: No, I think you need a newer version of OpenGL
20:44:05 <srhb> Buttons840: Looks like some dependency has changed types.
20:44:30 <shachaf> You might be familiar with this in (classical) logic: "for all X, P(X)" is the same as "it's not true that there exists an X such that not P(X)"
20:44:53 <shachaf> And: "there exists an X such that P(X)" is the same as "it's not true that for all X, not P(X)"
20:44:54 <srhb> Yes.
20:45:03 <srhb> Of course.
20:45:10 <shachaf> It's not quite the same situation in Haskell but it's close.
20:45:15 <dmwit> Now imagine how you would implement "not" if "not" didn't exist.
20:45:15 <Buttons840> srhb: do you know what version of OpenGL is supported by the package?
20:45:17 <shachaf> That's the sort of relationship I'm talking about.
20:45:40 <cmccann> see also: de morgan's laws
20:45:44 <srhb> Buttons840: Hm, yes, it seems the problem might be that gloss doesn't work (or at least does not allow) a newer version
20:46:25 <gcganley> \u8717
20:46:42 <Buttons840> srhb: so gloss is broken?
20:46:48 <shachaf> Only 3/4 of De Morgan's laws work in Haskell anyway.
20:46:58 <dmwit> srhb: e.g. Haskell's type system looks a bit like a logic that has true (named ()), false (named Void), and (named (,)), or (named Either), and implies (named (->)). How would you implement not in that system?
20:46:58 <gcganley> shachaf: you make my brain hurt, thank you
20:47:20 <Buttons840> srhb: you guess that I my version of OpenGL is too old, or too new?
20:47:28 <shachaf> gcganley: Which part is the problem?
20:48:02 <Buttons840> from my system: "OpenGL version string: 3.0 Mesa 10.1.3"
20:48:55 <gcganley> shachaf: just the fact that i thought 'forall' == exsitential qualification and i guess im wrong so im going to go read some more about cat/type theory as penance for my ignorance
20:49:33 <shachaf> I don't think reading category theory will help much (unless you're picky about what is meant by "duality").
20:49:50 <cmccann> gcganley: you'd be better off reading up on formal logic if you want to figure out the quantifier stuff
20:50:19 <ab9rf> dmwit: that's not nice, i have a headache now
20:50:26 <shachaf> If you really like the idea of forall = existential quantification, you'd be better off reading up on informal logic.
20:50:27 <gcganley> shachaf, cmccann: any suggestions for someone that has 0 formal training in logic?
20:50:29 <cmccann> ab9rf: that's how you know it's working
20:50:30 <srhb> dmwit: Not sure I'm getting it. It's something with implies, but urgh?
20:50:48 <dmwit> srhb: Yep, it uses implies. And it's tricky!
20:50:55 <srhb> Hmm.
20:51:00 <dmwit> But also short.
20:51:02 <srhb> No spoilers!
20:51:23 <ab9rf> no spillage!
20:52:03 <dmwit> I only spoil people who give enthusiastic consent.
20:52:21 <cmccann> gcganley: sometimes the wikipedia articles for this kinda stuff are decent as a starting point
20:53:07 <ab9rf> wikipoopiea
20:53:15 <cmccann> gcganley: you could also look on Stack Overflow for people asking about quantifiers in Haskell, some of the answers include overviews of the related logic and/or links to useful stuff
20:53:19 <ab9rf> sorry, i'm tired
20:53:48 <ab9rf> i find wikipedia articles on technical topics to be little better than word salad much of the time
20:54:27 <gcganley> cmccann: i usually throw my self into a textbook and see if i sink or swim
20:54:29 <ab9rf> they're typically written by students in the topic in quesiton and often reflect an extremely superficial, if not actually wrong, understanding of the topic.
20:54:39 <cmccann> ab9rf: for the very broad, general subjects they can be fine sometimes. anything narrower and it becomes "this makes sense if you already know what it says"
20:54:53 <shachaf> I think one reasonable approach to teaching Haskell uses explicit forall from the beginning so that it's less of a mystery.
20:54:55 <ab9rf> cmccann: that's also a problem yes
20:54:57 <srhb> () -> Void?
20:55:01 <srhb> Hmm
20:55:10 <cmccann> srhb: that's "true implies false"
20:55:13 <cmccann> sounds fishy to me :P
20:55:15 <ab9rf> cmccann: they do badly on broad topics for an entirely different reason :)
20:55:15 <srhb> Yes.
20:55:30 <dmwit> srhb: Do you want a hint? It's very gentle.
20:55:35 <srhb> dmwit: Yes please
20:55:38 <srhb> I'm running in circles.
20:55:43 <dmwit> srhb: I observe that "true implies false" is "false", which happens to be "not true".
20:55:57 <shachaf> that hint is gentle like the gentle introduction is gentle
20:56:17 <srhb> shachaf: I think what you're saying is that I'm stupid. :-)
20:56:27 <cmccann> ab9rf: one thing wikipedia is definitely good for is keyword mining. if you look at a badly written article on the subject you want to know more about, find the words you don't recognize, and google for them you usually find something helpful
20:56:28 <dmwit> Hm. I suppose there's a difference between "this hint makes the problem gentle" and "this hint gives only a gentle push in the right direction".
20:56:39 <dmwit> I meant the latter.
20:56:45 <shachaf> That's what I meant too.
20:56:51 <shachaf> I think I'm saying that following dmwit's hint makes the problem into simple pattern-matching.
20:57:17 <shachaf> But maybe I'm the one giving the ungentle hints now.
20:57:42 <srhb> Well, now I don't dare try my hand at it for fear of being unable to do simple pattern matching. :P Spoil away.
20:57:49 <cmccann> it's hard to give hints on problems that involve exactly one non-obvious step
20:58:01 <shachaf> OK, maybe I wasn't very constructive there.
20:58:33 <dmwit> srhb: "not true = true implies false"
20:59:05 <dmwit> srhb: I wonder if a rule like that holds for other propositions?
21:00:08 <dmwit> srhb: abg k rdhnyf k vzcyvrf snyfr
21:01:26 <srhb> Right. OK, that's where I was going with the () -> Void (I was thinking of the truth table for -> where it is False)
21:01:32 <srhb> I see it now.
21:02:02 <shachaf> srhb almost had it anyway.
21:02:19 <dmwit> yeah
21:02:20 <srhb> Because I was thinking of p -> q truth table vs not p or q -- because that's the only place I could think of producing a not from something else
21:02:22 <srhb> :)
21:02:33 <srhb> I guess that was a roundabout method...
21:02:34 <dmwit> srhb: Okay, you ready for the next step?
21:02:38 <srhb> Yeah, go.
21:02:44 <dmwit> srhb: What's not (forall x. p x)?
21:02:58 <dmwit> srhb: (We have "forall" in our logic, too, it turns out.)
21:03:28 <srhb> exists x. not p x
21:03:37 <srhb> or..
21:03:43 <srhb> Eek, I'm rusty in logic!
21:04:00 <dmwit> Eeeek, yes, I wanted to set "not (forall x. not (p x))" as the exercise in the first place.
21:04:06 <dmwit> Just expand the not's.
21:04:15 <dmwit> We'll use that as a definition for exists afterwards.
21:04:40 <srhb> it's not exists x. not p x, right?
21:05:04 <dmwit> Okay. That exercise fell flat.
21:05:18 <srhb> derp.
21:05:20 <srhb> :|
21:05:20 <dmwit> But "not (forall x. not (p x))" = "(forall x. not (p x)) -> Void", right?
21:05:21 <EvanR> (forall x . p x) -> Void
21:05:37 <dmwit> = "(forall x. (p x -> Void)) -> Void"
21:05:37 <EvanR> where did the other not come from
21:05:55 <dmwit> EvanR: my brain
21:06:01 <EvanR> :S
21:06:10 <EvanR> oh you changed the problem
21:06:16 * hackagebot calculator 0.2.0.0 - A calculator repl.  http://hackage.haskell.org/package/calculator-0.2.0.0 (sumitsahrawat)
21:06:50 <shachaf> When dmwit is done I can talk about forall in Haskell a bit if people are interested.
21:07:27 <dmwit> srhb: The point being, Haskell doesn't have "exists". But it does have "forall". And since we agreed that "not (forall x. not (p x))" behaves the way we want "exists x. p x" to behave...
21:07:46 <dmwit> srhb: ...and we have "forall" and "not"... then we can pretend we have "exists" even though we don't.
21:08:06 <shachaf> (I don't mean explaining dmwit's things a different way, because his explanations are fine. Just talking about different things.)
21:08:35 <dmwit> srhb: Dunno if I'm making any sense.
21:08:49 <srhb> dmwit: You are, sorry, I'm just going through each step very slowly.
21:08:54 <shachaf> dmwit: If only (Not (forall x. Not (P x))) *was* (exists x. P x). :-(
21:08:59 <EvanR> how do Void functions help practically for doing exists
21:09:25 <Buttons840> I want to find all cabal sandboxes on my system; I will search for ".cabal-sandbox, but is this what the sandbox folders are always named? or can it be customized?
21:09:27 <ab9rf> i'm sure one of you is wrong, but i'm not sure which
21:09:29 <shachaf> (It's the same logically but not quite in Haskell. But I'm sure dmwit is getting to it.)
21:09:33 <srhb> Okay yes. Got it.
21:09:37 <ab9rf> Buttons840: it can be customized.
21:09:42 <EvanR> ab9rf: yeah just apply LEM ;)
21:09:48 <benzrf> EvanR: D:
21:09:55 <ab9rf> EvanR: lunar excursion module?
21:10:27 <srhb> dmwit: Thanks :)
21:10:34 <EvanR> law of excluded meddle
21:10:38 <Buttons840> ab9rf: how would you find all sandboxes?
21:11:16 * hackagebot purescript 0.6.5 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.5 (PhilFreeman)
21:11:41 <PPewt> Hey, somewhat new to haskell (written a few thousand lines of code thus far) and just ran into a rather unexpected issue which would be nice to find a workaround for if possible
21:11:53 <PPewt> That is, pattern matching doesn’t seem to always play nice with 0-arg data constructors, such as with:
21:12:07 <ab9rf> Buttons840: there's a sandbox config file (the name of which escapes me).  search for those.
21:12:20 <PPewt> data A = A a | … | B        data B = B A b c d
21:12:36 <ab9rf> check the documentation for cabal, it will say
21:12:53 <Buttons840> ab9rf: cabal.sandbox.config?
21:12:54 <shachaf> PPewt: What are a, b, c, d?
21:12:57 <EvanR> PPewt: so you used B as a constructor name and as a type name
21:12:59 <ab9rf> Buttons840: sounds right
21:13:00 <PPewt> m (a b c d)       — won’t match if A is a B (0-arg of A)
21:13:16 <EvanR> three different B
21:13:24 <PPewt> Whoops, yeah, I was just coming up with quick and dirty placeholder names, rename the second data to data X = X A b c d
21:13:42 <PPewt> Ugh, restart the example, I’m bad at this =/
21:13:45 <shachaf> PPewt: That doesn't change the question. What are b, c, d?
21:13:48 <ab9rf> is that even legal?
21:14:07 <shachaf> I think it's better to let PPewt ask their question.
21:14:12 <PPewt> data A = A x | … | B  , data X = X A b c d , m (B a b c d)
21:14:17 <PPewt> Types of b c d x aren’t important
21:14:28 <PPewt> The idea is that I have one or more n>0-argument data constructors for data type A
21:14:31 <PPewt> and one 0-argument data constructor
21:14:35 <shachaf> OK, so x,b,c,d are actually concrete (start with an uppercase letter) types.
21:14:35 <PPewt> and then type X contains an A and some other stuff
21:14:54 <PPewt> and when pattern matching against (X a b c d), it fails if A used the empty data constructor B
21:15:04 <shachaf> I'm still confused. Is m a function?
21:15:05 <gcganley> @pl (\xs ys -> and (zipWith (==) xs ys))
21:15:05 <lambdabot> (and .) . zipWith (==)
21:15:18 <gcganley> :t and . zipWith (==)
21:15:19 <lambdabot>     Couldn't match type ‘[b] -> [Bool]’ with ‘[Bool]’
21:15:19 <lambdabot>     Expected type: [b] -> [Bool]
21:15:19 <lambdabot>       Actual type: [b] -> [b] -> [Bool]
21:15:30 <shachaf> What's (B a b c d)? Are a b c d types or values here?
21:15:33 <ab9rf> gcganley: yuou can messaghe lambdabot.
21:15:33 <gcganley> :t (and .) . zipWith (==)
21:15:34 <lambdabot> Eq b => [b] -> [b] -> Bool
21:15:45 <PPewt> shachaf, a pattern match in a function
21:16:24 <shachaf> Are you able to make a simpler example?
21:16:39 <ab9rf> i am finding this example too inconcrete to understand
21:16:41 <shachaf> If you can define types that I can actually type into a program to make your point, that'll be helpful. :-)
21:16:49 <PPewt> Fair point, will write up one on pastebin
21:17:02 <PPewt> and unfortunately I don’t think I can make it simpler since I need nested datatypes with multiple type constructors
21:17:25 <shachaf> That's fine.
21:18:56 <PPewt> whoops, can do it with a single recursive data type
21:19:47 <PPewt> http://pastebin.com/L80meFRf here we go
21:20:34 <shachaf> PPewt: I don't believe you. :-)
21:21:04 <shachaf> You should make it a complete program and include the output.
21:21:12 <PPewt> so, I don’t believe myself either, really, which is why I’m confused
21:21:19 <PPewt> I have a working example of this failing but it’s part of tons of code
21:21:25 <PPewt> will try to come up with a simpler case
21:21:38 <shachaf> You can post your full code if you want, it could be easy for people to find.
21:22:04 <shachaf> But if you complete your example to be valid Haskell, the first and second cases will match.
21:22:31 <PPewt> That’s what I’d like to believe, but my example code seems to disagree
21:22:36 <PPewt> my actual code*
21:23:19 <shachaf> What is your actual code?
21:24:53 <PPewt> So, now I’m even more confused, because when I come up with a simple example it works fine.
21:25:38 <shachaf> You should be less confused. If your example didn't work fine, it would mean Haskell is very strange and not in line with your expectations; now it's only your actual code that's very strange and not in line with your expectations.
21:26:17 * hackagebot curve25519 0.2 - Fast implementations of the curve25519 elliptic curve primitives.  http://hackage.haskell.org/package/curve25519-0.2 (AdamWick)
21:26:19 * hackagebot keter 1.3.8 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.8 (MichaelSnoyman)
21:26:50 <PPewt> Fair point, but my code is simple enough that I’m not sure what’s going on here:
21:27:09 <PPewt> http://pastebin.com/ZLve9WeG Commented line commented out: I get the error at the bottom. Uncommented: I get the error at the top
21:28:24 <PPewt> aha, haven’t tested to fix this yet, but I think I’ve discovered the issue
21:28:48 <PPewt> I’m guessing if guards fail to match it carries on to the next function definition rather than just erroring then and there?
21:29:34 <PPewt> Yeah, that was the issue. Neato. Assumed it would work the same way as case/etc where it just fails if it runs out of cases
21:29:39 <PPewt> Sorry for the false alarm
21:31:58 <shachaf> PPewt: Yes, that's how it works.
21:32:40 <shachaf> It's great.
21:32:57 <PPewt> that’s actually rather convenient, now that I know that’s how it works
21:33:00 <PPewt> learn something new every day
21:33:16 <shachaf> Yep.
21:33:41 <PPewt> the dangers of testing half-implemented code to see what it does this far, though ^^
21:33:45 <PPewt> thus*
21:36:50 <Zemyla> Why is there no class Nullable a with null :: a -> Bool?
21:37:28 <ab9rf> why would there be?
21:37:35 <Zemyla> I am sick to death of having to say Set.null or ByteString.null or FlibbertyJibbet.null.
21:38:00 <ab9rf> ah.  well, write one.
21:38:03 <Zemyla> It should be a typeclass because the set of types of things that can be tested for nullness is well-defined.
21:38:40 <shachaf> null will be part of Foldable in GHC 7.10
21:38:46 <Zemyla> It should be part of Haskell core so any type that needs it can go "instance Nullable FlibbertyJibbet where".
21:38:57 <shachaf> That only works for parameterized types, of course.
21:38:58 <Zemyla> Hmm, will it have empty :: a as well?
21:39:07 <shachaf> No.
21:39:30 <shachaf> I don't think a Nullable class like yours is so great. Foldable is probably OK.
21:39:39 <shachaf> (You could already implement it with Foldable, just not efficiently.)
21:39:42 <Zemyla> IntSet can't be foldable.
21:39:54 <Zemyla> For instance.
21:40:02 <Zemyla> ByteString can't be Foldable.
21:40:38 <shachaf> Yes, like I said, just parameterized types.
21:42:31 <HeladoDeBrownie> normally when you have an "empty" element it's with respect to some operation, which is just Monoid. guess what has a Monoid instance?
21:42:51 <Zemyla> empty should be part of it too, because if testing whether something is empty is meaningful, then there should be a value that gives True/
21:42:52 <shachaf> The comment in https://github.com/ghc/ghc/blob/master/libraries/base/Data/Foldable.hs#L181 is silly.
21:43:11 <shachaf> Oh well, whatever.
21:43:14 <nshepperd> empty already exists, in Monoid
21:44:18 <HeladoDeBrownie> that said, Monoid alone does not let you test for that element. for that you'd generally also need Eq. so, i suppose there might be *some* use in having a class with Monoid and Eq as superclasses. but in practice it's not used much.
21:45:36 <ab9rf> it sounds like your interest is mainly out of convenience rather than out of useable polymorphism
21:45:37 <HeladoDeBrownie> though it's worth asking why you want to test whether something is the empty element.
21:45:53 <mseeks> any introductions/tutorials to TCache?
21:46:01 <Zemyla> Yeah, it is, mostly.
21:46:18 * hackagebot hjsonschema 0.1.1.0 - Haskell implementation of JSON Schema v4.  http://hackage.haskell.org/package/hjsonschema-0.1.1.0 (seagreen)
21:46:19 <ab9rf> if you're writing code that should work on any objecty htat might be "null", then you are probably also going to want to be able to worjk on it when ti's not null as well
21:46:52 <ab9rf> and that suggests you need some means to iterate over whatevr generic container you're talking about
21:47:08 <ab9rf> hence, foldable, traversable, or some similar class
21:51:10 <HeladoDeBrownie> i think iteration and "emptiness" are separate concerns
21:51:17 <HeladoDeBrownie> it just so happens that some things have both features.
21:55:02 <carter> it's not that bad to have (Eq m, Monoid m)=> as your constraints anyways
21:55:28 <HeladoDeBrownie> yeah, given that that's what you need
21:59:37 <glguy> The magic null class is in lens
21:59:49 <HeladoDeBrownie> glguy, which?
22:00:10 <glguy> AsEmpty
22:01:19 * hackagebot calculator 0.2.0.1 - A calculator repl.  http://hackage.haskell.org/package/calculator-0.2.0.1 (sumitsahrawat)
22:01:47 <HeladoDeBrownie> more useful than a -> Bool at least, since it gives a Prism.
22:04:42 <carter> http://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Empty.html#t:AsEmpty
22:16:19 * hackagebot yesod-auth 1.4.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.2 (MichaelSnoyman)
22:16:21 * hackagebot yesod-core 1.4.7.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.7.3 (MichaelSnoyman)
22:20:32 <mseeks> i was trying out TCache in ghci, and when I ran `newDBRef` it basically hung and made some files that ate up all my disk space
22:23:36 <mseeks> now I'm really scared of using TCache
22:27:33 <isomorphic> If I have two typeclasses, Categoric and Interval, and I know that these two instances are mutually exclusive, how can I write a typeclass which will work with anything that has one of them?  Or do I need two typeclasses?
22:31:06 <Hafydd> isomorphic: I don't know a lot about typeclasses, but it seems to me like you could write a third typeclass that both are a subclass off.
22:31:49 <Hafydd> Then each value defined in the superclass has a Maybe or Either version of the subclass's values.
22:32:35 <isomorphic> Thanks Hafydd
22:34:41 <isomorphic> I'll play around with something like that
22:35:34 <cmccann> isomorphic: last I checked there's no "proper" way to do what you want
22:39:33 <isomorphic> cmccann: thanks :)
22:42:24 <cmccann> isomorphic: if you have two classes A and B such that C has an obvious implementation in terms of either, then for a function "foo" belonging to C I'd write "defaultFooA" and "defaultFooB" using the other classes
22:42:45 <cmccann> isomorphic: then just copypasta boilerplate instances of C for each instance of A or B
22:44:43 <isomorphic> cmccann:    Hm..  Thanks.   No, the implementation for C is different.  Although, I might be trying to solve the problem the wrong way (ie: I don't have to use typeclasses, I just thought it seemed like the right way).   What I actually have a family of types which I call Interval types (Double, Float, Int) and a family of types I call Categorical types (Bool, String, Text).   I want to the user to be able to get a summary, but the
22:44:44 <isomorphic>  summary is much different depending on which family of types this particular type belongs to
22:46:06 <mniip> isomorphic, I don't follow why is Int an inteval and Bool not?
22:47:27 <cmccann> isomorphic: I have a suspicion you're overcomplicating things somehow but I don't have time to dig deeper, sorry :T
22:47:30 <isomorphic> mniip:  There might be cases where it's different.   I was thinking of a case where two Ints have a meaningful distance between them, and a case where Bool represented True and False
22:47:42 <isomorphic> cmccann:  All good, :)
22:48:20 <mniip> any member of Enum can have a distance between 2 members
22:48:24 <mniip> including Bool
22:48:33 <mniip> and with some imagination, String
22:48:34 <cmccann> well, the distance between two Bool values is their XOR, arguably
22:49:04 <mniip> is the distance :: a -> a -> a, or :: a -> a -> Integer
22:49:18 <mniip> the former doesn't work at all
22:50:14 <mniip> hmm, I should rewrite my Enum [a] to follow Ord order
22:52:22 <PrecisionGuy> help please ... I need a function (or Monad) to return one of two types I get back from a function
22:52:31 <PrecisionGuy> I get back 'Result Expr'
22:52:36 <PrecisionGuy> but I just want the 'Expr'
22:52:49 <PrecisionGuy> I've tried 'snd' and so forth with no joy
22:53:03 <PrecisionGuy> I understand that a Monad may be the best way to do this
22:53:11 <PrecisionGuy> but is there a simple way I'm missing?
22:53:30 <mniip> what's a Result
22:53:37 <mniip> also snd only works on tuples
22:53:41 <PrecisionGuy> Just types 'Ok' or 'Err'
22:53:50 <mniip> can you give some context?
22:54:13 <PrecisionGuy> Sure: parseExpr returns 'Result Expr'
22:54:35 <glguy> PrecisionGuy: Just case on it
22:54:41 <PrecisionGuy> but I need to call it recursively which stacks up the results so need to call out and ditch intermediate results
22:54:56 <mniip> is Result a data constructor?
22:55:05 <Zemyla> Hmm. Why isn't Maybe a MonadZip?
22:55:29 <PrecisionGuy> data Result a = Ok a -- Success
22:55:29 <PrecisionGuy>               | Err String -- Error with description
22:55:29 <PrecisionGuy>               deriving (Eq, Show)
22:55:53 <mniip> looks a bit like Either, but go on
22:55:54 <PrecisionGuy> and Expr is a separate type
22:56:43 <mniip> looks like you want case
22:58:00 <PrecisionGuy> case of what? I get back (Ok, newexpr) from parseExpr then need to just pass in the 'newexpr' back into parseExpr recursively, ditching the 'Ok'
22:58:27 <mniip> (Ok, newexpr) isn't valid...
22:58:34 <mniip> you mean OK newexpr?
22:58:36 <mniip> Ok*
22:58:40 <PrecisionGuy> Yes
22:59:03 <mniip> case parseExpr ... of Ok x -> whatever; Err s -> whatever
22:59:56 <PrecisionGuy> BRB after I try this thx
23:00:05 <mniip> https://wiki.haskell.org/Keywords#case
23:04:33 <PrecisionGuy> Thanks mniip -- don't know how I missed that was recursing from a different 'case' above and just didn't see this
23:04:46 <PrecisionGuy> too much imperative cruft sticking in my brain!
23:05:35 <mniip> you should consider declaring 'instance Monad Result' and then just use 'forever' or something
23:06:17 <PrecisionGuy> this gets me over my immediate hump but will look at that later thx
23:06:22 <mniip> return = Ok; (Ok x) >>= f = f; s@(Err _) >>= _ = s;
23:06:36 <nocturne777> I am planning to use emacs for haskell coding. what is the most popular editor among haskellers?
23:06:40 <mniip> er
23:06:41 <mniip> f x
23:07:11 <mniip> nocturne777, whatever editor you're comfortabe with
23:07:21 <ryantrinkle> nocturne777: i use emacs; i'm thinking of trying this stuff when I have some time: http://blog.hoersten.co/post/110096363794/modern-emacs-haskell-mode
23:07:29 <HeladoDeBrownie> nocturne777, the most popular is likely emacs, with vim being a second, from what i can tell
23:08:20 <mniip> I'm using more or less vanilla vim, with only formatprg overriden to pointfree
23:08:27 <ryantrinkle> nocturne777: emacs and vim are very popular, but keep in mind that there's a difficult learning curve, so if you don't already know one of them, it might be better to stick with something you know rather than learning emacs and haskell at the same time
23:08:34 <HeladoDeBrownie> mniip, D:
23:08:52 <nocturne777> ryantrinkle: I already know emacs :)
23:08:59 <nocturne777> Have not been using it for a while
23:09:06 <nocturne777> been using IDEs
23:09:11 <ryantrinkle> nocturne777: awesome; then hopefully that link i sent will be useful :)
23:09:26 <ryantrinkle> (ping me if you try it! i'd love to know how it goes for you)
23:09:39 <mniip> HeladoDeBrownie, what
23:09:49 <mniip> I don't need no more
23:10:23 <HeladoDeBrownie> mniip, i don't know exactly what formatprg is but it sounds like you have vim automatically replace your definitions with their point-free versions
23:10:29 <HeladoDeBrownie> mniip, is that correct?
23:10:38 <mniip> not automatically
23:10:51 <mniip> only if I 'gq' in visual mode
23:11:02 <HeladoDeBrownie> i see
23:11:25 <nocturne777> ryantrinkle: what about this one https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md ?
23:11:39 <HeladoDeBrownie> i still find that a little odd, since if i'm not clever enough to come up with the point-free version myself, i'm often not clever enough to remember what it does later, but whatever suits you
23:11:57 <ryantrinkle> nocturne777: that looks very nice :)
23:12:15 <agam> > not True
23:12:17 <lambdabot>  False
23:12:59 <mniip> HeladoDeBrownie, I only keep pointfrees that are readable
23:13:33 <nocturne777> ryantrinkle: it looks a lot of work
23:13:54 <ryantrinkle> nocturne777: yeah, definitely
23:14:01 <ryantrinkle> personally, i just use haskell-mode these days
23:14:56 <ryantrinkle> it would be nice to have some fancier stuff, but i haven't spent the necessary time
23:17:27 <Buttons840> How can I install a package from source into a cabal sandbox?
23:18:23 <Buttons840> as in, I want to do "Setup.hs build" and have libraries from a sandbox used for buildings, then do "Setup.hs install" and have the new package installed to the sandbox
23:19:34 <Hijiri> I did that serras guide, I don't think it took that long to set my emacs up
23:19:56 <Hijiri> I still don't know all the keybindings though
23:37:23 <reem> Is it possible to have type inequality bounds in Haskell? Something like (Ord a, Ord t, t != a) => ..
23:37:41 <reem> Note that I mean that the type t is the not same as the type a, not that their values are different
23:38:26 <rhllor> I believe you'd have to check value equality in the functin body itself
23:39:16 <pacak>  type family Equal (a :: k) (b :: k) :: Bool type instance where    Equal a a = True    Equal a b = False
23:40:21 <enthropy> there's a Data.Type.Equality.== in base
23:40:40 <enthropy>  (Ord a, Ord t, (t == a) ~ False) => ...
23:43:04 <enthropy> reem: but why? Having 't' and 'a' as separate type variables already prevents you from mixing them up
23:44:47 <reem> enthropy: This is a useless case, but it can come in handy
23:44:57 <reem> for instance if you want to encode whether a type is present in an HList or not
23:46:24 <reem> pacak: That seems to be what I'm looking for.
