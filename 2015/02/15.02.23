00:03:04 <dulla> anyways, things will get weirder as the interfaces get more and more rational
00:07:43 <sinelaw> Trying to read a paper, they have a bar notation over some terms, which I'm not familiar with: http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html
00:08:13 <sinelaw> page 5
00:08:17 <sinelaw> what does the bar mean?
00:08:27 * hackagebot tabular 0.2.2.6 - Two-dimensional data tables with rendering functions  http://hackage.haskell.org/package/tabular-0.2.2.6 (EricKow)
00:08:27 * hackagebot euler 0.2.2 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.2.2 (decomputed)
00:08:29 <heatsink> list
00:09:12 <heatsink> sinelaw: list
00:09:16 <sinelaw> heatsink, thanks
00:09:25 <sinelaw> heatsink, possibly empty I assume?
00:09:29 <heatsink> yes
00:09:31 <Cale> sinelaw: They explain that in more detail at the start of section 4.1
00:09:53 <sinelaw> Cale, oh missed that, was skimming through. thanks also
00:14:20 <dulla> 4.1?
00:15:12 <Cale> dulla: Yes, on page 5
00:15:23 <dulla> Sol Severitas?
00:15:31 <Cale> ?
00:17:31 * dulla wipes brow
00:28:44 <planko> hi
00:34:53 <merijn> What do haskellers and cheapskates have in common?
00:34:59 <merijn> They both like free stuff :p
00:37:44 <tdammers> I don't like most free-as-in-beer stuff that isn't free-as-in-speech
00:38:05 <tdammers> mostly because there's still a price to pay, just not in money
00:38:36 <obiwahn> mic
00:38:51 <merijn> tdammers: I was referring to free monoids and free theorems :>
00:38:56 <tzaeru> tdammers, how about "free-as-in-beer with the beer recipe along with it"?
00:39:17 <merijn> And you go and turn it into a boring licensing debate >.>
00:39:23 <tdammers> haha
00:39:37 <tdammers> so are free monoids free as in beer, or free as in speech, or free as in from lice?
00:41:17 <merijn> I dunno, I didn't read the free monoids blogpost yet :p
00:41:49 <merijn> Free theorems are free as in "crazy ravings of a homeless person", you're getting them whether you want them or not ;)
00:42:26 <shachaf> Oh, dolio wrote a post about free monoids.
00:44:07 <shachaf> And it's about something I've been saying for years.
00:44:26 <ocharles_> What's up, bgmari?
00:44:34 <shachaf> (Not that I'm the first person to say it.)
00:50:51 <merijn> The reason "(single 1 <>)" in that blogpost is because mappend is recursing on it's second (potentially infinite) argument, right?
00:52:28 <shachaf> The reason what?
00:53:18 <merijn> *is strict
00:53:23 <merijn> Typing is hard...
00:53:24 * hackagebot hub 1.9.0.1 - For multiplexing GHC installations and providing  development sandboxes  http://hackage.haskell.org/package/hub-1.9.0.1 (ChrisDornan)
00:53:24 <dulla> ?
00:54:42 <shachaf> Recursing?
00:54:54 <shachaf> mappend is matching on its second argument.
00:56:20 <merijn> And then recursively calling itself, but since the second argument never terminates, neither does the recursion and that's the problem, right?
00:56:23 <dulla> free monoids?
00:56:28 <dulla> free like free india?
00:56:54 <mniip> I pat $4.99 for this monoid
00:56:57 <mniip> paid*
00:56:57 <EvanR> free as in beer
00:57:23 <shachaf> The recursion isn't the reason it's strict.
00:57:30 <dulla> so
00:57:35 <dulla> they happen
00:57:36 <tdammers> mniip: I'll sell you extended support for 12 months for just $1.99
00:57:44 <dulla> not sure what free means anyways
00:57:45 <merijn> dulla: No, free like free theorems :p
00:57:53 <dulla> man
00:57:55 <shachaf> "mappend ys Empty = ys; mappend ys (xs :> x) = (mappend ys xs) :> x"
00:57:56 <dulla> if only I knew math
00:58:25 <merijn> dulla: It's never too late to learn!
00:58:35 <dulla> Well
00:58:57 <dulla> The issue is multiplexing/compiling from a to b
00:58:58 <shachaf> It's matching on the second argument, therefore it's strict in it.
00:59:04 <dulla> through c..z
00:59:39 <merijn> dulla: Essentially it boils down to a neat paper by Wadler called "Theorems for Free", which shows how parametrically polymorphic functions give you some "theorems for free", i.e. the type alone proves some properties about the function
01:00:07 <dulla> I feel like oleg is staring in through the window
01:00:22 <mniip> <merijn> dulla: No, free like free theorems :p
01:00:22 <dulla> all this free effects with zippers, and the sort
01:00:27 <merijn> dulla: One example would be that "map :: (a -> b) -> [a] -> [b]" cannot create a's out of thin air, therefore the results MUST be a subset of the a's in the input list with the function applied to it.
01:00:27 <mniip> I paid $3 for this theorem
01:00:32 <mniip> seriously what's a free theorem
01:01:02 <merijn> dulla: Similarly, the fact that "id :: a -> a" MUST return it's input (well, or bottom, because bottom always ruins the party...)
01:01:41 <merijn> @djinn (a -> b) -> [a] -> [b]
01:01:42 <lambdabot> Error: Undefined type []
01:01:49 <merijn> aww, djinn doesn't know lists...
01:01:50 * EvanR reads what a free object is
01:01:57 <mniip> djinn can't into recursive types
01:02:14 <merijn> @djinn (a -> b) -> Maybe a -> Maybe b
01:02:15 <lambdabot> f a b =
01:02:15 <lambdabot>     case b of
01:02:15 <lambdabot>     Nothing -> Nothing
01:02:15 <lambdabot>     Just c -> Just (a c)
01:03:09 <shachaf> djinn doesn't have all that much to do with free theorems.
01:03:41 <Cale> @free f :: (a -> b) -> Maybe a -> Maybe b
01:03:41 <lambdabot> h . k = p . g => $map_Maybe h . f k = f p . $map_Maybe g
01:04:23 <Cale> @free (a -> b) -> [a] -> [b]
01:04:23 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
01:04:27 <Cale> @free f :: (a -> b) -> [a] -> [b]
01:04:28 <lambdabot> h . k = p . g => $map h . f k = f p . $map g
01:05:21 <kaidelong> mmm
01:05:34 <kaidelong> there was this transformation you could do on [] to make it non-recursive, right?
01:05:38 <kaidelong> by encoding it as a right fold?
01:05:45 <kaidelong> I wonder if djinn could work with that
01:06:02 <kaidelong> well
01:06:08 <kaidelong> it'd have to know about cons and friends
01:06:18 <kaidelong> because those become functions, rather than constructors
01:08:50 <nshepperd> @djinn (a -> b) -> (c -> (a -> c -> c) -> c) -> (c -> (b -> c -> c) -> c)
01:08:50 <lambdabot> f a b c d = b c (\ e -> d (a e))
01:09:10 <dolio> shachaf: I thought it should finally be written down instead of just said.
01:09:23 <nshepperd> hmm
01:09:34 <shachaf> dolio: Yep.
01:12:30 <nshepperd> that does seem to be the correct map
01:13:49 <shachaf> There's only one correct map.
01:14:06 <shachaf> OK, I guess that's why you said "the".
01:14:33 <shachaf> What's that type for?
01:15:43 <nshepperd> (a -> b) -> [a] -> [b], with lists encoded as a foldr
01:16:11 <nshepperd> minus the universal quantification that should really be in there
01:16:32 <shachaf> Oh. That's really very different without the quantification.
01:17:11 <nshepperd> @djinn (a -> b) -> (forall c. c -> (a -> c -> c) -> c) -> (forall c. c -> (b -> c -> c) -> c)
01:17:11 <lambdabot> f a b c d = b c (\ e -> d (a e))
01:17:13 <shachaf> And of course map f _ = [] is a valid function of that type.
01:17:26 <nshepperd> huh, djinn does understand rank 2 types
01:17:34 <shachaf> @djinn (a -> b) -> (word c. c -> (a -> c -> c) -> c) -> (word c. c -> (b -> c -> c) -> c)
01:17:34 <lambdabot> f a b c d = b c (\ e -> d (a e))
01:17:40 <shachaf> a bit fishy
01:17:41 <nshepperd> oh
01:17:58 <nshepperd> that's suspicious
01:18:40 <nshepperd> I was kind of expecting it to say f a b c _ = c
01:19:21 <shachaf> It tries to use all the arguments if it can. Sort of.
01:23:47 <dolio> @djinn (wat . a) -> (wat . a)
01:23:47 <lambdabot> Cannot parse command
01:24:20 <dulla> wat
01:24:37 <dolio> Oh, I see.
01:24:42 <dolio> @djinn a. -> a -> a.
01:24:43 <lambdabot> f a _ = a
01:25:07 <dolio> . is allowed in variable names.
01:25:45 <Gomboc> ok I got 10 minutes before I have to go
01:25:49 <Gomboc> teach me template haskell
01:26:14 <EvanR> clocks ticking
01:26:22 <heatsink> @djinn (forall a. f a -> f (f a)) -> f a -> f (f a)
01:26:23 <lambdabot> -- f cannot be realized.
01:27:43 <mniip> to djinn 'forall a.' is like 'x y'
01:28:40 <heatsink> Hmm
01:28:44 <heatsink> @djinn [a] -> [a]
01:28:44 <lambdabot> Error: Undefined type []
01:33:26 * hackagebot hindent 4.3.12 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.12 (ChrisDone)
01:35:46 <funfunctor> EvanR: are you still around?
01:36:07 <EvanR> yes
01:36:48 <funfunctor> EvanR: alright so I am just trying to write openBladeRF' :: IO (Either BladeRFError DeviceHandle)
01:37:01 <EvanR> makes sense afaik
01:38:12 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121018
01:38:34 <funfunctor> EvanR: ^ how to write that properly, possibly with alloc
01:38:48 <funfunctor> note it does not type-check properly
01:39:01 <funfunctor> I'm not constructing the device handle type properly
01:39:42 <EvanR> :t alloca
01:39:43 <lambdabot> Not in scope: ‘alloca’
01:40:00 <EvanR> something like this http://lpaste.net/121018
01:40:18 <mniip> alloca isn't a function is it
01:40:20 <mniip> it's a C built in
01:40:30 <EvanR> alloca is a function in haskell FFI
01:40:36 <mniip> oh
01:40:51 <EvanR> its also in C, and not used here
01:41:23 <mniip> yeah I thought it was an attempt to use the foreign alloca, which is not a real function
01:41:50 <funfunctor> EvanR: but how does alloca know the type of the ptr there to get the correct size?
01:42:18 <EvanR> it might know from the type of c'bladerf_open
01:42:36 <funfunctor> hmm ok
01:42:43 <EvanR> or it might not, in which case you need a type annotation, but imo the type of c'bladerf_open is the right place to put it
01:43:08 <funfunctor> EvanR: alright how to get the last bit to type check, Just is from Maybe not Either
01:43:22 <EvanR> the size in question is the size of a pointer so the type beyond `Ptr a' is inconsequential
01:43:27 * hackagebot structured-haskell-mode 1.0.20 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.20 (ChrisDone)
01:43:53 <EvanR> @src Either
01:43:53 <lambdabot> Source not found. :(
01:44:01 <EvanR> funfunctor: Left and Right are the constructors of Either
01:44:12 <EvanR> Left is an error by convention
01:44:37 <funfunctor> :t Right
01:44:38 <lambdabot> b -> Either a b
01:44:47 <funfunctor> :t Either
01:44:47 <lambdabot>     Not in scope: data constructor ‘Either’
01:44:47 <lambdabot>     Perhaps you meant ‘Other’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
01:45:08 <EvanR> :t Right
01:45:09 <lambdabot> b -> Either a b
01:45:23 <funfunctor> thx, Right is basically Just (i.e. went ok)?
01:45:41 <EvanR> you have to check ret to know if you need to return Left
01:46:42 <funfunctor> EvanR: I know but I am probably going to come back to it and use Exception instance instead of Either, maybe thats better?
01:46:53 <EvanR> you can do both
01:46:56 <merijn> funfunctor: Conventionally "Right" is the "ok" case, yes
01:47:01 <EvanR> one can be implemented in terms of the other
01:47:15 <merijn> Mostly because that way is most useful with the Functor/Monad instance of Either :)
01:47:19 <dulla> right is right
01:47:29 <merijn> i.e.
01:47:34 <funfunctor> I'm very confused by Exception handling in Haskell.. names have changes on hackage over time and stuff
01:47:44 <EvanR> Control.Exception
01:47:57 <EvanR> and yes google linking to hackage can give you old versions of stuff beware
01:48:08 <merijn> funfunctor: Control.Exception and (if you're using monad transformers) the exceptions library are the way to go
01:48:15 <funfunctor> EvanR: I mean blogs and stuff to get a feeling for how stuff is done
01:48:31 <merijn> (exceptions just wraps Control.Exception with transformer stuff)
01:48:36 <EvanR> merijn: ive spent the last few days trying to get funfunctor to avoid transformers in his case ;)
01:48:45 <merijn> funfunctor: Well, the confusing bit is that some people are calling things excpetions that are not
01:48:56 <merijn> funfunctor: i.e. calling "Either Error Foo" an "exception"
01:49:01 <funfunctor> hehe, thx for all the help btw
01:49:24 <simg> Hi. Anyone know if digestive-functors has a size limit on file fields. I have such a form field silently failing when the size is > ~128Kb ?
01:49:38 <EvanR> funfunctor: exceptions (in IO, the normal kind of exceptions) are easy. you use throwIO, and you can catch a particular exception with try
01:49:40 <merijn> funfunctor: And in the olden days there were only IOError exceptions whereas now there's extensible exceptions that can be customised
01:49:55 <funfunctor> Either is just the monad the controls the if good else bad control flow but the Exception instance is the signaling pathway right?
01:50:09 <merijn> EvanR: You can actually catch classes of exceptions too, not just single ones :)
01:50:24 <EvanR> funfunctor: Exception is for "impure" exceptions, corresponding to exceptions in every other language
01:50:31 <EvanR> which is what ive been talking about only
01:50:35 <funfunctor> oh ok
01:50:37 <merijn> funfunctor: Control.Exception are proper unchecked exceptions like you have in Java/Python/C++/etc
01:50:38 <EvanR> merijn: yes
01:51:06 <merijn> Now I consider the unchecked bit a design flaw and have some ideas on how to eradicate that, but they'll have to do for now...
01:51:28 <EvanR> meanwhile the current IO exceptions situation is just fine with me
01:51:34 <funfunctor> so what would I use in my case where I have all those various error codes defined in data BladeRFError = ErrorThis | ErrorThat | ErrorWillError
01:51:54 <funfunctor> it has a nice show instance also
01:51:56 <EvanR> funfunctor: depends on ret?
01:52:00 <funfunctor> correct
01:52:05 <merijn> funfunctor: Well, basically the rule of thumb I use is: Expected/common cases and libraries should return explicit errors
01:52:21 <merijn> funfunctor: Applications that want to terminate an inner loop based on an error should use exceptions
01:52:28 <funfunctor> from various C functions. Actually I map BladeRFError to the C error codes using a Enum instance
01:52:40 <merijn> funfunctor: i.e. socket error deep inside inner server loop -> exceptions
01:52:47 <EvanR> merijn: or provide both as a library so the client code can decide if the error is expected common or not
01:53:09 <merijn> funfunctor: Basically, use them whenever unchecked exceptions would be appropriate in other languages
01:53:10 <EvanR> and decide how much of a shit to give about possible errors
01:53:14 <funfunctor> right, I like the "do both, let user choice" version
01:53:27 * hackagebot learning-hmm 0.3.1.1 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.3.1.1 (mnacamura)
01:53:28 <merijn> EvanR: Yeah, but I think people defaulting to unchecked exceptions in libraries is bad design
01:53:35 <EvanR> yes definitely
01:53:50 <funfunctor> Well there are a hand full of errors really and I would like to handle them all because I am dealing with hw
01:53:59 <EvanR> yes
01:54:01 <merijn> I'd really love to make them all checked in haskell, so you know for sure you're handling them
01:54:24 <merijn> funfunctor: Basically if you always handle them right when they happen, use Either, if you handle them "elsewhere" use exceptions
01:54:28 <EvanR> funfunctor: thats why i suggested starting with Either
01:54:37 <EvanR> you can add throwIO versions later if you really want
01:54:48 <merijn> Because Either will make the compiler check that you're not forgetting some errors
01:55:21 <EvanR> the exception versions are good when the only thing you would/could do on a Left is ... crash, error, whatever
01:55:41 <EvanR> its stupid to deal with that everywhere if thats what youre going to do, like C if(ret < 0){
01:57:54 <lpaste> funfunctor revised “No title”: “No title” at http://lpaste.net/121018
01:57:55 <phaazon> hi
01:58:05 <funfunctor> EvanR: so something like that?
01:58:48 <EvanR> funfunctor: no
01:59:09 <EvanR> modifying
02:00:59 <phaazon> is there a good spline library out there?
02:01:11 <phaazon> I found one on hackage, but it seems to be discontinued
02:01:44 <EvanR> funfunctor: http://lpaste.net/121018
02:04:42 <funfunctor> EvanR: ah ok, yes its that error in every case because the function works if the hw exists and else does not work :)
02:04:49 <EvanR> funfunctor: i modified it again to fix the if then indentation
02:05:14 <funfunctor> EvanR: would it not be better to merge those two openBladeRF's into one action?
02:05:18 <EvanR> how?
02:05:28 <EvanR> they do two different things
02:06:10 <EvanR> nevermind, just no ;)
02:06:19 <funfunctor> EvanR: so your saying I should expose both outside the binding?
02:06:41 <EvanR> the Either one is the rightest, and the exception one is like a convenience, to me
02:06:44 <funfunctor> one for exception and the other for Either
02:07:00 <EvanR> which means you can be a hard ass and not give them the excpetion one
02:07:16 <funfunctor> lol
02:07:37 <EvanR> but like i said before it just leads to people writing C-like code where they do if(left){ fprintf(stderr, "oh no...\n"); exit(-1); }
02:07:40 <funfunctor> EvanR: but that would mean I would have two of every action, there is like 40-50 actions
02:07:55 <EvanR> they all can fail?
02:07:59 <funfunctor> yes
02:08:12 <funfunctor> see error codes
02:08:23 <funfunctor> we are talking to *hardware* i.e. real world
02:08:33 <EvanR> sure
02:08:49 <funfunctor> so these errors are the bare minimum
02:08:55 <EvanR> if it has a documented failure mode, you must honor it in the bindings
02:09:13 <EvanR> haskell runs on hardware yet we have a lot of pure functions anyway
02:09:14 <EvanR> just saying
02:09:30 <funfunctor> thats a little different
02:09:53 <funfunctor> the kernel runs on hw but it knows nothing about the complexity of DDR training
02:10:09 <funfunctor> see coreboot
02:10:26 <EvanR> anyway, yes you have to do a lot of repetative work when writing bindings
02:10:43 <EvanR> some projects autogenerate them
02:10:52 <funfunctor> EvanR: sounds like I should just expose the non-hard-ass versions with exceptions
02:11:07 <funfunctor> EvanR: yea I am using bindingDSL also
02:11:25 <EvanR> fine
02:11:30 <funfunctor> that generates all the horriblely named stuff and then I shim around it to be more Haskell like
02:11:40 <EvanR> merijn will be sad but ok
02:12:05 <funfunctor> duplicates a bit but it means its a bit more maintainable for when the C library breaks shit
02:12:06 <EvanR> the code for the Either versions can be pretty easily be autogenerated
02:12:26 <funfunctor> ?
02:12:34 <EvanR> but youre your only user of these bindings so its just a matter of how much work you want to do for yourself
02:13:00 <EvanR> to me it seems haskell libs put a lot of work into making it make sense in good, if its going on hackage
02:13:14 <EvanR> if the reason for something missing is "meh im lazy", well that sucks ;)
02:13:15 <funfunctor> EvanR: I usually do prefer for things to be done right provided I am not spending a week just on error handling
02:13:38 <EvanR> you probably wouldnt have spent so long if you had prior practice doing any of this
02:13:50 <funfunctor> EvanR: yes I am just trying the balance the binding and all the other many sub components
02:14:40 <funfunctor> true, I get rusty every time I come back to Haskell and I have not spent long enough working with it in every interesting way not to keep forgetting stuff
02:14:43 <EvanR> bindings in particular seem to take a lot of repetitive work
02:14:51 <funfunctor> yea, pain
02:15:33 <EvanR> i think you should expose one or the other, but do both for a small few of the api calls
02:15:44 <EvanR> so that your laziness is staring you in the face forever
02:15:57 <funfunctor> EvanR: take a look at the mBTS branch of https://github.com/victoredwardocallaghan/hlibBladeRF/tree/mBTS
02:16:06 <funfunctor> EvanR: your see the binding is actually pretty large
02:16:20 <EvanR> .. what file
02:17:00 <EvanR> looks pretty small to me ;)
02:17:14 <funfunctor> thats not all of it
02:17:27 <funfunctor> yea, I guess its not libX
02:17:32 <EvanR> i could find any sizable amount of stuff starting from just your last link
02:17:34 <EvanR> couldnt
02:17:59 <funfunctor> no, I have not published much yet
02:20:06 <merijn> funfunctor: You can autogenerate bindingDSL from C code, FYI
02:20:22 <merijn> c2hsc can do that
02:20:29 <funfunctor> merijn: I do all that
02:20:59 <funfunctor> merijn: https://github.com/victoredwardocallaghan/hlibBladeRF/blob/mBTS/src/Bindings/LibBladeRF/LibBladeRF.hsc
02:21:18 <EvanR> i think this code is one level above the bindings to change it from Ptrs to newtypes and throw exceptions
02:21:23 <merijn> I meant that c2hsc can autogenerate that hsc file
02:21:48 <funfunctor> merijn: oh !
02:21:55 <funfunctor> shit, now you tell me
02:22:03 <funfunctor> oh well, atleast my vim isn't so bad
02:22:12 <funfunctor> I just used some regexp on the header
02:22:16 <merijn> It doesn't really integrate automatically in cabal, so I wrote my own cabal hook for it
02:22:22 <merijn> https://github.com/merijn/SNet2.0/blob/master/Setup.hs
02:22:56 <funfunctor> merijn: thx, i'll look into that
02:22:58 <merijn> Which automatically generates hsc from the header file I pass in, because I'm lazy :p
02:24:01 <merijn> I actually don't find FFI bindings that painful, as long as you don't have to deal with structs (pointers to structs that you don't have to update from haskell are fine)
02:24:30 <merijn> Although I recently saw a proposal to allow GHC to deal with C structs, which would be neat
02:25:07 <EvanR> updating a struct field is just a #(poke
02:25:28 <funfunctor> merijn: yea I have to deal with structs and awkward usage of int's
02:25:38 <merijn> EvanR: You still need to define a Storable instance
02:25:43 <EvanR> you do not
02:25:53 <Yuras_> merijn: the proposal is thrown away :)
02:25:54 <merijn> Oh, you mean in hsc?
02:25:57 <merijn> Yuras_: :(
02:26:12 <EvanR> i didnt do that because my structs were huge and partially private, so it made no sense to overwrite the whole thing to change a field
02:26:35 <EvanR> yeah hsc
02:26:51 <merijn> hsc is wrought with potential errors still, though
02:26:57 <EvanR> yep
02:27:17 <merijn> funfunctor: Yeah, I really want a more consistent way of marshalling things
02:27:29 <EvanR> each C library is a special snowflake
02:27:50 <merijn> funfunctor: Also, make sure to properly use CInt everywhere instead of Int, the auto-marshalling of Int is filled with lies...
02:29:41 <funfunctor> thx i know
02:30:07 <EvanR> didnt know Int was Storable
02:30:23 <merijn> Things don't have to be Storable to be marshallable
02:30:34 <EvanR> whats marshallable then?
02:30:43 <merijn> That they can be auto converted
02:30:49 <EvanR> in what context??
02:30:55 <merijn> i.e. I can pass Int to foreign imported functions
02:31:11 <EvanR> oh, didnt know you could do that either
02:31:22 <merijn> foreign import ccall "sleep" sleep :: Int -> IO ()
02:31:43 <merijn> Except that will screw you over when Int and CInt have different word sizes :p
02:32:06 <EvanR> sleep :: CUInt -> IO CUInt
02:32:18 <merijn> As I found out when I discovered that 64bit GHC on OSX uses 64bit Int whereas my 64bit C compiler uses 32bit CInt :p
02:32:25 <funfunctor> FFI is Haskells cliff edge of its type system
02:32:39 <funfunctor> "type system, what type system... we are talking to C silly.."
02:32:48 <EvanR> just not having Int available at that spot would be better
02:32:56 <EvanR> funfunctor: C happens to have a type system too ;
02:32:57 <EvanR> )
02:33:06 <funfunctor> lol
02:33:08 <funfunctor> Int
02:33:42 <EvanR> at least haskell has a typed ffi
02:34:07 <funfunctor> will haskell ever get hotswappable code
02:34:08 <EvanR> rather than a void*
02:34:19 <EvanR> funfunctor: theres several libs for that
02:34:23 <merijn> funfunctor: You can already dynamically load/unload code
02:34:24 <funfunctor> void *, isn't that just Int again lol
02:34:33 <merijn> funfunctor: Although that's fairly new
02:34:35 <EvanR> void* is certainly not an int
02:34:38 <funfunctor> in the way Erlang can?
02:34:52 <EvanR> i dont think so
02:34:54 <merijn> funfunctor: No, and I doubt it will anytime soon
02:35:10 <merijn> funfunctor: Since that'd require a rather comprehensive overhaul of the runtime
02:35:12 <funfunctor> EvanR: yea it is, void *p; p + 5;
02:35:21 <merijn> And I don't think there's much interest in doing that
02:35:28 <EvanR> youre confusing pointer arithmetic with integer arithmetic
02:35:44 <merijn> funfunctor: That's wrong, because void* is 64bit on 64bit architectures while int may be 32bit
02:35:46 <EvanR> you are allowed to add and subtract ints from pointers
02:36:03 <EvanR> to get another pointer
02:36:04 <funfunctor> merijn: C compiler isn't going to stop you
02:36:13 <EvanR> itll be promoted
02:36:31 <funfunctor> you can store a pointer to a int and read it back again
02:36:36 <merijn> funfunctor: None of the academic people working on haskell will want to overhaul the runtime, because you can't publish that. So unless someone hacks it in their spare time/industry takes it up I don't think it'll happen
02:36:38 <funfunctor> in fact a function is a int also
02:36:40 <EvanR> not without a cast
02:36:46 <EvanR> no it isnt
02:36:51 <merijn> funfunctor: Those things are undefined behaviour
02:36:51 <funfunctor> thats just syntax sugar
02:37:02 <merijn> You can't even store a function in a void*
02:37:19 <EvanR> its not right to describe explicitly disabling of type safety syntax sugar
02:37:37 <funfunctor> internally its the same
02:37:47 <funfunctor> its all just ints really
02:37:47 <EvanR> yes thats what type systems are there for
02:37:49 <merijn> Not necessarily
02:37:58 <EvanR> so you dont have to know or care about that
02:38:01 <merijn> funfunctor: I know plenty of examples where this is not true
02:38:29 <merijn> funfunctor: Embedded systems often have separate code and data memories, which means that functions are not in the same address space (which is why you can't store functions in void*)
02:38:31 <EvanR> pointer to function not necessarily the same as other pointers, yadda yadda
02:38:46 <funfunctor> merijn: I work on coreboot I know
02:38:52 <merijn> Similarly pointers are not always stored in ints
02:39:09 <merijn> For example, as I mentioned just now ints are 32bit on my machine while pointers are 64bit
02:39:18 <funfunctor> but the MMU make virtual address (virtual ints) does not stop it from being a int
02:39:53 <EvanR> C is in an unfortunately spot where people confuse its abstract semantics with real life implementations
02:39:54 <funfunctor> merijn: actually x64 addressing is 48bit in truth
02:40:03 <funfunctor> instructions are 64bit
02:40:06 <funfunctor> different things
02:40:09 <ibid> C specifies the optional type intptr_t (iirc) as one that can store a (non-function) pointer in a recoverable way
02:40:25 <EvanR> haskell has the luxury of nobody understanding its implementation to be able to make that mistake ;)
02:40:32 <funfunctor> lol
02:40:40 <ibid> the recoverable conversion is not guaranteed for any other integer type
02:40:55 <funfunctor> what I am trying to say is C's type system is "fake"
02:41:03 <ibid> (unless they are big enough, which is implementation defined)
02:41:13 <EvanR> C's type system is there for the same purpose as haskells type system its just less sophisticated
02:41:19 <ibid> funfunctor: that's not a technical term :)
02:41:24 <merijn> ibid: Actually, intptr_t is guaranteed to store function pointers too
02:41:33 <EvanR> both can be disabled when you want them to be (unsafeCoerce)
02:41:40 <funfunctor> ibid: now it is ^^
02:41:45 <LordBrain> i think the language should be made expressive enough that we do not need to link with a c runtime
02:42:02 <merijn> LordBrain: That's not a fundamental limitation
02:42:21 <LordBrain> no idea what you are saying
02:42:25 <merijn> LordBrain: The runtime could easily be replaced with haskell + some assembler bits, but why bother
02:42:30 <ibid> merijn: iirc not, but let me check
02:42:36 <EvanR> easily?
02:42:46 <merijn> EvanR: For some value of easy
02:42:52 <EvanR> its certainly possible
02:42:56 <EvanR> its not a language barrier
02:42:57 * funfunctor shrugs
02:43:00 <merijn> EvanR: I mean: It's not a unsolved problem or anything that's never been done before
02:43:02 <funfunctor> fake C is fake
02:43:11 <merijn> It's just a lot of engineering work for no good reason
02:43:18 <merijn> LordBrain: What would the value of a non-C runtime be?
02:43:31 <EvanR> bragging rights
02:43:34 <KaneTW> dick waving
02:43:40 <KaneTW> too slow
02:43:53 <ibid> merijn: intptr_t handles pointers to void.  function pointers may not be convertible to pointer to void
02:44:08 * merijn gets out the language lawyer book
02:44:17 <ibid> merijn: i just checked the C standard :)
02:44:49 <LordBrain> merijn, why do lowlevel languages exist? why do we have c and why are they making rust etc.. there's still plenty of place for non-garbage collected lowlevel code.
02:45:04 <EvanR> im not sure why they are making rust
02:45:04 <LordBrain> furthermore
02:45:08 <EvanR> thats another story though
02:45:11 <LordBrain> its more pleasant to hack on haskell
02:45:30 <merijn> LordBrain: That's not what I'm asking
02:45:40 <LordBrain> you like c?
02:45:44 <merijn> LordBrain: I'm asking: What motivation do we have to replace the C runtime with something else
02:46:00 <LordBrain> any thing that can be written in haskell, should
02:46:03 <funfunctor> hehe try and run a hello world form cache only using asm and haskell
02:46:04 <merijn> LordBrain: No, but we have a well tested, high performance existing runtime. What reason exists to replace it with something untested
02:46:08 <funfunctor> thats the real test
02:46:19 <merijn> LordBrain: I look forward to your implementation of the runtime :)
02:46:35 <EvanR> funfunctor: you can do it with only asm and the trivially no haskell ;)
02:46:37 <EvanR> does that count
02:46:52 <funfunctor> I wrote a complete hello world that needs no RAM installed using asm+Ada
02:46:57 <tdammers> LordBrain: that's almost as false as it is for most other languages
02:47:10 <EvanR> if some haskell is required, throw in something recognizable as a generational gc or soemthing that doesnt contribute to the hello worlding
02:47:11 <merijn> ibid: I've looked this up before in the past and remembered that intptr_t did function pointers, because why else bother adding a new type?
02:47:40 <merijn> ibid: But I can't find it in the spec right now :\
02:47:48 <merijn> So maybe my memory is fried
02:47:54 <nkar> how do I install dependencies with profiling?  if I run cabal-install --only-dep --enable-library-profiling, a bunch of packages fail with "Perhaps you haven't installed the profiling libraries for package"
02:47:54 <LordBrain> not from an idealist point of view it isnt false... sure if you are limiting yourself to a certain versoin of hte language tdammers, but if you are just out to create and discover the best possible language then it is true whatever you call that language.
02:48:26 <EvanR> LordBrain: the haskell FFI is defined against some C implementation, youre stuck
02:48:37 <merijn> LordBrain: This is similar to the people complaining that the haskell wiki runs on PHP, yet somehow none of the complainers ever have time to reimplement our wiki using haskell
02:48:49 <merijn> EvanR: That will be remedied soon now that we have a JS FFI
02:48:54 <ibid> merijn: you add the type because no other standard type is guaranteed to be big enough to handle object pointers
02:49:11 <LordBrain> why do you call them complainers?
02:49:13 <merijn> EvanR: There's only a very small number of C specific things in there
02:49:15 <ibid> merijn: *no* type is guaranteed to handle function pointers
02:49:26 <ibid> integer type, that is
02:49:32 <LordBrain> they obviously love haskell
02:49:41 <merijn> ibid: void* is guaranteed to handle object pointers, I think you mean it's not guaranteed to hold all integer types
02:49:55 <tdammers> LordBrain: Haskell isn't great at everything, as much as I'd want to believe it
02:49:59 <merijn> LordBrain: I call them complainers because "the haskell wiki should be written in haskell!" is a complaint
02:50:32 <EvanR> hehe how about an idris runtime
02:50:43 <merijn> LordBrain: The pragmatics are: There is a functioning and existing PHP wiki which works fine. Why are you telling people working on more useful stuff to stop what they're doing and write a Haskell wiki?
02:50:50 <ibid> merijn: i mean no other integer type is guaranteed to handle object pointers
02:50:51 <tdammers> and frankly, I think reimplementing things in a different language just because is really really stupid
02:50:53 <merijn> LordBrain: The same goes for the runtime
02:51:19 <LordBrain> i don't like words being placed in my mouth
02:51:24 <merijn> LordBrain: If people think it's that important, I'd be happy to see their new solution and switch, provided it is actually as full-featured as the existing code
02:51:46 <ibid> merijn: and no integer type is guaranteed to handle function pointers. in fact, conversion of object pointers to integers is allowed if the integer type is large enough, but no such guarantee is made for function pointers
02:52:02 <merijn> ibid: I know
02:52:21 <frerich> ibid: Makes you wonder how something like 'dlsym' can ever work correctly.
02:52:22 <ibid> merijn: then what are we arguing about? :)
02:52:23 <merijn> ibid: Oh well, I'll just have to console myself with posix mandating void* can handle all function pointers :)
02:52:36 <merijn> frerich: Because POSIX guarantees more than C does :)
02:52:46 <ibid> frerich: dlsym does not restrict itself to standard c
02:52:47 <tdammers> implementing a wiki from scratch in Haskell would be a better choice than implementing a wiki from scratch in PHP; but that's not the situation. The choice is between "implement a wiki in Haskell from scratch" and "keep the existing, functioning PHP wiki in place"
02:52:48 <merijn> frerich: Such as all function pointers fitting in void*
02:52:53 <EvanR> ibid: i noticed merijn saying the exact same thing as you about 30 minutes ago, i think he forgot
02:53:39 <merijn> ibid: The only thing was that I thought intptr_t could fit function pointers, but that's apparently only when function pointers fit into void* anyway (i.e. posix)
02:53:50 <ibid> merijn: yes
02:53:52 <frerich> merijn: Ah, really? I never knew that's actually mandated by POSIX.
02:54:23 <ibid> merijn, frerich: also, dlsym is written to know the compiler and the standard library, and thus assumes more than just posix also :)
02:57:14 <frerich> ibid: That doesn't seems like a safe thing to do, given that you can use dlsym in a program written in e.g. C to resolve a symbol in a module written in - say - C#.
02:57:43 <frerich> I guess it's a file-format thing.
02:58:31 * hackagebot text-and-plots 0.1.0.0 - EDSL to create HTML documents with plots based on the C3.js library.  http://hackage.haskell.org/package/text-and-plots-0.1.0.0 (andersjel)
02:58:34 <ibid> frerich: true enough. there's the ELF standard and the platform-specific API standards, to which dlsym, the C compiler and runtime, and C# FFI are written against
02:58:38 <d12frosted> Hi everyone!
02:58:51 <funfunctor> EvanR: dumb question but how do I extract the pointer type to pass to the C function out of  the DeviceHandle?
02:59:17 <EvanR> by using this definition of the newtype (or pattern matching in the function argument)
02:59:23 <ibid> frerich: for Linux and BSD, at least. on Windows, i believe there is no such universal standard and you really have to know which C compiler is used (not sure)
02:59:38 <EvanR> newtype DeviceHandle = DeviceHandle { unDeviceHandle :: Ptr Whatever }
02:59:47 <ibid> frerich: s/API/ABI/
02:59:56 <funfunctor> EvanR: oh that, a unwrapper yea
03:00:01 <EvanR> or getDeviceHandle, or getDeviceHandlePointer, or unwrapDeviceHandle
03:00:08 <EvanR> but in the function you can just do
03:00:14 <EvanR> f (Devicehandle ptr) = do
03:01:53 <frerich> merijn, ibid: Interestingly, despite the fact that POSIX apparently mandates that void* and function pointers are convertible it sems that you still have to jump through some loops to be on the safe side. cosine(3) does '*(void **) (&cosine) = dlsym(handle, "cos");' (with 'cosine' being a 'double(*)(double)').
03:02:15 <d12frosted> Is it possible to have data type like `data HasName a = HasName Text a` and use it like: `value = HasName' 12 :: HasName "Age" Int`?
03:02:18 <frerich> I'll shut up with the offtopic talk now. I'm just glad I don't have to work on the runtime of anything :)
03:02:43 <d12frosted> It's a bit dummy syntax, but I use it to show my intention
03:03:12 <shachaf> d12frosted: It sounds like you don't want a value of type Text, but a thing on the type level.
03:03:22 <d12frosted> yeah
03:03:26 <d12frosted> that's it
03:04:27 <d12frosted> shachaf: but I want the values of type (HasName "Age" Int and hasName "Year" Int) be the same
03:04:37 <shachaf> GHC has something called Symbol which might do what you want.
03:04:48 <shachaf> What does it mean for values of different types to be the same?
03:05:22 <EvanR> d12frosted: use a type synonym?
03:05:26 <EvanR> type Age = Int
03:05:29 <EvanR> type Year = Int
03:06:08 <d12frosted> Oh, what I meant is - I want to be able to define functions like f :: HasValue anyText a -> b
03:06:20 <EvanR> er, type Age a = a
03:06:21 <tdammers> d12frosted: I'd go with explicit conversions of either type to a common type
03:06:21 <shachaf> Oh, sure.
03:06:31 <tdammers> and then compare the converted values
03:06:39 <shachaf> Are you sure you want a string there, rather than something more structured?
03:06:45 <d12frosted> EvanR: it's not good, because I still want to access that information as Text. So I also need a function like getName :: HasName name a -> Text
03:06:58 <EvanR> uhg, text ;)
03:07:06 <tdammers> or maybe use "OOP"
03:07:08 <arianvp___> boothead: Are you there?
03:07:08 <tdammers> :P
03:07:10 <d12frosted> shachaf: well, text/string is just an example
03:07:23 <EvanR> use Typeable ;)
03:07:25 <d12frosted> so in general
03:07:33 <shachaf> Well, the type level is different from the value level.
03:07:44 <tdammers> or maybe you want some sort of dynamic typing?
03:07:45 <shachaf> Text doesn't exist there.
03:09:27 <shachaf> You can use some GHC extensions and define: data HasName (s :: Symbol) a = HasName a
03:09:46 <d12frosted> in general it will be something like DataTypeWithValues = DataTypeWithValues TagType_1 TagType_2 ... TypeTag_n ValueType_1 ... ValueType_n, so it can be used at type level as value :: DataTypeWithValues vOfT_1 vOfT_2 ... vOfT_n ValueType_1 ... ValueType_n
03:09:56 <shachaf> And then e.g. getName :: forall s a. KnownSymbol s => T s a -> String; getName _ = symbolVal (Proxy :: Proxy s)
03:10:19 <shachaf> But this is probably asking the wrong question.
03:10:23 <d12frosted> so it's something like fixing values at type level (or how show it be called?)
03:10:39 <shachaf> I don't know how it should be called because I don't understand what it is.
03:10:52 <EvanR> first class tyles
03:11:01 <EvanR> static class variables
03:12:34 <d12frosted> EvanR: have you mentioned Typeable?
03:13:02 <EvanR> yeah but not seriously
03:14:07 <d12frosted> EvanR: just started to read about it
03:14:08 <d12frosted> :D
03:14:26 <EvanR> the proxy thing above is probably closer to what you want
03:14:40 <jameseb> a workaround using phantom types and a typeclass would work, wouldn't it?
03:14:49 <EvanR> yes see the proxy thing above
03:15:32 <d12frosted> EvanR: do you mean this https://hackage.haskell.org/package/tagged-0.2.3.1/docs/Data-Proxy.html by proxy?
03:16:05 <d12frosted> jameseb: oh cool, new thing to learn - phantom types
03:17:00 <jameseb> d12frosted: phantom types themselves aren't hard, it's just understanding when you might use them
03:18:08 <d12frosted> jameseb: phantom types reminds me about that Proxy thing
03:18:32 * hackagebot blaze-markup 0.7.0.0 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.7.0.0 (JasperVanDerJeugt)
03:18:34 <EvanR> d12frosted: maybe you could ask about ways to solve your actual problem
03:19:13 <jameseb> d12frosted: yeah, I think that may be what EvanR was trying to say after I mentioned phantom types
03:19:51 <jameseb> but EvanR is right, there may be a better way to solve the underlying problem
03:20:06 <d12frosted> EvanR, jameseb: a little information about what I am trying to implement. For example I have a record with N fields
03:20:27 <d12frosted> EvanR, jameseb: what I want to do is to simplify serialization / deserialization
03:21:19 <d12frosted> EvanR, jameseb: so instead of making the mapping between fieldName to actual name and back I want to implement records as
03:22:16 <d12frosted> EvanR, jameseb: data Record = Record { field1 :: NamedField "TheField1Name" T1, ... , field2 :: NamedField "TheField2Name" TN }
03:22:32 <EvanR> Read and Show can be automatically derived, for the same of serialization and deserialization
03:22:42 <EvanR> also you can use a tool to derive Binary instances
03:23:20 <d12frosted> Read and Show are derived automatically, but I don't want to use fieldName for serialisation, the fieldName is for developer and not for the user of data
03:23:32 * hackagebot blaze-html 0.8.0.0 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.8.0.0 (JasperVanDerJeugt)
03:24:40 <EvanR> d12frosted: ok. those strings for the field names dont belong in the type
03:25:00 <EvanR> put them in the serializer, deserializer
03:25:59 <d12frosted> EvanR: well, while I understand this, I think that it would be nice to define the fields with serialization name. What I want is really simillar to atributes in C#
03:26:16 <EvanR> what i didnt suggest that
03:26:47 <shachaf> If you want types that have strings associated with them, I already said how to do it above.
03:27:46 <nshepperd> hmm, is it possible to use numeric literals as singleton values, with GHC.TypeLits
03:27:49 <nshepperd> ?
03:28:36 <nshepperd> er, as in I want to do 'foo :: SNat n -> Foo n' and call it with 'foo 36'
03:28:38 <shachaf> That depends on what you mean exactly.
03:28:47 <d12frosted> shachaf: yeah, I will try your solution. But wanted to provide more details on my problem :D
03:29:03 <shachaf> Numeric literals on the value level?
03:29:37 <nshepperd> yes
03:29:47 <d12frosted> EvanR: well, currently that's what I am doing - serialized / deserializer uses associative list for this
03:29:50 <shachaf> You would need to use an existential or something there.
03:30:14 <d12frosted> EvanR: but I was hoping that more interesting solution is available
03:30:21 <EvanR> d12frosted: cool, those are nice and configurable
03:31:43 <nshepperd> well, I want ghc to infer that (36 :: SNat n) implies n = 36
03:32:14 <d12frosted> EvanR: well yes, serializer is really configurable, it also can take a function of type (String -> String) to modify field name (so I can e. g. append something or find for desired name in table).
03:32:28 <shachaf> 36 means fromInteger (36 :: Integer)
03:32:29 <d12frosted> EvanR: as far as I understand it's common way to solve this problem
03:32:35 <shachaf> No GHC extensions change that.
03:32:46 <nshepperd> yeah, I think this probably can't work...
03:32:53 <EvanR> d12frosted: whats the serialization format?
03:33:33 * hackagebot pdfinfo 1.5.2 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-1.5.2 (ChrisDone)
03:33:47 <d12frosted> EvanR: and while I am happy with this in most cases, sometimes I wish to have something a bit simpler (from the point of usage, not internal implementation) for cases like this - when you need to serialize record without providing this associative list. I was also thinking about implementing syntax sugar for this
03:34:04 <d12frosted> EvanR: custom ini-like format
03:34:46 <EvanR> yeah you might even not want record types at all
03:35:07 <EvanR> depending on what can be in the ini format
03:35:46 <EvanR> aeson is also a library to look at for a way to deal with dynamic record serialization
03:35:59 <d12frosted> EvanR: probably you right, but it simplifies mapping between development-only names (fieldName) and ini-file names (like 'the field 1 with $name = the value goes here')
03:36:12 <d12frosted> EvanR: yeah, aeson is awesome
03:36:26 <d12frosted> EvanR: when I need json serialisation - aeson is my choice :D
03:36:36 <EvanR> you could do something similar
03:37:01 <d12frosted> EvanR: because of Aeson a learned a bit about Generics :D
03:37:15 <EvanR> haskell generics?
03:37:39 <d12frosted> EvanR: yes, for deriving
03:38:17 <d12frosted> EvanR: I did some attempts to solve my 'problem' with generics, but couldn't come to simplification of usage
03:38:33 * hackagebot crf-chain1-constrained 0.3.2 - First-order, constrained, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-constrained-0.3.2 (JakubWaszczuk)
03:38:41 <d12frosted> EvanR: still serialisation with function is far more usable
03:39:02 <EvanR> d12frosted: i recently did something like this for work. i wrote a schema language to describe the nested record structure
03:39:18 <EvanR> so the loader/unloader can put the right field names
03:39:26 <EvanR> and tell you where something is fucked up
03:40:16 <EvanR> the schema itself tells it how to serialize and deserialize, you dont write the code for that
03:41:58 <d12frosted> EvanR: similar ways. But how it know how to serialize and serialize?
03:42:10 <d12frosted> EvanR: and it's cools that it says where something if broken
03:42:26 <d12frosted> EvanR: are sources available somewhere?
03:42:32 <EvanR> nope
03:43:01 <EvanR> and i dont know if its applicable to you because i dont know anything about your files
03:43:14 <EvanR> its up to you to discover patterns and exploit them ;)
03:43:29 <EvanR> and where details would get in the way, destroy them ;)
03:43:33 * hackagebot crf-chain2-tiers 0.2.4 - Second-order, tiered, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-tiers-0.2.4 (JakubWaszczuk)
03:44:33 <d12frosted> EvanR: oh, I wanted to check sources just to read them :D To find the ideas I could reuse.
03:44:37 <d12frosted> EvanR: right
03:44:55 <EvanR> that code is closed source and in another language
03:45:10 <EvanR> at a job i dont have anymore
03:45:13 <EvanR> lol
03:45:34 <d12frosted> EvanR: well, anyway, thank you for this conversation. Now I have some things to ckeck and try :D Hope to come to satisfaction :D
03:45:39 <d12frosted> EvanR: lol
03:46:10 <d12frosted> shachaf, jameseb: thank you too, I will try your suggestions as well!
03:52:00 <shachaf> dolio: s/becuase/because/ in your article.
03:54:01 <EvanR> d12frosted: example of the idea, the schema value informs what the structure of the record should be, what a parsed tree would look like, and how to serialize one http://lpaste.net/121024
03:54:56 <osfameron> there is a talk about Elm FRP at DoES Liverpool tomorrow, if anyone's in NW UK
03:55:30 <d12frosted> EvanR: actually this is very simillar to what I want to have! Instead of using Records I just can use some primitives and 'F "field1" Number'!
03:55:48 <EvanR> yes no subrecords ok
03:56:45 <d12frosted> EvanR: great, I inspired me! I will try reuse your idea in my case.
03:58:05 <EvanR> d12frosted: extraneous R in there removed
03:59:17 <cfoch> hello, can somebody tell me how do I read a weekDate in this example. What does each result mean?
03:59:17 <cfoch> http://fpaste.org/189166/14246926/
03:59:38 <EvanR> cfoch: what are you trying to get, Sunday?
04:00:01 <d12frosted> EvanR: it's ok, I got the idea anyway :D
04:00:28 <cfoch> EvanR: Monday, here it is Monday
04:00:35 <EvanR> ok
04:03:03 <EvanR> cfoch: http://lpaste.net/121026
04:03:38 <EvanR> YMMV
04:06:54 <merijn> cfoch: The docs explain what each result is
04:07:04 <EvanR> the continuous 7 day cycle is older than the gregorian calendar, and the julian calendar
04:07:08 <cfoch> EvanR: thanks :)
04:07:39 <EvanR> perhaps the universe was created on a tuesday
04:07:59 <cfoch> merijn: yes, but I think I am misunderstanding the result in my example
04:08:17 <EvanR> cfoch: you have the arguments mixed up btw
04:08:24 <EvanR> its year month day
04:08:56 <merijn> "Invalid values will be clipped to the correct range, month first, then day." <- ouch...
04:09:06 <EvanR> yeah an exception would be nice
04:09:25 <merijn> You mean a maybe/newtype on inputs would be nice...
04:09:30 <merijn> Exception would be awful >.<
04:09:37 <EvanR> meh
04:09:57 <EvanR> i use Int for lots of things whose correct particular values i cant be arsed to prove
04:10:36 <EvanR> a maybe would be awful
04:11:05 <EvanR> that function should be fixed
04:11:32 <cfoch> EvanR... ah yes... first it is the year
04:13:54 <EvanR> merijn: since hes likely to not want to modify the api, an exception would be preferable. from what dibblego showed earlier hes probably not likely to do anything
04:21:22 <cfoch> if I have a data type deriving from Show, can I "show" custom how it will be showed?
04:21:51 <EvanR> you cant control the derived Show instance
04:21:52 <hpc> deriving writes the instance for you
04:22:05 <EvanR> thats what writing it yourself is for
04:22:15 <hpc> you don't want to write a custom instance anyway, Show isn't meant for pretty-printing
04:26:53 <albr> Hi everyone: in SYB is it possible to retrieve the number of parameters to a constructor?
04:27:07 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
04:28:10 <hpc> albr: it's not pretty
04:28:14 <hpc> what are you trying to do?
04:28:50 <albr> hpc: build a OCaml representation of a Haskell algebraic data type
04:29:11 <EvanR> merijn: im not sure i get the core point of that paragraph... Show is for consistently convert to text in a way that could be valid haskell code... *therefore* its only for debugging
04:29:26 <EvanR> seems like two orthogonal, of course true, situations
04:30:15 <Unhammer> getAllTextMatches $ "foo ab cd" =~ "( ab| cd)*$" :: [String]
04:30:15 <Unhammer> [" ab cd",""] -- how can I get [" ab"," cd"] ?
04:30:27 <hpc> albr: oh, you said in SYB
04:30:34 <albr> hpc: for this purpose I actually only need to know whether a constructor has parameters or is constant
04:30:42 <albr> hpc: yes
04:30:52 <hpc> i don't know syb very well
04:30:53 <hpc> uh
04:31:29 * EvanR goes unconscious
04:31:55 <albr> hpc: ok, no problem. were you suggesting another solution?
04:32:02 <shachaf> albr: You mean with Data.Data?
04:32:07 <hpc> albr: at a glance it seems syb doesn't have what you need
04:32:11 <hpc> but yeah, Data.Data has it
04:32:14 <albr> shachaf: yes
04:32:19 <hpc> get the constructor you want, then constrFixity :: Constr -> Fixity
04:32:34 <shachaf> Fixity?
04:32:40 <albr> hpc: doesn't that say whether it's infix or prefix?
04:32:43 <hpc> doh
04:32:57 <albr> there is one option to get the fields
04:33:02 <hpc> constrFields
04:33:08 <albr> but that only works when you name your fields
04:33:27 <hpc> huh
04:33:36 * hackagebot wai-handler-launch 3.0.0.3 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-3.0.0.3 (MichaelSnoyman)
04:33:38 * hackagebot wai-websockets 3.0.0.5 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-3.0.0.5 (MichaelSnoyman)
04:33:39 <albr> data T = T1 String | T2 { a:: String, b:: Int }
04:33:59 <albr> in that case T1 has no fields, while T2 has ["a", "b"] as fields
04:34:59 <hpc> not sure then, you now know more about it than i do
04:35:07 <hpc> i try and avoid metaprogramming
04:35:15 <albr> :)
04:35:28 <albr> Ok thanks for the hints anyway
04:36:03 <albr> I bumped my head on it this weekend, hopefully I'll get to a solution
04:38:07 <shachaf> albr: I think you can do it.
04:38:52 <albr> shachaf: I think I was almost there, but my program does not compile
04:38:55 <shachaf> > getConst $ gfoldl (\(Const n) _ -> Const (n+1)) (\_ -> Const 0) ('a','b','c') -- something like this
04:38:57 <lambdabot>  3
04:40:56 <shachaf> That's a bit hacky but you can write all sorts of other things along those lines. The point is that the information is there.
04:42:01 <shachaf> > length . execWriter $ gmapM (\x -> tell [1] >> return x) ('a','b','c')
04:42:02 <albr> shachaf: Ok, but the problem there is that I need an instance of that constructor, I think
04:42:02 <lambdabot>  3
04:42:21 <shachaf> Doesn't Data.Data let you make one?
04:42:37 <albr> with fromConstr
04:43:08 <albr> but I could not compile my code for some reason
04:43:37 * hackagebot wai-extra 3.0.4.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.4.3 (MichaelSnoyman)
04:44:02 <albr> because the instance of gmapM could not be determined when I built an instance with fromConstr
04:44:15 <shachaf> You probably need to specify the type.
04:45:04 <shachaf> This all seems very roundabout.
04:48:37 * hackagebot warp 3.0.9.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.9.2 (MichaelSnoyman)
04:51:09 <albr> shachaf: http://lpaste.net/8745805895838990336 this fails to compile for example
04:51:59 <shachaf> albr: It looks like you need to specify a type rather than have it work with an arbitrary Constr.
04:52:48 <albr> shachaf: but what type do I specify? it can be any type that derives Data
04:53:11 <shachaf> I don't think Constr works that way.
04:53:37 * hackagebot haxr 3000.10.4.2 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.10.4.2 (BrentYorgey)
04:53:40 <shachaf> It's a bit of a strange type.
04:54:14 <shachaf> Look at the information that's available: https://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-Data.html#line-472
04:54:33 <shachaf> Without the Data instance there's no way to answer your question.
04:55:28 <albr> shachaf: ok but I can retrieve the DataType from Constr
04:55:34 <albr> does that help?
04:55:52 <shachaf> All the DataType gives you is a tycon (String) and a DataRep
04:56:03 <shachaf> And all the DataRep gives you is a bunch of Constrs.
04:56:39 <albr> so it's circular, I cannot retrieve the type
04:57:31 <albr> but what if I have the type as a parameter to numArgs?
04:57:41 <shachaf> Not from a Constr alone.
04:57:47 <shachaf> In that case you can do it.
04:58:24 <shachaf> Just specify the type of inst.
04:59:45 <albr> shachaf: how? can I have type parameters to numArgs that I can are bound when I specify the type of fromConstr c?
05:00:34 <shachaf> numArgs :: forall d. Data d => Proxy d -> Constr -> Int; numArgs c = ... (fromConstr c :: d)
05:00:37 <shachaf> Maybe something like that.
05:00:42 <shachaf> (That uses ScopedTypeVariables.)
05:01:09 <albr> shachaf: ok thanks I'll try it
05:02:35 <albr> shachaf: it works! thanks a lot! :)
05:13:19 <bitonic> is there any way to use CPP with hsc2hs?
05:17:55 <kvelicka> Hello. Is there a way to set up cabal for a specific project so that it uses a version of ghc that I've got compiled rather than the one that I have installed?
05:20:12 <mpickering> yes kvelicka
05:20:51 <mpickering> make a "cabal.config" with "with-compiler: ghc-7.11.20150118"
05:21:27 <mpickering> you might also need to specify the package-db and with-hc-pkg
05:22:15 <kvelicka> do I set the path to the head ghc in cabal.config as well?
05:23:33 <merijn> kvelicka: Cabal will just use whichever GHC is first in your path
05:23:48 <merijn> kvelicka: You can just change your path and it will just work
05:24:01 <merijn> Assuming your compiled and installed GHC are different versions
05:24:11 <merijn> Since GHC has a per-version database of packages anyway
05:26:36 <kvelicka> yep, I've got 7.8 installed and a clone of the latest version just compiled
05:35:58 <VELVETDETH> Hi, anybodu here?
05:36:13 <VELVETDETH> It's my first experience of IRC
05:36:25 <VELVETDETH> Quite interesting ...
05:36:39 <tdammers> plenty of people here
05:36:45 <tdammers> see the /who
05:37:12 <VELVETDETH> wow amazing
05:37:27 <speak> Oops :D
05:37:37 <stool> What's max sendq?
05:38:10 <speak> May've done /who in the status window or something?
05:40:46 <zomg> /names is probably better to avoid that... :D
05:41:08 <VELVETDETH> Hi so what are people used to talk here?
05:41:46 <tdammers> VELVETDETH: how about you just lurk for a while? questions like these will mostly answer themselves...
05:42:11 <VELVETDETH> Oh sorry ... ;p
05:42:15 <byorgey> VELVETDETH: in here we talk about the Haskell programming language: http://www.haskell.org
05:42:37 <VELVETDETH> Yeah thanks, and I'm a Haskell programmer
05:42:49 <byorgey> great, welcome =)
05:43:06 <tdammers> (no offense btw... by all means feel very welcome)
05:43:32 <SegmentFault> wow
05:43:56 <SegmentFault> I suppose most of the haskell programmer are just for fun..
05:46:51 <Grisha> hi, I've got a function in a where-clause, its type depends on the type of the enclosing function. Is there a way to declare the type of the nested function in terms of the type of the enclosing one?
05:47:13 <mauke\> yes, depending on what exactly you mean
05:47:26 <mauke\> do you have an example?
05:47:27 <ab9rf> Grisha: can yoi provide a code snippet?
05:47:29 <ab9rf> @paste
05:47:30 <lambdabot> Haskell pastebin: http://lpaste.net/
05:47:32 <Grisha> wait a sec
05:49:28 <lpaste> Velvetdeth pasted “TryWithThePasteBin” at http://lpaste.net/121027
05:50:17 <Grisha> hm
05:50:27 <Grisha> it's difficult to formulate a simple example
05:50:30 <Grisha> :-)
05:50:38 <KaneTW> it's fine if it's complex
05:51:18 <Grisha> http://lpaste.net/121028
05:51:21 <Grisha> something like this
05:51:35 <Grisha> I need to figure out the type of nested
05:51:51 <Grisha> nested operates on a MyType field of x
05:52:07 <rui> Ia m doing cabal install pulse-simple, and getting an ExitFailure in the configure step, without any information
05:52:17 <rui> and I can't find the repo on github
05:52:37 <rui> No hope?
05:53:36 <mauke\> Grisha: that needs the ScopedTypeVariables extension
05:53:49 <Grisha> mauke thanks
05:53:54 <mauke\> Grisha: and then enclosing :: forall a b c. MyType a b -> c
05:54:06 <mauke\> then 'a' should be available in the 'where' clause
05:54:18 <Grisha> mauke, I will look into this
05:54:26 <Grisha> mauke, thanks again for a quick solution
05:55:00 <Grisha> mauke, is it an example of bad smelling code if I need to do that?
05:55:23 <rui> (forget it)
05:56:07 <mauke\> Grisha: no
05:56:15 <mauke\> this kind of thing just happens sometimes
05:56:30 <nshepperd> nah, use of ScopedTypeVariables is fine
05:57:14 <Grisha> mauke, nshepperd is there a way to check what type of nested ghci has derived? like setting a breakpoint and lookig at its type?
05:57:28 <nshepperd> I really do hope STV gets included in the haskell report some day soon
05:57:34 <mauke\> oh, good question
05:57:54 <Grisha> I tried to set a breakpoint right on the line with nested, but :t nested wouldn't work
05:59:21 <mauke\> which version of ghc are you using?
06:00:12 <Grisha> 7.8.3
06:00:54 <mauke\> then you should have holes
06:01:08 <mauke\> I've never used them, though :-)
06:01:19 <mauke\> what happens if you add '_ = [nested, _]' to your 'where' block?
06:01:29 <Grisha> I think I found something
06:01:40 <Grisha> lexically scoped type variables
06:01:56 <Grisha> oh, it's just what you said
06:02:06 <Grisha> -XScopedTypeVariables
06:02:14 <chrisdone> ghci-ng can determine types of source spans
06:02:16 <mauke\> I was looking at https://wiki.haskell.org/GHC/Typed_holes
06:03:01 <chrisdone> Grisha: https://github.com/chrisdone/ghci-ng/#type-info
06:03:45 <Grisha> chrisdone, thanks a lot, I will look into this
06:04:41 <nshepperd> also, if you happen to use emacs, ghc-mod has a key combination that will tell you the inferred type of whatever is selected
06:05:08 <chrisdone> step 1: get ghci-mod working
06:06:11 <Grisha> have to switch to emacs for that first
06:06:17 <Grisha> used to use it, but not anymore
06:07:37 <nshepperd> oh well
06:08:24 <chrisdone> ghc-mod works for vim too iirc
06:08:43 <deMoivre> Alright...I'm trying to learn Haskell from learnyouahaskell.com
06:09:17 <deMoivre> and everything was going quite well, until I tried to implement some simple looping
06:09:18 <Grisha> chrisdone, will check it
06:09:35 <deMoivre> I can't seem to find any resource on the web that can explain how to do what I'm trying to do in Haskell
06:09:46 <Grisha> chrisdone, I'd first go for the scoped type variables
06:10:07 <deMoivre> To start, I just want a double nested loop that will print a single 'X' character to the screen each time the innermost loop executes
06:10:11 <chrisdone> holes are also handy there
06:10:23 <chrisdone> they act like `undefined' but also print out their type
06:10:30 <deMoivre> and then increment some variables...which I know, strictly speaking, can't be done in Haskell
06:10:35 <deMoivre> I know this has to be done via recursion
06:10:54 <deMoivre> I just don't understand how to convert from a procedural loop to whatever the equivalent is in Haskell
06:10:59 <chrisdone> Grisha: so if you have f and x and don't know how to combine them, you can write: f (_hmm x) and _hmm will show you the type of thing you need to get from x to f's expected input type
06:11:20 <deMoivre> Can anyone point me in the right direction?
06:11:30 <simg> deMoivre: fellow noob here. check out using fmap to interate over lists
06:11:36 <Grisha> chrisdone, is _hmm a kind of magic word?
06:11:50 <deMoivre> simg: Do you have a URL for a good page on that technique?
06:11:52 <chrisdone> Grisha: _ or _foo is a hole. you can use _ but _naming also works
06:12:03 * chrisdone tends to name out of habit
06:12:03 <Grisha> chrisdone, I see
06:12:38 <Grisha> chrisdone, i'm playing with some hidden markov model simulations, so there are a lot of hmm variables in my code ;-)
06:12:38 <Mystyy> Anyone intrested in starting a learning group based on hacking ?
06:12:39 <chrisdone> > map _whatsthis [1..] :: [Char]
06:12:40 <lambdabot>  Found hole ‘_whatsthis’ with type: a0 -> GHC.Types.Char
06:12:41 <lambdabot>  Where: ‘a0’ is an ambiguous type variable
06:12:44 <chrisdone> like that
06:12:58 <chrisdone> > map _whatsthis [1 :: Int ..] :: [Char]
06:12:58 <Grisha> chrisdone, I see
06:12:59 <lambdabot>  Found hole ‘_whatsthis’ with type: GHC.Types.Int -> GHC.Types.Char
06:13:24 <ab9rf> deMoivre: most of the time iteration in haskell is achieved by mapping over a list or something that is similar to a list
06:13:42 * hackagebot rest-client 0.5.0.0 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.5.0.0 (AdamBergmark)
06:13:44 * hackagebot rest-core 0.35 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.35 (AdamBergmark)
06:13:46 * hackagebot rest-gen 0.17.0.0 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.17.0.0 (AdamBergmark)
06:13:56 <Grisha> deMoivre, what's the ultimative point of printing X on the screen?
06:15:42 <deMoivre> Grisha: Well, that's just one step along the way to the final goal
06:15:48 <ab9rf> deMoivre: what's the final goal?
06:16:05 <deMoivre> I'm trying to port a Mandelbrot Set generator benchmark from Java to Haskell
06:16:29 <Grisha> deMoivre, separate your data and your graphics
06:16:36 <ab9rf> yeah, really
06:16:52 <deMoivre> I've ported it already to Go, Fortran, Ada, C & C++, and I've done it many times in BASIC and Pascal as well
06:16:54 <Grisha> your function should return a collection of (x,y) coordinates of the dots in the Mandelbrot set
06:17:04 <chrisdone> deMoivre: those languages are all the same
06:17:07 <deMoivre> I ran up against the same issue when I tried to learn Chicken Scheme and Clojure
06:17:19 <Grisha> deMoivre, think about how you would generate a list/array/vector of coordinates first
06:17:20 <chrisdone> it's like converting between spanish and italian. easy
06:17:22 <deMoivre> I can't figure out how to convert my procedural looping idioms into recursive functional ones
06:17:25 <ab9rf> heh, i'm not surpised
06:17:29 <chrisdone> haskell is arabic =p
06:17:44 <chrisdone> deMoivre: do you know how to use the IO library?
06:17:56 <ab9rf> chrisdone: finnish, or that one aleutian that's agglutinative to the max
06:18:05 <deMoivre> chrisdone: I completely agree with your linguistic analogy ;)
06:18:10 <ab9rf> chrisdone: arabic still has a fairly typical SVO structure
06:18:11 <deMoivre> chrisdone: Not really, no.
06:18:16 <funfunctor> EvanR: you were completely right my binding is much easier to work with now without the StateT monad
06:18:21 <ab9rf> chrisdone: just a different alphabet
06:18:25 <deMoivre> chrisdone: I've hacked out a few things based on examples from Learn you a Haskell
06:18:37 <deMoivre> I'm used to looping coming much, much earlier in the learning process
06:18:37 <tdammers> I think vietnamese would be a better analogy
06:18:41 <deMoivre> it's fundamental to getting anything done
06:18:43 * hackagebot rest-happstack 0.2.10.7 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.10.7 (AdamBergmark)
06:18:45 * hackagebot rest-snap 0.1.17.17 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.17 (AdamBergmark)
06:18:47 * hackagebot rest-types 1.13 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.13 (AdamBergmark)
06:18:49 * hackagebot rest-wai 0.1.0.7 - Rest driver for WAI applications.  http://hackage.haskell.org/package/rest-wai-0.1.0.7 (AdamBergmark)
06:18:53 <tdammers> same alphabet, but radically different grammar
06:19:07 <tdammers> but then, all analogies are bad, so there goes that
06:19:12 <deMoivre> yep
06:19:16 <rom1504> looping ? you mean recursion ?
06:19:31 <deMoivre> rom1504: Well, that's how looping idioms are implemented in Haskell...so...yes
06:19:38 <deMoivre> (or any other functional language, apparently)
06:19:38 <tdammers> haha
06:19:41 <tdammers> well
06:19:52 <deMoivre> I managed to create a 'for' function in Scheme that was directly equivalent to a C-style loop
06:20:04 <chrisdone> deMoivre: so you know how to sequence two IO values so that when you execute it they run in sequence, right?
06:20:17 <deMoivre> and I was criticized by my architect at Softlayer/IBM for not doing it the 'real' way in Lisp
06:20:23 <Grisha> deMoivre, generate the data first, than think about how to plot it
06:20:23 <tdammers> you could argue equally well that looping is how mapping, filtering, and folding are typically implemented in imperative languages :D
06:20:28 <ab9rf> deMoivre: and did your scheme version have decent performance? :)
06:20:39 <deMoivre> chrisdone: No, I suppose not.  If I've done that, I'm not aware that your description of it fits what I've done.
06:20:54 <chrisdone> deMoivre: e.g. print 1 >> print 2
06:21:15 <deMoivre> Grisha: I don't want the data to be generated first and then plotted...I want to see it being generated as it's plotted, like all the other languages I've implemented this in.
06:21:19 <deMoivre> real-time IO
06:21:20 <chrisdone> deMoivre: or the syntactic convenience for the same thing: do print 1; print 2
06:21:35 <deMoivre> tdammers: re: mappping/filtering/folding -- certainly
06:21:44 <boj> deMoivre: i think you will achieve that, he's suggesting you separate responsibilities first
06:21:44 <deMoivre> ab9rf: It sure did.
06:21:52 <ab9rf> mandelbrot is just "compute here", right, no benefit to storing "nearby values"
06:21:52 <deMoivre> ab9rf: (Have decent performance.)
06:22:21 <Grisha> deMoivre, mixing generating data and plotting would make you to drag the IO type all the way through your otherwise purely mathematical code
06:22:25 <ab9rf> i'm trying to remmeber if there's any "special tricks" to getting a fast mandelbrot
06:22:30 <deMoivre> chrisdone: How does whitespace and/or newlines (\n) interact with something like: do print 1; print 2    ?
06:23:13 <deMoivre> ab9rf: I think the answer to your question is 'yes', since the core algorithm is embarrassingly parallelizable
06:23:25 <cfoch> is there a way to get a sublist from a start_index to an end_index ?
06:23:29 <ab9rf> deMoivre: that's what i though too
06:23:29 <Grisha> by the way, if you google "mandelbrot set haskell'', the first link is a nice solution
06:23:36 <cfoch> is there a function, I mean...
06:23:40 <deMoivre> ab9rf: I'm not worried about getting a speed-optimized one.  That can come later.
06:23:47 <ab9rf> deMoivre: it's been two decades since i looked at it
06:23:49 <deMoivre> I didn't bother to optimize the algorithm in Ada or Fortran, either
06:23:49 <grohne> is there a typeclass for t :: * -> * that allows constructing all elements of t () up to a certain size? construct :: Int -> [t ()]
06:23:57 <ab9rf> i don't even remember the definition anymore
06:23:57 <deMoivre> I'm just trying to get the basic thing implemented correctly
06:23:59 <tdammers> isn't the core algorithm basically just a matter of Position -> Bool?
06:24:05 <ab9rf> tdammers: basically, yes
06:24:11 <ab9rf> Complex -> Bool
06:24:24 <ab9rf> since it's technically defined on complex numbers
06:24:24 <deMoivre> Grisha: But I don't want the solution handed to me...I'm trying to learn Haskell.
06:24:32 <Grisha> deMoivre, I see
06:24:33 <deMoivre> Grisha: I'm trying to learn it somewhat correctly, in the right order
06:24:38 <deMoivre> So I can actually use this tool =)
06:24:40 <chrisdone> deMoivre: do x; y is equivalent to writing
06:24:40 <chrisdone> do x
06:24:40 <chrisdone>    y
06:24:45 <ab9rf> and you'll just do a comprehension over some region of the complex plane
06:24:46 <deMoivre> Haskell is attractive because of the power it offers
06:24:48 <deMoivre> purity and such
06:24:59 <tdammers> so anyway
06:25:12 <deMoivre> tdammers: Yes, although I do bother to split it out into 16 or so return values in some of the languages I've done this in
06:25:19 <Grisha> deMoivre, I think that separating pure code and IO is a part of ``correct'' programming in Haskell
06:25:27 <ab9rf> 16 return values?
06:25:39 <tdammers> yeah, you can output a double or so for nicer colors at the edges
06:25:47 <deMoivre> I.E., instead of returning just 'O' or 'X', it'll return from the list ['O','X','$','@','#'...(whatever)...]
06:25:59 <deMoivre> Grisha: I do understand that; yes.
06:26:02 <ab9rf> tdammers: yeah, many implementaitons return the number of iterations as a way to generate colors
06:26:07 <deMoivre> ab9rf: up to, yeah.  I've done it with 4 in a few
06:26:17 <tdammers> but at the core, you want a function mandelbrot :: Complex -> Double -- or something like that
06:26:20 <deMoivre> ab9rf: Yes, of course.  I've been doing that since I was a child =)
06:26:27 <deMoivre> What I'm doing right now is just a certain specification
06:26:35 <ab9rf> deMoivre: likely i've been doing it since before you were born :)
06:26:40 <deMoivre> Would it help anyone if I showed y'all the Go code for this?
06:26:41 <deMoivre> or the Java code?
06:26:50 <tdammers> and then on one end, a concern is converting screen coordinates into Complex
06:26:54 <deMoivre> ab9rf: I was doing this in 1986, I think
06:26:56 <deMoivre> or 1987
06:27:02 <chrisdone> ab9rf: stop that
06:27:07 <boj> deMoivre: it's been hard for me, but forget your imperative examples, they don't really apply
06:27:08 <Grisha> mandelbrot :: Complex -> [Complex] rather
06:27:08 <tdammers> on the other end, you want to map the output values onto pixel colors (or ascii characters)
06:27:22 <Grisha> since it's primed by a complex seed
06:27:22 <deMoivre> boj: I know that they can't be translated directly
06:27:34 <deMoivre> tdammers: ASCII characters, yes
06:27:39 <Grisha> returning an infinite list
06:27:52 <tdammers> deMoivre: yes, but you want to keep that concern separate
06:28:23 <tdammers> and finally, you need to map the combination of these three functions over your screen grid
06:28:24 <deMoivre> https://bitbucket.org/aquishix/mandelbenching-go/src/2e508eebb4a551a06254ae4baaa3b65fb7a4ce39/mandelbench.go?at=master
06:28:27 <deMoivre> there's the Go code
06:28:56 <deMoivre> https://bitbucket.org/aquishix/mandelbenching-c/src/f9ee6b5586589f75108503ee3ee6af59bc0e4fdb/MandelBench.cpp?at=master
06:28:58 <Grisha> oops, completely missed the whole point
06:29:03 <deMoivre> That's roughly equivalent C++ code
06:29:15 <deMoivre> Grisha: I'm missing the whole point?
06:29:36 <tdammers> deMoivre: your C++ code at least doesn't properly separate those concerns
06:29:45 <boj> deMoivre: maybe think of it as a two phase process.  a) computation, and b) IO to display said computation
06:30:01 <Grisha> deMoivre, sorry, I was talking about myself - I misread the definition of the Mandelbrot set
06:30:06 <deMoivre> boj: But as I said, I want this to display the characters as they're being computed
06:30:18 <boj> deMoivre: ok, have you written the computation code first?
06:30:21 <tdammers> deMoivre: that's going to happen automatically
06:30:30 <tdammers> at least if you don't force strictness
06:31:32 <deMoivre> http://play.golang.org/p/3bPDVGNW7W
06:31:43 <deMoivre> I adjusted a few things so you can see it on golang.org
06:31:52 <tdammers> > let f x = if even x then "<" else ">" in map f [0..] -- try this in GHCI
06:31:53 <chrisdone> deMoivre: your go example is easily convertible to haskell. have you tried something like a loop to print the numbers 1 to 10?
06:31:54 <lambdabot>  ["<",">","<",">","<",">","<",">","<",">","<",">","<",">","<",">","<",">","<"...
06:32:09 <tdammers> it'll keep printing things as they are computed
06:32:16 <deMoivre> chrisdone: I think I've managed to do exactly that so far, yes.
06:32:24 <deMoivre> But this is a tripled-nested loop
06:32:26 <chrisdone> deMoivre: can i see?
06:32:32 <deMoivre> which seems quite a bit trickier to me at my level
06:32:39 <deMoivre> chrisdone: http://play.golang.org/p/3bPDVGNW7W ?
06:32:41 <deMoivre> I just pasted it
06:32:46 <boj> your haskell code
06:32:47 <chrisdone> your haskell code of a loop
06:32:53 <deMoivre> oh
06:32:59 <deMoivre> yes..let me dig up that chunk of code
06:32:59 <deMoivre> brb
06:34:59 <deMoivre> http://pastebin.com/DDb7FuSN
06:35:03 <deMoivre> It's not compiling right now
06:35:30 <chrisdone> deMoivre: what's the type of putStrLn?
06:35:30 <deMoivre> I think I just fixed it, though
06:35:49 <funfunctor> I learned me a lesson today! lifting is bad in the bigger picture of things.
06:36:02 <deMoivre> well..that would be...
06:36:08 <chrisdone> funfunctor: do u even lift :: m a -> t m a?
06:36:09 <deMoivre> String -> IO ()
06:36:27 <chrisdone> deMoivre: okay. you fixed it or not?
06:36:38 <funfunctor> chrisdone: both my I's and O's bro
06:36:39 <deMoivre> almost
06:36:41 <deMoivre> it compiles and runs
06:36:42 <tdammers> funfunctor: why? because it obscures detailed type information?
06:36:45 <deMoivre> almost correctly, but not quite
06:37:11 <Grisha> thanks a lot again!
06:37:13 <Grisha> bye
06:37:13 <funfunctor> tdammers: monad transformers are hard to work with
06:37:22 <chrisdone> deMoivre: what's wrong with it?
06:37:28 <deMoivre> http://pastebin.com/j5E9Qg0D
06:37:30 <tdammers> funfunctor: hmm, yes, kind of
06:37:31 <funfunctor> tdammers: and probably a whole bunch of other reasons
06:37:39 <deMoivre> It's executing putStrLns, but they're blank
06:37:43 <deMoivre> I'm not seeing the numbers
06:38:03 <deMoivre> or characters, rather
06:38:06 <funfunctor> tdammers: you end up with one big gaint fat monad, Yes/No button of the future
06:38:12 <deMoivre> but they are low in the ASCII table...hmm
06:38:15 <deMoivre> what was I thinking?
06:38:59 <deMoivre> I was thinking of show or tell or something like that, I think
06:39:02 <deMoivre> not chr
06:39:13 <tdammers> funfunctor: well, it depends... if you're dealing with problems that lend themselves to an imperative solution, then building a monad stack that provides exactly the environment that the imperative minilanguage is supposed to access isn't such a terrible idea IMO
06:39:25 <tdammers> *if* the imperative minilanguage approach is the right one, that ids
06:39:27 <tdammers> *is
06:39:54 <funfunctor> tdammers: i'm sure they have their place of course
06:41:00 <funfunctor> tdammers: I was just saying in the bigger picture
06:41:05 <tdammers> yes
06:41:07 <tdammers> certainly
06:41:30 <tdammers> I'd say about 50% of my haskell-related brain wrecking is monad transformer induced
06:42:41 <deMoivre> http://pastebin.com/uw82Es8A
06:42:43 <deMoivre> I got it to work
06:42:49 <deMoivre> just the simple counting from 10 to 1
06:43:04 <deMoivre> I'm now the equivalent of a 2-year-old in Haskell
06:43:25 * chrisdone gives deMoivre a lollypop
06:43:27 <funfunctor> tdammers: good to know i'm not the only one!!!!
06:43:44 <deMoivre> chrisdone: Ok...where do I go from here?
06:43:48 <deMoivre> I don't see what the next step is
06:43:55 <funfunctor> deMoivre: lift only little tiny monads :)
06:44:29 <funfunctor> so what are gonads?
06:44:40 <funfunctor> is that a comonad of some kind?
06:44:46 <agocorona> tdammers:  a monad with some important effects included could be a fantastic platform for many purposes
06:44:55 <deMoivre> Sounds like an implement of monads in Golang
06:44:58 <tdammers> agocorona: yes, sure
06:45:15 <quchen2> deMoivre: STOP. Save that source code. Keep it in a folder you protect carefully. Back it up regularly. Come back to it in a month and see how much you've learned. Come back in six months and it'll give you a warm fuzzy feeling of nostalgia.
06:45:25 <zomg> ^
06:45:37 <zomg> I have a screenshot of my first website somewhere
06:45:39 <chrisdone> deMoivre: how about writing something that prints 100 rows in two nested loops? :)
06:45:41 <quchen2> deMoivre: My biggest regret with Haskell so far is that I lost my beginner's solution to making the Collatz tree.
06:45:44 <tdammers> agocorona: that's what I end up doing often enough
06:45:44 <zomg> but rather than nostalgia, it makes me terrified
06:45:45 <zomg> lol
06:45:48 <funfunctor> https://www.youtube.com/watch?v=dkZFtimgAcM
06:45:49 <quchen2> It was *awful*. I miss it a lot.
06:46:03 <deMoivre> quchen2: Alright.  =)
06:46:05 <chrisdone> my first haskell program was a connect4 solver. it was also awful
06:46:17 <deMoivre> I still have some of my GWBASIC code from the 80s
06:46:23 <boj> that is funny to hear.  save your beginner code
06:46:26 <chrisdone> i think i spent a week mostly trying to get it to compile
06:46:26 <deMoivre> I rescued it from rotting floppies a decade ago or so
06:46:40 * quchen2 has a "playground" folder in the Haskell source root for that very reason
06:47:01 <agocorona> tdammers:  yes, and this repetition of the same process again and again with transformers means that may be some inmaturity in the Haskell  toos
06:47:11 <zomg> oo here it is
06:47:12 <agocorona> tools
06:47:12 <zomg> http://jjh.fi/p/asd/ff/firstsite.jpg
06:47:30 <quchen2> deMoivre: I'm a bit younger, but I recently saved my old VB6 sources. I tested for odd-ness by dividing by 2 and checking whether the resulting string ended in ",5" (comma because of German locale).
06:47:31 <deMoivre> I still have some of my web programming from the mid 90s
06:47:34 <deMoivre> like 1996-1997
06:47:34 <agocorona> (IMHO)
06:47:38 <deMoivre> not my absolute first, though
06:47:53 <deMoivre> quchen2: Are you sure?  I'm only 33 years old.
06:48:00 <zomg> Yeah I'm reasonably sure these were my first pages I wrote in html
06:48:04 <tdammers> agocorona: agree, at least a bit
06:48:06 <zomg> I think I may have fiddled with some wysiwyg editors before that tho
06:48:10 <quchen2> deMoivre: 27
06:48:14 <deMoivre> ah
06:48:19 <tdammers> btw, one of my earliest Haskell artifacts: https://bitbucket.org/tdammers/notator/commits/41b9fd79783ccd77852690641c3048a7f32596e3
06:48:26 <quchen2> 6 years is the difference between no internet and internet :-D
06:48:50 <zomg> I have some awful PHP scripts I wrote when I was a major scrublord too
06:48:51 <zomg> =)
06:49:28 <tdammers> I think I have some of my old C games around somewhere
06:49:41 <deMoivre> I think I lost all of my Pascal code
06:49:50 <deMoivre> that's the only language that I think I've lost every remnant of it
06:49:53 <deMoivre> well...that and Logo
06:49:59 <quchen2> Delphi?
06:50:05 <deMoivre> which I think, in some sense, was the first Lisp dialect I ever coded in
06:50:12 <deMoivre> I never coded in Delphi..just straight old Pascal in DOS
06:50:14 <tdammers> mmmh, pascal
06:50:18 <zomg> Somehow I have a DOS .bat file text game that an old friend made back in elementary school
06:50:22 <tdammers> I probably have some of that somewhere still, too
06:50:24 <zomg> I made some too but I don't have any of those left
06:50:28 <deMoivre> On my 10MHz XT or 40MHz 386-SX, one or the other
06:52:16 <chrisdone> d'aw
06:52:31 <chrisdone> all my old pastes in the irc log are on the old-old hpaste
06:52:38 <chrisdone> gone forevar
06:56:07 <deMoivre> https://bitbucket.org/aquishix/haskell-explorations/src/75775aa1a06d22c862548ee55003ba3f83bd90b0/mandel4.hs?at=master
06:56:15 <deMoivre> ok, it's committed and pushed, quchen2
06:56:25 <deMoivre> moving on...
06:57:02 <deMoivre> chrisdone: I don't know how to do a nested loop like that
06:57:05 <deMoivre> I've already tried and failed
06:57:14 <deMoivre> I can show you what my failed attempt looks like, if you want
06:57:17 <chrisdone> quchen2: this was me *cringe* http://ircbrowse.net/selection/haskell?title=Conversation&events=3529724,3529725,3529726,3529727,3529728,3529729,3529730,3529731,3529732,3529733,3529734
06:57:27 <chrisdone> demoivre: sure
06:57:33 <tdammers> deMoivre: you understand how to write a one-dimensional loop, right?
06:57:48 <tdammers> map f [1..iteration] -- or sth like that
06:58:06 <deMoivre> tdammers: I've only done it this way: http://pastebin.com/uw82Es8A
06:58:06 <deMoivre> so far
06:58:26 <tdammers> deMoivre: Ah, right.
06:58:35 <chrisdone> but then this is amusing http://ircbrowse.net/selection/haskell?title=Conversation&events=3529809
06:58:41 <tdammers> deMoivre: ok, now separate the loop body out, and make it an argument to your "loop" function
06:58:43 <chrisdone> back when Gentle was the Haskell book to get =p
06:59:08 <tdammers> deMoivre: such that you can pass arbitrary bodies to "loop", instead of hard-coding the body in
06:59:31 <tdammers> deMoivre: can you do that?
07:00:26 <deMoivre> tdammers: That's exactly what I'm trying to figure out...
07:00:39 <deMoivre> I saw some examples online and they seemed to be using curly braces and semicolons
07:00:44 <deMoivre> but I just couldn't seem to get the syntax right
07:00:50 <deMoivre> and I'm doing all of this in vim
07:00:55 <chrisdone> lol
07:01:04 <deMoivre> and I don't even have a syntax highlighting module in vim for Haskell yet, so this is a pretty 1970s experience
07:01:09 <chrisdone> <deMoivre> and I'm doing all of this in vim!! can you believe i'm using this crap?
07:01:13 <deMoivre> (even though Haskell didn't exist in the 70s ;) )
07:01:19 <chrisdone> =p
07:01:28 <tdammers> I use vim too
07:01:33 <boj> i challenge you to try ed instead
07:01:33 <xnull> i, too, use vim
07:01:39 <tdammers> so, not an excuse
07:01:39 <boj> just to make your haskell learning more interesting
07:01:40 <ab9rf> > i've never found syntax highliting that useful
07:01:41 <deMoivre> boj: I reject that challenge.  ;)
07:01:42 <lambdabot>  Not in scope: ‘i've’Not in scope: ‘never’Not in scope: ‘found’
07:01:42 <lambdabot>  Perhaps you meant ‘round’ (imported from Prelude)Not in scope: ‘syntax’Not i...
07:01:44 <deMoivre> edlin FTW
07:01:52 <ab9rf> oops :)
07:02:02 <tdammers> xkcd, real programmers
07:02:07 <deMoivre> yep
07:02:12 <deMoivre> Got my handy magnet right here
07:02:13 <ab9rf> my first editor was teco
07:02:14 <tdammers> anyhow
07:02:14 <deMoivre> show me the bits
07:02:33 <xnull> got my butterfly right here
07:02:39 <ab9rf> well, there was the crazy edit in trash-80 level 2 basic
07:02:42 <deMoivre> My first editor was the TRS-80 CoCo 2 BASIC source code input screen that was on ROM
07:02:46 <deMoivre> HAHAHAHA!
07:02:49 <deMoivre> ab9rf: wow
07:03:06 <boj> deMoivre: move the body of your loop to a new function, then figure out how to pass it to loop
07:03:07 <xnull> helo shit
07:03:10 <xnull> holy*
07:03:19 <deMoivre> boj: I don't know how to do that.
07:03:30 <boj> deMoivre: can you write the function at least?
07:03:30 <xnull> my first editor was notepad ;_; i'm jealous of you guys
07:03:43 <ab9rf> teco wasn't much different, really
07:03:59 <ab9rf> and edlin of course
07:04:03 <ab9rf> that was a few years later
07:04:10 <deMoivre> I think edlin was the first editor I tried on an IBM PC (XT)
07:04:12 <deMoivre> and it was a nightmare
07:04:18 <deMoivre> I preferred copy con and ^Z to that
07:04:30 <ab9rf> back to the parser
07:05:00 <deMoivre> I also used to think vi[m] was junk, but now I've come to kinda like it
07:05:06 <deMoivre> It's pretty handy and it's ubiquitous
07:05:14 <deMoivre> ubiquity has a lot of value to me
07:07:53 <deMoivre> tdammers: I am still trying to refactor this as you requested/suggested.
07:07:56 <deMoivre> I'm not slackin' off
07:10:40 <ab9rf> i don't understand why haskell puts such a high importance on terminating string constants
07:11:35 <stool> Are you suggesting we should not terminate them?
07:11:59 <zomg> You don't want to let strings run free do you? Soon we would have string overpopulation if we don't terminate them
07:12:37 <zomg> and then you would have to send a murderous cyborg back in time to terminate john connor
07:13:21 <mauke\> > "sarah connor
07:13:22 <lambdabot>  <hint>:1:14:
07:13:22 <lambdabot>      lexical error in string/character literal at end of input
07:13:23 <zomg> I am, of course, talking about C-3PO
07:13:43 <mauke\> c-3po was an android, not an iphone
07:15:17 <tromp_> > fix show
07:15:19 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
07:15:27 <mauke\> > fix fail
07:15:28 <lambdabot>  ""
07:15:39 <clrnd> > fix fix
07:15:40 <lambdabot>  Occurs check: cannot construct the infinite type: a ~ a -> a
07:15:40 <lambdabot>  Expected type: (a -> a) -> a -> a
07:15:41 <lambdabot>    Actual type: (a -> a) -> a
07:15:58 <thebnq> > fix (const fix)
07:16:00 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
07:16:00 <lambdabot>    arising from a use of ‘M722156184625693187527695.show_M7221561846256931875...
07:16:00 <lambdabot>  The type variable ‘a0’ is ambiguous
07:16:10 <tromp_> > fix error
07:16:12 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
07:16:23 <mauke\> that used to be a lambdabot exploit
07:16:55 <RyanGlScott> I have a question about static files with cabal.
07:16:56 <deMoivre> tdammers: http://pastebin.com/L4tM24qy
07:17:06 <deMoivre> tdammers: That's the best that I seem to be able to do
07:17:12 <RyanGlScott> If you register a static file, you can use the Paths_* module to refer to it from Haskell.
07:17:24 <RyanGlScott> Can you refer to a static file from a separate static file?
07:17:27 <deMoivre> I wanted to pull the "loop (n - 1)" part out as well, but it doesn't seem to make sense to
07:17:45 <RyanGlScott> e.g., refer to jquery-1.11.2.js from the js-jquery library (https://github.com/ndmitchell/js-jquery/tree/master/javascript)
07:18:34 <clrnd> deMoivre, you don't need really the 'do' keyword when you have a single expresion
07:18:43 <mauke\> > concatMap (`shows` "\n") (reverse [1 .. 10])
07:18:45 <lambdabot>  "10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n"
07:18:59 <deMoivre> clrnd: But isn't the loop (n - 1) part of the 'do' block?
07:19:06 <mauke\> > unlines (map show (reverse [1 .. 10]))
07:19:08 <lambdabot>  "10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n"
07:19:09 <tero-> ghc complains stack overflow "use +RTS -k<size> to increase it". putting +RTS -K1024M to ghc-options does not help. any ideas?
07:19:24 <mauke\> deMoivre: line 4
07:19:31 <clrnd> deMoivre, yeah but it's a single expresion, it can omit it: `do; loop 10` => `loop 10`
07:19:39 <ab9rf> tero-: rewrite your code to use tail recursion?
07:19:50 <mauke\> ab9rf: how will that help?
07:20:02 <deMoivre> mauke\: Thanks.
07:20:04 <deMoivre> duh.
07:20:11 <mauke\> deMoivre: loopBody = print  -- optimized
07:20:11 <clrnd> deMoivre, oh sorry, yeah the loop (n - 1) part is ok with `do`
07:20:20 <tero-> ab9rf: I'm trying to compile the code
07:20:27 <tero-> without optimizations it compiles ok
07:20:28 <ab9rf> oh, the compiler, sorry
07:20:47 <mauke\> tero-: have you tried -k instead of -K?
07:20:54 <clrnd> > [10..1]
07:20:56 <lambdabot>  []
07:21:02 <mauke\> > [10, 9 .. 1]
07:21:04 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
07:21:06 <clrnd> oh yeah
07:21:15 <mauke\> sorry, I was thinking in perl there
07:21:22 <clrnd> lol
07:21:53 <mauke\> (10 .. 1 is also the empty list in perl, but there's no enumFromTo, so you need reverse)
07:22:13 <tero-> mauke\: trying it
07:30:53 <ab9rf> is there a standard library name for liftM3 (\a b c -> a++b++c)
07:31:08 <ab9rf> or more elegant way to express that?
07:32:31 <tero-> mauke\: still the same. I used "-Wall -O2 +RTS -k1024M" as ghc-options
07:32:46 <bananagram> @pl (\a b c -> a++b++c)
07:32:46 <lambdabot> (. (++)) . (.) . (++)
07:33:18 <tero-> let's try with 2048M
07:33:25 <ab9rf> bananagram: that's not more elegant
07:33:39 <bananagram> I thought it would be
07:34:14 <exio4> ((++) .) . (++) -- is a cleaner point-free/less version of it, it's still not more elegant or anything
07:34:17 <ab9rf> i need to write test cases for this stupid app
07:34:33 <ab9rf> i never got the hang of unit testing
07:35:58 <ab9rf> "int" is a prefix of "integer"
07:36:36 <tero-> mauke\: okay now it's going further but I don't have enough memory to run it through
07:36:59 <tero-> only 14GB available on this VM
07:37:34 <tero-> ghc is quite a memory hog
07:38:14 <gcganley> hello is there a tutorial for working with the network in haskell that i can use to get my feet wet?
07:38:48 * hackagebot chalk 0.1.0.0 - Terminal string styling.  http://hackage.haskell.org/package/chalk-0.1.0.0 (cattheory)
07:42:43 <cfoch> erikd: hi
07:42:49 <cfoch> I was reading your comment
07:42:52 <cfoch> https://github.com/cfoch/cabal/commit/dace8df287db951ed4f764c7bfcd0d0e9265279f#commitcomment-9865399
07:43:22 <cfoch> " let isInstalled maybePkgName = maybe False (isPackageInstalled pkgs) maybePkgName"
07:43:57 <dcoutts> cfoch: oh, you're here, I was looking for you in #hackage
07:44:15 <cfoch> dcoutts: hi  o/
07:44:22 <dcoutts> cfoch: the thing I was going to suggest about that patch is that we should be looking in the source package index rather than the installed package index, for name clashes
07:44:43 <dcoutts> people only have a few packages installed, but the source package index is all of hackage
07:47:03 <cfoch> dcoutts: is there a function to check if a package has been installed? I wrote my own function because I didn't find one
07:48:04 <dcoutts> cfoch: well, you're using isPackageInstalled from the Distribution.Simple.PackageIndex module
07:48:54 <dcoutts> cfoch: or did you add that in the same patch?
07:49:01 <cfoch> dcoutts: I wrote that...
07:49:31 <cfoch> https://github.com/cfoch/cabal/commit/c35b17ec6a0c2a1ffbb6c0233b4e09cde1fc670f#diff-8c2f4d0e6d407977f4e8e419d65004aeR195
07:50:26 <dcoutts> cfoch: the simplest would be to use not (null (lookupPackageName index pkgname))
07:51:53 <dcoutts> cfoch: indeed that'd probably be better on balance than adding a specialised member function
07:52:10 <dcoutts> cfoch: but as I said, we really want to be using the source package index instead, not the installed package index.
07:52:31 <dcoutts> the source package index has a similar function to look up by name
07:52:58 <cfoch> the source package index involves all the packages available to install or what exactly?
07:53:11 <cfoch> dcoutts: ^
07:54:10 <dcoutts> cfoch: yes, it's the index from hackage
07:55:11 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121031
07:55:23 <funfunctor> what does this syntax error mean?
07:56:50 <cfoch> dcoutts: SourcePackageIndex == PackageIndex right? Once I've looked up for certain package index, how would I know if it is installed?
07:57:31 <dcoutts> cfoch: why do we care if it's installed? Don't we want to look for potential name clashes on hackage?
07:57:54 <clrnd> funfunctor, no need for `;` there
07:59:09 <funfunctor> clrnd: thats not what this is about.. ; is generated from do syntax
07:59:35 <clrnd> funfunctor, oh, you need to indent `then` a space
07:59:39 <clrnd> also `else`
07:59:45 <cfoch> ah... I understood that it should warn if the package is already installed
08:00:11 <dcoutts> cfoch: you'll notice that the Init code currently only getInstalledPackages and not getSourcePackages, but we can use that too, see any example of where it's used elsewhere
08:00:44 <clrnd> funfunctor, if it shouldn't insert `;` before it, it means you need to indent it a little more
08:00:47 <clrnd> afaik
08:00:57 <funfunctor> thx worked it out
08:01:02 <funfunctor> https://ghc.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
08:01:17 <dcoutts> cfoch: "any known existing package" would be source packages (ie the 7000+ on hackage), not just those few the user might have installed
08:01:22 <funfunctor> folklore has it that this gets asked a lot
08:02:11 <clrnd> it does, but meh, most people don't even use `if` that often
08:02:35 <xnull> is haskell's logo supposed to look like the bind operator and a lambda?
08:02:49 <c_wraith> xnull: precisely those, yes
08:02:53 <xnull> neat-o
08:40:48 <SrPx> Hello, could anyone with a lambda calculator give me a little hand? This paper: http://repository.readscheme.org/ftp/papers/topps/D-456.pdf says that " λbn.λzx0x1.b x0 x1 (n z x0 x1) " is the shift-left operator of binary lambda calculus numbers such as " 5 = λ z a b → a (b (a z))) ". When I test it on my lambda calculator, it doesn't work.
08:41:11 <SrPx> Specifically, using bruijn indexes, this is what I got by applying that operator to 5: ((λ (λ (λ (λ (λ (((0 1) 0) (((3 2) 1) 0))))))) (λ (λ (λ (0 (1 (0 2))))))) → (λ (λ (λ (λ (((0 1) 0) (((3 2) 1) 0))))))
08:41:36 <SrPx> the → indicates total normalization. So, what is wrong here? Is there a bug on my lambda calculator, did I note the formula worng, or is it actually wrong?
08:42:48 <SrPx> I can't understand why that would be the shift-left, too. I've came up with this definition of shiftleft: (λ n z a b → n (b z) a b) which seems to work... so... what is going on...!?
08:47:06 <matt3> what's the best way to download json for parsing with aeson? i'm currently using Network.HTTP.Conduit (simpleHttp) and I think it's doing some kind of caching because I get different results when I use it vs going to the page in my browser
08:48:53 * hackagebot List 0.5.2 - List monad transformer and class  http://hackage.haskell.org/package/List-0.5.2 (YairChuchem)
08:51:08 <int-e> SrPx: note that the first argument of \uparrow is supposed to be a boolean
08:53:15 <int-e> SrPx: and the list of example numbers is useless; I still don't know which of the digits is supposed to be the least significant one. judging by the definition of shift, it's the left-most bit.
08:54:07 * hackagebot lens-properties 4.7 - QuickCheck properties for lens  http://hackage.haskell.org/package/lens-properties-4.7 (EdwardKmett)
08:56:22 <int-e> SrPx: oh and you got the indices wrong; the first 0 should be 4.
08:56:54 <SrPx> int-e: thanks, it works now. How did you discover that? The paper talks about specialized versions but it doesn't clearly say that that first argument is a bool. And lol...  indeed. They should've noticed that.
08:57:06 <tejasmanohar> i know this is kinda odd question
08:57:19 <int-e> SrPx: "Single bits are represented as 0 ≡ T, 1 ≡ F."
08:57:19 <tejasmanohar> but is aynone familiar w/ graphing shapes w/ polar functions
08:57:24 <tejasmanohar> like flowers, spirals, etc
08:57:26 <SrPx> int-e: and yep, fixed it :)
08:57:51 <int-e> SrPx: but I missed it on the first reading as well; I realized this when I read the part where they generalize it to base d.
08:57:57 <SrPx> int-e: yea, I didn't understand what that meant at all...?
08:58:38 <SrPx> "single-bits" wut
08:58:38 <int-e> SrPx: it just means that 0 is represented by T (true; introduced earlier) and 1 by F (ditto).
08:59:21 <int-e> SrPx: and by "it means" I mean that putting the authors' intent and text together, this is the only plausible interpretation.
08:59:42 <SrPx> I see
09:01:25 <nitrix> Hi, how do I initialize the IORef inside a record ?
09:01:51 <mauke\> with newIORef
09:02:01 <nitrix> I'm creating a record   Ledger { merkleRoot = newIORef [Resource{...}] }
09:02:50 <tejasmanohar> is aynone familiar w/ graphing shapes w/ polar functions
09:03:10 <nitrix> And that gives me error expected type `IORef [Resource]`, currently `IO (IORef [Resource])`
09:03:20 <mauke\> nitrix: yeah, that looks like a type error
09:03:33 <mauke\> that's like doing Foo { bar = getLine } where bar :: String
09:03:34 <nitrix> mauke\: Isn't it possible to create an IORef without newIORef?
09:03:50 <mauke\> nitrix: what would that even do?
09:04:18 <nitrix> mauke\: What do you mean?
09:04:39 <nitrix> It's not about what it's doing, it's about being initialize properly.
09:05:02 <mauke\> assume you had a facility for creating IORefs without newIORef. what would it look like and what would it do?
09:05:35 <SrPx> Anyway, thank you int-e :) if anyone knows a different paper proposing an efficient representation of numbers, preferably with more operators (division?), I'd be thankful!
09:05:40 <bennofs> Are the results of the FTP survey already available somewhere?
09:06:28 <nitrix> mauke\: You'd create an object which of type IORef, and the other facilities would mutate it. I agree this implies IO, but the initial state shouldn't.
09:06:46 <mauke\> nitrix: how would I create the object?
09:08:00 <mauke\> what operations, with what types?
09:08:47 <nitrix> mauke\: You're mocking me, are you?
09:08:57 <nitrix> mauke\: Thedifferent facilities remains the same.
09:08:58 <ab9rf> trying to make sense of htest
09:09:12 <c_wraith> nitrix: no, those are legitimate questions.  What difference are you proposing, in terms of types?
09:09:18 <nitrix> c_wraith: None.
09:09:29 <mauke\> nitrix: no, I'm trying to figure out what exactly you're thinking
09:09:30 <c_wraith> nitrix: then..  congratulations, it's already done.
09:09:38 <mauke\> because what you're saying makes no sense to me
09:09:51 <c_wraith> nitrix: if you're proposing a change, there must be an actual change somewhere.
09:09:54 <nitrix> I want to create and return a record which has an IORef.
09:09:57 <mauke\> but it obviously does to you, so I'm trying to get details
09:10:06 <nitrix> Without it being an IO.
09:10:21 <c_wraith> nitrix: so what's the type of the new operation you're proposing?
09:10:21 <mauke\> nitrix: if you're proposing no difference, use newIORef
09:10:35 <TallerGhostWalt> I am looking for an algorithm to compare 2 regex for which one could represent the least possible match
09:10:35 <nitrix> If the initial value for an IORef is known, there's no reason for that function to have any side-effects.
09:10:52 <mauke\> nitrix: bla bla bla
09:11:00 <mauke\> you're paraphrasing instead of showing code
09:11:00 <nitrix> c_wraith: The operations remains the same, I'm talking about initialization of such record. It's not about IORef per se.
09:11:06 <mauke\> this is all handwaving
09:11:12 <c_wraith> nitrix: then what's the type of the new initialization operation?
09:11:13 <TallerGhostWalt> so "[a-c]" should be < "[d-z]"
09:11:14 <nitrix> mauke\: rawBlock <- inodeRead (Ledger{merkleRoot = newIORef [Resource {provider = head providers, blockId = BlockId "d3m0"}]}) (InodeId $ 9)
09:11:17 <c_wraith> nitrix: *types*.  WHat are they?
09:11:24 <mauke\> nitrix: that's a type error
09:11:29 <mauke\> we've been over that
09:11:34 <TallerGhostWalt> anyone know of something like that?
09:11:51 <nitrix> mauke\: IORef alone wont work.
09:12:10 <mauke\> nitrix: what
09:12:44 <nitrix> mauke\: IORef doesn't have a data constructor
09:12:49 <mauke\> cool story, bro
09:12:49 <nitrix> Other than newIORef.
09:13:00 <nitrix> mauke\: You're being unecessarily rude.
09:13:10 <nitrix> Last time a recall, this channel wasn't like this.
09:13:12 <mauke\> yes. and so are you.
09:13:30 <nitrix> I'm answering your questions.
09:13:31 <mauke\> if you don't want to answer my questions, just tell me up front
09:13:32 <c_wraith> nitrix: I'm really trying to understand your proposal, but I don't know what types you mean.
09:13:34 <mauke\> no, you're not
09:13:41 <nitrix> c_wraith: It's not a proposal.
09:13:42 <mauke\> you're handwaving and talking about different things
09:13:48 <nitrix> c_wraith: I want to know how to do it.
09:13:52 <ski> nitrix : allocating a new `IORef' is an effect. do you want/need to allocate a new one, or could you work with one you get as an input ?
09:14:06 <geekosaur> nitrix, you're not showing code or errors from any of these, just asserting things in ways that leave nobody able to help you
09:14:07 * hackagebot mp 0.2.0 - Music player for linux.  http://hackage.haskell.org/package/mp-0.2.0 (piotrborek)
09:14:11 <mauke\> nitrix: this is like saying "I want an integer that is both even and odd"
09:14:14 <mauke\> except less specific
09:14:15 <nitrix> geekosaur: I provided code.
09:14:39 <mauke\> also, this is an XY problem
09:14:41 <nitrix> geekosaur: Check the backlog or don't interfere, we don't need a 10 persons chaos.
09:14:51 <mauke\> I've just been asking about X because it seemed interesting
09:15:36 <c_wraith> nitrix: it's actually quite important that IORef initialization be in IO
09:15:38 <clrnd> well well no need to get all spiced up
09:15:47 <TallerGhostWalt> is there a way to bound the kind of strings generated from QuickCheck?
09:15:54 <c_wraith> nitrix: If it's not, it can get inlined, so that multiple structures share the same IORef
09:15:55 <clrnd> nitrix, it seems you are confusing types with values
09:15:56 <mauke\> <mauke\> what operations, with what types?   <nitrix> mauke\: You're mocking me, are you?  <- this is why I think you don't want to answer my questions, btw
09:16:14 <nitrix> ski: I'd like to be able to create an IORef without side-effects. I do not see IORef having a data constructor. I understand that mutating it is necessarily an IO, but the original value has no reason to be.
09:16:17 <ahammel> TallerGhostWalt: make a custom generator
09:16:21 <ski> nitrix : "If the initial value for an IORef is known, there's no reason for that function to have any side-effects." -- if the initial `IORef' itself is known, then you don't need effects. if only the initializing value is known, then you *do* need `IO' effects, since it's an `IO' effect to allocate a new one (that is inequal to any previous one)
09:16:31 <mauke\> nitrix: "I see no reason why even numbers can't be odd"
09:16:32 <hannes__1> nitrix: Creating an ioref is a side effect by necessity
09:16:37 <c_wraith> nitrix: this was the source of a *lot* of bugs with inlinePerformIO
09:16:56 <ski> nitrix : creating a new `IORef' needs to make sure that it is inequal to any preexisting one. that's an `IO' effect. no way around that
09:17:48 <TallerGhostWalt> ahammel: yeah, just didn't know if you could say something like... only include strings matching this regexp
09:17:52 <ski> nitrix : think of it like looking through a global "used index" list to check which is the next unused index. you really need to access (and thus depend) on that global state
09:18:08 <TallerGhostWalt> ahammel: without building it yourself
09:18:23 <c_wraith> nitrix: it seems like you're proposing an operation with type "a -> IORef a", except you refuse to say so.  ski is explaining why that doesn't work.
09:18:54 <nitrix> ski: Couldn't there be a Record / inline syntax that abstract the World to make it possible?
09:18:55 <ski> hannes__1 : .. yes, except i'd drop the "side"
09:19:30 <nitrix> ski: Surely the compiler as capable of making sure they are all unique at compile-time.
09:19:36 <ahammel> TallerGhostWalt: there's the regex-genex package
09:19:41 <mauke\> nitrix: that syntax is the IO type with its >>=
09:19:51 <ski> nitrix : i'm not sure what you mean by "abstrac the World" .. perhaps you're looking for something along the lines of idiom brackets (for applicative functors) .. but in this case for monads
09:20:16 <ski> nitrix : "Surely the compiler as capable of making sure they are all unique at compile-time." -- no, since you might make ones at run-time that depend on input you only get then
09:20:34 <TallerGhostWalt> ahammel: thanks, perfect now to make it only spit out the lexically smallest match!
09:20:42 <mauke\> (\f -> [f 0, f 0, f 0]) ioref
09:20:51 <mauke\> (\f -> let y = f 0 in [y, y, y]) ioref
09:20:57 <nitrix> ski: if the world was a simple increment, you'd have your guarantee right there.
09:21:23 <nitrix> And that doesn't break referencial transparency, no memoizing or whatever other optimizations.
09:21:29 <nitrix> *nor
09:21:31 <TallerGhostWalt> ahammel: ooh it is even ordering them!
09:21:31 * ski isn't sure where this talk of "world" is coming from
09:21:41 <ahammel> TallerGhostWalt: nice
09:22:22 <ski> nitrix : obviously it breaks duplication. incrementing once and reusing the result isn't the same as incrementing twice and using the two separate results
09:22:25 <clrnd> nitrix, in any case, in haskell newIORef is IO, so you'll need to use IO
09:23:17 <ski> nitrix : perhaps you can arrange to allocate your `IORef's beforehand .. e.g. if you're trying to build a cyclic structure of that, that can be done (with `mfix')
09:23:39 <nitrix> So there's no way to create a record inline which has an IORef.
09:24:01 <clrnd> nitrix, if the expresion's type is IO a then yes, you can
09:24:22 <nitrix> clrnd: rawBlock <- inodeRead (Ledger{merkleRoot = IORef [Resource {provider = head providers, blockId = BlockId "d3m0"}]}) (InodeId $ 9)
09:24:30 <nitrix> clrnd: It's inside an IO context, yeah.
09:25:04 <clrnd> nitrix, then just `ioref <- newIORef; ...  merkleRoot = ioref ...`
09:25:12 <nitrix> That's not inline.
09:25:35 * ski thinks "reflective syntax" would do what nitrix want here ..
09:26:16 <nitrix> I understand IOs are sequential, but that's inconvenient when your code has IO all over the place.
09:26:30 <nitrix> A one-liner would be much more convenient.
09:26:42 <mauke\> you can write everything on one line
09:26:51 <quchen> It's even more inconvenient if your code had no IO all over the place.
09:26:53 <clrnd> nitrix, oh so that's the problem ... do you know about pointfree style?
09:26:59 <nitrix> clrnd: I do.
09:27:08 <ab9rf> it's better to avoid having IO all over your code :)
09:27:21 <nitrix> ab9rf: My code is a distributed file-system.
09:27:29 <nitrix> ab9rf: Every operation is literally IO.
09:27:30 <ab9rf> nitrix: details :)
09:27:43 <nitrix> ab9rf: You're speaking through your hat.
09:27:51 <ab9rf> i don't have a hat
09:27:52 <clrnd> nitrix, believe us, you don't need IO taht much ...
09:27:54 <quchen> nitrix: IO isn't a value, so every operation can't literally be it ಠ_ಠ
09:28:23 <nitrix> quchen: So far there's only one pure function out of 230.
09:28:42 * ski thinks nitrix's request of "inline" here is reasonable. but currently, the closest thing to this that's implemented is idiom brackets
09:28:56 <quchen> Idiom brackets are implemented?
09:28:57 <clrnd> nitrix, okay, you can't write that "inline", next question
09:28:58 <ski> (and that's not enough for this case)
09:29:04 <quchen> I kmow them from Idris, but in Haskell?
09:29:14 <quchen> Or is it a TH module
09:29:17 <clrnd> idiom brackets cover monads? thought it was only applciative
09:29:27 <ski> @hackage applicative-quoters
09:29:27 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
09:30:03 <ski> clrnd : they only cover idiom/applicative. i'd spent some time sketching an extension to monads. "reflective syntax". but it's unimplemented
09:30:12 <clrnd> ski, cool!
09:30:54 <nitrix> The QuasiQuoter looks close to what I want.
09:30:55 <ski> quchen : yes, TH
09:30:58 <nitrix> I'll check.
09:31:39 <ski> nitrix : which "QuasiQuoter" ?
09:32:05 <nitrix> Control.Applicative.QQ.Idiom
09:32:10 <nitrix> The one you just talked about
09:34:08 * hackagebot binary 0.7.4.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.7.4.0 (LennartKolmodin)
09:34:55 <hsk5> Is this legal? import qualified Data.ByteString as D.B
09:35:18 <c_wraith> hsk5: I don't believe so, but I haven't actually tried.
09:35:28 <c_wraith> (or checked the grammar)
09:36:05 <hsk5> ok just tried, seems to work
09:36:19 <hsk5> What scheme do you use to name qualified imports so they're easily recognizable?
09:36:28 <hsk5> i'm trying to devise one scheme and stick with it
09:36:31 <nitrix> hsk5: Probably works until you alias D.
09:36:47 <monochrom> it is legal
09:39:26 <c_wraith> I stand corrected.
09:41:42 <geekosaur> actualy it doesn't care much at all. you can even use the same `as` for multiple modules
09:41:55 <geekosaur> (presumably as long as their imports don't collide)
09:42:16 <kadoban> hsk5: Most people just seem to use an acronym of it. Like B or BS for ByteStream, etc. It doesn't really need to be a fancy scheme, IMO. It's not like it's hard to find what it stands for.
09:42:21 <mauke\> yeah, it's the same thing that happens for the implicit scope
09:43:34 <hsk5> kadoban: so in your experience it's not hard? scrolling to the top of the file is not a problem?
09:43:57 <hsk5> i imagined it would be tedious
09:44:04 <hsk5> but i haven't experienced it yet
09:44:07 <hsk5> so i dunno
09:44:27 <c_wraith> hsk5: depends on your editor.  Many of them make go to top one button, and return to previous location a second button press.  No big deal
09:46:25 <mauke\> gg^O
09:46:53 <hsk5> ahk
09:47:02 <hsk5> c_wraith: which editor u use?
09:47:04 <hsk5> sublime?
09:47:06 <c_wraith> emacs
09:47:08 <hsk5> ok
09:47:31 <c_wraith> But there are a lot of good editors.  I'm not religious.  I've just developed muscle memory. :)
09:48:09 <ibid> c_wraith: what else is religion but muscle memory retroactively explained away? :D
09:49:12 <c_wraith> ibid: it also implies a tendencies towards proselytism. :)
09:49:49 <monochrom> in emacs, I sometimes open two viewports to the same file, each at a different location.
09:50:02 <ibid> c_wraith: like, "ed is the standard editor"? :D
09:50:07 <monochrom> in fact, I mostly do it to my html files
09:50:09 <c_wraith> ibid: exactly! :)
09:50:20 <geekosaur> like other editors can't do that?
09:50:32 <monochrom> I don't know.
09:50:41 <monochrom> I can only speak what I know.
09:50:49 <mauke\> I do that all the time in vim
09:50:52 <mauke\> just to spite emacs
09:51:01 <mauke\> I have no use for it
09:52:55 <monochrom> must I finish every sentence with a disclaimer "this statement is all and only what I mean, in no way it implies any other meaning it doesn't logically imply"?
09:52:59 <c_wraith> I know vi movement keys thanks to nethack!
09:53:24 <hsk5> i've never been much of a keyboard guy :(
09:53:26 <hsk5> never got into it
09:53:33 <hiptobecubic> keyboard forever!
09:53:44 <hiptobecubic> although i use my thinkpad nub pretty frequently
09:54:02 <hsk5> i imagine there are ongoing religious wars for emacs vs vim?
09:54:05 <mauke\> I've found the keyboard very useful for inputting text, such as computer programs
09:54:05 <hiptobecubic> haven't activated the trackpad in a few months i think
09:54:14 <c_wraith> hsk5: have been for at least 30 years.
09:54:18 <hsk5> lol
09:54:42 <geekosaur> well, not vim /per se/ because 30 years ago there was just vi :p
09:54:50 <redactyl_> I'm fighting the emacs vs vim war within myself, lately.
09:54:59 <ski> nitrix : ok
09:55:05 <geekosaur> then again many vim users don't realize that vi could do a lot of the things vim thinks it invented...
09:55:12 <c_wraith> redactyl_: fortunately, both sides are good choices.
09:55:13 <SolitaryCipher> Come on guys. Everyone should use the ACME editor from Plan9
09:55:15 <ski> (i wasn't sure if you meant that one, or some other one)
09:55:17 <gbiv> hsk5: yes, but now the wars have changed to emacs vs vim vs sublime-every-now-and-then vs intellij-sometimes vs [...]
09:55:22 <SolitaryCipher> https://en.wikipedia.org/wiki/Acme_%28text_editor%29
09:55:24 <mauke\> redactyl_: compromise: run vim inside an emacs buffer
09:55:34 <c_wraith> viper-mode?
09:55:38 <gbiv> evil-mode?
09:55:46 <mauke\> no, vim
09:56:16 <geekosaur> acme vs. 8 1/2!
09:56:17 <hsk5> heh
09:56:42 <redactyl_> mauke\: I almost think that would be an okay compromise.
09:57:04 <mauke\> my work here is done
09:57:42 <monochrom> in emacs, run vim; in that vim, use :! to run emacs
09:57:44 <redactyl_> emacs has a lot of nice features that I miss when using vi/vim, but I prefer the simplicity of vim.
09:58:23 <redactyl_> I tried acme, too, and I really wanted to like it, but I'm just not very mousy.
09:58:39 <ski> monochrom : .. or `emacsclient'
10:00:27 <SolitaryCipher> redactyl_: I like the mouse; I think it can be very efficient if done properly.
10:01:05 <SolitaryCipher> Acme gets most of the way there; I kinda want someone (preferably a researcher)  to look into how one could use the mouse in new and interesting ways.
10:01:15 <SolitaryCipher> Not just point-and-click stuff.
10:01:36 <stool> Acme seems pretty cool, do you use it too?
10:02:06 <SolitaryCipher> I did for a while. Went back to vim with mouse support
10:02:07 <redactyl_> SolitaryCipher: I'm sure it can be. I've though about trying to get a trackball, and I think that would help, but it's not that important to me, I guess.
10:02:49 <redactyl_> I think I would use the mouse more if all it did was move my cursor in vim.
10:05:14 <xandaros> I use vim without mouse support. Don't see the point, since I'm faster moving the cursor with the keyboard. What features does emacs have that vim doesn't? Never tried it
10:05:44 <SolitaryCipher> redactyl: I really like looking into input devices and how we use them. Not really consumer stuff, more like paradigms of how we use comptuers
10:06:18 <SolitaryCipher> Chording keyboards are interesting to me; in that I think they will become a bigger deal once IoT comes around and wearables become more accessible.
10:07:06 <SolitaryCipher> All of the old wearable guys have been using chording keyboards for ages, and I feel like they are a great alternative for portable, light, keyboards.
10:09:30 <kadoban> SolitaryCipher: They probably won't be as big as they should. Just look at phones: totally different input requirements from keyboards, and people still just use gross qwerty, regardless of how inappropriate it is.
10:09:52 <kadoban> Even ignoring that qwerty is kinda icky even on actual keyboards…
10:10:03 <deMoivre> Could someone help me figure out what's wrong with this code?
10:10:10 <deMoivre> I can't get it to compile
10:10:11 <deMoivre> http://pastebin.com/hhHEBxYv
10:10:16 <SolitaryCipher> True, but you can do stuff like have half a keyboard, with a "mode switch" button that changes the keyboard to the other half
10:10:21 <SolitaryCipher> and use it with one hand, without issues
10:10:44 <SolitaryCipher> Once you use if for an hour, your brain grasp it and you can type at almost your regular speed
10:11:01 <SolitaryCipher> link for an example http://www.matias.ca/halfkeyboard/
10:11:17 <c_wraith> deMoivre: could you add in the error message?
10:11:30 <deMoivre> sure
10:11:45 <dolio> Can you guys take your keyboard discussions and whatnot elsewhere?
10:12:09 <c_wraith> deMoivre: oh, I see a problem with the definition of mandelbrot
10:12:15 <SolitaryCipher> yup. Is there an offtopic channel?
10:12:37 <exio4> SolitaryCipher: #haskell-blah
10:12:47 <deMoivre> http://pastebin.com/WxY6BF20
10:12:51 <c_wraith> deMoivre: The signature says it takes one argument, a tuple.  But the definition expects 7 arguments that aren't a tuple.
10:13:04 <SolitaryCipher> Cool, thanks
10:13:05 <c_wraith> deMoivre: yep, that the error the message is talking about
10:13:12 <c_wraith> *that's
10:13:24 <deMoivre> c_wraith: I thought it might be something like that, but I'm not familiar enough with the syntax to know how to give it exaftly what it wasnts
10:14:06 <deMoivre> *exactly
10:14:11 <c_wraith> deMoivre: the quickest change is in the definition of mandelbrot.  pattern-match the tuple with "mandelbrot (cre, cim, ...) = ..."
10:14:51 <c_wraith> deMoivre: filling in the ...s yourself.  I was just lazy.  You need the real code. :)
10:15:04 <deMoivre> I know
10:15:05 <deMoivre> heh
10:15:11 <deMoivre> I'm just staring at the code
10:16:17 <deMoivre> I still don't see what I did wrong.  =(
10:17:05 <c_wraith> deMoivre: haskell doesn't use commas to separate function arguments, but it does use commas to bundle up tuples.
10:17:25 <c_wraith> deMoivre: your type signature said that the function takes a tuple of values (of the same type it returns)
10:17:41 <pdefql> http://lpaste.net/121038 <- is this valid haskell?
10:17:43 <c_wraith> deMoivre: but your function definition said that it expects 7 different arguments, rather than a 7-tuple
10:17:56 <pdefql> the pattern seems to include 1 extra parameter...
10:17:57 <deMoivre> OH
10:17:59 <deMoivre> DUH
10:18:11 <c_wraith> pdefql: no.  Function names need to start with lowercase letters
10:18:56 <deMoivre> c_wraith: :D
10:18:58 <pdefql> c_wraith: what about the parameters in the first case?
10:19:07 <deMoivre> c_wraith: Compilation successful
10:20:00 <pdefql> http://lpaste.net/121038
10:20:54 <c_wraith> pdefql: well, that appears to be syntactically valid anyway.  Didn't check to see if it typechecks or is correct. :)
10:27:51 <disgrntld> hey gang, is there a way to pattern match on a Ratio?
10:28:21 <dolio> No.
10:28:51 <disgrntld> oh, I just found numerator/denominator, that'll work
10:28:55 <disgrntld> thanks, dolio
10:29:00 <dschoepe> disgrntld: You can simulate this with view patterns, kinda
10:29:50 <disgrntld> honestly I have a way simple use case, I'm just doing project euler problems and playing
10:29:51 <c_wraith> and unidirectional pattern synonyms!
10:29:52 <disgrntld> will google view patterns though, dschoepe!
10:30:03 <c_wraith> But yeah, the accessors are probably easier. :)
10:30:31 <dolio> Oh right. Pattern synonyms.
10:30:46 <dolio> I wonder if that module could be improved by that.
10:31:04 <c_wraith> I think pattern synonyms are getting changed again in 7.10
10:31:16 <c_wraith> So probably too early to lean on them
10:31:25 <dolio> Can you make a pattern (:%) that you can match on, but when you use it, it does the normalization, with a hidden actual constructor?
10:31:52 <c_wraith> dolio: not in 7.8.  That sort of thing might be what 7.10 allows
10:31:57 <dolio> Nice.
10:32:20 <dolio> :% has to be the name, right? % isn't a pattern. Same naming rules as constructors?
10:32:36 <c_wraith> same naming rules as constructors, yes.
10:34:23 <dschoepe> disgrntld: basically, you could write it like this: http://lpaste.net/4935852673707540480
10:34:43 <dschoepe> not very pretty either, so it doesn't give you much over just using the accessors directly
10:38:24 <ski> dolio : i don't think i'd want "pattern (:%) that you can match on, but when you use it, it does the normalization"
10:39:15 <dolio> I'd also be okay with just having it do the match end.
10:39:35 <dolio> Having it also be an expression seems nice, though.
10:39:51 <dolio> Miranda actually had ways of defining rules that applied when you used constructors.
10:40:08 <dolio> So you could define Ratio without having smart constructors.
10:40:12 <ski> i'd want `case Foo a b of Foo a b -> ..a..b..' to be equal to `..a..b..' for any `Foo'
10:40:33 <dolio> Maybe, at least. Not sure if it'd work for ratio, but it'd work for other computable quotients.
10:40:54 <c_wraith> dolio: you can define just the match end with 7.8's PatternSynonyms, at least.
10:42:03 <ski> (in Mercury, you can have non-injective constructors (when you have user-defined equality). then matching is (conceptually) non-deterministic. you have to insert `promise' pragmas at the appropriate places where you believe the nondeterminism is no longer observable)
10:43:17 <ski> (`promise_equivalent_solutions', in this case)
10:48:24 <dolio> Wouldn't that be due to expecting to run the constructor backwards to determine inputs?
10:48:36 <dolio> Which is not something you can do in Haskell.
10:49:12 * hackagebot scyther-proof 0.10.0.0 - Automatic generation of Isabelle/HOL correctness proofs  for security protocols.  http://hackage.haskell.org/package/scyther-proof-0.10.0.0 (SimonMeier)
10:49:45 <narendraj9> How can I add bindings that persist multiple expressions on tryhaskell.org?
10:50:20 <dolio> Haskell doesn't really have term equality considered, either.
10:50:35 <not_on_fp> @version
10:50:35 <lambdabot> lambdabot 5.0
10:50:36 <lambdabot> git clone git://github.com/lambdabot/lambdabot.git
10:50:37 <dolio> If it did, there are already non-injective constructors, at least if you consider parametricity.
10:50:52 <ski> dolio : "run the constructor backwards to determine inputs" is that pattern-matching on constructors is
10:51:10 <ski> (s/that/what/)
10:51:19 <narendraj9> @let x = 10
10:51:20 <lambdabot>  .L.hs:157:1:
10:51:20 <lambdabot>      Multiple declarations of ‘x’
10:51:20 <lambdabot>      Declared at: .L.hs:156:1
10:51:31 <narendraj9> @let xeta = 10
10:51:32 <lambdabot>  Defined.
10:51:40 <narendraj9> > xeta * 100
10:51:42 <lambdabot>  1000
10:52:04 <narendraj9> Is there a way to do this in tryhaskell.org? Because I am using the website for my bot.
10:52:15 <ski> (also, Mercury doesn't really use a plain term quality, like Prolog does)
10:52:29 <xnull> narendraj9: let xeta = 10 in xeta * 100
10:52:29 <ski> (argh, s/quality/equality/)
10:52:50 <narendraj9> xnull: I want to use xeta in the next expression that type.
10:53:12 <narendraj9> xnull: *I type
10:54:38 <xnull> narendraj9: you should be able to do just
10:54:43 <xnull> let xeta = 10
10:54:46 <xnull> then blah
10:55:05 <dolio> Pattern matching is not the same as reversing the direction of computation that I'm thinking of.
10:55:21 <dolio> I guess I'm not talking about just the constructor, it is running a case backwards as well.
10:55:42 <narendraj9> xnull: No, I can't do this on tryhaskell.org
10:55:51 <dolio> Trying to determine the values of x in 'case C x of C y -> ...' from the value of y relies on injectivity of C.
10:56:27 <dolio> Or trying to determine y from x.
10:56:54 <xnull> narendraj9: ah. sorry
10:57:24 <hcore> so im on cis194 hw 5 (type classes) and im kind of confused why I can't do this: http://lpaste.net/121042
10:57:24 <dolio> Currently the cases of where you can't determine y from x are cases where you're prevented from caring.
10:58:14 <dbushenko> hi all!
10:58:21 <dbushenko> how to perform lazy computation?
10:58:31 <pdefql> is there a reason why multi-parameter type classes aren't the default?
10:58:33 <ab9rf> dbushenko: by not being too eager
10:58:34 <geekosaur> hcore, the parentheses around + and * don't do what you think...
10:58:54 <S11001001> pdefql: because they aren't uncontroversial.
10:59:07 <ab9rf> ooh, double negative
10:59:10 <hcore> and i think i should be making some sort of Eval class and making parse an instance of it but since Lit and Add/Mul have different numbers of arguments i'm not sure how
10:59:17 <geekosaur> pdefql, without either type families or functional dependencies, they kinda wreck type inference
10:59:18 <hcore> geekosaur: they don't?
10:59:34 <ski> dolio : "Trying to determine .." -- yes
10:59:59 <geekosaur> parens around an operator makes it a function. in this case it thinks you are passing the function-value of the + operator to the function returned by (parse a)
10:59:59 <ski> dolio : i don't follow the "Currently .." sentence. elaborate ?
11:00:17 <dolio> Construtors that involve existential quantification aren't injective.
11:00:38 <dolio> At least, not necessarily.
11:00:38 <geekosaur> that is, it's not an operator any more, just a value
11:00:51 <geekosaur> > 3 (+) 2
11:00:52 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0 -> a0) -> a1 -> t))
11:00:52 <lambdabot>    arising from the ambiguity check for ‘e_132’
11:00:52 <lambdabot>  from the context (GHC.Num.Num ((a -> a -> a) -> a2 -> t),
11:01:08 <ab9rf> heh
11:01:11 <ski> dolio : hm, interesting point
11:01:21 <hcore> so how do i make it an operator then? removing the () doesn't work out
11:01:27 <ab9rf> lambdabot's funny numbers make for cuurious error messages
11:01:31 <geekosaur> no, I presume you have other problems in that case
11:01:45 <hcore> definitely do :)
11:01:51 <ski> dolio : i suppose you're assuming observational equivalence as equality here
11:02:38 <hcore> ahh
11:02:56 <hcore> instead of ExprT -> a i should be doing a more strict Exprt -> Integer
11:02:58 <ab9rf> hcore: in parse :: ExprT -> a, what is a?
11:03:01 <geekosaur> hcore: you can't be producing an `a`, you are .. yes
11:03:15 <geekosaur> because you are aseeting that the caller can choose an a and you must produce it
11:03:20 <geekosaur> but you can only produce Integer
11:03:29 <hcore> that makes sense now
11:03:30 <dolio> Yes, although you probably have problems if you can prove that they are injective. Even something very intensional would probably leave it undetermined.
11:03:30 <hcore> thanks!
11:03:31 <geekosaur> *asserting
11:03:31 <ab9rf> if ExprT were defined differetly, perhaps
11:03:42 <ab9rf> data ExprT a = Lit a ...
11:04:04 <hcore> ab9rf: totally, but i presume i need to use what the homework defines it as
11:04:19 <ab9rf> hcore: i would assume. i haven't done homework in two decades :)
11:04:20 <dolio> If you have fancier type theories you bump into other cases. Like 'higher inductive types' lose injectivity. And quotients are a special case of those.
11:05:00 <ski> dolio : well, if you can prove injectivity, then that just means that your reasoning system can tell more differences than observation can, no ?
11:05:01 <hcore> ab9rf: i haven't done actual homework in 5 years, this is self-imposed :)
11:05:03 <hannes__1> hcore: Do your homework... but it doesn't need to stop there. No reason not to try to make it better if you can figure out how
11:05:18 <hcore> hannes__1: totally
11:05:47 <ab9rf> hcore: if you're not being Actually Graded, then you should explore hw to make it better
11:06:10 <dolio> ski: I guess you could be anti-extensional.
11:06:39 <dolio> Most of the time intensional just leaves fewer things determined than extensional, though.
11:07:16 <hcore> ab9rf: i agree but im afraid if i do that i'll end up missing parts of the learning in a way, since i don't know haskell so well i can only assume that Brent Yorgey put in such restrictions so that those doing the homework learned things from them
11:07:20 <pdefql> http://lpaste.net/121046 <- why does the pattern for (<*>) declare 3 parameters even though (<*>) takes only 2?
11:08:19 <hannes__1> hcore: Restrictions aren't meant to help you learn better; They're intended to keep you from being overwhelmed by new information
11:08:23 <chreekat> pdefql: It's saying that (a <*> b) takes a parameter.
11:08:30 <hannes__1> hcore: Feel free to disregard them for experimentation
11:08:45 <raek> pdefql: (<*>) has type Applicative f => f (a -> b) -> f a -> f b. Now replace f with ((->) e)...
11:09:21 <ab9rf> hcore: it's very easy to be overwhelmed with haskell
11:09:29 <raek> (<*>) :: (e -> (a -> b)) -> (e -> a) -> e -> b
11:09:31 <ski> dolio : hm, point
11:10:44 <dolio> ski: Being anti-extensional in that way probably provides a means of distinguishing what were formerly indistinguishable, though. So I guess in that sense you're probably never breaking observable equality.
11:10:49 <dolio> You're just adding new observations.
11:11:34 * ski nods
11:12:03 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #9
11:12:07 <raek> pdefql: you can also write the <*> definition as "f <*> g = \x -> f x (g x)" if that makes more sense for you.
11:12:11 <hcore> hannes__1: totally, which i suppose is why LYAH is still using head/tail in chapter 10, even though it's wrong
11:12:12 <pdefql> rabisg: (f b) becomes (e -> b) ?
11:12:18 <pdefql> raek: (f b) becomes (e -> b) ?
11:12:21 <raek> pdefql: yes
11:12:36 <pdefql> thats so confusing lol
11:12:45 <hcore> ab9rf: i agree, especially since this is my first language, except for about 3-4 months of learning some java and realizing i hated java
11:12:54 <ab9rf> hcore: that's probalby an advantage
11:12:55 <raek> and because of currying "(e -> (a -> b)) -> (e -> a) -> (e -> b)" and "(e -> (a -> b)) -> (e -> a) -> e -> b" are the same
11:13:18 <pdefql> rabisg: wouldnt it become (e -> b) in brackets? so it returns a function?
11:13:18 <ab9rf> pdefql: functions that return functions are confusing
11:13:29 <pdefql> raek: wouldnt it become (e -> b) in brackets? so it returns a function?
11:14:13 * hackagebot gitson 0.5.1 - A document store library for Git + JSON.  http://hackage.haskell.org/package/gitson-0.5.1 (myfreeweb)
11:14:23 <pdefql> does haskell see a -> (b -> c) as the same thing as a -> b -> c ?
11:14:29 <raek> pdefql: yes, but a function that "takes two arguments" is indistinguishable from a function taking the first argument returning another function taking the second argument
11:14:39 <raek> pdefql: exactly
11:14:49 <pdefql> ah okay i see
11:14:50 <hcore> ab9rf: i sure hope so
11:14:54 <pdefql> thanks
11:15:22 <raek> pdefql: this is called "currying"
11:15:46 <pdefql> raek: this seem like the opposite of currying
11:16:29 <pdefql> i understood currying as going from 'a -> b ->b' to 'a -> (b -> c)'
11:16:37 <ReinH> :t curry
11:16:38 <lambdabot> ((a, b) -> c) -> a -> b -> c
11:16:38 <pdefql> but this sesms to be going the other way
11:16:39 <ReinH> That's curry
11:17:03 <ReinH> It takes "a function of two arguments" (in fact a pair) into a curried function.
11:17:04 <geekosaur> pdefql, currying is (a, b) -> c becomes a -> b -> c which is the same as a -> (b -> c)
11:17:42 <pdefql> -_- ok where is this tuple coming from
11:17:44 <ReinH> In Haskell, all functions are curried, so f a b is (f a) b
11:17:50 <raek> I should probably have written that differently
11:17:56 <geekosaur> the tuple is how parameters work in other languages
11:18:10 <geekosaur> you know, you say f(a, b) instead of f a b
11:18:24 <geekosaur> and it insists on keeping those together, so effectively it's a tuple
11:18:32 <pdefql> okay...
11:18:56 <geekosaur> haskell breaks them apart by currying them. now we get partial paplication for free, and the ability to work with the pieces like you are with that (<*>)
11:19:00 <pdefql> 'curry' is some sort of utility function and not the way currying works in the haskell language right?
11:19:06 <geekosaur> right
11:19:27 <ReinH> the curry function isn't currying, the concept
11:19:35 <pdefql> i understand how currying works when u supply only some of the parameters to a function..
11:20:03 <hannes__1> pdefql: The point is that _all_ haskell functions are _always_ curried
11:20:08 <pdefql> the confusing thing is how it also goes the other way... for example in the (->) applicative instance
11:20:18 <ReinH> What do you mean?
11:20:19 <hannes__1> pdefql: haskell functions are always 1 parameter functions
11:20:25 <raek> you are not really "going" from "a -> b -> c" to "a -> (b -> c)". they mean the same thing.
11:20:27 <pdefql> http://lpaste.net/121046
11:20:27 <ReinH> How does it "go the other way"?
11:20:40 <raek> the arrow is right-associative
11:20:51 <pdefql> see the pattern for <*> has 3 arguments
11:21:06 <pdefql> :t (<*>)
11:21:07 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:21:15 <pdefql> but the class definition only has 2
11:21:37 <redactyl> What is ((->) e)? Can anyone provide an example of its use?
11:21:43 <raek> one way to think of it, is that the expressoion does not _take_ three arguments it _is_ three functions (three lambdas)
11:21:43 <hannes__1> pdefql: Where do you see 3 arguments
11:21:48 <pdefql> so it replaces the type signature with the (->) type... making it take 3 arguments..?
11:21:58 <hannes__1> redactyl: It's just the function arrow partially applied
11:22:14 <pdefql> hannes__1: in the lpaste link above
11:22:14 <ReinH> > (==) <$> reverse <*> id $ "radar" -- redactyl
11:22:15 <lambdabot>  True
11:22:44 <ab9rf> pdefql: there are only functions of one argument.  a function that appears to take two or more arguments actually is a function of one argument that returns a function
11:22:45 <raek> redactyl: functions from e to anything. for example, if you let "e" be time, you can use it to describe values that change over time.
11:22:48 <ReinH> pdefql: what is the type of (<*>) there, for ((->) e)?
11:23:26 <raek> or "e" could be some constant configuration data you want to be able to read from anywhere in your program
11:23:37 <ReinH> pdefql: a function of type a -> b for some a and b can take 3 arguments
11:23:54 <pdefql> ReinH: how does that work?
11:23:54 <ReinH> a can be a function type
11:24:00 <ReinH> or b can
11:24:03 <ReinH> rather
11:24:08 <raek> if you write values of type (e -> a), (e -> b) and (e -> c), rather than just a, b, and c, then you can compose those
11:24:14 <ab9rf> it's b that has to be function type :)
11:24:24 <hannes__1> Think for example
11:24:29 <raek> and hide the application of the "e" argument
11:24:30 <hannes__1> > id (+) 3 3
11:24:32 <lambdabot>  6
11:24:45 <hannes__1> so
11:24:47 <hannes__1> :t id
11:24:48 <lambdabot> a -> a
11:24:51 <raek> one way to get rid of the Singleton (anti-)pattern
11:24:51 <hannes__1> :t id (+)
11:24:52 <lambdabot> Num a => a -> a -> a
11:25:32 <ReinH> Or, for that matter,
11:25:33 <ReinH> > id id id id id succ 1
11:25:35 <lambdabot>  2
11:26:14 <ReinH> pdefql: if a and b can be any type, then a can be Int and b can be Int -> Int
11:26:22 <ReinH> :t (+)
11:26:23 <lambdabot> Num a => a -> a -> a
11:26:45 <pdefql> ReinH: the weird thing is that the type is not determined yet, because its just the definiton, and 3 arguments are matched against in the pattern..
11:26:59 <ReinH> pdefql: the type is determined
11:27:04 <hannes__1> pdefql: At the definition the type is determined
11:27:16 <ReinH> f is determined to be ((->) e)
11:27:34 <ReinH> in instance Applicative ((->) e) where ...
11:27:54 <raek> hrm, is there an extension that allows you to write (e ->) instead? :-)
11:28:07 <ski> we'd like that
11:28:07 <ReinH> so f a ~ e -> a, f (a -> b) ~ e -> a -> b
11:28:11 <raek> some kind of infix type section
11:28:30 <hannes__1> raek: I don't think so
11:29:07 <ReinH> The type of (<*>) for the ((->) e) instance is given by replacing f with ((->) e) everywhere and simplifying
11:29:25 <ReinH> f ( a -> b) -> f a -> f b ~ (e -> a -> b) -> (e -> a) -> (e -> b)
11:30:38 <ReinH> There aren't a lot of possible instances of this type.
11:30:59 <raek> are there others?
11:31:05 <ReinH> Yes. bottom.
11:31:29 <raek> oh. well that's cheating :P
11:31:33 <ReinH> It is not :)
11:31:50 <ReinH> @djinn (e -> a -> b) -> (e -> a) -> (e -> b)
11:31:50 <lambdabot> f a b c = a c (b c)
11:31:53 <ReinH> Either that or bottom
11:32:12 <pdefql> ReinH: so 'class X a where...' 'instance X b where...' the b in the instance gets replaced everywhere by the a from class, but the b is used to apply further restrictions on the type?
11:32:13 * ReinH notes that f a d c = a c (d c)
11:32:17 <raek> oh. so those are the only possible ones? neat.
11:32:19 <hannes__1> ReinH: I think bottom doesn't count
11:32:23 <ReinH> hannes__1: sure it does
11:32:26 <ReinH> it's an inhabitant
11:33:02 <hannes__1> ReinH: Yeah but more of the 'incidental' kind
11:33:13 <ReinH> hannes__1: Not at all. Quite necessary.
11:33:19 <ReinH> It's an inhabitant of *all* types, after all
11:33:43 <ReinH> You can say that f a b c = a c (b c) is the only defined inhabitant.
11:33:59 <dolio> Ignoring bottom is overrated.
11:34:04 <hannes__1> It's only necessary in the sense that non-total functions wouldn't type check without bottom
11:34:08 <dolio> You can learn interesting things by thinking about bottom.
11:34:19 <ReinH> hannes__1: Yes, it's only necessary in the sense that it's necessary.
11:34:42 <raek> I remember the video where Brian Beckmand and Erik Meijer derived the state monad. they drew boxes and arrows and concluded that this was the only way to compose state transformations.
11:34:59 <raek> then I recalled that there is such a thing as the "reverse state monad"...
11:35:01 <ReinH> pdefql: You can replace a with b everywhere to get the types of the functions defined for the instance, yes.
11:35:12 <ReinH> raek: Uh, that can't be so.
11:35:18 <ReinH> Djinn can show you another way, in fact.
11:35:25 <ReinH> @unmtl State s a
11:35:25 <lambdabot> s -> (a, s)
11:35:33 <ReinH> :t (>>)
11:35:34 <lambdabot> Monad m => m a -> m b -> m b
11:35:36 <pdefql> another wierd thing is that ((->) a) is a partial? type - is the second type parameter inferred later, from the context?
11:35:52 <hannes__1> pdefql: It doesn't need to be
11:35:57 <ski> pdefql : it is provided later
11:35:58 <raek> ReinH: the one where you compose the state transformations in the reverse order?
11:35:59 <dolio> Reverse state is different from state, though.
11:36:01 <hannes__1> pdefql: You supply it yourself
11:36:05 <ReinH> @djinn (s -> (a, s)) -> (s -> (b, s)) -> (s -> (b, s))
11:36:05 <lambdabot> f a b c =
11:36:05 <lambdabot>     case b c of
11:36:05 <lambdabot>     (d, _) -> case a c of
11:36:05 <lambdabot>               (_, e) -> (d, e)
11:36:11 <ReinH> Djinn can just throw away one of the states.
11:36:22 <dolio> And not just in the sense that it's implemented differently. :)
11:36:26 <pdefql> hannes__1: via type annotations?
11:36:31 <raek> wow. I should play more with djinn I just realized
11:36:40 * josephle is waiting for someone to bring up tardis
11:36:42 <ReinH> Well, that's applicative though. It might not be true for the monad instance.
11:36:48 <hannes__1> pdefql: Well yeah. The annotations are of course not necessary most of the time
11:37:04 <hannes__1> pdefql: The point is f is an 'incomplete type' in applicative
11:37:12 <pdefql> right
11:37:18 <hannes__1> pdefql: but f (a -> b) isn't anymore, and neither is f b
11:37:34 <ReinH> pdefql: ((->) a) is a type constructor.
11:37:39 <ReinH> Just like Maybe
11:37:43 <pdefql> right
11:37:53 <pdefql> but it takes 2 parameter right?
11:37:57 <ReinH> Just one.
11:38:05 <ReinH> @kind ((->) e)
11:38:06 <lambdabot> Not in scope: type variable ‘e’
11:38:10 <raek> type constructors are curried too
11:38:11 <ReinH> fine
11:38:20 <pdefql> :k (->)
11:38:21 <lambdabot> * -> * -> *
11:38:47 <pdefql> raek: but where does the second parameter come from?
11:39:28 <pdefql> ReinH: ah i see ((->) a) takes 1 parameter, a is the first one
11:39:28 <ReinH> pdefql: Where does the second parameter come for Maybe?
11:39:45 <ReinH> It is supplied as an argument.
11:40:02 <ReinH> raek: Ah, I think you're right about the Monad instance. Do you recall where you found the video btw?
11:40:05 <ReinH> @djinn (s -> (a, s)) -> (a -> (s -> b, s)) -> (s -> (b, s))
11:40:05 <lambdabot> f a b c =
11:40:05 <lambdabot>     case a c of
11:40:05 <lambdabot>     (d, e) -> case b d of
11:40:05 <lambdabot>               (f, g) -> (f g, e)
11:40:21 <ReinH> Oh, I messed that up
11:40:36 <ReinH> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
11:40:36 <lambdabot> f a b c =
11:40:36 <lambdabot>     case a c of
11:40:36 <lambdabot>     (d, e) -> b d e
11:40:41 <ReinH> That looks better.
11:41:31 <ReinH> raek: (and ofc it's well known that there are more than one possible applicative instances)
11:41:41 <ski> ReinH : i'd say `(->) a' is a type function, but not a type constructor. `(->)' being a type constructor ..
11:41:54 <pdefql> ReinH: why isnt the instnace just declared as 'instance Applicative (->) where...' ?
11:41:59 <pdefql> whats the purpose of the a?
11:42:06 <Hijiri> The thing that's applicative needs to take one type argument
11:42:09 <ReinH> ski: I guess I would say that ((->) a) and Either a are both type constructors.
11:42:09 <Hijiri> (->) takes 2
11:42:11 <ski> @kind (->) Integer
11:42:12 <lambdabot> * -> *
11:42:21 <ReinH> ski: But I could be wrong
11:42:32 <dolio> Integer is a type constructor, too.
11:42:38 <ReinH> pdefql: Applicative requires a type of kind * -> *
11:42:41 <ReinH> @kind (->)
11:42:42 <lambdabot> * -> * -> *
11:42:48 <ReinH> (->) is the wrong kind
11:43:05 <rasen> dolio: isn't Integer a data constructor?
11:43:12 <dolio> No.
11:43:13 <ReinH> dolio: nullary type constructors, the only place we like to talk about nullary functions in Haskell ;)
11:43:28 <dolio> Integer isn't a function.
11:43:30 <raek> Applicative allows one type to vary. (->) allows to types to vary. ((->) e) means keeping the first type constant
11:43:31 <ReinH> rasen: if (say) data Foo = Integer, Integer would be a data constructor
11:43:36 <ski> ReinH : there's different terminology conventions here. i prefer to use the one where "type constructor" looks more similar in spirit to "data constructor", so `Either a' is not a type constructor then. `Either a b' is a concrete type, `Either a' is not (it is a parametric type, or incomplete type, or type function)
11:43:47 <dolio> It's just a constructor. Like True is a constructor.
11:43:48 <ReinH> dolio: sure it is, it's a nullary type function ;)
11:44:00 <ski> (of course `Either' is both a type constructor and a parametric/incomplete type / type function)
11:44:12 <ReinH> ski: I'll buy that.
11:44:15 * hackagebot aws-kinesis-client 0.3.0.0 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.3.0.0 (JonSterling)
11:44:20 <ski> ReinH : and what dolio said
11:44:23 <rasen> yeah. thanks. just found about nullary type constructors
11:44:34 <pdefql> ReinH: is the type that applicative requires determined from the class definition? ie 'pure = f a' ?
11:44:40 <hannes__1> ReinH: Really? I've seen people refer to constants as nullary functions quite a bit; And it's not technically inaccurate to refer to them as such, is it?
11:44:41 <ReinH> dolio: well not, in point of fact, like True. Like Bool perhaps.
11:44:52 <ski> (ReinH : "constructor" doesn't imply "function" :)
11:45:06 <ReinH> ski: It would be reasonable if it did.
11:45:25 * monochrom rekindles "I have a square. is it a rectangle?"
11:45:39 <ReinH> monochrom: :)
11:46:03 <ReinH> hannes__1: "function" in Haskell is generally taken to mean "has (->) as its outermost type constructor"
11:46:16 <ReinH> It's possible, but not very useful, to talk about nullary functions in a mathematical sense
11:46:25 <ski> pdefql : not sure what you're asking about exactly, but if `f' is a type level thing, then `pure = f a' looks like nonsense :/
11:46:25 <hannes__1> fair enough
11:49:13 <ski> hannes__1 : you might find conal's <http://conal.net/blog/posts/everything-is-a-function-in-haskell> interesting (looks like the server is taking a long time to respond atm (down ?). perhaps try <https://web.archive.org/web/20150102162543/http://conal.net/blog/posts/everything-is-a-function-in-haskell>)
11:49:49 <monochrom> there is no single standard. there are multiple conflicting standards.
11:49:56 <ReinH> hannes__1: (If an n-ary operator is a function from X^n -> X, where X^n is the n-fold cartesian product of X, then a nullary function is a function X^0 -> X, or 1 -> X, or a function that selects an X, or a "constant function" of X. Exponentials actually do work out in this way, at least in Set, and Mac Lane and Birhoff use this construction.)
11:50:05 <ReinH> hannes__1: We don't use this in Haskell because, well, it doesn't buy us anything.
11:50:06 <adek> Is there some abstraction, like a monad, around the following use. You have N funcions which might succeed or not. You want to return result of the first call that succeeded.
11:50:15 <monochrom> when you make a definition, you make it for your convenience, not for a platonic thing that some people believe in.
11:50:35 <monochrom> it is more convenient, in Haskell, to say "True is not a function"
11:50:49 <hannes__1> ReinH: I'm just used to using nullary operators for constants in math
11:50:57 <ReinH> hannes__1: yep.
11:50:58 <monochrom> and it is more convenient, in a logic textbook with a different focus, to say "True is a function of arity 0"
11:51:17 <ski> adek : maybe `Maybe' (or `MaybeT m') with `mplus' or `msum' ?
11:51:31 <monochrom> there is no contradiction. the only contradiction is the fiction of "one size fits all"
11:52:01 <ReinH> hannes__1: and in Algebra it's nice to say that algebraic structures consist of a carrier set, some operations, and some laws, so nullary operators are useful for keeping this consistent.
11:52:24 <ski> adek : or `(<|>)' and `asum' for the idiomatic/applicative corresponding operations
11:52:32 <ReinH> hannes__1: But it's also just as common to say "A monoid is a set M together with a binary operator * and _an element of M_ called unit, blah blah
11:52:50 <hannes__1> adek: That's just asum
11:53:10 * ski basically agrees with monochrom
11:53:18 <ReinH> So do I.
11:53:23 <hannes__1> or rather, asum . map . flip ($)
11:53:42 <ski> (some definitions might be inherently less useful, though)
11:53:54 <falsesentence> hi
11:54:12 * ski assumes everything falsesentence says must be false
11:54:17 <ReinH> hannes__1: My definition of "function" makes it meaningfully distinct from "value", and as such an actually useful concept. ;)
11:54:38 <falsesentence> this sentence is false
11:54:43 <ReinH> Otherwise you just have to say "a non-nullary function" everywhere, and that's annoying.
11:55:16 <ReinH> ski: You deserved that one.
11:55:17 <Hijiri> if this sentence is true, then this sentence is false
11:55:26 <ski> ReinH : i did :)
11:55:58 * ski . o O ( coercive logic )
11:56:04 <hannes__1> Hijiri: Your sentence is not 'false' so it is false
11:56:22 <falsesentence> hey, I'm a newbie. I'm working through learn you a haskell, and I have an issue. I can't write a file that says import Applicative or Control.Applicative. It fails with "Could not find module `Applicative'
11:56:24 <falsesentence>     Use -v to see a list of the files searched for.
11:56:24 <falsesentence> Failed, modules loaded: none.
11:56:24 <falsesentence> "
11:56:52 <ReinH> falsesentence: Applicative doesn't exist. What happens when you try Control.Applicative?
11:56:56 <hannes__1> It's called Control.Applicative - what ghc version? Do you have base?
11:57:15 <falsesentence> fasted way to check?
11:57:24 <monochrom> "ghc --version"
11:57:44 <falsesentence> The Glorious Glasgow Haskell Compilation System, version 7.4.1
11:57:52 <monochrom> it has Control.Applicative
11:57:59 <hannes__1> that's old, but it should have applicative
11:58:13 <hannes__1> did you install haskell-platform?
11:58:20 <merijn> hannes__1: base is hardwired into GHC, you can't "not have it" and still have GHC :)
11:58:29 <monochrom> it already comes with GHC
11:58:56 <hannes__1> I choose to believe there's some way to make it not work anyway
11:59:16 * hackagebot Cabal 1.22.1.1 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.22.1.1 (JohanTibell)
11:59:21 <falsesentence> oh grief, it did work. I was confused because at interactive prompt I had to import both Applicative and Control.Applicative
11:59:24 <falsesentence> thanks!
11:59:41 <hannes__1> falsesentence: That doesn't make any sense
11:59:55 <falsesentence> ok
11:59:55 <geekosaur> hannes__1, trivially, find and move/remove ControlApplicative.hi
12:00:00 <hannes__1> falsesentence: It's still Control.Applicative in ghci
12:00:19 <geekosaur> (...if it is not clear, don't do that)
12:00:48 <falsesentence> some of the commands found in LYAH didn't work unless I imported both, but it's all good, because it works, so ... cool
12:01:01 <hannes__1> geekosaur: Yeah, grossly inefficient. rm /**/*.hi much better
12:01:02 <geekosaur> how can you import both? Applicative does not exist
12:01:13 <geekosaur> Control.Applicative does
12:01:24 <hannes__1> unless you define a module called 'applicative' yourself
12:01:25 <falsesentence> *Main Control.Applicative> import Applicative
12:01:26 <falsesentence> *Main Control.Applicative>
12:01:31 <geekosaur> there was never a Haskell98 version of Applicative, as H'98 was obsolete by then
12:01:38 <merijn> falsesentence: yeah, that's not doing anything :)
12:01:42 <Heffalump> is there any documentation on why Control.Monad.Error has been deprecated?
12:01:46 <geekosaur> 7.4's ghci didn't report errors
12:01:53 <geekosaur> that import failed
12:01:57 <merijn> Heffalump: Confusing name, renamed to ExceptT
12:02:04 <geekosaur> (as inidcated by the prompt not changing)
12:02:09 <merijn> Heffalump: Because it's not strictly for errors
12:02:25 <merijn> Heffalump: There was lots of bikeshedding about it
12:02:37 <Heffalump> What's mainly confusing me is why Control.Monad.Except in transformers-compat still seems to have a MonadError class
12:02:48 <Heffalump> am I just kicking the can down the road by changing my import and nothing else?
12:03:34 <Heffalump> also where was the bikeshedding, libraries@?
12:03:37 <merijn> Heffalump: Any change in this area will be slow and with a long deprecation cycle (given how central mtl is), so I think changing the import should be fine
12:03:48 <merijn> Heffalump: Yeah libraries@, but that was probably over a year ago now
12:04:03 <Heffalump> ok, thanks a lot
12:05:56 <pdefql> the kind of a class parameter is inferred from the functions in the instance declaration?
12:06:12 <ReinH> Heffalump: MonadError is still the name of the relevant typeclass.
12:06:12 <Heffalump> pdefql: yes
12:06:30 <merijn> pdefql: Right, although if you wish you can explicitly specify it using the KindSignatures extension
12:06:37 <dolio> ReinH: Is that going to change? It's pretty weird.
12:06:44 <shapr> Heffalump: hiii! I haven't seen you here in a long time!
12:06:50 <Heffalump> ReinH: that was what was confusing me, given that I also had the vague memory that the renaming was because the 'Error' name was considered bad
12:06:57 <ReinH> dolio: No idea. It probably should though.
12:06:58 <Heffalump> why change the module but not the class?
12:07:10 <ReinH> Heffalump: because reasons, probably
12:07:18 <merijn> I'm betting that right now Except just reexports Erro
12:07:20 <Heffalump> :-)
12:07:27 <hannes__1> Heffalump: mv easier than sed
12:09:54 <ski> pdefql : also possibly inferred from the superclass context of the class, if any
12:10:11 <pdefql> ah right ski
12:10:28 <xkb> whats currently the best vim setup for haskell?
12:10:34 <ski> like `class Functor f => Applicative f' already tells you that `f :: * -> *'
12:10:56 <pdefql> ski: does that also mean that f must be an instance of Functor?
12:11:04 <merijn> pdefql: Yeah
12:11:08 <pdefql> ok
12:11:23 <ski> that's the purpose of adding superclass annotations to a `class' declaration, yes
12:11:28 <merijn> pdefql: A constraint in a class declaration means that you can't make instances that don't satisfy the constraint
12:11:42 <pdefql> okay
12:16:36 <ReinH> pdefql: Have you read the typeclassopedia?
12:19:12 <lachenmayer>  is there some way to automatically derive Show for a huge nested ADT so that I can at least print something useful in ghci? I'm trying to debug a compiler, and ideally don't want to touch the source
12:19:49 <clrnd> deriving Show?
12:19:50 <lachenmayer> i know about StandaloneDeriving, but there are too many different types
12:19:58 <clrnd> ohh
12:20:19 <geekosaur> I think the "nested" part may be relevant as well
12:20:43 <lachenmayer> I'd need some sort of recursive "deriving Show" mechanism that looks at the type errors generated, ha.
12:20:49 <geekosaur> (as in, "please derive Show for any type used in here that doesn't already")
12:20:54 <lachenmayer> yes, it's a big AST ADT (hehe)
12:21:02 <lachenmayer> yes, exactly geekosaur
12:21:26 <geekosaur> and I suspect that's either TH or a preprocessor of some kind
12:21:26 <pdefql> ReinH: I dont think ive read that
12:21:28 <xkb> any tips on a vim plugin/module for haskell?
12:22:07 <hannes__1> xkb: As in, 'which' or are you asking about a specific one?
12:22:30 <xkb> hannes__1: which :)
12:22:45 <hannes__1> I'm using neocomplete with neco-ghc
12:23:05 <hannes__1> and syntastic
12:23:11 <merijn> syntastic++
12:23:33 <lachenmayer> also, what is the reason for ADTs not deriving Show by default? it seems to me that any ADT should be printable?
12:23:49 <merijn> lachenmayer: Not all
12:23:58 <hannes__1> lachenmayer: data Read a b = Read (a -> b)
12:24:05 <merijn> lachenmayer: Simple example: "data Foo a b = Foo (a -> b)" <- how do you print functions?
12:24:09 <merijn> Rats!
12:24:12 <merijn> Too slow :p
12:25:05 <hannes__1> merijn: you were faster in wpm though
12:25:08 <Hijiri> even if you could derive Show for everything you might not want to expose what your ADT looks like
12:25:24 <lachenmayer> like so? (f :: (a -> b)), where f is fresh?
12:25:29 <hannes__1> Hijiri: Or worse, Read...
12:25:30 <lachenmayer> Show probably isn't the right thing for this though
12:25:58 <hannes__1> lachenmayer: What do you mean with 'fresh'
12:26:08 <ReinH> @where typeclassopedia
12:26:08 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
12:26:15 <ReinH> pdefql: Might be useful to you
12:27:16 <lachenmayer> hannes__1: as in, it generates 'garbage' names that don't really mean anything - the type is the interesting part, at least for this usecase: debugging/inspecting
12:27:33 <merijn> lachenmayer: How would it figure out the type at runtime?
12:27:44 <merijn> lachenmayer: GHC does type erasing, types don't exist at runtime :)
12:28:17 <poop42> is this chatroom really quiet or do i just not understand irc?
12:28:24 <lachenmayer> ...back to TH/pre-processing then! ;)
12:28:48 <lachenmayer> anyway, silly idea - i'm just a bit miffed that ghci can't print anything useful at all for me
12:29:27 <hannes__1> merijn: Why'd you do it at runtime? I thought we were talking about show instances
12:30:10 <hannes__1> the problem is that this isn't really a show thing, it should rather be DebugDump or something along those lines
12:30:20 <chreekat> poop42: Seems pretty noisy to me
12:30:26 <lachenmayer> i agree hannes__1
12:30:40 <mmachenry> chreekat: Sssh, I'm trying to program.
12:31:03 <ski> lachenmayer : perhaps you can use `:sprint' -- but you'll need to manually force the values (perhaps using `rnf' ?)
12:31:47 <ReinH> lachenmayer: it *could*.
12:31:51 <ReinH> > (+)
12:31:52 <lambdabot>  <Integer -> Integer -> Integer>
12:32:33 <ski> poop42 : people don't talk in here every minute and second (even though it may sometimes appear so) :)
12:34:16 <lachenmayer> hmm, in fact using :print does do exactly what I said, it generates a fresh variable
12:34:25 <lachenmayer> > :print (+)
12:34:26 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:34:38 <lachenmayer> + = (_t3::Num a => a -> a -> a)
12:34:47 <ski> poop42 : in the really slow channels, there may be days or weeks inbetween conversations happening
12:35:08 <Ankhers> Has anyone taken a look at BufferBuilder?
12:35:20 <ski> poop42 : sometimes people have conversations with hours inbetween each person saying something ..
12:35:31 <clrnd> poop42, can you read us lol?
12:36:04 <poop42> i read you :)
12:36:13 <hannes__1> This channel is actually pretty active as far as I'm concerned
12:36:40 <hannes__1> I never go here without finding someone talking about something for longer than maybe a couple minutes
12:37:06 <geekosaur> I have seen it be pretty quiet. (mostly around 0330 US/Eastern...)
12:37:47 <monochrom> this channel is active when I have grading to do, quiet when I have finished grading.
12:37:49 <geekosaur> (still a bit surprising as one would think there'd be a few Haskell users in .au etc.)
12:38:07 <ski> poop42 : assuming you're new to IRC, it may be good to know that many people are logged in to it all day (or even all day and night, 24 hours). obviously they'ren't active all this time. but they frequently check the recent backlog when they next look at IRC, possibly catching up with some interesting conversation or messages from someone
12:38:45 <poop42> i was in this chatroom at 2 am yesterday and (big surprise) it was pretty silent
12:38:54 <ski> poop42 : so, you can't expect to always be able to catch someone sitting at IRC. this is why it's important to wait after asking a question (at least half an hour, preferably hours, in slow channels)
12:39:41 <hannes__> one of these days I"m gonna figure out irssi
12:40:28 <rabipelais> Hello. Can I recover the value of a type-level literal? What I mean is: let's say I have `data Foo (n :: Symbol) v = Foo v` and I declare `foo = (Foo 1 :: Foo "test" Int)`. Is there a way to get back the "test" in a function?
12:40:31 <merijn> poop42: 2 am which time zone?
12:40:39 <poop42> eastern
12:40:51 <merijn> poop42: Also see http://ircbrowse.net/haskell for activity graph :)
12:41:03 <hannes__> rabipelais: yes
12:41:07 <merijn> rabipelais: Yes, but it's kinda tricky, so I always forget how
12:41:45 <hannes__> rabipelais: I forget how, but it involves the KnownSymbol / KnownNat classes somehow
12:41:50 <ski> poop42 : unfortunately, i've seen lots of newbies ask a question, wait maybe 5 minutes, then leave. perhaps half an hour later, i notice someone has said anything, see that i could have given a useful answer, but can't because they've already left (and who knows whether they'll be back anytime)
12:41:59 <rabipelais> Everything I find involves some type `Proxy`
12:42:10 <hannes__> rabipelais: yeah that sounds right
12:42:24 <merijn> rabipelais: Yeah, proxy is just "data Proxy a = Proxy"
12:42:38 <merijn> rabipelais: It's basically a "phantom type holder"
12:43:00 <rabipelais> and theres the function `symbolVal :: KnownSymbol n => proxy n -> String`
12:43:38 <merijn> > natVal (Proxy :: Proxy 5)
12:43:39 <lambdabot>  Not in scope: ‘natVal’
12:43:43 <merijn> hmmm
12:43:51 <rabipelais> what I don't understand is what relationship do Proxy and my type Foo have
12:43:51 <merijn> > GHC.TypeLits.natVal (Proxy :: Proxy 5)
12:43:52 <lambdabot>  Not in scope: ‘GHC.TypeLits.natVal’
12:44:11 <rabipelais> > Data.Symbol.natVal (Proxy :: Proxy 4)
12:44:13 <lambdabot>  Not in scope: ‘Data.Symbol.natVal’
12:44:15 <hannes__> rabipelais: then you really just `getMyNumber :: Foo n s -> Proxy n` and `getMySymbol :: Foo n s -> Proxy s`
12:44:18 <merijn> rabipelais: Well, you need to somehow reference the Symbol type so GHC can obtain the right typeclass instance
12:44:30 <rabipelais> > Data.Proxy.natVal (Proxy :: Proxy 4)
12:44:31 <lambdabot>  Not in scope: ‘Data.Proxy.natVal’
12:44:50 <merijn> rabipelais: But, since you can't have values with kinds other than *, you can't directly pass 5 or "foo" to a function, because what value would that have
12:45:03 <merijn> rabipelais: The Proxy's only goal is to be a carrier of the Symbol/Nat type
12:45:50 <merijn> rabipelais: Import Data.Proxy and GHC.TypeLits in ghci and run "symbolVal (Proxy :: Proxy "foo")"
12:46:35 <poop42> can i create variables in ghci?
12:46:53 <merijn> rabipelais: "symbolVal :: forall n proxy. KnownSymbol n => proxy n -> String" <- here the proxy is just a type variable so it doesn't REQUIRE you to use Proxy, if you happen to have another type lying around you can use that too
12:47:31 <merijn> rabipelais: So if you have "data Foo :: Symbol -> * where Foo :: Foo "bar"", then you can just use "Foo" directly as argument to symbolVal
12:47:55 <merijn> rabipelais: And KnownSymbol is just the typeclass that lets you go from type to value
12:48:36 <ski> poop42 : yes, like `let myNumber = 42', or `let myFunction x = 1 + x*x'
12:48:53 <poop42> thanks
12:49:14 <ski> poop42 : if you also want a type signature, use `;', like `let myFunction :: Integer -> Integer; myFunction x = 1 + x*x'
12:49:15 <hannes__> you need let because ghci is *almost* just running your code as a large IO action
12:49:38 <ski> poop42 : if you want multiple defining equations (for pattern-matching), also separate them with `;' on the same GHCi line
12:49:50 <hannes__> with various specialities, like allowing type definitions and imports, etc
12:50:10 <ski> (it is also possible to use `:{' and `:}' in GHCi to give one line at a time of a multi-line declaration/definition, if you prefer that)
12:50:33 <poop42> thanks
12:50:33 <hannes__> or just `:set +m`
12:50:38 <merijn> Generally it's recommend to work in a text editor and just load the file into ghci
12:50:44 <merijn> Using ":load foo.hs"
12:50:49 <merijn> And/or ":reload"
12:50:50 <poop42> i've been doing that also
12:51:27 <ski> hannes__ : oh, haven't noticed that one before :)
12:52:05 <hannes__> yeah, it can get a bit annoying at times because it doesn't always know when your declaration is over, so you have to hit double enter...
12:52:08 <rabipelais> merijn: I see. That works. Is there then a type-level `flip` function? Because if I redefine my `Foo` to be `data Bar v (n :: Symbol) = Bar v` I can then do as intended `bar = (Bar 1 :: Bar Int "blub)` and `symbolVal bar` gives me blub
12:52:13 <hannes__> and anything that requires indention is kind of a pain
12:52:14 <ski> hannes__ : i noticed :)
12:52:45 <rabipelais> however, with Foo (notice the ordering of the type variables) I get, rightly, a kind mismatch
12:52:45 <hannes__> rabipelais: You don't need that
12:53:19 <hannes__> rabipelais: just define `fooNat :: Foo n s -> proxy n; fooNat = undefined;`
12:53:40 <hannes__> and then `natVal (fooNat yourFoo)`
12:54:02 <poop42> is a string just a list of characters?
12:54:05 <JagaJaga> Guys, how can I get using haskell (and it's libs ofc), whereis my ghc? Maybe inspecting $PATH. Because some projects are using `ghc-paths` and it's working incorrect.
12:54:09 <c_wraith> poop42: yes
12:54:18 <hannes__> poop42: the String type is just an alias for a list of characters
12:54:19 * hackagebot smoothie 0.1.0.0 - Smooth curves via several spline and polynomials.  http://hackage.haskell.org/package/smoothie-0.1.0.0 (DimitriSabadie)
12:54:28 <hannes__> poop42: But that's not necessarily the best representation
12:54:33 <hannes__> in fact, it often isn't
12:54:34 <adek> ski: Going back to asum answer. So it seems like I will have to have a definition of my alternative which would alway return first success?
12:55:01 <poop42> what do you mean it's not the best representation?
12:55:03 <hannes__> adek: That's called maybe
12:55:27 <geekosaur> JagaJaga, I am not sure what you are asking... much less what environment you are in
12:55:49 <adek> hannes__: oh, so the whole idea is to run asum fs, where fs :: String -> Maybe Obj
12:55:59 <hannes__> poop42: Because linked lists don't have random access, require a lot of space, aren't cache friendly
12:56:19 <poop42> thanks
12:56:47 <hannes__> etc etc you can probably find better explanations in the bytestring and text packages respectively
12:56:58 <ski> adek : well, run `asum' on a list of `String -> Maybe Obj's .. or combine them directly with `<|>'
12:56:58 <ReinH> hannes__: I would say that it almost never is.
12:57:12 <phaazon> do you have the script to send haddock documentation on hackage?
12:57:29 <JagaJaga> geekosaur: this PR can explain everything https://github.com/simonmar/ghc-paths/issues/4
12:57:37 <JagaJaga> geekosaur: this issue ofc
12:57:41 <hannes__> ReinH: Well, it does the advantage of being easy to pattern match on
12:58:27 <rabipelais> hannes__: thanks, that seemed to do the trick
12:59:59 <rabipelais> now I forgot what I was originally trying to solve
13:00:12 <hannes__> rabipelais: Oh it'll come back to you
13:00:23 <hannes__> rabipelais: If not, it probably wasn't that important
13:01:02 <adek> ski: perfect, thanks!
13:01:47 <adek> Overall, is typeclassopedia a place to look for this generalized patterns? Sometimes I encounter things like that and I would supernice to be able to know its actual name and not reinvent the wheel
13:02:28 <merijn> adek: typeclassopedia covers the most obvious basics
13:03:28 <adek> merijn: a more complex example would be for example futures implementation, it also seems to have rather monadic base. Probably can be reduced to Maybe or Either
13:04:00 <phaazon> do the haddock documentation automatically builds now?
13:04:03 <phaazon> build*
13:04:35 <merijn> adek: futures are monads, yes (at least any sensible implementation)
13:04:43 <merijn> adek: Take a look at the async library, for example
13:05:33 <adek> I am looking at it from perspective of C++, but as Bartosz Milewski noted on his blog posts all languages seem to import ideas from category theory, monads etc nowadays. I find Haskell solutions very inspiring and often help me write better code in imperative languages knowing how things are done in Haskell.
13:06:11 <phaazon> yeah, Haskell rules. :)
13:06:32 <merijn> Bartosz' posts are great
13:06:38 <ralu> nice future implementation in C++ provides asio
13:06:39 <hiptobecubic> They are pretty funny
13:07:32 <ralu> it is actualy async i think
13:08:17 <darthdeus> hey guys, if anyone has a sec, I'd really appreciate any ideas :) http://www.reddit.com/r/haskell/comments/2wwm0o/suggestions_for_a_semestral_project_in_haskell/
13:09:20 * hackagebot hexpat 0.20.9 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.20.9 (StephenBlackheath)
13:10:09 <TheLemonMan> oh, the joy of finding that there's a semigroup package :> I think that should be part of the Base library
13:11:15 <S11001001> TheLemonMan: you want semigroups, not semigroup :)
13:11:15 <tejasmanohar> anyone here familiar w/ graphing flower shapes with polar functions
13:11:18 <tejasmanohar> ?
13:11:45 <TheLemonMan> S11001001, my pinkie slipped over the trailing s :)
13:12:16 <c_wraith> tejasmanohar: things like r = sin (2*theta) ?
13:12:26 <c_wraith> or, well, make it like 5*theta
13:13:02 <rasen> tejasmanohar: what's the question?
13:13:59 <tejasmanohar> rasen: im trying to graph http://goo.gl/XwsjgP or something that looks like it in the structure of petals
13:14:03 <tejasmanohar> c_wraith: yeah
13:14:15 <tejasmanohar> i have r=cos(2*theta) right now
13:14:41 <c_wraith> tejasmanohar: this might not be the perfect channel for the topic
13:14:44 <tejasmanohar> or i guess r = sin ( 2*theta) is a better place to startup from that flower c_wraith?
13:14:51 <tejasmanohar> c_wraith: oh i thought this is math :\
13:15:34 <tejasmanohar> i think cos > sin for this type of flower
13:15:54 <tejasmanohar> oh snap wrong channel i thought this was #math-- either way c_wraith rasen are you guys familiar w/ this? im kinda stumped i can PM you?
13:16:10 <c_wraith> tejasmanohar: the difference between sin and cos is just rotation.  Not important.
13:16:51 <tejasmanohar> c_wraith: yeah realized that now
13:17:20 <tejasmanohar> c_wraith: but in the photo i provided there are 3 big petals but r = cos(2*theta) gives me 4 big petals how do i fix this or impossible
13:17:33 <poop42> aww...how come i can prepend a list to a list variable containing lists but i cant prepend a list to a list variable?
13:18:12 <rasen> poop42: you can append lists
13:18:43 <poop42> i did this [1,2,3]:b for my list b and it gave me an error
13:19:16 <hannes__> poop42: Because : is for cons'ing elements, not for appending lists
13:19:29 <hannes__> poop42: a -> [a] -> [a] vs [a] -> [a] -> [a]
13:19:51 <poop42> why does this work fine then [1,2,3]:[4,5,6]
13:19:54 <clrnd> :t (++)
13:19:55 <poop42> ?
13:19:55 <lambdabot> [a] -> [a] -> [a]
13:20:03 <hannes__> poop42: It doesn't. You're lying.
13:20:06 <ralu> 1:2:3:[4,5,6]
13:20:07 <clrnd> liar!
13:20:19 <ReinH> poop42: It doen't work fine.
13:20:21 <poop42> you're right, sorry
13:20:59 <ralu> :t (:)
13:21:00 <lambdabot> a -> [a] -> [a]
13:21:00 <geekosaur> > [1,2,3]:[]
13:21:02 <lambdabot>  [[1,2,3]]
13:21:09 <geekosaur> notice it's now a list inside a list
13:21:15 <poop42> oh i see, thanks
13:21:53 <geekosaur> because for the type to work, the empty list must have been a list of lists of Integer
13:21:59 <poop42> i guess that explains why i can do 1:[2]
13:21:59 <ralu> why is this correct?
13:22:33 <geekosaur> ralu, I'm not sure what you are asking?
13:22:37 <ralu> i would expect [1,2,3]:[[]] to be correct
13:22:54 <hannes__> ralu: That'd be [[1,2,3],[]]
13:23:07 <ReinH> [] is an empty list of lists
13:23:09 <monochrom> > [1,2,3] : [[]]
13:23:11 <lambdabot>  [[1,2,3],[]]
13:23:12 <ReinH> [[]] is a non-empty list of lists
13:23:16 <monochrom> it is legal, yes.
13:23:40 <geekosaur> [] is an empty list of any valid list type. [[]] is a list containing an empty list of some unknown type
13:23:57 <monochrom> if you want to see the types: let a=[Integer].
13:24:22 <monochrom> (but not a=Integer)
13:24:37 <hannes__> monochrom: pseudo code? Wasn't obvious to me at first
13:24:52 <poop42> is there a difference between a number and a list with 1 number?
13:24:57 <monochrom> which piece of code are you referring to?
13:24:59 <hannes__> poop42: Yes
13:25:28 <monochrom> I said I wished pronouns be banned. my wish was granted. now people simply omit all subjects!
13:25:30 <dfeuer> @ask hvr Why isn't https://github.com/haskell/vector/commit/fe6832130997de3d647c1d67aeb7043e5dd47a25 (adding the ifoldM family to Data.Vector) in the version of vector on Hackage? It's from 2013!
13:25:30 <lambdabot> Consider it noted.
13:25:33 <geekosaur> > [1] + [2] -- error
13:25:34 <lambdabot>  No instance for (GHC.Show.Show t0)
13:25:34 <lambdabot>    arising from a use of ‘M30101579839109763451493.show_M30101579839109763451...
13:25:34 <lambdabot>  The type variable ‘t0’ is ambiguous
13:25:38 <hannes__> poop42: Actually, they don't really have anything in common. Philosophically they may be considered similar, but mathematically they're completely different objects
13:25:43 <geekosaur> no Num instance for lists
13:26:08 <ski> > [1,2,3] ++ [4,5,6]  -- poop42, this is appending lists
13:26:08 <ralu> ++
13:26:10 <lambdabot>  [1,2,3,4,5,6]
13:26:25 <dfeuer> monochrom, what is this about banning pronouns?
13:26:36 <ralu> > 1+1
13:26:38 <lambdabot>  2
13:27:04 <hannes__> dfeuer: So we can't play the pronoun game anymore
13:27:09 <monochrom> people saying "it" or "that" after a sentence talks about 3 things so it is completely unknown what the pronoun refers to.
13:27:25 <hannes__> but that defeats like half the point of irc
13:27:32 <hannes__> to keep you from doing actual work
13:27:54 <monochrom> or even better, saying "it" twice and there is no way both refer to the same thing.
13:28:20 <dfeuer> monochrom, well, the best answer I know of is the one used in ASL, which makes it quite easy to index multiple things.
13:28:33 <dfeuer> But that's hard to deal with on IRC, and I'm far from fluent anyway.
13:28:59 <mswan> Does anyone know of some program that could generate Vim-compatible CTAGS that is Template Haskell conscious?
13:29:04 <monochrom> is ASL "American Sign Language"?
13:29:06 <ski> dfeuer : "ASL" ?
13:29:06 <geekosaur> use tagged holes instead. _1, _2, ...
13:29:18 <dfeuer> ski, monochrom identified it correctly, yes.
13:29:21 <ski> oh, direction-indexed pronouns
13:29:26 <hannes__> dfeuer: asl? So we are to communicate in ascii art of sign language now? Neat.
13:29:28 <monochrom> yeah, I asked Google :)
13:29:59 <hannes__> except it's gonna suck for people with small terminals
13:29:59 <dfeuer> hannes__, there is a semi-experimental writing system for it.
13:30:30 <monochrom> logic people came up with the idea of using dummy variables for this. I like variables. but I guess tagged holes are just as good.
13:30:49 <hannes__> dfeuer: Huh, I'd expect most people who know ASL to be able read english
13:30:54 <merijn> monochrom: I think that might be an issue with non-native English speakers
13:31:01 <hannes__> is that wrong?
13:31:13 <merijn> monochrom: I often have to rewrite my sentences due to English' incredibly poor ability to disambiguate pronouns
13:31:27 <dfeuer> hannes__, most of them (esp. most of the ones who live in the U.S.) are, yes.
13:31:32 <dfeuer> But that's not the point.
13:31:34 <merijn> monochrom: Dutch and German (for example) will easily have 3 times as many pronouns without confusion
13:31:49 <dfeuer> The point was that ASL is a language that offers a good solution to the pronoun problem.
13:31:53 <merijn> I usually don't notice until rereading
13:33:06 <hannes__> dfeuer: So is haskell. let it = "a nice book" in ...
13:33:36 <dfeuer> hannes__, yep.
13:36:37 <Xenasis> Hey folks, trying to put multiple putStrLns in Main, but it's taking the second line as a third argument to putStrLn
13:36:58 <Clint> are you using do notation?
13:37:19 <Xenasis> I'm pretty sure I am, assuming it extends inside if statements
13:37:26 <davean> no
13:37:32 <Xenasis> ah
13:37:38 <Xenasis> that'd be my problem
13:37:41 <davean> put another do
13:37:54 <Xenasis> It worked for the else so I assumed it would for the "then"
13:37:57 <Xenasis> odd!
13:37:58 <Xenasis> thanks
13:38:05 <ralu> :t (>>)
13:38:06 <lambdabot> Monad m => m a -> m b -> m b
13:38:20 <hexagoxel> Xenasis: uh oh.. it did not work for else(!)
13:38:22 <davean> Xenasis: it didn't work for else either :)
13:38:32 <Xenasis> It definitely does work for else
13:38:46 <hexagoxel> syntactically it does, but not what you want :)
13:38:47 <hannes__> Xenasis: It's unclear what you mean
13:38:47 <rasen> Xenasis: maybe, you have a single command in else?
13:38:52 <hannes__> Xenasis: code
13:38:55 <acowley> dysinger: So I ran into a build problem with cabbage and rifactor wherein unix-2.7.1 won't build for me.
13:38:59 <merijn> @where lpaste
13:38:59 <lambdabot> http://lpaste.net/
13:39:17 <acowley> dysinger: Weirdly, I setup a test project that depended on any version of unix, and cabal picked 2.7.0.1 which built fine!
13:39:18 <Xenasis> aha, so do works if there's one function call but not many o.o
13:39:32 <hannes__> Xenasis: No that's not it
13:39:50 <rasen> Xenasis: you can think of do as a glue when you want multiple commands
13:39:56 <davean> Xenasis: Well, do builds a function
13:40:02 <davean> Xenasis: A function is a function
13:40:06 <hannes__> Xenasis: It's just that function calls and 'multiple' don't quite work like you think they do
13:40:06 <dysinger> @acowley this project is tricky in that I’m using amazonka libs which expect 7.10’s ‘time’ package. if you build with 7.8.4 you have to force reinstall
13:40:06 <lambdabot> Unknown command, try @list
13:40:07 <davean> then and else take a function
13:40:08 <acowley> dysinger: I think this is because unix is bundled with GHC so I've probably never built it before
13:40:10 <Xenasis> I get that it's syntactic sugar for >>=
13:40:27 <rasen> not only
13:40:30 <dysinger> @acowley I just tried upgrading to ghcHEAD in the branch to see if that’s easier
13:40:30 <lambdabot> Unknown command, try @list
13:40:32 <Xenasis> and >> and etc
13:40:49 <acowley> dysinger: Yeah, be sure to change shell.nix to point to the GHC and cabal-install you want to use
13:40:58 <merijn> Xenasis: Paste the code on lpaste
13:41:15 <dysinger> @acowley I’ve been doing that.  Still don’t understand why nix-shell —run errors
13:41:15 <lambdabot> Unknown command, try @list
13:41:22 <acowley> dysinger: Also, you know more about these things that I do, so tell me what I should be recommending instead of the 'sh $setup' line
13:41:27 <Xenasis> okay, yeah, adding in another do worked, thanks
13:41:29 <acowley> dysinger: I guess I'm assuming 'sh' is bash
13:41:31 <dysinger> probably not :)
13:41:37 <Xenasis> (I don't want to post it on lpaste because it's for an assignment)
13:42:20 <dysinger> @acowley probably you know more about nix than me. (is what I meant).
13:42:20 <lambdabot> Unknown command, try @list
13:42:27 <acowley> dysinger: Well, I'm guessing this will work with 7.10 if we can sort out the sh business
13:42:35 <glguy> dysinger: Please stop using @ to address people, it triggers the bot
13:42:39 <acowley> dysinger: Probably eval("$setup") would work
13:42:41 <dysinger> sorry
13:42:47 <dysinger> too much twitter
13:42:49 <ski> davean : "do builds a function" ?
13:42:49 <rasen> dysinger: ls -l `which sh`
13:42:58 <davean> ski: no
13:43:08 <davean> ski: not technically
13:43:13 <davean> ski: But I didn't mean technically
13:43:17 <ski> just wondering what you meant
13:43:28 <hannes__> ski: It does when you're in the reader monad
13:43:32 <davean> ski: I meant it in the "builds a single thing that does something" sense
13:43:54 <acowley> dysinger: But I'd like to figure out how to deal with what unix-2.7.1's configure script is trying to do when it builds as nix is currently preventing it.
13:44:14 <hannes__> davean: I don't know, do lists do something? I get the whole 'lie to children' attitude but I'm not sure this helps
13:44:18 <jophish> ghc.haskell.org is down, right?
13:44:22 * hackagebot xml 1.3.14 - A simple XML library.  http://hackage.haskell.org/package/xml-1.3.14 (IavorDiatchki)
13:44:55 <ski> hannes__ : i know (and also in state monad or continuation monad), but i wasn't sure whether hannes__ was talking about any such thing
13:45:10 <TheLemonMan> is there a way to let ghc slap me every time I use the do notation ?
13:45:36 <geekosaur> ghc.haskell.org is up, just redirects to haskell.org/ghc
13:45:42 <davean> hannes__: he was talking about IO
13:45:47 <ski> davean : i suppose i still don't understand. nvm
13:45:52 <ReinH> TheLemonMan: no? There's nothing wrong with do notation.
13:46:07 <davean> hannes__: he called it a function, so I didn't debate terminilogy
13:46:22 <davean> hannes__: There is a perfectly reasonable, non-technical definition of function that fits his usage
13:46:26 <hannes__> TheLemonMan: Write a 'NoMonadicDo' extension if it bothers you that much
13:46:54 <quchen> LANGUAGE CPP; #define do "dobiedobiedo"
13:46:55 <quchen> Solved
13:47:06 <ab9rf> hee
13:47:47 <ski> > let in do let {}; do ()
13:47:48 <hannes__> quchen: #define do #error "No"
13:47:49 <lambdabot>  ()
13:48:54 <rasen> ski: didn't get what just happened
13:49:02 <quchen> ReinH: To be fair, "fail" is wrong with do notation.
13:49:17 <raek> #define do don't
13:49:25 * hackagebot http-server 1.0.6 - A library for writing Haskell web servers.  http://hackage.haskell.org/package/http-server-1.0.6 (IavorDiatchki)
13:49:27 * hackagebot hackernews 0.3.1.1 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.3.1.1 (DavidJohnson)
13:49:36 <ski> rasen : just some nonsense. feel free to ignore
13:50:02 <quchen> ski: It's a stress-test for human Haskell parsing!
13:50:38 <shachaf> > let in do let {}; do () :: () :: () :: () :: ()
13:50:39 <lambdabot>  ()
13:50:50 <ab9rf> decorative
13:51:06 * ski . o O ( "how come the consing doesn't appear to work there ?" )
13:51:31 <shachaf> It's type-level consing, obviously.
13:51:35 <shachaf> Not visible in the value.
13:51:55 <rasen> Lol. It's not consing
13:52:00 <dolio> shachaf: That's pretty tricky.
13:52:27 <hannes__> I'm bad at parsing
13:52:41 <hannes__> fortunately we have automatic parsers for stuff like that
13:53:02 <shachaf> > Just $ do 1 :: Double
13:53:04 <rasen> Ok. I got it
13:53:04 <lambdabot>  Just 1.0
13:53:06 <shachaf> It's a great trick.
13:53:09 <ab9rf> computers are far better at dealing with such details than i am
13:53:17 <shachaf> @quote cmccann ::.*::
13:53:17 <lambdabot> cmccann says: :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
13:53:44 <glguy> > Just $ do do 1 :: Double -- in case you think it needs to be a little more forceful
13:53:46 <lambdabot>  Just 1.0
13:53:59 <rasen> > let in 5 -- the main trick
13:54:00 <lambdabot>  5
13:54:35 <ralu> >let 5 6
13:54:47 <ralu> > let 5 6
13:54:48 <lambdabot>  <hint>:1:8:
13:54:48 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:55:45 <rasen> `in` is must
13:56:11 <dolio> shachaf: I'm amazed; ermine also parses things that way.
13:56:19 <dolio> I would have bet we failed to do that.
13:56:20 <monochrom> interesting
13:56:23 <ski> some people don't know that you don't need `where' in `class',`instance' declarations (and GADT declarations), in case you're not planning to include any items after the `where'
13:57:09 <dolio> ski: The GADT one is probably new and requires EmptyDataDecls?
13:57:16 <monochrom> I didn't know that. or sometime told me but I disbelieved.
13:57:42 <monochrom> hmm, do I have hugs around so I can check that one too? :)
13:57:58 <monochrom> but I have something better. I have the Haskell 2010 Report!
13:58:21 <geekosaur> ...and endless optimism that everyone implements it properly >.>
13:58:27 <monochrom> indeed, the report agrees.
13:58:43 <ski> dolio : hm. iirc, it's been working for some time. maybe `GADTs' imply `EmptyDataDecls' ?
13:58:43 <cmccann> for consistency, I think "module Foo" should be legal iff "module Foo where" would be legal and the module is empty
13:59:03 <monochrom> oh, my concern is this: I can test that GHC supports it, so now my question is "is it GHCism?"
13:59:07 <dolio> ski: I think GADTs predates EmptyDataDecls. Maybe it was working with GADTs on, though.
13:59:15 <ski> monochrom : *nod*
13:59:31 <quchen> Can someone explain why that works?
13:59:42 <rom1504> magic
13:59:47 <monochrom> my question can be answered one of two ways. test hugs. see the report.
14:00:08 <monochrom> the rest is merely "path of least resistance"
14:00:14 <dolio> quchen: Why what works?
14:00:39 <rasen> monochrom: report is better
14:00:40 <cmccann> another fun bit of syntax is that comments are considered whitespace
14:00:41 <quchen> dolio: Those chained "::" oddities from above (that I assumed you were still talking about)
14:00:57 <cmccann> so you can have block comments as part of the whitespace used for layout
14:01:04 <dolio> quchen: It parses as: (do () :: ()) :: ()
14:01:06 <dolio> And so on.
14:01:40 <quchen> dolio: Sure, but why is it special for "do"? () :: () :: () gives me a parse error
14:02:06 <monochrom> yeah, it is "expr ::= expr :: type | ..." exploited a few times
14:02:12 <rasen> cmccann: it's kind of OK. But the code would look weird
14:02:37 <quchen> > () :: () :: () -- but then why doesn't this work, monochrom?
14:02:38 <lambdabot>  <hint>:1:10: parse error on input ‘::’
14:02:47 <jophish> Could someone take a quick look at this issue, I get the feeling that this should be a quick fix because it used to work (I presume with an earlier version of ghc) https://github.com/basvandijk/regions/issues/9 My type-family-foo isn't strong enough to fogure it out though. I'm trying to compile regions from master
14:02:54 <dolio> quchen: Because that is parsed as () :: (() :: ())
14:02:54 <monochrom> alright, I was sloppy. it was just the rough idea.
14:03:04 <dolio> Or, not parsed, really.
14:03:21 <ski> presumably because it treats `do () :: ()' as "atomic" in some syntactic sense, so that `:: ()' can be postfixed to it
14:03:29 <ocharles_> Huh... any TH gurus around? Confused that $([| (const False) True |] >>= stringE . show) doesn't contain a ParensE
14:03:33 <merijn> jophish: I haven't looked at the issue, but know that due to a bug 7.6 was too lenient in what it accepted for type families
14:03:38 <merijn> jophish: i.e. it accepted wrong things
14:03:50 <ocharles_> I would expect AppE ParensE ConE shape
14:04:04 <jophish> merijn: this? https://ghc.haskell.org/trac/ghc/ticket/4259
14:04:25 <quchen> monochrom: I'm confused because the "do" changes the associativity of the "::", not because of sloppiness
14:04:31 <jophish> carter said he'd have a think about it two years ago :)
14:04:59 <dolio> quchen: () :: () is an illegal type expression. And type annotations extend as far as possible in a given scope while still parsing.
14:05:24 <cmccann> rasen: http://lpaste.net/86610
14:05:25 <dolio> So 'do () :: ()' parses but 'do () :: (() :: ())' does not.
14:05:40 <dolio> So it is instead parsed as '(do () :: ()) :: ()'.
14:05:53 <cmccann> rasen: that was from a previous conversation but I found it just for you
14:06:12 <rasen> cmccann: it's ok if you mentally ignore comments
14:06:13 <dolio> Because that extends as far as possible while still parsing.
14:06:30 <quchen> dolio: And that "parse as far as you can" is something enabled by "do"?
14:06:41 <dolio> It is a general parsing rule.
14:07:02 <dolio> do (() :: () :: ()) is a parse error.
14:07:02 <quchen> dolio: But then why doesn't ()::()::() parse for the same reason?
14:07:27 <dolio> So the do's scope can only extend as far as (do (() :: ()))
14:07:53 <dolio> :: doesn't work that way, I guess.
14:08:15 <dolio> It doesn't introduce a scope, it just eats up whatever it's in.
14:08:34 <dolio> I guess it actually has to do with layout.
14:08:44 <dolio> To some degree.
14:08:56 <dolio> do { () :: () } :: ()
14:09:10 <quchen> Sounds hacky.
14:09:26 <dolio> Apparently it is the least hacky thing you can do.
14:09:47 <dolio> Because we automatically parse this way in ermine, and we didn't make any effort to do so.
14:10:24 <dolio> You can't do the 'do' but you can do the let-in.
14:11:03 <cmccann> dolio: I imagine it also handles my weird syntax example which shachaf made lambdabot quote
14:11:04 <quchen> Then it might not hacky after all, and an emergent oddity of the parser. :-D
14:12:37 <shachaf> It would be nice if e.g. "f do x" meant "f (do x)"
14:12:47 <dolio> cmccann: Yes.
14:12:48 <merijn> Word
14:12:51 <shachaf> I don't think doing that with do/case/let/etc. would cause an ambiguity.
14:13:05 <shachaf> Or with lambdas.
14:13:15 <hpc> lambdas are the one that really matters
14:13:25 <dolio> cmccann: In ermine it looks like:  f -> x -> f x : Int : Int -> Int : (Int -> Int) -> Int -> Int
14:13:50 <cmccann> dolio: ooh, I like that. it's even more cryptic-looking.
14:13:56 <dolio> shachaf: I think it would make magic $ be unnecessary, too.
14:14:06 <dolio> Which would be nice.
14:14:08 <shachaf> Yes.
14:14:16 <cmccann> un-magic-ifying $ is the best argument for what shachaf wants
14:14:31 <shachaf> cmccann: Does that work for anything I want or just for this syntax?
14:14:32 <fragamus> Has anyone signed up for NFP conference at JPL
14:14:32 <cmccann> it's something I've heard people suggest many times
14:14:46 <fragamus> When I tried, it sent no confirmation email
14:15:09 <cmccann> shachaf: not sure what you mean
14:15:20 <rasen> @src ($) -- shachaf
14:15:20 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
14:15:33 <rasen> ok.
14:15:43 <hpc> rasen: the magic is much deeper than the definition
14:15:44 <rasen> f $ x = f x
14:15:46 <dolio> rasen: The magic will not be visible in the definition anyway.
14:16:13 <rasen> Am I wrong?
14:16:15 <hpc> it has to do with types like ST, where type inference falls down
14:16:19 <dolio> No, that is correct.
14:16:20 <quchen> rasen: $ has a couple of "magic" properties to make it work with higher-rank types
14:16:32 <hpc> and can't determine which types are the same correctly
14:16:38 <rasen> quchen: hmmm... didn't know about that
14:17:03 <fragamus> Correction: NFM
14:17:10 <merijn> rasen: Basically, the typechecker has a special case for $ to make it work with the runST (and other RankN) functions
14:17:21 <hpc> it's one of those things you don't ever hear about until it's the end of the world
14:17:23 <quchen> rasen: When your perfectly fine ST "do" block fails with an obscure error message it's time to check whether you've got a "$" before it, just as a takeaway message. ;-)
14:18:37 <rasen> quchen: oh.. that's probably the problem I encountered once
14:18:38 <geekosaur> I thought it was trying to use (.) that triggered the weird error message, specifically because ($) has a typechecker hack?
14:19:27 * hackagebot atlassian-connect-descriptor 0.4.0.0 - Code that helps you create a valid Atlassian Connect Descriptor.  http://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.0.0 (RobertMassaioli)
14:19:59 <quchen> geekosaur: That's how I stumbled upon it as well
14:22:40 <quchen> rasen: Note that this isn't a property of the "dollar function", but it's a proper special syntactic form.
14:22:58 <quchen> > runST $ return 1
14:23:02 <lambdabot>  1
14:23:04 <quchen> > ($) runST (return 1)
14:23:10 <tejasmanohar> rasen: i got the other flower but any idea how to attack this one? http://goo.gl/Nbsh36
14:23:10 <lambdabot>  Couldn't match type ‘m0 a0’ with ‘forall s. GHC.ST.ST s a’
14:23:12 <lambdabot>  Expected type: m0 a0 -> a
14:23:13 <monochrom> w00t, the survey is done, SPJ now recomments FTP
14:23:14 <lambdabot>    Actual type: (forall s. GHC.ST.ST s a) -> a
14:23:21 <quchen> monochrom: REJOICE!
14:23:26 <quchen> \o/
14:23:31 <dfeuer> carter, I *did* run into trouble with roles trying to implement map/coerce for vector. I still don't understand why. My workaround, if it works: forall (s::Stream Id a) . map coerce s = unsafeCoerce
14:26:05 <dfeuer> monochrom, recomments = recommends or = rewrites the comments for?
14:26:12 <monochrom> recommends
14:26:34 <quchen> "Bottom line: we recommend Plan FTP."
14:27:40 <silver> File Transfer Protocol?
14:28:00 <quchen> Foldable/Traversable Proposal
14:28:05 <dfeuer> Ahhh.....
14:28:16 <monochrom> :)
14:28:34 <monochrom> "we recommend the Haskell website to ditch http and switch to ftp" yeah!
14:28:44 <silver> :D
14:28:47 <Clint> no, gopher
14:29:15 <quchen> monochrom: HTTP insecure because of Lenovo breach, switching to HTTPS
14:29:23 <dfeuer> I have mixed feelings about FTP, but I do think reverting it would have set back 7.10 by several months and thrown Hackage into disarray.
14:29:44 <dfeuer> quchen, don't you mean switching to SFTP?
14:30:12 <quchen> dfeuer: You can't correct that sentence with a single statement. :-þ
14:30:28 <dulla> all I know is that lenovo is nuking ssl/ssh
14:30:30 <merijn> I'd be okay with 7.10 being delayed if that means the improved GADT coverage check makes it in :P
14:30:40 <hpc> ftp is insecure
14:30:43 <hpc> switch haskell.org to zmodem
14:30:48 <josephle> dulla, https does not save you from lenovo, which is why quchen's statement is so funny
14:30:51 <Xe> nonono
14:31:02 <Xe> you need xor-based OTP
14:31:05 <dulla> did https rely on ssl?
14:31:17 <quchen> merijn: Is that too big to go into 7.10.2?
14:31:20 <dfeuer> merijn, I would *love* to have improved GADT coverage stuff in there. Why did that not happen yet?
14:31:21 <dulla> you uh, trying to make things less secure? xe
14:31:35 <Xe> dulla: I'm trolling
14:31:36 <quchen> merijn: I'm not a friend of pushing releases back because of "that one feature"
14:31:36 <josephle> dulla, https is http on top of ssl/tls
14:31:44 <dfeuer> I think everyone's forgotten how to use telnet, so it's probably safe to go back to that.
14:31:48 <merijn> dfeuer: It's work in progress by Tom Schrijvers students
14:31:49 <dulla> sounds ass backwards
14:31:49 <hpc> what happened was lenovo pre-loaded software from another company that installed a root cert on the machine
14:31:55 <dulla> like layering too many monads
14:32:17 <quchen> hpc: … along with the private key of that cert
14:32:28 <hpc> along with the ability to intercept https traffic and re-encrypt it to be signed differently
14:32:30 <josephle> heh, at least they were kind to leave the password in memory!
14:32:46 <hpc> the private key was password-protected, but the password was the name of the company
14:32:53 <dfeuer> hpc, this sounds to me like a violation of the laws against cracking. I wonder if any of them will get to go to jail (haha! of course not! they make too much money for that)
14:32:54 <cmccann> hpc: are you serious
14:33:11 <hpc> what's worse
14:33:34 <hpc> the resigning software made no alterations to the "other domains" field, so even without the private key you could sign anything you want
14:33:36 <dulla> I'm not sure how you can get away with something so unabashed
14:33:38 <dulla> But
14:33:44 <monochrom> this is why "criminal gross negligence" exists, or whatever the correct spelling is
14:33:47 <dfeuer> cmccann, this has got to be the most ridiculous breach in recent memory.
14:33:51 <dulla> I guess that's how gawker/ubm/conde nast got so powerful
14:33:54 <geekosaur> there's actually worse out there. seems comodo (a certificate provider!) has been shipping such a proxy of their own.
14:33:55 <dulla> people let them
14:34:16 <dfeuer> monochrom, I don't think this can be called negligence; they *intentionally* installed adware on other the machines they sold to make a buck.
14:34:17 <geekosaur> (supposedly they are not shipping the version that wtfs even worse than the superfish one that lenovo was shippoing)
14:34:44 <dulla> so intentional consumer abuse?
14:34:51 <hpc> yep
14:35:19 <geekosaur> perhaps the real wtf is the reason comodo claimed for shipping their own mitm-ing ssl/tls proxy: to replace potentially untrusted ads with ones from a "secure" source
14:35:31 <geekosaur> https://blog.hboeck.de/archives/865-Comodo-ships-Adware-Privdog-worse-than-Superfish.html
14:35:47 <zomg> lolwut
14:36:02 <dulla> are they trying
14:36:03 <raek> is there any safe way to run an I/O action once on application startup and put the produced (pure) value in a global constant? (e.g. for reading a configuration file)
14:36:04 <zomg> isn't Comodo an antivirus software...
14:36:08 * geekosaur is well beyond "what are these people thinking?" and into "*are* these people thinking?!"
14:36:09 <dulla> or are they using xor
14:36:15 <Clint> raek: yes
14:36:16 <hpc> reminder: use a browser that doesn't render ads, like firefox with noscript or adblock
14:36:17 <josephle> I think the sad part is that the MITM itself is insecure, so it's a free attack vector -_-
14:36:34 <hpc> to not even give them /that/
14:36:36 <zomg> hpc: the company I work for makes online ads ;x
14:36:37 <cmccann> geekosaur: I think they're doing whatever is the opposite of thinking.
14:36:42 <Clint> raek: wait, what do you mean by "safe"
14:36:44 <cmccann> geekosaur: not thinking at all would be an improvement
14:37:08 <raek> Clint: that the I/O action will be performed at most once
14:37:20 <hpc> zomg: lol
14:37:22 <Clint> raek: yes
14:37:27 <monochrom> I was already into "people are neural networks" several years ago
14:37:28 <sx> What could be the performance problem with http://codepad.org/h9bH1G8b ?
14:37:37 <raek> Clint: ok. how? :-)
14:37:42 <merijn> raek: unsafePerformIO + noinline
14:37:51 <hpc> raek: ReaderT
14:37:59 <rom1504> monochrom: so you were wrong several years ago too
14:38:02 <hpc> raek: to give some variety with a good answer :P
14:38:18 * Clint sniffs.
14:38:49 <raek> my use case: define a class in HsQML
14:39:37 <dulla> Looks like I was right
14:39:43 <dulla> some kind of reader
14:40:09 <raek> "newClass [...stuff]]" has a type like "IO (Class tt)"
14:40:12 <monochrom> raek: one way is unsafePerformIO at the top level
14:40:55 <raek> ok, but the noinline (thanks merijn!) is needed in order to be sure that it is only executed once?
14:41:37 <dulla> curious how you insert a whole config into a reader monad
14:41:37 <merijn> Yes, if the unsafePerformIO gets inlined it can happen multiple times and won't be shared
14:41:56 <Clint> dulla: main = readFile >>= \contents -> restofyourprogram
14:42:03 <Clint> where restofyourprogram can be a runReaderT or something
14:42:19 <dulla> so no need to chop it up?
14:42:47 <dulla> or do you reformat it into an association list and pop it
14:42:54 <Clint> i don't know; what's your config structure?
14:43:08 <raek> is it possible to abstract away unsafePerformIO and noinline into a function, or does the noinline pragma need to go on the global variable definition?
14:43:38 <raek> e.g. "myClass = performOnce $ newClass [ ... ]"
14:43:53 <raek> where performOnce has the noinline thingy in it
14:43:55 <Clint> @hackage auto-update
14:43:55 <lambdabot> http://hackage.haskell.org/package/auto-update
14:53:49 <shapr> acowley: you still working on something copilot like that's not online yet?
14:54:02 <acowley> Yes!
14:54:09 <shapr> any word on when it might be online?
14:54:15 <acowley> No :(
14:54:36 <shapr> aww
14:54:42 <acowley> I know, I shouldn't have mentioned it
14:54:44 <shapr> oh well, I'll keep poking at Atom in the mean time
14:54:52 <shapr> acowley: nah, it's exciting to know there's new fun stuff coming up!
14:54:54 <acowley> but it's in that Compose talk
14:55:01 <acowley> I'm glad to hear that
14:55:37 <shapr> We're slowly getting more activity in the HaskellEmbedded community and on #haskell-embedded
14:55:45 <shapr> hodapp is writing blog posts, yay!
14:56:06 * hodapp hears name, trips over floor
14:58:13 <hodapp> acowley: I quite liked the Functional Roboticist slides, by the way
14:58:24 <acowley> hodapp: Thanks!
14:58:42 <hodapp> acowley: very nice to have a specific example in there that gives some practicality of SBV and Copilot
14:58:46 <acowley> There are so many haskell subchannels
14:59:21 <hodapp> well, it helps that the main channel does not have the connotation of #haskell-gofuckyourself
14:59:26 <hodapp> like some programming language channels do
14:59:43 <merijn> hodapp: Ah, you've been to ##c and ##c++ too? ;)
14:59:52 <hodapp> merijn: how did you know?
15:01:21 <tommd> shapr: Does Ivory not count?
15:01:49 <shapr> tommd: sure it does! It's the most commercially used embedded lib on #haskell-embedded as far as I know
15:01:50 <hodapp> What about Ivory?
15:02:01 <hodapp> shapr: based on a sample size of... me? :P
15:02:06 <shapr> hodapp: exactly!
15:02:14 <merijn> hodapp: Occasionally I forget and join those two with a question before giving up and asking #haskell-blah for C++ help instead :p
15:02:27 * shapr laughs
15:02:50 <merijn> Anyhoo
15:03:04 <merijn> Bed time, I'll have sweet "FTP is a go" dreams :p
15:04:03 <hodapp> hah
15:05:57 <tomberek> join /ghc-devs
15:09:29 * hackagebot bytestring-builder 0.10.4.1.2 - The new bytestring builder, packaged outside of GHC  http://hackage.haskell.org/package/bytestring-builder-0.10.4.1.2 (LeonSmith)
15:14:51 <Guest94027> hi
15:15:08 <Guest94027> does anyone know about a project
15:15:19 <Guest94027> a dependency manager
15:15:33 <Guest94027> implemented in haskell
15:15:42 <Guest94027> that uses a database of facts
15:16:05 <Guest94027> and uses a logic like language for calculating dependencies based on those facts
15:16:16 <Guest94027> I remember having seen a video
15:16:26 <Guest94027> but can't remember the name of the projec
15:16:45 <Guest94027> the project was not yet release at the time I saw the video, though
15:17:01 <Guest94027> but I've lost the links to it and I cannot find them
15:21:37 <RyanGlScott> I'm curious about the state of this proposal from two years ago to make Semigroup a superclass of Monoid in base ( https://mail.haskell.org/pipermail/libraries/2013-June/020194.html )
15:22:10 <RyanGlScott> It was mentioned that we'd wait until the dust from AMP and FTP settled down.
15:22:33 <RyanGlScott> Well, dust settled, I suppose.
15:22:47 <EvanR> seems like that would break a lot of existing code which knows nothing about semigroup
15:22:55 <EvanR> unless there was an autoderiving thing of some sort
15:22:59 <geekosaur> I would say it's not fully settled yet, since there'll be fresh storms when 7.10 is actually released
15:23:08 <RyanGlScott> geekosaur: Good point.
15:23:09 <toblerone> hi. I have a situation where i'm evaluating one StateT inside of another. Is there a way the "child StateT" can access the "parent" one? Here is an example: http://lpaste.net/6274988154789298176
15:23:31 <tommd> toblerone: Sure, 'lift'.
15:23:50 <choltz95> that does not sound like good functional programming practices
15:23:56 <toblerone> does my example work? I'm pretty sure it doesn't... : O
15:23:56 <tommd> Nope.
15:23:57 <RyanGlScott> EvanR: It's not autoderiving per se, but currently Semigroup has a default instance for Monoid instances: https://github.com/ekmett/semigroups/blob/435b328c8db73ec7cf60555814fe50ab560b30b3/src/Data/Semigroup.hs#L153-169
15:24:39 <EvanR> RyanGlScott: ok. so existing monoid instances which need to have their <> moved?
15:24:48 <EvanR> guessing no
15:25:05 <EvanR> in which case whats the point
15:25:08 <RyanGlScott> EvanR: Well, the AMP didn't get rid of return from Monad, so I'm guessing not.
15:25:46 <EvanR> would <> be monoid or semigroup
15:26:32 <RyanGlScott> EvanR: Probably Semigroup. I'm guessing Data.Monoid would reexport the Semigroup <>, similarly to how Data.List exports Foldable/Traversable functions after FTP.
15:27:05 <EvanR> right... which would call the semigroup method, which would be the monoid mappend in almost all cases
15:27:35 <RyanGlScott> Correct. There's two reasons I'd really love to have Semigroup in base, though.
15:28:07 <RyanGlScott> One, it would make the Monoid instance for Maybe make more sense. Currently it's Monoid a => Monoid (Maybe a), but it can be generalized to Semigroup a => Monoid (Maybe a)
15:28:34 <RyanGlScott> The docs for base even slyly note this: https://hackage.haskell.org/package/base-4.8.0.0/candidate/docs/Data-Monoid.html#t:Monoid
15:29:11 <RyanGlScott> Two, the times1p function is incredibly handy: https://github.com/ekmett/semigroups/blob/435b328c8db73ec7cf60555814fe50ab560b30b3/src/Data/Semigroup.hs#L191
15:29:24 <EvanR> Maybe makes a semigroup into a monoid
15:29:33 <EvanR> or an existing monoid into another monoid ;)
15:30:01 <RyanGlScott> I'm sure there's also other parts of base that could be generalized as well, but that's the first one that pops into my mind.
15:30:11 <toblerone> Well the situation I have is that I'm using a library that runs everything in a StateT monad. During execution it periodically signals some events that can be handled in its monadic context. I want to expose those values to the parent state which is running on its own thread.
15:30:23 <EvanR> RyanGlScott: Natural?
15:30:54 <toblerone> One solution was to use an MVar and with each event pass the value to it so it could be read by anyone who is interested.
15:31:07 <toblerone> but i thought that was kinda ugly
15:31:18 <RyanGlScott> EvanR: Like a Word, except unbounded in size. Originally from the nats package, and a part of base as of 4.8.0.0: https://hackage.haskell.org/package/base-4.8.0.0/candidate/docs/Numeric-Natural.html
15:31:34 <EvanR> toblerone: StateTs inside of StateTs is kinda ugly
15:32:01 <EvanR> especially if they are in different threads (?)
15:32:16 <toblerone> ya, well I think this situation calls for it. I tried several other options, and found this one was the nicest...
15:32:23 <EvanR> RyanGlScott: oh wow didnt know about that
15:32:56 <RyanGlScott> EvanR: It's amazing how many of edwardk's packages end up becoming a part of base. I wouldn't be surprised if semigroups ends up that way too.
15:33:28 <EvanR> toblerone: after a certain point in a stateful app, it seems to be transformers just breaks down and what you really have is a bunch of simple threads
15:33:29 <toblerone> And they aren't "nested" StateT's by the way. As in my example, they are both essentially "StateT st IO ret" one is just being evaluated inside the other with liftIO
15:34:01 <EvanR> oop -> concurrent programming, not stateTs
15:34:04 <RyanGlScott> It's already happened with bifunctors, void, nats, ...
15:34:40 * hackagebot blaze-builder 0.4.0.1 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.4.0.1 (LeonSmith)
15:35:35 <toblerone> EvanR: So you think using StateT like this is generally a bad idea? http://lpaste.net/6274988154789298176 Its just a stateful computation running inside another one
15:35:51 <EvanR> IO already has several mutable state faciltiies
15:36:06 <EvanR> whats the StateT for
15:36:27 <toblerone> Well, the inner statet is introduced by a library i'm using
15:36:36 <edwardk> RyanGlScott: some folks are talking about doing a Semigroup-Monoid proposal, but we wanted to wait and see how the community responded to the AMP and Foldable/Traversable proposal before letting that horse leave the gate ;)
15:37:53 <EvanR> toblerone: if you have a thread running in LibraryT, great excuse to use another thread for your own use, especially if its asking you to handle something in another thread
15:38:40 <EvanR> two threads both in LibraryT seems like a disaster
15:38:49 <edwardk> RyanGlScott: in theory we could in 7.12 warn that Semigroup goes in in 7.14 (AMP-style name collision warnings), move it to Prelude in 7.14 and add a warning if you have a Monoid without an instance, and make the superclass constraint in 7.16, or we could go for a tighter time table, as from the data we have these super-gradual warnings don't elicit any sort
15:38:49 <edwardk> of clear action by users.
15:39:13 <edwardk> RyanGlScott: but we don't have a concrete proposal ready at this time
15:39:40 * hackagebot pipes-safe 2.2.2 - Safety for the pipes ecosystem  http://hackage.haskell.org/package/pipes-safe-2.2.2 (GabrielGonzalez)
15:39:41 <RyanGlScott> edwardk: That's good to hear. If I were more familiar with GHC's build system, I'd love to come up with a patch.
15:39:58 <Zemyla> I always feel weird when typing "unsafeShiftL" and "unsafeShiftR", even when I know it's actually perfectly safe.
15:40:13 <RyanGlScott> Also since there's a couple of really trivial bugs I've reported that I could probably fix myself, but that's a different story...
15:41:31 <falsesentence> with the help of my friend I just wrote the ugliest code ever, it checks if a set and an operation is a group
15:41:50 <RyanGlScott> edwardk: Is there any previous history of bringing in a typeclass from a different package to base that defines instances for non-base data types?
15:42:49 <edwardk> RyanGlScott: well, we're slowly trying to evolve base to include the things that exist for deep fundamental reasons that folks want to share, and shed the parts that can't exist everywhere, to make it easier for folks like Haste or GHCJS, etc. to exist.
15:42:54 <RyanGlScott> edwardk: Because it does seem like reworking the Semigroup instances for text, unordered-containers, etc. could be a bit of a pain.
15:43:02 <toblerone> EvanR: nooo. I have MyStateT which runs on its own thread. Inside MyStateT I evaluate LibraryT as if it were just an IO function. LibraryT may be running on a separate green thread, but I don't know. I'm looking for a way to pass data out of the computation being run in LibraryT as it happens. One way to do this is to use STM, but I was hoping to f
15:43:02 <toblerone> ind a cleaner way
15:43:15 <toblerone> sorry if i wasn't more clear earlier
15:43:40 <Zemyla> edwardk: Are you familiar with the SIMD operators in GHC.Prim?
15:43:43 <edwardk> RyanGlScott: on the other hand, the situation we have today makes it so you get folks who have to use (Semigroup m, Monoid m) constraints everywhere. like they did with (Applicative m, Monoid m) before
15:43:47 <edwardk> or they duplicate combinators
15:44:07 <EvanR> toblerone: so that LibraryT IO does not return
15:44:09 <edwardk> Zemyla: enough to be sad about the lack of swizzling and held back from using them until there is better support for that sort of thing
15:44:36 <edwardk> Zemyla: carter is pretty deeply familiar with their details, he might be a better person to ask about particulars
15:45:35 <RyanGlScott> edwardk: On a related note, Semigroup currently has a default signature for Monoids. If brought into base, would that be kept, or would users be encouraged to move their mappend definition to a Semigroup instance?
15:45:47 <RyanGlScott> edwardk: Hypothetically speaking of course.
15:45:51 <Zemyla> edwardk: I'm wondering why there's no operation like lookupWord8X16# :: Word8X16# -> Int# -> Word#.
15:46:00 <edwardk> RyanGlScott: those are the kinds of things that make such a concrete proposal messy
15:46:04 <edwardk> not sure yet
15:46:10 <RyanGlScott> Gotcha
15:46:26 <Zemyla> Because there's an insert operation, but no operation to read a specific value from a SIMD tuple.
15:46:35 <RyanGlScott> Well, it'll be nice to argue about something other than Foldable/Traversable for a change, I suppose.
15:46:56 <edwardk> RyanGlScott: on the plus side if we shed it it can lead to a better end-state. in say 7.16 or 7.18 we could remove the mappend member from Monoid and move it to a top level alias, letting you get more general signatures. on the downside it'd have a higher transition cost
15:47:20 <edwardk> Zemyla: that is one case of the sort of swizzling problem i'm talking about
15:47:47 <edwardk> RyanGlScott: give me a few months to recharge before throwing me back into the fray ;)
15:48:29 <lpaste> gb2 pasted “brainf.hs” at http://lpaste.net/121051
15:48:31 <toblerone> EvanR: No, it does. I have a bunch of readers and a global cache that they all have access to via STM. During the reading and processing, each worker should consult and update the cache. The "parent" StateT has access to that cache and functions to operate on it. Therefore, I need a way to touch that cache from inside LibraryT which is where alot o
15:48:31 <toblerone> f the work is happening
15:48:47 <RyanGlScott> edwardk: No worries, I was just curious about the future typeclass landscape.
15:48:51 <edwardk> anyways the question i on the semigroup-monoid stuff is a.) is there a will to do it, and b.) do people prefer a longer process with several drawn-out steps, or something faster without weird intermediate states. a lot of the flak we caught on FTP was over the Data.List weirdness for instance.
15:49:20 <EvanR> toblerone: this is why the LibraryT using StateT over IO is making it hard for you to do stuff, you dont have easy access to things, its not modular
15:49:31 <hpc> and the benefit it has
15:49:32 <Zemyla> edwardk: Will comonads be brought into base?
15:49:34 <edwardk> RyanGlScott: we don't have a lot of big changes in mind. the big ones that folks have asked about repeatedly are 'can we make Semigroup a superclass of Monoid' and 'can we remove fail from Monad'
15:49:42 <hpc> how many interesting structures have a Semigroup but not Monoid
15:49:52 <edwardk> Zemyla: i'm personally not in a hurry to move them there.
15:50:02 <edwardk> hpc: quite a few actually.
15:50:15 <toblerone> EvanR: sure, but given that is how its designed, i'd still like to use it. : )
15:50:15 <hpc> oh?
15:50:42 <Zemyla> hpc: Either a b is a semigroup.
15:50:52 <EvanR> toblerone: id suggest encapsulating access to this stuff in its own thread, of course i have no idea what this library is or how its design really so i dunno
15:51:14 <hpc> heh, just saw that instance
15:51:24 <edwardk> hpc: Min and Max without a bound is a good start. Last and First without the Nothing case.
15:51:27 <hpc> and Const
15:51:52 <toblerone> okay. at least its good to know that there is no way I can use "lift" or whatever to accomplish this. I was pretty sure there wasn't but I wanted to be sure..
15:51:55 <edwardk> the Monoid a => Monoid (Maybe a)    instance really should be Semigroup a => Monoid (Maybe a)
15:51:58 <hpc> actually Const can be Monoid
15:52:13 <RyanGlScott> hpc: There's also NonEmpty lists, although that's not in base :)
15:52:28 <EvanR> toblerone: i didnt see that, but ok
15:52:35 <edwardk> which would recover the existing Last and First monoids using Maybe (Last a) and Maybe (First a)
15:53:16 <edwardk> right now we shove a bunch of extra units in data types to _make_ them monoids
15:53:46 <toblerone> see that I had asked about lift? Yeah, I never explicitly mentioned it, but I sorta asked about it in my example
15:53:48 <EvanR> toblerone: if this cache is really an IORef or something in the context, you can just pass that into the subactions (which dont really need to be transformers either)
15:54:25 <toblerone> yeah. I was considering that... There are some complications with that approach, but I may end up going that route
15:54:53 <EvanR> putting IORefs for state in the contet of a StateT seems crazy to me
15:54:53 <edwardk> some folks campaign that a better monoid for map would be instance (Eq k, Monoid a) => Monoid (Map k a) -- but it would really be instance (Eq k, Semigroup a) => Monoid (Map k a) -- no unit is needed, we only mash things together when we have two of them
15:55:05 <edwardk> so handling that extra unit case is a price everyone has to pay for, even if they don't want it
15:55:22 <edwardk> it rules out spec-constr style optimizations in many cases
15:55:28 <toblerone> Why is that crazy?
15:55:56 <toblerone> you mean, putting a TVar in StateT is crazy?
15:55:59 <hiptobecubic> Strangely enough, I noticed this myself just today
15:56:01 <EvanR> toblerone: usually the state isnt "which mutable variable do i have" its "the mutable variable itself"
15:56:16 <RyanGlScott> Ooh, what would the (Eq k, Monoid a) => Monoid (Map k a) instance do differently?
15:56:29 <EvanR> if you use put, you clobber your register, rather than update the register
15:56:40 <toblerone> true...
15:56:45 <RyanGlScott> Or rather, the (Eq k, Semigroup a) => Monoid (Map k a) instance?
15:56:49 <EvanR> its befuddled
15:56:56 <toblerone> i suppose you could use a ReaderT for that case then.... :)
15:57:00 <EvanR> indeed
15:57:14 <EvanR> which is just passing a parameter
15:57:31 <hiptobecubic> RyanGlScott, if key exists in second map, binop the values together, otherwise just take this one.
15:58:02 <RyanGlScott> hiptobecubic: Ah, that makes sense.
15:58:07 <hiptobecubic> I'd think basically "union" using <> to resolve conflicts
15:58:24 <toblerone> yeah. I initially did that, but then I found I wanted some state along for the ride. Is this what RWS if for?
15:58:33 <RyanGlScott> I'm surprised that there isn't a newtype that does that (or maybe there is, and I haven't noticed).
15:58:37 <hiptobecubic> Although i don't see what the alternative even is? Just overwriting?
15:58:50 <monochrom> a use of State or StateT, where you will never really use put... well, not crazy, just overkill
15:59:14 <RyanGlScott> hiptobecubic: Right now, it's just a plain union. http://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Map-Base.html#Map
15:59:15 <toblerone> No I use put
15:59:15 <EvanR> toblerone: no. like i just said, if youre in IO, you already have state in the form of mutable variables
15:59:35 <EvanR> RWST over IO in order to just have mutable variables...
15:59:39 <EvanR> well thats IO
16:00:43 <toblerone> well its not just that. : ) But i understand your critiques. Maybe I should reconsider my approach a bit...
16:01:08 <EvanR> my critque comes from the amount of code involved to do it with a transformer
16:01:28 <EvanR> before this convo i wasnt even thinking of how multiple said different stacks would interact, but yeah
16:02:23 <toblerone> huh? I tried two other approach before settling on this one, but I found that StateT offered greater flexibility in the API
16:03:24 <toblerone> but still, points taken. I'll take another look at how to best accomplish this. : )
16:06:58 <levi> Wow, the sqlite-simple library really is simple.
16:07:37 <hpc> sqlite is pretty simple
16:08:56 <bitemyapp> hpc: uhhh...seen the test suite? (squite?)
16:09:31 <hpc> conceptually simple
16:09:47 <sx> What does '>>=.\' mean in profiling? Or how is it different from '>>='?
16:21:11 <Zemyla> How do you create and pass around values of type, say, ((Ord a) => f a)?
16:22:26 <orzo> ExistentialQuantification?
16:22:49 <sx> In general you can't, or am I wrong
16:23:55 <geekosaur> there are ways to do it but it's generally considered an antipattern
16:23:55 <Zemyla> Well, I know I've seen things like (a :~: b) -> ((a ~ b) => c) -> c.
16:25:16 <gb2> i am using lenses inside a state monad eg scnt %= (\a -> a+1) :how to can i add error handling : scnt ??? (\a -> if a<0 then Left "oops" else Right (a+1))
16:27:18 <pavonia> Any ideas how to make that function more compact? http://lpaste.net/5734929552421945344  There are a lot of duplicate values but I don't see a good way of factoring them
16:27:50 <pavonia> *factorising
16:29:02 <orzo> is compactness important for it?  having the tabular form might be more desirable i figure
16:29:30 <sx> gb2: You could use MonadError to create a combinator, on Left you use throwError and on Right you perform %=.
16:30:12 <pavonia> orzo: Not really, it just looks a bit too verbose in the code IMO
16:30:17 <hpc> pavonia: unless individual bits mean specific things
16:30:21 <orzo> well maybe several tables instead
16:30:33 <hpc> which, i see no pattern at all
16:30:45 <hpc> leave it like it is
16:30:49 <hpc> it looks like what it does
16:31:03 <isomorphismes> I'm having some trouble with cabal install pandoc: https://dpaste.de/aXCo. Is this the right place to ask for help with cabal?
16:31:17 <pavonia> Okay
16:31:30 <hpc> that's my general rule for coding, anyway
16:33:47 <orzo> it sucks when websites insist on having both white-on-black and black-on-white on the same page, so even inverting your screen colors is useless in acheiving your preference
16:34:53 * hackagebot linear-opengl 0.2.0.6 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.2.0.6 (BenGamari)
16:35:08 <deMoivre> I need help constructing the type signature for a function
16:35:13 <deMoivre> it's driving me nuts
16:35:14 <deMoivre> heh
16:35:38 <HeladoDeBrownie> deMoivre, what's the function?
16:35:38 <exio4> deMoivre: you could just leave it out, load the file in the repl, and check which type it got infered
16:36:08 <deMoivre> I haven't even gotten to the point where I define the function
16:36:14 <HeladoDeBrownie> i often do what exio4 just said but it's also useful to know how to figure out types yourself
16:36:23 <deMoivre> I'm just stubbing it with a zero value to get this to compile
16:36:34 <HeladoDeBrownie> deMoivre, well, how does it need to be used then?
16:37:38 <gb2> is there a way to leverage the %= combinator?
16:37:49 <orzo> deMoivre: with a suficiently bleeding edge compiler, you can specify the type signature in peices and let the compiler infer other chunks
16:38:10 <deMoivre> http://pastebin.com/UeyB5cYv
16:39:02 <HeladoDeBrownie> deMoivre, how does that code tie to what you were saying?
16:39:25 <deMoivre> HeladoDeBrownie: Well, if I -- out the line with :: on it...
16:39:28 <deMoivre> what I get is:
16:39:31 <deMoivre> :t mandelbrot
16:39:32 <lambdabot> Not in scope: ‘mandelbrot’
16:39:40 <deMoivre>   :: (Num t11, Fractional t10, Fractional t9, Fractional t8,
16:39:40 <deMoivre>       Fractional t7) =>
16:39:40 <deMoivre>      (t, t1, t2, t3, t4, t5, t6) -> (t7, t8, t9, t10, t11, Bool, [Char])
16:40:02 <deMoivre> which isn't what I want...which is: mandelbrot :: (Double, Double, Double, Double, Int, Bool, String) -> (Double, Double, Double, Double, Int, Bool, String)
16:40:02 <HeladoDeBrownie> sure
16:40:09 <HeladoDeBrownie> ah, well that type is more general than what you want
16:40:20 <deMoivre> ...right
16:40:31 <HeladoDeBrownie> so it's fine, you can just write your own type or use it the way you want, although you might have to resolve ambiguity another way if you don't write it out
16:40:53 <deMoivre> Well, let's approach this from another angle, now that I've got your attention =)
16:41:04 <orzo> the infered type only matters if you don't explicitly specify a type
16:41:50 * HeladoDeBrownie will try to refrain from making any more guesses until the problem has been explained
16:42:01 <deMoivre> http://pastebin.com/iLLrizDC
16:42:10 <deMoivre> That compiles and runs
16:42:20 <deMoivre> but it I remove the --s, it doesn't
16:42:21 <HeladoDeBrownie> that's exactly the same as the last thing you showed.
16:42:24 <deMoivre> I get this error:
16:42:26 <deMoivre> (yes, it is)
16:42:28 <HeladoDeBrownie> did you intend that?
16:42:30 <HeladoDeBrownie> okay.
16:42:52 <deMoivre> mandel4.hs:6:5: parse error on input ‘|’
16:42:53 <deMoivre> Failed, modules loaded: none.
16:43:13 <HeladoDeBrownie> did you also remove everything from the = onwards on line 2?
16:43:25 <HeladoDeBrownie> including the =
16:43:40 <deMoivre> No, because I'm an idiot.
16:43:41 <deMoivre> brb
16:43:54 <HeladoDeBrownie> syntax can be unintuitive sometimes :P
16:44:17 <deMoivre> now, I get a monster error
16:44:20 <HeladoDeBrownie> show the error and the code producing it
16:45:35 <deMoivre> http://pastebin.com/ZKGB5Ned
16:45:58 <HeladoDeBrownie> please include the code, now that you've made changes to it.
16:46:00 <deMoivre> code producing it is what you've already seen, minus the --s and the = and the stuff after it on that line
16:46:03 <deMoivre> as you pointed out
16:47:10 <HeladoDeBrownie> it may sound like this should be trivial to work out, but can you please update the code anyway? it helps me be sure i understand correctly and also means there's less to hold in my head at once
16:47:52 <deMoivre> http://pastebin.com/wU51bsvA
16:47:53 <acowley> How do I get a list of packages that come with GHC?
16:47:59 <acowley> E.g. those listed in the right column here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/index.html
16:48:52 <HeladoDeBrownie> deMoivre, at least part of this error is certainly happening elsewhere. i suspect the whole thing.
16:48:53 <ednedfred> Does anyone have any good resources for maintaining a database connection in a web application? I have been looking up different techniques for weeks, and I am still unsure what to do.
16:49:33 <HeladoDeBrownie> deMoivre, ah, never mind, i tried the exampe isolated and it does indeed give the first error there. i'll try working this out
16:49:43 <ednedfred> If anything, I just need to be pointed in the right direction.
16:50:06 <deMoivre> ok
16:50:14 <deMoivre> I'm baffled, but I'm a Haskell n00b
16:50:32 <deMoivre> I've never gotten comfortable in a functional language before
16:51:09 <HeladoDeBrownie> deMoivre, the tuples are different sizes
16:51:12 <HeladoDeBrownie> deMoivre, that's the cause of the error
16:51:33 <deMoivre> 7 each, as far as I can tell
16:51:38 <HeladoDeBrownie> one of them is eight. check.
16:51:40 <deMoivre> all 5 places
16:51:56 <HeladoDeBrownie> hrm, i'm confused...
16:51:57 <deMoivre> OMG
16:52:00 <deMoivre> I AM BLIND
16:52:01 <deMoivre> hahahaha
16:52:02 <deMoivre> ok
16:52:21 <HeladoDeBrownie> oh!
16:52:23 <HeladoDeBrownie> found it
16:52:29 <deMoivre> yeah, me too
16:52:31 <HeladoDeBrownie> i didn't see it in the source, i saw it in the error. you typed , when you meant .
16:52:34 <deMoivre> yep
16:52:36 <HeladoDeBrownie> that must be infuriating
16:52:37 <deMoivre> it compiles now
16:52:42 <deMoivre> GOD.
16:52:48 <HeladoDeBrownie> by the way, you can just type 0 for those instead of 0.0
16:52:59 <deMoivre> I thought Haskell was super-strongly-typed
16:53:03 <HeladoDeBrownie> it is
16:53:05 <deMoivre> Like Ada
16:53:11 <deMoivre> That kind of shennanigan isn't allowed in Ada =)
16:53:19 <HeladoDeBrownie> but numeric literals are polymorphic in a way that it works out that you can type that
16:53:24 <deMoivre> ok
16:53:28 <HeladoDeBrownie> @type 0
16:53:29 <lambdabot> Num a => a
16:53:29 <deMoivre> I'll do that from now on, then
16:53:30 <HeladoDeBrownie> @type 0.0
16:53:31 <lambdabot> Fractional a => a
16:53:34 <HeladoDeBrownie> @info Fractional
16:53:34 <lambdabot> Fractional
16:53:36 <HeladoDeBrownie> erm
16:53:46 <HeladoDeBrownie> well anyway all Fractional are also Num
16:53:50 <deMoivre> Yep.
16:53:57 <deMoivre> subcategory
16:54:01 <HeladoDeBrownie> subclass
16:54:13 <deMoivre> in the typeclass sense?
16:54:23 <HeladoDeBrownie> yep. there are no classes commonly discussed in haskell besides typeclasses.
16:54:32 <deMoivre> ohj
16:54:33 <deMoivre> *oh
16:54:35 <HeladoDeBrownie> so you can say "Fractional is a subclass of Num"
16:54:40 <deMoivre> So there's no OO conception in Haskell?
16:54:56 <HeladoDeBrownie> you can *express* oo concepts in haskell but we don't talk about oo classes the majority of the time
16:55:12 <deMoivre> I guess that would make sense, since state is to be controlled and not mutated in like manner as in Java, let's say
16:55:13 <HeladoDeBrownie> if you say "class" and you mean "oo class" you ought to clarify that
16:55:21 <deMoivre> Noted.
16:55:25 <Rotaerk> OO is a term that refers to a varied assortment of things
16:55:33 <Rotaerk> kind of a crap term
16:55:33 <tomberek_> @pf \ ((e,s),b) -> (e,(b,s))
16:55:33 <lambdabot> Maybe you meant: pl bf
16:55:36 <deMoivre> Rotaerk: Yeah...
16:55:44 <tomberek_> @pl \ ((e,s),b) -> (e,(b,s))
16:55:44 <lambdabot> uncurry (uncurry ((. flip (,)) . (.) . (,)))
16:55:53 <deMoivre> When I say OO, I mean it in the Java/C++ way.  Not in the Smalltalk way or whatever else
16:56:32 <arw_> you could emulate objects with a little closure and struct trickery in a very weird way.
16:56:42 <deMoivre> yeah
16:56:42 <deMoivre> heh
16:56:44 <arw_> but no inheritance for example.
16:56:49 <deMoivre> But they's be pseudo-object at best
16:56:56 <deMoivre> *pseudo-objects
16:57:03 <deMoivre> not even as good as the pseudo-objects in Golang
16:58:11 <arw_> haskell is functional, not "multi-paradigm" or something.
16:58:16 <exio4> most of the "OOP code" I have seen is basically somehow emulating closures, high order functions, and/or sumtypes
16:59:08 <arw_> there are many concepts that come very easily if you know some functional programming.
16:59:40 <arw_> e.g. all those 'design patterns' OO people tend to brag about look strangely familiar...
16:59:46 <Rotaerk> I would just call haskell's paradigm the haskell paradigm, not "functional"
17:00:06 <deMoivre> I'm interested in learning the Haskell way first
17:00:06 <Rotaerk> I think FP is also an assortment of ideas, and which ideas can vary
17:00:08 <deMoivre> not the functional paradigm
17:00:17 <deMoivre> the general functional paradigm understanding can come later
17:00:20 <exio4> Rotaerk: declarative programming!
17:00:46 <HeladoDeBrownie> deMoivre, there really is no singular "functional way" anyway. so yeah, learning idiomatic haskell is a good goal on your way to learn haskell.
17:00:49 <Rotaerk> exio4, you could call it declarative, since that describes a very precise thing about the language
17:01:02 <Hijiri> I remember someone writing that writing in haskell is like B/D, does anyone remember where that is from?
17:01:09 <Rotaerk> you could also say that it's expression-oriented, as opposed to statement-oriented
17:01:22 <deMoivre> Rotaerk: That makes a lot of sense.
17:01:50 <Rotaerk> B/D?
17:01:56 <Hijiri> bondage and discipline
17:02:12 <deMoivre> How do I cast from Int to Double?
17:02:19 <geekosaur> make that bind-age and I might agree :p
17:02:20 <HeladoDeBrownie> @type fromIntegral
17:02:21 <lambdabot> (Num b, Integral a) => a -> b
17:02:22 <petercommand> what's B/D?
17:02:25 <HeladoDeBrownie> deMoivre, ^
17:02:33 <Rotaerk> <Hijiri> bondage and discipline
17:02:41 <petercommand> oh...
17:02:44 <deMoivre> say a function is
17:02:57 <deMoivre> f :: (Double, Double) -> (Double, Double)
17:03:04 <deMoivre> but I have two values m and n
17:03:05 <deMoivre> which are Ints
17:03:08 <EvanR> "haskell? oh you mean that bondage and discipline language"
17:03:10 <deMoivre> and I want to pass them into f
17:03:21 <EvanR> which ive heard
17:03:22 <HeladoDeBrownie> deMoivre, f (fromIntegral m, fromIntegral n)
17:03:27 <deMoivre> that's it
17:03:30 <deMoivre> Thanks.
17:03:45 <HeladoDeBrownie> deMoivre, are you learning haskell as part of a university course?
17:03:50 <deMoivre> HeladoDeBrownie: No.
17:04:00 <HeladoDeBrownie> ah, bad guess on my part then.
17:04:15 <HeladoDeBrownie> i guessed that because that's the only place i've seen the single-tuple-as-parameter style taught.
17:04:15 <deMoivre> I have a Master's in Mathematics from Dartmouth and most of a PhD
17:04:27 <deMoivre> I'm not sure anyone taught me that style
17:04:31 <deMoivre> it's just what occurred to me
17:04:34 <HeladoDeBrownie> ah, okay
17:04:37 <johnw> deMoivre: do you express your progress toward a PhD as a floating-point or a rational?
17:04:45 <deMoivre> I'm currently a Software Engineer II at Softlayer, an IBM Company
17:04:45 <HeladoDeBrownie> well in that case, some information on more idiomatic haskell
17:04:48 <deMoivre> (that's our official line)
17:05:01 <HeladoDeBrownie> normally, we don't write (A, B, C) -> D, we write A -> B -> C -> D
17:05:05 <deMoivre> johnw: rational, hopefully
17:05:06 <HeladoDeBrownie> that way it's more easily composed with other things
17:05:13 <EvanR> or a CReal
17:05:13 <deMoivre> HeladoDeBrownie: I Know.
17:05:14 <deMoivre> *know
17:05:15 <johnw> good man, now I believe you :)
17:05:28 <deMoivre> HeladoDeBrownie: right...but I wanted to make this easy for recursion
17:05:38 <xandaros> EvanR: cereal?
17:05:40 <deMoivre> if you think I'm employing an inferior style, refactor it for me in a pastebin
17:05:48 <johnw> deMoivre: you can use curry and uncurry
17:05:48 <deMoivre> but only AFTER I get the currently revision compiling correctly again
17:05:49 <deMoivre> brb
17:05:59 <HeladoDeBrownie> deMoivre, ah, so you want to pass an entire tuple rather than having to deconstruct every time?
17:06:17 <deMoivre> Yes, exactly.  =)
17:06:18 <deMoivre> brb
17:06:18 <hiptobecubic> johnw, i'd think you'd prefer floating point over rational
17:06:22 <EvanR> > let phd = sqrt 2 / 2 :: CReal in phd
17:06:24 <lambdabot>  0.7071067811865475244008443621048490392848
17:06:29 <hiptobecubic> assuming you want to arrive there eventually
17:06:38 <ednedfred> Could somebody point be to a good resource about maintaining a database connection in a Haskell web application? I have been searching for weeks, and have yet to find a really good resource.
17:06:42 <hiptobecubic> At least *I* would like a finite number of hops
17:06:52 <HeladoDeBrownie> deMoivre, that makes sense. nothing strictly superior springs to mind in this example.
17:07:10 <EvanR> hiptobecubic: but you might end up at 1.0001842734234 phd
17:07:25 <hpc> ednedfred: maintaining as in how to carry it around as a value, or making sure there's no odd disconnects and such?
17:08:09 <hiptobecubic> EvanR, if the goal is to surpass 1 phd, then that's much better than going depth first up from 0
17:08:23 <ednedfred> Well, I'm using Scotty to handle routing, and I have not found a good way to pass the connection around.
17:08:51 <EvanR> hiptobecubic: you might suddenly be at NaN phd ;)
17:09:27 <ednedfred> I have seen many examples where the program is accessing a connection similar to a global variable in an OO language
17:09:30 <hiptobecubic> EvanR, if your fpu returns nan when incrementing a non-nan, you have bigger problems.
17:10:07 <EvanR> the differential equation describing your progress might have something that messes up your solver
17:10:38 <hiptobecubic> :D
17:10:41 <hiptobecubic> heading out!
17:10:45 <hiptobecubic> night all
17:10:52 <deMoivre> Right now my progress feels so unpredictable that it wouldn't even have a derivative
17:10:54 <deMoivre> thus, no DEs
17:13:01 <orzo> what's Scotty
17:14:57 <xandaros> A web framework, like yesod and snap, I think
17:15:09 <johnw> well, not much of a "framework"
17:15:20 <ednedfred> orzo: A web framework similar to Ruby's sinatra if you have ever used that
17:15:22 <johnw> as it is just an easy way of writing responders to dynamic routes
17:15:29 <Xe> scotty : martini :: haskell : go
17:15:45 <benzrf> eek
17:16:26 <EvanR> martini.codegangsta.io, nice
17:16:37 <EvanR> classy webframework for go
17:17:07 <ReinH> These are the fedora tippiest web frameworks.
17:17:23 * benzrf tips fedora
17:17:27 <benzrf> tip tip tip
17:18:07 <shachaf> Can we not have that in here, please?
17:19:48 <EvanR> no talking about go
17:20:00 <deMoivre> HeladoDeBrownie: http://pastebin.com/f9PBTybr
17:20:52 <HeladoDeBrownie> deMoivre, it tells you in the error message what it looks to me like the problem is.
17:20:58 <HeladoDeBrownie> Probable cause: ‘loop’ is applied to too few arguments
17:21:26 <deMoivre> HeladoDeBrownie: Here's the code: http://pastebin.com/fMzcFAqb
17:21:49 <deMoivre> oh
17:21:49 <deMoivre> duh
17:21:51 <HeladoDeBrownie> deMoivre, that strengthens my belief that the error message is correct.
17:23:04 <HeladoDeBrownie> i'm going to be semi-idle working one of my projects, but other channel denizens may be able to help with any further problems you may have
17:23:41 <deMoivre> ok.
17:23:45 <deMoivre> Thanks for all your help =)
17:35:38 <deMoivre> How do I grab the final element of a tuple?
17:35:49 <deMoivre> that's, say, 7 dimensional
17:36:33 <hodapp> just match over it
17:36:43 <deMoivre> I don't know how.
17:37:23 <hodapp> # EDSLs: Code Generation
17:37:29 <hodapp> ack paste fail...
17:37:40 <hodapp> :t (\(_,_,_,_,_,_,x) -> x)
17:37:41 <lambdabot> (t, t1, t2, t3, t4, t5, t6) -> t6
17:38:30 <deMoivre> so, create a function to do it for me, basically
17:38:31 <deMoivre> heh
17:38:54 <hodapp> I don't think anything beyond 'fst' and 'snd' is part of the standard libraries
17:38:58 <benzrf> :t _6
17:39:01 <shachaf> No, just do it in-place.
17:39:03 <deMoivre> yeah, I think you're right
17:39:05 <benzrf> :t _7
17:39:07 <deMoivre> that's why I was wasking =/
17:39:17 <benzrf> hh
17:39:20 <shachaf> Better yet, don't use a 7-tuple at all.
17:39:24 <deMoivre> shachaf: I don't know how to do it in place
17:39:26 <deMoivre> haha
17:39:31 <hodapp> yeah, I'm sort of wondering too why a 7-tuple came up.
17:39:37 <deMoivre> lemmeloanabout the 7-tuples...
17:40:09 <exio4> I think 4 of those values can be reduced to two Complex, so we've got only 5 elements now, I think
17:40:16 <xandaros> If you need a 7-tuple, chances are you can combine some of the values to a new type
17:40:17 <deMoivre> That is true
17:40:30 <deMoivre> But I'm trying to make this code mimic the Java code I have as closely as possible
17:40:33 <xandaros> ...or all of them
17:40:37 <hodapp> when has that ever been a good thing?!
17:40:49 <deMoivre> I will certainly be using complex types after I figure this program out
17:42:39 <deMoivre> ripOffThe7th :: (t1, t2, t3, t4, t5, t6, t7) -> t7
17:42:40 <deMoivre> ripOFfThe7th (a, b, c, d, e, f, g) = g
17:42:43 <deMoivre> Why doesn't that work?
17:42:51 <shachaf> Why don't you tell us?
17:43:13 <Welkin> because of associativity
17:43:25 <Welkin> Constructor a b c
17:43:36 <Welkin> is not the same as Constructor (a, b, c)
17:43:52 <monochrom> deMoivre: what we mean is, what is "doesn't work"?
17:43:53 <Welkin> oh, wait
17:43:54 <xandaros> The name has a typo
17:44:03 <deMoivre> ugh
17:44:39 <ReinH> If you use records, you can give fields meaningful names.
17:44:44 <Welkin> deMoivre: the compiler will have told you about the spelling error
17:45:01 <deMoivre> Welkin: Not in any way that was apparent
17:45:46 <ReinH> I think "Not in scope" is a pretty good indicator of a potential typo.
17:45:56 <xandaros> lacking a binding, probably
17:45:58 <Welkin> one way to avoid spelling errors like that is tp use autocomplete more often
17:46:08 <Welkin> C-/ in emacs
17:46:11 <ReinH> xandaros: Or that.
17:46:16 <deMoivre> xandaros: bingo
17:46:17 <Welkin> er
17:46:20 <Welkin> M-/
17:46:25 <ReinH> Both are.
17:47:21 <ReinH> It's logical that if the compiler is complaining that the thing you just wrote doesn't exist, there might be something wrong with they way you wrote it.
17:48:04 <Welkin> I learned my lesson long ago that the compiler tells you exactly what is wrong
17:48:10 <ReinH> And in any event, "why doesn't this work?" is a question that should be accompanied by a description of how it doesn't work.
17:48:21 <Welkin> if the error looks cryptic, then you must have typed something other than what you thought
17:48:21 <deMoivre> omg...I think I've made some progress
17:48:26 <deMoivre> that's not possible in Haskell
17:48:31 <deMoivre> Welkin: haha...yeah ;)
17:48:55 <Welkin> a let expression carelessly placed in a rather large do-block led me down a rabbit hole for 2 hours
17:48:56 <xplat> doesn't GHC actually give you 'maybe you meant' hints with out-of-scope errors?
17:49:00 <Welkin> all I had to do was delete it
17:49:56 * hackagebot http-media 0.6.0 - Processing HTTP Content-Type and Accept headers  http://hackage.haskell.org/package/http-media-0.6.0 (TimothyJones)
17:50:12 <shachaf> xplat: In this case I think it would just tell you that you have a type but no definition.
17:50:29 * deMoivre got something!!!
17:50:38 <deMoivre> I never got this far in Clojure or Chicken Scheme
17:51:06 <ReinH> xplat: in other situations, yes
18:14:46 <aavogt> anybody know why there's no instance (Enum a, Ord a, Enum b, Ord b) => Enum (Either a b)?
18:15:43 <pacak> aavogt: How many bits will be used by a and b parts in Enum (Either a b) instance?
18:16:51 <aavogt> fromEnum 0 = Left (fromEnum 0) is a sensible choice, no?
18:17:46 <aavogt> there being less Ints than Integers doesn't stop the standard from defining Enum Integer
18:17:53 <pacak> aavogt: What would be the difference between fromEnum (Right (maxBound :: Int)) vs fromEnum (Left (maxBound :: Int)) in Either Int Int?
18:18:38 <aavogt> > fromEnum (toEnum (maxBound :: Int) + 100  :: Integer)
18:18:39 <lambdabot>  -9223372036854775709
18:20:37 <dfeuer> aavogt, you probably want a Bounded constraint, right?
18:21:04 <aavogt> dfeuer: I think you can do it without Bounded
18:21:30 <dfeuer> aavogt, explain.
18:21:40 <aavogt> succMaybe :: Enum a => a -> Maybe a; succMaybe x = case enumFrom x of [_] -> Nothing; _ : a : _ -> a
18:22:01 <aavogt> I think all we might need is the bound that's implied by enumFrom
18:22:37 <dfeuer> aavogt, you are confusing me very much. What does Maybe have to do with anything? And counting all the way up is not so cheap.
18:23:07 <pacak> aavogt: In worst case scenario you need 64 bits to store a/b and one extra bit to store Left/Right.
18:23:08 <dfeuer> But if the left side is Bounded,
18:23:16 <dfeuer> that could tell you where to start the Right.....
18:24:01 <HeladoDeBrownie> that doesn't look to me like it'd go "all the way up", at most it gets the next element
18:24:12 <aavogt> http://lpaste.net/5973060629714436096 was my original thought (involving Bounded)
18:24:31 <pacak> dfeuer: You don't need bound since you won't have both a and b at the same time, first bit can be used for Left/Right and 63 bits for a/b, but that's not enough bits.
18:25:03 <sjl99> @pl \f g x y -> f (x ++ g x) (g y)
18:25:03 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
18:26:04 <dfeuer> pacak, you need a contiguous range, presumably, to support ranges well.
18:26:37 <aavogt> but then I think it might be sensible to define everything in terms of succMaybe and predMaybe (here http://lpaste.net/8436798525198565376)
18:28:45 <aavogt> dfeuer: but fromEnum = fromJust . elemIndex [somethingThat'sNotMinBound .. ]  -- is what you mean by "counting up isn't so cheap"?
18:30:02 <aavogt> somethingThat'sNotMinBound = fromJust $ last $ takeWhile isJust $ iterate (predMaybe =<<) (Just (fromEnum 0))
18:31:41 <aavogt> probably the contortions needed to avoid Bounded on the left aren't worthwhile
18:32:47 <dfeuer> aavogt, that's my point.
18:33:15 <aavogt> so what about Bounded on the Right?
18:33:34 <dfeuer> aavogt, on the other hand, Enum is a broken broken class that should not exist.
18:33:39 <homovitruvius> anything similar to hspec-attoparsec for parsec? thanks
18:33:54 <dfeuer> It's useful for ranges (and I don't see why you'd *want* those for Either)
18:34:07 <dfeuer> and it's useful for *fast fast fast* conversion to/from Int (which you don't get either)
18:34:13 <dfeuer> So I'm not sure what the point really is.
18:34:35 <aavogt> it's for desugaring ranges
18:37:28 <dfeuer> aavogt, when do you want to do that with Either?
18:41:29 <aavogt> well the actual concern is Variant, but it has the same situation
18:45:55 <aavogt> I might have  type MessageLevel = Variant '[Tagged "quiet" Bool, Tagged "verbose" Bool, Tagged "debug" bool]
18:46:10 <aavogt> and cmdargs can generate sensible flags for that data type
18:46:24 <funfunctor> EvanR: about?
18:46:32 <shachaf> Variant = Foldr Either Void, I suppose.
18:55:46 <dmwit> aavogt: how to handle enumfromthen?
18:56:06 <dmwit> aavogt: when switching from left to right
18:57:25 <aavogt> I don't have code to do it, but you might  elemIndex to (iterate succ from), and elemIndex to (iterate pred from) to get how many succs to do
18:57:38 <aavogt> /how many preds you need between each element
18:57:48 <dmwit> i see
18:58:10 <aavogt> but I guess using Ord is better in that situation (thanks to Double)
18:58:22 <dmwit> no, i don't see
18:59:01 <aavogt> that it can work?
18:59:21 <dmwit> moment
18:59:43 <aavogt> it would be the same as the enumFromTo in http://lpaste.net/8436798525198565376, except instead of succ, it uses some function that might be succ, succ.succ, pred.pred etc.
19:00:41 <dmwit> can't see that paste...
19:01:44 <aavogt> dmwit: should I PM or put it somewhere else?
19:01:56 <dmwit> got it
19:02:09 <dmwit> phone put extra , in url
19:03:56 <dmwit> ok, your answer to my question is
19:04:12 <dmwit> "use fromenum 0"
19:04:45 <dmwit> which is weird and probably wrong in many cases, but ok
19:05:33 <aavogt> well the "enumFromThen x (toEnum 0)" only applies if 'x' has no succ
19:06:15 <dmwit> yes... i.e. when switching from left to right
19:06:56 <dmwit> but e.g. is v. strange for numerical types
19:07:13 <aavogt> that function is just for writing spoon.pred
19:07:18 <dmwit> and may crash for some types, too
19:07:33 <aavogt> look at the http://lpaste.net/8436798525198565376#line43 for how Either is handled
19:07:41 <aavogt> oh you did look there...
19:08:22 <aavogt> yeah 46 could be some "better" minBound-written-in-terms-of-Enum
19:08:51 <octopuscabbage> how do i concurrently access a sqlite database without it constantly throwing errors
19:08:59 <octopuscabbage> is there a way to handle those errors in persistent
19:10:00 <aavogt> you might have one thread whose job it is to talk to the database
19:10:02 <monochrom> dfeuer: why do you want to make brain salads?! :)
19:10:14 <dmwit> I would say the need to use "toEnum <arbitrarynumber>" is a good reason not to write this instance.
19:10:31 <dmwit> aavogt: Perhaps you'd just like an implementation of one of the "searchable" classes available from Hackage.
19:10:39 <dfeuer> monochrom, because it's a funny/crazy thing to imagine?
19:11:35 <aavogt> dmwit: did you look at the other version http://lpaste.net/5973060629714436096 ?
19:11:49 <aavogt> which uses Bounded for most parameters
19:12:17 <nshepperd> instance (Enum a, Enum b) => Enum (Either a b) where { toEnum n = case n `divMod` 2 of { (j, 0) -> Left (toEnum j) ; (j, 1) -> Right (toEnum j) }, ... }
19:13:03 <dmwit> aavogt: I don't think you can rely on 0 being the smallest value returned from fromEnum.
19:13:14 <nshepperd> ^^ the best awful Enum instance
19:13:15 <dmwit> aavogt: So that fromEnum instance looks questionable for the same reason as before.
19:13:42 <monochrom> heh nshepperd
19:13:56 <dmwit> aavogt: I think you should make a separate class.
19:14:02 <dmwit> (personally)
19:14:42 <nshepperd> fromEnum (Left x) = 2 * fromEnum x; fromEnum (Right y) = 2 * fromEnum y + 1
19:15:47 <dmwit> aavogt: edwardk once suggested to me something like class Enum' a where succ', pred' :: a -> [a]
19:16:09 <monochrom> ooohhh, branching
19:16:44 <monochrom> a self-adventure book can be written using this Enum' class :)
19:17:23 <nshepperd> oh hmm, this is slightly too awful, since it'll crash if the two types have different cardinality
19:20:09 <dmwit> Actually, it was probably more like class Searchable a where bigger :: Alternative f => a -> f a; smaller :: a -> Maybe a
19:20:12 <dmwit> or something
19:30:03 * hackagebot unix-time 0.3.5 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.3.5 (KazuYamamoto)
19:37:27 <DELB> I feel like an utter noob answering this question (I am) but how does this work: v
19:37:27 <DELB> [[x * y | y <- [1..5]] | x <- [1..5]]
19:37:40 <DELB> it prints out the time tables up until 5
19:37:47 <DELB> but I dunno the order of execution
19:37:55 <DELB> is it y that gets worked out first or x
19:38:17 <monochrom> x is outer loop, y is inner loop. if that helps.
19:38:38 <dmj`> > [(x,y) | x <- [1,2,3], y <- [4,5,6]]
19:38:39 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
19:39:06 <shachaf> Order of execution isn't specified.
19:39:43 <monochrom> x becomes 1, y goes through 1 to 5. then x becomes 2, y goes through 1 to 5 again. etc.
19:39:52 <shachaf> Define f x = [x * y | y <- [1..5]]. Now that expression is [f x | x <- [1..5]]
19:39:57 <shachaf> Maybe that's easier to follow.
19:40:31 <monochrom> yeah. [f 1, f 2, f 3, f 4, f 5]. now expand those f's.
19:41:12 <DELB> x becomes 1, y goes through 1 to 5. then x becomes 2, y goes through 1 to 5 again. etc.
19:41:19 <DELB> that seemed easier to understand for me
19:41:38 <DELB> what's f mean then?
19:41:39 <DELB> function?
19:41:42 <DELB> function x?
19:41:54 <johnw> it's the name of the function being defined up above, is all
19:41:56 <monochrom> f means "Define f x = [x * y | y <- [1..5]]". that f.
19:42:28 <DELB> ah right
19:42:33 <DELB> cheers
19:45:04 * hackagebot picoparsec 0.1.1 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/picoparsec-0.1.1 (MarioBlazevic)
19:45:41 <DELB> I don't suppose someone could also help me out on the "lazy" bit?  how is Haskell lazy?
19:45:57 <DELB> I mean, I get that Haskell will not do something unless needed to but I haven't had any example code
19:46:31 <johnw> take 1 [[x * y | y <- [1..5]] | x <- [1..5]]
19:46:41 <shachaf> Haskell evaluation is non-strict. Haskell implementations are usually lazy.
19:47:12 <shachaf> > [2*x | x <- [1..]] -- the beginning of an infinite list
19:47:13 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
19:49:03 <DELB> [2*x | x <- [1..]] say this
19:49:07 <DELB> why is this lazy?
19:49:34 <shachaf> Haskell isn't lazy. Haskell evaluation is non-strict.
19:49:42 <shachaf> > let x = 1 : x in x -- simpler example
19:49:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:49:49 <CindyLinz> > let fib = 1 : 1 : [(a+b) | a <- fib | b <- tail fib] in take 10 fib
19:49:50 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
19:49:56 <CindyLinz> DELB: another example
19:50:01 <shachaf> You don't need to look at x to know what 1 : x is.
19:50:16 <shachaf> Well, to get some information about it.
19:51:53 <DELB> gimme another one Cindy, appreciate everyone's help
19:52:07 <DELB> please*
19:52:38 <shachaf> I'm not sure what you need is more examples, or certainly more complicated examples.
19:52:41 <shachaf> Let's take a simpler example.
19:52:54 <DELB> okay
19:53:01 <shachaf> > let { f x = 5; loop = loop } in f loop
19:53:02 <lambdabot>  5
19:53:17 <shachaf> In a strict language, loop would loop.
19:53:29 <shachaf> But f doesn't inspect loop, so it's never evaluated.
19:53:38 <mac10688> Does someone know how to call this function in haskell? I'm going through the learnyouhaskell.com website
19:53:39 <mac10688> addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
19:53:40 <mac10688> addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
19:54:08 <mac10688> I tried addedVectors = addVectors ((5,2)(3,2))
19:54:11 <shachaf> Call it the same way it's defined.
19:54:18 <shachaf> addVectors (x1, y1) (x2, y2)
19:54:21 <pacak> addedVectors = addVectors  (5,2) (3,2)
19:54:27 <shachaf> In your case, addVectors (5, 2) (3, 2)
19:54:30 <Cale> Well, it's reasonable to assume that evaluation will be lazy evaluation. It's good to know that the compiler won't always evaluate everything in that order, but since it always produces the same result as evaluating lazily (just possibly does so using a bit less space or allocation time), you can always understand the behaviour of programs that way.
19:54:34 <mac10688> thanks!
19:54:50 <Cale> (i.e. outermost-first evaluation with sharing)
19:54:52 <shachaf> It's reasonable to assume and it's good to know.
19:55:07 <shachaf> It's a good second step.
19:57:06 <DELB> let { f x = 5; loop = loop } in f loop so this code should make the code in f loop but since Haskell is lazy it won't?
19:57:37 <mac10688> I'm going to make a statement and it would be nice if someone would confirm it. I was trying to write all the examples from the website but it seems I can't print more than once for a module. So I have to keep declaring a bunch of variables and print it out at the very end
19:57:40 <DELB> and why won't f inspect loop?
19:58:13 <shachaf> Because it doesn't need to.
19:58:23 <shachaf> f x = 5, for any x. Even loop.
19:58:37 <shachaf> mac10688: Hard to understand what you mean or what the problem is.
19:59:12 <mac10688> http://pastebin.com/1fB7yaFM
19:59:31 <mac10688> I wish I could print out each variable as I define it but it complains about a naked top level function or something
19:59:39 <shachaf> Much clearer.
19:59:58 <mac10688> so in the end I have to use main = print (<variables...>) to get what I want
20:00:23 <shachaf> You can only print from main or from things main calls, just like in C.
20:00:24 <mac10688> just kind of clunky :(
20:00:57 <shachaf> You can write "main = do", and then "  print x", "  print y", "  print z" on subsequent lines.
20:01:01 <DELB> let { f x = 5; loop = loop } in f loop
20:01:09 <DELB> if this was a strict language it would loop x = 5?
20:01:10 <shachaf> You can also open the file in ghci and inspect things as much as you like.
20:01:58 <mac10688> I suppose so, it's just a lot easier to follow along with my sublime editor and ctrl + b to see all the results
20:02:08 <mac10688> but oh well, I'll keep at it
20:02:10 <shachaf> Yes. For example in C: "int loop() { return loop(); }"; "int f(int x) { return 5; }"; "f(loop())"
20:04:06 <DELB> right I see
20:04:14 <DELB> I still don't see why Haskell just goes lazy on it though
20:04:24 <DELB> too used to OOP/Imperative languages lol
20:04:51 <shachaf> Haskell "goes lazy" (non-strict) on everything.
20:05:31 <shachaf> If you wrote "f x = x + 1", then you'd be in trouble, because what's "f loop"?
20:05:45 <shachaf> (It's "loop + 1". But now what?)
20:08:30 <DELB> f x = x + 1, my brain is just reading that is inputting a value into x and then it's whatever x is + 1
20:08:40 <DELB> where does the loop come into it? :)
20:12:22 <solatis> can i make a bold statement?
20:12:28 <solatis> incremental parsing in attoparsec sucks
20:13:24 <Cale> I blame solatis for not improving it
20:13:33 <solatis> haha
20:13:34 <solatis> well
20:13:42 <solatis> this might be my own fault
20:13:51 <solatis> but i'm doing network reading, and incremental parsing
20:14:04 <solatis> and i get a partial on some input
20:14:16 <solatis> where the parser has to decide between 5 different tokens
20:14:24 <solatis> and there is absolutely *one* token that can match
20:14:35 <solatis> (the input is: "SESSION STATUS RESULT=INVALID_KEY\n"
20:14:35 <solatis> )
20:14:42 <solatis> and attoparsec returns a partial
20:15:01 <solatis> so i need to tell attoparsec that the end of the input has been reached
20:15:09 <solatis> but how do i do that in a networking context?
20:15:32 <solatis> in other words, my socket read operation blocks, because the other side of the socket doesn't send any more data
20:15:55 <Cale> Apply the continuation to an empty string
20:17:44 <solatis> .. and how can i differentiate between a slow socket connection and "no more data will be sent" ?
20:18:05 <solatis> as in, because attoparsec returns a partial, my code assumes more data should be received from the socket
20:18:11 <solatis> so it attempts to read
20:18:19 <solatis> but no more data will be sent
20:18:28 <solatis> so i'll have to work with timeouts?
20:18:33 <solatis> that sounds like an ugly hack
20:19:11 <Cale> Well, why is your parser demanding more input?
20:19:19 <solatis> that is exactly my question
20:19:22 <solatis> i have no idea why
20:19:30 <solatis> https://github.com/solatis/haskell-network-anonymous-i2p/blob/mvp/src/Network/Anonymous/I2P/Protocol/Parser.hs#L88
20:19:33 <solatis> that is the code in question
20:19:49 <solatis> as far as i can see, https://github.com/solatis/haskell-network-anonymous-i2p/blob/mvp/src/Network/Anonymous/I2P/Protocol/Parser.hs#L80 is the only branch that could succeed
20:20:42 <solatis> it might have to do with my use of string
20:21:10 <solatis> since string s = takeWith (T.length s) (==s)
20:21:17 <solatis> as in, there are other branches that require longer strings
20:21:52 <solatis> but it only wants to compare them as soon as T.length s bytes first have consumed
20:22:12 <solatis> so a branch that can only fail, apparently doesn't have enough input yet to know that it will fail
20:22:20 <solatis> because it is very greedy
20:23:41 <solatis> imho it should keep taking 1 character and return false as soon as one of the characters doesn't match
20:23:48 <solatis> which works a lot better in an incremental context
20:24:10 <solatis> guess i'll should make my own "string" parser for this
20:24:55 <nshepperd> it does 'ensure n'
20:25:11 <nshepperd> how silly
20:25:50 <solatis> yeah that is what i mean, it's probably good for performance, but absolutely sucks in an incremental situation
20:26:26 <solatis> they even claim that attoparsec does incremental parsing because that is awesome for network programming, but then pull a trick like this
20:28:30 <Cale> solatis: okay, so:
20:28:31 <Cale> ghci> parse ("SESSION STATUS RESULT=" *> parseResultInvalidKey) "SESSION STATUS RESULT=INVALID_KEY\n"
20:28:31 <Cale> Done "\n" SessionResultInvalidKey
20:29:18 <Cale> ghci> parse ("SESSION STATUS RESULT=" *> parseResultInvalidKey <* endOfLine) "SESSION STATUS RESULT=INVALID_KEY\n"
20:29:18 <Cale> Done "" SessionResultInvalidKey
20:31:19 <Cale> ah, yeah, that's it
20:35:15 <nwf> Hey channel; pardon a dumb question.  https://ghc.haskell.org/trac/ghc/wiki/Prelude710/FTP mentions that there are Traversables for which traverse blows the stack but mapM won't, but it doesn't say what an example is.  Is there an easy-to-understand example?
20:37:41 <Cale> solatis: yeah,  string' = mapM (Atto.satisfy . (==)) . BS.unpack -- works
20:41:08 <Cale> solatis: I guess another option would be to rearrange the <|>'s so that they're in order of increasing length of demanded string
20:41:28 <Cale> solatis: Which maybe would perform better at the expense of being ridiculously sneaky
20:44:23 <Cale> solatis: It's a shame that Parsec and Attoparsec both don't have a symmetric <|>
21:01:00 <nshepperd> nwf: good question
21:01:16 <nshepperd> nwf: I think edwardk might know
21:01:35 <nwf> I have yet to encounter a question to which that is not an appropriate response.
21:02:23 <nwf> In any case, it's hardly urgent, I was just curious.
21:02:35 <nshepperd> heh
21:03:12 <ddellacosta> I could imagine some, but I'd probably get banned from #haskell if I typed them out
21:12:13 <shachaf> nwf: I didn't see that but now I'm also curious what the example is.
21:12:27 <solatis> Cale, thanks, i'll try the 'increasing length' option
21:12:37 <solatis> it is sneaky, but not more sneaky than certain pattern matches
21:15:11 * hackagebot word8 0.1.2 - Word8 library  http://hackage.haskell.org/package/word8-0.1.2 (KazuYamamoto)
21:19:40 <sclv> nwf, shachaf -- the example is a necessarily finite but very long list
21:20:31 <nwf> sclv: I'm not smart enough to immediately understand that; would you mind unpacking that a bit for me?
21:20:33 <shachaf> As in data L a = Z | C a !(L a) ?
21:22:46 <sclv> or just a regular list where you guarantee it is finite
21:22:55 <n1cky> i'm trying to solve #1 of project euler in haskell and i'm a bit stuck on trying to knock down exactly how to manage haskell. This is my first interaction with haskell and functional programming in general.
21:23:16 <n1cky> is this a bad place to get help?
21:23:28 <shachaf> sclv: Why is a regular list an example?
21:23:59 <sclv> i think the trick is that with the monadic action you can basically generate the "result" list using the old "generate backwards than reverse" accumulating parameter trick
21:24:09 <sclv> but if you only have the power of an applicative, you can't
21:24:14 <shachaf> Do you have an example?
21:25:02 <MrBuzz> why has Haskell been catching on recently.
21:25:13 <Axman6> n1cky: this is an excellent place for help. perhaps you should start with a haskell tutorial though
21:25:23 <Axman6> @where learnhaskell
21:25:24 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:25:28 <Axman6> n1cky: ^^^^^^
21:25:38 <sclv> so traverse builds up the usual big list of thunks you get out of a foldr, while mapM' lets you do effectively a foldl' and reverse :-)
21:25:52 <evenex> general terminology question - say i have a 3D data structure whose points are some values (so its like a (int,int,int) indexed container in other words) and i want to reinterpret it as a 1D container of 2D containers... or put another way, i want to reinterpret a cube as a line whose points are planes... is there a name for this kind of operation?
21:25:55 <funfunctor> hi
21:26:05 <EvanR> MrBuzz: only recently?
21:26:15 <shachaf> Do you have an example I can run? I've done lots of things with traverse but I don't think I've encountered an issue where mapM would help.
21:26:28 <funfunctor> hi EvanR, so I manged to rip out that StateT from the binding as you suggested
21:26:35 <sclv> i don't have an example handy. i just remember the story from hearing it a few times.
21:26:35 <EvanR> excellent
21:26:43 <MrBuzz> EvanR: I programmed with it in the latter '90s, interesting to see thta it has more interest
21:26:46 <sclv> iirc, dolio and rwbarton are the ones who cooked it up
21:27:17 <funfunctor> EvanR: I'm not sure how i can rip out StateT from RadioDevice though to get rid of the monadic type parameter from the RadioDevice definition though
21:27:49 <sclv> MrBuzz: the big turning point was getting a package repo and story that is decent, via hackage and cabal
21:27:55 <EvanR> funfunctor: should happen imo
21:28:05 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121061
21:28:07 <sclv> combined with the work of the ByteString crew and related in pushing performance into good territory
21:28:15 <funfunctor> EvanR: here is how the BladeRF driver looks now
21:28:34 <sclv> then a whole bunch of work on the IO manager + a nice concurrency and parallelism story
21:28:43 <MrBuzz> sclv: whats the primary use case for it
21:28:44 <sclv> together these made it a much more appealing language for real world applications
21:29:02 <sclv> MrBuzz: it is a general purpose language :-) people use it for everything these days!
21:29:43 <MrBuzz> sclv: something caused more interest in it, it lay dormant for years
21:29:45 <EvanR> funfunctor: where is RadioDevice
21:29:58 <sclv> MrBuzz: I just gave three things that came together
21:30:06 <funfunctor> EvanR: the definition of the type?
21:30:10 <EvanR> yes
21:30:57 <sclv> it evolved into a much better language for many purposes than prior, and the efforts of a few early adopters in pushing it into real world use then inspired a next and next-next generation
21:30:58 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121063
21:30:59 <funfunctor> EvanR: ^
21:31:30 <sclv> and the existence of Hackage meant that we had a multiplier effect because people could leverage increasingly good sets of libraries
21:31:45 <EvanR> funfunctor: so for example on this line
21:31:54 <EvanR> getRxGain             :: m Double
21:32:10 <EvanR> is that a IO Double
21:32:16 <funfunctor> EvanR: should be :: IO Double
21:32:17 <funfunctor> yes
21:32:21 <funfunctor> but..
21:32:21 <EvanR> i mean, make that a IO Double
21:32:45 <EvanR> if it were a constant, then :: Double
21:32:52 <EvanR> but i see you can configure it at will
21:33:56 <funfunctor> EvanR: you see that wont type-check because Couldn't match expected type `IO Double' with actual type `BladeRFDevice Double'
21:34:06 <EvanR> wheres that
21:34:20 <funfunctor> EvanR: BladeRFDevice is in the first paste
21:34:32 <EvanR> what line would cause that type error
21:34:52 <EvanR> bladeRFGetRxGain ?
21:34:57 <funfunctor> EvanR: src/BTS/RadioDevice/BladeRFDevice.hs:145:55:
21:35:14 <EvanR> right, that function wouldnt even need to exist
21:36:47 <funfunctor> EvanR: but rxGain is stored in data HwState, that is runtime dynamic
21:37:12 <EvanR> funfunctor: its deriving from HwState, instead of having all the mutable variable values in one record, have it be a record of mutable variables that can be changed independently
21:37:25 <EvanR> TVar Double, for example
21:37:28 <EvanR> or IORef
21:37:41 <funfunctor> Oh, I don't know how they work?
21:37:46 <EvanR> IORef?
21:37:54 <funfunctor> TVar and IORef
21:37:57 <EvanR> that would explain a few things ;)
21:38:10 <EvanR> look at Data.IORef
21:38:12 <funfunctor> ok.... learning time
21:38:22 <funfunctor> looking now
21:38:55 <funfunctor> and what is TVar, whats the difference between that and IORef?
21:39:08 <EvanR> its the same thing but you can modify a bunch of TVars in a transaction
21:39:15 <EvanR> from concurrent threads
21:39:49 <funfunctor> ok so IORef is like a pointer and TVars is the thread-safe version?
21:40:01 <EvanR> IORef is an object holding a value
21:40:15 <EvanR> you can put in a new value
21:40:21 <EvanR> with an IO action
21:40:24 <funfunctor> like a mini StateT except not so rigid?
21:40:38 <EvanR> its not like StateT at all
21:41:00 <heatsink> It's a piece of mutable data
21:41:00 <funfunctor> but IORef is stateful right? i.e. it remembers stuff
21:41:26 <EvanR> its a mutable variable
21:41:36 <heatsink> I think it's reasonable to say it's like a pointer
21:41:48 <EvanR> head scratch
21:41:54 <heatsink> But the important thing is that it's mutable
21:41:56 <EvanR> theres probably several pointers involved
21:42:12 <funfunctor> if you say "its like using a pointer" I get it in practice, I realise the theory is different
21:42:17 <Cale> It's a mutable pointer to an immutable value
21:42:19 <EvanR> thats confusing
21:42:29 <Cale> behind the scenes
21:42:42 <funfunctor> is that not zero copy then?
21:42:45 <funfunctor> i.e. expensive
21:43:23 <Cale> Well, those values are themselves represented by pointers to code
21:43:51 <funfunctor> ok, right so IORef isn't really thread safe
21:44:06 <EvanR> depends
21:44:07 <funfunctor> well maybe on something other than x86 it is
21:44:21 <Cale> Well, what exactly do you mean by thread safe?
21:44:22 <funfunctor> I could imagine load and store getting mixed up
21:44:29 <Cale> It's impossible to do a half-update
21:44:57 <funfunctor> oh! yea, says exactly that in the doc http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-IORef.html see end of page
21:44:58 <Cale> But it's not synchronised in any other regard
21:45:11 <EvanR> a single IORef can be modified by several threads, but two IORefs that need to updated consistently wont work from multiple threads
21:45:13 <funfunctor> ok, so TVars, how does that work
21:45:19 <Cale> There's atomicModifyIORef which does a compare and swap
21:45:42 <Cale> TVars are mutable variables which are only accessible via STM transactions
21:45:44 <funfunctor> is TVars like a chained together atomicModifyIORef?
21:45:51 <Cale> not really
21:46:03 <Cale> It's more like database transactions for memory
21:46:20 <heatsink> Why do we have both IORef and MVar?
21:46:21 <funfunctor> here comes the horribly missinformed stupid question "which is better miss?"
21:46:34 <EvanR> IORef and MVar do different things
21:46:39 <Cale> heatsink: MVar has totally different semantics
21:46:42 <EvanR> MVars can be empty
21:46:45 <funfunctor> ok so MVar is acid state
21:46:48 <Cale> uhhh
21:47:08 <Cale> I can't even explain all the things that need explaining all at once here
21:47:10 <Cale> lol
21:47:16 <Cale> Okay, let's start with MVar
21:47:18 <Cale> before STM
21:47:19 <funfunctor> lol sorry
21:47:22 <Cale> because STM is more involved
21:47:26 <funfunctor> ok
21:47:37 <heatsink> Did MVar come from Id?
21:47:39 * funfunctor takes out pen
21:47:52 <Cale> So, an MVar is a mutable cell which may be empty or full.
21:48:03 <Cale> Writing to an empty MVar fills it
21:48:16 <Cale> Taking (reading) from a full MVar empties it
21:48:27 <Cale> Writing to a full MVar will block until it is empty
21:48:38 <Cale> Taking from an empty MVar will block until it is full
21:49:37 <Cale> The usual access pattern is to takeMVar, compute the new value (during which time any other thread wanting to update the MVar will takeMVar and block), and then putMVar the updated value
21:50:18 <heatsink> Do all MVar accesses behave as memory barriers on relaxed consistency hardware?
21:50:52 <Cale> You can also do things like have the main thread create an empty MVar, fork a bunch of threads to try to write to it, have the main thread read from the MVar and then kill all the threads, in order to have a bunch of threads race to compute something.
21:51:24 <AY23Z5r> Haskell? That dead language of yore? HAHAHA
21:51:50 <EvanR> haskell is dead. long live haskell
21:52:06 <Cale> heatsink: MVars work exactly like I described independently of the hardware. If they do anything else, it's a GHC bug.
21:53:48 <Cale> When multiple threads are blocked on either taking an empty MVar or putting to a full one, they are woken up in FIFO order.
21:54:05 <Cale> If that helps any
21:54:20 <Cale> (and only one gets woken up when the MVar becomes available)
21:54:30 <EvanR> funfunctor: use an IORef unless you are thinking of giving multiple threads low level access to these hardwares, in which case you need to probably think hard again
21:54:38 <platz> this sounds like blackhole territory
21:54:45 <heatsink> Cale: You did not describe how the ordering of multiple MVar accesses is observed by other threads.
21:55:23 <Cale> heatsink: Hm?
21:55:32 <Cale> heatsink: You can't read from an MVar without emptying it.
21:55:41 <EvanR> Cale: you can now, with readMVar
21:55:50 <EvanR> which is interesting
21:56:06 <heatsink> Cale: let x, y :: MVar Int; In relaxed consistency, it's possible that thread A updates x, then y, and thread B observes x's value changing before y's value changes.
21:56:11 <Cale> EvanR: oh, yeah, that's new
21:56:18 <heatsink> Cale: That situation is consistent with what you have described.
21:56:28 <heatsink> err
21:56:29 <funfunctor> ... just writing all this down...
21:56:37 <heatsink> thread B observes y's value changing before x's value changes
21:56:46 <Cale> funfunctor: You could also just http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Concurrent-MVar.html#t:MVar
21:58:01 <carter> Cale: heatsink  i think the semantics of CAS in a multi core parallel setting are CPU arch depdnent
21:58:18 <carter> in a single threaded runtime, its obviously sequentially consistent
21:58:28 <carter> likewise, on x86
21:58:32 <carter> not sure about anywhere else though
21:58:34 <Cale> Yeah, I don't know about distinct MVars... the paper probably answers that question.
21:59:08 <heatsink> I just found a blog post by ezyang saying that IORef accesses can be observed out of order.  The post doesn't say what happens with MVar.
21:59:15 <funfunctor> Cale: thx for that ! I wrote it all down also
21:59:58 <funfunctor> ok this makes much more sense now
22:00:11 <funfunctor> EvanR: yea, multiple threads will complete for hardware
22:00:21 <heatsink> carter, yeah.  So MVar accesses are like CAS instructions as far as consistency goes?
22:00:25 <funfunctor> EvanR: multiple clients will want to send their data to the hw
22:00:31 <Cale> heatsink: Yeah, I think you can observe the updates in reverse order, but it's usually not a huge difficulty when you're using the abstraction
22:00:36 <EvanR> funfunctor: ok... if they are competing and can issue multiple low level instructions interleaved, that sounds crazy
22:00:56 <funfunctor> EvanR: its pretty tricky
22:01:08 <EvanR> funfunctor: so maybe clients should have to take a lock before issuing instructions?
22:01:29 <funfunctor> EvanR: they use mutex locks in this C++ code
22:01:45 <EvanR> then you should include one MVar in your object for this purpose
22:01:51 <funfunctor> I'm going to think about this for a bit
22:02:29 <platz> atomicModifyIORef' seems to do something quite similar
22:02:34 <EvanR> the api would use it behind the scenes when you do the withDevice bracket thing
22:03:16 <EvanR> implemented with withMVar
22:03:50 <Cale> heatsink: I guess the new readMVar changes things because it lets you look at the value of an MVar atomically without taking it
22:04:46 <Cale> heatsink: But ordinarily, in order to observe the value of two MVars in a way that can let you see either order you'd need to have the takeMVars happening in separate threads anyway
22:05:10 <EvanR> in an office setting this kind of mutual exclusion can be implemented on some office resource. you cant use "crappy single user tool" until you find the stuffed animal. if you dont have the animal you dont know if someone is using crappy single user tool
22:05:14 * hackagebot euler 0.3.0 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.3.0 (decomputed)
22:05:27 <funfunctor> MVar sounds like a "better" IORef to me
22:05:37 <funfunctor> but maybe a little more expensive
22:05:42 <Cale> funfunctor: Well, it's different.
22:05:48 <EvanR> using MVar for all your internal variables doesnt make sense
22:05:49 <heatsink> That's an interesting point about the ordering of updates not being observable with takeMVar.
22:06:16 <funfunctor> more "powerful"
22:06:20 <dmwit> funfunctor: MVar's can be empty, but IORef's can.t
22:06:26 <funfunctor> if you were explaining it to a 2year old
22:06:35 <dmwit> funfunctor: If you include that in your "better", then maybe so. =)
22:06:46 <funfunctor> hehe
22:06:56 <heatsink> For a 2 year old, a cookie would be even better than MVars
22:06:59 <EvanR> your variables couldnt be empty before so im not sure why they need to be now
22:07:21 <funfunctor> dmwit: did we once swap code on github, I seem to remember your nick
22:07:38 <dmwit> Sounds plausible.
22:07:40 * dmwit shrugs
22:07:44 <funfunctor> lol
22:08:41 <funfunctor> dmwit: oh cryptol stuff
22:08:51 <dmwit> Oh, quite recent, then!
22:09:04 <Cale> funfunctor: So, there's still a problem with MVars, in that once you start using more than one, you can run into problems: If you have one thread doing takeMVar x followed by takeMVar y and a second thread doing takeMVar y followed by takeMVar x, then each thread can take one of the MVars and then they both get stuck
22:09:37 <funfunctor> Cale: deadlock
22:09:40 <Cale> right
22:09:54 <funfunctor> thanks for the heads up on that one!
22:10:33 <Cale> So, STM is designed to allow for more complicated communication between threads, in such a way that to each thread, it looks as if they're the only thread running in the system (even though that's not true)
22:10:34 <EvanR> the straightforward translation from what you had to what you need is IORefs, your StateT wasnt concurrent
22:10:36 <dmwit> Or of course you can choose STM instead. Then you get to deal with livelock, which is ever so much better.
22:11:10 <funfunctor> lol
22:11:29 <funfunctor> I wife says software is like stripping, always making compromises
22:11:36 <Cale> STM at least guarantees a certain kind of progress -- it doesn't guarantee that any particular transaction will ever complete, but it can guarantee that *some* threads are getting to do their work.
22:11:42 <funfunctor> I figure she knows more about software than me
22:12:11 <EvanR> no compromises
22:12:13 <Cale> STM *could* guarantee that any given transaction will eventually finish, and that might happen someday
22:12:16 <fryguybob> Cale: Ideally, but there is a narrow window in the implementation for live-lock.
22:12:18 <EvanR> i hate that excuse
22:12:24 <Cale> without having to change any client code
22:12:27 <funfunctor> alright, i'll start with IORef and then move my way up in complexity as I need to
22:13:02 <Cale> fryguybob: oh, okay, I'm not totally familiar with the bugs :)
22:13:18 <funfunctor> If only I was born a puppy..
22:13:21 <dmwit> Stripping involves compromises?
22:13:29 <dmwit> Maybe I don't want to probe in that direction.
22:13:32 <fryguybob> funfunctor: You could view the STM semantics as less complexity then IORef.
22:13:57 <fryguybob> funfunctor: Certainly it is less complex the MVar as soon as more then one MVar is in play.
22:14:12 <EvanR> you need to lock out multiple instructions in a row anyway, STM would make that more complex
22:14:26 <EvanR> since the instructions are more than just changes to the variables
22:14:46 <Cale> funfunctor: Basically, the idea of STM is that you have this monad STM, which is like IO, except that the only effects you can cause are changes to TVars (and related structures built up from them). There's a function atomically :: STM a -> IO a which causes an entire STM action to occur as-if-atomically with respect to all the other threads.
22:14:50 <EvanR> i see no need for multiple MVars
22:15:45 <funfunctor> ok thanks guys
22:15:56 <Cale> There are programs for which IORef, MVar, and TVar are the simplest approach
22:16:05 <Cale> none of them really beats the others
22:16:07 <funfunctor> I better write some code, see how I go and then probably throw 70% away
22:16:26 <funfunctor> understood
22:16:27 <EvanR> deletion of code is the most productive part ;)
22:16:36 <funfunctor> they solve different problems
22:16:53 <funfunctor> EvanR: I know ;)
22:17:06 <funfunctor> but I have to generate some entropy first..
22:17:20 <Cale> The original paper on STM in Haskell is really good: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
22:17:38 <funfunctor> Cale: thx!
22:17:56 <Cale> It sort of starts off with a tutorial about how it works
22:18:38 <funfunctor> I better get off here and write some code while its still fresh in my mind..
22:18:58 <funfunctor> thx again for all the advice
22:19:19 <fryguybob> heatsink,Cale: From what I can tell in the implementation, there should be a global total order on MVar operations.
22:20:07 <heatsink> fryguybob: That's good to hear
22:20:35 <fryguybob> The only exception would depend on what this comment means: https://github.com/ghc/ghc/blob/192128da38b0aa9b23cd2df45c92eb20529f1c75/includes/stg/SMP.h#L142
22:20:50 <fryguybob> I'm not familiar enough with ARM to know off-hand.
22:21:34 <fryguybob> But I would say that it would be a bug if there isn't a total order.
22:23:20 <fryguybob> Well, I suppose I don't know enough about if GHC itself could reorder MVar operations, but I assume it doesn't do that.
22:23:53 <heatsink> probably not
22:24:30 <heatsink> but that's the kind of thing that could happen in the future if someone adds more clever optimizations while the memory semantics isn't fully specified
22:24:44 <fryguybob> heatsink: Right
22:25:46 <dfeuer> Cale, some crazy people are saying we should deprecate and remove fromJust, so I responded with a better implementation that uses a GADT with unsafeCoerce to avoid checking if the constructor really is Just.
22:26:25 <dfeuer> I hope that gets coffee on someone's keyboard.
22:26:26 * heatsink can't tell if that's a joke
22:27:06 <dfeuer> heatsink, the best jokes have an element of truth in them, no?
22:27:12 <heatsink> yah
22:27:26 * EvanR likes fromJust the way it is, and would like a fromRight
22:27:27 <fryguybob> @quote fromJust
22:27:27 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
22:27:36 <EvanR> lol
22:27:54 <dfeuer> Haaa
22:28:09 <EvanR> fix safeFromJust
22:29:45 <dfeuer> data FakeMaybe b a where {N:: FakeMaybe 'False a; J :: FakeMaybe 'True a} fromJ::IM 'True a->a; fromJ (J a) = a
22:30:02 <dfeuer> fromJust m = fromJ (unsafeCoerce m)
22:30:49 <fryguybob> @quote isJust.=.unsafe
22:30:50 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
22:31:04 <dfeuer> (er ... but the last line needs a type signature to avoid crashing GHCi :-))
22:31:09 <fryguybob> That's the one I was thinking of, but monochrom's is good too :D
23:00:17 * hackagebot duplo 1.8.1 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.8.1 (kenhkan)
23:36:38 <L8D> sup people
23:38:15 <bitemyapp> L8D: hi
23:38:58 <L8D> bitemyapp: :D
23:42:11 <funfunctor> hi
23:42:31 <funfunctor> EvanR: alright so I learnt how IORef works basically
23:42:41 <funfunctor> I still don
23:42:49 <funfunctor> t fully get how it solves me issue yet
23:43:17 <EvanR> you can implement getRxGain :: IO Double by using readIORef
23:43:24 <EvanR> :t readIORef
23:43:25 <lambdabot>     Not in scope: ‘readIORef’
23:43:25 <lambdabot>     Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
23:43:31 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121068
23:43:59 <funfunctor> lets try converting this
23:44:22 <funfunctor> EvanR: how can I deal with updateTime
23:44:37 <EvanR> what is it supposed to do
23:45:00 <EvanR> seems to be like IO (), so not sure the effect
23:45:13 <funfunctor> EvanR: timestamp when DeviceWriteSamples has occured
23:45:38 <EvanR> it samples the current time and does what/
23:45:46 <funfunctor> since when the device was first started in withNullDevice
23:46:45 <EvanR> but why do i care about calling this if it has no return value
23:47:41 <EvanR> i cant read the code
23:48:36 <funfunctor> EvanR: well what I am doing at the moment is holding the state since we first started the clock
23:49:03 <EvanR> the initial timestamp would be a constant for a given instance of the device
23:49:17 <EvanR> since its a null device, maybe youre not doing anything important at all
23:49:47 <funfunctor> true, its not "critical" in the null device in the sense that its just emulating what bladerf /would/ do
23:50:09 <EvanR> we cant get to the meat of this matter without having some goal
23:51:18 * EvanR implements updateTime :: IO () as return () ;)
23:52:02 <EvanR> funfunctor: how about implementing get and set rx gain
23:52:23 <funfunctor> ah ok so the goal is to have packets timestamped so they can be sorted in a priority queue
23:52:37 <funfunctor> EvanR: yea ok
23:52:56 <EvanR> (but why and how would a client call updateTime to do this)
23:53:36 <funfunctor> EvanR: client does not call updateTime, that happens in the backend driver upon Write and Read samples
23:54:41 <EvanR> then you might not need it as such
23:55:24 <EvanR> i have two things to say about this pattern, where you have an "atomic instruction" of type IO () and its supposed to sample the time at the time its executed for some purpose
23:55:40 <funfunctor> EvanR: alright so what would you expect the type signature of bladeRFGetRxGain ?
23:55:50 <mswan> quit
23:56:38 <EvanR> the relevant time of the current action will change depending on when in the action you execute the call to getCurrentTime. if you do this more than once, you will get inconsistent values for the time
23:56:57 <EvanR> so a better idea is to get the time once and pass it around for the duration of this action
23:57:18 <EvanR> second, because its an IO (), rather than UTCTime -> IO (), you cant configure which time is being used
23:57:53 <EvanR> so generally not having "current time" be some magic variable that can be read at any time, you should agree on the start time of the current action and use that
23:58:49 <EvanR> that sentence didnt make complete sense. but its basically a functional perspective on action time. the opposite sentiment is encapsulated in acme-now where the current time is a pure value
23:59:36 <EvanR> funfunctor: in the interface you have getRxGain :: IO Double
23:59:39 <funfunctor> EvanR: do you mean currentStamp
23:59:52 <EvanR> getCurrentTime
