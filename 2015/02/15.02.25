00:00:03 <tdammers> it makes sense to define instances for common types in the same module as the typeclass
00:00:08 <jle`> oh i see
00:00:12 <jle`> i missed the "and"
00:00:25 <mrkkrp> well, I'm trying to make Haskeline work with my custom (newtype dfined) monad transformer
00:00:26 <jle`> :)
00:00:36 <mgsloan> Just being pedantic :)
00:00:39 <mrkkrp> I don't think I can modify source files of Haskeline
00:01:22 <jle`> i encourage it mgsloan :D
00:03:27 <Arahael> So I have "eitherFoo bar baz = try (foo bar baz)", how can I get it to a point-free form?
00:04:51 <ReinH> Arahael: You can do it, but it isn't worth it
00:05:09 <dmj`> @pl eitherFoo bar baz = try (foo bar baz)
00:05:09 <lambdabot> eitherFoo = (try .) . foo
00:05:15 <ReinH> eitherfoo = (try .) . foo
00:05:17 <ReinH> right
00:05:18 <dmj`> ew
00:05:37 <Arahael> ReinH: I agree, but it's worth knowing how, I reckno.
00:05:37 <dmj`> such obfuscate
00:05:38 <LordBrain> if you have hlint, turn off the warning
00:05:40 <Arahael> ReinH: I agree, but it's worth knowing how, I reckon.
00:05:41 <ReinH> or fmap try . foo, if you want something even harder to read
00:05:53 <SrPx> tdammers: I don't get any of your solutions :(
00:06:02 <LordBrain> i don't really agree with hlint's defaults
00:06:12 <SrPx> tdammers: but I've posted the question on SO
00:06:15 <LordBrain> i'm guessing i am not the only one
00:06:16 <SrPx> thanks! good night
00:06:36 <Arahael> ReinH: I'm strugglign with the mental step of thinking of the (try .) . foo form.
00:06:38 <jle`> was wrestling with a really weird type error all last night and this afternoon
00:06:50 <jle`> but now it just compiles like magic
00:06:56 <jle`> maybe ghc isn't a pure function
00:08:36 * hackagebot vivid 0.1.0.1 - Sound synthesis with SuperCollider  http://hackage.haskell.org/package/vivid-0.1.0.1 (TomMurphy)
00:08:36 * hackagebot yesod-bin 1.4.3.10 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.10 (MichaelSnoyman)
00:10:31 <Arahael> I'm also looking in hoogle for: ([a] -> Maybe b) -> [[a]] -> [Maybe b]
00:12:02 <Hijiri> Arahael: map?
00:13:01 <Arahael> Hijiri: Similar.  Actually I guess what I should be looking for, is something that takes [a] -> Maybe b, and then just use map.
00:14:24 <Arahael> Nevermind, seems I'm _still_ yet to learn the types properly! I wanted [a] -> Int -> Maybe a
00:14:58 <Hijiri> safe subscripting?
00:15:18 <Arahael> Hijiri: Yes. :)
00:15:24 <Arahael> A safer version of !!.
00:16:57 <Arahael> I suppose I should just make my own, and call it !!?
00:17:43 <Hijiri> there is Safe.at
00:18:19 <Hijiri> oh, that is wrong
00:18:36 <Hijiri> Safe.atMay
00:19:04 <lpaste> MP2E pasted “safe (!!)” at http://lpaste.net/121171
00:19:30 <MP2E> oh didn't know there was a Safe function for it already, but that makes sense
00:19:39 <MP2E> I just wrote my own when I encountered that issue.
00:20:49 <Procian> ? \n -> listToMaybe . take n
00:21:11 <Procian> Sorry, drop
00:21:29 <Procian> Though that goes awry with negative argument.
00:22:20 <Arahael> Procian: That's different.
00:23:33 <Arahael> MP2E: Hmm, that does look good...  I was thinking of simply using 'if length...'
00:23:42 <Arahael> MP2E: But yours should be twice as fast, I expect?
00:24:05 <Procian> > (\n -> listToMaybe . take n) 3 [1..10]
00:24:06 <lambdabot>  Just 1
00:24:09 <Procian> > (\n -> listToMaybe . drop n) 3 [1..10]
00:24:11 <Arahael> MP2E: (And yours would work for infinite lists, whereas I guess length would die)
00:24:11 <lambdabot>  Just 4
00:24:15 <Procian> > (\n -> listToMaybe . drop n) 15 [1..10]
00:24:16 <lambdabot>  Nothing
00:24:26 <Procian> > (\n -> listToMaybe . drop n) (-15) [1..10]
00:24:27 <lambdabot>  Just 1
00:24:51 <Arahael> Procian: How does it not return a list?
00:25:40 <Procian> Arahael: listToMaybe is basically a safe head.
00:25:56 <Procian> So if you drop some elements, and then do a safeHead, you've got a safe-index (though negatives)
00:26:46 <Arahael> Procian: Cool - so yours is the same - and much more concise.
00:28:11 <Procian> Arahael: Except MP2E's sensibly returns Nothing for negative argument. You might want a guard there.
00:28:59 <Arahael> Procian: Point.  In this case, I don't need that.
00:41:23 <funfunctor> how can I modify a signal field of a record data type leaving the rest alone in a non-messy way?
00:43:08 <funfunctor> suppose data MyThing = MyThing { foo :: Int , bar :: Double } and I have myThingRef <- newIORef MyThing 0 0.0    and later I want to modifyIORef myThingRef   but change only foo
00:44:21 <merijn> funfunctor: If "xyzzy :: MyThing" then you can write "xyzzy { bar = 2.0 }" which will return a new MyThing with the 'bar' field set to 2.0
00:44:48 <mniip> \m -> m{foo = 2}
00:44:48 <funfunctor> merijn: thanks and that keeps everything else in tact I trust?
00:44:50 <merijn> Note that this is a copy/new value, since modifying isn't possible with immutable data :)
00:44:53 <mniip> no better way
00:45:11 <funfunctor> ok so it has a slight overhead
00:45:31 <merijn> funfunctor: Maybe, maybe not. Allocation is cheap and copying is shallow copying, so...
00:45:42 <funfunctor> true, ok
00:45:46 <funfunctor> thanks for the note however
00:45:48 <merijn> Everything you write in haskell is mostly copying things :)
00:45:55 <funfunctor> mniip: thanks for the lambda expression
00:46:11 <funfunctor> merijn: hehe
00:46:25 <funfunctor> says anyone who has ever made anything ever :D
00:48:26 <merijn> I think I've asked this before, but I forgot
00:48:35 <merijn> Is the identity morphism unique?
00:48:56 <merijn> Oh, wait, I think I remember this
00:49:27 <merijn> It's unique op to isomorphism and then all the HoTT people go all "we put isomorphisms in your isomorphisms", right?
00:49:43 <tdammers> everything *I* ever write in haskell is a matter of writing random things and then changing them until they compile
00:49:48 <shachaf> No, it's just plain unique.
00:50:00 <shachaf> Same as the identity element in a monoid. And in fact you can show it with the same proof.
00:50:12 <jle`> funfunctor: btw lens is one such solution to finding a "less messy" way
00:50:59 <jle`> you'd do something like `\m -> set foo 2 m"
00:51:05 <jle`> or `set foo 2`
00:51:51 <funfunctor> jle`: \x -> x { foo = .. } does not seem so bad
00:51:54 <jle`> so, modifyIORef (set foo 2)
00:51:55 <merijn> shachaf: So if I have an isomorphism f : A -> B, g : B -> A then f.g must necessarily be id_A?
00:52:08 <merijn> I thought that wasn't necessarily true
00:52:19 <funfunctor> :t modifyIORef
00:52:20 <lambdabot>     Not in scope: ‘modifyIORef’
00:52:20 <lambdabot>     Perhaps you meant one of these:
00:52:20 <lambdabot>       ‘modifySTRef’ (imported from Data.STRef),
00:52:22 <shachaf> Yes, that's what isomorphism means.
00:52:34 <shachaf> (Well, isomorphism also means that g . f is id_B.)
00:53:15 <jle`> funfunctor: it's not too bad :)  the lensy way generalies to nested data structures, but if this is the case you have, then it's a matter of taste.  using `foo` you can also get some other nice things though when working with IORef
00:53:17 <merijn> Oh, wait, maybe I'm thinking of another case
00:53:27 <jle`> modifyIORef (set foo 2)
00:53:31 <jle`> modifyIORef (over foo (*2))
00:53:37 <jle`> ^ that doubles the `foo` field
00:53:43 <merijn> There was some chicanery with homomorphisms in Awodey, but I forgot what exactly
00:54:00 <shachaf> Many things are defined only up to isomorphism.
00:54:21 <shachaf> But isomorphism itself means f.g=id and g.f=id.
00:54:26 <jle`> readIORef (get foo)
00:54:37 <jle`> ^^ that'd read the foo value from your data type
00:54:57 <shachaf> (Which is wometimes isomorphism is too strong a notion.)
00:55:03 <shachaf> why sometime
00:55:09 <jle`> er sorry, get foo <$> readIORef
00:55:21 <jle`>  ( ... ref)
00:55:44 <shachaf> I think bringing lenses (let alone lens) into this is not particularly helpful.
00:56:44 <jle`> from a pedagological standpoint or a practical one?
00:57:08 <shachaf> The former.
00:57:12 <shachaf> Lenses are a great concept but you should know enough about Haskell to be able to do things the ordinary way before using them. :-)
00:58:21 <jle`> fair enough :)
01:00:41 <mrkkrp> What is preferred way to arrange source code in Haskell, top-down or bottom-up?
01:01:31 <merijn> mrkkrp: I tend to move minor convenience functions (1 liners) to the top, then the actual exported/useful code and big internal stuff at the bottom
01:02:04 <merijn> (the 1 liners at the top as a sort of reminder for the shortcuts I introduced)
01:18:29 <Emankcin> May somebody please help me get some code to compile?
01:18:30 <Emankcin> http://lpaste.net/121172
01:18:48 <Emankcin> BTW I am realitively new to Haskell
01:19:11 <Emankcin> Just trying to capture the output of a command into a String/[Char]
01:19:48 <mjrosenb> Emankcin: IO is like the kraken, once you're inside of it, you don't come out.
01:19:55 <Emankcin> whaha
01:20:01 <Emankcin> Oh god
01:20:27 <tdammers> it's sometimes inconvenient, but in the end, the benefits outweigh the hassle
01:20:29 <thebnq> well you can... but its considered dirty :)
01:20:34 <Emankcin> All I wanted to do was wrap pacman ^-^
01:20:48 <tdammers> you can, but you need to drag IO around
01:21:03 <mjrosenb> Emankcin: since readProcess foo bar has type IO String, anything that uses it will be in IO.
01:21:57 <tdammers> IO [String], right?
01:22:17 <tdammers> ah no, just IO String
01:23:24 <Emankcin>  I just fixed it
01:23:25 <mjrosenb> Emankcin: at a pretty high level, this is just fine, since you're probably going to want to do something like print this value (or a transformation of it), and print returns IO (), so you're just going to stay in IO.
01:23:31 <Emankcin> I made it return an IO String
01:23:45 <Emankcin> and then when the function is called I convert it into a String
01:23:50 <Emankcin> It works fine
01:23:57 <Emankcin> Unless there is a better way
01:24:08 <mjrosenb> Emankcin: I suspect you aren't understanding something in there.
01:24:28 <Emankcin> mjrosenb: Quite possibly haha
01:24:53 <mjrosenb> Emankcin: how are you converting IO String to String?
01:25:28 <Emankcin> mjrosenb: I use this "<-"
01:25:33 <Emankcin> For example
01:25:43 <Emankcin> foo <- function.call
01:25:50 <otiose> i am also pretty new to haskell, but im going through the folds/monoids chapter of http://www.seas.upenn.edu/~cis194/spring13/lectures.html and i'm stuck on the homework. http://lpaste.net/7116457528946327552
01:26:39 <mjrosenb> Emankcin: that isn't really a conversion, but it will work.
01:26:53 <tdammers> Emankcin: <- is not a proper operator, it's syntax sugar
01:27:02 <Emankcin> mjrosenb: I read about that
01:27:09 <otiose> My problem is with `indexJ` which is supposed to index into the JoinList like a normal list; It has a `Sized` monoid to tell it what subtree to branch into... The error I am getting is written in the paste
01:27:20 <Emankcin> mjrosenb: Didn't understand it all, but I read about it
01:27:21 <tdammers> foo <- bar; baz foo -- is syntax sugar for bar >>= \foo -> baz foo
01:27:38 <Emankcin> Which was is favoured?
01:27:43 <Emankcin> *which way
01:28:20 <tdammers> depends
01:28:26 <mjrosenb> Emankcin: the do syntax is usually much more coherent.
01:28:28 <mjrosenb> /usually/
01:28:32 <tdammers> indeed
01:28:51 <tdammers> bar >>= \foo -> baz foo -- can be collapsed into bar >>= baz
01:28:59 <Emankcin> Okay
01:29:03 <Emankcin> Thanks guys
01:29:12 <Emankcin> Off to make even more erorrs ;)
01:29:27 <tdammers> bar >>= baz is generally preferred over do { foo <- bar; baz foo }, because it avoids the extra variable
01:29:54 * mjrosenb has been trying to come up with an IO analogy, with giving someone in another room directions
01:29:54 <thebnq> otiose: i suspect you need to give a type to "indexJ 0 Empty"
01:30:03 <mjrosenb> tdammers: variables are cheap.
01:30:15 <otiose> thebnq: i was thinking so too, but must it be necessary?
01:30:33 <tdammers> mjrosenb: sure. but if the only purpose of a variable is to string to functions together, it becomes kind of a lie
01:30:48 <tdammers> point-free style and all that
01:31:01 <tdammers> as long as the extra variable helps clarify things, I'm all for using it
01:31:02 <thebnq> yes because you pass it Empty, it can't figure out what the type `b` is
01:31:06 <otiose> the homeworks say that it should work just like turning it into a list and safe indexing it
01:31:27 <mroman> Couldn't match expected type ‘Data.Text.Internal.Text’ with actual type ‘Text’
01:31:32 <mroman> yeah
01:31:41 <mroman> but Data.Text.Internal does not provide a "pack" function?
01:31:46 <mroman> How do I create an internal Text?
01:32:02 <tdammers> Data.Text.Internal.Text is re-exported as Data.Text.Text
01:32:05 <shachaf> Data.Text.Internal.Text and Data.Text.Text are the same type.
01:32:33 <mroman> ghc says different
01:32:42 <shachaf> Data.Text.Lazy.Text and Data.Text.Lazy.Internal.Text are also the same type.
01:32:45 <otiose> ah, ok using `Empty :: JoinList Size Char` seemed to work
01:32:47 <shachaf> But those are two different types.
01:33:14 <otiose> kind of annoying, but i guess it will do
01:33:40 <tdammers> > let x = Data.Text.empty; y = Data.Text.Internal.empty in x <> y
01:33:42 <lambdabot>  Not in scope: ‘Data.Text.empty’Not in scope: ‘Data.Text.Internal.empty’
01:33:49 <tdammers> vOv
01:34:12 <mroman> ow
01:34:13 <mroman> right
01:34:18 <mroman> this thing uses both lazy and strict
01:34:37 <mroman> alright.
01:35:01 <tdammers> anyway, it works fine in ghci with the right imports in place
01:35:16 <thebnq> otiose: if you tried something like "indexJ 0 (Single (Size 1) 'f')" it probably works because it knows based on the 'f'
01:36:16 <otiose> thebnq: yeah, Single and Append seemed to be working fine
01:36:39 <merijn> mroman: That error almost certainly means: "you're accidentally mixing strict and lazy Text"
01:37:06 <merijn> oh, I'm late to the party
01:37:13 <otiose> and i was confused, because the Empty case pretty much just doesn't care about the types of m and a at all; but i suppose m and b are part of the type of Empty itself
02:18:40 <EvanR> question about JuicyPixels, am i to assume that RGBA images have their channels normalized to that order? i.e. a windows bmp and png will load the same, as straight RGBA data?
02:19:00 <EvanR> no need to worry about ABGR weirdness?
02:26:06 <otiose> thebnq: i updated the paste, with some more info: http://lpaste.net/7116457528946327552
02:26:15 <otiose> oh nevermind
02:26:19 <otiose> i figured it out
02:27:01 <otiose> but since i pinged you: `jlToList Empty` is working out just fine; but i'm guessing its because there is no `Monoid` or `Sized` constraint this time
02:28:50 <thebnq> yay glad i could help :D
02:30:01 <otiose> :D
03:12:30 <akegalj> i have cabal sandbox. Can I somehow run ghc individually (appart of cabal) and tell him to look at .cabal-sandbox for packages?
03:13:11 <dcoutts> akegalj: yes, cabal exec bash
03:13:22 <akegalj> dcoutts: thanks
03:13:24 <dcoutts> or directly, cabal exec ghc
03:13:44 <dcoutts> akegalj: and cabal repl also works, when in a sandbox and not in a dir containing a package
03:14:47 <funfunctor> EvanR: around? :)
03:15:16 <EvanR> maybe
03:17:30 <otiose> how active does this channel get?
03:17:41 <otiose> ive noticed its pretty quiet considering the amount of people there are
03:17:48 <jle`> it depends on the time of day :)
03:18:02 <jle`> most people on the list of users are usually idle too
03:18:33 <jle`> we just leave our clients on while we are out and about
03:18:47 <otiose> yeah that makes sense; where are most people from, or rather, what time are people usually around?
03:19:00 <otiose> i'm in japan, so imagine im on while the rest of the world is asleep
03:20:20 <jle`> from my experience activity seems to coincide with daytime in the states, but things can still get active around europe/australia daytime
03:20:29 <jle`> varies on the day and the topic
03:20:31 <thebnq> http://ircbrowse.net/haskell
03:20:49 <thebnq> hehe theres a little peek right about now on that graph
03:21:13 <akegalj> doctorin1: I am trying to run sumething like "cabal exec ghc -O2 -fforce-recomp -rtsopts -threaded -fspec-constr-count=18 -with-rtsopts="-A4M" VideoFunhouse.hs" but he is complaining about -O2 and other flags
03:21:17 <otiose> oh this is pretty cool. thanks
03:21:50 <akegalj> dcoutts: I am trying to run sumething like "cabal exec ghc -O2 -fforce-recomp -rtsopts -threaded -fspec-constr-count=18 -with-rtsopts="-A4M" VideoFunhouse.hs" but he is complaining about -O2 and other flags
03:22:06 <lpaste> funfunctor pasted “No title” at http://lpaste.net/121174
03:22:20 <dcoutts> akegalj: use -- to separate args to the prog
03:22:29 <funfunctor> EvanR: ^ any advice on my read/writeSamples signatures?
03:23:04 <akegalj> dcoutts: thank you
03:25:42 <EvanR> funfunctor: starting with writeSamples
03:27:29 <mrkkrp> Is it possible to define this function: `f = liftIO . putStrLn . printf' without losing magic of `printf' (variadic args). I don't know what type `f' should have. Also composition won't work here if `printf' takes more than 1 argument, but wrote this definition for demonstration only.
03:27:42 <EvanR> funfunctor: the Int seems unnecessary. the return type seems like it should be a Sum rather than a product
03:35:24 <trds> hi everyone, is there anything like html5canvas in haskell?
03:36:05 <EvanR> trds: theres SDL and OpenGL
03:36:27 <EvanR> and cairo
03:36:57 <EvanR> trds: and apparently this https://hackage.haskell.org/package/blank-canvas
03:37:49 <felixsch> trds: what about diagrams?
03:38:43 * hackagebot haskell-docs 4.2.5 - A program to find and display the docs and type of a name  http://hackage.haskell.org/package/haskell-docs-4.2.5 (ChrisDone)
03:40:04 <EvanR> funfunctor: i dont really understand what the timestamp is doing in readSamples
03:40:36 <funfunctor> EvanR: I guess now comes the part to fully grok http://lpaste.net/121175 and understand how these read/write primitives actually work in detail
03:40:55 <EvanR> joy
03:41:01 <funfunctor> :p
03:41:09 <EvanR> i would have started with that, honestly
03:41:27 <funfunctor> EvanR: I did but now I forgot
03:41:39 <EvanR> well ill be interested to know what you find out ;)
03:41:40 <funfunctor> the finer details
03:46:52 <funfunctor> EvanR: it a IQ QAM constellation plot decision problem algorithm with timestamp adjustment.
03:47:12 <funfunctor> EvanR: also DC offset correction
03:48:21 <EvanR> alphabet soup
03:48:34 <EvanR> i know QAM
03:48:49 <funfunctor> EvanR: yea the code is virtually unreadable
03:49:08 <funfunctor> oh cool! QAM is awesome stuff
04:00:41 <trds> thank you all for suggestions, i'm looking for more pleasant graphics environment (and not gloss :)
04:03:53 <tdammers> graphics is kind of problematic
04:04:22 <tdammers> wrapping existing C libraries with FFI is unsound when the C library isn't thread-safe
04:04:28 <tdammers> or relies on evaluation order
04:04:46 <tdammers> unfortunately, many graphics libraries are exactly like that
04:05:01 <tdammers> common pattern in C is to have some global state and a library initialization function
04:05:09 <tdammers> but that "global" state isn't thread safe
04:05:13 <tdammers> nor reentrant
04:05:23 <SoupE> opengls global state is a nightmare but there is light with direct state access upcomming
04:06:17 <hexagoxel> akegalj: use `cabal exec -- ghc --foo --bar`, i.e. the `--` as seperator is important
04:06:27 <hexagoxel> *separator
04:06:35 <akegalj> hexagoxel: hm, ill try now
04:11:33 <trds> tdammers: should we forget about graphics in haskell?
04:11:46 <KaneTW> for simple 2d stuff, what's the preferred haskell package
04:12:12 <tdammers> trds: no... just saying things are rough ATM
04:16:28 <akegalj> hexagoxel: I ended up configuring .cabal wit extra ghc options. thnx anyway
04:18:14 <hexagoxel> akegalj: yes, cabal passes more than the package repositories and the --ghc-options flags to ghc (e.g. include directories and extensions to use). the manual (i.e. cabal exec) path is somewhat cumbersome.
04:18:57 <hexagoxel> an alternative to modifying .cabal is specifying --ghc-options when configuring, i think.
04:22:01 <trds> i would like to sponsor open source project that provide decent and pleasant graphics environment for beginers and experts as well, anyone interested?
04:24:17 <clrnd> Blender 3D is ruled out then, I guess
04:25:08 <tzaeru> clrnd, :D
04:25:38 <tzaeru> I can't get over from how accurate a throw that was.
04:25:47 <akegalj> hexagoxel: might be, I'm still new to cabaling things
04:27:05 <trds> clrnd: we are talking about html5canvas like
04:30:30 <trds> dont you like to have something similar in haskell?
04:31:21 <tdammers> haskell doesn't run in the browser as-is, so what would "similar" even mean?
04:32:00 <tdammers> there's libcairo, which works reasonably well in Haskell
04:32:20 <tdammers> but it covers only graphics rendering, no user input or animation
04:37:50 <trds> cairo is fine, can we have one simple example that work for anyone?no
04:38:42 <tdammers> trds: fwiw, https://bitbucket.org/tdammers/notator
04:38:48 <tdammers> my first "real" haskell project
04:39:01 <tdammers> cairo is pretty central to what it does
04:39:06 <tdammers> (rendering sheet music, that is)
04:39:24 <felixsch> trds: how about contribute to diagrams? It sounds like what you want?
04:39:25 <ajaymenon> hello
04:41:32 <trds> tdammers: i'm PC, sorry :)
04:45:20 <mrkkrp> What do you think about putting all constants in one file? Does anyone do this sort of things?
04:46:31 <arw_> yes, i've seen that, so one can make a script that complains bitterly if someone tries to change the value of pi or the mass of an electron.
04:47:08 <arw_> (but that was more in jest than the real reason)
04:48:23 <tdammers> mrkkrp: no
04:48:26 <arw_> i've worked with some physics code and its handy to have all the useful constants for everything in a file, so you can just get someone to copy the particle data booklet and be done with it.
04:48:27 <tdammers> I don't
04:48:51 <tdammers> I put constants where they belong, semantically
04:49:03 <mrkkrp> Well, I have various default values and names of configuration files spread among different files, so I think it's better to collect them in one place
04:49:17 <tdammers> a constant that is closely related to foobar functionality belongs in module Acme.Foobar
04:49:20 <arw_> but for the usual computer science "constants" like "maxNumberOfUsers", i'd go with tdammers
04:49:46 <mrkkrp> *spreaded
04:49:46 <tdammers> I do have a type called "Configuration" though
04:50:14 <tdammers> but it's just a record type combining several more specific sub-configurations
04:50:37 <tdammers> and the only reason I have that type is because I want to read a configuration file at startup and dispatch things to the relevant modules from there
04:51:02 <tdammers> but configuration files aren't constants
04:51:12 <tdammers> they're state
04:51:31 <EvanR> or are they variables?
04:51:39 <tdammers> state variables
04:51:42 <EvanR> lol
04:51:43 <tdammers> but they don't vary
04:51:45 * tdammers ducks
04:51:48 <mrkkrp> I read configuration file too, but if something is not set in it, I use default values. There are quite a bit of them.
04:52:00 <tdammers> mrkkrp: implement Data.Default for them
04:52:15 <EvanR> or have a shadow default config full of the default values constants
04:52:26 <EvanR> now both are configurable
04:52:49 <EvanR> dont allow stuff missing from the default config, or else youll need a teritary config
04:53:01 <mrkkrp> tdammers, EvanR: thank you for the suggestions
04:53:02 <EvanR> or an infinite hierarchy
04:53:28 <arw_> you need a hierarchy of overridable configs at some point, at least for a lot of projects.
04:53:57 <arw_> but yes, you should start with a sensible and complete default
05:03:30 <mrkkrp> Yay! I've spent 2 days on refactoring of one my Haskell program (without running it), and now I run it and it just works. I've improved some parts and they seem to work just I like I wanted. This is amazing.
05:05:05 <clrnd> hurray
05:08:48 * hackagebot wai-middleware-static-caching 0.6.0.1 - WAI middleware that serves requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-caching-0.6.0.1 (AlexanderThiemann)
05:13:07 <clrnd> hey I wanna try lambdabot, I'm firing up a trusy64 vm for it
05:13:27 <utdemir> !lambdabot hi
05:13:46 <clrnd> the README says 'but currently the lambdabot binary makes certain assumptions about what directory it is being run in & where files it needs can be found'
05:13:50 <utdemir> i guess this is not how it works...
05:14:05 <clrnd> and the question is, what are those assumptions?
05:14:43 <dfeuer> I'm thinking about putting together a package with Data.Maybe.Unsafe(unsafeFromJust) and Data.List.Unsafe(unsafeHead,unsafeTail,unsafeListToStream). This clearly belongs in the "acme" package hierarchy, but what should I call it?
05:14:46 <alpounet> @botsnack
05:14:46 <lambdabot> :)
05:15:06 <alpounet> oh, it's been removed
05:15:31 <dfeuer> What has, alpounet?
05:16:04 <alpounet> nevermind, i have a crappy connection so lambdabot's :) took quite a while to reach me
05:16:41 <dfeuer> Ahhhhh.
05:19:22 <clrnd> @help installation
05:19:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:20:54 <dfeuer> In fact, I should probably also learn how to use Template Haskell (and generics?) so I can write fully general unsafe extraction functions.
05:21:12 <mauke\> it's called unsafeCoerce
05:21:23 <dfeuer> mauke\, it uses unsafeCoerce under the hood.
05:21:39 <dfeuer> But you need to set some things up for each type.
05:23:22 <dfeuer> mauke\, it's not hard to set up for each type; I just think it would be fun to write an acme package to automate it.
05:26:23 <nshepperd> acme-unsafeprelude?
05:26:56 <dfeuer> nshepperd, not bad at all.
05:29:53 <EvanR> it is not clear to me why when i install my package which depends on a valid and installed version of gl... it proceeds to reinstall different (older versions) of all of gl's dependencies
05:29:56 <nshepperd> you could also provide an Acme.Unsafe.Prelude that just re-exports most of the prelude :)
05:29:59 <EvanR> and not touch gl
05:30:05 * mjrosenb read that as acme-unsafeplunder
05:30:28 <EvanR> does this indicate my packages are messed up, or what
05:30:56 <c_wraith> I thought https://hackage.haskell.org/package/acme-php was the unsafe prelude.
05:31:12 <tdammers> c_wraith: no, that's the insane prelude
05:31:41 <tdammers> nshepperd: how about an unsafe prelude that redefines everything into IO?
05:32:05 <EvanR> or doesnt, but reimplements everything with unsafePerformIO
05:32:07 <tdammers> Acme.Unsafe.Prelude.++ :: [a] -> [a] -> IO [a]
05:32:18 <mauke\> rplacd time!
05:32:19 <tdammers> EvanR: even better
05:33:27 <EvanR> congratz cabal, you reinstalled the already installed duplicates of all contravariant, distributive, comonad, semigroupoid, bifunctor, profunctor, free, adjuctions, lens, and linear
05:33:29 <mauke\> http://www.lispworks.com/documentation/lw60/CLHS/Body/f_rplaca.htm
05:34:54 <mjrosenb> EvanR: I bet it feels very proud of itself!
05:35:46 <nshepperd> the joke is that the prelude is already unsafe though
05:36:37 <nshepperd> well, "unsafe". pure functions from the prelude don't launchMissiles yet
05:36:49 <tdammers> plenty of partial functions though
05:37:10 <mjrosenb> aren't most functions partial?
05:37:21 <int-e> I really dislike people calling partial functions unsafe.
05:37:51 <EvanR> do i really need two minor versions of transformers-compat...
05:37:58 <EvanR> cabal claims that i do
05:38:05 <int-e> dfeuer: And btw, I think your *unsafe* fromJust was a bit too subtle.
05:38:07 <tdammers> mjrosenb: one could argue that all functions are total...
05:38:20 <mauke\> safeCoerce :: a -> b; safeCoerce x = seq x undefined
05:38:34 <dfeuer> int-e, too subtle how?
05:38:35 <tdammers> ...there's just a discrepancy between the declared type and the actual type :P
05:39:25 <int-e> dfeuer: I'm not sure it's all that obvious that it was a joke. (Unless it wasn't, in which case I'll pretend I never knew you.)
05:39:42 <dfeuer> nshepperd, I mean like this: http://lpaste.net/121151
05:39:42 <clrnd> mmm can I use stackage outside a sandbox?
05:40:18 <dfeuer> int-e, everything in the acme hierarchy is a joke on some level.
05:40:56 <int-e> dfeuer: Ah is that where the code is from? Your mail didn't say that.
05:41:07 <merijn> mjrosenb: What makes you say most functions are partial?
05:41:09 <dfeuer> int-e, I wrote that.
05:41:18 <nshepperd> dfeuer: ha
05:42:21 <EvanR> i just noticed i have something called witherable installed. is this the long long "filter" class everyone wants? or does it not satisfy enough laws to be interesting
05:42:30 <EvanR> long lost*
05:42:43 <dfeuer> No idea.
05:43:15 <EvanR> oh its part of fumieval's domain
05:43:28 <mjrosenb> merijn: I guess I was thinking functions on lists, where other than things like map, being given an infinite list is a bad time for getting any value out of it.
05:44:00 <nshepperd> in a purely technical sense, partial functions aren't functions. in a slightly less technical sense, every total function f : D -> R has 2^|D| - 1 partial "sub"functions
05:44:03 <merijn> mjrosenb: map on infinite list isn't partial
05:44:27 <merijn> > map (+1) [1..] !! 20 -- I don't see the problem?
05:44:29 <lambdabot>  22
05:44:57 <mjrosenb> merijn: "other than things like map"
05:44:59 <dfeuer> int-e, I actually was thinking about one of these unsafe operations out of frustration when working on some implementation of scanr or scanl.
05:45:00 <EvanR> infinite lists were added to the codomain
05:45:15 <merijn> mjrosenb: Name one other than foldl/(m)sum
05:45:26 <mjrosenb> merijn: last
05:45:37 <dfeuer> last is left fold.
05:45:45 <benzrf> mjrosenb: :D
05:45:55 <benzrf> dfeuer: oh damn
05:46:13 <mjrosenb> by that argument, all list functions are foldl or foldr.
05:46:17 <dfeuer> last = foldl (flip const)
05:46:20 <dfeuer> er. ..
05:46:31 <merijn> All list functions are foldr :p
05:46:35 <dfeuer> last = foldl (flip const) (error "Empty list")
05:46:41 <dfeuer> Not all.
05:46:45 <merijn> Actually, all primitve recursive functions are foldr :p
05:47:16 <nshepperd> last, sum, and, or, find
05:48:24 <dfeuer> I guess you could write sort as a fold....
05:48:25 <merijn> :t and
05:48:26 <lambdabot> [Bool] -> Bool
05:48:29 <nshepperd> ==
05:48:45 <merijn> > and (cycle [True, False])
05:48:46 <lambdabot>  False
05:49:09 <nshepperd> > and (repeat True)
05:49:42 <nshepperd> oh dear
05:49:47 <dfeuer> > "What, no timeout?"
05:49:49 <lambdabot>  "What, no timeout?"
05:49:54 <Clint> mueval was insulted
05:51:19 <mjrosenb> right, so foldl and foldr can both be partial, depending on what they are given.
05:51:53 <tdammers> anything involving recursive data structures can be partial
05:52:01 <tdammers> (or so I assume)
05:54:21 <mroman> /usr/bin/ld: cannot find -lHSbase16-bytestring-0.1.1.6-ghc7.8.3
05:54:23 <mroman> damn
05:54:26 <mroman> this looks bad
05:56:38 <mroman> oh
05:56:47 <mroman> --reinstall --force-reinstalls of base16-bytestring worke
05:56:59 <merijn> o.O
05:57:24 <merijn> I don't understand why everyone is so trigger happy with --force-reinstalls >.>
05:57:31 <mauke\> star wars
05:58:49 <mjrosenb> merijn: because it is the closest that cabal-install comes to being a competent package manager?
05:58:50 <bergmark> we always do --force-reinstalls in our cabal wrapper, it's just annoying to get a "failure" when there is an install plan
06:01:23 <merijn> But force reinstalls has the potential to break a billion more things...
06:02:15 <merijn> No wonder so many people have such brittle haskell environments...
06:03:53 <mjrosenb> merijn: what do you recommend doing instead?
06:04:07 <mjrosenb> (fwiw, I try to avoid cabal-install like the plague)
06:07:16 <merijn> mjrosenb: sandbox and/or "ghc-pkg unregister" conflicting package and reinstall them by cabal installing your initial target
06:07:37 <merijn> That will explicitly tell you which libraries depend on it (and will thus be broken unless you unregister/reinstall them)
06:08:54 <int-e> > and (repeat True) -- hmm, I guess *some* reply is better than none at all
06:08:59 <lambdabot>  mueval: ExitFailure 1
06:09:42 <int-e> > sum [1..]
06:09:46 <lambdabot>  mueval-core: Time limit exceeded
06:13:31 <utdemir> > undefined
06:13:33 <lambdabot>  *Exception: Prelude.undefined
06:14:11 <mniip> is there someplace where I can read about Traversable?
06:14:37 <utdemir> mniip: Typeclassopedia?
06:14:43 <utdemir> > readFile "/etc/hosts"
06:14:44 <clrnd> mniip, the original paper?
06:14:45 <lambdabot>  <IO [Char]>
06:14:59 <clrnd> @google essence iterator pattern
06:15:01 <lambdabot> http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
06:15:01 <lambdabot> Title: The Essence of the Iterator Pattern
06:15:24 <mniip> heh that is probably too much
06:26:07 <Darwin226> Hey, could someone provide a bit of clarification regarding some elementary category theory stuff?
06:27:52 <Darwin226> So a functor goes from one category to another, and in haskell all of them are endofunctors, right?
06:28:55 <Darwin226> so if I have an arrow a -> b, a functor f maps that to f a -> f b. Now this makes sense to me from that math perspective. But how does it make sense in haskell?
06:29:12 <ski> Darwin226 : "in haskell all of them are endofunctors, right?" -- no
06:29:24 <ski> every instance of `Functor' is an endofunctor
06:29:42 <ski> (specifically an endofunctor on `*', or on `Hask', if you prefer to state it that way)
06:29:58 <Darwin226> ski: Ok, I don't think that changes my question
06:30:04 <Darwin226> so
06:30:12 <ski> you can have a functor `F', without having to make it an instance of `Functor. mathematically speaking, it's still a functor
06:30:17 <clrnd> :t fmap
06:30:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:30:49 <Darwin226> I'm having issues with the idea that f as a type constructor maps from one type to another
06:30:50 <ski> you could have a `T :: (* -> *) -> (* -> *)' that is a functor. or a `D :: (* -> *) -> *' that is a functor
06:31:01 <Darwin226> I mean, sure it maps from a to f a, but f a isn't really any type
06:31:07 <Darwin226> It's wrapped in an f
06:31:13 <ski> or of course `F2 :: * -> * -> *'
06:31:56 <ski> you'd need different type classes to collect such functors (well, perhaps not with polymorphic type classes, like the newest `Typeable' also works on types of other kinds than `*')
06:32:31 <ski> Darwin226 : hm
06:32:36 <clrnd> Darwin226, I'd say Maybe Int is a type, not an Int wrapped
06:32:53 <ski> Darwin226 : `f :: * -> *' here. it is a type function, mapping concrete types to concrete types
06:33:10 <Darwin226> clrnd: Yeah, but the math. definition seems to imply that a functor can pretty much be any mapping.
06:33:10 <ski> it just so happens that it always maps concrete types to concrete types of a particular form
06:33:18 <ski> (in the case of `Maybe')
06:33:35 <Darwin226> ski: Isn't that more restrictive than it should be?
06:34:01 <realteh_> I'm hostly not trying to troll but does anyone feel like typing <|>, <$> and <*> is not fun?
06:34:17 <realteh_> do people have emacs shortcuts for those or something?
06:34:18 <ski> Darwin226 : well, conceptually, `f' could be any type function. it's another matter that (at least without type and data families) the type functions we actually can express are a bit limited
06:34:20 <clrnd> realteh_, not me, but check out idiom brackets
06:34:36 <realteh_> clrnd, thanks (*googles*)
06:35:02 * geekosaur still often writes them the old way because they're a bit fugly. ("hard to type" just means make your editor do it for you...)
06:35:06 <Darwin226> ski: Yeah. Type families could express that idea better I think.
06:35:41 <ski> Darwin226 : if we had product kinds, that could perhaps also make the situation more interesting ..
06:37:31 <Darwin226> ski: I've now spent around half a year tinkering with some of the more advanced topics of haskell (well... I say advanced...) and it still blows my mind how often it happens that someone just casually says something along the lines of "if we had product kinds..."
06:37:45 <Darwin226> ski: and I've never heard of product kinds before :D
06:37:53 <ski> Darwin226 : here's maybe a somewhat similar situation : in constructive math, the only endofunctions on the real numbers you actually can construct are continuous ones (but not necessarily differentiable). however, you can't prove that every endo on reals is continuous (without extra anti-classical axioms which formalize the intuition that we only seem to be able to compute continuous stuff)
06:38:29 <ski> Darwin226 : well, you know what product types are, right ?
06:38:37 <Darwin226> ski:  yeah
06:38:46 <lachenmayer> hi, I'm trying to install a dependency in a cabal sandbox that I have manually added using `cabal sandbox add-source`. When I do `cabal install --only-dependencies`, the package gets installed fine. It is only an executable, not a library, so the binary ends up in .cabal-sandbox/bin as expected. When I try to `cabal build`, it tells me that "At least the following dependencies are missing", even though it is installed.
06:38:49 <tdammers> Darwin226: https://cokmett.github.io/cokmett/
06:39:09 <lachenmayer> I've completely rebuilt the sandbox etc, it's entirely clean. Any ideas?
06:39:32 <Darwin226> tdammers: hahaha
06:39:39 <fractalsea> Is it possible to change the order of a monad transformer stack, i.e. in my case I want a function :: ReaderT Env (EitherT String IO) a -> EitherT String (ReaderT Env IO) a
06:40:55 <Darwin226> fractalsea: Not always. But that's all I know
06:41:02 <Darwin226> fractalsea: Some of them don't commute
06:41:52 <fractalsea> Darwin226: OK, so I have to write a specific function myself?
06:42:35 <ski> Darwin226 : so, take a bifunctor ⌜f ∷ ★ → ★ → ★⌝. if we want to express this categorically, we really intend an uncurried ⌜f′ ∷ ★ × ★ ⟶ ★⌝, where ⌜★ × ★⌝ is the kind of pairs of concrete types
06:43:19 <ski> Darwin226 : so, this is intended as a functor from the category ⌜★ × ★⌝ to the category ⌜★⌝ (or from ⌜Hask × Hask⌝ to ⌜Hask⌝, using alternate notation)
06:43:57 <clrnd> WTH: Warning: Unable to strip executable or library
06:43:58 <clrnd> 'setup-Simple-Cabal-1.18.1.5-x86_64-linux-ghc-7.8' (missing the 'strip'
06:43:58 <clrnd> program)
06:44:25 <ski> Darwin226 : we can express basically the same functor in the curried fashion in Haskell, without product kinds. but we can't then fit it into a generic (iow polymorphic) type class that would work for any domain and codomain categories for our functor
06:45:39 <ski> Darwin226 : also, we can't express ⌜g ∷ ★ ⟶ ★ × ★⌝ directly in Haskell, we have to use the components ⌜g₀ ∷ ★ ⟶ ★⌝ and ⌜g₁ ∷ ★ ⟶ ★⌝
06:45:43 <hexagoxel> lachenmayer: short answer is "currently dependencies work only with libraries" see https://github.com/mietek/haskell-on-heroku/issues/4 https://github.com/haskell/cabal/issues/220 https://github.com/haskell/cabal/issues/779
06:45:45 <ski> Darwin226 : makes any sense ?
06:45:54 <Darwin226> ski: About 70%
06:46:20 <Darwin226> ski: Which is above passing grade :D
06:46:59 <ski> Darwin226 : questions ?
06:48:19 <mniip> What's the point in Arrow/ArrowChoice/ArrowApply if the only instance is (->) and (Kleisli m)
06:49:48 <lachenmayer> hexagoxel: thanks a lot! i've been searching aimlessly for hours... :) do you have any experience with halcyon/would you recommend using it in this case?
06:50:37 <Darwin226> ski: hmm... not really. I'm just lacking some general understanding. Thanks for the info
06:50:40 <ski> mniip : "only instance" isn't the same as "only standard instance"
06:50:44 <tdammers> mniip: open instances? can always write your own
06:50:47 <Darwin226> ski: Though, I have one related to my original point
06:51:46 <Darwin226> ski: So, since type functions using families could express the idea of a functor better than the current approach, are there no benefits that would make it worth it to switcH?
06:52:41 <ski> Darwin226 : switch from what to what ?
06:53:33 <Darwin226> ski: From the notion of a functor as described by the typeclass to the notion of a functor as descibed as a type family
06:53:40 <Darwin226> ski: If that makes any sense at all
06:54:23 <Darwin226> ski: Maybe "with a type family" instead of "as a type family"
06:55:26 <jophish> Do any scarse resource handling packages exist based on indexed monads?
06:55:36 <ski> Darwin226 : afaiui, that doesn't make sense
06:56:38 <ski> Darwin226 : as i was considering it above. we've either want to use a type class or not use a type class. then, independently, we'd like to allow using type/data families to generate type functions, or not allow it
06:58:11 <Darwin226> ski: So, we could do both?
07:00:19 <ski> but, iirc, if we're using type families, then we aren't allowed to make them instances of type classes
07:00:39 <ski> (similarly to how we can't make type synonyms instances of type classes)
07:01:23 <ski> (however, we can do it for data families)
07:01:29 <ski> <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-families.html#ty-fams-in-instances>
07:02:26 <angerman> what's the go-to library for regex? (which is also in stackage?)
07:02:33 <angerman> regex-compat-tdfa, is not.
07:03:00 <Clint> there is no go-to library for regex
07:03:09 <tdammers> regex is not a go-to thing in haskell :x
07:03:27 <ski> Darwin226 : type/data families increase the ways we can construct type functions in. ideally, we'd still want to use the same type classes as before. however, due to <details> we can't always make instances of a type function (which was already true before type/data families)
07:03:40 <ski> Darwin226 : makes any sense ?
07:04:35 <Darwin226> ski: Yeah. It does
07:05:20 <mietek> lachenmayer: hi!
07:05:49 <mietek> lachenmayer: if you’re interested in Halcyon, join us in #haskell-deployment
07:07:13 <angerman> Clint, tdammers: ok, so what the usual appraoch then?
07:07:31 <tdammers> angerman: parsec/attoparsec, I would say
07:08:01 <tdammers> writing a proper parser is pretty comfortable in haskell
07:08:15 <tdammers> comfortable enough to not embark on the pain that lies down the regex road
07:15:41 <angerman> tdammers: well, i use it only to do some nomralization sets of user intput, e.g. drop excessive spaces etc. And I'd like to keep it user confgurable.
07:16:09 <angerman> Not sure how I'd write a user configurable parsec solution.
07:21:56 <utdemir> Hey. Is `Monad m => (a -> m b) -> m (a -> b)` makes sense? Is it possible?
07:22:14 <mauke\> not possible
07:22:33 <mauke\> at least not in any usable form
07:22:43 <mauke\> consider (a -> Maybe b) -> Maybe (a -> b)
07:22:46 <mauke\> how would you write that?
07:23:23 <utdemir> mauke\: You are right. It isn't meaningful. Thanks.
07:23:59 <mauke\> on the other hand, if it existed, it would solve the problem someone else had a while ago :-)
07:24:09 <mauke\> they wanted a -> IORef a
07:24:32 <mauke\> magicFunction newIORef :: IO (a -> IORef a) :-)
07:24:49 <exio4> couldn't you break purity that way?
07:24:52 <mauke\> yep
07:25:13 <exio4> x <- magic (const () getLine); f (x ()) (x ())
07:25:15 <mniip> is it just me or does 'traverse f = sequenceA . fmap f'
07:26:20 <mniip> ah
07:26:31 <mniip> that's pretty much the default definition of traversa
07:26:35 <mniip> traverse
07:27:17 <ski> yes
07:27:33 <ski> @src mapM
07:27:33 <lambdabot> mapM f as = sequence (map f as)
07:27:35 <ski> same thing
07:27:54 <utdemir> So, if I have `f :: a -> (b -> d) -> e` and `b -> m d`, I can't have something like `m e`?
07:28:11 <mniip> is traverse supposed to be a generalization of mapM?
07:28:31 <ski> yes
07:28:56 <ski> `mapM'/`traverse' might be more efficient than `sequence'&`map' / `sequenceA'&`fmap', in that the former avoids the intermediate data structure, while the latter would need to use fusion or something to avoid it
07:29:06 <mniip> :t mapM
07:29:08 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
07:29:08 <ski> @type traverse
07:29:10 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:29:21 <mniip> hmm
07:29:25 <ski> lists are generalized to arbitrary traversable functors
07:29:40 <mniip> yeah that I can see
07:29:42 <ski> @type Data.Traversable.mapM
07:29:43 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
07:29:50 <ski> is the direct generalization
07:29:56 <mauke\> utdemir: where are you going to get a/b from?
07:29:58 <mniip> t is zonked with []
07:30:10 <ski> `traverse' also generalizes from `Monad' to `Applicative', since we don't really need the extra power of `Monad' here
07:30:19 <KaneTW> > traverse print [1..10]
07:30:21 <lambdabot>  <IO [()]>
07:30:50 <KaneTW> >mapM print [1..10]
07:30:53 <ski> (if `Monad' had been a subclass of `Applicative' from the start, then we'd probably never introduced a version specifically for monads)
07:31:04 <KaneTW> > mapM print [1..10]
07:31:05 <lambdabot>  <IO [()]>
07:31:22 <mniip> KaneTW: [1..10] implies t ~ []
07:31:24 <hodapp> ski: I'm imagining you sitting on a porch with a cane saying that really grumpily to some kid on your lawn - is that okay?
07:31:28 <mniip> so there's no difference
07:31:29 <ski> KaneTW : probably you want `mapM_' with `print'
07:31:34 <KaneTW> yeah
07:31:35 <utdemir> mak`: Think them as concrete types. I have a data constructor taking two values and a function `a -> b`, but I have `a -> m b` as a function, and I want to apply that to constructor. Probably it isn't possible.
07:31:38 <ski> hodapp : sure :)
07:31:39 <KaneTW> > mapM_ print [1..10]
07:31:41 <lambdabot>  <IO ()>
07:31:48 <taruti> http://www.taloussanomat.fi/kotimaa/2015/02/25/voiko-tokmanni-tehda-nain-yliopisto-selvittaa/20152449/12 hah
07:31:58 <KaneTW> lamdabot probably doesn't execute > code in the IO monad
07:32:00 <utdemir> s/mak`/mauke\
07:32:04 <tdammers> angerman: me neither :D
07:32:09 <ski> @help run
07:32:10 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
07:32:16 <phaazon> KaneTW: it can
07:32:16 <ski> KaneTW : right
07:32:23 <phaazon> with something like PureIO
07:32:34 <mniip> I should try making a haskell sandbox that isn't afraid of nothing
07:32:39 <utdemir> :t mapM
07:32:40 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
07:32:46 <utdemir> :t performUnsafeIO
07:32:47 <lambdabot> Not in scope: ‘performUnsafeIO’
07:33:03 <mniip> last time I tried I got stuck on ghci requiring an OS thread for input
07:33:06 <phaazon> :t unsafePerformIO
07:33:07 <lambdabot> Not in scope: ‘unsafePerformIO’
07:33:10 <exio4> you don't have unsafePerformIO nor unsafeCoerce
07:33:58 * hackagebot smoothie 0.1.0.1 - Smooth curves via several splines and polynomials.  http://hackage.haskell.org/package/smoothie-0.1.0.1 (DimitriSabadie)
07:35:05 <mniip> so uh
07:35:18 <mniip> what magic tricks can I do with Traversable
07:35:32 <Clint> traversing
07:35:44 <mniip> [] is the most magical standard type, and sequence can already do that
07:35:45 <phaazon> yeah basically traversing… :D
07:36:08 <dulla> there's not much you can do with traversing, mniip
07:36:12 <mniip> sad
07:36:18 <srhb> mniip: The point is that traverse is polymorphic, after all :)
07:36:26 <phaazon> > traverse (\i | i < 10 -> Just 3 | otherwise -> Nothing) [1..9]
07:36:28 <lambdabot>  <hint>:1:14: parse error on input ‘|’
07:36:39 <phaazon> oh, yeah.
07:36:48 <mniip> ifthenelse
07:36:54 <phaazon> > traverse (\i | if i < 10 then Just 3 else Nothing) [1..9]
07:36:54 <dulla> More or less, it's if you want to scan an entire structure
07:36:55 <lambdabot>  <hint>:1:14: parse error on input ‘|’
07:37:01 <dulla> Or edit an entire structure
07:37:04 <KaneTW> > traverse (\i -> if i < 10 then Just 3 else Nothing) [1..9]
07:37:05 <lambdabot>  Just [3,3,3,3,3,3,3,3,3]
07:37:06 <phaazon> > traverse (\i -> if i < 10 then Just 3 else Nothing) [1..9]
07:37:07 <lambdabot>  Just [3,3,3,3,3,3,3,3,3]
07:37:15 <phaazon> > traverse (\i -> if i < 10 then Just 3 else Nothing) [1..20]
07:37:17 <lambdabot>  Nothing
07:37:18 <mniip> nice
07:37:21 <mniip> Just [3,3,3,3]
07:37:24 <mniip> so magical
07:37:42 <mniip> yet again
07:37:47 <mniip> [1..20] so it's just mapM
07:37:48 <KaneTW> > traverse (\i -> if i < 10 then Just 3 else Nothing) (Just 5)
07:37:49 <lambdabot>  Just (Just 3)
07:37:55 <KaneTW> nice
07:37:56 <dulla> anyways, there's the derivative of a traverse, the zipper :^)
07:38:09 <phaazon> mniip: you can implement Traversable for [] with mapM, yeah
07:38:10 <phaazon> and guess what
07:38:16 <phaazon> traverse_ is implemented with mapM_
07:38:52 <phaazon>  > traverse (\i -> if i < 10 then Just 3 else Nothing) (Just 11)
07:39:00 <mniip> > [1..5] >>= "hello"
07:39:01 <phaazon> > traverse (\i -> if i < 10 then Just 3 else Nothing) (Just 11)
07:39:02 <lambdabot>  Couldn't match expected type ‘a0 -> [b]’
07:39:02 <lambdabot>              with actual type ‘[GHC.Types.Char]’
07:39:02 <lambdabot>  can't find file: L.hs
07:39:07 <mniip> oop
07:39:09 <mniip> > [1..5] >> "hello"
07:39:11 <lambdabot>  "hellohellohellohellohello"
07:39:21 <ski> dulla : in which sense is it the derivative of a traverse ?
07:40:43 <dulla> it's smarter
07:41:07 <dulla> read this from oleg's papers
07:41:26 <dulla> but more or less you can control how it steps through a recursive data structure
07:41:51 <dulla> and it can edit the structure a bit more intimately, like movingbranches
07:41:59 <ski> i know zippers are related to derivatives (the zipper is more or less a list of derivatives of the layers of the original data structure)
07:42:09 <dulla> not really
07:42:31 <dulla> again, reading oleg's papers, zippers are not a derivative of the structure itself
07:42:37 <dulla> just the traverse
07:42:49 <dulla> and then it becomes type irrespective, and a lot cooler
07:43:45 <cschneid> Is there a package for doing time ranges? Start -> Stop, inclusive & not. Then checking if any given time is in that range, etc.?
07:44:38 <tdammers> cschneid: more likely would be a general-purpose range library, which you could then just use on various date/time types
07:44:47 <cschneid> tdammers: valid. Do you know one of those? :)
07:45:07 <c_wraith> @hackage range
07:45:07 <lambdabot> http://hackage.haskell.org/package/range
07:45:26 <tdammers> who'd have thunk
07:45:28 <tdammers> :D
07:45:32 <cschneid> heh.
07:45:33 <cschneid> thanks
07:46:29 <cschneid> actually - this came up at work yesterday - is there a standard way to sort ranges? Math-wise?  I figure its a partial ordering?
07:46:31 <tdammers> @hackage interval
07:46:31 <lambdabot> http://hackage.haskell.org/package/interval
07:46:41 <tdammers> could also work
07:46:50 <ski> dulla : yes, i know "zippers are not a derivative of the structure itself"
07:47:44 <cschneid> hackage link for interval failed. but the ekmett lib is focused on numeric ranges afaik
07:47:56 <tdammers> true
07:48:22 <mauke\> @hackage foo~bar~baz
07:48:22 <lambdabot> http://hackage.haskell.org/package/foo~bar~baz
07:48:49 <tdammers> cschneid: it would still be able to do a lot of things with Ord alone
07:49:17 <cschneid> sure. I'm actually a little disappointed in the range thing, since it doesn't have simple accessors like: "what's the start point of this range"
07:49:21 <cschneid> at least not in the docs
07:49:24 <arw_> i'm having a hard time remembering: what is the thingy called that is commonly described by "like a toy railroad you can compose"
07:49:28 <tdammers> the kmett one does
07:49:49 <tdammers> intervals, btw, not interval :P
07:50:32 <c_wraith> arw_: the only time I saw that, it was a metaphor for monadic composition.
07:50:37 <cschneid> ah sure, I could make a Interval UTCTime, and then just rely on only the Ord based functions, and ignore the Num ones, since they don't make sense anyway
07:52:03 <arw_> c_wraith: got it, thanks. it was arrows: https://wiki.haskell.org/Arrow_tutorial
07:52:20 <arw_> although i can't find the railroad example i was thinking about
07:52:47 <juanpaucar> Hey is there something to make this "1 2 3" to [1, 2, 3] i have to use a bunch of functions and doesn't look good
07:52:57 <tdammers> > words "1 2 3"
07:52:58 <lambdabot>  ["1","2","3"]
07:53:08 <mauke\> > map read (words "1 2 3")
07:53:09 <lambdabot>  [*Exception: Prelude.read: no parse
07:53:13 <mauke\> > map read (words "1 2 3") :: [Integer]
07:53:14 <lambdabot>  [1,2,3]
07:53:19 <tdammers> ^ that
07:53:38 <tdammers> > map read . words $ "1 2 3" :: [Integer] -- is what I'd write
07:53:39 <lambdabot>  [1,2,3]
07:53:40 <k0ral> hello, it looks like the dyre recompilation feature doesn't play well with cabal sandboxes, at least not with the default configuration that I've tested; it spawns a ghc that is unaware of the sandbox; how would you fix that ?
07:53:42 <tdammers> same thing though
07:54:11 <c_wraith> k0ral: can you configure the command used to execute ghc?
07:54:18 <juanpaucar> mauke\: thanks man
07:54:26 <c_wraith> k0ral: if so, you want it to be something like "cabal exec ghc" instead of "ghc"
07:54:28 <juanpaucar> i feel kind of dull
07:54:29 <k0ral> c_wraith: I can choose the options for ghc
07:54:30 <juanpaucar> hehe
07:55:31 <k0ral> c_wraith: I may need to change dyre's code for that; only GHC options are configurable as far as I know
07:56:22 <c_wraith> k0ral: it should really use that whenever there's a cabal file present, sandbox or not
07:56:26 <k0ral> it looks like this:  ghcProc <- runProcess "ghc" ghcOpts (Just cacheDir) ...
07:56:58 <k0ral> I'll open an issue on dyre's github
07:57:07 <k0ral> thanks for the help
08:02:22 <k0ral> c_wraith: in this case, the cabal file isn't located in the same directory as the source, so this may be tricky to automatically detect
08:02:36 <nkar> has anyone tried running ghc on a novena?
08:03:02 <c_wraith> k0ral: dyre really needs to be able to at least support configuring all that, though.
08:03:14 <c_wraith> Even if it can't autodetect it.
08:03:59 * hackagebot soxlib 0.0.1.2 - Write, read, convert audio signals using libsox  http://hackage.haskell.org/package/soxlib-0.0.1.2 (HenningThielemann)
08:08:05 <xplat> what's broken if i try to install newtype and i get '/usr/bin/ld: --hash-size=31: unknown option'
08:08:08 <xplat> ?
08:08:56 <Clint> xplat: are you using gold?
08:10:08 <xplat> Clint: yes
08:10:30 <Clint> xplat: then the answer is "gold"
08:10:50 <xplat> Clint: i was hoping for a more specific answer?
08:11:32 <Clint> like "something is expecting a real linker and not a broken toy"?
08:17:02 <int-e> Clint: hmm, does 'gcc -Wl,--version' print a line that starts with "GNU ld"?
08:17:46 <xplat> i wasn't aware explicitly adjusting default hash table sizes was a prerequisite for a linker to be real
08:18:11 <Clint> don't mind me, i just despise gold beyond words
08:18:22 <int-e> oh, wait.
08:18:28 <int-e> xplat: I should ask you
08:19:00 * hackagebot soxlib 0.0.2 - Write, read, convert audio signals using libsox  http://hackage.haskell.org/package/soxlib-0.0.2 (HenningThielemann)
08:19:01 <xplat> Clint: believe it or not, i actually guessed that
08:19:12 <int-e> xplat: I don't know when ghc introduced it, but ghc-7.8.3 tries to check whether the linker is GNU ld before passing those flags.
08:20:11 <xplat> int-e: GNU gold (GNU Binutils for Ubuntu 2.22) 1.11
08:20:17 <xplat> ghc is 7.4.1
08:20:47 <int-e> that's a bit old
08:21:16 <geekosaur> 7.4 had that bug when working with gold, yes
08:21:16 <xplat> yes, i know, i'm writing a library i want to support old ghc
08:21:44 <xplat> so using a newer ghc would be counter to my purposes
08:21:46 <geekosaur> ubuntu allows the gnu ld to be selected at runtime; 7.4 only works with the one found during its configure step, iirc
08:22:21 <geekosaur> use the alternatives mechanism to swap back to standard binutils ld, or rebuild 7.4 yourself against gold
08:22:29 <xplat> is there some option i can put in cabal or ghc config that will cause it to use ld.bfd instead of ld?
08:23:32 <int-e> xplat: If I remember correctly, you can actually change $install_root/lib/ghc-7.4.1/settings and remove the offending flags.
08:23:32 <arw_> export LD=?
08:24:00 * hackagebot hscolour 1.21 - Colourise Haskell code.  http://hackage.haskell.org/package/hscolour-1.21 (MalcolmWallace)
08:26:01 <hexagoxel> xplat: a wild guess is cabal flag `--with-ld=ld.bfd`
08:26:21 <nkar> Clint: what's wrong with gold?  some claim that it links faster.  I haven't done any measurements, so I can't say for sure.
08:26:42 <c_wraith> It definitely uses less memory in some cases
08:27:29 <arw_> nkar: it might link faster, but it doesn't have all the features one needs for certain software and it has more bugs than traditional ld.
08:29:53 <xplat> hexagoxel: ding ding ding!  you are the winner!!  thanks.
08:31:20 <xplat> i would love if bfd ld could demonstrate not only partial but *complete* superiority over gold by not taking 8 hours to link pandoc on an unloaded machine due to swapping
08:56:20 <zerokarmaleft> is there a way to unset a flag in ghci, e.g. :set -fdefer-type-errors, to turn them back into errors? or do I just need to restart ghci?
08:56:43 <jabesed> is there some name for monads satifying  `join . fmap f . return = f` ?  and are there even some typical monads that don't satisfy this property?
08:57:51 <jtanguy> zerokarmaleft: you can unset flags with -fno-<flag>, like :set -fno-defer-type-errors
08:58:08 <zerokarmaleft> jtanguy: awesome
08:58:28 <hexagoxel> zerokarmaleft: there should be -fno-defer-type-errors. see `man ghc`
08:58:39 * hexagoxel is slow
08:58:51 <fragamus> :t join
08:58:52 <lambdabot> Monad m => m (m a) -> m a
08:59:03 * hackagebot MonadCompose 0.7.0.0 - Methods for composing monads.  http://hackage.haskell.org/package/MonadCompose-0.7.0.0 (JamesCandy)
08:59:14 <mpickering> jabesed: I think all monads will satisfy that?
09:00:05 <jabesed> mpickering: I surely can't think of a usual one that doesn't... but monad laws don't appear to guarantee it
09:00:26 <jabesed> mpickering: the monad laws only state that `join . return = id`
09:00:32 <int-e> jabesed: join . fmap f . return = join . return . f = id . f = f
09:00:45 <ski> jabesed : for every monad, `fmap f . return = return f', and also `join . return = id', so ..
09:01:15 <jabesed> ski: ok I thought I was indeed missing something
09:01:54 <ski> (the second is a monad law, the first says that `return' is a natural transformation (`fmap f . join = join . fmap (fmap f)' says that `join' is a NT)
09:01:59 <jabesed> ski: but where do you get that law from...
09:02:02 <jabesed> ohhhhhhh
09:02:05 <jabesed> argh
09:02:08 <jabesed> that was dumb
09:02:10 <jabesed> of course
09:02:41 <jabesed> I kept thinking of the monad diagrams and ignored they were natural transformations
09:02:49 <ski> assuming `fmap' is defined to be `liftM', you should probably be able to prove that `return' and `join' are NTs, from the three usual monad laws (?)
09:03:05 <jabesed> ski, int-e: thanks
09:03:22 <jabesed> ski: yeah, I was just thinking in category theory notation and translated it to haskell like that
09:03:26 <ski> @src liftM
09:03:27 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
09:03:56 <jabesed> ski: but that's only the case in haskell due to polymorphism no?
09:04:03 <ski>   liftM f ma = ma >>= return . f
09:04:09 <ski> jabesed : "that" referring to ?
09:04:38 <jabesed> ski: that referring to return/eta being natural transgormation following from the monad laws
09:05:08 <ski> well, look at `liftM' above
09:05:32 <ski>      liftM f . return
09:06:04 <jabesed> ski: well yeah, but I'm afraid that may induce one in error because haskell is more restricted then a general categorical setting (e.g. you're guaranteed to have a tensorial strength too in every monad)
09:06:09 <ski>   =  (\ma -> ma >>= return . f) . return
09:06:22 <ski>   =  \a -> return a >>= return . f
09:06:40 <ski>   =  \a -> (return . f) a
09:06:45 <ski>   =  return . f
09:07:22 <ski> so, using only the three usual (in Haskell) laws for `return' and `(>>=)', we can prove the `liftM f . return = return . f' natural transformation law
09:07:30 <ski> probably you can do something similar with `join'
09:07:42 <ski>   join mma = mma >>= return
09:07:50 <ski> start from this and see if you can do it ?
09:08:30 <ski> (iirc, it's only if you start from the `return' and `join' formulation that you also have to assume `fmap', and the natural transformation laws for `return' and `join')
09:08:45 <jabesed> hmm need to look at each line carefully
09:08:45 <ski> jabesed : i have to run run, but iirc, this works out fine
09:08:52 <jabesed> ski: thanks you!
09:09:28 <ski> (of course, the above also assumes eta laws and such, which doesn't strictly hold in Haskell due to the presence of `seq' ..)
09:10:38 <ski> (s/run run/run now/)
09:27:38 <dolio> ski: Eta reducing a composition doesn't require eta, I think. It follows from beta and the definition of composition.
09:30:29 <mniip> what's an eta reduction o.o
09:30:43 <mniip> I've heard of beta reduction and alpha-equivalence
09:30:47 <mniip> not eta
09:31:51 <thebnq> mniip: eta is essentially substitution
09:32:00 <mauke\> eta is like when you have \x -> ... x
09:32:09 <josephle> eta expansion: f ==> \x -> f x
09:32:09 <mauke\> and then you just cancel the two x's
09:32:27 <mniip> isn't that beta?
09:32:41 <mniip> oh
09:32:43 <mniip> I see
09:33:42 <thebnq> oops i chose the wrong word
09:35:01 <dolio> There are other eta rules, too, for things other than functions.
09:35:12 <dolio> p = (fst p, snd p)
09:35:21 <dolio> Going right is expansion, left is reduction.
09:35:40 <mniip> is there a superscientific name for \x -> f $ g $ h x   --> f . g . h
09:37:24 <dolio> Not really.
09:37:43 <dolio> It is just use of the definition of (.) and ($).
09:38:06 <dolio> I guess inlining and abstracting definitions has a name in systems that have it.
09:38:08 <mniip> nah I'm just using $ instead of parentheses here
09:38:10 <dolio> Delta maybe.
09:38:46 <mniip> $ is like a ( that you don't need to close
09:38:52 <mniip> to avoid the lisp problem
09:41:47 <dolio> Yes, I guess delta is the name typically given to replacing named definitions with their body or vice versa.
09:42:46 <mniip> so yeah
09:42:59 <mniip> is there anything else I should learn before trying to comprehend optics?
09:43:26 <stool> Lol, you mean lens?
09:43:39 * quchen recommends SPJ's talk.
09:43:41 <mniip> yeah
09:43:57 <mniip> but 'lens' is ambiguous because it can also mean Lens
09:44:33 <mniip> I'm not only aiming for Lens'es but also other types
09:44:38 <geekosaur> doesn't ek also use "optics" to talk about the various lens-like-but-not-quite-lenses?
09:44:41 <tromp_> learn all about lenses in the Haskell School of Optometry
09:45:03 <mniip> I think lens-family might be the scientific term?
09:45:15 <mauke\> optics is fine
09:45:18 <quchen> geekosaur: Prisms aren't lens-like at all, and also unified under "optics"
09:45:23 <mniip> no
09:45:26 <mniip> that is something else
09:45:48 <mniip> should've named Iso "Glass"
09:47:31 <Dopagod> how 2 haskell?
09:48:06 <mniip> Dopagod, just do it
09:48:20 <arw_> is it normal to use unsafePerformIO for quickCheck properties that have return type IO Bool?
09:48:22 <Dopagod> mniip how to begin
09:48:42 <mniip> Dopagod, Learn You A Haskell is a good tutorial
09:48:57 <fragamus> Dopagod: I would start with Graham Hutton's book
09:49:00 <Dopagod> can you make vidya
09:49:05 <Dopagod> with haskell
09:49:11 <mniip> but it depends largely on your past experience with other languages
09:49:30 <Dopagod> i know little python and basic
09:49:45 <fragamus> 2 haskell or not 2 haskell
09:49:50 <mniip> sure I guess... there are opengl bindings out there
09:50:11 <Dopagod> fragamus: i do not understand
09:50:32 <fragamus> nvm
09:50:42 <Dopagod> by the way. whats better perl or haskell or python!
09:51:04 <arw_> or
09:51:05 <mniip> Dopagod, all have their pros and cons, it depends on the domain you're trying to use it in
09:51:05 <moghedrin> Dopagod: It depends.
09:51:19 <Dopagod> mniip: web?
09:51:42 <lynnard> anyone installed hlint 1.9.16? I have problem with its installation...
09:52:09 <lynnard> src/HsColour.hs:25:16:
09:52:09 <lynnard>     Couldn't match type ‘Int’ with ‘[Char]’
09:52:23 <mniip> Dopagod, my guess would be perl
09:52:39 <Dopagod> perl is better than python for web?
09:52:53 <mniip> hard to say really
09:53:04 <quchen> Haskell is very webscale.
09:53:17 <mniip> all of them have good support for that kinda stuff
09:53:29 <bergmark> lynnard: lemme try
09:53:35 <arw_> Dopagod: its always a question of what you are more comfortable with. and what pre-existing libraries exist that you might want to use.
09:53:49 <mauke\> [#perl] <Dopagod> is perl any good for web applications?  <Dopagod> how does it compete with python?
09:54:11 <mniip> ooooo
09:54:13 <mniip> cross-posting
09:55:09 <mniip> my only experience with webdev so far was purely within CGI, and in that aspect all languages are more or less equal
09:55:36 <mniip> except assembly. assembly is clearly the winner there
09:55:41 <bergmark> Dopagod: i've done web dev in lots of languages and I've found  haskell to be the best by far
09:57:29 <lynnard> bergmark: OK from the source file I see hscolour has changed one of its CSS functions in its newest version
09:57:57 <lynnard> bergmark: Is there a way that I can tell cabal to install a specific version of hscolour and then let it be done with that?
09:58:19 <dolio> arw_: I thought there was something for doing quick check with IO.
09:58:34 <bergmark> lynnard: e.g. --constraint='hscolour<1.21'
09:58:50 <dolio> Using unsafePerformIO is probably not going to be ideal.
09:59:37 <Xnuk> Hello, why can't I make "reverse . take"?
09:59:43 <bergmark> lynnard: new hscolour was just released so there will probably be a ticket for that on stackage tomorrow, no need for you to notify the author
09:59:52 <lynnard> bergmark: saved my day! btw, is it a very common thing for upstream packages in hackage to break the downstream ones?
10:00:18 <tromp_> Xnuk you need take n to return a list
10:00:28 <arw_> > reverse . (take 10) $ [1..]
10:00:30 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
10:00:31 <mauke\> Xnuk: because that's equivalent to \x -> reverse (take x)
10:00:39 <bergmark> lynnard: if you like hlint don't have upper bounds on your dependencies it's much more likely that they will break at some point
10:00:41 <mauke\> Xnuk: reverse takes a list, but take x is not a list
10:01:36 <arw_> dolio: yes, i've thought about just using the generators and doing normal unit testing otherwise.
10:01:54 <arw_> dolio: but that just makes the code uglier.
10:02:51 <dolio> arw_: No, I mean stuff like Test.QuickCheck.Monadic.
10:03:06 <dolio> There is quickcheck stuff for having IO in properties.
10:03:24 <arw_> ah, okay, thanks, i'll try that
10:09:07 * hackagebot shelly 1.6.1.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.1.1 (GregWeber)
10:12:14 <hanlei> Hello
10:19:08 * hackagebot flexible-time 0.1.0.0 - Flexible time library.  http://hackage.haskell.org/package/flexible-time-0.1.0.0 (tattsun)
10:19:18 <bitonic> are there some conventions to do lexing and parsing in one pass with parsec (or similar) and still get good error messages?
10:20:00 <bitonic> in my case, I already have a lexer + parser in Parsec, the parser produces good error messages because it never looks ahead.  I'd like to easily convert that to a parser that does not lex first but still gives good errors
10:20:24 <dulla> flexible time? what?
10:24:08 * hackagebot flexible-time 0.1.0.1 - Flexible time library.  http://hackage.haskell.org/package/flexible-time-0.1.0.1 (tattsun)
10:39:09 * hackagebot simple-smt 0.5.4 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.5.4 (IavorDiatchki)
10:41:54 <xnull_> i am having trouble grokking the concept of applicative functors.
10:42:16 <xnull_> specifically, i am having trouble with <*>. what is the point of this function?
10:43:12 <xnull_> as in, can someone explain a scenario to me in which the function is actually useful?
10:43:28 <conal> xnull_: do you see how liftA2, liftA3, etc are useful?
10:44:10 * hackagebot ghcid 0.3.5 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.3.5 (NeilMitchell)
10:46:04 <xnull_> conal: yes, it seems like an fmap with more arguments in both itself and the function it accepts
10:46:56 <conal> xnull_: yes. and <*> makes it easy to define liftA2, liftA3, .... It's also often used as an alternative to them.
10:47:27 <xnull_> i'm confused as to how you might use <*> synonymously with liftA2
10:47:32 <conal> xnull_: e.g., liftA3 f xs ys zs = f <$> xs <*> ys <*> zs
10:47:51 <xnull_> oh, that is where i've usually seen <*> used
10:48:23 <xnull_> it's a bit hard for me to grasp what's going on there, i suppose i just need a bit to let it sink in.
10:48:35 <xnull_> thanks for the explanation, conal
10:48:59 <conal> xnull_: <*> and liftA2 can each be used to define the other. <*> has a simpler type, and so makes for a better primitive.
10:49:07 <conal> xnull_: you're welcome.
10:50:45 <hannes__> does anyone here know how to solve/work around the 'type families are not injective' thing?
10:52:39 <xnull_> conal: wait, would liftA simply be equal to fmap besides the requirement of an Applicative instead of just a Functor?
10:52:54 <conal> xnull_: yes
10:53:46 <xnull_> and `liftA f x y' == `f <$> x <*> y'?
10:54:03 <xnull_> or just <$>
10:54:15 <xnull_> oh, no
10:54:26 <xnull_> `liftA f x' == `f <$> x'?
10:54:33 <hannes__> yes
10:54:54 <hannes__> liftA is fmap, and so is (<$>)
10:54:54 * xnull_ scribbles around in ghci some more
10:55:04 <conal> xnull_: and fmap f w == pure f <*> w
10:55:09 <xnull_> hannes__: but Applicative is a superset of Functor, is it not?
10:55:18 <hannes__> xnull_: yes
10:55:26 <conal> xnull_: i.e., f <$> w == pure f <*> w
10:55:29 <xnull_> so liftA is not /always/ fmap
10:55:37 <xnull_> or not exactly fmap
10:55:38 <hannes__> xnull_: actually no
10:55:42 <hannes__> xnull_: or yes
10:55:47 <xnull_> correct?
10:55:47 <hannes__> xnull_: depending on what you mean by that
10:56:08 <xnull_> liftA :: Applicative f => (a -> b) -> f a -> f b
10:56:17 <xnull_> fmap :: Functor f => (a -> b) -> f a -> f b
10:56:24 <hannes__> xnull_: Applicative is a subset of Functor in the sense that all applicatives are functors, but their functionality is a superset of the functionality of functors
10:56:30 <xnull_> OH
10:56:44 <xnull_> ohhhh.
10:57:00 <xnull_> this is strange to me
10:57:08 <conal> (more requirements == fewer members)
10:57:31 <xnull_> gotcha
10:57:49 <xnull_> hrm
10:58:21 <xnull_> the synonymity of "liftA2 f x y" to "f <$> x <*> y" is still a bit confusing to me
10:58:29 <xnull_> i'll just have to work out the types
10:59:03 <conal> xnull_: yeah. work out the types, and i bet you'll get an aha!
10:59:34 <hannes__> xnull_: just write it as (f <$> x) <*> y and that should make it fairly easy
11:01:55 <xnull_> yeah, i think taking infix notation out of it might help too
11:04:14 <libc> Hi.  I'm interested in learning about and messing around with DSP.  Would haskell be a good language for that compared to your run of the mill C/Python/whatever?  I've been wanting an excuse to learn haskell
11:04:16 <forgottenone> how can i produce all possible logical combinations in a truth table with monads?
11:04:35 <hannes__> forgottenone: Why 'with monads'?
11:04:47 <forgottenone> hannes_ just for curiosity
11:04:55 <jle`> you can use the Applicative instance for list
11:04:57 <xnull_> f <$> x <*> y = (<*>) (fmap x) y
11:05:07 <xnull_> oh jeez, the partial application is what's tripping me up
11:05:12 <jle`> > liftA2 (&&) [False, True] [True, False]
11:05:13 <lambdabot>  [False,False,True,False]
11:05:21 <hannes__> forgottenone: Easiest way is with applicative liftA2 (,) x1 x2
11:05:39 <scott> xnull_: remember that a -> b -> c is a -> (b -> c) so it fits into fmap's type
11:05:52 <xnull_> wat
11:05:54 <hannes__> > liftA2 (,) [1,2] [3,4]
11:05:56 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
11:06:00 * xnull_ is incredibly confused now
11:06:16 <xnull_> oh derp
11:06:18 <scott> :t fmap
11:06:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:06:24 <scott> :t (++)
11:06:25 <lambdabot> [a] -> [a] -> [a]
11:06:27 <xnull_> sorry about that
11:06:28 <scott> :t fmap (++)
11:06:29 <lambdabot> Functor f => f [a] -> f ([a] -> [a])
11:06:39 <jle`> (+) <$> Just 3 <*> Just 9
11:06:44 <scott> b = [a] -> [a]
11:06:44 <jle`> Just (3 +) <*> Just 9
11:06:51 <jle`> Just (3 + 9)
11:06:53 <jle`> ^^ xnull_
11:07:41 <xnull_> jle`: i like how you reduced that down
11:07:43 <forgottenone> hannes_ what if want truth table with 4 or 5 variables?
11:08:12 <xnull_> OH
11:08:39 <jle`> forgottenone: you can use the <$>/<*> synax
11:08:40 <hannes__> forgottenone: depends. what are you asking?
11:08:42 <jle`> er, formulation
11:08:46 <xnull_> so (<*>) takes a function wrapped in an applicative functor as well as another value wrapped in the same type of applicative functor and returns a new applicative functor with a new value
11:09:11 <xnull_> so without referring to the actual type i want to construct (<*>)'s myself
11:09:14 <xnull_> gimme a moment
11:09:43 <xnull_> (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:09:43 <forgottenone> jle,hannes__ thanks
11:09:54 <xnull_> :t (<*>)
11:09:55 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:09:57 <xnull_> YESSSS
11:10:01 <xnull_> thanks guys
11:10:12 <jle`> > (\a b c d e f -> a /= (b && c || d /= (not f && e)) <$> [False..] <*> [False..] <*> [False..] <*> [False..] <*> [False..] <*> [False..] <*> [False..]
11:10:14 <lambdabot>  <hint>:1:65: parse error on input ‘]’
11:10:39 <jle`> > (\a b c d e f -> a /= (b && c || d /= (not f && e)) <$> [False ..] <*> [False ..] <*> [False ..] <*> [False ..] <*> [False ..] <*> [False ..] <*> [False ..]
11:10:40 <lambdabot>  <hint>:1:157:
11:10:41 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:10:50 <xnull_> > (\a b c d e f -> a /= (b && c || d /= (not f && e)) <$> [False ..] <*> [False ..] <*>  [False ..] <*> [False ..] <*> [False ..] <*> [False ..] <*> [False ..])
11:10:52 <lambdabot>  Precedence parsing error
11:10:52 <lambdabot>      cannot mix ‘GHC.Classes./=’ [infix 4] and ‘Data.Functor.<$>’ [infixl 4] ...
11:10:57 <jle`> heh sorry
11:10:59 <S11001001> jle`: 3rd close paren
11:11:06 <clrnd> xnull_ leveled up
11:11:09 <jle`> not just that, but fixity stuf
11:11:10 <xnull_> :)
11:11:16 <S11001001> jle`: \, b, not
11:11:30 * S11001001 has practice from years of lisp
11:11:53 <scott> xnull_: and if you compare to fmap, it's almost the same except with f (a -> b) instead of (a -> b), and pure lets you go from a -> f a (or (a -> b) -> f (a -> b), and that's why you can implement fmap with (<*>) and pure
11:12:12 <xnull_> scott: ah! :D
11:12:27 <hiptobecubic> jle`, oh that's nice. I usually do some horrible zip incantation for that case
11:12:31 <xnull_> let me try my hand at implementing fmap with (<*>) and pure
11:12:35 <xnull_> :t fmap
11:12:37 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:12:51 <S11001001> hiptobecubic: well, zip is a different applicative functor than the default list one.
11:13:21 <S11001001> hiptobecubic: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Control-Applicative.html#ZipList
11:13:24 <faux___> why do you say 'minBound :: Int' instead of 'minBound Int'? I don't understand the use of '::'
11:13:39 <hannes__> faux___: type annotation
11:13:45 <hiptobecubic> oh is that using the same semantics as the normal list monad? of course, right.
11:13:47 <hannes__> faux___: it means 'minBound of type int'
11:13:57 <hiptobecubic> it just *looked* like it should be ziplisty
11:14:04 <S11001001> hiptobecubic: it does :)
11:14:25 <xnull_> :t (\f x -> pure f <*> x)
11:14:26 <lambdabot> Applicative f => (a -> b) -> f a -> f b
11:14:34 <faux___> hannes__: i see. its like polymorphism
11:14:36 <xnull_> would that be how you would do it?
11:14:43 <faux___> hannes__: thanks
11:14:54 <xnull_> or is there some way to get Applicative in the final class to be Functor
11:14:58 <hannes__> faux___: it's not 'like' polymorphism. It's actual polymorphism.
11:15:12 <faux___> hannes__: even better :)
11:15:30 <scott> xnull_: that's how you do it. Applicative is required here no matte what since you use (<*>) and pure
11:15:35 <xnull_> because that's more liftA than fmap
11:15:40 <jle`> xnull_: you use pure too
11:15:55 <hannes__> xnull_: liftA is fmap with different constraints. same difference really
11:16:05 <xnull_> yeah, just being pedantic
11:16:06 <scott> :t ap
11:16:07 <lambdabot> Monad m => m (a -> b) -> m a -> m b
11:16:08 <jle`> xnull_: however, it is identical in result-output to fmap
11:16:14 <xnull_> could you do:
11:16:18 <jle`> it follows the fmap laws
11:16:29 <hannes__> xnull_: I guess not everything that's a functor is also applicative, though I can't think of any obvious examples on top of my head.
11:16:36 <xnull_> fmap' :: Functor f => (a -> b) -> f a -> f b
11:16:44 <xnull_> fmap' f x = pure f <*> x
11:16:46 <xnull_> ?
11:17:03 <scott> xnull_: no
11:17:19 <xnull_> yeah...
11:17:21 <jle`> :t (<*>)
11:17:22 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:17:27 <xnull_> functor doesn't necessarily... oh.
11:17:36 <xnull_> hrm. poop
11:17:38 <jle`> (<*>) takes an `f b` on the right hand side
11:17:43 <hannes__> xnull_: You can't hide the fact that you use Applicative in the implementation
11:17:46 <xnull_> yeah
11:17:46 <jle`> where the f is Applicative
11:17:50 <xnull_> lol jle`
11:17:56 <scott> xnull_: you can prove fmap' is the same as fmap for Applicatives
11:17:58 <jle`> so the type is inferred to be Applicative f => ... f b
11:18:01 <xnull_> scott: indeed
11:18:21 <hannes__> xnull_: Or actually, well you could but only if you define both the functor and applicative instances at the same time
11:18:34 <xnull_> so once you've polluted your logic with Applicatives you can't return back to regular Functors
11:18:56 <hannes__> xnull_: Type classes are like the GPL in that regard
11:19:00 <jle`> good too, because not all Functors are Applicative
11:19:19 <jle`> so you can't make a function polymorphic on all Applicative to a function polymorphic on all Functor
11:19:19 <xnull_> hannes__: hah!
11:19:42 <xnull_> jle`: yeah, i see
11:20:04 <xnull_> OH
11:20:08 <xnull_> this all makes sense now
11:20:10 <jle`> not all functors have `pure`, for instance
11:20:17 <scott> is there a name for a version of Application without pure?
11:20:24 <xnull_> you've still got to instantiate/implement fmap itself explicitly for any instance of Functor
11:20:33 <scott> it seems like a fair bit of the uses of Applicative I see don't need pure
11:20:44 <scott> Applicative*
11:20:45 <jle`> xnull_: yes, not all Functors have "pure" defined, and not all functors have (<*>) defined
11:20:53 <geekosaur> scott: that would be Functor
11:20:55 <jle`> scott: people call it Apply
11:20:58 <geekosaur> @where typeclassopedia
11:20:58 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
11:21:01 <xnull_> but you just define (<*>) and pure for an Applicative and you get liftA magically
11:21:04 <hannes__> geekosaur, scott Apply
11:21:07 <geekosaur> hm, maybe I misunderstood
11:21:18 <scott> geekosaur: Functor can't supply (<*>)
11:21:24 <hannes__> geekosaur: if you drop pure you still have <*>
11:21:24 <jle`> scott: it's basically similiar to semigroup vs. monoid
11:21:27 * geekosaur is scrambled today
11:21:29 <scott> thank you jle` / hannes__
11:21:35 <ril> hi, I have a dumb question
11:21:43 <hannes__> ril: That's interesting news
11:21:46 <jle`> ril: ask away :D
11:21:53 <scott> jle`: right, nice analogy
11:22:07 <jle`> what's a lot less useful is Applicative w/out (<*>)/ap
11:22:10 <jle`> or a lot less meaningful
11:22:11 <xnull_> so how do you decide whether to use Functor or Applicative?
11:22:12 <ril> I'm working through LYaHfGG and I want try making a module
11:22:22 <jle`> xnull_: usually i use the "minimal power"
11:22:29 <xnull_> but i can't decide which is minimal here
11:22:29 <jle`> or make my functions as general as possible
11:22:35 <scott> jle`: I'm starting to remember... that's what they called Point which has no meaningful laws, right?
11:22:35 <jle`> in which case?
11:22:36 <hannes__> xnull_: You'll know how much you need
11:22:55 <jle`> scott: yeah, it's like having a typeclass that is just `mempty`
11:22:57 <xnull_> jle`: it seems like each has an inescapable difference, one doesn't just have less power than the other
11:23:00 <ril> so I have for instance the vector type and a few functions from chapter 7, and I can :l vector and that's dandy
11:23:28 <Hijiri> xnull_: Functor has strictly less power than Applicative
11:23:28 <jle`> xnull_: make your functions as general as possible so they can be used on as many types as possible
11:23:31 <hannes__> xnull_: Actually, it's exactly one has less power than the other. Functor is a weaker constraint and thereforem ore general
11:23:36 <ril> so I want to add module (Vector(..), vplus, dotProd, vmult) where at the top of my source file
11:23:37 <Hijiri> since all Applicative are Functors
11:23:43 <xnull_> oh, but you can
11:23:45 <xnull_> oh
11:23:45 <ril> and then import vector
11:23:48 <xnull_> ok.
11:23:49 <scott> jle`: hrm, that really is a useful analogy. kind of makes it obvious why Point is worthless
11:24:07 <xnull_> jle`: yeah i get that i was just having trouble making sense of which had more power
11:24:33 <hannes__> ril: so what's the question?
11:24:42 <ril> parse error on input ‘vector’
11:24:44 <jle`> there is actually a "just mempty" typeclass that floats around, called Default, but it doesn't really have any meaning attached to it, so it doesn't really make sense to write functions "polymorphic over all Default"
11:24:58 <hannes__> ril: modules start with an uppercase letter
11:25:00 <xnull_> so how do you convert something from a Functor to an Applicative?
11:25:00 <jle`> ril: if you have a file called Vector.hs, you can say `import Vector`
11:25:01 <ril> I'm clearly stumbling on some syntax and it's frustrating
11:25:07 <xnull_> OHHHH
11:25:08 <xnull_> never mind
11:25:14 <xnull_> that was where i was confused, i get it now
11:25:43 <ril> but I get this parse error
11:25:44 <jle`> xnull_: every function you write as `Functor f => ...` will work on all Functors, Applicatives, and soon, Monads
11:25:47 <xnull_> for something that is an applicative, you would instantiate it as both an Applicative and a Functor, and wherever possible you would use Functor in function type definitions
11:25:59 <xnull_> jle`: yeah, i read the thing about monads a bit ago, pretty awesome
11:26:06 <jle`> every function you write as `Applicative f => ...` will only work on Applicatives and, soon, Monads
11:26:11 <jle`> they won't work on Functors
11:26:16 <xnull_> right
11:26:24 <jle`> ril: make your file called Vector.hs, and import Vector
11:26:33 <jle`> it's kind of like a naming convention thing
11:26:36 <xnull_> you just use the lowest one in the chain that you can use
11:26:41 <ril> oh, it's case sensitive?
11:26:44 <xnull_> ril: yes
11:26:45 <jle`> mhm
11:26:56 <xnull_> jle`: nice double answer there
11:27:10 <scott> jle`: I can think of a single case where you want to by polymorphic over Default, and that's when defining 'recursive' Default instances like Default a => Default (a, a) or so
11:27:16 * xnull_ skips down to the Monoids section in LYAH
11:27:41 <jle`> scott: a valid contrived case :)
11:28:06 <hannes__> ril: Everything in haskell is case sensitive. Types (except for type variables), constructors and module names are capitalized, variables of any description aren't
11:28:21 <jle`> yeah, imagine my surprise when i came from fortran!
11:28:27 <xnull_> but anyways, say i wanted a list consisting different operations performed on some number
11:28:31 <xnull_> i could do
11:28:52 <ril> I just didn't think that the file name would matter too
11:29:00 <ril> no I get <no location info>: do I need to specify a relative path?
11:29:03 <ril> *now
11:29:12 * hackagebot casadi-bindings 2.2.0.7 - mid-level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.2.0.7 (GregHorn)
11:29:14 * hackagebot vcache 0.2.2 - large, persistent, memcached values and structure sharing for Haskell  http://hackage.haskell.org/package/vcache-0.2.2 (dmbarbour)
11:29:19 <jle`> ril: is that on ghci?
11:29:23 <ril> yup
11:29:35 <hannes__> ril: :l path/to/file
11:29:51 <hannes__> ril: ghci doesn't do relative imports IIRC
11:29:51 <ril> are import and :l the same thing?
11:29:53 <jle`> also i fear you might have gotten your module syntax off, unless that was a typo earlier
11:29:56 <xnull_> myResults = (\x y z -> [x,y,z]) <$> (+3) <*> (*3) <*> (-3)
11:29:59 <xnull_> then i can do
11:30:02 <ril> I thought :l was more like #include in C
11:30:09 <hannes__> ril: No, :l is a ghci only thing and loads files instead of modules
11:30:15 <jle`> module Vector (blah, blah) where ...
11:30:22 <hannes__> ril: well, you can think of it like that
11:30:29 <xnull_> myResults 5 => [8,15,2]
11:30:48 <ril> like when I import a module I can hide certain functions by not exporting them, but :l will just load everything, right?
11:30:50 <xnull_> ugh, the use of <$> <*> <*> is so confusing to me
11:30:57 <xnull_> just having intuition forit
11:31:05 <jle`> xnull_: yeah, i really like liftAX form better
11:31:07 <hannes__> xnull_: you defined a 3 parameter function and only supplied one
11:31:11 <xnull_> is there a simple way to think about it?
11:31:31 <jle`> xnull_: you can think of it as genearlized function application. they're supposed to fade away in your head
11:31:37 <jle`> f <$> x <*> y <*> z
11:31:42 <jle`> is supposed to look like `f x y z`
11:31:49 <xnull_> :t (\x y z -> [x,y,z]) <$> (+3) <*> (*3) <*> (-3)
11:31:50 <lambdabot> (Num (t -> t), Num t) => t -> [t]
11:31:54 <jle`> > Just (+) <*> Just 3 <*> Just 10
11:31:55 <lambdabot>  Just 13
11:31:57 <jle`> > (+) 3 10
11:31:58 <lambdabot>  13
11:32:08 <xnull_> hannes__: look above
11:32:10 <jle`> > Just elem <*> Just 5 <*> Just [1,5,7]
11:32:11 <lambdabot>  Just True
11:32:15 <jle`> > elem 5 [1,5,7]
11:32:17 <lambdabot>  True
11:32:23 <xnull_> > ((\x y z -> [x,y,z]) <$> (+3) <*> (*3) <*> (-3)) 5
11:32:25 <lambdabot>  No instance for (GHC.Show.Show t0)
11:32:25 <lambdabot>    arising from a use of ‘M72641620703417023211681.show_M72641620703417023211...
11:32:25 <lambdabot>  The type variable ‘t0’ is ambiguous
11:32:32 <xnull_> woah, what
11:32:37 <hannes__> xnull_: well, if you have a Num (t->t) instance defined that could technically work I guess
11:32:46 <ril> thanks, I did have that that syntax wrong
11:32:49 <xnull_> wat
11:32:51 <exio4> it's missing the \x -> x-3
11:33:00 <ril> so GHCI cannot import a module that's in a source file?
11:33:00 <xnull_> > (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
11:33:02 <lambdabot>  [8.0,10.0,2.5]
11:33:09 <xnull_> huh
11:33:11 <jle`> xnull_: it's interpreting (-3) as negative 3
11:33:15 <jle`> > -3
11:33:16 <xnull_> oh!
11:33:17 <lambdabot>  -3
11:33:17 <dolio> xnull_: (-3) is negative 3, not subtract 3.
11:33:32 <xnull_> > ((\x y z -> [x,y,z]) <$> (+ 3) <*> (* 3) <*> (- 3)) 5
11:33:32 <hannes__> xnull_: yeah, that looks better
11:33:34 <lambdabot>  No instance for (GHC.Show.Show t0)
11:33:34 <lambdabot>    arising from a use of ‘M236412548272898633011724.show_M2364125482728986330...
11:33:34 <lambdabot>  The type variable ‘t0’ is ambiguous
11:33:35 <hannes__> :t neg
11:33:36 <lambdabot> Not in scope: ‘neg’
11:33:39 <hannes__> :t negate
11:33:40 <lambdabot> Num a => a -> a
11:33:42 <hannes__> negate 5
11:33:46 <jle`> > subtract 3   $   10
11:33:48 <lambdabot>  7
11:33:50 <xnull_> > ((\x y z -> [x,y,z]) <$> ((+) 3) <*> ((*) 3) <*> ((-) 3)) 5
11:33:52 <lambdabot>  [8,15,-2]
11:33:54 <hannes__> > subtract 5 3
11:33:55 <xnull_> there we go
11:33:56 <lambdabot>  -2
11:34:03 <jle`> xnull_: that's actually backwards of what you want, but :)
11:34:05 <jle`> you want `subtract 3`
11:34:07 <xnull_> yeah, it is
11:34:08 <xnull_> oh, ok
11:34:20 <jle`> it's a weird parsing quirk yeah :/
11:34:27 <xnull_> > ((\x y z -> [x,y,z]) <$> (+3) <*> (*3) <*> (`subtract 3`)) 5
11:34:28 <lambdabot>  <hint>:1:55: parse error on input ‘3’
11:34:33 <xnull_> > ((\x y z -> [x,y,z]) <$> (+3) <*> (*3) <*> (`subtract` 3)) 5
11:34:35 <lambdabot>  [8,15,-2]
11:34:41 <xnull_> > ((\x y z -> [x,y,z]) <$> (+3) <*> (*3) <*> (subtract 3)) 5
11:34:42 <hannes__> jle`: that's what you get for supporting negative literals
11:34:43 <lambdabot>  [8,15,2]
11:34:45 <xnull_> oi
11:34:49 <jle`> btw there's a general shorthand for lifting (\x y z -> [x,y,z]) ... for arbitrary number of elements
11:34:56 <dolio> That's enough lambdabotting.
11:35:00 <xnull_> indeed
11:35:03 <jle`> we call it sequenceA
11:35:20 <xnull_> yeah, but it was an example in LYAH
11:35:24 <jle`> > sequenceA [Just 3, Just 10, Just 3]
11:35:25 <lambdabot>  Not in scope: ‘sequenceA’
11:35:25 <lambdabot>  Perhaps you meant one of these:
11:35:25 <lambdabot>    ‘T.sequenceA’ (imported from Data.Traversable),
11:35:28 <jle`> > T.sequenceA [Just 3, Just 10, Just 3]
11:35:29 <lambdabot>  Just [3,10,3]
11:35:41 <jle`> > T.sequenceA [(+3), (*3), subtract 3)   $    5
11:35:42 <lambdabot>  <hint>:1:36: parse error on input ‘)’
11:35:46 <jle`> > T.sequenceA [(+3), (*3), subtract 3]   $    5
11:35:47 <lambdabot>  [8,15,2]
11:35:55 <jle`> oh okay. then ignore me :)
11:35:59 <xnull_> :P
11:36:37 <xnull_> i'll probably have to revisit this; it's nearly as hard for me to grasp as monads were
11:36:40 <ril> so am I misunderstanding something about how modules relate to ghci?
11:37:05 <jle`> xnull_: it's ok, no rush :)
11:37:11 <xnull_> (monads were hard for me to get because i couldn't find an explanation that was simple enough, everything tried to put more to it than there should've been IMHO)
11:37:14 <jle`> ril: you can import a module, and it's like importing them into a file
11:37:38 <ril> but I can't import a module defined in a .hs file?
11:37:44 <xnull_> if someone had said "Monad is a typeclass consisting of the functions bind and return" i would have gotten it instantly
11:37:55 <jle`> ril: you can only import a module defined in a .hs file
11:38:05 <xnull_> unfortunately all i got out of folks was a "monoid in the class of endofunctors"
11:38:21 <voidzero> oh, look, it's this subject again
11:38:30 <xnull_> :(
11:38:33 <jle`> xnull_: i really think you might want to revisit your source of haskell education :)
11:38:38 <xnull_> yeah...
11:38:39 <jle`> er, revisit your decision on your source
11:38:52 <xnull_> heh
11:38:54 <hannes__> xnull_: it's even easier if you think 'monad is applicative + join'
11:39:04 <jle`> maybe "Functor + Join"
11:39:09 <xnull_> soon.jpg
11:39:15 <jle`> oh yeah, Applicative for pure
11:39:17 <jle`> sry
11:39:37 <xnull_> so can i use <*> with Monads?
11:39:53 <jle`> for almost all types that are monads, yes.
11:39:54 <geekosaur> most of them now, all of them soon
11:39:54 <hannes__> xnull_: with nearly all of them in 7.8, and yes starting with 7.10
11:40:07 <xnull_> when is 7.10 scheduled?
11:40:12 <jle`> but for a month or two you won't be able to use <*> in a function that is Monad m => ...
11:40:12 <geekosaur> end of march
11:40:17 <hannes__> RC2 is out, don't know release
11:40:19 <xnull_> awesome! :D
11:40:37 <jle`> you can use `ap`, though
11:40:42 <jle`> ap is to <*> as liftA is to fmap
11:41:01 <jle`> :t ap
11:41:02 <lambdabot> Monad m => m (a -> b) -> m a -> m b
11:41:03 <jle`> :t (<*>)
11:41:04 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:41:13 <xnull_> oh, awesome
11:41:23 <hannes__> > return (+3) `ap` return 5 :: Maybe Int
11:41:26 <lambdabot>  Just 8
11:41:45 <jle`> we just use ap these days because a lot of types we like to write functions over all Monad m, and if we wanted to use (<*>) we'd have to make them over all (Appliative m, Monad m) => ...
11:41:59 <jle`> but as of 7.10 this will be all better :)
11:42:00 <ajcoppa> xnull_: the NICTA course is awesome for getting really deep on functor/applicative/monad by implementing several of them yourself
11:42:22 <ril> okay so I can do this `:l Vector` `:m` `import Vector` and it works
11:42:23 <hannes__> and with 7.10 everyone has to stop ignoring Foldable :D
11:42:50 <ril> but if I just start ghci and do `import Vector` I get a "could not find module"
11:42:50 <jle`> ril: congrats :)
11:42:54 <jle`> oh
11:43:00 <jle`> is Vector.hs in the directory you are in?
11:43:02 <ril> yes
11:43:12 <jle`> does it start with module Vector (blah blah) where ....
11:43:13 <ril> my guess is it's a compilation thing?
11:43:14 <jle`> ?
11:43:17 <ril> yeah
11:43:20 <hannes__> ghci doesn't look for stuff that's not in registered packages by default
11:43:27 <jle`> oh yes of course
11:43:35 <jle`> wait
11:43:40 <ril> so :l has some side effects that persist after :m and allow import to work
11:43:41 <Hijiri> RC = Release Candidate?
11:43:45 <geekosaur> yes
11:44:06 <geekosaur> note that they're still working on a bug so it's not clear how actually RC it is...
11:44:13 * hackagebot aws-kinesis-client 0.3.0.1 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.3.0.1 (JonSterling)
11:44:27 <hannes__> geekosaur: it compiles and you can run ghci
11:44:34 <hannes__> totally RC
11:44:55 <jle`> if it typechecks it ships
11:45:28 <geekosaur> (https://ghc.haskell.org/trac/ghc/ticket/9858 aka yet another way to derive unsafeCoerce)
11:46:01 <xnull_> so, if LYAH gets to Zippers and just stops, what would be a good place to go after that, since i think i have a good foundation with Monads and will likely be through the rest of the book pretty quickly?
11:47:23 <S11001001> xnull_: transformers!  Data types that change monads to other monads.
11:47:46 <jonsterling> geekosaur: WOW! That ticket is amazing...
11:48:14 <xnull_> S11001001: is there a text that you would recommend for after LYAH?
11:49:16 <ril> I thought maybe :l was doing some kind of compilation step, so I tried `ghc --make Vector.hs`, but that does nothing
11:53:15 <clrnd> huh, I'm having a problem with cabal
11:53:28 <faux___> if i want to pattern-match on the head and tail of a list, why must i wrap it in parens? eg why '(x:xs)' instead of 'x:xs'?
11:53:40 <hannes__> clrnd: There's no such thing as someone not having problems with cabal
11:53:53 <clrnd> http://lpaste.net/121187
11:53:55 <hannes__> it just means you're human, don't worry about it
11:54:00 <ajcoppa> xnull_: check out https://github.com/bitemyapp/learnhaskell
11:54:02 <clrnd> I know ;D
11:54:05 <shachaf> faux___: You don't have to.
11:54:16 <shachaf> case l of x:xs -> (x,xs)
11:54:25 <ajcoppa> xnull_: CIS194 is a free introductory course that has exercises you can do to validate the understand you got from LYAH
11:54:26 <xnull_> ajcoppa: generally i've read that real world haskell is nice to go through
11:54:30 <S11001001> faux___: f x : xs looks like x and xs are the 1st & 3rd args to f, the : is... something.  This is a general thing about patmat for function args, not specific to :.
11:54:36 <clrnd> btw, I did previous to that: `cabal install transformers==0.4.*`
11:54:44 <ajcoppa> xnull_: i recommend the first two resources in the linked guide. CIS194 followed by the NICTA course
11:54:50 <faux___> S11001001: thank you
11:54:53 <xnull_> alright
11:54:53 <clrnd> (all this in a sandbox)
11:55:06 <ReinH> S11001001: Er. f x : xs is (f x) : xs
11:55:18 <S11001001> ReinH: ah right
11:55:21 <ajcoppa> xnull_: there's also a #haskell-beginners channel here on freenode that's lighter traffic and specifically for learning, which can make it easier to get help sometimes
11:55:23 <geekosaur> faux____, in general patterns follow the same rules as expressions. so `f x:xs` parses as `(f x) : xs` even though the latter isn't that meaningful as a pattern
11:55:39 <geekosaur> but the consistency between the two is helpful
11:55:45 <ReinH> S11001001: The whole thing is ((:) (f x)) xs
11:55:52 <hannes__> clrnd: try hiding transformer 0.3.0.0?
11:55:54 <faux___> geekosaur: thanks
11:55:57 <geekosaur> rather than it behaving one way in patterns and some other way in expressions
11:56:10 <faux___> geekosaur: makes sense
11:56:18 <ril> so is there a way to make ghci look in $PWD when I ask it to import, or do I have to create a package?
11:56:19 <clrnd> hannes__, ghc-pkg unregister won't let me, because it's installed in a root folder (I could sudo but why?)
11:56:44 <S11001001> clrnd: what are you requiring transformers 0.4 for?
11:57:04 <clrnd> S11001001, lambdabot==5.0
11:57:31 <hannes__> ril: I don't think there is. I don't think I've missed that option though tbh
11:58:01 <ril> okay, thanks :)
11:59:13 * hackagebot flexible-time 0.1.0.2 - Flexible time library.  http://hackage.haskell.org/package/flexible-time-0.1.0.2 (tattsun)
11:59:32 <ril> I don't think it's a big deal in general, except that I was just learning about the module declaration and it wasn't clear that I was doing it properly since :load wasn't hiding functions I declined to export
11:59:48 <Hijiri> I'm pretty sure ghci looks in the working directory if the source files are named properly
11:59:53 <lpaste> kyclark pasted “IO a -> a” at http://lpaste.net/121189
12:00:12 <hannes__> Hijiri: not my experience
12:00:18 <Hijiri> oh, maybe not then
12:00:22 <ril> Hijiri, if I :load it first, then I can unload it and import it and it the not-exported functions are hidden
12:00:43 <hannes__> Hijiri: maybe it's just been too long since you've worked outside of a cabal package :P
12:00:50 <ril> but I can't just import it straight away, and if I :load it without the other steps, then every function gets loaded
12:00:52 <jle`> kyclark: it's a little awkward, but you can use >>=
12:01:02 <Hijiri> ok, I just tried and it doesn't work
12:01:09 <Hijiri> so I was saying wrong things
12:01:14 <ril> thanks everyone
12:01:15 <S11001001> kyclark: this would not be pure.  Control.Monad provides several combinators for doing point-free monad programming.
12:01:15 <jle`> doesFileExist inLoc >>= \exists -> when (not exists) (...)
12:01:29 <kyclark> Which way is most idiomatic Haskell?
12:01:30 <jle`> kyclark: and you could make that point-free
12:01:47 <jle`> kyclark: the way you had it is already good, but if you really want to "not have a name"
12:02:12 <jle`> doesFileElist inLoc >>= flip when (.....)
12:02:19 <jle`> but the idiomatic way would be just to name it
12:02:51 <kyclark> OK, all great things for me to consider and read up on, just getting the hang of bind >>=
12:03:26 <jle`> no worries, no need to rush.  what's import here is that do { x <- m; blah blah x } is the same as m >>= (\x -> blah blah x)
12:03:46 <jle`> but yeah for now i'd just name it, *or* you could define your own custom "monadic when"
12:03:55 <geekosaur> ril: actually that sounds broken to me, local modules should be compiled as needed on import. -i can be used to set the search path for them (-i by itself clears the search list, otherwise -i/path/to/modules/dir, default should be -i. to search current directory)
12:04:14 * hackagebot flexible-time 0.1.0.3 - simple extension of Data.UnixTime.  http://hackage.haskell.org/package/flexible-time-0.1.0.3 (tattsun)
12:04:18 <jle`> whenM mx y = mx >>= \x -> when x y
12:04:21 <geekosaur> note that if you are using cabal repl then cabal may be modifying search paths around your back
12:04:26 <Clint> there are far too many libraries with whenM
12:04:40 <jle`> then you can do whenM (doesFileExist inLoc) (...)
12:05:14 <jle`> but yeah, idiomatic would just be to name it here
12:05:56 <ril> geekosaur:
12:06:17 <ril> `ghci -i`
12:06:18 <ril> import Vector
12:06:18 <ril> <no location info>:
12:06:24 <geekosaur> yes.
12:06:29 <ril> `ghci -i $PWD`
12:06:30 <geekosaur> why are you using -i
12:06:35 <ril> didn't you just..?
12:06:43 <geekosaur> "-i by itself clears the list, ..."
12:06:54 <geekosaur> "default should be -i."
12:07:01 <geekosaur> that is -i followed by a dot
12:07:43 <geekosaur> suppose I should have used more quoting, it is a bit ambiguous :/
12:07:46 <ril> as I was about to say, -i. has no effect, and -i $PWD throws
12:07:59 <ril> target ‘/Users/ril/lyah’ is not a module name or a source file
12:08:00 <geekosaur> no space there
12:08:03 <geekosaur> -i$PWD
12:08:28 <ril> still <no location info>
12:08:32 <geekosaur> with a space it looks like bare "-i" (clear search path) followded by an attempt to use $PWD as a source file
12:08:47 <geekosaur> what version of ghc is this? (ghc --version)
12:08:55 <ril> 7.8,4
12:09:02 <ril> *7.8.4
12:09:31 <geekosaur> hm, I have 7.8.3. I can't claim that 7.8.4 didn't break it somehow :/
12:12:03 <geekosaur> oh, now I wonder if it only works if the current module imports it. that would still be a bug in my book...
12:12:14 <geekosaur> (would also agree with what you were seeing earlier)
12:12:23 <ReinH> @hackage monad-loops contains whenM and a bunch of other useful combinators, jle` kyclark
12:12:24 <lambdabot> http://hackage.haskell.org/package/monad-loops contains whenM and a bunch of other useful combinators, jle` kyclark
12:13:03 <jle`> neat lambdabot feature
12:13:09 <jle`> @where lpaste is where you can paste things
12:13:09 <lambdabot> http://lpaste.net/
12:13:18 <ril> no space after a flag seems strangely un-unixy to me, fwiw
12:13:27 <ril> not that you make the decisions
12:13:29 <jle`> oh i's only on @hackage because it's basically just a ("...package"++)
12:13:34 <hannes__> ril: not unheard of, though it does seem weird
12:13:41 <geekosaur> actually it's very unixy. it's not POSIXy
12:13:48 <ril> pardon me.
12:13:58 <geekosaur> there was approximately no consistency in how options worked before POSIX :)
12:14:01 <bezirg> hi, I want to have an array with values of my customm datatype. The array package only supports Storable's?
12:14:04 <geekosaur> (see for example tar short options)
12:14:37 <hannes__> tar xyzzy please-work.tar.garzarp
12:14:48 <bezirg> if I cannot use the array package what other structure can I use to have o(1) indexing?
12:14:59 <hannes__> bezirg: vector?
12:15:07 <ReinH> bezirg: Array supports any data type
12:15:33 <hannes__> ReinH: He didn't say it was because of a datatype mismatch
12:15:42 <ReinH> hannes__: Yes they did.
12:15:59 <ril> I started using unices in 2001, so I have no memory of a time before posix
12:16:02 <ReinH> hannes__: "The array package only supports Storable's?"
12:16:04 <hannes__> ReinH: o right.
12:16:26 <ReinH> bezirg: Only Data.Array.Storable has a Storable constraint, not the whole package.
12:16:37 <bezirg> ok thx
12:16:39 <bezirg> now I understand
12:17:02 <hannes__> depending on what you want vector still might be better thougg
12:17:08 <geekosaur> you can see remnants of the old days all around: tar and ar short options, grep's -e (obviated by POSIX's "--"), ...
12:17:44 <Clint> wait, how is -e obviated by --
12:17:52 <hannes__> at least nobody uses slashes for options
12:18:34 <ril> you know what would be stupid and awesome? a type safe replacement for posix/bash
12:18:49 <hodapp> ril: see Shelly and Turtle.
12:18:55 <hannes__> ril: isn't powershell sort of typesafe?
12:19:03 <hodapp> powershell is sort of something.
12:19:24 <voidzero> what does that mean?
12:19:33 <ril> ooh, thanks for that!
12:19:43 <hodapp> voidzero: what?
12:20:02 <voidzero> what do you mean with sort of something? <g>
12:20:19 <hodapp> ril: and some of us were talking about reviving something lighter and more portable, like Hugs, to repurpose to a Haskell interpreter suitable for scripting
12:20:20 <hannes__> although I still don't get how much you get from a typed shell, considering half of the time you're just piping one untyped output into another untyped input
12:20:34 <voidzero> i can read it as 'sort of weird' or as 'sort of useful'
12:20:45 <hodapp> voidzero: precisely.
12:21:05 <voidzero> good. i'm glad we sorted it out.
12:21:34 <voidzero> grin
12:22:45 <clrnd> http://lpaste.net/121187 <-- wtf cabal
12:22:49 <ril> ls and ps, for instance, produce fairly structured output that would be amenable to typing
12:24:10 <ril> wc could report a number with a unit instead of a dimensionless integer implicitly dependent on the parameters it was called with
12:24:12 <ril> that sort of thing
12:24:54 <int-e> clrnd: that looks like you have transformers-0.4.2 installed and are now trying to install lambdabot on top. that's not possible because the ghc package relies on transformers-0.3.
12:25:11 <int-e> clrnd: and lambdabot indirectly depends on the ghc package.
12:25:33 <ril> this would be a particularly good fit for a rust-based green field fantasy land
12:26:08 <clrnd> int-e, okay, let me uninstall transfomers-4 which I tried because of a previous error
12:27:23 <clrnd> int-e, ther eit is, the original error: http://lpaste.net/121190
12:28:21 <tdammers> crap, think I need to use something other than Data.Scientific
12:28:32 <tdammers> turns out dividing by 3 is not a great idea with Scientific
12:28:43 <aawe> say I have a large scene tree and I update every node and leaf during a logic pass - does haskell make a copy of the whole tree for each change, or does it see that I do not keep the interrmediate trees and optimize them away?
12:29:11 <ReinH> voidzero: sort of sorted it out
12:29:25 <ReinH> It's a strange phrase, "sort of", when you think about it
12:29:44 <int-e> clrnd: in any case as I wrote in the announcement, cabal-install has trouble resolving lambdabot's dependencies. this still seems to work on a pristine ghc-7.8.3 installation (hmm, I just realized I don't have any ghc 7.8.4 anywhere): cabal install lambdabot-haskell-plugins lambdabot
12:29:45 <voidzero> sort/type/kind of
12:29:55 <ReinH> voidzero: type doesn't work though
12:30:08 <ReinH> "I'm kind of a big deal." "I'm type of a big deal."
12:30:17 <clrnd> int-e, what announcement? sorry, I don't follow lambdabot's development closely
12:30:18 <voidzero> yeah you're kinda/typa right
12:30:34 <int-e> clrnd: on haskell-cafe
12:31:38 <voidzero> in dutch the word 'sort' is more akin to 'kind', and we don't have a word for 'kind'
12:31:51 <tdammers> voidzero: "aard"
12:31:53 <tdammers> vOv
12:31:59 <voidzero> 'nature'
12:32:04 <jfischoff> is there a haskell package that will tell the location of a given executable like `which foo` does?
12:32:04 <ReinH> voidzero: In type theory, sort is the type of kinds :)
12:32:07 <voidzero> but maybe. I'll consider it :P
12:32:16 <jfischoff> err function in a package I mean
12:32:41 <voidzero> so any kind of type is a sort of kind?
12:33:04 <voidzero> or, sort of a kind? i'm confusing myself now.
12:33:24 <waltermundt> Quick question: what's the easiest way to determine the current day of the week (relative to local time)?  I've been reading the docs for Data.Time.* and not getting very far.
12:33:26 <lpaste> kyclark revised “IO a -> a”: “No title” at http://lpaste.net/121189
12:33:28 <ReinH> voidzero: In Haskell, we have types of different kinds. In other type theories, there are also different classes of kind.
12:33:43 <clrnd> int-e, I'm trying intalling haskell-plugins first, if it doesn't work I'll try on ghc-7.8.3, thanks
12:33:54 <int-e> clrnd: note that if the last line of cabal's error is "Backjump limit reached (change with --max-backjumps)." then this does not mean that there is no valid install plan; it means that the dependency solver didn't manage to find one in the allotted amount of backtracking.
12:34:38 <clrnd> int-e, I tried with absurd max-backjump numbers, it didn't work :P
12:35:05 <int-e> clrnd: (however, lifting the backjump limit didn't help me; I ended up killing cabal-install after 15 minutes)
12:35:11 <int-e> clrnd: yeah
12:35:20 <voidzero> ReinH, if Haskell had support for kind classes, would that mean that there would be more than for example (* -> *) i.e. 'star to star'?
12:35:52 <waltermundt> oh, I see now.  get local time, run localDay, then use calendar functions on the Day value.
12:37:14 <scott> jle`: this made the analogy between Applicative and Monoid really clear: https://wiki.haskell.org/Typeclassopedia#Alternative_formulation
12:37:15 <jle`> kyclark: "not" works on a Bool
12:37:23 <voidzero> waltermundt, or, maybe, get the seconds-since-epoch and convert to a timezone?
12:37:24 <aawe> does haskell avoid creating intermediate lists/trees when multiple transformations are chained on them?
12:37:27 <jle`> kyclark: and you have an IO Bool
12:37:31 <scott> jle`: they call it Monoidal, so I guess you could make something like that for Apply called Semigroupal :)
12:37:33 <jle`> kyclark: so you can use fmap
12:37:47 <int-e> clrnd: oh, this also finds an install plan:  cabal install lambdabot --constraint transformers\ installed
12:37:55 <jle`> kyclark: fmap not (doesFileExist "Setup.hs"), or the infix alias, not <$> doesFileExist "Setup.hs"
12:38:13 <jle`> scott: yes :)
12:38:30 <hannes__> aawe: I think that's a 'sometimes'. I'm pretty sure it can do that, but it's probably not too difficult to construct cases where it can't
12:38:38 <clrnd> int-e, --contraint without a version number, weird! gonna try that too (my pc is kinda slow, still building haskell-plugins)
12:38:57 <aawe> hannes__: do you know where I can read more about it?
12:39:04 <int-e> clrnd: the "installed" is part of the constraint, note the \ before the space
12:39:21 <waltermundt> voidzero: a timezone?  Not sure what you mean.  Seconds-since-epoch is nice, but AFAIK all the functions for dealing with times of day and calendars want Data.Time.LocalTime LocalTime values, or parts thereof
12:39:36 <clrnd> int-e, oh I though it was you signaling the end of the command, it was scaping a space lol
12:39:54 <hannes__> aawe: ghc source code I guess. I don't know if the optimizations are described in great detail in prose anywhere.
12:40:19 <ReinH> aawe: Yes, sometimes, via rewrite rules and a process known as list fusion https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
12:40:35 <ReinH> aawe: (GHC does, rather. Haskell the language doesn't specify.)
12:40:48 <aawe> ReinH: you know if list fusion applies to trees too?
12:40:48 <voidzero> waltermundt, ok. I'm not even certain if what I said makes sense - I was thinking of the TZ environment variable that is useful on the shell. If I want to know the current local time of any timezone, on the shell I issue for example `TZ=Europe/Amsterdam date`
12:40:57 <ReinH> aawe: List fusion applies to lists :)
12:41:18 <aawe> ReinH: sure, but a tree looks kind of like a list if you squint your eyes
12:41:33 <ReinH> aawe: If the implementation of the tree includes rewrite rules, GHC will attempt to apply them.
12:43:29 <hannes__> now I'm wondering if ghc will always rewrite `fmap f . fmap g . fmap h` to `fmap (f.g.h)`
12:43:35 <ReinH> scott, jle`: edwardk turned me on to the closed functor interpretation of Applicative recently and I really like it.
12:43:39 <waltermundt> voidzero: Okay, I think the functions I've found will take that into account: _ _ dayOfWeek <- (toWeekDate . localDay . T.zonedTimeToLocalTime) `fmap` T.getZonedTime
12:44:20 <voidzero> ah, yes. Nice :)
12:45:17 <voidzero> tdammers, translating 'kind' to 'aard' makes me curious; i am going to read about kinds again while keeping that in mind :)
12:45:30 <waltermundt> just took me awhile to string together the right accessors and converters
12:46:19 <voidzero> yeah for me that's always the hard part
12:47:09 <nerium> I'm trying to do something like this in Haskell
12:47:09 <nerium> https://gist.github.com/oleander/df51e1f5bf8bd8a6077b
12:47:31 <waltermundt> voidzero: actually, minor correction: (_, _, dayOfWeek) <- (toWeekDate . T.localDay . T.zonedTimeToLocalTime) `fmap` T.getZonedTime
12:47:33 <nerium> I want to run the "ask" function until the name is "Haskell" and then use it on the line below
12:47:38 <nerium> Is that possible?
12:47:46 <waltermundt> where dayOfWeek comes from Data.Time.Calendar.WeekDate
12:47:59 <Hijiri> nerium: It's possible
12:48:38 <nerium> Hijiri: How?
12:48:44 <Hijiri> the simplest solution would be using a recursive helper function
12:49:35 <Hijiri> loop name | name == "Haskell" = return () | otherwise = putStrLn ("Your name is" ++ name) >> ask "What is your name?" >>= loop
12:49:39 <Hijiri> or something like that
12:50:10 <Hijiri> there might be some combinators in monad-loops that match this use case if you want to check that out
12:50:28 <Hijiri> and then main = ask "What is your name?" >>= loop
12:52:33 <nerium> Hijiri: I'm not sure which one to use https://hackage.haskell.org/package/monad-loops-0.3.0.2/docs/Control-Monad-Loops.html :)
12:52:55 <Hijiri> nerium: I don't know either, I haven't checked
12:53:38 <Darwin226> Is there a way, perhaps an extension, that would let me write 'f a b _ c d' (f :: a -> b -> c -> d -> e -> f) which would produce a new function of the type c -> f?
12:54:14 <Darwin226> Basically, sintax sugar for \x -> f a b x c d
12:55:02 <hannes__> Darwin226: That seems oddly specific and not terribly useful to me
12:55:12 <Hijiri> nerium: iterateUntilM looks promising
12:55:23 <ReinH> Darwin226: no.
12:55:46 <Darwin226> hannes__: Really? I ran into it all the time.
12:55:53 <Darwin226> run*
12:56:28 <nerium> Hijiri: I looked at that one, but I*m not sure how to use it
12:56:35 <nerium> Any ideas?
12:57:03 <Hijiri> well we can look at what the function takes
12:57:17 <Hijiri> the first is a predicate, a -> Bool
12:57:26 <Hijiri> what do you think you would use for that?
12:58:15 <Hijiri> what is the condition you are checking
12:58:16 <nerium> Hijiri: How about this? iterateUntilM (\age -> age == "10") ask "What is your age?"
12:58:21 <hannes__> Darwin226: That seems somewhat worrying. But even then, it doesn't seem very useful. You'd save a handful of characters every now and again. Why make the language more complicated for that/
12:58:26 <napping> Darwin226: there's not really any good way to do that
12:59:03 <napping> You can get that effect either with some combinators or macros, but both are not usually shorter than a macro
12:59:07 <napping> than a lambda, I mean
12:59:19 <Hijiri> nerium: That wouldn't quite do what you want
12:59:28 <nerium> Hijiri: Hehe, okay
12:59:39 <Hijiri> you put ask for the second argument
12:59:49 <Hijiri> That would take the result of asking and use that as a quesiton
13:00:02 <Hijiri> So if I entered "9", the next thing it would do is ask "9"
13:00:04 <ReinH> nerium: iterateUntil (== "10") (ask "What is your age?") might work depending on what `ask' is.
13:00:51 <Hijiri> If you want to print out the age you will need iterateUntilM though
13:01:04 <ReinH> e.g., ask q = pustStrLn q >> getLine
13:01:13 <ReinH> Hijiri: there is no iterateUntilM
13:01:18 <ReinH> And I don't believe that you do
13:01:32 <Hijiri> ReinH: are you looking in monad-loops?
13:01:34 <ReinH> iterateUntil executes the action
13:02:03 <ReinH> Ah, I was looking at an older version.
13:02:12 <ReinH> iterateUntilM is still not what is needed as far as I can tell
13:02:52 <nerium> Hijiri: Yay, that works :) Thanks
13:03:00 <Hijiri> what works?
13:03:06 <nerium> Hijiri: What you posted
13:03:12 <nerium> Using iterateUntil
13:03:20 <Hijiri> ReinH posted that
13:03:33 <nerium> Aha, sorry
13:03:36 <ReinH> :)
13:03:49 <nerium> ReinH: Then thanks to you
13:03:53 <ReinH> nerium: yw
13:04:08 <Hijiri> ReinH: do you mean that iterateUntilM isn't needed for the age example or the name example?
13:04:29 <ReinH> The age example.
13:05:13 <ReinH> nerium: it would be instructive to try to write your own iterateUntil
13:06:26 <Hijiri> ReinH: I didn't say enough, when I meant printing the age out, I meant only printing it out if it doesn't satisfy the condition, like with the name example
13:06:31 <nerium> ReinH: It would be easy to do it if monads aren't included, but they are which makes everything a bit harder
13:06:42 <ReinH> nerium: That's why you should do it :)
13:06:57 <ReinH> Hijiri: Ah.
13:06:58 <nerium> ReinH: Does it use >>= in some way?
13:07:04 <nerium> or foldr?
13:07:24 <ReinH> >>=
13:10:36 <ReinH> Most things involving monads use >>= ;)
13:12:12 <jle`> (>>= __ =<<)
13:13:16 <joneshf-laptop> I find myself manually interspersing a bunch of `tell "\n"` in RWS is there something I'm missing here?
13:13:32 <joneshf-laptop> something that will just automatically put the `tell "\n"` in?
13:13:34 <cariveri> Hi. does anyone know of a receiving POST data in a warp server?
13:13:59 <dmj`> cariveri: can you restate your question
13:14:13 <jle`> joneshf-laptop: if you are always going to just be telling whole lines, you can just tell [String]
13:14:31 <jle`> and then at the end, unlines the result
13:15:14 <carter_cloud> whats the trick for doing show to render TH quote asts in GHCi?
13:15:16 <joneshf-laptop> jle`, does that mean i'd have to wrap all my tells in lists?
13:15:18 <carter_cloud> i always forget it
13:15:45 <jle`> yes, or if that bugs you, you can define your own custom tell
13:15:45 <ReinH> jle`: yes, or write yourself a little function to do that
13:15:58 <jle`> tell' = tell . (:[])
13:16:24 <jle`> i wonder if there's a "tells", analogous to "gets"/"asks"
13:16:26 <ReinH> apprise = tell . return
13:17:21 <joneshf-laptop> jle`, `censor`?
13:18:18 <jle`> :t center (:[]) . tell $ "hello"
13:18:19 <lambdabot>     Not in scope: ‘center’
13:18:20 <lambdabot>     Perhaps you meant one of these:
13:18:20 <lambdabot>       ‘censor’ (imported from Control.Monad.Writer),
13:18:27 <jle`> :t censor (:[]) . tell $ "hello"
13:18:28 <lambdabot>     Couldn't match type ‘[Char]’ with ‘Char’
13:18:28 <lambdabot>     Expected type: [Char] -> [Char]
13:18:28 <lambdabot>       Actual type: [Char] -> [[Char]]
13:18:30 <cariveri> dmj`: does someone knows the (haskell based) warp server in here? :)
13:18:35 <jle`> nah that doesn't work
13:18:43 <jle`> it has to be a w -> w
13:19:26 <jle`> gets f = f <$> get,   asks f = f <$> ask,    tells f = tell . f
13:19:32 <jle`> it's like a contravariant version heh
13:21:39 <joneshf-laptop> :t censor
13:21:40 <lambdabot> MonadWriter w m => (w -> w) -> m a -> m a
13:21:53 <dmj`> cariveri: if you're interested in how to handle POST data, I'd look at using the wai package
13:22:20 <jle`> joneshf-laptop: censor has to keep the same w type; gets, asks, tells can all change the parameter
13:22:46 <joneshf-laptop> :t listen
13:22:47 <lambdabot> MonadWriter w m => m a -> m (a, w)
13:22:57 <joneshf-laptop> :t listens
13:22:58 <lambdabot> MonadWriter w m => (w -> b) -> m a -> m (a, b)
13:23:00 <joneshf-laptop> ?
13:23:38 <chaosmasttter> carter_cloud: runQ?
13:23:49 <int-e> carter_cloud: runQ [| 1 + 1 |]  in ghci, with many variations
13:24:04 <joneshf-laptop> nah, guess not
13:24:12 <joneshf-laptop> weird, wonder why that doesn't exist
13:24:21 * hackagebot hlint 1.9.17 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.17 (NeilMitchell)
13:24:37 <joneshf-laptop> :t censor (++ "\n")
13:24:38 <lambdabot> MonadWriter [Char] m => m a -> m a
13:24:43 <joneshf-laptop> that prtty much works for me
13:25:02 <jle`> yeah you can do that too, and write your own custom "tellLn"
13:25:06 <joneshf-laptop> though not really
13:25:21 <joneshf-laptop> w/e, just wanted to see if i was missing something simple :)
13:26:46 <int-e> carter_cloud: and for debugging outside of ghci, qRunIO is your friend: $(do exp <- [| 1 + 1 |]; qRunIO $ print exp; return exp)
13:26:55 <exio4> is there any function like (dropPrefix "abc" "abcde" -> "de") or similar?
13:27:22 <jle`> how do i get rid of Prelude on cabal repl
13:27:59 <Hijiri> exio4: what happens in the case that the prefix doesn't match?
13:28:40 <exio4> Hijiri: I don't really care, that should never happen anyway
13:28:56 <Hijiri> exio4: drop . length
13:29:14 <int-e> jle`: :set -XNoImplicitPrelude followed by :m -Prelude  seems to do the trick
13:29:20 <jle`> int-e: thanks :)
13:29:26 <exio4> wow, that was silly, thanks Hijiri
13:29:30 <int-e> jle`: I'd consider using  cabal exec ghci -whateveroptions  instead
13:29:38 <HeladoDeBrownie> does th make any termination guarantees?
13:29:41 <jle`> oh, is there a practical difference?
13:29:48 <socumbersome> Hi. What does "(Int -> Int)" mean in: data D = B (Int -> Int)  ?
13:30:02 <int-e> jle`: you get to provide ghci flags
13:30:08 <Hijiri> socumbersome: Int -> Int is the type of function from Ints to Ints
13:30:10 <kadoban> socumbersome: It's the type of a function from an Int to an Int
13:30:13 <hannes__> socumbersome: same thing it does anywhere else, function from Int to Int
13:30:14 <jle`> is cabal exec ghci the same as cabal repl?
13:30:16 <Hijiri> socumbersome: -> is an infix type constructor
13:30:22 <HeladoDeBrownie> socumbersome, B is a constructor of D that can store functions of type Int -> Int.
13:30:25 <Hijiri> If you did it prefix, it would look like (->) Int Int
13:30:35 <Hijiri> so like Either Int Int
13:31:13 <HeladoDeBrownie> socumbersome, in other words, that definition introduces B :: (Int -> Int) -> D
13:31:26 <int-e> jle`: It depends on whether you're inside a package directory or not.
13:31:26 <jle`> int-e: cabal exec ghci -XNoImplicitPrelude doesn't seem to be working here, it says it's not a recognized flag
13:31:50 <hannes__> jle`: -- -XNoImplicitPrelude?
13:32:12 <jle`> oh hey that works
13:32:14 <jle`> thanks :)
13:32:19 <hexagoxel> .. or --ghc-options="-XNowhatever"
13:32:49 <int-e> jle`: oh, yeah, you need some -- in there. sorry, what I *actually* tend to do is  cabal exec bash  and then enjoy my new shell. It's just too bad one can't use cabal-install inside of that shell.
13:33:10 <jle`> cabal exec bash sounds delightful :P
13:33:25 <Hijiri> I think I prefer cabal exec zsh
13:33:30 <ReinH> @quote fugue
13:33:31 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
13:33:34 <HeladoDeBrownie> `cabal exec bash` sounds like cabal is throwing a party.
13:33:34 <ReinH> Every time! :D
13:33:39 <int-e> Hijiri: I should've written $SHELL, sorry.
13:33:40 <hannes__> cabal exec cmd.exe ahaha
13:34:18 <HeladoDeBrownie> hannes__, that could even float some people's boats
13:34:25 <mrmagneto> noob here: if I have a list of strings and want to access each element and perform an action on them, what steps should i take?
13:34:35 <HeladoDeBrownie> mrmagneto, what is an "action" in this context?
13:34:36 <int-e> Hijiri: (And I know that some of the best bash features have been stolen from zsh.)
13:34:59 <mrmagneto> I would like to perform drop 7 on each element of the list of strings
13:35:06 <HeladoDeBrownie> mrmagneto: map (drop 7)
13:35:13 <hannes__> mrmagneto: map
13:35:14 <hannes__> :t map
13:35:15 <lambdabot> (a -> b) -> [a] -> [b]
13:35:27 <mrmagneto> map (drop 7) (myListOfStrings) ?
13:35:34 <hannes__> mrmagneto: don
13:35:42 <HeladoDeBrownie> mrmagneto, yep. although the second pair of parens is unnecessary.
13:35:43 <hannes__> 't need the second set of parantheses there, but yes
13:36:07 <mrmagneto> thank you all very much, that makes sense
13:43:12 <mrmagneto> I think this is another map usage that im missing, but I have a list of strings and want to plug each of those strings in to a function that takes a string as input
13:43:54 <mrmagneto> can i map each string from a list to input to the input of a function that requires a string ?
13:45:31 <moghedrin> mrmagneto: map func ["Hello", "World"]?
13:45:36 <josephle> what do you expect as the output of this?
13:45:46 <josephle> a list of results from applying that function to each string?
13:46:15 <mrmagneto> yes, a list of strings
13:47:05 <josephle> > map reverse ["hello", "world"]
13:47:07 <lambdabot>  ["olleh","dlrow"]
13:47:13 <josephle> ^ something like this?
13:56:06 <mrmagneto> @josephle thank you, that worked
13:56:06 <lambdabot> Unknown command, try @list
13:59:24 * hackagebot cassandra-cql 0.5.0.0 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.5.0.0 (kayceesrk)
14:01:41 <ahammel> Anybody know of a bounded asynch queue with a fire-and-forget mode?
14:02:17 <mrmagneto> How can i count the number of lists in a list of lists?
14:02:17 <ahammel> i.e., if they queue is at capacity, throw the message away instead of blocking
14:02:59 <ahammel> > length [[1, 2], [3, 4]]
14:03:01 <lambdabot>  2
14:05:36 <mrmagneto> perfect, adding to that: i did length myList and then intToDigit (length myList) to get the char of that int, and then [(intToDigit (length myList)] to turn it into a one digit string. this worked, but is there a more proper way to do it. I did all of that in order to add that string to a string
14:06:51 <moghedrin> mrmagneto: What's the input you have, and what is the output you want?
14:07:04 <rasen> > let a = show (length [1,2,3]) in print a
14:07:05 <lambdabot>  <IO ()>
14:07:21 <rasen> show (length [1,2,3])
14:07:29 <rasen> argh
14:07:38 <rasen> > show (length [1,2,3])
14:07:39 <lambdabot>  "3"
14:08:21 <worldsayshi> Quick sandbox question: If i init a sandbox in foo/.cabal-sandbox and then go to my project in foo/examples/bar and run cabal install ‘—dependencies-only’ - will the dependencies then end up in the sandbox?
14:08:45 <mrmagneto> my input is a list of strings, my output i want is a string so that i can concatenate it to another string
14:08:58 <mrmagneto> show works, but it puts ' around my output?
14:09:18 <worldsayshi> Uh, the ‘ chars above where a bit misplaced.
14:10:46 <barrucadu> > show (length [[1,2],[3,4]]) ++ " - is the number of things in my list"
14:10:48 <lambdabot>  "2 - is the number of things in my list"
14:10:50 <barrucadu> Like that?
14:11:07 <hexagoxel> worldsayshi: quick answer: nope. (unless you do some shared-sandbox-magic). cabal looks for a sandbox only in current directory
14:11:46 <mrmagneto> thank you barrucadu
14:11:49 <worldsayshi> hexagoxel: Thanks. I think python sandboxes or some other work in that manner so I expected that :/
14:12:11 <worldsayshi> hexagoxel: I might be wrong
14:18:41 <bezirg> can anyone help me with this? I tried to fix this type error for hours now. When I used the MonadIO, I have type error. When I change it to Monad it typechecks fine:   http://lpaste.net/121198
14:19:28 * hackagebot highlight-versions 0.1.3.5 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.3.5 (BrentYorgey)
14:20:54 <Cale> bezirg: No instance for (Control.Monad.IO.Class.MonadIO ((->) Int))
14:21:06 <Cale> You're making use of the instance of Monad for functions there.
14:21:08 <bezirg> Cale: y I have this
14:22:06 <Cale> bezirg: Well, the left hand argument to =<< must be a function
14:22:28 <hpc> bezirg: write main in do-notation
14:22:35 <hpc> bezirg: then do a naive translation to (>>=)
14:22:45 <Cale> In this case, because the result of do_y (4 :: Int)  is Int, it must be a function taking an Int argument
14:23:00 <Cale> So f =<< do x (3 :: Int) must be a function that accepts an Int argument
14:23:11 <bezirg> hpc: >>= works, I tried that. But because this is generated code, I would like it to have it in =<< form
14:23:16 <Cale> oops, do_x of course
14:23:24 <Cale> So do_x (3 :: Int) must be a function which takes an Int argument
14:23:35 <emaczen> Is anyone here using emacs for their haskell environment?
14:24:04 <hpc> bezirg: perhaps you want to use Applicative, then?
14:24:09 <Cale> and in particular, there's no instance of MonadIO which would allow that
14:24:10 <emaczen> my question would be about completion
14:24:23 <hpc> f <$> do_x <*> do_y
14:24:26 <hpc> er
14:24:28 * hackagebot cassandra-cql 0.5.0.1 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.5.0.1 (kayceesrk)
14:24:30 <bezirg> hpc: i will try that
14:24:34 <hpc> f <$> do_x (3 :: Int) <*> do_y (4 :: Int)
14:24:49 <Cale> bezirg: There's no difference between (>>=) and (=<<) except the order of the arguments
14:25:00 <Cale> bezirg: So if you're generating code, it shouldn't matter :P
14:25:07 <bezirg> Cale: u r right
14:25:10 <hpc> the order of arguments with (=<<) can make it awkward to deal with the lambdas
14:25:26 <bezirg> y i just realized that
14:25:48 <bezirg> thank you ppl
14:35:18 <Lokathor> Control.Monad has when and unless, which allow conditional execution of monadic expressions using Bool. Is there a similar sort of standard function using Maybe instead of Bool?
14:35:30 <untseac> Hey
14:36:14 <jle`> Lokathor: how do you mean?
14:36:19 <quchen> Lokathor: when (isJust x)?
14:36:44 <jle`> :t F.mapM_ `asAppliedTo` Nothing
14:36:45 <tdammers> :t maybe
14:36:45 <lambdabot>     Couldn't match expected type ‘a -> m b’ with actual type ‘Maybe a0’
14:36:45 <lambdabot>     In the second argument of ‘asAppliedTo’, namely ‘Nothing’
14:36:45 <lambdabot>     In the expression: F.mapM_ `asAppliedTo` Nothing
14:36:46 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:36:53 <jle`> :t F.forM_ `asAppliedTo` Nothing
14:36:54 <lambdabot> Monad m => Maybe a -> (a -> m b) -> m ()
14:36:56 <untseac> How do I know what '%s' means when I run ':set prompt' in ghci?
14:37:02 <Lokathor> oh, right, isJust
14:37:23 <jle`> with mapM and forM you can have a (a -> m b) run based on a  `Maybe a`
14:37:36 <jle`> but yeah you can also use isJust, if that was what you wanted in the first place
14:38:00 <Lokathor> jle`, I make a call out to C which returns a Maybe Window, and when there's no window returned i want to print an error and exit.
14:38:12 <jle`> and if there is a window returned, then what?
14:38:30 <Lokathor> then the whole rest of the program
14:38:48 <jle`> yeah, you can use mapM with a (Window -> IO ()) on a (Maybe Window)
14:38:48 <Lokathor> so i don't quite want to indent it an extra level inside a case statement
14:39:07 <jle`> so if it's a Nothing, the function is skipped entirely
14:39:14 <joneshf-laptop> I've got an AST: `data Foo = Foo String | Bar [Foo]` I want to use RWS `type FooEnv  = RWS Foo String Number` to evaluate it. when I get to a `Bar` I use `for foos \foo -> local (const foo) eval`. However, this doesn't actuallychange the state overall state after each invocation. Is there something that does this?
14:39:14 <jle`> if it's a Just window, then the function is run with 'window' in scope
14:39:20 <Lokathor> hmmm
14:39:25 <jle`> this doesn't let you error, tho
14:39:30 <joneshf-laptop> I want a more monadic `for`, if that makes any sense
14:39:42 <geekosaur> untseac, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-commands.html
14:40:04 <joneshf-laptop> or maybe I just need a different way to evaluate things?
14:40:08 <jle`> you could possibly use flip (maybe (error "goodbye!")) maybeWindowMaker $ \window -> ....
14:40:12 <Lokathor> jle`, thanks, I'll think about that structure later, but for now isJust seems to be what I want
14:40:14 <ReinH> joneshf-laptop: what is the type of the thing you want?
14:40:35 <untseac> geekosaur, thanks
14:40:41 <jle`> Lokathor: the problem with when isJust for what you want is that you are either just deferring a case statement, or a "fromJust"
14:40:43 <ReinH> joneshf-laptop: or do you just mean mapM/forM?
14:40:44 <jle`> ;)
14:40:55 <joneshf-laptop> ReinH, I think it should still be the same type as `for`
14:41:05 <ReinH> joneshf-laptop: If it's the same type as for then it can't do what you want.
14:41:15 <jle`> what type thing are you looking for, joneshf-laptop ?
14:41:25 <Lokathor> jle`, true. Though, in this case I'm also attempting to produce the haskell version of a C example, so starting with a version that looks "the most like" the C example is best I think
14:41:28 <ReinH> joneshf-laptop: fmap can't modify the context at all
14:41:37 <ReinH> In fact, that's one of the laws of fmap
14:42:04 <ReinH> Oh, wait, for isn't flip fmap, is it
14:42:09 <ReinH> for is flip traverse
14:42:13 <ReinH> Disregard.
14:42:15 <joneshf-laptop> yeah
14:42:25 <jle`> Lokathor: ok then.  but the version with forM vs. the version with when isJust + fromJust is pretty much the same, except the when version is less ensured-to-be-safe-by-compiler
14:42:30 <ReinH> for is strangely named
14:42:51 <ReinH> joneshf-laptop: what do you want to do that for can't do?
14:43:05 <jle`> it's not much different to implement, if that's your worry
14:43:14 <jle`> forM maybeWindow $ \window -> do ...
14:43:15 <jle`> vs.
14:43:26 <jle`> when (isJust maybeWondw) $ let window = fromJust maybeWindow in ....
14:43:27 <joneshf-laptop> ReinH, I want the state changes to persist across each "iteration" of `for`
14:43:48 <ReinH> joneshf-laptop: traverse already does that though
14:43:51 <joneshf-laptop> ReinH, rather than it using the state outside of the `for`
14:44:10 <joneshf-laptop> ReinH, it does?
14:44:38 <jle`> yes, that's the whole point of the Applicative instance :)
14:45:07 <Lokathor> jle`, actually how I have it is more like: unless (isJust maybeWindow) do{<print error and close>}
14:45:14 <Lokathor> but yes
14:45:16 <jle`> > flip runState 10 $ liftA2 (,) (modify (+1)) (modify (*2))
14:45:18 <lambdabot>  (((),()),22)
14:45:24 <jle`> Lokathor: but you're going to fromJust eventually, right?
14:45:28 <mmachenry> Are there any libraries that will do scheduling for me? I have a concurrent TCP server and I added about 5-6 threads that do things every few minutes. Basically a scheduler. I figure there might be a library that does this for me but I haven't found anything.
14:46:06 <Lokathor> yeah but on the next line :P
14:46:06 <jle`> > flip runState 10 $ T.sequenceA [modify (+3), get, modify (*4), modify (^2)]
14:46:08 <lambdabot>  No instance for (GHC.Num.Num ()) arising from the literal ‘10’
14:46:21 <jle`> > flip runState 10 $ T.sequenceA [modify (+3), modify (*4), modify (^2)]
14:46:23 <lambdabot>  ([(),(),()],2704)
14:46:41 <Lokathor> when converting among languages i prefer to start by making the version that's line-by-line as close as possible, and then switching to the idioms of the target language
14:46:57 <jle`> Lokathor: ah if you need to actually "do" things then you might just want a case statement there in the end
14:47:00 <jle`> Lokathor: and yeah, fair enough :)
14:47:17 <ReinH> joneshf-laptop: Maybe I'm confused about what you want. Do you have an example?
14:47:19 <jle`> good to be disciplined
14:52:47 <mrmagneto> How can I sum the head element of a list of lists of ints?
14:53:12 <ReinH> mrmagneto: what do you want to do when one of the lists is empty?
14:53:18 <mrmagneto> for example: I want [[1,2],[3,4]] to equal 4
14:53:43 <mrmagneto> one of the lists will never be empty, that is checked for prior
14:53:49 <moghedrin> > sum (map length [[1,2], [3,4]])
14:53:51 <lambdabot>  4
14:54:16 <moghedrin> Oh XD
14:54:21 <moghedrin> Maybe I should read what you want, lol
14:54:31 <ReinH> That's one way to get 4
14:54:42 <mrmagneto> ill try that, thank you!
14:54:45 <ReinH> so is const 4
14:54:47 <moghedrin> Don't do that!
14:54:48 <ReinH> mrmagneto: That doesn't do what you want
14:54:54 <moghedrin> Lololol
14:55:08 <exio4> mrmagneto: you probably want sum . map head, not sum . map length
14:55:16 <moghedrin> ^
14:55:18 <exio4> (sum . map head)
14:55:26 * moghedrin slinks away to the shadows
14:57:42 <mrmagneto> Haha not a problem, I am ashamed that i just tried it before noticing it did something completely different
14:58:26 <glguy> Instead of checking first and then using head you can combine the checks together with the head operation
14:58:47 <glguy>  traverse listToMaybe :: [[a]] -> Maybe [a]
14:59:03 <glguy> now in the case that you have a Just (_ :: [Int]) you can use sum
14:59:15 <ReinH> One safe way to do it would be
14:59:28 <ReinH> > sum . map (foldr const 0) $ [[1,2],[3,4]]
14:59:30 <lambdabot>  4
14:59:33 <ReinH> > sum . map (foldr const 0) $ [[1,2],[3,4],[]]
14:59:34 <lambdabot>  4
14:59:55 <glguy> sumOf (folded._head) :: [[Int]] -> Int
15:00:03 <ReinH> glguy: nice
15:00:37 <mrmagneto> My problem is that my list isnt actually ints, it is a list of strings, so my input looks like [["4","13"],["3","10"]]
15:00:43 <KaneTW> Is haskell.org down right now?
15:01:20 <mrmagneto> can i convert those strings into ints and then use one of the above methods to sum the heads?
15:01:56 <ReinH> What do you want to do if one of the strings isn't formatted as an integer?
15:02:28 <mrmagneto> they all are, there is another function that adds them to that list in that format and does the error checking
15:02:40 <glguy> :t fmap sum . traverse (Text.Read.readMaybe <=< listToMaybe)
15:02:42 <lambdabot> (Read b, Num b) => [[String]] -> Maybe b
15:03:20 <ReinH> mrmagneto: Why does another function check that they are integers but not add them *as* integers?
15:03:30 <ReinH> or Int, or w/e
15:04:08 <ReinH> (that they are *strings formatted as integers*)
15:04:08 <joneshf-laptop> ReinH, http://lpaste.net/121202
15:05:18 <ReinH> joneshf-laptop: what am I looking at, specifically?
15:05:28 <joneshf-laptop> ReinH, the output
15:05:51 <ReinH> joneshf-laptop: what does that have to do with summing a list?
15:06:25 <joneshf-laptop> ReinH, I'm not sure what you mean
15:06:31 <ReinH> That makes two of us.
15:06:37 <ReinH> Oh. Sorry.
15:06:41 <ReinH> joneshf-laptop: What am I looking at?
15:06:47 <ReinH> joneshf-laptop: Oh I remember now.
15:07:11 <SrPx> Hey guys, is there any non-recursive, elegant way to get the half of a natural number on the Lambda Calculus, using church encodings?
15:07:28 <joneshf-laptop> ReinH, oh, wait I think i see the problem
15:08:27 <ReinH> joneshf-laptop: you never update the state
15:08:36 <ReinH> you only gets (+1)
15:08:59 <ReinH> The state is always 0
15:09:31 * hackagebot fltkhs 0.1.0.1 - FLTK bindings  http://hackage.haskell.org/package/fltkhs-0.1.0.1 (deech)
15:09:47 <mrmagneto> trying to break down my problem now, can someone explain how to fix this? sum (map (head [[1,2],[3,4]]))
15:10:04 <ReinH> mrmagneto: We said (sum . map head)
15:10:08 <mrmagneto> output of 4 expected
15:10:16 <ReinH> mrmagneto: Use the definition of (.) to see how that is different from what you wrote
15:10:18 <ReinH> @src (.)
15:10:19 <lambdabot> (f . g) x = f (g x)
15:10:33 <glguy> map (head list) isn't the same as   map head list
15:10:40 <napping> One thing is that map needs two arguments
15:10:55 <ReinH> napping: ahem...
15:14:59 <jle`> > map head [[1,2],[4,5]]
15:15:01 <lambdabot>  [1,4]
15:15:05 <jle`> > sum (map head [[1,2],[4,5]])
15:15:07 <lambdabot>  5
15:15:34 <jle`> mrmagneto: btw i do second the suggestion that the function that adds them to the list and does the error checking actaully add Int, instead of strings
15:17:08 <ReinH> Separating verification from use just creates an opportunity for bugs
15:17:30 <ReinH> In fact, this is an incredibly common source of bugs
15:18:42 <ReinH> It's known as TOCTOU http://en.wikipedia.org/wiki/Time_of_check_to_time_of_use
15:19:17 <ReinH> Or perhaps this is a more general form. Anyway, it's bad.
15:19:22 <hpc> oh hey, it has a name
15:21:32 <EvanR> its also annoying because a lot of things you are paranoid about being a TOCTOU source of problems arent for some reason, and the reason is hard to understand
15:21:41 <Lokathor> the loop-while package has exactly what I want, but seems to be totally ancient in terms of dependencies :/
15:21:55 <EvanR> in any case there would be no way to convince your manage of one way or the other
15:21:59 <EvanR> manager
15:22:15 <EvanR> Lokathor: monad-loops?
15:22:28 <hpc> and being too tight can lead to performance trouble, like if something's at the boundary of inside vs outside a loop
15:23:27 <Lokathor> EvanR, wow, lots of options here... i guess one of these is bound to be like a do-while loop
15:24:37 <fsldn> :t pure (+) <*> 1 <*> 2
15:24:38 <lambdabot> (Applicative f, Num (f b), Num b) => f b
15:24:38 * hackagebot bet 0.1.2.1 - Betfair API bindings. Bet on sports on betting exchanges.  http://hackage.haskell.org/package/bet-0.1.2.1 (Adeon)
15:24:44 <fsldn> > pure (+) <*> 1 <*> 2
15:24:45 <lambdabot>  No instance for (GHC.Show.Show (f0 b0))
15:24:45 <lambdabot>    arising from a use of ‘M57799225751409226315565.show_M57799225751409226315...
15:24:45 <lambdabot>  The type variables ‘f0’, ‘b0’ are ambiguous
15:24:51 <ReinH> Lokathor: You probably want something from monad-loops
15:24:51 <Lokathor> untilM_ seems to be the ticket
15:25:02 <fsldn> how can i extract the value of an applicative?
15:25:07 <EvanR> Lokathor: whileM ?
15:25:10 <ReinH> fsldn: You can't.
15:25:19 <napping> depends on the applicative
15:25:27 <Lokathor> EvanR, whileM checks before the loop, untilM checks after the loop
15:25:28 <ReinH> fsldn: For some type constructors (that are instances of Applicative), you can.
15:25:35 <fsldn> ReinH: can i somehow get the value of the expression above?
15:25:40 <EvanR> Lokathor: yeah, pick your poison ;)
15:25:43 <fsldn> :t pure (+) <*> 1 <*> 2
15:25:43 <lambdabot> (Applicative f, Num (f b), Num b) => f b
15:25:48 <fsldn> ^
15:25:48 <ReinH> fsldn: That is the value of the expression.
15:26:06 <ReinH> There is no other value to get.
15:26:13 <napping> fsldn: the type says you can pick your applicative, so if you want a single value you can use Identity
15:26:13 <fsldn> ReinH: thats the type
15:26:18 <fsldn> i want to get the value
15:26:29 <ReinH> That expression is the value.
15:26:32 <ReinH> There is no other value.
15:26:34 <napping> fsldn: it's a value too, the way you have it
15:26:47 <fsldn> wat
15:26:49 <napping> It's still polymorphic like that
15:26:49 <ReinH> That expression doesn't "contain" some other value that you can "extract".
15:27:00 <napping> like, sum is already a value
15:27:10 <ReinH> That expression is also almost certainly not what you want anyway.
15:27:26 <ReinH> Since it requires an instance Num (f b)
15:27:29 <napping> Oh, yeah, I didn't see the numbers
15:27:32 <napping> That's a funny type
15:27:37 <fsldn> wat
15:27:42 <fsldn> :t pure (+) <*> 1 <*> 2
15:27:43 <lambdabot> (Applicative f, Num (f b), Num b) => f b
15:27:58 <fsldn> 2 is instance of Num right?
15:28:02 <ReinH> Yes.
15:28:10 <napping> But <*> wants some applicative around it
15:28:18 <napping> :t pure (+) <*> pure 1 <*> pure 2
15:28:18 <ReinH> That expression has the constraint Num (f b)
15:28:19 <lambdabot> (Applicative f, Num b) => f b
15:28:45 <napping> and that's equivalent by rules of Applicative to pure 3
15:29:00 <fsldn> > pure 2
15:29:02 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
15:29:02 <lambdabot>    arising from a use of ‘M658086852161953603915644.show_M6580868521619536039...
15:29:02 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
15:29:45 <fsldn> ReinH: that means f is a constructor that takes a type b ?
15:29:58 <napping> > pure 2 :: Identity Int
15:30:00 <lambdabot>  Identity {runIdentity = 2}
15:30:01 <ReinH> fsldn: It means f is a consturctor that takes a type b, and f b must be an instance of Num
15:30:21 <fsldn> oh
15:30:41 <fsldn> whats Identity?
15:30:57 <fsldn> > (pure (+) <*> 1 <*> 2) :: Identity Int
15:30:59 <ReinH> The type says, for all types f and b, where f is an instance of Applicative and b is a instance of Num and f b is also an instance of Num...
15:30:59 <lambdabot>  No instance for (GHC.Num.Num
15:30:59 <lambdabot>                     (Data.Functor.Identity.Identity GHC.Types.Int))
15:30:59 <lambdabot>    arising from the literal ‘1’
15:31:01 <napping> a specific type that's an instance of Identity and stuff
15:31:09 <ReinH> And, in point of fact, there is no such instance.
15:31:25 <napping> instance of Applicative, rather
15:31:32 <fsldn> :t pure 2
15:31:33 <lambdabot> (Applicative f, Num a) => f a
15:31:39 <fsldn> :t pure (+) <*> 1 <*> 2
15:31:40 <lambdabot> (Applicative f, Num (f b), Num b) => f b
15:32:04 <ReinH> :t (<*>)
15:32:05 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:32:10 <napping> newtype Identity a = Identity {runIdentity :: a}
15:32:25 <Lokathor> does a do block normally have to be inside ( ) when you pass it to a function?
15:32:38 <napping> something like (pure 1) is still polymorphic, so it's evaluated as far as you can get without picking specific types to use
15:32:53 <fsldn> so
15:33:05 <ReinH> fsldn: The only reason this even typechecks is that numbers literals in Haskell are polymorphic
15:33:11 <fsldn> can Identity be used to get the value of the expression?
15:33:47 <napping> If it's polymorphic there are lots of ways to try to use it, but Identity is one of the more straightforward
15:34:15 <fsldn> ReinH: (+) is the instance of Applicative ((->) a) right
15:34:25 <fsldn> and pure for ((->) a) is defined as const
15:34:36 <napping> Like, what's "the value" of
15:34:37 <Lokathor> "Perhaps you meant one of... " should be a feature in every compiler
15:34:39 <napping> :t 1 + 255
15:34:40 <lambdabot> Num a => a
15:34:44 <napping> is it
15:34:47 <napping> > 1 + 255 :: Int
15:34:48 <lambdabot>  256
15:34:56 <napping> > 1 + 255 :: Double
15:34:58 <lambdabot>  256.0
15:35:01 <napping> > 1 + 255 :: Word8
15:35:01 <ReinH> fsldn: No
15:35:02 <lambdabot>  0
15:35:05 <ReinH> fsldn: Not at all.
15:35:05 <napping> ?
15:35:15 <fsldn> ReinH: which part is no?
15:35:23 <ReinH> pure (+) does not imply that f is ((->) a)
15:35:36 <ReinH> :t pure (+)
15:35:38 <lambdabot> (Applicative f, Num a) => f (a -> a -> a)
15:35:42 <ReinH> it implies that a is an instance of Num
15:35:43 <fsldn> oh right ReinH
15:35:57 <fsldn> ok isee what i was missing
15:36:04 <ReinH> fsldn: Again, pure (+) <*> 1 <*> 2 is not what you want
15:36:18 <ReinH> Again, it only typechecks because number literals are polymorphic
15:36:18 <fsldn> ReinH: that is what i want cause im just messing around with it
15:36:31 <ReinH> If you did pure f <*> 'a' <*> 'b', you would have a type error
15:36:34 <fsldn> ReinH: wouldnt it typecheck if it was Int as well?
15:36:47 <fsldn> if I had a function on Ints rather than Nums?
15:36:49 <napping> :t pure (+) <*> (1 :: Int) <*> (2 :: Int)
15:36:51 <lambdabot>     Couldn't match expected type ‘f b’ with actual type ‘Int’
15:36:51 <lambdabot>     In the second argument of ‘(<*>)’, namely ‘(1 :: Int)’
15:36:51 <lambdabot>     In the first argument of ‘(<*>)’, namely ‘pure (+) <*> (1 :: Int)’
15:37:01 <ReinH> No.
15:37:05 <napping> :t pure ((+) :: Int -> Int -> Int) <*> 1 <*> 2
15:37:05 <fsldn> oh right
15:37:06 <lambdabot> (Applicative f, Num (f Int)) => f Int
15:37:08 <ReinH> Int cannot unify with f b for any f or b
15:37:15 <fsldn> cause Int is not an instance of Applicative right?
15:37:55 <ReinH> There is no type constructor f which, combined with another type, yields Int
15:38:04 <ReinH> s/combined with/applied to
15:38:08 <fsldn> :t pure (+) <*> pure 1 <*> pure 2
15:38:08 <lambdabot> (Applicative f, Num b) => f b
15:38:36 <napping> To do anything with pure (+) <*> 1 <*> 2 you'd have to define something crazy like instance Num [Int]
15:38:55 <fsldn> okay i see
15:38:59 <ReinH> napping: really?
15:39:12 <napping> Yeah
15:39:15 <ReinH> f and b are universally quantified
15:39:32 <napping> Because you're using that "1" directly with <*> it knows the literal "1" has a type like f a for some Applicative f
15:39:50 <napping> but also because it's a number literal, whatever type the whole thing has is an instance of Num
15:40:00 <fsldn> haskell is hard
15:40:02 <ReinH> Never mind.
15:40:17 <ReinH> The quantification is on the outside
15:40:28 <napping> So anything that meets both of those is going to be pretty strange
15:40:58 <fsldn> haskell has the most helpful community out of any programming language I've used
15:41:04 <napping> The main thing going on here is that numeric literals are polymorphic
15:41:47 <napping> and rather than deciding to give you an error like "Numbers are not applicative!" it spits out some constraints meaning "Well, if you *really* wanted to declare something to be both a number and an applicative container I suppose I could make sense of this"
15:42:11 <napping> not that all Applicatives are containers exactly
15:42:23 <ReinH> Which is what got us into this mess in the first place.
15:43:25 <Lokathor> forgot a semicolon in haskell for the first time, yay
15:44:13 <fsldn> so to 'extract' something from an applicative, in general you need a function for that type to extract it?
15:44:36 <platz> looks like someone borked up the wai results on the techempower bench preview that just came out.. 2 seconds latency for json deserializtion is not right
15:45:12 <napping> Yeah, the applicative class doesn't have any general way to get values out
15:49:32 <ReinH> fsldn: That question has a different answer for every instance of Applicative. It doesn't make sense to talk about "extracting something from an Applicative" in general.
15:49:45 <fsldn> right ReinH
15:50:11 <ReinH> Some typeclasses do have a notion of "extracting", for example Comonad include extract :: Comonad w => w a -> a
15:50:26 <fsldn> ah
15:54:36 <ReinH> In general, if a type constructor f (of kind * -> *) has a function of type f a -> a, we can call it an f-algebra. We could define a typeclass class Algebra f where alg :: f a -> a
15:54:55 <ReinH> It could have instances like instance Algebra Identity where alg (Identity a) = a
15:55:12 <ReinH> fsldn: And there are, in fact, some very useful things that you can do with f-algebras https://www.fpcomplete.com/user/bartosz/understanding-algebras
15:55:44 <fsldn> thanks ill check it out
15:56:44 <ReinH> (More precisely, I should say that f equipped with its corresponding function f a -> a are an f-algebra)
15:58:05 <shachaf> I think you mean a type a, not f.
15:58:32 <ReinH> shachaf: Oh, I do.
15:58:48 <ReinH> a is the carrier
15:58:58 <ReinH> shachaf: thanks
16:00:01 <shachaf> But given such a function, it's obvious what its type is, so I think it's fine to call it an f-algebra.
16:00:02 <Lokathor> jle`, you can see my completed program using the isJust thing here if you like: https://github.com/Lokathor/gl-tutorial/blob/master/src/Tutorial01.hs
16:01:25 <ReinH> Lokathor: :(
16:01:35 <ReinH> Lokathor: Instead of isJust and fromJust, use a case statement
16:01:50 <ReinH> That maintains the invariant for you
16:03:00 <Lokathor> I'm puzzled. Could you give an example of the invariant not being maintained using this format?
16:03:16 <ReinH> Lokathor: The point is that you have to maintain the invariant manually and keep it in your brain
16:03:25 <ReinH> Haskell has a type system in part so it can keep track of that stuff for you
16:03:29 <ReinH> So not using it is a shame
16:03:57 <ReinH> There's no point in having to check every time you edit that file that you haven't caused a runtime exception
16:04:03 <ReinH> When the type system can completely prevent it for you
16:04:06 <fsldn> ReinH: what does 'invariant' mean?
16:04:22 <Lokathor> well, normally yes, but in this case if you get Nothing the program exits right there.
16:04:36 <ReinH> fsldn: In this case, it means that "when the window is Nothing then these things should happen, and when the window is Just something then these other things should happen, and these things should be mutually exclusive."
16:04:38 <bitemyapp> fsldn: can't vary
16:05:01 <ReinH> Lokathor: Yes, but there's no guarantee that this will happen except for you, the programmer, checking that it is so
16:05:04 <bitemyapp> fsldn: mid-14c. (transitive); late 14c. (intransitive), from Old French variier "be changed, go astray; change, alter, transform" and directly from Latin variare "change, alter, make different," from varius "varied, different, spotted;"
16:05:10 <ReinH> Why not let the language do this for you *perfectly* instead?
16:05:24 <fsldn> bitemyapp: i know that
16:05:33 <Lokathor> in this case, the major reason to not do that is, "this is closer to how the original example was structured"
16:05:35 <ReinH> This is one of the main reasons *for* using Haskell
16:05:46 <fsldn> bitemyapp: i mean what does 'maintains the invariant' mean
16:05:59 <ReinH> Ok, then since we can show that the two are operationally equivalent, you can go ahead and make the change.
16:06:02 <Lokathor> fsldn, means that my assumptions can't be violated
16:06:13 <bitemyapp> fsldn: bake something as an invariant into the type and attempts to violate it will be a type error at compile-time rather than something you could slip in at runtime.
16:06:13 <fsldn> okay i see
16:06:34 <fsldn> bitemyapp: can you give an example?
16:06:46 <bitemyapp> data Person = Person String Int
16:06:52 <bitemyapp> Person takes a String and Int argument
16:07:03 <bitemyapp> those are relatively weak, but still invariant declarations about what data is permissible.
16:07:19 <fsldn> okay i see
16:07:20 <bitemyapp> I cannot construct (Person 10 "blah"), wrong order. Invariant violation, gets caught at compile-time.
16:07:30 <bitemyapp> you can get more expressive and detailed about it than that, but that's the gist of the core idea.
16:08:10 <ReinH> Lokathor: Anyway, this is a textbook example of when you should let the type system enforce your invariants for you
16:08:23 <mrmagneto> How can I take a list and attach an incremented number to the start of each element in said list. For example ["this","is", "my", "list"] would be become ["1 this", "2 is", "3 my", "4 list"]. I think I could use an infinite list of numbers starting at 1 i.e. [1..] and add(map?) this to each element in the other list?
16:08:26 <ReinH> That's literally why the Maybe type exists
16:08:34 <ReinH> So your use of Maybe here is subverting it
16:08:34 <Lokathor> fsldn, another simple example is that as you sort a list using insertion sort, the part of the list lower than your insertion point is the "already sorted" segment.
16:09:00 <ReinH> It's also an example of boolean blindness
16:09:37 <Lokathor> I forget exactly what boolean blindness is
16:09:47 <bitemyapp> > zipWith (\x y -> show y ++ " " ++ x) ["this", "is", "my", "list"] [1..]
16:09:48 <Lokathor> isn't that where a boolean isn't enough useful info about the situation?
16:09:48 <lambdabot>  ["1 this","2 is","3 my","4 list"]
16:09:49 <bitemyapp> mrmagneto: ^^
16:09:57 <bitemyapp> @ty zipWith
16:09:58 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
16:10:00 <bitemyapp> @ty show
16:10:01 <lambdabot> Show a => a -> String
16:10:02 <bitemyapp> @ty (++)
16:10:03 <lambdabot> [a] -> [a] -> [a]
16:10:15 <ReinH> Lokathor: you have a type, Maybe Window, which contains exactly the information you need. You throw that type away and instead use Bool.
16:11:24 <Lokathor> I suppose
16:11:26 <mrmagneto> thanks all
16:11:29 <ReinH> A case scrutiny of Maybe Window is exactly the right way to use the information contained in the type.
16:11:40 <bitemyapp> mrmagneto: cheers
16:11:48 <Lokathor> It would indent the rest of the program an extra level, but i will adjust the file
16:12:35 <ReinH> You could also extract the two branches into their own values and write `maybe die continue maybeWindow'
16:13:08 <Lokathor> i'm not familiar with what you just wrote at all
16:13:09 <ReinH> which very concisely expresses what you want to happen when the window exists or does not exist
16:13:27 <ReinH> :t maybe
16:13:28 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:13:40 <Lokathor> oh, the ` and ' weren't intended to be significant
16:13:41 <Lokathor> alright
16:13:56 <ReinH> Yeah, no
16:14:07 <ReinH> where continue :: Window -> IO () or whatever
16:14:38 <Lokathor> well, i do need it inside of the maybe for makeCurrentContext
16:15:04 <ReinH> Lokathor: At that point, you can just wrap it up with Just again
16:15:29 <ReinH> Also btw you don't actually need the {} or ; for that do block.
16:15:38 <ReinH> You can have do blocks inside parens just using layout
16:17:01 <lpaste> Lokathor pasted “case-form” at http://lpaste.net/121206
16:17:27 <Lokathor> parens are enough for do: handy to know
16:17:49 <ReinH> Lokathor: ahhhh
16:18:12 <Lokathor> did i... get it wrong again?
16:18:19 <ReinH> That was a sigh of relief :)
16:18:35 <Lokathor> i think it looks much worse myself
16:18:56 <ReinH> Lokathor: Nah, much better.
16:19:18 <ReinH> Oh btw if you use SPJ style it's harder to miss semicolons http://lpaste.net/580861032197521408
16:19:37 <ReinH> (I just don't use braces)
16:20:13 <Lokathor> SPJ can "as if by magic" all he wants but i'm not sure that "semicolin first" will ever catch on that much :P
16:20:20 <ReinH> :)
16:20:36 <ReinH> Well, I prefer it to semicolon last, but I prefer no semicolons to bth
16:20:41 <glguy> delimiters first is fairly standard in Haskell
16:20:51 <jle`> Lokatho: the invariants we are talking about here versus algorithmic invariants like insertion sort is that the compiler can't prove your sort invariant, but it can prove things like w/ case and Maybe :)
16:20:52 <ReinH> *both
16:21:12 <jle`> your trust in your invariants doesn't come from your own cleverness or the cleverness of the algorithm
16:21:20 <jle`> it is enforced by the compiler itself
16:21:42 <ReinH> Also it's not a bad thing for a branch in your program to be represented by a branch in your code ;)
16:22:00 <Lokathor> hmm, perhaps it is a background issue of sorts then
16:22:17 <Lokathor> never having had much of a compiler to be trusted, i've never thought to put so much trust in the compiler
16:22:18 <jle`> your "everything past this point is a Just" can be enforced by your own logic and your own assurances.... or it can be enforced by the compiler
16:22:24 <ReinH> Lokathor: Well, now you have one :)
16:22:49 <Lokathor> hmm
16:22:52 <ReinH> The ability to offload some of the things I would normally have to keep in my brain onto the compiler is one of my favorite things about Haskell
16:23:03 <jle`> in Haskell we can rely on the compiler to prove a lot of our programs without relying on our own shaky algorithmic or in-your-head logical proofs
16:23:19 <ReinH> This lets you keep more of the important stuff in your brain
16:23:24 <ReinH> The stuff the compiler *can't* do for you
16:23:26 <jle`> yes this is probably like one of my favorite parts too
16:23:30 <ReinH> like the actually interesting parts of your program
16:23:34 <jle`> it also does loads for maintainability
16:23:54 <jle`> if you come back a few months later, your intricate genius understanding of your code might go away
16:24:03 <ReinH> "months"
16:24:22 <jle`> but in Haskell, you don't need to really remember anything
16:24:42 * jle` is slightly exaggerating
16:24:51 <ReinH> I have trouble days later.
16:24:52 <bitemyapp> ReinH: yeah the time unit should be more polymorphic.
16:24:59 <jle`> (but only slightly :) )
16:25:03 <bitemyapp> parameterize over the fourth dimension
16:25:09 <jle`> I gave a specific instance
16:25:41 <jle`> my statement might have been more general had it been parameterized yes :)
16:26:19 <Lokathor> in other languages, you would normally check for bad inputs and return or exeption "early", and then the rest of your operation can take place in the clear
16:26:32 <Lokathor> though that does have to be set up by hand, which is always troublesome to maintain
16:27:32 <bitemyapp> ReinH: may I submit a vocab query?
16:27:34 <Lokathor> sometimes i have to pass data through several stages that might fail with IO in between some of the steps, and i've yet to master the monad transformer arts
16:27:38 <ReinH> bitemyapp: ok
16:27:46 <bitemyapp> ReinH: okay, there's skolem/rigid, but that's something else
16:28:06 <bitemyapp> ReinH: do I want parametrically polymorphic or some other term for polymorphic type variables not constrained by a typeclass?
16:28:26 <bitemyapp> and how do you prefer to refer to those that are constrained by a typeclass?
16:28:28 <ReinH> bitemyapp: parametrically polymorphic, as opposed to ad hoc polymorphic, iirc
16:28:35 <bitemyapp> yeah, that's how we'd been doing it.
16:28:39 <ReinH> At least, that's the terminology that the typeclasses paper used
16:28:42 <bitemyapp> somebody objected to ad-hoc for the constrained ones, so we were mixing it up.
16:28:50 <bitemyapp> ReinH: coolio. Thanks :)
16:28:51 <ReinH> The authors of the paper didn't object :p
16:29:02 <bitemyapp> ReinH: I'll use that reference next time somebody does.
16:29:03 <ReinH> You could use "less ad-hoc" ;)
16:29:05 <bitemyapp> and add it to my footnotes.
16:29:20 <ReinH> I wonder if "constrained polymorphism" would work.
16:29:20 <mrmagneto> how can I compare the first elements in a list of strings? I want to perform a function if they arent equivalent. For example, ["abc","agg"] checks out but ["abc","bbb"] calls notSameFirst
16:29:52 <bitemyapp> ReinH: that's what we used in addition to ad-hoc
16:30:01 <bitemyapp> ReinH: we were calling it ad-hoc or constrained polymorphism.
16:30:07 <ReinH> bitemyapp: I haven't seen a better term
16:30:11 <bitemyapp> each are indicating a different component of what's true about it.
16:30:32 <bitemyapp> a type variable with a typeclass constraint is a set that has fewer valid inhabitants
16:30:39 <bitemyapp> so "constrained" fits at least from that point of view.
16:31:11 <Lokathor> mrmagneto, a [String] is a [[Char]], so start by keeping in mind that not all strings in the list will even have a first element
16:31:51 <S11001001> @where existential
16:31:51 <lambdabot> I know nothing about existential.
16:32:12 <Lokathor> same for us all lambdabot, same for us all
16:32:26 <Axman6> @where existance
16:32:26 <lambdabot> I know nothing about existance.
16:32:38 <mrmagneto> my list of strings is predetermined, so I know it will always be of the form ["abc"] or ["abc", "bcd"]
16:32:41 <mrmagneto> etc.
16:33:09 <Lokathor> well, all the first characters would be (map head myList) i guess
16:33:14 <hiptobecubic> @where anything
16:33:15 <lambdabot> I know nothing about anything.
16:33:29 <ReinH> bitemyapp: typeclass-constrained ad-hoc polymorphism is a bit of a mouthful
16:33:37 <ReinH> mouth full*
16:33:52 <Lokathor> not sure if there's a quick way to check if an entire list is the same... probably some sort of fold
16:34:02 <bitemyapp> "less polymorphic than the full monty, more polymorphic than Brand X"
16:35:00 <ReinH> mrmagneto: This sounds a lot like an XY Problem to me
16:36:10 <Lokathor> actually you can't fold the list of heads using (==) i guess, hmm
16:36:21 <mrmagneto> that created problem z for me because I had to look that up :/
16:38:42 <ReinH> mrmagneto: what are you doing with all of these lists of lists anyway?
16:39:40 <jle`> is there a big to having the tutorial to my library be a part of the haddock on hackage vs. hosted on Github or something? I mean with the haddock solution I get auto-generated links... and people can more easierly save local versions
16:39:41 <Lokathor> I think they wanted to see if every element in a [String] had the same starting Char or not.
16:40:05 <jle`> but I've already written the whole thing in markdown and translating it is going to be a huge pain even with pandoc
16:40:07 <jle`> ughhhh
16:40:30 <mrmagneto> im reading an input file into a list of strings using lines, and now i want to see if each of these strings starts with the same char (as lokathor just said)
16:40:47 <jle`> I can just insert my own links. but the getting a local copy on cabal install thing is probably the biggest benefit
16:40:58 <libc> is haskell well suited for DSP?
16:41:10 <Lokathor> jle`, so you already have it written using haddock? or you already have it written for github?
16:41:28 <libc> I'm interested in experimenting with DSP and it'd be a great excuse to learn haskell
16:41:30 <jle`> libc: I'd say yes, but for performance sensitive situations you probably won't beat a c loop
16:41:34 <libc> since DSP is very math-y
16:41:45 <jle`> but it definitely offers a very nice approach to DSP
16:41:55 <jle`> from a mathy perspective
16:42:01 <jle`> :)
16:42:07 <libc> jle`: yeah that would make it worth it for me
16:42:29 <jle`> it'll be much more readable, maintainable, safe, easier to write, less error prone
16:43:00 <jle`> I just mention the speed thing because in real world industry dsp speed tends to be a factor, but if it's just a learning project then I'd say go for it :)
16:43:13 <ReinH> mrmagneto: Ok, here's a hint:
16:43:18 <rasen> I've just started signal processing course at university.
16:43:21 <jle`> I'm actually writing what could be called a DSP library right now
16:43:35 <ReinH> :t \xs -> all (== head xs) (tail xs)
16:43:36 <lambdabot> Eq a => [a] -> Bool
16:43:40 <rasen> Haskell is soo easy to solve labs
16:43:42 <jle`> Lokatho: it's already written in markdown
16:44:29 <jle`> haskell makes it really easy to express the formalism in DSP at a high level and to go straight from the formalism to fast compiled code
16:44:39 <mrmagneto> thank you reinH
16:44:48 <libc> jle`: that makes sense.  I'd mostly be messing around and if I wanted to make anything performance critical I'd do it in C since I'd know what I was doing by then
16:44:51 <ReinH> jle`: Hard realtime constraints would be very hard to achieve, but for non-realtime or soft-realtime it'd probably be a good choice.
16:44:55 <jle`> so you can make reductions in Haskell code as if you were making reductions and simplifications in your signal model
16:45:17 <jle`> er, your dsp model
16:46:08 <jle`> mhm. dsp definitely has different peformance constraints based on the application domain
16:47:23 <rasen> Is that at all possible to achieve hard-realtime with GC?
16:47:23 <jle`> okay my solution is I will include the tutorial in markdown in the cabal package, and then put a link to a pretty html rendered one on Github in the docs.
16:47:41 <libc> jle`: I'm specifically interested in audio processing
16:48:06 <ReinH> rasen: with GHC's GC? No. With some sort of GC? Maybe.
16:48:10 <libc> taking an audio wave and doing things with it, i.e making a spectrogram
16:48:11 <ReinH> That's an active research area.
16:48:17 <jle`> that way people who have local copies and no Internet will be able to read the markdown and the html if they have a converter, and people online can read it fine
16:48:31 <jle`> libc: sounds like fun :D
16:48:45 <ReinH> rasen: here's a brief summary of some of it http://michaelrbernste.in/2013/06/03/real-time-garbage-collection-is-real.html
16:49:01 <jle`> be sure to blog about your learning journey, it's a Haskell rite of passage
16:49:03 <jle`> :)
16:49:08 <cdk> rasen: here's one that I know of: http://www.azulsystems.com/
16:49:10 <ReinH> And be sure to write at least one monad tutorial.
16:49:23 <jle`> no monad tutorials pls
16:49:23 <libc> jle`: I'll keep that in mind :)
16:49:34 <ReinH> jle`: Well they don't have to publish it ;)
16:49:36 <rasen> Thanks for links
16:49:40 <jle`> that's the one rule of haskell writing
16:49:53 <jle`> (1) you will not write a Monad tutorial
16:50:51 <bitemyapp> jle`: you skirted that.
16:50:57 <bitemyapp> jle`: you had me worried.
16:51:18 <hrumph> in yesod i'm having some form trouble..........sometimes i get a form through ajax but then the ids in the form can conflict with ids in existing forms so i'd like to do something about it
16:51:26 * EvanR registers monad tutorial.com 
16:51:32 <bitemyapp> ReinH: does Azul have hard real-time now or are they still soft?
16:51:35 <jle`> I wrote a tutorial on a specific style of interface that can be abstracted over with Monad
16:51:36 <EvanR> the monad tutorial to end all tutorials
16:51:41 <jle`> what's the big deal? :)
16:51:41 <ReinH> bitemyapp: Dont ask me :)
16:51:47 <Lokathor> I'll be sure to put that in my website. It'll say "Monad Tutoral" in the side bar, and if you click it the page will just say "No." in big text.
16:51:54 <ReinH> Lokathor: <3
16:51:55 <nshepperd> write a monad tutorial, meditate over it, then delete it
16:51:56 <EvanR> lol
16:51:58 <libc> pfft I'll write a generic badly written blog post that thinks it's way more edgy and original than it is /s
16:52:31 <EvanR> i finally get arrays
16:52:34 <jle`> nshepperd: like that sand art exercise, right?
16:53:11 <bitemyapp> EvanR: nope: http://i.imgur.com/MnDYfWa.png
16:53:31 <EvanR> what you bought it
16:53:40 <bitemyapp> EvanR: yes.
16:53:43 <jle`> someone should make a Burrito typeclass
16:53:43 <EvanR> hehe, when
16:53:46 <bitemyapp> just now.
16:53:51 <EvanR> figures
16:53:52 <nshepperd> heh, the sand mandala, yes
16:54:02 * EvanR registers typeclassmorphism.com 
16:54:05 <EvanR> ...
16:54:05 <jle`> then write a post "Burritos are like burritos"
16:54:10 <jle`> and they will be correct
16:54:29 <Lokathor> ReinH, https://sites.google.com/site/haskellguides/monads
16:54:41 <Cale> We need a new monad tutorial joke
16:54:44 <ReinH> hah
16:54:54 <EvanR> put it on bitemyapp's site
16:54:58 <Cale> I'm so tired of burritos and spacesuits
16:54:59 <ReinH> EvanR: Oh, you should give that to conal :)
16:55:23 <EvanR> i was waiting for that emote to cause conal to register it first
16:55:39 <EvanR> wasting peoples money today lol
16:55:42 <rasen> lol. https://wiki.haskell.org/Monad_tutorials_timeline
16:55:52 <bitemyapp> EvanR: I was thinking a big bold "Don't." in the middle of the page.
16:56:07 <bitemyapp> Lokathor: LOL
16:56:14 <ReinH> "Stahp"
16:56:24 <shachaf> Cale: It would be good if people stopped making those jokes.
16:56:26 <EvanR> bitemyapp: theres still plenty of people who dont know that its a joke, and so ...
16:56:28 <shachaf> No replacement necessary.
16:56:47 <bitemyapp> shachaf: it's okay, we can make jokes about existentially quantified type variables instead.
16:56:52 <EvanR> they dont find it funny
16:57:12 <bitemyapp> EvanR: I am accustomed to people not understanding my humor at this point.
16:57:15 <jle`> are we making jokes about jokes about jokes now
16:57:20 <bitemyapp> EvanR: maybe even a veteran.
16:57:26 <bitemyapp> I should get a pension.
16:57:27 <shachaf> bitemyapp: What?
16:57:51 <Cale> shachaf: heh, I'm not opposed to jokes, it's just that you're eventually flogging a dead horse
16:58:00 <bitemyapp> shachaf: ∃ j . j o k e
16:58:04 <Cale> You need fresh material every now and then
16:58:05 <shachaf> bitemyapp: I don't get it.
16:58:09 <ReinH> Cale: Well, first we killed the horse.
16:58:11 <Lokathor> "
16:58:12 <Lokathor> This is true because tortillas are indistinguishable."
16:58:14 <bitemyapp> shachaf: you won't get yer data back out either.
16:58:21 <Lokathor> oh no i pasted i the newline >_<
16:58:25 <shachaf> bitemyapp: Why do you keep talking to me about existential quantification?
16:58:39 <bitemyapp> shachaf: it's our secret
16:59:22 <EvanR> im very interested in why my sandboxed set of *functor dependencies are (almost?) identical yet incompatible
16:59:25 <jle`> I actually did appreciate the fishy monad tutorial
16:59:26 <shachaf> bitemyapp: The secret is that one time I told you that "forall" isn't an existential quantifier without elaborating, and ever since then you've been badgering me about it?
16:59:40 * glguy would probably also keep that a secret
16:59:48 <bitemyapp> higher ranked in that case, as I recall.
17:00:01 <ReinH> hah
17:00:07 <ReinH> "Let us never speak of this"
17:00:17 <shachaf> bitemyapp: At any rate, stop it.
17:00:55 <bitemyapp> shachaf: okie
17:01:32 <Cale> Note to self: get shachaf a T-shirt with a backwards E on it for his birthday
17:01:59 <jle`> why not just wear a shirt with a normal E on it backwards
17:02:09 <bitemyapp> our t-shirts will blot out the sun
17:02:13 <Lokathor> or a forwards E and then look in the mirror
17:02:26 <shachaf> Cale: Works for me.
17:02:32 <bitemyapp> Cale: https://twitter.com/hg_/status/570750198797897728
17:02:36 <Cale> Or what about an E-shirt with a backwards T?
17:03:08 <jle`> note to self: start a kickstarter on rubiks cube tshirts
17:03:15 <shachaf> Presumably a T-shirt with an ∃ would correspond to a ⊥-shirt with a ∀.
17:03:26 <Lokathor> Cale, your plan is the best so far
17:03:29 <ReinH> aha, ahahaha
17:03:30 <jle`> shirts that can be rotated around and reconfigured
17:03:36 <jle`> hahaha
17:03:45 <glguy> Oh, neat. I didn't realize the T in T-shirt was for Top
17:03:47 <jle`> .... at shachaf, not at myself
17:04:12 <glguy> If you wear your T-shirt while sleeping you'll have a turnstile shirt
17:04:14 <ReinH> glguy: I believe that ⊥-shirts are also known as "shorts".
17:04:35 <butyoudonot> ⊥-shorts
17:04:54 <jle`> it fits with the obvious partial ordering of clothing items
17:05:02 <jle`> everything is sense now
17:05:06 <bitemyapp> I want to wear t-shorts, but I think those are just t-shirts in Appalachian.
17:05:45 <Lokathor> I thought the T in t-shirt was because they're shaped like really a fat T
17:06:22 <mrmagneto> ^^ mind blown
17:06:40 * Clint squints.
17:07:55 <hiptobecubic> Lokathor, i did too. I'm shocked it's not!
17:27:33 <marcusbuffett> Hey guys, quick question. I have a function that calls 'runCommand', which has a return type of IO ProcessHandle, my function has a return value of IO (). Haskell complains about this, I could change my function's return value, but I was under the impression that IO () meant any value in the IO monad?
17:28:20 <shachaf> marcusbuffett: No, () is a particular type. () isn't the same as Int and IO () isn't the same as IO Int.
17:28:52 <rasen> You can append return () to your function or use void
17:28:54 <rasen> :t void
17:28:55 <lambdabot> Functor f => f a -> f ()
17:29:21 <marcusbuffett> Oh okay, so I just do void $ theRestOfMyFunction?
17:29:36 <rasen> yep
17:30:14 <S11001001> the laughs keep coming on scala-user http://comments.gmane.org/gmane.comp.lang.scala.user/74931
17:39:39 <houshuang> Is there an API or a programmatic way of finding which Hackage packages provide a certain module? Other than Google?
17:42:04 <Welkin> @hayoo
17:42:04 <lambdabot> Unknown command, try @list
17:42:16 <Welkin> houshuang: use hayoo to search for it and it will link you to hackage
17:47:58 <benzrf> marcusbuffett what are you doing
17:48:02 <benzrf> how are you learning haskell o_O
17:48:48 <jophish> I couldn't find this on hoogle, but does Either a a -> a exist?
17:49:17 <jle`> I don't think so jophish
17:49:35 <jle`> either id id is probably succinct enough for most purposes
17:50:14 <jophish> jle`: thanks
17:50:37 <jophish> what's the rule called, which prevents simple definitions like aliases for either id id from being put into libraries
17:50:44 <jophish> there's a nice term for it
17:51:10 <Fuuzetsu> feature creep?
17:51:49 <jophish> nah, something else
17:51:56 <shachaf> Maybe you're thinking of "Fairbairn threshold".
17:52:00 <Fuuzetsu> honestly ‘either id id’ is probably shorter than any reasonable name we could come up with that wouldn't have big namespace issues
17:52:28 <Fuuzetsu> https://mail.haskell.org/pipermail/libraries/2012-February/017548.html
17:52:59 <jophish> shachaf: bingo
17:52:59 <jophish> thanks!
17:53:07 <jophish> Fuuzetsu: that's exactly it!
17:55:22 <xnull> what role do monoids fulfill? i know they are sort of analogous with list concatenation (mconcat vs concat) to Functors with list mapping (fmap vs map) but i'm not sure i see a real example of where having the Monoid typeclass might be useful.
17:55:37 <Guest63233> If I type 'x = 5' into the REPL, why does the interpreter tell me: parse error on input `='
17:55:50 <shachaf> Because that's not how you use ghci.
17:55:54 <xnull> Guest63233: you can't assign things like that in ghci
17:55:56 <pacak> let x = 5
17:56:00 <shachaf> The documentation goes into full detail, but you can use "let x = 5" here.
17:56:14 <Guest63233> shachaf: thanks
17:56:25 <jle`> Guest63233: ghci is actually a different syntax than a haskell source foe; let x = 5 is what it wants, yeah
17:56:32 <jle`> s/foe/file
17:56:45 <xnull> i construct my programs with my foes
17:59:20 <Fuuzetsu> keep your files close but your foes even closer?
18:02:02 <jle`> ironically maybeToList has been generalized since that mailing list thread
18:02:06 <jle`> and is now in Prelude
18:05:28 <cfoch> hello
18:05:29 <cfoch> is there a frequently-updated Haskell Operative System?
18:05:58 <ReinH> cfoch: What is a "Haskell Operative System"?
18:06:28 <cfoch> i mean an Operative System written in Haskell
18:07:21 <jle`> hm...what's an operative system?
18:07:31 <jle`> the word is new to me and a google doesn't help too much :/
18:07:42 <ReinH> Do you mean an "Operating System"?
18:09:51 <cfoch> I've found House, but it looks like a bit old
18:10:09 <cfoch> operating system*
18:10:31 <Cale> I think maybe Galois has something but it's not open source?
18:10:46 <ReinH> I believe House is more of a kernel than an OS
18:11:03 <ReinH> Cale: something other than HaLVM?
18:11:09 <Cale> I don't know
18:11:19 <HeladoDeBrownie> xnull, the basic motivation is there are lots of things that look this way so why not give a name to them and talk about them as a whole? my favorite thing you can do with any monoid is indeed to mconcat it. i can have a list of instructions and i can turn it into a single instruction, or likewise with numbers, etc.
18:11:36 <Cale> Maybe it was just HaLVM which was being talked about.
18:11:53 <Hijiri> ReinH: Linux is a kernel and an OS!
18:12:13 <ReinH> In any event, I don't think there's any ongoing development on a Haskell OS
18:12:40 <Fuuzetsu> I'll write one when I find myself with copious amounts of free time
18:12:51 <Fuuzetsu> or have something more important to do
18:13:02 <yukko> Hijiri actually Linux is just a kernel, the operating system is called GNU/Linux
18:13:16 <xnull> HeladoDeBrownie: i just didnt exactly know what all fit into the class of monoids
18:13:16 <Hijiri> yukko: or as rms has recently taken to calling it, GNU + Linux
18:13:26 <Hijiri> or copious amounts of important things to do
18:13:26 <ReinH> Oh no.
18:13:34 <benbangert> has anyone ever tried to use http-client with a shared manager in a high concurrency and high performance environment?
18:14:01 <yukko> has he? i thought he just called it GNU/Linux, but GNU+Linux works fine too
18:14:16 <benbangert> I'm hitting a major memory usage issue if I don't use a global session, but a global session has a global lock it seems, so having multiple haskell threads use it doesn't increase concurrency
18:14:24 <HeladoDeBrownie> xnull, oh tons of stuff. pretty much any sort of string, like String (which is just a list, and lists form a monoid), Text, ByteString, as well as numbers (under addition or multiplication), booleans (under disjunction or conjunction), i even wrote a little edsl that's monoidal.
18:16:37 <ReinH> Bloom filters.
18:17:15 <ReinH> diagrams
18:20:09 * HeladoDeBrownie wonders if monoids form a monoid
18:20:20 <HeladoDeBrownie> something to do with monoid homomorphisms i'd guess
18:20:42 <HeladoDeBrownie> although that's a bit far afield of how Monoid is used in haskell :P
18:20:54 <byorgey> HeladoDeBrownie: monoids together with monoid homomorphisms form a category, which can be thought of as a generalized monoid
18:20:57 <byorgey> so you are not too far off =)
18:21:44 <HeladoDeBrownie> byorgey, we can't just arbitrarily compose monoid homo—oh of course, they have start and end monoids
18:21:56 <byorgey> right, exactly
18:23:03 <xnull> HeladoDeBrownie: wait, what do monoids offer in particular? is there a high-level way of thinking about monoids that just lets you say "monoids do x" like you can say "monads allow you to deal with state"
18:23:22 <xnull> i realize what they offer on a low level
18:23:47 <Fuuzetsu> they offer you a binary operation over all elements with certain property
18:23:56 <HeladoDeBrownie> xnull, are you looking for something for your intuition to hook into? or do you want something more technically correct?
18:24:03 <xnull> intuition!
18:24:05 <HeladoDeBrownie> xnull, "monads allow you to deal with state" is more the former, by the way
18:24:06 <jle`> xnull: perhaps you meant to say, one usage of monads is a way to manage state
18:24:07 <HeladoDeBrownie> okay
18:24:48 <jle`> monoids let abstract over concatenating things :D
18:24:51 <HeladoDeBrownie> well monoids let you combine two things of a certain kind into one of that kind
18:24:51 <xnull> jle`: yeah, just a particular thing it offers
18:24:58 <jle`> http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf is one nice paper
18:25:12 <HeladoDeBrownie> s/kind/type/ i should say, since "kind" means something else :P
18:25:22 <jle`> monoids let you concat things with the guarantee that it is associative
18:25:29 <xnull> or perhaps i'm looking for something like "monads are a subset of the things that are functors"
18:25:46 <HeladoDeBrownie> monoids are all semigroups
18:26:02 <xnull> more than one way of hooking my intuition into it i suppose
18:26:09 <ReinH> monoids are a subset of groups
18:26:16 <ReinH> or rather, the other way around
18:26:18 <HeladoDeBrownie> other way around, no?
18:26:18 <xnull> and groups are...
18:26:20 <HeladoDeBrownie> yeah
18:26:22 <jle`> concatenating things comes up a lot, actually
18:26:31 <jle`> xnull: how would you concatenate a bunch of "Map k a"'s?
18:26:47 <jle`> how would you concatenate a bunch of "a -> String"'s ?
18:26:48 <HeladoDeBrownie> xnull, groups are "invertible monoids". for any element there's an element that undoes it.
18:27:24 <jle`> it turns out that the meaningful behavior of "concatenating things" can be "isolated" in order to make statements about generalized concatenation
18:27:29 <HeladoDeBrownie> so, for example, integers under addition form a group, since there are negative integers that are the additive inverses of the positive
18:27:37 <HeladoDeBrownie> and 0, the identity element, is its own additive inverse
18:28:10 <jle`> if i gave you a list of Int's, how could you "concat" them all?
18:28:36 <ReinH> @google byorgey monoid pearl
18:28:56 <ReinH> xnull: http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
18:29:08 <jle`> i did just literally post that link a bit earlier :)
18:29:42 <xnull> jle`: addition or multiplication
18:29:42 <HeladoDeBrownie> and the author is conveniently in this channel too! :P
18:29:48 * hackagebot hs-re 0.1.0 - Easy to use Regex  http://hackage.haskell.org/package/hs-re-0.1.0 (SKAhack)
18:29:50 * hackagebot turtle 1.0.2 - Shell programming, Haskell-style  http://hackage.haskell.org/package/turtle-1.0.2 (GabrielGonzalez)
18:29:51 <xnull> or just concating the list
18:29:53 <Sonarpulse> Is there any way to get around cabal not matching x.y.z on *.z ?
18:29:54 <jle`> xnull: yes, you have two ways
18:30:01 <jle`> xnull: concating the list of ints?
18:30:09 <xnull> jle`: exponentiating
18:30:14 <xnull> jle`: no, not concating the list
18:30:16 <xnull> sorry
18:30:23 <xnull> no, no exponentiating
18:30:25 <jle`> [Int] -> Int
18:30:30 <HeladoDeBrownie> Sonarpulse, that seems like a misuse of * to me, can you give a bit more context?
18:30:39 <Sonarpulse> for data-files that is
18:30:50 <xnull> exponentiation doesn't have an identity value
18:31:00 <ReinH> jle`: you have more than two ways :)
18:31:00 <jle`> xnull: also it's not associative
18:31:05 <xnull> yeah, that too
18:31:14 <jle`> :)
18:31:34 <jle`> think about things like [a -> String] -> (a -> String)
18:31:38 <jle`> [Map k a] -> Map k a
18:31:45 <jle`> [Bool] -> Bool
18:31:54 <xnull> o... oh.
18:31:59 <jle`> you can isolate aspects of behaviors around meaningful implementations of these functions
18:32:02 <ReinH> jle`: [a -> String] -> a -> String ?
18:32:11 <ReinH> a -> a is a monoid, a -> b is not
18:32:18 <jle`> r u sure
18:32:20 <HeladoDeBrownie> not in general, but String is also a monoid
18:32:27 <xnull> jle`: is it only for lists though
18:32:36 <jle`> > mconcat [reverse, take 3, id, drop 2] "hello!"
18:32:37 <xnull> or is it for list-like things?
18:32:38 <lambdabot>  "!ollehhelhello!llo!"
18:32:47 <ReinH> Oh right, Monoid b => a -> b
18:33:02 <xnull> say could `Map k v' implement the typeclass Monoid?
18:33:04 <jle`> xnull: any sort of collection that you can <>/combine elements from
18:33:20 <jle`> xnull: yes, that's what we mean when we say [Map k v] -> Map k v
18:33:29 <jle`> mconcat :: Monad m => [m] -> m
18:33:34 <jle`> Map k v is the monoid here
18:33:45 <xnull> i thought [Map k v] was the monoid, sorry
18:33:48 <jle`> [a -> String] -> (a -> String)  ... (a -> String) is the Monoid here
18:33:57 <jle`> [Int] -> Int, Int is the monoid here
18:34:00 <xnull> do you mean Monoid
18:34:01 <xnull> oh
18:34:02 <xnull> yeah
18:34:15 <HeladoDeBrownie> turning a list of monoidal values into a single of those values is just an operation all monoids support
18:34:31 <xnull> yes, i see
18:34:38 <jle`> list is just incidental, you can collapse any ordered collection
18:36:02 <jle`> if you look for a common pattern between meaningful/useful implementations of these [m] -> m collapsing functions, you start to see that monoid laws unite all of them
18:36:12 <jle`> (i'm pulling a strong "no true scottsman" here, but you get the picture)
18:36:43 <ReinH> :t fold
18:36:44 <lambdabot> (Monoid m, Foldable t) => t m -> m
18:37:28 <mac10688> how can I run this in ghci?
18:37:28 <mac10688> capital :: String -> String
18:37:28 <mac10688> capital "" = "Empty string, whoops!"
18:37:28 <mac10688> capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]
18:37:43 <mac10688> after I type the first line it tells me capital is not in scope
18:38:03 <jle`> mac10688: you'd have to put it all on one line / use multiline
18:38:14 <HeladoDeBrownie> mac10688, i'd suggest putting it into a file and loading it.
18:38:15 <mac10688> oh ok
18:38:22 <jle`> let capital :: String -> String; capital "" = "Empty string!"; captal all@(x:xs) = ...
18:38:27 <jle`> but yeah putting it in a file is better :)
18:38:40 <xnull> i feel like ReinH's demonstration of fold's type is more helpful to me to think about
18:39:26 <mac10688> thanks :)
18:39:57 <cfoch> which is the official repo for Haddock?
18:42:56 <HeladoDeBrownie> cfoch, looks to be listed here http://hackage.haskell.org/package/haddock
18:48:00 <mac10688> what's the best way to write a bunch of test code in an editor and see the output?
18:48:24 <HeladoDeBrownie> mac10688, runhaskell CodeFile.hs
18:48:28 <mac10688> Right now I have to declare a lot of things and then at the end I have to spit it all out at once
18:48:33 <jle`> some people like to slime but i just have a ghci screen open and :r
18:48:44 <HeladoDeBrownie> mac10688, maybe i misunderstood, sorry; can you clarify what you've done?
18:48:50 <jle`> :l the file and play around and :r whenever you edit
18:49:30 <mac10688> I've just been doing this
18:49:31 <mac10688> https://gist.github.com/mac10688/060e597362e77759ab0f
18:49:44 <mac10688> but let me read through the responses I just got to see what you guys are talking about
18:50:23 <HeladoDeBrownie> yeah, if you have it in a file like that, and you just want to run main, runhaskell is good. if you want to examine the bindings in scope in that module and play around with them, do what jle` suggested
18:51:01 <mac10688> ohhh ok, yeah I think runhaskell might be what i'm looking for, let me test it
18:52:06 <orion> Is there a way to run a ByteString builder strictly as opposed to lazily?
19:07:21 <benbangert> I don't suppose anyone could verify a behavior in a haskell lib before I file a bug for it?
19:07:54 <HeladoDeBrownie> benbangert, say what it is, maybe someone will know
19:08:20 <benbangert> the wreq lib has the concept of a Session, using a session repeatedly is better than not for various resource reasons
19:08:38 <benbangert> wreq, under the hood, uses http-client, which has the concept of a Manager, a Manager has a pool of connections to every connKey (IP)
19:09:02 <benbangert> the http-client Manager can be shared between threads for concurrent use of the pool of TCP connections
19:09:53 <benbangert> the wreq Session however, add's an MVar for the CookieJar, and due to its use of doing the entire HTTP transaction within a modifyMVar, locks up the entire Session (and its Manager), such that multiple threads cannot concurrently use a wreq Session
19:10:32 <benbangert> this is rather problematic if you assume that you can use a Session between threads, just like you can use a http-client Manager
19:10:59 <benbangert> I was going to file a bug for the wreq lib regarding this, but wanted to ensure I'm reading its code correctly regarding this all
19:14:05 <Cale> benbangert: But is there even a way around the problem, I wonder...
19:14:38 <benbangert> Cale: well, I could make a single Manager, and share that, but create a Session per thread sharing the Manager
19:14:49 <benbangert> which is my next course of action, hopefully it will still retain enough efficiency
19:15:51 <benbangert> for reference, the resource usage comparison is like this. if I use a fresh wreq http request per thread, for 500 threads, memory usage hovers around 1.5 GB of ram
19:15:52 <Cale> I guess it depends on how much it matters to you that the cookie updates are done in a consistent fashion
19:16:07 <benbangert> using a shared wreq session (given its single request/response at a time), memory usage is 36 MB
19:16:26 <benbangert> so.... 36 MB for 500 threads vs. 1.5 GB of memory or more.... is rather alarming
19:16:57 <benbangert> Cale: the threads are all independent, so I don't need cookies at all actually
19:17:19 <benbangert> I just need the connection pool restraint to avoid excessive TCP connections
19:19:57 * hackagebot hjsonschema 0.4.0.0 - Haskell implementation of JSON Schema Draft 4.  http://hackage.haskell.org/package/hjsonschema-0.4.0.0 (seagreen)
19:30:26 <anohigisavay> hi, i'm new to haskell
19:30:52 <anohigisavay> i have a question: if i create a typeclass and define a (*) function with different types of arguments
19:31:16 <anohigisavay> why would it overwrites the default (*) operator?
19:32:50 <geekosaur> it shadows the original, not "overwrites"
19:33:00 <geekosaur> Prelude.* will work
19:33:59 <geekosaur> this is no different from e.g. a local variable in some other language hiding one from an outer scope
19:34:58 <anohigisavay> geekosaur: so is it possible such that the actual function is inferred by the argument types applied to (*)?
19:35:21 <anohigisavay> such that (Vector 1 2) * 3 = Vector 3 6
19:35:26 <geekosaur> no, type directed name resolution has problems, especially if you try to mix it with type inference
19:35:29 <cloud-pyon> Is there any way to make GHC emit a warning whenever I define a function that doesn't span all the constructors of a GADT? That is, even if the GADT's type parameters are specialized.
19:35:47 <cloud-pyon> Specialized, instantiated, or whatever might be the right term.
19:36:26 <anohigisavay> geekosaur: thanks a lot :)
19:36:34 <c_wraith> cloud-pyon: doesn't -Wall do that?
19:37:02 <cloud-pyon> Dunno, testing.
19:39:26 <cloud-pyon> c_wraith: It does not.
19:40:13 <cloud-pyon> Basically, I want to make sure that I always use GADTs through their full induction principle, rather than "slicing" them.
19:42:14 <jmcarthur> there are certain cases where type directed name resolution works. if you restrict the kind of names that can be resolved by type then it work out decently. for example, in newish versions of ocaml you can use constructors and record fields without fully qualifying them, and it will choose the correct one based on inferred type, if possible.
19:42:44 <Fuuzetsu> Agda can do it too, a bit
19:42:47 <Fuuzetsu> but it's not great
19:42:49 <jmcarthur> yes it can thwart type inference, but in that case you just qualify it
19:43:13 <jmcarthur> so it is no worse than before (having to qualify everything)
19:43:33 <cfoch> hello, the first time I did
19:43:34 <cfoch> $ autoconf
19:43:34 <cfoch> $ ./configure
19:43:34 <cfoch> $ make html
19:43:36 <cfoch> it worked
19:43:43 <cfoch> but if I do "make pdf"
19:44:00 <cfoch> it says "make: Nothing to be done for `pdf'.
19:44:00 <cfoch> "
19:44:05 <cfoch> Haddock ^
19:44:27 <jmcarthur> cfoch: FYI, using many lines for just one statement is generally seen as kind of annoying on irc. so is pasting (since it often takes many lines)
19:45:03 <jmcarthur> sadly i can only complain, since i don't know the answer to your question
19:45:30 <cfoch> yes, I know, sorry, but those just were 3 lines...
19:45:46 <jmcarthur> counting the question that's 9 lines
19:46:20 <jmcarthur> anyway, i don't mean to be a butt, sorry. i hope somebody can help you
19:47:09 <pavonia> cfoch: What package are you building?
19:47:20 <anohigisavay> cfoch: apparently there no pdf target in the Makefile
19:47:33 <cfoch> pavonia: https://github.com/cfoch/haddock/tree/master/doc
19:47:36 <cfoch> Haddock
19:52:43 <mrmagneto> what is the proper way of concatenating characters into a string? [char1]++[char2]? i havent been able to understand this fully yet
19:52:53 <cfoch> anohigisavay: if I want to "make pdf" i would have to do something like "INSTALL_PDF_DOC"  ?
19:53:04 <cfoch> I don't have idea. I'm just guessing.
19:54:05 <cloud-pyon> mrmagneto: char1 : char2 : "" -- :-P
19:54:18 <cloud-pyon> mrmagneto: Or [char1, char2]
19:54:41 <mrmagneto> can you ELI5 the difference between : and ++?
19:55:13 <platz> mrmagneto: what is the definition of List ? (i.e. [])
19:55:14 <Jeanne-Kamikaze> aside from the obvious ?
19:55:14 <cloud-pyon> mrmagneto: : is the constructor for non-empty lists. It takes as arguments the head (first element) and tail (remainder) of the new non-empty list.
19:55:35 <cloud-pyon> mrmagneto: ++ is a function that concatenates lists.
19:55:47 <Jeanne-Kamikaze> and it'll copy the left one
19:56:22 <cloud-pyon> Well, in this case, in most likelihood, GHC can optimize away the temporary list containing only char1.
19:56:51 <Guest632`> I am 15 minutes into learning haskell -- I am trying to use hte isLower function and the interpreter has told me that it is not in scope. How can I get it into scope?
19:57:00 <cloud-pyon> Guest632`: import Data.Char
20:00:00 <Cale> Jeanne-Kamikaze: Well, "copy". The cons cells in the new list that it constructs will have pointers to the same list items as the old one did, but there's no conceivable way they could be equal to the cons cells in the original list apart from that, because they have different tails.
20:00:53 <Jeanne-Kamikaze> s/copy/shallow copy
20:01:15 <pavonia> cfoch: From the makefile I would guess FOP is set but PDFXMLTEX isn't. I don't understand the @...@ snytax in https://github.com/cfoch/haddock/blob/master/doc/config.mk.in though to tell where these commands are coming from
20:01:38 <randir> What's the best way to randomly permute a list in Haskell?
20:02:01 <Welkin> > permutations [1,2,3]
20:02:02 <lambdabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
20:02:18 <Welkin> then choose one at random
20:02:21 <Cale> randir: There's a package which implements that algorithm on Hackage
20:02:32 <mrmagneto> how can i add a character(s) to a list of chars. im getting errors doing ['a','b']++['b','c']
20:02:37 <Cale> Choosing an element from a list with n factorial elements in it is pretty not-cheap
20:02:46 <cloud-pyon> randir: Off the top of my head: make an IntMap whose keys are random ints, and whose values are the elements of the list. Then, toList...
20:02:52 <Welkin> haha, true Cale
20:02:58 <pavonia> @hackage random-shuffle  -- randir
20:02:58 <lambdabot> http://hackage.haskell.org/package/random-shuffle  -- randir
20:02:58 <koala_man> > ['a','b']++['b','c']
20:03:00 <lambdabot>  "abbc"
20:03:06 <Cale> Like, if the list you're trying to shuffle is even 10 or so elements long, that's really awful.
20:03:08 <Jeanne-Kamikaze> he never defined "best"
20:03:25 <koala_man> mrmagneto: seems to work. is that your actual failing example?
20:03:33 <Jeanne-Kamikaze> your question is ambiguous randir
20:03:38 <Cale> Using random-shuffle is probably best.
20:04:06 <Cale> Though I kind of want to make a replacement for that package with the same code and slightly different types every time I see it.
20:04:20 <mrmagneto> yes. a stupid question now: is ['a','b'] the same type as ['a','b']++['b','c']? they are both of type [Char] correct? im getting type errors on my program
20:04:31 <byorgey> mrmagneto: correct
20:04:35 <randir> I'm asking because I think it might be an interview question for an interview I have tomorrow (!!) to shuffle a deck of cards
20:04:37 <Cale> mrmagneto: yes, those lists have the same type
20:04:41 <randir> not a hard question, but want to be prepared
20:04:47 <mrmagneto> thank you, i will go check my code again
20:04:56 <randir> I've done this before: http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
20:05:09 <Cale> randir: Oh, in that case, you might want to actually write the algorithm :)
20:05:20 <Welkin> randir: sounds like a horrible interview
20:05:20 <randir> I wonder how to efficently implement this though, since swapping out elements in a list isn't very efficent
20:05:27 <randir> an IO array probably, if I wanted
20:05:34 <randir> Welkin: how so?
20:05:37 <Jeanne-Kamikaze> use ST
20:05:39 <Cale> haha, another one of those algorithms which has two people's names attached to it despite being the most obvious algorithm for the task at hand
20:05:46 <randir> haha
20:06:06 <Welkin> randir: Dance, monkey! Dance!
20:06:14 <Jeanne-Kamikaze> it actually has 3 names xD
20:06:28 <Cale> randir: One thing which is likely going to be quite useful (and really ought to be in the list library but is not)
20:06:44 <Welkin> randir: you are preparing for a circus show
20:06:50 <Cale> is   select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
20:07:09 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
20:07:11 <lambdabot>  Defined.
20:07:15 <Cale> > select [1,2,3,4]
20:07:17 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
20:07:19 <randir> Welkin: Hehe. I think it's actually gonna be a good interview, with the head developer for a startup who presumably knows his stuff. I just read on Glassdoor that that question was once asked on an interview for this company, so I'm preparing out of nerves :P
20:07:31 <randir> my first technical interview (I'm finishing up my undergrad CS)
20:07:49 <Cale> randir: Once you have that, if you can write a function to pick a random element of a list, you should be good :)
20:08:51 <Cale> randir: Because that basically gives you your selected element, and the list of remaining elements that you can recurse on
20:09:11 <randir> Cale: Hmm, cool. :)
20:09:42 <randir> Cale: I'm not exactly worried, I can generally come up with code on the fly. Just very restless waiting for the interview, so figured I might as well prepare for some stuff
20:10:06 <Welkin> yes... that is the problem
20:10:11 <Welkin> the interview is pointless
20:10:18 <Welkin> it reveals nothing
20:10:31 <Welkin> anyone can cram on coding questions
20:10:34 <randir> Welkin: Coding will be only a portion of it, he's moreso gonna ask questions.
20:10:39 <Welkin> and memorize their data structures textbook
20:10:50 <randir> Welkin: And I agree, the interview structure isn't very good.
20:11:14 <Welkin> it is horrible, and has nothing to do with what the job actually requires
20:11:24 <Welkin> unless the job is algorithms research
20:11:47 <randir> I think this one will be okay, as the guy's an actual head developer, not just a recruiter guy
20:12:04 <Welkin> the recruiters don't interview
20:12:17 <Welkin> engineers are forced to interview candidates (technical screen)
20:12:38 <randir> I know, used the wrong term. I meant just a lower-level coder, as opposed to someone with experience/good sense of stuff
20:13:29 <randir> I think that the capability to learn/adapt/synthesis information and make something of it is way more important than just memorized structures and complexities, and I think in general it's what good developers look for.
20:13:54 <jle`> different criteria for different roles
20:14:00 <jle`> and different price points :)
20:16:38 <d35mille> Hey, anyone able to help me with something? I have an instance for Extract for an Integer type and a function called asBool where I give it an Integer and it returns a boolean equivelant. So if I called (asBool 4) it will return True. This all works fine in ghci, but when I use HUnit to test it and use it as my expected value, I get a big long error complaining about "No instance for (Extract x0) arising from a use of asBool ....." Anyone work with HUnit b
20:18:33 <Welkin> what is the type of asBool? Integer -> Bool ?
20:19:08 <d35mille> asBool :: Extract x => x -> Bool
20:20:15 <shachaf> When you ask a question like that you should paste your full code and full error.
20:20:18 <whn-pyon> Where is this Extract class defined? :-O
20:20:47 <Welkin> add Integral as a constraint
20:21:25 <Welkin> or just change the type to Integer -> Bool
20:22:40 <d35mille> class Extract x where asBool :: x -> Bool asInteger :: x -> Integer asDouble :: x -> Double
20:22:59 <d35mille> well that's the class, and I have 4 instances for it
20:23:36 <d35mille> and this is the instance that I've defined:
20:23:47 <Welkin> d35mille: use lpaste
20:23:49 <Welkin> @lpaste
20:23:49 <lambdabot> Haskell pastebin: http://lpaste.net/
20:24:08 <d35mille> ok one sec
20:26:31 <lpaste> d35mille pasted “a2.hs” at http://lpaste.net/121209
20:26:54 <mrmagneto> how can i replicate two characters and keep the result a list of strings, instead of a list of a list of a strings?
20:27:15 <Guest632`> The compiler is telling me: Could not find module `IO'
20:27:15 <Guest632`> It is a member of the hidden package `haskell98-2.0.0.2'.
20:27:25 <Guest632`> How can I resolve this issue?
20:28:08 <mrmagneto> I want replicate 5 "aa" to be "aaaaaaaaaa" instead of ["aa","aa", etc...
20:28:27 <lpaste> d35mille revised “a2.hs”: “No title” at http://lpaste.net/121209
20:28:37 <whn-pyon> Guest632`: s
20:28:41 <whn-pyon> Guest632`: What is the problematic code?
20:28:50 <Guest632`> Just an "import IO"
20:28:50 <c_wraith> mrmagneto: so concat the result?
20:29:13 <glguy> Guest632: typically you wouldn't use that module as it is very old and replaced by newer ones, but if you're trying to run old code then you can add the flag -package haskell98
20:29:23 <Welkin> > take (5 * 2) . repeat $ "aa"
20:29:24 <lambdabot>  ["aa","aa","aa","aa","aa","aa","aa","aa","aa","aa"]
20:29:32 <c_wraith> Guest632`: the flat namespace in Haskell98 has been deprecated for a long time.  The new name for that module would be System.IO
20:29:47 <ReinH> mrmagneto: concat
20:30:51 <mrmagneto> concat (replicate 5 "aa")
20:30:57 <mrmagneto> is that the proper form?
20:31:02 <ReinH> mrmagneto: sure
20:31:12 <mrmagneto> thank you
20:31:21 <Welkin> mrmagento
20:31:28 <Welkin> erisco's favorite
20:31:55 <whn-pyon> Guest632`: Why do you want to "import IO" in the first place?
20:33:11 <whn-pyon> Guest632`: The IO type constructor is already in the Prelude, which is imported by default into all modules, you do not need to import anything in order to use it.
20:33:48 <Guest632`> whn-pyon:: I am going through a beginning tutorial
20:34:04 <c_wraith> Guest632`: I highly recommend a newer tutorial
20:34:06 <jle`> hmmm... what tutorial is this?
20:34:08 <Guest632`> c_wraith: Thanks
20:34:10 <jle`> it might be fatally outdated
20:34:30 <Guest632`> http://en.wikibooks.org/wiki/Haskell/YAHT
20:35:23 * enthropy used that one
20:35:27 <whn-pyon> Guest632`: I can't find "import IO" in there.
20:35:31 <glguy> Whn-pyon: there used to be a module IO, it isn't trying to import the IO type
20:35:41 <whn-pyon> glguy: Oh.
20:35:51 <Guest632`> It should be on page 32 and 33
20:35:56 <jle`> 2006
20:36:07 <enthropy> "import System.IO" probably gives you roughly the same names in scope
20:36:42 * jle` reminisces about the world of 2006
20:38:02 <Rotaerk> Guest632`, I'd find a different resource
20:38:30 <Rotaerk> someone in here linked this once:  http://www.stephendiehl.com/what/
20:38:39 <kadoban> Guest632`: https://github.com/bitemyapp/learnhaskell has good recommendations, specifically the cis194 class is a good place to start
20:38:40 <jle`> @where learnhaskell
20:38:40 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:39:58 <Welkin> @where waldo
20:39:58 <lambdabot> http://planet.haskell.org
20:40:04 * hackagebot clash-prelude-quickcheck 0.1.0.0 - QuickCheck instances for various types in the CaSH Prelude  http://hackage.haskell.org/package/clash-prelude-quickcheck-0.1.0.0 (JohnEricson)
20:40:14 <Welkin> it's a lie!
20:40:26 <Welkin> there is no waldo on planet haskell
20:40:31 <Guest632`> thanks guys!
20:41:00 <mniip> does <**> also flip the order of the side effects?
20:42:53 <enthropy> no it's still left to right
20:43:04 <Rotaerk> what side effects?
20:43:36 <mniip> > [(<*>), flip (<**>)] <*> [id, (*2)] <*> [3, 4]
20:43:38 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
20:43:38 <lambdabot>    arising from a use of ‘M152197854905485746620551.show_M1521978549054857466...
20:43:38 <lambdabot>  The type variable ‘b0’ is ambiguous
20:43:52 <jle`> no flip, check out the source :)
20:44:06 <jle`> @src (<**>)
20:44:06 <lambdabot> (<**>) = liftA2 (flip ($))
20:44:10 <enthropy> > ('1' <$ tell "y") <**> (const succ <$ tell "x")
20:44:11 <lambdabot>  No instance for (GHC.Show.Show (f0 (a0 -> a0)))
20:44:12 <lambdabot>    arising from a use of ‘M657398028070262303320574.show_M6573980280702623033...
20:44:12 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
20:44:43 <Cale> Rotaerk: the effects from executing the first and second argument of <**>
20:44:43 <mniip> well that suggests that the argument is evaluated before the function
20:44:58 <jle`> that's fine too?
20:45:29 <enthropy> > runWriter $ ('1' <$ tell "y") <**> (succ <$ tell "x")
20:45:30 <lambdabot>  ('2',"yx")
20:45:36 <Cale> The effects from the first argument to <**> happen first, if it's not clear already :)
20:46:01 <Rotaerk> :t (<**>)
20:46:02 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
20:46:38 <Rotaerk> I don't get how applicative has "effects"
20:46:58 <enthropy> Rotaerk: what do you call the "yx" there?
20:47:08 <EvanR> mniip: evaluation order doesnt have anything to do with executing side effects though
20:47:09 <Cale> Rotaerk: Consider the case where f = IO, for instance.
20:47:12 <EvanR> luckily
20:47:21 <jle`> > flip runState 10 $ liftA2 (,) (modify (+2)) (modify (*2))
20:47:22 <lambdabot>  (((),()),24)
20:47:38 <mniip> EvanR, I meant consideration of the side effects
20:47:46 <jle`> > flip runState 10 $ (modify (+2) *> modify (*2) *> modify (+10))
20:47:48 <EvanR> me too?
20:47:48 <lambdabot>  ((),34)
20:47:55 <jle`> all Applicative
20:48:27 <Cale> mniip: The action which produces the argument is executed before the action which produces the function. Then the function is applied to the argument to produce the result of the combined action.
20:48:40 <jle`> > flip runState 10 $ T.sequenceA [modify (+3), modify (*2), modify (+10), modify negate]
20:48:42 <lambdabot>  ([(),(),(),()],-36)
20:48:53 <Cale> mniip: The result may or may not be evaluated in this process.
20:49:10 <Cale> mniip: In fact, it probably won't be.
20:49:39 <Cale> (it'll just be left as an application term until something pattern matches on it)
20:49:46 <jle`> (f, m1) <*> (x, m2) = (f x, m1 <> m2)
20:50:09 <Rotaerk> hmm I see
20:50:15 <jle`> (x, m1) <**> (f, m2) = (f x, m1 <> m2)
20:50:25 <jle`> same ordering
20:50:42 <Rotaerk> > (putStr "Lo" >> return (+6)) <*> (putStr "Hi" >> return 5)
20:50:43 <lambdabot>  <IO Integer>
20:51:23 <jle`> yeah, try (5 <$ putStrLN "hey") <**> (negate <$ putStrLn "you")
20:51:25 <jle`> on ghci
20:53:00 <jle`> iof <*> iox = do { f <- iox; x <- iox; return (f x) }
20:53:17 <jle`> um, the first one shold be iof
20:53:29 <jle`> iox <**> iof = do { x <- iox; f <- iof; return (f x) }
20:53:38 <jle`> ^^ for IO
20:55:32 <deMoivre> I had the most bizarre thing happen to me a few minutes ago.
20:55:39 <deMoivre> And I would greatly appreciate any insight into this
20:55:54 <deMoivre> I got my Mandelbrot Set algorithm to work in Haskell, and compiled it
20:56:03 <jle`> yaay
20:56:05 <deMoivre> and got a benchmark runtime out of it of about 9.7seconds
20:56:30 <deMoivre> Then I came back home after work and compiled and ran it again, and it practically halted after the first few lines of output, it was going so slow
20:56:36 <deMoivre> and I couldn't figure out why
20:56:40 <deMoivre> (I still can't figure out why)
20:56:46 <jle`> same compiler flags?
20:56:48 <deMoivre> but I did manage to reproduce the phenomenon
20:56:51 <deMoivre> yes; same flags
20:56:54 <deMoivre> I thought of that
20:56:59 <deMoivre> identical .hs files
20:57:05 <deMoivre> I cleared away the other files, even
20:57:08 <bob_twinkles> hitting swap?
20:57:09 <deMoivre> started from scratch
20:57:09 <jle`> any TH?
20:57:17 <deMoivre> bob_twinkles: huh?
20:57:22 <deMoivre> jle`: huh?
20:57:29 <jle`> template haskell. but. most likely not
20:57:36 <bob_twinkles> deMoivre: is your machine running out of RAM and swapping out to the disk?
20:57:48 <deMoivre> bob_twinkles: I thought that's what you meant, but it seems like such a silly thing to ask me...
20:57:49 <deMoivre> no =)
20:57:50 <jle`> it triggers code execution (and possibly io) during compilation
20:58:00 <deMoivre> I duplicated the problem on my iMac and my i5 quad core Windows 7 box
20:58:02 <deMoivre> same behavior
20:58:09 <jle`> same slowness
20:58:11 <jle`> or same fast-then-slow?
20:58:17 <deMoivre> Windows GHC and OS X GHC
20:58:25 <deMoivre> same fast-then-slow
20:58:26 <bob_twinkles> deMoivre: heh, you never know =P
20:58:30 <deMoivre> let me show you the source code
20:58:32 <jle`> that's interesting
20:58:45 <deMoivre> https://bitbucket.org/aquishix/haskell-explorations
20:58:52 <deMoivre> look at the mandel4.hs file
20:59:08 <randir> Random question: In a sentence or two, how would you describe SOA?
20:59:39 <jle`> it's an american crime drama series about a close-knit outlaw motorcycle club
20:59:50 <Cale> randir: "What's SOA?" :D
20:59:55 <c_wraith> Sons of Anarchy
21:00:01 <jle`> that's what i get from wikipedia at least
21:00:09 <deMoivre> service oriented architecture?  Assigning repsonsibilities to individual daemons or runtimes that are distributed throughout a network and which communicate with each other through TCP/IP instead of some kind of IPC within 1 runtime on the same machine
21:00:14 <randir> jle`: that made my day
21:00:22 <deMoivre> That's how I'd define it, at least
21:00:40 <deMoivre> decoupled, also
21:01:01 <deMoivre> the services are supposed to be decoupled and usually stateless to some degree
21:01:26 <deMoivre> ok, so...
21:01:29 <deMoivre> jle`
21:01:32 <deMoivre> bob_twinkles
21:01:38 <deMoivre> in mandel4.hs
21:01:41 <randir> deMoivre: thanks, that's a good definition. That's how I pretty much understood it, but I saw lots of job listings talking about SOA and wanted to make sure I understood it right.
21:01:51 <deMoivre> randir: np
21:01:58 <deMoivre> in mandel4.hs, there's this line:
21:02:05 <deMoivre> | its >= 1000000           = (cre, cim, zre, zim, its, " ")
21:02:15 <deMoivre> I cranked that 1000000 down to 1000 and recompiled
21:02:22 <deMoivre> and it was blazingly fast, and you might expect
21:02:26 <deMoivre> so then I iterated a few times
21:02:37 <deMoivre> I bumped it to 10000, recompiled, and re-ran
21:02:43 <deMoivre> all the way back up to 1000000
21:02:51 <deMoivre> by the time I did, the good performance was restored
21:02:54 <deMoivre> -----
21:03:01 <deMoivre> I might as well have visible question marks above my head at this point.
21:03:22 <deMoivre> I captured the executable OS X binaries in case anyone wants to take a look at the difference between them
21:03:26 <deMoivre> same with the .hi and .o files
21:03:29 <deMoivre> I captured those, too
21:03:46 <deMoivre> they're all different except for the .hs files, which are identical
21:03:53 <deMoivre> each has 1000000
21:05:05 * hackagebot fast-logger 2.3.0 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.3.0 (MichaelSnoyman)
21:05:07 * hackagebot monad-logger 0.3.13.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.13.1 (MichaelSnoyman)
21:08:58 <bob_twinkles> so if you run it a few times at the lower iteration count and then try it at the high iteration count it's fast, but if you run the high iteration count multiple times in a row it's slow?
21:09:17 <deMoivre> I was re-compiling between each of these runs
21:09:25 <deMoivre> it's not a command line parameter
21:10:00 <deMoivre> if you mean running the compiler multiple times at the high iteration count, then the answer to that question is "Yes."
21:10:16 <kadoban> deMoivre: Are you running ghc with -fforce-recomp or whatever it is? If you're getting nonsense like that, there's a good chance it's not actually running what you think it is.
21:10:36 <deMoivre> kadoban: I'm using no command line options at all right now
21:10:43 <deMoivre> I was using -O2 earlier off and on, but that's it
21:10:53 <deMoivre> it didn't seem to make a difference either way with any of this
21:12:21 <mrmagneto> in a function, is there a simple way to store a string from an input list?
21:12:49 <Welkin> store a string?
21:12:49 <shachaf> That depends on what that means.
21:12:55 <Hijiri> store in what sense?
21:12:56 <Welkin> there is no assignment in haskell
21:13:41 <Welkin> inside a do-block you can use a let expression to contain a result that may be used later
21:14:06 <Cale> mrmagneto: What do you want your function to compute?
21:14:13 <johnw> you don't need a do-block to do that
21:14:14 <mrmagneto> Im trying to write a function that turns "jump,s,ed" (or something similar) into ["jump","jumps","jumped"] and im having trouble trying to think about how to approach it.
21:14:46 <Hijiri> mrmagneto: and without using standard library splitting functions?
21:15:06 * hackagebot wai-extra 3.0.4.5 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.4.5 (MichaelSnoyman)
21:15:13 <Cale> > ["jump" ++ affix | affix <- ["","s","ed"]]
21:15:14 <lambdabot>  ["jump","jumps","jumped"]
21:15:40 <Cale> Does that help? :)
21:15:46 <Hijiri> oh, I misinterpreted the question
21:16:08 <mrmagneto> Hijiri: like splitAt?
21:16:15 <mrmagneto> ook
21:16:41 <Cale> splitAt would be the wrong thing to use, you'd want to use break or something
21:16:58 <Hijiri> I actually don't think I was thinking of a standard library function
21:17:18 <Cale> > break (== ',') "jump,s,ed"
21:17:19 <lambdabot>  ("jump",",s,ed")
21:17:27 <Hijiri> Data.List.Split.splitOn might be what I was looking for
21:17:41 <Cale> yeah, that would definitely be useful
21:17:41 <hrumph> > map ("jump" ++) ["","s","ed"]
21:17:43 <lambdabot>  ["jump","jumps","jumped"]
21:18:02 <Cale> > splitOn "," "jump,s,ed"
21:18:03 <lambdabot>  ["jump","s","ed"]
21:18:29 <mrmagneto> hrumph, that method makes the most sense to me from what ive learned so far
21:18:36 <Cale> > let (prefix : affixes) = splitOn "," "jump,s,ed" in [prefix ++ affix | affix <- affixes]
21:18:37 <lambdabot>  ["jumps","jumped"]
21:18:44 <Cale> > let (prefix : affixes) = splitOn "," "jump,s,ed" in [prefix ++ affix | affix <- "" : affixes]
21:18:45 <lambdabot>  ["jump","jumps","jumped"]
21:19:53 <deMoivre> kadoban: I just tried it with -fforce-recomp ...it did not fix the problem.  =(
21:20:31 <johnw> > let foo [] = []; foo (x:xs) = x:map (x++) xs in foo ["jump","s","ed"]
21:20:32 <lambdabot>  ["jump","jumps","jumped"]
21:21:02 <mrmagneto> the last part of the question is that if "@ing" is the string, then drop the last letter. How could i deal with special cases like this? I only know java so my brain hasn't gotten used to this
21:21:36 <Cale> drop the last letter of what?
21:21:49 <Cale> Could you give a more complete example of what you want there?
21:21:57 <mrmagneto> yes, one sec
21:22:43 <mrmagneto> "code,s,@ing" becomes ["code", "codes", "coding"]
21:22:51 <Cale> okay
21:22:55 <mrmagneto> where @ signifies that code becomes cod before appending ing
21:22:58 <Cale> right
21:23:30 <Cale> Well, for that, you might want to actually have a special version of (++)
21:24:50 <Cale> > let xs ++@ ('@':ys) = init xs ++@ ys; xs ++@ ys = xs ++ ys; (prefix : affixes) = splitOn "," "code,s,ed,@ing" in [prefix ++@ affix | affix <- "" : affixes]
21:24:51 <lambdabot>  ["code","codes","codeed","coding"]
21:24:55 <Cale> oops
21:25:07 <Cale> > let xs ++@ ('@':ys) = init xs ++@ ys; xs ++@ ys = xs ++ ys; (prefix : affixes) = splitOn "," "code,s,@ed,@ing" in [prefix ++@ affix | affix <- "" : affixes]
21:25:09 <lambdabot>  ["code","codes","coded","coding"]
21:25:14 <Cale> right :)
21:26:08 <mrmagneto> I wish i could write haskell that well! a lot of that means nothing to me still
21:26:21 <Cale> > let xs ++@ ('@':ys) = init xs ++@ ys; xs ++@ ys = xs ++ ys; (prefix : affixes) = splitOn "," "code,s,@ed,@ing,@@bb salad" in [prefix ++@ affix | affix <- "" : affixes]
21:26:22 <lambdabot>  ["code","codes","coded","coding","cobb salad"]
21:26:45 <Cale> lol
21:26:58 <Cale> mrmagneto: Is there anything you'd like me to explain specifically?
21:27:07 <Cale> I defined a new concatenation operator ++@
21:27:44 <mrmagneto> So, you defined a new function entirely called ++@ (which could be called anything?)
21:27:46 <Cale> yes
21:27:59 <Cale> xs ++@ ('@':ys) = init xs ++@ ys
21:28:43 <mrmagneto> ok, so that function says, if x (the first element of the string) is equal to at, then something
21:28:43 <Cale> This says that if the second argument to ++@ is a string that starts with '@', we take the init of the first argument (i.e. drop the last element of it)
21:28:54 <Cale> and ++@ that to the remainder of the second argument
21:29:16 <Cale> (which might again start with an @ sign, as was the case with my silly cobb salad example)
21:29:54 <Cale> We could also have just made it xs ++@ ('@':ys) = init xs ++ ys  and skip the recursion
21:30:03 <Cale> but only handle one @ sign like that
21:30:36 <Cale> and then the second line of the definition xs ++@ ys = xs ++ ys  is what happens when the first pattern match falls through, so in all other cases, this acts like concatenation.
21:30:54 <mrmagneto> ok. that make senses
21:31:02 <mrmagneto> now how does it know when to call that function?
21:31:09 <Cale> Well, I used it later on
21:31:15 <Cale> prefix ++@ affix
21:32:04 <mrmagneto> oo, so its just always calling it which itself is then checking if the @ exists
21:32:20 <Cale> yeah
21:32:20 <mrmagneto> ?
21:32:32 <mrmagneto> ok, that makes sense now
21:32:54 <mrmagneto> i think i just learned more in those 10 questions then i have in the past week
21:32:56 <mrmagneto> thank you
21:33:00 <Cale> no problem!
21:33:33 <mrmagneto> if you dont mind, what is your profession/are you a student?
21:33:54 <Cale> My last few jobs have been programming in Haskell
21:34:22 <mrmagneto> what type of real world applications are there for haskell?
21:34:41 <Cale> I have a BMath in pure mathematics from Waterloo, and have been programming in Haskell for around 13 or 14 years now.
21:35:02 <Cale> Well, almost anything you can imagine making computers do? It's a general purpose programming language.
21:35:22 <Cale> My last job was working on a web application backend in Haskell for skedge.me
21:36:02 <Cale> and before that, I worked for a startup on an action RPG targeted at iPhones and other mobile devices written mostly in Haskell
21:36:57 <Cale> (we sadly didn't get the game done before running out of funding, but the game engine worked reasonably well -- we still had a lot of things to do to make the game we were really trying to make though)
21:37:23 <mrmagneto> is there a benefit to using haskell for a project like that over Lua or C++ (which seem to be the industry standards?)?
21:38:14 <Cale> I think so. There are also a lot of downsides, in terms of not being able to pick up an already written game-engine. If you're going to write something from scratch, you might as well use a better language than C++ though.
21:39:14 <Cale> The reason that things are industry standard has a lot more to do with inertia than it does with quality or suitability for purpose.
21:39:21 <Cale> almost always
21:40:09 <mrmagneto> That sucks that the action rpg was never able to launch, that sounds like a really awesome team to be apart of
21:40:14 <Cale> yeah
21:41:10 <mrmagneto> that makes sense. the only reason I know Lua is because of the ease of use with the corona sdk, same for javascript with the countless frameworks
21:41:15 <Cale> Eventually we can hopefully take the FRP system that we created, and the insights we had about the Arrow type class and give them back to the community.
21:41:16 <hrumph> haskell's not always the best for interfacing with the outside world, not because there's anything wrong with haskell just that people have had some eccentric ideas about how to interface things
21:42:24 <mrmagneto> FRP?
21:42:30 <Cale> Functional reactive programming
21:42:32 <hrumph> some of the packages i'm working with right now are making me scratch my head
21:43:23 <Cale> mrmagneto: A lot bugs, especially in games, but in many types of application generally, have to do with mistakes surrounding updating state in response to other changes in state.
21:43:30 <mrmagneto> hrumph: learning the basics of haskell only knowing java, javascript, c, and c++ has made me scratch my head a lot lately
21:43:43 <hrumph> mrmagneto, haskell is pretty damn awesome
21:44:21 <platz> I didn't realize the Elm <-> React connection until evan posted about it.. I'm not sure if laziness is as much as a problem as I've heard about, but at least now I have an architecture in my head for FRP that makes sense
21:44:48 <mrmagneto> Cale: makes sense
21:45:07 <Cale> mrmagneto: Functional reactive programming is an attempt to provide ways to describe the connections between things that change over time in such a way that the library can do the actual work of keeping things up to date.
21:45:07 * hackagebot learning-hmm 0.3.1.2 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.3.1.2 (mnacamura)
21:46:38 <benbangert> Cale: the main thing I've hit is that when you hit serious performance/memory issues, its almost always impossible to address them yourself. it requires an email to a list of the very very top haskell experts
21:46:40 <platz> Cale: thats pretty much the most concise way I've ever heard anyone put that
21:46:42 <Cale> mrmagneto: So you have two basic concepts which show up in most such libraries. The first is behaviours, which are things that have a value at any time that you look at them. Examples of these might include the current position of the mouse, or the number of HP that a monster has, or what animations to display.
21:47:13 <benbangert> Cale: generally because while many people make small 'play projects' in haskell, its much harder to find libs that have been used in large-scale production use
21:47:47 <Cale> mrmagneto: The second sort of thing is events, which are things that occur at particular points in time, and have a value at those times, like the sequence of keystrokes or mouse clicks, the sequence of attacks made by a monster, or the sequence of sound effects that need to be played.
21:48:11 <platz> benbangert: Is that for things like games, or for GUI's?  I wonder if GUI's have simpler signal graphs that could avoid some of those problems
21:48:27 <platz> otherwise, not being able to diagnose your problems would not be a good place to be
21:48:44 <benbangert> platz: prolly neither. I'm speaking purely from a heavily concurrent/parallel network daemon view
21:49:00 <benbangert> platz: and yea, it sucks to be unable to precisely and easily diagnose your own problem
21:49:53 <benbangert> platz: oddly, at the same time, given what I know about how crappy it would be to do this project in many other langs... it can take less time to deal with that pain when it hits.
21:50:18 <mrmagneto> cale: thank you, thats all something that ive never heard of/learned about before. very interesting to know.
21:50:42 <platz> benbangert: hrmm, I wasn't aware FRP was being used for those kind of use cases.  one of the things i haven't found a good answer for in this space (and the creator of elm couldn't answer) was how to handle large amounts of data and deal with things like backpressure - frp doesn't have good mechanism for this
21:51:33 <Cale> benbangert: I think it's kind of like programming in any other language, but different. Most people don't have that many years of experience programming in Haskell.
21:52:11 <benbangert> platz: oh, it isn't, sorry, didn't read backlog before jumping in. I'm not doing FRP ;)
21:52:14 <Cale> benbangert: Learning how to locate and solve space performance issues especially is something that people only learn gradually through a lot of experience, no matter what language they're writing in.
21:53:02 <benbangert> Cale: yea, makes sense. thats the way I've tried to approach it when it frustrates me. to consider I've had 10+ years learning how to solve this other class of bugs from imperative languages
21:54:05 <benbangert> Cale: btw, what insights about the Arrow class?
21:55:21 <Cale> benbangert: That it's missing a lot of stuff... the definition ought to look a lot closer to the definition of a symmetric monoidal category, which means including a bunch of stuff for reassociating and swapping tuples, and introducing/eliminating units as primitives
21:55:35 <Cale> That basically means that you get to use 'arr' a whole lot less
21:56:01 <Cale> Well... let me say something else first
21:56:26 <Cale> A thing which Arrow gives you over Monad is that both of the arguments to (>>>) are of a type that you have control over.
21:56:49 <mrmagneto> if i have "one,two,three" how can i pull out "one"?
21:57:26 <bob_twinkles> (head . words)
21:57:30 <Cale> If you have something written in terms of the monad operations, it's impossible to do much runtime analysis to simplify the computation before it runs, because as soon as you hit a (>>=), you have a black box function on the right
21:58:17 <Cale> But if you have something written in terms of the Arrow combinators, there's a little more hope, because if you have f >>> g, well, f and g are values of a type that you mostly control, and so you might see some way to optimise things
21:58:33 <HeladoDeBrownie> Cale, can ghc ever pull expressions out of a lambda?
21:58:42 <Cale> However, using arr spoils this, because you're putting black box functions in the way of any optimisation you might do.
21:59:02 <Cale> and if you use the proc/do notation, you're especially screwed, because it's going to stick an arr in between every pair of lines
21:59:42 <bob_twinkles> mrmagneto: er, I'm silly; (fst . break (== ','))
22:00:06 <Cale> So, we eventually came to the conclusion that we should add some more primitives to Arrow, like  assocR :: (Arrow (~>)) => ((a,b),c) ~> (a,(b,c))
22:00:19 <Cale> and  swap :: ... => (a,b) ~> (b,a)
22:00:20 <Cale> and so on
22:00:57 <Cale> and then the proc/do notation only needs to use arr if you do a pattern match against something which isn't a tuple, or you have a complex expression to the right of -<
22:01:04 <mrmagneto> bob_twinkles: thank you, perfect!
22:01:12 <Cale> which helps a lot
22:02:10 <Cale> and then the thing which runs your arrow computations can do a lot more to inspect where values are going and simplify things ahead of time -- our FRP system built up a heterogeneously typed graph of the computation and did a bunch of work to simplify it
22:02:46 <Cale> HeladoDeBrownie: um, I believe it can lift constants out
22:03:17 <HeladoDeBrownie> Cale, is the general answer something like "usually, no"?
22:03:25 <HeladoDeBrownie> (thus the "black box" thing?)
22:03:38 <zav> cabal sandbox vs cabal-dev anyone?
22:03:50 <pacak> zav: cabal sandbox.
22:03:54 <Cale> Oh, well, that doesn't affect the fact that at runtime, if you have a function, all you can do to tell what it is, is to apply it to an argument and see what you get.
22:04:11 <ReinH> Cale: can you actually say Arrow (~>)?
22:04:18 <Cale> ReinH: You used to be able to
22:04:27 <Cale> ReinH: It really sucks that you can't now
22:04:28 <benbangert> Cale: so that additional Arrow combinators makes things more efficient during run-time?
22:04:40 <ReinH> Cale: Yeah I was thinking about that. It would be nice.
22:05:20 <Cale> benbangert: Yeah, just writing our preprocessor to translate the proc/do notation in terms of our new primitives made the game run something like 7 to 10 times faster
22:05:28 <ReinH> Profunctor (+>), etc
22:05:35 <mrmagneto> is this allowed? I have a function called breakDown that takes in a string/[Char] and i want to access it as both a string and a list of elements, so can i say something like breakDown (x:xs),string = ...?
22:05:59 <HeladoDeBrownie> mrmagneto, there is literally no distinction between strings and lists of Char. that said, you can easily write string@(x:xs)
22:06:10 <HeladoDeBrownie> mrmagneto, in that case string means the whole thing, while x is the head and xs is the rest
22:06:12 <Fuuzetsu> type String = [Char]
22:06:18 <Cale> benbangert: and probably more than that by the end, since we hadn't even added all the optimisations at that point
22:06:59 <benbangert> Cale: makes sense, just wrapping my own head around the thought that you're optimizing something for the optimizers just by changing types around
22:07:02 <zav> pacak: is there a particular reason? i like NPM
22:07:20 <Cale> benbangert: I think that factor was just from avoiding all the stupid tuple construction and deconstruction
22:07:22 <pacak> zav: Because cabal-dev is no longer supported
22:07:47 <Cale> benbangert: It was more about exposing details about the computation so that *our own* optimiser could fix things up *at runtime*
22:08:04 <Fuuzetsu> Cale: what game is this?
22:08:10 <Cale> Fuuzetsu: Blood Knight
22:08:26 <zav> pacak: thanks, you saved me time
22:08:43 <Cale> benbangert: The FRP system started to look a bit like a compiler, I suppose if things had gone on we might eventually replaced it with something static.
22:09:04 <Cale> But there were some operations which really benefited from having this optimisation take place dynamically
22:09:37 <ReinH> Cale: Hmm, maybe conal should work on super compilers for FRP...
22:09:38 <Cale> Like, when you spawn new monster AIs and stuff, you're effectively addding to the graph of the computation that's being done, and it's nice to be able to run the simplifier over the whole thing
22:09:56 <ReinH> JIT arrow optimization
22:10:03 <Cale> yeah, pretty much
22:10:36 <Fuuzetsu> Cale: did it never come out or something? Can't find much about it
22:10:56 <ReinH> It's probably in the dead startup graveyard somwhere :(
22:11:16 <Cale> Fuuzetsu: Yeah, it never came out, we got pretty far with the engine, but it was pretty far from the ARPG we were trying to make when we ran out of money
22:11:39 <augur> jle`: the type you give for mconcat is not a valid type
22:11:50 <augur> oh god that was so long ago.. damn you scrollup :(
22:11:59 <bitemyapp> Cale: games are really, really hard.
22:12:01 <Fuuzetsu> has the code been purged
22:12:20 <bitemyapp> Cale: I gave up the idea of being a game developer after a couple years of kicking around mods. Sooooooooooooo much work.
22:12:34 <Cale> We had a big, but mostly still pretty lonely, world map that was dynamically loaded, basic ranged and melee monster AIs that were pretty fun to fight against
22:12:37 <bitemyapp> Cale: I don't think most gamers realize just how much more difficult game dev is than what most programmers do on a daily basis.
22:12:49 <bitemyapp> Cale: are you into roguelikes?
22:13:00 <Cale> Yeah, I'm into most sorts of games really :)
22:13:17 <bitemyapp> Cale: I've been thinking about making an AI for hearthstone.
22:13:27 <HeladoDeBrownie> i'm… i'm writing a mud. that counts as a game i think :P
22:13:36 <ReinH> HeladoDeBrownie: sure it does!
22:13:42 <ReinH> HeladoDeBrownie: in Haskell?
22:13:42 <bitemyapp> Cale: I've realized I'm bored with individual games of Hearthstone and that I'd rather generalize strategies and collect data more quickly.
22:13:54 * Fuuzetsu mutters something about the game library he was using not working anymore
22:14:15 <HeladoDeBrownie> ReinH, yeah. i was thinking how it seems to sidestep many design issues, while also complicating others, but you're right, it is a game.
22:14:18 <bitemyapp> I should probably give some thought to quantifying the search spaces involved though.
22:14:29 <Cale> Haha, cool, I've thought about that a bit. I'm sure that there's a lot of potential for doing a lot better than the existing AIs do in terms of strength of play. There hasn't been much motivation for the AI creators to make their bots very good at the game, since it's more about just grinding out a lot of matches.
22:14:51 <bitemyapp> Cale: yeah I don't want to grind out matches per se, I just find thinking about the game at a higher level more interesting.
22:14:57 <bitemyapp> Cale: and as stated, I want to gather data more quickly.
22:15:12 <bitemyapp> partly so I can validate builds more quickly.
22:15:21 <ReinH> bitemyapp: I suspect that a hearthstone AI without any predictive capabilities would still do quite well
22:15:28 <Cale> bitemyapp: btw, this is getting really offtopic for #haskell, but have you checked out Prismata at all?
22:15:44 <ReinH> Most players aren't really maximizing their card value, so just doing that correctly would be an edge
22:15:48 <bitemyapp> Cale: yeah, I did the purchase thing-y but haven't figured out how to play it.
22:15:53 <Cale> oh
22:15:58 <Cale> did they send you a key?
22:16:06 <bitemyapp> ReinH: I've found most players start playing close to optimally by rank ~14
22:16:10 <Cale> If you still haven't got your key, I'll bug Alex.
22:16:13 <bitemyapp> Cale: I don't know, I should check again.
22:16:21 <ReinH> 14? That hasn't been my experience at all.
22:16:30 <bitemyapp> I've not been 14 for awhile
22:16:34 <bitemyapp> so it may have changed.
22:16:54 <ReinH> It'll be different at the start of a season or whatever they're called
22:17:21 <bitemyapp> ReinH: I've found the game gets to be pretty RNGesus/meta heavy once people start playing competently.
22:17:43 <bitemyapp> ReinH: which is another reason I want an AI. I want to see the entire curve across different classes and see how each build performs.
22:17:48 <jle`> augur: hm which one?
22:17:50 <ReinH> bitemyapp: Right, it's much harder to make an AI aware of meta. Deck archetypes and such.
22:18:10 <augur> jle`:   mconcat :: Monad m => [m] -> m
22:18:19 <jle`> heh
22:18:23 <bitemyapp> ReinH: I suppose so, there's a lot of upfront labor just in modeling the cards and their behaviors properly too.
22:18:27 <ReinH> It's relatively easy to get an AI to maximize card value. It's harder to get an AI to know whether your mage opponent is running flamestrike
22:18:48 <bitemyapp> ReinH: I had a python user tell me you couldn't model a game like Hearthstone just using data.
22:19:01 <ReinH> Well, by relatively easy I mean "within the realm of things I think I could accomplish"
22:19:02 <bitemyapp> signifier/signified distinction was lost on them. *shrug*
22:19:11 <augur> jle`: i think maybe you meant Monoid m?
22:19:14 <EvanR> bitemyapp: what kind of data?
22:19:15 <jle`> mhm
22:19:28 <bitemyapp> ReinH: I think if you fed it enough data, it could build predictive models based on card co-occurrence.
22:19:30 <augur> tho a monoidal monad would be interesting
22:19:49 <augur> tho i guess all monads are monoidal
22:19:54 <ReinH> bitemyapp: Oh, sure, even a markov model could do that
22:19:57 <bitemyapp> ReinH: but realistically, it's easier to just feed it decks from the sites where people post and vote on builds.
22:20:02 <bitemyapp> and higher fidelity.
22:20:14 <Fuuzetsu> augur: just a monoid …
22:20:17 <augur> and you could just fold with (>>)? but
22:20:43 <HeladoDeBrownie> my favorite thing about monads is how kleisli arrows form a category
22:20:50 <mrmagneto> can someone explain to me how to get map (break (== ',')) "a,b,c" to work? my expected output is ["a","b","c"]
22:20:55 <augur> no that wouldnt work because you'd need a non-empty list
22:21:01 <ReinH> mrmagneto: Well, it won't do that.
22:21:14 <Fuuzetsu> >(break (== ',')) "a,b,c"
22:21:15 <augur> (Monoid a, Monad m) => [m a] -> m a   is definitely doable tho!
22:21:23 <Fuuzetsu> > break (== ',') "a,b,c"
22:21:24 <lambdabot>  ("a",",b,c")
22:21:25 <ReinH> @hackage split mrmagneto
22:21:25 <lambdabot> http://hackage.haskell.org/package/split mrmagneto
22:21:31 <Fuuzetsu> oh that's your problem
22:21:35 <Fuuzetsu> yes, use that package
22:21:42 <augur> :t fmap mconcat.sequence
22:21:43 <lambdabot> (Monoid b, Functor f, Monad f) => [f b] -> f b
22:21:47 <mrmagneto> yeah, thats why i tried to map it
22:21:49 <augur> \o/
22:21:53 <jle`> \o/
22:22:06 <ReinH> mrmagneto: mapping it would try to apply the function to each character
22:22:11 <jle`> darn amp
22:22:14 <mrmagneto> is there a way to fix my existing code?
22:22:27 <augur> functor constraint? interesting. which version of GHC is lambdabot running?
22:22:44 <Fuuzetsu> not 7.10 for sure
22:22:50 <ReinH> augur: the one where fmap is a Functor method?
22:22:52 <jle`> > #VERSION
22:22:54 <lambdabot>  <hint>:1:2: lexical error at character 'V'
22:23:14 <ReinH> Probably not the one that hasn't been released yet?
22:23:38 <Fuuzetsu> pft, RC is pretty much released
22:24:09 <ReinH> Well, you can still liftM for now :p
22:24:30 <ReinH> mrmagneto: no, break doesn't do what you want
22:24:30 <Fuuzetsu> unless you're one of those people who e-mailed me asking to upload versions of stuff that work with 7.10 then I take the ‘it's not even out yet’ stance
22:25:16 <Fuuzetsu> :t scan
22:25:17 <lambdabot>     Not in scope: ‘scan’
22:25:17 <lambdabot>     Perhaps you meant one of these:
22:25:17 <lambdabot>       ‘scanl’ (imported from Data.List),
22:25:17 <ReinH> mrmagneto: why not just use the list splitting package to split your list?
22:25:19 <Fuuzetsu> :t scanl
22:25:20 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
22:25:26 <Fuuzetsu> hm
22:26:05 <augur> ReinH: i guess even tho monad entails functor, the constraint isnt subsumed in the sig
22:26:36 <mrmagneto> my assignment only allows prelude, data.char, and no recursion (we just learned higher order functions so were supposed to use those instead of writing our own recursion)
22:26:42 <augur> :t ?
22:26:42 <Fuuzetsu> Monad doesn't entail Functor yet
22:26:42 <lambdabot> parse error on input ‘?’
22:26:44 <augur> whoops
22:26:46 <augur> :t _
22:26:47 <lambdabot>     Found hole ‘_’ with type: t
22:26:47 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
22:26:47 <lambdabot>                the inferred type of it :: t at Top level
22:26:56 <ReinH> mrmagneto: Oh. Ok then.
22:27:04 <augur> so: its 7.8ish
22:27:42 <mrmagneto> ReinH: haha, yeah. i would have used split a long time ago if i could have!
22:27:53 <ReinH> mrmagneto: Well, you can do it with foldr
22:28:19 <mrmagneto> and break?
22:28:31 <ReinH> No, you don't need break
22:55:11 * hackagebot template-haskell-util 0.1.0.2 - Some utilities for template Haskell.  http://hackage.haskell.org/package/template-haskell-util-0.1.0.2 (songzh)
23:00:07 <jle`> :t 3 + _
23:00:08 <lambdabot>     Found hole ‘_’ with type: a
23:00:08 <lambdabot>     Where: ‘a’ is a rigid type variable bound by
23:00:08 <lambdabot>                the inferred type of it :: a at Top level
23:00:16 <jle`> anyone knows what needs to be done for that to be Num a => a
23:00:22 <jle`> or some indicator that it has to be Num
23:00:26 <jle`> this has long been a mystery to me
23:01:13 <bitemyapp> huh.
23:01:21 <jle`> > [3, _]
23:01:22 <lambdabot>  Found hole ‘_’ with type: t
23:01:22 <lambdabot>  Where: ‘t’ is a rigid type variable bound by
23:01:22 <lambdabot>             the inferred type of it :: [t] at Top level
23:01:24 <jle`> that too
23:01:31 <bitemyapp> wtf
23:01:40 <jle`> it's always been this way
23:01:44 <bitemyapp> :t (3 :: Integer) + _
23:01:45 <lambdabot>     Found hole ‘_’ with type: Integer
23:01:45 <lambdabot>     In the second argument of ‘(+)’, namely ‘_’
23:01:45 <lambdabot>     In the expression: (3 :: Integer) + _
23:01:57 <bitemyapp> :t (3 :: Num a => a) + _
23:01:58 <lambdabot>     Found hole ‘_’ with type: a
23:01:58 <lambdabot>     Where: ‘a’ is a rigid type variable bound by
23:01:58 <lambdabot>                the inferred type of it :: a at Top level
23:02:38 <jle`> mysteries of ghc
23:02:47 <bitemyapp> jle`: I didn't know about this, this is actually really good to know because I was considering putting a clinic on typed holes in the book.
23:03:16 <jle`> yeah i think typed holes have problems with typeclass constraints
23:03:29 <jle`> :t return () >> _
23:03:30 <lambdabot>     Found hole ‘_’ with type: m b
23:03:30 <lambdabot>     Where: ‘m’ is a rigid type variable bound by
23:03:30 <lambdabot>                the inferred type of it :: m b at Top level
23:03:33 <jle`> no Monad m => ...
23:03:44 <bitemyapp> jle`: hrm. I think you might be right. That's kind of a problem.
23:04:29 <jle`> can't we just call it a feature
23:05:44 <bitemyapp> jle`: I'm kinda bothered. I really wanted to put that in the book.
23:05:49 <bitemyapp> jle`: but I can't now because it's yet another noobie trap.
23:06:04 <jle`> it's still useful though
23:06:10 <jle`> for things not involving typeclasses
23:06:13 <bitemyapp> jle`: not to new people.
23:06:23 <jle`> i think it'd still be
23:06:26 <bitemyapp> jle`: you really can't give new people unreliable/misleading diagnostic tactics.
23:06:31 <jle`> > "hello" ++ _
23:06:32 <lambdabot>  Found hole ‘_’ with type: [GHC.Types.Char]
23:06:54 <jle`> maybe ask around for people who would know
23:07:18 <jle`> time for a reddit post?
23:07:25 <bitemyapp> jle`: trac ticket?
23:07:32 <bitemyapp> this feels like a trac ticket to me.
23:07:48 <jle`> maybe there's something we're missing
23:12:52 <Hijiri> > _ :: Num a => a
23:12:54 <lambdabot>  Found hole ‘_’ with type: a1
23:12:54 <lambdabot>  Where: ‘a1’ is a rigid type variable bound by
23:12:54 <lambdabot>              an expression type signature: GHC.Num.Num a1 => a1
23:12:56 <Cale> Does anyone know what state DPH is in at the moment?
23:13:22 <bitemyapp> Cale: moribund last I heard. Begging forgiveness if I'm wrong.
23:13:30 <Cale> :S
23:13:35 <Cale> I really want more progress there
23:13:46 <Cale> It's very promising
23:13:50 <bitemyapp> I think Simon commented on it at one point.
23:13:55 <bitemyapp> During an interview or something.
23:14:39 <bitemyapp> I think part of the problem was relatively poor perf compared to the other solutions and the apparent work required to make a practical solution in that design space.
23:14:45 <Cale> I haven't heard much about it since 7.4 came out
23:16:09 <kadoban> jle`, bitemyapp: https://ghc.haskell.org/trac/ghc/ticket/9479 found this ticket while looking up what any of that meant :)
23:16:57 <kadoban> Or maybe that's slightly different…
23:17:17 <jle`> that sounds like that's exactly it kadoban
23:17:18 <bitemyapp> kadoban: nah that seems to be it.
23:17:50 <kadoban> Ah good
23:18:17 <jle`> ty
23:19:09 <bitemyapp> kadoban: thanks :)
23:19:38 <kadoban> 'welcome. Thanks for mentioning that feature. Never knew it existed, and sounds pretty badass actually…even badasser if your suggestion gets in there somehow.
23:20:05 <EvanR> is there a channel for cabal help
23:24:13 <nilg> Is there a way to express that that type class B "inherits" type class A, in the sense that for all a if (A a) then (B a)?
23:24:43 <nilg> where A a and B a are type constraints of course...
23:25:12 * hackagebot timestamper 1.0 - Read standard input and prepend each line with a timestamp  http://hackage.haskell.org/package/timestamper-1.0 (kisom)
23:25:56 <EvanR> nilg: class Semigroup a => Monoid a where
23:26:28 <EvanR> all monoids are semigroups
23:27:22 <quchen2_> There's no inheritance here, you have to specify parent classes explicitly.
23:27:54 <quchen2_> And I'm not sure inheritance is a good word for it anyway, because it's mostly used in an OOP context.
23:28:22 <bitemyapp> is the bytes count that `:set +s` reports considered reliable?
23:29:03 <EvanR> nilg: class B a => A a where i think satsifies the second part of your question, but its not really inheritance
23:29:37 <nocturne777> I do not understand how sequence works actually. on the surface I sort of understand, but I do not understand why this code is valid "sequence [(> 4), (< 10), odd] 7"
23:30:00 <shachaf> nocturne777: Do you not understand because you expect it to be invalid?
23:30:39 <nocturne777> shachaf: probably
23:30:57 <shachaf> Why do you expect it to be invalid?
23:31:33 <nocturne777> like why is "sequence [(> 4), (< 10), odd]" returns "a -> [Bool]"
23:31:47 <nocturne777> I mean those are partially applied functions
23:32:00 <HeladoDeBrownie> @type sequence
23:32:01 <lambdabot> Monad m => [m a] -> m [a]
23:32:05 <HeladoDeBrownie> m ~ (e ->)
23:32:14 <HeladoDeBrownie> does that give you a hint?
23:32:37 <nocturne777> HeladoDeBrownie: yes, I looked at the type signature too
23:32:50 <HeladoDeBrownie> also noting what i said right after
23:33:15 <HeladoDeBrownie> let's do the substitution
23:33:23 <HeladoDeBrownie> [e -> a] -> e -> [a]
23:33:35 <nocturne777> list of monads become monad that has a list
23:34:26 <jle`> not quite a "list of monads", but yeah
23:34:38 <jle`> [Maybe a] -> Maybe [a]
23:34:44 <jle`> [IO a] -> IO [a]
23:34:47 <EvanR> a fistful of monads
23:34:52 <EvanR> for a few monads more
23:34:52 <jle`> [Either e a] -> Either e [a]
23:35:17 <jle`> [r -> a] -> (r -> [a])
23:35:24 <jle`> or in infix form
23:35:34 <jle`> [(->) r a] -> ( (->) r [a] )
23:36:49 <acetoline> Monad Lisa
23:37:33 <nocturne777> I understand this simple example: sequence [getLine, getLine]
23:38:00 <jle`> do you follow the types, though?
23:38:07 <jle`> do you see why the types fit together?
23:38:20 <EvanR> in the example the r and a are all the same so it might be confusing
23:38:36 <EvanR> i mean all rs are the same, and all a/b are the same
23:39:05 <ttt_fff> suppose I wanted the most dumbass "submit form" + store with haskell backend to a file, what should I use?
23:40:18 <randir> Anyone here have experience with CSRF tokens?
23:40:58 <EvanR> dont ask to ask
23:41:16 <shachaf> Lots of people, I'm sure.
23:44:20 <monochrom> I don't.
23:44:29 <monochrom> (I answer to not answer :) )
23:45:20 <bjobjo>    
23:46:45 <ttt_fff> monochrom: is this the "be so incompotent at job XYZ that they will never ask you to do XYZ again" trick?
23:46:59 <ttt_fff> like "oh, you want me to grab lunch? I hear everyone likes vegetarian"
23:48:13 <glguy> Maybe he just wanted to know if many people knew about them or not as a survey
23:48:17 <dulla> what is with all the e's
23:51:33 <ttt_fff> so I'm trying to build a scanner with an ipad mini + macbook pro + haskell
23:51:39 <ttt_fff> this would be a $2500 scanner
23:51:53 <ttt_fff> and apparently you can not capture _still imge_ at a higher resolution than _video resolution_ in javascript
23:51:57 <ttt_fff> *WTF*
23:52:05 <ttt_fff> this is porbably haskell-blah material I guess
23:52:17 <dulla> then supersample a video input, ttt_fff
23:52:46 <ttt_fff> that sounds too much work, I wanted somethig simple with haste + happstack, not image processing magic
23:56:59 <nocturne777> why is something like this possible "do  m <- (+2) .."?  is it because partially applied functions are monads as well?
23:58:14 <EvanR> all functions have a monad instance
23:58:40 <Saizan> nocturne777: (r ->) is a monad for every r
