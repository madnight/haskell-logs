00:02:06 <EvanR> johnw: pong
00:02:16 <johnw> EvanR: did you resolve your problems with fsnotify?
00:02:39 <EvanR> if i remember correctly, the reported events in osx were wonky?
00:02:45 <johnw> how so?
00:02:57 <EvanR> i was mainly asking you, that was a while back
00:03:02 <johnw> oh, hehe
00:03:06 <johnw> I'm just trying to use it now
00:03:34 <EvanR> if you dump the fs events, youll notice very interesting results for something simple like touch or echoing to a file
00:03:43 <EvanR> or text editor save
00:03:56 <johnw> i did, but I didn't notice anything interesting
00:04:04 <EvanR> maybe they fixed it all
00:08:13 * hackagebot hwsl2 0.2.0.0 - Hashing with SL2  http://hackage.haskell.org/package/hwsl2-0.2.0.0 (srijs)
00:08:13 * hackagebot network-attoparsec 0.11.0 - Utility functions for running a parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.11.0 (solatis)
00:24:51 <amar> Hi
00:38:11 <mniip> is there a more fancy way of writing
00:38:12 <mniip>  uncurry (flip (,))
00:38:56 <mniip> oh I know
00:39:26 <johnw> (,) . flip?
00:39:34 <mniip> hm?
00:39:41 <mniip> that does something else
00:40:45 <mniip> @pl \x -> f <*> (const x)
00:40:45 <lambdabot> (f <*>) . const
00:41:05 <mniip> that's pretty boring
00:43:00 <mniip> (const (f <*>)) <*> const
00:54:53 <orzo> what's a good fast lookup structure to use for SockAddr keys?
01:02:09 <edwardk> mniip: well, using one of the categories packages its usually 'swap'
01:02:31 <mniip> edwardk, that's boring
01:02:54 <mniip> I'm trying to introduce useless complexity
01:02:56 <edwardk> :t Data.Tuple.swap
01:02:57 <lambdabot> (a, b) -> (b, a)
01:03:03 <edwardk> ^- sorry base has you covered
01:03:35 <gfixler> to anyone who's dug into the interals of GHC, how is it?
01:03:54 <gfixler> is an example of beautiful, clean, compact code, or a 20-year-oldcluster?
01:04:08 <gfixler> I've been curious for a long time now
01:04:31 <edwardk> gfixler: it is a glimpse inside the minds of several madmen after they've been thrown in a blender
01:04:38 <gfixler> :)
01:04:59 <edwardk> amazing vistas littered with the corpses of graduate students long gone
01:05:06 <gfixler> haha
01:05:24 <gfixler> if we lost it, how long would it take us to rebuild it?
01:06:04 <edwardk> probably several years
01:06:15 <gfixler> hmmm
01:06:31 <gfixler> I've also wondered if it's possible for an enterprising hobbyist to make a subset of it
01:06:38 <edwardk> there is a lot of distributed knowledge about what went into all the different parts, and if folks started rebuilding they;d have all sorts of second system problems ;)
01:06:43 <gfixler> in the way that everyone makes their own lisp in 3 nights of screwing around
01:06:55 <gfixler> (except me; I need to get on that)
01:07:44 <edwardk> well, lisp/scheme have nothing like haskell's type system. that type system makes it tricky to get a haskell compiler bootstrapped. there is a paper/codebase for "typing haskell in haskell" that gets you some of what you need to know
01:08:01 <edwardk> but it doesn't generate an intermediate representation, it stops at type checking
01:08:13 <edwardk> and for more or less haskell 98, though there is a repo for haskell 98 + MTPCs
01:08:33 <Gurkenglas> I have a function ((a -> (a, b)) -> IO b) and a bunch of functions (a -> (a,b)) to be perhaps made more easily composable. What monad is appropriate, and how should I have deduced that?
01:08:33 <edwardk> doing type checking is a bit tricky because you need to elaborate the code as you check
01:08:42 <edwardk> once you get the 'trick' it is pretty straightforward
01:09:10 <gfixler> any good reads on the way to getting this trick?
01:09:12 <mniip> [12:05:22] <gfixler> in the way that everyone makes their own lisp in 3 nights of screwing around
01:09:23 <mniip> I made an untyped lambda calculus interpreter once
01:09:28 <mniip> it somehow was a list interpreter also
01:09:30 <mniip> lisp
01:10:09 <gfixler> mniip: I'd like to give that a go one day, for the learning
01:10:13 <gfixler> it doesn't seem too overbearing
01:10:25 <gfixler> ./compiler/simplCore/OccurAnal.hs
01:10:26 <Gurkenglas> (In the sense of, what monad transformer combination gives me what I need? Hmm, maybe I should just write a manual monad instance and worry about the transformer stuff later...)
01:10:30 <gfixler> hmmm... madmen indeed
01:10:46 <edwardk> gfixler: basically the trick is to produce the core / witness of correctness as you typecheck, e.g. something like https://github.com/ermine-language/ermine/blob/master/src/Ermine/Inference/Type.hs#L443
01:11:05 <edwardk> Gurkenglas: (a -> (a, b)) looks like State a b to me
01:11:16 <gfixler> edwardk: I feel like you were talking about that in your recent typeclasses vs. talk
01:11:18 <edwardk> so you can compose those monadic actions
01:11:25 <gfixler> I at least remember you mentioning witnesses
01:11:32 <edwardk> gfixler: well, different kind of witness
01:11:37 <gfixler> ah
01:11:42 <edwardk> gfixler: its still an evidence based approach
01:11:51 <Gurkenglas> edwardk, oh, of course! The IO b thing is irrelevant to that.
01:12:22 <ibid> fr33domlover: yes?
01:13:14 <mniip> gfixler, have you seen AnalEnv?
01:13:28 <mniip> especially virgin :: AnalEnv -> Bool
01:13:51 <gfixler> mniip: heavens, no
01:14:23 <mniip> oops
01:14:25 <mniip> ae_virgin
01:14:43 <gfixler> is graph reduction an iterative thing?
01:14:55 <gfixler> does it keep going around and around until it can't reduce anymore?
01:15:19 <mniip> 'graph reduction'?
01:17:16 <ibid> gfixler: yes, like all reduction
01:17:32 <ibid> mniip: the basic technique for implementing lazy evaluation
01:17:53 <gfixler> I felt like it must be, but was curious
01:17:57 <mniip> ah
01:18:25 <mniip> wait what
01:18:42 <mniip> untyped lambda calculus is totally not interative
01:18:49 <ibid> gfixler: or rather, graph reduction by itself just specifies a way of representing terms and a rule of reduction.  it does not compel you to do any reductions
01:18:50 <mniip> ugh
01:18:59 <mniip> untyped lambda calculus reduction is totally not iteratiev
01:19:27 <ibid> gfixler: but usually one is aiming for the WHNF, which forces iterative behaviour
01:20:00 <gfixler> ibid: I wish I had a graph of dependencies on learning this stuff
01:20:06 <gfixler> what to read, and when
01:20:13 <gfixler> order, prerequisites
01:20:28 <gfixler> I'm always doing the Homer Simpson method of studying martketing
01:20:33 <ibid> gfixler: i wrote an essay once on graph reduction that should not require much prequisities
01:20:46 <gfixler> Advanced Marketing -> Basic Marketing -> Dictionary "marketing"
01:20:55 <gfixler> ibid: is it online?
01:20:58 <ibid> also, does not tell the whole story, of course
01:21:00 <ibid> gfixler: yes
01:21:22 <ibid> http://users.jyu.fi/~antkaij/opetus/okp/2010/luennot/laziness.pdf
01:21:28 <gfixler> I'd just keep on reading if all of this stuff was in order
01:21:46 <gfixler> I'm always getting to page 2 of things and realizing I need 5 more large things before I'll understand
01:23:10 * hackagebot Rasterific 0.5.0.3 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.5.0.3 (VincentBerthoux)
01:25:51 <Gurkenglas> Oh, MonadState offers exactly what I want, including the ((a -> (a, b)) -> IO b)
01:38:05 <mniip> what
01:38:23 <mniip> can't instance decider figure out type synonyms or something?
01:41:23 <Gurkenglas> Was that confusion about me needing to explicitly refer to MonadState or were you talking to another?
01:48:12 * hackagebot lexer-applicative 1.0.0.1 - Simple lexer based on applicative regular expressions  http://hackage.haskell.org/package/lexer-applicative-1.0.0.1 (RomanCheplyaka)
02:07:23 <solatis> is it safe to upgrade the `network` package under windows when using the haskell platform?
02:12:35 <Gurkenglas> Damn compiler always confusing my syntax mixup with an attempt to use higher-level-than I syntax features.
02:14:19 <Gurkenglas> How do I copypaste an error out of a ghci.exe console?
02:14:58 <Xe> Gurkenglas: windows?
02:15:09 <Freundlich> In cmd.exe (I guess that's what you are using) you can do rightclick -> mark (or something), mark the text and then press enter.
02:15:20 <Gurkenglas> Xe, yes
02:15:36 <Xe> yeah that
02:15:41 <Xe> what Freundlich said
02:15:42 <Gurkenglas> Nah I doubleclicked on the hs file and it opened a ghci.exe console
02:15:51 <Xe> screenshot it
02:15:56 <Gurkenglas> ._.
02:15:56 <Xe> alt-printscreen
02:16:13 <Gurkenglas> I knew something :D
02:16:19 <Gurkenglas> http://lpaste.net/120884
02:16:56 <Gurkenglas> Where am I to upload screenshots?
02:18:04 <solatis> imgur.com is a solid place
02:18:24 <naevathecat> Second imgur. It's pretty no nonsense
02:18:32 <solatis> ghci.exe console is mingw/
02:18:32 <LordBrain> Gurkenglas, you mean to runStateT there?
02:18:33 <solatis> ?
02:18:45 <solatis> or do you use it out of powershell?
02:18:58 <solatis> (powershell uses your right mouse button to copy)
02:19:01 <Gurkenglas> Oh, didn't paste the readOnly thing
02:19:23 <sdx23> Hi. I'm maintaining a list an repetitevely use elem on it, as well as sometimes adding elements. What is a more sensible structure for such a usecase?
02:19:24 <Gurkenglas> http://lpaste.net/120885
02:20:12 <Gurkenglas> solatis, rightclicks and mousewheel clicks dont do anything, looks like.
02:20:31 <solatis> in powershell, first select text, then right mouse click
02:20:49 <Gurkenglas> Dragging the left mouse does nothing.
02:20:58 <solatis> are you using powershell?
02:21:04 <Gurkenglas> Dunno
02:21:39 <Gurkenglas> Probably not, since your instruction don't work.
02:21:41 <LordBrain> @type find
02:21:42 <lambdabot> (a -> Bool) -> [a] -> Maybe a
02:21:49 <LordBrain> it takes a list
02:22:09 <Gurkenglas> [Player] is a list
02:22:44 <LordBrain> State [Player]
02:23:48 <LordBrain> State [Player] is something like ([Player],a) if i recall.
02:24:02 <Gurkenglas> ([Player] -> (a, [Player]))
02:24:48 <LordBrain> well anyway.. i don't see where you are giving htat to find
02:25:02 <Gurkenglas> http://i.imgur.com/k1cLiqn.png
02:25:49 <Gurkenglas> LordBrain, readOnly turns find ((==plrname) . name) into what can then be wrapped into a PlayerTransaction (Maybe Player)
02:26:37 <LordBrain> i se
02:29:05 <maybefbi> when you use a library like scotty, how do you  understand of the types?
02:29:15 <maybefbi> *understand the types
02:30:18 <maybefbi> do you read through the source code?
02:30:41 <bennofs> maybefbi: no, I usually only look at the haddocks
02:31:08 <maybefbi> what about type synonyms
02:31:32 <bennofs> maybefbi: they are expanded in the haddocks too
02:31:58 <maybefbi> bennofs: ok
02:33:17 <bennofs> maybefbi: for scotty, there is also https://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html which is nice to a quick overview
02:34:26 <maybefbi> bennofs: do you try to understand WAI and other dependencies before understanding scotty?
02:34:47 <bennofs> maybefbi: scotty can be used without WAI, it seems, so no need to understand that
02:35:10 <bennofs> maybefbi: (using scotty <port> $ do ....)
02:35:50 <maybefbi> ok
02:39:28 <Gurkenglas> To recap, http://lpaste.net/120885 causes http://i.imgur.com/k1cLiqn.png and I'd like to know what I did wrong
02:39:46 <LordBrain> Gurkenglas, getPlayer plrname = get >>= return . find ((==plrname) . name)
02:39:47 <LordBrain> works
02:40:32 <bennofs> Gurkenglas: it should work if you use `state` instead of StateT
02:40:41 <LordBrain> could use fmap
02:41:04 <bennofs> Gurkenglas: StateT is the monad transformer constructor. `state` is a constructor when you're using just State (not StateT)
02:42:05 <Gurkenglas> So that's what MonadState does, then. I thought it would be the slot to put my (PlayerTransaction String -> IO String) into.
02:42:23 <LordBrain> State is now defined as StateT s Identity
02:44:29 <Gurkenglas> Thanks.
02:47:13 <gfixler> let's say I ruined an operator in GHCi... is there a way to restore it?
02:47:24 <bennofs> gfixler: what do you mean by "ruined" ?
02:47:30 <gfixler> let (+) = whatever
02:47:49 <bennofs> gfixler: let (+) = Prelude.(+) (or whatever module you original got it from)
02:47:54 <gfixler> e.g. let (+) = (+) creates a bottom
02:48:01 <mauke> (Prelude.+)
02:48:03 <gfixler> bennofs: thanks - thought there'd be something like that
02:48:35 <bennofs> gfixler: ah, mauke is correct, the syntax would be (Prelude.+)
02:48:47 <gfixler> yeah, it's still an infix - interesting
02:48:58 <mauke> > 1 Prelude.+ 2
02:49:00 <lambdabot>  3
02:49:23 <mauke> > M.singleton "foo" 42 M.! "foo"
02:49:25 <lambdabot>  42
02:49:26 <gfixler> that was my next question - what if someone ruins lambdabot's (+)
02:49:33 <bennofs> gfixler: @undef
02:49:35 <mauke> there's an @undefine command
02:49:40 <gfixler> ah, that's right
02:49:52 <gfixler> I'll just stick to let-in
02:49:54 <mauke> more common is breaking f and x, though
02:50:01 <gfixler> let 2 > 3 = True in 2 > 3
02:50:04 <gfixler> > let 2 > 3 = True in 2 > 3
02:50:06 <lambdabot>  True
02:57:41 <nh2> does anybody remember what that tool was called that does what haddocks --hyperlink-source does, but with clickable code (jumps to definition)?
02:57:58 <nh2> like this page, but with go to definition: http://goto.ucsd.edu/~rjhala/Annot/hscolour/src/Language-Haskell-HsColour-CSS.html#
02:58:15 * hackagebot euler 0.1.0 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.1.0 (decomputed)
02:58:43 <nschoe> Hi fellow Haskellers :-)
03:01:54 <shock_one> Is there a library function to unwrap a monoid without knowing its exact type? Like I have something that can be either Sum or Product, and can get the number out of it.
03:02:23 <shock_one> *want to get the number.
03:03:06 <EvanR> Either (Sum a) (Product a) ?
03:03:29 <EvanR> Either (Sum Int) (Product Int) ?
03:03:29 <shock_one> No, I have a :: Monoid a.
03:04:05 <EvanR> a isnt necessarily a number
03:04:33 <orzo> you can use generics to extract Int out of any simple wrapper of it
03:04:39 <shock_one> OK, I know for sure that it's a number. Let it be a :: Monoid Integer. Also I know that it's either Product or Sum.
03:05:00 <EvanR> ok, so rearrange it so its Either (Sum Int) (Product Int) ;)
03:05:06 <EvanR> then you can do it
03:05:19 <EvanR> and itll be more right, according to what you said you know
03:05:27 <orzo> Monoid is a type class, you keep treating it like a type, not sure if you realize
03:05:53 <EvanR> yes getting to that afterward
03:06:06 <EvanR> i think were not done hearing all the details
03:07:18 <quchen> Well, there is `coerce :: Coercible k a b => a -> b`, but it's hardly intended for this kind of thing
03:07:29 <quchen> See http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Coerce.html
03:08:06 <shock_one> OK, basically I have a function like that and want to treat last two cases universally. https://gist.github.com/shockone/1774ae48086a30a9a80d
03:08:46 <EvanR> its not universal, theres two specific cases
03:09:16 <EvanR> you handled them
03:09:32 <phadej> in http://youtu.be/hIZxTQP1ifo kmett discuss typeclasses, though the video is 2 hours long, I'd say it's worth looking
03:09:51 <phadej> you'll understand typeclasses better. Also why they are what they are.
03:10:12 <shock_one> Thank you, phadej
03:10:25 <phadej> at the end he shows http://hackage.haskell.org/package/reflection-1.5.1.1/docs/Data-Reflection.html
03:10:47 <EvanR> generics and reflection are probably not applicable to this situation
03:10:59 <phadej> using that you could turn `(+) , 0` into Monoid on Int in lexical scope - kind of
03:11:04 <shock_one> So, you guys are saying that's it's not worth using monoids and mappend instead of what I have?
03:11:33 <EvanR> youd have to start by wrapping them in Sum or Product
03:11:44 <EvanR> with a case
03:12:09 <orzo> eval (Expression f (Operands ns)) = coerce $ foldr mappend mempty $ map (f . eval) ns
03:12:10 <EvanR> im not sure what you hope to accomplish
03:12:13 <orzo> heh
03:12:38 <shock_one> I want to have one line instead of two almost identical lines.
03:12:52 <phadej> you could define data Monoid' a = { mappend' :: a -> a -> a, mempty' :: a } and pass it explicitly
03:13:03 <phadej> and using reify you could re-use Monoid combinators
03:13:11 <EvanR> ._.
03:13:23 <phadej> but as kmett points in his talk, it's not the most elegant solution
03:13:28 <EvanR> shock_one: your type has three cases, you have to have three cases in your case expression to do anything
03:13:57 <phadej> he also explains how you could try to workaround issues :)
03:14:00 <EvanR> theres no "apply this to all variants of my sum type" function
03:14:08 <EvanR> unless you make one, which you are
03:14:55 <EvanR> also, spelling out the separate lines probably looks way easier to read and understand than any possible generic, reflection, template haskell, existential anything you can come up with
03:15:22 <EvanR> case1, Addition, sum
03:15:28 <EvanR> case2, Multiplication, product :|
03:15:36 <orzo> :t Sum
03:15:37 <lambdabot> a -> Sum a
03:15:58 <phadej> hmm, for some reason Sum and Product aren't Functors in base
03:16:10 <phadej> otherwise you could just fmap things inside
03:17:12 <quchen> Sum and Product aren't really used for many things I think. Mostly Writer and foldMap for me.
03:17:12 <orzo> it wouldn't be terrible if he did up something using coerce
03:17:21 <EvanR> but... why??
03:18:10 <orzo> heh
03:19:22 <orzo> because he can and by gosh not so long ago it wasn't doable
03:19:51 <EvanR> how many extra lines of code will it take to do what youre saying
03:19:57 <orzo> iduno
03:20:09 <orzo> in theory he might have a whole bunch of other monoid cases he wants to add
03:20:34 <EvanR> going to say its a 0% chance
03:20:59 <lpaste> Kah0ona pasted “Getting an element in my list like datatype of a musical scale” at http://lpaste.net/120887
03:21:41 <shock_one> EvanR: you're right, only two monoids.
03:21:54 <EvanR> orzo: dont repeat yourself could be interpreted as dont use the same letter more than once, do we have an extension to help with that too?
03:22:00 <EvanR> deflate?
03:22:04 <Kah0ona> Oh neat bot :-)
03:23:50 <Kah0ona> if I have a list like datatype, is it possible to get the nth element out of it? I have a Scale type consisting of musical Notes
03:24:23 <EvanR> yes, thats the !! operator
03:24:27 <EvanR> :t (!!)
03:24:28 <lambdabot> [a] -> Int -> a
03:24:31 <Kah0ona> okay but it's not a list by the way
03:24:42 <orzo> Kah0ona: you need another argument to Scale
03:24:43 <Kah0ona> would that still work then?
03:24:46 <EvanR> you can easily write your own version of this
03:24:51 <EvanR> @src (!!)
03:24:51 <lambdabot> xs     !! n | n < 0 = undefined
03:24:51 <lambdabot> []     !! _         = undefined
03:24:51 <lambdabot> (x:_)  !! 0         = x
03:24:51 <lambdabot> (_:xs) !! n         = xs !! (n-1)
03:25:06 <EvanR> or dont use a list because if its 12 values, a list might not be the best
03:25:18 <Kah0ona> yeah but it can be less
03:25:22 <orzo> it should be noteAt :: Scale Note -> Int -> Note
03:25:47 <orzo> based on your definition of Scale and your idea that it be a Functor
03:25:50 <Kah0ona> (ie. a Major scale is a scale with a subset of the possible notes)
03:26:04 <Kah0ona> yeah i'm a novice, a functor seemed reasonable to me :)
03:26:09 <EvanR> very well, but why dont you use a list
03:26:37 <orzo> yeah, i sugest newtype Scale = Scale [Note]
03:26:46 <Kah0ona> yeah i contemplated that, but I thought it would be cool to make a custom data type for it? Or would you, in 'real life' just make a new type
03:26:48 <Kah0ona> aha thanks
03:26:50 <orzo> if you want it to be its own datatype
03:27:10 <Kah0ona> when would you want it to be its own datatype in this case orzo?
03:27:32 <Kah0ona> i would basically want to iterate over a scale, and, say, print out the note on a specific index or something
03:28:18 <orzo> i dont think i understand the question
03:28:32 <Kah0ona> well i'm basically contempalte what is the best way in such a situation
03:28:45 <Kah0ona> let scale be a list of notes using new type
03:28:47 <Kah0ona> or
03:29:02 <Kah0ona> do something like data Scale = ...
03:29:32 <orzo> newtype lets you define an interface specifically for Scale and forget the "implementation details" that it is actually just a list of Note
03:30:08 <Kah0ona> ok, so that sounds it would be well suited in my case then.
03:30:12 <Hamp-ster> What is haskell
03:30:32 <Kah0ona> wow it seems my question wasn't the most novice one here ;-)
03:30:39 <orzo> some dead mathematician
03:30:49 <EvanR> Kah0ona: its up to you to decide what restrictions you want to place on the type
03:30:51 <Hamp-ster> oh really?
03:31:20 <orzo> https://en.wikipedia.org/wiki/Haskell_Curry
03:31:29 <Hamp-ster> Haskell Curry was a logician, not 0athe0at5cian
03:31:35 <EvanR> Kah0ona: you can try something and if you dont like it go back and refactor.
03:31:44 <Kah0ona> yeah I will
03:31:57 <Kah0ona> also i'll read up some documentation as well
03:32:52 <EvanR> newtypes have a lot of use cases, for one, if you have a function which takes three Ints for three different purposes, you can make 3 newtypes so you dont accidentally swap the arguments
03:32:53 <Hamp-ster> " R0M=2(JT.TT.=A>P.K(-930<.L%92&47%LB1E0T6KE>0;NL4GEL+A6& P.*T1.T=37.,)IU.T.;&C =M.-R.:E.9$.KN?&$8F5%1OI.T8;74%BT%A- Q(=.$)#EA-0Q+,34C2F*#+C41.KRR-N<2M.BED(E#.IC7$G.CD&*+3Q3.6GD%+U7E/>.;5L?.0BHFL.C..&U$.9NQ17)4QAAR5L-K4.8.S.4:.6.QETU>N.'SKKMMHL>>FRPD.:FD*B7B<+;.6.A*#IL-.>$TI+.#CA85P.7$.'>?6AR..E21)I1
03:32:54 <Hamp-ster> HOL$0.@O>1(?.3,T%TN .>KD32P2.H,5R-<(.SKF#0QTH8$;; #)3.RJ29KG=+9BO)3EI.-:5B0'@E).Q<#U.58"<.J@RA.OFM/.(2S41U*L3K>.8.QH.7P2&.AQ9/(BJ* - &E/ <FL/K;.#EP4JJ6?UCRB.Q.QU.)*GOT.EEE0NO>-*F1<$1CL FD/$BSF.?(%)#+#/*P..=.MAH8"SM.U>P+(9.,%"G;5;TT;FH.1B.%6D.?>D,.@49+@E8.?.
03:32:56 <Hamp-ster> +6TO2#A.L.K4"ET(L;C@DL1<=)UKS$$ O<+J.J<R<666HU32:G96@/.+-3$?LC;P"BN4O/<@?G.B(THJ6@&O2>LM.NG;./.N9=9.LHAIA7,.'E+/>>.:*U>9@.K%0I 2J $S3.0,DQ 26:D54*U#A/=9)B"F4I<8G ..-J4K56.6RH .8;/.BI+4;J0T."96=FG'0.SPN%8L??/.?/&".%.<:0'LQ.F;1 @4=).R?/.;6MN8Q65G 83.";5*O I
03:32:58 <EvanR> @ops
03:32:58 <lambdabot> Maybe you meant: pl oeis docs
03:34:00 <orzo> hm, i've been doing that a lot lately, EvanR.  But my code is chock full of newtypes.  Good to know you approve
03:34:14 <EvanR> it could be cumbersome too
03:34:17 <Kah0ona> EvanR and Orzo, thanks
03:34:19 <orzo> :-P
03:34:39 <EvanR> requiring a newtype for that amounts to basically typing the code twice as a check
03:34:51 <EvanR> which seems dumb
03:34:55 <Kah0ona> yeah i'm just trying to see if i can build some musical haskell functions that automatically build major / minor scales and transposes them into different keys
03:35:28 <Kah0ona> it's fun though:)
03:35:29 <maybefbi> i need some help with this: http://lpaste.net/731379737338839040
03:35:46 <maybefbi> I want to call Network.HTTP.simpleClient from inside convert function
03:36:09 <maybefbi> but Network.HTTP.simpleClient . getResponseBody :: IO ()
03:36:19 <maybefbi> and convert function is pure
03:36:34 <mauke> so you need to change the type of convert
03:36:35 <orzo> goodnight
03:36:48 <EvanR> Kah0ona: the notes, ABCDEFGABC... can be seem as an additive group that has forgotten its identity
03:36:50 <maybefbi> mauke: but if i do that i will need to change the type of ActionM
03:37:04 <EvanR> the additive group of integers
03:37:06 <mauke> maybefbi: why?
03:37:46 <maybefbi> because then convert would be :: IO T.Text
03:37:46 <EvanR> Kah0ona: it could be interesting to expose it this way with your type. you can subtract any two notes to get an integer, and add an integer to a note to get another note
03:37:59 <mauke> maybefbi: go on
03:38:03 <Kah0ona> yes
03:38:04 <EvanR> Kah0ona: but they arent themselves "some number"
03:38:17 <EvanR> theres no distinguished one to "start" at
03:38:34 <maybefbi> mauke: because then convert would be :: IO T.Text and text is :: Text -> ActionM ()
03:38:50 <maybefbi> mauke: i will need to change the type of text
03:38:50 <Kah0ona> well I actually have some working functions that, given a Root note, will generate the subset of all possible notes that are in the major scale
03:39:07 <mauke> maybefbi: that doesn't follow
03:39:12 <Kah0ona> so i got it working, but yeah thanks for the advice
03:39:57 <mauke> maybefbi: t <- liftIO (convert pincode); text t
03:40:12 <phaazon> I can’t wrap my mind around netwire way to do FRP
03:40:20 <phaazon> it sounds so messy
03:40:27 <maybefbi> mauke: how did you know we can liftIO there?
03:40:40 <maybefbi> mauke: can we liftIO anywhere?
03:41:03 <mauke> maybefbi: first I checked http://hackage.haskell.org/package/scotty-0.9.1/docs/Web-Scotty.html#t:ActionM
03:41:18 <mauke> this tells me ActionM is an alias for ActionT Text IO
03:41:23 <phaazon> I poll events from IO before running the main wire, something like IO [MyEvent] ; then the first wire has time Wire s e m (Event [MyEvent]) () ; I have no idea how I’m supposed to deal with that the correct way
03:41:29 <mauke> then I clicked on ActionT: http://hackage.haskell.org/package/scotty-0.9.1/docs/Web-Scotty-Internal-Types.html#t:ActionT
03:41:32 <phaazon> I’m not even sure I need netwire
03:41:43 <phaazon> since when, I just foldl the events
03:41:46 <mauke> this says (MonadIO m, ScottyError e) => MonadIO (ActionT e m)
03:41:47 <fr33domlover> ibid, I'm a haskell beginner and I wonder if posts like "my beginning with haskell" would fit into the planet
03:41:48 <phaazon> generating a new version of my application
03:41:58 <mauke> i.e. if m is an instance of MondIO, so is ActionT e m
03:42:12 <mauke> our m is IO, and IO is (trivially) an instance of MonadIO
03:42:16 <fr33domlover> ibid, could maybe help people understand the beginner pov etc.
03:42:18 <maybefbi> mauke: wow ok
03:42:21 <mauke> oh, and MonadIO provides the liftIO function
03:42:37 <mauke> for IO it looks like this: instance MonadIO IO where liftIO x = x
03:42:46 <mauke> (hence "trivial")
03:43:14 <maybefbi> mauke: hmm i guess i need to pay attention to tyep definitions
03:43:14 <mauke> maybefbi: this is used for monad transformers that wrap IO somehow
03:43:24 <mauke> makes it easy to embed arbitrary IO actions
03:43:51 <mauke> so seeing ActionM = ActionT Text IO was already a good hint that it's probably an instance of MonadIO
03:44:10 <maybefbi> yeah
03:44:55 <maybefbi> mauke: i still am not fluent in monad transformers. i understand the definitions
03:45:30 <maybefbi> mauke: it doesnt catch my eye i guess
03:45:59 <mauke> it's a common pattern for frameworks that provide their own top-level type
03:46:24 <mauke> you just know it's going to wrap IO because it's so common to need to do IO in your app
03:46:25 <maybefbi> ok
03:46:40 <mauke> source: I've done some xmonad development
03:47:23 <maybefbi> i see
03:54:10 <ibid> fr33domlover: it would probably qualify
03:58:01 <fr33domlover> ibid, ok thanks. I just need to figure out how to filter just my haskell relates posts now...
04:02:26 <lpaste> Kah0ona pasted “Version 2 of the notes, how to make majorScale of type: Note -> Scale? ” at http://lpaste.net/120891
04:03:09 <Kah0ona> It now technically works, but it doesn't seem to use the newtype Scale = Scale [Note], rather it is working with [Note]
04:08:43 <xkb> https://gist.github.com/svdberg/35c0d4add5952a19c52c <= Line 17 I want to parse either a Command or a string.. Any idea how to do this?
04:09:24 <EvanR> Kah0ona: you mean, you operate on the unwrapped list?
04:13:48 <Kah0ona> yeah I should probably operate on the wrapped list
04:14:31 <EvanR> another use of newtypes is to only expose the operations on the newtype
04:14:43 <EvanR> which of course must be implemented by unwrapping the type
04:21:09 <gfixler> ibid: that was a good read - thanks
04:25:06 <shlevy> Is dealing with streams still down to pipes vs conduit?
04:25:10 <Kah0ona> ok i got it :-) thanks for the help EvanR
04:31:36 <bennofs> shlevy: there is also io-streams now (though that is even more different I think and less general)
04:33:20 * hackagebot ArrowVHDL 1.0 - A library to generate Netlist code from Arrow descriptions.  http://hackage.haskell.org/package/ArrowVHDL-1.0 (brettschneider)
04:33:34 <gfixler> ~/ghc (master)$ find -iname '*.c' -exec cat {} \; | wc -l
04:33:35 <gfixler> 68247
04:33:56 <gfixler> ~/ghc (master)$ find -iname '*.hs' -exec cat {} \; | wc -l
04:33:56 <gfixler> 473908
04:34:06 <gfixler> that's a lot of code
04:36:44 <maybefbi> how do i deserialize in aeson the value of a key which is a reserved keyword in Haskell?
04:36:57 <maybefbi> the corresponding datatype cant have the reserved keyword
04:38:27 <maybefbi> i cannot use the derivegeneric in aeson in such a case can I?
04:38:40 <xkb> I have this error msg: Couldn't match expected type 'Data.Text.Lazy.Internal.Text'
04:38:40 <xkb> with actual type 'Data.Text.Internal.Text' How do I convert between the two Text representations?
04:39:50 <maybefbi> xkb: use fromStrict
04:40:15 <maybefbi> unless of you are willing to change the types to lazy in the offending place
04:40:20 <maybefbi> *of course
04:41:22 <lf94> How would you guys improve this? https://github.com/lf94/g_challenges/blob/master/04/dencrypt.hs
04:42:14 <dibblego> lf94: there is some repetition in rot13 and unrot13 that can be factored out
04:43:34 <lf94> Yea
04:43:40 <dutchie> is there some (hackage/standard library) function that takes a UTCTime and turns it into some pretty "x ago" thing? not averse to writing my own, just don't want to if there's already something
04:43:43 <lf94> I wasn't sure if it was enough to consider that
04:43:52 <FreeFull> rot13 = unrot13
04:44:00 <lf94> hm?
04:44:01 <lf94> no
04:44:04 <dutchie> well, i guess it'd be a DiffTime anyway
04:44:05 <lf94> (+) vs (-)
04:44:14 <mlen> FreeFull: only when you assume that charset length is 26
04:44:19 <mlen> and that's not the case here
04:44:34 <FreeFull> Well, that's not rot13 as rot13 is usually defined
04:44:35 <mlen> but actually what lf94 done here is not rot13
04:44:47 <lf94> it is add 13 to char B)
04:45:12 <lf94> my bad
04:45:17 <lf94> didn't even occur to me
04:45:25 <lf94> Sorry FreeFull you are right :)
04:45:51 <mlen> if you add 13 to Z you should get M
04:50:01 <xkb> https://gist.github.com/svdberg/35c0d4add5952a19c52c <= Line 17 I want to parse either a Command or any string.. Any idea how to do this?
04:50:30 <bennofs> xkb: does that not work?
04:50:55 <lf94> How would you do "if c is with [a..z]" ?
04:51:02 <lf94> Making this real rot13
04:51:07 <xkb> bennofs: not as I expect :)
04:51:16 <lf94> within*
04:51:23 <bennofs> xkb: what is the problem?
04:52:29 <gfixler> lf94: if 'a' <= c && c <= 'z'
04:52:42 <lf94> that's how i'd do it in C
04:52:49 <lf94> is there no awesome haskell way
04:53:03 <gfixler> elem?
04:53:08 <gfixler> elem c ['a'..'z']
04:53:08 <bennofs> lf94: c `elem` ['a'..'z']
04:53:16 <bennofs> lf94: but that is less efficient :|
04:53:35 <bennofs> @hoogle isAlpha
04:53:36 <lf94> isn't that lazy or something
04:53:37 <lambdabot> Data.Char isAlpha :: Char -> Bool
04:53:37 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
04:53:39 <xkb> bennofs: I think its the string
04:53:47 <xkb> parseCommand gives a Parser
04:53:54 <xkb> string seems to give a ByteString
04:54:04 <xkb> and I guess <|> needs two Parsers
04:54:12 <lf94> ah, isAlpha works too :)
04:54:27 <bennofs> xkb: ah, so you get a compile error? Sorry I don't have a compiler in my head :) (attaching the error message in this case really helps the people trying to help you)
04:55:20 <bennofs> xkb: ok, what do you think the type of parseInput should be?
04:56:03 <gfixler> lf94: also isLetter - not sure what the difference is
04:56:06 <xkb> bennofs: L.Text -> Either String Command
04:56:17 <xkb> at least, thats what I want
04:56:28 <bennofs> xkb: ok, but (<|>) :: Parser a -> Parser a -> Parser a
04:56:43 <bennofs> xkb: so you need to lift both parseCommand and string s to Parser (Either String Command)
04:56:46 <xkb> ah
04:57:03 <xkb> so parseCommand is Parser a already
04:57:13 * xkb checks ghci
04:57:18 <bennofs> xkb: parseCommand is Parser Command
04:57:42 <Gurkenglas> http://lpaste.net/1810186547551535104 yields http://imgur.com/uV7Bmxi . Explain what I did wrong with the modify pls?
04:59:29 <bennofs> Gurkenglas: you cannot use modify in io
04:59:57 <Gurkenglas> What do you mean by using it in io?
05:00:16 <xkb> bennofs: string is BS -> Parser BS
05:00:18 <bennofs> Gurkenglas: ah, sorry, should have read the code fully before answering :D
05:00:23 <xkb> so the a cannot be unified?
05:01:13 <bennofs> xkb: yes. but you can easily get from Parser Command to Parser (Either a Command)   and from Parser BS to Parser (Either BS b), and those can be unified
05:01:23 <bennofs> xkb: with fmap
05:01:42 <xkb> Functor fmap
05:02:00 <Gurkenglas> (Other comments on style and abstractions and so on are also welcome, but I'm already seeing the things lpaste says)
05:02:16 <Gurkenglas> (As in, I noticed them through reading it)
05:03:10 <xkb> bennofs: thanks for the pointers. Appreciated.
05:04:56 <xkb> bennofs: last question: If I wanted to add a parameter to the verbs (New etc..) would I still use the string combinator?
05:05:22 <bennofs> xkb: yes, why not?
05:05:46 <xkb> because I want to "bind" two things
05:05:47 <bennofs> xkb: btw, the module Data.Attoparsec.Char8 seems to be deprecrated
05:06:07 <bennofs> xkb: you can use applicative syntax for that
05:07:01 <bennofs> xkb: like string "New" >> (New <$> parserForArgumentOfNew)
05:07:12 <xkb> ahh
05:07:21 <bennofs> xkb: (that wasn't even applicative. (<$>) is just fmap again :)
05:07:50 <init> >> is monadic, *> would do it, too! :P
05:08:02 <bennofs> xkb: for multiple arguments, you need applicative: string "New" >> (New <$> parseArg1 <*> parseArg2)
05:08:24 <bennofs> init: yes, I was trying to stick as much as possible to the original code :)
05:08:37 <xkb> cool
05:08:57 <init> oh, I see
05:09:15 <youhan> Excuse me, but why doesn't (+2).(*3) 4 work? Though (+2) $ (*3) 4 works
05:09:33 <Gurkenglas> Okay, I found the problem. Apparently, replacing the [Player plrname 0] by [Player plrname 0 [] []] fixes both problems. Question: !?
05:09:43 <init> youhan: that's the same as "(+2) . ( (*3) 4 )", and the second param isn't a function
05:09:45 <dibblego> youhan: because it parses as (+2).((*3) 4)
05:09:46 <init> @type (.)
05:09:46 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:09:58 <Gurkenglas> Why is there action at a distance here?
05:10:00 <dibblego> youhan: typical is (+2).(*3) $ 4
05:10:08 <init> youhan: you probably want ((+2) . (*3)) 4 or ((+2) . (*3) $ 4)
05:11:04 <youhan> Oh I see the problem
05:11:06 <youhan> thanks
05:15:23 <wz1000> @src liftA2
05:15:23 <lambdabot> liftA2 f a b = f <$> a <*> b
05:16:26 <wz1000> Why doesn't  (\a b -> const <$> b <*> a) behave the same way as liftA2 (flip const)?
05:16:52 <wz1000> When applied to IO actions, the sequencing is the other way round.
05:17:01 <bennofs> wz1000: it would be flip (liftA2 const)
05:17:33 <bennofs> wz1000: liftA2 (flip const) = \a b -> flip const <$> a <*> b     /= (\a b -> concat <$> b <*> a)
05:18:07 <wz1000> bennofs: Oh right
05:19:08 <lf94> Ok guys, I have real rot13 now
05:19:18 <lf94> Looks like crap imo, but that's why you guys are here to help me with B)
05:19:28 <lf94> https://github.com/lf94/g_challenges/blob/master/04/dencrypt.hs
05:26:09 <balor> Where can I find documentation on the keyword "loop" as in "loop f = ... loop f" used in https://wiki.haskell.org/Simple_Servers ?
05:27:04 <Stratege__> balor loop is not a keyword, it's just a function defined in the example which calls itself.
05:28:22 * hackagebot ArrowVHDL 1.1 - A library to generate Netlist code from Arrow descriptions.  http://hackage.haskell.org/package/ArrowVHDL-1.1 (brettschneider)
05:29:26 <wz1000> lf94: Looks fine, though you could get rid of the pattern guards in add13_
05:30:23 <mpickering> Anyone know any libraries on hackage with bindings to a link minifying api
05:31:13 <mpickering> shortener rather
05:36:25 <lf94> wz1000: and replace with what?
05:37:29 <Gurkenglas> Are functions named wordWord or wordword?
05:37:45 <lf94> wordWord
05:38:23 * hackagebot highlighter2 0.2.3 - source code highlighting  http://hackage.haskell.org/package/highlighter2-0.2.3 (chemist)
05:39:00 <balor> Stratege, ah, so a function can be named with a space between parts?
05:39:24 <balor> d'oh, no sock is a parameter in this case!
05:41:46 <wz1000> lf94: Use mod instead of manual bound checking. Your Integers would just wrap around!
05:42:10 <lf94> I'm reinventing rot13 B)
05:42:47 <wz1000> That's how you would get rid of the pattern match
05:43:21 <lf94> heh
05:43:35 <lf94> wz1000 I'm unaware of the conventional uses of mod
05:43:47 <lf94> oh nevermind
05:43:48 <lf94> just clicked
05:43:49 <lf94> derp
05:48:39 <IP92> is this any good for swapping 2 rows in a matrix?
05:48:40 <IP92> http://pastebin.com/cTXTC54G
05:51:28 <wei2912> @oeis 3,7,31
05:51:30 <lambdabot>  Mersenne primes (of form 2^p - 1 where p is a prime).[3,7,31,127,8191,131071...
05:51:59 <wei2912> @oeis 3,7,31,211
05:52:00 <lambdabot>  Euclid numbers: 1 + product of the first n primes.[2,3,7,31,211,2311,30031,5...
06:00:57 <vinc> short question: what is split-objs? googling does not turn up a noob explanation (for me anyway)
06:07:06 <ph88> how can i pattern match a string [Char] that has at least 2 characters? i tried (x:s:xs)
06:07:52 <Clint> ph88: and what happened?
06:08:17 <ph88> Couldn't match expected type ‘[Char]’ with actual type ‘Char’     In the second argument of ‘(:)’, namely ‘s’     In the expression: x : s
06:09:09 <ph88> what does x and xs stand for anyway?
06:09:49 <ChristianS> ph88: first element and rest of a list
06:10:14 <ph88> what's a good letter for second element ?
06:10:47 <wz1000> ph88: xs is like the plural of x
06:11:49 <athan> ph88: x is the element that's captured in the pattern match on the outer-most part of the list structure, and xs is the rest :)
06:12:25 <KaneTW> @opus 4,5,9
06:12:28 <lambdabot>  Decimal expansion of Pi (or, digits of Pi).[3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,...
06:12:29 <ph88> this works now   getFirst (x:s:xs) = x ++ s
06:13:49 <Clint> ph88: that means that x and s are lists and xs is a list of lists
06:14:17 <wz1000> @opus 1,3,7,12,18
06:14:19 <lambdabot>  Sequence and first differences (A030124) together list all positive numbers ...
06:14:36 <wz1000> Clever
06:14:42 <phaazon> is there a #netwire
06:14:43 <phaazon> ?
06:15:04 <phaazon> I’d like to learn the better way to handle IO events within netwire
06:15:22 <ph88> Clint: i wanted x and s to be the first two characters of a [Char]   how do i get this right ?
06:15:42 <wz1000> @botsnack
06:15:42 <lambdabot> :)
06:17:03 <Clint> ph88: well you can't append a Char to a Char with ++
06:17:14 <Clint> so don't do that
06:17:14 <ph88> Clint: i wanted x and s to be the first two characters of a [Char]   how do i get this right ?
06:17:18 <ph88> sorry double
06:18:24 <ph88> fixed    getFirst (x:s:xs) = [x,s] getFirst _ = "XX"  main = do   bla <- getLine   print $ getFirst bla
06:19:32 <ph88> how come i don't have to use fmap here or some other monad thing ?
06:19:52 <ph88> i expect since bla is not pure that i can not enter it into the getFirst function just like this ... but i can ?!
06:23:25 * hackagebot caramia 0.7.2.0 - High-level OpenGL bindings  http://hackage.haskell.org/package/caramia-0.7.2.0 (Adeon)
06:24:52 <ibid> gfixler: :)
06:38:07 <kranius> ph88: the 'bla' variable has type String
06:40:42 <NightRa> cabal fails to install everything with the error: "setup-Simple-Cabal-1.18.1.5-x86_64-windows-ghc-7.8.4.exe: does not exist".
06:40:51 <NightRa> How can it be fixed?
06:41:38 <kranius> ph88: the do notation provides the (<-) operator, called 'slurp', it call pull values from a wrapper, in this case IO
06:41:40 <ph88> kranius: why not IO::String ?
06:41:47 <ph88> oh ok
06:41:56 <hpc> it's not really an operator, just part of the syntax
06:42:16 <ph88> slurp sounds funny
06:42:21 <ab9rf> <- is magic fairy dust, not an operator :)
06:42:34 <ab9rf> "slurp"?
06:42:45 <ph88> like kranius said
06:42:56 <hpc> also people generally call it bind
06:43:07 <hpc> (because it's basically (>>=))
06:43:16 <ab9rf> for some reason that makes me think of futurama
06:43:41 <hpc> probably slurm
06:43:51 <ab9rf> that's likely it
06:44:33 <chrisdone> i've never heard it called slurp
06:45:35 <chrisdone> hpc: slurm is the solution
06:46:30 <NightRa> Just had to play with the path. solved
06:46:59 <kranius> sorry I'm not being precise enough
06:48:13 <gigabytes> Hi all
06:48:15 <charlie> hi gigabytes
06:48:44 <gigabytes> little question: I used to call makeFields from Control.Lens.TH to generate accessors for the fields of my ADTs
06:48:52 <gigabytes> but I don't really need lenses
06:48:59 <gigabytes> I just want accessors without name clashes
06:49:27 <gigabytes> is there some package that provides something like makeFields but that generate simple functions instead of lenses?
06:49:55 <gigabytes> or, anyway, any nice way to solve the accessor name clashes problem?
06:52:01 <geekosaur> fclabels?
06:52:21 <gigabytes> geekosaur: it's a package?
06:52:38 <geekosaur> (in some sense, the answer is "no". but not all lens packages are as overwhelming as the "lens" package)
06:52:42 <geekosaur> yes, it's a package
06:55:08 <gigabytes> thanks
06:55:38 <geekosaur> and everything considered to try to solve *just* the name clash problem always ends up turning into a lens of some kind, whether simple or complex
06:56:38 <geekosaur> (well, there was tdnr but it had other issues)
06:56:47 <gigabytes> I just wanted a get function, actually
06:56:59 <gigabytes> exaclty like those created by record syntax, but overloaded
06:57:12 <gigabytes> with the trick of creating a typeclass for each name
06:57:34 <geekosaur> you pretty much just describeda lens in its simplest form
06:57:38 <gigabytes> I don't care about setters, composition, ecc... (in this piece of code)
07:05:31 <gigabytes> anyway
07:05:36 <gigabytes> I'm learning parsec
07:05:39 <gigabytes> it's wonderful
07:10:27 <ab9rf> heh
07:10:45 <ab9rf> gigabytes: i'm working on a parsec project at the moment
07:11:11 <gigabytes> ab9rf: me too, I need to parse a lisp-like syntax
07:11:20 <ab9rf> gigabytes: oh, that's quite easy :)
07:11:33 <gigabytes> yes, perfect for learning
07:11:58 <gigabytes> but I hated doing it with Happy
07:12:04 <deMoivre> Wow.
07:12:11 <deMoivre> Every Haskell user in the world must be in this channel right now
07:12:14 <deMoivre> Huge.
07:12:18 <ab9rf> gigabytes: i had a happy parser for this but i am ditching it
07:12:42 <gigabytes> deMoivre: every haskell user together with the composition of every pair of haskell users and the inverse of each user
07:13:08 <ab9rf> gigabytes: actually i had an alex lexer and happy parser, but i'm rewriting the alex lexer in parsec and will be rewriting the happy parser in parsec as well :)
07:13:15 <ab9rf> the lexer is nearly done
07:13:40 <ab9rf> i have four productions that still need to be written, but they won't take long
07:13:42 <gigabytes> ab9rf: is it actually useful to separate lexing and parsing stages when using parsec?
07:13:47 <ab9rf> gigabytes: i'm not sure
07:13:48 <chrisdone> yeah
07:13:58 <ab9rf> gigabytes: i may yet go to a unified parser.
07:14:03 <chrisdone> parsing concrete syntax adds more noise to the process
07:14:16 <ab9rf> but i suspect it will work better this way
07:14:26 <chrisdone> it's nicer to deal in terms of tokens instead of characters
07:14:31 <bennofs> ab9rf: interesting. have you already compared performance between the too?
07:14:34 <ab9rf> bennofs: no
07:15:10 <gigabytes> chrisdone: so I should create the lexer to produce tokens and then have a parser with a stream type of [Token]?
07:15:36 <chrisdone> that'll probably nicer, specially if the grammar is bigger
07:15:42 <ab9rf> gigabytes: that's what i'm doing
07:15:53 <chrisdone> i tokenize with attoparsec and then parse the tokens with parsec
07:15:54 <deMoivre> Is Haskell really the best functional language to learn first?
07:16:01 <ab9rf> gigabytes: http://github.com/ab9rf/phaestus, if you're interested.
07:16:10 <deMoivre> I've taken a few stabs at some modern LISP dialects and have pretty much failed
07:16:14 <deMoivre> Chicken Schema and Clojure
07:16:16 <deMoivre> *Scheme
07:16:31 <ab9rf> i never really bought into scheme as "functional"
07:16:39 <deMoivre> ab9rf: I kinda wonder about that, too.
07:16:41 <chrisdone> haskell, ml or clojure are good
07:16:48 <Phillemann> Is there a library available that wraps the functions from System.Directory to the more type-safe FilePath type from system-filepath?
07:16:48 <chrisdone> scheme doesn't pretend to be functional
07:16:55 <chrisdone> it has "procedures"
07:16:58 <ab9rf> i don't know why people sayu scheme is functional
07:17:05 <hpc> you can force yourself to write functional code in scheme
07:17:10 <hpc> much like javascript or perl
07:17:12 <ab9rf> it has call/cc which is interesting and fun but it's not inherently functional
07:17:14 <chrisdone> and data structures are mutable
07:17:15 <deMoivre> Because it *allows* for functional programming, I think
07:17:22 <deMoivre> and focuses on immutable data structures
07:17:24 <rui> Is there a dot product of lists in the standard library?
07:17:28 <Welkin> "functional" does not have a clear definition
07:17:28 <chrisdone> most modern languages do now
07:17:45 <Welkin> some people think "functional" means that the language supports map, filter, and reduce
07:17:47 <chrisdone> clojure actually has immutible data structures which is much more conducive to functional style
07:17:52 <ab9rf> Welkin: hell, that's perl
07:17:59 <rui> Or I should just define some dot l1 = sum . zipWith (*) l1
07:18:05 <deMoivre> Welkin: Right...and some think it has more to do with having functions as 1st class citizens/objects
07:18:12 <Welkin> some may add to that: tail call optimization, currying, partial application
07:18:17 <ab9rf> rui: go for it
07:18:30 <hpc> > (,) <$> ["like", "this?"] <*> [1,2,3,4,5] -- rui
07:18:32 <lambdabot>  [("like",1),("like",2),("like",3),("like",4),("like",5),("this?",1),("this?"...
07:18:52 <hpc> oh, dot product
07:19:09 <ab9rf> rui: yhou should write your code so that your literary intent is clear.  if defining dot makes it clearer what you are doing, then define it.  don't try to use an obscure idiom that will just make your code hard to understand.
07:19:48 <chrisdone> λ> [i| (,) ["like", "this?"] [1,2,3,4,5] |]
07:19:48 <chrisdone> [("like",1),("like",2),("like",3),("like",4),("like",5),("this?",1),("this?",2),("this?",3),("this?",4),("this?",5)]
07:19:48 <chrisdone> :3
07:20:24 <rui> ab9rf Yes, but efficiency is more or less important in this case
07:20:34 <chrisdone> deMoivre: the key point is whether the functions are true mathematical functions or procedures
07:20:44 <ab9rf> rui: it won't be more or less efficient just because you used an idiom
07:20:46 <rui> and I expect to be using lienar algebra quite a bit in the future
07:21:04 <hpc> rui: you should pick a better structure than [] - check out hmatrix
07:21:09 <hpc> or another matrix lib
07:21:10 <chrisdone> deMoivre: haskell functions follow a substitution model and that's all
07:21:11 <Welkin> rui: there are plenty of linear algebra libraries already
07:21:30 <ab9rf> if you're doing mathematical dot products on fixed vectors, you should use a fixed vector type rather than lists, or just use a linear algebra library
07:21:30 <chrisdone> in scheme the substitution model breaks down due to the introduction of side-effects
07:21:31 <Welkin> yes, lists are not a good idea for matrices
07:21:49 <deMoivre> chrisdone: Can you explain a bit more about that break down in Scheme?
07:21:50 <ab9rf> lists are not te right model for a fixed-length matrix
07:21:54 <deMoivre> Or point me to a page that shows an example?
07:22:39 <rui> ab9rf I think I didn't understand what you meant by obscure idiom
07:23:07 <deMoivre> I'm a Mathematician, btw.  In between masters and PhD level.  I've studied category theory at Dartmouth and a little more at University of Arizona and Texas Christian University... but it really ate my lunch.
07:23:11 <chrisdone> deMoivre: this is covered in SICP; they start off with just the pure subset of scheme that follows a simple substitution model (https://mitpress.mit.edu/sicp/full-text/sicp/book/node10.html). then later they introduce set! and print
07:23:18 <deMoivre> Category Theory and Model Theory were my hardest subjects, probably
07:23:26 <rui> hpc Great, so you think that those libraries might be considerably more efficient. That's waht I wanted to know
07:23:44 <deMoivre> So, that's why I've gravitated a little more towards Lisp instead of Haskell
07:23:54 <rui> Welkin Its the plenty of options that make it hard to choose :P
07:23:55 <deMoivre> Seems like using Haskell requires a more solid understanding of category theory than I practically have
07:24:02 <rui> Any suggestions? hmatrix?
07:24:03 <ab9rf> rui: it's more that choosing a more appropriate representation that will result in it being more efficient
07:24:07 <deMoivre> chrisdone: Thanks.
07:24:36 <Welkin> rui: just try them all out
07:24:42 <Welkin> that's my approach
07:25:07 <Welkin> you'll find the one that fits your needs best
07:25:16 <ab9rf> huh
07:25:27 <chrisdone> deMoivre: there's also a lecture where they introduce assignment https://www.youtube.com/watch?v=jl8EHP1WrWY
07:26:10 <ab9rf> hm, the keyword/identifier parser is dropping the first character
07:26:15 <ab9rf> "if" is recognized as "f"
07:26:17 <gigabytes> little question
07:26:19 <ab9rf> "cat" as "at"
07:26:23 <ab9rf> so hm
07:26:29 <ddellacosta> deMoivre: I am not anywhere close to a master of Category Theory but I find Haskell has a ton of utility. More to the point I find that I'm slowly learning Category Theoretic concepts through learning Haskell--absorbing them through programming makes it easier when I go back and attempt to read CT textbooks and whatnot.
07:26:29 <bennofs> deMoivre: I learned haskell without knowing anything about CS
07:26:39 <gigabytes> I'm using a lot of newtype for type safety, instead of having a lot of meaningless integers and strings here and there
07:26:45 <ab9rf> gigabytes: yay!
07:26:54 <ddellacosta> deMoivre: and if you are a mathematician then for you I can only imagine that process will be easier
07:27:09 <bennofs> ddellacosta: same for me :)
07:27:09 <gigabytes> I'm using NewTypeDeriving to derive automatically the instances that I need from the interior type
07:27:20 <ddellacosta> bennofs: :-)
07:27:37 <gigabytes> but if I derive Show, for example, I get the "standard" show instance, instead of an instance that simply relay to the instance of the interior type
07:28:00 <ab9rf> ddellacosta: i don't know category theory except from what i've absorbed from writing haskell, listening to others in here, and reading papers
07:28:03 <gigabytes> is there a way to automatically derive Show for newtypes in this way?
07:28:19 <ab9rf> ddellacosta: of course, my academic training is in political science and law :)
07:28:35 <ddellacosta> ab9rf: yeah, it seems like that's a pretty common pattern for a subset of Haskell programmers
07:28:50 <ddellacosta> ab9rf: er, maybe not the polysci and law part...haha
07:28:57 <ab9rf> ddellacosta: heh
07:29:42 <chrisdone> deMoivre: trying to put it neatly: x * 0 = 0 is always true, right?
07:29:43 <dschoepe> gigabytes: That seems to be what deriving Show automatically already does here: http://lpaste.net/8436791601711284224 -- show (B A) yields "B 1"
07:30:01 <deMoivre> chrisdone: That completely depends on the meaning of those symbols.
07:30:20 <deMoivre> In a ring, that's an axiom
07:31:08 <deMoivre> ddellacosta: You'd think...but that's kinda my point.  I'm basically an Analyst, with a focus on [Discrete] Dynamical Systems
07:31:24 <ab9rf> i write code :)
07:31:24 <chrisdone> okay, so you can rely on this in doing equational reasoning and substitute x*0 with 0, etc.
07:31:28 <deMoivre> Category Theory is a whole other beast that seems like it doesn't bear much on analysis
07:31:40 <ddellacosta> deMoivre: I see...I guess it is true that haskell leans more heavily on the algebraic side of things
07:31:41 <ab9rf> deMoivre: i'm still not convinced that category theory is real
07:31:51 <gigabytes> dschoepe: yeah, that's the behaviour I want to avoid. If you derive any other instance with NewTypeDeriving, that happens is that the derived instance simply call the instace of the underlying type, without anything else. Instead, Show gets implemented by printing the constructor, like standard deriving behaves. I want to avoid that
07:31:52 <deMoivre> ddellacosta: Yes...
07:32:39 <deMoivre> ab9rf: It's 'real' in the sense that it's logically coherent and is actually useful in certain mathematical contexts.
07:32:47 <deMoivre> ab9rf: In what sense do you suspect that it isn't 'real'?
07:33:36 <rui> Welkin, ok, I'll give it a shot
07:33:43 <ddellacosta> wow, if we start going down that road then we have to start talking about Platonism, Formalism and Intuitionism and whatnot...
07:33:55 <dschoepe> gigabytes: Oh, I see. Well if it's just about Show, then I guess writing the instance manually wouldn't be too terrible (instance Show where show = show . unA) where unA removes the newtype constructor. Not an ideal solution
07:33:58 <dschoepe> though
07:34:17 <ab9rf> deMoivre: i can't really say.
07:34:28 <rui> Is package documentation installed or in some standard place? Or there's just the haddock stuff plus what you might expect to find on github or in some package home page?
07:34:30 <dschoepe> You could also automate it using Template Haskell, but still not that nice
07:34:45 <gigabytes> dschoepe: yes, it's trivial. But since I use newtype heavily to create a lot of synonims for String in my compiler, I have tons of those instances
07:34:47 <ab9rf> deMoivre: note that my math career died on Green's Theorem, and i have no real understnading of higher mathematics beyond that which i got from typing papers for a math grad student for two years.
07:34:54 <ab9rf> deMoivre: i'm really good at LaTeX :)
07:35:30 <dschoepe> gigabytes: maybe TH is a good workaround if you have it take a list of newtypes and have it generate instances for all of those at once
07:35:31 <chrisdone> deMoivre: comparatively, in a language with procedures, x * 0 is not necessarily 0. in scheme (* (do-something) 0) can launch missiles or read some state elsewhere. hence you can't apply a basic substitution model and that makes equational reasoning much harder
07:35:49 <dschoepe> then it'd be one line for all the newtypes in that modules, not one line per newtype at least
07:35:53 <ddellacosta> deMoivre: well, leaving all of this aside, I think that you shouldn't rule out Haskell based on its usage of Category Theoretic concepts.  Just taken on its own, it's quite a powerful, elegant and useful language, and you don't have to take it as an all or nothing kind of thing.  That's my two cents and I'll leave it at that. :-)
07:36:22 <dukerutledge_> I'm fumbling my way through lens, does anyone know how I can compose a set on a nested map/set, eg: at 1 .~ at 3 .~ at 4
07:36:31 <gigabytes> dschoepe: idea: I could create a typeclass MyShow, derive that, declare an instance for String, and a instance MyShow t => Show t
07:36:41 <dukerutledge_> Also is there a canonical walk through of some of the more complex concepts in lens?
07:37:47 <dukerutledge_> maybe edwardk
07:38:06 <dschoepe> gigabytes: well, I guess you'd also need to create instances for Int, MyShow a => [a], etc.
07:38:16 <dschoepe> but that might still be cleaner than TH
07:38:32 <deMoivre> ddellacosta: Noted.
07:38:42 <gigabytes> dschoepe: didn't get the last point
07:38:44 <deMoivre> chrisdone: Is that essentially the same as lazy evaluation?
07:38:58 <chrisdone> that's an orthogonal concept
07:39:22 <dschoepe> gigabytes: Well, you'd need a MyShow instance for any type that gets wrapped in a newtype
07:39:43 <dschoepe> (and isn't made up of types already having an instance)
07:39:50 <deMoivre> chrisdone: In Haskell, I mean.  I'm not aware of any lazily-evaluated outside of Haskell in the first place
07:40:02 <deMoivre> none that I've ever coded "Hello, world!" in, at least
07:40:03 <gigabytes> dschoepe: that's with the automatic derive
07:40:29 <deMoivre> :s/lazily-evaluated/lazily-evaluated languages/%
07:41:40 <dschoepe> gigabytes: what I meant is that GHC can't derive it automatically for something like newtype A = A Integer if you don't also add a MyShow instance for Integer. And similarly for other types like that
07:41:41 <chrisdone> nevermind, my comments probably aren't helpful
07:41:41 <deMoivre> :s/%/g/
07:41:47 <deMoivre> =)
07:42:04 <deMoivre> chrisdone: Actually, they are.
07:42:40 <gigabytes> dschoepe: oh yeah of course. But it's two instances for twenty :P
07:43:02 <deMoivre> chrisdone: I'm just trying to understand why those are orthogonal concepts.
07:44:18 <ddellacosta> deMoivre: you can have purity without laziness (and I suppose laziness without purity, as terrifying as that sounds to reason about)
07:44:28 <dschoepe> gigabytes: True. I guess that solution is still the lesser evil considering the (lack of) alternatives
07:44:59 <gigabytes> yes
07:45:03 <gigabytes> changing topic
07:45:22 <gigabytes> is someone of you going to LambdaCon at Bologna this March?
07:45:31 <chrisdone> i am
07:45:39 <gigabytes> cool
07:45:48 <Welkin> I'll have to take note of al these conferences
07:45:51 <Welkin> I always seem to miss them
07:45:51 <ddellacosta> deMoivre: and Clojure has laziness as a feature too, btw, although it's not all-pervasive as in Haskell
07:45:52 <gigabytes> chrisdone: where do you come from? italy?
07:46:02 <deMoivre> ddellacosta: Yes, exactly...I just verified that ;)
07:47:09 <chrisdone> gigabytes: sono inglese ma sono stato a trento per tre anni ;)
07:48:29 * hackagebot pcre-heavy 0.2.2 - A regexp library on top of pcre-light you can actually use.  http://hackage.haskell.org/package/pcre-heavy-0.2.2 (myfreeweb)
07:48:38 <chrisdone> gigabytes: where are you from?
07:48:39 <Welkin> chrisdone: you're from Britain?
07:48:43 <chrisdone> yup
07:48:52 <gigabytes> chrisdone: italy :)
07:48:59 <gigabytes> Trento is nice
07:49:26 <chrisdone> where in italy?
07:50:55 <hpc> still waiting for the regex library that just uses the perl runtime
07:51:02 <gigabytes> chrisdone: Udine, north-east
07:52:13 <silver> hpc, why?
07:52:30 <hpc> silver: it's the logical progression :P
07:52:41 <hpc> also perl's regex engine is pretty damn good
07:53:05 <chrisdone> hpc: we've already tried the other direction
07:53:05 <bennofs> hpc: but it can't use DFAs since perl regexes aren't actually regular (at least that's what I've read)
07:53:18 <chrisdone> (make perl a library implemented in haskell: pugs)
07:53:40 <hpc> haha
07:53:54 <hpc> bennofs: they very much are not
07:54:01 <hpc> but i like it that way
07:54:13 <ddellacosta> holy crap that's really a thing isn't it: http://www.pugscode.org/
07:54:20 <ddellacosta> I thought it was a joke
07:54:21 <chrisdone> :D
07:54:38 <hpc> pugs was the start of perl6
07:54:53 <hpc> it's now self-hosting, but it just goes to show
07:55:02 <hpc> even perl can't parse perl
07:55:04 <hpc> use haskell
07:55:06 <chrisdone> in the early days a lot of perl programmers learned about haskell via pugs and then just moved onto haskell
07:55:23 <hpc> chrisdone: i went the other way, haskell to perl
07:55:42 <hpc> (which i recommend - the good habits of haskell prevent you from doing terrible things that perl lets you do)
07:55:54 * hodapp just realized that agocorona made both MFlow and the Transient monad
07:56:06 <ddellacosta> chrisdone: I was just going to say, if you spend enough time playing with Haskell trying to write Perl, I can't imagine you wouldn't just give up and use Haskell (speaking as someone who learned to program using Perl 5)
07:56:13 <bennofs> hmm, it could happen to me: Haskell -> NixOS -> Perl (since many of nix infrastructure is perl)
07:56:20 <hodapp> nix infrastructure is perl?
07:56:30 <bennofs> hodapp: hydra is perl, some nix scripts are perl
07:56:42 <chrisdone> so now i know why johnw was rewriting nix in haskell
07:56:45 <hpc> so much of linux in general is perl
07:56:50 <bennofs> nix-shell is a perl script for example
07:56:59 <bennofs> chrisdone: the core lib of nix is C++
07:57:03 <hodapp> ewww
07:57:16 <bennofs> I don't know how it works, but somehow the perl code uses the C++ libraries
08:05:07 <gigabytes> dschoepe: ghc complains about that trick
08:05:13 <gigabytes> it wants UndecidableInstances
08:05:57 <dschoepe> gigabytes: Oh I guess because it now has two Show instances for Integer, String, etc.
08:06:12 <dschoepe> one via MyShow and the normal one
08:06:20 <gigabytes> no, it's because it says "constraint no smaller than instance head"
08:06:28 <gigabytes> in instance MyShow t => Show t
08:08:34 <dschoepe> gigabytes: okay, it seems even if you turn on UndecidableInstances, you do get overlapping instances
08:08:48 <dschoepe> (unsurprising in retrospect, but still)
08:16:23 <ddellacosta> what is the complexity of array lookup?  Is it O(log n), or O(1)?
08:16:56 <ddellacosta> talking about Data.Array to be clear
08:17:01 <bennofs> ddellacosta: O(1)
08:17:04 <mpickering> I was under the impression it was O(1)
08:17:14 <ddellacosta> bennofs, mpickering: thanks
08:18:02 <ddellacosta> so, presumably, if you can model your key as a finite Enum of some sort, and your algorithm has a lot of lookups, it's always more efficient to use Data.Array vs. Data.Map
08:18:41 <ddellacosta> inserts are presumably a lot more expensive though
08:22:48 <phaul> ddellacosta: I think the important difference is that if you want to store 2 elements with 2 keys which are very far apart, Array representation is stupid
08:23:21 <ddellacosta> phaul: that's a good point
08:23:36 <ddellacosta> phaul: I wasn't really thinking about space considerations
08:23:50 <hodapp> if I have foo :: IntegralE => E a -> Atom (), and polymorphic value, bar :: IntegralE a => a, is there any way to resolve the ambiguity in 'foo bar' without just having N instances of foo (bar :: SomeIntegralE)?
08:24:51 --- mode: monochrom set -bbbo *!*@90.174.3.224 *!*@88.246.8.160 *!*@85.106.77.169 monochrom
08:27:23 <joelneely> @pl \ns -> (sum ns) / 3
08:27:23 <lambdabot> (/ 3) . sum
08:38:50 <joelneely> @pl \ns -> map ((/ 3) . sum) $ filter ((3 <=) . length) $ map (take 3) $ tails ns
08:38:50 <lambdabot> map ((/ 3) . sum) . filter ((3 <=) . length) . map (take 3) . tails
08:39:09 <chrisdone> lol
08:39:27 <chrisdone> <lambdabot> that'll be $50
08:39:35 <monochrom> :)
08:40:39 <hiptobecubic> how does Ix *work* ?
08:41:28 <phaul> @pl \x -> x + x
08:41:28 <lambdabot> join (+)
08:42:53 <monochrom> Ix doesn't do a lot of things, does it?
08:43:36 <monochrom> it's just there to give you some helpers for array indexing
08:43:50 <lpaste> chrisdone pasted “yay, TH-base presentations” at http://lpaste.net/120897
08:43:51 <hpc> (Ix a) is a mapping from a range of a to Ints
08:44:17 <hpc> so you can make an array with bounds of EQ to GT
08:44:23 <bennofs> Ix from lens or Ix from base?
08:44:36 <hpc> gah, there's more than one
08:44:47 <chrisdone> of course there is =p
08:44:49 <bennofs> :t ix
08:44:50 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
08:44:58 <bennofs> ah, it's called Ixed in lens
08:45:03 <cfoch> hello
08:45:12 <cfoch> I have this enhancement for
08:45:18 <cfoch> https://github.com/haskell/cabal/issues/2372
08:45:24 <cfoch> https://github.com/cfoch/cabal/tree/initChooseOtherName
08:45:34 <cfoch> I wonder if someone can review it, please
08:45:48 <gigabytes> guys
08:46:04 <gigabytes> what's the difference between the modules under Text.Parsec and Text.ParserCombinators.Parsec ??
08:46:14 <hpc> history
08:46:43 <quchen> Use the former.
08:46:43 <quchen> The other one is only for compatibility or something.
08:47:34 <hiptobecubic> cfoch, the review process is much easier if you make a pull request
08:47:43 <gigabytes> quchen: ok, thanks
08:48:04 <gigabytes> someone should update the online version of Real World Haskell
09:07:44 <m-r-r> Hello
09:08:22 * chrisdone opens the creaky front door to greet m-r-r
09:11:53 <hiptobecubic> I do have to wonder why Data.Vector doesn't use Ix..
09:14:25 <phaul> how's Ix different from Bounded, Enum seems pretty much the same
09:15:50 <phaul> index could be fromEnum
09:17:35 <hpc> phaul: you can index over a range not starting at 0
09:19:12 <phaul> Could Enum do that, mapping `a' to Ints not starting at 0
09:20:13 <hpc> suppose you were indexing by Float
09:20:25 <hpc> > [0..3] :: [Float]
09:20:27 <lambdabot>  [0.0,1.0,2.0,3.0]
09:20:35 <hpc> > [0.5..3] :: [Float]
09:20:37 <lambdabot>  [0.5,1.5,2.5,3.5]
09:21:04 <hpc> > [0.1..3] :: [Float] -- hmm
09:21:05 <lambdabot>  [0.1,1.1,2.1,3.1]
09:21:08 <xauth> 3.5? hmm
09:21:31 <hpc> oh, i think that was the bug actually
09:21:36 <hpc> that it goes beyond 3 at all
09:21:48 <quchen> There are a couple of pretty interesting Ix instances, for example when you have an index set of permutations of unequal numbers, as seen e.g. in differential geometry (where you have lots of totally antisymmetric objects).
09:21:58 <quchen> Well, possible Ix instances.
09:22:20 <quchen> That particular one is known as the combinatorical number system.
09:22:37 <quchen> Combinatorial*
09:22:57 <lpaste> nick_named pasted “Mapping reductions” at http://lpaste.net/120898
09:23:35 <nick_named> Does any one know a better way to force evaluation than I did in the above lpaste?
09:25:10 <quchen> nick_named: (`seq` True)
09:25:54 <quchen> Or with BangPatterns, acceptHalt !_ = True
09:26:43 <hodapp> is there some other mnemonic for... mapM foo =<< bar? I feel like there is but I cannot recall.
09:26:46 <hodapp> sorry, mapM_
09:27:17 <nick_named> Thanks quchen!
09:32:36 <phaul> hodapp: not that I know the answer, but what are your types? is foo :: a -> m b and bar :: m [ a ]?
09:34:49 <hodapp> :t (\x y -> mapM_ x =<< y)
09:34:50 <lambdabot> Monad m => (a -> m b) -> m [a] -> m ()
09:35:05 <hodapp> not sure there's any other choice for their types
09:35:19 <phaul> yes, I confused myself
09:35:38 <phaul> I thought for a second bar could have been [a] , using Monad []
09:36:57 <yac> I have a sandbox for ycdn and sandbox for dbmigrations. I have patched the dbmigrations and installed it via cabal --sandbox-config-file=<path-to-ycdn> install. However when I try to build ycdn, I get  cannot satisfy -package-id dbmigrations-0.8.1-dfb40ea7048605028eb65fe6e2e0c50b
09:37:01 <yac> any idea why?
09:37:10 <hodapp> maybe there isn't a mnemonic for that
09:37:42 <yac> oh, cabal configure fixed it
09:38:50 <hexagoxel> yac: or use `cabal sandbox add-source`, see help
09:50:15 <BrittB> Can someone help explain to me how to declare a poly morphic type constructor?
09:50:58 <quchen> BrittB: You mean a parametric one? Like data Foo a = Foo a?
09:52:55 <BrittB> quchen: I think so,  this is what Im confused on. I'm still fairly new to haskell  http://lpaste.net/775327491978952704
09:53:46 <BrittB> transpose (\ a -> a == "test")    I'm trying to make a set with "test" in it
09:53:47 <dulla> :t zip4With
09:53:48 <lambdabot>     Not in scope: ‘zip4With’
09:53:48 <lambdabot>     Perhaps you meant one of these:
09:53:48 <lambdabot>       ‘zipWith’ (imported from Data.List),
09:53:52 <quchen> BrittB: "transpose" sounds like it should filter the set, telling from the comment
09:53:55 <dulla> :t zipWith4
09:53:56 <lambdabot> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
09:53:58 <quchen> Is that your intention?
09:54:04 <quchen> You can also message lambdabot in private (/msg lambdabot) when you just want to try things out (as opposed to demonstrating code to others).
09:54:08 <quchen> dulla: ^
09:54:25 <dulla> o no
09:54:42 <hpc> i took it to mean (transpose p) = {x | forall x :: b. p x}
09:55:02 <hpc> (to use set notation)
09:56:58 <BrittB> I'm trying to put "test" into a set if that helps?
09:57:00 <yac> hexagoxel: looks like cabal 1.20 doesn't have that option
09:57:17 <BrittB> But I'm trying to create my own data type for it
09:59:21 <phaul> looking at the comment and the type signature of transpose, Im not sure which one you mean: is transpose supposed to modify an existing set applying the predicate somehow, or you want to create a set from a predicate?
09:59:35 <hexagoxel> yac: hmm you may be right, but afaik the command works in 1.20; only the documentation is missing
09:59:40 <mpickering> Is there any reason why Identity in Control.Monad.Identity lacks a show instance?
09:59:47 <fosskers> What's the simplest wrapping type? Identity?
09:59:59 <yac> hexagoxel: no, it told me to check --help
10:01:04 <hexagoxel> yac: ok, nevermind then
10:02:54 <ab9rf> mpickering: i suppose because monads rarely have show instances?
10:04:19 <BrittB> phaul: transpose (\ a -> a == "test")      if I call this I want to create a set with "test" in it. does that help?
10:04:31 <fosskers> Is there a better trivial wrapping type than Identity? Identity doesn't have Eq or Show instances, which I need.
10:05:24 <phaul> I think Im getting what you are saying now. So by using the fact that a -> Bool functions are essentially Sets over a you want to go from functions to sets
10:05:32 <mpickering> fosskers: what do you need identity for? You will probably be better off with your own?
10:06:04 <phaul> I dont think you can do that for any `a'
10:06:32 <phaul> if a is Enum then you can do it
10:07:30 <deMoivre> http://learnyouahaskell.com/starting-out
10:07:45 <deMoivre> ^^^^^^^^^^^^^^ is there some way to get colored console output from ghci like he shows there?
10:08:09 <phaul> BrittB: but it's non-trivial
10:08:22 <BrittB> phaul: what do you mean?
10:09:18 <wz1000> phaul: mniip wrote these helper functions (http://lpaste.net/120675) for that set type, naming it after me.
10:09:56 <fosskers> mpickering, wanted to get Functor/Applicative/Monad for free while just newtyping over Identity for my own equally trivially wrapping type
10:10:09 <joelneely> @pl \x -> ((f x), (g x))
10:10:09 <lambdabot> liftM2 (,) f g
10:10:36 <phaul> oh sorry, i thought the Set was Data.Set :)
10:10:48 <fosskers> mpickering, problem is, I want to be able to Eq and Show my own type
10:10:54 <mpickering> right
10:10:58 <darkroom> if i have a [Maybe a] and i want to get a Maybe a but i want to return nothing the second there is a nothing value how should i do that?4
10:11:03 <mpickering> so I assume that your type already has a monad instance?
10:11:24 <fosskers> so I either dont' wrap Identity, write my own App/Monad, or I do wrap Identity and write my own Eq/Show
10:11:36 <fosskers> Hence I'm here looking for a middle ground
10:12:05 <mpickering> If the type you're wrapping doesn't have a monad instance then wrapping in Identity for the monad instance is pointless and the monad instance for identity is just function application.
10:12:29 <fosskers> precisely
10:12:47 <fosskers> oh wait a minute
10:13:03 <mpickering> OTOH, if you do have a monad instance for your type r then you can turn on GeneralizedNewtypeDeriving and define.. newtype Wrapper = Wrapper r deriving (Show, Eq, Ord, Monad, etc..)
10:13:03 <phaul> BrittB: transpose is just the `id` function as the set is represented the same as a function
10:13:28 <fosskers> mpickering, that wasn't working
10:13:36 <fosskers> ah nevermind
10:13:45 <fosskers> yeah there was no Monad instance for `r`
10:14:05 <BrittB> phaul: what does that mean exactly? Sorry I'm having a hard time wrapping my head around it all
10:14:07 <fosskers> i may be making this more difficult for myself than i need to be
10:14:23 <mpickering> maybe, feel free to explain a bit more what you're trying to do
10:15:41 <phaul> Im sorry Im not great at explaining. by having this type Set a = a -> Bool, these things look exactly the same : a -> Bool functions and Set a sets. to traverse between them you don't need to do anything, they are interchangeable. Which is why traverese = id would work
10:16:18 <phaul> id being the identity function
10:19:01 <joelneely> @pl \xss -> map (\xs -> (length xs) - 1) xss
10:19:01 <lambdabot> map (subtract 1 . length)
10:19:37 <Javran> I watched "Typeclasses vs the World", just wondering what's the difference between entailment and implication?
10:20:46 <mpickering> in propositional logic (by the deduction theorem) {A} |- B iff |- A -> B
10:21:00 <monochrom> I have seen authors who define them identical, and authors who define them different.
10:21:01 <mpickering> this isn't true in all logical systems
10:21:23 <Javran> hmm, i see
10:21:52 <monochrom> not to mention that I have seen authors who define "entailment is the |- there, implication is the -> there" and authors who define the other way round
10:22:43 <Javran> I saw Ed talking about "A entails B" all the time, not sure if there's a particular reason to use "entail" over "imply"
10:22:46 <monochrom> and authors who use ⊃ where -> is used
10:23:06 <Procian> mpickering: Interesting. What logics don't allow that?
10:23:14 <Javran> so it really depends on the logical system I guess
10:23:19 <BrittB> phaul: I think I understand what you are saying. So for my transpose function would it be something simple?
10:23:28 <Ainieco> hello
10:23:50 <Javran> intuitionistic logic maybe?
10:24:01 <monochrom> IMO, to call them different in a context other than a logician's subtle detailed pursuit is pompous.
10:24:15 <arw_> it always depends on the definitions in the book. my favourite "well, its different here" is f . g = f(g(x)) or sometimes g(f(x))...
10:24:18 <Procian> Javran: Nah. Intuitionistic logic has that.
10:25:09 <hpc> arw_: dear god, people actually use the latter?
10:25:33 <arw_> hpc: yes. i actually almost failed an exam because of that :)
10:25:57 <hpc> i would say it's the exam that failed
10:26:09 <arw_> hpc: the reasoning (according to people) is, that f . g means "first apply f, then g"...
10:26:35 <mpickering> Procian: Kleene 3-valued logic, there are no tautologies (ie ~∃x . |- x)
10:26:41 <Javran> I think it should be something like g(f(x)) = (g.f)(x) = (f;g)(x)
10:26:47 <Ainieco> is possible to get rid of "x <- f" in "do { x <- f; case x of { y -> z; _ -> z' }"?
10:26:59 <ski> Javran : implication is a connective, entailment isn't
10:27:19 <thebnq> Javran: any particular location in the talk
10:27:32 <ski> @undo do { x <- f; case x of { y -> z; _ -> z' } }  -- Ainieco, yes
10:27:32 <lambdabot> f >>= \ x -> case x of { y -> z; _ -> z'}
10:27:47 <Procian> mpickering: Cool. Cheers!
10:27:58 <Javran> ski: connective?
10:28:10 <ski> Ainieco : you could also try `f >>= \case of { y -> z; _ -> z' }'
10:28:14 <Zemyla> Hmm. Can you safely unsafeCoerce a SIMD tuple of one type (such as Int8x16#) to another type of the same size (such as Int32x4#)?
10:28:28 <ski> Javran : like conjunction,disjunction,negation are connectives
10:28:50 <ski> Javran : connectives are used to build propositions out of "smaller" ones
10:29:01 <Procian> ski: I remember from Quine's Mathematical Logic that "implies" is not a connective.
10:29:02 <Ainieco> ski: okay, thanks
10:29:03 <hpc> Zemyla: i would expect the result to depend on endianness
10:29:06 <Procian> "only if" is a connective.
10:29:19 <Procian> But this is just silly pedantry.
10:29:24 <Zemyla> hpc: True. :V
10:29:40 <Javran> ski: so it's like "proposition constructors" in some sense?
10:29:51 <Procian> You just want to learn the basic distinction between → and ⊢
10:29:52 <ski> Procian : there's different terminology. sometimes what i called "implication" would be called a "conditional", and then perhaps they'd use "implication" for what i called "entailment" -- the concepts should still stay the same, i think
10:29:55 <Procian> Who cares what you name them.
10:30:15 <ski> Procian : *nod*
10:30:34 <ski> Javran : yes
10:30:53 <monochrom> unfortunately for you, the original question was precisely "I saw the word 'entail', what does it stand for"
10:31:08 <ski> Javran : the connectives expose (one way to construe) the logical shape of a proposition
10:31:10 <monochrom> you can't wing that by "name doesn't matter"
10:31:33 <monochrom> instead, I wing it by "different people use that same name for opposite things"
10:31:55 <monochrom> because it's really hopeless. you really have to know the author.
10:32:56 <Procian> In type theory, I'm not sure whether I'd really want to use the word "entail" at all.
10:33:16 <ibid> in some logics, both → and ⊃ are used for different versions of implication
10:33:35 <Procian> It's like: in the context of these variables having these types, I judge this.
10:33:59 <Procian> And I haven't figured out what's going on with sequents where you have multiple propositions on the right of the turnstile.
10:34:30 <monochrom> the nice thing about meaningful names is that there are so many opposite meanings to choose from.
10:35:29 <ski> Procian : multiple alternative conclusions
10:35:34 <monochrom> that's probably disjunction
10:35:40 <ski> structural disjunction, yes
10:36:08 <Procian> ski: I get that much, but I don't really get how it works.
10:36:19 <monochrom> to prove "p |- q, r", you just have to prove "p |- q" or "p |- r". there is probably one more way.
10:36:26 <ski> "just like multiple hypotheses, only the other way around"
10:36:50 <ski> monochrom : that's the additive version ..
10:37:12 <monochrom> the one more way is present in classical logic: prove "p, not q, not r |- false"
10:37:22 <ibid> (in fact, ⊃ is more intuitive for material implication than the now-more-common →)
10:38:40 <ski> Javran : you might perhaps be interested in "On the Meanings of the Logical Constants and the Justifications of the Logical Laws" by Per Martin-Löf in 1996 at <http://people.inf.elte.hu/divip/AgdaTutorial/Further_Reading/Meanings_and_justification.pdf>
10:38:41 <Javran> actually applying "not L" rule twice on "p |- q,r" and you'll get "p,not q,not r |- emptyset"
10:39:04 <ski> ibid : why ?
10:39:31 <ski> Javran : also, the beginning of Frege's Begriffsschrift
10:41:21 <Javran> ski: thanks, I'll definitely take a look!
10:41:23 <ibid> ski: p ⊃ q suggests the intuition that p contains q (that is, p already says q)
10:41:40 <ibid> ski: for me, at least
10:42:12 <ibid> ski: the arrow is, for me, just a learned notation with no intuitive sense to it
10:42:13 <ski> not "`q' contains `p", then ?
10:42:32 <ibid> ski: ah, sorry. yes, that way
10:42:41 <ibid> argh!
10:42:42 <monochrom> the arrow intuits to me "from p obtain q"
10:42:55 <ibid> ski: sorry, i always get confused about this :)
10:43:31 <ibid> ski: note that the notation is an inverted version of the usual set containment
10:43:33 <ski>   q ⊂ p  -- `q' is contains `p'
10:43:38 <ski> s/is //
10:43:43 <ibid> ski: so yes, p contains qm as i originally said
10:44:20 <ibid> ski: i can easily see why russell etc used it
10:44:34 <BrittB> phaul: where should I begin with my transpose function?  I think I am doing something wrong, it looks so simple. http://lpaste.net/775327491978952704
10:44:35 <ibid> ski: though i get confused because of the direction change from set notation :)
10:44:54 <ski> i seem to recall something about the set inclusion relation originally being a `C' .. but perhaps i'm misremembering, and it really being the (non-arrow) conditional/implication symbol which was (or both ?)
10:45:07 <monochrom> the set of theorems provable by p contains the set of theorems provable by q
10:45:13 <ski> (the `C' might have come from `conditional' ?)
10:45:31 <monochrom> dually, the set of models satisfying p is contained by the set of models satisfying q
10:45:56 <mauke> BrittB: line 1 is a syntax error
10:45:56 <monochrom> this is Aristotle's "properties vs examples" duality
10:46:06 <ibid> monochrom: but when russell etc were writing, they didn't have set theory, if i rrcall correctly
10:46:15 <BrittB> mauke: I just fixed it I think, I noticed it too sorry
10:46:21 <ibid> monochrom: *model theory, sorry
10:46:33 <ibid> monochrom: i should probably go to bed :D
10:46:46 <monochrom> one doesn't need model theory to say what Aristotle said.
10:47:04 <monochrom> "model" is a fancy way to say "example", "witness".
10:47:05 <ski> ibid : Frege had a version of a set theory (which turned out to be inconsistent)
10:47:15 <SrPx> Does anyone know a software that can unify this? http://lpaste.net/120901 -- this is failing to unify on my unifier, but it was supposed to work. I'm not sure if I derived the wrong constraints or if the solver is buggy, so I'd like to test it with another solver
10:47:46 <ibid> ski: frege had a higher-order logic, not set theory
10:47:59 <ibid> ski: but set theory is older, yes.  i mixed it with model theory
10:48:08 <phaul> BrittB: there are 2 ways going with it: type Set a = a -> Bool or data Set a = Set (a -> Bool) Former states that Sets are the same as the predicate funtions, latter creates a new set type.
10:48:31 <monochrom> if I say "those things satisfying p", no one asks me for a "thing theory" or a "those theory". yet it is exactly what "the set of models satisfying p" means.
10:48:44 <ski> ibid : he had "course-of-values" for his "concepts", which looks like a set to me
10:48:46 <phaul> notice the difference between data .. = vs type .. =
10:49:42 <phaul> if you go with data, then transpose need to lift the a -> Bool function to the Set type.
10:50:21 <ibid> ski: yes, and the difference between sets and propositional functions is a tiny one :) -- but the key point is, set theory is older than begriffschrift, i think
10:50:27 <phaul> by applying the Set type constructor, which is basically transpose
10:50:35 * monochrom goes naughty and adds "newtype Set a = Set (forall r. ((a -> Bool) -> r) -> r)"
10:51:00 <ski> ibid : Cantor i suppose. probably Dedekind as well ?
10:51:18 <ibid> ski: cantor at the latest.
10:52:00 <ski> monochrom : should be just `a -> Bool' by parametricity ?
10:52:19 <phaul> correction: applying Set data constuctor - nm
10:52:22 <monochrom> yes. I'm adding redundancy and obfuscation
10:52:38 <ibid> eschew obfuscation
10:52:45 <ibid> :D
10:52:59 <monochrom> I love obfuscation. it makes great jokes.
10:53:27 <ibid> "eschew obfuscation (go on, look them up)" is the best one i've heard
10:53:47 <monochrom> of course in serious applications I condemn obfuscation and write acidically about it.
10:53:58 <monochrom> oh hahaha
10:54:28 <monochrom> in fact to the point I call most usages of the word "thunk" obfuscation
10:54:38 <BrittB> phaul: sorry I am just having a hard time understanding. I think I am on the right track now, is this almost correct? http://lpaste.net/775327491978952704
10:54:46 <monochrom> until and unless you write a compiler, "thunk" = expression
10:55:05 <mauke> BrittB: no
10:55:11 <ibid> monochrom: you could also be discussing compilation techniques without writing one
10:55:15 <mauke> BrittB: there is no -> data constructor
10:55:25 <mauke> in fact, you can't look "into" functions at all
10:55:39 <phaul> BrittB: almost there ;)
10:55:40 <monochrom> ok right yes. but the "most usages" there are not discussing compilation techniques either.
10:55:53 <ibid> monochrom: example?
10:56:03 <monochrom> they are simply casual talk of lazy evaluation
10:56:13 <ibid> ok
10:56:14 <phaul> just put in `f` as the argument of transpose,
10:56:30 <ttt_fff> does implementing 'fail' in my monad allow me to catch (1) pattern match failures and (2) irrefutable pattern failures?
10:56:42 <phaul> BrittB: f being the function
10:57:06 <BrittB> phaul: then do I use f or no?
10:57:38 <bennofs> > (do ~(Left x) <- return $ Right 4; return x) :: Maybe Int
10:57:40 <lambdabot>  Just *Exception: <interactive>:3:5-33: Irrefutable pattern failed for patter...
10:57:45 <bennofs> > (do Left x <- return $ Right 4; return x) :: Maybe Int
10:57:47 <lambdabot>  Nothing
10:57:51 <BrittB> ah I think I have it
10:57:52 <bennofs> ttt_fff: ^^^
10:58:04 <phaul> use f, that's bound to the function value you pass in. Then you can just wrap it in Set as Set f
10:58:14 <ttt_fff> bennofs: nice, thanks!
10:58:41 <ttt_fff> bennofs: wait, wtf is the difference between Left x and ~(Left x) ?
10:58:49 <BrittB> http://lpaste.net/775327491978952704    okay so this is correct finally? Thank you both for all of the help
10:59:02 <bennofs> ttt_fff: ~(Left x) is an irrefutable pattern
10:59:30 <ttt_fff> (do let (Left x) = Right 4) :: Maybe Int
10:59:33 <bennofs> ttt_fff: also called lazy pattern match I think
10:59:37 <phaul> BrittB: looks ok to me :)
10:59:48 <ttt_fff> > (do let (Left x) = Right 4) :: Maybe Int
10:59:49 <lambdabot>  The last statement in a 'do' block must be an expression
10:59:49 <lambdabot>    let (Left x) = Right 4
10:59:52 <bennofs> > (do let (Left x) = Right 4; return x) :: Maybe Int
10:59:53 <lambdabot>  <hint>:1:37: parse error on input ‘)’
10:59:57 <ttt_fff> > (do let (Left x) = Right 4; return 2) :: Maybe Int
10:59:58 <lambdabot>  <hint>:1:37: parse error on input ‘)’
11:00:05 <ttt_fff> > (do let (Left x) = Right 4; return x) :: Maybe Int
11:00:06 <lambdabot>  <hint>:1:37: parse error on input ‘)’
11:00:07 <bennofs> > (do let { (Left x) = Right 4; } return x) :: Maybe Int
11:00:08 <lambdabot>  <hint>:1:33: parse error on input ‘return’
11:00:25 <nocturne777> >:t Left 'z'
11:00:30 <bennofs> > (do let { (Left x) = Right 4; }; return x) :: Maybe Int
11:00:31 <lambdabot>  Just *Exception: <interactive>:3:11-28: Irrefutable pattern failed for patte...
11:00:41 <nocturne777> > :t Left 'z'
11:00:42 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:00:42 <ttt_fff> > (do let (Left x) = Right 4 >> return x) :: Maybe Int
11:00:43 <lambdabot>  The last statement in a 'do' block must be an expression
11:00:43 <lambdabot>    let (Left x) = Right 4 >> return x
11:01:00 <ttt_fff> bennofs: okay okay, thanks
11:02:10 <nocturne777> why ghci is giving me "Left 'z' :: Either Char b" when I do ":t Left 'z'". I was expecting that it would give me "Left 'z' :: Either Char a"
11:02:13 <nocturne777> ?
11:02:34 <bennofs> nocturne777: a and b are both variables, what does the same matter?
11:02:35 <shachaf> nocturne777: Why were you expecting that?
11:03:01 <bennofs> s/same/name
11:03:06 <nocturne777> shachaf: because of how Either is declared
11:03:25 <nocturne777> Either is the type constructor and a goes into the value constructor Left
11:03:42 <shachaf> Either is declared as data Either a b = Left a | Right b
11:03:54 <nocturne777> shachaf: correct
11:03:56 <shachaf> When you say Left (x :: Char), that means that a=Char.
11:04:00 <shachaf> So you get Either Char b
11:04:03 <BrittB> phaul: is there a way to check if an element made it? I started it but not sure if this is the right approach. http://lpaste.net/775327491978952704
11:04:04 <bennofs> nocturne777: GHC renames / generates fresh type variables a lot, so you shouldn't expect it to preserve any type variables
11:04:34 <shachaf> But of course saying that something is :: Either Char b or :: Either Char a makes no difference, like bennofs said.
11:05:16 <nocturne777> bennofs: I see.
11:05:18 <shachaf> GHC tries to reuse variables if it happens to come across them, but there's no guarantee.
11:05:53 <nocturne777> thank you for the explanation guys
11:06:25 <ParmesanCaesarAu> hmm
11:09:35 <BrittB> How can I add an instance declaration?
11:10:17 <Rotaerk> BrittB, come on... that's googlable :P
11:10:46 <mauke> BrittB: instance <class> <type> where ...
11:11:17 <BrittB> Rotaerk: That is what I'm working on lol just having a hard time with it
11:11:22 <BrittB> thanks mauke
11:17:40 <rajac2000> hi.. just started learning.. am confused with nubBy.. in below ex.
11:17:40 <rajac2000> nubBy (\x y -> x+y == 10) [2,3,5,7,8]
11:17:40 <rajac2000> how values from the list are bound to x & y
11:19:30 <hpc> :t nubBy
11:19:31 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
11:19:51 <hpc> rajac2000: consecutively
11:20:02 <hpc> (2,3), (3,5), (5,7), (7,8)
11:20:49 <hpc> > nubBy (\x y -> y == 10) [1,10,2,2,10,10,3]
11:20:51 <lambdabot>  [1,10]
11:21:19 <shachaf> Are you sure about that?
11:21:30 <hpc> i was sure just a second ago... :P
11:22:09 <HeladoDeBrownie> hint: nubBy takes O(n²) time
11:22:13 <rajac2000> thank you very much.. hpc
11:22:36 <monochrom> please use an equivalence relation when you use nubBy
11:23:18 <jmcarthur> rajac2000: hpc made a mistake
11:23:22 <shachaf> You can verify what gets passed to your function with Debug.Trace.
11:23:29 <hpc> ah yes, it's just backwards
11:23:38 <shachaf> length $ nubBy (\x y -> traceShow (x,y) (x+y==10)) [2,3,5,7,8]
11:23:51 <hpc> http://lpaste.net/5238292498186502144
11:23:58 <jmcarthur> nubBy is O(n^2), so there must be more pairings than just consecutively, sometimes
11:24:11 <HeladoDeBrownie> that's very confusing output
11:24:34 <shachaf> That's why I wrote it to produce non-confusing output.
11:24:47 <ski> rajac2000 : i second monochrom's recommendation
11:25:19 <rajac2000> thanks all..
11:25:50 <rajac2000> still got to focus more to understand..
11:25:59 <hiptobecubic> So I asked earlier about solving https://www.hackerrank.com/challenges/cavity-map/submissions/code/11058189 and someone (Cale?) mentioned just using an Array and indexing around. I've done that here but it feels pretty unsatisfying. http://lpaste.net/120906  suggestions?
11:26:03 <jmcarthur> HeladoDeBrownie: http://lpaste.net/5238292498186502144
11:26:11 <HeladoDeBrownie> so, it looks like every order-ignoring pairing is made once
11:26:26 <HeladoDeBrownie> jmcarthur, did you mispaste?
11:26:33 <jmcarthur> HeladoDeBrownie: refresh
11:27:03 <HeladoDeBrownie> jmcarthur, weird, following the link again brought up the old one, but then refreshing showed your annotation
11:27:36 <hpc> hiptobecubic: expand the comprehensions to fmap, (>>=), whatever
11:27:41 <hpc> hiptobecubic: then see how readable it can be
11:28:16 <monochrom> (\x y -> traceShow (x,y) True) will show you the optimistic case
11:28:58 <monochrom> in general: for each item, compare to all previous seen, not thrown away items
11:29:38 <BrittB> Rotaerk:  is this close? http://lpaste.net/775327491978952704   I'm getting an error
11:30:09 <BrittB> Can anyone help me with my instance?
11:30:45 <phaul> BrittB: you don't have equality on functions. Therefore you can't have them on Sets
11:31:47 <toblerone> does it make sense to have nested TVars? For example: http://lpaste.net/120908 what is the difference between using Env and Env2?
11:32:02 <gigabytes> is UndecidableInstances so terrible?
11:32:26 <hpc> it's a bit terrible
11:32:27 <monochrom> not terrible if you have a proof of termination
11:32:31 <hpc> there's worse, but sometimes you need it
11:32:42 <jmcarthur> BrittB: the error message is because Eq is for types (kind *), not type constructors (kind * -> *). the correct way to specify the instance is    instance Eq (Set a) where ...
11:32:55 <jmcarthur> BrittB: however, phaul is correct, also. your Set instance is not possible as written
11:33:02 <jmcarthur> s/Set instance/Eq instance/
11:33:20 <monochrom> in the same way, is recursion terrible? not terrible if you have a proof of termination.
11:33:51 <jmcarthur> my proof of termination takes finite time. i wait for some finite amount of time for it to compile.
11:34:09 <monochrom> yes, that is one way.
11:34:10 <jmcarthur> but i can't use this trick to disprove it
11:34:13 <hpc> that's about what undecidable instances does
11:34:27 <hpc> there's a depth limit that's somewhat small
11:34:34 <monochrom> if you can prove it, don't look for a disproof :)
11:35:13 <haskell_noob> Hi,
11:35:16 <monochrom> in the same way, sometimes it is pretty hard to prove that a program loops forever
11:35:19 <jmcarthur> i just mean i can never wait long enough to disprove it if it is not true, but i can always wait long enough to prove it if it is true.
11:35:44 <haskell_noob> I'd like to know what file extensions represent dynamic profiled libs in a cabal dist file tree.
11:36:05 <fryguybob> toblerone: I would think that you would want either TVar Mystate2 or just MyState
11:36:08 <jmcarthur> i can at least prove whether it takes long enough to terminate as to be impractical
11:36:16 <haskell_noob> So that I can see if my config could actually compile Snap with ghc7.8.4 without having to wait for the entire Stackage to rebuild on every try.
11:36:21 <monochrom> haskell_noob: my recollection is that there is no such thing
11:36:47 <BrittB> phaul: are you saying I can still have an instance I just need to change what comes after "where"
11:37:12 <haskell_noob> Ok. I'l trying to follow the instructions to get Snap to compile despite the ghc7.8.4 profiled libs bug, and so far I fail.
11:38:17 <phaul> no. it's not possible to implement
11:38:30 <haskell_noob> I have library-profiling: True \nexecutable-profiling: True in my cabal.config in a sandbox.
11:38:39 <haskell_noob> It's currently compiling and I expect it to fail.
11:38:46 <ski> jmcarthur : termination is assertative. non-termination is refutative
11:38:53 <toblerone> fryguybob: So you are saying that the extra layer is unnecessary? What if i wanted something like "TVar (Map Foo (TVar (Set Bar)))"? Still unnecessary?
11:39:00 <haskell_noob> Can someone suggest me a configuration that would bring this endaevour to success?
11:39:20 <monochrom> I don't think assertative vs refutative makes much difference.
11:39:38 <monochrom> instead, an existential statement vs a universal statement
11:40:05 <ski> (Steven Vickers used those terms in "Logic Via Topology")
11:40:22 <monochrom> which hints directly at how one is enumerable and the other isn't, and the whole arithmetic hierarchy
11:41:39 <fryguybob> toblerone: It depends on what you want TVar (TVar a, TVar b) is different from (TVar a, TVar b).  I usually think in terms of what do I want to be able to independently update.
11:41:51 <BrittB> phaul: how can I run transpose (\ b -> b == "test")  then?
11:43:06 <monochrom> what is transpose?
11:43:22 <BrittB> monochrom: http://lpaste.net/775327491978952704
11:43:47 <toblerone> fryguybob: In what way are they different? With (TVar A, TVar b) does updating TVar A mean I am copying TVar B along with it?
11:44:13 <BrittB> monochrom: I am having difficulty with this and I might not be able to use an instance so I am stuck :(
11:44:41 <phaul> BrittB: To use it for anything you would need more utilities like elem - membership testing to try it. Unfortunately with that Set representation, you can't print Sets, or test whether they are eqaul
11:44:46 <fryguybob> toblerone: Depends on what you mean by "updating".
11:46:20 <fryguybob> toblerone: If I have some  x@(a,b) :: (TVar a, TVar b)  and I do  writeTVar a ...  nothing happens to b
11:46:22 <BrittB> phaul: can I change it so it could?
11:47:02 <phaul> BrittB: you should be able to write elem. It takes an `a' and a `Set a' gets the predicate function out of the Set and applies it on `a'
11:47:05 <fryguybob> toblerone: If I build some x' = (a',b) I'm "copying" the reference to b
11:47:25 <toblerone> right
11:48:33 <phaul> BrittB: then you can test it as elem "test" (transpose $ \a -> a == "test") should give you True
11:48:40 <jmcarthur> BrittB is running up against the awkard difference between covariant and contravariant models of sets. one is a predicate. the other is a collection.
11:49:08 <BrittB> phaul: I've seen 'elem' used before but never have used it myself. How would I go about doing this?
11:49:09 <jmcarthur> annoyed with myself for swapping the ordering
11:50:39 <toblerone> fryguybob: I've found this: https://hackage.haskell.org/package/stm-containers which tells me that there are additional considerations to make when using STM like this, but I can't find much detailed information.
11:50:54 <gigabytes> guys
11:51:05 <gigabytes> what does "orphan instance" mean?
11:52:15 <toblerone> it means someone has declared in instance of a typeclass in a module that neither declares the typeclass itself or the datatype you are declaring an instance for
11:52:25 <monochrom> it means the instance code is outside both the module that defines the type and the module that defines the class.
11:52:37 <toblerone> https://wiki.haskell.org/Orphan_instance
11:53:18 <fryguybob> toblerone: I'm not finding a reference to "additional considerations"
11:53:23 <phaazon> hm
11:53:28 <phaazon> is there a guard for Alternative?
11:53:51 <quchen> It's been proposed to generalize guard with the AMP
11:54:06 <quchen> But nothing's been done yet I think, in particular there's no standard Alternative guard
11:54:13 <phaazon> yeah, like, guard b | b = pure () | otherwise = empty
11:54:25 <toblerone> fryguybob: oh, well i doesn't say that. I'm just inferring that from the fact that this module makes specialized versions of the data structures for use with STM
11:54:38 <phaazon> for netwire it’d be neat
11:54:59 <phaul> BrittB: maybe try writing this function first: toPredicate :: Set a -> (a -> Bool)
11:55:07 <toblerone> which tells me that it isn't quite as simple as wrapping them in a TVar
11:55:26 <toblerone> oh well. I'm probably optimizing prematurely anyways...
11:55:34 <fryguybob> toblerone: Oh, certainly.  This is what I'm saying.  If you want to independently update things, they need to be in different TVars
11:56:23 <BrittB> phaul: what would that do?
11:56:30 <deech>  I just released http://hackage.haskell.org/package/fltkhs-0.1.0.0, a GUI toolkit which allows writing cross-platform native apps in pure Haskell. The announcement is here: https://mail.haskell.org/pipermail/haskell-cafe/2015-February/118301.html.
11:56:47 <phaul> get the predicate function out of the Set type that was used to create it
11:57:01 <phaul> the inverse of transpose
11:58:17 <dulla> :u
11:58:23 <BrittB> phaul: sorry I don't understand exactly.  How would that help?
11:58:41 * hackagebot origami 0.0.2 - An un-SYB framework for transforming heterogenous  data through folds  http://hackage.haskell.org/package/origami-0.0.2 (nedervold)
11:59:36 <toblerone> fryguybob: well I'm not sure what you mean by "independently".
12:00:33 <toblerone> err
12:00:51 <toblerone> well I guess i sorta see. I guess my question really is about the performance characteristics
12:00:52 <fryguybob> toblerone: If we have  type T = TVar (a,b)  and  type T' = (TVar a, TVar b), consider what an STM action that updates a looks like
12:01:33 <toblerone> for which type?
12:01:40 <fryguybob> Both
12:02:13 <fryguybob> updateT v a' = do (a,b) <- readTVar v; writeTVar v (a',b)
12:02:15 <toblerone> updateT' fn (a',b') = (modifyTVar' a fn, b)
12:02:26 <phaul> BrittB: if you have that function, you can apply it on the value that you are membership testing.
12:02:26 <fryguybob> :D
12:02:47 <fryguybob> Now imagine the same for updating b.
12:03:02 <monochrom> is this a philosophical pursuit of "what does it mean to be a set?"?
12:03:14 <fryguybob> If you have two threads, one updating a and one updating b for which type T or T' do the updates happen independently?
12:03:40 <toblerone> T'
12:03:50 <fryguybob> Right
12:03:54 <monochrom> http://captionsearch.com/image.php?id=244
12:04:27 <Rotaerk> heh
12:05:19 <fryguybob> toblerone: Unfortunately this isn't the whole story for performance, but it speaks to the opportunities for independence vs "false" sharing.
12:05:50 <fryguybob> toblerone: For performance you also have to consider the overhead of having more TVars vs more pure data structure.
12:06:01 <BrittB> phaul: toPredicate (Set a) = a        like this?
12:06:12 <phaul> yes!
12:06:17 <toblerone> Sure, I'd consider using an MVar instead
12:06:25 <Buttons840> are there any GUI programs that can sort the columns in GHC's time/space profile report?
12:06:33 <Scriptonaut>  /quit
12:06:33 <BrittB> phaul: then call fromFunc f = toPredicate (Set f)
12:06:42 <fryguybob> toblerone: Well STM will be faster in many cases.
12:06:47 <toblerone> oh ya?
12:06:57 <bennofs> Buttons840: if you use emacs, I have a little snippet of elisp that convert a haskell prof file to org-mode tree
12:07:07 <toblerone> because of deadlocks and such?
12:07:24 <fryguybob> MVar's suffer for an over abundence of fairness.
12:07:36 <fryguybob> from*
12:07:37 <bennofs> Buttons840: then you can collapse everything and drill down in the ares you're interrested in
12:07:52 <toblerone> fairness?
12:08:14 <ttt_fff> does a irrefutable pattern match failure just call "fail" or does it just go to "error", when inside of a monad ?
12:08:26 <Buttons840> bennofs: don't know emacs :(
12:08:30 <fryguybob> When multiple threads block to wait on an MVar they are queued fairly so that they each get their turn.
12:08:37 <bennofs> ttt_fff: are irrefutable pattern should not fail
12:08:51 <bennofs> ttt_fff: it is only checked when one of the matched values is actually requested
12:09:17 <monochrom> it goes to "error"
12:09:20 <ttt_fff> bennofs: hmm, hmm, right, I don't understand laziness
12:09:22 <fryguybob> This can make things go slowly as it may be much faster to be unfair.
12:09:25 <bennofs> > (do let { ~(Left x) = Right 4; }; return 3) :: Maybe Int
12:09:27 <lambdabot>  Just 3
12:09:36 <Buttons840> on the GHC time/space profile report; what do the lines that end in .\ mean?
12:09:39 <bennofs> -> x is never needed, so pattern isn't checked
12:09:45 <ttt_fff> bennofs: right
12:09:54 <bennofs> > isJust (do let { ~(Left x) = Right 4; }; return x)
12:09:55 <lambdabot>  True
12:10:01 <bennofs> > fromJust (do let { ~(Left x) = Right 4; }; return x)
12:10:04 <lambdabot>  *Exception: <interactive>:3:20-38: Irrefutable pattern failed for pattern (D...
12:10:05 <BrittB> phaul: I think I misunderstood what to do with the toPredicate.     do I do this?  transpose f = toPredicate (Set f)
12:10:34 <fryguybob> toblerone: If you are only dealing with low thread counts (8 or below) you should be fine with a single TVar with a pure data structure behind it.
12:10:34 <ttt_fff> bennofs: thanks for these examples for clarifying it up
12:11:21 <gigabytes> toblerone: is it a problem?
12:12:20 <toblerone> fryguybob: does this apply only to OS threads?
12:12:28 <toblerone> gigabytes: is what a problem?
12:12:32 <toblerone> oh
12:12:38 <toblerone> orphan istances?
12:12:38 <gigabytes> sorry, the orphan instance
12:12:58 <gigabytes> I mean, GHC gives me a warning about it, is it really a concern?
12:13:47 <fryguybob> toblerone: I'm refering to hardware resources (number of threads in your processor) and number of haskell execution contexts (each using an OS thread).
12:13:55 <toblerone> here is a pretty complete explanation why its generally considered a "bad thing" http://stackoverflow.com/a/3079748/536017
12:14:22 <fryguybob> toblerone: +RTS -N8  would be 8 threads.
12:14:26 <toblerone> ah ok
12:15:52 <toblerone> gigabytes: I think the short of it is that automatically export instances of types from modules. This leads to conflicts
12:16:10 <BrittB> phaul:  am I getting close? http://lpaste.net/775327491978952704
12:16:25 <toblerone> fryguybob: Well thanks a lot. Like i said, I'm certainly prematurely optimizing here, but its been a question ive run into before
12:17:00 <fryguybob> toblerone: No problem, feel free to ask questions any time.
12:17:56 <gigabytes> toblerone: the point is, I have an AST module and a PrettyPrint module. In the latter I have Show instances of data type declared in the former. So I get orphan instances warnings for these instances
12:18:22 <gigabytes> Is there a better way to handle this situation or can I simply turn off the warning? (I'm compiling with -Wall)
12:19:39 <mpickering> gigabytes:  You shouldn't use Show to pprint
12:20:23 <toblerone> Well one option would be to declare the Show instance of the AST in its own Module, and use a newtype for when you want to pretty print it. Alternatively, you could avoid using show altogether for pretty printing
12:20:39 <gigabytes> mpickering: I use Text.PrettyPrint to do the work, but then I need a show instance because I'm doing things at the interpreter and without a Show instance it's impossible
12:20:46 <gigabytes> its*
12:22:31 <begriffs> I'd like to sample a DiffTime value (from the time package) using the uniform distribution in the random-fu package. However I get the error "Could not deduce Distribution Uniform DiffTime" while DiffTime is an instance of so many typeclasses I'm surprised it can't make something work http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Clock.html#control.i:DiffTime
12:22:31 <toblerone> yeah, well you could just ignore the warning. Or why not just define the pretty printing instance in the AST module?
12:23:53 <gigabytes> toblerone: I like to separate things. Pretty printing is a boring and useless part of the code
12:23:58 <toblerone> sure
12:24:26 <begriffs> In order to get a uniform sample I need something that implements any of these typeclasses (including Ordering which seems promising). https://hackage.haskell.org/package/random-fu-0.2.6.2/docs/Data-Random-Distribution.html#control.i:Distribution
12:25:34 <toblerone> well I think that you can probably safely use an orphan instance in this situation... But in general its probably not the best idea, and you should try to find alternatives before reaching for it
12:26:03 <Buttons840> http://lpaste.net/120910 -- can someone help me understand the stats about my boardRows function? It is reported multiple times in the profile report.
12:26:10 <gigabytes> toblerone: yes I'll try
12:27:52 <Buttons840> for example, does the boardRows function use 15% or 30% of the runtime? both numbers are reported
12:28:28 <pavonia> Buttons840: Does boardRows has local function bindings?
12:29:45 <Buttons840> pavonia: like a let or where? is that what you mean by local function bindings?   it does have a lambda
12:29:58 <Buttons840> boardRows maps a lambda function over a list
12:30:19 <pavonia> That's what I meant, yes
12:30:23 <jmcarthur> Buttons840: the total running time within boardRows minus the total running time within boardRows.\ is 15% of your running time.
12:30:34 <hiptobecubic> Hmmm.... I have a vector like <3, 4, 1> and I want something like <3, 2, 2, 1>, that is, a vector whose elements are the number of elements greater or equal to the index from the original vector. So there are 3 elements >= 1, 2 >= 2, 2 >= 3, and 1 >= 4.
12:30:35 <Buttons840> ah.. boardRows.\ must refer to the lambda -- a nameless function?
12:30:39 <jmcarthur> Buttons840: boardRows.\ itself accounts for 30% of your running time
12:30:48 <hiptobecubic> It seems like this would be some kind of weird accumulate? or unfold or something?
12:30:55 <jmcarthur> Buttons840: the total running time within boardRows is 45% of your total
12:31:11 <pavonia> jmcarthur: What does .\ denote exactly?
12:31:40 <jmcarthur> pavonia: i'm guessing that's an unnamed lambda that has been lifted by the optimizer, but i don't know for sure
12:31:48 <Buttons840> pavonia: my guess is that it might say something like boardRows.localFunction -- but since it's a lambda it has no name, and so it says boardRows.\ ?
12:32:21 <pavonia> That's my guess to, but, well, only a guess :p
12:32:25 <pavonia> *too
12:32:31 <Buttons840> that confused me too, i thought it was line continuation or something; forgetting that \ is for denoting lambdas in haskell
12:32:46 <jmcarthur> Buttons840: i think the "individual" and "inherited" times give in the table at the bottom are more informative than the summary at the top
12:32:50 <jmcarthur> *given in
12:33:46 <jmcarthur> Buttons840: just because they are better described, that is
12:33:58 <Buttons840> jmcarthur: i agree
12:35:45 <bennofs> Note that profiling can sometimes change the runtime of a program a lot (just compiling my program with -prof makes it 4x slower as an example, without even enabled profiling at runtime)
12:36:54 <Lokathor> i want to map minus 2, but "map (- 2)" does the wrong thing in this case :/
12:37:20 <hiptobecubic> Lokathor, (subtract 2)
12:37:32 <hiptobecubic> :t (- 2)
12:37:33 <lambdabot> Num a => a
12:37:39 <Lokathor> !
12:37:41 <hiptobecubic> > (- 2) == -2
12:37:42 <Lokathor> fantastic
12:37:43 <lambdabot>  True
12:37:58 <EvanR> :t (-)
12:37:59 <lambdabot> Num a => a -> a -> a
12:38:05 <EvanR> :t (2 -)
12:38:06 <lambdabot> Num a => a -> a
12:38:09 <Lokathor> yeah it was parsing it as the negative 2
12:38:09 <EvanR> :t (- 2)
12:38:10 <lambdabot> Num a => a
12:38:17 <hiptobecubic> EvanR, isn't it great?
12:38:19 <Lokathor> odd edge case, since map (+2) works
12:38:24 <Buttons840> 30% of my program is being spent doing Data.Map.lookup's; what are some faster data structures I can use?
12:38:41 <EvanR> IntMap
12:38:43 <hiptobecubic> Buttons840, hashmap maybe? Depends on what your keys are
12:39:44 <Buttons840> Map (Int, Int) Color ; where data Color = White | Black
12:40:03 <EvanR> you can encode two ints into one and use IntMap
12:40:08 <EvanR> or use a 2D array
12:40:14 <raek> Lokathor: use 'subtract'
12:40:24 <Lokathor> uhm, might a set help? only track either the white or black locations?
12:40:26 <cmccann> jmcarthur: my favorite is when the profiler results show I'm spending 30% of my time in a function with 0 entries
12:40:38 <raek> oh, hiptobecubic already said that.
12:41:17 <hiptobecubic> raek, :)
12:41:24 <bennofs> Buttons840: what is the range of those ints?
12:41:27 <EvanR> Lokathor: a Set of keys of the form (Int,Int) is going to be the same as Map, since a Set is a Map with no values
12:41:46 <Buttons840> bennofs: it's a board game with a 6 * 6 grid , so 0 through 5
12:41:49 <bennofs> EvanR: it is probably implemented differently through
12:41:51 <cmccann> given that "entries" seems to either be "number of times called" or "mysteriously 0" I'm guessing it has something to do with functions being inlined
12:41:56 <phaazon> @hoogle (Arrow a) => (b -> (c,d)) -> a b (c,d)
12:41:57 <lambdabot> No results found
12:42:02 <Lokathor> ah, well i suppose i should have predicted that
12:42:09 <bennofs> Buttons840: ok, so you have 36 fields. I suggest using a Word64
12:42:17 <EvanR> Buttons840: a 6x6 Array
12:42:27 <bennofs> Buttons840: and just saying: "bit 3 set -> field 3 white, else black"
12:42:35 <bennofs> that will be the fastest IME
12:42:38 <EvanR> bit fields ;_;
12:43:05 <EvanR> what is this, ANSI C
12:43:49 <bennofs> Buttons840: since you need a Word64 anyway then, you can even encode your (Int,Int) easily as one Int: use bits 3 - 5 for one int and bits 0 - 2 for the other
12:44:13 <Buttons840> bennofs: my mistake, but the type is actually Map (Int, Int) (Maybe Color)
12:44:17 <bennofs> (so you don't need `quotRem` for converting, which is slower than bits)
12:44:20 <bennofs> ah :|
12:44:31 <Lokathor> as much as i hate the idea of bit fields, that Word64 method does sound effective
12:44:41 <hiptobecubic> ugh
12:44:44 <EvanR> :(
12:44:48 <bennofs> Lokathor: why is it bad? I found it's pretty nice to work in haskell
12:45:04 * EvanR starts using Word64 instead of Bool
12:45:08 <EvanR> its faster
12:45:21 <bennofs> Lokathor: data Board = Board { freeFields :: Word64; fieldColor :: Word64 }
12:45:25 <bennofs> EvanR: it's probably not
12:45:37 <bennofs> Lokathor: and then write nice functions on top of that and put it in a module
12:45:45 <EvanR> i can have 64 Bools! its saving a lot of space... ACTUALLY
12:45:56 <hiptobecubic> bennofs, at least newtype, that's a horrible data type.
12:46:10 <bennofs> hiptobecubic: oops, forgot the strictness annoation, you're right
12:46:11 <Lokathor> bennofs, over application of the technique, even when you don't need the speed, can cause a loss of clarity that leaves a bad taste in the mouth of folks
12:46:18 <cmccann> does an unboxed vector of Bool use bitfields? I don't think so. makes me wonder if it's really a good idea :P
12:46:31 <cmccann> I think it just uses Word8s
12:46:32 <hiptobecubic> cmccann, it does in C++
12:46:43 <cmccann> no, I mean Data.Vector.Unboxed
12:46:50 <bennofs> I'm using a bitset for a Board representation in my current program
12:46:58 <hiptobecubic> and I'm pretty sure they make all the right choices :)
12:47:06 <Lokathor> wait, what game has a 6 by 6 board?
12:47:09 <cmccann> then again maybe it's just because bitfields would muck up vector's fusion trickery
12:47:36 <bennofs> Really, I don't see the difference between       vector V.! i      and bitset `testBit` i
12:47:41 <Buttons840> Lokathor: pentago
12:47:47 <bennofs> why would a bitset be regarded less elegant?
12:48:07 <EvanR> bennofs: because there are 8 bits in a byte. there are 6x6 squares
12:48:11 <EvanR> come on
12:48:11 <bennofs> haskell even has all the nice functions you need already: insert -> setBit, remove -> clearBit
12:48:25 <bennofs> EvanR: Word64?
12:48:49 <EvanR> you could say its elegant to have 19 bit bytes, and simulate a 12x12x12 program
12:48:52 <EvanR> but why
12:49:03 <ReinH> xkb: Hey, I saw your gist from earlier
12:49:25 <bennofs> EvanR: I just don't understand why a bitset is much worse than using a Vector for that
12:49:33 <EvanR> bennofs: i suggested a 6x6 array
12:49:34 <phaazon> god I suck at arrow stuff
12:49:39 <phaazon> I have an arrow a b b
12:49:51 <phaazon> and a * TimeSpec
12:49:56 <EvanR> not 6x7 with a row ignored for elegance
12:50:05 <IP92> can someone tell what's wrong with my addr function http://pastebin.com/VNSCjLjc it's supposed to add one multiplied row to another
12:50:10 <phaazon> I’d like to make an arrow a b (b,TimeSpec)
12:50:24 <Lokathor> in the case of a 6 by 6 array, you'd need to expand the elements to be White | Black | Empty
12:50:37 <EvanR> or Maybe Color
12:50:40 <EvanR> whichever
12:50:50 <Lokathor> yeah maybe would be good too
12:50:53 <EvanR> its already a map to Maybe
12:51:03 <EvanR> so i guess you do need another layer
12:51:17 <bennofs> the non-maybe variant has the advantage that you can unbox the array then
12:51:51 <EvanR> yes unboxing is very elegant
12:52:01 <EvanR> a strictness annotations on every field in the whole program
12:52:19 <bennofs> EvanR: I mean you *could* unbox it if you need it
12:52:20 <EvanR> an inlining
12:52:23 <dulla> ?
12:52:42 <EvanR> might as well write it in asm, its fairly elegant imo
12:53:22 <bennofs> EvanR: there is a difference between doing this in ASM directly, and doing it in Haskell by hiding it behind a nice interface so that the rest of your program doesn't actually see that you're using a bitset
12:53:38 <EvanR> you were saying the bitset itself was a nice interface
12:53:45 <ReinH> xkb: Are you still having issues with the parser?
12:54:05 <bennofs> EvanR: no, I said that haskell has fairly nice functions for working with bitsets already. That doesn't mean that you should use them without hiding them behind an interface
12:54:30 <bennofs> EvanR: In fact, I suggested an abtract (ok, I didn't say it was abstract) type Board which uses bitset for the implementation
12:54:35 <ReinH> xkb: btw, Data.Attoparsec.Char8 is deprecated. You should use Data.Attoparsec.ByteString.Char8
12:55:24 <ReinH> xkb: (Although ByteString.Char8 doesn't handle encodings so will be broken for anything other than a strict 8-bit encoding like ascii)
12:56:03 <ReinH> xkb: Lastly, you can use (<?) to make parseCommand a bit nicer: https://gist.github.com/reinh/7e93f3fdad806221afcf#file-commandparser-hs-L11-L16
12:56:38 <EvanR> bennofs: it comes down to what you find entertaining
12:56:43 <EvanR> in the end
12:57:06 <EvanR> im board of the years i spent pointer swapping and bittwiddling to do normal tasks in C
12:57:09 <EvanR> bored
12:57:21 <ReinH> EvanR: bitsets?
12:57:29 <ReinH> What is a bitset?
12:57:36 <EvanR> huh?
12:57:45 <ReinH> Er. bennofs what is a bitset?
12:58:09 <bennofs> ReinH: using Word64 to store a Set Int (where the ints are all < 64)
12:58:13 <EvanR> bitvector bitfield
12:58:20 <bennofs> ReinH: by just setting the corresponding bits in the word
12:58:40 <EvanR> you cant store any Int that way, just powers of 2
12:58:44 <ReinH> A bit *vector*. Positionality is important. ;)
12:59:14 <ReinH> Ah. A bit vector used to implement a set.
12:59:21 <bennofs> ReinH: it doesn't give you an order. If you first insert 2, then insert 3, it's the same as inserting first 3 then 2
12:59:29 <bennofs> (bit 2 and 3 is set)
12:59:33 <ReinH> bennofs: Yes, I understand that.
12:59:47 <EvanR> 11 union 111 is 111 ..?
12:59:50 <ReinH> It may interest you to know that I'm writing a QQ for bit patterns.
13:00:08 <EvanR> er 10 111
13:00:23 <ReinH> > 0x3 .|. 0x6
13:00:24 <lambdabot>  7
13:00:25 <bennofs> ReinH: what does that do?
13:00:27 <ReinH> Yes.
13:00:30 <bennofs> (the QQ)
13:01:04 <ReinH> bennofs: You can write, e.g., instruction [byte|11sssddd|] = mov (reg sss) (reg ddd)
13:01:23 <ReinH> patterns with variables compile into bit twiddling, patterns without variables compile into Word8
13:01:34 <ReinH> Once I get it working for Word8 I'll try to generalize it to any instance of Bits
13:02:16 <darkroom> if i have an intmap and a binary operation is there a good way to apply each entry in the map just once to another entry?
13:02:21 <ReinH> (bit twiddling and shifting)
13:02:40 <bennofs> ReinH: ah, that is nice. Can you generate Isos from that?
13:02:48 <Buttons840> IntMap.lookup has complexity O(min(n,W))   what is W?
13:02:58 <EvanR> number of bits in a word
13:02:59 <ReinH> bennofs: Maybe? I generate QQs for patterns and expressions right now.
13:03:01 <darkroom> integer max
13:03:08 <ReinH> But I haven't quite gotten the pattern QQ to work :(
13:03:17 <hiptobecubic> darkroom, what are you actually trying to do?
13:03:20 <ReinH> I'm louse at TH though
13:03:24 <ReinH> *lousy
13:03:27 <bennofs> ReinH: it would be nice to use for (Word8,Word8) <-> Word16 for example
13:03:34 <darkroom> basically i have a collison detection function that takes two hitboxes
13:03:39 <darkroom> and an intmap of hitboxes
13:03:41 <ReinH> bennofs: Oh, I suppose you could. I wrote my own iso for that.
13:04:11 <darkroom> then returns a boolean and i need to check all the hitboxes against each other
13:04:31 <EvanR> Buttons840: after you have 32 or 64 things in the map, its constant
13:04:36 <ReinH> bennofs: You could wrote toBytes [bin|xxxxxxxyyyyyyyy] = (xxxxxxxx,yyyyyyyy) but not the other way
13:05:22 <ReinH> Hmm, you'd need fromIntegral
13:05:27 <ReinH> You'd still probably write fromBytes (x,y) = (fromIntegral x `shiftL` 8) .|. fromIntegral y
13:05:58 <cmccann> darkroom: you want to check everything against everything else? for N hitboxes that's N^2 comparisons. that won't scale well, will it?
13:06:00 <ReinH> but then you have your iso toBytes fromBytes :: Iso' Word16 -(Word8,Word8)
13:06:07 <ReinH> s/-//
13:06:41 <darkroom> well the algorithem i have in my mind isnt N^2 because in N^2 you will have duplicate checks
13:07:00 <EvanR> N^2 / 2 ~ N^2
13:07:13 <bennofs> darkroom: you can do it in sum [1..N] I think
13:07:15 <ReinH> bennofs: Hmm, I might be able to turn expressions that include variables into smart constructors.
13:07:21 <stelleg> any idea of how to take max of two Nats?
13:07:25 <darkroom> EvanR: is there a better way of doing collisons?
13:07:31 <zq> sum [1..N] is n^2
13:07:40 <bennofs> zq: eh, yes ofc
13:07:42 <zq> quadratic complexity, i mean
13:07:47 <ReinH> bennofs: I am writing this for my 8080 emulator opcode interpreter, but I realized it would be generally useful so I'm splitting it out.
13:07:49 <cmccann> darkroom: you can use a space partitioning tree
13:07:49 <zq> n * (n - 1) / 2
13:08:09 <darkroom> cmccann: is there a library for that?
13:08:29 <EvanR> theres a few
13:08:32 <ReinH> bennofs: The biggest advantage for me is avoiding all the junk lists I currently create https://github.com/reinh/Hask8080/blob/master/src/Hask8080/Opcode.hs#L42
13:08:34 <cmccann> darkroom: last I checked there were a couple half-baked ones :T
13:08:34 <Rotaerk> isn't sum [1..N] just O(n)? there are N-1 additions
13:08:39 <cmccann> there might be a better one now
13:08:47 <bennofs> ReinH: yeah, in my current project (game AI for hexagonal board with 60 tiles) I represent boards as either (Int, Int) or just and Int. a QQ could be used to write the converting function more easily :)
13:09:11 <EvanR> Rotaerk: computing sum [1..N] yeah... but the answer is ~ N^2
13:09:27 <EvanR> it grows with the square of N
13:09:31 <ReinH> bennofs: I have an Iso' for that https://github.com/reinh/Hask8080/blob/master/src/Hask8080/CPU.hs#L32-L34
13:09:35 <darkroom> thanks for the help guys
13:09:46 <ReinH> bennofs: You can use it as a constructor with (#) too, which is nice: https://github.com/reinh/Hask8080/blob/master/src/Hask8080/CPU.hs#L41
13:10:00 <xnil_> how do you export a data constructor from a module?
13:10:14 <xnil_> say i have
13:10:45 <ReinH> xnil_: module Foo (CTor) where data CTor = CTor
13:10:51 <xnil_> module IRC.Protocol (MsgData) where data MsgData = MsgData (Maybe [String]) (Maybe String)
13:11:02 <ReinH> Ah. data constructor.
13:11:10 <ReinH> (MsgData(..))
13:11:10 * ski would start with not naming the type ctor the same as the data ctor ..
13:11:21 <ski> (but that ^ also works ..)
13:11:25 <xnil_> ski: why not?
13:11:26 <ReinH> ski: touche
13:11:35 <codygman> Is it true that "persistent data structures allow only a single concurrent writer", context: http://www.reddit.com/r/programming/comments/2wfwqv/16_months_of_functional_programming/cossi7j
13:11:39 <Rotaerk> naming is hardd
13:11:43 <ski> xnil_ : imho it's confusing
13:12:09 <xnil_> they're both used in different contexts, and they're both exclusive to one another
13:12:18 <EvanR> codygman: you want the updates the be serializable right
13:12:19 <ski> iirc, `module Blah (MsgData (MsgData)) where ...' also works
13:12:37 <ski> xnil_ : the export list context is a context where both may be used
13:12:50 <ski> (so not exclusive)
13:13:02 <EvanR> codygman: its the same issue in a transactional database
13:13:07 <xnil_> i thought it was module IRC.Protocol (MsgData..) where ...
13:13:10 <xnil_> according to SPJ
13:13:13 <codygman> EvanR: I actually don't know much about the claim that guy made and I'm just trying to see if there is truth to it, I'm not facing the problem atm.
13:13:59 <EvanR> codygman: it sounds like hes missing a few points
13:14:19 <ReinH> codygman: persistent data structures (or ephemeral structures kept around in mutable containers) require locking, yes.
13:14:45 <ReinH> Except for those designed to be lockless, ofc
13:15:01 <EvanR> hes thinking about closure where your entire dataset is contained in a single assentially MVar
13:15:16 <EvanR> you can use many TVars and possibly avoid waiting
13:15:23 <ReinH> But we have tools like STM for working with such things in a nice way
13:15:28 <bennofs> codygman: why would you even need to use a persistent data structure if your doing IO anyway?
13:15:52 <codygman> ReinH, EvanR: Thanks!
13:15:59 <merijn> bennofs: I can think of tons of reasons to need a persistent data structure while doing IO...
13:16:21 <bennofs> merijn: ah, but that is not different in Haskell than in any other language, is it?
13:16:33 <codygman> bennofs: I usually just use persistent data structures for everything unless I have performance problems, but I can't really answer that.
13:17:00 <merijn> To be fair, you can only have single concurrent writers in imperative with some exceptions for things like lockless queues, but you can build those in haskell too
13:17:01 <EvanR> you dont hear much about persistence in haskell ;)
13:17:15 <merijn> EvanR: Sure you do, <3 acid-state
13:17:36 <EvanR> yes but i mean "persistent data structure" , which is essentially referring to almost all data structures in haskell
13:17:40 <ReinH> codygman: It's pretty simple: if (>=) 2 threads want to be able to interleave writes and reads to a persistent structure and have a consistent view of it, you need locking or some other mechanism for ensuring consistency. Haskell doesn't magically solve this for you, but it does provide some interesting tools to help you. :)
13:18:05 <bigs> EvanR: haha exactly! any decent language that prefers immutable data is going to have persistent data structs everywhere
13:18:05 <EvanR> and im glad we dont use this terminology because its confusing
13:18:13 <obb> what tools ReinH
13:18:15 <merijn> Rotaerk: I find that naming the first 26 variables is easy, then it becomes hard ;)
13:18:18 <bigs> but wrt shared state, sure -- transactions / locking are required
13:18:23 <ReinH> And actually, I get the feeling that the commenter is using "persistent" to mean exactly the opposite of persistent
13:18:25 <bigs> merijn: you demon
13:18:27 <merijn> obb: STM, MVars, etc.
13:18:30 <ReinH> i.e. to mean "mutable"
13:18:39 <bigs> aye, it would seem so
13:18:43 <codygman> ReinH: Thanks, from what's been said it seems like STM would be the answer in general, or TVars which EvanR said might avoid waiting.
13:18:43 <Rotaerk> you should be ashamed!
13:18:50 <ReinH> obb: e.g., LVars
13:18:57 <merijn> Oh, yeah!
13:19:00 <merijn> LVars are neat!
13:19:03 <ReinH> merijn: truly
13:19:06 <EvanR> bigs: transactions plz not locking, unless locking is meaningful to the semantics of your action (serialized execution of something)
13:19:22 <merijn> STM has some performance caveats, but in general it's pretty cool :)
13:19:24 <cmccann> ReinH: I think what he means is immutable data structures and mutable references, i.e. a single MVar holding a value
13:19:45 <ReinH> cmccann: Sure.
13:19:46 <cmccann> as was discussed earlier
13:20:07 <ReinH> cmccann: I think I understand what he *means*. ;)
13:20:41 <EvanR> its horrifying to think that given a single MVar with a big tree of program state in it... that you would want to arbitrarily allow "concurrent writers" to swap parts out
13:20:43 <bigs> EvanR: of course :P but it's worth mentioning the alternative
13:20:48 <bigs> haha yeah
13:20:54 <cmccann> ReinH: well, "persistent" is this sense means the value. if you take the value from the MVar and put something else in it, the value you took is still usable
13:20:59 <bigs> in fact persistent data structs + STM = happiness
13:21:08 <bigs> finer grain access control
13:21:10 <ph88> hey guys im trying to port some javascript to haskell.  In JS the object constructor instantiates a new object .. how would something like this be done in haskell?     this.guard = new Symbol(this);
13:21:29 <ReinH> cmccann: Right, but "persistent" irt haskell data structures usually means the opposite: immutable structures where any particular value "persists" (until GC'd).
13:21:47 <EvanR> cmccann: yeah so in this sense waiting to write to a persistent data structure doesnt make much sense in the first place, its immutable
13:21:50 <ReinH> e.g. Data.Map, where I can keep the old map around after I insert a new value, etc
13:21:58 <EvanR> wanting to*
13:22:01 <merijn> ph88: Like so:
13:22:18 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- recursive binding
13:22:20 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:22:21 <ReinH> cmccann: I'm just noting it as a potential source of confusion
13:22:30 <cmccann> ReinH: oh, it's definitely confusing :P
13:22:32 <bigs> ph88: hard to really tell how that would map to haskell, since the notion of an object *instances* doesn't really exist in an immutable, functional language
13:22:33 <EvanR> persistent as jargon is confusing
13:22:38 <bigs> ph88: can you elaborate
13:22:49 <cmccann> my first assumption is always that "persistent" means "not gone if my power goes out"
13:22:50 <merijn> bigs: I think he just wants a self-recursing record or the likes
13:22:55 <cmccann> which is an entirely different barrel of monkeys
13:23:01 <bigs> ah
13:23:09 <EvanR> yeah thats not what they mean
13:23:11 <ReinH> ph88: A line-by-line transliteration of JS to Haskell is not likely to end up with a reasonable Haskell program.
13:23:33 <merijn> ph88: "data Foo = Foo { label :: Int, cycle :: Foo }; x = Foo { label = 1, cycle = x }"
13:23:37 <ReinH> ph88: maybe take a step back and look at what the object is used for and try to do *that* in Haskell
13:23:51 <merijn> ReinH: Sure it is, look at that, perfectly sensible recursive definition :)
13:23:59 <ReinH> merijn: erm. :)
13:24:07 <merijn> Well, I guess he'd want a "symbol :: Foo -> Something" to add the indirection
13:24:16 <ReinH> merijn: what, in fact, does that have to do with his?
13:24:30 <bigs> haha
13:24:33 <merijn> ReinH: He's assigning a value based on "this" to a field in "this"?
13:24:45 <ph88> merijn thanks that   cycle = x seems good ... just that it's strange i can not do this in the data definition??
13:24:47 <merijn> That's what would seem the "hard" part
13:24:50 <ReinH> merijn: touche
13:25:04 <merijn> ph88: You don't have values in the definition, so that'd be meaningless
13:25:14 <ReinH> merijn: There's a significant difference in operational semantics between those, but anyway...
13:26:13 <ph88> merijn i mean the self reference, maybe the data constructor definition could be in such a way that i don't have to do    cycle = x   when i use the data type
13:26:14 <ReinH> cmccann: Yeah, to be fair, we're the ones using persistent in a non-standard way compared to the rest of the world...
13:26:25 <cmccann> codygman: anyway looking at the rest of that thread I think the guy's argument is essentially "my thinking about how programs work is very confused and I want my language to reflect that"
13:26:28 <ReinH> cmccann: Although I might call that "durable" instead. ;)
13:27:28 <codygman> cmccann: Thank you.
13:27:45 * ski . o O ( `y = x { label = 2 }' )
13:28:10 <EvanR> yes i love it when you take popular and not very enlightening jargon, drop it, and replacing it with two even better terms for two different things
13:28:45 <ReinH> EvanR: unsure if sarcasm :)
13:28:57 <ph88> why do i have to repeat the name of the datatype with record syntax ?     data Person = Person {} deriving (show)   ?
13:28:57 <EvanR> i dont know the meaning of the word!
13:29:07 <ReinH> EvanR: which word?
13:29:10 <EvanR> sarcasm
13:29:16 <HeladoDeBrownie> any of them, this is a post-word society
13:29:19 <ski> ph88 : you don't, it's not the name of the datatype, it's the name of the data constructor
13:29:27 <ReinH> EvanR: I thought you meant "durable" :)
13:29:28 <EvanR> post words
13:29:34 <ReinH> HeladoDeBrownie: <3
13:29:40 <EvanR> ReinH: durable is good, immutable is good
13:29:41 <ph88> ski on the right side of the  =  is the name of the data constructor ?
13:29:51 <ski> yes
13:29:56 <ph88> oki
13:30:05 <ReinH> ph88: It's a bit confusing because you can have data Foo = Foo, where Foo is both.
13:30:10 * ski 'd say `data Person = MkPerson { ... }'
13:30:12 <cmccann> codygman: though to be fair, I stopped taking him seriously when he led with "thinking this way is unnatural" as a criticism. of course it's unnatural. the way humans naturally think is entirely unsuited to thinking about programming.
13:30:18 <ReinH> Which is to say, there are two separate things that are both called Foo.
13:30:33 <ReinH> cmccann: :)
13:30:36 <EvanR> in clojure you talk about persisent data a lot as an implementation technique of immutable values, and this ingrains the implementation of things deeper in your reasoning about code
13:30:52 <cmccann> anything that forces people to step outside that comforting sense of "intuitive" understanding where they don't actually understand anything is a benefit in and of itself, in my opinion.
13:31:10 <HeladoDeBrownie> arguments from naturality are rarely valid on their own anyway, although intuitiveness should probably be taken into account in a user interface, i imagine
13:31:22 <HeladoDeBrownie> (but not necessarily allowed to rule)
13:31:34 <EvanR> but intuitiveness isnt natural ;)
13:31:37 <voidzero> intuitiveness, or recognition of common habits?
13:31:41 <EvanR> people are trained, its cultural
13:31:46 <HeladoDeBrownie> EvanR, i don't know what "natural" means in this context then.
13:31:49 <HeladoDeBrownie> ah.
13:32:17 <ReinH> This has all gotten quite philosophical all of a sudden
13:32:29 <EvanR> today UI idioms make sense to us, if you drop them in front of someone used to the GEM desktop, they might question your sanity for a second
13:32:37 <cmccann> HeladoDeBrownie: intuitiveness in UI comes down to a combination of consistency and familiarity.
13:32:40 <ReinH> Also, "all of a sudden" is such a strange phrase.
13:32:40 <voidzero> if most people are used to the × close-window button being at the top right of their screen.. then conforming to that in your own UI is not a sign of intuitiveness, but of habit appreciation
13:32:45 <ReinH> How does it even grammar?
13:32:58 <codygman> cmccann: Yeah, same here. I just didn' t know a rebuttal to what he said and took this as an opportunity to find out if there was something I was missing.
13:33:30 <HeladoDeBrownie> EvanR, i guess that familiarity thing is what you're talking about (re: cmccann)
13:33:32 <cmccann> if people are familiar with something consistently working in a particular way, making your thing work that way too is "intuitive".
13:33:38 <EvanR> voidzero: yeah the close button on old mac and beos had no X. you wouldnt know it closed your window ;)
13:33:47 <ph88> can i do pattern matching in a data constructor ?
13:34:02 <ski> EvanR : did it have a dot ?
13:34:03 <ReinH>  codygman I don't take issue with "mutable structures are not threadsafe", I take issue with basically everything else he said...
13:34:11 <EvanR> ski: no
13:34:14 <voidzero> that too. I guess my point is that 'intuition' is not the right word, 'habitual' probably is a better word.
13:34:29 <ski> ph88 : you can do pattern matching *on* a data constructor (applied to patterns)
13:34:31 <EvanR> in fact why would an X mean that
13:34:39 * ski dunno
13:34:40 <HeladoDeBrownie> cmccann, i think i probably value consistency more than "it works like things people are probably used to". although sometimes making a jump to something altogether consistent involves abandoning what we're used to, and as such creating a larger disconnect in expectations. it's unfortunate, but i wonder if there's a way around it.
13:34:49 <ski> on Amiga OS, there was a dot
13:34:50 <ReinH> voidzero: the design community makes use of J.J. Gibson's work on affordances here.
13:35:13 <cmccann> voidzero: intuition is where the consistency aspect comes in. if people are used to a pattern, and you do something they haven't seen before that nevertheless fits the pattern, they'll find it "intuitive".
13:35:16 <ReinH> voidzero: "X button in the top right closes windows" is an affordance.
13:35:58 <voidzero> cmccann, I agree with that; good point
13:35:59 <cmccann> HeladoDeBrownie: right. if the only things people are familiar with are not consistency, intuition is impossible.
13:36:03 <ReinH> voidzero: Or "a door knob affords twisting", "a handle affords pulling", etc.
13:36:04 <ph88> ski: must i make two different data constructors on the datatype or 1 constructor with more patterns?
13:36:05 <cmccann> *not consistent
13:36:19 <ski> ph88 : depends on what you want to do
13:36:47 <voidzero> ReinH, ok, affordance is a new word to me; heh, and to my spell checker, it seems :)
13:36:54 <HeladoDeBrownie> cmccann, in that case, i think what i wanted to say is that we should not let familiarity rule; even with a lot of learning an unfamiliar tool can be valuable. see all the people who learn to use vim or emacs :)
13:36:58 <EvanR> door handles like this [ afford pushing downward :S
13:36:59 <ReinH> cmccann: affordances are always in relation to agents and their capabilities :)
13:37:27 <ReinH> voidzero: it's jargon
13:37:41 <EvanR> HeladoDeBrownie: originally, probably out of refuge from anything else available at the time ;)
13:37:45 <voidzero> for whom? philosophers?
13:37:59 <voidzero> (i'm not a native english speaker)
13:37:59 <ReinH> voidzero: psychologists, originally
13:38:19 <ReinH> It was later used by designers and such as well
13:38:27 <voidzero> alright. Interesting. :-)
13:38:29 <ReinH> voidzero:
13:38:31 <ReinH> uh
13:38:41 <ph88> ski: ok _i think_ i want to have a record where i can pass in two different types .. depending on the type a different field should be set
13:39:15 * ski doesn't understand
13:39:18 <ReinH> Um. All of a sudden I can't paste?
13:39:24 <ReinH> @google Affordance Wikipedia
13:39:24 <lambdabot> http://en.wikipedia.org/wiki/Affordance
13:39:24 <lambdabot> Title: Affordance - Wikipedia, the free encyclopedia
13:39:25 <BrittB> Can someone please help me with this function?  http://lpaste.net/3769106412404211712
13:39:29 <cmccann> the interesting part about "intuitiveness" is when a consistent pattern exists but isn't obvious
13:39:30 <ReinH> voidzero: ^
13:39:30 <ph88> ski wait i will try to make it as far as i can
13:39:48 <cmccann> for example: what is the expected relationship between the functions foo and fooM?
13:40:09 <cmccann> the consistency isn't perfect, but if you know what "foo" does you can probably guess with 90% accuracy what fooM will be.
13:40:40 <ski> the latter, run in `Identity' will be equal to the former, module iso of `Identity a' to `a'
13:41:21 <HeladoDeBrownie> can we even write a rule for what adding M does? it seemed to me to be something like (use the deepest rightmost part of the type structure as the argument to some Monad m", but that falls apart if the thing being passed is a tuple, like in the case of StateT.
13:41:31 <HeladoDeBrownie> well,… actually that doesn't add M
13:41:32 <HeladoDeBrownie> i'm confused :P
13:41:55 <geekosaur> BrittB, neither of those make sense to me, actually
13:41:59 <HeladoDeBrownie> also please excuse my poor editing -_-
13:42:16 <ReinH> foo :: a -> b, fooM :: Monad m => a -> m b, likewise for any other instances of b in the type of foo
13:42:18 <ReinH> e.g.
13:42:21 <ReinH> :map
13:42:23 <ReinH> :t map
13:42:23 <lambdabot> (a -> b) -> [a] -> [b]
13:42:24 <ReinH> :t mapM
13:42:25 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
13:42:38 <ReinH> Ok, my rule is incomplete
13:42:48 <BrittB> geekosaur: do you know how I should do that instead? Those are the two that I tried and they don't work. Not sure what to do
13:43:04 <geekosaur> mostly because your definition of Set doesn't make a lot of sense. a Set is a function from a member to Bool? this is doable ("difference sets", I guess?) but there's no (++) on it
13:43:37 <merijn> I think the correct approach is
13:43:49 <HeladoDeBrownie> couldn't you take the union of such a "set" type by using (||) on the results of the respective functions?
13:43:56 <merijn> union (Set f) (Set g) = Set (\x -> f x || g x)
13:44:05 <BrittB> That is what I was realizing I can't use ++
13:44:21 <geekosaur> yes, something like that
13:44:23 <BrittB> yes merijn I think something like that
13:44:26 <cmccann> ReinH: if you want to be precise about it, I think turning (->) into kleisli arrows after uncurrying everything is more likely
13:44:50 <ReinH> cmccann: Ah, yeah. Perhaps.
13:44:52 <HeladoDeBrownie> cmccann, the "uncurrying" bit seems kind of arbitrary, and maybe not formulable in haskell, afaict
13:45:11 <cmccann> HeladoDeBrownie: that's sort of my point, it's hard to write down a single precise rule. but there's enough consistency to guide intuition.
13:45:17 <ReinH> cmccann: I think there's something about negative position and positive position as well, which perhaps that preserves
13:45:42 * ski prefers giving a rule for how to remove the `M'
13:45:47 <BrittB> merijn: that works perfectly! Thank you!
13:46:01 <BrittB> Did not realize I could use ||
13:46:12 <voidzero> ReinH, Thanks for the url, that was a fun read
13:46:21 <HeladoDeBrownie> ski, you're right, it seems like the M version is the proper version and the one without is just m ~ Identity while removing Identity from the types
13:46:32 <cmccann> ReinH: doubtful. think about what that would mean for mapM.
13:46:44 <ReinH> cmccann: Hmm, yeah.
13:46:47 <ReinH> voidzero: :)
13:47:10 <ReinH> HeladoDeBrownie: the non-M version is a specialization of the M version, right
13:47:21 <ReinH> (up to isomorphism)
13:47:55 <ReinH> MaybeI should be writing the M version of things first.
13:48:12 <cmccann> HeladoDeBrownie: just take any nested (->)s and turn it into a single (->) with a tuple on the left
13:48:32 <ski> one could probably give one rule for how to insert `M' for each one of a few different reduction strategies (like call-by-value,call-by-name)
13:49:18 <cmccann> anyway, consider filter vs. filterM. uncurrying filter gives (a -> Bool, [a]) -> [a]. lifting to kleisli arrows is (a -> m Bool, [a]) -> m [a]. curry that, and you have the type of filterM.
13:49:22 <ski> (cbv going from `A -> B' to `Monad m => A -> B m', cbn going to `Monad m => m A -> m B')
13:49:36 <ski> (where `A' and `B' are atomic types, of course)
13:49:46 <cmccann> uncurry-and-kleisli works for mapM as well
13:50:22 <ski> (er, s/B m/m B/)
13:50:41 <cmccann> I'm sure there's at least one example where uncurry-and-kleisli doesn't fit, but I can't think of one immediately
13:51:48 <ReinH> cmccann: write a paper on it :)
13:52:06 <ph88> ski: can you take a look at this? http://pastebin.com/DbegNtiu
13:52:17 <cmccann> ReinH: there's really not much else to say on the matter
13:52:24 <ReinH> cmccann: It'll be a short paper.
13:53:19 <ReinH> ph88: the terminal field can't be "blabla". Its type is Maybe Char.
13:53:40 <ReinH> And Symbol is a function of 4 arguments, not 1
13:53:56 <meoblast001> hi.. i'm using parsers and have this: "skipMany (try lineEndWhitespace) >> some parseRule"... should the start characters from lineEndWhitespace only be cleared from the set of expected next characters once something from parseRule has already been encountered?
13:54:09 <ski> ph88 : start by removing every `let' from there (if this is supposed to be a module in a file)
13:54:29 <ph88> ReinH: can i make something so that i don' t have to specify 3x Nothing Nothing Nothing if i just want to create a Symbol with the terminal set ?
13:54:49 <ReinH> ph88: you can write a function to do that, but you still have the type error
13:55:01 <ski>   baz = foo { terminal = Just "blabla" }  -- ph88, this is perhaps closer to what you wanted
13:55:03 <ReinH> mkTerminal x = Symbol Nothing Nothing (Just x) Nothing, for example
13:55:08 <ReinH> but you still have the type error
13:55:31 <ReinH> "blabla" is not a Char
13:55:44 * ski is assuming the type error has been fixed (at least in the head of ph88)
13:55:47 <ph88> yes ok .. its still pseudo code at this stage
13:56:00 <ph88> the basic types is not much a problem i can figure them out myself
13:56:29 <ph88> how can i do a test on bar so i know how to set the right values in baz2  ?
13:56:31 <ReinH> ph88: Also, since that function has a case on type of object, it's impossible to recreate in Haskell as such.
13:56:46 <ski> ph88 : for `baz2' you didn't say whether we should preserve all other fields of `baz'
13:56:50 <ReinH> You could use a function fro Either Symbol String or so.
13:56:53 <ReinH> *from
13:57:23 <ph88> ski: what do you mean preserve ?
13:58:39 <ski> ph88 : keep unchanged
13:59:26 <ski> in `baz = foo { terminal = Just "blabla" }', `baz' is defined to be just like `foo' (having all fields containing the same value), except that the `terminal' field of `baz' is to contain `Just "blabla"'
13:59:43 <ph88> ski yes baz should not affect baz2 and the other way around
13:59:46 <ski> so in this case, every field but `terminal' was preserved
14:00:32 <ph88> oh ok
14:00:36 <ski> ph88 : i'm not sure what you mean by "affect" here
14:00:38 <ReinH> (terminal still needs to be Maybe String)
14:01:21 <HeladoDeBrownie> i posit that thinking of javascript values as belonging to a single (static) makes accurate predictions about their nature and that if we represent them that way we can do anything we can do with them in languages like javascript
14:01:36 <ski> ph88 : surely if the `terminal' field of `bar' is `Just' of some value, you want the `terminal' field of `baz2' to also be that, and so what value is in the `terminal' field of `baz' affects what value the corresponding field of `baz2' will have
14:01:58 <HeladoDeBrownie> (granted, we lose the ability to reason about them before runtime if we do that)
14:02:09 <ski> (HeladoDeBrownie : "static" ?)
14:02:31 <HeladoDeBrownie> ski, i clarified, since "dynamically typed" languages often use "type" to mean "tag".
14:03:07 <HeladoDeBrownie> oops, i left out the word "type" -_-
14:03:07 * ski still has no idea what "static" meant there
14:03:12 <HeladoDeBrownie> single (static) type
14:03:41 <ReinH> ph88: We're glossing over a rather important problem here. Your function accepts strings, symbols, or rules as argument.
14:03:59 <ReinH> In Haskell, arguments to a function must each be of one and only one type.
14:04:13 <ReinH> So there is no way to write this function, as is, in Haskell.
14:04:25 <codygman> Is there a way to use cabal repl with "executable sections" of cabal files?
14:04:28 <ski> ReinH : not rules. "symbol"s having a rule present
14:04:31 <ReinH> You will need to make a decision about how to make this function typesafe.
14:04:44 <ReinH> ski: Yes rules. Look at like 37.
14:04:59 <ReinH> The last else case handles the case when the arg is neither a string nor a symbol
14:05:02 <ski> oh, i see. mea culpa
14:05:07 <ReinH> *line
14:05:19 <ReinH> Since it sets this.rule = value, I assume value in that case is meant to be a rule.
14:05:36 <meoblast001> okay.. slightly more refined... if i have "lineEndWhitespace = many space >> optional comment >> newline >> return ()" and "skipMany (try lineEndWhitespace)", why would it fail on a line containing only a new line?
14:06:12 * ski has to say it looks like this function is attempting to cram different behaviours into the same function (perhaps for "convenience")
14:06:52 <ReinH> Your options include: use a sum type to represent the multiple argument types, use separate functions for each argument type
14:07:33 <mauke> meoblast001: what's 'space'?
14:07:39 <ReinH> ski: This sort of thing (switching on object type as inferred by object behavior) is, imo, one of the worst design patterns that OOP enables.
14:07:53 <ReinH> s/inferred/guessed
14:07:58 <meoblast001> mauke: that comes from Text.Parser.Char
14:08:07 <meoblast001> oooh ugh... newline is in space
14:08:27 <ph88> ReinH, ski can you review my new version?  http://pastebin.com/yzRcAxUp
14:08:29 <ski> ReinH : fwiw, i thought doing this kind of thing was frowned on in OOP
14:08:30 <LambdaDusk> hey can someone briefly explan me how to use these "pattern" values here: http://hackage.haskell.org/package/sdl2-1.3.0/docs/Graphics-UI-SDL-Enum.html#g:37
14:08:30 <LambdaDusk> when I try to use them, GHC complains about "data contructor not in scope" and when I search for patterns in haskell, something entirely different shows up
14:08:38 <nurupo> haskell is going to space?
14:08:41 <ReinH> ski: Yep.
14:09:00 <ReinH> ph88: That can't possibly compile.
14:09:08 <ph88> ReinH: the original JS is not really clean
14:09:10 <ski> ph88 : you forgot to fix the type error
14:09:20 <ReinH> You still have the type error I mentioned originally.
14:09:31 <ski> ph88 : `Char' is not `String'
14:09:42 <koomi> LambdaDusk: those are pattern synonyms, you have to enable the PatternSynonyms extension to use them
14:09:44 <mauke> LambdaDusk: did you enable PatternSynonyms?
14:09:44 <ReinH> And you still face the same type safety problems implementing that function as written
14:10:06 <ph88> ReinH, ski the stirng in javascript is only 1 character long
14:10:18 <ReinH> ph88: "f" is a String, 'f' is a Char
14:10:23 <LambdaDusk> koomie, mauke. I added {-# LANGUAGE PatternSynonyms #-} in the head of the file, does that suffice?
14:10:27 <mauke> LambdaDusk: yes
14:10:33 <ph88> ReinH: oh ok !
14:10:34 <ReinH> If you are passing in a String, it is a String, regardless of length.
14:10:49 <LambdaDusk> mauke Yet, I get the error
14:10:57 <meoblast001> mauke: thanks. now it's working
14:11:04 <koomi> LambdaDusk: can you show us the code?
14:11:04 <ReinH> ph88: And it's still impossible to implement that function as written.
14:11:05 <meoblast001> i always forget space includes newlines.. i find that sort of misleading
14:11:17 <mauke> LambdaDusk: can I see your source?
14:11:44 <koomi> LambdaDusk: you cane use lpaste.net and post the link here
14:11:59 <lpaste> LambdaDusk pasted “Problem with patterns” at http://lpaste.net/120915
14:12:03 <merijn> LambdaDusk: What's the error after enabling patternsynonyms? And are you compiling with -Wall?
14:12:37 <LambdaDusk> merijn Just "data constructor not in scope"
14:13:14 <merijn> LambdaDusk: Which GHC version?
14:13:31 <ReinH> ph88: You can write functions symFromTerminal :: String -> Symbol, symFromRule :: Rule -> Symbol, symFromSymbol :: Symbol -> Symbol that each do one of the three different things the original function do in a typesafe way.
14:13:36 <hexagoxel> codygman: `cabal repl $COMPONENT` (see cabal help repl)
14:13:41 <ski> ph88 : in `bar', instead of `"Q"' you need `Just "Q"'
14:14:06 <ReinH> *does
14:14:15 <LambdaDusk> merijn 7.8.4
14:14:18 <ski> ph88 : there is no "should set ... the rest to Nothing"
14:15:05 <LambdaDusk> merijn I just added -Wall for the build, it says nothing more
14:15:12 <merijn> Weird...
14:15:14 <ski> ph88 : if you want to, you can define `emptySymbol = Symbol Nothing Nothing Nothing Nothing', and then you could say `baz = emptySymbol {terminal = Just foo}'
14:15:35 <LambdaDusk> I've not worked with Haskell for some time and I don't think I'm familiar with this pattern synonym thingies, though
14:15:56 <ph88> ski: aht does it mean if i don't set them to Nothing myself ?
14:16:05 <ski> ph88 : comparing with what ReinH said : `symFromTerminal t = emptySymbol {terminal = t}'
14:16:17 <mauke> LambdaDusk: what happens if you add the line 'import Graphics.UI.SDL as SDL (pattern SDL_INIT_EVERYTHING)'?
14:16:36 <ph88> what*
14:16:39 <ReinH> symFromRule r = Symbol Nothing Nothing Nothing (Just (incrementRule r))
14:16:40 <ski> ph88 : depending on how you do it, you either get an error at compile-time, or at run-time (when you try to use the unset field)
14:16:41 <ReinH> and so on
14:16:58 <merijn> LambdaDusk: Which SDL package is this? I don't see SDL_WINDOWPOS in the sdl package?
14:17:17 <mauke> ooh
14:17:20 <LambdaDusk> merijn: Using sdl2 package
14:17:22 <mauke> LambdaDusk: what's the actual error message?
14:17:57 <LambdaDusk> mauke: "Not in scope: data constructor ‘SDL.SDL_INIT_EVERYTHING'"
14:18:02 <ski>   symFromRule r = emptySymbol {rule = Just (incrementRule r)}
14:18:12 <ReinH> ph88: In this data structure, how many things can be a Just value at the same time?
14:18:16 <mauke> LambdaDusk: ok, and with my change?
14:18:28 <ReinH> ski: or that
14:18:37 <ph88> ski: what do you mean with define emptySymbol ?  as value ?
14:18:53 <merijn> LambdaDusk: Do you have the right package?
14:19:01 <LambdaDusk> mauke: Module ‘Graphics.UI.SDL’ does not export ‘SDL_INIT_EVERYTHING’
14:19:02 <ski> ph88 : the `emptySymbol' i defined is a value, yes
14:19:13 <merijn> LambdaDusk: The SDL2 I see on Github doesn't have a Graphics.UI.SDL module...
14:19:22 <mauke> LambdaDusk: which version of sdl2 is this?
14:19:25 <ski> ph88 : you could also define it as `emptySymbol = Symbol {prev = Nothing,next = Nothing,terminal = Nothing,rule = Nothing}'
14:19:26 <merijn> sdl has that module, but doesn't have that constructor...
14:19:27 <ph88> ReinH: i think all of them could be set to Just something (so 4 fields in Symbol)
14:19:33 <LambdaDusk> merijn: Using cabal sandbox and cabal repl
14:19:33 <ReinH> ph88: at the same time?
14:19:49 <LambdaDusk> merijn, mauke: This says it has: http://hackage.haskell.org/package/sdl2-1.3.0/docs/Graphics-UI-SDL-Enum.html#g:37
14:20:06 <mauke> I know
14:20:08 <LambdaDusk> that IS the current version of the package
14:20:11 <ph88> ReinH: yes
14:20:11 <mauke> but which version are you using?
14:20:13 <LambdaDusk> right?
14:20:22 <LambdaDusk> how do I find out...?
14:20:36 <merijn> LambdaDusk: "ghc-pkg list | grep SDL"
14:20:59 <mauke> merijn: sdl, not SDL
14:21:01 <LambdaDusk> merijn: with cabal sandbox
14:22:11 <LambdaDusk> mauke, merijn ARGH, it installed 1.2.0
14:22:18 <LambdaDusk> even though my .cabal says "1.*"
14:22:29 <LambdaDusk> changed to 1.3.* and now it works
14:22:32 <ReinH> ski: I think the versions without record update syntax might be easier to understand...
14:22:39 <ReinH> ski: I still have problems with record update syntax ;)
14:22:53 <ski> ReinH : maybe
14:22:55 <ReinH> But perhaps I am just projecting.
14:23:20 <HeladoDeBrownie> sometimes i wonder if, in a time far away, they could have known how to make it better…
14:23:54 <ph88> what does this error mean?  http://pastebin.com/pDC0UJfV
14:24:17 <LambdaDusk> merijn, mauke Thanks for the help
14:24:18 <hexagoxel> but 1.* includes 1.2.0.. and for sandboxes, the command is `cabal sandbox hc-pkg list`
14:24:41 <geekosaur> ph88: you declared `data Rule a = ..` and then tried to make a `Maybe Rule` instead of a `Maybe (Rule something)`
14:25:01 <LambdaDusk> the question is why does it install 1.2 instead of 1.3 when both are available?
14:25:12 <LambdaDusk> also how to do String -> CString ?
14:25:43 <ski> ph88 : why did you say `data Rule a = ...' instead of `data Rule = ...' ?
14:25:58 <ph88> geekosaur: tried to make where ?
14:26:08 <geekosaur> line 4
14:26:11 <ski> ph88 : perhaps you mean to use `a' later in the definition of `Rule' ?
14:26:19 <ph88> ski: i wanted to reference itself later
14:26:47 <merijn> LambdaDusk: Foreign.C.Types or something has marshalling functions
14:27:22 <geekosaur> the ", rule :: Maybe Rule" on line 4 will not work with the "data Rule a =" on line 7, because the latter tells it that it needs `(Rule something)`, not just `Rule`, to represent a value
14:27:26 <ReinH> ph88: What are you modeling with all of these self-referential structures? Seems a bit fishy to me.
14:28:37 <ph88> ReinH: some kind of linked list where each element can have children as well ... read more about it here http://www.sequitur.info/
14:28:49 <LambdaDusk> hm there seems only be String -> IO CString, how unfortunate...
14:29:12 <geekosaur> well, yes, I'd expect that
14:29:15 <EvanR> LambdaDusk: withCString
14:29:18 <ski> ph88 : usually you'd not want to use doubly-linked lists in Haskell (though you can, if you really want to)
14:29:38 <ph88> ski: whats the alternative ?
14:29:48 <ski> ph88 : depends on what you need
14:30:14 <geekosaur> because a C string has to be made in "C-like" memory, not "Haskell-like memory (specifically it has to not be movable by a garbage collection, since C can't track such moves)
14:30:19 <ph88> ski: at this point i can not specify that
14:30:34 <ski> sometimes you can use single linked-list
14:30:40 <hesiod> Is there a function like f [a] -> [f a], but for trifunctors?
14:30:42 <ski> sometimes an array, sometimes a tree, ...
14:30:50 <EvanR> LambdaDusk: a CString is a pointer to CChar
14:30:54 <EvanR> its not a normal value
14:31:31 <hesiod> Ah, I forgot Functor f. It should be Functor f => f [a] -> [f a]
14:32:00 <ski> hesiod : seems unlikely
14:32:14 <ski> (also, what do you mean by "trifunctor" ?)
14:32:38 <LambdaDusk> EvanR: I think I'll just blame sdl2 for using only the foreign types ^^ thanks for the tip
14:32:41 <HeladoDeBrownie> the ancient force that can repel evil when the chosen programmer holds it aloft
14:32:55 <EvanR> LambdaDusk: i think theres a few sdl bindings going arent, seems a mess
14:32:55 <geekosaur> ph88, by the way, I also notice an error on line 16 that the compiler didn't reach because of the type error. you need parentheses around `Just 'Q'`
14:33:00 <EvanR> going around
14:33:10 <ski> @type Data.Traversable.sequenceA . ([] ++)
14:33:10 <hesiod> ski: To make it a bit more concrete, I am talking in terms of the linear package. Having V3 x y [z], I want [V3 x y z].
14:33:11 <lambdabot> Applicative f => [f a] -> f [a]
14:34:51 <ReinH> ski: presumably a type constructor which takes three arguments and an associated map
14:35:20 <ski> ReinH : .. didn't look that way
14:35:31 <LambdaDusk> EvanR: They just take the "low-level" thing very seriously, it seems
14:35:32 <ReinH> ski: Oh, then it's probably named wrong
14:35:56 <ReinH> hesiod: Ah, that's not a trifunctor ;)
14:36:24 <hesiod> ReinH: I thought so?
14:36:40 <ph88> geekosaur: already saw that one myself ;)
14:36:45 <ReinH> hesiod: You can't do that with V2 anyway
14:36:47 <ReinH> er V3
14:36:55 <ph88> don't understand this error http://pastebin.com/HmGhgMGj
14:36:56 <ReinH> data V3 a = V3 !a !a !a
14:36:57 <ski> hesiod : is `V3' a data constructor or a type constructor ?
14:37:02 <ReinH> ski: yes.
14:37:13 <ReinH> hesiod: The members must be of the same type
14:37:16 <ReinH> One of them can't be a list
14:37:26 <hesiod> ReinH: too bad
14:37:28 <ReinH> (unless all of them are)
14:37:45 <HeladoDeBrownie> ph88, you have two clauses for newSymbol, one of which cannot be reached because the other satisfies everything it does
14:37:58 <ph88> hmm
14:37:58 <ReinH> hesiod: a trifunctor is a type constructor which takes three arguments and an associated map :)
14:37:59 <hesiod> ReinH: actually, that would be even better: V3 [x] [y] [z] -> [V3 x y z]
14:38:19 <HeladoDeBrownie> ph88, any Symbol constructor contains both a terminal and a rule.
14:38:23 <hesiod> ReinH: And I thought I could finally use a fancy typeclass name :D
14:38:31 <cmccann> hesiod: do you want that to behave like a zip or cartesian product though
14:38:42 <HeladoDeBrownie> ph88, those fields you write there are thus not part of what the match is based off of; they just declare what should be bound on the right side
14:38:51 <ReinH> Well, V3 is applicative, so sequenceA will be a function of that type.
14:38:58 <ReinH> Well, it will be a function V3 [a] -> [V3 a]
14:39:04 <cmccann> hesiod: because sequenceA will give you "V3 [a] -> [V3 a]" as the cartesian product
14:39:29 <hesiod> cmccann: Neither, a list including all possible combinations
14:39:36 <ReinH> And if x and y are singleton lists, I suppose you'll get the behavior you want
14:39:53 <ph88> HeladoDeBrownie: actually i would like to test if terminal is not Nothing then create a new Symbol like on line 10
14:39:53 <cmccann> hesiod: that's what I mean by cartesian product. all possible combinations
14:39:56 <ReinH> hesiod: that's cartesian product.
14:40:22 <hesiod> ReinH, cmccann: thanks for the clarification
14:40:52 <HeladoDeBrownie> ph88, in that case you may use a guard
14:41:11 <HeladoDeBrownie> ph88, wait better yet, use a case expression
14:41:48 <HeladoDeBrownie> ph88, you could also write yet another clause, substituting Nothing for t
14:41:58 <HeladoDeBrownie> (and the other Just t)
14:42:08 <HeladoDeBrownie> ph88, make sense?
14:42:11 <LambdaDusk> I must admit that the line "import Data.Bits ((.|.))" does not look PG-13...
14:42:19 <HeladoDeBrownie> sorry for giving you three different options, if in doubt, just take the last one :P
14:42:22 <xnil_> lol
14:42:34 <xnil_> LambdaDusk: itty bitty datums
14:43:13 <cmccann> hesiod: fwiw, if you have something like V3 (V3 a) instead you'll get the "zip-like" version which resembles matrix transpose, rather than all combinations
14:43:15 <LambdaDusk> it looks worse in a monospace font =/
14:43:23 <ReinH> Ironically, this is the sort of humor I would expect from a 13 year old.
14:43:41 <ph88> HeladoDeBrownie: i was going with guards i don't understand your suggestion with case expressions and substitution
14:43:57 <HeladoDeBrownie> ph88, mind moving your code to lpaste? then i can annotate it
14:44:12 <ph88> not a problem
14:45:52 <ph88> HeladoDeBrownie: http://lpaste.net/384889229328515072
14:46:12 <ph88> not Nothing is not gonna fly .. i have yet to figure that out
14:47:15 * ski is still not really understanding what the purpose of this code is ..
14:47:17 <HeladoDeBrownie> ph88, this is different from your pastebin.
14:47:31 <danilo2> Hello! I'm trying to create a type class that would allow me to "map" over values in a recursive tuple. I've got a problem when trying to map a function that depends on type of the first arg. Could anybody look at this small code example and tell me if we are able somehow to use rankntypes here to compile it? http://lpaste.net/120920
14:47:43 <HeladoDeBrownie> ph88, well anyway "not Nothing" isn't something you can write. it's usually best to think in terms of cases anyway
14:48:06 <ph88> HeladoDeBrownie: eh yes true ... here is the original before i started working with guards http://lpaste.net/4470718543163293696
14:48:19 <hesiod> cmccann: No, I just have plain V3s
14:48:40 <ph88> HeladoDeBrownie: eh ok cases ...
14:48:42 <HeladoDeBrownie> ph88, i realize i'm confused about what you actually want.
14:49:12 <HeladoDeBrownie> ph88, instead of thinking in terms of "it's not this specific case", think of what to do in each case. Nothing? then what? Just t? then what?
14:50:04 <ph88> HeladoDeBrownie: i want to create a new Symbol from an existing Symbol
14:50:35 <ReinH> danilo2: Hi. f is unified with (Int -> Int) when applied to the two Ints, so it can't then also unify with (String -> String)
14:50:40 <HeladoDeBrownie> ph88, well anyway, you can write something like: foo MyType { bar = Nothing } = … ; foo MyType { bar = Just x } = …
14:50:46 <ReinH> danilo2: I'm not sure how to (or if you can) solve this.
14:50:52 <HeladoDeBrownie> i was going to annotate but now i'm not sure what annotation to write, but i can give you that
14:50:58 <ph88> HeladoDeBrownie: i'm not sure how to compare t   with something that validates to true when  t is not Nothing
14:51:00 <danilo2> ReinH: yep, thats obvious. I'm looking for a way to do it properly
14:51:26 <ski> danilo2 : looks like you'd want to pass an `f' of type `forall a. Foo a => a -> a' to `map'
14:51:56 <HeladoDeBrownie> ph88, i don't understand the problem you just expressed.
14:51:58 <ReinH> danilo2: Perhaps you need a rank 2 type
14:52:06 <danilo2> ski: not exaclty. I dont want to narrow the use cases to Foo
14:52:08 <ski> danilo2 : presumably `f~(a->b)' will assume that `f' is monomorphic
14:52:10 <ph88> HeladoDeBrownie: i don't understand your solution either :|
14:52:20 <ski> danilo2 : i mean in your specific use
14:52:21 <danilo2> ski: yep, thats the case
14:52:22 <cmccann> danilo2: you definitely need some sort of rank 2 type, but I'm not sure how to make that work given the structure of your code
14:52:38 <HeladoDeBrownie> ph88, hmm, i think i had an idea. one moment.
14:53:31 <ReinH> danilo2: If think you can introduce the Foo constraint at the use site, you won't be doing so.
14:53:36 <ReinH> s/think //
14:54:06 <arianvp___> I sometimes see     "data Blah" in type class definitions
14:54:10 <ReinH> I'm not sure how rank 2 types interact with constraints here though
14:54:15 <arianvp___> how is this feature / language extension called
14:54:16 <ski> arianvp___ : associated types
14:54:17 <arianvp___> ?
14:54:21 <danilo2> ReinH: I do not want to narrow this to only Foo. I would like to "map" anythink I want - any type class function
14:54:22 <arianvp___> thanks
14:54:43 <HeladoDeBrownie> ph88, see my annotation: http://lpaste.net/384889229328515072
14:54:54 <ReinH> danilo2: It *must* be narrowed to Foo *somewhere*, I believe. The question is if you can do the narrowing at the use site so you can narrow it to something else elsewhere.
14:55:14 <Sornaensis> !ud numerologism
14:55:21 <Sornaensis> bots suck
14:55:29 <ski> perhaps there should be a variant of `~' that makes one side a specialization of the other ..
14:55:32 <ReinH> Somehow the type system needs to be told that f is ad hoc polymorphic over (Int -> Int) and (String -> String) in map foo t
14:55:53 <ReinH> or rather, that you must provide an f that is such
14:56:21 <HeladoDeBrownie> ph88, by the way, i only did minimal edits, if i had written that from scratch i would not have written it quite that way
14:56:27 <cmccann> danilo2: I don't think there's any way in Haskell to properly express what you're really trying to do
14:56:31 <ReinH> danilo2: but at this point I'm getting over my head a bit, sorry
14:56:34 <tnks> anyone have a nice technique to chase down reverse dependencies in Hackage?
14:56:40 <cmccann> danilo2: so the question is what sort of hoops you're willing to jump through to approximate it
14:56:55 <tnks> sometimes it's nice to know how many people have coupled to a library.
14:56:56 <HeladoDeBrownie> ph88, as a pattern, _ means "don't care". it matches anything, but binds no variables.
14:57:09 <HeladoDeBrownie> ph88, so that field could just as well have been omitted.
14:57:09 <merijn> tnks: http://packdeps.haskellers.com/reverse
14:57:17 <ph88> HeladoDeBrownie: how does your annotation prevent t being Nothing ?
14:57:38 <HeladoDeBrownie> ph88, t *must* be Nothing in the second clause, but *cannot* be in the first. is that what you wanted?
14:57:47 * ski dislikes that you can avoid mentioning all fields in patterns, with the basic syntax
14:57:52 <tnks> merijn: thanks.
14:57:54 <HeladoDeBrownie> ph88, the reason it cannot be in the first is because that clause specifically handles the Just case.
14:57:58 <danilo2> cmccann, ReinH: hmmm, thank you for the help. I will try some other methods now and maybe Iw will be back with something in a momen.t cmccann: I'm just trying to do it - to use it later in a nice way :)
14:58:09 <ph88> HeladoDeBrownie: yes ... that's what i want . Why can it not be Nothing in the first clause ?
14:58:18 <ReinH> danilo2: If you can, try to bug edwardk about it. :)
14:58:19 <ph88> oh
14:58:21 <HeladoDeBrownie> ph88, this is sort of what i was talking about: you have to think of how to handle each case, instead of how to handle it if the case is not some specific thing
14:58:24 <cmccann> danilo2: also, you're basically trying to write map for a heterogenous list here
14:58:35 <danilo2> cmccann, ReinH: I'm starting to belive it is possible to do using DysfunctionalDependencies, brb
14:58:35 <cmccann> danilo2: there are existing libraries for that sort of thing
14:58:35 <HeladoDeBrownie> ph88, because the first clause is only used if there's a Just there
14:58:39 <cmccann> maybe look at what they do?
14:58:42 <HeladoDeBrownie> ph88, otherwise it will continue to the second clause
14:58:54 <ph88> HeladoDeBrownie: well i didnt know i could put Just there
14:59:00 <HeladoDeBrownie> ph88, the more you know!
14:59:07 <arianvp___> does there exist a function that does something like this ? https://gist.github.com/arianvp/b4fc4e5bc3f2b9f7351d
14:59:10 <cmccann> danilo2: I doubt it. you're still going to get unification even with old-school dodgy fundeps, I think.
14:59:24 <ski> ph88 : patterns are nestable
14:59:28 <mpickering> Is there a precise relationship between functional dependencies and associated types?
14:59:28 <ReinH> cmccann: To that point, I wonder if HList does this
14:59:32 <arianvp___> basically. given a Lens a a' and a Lens b b'   transform a function (a -> b) to (a' -> b')
14:59:35 <ReinH> I can't see how, but maybe
14:59:36 <ski> .. just like expressions, in fact
15:00:03 <edwardk> arianvp___: its not quite what you expect.
15:00:11 <edwardk> arianvp___: there is 'inside'
15:00:13 <edwardk> :t inside
15:00:14 <lambdabot> (Data.Profunctor.Rep.Corepresentable p, Functor f) => ALens s t a b -> (p e a -> f (p e b)) -> p e s -> f (p e t)
15:00:18 <edwardk> and there is outside
15:00:19 <edwardk> :t ouside
15:00:20 <lambdabot>     Not in scope: ‘ouside’
15:00:20 <lambdabot>     Perhaps you meant one of these:
15:00:20 <lambdabot>       ‘outside’ (imported from Control.Lens),
15:00:26 <edwardk> :t Control.Lens.outside
15:00:27 <lambdabot> (Data.Profunctor.Rep.Representable p, Functor f) => APrism s t a b -> (p b r -> f (p a r)) -> p t r -> f (p s r)
15:00:29 <ReinH> Oh, maybe jonsterling would know if this is possible. He's my go-to for "how do I do weird type-level shit".
15:00:30 <ph88> runs without errors :>
15:00:34 <ph88> The End
15:00:44 <edwardk> outside takes a prism and lets you specialize how a function handles some particular case.
15:00:45 <cmccann> mpickering: I don't think there's a simple and precise direct relationship
15:00:52 <edwardk> inside maps over the result space
15:00:54 <HeladoDeBrownie> ph88, even so, did you see my warning comment?
15:01:12 <edwardk> what you asked for doesn't actually work, the lens has the wrong polarity to deal with the argument in negative position
15:01:14 <cmccann> ReinH: yes, vinyl has something similar but won't do what danilo2 wants without lots of extra cruft
15:01:15 <HeladoDeBrownie> ph88, try passing a Symbol where both rule = Nothing and terminal = Nothing.
15:01:36 <HeladoDeBrownie> ph88, what should it do then?
15:01:52 <ph88> HeladoDeBrownie: that's ok... this code is not going to control a nuclear facility xD
15:02:12 <ph88> i get the point though
15:02:20 <HeladoDeBrownie> ph88, so, do you never construct such a Symbol?
15:02:21 <arianvp___> why wouldn't it work.  if I have a Lens a a'   . By 'updating' a' I get an a right?
15:02:59 <ph88> HeladoDeBrownie: doesn't look like it from the original javascript implementation
15:03:11 <HeladoDeBrownie> ph88, the problem isn't necessarily how catastrophic the error will be if you meet that case. it can also be about how much effort you have to expend to figure out why there is an error.
15:03:31 <cmccann> ReinH: I made a couple attempts to reduce the boilerplate around doing stuff polymorphically over vinyl records and it really didn't work
15:03:41 <HeladoDeBrownie> ph88, well, your haskell code does not correspond directly to your javascript code, so they will potentially contain different errors.
15:03:49 <ph88> HeladoDeBrownie: ok in that case i would like to add a clause that just throws an error so i know it originate from there
15:03:50 <init> are there any heterogenous "vectors" (lists..) (in the sense of having the length in their type)?
15:03:53 <mpickering> cmccann: Right.. that is very disappointing
15:04:18 <HeladoDeBrownie> ph88, good, that sounds okay to do. in that case you can write something like: newSymbol _ = error "newSymbol: unhandled case"
15:04:20 <chrisdone> hey cmccann :)
15:04:21 <cmccann> at least compared to more tractable stuff like union/intersection on vinyl records in order to put a disjoint label constraint on (<+>), which is fairly simple
15:04:33 <cmccann> chrisdone: yo
15:04:43 <HeladoDeBrownie> ph88, that's the "default" thing to do if you really really don't care
15:04:54 <HeladoDeBrownie> (it's not as default as it should be, but…)
15:04:59 <ph88> not right now ... maybe care later about this one
15:05:21 <dmj`> jle`: ping
15:05:46 <ski> (if you don't care, put an `error' there, so that later, when you care, you can find out where the problem came from)
15:05:49 <cmccann> though I tried to write a more general version of vinyl's subset lens and that really, really didn't work
15:06:03 <ph88> ski: yes we just covered that ^^
15:06:37 <HeladoDeBrownie> ski was noting the contradiction between deciding to do that "not right now" and "maybe care later" :P
15:06:41 * ski was responding to the "not right now ... maybe care later about this one"
15:07:55 <ReinH> cmccann: heh :)
15:08:10 <ReinH> cmccann: Jon is a wizard.
15:09:14 <cmccann> eh, most of the stuff in vinyl is pretty simple. it's just that until recent GHC versions it was a nightmare to implement any of this, cf. oleg's deep magic
15:11:30 <cmccann> the most remarkable part of vinyl is that it does all that stuff internally while still being usable by sane people :D
15:11:43 <danilo2> ReinH, cmccann: Ok, I did it, but using some kind of work-around and DysfunctionalDependencies : http://lpaste.net/120920
15:12:33 <ReinH> danilo2: that's nicer than I expected :)
15:12:35 <arianvp___>  edwardk: could you give an example of `outside` ?
15:12:56 <cmccann> danilo2: doesn't that require a new instance of GetPolyFunc for every possible function you want to map? :T
15:13:03 <danilo2> ReinH: Yep, this is a kind of trick, I'm using Dysfundeps all the time for :D
15:13:20 <danilo2> cmccann: it does unfortunetally :(
15:13:42 <ReinH> heh
15:13:43 <danilo2> cmccann: otherwise it gets unified even with a wrapper and GADT's like (~) syntax
15:13:59 <cmccann> danilo2: see, that really crosses the line from "usable in practice" to "cute trick but useless" to my mind :[
15:14:03 <danilo2> cmccann: anyway, that could be minimised with little help of TH - of course its far from perfect / nice
15:14:21 <cmccann> danilo2: right, and if you're resorting to TH there's probably nicer ways to do the whole thing
15:14:58 <danilo2> cmccann: hmm, look at the differnet side of the coin. We are able to create a mechanism to do poly-map on such recursive tuple - if we want to create a new mapping function, we can use this mechanism to minimalize our boilerplate
15:15:18 <danilo2> cmccann: I dont think there is a nicer way in th to do it
15:17:44 <cmccann> danilo2: idk, just doesn't seem like a very satisfying solution to me :T
15:18:19 <danilo2> cmccann: to me too. I only tell it is a workingg solution. I would just love to see nicer one
15:19:36 <cmccann> danilo2: well, lemme try something
15:20:10 <danilo2> cmccann: Of course! :)
15:20:11 <wayne> does anyone know of some problem sets for practicing Kinds?
15:21:17 <chrisdone> wayne: try understanding this blog post http://chrisdone.com/posts/haskelldb-and-typeoperator-madness
15:21:53 <chrisdone> i can't believe i wrote
15:21:53 <chrisdone> > Finally it takes another field, k. GHCi tells us:
15:21:53 <chrisdone> > λ> :k (:~~>:)
15:21:53 <chrisdone> > (:~~>:) :: * -> * -> (* -> *) -> * -> *
15:21:56 <chrisdone> > Which makes it very clear.
15:21:57 <lambdabot>  mueval-core: Time limit exceeded
15:21:57 <lambdabot>  mueval-core: Time limit exceeded
15:21:57 <lambdabot>  mueval-core: Time limit exceeded
15:21:58 <lambdabot>  <hint>:1:27:
15:21:58 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:22:04 <chrisdone> ew lambdabot, stawp
15:22:24 <ReinH> chrisdone: such clear
15:22:36 <ReinH> very understanding
15:22:37 <wayne> haha
15:23:16 <Luke> anyone know how to submit a PR for the haskell.org site?
15:23:18 <HeladoDeBrownie> what is (:~~>:), type composition?
15:23:34 <HeladoDeBrownie> (albeit non-polymorphic)
15:23:38 <chrisdone> i was building a type-level reader monad
15:23:41 <chrisdone> that was 'return'
15:23:42 <HeladoDeBrownie> ah
15:23:45 <chrisdone> λ> :k (:>>:)
15:23:45 <chrisdone> (:>>:) :: ((* -> *) -> * -> *) -> ((* -> *) -> *) -> (* -> *) -> *
15:23:50 <chrisdone> and that was >> =p
15:23:54 <ReinH> o_O
15:23:57 <ReinH> chrisdone: stahp :p
15:24:51 <chrisdone> :p
15:26:23 <bmf> anyone can help with ubuntu ufw
15:26:42 <HeladoDeBrownie> bmf, you might try ubuntu's channel, #ubuntu on some (possibly this) network
15:26:45 <jophish> How can I constrain an argument to be of a particular kind?
15:27:02 <HeladoDeBrownie> jophish, what's the context?
15:27:39 <jophish> HeladoDeBrownie: for example, I have a function: foo :: a -> S a, and a must be of kind Nat
15:27:57 <jophish> I'm looking for something like foo:: Nat a => a -> S a
15:27:58 <HeladoDeBrownie> i think you can write (a :: Nat) => …
15:28:07 <jophish> ah great!
15:28:09 <jophish> thanks
15:28:10 <HeladoDeBrownie> not sure though
15:28:15 <HeladoDeBrownie> try and if it doesn't work say so :P
15:28:33 <HeladoDeBrownie> it might in fact be foo :: (a :: Nat) -> S a
15:28:53 <HeladoDeBrownie> if it's neither of those then i am surprised and stumped
15:29:11 <jophish> I'll give those a try, thanks HeladoDeBrownie
15:29:21 <ski> hm, maybe `foo :: forall (a :: Nat). a -> S a' ?
15:29:34 <HeladoDeBrownie> ah yeah
15:29:41 <HeladoDeBrownie> another good idea for what it might be
15:30:31 <HeladoDeBrownie> it's kind of amusing how we're so uncertain though. i guess kinds aren't a big thing we think about in haskell :P
15:31:32 <ski> @type return :: forall (m :: * -> *) (a :: *). Monad m => a -> m a
15:31:34 <lambdabot> Monad m => a -> m a
15:31:37 <ski> seems right
15:32:15 <jophish> upon further inspection, I don't think this was actually what I wanted
15:32:20 <ski> hehe
15:32:41 <jophish> (although that was still very helpful!)
15:33:08 <jophish> broader context: I'm trying to use Nats to index into vinyl records
15:33:40 <foozer> hi
15:33:45 <foozer> I'm sure many of you use emacs
15:33:55 <foozer> the thing is, I'm stuck setting up tags (using etags)
15:34:10 <foozer> I'm following this tutorial:
15:34:10 <foozer> https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md#installing-and-setting-up-emacs
15:34:24 <foozer> but when I evaluate the init file in emacs, I get an error message
15:34:54 <bmf> 23rf
15:34:54 <bmf> ew
15:34:54 <bmf> rw
15:34:55 <bmf> e
15:34:55 <bmf> e
15:34:55 <bmf> e
15:34:59 <bmf> e
15:35:01 <bmf> e
15:35:03 <bmf> e
15:35:05 <bmf> tqwe
15:35:07 <bmf> q
15:35:09 <bmf> w
15:35:11 <bmf> er
15:35:13 <bmf> we
15:35:15 <bmf> r
15:35:17 <bmf> werwefr
15:35:18 <foozer> bmf, your cat is walking over your keyboard
15:35:19 <bmf> wer
15:35:21 <bmf> wer
15:35:23 <jophish> I have a type family V (a :: Nat) :: *, which provides the mapping between Nats and the record element type, I have a term level function which I'd like to look something like this: foo :: (n :: Nat) -> V n -> SomethingElse n
15:35:23 <bmf> wer
15:35:32 <bmf> sorry guys
15:35:35 <bmf> ;p;
15:35:42 <bmf> lol*
15:36:04 <bmf> hey all i need some help with ufw
15:36:10 <foozer> ufw?
15:36:17 <bmf> yea on ubuntu
15:36:30 <jophish> Ideally to be called as close to: foo 0 something
15:36:35 <bmf> prebabrly not the channel to ask but belive it or not the ubuntu channel is not helpful
15:37:02 <foozer> you're probably better off on stack overflow
15:37:04 <jophish> Although I suppose that 0 will have to be wrapped in a proxy
15:39:32 <ReinH> bmf: I don't think we'll be helpful either, but at least we'll try to be nice about it.
15:41:51 * EvanR politely suggests bmf uses another distro
15:42:20 * EvanR POLITE FLAME
15:42:26 <bmf> lol
15:42:32 <bmf> thanks anyway guys
15:42:52 <danilo2> cmccann: Do you have any results? :)
15:43:55 <cmccann> danilo2: alas no, and I was just about to give up
15:44:11 <danilo2> cmccann: heh, so the ugly one is for now the only one :D
15:44:28 <cmccann> danilo2: what I was trying to do was make your poly map take a rank-2 type carrying a constraint that it could use to know how to apply it at each step
15:44:37 <cmccann> danilo2: which definitely avoids the unification issue
15:45:08 <ReinH> cmccann: Does it help to reify the constraint with https://hackage.haskell.org/package/constraints-0.3.2/docs/Data-Constraint.html ?
15:45:14 <cmccann> and I still think it could be made to work, but the trick is in how to express the constraint properly and pass it around
15:45:19 <danilo2> cmccann: hmm, it would make sense. But I understand it is not so straightforward / r even possible ?
15:46:02 <cmccann> ReinH: yeah, I didn't get that far before deciding to give up
15:46:12 <ReinH> cmccann: :)
15:46:48 <danilo2> cmccann: Coudl you show me what you;ve got so far please?
15:47:14 <mpickering> danilo2: I'm looking forward to when you actually release your project because you always ask interesting questions
15:47:27 <mpickering> maybe then you'll have time to write down some things you've learnt along the way..
15:47:44 <cmccann> danilo2: I would except I already mangled it trying something else that didn't work at all, sorry
15:48:06 <cmccann> danilo2: you'd probably learn more from looking at the constraints and vinyl packages and seeing how they do stuff
15:48:06 <danilo2> mpickering: In about a month I think we are going to open source a big part of the project. (our language compiler). I'll write here about it then.
15:48:24 <danilo2> cmccann: ok, thank you! :)
15:48:46 <danilo2> mpickering: writing something about it would also be an interesting idea!
15:48:50 <cmccann> danilo2: in particular, see http://hackage.haskell.org/package/vinyl-0.5.1/docs/Data-Vinyl-Core.html#v:reifyConstraint
15:48:58 <dulla> ?
15:49:04 <cmccann> danilo2: which is vinyl solving a similar problem to yours in a way similar to what I tried to do
15:49:35 <danilo2> cmccann: hmm interesting. Thank you!
15:49:50 <orzo> when making a server, does it make sense to use a bunch of haskell threads per os thread and allocate new os threads when there is backlog?
15:49:54 <dulla> ?
15:50:08 <ReinH> @hackage constraints -- danilo2
15:50:08 <lambdabot> http://hackage.haskell.org/package/constraints -- danilo2
15:50:16 <dulla> can't really substitute os threads with haskell threads
15:50:26 <cmccann> danilo2: basically vinyl's reifyConstraint and RecAll were the square peg and the API of your lpaste was the round hole :P
15:50:33 <jonsterling> Doing this stuff in haskell is a repeating story of wanting things to hold judgementally what only hold by induction... reifyConstraint is a bit of grossness to help with this... /cmccann danilo2
15:50:48 <ReinH> Ah, he appears.
15:50:50 <cmccann> jonsterling: yes, I've learned that the hard way by trying to improve on it :P
15:50:58 <dulla> ?
15:51:00 <jonsterling> lol
15:51:03 <ReinH> jonsterling: o/
15:51:03 <HeladoDeBrownie> orzo, that sounds kinda like premature optimization to me, but it depends on what sort of server and various other factors about the use case. more details?
15:51:22 <danilo2> ReinH, cmccann, jonsterling: This sounds really good - as a better solution to that one I've posted before. Does anybody have any idea how to glue it together?
15:51:23 <cmccann> jonsterling: btw, have you considered adding some sort of union/intersection/difference stuff to vinyl?
15:51:25 <cmccann> since you're here and all
15:51:26 <HeladoDeBrownie> orzo, though one thing you should know is that forkOS *does not create* os threads
15:51:33 <HeladoDeBrownie> orzo, in case that's what you were thinking
15:51:34 <ReinH> orzo: You should let the RTS schedule your threads for you and use profiling to determine if you should keep a pool or worry about afinity
15:51:37 <orzo> it's an IKEv2 server for establishing vpn sessions.  ike is a udp protocol
15:51:47 <jonsterling> cmccann: I'd love to have that sort of thing. If someone made a nice patch for it, I'd certainly accept it
15:52:01 <ReinH> We can't tell you what works best since we can't profile your program for you
15:52:10 <cmccann> jonsterling: well, "nice" is the hard part there
15:52:33 <orzo> i just want a sensible ready solution that should perform well
15:52:37 <cmccann> jonsterling: I did hack something together while trying to make a more generalized version of rsubset
15:52:44 <jonsterling> Even a version of <+> that prevented duplicate fields would be nice. the current version is kind of cramping my intention for Vinyl's denotation to be functions (x:sh) -> po x / cmccann
15:52:45 <ReinH> danilo2: jonsterling might :)
15:53:00 <orzo> HeladoDeBrownie: could you explain about forkOS?
15:53:07 <cmccann> jonsterling: it worked, of course, except for the part where it wrecked type inference to the point of being unusable.
15:53:13 <jonsterling> lol, yep
15:53:20 <HeladoDeBrownie> orzo, if you weren't already thinking that forkOS created os threads, then good
15:53:24 <HeladoDeBrownie> orzo, were you?
15:53:33 <HeladoDeBrownie> (it's a semi-common misconception)
15:53:35 <danilo2> jonsterling: Would you be so nice and help us? :)
15:53:43 <Cale> orzo: All that forkOS does is ensure that FFI calls made by the Haskell thread it creates all happen on the same OS thread.
15:53:54 <ReinH> orzo: forkOS creates a Haskell thread that is bound to an OS thread. It does not create an OS thread.
15:54:07 <ReinH> OS threads are managed by the RTS
15:54:09 <Cale> orzo: It doesn't even ensure that all the Haskell execution/evaluation happen on the same OS thread.
15:54:11 <jonsterling> danilo2: I wish I could do! I'd be happy to do what I can asynchronously (my email is jon[at]jonmsterling[dot]com, but I don't have the time at the present moment to help.
15:54:13 * HeladoDeBrownie is actually not sure how to create an os thread in haskell, but fortunately has never needed to
15:54:33 <geekosaur> you can't hard-bind a Haskell thread to an OS thread
15:54:49 <Cale> orzo: It's basically only of use when you're doing FFI to a C library that's not threadsafe.
15:55:01 <ReinH> orzo: I don't see any need to do so for the problem you described anyway
15:55:08 <geekosaur> what yu can do is ensure that all FFI calls made on a particular Haskell thread are made on the same OS thread, by starting that thread using forkOS
15:55:19 <orzo> so if i just use -threaded with forkIO, then it will use multiple cpu threads and try its best to schedule things sensibly?
15:55:29 <Cale> orzo: Yeah
15:55:29 <geekosaur> Cale: or the C library uses thread-local state
15:55:30 <danilo2> jonsterling: Ok, I will write to you! thank you! :)
15:55:36 <Cale> geekosaur: yeah
15:55:41 <ReinH> orzo: And -N
15:55:46 <jonsterling> danilo2: Cheers!
15:55:51 <ReinH> or -N n where n > 1
15:55:59 <danilo2> jonsterling: cheers! thank you once again!
15:56:01 <HeladoDeBrownie> orzo, basically, the best is to leave all the scheduling to the scheduler, unless you have a really good reason why not (and i can't think of such a reason)
15:56:25 <cmccann> jonsterling: look at http://lpaste.net/120932
15:56:59 <Cale> I do think it's a little bit sad that the whole pluggable thread schedulers project didn't end up working out well enough to keep
15:56:59 <cmccann> jonsterling: it's a mess of experimenting but the function type signatures should give you the idea
15:57:07 <ReinH> orzo: All of this sounds like premature optimization. Let the RTS manage your threads for you. If you can prove by profiling that this is inefficient in some way, you should have enough information to know how to fix it at that time.
15:57:34 <HeladoDeBrownie> ReinH, i'm afraid i may have accidentally started this thread (of conversation) by assuming something as of yet unanswered about their knowledge
15:57:44 <ReinH> HeladoDeBrownie: :)
15:57:49 <HeladoDeBrownie> i might end up having been correct but it still was a mistake
15:57:52 <cmccann> jonsterling: in particular "(<+|>) :: (Disjoint as bs) => Rec f as -> Rec f bs -> Rec f (as ++ bs)"
15:58:08 <jonsterling> Interesting... Does it work well? Or are there inference problems?
15:58:21 <ReinH> The solution may be orthogonal to threads, like some sort of resource pooling.
15:58:33 <cmccann> jonsterling: some parts work better than others
15:58:38 <jonsterling> cmccann: Heh, OK
15:58:39 <ReinH> But without an actual problem, there's no point in coming up with solutions.
15:59:07 <jonsterling> cmccann: Maybe I'll have to try it out and see... Sadly, I don't have much mindspace for Haskell type hacking these days; I need to work on my meaning explanations talk desparately...
15:59:13 <cmccann> jonsterling: I kinda gave up after realizing that I was shaving the wrong yak at the time
15:59:13 <orzo> leaving everthing to the scheduler, should i code it up like threads have zero cost and just forkIO every independent task?
15:59:40 <ReinH> orzo: Yes, use a naive strategy at first and then you'll see whether it works or not.
15:59:43 <jophish> jonsterling: I was just thinking of you! I'm trying to use Vinyl for Nat indexed records but feel that I'm doing it the hard way. Would you be able to take a quick peek and tell suggest what I could be doing differently?
16:00:12 <jonsterling> jophish: Sure, send me a link! I can't guarantee I shall be very helpful, but I can at least take a look
16:00:16 <jophish> thanks!
16:00:18 <jophish> http://lpaste.net/120933 particularly how I'm passing the Nat on line 24
16:00:19 <cmccann> jonsterling: dunno if you remember, but I also hacked together a case-like thing using vinyl ages ago to fake sum types
16:00:32 <Adeon> doesn't the GHC implementation create a new OS thread anyway with forkOS
16:00:36 <jonsterling> cmccann: I do remember that! Was pretty cool...
16:00:38 <ReinH> Adeon: No.
16:00:46 <ReinH> Adeon: this was explained earlier.
16:01:10 <ReinH> forkOS binds FFI calls to a particular OS thread to support calls into non-threadsafe external libraries
16:01:29 <cmccann> jonsterling: it was mostly smoke and mirrors tbh, haha. it basically amounted to a record of case branches and a some phantom types on the "sum"
16:01:30 <jophish> the instances of Show can probably be made better, but I think I can handle that
16:02:04 <jonsterling> jophish: Nice, it looks like you're going about it the right way; I am not sure I understand the use-case, but in the broad strokes, this is how I'd do it too.
16:02:09 <Adeon> I faintly recall a discussion related to OpenGL and multiple contexts that it has to create an OS thread, although the documentation does not suggest that
16:02:13 <Adeon> I need to check the source
16:02:27 <jonsterling> jophish: Is there anything in particular you are unsure about?
16:02:55 <jophish> jonsterling: the verbose method of passing in '1' as a marker to (=::)
16:03:16 <jonsterling> jophish: Ah, OK. That is a bit of not-much-fun there...
16:03:30 <jophish> yeah, I thought so :)
16:03:44 <dmj`> is anyone using ghcjs on osx here?
16:04:01 <jonsterling> jophish: Since there aren't nice singletons for type-nats built-in, you could write your own singleton type and use it instead of the proxy
16:04:21 <Adeon> forkOS calls pthread_create() in rts
16:04:38 <Cale> GHC.Conc includes a bunch of additional stuff like forkOn which can be used to run a Haskell thread on a particular capability (which are usually in correspondence with OS threads), and setNumCapabilities which can be used to change the number of capabilities in use at runtime.
16:04:44 <jonsterling> jophish: Also, you should not hard-code Proxy into the type of =::, since you can define the same function with a variable, like `proxy (f :: nat)`
16:04:57 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.2/GHC-Conc.html
16:04:59 <HeladoDeBrownie> Adeon, can i see? where did you find that?
16:05:01 <danilo2> cmccann, ReinH: I will write the resutls to you we get after mailing with jonsterling :)
16:05:16 <Adeon> posix/OSThreads.c, line 221, GHC 7.8.4
16:05:27 <Cale> But I don't think I've ever seen a case where those were really needed.
16:05:37 <Adeon> called by the haskell forkOS function with some setup on haskell side
16:05:40 <jonsterling> jophish: If you want to use nats at the type level, you can do a GADT for their singleton sets; data Natty :: Nat -> * where Ze :: Natty 0; Su :: Natty n -> Natty (n + 1)
16:05:48 <HeladoDeBrownie> Adeon, is that available online?
16:05:59 <HeladoDeBrownie> wait of course it is
16:06:04 <HeladoDeBrownie> i meant is it browseable online
16:06:10 <hiptobecubic> is there a  Monoid a => Monoid (b -> a) instance? I'm not following what happens here...
16:06:12 <jonsterling> jophish: Then you can use these terms instead of the proxies, as in "(Su Ze =:: 4) :& RNil"
16:06:17 <HeladoDeBrownie> ah, found ghc's repo
16:06:26 <hiptobecubic> > foldMap (++) ["abc", "def"] "foo"
16:06:26 <Cale> hiptobecubic: yes
16:06:27 <lambdabot>  "abcfoodeffoo"
16:06:34 <ski> hiptobecubic : yes
16:06:54 <jophish> jonsterling: I think I've got an even better way actually: how about v = (Component 1 :: Component 1) :& RNil
16:06:59 <Cale> hiptobecubic: mempty = \x -> mempty and mappend f g = \x -> mappend (f x) (g x)
16:07:06 <jophish> I am certainly taking your advice to heart though!
16:07:08 <ReinH> Adeon: interesting.
16:07:18 <jonsterling> jophish: Ah, you can definitely do that too!
16:07:29 <Cale> hiptobecubic: A cute way to use this is with the Monoid instance for Ordering, to combine comparison functions:
16:07:31 <ReinH> Adeon: That seems to contradict the documentation, or vice versa.
16:07:34 <ski> hiptobecubic : seen <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> yet ?
16:07:50 <jonsterling> jophish: In fact, if you have got the whole term annotated like you do in your example, you probably don't even need to do the type annotation inside the term.
16:07:54 <Cale> heh, I was about to give that example
16:08:01 <hiptobecubic> ok so... we get ("abc" ++) and ("def" ++) and use the mappend from string with the results
16:08:02 <Cale> I guess that link saves me the trouble :)
16:08:06 <ski> Cale : .. you already did :)
16:08:14 <merijn> hiptobecubic: Right
16:08:16 <hiptobecubic> Oh i have. I just didn't realize that was this i guess
16:08:16 <Arahael> So I was wondering... How can I know that a given haskell function will behave as expected? (To me, as a novice, that means without a runtime exception)
16:08:42 <Adeon> ReinH: it doesn't contradict it, I think it's just not guaranteed that it will really be in a different OS thread
16:08:50 <Adeon> ReinH: it's just implemented that way
16:08:51 <merijn> Arahael: You mean that it won't crash/throw an exception?
16:08:53 <timthelion> > "/foo" System.FilePath.(</>) "/bar"
16:08:55 <lambdabot>  Not in scope: data constructor ‘System.FilePath’Not in scope: ‘</>’
16:08:55 <lambdabot>  Perhaps you meant one of these:
16:08:55 <lambdabot>    ‘<*>’ (imported from Control.Applicative),
16:09:05 <Arahael> merijn: Yes, and that nothing takes the head of an empty list, etcetera.
16:09:09 <hiptobecubic> Arahael, you kind of can't because people can put "undefined" anywhere it will compile, horrifyingly
16:09:09 <jophish> jonsterling: You lost me there. How could the type be inferred without the annotation, wouldn't the index be ambiguous
16:09:11 <Cale> Arahael: For that, you have to look at the source code.
16:09:12 <ReinH> Adeon: "Using forkOS instead of forkIO makes no difference at all to the scheduling behaviour of the Haskell runtime system." I would call creating an OS thread to be a change to the scheduling behavior of the RTS...
16:09:15 <merijn> Arahael: You can't in Haskell
16:09:23 <Adeon> but somewhere I remember the idea that forkOS cannot be sensibly implemented if you don't actually create a thread
16:09:24 <merijn> Arahael: That'd require solving the halting problem
16:09:27 <Adeon> but I can't remember why
16:09:29 <timthelion> "/foo" </> "/bar" == "/bar" -- kinda surprising eh
16:09:30 <Cale> Arahael: It's not in general machine checkable.
16:09:35 <ski> > "/foo" System.FilePath.</> "/bar" -- not in scope
16:09:36 <jophish> (If you're suggesting: v = (Component 1) :& RNil
16:09:36 <lambdabot>  Not in scope: ‘System.FilePath.</>’
16:09:44 <jophish> oh, never mind
16:10:09 <jophish> well, it works in that example, but perhaps not with a record with more than one member I think
16:10:09 <jonsterling> jophish: You've already got v :: Rec Component '[1] :)
16:10:10 <ReinH> s/call/consider
16:10:11 <Arahael> merijn: Why would it?  It means that all functions must have a catchall pattern, and that all exceptions are checked.
16:10:13 <merijn> Arahael: There are languages (the proper term is "total language") which guarantees termination and that can therefore check this, but the cost of that is that your language can't be Turing complete (to avoid the halting problem)
16:10:16 * HeladoDeBrownie gives up on trying to find the appropriate file browseable with a web browser
16:10:27 <jonsterling> jophish: It should work with a record of any number of members, but only if you've got the whole thing ascribed at a type
16:10:27 <merijn> Arahael: Haskell doesn't have checked exceptions
16:10:29 <Arahael> merijn: I don't need a guarantee of termination, that's a separate problem.
16:10:55 <hiptobecubic> Oh.. Cale. I tried your suggestion using Array to solve that problem yesterday. It works of course but it seems kind of ... unappealing? http://lpaste.net/120906 Is that how you'd have done it?
16:10:56 <HeladoDeBrownie> Arahael, in short, it's discouraged to use undefined and error and things, but not disallowed.
16:11:00 <merijn> Arahael: To haskell's type system "crash" and "non-termination" are indistinguishable
16:11:15 <johnw> chrisdone: ping
16:11:23 <Cale> hiptobecubic: Yeah, that looks pretty much like what I was suggesting
16:11:40 <Arahael> merijn: That's unfortunate.  A real-world example is when I attempt to download a file, using Wreq, and taking every opportunity to ensure that I'm using the forms that give me Maybe's and Either's, I _still_ get exceptions.
16:11:51 <jonsterling> merijn: turing completeness and totality is a lot more nuance than that... Check out this recent McBride joint: https://personal.cis.strath.ac.uk/conor.mcbride/pub/Totality.pdf
16:11:52 <Arahael> merijn: And I'd rather not have to discover that at runtime.
16:11:52 <merijn> Arahael: I have some ideas on how you could add checked exceptions to haskell, but I don't have time to play with it right now and don't have a bachelor student to hack on it for me right now >.>
16:12:01 <merijn> Arahael: I would consider that a bug in wreq
16:12:09 <nshepperd> are they? Safe Haskell doesn't let you use undefined/error I thought
16:12:11 <HeladoDeBrownie> Arahael, an exception will, by default, halt the thread it happens in. this can be caught.
16:12:16 <ReinH> Arahael: that's a design decision or a bug in wreq, it isn't an example of what we're talking about.
16:12:24 <HeladoDeBrownie> Arahael, e.g., using forkFinally
16:12:26 <Arahael> merijn: Regardless, it's a perfectly good example of what kind of thing I'd like the compiler to give me a hint about.
16:12:34 <merijn> nshepperd: "let x = x in x" <- safe haskell is bollocksed
16:12:43 <Arahael> HeladoDeBrownie: How do you catch an exception you know nothing about?
16:12:50 <benzrf> nshepperd: halting problem ;)
16:12:58 <merijn> Arahael: Oh, I fully agree about the exceptions being kinda sucky, but that's not something we have a good answer for
16:13:13 <nshepperd> merijn: yeah but Arahael isn't worried about nontermination, only crashing
16:13:14 <merijn> Arahael: I'd prefer to see all haskell exceptions become checked
16:13:14 <glguy> Nsheppard: undefined and error are perfectly safe, and allowed in safe haskell
16:13:21 <nshepperd> for whatever reason
16:13:28 <Arahael> merijn: I'm surprised hlint doesn't cover this.
16:13:45 <merijn> Arahael: How could it? That'd require recursively analysing all source
16:13:56 <Arahael> merijn: Is that a problem?
16:13:58 <merijn> hlint is just a stupid checker
16:13:59 <ReinH> Arahael: It's impossible in general, but it's certainly possible in specific cases to prevent certain types of runtime exceptions.
16:14:00 <HeladoDeBrownie> Arahael, see here: http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Concurrent.html#v:forkFinally
16:14:07 <jophish> jonsterling: You're quite right, thanks a bunch for the help!
16:14:09 <merijn> Arahael: Yes, hlint is nowhere near smart enough for that
16:14:13 <jonsterling> np1
16:14:16 <jonsterling> *np!
16:14:18 <hiptobecubic> Cale, fair enough. thanks
16:14:20 <dolio> You might not even have the source.
16:14:21 <Arahael> HeladoDeBrownie: I'm actually not using any concurrency (that I am aware of)
16:14:23 <HeladoDeBrownie> Arahael, SomeException "is the root of the exception hierarchy", thus you can handle any there
16:14:32 <nshepperd> glguy: ah...
16:14:42 <Arahael> HeladoDeBrownie: So Exceptions in Haskell always have a single root?
16:14:45 <HeladoDeBrownie> Arahael, i'm suggesting that you start, if it's important that you learn when a function uses undefined or error.
16:14:47 <merijn> HeladoDeBrownie: That doesn't help the problem of "how do I know whether exceptions can arise"
16:14:56 <merijn> Arahael: Yes, SomeException is the catch all case
16:15:04 <HeladoDeBrownie> merijn, quite right, i was just providing a possible workaround
16:15:08 <Arahael> Cool, that helps.
16:15:21 <Cale> hiptobecubic: If you want to be super pretty about it, you might want to look into http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
16:15:22 <merijn> "foo `catch` (\(SomeException _) -> whaterver)" should catch everything
16:15:34 <HeladoDeBrownie> the code that bottoms out is out of Arahael's hands it seems, so the best that can be done is something kinda gross like forkFinally to catch it
16:15:49 <ReinH> HeladoDeBrownie: why does that require forkFinally?
16:15:50 <hiptobecubic> Cale, well evaluation is timed :)
16:15:54 <merijn> hiptobecubic: You still at UvA? I don't suppose you wanna do a bachelor/master project on checked exceptions in haskell like languages? ;)
16:16:01 <Arahael> HeladoDeBrownie: Are you suggesting that I fork every library function I use!? ;)
16:16:16 <HeladoDeBrownie> ReinH, so that you can handle the thread dying due to _|_… am i missing something?
16:16:29 <Arahael> I don't have the time to read the implementation of every function I use.  There is a reason why I use ilbraries.
16:16:32 <Arahael> *libraries
16:16:34 <HeladoDeBrownie> Arahael, do them all in the same thread, which you fork off main, is what i was suggesting. but it's possible i'm missing something, apparently
16:16:35 <ReinH> HeladoDeBrownie: but they aren't forking a thread, so why can't they just use catch?
16:16:45 <hiptobecubic> merijn, i *would* have but no :)  I graduated in 2013 I think
16:16:49 <hiptobecubic> Yes definitely was 2013
16:16:52 <HeladoDeBrownie> ReinH, i didn't think catch worked on bottom exceptions.
16:17:10 <hiptobecubic> Not even in the Netherlands anymore
16:17:17 <merijn> hiptobecubic: Where are you now?
16:17:17 <Cale> Arahael: Okay, then read the documentation. It should be common enough practice to warn about cases where functions may use error.
16:17:19 <ReinH> HeladoDeBrownie: It does fsvo bottom, i.e. the ones generated by error?
16:17:27 <ReinH> which are IOExceptions?
16:17:35 <hiptobecubic> merijn, Austin, TX. The weather is pretty much reversed. I'm enjoying it.
16:17:38 <HeladoDeBrownie> ReinH, that is the information i was missing. thank you for clearing that up. Arahael, ignore my suggestion then.
16:17:44 <Arahael> HeladoDeBrownie: What I was hoping for, is some kind of tool that analysed the code and then suggested that such a function might throw and if so, then it isn't handled.
16:17:45 <merijn> The problem with bottom is not that it can't be caught, but that you can't guarantee they're thrown
16:17:53 <Arahael> Cale: Wreq does not warn.
16:17:57 <Cale> Arahael: error should only be used in cases where you're *not* going to try to catch the exception
16:18:06 <HeladoDeBrownie> Arahael, understood. i'm not aware of that existing and i sorta doubt it does.
16:18:13 <Cale> Arahael: Or are we looking at a case where throwIO is being used?
16:18:14 <HeladoDeBrownie> Cale, the problem is someone else's code *already* does that
16:18:21 <Arahael> HeladoDeBrownie: Ironically, Java does this.
16:18:24 <HeladoDeBrownie> in short we have an api problem
16:18:24 <ReinH> HeladoDeBrownie: undefined is distinguishable from non-termination at runtime :)
16:18:24 <merijn> Cale: That doesn't help the "my dependecy throws exceptions and doesn't document it" problem
16:18:28 <Cale> Yeah, well, maybe stop using that code
16:18:36 <HeladoDeBrownie> Cale, :)
16:18:50 <merijn> Ok, bed time for me now
16:18:50 <Arahael> Cale: I'm not sure.... I don't know (and I don't care) how Wreq does this.
16:19:04 <HeladoDeBrownie> ReinH, yep, i know
16:19:06 <Arahael> Cale: Except for this particular example, I quite like Wreq's api.
16:19:08 <ReinH> HeladoDeBrownie: or, rather, during execution of an IO action that produces it :)
16:19:16 <ReinH> HeladoDeBrownie: ok :)
16:19:23 <HeladoDeBrownie> ReinH, thanks again for clarifying
16:19:35 <Cale> It is theoretically possible to catch exceptions thrown by calls to error for this reason that you may really need to, but it's a last resort tactic, not something that you'd usually like to admit in your program if you can avoid it.
16:19:41 <ReinH> HeladoDeBrownie: :)
16:20:06 <Cale> Catching exceptions thrown from the execution of IO actions rather than by evaluation of expressions is another matter.
16:20:21 <Cale> You can just use try or catch or handle
16:20:35 <HeladoDeBrownie> haskell has a bazaar of sorts of errors, some of which are indeed rather bizarre.
16:20:38 <ReinH> Arahael: what exceptions are actually thrown by Wreq? I sort of doubt that it just uses error.
16:21:00 <ReinH> I would imagine it is throwing a particular IO exception.
16:21:02 <Cale> http://hackage.haskell.org/package/wreq right?
16:21:07 <ReinH> Cale: yep
16:21:31 <hiptobecubic> url 1
16:21:36 <ReinH> As in, if it actually uses error I would consider that a bug, and that seems uncharacteristic of bos.
16:22:09 <Arahael> ReinH: Depends on how I trigger the failure, here's one: stocks: StatusCodeException (Status {statusCode = 405, statusMessage = "Method Not Allowed"}) [("Server","Apache-Coyote/1.1"),("Content-Length","0"),("Date","Wed, 18 Feb 2015 22:33:02 GMT"),("Connection","close"),("X-Response-Body-Start",""),("X-Request-URL","POST http:/\
16:22:24 <Arahael> /www.foo.com:80/bar")] (CJ {expose = []})
16:22:27 * HeladoDeBrownie thinks that all uses of error that cannot be replaced by another expression to have the same effect are bugs :P
16:22:45 <Arahael> And I get a different error if I misspell the domain name.
16:23:03 <HeladoDeBrownie> Arahael, that one is definitely catchable and you should catch it
16:23:30 <Arahael> HeladoDeBrownie: The problem I have is *how do I know*!?
16:23:34 <ReinH> Arahael: How did you produce that exception?
16:23:40 <ab9rf> i dislike the use of exceptions to handle "the remote server didn't respond the way you wanted it to"
16:23:44 <HeladoDeBrownie> Arahael, how do you know… what specifically?
16:23:49 <ReinH> I wonder if there's a safe(r) version
16:23:56 <HeladoDeBrownie> ab9rf, i agree, i'd rather Either, but maybe it got too verbose
16:24:23 <Arahael> ReinH: Simple, I followed their tutorial, then deliberately misspelt the url, and got an exception despite using the ^? accessor functions rather than ^. (from Lens, as per Wreq documentation)
16:24:34 <ab9rf> exceptions are a pita; using explicit error returns, while "more cumbersome", is easier to reason about.
16:24:38 <Cale> Can I see the code?
16:24:43 * geekosaur seriously wishes we didn't use exceptions for that
16:24:46 <Arahael> Cale: One sec.
16:24:48 <geekosaur> we have a real type system...
16:24:51 <Cale> Just so I can look at what in Wreq is producing the error
16:25:33 <Cale> I don't see many calls to error in Wreq -- there's just one in Network/Wreq/Cache/Store.hs, and it's apparently where an invariant of a data structure is violated, so it really shouldn't happen
16:25:38 <simon> geekosaur, aren't exceptions more efficiently implemented than, say, using Maybe/Either?
16:25:49 <Cale> and there are no occurrences of throwIO either
16:25:51 <geekosaur> um, no?
16:25:55 <init> does anyone know why "GHC Internal error" happens in this example code (instead of a friendly error)? http://lpaste.net/120936
16:26:26 <geekosaur> exceptions are usually extremely inefficient. except in languages which made the mistake of trying to use them for things like this, and then discovered they needed to find some way to optimize stack unwinding or the equivalent
16:26:29 <Cale> I think maybe the HTTP library that is being used by Wreq throws the exceptions
16:26:51 <Cale> because the comments in Wreq talk about them
16:26:52 <ReinH> Cale: Look at http-client.
16:26:58 <simon> geekosaur, those were the languages I had in mind.
16:27:00 <geekosaur> (and even so theyre never very efficient)
16:27:04 <ReinH> Cale: that's what's generating the Response
16:27:10 <geekosaur> (because stack unwinding is never efficient)
16:27:38 <HeladoDeBrownie> arguably, exceptions and Either and Maybe address separate concerns. for example, an IO computation can fail *at any moment* for any number of reasons, e.g., out of memory, instructed to terminate, etc. if you had to use Either or Maybe to cover these, you'd either have all IO computations result in one of those, or you'd build it into the type, *or* you'd build it into the interpreter… which is
16:27:40 <geekosaur> you can optimize it somewhat but there's a limit
16:27:41 <HeladoDeBrownie> kinda-sorta what exceptions are, afaict.
16:28:07 <chrisdone> exceptions don't have to be fast
16:28:10 <chrisdone> they're exceptional =p
16:28:16 <ReinH> simon: Just the opposite, in fact. :)
16:28:25 <HeladoDeBrownie> (anyone feel free to address anything i said that seems incorrect)
16:28:28 <Cale> http://hackage.haskell.org/package/http-client-0.4.7.1/docs/Network-HTTP-Client.html#g:12 -- yeah
16:28:35 <Arahael> Cale: I'd prefer to keep the code private, however it is here: http://lpaste.net/3457867879267958784
16:28:37 <geekosaur> right, but there is a difference between exception because out of memory and using throwErrnoIfMinusOne to turn a synchronous error condition into an asynchronous exception
16:28:48 <ReinH> wreq at least provides nice lenses for those exceptions
16:28:52 * hackagebot jose-jwt 0.4 - JSON Object Signing and Encryption Library  http://hackage.haskell.org/package/jose-jwt-0.4 (LukeTaylor)
16:28:53 <geekosaur> which is what our FFI stuff all too often does, including the network stuff
16:29:10 <HeladoDeBrownie> geekosaur, so would one solution be to implement more stuff natively in haskell, if possible?
16:29:18 <Cale> Arahael: Are you sure the exception is happening in that code?
16:29:24 <Arahael> Cale: Completely sure.
16:29:41 <Cale> Arahael: oh, it's probably inside of "post"?
16:29:53 <geekosaur> HeladoDeBrownie, there's no reason FFI calls couldn't produce Either ErrorCode whatever, they just weren't designed that way and it's probably too late to fix them :(
16:30:09 <Arahael> Cale: It's the only code that uses wreq, and yes, I believe it is probably from "post", as wreq would have to be astonishinly bad if it was from the Lens calls.
16:30:16 <cmccann> there's always spoon
16:30:17 <cmccann> @hackage spoon
16:30:17 <lambdabot> http://hackage.haskell.org/package/spoon
16:30:19 <Cale> right, yeah
16:30:20 <geekosaur> there are some "safe" type packages on hackage, like spoon
16:30:37 <geekosaur> but base and network have all these things that use exceptions for no good reason
16:30:50 <Cale> So, yeah, the exception type that gets thrown is HttpException from here: http://hackage.haskell.org/package/http-client-0.4.7.1/docs/Network-HTTP-Client.html#g:12
16:31:39 <Cale> You can catch that by applying try to the post, and treating the result as an Either HttpException (Response ByteString)
16:31:39 <geekosaur> and worse, the interaction between exceptions and laziness is pretty terrible
16:31:50 * cmccann thinks that exceptions which occur during normal use for predictable and locally-relevant reasons shouldn't be exceptions
16:32:06 <cmccann> like, "out of memory" is a perfect example of a legit exception
16:32:17 <geekosaur> you keep having to force things just to make sure you can catch an error reflected as an exception instead of as an error return
16:32:25 <Arahael> Cale: I believe I'll implement a wrapper called eitherPost, however the point remains "how do I know this could happen?"
16:32:28 --- mode: Cale set -oo Cale shapr
16:32:30 <cmccann> whereas "file not found" when trying to open a file should absolutely not be an exception
16:32:46 <Cale> Arahael: Well, in general, you can't.
16:33:30 <Cale> Arahael: But you'd hope that the author of the library documents it. In this particular case, it's just a little unfortunate because Wreq is a wrapper around the library which produces the exceptions.
16:33:30 <cmccann> since even checking first whether the file exists doesn't mean it'll be there when you try to open it
16:33:33 <Arahael> Cale: So I should assume that anything in the IO monad could have an exception, and this would be 'perfectly reasonable' in Haskell, whereas exceptions anywhere else should be regarded as a bug?
16:33:58 <Cale> If you'd been using http-client directly, the documentation would have been clearer about the fact that exceptions get thrown.
16:34:06 <Cale> Yeah
16:34:21 <Cale> Well, I don't know about "perfectly reasonable"
16:34:26 <Cale> It's always a matter of taste
16:34:28 <ReinH> imperfectly reasonable.
16:34:29 <Arahael> Cale: That is a fairly poor explaination - I shouldn't have to care about the implementation of a routine in order to use it.
16:34:30 <cmccann> Cale: it seems to me that exceptions you'd expect to be documented are exactly those which really ought to be explicit in the type using Either or such
16:34:48 <Cale> Arahael: There's only so much that types encode, and this is on purpose.
16:34:59 <Arahael> Cale: Even *Java* manages to encode this fine.
16:35:08 <aavogt> @hackage explicit-exception
16:35:08 <lambdabot> http://hackage.haskell.org/package/explicit-exception
16:35:12 <Cale> Arahael: What types ought to encode and what they ought not to encode is always an important design decision.
16:35:14 <rui> Is it free to put something in a newtype?
16:35:20 <cmccann> Arahael: isn't that one of the things in Java that everyone hates, though? like, even people who like Java for some reason.
16:35:27 <Cale> Arahael: and the answer is almost never a complete specification of what the function does
16:35:28 <rui> I mean, does it take time?
16:35:46 <cmccann> rui: applying newtype constructors are generally equivalent to id
16:35:54 <Arahael> cmccann: For various reasons, I don't think they apply here.
16:36:07 <cmccann> rui: both will optimized away when applied directly. something like "map SomeNewtype list" is another matter.
16:36:17 <Arahael> cmccann: Java has no parametric polymorphism, for instance.
16:36:21 <rui> cmccann Great, clear. Thanks
16:36:26 <Cale> Arahael: Of course in Haskell we have this option to not use IO exceptions, and most of the time, we even take that route.
16:36:36 <Cale> Arahael: You can always use Either instead.
16:36:47 <Arahael> Cale: Here, I was explicitly attempting to always use Either.
16:36:50 <cmccann> Arahael: true, we have better ways to work with stuff in general, I just don't think this is something that Java got "right" necessarily
16:37:06 <Arahael> cmccann: Perhaps it's a good idea but poorly executed in Java.
16:37:19 <Cale> and you can even use Either in conjunction with the Exception machinery, if you want to be a bit imprecise about what type of exception may occur -- you can use Either SomeException
16:37:23 <cmccann> Arahael: yeah, I can probably agree with that
16:37:50 <Arahael> Cale: Isn't exception handlign usually imprecise anyway - you could match against that with more precise patterns?
16:37:53 <Cale> Arahael: Yeah, your problem was simply that the authors of the library you were using made a different design decision about what to encode at the type level than you expected.
16:38:19 <Arahael> Cale: Regardless of hte design decision - their API design and documentation is at odds with that decision.
16:39:03 <Cale> Well, I haven't looked closely enough at Wreq to be sure, but it seems at least slightly reasonable to have things throw an HttpException when something goes wrong at that level.
16:39:25 <Hafydd> I'll wreq you, m8.
16:39:31 <Cale> It gives you some options for where to handle the errors in cases where you're doing a bunch of HTTP requests and might not want to handle the failures one at a time.
16:39:50 <Cale> You can just let the exception bubble up a bit and catch it in a wider scope
16:40:00 <Arahael> Cale: Consider that you should _still_ be getting an http response if you get the url wrong (but the domain right), and that you should therefore have an http code.
16:40:39 <Cale> Yeah, it's possible that StatusCodeException should not be one of the exceptions
16:40:57 <Cale> (but there are lots of other ones which seem reasonable)
16:41:09 <Keiya> .topic
16:41:15 <Arahael> Cale: Also, they provide api's that specifically result in Either, it's reasonalbe to assume that any exceptions would result in the 'left' type.
16:41:21 <Keiya> whoops, sorry
16:41:34 <Arahael> (Or Maybe, as the case may be)
16:41:50 * Arahael nudges Keiya's keyboard to the left.
16:42:08 <Cale> One thing I find a bit surprising is that HttpException is this type with a ridiculous number of constructors, rather than a whole bunch of separate exception types
16:42:17 <monochrom> that would lead to /yp[ov :)
16:43:12 <Cale> (and maybe one catch all type which implements the Exception class in such a way as to catch any of the HTTP exceptions)
16:43:27 <Arahael> Cale: Perhaps they should return Either HttpException then, and thus cover them in the return type.
16:43:43 <Cale> Arahael: That is definitely an option
16:43:57 <Cale> Arahael: Probably the one which most Haskell programmers would even prefer, I think
16:44:08 <Cale> But I'm just saying it's not totally unreasonable to do what they did
16:44:17 <Cale> It's just a matter of personal taste
16:44:53 <Arahael> Cale: Yeah.  And given that...  I was really hoping that there was a hlint tool or copmiler option that would at least warn me of this.
16:45:01 <Cale> The Wreq documentation should *definitely* mention the possibility of exceptions too.
16:46:27 <Cale> I wonder how hard it would be to make a tool which would statically determine some reasonably tight superset of the possible exceptions that an IO action may produce.
16:47:13 <dulla> there are two other ways to toss exceptions
16:47:37 <dulla> forgot what they were, one is interoperable
16:48:26 * cmccann still wishes that IO didn't implicitly allow arbitrary exceptions to be thrown and caught as if it was "ExceptT SomeException IOWithoutExceptions"
16:49:41 <dulla> We need to go deeper, cmccann
16:50:01 * dulla bwwwwommmmmmmmmmmmmmmm
16:57:18 <shapr> Cale: aw, I like my op hat
16:59:07 <Cale> shapr: Put it back on if you like, I just thought you might've left it on by accident
17:00:54 <Sornaensis> is there a way to dynamically load libraries in a haskell program
17:01:03 <RobbyG> can someone help me please with a picture frame project?  I only have one thing left so it should be easy but I can not figure it out http://lpaste.net/2212564604536487936
17:01:18 <Sornaensis> seems that once something is imported it can't be changed out
17:02:18 <Arahael> How do I lift a type again?  Eg, I want to return IO Right resultThatReturnsIO
17:02:51 <HeladoDeBrownie> Arahael, "lift" is vague. can you clarify?
17:03:00 <HeladoDeBrownie> (i didn't understand your example)
17:03:32 <ski>   liftM Right resultThatReturnsIO  -- possibly
17:03:34 <HeladoDeBrownie> Arahael, often it's helpful to write the entire type of the function you want
17:03:42 <HeladoDeBrownie> thingIHave -> thingIWant
17:03:42 <Arahael> HeladoDeBrownie: Given a function 'foo', that returns IO a, for some type a.  I want to return an instance of IO Either SomeException a
17:03:46 <ski> (or `fmap' instead of `liftM')
17:04:10 <Arahael> ski: liftM works with type constructors as well as functions?
17:04:10 <HeladoDeBrownie> Arahael, fmap as needed
17:04:28 <ski> Arahael ?
17:04:48 <HeladoDeBrownie> so we want a proof of this type: (a -> IO b) -> (a -> IO (Either e b))
17:05:13 <Arahael> HeladoDeBrownie: Yes.
17:05:19 <Zemyla> Oh, if I'm given a value m of kind (* -> *) and a value c of kind (* -> Constraint), can I check whether c a => c (m a)?
17:05:39 <ski> @type (liftM Right .)
17:05:40 <lambdabot> Monad m => (a -> m a1) -> a -> m (Either a2 a1)
17:05:44 <HeladoDeBrownie> that's just composing (fmap Right) after the original function, so… yes, what ski just said
17:05:50 <Zemyla> Like it would be true for m = [] and c = Ord, but not m = [] and c = Bounded.
17:06:06 <pavonia> RobbyG: What are the second and third parameters of foldFrameDesign supposed to be?
17:06:11 <Zemyla> Is there a way I can check that as a constraint?
17:06:21 <ski> Zemyla : s/value/type/
17:06:38 <Zemyla> ski: Yes.
17:06:59 <ski> Zemyla : sounds like you'd want to say `(forall a. c a => c (m a)) => ...' -- i don't think there is any higher-rank constraint extension ..
17:07:42 <ski> Zemyla : for a specific `C', one workaround is to define a new type class `C1' ..
17:08:14 <ski> (so, with `C :: * -> Constraint', we'd get `C1 :: (* -> *) -> Constraint')
17:08:48 <RobbyG> pavonia: I added the description on the bottom. http://lpaste.net/2212564604536487936
17:09:58 <Zemyla> ski: But it's something the compiler can check, given a c and an m.
17:10:43 <pavonia> RobbyG: So you can use a case expression to select what to do if either of the alternatives are passed to fold
17:10:48 <Arahael> ski: Thanks - took a while to figure it out, but it works _and_ makes sense.  Additionally, it seems that liftM and fmap are identical in this case?
17:11:19 <HeladoDeBrownie> Arahael, they ought to be and almost always are identical whenever both are defined over a given type
17:11:33 <ski> Arahael : yes. for any monad `liftM' ought to be equal to `fmap' (otherwise you have a bug)
17:11:38 <Arahael> HeladoDeBrownie: What is one example where they might be different?
17:11:50 <HeladoDeBrownie> Arahael, someone has committed an error programming one of them.
17:12:10 <Arahael> HeladoDeBrownie: Would that 'someone' be the implementator of the type, or the user of the type?
17:12:17 <RobbyG> pavonia: how would I use a case expression to do that?  I've been going through haskell examples on various websites but this one is kicking by butt
17:12:27 <HeladoDeBrownie> Arahael, whoever wrote the instance.
17:12:38 <ski> if `Functor' was a superclass of `Monad', then `liftM' would only need to be used when making a `Functor' instance when you already have written the `Monad' instance
17:12:39 <pavonia> RobbyG: Do you know how case works?
17:12:39 <HeladoDeBrownie> Arahael, (this can easily not be the one who wrote the type)
17:12:54 <Arahael> HeladoDeBrownie: In the case of orphan instances?
17:12:58 <pavonia> RobbyG: Or how to do pattern matching?
17:13:13 <HeladoDeBrownie> Arahael, orphan instances, but also defining instances in the same module as the typeclass.
17:13:15 <ski> Arahael : or in case someone defined a new type class
17:13:20 <HeladoDeBrownie> what ski said
17:13:30 <Arahael> ski: Ah, I haven't covered those yet.
17:13:41 <ski> which ?
17:13:49 <Arahael> ski: Making my own type classes.
17:13:54 <RobbyG> pavonia: I have seen it a few times but don't have much experience with them, that is why I came on here to see if someone could help me get through this example to learn them.
17:14:00 <ski> ok
17:14:02 <HeladoDeBrownie> Arahael, i suggest it should be done sparingly.
17:14:10 <HeladoDeBrownie> Arahael, usually creating your own datatype suffices.
17:14:22 <Arahael> HeladoDeBrownie: I've found datatypes work most of the time.
17:14:28 <HeladoDeBrownie> good.
17:15:28 <ski> RobbyG : two `Horizontal's ?
17:15:58 <siddhu_> Can you use fold for applicatives? ``` (+) <$> a <*> b <*> c <*> d <*> ....``` where the letters ['a'..'d'] are just list of ints, and the number of letters are not known beforehand?
17:16:08 <RobbyG> ski: thanks for that catch, it is fixed
17:16:21 <Arahael> I'm having difficulty with my operator precedence rules here: eitherPost url args = (liftM Right .)  post ( url args ) `E.catch` Left
17:16:28 <ski> RobbyG : s/hframe/hlayout/ ?
17:16:48 <ski> siddhu_ : what would be the type of `(+)' ?
17:16:51 <pavonia> RobbyG: I added an example branch for Frame http://lpaste.net/2212564604536487936  Can you add the right-hand side?
17:17:02 <Arahael> ski: Do I need to liftM that 'Left' as well?
17:17:03 <siddhu_> (+) :: Int -> Int -> Int
17:17:41 <siddhu_> it's basically ```(+) <$> [1..5] <*> [11..15]```
17:18:08 <arianvp___> you want to generalize that for n lists of ints?
17:18:22 <RobbyG> ski: yes I think I messed that up too. Should be the same, thanks for another catch!
17:18:23 <cow_2001> you guys should add asymmetrical string delimiters to the haskell language.
17:18:24 <siddhu_> yes. I can't know the length of the list beforehand.
17:18:40 <cow_2001> add a language pragma for smart quotes
17:18:48 <Keiya> So I have a vitally unimportant question: Is it weird that I ALWAYS read 'point-free' as 'pants-free'?
17:19:00 <cow_2001> {- thingie SmartQuotes -}
17:19:08 <arianvp___> pants-free is pantless
17:19:23 <arianvp___> huehuehue
17:19:43 <arianvp___> siddhu_: It feels like it should be possible. let me try something
17:19:55 <lyxia> > foldl (liftM2 (+)) [0 :: Int] [[1], [2], [3]] -- siddhu_
17:19:57 <lambdabot>  [6]
17:20:06 <RobbyG> pavonia: sorry you lost me, where is the example branch?
17:20:07 <pavonia> cow_2001: What are asymmetrical string delimiters?
17:20:10 <ski> @type (sum <$>) . Data.Traversable.sequenceA . ([] ++)  -- hmm
17:20:11 <lambdabot> (Applicative f, Num b) => [f b] -> f b
17:20:17 <arianvp___> siddhu
17:20:21 <pavonia> RobbyG: In that fold function
17:20:34 <arianvp___> > join [[1..5],[11..15],[3..20]]
17:20:36 <lambdabot>  [1,2,3,4,5,11,12,13,14,15,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
17:20:39 <cow_2001> pavonia: “smart quotes”
17:20:39 <monochrom> {-# LANGUAGE SmartQuotes, PantsOff, PatternSynonyms #-}
17:20:52 <arianvp___> :t sum . join
17:20:53 <lambdabot> Num c => [[c]] -> c
17:21:03 <arianvp___> how about that?
17:21:10 <cow_2001> monochrom: D:
17:21:21 <pavonia> cow_2001: What are smart quotes?
17:21:23 <ski> > sum <$> T.sequenceA [[100,200],[30,40],[5,6]]
17:21:24 <lambdabot>  [135,136,145,146,235,236,245,246]
17:21:37 <cow_2001> pavonia: look at the quotes in that smart quotes quote
17:21:45 <cow_2001> pavonia: they're different on the left and on the right
17:21:46 <ski> > sum <$> T.sequenceA [Just 100,Just 30,Just 5]
17:21:48 <lambdabot>  Just 135
17:21:58 <ski> siddhu_ : something like those ^ ?
17:22:06 <Arahael> Here's another attempt, with the parens where I think they should be: eitherPost url args = ((liftM Right .)  post ( url args )) `E.catch` (liftM Left .)
17:22:14 <siddhu_> Yes. I'm just confused. There's so many.
17:22:23 <cow_2001> pavonia: it's easier to grep brackets than quotes because brackets are different on the left than on the right
17:22:28 <ski> siddhu_ : so many what ?
17:22:35 <cow_2001> pavonia: an opening bracket is different than a closing bracket
17:22:46 <pavonia> I see
17:22:50 <cow_2001> pavonia: smart quotes are the same as brackets for quoting
17:23:21 <cow_2001> pavonia: postscript uses (..) for quoting for the same reason, or so i've heard on #nothaskell
17:23:38 <yac> In haskell () is (_|_), right?
17:23:43 <RobbyG> pavonia: okay I see it now thank you, so there are more cases for each one?
17:23:51 <hiptobecubic> yac, ?
17:23:51 <Arahael> cow_2001: LaTeX uses `'
17:23:52 <HeladoDeBrownie> yac, no
17:23:54 <monochrom> no, () is not (_|_)
17:24:05 <cow_2001> Arahael: that's cool
17:24:12 <ski> RobbyG : you didn't show either of `doubleSize',`multSize'
17:24:15 <siddhu_> sum <$> T.sequenceA [[100,200],[30,40],[5,6]] is what I was looking for. Thanks everyone!
17:24:16 <yac> what is () then?
17:24:18 <HeladoDeBrownie> yac: _|_ is what we sometimes write to represent bottom, which represents non-termination or otherwise lack of value
17:24:25 <ski> RobbyG : presumably `foldFrameDesign' is a standard fold/catamorphism
17:24:27 <pavonia> RobbyG: One pattern for each constructor, yes
17:24:29 <cow_2001> Arahael: i think it'd be nice to have something like that in haskell
17:24:34 <HeladoDeBrownie> yac, () is the only (non-_|_) value of the unit type, also written ().
17:24:56 * ski . o O ( `()', aka "Sierpinski" )
17:24:59 <Arahael> cow_2001: It'd be too confusing as ` has a special meaning already. (Ie, `foo` turns it into infix)
17:25:25 <yac> HeladoDeBrownie: how do you call it?
17:25:28 <HeladoDeBrownie> Arahael, smart quotes wouldn't conflict with that
17:25:32 <HeladoDeBrownie> yac, "bottom" when pronounced
17:25:32 <hiptobecubic> ugh, I hate `'
17:25:37 <yac> HeladoDeBrownie: I mean ()
17:25:42 <HeladoDeBrownie> yac, "unit".
17:25:42 * ski shifts
17:26:38 <RobbyG> ski: Sorry I left so much out I added them now http://lpaste.net/120940
17:26:38 <cow_2001> Arahael: so something different
17:26:41 <HeladoDeBrownie> Arahael, gah, sorry, i missed your last message
17:26:43 <ski> yac : the type `()' is known as "unit", since it's (up to iso) the unit for type product. the value `()' is the "empty tuple"
17:26:56 <cow_2001> Arahael: those directional smart quotes are nice
17:27:02 <yac> oooh, empty tuple
17:27:06 <HeladoDeBrownie> ski, that's not in common use, is it?
17:27:08 <yac> that makes way more sense
17:27:10 <HeladoDeBrownie> ("the empty tuple")(
17:27:27 <yac> wiki: . It is also called the zero or empty type, and is sometimes denoted with falsum (⊥).
17:27:32 <HeladoDeBrownie> i mean, i agree you can *think of it* as the empty tuple. but i've never heard it called that.
17:27:34 <yac> this is confusing a bit
17:27:41 <HeladoDeBrownie> yac, that's describing a different type.
17:27:46 <Arahael> HeladoDeBrownie: So yeah, I think it'd be confusing to use the same symbols that introduce infix notation.
17:27:47 <HeladoDeBrownie> yac, that type is usually spelled Void in haskell.
17:28:03 <HeladoDeBrownie> yac, Void is 0, () is 1.
17:28:14 <HeladoDeBrownie> (Bool is 2, etc.)
17:28:32 <ski> `(Bool,Ordering)' is `2 * 3', iow `6'
17:28:44 <HeladoDeBrownie> yay algebra!
17:28:55 <ski> arithmetic
17:29:00 <HeladoDeBrownie> yes that
17:29:21 <RobbyG> ski: http://lpaste.net/120940   I fixed this version I was getting confused with two of them
17:29:37 <ski> RobbyG : `Horizontal' is back from the dead
17:30:15 <Arahael> Here's another version that also doesn't compile. :(  eitherPost url args = (liftM Left .) E.catch ((liftM Right .)  post ( url args ))
17:30:22 <RobbyG> ski: okay fixed it, jeeze I am running in circles
17:30:23 <ski> RobbyG : please rename `a',`b',`c' into `frame',`horizontal',`vertical'
17:30:25 <monochrom> the () type is not empty. not in both senses.
17:30:53 <ski> (s/both senses/either sense/ ?)
17:31:02 <monochrom> yeah, something
17:31:13 <monochrom> in the good spirit of "and/or": ...
17:31:19 <monochrom> the () type is not empty. not in both/either senses.
17:31:24 <taktoa> yeah the empty type is data Void
17:31:38 <HeladoDeBrownie> Arahael, i know it's tempting not to, but you need to be mindful of the types when you decide to write something one way. so, what are the types of the things you need composed together?
17:31:47 <ski> RobbyG : consider `doubleSize (Frame  {fname = "one", width = 50, height = 5})' -- what should this return ?
17:31:59 * monochrom is smart! :)
17:33:01 * ski . o O ( "not both in the first sense or in the second sense" )
17:33:14 <HeladoDeBrownie> ski, not both senses.
17:33:16 * monochrom has a cunning plan!
17:33:37 <HeladoDeBrownie> not both "not both" senses
17:33:55 <RobbyG> ski: i renamed a,b,c     I think double would return a window with double the height and width?
17:33:55 * hackagebot buffer-builder 0.2.0.0 - Library for efficiently building up buffers, one piece at a time  http://hackage.haskell.org/package/buffer-builder-0.2.0.0 (chadaustin)
17:33:57 * hackagebot network-attoparsec 0.11.1 - Utility functions for running a parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.11.1 (solatis)
17:34:02 <monochrom> instead of speaking normal English, we should sometimes speak in regex. so that the audience can select whichever actual string they like that matches your regex.
17:34:24 <HeladoDeBrownie> monochrom, interesting\..*
17:34:38 <monochrom> :)
17:34:48 <orzo> do i need to take care to serialize udp sendTo calls to the same socket?
17:34:50 <solatis> monochrom, ah, that will finally get rid of the british english or american english discussion?
17:35:08 <Arahael> HeladoDeBrownie: What I need is IO Either e a, but the functions I have returns IO a. Actually an Exception wouldn't have an IO type, woudln't it?
17:35:24 <solatis> orzo, i believe under windows you should not share sockets between threads
17:35:25 <HeladoDeBrownie> Arahael, it would not, if you're talking about in the type of catch.
17:35:46 <solatis> orzo, sharing sockets between threads is a bad idea in the first place imho
17:36:10 <HeladoDeBrownie> Arahael, do you mind making an lpaste of your erroneous code? it will be easier than scrolling up to see it
17:36:43 <HeladoDeBrownie> Arahael, include the error
17:36:52 <Arahael> HeladoDeBrownie: Ah, in that case I'll lpaste it.
17:37:03 <ski> RobbyG : use that to figure out what to write in the first `case' branch
17:38:50 <Arahael> HeladoDeBrownie: http://lpaste.net/4371148574038163456
17:39:01 * ski stares at RobbyG
17:39:10 <Arahael> HeladoDeBrownie: I can easily get it working if I exclude the 'E.catch' and handler.
17:39:57 <orzo> this stackoverflow answer seems to contradict your advise about not sharing sockets, even claiming "that's what most servers do" http://stackoverflow.com/questions/10271761/sharing-socket-descriptor-between-multiple-threads
17:40:42 <johnw> does anyone know why the following code is giving me a non-exhaustive pattern match warning?  https://gist.github.com/ecc61f7939f10525b54f
17:41:02 <johnw> i would have thought that the use of a closed type family would be sufficient to indicate which pattern matches are impossible
17:41:22 <Arahael> orzo: I would expect that depends completely on how the IO implementation is done, and the specifics of the threading behaviour.
17:41:58 <Arahael> orzo: There, they're using pthreads, and presumably some unix system which probably allows child processes or threads to inherit descriptors.
17:42:30 <pavonia> johnw: What about (</>) p@(RelDir (Just _) _) _?
17:42:36 <RobbyG> ski: something lthis simple? http://lpaste.net/120940
17:42:44 <davean> probably?
17:42:53 <johnw> pavonia: I'm more wondering abuot (AbsDir _ _) Root , for example
17:42:59 <orzo> i'm not on windows either
17:43:24 <johnw> the implementation is not finished, I just ran into that and wondered
17:43:29 <HeladoDeBrownie> Arahael, well the handler looks to be of the wrong type. you need it to return IO thing but it returns Either whatever thing
17:43:31 <orzo> if sharing sockets on unix is best practice on unix, than that overrules windows concerns for me
17:43:47 <Arahael> HeladoDeBrownie: So it looks like I need to Lift it somehow?
17:43:55 <HeladoDeBrownie> Arahael, yeah, return . Left should serve
17:44:13 <Arahael> HeladoDeBrownie: Of course! It's not just syntatic sugar in "do notation", isn't it?
17:44:19 <HeladoDeBrownie> Arahael, right :)
17:44:21 <ski> RobbyG : getting closer
17:44:23 <HeladoDeBrownie> @type return
17:44:24 <lambdabot> Monad m => a -> m a
17:44:26 <Arahael> HeladoDeBrownie: Thanks. :)
17:44:27 <HeladoDeBrownie> return :: a -> IO a
17:44:43 <HeladoDeBrownie> return :: Either a b -> IO (Either a b)
17:44:59 <ski> RobbyG : look at the definition of `doubleSize', it passes something which doubles numbers as first argument to `foldFrameDesign' .. you need to use this to (indirectly) do the doubling in the first case of `foldFrameDesign', instead of directly
17:45:32 <davean> Arahael: its a *requirement* of POSIX, a fundimental part of how POSIX works
17:47:10 <davean> Arahael: http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html
17:47:19 <ski> RobbyG : makes any sense ?
17:47:29 <davean> "File descriptors open in the calling process image shall remain open in the new process image, except for those whose close-on- exec flag FD_CLOEXEC is set."
17:48:07 <RobbyG> ski: I think so, so I call that? http://lpaste.net/120940
17:48:19 <ski> (RobbyG : the reason you can't double directly like in that revision is that then `addToSize' would want you to also instead add to instead of double)
17:48:35 <ski> RobbyG : no
17:48:46 <cmccann> johnw: you will get non-exhaustive pattern warnings even when you've covered all cases possible for non-bottom arguments
17:48:46 <mniip> [21:07:53] <wz1000> phaul: mniip wrote these helper functions (http://lpaste.net/120675) for that set type, naming it after me.
17:48:52 <mniip> sadly that paste has exppired
17:49:11 <ski> RobbyG : `doubleSize' should call `foldFrameDesign', not the other way around
17:49:24 <Zemyla> :k (Int ~)
17:49:25 <lambdabot> parse error on input ‘)’
17:49:26 <ski> RobbyG : can you tell me, for this particular call to `foldFrameDesign' (the one inside the definition of `doubleSize'), what is the values of `frame',`horizontal',`vertical',`design' ?
17:49:30 <Sornaensis> does anyone here have experience dynamically loading libraries in haskell
17:49:37 <Zemyla> :k ((~) Int)
17:49:38 <lambdabot> * -> Constraint
17:49:39 <cmccann> johnw: which is a bit silly imo, but last I checked that's what happens
17:49:56 <mniip> wz1000, https://gist.github.com/mniip/671e06b4cc8c39b11e18
17:50:49 <ski> mniip : <http://lpaste.net/revision/120675>
17:51:45 <dulla> ??
17:52:10 <mniip> oh?
17:52:14 <johnw> cmccann: well, that's irksome
17:52:14 * ski blinks at dulla
17:52:25 <cmccann> johnw: yes
17:52:36 <johnw> cmccann: I guess I can add a PathKind to cover that case, and then never provide a constructor that produces it for my GADT
17:53:07 <johnw> no, then I have no implementation possible
17:53:10 <johnw> I need Void there
17:53:30 * ski awaits more feedback from RobbyG
17:54:55 <cmccann> johnw: afaik there are open bugs in the GHC traq about how that's handled
17:55:12 * dulla blinks back ski with dewy eyes, and long eyelashes
17:55:24 <johnw> cmccann: thanks anyway
17:55:31 <cmccann> johnw: in some cases there really are valid patterns containing _ that it complains about, and sometimes it's actually impossible to write the missing patterns at all
17:55:36 <RobbyG> ski: It should take the three frames, but  I'm having a hard time tracing through it.
17:55:38 <cmccann> which yours is I'm not sure
17:55:49 * ski gesticulates wildly to dulla pointing to a plum pudding and a paddle
17:56:23 <RobbyG> ski: should I be using map?
17:56:24 * dulla swoons in response to ski 's advances
17:56:45 <cmccann> johnw: here's some fun reading for you: https://ghc.haskell.org/trac/ghc/ticket/3927
17:56:54 * ski frowns
17:57:06 <dulla> I don't know how to interpret that, ski
17:57:09 <dulla> So
17:57:14 <dulla> presume it's something
17:57:19 <geekosaur> as inappropriate for channel, for one
17:58:22 <ski> RobbyG : you will need to use `map' (or something similar) at some point .. but not for this branch
17:59:03 <RobbyG> ski: I feel like I am missing something so simple
18:00:04 <ski> RobbyG : `foldFrameDesign' itself doesn't (shouldn't) know how to specifically massage `design' .. the other arguments are there to tell this
18:01:35 <RobbyG> ski: Since the size is already doubled do I just leave it as 'Frame name w h -> Frame name w h'
18:01:52 <ski> RobbyG : .. it might be simpler to start with writing `sumWidth',`doubleSize',`addToSize',`multSize' directly with recursion first, and then factor out the common bits until you arrive at `foldFrameDesign'
18:02:44 <ski> RobbyG : but since it seemed you didn't want to do that, but write `foldFrameDesign' directly, i'm attempting to figure out how to show how you can do that, without just giving the solution away (which i could do (and explain it), if that would help more)
18:02:58 <Arahael> davean: Windows is not POSIX compliant.
18:03:02 <ski> RobbyG : "Since the size is already doubled" -- where is it doubled ?
18:03:27 <Arahael> davean: It's not even POSIX 1 compliant, unless you have the (discontinued?) SKU installed.
18:04:51 <RobbyG> ski: I didn't want to go that route but for this example I think the solution and explanation would help a lot.   I thought doubleSize doubles it but I might be wrong
18:05:20 <ski> RobbyG : yes `doubleSize' doubles. where specifically inside it is the doubling happen ?
18:05:44 <ski> s/happen/happening/
18:06:15 <RobbyG> ski: Is that the 'Frame' part
18:06:51 <ski> which exact (sub)expression ?
18:07:47 <RobbyG> ski: does this first branch return the area?
18:08:08 <ski> "area" ?
18:08:44 <ski> i'm not sure what you mean
18:08:58 <RobbyG> ski: length*width for the frame ?
18:09:40 <ski> the first branch (of the `case' in `foldFrameDesign') is supposed to return what `foldFrameDesign' is supposed to return, when passed a plain `Frame {...}' design
18:10:07 <ski> so far, i haven't seen any code that will return `length * width' for any frame
18:10:16 <RobbyG> s/length/height
18:10:21 <ski> (or `height * width' for that matter)
18:10:31 <davean> Arahael: "some unix system which probably allows child processes or threads to inherit descriptors."
18:10:49 <davean> Arahael: if it doesn't, it is - by definition - not unix.
18:11:57 <RobbyG> ski: nevermind with the area I thought size was the area, that was throwing me off
18:12:09 <ski> ok
18:13:35 * ski ponders whether to reask RobbyG the unanswered questions
18:14:38 <Arahael> davean: I was responding to the stackoverflow reference in the original conversation. "unix" is not mentioned.
18:16:06 <RobbyG> ski: I was trying to work this out but I'm just not getting anywhere with this one.    Frame name w h -> FrameDesign (name, w, h,)
18:17:29 <ski> RobbyG : you need to use the other arguments given to `foldFrameDesign'
18:18:57 * hackagebot yeller 0.1.0.0 - A Yeller Client For Haskell  http://hackage.haskell.org/package/yeller-0.1.0.0 (TomCrayford)
18:20:12 <RobbyG> ski: Can you explain the first branch and I'll try to work out the rest? I'm just not folowing sorry
18:23:37 <ski> RobbyG : you want `doubleSize' to return a `Frame {...}' when passed a `Frame  {fname = "one", width = 50, height = 5}', agree ?
18:24:08 <RobbyG> ski: yes agree
18:24:59 <ski> and because `doubleSize' directly calls `foldFrameDesign', with this same input frame (plus a bunch of other arguments), we want this call to `foldFrameDesign' to also return this `Frame {...}'
18:25:25 <ski> so, when `foldFrameDesign' is called, we know
18:25:31 <gregnwosu> can i ask a slightly trolly question
18:25:50 <ski>   frame      = \(fn,w,h) -> Frame {fname = fn, width = 2*w, height = 2*h}
18:25:55 <ski>   hotizontal = Horizontal
18:26:02 <ski>   vertical = Vertical
18:26:26 <ski>   design     = Frame {fname = "one", width = 50, height = 5}
18:26:32 <gregnwosu> does anyone have any practical experience of using category theory to improve thier programs?
18:26:40 <ski> (s/hotizontal/horizontal/)
18:27:02 <ski> gregnwosu : maybe you should ask edwardk
18:27:12 <gregnwosu> im reading lots about C-theory but texts are very thin on practical application in haskell
18:27:19 <ski> RobbyG : ok, so far ?
18:27:26 <johnw> gregnwosu: it's more about using it to improve your thinking, since you are using one category at least anytime that you compose functions
18:27:35 <btcNeverSleeps> How can I find a cabal.config on stackage that has a constraint on, say, cabal-install 1.20.0.6?
18:28:06 <RobbyG> ski: yes I am following along
18:28:14 <Arahael> Hmm, I'm still struggling with liftM and post, as it turns out:
18:28:43 <Arahael> http://lpaste.net/238851188689207296
18:29:06 <ski> RobbyG : so, next `foldFrameDesign' matches `design' on the pattern `Frame name w h', which matches (thereby committing to this branch), getting us the further bindings :
18:29:11 <Arahael> It doesn't seem to matter how many arguments I give to post...  It still claims that 'post' has too few arguments.
18:29:13 <ski>   name = "one"
18:29:13 <gregnwosu> johnw: not only composition but using functions map to morphisms no?
18:29:20 <ski>   w    = 50
18:29:23 <ski>   h    = 5
18:29:47 <johnw> gregnwosu: functions are the morphisms of the Hask category
18:29:59 <ski> RobbyG : now, from these pieces, the question is how to piece together the `Frame {...}' we want to return here (which exact frame is that, in this example ?)
18:30:05 <johnw> with (.) for compositions, and "id" for identity
18:30:18 <Arahael> This one has imports added: http://lpaste.net/238851188689207296
18:30:30 <Arahael> I can't fathom why that doesn't typecheck.
18:30:37 <gregnwosu> johnw: aye, i guess my cat-fu just isnt at the level where i can apply its findings
18:30:51 <ski> Arahael> :t post
18:31:18 <gregnwosu> johnw: do you know of any resources that have common haskell applications of cat theory
18:31:21 <Arahael> ski: From hackage: post\ ::\ Postable\ a\ =\>\ String\ -\>\ a\ -\>\ IO\ \(Response\ ByteString\)
18:31:27 * ski blinks
18:31:28 <johnw> gregnwosu: my earlier paste is an example of how I'm trying to apply category theory right at this moment to devise a better interface for working with file pathnames
18:31:31 * Arahael also blinks...
18:31:37 <Arahael> post :: Postable a => String -> a -> IO (Response ByteString)
18:31:41 <johnw> https://github.com/jwiegley/notes/blob/master/Pathname.hs
18:31:44 <Arahael> No idea how those backticks got in.
18:31:59 <gregnwosu> johnw: awesome thanks muchly
18:32:00 <ski>   eitherPost url args = liftM Right (post url args)
18:32:02 <johnw> categories are the right structure for thinking about paths, in my opinion, but it isn't how we think of them today
18:32:13 <RobbyG> ski: Frame {fname = "one", width = 50, height = 5}   or with 100 and 10?
18:32:29 <ski> RobbyG : the latter is what we want to return here, no ?
18:32:46 <RobbyG> Yes
18:32:47 <ski> (since this will be what `doubleSize' also returns)
18:33:23 <ski> RobbyG : so, using the seven bindings above, how do you build this intended result ?
18:33:54 <gregnwosu> johnw: interesting thoughts... i suppose they are good if you want to compose paths and infer on things like initial /terminal objects etc
18:34:10 <btcNeverSleeps> In a cabal.config I can specify the constraints to, say, cabal-install.  How can I specify that I want GHC 7.8 and not GHC 7.10?
18:34:18 * ski is trying to make RobbyG view this as a puzzle, with puzzle pieces to try to fit together to make the desired shape
18:34:29 <johnw> gregnwosu: exactly, and what functors are there, and does a useful Monad exist, etc.
18:34:49 <johnw> CT opens up your thinking, because you get to bring a huge catalog of prior discovery into play
18:35:03 <ski> RobbyG : .. i can tell you that in this case, you won't need *any* other operation than these seven bindings (and you don't need all of them, either)
18:35:31 <gregnwosu> yeah, im boning up but im struggling making the cognitive leap to seeing my haskell in categories
18:36:05 <orzo> :t whenJust
18:36:07 <lambdabot> Not in scope: ‘whenJust’
18:36:12 <RobbyG> ski: I was laughing at your star comments.   Just to be clear the seven binding are frame, horizontal, vertical, design, name, w, and h?
18:36:21 <orzo> :t withJust
18:36:22 <lambdabot>     Not in scope: ‘withJust’
18:36:22 <lambdabot>     Perhaps you meant ‘without’ (imported from Control.Lens)
18:36:26 <johnw> gregnwosu: Milewski's recent posts might be good for that
18:36:44 <gregnwosu> johnw: thanks again will read
18:37:25 <ski> RobbyG : yes
18:37:36 <gregnwosu> ah ive read some of those, will read more , i think i had to take a softer introduction but i feel ready for them again no
18:37:47 <gregnwosu> *now
18:38:02 <RobbyG> ski: Is this getting close? Frame {fname = name, width = 2*w, height = 2*h}
18:38:13 <johnw> edwardk recently made a discovery using some rather deep CT results, which in the end let him optimize lens traversals in a very cool way
18:38:22 <ski> RobbyG : yes
18:38:23 <johnw> he's definitely a master at translating that kind of theory into practice
18:38:54 <ski> RobbyG : now you've abstracted from the particular result-parts `100' and `10' and replaced them with puzzle pieces, which is good
18:39:07 <ski> oh, and also the `name' part
18:39:08 <mauke> johnw: ooh, do you have a link to more information?
18:39:16 <ski> RobbyG : now the final step here :)
18:39:20 <gregnwosu> mauke:  he has a blog
18:39:29 <johnw> mauke: I'm not sure he's written this up yetn
18:39:35 <ski> RobbyG : which of the seven bindings haven't you used yet ?
18:39:37 <ParmesanCaesar> all this flirting is getting me hot and bothered
18:39:37 <johnw> it involves three different kinds of kan extensions
18:39:44 <ski> RobbyG : what are their values ?
18:39:47 <johnw> if you ask him, I'm sure he'll be more than happy to retell the story :)
18:39:52 <ski> RobbyG : which of them could possibly be of any use here ?
18:40:00 <gregnwosu> mauke: my mistake i was thinking of ezyang
18:40:22 <Arahael> ski: Sorry, I had to go out, back to this: post :: Postable a => String -> a -> IO (Response ByteString)
18:40:25 <johnw> one of the key aspects was contravariant applicative functors, by using the Day convolution appropriate to Applicatives
18:40:34 <johnw> s/appropriate/approach
18:40:40 <ski> <ski>   eitherPost url args = liftM Right (post url args)
18:40:43 <ski> Arahael ^
18:40:50 <Arahael> ski: I've interpreted that as "post is a function taking two arguments, and returning an IO (Response ...
18:40:50 <johnw> (i.e., the monoid object ([Hask,Hask],Day,Identity))
18:40:54 <gregnwosu> *mindblown*
18:41:22 <Arahael> ski: Right...  I must've unintentionally introduced another argument with the '.' operator?
18:41:50 <shachaf> johnw: That isn't a monoid object. :-(
18:41:54 <btcNeverSleeps> can anyone explain me the relation between a package constraint and GHC?  Can older versions of GHC be installed inside cabal sandboxes?
18:42:00 <ski> Arahael : you could also say `eitherPost = (liftM Right .) . post', if you really wanted to ..
18:42:36 <ski> (or `eitherPost = liftM Right .: post', if you define `(.:)' appropriately)
18:42:51 <RobbyG> ski: design?
18:43:03 <ski> RobbyG : `design' was used in `case design of ...'
18:43:05 <Arahael> ski: I admit I''m a bit confused as to what those parens are doing aroudn that liftM - surely it shouldn't make any difference, except for precedence rules?
18:43:17 <ski> the pieces of it is `name',`w',`h'
18:43:47 <ski> Arahael : which parens ?
18:43:47 <kadoban> Arahael: It's a section, like (1+) means \x -> x + 1
18:44:15 <RobbyG> ski: frame then?
18:44:20 <Arahael> ski: The "section" (Thanks kadoban)
18:44:24 <ski> RobbyG : why ?
18:44:26 <HeladoDeBrownie> hmm, since there's an M-less version of many functions where we set  m ~ Identity and remove it, does that mean lift :: (a -> b) -> a -> b -- ? :P
18:44:41 * ski grins
18:45:02 <mjrosenb> are there html docs for the git version of sdl2?
18:45:14 <mjrosenb> If not, I guess I'll have to build them locally.
18:46:19 <johnw> shachaf: isn't that what he said when we last discussed it?
18:46:23 <johnw> shachaf: I guess I misread something
18:46:27 <gregnwosu> btcNeverSleeps: sandboxes only deal with things that can be installed via cabal
18:46:47 <gregnwosu> ghc afaik cannot be installed via cabal
18:46:49 <Arahael> kadoban: I mean, I understand the section - but I don't understand the _context_ of that section. Why use (liftM Right .) instead of just 'liftM Right'?
18:47:11 <btcNeverSleeps> gregnwosu: oh I see...
18:47:14 <ski> Arahael : see :
18:47:14 <RobbyG> ski: I don't think we need the vertical and horizontal but I might be wrong
18:47:20 <ski>   eitherPost url args = liftM Right (post url args)
18:47:37 <ski>                       = (liftM Right . post url) args
18:47:47 <ski>   eitherPost url = liftM Right . post url
18:48:00 <kadoban> :t (liftM Right .)
18:48:00 <lambdabot> Monad m => (a -> m a1) -> a -> m (Either a2 a1)
18:48:04 <ski>                  = (liftM Right .) (post url)
18:48:05 <kadoban> :t liftM Right
18:48:06 <lambdabot> Monad m => m a1 -> m (Either a a1)
18:48:12 <ski>                  = ((liftM Right .) . post) url
18:48:19 <johnw> shachaf: what kind of thing is ([Hask,Hask],Day,Identity) then?
18:48:21 <ski>   eitherPost = (liftM Right .) . post
18:49:03 <Arahael> ski: Makes sense, but I"d never make that leap without that assistance.
18:49:04 <ski> Arahael : "intuitively", it's because we're (curriedly) passing on two arguments to `post', not just one
18:49:24 <ski> RobbyG : correct
18:49:33 <ski> RobbyG : .. so, what is left ?
18:49:46 <RobbyG> frame?
18:49:49 <ski> yes
18:49:54 <ski> what is the value of `frame' ?
18:50:12 <ski> what is your current attempt expression above ?
18:52:08 <RobbyG> ski: we want Frame {fname = name, width = 2*w, height = 2*h}     so frame (name,2*w,2*h)
18:53:11 <Arahael> ski: Thanks - I've finally gotten 'eitherPost' implemented, in a way I also understand it, I believe. :)
18:53:48 <ski> RobbyG : almost
18:53:52 <rui> stack space overflow >_>
18:54:16 <ski> RobbyG : again :
18:54:17 <ski> <ski> what is the value of `frame' ?
18:55:14 <RobbyG> frame \(name,w,h)
18:55:27 <RobbyG> without the slash
18:55:44 <ski> no
18:55:54 <ski> i game the value binding for `frame' above
18:55:57 <ski> please recall it
18:56:03 <ski> (s/game/gave/)
18:56:51 <ski> (or i could do that .. but it would probably be better if you correctly understood what i'm asking for)
18:59:11 <RobbyG> ski: frame      = \(fn,w,h) -> Frame {fname = fn, width = 2*w, height = 2*h}
19:03:53 <RobbyG> ski:  was that correct?
19:04:28 <ski> RobbyG : yes
19:04:44 <ski> RobbyG : now note the following
19:04:48 <ski>      frame (name,2*w,2*h)
19:05:08 <ski>   =  (\(fn,w,h) -> Frame {fname = fn, width = 2*w, height = 2*h}) (name,2*w,2*h)
19:05:26 <ski>   =  Frame {fname = name, width = 2*(2*w), height = 2*(2*h)}
19:05:30 <ski> RobbyG : see the problem ?
19:06:14 <RobbyG> ski: yes it is already being doubled so just frame (name,w,h)  ?
19:06:20 <ski> yes
19:07:12 <ski> `doubleSize' indirectly tells `foldFrameDesign' it wants to do some doubling by passing something that doubles as `frame' (a callback, if you wish)
19:07:50 <ski> `foldFrameDesign' itself knows nothing about this doubling
19:08:25 <ski> (which is as it should be, otherwise it would always double in this case, which isn't what `addToSize' would want it to do)
19:09:07 <ski> now, i'd myself rather have made the type signature to be
19:09:15 <ski>   foldFrameDesign :: (String -> Int -> Int -> x) -> ([x] -> x) -> ([x] -> x) -> FrameDesign -> x
19:10:02 <ski> and then instead of `Frame name w h -> frame (name,w,h)', you'd simply had `Frame name w h -> frame name w h', which would look even more aesthetically pleasing
19:10:34 <ski> (note how you essentially "replace" the data constructor `Frame' with the argument that was called `frame' ..)
19:10:42 <ski> RobbyG : makes sense ?
19:11:12 <lpaste> Zemyla pasted “Dumb Term Rewriting for Dynamic Type Equality” at http://lpaste.net/120946
19:11:59 <RobbyG> ski: yes makes sense thank you
19:12:05 <Zemyla> I am not quite sure why I made this, but it's probably stupid and there are more elegant ways to do this sprt of thing automatically.
19:14:00 * hackagebot html-email-validate 0.1.0.0 - Validating an email address against HTML standard  http://hackage.haskell.org/package/html-email-validate-0.1.0.0 (zudov)
19:15:17 <ski> RobbyG : are you familiar how in `foldr cons nil', you similarly essentially replace the list constructors with `nil' and `cons' ?
19:15:51 <RobbyG> ski: kind of, I'm still learning and going through examples with foldr
19:16:21 <ski> > foldr f z [a,b,c,d]
19:16:22 <lambdabot>  f a (f b (f c (f d z)))
19:16:33 <ski> > foldr f z (a : (b : (c : (d : []))))
19:16:35 <lambdabot>  f a (f b (f c (f d z)))
19:16:52 <ski> > foldr f z ((:) a ((:) b ((:) c ((:) d []))))
19:16:54 <lambdabot>  f a (f b (f c (f d z)))
19:18:22 <ski>   foldr cons nil [        ] = nil
19:18:27 <ski>   foldr cons nil ((:) a as) = cons a (foldr cons nil as)
19:19:30 <ski> so, `[]' is replaced by `nil', `(:)' by `cons', and we also need to make a recursive `foldr cons nil' call on the `as' part, to recursively replace all the list-constructors (at the top level list, in case there's lists in the elements) in `as'
19:19:34 <RobbyG> ski: so would this be used for one of the different branches?
19:19:51 <ski> the same pattern reappears for every fold/catamorphism
19:20:20 <ski> (note that `foldl' doesn't fit this pattern. that is a different kind of think. `foldr' is the generic fold for the (right-associated) list type)
19:20:31 <ski> RobbyG : all of them
19:21:02 <ski> <RobbyG> ski: should I be using map?
19:21:03 <ski> <ski> RobbyG : you will need to use `map' (or something similar) at some point .. but not for this branch
19:22:15 <ski> RobbyG : `sumWidth (Horizontal [Frame  {fname = "one", width = 50, height = 5},fname = "two", width = 25, height = 10])' might be a good example to ponder, to figure out the `Horizontal' branch
19:22:39 <RobbyG> ski:  for this branch is there is more that just    Frame name w h -> frame (name,w,h)     how/where do I add foldr?
19:23:00 <ski> RobbyG : "this branch" being ? the `Frame name w h -> ...' branch ?
19:23:20 <RobbyG> ski: Yes
19:23:46 <ski> RobbyG : "how/where do I add foldr?" -- you don't need `foldr' here. `foldr' is the fold/catamorphism for the list type. you're writing `foldFrameDesign', which is the fold/catamorphism for the `FrameDesign' type
19:23:50 <ski> it's an analogy
19:24:45 <ski> your `Frame name w h -> frame (name,w,h)' branch is comparable to the `foldr cons nil [        ] = nil' branch above for `foldr'
19:24:55 <ski> neither is a recursive case
19:24:57 <RobbyG> ski: Oh okay, that's what I was thinking and had me confused because I thought you meant I needed to add foldr too
19:25:04 <ski> the recursive cases are slightly more tricky
19:25:34 <ski> btw, if you wanted to, you could define your `foldFrameDesign' like
19:25:48 <ski>   foldFrameDesign frame horizontal vertical (Frame name w h) = frame (name,w,h)
19:25:54 <RobbyG> For this branch is there a way to test it without getting the Non-exhaustive patterns in case error?
19:25:58 <ski>   foldFrameDesign frame horizontal vertical (Horizontal ...) = ...
19:26:03 <ski>   foldFrameDesign frame horizontal vertical (Vertical ...) = ...
19:26:04 <ski> instead
19:26:10 <ski> (instead of using the `case', i mean)
19:26:17 <ski> it's the same thing, just another style
19:26:24 <ski> sometimes one is nicer, sometimes the other
19:26:31 <ski> (and it's up to personal taste)
19:26:46 <funfunctor> hi
19:27:05 <heatsink> What are test-framework, tasty, and htf good for?
19:27:27 <ski> RobbyG : try `doubleSize (Frame {fname = "one", width = 50, height = 5})' ?
19:27:35 <heatsink> They're intended to be used for running HUnit and QuickCheck tests
19:27:46 <ski> RobbyG : that should work now, if you comment out the branches that aren't done yet
19:28:06 <heatsink> I don't know what extra things they do
19:28:14 <ski> RobbyG : well, you could add a `_ -> undefined' branch at the end, perhaps
19:28:54 <funfunctor> alright I am sort of a little confused with doing dynamic dispatch in haskell
19:29:55 <RobbyG> ski: okay this is working for that case!  And having multiple definitions for the different cases is easier for me to understand but I get them both now thanks to you.
19:30:49 <lpaste> funfunctor pasted “radiodevice” at http://lpaste.net/120947
19:30:51 <geekosaur> funfunctor, if you mean doing different things based on the type, we don't usually. typeclasses provide a (limited by design, for specific purposes) way to do different things with different types, but normally you would wrap things in an ADT and dispatch on the constructor. (data Foo = FString String | FInt Integer | ...)
19:31:21 <lpaste> funfunctor pasted “radiointerface” at http://lpaste.net/120948
19:31:28 <johnw> shachaf: ah, this is what I was thinking of:
19:31:29 <johnw> [03:10:12] <edwardk> Applicatives are monoid objects in ([Hask,Hask],Day,Identity)
19:31:53 <ski> RobbyG : "multiple definitions for the different cases" ?
19:32:13 <edwardk> technically Identity there winds up being (->) ()  -- but it might as well be identity
19:32:19 <geekosaur> typecase works better when you compile to a virtual machine that has typed storage, as opposed to compiling to the CPU which really only knows memory addresses that have no clue what types are
19:32:40 <funfunctor> geekosaur: yea so I am avoiding the anti-pattern of using existential-typeclass
19:32:40 <edwardk> it only matters when you go to find what the contravariant form is, or when you work with other categories and are hunting for the unit
19:32:45 <benzrf> edwardk: hmmm wait what
19:32:54 <RobbyG> ski: instead of using 'case ... of'
19:33:23 <edwardk> see the note on conquer in: http://hackage.haskell.org/package/contravariant-1.2.0.1/docs/Data-Functor-Contravariant-Divisible.html
19:33:29 <edwardk> and why 'lose' is the way it is
19:33:38 <edwardk> both are instances of the same construction, contravariantly
19:33:41 <ski> RobbyG : oh, ok. i suppose i call them "multiple defining equations/clauses"
19:33:51 <funfunctor> geekosaur: see the two pastes, basically I have two types, RadioDevice that abstracts away a module for each hw device and RadioInterface that contains a RadioDevice and calls its functions
19:33:54 <edwardk> its only in the product -> product covariant case that the thing looks like the identity functor
19:34:00 * hackagebot hath 0.2.3 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.2.3 (MichaelOrlitzky)
19:34:05 <RobbyG> okay, I wasnt sure what to call them
19:34:28 <johnw> edwardk: cool, I had called the category a monoid object, level mismatch
19:34:54 <funfunctor> I'm sort of a bit lost as to where constructors go and how to get this abstraction actually working
19:34:55 <johnw> ([Hask,Hask],Day,Identity) is a monoidal category?
19:35:16 <edwardk> the others wind up with conquer taking  (a -> ())     lose taking (a -> Void)      pure taking (() -> a)      and empty taking (Void -> a)  -- the conquer and empty cases are trivial
19:35:24 <ski> funfunctor : next time, consider annotating related pastes on the original paste, instead of making a brand new paste
19:35:33 <ski> RobbyG : np
19:35:36 <benzrf> wait, what is [Hask, Hask]
19:35:40 <edwardk> pure is Identity, lose is the only one that doesn't 'simplify' nicely
19:35:53 <ski> benzrf : a list with two elements, both being `Hask'
19:36:02 <funfunctor> ski: ? these are not based on anything I wrote these late yesterday
19:36:04 <benzrf> ski: ..in this context?
19:36:06 <edwardk> empty and conquer shed their arguments as they are initial/terminal morphisms respectively
19:36:18 <geekosaur> funfunctor, I remember someone was working with you on this but wasn't following closely so I don't know which way they were directing you. but I think if you found yourself trying to do typecase, you may have misunderstood something
19:36:19 <edwardk> pure replaces (() -> )  with Identity
19:36:22 <benzrf> edwardk: what are you using [hask, Hask] to mean
19:36:24 <shachaf> ski: In this case [-,-] is the internal hom functor.
19:36:25 <edwardk> or rather with nothing at all
19:36:35 <edwardk> benzrf: the category of functors from Hask to Hask. Hask^Hask if you will
19:36:37 <ski> benzrf : what shachaf said
19:36:40 <benzrf> aha
19:36:44 <benzrf> ski: i have shachaf on ignore
19:36:48 <ski> ok
19:36:58 <funfunctor> geekosaur: yes I was talking to edwardk about patterns for dynamic dispatch
19:37:10 <edwardk> we're looking at the 'internal hom' of Cat there.
19:37:20 <funfunctor> but there was no code then..
19:37:31 <RobbyG> ski: can you quickly explain what  foldFrameDesign frame horizontal vertical (Horizontal ...) = ... should be before I leave for work? :(Got to hate night shift)
19:37:31 <shachaf> Maybe you get more interesting cases with Chu spaces.
19:37:53 <shachaf> Or Chu(Cat,Set) or something. I don't know.
19:38:10 <funfunctor> geekosaur: so what are you saying I missunderstood?
19:38:11 <ski> RobbyG : in terms of a specific example ? or generally ?
19:38:16 <edwardk> so we have product categories C * D,   coproducts of categories C + D, but we also have exponentials C ^ D    or [D, C] depending on how you want to note it
19:38:26 <ReinH> shachaf: Or, as I like to call it, the sleepy owl functor.
19:38:38 <heatsink> funfunctor: From the field names your using, I think you're designing data types as if they were C++ or Java classes.  Is that what you're trying to do?
19:38:48 <shachaf> Some people use the notation [-,=]
19:38:56 <shachaf> Slightly more alert.
19:39:00 <ReinH> heh
19:39:12 <geekosaur> funfunctor, I... don't actually know what you misunderstood. I just know that nobody would have been leading you in the direction of typecase, so if you ended up there then you got onto the wrong path somewhere
19:39:16 <funfunctor> heatsink: sort of yes and no
19:39:36 <jasonkuhrt> Hi, how would I create an enum type in haskell that allows for a small enum of strings such as "foo" "bar" "zed"
19:39:52 <heatsink> funfunctor: In particular, I see functions like setRxGain that look like Java-ish setters.  That's usually not the right approach in Haskell.  When you do want to have getters and setters, you can't do it this way.
19:39:53 <funfunctor> can I just re-explain what I am /trying/ to do..
19:40:16 <funfunctor> heatsink: oh that is not what this is at all
19:40:20 <heatsink> oh ok
19:40:34 <RobbyG> ski: oh would it be something like   foldFrameDesign frame horizontal vertical (Horizontal f) = (foldFrameDesign (frame, horizontal, vertical, f)
19:40:44 <funfunctor> I want to have multiple hw backends and a common interface to these functions
19:41:42 <heatsink> jasonkuhrt: Probably define an enumerative type, and functions to convert it to/from strings
19:41:58 <ski> RobbyG : `foldFrameDesign' doesn't want a quadruple. `f' is a list of `FrameDesign's -- other than that, you're close
19:42:32 <jasonkuhrt> heatsink: so data Blah = foo | bar | zed
19:43:09 <RobbyG> ski: That's right it takes a triple, correct?
19:43:28 <mauke> jasonkuhrt: constructors must start with an uppercase letter
19:43:37 <jasonkuhrt> mauke: true yeah
19:43:49 <ski> RobbyG : nope
19:43:51 <mauke> data Blah = Foo | Bar | Zed deriving (Read, Show, Eq, Ord, Enum, Bounded)
19:43:54 <ski> RobbyG : `frame' takes a triple
19:44:05 <ski> look at the types
19:44:11 <ski>   foldFrameDesign :: ((String,Int,Int) -> x) -> ([x] -> x) -> ([x] -> x) -> FrameDesign -> x
19:44:28 <funfunctor> alright so I have another module that actually implements the functions in the RadioDevice type. How do I hook them up together so the type is constructed with the backend module embedded within the RadioDevice type?
19:44:37 <ski> only triple type here is in the argument type of the first argument (function) passed to `foldFrameDesign'
19:44:55 <RobbyG> ski: How many does foldFrameDesign take?
19:45:06 <ski> how many what ?
19:46:54 <heatsink> funfunctor: You would create a RadioDevice object containing all the functions
19:46:59 <funfunctor> is it "bad" to write custom type constructor functions?
19:47:16 <ski> RobbyG : i suggest you meditate on the `sumWidth (Horizontal [Frame  {fname = "one", width = 50, height = 5},fname = "two", width = 25, height = 10])' example, similar to how we did for the `doubleSize (Frame {fname = "one", width = 50, height = 5})' one to figure out the `Frame' case above
19:47:24 <RobbyG> ski: does it take arguments seperated with spaces?
19:47:47 <funfunctor> heatsink: something like constructRD = return $ RadioDevice { .. ?
19:48:46 <heatsink> funfunctor: fooRadioDevice = RadioDevice fooSetVCTCXOValue ...
19:49:01 <heatsink> barRadioDevice = RadioDevice barSetVCTCXOValue ...
19:49:01 * hackagebot buffer-builder-aeson 0.2.0.0 - Serialize Aeson values with Data.BufferBuilder  http://hackage.haskell.org/package/buffer-builder-aeson-0.2.0.0 (afriesen)
19:49:19 <ski> RobbyG : every function in Haskell always takes exactly one argument
19:49:19 <funfunctor> yea I really don't see how this is going to work? I want *multiple* hw backends to be abstracted into one known agnostic interface for the rest of the stack
19:49:48 <heatsink> funfunctor: The rest of the stack takes the implementation as a parameter
19:50:12 <funfunctor> heatsink: how do you mean? sorry can you come up with a simple workable example
19:50:37 <heatsink> funfunctor: Suppose you have different communication channels: sockets, files, pipes
19:50:46 <ski> RobbyG : there's two main ways to simulate "multiple arguments" : (a) tupled style, you pass a single tuple argument which contains as components the "multiple arguments"; (b) curried style, you pass the "first argument" as the argument, and you get another function returned, which you pass the "next argument" to, and so on, until you get the "final result"
19:51:04 <heatsink> funfunctor: they all have an implementation of send, with signature String -> IO (), and an implementation of recv, with signature IO String
19:51:18 <funfunctor> heatsink: ok
19:51:28 <heatsink> funfunctor: Now, you want to write a function that can send and receive to any of these communication channels
19:51:28 <ski> RobbyG : `foldFrameDesign' is defined in curried style, and so, it "curriedly" takes four arguments. `frame' otoh is in tupled style, and so takes a triple containing three parts
19:51:56 <heatsink> funfunctor: You can define a common interface, data CommChannel = CommChannel {send :: String -> IO (), recv :: IO String}
19:51:57 <ski> RobbyG : `foldFrameDesign frame horizontal vertical design' is the same as `(((foldFrameDesign frame) horizontal) vertical) design'
19:52:29 <ski> RobbyG : the latter shows more clearly how one argument at a time is passed, and the resulting function applied to the next argument
19:52:41 <heatsink> funfunctor: You can turn any of the communication channels into a CommChannel by putting its send and receive methods into a CommChannel value.
19:53:22 <ski> RobbyG : makes sense ?
19:53:29 <heatsink> funfunctor: To write a function that does IO to any kind of communication channel, have the function take a CommChannel as an argument
19:53:40 <funfunctor> heatsink: alright but how does that last bit work..
19:53:49 <heatsink> funfunctor: sendSomeData channel = send channel "Hello"
19:53:56 <RobbyG> ski: yes that clears up a lot actually
19:54:47 <heatsink> funfunctor: Do you see how the CommChannel is a common interface to different channels, so that 'sendSomeData' can send to any kind of channel?
19:54:53 <funfunctor> heatsink: ah but I don't want anything above RadioDevice to know anything about the specific device at all
19:55:02 <RobbyG> ski: Im still not any closer unfortunately...
19:55:33 <funfunctor> heatsink: yes its common in the sense of a type signature but not abstract enough to not know anything at all about the channel
19:55:49 <RobbyG> with the sumWidth one
19:55:50 <heatsink> funfunctor: How does 'sendSomeData' know something about the specific type of channel it's sending to?
19:55:51 <ski> RobbyG : sorry, i goofed up the example slightly above. it should be `sumWidth (Horizontal [Frame {fname = "one",width = 50,height = 5},Frame {fname = "two",width = 25,height = 10])'
19:56:07 <heatsink> funfunctor: Can it tell whether it is sending to a socket or a file?
19:56:28 <ski> RobbyG : so, the first step is to rewrite this using the (known) definition of `sumWidth'
19:56:41 <funfunctor> heatsink: whats the type signature of sendSomeData ?
19:56:51 <heatsink> funfunctor: CommChannel -> IO ()
19:57:03 <ski> RobbyG : next, using the partial definition of `foldFrameDesign', especially taking note here of the bindings you have to play with, so to speak
19:57:49 <ski> RobbyG : you need to invent a complete pattern to match on for the `Horizontal' case (it should be as general as possible, handling every `FrameDesign' constructed via the `Horizontal' data constructor)
19:57:50 <funfunctor> heatsink: right so we need to construct a CommChannel with a specific channel backend in mind and pass it around when we want to pipe down that channel
19:57:59 <heatsink> yes
19:58:20 <ski> RobbyG : where does this lead you ?
19:59:12 <funfunctor> heatsink: alright but when happens when we create multiple backends we have multiple CommChannel instances
19:59:14 <RobbyG> ski: foldFrameDesign frame horizontal vertical (Horizontal f) = ...
19:59:22 <ski> sounds fine
19:59:25 <ski> what's the type of `f' ?
19:59:46 <cfoch> hello
19:59:55 <cfoch> what do you understand by
20:00:05 <cfoch> "fromJust. It is not a total function."
20:00:18 <RobbyG> ski: f is a list of Frames
20:00:22 <cfoch> https://github.com/cfoch/cabal/commit/c35b17ec6a0c2a1ffbb6c0233b4e09cde1fc670f#commitcomment-9857574
20:00:24 <benzrf> cfoch: are you asking what that means?
20:00:25 <ski> `fromJust' is a partial function, not defined for all (total) inputs
20:00:30 <funfunctor> heatsink: each instance is going to have a different name, how are we going to manage all these instances floating about
20:00:49 <ski> > [fromJust x | x <- [Just 3,Just 4,Nothing,Just 7]]
20:00:51 <lambdabot>  [3,4,*Exception: Maybe.fromJust: Nothing
20:01:04 <ski> RobbyG : yes
20:01:16 <heatsink> funfunctor: How will the user of the program control which backend is used?  With command line flags?
20:01:27 <RobbyG> ski: loop through the list using recursion?
20:01:41 <ski> RobbyG : *would* be possible
20:01:49 <funfunctor> heatsink: they don't, it is whatever is available, i.e. what hw is found
20:01:54 <RobbyG> ski: is there an easier way?
20:02:03 <ski> <RobbyG> ski: should I be using map?
20:02:03 <ski> <ski> RobbyG : you will need to use `map' (or something similar) at some point .. but not for this branch
20:02:42 <heatsink> funfunctor: Ok, so there will be code to find the available hardware and create the corresponding CommChannel
20:02:48 <funfunctor> heatsink: I guess RadioInterface should be Applicative in structure?
20:03:22 <funfunctor> heatsink: or monadic worst case
20:03:28 <heatsink> funfunctor: Perhaps the code goes through a list of them, checking availability for each, and returns the first available.
20:03:46 <funfunctor> heatsink: I thought about that, sounds horrible
20:03:48 <RobbyG> ski: okay we use the map here.     map foldFrameDesign f
20:03:52 <RobbyG> ?
20:03:56 <ski> good start
20:04:05 <ski> you need to fix the `foldFrameDesign' part
20:04:55 <funfunctor> heatsink: I think i'm reasoning about this all wrong, RadioDevice and RadioInterface should be a monadic stack?
20:04:58 <ski> `map' wants a function that accepts a `FrameDesign' (as first curried argument). `foldFrameDesign' wants a `(String,Int,Int) -> x' (as first curried argument)
20:05:04 <ski> these doesn't match
20:05:15 <ab9rf> i want curry
20:05:28 <ski> you could e.g. start to say `map (\childDesign -> ...) f'
20:05:49 <ski> where `...' may now also use `childDesign' (and will probably also involve `foldFrameDesign')
20:06:10 <heatsink> funfunctor: I don't see how monads would solve the problem.  I'm still trying to understand what problem you are describing.
20:06:15 <ski> `\childDesign -> ...' means : the function that when given a design, call it `childDesign', will return `...'
20:06:36 <ski> RobbyG : understand ?
20:06:47 <ab9rf> monads never solve problems.  rather, many of the things that do solve problems turn out to also be monads :)
20:07:02 <RobbyG> ski: maybe, like this?  map (\childDesign -> frame) f
20:07:29 <ski> then you don't use `childDesign' at all -- which is probably not what you want to
20:07:37 <RobbyG> ski: nevermind not right
20:07:47 <ski> presumably you want to take into account the actual contents of each list element here
20:08:18 <ski> you want to process each child design by the same function, so a recursive call is needed
20:08:33 <funfunctor> heatsink: essentially what I want is RadioInterface is encapsulate RadioDevice and some other stuff where RadioDevice encapsulates fooRadioDevice
20:09:13 <RobbyG> ski:   map (\childDesign -> foldFrameDesign ...) f
20:09:54 <ski> yes
20:10:04 <ski> now, what should `...' be here ?
20:10:14 <ski> what to pass as (curried) arguments to `foldFrameDesign' ?
20:10:28 <RobbyG> ski: childDesign?
20:10:39 <heatsink> funfunctor: I described a way to encapsulate the implementation of an interface, using a data type containing functions.  What is bad about that approach for your purpose?
20:10:40 <ab9rf> childDesign is the only thing in scope
20:10:42 <ski> yes .. but not as first argument (wrong type)
20:11:05 <hiptobecubic> Why doesn't Data.IntMap track it's current size? It seems odd to have `size m` be O(n) when we know how many elements we put in and take out every time.
20:11:08 <hiptobecubic> its*
20:11:42 <ski> RobbyG : what's the type of the first argument of `foldFrameDesign' ? what are the types of the local variables in the definition of `foldFrameDesign' ? which of them fits ?
20:12:02 <ski> (that might have been a too obvious way to state it)
20:12:04 <funfunctor> heatsink: we wind up with fooRadioDevice barRadioDevice and so on we have to enumerate though in the construction of RadioInterface before we start making calls to the functions in RadioDevice inside RadioInterface
20:12:18 <RobbyG> ski:   map (\childDesign -> foldFrameDesign frame horizontal vertical childDesign) f
20:12:40 <ski> RobbyG : good. now what's the type of this whole expression ?
20:12:47 <heatsink> funfunctor: The program doesn't have to enumerate through them
20:13:03 <heatsink> funfunctor: The program does have to decide what implementation to use
20:13:31 <ski> RobbyG : also, it's possible to simplify this expression slightly (can you see it ?)
20:13:33 <RobbyG> ski: FrameDesign?
20:13:34 <funfunctor> heatsink: i'm either very confused about something I am missing or I really need to see a full example how this is going to work for my use case/context
20:13:38 <ski> RobbyG : nope
20:13:57 <ski> RobbyG : in general, if `f :: A -> B' and `as :: [A]', then `map f as :: [B]'
20:14:14 <ski> RobbyG : in this case, what's the type of `f' ?
20:14:17 <funfunctor> heatsink: to decide we have to enumerate
20:14:23 <funfunctor> on construction
20:14:31 <ski> RobbyG : what's the type of `\childDesign -> foldFrameDesign frame horizontal vertical childDesign' ?
20:15:02 <ski> (RobbyG : sorry, two different `f's, one in my "in general" case, another one in your case. please don't mix up)
20:15:13 * ski ought to have said `map g as' or something
20:15:19 <heatsink> funfunctor: Why is it necessary to enumerate?
20:15:34 <RobbyG> ski: okay yes that did confuse me for a second.
20:15:57 <funfunctor> heatsink: the way I understand it, its a mess
20:16:06 <heatsink> What's a mess?
20:16:20 <gcganley> is there anyone that has read "Category Theory by Steve Awodey"
20:16:20 <ski> RobbyG : so, what's the type of your `f' ?
20:16:54 <gcganley> i have a question about notation
20:16:58 <funfunctor> heatsink: its too value driven.. I realize values are easy to work with but complexity gets the better of you.. Have a value for each device and needing to pass it around is a mess for trying to abstract that away
20:17:32 <RobbyG> ski: I'm not exactly sure, a little lost
20:17:37 <funfunctor> heatsink: the entire point of RadioDevice is so that I can just call the functions and not care about anything else, including what implementation happens to be doing the lifting
20:17:39 <ReinH> gcganley: Probably a few of us.
20:18:06 <funfunctor> heatsink: hence I think monadic now, i.e. I picture RadioDevice as a IO action
20:18:12 <heatsink> funfunctor: Would you care if some of the function calls go to one implementation, and some go to another implementation?
20:18:22 <ski> RobbyG : ok. recall
20:18:25 <ski> <RobbyG> ski: foldFrameDesign frame horizontal vertical (Horizontal f) = ...
20:18:33 <heatsink> If you don't want that to happen, then you _do_ care what implementation happens to be doign the lifting
20:18:33 <funfunctor> heatsink: in this case no
20:18:38 <ski> RobbyG : what's the type of `Horizontal f' here ?
20:18:50 <ReinH> gcganley: what's the question?
20:19:01 <ski> (you should be able to read this directly off the type signature for `foldFrameDesign')
20:19:15 <RobbyG> ski: ([x]->x)
20:19:22 <ski> no
20:19:24 <ski> try again
20:21:06 <ski> RobbyG : shall i ?
20:21:10 <RobbyG> ski: ((String,Int,Int) -> x)  = frame        ([x] -> x) = horizontal      ([x] -> x) = vertical    WindowLayout = (Horizontal f)  ?
20:21:30 <RobbyG> ski: is that correct up to that point?
20:21:32 <heatsink> funfunctor: I think you're trying to say that the user should not have to pass around the interface explicitly
20:21:38 <ski> yes, except i'd flip the order and say `::' instead of `=', like `frame :: (String,Int,Int) -> x', and so on
20:21:47 <funfunctor> heatsink: yes
20:21:58 <ski> RobbyG : also, not `WindowLayout', but `FrameDesign'
20:22:31 <heatsink> funfunctor: After an implementation is chosen, will it be used for all calls?
20:22:40 <ski> RobbyG : so we know `Horizontal f :: WindowLayout'. what does that tell us about the type of `f' itself ?
20:22:47 <gcganley> ReinH: yeah in the first section there is a part where he uses >= but it has a subscript 'A
20:22:51 <ski> (hint : recall the type of `Horizontal')
20:22:55 <RobbyG> ski: whoops wrong example.
20:23:01 <gcganley> ReinH: i have no idea what that means
20:23:02 <ReinH> gcganley: Do you have a page number?
20:23:08 <gcganley> ReinH: one sec
20:23:37 <gcganley> ReinH: pg 6, half way down
20:24:10 <ReinH> gcganley: Ah, I see. The subscript indicates that <= is a binary op on A.
20:24:27 <gcganley> ReinH: interesting...
20:24:47 <ReinH> You see later <=_A and <=_B for the lte op on A and B, respectively
20:24:49 <gcganley> ReinH: i recently bought the book off of amazon and its my first real math book
20:25:21 <ReinH> e.g., m : A -> B is monotone of a <=_A a' implies m(a) <=_B m(a')
20:25:23 <RobbyG> ski: is it a Frame?
20:25:30 <shachaf> I like Tom Leinster's _Basic Category Theory_.
20:25:33 <funfunctor> heatsink: correct!
20:25:35 <ReinH> in other words, if a is lte a' in A then m(a) is lte m(a') in B
20:25:46 <ReinH> shachaf: Oh that's out now isn't it
20:25:48 <funfunctor> heatsink: that would be sutiable here
20:26:01 <shachaf> It's been out for a while.
20:26:02 <ReinH> *monotone if*
20:26:06 <ReinH> gcganley: does that make sense?
20:26:09 <ReinH> shachaf: Cool, I guess I'm a bit slow
20:26:17 <ReinH> shachaf: I saw a ToC a while back and it looked good.
20:26:26 <gcganley> ReinH: yeah i stubled through it but it helps a lot
20:27:02 <ddellacosta> what is the implementation of Data.Array.IArray based on?
20:27:10 <ReinH> gcganley: A and B are sets. Each has a relation <=, so you have both <=_A (the <= on members of A) and <=_B (the <= on members of B)
20:27:20 <shachaf> @quote TomLeinster
20:27:21 <lambdabot> TomLeinster says: In subjects such as number theory and combinatorics, some questions are simple to state but extremely hard to answer. Basic category theory is not like that. To understand the question is very nearly to know the answer.
20:27:27 <heatsink> funfunctor: You could put the code that passes the implementation around inside a monad
20:27:38 <RobbyG> ski: Horizontal f :: FrameDesign    so would f be a Frame?
20:27:48 <funfunctor> heatsink: something like StateT ?
20:27:54 <heatsink> like Reader
20:27:57 <gcganley> ReinH: yeah i just need to keep refering back to a wiki page on the notation because i still have trouble with the unicode char for things like `elem`
20:28:24 <funfunctor> heatsink: can you show me how all this fits together please with some stubbed types?
20:28:27 <ski> RobbyG : what's a `Frame' ?
20:28:53 * ski sees no mention of a type named `Frame' at <http://lpaste.net/120940>
20:29:10 <lf94> could someone explain this type to me? Either String (Vector (Text, Int))
20:29:24 <lf94> So Left is a String or Right is a Vector?
20:29:32 <Rotaerk> yar
20:29:35 <RobbyG> ski: from  data FrameDesign = Frame {fname :: String, width :: Int, height :: Int}
20:29:35 <ski> lf94 : either a string, or a vector containing pairs of texts and ints
20:29:56 <ski> RobbyG : that `Frame' is not a type, so not relevant here
20:30:03 <lf94> ski: why does vector have () around it
20:30:04 <lf94> why not
20:30:13 <lf94> Either String Vector (Text, Int)
20:30:15 <ski> lf94 : because `Either' wants two arguments
20:30:21 <lf94> ah!
20:30:23 <lf94> I see
20:30:26 <lf94> Thanks X)
20:30:33 <ski> `Either String (Vector (Text, Int))' means `(Either String) (Vector (Text, Int))', which is right
20:30:35 <lf94> Could you do...
20:30:47 <lf94> Either String $ Vector (Text, Int) ?
20:31:02 <lf94> or something
20:31:04 <ski> `Either String Vector (Text, Int)' would mean `((Either String) Vector) (Text, Int)', which is wrong (kind-incorrect)
20:31:05 <lf94> something to avoid the ()
20:31:12 <ski> lf94 : no `$' at the type-level
20:31:16 <lf94> mmmm
20:31:18 <ski> brackets are nothing to fear
20:31:23 <lf94> Alright :)
20:31:32 <RobbyG> ski: what is type f?
20:31:34 <ski> @kind Either
20:31:35 <lambdabot> * -> * -> *
20:31:44 <gcganley> lf94: yeah there is no kind/type level ($)
20:31:55 <heatsink> @let genericOutputer = do {formatOutput <- get; formatOutput "hello")
20:31:55 <lambdabot>  Parse failed: Parse error: )
20:32:00 <heatsink> @let genericOutputer = do {formatOutput <- get; formatOutput "hello"}
20:32:01 <lambdabot>  Defined.
20:32:13 <heatsink> > runReader (return . parens) genericOutputer
20:32:14 <lambdabot>  Couldn't match type ‘Text.PrettyPrint.HughesPJ.Doc
20:32:14 <lambdabot>                       -> m0 Text.PrettyPrint.HughesPJ.Doc’
20:32:14 <lambdabot>                with ‘Control.Monad.Trans.Reader.ReaderT
20:32:21 <gcganley> wat
20:32:30 <ski> RobbyG : in the definition of `FrameDesign', we see that the data constructor `Horizontal' takes a `[FrameDesign]' to build a `FrameDesign' (therefore `Horizontal :: [FrameDesign] -> FrameDesign')
20:32:34 <gcganley> @type genericOutputer
20:32:34 <heatsink> > runReader genericOutputer (return . parens)
20:32:35 <lambdabot> MonadState ([Char] -> m b) m => m b
20:32:36 <lambdabot>  No instance for (GHC.Show.Show a0)
20:32:36 <lambdabot>    arising from a use of ‘M779694556401099652926163.show_M7796945564010996529...
20:32:36 <lambdabot>  The type variable ‘a0’ is ambiguous
20:32:49 <gcganley> @info MonadState
20:32:49 <lambdabot> MonadState
20:32:53 <gcganley> damn
20:33:01 <ski> RobbyG : in `Horizontal f :: FrameDesign', it has already built the resulting `FrameDesign', so therefore the argument `f' to it must have had type `[FrameDesign]'
20:33:09 <ski> RobbyG : therefore, we now know `f :: [FrameDesign]'
20:33:12 <monochrom> there is no @info. it is auto-corrected to @undo
20:33:31 <heatsink> Oh, I mistyped my example
20:33:31 <ReinH> monochrom: haha
20:33:35 <ski> RobbyG : ok ?
20:33:39 <heatsink> @let genericOutputer = do {formatOutput <- get; formatOutput (text "hello")}
20:33:40 <lambdabot>  .L.hs:156:1:
20:33:40 <lambdabot>      Multiple declarations of ‘genericOutputer’
20:33:40 <lambdabot>      Declared at: .L.hs:153:1
20:33:44 <RobbyG> ski: okay I follow
20:33:46 <heatsink> @undefine genericOutputer
20:33:46 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
20:34:04 <monochrom> do it! undefined everything!
20:34:08 <ski> RobbyG : now, back to `map (\childDesign -> foldFrameDesign frame horizontal vertical childDesign) f'
20:34:21 <heatsink> @restartcomputer
20:34:21 <lambdabot> Unknown command, try @list
20:34:24 <heatsink> @undefine
20:34:24 <lambdabot> Undefined.
20:34:32 <heatsink> @let genericOutputer = do {formatOutput <- get; formatOutput (text "hello")}
20:34:33 <lambdabot>  Defined.
20:34:42 <heatsink> > runReader genericOutputer (return . parens)
20:34:43 <lambdabot>  No instance for (GHC.Show.Show a0)
20:34:43 <lambdabot>    arising from a use of ‘M202346194056106547226214.show_M2023461940561065472...
20:34:43 <lambdabot>  The type variable ‘a0’ is ambiguous
20:34:44 <gcganley> is this an OK place to ask about cat theory or should i ask in a math channel?
20:35:08 <ski> gcganley : you could try here, or ##math, or ##categorytheory
20:35:20 <funfunctor> heatsink: don't worry I sort of get what your trying to do there..
20:35:24 <heatsink> > runState genericOutputer (return . parens)
20:35:25 <lambdabot>  No instance for (Control.Monad.State.Class.MonadState
20:35:25 <lambdabot>                     (Text.PrettyPrint.HughesPJ.Doc
20:35:25 <lambdabot>                      -> Control.Monad.Trans.State.Lazy.StateT
20:35:32 <gcganley> ski: i just wanted to make sure with an op it was cool
20:36:00 <ddellacosta> gcganley: not an op but my impression is that folks never mind, it definitely seems on topic
20:36:14 * ski glances around to check whether there's any ops nearby ..
20:36:30 <monochrom> I recommend asking in all 3 channels so you maximize the chance of getting 3 conflicting answers
20:36:30 <ski> (.. i can see at least one)
20:36:33 <heatsink> funfunctor: ok
20:37:10 <funfunctor> heatsink: I still have many questions how this actually fits together but i'll try write some more code and see if anything comes together..
20:37:17 <gcganley> johnw: you online?
20:37:29 <johnw> gcganley: I am, but I'm stepping away and will be back in an hour
20:37:33 <johnw> please ping me then
20:37:43 <gcganley> johnw: i'll be asleep ;-;
20:37:54 <heatsink> funfunctor: It is still passing the implementation around within the monad.  Each function would delegate to the interface.
20:37:55 <ski> RobbyG : it's currently a bit noisy in here. perhaps we should consider moving to #haskell-overflow ?
20:38:15 <gcganley> is there a way to leave a note for someone?
20:38:25 <ski> @help tell
20:38:25 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
20:38:40 <RobbyG> ski:  Yes we can if you want to. Are we close?     map (\childDesign -> foldFrameDesign frame horizontal vertical childDesign) f
20:38:46 <ski> /msg MemoServ send <nick> <message>
20:40:09 <funfunctor> heatsink: I get the concept just fine, init a state into reader, have interface functions ask reader for backend hw implementation value to work with..
20:40:25 <gcganley> is ther any use for Posets in haskell?
20:42:21 <Javran> can I use hsenv to compile ghc?
20:43:04 <carter> Javran: ... you can just configure the build to use a selected ghc
20:43:17 <carter> Javran: ./configure --help should list the applicable flags
20:43:57 <heatsink> Is it worth using a test framework on top of HUnit and QuickCheck?
20:44:23 <heatsink> There are some packages for that but I don't know what they are for
20:44:38 <funfunctor> be back a bit later
20:44:42 <ReinH> gcganley: A variety of uses, yeah
20:44:44 <funfunctor> thanks for the help heatsink
20:44:49 <heatsink> you're welcome
20:45:47 <Javran> carter: I see
20:45:55 <carter> Javran: do you see it
20:45:56 <carter> ?
20:46:09 <Javran> --with-gcc=ARG ?
20:46:45 <carter> no
20:46:48 <carter> thaats G C C
20:46:50 <ttt_fff> is it possible to have hoogle (running on localhost:8080) to oint at LOCAL docs ... rather than remote docs?
20:46:58 <Javran> oops sorry
20:47:03 <ttt_fff> sometimes I'm offline (i.e. on train / bus, and I'd liek to be able to use local hoogle)
20:47:04 <carter> Javran: what ghc are you trying to build
20:47:08 <carter> and why are you trying to build it
20:47:13 <carter> and why cant you use your default ghcc
20:47:47 <Javran> carter: just try to build the latest version, for fun maybe
20:47:53 <carter> sure
20:47:59 <carter> why are you trying to use hsenv though
20:48:24 <carter> Javran: why can't you just ./perl boot ; ./configure ; make
20:48:26 <xnil____4> i keep getting confused when i see `carter'; i'm the only person i know named carter so it's a bit of a shock
20:48:36 <gcganley> ReinH: it says f has type A -> B but then it says f is a subtype of (A x B)... its makes no sense... i dont get how a function can have that type but still be a subnet of (A,B)
20:48:41 <Javran> carter: because I'm getting errors
20:48:51 <carter> Javran: @lpaste them
20:48:53 <gcganley> ReinH: pg 7 half way down
20:48:57 <Javran> carter: http://lpaste.net/3557611047244267520
20:49:03 <carter> xnil____4: tough, i've been active in haskell land for a decade
20:49:04 <carter> :P
20:49:06 <gcganley> ReinH: maybe this book is too advanced for me :/
20:49:08 <Javran> not sure how to deal with it
20:49:24 <ReinH> gcganley: You might try Lawvere's _Conceptual Mathematics_
20:49:27 <carter> Javran: dont use hsenv
20:49:36 <carter> have you tried that? :)
20:50:03 <carter> Javran: how'd you do the clone?
20:50:21 <ReinH> gcganley: That's describing the category Rel of sets and binary relations. Do you know what a binary relation is?
20:50:27 <carter> git clone --recursive git://git.haskell.org/ghc.git ; cd ghc ; perl boot ; ./configure ; make
20:50:28 <carter> should work
20:50:37 <carter> if you want a perf build of head
20:50:47 <gcganley> ReinH: rein I've I
20:50:51 <gcganley> shit
20:51:00 <Javran> carter: I don't have alex local installed so I guess hsenv would be safer.. ok I'll try to compile it without hsenv
20:51:09 <carter> Javran: cabal install happy alex
20:51:12 <carter> bam
20:51:13 <carter> :)
20:51:26 <carter> cabal update ; cabal install happy alex
20:51:32 <Javran> I like to keep then in sandbox though :(
20:51:41 <carter> no
20:51:42 <carter> sorry
20:51:43 <Javran> or I have to nuke .ghc occasionally
20:51:45 <gcganley> ReinH: rein I'm 17, the highest math knowlage i have is calc 1. all of these terms are new to me. other than some cat theory things ive picked up on while using haskell like (.) and what a functor is
20:51:47 <carter> nuking is ok
20:52:00 <carter> Javran: alex and happy are just binaries though
20:52:03 <benzrf> gcganley: haha sucker im 18 now
20:52:07 <carter>  as long asyou never nuck ~/.cabal
20:52:10 <carter> they live on
20:52:12 <ReinH> gcganley: You should try Lawvere.
20:52:13 <gcganley> benzrf: DAMN IT
20:52:21 <carter> just put `~/.cabal/bin in your path
20:52:51 <gcganley> ReinH: actually i opened it in my ibooks and it jumped to pg 26, ive cracked it open before
20:52:53 <gcganley> lol
20:53:08 <Javran> carter: ok
20:53:41 <shachaf> gcganley: When you're learning from a math book, it's OK (and standard) to take your time with it. You should work through each definition, not expect to understand it immediately.
20:54:07 <shachaf> You might need to look things up, read back to earlier parts of the book, think of examples yourself, and so on.
20:54:31 <gcganley> shachaf: these are the hardest 10 pages I've ever dealt with to be honest
20:54:39 <ReinH> gcganley: A binary relation on A is a subset of A * A. In haskell terms, a relation on a is a subset of (a,a). You can model this as type Rel a = (a,a) -> Bool, i.e. a function that determines whether the pair is in the subset.
20:54:49 <shachaf> <gcganley> ReinH: i recently bought the book off of amazon and its my first real math book
20:54:59 <shachaf> Why would you expect otherwise in that case? :-)
20:55:42 <ReinH> gcganley: A binary relation from A to B is, similarly, a subset of A * B. In Haskell terms, type Rel a b = (a,b) -> True is a function that determines whether the pair is in the subset or not.
20:55:52 <gcganley> shachaf: oh i completely expected it would cause many headaches but i know that in the end it will be worth it
20:56:03 <shachaf> I still recommend Leinster's book.
20:56:25 <shachaf> Though maybe not as your "first real math book". I don't know.
20:56:56 <gcganley> ReinH: that makes a lot more sense with the haskell definition to be honest. maybe i just need to get used to this math notation
20:57:07 <Javran> carter: thanks for the help, I'm compiling, so far so good :)
20:57:10 <darkroom> when i try to install the spacepart package using cabal it fails when trying to install the vector-space package with errors talking about not in scope type constructor "HasTrie" does anyone know why this happens?
20:57:19 <gcganley> shachaf: i like a challenge
20:57:36 <carter> Javran: mind you, theres ways to make the build faster
20:57:41 <ReinH> gcganley: (You'll sometimes see it written as type Rel a b :: a -> b -> True, this is the same thing curried.)
20:57:52 <carter> Javran: cp  mk/build.mk.sample mk/build.mk
20:58:02 <carter> then edit mk/build.mk to be a quick build
20:58:08 <carter> Javran: then also you can eg, do
20:58:13 <carter> make -jN
20:58:15 <shachaf> ReinH: That's a reasonable way to define relations but if your goal is functions as a subset of relations, it's pretty awful in the context of Haskell.
20:58:16 <carter> where n= # of cores
20:58:38 <gcganley> ReinH: how could you view (,) as (->)...
20:58:54 <gcganley> if Rel a b :: (a -> b) -> True
20:59:02 <ReinH> shachaf: True enough. I was just going for a straightforward interpretation
20:59:05 * hackagebot network-attoparsec 0.11.2 - Utility functions for running a parser against a socket  http://hackage.haskell.org/package/network-attoparsec-0.11.2 (solatis)
20:59:14 <Javran> carter: yeah, I'm using that, just following what ghc wiki says
20:59:26 <shachaf> I don't think thinking about Haskell is very helpful for that definition.
20:59:45 <shachaf> It's the topic of this channel, though, I guess.
20:59:55 <benzrf> ReinH: -> True?
21:00:04 <gcganley> shachaf: should i just learn the math notation instead of trying to relate it to haskell?
21:00:10 <ReinH> benzrf: yes
21:00:42 <ReinH> benzrf: You need to determine whether that particular pair is in the subset or not
21:00:54 <shachaf> Haskell is a good source for intuition, but not the only source. It only matches set theory somewhat well.
21:00:54 <gcganley> benzrf: do you go to the meetups in boston much
21:00:57 <ReinH> since a relation from A to B is *a subset* of A * B
21:02:05 <benzrf> gcganley: only ocasionaly
21:02:28 <benzrf> ReinH: i dont understand..
21:02:36 <benzrf> ReinH: is True the 1-inhabitant set here
21:02:46 <ReinH> benzrf: Eh?
21:02:59 <benzrf> ReinH: when you say -> True here, do you mean 1-element
21:03:07 <ReinH> No, I mean (a,b) -> True
21:03:19 <ReinH> Some members of (a,b) will be in the relaiton.
21:03:21 <ReinH> Some will not.
21:03:31 <shachaf> ReinH: People are objecting to "True" vs. "Bool"
21:03:36 <ReinH> Uh.
21:03:39 <ReinH> Oh.
21:03:42 * ReinH facepalms
21:03:46 <ReinH> (a,b) -> Bool
21:03:48 <ReinH> Sorry I'm an idiot.
21:05:05 <dolio> Also don't call it Bool. :)
21:05:16 <ReinH> dolio: why?
21:05:22 <gcganley> ReinH: are you tired? lol
21:05:26 <ReinH> gcganley: I guess so.
21:05:32 <dolio> Because not all logics are Boolean.
21:05:38 <gcganley> benzrf: good morning
21:05:55 <benzrf> mrn
21:06:04 <benzrf> ReinH: th a n k
21:06:05 <gcganley> good morning to everyone on the east coast
21:06:09 <benzrf> i was confused for a minute there :(
21:06:17 <ReinH> benzrf: Understandable :(
21:06:23 <benzrf> ReinH: (a -> b) -> True?
21:06:24 <benzrf> really
21:06:28 <ReinH> benzrf: Sorry.
21:06:31 <benzrf> what a boring type :D
21:06:38 <benzrf> only one inhabitant smh
21:07:30 <gcganley> type True = True
21:08:02 <stephenmac7> @undo do a <- (*2); b <- (+10); return (a+b)
21:08:02 <lambdabot> (* 2) >>= \ a -> (+ 10) >>= \ b -> return (a + b)
21:09:04 <mniip> is there something that is like a sequel to LYAH?
21:09:28 <stephenmac7> mniip: if only...
21:09:28 <gcganley> mniip: one step up in complexity or on the same rung?
21:09:45 <ReinH> shachaf: I guess a more Haskell-friendly model would be something like data Rel a b = Rel (Map a (Set b)) (Map b (Set a)) with smart constructors that enforce the invariants.
21:09:59 <Javran> carter: so I guess the compilation is done, but where is the binary? doesn't seem to have a "ghc/inplace/bin/"
21:10:07 <lf94> So, I have a tuple with 42 elements. How do I index the 39th one?
21:10:08 <carter> Javran: ....
21:10:20 <carter> Javran: dont you mean inplace/bin
21:10:22 <carter> you're already in ghc
21:10:34 <mniip> gcganley, well I know like 3 fundamental typeclasses from lyah, functor applicative and monad
21:10:41 <mniip> there are obviously more things to learn than those
21:10:44 <Cale> lf94: ;____; why do you have a tuple with that many elements?
21:10:47 <ReinH> @where typeclassopedia
21:10:47 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
21:10:53 <ReinH> mniip: ^
21:10:56 <lf94> Because of Data.Csv
21:10:59 <mniip> ooo
21:11:01 <mniip> fancy
21:11:13 <lf94> Cale: my csv has 42 columns
21:11:17 <Javran> carter: now I feel stupid XD
21:11:26 <Cale> lf94: The only remotely sensible case I can imagine that occurring involves code generation, in which case, you should just generate a lambda term for indexing the appropriate component
21:11:32 <ReinH> benzrf: I think I'm going to play some video games and give my brain a rest. It obviously needs it...
21:11:44 <benzrf> ReinH: hehehe
21:11:53 <gcganley> mniip: i would say the typeclassopedia
21:11:59 <mniip> cool
21:12:00 <Cale> lf94: That doesn't mean that you have to use tuples!
21:12:00 <mniip> am reading
21:12:16 <lf94> Cale: Either String (Vector (my columns))
21:12:22 <Javran> carter: yeah it's working, thanks for the help!
21:12:23 <ReinH> Cale: liftA42 MyRecord? ;)
21:12:28 <lf94> Cale: under "usage example": https://hackage.haskell.org/package/cassava-0.4.2.1/docs/Data-Csv.html
21:12:54 <nshepperd> I might be confused, but it seems like hblas has its matrix coordinates mixed up
21:13:00 <Cale> lf94: right, you're likely to use tuples if your CSV has 2 or maybe 3 columns
21:13:01 <carter> numberten: you've gotten coq setup right?
21:13:47 <Cale> lf94: If it has more, you're going to want to write instances of FromRecord/ToRecord and/or FromNamedRecord/ToNamedRecord
21:13:52 <lf94> Cale: ok so I'm going to use (Vector Vector) then?...
21:14:11 <lf94> ah
21:14:12 <Cale> and use something that's not a tuple to represent the records
21:14:47 <nshepperd> but no-one noticed because all example matrix code uses square matrices >_>
21:14:47 <lf94> Well this is lame
21:14:52 <lf94> Data.Csv you have failed me
21:15:01 <Cale> Why?
21:15:21 <lf94> Cale I think I'm better off using Text.CSV
21:15:22 <Cale> It provides combinators which make writing those instances not so bad
21:15:52 <ReinH> lf94: That seems unlikely
21:15:57 <Cale> Well, maybe, if all your data are strings or something
21:16:32 <lf94> Cale: most are
21:16:44 <lf94> There is just one field that has currency data in it that I want
21:16:47 <ReinH> Text.CSV hasn't been updated since 2010
21:17:04 <ReinH> And has only ever been updated twice: once in 2007 and once in 2010.
21:17:33 <Cale> ReinH: Well, that doesn't mean much, I wouldn't expect it to need to change all that often given what it does
21:18:34 <ReinH> Text.CSV parses things into [[String]].
21:18:44 <Cale> right
21:18:53 <ReinH> I guess if that's all you need.
21:18:54 <Cale> Which might be enough! :)
21:18:56 <Cale> yeah
21:19:07 <Cale> But yeah, I don't think you need to give up on cassava
21:19:27 <Cale> It's actually probably pretty convenient for what you're after
21:19:57 <Cale> lf94: If you can show me an example CSV and tell me what data you want to extract, I can write you an instance to get you started
21:20:21 <lf94> I'd rather figure it out myself ^^
21:20:26 <lf94> Thank you though
21:20:36 <lf94> and this is a little sensitive...it is my own financial data
21:21:06 <lf94> Cale: Is there a haskell lib that parses currencies?
21:21:09 <lf94> like
21:21:17 <lf94> 1,076.02 is a string
21:21:23 <lf94> and converts to a Rational
21:21:24 <lf94> ?
21:21:49 <Cale> I think you're looking for Data.Fixed
21:22:02 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.2/Data-Fixed.html
21:22:18 <Cale> In particular, the Centi type
21:22:40 <lf94> Why fixed?
21:22:59 <Cale> Well, you're representing an exact integer number of pennies, right?
21:23:39 <lf94> This CSV is, correct
21:23:53 <lf94> What is wrong with me using more precision?
21:23:59 <lf94> Just less efficient?
21:24:57 <EvanR> its more appropriate for the situation
21:25:01 <Cale> Well, I guess you can use Double or something if you really want, but it's not necessarily "more precision" in every case. Floating point is weird.
21:25:04 <EvanR> you dont ever get 1/3 of a dollar
21:25:10 <lf94> Right
21:25:20 <lf94> Yeah I found what I was looking for, readFloat
21:25:29 <lf94> But Data.Fixed, like you said, seems more appropriate
21:25:33 <EvanR> but you also never get 1/10 of a float
21:25:38 <EvanR> so float is wrong
21:25:47 <lf94> Is there a readFixed function?
21:25:57 <Cale> Just use the Read instance
21:25:58 <Cale> reads
21:26:03 <lf94> oh
21:26:07 <EvanR> > read "1.234" :: Centi
21:26:08 <lambdabot>  1.23
21:26:17 <lf94> haskell is so genius
21:26:23 <Cale> > reads "1.234" :: [(Centi,String)]
21:26:25 <lambdabot>  [(1.23,"")]
21:26:27 <lf94> How does the complier read that line
21:26:32 <lf94> Type first?
21:27:06 <monochrom> it's of the form <expr>::<type>
21:27:12 <Jeanne-Kamikaze> when you read cvs instead of csv and you shiver
21:28:50 <mniip> is it possible to limit instances imported from a module
21:29:23 <lf94> monochrom: i mean like, does the compile see the reads function, then determines how to covert based on the type?
21:29:36 <monochrom> no, you import, you get them all, no escape.
21:29:40 <lf94> I don't see a Read instance for Data.Fixed here
21:30:01 <EvanR> the Fixed types are Centi Milli Micro and so on
21:30:09 <monochrom> the reads function calls some method of the Read class for parsing
21:30:11 <lf94> oh derp
21:30:23 <monochrom> so every time gets a different parser
21:30:25 <lf94> HasResolution a => Read (Fixed a)
21:30:33 <monochrom> err, every type gets a different parser
21:30:48 <lf94> Shouldn't Data.Fixed implement its own parser?
21:31:15 <EvanR> lf94: click the source link and youll see the implementation of Read for those types
21:31:29 <lf94> Oh, ok
21:32:14 <ReinH> You can also tag your currency with a phantom currency type so that (100 :: Yen) + (100 :: Dollar) is a type error, but probably you're doing everything in a single currency.
21:32:20 <lf94> Ah I see
21:32:21 <lf94> I see the magic
21:32:43 <EvanR> i see the sufficiently advanced technology
21:32:46 <lf94> Those source links are extremely helpful
21:32:47 <ReinH> ha
21:32:56 <lf94> Should be pointed out more
21:33:14 <ReinH> (I should say USDollar or use ISO currency codes, I guess)
21:33:34 <EvanR> USD
21:33:46 <EvanR> thats what bitcoiners call it ;)
21:34:37 <EvanR> good old abraham lincolns
21:35:11 <monochrom> lincoins? that's a great name
21:37:00 <EvanR> its unfortunately been materialized as several things...
21:37:05 <EvanR> apparently
21:44:06 * hackagebot html5-entity 0.2.0.2 - A library for looking up and validating HTML5 entities.  http://hackage.haskell.org/package/html5-entity-0.2.0.2 (zudov)
21:46:20 <mniip> 4. Give an example of a type of kind * -> * which cannot be made an instance of Functor (without using undefined).
21:46:31 <mniip> is 'data NotFunctor a = NotFunctor (a -> ())' good enough?
21:46:44 <monochrom> I think so
21:47:28 <monochrom> maybe not. make it a->Bool or something.
21:48:10 <mniip> ⊥ is an inhabitant of () too :P
21:48:28 <mniip> there are plenty of 'a -> ()' functions
21:48:41 <monochrom> I guess.
21:49:11 <haasn> mniip: I count three
21:49:21 <pacak> mniip: Plenty? Give me five?
21:49:33 <pacak> const () -- one
21:49:38 <pacak> undefined -- two
21:49:54 <pacak> And that's about it I think.
21:49:54 <monochrom> I think it's pretty clear that we do not mean "forall a. a->()"
21:49:58 <mniip> yeah
21:49:59 <haasn> pacak: const undefined -- three
21:50:02 <haasn> oh
21:50:13 <mniip> f . (\x -> if x then undefined else ())
21:50:18 <mniip> where f is any a -> Bool
21:50:19 <monochrom> instead, we mean, for example, the type NotFunctor Int, i.e., Int->()
21:50:34 <pacak> haasn: Nice one, yes.
21:50:40 <mniip> oops that's abckwards
21:50:44 <shachaf> For clarity I would use any type other than ()
21:50:50 <mniip> yeah ok
21:50:55 <mniip> data NotFunctor a = NotFunctor (a -> a)
21:52:15 <mniip> "The composition of two Functors is also a Functor." - I'm not sure I understand the terminology here
21:52:38 <haasn> In Haskell terms, that would be Comp f g a = Comp (f (g a))
21:52:38 <HeladoDeBrownie> data Compose f g x = Compose (f (g x))
21:52:41 <mniip> 'composition of Maybe and Either' is pretty meaningless
21:52:45 <mniip> ah
21:52:48 <HeladoDeBrownie> Either is not a Functor.
21:52:48 <shachaf> Either isn't a functor.
21:52:49 <HeladoDeBrownie> Either e is.
21:52:59 <HeladoDeBrownie> (for any e)
21:53:03 <numberten> carter: yeah I have
21:53:07 <mniip> yeah of course
21:53:10 <numberten> carter: really late response :)
21:53:12 <carter> numberten: nvm, got it working
21:53:15 <haasn> unctor composition is a thing in category theory
21:53:17 <haasn> functor*
21:53:27 <monochrom> you should compose Maybe with IO, of course :)
21:53:40 <shachaf> Compose IO with String to obtain IO String.
21:53:54 <HeladoDeBrownie> shachaf, wat
21:54:02 <shachaf> Hmm, that's not a helpful thing to say when people are actually confused about what compose means.
21:54:04 <mniip> shachaf, that sounds more like 'apply'
21:54:11 <mniip> but yeah I get what is implied now
21:54:22 <mniip> type-analogy of (.)
21:54:26 <HeladoDeBrownie> yep.
21:54:59 <haasn> mniip: String = [] Char
21:55:03 <mniip> ah
21:55:11 <mniip> no wait
21:55:12 <mabino-pyon> Can -XDeriveFunctor derive the Functor instance for Compose?
21:55:17 <haasn> No, that still doesn't make sense to me
21:55:18 <mniip> String is a concrete type
21:55:33 <mniip> composing IO with [] makes sense
21:55:42 <shachaf> Yes, String = [] Char is just application.
21:55:50 <mniip> so is 'IO String'
21:56:30 <EvanR> IO String = IO String
21:56:57 <mniip> EvanR, woah
21:57:00 <mniip> I didn;t know that
21:57:03 <HeladoDeBrownie> mabino-pyon, yes.
21:57:13 <shachaf> Yes. What I said was a joke inspired by http://www.vex.net/~trebla/photo/unorganized/IO-String.png
21:57:56 <mniip> I don't get it..
21:58:03 <shachaf> It's OK, it wasn't a good joke.
21:58:16 <EvanR> whats the angle in the bottom right
21:58:17 <mniip> where's (,) come from
21:58:23 <mabino-pyon> HeladoDeBrownie: Whoa, that's cool... Deriving a Functor instance that depends on other Functor instances. :-P
21:58:30 <monochrom> pull-back or push-out, I forgot whcih
21:58:31 <EvanR> besides 90
21:59:21 <lf94> What does the ! mean? data Person = Person { name :: !Text, age :: !Int }
21:59:36 <benzrf> lf94: strictness annotation
21:59:43 <benzrf> lf94: the Person constructor is strict in its arguments
22:00:44 <lf94> I don't understand isn't Haskell always strict
22:00:50 <mniip> no?
22:00:53 <mniip> on the contrary
22:01:00 <EvanR> haskell is a non-strict purely functional language
22:01:09 <lf94> Isn't haskell strict when you give things types
22:01:22 <lf94> hm
22:01:28 <lf94> i guess !Text is actually giving something a type
22:01:28 <platz> how do people feel about io-streams?  too simplistic? convienient?
22:01:42 <EvanR> too complex
22:01:48 <lf94> everything else, just a temporary "tag"
22:01:51 <lf94> temprorary type
22:01:52 <HeladoDeBrownie> lf94, if a function f is strict in its argument, that means that f _|_ = _|_. this is not always the case in haskell (and is not, by default)
22:01:54 <lf94> whatever
22:01:59 <LordBrain> lf94, strict as in eagerly evaluated, as opposed to lazy
22:02:06 <HeladoDeBrownie> well, many things are strict just by their form. e.g., id x = x
22:02:23 <lf94> Ok, second question
22:02:24 <lf94>  m .: "age"
22:02:25 <EvanR> lf94: heh, its worth being more precise about these things, and studying more to understand all the implications
22:02:27 <lf94> Whit is .: ?
22:02:29 <lf94> What*
22:02:37 <lf94> EvanR: gotchya
22:02:37 <platz> hrmm, more complex than transformers amd mult-type param abstractions?
22:03:03 <lf94> What is .: guys
22:03:05 <HeladoDeBrownie> by default, all data constructors are non-strict.
22:03:08 <EvanR> (.) . (.)
22:03:13 <lf94> Oh nevermind
22:03:13 <LordBrain> its a lens thing
22:03:20 <platz> it's limited, of course
22:03:21 <HeladoDeBrownie> you have to explicitly define them to be strict, as in that example.
22:03:30 <HeladoDeBrownie> (the one you gave)
22:03:48 <lf94> Why do people use <$> ?
22:03:54 <lf94> Instead of ($) or something
22:03:59 <HeladoDeBrownie> lf94, sometimes fmap looks better infix.
22:03:59 <EvanR> instead `fmap`
22:04:04 <lf94> oh
22:04:07 <LordBrain> <$> is fmap, $ is just application
22:04:08 <HeladoDeBrownie> lf94:  (<$>) is not ($), it's merely analogous to it in some sense.
22:04:14 <lf94> My bad
22:04:35 <platz> haskell people really don't like typing characters
22:04:41 <LordBrain> lol
22:05:03 <lf94> Person <$> m .: "name" <*> m .: "age"
22:05:07 <platz> if they can save 1 char thar is a total win
22:05:14 <lf94> extract name from record m, as well as age
22:05:18 <platz> so much effort
22:05:37 <heatsink> It's more about avoiding parentheses
22:05:42 <EvanR> [MickeyMouse, SonicTheHedgeHog, HelloKitty] :: [Char]
22:05:52 <lf94> heatsink: yeah I see that
22:05:52 <LordBrain> well fmap is common enough that its not really a big deal to have an operator version i think
22:06:19 <platz> of course I agree
22:06:24 <lf94> so what is fmap doing here
22:06:32 <EvanR> :t fmap
22:06:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:06:34 <lf94> applying the constructor (Person) ?
22:06:58 <LordBrain> yeah
22:07:00 <HeladoDeBrownie> lf94, what is it doing where?
22:07:01 <EvanR> alternatively Functor f => (a -> b) -> (f a -> f b)
22:07:06 <platz> at least n+k patterns died
22:07:14 <lf94> Person <$> m .: "name" <*> m .: "age"
22:07:15 <lf94> There
22:07:18 <lf94> @ HeladoDeBrownie
22:07:25 <HeladoDeBrownie> lf94, ah missed your line
22:08:14 <lf94> Cale was right
22:08:23 <lf94> Cale, Data.Csv > Text.CSV
22:08:24 <lf94> B)
22:08:37 <HeladoDeBrownie> to put it one way, it's lifting Person into the type being used (i don't know what type that is) so that it can be applied to other values in that type.
22:08:38 <lf94> Implementing FromNamedRecord is the way to go
22:09:05 <lf94> HeladoDeBrownie, https://hackage.haskell.org/package/cassava-0.4.2.1/docs/Data-Csv.html#t:FromNamedRecord
22:09:15 <HeladoDeBrownie> this is a pretty imprecise way of putting it but i hope it serves your intuition.
22:09:42 <lf94> The type being used is...Person?
22:09:50 <lf94> So I'm still confused
22:09:51 <lf94> X)
22:10:01 <EvanR> no, whatever m .: "name" is returning
22:10:09 <lf94> oh
22:10:09 <Rotaerk> Parser a
22:11:09 <HeladoDeBrownie> Person is a value (specifically a data constructor), not a type.
22:11:19 <HeladoDeBrownie> (also specifically a function)
22:11:25 <lf94> sorry >_<
22:11:38 <HeladoDeBrownie> you don't need to apologize, i'm just clarifying.
22:11:44 <HeladoDeBrownie> (or i hope that's what i'm doing. :)
22:11:50 <lf94> so fmap Person (type returned from m .: "whatever") ?
22:12:15 <lf94> What about the other m .: ""
22:12:18 <HeladoDeBrownie> fmap Person gets applied to a value rather than a type.
22:12:49 <HeladoDeBrownie> this is one of the intermediate expressions: Person <$> m .: "name"
22:13:28 <HeladoDeBrownie> that whole thing evaluates to some value, whose type in this case is Parser applied to some function type.
22:13:35 <HeladoDeBrownie> Parser (… -> …)
22:14:08 <HeladoDeBrownie> we use that as an argument to (<*>), along with m .: "age", to result finally in Parser Person.
22:14:13 <HeladoDeBrownie> oh, i can fill in one of the blanks i left.
22:14:34 <HeladoDeBrownie> the type of that thing i mentioned as an intermediate expression is Parser (… -> Person)
22:14:37 <HeladoDeBrownie> i don't know what … is.
22:14:46 <HeladoDeBrownie> i haven't traced through the types that far.
22:14:50 <HeladoDeBrownie> the compiler knows what it is, presumably.
22:15:38 <HeladoDeBrownie> does this make sense?
22:15:43 <HeladoDeBrownie> ask for clarification where needed.
22:17:43 <EvanR> lf94: tackle one thing at a time, first expressions of the form f <$> x, then f <$> x <*> y, then f .: x, then all of it together
22:17:46 <EvanR> follow the types
22:18:08 <HeladoDeBrownie> yes, knowing the types is crucial in haskell.
22:18:08 <EvanR> > (+1) <$> [1,2,3]
22:18:09 <lambdabot>  [2,3,4]
22:18:33 <EvanR> and look at examples in ghci ;)
22:19:42 <HeladoDeBrownie> one of the problems here is you're tackling not only function application, but type unification, infix operators, infix precedence, fixity, applicative idioms…
22:21:42 <HeladoDeBrownie> don't go looking all that up at once, by the way, you'll probably end up more confused and chasing rainbows
22:22:05 <lf94> Sorry guys, had to go hang laundry
22:22:08 <lf94> Reading now
22:23:05 <lf94> alright, I was unaware Person <$> m .: "name" was actually a sensible type
22:23:08 <monochrom> shapr learned haskell by riding a unicycle to chase the rainbow
22:23:13 <EvanR> its not a type
22:23:31 <lf94> (Person <$> m .: "name") :: NoType
22:23:32 <lf94> X)
22:23:41 <lf94> Ok that is joke
22:23:41 <HeladoDeBrownie> lf94, do you mind if we try to tackle a similar problem instead for a moment?
22:23:43 <monochrom> it had to be unicycle because it was the closest thing to unicorn
22:23:46 <lf94> But I know it isn't a type
22:23:54 <lf94> Not at all!
22:23:56 <lf94> Educate me :)
22:24:36 <HeladoDeBrownie> lf94, okay; i'm going to ask you to take my word for now that this evaluates to the same thing as the expression under discussion: liftA2 Person (m .: "name") (m .: "age")
22:24:45 <shachaf> I think #haskell-overflow may be a better channel for this.
22:24:55 <HeladoDeBrownie> shachaf, okay. lf94, shall we go there?
22:25:12 <lf94> Sure :)
22:33:18 <johnw> no
22:33:21 <johnw> (sorry)
22:33:25 <johnw> (wrong window)
22:34:08 * hackagebot template-haskell-util 0.1.0.0 - Some utilities for template Haskell.  http://hackage.haskell.org/package/template-haskell-util-0.1.0.0 (songzh)
22:44:11 <Lokathor> might there be a way to have cabal or ghc tell me the number of errors there are when there are errors?
22:47:51 <jle`> const is so long. i'll start aliasing it to k
22:48:39 <jle`> or maybe i'll just use `\_->`
22:48:51 <jle`> the forward-sliding-chair operator
22:48:58 <jle`> (\_->)
22:49:23 <jle`> :t let foo = \_-> "slide that chair" in foo 10
22:49:24 <lambdabot> [Char]
22:50:38 <dulla> > map (const "\\_ ->") [1..7]
22:50:40 <lambdabot>  ["\\_ ->","\\_ ->","\\_ ->","\\_ ->","\\_ ->","\\_ ->","\\_ ->"]
22:51:01 <dulla> > map (const "\_ ->") [1..7]
22:51:02 <lambdabot>  <hint>:1:14:
22:51:02 <lambdabot>      lexical error in string/character literal at character '_'
22:54:06 <monochrom> \_-> is more keystrokes than const
22:54:35 <shachaf> const requires a space
22:56:30 <jle`> :t \_->4
22:56:31 <lambdabot> Num a => t -> a
22:57:40 <lf94> #haskell is the best teacher
22:57:56 <jle`> i'm going to add it to my other shorthands, like io for liftIO, l0 for pure, l1 for fmap, l2 l3 l4 etc. for liftA2 liftA3 etc.
22:58:47 <jle`> if i call const k then i might as well call ap s but ap is already short as it is
22:59:37 <rola> woah, you can you let..in in :type
22:59:45 <mniip> jle`, ApKId calculus? :P
22:59:56 <jle`> rola: yes, because let .. in .. is an expression :)
23:03:47 <orzo> i have some timing code i wrote using STM, but it's clear to me that I could trivially eliminate STM by replacing an TMVar with an MVar.  Would it benifit me to do taht?
23:05:39 <voidzero> are MVars thread safe?
23:05:44 <monochrom> yes
23:06:02 <voidzero> then I'd say the proof of the pudding is in the eating
23:07:02 <monochrom> if your only use of STM is "atomically (one single putTMVar)" and "atomically (one single takeTMVar)", then you can change to MVar.
23:07:31 <orzo> yes, that's my situtation
23:07:57 <orzo> and MVar is cheaper and so i should go ahead?
23:08:14 <monochrom> STM becomes non-boring only when you start doing "atomically (do some queries, update several variables)"
23:09:10 <monochrom> I have not really measured which is cheaper
23:11:55 <Lokathor> how do you make an IO () function "return early" like you do in a C style language
23:12:11 <cmccann> I'm pretty sure an MVar is cheaper than a TMVar, the question is by how much
23:12:31 <orzo> i went ahead an dmade the change
23:14:17 <orzo> Lokathor: you could use callCC, which is probably mainly useful for translating C style code
23:14:41 <Lokathor> that is, i have some data and want to do processing with it if it's correct, and if it's not i want to just break out early
23:14:53 <solatis> is there an opposite of Data.Text.splitOn ? As in, say I have an [Data.Text] with ["1", "2", "3"], convert it to Data.Text "1.2.3"
23:14:53 <jle`> Lokathor: you could also use MaybeT
23:15:06 <jle`> solatis: intercalate i think? or intersperce
23:15:14 <jle`> one or the other, i always forget which does what
23:15:27 <Lokathor> intercalate is what you want probably
23:15:37 <solatis> jle`, intersperse!
23:15:38 <shachaf> cmccann: It depends on the trademark fees.
23:15:40 <Lokathor> T.intercalate "." ["1","2","3"]
23:15:45 <solatis> first time in my life i heard that
23:15:53 <jle`> :t intersperse
23:15:54 <lambdabot> a -> [a] -> [a]
23:16:02 <solatis> > T.intersperse '.' ["1", "2", "3"]
23:16:03 <Lokathor> :t intercalate
23:16:05 <lambdabot> [a] -> [[a]] -> [a]
23:16:06 <lambdabot>  No
23:16:18 <solatis> no?
23:16:21 <solatis> well that's nice
23:16:21 <jle`> haha
23:16:25 <Lokathor> > T.intercalate "." ["1","2","3"]
23:16:26 <lambdabot>  Not in scope: ‘T.intercalate’
23:16:27 <lambdabot>  Perhaps you meant one of these:
23:16:27 <lambdabot>    ‘BS.intercalate’ (imported from Data.ByteString),
23:16:37 <Lokathor> > BS.intercalate "." ["1","2","3"]
23:16:38 <lambdabot>  Couldn't match expected type ‘Data.ByteString.Internal.ByteString’
23:16:38 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
23:16:38 <lambdabot>              with actual type ‘[GHC.Types.Char]’Couldn't match expected type ...
23:16:44 <shachaf> It would be great to have a non-trade version of ™. Just a mark.
23:16:48 <Lokathor> wow lambdabot
23:17:09 <shachaf> Please use lambdabot in /msg unless you have something to show the channel.
23:17:16 <solatis> yeah sorry
23:17:17 <shachaf> Errors are very verbose.
23:17:26 <shachaf> lambdabot errorsᴹ
23:17:45 <jle`> trademark variable vs mark variable
23:17:55 <Lokathor> i was attemptint to show the channel, but apparently lambdabot does not have the imports i was expecting
23:18:19 <shachaf> Right. Better to test first, especially after the first time.
23:18:21 <orzo> you mean OverloadedStrings
23:18:51 <Lokathor> that too orzo
23:19:04 <solatis> yeah
23:19:11 <solatis> maybe the real problem here is lambdabot
23:19:34 <solatis> when it generates an error, it could be an idea to PM the person generating the error
23:19:41 <solatis> that would solve a *lot* of noise
23:20:12 <voidzero> If people don't abuse the bot, the errors can be useful
23:20:12 <orzo> if you make your fonts really small, there's hardly any
23:20:15 <solatis> since humans will always remain the weakest link, and remain (ab)using this
23:20:27 <solatis> voidzero, the problem is people
23:20:29 <voidzero> hey! humans are cool man.
23:20:45 <voidzero> in my opinion.*
23:20:54 <solatis> and you will always have people that are annoyed by other people
23:21:12 <solatis> best to make it a special flag if you want lambdabot to puke any errors in the main channel
23:21:28 <solatis> just my 2 cents
23:21:37 <Lokathor> i mean 3 lines doesn't seem excessively verbose
23:21:45 <Lokathor> i looked away just now and more than 3 lines were said before i looked back
23:22:09 <solatis> i know, but i think everyone in this channel has a natural hatred towards ghc errors
23:22:13 <solatis> :)
23:22:17 <orzo> joins and parts are more noise than lambdabot
23:22:19 <Lokathor> probably
23:22:26 <voidzero> nah, hate costs too much energy.
23:22:36 <Lokathor> so i don't think I can use a MaybeT in my situation
23:22:46 <solatis> orzo, you are able to configure that in your irc client -- lambdabot is either an "ignore lambdabot altogether, or live with the noise"
23:22:49 <solatis> *anyway*
23:23:04 <solatis> maybe i'll open an issue for this on the lambdabot github
23:23:07 <Lokathor> i've got a function of type PendingConnection -> IO () that I pass to the websocket server runner thing, but that's a library call so i can't just switch around the type there
23:23:13 <solatis> and continue the discussion there
23:23:14 <orzo> Lokathor: i think its better code to avoid something like callCC if you can
23:23:19 <jle`> Lokathor: can you put an example
23:24:19 <xkb> ReinH: thanks for the pointers on my parser problem. Looks way better now.
23:24:27 <Lokathor> ah, well, hmm
23:25:36 <gfixler> I'm missing something about how GHCi handles: module Foo (foo,bar) where
23:25:51 <Lokathor> i'm not sure i can provide a very concise example >_>
23:25:58 <gfixler> if I also have a baz in there, it's visible when I load it into GHCi
23:26:20 <gfixler> I've been looking through things online relating to imports and :load, but I'm not finding this answer
23:26:27 <Lokathor> gfixler, i think ghci cheats compared to ghc
23:27:35 <gfixler> Lokathor: does the export list only make sense when the module is imported into other modules?
23:27:45 <Lokathor> yeah
23:27:54 <gfixler> hmmm - any way around that?
23:28:08 <gfixler> it's not a big deal, but I felt like I was going crazy not being able to hide things from GHCi
23:28:57 <Lokathor> that's the sense i got with it when i had this sort of problem the other day. I made a fake Main.hs that imported just the things I wanted, then only loaded that
23:29:04 <Lokathor> and i think it kinda worked out how i wanted
23:30:20 <xkb> gfixler: why do you want to hide stuff from ghci?
23:30:22 <gfixler> that seems to work, although :browse doesn't show any of the function names now
23:30:49 <voidzero> you could do ':m + Data.List' and 'let llast = Data.List.last'
23:30:50 <gfixler> xkb: in part just feel like things were correct, in part to have a better sense through :browse what I've hidden
23:31:23 <gfixler> I get that not hiding things from GHCi makes it a lot easier to play with everything
23:31:25 <xkb> Ah. I also use the main approach Lokathor mentions
23:31:29 <Lokathor> xkb, in my case i was writing my own and/or functions for chip simulations, and got name clashings
23:31:54 <gfixler> xkb: do you reexport from Main?
23:32:15 <xkb> Hmm no
23:32:46 <xkb> Never tried that
23:33:13 <gfixler> hmmm, it didn't help - ghci Main.hs -> :browse -> shows nothing
23:33:31 <Lokathor> yikes, i didn't even know :browse was a thing
23:33:40 <mniip> any tips on how to prove
23:33:41 <mniip> pure f <*> x = pure (flip ($)) <*> x <*> pure f
23:34:00 <gfixler> xkb: it works if I reexport the functions individually again in Main.hs
23:34:19 <gfixler> I thought module Main (module Main) where would reexport things
23:34:25 <xkb> That's a load of work.
23:34:26 <gfixler> Lokathor: I keep finding things, too
23:34:30 <gfixler> xkb: yeah, I don't want to do that
23:34:42 <xkb> Also quite error prone
23:34:48 <gfixler> oh, I solved it
23:34:58 <gfixler> more like, I finally properly remembered what I stumbled on awhile back
23:35:09 <gfixler> module Main ( module Foo ) where
23:35:13 <gfixler> import Foo
23:35:33 <gfixler> that will reexport from Main what Foo exports - sweet
23:36:12 <xkb> Nice! No idea you could do that
23:36:24 <gfixler> so now I can ghci Main.hs to get the hiding, or ghci Foo.hs to play with everything
23:38:05 <benzrf> xkb: how often do you get pinged in gnu/linux channels
23:38:08 <gfixler> I should clarify - :browse *doesn't* show non-exports, but they're still there and available via ghci Foo.hs
23:44:40 <funfunctor> hi
23:44:56 <funfunctor> anyone happen to know about dealing with time in haskell?
23:45:15 <orzo> getCurrentTime
23:45:22 <orzo> yw
23:45:24 <funfunctor> the eval of gettimeofday()
23:45:34 <funfunctor> s/eval/equiv/
23:45:43 <funfunctor> :t getCurrentTime
23:45:44 <lambdabot> Not in scope: ‘getCurrentTime’
23:45:56 <orzo> Data.Time.Clock
23:46:14 <funfunctor> orzo: is that the datetime package?
23:46:20 <EvanR> time
23:46:32 <EvanR> its included in base i think
23:46:49 <EvanR> getCurrentTime :: IO UTCTime
23:47:17 <orzo> funfunctor: https://www.haskell.org/hoogle/ is a good resource
23:47:42 <EvanR> https://github.com/evanrinehart/time-diagram
23:47:50 <funfunctor> I want to do the equiv of this: gettimeofday(&currTime,NULL); double timeElapsed = (currTime.tv_sec - startTime.tv_sec)*1e6 + (currTime.tv_usec - startTime.tv_usec);
23:48:31 <EvanR> use diffUTCTime
23:48:48 <EvanR> and have startTime :: UTCTime ready
23:48:49 <orzo> did you work on that diagram since i saw it last
23:48:59 <EvanR> not really
23:49:16 <funfunctor> EvanR: good diagram!
23:49:19 <orzo> i remember one with hexagons and circles
23:49:33 <EvanR> oh yeah, that was really old, i immediately redid it
23:50:28 <peddie> haha, EvanR, I have code that works with orbital mechanics; that diagram is like twice as big when you have to deal with TAI and UT1 in Julian days etc.
23:50:40 <EvanR> heh
23:50:45 <peddie> humans aren't actually that good at time, it turns out :)
23:50:50 <lpaste> mniip pasted “pure f <*> x = pure (flip ($)) <*> x <*> pure f” at http://lpaste.net/3296066836205928448
23:50:58 <mniip> does this seem like a decent proof
23:52:20 <EvanR> peddie: TAI is in 1-to-1 correspondence with AbsoluteTime? and the JD plus fraction is universal time at longitude 0 ?
23:52:24 <orzo> your new diagram should go into the haddock
23:53:02 <EvanR> youre not doing relativity are you ;)
23:53:03 <peddie> EvanR: actually, yeah, TAI should be the same as AbsoluteTime
23:53:10 <wagle> @hoogle [a, b] -> (a,b)
23:53:11 <peddie> not in this code :)
23:53:12 <lambdabot> Parse error:
23:53:12 <lambdabot>   [a, b] -> (a,b)
23:53:12 <lambdabot>     ^
23:53:33 <wagle> d'uh
23:53:43 <EvanR> peddie: it seems silly to call UT ... universal time lol
23:53:56 <peddie> but UT1 is a celestial time, so if the earth's orbit wibbles a bit, time changes . . .
23:54:22 <peddie> s/orbit/rotation/
23:54:26 <EvanR> right UT has the Day number included
23:54:32 <EvanR> and the fraction is the rotation
23:54:44 <EvanR> they have little to do with "time" ;)
23:54:50 <mniip> wagle, are you looking for a function that turns a list of 2 elements into a 2-tuple?
23:54:58 <wagle> @hoogle [a] -> (a,b)
23:54:58 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
23:54:58 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
23:54:58 <lambdabot> Control.Monad.Trans.RWS.Lazy execRWS :: RWS r w s a -> r -> s -> (s, w)
23:55:12 <peddie> TDB is the other one, which I think does have a gravitational correction
23:55:15 <jle`> where would the b come from...?
23:55:18 <wagle> mniip: yeah
23:55:23 <EvanR> peddie: i meant to indicate that AbsoluteTime as a type represents a time... DiffTime from TAI 0 would be .. TAI ;)
23:55:26 <mniip> wagle, no such predefined function
23:55:35 <wagle> yeah
23:55:35 <mniip> but you can easily make one
23:55:37 <wagle> 8)
23:55:40 <wagle> sure
23:55:46 <mniip> also its type would be [a] -> (a,a)
23:55:53 <jle`> :t \(x:y:_) -> (x,y)
23:55:54 <lambdabot> [t] -> (t, t)
23:55:56 <wagle> was about to, but thought i'd double check
23:56:00 <EvanR> peddie: im glad the library makes a distinction between points in time and time diffs
23:56:15 <peddie> EvanR: yeah, that confused me at first, but I've come to appreciate it a lot
23:56:23 <funfunctor> EvanR where is startTime defined?
23:56:35 <mniip> jle`, pfft
23:56:36 <mniip> (,) <$> head <*> head . tail
23:56:37 <EvanR> funfunctor: you have to get it at the start?
23:56:43 <EvanR> its up to you
23:57:10 <funfunctor> EvanR: oh you mean startTime isn't part of time package?
23:57:18 <mniip> > (,) <$> head <*> head . tail $ "hello"
23:57:19 <lambdabot>  ('h','e')
23:57:25 <EvanR> funfunctor: start time of what? you are the one who used it first
23:58:18 <peddie> funfunctor: if you want to measure an interval of time, use getCurrentTime at the beginning and the end of the interval and compute the length of the interval using diffUTCTime
23:58:26 <funfunctor> EvanR: ok so getCurrentTime and put that in my StateT monad?
23:58:36 <EvanR> or a Reader, or just pass it around
23:58:38 <funfunctor> peddie: ok thx
23:58:44 <funfunctor> wonderful thanks
23:58:51 <jle`> :t (\xs -> do (x:y:_) <- xs; Just (x,y))
23:58:52 <lambdabot> Maybe [t] -> Maybe (t, t)
23:58:57 <jle`> :t (\xs -> do (x:y:_) <- Just xs; Just (x,y))
23:58:58 <lambdabot> [t] -> Maybe (t, t)
23:59:04 <jle`> now with safety :D
23:59:47 <jle`> :t (,) <$> listToMaybe <*> (listToMaybe . drop 1)
23:59:48 <lambdabot> [a] -> (Maybe a, Maybe a)
23:59:59 <jle`> :t liftA2 (,) <$> listToMaybe <*> (listToMaybe . drop 1)
